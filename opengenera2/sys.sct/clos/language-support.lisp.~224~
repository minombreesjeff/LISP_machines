;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

(DEFMACRO DEFSTRUCT-SIMPLE (NAME-AND-OPTIONS &BODY REST)
  #+(OR Genera CLOE-Runtime) `(LISP:DEFSTRUCT ,NAME-AND-OPTIONS ,@REST)
  #+Minima `(DEFSTRUCT ,NAME-AND-OPTIONS ,@REST)
  #-(OR Genera CLOE-Runtime Minima) (ERROR "Simple defstruct must be supplied."))

#+CLOE-Runtime
(DEFMACRO DECLAIM (&REST DECLARATIONS)
  `(PROGN ,@(MAPCAR #'(LAMBDA (DECLARATION) `(PROCLAIM ',DECLARATION)) DECLARATIONS)))

#+CLOE-Runtime
(DEFMACRO DEFINE-SETF-EXPANDER (NAME LAMBDA-LIST &BODY BODY)
  `(DEFINE-SETF-METHOD ,NAME ,LAMBDA-LIST ,@BODY))

#+CLOE-Runtime
(DEFUN GET-SETF-EXPANSION (&REST ARGS)
  (DECLARE (DYNAMIC-EXTENT ARGS))
  (APPLY #'GET-SETF-METHOD-MULTIPLE-VALUE ARGS))

#+CLOE-Runtime
(DEFUN SPECIAL-OPERATOR-P (SYMBOL)
  (SPECIAL-FORM-P SYMBOL))

#-CLOE-Runtime
(DEFMACRO DEFSUBST (FUNCTION LAMBDA-LIST &BODY BODY)
  `(PROGN (DECLAIM (INLINE ,FUNCTION))
	  (DEFUN ,FUNCTION ,LAMBDA-LIST ,@BODY)))

#-Genera
(DEFMACRO DEFVAR-RESETTABLE
	  (NAME INITIAL-VALUE &OPTIONAL (WARM-BOOT-VALUE INITIAL-VALUE) DOCUMENTATION)
  (DECLARE (IGNORE WARM-BOOT-VALUE))
  `(DEFVAR ,NAME ,INITIAL-VALUE ,@(WHEN DOCUMENTATION `(,DOCUMENTATION))))

(DEFVAR *CLOS-INITIALIZED-P* NIL)

#+Genera
(DEFVAR-RESETTABLE *INSIDE-WITH-PENDING-DW-UPDATES* NIL)

;;; The processing of any pending updates on warm boot is handled
;;; by DW's *pending-type-changes*.
#+Genera
(DEFVAR-RESETTABLE *PENDING-DW-UPDATES* NIL)

;;; Have the outermost guy do the actual updates.  Each level that
;;; either does a batch of updates, or which does an actual installation
;;; of a class change, should use this macro.
#+Genera
(DEFMACRO WITH-PENDING-DW-UPDATES (&BODY BODY)
  (LET ((OLD-VALUE (SYS:GENSYMBOL "OLD-UPDATE-FLAG-")))
    `(LET ((,OLD-VALUE *INSIDE-WITH-PENDING-DW-UPDATES*)
	   (*INSIDE-WITH-PENDING-DW-UPDATES* T))
       ;; Only bind the list if we're the outermost.
       (SYS:LET-IF (NOT ,OLD-VALUE)
		   ((*PENDING-DW-UPDATES* NIL))
	 (UNWIND-PROTECT
	     (PROGN ,@BODY)
	   (WITHOUT-ABORTS ("The mouse sensitivity tables are being updated to reflect the~@
		    	     changes in the class type hierarchy.~@
~@
			     If you abort now, the tables may be left in an inconsistent~@
			     state, with only some of the changes in effect.")
	     (UNLESS ,OLD-VALUE
	       (DO-PENDING-DW-UPDATES))
	     ))))))

#-Genera
(DEFMACRO WITH-PENDING-DW-UPDATES (&BODY BODY)
  `(PROGN ,@BODY))

#+Genera
(DEFUN DO-PENDING-DW-UPDATES ()
  (DOLIST (UPDATE *PENDING-DW-UPDATES*)
    (DW:FINISH-TYPE-REDEFINITION UPDATE))
  (SETQ *PENDING-DW-UPDATES* NIL))

;; Interface with *pending-dw-updates*.

#+Genera
(DEFUN NOTE-CHANGE-FOR-DW (CLASS)
  (UNLESS *INSIDE-WITH-PENDING-DW-UPDATES*
    (CERROR "Continue updating ~S."
	    "Internal CLOS/DW error: Attempt to redefine a class~@
	     without arranging to tell the presentation substrate when we're done.~@
	     The immediately affected type is ~S."
	    CLASS))
  (WHEN CLASS
    (UNLESS (MEMBER CLASS *PENDING-DW-UPDATES*)
      (PROG1 (DW:PREPARE-FOR-TYPE-CHANGE CLASS)
	     (PUSH CLASS *PENDING-DW-UPDATES*)))))

#-Genera
(DEFMACRO NOTE-CHANGE-FOR-DW (CLASS)
  CLASS)

#-Genera
(DEFMACRO WITH-OUTPUT-AS-PRESENTATION (IGNORE &BODY BODY)
  (DECLARE (IGNORE IGNORE))
  `(PROGN ,@BODY))

#-(OR Genera CLOE-Runtime)
(DEFMACRO ONCE-ONLY (VARS &BODY FORMS)
  (LET ((GENVARS NIL))
    (DO ((VARS VARS (CDR VARS))) ((NULL VARS))
      (IF (EQ (CAR VARS) '&ENVIRONMENT)
	  (SETQ VARS (CDR VARS))
	  (PUSH (GENSYM) GENVARS)))
    ``(LET ,(MAPCAR #'LIST ',GENVARS (LIST ,@VARS))
	,(LET ,(MAPCAR #'(LAMBDA (GENVAR VAR) (LIST VAR `',GENVAR)) GENVARS VARS)
	   ,@FORMS))))

;;; If this is non-nil, it is a class being finalized.  MAKE-INSTANCES-OBSOLETE will
;;; not compute a new prototype and ensure instances get updated when called on the
;;; class in *FINALIZING-CLASS*.
(DEFVAR-RESETTABLE *FINALIZING-CLASS* NIL)

;;; Misc. features maybe not in all lisps.

#+CLOE-Runtime
(DEFUN CONSTANTLY (VALUE)
  (LOCALLY (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0)))
    #+CLOE-Runtime (COND ((EQ VALUE T) #'SYS::TRUE)
		 ((NULL VALUE) #'SYS::FALSE)
		 (T #'(LAMBDA ()
			(DECLARE (OPTIMIZE (SAFETY 0)))
			;;Reliance on no number of arg checking?
			VALUE)))
    #-CLOE-Runtime #'(LAMBDA (&REST IGNORED)
	       (DECLARE (IGNORE IGNORED))
	       VALUE)))

(DEFMACRO PARSING-DEFINITION ((NAME TYPE) &BODY BODY)
  #-Genera (DECLARE (IGNORE NAME TYPE))
  (LET ((WARNINGS (GENSYM)))
    `(LET (#+Genera (COMPILER:DEFAULT-WARNING-FUNCTION ,NAME)
	   #+Genera (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE ',TYPE)
	   (,WARNINGS NIL))
       (UNWIND-PROTECT
	   (FLET ((PARSE-WARN (WARNING &REST PARAMETERS)
		    #+Cloe-Runtime (DECLARE (SYS:DOWNWARD-FUNCTION))
		    (PUSH WARNING ,WARNINGS)
		    (PUSH PARAMETERS ,WARNINGS)))
	     (DECLARE (DYNAMIC-EXTENT #'PARSE-WARN))
	     (MACROLET ((PARSE-WARNINGS () ',WARNINGS))
	       ,@BODY))
	 (WHEN ,WARNINGS
	   ;; Collect all the warnings into a big warning
	   (WARN "~{~&~?~}" (REVERSE ,WARNINGS)))))))

(DEFUN PARSE-TOPLEVEL-BODY (BODY ENVIRONMENT LAMBDA-LIST)
  #-Genera (DECLARE (IGNORE LAMBDA-LIST))
  #+Genera (DECLARE (VALUES REAL-BODY DECL-SPECS DOCUMENTATION))
  #-(or Genera CLOE-Runtime) (DECLARE (IGNORE ENVIRONMENT))
  #+Genera
  (LET ((DECL-SPECS NIL) (DOCUMENTATION NIL))
    (MULTIPLE-VALUE-BIND (DOC-AND-DECLARATIONS REAL-BODY)
	(SYS:FIND-BODY-DECLARATIONS BODY ENVIRONMENT LAMBDA-LIST)
      (DOLIST (FORM DOC-AND-DECLARATIONS)
	(TYPECASE FORM
	  (CONS (SETQ DECL-SPECS (APPEND DECL-SPECS (CDR FORM))))
	  (STRING (UNLESS DOCUMENTATION (SETQ DOCUMENTATION FORM)))))
      (MAP-INTO DECL-SPECS #'(LAMBDA (SPEC)
			       (LET ((ALIAS (GET (CAR SPEC) 'SI:DECLARATION-ALIAS)))
				 (ETYPECASE ALIAS
				   (NULL)
				   (SYMBOL (SETF SPEC `(,ALIAS ,@(REST SPEC))))
				   (FUNCTION (SETF SPEC (FUNCALL ALIAS SPEC ENVIRONMENT)))))
			       SPEC)
		DECL-SPECS)
      (VALUES REAL-BODY DECL-SPECS DOCUMENTATION)))
  #+CLOE-Runtime
  (MULTIPLE-VALUE-BIND (REAL-BODY DECL-SPECS DOCUMENTATION-LIST)
      (PARSE-BODY BODY ENVIRONMENT)
    ;;This is KMP's hypothetical definition which exists in cloe.
    (VALUES REAL-BODY
	    (MAPCAN #'(LAMBDA (X) (COPY-LIST (CDR X))) DECL-SPECS)
	    (CAR DOCUMENTATION-LIST)))
  #-(or Genera CLOE-Runtime)
  (LOOP WITH DOC-STRING = NIL
	FOR SUBLIST ON BODY
	FOR FORM = (FIRST SUBLIST)
	WHILE (TYPECASE FORM
		(CONS
		  (CASE (FIRST FORM)
		    ((DECLARE) T)))
		(STRING
		  (AND (NULL DOC-STRING) (NOT (NULL (CDR SUBLIST))))))
	IF (STRINGP FORM)
	  DO (SETF DOC-STRING FORM)
	ELSE APPEND (REST FORM) INTO DECL-SPECS
	FINALLY (RETURN (VALUES SUBLIST DECL-SPECS DOC-STRING))))

;;; LAMBDA-LIST will be the lambda list
;;;
;;; DECL-SPECS is a list of the decl-specs.
;;;
;;; DOCUMENTATION is a string or NIL
;;;
;;; REAL-BODY is the actual body
(DEFUN PARSE-LAMBDA-EXPRESSION (LAMBDA-EXPRESSION ENVIRONMENT)
  #+Genera (DECLARE (VALUES LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY))
  ;; In Genera/CLOE, the lambda expression might be a lambda-macro, so macroexpand
  ;; them away.
  ;; What do you mean in cloe, glenn???
  #+Genera
  (SETQ LAMBDA-EXPRESSION
	(SI:UNDIGEST (SYS:LAMBDA-MACRO-EXPAND LAMBDA-EXPRESSION ENVIRONMENT)))
  (ECASE (FIRST LAMBDA-EXPRESSION)
    ((LAMBDA #+Genera ZL:LAMBDA)
     (LET ((LAMBDA-LIST (SECOND LAMBDA-EXPRESSION)))
       (MULTIPLE-VALUE-BIND (REAL-BODY DECL-SPECS DOCUMENTATION)
	   (PARSE-TOPLEVEL-BODY (CDDR LAMBDA-EXPRESSION) ENVIRONMENT LAMBDA-LIST)
	 (VALUES LAMBDA-LIST
		 DECL-SPECS
		 DOCUMENTATION
		 REAL-BODY))))))

#+Genera
(DEFUN OPTIMIZE-METHOD-LAMBDA (LAMBDA-EXPRESSION ENVIRONMENT)
  (DECLARE (VALUES LAMBDA-EXPRESSION
		   NEEDS-NEXT-METHOD-INFORMATION NEEDS-ORIGINAL-ARGUMENTS-P
		   NEEDS-CALL-NEXT-METHOD-P NEEDS-NEXT-METHOD-P-P
		   INITFORM-SLOT-VALUE-P))
  (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS DOCUMENTATION BODY)
      (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT)
    (LET ((NEEDS-NEXT-METHOD-INFORMATION NIL)
	  (NEEDS-ORIGINAL-ARGUMENTS-P NIL)
	  (NEEDS-CALL-NEXT-METHOD-P NIL)
	  (NEEDS-NEXT-METHOD-P-P NIL)
	  ;; If we can't open code all calls to CALL-NEXT-METHOD and NEXT-METHOD-P in
	  ;; the lambda expression, then we will add CALL-NEXT-METHOD or NEXT-METHOD-P
	  ;; to the lexical environment.  However, at this time, they are not in the
	  ;; environment.  We are interested in any references to CALL-NEXT-METHOD and
	  ;; NEXT-METHOD-P in LAMBDA-EXPRESSION which have not been shadowed in
	  ;; LAMBDA-EXPRESSION, i.e. we are interested in references which show up as
	  ;; references to these functions in ENVIRONMENT (which may be NIL).
	  (CALL-NEXT-METHOD (ASSOC 'CALL-NEXT-METHOD (SI:ENV-FUNCTIONS ENVIRONMENT)))
	  (NEXT-METHOD-P (ASSOC 'NEXT-METHOD-P (SI:ENV-FUNCTIONS ENVIRONMENT))))
      (DECLARE (IGNORE LAMBDA))
      (VALUES
	`(LAMBDA ,LAMBDA-LIST
	   (DECLARE ,@DECL-SPECS)
	   ,@DOCUMENTATION
	   ,(LT:COPYFORMS
	      #'(LAMBDA (FORM KIND USAGE)
		  (DECLARE (IGNORE USAGE))
		  (BLOCK PROCESS-FORM
		    (WHEN (AND (CONSP FORM)
			       (LISTP KIND))
		      (LET ((FIRST (FIRST FORM)))
			(CASE FIRST
			  ((FUNCTION SCL:FUNCTION)
			   (LET ((FUNCTION (SECOND FORM)))
			     (CASE FUNCTION
			       (CALL-NEXT-METHOD
				 (WHEN
				   (EQ 
				     (ASSOC 'CALL-NEXT-METHOD
					    (SI:ENV-FUNCTIONS
					      LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*))
				     CALL-NEXT-METHOD)
				   (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
				   (SETQ NEEDS-CALL-NEXT-METHOD-P T)
				   (SETQ NEEDS-ORIGINAL-ARGUMENTS-P T)))
			       (NEXT-METHOD-P
				 (WHEN
				   (EQ 
				     (ASSOC 'NEXT-METHOD-P
					    (SI:ENV-FUNCTIONS
					      LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*))
				     NEXT-METHOD-P)
				   (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
				   (SETQ NEEDS-NEXT-METHOD-P-P T))))))
			  ((CALL-NEXT-METHOD)
			   (WHEN (EQ (ASSOC 'CALL-NEXT-METHOD
					    (SI:ENV-FUNCTIONS
					      LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*))
				     CALL-NEXT-METHOD)
			     (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
			     (COND ((CDR FORM)
				    (RETURN-FROM PROCESS-FORM
				      `(CALL-NEXT-METHOD-WITH-NEW-ARGUMENTS ,@(CDR FORM))))
				   (T
				    (SETQ NEEDS-ORIGINAL-ARGUMENTS-P T)
				    (RETURN-FROM PROCESS-FORM
				      (VALUES
					`(CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS)
					T))))))
			  ((NEXT-METHOD-P)
			   (WHEN (EQ (ASSOC 'NEXT-METHOD-P
					    (SI:ENV-FUNCTIONS
					      LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*))
				     NEXT-METHOD-P)
			     (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
			     (RETURN-FROM PROCESS-FORM
			       '(INLINE-NEXT-METHOD-P)))))))
		    FORM))
	      `(PROGN ,@BODY)
	      :ENVIRONMENT ENVIRONMENT))
	NEEDS-NEXT-METHOD-INFORMATION
	NEEDS-ORIGINAL-ARGUMENTS-P
	NEEDS-CALL-NEXT-METHOD-P
	NEEDS-NEXT-METHOD-P-P
	(MULTIPLE-VALUE-BIND (NOTEPAD FREE-VARIABLES FREE-BLOCKS FREE-TAGS REPLICABILITY FREE-FUNCTIONS)
	    (LT:ANNOTATE-FORM `#'(LAMBDA ,LAMBDA-LIST (DECLARE ,@DECL-SPECS) NIL)
			      NIL ENVIRONMENT)
	  (DECLARE (IGNORE NOTEPAD FREE-VARIABLES FREE-BLOCKS FREE-TAGS REPLICABILITY))
	  (SOME #'(LAMBDA (FCN)
		    (OR (EQ FCN 'SLOT-VALUE)
			(EQUAL FCN '(SETF SLOT-VALUE))
			(EQUAL FCN '(LOCF SLOT-VALUE))
			(COMPILER:ACCESSOR-GENERIC-FUNCTION-P FCN)))
		FREE-FUNCTIONS))
	))))

#+Genera
(DEFUN MAKE-STANDARD-METHOD-LAMBDA (LAMBDA-EXPRESSION &OPTIONAL ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY)
      (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS RESTP KEYWORDSP KEYWORDS ALLOWP)
	(LAMBDA-LIST-COMPONENTS LAMBDA-LIST)
      KEYWORDS

      (WHEN (AND KEYWORDSP (NULL ALLOWP))
	(LET ((AUX (MEMBER '&AUX LAMBDA-LIST)))
	  (SETF LAMBDA-LIST 
		(IF AUX
		    (SUBST `(&ALLOW-OTHER-KEYS ,@AUX) AUX LAMBDA-LIST)
		    (APPEND LAMBDA-LIST '(&ALLOW-OTHER-KEYS))))))

      (LET ((TOP-LEVEL-DECL-SPECS
	      (LOOP FOR DECLARATION IN DECL-SPECS
		    WHEN (OR (MEMBER (FIRST DECLARATION)
				     '(SYS:FUNCTION-NAME SYS:DOWNWARD-FUNARG))
			     (GET (FIRST DECLARATION) 'SI:DEBUG-INFO))
		      COLLECT DECLARATION
		      AND DO (SETQ DECL-SPECS (REMOVE DECLARATION DECL-SPECS))))
	    (ARGUMENT-FORMAT
	      ;; On non-3600s, the argument format is always the extra argument
	      ;; followed by the normal arguments.  On 3600s, if there are no
	      ;; required arguments, the format is the same as on the non-3600s.
	      ;; However, if there are required arguments, the format is the first
	      ;; required argument, the extra argument, an ignored argument, and then
	      ;; the remaining arguments.
	      #-|3600| 'STANDARD
	      #+|3600| (IF (= N-REQUIRED-ARGUMENTS 0) 'STANDARD 'STANDARD-3600))
	    (NEXT-METHOD-INFORMATION '.NEXT-METHOD-INFORMATION.)
	    (MAPPED-VARIABLES
	      (LET ((IGNORED-VARS (LOOP FOR (DECL . REST) IN DECL-SPECS
					WHEN (EQ DECL 'LISP:IGNORE)
					  APPEND REST)))
		(LOOP REPEAT (MIN N-REQUIRED-ARGUMENTS
				  (ASH 1 (BYTE-SIZE CLOS-INTERNALS:%%MAP-BITS-CLASS)))
		      FOR VAR-NAME IN LAMBDA-LIST
		      COLLECT (AND (NOT (MEMBER VAR-NAME IGNORED-VARS))
				   VAR-NAME)))))
			
	(MULTIPLE-VALUE-BIND (LAMBDA-EXPRESSION
			      NEEDS-NEXT-METHOD-INFORMATION NEEDS-ORIGINAL-ARGUMENTS-P
			      NEEDS-CALL-NEXT-METHOD-P NEEDS-NEXT-METHOD-P-P
			      INITFORM-SLOT-VALUE-P)
	    (OPTIMIZE-METHOD-LAMBDA
	      `(LAMBDA ,LAMBDA-LIST
		 ,@(WHEN DECL-SPECS `((DECLARE ,@DECL-SPECS)))
		 ,@REAL-BODY)
	      ENVIRONMENT)
	  (MULTIPLE-VALUE-SETQ (LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY)
	    (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT))
	  (FLET ((WRAP-IN-MACROS (ADDITIONAL-MACROS BODY)
		   (IF NEEDS-NEXT-METHOD-INFORMATION
		       `(LET ((,NEXT-METHOD-INFORMATION .EXTRA-ARGUMENT.))
			  (SETQ .EXTRA-ARGUMENT. (POP ,NEXT-METHOD-INFORMATION))
			  (MACROLET (,@ADDITIONAL-MACROS
				     (CALL-NEXT-METHOD-WITH-NEW-ARGUMENTS
					(&REST NEW-ARGUMENTS)
				       ,(ECASE ARGUMENT-FORMAT
					  (STANDARD
					    ``(FUNCALL (FIRST ,',NEXT-METHOD-INFORMATION)
						       (REST ,',NEXT-METHOD-INFORMATION)
						       ,@NEW-ARGUMENTS))
					  (STANDARD-3600
					    ``(FUNCALL (FIRST ,',NEXT-METHOD-INFORMATION)
						       ,(FIRST NEW-ARGUMENTS)
						       (REST ,',NEXT-METHOD-INFORMATION)
						       NIL
						       ,@(REST NEW-ARGUMENTS)))))
				     (INLINE-NEXT-METHOD-P
					()
				       `(NOT (INSTANCEP (CDR ,',NEXT-METHOD-INFORMATION)))))
			    ,@BODY))
		       `(PROGN ,@BODY))))
	    (VALUES
	      (IF (OR NEEDS-ORIGINAL-ARGUMENTS-P
		      INITFORM-SLOT-VALUE-P)
		  (LET ((REQUIRED-ARGS-GENSYMS NIL)
			(REQUIRED-ARGS (SUBSEQ LAMBDA-LIST 0 N-REQUIRED-ARGUMENTS))
			(REST-ARG-GENSYM (WHEN (OR RESTP KEYWORDSP (> N-OPTIONAL-ARGUMENTS 0))
					   (GENSYM)))
			(OUTER-DECL-SPECS NIL)
			(INNER-DECL-SPECS NIL)
			(FLET-FCNS
			  `((,@(WHEN NEEDS-CALL-NEXT-METHOD-P
				 `((CALL-NEXT-METHOD
				     (&REST ARGUMENTS)
				     (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
				     (IF ARGUMENTS
					 ,(ECASE ARGUMENT-FORMAT
					    (STANDARD
					      `(APPLY
						 (FIRST ,NEXT-METHOD-INFORMATION)
						 (REST ,NEXT-METHOD-INFORMATION)
						 ARGUMENTS))
					    (STANDARD-3600
					      `(APPLY (FIRST ,NEXT-METHOD-INFORMATION)
						      (FIRST ARGUMENTS)
						      (REST ,NEXT-METHOD-INFORMATION)
						      NIL
						      (REST ARGUMENTS))))
					 (CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS))))
				 )
			     ,@(WHEN NEEDS-NEXT-METHOD-P-P
				 `((NEXT-METHOD-P () (INLINE-NEXT-METHOD-P)))))
			    (DECLARE (INLINE ,@(WHEN NEEDS-CALL-NEXT-METHOD-P
						 '(CALL-NEXT-METHOD))
					     ,@(WHEN NEEDS-NEXT-METHOD-P-P
						 '(NEXT-METHOD-P)))))))
		    (DOTIMES (IGNORE N-REQUIRED-ARGUMENTS)
		      (DECLARE (IGNORE IGNORE))
		      (PUSH (GENSYM) REQUIRED-ARGS-GENSYMS))
		    (DOLIST (DECLARATION DECL-SPECS)
		      (LET ((DECL-TYPE (FIRST DECLARATION)))
			(COND ((OR (MEMBER DECL-TYPE
					   '(SPECIAL DYNAMIC-EXTENT ZL:UNSPECIAL LISP:IGNORE
						     COMPILER:VARIABLE-INLINABLE
						     SYS:ARRAY-REGISTER
						     SYS:ARRAY-REGISTER-1D
						     SYS:LOGIC-VARIABLE))
				   (CLI::TYPE-NAME-P DECL-TYPE))
			       (DOLIST (VAR (REST DECLARATION))
				 (IF (MEMBER VAR REQUIRED-ARGS)
				     (PUSH `(,DECL-TYPE ,VAR) OUTER-DECL-SPECS)
				     (PUSH `(,DECL-TYPE ,VAR) INNER-DECL-SPECS))))
			      ((EQ DECL-TYPE 'TYPE)
			       (LET ((TYPE (SECOND DECLARATION)))
				 (DOLIST (VAR (CDDR DECLARATION))
				   (COND ((MEMBER VAR REQUIRED-ARGS)
					  (PUSH `(TYPE ,TYPE ,VAR) OUTER-DECL-SPECS)
					  (PUSH `(TYPE ,TYPE
						       ,(NTH
							  (POSITION VAR REQUIRED-ARGS)
							  REQUIRED-ARGS-GENSYMS))
						TOP-LEVEL-DECL-SPECS))
					 (T
					   (PUSH `(TYPE ,TYPE ,VAR) INNER-DECL-SPECS))))))
			      (T (PUSH DECLARATION INNER-DECL-SPECS)))))
		    `(LAMBDA (,@(ECASE ARGUMENT-FORMAT
				  (STANDARD
				    `(.EXTRA-ARGUMENT. ,@REQUIRED-ARGS-GENSYMS))
				  (STANDARD-3600
				    `(,(FIRST REQUIRED-ARGS-GENSYMS)
				      .EXTRA-ARGUMENT. .GENERIC.
				      ,@(REST REQUIRED-ARGS-GENSYMS))))
			      ,@(WHEN REST-ARG-GENSYM `(&REST ,REST-ARG-GENSYM)))
		       ,@(WHEN TOP-LEVEL-DECL-SPECS
			   `((DECLARE ,@TOP-LEVEL-DECL-SPECS)))
		       ,@(WHEN REST-ARG-GENSYM
			   `((DECLARE (DYNAMIC-EXTENT ,REST-ARG-GENSYM))))
		       ,@(ECASE ARGUMENT-FORMAT
			   (STANDARD '(.EXTRA-ARGUMENT.))
			   (STANDARD-3600 '(.EXTRA-ARGUMENT. .GENERIC.)))
		       ,(WRAP-IN-MACROS
			  `((CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS
			      ()
			      ,(ECASE ARGUMENT-FORMAT
				 (STANDARD
				   ``(,',(IF REST-ARG-GENSYM 'APPLY 'FUNCALL)
				      (FIRST ,',NEXT-METHOD-INFORMATION)
				      (REST ,',NEXT-METHOD-INFORMATION)
				      ,@',REQUIRED-ARGS-GENSYMS
				      ,@',(WHEN REST-ARG-GENSYM
					    `(,REST-ARG-GENSYM))))
				 (STANDARD-3600
				   ``(,',(IF REST-ARG-GENSYM 'APPLY 'FUNCALL)
				      (FIRST ,',NEXT-METHOD-INFORMATION)
				      ,',(FIRST REQUIRED-ARGS-GENSYMS)
				      (REST ,',NEXT-METHOD-INFORMATION)
				      NIL
				      ,@',(REST REQUIRED-ARGS-GENSYMS)
				      ,@',(WHEN REST-ARG-GENSYM
					    `(,REST-ARG-GENSYM)))))))
			  `((LET (,@(MAPCAR #'LIST REQUIRED-ARGS REQUIRED-ARGS-GENSYMS))
			      (DECLARE (COMPILER:VARIABLE-INLINABLE ,@REQUIRED-ARGS))
			      ,@(WHEN OUTER-DECL-SPECS `((DECLARE ,@OUTER-DECL-SPECS)))
			      (WITH-MAPPED-SLOT-ACCESS (,MAPPED-VARIABLES .EXTRA-ARGUMENT.)
				,(IF REST-ARG-GENSYM
				     `(APPLY #'(LAMBDA ,(NTHCDR N-REQUIRED-ARGUMENTS LAMBDA-LIST)
						 ,@(WHEN INNER-DECL-SPECS
						     `((DECLARE ,@INNER-DECL-SPECS)))
						 (FLET ,@FLET-FCNS
						   ,@REAL-BODY))
					     ,REST-ARG-GENSYM)
				     `((LAMBDA ,(MEMBER '&AUX LAMBDA-LIST)
					 ,@(WHEN INNER-DECL-SPECS
					     `((DECLARE ,@INNER-DECL-SPECS)))
					 (FLET ,@FLET-FCNS
					   ,@REAL-BODY))))))))))
		  `(LAMBDA
		     ,(ECASE ARGUMENT-FORMAT
			(STANDARD `(.EXTRA-ARGUMENT. ,@LAMBDA-LIST))
			(STANDARD-3600
			  `(,(FIRST LAMBDA-LIST) .EXTRA-ARGUMENT. .GENERIC.
			    ,@(REST LAMBDA-LIST))))
		     ,@(WHEN TOP-LEVEL-DECL-SPECS
			 `((DECLARE ,@TOP-LEVEL-DECL-SPECS)))
		     ,@(WHEN DECL-SPECS `((DECLARE ,@DECL-SPECS)))
		     ,@(ECASE ARGUMENT-FORMAT
			 (STANDARD '(.EXTRA-ARGUMENT.))
			 (STANDARD-3600 '(.EXTRA-ARGUMENT. .GENERIC.)))
		     ,(WRAP-IN-MACROS
			NIL
			`((FLET (,@(WHEN NEEDS-NEXT-METHOD-P-P
				       `((NEXT-METHOD-P () (INLINE-NEXT-METHOD-P)))))
			      ,@(WHEN NEEDS-NEXT-METHOD-P-P
				  `((DECLARE (INLINE NEXT-METHOD-P))))
			      (WITH-MAPPED-SLOT-ACCESS
				(,MAPPED-VARIABLES
				 .EXTRA-ARGUMENT.)
				,@REAL-BODY))))))
	      `(,@(WHEN DOCUMENTATION
		    `(:DOCUMENTATION ,DOCUMENTATION))
		,@(UNLESS NEEDS-NEXT-METHOD-INFORMATION
		    `(NO-NEXT-METHOD-INFORMATION T))))))))))

;;; This needs to be made a lot smarter.
#+Minima
(DEFUN OPTIMIZE-METHOD-LAMBDA (LAMBDA-EXPRESSION ENVIRONMENT MAPPED-VARIABLES)
  (DECLARE (IGNORE ENVIRONMENT))
  (LABELS ((NEEDS-P (FORM SYMBOL)
	     (OR (EQ FORM SYMBOL)
		 (AND (CONSP FORM)
		      (OR (NEEDS-P (CAR FORM) SYMBOL)
			  (NEEDS-P (CDR FORM) SYMBOL))))))
    (LET ((CALL-NEXT-METHOD-P (NEEDS-P LAMBDA-EXPRESSION 'CALL-NEXT-METHOD))
	  (NEXT-METHOD-P-P (NEEDS-P LAMBDA-EXPRESSION 'NEXT-METHOD-P))
	  (INITFORM-SLOT-VALUE-P
	    (LOOP WITH LL = (SECOND LAMBDA-EXPRESSION)
		  FOR VARIABLE IN MAPPED-VARIABLES
		  WITH INITFORMS = (OR (MEMBER '&OPTIONAL LL)
				       (MEMBER '&KEY LL)
				       (MEMBER '&AUX LL))
		  THEREIS (NEEDS-P INITFORMS VARIABLE))))
      (IF (OR CALL-NEXT-METHOD-P NEXT-METHOD-P-P)
	  (VALUES LAMBDA-EXPRESSION T T CALL-NEXT-METHOD-P NEXT-METHOD-P-P INITFORM-SLOT-VALUE-P)
	  (VALUES LAMBDA-EXPRESSION NIL NIL NIL NIL INITFORM-SLOT-VALUE-P)))))

#+Minima
(DEFUN MAKE-STANDARD-METHOD-LAMBDA (LAMBDA-EXPRESSION &OPTIONAL ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY)
      (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS RESTP KEYWORDSP KEYWORDS ALLOWP)
	(LAMBDA-LIST-COMPONENTS LAMBDA-LIST)
      KEYWORDS

      (WHEN (AND KEYWORDSP (NULL ALLOWP))
	(LET ((AUX (MEMBER '&AUX LAMBDA-LIST)))
	  (SETF LAMBDA-LIST 
		(IF AUX
		    (SUBST `(&ALLOW-OTHER-KEYS ,@AUX) AUX LAMBDA-LIST)
		    (APPEND LAMBDA-LIST '(&ALLOW-OTHER-KEYS))))))

      (LET ((TOP-LEVEL-DECL-SPECS
	      (LOOP FOR DECLARATION IN DECL-SPECS
		    WHEN (MEMBER (FIRST DECLARATION) '(MINIMA-INTERNALS::FUNCTION-NAME))
		      COLLECT DECLARATION
		      AND DO (SETQ DECL-SPECS (REMOVE DECLARATION DECL-SPECS))))
	    (NEXT-METHOD-INFORMATION '.NEXT-METHOD-INFORMATION.)
	    (MAPPED-VARIABLES
	      (LET ((IGNORED-VARS (LOOP FOR (DECL . REST) IN DECL-SPECS
					WHEN (EQ DECL 'IGNORE)
					  APPEND REST)))
		(LOOP REPEAT N-REQUIRED-ARGUMENTS
		      FOR VAR-NAME IN LAMBDA-LIST
		      COLLECT (AND (NOT (MEMBER VAR-NAME IGNORED-VARS))
				   VAR-NAME)))))
			
	(MULTIPLE-VALUE-BIND (LAMBDA-EXPRESSION
			       NEEDS-NEXT-METHOD-INFORMATION NEEDS-ORIGINAL-ARGUMENTS-P
			       NEEDS-CALL-NEXT-METHOD-P NEEDS-NEXT-METHOD-P-P
			       INITFORM-SLOT-VALUE-P)
	    (OPTIMIZE-METHOD-LAMBDA
	      `(LAMBDA ,LAMBDA-LIST
		 ,@(WHEN DECL-SPECS `((DECLARE ,@DECL-SPECS)))
		 ,@REAL-BODY)
	      ENVIRONMENT MAPPED-VARIABLES)
	  (MULTIPLE-VALUE-SETQ (LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY)
	    (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT))
	  (FLET ((WRAP-IN-MACROS (ADDITIONAL-MACROS BODY)
		   (IF NEEDS-NEXT-METHOD-INFORMATION
		       `(LET ((,NEXT-METHOD-INFORMATION .EXTRA-ARGUMENT.))
			  (SETQ .EXTRA-ARGUMENT. (POP ,NEXT-METHOD-INFORMATION))
			  (MACROLET (,@ADDITIONAL-MACROS
				     (CALL-NEXT-METHOD-WITH-NEW-ARGUMENTS (&REST NEW-ARGUMENTS)
				       `(FUNCALL (FIRST ,',NEXT-METHOD-INFORMATION)
						 (REST ,',NEXT-METHOD-INFORMATION)
						 ,@NEW-ARGUMENTS))
				     (INLINE-NEXT-METHOD-P ()
				       `(NOT (INSTANCEP (CDR ,',NEXT-METHOD-INFORMATION)))))
			    ,@BODY))
		       `(PROGN ,@BODY))))
	    (VALUES
	      (IF (OR NEEDS-ORIGINAL-ARGUMENTS-P
		      INITFORM-SLOT-VALUE-P)
		  (LET ((REQUIRED-ARGS-GENSYMS NIL)
			(REQUIRED-ARGS (SUBSEQ LAMBDA-LIST 0 N-REQUIRED-ARGUMENTS))
			(REST-ARG-GENSYM (WHEN (OR RESTP KEYWORDSP (> N-OPTIONAL-ARGUMENTS 0))
					   (GENSYM)))
			(OUTER-DECL-SPECS NIL)
			(INNER-DECL-SPECS NIL)
			(FLET-FCNS
			  `((,@(WHEN NEEDS-CALL-NEXT-METHOD-P
				 `((CALL-NEXT-METHOD
				     (&REST ARGUMENTS)
				     (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
				     (IF ARGUMENTS
					 (APPLY (FIRST ,NEXT-METHOD-INFORMATION)
						(REST ,NEXT-METHOD-INFORMATION)
						ARGUMENTS)
					 (CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS))))
				 )
			     ,@(WHEN NEEDS-NEXT-METHOD-P-P
				 `((NEXT-METHOD-P () (INLINE-NEXT-METHOD-P)))))
			    (DECLARE (INLINE ,@(WHEN NEEDS-CALL-NEXT-METHOD-P
						 '(CALL-NEXT-METHOD))
					     ,@(WHEN NEEDS-NEXT-METHOD-P-P
						 '(NEXT-METHOD-P)))))))
		    (DOTIMES (IGNORE N-REQUIRED-ARGUMENTS)
		      (PUSH (GENSYM) REQUIRED-ARGS-GENSYMS))
		    (DOLIST (DECLARATION DECL-SPECS)
		      (LET ((DECL-TYPE (FIRST DECLARATION)))
			(COND ((OR (MEMBER DECL-TYPE '(SPECIAL DYNAMIC-EXTENT IGNORE))
				   (MINIMA-INTERNALS::TYPE-NAME-P DECL-TYPE))
			       (DOLIST (VAR (REST DECLARATION))
				 (IF (MEMBER VAR REQUIRED-ARGS)
				     (PUSH `(,DECL-TYPE ,VAR) OUTER-DECL-SPECS)
				     (PUSH `(,DECL-TYPE ,VAR) INNER-DECL-SPECS))))
			      ((EQ DECL-TYPE 'TYPE)
			       (LET ((TYPE (SECOND DECLARATION)))
				 (DOLIST (VAR (CDDR DECLARATION))
				   (COND ((MEMBER VAR REQUIRED-ARGS)
					  (PUSH `(TYPE ,TYPE ,VAR) OUTER-DECL-SPECS)
					  (PUSH `(TYPE ,TYPE
						       ,(NTH
							  (POSITION VAR REQUIRED-ARGS)
							  REQUIRED-ARGS-GENSYMS))
						TOP-LEVEL-DECL-SPECS))
					 (T
					   (PUSH `(TYPE ,TYPE ,VAR) INNER-DECL-SPECS))))))
			      (T (PUSH DECLARATION INNER-DECL-SPECS)))))
		    `(LAMBDA (.EXTRA-ARGUMENT.
			      ,@REQUIRED-ARGS-GENSYMS
			      ,@(WHEN REST-ARG-GENSYM `(&REST ,REST-ARG-GENSYM)))
		       ,@(WHEN TOP-LEVEL-DECL-SPECS
			   `((DECLARE ,@TOP-LEVEL-DECL-SPECS)))
		       ,@(WHEN REST-ARG-GENSYM
			   `((DECLARE (DYNAMIC-EXTENT ,REST-ARG-GENSYM))))
		       .EXTRA-ARGUMENT.
		       ,(WRAP-IN-MACROS
			  `((CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS
			      ()
			      `(,',(IF REST-ARG-GENSYM 'APPLY 'FUNCALL)
				(FIRST ,',NEXT-METHOD-INFORMATION)
				(REST ,',NEXT-METHOD-INFORMATION)
				,@',REQUIRED-ARGS-GENSYMS
				,@',(WHEN REST-ARG-GENSYM
				      `(,REST-ARG-GENSYM)))))
			  `((LET (,@(MAPCAR #'LIST REQUIRED-ARGS REQUIRED-ARGS-GENSYMS))
			      ,@(WHEN OUTER-DECL-SPECS `((DECLARE ,@OUTER-DECL-SPECS)))
			      (WITH-MAPPED-SLOT-ACCESS (,MAPPED-VARIABLES .EXTRA-ARGUMENT.)
				,(IF REST-ARG-GENSYM
				     `(APPLY #'(LAMBDA (,@(NTHCDR N-REQUIRED-ARGUMENTS LAMBDA-LIST))
						 ,@(WHEN INNER-DECL-SPECS
						     `((DECLARE ,@INNER-DECL-SPECS)))
						 (FLET ,@FLET-FCNS
						   ,@REAL-BODY))
					     ,REST-ARG-GENSYM)
				     `((LAMBDA ,(MEMBER '&AUX LAMBDA-LIST)
					 ,@(WHEN INNER-DECL-SPECS
					     `((DECLARE ,@INNER-DECL-SPECS)))
					 (FLET ,@FLET-FCNS
					   ,@REAL-BODY))))))))))
		  `(LAMBDA (.EXTRA-ARGUMENT. ,@LAMBDA-LIST)
		     ,@(WHEN TOP-LEVEL-DECL-SPECS
			 `((DECLARE ,@TOP-LEVEL-DECL-SPECS)))
		     ,@(WHEN DECL-SPECS `((DECLARE ,@DECL-SPECS)))
		     .EXTRA-ARGUMENT.
		     ,(WRAP-IN-MACROS
			NIL
			`((FLET (,@(WHEN NEEDS-NEXT-METHOD-P-P
				     `((NEXT-METHOD-P () (INLINE-NEXT-METHOD-P)))))
			    ,@(WHEN NEEDS-NEXT-METHOD-P-P
				`((DECLARE (INLINE NEXT-METHOD-P))))
			    (WITH-MAPPED-SLOT-ACCESS
			      (,MAPPED-VARIABLES
			       .EXTRA-ARGUMENT.)
			      ,@REAL-BODY))))))
	      `(,@(WHEN DOCUMENTATION
		    `(:DOCUMENTATION ,DOCUMENTATION))
		,@(UNLESS NEEDS-NEXT-METHOD-INFORMATION
		    `(NO-NEXT-METHOD-INFORMATION T))))))))))


#+CLOE-Runtime
(DEFUN OPTIMIZE-METHOD-LAMBDA (LAMBDA-EXPRESSION ENVIRONMENT MAPPED-VARIABLES)
  (LET ((NEEDS-NEXT-METHOD-INFORMATION NIL)
	(NEEDS-ORIGINAL-ARGUMENTS-P NIL)
	(NEEDS-CALL-NEXT-METHOD-P NIL)
	(NEEDS-NEXT-METHOD-P-P NIL)
	(MAPPED-VARIABLE-ASSIGNED-P NIL))
    (LABELS ((FROB (FORM CONTEXT)
	       (ECASE CONTEXT
		 (:BIND
		   (LOCALLY
		     (DECLARE (SYMBOL FORM))
		     (WHEN (AND (MEMBER FORM MAPPED-VARIABLES)
				(NOT (ASSOC FORM MAPPED-VARIABLE-ASSIGNED-P)))
		       ;;We want to record assignments of only the first binding instance of the mapped variables.
		       (PUSH (SETF (CDR (MAP-FORMS-BINDING-INSTANCE FORM)) (CONS FORM NIL))
			     MAPPED-VARIABLE-ASSIGNED-P))))
		 (:ASSIGN
		   (LET ((INST (MAP-FORMS-BINDING-INSTANCE FORM)))
		     (WHEN (CDR INST) (RPLACD (CDR INST) T))))
		 (:FACCESS
		   (CASE FORM
		     (CALL-NEXT-METHOD
		       (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
		       (SETQ NEEDS-CALL-NEXT-METHOD-P T)
		       (SETQ NEEDS-ORIGINAL-ARGUMENTS-P T))
		     (NEXT-METHOD-P
		       (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
		       (SETQ NEEDS-NEXT-METHOD-P-P T))))
		 ((:MACRO-CALL :FUNCTION-CALL)
		  (CASE (CAR FORM)
		    (CALL-NEXT-METHOD
		      (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
		      (COND ((CDR FORM)
			     (RETURN-FROM FROB
			       `(CALL-NEXT-METHOD-WITH-NEW-ARGUMENTS
				  ,@(MAP-FORMS-BODY #'FROB (CDR FORM)))))
			    (T
			     (SETQ NEEDS-ORIGINAL-ARGUMENTS-P T)
			     (RETURN-FROM FROB
			       `(CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS)))))
		    (NEXT-METHOD-P
		      (SETQ NEEDS-NEXT-METHOD-INFORMATION T)
		      (RETURN-FROM FROB '(INLINE-NEXT-METHOD-P)))))
		 ((:TAG :GO :BLOCK :RETURN :DATA :DECLARE) NIL)
		 ((:ACCESS :FBIND :FEVAL :SPECIAL-FORM :LAMBDA-CALL) NIL))
	       (MAP-FORMS-RECURSE #'FROB FORM CONTEXT)))
	(VALUES (SECOND (MAP-FORMS-TOPLEVEL #'FROB `(FUNCTION ,LAMBDA-EXPRESSION)
					    :ENVIRONMENT ENVIRONMENT))
		NEEDS-NEXT-METHOD-INFORMATION
		NEEDS-ORIGINAL-ARGUMENTS-P
		NEEDS-CALL-NEXT-METHOD-P
		NEEDS-NEXT-METHOD-P-P
		MAPPED-VARIABLE-ASSIGNED-P))))

#+CLOE-Runtime
(DEFUN MAKE-STANDARD-METHOD-LAMBDA (LAMBDA-EXPRESSION &OPTIONAL ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY)
      (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS RESTP KEYWORDSP KEYWORDS ALLOWP)
	(LAMBDA-LIST-COMPONENTS LAMBDA-LIST)
      (DECLARE (IGNORE N-REQUIRED-ARGUMENTS KEYWORDS))
      (WHEN (AND KEYWORDSP (NULL ALLOWP))
	(LET ((AUX (MEMBER '&AUX LAMBDA-LIST)))
	  (SETF LAMBDA-LIST 
		(IF AUX
		    (SUBST `(&ALLOW-OTHER-KEYS ,@AUX) AUX LAMBDA-LIST)
		    (APPEND LAMBDA-LIST '(&ALLOW-OTHER-KEYS))))))
      (LET ((NEXT-METHOD-INFORMATION '.NEXT-METHOD-INFORMATION.)
	    (MAPPED-VARIABLES
	      (LET ((IGNORED-VARS (LOOP FOR (DECL . REST) IN DECL-SPECS
					WHEN (EQ DECL 'IGNORE)
					  APPEND REST)))
		(LOOP REPEAT (MIN N-REQUIRED-ARGUMENTS
				  (ASH 1 (BYTE-SIZE CLOS-INTERNALS:%%MAP-BITS-CLASS)))
		      FOR VAR-NAME IN LAMBDA-LIST
		      COLLECT (AND (NOT (EQ VAR-NAME 'IGNORE))
				   (NOT (MEMBER VAR-NAME IGNORED-VARS))
				   VAR-NAME)))))		      
	(MULTIPLE-VALUE-BIND (LAMBDA-EXPRESSION
			      NEEDS-NEXT-METHOD-INFORMATION NEEDS-ORIGINAL-ARGUMENTS-P
			      NEEDS-CALL-NEXT-METHOD-P NEEDS-NEXT-METHOD-P-P
			      MAPPED-VARIABLE-ASSIGNED-P)
	    (OPTIMIZE-METHOD-LAMBDA
	      `(LAMBDA ,LAMBDA-LIST
		 ,@(WHEN DECL-SPECS `((DECLARE ,@DECL-SPECS)))
		 ,@REAL-BODY)
	      ENVIRONMENT MAPPED-VARIABLES)
	  (FLET ((WRAP-IN-MACROS (ADDITIONAL-MACROS BODY)
		   `(MACROLET (,@ADDITIONAL-MACROS
			       (CALL-NEXT-METHOD-WITH-NEW-ARGUMENTS (&REST NEW-ARGUMENTS)
				 `(FUNCALL (FIRST ,',NEXT-METHOD-INFORMATION)
					   (REST ,',NEXT-METHOD-INFORMATION)
					   ,@NEW-ARGUMENTS))
			       (INLINE-NEXT-METHOD-P ()
				 `(NOT (INSTANCEP (CDR ,',NEXT-METHOD-INFORMATION)))))
		      ,@BODY)))
	    
	    (MULTIPLE-VALUE-BIND (LAMBDA METHOD-MAPPING-TABLE-FAMILY)
		(REWRITE-WITH-MAPPED-SLOT-ACCESS
		  (COND ((AND NEEDS-ORIGINAL-ARGUMENTS-P (> N-OPTIONAL-ARGUMENTS 0))
			 `(LAMBDA (.EXTRA-ARGUMENT. &REST .ORIGINAL-ARGUMENTS.)
			    .EXTRA-ARGUMENT.
			    ,(WRAP-IN-MACROS
			       `((CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS
				   ()
				   `(APPLY (FIRST ,',NEXT-METHOD-INFORMATION)
					   (REST ,',NEXT-METHOD-INFORMATION)
					   .ORIGINAL-ARGUMENTS.)))
			       `((LET ((,NEXT-METHOD-INFORMATION .EXTRA-ARGUMENT.))
				   (SETQ .EXTRA-ARGUMENT. (POP ,NEXT-METHOD-INFORMATION))
				   (FLET
				     (,@(WHEN NEEDS-CALL-NEXT-METHOD-P
					  `((CALL-NEXT-METHOD
					      (&REST ARGUMENTS)
					      (APPLY (FIRST ,NEXT-METHOD-INFORMATION)
						     (REST ,NEXT-METHOD-INFORMATION)
						     (OR ARGUMENTS .ORIGINAL-ARGUMENTS.)))))
				      ,@(WHEN NEEDS-NEXT-METHOD-P-P
					  `((NEXT-METHOD-P
					      ()
					      (NOT (INSTANCEP
						     (CDR ,NEXT-METHOD-INFORMATION)))))))
				     (APPLY #',LAMBDA-EXPRESSION .ORIGINAL-ARGUMENTS.)))))))
			(NEEDS-ORIGINAL-ARGUMENTS-P
			 (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS NIL REAL-BODY)
			     (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT)
			   (LET ((REQUIRED-ARGS-GENSYMS NIL)
				 (REQUIRED-ARGS (SUBSEQ LAMBDA-LIST 0 N-REQUIRED-ARGUMENTS))
				 (REST-ARG-GENSYM (WHEN (OR RESTP KEYWORDSP) (GENSYM)))
				 (REST-ARG (WHEN RESTP (NTH (+ N-REQUIRED-ARGUMENTS 1) LAMBDA-LIST)))
				 (OUTER-DECL-SPECS NIL)
				 (INNER-DECL-SPECS NIL))
			     (DOTIMES (IGNORE N-REQUIRED-ARGUMENTS)
			       (PUSH (GENSYM) REQUIRED-ARGS-GENSYMS))
			     (DOLIST (DECLARATION DECL-SPECS)
			       (CASE (FIRST DECLARATION)
				 (SPECIAL
				   (DOLIST (VAR (REST DECLARATION))
				     (IF (OR (MEMBER VAR REQUIRED-ARGS)
					     (EQ VAR REST-ARG))
					 (PUSH `(SPECIAL ,VAR) INNER-DECL-SPECS)
					 (PUSH `(SPECIAL ,VAR) OUTER-DECL-SPECS))))
				 (DYNAMIC-EXTENT
				   (DOLIST (VAR (REST DECLARATION))
				     (COND ((MEMBER VAR REQUIRED-ARGS)
					    (PUSH `(DYNAMIC-EXTENT ,VAR) INNER-DECL-SPECS))
					   ((EQ VAR REST-ARG)
					    (PUSH `(DYNAMIC-EXTENT ,REST-ARG-GENSYM)
						  OUTER-DECL-SPECS))
					   (T
					    (PUSH `(DYNAMIC-EXTENT ,VAR) OUTER-DECL-SPECS)))))
				 (TYPE
				   (LET ((TYPE (SECOND DECLARATION)))
				     (DOLIST (VAR (CDDR DECLARATION))
				       (COND ((MEMBER VAR REQUIRED-ARGS)
					      (PUSH `(TYPE ,TYPE ,VAR) INNER-DECL-SPECS)
					      (PUSH `(TYPE ,TYPE ,(NTH
								    (POSITION VAR REQUIRED-ARGS)
								    REQUIRED-ARGS-GENSYMS))
						    OUTER-DECL-SPECS))
					     (T
					      (PUSH `(TYPE ,TYPE ,VAR) OUTER-DECL-SPECS))))))
				 (OTHERWISE (PUSH DECLARATION INNER-DECL-SPECS))))
		       
			     `(LAMBDA (.EXTRA-ARGUMENT.
				       ,@REQUIRED-ARGS-GENSYMS
				       ,@(WHEN REST-ARG-GENSYM `(&REST ,REST-ARG-GENSYM))
				       ;; Deal with the keywords here.
				       ,@(MEMBER '&KEY LAMBDA-LIST))
				,@(WHEN OUTER-DECL-SPECS `((DECLARE ,@OUTER-DECL-SPECS)))
				.EXTRA-ARGUMENT.
				,(WRAP-IN-MACROS
				   `((CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS
				       ()
				       `(,',(IF (OR RESTP KEYWORDSP) 'APPLY 'FUNCALL)
					 (FIRST ,',NEXT-METHOD-INFORMATION)
					 (REST ,',NEXT-METHOD-INFORMATION)
					 ,@',REQUIRED-ARGS-GENSYMS
					 ,@',(WHEN (OR RESTP KEYWORDSP)
					       `(,REST-ARG-GENSYM)))))
				   `((LET ((,NEXT-METHOD-INFORMATION .EXTRA-ARGUMENT.))
				       (SETQ .EXTRA-ARGUMENT. (POP ,NEXT-METHOD-INFORMATION))
				       (FLET
					 (,@(WHEN NEEDS-CALL-NEXT-METHOD-P
					      `((CALL-NEXT-METHOD
						  (&REST ARGUMENTS)
						  (IF ARGUMENTS
						      (APPLY (FIRST ,NEXT-METHOD-INFORMATION)
							     (REST ,NEXT-METHOD-INFORMATION)
							     ARGUMENTS)
						      (CALL-NEXT-METHOD-WITH-ORIGINAL-ARGUMENTS))))
					      )
					  ,@(WHEN NEEDS-NEXT-METHOD-P-P
					      `((NEXT-METHOD-P
						  ()
						  (NOT (INSTANCEP
							 (CDR ,NEXT-METHOD-INFORMATION)))))))
					 (LET (,@(MAPCAR #'LIST REQUIRED-ARGS
							 REQUIRED-ARGS-GENSYMS)
					       ,@(WHEN RESTP
						   `((,REST-ARG ,REST-ARG-GENSYM))))
					   ,@(WHEN INNER-DECL-SPECS
					       `((DECLARE ,@INNER-DECL-SPECS)))
					   ,@REAL-BODY)))))))))
		    
			(T
			 (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS NIL REAL-BODY)
			     (PARSE-LAMBDA-EXPRESSION LAMBDA-EXPRESSION ENVIRONMENT)
			   `(LAMBDA (.EXTRA-ARGUMENT. ,@LAMBDA-LIST)
			      ,@(WHEN DECL-SPECS `((DECLARE ,@DECL-SPECS)))
			      .EXTRA-ARGUMENT.
			      ,(WRAP-IN-MACROS
				 NIL
				 `((LET (,@(WHEN NEEDS-NEXT-METHOD-INFORMATION
					     `((,NEXT-METHOD-INFORMATION .EXTRA-ARGUMENT.))))
				     ,@(WHEN NEEDS-NEXT-METHOD-INFORMATION
					 `((SETQ .EXTRA-ARGUMENT. (POP ,NEXT-METHOD-INFORMATION))))
				     (FLET (,@(WHEN NEEDS-NEXT-METHOD-P-P
						`((NEXT-METHOD-P () (INLINE-NEXT-METHOD-P)))))
				       ,@REAL-BODY))))))))
		  (MAPL #'(LAMBDA (X)
			    (WHEN (AND (CAR X) (CDR (ASSOC (THE SYMBOL (CAR X)) MAPPED-VARIABLE-ASSIGNED-P)))
			      (RPLACA X NIL)))
			MAPPED-VARIABLES)
		  '.EXTRA-ARGUMENT. ENVIRONMENT)
	      (VALUES
		LAMBDA
		`(,@(WHEN METHOD-MAPPING-TABLE-FAMILY
		      (FREEZE-MAPPING-TABLE-FAMILY METHOD-MAPPING-TABLE-FAMILY)
		      `(METHOD-MAPPING-TABLE-FAMILY ,METHOD-MAPPING-TABLE-FAMILY))
		  ,@(WHEN DOCUMENTATION
		      `(:DOCUMENTATION ,DOCUMENTATION))
		  ,@(UNLESS NEEDS-NEXT-METHOD-INFORMATION
		      `(NO-NEXT-METHOD-INFORMATION T)))))))))))

#+CLOE-Runtime
(PROGN

(DEFVAR *MAPPING-TABLE-VARIABLES*)
(DEFVAR *MAPPING-VARIABLE-NAME*)
(DEFVAR *MAPPING-TABLE-FAMILY*)

(DEFVAR *REWRITE-WITH-MAPPED-SLOT-ACCESS* T)

(DEFUN REWRITE-WITH-MAPPED-SLOT-ACCESS (FORM *MAPPING-TABLE-VARIABLES* *MAPPING-VARIABLE-NAME* ENV)
  (COND ((NOT *REWRITE-WITH-MAPPED-SLOT-ACCESS*) (VALUES FORM NIL))
	(T (SETQ *MAPPING-TABLE-VARIABLES* (COPY-LIST *MAPPING-TABLE-VARIABLES*))
	   (LET ((*MAPPING-TABLE-FAMILY* (MAKE-MAPPING-TABLE-FAMILY)))
	     (LET ((NEWFORM (MAP-FORMS-TOPLEVEL #'MAPPING-TABLE-FROBNICATOR FORM :ENVIRONMENT ENV)))
	       (VALUES NEWFORM
		       (IF (ZEROP (MAPPING-TABLE-FAMILY-SIZE *MAPPING-TABLE-FAMILY*))
			   NIL
			   *MAPPING-TABLE-FAMILY*)))))))

(DEFUN MAPPING-TABLE-FROBNICATOR (FORM TYPE)
  (ECASE TYPE
    (:BIND
      (LET ((N (POSITION (THE SYMBOL FORM) (THE LIST *MAPPING-TABLE-VARIABLES*))))
	(IF N
	    (SETF (CDR (MAP-FORMS-BINDING-INSTANCE FORM)) N
		  (NTHCDR N *MAPPING-TABLE-VARIABLES*) NIL)
	    (MULTIPLE-VALUE-BIND (KIND LOCALP STUFF)
		(VARIABLE-INFORMATION FORM *MAP-FORMS-ENVIRONMENT*)
	      ;;Basically what goes on here is that if a let variable had a variable-inlinable
	      ;; declaration, the data associated with that keyword should (after it is bound)
	      ;; be a list whose car is the initform.  So, if THAT  form is a variable we
	      ;; are doing mapping-table hackery for, then we will for the one we are binding
	      ;; here too.  Do so by simply copying the map-forms-binding-instance data.
	      (WHEN (AND LOCALP (EQ KIND :LEXICAL))
		(LET ((DATA (CDR (ASSOC 'COMPILER:VARIABLE-INLINABLE STUFF))))
		  (WHEN (AND (CONSP DATA)
			     (SYMBOLP (CAR DATA))
			     (SETQ N (CDR (MAP-FORMS-BINDING-INSTANCE (CAR DATA)))))
		    (SETF (CDR (MAP-FORMS-BINDING-INSTANCE FORM)) N))))))))
    (:ASSIGN
      (WHEN (CDR (MAP-FORMS-BINDING-INSTANCE FORM))
	(ERROR "Assigning a mapped argument unexpectedly: ~S." FORM)))
    (:FUNCTION-CALL
      (COND ((EQ (CAR FORM) 'SLOT-VALUE)
	     (MULTIPLE-VALUE-BIND (VAR EXTRA-ARG SEGMENT-NUMBER OFFSET)
		 (DETERMINE-SLOT-MAPPABILITY (SECOND FORM) (THIRD FORM) 'SLOT-VALUE)
	       (WHEN VAR
		 (RETURN-FROM MAPPING-TABLE-FROBNICATOR
		   (MAP-FORMS #'MAPPING-TABLE-FROBNICATOR
			      `(%MAPPED-SLOT-VALUE ,VAR ,EXTRA-ARG ,SEGMENT-NUMBER ,OFFSET))))))
	    ((AND (EQ (CAR FORM) 'FUNCALL) (EQUAL (SECOND FORM) '#'(SETF SLOT-VALUE) *MAP-FORMS-ENVIRONMENT*))
	     (MULTIPLE-VALUE-BIND (VAR EXTRA-ARG SEGMENT-NUMBER OFFSET)
		 (DETERMINE-SLOT-MAPPABILITY (FOURTH FORM) (FIFTH FORM) '(SETF SLOT-VALUE) *MAP-FORMS-ENVIRONMENT*)
	       (WHEN VAR
		 (RETURN-FROM MAPPING-TABLE-FROBNICATOR
		   (MAP-FORMS #'MAPPING-TABLE-FROBNICATOR
			      `(%MAPPED-SLOT-XSTORE ,(THIRD FORM) ,VAR ,EXTRA-ARG ,SEGMENT-NUMBER ,OFFSET))))))
	    ((EQ (CAR FORM) 'SET-SLOT-VALUE)
	     (MULTIPLE-VALUE-BIND (VAR EXTRA-ARG SEGMENT-NUMBER OFFSET)
		 (DETERMINE-SLOT-MAPPABILITY (SECOND FORM) (THIRD FORM) '(SETF SLOT-VALUE) *MAP-FORMS-ENVIRONMENT*)
	       (WHEN VAR
		 (RETURN-FROM MAPPING-TABLE-FROBNICATOR
		   (MAP-FORMS #'MAPPING-TABLE-FROBNICATOR
			      `(%MAPPED-SLOT-STORE ,VAR ,EXTRA-ARG ,SEGMENT-NUMBER ,OFFSET ,(FOURTH FORM)))))))))
    ((:MACRO-CALL :SPECIAL-FORM :LAMBDA-CALL :TAG :GO :BLOCK :RETURN :DATA :FBIND :ACCESS :FACCESS :FEVAL :DECLARE)))
  (MAP-FORMS-RECURSE #'MAPPING-TABLE-FROBNICATOR FORM TYPE))

(DEFUN DETERMINE-SLOT-MAPPABILITY (INSTANCE-ARG SLOT-NAME-ARG FN-NAME &AUX CLASS-INDEX)
  (WHEN (AND (SYMBOLP INSTANCE-ARG)
	     (SETQ CLASS-INDEX (CDR (MAP-FORMS-BINDING-INSTANCE INSTANCE-ARG)))
	     (CONSP SLOT-NAME-ARG)
	     (EQ (CAR SLOT-NAME-ARG) 'QUOTE))
    ;;@@@@
    #+IGNORE
    (MULTIPLE-VALUE-BIND (KIND LOCALP A-LIST)
	(FUNCTION-INFORMATION FN-NAME *MAP-FORMS-ENVIRONMENT*)
      (UNLESS (OR LOCALP
		  (EQ (CDR (ASSOC 'INLINE A-LIST)) 'NOTINLINE))
	(RETURN-FROM DETERMINE-SLOT-MAPPABILITY NIL)))
    (MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
	(GET-MAPPING-TABLE-FAMILY-SEGMENT-NUMBER-AND-OFFSET
	  *MAPPING-TABLE-FAMILY* CLASS-INDEX :SLOT (SECOND SLOT-NAME-ARG))
      (VALUES INSTANCE-ARG *MAPPING-VARIABLE-NAME* SEGMENT-NUMBER OFFSET))))
);;;NGORP

(DEFUN REMOVE-KEYWORDS (LIST &REST KEYWORDS)
  (DECLARE (DYNAMIC-EXTENT KEYWORDS))
  ;; Clear off any leading keywords
  (LOOP
    (WHEN (NULL LIST) (RETURN-FROM REMOVE-KEYWORDS NIL))
    (IF (MEMBER (CAR LIST) KEYWORDS)
	(SETQ LIST (CDDR LIST))
	(RETURN)))
  (LET ((LIST-COPY LIST)
	(LENGTH 0)
	(ANY NIL))
    (LOOP
      (WHEN (NULL LIST-COPY) (RETURN))
      (IF (MEMBER (POP LIST-COPY) KEYWORDS)
	  (SETQ ANY T)
	  (INCF LENGTH))
      (SETQ LIST-COPY (CDR LIST-COPY)))
    (UNLESS ANY (RETURN-FROM REMOVE-KEYWORDS LIST))
    (WHEN (= LENGTH 0) (RETURN-FROM REMOVE-KEYWORDS NIL))
    (LET* ((NEW-LIST (MAKE-LIST (* LENGTH 2)))
	   (HEAD NEW-LIST))
      (SETF (FIRST HEAD) (POP LIST))
      (SETQ HEAD (CDR HEAD))
      (SETF (FIRST HEAD) (POP LIST))
      (DECF LENGTH)
      (LOOP
	(WHEN (= LENGTH 0)
	  (RETURN-FROM REMOVE-KEYWORDS NEW-LIST))
	(LET ((KEY (POP LIST)))
	  (COND ((MEMBER KEY KEYWORDS)
		 (SETQ LIST (CDR LIST)))
		(T
		 (DECF LENGTH)
		 (SETQ HEAD (CDR HEAD))
		 (SETF (FIRST HEAD) KEY)
		 (SETF HEAD (CDR HEAD))
		 (SETF (FIRST HEAD) (POP LIST)))))))))

;;; There should be a better way to do this kind of thing
#-Genera
(DEFPARAMETER *GENERIC-FUNCTION-NAME-VALID-SPEC-TYPES*
	      '(SETF
		#+(OR Genera Minima) LOCF
		#+Genera SCL:SETF
		#+Genera :PROPERTY))

#-Genera
(DEFUN GENERIC-FUNCTION-NAME-VALID-P (FUNCTION-NAME)
  (OR (AND (SYMBOLP FUNCTION-NAME)
	   (NOT (SPECIAL-OPERATOR-P FUNCTION-NAME)))
      (AND (CONSP FUNCTION-NAME)
	   (MEMBER (FIRST FUNCTION-NAME) *GENERIC-FUNCTION-NAME-VALID-SPEC-TYPES*)
	   #+Genera (SYS:VALIDATE-FUNCTION-SPEC FUNCTION-NAME NIL)
	   #+CLOE-Runtime (SYSTEM:VALIDATE-FUNCTION-NAME FUNCTION-NAME)
	   #-(OR Genera CLOE-Runtime) (AND (CONSP (CDR FUNCTION-NAME))
				   (SYMBOLP (SECOND FUNCTION-NAME))
				   (NULL (CDDR FUNCTION-NAME))))))

;;; Given a function name, return an appropriate block name. 
#-Genera
(DEFUN DIVINE-SUITABLE-BLOCK-NAME (NAME)
  #+Genera (DECLARE (VALUES BLOCK-NAME-OR-NIL))
  (LOOP FOR BLOCK = NAME THEN (SECOND BLOCK) DO
    (COND ((SYMBOLP BLOCK) (RETURN (VALUES BLOCK T)))
	  ((OR (NOT (LISTP BLOCK))
	       (NOT (LISTP (CDR BLOCK))))
	   (RETURN (VALUES NIL NIL))))))

;;; If there is an appropriate block name for the function name, wrap the body in a
;;; block with that name.
#-Genera
(DEFUN WRAP-BODY-WITH-BLOCK (FUNCTION-NAME BODY)
  (MULTIPLE-VALUE-BIND (NAME FOUNDP)
      (DIVINE-SUITABLE-BLOCK-NAME FUNCTION-NAME)
    (IF FOUNDP
	`((BLOCK ,NAME ,@BODY))
	BODY)))  

(DEFUN CHECK-VARIABLE (TYPE PARAMETER-SPECIFIER VARIABLE &OPTIONAL (WARNING-FUNCTION #'WARN))
  (COND ((NOT (SYMBOLP VARIABLE)) 
	 (FUNCALL WARNING-FUNCTION
		  "The ~a ~s is not a symbol in ~s"
		  TYPE VARIABLE PARAMETER-SPECIFIER)
	 NIL)
	((CONSTANTP VARIABLE)
	 (FUNCALL WARNING-FUNCTION
		  "The ~a ~s is a constant in ~s"
		  TYPE VARIABLE PARAMETER-SPECIFIER)
	 NIL)
	(T T)))

(DEFUN CHECK-LAMBDA-LIST
       (LAMBDA-LIST ALLOW-INITIALIZATIONS-P ALLOW-AUXEN-P ALLOW-WHOLE-P
	&OPTIONAL (WARNING-FUNCTION #'WARN))
  #+Genera (DECLARE (VALUES SUCCESS-P PARSED-LAMBDA-LIST))
  (LET ((LAMBDA-LIST-COMPONENTS LAMBDA-LIST)
	(PARSED-LAMBDA-LIST NIL)
	(PARSE-FAILED NIL))
    (MACROLET ((PARSE-WARN (WARNING &REST ARGUMENTS)
		 `(PROGN
		    (SETQ PARSE-FAILED T)
		    (FUNCALL WARNING-FUNCTION ,WARNING ,@ARGUMENTS))))
      (LABELS ((CHECK-VAR (TYPE PARAMETER-SPECIFIER THING)
		 (LET ((RESULT (CHECK-VARIABLE
				 TYPE PARAMETER-SPECIFIER THING WARNING-FUNCTION)))
		   (UNLESS RESULT (SETQ PARSE-FAILED T))
		   RESULT))
	       (CHECK-INIT (PARAMETER-SPECIFIER TAIL)
		 (COND ((NULL TAIL)
			(VALUES T TAIL))
		       ((NULL ALLOW-INITIALIZATIONS-P)
			(PARSE-WARN
			  "Parameter initializations are not allowed, but one was ~
                           supplied in ~s.  The initialization will be ignored."
			  PARAMETER-SPECIFIER)
			(VALUES NIL NIL))
		       ((NOT (CONSP TAIL))
			(PARSE-WARN
			  "The parameter initialization for ~s is not a list.  The ~
                           initialization will be ignored."
			  PARAMETER-SPECIFIER)
			(VALUES NIL NIL))
		       (T
			(COND ((NULL (CDR TAIL)) (VALUES T TAIL))
			      ((CHECK-VAR
				 "supplied-p parameter"
				 PARAMETER-SPECIFIER (SECOND TAIL))
			       (COND ((CDDR TAIL)
				      (PARSE-WARN
					"The parameter ~s has too many components.  The ~
                                         excess components, ~s, will be ignored."
					PARAMETER-SPECIFIER (CDDR TAIL))
				      (VALUES NIL `(,(FIRST TAIL) ,(SECOND TAIL))))
				     (T (VALUES T TAIL))))
			      (T
			       (PARSE-WARN
				 "The supplied-p parameter will be ignored.")
			       (VALUES NIL `(,(FIRST TAIL)))))))))
	(TAGBODY
	  (LOOP
	    (WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
	    (UNLESS (CONSP LAMBDA-LIST-COMPONENTS)
	      (PARSE-WARN "The lambda list ~s is not a list." LAMBDA-LIST)
	      (GO DONE))
	    (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	      (COND ((AND (EQ PARAMETER-SPECIFIER '&WHOLE)
			  ALLOW-WHOLE-P
			  LAMBDA-LIST-COMPONENTS	;An &whole variable
			  (NULL PARSED-LAMBDA-LIST))	;first in lambda list
		     (PUSH '&WHOLE PARSED-LAMBDA-LIST))
		    ((EQ PARAMETER-SPECIFIER '&OPTIONAL) (GO OPTIONAL))
		    ((EQ PARAMETER-SPECIFIER '&REST) (GO REST))
		    ((EQ PARAMETER-SPECIFIER '&KEY) (GO KEYS))
		    ((EQ PARAMETER-SPECIFIER '&AUX) (GO AUX))
		    ((MEMBER PARAMETER-SPECIFIER LAMBDA-LIST-KEYWORDS)
		     (PARSE-WARN
		       "The lambda list keyword ~s does not make sense in the context: ~
                        ~s -->> ~s <<-- ~s.  The keyword will be ignored."
		       PARAMETER-SPECIFIER (REVERSE PARSED-LAMBDA-LIST)
		       PARAMETER-SPECIFIER LAMBDA-LIST-COMPONENTS))
		    ((CHECK-VAR
		       "required parameter" PARAMETER-SPECIFIER PARAMETER-SPECIFIER)
		     (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST))
		    (T
		     (PARSE-WARN "The parameter specifier ~s will be ignored."
				 PARAMETER-SPECIFIER)))))
       OPTIONAL
	  (PUSH '&OPTIONAL PARSED-LAMBDA-LIST)
	  (LOOP
	    (WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
	    (UNLESS (CONSP LAMBDA-LIST-COMPONENTS)
	      (PARSE-WARN
		"The lambda list ~s is not a list."
		LAMBDA-LIST
		(GO DONE)))
	    (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	      (COND ((EQ PARAMETER-SPECIFIER '&REST) (GO REST))
		    ((EQ PARAMETER-SPECIFIER '&KEY) (GO KEYS))
		    ((EQ PARAMETER-SPECIFIER '&AUX) (GO AUX))
		    ((MEMBER PARAMETER-SPECIFIER LAMBDA-LIST-KEYWORDS)
		     (PARSE-WARN
		       "The lambda list keyword ~s does not make sense in the context: ~
                        ~s -->> ~s <<-- ~s.  The keyword will be ignored."
		       PARAMETER-SPECIFIER (REVERSE PARSED-LAMBDA-LIST)
		       PARAMETER-SPECIFIER LAMBDA-LIST-COMPONENTS))
		    ((TYPEP PARAMETER-SPECIFIER 'CONS)
		     (IF (CHECK-VAR
			   "optional parameter" PARAMETER-SPECIFIER
			   (FIRST PARAMETER-SPECIFIER))
			 (MULTIPLE-VALUE-BIND (INIT-SUCCESS-P TAIL)
			     (CHECK-INIT PARAMETER-SPECIFIER (CDR PARAMETER-SPECIFIER))
			   (IF INIT-SUCCESS-P
			       (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST)
			       (LET ((NEW-PARAMETER-SPECIFIER
				       `(,(FIRST PARAMETER-SPECIFIER) ,@TAIL)))
				 (PARSE-WARN
				   "The parameter specifier ~s will be replaced with ~s"
				   PARAMETER-SPECIFIER NEW-PARAMETER-SPECIFIER)
				 (PUSH NEW-PARAMETER-SPECIFIER PARSED-LAMBDA-LIST))))
			 (PARSE-WARN
			   "The parameter specifier ~s will be ignored."
			   PARAMETER-SPECIFIER)))
		    ((CHECK-VAR
		       "optional parameter" PARAMETER-SPECIFIER PARAMETER-SPECIFIER)
		     (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST))
		    (T
		     (PARSE-WARN
		       "The parameter specifier ~s will be ignored." PARAMETER-SPECIFIER)))))
       REST
	  (UNLESS LAMBDA-LIST-COMPONENTS
	    (PARSE-WARN
	      "&REST was specified without a variable in ~s.  It will be ignored."
	      LAMBDA-LIST)
	    (GO DONE))
	  (UNLESS (CONSP LAMBDA-LIST-COMPONENTS)
	    (PARSE-WARN "The lambda list ~s is not a list." LAMBDA-LIST)
	    (GO DONE))
	  (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	    (UNLESS (CHECK-VAR "rest parameter" PARAMETER-SPECIFIER PARAMETER-SPECIFIER)
	      (PARSE-WARN "The remainder of the lambda list will be ignored")
	      (GO DONE))
	    (PUSH '&REST PARSED-LAMBDA-LIST)
	    (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST))
	  (WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
	  (WHEN (ATOM LAMBDA-LIST-COMPONENTS)
	    (PARSE-WARN "The lambda list ~s is not a list." LAMBDA-LIST)
	    (GO DONE))
	  (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	    (COND ((EQ PARAMETER-SPECIFIER '&KEY) (GO KEYS))
		  ((EQ PARAMETER-SPECIFIER '&AUX) (GO AUX))
		  ((MEMBER PARAMETER-SPECIFIER LAMBDA-LIST-KEYWORDS)
		   (PARSE-WARN
		     "The lambda list keyword ~s does not make sense in the context: ~
                      ~s -->> ~s <<-- ~s.  The remainder of the lambda list will be ~
                      ignored."
		     PARAMETER-SPECIFIER (REVERSE PARSED-LAMBDA-LIST)
		     PARAMETER-SPECIFIER LAMBDA-LIST-COMPONENTS)
		   (GO DONE))
		  (T
		   (PARSE-WARN
		     "~s found where &KEY or &AUX was expected.  The remainder of the lambda ~
                      list will be ignored."
		     PARAMETER-SPECIFIER)
		   (GO DONE))))
       KEYS
	  (PUSH '&KEY PARSED-LAMBDA-LIST)
	  (LOOP
	    (UNLESS LAMBDA-LIST-COMPONENTS (GO DONE))
	    (UNLESS (CONSP LAMBDA-LIST-COMPONENTS)
	      (PARSE-WARN
		"The lambda list ~s is not a list.  The remainder will be ignored" LAMBDA-LIST)
	      (GO DONE))
	    (BLOCK DO-KEYWORD-PARAMETER
	      (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
		(COND ((EQ PARAMETER-SPECIFIER '&ALLOW-OTHER-KEYS)
		       (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST)
		       (IF (NULL LAMBDA-LIST-COMPONENTS)
			   (GO DONE)
			   (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
			     (WHEN (EQ PARAMETER-SPECIFIER '&AUX)
			       (GO AUX))
			     (PARSE-WARN
			       "~s found where &AUX was expected.  The remainder of the ~
                                lambda list will be ignored"
			       PARAMETER-SPECIFIER)
			     (GO DONE))))
		      ((EQ PARAMETER-SPECIFIER '&AUX) (GO AUX))
		      ((MEMBER PARAMETER-SPECIFIER LAMBDA-LIST-KEYWORDS)
		       (PARSE-WARN
			 "The lambda list keyword ~s does not make sense in the context: ~
                          ~s -->> ~s <<-- ~s.  The remainder of the lambda list will be ~
                          ignored."
			 PARAMETER-SPECIFIER (REVERSE PARSED-LAMBDA-LIST)
			 PARAMETER-SPECIFIER LAMBDA-LIST-COMPONENTS)
		       (GO DONE))
		      ((TYPEP PARAMETER-SPECIFIER 'CONS)
		       (LET ((VAR-PART (FIRST PARAMETER-SPECIFIER)))
			 (COND ((CONSP VAR-PART)
				(UNLESS (SYMBOLP (FIRST VAR-PART))
				  (PARSE-WARN
				    "~s is not a valid keyword in the keyword parameter ~
                                     specifier ~s.  The parameter specifier will be ignored."
				    (FIRST VAR-PART) PARAMETER-SPECIFIER)
				  (RETURN-FROM DO-KEYWORD-PARAMETER))
				(UNLESS (AND (CONSP (CDR VAR-PART))
					     (NULL (CDDR VAR-PART)))
				  (PARSE-WARN
				    "~s is not a list of a keyword and a variable in the ~
                                     parameter specifier ~s.  The parameter specifier ~
                                     will be ignored."
				    VAR-PART PARAMETER-SPECIFIER)
				  (RETURN-FROM DO-KEYWORD-PARAMETER))
				(UNLESS (CHECK-VAR
					  "keyword parameter"
					  PARAMETER-SPECIFIER (SECOND VAR-PART))
				  (PARSE-WARN
				    "The parameter specifier ~s will be ignored."
				    PARAMETER-SPECIFIER)
				  (RETURN-FROM DO-KEYWORD-PARAMETER)))
			       ((CHECK-VAR "keyword parameter"
						PARAMETER-SPECIFIER VAR-PART))
			       (T
				(PARSE-WARN
				  "The parameter specifier ~s will be ignored."
				  PARAMETER-SPECIFIER)
				(RETURN-FROM DO-KEYWORD-PARAMETER)))
			 (MULTIPLE-VALUE-BIND (INIT-SUCCESS-P TAIL)
			     (CHECK-INIT PARAMETER-SPECIFIER (CDR PARAMETER-SPECIFIER))
			   (IF INIT-SUCCESS-P
			       (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST)
			       (LET ((NEW-PARAMETER-SPECIFIER `(,VAR-PART ,@TAIL)))
				 (PARSE-WARN
				   "~s will be substituted for ~s"
				   NEW-PARAMETER-SPECIFIER PARAMETER-SPECIFIER)
				 (PUSH NEW-PARAMETER-SPECIFIER PARSED-LAMBDA-LIST))))))
		      ((CHECK-VAR
			 "keyword parameter" PARAMETER-SPECIFIER PARAMETER-SPECIFIER)
		       (PUSH PARAMETER-SPECIFIER PARSED-LAMBDA-LIST))
		      (T
		       (PARSE-WARN
			 "The parameter specifier ~s will be ignored."
			 PARAMETER-SPECIFIER))))))
       AUX
	  (UNLESS ALLOW-AUXEN-P
	    (PARSE-WARN
	      "&AUX variables are not allowed in ~s.  They will be ignored."
	      LAMBDA-LIST)
	    (GO DONE))
	  (PUSH '&AUX PARSED-LAMBDA-LIST)
	  (LOOP
	    (UNLESS LAMBDA-LIST-COMPONENTS (GO DONE))
	    (UNLESS (CONSP LAMBDA-LIST-COMPONENTS)
	      (PARSE-WARN
		"The lambda list ~s is not a list."
		LAMBDA-LIST)
	      (GO DONE))
	    (BLOCK AUX-VARIABLE-SPECIFIER
	      (LET ((AUX-VARIABLE-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
		(COND ((MEMBER AUX-VARIABLE-SPECIFIER LAMBDA-LIST-KEYWORDS)
		       (PARSE-WARN
			 "The lambda list keyword ~s does not make sense in the context: ~
                          ~s -->> ~s <<-- ~s.  The keyword will be ignored."
			 AUX-VARIABLE-SPECIFIER (REVERSE PARSED-LAMBDA-LIST)
			 AUX-VARIABLE-SPECIFIER LAMBDA-LIST-COMPONENTS)
		       (RETURN-FROM AUX-VARIABLE-SPECIFIER))
		      ((TYPEP AUX-VARIABLE-SPECIFIER 'CONS)
		       (UNLESS (CHECK-VAR "aux variable" AUX-VARIABLE-SPECIFIER
					       (FIRST AUX-VARIABLE-SPECIFIER))
			 (PARSE-WARN
			   "The &aux variable specifier ~s will be ignored."
			   AUX-VARIABLE-SPECIFIER)
			 (RETURN-FROM AUX-VARIABLE-SPECIFIER))
		       (UNLESS (AND (LISTP (CDR AUX-VARIABLE-SPECIFIER))
				    (NULL (CDDR AUX-VARIABLE-SPECIFIER)))
			 (PARSE-WARN
			   "The aux variable specifier ~s is not a list of a variable ~
                            or a list of a variable and a form.  The excess components ~
                            will be ignored."
			   AUX-VARIABLE-SPECIFIER)
			 (PUSH `(,(FIRST AUX-VARIABLE-SPECIFIER)
				 ,@(AND (CONSP (CDR AUX-VARIABLE-SPECIFIER))
					(SECOND AUX-VARIABLE-SPECIFIER)))
			       PARSED-LAMBDA-LIST)
			 (RETURN-FROM AUX-VARIABLE-SPECIFIER))
		       (PUSH AUX-VARIABLE-SPECIFIER PARSED-LAMBDA-LIST))
		      ((CHECK-VAR "aux variable"
				       AUX-VARIABLE-SPECIFIER AUX-VARIABLE-SPECIFIER)
		       (PUSH AUX-VARIABLE-SPECIFIER PARSED-LAMBDA-LIST))
		      (T
		       (PARSE-WARN
			 "The aux variable specifier ~s will be ignored."
			 AUX-VARIABLE-SPECIFIER))))))
       DONE)
	(COND ((NULL PARSE-FAILED)
	       (VALUES T LAMBDA-LIST))
	      (T
	       (SETQ PARSED-LAMBDA-LIST (NREVERSE PARSED-LAMBDA-LIST))
	       (PARSE-WARN
		 "The lambda list ~s will be used instead of ~s"
		 PARSED-LAMBDA-LIST LAMBDA-LIST)
	       (VALUES NIL PARSED-LAMBDA-LIST)))))))

(DEFUN LAMBDA-LIST-COMPONENTS (LAMBDA-LIST)
  #+Genera (DECLARE (VALUES N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS RESTP
			    KEYWORDSP KEYWORDS ALLOW-OTHER-KEYS-P
			    WHOLE-P WHOLE))
  (LET ((WHOLE-P NIL)
	(WHOLE NIL)
	(N-REQUIRED-ARGUMENTS 0)
	(N-OPTIONAL-ARGUMENTS 0)
	(RESTP NIL)
	(KEYWORDSP NIL)
	(KEYWORDS NIL)
	(ALLOW-OTHER-KEYS-P NIL)
	(KWDPKG #-(or Minima Genera) NIL
		#+Genera SYS:PKG-KEYWORD-PACKAGE
		#+Minima MINIMA-INTERNALS::*KEYWORD-PACKAGE*))
    (DECLARE (FIXNUM N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS))
    (DO ()
	((NULL LAMBDA-LIST))
      (CASE (CAR LAMBDA-LIST)
	((&OPTIONAL &REST &KEY &AUX)
	 (RETURN))
	((&WHOLE)
	 (SETQ WHOLE-P T)
	 (POP LAMBDA-LIST)
	 (SETQ WHOLE (POP LAMBDA-LIST)))
	(OTHERWISE
	  (POP LAMBDA-LIST)
	  (INCF N-REQUIRED-ARGUMENTS))))
    (WHEN (EQ (CAR LAMBDA-LIST) '&OPTIONAL)
      (POP LAMBDA-LIST)
      (DO ()
	  ((NULL LAMBDA-LIST))
	(CASE (CAR LAMBDA-LIST)
	  ((&REST &KEY &AUX) (RETURN))
	  (OTHERWISE
	    (POP LAMBDA-LIST)
	    (INCF N-OPTIONAL-ARGUMENTS)))))
    (WHEN LAMBDA-LIST
      (CASE (CAR LAMBDA-LIST)
	((&KEY &AUX))
	(OTHERWISE
	  (POP LAMBDA-LIST)
	  (POP LAMBDA-LIST)
	  (SETQ RESTP T))))
    (WHEN (AND LAMBDA-LIST
	       (EQ (POP LAMBDA-LIST) '&KEY))
      (SETQ KEYWORDSP T)
      (DO ()
	  ((NULL LAMBDA-LIST))
	(CASE (CAR LAMBDA-LIST)
	  (&ALLOW-OTHER-KEYS
	    (SETQ ALLOW-OTHER-KEYS-P T)
	    (RETURN))
	  (&AUX (RETURN))
	  (OTHERWISE
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")	    0#-(or Minima Genera) (UNLESS KWDPKG (SETQ KWDPKG (FIND-PACKAGE "KEYWORD")))
	    (LET ((ARG (POP LAMBDA-LIST)))
	      (IF (SYMBOLP ARG)
		  (PUSH (INTERN (SYMBOL-NAME ARG) KWDPKG)
			KEYWORDS)
		  (LET ((ARG (CAR ARG)))
		    (PUSH (IF (SYMBOLP ARG)
			      (INTERN (SYMBOL-NAME ARG) KWDPKG)
			      (FIRST ARG))
			  KEYWORDS))))))))
    (VALUES N-REQUIRED-ARGUMENTS
	    N-OPTIONAL-ARGUMENTS
	    RESTP
	    KEYWORDSP
	    (NREVERSE KEYWORDS)
	    ALLOW-OTHER-KEYS-P
	    WHOLE-P
	    WHOLE)))

(DEFUN CLOS-LAMBDA-LISTS-CONGRUENT-P (GENERIC-FUNCTION-LAMBDA-LIST METHOD-LAMBDA-LIST)
  (MULTIPLE-VALUE-BIND (GREQUIRE GOPTIONAL GREST GKEYP GKEYS)
      (LAMBDA-LIST-COMPONENTS GENERIC-FUNCTION-LAMBDA-LIST)
    (MULTIPLE-VALUE-BIND (MREQUIRE MOPTIONAL MREST MKEYP MKEYS MALLOW)
	(LAMBDA-LIST-COMPONENTS METHOD-LAMBDA-LIST)
      (AND (= GREQUIRE MREQUIRE)
	   (= GOPTIONAL MOPTIONAL)
	   (EQ (OR GREST GKEYP) (OR MREST MKEYP))
	   (OR MALLOW
	       (NULL MKEYP)
	       (EVERY #'(LAMBDA (GKEY) (MEMBER GKEY MKEYS)) GKEYS))))))

(DEFUN COMPUTE-GENERIC-FUNCTION-LAMBDA-LIST (METHOD-LAMBDA-LIST)
  (LET ((RESULT NIL))
    (LOOP
      (WHEN (OR (NULL METHOD-LAMBDA-LIST)
		(MEMBER (CAR METHOD-LAMBDA-LIST)
			'(&OPTIONAL &REST &KEY &AUX)))
	(RETURN))
      (PUSH (POP METHOD-LAMBDA-LIST) RESULT))
    (WHEN (AND METHOD-LAMBDA-LIST
	       (EQ (CAR METHOD-LAMBDA-LIST) '&OPTIONAL))
      (PUSH (POP METHOD-LAMBDA-LIST) RESULT)
      (LOOP
	(WHEN (OR (NULL METHOD-LAMBDA-LIST)
		  (MEMBER (CAR METHOD-LAMBDA-LIST) '(&REST &KEY &AUX)))
	  (RETURN))
	(LET ((ARG (POP METHOD-LAMBDA-LIST)))
	  (TYPECASE ARG
	    (SYMBOL (PUSH ARG RESULT))
	    (LIST (PUSH (CAR ARG) RESULT))))))
    (WHEN (AND METHOD-LAMBDA-LIST (EQ (CAR METHOD-LAMBDA-LIST) '&REST))
      (PUSH (POP METHOD-LAMBDA-LIST) RESULT)
      (PUSH (POP METHOD-LAMBDA-LIST) RESULT))
    (WHEN (AND METHOD-LAMBDA-LIST (EQ (CAR METHOD-LAMBDA-LIST) '&KEY))
      (PUSH '&KEY RESULT))
    (NREVERSE RESULT)))

;;; Some of these symbols have to remain EQ across loading and dumping (for example,
;;; the gensymified lambda lists for method combinations) so just carefully intern
;;; the name in CLOS-INTERNALS, making sure it doesn't come from another package.
(DEFUN MAKE-STATIC-SYMBOL (NAME)
  (LET ((CLOS-INTERNALS (FIND-PACKAGE :CLOS-INTERNALS)))
    (LET ((SYMBOL (INTERN NAME CLOS-INTERNALS)))
      (UNLESS (EQ (SYMBOL-PACKAGE SYMBOL) CLOS-INTERNALS)
	(ERROR "MAKE-STATIC-SYMBOL attempting to make a symbol imported from another package"))
      SYMBOL)))

;;; Sources of unique names.  Always use the same symbols so that we can compare
;;; lambda expressions without walking their code.
(DEFUN MAKE-SYMBOL-GENERATOR (PREFIX)
  (LET ((INDEX 0))
    #'(LAMBDA ()
	(PROG1
	  (MAKE-STATIC-SYMBOL (GENSYM-SYMBOL-NAME PREFIX INDEX))
	  (INCF INDEX)))))

;;; This needs to work before FORMAT is there.
(DEFUN GENSYM-SYMBOL-NAME (PREFIX SUFFIX)
  (LET* ((PREFIX-LENGTH (LENGTH PREFIX))
	(SUFFIX-LENGTH (COND ((< SUFFIX 10) 1)
			     ((< SUFFIX 10) 2)
			     ((< SUFFIX 10) 3)
			     ((< SUFFIX 10) 4)
			     (T (RETURN-FROM GENSYM-SYMBOL-NAME
				  (FORMAT NIL "~A~D" PREFIX SUFFIX)))))
	(RESULT (MAKE-STRING (+ PREFIX-LENGTH SUFFIX-LENGTH))))
    (LOOP FOR I BELOW PREFIX-LENGTH DO
      (SETF (SCHAR RESULT I) (CHAR PREFIX I)))
    (LOOP FOR I DOWNFROM (+ PREFIX-LENGTH SUFFIX-LENGTH -1)
	  REPEAT SUFFIX-LENGTH
	  DO (MULTIPLE-VALUE-BIND (QUO REM)
		 (FLOOR SUFFIX 10)
	       (SETF (SCHAR RESULT I) (DIGIT-CHAR REM))
	       (SETF SUFFIX QUO)))
    RESULT))

(DEFUN WRAP-BODY-IN-VARIABLE-TRANSLATIONS (BODY TRANSLATIONS)
  `(SYMBOL-MACROLET ,TRANSLATIONS
     ,@BODY))

;;; LAMBDA-LIST is an ordinary lambda list.  We rename the variables and return a
;;; renamed lambda list and a set of translations (suitable for SYMBOL-MACROLET)
;;; which will translate between the old and new names.
(DEFUN GENSYMIFY-LAMBDA-LIST (LAMBDA-LIST-COMPONENTS)
  #+Genera (DECLARE (VALUES NEW-LAMBDA-LIST TRANSLATIONS))
  (LET ((TRANSLATIONS NIL)
	(NEW-LAMBDA-LIST NIL)
	(SYMBOL-GENERATOR (MAKE-SYMBOL-GENERATOR "MC-ARG")))
    (LABELS ((TRANSLATE-VARIABLE-NAME (VARIABLE-NAME)
	       (LET ((PAIR (SECOND (ASSOC VARIABLE-NAME TRANSLATIONS))))
		 (OR PAIR
		     (LET ((NEW (FUNCALL SYMBOL-GENERATOR)))
		       (SETQ TRANSLATIONS
			     (APPEND TRANSLATIONS (LIST (LIST VARIABLE-NAME `',NEW))))
		       NEW)))))

      (TAGBODY
	(LOOP
	  (WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
	  (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	    (CASE PARAMETER-SPECIFIER
	      (&WHOLE
		(PUSH '&WHOLE NEW-LAMBDA-LIST)
		(SETQ PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	      (&OPTIONAL (GO OPTIONAL))
	      (&REST (GO REST))
	      (&KEY (GO KEYS))
	      (&AUX (GO AUX)))
	    (PUSH (TRANSLATE-VARIABLE-NAME PARAMETER-SPECIFIER) NEW-LAMBDA-LIST)))
     OPTIONAL
	(PUSH '&OPTIONAL NEW-LAMBDA-LIST)
	(LOOP
	  (WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
	  (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	    (CASE PARAMETER-SPECIFIER
	      (&REST (GO REST))
	      (&KEY (GO KEYS))
	      (&AUX (GO AUX)))
	    (PUSH
	      (IF (TYPEP PARAMETER-SPECIFIER 'CONS)
		  (IF (CDR PARAMETER-SPECIFIER)
		      (LET* ((INIT (SECOND PARAMETER-SPECIFIER))
			     (NEW-INIT
			       (IF (CONSTANTP INIT)
				   INIT
				   (WRAP-BODY-IN-VARIABLE-TRANSLATIONS
				     `(,INIT) TRANSLATIONS))))
			(IF (CDDR PARAMETER-SPECIFIER)
			    `(,(TRANSLATE-VARIABLE-NAME (FIRST PARAMETER-SPECIFIER))
			      ,NEW-INIT
			      ,(TRANSLATE-VARIABLE-NAME (THIRD PARAMETER-SPECIFIER)))
			    `(,(TRANSLATE-VARIABLE-NAME (FIRST PARAMETER-SPECIFIER))
			      ,NEW-INIT)))
		      (TRANSLATE-VARIABLE-NAME (FIRST PARAMETER-SPECIFIER)))
		  (TRANSLATE-VARIABLE-NAME PARAMETER-SPECIFIER))
	      NEW-LAMBDA-LIST)))
     REST
	(LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	  (PUSH '&REST NEW-LAMBDA-LIST)
	  (PUSH (TRANSLATE-VARIABLE-NAME PARAMETER-SPECIFIER) NEW-LAMBDA-LIST))
	(WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
	(CASE (POP LAMBDA-LIST-COMPONENTS)
	  (&AUX (GO AUX))
	  (&KEY (GO KEYS)))
     KEYS
	(PUSH '&KEY NEW-LAMBDA-LIST)
	(LOOP
	  (UNLESS LAMBDA-LIST-COMPONENTS (GO DONE))
	  (LET ((PARAMETER-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	    (CASE PARAMETER-SPECIFIER
	      (&ALLOW-OTHER-KEYS
		(PUSH PARAMETER-SPECIFIER NEW-LAMBDA-LIST)
		(WHEN (NULL LAMBDA-LIST-COMPONENTS) (GO DONE))
		(POP LAMBDA-LIST-COMPONENTS)
		(GO AUX))
	      (&AUX (GO AUX)))
	    (FLET ((TRANSLATE-VAR-PART (VAR-PART)
		     (IF (SYMBOLP VAR-PART)
			 `(,(INTERN (SYMBOL-NAME VAR-PART)
				    #-(or Minima Genera) "KEYWORD"
				    #+Genera SYS:PKG-KEYWORD-PACKAGE
				    #+Minima MINIMA-INTERNALS::*KEYWORD-PACKAGE*)
			   ,(TRANSLATE-VARIABLE-NAME VAR-PART))
			 `(,(FIRST VAR-PART)
			   ,(TRANSLATE-VARIABLE-NAME (SECOND VAR-PART))))))
	      (PUSH
		(IF (CONSP PARAMETER-SPECIFIER)
		    (IF (CDR PARAMETER-SPECIFIER)
			(LET* ((INIT (SECOND PARAMETER-SPECIFIER))
			       (NEW-INIT
				 (IF (CONSTANTP INIT)
				     INIT
				     (WRAP-BODY-IN-VARIABLE-TRANSLATIONS
				       `(,INIT) TRANSLATIONS))))
			  `(,(TRANSLATE-VAR-PART (FIRST PARAMETER-SPECIFIER))
			    ,NEW-INIT
			    ,@(WHEN (THIRD PARAMETER-SPECIFIER)
				`(,(TRANSLATE-VARIABLE-NAME (THIRD PARAMETER-SPECIFIER))))))
			`(,(TRANSLATE-VAR-PART (FIRST PARAMETER-SPECIFIER))))
		    `(,(TRANSLATE-VAR-PART PARAMETER-SPECIFIER)))
		NEW-LAMBDA-LIST))))
     AUX
	(PUSH '&AUX NEW-LAMBDA-LIST)
	(LOOP
	  (UNLESS LAMBDA-LIST-COMPONENTS (GO DONE))
	  (LET ((AUX-VARIABLE-SPECIFIER (POP LAMBDA-LIST-COMPONENTS)))
	    (PUSH
	      (IF (CONSP AUX-VARIABLE-SPECIFIER)
		  (IF (CDR AUX-VARIABLE-SPECIFIER)
		      (LET* ((INIT (SECOND AUX-VARIABLE-SPECIFIER))
			     (NEW-INIT
			       (IF (CONSTANTP INIT)
				   INIT
				   (WRAP-BODY-IN-VARIABLE-TRANSLATIONS
				     `(,INIT) TRANSLATIONS))))
			`(,(TRANSLATE-VARIABLE-NAME (FIRST AUX-VARIABLE-SPECIFIER))
			  ,NEW-INIT))
		      (TRANSLATE-VARIABLE-NAME (FIRST AUX-VARIABLE-SPECIFIER)))
		  (TRANSLATE-VARIABLE-NAME AUX-VARIABLE-SPECIFIER))
	      NEW-LAMBDA-LIST)))
     DONE)
      (VALUES (NREVERSE NEW-LAMBDA-LIST)
	      TRANSLATIONS))))

(DEFUN CHECK-ARGUMENT-PRECEDENCE-ORDER (WARN-FUNCTION ARGUMENT-PRECEDENCE-ORDER LAMBDA-LIST)
  #+Genera (DECLARE (VALUES VALIDP PERMUATIONS))
  (LET* ((N-REQUIRED-ARGUMENTS (LAMBDA-LIST-COMPONENTS LAMBDA-LIST))
	 (REQUIRED-ARGUMENTS (SUBSEQ LAMBDA-LIST 0 N-REQUIRED-ARGUMENTS)))
    (COND (ARGUMENT-PRECEDENCE-ORDER
	   (UNLESS (AND (= (LENGTH ARGUMENT-PRECEDENCE-ORDER) N-REQUIRED-ARGUMENTS)
			(EVERY #'(LAMBDA (PARAMETER) (MEMBER PARAMETER REQUIRED-ARGUMENTS))
			       ARGUMENT-PRECEDENCE-ORDER)
			(EVERY #'(LAMBDA (PARAMETER)
				   (MEMBER PARAMETER ARGUMENT-PRECEDENCE-ORDER))
			       REQUIRED-ARGUMENTS))
	     (FUNCALL WARN-FUNCTION
		      "The argument precedence order ~s is not a permutation of the required ~@
                       parameters of ~s."
		      ARGUMENT-PRECEDENCE-ORDER LAMBDA-LIST)
	     (RETURN-FROM CHECK-ARGUMENT-PRECEDENCE-ORDER NIL))
	   (COPY-LIST
	     (MAPCAR #'(LAMBDA (PRECEDENCE-PARAMETER)
			 (POSITION PRECEDENCE-PARAMETER REQUIRED-ARGUMENTS))
		     ARGUMENT-PRECEDENCE-ORDER)))
	  (T
	   (LET ((LIST (MAKE-LIST N-REQUIRED-ARGUMENTS))
		 (I 0))
	     (MAPL #'(LAMBDA (PLACE)
		       (SETF (CAR PLACE) I)
		       (INCF I))
		   LIST)
	     (VALUES LIST))))))

(DEFUN SPECIALIZER-NAME (SPECIALIZER)
  (IF (LISTP SPECIALIZER)
      SPECIALIZER
      (CLASS-NAME SPECIALIZER)))

(DEFUN VALID-SPECIALIZER-NAME-P (SPECIALIZER-NAME)
  (OR (SYMBOLP SPECIALIZER-NAME)
      (AND (CONSP SPECIALIZER-NAME)
	   (EQ (FIRST SPECIALIZER-NAME) 'EQL)
	   (CONSP (CDR SPECIALIZER-NAME))
	   (NULL (CDDR SPECIALIZER-NAME)))
      (TYPEP SPECIALIZER-NAME 'CLASS)))

(DEFUN VALID-SPECIALIZER-P (SPECIALIZER)
  (OR (TYPEP SPECIALIZER 'CLASS)
      (AND (CONSP SPECIALIZER)
	   (EQ (FIRST SPECIALIZER) 'EQL)
	   (CONSP (CDR SPECIALIZER))
	   (NULL (CDDR SPECIALIZER)))))

(DEFUN PARSE-METHOD (NAME ORIGINAL-FORM GENERIC-FUNCTION-FINDER ENVIRONMENT WARN-FUNCTION)
  #+Genera (DECLARE (VALUES SUCCESS-P LAMBDA-LIST SPECIALIZER-NAMES QUALIFIERS FUNCTION
			    DOCUMENTATION OTHER))
  (MACROLET ((PARSE-WARN (WARNING &REST ARGS)
	       `(FUNCALL WARN-FUNCTION ,WARNING ,@ARGS)))
    (LET* ((FUNCTION-NAME (SECOND NAME))
	   (FORM ORIGINAL-FORM)
	   (METHOD-QUALIFIERS
	     (LET ((QUALIFIERS))
	       (LOOP
		 (UNLESS (CONSP FORM)
		   (PARSE-WARN
		     "While checking qualifiers, the non-cons ~s was encountered."
		     FORM)
		   (RETURN-FROM PARSE-METHOD NIL))
		 (LET ((NEXT-ELT (FIRST FORM)))
		   (WHEN (LISTP NEXT-ELT)
		     (RETURN (REVERSE QUALIFIERS)))
		   (PUSH NEXT-ELT QUALIFIERS))
		 (POP FORM))))
	   ;; Know that FORM is a cons because the qualifiers parser has
	   ;; already checked it.
	   (SPECIALIZED-LAMBDA-LIST (POP FORM))
	   (LAMBDA-LIST NIL)
	   (SPECIALIZED-PARAMETERS NIL)
	   (SPECIALIZER-NAMES NIL)
	   (DOCUMENTATION NIL)
	   (DECLARES NIL)
	   (BODY NIL)
	   (SUCCESS-P T))
      (SETF (CDDDR NAME) (COPY-LIST METHOD-QUALIFIERS))
      (LET ((SPECIALIZED-LAMBDA-LIST-PLACE SPECIALIZED-LAMBDA-LIST)
	    (REQUIRED-PARAMETERS NIL)
	    (REVERSED-SPECIALIZER-NAMES NIL))
	(LOOP
	  (WHEN (NULL SPECIALIZED-LAMBDA-LIST-PLACE) (RETURN))
	  (UNLESS (CONSP SPECIALIZED-LAMBDA-LIST-PLACE)
	    (PARSE-WARN
	      "The specialized lambda list ~s is not a list.  The portion of the ~
               specialized lambda list which has already been parsed will be used."
	      SPECIALIZED-LAMBDA-LIST)
	    (RETURN))
	  (LET ((NEXT-ELT (POP SPECIALIZED-LAMBDA-LIST-PLACE)))
	    (WHEN (MEMBER NEXT-ELT '(&OPTIONAL &REST &KEY &AUX))
	      (PUSH NEXT-ELT REQUIRED-PARAMETERS)
	      (RETURN))
	    (COND ((SYMBOLP NEXT-ELT)
		   (PUSH NEXT-ELT REQUIRED-PARAMETERS)
		   (PUSH T REVERSED-SPECIALIZER-NAMES))
		  ((AND (CONSP NEXT-ELT)
			(CONSP (CDR NEXT-ELT))
			(NULL (CDDR NEXT-ELT)))
		   ;; CHECK-LAMBDA-LIST will check the required parameter
		   (PUSH (FIRST NEXT-ELT) REQUIRED-PARAMETERS)
		   (PUSH (FIRST NEXT-ELT) SPECIALIZED-PARAMETERS)
		   (LET ((SPECIALIZER-NAME (SECOND NEXT-ELT)))
		     (COND ((VALID-SPECIALIZER-NAME-P SPECIALIZER-NAME)
			    (PUSH SPECIALIZER-NAME REVERSED-SPECIALIZER-NAMES))
			   (T
			    (PARSE-WARN
			      "The specialized parameter ~s does not have a specializer ~
                               name which is either a symbol, a class, or a list of the form ~
                               (EQL form).  A specializer-name of T will be substituted ~
                               so that parsing may continue."
			      NEXT-ELT)
			    (PUSH T REVERSED-SPECIALIZER-NAMES)))))
		  (T
		   (PARSE-WARN
		     "The required parameter ~s is not a variable or a specialized ~
                      parameter.  The parameter will be skipped."
		     NEXT-ELT)))))
	(SETQ LAMBDA-LIST (NCONC (NREVERSE REQUIRED-PARAMETERS) SPECIALIZED-LAMBDA-LIST-PLACE))
	(SETQ SPECIALIZER-NAMES (NREVERSE REVERSED-SPECIALIZER-NAMES)))
      (SETF (THIRD NAME) SPECIALIZER-NAMES)
      (MULTIPLE-VALUE-BIND (MY-SUCCESS-P NEW-LAMBDA-LIST)
	  (CHECK-LAMBDA-LIST LAMBDA-LIST T T NIL)
	(UNLESS MY-SUCCESS-P
	  (SETQ LAMBDA-LIST NEW-LAMBDA-LIST)
	  (SETQ SUCCESS-P NIL)))
      (MULTIPLE-VALUE-SETQ (BODY DECLARES DOCUMENTATION)
	(PARSE-TOPLEVEL-BODY FORM ENVIRONMENT LAMBDA-LIST))
      ;; We need to get hold of a prototype of the generic function and the method so
      ;; we can call MAKE-METHOD-LAMBDA.  This can create a generic function, which is
      ;; okay, but it also sticks it in the compilation environment, which isn't
      ;; supposed to happen yet, so this isn't quite right.
      (MULTIPLE-VALUE-BIND (GENERIC-INSTANCE METHOD-CLASS-INSTANCE)
	  (FUNCALL GENERIC-FUNCTION-FINDER FUNCTION-NAME LAMBDA-LIST)
	(MULTIPLE-VALUE-BIND (METHOD-LAMBDA OTHER-STUFF)
	    (MAKE-METHOD-LAMBDA
	      GENERIC-INSTANCE
	      METHOD-CLASS-INSTANCE
	      `(LAMBDA ,LAMBDA-LIST
		 #+Genera (DECLARE (SYS:FUNCTION-NAME ,NAME))
		 #+Minima (DECLARE (MINIMA-INTERNALS::FUNCTION-NAME ,NAME))
		 (DECLARE ,@(MAPCAN #'(LAMBDA (SPECIALIZER-NAME ARGUMENT)
					(WHEN (AND (SYMBOLP SPECIALIZER-NAME)
						   (NOT (EQ SPECIALIZER-NAME T)))
					  `((TYPE ,SPECIALIZER-NAME ,ARGUMENT))))
				    SPECIALIZER-NAMES
				    LAMBDA-LIST))
		 (DECLARE ,@DECLARES)
		 ;; Use these arguments so that they don't get "bound but never used"
		 ;; warnings.
		 ,@SPECIALIZED-PARAMETERS
		 ,@(WRAP-BODY-WITH-BLOCK FUNCTION-NAME BODY))
	      ENVIRONMENT)
	  (VALUES SUCCESS-P
		  LAMBDA-LIST
		  `(LIST
		     ,@(MAPCAR #'(LAMBDA (SPECIALIZER-NAME)
				   (ETYPECASE SPECIALIZER-NAME
				     (SYMBOL `(FIND-CLASS ',SPECIALIZER-NAME))
				     (LIST ``(EQL ,,(SECOND SPECIALIZER-NAME)))
				     (CLASS SPECIALIZER-NAME)))
			       SPECIALIZER-NAMES))
		  METHOD-QUALIFIERS
		  METHOD-LAMBDA
		  DOCUMENTATION
		  OTHER-STUFF))))))

;;;; File Declaration Environment Interface

;;; Functions for communicating with a compile-file environment.
;;; None are expected to be called outside the dynamic environment of a compile-file.

;;; The defined interface functions are FILE-DECLARATION (which works
;;; with SETF) and NOTICE-COMPILED-FUNCTION.  Both are provided in cloe
;;; by a compatible interface, and the system: symbols imported into
;;; clos-internals.  See them for commentary.

;;; Return a static version of an environment object which may have dynamic extent.
(DEFUN STATIC-ENVIRONMENT (ENVIRONMENT)
  (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      'COMPILE-FILE
      NIL))

;;; The above comment apprears to be false in this case -- Cyphers 8/3/90
#+CLOE-Runtime
(DEFUN NOTICE-COMPILED-FUNCTION (FUNCTION-SPECIFIER)
  FUNCTION-SPECIFIER)

#-CLOE-Runtime
(PROGN


;;; Tell the file compilation environment that specified function is being
;;; defined by this compilation.  This might do things like remember
;;; the function in the list of things defined by this generic pathname,
;;; and ensure that no referenced-but-undefined warnings occur.
(DEFUN NOTICE-COMPILED-FUNCTION (FUNCTION-SPECIFIER)
  #+Genera (PROGN
	     (COMPILER:FUNCTION-DEFINED FUNCTION-SPECIFIER)
	     (COMPILER:NOTICE-COMPILED-FUNCTION FUNCTION-SPECIFIER))
  FUNCTION-SPECIFIER)


;;; This is a cons of a flag and a getf-style plist.
;;; The association lets us rebind the variable but continue to update shadowed values
;;; since the pair is updated with rplacd.
;;; The flag says that if we start a new environment, this one should be used;  this
;;; would be specified by make-system, for instance, to keep the nested compile-files
;;; from each making their own.
;;;If an implementation properly binds this variable in compile-file etc., its global value
;;; should be nil.  A none-nil global value just gives us a global subjunctive environment
;;; to play with rather than none at all.
#-Genera
(DEFVAR *FILE-DECLARATION-TABLES*
	(CONS NIL NIL))


#-Genera
(DEFUN STANDARD-FILE-DECLARATION-TABLE-CREATOR (WHAT)
  (DECLARE (IGNORE WHAT))
  (MAKE-HASH-TABLE :TEST #'EQ))


#-Genera
(DEFUN EQUAL-FILE-DECLARATION-TABLE-CREATOR (WHAT)
  (DECLARE (IGNORE WHAT))
  (MAKE-HASH-TABLE :TEST #'EQUAL))


;;; Fetch a miscellaneous association from the file compilation
;;; database.  KIND is expected to be a symbol.
(DEFUN FILE-DECLARATION (NAME KIND)
  #+Genera (COMPILER:FILE-DECLARATION NAME KIND)
  #-Genera (LET ((SUBTABLE (GETF (CDR *FILE-DECLARATION-TABLES*) KIND)))
	     (IF SUBTABLE
		 (GETHASH NAME SUBTABLE)
		 (VALUES NIL NIL))))


(DEFUN (SETF FILE-DECLARATION) (VALUE NAME KIND)
  (CHECK-TYPE KIND SYMBOL)
  #+Genera (COMPILER:FILE-DECLARE NAME KIND VALUE)
  #-Genera (IF *FILE-DECLARATION-TABLES*
	       (SETF (GETHASH NAME (OR (GETF (CDR *FILE-DECLARATION-TABLES*) KIND)
				       (SETF (GETF (CDR *FILE-DECLARATION-TABLES*) KIND)
					     (FUNCALL (OR (GET KIND 'FILE-DECLARATION-TABLE-CREATOR)
							  #'STANDARD-FILE-DECLARATION-TABLE-CREATOR)
						      KIND))))
		     VALUE)
	       (CERROR "Never Mind."
		       "Cannot store file declaration, there is no environment."))
  VALUE)


#-Genera
(DOLIST (X '(FDEFINITION))
  (SETF (GET X 'FILE-DECLARATION-TABLE-CREATOR) 'EQUAL-FILE-DECLARATION-TABLE-CREATOR))


#-Genera
(DEFMACRO WITH-FILE-DECLARATION-ENVIRONMENT ((&KEY OVERRIDE-DYNAMIC-NESTINGS) &BODY BODY)
  `(LET ((*FILE-DECLARATION-TABLES*
	   (IF (CAR *FILE-DECLARATION-TABLES*)
	       *FILE-DECLARATION-TABLES*
	       (CONS ,OVERRIDE-DYNAMIC-NESTINGS NIL))))
     ,@BODY))

);;;PROGN

;;; We keep a list of class names to find the classes (this makes
;;; it easy to completely reset the state for development purposes).
(DEFVAR *ALL-CLASS-NAMES* NIL)			;List of names of all classes
#+Genera
(DEFVAR *ALL-CLASS-NAMES-AARRAY*		;For editor's completing reader
	(SI:MAKE-AARRAY 3000. :NAME "class name completion table"
			      :AREA SYS:PERMANENT-STORAGE-AREA))

(DEFUN REMOVE-ALL-CLASSES ()
  #+(OR Genera Minima)
  (FLET ((UNBIND-CLASS-HOLDER (CLASS-NAME)
	   (LET ((HOLDER (GET CLASS-NAME 'CLASS-HOLDER)))
	     (WHEN HOLDER
	       (LOCATION-MAKUNBOUND (LOCF (CLASS-HOLDER-CLASS HOLDER)) 'CLASS)))))
    (MAPC #'UNBIND-CLASS-HOLDER *ALL-CLASS-NAMES*)
    #+Genera (MAPC #'UNBIND-CLASS-HOLDER FLAVOR:*ALL-FLAVOR-NAMES*))
  #+Genera (SETF (FILL-POINTER *ALL-CLASS-NAMES-AARRAY*) 0)
  #+Genera (SETF (SI:AARRAY-SORT-STATE *ALL-CLASS-NAMES-AARRAY*) 0)
  (SETQ *ALL-CLASS-NAMES* NIL))

(DEFUN FIND-CLASS-INTERNAL (CLASS-NAME ENVIRONMENT INHERITP)
  #+Genera (DECLARE (VALUES CLASS FOUNDP))
  (WHEN (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (CLASS FOUNDP)
	(FILE-DECLARATION CLASS-NAME 'CLASS)
      (WHEN (OR FOUNDP (NULL INHERITP))
	(RETURN-FROM FIND-CLASS-INTERNAL (VALUES CLASS FOUNDP)))))
  (LET ((HOLDER (LOAD-CLASS-HOLDER CLASS-NAME :CREATEP NIL)))
    (VALUES (AND HOLDER (CLASS-HOLDER-BOUNDP HOLDER) (CLASS-HOLDER-CLASS HOLDER))
	    HOLDER)))

(DEFUN (SETF FIND-CLASS-INTERNAL) (CLASS CLASS-NAME ENVIRONMENT INHERITP)
  (DECLARE (IGNORE INHERITP))
  (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      (SETF (FILE-DECLARATION CLASS-NAME 'CLASS) CLASS)
      (LET* ((HOLDER (LOAD-CLASS-HOLDER CLASS-NAME :CREATEP CLASS))
	     (OLD-CLASS (AND HOLDER (CLASS-HOLDER-BOUNDP HOLDER) (CLASS-HOLDER-CLASS HOLDER)))
	     (CONSTRUCTORS (AND HOLDER (CLASS-HOLDER-CONSTRUCTORS HOLDER))))
	(UNLESS (EQ CLASS OLD-CLASS)
	  (COND ((NULL CLASS)
		 (SETF *ALL-CLASS-NAMES* (DELETE CLASS-NAME *ALL-CLASS-NAMES*))
		 #+Genera
		 (SI:AARRAY-DELETE *ALL-CLASS-NAMES-AARRAY* (SYMBOL-NAME CLASS-NAME) CLASS-NAME
				   'ATOM)
		 (CLASS-HOLDER-MAKUNBOUND HOLDER))
		(T
		 (PUSHNEW CLASS-NAME *ALL-CLASS-NAMES*)
		 #+Genera
		 (SI:AARRAY-INSERT *ALL-CLASS-NAMES-AARRAY* (SYMBOL-NAME CLASS-NAME) CLASS-NAME
				   'ATOM)
		 (SETF (CLASS-HOLDER-CLASS HOLDER) CLASS)
		 (WHEN CONSTRUCTORS
		   (SETF (CLASS-CONSTRUCTORS CLASS)
			 (UNION (CLASS-CONSTRUCTORS CLASS) CONSTRUCTORS)))
		 ;; Tell DW that CLASS-NAME now denotes a class
		 (WITH-PENDING-DW-UPDATES
		   #+Genera
		   (DW:MAYBE-CHECK-TYPE-REDEFINITION CLASS-NAME 'DEFCLASS :7.2-TYPE T)
		   (WHEN *CLOS-INITIALIZED-P*
		     (NOTICE-CLASS-NAME-CHANGE CLASS)))))
	  (WHEN OLD-CLASS
	    (WHEN CONSTRUCTORS
	      (SETF (CLASS-CONSTRUCTORS OLD-CLASS)
		    (SET-DIFFERENCE (CLASS-CONSTRUCTORS OLD-CLASS) CONSTRUCTORS)))
	    (NOTICE-CLASS-NAME-CHANGE OLD-CLASS)))
	CLASS)))

#+Genera
(DEFVAR *ALL-GENERIC-FUNCTION-NAMES-AARRAY*	;For completion over generic function names
	(SI:MAKE-AARRAY 7000. :NAME "funcallable instance name completion table"
			:AREA SYS:PERMANENT-STORAGE-AREA))

;;; If there are any encapsulations around the function, this is supposed to peel
;;; them away from what it returns.
(DEFUN FDEFINITION-IN-ENVIRONMENT (FUNCTION-NAME ENVIRONMENT &OPTIONAL (INHERITP T))
  (WHEN (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (VALUE FOUNDP)
	(FILE-DECLARATION FUNCTION-NAME 'FDEFINITION)
      (WHEN FOUNDP
	(RETURN-FROM FDEFINITION-IN-ENVIRONMENT VALUE))
      (UNLESS INHERITP
	#+Genera (ERROR 'SYS:UNDEFINED-FUNCTION :FUNCTION-NAME FUNCTION-NAME)
	#-Genera (CERROR "Use runtime-environment definition, if any."
			 "~S is not defined."
			 FUNCTION-NAME))))
  #+Genera (SETF FUNCTION-NAME (SI:UNENCAPSULATE-FUNCTION-SPEC FUNCTION-NAME))
  (FDEFINITION FUNCTION-NAME))

(DEFUN (SETF FDEFINITION-IN-ENVIRONMENT) (DEFINITION FUNCTION-NAME ENVIRONMENT
					   &OPTIONAL (INHERITP T))
  (DECLARE (IGNORE INHERITP))
  (COND ((COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	 (SETF (FILE-DECLARATION FUNCTION-NAME 'FDEFINITION) DEFINITION)
	 DEFINITION)
	(T
	  #+Genera (SETF FUNCTION-NAME (SI:UNENCAPSULATE-FUNCTION-SPEC FUNCTION-NAME))
	  (SETF (FDEFINITION FUNCTION-NAME) DEFINITION))))

#-Genera
(DEFUN FBOUNDP-IN-ENVIRONMENT (FUNCTION-NAME ENVIRONMENT)
  (WHEN (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (VALUE FOUNDP)
	(FILE-DECLARATION FUNCTION-NAME 'FDEFINITION)
      (DECLARE (IGNORE VALUE))
      (RETURN-FROM FBOUNDP-IN-ENVIRONMENT FOUNDP)))
  (FBOUNDP FUNCTION-NAME))


#+Genera
(SYS:ADD-INITIALIZATION "Sort CLOS Aarrays"
  '(PROGN (SI:SORT-AARRAY *ALL-CLASS-NAMES-AARRAY*)
	  (SETQ *ALL-CLASS-NAMES-AARRAY*
		(SYS:FOLLOW-STRUCTURE-FORWARDING *ALL-CLASS-NAMES-AARRAY*))
	  (SI:SORT-AARRAY *ALL-GENERIC-FUNCTION-NAMES-AARRAY*)
	  (SETQ *ALL-GENERIC-FUNCTION-NAMES-AARRAY*
		(SYS:FOLLOW-STRUCTURE-FORWARDING *ALL-GENERIC-FUNCTION-NAMES-AARRAY*)))
  '(:BEFORE-COLD))



;#+GENERA
;(DEFUN (:PROPERTY CONSTRUCTOR SYS:FUNCTION-SPEC-HANDLER) (FUNCTION FUNCTION-SPEC &REST ARGS)
;  (COND ((AND (= 2 (LIST-LENGTH FUNCTION-SPEC))
;	      (TYPEP (SECOND FUNCTION-SPEC) 'CONSTRUCTOR))
;	 (LET ((CONSTRUCTOR (SECOND FUNCTION-SPEC)))
;	   (CASE FUNCTION
;	     (SYS:FDEFINE
;	       (SETF (SLOT-VALUE CONSTRUCTOR 'CELL) (FIRST ARGS)))
;	     (SYS:FDEFINITION-LOCATION
;	       (LOCF (SLOT-VALUE CONSTRUCTOR 'CELL)))
;	     (SYS:FDEFINITION
;	       (SLOT-VALUE CONSTRUCTOR 'CELL))
;	     (SYS:FUNDEFINE
;	       (SLOT-MAKUNBOUND CONSTRUCTOR 'CELL))
;	     (SYS:FDEFINEDP
;	       (SLOT-BOUNDP CONSTRUCTOR 'CELL))
;	     (SI:DEFINITION-HAS-LOCATION-P T)
;	     (SYS:VALIDATE-FUNCTION-SPEC T)
;	     (OTHERWISE
;	       (APPLY #'SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARGS)))))
;	(T
;	 (CASE FUNCTION
;	   (SYS:VALIDATE-FUNCTION-SPEC NIL)
;	   (OTHERWISE (ERROR "Invalid function spec ~S." FUNCTION-SPEC))))))

(DEFVAR-RESETTABLE *ABORT-METHOD-COMBINATION-TAG* NIL)

(DEFMACRO WITHOUT-METHOD-COMBINATION-ERRORS-IF (TEST
						(&BODY BODY)
						(VARIABLES &BODY ERROR-RECOVERY))
  (LET ((NAME (GENSYM)))
    `(LET* ((,NAME ',NAME)
	    (*ABORT-METHOD-COMBINATION-TAG* (IF ,TEST ,NAME NIL)))
       (BLOCK ,NAME
	 (MULTIPLE-VALUE-BIND ,VARIABLES
	     (CATCH ,NAME
	       (RETURN-FROM ,NAME
		 (PROGN ,@BODY)))
	   ,@ERROR-RECOVERY)))))

(DEFMACRO SIGNALLING-METHOD-COMBINATION-ERROR (ERROR-VALUES &BODY BODY)
  `(IF *ABORT-METHOD-COMBINATION-TAG*
       (THROW *ABORT-METHOD-COMBINATION-TAG* ,ERROR-VALUES)
       (PROGN ,@BODY)))

;;; True if FORM does not depend on anything lexically bound in ENV
;;; including local SPECIAL declarations, and in that case the value is
;;; one of CONSTANT, SPECIAL, SIMPLE, READER, or WRITER
#+Genera
(DEFUN INITFORM-INLINABLE (FORM ENV)
  (MULTIPLE-VALUE-BIND (NOTEPAD FREE-VARIABLES FREE-BLOCKS FREE-TAGS NIL FREE-FUNCTIONS)
      (LT:ANNOTATE-FORM FORM NIL ENV)
    (UNLESS (OR FREE-BLOCKS
		FREE-TAGS
		(DOLIST (VARIABLE FREE-VARIABLES NIL)
		  (WHEN (OR (ASSOC VARIABLE (SI:ENV-VARIABLES ENV))
			    (NOT (LT:GLOBAL-SPECIAL-VARIABLE-P VARIABLE ENV)))
		    (RETURN T)))
		(DOLIST (FUNCTION FREE-FUNCTIONS NIL)
		  (WHEN (SI:LOCAL-FUNCTION-DEFINITION FUNCTION ENV)
		    (RETURN T))))
      ;; No lexical dependency, classify type of form
      (COND ((CONSTANTP FORM ENV) 'CONSTANT)
	    ((AND (SYMBOLP FORM) (NOT (LT:SYMBOL-MACRO-P FORM ENV))) 'SPECIAL)
	    ((LT::NOTEPAD-WRITTEN NOTEPAD) 'WRITER)
	    ((LT::NOTEPAD-READ NOTEPAD) 'READER)
	    (T 'SIMPLE)))))

#-Genera
(DEFUN INITFORM-INLINABLE (FORM ENV)
  ;;@@@@ This needs help.  Maybe i SHOULD port LT.
  (COND ((CONSTANTP FORM ENV) 'CONSTANT)))

(DEFUN MAKE-INITFUNCTION (FORM ENV TYPE CLASS-NAME NAME)
  #-(OR Genera Minima) (DECLARE (IGNORE CLASS-NAME NAME))
  (COND ((CONSTANTP FORM ENV)
	 `(CONSTANTLY ,FORM))
	#+Genera
	((AND (SYMBOLP FORM)
	      (EQ :SPECIAL (FCLI::VARIABLE-INFORMATION FORM ENV)))
	 `(SPECIAL-VARIABLE-VALUE ',FORM))
	(T
	 `#'(LAMBDA ()
	      ,@(WHEN TYPE
		  `((DECLARE #+Genera (SYS:FUNCTION-NAME (,TYPE ,CLASS-NAME ,NAME))
			     #+Minima (MINIMA-INTERNALS::FUNCTION-NAME (,TYPE ,CLASS-NAME ,NAME)))))
	      ,FORM))))

#+Genera
(DEFUN SPECIAL-VARIABLE-VALUE (VARIABLE)
  #+Genera (SYS:MAKE-LEXICAL-CLOSURE (LOCF (SYMBOL-VALUE VARIABLE))
				     #'(LAMBDA (ENVIRONMENT)
					 (DECLARE (CLOS:PRINT-OBJECT
						    SPECIAL-VARIABLE-VALUE-PRINTER))
					 (LOCATION-CONTENTS ENVIRONMENT)))
  #-Genera #'(LAMBDA () (SYMBOL-VALUE VARIABLE)))

#+Genera
(DEFUN SPECIAL-VARIABLE-VALUE-PRINTER (OBJECT STREAM)
  (WHEN (TYPEP OBJECT 'SYS:LEXICAL-CLOSURE)
    (SI:PRINTING-RANDOM-OBJECT (OBJECT STREAM)
      (FORMAT STREAM "FUNCTION Special Variable Value ~S"
	      (COMPILER:DISASSEMBLE-DECODE-LOCATIVE
		(SYS:LEXICAL-CLOSURE-ENVIRONMENT OBJECT))))))

#+Genera
(SI:DEFINE-FUNCTION-SPEC-HANDLER STRUCTURE-SLOT-INITFUNCTION (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((VALID (NULL (CDR (LAST FUNCTION-SPEC))))
	 (CLASS-NAME (AND VALID (SECOND FUNCTION-SPEC)))
	 (SLOT-NAME (AND VALID (THIRD FUNCTION-SPEC))))
    (CASE FUNCTION
      ((SYS:VALIDATE-FUNCTION-SPEC)
       (AND VALID (= (LENGTH FUNCTION-SPEC) 3) (SYMBOLP CLASS-NAME) (SYMBOLP SLOT-NAME)))
      ((SYS:FDEFINEDP)
       (NOT (NULL (STRUCTURE-SLOT-INITFUNCTION CLASS-NAME SLOT-NAME :ERROR NIL))))
      ((SYS:FDEFINITION)
       (STRUCTURE-SLOT-INITFUNCTION CLASS-NAME SLOT-NAME))
      ((SYS:FUNCTION-PARENT)
       (VALUES CLASS-NAME 'ZL:DEFSTRUCT))
      (OTHERWISE
	(SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

#+Genera
(SI:DEFINE-FUNCTION-SPEC-HANDLER STANDARD-CLASS-SLOT-INITFUNCTION (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((VALID (NULL (CDR (LAST FUNCTION-SPEC))))
	 (CLASS-NAME (AND VALID (SECOND FUNCTION-SPEC)))
	 (SLOT-NAME (AND VALID (THIRD FUNCTION-SPEC))))
    (CASE FUNCTION
      ((SYS:VALIDATE-FUNCTION-SPEC)
       (AND VALID (= (LENGTH FUNCTION-SPEC) 3) (SYMBOLP CLASS-NAME) (SYMBOLP SLOT-NAME)))
      ((SYS:FDEFINEDP)
       (LET ((CLASS (FIND-CLASS CLASS-NAME NIL)))
	 (AND CLASS
	      (LET ((SLOT (FIND SLOT-NAME (CLASS-DIRECT-SLOTS CLASS)
				:KEY #'SLOT-DEFINITION-NAME)))
		(AND SLOT
		     (NOT (NULL (SLOT-DEFINITION-INITFUNCTION SLOT))))))))
      ((SYS:FDEFINITION)
       (SLOT-DEFINITION-INITFUNCTION
	 (FIND SLOT-NAME (CLASS-DIRECT-SLOTS (FIND-CLASS CLASS-NAME))
	       :KEY #'SLOT-DEFINITION-NAME)))
      ((SYS:FUNCTION-PARENT)
       (VALUES CLASS-NAME 'DEFCLASS))
      (OTHERWISE
	(SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

#+Genera
(SI:DEFINE-FUNCTION-SPEC-HANDLER STANDARD-CLASS-DEFAULT-INITARG-FUNCTION (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((VALID (NULL (CDR (LAST FUNCTION-SPEC))))
	 (CLASS-NAME (AND VALID (SECOND FUNCTION-SPEC)))
	 (INITARG (AND VALID (THIRD FUNCTION-SPEC))))
    (CASE FUNCTION
      ((SYS:VALIDATE-FUNCTION-SPEC)
       (AND VALID (= (LENGTH FUNCTION-SPEC) 3) (SYMBOLP CLASS-NAME) (SYMBOLP INITARG)))
      ((SYS:FDEFINEDP)
       (LET ((CLASS (FIND-CLASS CLASS-NAME NIL)))
	 (AND CLASS
	      (LET ((ENTRY (ASSOC INITARG (CLASS-DIRECT-DEFAULT-INITARGS CLASS))))
		(AND ENTRY
		     (NOT (NULL (THIRD ENTRY))))))))
      ((SYS:FDEFINITION)
       (THIRD (ASSOC INITARG (CLASS-DIRECT-DEFAULT-INITARGS (FIND-CLASS CLASS-NAME)))))
      ((SYS:FUNCTION-PARENT)
       (VALUES CLASS-NAME 'DEFCLASS))
      (OTHERWISE
	(SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

#+Genera
(SI:DEFINE-FUNCTION-SPEC-HANDLER STRUCTURE-PRINT-FUNCTION (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((VALID (NULL (CDR (LAST FUNCTION-SPEC))))
	 (CLASS-NAME (AND VALID (SECOND FUNCTION-SPEC))))
    (CASE FUNCTION
      ((SYS:VALIDATE-FUNCTION-SPEC)
       (AND VALID (= (LENGTH FUNCTION-SPEC) 2) (SYMBOLP CLASS-NAME)))
      ((SYS:FDEFINEDP)
       (NOT (NULL (STRUCTURE-PRINT-FUNCTION CLASS-NAME :ERROR NIL))))
      ((SYS:FDEFINITION)
       (STRUCTURE-PRINT-FUNCTION CLASS-NAME))
      ((SYS:FUNCTION-PARENT)
       (VALUES CLASS-NAME 'ZL:DEFSTRUCT))
      (OTHERWISE
	(SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

#+Genera
(SI:DEFINE-DIGESTABLE-SPECIAL-FORM GENERIC-FLET
				   (&WHOLE SI:FORM FUNCTIONS &BODY BODY &ENVIRONMENT SI:ENV)
  ;;(DECLARE LT:(ARG-TEMPLATE))
  (LET ((REAL-FUNCTIONS
	  (MAPCAR #'(LAMBDA (FUNCTION)
		      (LET* ((NAME (POP FUNCTION))
			     (LAMBDA-LIST (POP FUNCTION)))
			(MULTIPLE-VALUE-BIND (LAMBDA-LIST CLASS INITARGS METHODS)
			    (PARSE-DEFGENERIC NIL LAMBDA-LIST FUNCTION SI:ENV)
			  `(,NAME
			    ,(SI:DIGEST-FORM `(MAKE-INSTANCE ',CLASS
							     :LAMBDA-LIST ',LAMBDA-LIST
							     ,@METHODS ,@INITARGS)
					     SI:ENV)))))
		  FUNCTIONS))
	(REAL-DECLARATIONS `((NOTINLINE ,@(MAPCAR #'FIRST FUNCTIONS)))))
    ;; Build new environment for digestion only.
    (LET ((FUNCTIONS REAL-FUNCTIONS)
	  (DECLARATIONS REAL-DECLARATIONS)
	  (E SI:ENV))
      (SI:INTERPRET-FUNCTION-BINDINGS
	(FUNCTIONS GENERIC-FLET 5
		   (NEW-ENV SI:ENV (POP E) (POP E) (POP E) (POP E) (CAR E)
			    DECLARATIONS)
		   (DECLARATIONS E FUNCTIONS))
	`(DIGESTED-GENERIC-FLET ,SI:FORM ,REAL-FUNCTIONS ,REAL-DECLARATIONS
				,@(SI:DIGEST-BODY BODY NEW-ENV))))))

#+Genera
(SI:DEFINE-DIGESTED-SPECIAL-FORM DIGESTED-GENERIC-FLET (BODY ENV)
  ;; Discard the special-form-name and the original-form
  (SETQ BODY (CDDR BODY))  
  ;; Create all the variables we will need before doing any %PUSHes
  (LET ((FUNCTIONS (POP BODY))
	(DECLARATIONS (POP BODY))
	(E ENV))
    ;; Build new environment
    (SI:INTERPRET-FUNCTION-BINDINGS
      (FUNCTIONS GENERIC-FLET 5
		 (NEW-ENV ENV (POP E) (POP E) (POP E) (POP E) (CAR E)
			  DECLARATIONS)
		 (DECLARATIONS E FUNCTIONS))
      ;; Evaluate the body
      (SI:EVAL-BODY BODY NEW-ENV))))

;;;

#+Genera
(SI:DEFINE-DIGESTABLE-SPECIAL-FORM GENERIC-LABELS
				   (&WHOLE SI:FORM FUNCTIONS &BODY BODY &ENVIRONMENT SI:ENV)
  ;;(DECLARE LT:(ARG-TEMPLATE))
  (LET ((REAL-FUNCTIONS
	  (MAPCAR #'(LAMBDA (FUNCTION)
		      (LET* ((NAME (POP FUNCTION))
			     (LAMBDA-LIST (POP FUNCTION)))
			(MULTIPLE-VALUE-BIND (LAMBDA-LIST CLASS INITARGS METHODS)
			    (PARSE-DEFGENERIC NIL LAMBDA-LIST FUNCTION SI:ENV)
			  `(,NAME (MAKE-INSTANCE ',CLASS :LAMBDA-LIST ',LAMBDA-LIST
						 ,@METHODS ,@INITARGS)))))
		  FUNCTIONS))
	(REAL-DECLARATIONS `((NOTINLINE ,@(MAPCAR #'FIRST FUNCTIONS)))))
    ;; Build new environment for digestion only.
    (LET ((FUNCTIONS REAL-FUNCTIONS)
	  (DECLARATIONS REAL-DECLARATIONS)
	  (E SI:ENV))
      (SI:INTERPRET-FUNCTION-BINDINGS
	(FUNCTIONS GENERIC-LABELS 5
		   (NEW-ENV SI:ENV (POP E) (POP E) (POP E) (POP E) (CAR E)
			    DECLARATIONS)
		   (DECLARATIONS E FUNCTIONS))
	(DOLIST (FUNCTION REAL-FUNCTIONS)
	  (SETF (SECOND FUNCTION) (SI:DIGEST-FORM (SECOND FUNCTION) NEW-ENV)))
	`(DIGESTED-GENERIC-LABELS ,SI:FORM ,REAL-FUNCTIONS ,REAL-DECLARATIONS
				  ,@(SI:DIGEST-BODY BODY NEW-ENV))))))

#+Genera
(SI:DEFINE-DIGESTED-SPECIAL-FORM DIGESTED-GENERIC-LABELS (BODY ENV)
  ;; Discard the special-form-name and the original-form
  (SETQ BODY (CDDR BODY))  
  ;; Create all the variables we will need before doing any %PUSHes
  (LET ((FUNCTIONS (POP BODY))
	(DECLARATIONS (POP BODY))
	(E ENV))
    ;; Build new environment
    (SI:INTERPRET-FUNCTION-BINDINGS
      (FUNCTIONS GENERIC-LABELS 5
		 (NEW-ENV ENV (POP E) (POP E) (POP E) (POP E) (CAR E)
			  DECLARATIONS)
		 (DECLARATIONS E FUNCTIONS))
      ;; Evaluate the body
      (SI:EVAL-BODY BODY NEW-ENV))))

;;; Separate function to save unnecessary environment consing
(DEFUN MAKE-EVAL-CLOSURE (FORM)
  #+(OR CLOE-Runtime Genera)
  (IF (CONSTANTP FORM)
      (CONSTANTLY (COMPILER::CONSTANT-EVALUATOR FORM))
      #'(LAMBDA () (EVAL FORM)))
  #-(OR CLOE-Runtime Genera)
  #'(LAMBDA () (EVAL FORM)))

#+Genera
(DEFUN (SETF SYS:FUNCTION-NAME) (NAME FUNCTION)
  (ETYPECASE FUNCTION
    (SYS:COMPILED-FUNCTION
      (LABELS ((SET-NAME-COMPILED (FUNCTION NAME DEPTH)
		 (LET ((CONS (SYS:CCA-EXTRA-INFO (SYS:COMPILED-FUNCTION-CCA FUNCTION))))
		   (COND ((= DEPTH 0)
			  (SETF (FIRST CONS) NAME))
			 (T
			  ;; SKip over :INTERNALs
			  (SETF CONS (FIRST CONS))
			  (WHEN (> DEPTH 1)
			    (LOOP REPEAT (1- DEPTH) DOING (SETF CONS (SECOND CONS))))
			  (SETF (SECOND CONS) NAME)))
		   ;; Now do its internals
		   (LET ((DEPTH (1+ DEPTH)))
		     #+Imach
		     (MAPC #'(LAMBDA (INTERNAL) (SET-NAME-COMPILED INTERNAL NAME DEPTH))
			   (SI:COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS FUNCTION))
		     #+|3600|
		     (MAPC #'(LAMBDA (OFFSET)
			       (SET-NAME-COMPILED
				 (SYS:%P-CONTENTS-OFFSET FUNCTION (- -1 OFFSET))
				 NAME
				 DEPTH))
			   (SI:COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS FUNCTION))))))
	(SET-NAME-COMPILED FUNCTION NAME 0)))
    ((AND SYS:LEXICAL-CLOSURE (SATISFIES SI:INTERPRETED-FUNCTION-P))
     (LET ((FUNCTION (SI:INTERPRETED-FUNCTION-LAMBDA-EXPRESSION FUNCTION)))
       (MULTIPLE-VALUE-BIND (LAMBDA-LIST DECL-SPECS DOCUMENTATION REAL-BODY)
	   (PARSE-LAMBDA-EXPRESSION (SECOND FUNCTION) NIL)
	 (SETQ DECL-SPECS (LOOP FOR DECL-SPEC IN DECL-SPECS
				UNLESS (EQ (CAR DECL-SPEC) 'SYS:FUNCTION-NAME)
				  COLLECT DECL-SPEC))
	 (SETF (SECOND FUNCTION)
	       `(LAMBDA ,LAMBDA-LIST
		  (DECLARE (SYS:FUNCTION-NAME ,NAME) ,@DECL-SPECS)
		  ,DOCUMENTATION
		  ,@REAL-BODY))
	 (IF (CAR (THIRD FUNCTION))
	     (SETF (CAR (THIRD FUNCTION)) NAME)
	     (SETF (THIRD FUNCTION) (CONS NAME NIL))))))))

#+Genera
(DEFUN FUNCTION-REAL-FUNCTION (FUNCTION)
  (TYPECASE FUNCTION
    (SYS:LEXICAL-CLOSURE
      (IF (SI:INTERPRETED-FUNCTION-P FUNCTION)
	  FUNCTION
	  (SYS:LEXICAL-CLOSURE-FUNCTION FUNCTION)))
    (OTHERWISE FUNCTION)))

#+Minima
(DEFUN FUNCTION-REAL-FUNCTION (FUNCTION)
  FUNCTION)



#+Genera
(DEFUN PROMPT-AND-READ (&REST FORMAT-ARGS)
  (DECLARE (DYNAMIC-EXTENT FORMAT-ARGS))
  (APPLY #'SCL:PROMPT-AND-READ :EVAL-FORM FORMAT-ARGS))

#-Genera
(DEFUN PROMPT-AND-READ (&REST FORMAT-ARGS)
  (DECLARE (DYNAMIC-EXTENT FORMAT-ARGS))
  (APPLY #'FORMAT *QUERY-IO* FORMAT-ARGS)
  (READ *QUERY-IO*))
