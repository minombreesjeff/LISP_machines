;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

#+Genera
(DEFMETHOD FUNCTION-SPEC-TYPE ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  'INSTANCE-FUNCTION-NAME)

#+CLOE-Runtime
(DEFMETHOD FUNCTION-SPEC-TYPE ((FUNCTION-NAME T))
  NIL)

#+CLOE-Runtime
(DEFMETHOD FUNCTION-SPEC-TYPE ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  #'INSTANCE-FUNCTION-NAME-HANDLER)


#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:FDEFINE))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG2))
  (SETF (FUNCTION-NAME-DEFINITION FUNCTION-NAME) ARG1))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:COMPILER-FDEFINE))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG2))
  (SETF (FUNCTION-NAME-DEFINITION FUNCTION-NAME 'COMPILE-FILE) ARG1))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:FDEFINEDP))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-BOUNDP FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:COMPILER-FDEFINEDP))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-BOUNDP FUNCTION-NAME 'COMPILE-FILE))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:FDEFINITION))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-DEFINITION FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:FDEFINITION-LOCATION))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-DEFINITION-LOCATION FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:DEFINITION-HAS-LOCATION-P))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-DEFINITION-HAS-LOCATION-P FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL `SI:FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:LOCATION-IS-FDEFINITION-LOCATION-P))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG2))
  (FUNCTION-NAME-LOCATION-IS-DEFINITION-LOCATION-P FUNCTION-NAME ARG1))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:FUNDEFINE))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-MAKUNBOUND FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:FUNCTION-PARENT))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-FUNCTION-PARENT FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:GET))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG2))
  (FUNCTION-NAME-GET FUNCTION-NAME ARG1))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:PUTPROP))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (SETF (FUNCTION-NAME-GET FUNCTION-NAME ARG2) ARG1))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:PLIST))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG1 ARG2))
  (FUNCTION-NAME-PLIST FUNCTION-NAME))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION (EQL 'SI:REMPROP))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (DECLARE (IGNORE ARG2))
  (FUNCTION-NAME-REMPROP FUNCTION-NAME ARG1))

#+Genera
(DEFMETHOD (:PROPERTY INSTANCE-FUNCTION-NAME SI:FUNCTION-SPEC-HANDLER)
	   ((FUNCTION SYMBOL)
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-NAME ARG1 ARG2))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :DEFINITION))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (FUNCTION-NAME-DEFINITION FUNCTION-NAME))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :BOUNDP))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (FUNCTION-NAME-BOUNDP FUNCTION-NAME))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :MAKUNBOUND))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (FUNCTION-NAME-MAKUNBOUND FUNCTION-NAME))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :DEFINE))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (SETF (FUNCTION-NAME-DEFINITION FUNCTION-NAME) ARG1))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :GET))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (FUNCTION-NAME-GET FUNCTION-NAME ARG1))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :PUT))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  (SETF (FUNCTION-NAME-GET FUNCTION-NAME ARG1) ARG2))

#+CLOE-Runtime
(DEFMETHOD INSTANCE-FUNCTION-NAME-HANDLER
	   ((OP (EQL :FUNCTION-FORM))
	    (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ARG1 ARG2)
  `(FUNCTION-NAME-DEFINITION ',FUNCTION-NAME))

(DEFMETHOD (SETF FUNCTION-NAME-DEFINITION) :AROUND
	   (DEFINITION
	     (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	     &OPTIONAL ENVIRONMENT)
  (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      (SETF (FDEFINITION-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT) DEFINITION)
      (CALL-NEXT-METHOD)))

#-Genera
(DEFUN UNHANDLED-FUNCTION-NAME-OPERATION ()
  (ERROR "Can not perform this operation"))

(DEFMETHOD (SETF FUNCTION-NAME-DEFINITION)
	   (DEFINITION
	     (FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	     &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:FDEFINE FUNCTION-NAME DEFINITION)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

(DEFMETHOD FUNCTION-NAME-BOUNDP :AROUND
	   ((FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ENVIRONMENT)
  (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      (FBOUNDP-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT)
      (CALL-NEXT-METHOD)))

(DEFMETHOD FUNCTION-NAME-BOUNDP ((FUNCTION-NAME INSTANCE-FUNCTION-NAME)
				   &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  NIL)

(DEFMETHOD FUNCTION-NAME-DEFINITION :AROUND
	   ((FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    &OPTIONAL ENVIRONMENT)
  (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      (FDEFINITION-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT)
      (CALL-NEXT-METHOD)))

(DEFMETHOD FUNCTION-NAME-DEFINITION ((FUNCTION-NAME INSTANCE-FUNCTION-NAME)
				     &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:FDEFINITION FUNCTION-NAME)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

#+Genera
(DEFMETHOD FUNCTION-NAME-DEFINITION-LOCATION ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:FDEFINITION-LOCATION FUNCTION-NAME))

#+Genera
(DEFMETHOD FUNCTION-NAME-FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
	   ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
				    FUNCTION-NAME))

#+Genera
(DEFMETHOD FUNCTION-NAME-LOCATION-IS-DEFINITION-LOCATION-P
	   ((FUNCTION-NAME INSTANCE-FUNCTION-NAME)
	    LOCATION)
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:LOCATION-IS-FDEFINITION-LOCATION-P
				    FUNCTION-NAME
				    LOCATION))

#+Genera
(DEFMETHOD FUNCTION-NAME-DEFINITION-HAS-LOCATION-P ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:DEFINITION-HAS-LOCATION-P FUNCTION-NAME))

(DEFMETHOD FUNCTION-NAME-MAKUNBOUND ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:FUNDEFINE FUNCTION-NAME)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

#+Genera
(DEFMETHOD FUNCTION-NAME-FUNCTION-PARENT ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:FUNCTION-PARENT FUNCTION-NAME))

(DEFMETHOD FUNCTION-NAME-GET ((FUNCTION-NAME INSTANCE-FUNCTION-NAME) INDICATOR)
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:GET FUNCTION-NAME INDICATOR)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

(DEFMETHOD (SETF FUNCTION-NAME-GET)
	   (VALUE (FUNCTION-NAME INSTANCE-FUNCTION-NAME) INDICATOR)
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:PUTPROP FUNCTION-NAME INDICATOR VALUE)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

(DEFMETHOD FUNCTION-NAME-PLIST ((FUNCTION-NAME INSTANCE-FUNCTION-NAME))
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:PLIST FUNCTION-NAME)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

(DEFMETHOD FUNCTION-NAME-REMPROP ((FUNCTION-NAME INSTANCE-FUNCTION-NAME) INDICATOR)
  #+Genera
  (SI:FUNCTION-SPEC-DEFAULT-HANDLER 'SI:REMPROP FUNCTION-NAME INDICATOR)
  #-Genera
  (UNHANDLED-FUNCTION-NAME-OPERATION))

(DEFMETHOD (SETF FUNCTION-NAME-DEFINITION)
	   (DEFINITION (FUNCTION-NAME BASIC-FUNCTION-NAME) &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  (SETF (SLOT-VALUE FUNCTION-NAME 'CELL) DEFINITION))

(DEFMETHOD FUNCTION-NAME-BOUNDP ((FUNCTION-NAME BASIC-FUNCTION-NAME) &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  (SLOT-BOUNDP FUNCTION-NAME 'CELL))

(DEFMETHOD FUNCTION-NAME-DEFINITION ((FUNCTION-NAME BASIC-FUNCTION-NAME) &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  (SLOT-VALUE FUNCTION-NAME 'CELL))

#+Minima
(DEFMETHOD (LOCF FUNCTION-NAME-DEFINITION) ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  (LOCF (SLOT-VALUE FUNCTION-NAME 'CELL)))

#+Genera
(DEFMETHOD FUNCTION-NAME-DEFINITION-LOCATION ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  (LOCF (SLOT-VALUE FUNCTION-NAME 'CELL)))

#+Genera
(DEFMETHOD FUNCTION-NAME-DEFINITION-HAS-LOCATION-P ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  T)

#+Genera
(DEFMETHOD FUNCTION-NAME-FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
	   ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  T)

#+Genera
(DEFMETHOD FUNCTION-NAME-LOCATION-IS-DEFINITION-LOCATION-P
	   ((FUNCTION-NAME BASIC-FUNCTION-NAME)
	    LOCATION)
  (EQ (FUNCTION-NAME-DEFINITION-LOCATION FUNCTION-NAME) LOCATION))

(DEFMETHOD FUNCTION-NAME-MAKUNBOUND ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  (SLOT-MAKUNBOUND FUNCTION-NAME 'CELL))

#+Genera
(DEFMETHOD FUNCTION-NAME-CURRENT-DEFINITION ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  FUNCTION-NAME)

#+Genera
(DEFMETHOD FUNCTION-NAME-CURRENT-P ((FUNCTION-NAME BASIC-FUNCTION-NAME))
  T)

#+Genera
(DEFMETHOD DECODE-SLOT-LOCATIVE ((FUNCTION-NAME BASIC-FUNCTION-NAME) LOCATION)
  (IF (EQ LOCATION (LOCF (SLOT-VALUE FUNCTION-NAME 'CELL)))
      (VALUES FUNCTION-NAME :FUNCTION)
      (CALL-NEXT-METHOD)))

#+Genera
(DEFMETHOD DECODE-SLOT-LOCATIVE ((FUNCTION-NAME T) LOCATION)
  (VALUES LOCATION :RANDOM))


(DEFMETHOD FUNCTION-NAME-GET ((FUNCTION-NAME FUNCTION-NAME-WITH-PLIST-MIXIN) INDICATOR)
  (GETF (SLOT-VALUE FUNCTION-NAME 'PLIST) INDICATOR))

(DEFMETHOD (SETF FUNCTION-NAME-GET)
	   (VALUE (FUNCTION-NAME FUNCTION-NAME-WITH-PLIST-MIXIN) INDICATOR)
  (SETF (GETF (SLOT-VALUE FUNCTION-NAME 'PLIST) INDICATOR) VALUE))

(DEFMETHOD FUNCTION-NAME-REMPROP ((FUNCTION-NAME FUNCTION-NAME-WITH-PLIST-MIXIN) INDICATOR)
  (REMF (SLOT-VALUE FUNCTION-NAME 'PLIST) INDICATOR))

#+Genera
(DEFMETHOD FUNCTION-NAME-FUNCTION-PARENT ((FUNCTION-NAME STANDARD-METHOD))
  (VALUES (SLOT-VALUE FUNCTION-NAME 'FUNCTION-PARENT)
	  'DEFUN))

#+(OR Genera Minima)
(DEFMETHOD (LOCF FUNCTION-NAME-DEFINITION) ((METHOD STANDARD-METHOD))
  (ERROR "Methods don't have definition locations."))

(DEFMETHOD (SETF FUNCTION-NAME-DEFINITION) :AFTER
           (FUNCTION (METHOD STANDARD-METHOD) &OPTIONAL ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  ;; This gets rather revolting
  ;; We compile the method function with the "METHOD" name so that it will be
  ;; meaningful to the observer.  We we go to make the method, we save the
  ;; function name in a slot of the method and bash the original function name.
  ;; All the internal function specs share structure with the top level function
  ;; spec, so this takes care of everything at once.
  #+Genera
  (LET ((REAL-FUNCTION (FUNCTION-REAL-FUNCTION FUNCTION)))
    (WHEN (TYPEP REAL-FUNCTION 'SYS:COMPILED-FUNCTION)
      ;; Get some information out of the debugging information
      (LET* ((CCA (SYS:COMPILED-FUNCTION-CCA REAL-FUNCTION))
	     (DEBUG-INFO (SYS:CCA-EXTRA-INFO CCA))
	     (NAME (POP DEBUG-INFO)))
	(TYPECASE NAME
	  (METHOD
	    ;; This function is shared by several methods.
	    (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-FAMILY)
		  (SLOT-VALUE NAME 'MAPPING-TABLE-FAMILY))
	    (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-ARGUMENTS)
		  (SLOT-VALUE NAME 'MAPPING-TABLE-ARGUMENTS))
	    (SETF (SLOT-VALUE METHOD 'MAPPED-ARGUMENTS-BITMAP)
		  (SLOT-VALUE NAME 'MAPPED-ARGUMENTS-BITMAP)))
	  (OTHERWISE
	    (DOLIST (ENTRY DEBUG-INFO)
	      (WHEN (CONSP ENTRY)
		(CASE (FIRST ENTRY)
		  (MAPPING-TABLE-FAMILY
		    (LET ((INFO (SECOND ENTRY)))
		      (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-FAMILY) (CAR INFO))
		      (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-ARGUMENTS) (CDR INFO))))
		  (MAPPED-ARGUMENTS
		    (SETF (SLOT-VALUE METHOD 'MAPPED-ARGUMENTS-BITMAP) (SECOND ENTRY))))))
	    (SETF (SYS:FUNCTION-NAME REAL-FUNCTION) METHOD))))))
  #+Minima
  (LET ((REAL-FUNCTION (FUNCTION-REAL-FUNCTION FUNCTION)))
    (WHEN (TYPEP REAL-FUNCTION 'IVORY::COMPILED-CODE)
      ;; Get some information out of the debugging information
      (LET* ((EXTRA-INFO (IVORY::COMPILED-FUNCTION-EXTRA-INFO REAL-FUNCTION))
	     (NAME (CAR EXTRA-INFO)))
	(COND ((AND (INSTANCEP NAME)
		    (TYPEP-CLASS NAME (FIND-CLASS 'METHOD)))
	       ;; This function is shared by several methods.
	       (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-FAMILY)
		     (SLOT-VALUE NAME 'MAPPING-TABLE-FAMILY))
	       (SETF (SLOT-VALUE METHOD 'MAPPED-ARGUMENTS-BITMAP)
		     (SLOT-VALUE NAME 'MAPPED-ARGUMENTS-BITMAP)))
	      (T
	       (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-FAMILY)
		     (GETF (CDR EXTRA-INFO) 'MAPPING-TABLE-FAMILY))
	       (SETF (SLOT-VALUE METHOD 'MAPPED-ARGUMENTS-BITMAP)
		     (GETF (CDR EXTRA-INFO) 'MAPPED-ARGUMENTS-BITMAP 0))
	       (SETF (CAR EXTRA-INFO) METHOD))))))
  #+CLOE-Runtime
  (SETF (SYS:FUNCTION-NAME FUNCTION) METHOD)
  ;; Method function has been redefined, fixup all the combined methods
  (LET ((GENERIC-FUNCTION (METHOD-GENERIC-FUNCTION METHOD)))
    (WHEN GENERIC-FUNCTION
      (WITH-CLOS-LOCK
	(NOTE-GENERIC-FUNCTION-METHOD-CHANGE GENERIC-FUNCTION METHOD :REMOVE)
	(NOTE-GENERIC-FUNCTION-METHOD-CHANGE GENERIC-FUNCTION METHOD :ADD)
	(UPDATE-DISPATCHES GENERIC-FUNCTION #'STANDARD-METHOD-COMBINER)))))

;;; The parent of a STANDARD-ACCESSOR-METHOD is the DEFCLASS which defines it.
#+Genera
(DEFMETHOD FUNCTION-NAME-FUNCTION-PARENT ((FUNCTION-NAME STANDARD-ACCESSOR-METHOD))
  (LET ((CLASS (CAR (LAST (METHOD-SPECIALIZERS FUNCTION-NAME)))))
    (VALUES (CLASS-NAME-FOR-TYPE-OF CLASS) 'DEFCLASS)))

#+Genera
(DEFMETHOD FUNCTION-NAME-GET ((FUNCTION-NAME STANDARD-METHOD) INDICATOR)
  (SI:FUNCTION-SPEC-GET
    (FUNCTION-SPEC-OBJECT FUNCTION-NAME)
    INDICATOR))

#+Genera
(DEFMETHOD (SETF FUNCTION-NAME-GET)
	   (VALUE (FUNCTION-NAME STANDARD-METHOD) INDICATOR)
  (SI:FUNCTION-SPEC-PUTPROP
    (FUNCTION-SPEC-OBJECT FUNCTION-NAME)
    VALUE
    INDICATOR))

#+Genera
(DEFMETHOD FUNCTION-NAME-PLIST ((FUNCTION-NAME STANDARD-METHOD))
  (SI:FUNCTION-SPEC-PLIST (FUNCTION-SPEC-OBJECT FUNCTION-NAME)))

#+Genera
(DEFMETHOD FUNCTION-NAME-REMPROP ((FUNCTION-NAME STANDARD-METHOD) INDICATOR)
  (SI:FUNCTION-SPEC-REMPROP (FUNCTION-SPEC-OBJECT FUNCTION-NAME) INDICATOR))

#+Genera
(DEFMETHOD FUNCTION-NAME-CURRENT-DEFINITION ((FUNCTION-NAME STANDARD-METHOD))
  (WHEN (NULL (FUNCTION-NAME-CURRENT-P FUNCTION-NAME))
    (LET ((GENERIC-FUNCTION-NAME (SECOND (SLOT-VALUE FUNCTION-NAME 'FUNCTION-PARENT))))
      (WHEN (FBOUNDP GENERIC-FUNCTION-NAME)
	(LET ((GENERIC-FUNCTION (FDEFINITION GENERIC-FUNCTION-NAME)))
	  (WHEN (TYPEP GENERIC-FUNCTION 'GENERIC-FUNCTION)
	    (LET ((METHOD (FIND-METHOD GENERIC-FUNCTION
				       (METHOD-QUALIFIERS FUNCTION-NAME)
				       (METHOD-SPECIALIZERS FUNCTION-NAME))))
	      (WHEN METHOD
		(RETURN-FROM FUNCTION-NAME-CURRENT-DEFINITION METHOD))))))))
  (CALL-NEXT-METHOD))

#+Genera
(DEFMETHOD FUNCTION-NAME-CURRENT-P ((FUNCTION-NAME STANDARD-METHOD))
  (LET ((GENERIC-FUNCTION (METHOD-GENERIC-FUNCTION FUNCTION-NAME)))
    (WHEN GENERIC-FUNCTION
      (LET ((NAME (GENERIC-FUNCTION-NAME GENERIC-FUNCTION)))
	(WHEN (AND #+Genera (SI:VALIDATE-FUNCTION-SPEC NAME)
		   (FBOUNDP NAME)
		   (EQ (FDEFINITION-IN-ENVIRONMENT NAME NIL) GENERIC-FUNCTION))
	  (NOT (NULL (MEMBER FUNCTION-NAME (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)))))))))

;;; The parent of a STANDARD-ACCESSOR-METHOD is the DEFCLASS which defines it.
#+Genera
(DEFMETHOD FUNCTION-NAME-FUNCTION-PARENT ((FUNCTION-NAME MISCELLANEOUS-FUNCTION))
  (VALUES (SLOT-VALUE FUNCTION-NAME 'NAME)
	  'DEFINE-METHOD-COMBINATION))

(DEFMETHOD MAKE-LOAD-FORM ((FUNCTION-NAME MISCELLANEOUS-FUNCTION))
  `(MISCELLANEOUS-FUNCTION-FOR-LAMBDA
     ',(SLOT-VALUE FUNCTION-NAME 'NAME)
     ',(SLOT-VALUE FUNCTION-NAME 'LAMBDA-EXPRESSION)))

;;; Call FLAVOR:FIND-FLAVOR rather than storing it in a slot, since if the flavor is
;;; redefined incompatibly, a new instance-information will be created without our consent
#+Genera
(DEFMETHOD CLASS-INSTANCE-INFORMATION ((CLASS FLAVOR-CLASS))
  (FLAVOR:FIND-FLAVOR (SLOT-VALUE CLASS 'NAME)))

#+Genera
(DEFMETHOD CLASS-DIRECT-SUPERCLASSES ((CLASS FLAVOR-CLASS))
  (LET ((FLAVOR (CLASS-INSTANCE-INFORMATION CLASS)))
    (OR (MAPCAR #'FIND-CLASS (FLAVOR::FLAVOR-LOCAL-COMPONENTS FLAVOR))
	(IF (FLAVOR::FLAVOR-WITHOUT-VANILLA FLAVOR)
	    (LIST *T-CLASS*)
	    (LIST (FIND-CLASS 'FLAVOR:VANILLA))))))

#+Genera
(DEFMETHOD CLASS-DIRECT-SUBCLASSES ((CLASS FLAVOR-CLASS))
  (MAPCAR #'FIND-CLASS (FLAVOR::FLAVOR-LOCAL-DEPENDENTS (CLASS-INSTANCE-INFORMATION CLASS))))

#+Genera
(DEFMETHOD DOCUMENTATION-OBJECT ((CLASS FLAVOR-CLASS))
  (FLAVOR:FLAVOR-DOCUMENTATION (CLASS-INSTANCE-INFORMATION CLASS)))

#+Genera
(DEFMETHOD (SETF DOCUMENTATION-OBJECT) (NEW-VALUE (CLASS FLAVOR-CLASS))
  (SETF (FLAVOR:FLAVOR-DOCUMENTATION (CLASS-INSTANCE-INFORMATION CLASS)) NEW-VALUE))

(DEFMETHOD PRINT-OBJECT ((MC STANDARD-METHOD-COMBINATION) STREAM)
  (IF *PRINT-ESCAPE*
      (PRINT-UNREADABLE-OBJECT (MC STREAM :TYPE T :IDENTITY T)
	(PRINC MC STREAM))
      (PRINC (LIST* (METHOD-COMBINATION-TYPE MC) (METHOD-COMBINATION-OPTIONS MC)) STREAM)))

(DEFMETHOD PRINT-OBJECT ((MCD METHOD-COMBINATION-DEFINITION) STREAM)
  (IF *PRINT-ESCAPE*
      (PRINT-UNREADABLE-OBJECT (MCD STREAM :TYPE T :IDENTITY T)
	(PRINC MCD STREAM))
      (PRIN1 (METHOD-COMBINATION-DEFINITION-NAME MCD) STREAM)))

;;;

(DEFMETHOD METHOD-COMBINATION-DEFINITION-NAME ((MC STANDARD-METHOD-COMBINATION))
  (METHOD-COMBINATION-DEFINITION-NAME (METHOD-COMBINATION-TYPE MC)))

(DEFMETHOD METHOD-COMBINATION-DEFINITION-FUNCTION
	   ((METHOD-COMBINATION-DEFINITION SHORT-FORM-METHOD-COMBINATION-DEFINITION))
  #'(LAMBDA (GENERIC METHODS &OPTIONAL (ORDER ':MOST-SPECIFIC-FIRST))
      (DECLARE (IGNORE GENERIC))
      (LET ((NAME (METHOD-COMBINATION-DEFINITION-NAME METHOD-COMBINATION-DEFINITION))
	    (AROUND NIL)
	    (PRIMARY NIL))
	(MAPC #'(LAMBDA (METHOD)
		  (BLOCK DO-METHOD
		    (LET ((QUALIFIERS (METHOD-QUALIFIERS METHOD)))
		      (WHEN QUALIFIERS
			(LET ((QUALIFIER (POP QUALIFIERS)))
			  (UNLESS QUALIFIERS
			    (COND ((EQ QUALIFIER :AROUND)
				   (PUSH METHOD AROUND)
				   (RETURN-FROM DO-METHOD))
				  ((EQ QUALIFIER NAME)
				   (PUSH METHOD PRIMARY)
				   (RETURN-FROM DO-METHOD)))))))
		    (METHOD-COMBINATION-ERROR
		      "Invalid qualifiers for ~s:  :AROUND and ~s are the only valid ~
                       method qualifiers"
			   METHOD NAME)))
	      METHODS)
	(UNLESS PRIMARY (ERROR "No applicable ~s method" NAME))
	(ECASE ORDER
	  (:MOST-SPECIFIC-FIRST (SETQ PRIMARY (NREVERSE PRIMARY)))
	  (:MOST-SPECIFIC-LAST))
	(SETQ AROUND (NREVERSE AROUND))
	(LET ((INNER
		(IF (AND (NULL (CDR PRIMARY))
			 (METHOD-COMBINATION-DEFINITION-IDENTITY-WITH-ONE-ARGUMENT
			   METHOD-COMBINATION-DEFINITION))
		    `(CALL-METHOD ,(FIRST PRIMARY))
		    `(,(METHOD-COMBINATION-DEFINITION-OPERATOR METHOD-COMBINATION-DEFINITION)
		      ,@(MAPCAR #'(LAMBDA (METHOD) `(CALL-METHOD ,METHOD)) PRIMARY)))))
	  (IF AROUND
	      `(CALL-METHOD
		 ,(FIRST AROUND)
		 (,@(REST AROUND)
		  (MAKE-METHOD ,INNER)))
	      INNER)))))

(DEFMETHOD COMPUTE-EFFECTIVE-METHOD
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD-COMBINATION STANDARD-METHOD-COMBINATION)
	    METHODS)
  (DECLARE (NOTINLINE METHOD-COMBINATION-TYPE METHOD-COMBINATION-OPTIONS))
  (APPLY (METHOD-COMBINATION-DEFINITION-FUNCTION
	   (METHOD-COMBINATION-TYPE METHOD-COMBINATION))
	 GENERIC-FUNCTION
	 METHODS
	 (METHOD-COMBINATION-OPTIONS METHOD-COMBINATION)))

(DEFMETHOD COMPUTE-EFFECTIVE-METHOD-1 ((GENERIC-FUNCTION GENERIC-FUNCTION) METHODS
				       ARGUMENT-FUNCTION)
  (DECLARE (IGNORE ARGUMENT-FUNCTION))
  (DECLARE (NOTINLINE GENERIC-FUNCTION-METHOD-COMBINATION))
  (COMPUTE-EFFECTIVE-METHOD GENERIC-FUNCTION
			    (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION)
			    METHODS))

(DEFMETHOD GENERIC-FUNCTION-CALL-FORM
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    FUNCALL-OR-APPLY FUNCTION EXTRA-ARGUMENT &REST ARGUMENTS)
  ;; Extra argument precedes normal arguments.
  #-(or |3600| CLOE-Runtime) `(,FUNCALL-OR-APPLY ,FUNCTION ,EXTRA-ARGUMENT ,@ARGUMENTS)
  #+CLOE-Runtime `(,FUNCALL-OR-APPLY (THE COMPILED-FUNCTION ,FUNCTION) ,EXTRA-ARGUMENT ,@ARGUMENTS)
  #+|3600| (IF (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION)
	     ;; There are specializable arguments, follow Flavors conventions, i.e.
	     ;; first required argument, extra argument, junk, remaining arguments.
	     `(,FUNCALL-OR-APPLY ,FUNCTION
	       ,(FIRST ARGUMENTS) ,EXTRA-ARGUMENT NIL ,@(REST ARGUMENTS))
	     ;; No required arguments, follow normal CLOS conventions, i.e. extra
	     ;; argument followed by remaining arguments.
	     `(,FUNCALL-OR-APPLY ,FUNCTION ,EXTRA-ARGUMENT ,@ARGUMENTS)))

(DEFMETHOD GENERIC-FUNCTION-NO-APPLICABLE-METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION))
  (VALUES (PROGN
	    #-|3600| 'STANDARD-CALL-NO-APPLICABLE-METHOD
	    #+|3600| (IF (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION)
		       'STANDARD-3600-CALL-NO-APPLICABLE-METHOD
		       'STANDARD-CALL-NO-APPLICABLE-METHOD))
	  GENERIC-FUNCTION))

#+|3600|
(DEFVAR *IGNORED-.GENERIC.* (MAKE-STATIC-SYMBOL ".GENERIC."))

(DEFMETHOD GENERIC-FUNCTION-MAKE-LAMBDA ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
					 EXTRA-ARGUMENT-VARIABLE LAMBDA-LIST BODY)
  ;; Extra argument precedes normal arguments.
  #-|3600| `(LAMBDA (,EXTRA-ARGUMENT-VARIABLE ,@LAMBDA-LIST) ,@BODY)
  #+|3600| (IF (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION)
	     ;; There are specializable arguments, follow Flavors conventions, i.e.
	     ;; first required argument, extra argument, junk, remaining arguments.
	     `(LAMBDA (,(FIRST LAMBDA-LIST)
		       ,EXTRA-ARGUMENT-VARIABLE
		       ,*IGNORED-.GENERIC.*
		       ,@(REST LAMBDA-LIST))
		(DECLARE (IGNORE ,*IGNORED-.GENERIC.*))
		,@BODY)
	     ;; No required arguments, follow normal CLOS conventions, i.e. extra
	     ;; argument followed by remaining arguments.
	     `(LAMBDA (,EXTRA-ARGUMENT-VARIABLE ,@LAMBDA-LIST) ,@BODY)))

;;; Short format DEFINE-METHOD-COMBINATION does not support :ARGUMENTS.
(DEFMETHOD METHOD-COMBINATION-DEFINITION-ARGUMENTS-LAMBDA-LIST
	   ((METHOD-COMBINATION-DEFINITION SHORT-FORM-METHOD-COMBINATION-DEFINITION))
  NIL)

(DEFMETHOD METHOD-COMBINATION-ARGUMENTS-LAMBDA-LIST
	   ((METHOD-COMBINATION STANDARD-METHOD-COMBINATION))
  (METHOD-COMBINATION-DEFINITION-ARGUMENTS-LAMBDA-LIST
    (METHOD-COMBINATION-TYPE METHOD-COMBINATION)))

(DEFMETHOD METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-METHOD)
	    NEXT-METHOD-FUNCTION
	    ARGUMENT-FUNCTION
	    &REST KEYS)
  (DECLARE (IGNORE KEYS))
  (VALUES METHOD
	  (COND ((METHOD-NO-NEXT-METHOD-INFORMATION METHOD)
		 (METHOD-MAPPING-TABLE METHOD ARGUMENT-FUNCTION))
		(T
		 (MULTIPLE-VALUE-BIND (NEXT-FUNCTION-NAME NEXT-EXTRA-ARGUMENT)
		     (FUNCALL NEXT-METHOD-FUNCTION)
		   (LIST* (METHOD-MAPPING-TABLE METHOD ARGUMENT-FUNCTION)
			  (FDEFINITION NEXT-FUNCTION-NAME)
			  NEXT-EXTRA-ARGUMENT))))))

(DEFMETHOD METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-READER-METHOD)
	    NEXT-METHOD-FUNCTION
	    ARGUMENT-FUNCTION
	    &REST KEYS)
  (DECLARE (IGNORE NEXT-METHOD-FUNCTION KEYS))
  (DECLARE (NOTINLINE METHOD-SLOT-NAME))
  (LET ((CLASS (FUNCALL ARGUMENT-FUNCTION 'CLASS 0)))
    (SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
      GENERIC-FUNCTION
      METHOD
      CLASS
      (SLOT-DEFINITION-LOCATION (FIND (METHOD-SLOT-NAME METHOD) (CLASS-SLOTS CLASS)
				      :KEY #'SLOT-DEFINITION-NAME)))))

(DEFMETHOD METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-WRITER-METHOD)
	    NEXT-METHOD-FUNCTION
	    ARGUMENT-FUNCTION
	    &REST KEYS)
  (DECLARE (IGNORE NEXT-METHOD-FUNCTION KEYS))
  (DECLARE (NOTINLINE METHOD-SLOT-NAME))
  (LET ((CLASS (FUNCALL ARGUMENT-FUNCTION 'CLASS 1)))
    (SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
      GENERIC-FUNCTION
      METHOD
      CLASS
      (SLOT-DEFINITION-LOCATION (FIND (METHOD-SLOT-NAME METHOD) (CLASS-SLOTS CLASS)
				      :KEY #'SLOT-DEFINITION-NAME)))))

#+(OR Genera Minima)
(DEFMETHOD METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-LOCATOR-METHOD)
	    NEXT-METHOD-FUNCTION
	    ARGUMENT-FUNCTION
	    &REST KEYS)
  (DECLARE (IGNORE NEXT-METHOD-FUNCTION KEYS))
  (DECLARE (NOTINLINE METHOD-SLOT-NAME))
  (LET ((CLASS (FUNCALL ARGUMENT-FUNCTION 'CLASS 0)))
    (SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
      GENERIC-FUNCTION
      METHOD
      CLASS
      (SLOT-DEFINITION-LOCATION (FIND (METHOD-SLOT-NAME METHOD) (CLASS-SLOTS CLASS)
				      :KEY #'SLOT-DEFINITION-NAME)))))

(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-READER-METHOD)
	    (CLASS STANDARD-CLASS)
	    (LOCATION INTEGER))
  (VALUES 'STANDARD-CLASS-LOCAL-SLOT-READER
	  LOCATION))

(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-READER-METHOD)
	    (CLASS STANDARD-CLASS)
	    (LOCATION
	      #+(OR Genera Minima) LOCATIVE
	      #-(OR Genera Minima) CONS))
  (VALUES 'STANDARD-CLASS-SHARED-SLOT-READER
	  LOCATION))

(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-READER-METHOD)
	    (CLASS FUNCALLABLE-STANDARD-CLASS)
	    (LOCATION INTEGER))
  (VALUES 'FUNCALLABLE-STANDARD-CLASS-SLOT-READER
	  LOCATION))

(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-WRITER-METHOD)
	    (CLASS STANDARD-CLASS)
	    (LOCATION INTEGER))
  (VALUES 'STANDARD-CLASS-LOCAL-SLOT-WRITER
	  LOCATION))

(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-WRITER-METHOD)
	    (CLASS STANDARD-CLASS)
	    (LOCATION
	      #+(OR Genera Minima) LOCATIVE
	      #-(OR Genera Minima) CONS))
  (VALUES 'STANDARD-CLASS-SHARED-SLOT-WRITER
	  LOCATION))

(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-WRITER-METHOD)
	    (CLASS FUNCALLABLE-STANDARD-CLASS)
	    (LOCATION INTEGER))
  (VALUES 'FUNCALLABLE-STANDARD-CLASS-SLOT-WRITER
	  LOCATION))

#+(OR Genera Minima)
(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-LOCATOR-METHOD)
	    (CLASS STANDARD-CLASS)
	    (LOCATION INTEGER))
  (VALUES 'STANDARD-CLASS-LOCAL-SLOT-LOCATOR
	  LOCATION))

#+(OR Genera Minima)
(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-LOCATOR-METHOD)
	    (CLASS STANDARD-CLASS)
	    (LOCATION
	      #+(OR Genera Minima) LOCATIVE
	      #-(OR Genera Minima) CONS))
  (VALUES 'STANDARD-CLASS-SHARED-SLOT-LOCATOR
	  LOCATION))

#+(OR Genera Minima)
(DEFMETHOD SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-LOCATOR-METHOD)
	    (CLASS FUNCALLABLE-STANDARD-CLASS)
	    (LOCATION INTEGER))
  (VALUES 'FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATOR
	  LOCATION))

(DEFMETHOD METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD CONS)
	    NEXT-METHOD-FUNCTION
	    ARGUMENT-FUNCTION
	    &REST KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (DECLARE (IGNORE NEXT-METHOD-FUNCTION))
  (UNLESS (AND (EQ (FIRST METHOD) 'MAKE-METHOD)
	       (NULL (CDDR METHOD)))
    (METHOD-COMBINATION-ERROR "~s is not a valid method for ~s" METHOD 'CALL-METHOD))
  (APPLY #'GENERATE-COMBINED-METHOD
	 GENERIC-FUNCTION ARGUMENT-FUNCTION (SECOND METHOD) NIL NIL KEYS))

(DEFMETHOD METHOD-NO-NEXT-METHOD-INFORMATION ((METHOD STANDARD-ACCESSOR-METHOD))
  T)

(DEFMETHOD METHOD-MAPPING-TABLE ((METHOD STANDARD-METHOD) (ARGUMENT-FUNCTION T))
  (DECLARE (NOTINLINE METHOD-MAPPING-TABLE-FAMILY METHOD-SPECIALIZERS))
  (LET ((FAMILY (METHOD-MAPPING-TABLE-FAMILY METHOD)))
    (WHEN FAMILY
      (LET ((CLASSES (MAKE-LIST (LENGTH (METHOD-SPECIALIZERS METHOD)))))
	(LOOP FOR PLACE ON CLASSES
	      FOR I FROM 0
	      DOING
	  (SETF (FIRST PLACE) (FUNCALL ARGUMENT-FUNCTION 'CLASS I)))
	(APPLY #'GET-MAPPING-TABLE-FOR-CLASSES FAMILY CLASSES)))))

#+(OR Genera Minima)
(DEFMETHOD DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
	   ((SELECTOR GENERIC-FUNCTION-SELECTOR))
  (FUNCALLABLE-INSTANCE-FROM-GENERIC-SELECTOR SELECTOR))

#-(OR Genera Minima)
(DEFMETHOD DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
	   ((SELECTOR STANDARD-GENERIC-FUNCTION))
  SELECTOR)

#+Genera
(DEFMETHOD DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
	   ((SELECTOR SYMBOL))
  (GET SELECTOR 'SELECTOR-GENERIC-FUNCTION))

(DEFMETHOD GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION))
  (LDB-TEST %%GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
	    (SLOT-VALUE GENERIC-FUNCTION 'FLAGS)))

(DEFMETHOD (SETF GENERIC-FUNCTION-EXPLICITLY-DEFINED-P)
	   (NEW-VALUE GENERIC-FUNCTION)
  (SETF (LDB %%GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
	     (SLOT-VALUE GENERIC-FUNCTION 'FLAGS))
	(IF NEW-VALUE -1 0)))

(DEFMETHOD GENERIC-FUNCTION-INITIALIZED-P (GENERIC-FUNCTION)
  (LDB-TEST %%GENERIC-FUNCTION-INITIALIZED-P (SLOT-VALUE GENERIC-FUNCTION 'FLAGS)))

(DEFMETHOD (SETF GENERIC-FUNCTION-INITIALIZED-P)
	   (NEW-VALUE GENERIC-FUNCTION)
  (SETF (LDB %%GENERIC-FUNCTION-INITIALIZED-P
	     (SLOT-VALUE GENERIC-FUNCTION 'FLAGS))
	(IF NEW-VALUE -1 0)))

(DEFMETHOD MAKE-METHOD-LAMBDA
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (METHOD STANDARD-METHOD)
	    LAMBDA
	    &OPTIONAL ENVIRONMENT)
  (MAKE-STANDARD-METHOD-LAMBDA LAMBDA ENVIRONMENT))

(DEFMETHOD ADD-MAPPING-TABLE ((CLASS CLASS) (MAPPING-TABLE T))
  NIL)

(DEFMETHOD ADD-MAPPING-TABLE ((CLASS MAPPED-CLASS-MIXIN) MAPPING-TABLE)
  (PUSHNEW MAPPING-TABLE (CLASS-MAPPING-TABLES CLASS)))

(DEFMETHOD ADD-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
		       (METHOD STANDARD-METHOD))
  (WITH-CLOS-LOCK
    (LET ((OLD-GF (AND (SLOT-BOUNDP METHOD 'GENERIC-FUNCTION)
		       (SLOT-VALUE METHOD 'GENERIC-FUNCTION))))
      (WHEN (AND OLD-GF (NOT (EQ GENERIC-FUNCTION OLD-GF)))
	(ERROR "Attempt to add a method for ~s to ~s" OLD-GF GENERIC-FUNCTION))
      (SETF (SLOT-VALUE METHOD 'GENERIC-FUNCTION) GENERIC-FUNCTION))
    ;; Check the lambda list for congruency
    (COND ((AND (NULL (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
		(NULL (GENERIC-FUNCTION-EXPLICITLY-DEFINED-P GENERIC-FUNCTION)))
	   (LET ((LAMBDA-LIST
		   (COMPUTE-GENERIC-FUNCTION-LAMBDA-LIST (METHOD-LAMBDA-LIST METHOD))))
	     (SETF (SLOT-VALUE GENERIC-FUNCTION 'LAMBDA-LIST) LAMBDA-LIST)
	     (SETF (SLOT-VALUE GENERIC-FUNCTION 'PRECEDENCE-ORDER)
		   (CHECK-ARGUMENT-PRECEDENCE-ORDER #'CLOS-ERROR NIL LAMBDA-LIST))))
	  (T
	   (MULTIPLE-VALUE-BIND (GREQUIRE GOPTIONAL GREST GKEYP GKEYS)
	       (LAMBDA-LIST-COMPONENTS (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION))
	     (MULTIPLE-VALUE-BIND (MREQUIRE MOPTIONAL MREST MKEYP MKEYS MALLOW)
		 (LAMBDA-LIST-COMPONENTS (METHOD-LAMBDA-LIST METHOD))
	       (UNLESS (AND (= GREQUIRE MREQUIRE)
			    (= GOPTIONAL MOPTIONAL)
			    (EQ (OR GREST GKEYP) (OR MREST MKEYP))
			    (OR MALLOW
				(NULL MKEYP)
				(EVERY #'(LAMBDA (GKEY) (MEMBER GKEY MKEYS)) GKEYS)))
		 (LET ((MISSING-KEYS (AND (NOT MALLOW) MKEYP (SET-DIFFERENCE GKEYS MKEYS)))
		       #+Genera
		       (DBG:*ERROR-MESSAGE-PRINLENGTH* NIL))	;show entire lambda-list
		   (ERROR "The lambda list of the method ~S,~@
			 which is ~:S, is not congruent~@
			 with the lambda list of the generic function ~S,~@
			 which is ~:S, because~:[~@
			 the generic function has ~D required argument~:P ~
			  but the method has ~D required argument~:P~;~2*~]~:[~@
			 the generic function has ~D optional argument~:P ~
			  but the method has ~D optional argument~:P~;~2*~]~:[~@
			 the generic function ~A but the method ~A~;~2*~]~:[~@
			 the method does not accept the keyword argument~P ~{~S~^, ~} ~
			 needed by the generic function~;~2*~]."
			  METHOD
			  (LDIFF (METHOD-LAMBDA-LIST METHOD)
				 (MEMBER '&AUX (METHOD-LAMBDA-LIST METHOD)))
			  (GENERIC-FUNCTION-NAME GENERIC-FUNCTION)
			  (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)
			  (= GREQUIRE MREQUIRE) GREQUIRE MREQUIRE
			  (= GOPTIONAL MOPTIONAL) GOPTIONAL MOPTIONAL
			  (EQ (OR GREST GKEYP) (OR MREST MKEYP))
			  (COND ((AND GREST GKEYP) "has rest and keyword arguments")
				(GREST "has a rest argument")
				(GKEYP "has keyword arguments")
				(T "has neither rest nor keyword arguments"))
			  (COND ((AND MREST MKEYP) "has rest and keyword arguments")
				(MREST "has a rest argument")
				(MKEYP "has keyword arguments")
				(T "has neither rest nor keyword arguments"))
			  (NOT MISSING-KEYS) (LENGTH MISSING-KEYS) MISSING-KEYS)))))))
    (LET ((SPECIALIZERS (METHOD-SPECIALIZERS METHOD))
	  (EXISTING-METHOD (FIND METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)
				 :TEST #'EQUIVALENT-METHOD-P)))
      (WHEN EXISTING-METHOD
	(NOTE-GENERIC-FUNCTION-METHOD-CHANGE GENERIC-FUNCTION EXISTING-METHOD :REMOVE)
	(DOLIST (SPECIALIZER SPECIALIZERS)
	  (REMOVE-DIRECT-METHOD SPECIALIZER EXISTING-METHOD))
	(SETF (SLOT-VALUE EXISTING-METHOD 'GENERIC-FUNCTION) NIL)
	(SETF (SLOT-VALUE GENERIC-FUNCTION 'INITIAL-METHODS)
	      (REMOVE EXISTING-METHOD
		      (GENERIC-FUNCTION-INITIAL-METHODS GENERIC-FUNCTION))))
      (NOTE-GENERIC-FUNCTION-METHOD-CHANGE GENERIC-FUNCTION METHOD :ADD)
      ;; Create a new list of methods rather than bashing the old list, for the
      ;; benefit of code which is using the old list for something.
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'METHODS)
	    (CONS METHOD
		  (IF EXISTING-METHOD
		      (REMOVE EXISTING-METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
		      (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))))
      #+Genera
      (WHEN (AND EXISTING-METHOD
		 (SI:FUNCTION-ENCAPSULATED-P EXISTING-METHOD)
		 ;; If they're both traced, the user must have gone to some trouble
		 ;; to get things that way, so don't do any second guessing.
		 (NOT (SI:FUNCTION-ENCAPSULATED-P METHOD)))
	;; The old method is encapsulated.
	(LET* ((SYS:FDEFINE-FILE-PATHNAME NIL)
	       (SI:PATCH-SOURCE-FILE-PATHNAME NIL)
	       (EXISTING-DEFINITION (FDEFINITION EXISTING-METHOD))
	       (UNENCAPSULATED-SPEC (SI:UNENCAPSULATE-FUNCTION-SPEC EXISTING-METHOD))
	       (EXISTING-REAL-DEFINITION (FDEFINITION UNENCAPSULATED-SPEC))
	       (NEW-DEFINITION (FDEFINITION METHOD)))
	  ;; Transfer the encapsulation to the new method
	  (SI:FDEFINE METHOD EXISTING-DEFINITION NIL T)
	  ;; Make the new definition be encapsulated
	  (SI:FDEFINE UNENCAPSULATED-SPEC NEW-DEFINITION NIL T)
	  ;; Restore the old method
	  (SI:FDEFINE EXISTING-METHOD EXISTING-REAL-DEFINITION NIL T)))
      (DOLIST (SPECIALIZER SPECIALIZERS)
	(ADD-DIRECT-METHOD SPECIALIZER METHOD))
      #+Genera
      (WHEN (METHOD-FUNCTION METHOD)
	(SI:WHEN-IN-INCREMENTAL-WHO-CALLS-MODE
	  (SI:WHO-CALLS-FDEFINE-HOOK METHOD)))
      (COND ((AND *INHIBIT-DISPATCH-CACHE-UPDATING*
		  ;; Need to check for the case where the generic
		  ;; function only had an unspecialized method.
		  (LET ((METHODS (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
			(T-CLASS *T-CLASS*))
		    (AND METHODS		
			 (CDR METHODS)
			 (NULL (CDDR METHODS))	;Exactly two methods (including this one)
			 (BLOCK CHECK
			   (DOLIST (THIS-METHOD METHODS)
			     ;; Don't care about the new method
			     (UNLESS (EQ METHOD THIS-METHOD)
			       (DOLIST (SPECIALIZER (METHOD-SPECIALIZERS THIS-METHOD))
				 (UNLESS (EQ SPECIALIZER T-CLASS)
				   (RETURN-FROM CHECK NIL)))))
			   T))))
	     ;; RECOMBINE-METHODS-SPECIALIZED-ON-CLASS won't see this generic
	     ;; function since it's not in the handler tables for the class.  Uncache
	     ;; the formerly lone method here.  The next time the generic function is
	     ;; called, the dispatch will be added.
	     (SETF (%FUNCALLABLE-INSTANCE-FUNCTION GENERIC-FUNCTION)
		   #'HANDLE-START-DISPATCH-MISS))
	    ((NOT *INHIBIT-DISPATCH-CACHE-UPDATING*)
	     (WHEN (OR (EQ GENERIC-FUNCTION *SHARED-INITIALIZE*)
		       (EQ GENERIC-FUNCTION *INITIALIZE-INSTANCE*))
	       (UPDATE-CLASS-INITIALIZATION-INFORMATION METHOD))
	     (WHEN (OR (EQ GENERIC-FUNCTION *MAKE-INSTANCE*)
		       (EQ GENERIC-FUNCTION *ALLOCATE-INSTANCE*))
	       (UPDATE-METACLASS-INITIALIZATION-INFORMATION METHOD))
	     (LET ((FUNCTION (METHOD-FUNCTION METHOD)))
	       (WHEN FUNCTION
		 (LET ((FAMILY (METHOD-MAPPING-TABLE-FAMILY METHOD)))
		   (WHEN FAMILY
		     #+Genera
		     (LET ((OLD-FAMILIES
			     (GENERIC-FUNCTION-MAPPING-TABLE-FAMILIES GENERIC-FUNCTION)))
		       (MULTIPLE-VALUE-BIND (NEW-FAMILY NEW-FAMILIES)
			   (FIND-APPROPRIATE-MAPPING-TABLE OLD-FAMILIES FAMILY)
			 (UNLESS (EQ OLD-FAMILIES NEW-FAMILIES)
			   (SETF (SLOT-VALUE GENERIC-FUNCTION 'MAPPING-TABLE-FAMILIES)
				 NEW-FAMILIES))
			 (WHEN (NOT (EQ FAMILY NEW-FAMILY))
			   (UPDATE-MAPPING-TABLE-INSTRUCTIONS FUNCTION NEW-FAMILY FAMILY)
			   (SETF FAMILY
				 (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-FAMILY) NEW-FAMILY)))))
		     #-Genera
		     (PUSH FAMILY (SLOT-VALUE GENERIC-FUNCTION 'MAPPING-TABLE-FAMILIES))
		     (ENTER-MAPPING-TABLE-FAMILY FAMILY)))))
	     (UPDATE-DISPATCHES GENERIC-FUNCTION #'STANDARD-METHOD-COMBINER))
	    (T
	     ;; This class is being redefined.  Defer the cache changes
	     ;; until the class gets finalized again (this reduces work,
	     ;; and makes metaclass redefinition possible).
	     NIL))
      GENERIC-FUNCTION)))

(DEFUN UPDATE-CLASS-INITIALIZATION-INFORMATION (METHOD)
  (LET ((CLASS (FIRST (METHOD-SPECIALIZERS METHOD))))
    (UNLESS (CONSP CLASS)
      (LET ((CLASSES NIL))
	(LABELS ((DO-CLASS (CLASS)
		   (UNLESS (MEMBER CLASS CLASSES)
		     (ENSURE-CLASS-INITIALIZATION-INFORMATION CLASS)
		     (PUSH CLASS CLASSES)
		     (MAPC #'DO-CLASS (CLASS-DIRECT-SUBCLASSES CLASS)))))
	  (DO-CLASS CLASS))))))

(DEFUN UPDATE-METACLASS-INITIALIZATION-INFORMATION (METHOD)
  (LET ((METACLASS (FIRST (METHOD-SPECIALIZERS METHOD))))
    (UNLESS (CONSP METACLASS)
      (LET ((CLASSES NIL))
	(LABELS ((DO-CLASS (CLASS)
		   (UNLESS (MEMBER CLASS CLASSES)
		     (WHEN (TYPEP-CLASS CLASS METACLASS)
		       (ENSURE-CLASS-INITIALIZATION-INFORMATION CLASS))
		     (PUSH CLASS CLASSES)
		     (MAPC #'DO-CLASS (CLASS-DIRECT-SUBCLASSES CLASS)))))
	  (DO-CLASS (FIND-CLASS 'T)))))))

(DEFMETHOD ENSURE-CLASS-INITIALIZATION-INFORMATION ((CLASS STANDARD-CLASS))
  (UNLESS (CLASS-FINALIZED-P CLASS)
    (RETURN-FROM ENSURE-CLASS-INITIALIZATION-INFORMATION NIL))
  (LET ((INSTANCE (CLASS-PROTOTYPE CLASS))
	(KEYWORDS NIL)
	(ALLOW-OTHER-KEYS-P NIL))
    (DOLIST (SLOT (CLASS-SLOTS CLASS))
      (DOLIST (KEY (SLOT-DEFINITION-INITARGS SLOT))
	(PUSHNEW KEY KEYWORDS)))
    (FLET ((ALL-KEYS (GF &REST ARGS)
	     (DECLARE (DYNAMIC-EXTENT ARGS))
	     (DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS GF ARGS))
	       (MULTIPLE-VALUE-BIND (KEYS ALLOW)
		   (FUNCTION-KEYWORDS METHOD)
		 (DOLIST (KEY KEYS)
		   (PUSHNEW KEY KEYWORDS))
		 (WHEN ALLOW
		   (SETF ALLOW-OTHER-KEYS-P T))))))
      ;; On page 88-002R 1-37, the valid keywords for MAKE-INSTANCE consist of the
      ;; union of the valid keywords for ALLOCATE-INSTANCE, INITIALIZE-INSTANCE,
      ;; and SHARED-INITIALIZE.  I am assuming that MAKE-INSTANCE was left out of
      ;; the list accidentally.
      (ALL-KEYS *ALLOCATE-INSTANCE* CLASS)
      (ALL-KEYS *MAKE-INSTANCE* CLASS)
      (ALL-KEYS *INITIALIZE-INSTANCE* INSTANCE)
      (ALL-KEYS *SHARED-INITIALIZE* INSTANCE T))
    (SETF (CLASS-MAKE-INSTANCE-KEYWORDS CLASS) (NREVERSE KEYWORDS))
    (SETF (LDB %%STANDARD-CLASS-MAKE-INSTANCE-ALLOW-OTHER-KEYS-P (SLOT-VALUE CLASS 'BITS))
	  (IF ALLOW-OTHER-KEYS-P -1 0))
    ;;--- This might be overzealous, since nothing that affects a constructor
    ;;---     might have changed.
    (MAPC #'NOTE-CONSTRUCTOR-CHANGED (CLASS-CONSTRUCTORS CLASS))))

(DEFMETHOD CLASS-FINALIZED-P ((CLASS BUILT-IN-CLASS))
  T)

(DEFMETHOD CLASS-FINALIZED-P ((CLASS FORWARD-REFERENCED-CLASS))
  NIL)

(DEFMETHOD CLASS-FINALIZED-P ((CLASS STANDARD-CLASS))
  (LDB-TEST %%STANDARD-CLASS-FINALIZED-P (CLASS-BITS CLASS)))

(DEFMETHOD CLASS-FINALIZED-P ((CLASS STRUCTURE-CLASS))
  (SLOT-BOUNDP CLASS 'INSTANCE-INFORMATION))

(DEFMETHOD CLASS-FINALIZED-P ((CLASS METHOD-ONLY-CLASS))
  NIL)

#+Genera
(DEFMETHOD CLASS-FINALIZED-P ((CLASS FLAVOR-CLASS))
  (FLAVOR::FLAVOR-INSTANTIABLE (CLASS-INSTANCE-INFORMATION CLASS)))

(DEFMETHOD LAMBDA-LIST-CONGRUENT-P
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    LAMBDA-LIST
	    &OPTIONAL
	    (GENERIC-FUNCTION-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)))
  (CLOS-LAMBDA-LISTS-CONGRUENT-P
    GENERIC-FUNCTION-LAMBDA-LIST
    LAMBDA-LIST))

(DEFMETHOD ADD-DIRECT-METHOD ((SPECIALIZER CONS) (METHOD METHOD))
  (MULTIPLE-VALUE-BIND (EQL? OBJECT)
      (EQL-METHOD-SPECIALIZER-P SPECIALIZER)
    (UNLESS EQL?
      (ERROR "~s is an invalid specializer" SPECIALIZER))
    (LET ((PAIR (ASSOC OBJECT *EQL-SPECIALIZER-METHODS*)))
      (IF PAIR
	  (LET ((CONS (MEMBER METHOD (CDR PAIR) :TEST #'EQUIVALENT-METHOD-P)))
	    (IF CONS
		(SETF (FIRST CONS) METHOD)
		(PUSH METHOD (CDR PAIR))))
	  (PUSH (LIST OBJECT METHOD) *EQL-SPECIALIZER-METHODS*)))))

(DEFMETHOD ADD-DIRECT-METHOD ((SPECIALIZER CLASS) (METHOD METHOD))
  NIL)

(DEFMETHOD REMOVE-DIRECT-METHOD ((SPECIALIZER CONS) (METHOD METHOD))
  (MULTIPLE-VALUE-BIND (EQL? OBJECT)
      (EQL-METHOD-SPECIALIZER-P SPECIALIZER)
    (UNLESS EQL?
      (ERROR "~s is an invalid specializer" SPECIALIZER))
    (LET ((PAIR (ASSOC OBJECT *EQL-SPECIALIZER-METHODS*)))
      (WHEN PAIR
	(SETF (CDR PAIR) (DELETE METHOD (CDR PAIR)))))))

(DEFMETHOD REMOVE-DIRECT-METHOD ((SPECIALIZER CLASS) (METHOD METHOD))
  NIL)

(DEFMETHOD SPECIALIZER-DIRECT-METHODS ((SPECIALIZER T))
  (LET ((METHODS NIL))
    (MAP-OVER-GENERIC-FUNCTIONS
      #'(LAMBDA (GENERIC-FUNCTION)
	  (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
	    (BLOCK METHOD
	      (DOLIST (SPEC (METHOD-SPECIALIZERS METHOD))
		(WHEN (EQUIVALENT-SPECIALIZERS-P SPEC SPECIALIZER)
		  (PUSHNEW METHOD METHODS)
		  (RETURN-FROM METHOD)))))))
    METHODS))

(DEFMETHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS ((SPECIALIZER T))
  (LET ((GENERIC-FUNCTIONS NIL))
    (MAP-OVER-GENERIC-FUNCTIONS
      #'(LAMBDA (GENERIC-FUNCTION)
	  (BLOCK GENERIC-FUNCTION
	    (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
	      (DOLIST (SPEC (METHOD-SPECIALIZERS METHOD))
		(WHEN (EQUIVALENT-SPECIALIZERS-P SPEC SPECIALIZER)
		  (PUSHNEW GENERIC-FUNCTION GENERIC-FUNCTIONS)
		  (RETURN-FROM GENERIC-FUNCTION)))))))
    GENERIC-FUNCTIONS))

(DEFMETHOD SPECIALIZER-DIRECT-METHODS ((SPECIALIZER CONS))
  ;;; This deals with EQL specializers.  Anything else is undefined
  (MULTIPLE-VALUE-BIND (OK-P OBJECT)
      (EQL-METHOD-SPECIALIZER-P SPECIALIZER)
    (UNLESS OK-P
      (ERROR "~s is not a valid EQL specializer" SPECIALIZER))
    (CDR (ASSOC OBJECT *EQL-SPECIALIZER-METHODS*))))

(DEFMETHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS ((SPECIALIZER CONS))
  ;;; This deals with EQL specializers.  Anything else is undefined
  (MULTIPLE-VALUE-BIND (OK-P OBJECT)
      (EQL-METHOD-SPECIALIZER-P SPECIALIZER)
    (UNLESS OK-P
      (ERROR "~s is not a valid EQL specializer" SPECIALIZER))
    (LET ((GENERIC-FUNCTIONS NIL))
      (DOLIST (PAIR *EQL-SPECIALIZER-METHODS*)
	(WHEN (EQL OBJECT (FIRST PAIR))
	  (DOLIST (METHOD (REST PAIR))
	    (PUSHNEW (METHOD-GENERIC-FUNCTION METHOD) GENERIC-FUNCTIONS))))
      GENERIC-FUNCTIONS)))

(DEFMETHOD EQUIVALENT-METHOD-P ((METHOD1 STANDARD-METHOD) (METHOD2 STANDARD-METHOD))
  (AND (EQ (METHOD-GENERIC-FUNCTION METHOD1)
	   (METHOD-GENERIC-FUNCTION METHOD2))
       (EQUIVALENT-SPECIALIZER-LISTS-P (METHOD-SPECIALIZERS METHOD1)
				       (METHOD-SPECIALIZERS METHOD2))
       (EQUIVALENT-QUALIFIERS-P (METHOD-QUALIFIERS METHOD1) (METHOD-QUALIFIERS METHOD2))))


(DEFMETHOD COMPUTE-APPLICABLE-METHODS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) FUNCTION-ARGUMENTS)
  (WHEN (< (LENGTH FUNCTION-ARGUMENTS)
	   (LENGTH (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION)))
    (TOO-FEW-ARGUMENTS-ERROR GENERIC-FUNCTION FUNCTION-ARGUMENTS))
  (SORT-APPLICABLE-METHODS
    GENERIC-FUNCTION
    (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)
    #'(LAMBDA (TYPE I)
	(LET ((ARGUMENT (NTH I FUNCTION-ARGUMENTS)))
	  (ECASE TYPE
	    (CLASS (CLASS-OF ARGUMENT))
	    (EQL (VALUES T ARGUMENT)))))))

(DEFMETHOD REINITIALIZE-INSTANCE ((INSTANCE STANDARD-OBJECT) &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  ;; The valid initargs are the union of the initargs for the slots,
  ;; REINITIALIZE-INSTANCE, and SHARED-INITIALIZE for this instance.
  (WHEN INITARGS
    (BLOCK CHECK-KEYWORDS
      (LET ((KEYWORDS NIL))
	(DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS
			  *REINITIALIZE-INSTANCE*
			  (LIST INSTANCE)))
	  (MULTIPLE-VALUE-BIND (KEYS ALLOW-OTHER-KEYS-P)
	      (FUNCTION-KEYWORDS METHOD)
	    (WHEN ALLOW-OTHER-KEYS-P
	      (RETURN-FROM CHECK-KEYWORDS))
	    (DOLIST (KEYWORD KEYS)
	      (PUSHNEW KEYWORD KEYWORDS))))
	(DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS
			  *SHARED-INITIALIZE*
			  (LIST INSTANCE NIL)))
	  (MULTIPLE-VALUE-BIND (KEYS ALLOW-OTHER-KEYS-P)
	      (FUNCTION-KEYWORDS METHOD)
	    (WHEN ALLOW-OTHER-KEYS-P
	      (RETURN-FROM CHECK-KEYWORDS))
	    (DOLIST (KEYWORD KEYS)
	      (PUSHNEW KEYWORD KEYWORDS))))
	(DOLIST (SLOT (CLASS-SLOTS (CLASS-OF INSTANCE)))
	  (DOLIST (KEYWORD (SLOT-DEFINITION-INITARGS SLOT))
	    (PUSHNEW KEYWORD KEYWORDS)))
	;; Ideally we would store this information someplace, but we can't do that until
	;; we know when it becomes invalid
	(VALIDATE-KEYWORDS-INTERNAL KEYWORDS INITARGS))))
  (APPLY #'SHARED-INITIALIZE INSTANCE NIL INITARGS))

(DEFMETHOD SHARED-INITIALIZE ((INSTANCE STANDARD-OBJECT) SLOT-NAMES &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (LET* ((SLOTS-INITIALIZED NIL)
	 (CLASS (CLASS-OF INSTANCE))
	 (SLOTS (CLASS-SLOTS CLASS))
	 (INITARGS-PLACE INITARGS))
    ;; Initialize the slots from INITARGS.  The leftmost initialization is used. 
    (LOOP
      (WHEN (NULL INITARGS-PLACE)
	(RETURN))
      (LET ((KEY (POP INITARGS-PLACE))
	    (VALUE (POP INITARGS-PLACE)))
	(MAPC #'(LAMBDA (SLOT)
		  (WHEN (MEMBER KEY (SLOT-DEFINITION-INITARGS SLOT))
		    (LET ((NAME (SLOT-DEFINITION-NAME SLOT)))
		      (UNLESS (MEMBER NAME SLOTS-INITIALIZED)
			(SETF (SLOT-VALUE INSTANCE NAME) VALUE)
			(PUSH NAME SLOTS-INITIALIZED)))))
	      SLOTS)))
    ;; Now, initialize every slot in SLOT-NAMES which is still unitialized
    (DOLIST (SLOT SLOTS)
      (LET ((NAME (SLOT-DEFINITION-NAME SLOT)))
	(WHEN (AND (OR (EQ SLOT-NAMES T)
		       (MEMBER NAME SLOT-NAMES))
		   (NOT (SLOT-BOUNDP INSTANCE NAME)))
	  (LET ((INITFUNCTION (SLOT-DEFINITION-INITFUNCTION SLOT)))
	    (WHEN INITFUNCTION
	      (SETF (SLOT-VALUE INSTANCE NAME) (FUNCALL INITFUNCTION)))))))
    INSTANCE))

(DEFMETHOD FUNCTION-KEYWORDS ((METHOD STANDARD-METHOD))
  (MULTIPLE-VALUE-BIND (N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS RESTP KEYWORDSP
			KEYWORDS ALLOW-OTHER-KEYS-P)
      (LAMBDA-LIST-COMPONENTS (METHOD-LAMBDA-LIST METHOD))
    (DECLARE (IGNORE N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS RESTP KEYWORDSP))
    (VALUES KEYWORDS ALLOW-OTHER-KEYS-P)))

(DEFMETHOD FIND-METHOD-COMBINATION
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    METHOD-COMBINATION-TYPE
	    METHOD-COMBINATION-OPTIONS)
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (MAKE-INSTANCE 'STANDARD-METHOD-COMBINATION
		 :TYPE (FIND-METHOD-COMBINATION-DEFINITION METHOD-COMBINATION-TYPE)
		 :OPTIONS METHOD-COMBINATION-OPTIONS))

(DEFMETHOD INITIALIZE-INSTANCE :AFTER
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    &KEY ENVIRONMENT)
  (UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
    (NOTICE-GENERIC-FUNCTION GENERIC-FUNCTION))
  #+Genera
  (LET ((NAME (GENERIC-FUNCTION-NAME GENERIC-FUNCTION)))
    (WHEN NAME
      (LET ((SYMBOL (IF (SYMBOLP NAME) NAME (SECOND NAME))))
	(SI:AARRAY-INSERT *ALL-GENERIC-FUNCTION-NAMES-AARRAY*
			  (SYMBOL-NAME SYMBOL) SYMBOL 'ATOM)))))

(DEFMETHOD SHARED-INITIALIZE :AFTER
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
	    (SLOT-NAMES T)
	    &REST KEYS
	    &KEY
	    ((FUNCTION-SPECIFIER FUNCTION-SPECIFIER) NIL FUNCTION-SPECIFIER-P)
	    (LAMBDA-LIST NIL LAMBDA-LIST-P)
	    ARGUMENT-PRECEDENCE-ORDER
	    (DECLARATIONS NIL DECLARATIONSP)
	    DOCUMENTATION
	    (INITIAL-METHODS NIL INITIAL-METHODS-P)
	    (METHOD-COMBINATION '(STANDARD) METHOD-COMBINATION-P)
	    (METHOD-CLASS 'STANDARD-METHOD METHOD-CLASS-P)
	    ((SELECTOR SELECTOR) NIL SELECTOR-P)
	    ((INITIALIZATION-TYPE INITIALIZATION-TYPE) NIL)
	    ENVIRONMENT)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (DECLARE (IGNORE ENVIRONMENT))
  (WHEN INITIALIZATION-TYPE
    ;; Class or metaclass change, so don't initialize any slots.
    (RETURN-FROM SHARED-INITIALIZE NIL))
  (UNLESS (GENERIC-FUNCTION-EXPLICITLY-DEFINED-P GENERIC-FUNCTION)
    (LOOP FOR (KEYWORD) ON KEYS BY #'CDDR
	  DOING
      (UNLESS (MEMBER KEYWORD '(:ENVIRONMENT FUNCTION-SPECIFIER STORAGE-AREA))
	(SETF (GENERIC-FUNCTION-EXPLICITLY-DEFINED-P GENERIC-FUNCTION) T)
	(RETURN NIL))))
  (LET ((RECOMPUTE NIL)
	(INITIALIZED-P (GENERIC-FUNCTION-INITIALIZED-P GENERIC-FUNCTION)))
    #+(OR Genera Minima)
    (UNLESS INITIALIZED-P
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'FUNCALLABLE-INSTANCE) GENERIC-FUNCTION))
    (WHEN (OR (NULL INITIALIZED-P) FUNCTION-SPECIFIER-P)
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'NAME) FUNCTION-SPECIFIER))
    #+Genera
    (WHEN (OR (NULL INITIALIZED-P) SELECTOR-P)
      (SETQ RECOMPUTE T)
      (WHEN INITIALIZED-P
	(LET ((OLD-SELECTOR (GENERIC-FUNCTION-SELECTOR GENERIC-FUNCTION)))
	  (WHEN OLD-SELECTOR
	    (REMPROP SELECTOR 'SELECTOR-GENERIC-FUNCTION)
	    (SETF *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS*
		  (DELETE GENERIC-FUNCTION *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS*)))))
      (WHEN SELECTOR
	(SETF (GET SELECTOR 'SELECTOR-GENERIC-FUNCTION) GENERIC-FUNCTION)
	(PUSH GENERIC-FUNCTION *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS*))
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'SELECTOR) SELECTOR))
    (WHEN (OR (NULL INITIALIZED-P) LAMBDA-LIST-P)
      (WHEN (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)
	(UNLESS (LAMBDA-LIST-CONGRUENT-P GENERIC-FUNCTION LAMBDA-LIST)
	  (CERROR
	    "Remove existing methods and allow the change to proceed"
	    "~s was previously defined as a generic function with the lambda list ~s, which is ~
             not congruent with the lambda list ~s."
	    (GENERIC-FUNCTION-NAME GENERIC-FUNCTION)
	    (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)
	    LAMBDA-LIST)
	  (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
	    (REMOVE-METHOD GENERIC-FUNCTION METHOD))))
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'LAMBDA-LIST) LAMBDA-LIST))
    (WHEN (OR (NULL INITIALIZED-P)
	      ARGUMENT-PRECEDENCE-ORDER
	      (AND LAMBDA-LIST-P
		   (NULL (GENERIC-FUNCTION-EXPLICITLY-DEFINED-P GENERIC-FUNCTION))))
      (SETQ RECOMPUTE T)
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'PRECEDENCE-ORDER)
	    (CHECK-ARGUMENT-PRECEDENCE-ORDER
	      #'CLOS-ERROR ARGUMENT-PRECEDENCE-ORDER
	      (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION))))
    (WHEN (OR LAMBDA-LIST-P DECLARATIONSP)
      ;; When LAMBDA-LIST-P is NIL, then we are being called from
      ;; ENSURE-GENERIC-FUNCTION for a DEFMETHOD.
      (LET ((DEBUGGING-INFO NIL)
	    (DOWNWARD-FUNARGS))
	(DOLIST (DECL-SPEC DECLARATIONS)
	  #+Genera
	  (LOOP
	    (LET ((ALIAS (GET (CAR DECL-SPEC) 'SI:DECLARATION-ALIAS)))
	      (ETYPECASE ALIAS
		(NULL (RETURN))
		(SYMBOL (SETF DECL-SPEC `(,ALIAS ,@(REST DECL-SPEC))))
		(FUNCTION (SETF DECL-SPEC (FUNCALL ALIAS DECL-SPEC NIL))))))
	  (CASE (FIRST DECL-SPEC)
	    ((SPECIAL FTYPE FUNCTION INLINE NOTINLINE DECLARATION IGNORE
		      #+Genera ZL:UNSPECIAL
		      #+Genera SYS:FUNCTION-NAME
		      #+Genera COMPILER:EVACUABLE-DOWNWARD-CLOSURES
		      #+Minima MINIMA-INTERNALS::FUNCTION-NAME)
	     (WARN "~s is an invalid decl-spec for a generic function.  It will be ignored"
		   DECL-SPEC))
	    #+(OR Genera CLOE-Runtime)
	    ((SYS:DOWNWARD-FUNARG)
	     (WARN "The ~S declaration is obsolete and should be replaced with an appropriate ~S declaration."
		   DECL-SPEC 'DYNAMIC-EXTENT)
	     #+Genera				;@@@@
	     (SETQ DOWNWARD-FUNARGS
		   (APPEND (SI:DOWNWARD-FUNARG-DEBUGGING-INFO
			     DECL-SPEC (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)
			     DECLARATIONS)
			   DOWNWARD-FUNARGS)))
	    #+(OR Genera CLOE-Runtime)
	    ((SYS:DOWNWARD-FUNCTION)
	     (WARN "The ~S declaration is obsolete and should be replaced with an appropriate ~S declaration."
		   DECL-SPEC 'DYNAMIC-EXTENT)
	     (PUSH '(SYS:DOWNWARD-FUNCTION) DEBUGGING-INFO))
	    ((DYNAMIC-EXTENT)
	     #+Genera
	     (SETQ DOWNWARD-FUNARGS
		   (APPEND (SI:DOWNWARD-FUNARG-DEBUGGING-INFO
			     DECL-SPEC (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)
			     DECLARATIONS)
			   DOWNWARD-FUNARGS)))
	    (OTHERWISE
	      #+Genera				;@@@@
	      (COND ((GET (CAR DECL-SPEC) 'SI:DEBUG-INFO)
		     (PUSH DECL-SPEC DEBUGGING-INFO))
		    ((SYS:VALID-DECLARATION-P (FIRST DECL-SPEC)))
		    (T (WARN "~s is an invalid decl-spec.  It will be ignored." DECL-SPEC))))))
	#+(OR Genera CLOE-Runtime)
	(WHEN DOWNWARD-FUNARGS
	  (PUSH `(SYS:DOWNWARD-FUNARG ,DOWNWARD-FUNARGS) DEBUGGING-INFO))
	(WHEN DOCUMENTATION
	  (PUSH (LIST :DOCUMENTATION DOCUMENTATION) DEBUGGING-INFO))
	(SETF (SLOT-VALUE GENERIC-FUNCTION 'DEBUGGING-INFO) DEBUGGING-INFO)))
    (WHEN (OR (NULL INITIALIZED-P) METHOD-COMBINATION-P)
      (SETQ RECOMPUTE T)
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'METHOD-COMBINATION)
	    (IF (CONSP METHOD-COMBINATION)
		(FIND-METHOD-COMBINATION GENERIC-FUNCTION (FIRST METHOD-COMBINATION) (REST METHOD-COMBINATION))
		METHOD-COMBINATION)))
    (WHEN (OR (NULL INITIALIZED-P) METHOD-CLASS-P)
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'METHOD-CLASS)
	    (IF (SYMBOLP METHOD-CLASS)
		(FIND-CLASS METHOD-CLASS)
		METHOD-CLASS)))
    (SETF (GENERIC-FUNCTION-INITIALIZED-P GENERIC-FUNCTION) T)
    (WHEN (AND INITIALIZED-P RECOMPUTE)
      (UPDATE-DISPATCHES GENERIC-FUNCTION #'STANDARD-METHOD-COMBINER T))
    (WHEN (OR (NULL INITIALIZED-P) INITIAL-METHODS-P)
      (WHEN INITIALIZED-P
	(DOLIST (METHOD (GENERIC-FUNCTION-INITIAL-METHODS GENERIC-FUNCTION))
	  (REMOVE-METHOD GENERIC-FUNCTION METHOD)))
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'INITIAL-METHODS) NIL)
      (LET* ((METHOD-CLASS (GENERIC-FUNCTION-METHOD-CLASS GENERIC-FUNCTION))
	     (METHODS (MAPCAR #'(LAMBDA (PLIST) (APPLY #'MAKE-INSTANCE METHOD-CLASS PLIST))
			      INITIAL-METHODS)))
	(SETF (SLOT-VALUE GENERIC-FUNCTION 'INITIAL-METHODS) METHODS)
	(DOLIST (METHOD METHODS)
	  (ADD-METHOD GENERIC-FUNCTION METHOD))))))

(DEFMETHOD ENSURE-GENERIC-FUNCTION-USING-CLASS
	   ((GENERIC-FUNCTION NULL) FUNCTION-SPECIFIER
	    &REST KEYS
	    &KEY
	    (GENERIC-FUNCTION-CLASS 'STANDARD-GENERIC-FUNCTION)
	    (LAMBDA-LIST NIL LAMBDA-LIST-P)
	    ENVIRONMENT
	    #+(OR Genera CLOE-Runtime)
	    ((STORAGE-AREA STORAGE-AREA)
	     (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
		 (PROGN #+Genera SYS:*DEFAULT-CONS-AREA*
			#+CLOE-Runtime SYS::AKIND$K-DEFAULT)
		 *CLOS-STATIC-AREA*))
	    &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE LAMBDA-LIST))
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (LET* ((INITIALIZATION-ARGUMENTS
	   (REMOVE-KEYWORDS KEYS :GENERIC-FUNCTION-CLASS #+(OR CLOE-Runtime Genera) STORAGE-AREA))
	 (GF (APPLY #'MAKE-INSTANCE GENERIC-FUNCTION-CLASS
		    'FUNCTION-SPECIFIER FUNCTION-SPECIFIER
		    #+(OR Genera CLOE-Runtime) 'STORAGE-AREA
		    #+(OR Genera CLOE-Runtime) STORAGE-AREA
		    INITIALIZATION-ARGUMENTS)))
    (COND #+Genera
	  ((AND (NULL LAMBDA-LIST-P)
		(NOT (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)))
	   (SI:FDEFINE-INTERNAL FUNCTION-SPECIFIER GF))
	  (T (SETF (FDEFINITION-IN-ENVIRONMENT FUNCTION-SPECIFIER ENVIRONMENT) GF)))
    (WHEN (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      (NOTICE-COMPILED-FUNCTION FUNCTION-SPECIFIER))
    GF))

(DEFMETHOD ENSURE-GENERIC-FUNCTION-USING-CLASS
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) FUNCTION-SPECIFIER
	    &REST KEYS
	    &KEY
	    (GENERIC-FUNCTION-CLASS 'STANDARD-GENERIC-FUNCTION CLASSP)
	    (LAMBDA-LIST NIL LAMBDA-LIST-P)
	    ENVIRONMENT
	    &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE LAMBDA-LIST))
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (WHEN (PROGN
	  #+Genera
	  (OR (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	      (NOT LAMBDA-LIST-P)
	      ;; If LAMBDA-LIST-P is provided, this form came from a
	      ;; DEFGENERIC, so record a source file name.  Otherwise, the
	      ;; generic function is being defined by something like DEFMETHOD,
	      ;; and no source file should be recorded.
	      (SI:RECORD-SOURCE-FILE-NAME FUNCTION-SPECIFIER))
	  #-Genera T)
    (LET ((INITIALIZATION-ARGUMENTS
	    (REMOVE-KEYWORDS KEYS :GENERIC-FUNCTION-CLASS))
	  (GF-CLASS
	    (TYPECASE GENERIC-FUNCTION-CLASS
	      (SYMBOL (FIND-CLASS GENERIC-FUNCTION-CLASS))
	      (OTHERWISE GENERIC-FUNCTION-CLASS))))
      (WHEN CLASSP      
	(UNLESS (EQ (CLASS-OF GENERIC-FUNCTION) GF-CLASS)
	  (CHANGE-CLASS GENERIC-FUNCTION GF-CLASS)))
      (APPLY #'REINITIALIZE-INSTANCE GENERIC-FUNCTION
	     INITIALIZATION-ARGUMENTS)
      GENERIC-FUNCTION)))

(DEFMETHOD NO-APPLICABLE-METHOD
	   ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) &REST FUNCTION-ARGUMENTS)
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (ERROR "No applicable method for ~a with arguments ~a" GENERIC-FUNCTION FUNCTION-ARGUMENTS))

(DEFMETHOD NO-NEXT-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION )
			   (METHOD STANDARD-METHOD)
			   &REST ARGS)
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (ERROR "No next method for method ~a of ~a with arguments ~a"
	 METHOD GENERIC-FUNCTION ARGS))

(DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS STANDARD-CLASS) OBJECT SLOT-NAME)
  (READ-SLOT CLASS OBJECT SLOT-NAME %INSTANCE-REF STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS STANDARD-CLASS) OBJECT SLOT-NAME)
  (WRITE-SLOT NEW-VALUE CLASS OBJECT SLOT-NAME %INSTANCE-REF STANDARD-CLASS-SLOT-LOCATION))

#+(OR Genera Minima)
(DEFMETHOD (LOCF SLOT-VALUE-USING-CLASS) ((CLASS STANDARD-CLASS) OBJECT SLOT-NAME)
  (LOCATE-SLOT CLASS OBJECT SLOT-NAME %INSTANCE-REF STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS STANDARD-CLASS) OBJECT SLOT-NAME)
  (BOUNDP-SLOT CLASS OBJECT SLOT-NAME %INSTANCE-REF STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS STANDARD-CLASS) OBJECT SLOT-NAME)
  (MAKUNBOUND-SLOT CLASS OBJECT SLOT-NAME %INSTANCE-REF STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD SLOT-EXISTS-P-USING-CLASS ((CLASS STANDARD-CLASS) OBJECT SLOT-NAME)
  (LET ((LOCATION (STANDARD-CLASS-SLOT-LOCATION OBJECT SLOT-NAME)))
    (IF (OR (TYPEP LOCATION 'FIXNUM)
	    #+(OR Genera Minima) (TYPEP LOCATION 'LOCATIVE)
	    #-(OR Genera Minima) (CONSP LOCATION))
	T
	(IF (NULL LOCATION)
	    NIL
	    (ERROR "Don't know what to do with this type of location")))))

(DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) OBJECT SLOT-NAME)
  (READ-SLOT CLASS OBJECT SLOT-NAME %FUNCALLABLE-INSTANCE-REF
	     FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD (SETF SLOT-VALUE-USING-CLASS)
           (NEW-VALUE (CLASS FUNCALLABLE-STANDARD-CLASS) OBJECT SLOT-NAME)
  (WRITE-SLOT NEW-VALUE CLASS OBJECT SLOT-NAME %FUNCALLABLE-INSTANCE-REF
	      FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION))

#+(OR Genera Minima)
(DEFMETHOD (LOCF SLOT-VALUE-USING-CLASS)
	   ((CLASS FUNCALLABLE-STANDARD-CLASS) OBJECT SLOT-NAME)
  (LOCATE-SLOT CLASS OBJECT SLOT-NAME %FUNCALLABLE-INSTANCE-REF
	       FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) OBJECT SLOT-NAME)
  (BOUNDP-SLOT CLASS OBJECT SLOT-NAME %FUNCALLABLE-INSTANCE-REF
	       FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) OBJECT SLOT-NAME)
  (MAKUNBOUND-SLOT CLASS OBJECT SLOT-NAME %FUNCALLABLE-INSTANCE-REF
		   FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION))

(DEFMETHOD SLOT-EXISTS-P-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) OBJECT SLOT-NAME)
  (LET ((LOCATION (FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION OBJECT SLOT-NAME)))
    (IF (OR (TYPEP LOCATION 'FIXNUM)
	    #+(OR Genera Minima) (TYPEP LOCATION 'LOCATIVE)
	    #-(OR Genera Minima) (CONSP LOCATION))
	T
	(IF (NULL LOCATION)
	    NIL
	    (ERROR "Don't know what to do with this type of location")))))

#+Genera
(DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS FLAVOR-CLASS) OBJECT SLOT-NAME)
  (SCL:SYMBOL-VALUE-IN-INSTANCE OBJECT SLOT-NAME))

#+Genera
(DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS FLAVOR-CLASS) OBJECT SLOT-NAME)
  (SETF (SCL:SYMBOL-VALUE-IN-INSTANCE OBJECT SLOT-NAME) NEW-VALUE))

#+Genera
(DEFMETHOD (LOCF SLOT-VALUE-USING-CLASS) ((CLASS FLAVOR-CLASS) OBJECT SLOT-NAME)
  (LOCF (SCL:SYMBOL-VALUE-IN-INSTANCE OBJECT SLOT-NAME)))

#+Genera
(DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS FLAVOR-CLASS) OBJECT SLOT-NAME)
  (SCL:BOUNDP-IN-INSTANCE OBJECT SLOT-NAME))

#+Genera
(DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS FLAVOR-CLASS) OBJECT SLOT-NAME)
  (LOCATION-MAKUNBOUND
    (LOCF (SCL:SYMBOL-VALUE-IN-INSTANCE OBJECT SLOT-NAME))
    SLOT-NAME))

#+Genera
(DEFMETHOD SLOT-EXISTS-P-USING-CLASS ((CLASS FLAVOR-CLASS) OBJECT SLOT-NAME)
  (DECLARE (IGNORE OBJECT))
  (LET ((FLAVOR (CLASS-INSTANCE-INFORMATION CLASS)))
    (NOT (NULL (MEMBER SLOT-NAME (FLAVOR::FLAVOR-ALL-INSTANCE-VARIABLES FLAVOR))))))

(DEFMETHOD SLOT-MISSING (CLASS OBJECT SLOT-NAME OPERATION &OPTIONAL NEW-VALUE)
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (IGNORE CLASS OPERATION NEW-VALUE))
  (ERROR "The slot ~s does not exist for ~s" SLOT-NAME OBJECT))

#+(OR Genera CLOE-Runtime)
(DEFINE-CONDITION UNBOUND-SLOT (CELL-ERROR)
  ((INSTANCE :INITARG :INSTANCE :READER UNBOUND-SLOT-INSTANCE)
   (SLOT-NAME :INITARG :NAME :READER CELL-ERROR-NAME))
  (:REPORT (LAMBDA (ERROR STREAM)
	     (FORMAT STREAM "Slot ~S is unbound in ~S"
		     (CELL-ERROR-NAME ERROR) (UNBOUND-SLOT-INSTANCE ERROR)))))

#+Genera
(FLAVOR:DEFWHOPPER (DBG:CURRENT-AND-INNERMOST-FRAMES-FOR-DEBUGGER UNBOUND-SLOT)
		   (INNERMOST-INTERESTING-FRAME)
  #+IMach
  (LOOP FOR FRAME = INNERMOST-INTERESTING-FRAME THEN (DBG:FRAME-PREVIOUS-ACTIVE-FRAME FRAME)
	WITH SLOT-LOCATION = (SCL:LOCF (SLOT-VALUE (UNBOUND-SLOT-INSTANCE SCL:SELF)
						   (CELL-ERROR-NAME SCL:SELF))) DO
    (WHEN (NULL FRAME)
      (RETURN (FLAVOR:CONTINUE-WHOPPER INNERMOST-INTERESTING-FRAME)))
    (WHEN (AND (EQ (DBG:FRAME-FUNCTION FRAME) #'DBG:ERROR-TRAP-HANDLER)
	       (EQ (DBG:FRAME-ARG-VALUE FRAME 3) SLOT-LOCATION))
      (RETURN (VALUES (DBG:FRAME-PREVIOUS-ACTIVE-FRAME FRAME)
		      INNERMOST-INTERESTING-FRAME))))
  #+|3600|
  (LOOP FOR FRAME = INNERMOST-INTERESTING-FRAME THEN (DBG:FRAME-PREVIOUS-ACTIVE-FRAME FRAME)
	WITH INSTANCE = (UNBOUND-SLOT-INSTANCE SCL:SELF)
	WITH SLOT = (CELL-ERROR-NAME SCL:SELF) DO
    (WHEN (NULL FRAME)
      (RETURN (FLAVOR:CONTINUE-WHOPPER INNERMOST-INTERESTING-FRAME)))
    (WHEN (EQ (DBG:FRAME-FUNCTION FRAME)
	      (FDEFINITION '(:INTERNAL (:PROPERTY DBG:BAD-DATA-TYPE DBG:DECODE) 0)))
      (LET ((INSTANCE-AND-SLOT (DBG:FRAME-ARG-VALUE FRAME 0)))
	(WHEN (AND (CONSP INSTANCE-AND-SLOT)
		   (EQ (CAR INSTANCE-AND-SLOT) INSTANCE)
		   (EQ (CDR INSTANCE-AND-SLOT) SLOT))
	  (RETURN (VALUES (DBG:FRAME-PREVIOUS-ACTIVE-FRAME FRAME)
			  INNERMOST-INTERESTING-FRAME)))))))

(DEFMETHOD SLOT-UNBOUND (CLASS INSTANCE SLOT-NAME)
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (IGNORE CLASS))
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (RESTART-CASE #+(OR Genera CLOE-Runtime) (ERROR 'UNBOUND-SLOT :INSTANCE INSTANCE :NAME SLOT-NAME)
		#-(OR Genera CLOE-Runtime) (ERROR "Slot ~S is unbound in ~S." SLOT-NAME INSTANCE)
    (CONTINUE
      ()
      :REPORT (LAMBDA (STREAM)
		(FORMAT STREAM "Retry reading slot ~S of ~S" SLOT-NAME INSTANCE))
      (SLOT-VALUE INSTANCE SLOT-NAME))
    (USE-VALUE
      (VALUE)
      :REPORT (LAMBDA (STREAM)
		(FORMAT STREAM "Supply a value to use this time as the contents of slot ~S of ~S"
			SLOT-NAME INSTANCE))
      :INTERACTIVE (LAMBDA ()
		     (LIST (PROMPT-AND-READ
			     "Form to evaluate use this time as the contents of slot ~S of ~S:~%"
			     SLOT-NAME INSTANCE)))
      VALUE)
    (STORE-VALUE
      (VALUE)
      :REPORT (LAMBDA (STREAM)
		(FORMAT STREAM "Supply a value to store permanently as the contents of slot ~S of ~S"
			SLOT-NAME INSTANCE))
      :INTERACTIVE (LAMBDA ()
		     (LIST (PROMPT-AND-READ
			     "Form to evaluate and store permanently as the contents of slot ~S of ~S:~%"
			     SLOT-NAME INSTANCE)))
      (SETF (SLOT-VALUE INSTANCE SLOT-NAME) VALUE))))

(DEFMETHOD CLASS-EQL-IS-EQ-P ((CLASS CLASS)) T)
#+(OR Genera Minima)
(DEFMETHOD CLASS-EQL-IS-EQ-P ((CLASS (EQL (FIND-CLASS 'DOUBLE-FLOAT)))) NIL)
(DEFMETHOD CLASS-EQL-IS-EQ-P ((CLASS (EQL (FIND-CLASS 'BIGNUM)))) NIL)
(DEFMETHOD CLASS-EQL-IS-EQ-P ((CLASS (EQL (FIND-CLASS 'COMPLEX)))) NIL)
;; Could make the big-ratio and small-ratio classes if we wanted.
(DEFMETHOD CLASS-EQL-IS-EQ-P ((CLASS (EQL (FIND-CLASS 'RATIO)))) NIL)

(DEFMETHOD MAP-OVER-CLASS-AND-ITS-SUBCLASSES ((CLASS CLASS) FUNCTION)
  (WHEN (CLASS-FINALIZED-P CLASS)
    (FUNCALL FUNCTION CLASS))
  (DOLIST (CLASS (CLASS-DIRECT-SUBCLASSES CLASS))
    (MAP-OVER-CLASS-AND-ITS-SUBCLASSES CLASS FUNCTION)))

(DEFMETHOD MAP-OVER-CLASS-AND-ITS-SUBCLASSES ((CLASS SYMBOL) FUNCTION)
  (MAP-OVER-CLASS-AND-ITS-SUBCLASSES (FIND-CLASS CLASS) FUNCTION))

(DEFMETHOD MAP-ALL-CLASS-COMPONENTS ((CLASS CLASS) FUNCTION STOP-CLASS)
  (DOLIST (C (CLASS-PRECEDENCE-LIST CLASS))
    (WHEN (EQ STOP-CLASS C) (RETURN))
    (FUNCALL FUNCTION C)))

(DEFMETHOD MAP-ALL-CLASS-COMPONENTS ((CLASS SYMBOL) FUNCTION STOP-CLASS)
  (MAP-ALL-CLASS-COMPONENTS (FIND-CLASS CLASS) FUNCTION STOP-CLASS))

(DEFMETHOD MAKE-LOAD-FORM ((GENERIC GENERIC-FUNCTION))
  (LET ((NAME (GENERIC-FUNCTION-NAME GENERIC)))
    (IF (AND NAME
	     (FBOUNDP NAME)
	     (EQ (FDEFINITION NAME) GENERIC))
	`(FDEFINITION ',NAME)
	(CALL-NEXT-METHOD))))

(DEFMETHOD MAKE-LOAD-FORM ((METHOD METHOD))
  `(FIND-METHOD ',(METHOD-GENERIC-FUNCTION METHOD)
		',(METHOD-QUALIFIERS METHOD)
		',(METHOD-SPECIALIZERS METHOD)))

;;; Some things to make debugging bearable

#-Genera
(DEFUN PRINT-FUNCTION (NAME FUNCTION STREAM)
  (LET ((CURRENTP (AND NAME
		       #+Genera (SI:VALID-FUNCTION-DEFINITION NAME)
		       (FBOUNDP NAME)
		       (EQ (FDEFINITION-IN-ENVIRONMENT NAME NIL NIL) FUNCTION))))
    (FLET ((PRINT-NAME (NAME)
	     #+Genera
	     ;; Maybe there's some CLIM thing that should go here
	     (DW::WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
					       :OBJECT NAME
					       :TYPE 'SYS:FUNCTION-SPEC)
	       (WRITE NAME :ESCAPE T :STREAM STREAM))
	     #-Genera
	     (WRITE NAME :ESCAPE T :STREAM STREAM)))
      (IF (OR (NULL CURRENTP)
	      *PRINT-ESCAPE*
	      *PRINT-READABLY*)
	  (PRINT-UNREADABLE-OBJECT (FUNCTION STREAM :TYPE T :IDENTITY T)
	    (COND (NAME
		   (IF CURRENTP
		       (PRINT-NAME NAME)
		       (WRITE NAME :ESCAPE T :STREAM STREAM))
		   (UNLESS CURRENTP
		     (WRITE-STRING " (Not the current definition)" STREAM))
		   #+Genera
		   ;; Should figure something out here for other systems
		   (WHEN (SI:FUNCTION-ENCAPSULATED-P (FDEFINITION NAME))
		     (WRITE-STRING " (Encapsulated)" STREAM)))
		  (T
		   (WRITE-STRING "unnamed" STREAM))))
	  (PRINT-NAME NAME)))))

(DEFMETHOD PRINT-OBJECT ((GENERIC GENERIC-FUNCTION) STREAM)
  (UNLESS (SLOT-BOUNDP GENERIC 'NAME)
    (RETURN-FROM PRINT-OBJECT (CALL-NEXT-METHOD)))
  (PRINT-FUNCTION (GENERIC-FUNCTION-NAME GENERIC) GENERIC STREAM))

#+(OR Genera Minima)
(DEFMETHOD PRINT-OBJECT ((GENERIC-FUNCTION-SELECTOR GENERIC-FUNCTION-SELECTOR)
			 (STREAM T))
  (PRINT-UNREADABLE-OBJECT (GENERIC-FUNCTION-SELECTOR STREAM :IDENTITY T)
    (FORMAT STREAM "Generic function selector for ~a"
	    (DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR GENERIC-FUNCTION-SELECTOR))))

(DEFMETHOD PRINT-OBJECT ((METHOD STANDARD-METHOD) STREAM)
  (UNLESS (AND (SLOT-BOUNDP METHOD 'GENERIC-FUNCTION)
	       (SLOT-BOUNDP METHOD 'QUALIFIERS)
	       (SLOT-BOUNDP METHOD 'SPECIALIZERS))
    (RETURN-FROM PRINT-OBJECT (CALL-NEXT-METHOD)))
  (LET* (#+Genera
	 (PARENT (AND (SLOT-BOUNDP METHOD 'FUNCTION-PARENT)
		      (SLOT-VALUE METHOD 'FUNCTION-PARENT)))
	 #+Genera
	 (PARENT-NAME (AND (CONSP PARENT)
			   (EQ (FIRST PARENT) 'METHOD)
			   (SECOND PARENT)))
	 (GENERIC-FUNCTION (METHOD-GENERIC-FUNCTION METHOD))
	 (NAME (AND GENERIC-FUNCTION (GENERIC-FUNCTION-NAME GENERIC-FUNCTION))))
    (FLET ((PRINT-IT ()
	     (COND #+Genera
		   (PARENT-NAME
		    (PRIN1 PARENT-NAME STREAM)
		    (COND ((EQUAL NAME PARENT-NAME))
			  ((NULL GENERIC-FUNCTION)
			   (WRITE-STRING " (Not the current definition)" STREAM))
			  (T
			   (WRITE-STRING " (Currently a method of " STREAM)
			   (WRITE GENERIC-FUNCTION :STREAM STREAM :ESCAPE NIL)
			   (WRITE-CHAR #\) STREAM))))
		   (GENERIC-FUNCTION
		    (WRITE GENERIC-FUNCTION :STREAM STREAM :ESCAPE NIL))
		   (T
		    (WRITE-STRING "(no generic function)" STREAM)))
	     (WRITE-CHAR #\Space STREAM)
	     (LET ((QUALIFIERS (METHOD-QUALIFIERS METHOD)))
	       (WHEN QUALIFIERS
		 (FORMAT STREAM "~s " QUALIFIERS)))
	     (LET ((SPECIALIZERS (METHOD-SPECIALIZERS METHOD)))
	       (WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT SPECIALIZERS)
		 (WHEN SPECIALIZERS
		   (FLET ((PRINT-SPECIALIZER (SPECIALIZER)
			    (IF (CONSP SPECIALIZER)
				(FORMAT STREAM "(EQL '~s)" (SECOND SPECIALIZER))
				(PRIN1 (CLASS-NAME-FOR-TYPE-OF SPECIALIZER) STREAM))))
		     (WRITE-CHAR #\( STREAM)
		     (PRINT-SPECIALIZER (CAR SPECIALIZERS))
		     (DOLIST (O (CDR SPECIALIZERS))
		       (WRITE-CHAR #\SPACE STREAM)
		       (PRINT-SPECIALIZER O)))
		   (WRITE-CHAR #\) STREAM))))))
      (COND ((OR *PRINT-READABLY*
		 *PRINT-ESCAPE*
		 #+Genera (NOT (EQUAL NAME PARENT-NAME))
		 (NULL GENERIC-FUNCTION))
	     (PRINT-UNREADABLE-OBJECT (METHOD STREAM :TYPE T :IDENTITY T)
	       (PRINT-IT)))
	    (T
	     (WRITE-STRING "(METHOD " STREAM)
	     (PRINT-IT)
	     (WRITE-CHAR #\) STREAM))))))

(DEFMETHOD PRINT-OBJECT ((INSTANCE STANDARD-OBJECT) STREAM)
  (PRINT-UNREADABLE-OBJECT (INSTANCE STREAM :TYPE T :IDENTITY T)))

#+Minima
(defmethod print-object :around ((instance standard-object) stream)
  (if (eql-dispatch-instance-p instance)
      (print-unreadable-object (instance stream :type nil :identity t)
	(write-string "EQL-DISPATCH-INSTANCE" stream))
      (call-next-method)))

;;; For the class-prototype of T
#+Genera
(DEFMETHOD PRINT-OBJECT ((INSTANCE T) STREAM)
  (PRINT-UNREADABLE-OBJECT (INSTANCE STREAM :IDENTITY T)
    (LET* ((CLASS (CLASS-OF INSTANCE))
	   (META-CLASS (CLASS-OF CLASS)))
      (FORMAT STREAM "~s ~s ~s"
	      (SYS:DATA-TYPE INSTANCE)
	      (CLASS-NAME META-CLASS)
	      (CLASS-NAME CLASS)))))

(DEFMETHOD PRINT-OBJECT ((CLASS CLASS) STREAM)
  (COND ((OR (NOT (SLOT-EXISTS-P CLASS 'NAME))
	     (NOT (SLOT-BOUNDP CLASS 'NAME)))
	 (CALL-NEXT-METHOD))
	((AND *PRINT-READABLY* *READ-EVAL* (CLASS-NAME-PROPER-P CLASS))
	 (FORMAT STREAM "#.~S" (MAKE-LOAD-FORM CLASS)))
	(T
	 (LET ((NAME (CLASS-NAME CLASS)))
	   (IF (AND (NULL *PRINT-READABLY*)
		    (NULL *PRINT-ESCAPE*)
		    NAME
		    (CLASS-NAME-PROPER-P CLASS))
	       (FORMAT STREAM "~s" NAME)
	       (PRINT-UNREADABLE-OBJECT (CLASS STREAM :TYPE T :IDENTITY T)
		 (IF (NULL NAME)
		     (WRITE-STRING "(anonymous)" STREAM)
		     (FORMAT STREAM "~s~:[ (improper)~;~]"
			     NAME
			     (CLASS-NAME-PROPER-P CLASS)))))))))

(DEFMETHOD PRINT-OBJECT ((MISCELLANEOUS-FUNCTION MISCELLANEOUS-FUNCTION)
			 (STREAM T))
  (UNLESS (SLOT-BOUNDP MISCELLANEOUS-FUNCTION 'NAME)
    (RETURN-FROM PRINT-OBJECT (CALL-NEXT-METHOD)))
  (PRINT-UNREADABLE-OBJECT (MISCELLANEOUS-FUNCTION STREAM :IDENTITY T :TYPE T)
    (PRINC (SLOT-VALUE MISCELLANEOUS-FUNCTION 'NAME) STREAM)))

(DEFMETHOD PRINT-OBJECT ((COMBINED-METHOD COMBINED-METHOD)
			 (STREAM T))
  (UNLESS (SLOT-BOUNDP COMBINED-METHOD 'INTERNAL)
    (RETURN-FROM PRINT-OBJECT (CALL-NEXT-METHOD)))
  (PRINT-UNREADABLE-OBJECT (COMBINED-METHOD STREAM :IDENTITY T :TYPE T)
    (FORMAT STREAM
	    "~:[~;(Internal) ~]~s"
	    (SLOT-VALUE COMBINED-METHOD 'INTERNAL)
	    (GENERIC-FUNCTION-NAME (SLOT-VALUE COMBINED-METHOD 'GENERIC-FUNCTION)))
    (LET ((SPECIALIZERS (SLOT-VALUE COMBINED-METHOD 'SPECIALIZERS)))
      (WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT SPECIALIZERS)
	(WHEN SPECIALIZERS
	  (WRITE-CHAR #\Space STREAM)
	  (WRITE-CHAR #\( STREAM)
	  (PRIN1 (SPECIALIZER-NAME (CAR SPECIALIZERS)) STREAM)
	  (DOLIST (O (CDR SPECIALIZERS))
	    (WRITE-CHAR #\SPACE STREAM)
	    (PRIN1 (SPECIALIZER-NAME O) STREAM))
	  (WRITE-CHAR #\) STREAM))))))

(DEFUN DEFAULT-DESCRIBE-OBJECT (OBJECT STREAM)
  (LET* ((CLASS (CLASS-OF OBJECT))
	 (SLOTS (CLASS-SLOTS CLASS)))
    (FORMAT STREAM "~&~s is an object of class ~s~%" OBJECT CLASS)
    (LET ((MIN-INDENTATION 27.)
	  (MAX-INDENTATION 40.)
	  (INDENTATION NIL))
      (SETQ INDENTATION
	    (MIN MAX-INDENTATION
		 (MAX MIN-INDENTATION
		      (+ 5 (LET ((TEMP MIN-INDENTATION))
			     (MAPC #'(LAMBDA (SLOT)
				       (SETQ TEMP (MAX #+Genera (SYS:FLATSIZE
								  (SLOT-DEFINITION-NAME SLOT))
						       #-Genera (LENGTH (SYMBOL-NAME (SLOT-DEFINITION-NAME SLOT)))
						       TEMP)))
				   SLOTS)
			     TEMP)))))
      (FLET ((SHOW-SLOT (SLOT)
	       (LET ((NAME (SLOT-DEFINITION-NAME SLOT)))
		 #+Genera
		 (SCL:PRESENT (LOCF (SLOT-VALUE OBJECT NAME))
			      `((DBG:NAMED-LOCATIVE-SLOT)
				:SYMBOL ,NAME
				:INDENTATION ,INDENTATION
				:STRUCTURE ,OBJECT)
			      :STREAM STREAM)
		 #-Genera
		 (LET ((*PRINT-CIRCLE* T)
		       (*PRINT-LEVEL* 4)
		       (*PRINT-LENGTH* 5))
		   (IF (SLOT-BOUNDP OBJECT NAME)
		       (FORMAT STREAM "  ~S ~vT~S" NAME INDENTATION (SLOT-VALUE OBJECT NAME))
		       (FORMAT STREAM "  ~S ~vTunbound" NAME INDENTATION)))
		 (TERPRI STREAM))))
	(LET ((CLASS-COUNT 0)
	      (INSTANCE-COUNT 0))
	  (DOLIST (SLOT SLOTS)
	    (IF (EQ (SLOT-DEFINITION-ALLOCATION SLOT) ':CLASS)
		(INCF CLASS-COUNT)
		(INCF INSTANCE-COUNT)))
	  (WHEN (> CLASS-COUNT 0)
	    (FORMAT STREAM "~&Class Slot~p:~&" CLASS-COUNT))
	  (DOLIST (SLOT SLOTS)
	    (WHEN (EQ (SLOT-DEFINITION-ALLOCATION SLOT) ':CLASS)
	      (SHOW-SLOT SLOT)))
	  (WHEN (> INSTANCE-COUNT 0)
	    (FORMAT STREAM "~&Instance Slot~p:~&" INSTANCE-COUNT)))
	(DOLIST (SLOT SLOTS)
	  (UNLESS (EQ (SLOT-DEFINITION-ALLOCATION SLOT) ':CLASS)
	    (SHOW-SLOT SLOT)))
	OBJECT))))

(DEFMETHOD DESCRIBE-OBJECT ((OBJECT STANDARD-OBJECT) STREAM)
  (DEFAULT-DESCRIBE-OBJECT OBJECT STREAM))

(DEFMETHOD ARGLIST-OBJECT ((OBJECT STANDARD-GENERIC-FUNCTION))
  (GENERIC-FUNCTION-LAMBDA-LIST OBJECT))

(DEFMETHOD CLASS-SLOTS ((CLASS BUILT-IN-CLASS))
  NIL)

(DEFMETHOD CLASS-SLOTS ((CLASS STANDARD-CLASS))
  (IF (CLASS-FINALIZED-P CLASS)
      (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS
	(CLASS-INSTANCE-INFORMATION CLASS))
      (COMPUTE-SLOTS CLASS)))

(DEFMETHOD CLASS-SLOTS ((CLASS STRUCTURE-CLASS))
  (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS
    (CLASS-INSTANCE-INFORMATION CLASS)))

#+Genera
(DEFMETHOD CLASS-SLOTS ((CLASS FLAVOR-CLASS))
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (LET ((FLAVOR (CLASS-INSTANCE-INFORMATION CLASS)))
    (UNLESS (FLAVOR::FLAVOR-INSTANTIABLE FLAVOR)
      (FLAVOR::PREPARE-FOR-INSTANTIATION FLAVOR))
    (LOOP FOR NAME IN (FLAVOR::FLAVOR-ALL-INSTANCE-VARIABLES FLAVOR)
	  FOR POSITION FROM 1
	  WITH INITS = (FLAVOR::FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FLAVOR)
	  WITH INITFORMS = (FLAVOR::FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS FLAVOR)
	  WITH PROTOTYPE = (FLAVOR::FLAVOR-TEMPLATE-INSTANCE FLAVOR)
	  WITH PROTO = (LOCF (%INSTANCE-REF PROTOTYPE POSITION))
	  AS INITFORM = (FIND POSITION INITFORMS :KEY #'SECOND)
	  COLLECT (MAKE-INSTANCE 'STANDARD-EFFECTIVE-SLOT-DEFINITION
				 :ALLOCATION ':INSTANCE
				 :INITARGS (LOOP FOR (KEY SLOT) IN INITS
						 WHEN (= SLOT POSITION) COLLECT KEY)
				 :INITFORM (IF (LOCATION-BOUNDP PROTO)
					       (LOCATION-CONTENTS PROTO)
					       (FIRST INITFORM))
				 :INITFUNCTION (IF (LOCATION-BOUNDP PROTO)
						   (CONSTANTLY (LOCATION-CONTENTS PROTO))
						   (AND INITFORM
							(MAKE-EVAL-CLOSURE (FIRST INITFORM))))
				 :LOCATION POSITION
				 :NAME NAME
				 :TYPE 'T))))

(DEFMETHOD CLASS-DEFAULT-INITARGS ((CLASS STANDARD-CLASS))
  (IF (CLASS-FINALIZED-P CLASS)
      (SLOT-VALUE CLASS 'DEFAULT-INITARGS)
      (COMPUTE-DEFAULT-INITARGS CLASS)))

(DEFMETHOD CLASS-PROTOTYPE ((CLASS STANDARD-CLASS))
  (UNLESS (CLASS-FINALIZED-P CLASS)
    (FINALIZE-INHERITANCE CLASS))
  (SLOT-VALUE CLASS 'PROTOTYPE))

#+Genera
(DEFMETHOD CLASS-PROTOTYPE ((CLASS FLAVOR-CLASS))
  (LET ((FLAVOR (CLASS-INSTANCE-INFORMATION CLASS)))
    (UNLESS (FLAVOR::FLAVOR-INSTANTIABLE FLAVOR)
      (FLAVOR::PREPARE-FOR-INSTANTIATION FLAVOR))
    (FLAVOR::FLAVOR-TEMPLATE-INSTANCE FLAVOR)))

(DEFMETHOD CLASS-NAME-FOR-TYPE-OF ((CLASS CLASS))
  (IF (CLASS-NAME-PROPER-P CLASS)
      (CLASS-NAME CLASS)
      CLASS))

(DEFMETHOD CLASS-NAME-FOR-TYPE-OF ((CLASS STANDARD-CLASS))
  (IF (LDB-TEST %%STANDARD-CLASS-TYPE-IS-CLASS (CLASS-BITS CLASS))
      CLASS
      (CLASS-NAME CLASS)))

(DEFMETHOD CLASS-NAME-PROPER-P ((CLASS CLASS))
  (EQ (FIND-CLASS (CLASS-NAME CLASS) NIL) CLASS))

(DEFMETHOD CLASS-NAME-PROPER-P ((CLASS STANDARD-CLASS))
  (NOT (LDB-TEST %%STANDARD-CLASS-TYPE-IS-CLASS (SLOT-VALUE CLASS 'BITS))))

(DEFMETHOD NOTICE-CLASS-NAME-CHANGE ((CLASS CLASS))
  NIL)

(DEFMETHOD NOTICE-CLASS-NAME-CHANGE ((CLASS STANDARD-CLASS))
  (SETF (LDB %%STANDARD-CLASS-TYPE-IS-CLASS (SLOT-VALUE CLASS 'BITS))
	(IF (LET ((NAME (CLASS-NAME CLASS)))
	      (NOT (AND (SYMBOLP NAME)
			(EQ (FIND-CLASS NAME NIL) CLASS))))
	    -1 0)))

#+Genera
(DEFMETHOD NOTICE-CLASS-NAME-CHANGE :AFTER ((CLASS CLASS))
  (WHEN (CLASS-FINALIZED-P CLASS)
    ;; Tell DW that each superclass' subclasses may have different names now
    (WITH-PENDING-DW-UPDATES
      (DOLIST (CLASS (CLASS-PRECEDENCE-LIST CLASS))
	(NOTE-CLASS-CHANGE-FOR-DW CLASS)))))

#+Genera
(DEFMETHOD PRINT-SELF ((OBJECT MESSAGE-PASSING-MIXIN) STREAM PRINT-DEPTH SLASHIFY-P)
  (DECLARE (IGNORE PRINT-DEPTH))
  (LET ((*PRINT-ESCAPE* SLASHIFY-P))
    (PRINT-OBJECT OBJECT STREAM)))

;;; This doesn't work.
;(DEFMETHOD FORMAT-SELF (OBJECT STREAM)
;  (PRINT-OBJECT OBJECT STREAM))

#+Genera
(DEFMETHOD DESCRIBE-OBJECT (OBJECT STREAM)
  (SI:DEFAULT-DESCRIBE OBJECT STREAM))

#+Genera
(DEFMETHOD SEND-IF-HANDLES ((OBJECT MESSAGE-PASSING-MIXIN) MESSAGE &REST REST)
  (DECLARE (DYNAMIC-EXTENT REST))
  (WHEN (OPERATION-HANDLED-P OBJECT MESSAGE)
    (SCL:LEXPR-SEND OBJECT MESSAGE REST)))

#+Genera
(DEFMETHOD WHICH-OPERATIONS ((OBJECT MESSAGE-PASSING-MIXIN))
  (LET ((OPERATIONS
	  '(:SEND-IF-HANDLES :WHICH-OPERATIONS :OPERATION-HANDLED-P :PRINT-SELF))
	(CLASSES (CLASS-PRECEDENCE-LIST (CLASS-OF OBJECT))))
    (DOLIST (GENERIC-FUNCTION *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS*)
      (LET ((SELECTOR (GENERIC-FUNCTION-SELECTOR GENERIC-FUNCTION)))
	(UNLESS (MEMBER SELECTOR OPERATIONS)
	  (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
	    (LET ((METHOD-SPECIALIZER (FIRST (METHOD-SPECIALIZERS METHOD))))
	      (WHEN (TYPECASE METHOD-SPECIALIZER
		      (CLASS
			(MEMBER METHOD-SPECIALIZER CLASSES))
		      (CONS
			(MULTIPLE-VALUE-BIND (EQL-P EQL-OBJECT)
			    (EQL-METHOD-SPECIALIZER-P METHOD-SPECIALIZER)
			  (COND (EQL-P
				 (EQL EQL-OBJECT OBJECT))))))
		(PUSH SELECTOR OPERATIONS)
		(RETURN)))))))
    OPERATIONS))

#+Genera
(DEFMETHOD OPERATION-HANDLED-P ((OBJECT MESSAGE-PASSING-MIXIN) MESSAGE)
  (CASE MESSAGE
    ((:SEND-IF-HANDLES :WHICH-OPERATIONS :OPERATION-HANDLED-P :PRINT-SELF)
     ;; Every member of MESSAGE-PASSING-MIXIN handles these
     (RETURN-FROM OPERATION-HANDLED-P T)))
  (LET ((GENERIC (DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR MESSAGE)))
    (WHEN GENERIC
      (LET ((CLASSES (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		       (%INSTANCE-INFORMATION-INLINE OBJECT))))
	(DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC))
	  (LET ((METHOD-SPECIALIZER (FIRST (METHOD-SPECIALIZERS METHOD))))
	    (WHEN (IF (TYPEP METHOD-SPECIALIZER 'ATOM)
		      (MEMBER METHOD-SPECIALIZER CLASSES)
		      (EQL (SECOND METHOD-SPECIALIZER) OBJECT))
	      (RETURN-FROM OPERATION-HANDLED-P T))))))))


;;; STANDARD-METHODs don't have function parents.  They are defined by DEFMETHOD.
#+Genera
(DEFMETHOD FUNCTION-PARENT-OBJECT ((METHOD-OBJECT STANDARD-METHOD))
  NIL)

;;; The parent of a STANDARD-ACCESSOR-METHOD is the DEFCLASS which defines it.
#+Genera
(DEFMETHOD FUNCTION-PARENT-OBJECT ((METHOD-OBJECT STANDARD-ACCESSOR-METHOD))
  (LET ((CLASS (CAR (LAST (METHOD-SPECIALIZERS METHOD-OBJECT)))))
    (VALUES (CLASS-NAME-FOR-TYPE-OF CLASS) 'DEFCLASS)))

;;; Calculate the function spec using the traditional means
#+Genera
(DEFMETHOD FUNCTION-SPEC-OBJECT ((METHOD-OBJECT STANDARD-METHOD))
  (IF (SLOT-BOUNDP METHOD-OBJECT 'FUNCTION-PARENT)
      (SLOT-VALUE METHOD-OBJECT 'FUNCTION-PARENT)
      (LET ((METHOD-FUNCTION (CLOS:METHOD-FUNCTION METHOD-OBJECT)))
	  (IF METHOD-FUNCTION
	      (SYS:FUNCTION-NAME METHOD-FUNCTION)
	      NIL))))

(DEFMETHOD METHOD-FUNCTION ((METHOD-OBJECT STANDARD-ACCESSOR-METHOD))
  NIL)

;;; accessor methods don't really have a method-function.  They have the slot but there's
;;; nothing in it.  Fudge a function spec for them.
#+Genera
(DEFMETHOD FUNCTION-SPEC-OBJECT ((METHOD-OBJECT STANDARD-ACCESSOR-METHOD))
  `(METHOD ,(GENERIC-FUNCTION-NAME (METHOD-GENERIC-FUNCTION METHOD-OBJECT))
	   ,(MAPCAR #'CLASS-NAME-FOR-TYPE-OF
		    (METHOD-SPECIALIZERS METHOD-OBJECT))
	   ,@(METHOD-QUALIFIERS METHOD-OBJECT)))


(INITIALIZE-CLOS-4)
