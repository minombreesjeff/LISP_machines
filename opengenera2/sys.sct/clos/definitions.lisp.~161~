;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

(DEFPARAMETER *AND-~S-FORMAT-STRING* "~#[~; ~:s~; ~:s and ~:s~:;~@{~#[~; and~] ~:s~^,~}~]")
(DEFPARAMETER *AND-~A-FORMAT-STRING* "~#[~; ~:a~; ~:a and ~:a~:;~@{~#[~; and~] ~:a~^,~}~]")

(DEFMACRO WITH-CLASS-UPDATES (&BODY BODY)
  `(WITHOUT-ABORTS (WITH-CLASS-UPDATES
		    "CLOS class tables are being updated.~@
                     If you abort now, the tables may be left in an inconsistent state~@
                     with only some of the changes in effect.")
     ,@BODY))

(DEFMACRO WITH-CLASS-UPDATES-ENABLE-ABORTS (&BODY BODY)
  `(WITH-ABORTS-ENABLED (WITH-CLASS-UPDATES)
     ,@BODY))


(DEFPARAMETER *GENERIC-FUNCTION-METHOD-CHANGES* NIL)

(DEFUN NOTE-GENERIC-FUNCTION-METHOD-CHANGE (GENERIC-FUNCTION METHOD CHANGE)
  (ASSERT (CLOS-LOCKED-P))
  (LET ((GENERIC-INFO (ASSOC GENERIC-FUNCTION *GENERIC-FUNCTION-METHOD-CHANGES*)))
    (WHEN (NULL GENERIC-INFO)
      (PUSH (SETQ GENERIC-INFO (LIST GENERIC-FUNCTION NIL NIL))
	    *GENERIC-FUNCTION-METHOD-CHANGES*))
    (ECASE CHANGE
      (:ADD
	(PUSH METHOD (SECOND GENERIC-INFO)))
      (:REMOVE
	(PUSH METHOD (THIRD GENERIC-INFO))))))

(DEFUN GET-GENERIC-FUNCTION-METHOD-CHANGES (GENERIC-FUNCTION &OPTIONAL (DELETE T))
  #+Genera (DECLARE (VALUES ADDED-METHODS REMOVED-METHODS))
  (LET ((GENERIC-INFO (ASSOC GENERIC-FUNCTION *GENERIC-FUNCTION-METHOD-CHANGES*)))
    (WHEN DELETE
      (ASSERT (CLOS-LOCKED-P))
      (SETQ *GENERIC-FUNCTION-METHOD-CHANGES*
	    (DELETE GENERIC-INFO *GENERIC-FUNCTION-METHOD-CHANGES*)))
    (VALUES (SECOND GENERIC-INFO)
	    (THIRD GENERIC-INFO))))

(DEFVAR-RESETTABLE *INHIBIT-DISPATCH-CACHE-UPDATING* NIL)

(DEFPARAMETER *DISABLE-SUPERCLASS-VALIDATION* NIL)

#+Genera
(SCL:DEFPROP DEFCLASS "CLOS class" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFCLASS (CLASS-NAME SUPERCLASS-NAMES SLOT-SPECIFIERS &REST CLASS-OPTIONS
		    &ENVIRONMENT ENV)
  #+Genera (DECLARE (ZWEI:INDENTATION 1 9 2 3 3 1))
  (PARSING-DEFINITION (CLASS-NAME DEFCLASS)
    (LET ((ALL-READERS NIL)
	  (ALL-WRITERS NIL)
	  #+(OR Genera Minima) (ALL-LOCATORS NIL)
	  (SLOT-DEFINITION-SPECIFIERS NIL)
	  (INITARGS-P NIL)
	  (INITARGS NIL)
	  (DOCUMENTATION-P NIL)
	  (DOCUMENTATION NIL)
	  (METACLASS-P NIL)
	  (METACLASS-NAME NIL)
	  (METACLASS NIL)
	  (METACLASS-INSTANCE NIL)
	  (PARSED-CLASS-NAME CLASS-NAME)
	  (PARSED-SUPERCLASS-NAMES SUPERCLASS-NAMES))
      ;; Start with the metaclass
      (LET ((PLACE CLASS-OPTIONS))
	(LOOP
	  (WHEN (NULL PLACE) (RETURN))
	  (WHEN (ATOM PLACE)
	    (PARSE-WARN "The non-list tail ~s was found in the class options.  It will be ~
                         ignored."
			PLACE)
	    (RETURN))
	  (LET ((CLASS-OPTION (POP PLACE)))
	    (BLOCK CLASS-OPTION
	      (FLET ((SPECIFIED-TWICE (ARG)
		       (PARSE-WARN
			 "The class option ~s was specified twice.  Only the first ~
                          use will be used."
			 ARG)
		       (RETURN-FROM CLASS-OPTION)))
		(UNLESS (CONSP CLASS-OPTION)
		  (PARSE-WARN
		    "The non-list class option ~s was encountered.  It will be ignored."
		    CLASS-OPTION)
		  (RETURN-FROM CLASS-OPTION))
		(CASE (FIRST CLASS-OPTION)
		  (:METACLASS
		    (WHEN METACLASS-P (SPECIFIED-TWICE :METACLASS))
		    (SETQ METACLASS-P T)
		    (COND ((AND (CONSP (CDR CLASS-OPTION))
				(NULL (CDDR CLASS-OPTION))
				(SYMBOLP (SECOND CLASS-OPTION)))
			   (SETQ METACLASS-NAME (SECOND CLASS-OPTION)))
			  (T
			   (PARSE-WARN
			     "~s is not a valid class option.  It should be of the form ~
                              (~s class-name), where class-name is a non-null symbol. ~
                              ~s will be used."
			     CLASS-OPTION ':METACLASS 'STANDARD-CLASS)
			   (SETQ METACLASS-NAME 'STANDARD-CLASS))))
		  (OTHERWISE)))))))
      (UNLESS METACLASS-P
	(SETQ METACLASS-NAME 'STANDARD-CLASS))
      (WHEN *CLOS-INITIALIZED-P*
	(UNLESS (SETQ METACLASS (FIND-CLASS METACLASS-NAME NIL))
	  (PARSE-WARN
	    "~s is not a valid metaclass name.  ~s will be used."
	    METACLASS-NAME 'STANDARD-CLASS)
	  (SETQ METACLASS-NAME 'STANDARD-CLASS)
	  (SETQ METACLASS (FIND-CLASS METACLASS-NAME)))
	(UNLESS (CLASS-FINALIZED-P METACLASS)
	  (FINALIZE-INHERITANCE METACLASS))
	(SETQ METACLASS-INSTANCE (CLASS-PROTOTYPE METACLASS)))

      ;; Now do the remaining class options
      (LET ((PLACE CLASS-OPTIONS))
	(LOOP
	  (WHEN (NULL PLACE) (RETURN))
	  (WHEN (ATOM PLACE)
	    (PARSE-WARN "The non-list tail ~s was found in the class options.  It will be ~
                         ignored."
			PLACE)
	    (RETURN))
	  (LET ((CLASS-OPTION (POP PLACE)))
	    (BLOCK CLASS-OPTION
	      (FLET ((SPECIFIED-TWICE (ARG)
		       (PARSE-WARN
			 "The class option ~s was specified twice.  Only the first ~
                          use will be used."
			 ARG)
		       (RETURN-FROM CLASS-OPTION)))
		(UNLESS (CONSP CLASS-OPTION)
		  (PARSE-WARN
		    "The non-list class option ~s was encountered.  It will be ignored."
		    CLASS-OPTION)
		  (RETURN-FROM CLASS-OPTION))
		(CASE (FIRST CLASS-OPTION)
		  (:DEFAULT-INITARGS
		    (WHEN INITARGS-P (SPECIFIED-TWICE :DEFAULT-INITARGS))
		    ;; The initargs are evaluated in the lexical environment of the
		    ;; DEFCLASS, but the dynamic environment of the
		    ;; make-instance.
		    (LET* ((BACKWARDS NIL)
			   (PLIST (CDR CLASS-OPTION)))
		      (LOOP
			(WHEN (NULL PLIST) (RETURN))
			(WHEN (OR (ATOM PLIST)
				  (ATOM (CDR PLIST)))
			  (PARSE-WARN
			    "The class option ~s is not a list.  The tail ~s will be ignored."
			    CLASS-OPTION PLIST)
			  (RETURN))
			(LET ((KEY (POP PLIST))
			      (FORM (POP PLIST)))
			  (IF (SYMBOLP KEY)
			      (PUSH `(LIST ',KEY
					   ',FORM
					   ,(MAKE-INITFUNCTION FORM ENV 'STANDARD-CLASS-DEFAULT-INITARG-FUNCTION CLASS-NAME KEY)
					   ',(INITFORM-INLINABLE FORM ENV))
				    BACKWARDS)
			      (PARSE-WARN
				"~s is not a valid initarg keyword.  It will be ignored."
				KEY))))
		      (SETQ INITARGS (NREVERSE BACKWARDS))
		      (SETQ INITARGS-P T)))
		  (:DOCUMENTATION
		    (WHEN DOCUMENTATION-P (SPECIFIED-TWICE :DOCUMENTATION))
		    (SETQ DOCUMENTATION-P T)
		    (IF (AND (CONSP (CDR CLASS-OPTION))
			     (NULL (CDDR CLASS-OPTION))
			     (STRINGP (SECOND CLASS-OPTION)))
			(SETQ DOCUMENTATION (SECOND CLASS-OPTION))
			(PARSE-WARN
			  "~s is not a valid class option.  It should be of the form ~
                           (~s string)."
			  CLASS-OPTION ':DOCUMENTATION)))
		  (:METACLASS)
		  (OTHERWISE
		    (PARSE-WARN
		      "~s is not one of the known class options~? to ~s. ~@
		      It will be ignored."
		      CLASS-OPTION
		      *AND-~S-FORMAT-STRING*
		      '(:DEFAULT-INITARGS :DOCUMENTATION :METACLASS)
		      'DEFCLASS))))))))
      
      (UNLESS (AND CLASS-NAME (TYPEP CLASS-NAME 'SYMBOL))
	(SETQ PARSED-CLASS-NAME (GENSYM))
	(PARSE-WARN
	  "The class name ~s is not a non-nil symbol.  ~s will be used."
	  CLASS-NAME PARSED-CLASS-NAME))

      ;; Check the superclass names to makes sure that they are a list of non-null
      ;; symbols.
      (LET ((PUSHP NIL)
	    (REVERSED-PARSED-SUPERCLASS-NAMES NIL)
	    (PLACE SUPERCLASS-NAMES))
	(LOOP
	  (WHEN (NULL PLACE) (RETURN))
	  (WHEN (ATOM PLACE)
	    (PARSE-WARN
	      "The non-list tail ~s was encountered in the list of superclass names.  It will
               be ignored."
	      PLACE)
	    (UNLESS PUSHP
	      (DO ((CONS SUPERCLASS-NAMES))
		  ((ATOM CONS))
		(PUSH (POP CONS) REVERSED-PARSED-SUPERCLASS-NAMES)))
	    (SETQ PUSHP T)
	    (RETURN))
	  (LET ((SUPERCLASS-NAME (POP PLACE)))
	    (COND ((NOT (AND SUPERCLASS-NAME (SYMBOLP SUPERCLASS-NAME)))
		   (PARSE-WARN
		     "The superclass name ~s is not a non-null symbol.  It will be ignored."
		     SUPERCLASS-NAME)
		   (UNLESS PUSHP
		     (DOLIST (SUPERCLASS-NAME SUPERCLASS-NAMES)
		       ;; In some systems, the broken superclass name could be an object
		       ;; for which EQ is not a safe comparison, so look for the first
		       ;; non-null symbol, which is guaranteed to be our target.
		       (IF (AND SUPERCLASS-NAME (SYMBOLP SUPERCLASS-NAME))
			   (PUSH SUPERCLASS-NAME REVERSED-PARSED-SUPERCLASS-NAMES)
			   (RETURN)))
		     (SETQ PUSHP T)))
		  (PUSHP (PUSH SUPERCLASS-NAME REVERSED-PARSED-SUPERCLASS-NAMES))
		  (T NIL))))
	(WHEN PUSHP (SETQ PARSED-SUPERCLASS-NAMES
			  (NREVERSE REVERSED-PARSED-SUPERCLASS-NAMES))))
      
      (LET ((ALL-NAMES NIL)
	    (PLACE SLOT-SPECIFIERS))
	(LOOP
	  (WHEN (NULL PLACE) (RETURN))
	  (WHEN (ATOM PLACE)
	    (PARSE-WARN
	      "The non-list tail ~s of the list of slot specifiers was encountered. ~
               It will be ignored."
	      PLACE)
	    (RETURN))
	  (LET ((SLOT-SPECIFIER (POP PLACE)))
	    (BLOCK SLOT-SPECIFIER
	      (FLET ((CHECK-NAME (NAME)
		       (WHEN (MEMBER NAME ALL-NAMES)
			 (PARSE-WARN
			   "The slot-name ~s is specified twice.  Only the first slot ~
                            specifier will be used."
			   NAME)
			 (RETURN-FROM SLOT-SPECIFIER))
		       (UNLESS (AND NAME (SYMBOLP NAME))
			 (PARSE-WARN
			   "The slot-name ~s is not a non-null symbol." NAME)
			 (RETURN-FROM SLOT-SPECIFIER))
		       (PUSH NAME ALL-NAMES)
		       NAME))
		(WHEN (TYPEP SLOT-SPECIFIER 'SYMBOL)
		  (CHECK-NAME SLOT-SPECIFIER)
		  (PUSH `(LIST :NAME ',SLOT-SPECIFIER) SLOT-DEFINITION-SPECIFIERS)
		  (RETURN-FROM SLOT-SPECIFIER))
		(LET ((ALLOCATION NIL)
		      (ALLOCATION-P NIL)
		      (INITARGS NIL)
		      (INITFORM NIL)
		      (INITFORM-P NIL)
		      (TYPE NIL)
		      (TYPE-P NIL)
		      (DOCUMENTATION NIL)
		      (DOCUMENTATION-P NIL)
		      (PLACE (CDR SLOT-SPECIFIER))
		      (READERS NIL)
		      (WRITERS NIL)
		      #+(OR Genera Minima) (LOCATORS NIL)
		      (KEYWORD NIL)
		      (VALUE NIL))
		  (LOOP
		    (WHEN (NULL PLACE) (RETURN))
		    (WHEN (ATOM PLACE)
		      (PARSE-WARN
			"The non-list tail ~s was found in the slot specifier ~s. It ~
                         will be ignored."
			PLACE SLOT-SPECIFIER)
		      (RETURN))
		    (FLET ((SPECIFIED-TWICE (ARG)
			     (PARSE-WARN
			       "~s specified twice in the slot specifier ~s.  Only the ~
                                first use will be used."
			       ARG SLOT-SPECIFIER)))
		      (SETQ KEYWORD (POP PLACE))
		      (WHEN (ATOM PLACE)
			(PARSE-WARN
			  "The non-list tail ~s was found after the keyword ~s in the slot ~
                           specifier ~s. It will be ignored."
			  PLACE KEYWORD SLOT-SPECIFIER)
			(RETURN))
		      (SETQ VALUE (POP PLACE))
		      (CASE KEYWORD
			(:READER
			  (IF (SYMBOLP VALUE)
			      (PUSH VALUE READERS)
			      (PARSE-WARN
				"The reader function name ~s is not a symbol.  It will be ~
                                 ignored."
				VALUE)))
			(:WRITER
			  (IF (OR (SYMBOLP VALUE)
				  (AND (CONSP VALUE)
				       (OR (EQ (FIRST VALUE) 'SETF)
					   #+Genera (EQ (FIRST VALUE) 'SCL:SETF))
				       (CONSP (CDR VALUE))
				       (SYMBOLP (SECOND VALUE))
				       (NULL (CDDR VALUE))))
			      (PUSH VALUE WRITERS)
			      (PARSE-WARN
				#-Genera
				"The writer function name ~s is not either a symbol or a list ~
                                 of the form (~s symbol).  It will be ignored."
				#+Genera
				"The writer function name ~s is not either a symbol or a list ~
                                 of the form (~s symbol) or (~s symbol).  It will be ignored."
				VALUE 'SETF #+Genera 'SCL:SETF)))
			(:ACCESSOR
			  (COND ((SYMBOLP VALUE)
				 (PUSH VALUE READERS)
				 (PUSH `(SETF ,VALUE) WRITERS))
				(T
				 (PARSE-WARN
				   "The accessor function name ~s is not a symbol.  It will ~
                                    be ignored."
				   VALUE))))
			(:ALLOCATION
			  (WHEN ALLOCATION-P (SPECIFIED-TWICE :ALLOCATION))
			  (UNLESS (OR (EQ VALUE :INSTANCE) (EQ VALUE :CLASS))
			    (PARSE-WARN
			      ":ALLOCATION ~s is not either ~s or ~s.  ~s will be used."
			      VALUE :INSTANCE :CLASS :INSTANCE)
			    (SETQ VALUE :INSTANCE))
			  (SETQ ALLOCATION-P T)
			  (SETQ ALLOCATION VALUE))
			(:INITARG
			  (COND ((TYPEP VALUE 'SYMBOL)
				 (PUSH VALUE INITARGS))
				(T
				 (PARSE-WARN
				   "The :INITARG ~s is not a symbol.  It will be ignored."
				   VALUE))))
			(:INITFORM
			  (WHEN INITFORM-P (SPECIFIED-TWICE :INITFORM))
			  (SETQ INITFORM-P T)
			  (SETQ INITFORM VALUE))
			(:TYPE
			  (WHEN TYPE-P (SPECIFIED-TWICE :TYPE))
			  (SETQ TYPE-P T)
			  (SETQ TYPE VALUE))
			(:DOCUMENTATION
			  (WHEN DOCUMENTATION-P (SPECIFIED-TWICE :DOCUMENTATION))
			  (SETQ DOCUMENTATION-P T)
			  (IF (TYPEP VALUE 'STRING)
			      (SETQ DOCUMENTATION VALUE)
			      (PARSE-WARN
				":DOCUMENTATION ~s is not a string.  It will be ignored."
				VALUE)))
			#+(OR Genera Minima)
			(:LOCATORS
			  (IF (OR (SYMBOLP VALUE)
				  (AND (CONSP VALUE)
				       (EQ (FIRST VALUE) 'LOCF)
				       (CONSP (CDR VALUE))
				       (SYMBOLP (SECOND VALUE))
				       (NULL (CDDR VALUE))))
			      (PUSH VALUE LOCATORS)
			      (PARSE-WARN
				"The locator function name ~s is not either a symbol or a ~
                                 list of the form (~s symbol).  It will be ignored."
				VALUE 'LOCF)))
			(OTHERWISE
			  (PARSE-WARN
			    "~s is an invalid slot option.  It will be ignored."
			    KEYWORD)))))
		  (SETQ ALL-READERS (APPEND READERS ALL-READERS))
		  (SETQ ALL-WRITERS (APPEND WRITERS ALL-WRITERS))
		  #+(OR Genera Minima)
		  (SETQ ALL-LOCATORS (APPEND LOCATORS ALL-LOCATORS))
		  ;; Construct the form which becomes the :SLOTS option
		  ;; to the ensure class
		  (PUSH
		    `(LIST
		       :NAME ',(CHECK-NAME (FIRST SLOT-SPECIFIER))
		       ,@(WHEN READERS `(:READERS '(,@(NREVERSE READERS))))
		       ,@(WHEN WRITERS `(:WRITERS '(,@(NREVERSE WRITERS))))
		       #+(OR Genera Minima)
		       ,@(WHEN LOCATORS `(:LOCATORS '(,@(NREVERSE LOCATORS))))
		       ,@(WHEN ALLOCATION-P `(:ALLOCATION ',ALLOCATION))
		       ,@(WHEN INITARGS `(:INITARGS '(,@INITARGS)))
		       ,@(WHEN INITFORM-P
			   `(:INITFORM ',INITFORM
			     :INITFUNCTION ,(MAKE-INITFUNCTION INITFORM ENV 'STANDARD-CLASS-SLOT-INITFUNCTION CLASS-NAME (FIRST SLOT-SPECIFIER))
			     'INITFORM-INLINABLE ',(INITFORM-INLINABLE INITFORM ENV)))
		       ,@(WHEN TYPE-P `(:TYPE ',TYPE))
		       ,@(WHEN DOCUMENTATION-P `(:DOCUMENTATION ,DOCUMENTATION)))
		    SLOT-DEFINITION-SPECIFIERS)
		  (RETURN-FROM SLOT-SPECIFIER)))))))
      (SETQ SLOT-DEFINITION-SPECIFIERS (NREVERSE SLOT-DEFINITION-SPECIFIERS))
      
      (FLET ((SUPERCLASS-LIST (&OPTIONAL ENV)
	       (OR PARSED-SUPERCLASS-NAMES
		   (IF *CLOS-INITIALIZED-P*
		       (CLASS-DEFAULT-DIRECT-SUPERCLASSES
			 METACLASS-INSTANCE :ENVIRONMENT ENV)
		       (ECASE METACLASS-NAME
			 (STANDARD-CLASS '(STANDARD-OBJECT))
			 (BUILT-IN-CLASS '()))))))
	`(PROGN
	   (EVAL-WHEN (:COMPILE-TOPLEVEL)
	     ,@(MAPCAR #'(LAMBDA (FUNCTION-NAME)
			   `(ENSURE-GENERIC-FUNCTION
			      ',FUNCTION-NAME
			      :ENVIRONMENT ',(STATIC-ENVIRONMENT ENV)))
		       ALL-READERS)
	     ,@(MAPCAR #'(LAMBDA (FUNCTION-NAME)
			   `(ENSURE-GENERIC-FUNCTION
			      ',FUNCTION-NAME
			      :ENVIRONMENT ',(STATIC-ENVIRONMENT ENV)))
		       ALL-WRITERS)
	     #+(OR Genera Minima)
	     ,@(MAPCAR #'(LAMBDA (FUNCTION-NAME)
			   `(ENSURE-GENERIC-FUNCTION
			      ',FUNCTION-NAME
			      :ENVIRONMENT ',(STATIC-ENVIRONMENT ENV)))
		       ALL-LOCATORS)
	     (ENSURE-CLASS ',CLASS-NAME
			   :ENVIRONMENT ',(STATIC-ENVIRONMENT ENV)
			   :DIRECT-SUPERCLASSES ',(SUPERCLASS-LIST
						    (STATIC-ENVIRONMENT ENV))
			   :SLOTS (LIST ,@SLOT-DEFINITION-SPECIFIERS)
			   :METACLASS ',METACLASS-NAME
			   :DEFAULT-INITARGS (LIST ,@INITARGS)))
	   (ENSURE-CLASS ',CLASS-NAME
			 :DIRECT-SUPERCLASSES ',(SUPERCLASS-LIST)
			 :SLOTS (LIST ,@SLOT-DEFINITION-SPECIFIERS)
			 :METACLASS ',METACLASS-NAME
			 :DOCUMENTATION ',DOCUMENTATION
			 :DEFAULT-INITARGS (LIST ,@INITARGS)))))))

#+CLOE-Runtime
(SYSTEM::DEFINE-COMPILE-FILE-PRINTER DEFCLASS "Class")

(DEFMACRO DEFINE-BUILT-IN-CLASS (NAME SUPERCLASSES)
  `(ENSURE-CLASS ',NAME :DIRECT-SUPERCLASSES ',SUPERCLASSES :METACLASS 'BUILT-IN-CLASS))

#+Genera
(ZL:DEFPROP DEFGENERIC LISP:DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

#+Genera
(ZL:DEFPROP DEGENERIC FUNDEFINE ZWEI:KILL-DEFINITION)

(DEFMACRO DEFGENERIC
	  (FUNCTION-NAME LAMBDA-LIST &BODY OPTIONS-AND-METHODS &ENVIRONMENT ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (LAMBDA-LIST GENERIC-FUNCTION-CLASS KEYS METHOD-FORMS)
      (PARSE-DEFGENERIC FUNCTION-NAME LAMBDA-LIST OPTIONS-AND-METHODS ENVIRONMENT)
    `(PROGN
       (EVAL-WHEN (:COMPILE-TOPLEVEL)
	 (ENSURE-GENERIC-FUNCTION ',FUNCTION-NAME
				  :GENERIC-FUNCTION-CLASS ',GENERIC-FUNCTION-CLASS
				  :ENVIRONMENT ',(STATIC-ENVIRONMENT ENVIRONMENT)
				  :LAMBDA-LIST ',LAMBDA-LIST
				  ,@KEYS))
       (DEFGENERIC-INTERNAL ',FUNCTION-NAME ',LAMBDA-LIST
	 ,@(AND (NOT (EQ GENERIC-FUNCTION-CLASS 'STANDARD-GENERIC-FUNCTION))
		`(:GENERIC-FUNCTION-CLASS (FIND-CLASS ',GENERIC-FUNCTION-CLASS)))
	 ,@METHOD-FORMS
	 ,@KEYS))))

#|| ;; Removed by X3J13.
(DEFMACRO GENERIC-FUNCTION (LAMBDA-LIST &BODY OPTIONS-AND-METHODS &ENVIRONMENT ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (LAMBDA-LIST GENERIC-FUNCTION-CLASS KEYS METHOD-FORMS)
      (PARSE-DEFGENERIC NIL LAMBDA-LIST OPTIONS-AND-METHODS ENVIRONMENT)
    `(MAKE-INSTANCE ',GENERIC-FUNCTION-CLASS
		    :LAMBDA-LIST ',LAMBDA-LIST
		    ,@METHOD-FORMS
		    ,@KEYS)))
||#

(DEFUN PARSE-DEFGENERIC (FUNCTION-NAME LAMBDA-LIST OPTIONS-AND-METHODS ENVIRONMENT)
  #+Genera (DECLARE (VALUES LAMBDA-LIST GENERIC-FUNCTION-INITARGS METHOD-FORMS))
  (LET ((METHODS NIL)
	(ARGUMENT-PRECEDENCE-ORDER-P NIL)
	(DECLAREP NIL)
	(DOCUMENTATIONP NIL)
	(METHOD-COMBINATION-P NIL)
	(GENERIC-FUNCTION-CLASS-P NIL)
	(METHOD-CLASS-P NIL)
	(METHOD-CLASS-NAME 'STANDARD-METHOD)
	(METHOD-CLASS NIL)
	(ARGUMENT-PRECEDENCE-ORDER NIL)
	#+Genera(SELECTOR NIL)
	#+Genera(SELECTORP NIL)
	(DECLARES NIL)
	(DOCUMENTATION NIL)
	(METHOD-COMBINATION NIL)
	(GENERIC-FUNCTION-CLASS-NAME NIL)
	(GENERIC-FUNCTION-CLASS NIL)
	(GENERIC-FUNCTION-CLASS-INSTANCE NIL)
	(METHOD-FORMS NIL))
    (PARSING-DEFINITION (FUNCTION-NAME DEFGENERIC)
      ;; Start by finding the metaclass for this generic function
      (LET ((OPTIONS-AND-METHODS-PLACE OPTIONS-AND-METHODS))
	(LOOP
	  (WHEN (NULL OPTIONS-AND-METHODS-PLACE) (RETURN))
	  (UNLESS (CONSP OPTIONS-AND-METHODS-PLACE)
	    (PARSE-WARN
	      "The options and methods are not a list.  The tail ~s will be ignored."
	      OPTIONS-AND-METHODS-PLACE)
	    (RETURN))
	  (BLOCK OPTION-OR-METHOD
	    (LET ((ELT (POP OPTIONS-AND-METHODS-PLACE)))
	      (UNLESS (CONSP ELT)
		(PARSE-WARN
		  "The option or method ~s is not a list.  It will be ignored." ELT)
		(RETURN-FROM OPTION-OR-METHOD))
	      (LET ((REST (CDR ELT)))
		(FLET ((SPECIFIED-TWICE ()
			 (PARSE-WARN
			   "The ~s option has already been specified.  ~s will be ignored."
			   (FIRST ELT) ELT)
			 (RETURN-FROM OPTION-OR-METHOD)))
		  (CASE (FIRST ELT)
		    (:GENERIC-FUNCTION-CLASS
		      (WHEN GENERIC-FUNCTION-CLASS-P (SPECIFIED-TWICE))
		      (SETQ GENERIC-FUNCTION-CLASS-P T)
		      (COND ((OR (NULL REST)
				 (NOT (CONSP REST))
				 (CDR REST)
				 (NOT (SYMBOLP (FIRST REST))))
			     (PARSE-WARN
			       "The generic function class option ~s is not a class name. ~
                                ~s will be used."
			       ELT 'STANDARD-GENERIC-FUNCTION)
			     (SETQ GENERIC-FUNCTION-CLASS-NAME 'STANDARD-GENERIC-FUNCTION))
			    (T (SETQ GENERIC-FUNCTION-CLASS-NAME (CAR REST)))))
		    (OTHERWISE))))))))
      (UNLESS GENERIC-FUNCTION-CLASS-P
	(SETQ GENERIC-FUNCTION-CLASS-NAME 'STANDARD-GENERIC-FUNCTION))
      (WHEN *CLOS-INITIALIZED-P*
	(UNLESS (SETQ GENERIC-FUNCTION-CLASS (FIND-CLASS GENERIC-FUNCTION-CLASS-NAME NIL))
	  (PARSE-WARN "The class ~s is not defined, ~s will be used."
		      GENERIC-FUNCTION-CLASS-NAME
		      'STANDARD-GENERIC-FUNCTION)
	  (SETQ GENERIC-FUNCTION-CLASS-NAME 'STANDARD-GENERIC-FUNCTION)
	  (SETQ GENERIC-FUNCTION-CLASS (FIND-CLASS GENERIC-FUNCTION-CLASS-NAME)))
	(UNLESS (CLASS-FINALIZED-P GENERIC-FUNCTION-CLASS)
	  (FINALIZE-INHERITANCE GENERIC-FUNCTION-CLASS))
	(SETQ GENERIC-FUNCTION-CLASS-INSTANCE (CLASS-PROTOTYPE GENERIC-FUNCTION-CLASS)))

      (LET ((OPTIONS-AND-METHODS-PLACE OPTIONS-AND-METHODS))
	(LOOP
	  (WHEN (NULL OPTIONS-AND-METHODS-PLACE) (RETURN))
	  (UNLESS (CONSP OPTIONS-AND-METHODS-PLACE)
	    (PARSE-WARN
	      "The options and methods are not a list.  The tail ~s will be ignored."
	      OPTIONS-AND-METHODS-PLACE)
	    (RETURN))
	  (BLOCK OPTION-OR-METHOD
	    (LET ((ELT (POP OPTIONS-AND-METHODS-PLACE)))
	      (UNLESS (CONSP ELT)
		(PARSE-WARN
		  "The option or method ~s is not a list.  It will be ignored." ELT)
		(RETURN-FROM OPTION-OR-METHOD))
	      (LET ((REST (CDR ELT)))
		(FLET ((SPECIFIED-TWICE ()
			 (PARSE-WARN
			   "The ~s option has already been specified.  ~s will be ignored."
			   (FIRST ELT) ELT)
			 (RETURN-FROM OPTION-OR-METHOD)))
		  (CASE (FIRST ELT)
		    (:ARGUMENT-PRECEDENCE-ORDER
		      (WHEN ARGUMENT-PRECEDENCE-ORDER-P (SPECIFIED-TWICE))
		      (SETQ ARGUMENT-PRECEDENCE-ORDER-P T)
		      (CHECK-ARGUMENT-PRECEDENCE-ORDER
			#'PARSE-WARN REST LAMBDA-LIST)
		      (SETQ ARGUMENT-PRECEDENCE-ORDER REST))
		    (DECLARE
		      (WHEN DECLAREP (SPECIFIED-TWICE))
		      (SETQ DECLAREP T)
		      (SETQ DECLARES REST))
		    (:DOCUMENTATION
		      (WHEN DOCUMENTATIONP (SPECIFIED-TWICE))
		      (SETQ DOCUMENTATIONP T)
		      (SETQ DOCUMENTATION (CAR REST)))
		    #+Genera
		    ;; Deal with message passing until Old Flavors compatibility is
		    ;; no longer an issue.
		    (:SELECTOR
		      (WHEN SELECTORP (SPECIFIED-TWICE))
		      (SETQ SELECTORP T)
		      (SETQ SELECTOR (CAR REST)))
		    (:METHOD-COMBINATION
		      (WHEN METHOD-COMBINATION-P (SPECIFIED-TWICE))
		      (SETQ METHOD-COMBINATION-P T)
		      (COND ((NOT (SYMBOLP (FIRST REST)))
			     (PARSE-WARN
			       "The type of method combination, in ~s is not a symbol.  ~s ~
                                will be used."
			       ELT 'STANDARD)
			     (SETQ METHOD-COMBINATION '(STANDARD)))
			    (T
			     (SETQ METHOD-COMBINATION REST))))
		    (:GENERIC-FUNCTION-CLASS)
		    (:METHOD-CLASS
		      (WHEN METHOD-CLASS-P (SPECIFIED-TWICE))
		      (SETQ METHOD-CLASS-P T)
		      (COND ((OR (CDR REST)
				 (NOT (SYMBOLP (FIRST REST))))
			     (PARSE-WARN
			       "The generic function method class option ~s is not a ~
                                class name.  ~s will be used."
			       ELT METHOD-CLASS-NAME))
			    (T (SETQ METHOD-CLASS-NAME (FIRST REST)))))
		    (:METHOD
		      ;; Save these up in case they come before the
		      ;; method class or the generic function class.
		      (PUSH REST METHODS))
		    (OTHERWISE
		      (PARSE-WARN
			"In ~s, ~s is not one of the known options~? to ~s. ~
			 It will be ignored."
			     ELT
			     (FIRST ELT)
			     *AND-~S-FORMAT-STRING*
			     '(:ARGUMENT-PRECEDENCE-ORDER
				:DOCUMENTATION
				:GENERIC-FUNCTION-CLASS
				:METHOD
				:METHOD-CLASS
				:METHOD-COMBINATION
				DECLARE)
			     'DEFGENERIC)))))))))

      (UNLESS (GENERIC-FUNCTION-NAME-VALID-P FUNCTION-NAME)
	(LET ((NEW-NAME (GENSYM)))
	  (PARSE-WARN
	    "~s is not a valid generic function name.  ~s will be used."
	    FUNCTION-NAME NEW-NAME)
	  (SETQ FUNCTION-NAME NEW-NAME)))
      (MULTIPLE-VALUE-BIND (LAMBDA-LIST-OK PARSED-LAMBDA-LIST)
	  (CHECK-LAMBDA-LIST LAMBDA-LIST NIL NIL NIL #'PARSE-WARN)
	(UNLESS LAMBDA-LIST-OK
	  (SETQ LAMBDA-LIST PARSED-LAMBDA-LIST)))
      (WHEN (OR METHOD-CLASS-P METHODS)
	(UNLESS (SETQ METHOD-CLASS (FIND-CLASS METHOD-CLASS-NAME NIL))
	  (PARSE-WARN "The class ~s is not defined.  ~s will be used."
		      METHOD-CLASS-NAME 'STANDARD-METHOD)
	  (SETQ METHOD-CLASS-NAME 'STANDARD-METHOD)
	  (SETQ METHOD-CLASS (FIND-CLASS 'STANDARD-METHOD))))
      (WHEN METHODS
	(UNLESS (CLASS-FINALIZED-P METHOD-CLASS)
	  (FINALIZE-INHERITANCE METHOD-CLASS))
	(LET ((METHOD-INSTANCE (CLASS-PROTOTYPE METHOD-CLASS)))
	  (DOLIST (METHOD METHODS)
	    (LET ((NAME (LIST 'METHOD FUNCTION-NAME NIL)))
	      (PARSING-DEFINITION (NAME INITIAL-METHOD)
		(MULTIPLE-VALUE-BIND (METHOD-SUCCESS-P
				      METHOD-LAMBDA-LIST SPECIALIZERS QUALIFIERS FUNCTION
				      DOCUMENTATION OTHER)
		    (BLOCK PARSE-METHOD
		      (PARSE-METHOD
			NAME
			METHOD
			#'(LAMBDA (FUNCTION-NAME METHOD-LAMBDA-LIST)
			    (DECLARE (IGNORE FUNCTION-NAME))
			    (UNLESS (LAMBDA-LIST-CONGRUENT-P
				      GENERIC-FUNCTION-CLASS-INSTANCE
				      METHOD-LAMBDA-LIST
				      LAMBDA-LIST)
			      (PARSE-WARN "The :METHOD lambda-list ~a is not congruent"
					  METHOD-LAMBDA-LIST)
			      (RETURN-FROM PARSE-METHOD NIL))
			    (VALUES GENERIC-FUNCTION-CLASS-INSTANCE
				    METHOD-INSTANCE))
			ENVIRONMENT
			#'PARSE-WARN))
		  (COND ((NULL METHOD-SUCCESS-P)
			 (PARSE-WARN "The form ~s will be ignored." METHOD))
			(T
			 (PUSH
			   `(LIST :LAMBDA-LIST ',METHOD-LAMBDA-LIST
				  :SPECIALIZERS ,SPECIALIZERS
				  :QUALIFIERS ',QUALIFIERS
				  :FUNCTION #',FUNCTION
				  ,@(WHEN DOCUMENTATION `(:DOCUMENTATION ',DOCUMENTATION))
				  ,@(MAPCAR #'(LAMBDA (THING) `',THING) OTHER))
			   METHOD-FORMS)))))))))
	  
      (LET ((KEYS
	      `(,@(AND (NOT (EQ METHOD-CLASS-NAME 'STANDARD-METHOD))
		       `(:METHOD-CLASS ',METHOD-CLASS-NAME))
		:ARGUMENT-PRECEDENCE-ORDER ',(IF ARGUMENT-PRECEDENCE-ORDER-P
						 ARGUMENT-PRECEDENCE-ORDER
						 (LOOP FOR ARG IN LAMBDA-LIST
						       UNTIL (OR (EQ ARG '&OPTIONAL)
								 (EQ ARG '&REST)
								 (EQ ARG '&KEY)
								 (EQ ARG '&AUX))
						       COLLECT ARG))
		,@(AND METHOD-COMBINATION-P
		       (NOT (EQUAL METHOD-COMBINATION '(STANDARD)))
		       `(:METHOD-COMBINATION ',METHOD-COMBINATION))
		:DECLARATIONS ',DECLARES
		:DOCUMENTATION ',DOCUMENTATION
		#+Genera 'SELECTOR #+Genera ',SELECTOR)))
	(VALUES
	  LAMBDA-LIST
	  GENERIC-FUNCTION-CLASS-NAME
	  KEYS
	  `(:INITIAL-METHODS ,(AND METHOD-FORMS `(LIST ,@METHOD-FORMS))))))))

(DEFMACRO DEFMETHOD (&WHOLE WHOLE FUNCTION-NAME &REST FORM &ENVIRONMENT ENVIRONMENT)
  #+Genera
  (DECLARE (ZWEI:INDENTATION . ZWEI:INDENT-FOR-CLOS-DEFMETHOD)
	   (SYS:ARGLIST FUNCTION-NAME {METHOD-QUALIFIER}* SPECIALIZED-LAMBDA-LIST
			&BODY BODY))
  (LET ((NAME (LIST 'METHOD FUNCTION-NAME NIL)))
    (PARSING-DEFINITION (NAME DEFMETHOD)
      (UNLESS (GENERIC-FUNCTION-NAME-VALID-P FUNCTION-NAME)
	(LET ((NEW-NAME (GENSYM)))
	  (PARSE-WARN
	    "The generic function name ~s is not valid.  ~s will be used."
	    FUNCTION-NAME NEW-NAME)
	  (SETQ FUNCTION-NAME NEW-NAME)))
      (MULTIPLE-VALUE-BIND (SUCCESS-P
			    LAMBDA-LIST SPECIALIZERS-FORM METHOD-QUALIFIERS METHOD-LAMBDA
			    DOCUMENTATION OTHER-STUFF)
	  (FLET ((FINDER (FUNCTION-NAME LAMBDA-LIST)
		   #+Cloe-Runtime (DECLARE (SYS:DOWNWARD-FUNCTION))
		   (DECLARE (IGNORE LAMBDA-LIST))
		   (LET ((GENERIC-INSTANCE
			   (ENSURE-GENERIC-FUNCTION
			     FUNCTION-NAME
			     :ENVIRONMENT
			     ENVIRONMENT)))
		     (VALUES GENERIC-INSTANCE
			     (CLASS-PROTOTYPE (GENERIC-FUNCTION-METHOD-CLASS GENERIC-INSTANCE))))))
	    (DECLARE (DYNAMIC-EXTENT #'FINDER))
	    (PARSE-METHOD NAME FORM #'FINDER ENVIRONMENT #'PARSE-WARN))
	(DECLARE (IGNORE SUCCESS-P))
	`(PROGN
	   (EVAL-WHEN (:COMPILE-TOPLEVEL)
	     (ENSURE-GENERIC-FUNCTION ',FUNCTION-NAME
				      :ENVIRONMENT ',(STATIC-ENVIRONMENT ENVIRONMENT)))
	   (DEFMETHOD-INTERNAL
	     ',FUNCTION-NAME
	     ',LAMBDA-LIST
	     ,SPECIALIZERS-FORM
	     ',METHOD-QUALIFIERS
	     #',METHOD-LAMBDA
	     ,DOCUMENTATION
	     ',OTHER-STUFF))))))

(DEFSTRUCT (METHOD-GROUP (:TYPE LIST))
  PATTERNS
  ORDER
  REQUIRED
  DESCRIPTION)

#+Genera
(SCL:DEFPROP DEFINE-METHOD-COMBINATION "CLOS method combination" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-METHOD-COMBINATION (NAME &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (PARSING-DEFINITION (NAME DEFINE-METHOD-COMBINATION)
    (UNLESS (TYPEP NAME 'SYMBOL)
      (LET ((NEW-NAME (GENSYM)))
	(PARSE-WARN
	  "The method combination name, ~s, is not a symbol.  ~s will be used."
	  NAME NEW-NAME)
	(SETQ NAME NEW-NAME)))
    (WHEN (OR (NULL BODY)
	      (AND (FIRST BODY) (TYPEP (FIRST BODY) 'SYMBOL)))
      ;; Short form method combination
      (LET ((DOCUMENTATION NIL)
	    (IDENTITY NIL)
	    (IDENTITY-P NIL)
	    (OPERATOR NAME)
	    (OPERATOR-P NIL)
	    (PLACE BODY))
	(LOOP
	  (WHEN (NULL PLACE) (RETURN))
	  (WHEN (OR (ATOM PLACE)
		    (NOT (CONSP (CDR PLACE))))
	    (PARSE-WARN
	      "The short form method combination options contains the tail ~s which is not ~
               a list of alternating keywords and values.  It will be ignored."
	      PLACE)
	    (RETURN))
	  (LET ((KEYWORD (POP PLACE))
		(VALUE (POP PLACE)))
	    (CASE KEYWORD
	      (:DOCUMENTATION
		(IF DOCUMENTATION
		    (PARSE-WARN
		      "~s is specified twice.  Only the first one will be used."
		      :DOCUMENTATION)
		    (IF (STRINGP DOCUMENTATION)
			(SETQ DOCUMENTATION VALUE)
			(PARSE-WARN
			  "~s must be a string.  The supplied value, ~s, will be ignored."
			  :DOCUMENTATION VALUE))))
	      (:IDENTITY-WITH-ONE-ARGUMENT
		(COND (IDENTITY-P
		       (PARSE-WARN
			 "~s was specified twice.  Only the first will be used."
			 :IDENTITY-WITH-ONE-ARGUMENT))
		      (T
		       (SETQ IDENTITY-P T)
		       (SETQ IDENTITY VALUE))))
	      (:OPERATOR
		(COND (OPERATOR-P
		       (PARSE-WARN
			 "~s was specified twice.  Only the first will be used."
			 :OPERATOR))
		      (T
		       (SETQ OPERATOR-P T)
		       (SETQ OPERATOR VALUE))))
	      (OTHERWISE
		(PARSE-WARN
		  "The keyword ~s (with value ~s) is not one of the known options,~?~@
                   for the short form of ~s.~@
                   It will be ignored."
		  KEYWORD VALUE
		  *AND-~S-FORMAT-STRING*
		  '(:DOCUMENTATION :IDENTITY-WITH-ONE-ARGUMENT :OPERATOR)
		  'DEFINE-METHOD-COMBINATION)))))
	(RETURN-FROM DEFINE-METHOD-COMBINATION
	  `(DEFINE-METHOD-COMBINATION-INTERNAL
	     'SHORT-FORM-METHOD-COMBINATION-DEFINITION
	     :NAME ',NAME
	     :OPERATOR ',OPERATOR
	     :IDENTITY-WITH-ONE-ARGUMENT ',IDENTITY
	     :DOCUMENTATION ',DOCUMENTATION))))
    ;; Must be the long form
    ;;
    ;; Already know that a lambda-list of some sort was provided (from the test for
    ;; short-form).
    (WHEN (NULL (CDR BODY))
      (PARSE-WARN
	"The method group specifiers position has not been filled.  The method combination ~
         definition will be ignored.")
      (RETURN-FROM DEFINE-METHOD-COMBINATION NIL))
    (WHEN (ATOM (CDR BODY))
      (PARSE-WARN
	"The method combination form contains the non-list tail ~s.  The method combination ~
         definition will be ignored."
	BODY)
      (RETURN-FROM DEFINE-METHOD-COMBINATION NIL))
    (LET* ((METHODS (GENSYM))
	   (QUALIFIER-VARIABLES NIL)
	   (QUALIFIER-PATTERNS NIL)
	   (QUALIFIER-PREDICATES NIL)
	   (QUALIFIER-ORDERS NIL)
	   (QUALIFIER-REQUIREDS NIL)
	   (QUALIFIER-DESCRIPTIONS NIL)
	   (LAMBDA-LIST (POP BODY))
	   (METHOD-GROUP-SPECIFIERS (POP BODY))
	   (METHOD-GROUP-SPECIFIER-PLACE METHOD-GROUP-SPECIFIERS)
	   (ARGUMENT-TRANSLATIONS NIL)
	   (ARGUMENTS-P NIL)
	   (ARGUMENTS-LAMBDA-LIST NIL)
	   (GENERIC-FUNCTION (GENSYM))
	   (GENERIC-FUNCTION-P NIL))

      ;; Check the method group specifiers
      (LOOP
	(WHEN (NULL METHOD-GROUP-SPECIFIER-PLACE)
	  (RETURN))
	(WHEN (ATOM METHOD-GROUP-SPECIFIER-PLACE)
	  (PARSE-WARN
	    "The method group specifiers is not a list.  The tail ~s will be ignored."
	    METHOD-GROUP-SPECIFIER-PLACE)
	  (RETURN))

	(BLOCK METHOD-GROUP-SPECIFIER
	  (LET* ((ORIGINAL-SPECIFIER (POP METHOD-GROUP-SPECIFIER-PLACE))
		 (SPECIFIER-PLACE ORIGINAL-SPECIFIER)
		 (VARIABLE-NAME NIL)
		 (QUALIFIERS NIL)
		 (PREDICATE NIL)
		 (DESCRIPTION NIL)
		 (DESCRIPTION-P NIL)
		 (ORDER ':MOST-SPECIFIC-FIRST)
		 (ORDER-P NIL)
		 (REQUIRED NIL)
		 (REQUIRED-P NIL))
	    
	    (WHEN (OR (ATOM ORIGINAL-SPECIFIER)
		      (ATOM (CDR ORIGINAL-SPECIFIER)))
	      (PARSE-WARN
		"The method group specifier ~s does not consist of at least a list of a ~
                 variable and a qualifier pattern.  It will be ignored."
		ORIGINAL-SPECIFIER)
	      (RETURN-FROM METHOD-GROUP-SPECIFIER))

	    (BLOCK METHOD-GROUP-SPECIFIER-OPTIONS

	      (SETQ VARIABLE-NAME (POP SPECIFIER-PLACE))
	      (UNLESS (CHECK-VARIABLE
			"method group specifier variable"
			ORIGINAL-SPECIFIER VARIABLE-NAME #'PARSE-WARN)
		(PARSE-WARN "The method group specifier will be ignored.")
		(RETURN-FROM METHOD-GROUP-SPECIFIER))

	      (BLOCK QUALIFIER-OR-PREDICATE
		(LET ((NEXT (FIRST SPECIFIER-PLACE)))
		  (WHEN (AND NEXT (SYMBOLP NEXT))
		    (SETQ PREDICATE NEXT)
		    (POP SPECIFIER-PLACE)
		    (RETURN-FROM QUALIFIER-OR-PREDICATE)))

		;; Find the method qualifier patterns or predicate
		(LOOP
		  (LET ((NEXT (FIRST SPECIFIER-PLACE)))
		    (COND ((OR (NULL NEXT) (EQ NEXT '*))
			   (PUSH NEXT QUALIFIERS))
			  ((CONSP NEXT)
			   ;; A list method qualifier pattern
			   (LET ((LAST 
				   (DO ((PLACE NEXT (CDR PLACE)))
				       ((ATOM PLACE) PLACE)
				     (UNLESS (AND (FIRST PLACE) (ATOM (FIRST PLACE)))
				       (PARSE-WARN
					 "The element ~s of the pattern ~s is not a ~
                                          valid qualifier name."
					 (FIRST PLACE) NEXT)))))
			     (UNLESS (OR (NULL LAST) (EQ LAST '*))
			       (PARSE-WARN
				 "The method qualifier pattern ~s is a dotted list, but its ~
                                  tail is not ~s."
				 NEXT '*)))
			   (PUSH NEXT QUALIFIERS))
			  (T
			   ;; Done with the qualifiers
			   (RETURN))))
		  (POP SPECIFIER-PLACE)
		  (WHEN (NULL SPECIFIER-PLACE)
		    (RETURN))
		  (WHEN (ATOM SPECIFIER-PLACE)
		    (PARSE-WARN
		      "The method group specifier ~s contained the non-list tail ~s.  The ~
                       tail will be ignored."
		      ORIGINAL-SPECIFIER SPECIFIER-PLACE)
		    (RETURN-FROM METHOD-GROUP-SPECIFIER-OPTIONS))))

	      ;; Find the options
	      (LOOP
		(WHEN (NULL SPECIFIER-PLACE)
		  (RETURN))
		(WHEN (OR (ATOM SPECIFIER-PLACE)
			  (ATOM (CDR SPECIFIER-PLACE)))
		  (PARSE-WARN "The method group specifier options for ~s do not consist of ~
                               an alternating list of keywords and values.  The list will ~
                               be ignored starting at ~s."
			      ORIGINAL-SPECIFIER SPECIFIER-PLACE)
		  (RETURN))
		(LET ((KEYWORD (POP SPECIFIER-PLACE))
		      (VALUE (POP SPECIFIER-PLACE)))
		  (CASE KEYWORD
		    (:DESCRIPTION
		      (COND (DESCRIPTION-P
			     (PARSE-WARN
			       "~s specified twice in ~s.  Only the first will be used."
			       KEYWORD ORIGINAL-SPECIFIER))
			    (T
			     (SETQ DESCRIPTION-P T)
			     (IF (TYPEP VALUE 'STRING)
				 (SETQ DESCRIPTION VALUE)
				 (PARSE-WARN
				   "The value of ~s, ~s, in ~s is not a string.  It will ~
                                    be ignored."
				   KEYWORD VALUE ORIGINAL-SPECIFIER)))))
		    (:ORDER
		      (COND (ORDER-P
			     (PARSE-WARN
			       "~s is specified twice in ~s.  Only the first will be used."
			       KEYWORD ORIGINAL-SPECIFIER))
			    (T
			     (SETQ ORDER-P T)
			     (SETQ ORDER VALUE))))
		    (:REQUIRED
		      (COND (REQUIRED-P
			     (PARSE-WARN
			       "~s is specified twice in ~s.  Only the first will be used."
			       KEYWORD ORIGINAL-SPECIFIER))
			    (T
			     (SETQ REQUIRED-P T)
			     (SETQ REQUIRED VALUE))))
		    (OTHERWISE
		      (PARSE-WARN
			"The keyword ~s is not one of the known options,~?~@
                         for the long form of ~s.~@
                         It will be ignored."
			KEYWORD
			*AND-~S-FORMAT-STRING*
			'(:DESCRIPTION :ORDER :REQUIRED)
			'DEFINE-METHOD-COMBINATION))))))

	    (UNLESS (OR QUALIFIERS PREDICATE)
	      (PARSE-WARN
		"The method group specifier ~s had neither a predicate nor qualifier ~
                 patterns.  It will be ignored."
		ORIGINAL-SPECIFIER)
	      (RETURN-FROM METHOD-GROUP-SPECIFIER))
	    (PUSH VARIABLE-NAME QUALIFIER-VARIABLES)
	    (PUSH (NREVERSE QUALIFIERS) QUALIFIER-PATTERNS)
	    (PUSH PREDICATE QUALIFIER-PREDICATES)
	    (PUSH DESCRIPTION QUALIFIER-DESCRIPTIONS)
	    (PUSH ORDER QUALIFIER-ORDERS)
	    (PUSH REQUIRED QUALIFIER-REQUIREDS))))
      (SETQ QUALIFIER-VARIABLES (NREVERSE QUALIFIER-VARIABLES))
      (SETQ QUALIFIER-PATTERNS (NREVERSE QUALIFIER-PATTERNS))
      (SETQ QUALIFIER-ORDERS (NREVERSE QUALIFIER-ORDERS))
      (SETQ QUALIFIER-REQUIREDS (NREVERSE QUALIFIER-REQUIREDS))
      (SETQ QUALIFIER-DESCRIPTIONS (NREVERSE QUALIFIER-DESCRIPTIONS))

      ;; Now take care of any pre-body options
      (LOOP
	(WHEN (OR (ATOM BODY)
		  (ATOM (FIRST BODY)))
	  (RETURN))
	(BLOCK CHECK-OPTION
	  (LET ((FIRST (FIRST BODY)))
	    (CASE (FIRST FIRST)
	      (:ARGUMENTS
		(WHEN ARGUMENTS-P
		  (PARSE-WARN
		    "The ~s long form method combination option was supplied more than once.
                     ~s will be ignored."
		    :ARGUMENTS FIRST)
		  (RETURN-FROM CHECK-OPTION))
		(SETQ ARGUMENTS-P T)
		(MULTIPLE-VALUE-BIND (LAMBDA-LIST-OK PARSED-LAMBDA-LIST)
		    (CHECK-LAMBDA-LIST (CDR FIRST) T T T #'PARSE-WARN)
		  (DECLARE (IGNORE LAMBDA-LIST-OK))
		  ;; Replace each parameter variable with a gensym.
		  ;; ARGUMENT-TRANSLATIONS will be an ALIST of
		  ;; translations (suitable for SYMBOL-MACROLET) .
		  (MULTIPLE-VALUE-SETQ (ARGUMENTS-LAMBDA-LIST ARGUMENT-TRANSLATIONS)
		    (GENSYMIFY-LAMBDA-LIST PARSED-LAMBDA-LIST))))
	      (:GENERIC-FUNCTION
		(WHEN GENERIC-FUNCTION-P
		  (PARSE-WARN
		    "The ~s long form method combination option was supplied more than once.
                     ~s will be ignored."
		    :GENERIC-FUNCTION FIRST)
		  (RETURN-FROM CHECK-OPTION))
		(UNLESS (CONSP (CDR FIRST))
		  (PARSE-WARN
		    "The ~s long form method combination option is not a list of ~s and a ~
                     variable name.  ~s will be ignored."
		    :GENERIC-FUNCTION :GENERIC-FUNCTION FIRST)
		  (RETURN-FROM CHECK-OPTION))
		(LET ((VARIABLE-NAME (SECOND FIRST)))
		  (IF (CHECK-VARIABLE "generic function variable" FIRST VARIABLE-NAME)
		      (SETQ GENERIC-FUNCTION VARIABLE-NAME)
		      (PARSE-WARN "It will be ignored."))))
	      (OTHERWISE (RETURN)))))
	(SETQ BODY (CDR BODY)))

      (MULTIPLE-VALUE-BIND (REAL-BODY DECLARATIONS DOCUMENTATION)
	  (PARSE-TOPLEVEL-BODY BODY ENVIRONMENT LAMBDA-LIST)
	`(DEFINE-METHOD-COMBINATION-INTERNAL
	   'LONG-FORM-METHOD-COMBINATION-DEFINITION
	   :NAME ',NAME
	   :DOCUMENTATION ',DOCUMENTATION
	   'METHOD-GROUPS ',(MAPCAR #'(LAMBDA (PATTERNS PREDICATE ORDER REQUIRED
					       DESCRIPTION)
					(MAKE-METHOD-GROUP
					  :PATTERNS (OR PATTERNS PREDICATE)
					  :ORDER ORDER
					  :REQUIRED REQUIRED
					  :DESCRIPTION DESCRIPTION))
				    QUALIFIER-PATTERNS
				    QUALIFIER-PREDICATES
				    QUALIFIER-ORDERS
				    QUALIFIER-REQUIREDS
				    QUALIFIER-DESCRIPTIONS)
	   :ARGUMENTS-LAMBDA-LIST ',ARGUMENTS-LAMBDA-LIST
	   :FUNCTION
	   #'(LAMBDA (,GENERIC-FUNCTION ,METHODS ,@LAMBDA-LIST)
	       (DECLARE #+Genera-LATER (SYS:FUNCTION-NAME
					 (METHOD-COMBINATION-FUNCTION ,NAME))
			,@DECLARATIONS)
	       ,GENERIC-FUNCTION ,METHODS
	       (LET ,QUALIFIER-VARIABLES
		 (MAPC
		   #'(LAMBDA (METHOD)
		       (BLOCK MATCH-METHOD
			 (LET ((METHOD-QUALIFIERS (METHOD-QUALIFIERS METHOD)))
			   ,@(MAPCAR
			       #'(LAMBDA (VAR PATTERN PREDICATE)
				   `(WHEN ,(IF PREDICATE
					       `(,PREDICATE METHOD-QUALIFIERS)
					       `(OR ,@(MAPCAR
							#'(LAMBDA (PATTERN)
							    `(QUALIFIERS-MATCH-P
							       METHOD-QUALIFIERS
							       ',PATTERN))
							PATTERN)))
				      (PUSH METHOD ,VAR)
				      (RETURN-FROM MATCH-METHOD)))
			       QUALIFIER-VARIABLES
			       QUALIFIER-PATTERNS
			       QUALIFIER-PREDICATES)
			   (INVALID-METHOD-ERROR
			     METHOD
			     "The method ~s can not be used with method combination type ~s"
			     METHOD ',NAME))))
		   ,METHODS)
		 ,@(MAPCAR
		     #'(LAMBDA (VARIABLE ORDER)
			 `(ECASE ,ORDER
			    (:MOST-SPECIFIC-FIRST (SETQ ,VARIABLE (NREVERSE ,VARIABLE)))
			    (:MOST-SPECIFIC-LAST)))
		     QUALIFIER-VARIABLES
		     QUALIFIER-ORDERS)
		 ,@(MAPCAN
		     #'(LAMBDA (VARIABLE REQUIRED PATTERN PREDICATE)
			 (WHEN REQUIRED
			   `((UNLESS ,VARIABLE
			       ,(IF PREDICATE
				    `(ERROR "The predicate ~s did not match any methods"
					    ',PREDICATE)
				    `(NO-METHOD-QUALIFIERS-MATCH-ERROR ',PATTERN))))))
		     QUALIFIER-VARIABLES
		     QUALIFIER-REQUIREDS
		     QUALIFIER-PATTERNS
		     QUALIFIER-PREDICATES)
		 ,(WRAP-BODY-IN-VARIABLE-TRANSLATIONS REAL-BODY ARGUMENT-TRANSLATIONS)
		 )))))))

(DEFMACRO STANDARD-CLASS-SLOT-LOCATION (OBJECT SLOT-NAME)
  `(LET ((INFORMATION (%INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
     (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (SPACE 0)))
     (BLOCK LOOKUP-SLOT
       #+Genera
       (LET ((N-SLOTS (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION)))
	 (WHEN (PLUSP N-SLOTS)
	   (LET ((PTR (SYS:%BLOCK-SEARCH-EQ
			,SLOT-NAME
			(LOCF (AREF (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION) 0))
			N-SLOTS)))
	     (WHEN PTR
	       (RETURN-FROM LOOKUP-SLOT
		 (LOCATION-CONTENTS (SYS:%POINTER-PLUS PTR N-SLOTS)))))))
       #+Minima
       (LET ((N-SLOTS (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION)))
	 (WHEN (PLUSP N-SLOTS)
	   (LET ((PTR (MINIMA-INTERNALS::%BLOCK-SEARCH-EQ
			,SLOT-NAME
			(LOCF (AREF (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION) 0))
			N-SLOTS)))
	     (WHEN PTR
	       (RETURN-FROM LOOKUP-SLOT
		 (LOCATION-CONTENTS (IVORY:%POINTER-PLUS PTR N-SLOTS)))))))
       #-(OR Genera Minima)
       (LET ((N-SLOTS (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION)))
	 (DECLARE (FIXNUM N-SLOTS))
	 (WHEN (> N-SLOTS 0)
	   (LET* ((TABLE (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION))
		  (N (POSITION (THE SYMBOL ,SLOT-NAME) TABLE :END N-SLOTS)))
	     ;;Yes, virginia, CLOE will really zorch through the table given enough
	     ;; rope in the optimization settings.  Your mileage may vary.
	     (DECLARE (SIMPLE-VECTOR TABLE))
	     (WHEN N
	       (RETURN-FROM LOOKUP-SLOT
		 (SVREF (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION)
			(THE FIXNUM (+ (THE FIXNUM N) N-SLOTS))))))))
       (LOOP WHILE (%CLASS-INSTANCE-INFORMATION-OBSOLETE-P INFORMATION) DO
	 (UPDATE-STANDARD-CLASS-INSTANCE ,OBJECT)
	 (SETQ INFORMATION (%INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
       #-(OR Genera CLOE-Runtime)
       (LET ((SLOT (FIND ,SLOT-NAME (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS INFORMATION)
			 :KEY #'SLOT-DEFINITION-NAME)))
	 (AND SLOT (SLOT-DEFINITION-LOCATION SLOT)))
       #+(OR Genera CLOE-Runtime)
       ;;CLOE (and theoretical non-genera probably) gets more bang when it calls generic functions
       ;; directly where the compiler can tell that that's what they are.
       ;; [Later...] A single isolated test of this code in Genera gets a 1/3 speedup on the 3640,
       ;; so I believe this loop should be propagated to the lispm too.
       (LOOP FOR SLOT IN (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS INFORMATION)
	     WHEN (EQ ,SLOT-NAME (SLOT-DEFINITION-NAME SLOT))
	       DO (RETURN (SLOT-DEFINITION-LOCATION SLOT)))
       )))

(DEFMACRO FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION (OBJECT SLOT-NAME)
  `(LET ((INFORMATION (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
     (LOOP WHILE (%CLASS-INSTANCE-INFORMATION-OBSOLETE-P INFORMATION) DO
       (UPDATE-FUNCALLABLE-STANDARD-CLASS-INSTANCE ,OBJECT)
       (SETQ INFORMATION (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
     #-(OR Genera CLOE-Runtime)
     (LET ((SLOT (FIND ,SLOT-NAME (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS INFORMATION)
		       :KEY #'SLOT-DEFINITION-NAME)))
       (AND SLOT (SLOT-DEFINITION-LOCATION SLOT)))
     #+(OR Genera CLOE-Runtime)
     ;;CLOE (and theoretical non-genera probably) gets more bang when it calls generic functions
     ;; directly where the compiler can tell that that's what they are.
     (LOOP FOR SLOT IN (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS INFORMATION)
	   WHEN (EQ ,SLOT-NAME (SLOT-DEFINITION-NAME SLOT))
	     DO (RETURN (SLOT-DEFINITION-LOCATION SLOT)))
     ))

;;; These macros implement our paradigm for how we store slot values.
;;; This same paradigm may be used across different metaclasses: that is why the
;;; accessor is passed in to the macro.  For ordinary instances, the accessor
;;; is %INSTANCE-REF.  For funcallable-instances, it is %funcallable-instance-ref.
(DEFMACRO READ-SLOT (CLASS OBJECT SLOT-NAME ACCESSOR LOCATOR)
  (UNLESS (AND (SYMBOLP OBJECT) (SYMBOLP SLOT-NAME))
    (WARN "READ-SLOT is a macro that should be given arguments that are variables."))
  `(LET ((.LOCATION. (,LOCATOR ,OBJECT ,SLOT-NAME)))
     (COND ((TYPEP .LOCATION. 'FIXNUM)
	    (,ACCESSOR ,OBJECT .LOCATION.))
	   #+(OR Genera Minima)
	   ((TYPEP .LOCATION. 'LOCATIVE)
	    (LOCATION-CONTENTS .LOCATION.))
	   #-(OR Genera Minima)
	   ((CONSP .LOCATION.)
	    (CAR .LOCATION.))
	   ((NULL .LOCATION.)
	    (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'SLOT-VALUE))
	   (T (ERROR "Don't know what to do with this type of location: ~S." .LOCATION.)))))

(DEFMACRO WRITE-SLOT (NEW-VALUE CLASS OBJECT SLOT-NAME ACCESSOR LOCATOR)
  (UNLESS (AND (SYMBOLP OBJECT) (SYMBOLP SLOT-NAME) (SYMBOLP NEW-VALUE))
    (WARN "WRITE-SLOT is a macro that should be given arguments that are variables."))
  `(LET ((.LOCATION. (,LOCATOR ,OBJECT ,SLOT-NAME)))
     (COND ((TYPEP .LOCATION. 'FIXNUM)
	    (SETF (,ACCESSOR ,OBJECT .LOCATION.) ,NEW-VALUE))
	   #+(OR Genera Minima)
	   ((TYPEP .LOCATION. 'LOCATIVE)
	    (SETF (LOCATION-CONTENTS .LOCATION.) ,NEW-VALUE))
	   #-(OR Genera Minima)
	   ((CONSP .LOCATION.)
	    (SETF (CAR .LOCATION.) ,NEW-VALUE))
	   ((NULL .LOCATION.)
	    (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'SETF ,NEW-VALUE))
	   (T (ERROR "Don't know what to do with this type of location: ~s." .LOCATION.)))))

#+(OR Genera Minima)
(DEFMACRO LOCATE-SLOT (CLASS OBJECT SLOT-NAME ACCESSOR LOCATOR)
  (UNLESS (AND (SYMBOLP OBJECT) (SYMBOLP SLOT-NAME))
    (WARN "LOCATE-SLOT is a macro that should be given arguments that are variables."))
  `(LET ((.LOCATION. (,LOCATOR ,OBJECT ,SLOT-NAME)))
     (COND ((TYPEP .LOCATION. 'FIXNUM)
	    (LOCF (,ACCESSOR ,OBJECT .LOCATION.)))
	   ((TYPEP .LOCATION. 'LOCATIVE)
	    .LOCATION.)
	   ((NULL .LOCATION.)
	    (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'LOCF))
	   (T
	    (ERROR "Don't know what to do with this type of location: ~s." .LOCATION.)))))

(DEFMACRO BOUNDP-SLOT (CLASS OBJECT SLOT-NAME ACCESSOR LOCATOR)
  (UNLESS (AND (SYMBOLP OBJECT) (SYMBOLP SLOT-NAME))
    (WARN "BOUNDP-SLOT is a macro that should be given arguments that are variables."))
  `(LET ((.LOCATION. (,LOCATOR ,OBJECT ,SLOT-NAME)))
     (COND ((NULL .LOCATION.) (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'SLOT-BOUNDP))
	   (T #+(OR Genera Minima)
	      (LOCATION-BOUNDP
		(COND ((TYPEP .LOCATION. 'FIXNUM)
		       (LOCF (,ACCESSOR ,OBJECT .LOCATION.)))
		      ((TYPEP .LOCATION. 'LOCATIVE)
		       .LOCATION.)
		      (T
		       (ERROR "Don't know what to do with this type of location: ~s."
			      .LOCATION.))))
	      #-(OR Genera Minima)
	      (COND ((TYPEP .LOCATION. 'FIXNUM)
		     ,(LET ((TESTER (GET ACCESSOR 'BOUNDP-PREDICATE)))
			(IF TESTER
			    `(,TESTER ,OBJECT .LOCATION.)
			    `(NOT (EQ (,ACCESSOR ,OBJECT .LOCATION.) *UNBOUND-INSTANCE-SLOT*)))))
		    ((CONSP .LOCATION.)
		     (NOT (EQ (CAR .LOCATION.) *UNBOUND-INSTANCE-SLOT*)))
		    (T (ERROR "Don't know what to do with this type of location: ~s."
			      .LOCATION.)))))))

(DEFMACRO MAKUNBOUND-SLOT (CLASS OBJECT SLOT-NAME ACCESSOR LOCATOR)
  (UNLESS (AND (SYMBOLP OBJECT) (SYMBOLP SLOT-NAME))
    (WARN "MAKUNBOUND-SLOT is a macro that should be given arguments that are variables."))
  `(LET ((.LOCATION. (,LOCATOR ,OBJECT ,SLOT-NAME)))
     #+Genera
     (COND ((TYPEP .LOCATION. 'FIXNUM)
	    (LOCATION-MAKUNBOUND (LOCF (,ACCESSOR ,OBJECT .LOCATION.)) ,SLOT-NAME))
	   ((TYPEP .LOCATION. 'LOCATIVE)
	    (LOCATION-MAKUNBOUND .LOCATION. ,SLOT-NAME))
	   ((NULL .LOCATION.)
	    (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'SLOT-MAKUNBOUND))
	   (T
	    (ERROR "Don't know what to do with this type of location: ~s." .LOCATION.)))
     #+Minima
     (COND ((TYPEP .LOCATION. 'FIXNUM)
	    (LOCATION-MAKUNBOUND (LOCF (,ACCESSOR ,OBJECT .LOCATION.)) ,SLOT-NAME))
	   ((TYPEP .LOCATION. 'LOCATIVE)
	    (LOCATION-MAKUNBOUND .LOCATION. ,SLOT-NAME))
	   ((NULL .LOCATION.)
	    (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'SLOT-MAKUNBOUND))
	   (T
	    (ERROR "Don't know what to do with this type of location: ~s." .LOCATION.)))
     #-(OR Genera Minima)
     (COND ((TYPEP .LOCATION. 'FIXNUM)
	    (SETF (,ACCESSOR ,OBJECT .LOCATION.) *UNBOUND-INSTANCE-SLOT*))
	   ((CONSP .LOCATION.)
	    (SETF (CAR .LOCATION.) *UNBOUND-INSTANCE-SLOT*))
	   ((NULL .LOCATION.) (SLOT-MISSING ,CLASS ,OBJECT ,SLOT-NAME 'SLOT-MAKUNBOUND))
	   (T (ERROR "Don't know what to do with this type of location: ~s." .LOCATION.)))))

(DEFCONSTANT %%STANDARD-CLASS-FINALIZED-P (BYTE 1 0))
(DEFCONSTANT %%STANDARD-CLASS-TYPE-IS-CLASS (BYTE 1 1))
(DEFCONSTANT %%STANDARD-CLASS-INITIALIZED-P (BYTE 1 2))
(DEFCONSTANT %%STANDARD-CLASS-MAKE-INSTANCE-ALLOW-OTHER-KEYS-P (BYTE 1 3))
;Bits 4, 5, 6, 7 are no longer used
(DEFCONSTANT %%GENERIC-FUNCTION-EXPLICITLY-DEFINED-P (BYTE 1 24))
(DEFCONSTANT %%GENERIC-FUNCTION-INITIALIZED-P (BYTE 1 25))

(DEFVAR *EQL-SPECIALIZER-METHODS* NIL)

(DEFVAR *ALLOCATE-INSTANCE*)
(DEFVAR *MAKE-INSTANCE*)
(DEFVAR *SHARED-INITIALIZE*)
(DEFVAR *INITIALIZE-INSTANCE*)
(DEFVAR *REINITIALIZE-INSTANCE*)
(DEFVAR *SLOT-VALUE-USING-CLASS*)
(DEFVAR *UPDATE-INSTANCE-FOR-REDEFINED-CLASS*)
(DEFVAR *UPDATE-INSTANCE-FOR-DIFFERENT-CLASS*)
(DEFVAR *NO-APPLICABLE-METHOD*)

(DEFMACRO WITH-ACCESSORS (SLOT-ENTRIES INSTANCE-FORM &BODY BODY)
  (LET ((TEMP (GENSYM)))
    `(LET ((,TEMP ,INSTANCE-FORM))
       #+(or Genera CLOE-Runtime) (DECLARE (COMPILER:VARIABLE-INLINABLE ,TEMP))
       ,TEMP
       (SYMBOL-MACROLET ,(MAPCAR #'(LAMBDA (SLOT-ENTRY)
				     (COND ((AND (TYPEP SLOT-ENTRY 'CONS)
						 (TYPEP (CAR SLOT-ENTRY) 'SYMBOL)
						 (TYPEP (CDR SLOT-ENTRY) 'CONS)
						 (TYPEP (CADR SLOT-ENTRY) 'SYMBOL)
						 (NULL (CDDR SLOT-ENTRY)))
					    `(,(FIRST SLOT-ENTRY)
					      (,(SECOND SLOT-ENTRY) ,TEMP)))
					   (T (ERROR "Invalid slot entry ~s" SLOT-ENTRY))))
				 SLOT-ENTRIES)
	 ,@BODY))))

(DEFMACRO WITH-SLOTS (SLOT-ENTRIES INSTANCE-FORM &BODY BODY)
  (LET ((TEMP (GENSYM)))
    `(LET ((,TEMP ,INSTANCE-FORM))
       #+(or Genera CLOE-Runtime) (DECLARE (COMPILER:VARIABLE-INLINABLE ,TEMP))
       ,TEMP
       (SYMBOL-MACROLET ,(MAPCAR #'(LAMBDA (SLOT-ENTRY)
				     (MULTIPLE-VALUE-BIND (VAR SLOT-NAME)
					 (COND ((TYPEP SLOT-ENTRY 'SYMBOL)
						(VALUES SLOT-ENTRY SLOT-ENTRY))
					       ((AND (TYPEP SLOT-ENTRY 'CONS)
						     (TYPEP (CAR SLOT-ENTRY) 'SYMBOL)
						     (TYPEP (CDR SLOT-ENTRY) 'CONS)
						     (TYPEP (CADR SLOT-ENTRY) 'SYMBOL)
						     (NULL (CDDR SLOT-ENTRY)))
						(VALUES (FIRST SLOT-ENTRY)
							(SECOND SLOT-ENTRY)))
					       (T (ERROR "Invalid slot entry ~s" SLOT-ENTRY)))
				       `(,VAR (SLOT-VALUE ,TEMP ',SLOT-NAME))))
				 SLOT-ENTRIES)
	 ,@BODY))))
