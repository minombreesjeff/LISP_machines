;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Package: CLOS-INTERNALS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Some utility functions:

;;; Given the kind of "matching" keyword arguments for the show commands,
;;; Create a predicate suitable for use as the matching function.
;;; If the value of KEYWORD-ARG is :ALL then the predicate #'true is used
;;; so that everything will match.
;;; If the value of KEYWORD-ARG is :NONE then the predicate #'false is used
;;; so that nothing will match.
;;; If the value of KEYWORD-ARG is a string, then a predicate is constructed which
;;; will succeed if the string is a substring of the value returned when NAME-KEY
;;; is applied to the thing.
;;; Otherwise KEYWORD-ARG should be a predicate to use.
(defmacro D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")get-matcher-function0 (keyword-arg name-key)
  `(let ((keyword-arg ,keyword-arg))
     (cond ((eq keyword-arg :all) #'scl:true)
	   ((eq keyword-arg :none) #'scl:false)
	   ((stringp keyword-arg)
	    #'(lambda (thing)
		(zl:string-search keyword-arg
				  (funcall ,name-key thing))))
	   (t keyword-arg))))

;;; Returns two values.
;;; The first value is true if the class satisfies the predicate.
;;; The second is true if any of the subclasses (not necessarily direct) of class
;;; satisfy the predicate.
(defun 1subclass-matches-p0 (class predicate)
  (declare (values class-matches branch-matches))
  (let ((class-matches (funcall predicate class)))
    (labels ((subclass-matches-helper (class)
	       (dolist (c (class-direct-subclasses class) nil)
		 (if (funcall predicate c)
		     (return-from subclass-matches-p (values class-matches t))
		     (subclass-matches-helper c)))))
      (subclass-matches-helper class)
      (values class-matches nil))))

(defmacro 1with-distinction0 ((distinguished?) &body body)
  (if (constantp distinguished?)
      (case distinguished?
	(:interesting `(progn ,@body))
	(:boring `(progn (write-char #\[)
			 (multiple-value-prog1
			   (progn ,@body)
			   (write-char #\]))))
	(t (error "Unknown option for WITH-DISTINCTION: ~s" distinguished?)))
      `(case ,distinguished?
	 (:interesting (progn ,@body))
	 (:boring (progn (write-char #\[)
			 (multiple-value-prog1
			   (progn ,@body)
			   (write-char #\])))))))

(defsubst1 method-generic-function-name0 (method)
  (generic-function-name (method-generic-function method)))

(defun 1grok-generic-function-name0 (generic-function)
  (let ((name (generic-function-name generic-function)))
    (cond ((symbolp name) (values name ""))
	  ((listp name)
	   (values (second name) (first name)))
	  (t ""))))

(defun 1generic-function-sort-name-predicate 0(gf1 gf2)
  (let ((name1 (grok-generic-function-name gf1))
	(name2 (grok-generic-function-name gf2)))
    (if (string-equal name1 name2)
	(let ((name1 (generic-function-name gf1))
	      (name2 (generic-function-name gf2)))
	  (cond ((symbolp name1) t)
		((symbolp name2) nil)
		(t (string-lessp (car name1) (car name2)))))
	(string-lessp name1 name2))))

(defun 1primary-method-p0 (method)
  (let ((qualifiers (method-qualifiers method))
	(method-combination
	  (generic-function-method-combination  (method-generic-function method))))
    (or (null qualifiers)
	(and (null (cdr qualifiers))				;only one qualifier
	     (eq (car qualifiers)
		 (method-combination-definition-name method-combination))
	     (lisp:typep (method-combination-type method-combination)
			 'long-form-method-combination-definition)))))

(defun1 interesting-specializer-positions0 (generic-function)
  (let* ((number-of-specializers (length (generic-function-argument-precedence-order
					   generic-function)))
	 (interest-map (make-list number-of-specializers :initial-element nil))
	 (class-named-t (find-class 't)))
    (dolist (method (generic-function-methods generic-function))
      (do* ((imap interest-map (cdr imap))
	    (specs (method-specializers method) (cdr specs))
	    (specializer (car specs) (car specs)))
	   ((null specs))
	(unless (eq specializer class-named-t)
	  (setf (car imap) t))))
    interest-map))

(defun 1class-direct-init-keywords 0(class)
  (let ((initialization-keywords nil)
	(allow-other-keys-p nil))
    (flet ((check-method (gf &rest specializers)
	     (dolist (method (generic-function-methods gf))
	       (when (equivalent-specializer-lists-p (method-specializers method) specializers)
		 (multiple-value-bind (keywords allow)
		     (function-keywords method)
		   (when allow
		     (setf allow-other-keys-p t))
		   (dolist (keyword keywords)
		     (pushnew keyword initialization-keywords)))))))
      (let ((metaclass `(eql ,class)))
	(check-method *make-instance* metaclass)
	(check-method *allocate-instance* metaclass))
      (check-method *initialize-instance* class)
      (check-method *shared-initialize* class t))      
    (dolist (slot (class-direct-slots class))
      (dolist (initarg (slot-definition-initargs slot))
	(pushnew initarg initialization-keywords)))
    (values initialization-keywords allow-other-keys-p)))

;;; Not all classes have names which are coercible to strings.  This
;;; generic function provides a hook for non-standard classes which
;;; allow non-symbol names, so that they can produce something suitable
;;; for the name matching predicates for the commands below.
(defgeneric 1class-name-string-for-matchp0 (class))

(defmethod 1class-name-string-for-matchp0 ((class standard-class))
  (string (class-name class)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; description functions:

;;; Describe a CLOS slot.
;;; SLOT is a slot-definition object.
;;; EMBOLDEN-NAME is a flag indicating that the name of the slot should be printed
;;; in bold face type.
;;; VERBOSE is a flag indicating that an extensive description, including type, allocation,
;;; readers, writers and initializers.
(defun 1document-slot0 (slot &optional embolden-name verbose)
  (let* ((slot-name (slot-definition-name slot)))
    (fresh-line)
    (if embolden-name
	(with-distinction (:interesting) (format t "~s " slot-name))
	(with-distinction (:boring) (format t "~s " slot-name)))
    (when verbose 
      (format t "~((~a allocation)~)"
	      (slot-definition-allocation slot))
      (scl:indenting-output (t 4)
	(let ((type (slot-definition-type slot)))
	  (unless (eq type t)
	    (format t "   type: ~s" type)))
	(let ((initform (slot-definition-initform slot)))
	  (when initform
	    (format t "~&initform: ")
	    (scl:abbreviating-output (t :height 1)
	      (prin1 initform))))
	(let ((format-miracle "~*~:[~;~&~2:*~a~{ ~s~}~]"))
	  (format t format-miracle "initargs:"
		  (slot-definition-initargs slot))
	  (format t format-miracle "readers: "
		  (slot-definition-readers slot))
	  (format t format-miracle "writers: "
		  (slot-definition-writers slot))
	  (format t format-miracle "locators: "
		  (slot-definition-locators slot)))))
    slot-name))

(defun1 grok-specializer-name0 (specializer)
  (if (listp specializer)
      specializer
      (class-name-for-type-of specializer)))

(defun 1method-argument-specializer-type-alist0 (method &key abbreviate (only-these :all))
  (do ((specializers (method-specializers method)
		     (cdr specializers))
       (ll (generic-function-lambda-list
	     (method-generic-function method))
	   (cdr ll))
       (alist nil))
      ((null specializers)
       alist)
    (let ((arg (car ll))
	  (specializer (car specializers)))
      (if (member specializer abbreviate :test #'equal)
	  (push (list arg '!) alist)
	  (unless (and (not (eq only-these :all))
		       (not (member specializer only-these :test #'equal)))
	    (push (list arg
			(grok-specializer-name specializer))
		  alist))))))

;;; Decsribe a method.  Prints the generic function name, the method qualifiers in {}
;;; brackets and the types of the specializers.  Any of the specializers which match
;;; CLASS-FOR-ABBREVIATION are printed as an ! exclamation point rather than having
;;; their names typed out.
(defun 1document-method0 (method &key
			specializers-for-abbreviation
			only-these-types
			brief
			(show-generic-function-name t))
  (fresh-line)
  (dw:with-output-as-presentation (:object method
				   :type (class-name (class-of method)))
    (dw:with-output-as-presentation (:object (function-spec-object method)
				     :type 'sys:function-spec)
      (when show-generic-function-name
	(scl:present (generic-function-name (method-generic-function method))
		     'generic-function-name)
	(write-char #\space))
      
      (lt:print-lambda-list
	(generic-function-lambda-list
	  (method-generic-function method))
;	(method-lambda-list method)   ;what if required arg names don't match those of generic
	*standard-output*
	:brief brief
	:types (method-argument-specializer-type-alist
		 method
		 :abbreviate specializers-for-abbreviation
		 :only-these only-these-types))
      
      (let ((qualifiers (method-qualifiers method)))
	;;; check for primary method of the method combination type
	(format t "~{ ~s~}" qualifiers))
      )))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; class and superclasses:

(defun 1document-class0 (class &key
		       (match-init-keywords #'scl:false)
		       (match-default-initargs #'scl:false)
		       (match-slots #'scl:false)
		       (match-methods #'scl:false)
		       (slot-description :terse)
		       ignore-slots
		       ignore-default-initargs
		       )
  (declare (values have-detailed found-default-initargs found-slots))
  (let ((have-detailed nil)
	(found-slots
	  (scl:ignore-errors
	    (sort (remove-if-not match-slots
				 (set-difference (class-direct-slots class)
						 ignore-slots
						 :key #'slot-definition-name))
		  #'string-lessp
		  :key #'slot-definition-name)))
	(found-initargs
	  (scl:ignore-errors
	    (multiple-value-bind (initargs allow-other-keys-p)
		(class-direct-init-keywords class)
	      (nconc (sort (delete-if-not match-init-keywords (copy-list initargs))
			   #'string-lessp)
		     (and allow-other-keys-p '(&allow-other-keys))))))
	(found-default-initargs
	  (scl:ignore-errors
	    (sort (remove-if-not match-default-initargs
				 (set-difference
				   (class-direct-default-initargs class)
				   ignore-default-initargs
				   :key #'car))
		  #'string-lessp
		  :key #'car))))
    
    (progn
      (when found-initargs
	(format t "~&init keywords: ")
	(scl:format-textual-list found-initargs #'prin1)
	(setq have-detailed t))
      (when found-default-initargs
	(format t "~&default initargs:")
	(scl:indenting-output (t 2)
	  (dolist (initarg found-default-initargs)
	    (format t "~&~s ~s"
		    (first initarg) (second initarg))))
	(setq have-detailed t)))

    (progn
      (when found-slots
	(format t "~&slots:")
	(scl:indenting-output (t 2)
	  (dolist (slot found-slots)
	    (document-slot slot t (if (eq slot-description :verbose)
				      t nil))))
	(setq have-detailed t)))
    
    (unless (eq match-methods #'scl:false)
      (let ((methods (remove-if-not match-methods
				    (specializer-direct-methods class))))
	(when methods
	  (format t "~&methods:")
	  (scl:indenting-output (t 2)
	    (dolist (method methods)
	      (document-method method 
			       :specializers-for-abbreviation (list class)
			       :only-these-types nil)))
	  (setq have-detailed t))))

    (values have-detailed found-default-initargs found-slots)
    ))

(defun 1document-class-and-superclasses
0       (class &key
	(match-superclass #'scl:true)
	(match-init-keywords #'scl:false)
	(match-default-initargs #'scl:false)
	(match-slots #'scl:false)
	(match-methods #'scl:false)
	(slot-description :terse)
	(exclude-classes nil)
	show-duplicate-classes
	)
  "Describe a class and the superclasses it inherits from.
  CLASS is a CLOS class.
  The :MATCH- keyword arguments are predicates which are applied to their respective
  whatevers to determine if they should be described."
  (let* ((precedence-list (class-precedence-list class))
	 (found-slots nil)					;slots which have been detailed
	 (found-default-initargs nil)				;default initargs which have been detailed
	 (dont-describe-these-classes (mapcar #'find-class exclude-classes))
	 ;; don't bother with detailed descriptions of the above classes.
	 (last-class-printed (make-array (length precedence-list)))
	 ;; this vector remembers the last class printed at each indentation level
	 ;; it needs to be as long as the depth of the superclass tree
	 (duplicate-queue nil)
	 ;; ((class level) (class level) ...) queue of duplicates waiting to be printed
	 (indentation-per-level (* 2 (or (scl:send-if-handles *standard-output* :char-width)
					 1)))
	 )
    (macrolet ((1place-of-precedence0 (class)
		 ;; Determining if the current position in the tree is the place
		 ;; from which the class gets included.
		 `(let ((this-is-the-place (eq ,class (car precedence-list))))
		    (when this-is-the-place (pop precedence-list))
		    this-is-the-place)))
      (labels ((1superclass-matches-p0 (class)
		 ;; Returns T if any of the superclasses (not necessarily direct) of class
		 ;; satisfy the MATCH-SUPERCLASSES predicate.
		 (dolist (c (class-direct-superclasses class) nil)
		   (if (funcall match-superclass c)
		       (return-from superclass-matches-p t)
		       (when (superclass-matches-p c)
			 (return-from superclass-matches-p t)))))
	       (1walk-superclasses0 (class level)
		 ;; Travel the class hierarchy and describe classes when and as appropriate.
		 (cond ((place-of-precedence class)
			(when (or (funcall match-superclass class)
				  (superclass-matches-p class))
			  (dequeue-duplicate-classes)
			  (scl:indenting-output (t (* level indentation-per-level))
			    (fresh-line)
			    (with-distinction (:interesting)
					      (scl:present class 'class))
			    (unless (member class dont-describe-these-classes)
			      (show-class-description-detailed class))
			    (setf (aref last-class-printed level) class))
			  (dolist (c (class-direct-superclasses class))
			    (walk-superclasses c (1+ level)))))
		       ((and show-duplicate-classes
			     (not (eq class *t-class*))
			     (not (eq class (find-class 'standard-object)))
			     (not (eq class (find-class 'structure-object)))
			     (not (eq class (find-class 'flavor:vanilla nil))))
			(when (or (funcall match-superclass class)
				  (superclass-matches-p class))
			  (enqueue-duplicate-class class level)))))
	       (1walk-superclasses-again0 (class level &rest trail)
		 (cond ((not (eq class (car precedence-list)))
			;; We didn't find the starting class yet, walk up the tree
			(dolist (c (class-direct-superclasses class))
			  (apply #'walk-superclasses-again c (1+ level) class trail)))
		       ((or (funcall match-superclass class)
			    (superclass-matches-p class))
			;; We found the next class to do, first show how we got here
			(loop for level from 0 and class in (reverse trail)
			      with equal = t do
			  (unless (eq class (aref last-class-printed level))
			    (setq equal nil))
			  (unless equal
			    (show-duplicate-class class level)))
			(walk-superclasses class level))
		       (t
			;; Skip this class
			(pop precedence-list))))
	       (1enqueue-duplicate-class0 (class level)
		 (push (list class level) duplicate-queue))
	       (1dequeue-duplicate-classes0 ()
		 (loop for (class level) in (nreverse duplicate-queue)
		       do (show-duplicate-class class level))
		 (setq duplicate-queue nil))
	       (1show-duplicate-class0 (class level)
		 (scl:indenting-output (t (* level indentation-per-level))
		   (fresh-line)
		   (with-distinction (:boring)
		     (scl:present class 'class))
		   (format t " ~c"
			   (if (member class precedence-list) #\downarrow #\uparrow))
		   (setf (aref last-class-printed level) class)))
	       (1show-class-description-detailed0 (class)
		 ;; Output a detailed description of CLASS.
		 ;; This will include descriptions of default initargs and slots if requested.
		 (scl:indenting-output (t 4)
		   (multiple-value-bind (nil default-initargs slots)
		       (document-class class
				       :match-init-keywords match-init-keywords
				       :match-default-initargs match-default-initargs
				       :match-slots match-slots
				       :match-methods match-methods
				       :ignore-slots found-slots
				       :ignore-default-initargs found-default-initargs
				       :slot-description slot-description)
		     (setq found-slots (append slots found-slots)
			   found-default-initargs (append default-initargs
							  found-default-initargs))
		     )))
	       )
	(walk-superclasses class 0)
	(loop while (some match-superclass precedence-list) do
	  (setq duplicate-queue nil)		;suppress trailing duplicates
	  (walk-superclasses-again class 0))
	))))

(defun 1list-class-and-superclasses0 (class)
  ;;; should the list be sorted alphabeticly?
  (let ((classes (class-precedence-list class)))
    (scl:format-item-list classes
			  :presentation-type 'class
			  :equalize-column-widths t)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; document class subclasses:

(defun 1document-class-and-subclasses0 (class &key
				      (depth-limit nil)
				      (match-subclasses #'scl:true)
				      (match-init-keywords #'scl:false)
				      (match-default-initargs #'scl:false)
				      (match-slots #'scl:false)
				      (match-methods #'scl:false)
				      (slot-description :terse)
				      show-duplicate-classes
				      )
  (let ((the-class class)
	(classes-already-detailed nil))
    (macrolet ((1class-already-detailed-p0 (class)
		 `(member ,class classes-already-detailed))
	       (1show-class-name0 (class distinction)
		 `(progn (fresh-line)
			 (with-distinction (,distinction)
			   (scl:present class 'class)))))
      (labels ((1check-ancestry0 (class)
		 (not (class-already-detailed-p class)))
	       (1walk-subclasses0 (class depth)
		 (let ((have-detailed nil))
		   ;; HAVE-DETAILED is a flag used to indicate where to print the
		   ;; elipsis (...) when abbreviating for depth limit.
		   (if (check-ancestry class)
		       (multiple-value-bind (class-matches branch-matches)
			   (subclass-matches-p class match-subclasses)
			 (if class-matches
			     (setq have-detailed (show-class-detailed class))
			     (when branch-matches
			       (show-class-name class :interesting)))
			 (when branch-matches
			   (let ((subclasses (class-direct-subclasses class)))
			     (if (and subclasses depth-limit (>= depth depth-limit))
				 (if have-detailed (format t "~&...") (format t " ..."))
				 (scl:indenting-output (t 2)
				   (dolist (c subclasses)
				     (walk-subclasses c (1+ depth))))))) )
		       (when show-duplicate-classes
			 (show-class-brief class)))))
	       (1show-class-detailed0 (class)
		 (push class classes-already-detailed)
		 (show-class-name class :interesting)
		 (scl:indenting-output (t 4)
		   (document-class class
				   :match-init-keywords match-init-keywords
				   :match-default-initargs match-default-initargs
				   :match-slots match-slots
				   :match-methods match-methods
				   :slot-description slot-description)))
	       (1show-class-brief0 (class)
		 (show-class-name class :boring)
		 (format t " ~c"
			 (if (class-already-detailed-p class)
			     #\uparrow #\downarrow)))
	       )
	(walk-subclasses the-class 0)
	))))

;; Handle things of the form (2 0 (NIL 0) (:FIX :BOLD :NORMAL) "CPTFONTCB")(clim:presentation-type 1integer2)
0(defun 1class-name-string-lessp0 (cn1 cn2)
  (cond ((and (consp cn1) (consp cn2))
	 (if (string-equal (first cn1) (first cn2))
	     (string-lessp (second cn1) (second cn2))
	     (string-lessp (first cn1) (first cn2))))
	((consp cn1)
	 (string-lessp (first cn1) cn2))
	((consp cn2)
	 (string-lessp cn1 (first cn2)))
	(t
	 (string-lessp cn1 cn2))))

(defun 1list-class-and-subclasses0 (class &key (depth-limit nil))
  (let ((classes nil))
    (labels ((walk-subclasses (class depth)
	       (setq classes (adjoin class classes))
	       (unless (and depth-limit (> depth depth-limit))
		 (dolist (c (class-direct-subclasses class))
		   (walk-subclasses c (1+ depth))))))
      (walk-subclasses class 0))
    (scl:format-item-list (sort classes #'class-name-string-lessp :key #'class-name)
			  :presentation-type 'class
			  :equalize-column-widths t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Document Class Initializations

;;; show init keyword, slot it fills (if any) default value
;;; could be from :initarg, from :default-initargs, from :initform, 
;;; methods on shared-initialize and initialize-instance
;;; class-default-initargs, class-direct-default-initargs
;;; slot-definition-initform, slot-definition-initfunction, slot-definition-initargs
;;; should also show names of initialization methods and what they are 
;;; defined on. (shared-initialize and initialize-instance)
(defun 1document-class-initializations0 (class &key direct (match #'scl:true))
  (let ((initialization-data (scl:make-heap :predicate #'string-greaterp)))
    ;; INITIALIZATION-DATA is where we record information about
    ;; initialization keywords as we find them.  They are stored in a
    ;; heap so that they are magically sorted for us and can be looked
    ;; up quickly.  For each keyword argument, we record the keyword,
    ;; the slot it is an initarg for, if any, and any default value we
    ;; might find.  We also record any methods for which it is an &key
    ;; argument.
    ;; Too bad there isn't a local version of defstruct.
    (macrolet ((1init-class0 (init) `(first ,init))
	       (1init-slots0 (init) `(second ,init))		;list of affected slots
	       (1init-default0 (init) `(third ,init))
	       (1init-has-default0 (init) `(fourth ,init))
	       (1init-methods0 (init) `(fifth ,init))
	       (1make-init-info 0(&key class slot (default nil has-default) (methods nil))
		 `(list ,class ,slot ,default ,has-default ,methods)))
      (labels ((1find-init0 (init-keyword)
		 ;; Given an init keyword, find the corresponding entry in
		 ;; INITIALIZATION-DATA, creating one if necessary.
		 (multiple-value-bind (info key)
		     (scl:send initialization-data :find-by-key init-keyword #'eq t)
		   (declare (ignore key))
		   (unless info
		     (setq info (make-init-info))
		     (scl:send initialization-data :insert info init-keyword))
		   info))
	       (1update-init-default0 (keyword default)
		 ;; Set the default value for the keyword to default, if it does not already
		 ;; have one.
		 (let ((init (find-init keyword)))
		   (unless (init-has-default init)
		     (setf (init-default init) default)
		     (setf (init-has-default init) t))))
	       (1update-init-slots0 (keyword slot)
		 ;; Set the slot for keyword if it does not already have one.
		 ;; can an initarg be used to fill more than one slot?
		 (let ((init (find-init keyword)))
		   (pushnew (slot-definition-name slot)
			    (init-slots init))))
	       (1process-class-inits0 (class)
		 ;; Given a class, extract information from its default-initargs and its
		 ;; direct slots.
		 (dolist (di (class-direct-default-initargs class))
		   (when (funcall match (car di))
		     (update-init-default (first di) (second di))))
;;; this next thing gets too much stuff:
;		 (dolist (init (class-direct-init-keywords class))
;		   (when (funcall match init)
;		     (find-init init)))
		 (dolist (slot (class-direct-slots class))
		   (dolist (slot-initarg (slot-definition-initargs slot))
		     (when (funcall match slot-initarg)
		       (update-init-slots slot-initarg slot)))))
	       )
	;;; collect the initializations
	(if direct
	    (process-class-inits class)
	    (progn
	      (dolist (init (class-make-instance-keywords class))
		(when (funcall match init)
		  (find-init init)))
	      (dolist (c (class-precedence-list class))
		(process-class-inits c))))

	;;; print them out in alphabetical order
	(let ((info nil))
	  (loop (multiple-value-bind (init-info init-keyword more-p)
		    (scl:send initialization-data :remove)
		  (unless more-p (return))
		  (push (cons init-keyword init-info) info)))
	  (fresh-line)
	  (scl:formatting-table (t :inter-column-spacing 4)
	    (scl:formatting-column-headings ()
	      (scl:with-character-face (:italic)
		(scl:formatting-cell () (write-string "init option"))
		(scl:formatting-cell () (write-string "slots"))
		(scl:formatting-cell () (write-string "default"))))
	    (dolist (this-info info)
	      (let* ((init-keyword (car this-info))
		     (init-info (cdr this-info))
		     (slots (init-slots init-info))
		     (init-default (init-default init-info))
		     (has-default (init-has-default init-info)))
		(scl:formatting-row ()
		  (scl:format-cell init-keyword #'prin1)
		  (scl:formatting-cell ()
		    (scl:format-textual-list slots #'prin1 :separator " "))
 		  (scl:formatting-cell ()
		    (if has-default
			(scl:abbreviating-output (t :height 1 :show-abbreviation t)
			  (prin1 init-default))
			(princ ""))))
		))))
	)) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Document Generic Function

(defun 1document-generic-function0 (generic-function)
  (let ((arg-precedence (generic-function-argument-precedence-order generic-function))
	(lambda-list (generic-function-lambda-list generic-function)) )
    (flet ((print-arglist (arglist)
	     (lt:print-lambda-list arglist *standard-output*
				   :brief t :error-p nil)))
      (format t "~&~%Generic function ~@\\presentation\\ "
	      (generic-function-name generic-function) 'generic-function-name)
      (print-arglist lambda-list)
      (unless (do ((args lambda-list (cdr args))
		   (prec arg-precedence (cdr args)))
		  ((null prec) t)
		(unless (eq (car args) (car prec))
		  (return nil)))
	(format t "~&has argument precedence ")
	(print-arglist arg-precedence))
      (format t "~&Its methods are combined using ~s method combination."
	      (method-combination-definition-name
		(generic-function-method-combination generic-function)))
      (let ((source (si:get-source-file-name (generic-function-name generic-function) 'defun)))
	(when source
	  (format t "~&There is an explicit ~a in file ~a." 'defgeneric source)))
      (when (generic-function-selector generic-function)
	(format t "~&This generic function is compatible with the ~s message."
		(generic-function-selector generic-function)))
      )))

(defun 1list-classes-specializing-generic-function 0(generic-function methods)
  (declare (ignore generic-function))
  (let ((classes nil))
    (dolist (m methods)
      (dolist (specializer (method-specializers m))
	(unless (listp specializer)
	  (setq classes (adjoin specializer classes)))))
    (setq classes (sort classes #'class-name-string-lessp :key #'class-name))
    classes))

;;; what about just sorting by class name?

(defun 1sort-generic-function-methods0 (generic-function methods &key sort)
  ;;; We're allowed to modify METHODS.  It's out callers responsibility to copy if necessary.
  (if sort
      (sort methods (make-method-sort-predicate generic-function sort))
      methods))

(defun 1make-method-sort-predicate0 (generic-function sort)
  (case sort
    ((1:alphabetic :alphabetical0)
     #'(lambda (method1 method2)
	 (labels ((1asp0 (m1-specs m2-specs)
		    (let (spec1 spec2)
		      (cond ((or (null m1-specs)
				 (null m2-specs))
			     t)					;preserve status quo
			    ((eql-method-specializer-p (setq spec1 (car m1-specs)))
			     t)					;EQL's first
			    ((eql-method-specializer-p (setq spec2 (car m2-specs)))
			     nil)
			    ((eq spec1 spec2)
			     (asp (cdr m1-specs) (cdr m2-specs)))
			    (t (string-lessp (class-name spec1)
					     (class-name spec2)))
			    ))))
	   (asp (method-specializers method1)
		(method-specializers method2)))))
    ((1:depth :heuristic0)
     (let ((precedence-positions
	     (mapcar #'(lambda (method-arg)
			 (position method-arg
				   (generic-function-lambda-list generic-function)))
		     (generic-function-argument-precedence-order generic-function))))
       ;;; least specific first
       #'(lambda (method1 method2)
	   (labels ((1msp0 (positions)
		      (if (null positions)
			  (let ((qualifier-length1 (length (method-qualifiers method1)))
				(qualifier-length2 (length (method-qualifiers method2))))
			  ;;; Methods have the same specializers.
			  ;;; Sort one with fewest qualifiers first.
			    (cond ((< qualifier-length1 qualifier-length2)
				   t)				;less qualified first
				  ((> qualifier-length1 qualifier-length2)
				   nil)
				  (t t)))			;preserve status quo
			  (macrolet ((1method-specializer0 (method)
				       `(nth (car positions)
					     (method-specializers ,method)))
				     (1depth-metric0 (class)
				       `(length (class-precedence-list
						  ,class))))
			    (let* ((spec1 (method-specializer method1))
				   (spec2 (method-specializer method2))
				   (eql1 (eql-method-specializer-p spec1))
				   (eql2 (eql-method-specializer-p spec2))
				   depth1 depth2)
		 ;;; Is spec1 less specific than spec2?
			      (cond ((and eql1 eql2)
				     (msp (cdr positions)))
				    (eql1 nil)
				    (eql2 t)
				    ((eq spec1 spec2)
				     (msp (cdr positions)))
				    ((< (setq depth1 (depth-metric spec1))
					(setq depth2 (depth-metric spec2)))
				     t)				;deeper one is less general
				    ((> depth1 depth2)
				     nil)
				    (t (string-lessp (class-name spec1)
						     (class-name spec2)))))))))
	     (msp precedence-positions)))))
    (t #'scl:true)
    ))

(defun1 select-methods-based-on-specializers0 (methods-list specialized-args)
  ;;; we'reactually cheating here.  There is currently no way to tell if :wild is
  ;;; an actual argument or a wildcarding indicator.  We take the liberal approach and
  ;;; assume it is a wild card for now.
  (let ((selected-methods nil))
    (dolist (method methods-list)
      (block consider-method
	(do* ((args specialized-args (cdr args))
	      (specializers (method-specializers method) (cdr specializers))
	      (arg (car args) (car args))
	      (spec (car specializers) (car specializers)))
	     ((null args)
	      (push method selected-methods))
	  (destructuring-bind (&optional (arg-kind :wild) arg-thing) arg
	    (case arg-kind
	      (:class
		(when (or (eql-method-specializer-p spec)
			  (not (subtypep arg-thing spec)))
		  (return-from consider-method)))
	      (:object
		(multiple-value-bind (eql? value)
		    (eql-method-specializer-p spec)
		  (unless (if eql?
			      (eql arg-thing value)
			      (typep arg-thing spec))
		    (return-from consider-method))))
	      (:wild))))))
    selected-methods))

(defun1 document-class-generic-functions0 (class &key detailed (match ""))
  (let ((methods-by-generic-function nil) )
    (labels ((1enter-method0 (method generic-function)
	       (let ((entry (member generic-function methods-by-generic-function
				    :key #'(lambda (x)
					     (method-generic-function (car x))))))
		 (if entry
		     (pushnew method (car entry))
		     (push (list method) methods-by-generic-function))))
	     (1build-types-arg0 (methods lambda-list)
	       (let ((types nil))
		 (dolist (method methods)
		   (do ((ll lambda-list (cdr ll))
			(specs (method-specializers method) (cdr specs)))
		       ((null specs))
		     (when (eq (car specs) class)
		       (pushnew (list (car ll) '!) types :key #'car))))
		 types)) )
      (dolist (method (specializer-direct-methods class))
	(let ((generic-function (method-generic-function method)))
	  (when (zl:string-search match (grok-generic-function-name generic-function))
	    (enter-method method generic-function))))
     
      (setq methods-by-generic-function
	    (sort methods-by-generic-function
		  #'generic-function-sort-name-predicate
		  :key #'(lambda (x)
			   (method-generic-function (car x)))))

      (let ((n-generics (length methods-by-generic-function)))
	(format t "~&~d generic function~:p~
                   ~:[~*~; matching ~s~] ~
                   which are specialized for ~\\presentation\\~:[:~;.~]"
		n-generics
		(> (length match) 0) match
		class 'class
		(zerop n-generics)))

      (scl:indenting-output (t 2)
	(fresh-line)
	(if detailed
	    (dolist (methods methods-by-generic-function)
	      (let ((lambda-list (generic-function-lambda-list
				   (method-generic-function (car methods)))))
		(format t "~&~s " (method-generic-function-name (car methods)))
		(lt:print-lambda-list
		  lambda-list
		  *standard-output*
		  :brief t
		  :types (build-types-arg methods lambda-list)
		  :error-p nil)))
	    (scl:filling-output (t)
	      (scl:formatting-textual-list (t :finally " and ")
		(dolist (methods methods-by-generic-function)
		  (scl:formatting-textual-list-element ()
		    (format t "~s"
			    (generic-function-name
			      (method-generic-function
				(car methods)))))))) )) )))

(defun 1effective-method-method-evaluation-order0 (effective-method)
  (let ((methods-reverse-evaluation-order nil))
    (labels ((walker (form kind usage state)
	       (declare (ignore usage)
			(values new-state suppress-processing))
	       (if (and (consp form)
			(listp kind)
			(eq (first form) 'call-method))
		   (progn
		     (push (second form) methods-reverse-evaluation-order)
		     (dolist (next-method (if (cdddr form) (getf (cddr form) ':next-methods)
					      (third form)))
		       (cond ((typep next-method 'method)
			      (push next-method methods-reverse-evaluation-order))
			     ((listp next-method)
			      (lt:mapforms-1 next-method))
			     (t (warn "Unknown next-method ~s" next-method)) ))
		     (values state t))
		   (values state nil))) )
      (lt:mapforms #'walker effective-method))
    (nreverse methods-reverse-evaluation-order)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CP commands:

(cp:define-command (1com-show-class-superclasses0 :command-table "CLOS")
    ((class 'class
	    :display-default nil
	    :prompt "class"
	    :confirm t
	    :documentation "A class whose superclasses are of interest."
	    )
     &key
     (brief           'scl:boolean
		      :default nil
		      :mentioned-default t
		      :documentation "Don't show structure, just list names.")
     (detailed        'scl:boolean
		      :default nil
		      :mentioned-default t
		      :documentation "List accessors and initargs for the slots as well.")
     (duplicates      'scl:boolean
		      :default nil
		      :mentioned-default t
		      :documentation
		      "Show duplicate occurrences of classes in the hierarchy.")
     (match           '(scl:token-or-type (:all :none) string)
		      :prompt "Superclasses matching"
		      :default :all
		      :documentation "Show superclasses which contain this substring.")
     (initargs        '(scl:token-or-type (:all :none) string)
		      :prompt "Initargs matching"
		      :default :none
		      :mentioned-default :all
		      :documentation "Show initargs containing this substring.")
     (slots           '(scl:token-or-type (:all :none) string)
		      :prompt "Slots matching"
		      :default :none
		      :mentioned-default :all
		      :documentation "Show slots containing this substring.")
     (methods         '(scl:token-or-type (:all :none) string)
		      :prompt "Methods matching"
		      :default :none
		      :mentioned-default :all
		      :documentation "Show methods containing this substring.")
     )
   (when (and detailed (eq slots :none))
     (format t "(the :Detailed argument is being ignored because it only applies to slots"))
   (if brief
       (progn
	 (when (some #'(lambda (x) (scl:neq x :none)) (list methods slots initargs))
	   (format t "~&The :Brief option does not accept match keywords, ignoreing them."))
	 (list-class-and-superclasses class))

       (document-class-and-superclasses
	 class
	 :match-superclass (get-matcher-function match #'class-name)
	 :match-init-keywords (get-matcher-function initargs #'identity)
	 :match-default-initargs (get-matcher-function initargs #'first)
	 :match-slots (get-matcher-function slots #'slot-definition-name)
	 :match-methods (get-matcher-function
			  methods
			  #'(lambda (method)
			      (let ((fspec (generic-function-name
					     (method-generic-function method))))
				(cond ((symbolp fspec) fspec)
				      ((and (listp fspec)
					    (eq (car fspec) 'setf))
				       (second fspec))
				      (t "")))))
	 :slot-description (if detailed :verbose :terse)
	 :exclude-classes '(T standard-object structure-object)
	 :show-duplicate-classes duplicates
	 )))

(cp:define-command (1com-show-class-subclasses0 :command-table "CLOS")
    ((class 'class
	    :display-default nil
	    :prompt "class"
	    :confirm t
	    :documentation "A class whose subclasses are of interest.")
     &key
     (brief      'scl:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "Don't show structure, just list names.")
     (detailed   'scl:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "List accessors and initargs for the slots as well.")
     (levels     '(scl:token-or-type (:all) (integer 1 *))
		 :default ':all
		 :confirm t
		 :prompt "number"
		 :display-default nil
		 :documentation "Number of levels of subclasses to show.")
     (match      '(scl:token-or-type (:all :none) string)
		 :default :all
		 :documentation "Show only those subclasses which contain this substring.")
     (duplicates 'scl:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "Show duplicate occurances of classes within the hierarchy.")
     (initargs   '(scl:token-or-type (:all :none) string)
		 :prompt "Initargs matching"
		 :default :none
		 :mentioned-default :all
		 :documentation "Show those initargs containing this substring.")
     (slots      '(scl:token-or-type (:all :none) string)
		 :prompt "Slots matching"
		 :default :none
		 :mentioned-default :all
		 :documentation "Show those slots containing this substring.")
     (methods    '(scl:token-or-type (:all :none) string)
		 :prompt "Methods matching"
		 :default :none
		 :mentioned-default :all
		 :documentation "Show methods containing this substring.")
     )
   (when (and detailed (eq slots :none))
     (format t "(the :Detailed argument is being ignored because it only applies to slots"))
   (if brief
       (list-class-and-subclasses class :depth-limit (if (numberp levels) levels nil))
       (document-class-and-subclasses
	 class
	 :depth-limit (if (numberp levels) levels nil)
	 :match-subclasses (get-matcher-function match #'class-name-string-for-matchp)
	 :match-init-keywords (get-matcher-function initargs #'identity)
	 :match-default-initargs (get-matcher-function initargs #'first)
	 :match-slots (get-matcher-function slots #'slot-definition-name)
	 :match-methods (get-matcher-function
			  methods
			  #'(lambda (method)
			      (let ((fspec (generic-function-name
					     (method-generic-function method))))
				(cond ((symbolp fspec) fspec)
				      ((and (listp fspec)
					    (eq (car fspec) 'setf))
				       (second fspec))
				      (t "")))))
	 :slot-description (if detailed :verbose :terse)
	 :show-duplicate-classes duplicates
	 )))

(cp:define-command (1com-show-class-slots0 :command-table "CLOS")
    ((class     'class
		:display-default nil
		:prompt "class"
		:confirm t
		:documentation "A class whose slots are of interest.")
     &key
     (detailed  'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "Incliude information about accessors, etc.")
     (direct    'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "Only show direct slots (those defined on this class).")
     (sort      '(member :alphabetical :class)
		:default :alphabetical
		:documentation
		"Sort the display alphabetically by slot name,
or by location in superclass hierarchy.")
     (match     '(scl:token-or-type (:all) string)
		:prompt "Slots matching"
		:default :all
		:documentation "Show slots whose names contain this substring."))
   (let ((matcher (get-matcher-function match #'slot-definition-name)))
     (if (eq sort :alphabetical)
	 (let* ((the-class class)
		(the-slots))
	   (if direct
	       (dolist (slot (class-direct-slots the-class))
		 (when (funcall matcher slot)
		   (pushnew slot the-slots :key #'slot-definition-name)))
	       (dolist (class (class-precedence-list the-class))
		 (dolist (slot (class-direct-slots class))
		   (when (funcall matcher slot)
		     (pushnew slot the-slots :key #'slot-definition-name)))))
	   (format t "~&~d ~:[Slot~2:*~p~;Direct slot~2:*~p~] of "
		   (length the-slots) direct)
	   (scl:present the-class 'class)
	   (if (eq match :all)	
	       nil
	       (format t " matching ~s" match))
	   (if the-slots
	       (format t ":  ")
	       (write-char #\.))
	   (setq the-slots (sort the-slots #'string-lessp :key #'slot-definition-name))
	   (scl:indenting-output (t 4)
	     (if detailed
		 (dolist (slot the-slots)
		   (document-slot slot t t))
	         (scl:filling-output ()
		   (scl:formatting-textual-list ()
		     (dolist (slot the-slots)
		       (scl:formatting-textual-list-element ()
			 (prin1 (slot-definition-name slot)))))))))
	 ;;; show slots by class hierarchy, call this for the user since they were too dumb
	 ;;; to do it themselves:
	 (document-class-and-superclasses
	   class
	   :match-superclass (if direct #'scl:false #'scl:true)
	   :match-slots matcher
	   :match-methods #'scl:false
	   :slot-description (if detailed :verbose :terse)
	   :exclude-classes '(T standard-object structure-object)
	   :show-duplicate-classes nil
	   ))))

(cp:define-command (1com-show-class-initargs0 :command-table "CLOS")
    ((class     'class
		:display-default nil
		:prompt "class"
		:confirm t
		:documentation "A class whose initargs are of interest.")
     &key
     (detailed  'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "Show affected slots and defaults too.")
     (direct    'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "Only show initializations defined on this class.")
     (match     '(scl:token-or-type (:all) string)
		:prompt "Initargs matching"
		:default :all
		:documentation "Only show initargs whose names contain this substring.")
     (sort      '(member :alphabetical :class)
		:default :alphabetical
		:documentation
		"Sort the display alphabetically by initarg,
or by location in superclass hierarchy."))
   ;; suggestion for future work: call COMPUTE-CLASS-PRECEDENCE-LIST
   ;; (when class not finalized, or maybe always) and walk over the
   ;; class precedence list, rather than walking over the class itself.
   ;; Not done here because the pre-existing code cannot be easily
   ;; changed to do that. (Gilbert & KMP)
   (unless (class-finalized-p class)
     (finalize-inheritance class))
   (if (eq sort :alphabetical)
       (if detailed
	   (document-class-initializations
	     class
	     :match (get-matcher-function match #'identity)
	     :direct direct)
	   (multiple-value-bind (initargs allow-other-keys-p)
	       (if direct
		   (class-direct-init-keywords class)
		   (values (class-make-instance-keywords class)
			   (ldb-test %%standard-class-make-instance-allow-other-keys-p
				     (class-bits class))))
	     (setf initargs (nconc (sort (copy-list initargs) #'string-lessp)
				   (and allow-other-keys-p '(&allow-other-keys))))
	     (if initargs
		 (scl:format-textual-list initargs #'prin1)
		 (format t "~&No ~:[~;direct ~]initargs of ~@\\presentation\\"
			 direct class 'class))))
       (document-class-and-superclasses
	 class
	 :match-superclass (if direct #'scl:false #'scl:true)
	 :match-default-initargs (get-matcher-function match #'car)
	 :match-init-keywords (get-matcher-function match #'identity)
	 :match-slots #'scl:false
	 :match-methods #'(lambda (method)
			    (let (keywords)
			      (and (let ((gf (method-generic-function method)))
				     (or (eq gf *initialize-instance*)
					 (eq gf *shared-initialize*)))
				   (setq keywords (function-keywords method))
				   (some (get-matcher-function match #'identity)
					 keywords))))
	 :exclude-classes '(T standard-object structure-object)
	 :show-duplicate-classes nil
	 ))) 

(cp:define-command (1com-show-class-generic-functions0 :command-table "CLOS")
    ((class     'class
		:display-default nil
		:prompt "class"
		:confirm t
		:documentation "A class whose generic functions are of interest.")
     &key
     (detailed  'scl:boolean
		:default nil
		:mentioned-default t
		:documentation
		"Show arguments, indicating those which can be specialized for this class.")
     (match     'string
		:prompt "Generic functions matching"
		:default ""
		:mentioned-default ""
		:documentation "Show generic functions whose names contain this substring.")
     )
   (document-class-generic-functions class :detailed detailed :match match))

(cp:define-command (1com-show-class-methods0 :command-table "CLOS")
    ((class     'class
		:display-default nil
		:prompt "class"
		:confirm t
		:documentation "A class whose generic functions are of interest.")
     &key
     (direct    'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "Don't show methods inherited from superclasses.")
     (stop-at   `(superclass ,class)
		:default (car (last (class-precedence-list class) 2))
		:documentation "Only look as far upwards as this class.")
     (match     'string
		:prompt "Generic functions matching"
		:default ""
		:mentioned-default ""
		:documentation "Show generic functions whose names contain this substring.")
     )
   (let ((methods nil)
	 (interesting-types nil))
     (labels ((1collect-methods-for-class0 (class)
		(dolist (method (specializer-direct-methods class))
		  (when (zl:string-search match (grok-generic-function-name
						  (method-generic-function method)))
		    (pushnew method methods)))))
       (when direct (setq stop-at class))
       (dolist (class (class-precedence-list class))
	 (push class interesting-types)
	 (collect-methods-for-class class)
	 (when (eq class stop-at) (return)))
       ;;; This should probably sort by generic function and then for
       ;;; methods in each generic function bucket, sort them the in the
       ;;; same ways that Show CLOS Generic Function does.
       (setq methods (sort methods #'generic-function-sort-name-predicate
			   :key #'method-generic-function))
       (scl:indenting-output (t 2)
	 (dolist (method methods)
	   ;;; might eventually be worth having a :detailed argument or something which
	   ;;; allows the user to select between the ":only-these-types" behavior and the
	   ;;; "specializers-for-abbreviation" behavior.
	   (document-method method
			    :only-these-types interesting-types
;			    :specializers-for-abbreviation (list class)
			    )))
       )))

(cp:define-command (1com-show-CLOS-generic-function0 :name "Show CLOS Generic Function"
						   :command-table "CLOS")
    ((generic-function
       'generic-function-name
       :display-default nil
       :prompt "generic function name"
       :confirm t
       :documentation "The name of a generic function whose methods are of interest.")
     &key
     (classes      '(scl:alist-member
		      :alist (("Yes" . t) ("No" . nil) ("by class" . :class)))
		   :default nil
		   :mentioned-default t
		   :documentation
		   "List classes which define methods for this generic function.")
     (methods							; 'scl:boolean
       '(scl:alist-member
	  :alist (("Yes" . t) ("No" . nil) ("Detailed" . :detailed)))
       :default nil
       :mentioned-default t
       :documentation
       "List methods defined on this generic function.")
     (specialized  `(generic-function-specializers-list ,generic-function
							:allow-wildcards t)
		   :prompt nil
		   :default nil
		   :documentation "Only consider methods satisfying these specializers")
     (sort         '(member :alphabetical :heuristic)
		   :default nil
		   :mentioned-default :alphabetical
		   :documentation
		   "Sort the methods by specializer names (in argument precedence order)
either alphabetically or heuristically.")
     )

   (when (and specialized (not (or methods classes)))
     (format t 
	     "(The :Specialized argument is meaningless without :Classes or :Methods.  It wll be ignored.)"))

   (let* ((generic-function (fdefinition-in-environment generic-function nil))
	  (methods-list (generic-function-methods generic-function)))
     (document-generic-function generic-function)
     (fresh-line)

     (setq methods-list
	   (if specialized
	       (select-methods-based-on-specializers methods-list specialized)
	       (copy-list methods-list)))

     (when classes
       (let* ((defined-on-classes
		(list-classes-specializing-generic-function generic-function methods-list))
	      (length (length defined-on-classes)))
	 (format t "~%There ~@? with methods defined for ~@\\presentation\\"
		 (if (= length 1) "is ~d class" "are ~d classes")
		 length
		 (generic-function-name generic-function) 'generic-function-name)
	 (when specialized
	   (format t " satisfying ~@\\presentation\\"
		   specialized
		   `((generic-function-specializers-list
		       ,generic-function)
		     :display-as-specializer t)))
	 (scl:format-item-list defined-on-classes
			       :presentation-type 'class) ))
     (if methods
	 (let* ( ;;(detailed-p (eq methods :detailed))
		(methods-list (sort-generic-function-methods generic-function
							     methods-list
							     :sort sort))
		(length (length methods-list)))
	   (unless sort (setq sort :alphabetical))
	   (format t "~%There ~:[are~;is~] ~d method~:p defined for ~@\\presentation\\"
		   (= length 1) length
		   (generic-function-name generic-function) 'generic-function-name)
	   (when specialized
	     (format t " satisfying ~@\\presentation\\"
		     specialized
		     `((generic-function-specializers-list
			 ,generic-function)
		       :display-as-specializer t)))
	   (scl:indenting-output (t 2)
	     (dolist (method methods-list)
	       (document-method method
				:only-these-types :all
				:show-generic-function-name nil))))
	 (when sort
	   (format t "(As no methods are being listed the :Sort argument is being ignored)")))
     ))

(cp:define-command (1com-show-effective-method0 :command-table "CLOS")
    ((generic-function-name
       '(generic-function-name :defined t)
       :prompt "generic function name"
       :confirm t
       :display-default nil
       :documentation "The name of a generic function whose methods are of interest."
       )
     (specialized-for
       `(generic-function-specializers-list ,generic-function-name)
       :prompt nil
       :confirm t)
     &key
     (code 'scl:boolean
	   :default nil
	   :mentioned-default t
	   :documentation "Show LISP code illustrating the behavior of the effective method")
     )
   (let ((generic-function (fdefinition (si:unencapsulate-function-spec
					  generic-function-name)))
	 applicable-methods effective-method method-evaluation-order)
     (setq applicable-methods
	   (compute-applicable-methods
	     generic-function
	     (mapcar #'(lambda (thing)
			 (case (car thing)
			   (:wild nil)				;should be an error
			   (:object (second thing))
			   (:class
			     (let ((class (second thing)))
			       (class-prototype class)))))
		     specialized-for)))
     (when applicable-methods
       (setq effective-method (compute-effective-method-1
				generic-function
				applicable-methods
				#'(lambda (type position)
				    (let ((thing (nth position specialized-for)))
				      (ecase type
					(class
					  (case (car thing)
					    (:wild nil)	;should be an error
					    (:object (class-of (second thing)))
					    (:class (second thing))))
					(eql
					  (case (car thing)
					    (:wild nil)	;should be an error
					    (:object (values t (second thing)))
					    (:class nil)))))))
	     method-evaluation-order
	     (effective-method-method-evaluation-order effective-method)))
     (format t "~&~%There are ~d method~:p applicable to ~s of ~@\\presentation\\."
	     (length applicable-methods)
	     generic-function-name
	     specialized-for `((generic-function-specializers-list ,generic-function-name)
			       :display-as-specializer t))
     (fresh-line)
     (scl:indenting-output (t 2)
       (dolist (method method-evaluation-order)
	 (document-method method
			  :only-these-types :all
			  :show-generic-function-name nil)))
     (when code
       (if effective-method
	   (progn 
	     (fresh-line)
	     (print effective-method))
	   (format t "~&No effective method.")))
     ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; New presentation types

(scl:define-presentation-type 1specializer-for-generic-function-argument
0      ((generic-function-name parameter-name &key allow-wildcards)
       &key initially-list-possibilities display-as-specializer)
   1:no-deftype0 t
   1:parser
0   ((stream &key original-type)
    (let* ((choices (if allow-wildcards '(:object :class :wild) '(:object :class)))
	   (what (dw:with-accept-help
		     (((:subhelp :append)
		       (format nil
			       "How do you wish to specialize the ~a argument to ~a (~{~:(~a~)~^, ~})?"
			       (symbol-name parameter-name)
			       (symbol-name generic-function-name)
			       choices)))
		   (scl:accept `(member ,@choices)
			       :stream stream
			       :initially-display-possibilities initially-list-possibilities
			       :prompt (format nil "argument ~a" (symbol-name parameter-name))
			       :provide-default nil
			       :original-type original-type
			       :additional-activation-chars '(#\space)
			       :additional-blip-chars '(#\space))))
	   thing)
      (flet ((eat-delimeter ()
	       (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
						   #\space)
		 (sys:parse-ferror "You must type a space after ~a" what))))
	(setq thing
	      (case what
		(:wild :wild)
		(:object
		  (eat-delimeter)
		  (dw:with-accept-help
		      (((:subhelp :append)
			#'(lambda (stream string-so-far)
			    (declare (ignore string-so-far))
			    (format stream
				    "An object on which to specialize the ~a argument"
				    (symbol-name parameter-name)
				    (symbol-name generic-function-name)))))
		    (scl:accept 'sys:expression
				:stream stream
				:prompt nil
				:initially-display-possibilities nil
				:provide-default nil
				)))
		(:class
		  (eat-delimeter)
		  (let* ((subprompt (format nil "the ~a argument to ~a"
					    (symbol-name parameter-name)
					    (symbol-name generic-function-name)))
			 (class (dw:with-accept-help
				    (((:subhelp :append)
				      #'(lambda (stream string-so-far)
					  (declare (ignore string-so-far))
					  (format stream "A class on which ~a is specialized" subprompt))))
				  (scl:accept 'class
					      :stream stream
					      :prompt nil
					      :initially-display-possibilities
					      initially-list-possibilities
					      ))))
		    class))) ))
      (list what thing)))
  1 :printer0 ((object stream)
	     (if display-as-specializer
		 (case (car object)
		   (:object (format stream "(eql ~s)" (second object)))
		   (:class (scl:present (second object) 'class :stream stream))
		   (:wild (write-char #\* stream)))
		 (progn
		   (princ (car object) stream)
		   (case (car object)
		     (:object
		       (write-char #\space stream)
		       (prin1 (second object) stream))
		     (:class
		       (write-char #\space stream)
		       (scl:present (second object) 'class :stream stream))
		     (:wild)))))
   )

(scl:define-presentation-type 1generic-function-specializers-list
0      ((generic-function-name &key allow-wildcards)
       &key prompt initially-list-possibilities display-as-specializer)
   1:describer
0   ((stream)
    (format stream "objects or classes specializing the generic function ~s"
	    generic-function-name))
   1:no-deftype0 t
   1:printer
0   ((object stream)
    (scl:formatting-textual-list (stream :separator " ")
      (dolist (spec object)
	(scl:formatting-textual-list-element (stream)
	  (scl:present spec
		       `((specializer-for-generic-function-argument
			   ,generic-function-name
			   #:any)
			 :display-as-specializer ,display-as-specializer)
		       :stream stream)))))
1   :parser
0   ((stream)
    (let ((generic-function (fdefinition (si:unencapsulate-function-spec
					   generic-function-name)))
	  lambda-list interests)
      (when generic-function
	(setq lambda-list (generic-function-lambda-list generic-function)
	      interests (interesting-specializer-positions generic-function))
	(dw:with-accept-help
	    (((:subhelp :override)
	      #'(lambda (stream string-so-far)
		  (declare (ignore string-so-far))
		  (let ((specializable-args (do ((args lambda-list (cdr args))
						 (ints interests (cdr ints))
						 (specs nil))
						((null ints) (nreverse specs))
					      (when (car ints)
						(push (car args) specs)))))
		    (scl:filling-output (stream)
		      (format stream "The arguments to the generic function ~s are "
			      generic-function-name)
		      (lt:print-lambda-list lambda-list stream :brief t :error-p nil)
		      (format stream ".~&Of these, ")
		      (scl:format-textual-list specializable-args #'princ
					       :stream stream :finally " and ")
		      (format stream " may be specialized.")
		      )))))
	  (do* ((ints interests (cdr ints))
		(arguments (generic-function-lambda-list generic-function)
			   (cdr arguments))
		(argument (car arguments) (car arguments)))
	       ((null ints)
		interests)
	    (symbol-macrolet ((interest (car ints)))
	      (when interest
		(setf interest
		      (scl:accept `(specializer-for-generic-function-argument
				     ,generic-function-name ,argument
				     :allow-wildcards ,allow-wildcards)
				  :stream stream
				  :initially-display-possibilities initially-list-possibilities
				  :prompt nil
				  :prompt-mode :normal
				  :query-identifier argument
				  :separate-inferior-queries nil			
				  :stream stream
				  :additional-blip-chars '(#\space)))
		(when (cdr ints)
		  (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
						      #\space)
		    (sys:parse-ferror "You must type a space between specializers")))
		)))
	  )) ))
   )

(scl:define-presentation-type1 superclass0 ((class))
1   :no-deftype0 t
   1:description0 "a superclass"
  1 :printer0 ((object stream)
	     (scl:present object 'class :stream stream))
   1:parser
0   ((stream &key type initially-display-possibilities)
    (let ((classes (class-precedence-list class)))
      (dw:with-accept-help
	  (((:subhelp :override)
	    #'(lambda (stream string-so-far)
	        ;; string-so-far isi what the user has already typed
		(declare (ignore string-so-far))
		(format stream "Select one of these classes:  ")
		(scl:indenting-output (t 4)
		  (scl:format-textual-list classes
					   #'(lambda (class stream)
					       (scl:present class 'class :stream stream))) ))))
	(scl:accept `(and class (satisfies ,#'(lambda (class)
						(member class classes))))
		    :prompt nil
		    :stream stream
		    :initially-display-possibilities initially-display-possibilities))))
   )

(scl:define-presentation-type 1class0 ()
   1:no-deftype0 t
  1 :parser
0   ((stream &key default)
    (do* ((class-name (scl:accept 'class-name
				  :stream stream
				  :prompt nil
				  :default (and default
						(clos:class-name default))))
	  (class (find-class class-name nil)))
	 (class class)
      (sys:parse-error "~s is not a defined class" class-name)))
   1:printer
0   ((class stream)
    (with-output-as-presentation (:stream stream
				  :object class
				  :type 'class
				  :allow-sensitive-inferiors nil)
      (if (and (slot-exists-p class 'name)
	       (slot-boundp class 'name)
	       (class-name-proper-p class))
	  (prin1 (class-name class) stream)
	  (prin1 class stream))))
   )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; some presentation translators

(scl:define-presentation-to-command-translator1 class-show-class-superclasses
0   (class :gesture nil :documentation "Show class superclasses")
   (class)
  `(com-show-class-superclasses ,class :detailed nil :duplicates nil))

(scl:define-presentation-to-command-translator 1class-show-class-subclasses
0   (class :gesture nil :documentation "Show class subclasses")
   (class)
  `(com-show-class-subclasses ,class :detailed nil :duplicates nil))

(scl:define-presentation-to-command-translator 1class-show-class-slots
0   (class :gesture nil :documentation "Show class slots")
   (class)
  `(com-show-class-slots ,class :direct t))

(scl:define-presentation-to-command-translator 1class-show-class-initargs
0   (class :gesture nil :documentation "Show class initargs")
   (class)
  `(com-show-class-initargs ,class :direct t))

(scl:define-presentation-to-command-translator 1class-show-class-generic-functions
0   (class :gesture nil :documentation "Show class generic functions")
   (class)
  `(com-show-class-generic-functions ,class))

(scl:define-presentation-to-command-translator 1class-show-class-methods
0   (class :gesture nil :documentation "Show class methods")
   (class)
  `(com-show-class-methods ,class :direct t))

(scl:define-presentation-to-command-translator 1generic-function-name-show
0   ((generic-function-name :defined t)
    :gesture nil
    :documentation "Show CLOS generic function")
   (gf-name)
  `(com-show-clos-generic-function ,gf-name :classes t))

(scl:define-presentation-to-command-translator 1class-edit-definition
0   (class :gesture :edit-function :documentation "Edit class definition")
   (class)
  `(si:com-edit-definition ,(class-name class) defclass))


#|
;;; Useful functions, recycle these someday?

;;; true if and only if specializer1 is a "subspecializer" of -specializer2.
;;; If they are both EQL specializers and their objects are EQL then true.
;;; If they are both class objects and (subclassp specializer1 specializer2) then true.
;;; If spec2 is an EQL specializer and spec1 is a class specializer then false
;;; if spec1 is an EQL specializer and spec2 is a class then (typep spec1 spec2)
(defun1 subspecializer-p0 (specializer1 specializer2)
  (multiple-value-bind (spec1-eql? spec1-object)
      (eql-method-specializer-p specializer1)
    (multiple-value-bind (spec2-eql? spec2-object)
	(eql-method-specializer-p specializer2)
      (if spec1-eql?
	  (if spec2-eql?
	      (eql spec1-object spec2-object)	;both are EQL specializers, are objects eql?
	      (typep spec1-object specializer2))
	  (if spec2-eql?
	      nil
	      (subtypep specializer1 specializer2) )) )))

;;; Describe a default-initializer.
;;; INITARG is a list as returned by class-default-initargs.
;;; EMBOLDEN-NAME is a flag indicating that the name of the initarg should
;;; be displayed in blod face type.
(defun 1document-default-initarg0 (initarg &optional embolden-name)
  (let* ((name (first initarg))
	 (value (second initarg)))
    (fresh-line)
    (with-distinction ((if embolden-name :interesting :boring))
      (scl:abbreviating-output (t :height 1)
	(format t "~s ~s" name value)))
    name))

(defun 1number-of-significant-specializers0 (methods)
  ;;; METHODS is a list of CLOS method objects.  Each method has associated with it a list of
  ;;; specializers describing for what arguments it should be used.  Some of these specializers
  ;;; might be T, indicating that any lisp object is acceptable in that argument position for
  ;;; this method.  In particular, all the methods in the list might have specializers of T for
  ;;; their last few arguments.  This would be the case for required arguments which were never
  ;;; intended to be specialized on.  The goal of this function is to determine how many
  ;;; specializers there are before those specializers which are T for every method in METHODS.
  (let ((the-class-t (find-class 't))
	(significant-specializers 0))
    (labels ((count-significant-specializers (specializer-list)
	       (if specializer-list
		   (let ((n (count-significant-specializers (cdr specializer-list))))
		     (if (zerop n)
			 (if (eq (car specializer-list) the-class-t)
			     0 1)
			 (1+ n)))
		   0)))
      (dolist (method methods)
	(setq significant-specializers
	      (max significant-specializers 
		   (count-significant-specializers (method-specializers method)))))
      significant-specializers)))

(scl:define-presentation-type 1method-specializer0 (() &key abbreviate)
   1:no-deftype0 t
   1:parser0 ((stream)
	    (scl:accept '(or (satisfies eql-method-specializer-p)
			     class)
			:stream stream))
   1:printer0 ((object stream)
	     (dw:with-output-as-presentation (:stream stream
					      :object object
					      :allow-sensitive-inferiors (not abbreviate)
					      :type 'method-specializer)
	       (if abbreviate
		   (write-char #\! stream)
		   (write object :stream stream))
	       ))
   )

|#

