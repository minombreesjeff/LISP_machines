;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

#-(OR Genera Minima)
(DEFVAR *UNBOUND-INSTANCE-SLOT* (MAKE-SYMBOL "*UNBOUND-INSTANCE-SLOT*"))

#+CLOE-Runtime
(IN-PACKAGE 'COMPILER)

#+CLOE-Runtime
(sys::%set-q (sys::%sq-ref sys::sq$l-&unbound-slot) 0 0 0 clos-internals::*unbound-instance-slot*)


#+CLOE-Runtime
(define-code-template clos-internals::%instance-ref (form mode)
  (let ((join (reflabel)))
    (vcompile (second form) CMP-PUSH)
    (vcompile (third form) CMP-LOADI)
    (gencode POP EBX)
    (gencode MOV ECX INDEX EBX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
    (gencode MOV EAX INDEX ECX ESI CADDR32 sys::instance$k-value-offset)
    (gencode CMP EAX ADDR32 (ash (sys::%sq-ref sys::sq$l-&unbound-slot) 2))	;relocatable address
    (gencode JNE join)
    (gencode CALL NEAR INDEX EDX CADDR32 sys::sq$l-%instance-ref-load)
    (setlabel join)
    (compile-1value EAX mode)))

#+(and CLOE-Runtime NOT-YET)
(define-code-template clos-internals::%funcallable-instance-ref (form mode)
  ;;Yes, virginia, the "value" in the symbol name is plural here and singular above.  Ask Schwalenberg.
  (codegen-instance-ref
    form mode
    (+ sys::trampoline$k-values-offset sys::funcallable-instance$p-slots)
    sys::sq$l-%funcallable-instance-ref-load)
  )


#+CLOE-Runtime
(defpred clos-internals::%instance-slot-boundp (form tagt tagf)
  (vcompile (second form) CMP-PUSH)
  (vcompile (third form) CMP-LOADI)
  (gencode POP EBX)
  (gencode MOV ECX INDEX EBX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
  (gencode MOV EAX INDEX ECX ESI CADDR32 sys::instance$k-value-offset)
  (gencode CMP EAX ADDR32 (ash (sys::%sq-ref sys::sq$l-&unbound-slot) 2))	;relocatable address
  (gencode JNE NEAR tagt)
  (gencode JMP tagf))


#+CLOE-Runtime
(defpred clos-internals::%funcallable-instance-slot-boundp (form tagt tagf)
  (vcompile (second form) CMP-PUSH)
  (vcompile (third form) CMP-LOADI)
  (gencode POP EBX)
  (gencode MOV ECX INDEX EBX CADDR32 (ptr+ sys::trampoline$k-values-offset sys::funcallable-instance$p-slots))
  (gencode MOV EAX INDEX ECX ESI CADDR32 sys::array$k-value-offset)
  (gencode CMP EAX ADDR32 (ash (sys::%sq-ref sys::sq$l-&unbound-slot) 2))	;relocatable address
  (gencode JNE NEAR tagt)
  (gencode JMP tagf))

#+CLOE-Runtime
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
(defun codegen-instance-set (form mode address-offset address-offset-2)
  (let ((k (and (constant-form-p (third form)) (constant-evaluator (third form))))
	(r EAX)
	(m CMP-LOAD)
	(r2 ESI))
    (when (eq mode CMP-LOADI) (setq r ESI r2 EAX m CMP-LOADI))
    (vcompile (second form) CMP-PUSH)
    (cond ((sys::fixnump k)
	   (vcompile (fourth form) m)
	   (gencode POP r2)
	   (gencode MOV r2 INDEX r2 CADDR32 address-offset)
	   (gencode MOV TO r INDEX r2 CADDR32 (ptr+ address-offset-2 (ash k 2))))
	  (t (vcompile (third form) CMP-PUSH)
	     (vcompile (fourth form) m)
	     (gencode POP EBX)
	     (gencode POP r2)
	     (gencode MOV r2 INDEX r2 CADDR32 address-offset)
	     (gencode MOV TO r INDEX r2 EBX CADDR32 address-offset-2)))
    (compile-single-value r mode)))
);End EVAL-WHEN

#+CLOE-Runtime
(define-code-template clos-internals::%instance-set (form mode)
  (codegen-instance-set form mode (ptr- sys::instance$p-data-address sys::instance$k-ptype) sys::instance$k-value-offset))

#+CLOE-Runtime
(define-code-template clos-internals::%funcallable-instance-set (form mode)
  (codegen-instance-set
    form mode
    (ptr+ sys::trampoline$k-values-offset sys::funcallable-instance$p-slots)
    sys::array$k-value-offset))

#+CLOE-Runtime
(define-code-template closi::%mapped-slot-value (form mode)
  (let ((segno (fourth form)) (offset (fifth form)))
    (cond ((or (not (constant-form-p segno)) (not (eql (constant-evaluator segno) 0)))
	   (warn "Yuk: ~S" form)
	   (codegen-function-call form mode))
	  ((or (> space 1) (< time 3) (not (constant-form-p offset)))
	   (vcompile (second form) CMP-PUSH)
	   (vcompile (third form) CMP-PUSH)
	   (vcompile offset CMP-LOADI)
	   (gencode CALL NEAR INDEX EDX CADDR32 sys::sq$l-%mapped-slot-value-load)
	   (compile-1value EAX mode))
	  (t (let ((k (ash (constant-evaluator offset) 2)) (oops (reflabel)) (join (reflabel)))
	     (vcompile (second form) CMP-PUSH)
	     (vcompile (third form) CMP-LOADI)
	     (gencode POP EBX)
	     (gencode MOV ECX EBX)
	     (gencode AND ECX CIMMED sys::ptype$k-mask)
	     (gencode CMP ECX CIMMED sys::instance$k-ptype)
	     (gencode JNE oops)
	     (gencode MOV ECX INDEX ESI CADDR32 (ptr+ sys::structure$k-value-offset k))
	     (gencode TEST CL CIMMED sys::et$k-mask)
	     (gencode JNE oops)
	     (gencode MOV EAX INDEX EBX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
	     (gencode MOV EAX INDEX EAX ECX CADDR32 sys::instance$k-value-offset)
	     (gencode CMP EAX ADDR32 (ash (sys::%sq-ref sys::sq$l-&unbound-slot) 2))
	     (gencode JNE join)
	     (setlabel oops)
	     (gencode PUSH EBX)
	     (gencode PUSH ESI)
	     (gencode MOV ESI CIMMED k)
	     (gencode CALL NEAR INDEX EDX CADDR32 sys::sq$l-%mapped-slot-value-load)
	     (setlabel join)
	     (compile-1value EAX mode))))))


#+CLOE-Runtime
(define-code-template closi::%mapped-slot-store (form mode)
  ;; (%MAPPED-SLOT-STORE INSTANCE MAPPING-TABLE SEGMENT-NUMBER OFFSET VALUE)
  (let* ((segno (fourth form)) (offset (fifth form)) (ok (and (constant-form-p offset) (constant-evaluator offset))))
    (cond ((or (not (constant-form-p segno)) (not (eql (constant-evaluator segno) 0)))
	   (warn "Yuk: ~S" form)
	   (codegen-function-call form mode))
	  ((or (> space 1) (< time 3) (not ok))
	   ;;/*  pushl instance			12(%ebp)
	   ;;/*  pushl mapping-table		8(%ebp)
	   ;;/*  movl value,%eax		%eax
	   ;;/*  movl $offset,%esi		%esi
	   (vcompile (second form) CMP-PUSH)
	   (vcompile (third form) CMP-PUSH)
	   (cond (ok (vcompile (sixth form) CMP-LOAD) (gencode MOV ESI CIMMED (ash ok 2)))
		 (t (vcompile offset CMP-PUSH)
		    (vcompile (sixth form) CMP-LOAD)
		    (gencode POP ESI)))
	   (gencode CALL NEAR INDEX EDX CADDR32 sys::sq$l-%mapped-setf-slot-value-load)
	   (compile-1value EAX mode))
	  (t (let ((oops (reflabel)) (join (reflabel)))
	       (vcompile (second form) CMP-PUSH)
	       (vcompile (third form) CMP-PUSH)
	       (vcompile (sixth form) CMP-LOAD)
	       (gencode POP ESI)		;mapping table
	       (gencode POP EBX)		;instance
	       (gencode MOV ECX EBX)
	       (gencode AND ECX CIMMED sys::ptype$k-mask)
	       (gencode CMP ECX CIMMED sys::instance$k-ptype)
	       (gencode JNE oops)
	       (gencode MOV ECX INDEX ESI CADDR32 (ptr+ sys::structure$k-value-offset (ash ok 2)))
	       (gencode TEST CL CIMMED sys::et$k-mask)
	       (gencode JNE oops)
	       (gencode MOV EBX INDEX EBX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
	       (gencode MOV TO EAX INDEX EBX ECX CADDR32 sys::instance$k-value-offset)
	       (gencode JMP join)
	       (setlabel oops)
	       (gencode PUSH EBX)
	       (gencode PUSH ESI)
	       (gencode MOV ESI CIMMED (ash ok 2))
	       (gencode CALL NEAR INDEX EDX CADDR32 sys::sq$l-%mapped-setf-slot-value-load)
	       (setlabel join)
	       (compile-1value EAX mode))))))


#+CLOE-Runtime
(define-code-template closi::%instance-unbound-init (form mode)
  (vcompile (second form) CMP-LOADI)
  (gencode MOV EDI INDEX EAX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
  (gencode ADD EDI CIMMED sys::instance$k-value-offset)
  (gencode MOV ECX INDEX EAX CADDR32 (ptr- sys::instance$l-size sys::instance$k-ptype))
  (gencode SAR ECX 4)				;it's a fixnum number of bytes (urk!)
  (gencode MOV EAX ADDR32 (ash (sys::%sq-ref sys::sq$l-&unbound-slot) 2))
  (gencode REP)
  (gencode STOSD)
  (edi-invalid)
  (compile-1value ESI mode))


#+CLOE-Runtime
(define-code-template closi::%instance-template-init (form mode)
  ;;(%instance-template-init instance template-or-prototype-instance).
  ;; They had better be the same size.
  (vcompile (second form) CMP-PUSH)		;Destination.
  (vcompile (third form) CMP-PUSH)		;Source (prototype/template).
  (gencode POP EBX)				;Source
  (gencode POP EAX)				;Dest and return value.
  (gencode MOV EDI INDEX EAX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
  (gencode MOV ESI INDEX EBX CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
  (gencode ADD EDI CIMMED sys::instance$k-value-offset)
  (gencode ADD ESI CIMMED sys::instance$k-value-offset)
  (gencode MOV ECX INDEX EAX CADDR32 (ptr- sys::instance$l-size sys::instance$k-ptype))
  (gencode SAR ECX 4)				;it's fixnum number of bytes (!!!)
  (gencode REP)
  (gencode MOVSD)
  (edi-invalid)
  (compile-1value EAX mode))


#+CLOE-Runtime
(define-code-template closi::%instance-block-init (form mode)
  ;;(%instance-block-init instance first-offset &rest initforms)
  ;; like (progn (%instance-set instance first-index initform-1)
  ;;		 (%instance-set instance (1+ first-index) initform-2) ...).
  (let ((instance (second form)) (first-offset (third form)) (initforms (cdddr form)) (koff nil) (nforms 0) (nformsbytes 0))
    (declare (fixnum nforms nformsbytes))
    (cond ((null initforms) `(progn ,instance ,first-offset nil))
	  ((null (cdr initforms)) `(progn (closi::%instance-set ,instance ,first-offset ,(first initforms)) nil))
	  (t (when (constant-form-p first-offset) (setq koff (constant-evaluator first-offset)))
	     (vcompile instance CMP-PUSH)
	     (unless koff (vcompile first-offset CMP-PUSH))
	     (dolist (a (reverse initforms)) (vcompile a CMP-PUSH) (incf nforms))
	     (setq nformsbytes (ash nforms 2))
	     (gencode LEA ESI INDEX ESP CADDR32 0)
	     (cond (koff
		    (gencode MOV EDI INDEX ESP CADDR32 nformsbytes)
		    (gencode MOV EDI INDEX EDI CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
		    (gencode ADD EDI CIMMED (+ sys::instance$k-value-offset (ash koff 2))))
		   (t (gencode MOV EDI INDEX ESP CADDR32 (+ nformsbytes 4))
		      (gencode MOV EDI INDEX EDI CADDR32 (ptr- sys::instance$p-data-address sys::instance$k-ptype))
		      (gencode ADD EDI CIMMED sys::instance$k-value-offset)
		      (gencode ADD EDI INDEX ESP CADDR32 nformsbytes)))
	     (gencode MOV ECX CIMMED nforms)
	     (gencode REP)
	     (gencode MOVSD)
	     (edi-invalid)
	     (gencode LEA ESP INDEX ESP CADDR32 (+ nformsbytes (if koff 4 8)))
	     (compile-1value EDX mode)))))


#+CLOE-Runtime
(IN-PACKAGE 'CLOS-INTERNALS)

;;;		       Standard Instance Protocol
;;;
;;; Standard instances consist of instance information and slots.
;;;
;;; %INSTANCE-REF instance                                       Subprimitive
;;;
;;;    Accesses the specified slot of the instance.  SETF, and, in Genera, LOCF, work
;;;    on this form.
;;;
;;; %INSTANCE-INSTANCE-INFORMATION                               Subprimitive
;;;
;;;    Accesses the instance information for the instance.
;;;

#-(or Genera CLOE-Runtime Minima)
(DEFSTRUCT (INSTANCE
	     (:PREDICATE INSTANCEP)
	     (:CONC-NAME "%INSTANCE-")
	     (:CONSTRUCTOR %ALLOCATE-INSTANCE-INTERNAL (INSTANCE-INFORMATION SLOTS))
	     (:PRINT-FUNCTION PRINT-INSTANCE))
  INSTANCE-INFORMATION
  SLOTS)


#+CLOE-Runtime
(PROGN

;;;Instancep is builtin.  The following isn't (yet):
(DEFMACRO %INSTANCE-INSTANCE-INFORMATION (INSTANCE)
  `(SYSTEM::%Q ,INSTANCE SYSTEM::INSTANCE$K-PTYPE SYSTEM::INSTANCE$P-INSTANCE-INFORMATION))

(DEFMACRO %SET-INSTANCE-INSTANCE-INFORMATION (INSTANCE NEW-II)
  `(SYSTEM::%SET-Q ,INSTANCE SYSTEM::INSTANCE$K-PTYPE SYSTEM::INSTANCE$P-INSTANCE-INFORMATION 0 ,NEW-II))

(DEFSETF %INSTANCE-INSTANCE-INFORMATION %SET-INSTANCE-INSTANCE-INFORMATION)

(DEFUN %INSTANCE-REF (INSTANCE INDEX)
  (%INSTANCE-REF INSTANCE INDEX))

(DEFUN %INSTANCE-SET (INSTANCE INDEX VALUE)
  (%INSTANCE-SET INSTANCE INDEX VALUE))

(DEFSETF %INSTANCE-REF %INSTANCE-SET)

(DEFUN %INSTANCE-SLOT-BOUNDP (INSTANCE INDEX)
  (%INSTANCE-SLOT-BOUNDP INSTANCE INDEX))

(SETF (GET '%INSTANCE-REF 'BOUNDP-PREDICATE) '%INSTANCE-SLOT-BOUNDP)

);;;NGORP #+CLOE-Runtime

;;; %INSTANCE-REF is built-in for Genera.

#+Minima (PROGN

(DEFUN INSTANCEP (X)
  (INSTANCEP X))

(DEFUN %INSTANCE-REF (INSTANCE INDEX)
  (%INSTANCE-REF INSTANCE INDEX))

(DEFUN (SETF %INSTANCE-REF) (VALUE INSTANCE INDEX)
  (SETF (%INSTANCE-REF INSTANCE INDEX) VALUE))

)

#-(OR Genera Minima)
(DEFUN SLOT-UNBOUND-FROM-INDEX (INSTANCE INDEX)
  #+(OR Genera CLOE-Runtime) (DECLARE (DBG::ERROR-REPORTER))
  (LET ((CLASS (CLASS-OF INSTANCE)))
    (DOLIST (SLOT (CLASS-SLOTS CLASS) (CERROR "Return NIL." "Can't find which slot is at index ~D in ~S!" INDEX INSTANCE))
      (WHEN (EQL INDEX (SLOT-DEFINITION-LOCATION SLOT))
	(RETURN (VALUES (SLOT-UNBOUND CLASS INSTANCE (SLOT-DEFINITION-NAME SLOT))))))))

#-(OR CLOE-Runtime Genera Minima)
(DEFUN %INSTANCE-REF (INSTANCE INDEX)
  (LET ((ANS (SVREF (%INSTANCE-SLOTS INSTANCE) INDEX)))
    (IF (EQ ANS *UNBOUND-INSTANCE-SLOT*)
	(SLOT-UNBOUND-FROM-INDEX INSTANCE INDEX)
	ANS)))

#-(OR CLOE-Runtime Genera Minima)			;We hand-code in cloe
(DECLAIM (INLINE %INSTANCE-SET))

#-(OR CLOE-Runtime Genera Minima)
(DEFUN %INSTANCE-SET (INSTANCE INDEX VALUE)
  (SETF (SVREF (%INSTANCE-SLOTS INSTANCE) INDEX) VALUE))

#-(OR CLOE-Runtime Genera Minima)
(DEFSETF %INSTANCE-REF %INSTANCE-SET)

#+|3600|
(DEFSUBST %INSTANCE-INSTANCE-INFORMATION (INSTANCE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (SYS:%MAKE-POINTER SYS:DTP-ARRAY (SYS:%P-CONTENTS-AS-LOCATIVE-OFFSET INSTANCE 0)))

#+IMACH
(DEFSUBST %INSTANCE-INSTANCE-INFORMATION (INSTANCE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (SYS:%SET-TAG
    (SYS:%POINTER-PLUS
      (SYS:%MEMORY-READ INSTANCE :CYCLE-TYPE SYS:%MEMORY-HEADER :SET-CDR-NEXT T)
      -3)
    SYS:DTP-ARRAY))

#+Minima
(DEFSUBST %INSTANCE-INSTANCE-INFORMATION (INSTANCE)
  (IVORY:%SET-TAG
    (IVORY:%POINTER-PLUS
      (IVORY:%MEMORY-READ INSTANCE :CYCLE-TYPE 'IVORY:HEADER)
      -2)
    (IVORY:DATA-TYPE 'IVORY:INSTANCE)))

#-(OR Genera Minima)
(DEFVAR *PRINT-INSTANCE-OVERRIDE* NIL)

#-(OR Genera Minima)
(DEFUN PRINT-INSTANCE (INST STREAM LEVEL)
  ;;This, obviously, is not a hook to make the printer print instances by
  ;; any sort of dispatching.  It is a stopgap to keep printing them from losing.
  (LET ((*PRINT-LEVEL* (AND *PRINT-LEVEL* (- *PRINT-LEVEL* LEVEL)))
	(II (%INSTANCE-INSTANCE-INFORMATION INST)))
    (COND ((AND *CLOS-INITIALIZED-P* (NOT *PRINT-INSTANCE-OVERRIDE*))
	   (LET ((CLS (%INSTANCE-INFORMATION-CLASS II)))
	     (COND ((AND (TYPEP CLS 'CLASS) (EQ (CLASS-PROTOTYPE CLS) INST))
		    (PRINT-UNREADABLE-OBJECT (INST STREAM :TYPE T :IDENTITY t)
		      (WRITE-STRING "(Prototype Instance)" STREAM)))
		   ((eq cls t)
		    (print-unreadable-object (inst stream :type nil :identity t)
		      (prin1 'eql-dispatch-instance stream)))
		   (t (PRINT-OBJECT INST STREAM)))))
	  (T (PRINT-UNREADABLE-OBJECT (INST STREAM :TYPE NIL :IDENTITY T)
	       (LET ((TYPENAME NIL))
		 (IF (AND (TYPEP II 'CLASS-INSTANCE-INFORMATION)
			  (OR (AND (SETQ TYPENAME (%CLASS-INSTANCE-INFORMATION-CLASS-NAME II))
				   (SYMBOLP TYPENAME))
			      (IGNORE-ERRORS
				(AND (SETQ TYPENAME (%CLASS-INSTANCE-INFORMATION-CLASS II))
				     (SYMBOLP (SETQ TYPENAME (CLASS-NAME TYPENAME)))))))
		     (PRIN1 TYPENAME STREAM)
		     (WRITE-STRING "INSTANCE" STREAM))))))))

;;;		     Funcallable Instance Protocol
;;;
;;; A funcallable instance is an instance which is passed a reference to itself as
;;; the extra argument.
;;;
;;; %FUNCALLABLE-INSTANCE-REF funcallable-instance offset        Subprimitive
;;;
;;;    Accesses the specified slot of the funcallable-instance.  SETF, and, in
;;;    Genera, LOCF, work on this form.
;;;
;;;                                                              Subprimitive
;;; %FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION funcallable-instance
;;;
;;;    Accesses the instance information of the funcallable-instance.
;;;
;;; %FUNCALLABLE-INSTANCE-FUNCTION                               Subprimitive
;;;
;;;    The function which will be called with an extra argument when the funcallable
;;;    instance is used as a function.  SETF may be used, LOCF may not.
;;;
;;; FUNCALLABLE-INSTANCE-FROM-EXTRA-ARGUMENT                     Function
;;;
;;;    Returns the funcallable instance associated with the extra argument.
;;;
;;;

#+IMACH
(SYS:DEFSTORAGE (FUNCALLABLE-INSTANCE :STRUCTURE NIL :FORWARDABLE NIL)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT)
  (%FUNCALLABLE-INSTANCE-FUNCTION))

#+IMACH
(SYS:DEFSTORAGE (FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT :BACKWARDS T :STRUCTURE NIL)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-NAME)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-FUNCALLABLE-INSTANCE)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-HEADER))

#+|3600|
(SYS:DEFSTORAGE (FUNCALLABLE-INSTANCE)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT)
  (%FUNCALLABLE-INSTANCE-FUNCTION))

#+|3600|
(SYS:DEFSTORAGE (FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT SYS:BACKWARDS)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-NAME)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-FUNCALLABLE-INSTANCE)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-HEADER))

#+Minima
(MINIMA-INTERNALS::DEFSTORAGE (FUNCALLABLE-INSTANCE :STRUCTURE NIL :FORWARDABLE NIL)
  (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT)
  (%FUNCALLABLE-INSTANCE-FUNCTION))

#+Minima
(DEFUN FUNCALLABLE-INSTANCE-P (OBJECT)
  (AND (IVORY::TYPE-MEMBER OBJECT (IVORY:DATA-TYPE 'IVORY:EXTRA-ARG-FUNCTION))
       (EQ (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
	     (IVORY:%TAG (IVORY:%MEMORY-READ OBJECT :SET-CDR-NEXT NIL))
	     IVORY::TAG
	     IVORY::LEXICAL-CLOSURE-SUBTYPE)
	   'IVORY::FUNCALLABLE-INSTANCE)))

#+Genera
(DEFSUBST %DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT (EXTRA-ARGUMENT)
  (SYS:%MAKE-POINTER
    SYS:DTP-INSTANCE
    (LOCF (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-HEADER EXTRA-ARGUMENT))))

#+Genera
(DEFSUBST %FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE (DISPATCH-INSTANCE)
  (%INSTANCE-REF DISPATCH-INSTANCE 1))

#+Genera
(DEFSUBST %FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION (FUNCALLABLE-INSTANCE)
  (%INSTANCE-INSTANCE-INFORMATION
    (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
      (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT FUNCALLABLE-INSTANCE))))

#+Minima
(DEFSUBST %DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT (EXTRA-ARGUMENT)
  (IVORY:%SET-TAG EXTRA-ARGUMENT (IVORY:DATA-TYPE 'IVORY::INSTANCE)))

#+Minima
(DEFSUBST %FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE (DISPATCH-INSTANCE)
  (%INSTANCE-REF DISPATCH-INSTANCE 1))

#+Minima
(DEFSUBST (SETF %FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE)
	  (FUNCALLABLE-INSTANCE DISPATCH-INSTANCE)
  (SETF (%INSTANCE-REF DISPATCH-INSTANCE 1) FUNCALLABLE-INSTANCE))

#+Minima
(DEFSUBST %FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION (FUNCALLABLE-INSTANCE)
  (%INSTANCE-INSTANCE-INFORMATION
    (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
      (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT FUNCALLABLE-INSTANCE))))

#+CLOE-Runtime
(LISP:DEFSTRUCT (FUNCALLABLE-INSTANCE
		  (:PREDICATE NIL)
		  (:CONC-NAME "%FUNCALLABLE-INSTANCE-")
		  :FUNCALLABLE
		  (:AREA ((AREA AREA) SYS:AKIND$K-DEFAULT))
		  (:CONSTRUCTOR %ALLOCATE-FUNCALLABLE-INSTANCE-INTERNAL
		   (INSTANCE-INFORMATION SLOTS &OPTIONAL (AREA SYS:AKIND$K-DEFAULT)))
		  (:PRINT-FUNCTION PRINT-FUNCALLABLE-INSTANCE)
		  )
  INSTANCE-INFORMATION
  SLOTS
  (FUNCTION #'HANDLE-START-DISPATCH-MISS :TYPE COMPILED-FUNCTION))

#+CLOE-Runtime
(SYSTEM::SET-STRUCTURE-LOAD-FORM-FUNCTION 'FUNCALLABLE-INSTANCE 'MAKE-LOAD-FORM)	;Symbol so trivially patchable...

#+CLOE-Runtime
(DEFSUBST %FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT (FUNCALLABLE-INSTANCE)
  FUNCALLABLE-INSTANCE)

#+CLOE-Runtime
(DEFSUBST %DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT (EXTRA-ARGUMENT)
  EXTRA-ARGUMENT)

#+CLOE-Runtime
(DEFUN PRINT-FUNCALLABLE-INSTANCE (INST STREAM LEVEL)
  (LET ((TYPE (LET ((II (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION INST)))
		(AND (TYPEP II 'CLASS-INSTANCE-INFORMATION)
		     (LET ((TN (%CLASS-INSTANCE-INFORMATION-CLASS-NAME II)))
		       (OR (AND (SYMBOLP TN) TN)
			   (IGNORE-ERRORS
			     (AND (TYPEP II 'CLASS-INSTANCE-INFORMATION)
				  (SETQ TN (%CLASS-INSTANCE-INFORMATION-CLASS II))
				  (SYMBOLP (SETQ TN (CLASS-NAME TN)))
				  TN))
			   "#"))))))
    (PRINT-UNREADABLE-OBJECT (INST STREAM :IDENTITY T)
      (FUNCALL (IF *PRINT-ESCAPE* #'PRIN1 #'PRINC)
	       (IF (EQ TYPE 'STANDARD-GENERIC-FUNCTION) 'STANDARD-GENERIC-FUNCTION 'FUNCTION)
	       STREAM)
      (WRITE-CHAR #\Space STREAM)
      (FUNCALL (IF *PRINT-ESCAPE* #'PRIN1 #'PRINC)
	       (IF (EQ TYPE 'STANDARD-GENERIC-FUNCTION) 
		   (OR (IGNORE-ERRORS (GENERIC-FUNCTION-NAME INST))
		       (IGNORE-ERRORS (BOOTSTRAP-FSLOT-VALUE INST 'NAME))
		       "???")
		   TYPE)
	       STREAM))))

#+(OR Genera Minima)
(DEFSUBST %FUNCALLABLE-INSTANCE-REF (FUNCALLABLE-INSTANCE SLOT)
  (%INSTANCE-REF (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
		   (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT FUNCALLABLE-INSTANCE))
		 SLOT))

#+(AND CLOE-Runtime NOT-YET)
(DEFUN %FUNCALLABLE-INSTANCE-REF (FUNCALLABLE-INSTANCE SLOT)
  (%FUNCALLABLE-INSTANCE-REF FUNCALLABLE-INSTANCE SLOT))

#-(OR Genera Minima (AND CLOE-Runtime NOT-YET))
(DEFUN %FUNCALLABLE-INSTANCE-REF (FUNCALLABLE-INSTANCE SLOT)
  (LET ((ANS (SVREF (%FUNCALLABLE-INSTANCE-SLOTS FUNCALLABLE-INSTANCE) SLOT)))
    (IF (EQ ANS *UNBOUND-INSTANCE-SLOT*)
	(SLOT-UNBOUND-FROM-INDEX FUNCALLABLE-INSTANCE SLOT)
	ANS)))

#+Minima
(DEFSUBST (SETF %FUNCALLABLE-INSTANCE-REF) (VALUE FUNCALLABLE-INSTANCE SLOT)
  (SETF (%INSTANCE-REF (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
			 (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT FUNCALLABLE-INSTANCE))
		       SLOT)
	VALUE))

#+Minima
(DEFSUBST (LOCF %FUNCALLABLE-INSTANCE-REF) (FUNCALLABLE-INSTANCE SLOT)
  (LOCF (%INSTANCE-REF (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
			 (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT FUNCALLABLE-INSTANCE))
		       SLOT)))

#+CLOE-Runtime
(DEFUN %FUNCALLABLE-INSTANCE-SET (FUNCALLABLE-INSTANCE SLOT VALUE)
  (%FUNCALLABLE-INSTANCE-SET FUNCALLABLE-INSTANCE SLOT VALUE))

#-(OR Genera CLOE-Runtime Minima)
(DECLAIM (INLINE %FUNCALLABLE-INSTANCE-SET))

#-(OR Genera Minima CLOE-Runtime)
(DEFUN %FUNCALLABLE-INSTANCE-SET (FUNCALLABLE-INSTANCE SLOT VALUE)
  (SETF (SVREF (%FUNCALLABLE-INSTANCE-SLOTS FUNCALLABLE-INSTANCE) SLOT) VALUE))

#-(OR Genera Minima)
(DEFSETF %FUNCALLABLE-INSTANCE-REF %FUNCALLABLE-INSTANCE-SET)

#+CLOE-Runtime
(DEFUN %FUNCALLABLE-INSTANCE-SLOT-BOUNDP (INSTANCE INDEX)
  (%FUNCALLABLE-INSTANCE-SLOT-BOUNDP INSTANCE INDEX))

#-(OR Genera CLOE-Runtime Minima)
(DECLAIM (INLINE %FUNCALLABLE-INSTANCE-SLOT-BOUNDP))

#-(OR Genera Minima CLOE-Runtime)
(DEFUN %FUNCALLABLE-INSTANCE-SLOT-BOUNDP (INSTANCE INDEX)
  (NOT (EQ (SVREF (%FUNCALLABLE-INSTANCE-SLOTS INSTANCE) INDEX) *UNBOUND-INSTANCE-SLOT*)))

#-(OR Genera Minima)
(SETF (GET '%FUNCALLABLE-INSTANCE-REF 'BOUNDP-PREDICATE) '%FUNCALLABLE-INSTANCE-SLOT-BOUNDP)

(DEFSUBST FUNCALLABLE-INSTANCE-FROM-GENERIC-SELECTOR (EXTRA-ARGUMENT)
  #+Genera (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT-FUNCALLABLE-INSTANCE EXTRA-ARGUMENT)
  #+Minima (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE
	     (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT EXTRA-ARGUMENT))
  #-(OR Genera Minima) EXTRA-ARGUMENT)

#-(OR Genera Minima)
(DEFTYPE GENERIC-FUNCTION-SELECTOR ()
  'FUNCALLABLE-INSTANCE)

;;;			    General Objects
;;;
;;; %INSTANCE-INFORMATION                                        Subprimitive
;;;
;;;    Returns the instance information for the object.  SETF may be used.


;;; This information is all that's needed for a dispatch table.
;;; NOTE!  This structure is known about by the CLOE kernel (see rclhead.d).
#-(OR Genera Minima)
(DEFSTRUCT-SIMPLE (INSTANCE-INFORMATION
		    (:CONC-NAME "%INSTANCE-INFORMATION-")
		    (:CONSTRUCTOR
		      MAKE-INSTANCE-INFORMATION-INTERNAL
		      (DISPTAB DISPATCH-MASK DISPATCH-ADDRESS))
		    (:PRINT-FUNCTION PRINT-INSTANCE-INFORMATION))
  ;; These slots are known about by a lot of things
  (SIZE 3 :TYPE FIXNUM)				;1+ the number of instance variables
  (DISPATCH-MASK 0 :TYPE FIXNUM)		;Logand with the selector
  ;; Address of the first entry in the dispatch table.
  (DISPATCH-ADDRESS NIL :TYPE DISPATCH-TABLE-ADDRESS)
  ;; T for an EQL-DISPATCH instance, NIL while being initialized, or a class object.
  (CLASS T)
  ;; End of magic locations
  (DISPTAB NIL :TYPE DISPATCH-TABLE)		;Without locatives we need this too.
  )

;;; In Genera, this structure must be implemented as a vector to keep the microcode happy.
;;; We also want it to print prettily, so we use a named array.
#+(OR Genera Minima)
(DEFSTRUCT-SIMPLE (INSTANCE-INFORMATION
		    (:CONC-NAME "%INSTANCE-INFORMATION-")
		    (:CONSTRUCTOR
		      MAKE-INSTANCE-INFORMATION-INTERNAL
		      (DISPTAB DISPATCH-MASK DISPATCH-ADDRESS))
		    (:COPIER NIL) (:PREDICATE NIL)
		    (:PRINT-FUNCTION PRINT-INSTANCE-INFORMATION))
  ;; These slots are known about by the microcode, among other things.
  (SIZE 3 :TYPE FIXNUM)				;1+ the number of instance variables
  (DISPATCH-MASK 0 :TYPE FIXNUM)		;Logand with the selector
  ;; Address of the first entry in the dispatch table.
  (DISPATCH-ADDRESS NIL :TYPE DISPATCH-TABLE-ADDRESS)
  ;; T for an EQL-DISPATCH instance, NIL while being initialized, or a class object.
  (CLASS T)
  ;; End of magic locations
  (DISPTAB NIL :TYPE DISPATCH-TABLE)		;Without locatives we need this too.
  )

(DEFUN PRINT-INSTANCE-INFORMATION (ME STREAM DEPTH)
  (DECLARE (IGNORE DEPTH))
  (PRINT-UNREADABLE-OBJECT (ME STREAM :TYPE T :IDENTITY T)
    (FORMAT STREAM "~s"
	    (%CLASS-INSTANCE-INFORMATION-CLASS-NAME ME))))

(DEFUN MAKE-CLOS-DISPATCH-TABLE (MISS-HANDLER)
  (MAKE-DISPATCH-TABLE
    8. NIL
    MISS-HANDLER
    (PROGN
      #+(OR IMACH Minima) (HANDLER-PC-NO-ENTRY MISS-HANDLER)
      #-(OR IMACH Minima) MISS-HANDLER)))

(DEFUN MAKE-INSTANCE-INFORMATION (MISS-HANDLER)
  (LET ((DISPATCH-TABLE (MAKE-CLOS-DISPATCH-TABLE MISS-HANDLER)))
    (MAKE-INSTANCE-INFORMATION-INTERNAL
      DISPATCH-TABLE
      (DISPATCH-TABLE-MASK DISPATCH-TABLE) (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE))))

(DEFUN %INSTANCE-INFORMATION-DISPATCH-TABLE (INFORMATION)
  #+Genera
  (COMPILER:%ERROR-WHEN (EQ (AREF INFORMATION 0) 'FLAVOR:FLAVOR)
    (RETURN-FROM %INSTANCE-INFORMATION-DISPATCH-TABLE
      (FLAVOR:FLAVOR-HANDLER-TABLE INFORMATION)))
  (%INSTANCE-INFORMATION-DISPTAB INFORMATION))

(DEFUN (SETF %INSTANCE-INFORMATION-DISPATCH-TABLE) (DISPATCH-TABLE INFORMATION)
  (WITH-NO-OTHER-PROCESSES
    #+Genera
    (IF (EQ (AREF INFORMATION 0) 'FLAVOR:FLAVOR)
	(SETF (FLAVOR:FLAVOR-HANDLER-TABLE INFORMATION) DISPATCH-TABLE)
	(SETF (%INSTANCE-INFORMATION-DISPTAB INFORMATION) DISPATCH-TABLE))
    #-Genera
    (SETF (%INSTANCE-INFORMATION-DISPTAB INFORMATION) DISPATCH-TABLE)
    (SETF (%INSTANCE-INFORMATION-DISPATCH-ADDRESS INFORMATION)
	  (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE))
    (SETF (%INSTANCE-INFORMATION-DISPATCH-MASK INFORMATION)
	  (DISPATCH-TABLE-MASK DISPATCH-TABLE))
    DISPATCH-TABLE))

(DEFUN REHASH-INFORMATION-DISPATCH-TABLE (INFORMATION &OPTIONAL FORCE)
  #+Genera (DECLARE (VALUES REHASHED-P))
  (WITH-NO-OTHER-PROCESSES
    (LET* ((OLD-DISPATCH-TABLE (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION))
	   (NEW-DISPATCH-TABLE (REHASH-DISPATCH-TABLE OLD-DISPATCH-TABLE FORCE)))
      (UNLESS (OR (NULL NEW-DISPATCH-TABLE)
		  (EQ OLD-DISPATCH-TABLE NEW-DISPATCH-TABLE))
	(SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION) NEW-DISPATCH-TABLE)))))

(DEFSUBST INSERT-IN-INFORMATION-DISPATCH-TABLE (INFORMATION SELECTOR HANDLER EXTRA-ARGUMENT)
  (WITH-NO-OTHER-PROCESSES
    (LET* ((OLD-DISPATCH-TABLE (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION))
	   (NEW-DISPATCH-TABLE
	     (INSERT-IN-DISPATCH-TABLE OLD-DISPATCH-TABLE SELECTOR HANDLER EXTRA-ARGUMENT)))
      (UNLESS (EQ OLD-DISPATCH-TABLE NEW-DISPATCH-TABLE)
	(SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION) NEW-DISPATCH-TABLE)))))

(DEFSUBST INFORMATION-DISPATCH-TABLE-SEARCH (INFORMATION SELECTOR)
  #+Genera (DECLARE (VALUES FOUNDP CELL))
  (LET* ((DISPATCH-TABLE (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION)))
    (WITH-NO-OTHER-PROCESSES
      (MULTIPLE-VALUE-BIND (FOUNDP CELL NEW-DISPATCH-TABLE)
	  (DISPATCH-TABLE-SEARCH DISPATCH-TABLE SELECTOR)
	(UNLESS (EQ DISPATCH-TABLE NEW-DISPATCH-TABLE)
	  (SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION)
		NEW-DISPATCH-TABLE))
	(VALUES FOUNDP CELL NEW-DISPATCH-TABLE)))))

(DEFSUBST INSTANCE-DISPATCH-TABLE-SEARCH (INSTANCE SELECTOR)
  #+Genera (DECLARE (VALUES FOUNDP CELL))
  (INFORMATION-DISPATCH-TABLE-SEARCH (%INSTANCE-INFORMATION INSTANCE) SELECTOR))



;;;			       Allocation
;;;
;;; %ALLOCATE-INSTANCE instance-information
;;;
;;; %ALLOCATE-FUNCALLABLE-INSTANCE instance-information

#+Genera
(DEFUN %ALLOCATE-INSTANCE (INSTANCE-INFORMATION &OPTIONAL AREA)
  (LET* ((SIZE (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION))
	 (INSTANCE (SI:%MAKE-STRUCTURE SYS:DTP-INSTANCE SYS:DTP-HEADER-P
				       SYS:%HEADER-TYPE-INSTANCE
				       (PROGN
					 #+|3600| INSTANCE-INFORMATION
					 #+IMACH (SYS:%POINTER-PLUS INSTANCE-INFORMATION 3))
				       (OR AREA SYS:*DEFAULT-CONS-AREA*) SIZE)))
    (SYS:%BLOCK-STORE-TAG-AND-POINTER
      (SYS:%POINTER-PLUS INSTANCE 1)
      (1- SIZE)
      SYS:DTP-NULL
      INSTANCE
      0)
    INSTANCE))

#+Minima-Runtime
(MINIMA-INTERNALS::DEFUN-SAFEGUARDED %ALLOCATE-INSTANCE (INSTANCE-INFORMATION &OPTIONAL (STORAGE-AREA T))
  (LET* ((SIZE (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION))
	 (RESULT (IVORY:%SET-TAG (IF (EQ STORAGE-AREA T)
				     (IVORY:%ALLOCATE-PRIMARY-BLOCK T SIZE)
				     (IVORY:%ALLOCATE-SECONDARY-BLOCK STORAGE-AREA SIZE))
				 (IVORY:DATA-TYPE 'IVORY:INSTANCE))))
    (IVORY:%BLOCK-WRITE 1 (IVORY::MAKE-HEADER-P IVORY:INSTANCE (IVORY:%POINTER-PLUS INSTANCE-INFORMATION 2)))
    ;; CDR-NIL in the last word to help the GC.
    (WHEN (< 1 SIZE)
      (IVORY::%P-STORE-CDR-CODE (IVORY:%POINTER-PLUS RESULT (1- SIZE))
				(IVORY::CDR-CODE 'IVORY::NIL)))
    RESULT))

#+CLOE-Runtime
(DEFUN %ALLOCATE-INSTANCE (INSTANCE-INFORMATION &OPTIONAL (AREA SYS::AKIND$K-DEFAULT))
  (LET ((INSTANCE (%INSTANCE-UNBOUND-INIT
		    (SYS::MAKEINSTANCE
		      SYS::SPACE$K-STRUCTURE AREA
		      (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION)))))
    (SETF (%INSTANCE-INSTANCE-INFORMATION INSTANCE) INSTANCE-INFORMATION)
    INSTANCE))

#-(OR CLOE-Runtime Genera Minima)
(DEFUN %ALLOCATE-INSTANCE (INSTANCE-INFORMATION)
  (%ALLOCATE-INSTANCE-INTERNAL
    INSTANCE-INFORMATION
    (MAKE-ARRAY (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION)
		:ELEMENT-TYPE T
		:INITIAL-ELEMENT *UNBOUND-INSTANCE-SLOT*)))

;;; %ALLOCATE-INSTANCE-COPY makes an exact copy of the template instance, including
;;; unbound slots.
#+IMACH
(DEFUN %ALLOCATE-INSTANCE-COPY
       (TEMPLATE &OPTIONAL (AREA SYS:*DEFAULT-CONS-AREA*))
  (SETQ TEMPLATE (SYS:FOLLOW-STRUCTURE-FORWARDING TEMPLATE))
  (LET ((SIZE (%INSTANCE-INFORMATION-SIZE (%INSTANCE-INSTANCE-INFORMATION TEMPLATE))))
    (SYS:%SET-TAG
      (PROG1
	(IF (EQ AREA :STACK)
	    (SI:ALLOCATE-DATA-STACK SIZE)
	    (SYS:%ALLOCATE-STRUCTURE-BLOCK AREA SIZE))
	(WHEN (PLUSP SIZE)
	  (SYS:WITH-BLOCK-REGISTERS (2)
	    (SETF (SYS:%BLOCK-REGISTER 2) TEMPLATE)
	    (SYS:UNROLL-BLOCK-FORMS (SIZE 8)
	      (SYS:%BLOCK-WRITE
		1
		(SYS:%BLOCK-READ 2 :CYCLE-TYPE SYS:%MEMORY-SCAVENGE :SET-CDR-NEXT NIL))))))
      SYS:DTP-INSTANCE)))

#+Minima-Runtime
(MINIMA-INTERNALS::DEFUN-SAFEGUARDED %ALLOCATE-INSTANCE-COPY (TEMPLATE &OPTIONAL (STORAGE-AREA T))
  (LET* ((SIZE (%INSTANCE-INFORMATION-SIZE (%INSTANCE-INSTANCE-INFORMATION TEMPLATE)))
	 (RESULT (IVORY:%SET-TAG (IF (EQ STORAGE-AREA T)
				     (IVORY:%ALLOCATE-PRIMARY-BLOCK T SIZE)
				     (IVORY:%ALLOCATE-SECONDARY-BLOCK STORAGE-AREA SIZE))
				 (IVORY:DATA-TYPE 'IVORY:INSTANCE))))
    (IVORY::SAVING-REGISTERS-FOR-EFFECT ((IVORY::BAR :BAR 2))
      (SETF (IVORY:BLOCK-REGISTER 2) TEMPLATE)
      (LOOP REPEAT SIZE DO
	(IVORY:%BLOCK-WRITE 1 (IVORY:%BLOCK-READ 2 :CYCLE-TYPE 'IVORY:SCAVENGE :SET-CDR-NEXT NIL))))
    RESULT))

#+|3600|
(DEFUN %ALLOCATE-INSTANCE-COPY
       (TEMPLATE &OPTIONAL (AREA SYS:*DEFAULT-CONS-AREA*))
  (SETQ TEMPLATE (SYS:FOLLOW-STRUCTURE-FORWARDING TEMPLATE))
  (LET* ((INSTANCE-INFORMATION (%INSTANCE-INSTANCE-INFORMATION TEMPLATE))
	 (SIZE (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION))
	 (INSTANCE (SI:%MAKE-STRUCTURE SYS:DTP-INSTANCE SYS:DTP-HEADER-P
				       SYS:%HEADER-TYPE-INSTANCE
				       (PROGN
					 #+|3600| INSTANCE-INFORMATION
					 #+IMACH (SYS:%POINTER-PLUS INSTANCE-INFORMATION 3))
				       (OR AREA SYS:*DEFAULT-CONS-AREA*) SIZE)))
    (SYS:%BLOCK-GC-COPY
      (SYS:%POINTER-PLUS TEMPLATE 1)
      (SYS:%POINTER-PLUS INSTANCE 1)
      (1- SIZE))
    INSTANCE))

#+CLOE-Runtime
(DEFUN %ALLOCATE-INSTANCE-COPY (TEMPLATE &OPTIONAL (AREA SYS::AKIND$K-DEFAULT))
  (LET ((INSTANCE (%INSTANCE-TEMPLATE-INIT
		    (SYS::MAKEINSTANCE
		      SYS::SPACE$K-STRUCTURE AREA
		      (%INSTANCE-INFORMATION-SIZE (%INSTANCE-INSTANCE-INFORMATION TEMPLATE)))
		    TEMPLATE)))
    (SETF (%INSTANCE-INSTANCE-INFORMATION INSTANCE) (%INSTANCE-INSTANCE-INFORMATION TEMPLATE))
    INSTANCE))

#-(OR CLOE-Runtime Genera Minima)
(DEFUN %ALLOCATE-INSTANCE-COPY (TEMPLATE)
  (%ALLOCATE-INSTANCE-INTERNAL
    (%INSTANCE-INSTANCE-INFORMATION TEMPLATE)
    (COPY-SEQ (%INSTANCE-SLOTS TEMPLATE))))

#+IMACH
(DEFUN %MAKE-FUNCALLABLE-INSTANCE (SLOTS FUNCALL-HANDLER
				   &OPTIONAL (AREA SYS:*DEFAULT-CONS-AREA*))
  (COMPILER:%ERROR-WHEN (NULL AREA)
    (SETQ AREA SYS:*DEFAULT-CONS-AREA*))
  (SI:%SET-CDR-CODE-NIL (LOCF FUNCALL-HANDLER))
  (SYS:%SET-TAG
    (PROG1
      (SYS:%ALLOCATE-LIST-BLOCK AREA 2)
      (SYS:%BLOCK-WRITE 1 SLOTS)
      (SYS:%BLOCK-WRITE 1 FUNCALL-HANDLER))
    SYS:DTP-LEXICAL-CLOSURE))

#+Minima
(DEFUN %MAKE-FUNCALLABLE-INSTANCE (SLOTS FUNCALL-HANDLER &OPTIONAL (AREA T))
  (IVORY:%SET-CDR-CODE-NIL (LOCF FUNCALL-HANDLER))
  (IVORY:%SET-TAG
    (PROG1
      (IF (EQ AREA T)
	  (IVORY:%ALLOCATE-PRIMARY-BLOCK T 2)
	  (IVORY:%ALLOCATE-SECONDARY-BLOCK AREA 2))
      (IVORY:%BLOCK-WRITE 1 SLOTS)
      (IVORY:%BLOCK-WRITE 1 FUNCALL-HANDLER))
    (IVORY:DATA-TYPE 'IVORY:EXTRA-ARG-FUNCTION)))

#+|3600|
(DEFUN %MAKE-FUNCALLABLE-INSTANCE (ENVIRONMENT FUNCTION
				   &OPTIONAL (AREA SYS:*DEFAULT-CONS-AREA*))
  (SYS:%MAKE-POINTER SYS:DTP-LEXICAL-CLOSURE (SYS:LIST-IN-AREA AREA ENVIRONMENT FUNCTION)))

#+Genera
(DEFUN %ALLOCATE-FUNCALLABLE-INSTANCE (INFORMATION &OPTIONAL AREA)
  (LET ((DISPATCH-INSTANCE (%ALLOCATE-INSTANCE INFORMATION AREA)))
    (SETF (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE DISPATCH-INSTANCE)
	  (%MAKE-FUNCALLABLE-INSTANCE
	    (SYS:%MAKE-POINTER-OFFSET SYS:DTP-GENERIC-FUNCTION DISPATCH-INSTANCE 2)
	    #'HANDLE-START-DISPATCH-MISS
	    AREA))))

#+Genera
(DEFUN %ALLOCATE-FUNCALLABLE-INSTANCE-COPY (TEMPLATE &OPTIONAL (AREA SYS:*DEFAULT-CONS-AREA*))
  (LET ((DISPATCH-INSTANCE (%ALLOCATE-INSTANCE-COPY
			     (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
			       (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT TEMPLATE)))))
    (SETF (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE DISPATCH-INSTANCE)
	  (%MAKE-FUNCALLABLE-INSTANCE
	    (SYS:%MAKE-POINTER-OFFSET
	      SYS:DTP-GENERIC-FUNCTION
	      (%ALLOCATE-INSTANCE-COPY DISPATCH-INSTANCE AREA)
	      2)
	    #'HANDLE-START-DISPATCH-MISS
	    AREA))))

#+Minima
(DEFUN %ALLOCATE-FUNCALLABLE-INSTANCE (INFORMATION &OPTIONAL (AREA T))
  (LET ((DISPATCH-INSTANCE (%ALLOCATE-INSTANCE INFORMATION AREA)))
    (SETF (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE DISPATCH-INSTANCE)
	  (%MAKE-FUNCALLABLE-INSTANCE
	    (IVORY:%SET-TAG DISPATCH-INSTANCE (IVORY:DATA-TYPE 'IVORY::GENERIC-FUNCTION))
	    #'HANDLE-START-DISPATCH-MISS
	    AREA))))

#+Minima
(DEFUN %ALLOCATE-FUNCALLABLE-INSTANCE-COPY (TEMPLATE &OPTIONAL (AREA T))
  (LET ((DISPATCH-INSTANCE (%ALLOCATE-INSTANCE-COPY
			     (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
			       (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT TEMPLATE))
			     AREA)))
    (SETF (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE DISPATCH-INSTANCE)
	  (%MAKE-FUNCALLABLE-INSTANCE
	    (IVORY:%SET-TAG DISPATCH-INSTANCE (IVORY:DATA-TYPE 'IVORY::GENERIC-FUNCTION))
	    #'HANDLE-START-DISPATCH-MISS
	    AREA))))

#+CLOE-Runtime
(DEFUN %ALLOCATE-FUNCALLABLE-INSTANCE
       (INFORMATION &OPTIONAL (AREA SYS::AKIND$K-DEFAULT))
  (LET ((FI (%ALLOCATE-FUNCALLABLE-INSTANCE-INTERNAL
	      INFORMATION
	      (MAKE-ARRAY (%INSTANCE-INFORMATION-SIZE INFORMATION)
			  :ELEMENT-TYPE T
			  :INITIAL-ELEMENT *UNBOUND-INSTANCE-SLOT*)
	      AREA)))
    (SYSTEM::%SET-TRAMPOLINE-FUNCTION FI #'%FUNCALLABLE-INSTANCE-TRAMPOLINE-FUNCTION)
    FI))

#+CLOE-Runtime
(DEFUN %ALLOCATE-FUNCALLABLE-INSTANCE-COPY
       (TEMPLATE &OPTIONAL (AREA SYS::AKIND$K-DEFAULT))
  (LET* ((II (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION TEMPLATE))
	 (FI (%ALLOCATE-FUNCALLABLE-INSTANCE-INTERNAL
	       II
	       (LET ((NSLOTS (%INSTANCE-INFORMATION-SIZE II)))
		 (SYS::%Q-REPLACE
		   (SYS::%MAKE-SIMPLE-ARRAY NSLOTS SYS::AETYPE$K-T)
		   (%FUNCALLABLE-INSTANCE-SLOTS TEMPLATE) 0 0 NSLOTS))
	       AREA)))
    (SYSTEM::%SET-TRAMPOLINE-FUNCTION FI #'%FUNCALLABLE-INSTANCE-TRAMPOLINE-FUNCTION)
    FI))

#-(OR Genera CLOE-Runtime Minima)
;;;CLOE has this hand-coded and installed in the kernel so that the 
;;; code address can be used as a kludgey way of discriminating that the
;;; object uses this calling sequence...
(DEFUN %FUNCALLABLE-INSTANCE-TRAMPOLINE-FUNCTION ()
  (DECLARE (SYS::CACHE-SELF-FUNCTION)
	   (OPTIMIZE (SPEED 3) (SAFETY 0)))
  (LET ((GF (SYS::%SELF-FUNCTION)))
    (SYS::%REAPPLY-WITH-EXTRA-ARGS (%FUNCALLABLE-INSTANCE-FUNCTION GF) GF)))

#-(OR Genera Minima)
(DEFUN INSTANCE-FORWARD (OLD-INSTANCE NEW-INSTANCE)
  (COND ((INSTANCEP OLD-INSTANCE)
	 (UNLESS (INSTANCEP NEW-INSTANCE) (ERROR "instance-forwarding metaclass confusion?"))
	 ;;Forward old-instance to new-instance:  i.e., make old-instance refer to the
	 ;; instance-information and slots of new-instance.  new-instance is generally going
	 ;; to be thrown away; in Cloe, the GC will actually make the two be EQ, but that
	 ;; can't be depended on since it can take arbitrarily long to happen.
	 (SETF (%INSTANCE-INSTANCE-INFORMATION OLD-INSTANCE) (%INSTANCE-INSTANCE-INFORMATION NEW-INSTANCE))
	 #+CLOE-Runtime
	 (SYSTEM::%SET-Q OLD-INSTANCE SYSTEM::INSTANCE$K-PTYPE SYSTEM::INSTANCE$P-DATA-ADDRESS 0
			 (SYSTEM::%Q NEW-INSTANCE SYSTEM::INSTANCE$K-PTYPE SYSTEM::INSTANCE$P-DATA-ADDRESS 0))
	 #-CLOE-Runtime
	 (SETF (%INSTANCE-SLOTS OLD-INSTANCE) (%INSTANCE-SLOTS NEW-INSTANCE)))
	((FUNCALLABLE-INSTANCE-P OLD-INSTANCE)
	 (UNLESS (FUNCALLABLE-INSTANCE-P NEW-INSTANCE) (ERROR "instance-forwarding metaclass confusion?"))
	 (SETF (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION OLD-INSTANCE)
	       (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION NEW-INSTANCE))
	 (SETF (%FUNCALLABLE-INSTANCE-SLOTS OLD-INSTANCE) (%FUNCALLABLE-INSTANCE-SLOTS NEW-INSTANCE))
	 ;;@@@@ function???
	 )
	(T (ERROR "instance-forwarding metaclass confusion?")))
  OLD-INSTANCE)



;;; Information shared by all classes
#-Genera
(DEFSTRUCT-SIMPLE (CLASS-INSTANCE-INFORMATION
		    (:CONC-NAME "%CLASS-INSTANCE-INFORMATION-")
		    (:INCLUDE INSTANCE-INFORMATION (CLASS NIL))
		    (:CONSTRUCTOR MAKE-CLASS-INSTANCE-INFORMATION-INTERNAL
		     (DISPTAB DISPATCH-MASK DISPATCH-ADDRESS &KEY
			      #+Minima ((STORAGE-AREA STORAGE-AREA) T)))
		    (:PRINT-FUNCTION PRINT-INSTANCE-INFORMATION))
  CLASS-NAME
  (PRECEDENCE-LIST NIL)
  EFFECTIVE-SLOTS
  (OBSOLETE-P NIL)
  (N-SLOTS 0 :TYPE FIXNUM)
  (SLOT-NAME-TABLE #() :TYPE SIMPLE-VECTOR)
  SPARE-B
  SPARE-C)

;;; The slots are carefully chosen so that they are aligned with a Flavor.
#+Genera
(DEFSTRUCT-SIMPLE (CLASS-INSTANCE-INFORMATION
		 (:CONC-NAME "%CLASS-INSTANCE-INFORMATION-")
		 (:INCLUDE INSTANCE-INFORMATION (CLASS NIL))
		 (:CONSTRUCTOR MAKE-CLASS-INSTANCE-INFORMATION-INTERNAL
		  (DISPTAB DISPATCH-MASK DISPATCH-ADDRESS))
		 (:PREDICATE NIL)		;done by hand below
		 (:PRINT-FUNCTION PRINT-INSTANCE-INFORMATION))
  CLASS-NAME
  EFFECTIVE-SLOTS
  (OBSOLETE-P NIL)
  (N-SLOTS 0)
  SLOT-NAME-TABLE
  SPARE-11
  SPARE-12
  SPARE-13
  SPARE-14
  SPARE-15
  SPARE-16
  SPARE-17
  PRECEDENCE-LIST)

;;; For speed, this assumes that the structure is some kind of INSTANCE-INFORMATION
;;; and that all we are testings is whether it is this particular kind.
#+Genera
(DEFSUBST CLASS-INSTANCE-INFORMATION-P (STRUCTURE)
  (EQ 'CLASS-INSTANCE-INFORMATION (AREF STRUCTURE 0)))

(DEFUN MAKE-CLASS-INSTANCE-INFORMATION (&KEY #+Minima ((STORAGE-AREA STORAGE-AREA) T))
  (LET ((DISPATCH-TABLE (MAKE-CLOS-DISPATCH-TABLE #'HANDLE-CLASS-DISPATCH-MISS)))
    (MAKE-CLASS-INSTANCE-INFORMATION-INTERNAL
      DISPATCH-TABLE
      (DISPATCH-TABLE-MASK DISPATCH-TABLE) (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)
      #+Minima 'STORAGE-AREA #+Minima STORAGE-AREA)))

(DEFUN SET-CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS (CLASS INFORMATION SLOTS)
  (LET ((NSLOTS (COUNT-IF #'(LAMBDA (X) (TYPEP X 'FIXNUM))
			  SLOTS :KEY #'SLOT-DEFINITION-LOCATION)))
    (DECLARE (FIXNUM NSLOTS))
    (COND ((OR (= NSLOTS 0)
	       (NOT (EQ (CLASS-NAME (CLASS-OF CLASS)) 'STANDARD-CLASS)))
	   (SETF (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION) 0))
	  (T
	   (LET ((SLOT-NAME-TABLE (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION)))
	     (WHEN (OR (NULL SLOT-NAME-TABLE)
		       (< (LENGTH SLOT-NAME-TABLE) (* 2 NSLOTS)))
	       (SETF (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION)
		     (SETF SLOT-NAME-TABLE (MAKE-ARRAY (* 2 NSLOTS)))))
	     (LET ((I 0))
	       (DECLARE (FIXNUM I))
	       (DOLIST (SLOT SLOTS)
		 (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT)))
		   (WHEN (TYPEP LOCATION 'FIXNUM)
		     (SETF (SVREF SLOT-NAME-TABLE I) (SLOT-DEFINITION-NAME SLOT))
		     (SETF (SVREF SLOT-NAME-TABLE (+ I NSLOTS)) LOCATION)
		     (INCF I)))))
	     (SETF (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION) NSLOTS)))))
  (SETF (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS INFORMATION) SLOTS))

(DEFSUBST INSTANCE-INFORMATION-OBSOLETE-P (INFORMATION)
  #+Genera
  (IF (EQ (AREF INFORMATION 0) 'FLAVOR:FLAVOR)
      (EQ (FLAVOR:FLAVOR-HANDLER-TABLE INFORMATION)
	  FLAVOR::*INSTANCE-TRANSFORMING-HANDLER-TABLE*)
      (%CLASS-INSTANCE-INFORMATION-OBSOLETE-P INFORMATION))
  #-Genera
  (%CLASS-INSTANCE-INFORMATION-OBSOLETE-P INFORMATION))

#+IMACH
(PROGN

(DEFVAR *VECTOR-INSTANCE*)
(DEFVAR *BIT-VECTOR-INSTANCE*)
(DEFVAR *ARRAY-INSTANCE*)
(DEFVAR *LEXICAL-CLOSURE-INSTANCE*)
(DEFVAR *PACKAGE-INSTANCE*)
(DEFVAR *READTABLE-INSTANCE*)

(DEFUN %INSTANCE-INFORMATION (OBJECT)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (COND ((SYS:INSTANCEP OBJECT)
	 (%INSTANCE-INSTANCE-INFORMATION OBJECT))
	((= (SYS:%DATA-TYPE OBJECT) SYS:DTP-ARRAY)
	 (LET ((HEADER (SYS:%SET-TAG (SYS:%MEMORY-READ OBJECT :CYCLE-TYPE SYS:%MEMORY-HEADER)
				     SYS:DTP-FIXNUM)))
	   (%INSTANCE-INSTANCE-INFORMATION
	     (IF (OR (NOT (LDB-TEST SYS:ARRAY-LONG-PREFIX-BIT HEADER))
		     (= (LDB SYS:ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1))
		 (IF (= (LDB SYS:ARRAY-TYPE-FIELD HEADER) SYS:ART-1B)
		     *BIT-VECTOR-INSTANCE*
		     (IF (LDB-TEST SYS:ARRAY-NAMED-STRUCTURE-BIT HEADER)
			 (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
			   (SYS:PACKAGE *PACKAGE-INSTANCE*)
			   (OTHERWISE *VECTOR-INSTANCE*))
			 *VECTOR-INSTANCE*))
		 (IF (LDB-TEST SYS:ARRAY-NAMED-STRUCTURE-BIT HEADER)
		     (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
		       (SYS:READTABLE *READTABLE-INSTANCE*)
		       (OTHERWISE *ARRAY-INSTANCE*))
		     *ARRAY-INSTANCE*)))))
	((= (SYS:%DATA-TYPE OBJECT) SYS:DTP-LEXICAL-CLOSURE)
	 (LET ((EXTRA-ARGUMENT (SYS:%MEMORY-READ OBJECT :SET-CDR-NEXT NIL)))
	   (IF (= (LDB SYS:%%Q-CDR-CODE-WITHIN-TAG (SYS:%TAG EXTRA-ARGUMENT))
		  SYS:LEXICAL-CLOSURE-SUBTYPE-FUNCALLABLE-INSTANCE)
	       (%INSTANCE-INSTANCE-INFORMATION
		 (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT EXTRA-ARGUMENT))
	       (%INSTANCE-INSTANCE-INFORMATION *LEXICAL-CLOSURE-INSTANCE*))))
	(T
	 (SYS:%MAKE-POINTER-OFFSET
	   SYS:DTP-ARRAY
	   (SYS:%MEMORY-READ
	     (SYS:%POINTER-PLUS
	       SYS:%TRAP-VECTOR-BASE
	       (+ SYS:%GENERIC-DISPATCH-VECTOR (SYS:%DATA-TYPE OBJECT))))
	   -3))))

(DEFUN (SETF %INSTANCE-INFORMATION) (INFORMATION OBJECT)
  (COND ((SYS:INSTANCEP OBJECT)
	 (WITH-NO-OTHER-PROCESSES
	   (SYS:%MEMORY-WRITE 
	     (SYS:%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE SYS:%MEMORY-HEADER)
	     (SYS:%SET-TAG (LOCF (%INSTANCE-INFORMATION-DISPATCH-MASK INFORMATION))
			   (DPB SYS:%HEADER-TYPE-INSTANCE SYS:%%Q-CDR-CODE-WITHIN-TAG
				SYS:DTP-HEADER-P)))))
	((= (SYS:%DATA-TYPE OBJECT) SYS:DTP-ARRAY)
	 (WITH-NO-OTHER-PROCESSES
	   (SYS:%MEMORY-WRITE
	     (SYS:%MEMORY-READ-ADDRESS
	       (LET ((HEADER (SYS:%SET-TAG
			       (SYS:%MEMORY-READ OBJECT :CYCLE-TYPE SYS:%MEMORY-HEADER)
			       SYS:DTP-FIXNUM)))
		 (IF (OR (NOT (LDB-TEST SYS:ARRAY-LONG-PREFIX-BIT HEADER))
			 (= (LDB SYS:ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1))
		     (IF (= (LDB SYS:ARRAY-TYPE-FIELD HEADER) SYS:ART-1B)
			 *BIT-VECTOR-INSTANCE*
			 (IF (LDB-TEST SYS:ARRAY-NAMED-STRUCTURE-BIT HEADER)
			     (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
			       (SYS:PACKAGE *PACKAGE-INSTANCE*)
			       (OTHERWISE *VECTOR-INSTANCE*))
			     *VECTOR-INSTANCE*))
		     (IF (LDB-TEST SYS:ARRAY-NAMED-STRUCTURE-BIT HEADER)
			 (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
			   (SYS:READTABLE *READTABLE-INSTANCE*)
			   (OTHERWISE *ARRAY-INSTANCE*))
			 *ARRAY-INSTANCE*)))
	       :CYCLE-TYPE SYS:%MEMORY-HEADER)
	     (SYS:%SET-TAG (LOCF (%INSTANCE-INFORMATION-DISPATCH-MASK INFORMATION))
			   (DPB SYS:%HEADER-TYPE-INSTANCE SYS:%%Q-CDR-CODE-WITHIN-TAG
				SYS:DTP-HEADER-P)))))
	((= (SYS:%DATA-TYPE OBJECT) SYS:DTP-LEXICAL-CLOSURE)
	 (WITH-NO-OTHER-PROCESSES
	   (LET* ((EXTRA-ARGUMENT (SYS:%MEMORY-READ OBJECT :SET-CDR-NEXT NIL))
		  (DISPATCH-INSTANCE
		    (IF (= (LDB SYS:%%Q-CDR-CODE-WITHIN-TAG (SYS:%TAG EXTRA-ARGUMENT))
			   SYS:LEXICAL-CLOSURE-SUBTYPE-FUNCALLABLE-INSTANCE)
			(%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT EXTRA-ARGUMENT)
			*LEXICAL-CLOSURE-INSTANCE*)))
	     (SYS:%MEMORY-WRITE 
	       (SYS:%MEMORY-READ-ADDRESS DISPATCH-INSTANCE :CYCLE-TYPE SYS:%MEMORY-HEADER)
	       (SYS:%SET-TAG
		 (LOCF (%INSTANCE-INFORMATION-DISPATCH-MASK INFORMATION))
		 (DPB SYS:%HEADER-TYPE-INSTANCE SYS:%%Q-CDR-CODE-WITHIN-TAG
		      SYS:DTP-HEADER-P))))))
	(T
	 (SYS:%MEMORY-WRITE
	   (SYS:%POINTER-PLUS
	     SYS:%TRAP-VECTOR-BASE
	     (+ SYS:%GENERIC-DISPATCH-VECTOR  (SYS:%DATA-TYPE OBJECT)))
	   (LOCF (%INSTANCE-INFORMATION-DISPATCH-MASK INFORMATION)))))
  INFORMATION)

(DEFUN %CLASS-INFORMATION-FOR-TYPE (TYPE)
  (SYS:%MEMORY-READ
    (SYS:%POINTER-PLUS SYS:%TRAP-VECTOR-BASE (+ SYS:%GENERIC-DISPATCH-VECTOR TYPE))))

(DEFUN (SETF %CLASS-INFORMATION-FOR-TYPE) (CLASS-INFORMATION TYPE)
  (SYS:%MEMORY-WRITE
    (SYS:%POINTER-PLUS SYS:%TRAP-VECTOR-BASE (+ SYS:%GENERIC-DISPATCH-VECTOR TYPE))
    (LOCF (%INSTANCE-INFORMATION-DISPATCH-MASK CLASS-INFORMATION)))
  CLASS-INFORMATION)
);End #+imach

#+Minima
(PROGN

(DEFVAR *VECTOR-INSTANCE*)
(DEFVAR *BIT-VECTOR-INSTANCE*)
(DEFVAR *ARRAY-INSTANCE*)
(DEFVAR *LEXICAL-CLOSURE-INSTANCE*)

(DEFUN %INSTANCE-INFORMATION (OBJECT)
  (COND ((INSTANCEP OBJECT)
	 (%INSTANCE-INSTANCE-INFORMATION OBJECT))
	((IVORY::TYPE-MEMBER OBJECT (IVORY:DATA-TYPE 'IVORY::ARRAY))
	 (%INSTANCE-INSTANCE-INFORMATION
	   (LET ((HEADER (IVORY:%SET-TAG (IVORY:%MEMORY-READ OBJECT :CYCLE-TYPE 'IVORY:HEADER)
					 (IVORY:DATA-TYPE 'FIXNUM))))
	     (IF (OR (NOT (MINIMA-DEFINITIONS:FIXNUM-FIELD-VALUE HEADER IVORY:ARRAY-HEADER IVORY:LONG-PREFIX))
		     (= 1 (MINIMA-DEFINITIONS:FIXNUM-FIELD-VALUE HEADER IVORY:LONG-ARRAY-HEADER IVORY:RANK)))
		 (IF (= (MINIMA-DEFINITIONS:FIXNUM-FIELD-VALUE HEADER IVORY:ARRAY-HEADER IVORY::TYPE-FIELD)
			#O05)
		     *BIT-VECTOR-INSTANCE*
		     *VECTOR-INSTANCE*)
		 *ARRAY-INSTANCE*))))
	((IVORY::TYPE-MEMBER OBJECT (IVORY:DATA-TYPE 'IVORY::EXTRA-ARG-FUNCTION))
	 (%INSTANCE-INSTANCE-INFORMATION
	   (LET ((EXTRA-ARGUMENT (IVORY:%MEMORY-READ OBJECT :SET-CDR-NEXT NIL)))
	     (IF (EQ (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
		       (IVORY:%TAG EXTRA-ARGUMENT)
		       IVORY::TAG
		       IVORY::LEXICAL-CLOSURE-SUBTYPE)
		     'IVORY::FUNCALLABLE-INSTANCE)
		 (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT EXTRA-ARGUMENT)
		 *LEXICAL-CLOSURE-INSTANCE*))))
	(T
	  (%CLASS-INFORMATION-FOR-TYPE
	    (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
	      (IVORY:%TAG OBJECT) IVORY::TAG IVORY::DATA-TYPE
	      :FIELD-TYPE FIXNUM)))))

(DEFUN (SETF %INSTANCE-INSTANCE-INFORMATION) (INFORMATION OBJECT)
  (WITH-NO-OTHER-PROCESSES
    (IVORY:%MEMORY-WRITE 
      (IVORY:%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE 'IVORY:HEADER)
      (IVORY::MAKE-HEADER-P
	IVORY:INSTANCE
	(IVORY:%POINTER-PLUS INFORMATION 2))))
  INFORMATION)

(DEFUN (SETF %INSTANCE-INFORMATION) (INFORMATION OBJECT)
  (COND ((INSTANCEP OBJECT)
	 (SETF (%INSTANCE-INSTANCE-INFORMATION OBJECT) INFORMATION))
	((IVORY::TYPE-MEMBER OBJECT (IVORY:DATA-TYPE 'IVORY::ARRAY))
	 (SETF (%INSTANCE-INSTANCE-INFORMATION
		 (LET ((HEADER (IVORY:%SET-TAG (IVORY:%MEMORY-READ OBJECT :CYCLE-TYPE 'IVORY:HEADER)
					       (IVORY:DATA-TYPE 'FIXNUM))))
		   (IF (OR (NOT (MINIMA-DEFINITIONS:FIXNUM-FIELD-VALUE HEADER IVORY:ARRAY-HEADER IVORY:LONG-PREFIX))
			   (= 1 (MINIMA-DEFINITIONS:FIXNUM-FIELD-VALUE HEADER IVORY:LONG-ARRAY-HEADER IVORY:RANK)))
		       (IF (= (MINIMA-DEFINITIONS:FIXNUM-FIELD-VALUE HEADER IVORY:ARRAY-HEADER IVORY::TYPE-FIELD)
			      #O05)
			   *BIT-VECTOR-INSTANCE*
			   *VECTOR-INSTANCE*)
		       *ARRAY-INSTANCE*)))
	       INFORMATION))
	((IVORY::TYPE-MEMBER OBJECT (IVORY:DATA-TYPE 'IVORY::EXTRA-ARG-FUNCTION))
	 (SETF (%INSTANCE-INSTANCE-INFORMATION
		 (LET ((EXTRA-ARGUMENT (IVORY:%MEMORY-READ OBJECT :SET-CDR-NEXT NIL)))
		   (IF (EQ (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
			     (IVORY:%TAG EXTRA-ARGUMENT)
			     IVORY::TAG
			     IVORY::LEXICAL-CLOSURE-SUBTYPE)
			   'IVORY::FUNCALLABLE-INSTANCE)
		       (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT EXTRA-ARGUMENT)
		       *LEXICAL-CLOSURE-INSTANCE*)))
	       INFORMATION))
	(T
	  (SETF (%CLASS-INFORMATION-FOR-TYPE
		  (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
		    (IVORY:%TAG OBJECT) IVORY::TAG IVORY::DATA-TYPE
		    :FIELD-TYPE FIXNUM))
		INFORMATION))))

(DEFUN %CLASS-INFORMATION-FOR-TYPE (TYPE)
  (IVORY:%SET-TAG
    (IVORY:%POINTER-PLUS
      (IVORY:%MEMORY-READ
	(IVORY:%POINTER-PLUS IVORY::%TRAP-VECTOR-BASE (+ IVORY::%GENERIC-DISPATCH-VECTOR TYPE)))
      -2)
    (IVORY:DATA-TYPE 'IVORY:INSTANCE)))

(DEFUN (SETF %CLASS-INFORMATION-FOR-TYPE) (CLASS-INFORMATION TYPE)
  (IVORY:%MEMORY-WRITE
    (IVORY:%POINTER-PLUS IVORY::%TRAP-VECTOR-BASE (+ IVORY::%GENERIC-DISPATCH-VECTOR TYPE))
    (IVORY:%POINTER-PLUS (IVORY:%SET-TAG CLASS-INFORMATION (IVORY:DATA-TYPE 'IVORY:LOCATIVE)) 2))
  CLASS-INFORMATION)
);End #+minima

#+|3600|
(PROGN

(DEFVAR *EXTENDED-NUMBER-INFORMATION* (MAKE-ARRAY 4))
(DEFVAR *BIT-VECTOR-INFORMATION*)
(DEFVAR *VECTOR-INFORMATION*)
(DEFVAR *ARRAY-INFORMATION*)
(DEFVAR *LEXICAL-CLOSURE-INFORMATION*)
(DEFVAR *STRING-INFORMATION*)
(DEFVAR *PACKAGE-INFORMATION*)
(DEFVAR *READTABLE-INFORMATION*)

(DEFUN %INSTANCE-INFORMATION (OBJECT)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (COND ((SYS:INSTANCEP OBJECT)
	 (%INSTANCE-INSTANCE-INFORMATION OBJECT))
	((STRINGP OBJECT) *STRING-INFORMATION*)
	((ARRAYP OBJECT)
	 (IF (VECTORP OBJECT)
	     (IF (BIT-VECTOR-P OBJECT)
		 *BIT-VECTOR-INFORMATION*
		 (IF (SYS:NAMED-STRUCTURE-P OBJECT)
		     (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
		       (SYS:PACKAGE *PACKAGE-INFORMATION*)
		       (OTHERWISE *VECTOR-INFORMATION*))
		     *VECTOR-INFORMATION*))
	     (IF (SYS:NAMED-STRUCTURE-P OBJECT)
		 (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
		   (SYS:READTABLE *READTABLE-INFORMATION*)
		   (OTHERWISE *ARRAY-INFORMATION*))
		 *ARRAY-INFORMATION*)))
	((SYS:LEXICAL-CLOSURE-P OBJECT) *LEXICAL-CLOSURE-INFORMATION*)
	((SYS:FUNCALLABLE-INSTANCE-P OBJECT)
	 (%INSTANCE-INSTANCE-INFORMATION
	   (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
	     (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT OBJECT))))
	((= (SYS:%DATA-TYPE OBJECT) SYS:DTP-EXTENDED-NUMBER)
	 (AREF *EXTENDED-NUMBER-INFORMATION* (SYS:%P-LDB SYS:%%HEADER-SUBTYPE-FIELD OBJECT)))
	(T
	 (LOCATION-CONTENTS (SYS:%POINTER-PLUS SYS:%GENERIC-DISPATCH-VECTOR 
						   (SYS:%DATA-TYPE OBJECT))))))

(DEFUN (SETF %INSTANCE-INFORMATION) (INFORMATION OBJECT)
  (COND ((SYS:INSTANCEP OBJECT)
	 (WITH-NO-OTHER-PROCESSES
	   (SYS:%P-STORE-TAG-AND-POINTER
	     (SYS:FOLLOW-STRUCTURE-FORWARDING OBJECT)
	     (DPB SYS:%HEADER-TYPE-INSTANCE SYS:%%Q-CDR-CODE-WITHIN-TAG SYS:DTP-HEADER-P)
	     OBJECT)))
	((SYS:LEXICAL-CLOSURE-P OBJECT)
	 (SETF *LEXICAL-CLOSURE-INFORMATION* INFORMATION))
	((SYS:FUNCALLABLE-INSTANCE-P OBJECT)
	 (WITH-NO-OTHER-PROCESSES
	   (LET ((INSTANCE (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
			     (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT OBJECT))))
	     (SYS:%P-STORE-TAG-AND-POINTER
	       (SYS:FOLLOW-STRUCTURE-FORWARDING INSTANCE)
	       (DPB SYS:%HEADER-TYPE-INSTANCE SYS:%%Q-CDR-CODE-WITHIN-TAG SYS:DTP-HEADER-P)
	       INSTANCE))))
	((STRINGP OBJECT)
	 (SETF *STRING-INFORMATION* INFORMATION))
	((ARRAYP OBJECT)
	 (IF (VECTORP OBJECT)
	     (IF (BIT-VECTOR-P OBJECT)
		 (SETF *BIT-VECTOR-INFORMATION* INFORMATION)
		 (IF (SYS:NAMED-STRUCTURE-P OBJECT)
		     (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
		       (SYS:PACKAGE (SETF *PACKAGE-INFORMATION* INFORMATION))
		       (OTHERWISE (SETF *VECTOR-INFORMATION* INFORMATION)))
		     (SETF *VECTOR-INFORMATION* INFORMATION)))
	     (IF (SYS:NAMED-STRUCTURE-P OBJECT)
		 (CASE (SYS:NAMED-STRUCTURE-SYMBOL OBJECT)
		   (SYS:READTABLE (SETF *READTABLE-INFORMATION* INFORMATION))
		   (OTHERWISE (SETF *ARRAY-INFORMATION* INFORMATION)))
		 (SETF *ARRAY-INFORMATION* INFORMATION))))
	((= (SYS:%DATA-TYPE OBJECT) SYS:DTP-EXTENDED-NUMBER)
	 (SETF (AREF *EXTENDED-NUMBER-INFORMATION*
		     (SYS:%P-LDB SYS:%%HEADER-SUBTYPE-FIELD OBJECT))
	       INFORMATION))
	(T (SETF (%CLASS-INFORMATION-FOR-TYPE (SYS:%DATA-TYPE OBJECT)) INFORMATION)))
  INFORMATION)

(DEFUN %CLASS-INFORMATION-FOR-TYPE (TYPE)
  (LOCATION-CONTENTS (SYS:%POINTER-PLUS SYS:%GENERIC-DISPATCH-VECTOR TYPE)))

(DEFUN (SETF %CLASS-INFORMATION-FOR-TYPE) (CLASS-INFORMATION TYPE)
  (LOOP REPEAT (IF (OR (= TYPE SYS:DTP-FIX) (= TYPE SYS:DTP-FLOAT)) 16 1) DO
    (SETF (LOCATION-CONTENTS (SYS:%POINTER-PLUS SYS:%GENERIC-DISPATCH-VECTOR TYPE))
	  CLASS-INFORMATION)
    (INCF TYPE))
  CLASS-INFORMATION)

);End #+|3600|

#+CLOE-Runtime
(IN-PACKAGE :COMPILER)

#+CLOE-Runtime
(define-code-template clos-internals::%instance-information-inline (form mode)
  (let ((join (reflabel)) (simple (reflabel)) (next (reflabel)))
    (vcompile (second form) CMP-LOAD)
    (gencode MOV ECX EAX)
    (gencode ROR ECX (1- SEGSHIFT))
    (gencode AND ECX CIMMED (+ SEGMASK SEGMASK))
    (gencode MOVZX ECX INDEX ECX ADDR32 DATATYPE-LOOKUP-1)
    (gencode AND ECX CIMMED sys::lo$k-typemask) ; strip off the pointer bit
    (gencode TEST CIMMDWD INDEX EDX ECX SCALE sys::sq$k-next-slot-scale CADDR32 sys::sq$l-index-bit-mask-0
	     (logior (ash 1 sys::lo$k-instance)
		     (ash 1 sys::lo$k-array)	;Must differentiate some array specializations.
		     (ash 1 sys::lo$k-symbol)	;NIL is the type NULL.
		     (ash 1 sys::lo$k-trampoline)	;Funcallable-instances are special.
		     (ash 1 sys::lo$k-xnum)	;Extended numbers must subdispatch on type.
		     ))
    (gencode JE NEAR simple)

    (gencode CMP CL CIMMED sys::lo$k-instance)
    (gencode JNE next)
    (gencode MOV EAX INDEX EAX CADDR32 (ptr- sys::instance$p-instance-information sys::instance$k-ptype))
    (gencode JMP NEAR join)

    (setlabel next)
    (setq next (reflabel))
    (gencode CMP CL CIMMED sys::lo$k-trampoline)
    (gencode JNE next)
    (let ((not-instance (reflabel)))
      (gencode MOV EBX INDEX EAX CADDR32 sys::trampoline$k-values-offset)
      (gencode CMP EBX IMMED 'clos-internals::funcallable-instance)
      (gencode JNE not-instance)
      (gencode MOV EAX INDEX EAX CADDR32 (+ sys::trampoline$k-values-offset sys::funcallable-instance$p-instance-information))
      (gencode JMP NEAR join)
      (setlabel not-instance)
      (gencode AND EBX CIMMED sys::ptype$k-mask)
      (gencode CMP EBX CIMMED sys::cons$k-ptype)
      (gencode JNE NEAR simple)			;If neither funcallable-instance nor lexical-closure, is just FUNCTION.
      (gencode MOV ESI IMMED 'clos-internals::*lexical-closure-instance-information*)
      (gencode MOV EAX INDEX ESI CADDR32 (- sys::symbol$p-value sys::symbol$k-ptype))
      (gencode JMP NEAR join))

    (setlabel next)
    (setq next (reflabel))
    (gencode CMP CL CIMMED sys::lo$k-array)
    (gencode JNE next)
    (gencode CMP IMMBYT INDEX EAX CADDR32 (- sys::array$b-rank sys::array$k-ptype) 1)
    (gencode JNE NEAR simple)			;Default case is just ARRAY.
    (gencode MOVZX EBX INDEX EAX CADDR32 (- sys::array$b-element-type sys::array$k-ptype))
    (gencode MOV ESI IMMED 'clos-internals::*vector-aetype-instance-information*)
    (gencode MOV ESI INDEX ESI CADDR32 (- sys::symbol$p-value sys::symbol$k-ptype))
    (gencode MOV EAX INDEX ESI EBX SCALE 4 CADDR32 (- sys::array$k-value-offset (ash sys::aetype$k-offset 2)))
    (gencode JMP NEAR join)

    (setlabel next)
    (setq next (reflabel))
    (gencode CMP CL CIMMED sys::lo$k-xnum)
    (gencode JNE next)
    (gencode MOV ESI IMMED 'clos-internals::*xnum-type-instance-information*)
    (gencode MOVZX EBX INDEX EAX CADDR32 (- sys::xnum$b-type sys::xnum$k-ptype))
    (gencode MOV ESI INDEX ESI CADDR32 (- sys::symbol$p-value sys::symbol$k-ptype))
    (gencode MOV EAX INDEX ESI EBX SCALE 4 CADDR32 sys::array$k-value-offset)
    (gencode JMP NEAR join)

    (setlabel next)
    (gencode CMP EAX EDX)
    (gencode JNE simple)
    (gencode MOV ESI IMMED 'clos-internals::*null-instance-information*)
    (gencode MOV EAX INDEX ESI CADDR32 (- sys::symbol$p-value sys::symbol$k-ptype))
    (gencode JMP join)

    (setlabel simple)
    (gencode MOV ESI IMMED 'clos-internals::*object-type-instance-information*)
    (gencode MOV ESI INDEX ESI CADDR32 (- sys::symbol$p-value sys::symbol$k-ptype))
    (gencode MOV EAX INDEX ESI ECX SCALE 4 CADDR32 sys::array$k-value-offset)

    (setlabel join)
    (compile-single-value EAX mode)))

#+CLOE-Runtime
(IN-PACKAGE :CLOS-INTERNALS)

#+CLOE-Runtime
(PROGN

(DEFVAR *NULL-INSTANCE-INFORMATION*)
(DEFVAR *LEXICAL-CLOSURE-INSTANCE-INFORMATION*)
(DEFVAR *T-CLASS-INSTANCE-INFORMATION*)

(DEFVAR *OBJECT-TYPE-INSTANCE-INFORMATION*
	(MAKE-ARRAY SYSTEM::LO$K-LIMIT :INITIAL-ELEMENT NIL))

(DEFVAR *XNUM-TYPE-INSTANCE-INFORMATION*
	(MAKE-ARRAY SYSTEM::LN$K-LIMIT :INITIAL-ELEMENT NIL))

(DEFVAR *VECTOR-AETYPE-INSTANCE-INFORMATION*
	(MAKE-ARRAY SYSTEM::AETYPE$K-LIMIT :INITIAL-ELEMENT NIL))


(DEFUN %INSTANCE-INFORMATION (OBJECT)
  #+Franz
  (LET ((LO (SYS::%SEGMENT-TYPE OBJECT)))
    (DECLARE (FIXNUM LO))
    (MACROLET ((SIMPLE () `(SVREF *OBJECT-TYPE-INSTANCE-INFORMATION* LO)))
      (COND ((= LO SYS::LO$K-INSTANCE) (%INSTANCE-INSTANCE-INFORMATION OBJECT))
	    ((= LO SYS::LO$K-TRAMPOLINE)
	     (LET ((Z (SYS::%TRAMPOLINE-REF OBJECT 0))) 
	       (COND ((EQ Z 'FUNCALLABLE-INSTANCE) (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION OBJECT))
		     ((CONSP Z) *LEXICAL-CLOSURE-INSTANCE-INFORMATION*)
		     (T (SIMPLE)))))
	    ((= LO SYS::LO$K-ARRAY)
	     (IF (= (SYS::%ARRAY-RANK OBJECT) 1)
		 (SVREF *VECTOR-AETYPE-INSTANCE-INFORMATION* (- (SYS::%ARRAY-ELEMENT-TYPE OBJECT) SYS::AETYPE$K-OFFSET))
		 (SIMPLE)))
	    ((= LO SYS::LO$K-XNUM) (SVREF *XNUM-TYPE-INSTANCE-INFORMATION* (SYS::%XNUM-TYPE OBJECT)))
	    ((NULL OBJECT) *NULL-INSTANCE-INFORMATION*)
	    (T (SIMPLE)))))
  #-Franz
  (%INSTANCE-INFORMATION-INLINE OBJECT))


(DEFUN (SETF %INSTANCE-INFORMATION) (II OBJECT)
  (LET ((LO (SYS::%SEGMENT-TYPE OBJECT)))
    (DECLARE (FIXNUM LO))
    (MACROLET ((SIMPLE () '(SETF (SVREF *OBJECT-TYPE-INSTANCE-INFORMATION* LO) II)))
      (COND ((= LO SYS::LO$K-INSTANCE) (SETF (%INSTANCE-INSTANCE-INFORMATION OBJECT) II))
	    ((= LO SYS::LO$K-STRUCTURE) (SIMPLE))
	    ((= LO SYS::LO$K-TRAMPOLINE)
	     (LET ((Z (SYS::%TRAMPOLINE-REF OBJECT 0)))
	       (COND ((EQ Z 'FUNCALLABLE-INSTANCE) (SETF (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION OBJECT) II))
		     ((CONSP Z) (SETQ *LEXICAL-CLOSURE-INSTANCE-INFORMATION* II))
		     (T (SIMPLE)))))
	    ((= LO SYS::LO$K-ARRAY)
	     (IF (= (SYS::%ARRAY-RANK OBJECT) 1)
		 (SETF (SVREF *VECTOR-AETYPE-INSTANCE-INFORMATION* (- (SYS::%ARRAY-ELEMENT-TYPE OBJECT) SYS::AETYPE$K-OFFSET)))
		 (SIMPLE)))
	    ((= LO SYS::LO$K-XNUM) (SETF (SVREF *XNUM-TYPE-INSTANCE-INFORMATION* (SYS::%XNUM-TYPE OBJECT)) II))
	    ((NULL OBJECT) (SETQ *NULL-INSTANCE-INFORMATION* II))
	    (T (SIMPLE))))))
);;;#+CLOE-Runtime

#-CLOE-Runtime
;;;CLOE has a code-template for this.  It probably isn't too big for the limited uses;
;;; if so I will have to introduce a third internal function name and remodularize it
;;; like the lispm's.
(DEFMACRO %INSTANCE-INFORMATION-INLINE (OBJECT)
  #+(OR IMACH |3600|)
  `(BLOCK %INSTANCE-INFORMATION-INLINE
     (COMPILER:%ERROR-UNLESS (SYS:INSTANCEP ,OBJECT)
       (RETURN-FROM %INSTANCE-INFORMATION-INLINE
	 (%INSTANCE-INFORMATION ,OBJECT)))
     (%INSTANCE-INSTANCE-INFORMATION ,OBJECT))
  #+Minima
  `(IF (INSTANCEP ,OBJECT)
       (%INSTANCE-INSTANCE-INFORMATION ,OBJECT)
       (%INSTANCE-INFORMATION ,OBJECT))
  #-(OR IMACH |3600| Minima)			;no quick SYS:INSTANCEP predicate in Cloe
  `(%INSTANCE-INFORMATION ,OBJECT))

;;;
;;;
;;;	       Dispatching Funcallable Instance Protocol
;;;
;;; A dispatching funcallable instance is a funcallable instance which supports
;;; argument dispatching.  Associated with each dispatching funcallable instance is a
;;; unique key, called the selector, which is used to start the dispatch.  For a
;;; generic function, this key is the extra argument, but for a message, the key may
;;; be something different.
;;;
;;;                                                              Generic Function     
;;; DISPATCHING-FUNCALLABLE-INSTANCE-SELECTOR dispatching-funcallable-instance
;;;
;;;    Returns the selector for the dispatching funcallable instance.  This may be
;;;    initialized with the SELECTOR initialization argument.
;;;
;;; DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR selector      Generic Function
;;;
;;;    Returns the funcallable instance associated with the selector.  SETF may be
;;;    used to form an association.

#+CLOE-Runtime
(IN-PACKAGE :COMPILER)

#+CLOE-Runtime
(define-code-template clos-internals::%call-presumed-generic-function (form mode)
  ;;Arguments here are in actual order of evaluation:  the function is moved last.
  (let ((nargs 0) (call-it (reflabel)))
    (declare (fixnum nargs))
    (gencode PUSH EDX)
    (do ((l (cdr form) (cdr l)))
	((null (cdr l))
	 (let ((f (car l)))
	   (if (and (consp f) (eq (car f) 'function))
	       (vcompile (cadr f) CMP-LOADF)	;This hack makes undefined-function errors graceful.
	       (vcompile f CMP-LOAD))))
      (vcompile (car l) CMP-PUSH)
      (incf nargs))
    (gencode PUSH CIMMED (ash nargs 2))		;push number of args if regular function call.
    (gencode MOV EBX INDEX EAX CADDR32 CODE-POS)
    (gencode CMP EBX ADDR32 (ash (sys::%sq-ref sys::sq$l-generic-function-trampoline-address) 2))    
    (gencode JNE call-it)
    (gencode ADD CIMMDWD INDEX ESP CADDR32 0 4)	;Increment the number of arguments passed,
    (gencode MOV TO EAX INDEX ESP CADDR32 (ash (1+ nargs) 2))	;Store the function itself as the first arg,
    (gencode MOV EAX INDEX EAX CADDR32		;Substitute the first-dispatch function for the original function,
	     (+ sys::trampoline$k-values-offset sys::funcallable-instance$p-function))
    (setlabel call-it)
    (gencode CALL NEAR INDEX EAX CADDR32 code-pos)
    (gencode LEA ESP INDEX ESP CADDR32 (ash (+ nargs 2) 2))
    (edi-invalid)
    (compile-mvalues mode)))

#+CLOE-Runtime
(IN-PACKAGE :CLOS-INTERNALS)

#+Minima
(DEFUN EQL-DISPATCH-INSTANCE-P (X)
  (AND (INSTANCEP X)
       (EQ (%INSTANCE-INFORMATION-CLASS (%INSTANCE-INSTANCE-INFORMATION X)) T)))

#-(OR Genera Minima)
(DEFUN EQL-DISPATCH-INSTANCE-P (X)
  (AND (TYPEP X 'INSTANCE)
       (EQ (%INSTANCE-INFORMATION-CLASS (%INSTANCE-INSTANCE-INFORMATION X)) T)))

(DEFSUBST EQL-DISPATCH-INSTANCE-DEFAULT-HANDLER (EQL-DISPATCH-INSTANCE)
  (%INSTANCE-REF EQL-DISPATCH-INSTANCE 1))

(DEFSUBST (SETF EQL-DISPATCH-INSTANCE-DEFAULT-HANDLER) (HANDLER EQL-DISPATCH-INSTANCE)
  (SETF (%INSTANCE-REF EQL-DISPATCH-INSTANCE 1) HANDLER))

(DEFSUBST EQL-DISPATCH-INSTANCE-DEFAULT-EXTRA-ARGUMENT (EQL-DISPATCH-INSTANCE)
  (%INSTANCE-REF EQL-DISPATCH-INSTANCE 2))

(DEFSUBST (SETF EQL-DISPATCH-INSTANCE-DEFAULT-EXTRA-ARGUMENT) (VALUE EQL-DISPATCH-INSTANCE)
  (SETF (%INSTANCE-REF EQL-DISPATCH-INSTANCE 2) VALUE))

(DEFCONSTANT %EQL-DISPATCH-INSTANCE-SIZE 3)

(DEFUN ALLOCATE-EQL-DISPATCH-INSTANCE (GENERIC-FUNCTION KEYS)
  (MULTIPLE-VALUE-BIND (MISS-HANDLER MISS-EXTRA-ARGUMENT)
      (FIND-EQL-DISPATCH-MISS-HANDLER-AND-EXTRA-ARGUMENT GENERIC-FUNCTION)
    (LET ((DISPATCH-TABLE
	    (MAKE-DISPATCH-TABLE
	      (LENGTH KEYS)
	      NIL
	      NIL
	      (FIND-EQL-DISPATCH-MISS-HANDLER KEYS))))
      (INHIBIT-GC-FLIPS
	(DOLIST (KEY KEYS)
	  (SETQ DISPATCH-TABLE
		(INSERT-DIRECTLY-IN-DISPATCH-TABLE
		  DISPATCH-TABLE KEY MISS-HANDLER MISS-EXTRA-ARGUMENT))))
      (LET ((INFORMATION (MAKE-INSTANCE-INFORMATION-INTERNAL
			   DISPATCH-TABLE
			   (DISPATCH-TABLE-MASK DISPATCH-TABLE)
			   (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE))))
	(SETF (%INSTANCE-INFORMATION-SIZE INFORMATION) %EQL-DISPATCH-INSTANCE-SIZE)
	(LET ((EQL-DISPATCH-INSTANCE (%ALLOCATE-INSTANCE INFORMATION)))
	  (SETF (EQL-DISPATCH-INSTANCE-DEFAULT-HANDLER EQL-DISPATCH-INSTANCE) MISS-HANDLER)
	  (SETF (EQL-DISPATCH-INSTANCE-DEFAULT-EXTRA-ARGUMENT EQL-DISPATCH-INSTANCE) MISS-EXTRA-ARGUMENT)
	  EQL-DISPATCH-INSTANCE)))))

(DEFUN UPDATE-EQL-DISPATCH-INSTANCE (GENERIC-FUNCTION EQL-DISPATCH-INSTANCE KEYS)
  (LET ((HASH-MISS-HANDLER (FIND-EQL-DISPATCH-MISS-HANDLER KEYS))
	(INFORMATION (%INSTANCE-INSTANCE-INFORMATION EQL-DISPATCH-INSTANCE)))
    (MULTIPLE-VALUE-BIND (MISS-HANDLER MISS-EXTRA-ARGUMENT)
	(FIND-EQL-DISPATCH-MISS-HANDLER-AND-EXTRA-ARGUMENT GENERIC-FUNCTION)
      (WITH-NO-OTHER-PROCESSES
	(LET* ((ORIGINAL-DISPATCH-TABLE (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION))
	       (DISPATCH-TABLE ORIGINAL-DISPATCH-TABLE))
	  (MAP-OVER-DISPATCH-TABLE
	    #'(LAMBDA (SELECTOR HANDLER EXTRA-ARGUMENT)
		(IF SELECTOR
		    (IF (MEMBER SELECTOR KEYS)
			(VALUES SELECTOR HANDLER EXTRA-ARGUMENT)
			(VALUES NIL HASH-MISS-HANDLER NIL))
		    (VALUES SELECTOR HASH-MISS-HANDLER NIL)))
	    DISPATCH-TABLE)
	  ;; Always rehash the table, so that we sure to update the miss handler.
	  (SETQ DISPATCH-TABLE (REHASH-DISPATCH-TABLE DISPATCH-TABLE T))
	  (LET ((MASK (DISPATCH-TABLE-MASK DISPATCH-TABLE))
		(ADDRESS (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)))
	    (DOLIST (KEY KEYS)
	      (UNLESS (DISPATCH-TABLE-SEARCH-INTERNAL KEY DISPATCH-TABLE MASK ADDRESS)
		(LET ((NEW-DISPATCH-TABLE
			(INSERT-IN-DISPATCH-TABLE
			  DISPATCH-TABLE KEY MISS-HANDLER MISS-EXTRA-ARGUMENT)))
		  (UNLESS (EQ NEW-DISPATCH-TABLE DISPATCH-TABLE)
		    (SETQ DISPATCH-TABLE NEW-DISPATCH-TABLE)
		    (SETQ MASK (DISPATCH-TABLE-MASK DISPATCH-TABLE))
		    (SETQ ADDRESS (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)))))))
	  (UNLESS (EQ ORIGINAL-DISPATCH-TABLE DISPATCH-TABLE)
	    (SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION) DISPATCH-TABLE)))))))

(DEFUN REMOVE-EQL-DISPATCH-INSTANCE-KEYS (EQL-DISPATCH-INSTANCE REMOVE-KEYS)
  (WITH-NO-OTHER-PROCESSES
    (LET* ((INFORMATION (%INSTANCE-INSTANCE-INFORMATION EQL-DISPATCH-INSTANCE))
	   (ORIGINAL-DISPATCH-TABLE (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION))
	   (DISPATCH-TABLE ORIGINAL-DISPATCH-TABLE))
      (DOLIST (REMOVE-KEY REMOVE-KEYS)
	(SETQ DISPATCH-TABLE (INSERT-IN-DISPATCH-TABLE DISPATCH-TABLE REMOVE-KEY NIL NIL)))
      (UNLESS (EQ ORIGINAL-DISPATCH-TABLE DISPATCH-TABLE)
	(SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE INFORMATION) DISPATCH-TABLE)))))



#+Genera
(DEFVAR *CLOS-WEAK-LINK-AREA*
	(SYS:MAKE-AREA :NAME '*CLOS-WEAK-LINK-AREA* :REGION-SIZE 10000
		       'SYS:%%REGION-SPACE-TYPE SYS:%REGION-SPACE-WEAK))

(DEFVAR *ALL-GENERIC-FUNCTIONS-LENGTH* 0)
(DEFVAR *ALL-GENERIC-FUNCTIONS*
	#+Genera (SCL:MAKE-ARRAY 1024 :AREA *CLOS-WEAK-LINK-AREA*)
	#-Genera (MAKE-ARRAY 1024))

;; Keep track of generic functions with symbols as selectors, for fast searching.
#+Genera
(DEFVAR *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS* NIL)

(DEFUN NOTICE-GENERIC-FUNCTION (GENERIC-FUNCTION)
  (WITH-CLOS-LOCK
    (LET ((TOTAL-SIZE (ARRAY-TOTAL-SIZE *ALL-GENERIC-FUNCTIONS*)))
      (WHEN (= TOTAL-SIZE *ALL-GENERIC-FUNCTIONS-LENGTH*)
	#+Genera
	;; Remove holes in the array left by the GC.
	(LET* ((OLD-LENGTH *ALL-GENERIC-FUNCTIONS-LENGTH*)
	       (NEW-LENGTH 0)
	       (OLD-ARRAY *ALL-GENERIC-FUNCTIONS*)
	       ;; If no entries have been GC'd, make a new array.
	       (NEW-ARRAY (IF (DOTIMES (INDEX OLD-LENGTH NIL)
				(MULTIPLE-VALUE-BIND (VALUE BOUNDP)
				    (SI:%WEAK-LINK-CONTENTS (LOCF (AREF OLD-ARRAY INDEX)))
				  (DECLARE (IGNORE VALUE))
				  (WHEN (NOT BOUNDP) (RETURN T))))
			      OLD-ARRAY
			      (SCL:MAKE-ARRAY (* 2 OLD-LENGTH) :AREA *CLOS-WEAK-LINK-AREA*))))
	  (DECLARE (SYS:ARRAY-REGISTER OLD-ARRAY NEW-ARRAY))
	  (DOTIMES (INDEX OLD-LENGTH)
	    (MULTIPLE-VALUE-BIND (VALUE BOUNDP)
		(SI:%WEAK-LINK-CONTENTS (LOCF (AREF OLD-ARRAY INDEX)))
	      (WHEN BOUNDP
		(SETF (AREF NEW-ARRAY NEW-LENGTH) VALUE)
		(INCF NEW-LENGTH))))
	  (IF (EQ NEW-ARRAY OLD-ARRAY)
	      (FILL NEW-ARRAY NIL :START NEW-LENGTH :END OLD-LENGTH)
	      (SETF *ALL-GENERIC-FUNCTIONS* NEW-ARRAY))
	  (SETF *ALL-GENERIC-FUNCTIONS-LENGTH* NEW-LENGTH))
	#-Genera
	(LET ((ARRAY (MAKE-ARRAY (* 2 *ALL-GENERIC-FUNCTIONS-LENGTH*))))
	  (REPLACE ARRAY *ALL-GENERIC-FUNCTIONS*
		   :END1 *ALL-GENERIC-FUNCTIONS-LENGTH*
		   :END2 *ALL-GENERIC-FUNCTIONS-LENGTH*)
	  (SETF *ALL-GENERIC-FUNCTIONS* ARRAY))))
    (SETF (AREF *ALL-GENERIC-FUNCTIONS* *ALL-GENERIC-FUNCTIONS-LENGTH*)
	  GENERIC-FUNCTION)
    (INCF *ALL-GENERIC-FUNCTIONS-LENGTH*))
  GENERIC-FUNCTION)

(DEFUN MAP-OVER-GENERIC-FUNCTIONS (CONTINUATION)
  (DECLARE (DYNAMIC-EXTENT CONTINUATION))
  (WITH-CLOS-LOCK
    (DOTIMES (I *ALL-GENERIC-FUNCTIONS-LENGTH*)
      #-Genera
      (FUNCALL CONTINUATION (AREF *ALL-GENERIC-FUNCTIONS* I))
      #+Genera
      (MULTIPLE-VALUE-BIND (GENERIC-FUNCTION FOUNDP)
	  (SI:%WEAK-LINK-CONTENTS (LOCF (AREF *ALL-GENERIC-FUNCTIONS* I)))
	(WHEN (AND FOUNDP GENERIC-FUNCTION)
	  (FUNCALL CONTINUATION GENERIC-FUNCTION))))))



;;;; Access via Mapping Tables


;;;These are prototypical Lisp versions.
;;; They are expected to be implemented at a lower level.
;;; They require all the structure stuff before they can be defined,
;;; which is why they are here rather than in mapping-tables.

#-(OR Genera Minima)
(DEFUN %MAPPED-SLOT-VALUE (INSTANCE MAPPING-TABLE SEGMENT-NUMBER OFFSET)
  (DECLARE (FIXNUM SEGMENT-NUMBER OFFSET))
  (UNLESS (= SEGMENT-NUMBER 0) (ERROR "wtf"))
  #+CLOE-Runtime
  (%MAPPED-SLOT-VALUE INSTANCE MAPPING-TABLE 0 OFFSET)
  #-CLOE-Runtime
  (LET ((WHAT (%MAPPING-TABLE-REF MAPPING-TABLE OFFSET)))
    (TYPECASE WHAT
      (FIXNUM (ETYPECASE INSTANCE
		(INSTANCE (%INSTANCE-REF INSTANCE WHAT))
		(FUNCALLABLE-INSTANCE (%FUNCALLABLE-INSTANCE-REF INSTANCE WHAT))))
      (CONS (CAR WHAT))
      (COMPILED-FUNCTION
	(FUNCALL (THE COMPILED-FUNCTION WHAT) 'SLOT-VALUE OFFSET MAPPING-TABLE INSTANCE))
      (T (ERROR "wtf")))))

#-(OR Genera Minima)
(DEFUN %MAPPED-SLOT-STORE (INSTANCE MAPPING-TABLE SEGMENT-NUMBER OFFSET VALUE)
  (DECLARE (FIXNUM SEGMENT-NUMBER OFFSET))
  (UNLESS (= SEGMENT-NUMBER 0) (ERROR "wtf"))
  #+CLOE-Runtime
  (%MAPPED-SLOT-STORE INSTANCE MAPPING-TABLE 0 OFFSET VALUE)
  #-CLOE-Runtime
  (LET ((WHAT (%MAPPING-TABLE-REF MAPPING-TABLE OFFSET)))
    (TYPECASE WHAT
      (FIXNUM (ETYPECASE INSTANCE
		(INSTANCE (SETF (%INSTANCE-REF INSTANCE WHAT) VALUE))
		(FUNCALLABLE-INSTANCE (SETF (%FUNCALLABLE-INSTANCE-REF INSTANCE WHAT) VALUE))))
      (CONS (SETF (CAR WHAT) VALUE))
      (COMPILED-FUNCTION
	(FUNCALL (THE COMPILED-FUNCTION WHAT) '(SETF SLOT-VALUE) MAPPING-TABLE SEGMENT-NUMBER INSTANCE VALUE))
      (T (ERROR "wtf?")))))


#-(OR Genera Minima)
(DEFUN %MAPPED-SLOT-XSTORE (VALUE INSTANCE MAPPING-TABLE SEGMENT-NUMBER OFFSET)
  (DECLARE (FIXNUM SEGMENT-NUMBER OFFSET))
  (UNLESS (= SEGMENT-NUMBER 0) (ERROR "wtf"))
  #+CLOE-Runtime
  (%MAPPED-SLOT-STORE INSTANCE MAPPING-TABLE 0 OFFSET VALUE)
  #-CLOE-Runtime
  (LET ((WHAT (%MAPPING-TABLE-REF MAPPING-TABLE OFFSET)))
    (TYPECASE WHAT
      (FIXNUM (ETYPECASE INSTANCE
		(INSTANCE (SETF (%INSTANCE-REF INSTANCE WHAT) VALUE))
		(FUNCALLABLE-INSTANCE (SETF (%FUNCALLABLE-INSTANCE-REF INSTANCE WHAT) VALUE))))
      (CONS (SETF (CAR WHAT) VALUE))
      (COMPILED-FUNCTION
	(FUNCALL (THE COMPILED-FUNCTION WHAT) '(SETF SLOT-VALUE) OFFSET SEGMENT-NUMBER INSTANCE VALUE))
      (T (ERROR "wtf?")))))
