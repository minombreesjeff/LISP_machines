;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The DEFSTRUCT macro itself.

(IN-PACKAGE :CLOS-INTERNALS)

(DECLAIM (INLINE %STRUCTURE-REF))
(DEFUN %STRUCTURE-REF (OBJECT OFFSET)
  #+(OR Genera Minima)
  (%INSTANCE-REF OBJECT (1+ OFFSET))
  #-(OR Genera Minima)
  (%INSTANCE-REF OBJECT OFFSET))

(DECLAIM (INLINE (SETF %STRUCTURE-REF)))
(DEFUN (SETF %STRUCTURE-REF) (VALUE OBJECT OFFSET)
  #+(OR Genera Minima)
  (SETF (%INSTANCE-REF OBJECT (1+ OFFSET)) VALUE)
  #-(or Genera Minima)
  (SETF (%INSTANCE-REF OBJECT OFFSET) VALUE)
  VALUE)

#+CLOE-Runtime
(SETF (GET '%STRUCTURE-REF 'BOUNDP-PREDICATE) '%INSTANCE-SLOT-BOUNDP)

(DECLAIM (INLINE DEFSTRUCT-LIST-REF))
(DEFUN DEFSTRUCT-LIST-REF (LIST I)
  (NTH I LIST))

(DECLAIM (INLINE (SETF DEFSTRUCT-LIST-REF)))
(DEFUN (SETF DEFSTRUCT-LIST-REF) (VALUE LIST I)
  (SETF (NTH I LIST) VALUE))

#+(OR Genera Minima)
(DECLAIM (INLINE (LOCF DEFSTRUCT-LIST-REF)))
#+(OR Genera Minima)
(DEFUN (LOCF DEFSTRUCT-LIST-REF) (LIST I)
  #+Genera (LOCF (NTH I LIST))
  #+Minima (IVORY:%SET-TAG (NTHCDR I LIST) (IVORY:DATA-TYPE 'IVORY:LOCATIVE))) 

#+Genera
(PROGN
(SCL:DEFPROP DEFSTRUCT ZL:DEFSTRUCT ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(SCL:DEFPROP DEFSTRUCT ZWEI:DEFSELECT-FUNCTION-SPEC-FINDER ZWEI:DEFINITION-FUNCTION-SPEC-FINDER))

(DEFMACRO DEFSTRUCT (NAME-AND-OPTIONS &BODY SLOT-DESCRIPTIONS &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (NAME SLOTS TYPE NAMED DOCUMENTATION INCLUDED-STRUCTURE CONC-NAME
			CONSTRUCTORS COPIER PREDICATE PRINT-FUNCTION STANDARD-CONSTRUCTOR
			#+Minima STORAGE-CATEGORY)
      (PARSE-DEFSTRUCT NAME-AND-OPTIONS SLOT-DESCRIPTIONS ENV)
    (MULTIPLE-VALUE-BIND (TYPE-NAME TYPE-ARGS)
	(TYPECASE TYPE
	  (SYMBOL
	    (VALUES TYPE NIL))
	  (OTHERWISE
	    (VALUES (FIRST TYPE) (REST TYPE))))
      #+Minima
      (COMPUTE-ACCESSOR-NAMES SLOTS CONC-NAME)
      `(#+Genera SYS:MULTIPLE-DEFINITION #+Genera ,NAME #+Genera ZL:DEFSTRUCT
	#-Genera PROGN
	(EVAL-WHEN (:COMPILE-TOPLEVEL)
	  (ENSURE-DEFSTRUCT-COMPILE
	    ',NAME ',TYPE ',INCLUDED-STRUCTURE ',(STATIC-ENVIRONMENT ENV)
	    :DOCUMENTATION ,DOCUMENTATION
	    ;; INITFUNCTIONs need special treatment.
	    :SLOTS ',(MAPCAR #'(LAMBDA (SLOT)
				 (SETF SLOT (COPY-LIST SLOT))
				 (WHEN (GETF (CDR SLOT) :INITFUNCTION)
				   (SETF (GETF (CDR SLOT) :INITFUNCTION)
					 #'(LAMBDA ()
					     (ERROR "Can't run compile-time initfunctions."))))
				 SLOT)
			     SLOTS)
	    ,@(AND (NOT (EQ TYPE 'STRUCTURE-OBJECT))
		   `('DEFSTRUCT-NAMED ,NAMED))
	    ))
	(ENSURE-DEFSTRUCT
	  ',NAME ',TYPE ',INCLUDED-STRUCTURE NIL
	  :DOCUMENTATION ,DOCUMENTATION
	  ;; INITFUNCTIONs need special treatment.
	  :SLOTS (LIST ,@(MAPCAR #'(LAMBDA (SLOT)
				     (DESTRUCTURING-BIND (NAME &REST KEYS &KEY INITFUNCTION &ALLOW-OTHER-KEYS) SLOT
				       (COND (INITFUNCTION
					      (SETF KEYS (COPY-LIST KEYS))
					      (REMF KEYS :INITFUNCTION)
					      `(LIST* ',NAME :INITFUNCTION ,INITFUNCTION ',KEYS))
					     (T
					      `',SLOT))))
				 SLOTS))
	  ,@(IF (EQ TYPE 'STRUCTURE-OBJECT)
		`('PRINT-FUNCTION
		  ,(AND PRINT-FUNCTION
			`#'(LAMBDA (.OBJECT. .STREAM.)
			     #+Genera (DECLARE (SYS:FUNCTION-NAME
						 (STRUCTURE-PRINT-FUNCTION ,NAME)))
			     (FUNCALL #',PRINT-FUNCTION .OBJECT. .STREAM. 0)))
		  #+Minima
		  ,@(AND STORAGE-CATEGORY
			 `('MINIMA-INTERNALS::STORAGE-CATEGORY
			   ',STORAGE-CATEGORY))
		  )
		`('DEFSTRUCT-NAMED ,NAMED))
	  'STANDARD-CONSTRUCTOR ',STANDARD-CONSTRUCTOR
	  #+Minima #+Minima
	  'FUNCTIONS ',(LIST* COPIER PREDICATE (MAP 'LIST #'CAR CONSTRUCTORS))
	  )
	,@(FUNCALL (CASE TYPE-NAME
		     ((LIST) #'DEFSTRUCT-BUILD-LIST-FUNCTIONS)
		     ((VECTOR) #'DEFSTRUCT-BUILD-VECTOR-FUNCTIONS)
		     ((STRUCTURE-OBJECT) #'DEFSTRUCT-BUILD-STRUCTURE-OBJECT-FUNCTIONS)
		     (OTHERWISE #'DEFSTRUCT-BUILD-FUNCTIONS))
		   TYPE-NAME TYPE-ARGS ENV 'NAME NAME :SLOTS SLOTS 'DEFSTRUCT-NAMED NAMED
		   :DOCUMENTATION DOCUMENTATION :INCLUDED-STRUCTURE INCLUDED-STRUCTURE
		   :CONC-NAME CONC-NAME :CONSTRUCTORS CONSTRUCTORS
		   :COPIER COPIER :PREDICATE PREDICATE :PRINT-FUNCTION PRINT-FUNCTION
		   #+Minima 'MINIMA-INTERNALS::STORAGE-CATEGORY #+Minima STORAGE-CATEGORY
		   )
	',NAME))))

(DEFUN AINTERN (&REST STRINGS)
  (DECLARE (DYNAMIC-EXTENT STRINGS))
  (INTERN (APPLY #'CONCATENATE 'STRING (MAPCAR #'STRING STRINGS)) *PACKAGE*))

(DEFUN PARSE-DEFSTRUCT (NAME-AND-OPTIONS SLOT-DESCRIPTIONS ENV)
  (LET ((TYPE NIL)
	(NAMED NIL)
	(DOCUMENTATION NIL)
	(INCLUDED-STRUCTURE NIL)
	(CONC-NAME T)
	(INCLUDED-SLOT-SPECS NIL)
	(INITIAL-OFFSET NIL)
	(CONSTRUCTORS NIL)
	(DEFAULT-CONSTRUCTOR NIL)
	(NO-CONSTRUCTOR NIL)
	(COPIER T)
	(PREDICATE T)
	(PREDICATE-SEEN NIL)
	(PRINT-FUNCTION NIL)
	(SLOTS NIL)
	(MAXIMUM-OFFSET 0)
	(STANDARD-CONSTRUCTOR NIL)
	#+Minima (STORAGE-CATEGORY NIL))
    (MULTIPLE-VALUE-BIND (NAME OPTIONS)
	(ETYPECASE NAME-AND-OPTIONS
	  (SYMBOL (VALUES NAME-AND-OPTIONS NIL))
	  (CONS (VALUES (FIRST NAME-AND-OPTIONS) (REST NAME-AND-OPTIONS))))
      (CHECK-TYPE NAME (AND SYMBOL (NOT NULL)))
      (LET ((CONC-NAME-SEEN NIL)
	    (COPIER-SEEN NIL))
	(DOLIST (OPTION OPTIONS)
	  (MULTIPLE-VALUE-BIND (KEYWORD ARGUMENTS)
	      (ETYPECASE OPTION
		(SYMBOL (VALUES OPTION NIL))
		(CONS (VALUES (FIRST OPTION) (REST OPTION))))
	    (ECASE KEYWORD
	      (:CONC-NAME
		(WHEN CONC-NAME-SEEN
		  (ERROR ":CONC-NAME may appear only once."))
		(SETF CONC-NAME-SEEN T)
		(DESTRUCTURING-BIND (&OPTIONAL (CONC-NAME-ARG NIL ARGP)) ARGUMENTS
		  (WHEN ARGP
		    (SETF CONC-NAME (ETYPECASE CONC-NAME-ARG
				      (NULL NIL)
				      (STRING CONC-NAME-ARG)
				      (SYMBOL (SYMBOL-NAME CONC-NAME-ARG)))))))
	      (:CONSTRUCTOR
		(DESTRUCTURING-BIND (&OPTIONAL (CONSTRUCTOR NIL CONSTRUCTOR-P)
					       (CONSTRUCTOR-ARGS NIL ARGS-P)) ARGUMENTS
		  (COND ((AND CONSTRUCTOR-P (NULL CONSTRUCTOR) (NOT ARGS-P))
			 (WHEN (OR CONSTRUCTORS DEFAULT-CONSTRUCTOR)
			   (ERROR "(:CONSTRUCTOR NIL) must be the only constructor option."))
			 (SETF NO-CONSTRUCTOR T))
			(NO-CONSTRUCTOR
			 (ERROR "(:CONSTRUCTOR NIL) must be the only constructor option."))
			((NOT CONSTRUCTOR-P)
			 (WHEN DEFAULT-CONSTRUCTOR
			   (ERROR "The default :CONSTRUCTOR may only be specified once."))
			 (SETF DEFAULT-CONSTRUCTOR T))
			((NOT ARGS-P)
			 (CHECK-TYPE CONSTRUCTOR (AND SYMBOL (NOT NULL)))
			 (PUSH `(,CONSTRUCTOR T) CONSTRUCTORS)
			 (SETF STANDARD-CONSTRUCTOR CONSTRUCTOR))
			(T
			 (CHECK-TYPE CONSTRUCTOR (AND SYMBOL (NOT NULL)))
			 (CHECK-TYPE CONSTRUCTOR-ARGS LIST)
			 (PUSH `(,CONSTRUCTOR ,CONSTRUCTOR-ARGS) CONSTRUCTORS)))))
	      (:COPIER
		(WHEN COPIER-SEEN
		  (ERROR ":COPIER may appear only once."))
		(SETF COPIER-SEEN T)
		(DESTRUCTURING-BIND (&OPTIONAL (COPIER-ARG NIL ARGP)) ARGUMENTS
		  (WHEN ARGP
		    (SETF COPIER COPIER-ARG)
		    (CHECK-TYPE COPIER SYMBOL))))
	      (:PREDICATE
		(WHEN PREDICATE-SEEN
		  (ERROR ":PREDICATE may appear only once."))
		(SETF PREDICATE-SEEN T)
		(DESTRUCTURING-BIND (&OPTIONAL (PREDICATE-ARG NIL ARGP)) ARGUMENTS
		  (WHEN ARGP
		    (SETF PREDICATE PREDICATE-ARG)
		    (CHECK-TYPE PREDICATE SYMBOL))))
	      (:INCLUDE
		(WHEN INCLUDED-STRUCTURE
		  (ERROR ":INCLUDE may appear only once."))
		(DESTRUCTURING-BIND (STRUCTURE-ARG &REST SLOT-SPECS) ARGUMENTS
		  (SETF INCLUDED-STRUCTURE STRUCTURE-ARG)
		  (SETF INCLUDED-SLOT-SPECS SLOT-SPECS)))
	      (:PRINT-FUNCTION
		(WHEN PRINT-FUNCTION
		  (ERROR ":PRINT-FUNCTION may appear only once."))
		(DESTRUCTURING-BIND (&OPTIONAL (PRINT-ARG 'DEFAULT-PRINT-STRUCTURE)) ARGUMENTS
		  (SETF PRINT-FUNCTION PRINT-ARG)
		  (CHECK-TYPE PRINT-FUNCTION (NOT (NULL)))))
	      (:TYPE
		(WHEN TYPE
		  (ERROR ":TYPE may appear only once."))
		(DESTRUCTURING-BIND (TYPE-ARG) ARGUMENTS
		  (SETF TYPE TYPE-ARG)))
	      (:NAMED
		(WHEN NAMED
		  (ERROR ":NAMED may appear only once."))
		(DESTRUCTURING-BIND () ARGUMENTS
		  (SETF NAMED T)))
	      (:INITIAL-OFFSET
		(WHEN INITIAL-OFFSET
		  (ERROR ":INITIAL-OFFSET may appear only once."))
		(DESTRUCTURING-BIND (OFFSET-ARG) ARGUMENTS
		  (SETF INITIAL-OFFSET OFFSET-ARG)
		  (CHECK-TYPE INITIAL-OFFSET (INTEGER 0 *))))
	      #+Minima
	      (MINIMA-INTERNALS::STORAGE-CATEGORY
		(WHEN STORAGE-CATEGORY
		  (ERROR "~S may appear only once." 'MINIMA-INTERNALS::STORAGE-CATEGORY))
		(DESTRUCTURING-BIND (CATEGORY) ARGUMENTS
		  (SETF STORAGE-CATEGORY CATEGORY)
		  (CHECK-TYPE STORAGE-CATEGORY (MEMBER :SAFEGUARDED :WIRED))))
	      ))))
      ;; Do defaulting
      (WHEN (EQ CONC-NAME T)
	(SETF CONC-NAME (CONCATENATE 'STRING (SYMBOL-NAME NAME) "-")))
      (WHEN (AND (NULL CONSTRUCTORS) (NOT NO-CONSTRUCTOR))
	(SETF DEFAULT-CONSTRUCTOR T))
      (WHEN DEFAULT-CONSTRUCTOR
	(SETF STANDARD-CONSTRUCTOR (AINTERN "MAKE-" NAME))
	(PUSH `(,STANDARD-CONSTRUCTOR T) CONSTRUCTORS))
      (WHEN (EQ COPIER T)
	(SETF COPIER (AINTERN "COPY-" NAME)))
      (WHEN (NULL TYPE)
	(SETF TYPE 'STRUCTURE-OBJECT)
	(SETF NAMED T))
      (WHEN (AND PREDICATE-SEEN PREDICATE (NOT NAMED))
	(ERROR "You cannot specify a predicate unless the structure is named."))
      (WHEN (EQ PREDICATE T)
	(SETF PREDICATE (AND NAMED (AINTERN NAME "-P"))))
      (UNLESS INITIAL-OFFSET
	(SETF INITIAL-OFFSET 0))
      (WHEN (AND PRINT-FUNCTION (NOT (EQ TYPE 'STRUCTURE-OBJECT)))
	(ERROR "You cannot specify a print function for a typed structure."))
      ;; Parse slot descriptions
      (CHECK-TYPE SLOT-DESCRIPTIONS LIST)
      ;; Get the documentation string.
      (WHEN (STRINGP (FIRST SLOT-DESCRIPTIONS))
	(SETF DOCUMENTATION (POP SLOT-DESCRIPTIONS)))
      ;; Collect slots
      ;; First for the included structure.
      (WHEN INCLUDED-STRUCTURE
	(MULTIPLE-VALUE-SETQ (SLOTS MAXIMUM-OFFSET)
	  (PARSE-INCLUDED-SLOTS SLOTS MAXIMUM-OFFSET
				NAME TYPE NAMED INCLUDED-STRUCTURE INCLUDED-SLOT-SPECS ENV)))
      ;; Now for the local slots
      (INCF MAXIMUM-OFFSET INITIAL-OFFSET)
      (MULTIPLE-VALUE-SETQ (SLOTS MAXIMUM-OFFSET)
	(PARSE-LOCAL-SLOTS SLOTS MAXIMUM-OFFSET NAME SLOT-DESCRIPTIONS ENV))
      ;; Get them in order
      (SETF SLOTS (REVERSE SLOTS))
      (VALUES NAME
	      SLOTS
	      TYPE
	      NAMED
	      DOCUMENTATION
	      INCLUDED-STRUCTURE
	      CONC-NAME
	      CONSTRUCTORS
	      COPIER
	      PREDICATE
	      PRINT-FUNCTION
	      STANDARD-CONSTRUCTOR
	      #+Minima STORAGE-CATEGORY
	      ))))

(DEFUN PARSE-INCLUDED-SLOTS (SLOTS MAXIMUM-OFFSET
			     DEFSTRUCT-NAME DEFSTRUCT-TYPE DEFSTRUCT-NAMED
			     INCLUDED-STRUCTURE INCLUDED-SLOT-SPECS ENV)
  (DESTRUCTURING-BIND (I-TYPE I-INCLUDED-STRUCTURE I-ENVIRONMENT &KEY
			      ((DEFSTRUCT-NAMED I-NAMED)) ((:SLOTS I-SLOTS)) &ALLOW-OTHER-KEYS)
      (LOOKUP-STRUCTURE-INFORMATION INCLUDED-STRUCTURE ENV)
    (DECLARE (IGNORE I-INCLUDED-STRUCTURE I-ENVIRONMENT))
    (WHEN (NOT (EQUAL I-TYPE DEFSTRUCT-TYPE))
      (ERROR "Included structure has a different representation type."))
    (WHEN (AND DEFSTRUCT-NAMED (NOT I-NAMED) (NOT (EQ DEFSTRUCT-TYPE 'STRUCTURE-OBJECT)))
      (ERROR "Included structure is not named."))
    (DOLIST (ISLOTD I-SLOTS)
      (DESTRUCTURING-BIND (SLOT-NAME &KEY INITFORM INITFUNCTION
				     ((INITFORM-INLINABLE INITFORM-INLINABLE) 'CONSTANT)
				     #+(OR Genera Minima) ((SLOT-LOCATABLE LOCATABLE) NIL)
				     (TYPE T) READ-ONLY LOCATION (SIZE 1) &ALLOW-OTHER-KEYS)
	  ISLOTD
	(WHEN INITFUNCTION
	  (CASE INITFORM-INLINABLE
	    (CONSTANT
	      (SETF INITFUNCTION `(CONSTANTLY ,INITFORM)))
	    #+Genera
	    (SPECIAL
	      (SETF INITFUNCTION `(SPECIAL-VARIABLE-VALUE ',INITFORM)))
	    (OTHERWISE
	      (SETF INITFUNCTION `(STRUCTURE-SLOT-INITFUNCTION ',INCLUDED-STRUCTURE ',SLOT-NAME))
	      (SETF INITFORM `(FUNCALL (LOAD-TIME-VALUE ,INITFUNCTION T))))))
	(LET ((ISPEC (ASSOC SLOT-NAME INCLUDED-SLOT-SPECS)))
	  (WHEN ISPEC
	    (SETF INITFUNCTION NIL)
	    (SETF ISPEC (REST ISPEC))
	    (WHEN (NOT (NULL ISPEC))
	      (SETF INITFORM (POP ISPEC))
	      (SETF INITFORM-INLINABLE (INITFORM-INLINABLE INITFORM ENV))
	      (SETF INITFUNCTION
		    (MAKE-INITFUNCTION INITFORM ENV 'STRUCTURE-SLOT-INITFUNCTION DEFSTRUCT-NAME SLOT-NAME))
	      (WHEN (NOT (NULL ISPEC))
		(LET ((TYPE-SEEN NIL)
		      (READ-ONLY-SEEN NIL)
		      #+(OR Genera Minima) (LOCATABLE-SEEN NIL))
		  (LOOP
		    (WHEN (ENDP ISPEC) (RETURN))
		    (LET ((KEYWORD (POP ISPEC)))
		      (WHEN (ENDP ISPEC)
			(ERROR "The value after the keyword ~S is missing." KEYWORD))
		      (LET ((VALUE (POP ISPEC)))
			(ECASE KEYWORD
			  (:READ-ONLY
			    (WHEN READ-ONLY-SEEN
			      (ERROR ":READ-ONLY specified more than once."))
			    (SETF READ-ONLY-SEEN T)
			    (COND (VALUE
				   (SETF READ-ONLY T))
				  (READ-ONLY
				   (ERROR "You cannot make an included slot writable."))))
			  (:TYPE
			    (WHEN TYPE-SEEN
			      (ERROR ":TYPE specified more than once."))
			    (SETF TYPE-SEEN T)
			    ;; This should pass in the environment to we look at the right types.
			    (MULTIPLE-VALUE-BIND (SUBTYPEP FOR-SURE)
				(SUBTYPEP VALUE TYPE)
			      (WHEN (AND (NOT SUBTYPEP) FOR-SURE)
				(WARN "~S is not a subtype of ~S." VALUE TYPE)))
			    (SETF TYPE VALUE))
			  #+(OR Genera Minima)
			  (LOCATABLE
			    (WHEN LOCATABLE-SEEN
			      (ERROR "~S specified more than once." 'LOCATABLE))
			    (SETF LOCATABLE-SEEN T)
			    (SETF LOCATABLE VALUE))
			  )))))))))
	(PUSH `(,SLOT-NAME :LOCATION ,LOCATION
		,@(WHEN INITFUNCTION
		    `(:INITFUNCTION ,INITFUNCTION
		      :INITFORM ,INITFORM
		      INITFORM-INLINABLE ,INITFORM-INLINABLE))
		,@(UNLESS (EQ TYPE T)
		    `(:TYPE ,TYPE))
		,@(WHEN READ-ONLY
		    `(SLOT-READ-ONLY ,READ-ONLY))
		,@(UNLESS (= SIZE 1)
		    `(SLOT-SIZE ,SIZE))
		#+(OR Genera Minima)
		,@(WHEN LOCATABLE
		    `(SLOT-LOCATABLE ,LOCATABLE))
		)
	      SLOTS)
	(SETF MAXIMUM-OFFSET (MAX MAXIMUM-OFFSET (+ LOCATION SIZE)))))
    (DOLIST (ISPEC INCLUDED-SLOT-SPECS)
      (UNLESS (ASSOC (FIRST ISPEC) SLOTS)
	(ERROR ":INCLUDE slot ~S not found in included structure." (FIRST ISPEC))))
    (VALUES SLOTS MAXIMUM-OFFSET)))

(DEFUN PARSE-LOCAL-SLOTS (SLOTS MAXIMUM-OFFSET DEFSTRUCT-NAME SLOT-DESCRIPTIONS ENV)
  (DOLIST (SPEC SLOT-DESCRIPTIONS)
    (MULTIPLE-VALUE-BIND (SLOT-NAME REST)
	(ETYPECASE SPEC
	  (SYMBOL (VALUES SPEC NIL))
	  (CONS (VALUES (FIRST SPEC) (REST SPEC))))
      (WHEN (ASSOC (SYMBOL-NAME SLOT-NAME) SLOTS :KEY #'SYMBOL-NAME :TEST #'STRING=)
	(ERROR "The slot ~A appears more than once." SLOT-NAME))
      (LET ((LOCATION MAXIMUM-OFFSET)
	    (SIZE 1)
	    (TYPE T)
	    (READ-ONLY NIL)
	    INITFORM
	    (INITFUNCTION NIL)
	    INITFORM-INLINABLE
	    #+(OR Genera Minima) (LOCATABLE NIL))
	(WHEN (NOT (NULL REST))
	  (SETF INITFORM (POP REST))
	  (SETF INITFORM-INLINABLE (INITFORM-INLINABLE INITFORM ENV))
	  (SETF INITFUNCTION
		(MAKE-INITFUNCTION INITFORM ENV 'STRUCTURE-SLOT-INITFUNCTION DEFSTRUCT-NAME SLOT-NAME))
	  (WHEN (NOT (NULL REST))
	    (LET ((TYPE-SEEN NIL)
		  (READ-ONLY-SEEN NIL)
		  #+(OR Genera Minima) (LOCATABLE-SEEN NIL))
	      (LOOP
		(WHEN (ENDP REST) (RETURN))
		(LET ((KEYWORD (POP REST)))
		  (WHEN (ENDP REST)
		    (ERROR "The value after the keyword ~S is missing." KEYWORD))
		  (LET ((VALUE (POP REST)))
		    (ECASE KEYWORD
		      (:TYPE
			(WHEN TYPE-SEEN
			  (ERROR ":TYPE specified more than once."))
			(SETF TYPE-SEEN T)
			(SETF TYPE VALUE))
		      (:READ-ONLY
			(WHEN READ-ONLY-SEEN
			  (ERROR ":READ-ONLY specified more than once."))
			(SETF READ-ONLY-SEEN T)
			(SETF READ-ONLY VALUE))
		      #+(OR Genera Minima)
		      (LOCATABLE
			(WHEN LOCATABLE-SEEN
			  (ERROR "~S specified more than once." 'LOCATABLE))
			(SETF LOCATABLE-SEEN T)
			(SETF LOCATABLE VALUE))
		      )))))))
	(PUSH `(,SLOT-NAME :LOCATION ,LOCATION
		,@(WHEN INITFUNCTION
		    `(:INITFUNCTION ,INITFUNCTION
		      :INITFORM ,INITFORM
		      INITFORM-INLINABLE ,INITFORM-INLINABLE))
		,@(UNLESS (EQ TYPE T)
		    `(:TYPE ,TYPE))
		,@(WHEN READ-ONLY
		    `(SLOT-READ-ONLY ,READ-ONLY))
		,@(UNLESS (= SIZE 1)
		    `(SLOT-SIZE ,SIZE))
		#+(OR Genera Minima)
		,@(WHEN LOCATABLE
		    `(SLOT-LOCATABLE ,LOCATABLE))
		)
	      SLOTS)
	(SETF MAXIMUM-OFFSET (MAX MAXIMUM-OFFSET (+ LOCATION SIZE))))))
  (VALUES SLOTS MAXIMUM-OFFSET))



(DEFUN SIZE-FROM-SLOTS (SLOTS)
  (REDUCE #'MAX SLOTS
	  :KEY #'(LAMBDA (SLOT)
		   (DESTRUCTURING-BIND (NAME &KEY LOCATION ((SLOT-SIZE SIZE) 1)
					     &ALLOW-OTHER-KEYS) SLOT
		     (DECLARE (IGNORE NAME))
		     (+ LOCATION SIZE)))
	  :INITIAL-VALUE 0))

(DEFUN DEFSTRUCT-COMPUTE-CONSTRUCTOR
       (CONSTRUCTOR-ARGS SLOTS &KEY (DEFAULT-VALUE NIL DEFAULT-VALUE-P) SIMPLE-ONLY)
  #+Genera (DECLARE (VALUES ARGLIST SIZE SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM SIMPLE-BINDINGS LEXICALS STORAGE-AREA))
  (LET* ((SIZE (SIZE-FROM-SLOTS SLOTS))
	 (SLOT-VECTOR (MAKE-ARRAY SIZE :INITIAL-ELEMENT NIL))
	 (SLOT-INITIALIZED (MAKE-ARRAY SIZE :INITIAL-ELEMENT NIL))
	 (SLOT-INITFORM (MAKE-ARRAY SIZE))
	 (LEXICALS NIL)
	 (ARGS NIL)
	 (BINDINGS NIL)
	 #+(OR Genera CLOE-Runtime Minima) (STORAGE-AREA NIL)
	 )
    (COND ((EQ CONSTRUCTOR-ARGS T)
	   (PUSH '&KEY ARGS)
	   (DOLIST (SLOT SLOTS)
	     (DESTRUCTURING-BIND (NAME &KEY INITFUNCTION INITFORM LOCATION &ALLOW-OTHER-KEYS)
		 SLOT
	       (LET ((TVAR (MAKE-SYMBOL (SYMBOL-NAME NAME))))
		 (SETF (SVREF SLOT-VECTOR LOCATION) SLOT)
		 (PUSH TVAR LEXICALS)
		 (SETF (SVREF SLOT-INITFORM LOCATION) TVAR)
		 (PUSH (COND (INITFUNCTION
			       (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
			       `(,TVAR ,INITFORM))
			     (DEFAULT-VALUE-P
			       (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
			       `(,TVAR ',DEFAULT-VALUE))
			     (T
			       (LET ((TEMP (GENSYM)))
				 (SETF (SVREF SLOT-INITIALIZED LOCATION) TEMP)
				 (PUSH TEMP LEXICALS)
				 `(,TVAR NIL ,TEMP))))
		       ARGS))))
	   #+(OR CLOE-Runtime Genera)
	   (PROGN
	     (PUSH '((STORAGE-AREA STORAGE-AREA)
		     #+Genera SYS:*DEFAULT-CONS-AREA*
		     #+Minima T 
		     #+CLOE-Runtime SYS::AKIND$K-DEFAULT
		     )
		   ARGS)
	     (SETQ STORAGE-AREA 'STORAGE-AREA)))
	  (T
	    (LET ((SLOTS-DONE NIL))
	      (LET ((STATE NIL))
		(DOLIST (ARG CONSTRUCTOR-ARGS)
		  (BLOCK DOARG
		    (WHEN (MEMBER ARG LAMBDA-LIST-KEYWORDS)
		      (PUSH (SETF STATE ARG) ARGS)
		      (RETURN-FROM DOARG))
		    (MULTIPLE-VALUE-BIND (NAME INITP KEYWORD)
			(ETYPECASE ARG
			  (SYMBOL
			    (VALUES ARG NIL ARG))
			  (CONS
			    (DESTRUCTURING-BIND (NAME &OPTIONAL (INIT NIL INITP) SUPPLIED-P) ARG
			      (DECLARE (IGNORE INIT SUPPLIED-P))
			      (ETYPECASE NAME
				(SYMBOL
				  (VALUES NAME INITP NAME))
				(CONS
				  (VALUES (SECOND NAME) INITP NAME))))))
		      (LET ((SLOT (ASSOC NAME SLOTS)))
			(WHEN (NULL SLOT)
			  (PUSH ARG ARGS)
			  #+(OR CLOE-Runtime Genera Minima)
			  (WHEN (EQ NAME 'STORAGE-AREA)
			    (SETQ STORAGE-AREA NAME))
			  (RETURN-FROM DOARG))
			(PUSH SLOT SLOTS-DONE)
			(DESTRUCTURING-BIND (NAME &KEY LOCATION INITFUNCTION INITFORM ((INITFORM-INLINABLE INITFORM-INLINABLE) 'CONSTANT) &ALLOW-OTHER-KEYS) SLOT
			  (SETF (SVREF SLOT-VECTOR LOCATION) SLOT)
			  (COND ((OR (NULL STATE) INITP)
				 (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
				 (PUSH NAME LEXICALS)
				 (SETF (SVREF SLOT-INITFORM LOCATION) NAME)
				 (PUSH ARG ARGS))
				(T
				  (ECASE STATE
				    ((&OPTIONAL &KEY)
				     (COND (INITFUNCTION
					     (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
					     (PUSH NAME LEXICALS)
					     (SETF (SVREF SLOT-INITFORM LOCATION) NAME)
					     (WHEN (NULL INITFORM-INLINABLE)
					       (SETF INITFORM `(FUNCALL ,INITFUNCTION)))
					     (PUSH `(,KEYWORD ,INITFORM) ARGS))
					   (DEFAULT-VALUE-P
					     (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
					     (PUSH NAME LEXICALS)
					     (SETF (SVREF SLOT-INITFORM LOCATION) NAME)
					     (PUSH `(,KEYWORD ',DEFAULT-VALUE) ARGS))
					   (T
					     (LET ((TEMP (GENSYM)))
					       (PUSH TEMP LEXICALS)
					       (SETF (SVREF SLOT-INITIALIZED LOCATION) TEMP)
					       (PUSH NAME LEXICALS)
					       (SETF (SVREF SLOT-INITFORM LOCATION) NAME)
					       (PUSH `(,KEYWORD NIL ,TEMP) ARGS)))))
				    ((&AUX))
				    ((&REST)
				     (LET ((TEMP (GENSYM)))
				       (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
				       (SETF (SVREF SLOT-INITFORM LOCATION) TEMP)
				       (PUSH `(,TEMP ,ARG) BINDINGS)
				       (PUSH ARG ARGS)))
				    )))))))))
	      (DOLIST (SLOT SLOTS)
		(UNLESS (MEMBER SLOT SLOTS-DONE)
		  (DESTRUCTURING-BIND (NAME &KEY LOCATION INITFUNCTION INITFORM
					    ((INITFORM-INLINABLE INITFORM-INLINABLE) 'CONSTANT)
					    &ALLOW-OTHER-KEYS)
		      SLOT
		    (DECLARE (IGNORE NAME))
		    (SETF (SVREF SLOT-VECTOR LOCATION) SLOT)
		    (WHEN INITFUNCTION
		      (SETF (SVREF SLOT-INITIALIZED LOCATION) T)
		      (WHEN (NULL INITFORM-INLINABLE)
			(SETF INITFORM `(FUNCALL ,INITFUNCTION)))
		      (COND ((AND SIMPLE-ONLY (NOT (EQ INITFORM-INLINABLE 'CONSTANT)))
			     (LET ((TEMP (GENSYM)))
			       (PUSH `(,TEMP ,INITFORM) BINDINGS)
			       (SETF (SVREF SLOT-INITFORM LOCATION) TEMP)))
			    (T
			      (SETF (SVREF SLOT-INITFORM LOCATION) INITFORM))))))))))
    (VALUES (REVERSE ARGS) SIZE SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM
	    (REVERSE BINDINGS) (REVERSE LEXICALS) #+(OR CLOE-Runtime Genera Minima) STORAGE-AREA)))

#+Minima
(DEFUN COMPUTE-ACCESSOR-NAMES (SLOTS CONC-NAME)
  (MAPCAR #'(LAMBDA (SLOT)
	      (DESTRUCTURING-BIND (NAME &KEY &ALLOW-OTHER-KEYS) SLOT
		(SETF (GETF (CDR SLOT) 'SLOT-ACCESSOR)
		      (IF CONC-NAME (AINTERN CONC-NAME NAME) NAME))))
	  SLOTS))

(DEFUN DEFSTRUCT-COMPUTE-ACCESSORS (TYPE REF-MACRO CONC-NAME SLOTS OFFSET)
  #-(OR Genera CLOE-Runtime Minima) (DECLARE (IGNORE TYPE))
  #+Minima (DECLARE (IGNORE CONC-NAME))
  (MAPCAR #'(LAMBDA (SLOT)
	      (DESTRUCTURING-BIND (NAME &KEY LOCATION ((SLOT-READ-ONLY READ-ONLY))
					#+(OR Genera Minima) ((SLOT-LOCATABLE LOCATABLE))
					#+Minima ((SLOT-ACCESSOR ACCESSOR))
					&ALLOW-OTHER-KEYS)
		  SLOT
		#+Minima (DECLARE (IGNORE NAME))
		(LET (#-Minima (ACCESSOR (IF CONC-NAME (AINTERN CONC-NAME NAME) NAME))
		      (LOCATION (+ LOCATION OFFSET)))
		  #-(OR Genera CLOE-Runtime Minima)
		  `(PROGN
		     (DEFSUBST ,ACCESSOR (STRUCTURE)
		       (,REF-MACRO STRUCTURE ',LOCATION))
		     ,@(UNLESS READ-ONLY
			 `((DEFSUBST (SETF ,ACCESSOR) (VALUE STRUCTURE)
			     (SETF (,REF-MACRO STRUCTURE ',LOCATION) VALUE))))
		     #+(OR Genera Minima)
		     ,@(WHEN LOCATABLE
			 `((DEFSUBST (LOCF ,ACCESSOR) (STRUCTURE)
			     (LOCF (,REF-MACRO STRUCTURE ',LOCATION)))))
		     )
		  #+(OR Genera CLOE-Runtime Minima)
		  (FLET ((DEF-IT (FSPEC)
			   `(PROGN
			      (EVAL-WHEN (:COMPILE-TOPLEVEL)
				(DEF-DEFSTRUCT-ACCESSOR-2 ',FSPEC ',TYPE ',REF-MACRO ,LOCATION))
			      (DEF-DEFSTRUCT-ACCESSOR-1 ',FSPEC ',TYPE ',REF-MACRO ,LOCATION))))
		    `(PROGN
		       ,(DEF-IT ACCESSOR)
		       ,@(UNLESS READ-ONLY
			   `(,(DEF-IT `(SETF ,ACCESSOR))))
		       #+(OR Genera Minima)
		       ,@(WHEN LOCATABLE
			   `(,(DEF-IT `(LOCF ,ACCESSOR)))))))))
	  SLOTS))

#+(OR Genera Minima CLOE-Runtime)
(DEFUN DEF-DEFSTRUCT-ACCESSOR-2 (FSPEC TYPE REF-MACRO LOCATION)
  (DECLARE (IGNORE TYPE))
  #+CLOE-Runtime (COND ((SYMBOLP FSPEC)
		(SETF (SYS::FUNCTION-NAME-GET FSPEC 'COMPILER::REDUCER)
		      '(CLOS-DEFSTRUCT-FETCH-REDUCER))
		(SETF (SYS::FUNCTION-NAME-GET FSPEC 'ACCESS-INFO)
		      `(,LOCATION . ,REF-MACRO)))
	       (T
		(SETF (SYS::FUNCTION-NAME-GET (SECOND FSPEC) 'SETF)
		      `(CLOS-STRUCTURE-SLOT-STORE (,LOCATION . ,REF-MACRO)))))
  #+Genera (COMPILER:FILE-DECLARE FSPEC 'COMPILER:COMPILER-MACRO
				  (MAKE-ACCESSOR-COMPILER-MACRO FSPEC REF-MACRO LOCATION))
  #+Minima (MINIMA-INTERNALS::DEFINE-COMPILER-MACRO-2
	     FSPEC (MAKE-ACCESSOR-COMPILER-MACRO FSPEC REF-MACRO LOCATION))
  FSPEC)

#+CLOE-Runtime
(DEFMACRO CLOS-STRUCTURE-SLOT-STORE (DATA THING VALUE)
  `(SETF (,(CDR DATA) ,THING ,(CAR DATA)) ,VALUE))

#+CLOE-Runtime
(DEFUN CLOS-DEFSTRUCT-FETCH-REDUCER (FORM)
  (IF (AND (CONSP FORM)
	   (CONSP (CDR FORM))
	   (NULL (CDDR FORM)))
      (LET ((DATA (SYS::FUNCTION-NAME-GET (FIRST FORM) 'ACCESS-INFO)))
	`(,(CDR DATA) ,(SECOND FORM) ,(CAR DATA)))
      FORM))

;;; LIST

(DEFUN DEFSTRUCT-BUILD-LIST-FUNCTIONS
       (TYPE-NAME TYPE-ARGS ENV
		  &KEY ((NAME NAME)) SLOTS CONC-NAME CONSTRUCTORS COPIER PREDICATE
		  ((DEFSTRUCT-NAMED NAMED)) &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE TYPE-NAME TYPE-ARGS ENV))
  `(,@(LOOP FOR (CONSTRUCTOR CONSTRUCTOR-ARGS) IN CONSTRUCTORS
	    COLLECT
	      (MULTIPLE-VALUE-BIND (ARGS SIZE SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM
					 SIMPLE-BINDINGS LEXICALS
					 #+(OR CLOE-Runtime Genera Minima) STORAGE-AREA)
		  (DEFSTRUCT-COMPUTE-CONSTRUCTOR CONSTRUCTOR-ARGS SLOTS :DEFAULT-VALUE NIL)
		(DECLARE (IGNORE SLOT-VECTOR SIMPLE-BINDINGS LEXICALS))
		`(DEFSUBST ,CONSTRUCTOR ,ARGS
		   ,(IF (AND (< SIZE LAMBDA-PARAMETERS-LIMIT)
			     #+(OR Genera Minima) (NULL STORAGE-AREA))
			`(LIST ,@(AND NAMED `(',NAME))
			       ,@(MAP 'LIST #'(LAMBDA (INITIALIZED INITFORM)
						(AND INITIALIZED INITFORM))
				      SLOT-INITIALIZED SLOT-INITFORM))
			(LET ((LIST-SIZE (+ SIZE (IF NAMED 1 0))))
			  `(LET* ((LIST #+Genera
					(LISP:MAKE-LIST ,LIST-SIZE
							,@(AND STORAGE-AREA
							       `(:AREA ,STORAGE-AREA)))
					#+Minima
					(IF (EQ ,(OR STORAGE-AREA T) T)
					    (MAKE-LIST ,LIST-SIZE)
					    (MINIMA-INTERNALS::%MAKE-LIST-IN-AREA ,STORAGE-AREA ,LIST-SIZE))
					#-(OR Genera Minima)
					(MAKE-LIST ,LIST-SIZE))
				  (TEMP LIST))
			     ,@(WHEN NAMED
				 `((SETF (CAR TEMP) ',NAME)
				   (SETF TEMP (CDR TEMP))))
			     ,@(LET ((CURRENT-POS -1)
				     (LIST-POS 0))
				 (MAP 'LIST #'(LAMBDA (INITIALIZED INITFORM)
						(INCF CURRENT-POS)
						(AND INITIALIZED
						     `(PROGN (SETF TEMP (NTHCDR ,(- CURRENT-POS (SHIFTF LIST-POS CURRENT-POS)) TEMP))
							     (SETF (CAR TEMP) ,INITFORM))))
				      SLOT-INITIALIZED SLOT-INITFORM))
			     LIST))))))
    ,(AND COPIER
	  #+Genera `(SYS:DEFF ,COPIER #'COPY-LIST)
	  #+Minima `(MINIMA-INTERNALS::DEFUN-1 ',COPIER #'COPY-LIST NIL)
	  #-(OR Genera Minima)
	  `(DEFSUBST ,COPIER (STRUCTURE)
	     (COPY-LIST STRUCTURE)))
    ,(AND PREDICATE
	  `(DEFSUBST ,PREDICATE (STRUCTURE)
	     (AND (CONSP STRUCTURE)
		  (LET ((NAME (FIRST STRUCTURE)))
		    (OR (EQ NAME ',NAME)
			(STRUCTURE-SUBTYPEP NAME ',NAME))))))
    ,@(DEFSTRUCT-COMPUTE-ACCESSORS 'LIST 'DEFSTRUCT-LIST-REF CONC-NAME SLOTS (IF NAMED 1 0))))

;;; VECTOR

(DEFUN DEFSTRUCT-BUILD-VECTOR-FUNCTIONS
       (TYPE-NAME TYPE-ARGS ENV
	&KEY ((NAME NAME)) SLOTS CONC-NAME CONSTRUCTORS COPIER PREDICATE
	((DEFSTRUCT-NAMED NAMED)) &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE TYPE-NAME ENV))
  (DESTRUCTURING-BIND (&OPTIONAL (ELEMENT-TYPE '*)) TYPE-ARGS
    (WHEN (EQ ELEMENT-TYPE '*)
      (SETF ELEMENT-TYPE T))
    `(,@(LOOP FOR (CONSTRUCTOR CONSTRUCTOR-ARGS) IN CONSTRUCTORS
	      COLLECT
		(MULTIPLE-VALUE-BIND (ARGS SIZE SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM
				      SIMPLE-BINDINGS LEXICALS
				      #+(OR CLOE-Runtime Genera Minima) STORAGE-AREA)
		    (DEFSTRUCT-COMPUTE-CONSTRUCTOR CONSTRUCTOR-ARGS SLOTS
		      :DEFAULT-VALUE (IF (SUBTYPEP ELEMENT-TYPE 'INTEGER) 0 NIL))
		  (DECLARE (IGNORE SIMPLE-BINDINGS LEXICALS))
		  `(DEFSUBST ,CONSTRUCTOR ,ARGS
		     ,(IF (AND (EQ ELEMENT-TYPE T)
			       (< SIZE LAMBDA-PARAMETERS-LIMIT)
			       #+(OR CLOE-Runtime Genera Minima) (NULL STORAGE-AREA))
			  `(VECTOR ,@(AND NAMED `(',NAME))
				   ,@(MAP 'LIST #'(LAMBDA (INITIALIZED INITFORM)
						    (AND INITIALIZED INITFORM))
					  SLOT-INITIALIZED SLOT-INITFORM))
			  (LET ((INSTANCE '#:INSTANCE))
			    `(LET ((,INSTANCE
				    #+(OR CLOE-Runtime Genera)
				    (LISP:MAKE-ARRAY ,(IF NAMED (1+ SIZE) SIZE)
						     :ELEMENT-TYPE ',ELEMENT-TYPE
						     ,@(AND STORAGE-AREA
							    `(:AREA ,STORAGE-AREA)))
				    #+Minima
				    (MAKE-ARRAY ,(IF NAMED (1+ SIZE) SIZE)
						:ELEMENT-TYPE ',ELEMENT-TYPE
						'STORAGE-AREA ,STORAGE-AREA)
				    #-(OR CLOE-Runtime Genera Minima)
				    (MAKE-ARRAY ,(IF NAMED (1+ SIZE) SIZE)
						:ELEMENT-TYPE ',ELEMENT-TYPE)))
			       #+Genera (DECLARE (SYS:ARRAY-REGISTER ,INSTANCE))
			       ,(WHEN NAMED
				  `(SETF (AREF ,INSTANCE 0) ',NAME))
			       ,@(LOOP FOR I BELOW SIZE
				       COLLECT (AND (AREF SLOT-VECTOR I)
						    (AREF SLOT-INITIALIZED I)
						    `(SETF (AREF ,INSTANCE ,(IF NAMED (1+ I) I))
							   ,(AREF SLOT-INITFORM I))))
			       ,INSTANCE))))))
      ,(AND COPIER
	    `(DEFSUBST ,COPIER (STRUCTURE)
	       (MAKE-ARRAY (LENGTH STRUCTURE) :ELEMENT-TYPE ',ELEMENT-TYPE
			   :INITIAL-CONTENTS STRUCTURE)))
      ,(AND PREDICATE
	    `(DEFSUBST ,PREDICATE (STRUCTURE)
	       (AND (VECTORP STRUCTURE)
		    (LET ((NAME (AREF STRUCTURE 0)))
		      (OR (EQ NAME ',NAME)
			  (STRUCTURE-SUBTYPEP NAME ',NAME))))))
      ,@(DEFSTRUCT-COMPUTE-ACCESSORS 'VECTOR 'AREF CONC-NAME SLOTS (IF NAMED 1 0)))))

;;; STRUCTURE-OBJECT

(DEFUN MAKE-LOOKUP-STRUCTURE-INSTANCE-INFORMATION
       (NAME #+Minima STORAGE-CATEGORY &OPTIONAL SIZE)
  `(LOAD-TIME-VALUE
     (LOOKUP-STRUCTURE-INSTANCE-INFORMATION
       ',NAME
       #+(OR |3600| Imach) ,(1+ SIZE)
       #-(OR |3600| Imach) ,SIZE
       #+Minima ',STORAGE-CATEGORY)))

(DEFUN DEFSTRUCT-BUILD-STRUCTURE-OBJECT-FUNCTIONS
       (TYPE-NAME TYPE-ARGS ENV
	&KEY ((NAME NAME)) INCLUDED-STRUCTURE SLOTS CONC-NAME CONSTRUCTORS COPIER PREDICATE
	#+Minima ((MINIMA-INTERNALS::STORAGE-CATEGORY STORAGE-CATEGORY))
	&ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE TYPE-NAME TYPE-ARGS))
  (LET* ((SIZE (SIZE-FROM-SLOTS SLOTS))
	 (INFORMATION (MAKE-LOOKUP-STRUCTURE-INSTANCE-INFORMATION
			NAME #+Minima STORAGE-CATEGORY SIZE))
	 #+IMACH (HEADER `(LOAD-TIME-VALUE
			    (SYS:%MAKE-POINTER-OFFSET SYS:DTP-LOCATIVE ,INFORMATION 3))))
    `(,@(LOOP FOR (CONSTRUCTOR CONSTRUCTOR-ARGS) IN CONSTRUCTORS
	      COLLECT
		(MULTIPLE-VALUE-BIND (ARGS SIZE2 SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM
				      SIMPLE-BINDINGS LEXICALS
				      #+(OR CLOE-Runtime Genera Minima) STORAGE-AREA)
		    (DEFSTRUCT-COMPUTE-CONSTRUCTOR CONSTRUCTOR-ARGS SLOTS :SIMPLE-ONLY T)
		  (DECLARE (IGNORE SIZE2))
		  #-IMACH
		  (DECLARE (IGNORE LEXICALS))
		  (LET ((INSTANCE '#:INSTANCE))
		    #+IMACH
		    (LET* ((NULL '#:NULL)
			   (HELPER `(STRUCTURE-CONSTRUCTOR ,NAME))
			   (HELPER-ARGS
			     `(STORAGE-AREA ,@(MAPCAR #'FIRST SIMPLE-BINDINGS) ,@LEXICALS))
			   (HELPER-FORM
			     `(LET* ((,INSTANCE (SYS:%SET-TAG (SYS:%ALLOCATE-STRUCTURE-BLOCK STORAGE-AREA ,(1+ SIZE))
							      SYS:DTP-INSTANCE))
				     ,@(AND (POSITION NIL SLOT-VECTOR)
					    `((,NULL (SYS:%SET-TAG ,INSTANCE SYS:DTP-NULL)))))
				(SYS:%BLOCK-WRITE 1 (SYS:%SET-TAG
						      ,HEADER
						      (SYS:%LOGDPBS SYS:%HEADER-TYPE-INSTANCE
								    SYS:%%Q-CDR-CODE-WITHIN-TAG
								    SYS:DTP-HEADER-P
								    SYS:%%Q-TYPE-WITHIN-TAG
								    0)))
				,@(MAP 'LIST #'(LAMBDA (SLOT INITIALIZED INITFORM)
						 `(SYS:%BLOCK-WRITE 1 ,(IF SLOT
									   (DESTRUCTURING-BIND (NAME &REST KEYS) SLOT
									     (DECLARE (IGNORE KEYS))
									     `(IF ,INITIALIZED
										  ,INITFORM
										  (SYS:%MAKE-POINTER SYS:DTP-NULL ',NAME)))
									   NULL)))
				       SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM)
				,INSTANCE)))
		      `(PROGN
			 (EVAL-WHEN (:LOAD-TOPLEVEL)
			   (DEFUN ,HELPER ,HELPER-ARGS
			     ,HELPER-FORM))
			 (EVAL-WHEN (:EXECUTE)
			   (SETF (FDEFINITION ',HELPER)
				 (COMPILE NIL '(LAMBDA ,HELPER-ARGS
						 (DECLARE (SYS:FUNCTION-NAME ,HELPER))
						 ,HELPER-FORM))))
			 (COMPILER:ADD-COMPILE-ONLY-OPTIMIZER
			   ,HELPER OPTIMIZE-DEFSTRUCT-CONSTRUCTOR)
			 (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
			   (SETF (GET ',NAME 'DEFSTRUCT-HELPER-DEFINITION)
				 '(,HELPER-ARGS ,HELPER-FORM)))
			 (DEFSUBST ,CONSTRUCTOR ,ARGS
			   (FUNCALL (SYS:FUNCTION ,HELPER)
				    ,(OR STORAGE-AREA 'SYS:*DEFAULT-CONS-AREA*)
				    ,@(MAPCAR #'SECOND SIMPLE-BINDINGS)
				    ,@LEXICALS))))
		    #+|3600|
		    `(DEFSUBST ,CONSTRUCTOR ,ARGS
		       (LET* (,@SIMPLE-BINDINGS
			      (,INSTANCE (ALLOCATE-STRUCTURE-OBJECT
					   ,INFORMATION
					   ,@(AND STORAGE-AREA `(,STORAGE-AREA)))))
			 ,@(MAP 'LIST #'(LAMBDA (SLOT INITIALIZED INITFORM)
					  (WHEN SLOT
					    (DESTRUCTURING-BIND (NAME &KEY LOCATION &ALLOW-OTHER-KEYS)
						SLOT
					      (DECLARE (IGNORE NAME))
					      `(WHEN ,INITIALIZED
						 (SETF (%STRUCTURE-REF ,INSTANCE ,LOCATION) ,INITFORM)))))
				SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM)
			 ,INSTANCE))
		    #-(or Imach |3600|)
		    `(DEFSUBST ,CONSTRUCTOR ,ARGS
		       (LET* (,@SIMPLE-BINDINGS
			      (,INSTANCE (%ALLOCATE-INSTANCE ,INFORMATION
							     #+(OR Minima CLOE-Runtime)
							     ,@(AND STORAGE-AREA
								    `(,STORAGE-AREA)))))
			 ,@(MAP 'LIST #'(LAMBDA (SLOT INITIALIZED INITFORM)
					  (WHEN SLOT
					    (DESTRUCTURING-BIND (NAME &KEY LOCATION &ALLOW-OTHER-KEYS)
						SLOT
					      #-(OR Genera Minima) (DECLARE (IGNORE NAME))
					      `(IF ,INITIALIZED
						   (SETF (%STRUCTURE-REF ,INSTANCE ,LOCATION) ,INITFORM)
						   #+(OR Genera Minima)
						   (LOCATION-MAKUNBOUND (LOCF (%STRUCTURE-REF ,INSTANCE ,LOCATION)) ',NAME)))))
				SLOT-VECTOR SLOT-INITIALIZED SLOT-INITFORM)
			 ,INSTANCE)))))
      ,(AND COPIER
	    #+Genera `(SYS:DEFF ,COPIER #'%ALLOCATE-INSTANCE-COPY)
	    #+Minima `(MINIMA-INTERNALS::DEFUN-1 ',COPIER #'%ALLOCATE-INSTANCE-COPY NIL)
	    #-(OR Genera Minima)
	    `(DEFSUBST ,COPIER (STRUCTURE)
	       (%ALLOCATE-INSTANCE-COPY STRUCTURE)))
      ,(AND PREDICATE
	    `(DEFSUBST ,PREDICATE (STRUCTURE)
	       (AND (INSTANCEP STRUCTURE)
		    (LET ((INFORMATION (%INSTANCE-INSTANCE-INFORMATION STRUCTURE)))
		      (OR (EQ INFORMATION ,INFORMATION)
			  (STRUCTURE-CLASS-TYPEP STRUCTURE ',NAME))))))
      ,@(DEFSTRUCT-COMPUTE-ACCESSORS 'STRUCTURE-OBJECT '%STRUCTURE-REF CONC-NAME SLOTS 0))))

#+IMACH
(DEFUN OPTIMIZE-DEFSTRUCT-CONSTRUCTOR (FORM)
  (LET* ((NAME (SECOND (SECOND (FIRST FORM))))
	 (METHOD (GET NAME 'DEFSTRUCT-HELPER-DEFINITION)))
    (WHEN METHOD
      (LET ((LAMBDA-LIST (FIRST METHOD)))
	(WHEN (= (LENGTH LAMBDA-LIST) (LENGTH (REST FORM)))
	  (LET* ((BINDINGS (MAPCAR #'CONS LAMBDA-LIST (REST FORM)))
		 (SUBSTITUTIONS
		   (REMOVE-IF-NOT #'(LAMBDA (BINDING)
				      (CONSTANTP (CDR BINDING)
						 COMPILER:*OPTIMIZER-ENVIRONMENT*))
				  BINDINGS)))
	    (WHEN SUBSTITUTIONS
	      (SETF BINDINGS (SET-DIFFERENCE BINDINGS SUBSTITUTIONS))
	      (LET ((BODY (SECOND METHOD)))
		(SETF BODY (LT::LET-SUBST-COPYFORMS SUBSTITUTIONS BODY
						    COMPILER:*OPTIMIZER-ENVIRONMENT*))
		(SETF BODY (LT:COPYFORMS #'(LAMBDA (FORM KIND IGNORE)
					     (DECLARE (IGNORE IGNORE))
					     (WHEN (AND (NULL KIND)
							(CONSP FORM)
							(EQ (FIRST FORM) 'IF)
							(EQ (SECOND FORM) NIL))
					       (LET ((BINDING (ASSOC (THIRD FORM) BINDINGS)))
						 (WHEN BINDING
						   (SETF BINDINGS (REMOVE BINDING BINDINGS)))))
					     (VALUES FORM NIL))
					 BODY :ENVIRONMENT COMPILER:*OPTIMIZER-ENVIRONMENT*))
		(RETURN-FROM OPTIMIZE-DEFSTRUCT-CONSTRUCTOR
		  `(FLET ((,NAME (,@(MAPCAR #'CAR BINDINGS))
			   ,BODY))
		     (,NAME ,@(MAPCAR #'CDR BINDINGS)))))))))))
  FORM)
