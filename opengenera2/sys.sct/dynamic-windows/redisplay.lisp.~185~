;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Tabulation.  Redisplay.

(defmacro with-redisplayable-output ((&rest options
				      &key stream cache-value redisplay-piece
					   dont-snapshot-variables
				      &allow-other-keys)
				     &body body)
  (declare (arglist (&key (stream *standard-output*)
			  cache-value (unique-id nil id-p)
			  (redisplay-piece nil)
			  (cache-test #'eql)
			  (copy-cache-value nil)
			  (id-test #'eql)
			  (piece-hook nil)
			  (piece-flavor 'redisplay-piece)
			  (dont-snapshot-variables nil))
		    &body body)
	   (zwei:indentation 0 3 1 1))
  (format-output-macro-default-stream stream)
  (let ((cache-value-var (if (and (symbolp cache-value) (not (constantp cache-value)))
			     cache-value
			     'ignore))
	(piece-var (or redisplay-piece 'ignore)))
    `(display-internal
       ;;+++ This can shapshot too much; in particlar, it shouldn't get anything that
       ;;is a cache value for a higher with-redisplayable-output.
       (format-output-macro-continuation (:name with-redisplayable-output
					  :dont-snapshot-variables ,dont-snapshot-variables)
					 (,cache-value-var ,stream ,piece-var)
	 ,(unless (eq cache-value-var 'ignore)
	    `(ignore ,cache-value-var))
	 . ,body)
       ,stream
       . ,(si:rem-keywords options '(:stream :redisplay-piece :dont-snapshot-variables)))))

(defun redisplayable-present
       (object &optional (presentation-type (type-of object)) &rest options
	&key (stream *standard-output*)
	(unique-id nil id-p)
	&allow-other-keys)
  (stack-let ((display-options `(:unique-id ,unique-id)))
    (si:with-rem-keywords (present-options options '(:stream :unique-id))
      (apply #'display-internal
	     (named-value-snapshot-continuation display (object stream ignore)
	       (apply #'present object presentation-type :stream stream present-options))
	     stream
	     :cache-value object
	     (and id-p display-options)))))

(defun redisplayable-format-cell (object printer &rest options
						 &key (stream *standard-output*)
						 &allow-other-keys)
  (declare (arglist object printer &key (stream *standard-output*) align-x align-y))
  (si:with-rem-keywords (real-options options '(:stream))
    (with-redisplayable-output (:stream stream :cache-value object)
      (apply #'format-table-operation :format-cell stream
	     (format-output-macro-continuation (:name format-cell) (ignore stream ignore)
	       (funcall printer object stream))
	     real-options))))

;;; A single cache keyed by all arguments, allowing arbitrary format usage.
(defun redisplayable-format (stream format-string &rest format-args)
  (case stream
    ((nil) (error "Cannot do REDISPLAYABLE-FORMAT to a string."))
    ((t) (setq stream *standard-output*)))
  (with-redisplayable-output (:stream stream :unique-id format-string
			      :cache-value format-args :cache-test #'equal
			      :copy-cache-value t)
    (apply #'format stream format-string format-args)))

;;; A separate cache for each argument.  Won't work with format commands that
;;; need all the arguments, like conditionals, iterations, or gotos.
(defmacro independently-redisplayable-format (stream format-string &rest format-args
					      &environment env)
  (once-only (stream &environment env)
    (let ((last-ctl-index 0)
	  (last-output-ctl-index 0)
	  (end-index (string-length format-string))
	  (pending-args format-args)
	  (forms nil))
      (using-resource (format:format-params format:format-params)
	(loop
	  (flet ((output-form (form) (push form forms)))
	    (let ((next-ctl-index (string-search-char #\~ format-string
						      :start last-ctl-index
						      :end end-index)))
	      (flet ((force-ctl-form (&optional args (index (or next-ctl-index end-index)))
		       (unless (= last-output-ctl-index index)
			 (output-form `(,(if args 'redisplayable-format 'format)
					,stream
					,(substring format-string last-output-ctl-index
						    index)
					. ,args))
			 (setq last-output-ctl-index index))))
		(when (null next-ctl-index)
		  (when pending-args
		    (warn "Leftover format argument~P ~S."
			  (length pending-args) pending-args))
		  (force-ctl-form)
		  (return))
		(let ((format:atsign-flag nil)
		      (format:colon-flag nil)
		      (format:ctl-string format-string)
		      (format:ctl-index next-ctl-index)
		      (format:ctl-length end-index))
		  (setf (fill-pointer format:format-params) 0)
		  (multiple-value-bind (nil nil type args)
		      (format:format-parse-command pending-args t)
		    (ecase type
		      (:no-arg )
		      (:one-arg (pop args))
		      (:multi-arg (warn "Multiple argument format clause will not work.")))
		    (when (neq args pending-args)
		      (force-ctl-form)
		      (force-ctl-form (ldiff pending-args args) format:ctl-index)
		      (setq pending-args args)))
		  (setq last-ctl-index format:ctl-index)))))))
      `(progn . ,(nreverse forms)))))

(defun display-internal (displayer stream &rest args &key cache-value &allow-other-keys)
  (if (operation-handled-p stream :display-internal)
      (lexpr-send stream :display-internal displayer stream args)
      (funcall displayer cache-value stream nil)))

(defmacro redisplayer ((&optional stream &rest options) &body body)
  (ignore options)
  (format-output-macro-default-stream stream)
  `(make-redisplay-piece :displayer
			 (zl:named-lambda redisplayer (ignore ,stream ignore)
					  . ,body)))

(eval-when (compile load eval)
(defun format-x-outputify (body stream)
  `(progn . ,(loop for form in body
		   when (stringp form)
		     collect `(write-string ',form ,stream)
		   else collect form))))

(defmacro formatting-table ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream &key equalize-column-widths extend-width extend-height
					   (inter-row-spacing 0)
					   (inter-column-spacing (send stream :char-width))
					   multiple-columns
					   (multiple-column-inter-column-spacing
					     inter-column-spacing)
					   (equalize-multiple-column-widths nil)
					   (output-multiple-columns-row-wise nil)
					   (rules nil)
					   dont-snapshot-variables)
		    &body body))
  (format-output-macro-default-stream stream)
  (let ((dont-snapshot-variables (option-remf options :dont-snapshot-variables)))
    `(with-stack-list (.options. . ,options)
       (format-table-contents ,stream .options.
			      (format-output-macro-continuation (:name formatting-table
								 :dont-snapshot-variables
								 ,dont-snapshot-variables)
								(ignore ,stream ignore)
				,@body)))))

(defmacro formatting-item-list ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream
			       &key
			       (inter-row-spacing 0)
			       (inter-column-spacing (send stream :char-width))
			       (row-wise t) output-row-wise
			       n-rows n-columns equalize-column-widths
			       inside-width inside-height
			       max-width max-height
			       dont-snapshot-variables)
		    &body body))
  (format-output-macro-default-stream stream)
  (let ((dont-snapshot-variables (option-remf options :dont-snapshot-variables)))
    `(with-stack-list (.options. . ,options)
       (format-menu-contents ,stream .options. 
			     (format-output-macro-continuation (:name formatting-item-list
								:dont-snapshot-variables
								,dont-snapshot-variables)
							       (ignore ,stream ignore)
			       . ,body)))))

(defmacro formatting-column-headings ((&optional stream &rest options) &body forms)
  (declare (arglist (&optional stream
		     &key (underline-p nil) dont-snapshot-variables)
		    &body forms))
  (format-output-macro-default-stream stream)
  `(format-table-operation :format-column-headings
     ,stream
     (format-output-macro-continuation (:name formatting-column-headings
					:dont-snapshot-variables
					 ,(option-remf options :dont-snapshot-variables))
			       (ignore ,stream ignore)
       . ,(loop for form in forms
		when (stringp form)
		  collect `(formatting-cell (,stream) (write-string ',form ,stream))
		else collect form))
     . ,options))

(defmacro formatting-row ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream
		     &key dont-snapshot-variables single-column)
		    &body body))
  (format-output-macro-default-stream stream)
  `(format-table-operation ,(if (option-remf options :single-column)
				:format-single-column-row-cells
				:format-row-cells)
     ,stream 
     (format-output-macro-continuation (:name formatting-row
					:dont-snapshot-variables
					 ,(option-remf options :dont-snapshot-variables))
				       (ignore ,stream ignore)
       ,(format-x-outputify body stream))
     . ,options))

(defmacro formatting-column ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream
		     &key dont-snapshot-variables)
		    &body body))
  (format-output-macro-default-stream stream)
  `(format-table-operation :format-column-cells
     ,stream
     (format-output-macro-continuation (:name formatting-column
					:dont-snapshot-variables
					 ,(option-remf options :dont-snapshot-variables))
				       (ignore ,stream ignore)
       ,(format-x-outputify body stream))
     . ,options))

(defmacro formatting-cell ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream
		     &key align-x align-y dont-snapshot-variables)
		    &body body))
  (format-output-macro-default-stream stream)
  `(format-table-operation :format-cell
     ,stream
     (format-output-macro-continuation (:name formatting-cell
					:dont-snapshot-variables
					 ,(option-remf options :dont-snapshot-variables))
				       (ignore ,stream ignore)
       ,(format-x-outputify body stream))
     . ,options))

;;; Functional interfaces.
(defun format-sequence-as-table-rows (sequence printer &rest options
						       &key (stream *standard-output*)
						       &allow-other-keys)
  (declare (arglist sequence printer &key (stream *standard-output*)
		    equalize-column-widths extend-width extend-height
		    (inter-row-spacing 0) (inter-column-spacing (send stream :char-width))
		    multiple-columns
		    (multiple-column-inter-column-spacing inter-column-spacing)
		    (equalize-multiple-column-widths nil)
		    (output-multiple-columns-row-wise nil)))
  (si:with-rem-keywords (some-options options '(:stream))
    (with-stack-list* (real-options :output-multiple-columns-row-wise t some-options)
      (format-table-contents stream real-options
			     (format-output-macro-continuation
			         (:name format-sequence-as-table-rows)
				 (ignore stream ignore)
			       (map ()
				    (lambda (element)
				      (formatting-row (stream)
					(funcall printer element stream)))
				    sequence))))))

(defun format-cell (object printer &rest options
				   &key (stream *standard-output*)
				   &allow-other-keys)
  (declare (arglist object printer &key (stream *standard-output*) align-x align-y))
  (si:with-rem-keywords (real-options options '(:stream))
    (apply #'format-table-operation :format-cell stream
	   (format-output-macro-continuation (:name format-cell) (ignore stream ignore)
	     (funcall printer object stream))
	   real-options)))
    
;;; The above macros expand into calls to the below functions, which are not
;;; to be called directly.

(defun format-table-contents (stream options continuation)
  (with-output-truncation (stream :horizontal t)	;Doesn't work otherwise.
    (if (operation-handled-p stream :format-table-contents)
	(send stream :format-table-contents options continuation)
	(let ((piece (redisplayer (stream)
		       (send stream :format-table-contents options continuation))))
	  (do-redisplay piece stream
			:once-only t :truncate-p :if-necessary
			:full-set-cursorpos (destructuring-bind
						(&key multiple-columns
						      output-multiple-columns-row-wise
						      rules
						 &allow-other-keys)
					       options
					      (if rules
						  :graphics
						  (and (not output-multiple-columns-row-wise)
						       multiple-columns
						       (not (eql multiple-columns 1))))))))))

(defun format-menu-contents (stream options continuation)
  (with-output-truncation (stream :horizontal t)
    (if (operation-handled-p stream :format-menu-contents)
	(send stream :format-menu-contents options continuation)
	(let ((piece (redisplayer (stream)
		       (send stream :format-menu-contents options continuation))))
	  (do-redisplay piece stream
			:once-only t :truncate-p :if-necessary
			:full-set-cursorpos (destructuring-bind
						(&key (row-wise t)
						      (output-row-wise nil)
						 &allow-other-keys)
					       options
					      (and (not row-wise)
						   (not output-row-wise))))))))

(defun format-table-operation (operation stream continuation &rest args)
  (if (operation-handled-p stream operation)
      (lexpr-send stream operation continuation args)
      (table-state-error stream operation nil)))

(defun check-table-state (operation stream state-now allowed-states)
  (unless (member state-now allowed-states)
    (table-state-error stream operation state-now)))

(defun table-state-error (stream operation state-now)
  (declare (dbg:error-reporter))
  (error 'table-state-error :stream stream :operation operation :state-now state-now))

(defflavor table-state-error (stream operation state-now) (error)
  :initable-instance-variables)

(defparameter *table-state-error-operations*
  '(((:tyo :string-out :fresh-line) (nil nil nil) (formatting-cell formatting-graph-node))
    ((:format-table-contents :format-menu-contents :format-graph-contents)
     (formatting-table formatting-item-list formatting-graph)
     (formatting-cell formatting-graph-node)
     t)
    ((:format-row-cells :format-column-cells
      :format-column-headings :format-single-column-row-cells)
     (formatting-row formatting-column formatting-column-headings formatting-row)
     (formatting-table))
    ((:format-cell) (formatting-cell)
     (formatting-row formatting-column formatting-column-headings))
    ((:format-graph-node) (formatting-graph-node) (formatting-graph))))

(defmethod (dbg:report table-state-error) (report-stream)
  (format report-stream "The stream ~S " stream)
  (if state-now
      (format report-stream "is in state ~S, which is not valid for" state-now)
      (format report-stream "does not handle"))
  (format report-stream " the ~S operation.~%" operation)
  (format report-stream "Your table formatting directives are not properly nested.~%")
  (multiple-value-bind (found directive superiors nested-p)
      (block found
	(loop for (elem-ops elem-directives elem-superiors elem-nested-p)
		  in *table-state-error-operations*
	      do
	  (loop for elem-op in elem-ops
		for elem-directive in elem-directives
		do (when (eq elem-op operation)
		     (return-from found
		       (values t elem-directive elem-superiors elem-nested-p))))))
    (when found
      (when nested-p
	(format report-stream "A nested "))
      (if directive
	  (format report-stream "~S should be used within " directive)
	  (format report-stream "Normal output should be done within "))
      (format-textual-list superiors #'prin1 :conjunction "or" :stream report-stream)
      (format report-stream ".~%")))
  (format report-stream 
	  "It may also be that you are not using the same stream for all directives."))

;;; Cooperation with other formatted output macros

(defmethod (:display-internal encapsulating-output-stream)
	   (displayer xstream &rest args &key cache-value &allow-other-keys)
  (if (operation-handled-p stream :display-internal)
      (lexpr-send stream :display-internal displayer xstream args)
      (funcall displayer cache-value xstream nil)))

(defmethod (:set-window-cursorpos encapsulating-output-stream) (&rest args)
  (lexpr-send stream :set-window-cursorpos args))

(defmethod (:collect-redisplay-pieces encapsulating-output-stream) (piece xstream)
  (send stream :collect-redisplay-pieces piece xstream))

(defmethod (:doing-display-phase encapsulating-output-stream) (piece xstream)
  (send stream :doing-display-phase piece xstream))

#|
method to redisplay madness:
 collect inferiors to be displayed
 compact phase
  arrange for some to receive their initial contents
  arrange to erase some other old stuff
  compact phase for inferiors
  if getting smaller, do erase now
 display phase
  do remaining copies
  display phase for inferiors
|#

(defstruct (rdcopies :named-array :conc-name (:alterant alter-rdcopies-internal))
  displayed-presentation
  old-box new-box
  old-inferior-boxes
  boxes-to-erase
  inferior-copies
  old-dead-inferiors
  protect-new-box boxes-to-maybe-erase
  pending-copies
  copy-done-p)

(defmacro alter-rdcopies (rdcopies &rest alterations)
  (declare (arglist rdcopies &key displayed-presentation old-box new-box
		    old-inferior-boxes boxes-to-erase inferior-copies old-dead-inferiors
		    protect-new-box boxes-to-maybe-erase pending-copies))
  ;;+++Interface to old ZL defstruct yuckery
  ;;Convert CL-ish keywords to ZL-ish symbols in prevailing package
  `(alter-rdcopies-internal ,rdcopies
			    ,@(loop with package = (symbol-package 'alter-rdcopies)
				    for (key val) on alterations by #'zl:rest2
				    collect (if (eq (symbol-package key)
						    pkg-keyword-package)
						(intern (string key) package)
						(error "~s is not a keyword" key))
				    collect val)))

(defflavor redisplay-piece
	((displayed-presentation nil)

	 (new-box nil)
	 start-cursor-x start-cursor-y		;In a box relative coordinate system
	 end-cursor-x end-cursor-y

	 displayer
	 unique-id
	 (contents-ok nil)
	 (move-old-contents nil)
	 (generation-count 0)
	 (cache-value nil)

	 (displayed-inferiors nil)
	 (inferiors-to-be-displayed nil)
	 (non-inferior-output nil)
	 (superior nil)

	 extra-state
	 )
	()
  :initable-instance-variables
  :writable-instance-variables
  (:locatable-instance-variables extra-state))

(defflavor table-redisplay-piece-table
	((table-options)
	 (row-height-table)
	 (column-width-table)
	 current-row current-column
	 (final-cell)

	 (multiple-columns-column-width-tables nil)
	 (multiple-columns-nrows nil)
	 (multiple-columns-column-heading-row nil)

	 (rules-to-be-displayed nil)
	 (displayed-rules nil)
	 )
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defflavor table-redisplay-piece-menu
	((table-options)
	 (menu-geometry)
	 current-row current-column
	 (final-cell)
	 (row-wise t)				;bug-for-bug compatible with TV:MENUs
	 (output-row-wise nil)
	 )
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defflavor table-redisplay-piece-row
	(column-width-table current-column current-row-height
	 (final-cell))
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defflavor table-redisplay-piece-single-column-row () (table-redisplay-piece-row))

(defflavor table-redisplay-piece-column
	(row-height-table current-row current-column-width
	 (final-cell))
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defflavor table-redisplay-piece-cell
	(cell-options)
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defflavor table-redisplay-piece-column-headings
	(column-headings-options)
	(table-redisplay-piece-row)
  :initable-instance-variables
  :writable-instance-variables)

(defun make-redisplay-piece (&rest init-args &key flavor &allow-other-keys)
  (apply #'make-instance (or flavor 'redisplay-piece)
	 (si:rem-keywords init-args '(:flavor))))

(defflavor menu-geometry
	((n-columns) (n-rows)
	 (inside-width) (inside-height)
	 (max-width) (max-height)
	 (max-cell-width) (max-cell-height)
	 (column-width) (row-height)
	 (cell-count) (column-width-table nil)
	 (equalize-column-widths nil)
	 )
	()
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (make-instance redisplay-helper-stream :after) (&rest ignore)
  (unless (variable-boundp window-x-offset)
    (multiple-value-setq (nil window-x-offset window-y-offset)
      (stream-window-and-offsets stream)))
  (setq stream-has-newline-without-erasing (not (null (operation-handled-p
							stream
							:newline-without-erasing)))
	stream-real-set-cursorpos (send-if-handles stream :real-set-cursorpos)))

(defmethod (:set-limit-to-viewport redisplay-helper-stream) (limit-p)
  (when limit-p
    (multiple-value-setq (nil nil nil viewport-y-limit)
      (send stream :visible-cursorpos-limits))))

(defmethod (:set-scroll-position-for-total-extent redisplay-helper-stream) ()
  (when total-y-extent
    (let* ((top (send stream :maximum-y-position))
	   (height (- total-y-extent top)))
      (when (plusp height)
	;; Draw a blank rectangle the size of what the entire output would
	;; be, so that the scroll-bar's elevator comes out correct
	(send stream :draw-rectangle 1 height 0 top boole-2)))))	;aka color:alu-noop

(defsubst translate-to-window-coordinates-internal (x y x-offset y-offset)
  (values (+ x x-offset) (+ y y-offset)))

(defsubst translate-from-window-coordinates-internal (x y x-offset y-offset)
  (values (- x x-offset) (- y y-offset)))

(defmethod (translate-from-window-coordinates redisplay-helper-stream) (x y)
  (translate-from-window-coordinates-internal x y window-x-offset window-y-offset))

(defmethod (translate-to-window-coordinates redisplay-helper-stream) (x y)
  (translate-to-window-coordinates-internal x y window-x-offset window-y-offset))

(defmethod (:set-window-cursorpos redisplay-helper-stream) (x y)
  (multiple-value-bind (sx sy)
      (translate-from-window-coordinates-internal x y window-x-offset window-y-offset)
    (send self :set-cursorpos sx sy)
    (values sx sy)))

(defun-in-flavor (redisplay-helper-stream-graphics-box redisplay-helper-stream)
                 (left top right bottom)
  (minf-or min-x-position left)
  (minf-or min-y-position top)
  (maxf-or max-x-position right)
  (maxf-or max-y-position bottom)
  (setq any-output-p t)
  nil)

(defvar *redisplay-once-only* nil)

;;; This message is only sent to the top-level guy
(defmethod (do-redisplay redisplay-piece) (&optional (stream *standard-output*)
					   &key (full-set-cursorpos nil)
						(truncate-p nil truncate-p-p)
						(once-only nil)
						(save-cursor-position nil)
						(limit-to-viewport nil)
					   &aux x-offset y-offset old-x old-y
						(original-truncate-p truncate-p))
  (incf generation-count)
  (setf stream (cli::follow-synonym-stream stream))
  (clear-before-redisplay self stream)
  (when save-cursor-position
    (multiple-value-setq (old-x old-y)
      (send stream :read-cursorpos)))
  (multiple-value-setq (nil x-offset y-offset)
    (stream-window-and-offsets stream))
  (when displayed-presentation
    (multiple-value-bind (start-x start-y)
	(redisplay-piece-start-position self)
      (multiple-value-bind (sx sy)
	  (translate-from-window-coordinates-internal start-x start-y x-offset y-offset)
	;; This set-cursorpos could try to move the cursor past the
	;; top of the viewport, which would get clipped to within the
	;; viewport.  In that case, we'll need to do the initial part of
	;; the redisplay invisibly.
	(if (box-contains-point-p (send stream :cursor-viewport) sx sy)
	    (send stream :set-cursorpos sx sy)
	  (unless (and (null truncate-p) truncate-p-p)
	    (setq truncate-p t))
	  (with-output-truncation (stream)
	    (send stream :set-cursorpos sx sy)))))
    (multiple-value-bind (end-x end-y)
	(redisplay-piece-end-position self)
      (multiple-value-setq (end-x end-y)
	(translate-from-window-coordinates-internal end-x end-y x-offset y-offset))
      (unless (or (box-contains-point-p (send stream :cursor-viewport) end-x end-y)
		  (and (null truncate-p) truncate-p-p))
	(setq truncate-p t))))
  (let ((real-set-cursorpos (send-if-handles stream :real-set-cursorpos)))
    (macrolet ((check-for-graphics ()
		 `(case real-set-cursorpos
		    ((nil)
		      (cerror "Try to output anyway"
			      "The stream ~S is not capable
  of doing the proper graphics and coordinate positioning for this operation.
These are currently only supported on dynamic windows and LGP2s." stream))
		    ((:hardcopy)
		     (return-from do-redisplay
		       (with-hardcopy-upside-down-stream (stream)
			 (do-redisplay self stream :once-only once-only))))))
	       (catch-better (form)
		 `(condition-case (error)
		       ,form     
		     (set-cursorpos-simulating-stream-no-cursor-back
		       (setq full-set-cursorpos (send error :class))
		       (return-from try-again-with-more)))))
      (when (eq full-set-cursorpos :graphics)
	(check-for-graphics))
      (when (eq truncate-p :if-necessary)
	(when (or (null real-set-cursorpos) (eq real-set-cursorpos :hardcopy))
	  (loop
	    (block try-again-with-more
	      (return-from do-redisplay
		(case full-set-cursorpos
		  ((nil)
		   (catch-better
		     (using-resource (better-stream set-cursorpos-simulating-stream stream)
		       (do-redisplay self better-stream :once-only once-only))))
		  ((:graphics)
		   (check-for-graphics))
		  (otherwise
		    (catch-better
		      (using-resource (better-stream line-buffering-stream stream)
			(multiple-value-prog1
			  (do-redisplay self better-stream :once-only once-only)
			  (send better-stream :force-line-buffer))))))))))
	(let ((end-of-page-mode (send-if-handles stream :defaulted-end-of-page-mode)))
	  ;; Truncate if will jump around on page or area not contiguous.
	  (setq truncate-p (or full-set-cursorpos (eq end-of-page-mode :wrap)))))))
  (let ((xstream (make-redisplay-helper-stream stream
					       :window-x-offset x-offset
					       :window-y-offset y-offset)))
    (send xstream :reset-cursorpos)
    (when limit-to-viewport
      (send xstream :set-limit-to-viewport limit-to-viewport))
    (redisplay-piece-collect-inferiors self xstream)
    (labels ((clear-area ()
	       (multiple-value-bind (left top right bottom)
		   (box-edges (redisplay-piece-new-box self))
		 (multiple-value-setq (left top)
		   (translate-from-window-coordinates-internal left top
							       x-offset y-offset))
		 (multiple-value-setq (right bottom)
		   (translate-from-window-coordinates-internal right bottom
							       x-offset y-offset))
		 (send-if-handles stream :clear-region left top nil bottom)))
	     (do-real-output (ignore)
	       (if once-only
		   (clear-area)
		 (unless displayed-presentation
		   (clear-area))		;Even DW cannot be relied upon to be blank.
		 (redisplay-piece-promote-contents-ok self)
		 (multiple-value-bind (old-inferior-boxes boxes-to-erase inferiors old-dead
				       protect-new-box boxes-to-maybe-erase)
		     (redisplay-piece-copy-phase self xstream)
		   (send xstream :copy-presentations
			 (make-rdcopies :displayed-presentation displayed-presentation
					:old-box (redisplay-piece-displayed-box self)
					:new-box new-box
					:old-inferior-boxes old-inferior-boxes
					:boxes-to-erase boxes-to-erase
					:inferior-copies inferiors
					:old-dead-inferiors old-dead
					:protect-new-box protect-new-box
					:boxes-to-maybe-erase boxes-to-maybe-erase))))
	       (send xstream :reset-cursorpos)
	       (let ((*redisplay-once-only* once-only))
		 (redisplay-piece-display-phase self xstream))))
      (cond ((eq (send stream :real-set-cursorpos) :simulated-hardcopy)
	     (multiple-value-bind (right bottom)
		 (box-bottom-right (redisplay-piece-new-box self))
	       (send stream :with-pages-for-box #'do-real-output stream right bottom)))
	    ((not truncate-p)
	     (do-real-output stream))
	    (t
	     ;; If truncating, try to glitch before doing the output.
	     (with-output-truncation (stream)
	       (multiple-value-bind (end-x end-y)
		   (redisplay-piece-new-end-position self)
		 (multiple-value-setq (end-x end-y)
		   (translate-from-window-coordinates-internal end-x end-y x-offset y-offset))
		 (send-if-handles stream :scroll-to-visible-cursor nil
				  (+ end-y (send stream :line-height))))
	       (do-real-output stream)))))
    (when limit-to-viewport
      (send xstream :set-scroll-position-for-total-extent)))
  (cond (save-cursor-position
	 (with-output-truncation (stream)
	   (send stream :set-cursorpos old-x old-y)))
	((and displayed-presentation
	      (operation-handled-p displayed-presentation 'presentation-displayed-box))
	 (multiple-value-bind (end-x end-y)
	     (redisplay-piece-end-position self)
	   (multiple-value-bind (sx sy)
	       (translate-from-window-coordinates-internal end-x end-y x-offset y-offset)
	     (multiple-value-bind (nil nil max-x)
		 (send stream :visible-cursorpos-limits)
	       (setq sx (min sx (1- max-x))))
	     (with-output-truncation (stream)
	       (send stream :set-cursorpos sx sy))))
	 ;; Cursor should already be at the start of a line, but it might be right at the
	 ;; end of the viewport with an end of page exception.  This seems to mess up the
	 ;; input editor help mechanism.  This will cause the right screen glitch.
	 (when (eq original-truncate-p :if-necessary)
	   (send-if-handles stream :increment-cursorpos 0 0)))
	(t
	 (multiple-value-bind (end-x end-y)
	     (redisplay-piece-new-end-position self)
	   (multiple-value-bind (sx sy)
	       (translate-from-window-coordinates-internal end-x end-y x-offset y-offset)
	     (with-output-truncation (stream)
	       (send stream :set-cursorpos sx sy)))))))

(defmethod (clear-before-redisplay redisplay-piece) (stream)
  (let ((changed-pieces nil))
    (let ((clobbered-top nil)
	  (clobbered-bottom nil))
      (dolist (old-inferior displayed-inferiors)
	(let ((presentation (redisplay-piece-displayed-presentation old-inferior)))
	  (when presentation
	    (unless (member presentation (presentation-inferiors
					   (presentation-superior presentation)))
	      (push old-inferior changed-pieces)
	      (multiple-value-bind (nil top nil bottom)
		  (box-edges (presentation-displayed-box presentation))
		(when (or (null clobbered-top) (< top clobbered-top))
		  (setq clobbered-top top))
		(when (or (null clobbered-bottom) (> bottom clobbered-bottom))
		  (setq clobbered-bottom bottom)))))))
      ;; Erase a single block for anything that got overwritten.  This takes less
      ;; time and looks less spastic than doing it piece by piece.
      (when (and clobbered-top clobbered-bottom)
	(send stream :clear-region nil clobbered-top nil clobbered-bottom)))
    ;; This can either be because a nested redisplay was done to a stream that doesn't
    ;; record presentations (for sizing), or they got overwritten by incidental output,
    ;; or they got cleared just above.
    (labels ((check-inactive (piece)
	       (unless (let ((presentation (redisplay-piece-displayed-presentation piece)))
			 (when presentation
			   (member presentation (presentation-inferiors
						  (presentation-superior presentation)))))
		 (push piece changed-pieces)
		 t))
	     (check-inferiors (piece)
	       (let ((inferiors (delete-if #'check-inactive
					   (redisplay-piece-displayed-inferiors piece))))
		 (dolist (inferior inferiors)
		   (check-inferiors inferior))
		 (setf (redisplay-piece-displayed-inferiors piece) inferiors))))
      (check-inferiors self))
    (nreverse changed-pieces)))

(defmethod (force-redisplay redisplay-piece) (stream)
  (when displayed-presentation
    (multiple-value-bind (start-x start-y)
	(redisplay-piece-start-position self)
      (multiple-value-bind (nil x-offset y-offset)
	  (stream-window-and-offsets stream)
	(multiple-value-bind (sx sy)
	    (translate-from-window-coordinates-internal start-x start-y x-offset y-offset)
	  (send stream :set-cursorpos sx sy))))
    (erase-displayed-presentation displayed-presentation stream nil t)
    (setq displayed-presentation nil))
  (setq displayed-inferiors nil))

(defmethod (redisplayer-output-size redisplay-piece) (&optional (stream *standard-output*))
  (incf generation-count)
  (let ((xstream (make-redisplay-helper-stream stream)))
    (send xstream :reset-cursorpos)
    (redisplay-piece-collect-inferiors self xstream)
    )
  (box-size new-box))

(defmethod (redisplay-piece-call-displayer redisplay-piece) (xstream)
  (catch 'viewport-y-limit
    (funcall displayer cache-value xstream self)))

(defmethod (redisplay-piece-collect-inferiors redisplay-piece) (stream)
  (multiple-value-setq (new-box start-cursor-x start-cursor-y end-cursor-x end-cursor-y
				inferiors-to-be-displayed non-inferior-output)
    (send stream :collect-redisplay-pieces self stream)))

(defmethod (redisplay-piece-map-over-table-cells redisplay-piece) (function)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-map-over-table-cells inf function)))

(defmethod (redisplay-piece-map-over-table-cells table-redisplay-piece-cell) (function)
  (funcall function self))

;; These -reconsider- methods must be here, and not in do-redisplay,
;; because it has to happen bottom-up (can't size a table till you've sized
;; its cells, and what happens if a cell contains another table?)
(defmethod (redisplay-piece-collect-inferiors table-redisplay-piece-table :after) (stream)
  (redisplay-piece-consider-table-implications self stream nil))

(defmethod (redisplay-piece-collect-inferiors table-redisplay-piece-menu :after) (stream)
  (redisplay-piece-consider-table-implications self stream nil))

;;; Assemble a structure of the copies that are to be performed, collected recursively
;;; from inferiors too.
;;; DELTA-X and DELTA-Y are how far off our coordinates are from where they will be,
;;; so that inferiors know where the bits are really coming from.
(defmethod (redisplay-piece-copy-phase redisplay-piece) (xstream)
  (declare (values old-inferior-boxes boxes-to-erase inferiors old-dead
		   protect-new-box boxes-to-maybe-erase))
  (let ((inferior-boxes (multiple-value-bind (delta-x delta-y)
			    (redisplay-piece-position-deltas self)
			  (if (and (zerop delta-x) (zerop delta-y))
			      (map 'list #'redisplay-piece-displayed-box displayed-inferiors)
			      (loop for inferior in displayed-inferiors
				    collect (box-copy-with-offsets
					      (redisplay-piece-displayed-box inferior)
					      delta-x delta-y)))))
	(boxes-to-erase nil)
	(inferiors nil)
	old-dead boxes-to-maybe-erase)
    (let ((prev-box-alist (loop for inf in displayed-inferiors
				for box in inferior-boxes
				collect (cons inf box))))
      (dolist (inf inferiors-to-be-displayed)
	(let ((prev-inf-box (and (redisplay-piece-displayed-box inf)
				 (if (eq inf (caar prev-box-alist))
				     (cdr (pop prev-box-alist))	;Quick check for common case.
				     (let ((elem (assoc inf (cdr prev-box-alist))))
				       (setq prev-box-alist (delete elem prev-box-alist))
				       (cdr elem)))))
	      (new-inf-box (redisplay-piece-new-box inf)))
	  (if (or (null prev-inf-box)
		  (not (redisplay-piece-move-old-contents inf)))
	      (push new-inf-box boxes-to-erase)
	      (push (make-rdcopies :displayed-presentation inf
				   :old-box prev-inf-box
				   :new-box new-inf-box)
		    inferiors))
	  (when prev-inf-box
	    (setq boxes-to-maybe-erase (nconc boxes-to-maybe-erase
					      (if (redisplay-piece-non-inferior-output inf)
						  ;; Output not otherwise accounted for might
						  ;; have changed.
						  (ncons prev-inf-box)
						  (box-difference prev-inf-box
								  new-inf-box)))))))
      (loop for alist on prev-box-alist do
	(setq boxes-to-maybe-erase (nconc boxes-to-maybe-erase (ncons (cdar alist))))
	(setf (car alist) (redisplay-piece-displayed-presentation (caar alist))))
      (setq old-dead prev-box-alist))
    (dolist (inf-elem inferiors)
      (let ((inf (rdcopies-displayed-presentation inf-elem)))
	(multiple-value-bind (old-inferior-boxes boxes-to-erase inferiors old-dead
			      protect-new-box boxes-to-maybe-erase)
	    (redisplay-piece-copy-phase inf xstream)
	  (alter-rdcopies inf-elem
			  :displayed-presentation (redisplay-piece-displayed-presentation inf)
			  :old-inferior-boxes old-inferior-boxes
			  :boxes-to-erase boxes-to-erase
			  :inferior-copies inferiors
			  :old-dead-inferiors old-dead
			  :protect-new-box protect-new-box
			  :boxes-to-maybe-erase boxes-to-maybe-erase))))
    (values inferior-boxes boxes-to-erase inferiors old-dead
	    ;; Protect if this is terminal, or has some output worth saving.
	    (or (null inferiors-to-be-displayed)
		(and non-inferior-output contents-ok))
	    boxes-to-maybe-erase)))

(defwhopper (redisplay-piece-call-displayer table-redisplay-piece-cell) (stream)
  ;; (terpri) within a cell goes to the column margin.
  (send stream :output-with-cell-left-margin (send stream :read-cursorpos)
	#'(lambda (stream)
	    (declare (downward-function))
	    (continue-whopper stream))
	stream))

(defmethod (redisplay-piece-display-phase table-redisplay-piece-cell :before) (stream)
  ;; Arrange for the previous method to have the right left margin.
  (multiple-value-bind (x y) (redisplay-piece-new-start-position self)
    (send stream :set-window-cursorpos x y)))

(defmethod (redisplay-piece-display-phase table-redisplay-piece-column-headings :after)
	   (stream)
  (when (loop for superior = superior then (redisplay-piece-superior superior)
	      while superior
	      when (typep superior 'table-redisplay-piece-table)
		return
		  (eq self (table-redisplay-piece-table-multiple-columns-column-heading-row
			     superior)))
    (dolist (sibling (redisplay-piece-inferiors-to-be-displayed superior))
      (when (and (typep sibling 'table-redisplay-piece-column-headings)
		 (neq sibling self))
	(redisplay-piece-display-phase sibling stream)
	(send stream :skip-redisplay-piece sibling))))
  (destructuring-bind (&key (underline-p nil)) column-headings-options
    (when underline-p
      (multiple-value-bind (left top right bottom) (box-edges new-box)
	(multiple-value-setq (left top)
	  (translate-from-window-coordinates stream left top))
	(multiple-value-setq (right bottom)
	  (translate-from-window-coordinates stream right bottom))
	(multiple-value-bind (end-x end-y)
	    (send stream :read-cursorpos)
	  (ignore end-x)
	  (underline-between-cursorposes stream left end-y right end-y))))))

;;; A placeholder type for the presentations which are the elements of a redisplay.
(define-presentation-type redisplay-structure  ())

(defmethod (redisplay-piece-display-phase redisplay-piece) (stream)
  (if (null displayed-presentation)
      (if (and *redisplay-once-only* superior)	;Give one to top-level piece for end position
	  (send stream :doing-display-phase self stream)
	  (setq displayed-presentation (with-output-as-presentation
					   (:stream stream
					    :object self
					    :type 'redisplay-structure
					    :redisplay-place-holder t)
					 (send stream :doing-display-phase self stream))))
      ;; Reduce inferiors to just those we output ourselves last time.
      ;; Non redisplay generated pieces should be lost.  Redisplay generated will be
      ;; removed as necessary.
      (setf (presentation-inferiors displayed-presentation)
	    (delete-if-not #'(lambda (inferior-presentation)
			       (member (presentation-object inferior-presentation)
				       displayed-inferiors))
			   (presentation-inferiors displayed-presentation)))
      (send stream :output-for-re-presentation displayed-presentation
	    (lambda (stream) (send stream :doing-display-phase self stream))
	    stream))
  ;; If nothing is getting output at all, we must still maintain our place in the
  ;; presentation hierarchy, lest the next redisplay think that our superior has moved to
  ;; the right or something like that.  Also, even if stuff doesn't get output there,
  ;; make sure the corner of the box is where it's supposed to be.
  (when displayed-presentation
    (multiple-value-call #'set-box-edges
			 (presentation-displayed-box displayed-presentation)
			 (box-edges new-box))
    (when (box-empty-p new-box)
      (let ((superior (presentation-superior displayed-presentation)))
	(when superior
	  (pushnew displayed-presentation (presentation-inferiors superior))))))
  (setq displayed-inferiors inferiors-to-be-displayed))

(defmethod (redisplay-piece-check-contents-ok redisplay-piece) (value test value-p copy-p)
  (when (or (null superior)
	    ( generation-count (redisplay-piece-generation-count superior)))
    (setq contents-ok (and (not (null displayed-presentation))
			   value-p
			   (funcall test cache-value value)))
    (labels ((set-move-old-contents (piece value)
	       (setf (redisplay-piece-move-old-contents piece) value)
	       (dolist (inf (redisplay-piece-displayed-inferiors piece))
		 (set-move-old-contents inf value))))
      (set-move-old-contents self (or contents-ok (not (null displayed-inferiors)))))
    (when (and value-p (not contents-ok))
      (setq cache-value (if copy-p (copy-seq value) value)))
    (setq generation-count (redisplay-piece-generation-count superior)))
  contents-ok)

(defmethod (redisplay-piece-promote-contents-ok redisplay-piece) ()
  (let ((all-ok t))
    (dolist (inferior inferiors-to-be-displayed)
      (unless (redisplay-piece-promote-contents-ok inferior)
	(setq all-ok nil)))
    (when (and (not contents-ok) all-ok
	       (not non-inferior-output) (not (null displayed-presentation))
	       (equal inferiors-to-be-displayed displayed-inferiors)
	       (box-equal new-box (redisplay-piece-displayed-box self)))
      (setq contents-ok t)))
  contents-ok)

(defmethod (redisplay-piece-no-cursor-motion redisplay-piece) ()
  (and (or non-inferior-output (not (null displayed-inferiors)))
       (= start-cursor-x end-cursor-x) (= start-cursor-y end-cursor-y)))

;;; If the starting and ending cursor positions of the piece are the same,
;;; we should assume that graphical output was done with absolute cursor addressing and
;;; use 0,0 for the deltas.  This requires anything that does graphics relative to
;;; :read-cursorpos to move the cursor when done.  The alternative is to require that
;;; graphics all be relative to :read-cursorpos if the cursor is ever moved in the process
;;; of output.
(defun redisplay-piece-position-deltas (redisplay-piece &optional x y)
  (when (or (null (redisplay-piece-displayed-box redisplay-piece))
	    (redisplay-piece-no-cursor-motion redisplay-piece))
    (return-from redisplay-piece-position-deltas
      (values 0 0)))
  (unless (and x y)
    (multiple-value-setq (x y)
      (redisplay-piece-new-start-position redisplay-piece)))
  (multiple-value-bind (start-x start-y)
      (redisplay-piece-start-position redisplay-piece)
    (values (- x start-x) (- y start-y))))

(defun redisplay-piece-adjust-for-unchanged-move (piece x y)
  (multiple-value-bind (delta-x delta-y)
      (redisplay-piece-position-deltas piece x y)
    (labels ((move-box (piece)
	       (let ((old-new-box (redisplay-piece-new-box piece))
		     (displayed-box (redisplay-piece-displayed-box piece)))
		 (if (and old-new-box (neq old-new-box displayed-box))
		     (multiple-value-bind (left top right bottom)
			 (box-edges displayed-box)
		       (set-box-edges old-new-box (+ left delta-x) (+ top delta-y)
						  (+ right delta-x) (+ bottom delta-y)))
		     (setf (redisplay-piece-new-box piece)
			   (box-copy-with-offsets displayed-box delta-x delta-y))))
	       (let ((infs (redisplay-piece-displayed-inferiors piece)))
		 (dolist (inf infs)
		   (move-box inf))
		 (setf (redisplay-piece-inferiors-to-be-displayed piece) infs))))
      (move-box piece))))

(defmethod (redisplay-piece-displayed-box redisplay-piece) ()
  (and displayed-presentation (presentation-displayed-box displayed-presentation)))

(defmethod (redisplay-piece-start-position redisplay-piece) ()
  (multiple-value-bind (left top)
      (box-position (redisplay-piece-displayed-box self))
    (values (+ left start-cursor-x) (+ top start-cursor-y))))

(defmethod (redisplay-piece-new-start-position redisplay-piece) ()
  (multiple-value-bind (left top)
      (box-position new-box)
    (values (+ left start-cursor-x) (+ top start-cursor-y))))

(defmethod (redisplay-piece-end-position redisplay-piece) ()
  (multiple-value-bind (left top)
      (box-position (redisplay-piece-displayed-box self))
    (values (+ left end-cursor-x) (+ top end-cursor-y))))

(defmethod (redisplay-piece-new-end-position redisplay-piece) ()
  (multiple-value-bind (left top)
      (box-position new-box)
    (values (+ left end-cursor-x) (+ top end-cursor-y))))

(defmethod (redisplay-piece-consider-table-implications redisplay-piece)
	   (stream table-superior)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-consider-table-implications inf stream table-superior)))

;;; This is done to a table to get a good ending position.
(defun-in-flavor (redisplay-piece-update-final-cell redisplay-piece)
		 (stream final-cell return-at-end)
  (cond (return-at-end
	 (setq end-cursor-x (- (redisplay-piece-new-start-position self))
	       end-cursor-y (box-height new-box)))
	(final-cell
	 (multiple-value-bind (fx fy) (redisplay-piece-new-end-position final-cell)
	   (multiple-value-bind (sx sy) (box-position new-box)
	     (setq end-cursor-x (- fx sx)
		   end-cursor-y (- fy sy))))))
  (when superior
    (multiple-value-bind (fx fy)
	(redisplay-piece-new-end-position self)
      (send stream :set-window-cursorpos fx fy))))

;;; This is done to a row or column and any pieces between it and the table to make
;;; sure that the cursor appears to move properly.
(defun-in-flavor (redisplay-piece-set-cursor-from-final-cell redisplay-piece)
		 (table-superior final-cell)
  (when final-cell
    (multiple-value-bind (fx fy) (redisplay-piece-new-end-position final-cell)
      (loop for piece = self then (redisplay-piece-superior piece)
	    until (eq piece table-superior)
	    do
	(redisplay-piece-set-end-cursor-position piece fx fy)))))

(defmethod (redisplay-piece-set-end-cursor-position redisplay-piece) (fx fy)
  (multiple-value-bind (sx sy) (box-position new-box)
    (setq end-cursor-x (- fx sx)
	  end-cursor-y (- fy sy))))

(defmethod (redisplay-piece-consider-table-implications table-redisplay-piece-table)
	   (stream table-superior)
  (ignore table-superior)
  (when (null row-height-table)
    (setq row-height-table (make-array 10 :fill-pointer 0 :initial-element 0)
	  column-width-table (make-array 10 :fill-pointer 0 :initial-element 0)))
  (setf (fill-pointer row-height-table) 0)
  (setf (fill-pointer column-width-table) 0)
  (setq multiple-columns-column-width-tables nil)
  (setq current-row 0 current-column 0)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-consider-table-implications inf stream self))
  ;; Process global table options
  (destructuring-bind (&key equalize-column-widths extend-width extend-height
			    (inter-row-spacing 0) (inter-column-spacing
						    (send stream :char-width))
			    (multiple-columns nil)
			    (multiple-column-inter-column-spacing inter-column-spacing)
			    (equalize-multiple-column-widths nil)
			    output-multiple-columns-row-wise
			    (return-at-end t) (rules nil))
		      table-options
    (ignore output-multiple-columns-row-wise)
    (setf (getf table-options :inter-row-spacing) inter-row-spacing)
    (setq inter-column-spacing (format-output-standardize-horizontal-spacing
				 stream inter-column-spacing))
    (setf (getf table-options :inter-column-spacing) inter-column-spacing)
    (when multiple-columns
      (setq multiple-column-inter-column-spacing
	    (format-output-standardize-horizontal-spacing
	      stream multiple-column-inter-column-spacing)))
    ;; Equalize column widths when requested
    (when equalize-column-widths
      (let ((max (loop for x being array-elements of column-width-table
		       maximize x)))
	(dotimes (j (fill-pointer column-width-table))
	  (setf (aref column-width-table j) max))))
    ;; Extend if requested
    (when (or extend-width extend-height)
      (when (or (eq extend-width 't) (eq extend-height 't))
	(multiple-value-bind (nil nil width height)
	    (send stream :visible-cursorpos-limits)
	  (when (eq extend-width 't)
	    (setq extend-width width))
	  (when (eq extend-height 't)
	    (setq extend-height height))))
      (flet ((extend (array to-limit spacing)
       	       (when to-limit
		 (let ((current (loop for x being the array-elements of array
				      sum x
				      do (decf to-limit spacing))))
		   (incf to-limit spacing)
		   (cond ((> current to-limit)
			;(error "Table is already bigger than requested extension.")
			  )
			 ((= current to-limit) )
			 (t
			  (loop for i below (fill-pointer array)
				do (setf (aref array i)
					 (floor (* (aref array i) to-limit) current)))))))))
	(extend column-width-table extend-width inter-column-spacing)
	(extend row-height-table extend-height inter-row-spacing)))
    (multiple-value-bind (left top) (box-position new-box)
      ;;Adjust column and row start positions
      (flet ((addup (array start extra)
	       (when rules
		 (incf start (floor extra 2)))
	       (loop with x = start
		     for j below (fill-pointer array)
		     for new = (+ x (aref array j) extra)
		     do (setf (aref array j) x)
			(setq x new)
		     finally (vector-push-extend x array))))
	(addup column-width-table left inter-column-spacing)
	(addup row-height-table top inter-row-spacing)
	(when (and multiple-columns (not (eql multiple-columns 1)))
	  (let (multiple-columns-column-width
		#+ignore multiple-columns-row-height
		multiple-columns-ncolumns)
	    (setq multiple-columns-column-width (aref column-width-table
						      (1- (fill-pointer column-width-table)))
		  #+ignore #+ignore
		  multiple-columns-row-height (- (aref row-height-table 1)
						 (aref row-height-table 0)))
	    (if (eq multiple-columns t)
		(multiple-value-bind (nil nil stream-width stream-height)
		    (send stream :visible-cursorpos-limits)
		  (ignore stream-height)
		  (setq multiple-columns-ncolumns
			(max 1 (floor stream-width
				      (+ multiple-columns-column-width
					 multiple-column-inter-column-spacing)))
			multiple-columns-column-width (floor stream-width
							     multiple-columns-ncolumns)))
		(setq multiple-columns-column-width (+ multiple-columns-column-width
						       multiple-column-inter-column-spacing)
		      multiple-columns-ncolumns multiple-columns))
	    (let ((nlines (1- (fill-pointer row-height-table))))
	      (when multiple-columns-column-heading-row
		(decf nlines))			;This comes in later
	      (setq multiple-columns-nrows (max 1
						(ceiling nlines multiple-columns-ncolumns))
		    multiple-columns-ncolumns (max 1
						   (ceiling nlines multiple-columns-nrows))))
	    (when multiple-columns-column-heading-row
	      (dotimes (i multiple-columns-ncolumns)
		(let ((where (* i (1+ multiple-columns-nrows))))
		  (if (zerop where)
		      (unless (eq multiple-columns-column-heading-row
				  (nth i inferiors-to-be-displayed))
			(error "FORMATTING-COLUMN-HEADINGS not at start of table"))
		      (insert-array-element (aref row-height-table where)
					    row-height-table where)
		      (let ((dy (- (aref row-height-table 1)
				   (aref row-height-table 0))))
			(loop for j from (1+ where) below (fill-pointer row-height-table) do
			  (incf (aref row-height-table j) dy)))
		      (push (copy-redisplay-piece multiple-columns-column-heading-row)
			    (nthcdr where inferiors-to-be-displayed)))))
	      (incf multiple-columns-nrows))
	    (setq multiple-columns-column-width-tables (make-array multiple-columns-ncolumns))
	    (dotimes (col-no multiple-columns-ncolumns)
	      (setf (aref multiple-columns-column-width-tables col-no)
		    (let ((copy (make-array (zl:array-length column-width-table)
					    :fill-pointer 0)))
		      (when equalize-multiple-column-widths
			(copy-array-contents-and-leader column-width-table copy))
		      copy)))
	    (unless equalize-multiple-column-widths
	      (setq current-row 0 current-column 0)
	      (setf (fill-pointer row-height-table) multiple-columns-nrows)
	      (fill row-height-table 0)
	      (dolist (inf inferiors-to-be-displayed)
		(redisplay-piece-consider-table-implications inf stream self))
	      (dotimes (col-no multiple-columns-ncolumns)
		(addup (aref multiple-columns-column-width-tables col-no)
		       left inter-column-spacing))
	      (addup row-height-table top inter-row-spacing))
	    (let ((running-offset 0))
	      (dotimes (col-no multiple-columns-ncolumns)
		(let ((array (aref multiple-columns-column-width-tables col-no)))
		  (dotimes (i (fill-pointer array))
		    (incf (aref array i) running-offset))
		  (setq running-offset (+ (- (aref array (1- (fill-pointer array))) left)
					  multiple-column-inter-column-spacing))))))))
      (redisplay-piece-reposition-table-components self nil :absolute left top)
      (setq rules-to-be-displayed (and rules (lay-out-table-rules self)))
      (when (and multiple-columns (not (eql multiple-columns 1)))
	(setq final-cell (let ((row (nth (1- multiple-columns-nrows)
					 inferiors-to-be-displayed)))
			   (and row (table-redisplay-piece-row-final-cell row)))))
      ;; Account for cursor motion of the whole table, and update the stream's position
      ;; to correspond to that, in case we aren't the top-level redisplay piece.
      (redisplay-piece-update-final-cell stream final-cell return-at-end))))

(defmethod (copy-redisplay-piece redisplay-piece) ()
  (let* ((fl (%instance-flavor self))
	 (new (make-instance (%flavor-typename fl))))
    (flavor::%block-copy-allow-null self new
				    (flavor::flavor-instance-size fl))
    (copy-redisplay-piece-1 new)
    new))

(defmethod (copy-redisplay-piece-1 redisplay-piece) ()
  (setq new-box (copy-box new-box)
	inferiors-to-be-displayed (map 'list #'(lambda (old)
						 (let ((new (copy-redisplay-piece old)))
						   (setf (redisplay-piece-superior new) self)
						   new))
				       inferiors-to-be-displayed)))

(defwhopper (copy-redisplay-piece-1 table-redisplay-piece-row) ()
  (setq final-cell (position final-cell inferiors-to-be-displayed))
  (continue-whopper)
  (when final-cell
    (setq final-cell (nth final-cell inferiors-to-be-displayed))))

(defwhopper (copy-redisplay-piece-1 table-redisplay-piece-column) ()
  (setq final-cell (position final-cell inferiors-to-be-displayed))
  (continue-whopper)
  (when final-cell
    (setq final-cell (nth final-cell inferiors-to-be-displayed))))

(defmethod (redisplay-piece-consider-table-implications table-redisplay-piece-menu)
	   (stream table-superior)
  (ignore table-superior)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-consider-table-implications inf stream self))
  ;; Process global table options
  (destructuring-bind (&key (inter-row-spacing 0)
			    (inter-column-spacing (send stream :char-width))
			    ((:row-wise new-row-wise) () row-wise-p)
			    ((:output-row-wise new-output-row-wise) () output-row-wise-p)
			    n-rows n-columns equalize-column-widths
			    inside-width inside-height
			    max-width max-height
			    (return-at-end t)
			    )
		      table-options
    (setf (getf table-options :inter-row-spacing) inter-row-spacing)
    (setq inter-column-spacing (format-output-standardize-horizontal-spacing
				 stream inter-column-spacing))
    (setf (getf table-options :inter-column-spacing) inter-column-spacing)
    (when (null menu-geometry) (setq menu-geometry (make-instance 'menu-geometry)))
    (macrolet ((zz (&rest names)
		 `(progn ,@(loop for name in names
				 collect `(progn ;when ,name
					    (setf (,(intern (string-append 'menu-geometry-
									   name))
						   menu-geometry)
						  ,name))))))
      ;; zz does like (when n-rows (setf (menu-geometry-n-rows menu-geometry) n-rows))
      (zz n-rows n-columns inside-width inside-height max-width max-height
	  equalize-column-widths))
    (when row-wise-p (setq row-wise new-row-wise))
    (when output-row-wise-p (setq output-row-wise new-output-row-wise))
    (menu-geometry-consider-formatting
      menu-geometry stream self
      ;; :label-width ---
      :inter-column-spacing inter-column-spacing
      :inter-row-spacing inter-row-spacing)

    (setq current-row 0 current-column 0)
  
    (multiple-value-bind (left top)
	(box-position new-box)
      (redisplay-piece-reposition-table-components self nil :absolute left top))
    (redisplay-piece-update-final-cell stream final-cell return-at-end)))

(defmethod (redisplay-piece-consider-table-implications table-redisplay-piece-row)
	   (stream table-superior)
  (setq column-width-table (table-redisplay-piece-table-current-column-width-table
			     table-superior)
	current-row-height 0
	current-column 0)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-consider-table-implications inf stream self))
  (redisplay-piece-set-cursor-from-final-cell table-superior final-cell)
  (table-redisplay-piece-advance-row table-superior current-row-height final-cell))

(defmethod (redisplay-piece-consider-table-implications table-redisplay-piece-column)
	   (stream table-superior)
  (setq row-height-table (table-redisplay-piece-table-row-height-table
			   table-superior)
	current-column-width 0
	current-row 0)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-consider-table-implications inf stream self))
  (redisplay-piece-set-cursor-from-final-cell table-superior final-cell)
  (table-redisplay-piece-advance-column table-superior current-column-width final-cell))

(defmethod (redisplay-piece-consider-table-implications table-redisplay-piece-cell)
	   (stream table-superior)
  (dolist (inf inferiors-to-be-displayed)
    (redisplay-piece-consider-table-implications inf stream self))
  (multiple-value-bind (width height) (box-size new-box)
    (table-redisplay-piece-advance-cell table-superior width height self)))

;;; This is largely copied from tv:(defun-in-flavor menu-deduce-parameters basic-menu).
;;; It could use enhancements to understand that not all items need be placed in the
;;; same size rectangle.  And a few others too. :-
;;; Modified to take proper account of :INTER-ROW-SPACING -- ACW 8/19/92
;;; Modified to prevent blowouts on pathological usages like empty sequences -- Dodds 5 Oct 92
(defmethod (menu-geometry-consider-formatting menu-geometry)
	   (stream menu-piece
		   &key
		   label-width
		   (inter-column-spacing (send stream :char-width))
		   (inter-row-spacing 0)
		   )
  (setq max-cell-width 0 max-cell-height 0 cell-count 0)
  (redisplay-piece-map-over-table-cells
    menu-piece
    (lambda (cell-piece)
      (multiple-value-bind (width height)
	  (box-size (redisplay-piece-new-box cell-piece))
	(setq max-cell-width (max max-cell-width width)
	      max-cell-height (max max-cell-height height)
	      cell-count (1+ cell-count)))))
  
  ;; Realize any immediately clear implications
  ;; (when (and n-rows (null inside-height)) (setq inside-height (* n-rows max-cell-height)))
  (when (and inside-height (null n-rows))
    (setq n-rows (max 1 (floor (+ inside-height inter-row-spacing)
			       (max 1 (+ max-cell-height inter-row-spacing))))))
  (multiple-value-bind (vleft vtop vright vbottom)
      (send stream :visible-cursorpos-limits)
    (let ((vwidth (- vright vleft))
	  (vheight (- vbottom vtop)))
      (unless max-width
	(setq max-width (if inside-width (min inside-width vwidth) vwidth)))
      (unless max-height
	(setq max-height (if inside-height (min inside-height vheight) vheight)))))
  
  (let ((col-width nil)
	minimum-column-width)
    
    ;; Compute the horizontal parameters.
    (cond ((and inside-width n-columns)
	   ;;it's fully-determined
	   )
	  (inside-width
	   ;; We have the width.  Compute N-COLUMNS based on widest item,
	   ;; but always fill the space
	   (let ((would-fit (max 1 (floor (+ inside-width inter-column-spacing)
					  (max 1 (+ max-cell-width inter-column-spacing))))))
	     (if n-rows
		 (let ((needed (ceiling cell-count n-rows)))
		   (if (> needed would-fit)
		       ;; It will need more than the requested number of rows
		       (setq n-columns would-fit
			     n-rows (ceiling cell-count n-columns))
		       (setq n-columns needed)))
		 (setq n-columns (min would-fit cell-count)))))
	  (n-columns
	   ;; We don't have the width, but do know how many columns, compute width
	   (setq inside-width
		 (min (- (* (+ max-cell-width inter-column-spacing) n-columns)
			 inter-column-spacing)
		      max-width)))
	  (n-rows
	   ;; We know how high, make it wide enough to come out this high
	   (setq n-rows (min n-rows cell-count)
		 n-columns (max (ceiling cell-count n-rows) 1)
		 col-width (+ max-cell-width inter-column-spacing)
		 inside-width (- (* col-width n-columns) inter-column-spacing)))
	  (t
	   ;;No geometry supplied, pick N-ROWS and N-COLUMNS to make it look nice
	   ;;Use the largest number of columns which does not make the ratio
	   ;;of height to width less than the Golden ratio
	   (setq col-width (+ max-cell-width inter-column-spacing)
		 n-columns (max 1 (floor (sqrt (/ (* cell-count
						     max-cell-width
						     max-cell-height)
						  tv:menu-golden-ratio))
					 (max 1 max-cell-width)))
		 inside-width (max tv:menu-minimum-width
				   (- (* col-width n-columns) inter-column-spacing)))))
    
    ;; Now figure out the vertical characteristics
    (when (null n-rows)
      (setq n-rows (max 1 (ceiling cell-count (max 1 n-columns)))))
    (when (null inside-height)
      (setq inside-height (- (* n-rows (+ max-cell-height inter-row-spacing))
			     inter-row-spacing)))
    
    (flet ((deequalize ()
	     (unless equalize-column-widths
	       (setq column-width-table (make-array n-columns :initial-element 0))
	       (setq minimum-column-width most-positive-fixnum)
	       (let ((true-n-rows (max 1 (ceiling cell-count (max 1 n-columns))))
		     (cell-no 0)
		     (row-wise (table-redisplay-piece-menu-row-wise menu-piece)))
		 (redisplay-piece-map-over-table-cells
		   menu-piece
		   (lambda (cell-piece)
		     (let ((cell-width (box-size (redisplay-piece-new-box cell-piece))))
		       (maxf (aref column-width-table (if row-wise
							  (rem cell-no (max 1 n-columns))
							  (floor cell-no true-n-rows)))
			     cell-width)
		       (minf minimum-column-width cell-width)
		       (incf cell-no)))))
	       (let ((running-total 0))
		 (dotimes (col-no n-columns)
		   (setf (aref column-width-table col-no)
			 (prog1 running-total
				(incf running-total (+ inter-column-spacing
						       (aref column-width-table col-no))))))
		 (setq inside-width (- running-total inter-column-spacing))))))

      (deequalize)

      ;; If there is a label, the menu must be at least wide enough to accomodate it
      (when label-width
	(setq inside-width (max inside-width label-width)))
    
      ;; If this came out too high or too wide, retrench
      ;; Fix vertical first, preferring a vertical scroll bar to a horizontal one.
      (when (> inside-height max-height)
	(when col-width
	  (setq n-rows (max 1 (floor max-height (max 1 max-cell-height)))
		n-columns (max 1 (ceiling cell-count n-rows))
		inside-height (- (* n-rows (+ max-cell-height inter-row-spacing))
				 inter-row-spacing)
		inside-width (- (* n-columns col-width) inter-column-spacing))
	  (deequalize)))

      (when (> inside-width max-width)
	(when col-width	;;If N-COLUMNS was not user-supplied, recompute it
	  (setq n-columns (max 1 (floor (+ max-width inter-column-spacing)
					(max 1 col-width))))
	  (unless equalize-column-widths
	    ;; We may be able to fit more columns than that, because some of the
	    ;; columns will be narrower than col-width.  Iterate on n-columns.
	    (loop with went-too-far = nil doing
	      (deequalize)
	      (cond ((and (not went-too-far)
			  ( (+ inside-width inter-column-spacing minimum-column-width)
			     max-width))
		     ;; After deequalize, another column should fit
		     (incf n-columns))
		    ((or ( inside-width max-width)
			 (= n-columns 1))
		     ;; We've found the correct number of columns
		     (return))
		    (t
		     ;; We went too far, back off
		     (setq went-too-far t)
		     (decf n-columns)))))
	  (setq n-rows (max 1 (ceiling cell-count (max 1 n-columns))))
	  (when equalize-column-widths
	    (setq inside-width (- (* n-columns col-width) inter-column-spacing))))
	(when (> inside-width max-width)
	  (setq inside-width max-width))))
    (setq n-rows (max 1 (ceiling cell-count (max 1 n-columns)))
	  inside-height (- (* n-rows (+ max-cell-height inter-row-spacing))
			   inter-row-spacing))

    ;; At this point, INSIDE-WIDTH, INSIDE-HEIGHT, N-COLUMNS, and N-ROWS
    ;; are all valid and consistent, and not bigger than the available area,
    ;; provided that the original parameters were not illegally huge.
    
    ;;(setq column-width (or col-width (+ max-cell-width inter-column-spacing)))
    (setq column-width (floor (+ inside-width inter-column-spacing)
			      (max 1 n-columns)))
    (setq row-height (+ max-cell-height inter-row-spacing)))
  nil)

(defmethod (table-redisplay-piece-incf-current-row table-redisplay-piece-table) ()
  (incf current-row))
(defmethod (table-redisplay-piece-incf-current-column table-redisplay-piece-table) ()
  (incf current-column))

(defmethod (table-redisplay-piece-incf-current-cell table-redisplay-piece-row) ()
  (incf current-column))
(defmethod (table-redisplay-piece-incf-current-cell table-redisplay-piece-column) ()
  (incf current-row))

(defmethod (table-redisplay-piece-incf-current-cell table-redisplay-piece-menu) ()
  (if row-wise
      (when ( (setq current-column (1+ current-column))
	       (menu-geometry-n-columns menu-geometry))
	(setq current-column 0
	      current-row (1+ current-row)))
      (when ( (setq current-row (1+ current-row))
	       (menu-geometry-n-rows menu-geometry))
	(setq current-row 0
	      current-column (1+ current-column)))))

(defmethod (table-redisplay-piece-advance-cell table-redisplay-piece-menu) (width height cell)
  (ignore width height)
  (setq final-cell cell)
  nil)

(defun-in-flavor (check-for-direction-mismatch table-redisplay-piece-table) ()
  (loop for inferior in inferiors-to-be-displayed
	count (typep inferior 'table-redisplay-piece-row) into rows
	count (typep inferior 'table-redisplay-piece-column) into columns
	finally (when (and (plusp rows) (plusp columns))
		  (error 
 "You cannot use both formatting-column and formatting-row (or formatting-column-headings) in the same table.")))
    (error "Fill-pointer and current-column out of sync"))

(defmethod (table-redisplay-piece-advance-row table-redisplay-piece-table) (height cell)
  (setq final-cell cell)
  (cond (multiple-columns-column-width-tables
	 (let ((current-row-index (rem current-row multiple-columns-nrows)))
	   (maxf (aref row-height-table current-row-index) height))
	 (incf current-row))
	(t
	 (vector-push-extend height row-height-table)
	 (incf current-row)
	 (unless (= current-row (fill-pointer row-height-table))
	   (check-for-direction-mismatch)))))

(defmethod (table-redisplay-piece-advance-column table-redisplay-piece-table) (width cell)
  (setq final-cell cell)
  (vector-push-extend width column-width-table)
  (incf current-column)
  (unless (= current-column (fill-pointer column-width-table))
    (check-for-direction-mismatch)))

(defun-in-flavor (table-redisplay-piece-advance-row-cell table-redisplay-piece-row)
		 (width height cell single-column)
  (when ( (fill-pointer column-width-table) current-column)
    (loop repeat (1+ (- current-column (fill-pointer column-width-table)))
	  do (vector-push-extend 0 column-width-table)))
  (unless single-column
    (maxf (aref column-width-table current-column) width))
  (incf current-column)
  (setq final-cell cell)
  (maxf current-row-height height))

(defmethod (table-redisplay-piece-advance-cell table-redisplay-piece-row) (width height cell)
  (table-redisplay-piece-advance-row-cell width height cell nil))

(defmethod (table-redisplay-piece-advance-cell table-redisplay-piece-single-column-row)
	   (width height cell)
  (table-redisplay-piece-advance-row-cell width height cell t))

(defmethod (table-redisplay-piece-advance-cell table-redisplay-piece-column)
	   (width height cell)
  (when ( (fill-pointer row-height-table) current-row)
    (loop repeat (1+ (- current-row (fill-pointer row-height-table)))
	  do (vector-push-extend 0 row-height-table)))
  (maxf (aref row-height-table current-row) height)
  (incf current-row)
  (setq final-cell cell)
  (maxf current-column-width width))

(defmethod (table-redisplay-piece-inter-column-spacing redisplay-piece) ()
  (if superior
      (table-redisplay-piece-inter-column-spacing superior)
      0))

(defmethod (table-redisplay-piece-inter-row-spacing redisplay-piece) ()
  (if superior
      (table-redisplay-piece-inter-row-spacing superior)
      0))

(defmethod (table-redisplay-piece-inter-column-spacing table-redisplay-piece-table) ()
  (getf table-options :inter-column-spacing))

(defmethod (table-redisplay-piece-inter-row-spacing table-redisplay-piece-table) ()
  (getf table-options :inter-row-spacing))

(defmethod (table-redisplay-piece-inter-column-spacing table-redisplay-piece-menu) ()
  (getf table-options :inter-column-spacing))

(defmethod (table-redisplay-piece-inter-row-spacing table-redisplay-piece-menu) ()
  (getf table-options :inter-row-spacing))

(defmethod (table-redisplay-piece-table-current-column-width-table
	     table-redisplay-piece-table) ()
  (if multiple-columns-column-width-tables
      (aref multiple-columns-column-width-tables (floor current-row multiple-columns-nrows))
      column-width-table))

(defmethod (table-redisplay-piece-current-cell-location table-redisplay-piece-table) ()
  (let* ((current-column-width-table
	   (table-redisplay-piece-table-current-column-width-table self))
	 (left (aref current-column-width-table current-column))
	 (width (- (aref current-column-width-table (1+ current-column)) left))
	 (current-row-index (if multiple-columns-column-width-tables
				(rem current-row multiple-columns-nrows)
				current-row))
	 (top (aref row-height-table current-row-index))
	 (height (- (aref row-height-table (1+ current-row-index)) top)))
    (values left top width height)))

(defmethod (table-redisplay-piece-current-cell-location table-redisplay-piece-row) ()
  (values
    (aref column-width-table current-column)
    (box-top new-box)
    (- (aref column-width-table (1+ current-column))
       (aref column-width-table current-column))
    (box-height new-box)))

(defmethod (table-redisplay-piece-current-cell-location table-redisplay-piece-column) ()
  (values (box-left new-box)
	  (aref row-height-table current-row)
	  (box-width new-box)
	  (- (aref row-height-table (1+ current-row))
	     (aref row-height-table current-row))))

(defmethod (table-redisplay-piece-current-cell-location table-redisplay-piece-menu) ()
  (let ((column-width-table (menu-geometry-column-width-table menu-geometry))
	(column-width (menu-geometry-column-width menu-geometry))
	(row-height (menu-geometry-row-height menu-geometry)))
    (multiple-value-bind (left top)
	(box-position new-box)
      (values (+ left (if column-width-table
			  (aref column-width-table current-column)
			  (* current-column column-width)))
	      (+ top (* current-row row-height))
	      column-width
	      row-height))))

(defmethod (redisplay-piece-reposition-table-components redisplay-piece)
	   (table-superior how left top)
  (let ((dx left)
	(dy top))
    (multiple-value-bind (old-left old-top) (box-position new-box)
      (ecase how
	(:absolute
	  (setq dx (- left old-left)
		dy (- top old-top)))
	(:relative
	  (setq left (+ old-left dx)
		top (+ old-top dy)))))

    (set-box-position new-box left top)
    (dolist (inf inferiors-to-be-displayed)
      (redisplay-piece-reposition-table-components inf table-superior :relative dx dy)))

  ;; Repositioning our inferiors may have widened their boxes, which can affect the
  ;; size of ours as well.
  (multiple-value-bind (left top right bottom)
      (box-edges new-box)
    (dolist (inf inferiors-to-be-displayed)
      (multiple-value-bind (nil nil inf-right inf-bottom)
	  (box-edges (redisplay-piece-new-box inf))
	(maxf right inf-right)
	(maxf bottom inf-bottom)))
    (set-box-edges new-box left top right bottom)))

(defmethod (redisplay-piece-reposition-table-components table-redisplay-piece-table)
	   (table-superior how left top)
  (ignore table-superior)

  (let ((dx left)
	(dy top))
    (multiple-value-bind (old-left old-top) (box-position new-box)
      (ecase how
	(:absolute
	  (setq dx (- left old-left)
		dy (- top old-top)))
	(:relative
	  (setq left (+ old-left dx)
		top (+ old-top dy)))))

	;; Normally called with left,top as box-position of new-box. But with nested tables,
	;; adjustment is necessary.
	(unless (zerop dx)
	  (dotimes (i (fill-pointer column-width-table))
	    (incf (aref column-width-table i) dx))
	  (when multiple-columns-column-width-tables
	    (loop for table being the array-elements of multiple-columns-column-width-tables
		  do (dotimes (i (fill-pointer table))
		       (incf (aref table i) dx)))))
	(unless (zerop dy)
	  (dotimes (i (fill-pointer row-height-table))
	    (incf (aref row-height-table i) dy))))

  (set-box-edges new-box
		 left top 
		 (if multiple-columns-column-width-tables
		     (let ((table (aref multiple-columns-column-width-tables
					(1- (length multiple-columns-column-width-tables)))))
		       (aref table (1- (fill-pointer table))))
		   (aref column-width-table (1- (fill-pointer column-width-table))))
		 (aref row-height-table (1- (fill-pointer row-height-table))))

  (setq current-row 0 current-column 0)
  (dolist (inf inferiors-to-be-displayed)
    (multiple-value-bind (inf-left inf-top)
	(table-redisplay-piece-current-cell-location self)
      (redisplay-piece-reposition-table-components inf self :absolute inf-left inf-top))))

(defmethod (redisplay-piece-reposition-table-components table-redisplay-piece-menu)
	   (table-superior how left top)
  (ignore table-superior)

  (ecase how
    (:absolute )
    (:relative
      (multiple-value-bind (old-left old-top) (box-position new-box)
	(setq left (+ old-left left)
	      top (+ old-top top)))))

  ;;Resize self and relocate all inferiors
  (set-box-edges new-box
		 left top 
		 (+ left (menu-geometry-inside-width menu-geometry))
		 (+ top (menu-geometry-inside-height menu-geometry)))
  
  (setq current-row 0 current-column 0)
  (dolist (inf inferiors-to-be-displayed)
    (multiple-value-bind (inf-left inf-top)
	(table-redisplay-piece-current-cell-location self)
      (redisplay-piece-reposition-table-components inf self :absolute inf-left inf-top))))

(defmethod (redisplay-piece-reposition-table-components table-redisplay-piece-row)
	   (table-superior &rest ignore)

  (multiple-value-bind (left top)
      (table-redisplay-piece-current-cell-location table-superior)
    (set-box-position new-box left top))
  
  (setq column-width-table (table-redisplay-piece-table-current-column-width-table
			     table-superior)
	current-column 0)
  (dolist (inf inferiors-to-be-displayed)
    (multiple-value-bind (inf-left inf-top)
	(table-redisplay-piece-current-cell-location self)
      (redisplay-piece-reposition-table-components inf self :absolute inf-left inf-top)))
  (setf (box-right new-box)
	(+ (box-left new-box)
	   (- (aref column-width-table current-column) (aref column-width-table 0))))
  (table-redisplay-piece-incf-current-row table-superior))

(defmethod (redisplay-piece-reposition-table-components table-redisplay-piece-column)
	   (table-superior &rest ignore)

  (multiple-value-bind (left top)
      (table-redisplay-piece-current-cell-location table-superior)
    (set-box-position new-box left top))
  
  (setq row-height-table (table-redisplay-piece-table-row-height-table table-superior)
	current-row 0)
  (dolist (inf inferiors-to-be-displayed)
    (multiple-value-bind (inf-left inf-top)
	(table-redisplay-piece-current-cell-location self)
      (redisplay-piece-reposition-table-components inf self :absolute inf-left inf-top)))
  (setf (box-bottom new-box)
	(+ (box-top new-box)
	   (- (aref row-height-table current-row) (aref row-height-table 0))))
  (table-redisplay-piece-incf-current-column table-superior))

(defmethod (redisplay-piece-reposition-table-components table-redisplay-piece-cell)
	   (table-superior &rest ignore)

  (multiple-value-bind (left top in-width in-height)
      (table-redisplay-piece-current-cell-location table-superior)

    (destructuring-bind (&key align (align-x align) align-y) cell-options
      (ecase align-x
	((nil :left) )
	(:right
	  (let ((extra-width (- in-width (box-width new-box)
				(table-redisplay-piece-inter-column-spacing
				  table-superior))))
	    (incf left extra-width)))
	(:center
	  (let ((extra-width (- in-width (box-width new-box)
				(table-redisplay-piece-inter-column-spacing
				  table-superior))))
	    (incf left (floor extra-width 2)))))
      (ecase align-y
	((nil :top) )
	(:bottom
	  (let ((extra-height (- in-height (box-height new-box)
				 (table-redisplay-piece-inter-row-spacing
				   table-superior))))
	    (incf top extra-height)))
	(:center
	  (let ((extra-height (- in-height (box-height new-box)
				 (table-redisplay-piece-inter-row-spacing
				   table-superior))))
	    (incf top (floor extra-height 2))))))

    (multiple-value-bind (old-left old-top)
	(box-edges new-box)
      (set-box-position new-box left top)
      (let ((dx (- left old-left))
	    (dy (- top old-top)))
	(dolist (inf inferiors-to-be-displayed)
	  (redisplay-piece-reposition-table-components inf self :relative dx dy)))))

  (table-redisplay-piece-incf-current-cell table-superior))

(defmethod (redisplay-piece-call-displayer-for-display-phase table-redisplay-piece-menu)
	   (xstream)
  (if (or row-wise (not output-row-wise))
      (redisplay-piece-call-displayer self xstream)
      (send xstream :reset-old-redisplay-pieces
	    (column-invert-list inferiors-to-be-displayed
				(menu-geometry-n-rows menu-geometry)
				(menu-geometry-n-columns menu-geometry)))
      (loop as cell = (send xstream :next-redisplay-piece) while cell do
	(send xstream :output-as-if-cell #'redisplay-piece-redisplay-or-display cell xstream)))
  (when superior
    (multiple-value-bind (fx fy)
	(redisplay-piece-new-end-position self)
      (send xstream :set-window-cursorpos fx fy))))

(defmethod (redisplay-piece-call-displayer-for-display-phase table-redisplay-piece-table)
	   (xstream)
  (if (not (and multiple-columns-column-width-tables
		(> (length multiple-columns-column-width-tables) 1)
		(getf table-options :output-multiple-columns-row-wise)))
      (redisplay-piece-call-displayer self xstream)
      (send xstream :reset-old-redisplay-pieces
	    (column-invert-list inferiors-to-be-displayed
				multiple-columns-nrows
				(length multiple-columns-column-width-tables)))
      (loop as row = (send xstream :next-redisplay-piece) while row do
	(send xstream :output-as-if-row #'redisplay-piece-redisplay-or-display row xstream)))
  (when superior
    (multiple-value-bind (fx fy)
	(redisplay-piece-new-end-position self)
      (send xstream :set-window-cursorpos fx fy))))

(defun column-invert-list (list n-rows n-cols)
  (let ((length (length list)))
    (with-stack-array (cells length :initial-contents list)
      (loop for i below (* n-rows n-cols)
	    as idx = (+ (floor i n-cols) (* (rem i n-cols) n-rows))
	    when (< idx length)
	      collect (aref cells idx)))))

(defstruct table-rule
  from-x from-y
  to-x to-y
  presentation)

(defun table-rule-equal (rule-1 rule-2)
  (and (= (table-rule-from-x rule-1) (table-rule-from-x rule-2))
       (= (table-rule-from-y rule-1) (table-rule-from-y rule-2))
       (= (table-rule-to-x rule-1) (table-rule-to-x rule-2))
       (= (table-rule-to-y rule-1) (table-rule-to-y rule-2))))

(defmethod (lay-out-table-rules table-redisplay-piece-table) ()
  (destructuring-bind (&key inter-column-spacing inter-row-spacing &allow-other-keys)
      table-options
    (let ((top (- (aref row-height-table 0) (floor inter-row-spacing 2)))
	  (bottom (- (aref row-height-table (1- (length row-height-table)))
		     (floor inter-row-spacing 2)))
	  (left (- (aref column-width-table 0) (floor inter-column-spacing 2)))
	  (right (- (aref column-width-table (1- (length column-width-table)))
		    (floor inter-column-spacing 2))))
      (nconc
	(loop for y being the array-elements of row-height-table
	      do (decf y (floor inter-row-spacing 2))
	      collect (make-table-rule :from-x left :to-x right
				       :from-y y :to-y y))
	(loop for x being the array-elements of column-width-table
	      do (decf x (floor inter-column-spacing 2))
	      collect (make-table-rule :from-y top :to-y bottom
				       :from-x x :to-x x))))))

(defun draw-table-rule (table-rule &rest drawing-options)
  (apply #'graphics:draw-line (table-rule-from-x table-rule) (table-rule-from-y table-rule)
			      (table-rule-to-x table-rule) (table-rule-to-y table-rule)
			      drawing-options))

(defmethod (redisplay-piece-copy-phase table-redisplay-piece-table :before) (stream)
  (dolist (rule displayed-rules)
    (let ((new (find rule rules-to-be-displayed :test #'table-rule-equal))
	  (presentation (table-rule-presentation rule)))
      (if (and new presentation
	       (member presentation
		       (presentation-inferiors (presentation-superior presentation))))
	  (setf (table-rule-presentation new) presentation)
	(if presentation
	    (graphics:erase-graphics-presentation presentation
						  :stream stream
						  :redisplay-overlapping-presentations nil)
	    (draw-table-rule rule :stream stream :alu :erase))
	(setq displayed-rules (delete rule displayed-rules))))))

(defmethod (redisplay-piece-display-phase table-redisplay-piece-table :after) (stream)
  (dolist (rule rules-to-be-displayed)
    (unless (member rule displayed-rules :test #'table-rule-equal)
      (setf (table-rule-presentation rule)
	    (graphics:with-output-as-graphics-presentation (stream)
	      (draw-table-rule rule :stream stream)))))
  (setq displayed-rules rules-to-be-displayed))

(defmethod (:output-as-if-row redisplay-helper-stream) (function &rest arguments)
  (letf ((table-state :row))
    (apply function arguments)))

(defmethod (:output-as-if-cell redisplay-helper-stream) (function &rest arguments)
  (letf ((table-state :cell))
    (apply function arguments)))

(defmethod (:reset-cursorpos redisplay-helper-stream) ()
  (multiple-value-setq (x-position y-position)
    (send stream :read-cursorpos))
  (setq cursorpos-pending nil))

(defmethod (:collect-redisplay-pieces redisplay-helper-stream) (piece xstream)
  (declare (values (new-box start-cursor-x start-cursor-y end-cursor-x end-cursor-y
                    inferiors-to-be-displayed non-inferior-output)))
  (let ((start-x x-position)
        (start-y y-position))
    (letf ((state :collecting)
           (current-redisplay-piece piece)
           (old-redisplay-pieces (copy-list (redisplay-piece-displayed-inferiors piece)))
           (new-redisplay-pieces nil)
           (any-output-p nil)
           (min-x-position nil)
           (max-x-position nil)
           (min-y-position nil)
           (max-y-position nil)
           (max-line-height (send self :line-height)))
      (redisplay-piece-call-displayer piece xstream)
      (when (null min-x-position)
        ;; No output at all, just take empty box at current position.
        (setq min-x-position x-position
              min-y-position y-position
              max-x-position x-position
              max-y-position y-position))
      (values (multiple-value-bind (x1 y1)
                  (translate-to-window-coordinates self min-x-position min-y-position)
                (multiple-value-bind (x2 y2)
                    (translate-to-window-coordinates self max-x-position max-y-position)
		  (make-temporary-box x1 y1 x2 y2)))
              (- start-x min-x-position) (- start-y min-y-position)
	      (- x-position min-x-position) (- y-position min-y-position)
              (nreverse new-redisplay-pieces) any-output-p))))

(defmethod (:doing-display-phase redisplay-helper-stream) (piece xstream)
  (letf ((state :displaying)
	 (current-redisplay-piece piece)
	 (old-redisplay-pieces (redisplay-piece-inferiors-to-be-displayed piece)))
    (redisplay-piece-call-displayer-for-display-phase piece xstream))
  ;; If our caller is inside :with-output-as-presentation to a
  ;; stream that doesn't hack sensitivity, we are expected to
  ;; return either a presentation, or NIL.  So here it is.
  nil)

(defmethod (redisplay-piece-call-displayer-for-display-phase redisplay-piece) (xstream)
  (redisplay-piece-call-displayer self xstream))

(defun redisplay-piece-equal (piece unique-id test)
  (funcall test unique-id (redisplay-piece-unique-id piece)))

(defmethod (:display-internal redisplay-helper-stream) (displayer xstream
                                                        &key (cache-value nil cv-p)
                                                             (cache-test #'eql)
                                                             (copy-cache-value nil)
                                                             (unique-id nil id-p)
                                                             (id-test #'eql)
                                                             (copy-unique-id nil)
							     (piece-hook nil)
                                                             (piece-flavor 'redisplay-piece)
							     (vertical-fraction nil)
							     (inhibit-viewport-y-limit nil))
  (when (and (not inhibit-viewport-y-limit)
	     viewport-y-limit ( y-position viewport-y-limit))
    (when (eq state :displaying)
      ;; Anything which we aren't going to get to on the second pass should not
      ;; be recorded for the redisplay.  Normally we would have punted the first
      ;; time, but not always on table redisplay.  To use this feature to best
      ;; effect, stay away from table redisplay.
      (when current-redisplay-piece
	(setf (redisplay-piece-inferiors-to-be-displayed current-redisplay-piece)
	      (set-difference (redisplay-piece-inferiors-to-be-displayed
				current-redisplay-piece)
			      old-redisplay-pieces)))
      ;; Arrange for scroll bar to be correct when done.
      (when (and vertical-fraction (null total-y-extent))
	(setq total-y-extent (round y-position vertical-fraction))))
    (throw 'viewport-y-limit t))
  (ecase state
    (:collecting
      (let ((piece (dolist (piece old-redisplay-pieces)
                     ;; If a cache unique-id is supplied, scan old pieces looking for the one
                     ;;  (if any) with that cache.  Otherwise, just use the next piece found.
                     (when (and (if id-p
                                    (redisplay-piece-equal piece unique-id id-test)
                                    t)
                                (eq (type-of piece) piece-flavor))
                       ;; Don't want to use a moldy old closure.
                       (setf (redisplay-piece-displayer piece) displayer)
                       (if (eq piece (first old-redisplay-pieces))
			   (pop old-redisplay-pieces)	;Common case quickly.
			   (setq old-redisplay-pieces (delete piece old-redisplay-pieces)))
                       (return piece)))))
        (when (null piece)
          (when copy-unique-id
	    (setq unique-id (copy-if-necessary unique-id)))
	  (setq piece (make-redisplay-piece :displayer displayer
                                            :superior current-redisplay-piece
                                            :unique-id unique-id
                                            :flavor piece-flavor))
          (when piece-hook
            (funcall piece-hook piece)))
        (if (redisplay-piece-check-contents-ok piece cache-value cache-test cv-p
                                               copy-cache-value)
            (redisplay-piece-adjust-for-unchanged-move piece x-position y-position)
            (redisplay-piece-collect-inferiors piece xstream))
        (multiple-value-bind (end-x end-y)
            (redisplay-piece-new-end-position piece)
          (multiple-value-setq (x-position y-position)
            (translate-from-window-coordinates self end-x end-y)))
        (multiple-value-bind (new-left new-top new-right new-bottom)
            (box-edges (redisplay-piece-new-box piece))
          (multiple-value-setq (new-left new-top)
            (translate-from-window-coordinates self new-left new-top))
          (multiple-value-setq (new-right new-bottom)
            (translate-from-window-coordinates self new-right new-bottom))
          (minf-or min-x-position new-left)
          (minf-or min-y-position new-top)
          (maxf-or max-x-position new-right)
          (maxf-or max-y-position new-bottom))
        (push piece new-redisplay-pieces)
        piece))
    (:displaying
      (let ((piece (pop old-redisplay-pieces)))
        (unless (and piece
                     (or (not id-p)
                         (redisplay-piece-equal piece unique-id id-test)))
          (error "Redisplay did not find the same output on pass two.
Redisplayable output should not depend on state that can change between redisplays."))
        (redisplay-piece-redisplay-or-display piece xstream)
        piece))))

(defun redisplay-piece-redisplay-or-display (piece xstream)
  (if (redisplay-piece-contents-ok piece)
      (multiple-value-bind (end-x-position end-y-position)
	  (redisplay-piece-new-end-position piece)
	(send xstream :set-window-cursorpos end-x-position end-y-position)
	(send xstream :add-displayed-presentation
	      (redisplay-piece-displayed-presentation piece)
	      nil))
      (redisplay-piece-display-phase piece xstream)))

(defmethod (:skip-redisplay-piece redisplay-helper-stream) (piece)
  (setq old-redisplay-pieces (remove piece old-redisplay-pieces)))

(defmethod (:reset-old-redisplay-pieces redisplay-helper-stream) (new-pieces)
  (setq old-redisplay-pieces new-pieces))

(defmethod (:next-redisplay-piece redisplay-helper-stream) ()
  (pop old-redisplay-pieces))

(defmethod (:format-table-contents redisplay-helper-stream) (options continuation)
  (check-table-state :format-table-contents self table-state '(nil :cell :graph-node))
  (letf ((table-state :table))
    (send self :display-internal continuation self
	  :piece-flavor 'table-redisplay-piece-table
	  :piece-hook (lambda (piece)
			(declare (sys:downward-function))
			(setf (table-redisplay-piece-table-table-options piece)
			      (copy-list options))))))

(defmethod (:format-menu-contents redisplay-helper-stream) (options continuation)
  (check-table-state :format-menu-contents self table-state '(nil :cell :graph-node))
  (letf ((table-state :menu))
    (send self :display-internal continuation self
	  :piece-flavor 'table-redisplay-piece-menu
	  :piece-hook (lambda (piece)
			(declare (sys:downward-function))
			(setf (table-redisplay-piece-menu-table-options piece)
			      (copy-list options))))))

(defmethod (:format-row-cells redisplay-helper-stream) (continuation &rest options)
  (check-table-state :format-row-cells self table-state '(:table))
  (send-if-handles stream :check-set-cursorpos-simulating-stream-no-cursor-back)
  (letf ((table-state :row)
	 (x-position x-position)
	 (y-position y-position))
    (lexpr-send self :display-internal continuation self
		:piece-flavor 'table-redisplay-piece-row
		options)))

(defmethod (:format-single-column-row-cells redisplay-helper-stream)
	   (continuation &rest options)
  (check-table-state :format-single-column-row-cells self table-state '(:table))
  (send-if-handles stream :check-set-cursorpos-simulating-stream-no-cursor-back)
  (letf ((table-state :row)
	 (x-position x-position)
	 (y-position y-position))
    (lexpr-send self :display-internal continuation self
		:piece-flavor 'table-redisplay-piece-single-column-row
		options)))

(defmethod (:format-column-cells redisplay-helper-stream) (continuation &rest options)
  (check-table-state :format-column-cells self table-state '(:table))
  (send-if-handles stream :check-set-cursorpos-simulating-stream-no-cursor-back)
  (letf ((table-state :column)
	 (x-position x-position)
	 (y-position y-position))
    (lexpr-send self :display-internal continuation self
		:piece-flavor 'table-redisplay-piece-column
		options)))

(defmethod (:format-cell redisplay-helper-stream) (continuation &rest options)
  (check-table-state :format-cell self table-state '(:row :column :menu))
  (letf ((gprint:*overriding-left-indent* 0)
	 (table-state :cell)
	 (x-position x-position)
	 (y-position y-position))
    (send self :display-internal continuation self
	  :piece-flavor 'table-redisplay-piece-cell
	  :piece-hook (lambda (piece)
			(declare (sys:downward-function))
			(setf (table-redisplay-piece-cell-cell-options piece)
			      (copy-list options))))))

(defmethod (:format-column-headings redisplay-helper-stream) (continuation &rest options)
  (check-table-state :format-column-headings self table-state '(:table))
  (letf ((table-state :row)
	 (x-position x-position)
	 (y-position y-position))
    (send self :display-internal continuation self
	  :piece-flavor 'table-redisplay-piece-column-headings
	  :piece-hook (lambda (piece)
			(let ((table (loop for superior = current-redisplay-piece
							then (redisplay-piece-superior
							       superior)
					   while superior
					   when (typep superior 'table-redisplay-piece-table)
					     return superior)))
			  (if (null (table-redisplay-piece-table-multiple-columns-column-heading-row
				      table))
			      (setf (table-redisplay-piece-table-multiple-columns-column-heading-row
				      table)
				    piece)
			      (cerror "Skip these headings"
				      "More than one set of column headings is not currently supported.
You can have more than one line within each cell.")))
			(setf (table-redisplay-piece-column-headings-column-headings-options
				piece)
			      (copy-list options))))))

(defmethod (:output-with-cell-left-margin redisplay-helper-stream)
	   (margin function &rest arguments)
  (letf ((cell-left-margin margin))
    (apply function arguments)))

(defun-in-flavor (force-output-cursor-position redisplay-helper-stream) ()
  (when cursorpos-pending
    (multiple-value-bind (x y)
	(send stream :read-cursorpos)
      (if (or (< y-position y)
	      (and (= y-position y)
		   (< x-position x))
	      ;; This is really to keep from using :increment-cursorpos on the
	      ;; encapsulating stream, which won't let you move backwards.  In a dynamic
	      ;; window, :set-cursorpos would make the exception happen in the middle of
	      ;; the line, which looks ugly.
	      (neq stream-real-set-cursorpos t))
	  (send stream :set-cursorpos x-position y-position)
	  (let ((dx x-position)
		(dy (- y-position y)))
	    (cond ((zerop dy)
		   (setq dx (- x-position x)))
		  ((and stream-has-newline-without-erasing
			(= dy (send stream :line-height)))
		   (send stream :newline-without-erasing))
		  (t
		   (send stream :increment-cursorpos (- x) dy)))
	    (unless (zerop dx)
	      (send stream :increment-cursorpos dx 0)))))
    (setq cursorpos-pending nil)))

(defun-in-flavor (increment-x-position redisplay-helper-stream) (dx)
  (minf-or min-x-position x-position)
  (minf-or min-y-position y-position)
  (incf x-position dx)
  (maxf-or max-x-position x-position)
  (maxf-or max-y-position (+ y-position max-line-height)))

(defmethod (:tyo redisplay-helper-stream) (char)
  (check-table-state :tyo self table-state '(nil :cell :graph-node))
  (selector char char=
    (#\Return
      (when (eq state :displaying)
	(setq max-line-height (or (send-if-handles stream :current-line-height)
				  (send self :line-height))))
      (multiple-value-bind (nil y)
	  (send self :read-cursorpos)
	(send self :set-cursorpos cell-left-margin (+ y max-line-height)))
      (setq max-line-height (send self :line-height)))
    (otherwise
      (case state
	(:displaying
	  (force-output-cursor-position)
	  (send stream :tyo char)
	  (send self :reset-cursorpos))
	(otherwise
	  (increment-x-position (send stream :character-width char))
	  (unless (or (char-equal char #\space) (char-equal char #\tab))
	    (setq any-output-p t)))))))

;;; See accept-present-default
(defmethod (:force-non-empty-presentation redisplay-helper-stream) ()
  (send self :tyo #\Space)
  (setq any-output-p t))

(defmethod (:fresh-line redisplay-helper-stream) ()
  (check-table-state :fresh-line self table-state '(nil :cell :graph-node))
  (cerror "Attempt to do redisplay anyway"
	  "You cannot do conditional newline output during redisplay, ~
since conditions may not be the same on both redisplay passes.
You should do an unconditional newline after the output rather than a conditional newline ~
at the start of it.")
  (unless (zerop (send self :read-cursorpos))
    (send self :tyo #\Return)
    t))

(defmethod (:with-character-style redisplay-helper-stream)
	   (style continuation xstream &optional bind-line-height)
  (cond ((or (eq state :displaying)
	     (not bind-line-height))
	 (send stream :with-character-style style continuation xstream bind-line-height))
	(t
	 (flet ((adjust-max-line-height-and-continue (xstream)
		  (declare (downward-function))
		  (maxf max-line-height (send self :line-height))
		  (funcall continuation xstream)))
	   (send stream :with-character-style style #'adjust-max-line-height-and-continue
					      xstream bind-line-height)))))

(defmethod (:set-cursorpos redisplay-helper-stream) (x y &optional (unit :pixel))
  (cl:ecase unit
    (:pixel )
    (:character
      (when x (setq x (* x (send stream :char-width))))
      (when y (setq y (* y (send stream :line-height))))))
  (when x (setq x-position x))
  (when y (setq y-position y))
  (when (eq state :displaying)
    (setq cursorpos-pending t)))

(defmethod (:read-cursorpos redisplay-helper-stream) (&optional (unit :pixel))
  (multiple-value-bind (x y)
      (values x-position y-position)
    (cl:ecase unit
      (:pixel )
      (:character
	(setq x (floor x (send stream :char-width))
	      y (floor y (send stream :line-height)))))
    (values x y)))

(defmethod (:increment-cursorpos redisplay-helper-stream) (dx dy &optional (unit :pixel))
  (cl:ecase unit
    (:pixel )
    (:character
      (setq dy (* dy (send stream :line-height))
	    dx (* dx (send stream :char-width)))))
  (send self :set-cursorpos (+ x-position dx) (+ y-position dy)))

(defmethod (:character-width redisplay-helper-stream) (char)
  (send stream :character-width char))

(defmethod (:char-width redisplay-helper-stream) ()
  (send stream :char-width))

(defmethod (:line-height redisplay-helper-stream) ()
  (send stream :line-height))

(defmethod (:erase-aluf redisplay-helper-stream) ()
  (send stream :erase-aluf))

(defmethod (:char-aluf redisplay-helper-stream) ()
  (send stream :char-aluf))

(defmethod (:clear-region redisplay-helper-stream) (&rest args)
  (when (eq state :displaying)
    (lexpr-send-if-handles stream :clear-region args)))

(defmethod (:clear-window redisplay-helper-stream) (&rest args)
  (lexpr-send stream :clear-window args))

(defmethod (:scroll-to-visible-cursor redisplay-helper-stream) (x y)
  (send stream :scroll-to-visible-cursor x y))

(defmethod (:x-scroll-to redisplay-helper-stream) (pos type)
  (send stream :x-scroll-to pos type))

(defmethod (:x-scroll-position redisplay-helper-stream) ()
  (send stream :x-scroll-position))

(defmethod (:y-scroll-to redisplay-helper-stream) (pos type)
  (send stream :y-scroll-to pos type))

(defmethod (:y-scroll-position redisplay-helper-stream) ()
  (send stream :y-scroll-position))

(defmethod (:scroll-one-screenful redisplay-helper-stream)
	   (backward-p &optional (context-nlines 1))
  (send stream :scroll-one-screenful backward-p context-nlines))

(defmethod (:output-as-presentation redisplay-helper-stream)
	   (continuation xstream &rest args)
  (case state
    (:displaying
      (force-output-cursor-position)
      (lexpr-send stream :output-as-presentation continuation xstream args))
    (otherwise
      (funcall continuation xstream)
      nil)))

(defmethod (:output-as-presentation-1 redisplay-helper-stream)
	   (continuation continuation-args &rest args)
  (case state
    (:displaying
      (force-output-cursor-position)
      (lexpr-send stream :output-as-presentation-1 continuation continuation-args args))
    (otherwise
      (apply continuation continuation-args)
      nil)))

(defmethod (:string-out redisplay-helper-stream) (string &optional (start 0) end)
  (check-table-state :string-out self table-state '(nil :cell :graph-node))
  (let ((displaying (eq state :displaying)))
    (if displaying
	(force-output-cursor-position)
	(when (string-search-not-set '(#\space #\tab #\return) string :start start :end end)
	  (setq any-output-p t)))
    (do-delimited-substrings ((string :start start :end end)
			      (char start-index end-index))
        (unless (= start-index end-index)
	  (if displaying
	      (send stream :string-out string start-index end-index)
	      (multiple-value-bind (x nil nil nil height)
		  (send stream :string-length string start-index end-index)
		(when height
		  (maxf max-line-height height))
		(increment-x-position x))))
      (#\Return
       (send self :tyo char)
       (force-output-cursor-position)))
    (when displaying
      (send self :reset-cursorpos))))

(defmethod (:output-for-re-presentation encapsulating-output-stream)
	   (presentation continuation xstream)
  (send stream :output-for-re-presentation presentation continuation xstream))

(defmethod (:copy-presentations redisplay-helper-stream) (copies)
  (copy-presentations copies stream))

(defmethod (:displayed-presentations redisplay-helper-stream) ()
  (and (eq state :displaying)
       (send stream :displayed-presentations)))

(defmethod (:clear-between-cursorposes redisplay-helper-stream) (&rest args)
  (when (eq state :displaying)
    (lexpr-send stream :clear-between-cursorposes args)))


(defresource mark-table ()
  :initial-copies 0
  :clear-for-gc :cleanup
  :constructor (cl:make-hash-table :locking nil :number-of-values 0)
  :deinitializer (clrhash object))

;;; Later this should interface to the window in a window that really
;;; moves presentations so that sensitivity is preserved.
(defun copy-presentations (copies stream)
  ;; Sort into preferred order.
  (labels ((sort-copies (copies)
	     (setf (rdcopies-inferior-copies copies)
		   (sort (rdcopies-inferior-copies copies) #'box-position-greaterp
			 :key #'rdcopies-new-box))
	     (dolist (copy (rdcopies-inferior-copies copies))
	       (sort-copies copy))))
    (sort-copies copies))
  ;; Arrange to bitblt areas that are shared, and erase those explicitly requested.
  (labels ((adjoin-copies (copies)
	     (let ((pending-copies nil)
		   (inferior-boxes (rdcopies-old-inferior-boxes copies)))
	       (dolist (erase (rdcopies-boxes-to-erase copies))
		 (setq pending-copies (adjoin-box-erase pending-copies inferior-boxes
							erase)))
	       (dolist (copy (rdcopies-inferior-copies copies))
		 (setq pending-copies (adjoin-box-copy pending-copies
						       inferior-boxes
						       (rdcopies-old-box copy)
						       (rdcopies-new-box copy)))
		 (adjoin-copies copy))
	       (setf (rdcopies-pending-copies copies) pending-copies))))
    (adjoin-copies copies))
  ;; Erase parts of old pieces that got moved away and nothing else moved into the new area.
  (stack-let ((newly-filled (make-coordinate-sorted-set))
	      (boxes-to-erase nil))
    (labels ((collect-filling (copies)
	       (if (rdcopies-protect-new-box copies)
		   (add-to-coordinate-sorted-set (rdcopies-new-box copies) newly-filled
						  :key #'identity)
		   (map () #'collect-filling (rdcopies-inferior-copies copies)))))
      (collect-filling copies))
    (labels ((adjoin-all-erases (copies)
	       (let ((elem (assoc 'nil (rdcopies-pending-copies copies))))
		 (when elem
		   (dolist (box (rest elem))
		     (dolist (box (box-set-difference-sorted box newly-filled))
		       (setq boxes-to-erase (adjoin-boxes box boxes-to-erase))))
		   (setf (rdcopies-pending-copies copies)
			 (delete elem (rdcopies-pending-copies copies)))))
	       (dolist (box (rdcopies-boxes-to-maybe-erase copies))
		 (dolist (box (box-set-difference-sorted box newly-filled))
		   (setq boxes-to-erase (adjoin-boxes box boxes-to-erase))))
	       (dolist (copy (rdcopies-inferior-copies copies))
		 (adjoin-all-erases copy))))
      (adjoin-all-erases copies))
    (push (cons 'nil boxes-to-erase) (rdcopies-pending-copies copies)))
  (let ((off-screen-copies nil))
    (flet ((do-pending-copies (copies)
	     ;; Copying and erasing here should not affect subpresentations.
	     (stack-let ((protected-presentations (make-array (length (rdcopies-inferior-copies
									copies)))))
	       (loop for copy in (rdcopies-inferior-copies copies)
		     for i from 0 do
		 (setf (aref protected-presentations i)
		       (rdcopies-displayed-presentation copy)))
	       (setq off-screen-copies (do-box-copies (rdcopies-pending-copies copies)
						      stream protected-presentations
						      off-screen-copies)))
	     (setf (rdcopies-copy-done-p copies) t)))
      ;; Now do bitblts.  If getting smaller, must do in place before moving.
      (labels ((compact (copies)
		 (dolist (copy (rdcopies-inferior-copies copies))
		   (compact copy))
		 (when (or (null (rdcopies-displayed-presentation copies))
			   (box-smaller-p (rdcopies-new-box copies)
					  (rdcopies-old-box copies)))
		   (do-pending-copies copies))))
	(compact copies))
      (labels ((expand (copies)
		 (unless (rdcopies-copy-done-p copies)
		   (do-pending-copies copies))
		 (dolist (copy (rdcopies-inferior-copies copies))
		   (expand copy))))
	(expand copies)))
    ;; Adjust the presentations' boxes.  Remember that :note-box-shift didn't do this.
    ;; Work inside out regardless, so that things with more accurate new boxes get set
    ;; first and others based on their superior's motion only in the absense of better
    ;; information.
    (using-resource (mark-table mark-table)
      (labels ((move-presentations (copies)
		 (dolist (copy (rdcopies-inferior-copies copies))
		   (move-presentations copy)
		   (let ((presentation (rdcopies-displayed-presentation copy))
			 (new-box (rdcopies-new-box copy)))
		     (unless (box-equal (presentation-displayed-box presentation) new-box)
		       (presentation-set-displayed-box presentation new-box mark-table))))
		 (dolist (dead (rdcopies-old-dead-inferiors copies))
		   (send stream :delete-displayed-presentation dead))
		 (setf (rdcopies-old-dead-inferiors copies) nil)))
	(move-presentations copies)))
    ;; Erase those portions that got moved or changed and will be rewritten.
    (do-box-erases (rdcopies-pending-copies copies) stream)
    ;; Window will have bene overzealous in forgetting things that got partially erased.
    (labels ((repatriate (copies)
	       (dolist (copy (rdcopies-inferior-copies copies))
		 (let ((presentation (rdcopies-displayed-presentation copy)))
		   (pushnew presentation
			    (presentation-inferiors (presentation-superior presentation))))
		 (repatriate copy))))
      (repatriate copies))
    ;; Refresh those parts of the screen into which things were to be copied but from invisible
    ;; areas.
    (when off-screen-copies
      (send stream :update-viewport-indices)
      (dolist (box (cdr (assoc 'nil off-screen-copies)))
	(send stream :redraw-inside-sets box)))))

(defmacro with-hidden-output ((&optional stream &key initially-visible)
			      label-form &body hidden-forms)
  (format-output-macro-default-stream stream)
  `(with-redisplayable-output (:unique-id ',(gensym)		;Just in case
		:stream ,stream
		:redisplay-piece .piece.
		:piece-hook (lambda (piece)
			      (setf (redisplay-piece-extra-state piece) ,initially-visible)))
     (with-output-as-presentation (:stream ,stream
			     :object ,initially-visible
			     :type 'hidden-output
			     :location (and .piece.
					    (locf (redisplay-piece-extra-state .piece.))))
       ,label-form)
     (when (if .piece.
	       (redisplay-piece-extra-state .piece.)
	       ,initially-visible)
       . ,hidden-forms)))

(define-presentation-type hidden-output ()
   :expander 't)

;;; This is a translator, not an action, so as to cause a wakeup on the input side.
(define-presentation-translator hidden-output
				(hidden-output window-wakeup-redisplay
				 :tester ((ignore &key presentation)
					  (presentation-object-value-replace-p presentation))
				 :documentation ((on-p)
						 (format nil "~:[Open~;Close~] this output."
							 on-p))
				 :gesture :select
				 :do-not-compose t D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"); DON'T run the body unless clicked.
0				 :context-independent t)
				(on-p &key presentation window)
  (replace-presentation-object-value presentation (not on-p))
  window)

(defun format-item-list (list &key (stream *standard-output*)
				    printer presentation-type
				    (key #'identity)
				    (fresh-line t) (return-at-end t)
				    (order-columnwise t)
				    (optimal-number-of-rows si:*optimal-number-of-rows*)
				    (additional-indentation 2)
				    (equalize-column-widths nil)
				    max-width max-height)
  (cond ((and printer presentation-type)
	 (error "Cannot specify both type and printer."))
	((null printer)
	 (setq printer (lambda (object stream)
			 (present object (or presentation-type (type-of object))
				  :stream stream)))))
  (when fresh-line
    (fresh-line stream))
  (unless (null list)
    (flet ((do-it (stream)
	     (when additional-indentation
	       (send stream :increment-cursorpos additional-indentation 0 :character))
	     (formatting-item-list
	       (stream :row-wise (not order-columnwise)
		       :output-row-wise t
		       :n-rows optimal-number-of-rows
		       :inter-column-spacing (* 2 (send stream :char-width))
		       :equalize-column-widths equalize-column-widths
		       :max-width (or max-width
				      (multiple-value-bind (ll ignore rr ignore)
					  (send stream :visible-cursorpos-limits)
					(- rr (max ll
						   (send stream :read-cursorpos)))))
		       :max-height max-height
		       :return-at-end return-at-end
		       )
	       (dolist (item list)
		 (format-cell (funcall key item) printer :stream stream)))))
      ;; Must encapsulate before the :increment-cursorpos above to set left margin.
      (if (member (send-if-handles stream :real-set-cursorpos) '(nil :hardcopy))
	  ;;See do-redisplay.
	  (using-resource (better-stream set-cursorpos-simulating-stream stream)
	    (do-it better-stream))
	  (do-it stream))))
  list)

(define-presentation-type window-wakeup () )
(define-presentation-type window-wakeup-select ()
   :expander 'window-wakeup)
(define-presentation-type window-wakeup-expose ()
   :expander 'window-wakeup)
(define-presentation-type window-wakeup-refresh ()
   :expander 'window-wakeup)
(define-presentation-type window-wakeup-viewport-position-changed ()
   :expander 'window-wakeup)
