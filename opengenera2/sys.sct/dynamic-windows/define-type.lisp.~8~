;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")define-presentation-type0 macro and support.

(defvar *presentation-type-being-compiled* nil)
(defvar *presentation-type-being-compiled-arglist*)

(defprop define-presentation-type "Presentation type" si:definition-type-name)

;;; The local state for expanding a 1define-presentation-type0.  Purely a temporary
;;; object.
(defflavor presentation-type-definition
	(type-name arglist
		   (parser) (printer) (viewspec-choices)
		   (description) (describer) (no-deftype) (disallow-atomic-type)
		   history (expander)
		   (abbreviation-for) (expander-stack) (abbreviation-for-stack)
		   (choose-displayer) (accept-values-displayer) (menu-displayer)
		   (default-preprocessor) (history-postprocessor) (highlighting-box-function)
		   (presentation-type-arguments)
		   (presentation-subtypep) (key-generator) (key-function)
		   (map-over-subtypes) (map-over-supertypes)
		   (map-over-supertypes-and-subtypes)
		   (typep)
		   (with-cache-key) (with-full-cache-key)
		   (do-compiler-warnings)
		   (data-arguments-are-disjoint)

		   (reversed-output)
		   create-form
		   no-deftype-needed
		   data-arglist pr-arglist
		   (input-history-expander) (history-form))
	()
  :initable-instance-variables
  (:readable-instance-variables reversed-output))

;;; Check validity and compatibility of arguments
(defmethod (define-presentation-type-phase-1 presentation-type-definition) ()
  (check-type type-name symbol)
  (check-type arglist list)
  (when (and description describer)
	(warn "Both ~S and ~S supplied." :description :describer)
	(setq description nil))
  ;;--- There must be a better way to effect this.
  (when (and (null description)
	     (null describer)
	     (or expander abbreviation-for))
    ;; If this type is equivalent to (or a restriction of) another type and no
    ;; description was supplied, generate one.
    (setq description (let ((string (string-downcase type-name)))
			(when (find #\- string)
			  (setq string (substitute #\Space #\- string)))
			(if (zerop (length string))
			    "a ||"		;silly case
			  (string-a-or-an string)))))
  (setq data-arglist (car arglist))
  (setq pr-arglist (cdr arglist))
  (check-type data-arglist list)
  (check-type pr-arglist list)
  (when pr-arglist
    (unless (or (eq (car pr-arglist) '&key)
		(eq (car pr-arglist) '&rest))
      (warn '(:fatal t) "Only keyword presentation arguments are allowed.")))
  
  (macrolet ((check-bad-combo (key1 val1 key2 val2 &optional val3)
	       `(when (and ,val1 ,val2)
		  (warn "Both ~S and ~S supplied." ,key1 ,key2)
		  (setq ,val2 nil ,@(when val3 `(,val3 nil))))))
    (check-bad-combo :no-deftype no-deftype
		     :expander expander expander-stack)
    (check-bad-combo :no-deftype no-deftype
		     :abbreviation-for abbreviation-for abbreviation-for-stack)
    (check-bad-combo :abbreviation-for abbreviation-for
		     :expander expander expander-stack)
    (check-bad-combo :abbreviation-for-stack abbreviation-for-stack
		     :expander expander expander-stack)
    (check-bad-combo :abbreviation-for abbreviation-for
		     :expander-stack expander-stack expander)
    (check-bad-combo :abbreviation-for-stack abbreviation-for-stack
		     :expander-stack expander-stack expander)
    (check-bad-combo :abbreviation-for-stack abbreviation-for-stack
		     :map-over-subtypes map-over-subtypes)
    (check-bad-combo :abbreviation-for-stack abbreviation-for-stack
		     :map-over-supertypes map-over-supertypes)
    (check-bad-combo :abbreviation-for abbreviation-for
		     :map-over-subtypes map-over-subtypes)
    (check-bad-combo :abbreviation-for abbreviation-for
		     :map-over-subtypes map-over-subtypes)
    (check-bad-combo :expander-stack expander-stack
		     :map-over-supertypes map-over-supertypes)
    (check-bad-combo :map-over-supertypes-and-subtypes map-over-supertypes-and-subtypes
		     :map-over-supertypes map-over-supertypes)
    (check-bad-combo :map-over-supertypes-and-subtypes map-over-supertypes-and-subtypes
		     :map-over-subtypes map-over-subtypes))
  (labels ((check-not-heap-stack (key-heap val-heap key-stack val-stack)
	     (when (and val-stack (not val-heap))
	       (warn "~S must be supplied if ~S is supplied."
		     key-heap key-stack))))
    (check-not-heap-stack :abbreviation-for abbreviation-for
			  :abbreviation-for-stack abbreviation-for-stack)
    (check-not-heap-stack :expander expander :expander-stack expander-stack)))

;;; Do defaulting
(defmethod (define-presentation-type-phase-2 presentation-type-definition) ()
  (setq create-form (copy-list `(initialize-presentation-type ',type-name
							      :record-source-file-name nil))
	no-deftype-needed (or no-deftype
			      (member type-name *standard-terminal-types*)
			      (flavor:find-flavor type-name nil)
			      (defstruct-type-p type-name)))
  ;; Really, we should output a defining form that builds a closure.
  (when (stringp printer)
    (setq printer `((ignore stream) (princ ,printer stream))))

  (when (not data-arguments-are-disjoint)
    (unless (or key-function key-generator)
      (setq key-function '#'standard-key-generator))
    (unless with-cache-key
      (setq with-cache-key '#'standard-cache-key-generator)))

  (when (variable-boundp history)
    (multiple-value-setq  (history input-history-expander history-form)
	 (interpret-history-spec-arg history type-name)))
  
  (when (and (null data-arglist)
	     (null pr-arglist))
    ;; Canonicalize this case.
    (setq arglist nil))
  
  (when map-over-supertypes-and-subtypes
    (setq map-over-supertypes map-over-supertypes-and-subtypes))

  )

(defmacro-in-flavor (output presentation-type-definition) (x)
  `(push ,x reversed-output))

(defmacro-in-flavor (create-args presentation-type-definition) (keyword value)
  `(setf create-form (nconc create-form (list* ,keyword ,value nil))))

(defmacro-in-flavor (if-have-do presentation-type-definition) (&rest xs)
  `(progn .
	  ,(loop for x in xs
		 collect
		   (let ((prop (case x
				 (describer 'presentation-type-printer)
				 (otherwise x))))
		     `(when ,x
			(output (def-pres-type-fngenerate
				  type-name ,x arglist ',prop)))))))


(defparameter *presentation-type-definition-version* 2)

;;; Generate the output
(defmethod (define-presentation-type-phase-3 presentation-type-definition) ()
  ;; Do this first, so we aren't nesting type definitions.
  (unless no-deftype
    (output
      `(deftype ,type-name ,data-arglist
	 ,@(find-lambda-vars data-arglist)
	 `(presentation-only-type ,',type-name))))
  (output create-form)
  (create-args :version *presentation-type-definition-version*)
  (when no-deftype
    (create-args :cl-type-allowed no-deftype))
  (if-have-do parser printer viewspec-choices describer
	      input-history-expander choose-displayer
	      accept-values-displayer
	      default-preprocessor history-postprocessor highlighting-box-function
	      menu-displayer do-compiler-warnings
	      map-over-subtypes map-over-supertypes
	      )

  ;; If we've got the same function for both, copy the definition.
  (when map-over-supertypes-and-subtypes
    (output `(deff (presentation-function ,type-name map-over-subtypes)
		   #'(presentation-function ,type-name map-over-supertypes))))
  (hack-do-compiler-warnings self)
  (hack-inheritance self)
  (hack-presentation-subtypep self)
  (hack-typep self)
  (hack-type-key self)
  (hack-cache-key self)
  (hack-full-cache-key self)
  (hack-flags self)
  ;; Say we're done changing this type.
  (output `(finish-type-redefinition ',type-name))
  )

(defmethod (hack-do-compiler-warnings presentation-type-definition) ()
  (when (and (not do-compiler-warnings)
	     presentation-type-arguments)
    (let ((type-var (make-symbol "TYPE"))
	  (args-var (make-symbol "ARGS")))
      (output `(defun (presentation-function ,type-name do-compiler-warnings)
		      (,type-var &rest ,args-var)
		 (declare (compiler:do-not-record-these-macros
			    with-presentation-type-arguments))
		 (with-presentation-type-arguments (,type-name ,type-var)
		   ,@(let ((rest-data (second (member '&rest data-arglist)))
			   (rest-pr (second (member '&rest pr-arglist))))
		       (loop for tparg in presentation-type-arguments
			     collect
			       (if (or (eql tparg rest-data)
				       (eql tparg rest-pr))
				   `(dolist (one-type ,tparg)
				      (apply #'check-presentation-type-argument one-type
					     :evaluated nil ,args-var))
				 `(apply #'check-presentation-type-argument ,tparg
					 :evaluated nil
					 ,args-var))))))))))

(defmethod (hack-inheritance presentation-type-definition) ()
  (let ((type-var (gensymbol "TYPE-"))
	(function-var (gensymbol "FUNCTION-")))
    (unless abbreviation-for-stack
      (when abbreviation-for
	(unless (constantp abbreviation-for)
	  (unless (lt::variablep abbreviation-for)	;No consing needed
	    (setq abbreviation-for-stack
		  `((,type-var ,function-var)
		    (declare (compiler:do-not-record-these-macros
			       with-presentation-type-arguments))
		    (with-presentation-type-arguments (,type-name ,type-var)
		      (stack-let ((type ,abbreviation-for))
			(funcall ,function-var type)))))))))

    (unless expander-stack
      (when expander
	(unless (constantp expander)
	  (unless (lt::variablep expander)	;No consing needed.
	    (setq expander-stack
		  `((,type-var ,function-var)
		    (declare (compiler:do-not-record-these-macros
			       with-presentation-type-arguments))
		    (with-presentation-type-arguments (,type-name ,type-var)
		      (stack-let ((type ,expander))
			(funcall ,function-var type)))))))))

    (when abbreviation-for
      (if (constantp abbreviation-for)
	  (output `(defun (presentation-function ,type-name data-type-equivalent) (ignore)
		     ,abbreviation-for))
	(output `(defun (presentation-function ,type-name data-type-equivalent) (,type-var)
		   (declare (compiler:do-not-record-these-macros
			      with-presentation-type-arguments))
		   (with-presentation-type-arguments (,type-name ,type-var)
		     ,abbreviation-for)))))

    (when abbreviation-for-stack
      (output `(defun (presentation-function ,type-name data-type-equivalent-stack)
		      ,@abbreviation-for-stack)))

    (when expander
      (if (constantp expander)
	  (output `(defun (presentation-function ,type-name data-type-generator) (ignore)
		     ,expander))
	(output `(defun (presentation-function ,type-name data-type-generator) (,type-var)
		   (declare (compiler:do-not-record-these-macros
			      with-presentation-type-arguments))
		   (with-presentation-type-arguments (,type-name ,type-var)
		     ,expander)))))

    (when expander-stack
      (output `(defun (presentation-function ,type-name data-type-generator-stack)
		      ,@expander-stack)))))

(defmethod (hack-presentation-subtypep presentation-type-definition) ()
  (when (and presentation-type-arguments
	     (not map-over-subtypes)
	     (not map-over-supertypes)
	     (not presentation-subtypep)
	     (not expander)
	     (not abbreviation-for))
    (warn "A ~S, ~S, or ~S option is required~@
	       for proper operation when a type has presentation-type arguments."
	  :presentation-subtypep :expander :abbreviation-for))	      

  (when presentation-subtypep
    (unless (or key-generator key-function presentation-type-arguments)
      (warn "A ~S, ~S, ~S or ~S option is required~@
		 when ~S is present for proper operation.~@
		 Whenever one type is ~S of another, their keys must be the same~@
		 (~S atoms, or lists who's atoms are ~S)."
	    :data-arguments-are-disjoint :key-generator
	    :key-function :presentation-type-arguments
	    :presentation-subtypep
	    'presentation-subtypep 'eql 'eql))
    (if (atom presentation-subtypep)
	(output `(deff (presentation-function ,type-name presentation-subtypep)
		       ',presentation-subtypep))
      (let ((arglist (first presentation-subtypep)))
	(unless (and (listp arglist)
		     (= (length arglist) 2))
	  (warn "~S is not a legal argument list for ~S functions."
		arglist :presentation-subtypep)))
      (output `(defun (presentation-function ,type-name presentation-subtypep)
		      ,(first presentation-subtypep)
		 ,@(rest presentation-subtypep))))))

(defmethod (make-key-generator presentation-type-definition) (key-macro key-type)
  (let* ((function (make-symbol "FUNCTION"))
	 (type-name-var (make-symbol "TYPE-NAME"))
	 (body
	   `(macrolet ((non-list (var)
			 `(if (listp ,var)
			      (%make-pointer dtp-locative ,var)
			    ,var)))
	      (stack-let
		((key (list ,type-name-var
			    ,@(loop for var
					in (find-lambda-vars data-arglist)
				    collect (if (member var
							presentation-type-arguments)
						var
					      `(non-list ,var))))))
		(funcall ,function key)))))
    (loop for parg in presentation-type-arguments
	  do (setf body
		   `(,key-macro (,parg ,parg)
		     ,body)))
    (output `(defun (presentation-function ,type-name ,key-type)
		    (,function ,type-name-var ,@data-arglist)
	       (declare (dbg:invisible-frame :presentation-handler-search))
	       ,body))))

(defmethod (hack-type-key presentation-type-definition) ()
  (when (and (null key-function) (null key-generator)
	     (or presentation-type-arguments (member '&key data-arglist)))
    (make-key-generator self 'with-presentation-type-key 'key-generator))
	
  (when key-function
    (when key-generator
      (warn "Both a ~S and an ~S option were provided.  Only ~S will be used."
	    :key-function :key-generator :key-function)
      (setq key-generator nil))
    (cond ((atom key-function)
	   (output `(deff (presentation-function ,type-name key-generator)
			  ',key-function)))
	  ((or (eq (car key-function) 'function)
	       (eq (car key-function) 'quote))
	    (output `(deff (presentation-function ,type-name key-generator)
			  ,key-function)))
	  (t (output `(defun (presentation-function ,type-name key-generator)
			     (,@(loop with args = (first key-function)
				      repeat 2
				      collect (if args (pop args) 'ignore))
			      ,@data-arglist)
			(declare (dbg:invisible-frame :presentation-handler-search))
			,@(rest key-function))))))

  (when key-generator
    (cond ((atom key-generator)
	   (output `(deff (presentation-function ,type-name key-generator)
			  ',key-generator)))
	  ((or (eq (car key-generator) 'function)
	       (eq (car key-generator) 'quote))
	   (output `(deff (presentation-function ,type-name key-generator)
			  ,key-generator)))
	  (t (let ((key (make-symbol "KEY"))
		   (type-name-var (make-symbol "TYPE-NAME"))
		   (function (make-symbol "FUNCTION")))
	       (output `(defun (presentation-function ,type-name key-generator)
			       (,function ,type-name-var ,@data-arglist)
			  (declare (dbg:invisible-frame :presentation-handler-search))
			  (macrolet ((with-presentation-type-arguments (ignore &rest body)
				       (warn "~S is not legal inside a ~S function.~@
					     You may not reference presentation arguments."
					     'with-presentation-type-arguments
					     :key-generator)
				       `(progn ,@body)))
			    ,type-name-var
			    (stack-let ((,key ,key-generator))
			      (funcall ,function ,key))))))))))

(defmethod (hack-cache-key presentation-type-definition) ()
  (when (and (or (null with-cache-key)
		 (equal with-cache-key '#'standard-cache-key-generator))
	     presentation-type-arguments)
    (make-key-generator self 'with-key-for-cache 'with-cache-key)
    (setq with-cache-key nil))			(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Don't generate another later.
0  (when with-cache-key
    (cond ((atom with-cache-key)
	   (output `(deff (presentation-function ,type-name with-cache-key)
			  ',with-cache-key)))
	  ((or (eq (car with-cache-key) 'function)
	       (eq (car with-cache-key) 'quote))
	   (output `(deff (presentation-function ,type-name with-cache-key)
			  ,with-cache-key)))
	  (t (destructuring-bind ((function-var original-type-name) &body body) with-cache-key
	       (output `(defun (presentation-function ,type-name with-cache-key)
			       (,function-var ,original-type-name ,@data-arglist)
			  (declare (dbg:invisible-frame :presentation-handler-search))
			  ,@body)))))))

(defmethod (hack-full-cache-key presentation-type-definition) ()
  (if with-full-cache-key
      (cond ((atom with-full-cache-key)
	     (output `(deff (presentation-function ,type-name with-full-cache-key)
			    ',with-full-cache-key)))
	    ((or (eq (car with-full-cache-key) 'function)
		 (eq (car with-full-cache-key) 'quote))
	     (output `(deff (presentation-function ,type-name with-full-cache-key)
			    ',with-full-cache-key)))
	    (t (destructuring-bind (user-arglist &body body) with-full-cache-key
		 (restructuring-arglist ((function type &optional do-not-cache
						   (original-type type))
					 (function &key type do-not-cache original-type))
			  (new-arglist user-arglist)
			  (new-body body)
		    (output `(defun (presentation-function ,type-name with-full-cache-key)
				    ,new-arglist
			       (declare (dbg:invisible-frame :presentation-handler-search))
			       (with-presentation-type-arguments (,type-name ,type)
				 ,@new-body)))))))
    (output (make-full-cache-key self))))


;;; Make the top-level definition form, returning it.
(defmethod (make-full-cache-key presentation-type-definition) ()
  (let ((new-arglist)
	(tests)
	(vals)
	(real-rest (gensymbol "REAL-REST-"))
	(rest-p))
    (labels ((map-arglist (arg state)
	       (setq arg (car arg))		;Damfino why 1lt:map-over-lambda-list0 is stupid
	       (ecase state
		 (:rest
		   (when (and (string-equal arg "IGNORE")
			      (not presentation-type-arguments))
		     ;; If we have 1&rest0 var, then order matters, and we
		     ;; have to do the full key.
		     (return-from make-full-cache-key
		       `(deff (presentation-function ,type-name with-full-cache-key)
			      #'standard-cache-key-generator-rest)))
		   ;; IGNORE
		   (unless (string-equal real-rest "IGNORE")
		     (setq real-rest arg
			   rest-p t)))
		 (:key (push (cond ((atom arg) arg)
				   ((lt::key-supplied-p-arg-name arg)
				    (lt::key-supplied-p-arg-name arg))
				   ((null (lt::arg-default arg)) (lt::key-arg-name arg))
				   ((not (constantp (lt::arg-default arg)))
				    (let ((supplied-p
					    (gensymbol (string-append (lt::key-arg-name arg)
								      "-SUPPLIED-P-"))))
				      (setq arg `(,(lt::arg-name arg) ,(lt::arg-default arg)
						  ,supplied-p))
				      supplied-p))
				   (t `(not (eql ,(lt::key-arg-name arg)
						 ,(lt::arg-default arg)))))
			     tests)
		  (push arg new-arglist)
		  (push (lt::key-arg-name arg) vals)))))
      (multiple-value-bind (key-p allow-other-keys)
	  (lt:map-over-lambda-list pr-arglist #'map-arglist)
	(ignore allow-other-keys)		;Always; remember 1:description
0	(setq tests (nreverse tests)
	      vals (nreverse vals)
	      new-arglist `(&rest ,real-rest
			    ,@(when key-p `(&key))
			    ,@(nreverse new-arglist)
			    ,@(when key-p `(&allow-other-keys))))

	(case (length tests)
	  ((0 1 2)
	   (if (null presentation-type-arguments)
	       `(deff (presentation-function ,type-name with-full-cache-key)
		      #'standard-cache-key-generator-rest)
	     (make-general-full-key-generator self tests vals new-arglist rest-p real-rest)))
	  (otherwise (make-general-full-key-generator self tests vals new-arglist
						      rest-p real-rest)))))))


;;; Make the general-case 
;;; We could arrange to not push the flag words when they're all zero, and just
;;; use the datatype.
(defmethod (make-general-full-key-generator presentation-type-definition)
	   (tests vals new-arglist rest-p real-rest)
  (let* ((function (gensymbol "CONTINUATION-"))
	 (do-not-cache (gensymbol "DO-NOT-CACHE-"))
	 (original-type (gensymbol "ORIGINAL-TYPE-"))
	 (data-type (gensymbol "DATA-TYPE-"))
	 (data-type-name (gensymbol "TYPE-NAME-"))
	 (type-dargs (gensymbol "DATA-TYPE-ARGS-"))
	 (data-type-cache-key (gensymbol "DATA-TYPE-CACHE-KEY-"))
	 (decode-presentation-args (gensymbol "DECODE-PRESENTATION-ARGS-"))
	 (decode-data-args (gensymbol "DECODE-DATA-ARGS-"))
	 (full-cache-key-function (gensymbol "FULL-CACHE-KEY-FUNCTION-"))
	 (type (gensymbol "TYPE-"))
	 (count (gensymbol "COUNT-"))
	 (flags (loop repeat (ceiling (length tests) 32)
		      collect (gensymbol "BITMASK-")))
	 (result-list (gensymbol "RESULT-LIST-"))
	 (meta-keywords (gensymbol "META-KEYWORDS-"))
	 (meta-missing (gensymbol "META-MISSING-"))
	 (meta-val (gensymbol "META-KEYWORD-VALUE-"))
	 (meta-keywords-filter (find-meta-presentation-keywords-filter pr-arglist
								       :force))
	 (full-cache-key-function-def)
	 (invoke-form `(apply #'with-cache-key
			      (symbol-presentation-type-descriptor ,data-type-name)
			      #',decode-data-args ,data-type-name ,type-dargs)))
    (labels ((make-push (v do-not-cache)
	       (if (member v presentation-type-arguments)
		   `(progn (incf ,count)
			   (%push ,v))
		 (unless rest-p
		   `(progn (when (locally (declare (notinline consed-in-control-stack ))
					  (consed-in-control-stack ,v))
			     (setq ,do-not-cache t))
			   (incf ,count)
			   (%push (if (atom ,v)
				      ,v
				    (%make-pointer dtp-locative ,v))))))))

      (when presentation-type-arguments
	(setq full-cache-key-function-def
	      (list (make-full-data-key-generator self full-cache-key-function
						  do-not-cache))
	      invoke-form `(apply #',full-cache-key-function #',decode-data-args
				  ,data-type-name ,type-dargs)))
      (let ((body
	      `((let ((,result-list)
		      (,count 0)
		      ;; We don't bother when there's a &rest argument.  Even though
		      ;; this distinguishes types which aren't really distinct, as
		      ;; the &rest argument filters out the meta args.  This doesn't
		      ;; hurt us much; it just means that meta-args in a different position
		      ;; will register as a distinct type, and not be encached as identical.
		      ,@(when (and meta-keywords-filter
				   (not rest-p))
			  `((,meta-keywords ,meta-keywords-filter)
			    (,meta-missing '(no-meta-arg))
			    (,meta-val)))
		      ,@(unless rest-p
			  (loop for flag in flags
				collect `(,flag 0))))
		  (%push ,data-type-cache-key)
		  ,@(if rest-p
			(find-lambda-vars new-arglist)
		      (loop with flags = flags
			    with flag
			    for test in tests
			    for i from 0
			    when (zerop (mod i 32))
			      do (setf flag (pop flags)
				       i 0)
			    collect `(when ,test
				       (setf ,flag
					     (logior ,(lsh 1 i) ,flag)))))
		  ;; We could make this slightly faster by pushing it
		  ;; last, and only performing the tests once, but
		  ;; having it here makes the keys differ sooner if
		  ;; args aren't supplied.
		  ,@(unless rest-p
		      `((incf ,count ,(length flags))
			,@(loop for flag in flags
				collect `(%push ,flag))
			,@(loop for test in tests
				for val in vals
				collect `(when ,test
					   ,(make-push val do-not-cache)))))
		  ,@(when (and meta-keywords-filter
			       (not rest-p))
		      `((loop while ,meta-keywords
			      do
			  (setq ,meta-val (getf ,real-rest
						(pop ,meta-keywords)
						,meta-missing))
			  (unless (eq ,meta-val ,meta-missing)
			    (incf ,count)
			    (%push ,meta-val)))))
		  ,@(if (not rest-p)
			`((setq ,result-list (%finish-stack-list ,count)))
		      `((incf ,count)
			(%push ,real-rest)
			(setq ,result-list
			      (%finish-stack-list* ,count))))
		  (funcall ,function ,result-list ,do-not-cache)))))
	(setq body
	      (wrap-presentation-type-arguments-full-cache-key
		self body do-not-cache () () real-rest rest-p vals))
	`(defun (presentation-function ,type-name with-full-cache-key)
		(,function ,type ,do-not-cache ,original-type)
	   (declare (sys:downward-funarg ,function)
		    (dbg:invisible-frame :presentation-handler-search))
	   (flet ((,decode-presentation-args (,data-type ,@new-arglist)
		   (with-type-decoded (nil ,type-dargs) ,data-type
		      (with-type-decoded (,data-type-name) ,original-type
			 (flet ((,decode-data-args
				 (,data-type-cache-key
				  ;; This is optional so we can use 1with-cache-key0, which
				  ;; does not pass it through.
				  &optional (,do-not-cache ,do-not-cache))
				 (declare (sys:downward-function)
					  (dbg:invisible-frame :presentation-handler-search))
				 ,@body)
				,@full-cache-key-function-def)
			   (if (null ,type-dargs)
			       (,decode-data-args ,data-type-name ,do-not-cache)
			       ,invoke-form))))))
	     (apply #',decode-presentation-args ,type)))))))

;;; Make the internal function to construct the data-type portion of the key.

(defmethod (make-full-data-key-generator presentation-type-definition)
	   (full-cache-key-function do-not-cache)
  (let* ((continuation (gensymbol "CONTINUATION-"))
	 (data-type-name (gensymbol "DATA-TYPE-NAME-"))
	 (result-list (gensymbol "RESULT-LIST-"))
	 (count (gensymbol "COUNT-"))
	 (old-state :required)
	 (new-arglist)
	 (required)
	 (optional-tests)
	 (optional-vals)
	 (rest (gensymbol "REAL-REST-"))
	 (rest-p)
	 (key-tests)
	 (key-vals)
	 (flags)
	 (flags2 flags)
	 (flag)
	 (flags-used))
    (labels ((make-push (v)
	       (if (member v presentation-type-arguments)
		   `(progn (incf ,count)
			   (%push ,v))
		 `(progn (incf ,count)
			 (%push (if (atom ,v)
				    ,v
				  (%make-pointer dtp-locative ,v)))
			 (when (locally (declare (notinline consed-in-control-stack))
					;; If inline, introduces a 1let0 variable, which
					;; will be in the wrong spot because of the
					;; %PUSH's we've done.
					(consed-in-control-stack ,v))
			   (setq ,do-not-cache t)))))
	     (map-data-arglist (arg state)
	       ;; Damfino why 1lt:map-over-lambda-list0 is stupid
	       (setq arg (car arg))
	       (ecase state
		 (:required
		   (ecase old-state
		     (:required))
		   (push arg required))
		 (:optional
		   (ecase old-state
		     (:required
		       (setq old-state state)
		       (push '&optional new-arglist))
		     (:optional))
		   (push (cond ((atom arg) arg)
			       ((null (lt::arg-default arg))
				(lt::arg-name arg))
			       ((lt::key-supplied-p-arg-name arg)
				(lt::key-supplied-p-arg-name arg))
			       ((not (constantp (lt::arg-default arg)))
				(let ((supplied-p (gensymbol
						    (string-append (lt::arg-name arg)
								   "-SUPPLIED-P-"))))
				  (setq arg `(,(lt::arg-name arg) ,(lt::arg-default arg)
					      ,supplied-p))
				  supplied-p))
			       (t `(not (eql ,(lt::arg-name arg) ,(lt::arg-default arg)))))
			 optional-tests)
		   (push (lt::arg-name arg) optional-vals))
		 (:rest
		   (ecase old-state
		     ((:required :optional)
		      (setq old-state state)
		      (push '&rest new-arglist)))
		   (setq rest arg
			 rest-p t))
		 (:key 
		   (ecase old-state
		     ((:key))
		     ((:required :optional)
		      (setq old-state state)
		      (push '&rest new-arglist)	;Fast-forward past the 1:rest0 state.
		      (push rest new-arglist)	;..
		      (push '&key new-arglist))	;And on to 1:key0.
		     (:rest
		       (push '&key new-arglist)))
		   
		   (push (cond ((atom arg) arg)
			       ((lt::key-supplied-p-arg-name arg)
				(lt::key-supplied-p-arg-name arg))
			       ((null (lt::arg-default arg)) (lt::key-arg-name arg))
			       ((not (constantp (lt::arg-default arg)))
				(let ((supplied-p
					(gensymbol (string-append (lt::key-arg-name arg)
								  "SUPPLIED-P-"))))
				  (setq arg `(,(lt::arg-name arg) ,(lt::arg-default arg)
					      ,supplied-p))
				  supplied-p))
			       (t `(not (eql ,(lt::key-arg-name arg)
					     ,(lt::arg-default arg)))))
			 key-tests)
		   (push (lt::key-arg-name arg) key-vals)))
	       (push arg new-arglist)))
      (multiple-value-bind (nil allow-other-keys)
	  (lt:map-over-lambda-list data-arglist #'map-data-arglist)
	(setq new-arglist (nreverse new-arglist)
	      required (nreverse required)
	      optional-tests (nreverse optional-tests)
	      optional-vals (nreverse optional-vals)
	      key-tests (nreverse key-tests)
	      key-vals (nreverse key-vals)
	      flags (loop repeat (ceiling (+ (length optional-tests) (length key-tests)) 32)
			  collect (gensymbol "FLAG-"))
	      flags2 flags)
	(let ((body
		`((let ((,result-list)
			(,count 0)
			,@(loop for flag in flags
				collect `(,flag 0)))
		    (%push ,data-type-name)
		    ,@(loop for v in required
			    collect (make-push v))
		    ,@(loop for test in optional-tests
			    for i from 0
			    when (zerop (mod i 32))
			      do (setq i 0
				       flag (pop flags2))
				 (push flag flags-used)
			    collect `(when ,test
				       (setf ,flag
					     (logior ,(lsh 1 i) ,flag))))
		    ,@(unless (and rest-p (not (string-equal rest "IGNORE")))
			(loop for test in key-tests
			      for i from (length optional-tests)
			      when (zerop (mod i 32))
				do (setq i 0
					 flag (pop flags2))
				   (push flag flags-used)
			      collect `(when ,test
					 (setf ,flag
					       (logior ,(lsh i 1) ,flag)))))
		    ,@(when (unless (and rest-p (not (string-equal rest "IGNORE")))
			      key-tests)
			(setq flags-used (nreverse flags-used))
			(loop for flag in flags-used
			      collect `(incf ,count)
			      collect `(%push ,flag)))
	    
		    ,@(loop for val in optional-vals
			    for test in optional-tests
			    collect `(when ,test
				       ,(make-push val)))
		    
		    ,@(if (and rest-p (not (string-equal rest "IGNORE")))
			  `((incf ,count)
			    (%push ,rest)
			    (setq ,result-list (%finish-stack-list* ,count))
			    (funcall ,continuation ,result-list ,do-not-cache))
			(append
			  (loop for val in key-vals
				for test in key-tests
				collect `(when ,test
					   ,(make-push val)))
			  (when allow-other-keys
			    `(&allow-other-keys))
			  `((setq ,result-list (%finish-stack-list ,count))
			    (funcall ,continuation ,result-list ,do-not-cache))))))))
	  (setq body
		(wrap-presentation-type-arguments-full-cache-key self body do-not-cache
								 required optional-vals
								 rest rest-p key-vals))
	  `(,full-cache-key-function (,continuation ,data-type-name
				      ,@new-arglist ,@(when allow-other-keys
							'(&allow-other-keys)))
	    (declare (sys:downward-function)
		     (dbg:invisible-frame :presentation-handler-search))
	    ,@body))))))


(defmethod (wrap-presentation-type-arguments-full-cache-key presentation-type-definition)
	   (body do-not-cache required optional-vals rest rest-p key-vals)
  (let ((losers)
	(winners))
    (when (and rest-p (not (string-equal rest "IGNORE"))
	       (setq losers (intersection presentation-type-arguments key-vals)))
      (warn "~S cannot be used together with ~S~@
	     refering to keyword arguments. ~S cannot write~@
	     correct code for the full cache key.~@
	     Type methods (printers, parsers, etc.) may receive the wrong values
	     for the following type argument~P:  ~{~S~^, ~}"
	    '&rest :presentation-type-arguments 'define-presentation-type
	    (length losers) losers))
    ;; Winners are the ones we can reasonably get our hands on and order to suit.
    (setq winners (set-difference presentation-type-arguments losers))
    (labels ((wrap (var)
	       (setq body
		     (cond ((eql var rest)
			    (if (member var presentation-type-arguments)
				`((flet ((with-rest-presentation-arguments-body
					    (,var ,do-not-cache)
					   (declare (sys:downward-function)
						    (dbg:invisible-frame
						      :presentation-handler-search))
					   ,@body))
				    (with-rest-presentation-arguments
				      #'with-rest-presentation-arguments-body
				      ,var ,do-not-cache)))
			      `((flet ((call-with-one-level-key-body (,var ,do-not-cache)
					 (declare (sys:downward-function)
						  (dbg:invisible-frame
						    :presentation-handler-search))
					 ,@body))
				  (call-with-one-level-key-cache #'call-with-one-level-key-body
								 ,var ,do-not-cache)))))
			   ((member var winners)
			    `((with-full-key-for-cache (,var ,do-not-cache ,var
							:do-not-cache ,do-not-cache)
				,@body)))
			   ((member var losers)
			    `((let ((,var '|Unable to put into key.|))
				;; If this makes it into the key, something is *very*
				;; wrong here!  We just warned the user it wouldn't make
				;; it!
				,@body)))
			   (t body))))
	     (wrap-list (varlist)
	       (loop for var in (reverse varlist)	;From inside out.
		     do
		 (wrap var))))
      ;; from the inside out.
      (wrap-list key-vals)
      (unless (or (not rest-p) (string-equal rest "IGNORE"))
	(wrap rest))
      (wrap-list optional-vals)
      (wrap-list required)
      body)))

(defmethod (hack-typep presentation-type-definition) ()
  (when typep
    (destructuring-bind ((object-var) &body body) typep
      (output `(defun (presentation-function ,type-name typep-function)
		      (,object-var ,@data-arglist)
		 ,@body)))))

(defmethod (hack-flags presentation-type-definition) ()
  (when disallow-atomic-type
    (create-args :disallow-atomic-type t))
  (when (or disallow-atomic-type typep)
    (create-args :explicit-type-function (or disallow-atomic-type (not (null typep)))))
  (when (and (variable-boundp history) history)
    (create-args :input-history-type `',history))
  (when description
    (create-args :type-pretty-name `',description))
  (when history-form
    (create-args :presentation-type-history history-form))
  (when presentation-type-arguments
    (create-args :presentation-type-arguments `',presentation-type-arguments))
  (create-args :arglist `',arglist)
  ;; This must come after the type is defined, since it depends on
  ;; the PRESENTATION-TYPE-PRINTER
  (when history-form
    (output `(setup-history-name-from-type (presentation-type-history ',type-name)))))

(defmacro define-presentation-type (type-name arglist &rest args)
  (declare (zwei:indentation 0 4 1 5 2 2)
	   (arglist . (type-name (data-arglist . pr-arglist)
				 &key
				 parser printer viewspec-choices
				 description describer no-deftype disallow-atomic-type
				 (history nil history-supplied-p)
				 expander abbreviation-for
				 choose-displayer accept-values-displayer menu-displayer
				 default-preprocessor history-postprocessor
				 highlighting-box-function
				 presentation-type-arguments
				 presentation-subtypep key-generator key-function
				 do-compiler-warnings
				 map-over-subtypes map-over-supertypes
				 map-over-supertypes-and-subtypes
				 typep with-cache-key
				 data-arguments-are-disjoint)))
  (let* ((compiler:default-warning-function type-name)
	 (compiler:default-warning-definition-type 'define-presentation-type)
	 (definition (condition-case (.error.)
			  (apply #'make-instance 'presentation-type-definition
				 :type-name type-name
				 :arglist arglist
				 args)
			(flavor:invalid-initialization-keyword
			  (if (not (eql (send .error. :flavor-name)
					'presentation-type-definition))
			      (error "~A" .error.)
			    (error "~S is not a legal keyword for ~@\\PRESENTATION\\."
				   (first (send .error. :keywords))
				   'define-presentation-type 'function-name))))))
    (define-presentation-type-phase-1 definition)
    (define-presentation-type-phase-2 definition)
    (define-presentation-type-phase-3 definition)
    (compiler:file-declare type-name 'define-presentation-type t)
    (compiler:file-declare type-name 'presentation-type-arglist arglist)
    `(zl:local-declare ((presentation-type-arglist ,type-name ,arglist))
       ;; We use LOCAL-DECLARE to let expansions know during macroexpansion of this
       ;; macro.  COMPILER:FILE-DECLARE doesn't happen then, even if we call it
       ;; during expansion.  But we have to do COMPILER:FILE-DECLARE, too, for
       ;; compiling the file.
       ;; Make sure the presentation-type-descriptor exists before going into
       ;; the multiple-definition, so that any fdefinition-location references
       ;; by presentation-functions to other presentation-functions will work.
       (ensure-presentation-type-descriptor-exists ',type-name)
       (multiple-definition ,type-name define-presentation-type
	 . ,(nreverse (presentation-type-definition-reversed-output definition))))))


(defun interpret-history-spec-arg (arg typename)
  (declare (values property function form))
  (cond ((eq arg t)
	 (values nil nil `(define-presentation-type-history-1 ',typename)))
	;; :HISTORY NIL needs to be distinguished from no mention of :HISTORY.
	;; Since this is a property, we can't simply use NIL.
	((null arg)
	 (values :none nil nil))
	((keywordp arg)
	 (values arg nil nil))
	((symbolp arg)
	 (values `(:use ,arg)))
	((nlistp arg)
	 (error "Unknown history type arg: ~S" arg))
	((keywordp (car arg))
	 (values arg nil nil))

	((and (car arg) (symbolp (car arg)))
	 (error "Unknown history type arg: ~S" arg))
	(t
	 (values nil arg nil))))

(defun def-pres-type-parse-args (arglist)
  (let (required key aux optional)
    (let ((ptr (locf required)))
      (dolist (arg arglist)
	(case arg
	  (&optional (setq ptr (locf optional)))
	  (&key (setq ptr (locf key)))
	  (&rest (error "&REST not meaningful in presentation type function arglist"))
	  (&aux (setq ptr (locf aux)))
	  (otherwise (rplaca ptr (cons arg (car ptr)))))))
    (values (nreverse required)
	    (nreverse optional)
	    (nreverse key)
	    (nreverse aux))))

(defparameter *def-pres-type-debug-info-args*
	      '(plural-count))

(defprop plural-count t si:debug-info)

(defun def-pres-type-fngenerate (type-name definition type-arglist property)
  (with-stack-list (errname 'define-presentation-type
			    type-name
			    (intern (symbol-name property)
				    zl:pkg-keyword-package))
    (destructuring-bind (arglist . body) definition
      (unless (listp arglist)
	(error "Missing or bad argument list in ~S" errname))
      (unless body
	(error "Missing body or bad syntax in ~S" errname))
      (let ((template (cadr (assoc property *presentation-function-arglists*))))
	(multiple-value-bind (trequired nil tkey)
	    (cli::tkm-parse-arglist template)
	  (multiple-value-bind (required nil key aux)
	      (def-pres-type-parse-args arglist)
	    (flet ((str=memq (item list)
		     (car (member item list :test #'string-equal))))
	      (let ((reverse-arglist nil)
		    (copy-keys (copy-list key))
		    (type-var)
		    tem)
		(loop for argdesc in trequired
		      unless required
			do (error "Missing required arg ~S to ~S" argdesc errname)
		      do (push (pop required) reverse-arglist))
		(when required
		  (error "Extra arg ~S to ~S" (car required) errname))
		(loop for argdesc in tkey
		      do (cond ;; Ordinary key arg, convert to required.
			       ((setq tem (str=memq argdesc copy-keys))
				(setq copy-keys (delete tem copy-keys))
				(when (string= tem :type)
				  (setq type-var tem))
				(push tem reverse-arglist))
			       ((and type-arglist
				     (or (car type-arglist) (cdr type-arglist))
				     (string= argdesc :type))
				(setq type-var (make-symbol "TYPE"))
				(push type-var reverse-arglist))
			       (t (push 'ignore reverse-arglist))))
		(when copy-keys
		  (error "Unknown keyword arg to ~S: :~A" errname (car copy-keys)))
		
		(multiple-value-bind (decls code)
		    (si:find-body-declarations body nil arglist)
		  (unless code
		    (error "No code in ~S?" errname))
		  
		  ;; Allow sys to figure out if handles.
		  (loop for arg in key
			do (loop for s in *def-pres-type-debug-info-args*
				 when (string-equal arg s)
				   do (push `(,s) decls)))
		  
		  (when aux
		    (setq code `((let* (,@aux)
				   . ,code))))
		  
		  (when (and type-arglist type-var)
		    (push '(compiler:do-not-record-these-macros
			     with-presentation-type-arguments)
			  decls)
		    (setq code `((with-presentation-type-arguments (,type-name ,type-var)
				   . ,code))))
		  
		  (loop with rargs = reverse-arglist
			while (eq (car rargs) 'ignore)
			do (pop rargs)
			count t into c
			finally (when (> c 0)
				  (setq reverse-arglist `(ignore &rest . ,rargs))))
		  
		  `(defun (presentation-function ,type-name ,property)
			  ,(nreverse reverse-arglist)
		     ,@ (when decls
			  `((declare ,@ decls)))
		     ,@ (when (member property
				      '(map-over-subtypes map-over-supertypes))
			  '((declare (dbg:invisible-frame :presentation-handler-search))))
			  
			  ,@code))))))))))

(compile-flavor-methods presentation-type-definition)

