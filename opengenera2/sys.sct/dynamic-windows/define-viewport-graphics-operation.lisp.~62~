;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Graphics

(define-presentation-type graphics ()
      :expander 't)

(defflavor graphics-displayed-presentation
	((object nil)
	 (type 'graphics)
	 operation
	 arguments
	 priority
	 )
	(displayed-presentation)
  (:init-keywords :window)
  :initable-instance-variables
  :readable-instance-variables
  (:writable-instance-variables priority))

(defmethod (make-instance graphics-displayed-presentation :after) (&key window
								   &allow-other-keys)
  (multiple-value-bind (left top right bottom)
      (apply #'graphics-displayed-presentation-box-edges self window arguments)
    (setq displayed-box (make-box left top right bottom))))

(defmethod (presentation-anonymous-p graphics-displayed-presentation) () t)

(defmethod (redraw-displayed-presentation graphics-displayed-presentation) (window box)
  ;; This requires cooperation of the primitives
  (ignore box)
  (if (keywordp operation)
      (lexpr-send window operation arguments)
      (apply operation window arguments)))

(defmethod (:delete-graphics-displayed-presentation dynamic-window) (graphics)
  (let ((at-index (delete-from-coordinate-sorted-set graphics displayed-graphics)))
    (when at-index
      (let ((new-length (fill-pointer displayed-graphics)))
	(minf viewport-displayed-graphics-start-index new-length)
	(when viewport-displayed-graphics-end-index
	  (minf viewport-displayed-graphics-end-index new-length))
	(note-end-of-viewport-clobbered (= at-index new-length))))))

(defmethod (erase-graphics-displayed-presentation graphics-displayed-presentation)
	   (window recursive)
  (send window :delete-graphics-displayed-presentation self)
  (when (and superior (not recursive))
    ;; Delete from superior's list of inferiors.
    (send window :delete-displayed-presentation self)))

;;; Refuse to do this.  We should be moved properly by box shifting.
;;; Cf. note on :note-box-shift.
(defmethod (presentation-set-displayed-box graphics-displayed-presentation) (&rest ignore) )

(defmethod (presentation-mouse-sensitive-boxes graphics-displayed-presentation)
	   (window &optional ignore)
  (if highlighting-boxes
      (highlighting-boxes-mouse-sensitive-boxes highlighting-boxes displayed-box window)
      (displayed-box-mouse-sensitive-boxes displayed-box window)))

(defflavor refined-box-graphics-displayed-presentation () (graphics-displayed-presentation)
  (:required-methods refined-mouse-sensitive-boxes)
  :abstract-flavor)

(defmethod (make-instance refined-box-graphics-displayed-presentation :after)
	   (&rest ignore)
  (unless (displayed-presentation-single-box self)
    (setq highlighting-boxes (refined-mouse-sensitive-boxes self))))

(defmethod (presentation-adjust-for-box-move refined-box-graphics-displayed-presentation
					     :after)
	   (&rest ignore)
  (unless (displayed-presentation-single-box self)
    (setq highlighting-boxes (refined-mouse-sensitive-boxes self))))

(defmethod (graphics-displayed-presentation-priority displayed-presentation) ()
  (when inferiors
    (loop for presentation in inferiors
	  as priority = (graphics-displayed-presentation-priority presentation)
	  when (null priority)
	    return priority
	  minimize priority)))

(defmethod ((setf graphics-displayed-presentation-priority) displayed-presentation) (priority)
  (dolist (inferior inferiors)
    (setf (graphics-displayed-presentation-priority inferior) priority)))

(defmethod (graphics-displayed-presentation-reorder-priority displayed-presentation)
	   (starting-timestamp)
  (let ((lowest-now nil)
	(highest-now nil))
    (labels ((get-now (presentation)
	       (let ((inferiors (presentation-inferiors presentation)))
		 (if inferiors
		     (map () #'get-now inferiors)
		     (let ((priority (graphics-displayed-presentation-priority presentation)))
		       (when priority
			 (when (or (null lowest-now)
				   (< priority lowest-now))
			   (setq lowest-now priority))
			 (when (or (null highest-now)
				   (> priority highest-now))
			   (setq highest-now priority))))))))
      (get-now self))
    (when (and lowest-now highest-now)
      (labels ((reorder (presentation)
		 (let ((inferiors (presentation-inferiors presentation)))
		   (if inferiors
		       (map () #'reorder inferiors)
		       (let ((priority (graphics-displayed-presentation-priority 
					 presentation)))
			 (when priority
			   (setf (graphics-displayed-presentation-priority presentation)
				 (+ starting-timestamp 1 (- priority lowest-now)))))))))
	(reorder self))
      (incf starting-timestamp (1+ (- highest-now lowest-now)))))
  starting-timestamp)

(defmethod (:reorder-graphics-displayed-presentation-priority dynamic-window) (presentation)
  (without-interrupts
    (setq graphics-timestamp
	  (graphics-displayed-presentation-reorder-priority presentation
							    graphics-timestamp))))

(defmacro computing-outline-from-path ((&optional stream &rest args) &body body)
  (declare (arglist (&optional (stream *standard-output*) &key transform filled-allowed)
		    &body body))
  (format-output-macro-default-stream stream)
  `(computing-outline-from-path-internal
     (named-continuation computing-outline-from-path (,stream) . ,body)
     . ,args))

(defun computing-outline-from-path-internal (continuation &rest args)
  (using-resource (stream graphics::line-path-stream)
    (lexpr-send stream :initialize args)
    (funcall continuation stream)
    (flet ((convert-to-list (array)
	     (loop for index below (fill-pointer array) by 4
		   collect (list (aref array index)
				 (aref array (1+ index))
				 (aref array (+ index 2))
				 (aref array (+ index 3))))))
      (list :lines (convert-to-list (send stream :lines))
	    :solid-boxes (convert-to-list (send stream :rectangles))))))

(defmethod (refined-position-test refined-box-graphics-displayed-presentation) (&rest ignore)
  t)

(defmethod (position-inside-presentation refined-box-graphics-displayed-presentation) (x y)
  (and (box-contains-point-p displayed-box x y)
       (or (displayed-presentation-single-box self)
	   (refined-position-test self x y))))

(defmethod (presentation-at-position refined-box-graphics-displayed-presentation)
	   (ignore x y &rest ignore)
  (if (> y (box-bottom displayed-box))
      (values nil t)
      (when (position-inside-presentation self x y)
	self)))

(defmethod (:add-graphics-presentation dynamic-window) (constructor arguments)
  (let ((displayed-presentation
	  (let ((default-cons-area *presentation-area*)
		(superior current-output-displayed-presentation))
	    (funcall constructor (copy-if-necessary arguments) self 
		     (without-interrupts (incf graphics-timestamp))
		     (or (null superior) (displayed-presentation-single-box superior))
		     superior))))
    (send self :close-current-output-displayed-string)
    (add-to-coordinate-sorted-set displayed-presentation displayed-graphics)
    (setq displayed-graphics (follow-structure-forwarding displayed-graphics))
    (when current-output-displayed-presentation
      (displayed-presentation-add-inferior current-output-displayed-presentation
					   displayed-presentation t))
    (let ((box (presentation-displayed-box displayed-presentation)))
      (multiple-value-bind (right bottom)
	  (box-bottom-right box)
	(let ((new-max nil))
	  (when (> right maximum-x-position)
	    (setq maximum-x-position right new-max t))
	  (when (> bottom maximum-y-position)
	    (setq maximum-y-position bottom new-max t))
	  (when new-max
	    (send self :new-scroll-position)))))
    (send self :include-graphics-in-cursor-viewport)
    (when viewport-displayed-graphics-end-index
      (setq viewport-displayed-graphics-end-index nil))
    (when (and current-output-displayed-presentation
	       viewport-displayed-presentations-end-index)
      (setq viewport-displayed-presentations-end-index nil))))

(compile-flavor-methods refined-box-graphics-displayed-presentation)

(defprop define-viewport-graphics-operation "Graphics operation" si:definition-type-name)

(defmacro define-viewport-graphics-operation (operation lambda-list
                                              &key values values-to-convert
                                                   arguments-to-convert alu
                                                   (recording t) (window 'ignore)
                                                   box refined-box refined-position-test
						   merge-style)
  (let* ((presentation-flavor-name (when recording
				     (fintern "~A-GRAPHICS-DISPLAYED-PRESENTATION"
					      (let ((name (symbol-name operation)))
						(when (string-equal name "DRAW-" :end1 5)
						  (setq name (substring name 5)))
						name))))
	 (constructor-name (fintern "MAKE-~A" presentation-flavor-name))
	 (args (reduce-lambda-list-to-names lambda-list))
	 (rest-arg-p (member '&rest lambda-list))
	 (rest-arg-convert-p (or (member '&rest arguments-to-convert)
				 (member '&xs-and-ys arguments-to-convert))))
   (flet ((converter (type)
            (let ((spread-args arguments-to-convert))
	      (when rest-arg-convert-p 
		(setq spread-args (ldiff spread-args rest-arg-convert-p)))
              `(progn
		 ,(when spread-args
		    `(coordinate-convert-points self ,type :inside . ,spread-args))
		 ,(when rest-arg-convert-p
		    (ecase (first rest-arg-convert-p)
		      (&rest
			`(setq ,(second rest-arg-convert-p)
			       (coordinate-convert-point-sequence
				 self ,type :inside ,(second rest-arg-convert-p))))
		      (&xs-and-ys
			`(multiple-value-setq (,(second rest-arg-convert-p)
					       ,(third rest-arg-convert-p))
			   (coordinate-convert-xs-and-ys self ,type :inside
							 . ,(rest rest-arg-convert-p))))))
		 )))
          (pass-on (&optional (stream 'stream))
            (if (keywordp operation)
                `(,(if rest-arg-p 'lexpr-send 'send) ,stream ,operation . ,args)
                `(,(if rest-arg-p 'apply 'funcall) (flavor:generic ,operation)
                  (si:follow-syn-stream ,stream) . ,args))))
    `(zl:local-declare ((function-parent ,operation define-viewport-graphics-operation))
       (record-source-file-name ',operation 'define-viewport-graphics-operation)
       ,@(when recording `(
         (defflavor ,presentation-flavor-name
                 ((operation ,(if (keywordp operation)
                                  operation
                                  `(flavor:generic ,operation))))
                 (,(if (or refined-box refined-position-test)
                       'refined-box-graphics-displayed-presentation
                       'graphics-displayed-presentation))
	   (:constructor ,constructor-name (arguments window priority single-box superior)))
         (defmethod (graphics-displayed-presentation-box-edges ,presentation-flavor-name)
                    (,window . ,(reduce-lambda-list-to-names lambda-list 'arglist))
           (ignore . ,args)                     ;Probably don't need them all
           ,box)
         ,(when refined-box
            `(defmethod (refined-mouse-sensitive-boxes ,presentation-flavor-name) ()
               (destructuring-bind ,lambda-list arguments
                 (ignore . ,args)
                 ,refined-box)))
         ,(when refined-position-test
            `(defmethod (refined-position-test ,presentation-flavor-name)
                        ,(first refined-position-test)
               (destructuring-bind ,lambda-list arguments
                 (ignore . ,args)
                 . ,(rest refined-position-test))))
         ,(when alu
            `(defmethod (erase-displayed-presentation ,presentation-flavor-name)
                        (window &optional recursive &rest ignore)
               (unless (eq (send window :output-recording-enabled) :history-only)
                 (destructuring-bind ,lambda-list arguments
                   (setf ,alu (inverse-alu ,alu window))
                   (with-output-recording-disabled (window)
                     ,(pass-on 'window))))
               (erase-graphics-displayed-presentation self window recursive)))
         (defmethod (presentation-adjust-for-box-move ,presentation-flavor-name)
                    (delta-x delta-y)
           (destructuring-bind ,lambda-list arguments
             (ignore . ,args)
             ,@(loop for (x y) on (ldiff arguments-to-convert rest-arg-convert-p) by 'cddr
                     collect `(incf ,x delta-x)
                     collect `(incf ,y delta-y))
             ,(when rest-arg-convert-p
		(ecase (first rest-arg-convert-p)
		  (&rest
		    `(setq ,(second rest-arg-convert-p)
			   (translate-point-sequence ,(second rest-arg-convert-p)
						     delta-x delta-y)))
		  (&xs-and-ys
		    `(multiple-value-setq (,(second rest-arg-convert-p)
					   ,(third rest-arg-convert-p))
		       (translate-xs-and-ys delta-x delta-y . ,(rest rest-arg-convert-p))))))
	     (setq arguments ,(reduce-lambda-list-to-names lambda-list 'list))))
         (compile-flavor-methods ,presentation-flavor-name)
         (defwhopper (,operation dynamic-window) ,lambda-list
           ,(when merge-style
	      `(setf ,merge-style (if ,merge-style
				      (si:merge-character-styles ,merge-style
								 tv:merged-current-style)
				      tv:merged-current-style)))
	   (let ((draw-p t)
                 (record-p t))
             (ecase output-recording-enabled
               ((t) )
               ((:history-only) (setq draw-p nil))
               ((:clear-region nil) (setq record-p nil)))
             (when record-p
               (send self :add-graphics-presentation #',constructor-name
                     ,(reduce-lambda-list-to-names lambda-list 'list)))
             (when draw-p
	       (tv:prepare-sheet (self)		;Lock out viewport shifting
		 (,(if rest-arg-convert-p 'with-data-stack 'progn)
		  ,(converter :relative)
		  ,(let ((body `(with-viewport-margins ((if record-p
							    cursor-viewport
							    (or secondary-viewport
								cursor-viewport)))
				  (letf ((coordinate-transformation-enabled nil)
					 (output-recording-enabled nil))
				    (,(if rest-arg-p 'lexpr-continue-whopper 'continue-whopper)
				     . ,args)))))
		     (when values-to-convert
		       (setq body `(multiple-value-bind ,values
				       ,body
				     (coordinate-convert-points self :absolute :inside
								. ,values-to-convert)
				     (values . ,values))))
		     body))))))))
       ,(when (not recording)
          `(defwhopper (,operation dynamic-window) ,lambda-list
             (if (not coordinate-transformation-enabled)
                 (continue-whopper . ,args)
               ,(converter :relative)
               (with-viewport-margins ()
                 (continue-whopper . ,args)))))
       ;; It sucks that there are two implementations of essentially the same thing here.
       (defmethod (,operation new-coordinates-stream) ,lambda-list
         (,(if rest-arg-convert-p 'with-data-stack 'progn)
          ,(converter :absolute)
          ,(pass-on)))
       (defmethod (,operation pixel-width-stream) ,lambda-list
         (ignore . ,args)
         (multiple-value-bind (left top right bottom) (let ((,window self)) ,box)
	   (pixel-width-stream-graphics-box left top right bottom)))
       (defmethod (,operation redisplay-helper-stream) ,lambda-list
         (if (neq state :displaying)
             (multiple-value-bind (left top right bottom) (let ((,window self)) ,box)
               (redisplay-helper-stream-graphics-box left top right bottom))
             ,(pass-on)))
       (defmethod (,operation simulated-presentation-recording-stream) ,lambda-list
         (multiple-value-bind (gr-left gr-top gr-right gr-bottom)
             (let ((,window stream))
               ,box)
           (minf-or left gr-left)
           (minf-or top gr-top)
           (maxf-or right gr-right)
           (maxf-or bottom gr-bottom))
         ,(pass-on))
       (defmethod (,operation tv:basic-typeout-window :before) ,lambda-list
         (ignore . ,args)
         (multiple-value-bind (nil nil nil bottom)
             (let ((,window self))
               ,box)
           (tv:typeout-graphics-update bottom)))
       (defwhopper (,operation tv:roving-bitmap-mixin) ,lambda-list
         (when tv:adjust-p
           (multiple-value-bind (left top right bottom)
               (let ((,window self))
                 ,box)
             (send self :assure-room-for-output left top right bottom)))
         (,(if rest-arg-convert-p 'with-data-stack 'progn)
          ,(converter :relative)
          ,(let ((body `(letf ((tv:adjust-p nil))
                          (,(if rest-arg-p 'lexpr-continue-whopper 'continue-whopper)
                           . ,args))))
             (when values-to-convert
               (setq body `(multiple-value-bind ,values
                               ,body
                             (coordinate-convert-points self :absolute :inside
                                                        . ,values-to-convert)
                             (values . ,values))))
             body)))
       ))))

(eval-when (eval load compile)
(defun reduce-lambda-list-to-names (lambda-list &optional (into-format nil))
  (let ((list nil))
    (macrolet ((output (thing)
		 `(push ,thing list)))
      (let ((state nil))
	(dolist (thing lambda-list)
	  (cond ((eq thing '&rest)
		 (setq state '&rest))
		((eq thing '&key)
		 (setq state '&key))
		((eq thing '&aux)
		 (return))
		((member thing lambda-list-keywords))
		(t
		 (let ((symbol (if (listp thing) (first thing) thing)))
		   (cond ((eq state '&key)
			  (let (keyword)
			    (if (listp symbol)
				(setf `(,keyword ,symbol) symbol)
				(setq keyword (intern (symbol-name symbol) "")))
			    (output keyword)
			    (if (eq into-format 'list)
				(output `(copy-if-necessary ,symbol *presentation-area*))
				(output symbol))))
			 (t
			  (when (and (eq state '&rest)
				     (eq into-format 'arglist))
			    (output '&rest))
			  (if (eq into-format 'list)
			      (output `(copy-if-necessary ,symbol *presentation-area*))
			      (output symbol))))))))
	(setq list (nreverse list))
	(when (eq into-format 'list)
	  (push '*presentation-area* list)
	  (push (if (eq state '&rest) 'list*-in-area 'list-in-area) list))))
    list))
)

(defun inverse-alu (alu window)
  (cond ((or (eql alu tv:alu-xor) (eql alu color:alu-noop)
	     (eql alu :flip) (eql alu :noop))
	 alu)
	#||
	((or (null alu)
	     (eql alu (send window :char-aluf))
	     (eql alu :draw))
	 (send window :erase-aluf))
	((or (eql alu (send window :erase-aluf))
	     (eql alu :erase))
	 (send window :char-aluf))
	||#
	(t
	 (send window :erase-aluf))))

(defun coordinate-convert-point-sequence (window to-what where points)
  (let ((new-points (make-stack-array (length points) :type 'art-q-list)))
    (if (listp points)
	(loop for (x y) on points by 'cddr
	      for i from 0 by 2
	      do (coordinate-convert-points window to-what where x y)
		 (setf (aref new-points i) x
		       (aref new-points (1+ i)) y))
	(loop for i from 0 by 2 below (vector-length points)
	      do (let ((x (aref points i))
		       (y (aref points (1+ i))))
		   (coordinate-convert-points window to-what where x y)
		   (setf (aref new-points i) x
			 (aref new-points (1+ i)) y))))
    (g-l-p new-points)))

(defun coordinate-convert-xs-and-ys (window to-what where xs ys &optional end)
  (unless end
    (setq end (min (length xs) (length ys))))
  (let ((new-xs (make-stack-array end))
	(new-ys (make-stack-array end)))
    (dotimes (i end)
      (let ((x (aref xs i))
	    (y (aref ys i)))
	(coordinate-convert-points window to-what where x y)
	(setf (aref new-xs i) x)
	(setf (aref new-ys i) y)))
    (values new-xs new-ys)))
  
(defun point-sequence-box (points)
  (if (listp points)
      (loop for (x y) on points by 'cddr
	    minimize x into left
	    minimize y into top
	    maximize x into right
	    maximize y into bottom
	    finally (return (values left top right bottom)))
      (loop for i from 0 by 2 below (vector-length points)
	    as x = (aref points i)
	    as y = (aref points (1+ i))
	    minimize x into left
	    minimize y into top
	    maximize x into right
	    maximize y into bottom
	    finally (return (values left top right bottom)))))

(defun xs-and-ys-box (px py end)
  (loop for i below (or end (min (length px) (length py)))
	as x = (aref px i)
	and y = (aref py i)
	minimize x into left
	minimize y into top
	maximize x into right
	maximize y into bottom
	finally (return (values left top right bottom))))

(defun translate-point-sequence (points dx dy)
  (let ((new-points (make-stack-array (length points) :type 'art-q-list)))
    (if (listp points)
	(loop for (x y) on points by 'cddr
	      for i from 0 by 2
	      do (setf (aref new-points i) (+ x dx)
		       (aref new-points (1+ i)) (+ y dy)))
	(loop for i from 0 by 2 below (vector-length points)
	      do (let ((x (aref points i))
		       (y (aref points (1+ i))))
		   (setf (aref new-points i) (+ x dx)
			 (aref new-points (1+ i)) (+ y dy))  )))
    (g-l-p new-points)))

(defun translate-xs-and-ys (dx dy px py &optional end)
  (let* ((length (or end (min (length px) (length py))))
	 (new-x (make-stack-array length))
	 (new-y (make-stack-array length)))
    (loop for i below length
	  do (setf (aref new-x i) (+ (aref px i) dx))
	     (setf (aref new-y i) (+ (aref py i) dy)))
    (values new-x new-y)))

(define-viewport-graphics-operation :draw-point (x y &optional (alu :draw) (value -1))
  :arguments-to-convert (x y)
  :alu alu
  :box (values x y (1+ x) (1+ y)))

(define-viewport-graphics-operation :draw-rectangle (rect-width rect-height x y
						     &optional (alu :draw))
  :arguments-to-convert (x y)
  :alu alu
  :box (values x y (+ x (max 0 rect-width)) (+ y (max 0 rect-height))))

(define-viewport-graphics-operation :draw-char (char x y &optional (alu :draw) style)
  :arguments-to-convert (x y)
  :alu alu
  :merge-style style
  :window window
  :box (values x y (+ x (send window :character-width char))
		   (+ y (send window :line-height))))

(define-viewport-graphics-operation :draw-glyph (index font x y &optional (alu :draw))
  :arguments-to-convert (x y)
  :alu alu
  :box (values x y
	       (+ x (let ((cwt (zl:font-char-width-table font)))
		      (if cwt (aref cwt index)
			  (zl:font-char-width font))))
	       (+ y (zl:font-char-height font))))

(define-viewport-graphics-operation :draw-string (string from-x from-y
						  &optional (toward-x (1+ from-x))
							    (toward-y from-y)
							    (stretch-p nil)
							    style (alu :draw))
  :arguments-to-convert (from-x from-y toward-x toward-y)
  :alu alu
  :merge-style style
  :window window
  :box (multiple-value-bind (string-width char-width string-height line-height baseline)
	   (send window :draw-string-size string style)
	 (when (and (= from-x toward-x) (= from-y toward-y))
	   (setq toward-x (1+ from-x)))
	 (let ((left from-x)
	       (top (- from-y baseline))
	       (right (+ from-x char-width))
	       (bottom (+ from-y (- line-height baseline))))
	   (cond ((= from-x toward-x)
		  (if (> toward-y from-y)
		      (setq left from-x
			    right (+ left char-width))
		      (setq left (- left char-width)
			    right from-x)))
		 ((> toward-x from-x)
		  (setq right (if stretch-p
				  (max toward-x (+ left string-width))
				  (+ left string-width))))
		 (t
		  (setq left (if stretch-p
				 (min toward-x (- left string-width))
				 (- left string-width)))))
	   (let ((height (cond ((= from-y toward-y) line-height)
			       ((= from-x toward-x) string-height)
			       (t (floor (* string-width (abs (- toward-y from-y)))
					 (abs (- toward-x from-x)))))))
	     (if ( toward-y from-y)
		 (setq bottom (if stretch-p (max toward-y (+ top height)) (+ top height)))
		 (setq top (if stretch-p (min toward-y (- bottom height))
			       (- bottom height)))))
	   (values left top right bottom))))

(defun point-close-to-line-p (x y from-x from-y to-x to-y &optional (thickness 1))
  (let ((distance (1+ thickness))
	(dx (- to-x from-x))
	(dy (- to-y from-y)))
    (cond ((and (zerop dx) (zerop dy))
	   (and ( (abs (- x from-x)) distance)
		( (abs (- y from-y)) distance)))
	  ((> (abs dx) (abs dy))
	   (let ((correct-y (- to-y (floor (* (- to-x x) dy) dx))))
	     ( (abs (- y correct-y)) distance)))
	  (t
	   (let ((correct-x (- to-x (floor (* (- to-y y) dx) dy))))
	     ( (abs (- x correct-x)) distance))))))

(defun outline-line-with-hexagon (from-x from-y to-x to-y &optional (thickness 1))
  (let ((distance (1+ thickness)))
    (multiple-value-bind (x1 y1 x2 y2 x3 y3 x4 y4 x5 y5 x6 y6)
	(if (eq (minusp (- to-x from-x)) (minusp (- to-y from-y)))
	    (values (- from-x distance) (- from-y distance)
		    (- from-x distance) (+ from-y distance)
		    (- to-x distance) (+ to-y distance)
		    (+ to-x distance) (+ to-y distance)
		    (+ to-x distance) (- to-y distance)
		    (+ from-x distance) (- from-y distance))
	  (when (> to-y from-y)
	    ;; Make line go down to right.
	    (rotatef to-x from-x)
	    (rotatef to-y from-y))
	  (values (- from-x distance) (+ from-y distance)
		  (- from-x distance) (- from-y distance)
		  (- to-x distance) (- to-y distance)
		  (+ to-x distance) (- to-y distance)
		  (+ to-x distance) (+ to-y distance)
		  (+ from-x distance) (+ from-y distance)))
      `(:lines ((,x1 ,y1 ,x2 ,y2)
		(,x2 ,y2 ,x3 ,y3)
		(,x3 ,y3 ,x4 ,y4)
		(,x4 ,y4 ,x5 ,y5)
		(,x5 ,y5 ,x6 ,y6)
		(,x6 ,y6 ,x1 ,y1))))))

(define-viewport-graphics-operation :draw-line (from-x from-y to-x to-y
						&optional (alu :draw) (draw-end-point t))
  :arguments-to-convert (from-x from-y to-x to-y)
  :alu alu
  :box (values
	 (min from-x to-x)
	 (min from-y to-y)
	 (1+ (max from-x to-x))
	 (1+ (max from-y to-y)))
  :refined-position-test ((x y) (point-close-to-line-p x y from-x from-y to-x to-y))
  :refined-box (outline-line-with-hexagon from-x from-y to-x to-y))

(define-viewport-graphics-operation graphics::draw-scaled-line
				    (from-x from-y to-x to-y
				     &optional (alu :draw) (draw-end-point t))
  :arguments-to-convert (from-x from-y to-x to-y)
  :alu alu
  :box (values
	 (min from-x to-x)
	 (min from-y to-y)
	 (1+ (max from-x to-x))
	 (1+ (max from-y to-y)))
  :refined-position-test ((x y) (point-close-to-line-p x y from-x from-y to-x to-y))
  :refined-box (outline-line-with-hexagon from-x from-y to-x to-y))

(define-viewport-graphics-operation :draw-dashed-line (from-x from-y to-x to-y
						       &optional (alu :draw) dash-spacing
						       space-literally-p offset dash-length)
  :arguments-to-convert (from-x from-y to-x to-y)
  :alu alu
  :box (values
	 (min from-x to-x)
	 (min from-y to-y)
	 (1+ (max from-x to-x))
	 (1+ (max from-y to-y)))
  :refined-position-test ((x y) (point-close-to-line-p x y from-x from-y to-x to-y))
  :refined-box (outline-line-with-hexagon from-x from-y to-x to-y))

(defun point-inside-triangle-p (x y x1 y1 x2 y2 x3 y3)
  (graphics::some-point-inside-triangle-p x1 y1 x2 y2 x3 y3 x y))

;;; Attempt at something that looks moderately alright but doesn't take long to compute.
(defun outline-triangle-with-triangle (x1 y1 x2 y2 x3 y3)
  (let ((cx (floor (+ x1 x2 x3) 3))
	(cy (floor (+ y1 y2 y3) 3)))
    (flet ((one-step-beyond (x y)
	     (let ((dx (- x cx))
		   (dy (- y cy)))
	       (if (< (abs dx) (abs dy))
		   (values (round (+ x (* (signum dx) 2)))
			   (round (+ y (if (zerop dx) 2 (round (* dy 2) (abs dx))))))
		   (values (round (+ x (if (zerop dy) 2 (round (* dx 2) (abs dy)))))
			   (round (+ y (* (signum dy) 2))))))))
      (multiple-value-setq (x1 y1)
	(one-step-beyond x1 y1))
      (multiple-value-setq (x2 y2)
	(one-step-beyond x2 y2))
      (multiple-value-setq (x3 y3)
	(one-step-beyond x3 y3))))
  `(:lines ((,x1 ,y1 ,x2 ,y2)
	    (,x2 ,y2 ,x3 ,y3)
	    (,x3 ,y3 ,x1 ,y1))))

(define-viewport-graphics-operation :draw-triangle (x1 y1 x2 y2 x3 y3 &optional (alu :draw))
  :arguments-to-convert (x1 y1 x2 y2 x3 y3)
  :alu alu
  :box (values (min x1 x2 x3)
	       (min y1 y2 y3)
	       (1+ (max x1 x2 x3))
	       (1+ (max y1 y2 y3)))
  :refined-position-test ((x y) (point-inside-triangle-p x y x1 y1 x2 y2 x3 y3))
  :refined-box (outline-triangle-with-triangle x1 y1 x2 y2 x3 y3))

(define-viewport-graphics-operation :draw-fractional-triangle
				    (x1 y1 x2 y2 x3 y3 &optional (alu :draw))
  :arguments-to-convert (x1 y1 x2 y2 x3 y3)
  :alu alu
  :box (values (floor (min x1 x2 x3))
	       (floor (min y1 y2 y3))
	       (1+ (floor (max x1 x2 x3)))
	       (1+ (floor (max y1 y2 y3))))
  :refined-position-test ((x y) (point-inside-triangle-p x y x1 y1 x2 y2 x3 y3))
  :refined-box (outline-triangle-with-triangle x1 y1 x2 y2 x3 y3))

;;; The pattern-left/top give the position of the original triangle within the plane of
;;; the replicated stipple, and are preserved after translation to give the original offset.
;;; It doesn't matter which corner is chosen, since all drawing is further offset by the
;;; difference between pattern-xxx and x1,y1.
(define-viewport-graphics-operation :draw-patterned-triangle
				    (x1 y1 x2 y2 x3 y3
				     pattern &optional (alu :draw) (zeros-alu :erase)
						       (pattern-left x1) (pattern-top y1)
						       xmin ymin xmax ymax)
  :arguments-to-convert (x1 y1 x2 y2 x3 y3)
  :alu alu
  :box (values (floor (min x1 x2 x3))
	       (floor (min y1 y2 y3))
	       (1+ (floor (max x1 x2 x3)))
	       (1+ (floor (max y1 y2 y3))))
  :refined-position-test ((x y) (point-inside-triangle-p x y x1 y1 x2 y2 x3 y3))
  :refined-box (outline-triangle-with-triangle x1 y1 x2 y2 x3 y3))

(define-viewport-graphics-operation :draw-tiled-triangle
				    (x1 y1 x2 y2 x3 y3
				     pattern &optional (alu :draw)
						       (pattern-left x1) (pattern-top y1)
						       xmin ymin xmax ymax)
  :arguments-to-convert (x1 y1 x2 y2 x3 y3)
  :alu alu
  :box (values (floor (min x1 x2 x3))
	       (floor (min y1 y2 y3))
	       (1+ (floor (max x1 x2 x3)))
	       (1+ (floor (max y1 y2 y3))))
  :refined-position-test ((x y) (point-inside-triangle-p x y x1 y1 x2 y2 x3 y3))
  :refined-box (outline-triangle-with-triangle x1 y1 x2 y2 x3 y3))

(define-viewport-graphics-operation :draw-regular-polygon (x1 y1 x2 y2 n &optional (alu :draw))
  :arguments-to-convert (x1 y1 x2 y2)
  :alu alu
  :box (let ((theta (* pi (1- (/ 2.0 n))))
	     (n (abs n))
	     (min-x (min x1 x2))
	     (max-x (max x1 x2))
	     (min-y (min y1 y2))
	     (max-y (max y1 y2)))
	 (do ((i 2 (1+ i))
	      (sin-theta (sin theta))
	      (cos-theta (cos theta))
	      (x3) (y3))
	     (( i n))
	   (setq x3 (+ (- (- (* x1 cos-theta)
			     (* y1 sin-theta))
			  (* x2 (1- cos-theta)))
		       (* y2 sin-theta))
		 y3 (- (- (+ (* x1 sin-theta)
			     (* y1 cos-theta))
			  (* x2 sin-theta))
		       (* y2 (1- cos-theta))))
	   (minf min-x x3)
	   (maxf max-x x3)
	   (minf min-y y3)
	   (maxf max-y y3)
	   (setq x1 x2 y1 y2
		 x2 x3 y2 y3))
	 (values (round min-x)
		 (round min-y)
		 (round max-x)
		 (round max-y)))
  )

(define-viewport-graphics-operation graphics::draw-scaled-circle
				    (center-x center-y radius &optional (alu :draw) clockwise)
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x radius))
	 (floor (- center-y radius))
	 (ceiling (+ center-x radius 1))
	 (ceiling (+ center-y radius 1)))
  :refined-position-test ((x y)
			  (let ((dx (- x center-x))
				(dy (- y center-y)))
			    ( (abs (- (+ (expt dx 2) (expt dy 2))
				       (expt radius 2)))
			       (* 4 (+ (abs dx) (abs dy))))))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-circle stream center-x center-y (+ radius 2))
		 (when (> radius 2)
		   (graphics::draw-scaled-circle stream center-x center-y (- radius 2)))))

(define-viewport-graphics-operation graphics::draw-scaled-filled-in-circle
				    (center-x center-y radius &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x radius))
	 (floor (- center-y radius))
	 (ceiling (+ center-x radius))
	 (ceiling (+ center-y radius)))
  :refined-position-test ((x y)
			  ( (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
			     (expt radius 2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-circle stream center-x center-y (+ radius 2))))

(define-viewport-graphics-operation graphics::draw-scaled-ring
				    (center-x center-y minor-radius major-radius
				     &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x major-radius))
	 (floor (- center-y major-radius))
	 (ceiling (+ center-x major-radius))
	 (ceiling (+ center-y major-radius)))
  :refined-position-test ((x y)
			  ( (expt minor-radius 2)
			     (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
			     (expt major-radius 2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-circle stream center-x center-y (+ major-radius 2))
		 (when (> minor-radius 2)
		   (graphics::draw-scaled-circle stream center-x center-y
							(- minor-radius 2)))))

(defun point-between-angles-p (x y center-x center-y theta-1 theta-2)
  (unless (and (= x center-x) (= y center-y))
    (let ((theta-1 (mod theta-1 (* pi 2)))
	  (angle (mod (atan (- y center-y) (- x center-x)) (* pi 2)))
	  (theta-2 (mod theta-2 (* pi 2))))
      (when (< angle theta-1)
	(incf angle (* pi 2)))
      (when ( theta-2 theta-1)
	(incf theta-2 (* pi 2)))
      (< angle theta-2))))

(define-viewport-graphics-operation graphics::draw-scaled-filled-in-sector
				    (center-x center-y
				     radius theta-1 theta-2
				     &optional (alu :draw) pattern (zeros-alu :noop)
				     (pattern-left center-x) (pattern-top center-y))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (elliptical-arc-box center-x center-y radius radius theta-1 theta-2 t)
  :refined-position-test ((x y)
			  (and (< (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
				  (expt radius 2))
			       (point-between-angles-p x y center-x center-y
						       theta-1 theta-2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics:draw-circle center-x center-y radius
				       :start-angle theta-1 :end-angle theta-2
				       :filled nil :stream stream)
		 (graphics:with-graphics-translation (stream center-x center-y)
		   (graphics:draw-line 0 0 radius 0 :rotation theta-1 :stream stream)
		   (graphics:draw-line 0 0 radius 0 :rotation theta-2 :stream stream))))

(define-viewport-graphics-operation graphics::draw-scaled-sector-ring
				    (center-x center-y
				     radius-1 radius-2 theta-1 theta-2
				     &optional (alu :draw) pattern (zeros-alu :noop)
				     (pattern-left center-x) (pattern-top center-y))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (multiple-value-bind (left-1 top-1 right-1 bottom-1)
	   (elliptical-arc-box center-x center-y radius-1 radius-1 theta-1 theta-2 nil)
	 (multiple-value-bind (left-2 top-2 right-2 bottom-2)
	     (elliptical-arc-box center-x center-y radius-2 radius-2 theta-1 theta-2 nil)
	   (values (min left-1 left-2) (min top-1 top-2)
		   (max right-1 right-2) (max bottom-1 bottom-2))))
  :refined-position-test ((x y)
			  (and ( (expt (min radius-1 radius-2) 2)
				  (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
				  (expt (max radius-1 radius-2) 2))
			       (point-between-angles-p x y center-x center-y
						       theta-1 theta-2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics:draw-circle center-x center-y (max radius-1 radius-2)
				       :inner-radius (min radius-1 radius-2)
				       :start-angle theta-1 :end-angle theta-2
				       :filled nil :stream stream)
		 (graphics:with-graphics-translation (stream center-x center-y)
		   (graphics:draw-line (min radius-1 radius-2) 0
				       (max radius-1 radius-2) 0
				       :rotation theta-1 :stream stream)
		   (graphics:draw-line (min radius-1 radius-2) 0
				       (max radius-1 radius-2) 0
				       :rotation theta-2 :stream stream))))

(defun elliptical-arc-box (center-x center-y x-radius y-radius theta-1 theta-2 filled)
  (setq theta-1 (mod theta-1 graphics:2pi)
	theta-2 (mod theta-2 graphics:2pi))
  (let ((x1 (+ center-x (* x-radius (cos theta-1))))
	(y1 (+ center-y (* y-radius (sin theta-1))))
	(x2 (+ center-x (* x-radius (cos theta-2))))
	(y2 (+ center-y (* y-radius (sin theta-2)))))
    (let ((left (min x1 x2))
	  (top (min y1 y2))
	  (right (max x1 x2))
	  (bottom (max y1 y2)))
      (when (graphics:angle-between-angles-p pi theta-1 theta-2)
	(minf left (- center-x x-radius)))
      (when (graphics:angle-between-angles-p (* pi 3/2) theta-1 theta-2)
	(minf top (- center-y y-radius)))
      (when (graphics:angle-between-angles-p 0 theta-1 theta-2)
	(maxf right (+ center-x x-radius)))
      (when (graphics:angle-between-angles-p (/ pi 2) theta-1 theta-2)
	(maxf bottom (+ center-y y-radius)))
      (when filled
	(minf left center-x)
	(minf top center-y)
	(maxf right center-x)
	(maxf bottom center-y))
      (values (floor left) (floor top) (ceiling right) (ceiling bottom)))))

(define-viewport-graphics-operation graphics::draw-scaled-circular-arc
				    (center-x center-y
				     radius theta-1 theta-2
				     &optional (alu :draw) clockwise join-to-path)
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (elliptical-arc-box (+ center-x .5) (+ center-y .5) (+ radius .5) (+ radius .5)
			   theta-1 theta-2 nil)
  :refined-position-test ((x y)
			  (and (let ((dx (- x center-x))
				     (dy (- y center-y)))
				 ( (abs (- (+ (expt dx 2) (expt dy 2))
					    (expt radius 2)))
				    (* 4 (+ (abs dx) (abs dy)))))
			       (point-between-angles-p x y center-x center-y
						       theta-1 theta-2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics:draw-circle center-x center-y radius
				       :start-angle theta-1 :end-angle theta-2
				       :filled nil :stream stream)))

(defun point-inside-ellipse-p (x y center-x center-y x-radius y-radius)
  ( (+ (expt (* (- x center-x) y-radius) 2)
	(expt (* (- y center-y) x-radius) 2))
     (expt (* x-radius y-radius) 2)))

(define-viewport-graphics-operation graphics::draw-scaled-simple-ellipse
				    (center-x center-y x-radius y-radius
				     &optional (alu :draw) clockwise)
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x x-radius))
	 (floor (- center-y y-radius))
	 (ceiling (+ center-x x-radius 1))
	 (ceiling (+ center-y y-radius 1)))
  :refined-position-test ((x y)
			  (and (point-inside-ellipse-p x y center-x center-y
						       (+ x-radius 2) (+ y-radius 2))
			       (or ( x-radius 2) ( y-radius 2)
				   (not (point-inside-ellipse-p x y
								center-x center-y
								(- x-radius 2)
								(- y-radius 2))))))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-simple-ellipse stream
						       center-x center-y
						       (+ x-radius 2) (+ y-radius 2))
		 (when (and (> x-radius 2) (> y-radius 2))
		   (graphics::draw-scaled-simple-ellipse stream
							 center-x center-y
							 (- x-radius 2) (- y-radius 2)))))

(define-viewport-graphics-operation graphics::draw-scaled-filled-in-simple-ellipse
				    (center-x center-y x-radius y-radius &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x x-radius))
	 (floor (- center-y y-radius))
	 (ceiling (+ center-x x-radius))
	 (ceiling (+ center-y y-radius)))
  :refined-position-test ((x y)
			  ( (+ (expt (* (- x center-x) y-radius) 2)
				(expt (* (- y center-y) x-radius) 2))
			     (expt (* x-radius y-radius) 2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-simple-ellipse stream
						       center-x center-y
						       (+ x-radius 2) (+ y-radius 2))))

(defun point-inside-general-ellipse-p (x y center-x center-y x-radius y-radius
				       rotation shear-x)
  (multiple-value-bind (max-x nil max-y-x max-y)
      (graphics::ellipse-limits x-radius y-radius rotation shear-x)
    (let* ((x (- x (+ max-y-x (* (- y center-y max-y) (/ max-y-x max-y)))))
	   (p (expt (* max-x max-y) 2))
	   (q (+ (expt (* (- x center-x) max-y) 2)
		 (expt (* (- y center-y) max-x) 2))))
      ( q p))))

(define-viewport-graphics-operation graphics::draw-general-ellipse
				    (center-x center-y x-radius y-radius rotation shear-x
				     inner-x-radius inner-y-radius start-angle end-angle
				     clockwise join-to-path filled pattern
				     ones-alu zeros-alu pattern-left pattern-top)
  :arguments-to-convert (center-x center-y)
  :alu ones-alu
  :box (if (and (zerop rotation) (not (and (= start-angle 0) (= end-angle graphics:2pi))))
	   (elliptical-arc-box center-x center-y x-radius y-radius
			       start-angle end-angle filled)
	   (multiple-value-bind (max-x nil nil max-y)
	       (graphics::ellipse-limits x-radius y-radius rotation shear-x)
	     (values 
	       (floor (- center-x max-x))
	       (floor (- center-y max-y))
	       (ceiling (+ center-x max-x 1))
	       (ceiling (+ center-y max-y 1)))))
  :refined-position-test ((x y)
			  (and (if filled
				   (point-inside-general-ellipse-p x y
								   center-x center-y
								   x-radius y-radius
								   rotation shear-x)
				   (and (point-inside-general-ellipse-p x y
									center-x center-y
									(+ x-radius 2)
									(+ y-radius 2)
									rotation shear-x)
					(or ( x-radius 2) ( y-radius 2)
					    (point-inside-general-ellipse-p x y
									    center-x center-y
									    (- x-radius 2)
									    (- y-radius 2)
									    rotation
									    shear-x))))
			       (point-between-angles-p x y center-x center-y
						       start-angle end-angle)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics:draw-ellipse 0 0 (+ x-radius 2) (+ y-radius 2)
					:start-angle start-angle :end-angle end-angle
					:translation (list center-x center-y)
					:rotation rotation :filled nil :stream stream)
		 (when (and (not filled) (> x-radius 2) (> y-radius 2))
		   (graphics:draw-ellipse 0 0 (- x-radius 2) (- y-radius 2)
					:start-angle start-angle :end-angle end-angle
					:translation (list center-x center-y)
					:rotation rotation :filled nil :stream stream))))

(define-viewport-graphics-operation :draw-circle
				    (center-x center-y radius &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x radius))
	 (floor (- center-y radius))
	 (ceiling (+ center-x radius 1))
	 (ceiling (+ center-y radius 1)))
  :refined-position-test ((x y)
			  (let ((dx (- x center-x))
				(dy (- y center-y)))
			    ( (abs (- (+ (expt dx 2) (expt dy 2))
				       (expt radius 2)))
			       (* 4 (+ (abs dx) (abs dy))))))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-circle stream (+ center-x .5) (+ center-y .5)
					       (+ radius 2.5))
		 (when (> radius 3)
		   (graphics::draw-scaled-circle stream
						 (+ center-x .5) (+ center-y .5)
						 (- radius 2.5)))))

(define-viewport-graphics-operation :draw-filled-in-circle
				    (center-x center-y radius &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x radius))
	 (floor (- center-y radius))
	 (ceiling (+ center-x radius 1))
	 (ceiling (+ center-y radius 1)))
  :refined-position-test ((x y)
			  ( (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
			     (expt radius 2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-circle stream (+ center-x .5) (+ center-y .5)
					       (+ radius 2.5))))

(define-viewport-graphics-operation :draw-ring
				    (center-x center-y minor-radius major-radius
				     &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x major-radius))
	 (floor (- center-y major-radius))
	 (ceiling (+ center-x major-radius 1))
	 (ceiling (+ center-y major-radius 1)))
  :refined-position-test ((x y)
			  ( (expt minor-radius 2)
			     (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
			     (expt major-radius 2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-circle stream (+ center-x .5) (+ center-y .5)
					       (+ major-radius 2.5))
		 (when (> minor-radius 3)
		   (graphics::draw-scaled-circle stream (+ center-x .5) (+ center-y .5)
							(- minor-radius 2.5)))))

(define-viewport-graphics-operation :draw-filled-in-sector (center-x center-y
							    radius theta-1 theta-2
							    &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (elliptical-arc-box center-x center-y radius radius theta-1 theta-2 t)
  :refined-position-test ((x y)
			  (and (< (+ (expt (- x center-x) 2) (expt (- y center-y) 2))
				  (expt radius 2))
			       (point-between-angles-p x y center-x center-y
						       theta-1 theta-2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics:draw-circle (+ center-x .5) (+ center-y .5) (+ radius .5)
				       :start-angle theta-1 :end-angle theta-2
				       :filled nil :stream stream)
		 (graphics:with-graphics-translation (stream center-x center-y)
		   (graphics:draw-line 0 0 radius 0 :rotation theta-1 :stream stream)
		   (graphics:draw-line 0 0 radius 0 :rotation theta-2 :stream stream))))

(define-viewport-graphics-operation :draw-circular-arc (center-x center-y
						        radius theta-1 theta-2
							&optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (elliptical-arc-box center-x center-y radius radius theta-1 theta-2 nil)
  :refined-position-test ((x y)
			  (and (let ((dx (- x center-x))
				     (dy (- y center-y)))
				 ( (abs (- (+ (expt dx 2) (expt dy 2))
					    (expt radius 2)))
				    (* 4 (+ (abs dx) (abs dy)))))
			       (point-between-angles-p x y center-x center-y
						       theta-1 theta-2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics:draw-circle (+ center-x .5) (+ center-y .5) (+ radius .5)
				       :start-angle theta-1 :end-angle theta-2
				       :filled nil :stream stream)))

(define-viewport-graphics-operation :draw-simple-ellipse
				    (center-x center-y x-radius y-radius
				     &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x x-radius))
	 (floor (- center-y y-radius))
	 (ceiling (+ center-x x-radius 1))
	 (ceiling (+ center-y y-radius 1)))
  :refined-position-test ((x y)
			  (and (point-inside-ellipse-p x y center-x center-y
						       (+ x-radius 2) (+ y-radius 2))
			       (or ( x-radius 2) ( y-radius 2)
				   (not (point-inside-ellipse-p x y
								center-x center-y
								(- x-radius 2)
								(- y-radius 2))))))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-simple-ellipse stream
						       (+ center-x .5) (+ center-y .5)
						       (+ x-radius 2.5) (+ y-radius 2.5))
		 (when (and (> x-radius 3) (> y-radius 3))
		   (graphics::draw-scaled-simple-ellipse stream
							 (+ center-x .5) (+ center-y .5)
							 (- x-radius 2.5) (- y-radius 2.5)))))

(define-viewport-graphics-operation :draw-filled-in-simple-ellipse
				    (center-x center-y x-radius y-radius &optional (alu :draw))
  :arguments-to-convert (center-x center-y)
  :alu alu
  :box (values 
	 (floor (- center-x x-radius))
	 (floor (- center-y y-radius))
	 (ceiling (+ center-x x-radius 1))
	 (ceiling (+ center-y y-radius 1)))
  :refined-position-test ((x y)
			  ( (+ (expt (* (- x center-x) y-radius) 2)
				(expt (* (- y center-y) x-radius) 2))
			     (expt (* x-radius y-radius) 2)))
  :refined-box (computing-outline-from-path (stream)
		 (graphics::draw-scaled-simple-ellipse stream
						       (+ center-x .5) (+ center-y .5)
						       (+ x-radius 2.5) (+ y-radius 2.5))))

(define-viewport-graphics-operation :draw-wide-curve (px py curve-width
							 &optional end (alu :draw))
  :alu alu
  :arguments-to-convert (&xs-and-ys px py end)
  :box (xs-and-ys-box px py end))

;;; :bitblt does not record, it is just used for internal operations.
;;; :draw-1-bit-raster and :draw-patterned-rectangle take a 1-bit image and two alus.
;;; :draw-raster and :draw-tiled-rectangle take a n-bit image and one alu.
;;; :draw-1-bit-raster and :draw-raster assume the image is being drawn once.
;;; :draw-patterned-rectangle and :draw-tiled-rectangle assume it is being replicated
;;;   and so offset the pattern position too, thereby keeping in phase things drawn
;;;   in other viewports.
(define-viewport-graphics-operation :draw-1-bit-raster
				    (width height pattern pattern-left pattern-top left top
					   &optional (ones-alu :draw) (zeros-alu :erase))
  :arguments-to-convert (left top)
  :alu ones-alu
  :box (values left top (+ left width) (+ top height)))

(define-viewport-graphics-operation :draw-raster
				    (width height pattern left top
					   &optional (pattern-left 0) (pattern-top 0)
						     (alu tv:alu-seta))
  :arguments-to-convert (left top)
  :alu alu
  :box (values left top (+ left width) (+ top height)))

;;; The difference with this one is that the pattern is phase shifted
;;; too, since it is replicated, not imaged.
;;; For viewports, we want to keep the same position of from the original replicated
;;; plane wherever the rectangle gets drawn.  For encapsulating streams with coordinate
;;; offsets, you could make an argument either putting the corner of the stipple plane
;;; in either the corner of the subwindow, or the corner of the whole.  We opt for the
;;; former, since it's simpler to do here.
(define-viewport-graphics-operation :draw-patterned-rectangle
				    (width height left top pattern
				     &optional (ones-alu :draw) (zeros-alu :erase)
					       (pattern-left left) (pattern-top top))
  :arguments-to-convert (left top)
  :alu ones-alu
  :box (values left top (+ left width) (+ top height)))

;;; Here the image is the same depth, rather than per-pixel alu's.
(define-viewport-graphics-operation :draw-tiled-rectangle
				    (width height left top pattern
				     &optional (alu :draw)
					       (pattern-left left) (pattern-top top))
  :arguments-to-convert (left top)
  :alu alu
  :box (values left top (+ left width) (+ top height)))

(define-viewport-graphics-operation graphics::draw-simply-scaled-image
				    (image x y scale-x scale-y
				     pattern ones-alu zeros-alu opaque
				     image-left image-top image-right image-bottom)
  :arguments-to-convert (x y)
  :alu ones-alu
  :box (let ((left x) (top y)
	     (right (+ x (* (- image-right image-left) scale-x)))
	     (bottom (+ y (* (- image-bottom image-top) scale-y))))
	 (when (minusp scale-x)
	   (rotatef left right))
	 (when (minusp scale-y)
	   (rotatef top bottom))
	 (values left top right bottom)))

(define-viewport-graphics-operation :bitblt (alu width height
					     from-raster from-x from-y to-x to-y)
  :recording nil	;Use draw-pattern
  :arguments-to-convert (to-x to-y)
  :alu alu
  :box (values to-x to-y (+ to-x (abs width)) (+ to-y (abs height))))

(define-viewport-graphics-operation :bitblt-from-sheet (alu width height from-x from-y
							to-raster to-x to-y)
  :recording nil
  :arguments-to-convert (from-x from-y)
  :alu alu
  :box (values 0 0 0 0)				;A read operation
  )

(define-viewport-graphics-operation :bitblt-within-sheet (alu width height
							  from-x from-y to-x to-y)
  :recording nil
  :arguments-to-convert (from-x from-y to-x to-y)
  :alu alu
  :box (values to-x to-y (+ to-x (abs width)) (+ to-y (abs height))))

(define-viewport-graphics-operation :bitblt-to-sheet (alu width height from-x from-y
						      to-sheet to-x to-y)
  :recording nil
  :arguments-to-convert (from-x from-y)
  :alu alu
  :box (values from-x from-y (+ from-x (abs width)) (+ from-y (abs height))))

(define-viewport-graphics-operation :bitblt-from-sheet-to-sheet (alu width height
								 from-sheet from-x from-y
								 to-x to-y)
  :recording nil
  :arguments-to-convert (to-x to-y)
  :alu alu
  :box (values to-x to-y (+ to-x (abs width)) (+ to-y (abs height))))

(define-viewport-graphics-operation graphics::screen-specific-two-point-graphics
				    (screen-type default-function screen-function
				     left top right bottom alu
				     bounding-box refined-position-test refined-box
				     &rest more-args)
  :arguments-to-convert (left top right bottom)
  :box (destructuring-bind (bleft btop bright bbottom)
	   bounding-box
	 (values (+ bleft left) (+ btop top)
		 (+ bright left) (+ bbottom top)))
  :refined-position-test ((x y)
			  (or (null refined-position-test)
			      (funcall refined-position-test x y left top right bottom)))
  :refined-box (and refined-box (funcall refined-box left top right bottom))
  :alu alu
  )

(define-viewport-graphics-operation graphics::screen-specific-n-point-graphics
				    (screen-type default-function screen-function
				     points alu
				     bounding-box refined-position-test refined-box
				     &rest more-args)
  :arguments-to-convert (&rest points)
  :box (let ((left (elt points 0))
	     (top (elt points 1)))
	 (destructuring-bind (bleft btop bright bbottom)
	     bounding-box
	   (values (+ bleft left) (+ btop top)
		   (+ bright left) (+ bbottom top))))
  :refined-position-test ((x y)
			  (or (null refined-position-test)
			      (funcall refined-position-test x y points)))
  :refined-box (and refined-box (funcall refined-box points))
  :alu alu
  )


;;; :display-lozenged-string can't be done with define-viewport-graphics-operation
;;; because the "sheet" operation uses the cursor rather than taking coordinate arguments.
;;; However, we still want to exploit the graphics-displayed-presentation mechanism.

(defflavor lozenged-string-displayed-presentation
	((operation :display-lozenged-string))
	(graphics-displayed-presentation)
  (:constructor make-lozenged-string-displayed-presentation
		(arguments window priority single-box superior)))

(defmethod (graphics-displayed-presentation-box-edges lozenged-string-displayed-presentation)
	   (window string x y w h)
  (ignore window string)
  (values x y (+ x w) (+ y h)))

(defmethod (presentation-adjust-for-box-move lozenged-string-displayed-presentation)
	   (delta-x delta-y)
  (incf (second arguments) delta-x)
  (incf (third arguments) delta-y))

(compile-flavor-methods lozenged-string-displayed-presentation)

;;; X,Y,W,H arguments are only used when called back for redisplay
(defmethod (:display-lozenged-string dynamic-window) (string &optional x y w h
						      &aux (set-cursorpos nil))
  (when (null x)
    (send self :close-current-output-displayed-string)
    (setq set-cursorpos t
	  x tv:cursor-x
	  y tv:cursor-y
	  w (tv:prepare-sheet (self)
	      (tv:sheet-lozenged-string-width string))
	  h 10)
    ;; This right-margin wrapping isn't very dynamic, but it's what "sheet" windows do
    (when (> (+ x w) (if (zerop (tv:sheet-right-margin-character-flag))
			 (tv:sheet-inside-right)
			 (- (tv:sheet-inside-right) tv:char-width)))
      (send self :end-of-line-exception)
      (setq x tv:cursor-x
	    y tv:cursor-y))
    (coordinate-convert-points self :absolute :outside x y)
    (setq y (+ y 1 (max (- tv:baseline 10) 0))))
  (let ((draw-p t)
	(record-p t))
    (ecase output-recording-enabled
      ((t) )
      ((:history-only) (setq draw-p nil))
      ((:clear-region nil) (setq record-p nil)))
    (when record-p
      (send self :add-graphics-presentation #'make-lozenged-string-displayed-presentation
					    (list string x y w h)))
    (when draw-p
      (tv:prepare-sheet (self)
	(coordinate-convert-points self :relative :outside x y)
	(setq x (tv:sheet-display-lozenged-string-internal string x y (tv:sheet-inside-right)
							   tv:char-aluf))
	(when set-cursorpos
	  (setq tv:cursor-x x))))))

(define-viewport-graphics-operation :draw-multiple-lines (lines &optional (alu :draw)
									  (draw-end-point t))
  :arguments-to-convert (&rest lines)
  :box (multiple-value-bind (left top right bottom)
	   (point-sequence-box lines)
	 (when draw-end-point
	   (incf right)
	   (incf bottom))
	 (values left top right bottom))
  :alu alu)

(define-viewport-graphics-operation :draw-multiple-rectangles (rects &optional (alu :draw))
  :arguments-to-convert (&rest rects)
  :box (point-sequence-box rects)
  :alu alu)
