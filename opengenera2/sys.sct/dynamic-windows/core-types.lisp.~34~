;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun write--or--sequence (sequence stream &optional (printer #'princ))
  (declare (downward-funarg printer)
	   (zwei:indentation 0 4 1 4 2 2))
  (format-textual-list sequence printer :conjunction "or" :stream stream))

(defun write--and--sequence (sequence stream &optional (printer #'princ))
  (declare (downward-funarg printer)
	   (zwei:indentation 0 4 1 4 2 2))
  (format-textual-list sequence printer :conjunction "and" :stream stream))


;;;; Viewspec stuff

(defun presentation-cvv-choices (presentation)
  (declare (values presentation-type cvv-choices))
  (let ((presentation-type (presentation-type presentation)))
    (with-type-method ((real-presentation-type function) presentation-type
		       #'presentation-type-viewspec-choices
		       :error-p nil)
      (when function
	(funcall function real-presentation-type presentation-type presentation)))))
      
(defun presentation-type-keyword-options-into-cvv (presentation-type options)
  (with-type-decoded (type-name data-args presentation-args)
		     presentation-type
    (multiple-value-bind (presentation-options cvv-choices)
	(loop for (keyword presentation-type default name) in options
	      collect keyword into p-options
	      collect (getf presentation-args keyword default) into p-options
	      collect (list (locf (car (last p-options)))
			    (or name (string-capitalize-words keyword))
			    presentation-type)
		into c-choices
	      finally (return (values p-options c-choices)))
      (values (cons (cons type-name data-args)
		    (nconc presentation-options
			   (loop for (ind val) on presentation-args by 'cddr
				 when (eq (getf presentation-options ind 'not-given)
					  'not-given)
				   collect ind and collect val)))
	      cvv-choices))))

;;;; Type specific definitions for obscure types.
;;; Things that use comprehensible techniques belong in standard-presentation-types.lisp.

(defun accept-expression-internal (parser stream type)
  ;; (READ) isn't going to read with our delimiters, so check for null first.
  (let ((pos (send stream :read-location)))
    (unless (true-null-parser stream nil)
      (error 'read-end-of-file :stream stream :correct-input t))
    (send stream :set-location pos))
  (multiple-value-prog1
    ;; Enter a cutoff context, so that blips go into the input buffer instead of replacing the
    ;; whole form.
    (with-presentation-input-context (type :stream stream :inherit nil) ()
	 (with-accept-activation-chars ('(#\End) :override t)
	   (let ((si:read-preserve-delimiters t))
	     (funcall parser stream)))
       )
    ;; Within the expression, we turned off some activation characters.
    ;; If they were also whitespace (such as return), they are in the
    ;; buffer, but not as activations.  Convert now to new context.
    (let ((terminator (peek-char-for-accept stream)))
      (when terminator
	(read-char-for-accept stream)
	(cond ((or (not (send stream :interactive))	;From a string.
		   (send stream :rescanning-p)		;Still more stuff after this.
		   (not (characterp terminator)))	;A blip of some sort.
	       (unread-char-for-accept terminator stream))	;Put back as character.
	      ((accept-activation-p terminator)		;Activation in the higher context.
	       (send stream :replace-input 1 "")	;Really exterminate it and reform.
	       (unread-char-for-accept `(:activation ,terminator nil) stream))
	      ((not (char-equal terminator #\space))	;Not activation in higher context
	       ;; Don't lose the character unless it's a space.  It's okay to lose
	       ;; spaces that aren't activation characters, as seen after top-level forms.
	       (unread-char-for-accept terminator stream)))))))

(defvar *readtable-for-expression* si:*initial-common-lisp-readtable*
  "Readtable to use with D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")sys:expression0.  Bind or set this if you
are extending Lisp syntax, but not if you are using your
readtable to implement a different syntax.")

(define-presentation-type expression (() &rest options)

  :no-deftype t
  :history t

  :parser ((stream &key type original-type)
	   (values
	     (let ((pkg *package*)
		   (sre si:*suppress-read-eval*))
	       (scl:with-standard-io-environment
		 (let* ((*package* pkg)
			(si:*suppress-read-eval* sre)
			(si:print-readably nil)
			(*read-base* (getf options :base *read-base*))
			(*readtable* *readtable-for-expression*)
			(object (accept-expression-internal #'sys:read-expression stream
							    original-type)))
		   (unless (ptypep object original-type)
		     (error 'object-parsed-not-of-type :object object
			    :type original-type))
		   object)))
	     'expression))

  :printer
    ((object stream &key acceptably original-type)
     (with-type-decoded (type-name) original-type
       ;; This 1member0 kludge below is slowly being replaced by having most subtypes of
       ;; 1sys:expression0 expand to 1((sys:expression) :escape nil)0.  --RWK
       (if (and (null acceptably) (not (member type-name '(expression form code-fragment))))
	   (with-standard-io-environment
	     (let ((si:print-readably acceptably)
		   (si:*print-sensitive* -1)
		   (*readtable* *readtable-for-expression*))
	       (apply #'write object :stream stream :escape nil
		      options)))
	 (when (and (eq acceptably :very)
		    (not (or (and (symbolp object)
				  (not (null (symbol-package object))))
			     (fixnump object)	;Gosper might want the EQ bignum
			     ;; Didn't include characters because might be non-standard.
			     (and (consp object)
				  (member (first object) '(quote function))
				  (consp (rest object))
				  (or (and (symbolp (second object))
					   (not (null (symbol-package (second object)))))
				      (fixnump (second object)))
				  (presentation-subtypep-cached original-type 'form)))))
	   (error 'print-not-readable :object object))
	 (let ((si:print-readably acceptably)
	       (si:*print-sensitive* -1)
	       (*readtable* *readtable-for-expression*))
	   (apply #'write object :stream stream options)))))

  :describer ((stream &key original-type)
	      (with-type-decoded (type-name) original-type
		(if (eq type-name 'expression)
		    (write-string "the representation of any Lisp object" stream)
		  (with-type-method ((parser-type ignore) original-type
				     #'presentation-type-find-parser)
		    (with-type-decoded (parser-type-name) parser-type
		       (when (eq parser-type-name 'expression)
			 (write-string "the Lisp representation of " stream))))
		  (let ((string (string-downcase type-name)))
		    (if (zerop (length string))
			(write-string "a ||" stream)	;Damned silly case.
		      (write-string (string-a-or-an string nil :downcase) stream)
		      (write-char #\Space stream)
		      (write-string string stream))))))

  :viewspec-choices ((&key type)
		     (presentation-type-keyword-options-into-cvv
		       type
		       (mapcar #'(lambda (thing)
				   (list (cli::write-keyword-keyword thing)
					 (cli::write-keyword-presentation-type thing)
					 (symbol-value
					   (cli::write-keyword-variable thing))))
			       cli::*write-keywords*)))
  )

(define-presentation-type gprint::expression-length-ellipsis ()
   :expander 'expression)

(define-presentation-type form
      (() &key (environment si:*read-form-environment* environment-p)
       (expression-reader nil)
       (expression-printer nil)
       (edit-trivial-errors-p si:*read-form-edit-trivial-errors-p*))
   :description "a Lisp expression to be evaluated"
   :expander `expression
   :parser ((stream &key original-type)
	    ;; read-form hacks package DWIM, etc. which is why FORM has a different
	    ;; parser than EXPRESSION
	    ;; --- perhaps they should be unified somehow, perhaps by always calling
	    ;; --- READ-FORM, but with :EDIT-TRIVIAL-ERRORS-P NIL for expressions.
	    (let ((si:*read-form-edit-trivial-errors-p* edit-trivial-errors-p))
	      (accept-expression-internal
		(labels ((default-reader (stream &rest args)
			   (declare (sys:downward-function))
			   (apply #'sys:read-form stream :presentation-type nil args)))
		  (let ((reader (or expression-reader #'default-reader)))
		    (if environment-p
			#'(lambda (stream)
			    (funcall reader stream :environment environment))
		      #'(lambda (stream)
			  (funcall reader stream)))))
		stream original-type))))

;;--- Someday this should be merged (how?) with DBG:EVALUATED-EXPRESSION
(define-presentation-type evaluated-form
      (() &key (environment si:*read-form-environment*)
	       (expression-reader nil)
	       (expression-printer nil)
	       (edit-trivial-errors-p si:*read-form-edit-trivial-errors-p*))
   :description "a Lisp expression to be evaluated"
   :parser ((stream &key type)
	    (let ((form (accept `((sys:form) :environment ,environment
				  :expression-reader ,expression-reader
				  :expression-printer ,expression-printer
				  :edit-trivial-errors-p ,edit-trivial-errors-p)
				:stream stream :prompt nil)))
	      (si:with-parse-ferror (error)
		(eval form environment))))
   :printer ((object stream)
	     ;;--- Should this pass original-type?  Does evaluated-form need to be
	     ;; added to the list of special type-names in EXPRESSION's :printer?
	     (present (if (and (atom object)
			       (or (not (symbolp object))
				   (compiler:self-evaluating-symbol-p object)))
			  object
			  `',object)
		      `((sys:form) :environment ,environment
				   :expression-reader ,expression-reader
				   :expression-printer ,expression-printer)
		      :stream stream)))

(define-presentation-type out-of-band-character ((&rest chars))
   :expander `character
   :parser ((stream &key original-type)
	    (let ((char (accept 'character :prompt nil :provide-default nil :stream stream
				:additional-activation-chars chars)))
	      (unless (member char chars :test #'char=)
		(error 'object-parsed-not-of-type :object char :type original-type))
	      (values char 'character)))
   :describer ((stream)
	       (flet ((tio (c s)
			(if (char= c #\Return)
			    (write-string "<return>" s)
			    (write-char c s))))
		 (write-string
		   (if (cdr chars)
		       "one of the characters "
		       "the character ")
		   stream)
		 (write--or--sequence chars stream #'tio))))


;;; This basically implements CONS without depending on the CL type system
;;; to do it.  We want to avoid inheriting directly from SEQUENCE above,
;;; which uses a different syntax, even if it is a supertype.
(define-presentation-type cons (() &rest options)
   :no-deftype t
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (with-type-decoded (nil nil pr-args) type
       (let ((predicate (when predicate-p
			  (merge-predicates #'consp predicate))))
	 (merge-meta-args 'list pr-args recurse function predicate))))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :description "a cons")

(define-presentation-type list (() &rest options)
   :no-deftype t
   ;; This printer and parser are so we present and accept 1list0's as 1expression0's,
   ;; not as 1sequence0's.  If you want 1sequence0 syntax, take them out.
   :parser ((stream &key default original-type)
	    (values (accept `(and ((expression) ,@options) (satisfies listp))
			    :stream stream
			    :prompt nil
			    :default default
			    :original-type original-type)))
   :printer ((object stream &key acceptably original-type)
	     (present object `((expression) ,@options)
		      :acceptably acceptably
		      :original-type original-type
		      :stream stream))
   :map-over-subtypes
   ((function predicate &key keys-seen predicate-p type)
    (let ((predicate (when predicate-p
		       (merge-predicates #'listp predicate))))
      (unless (or (already-seen-p '(or null cons) keys-seen)
		  (already-seen-p '(or cons null) keys-seen))
	(funcall function '(or null cons) '(or null cons) predicate))))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (with-type-decoded (nil nil pr-args) type
      (let ((predicate (when predicate-p
			 ;; Optimize out redundant predicate when we're from 1cons0.
			 (if (eql predicate #'consp)
			     predicate
			   (merge-predicates #'listp predicate)))))
	(merge-meta-args 'sequence pr-args recurse function predicate))))
   :description "a list")

(defun summarize-list-contents (list &optional (predicate #'equal))
  (loop with le
	for last = nil then element
	for element in list
	when (and le (funcall predicate last element))
	    do (incf (car le))
	else collect (setq le `(1 . ,element))))


(define-presentation-type null ()
   :no-deftype t
   :parser ((stream)
	    (true-null-parser stream))
   :printer "None"
   :map-over-supertypes
   ((function predicate &key recurse type predicate-p)
    (with-type-decoded (nil nil pr-args) type
       ;; No supertypes to speak of if subtype excluded 1null0.
       ;; This way we don't have to merge in his predicate.
       (when (or (not predicate-p)
		 (not predicate)
		 (funcall predicate nil))
	 ;; Use 1not0 below, because 1#'null0 => 1not0 (the symbol, not the function)
	 (let ((predicate (when predicate-p #'not)))
	   (merge-meta-args '(member nil) pr-args function '(member nil) predicate)
	   (merge-meta-args 'list pr-args recurse function predicate)
	   (merge-meta-args 'symbol pr-args recurse function predicate)))))

   :map-over-subtypes ((function predicate) (ignore function predicate))

   :description "a null value")

(defun true-null-parser (stream &optional (signal t))
  (let ((pt (send stream :read-location)))
    (loop for ch = (read-char-for-accept stream)
	  unless (member ch '(#\Space #\Tab))	;blipped spaces don't count.
	  do (unread-char-for-accept ch stream)
	     (send stream :set-location pt)
	     (if (or (null ch)
		     (and (consp ch)
			  (member (first ch) '(:activation :accept))))	;delimiter
		 (return (values nil 'null))
		 ;; Hahahahahaha  "" is a deterministic kludge
		 ;; for a nonhalting computation.
		 (if signal
		     (error 'input-not-of-required-type :type 'null :string "")
		     (return t))))))

(defun invert-predicate (predicate)
  (encache-predicate (predicate)
    (invert-predicate-internal predicate)))

(defun invert-predicate-internal (predicate)
  (labels ((inverted (object)
	     (declare (copyable-closure))
	     (not (funcall predicate object))))
    #'inverted))

(define-presentation-type not ((inverted-type))
   :no-deftype t
   :disallow-atomic-type t
   :presentation-type-arguments (inverted-type)
   :typep ((object) (not (ptypep object inverted-type)))
   :presentation-subtypep
   ((type1 type2)
    (with-presentation-type-arguments (not type1)
      (let ((t1 inverted-type))
	(with-presentation-type-arguments (not type2)
	  (let ((t2 inverted-type))
	    (presentation-subtypep-cached t2 t1))))))
   :describer ((stream)
	       (princ "not " stream)
	       (describe-presentation-type inverted-type stream))
   :map-over-supertypes-and-subtypes
   ((function predicate &key supertype-p for-lookup keys-seen predicate-p)
    (let ((original-predicate predicate)
	  (inverted-predicate (when predicate
				(invert-predicate predicate))))
      (with-type-decoded (nil nil pr-args) inverted-type
	(labels ((map-not (type key new-predicate)
		   (let ((predicate (if (eq new-predicate original-predicate)
					inverted-predicate
				      (when new-predicate
					(invert-predicate new-predicate)))))
		     (case (presentation-type-name type)
		       ((t) (merge-meta-args nil pr-args function nil predicate))
		       ((nil) (merge-meta-args t pr-args function t predicate))
		       ((not) (with-presentation-type-arguments (not type)
				(with-presentation-type-key (key inverted-type)
				  (unless (already-seen-p key keys-seen)
				    (merge-meta-args inverted-type pr-args
						     function key predicate)))))
		       (otherwise
			 (stack-let ((not-type `(not ,type))
				     (not-key `(not ,key)))
			   (unless (already-seen-p key keys-seen)
			     (merge-meta-args not-type pr-args
					      function not-key predicate))))))))
	  ;; (not for-lookup) because when we are mapping the type in the inverse
	  ;; direction, because it has to match against a search in the other direction
	  ;; which is running in the other sense.  Clear as a bell, eh?
	  (map-over-type-hierarchy inverted-type (not supertype-p) (not for-lookup) #'map-not
				   predicate predicate-p))))))

(define-presentation-type parse-error-wall ((type))
   :history (() (find-accept-history type))
   :presentation-type-arguments (type)
   :presentation-subtypep ((type1 type2)
			   (with-presentation-type-arguments (parse-error-wall type1)
			     (let ((type1-type type))
			       (with-presentation-type-arguments (parse-error-wall type2)
				 (let ((type2-type type))
				   (presentation-subtypep type1-type type2-type))))))
   :printer ((object stream &key acceptably)
	     (present object type :stream stream :acceptably acceptably))
   :parser ((stream &key initially-display-possibilities)
	    (let ((*accept-cut-flag* t))
	      (accept type :stream stream :prompt nil
			   :initially-display-possibilities initially-display-possibilities)))
   )

;;--- This should really be fixed at the level of the 1or0 parser
(define-presentation-translator object-to-parse-error-wall
   (t (parse-error-wall nil)
   :tester ((ignore &key presentation input-context)
	    (when (not (null input-context))
	      (stack-let ((type `(parse-error-wall
				   ,(presentation-type presentation)))
			  (object (presentation-object presentation)))
		(let ((desired-type (presentation-input-context-presentation-type
				      input-context)))
		  (presentation-type-applies-p type desired-type object))))))
   (object &key presentation)
  (values object `(parse-error-wall ,(presentation-type presentation))))

;;--- This should really be fixed at the level of the 1or0 parser
(define-presentation-translator object-to-parse-error-wall-sequence
   (t (parse-error-wall (sequence nil))
   :tester ((ignore &key presentation input-context)
	    (when (not (null input-context))
	      (stack-let ((type `(parse-error-wall
				   (sequence ,(presentation-type presentation))))
			  (object (list (presentation-object presentation))))
		(let ((desired-type (presentation-input-context-presentation-type
				      input-context)))
		  (presentation-type-applies-p type desired-type object)))))
   :priority 1.5)	;a little higher than its cousin above
   (object &key presentation)
  (values (list object) `(parse-error-wall (sequence ,(presentation-type presentation)))
	  :activate nil))
				   
;; OR has to call all its subtypes' parsers for possibilities when 
;; generating a help display.  [This could be separated out into a
;; separate 1:possibilities0 type method  --RWK]
;;--- The OR presentation-type is riddled with so many problems, that it
;;--- should be thrown out and reimplemented as a sort of meta-p-t
;; [Actually, that's not true.  You just shouldn't depend on it for
;;  parsers.  It can't decide for you how you want to avoid collisions
;;  of syntax, anyway.  --RWK]
(define-presentation-type or ((&rest types))
   :no-deftype t
   :disallow-atomic-type t
   :data-arguments-are-disjoint t
   :presentation-type-arguments (types)
   :history (()
	     (loop for type in types
		   thereis (find-accept-history type)))
		   
   :default-preprocessor ((default &key type original-type default-type)
			  (block default-preprocessor
			    (loop for otype in types
				  as default-object-type =
				     ;; If what we are looking for is a sequence of
				     ;; something, then we need to do be careful to
				     ;; claim that the object-type is a sequence, too.
				     (if (and (eq (presentation-type-name otype) 'sequence)
					      (consp default))
					 `(sequence ,(type-of (first default)))
				       (type-of default))
				  ;; If the user did not supply a default-type
				  ;; we should use the object type, which will
				  ;; be the most specific appropriate type we
				  ;; can construct.
				  as real-default-type =
				     (if (eq default-type original-type)
					 default-object-type
				       default-type)
				  doing
			      ;; Don't invoke the default-preprocessor unless
			      ;; there's a type match.  This screws
			      ;; 1(accept '((or ((sequence pathname)) printer)))
0			      ;; where the default is going to be gotten
			      ;; from the history, but no one is really going
			      ;; to do that anyway.
			      (when (t-to-t-identity-translate-p
				      real-default-type default-object-type otype
				      default)
				(return-from default-preprocessor
				  ;; We believe that we can pass 1otype0 instead of
				  ;; 1original-type0 because by now 1otype0 is the
				  ;; appropriate, more specific type
				  (invoke-default-preprocessor
				    default otype otype real-default-type))))))

   :describer ((stream &key plural-count)
	       (when (member 'null types)
		 (setq types (append (remove 'null types) '(null))))
	       (typecase plural-count
		 (null)
		 (integer (format stream "~R " plural-count))
		 (symbol)
		 (otherwise
		   (format stream "~A " plural-count)))

	       (write--or--sequence
		 types stream
		 (lambda (e s)
		   (describe-presentation-type e s (and plural-count t)))))

   :printer
   ((object stream &key acceptably for-context-type original-type type)
    ;; The printer for 1or0 has to match the object being printed against
    ;; the types specified in the 1or0 type.  However, if some caller has
    ;; claimed that "he knows better" (via 1:for-context-type0), we have
    ;; to check that first.
    (let ((printer-type
	    (block find-printer
	      (when for-context-type
		(loop for one-type in types doing
		  (multiple-value-bind (subtypep nil predicate)
		      (presentation-subtypep one-type for-context-type)
		    (when (and subtypep
			       (or (null predicate)
				   (funcall predicate object)))
		      (return-from find-printer one-type)))))
	      (loop for one-type in types doing
		(when (ptypep object one-type)
		  (return-from find-printer one-type))))))
      (if (null printer-type)
          ;; The user is really a loser in disguise.
	  (error "Trying to print the object ~S ~@
		  which doesn't match any of the types in ~@\\presentation\\"
		 object type 'presentation-type)
	;; We do this instead of 1present0 in order to avoid creating an inferior.
	;;--- It may actually be right to create that inferior!  --RWK
	(with-type-method ((real-printer-type printer)
			   printer-type #'presentation-type-find-printer)
	  (funcall printer object stream real-printer-type
			   printer-type acceptably original-type)))))

   :parser
   ((stream &key default type original-type initially-display-possibilities)
    (block or-parser
      ;; --- After the beta test:
      ;; Should separate out this flet & associated code into a macro.
      (labels ((uninteresting-type-p (type)
		 (with-type-decoded (type-name) type
		   (member type-name '(boolean alist-member member))))
	       (do-help (help-stream string-so-far)
		 (labels ((funny-stream (op &rest args)
			    ;; This stream is a "Funny Stream" that tries to throw whenever
			    ;; the parser body actually tries to interact with the user.
			    (select op
			      ((:any-tyi :tyi :noise-string-out)
			       (throw 'done-displaying-possibilities nil))
			      (:stuff-so-far string-so-far)
			      (:read-location 0)
			      (:set-location )
			      (:rescanning-p nil)
			      (otherwise (lexpr-send help-stream op args))))
			  (funcall-parser (type)
			    (catch 'done-displaying-possibilities
			      (with-type-method ((real-type parser)
						 type #'presentation-type-find-parser)
				;; 1type(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"),0 not 1original-type0.  1type0 is more specific
				;; than what we were given.
				(funcall parser #'funny-stream
						real-type type nil
						:then-return
						nil nil nil)))))
		   (loop for type in types
			 unless (uninteresting-type-p type)
			   do (funcall-parser type))
		   (loop for type in types
			 when (uninteresting-type-p type)
			   do (funcall-parser type)))))
	(with-accept-help
	    (((:subhelp :override)
	      #'do-help ))
	  ;; stream original-type p-type default i-d-p
	  (when (eq initially-display-possibilities ':then-return)
	    (do-help stream (send stream :stuff-so-far))
	    (throw 'done-displaying-possibilities nil))
	  (labels ((type-contains-NULL (types)
		     (loop for type in types
			   as type-name = (presentation-type-name type)
			   thereis (or (eq type-name 'null)
				       (and (eq type-name 'or)
					    (with-type-decoded (nil tdargs) type
					       (type-contains-NULL tdargs)))))))
	    (let ((read-loc (send stream :read-location)))
	      ;; Perhaps this special casery is brain-damage, and the
	      ;; user should be required to say '(or null pathname),
	      ;; meaning that '((or pathname null)) is useless.
	      (cond ((and (type-contains-NULL types)
			  (condition-case (error)
			       ;; The call to ACCEPT has already established
			       ;; the input-context for the full, hairy type.
			       (accept 'null :stream stream :prompt nil)
			     (input-not-of-required-type nil)
			     (:no-error t)))
		     (values nil 'null))
		    (t (flet ((presentation-subtypep-that-masks-bug-in-ptypep (object type)
				(multiple-value-bind (subtypep ignore predicate)
				    (presentation-subtypep (type-of object) type)
				  (if (or (null subtypep) (null predicate))
				      subtypep
				    (funcall predicate object)))))
			 (loop with errstr
			       with error-type
			       for otype in types
			       doing
			   (unless (eq otype 'null)	;just for optimization, see above
			     (block fail
			       (send stream :set-location read-loc)
			       (condition-bind
				 ;; This is the pits.  --SWM & Doughty
				 ((input-not-of-required-type
				    (lambda (error)
				      (setq errstr (send error :string)
					    error-type 'input-not-of-required-type)
				      (cond ((and (string-equal errstr "")
						  (neq errstr *complete-input-magic-null-string*))
					     ;; The null string is handled at
					     ;; a higher level (ACCEPT-2), which
					     ;; inserts the default instead
					     nil)
					    ((not *accept-cut-flag*)
					     (return-from fail nil)))
				      nil))
				  (sys:parse-error
				    (lambda (error)
				      ;; Don't handle 1input-not-of-required-type0 again,
				      ;; since we already did it above.  Sigh.
				      (unless (typep error 'input-not-of-required-type)
					(setq error-type 'parse-error
					      errstr error)
					(unless *accept-cut-flag*
					  (return-from fail nil)))
				      nil)))
				 (let ((provide-default
					 (and (presentation-subtypep-that-masks-bug-in-ptypep
						default
						otype)
					      ;; I think the above test is
					      ;; redundant with the one below.
					      (ptypep default otype))))
				   (multiple-value-bind (object type)
				       (accept otype
					       :stream stream
					       ;; Usually you want to do this in order
					       ;; to pass along the most specific
					       ;; possible type.  In the case of OR,
					       ;; the original type is 2less0 specific.
					       ; :original-type original-type
					       :default (when provide-default
							  default)
					       :provide-default provide-default
					       :prompt nil
					       :initially-display-possibilities
					       initially-display-possibilities)
				     (return (values object type)))))))
			       finally
				 (send stream :set-location read-loc)
				 (ecase error-type
				   (parse-error
				     (zl:parse-ferror "~A" errstr))
				   (input-not-of-required-type
				     (error 'input-not-of-required-type
					    :type original-type
					    :string errstr)))))))))))))

   :accept-values-displayer
   ((stream object query-identifier &key original-type provide-default)
    ;; Idea here is that if all types, or all but one, can be input by clicking on
    ;; displayed choices, we set up a row of choices.  If there is a type that has
    ;; to be read with ACCEPT, we put a field in the row of choices that shows the
    ;; value, if the object is of that type, and otherwise shows the name of the
    ;; type, in either case clicking there allows the value to be accepted.
    ;; Otherwise we give up and use the printer, as if this "method" was not here.
    (standard-accept-values-displayer (stream object query-identifier provide-default)
      (if (loop with types = types
		with n-accept = 0
		with n-choose = 0
		while types
		as type = (pop types)
		do (with-type-method ((ptype handler htype) type
				      #'presentation-type-displayer-for-accept-values)
		     (ignore handler)
		     (with-type-decoded (type-name more-types) ptype
			(cond ((eq type-name 'or)
			       ;; Expand nested or to find out what's really going on
			       (setq types (append more-types types)))
			      ((eq htype 'printer)
			       (incf n-accept))
			      (t (incf n-choose)))))
		finally (return (or (zerop n-choose) (> n-accept 1))))
	  ;; Can't use a row of choices
	  (values object original-type
		  (present-editable-choice object original-type nil t)
		  x y)
	  ;; Fancy row of choices case
	  (loop for (type . more) on types
		with last-presentation = nil with accept-presentation = nil
		finally (return (values object original-type
					(or accept-presentation last-presentation)
					x y)) do
	    (accept-values-dispatch (type)
	      ;; accept-values-displayer
	      (multiple-value-setq (nil nil last-presentation))
	      ;; choose-displayer, menu-displayer
	      (setq last-presentation)
	      ;; No special handler, prefer to return this one
	      (setq accept-presentation (present-editable-choice object type)))
	    (when more
	      (write-string "  " stream))))))

   :key-function ((function original-type-name)
		  (stack-let ((data-args `(,original-type-name ,@types)))
		    (call-with-presentation-type-keys function data-args)))

   :with-cache-key ((function original-type-name)
		    (stack-let ((data-args `(,original-type-name ,@types)))
		      (call-with-presentation-type-cache-keys function data-args)))

   ;; Can't get subtypep by looking at the 1or0, you have to keep mapping.
   :presentation-subtypep ((ignore ignore) (values nil nil))

   :map-over-subtypes ((function predicate &key recurse)
		       (loop for type in types
			     do (funcall recurse type function predicate)))

   :map-over-supertypes ((function predicate &key recurse keys-seen type for-lookup)
			 (with-type-decoded (nil nil pr-args) type
			   (if (null (cdr types))
			       ;; In singleton-case, we're equivalent to that type.
			       (merge-meta-args (first types) pr-args
						recurse function predicate)
			     (loop for (supertype super-predicate)
				       in (common-supertypes types for-lookup)
				   do
			       (with-presentation-type-key (key supertype)
				 (unless (already-seen-p key keys-seen)
				   (merge-meta-args supertype pr-args function key
						    (merge-predicates predicate
								      super-predicate))))))))

   )

#||
(defun test-common-or-failures ()
  (print (accept '(or sct:system sct:subsystem)
		 :prompt "a system"))
  (print (accept '(or sct:system sct:subsystem)
		 :prompt "a subsystem"))
  (print (accept '(null-or-type string) :default nil :provide-default t
		 :prompt "[Return]  NIL"))
  (print (accept '(null-or-type string) :default "foo" :provide-default t
		 :prompt "[Return]  foo"))
  (print (accept '(or (sys:function-spec :defined-p :any) sys:generic-function-name)
		 :prompt "undefined-fspec[End]")))
||#

;;; This intersects the type hierarchies of each type.
;;; The return value is an alist of (2type0 2predicate0) for each supertype,
;;; in the correct order.
(defun common-supertypes (type-list &optional for-lookup)
  (declare (values supertypes))
  (labels ((doit (types-to-go key-list)
	     (declare (dbg:invisible-frame :presentation-handler-search)
		      (sys:downward-function))
	     (macrolet ((cachable-p (type)
			  `(with-type-decoded (nil nil pr-args)
					      ,type
			     (loop for pr in pr-args
				   never (consed-in-control-stack pr)))))
	       (if types-to-go
		   (if (not (cachable-p (first types-to-go)))
		       ;; Can't cache, ignore the key, just get the answer.
		       (compute-common-supertypes type-list)
		     (with-key-for-cache (key (first types-to-go))
		       (stack-let ((key-list `(,key ,key-list)))
			 (doit (rest types-to-go) key-list))))
		 (multiple-value-bind (supertypes found-it)
		     (gethash key-list *common-supertypes-cache*)
		   (if found-it
		       supertypes
		     (multiple-value-bind (supertypes exists-p)
			 (compute-common-supertypes type-list)
		       (if (not exists-p)
			   nil
			 (setf supertypes (copy-list supertypes *handler-ephemeral-area*))
			 (loop for type-ptr on supertypes
			       for type-list = (first type-ptr)
			       do (setf (first type-list)
					(heap-copy-presentation-type (first type-list)
								     *handler-ephemeral-area*)
					(first type-ptr)
					(copy-list (first type-ptr) *handler-ephemeral-area*)))
			 (when (loop for (type) in supertypes
				     always (cachable-p type))			       
			   (setf (gethash (copy-tree key-list *handler-ephemeral-area*)
					  *common-supertypes-cache*)
				 supertypes))
			 supertypes)))))))
	   (compute-common-supertypes (type-list)
	     (declare (dbg:invisible-frame :presentation-handler-search)
		      (sys:downward-function))
	     (stack-let ((table (make-hash-table :test #'fringe-eql
						 :hash-function #'fringe-eql-hash
						 :locking nil))
			 (count (length type-list)))
	       (loop with type-alist = nil
		     for type in type-list
		     for i from 0
		     do
		 (labels ((note-type (supertype ignore predicate)
			    (declare (dbg:invisible-frame :presentation-handler-search)
				     (sys:downward-function))
			    (with-key-for-cache (superkey supertype)
			      (let ((flag-array (gethash superkey table)))
				(unless flag-array
				  (setf flag-array
					(setf (gethash (copy-tree superkey) table)
					      (make-array count :initial-value nil)))
				  (heap-copy-presentation-type-if-necessary supertype)
				  (push (list supertype flag-array) type-alist))
				(setf (aref flag-array i) (or predicate t))))))
		   (map-over-type-hierarchy type t for-lookup #'note-type nil))
		     finally
		       ;; Take them in the order we got them.
		       (setq type-alist (nreverse type-alist))
		       (loop with good-types
			     for (type array) in type-alist
			     do
			 (let ((array array))
			   (declare (sys:array-register array))
			   (when (loop for i below count
				       always (aref array i))
			     (push (list type
					 (loop for i below count
					       for npred = (aref array i)
					       for pred = (if (eq npred t) pred
							    (merge-or-predicates npred pred))
					       finally (return pred)))
				   good-types)))
			     finally
			       (return-from compute-common-supertypes
				 (values (nreverse good-types) t)))))))
    (stack-let ((key (list for-lookup)))
      (doit type-list key))))


(define-presentation-type and ((&rest types))
   :no-deftype t
   :disallow-atomic-type t
   :data-arguments-are-disjoint t
   :presentation-type-arguments (types)
   :history (()
	     (some #'find-accept-history types))
   :describer ((stream &key plural-count)
	       (labels ((that-is-or-are ()
			  (if plural-count " that are " " that is ")))
		 (describe-presentation-type (first types) stream plural-count)
		 (loop with previous-construction = nil
		       for type in (cdr types)
		       do
		   (with-type-decoded (typename nil pr-args) type
		     (case typename
		       (satisfies
			 (with-presentation-type-arguments (satisfies type)
			   (let ((desc (getf pr-args :description)))
			     (if (null desc)
				 ;;e.g. ((satisfies oddp))
				 (progn
				   (write-string
				     (ecase previous-construction
				       (satisfying " and ")
				       (that-is
					 (if plural-count " and satisfy " " and satisfies "))
				       ((nil normal-type) " satisfying "))
				     stream)
				   (prin1 satisfies-function stream)
				   (setq previous-construction 'satisfying))
				 ;;e.g. ((satisfies (lambda (x) ...)) :description "prime")
				 (write-string
				   (ecase previous-construction
				     ((satisfying nil normal-type) (that-is-or-are))
				     (that-is " and "))
				   stream)
				 (write-string desc stream)
				 (setq previous-construction 'that-is)))))
		       ;;e.g. ((not ((member ...))))
		       (otherwise
			 (write-string
			   (ecase previous-construction
			     ((satisfying nil) (that-is-or-are))
			     (that-is (if plural-count " and are " " and is "))
			     (normal-type " and "))
			   stream)
			 (describe-presentation-type type stream (not (null plural-count)))
			 (setq previous-construction 'normal-type)))))))

   :map-over-supertypes
   ((function predicate &key recurse type predicate-p)
    (with-type-decoded (nil nil pr-args) type
       (loop with predicate = (when predicate-p
				(compute-and-predicate types predicate))
	     for arg in types
	     do (merge-meta-args arg pr-args recurse function predicate))))

   :map-over-subtypes
   ((function predicate &key recurse predicate-p)
    (when predicate-p
      (destructuring-bind (main-type . restrictions) types
	(labels ((recurse-with-predicate (type key new-predicate)
		   (declare (sys:downward-function)
			    (dbg:invisible-frame :presentation-handler-search))
		   (funcall function type key
			    (compute-and-predicate restrictions new-predicate))))
	  (funcall recurse
		   main-type #'recurse-with-predicate predicate)))))
   :key-function ((function original-type-name)
		  (stack-let ((data-args `(,original-type-name ,@types)))
		    (call-with-presentation-type-keys function data-args)))

   :with-cache-key ((function original-type-name)
		    (stack-let ((data-args `(,original-type-name ,@types)))
		      (call-with-presentation-type-cache-keys function data-args)))
    )

;;; We really want to build a stack-closure, and copy it to the heap
;;; if we need to store it.
(defun compute-and-predicate (type-dargs existing-predicate)
  (if (null type-dargs)
      existing-predicate
    (if (and (not existing-predicate)		;Optimize ((and foo ((satisfies pred))))
	     ;;Fixed in Joshua
	     (not (cdr type-dargs))
	     (not (atom (car type-dargs)))
	     (or (eq (caar type-dargs) 'satisfies)
		 (and (consp (caar type-dargs))
		      (eq (caaar type-dargs) 'satisfies))))
	(if (consp (caar type-dargs))
	    (cadaar type-dargs)
	  (cadar type-dargs))
      (labels ((copy-types (types)
		 (loop for types on types
		       do (setf (first types)
				(heap-copy-presentation-type (first types) *predicate-area*
							     2)))
		 (copy-list types *predicate-area*))
	       (recurse (more-types key-so-far)
		 (if (null more-types)
		     (encache-predicate (key-so-far existing-predicate)
		       (compute-and-predicate-internal
			 (copy-types type-dargs)
			 existing-predicate))
		   (with-key-for-cache (nkey (first more-types))
		     (stack-let ((key (cons nkey key-so-far)))
		       (recurse (cdr more-types) key))))))
	(recurse type-dargs nil)))))

;;; Split to avoid consing closures unless needed.
(defun compute-and-predicate-internal (type-dargs existing-predicate)
  (labels ((predicate (object)
	     (declare (copyable-closure))
	     (and (or (null existing-predicate)
		      (funcall existing-predicate object))
		  (loop for tp in type-dargs
			always
			  (cond ((atom tp)
				 (ptypep object tp))
				((eq (car tp) 'satisfies)
				 (funcall (second tp) object))
				((atom (car tp))
				 (ptypep object tp))
				((eq (caar tp) 'satisfies)
				 (funcall (second (car tp)) object))
				(t (ptypep object (car tp))))))))
    #'predicate))


(define-presentation-type symbol ()
   :no-deftype t
   :parser ((stream &key default original-type)
	    (values (accept `(and expression (satisfies symbolp))
			    :stream stream
			    :prompt nil
			    :default default
			    :original-type original-type)))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
     ((function predicate &key type recurse predicate-p)
      (with-type-decoded (nil nil pr-args) type
	 (stack-let ((new-type `((expression) ,@pr-args))
		     (predicate (when predicate-p
				  (merge-predicates #'symbolp predicate))))
	   (funcall recurse (if pr-args new-type 'expression) function predicate))))
   :description "a symbol")

(define-presentation-type keyword ()
   :no-deftype t
   :printer ((object stream)
	     (write-string (string-capitalize (symbol-name object)) stream))
   :parser ((stream &key default default-supplied)
	    (let ((string (read-standard-token stream)))
	      (if (string-equal string "")
		  (if default-supplied
		      default
		    (sys:parse-error "No default supplied."))
		(values (intern (string-upcase string) si:pkg-keyword-package)))))
   :map-over-supertypes-and-subtypes
     ((function predicate &key supertype-p recurse predicate-p type)
      (when predicate-p
	(setq predicate (merge-predicates #'keywordp predicate)))
      (when (or supertype-p predicate-p)
	(with-type-decoded (nil nil pr-args) type
	   (merge-meta-args 'symbol pr-args recurse function predicate))))
   :description "a keyword")

(define-presentation-type package ()
   :no-deftype t
   :history t

   :printer ((object stream)
	     (write-string (zl:pkg-name object) stream))

   :parser ((stream &key type initially-display-possibilities)
	    (let* ((aarray si:*package-name-aarray*)
		   (completion-table nil))
	      (si:prepage-aarray aarray)
	      (si:sort-aarray aarray)
	      (let ((number-of-refnames 0)
		    (there-is-a-conflicting-refname nil)
		    (syntax (si:current-lisp-syntax)))
		(loop for pkg in (si:pkg-self-and-use-list *package*)
		      do (loop for (name . ref) in (si:pkg-relative-names pkg)
			       do (if ref
				      (incf number-of-refnames)
				      (setq there-is-a-conflicting-refname t))
			       when (let ((entry (si:aarray-lookup name aarray)))
				      ;; CL-USER has a ZL refname which is the same as global
				      ;; package name ZL.  This check keeps us from 
				      ;; gratuitously entering the slow case below, when the
				      ;; medium case would suffice. -kmp 8-Oct-89
				      (and entry (neq ref (second entry))))
				 do (setq there-is-a-conflicting-refname t)))
		(loop for (name . ref)
			  in (si:lisp-syntax-relative-names (si:current-lisp-syntax))
		      do (if ref
			     (incf number-of-refnames)
			     (setq there-is-a-conflicting-refname t))
		      when (let ((entry (si:aarray-lookup name aarray)))
			     (and entry (neq ref (second entry))))
			do (setq there-is-a-conflicting-refname t))
		(when (si:lisp-syntax-shadow-global-packages syntax)
		  (setq there-is-a-conflicting-refname t))
		(cond (there-is-a-conflicting-refname
		       ;; Slow case.
		       (let (new-aarray)
			 (if (si:lisp-syntax-shadow-global-packages syntax)
			     (setq new-aarray (si:make-aarray number-of-refnames))
			     (setq new-aarray (si:make-aarray (+ (fill-pointer aarray)
								 number-of-refnames)))
			     (loop for i below (fill-pointer aarray) do
			       (setf (aref new-aarray i) (copy-list (aref aarray i))))
			     (setf (fill-pointer new-aarray) (fill-pointer aarray))
			     (setf (si:aarray-sort-state new-aarray)
				   (si:aarray-sort-state aarray)))
			 (loop for pkg in (si:pkg-self-and-use-list *package*)
			       do (loop for (name . other-pkg) in (si:pkg-relative-names pkg)
					when other-pkg
					  do (si:aarray-insert new-aarray name other-pkg)))
			 (loop for (name . other-pkg)
				   in (si:lisp-syntax-relative-names syntax)
			       do (if other-pkg
				      (si:aarray-insert new-aarray name other-pkg)
				      (si:aarray-delete-by-name new-aarray name)))
			 (setq completion-table new-aarray)))
		      ((plusp number-of-refnames)
		       ;; Medium case.
		       (setq completion-table (g-l-p aarray))
		       (loop for pkg in (si:pkg-self-and-use-list *package*)
			     do (loop for (name . other-pkg) in (si:pkg-relative-names pkg)
				      when other-pkg
					do (push (list name other-pkg) completion-table)))
		       (loop for (name . other-pkg)
				 in (si:lisp-syntax-relative-names syntax)
			     when other-pkg
			       do (push (list name other-pkg) completion-table)))
		      (t (setq completion-table aarray))) ; Fast case.
		(multiple-value-bind (string success pkg)
		    (complete-input-from-aarray
		      completion-table
		      stream
		      :partial-completers `(#\Space)
		      :type type
		      :possibility-printer
		        #'(lambda (name package stream &optional presentation-type)
			    (declare (sys:downward-function))
			    (ignore presentation-type)
			    (with-output-as-presentation
				(:object package
				 :type type
				 :stream stream)
			      (princ name stream)))
		      :initially-display-possibilities initially-display-possibilities
		      :compression-delimiter #\-)
		  (ignore string success)
		  (values pkg type)))))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (when predicate-p
      (setq predicate (merge-predicates #'packagep predicate)))
    (with-type-decoded (nil nil pr-args) type
       (merge-meta-args 'zl:package pr-args recurse function predicate)))
   :description "a package")


(defmacro standard-recurse-supertype (function predicate &key recurse type predicate-p
				      new-type new-predicate subtype-predicates)
  `(progn ,@(when new-predicate
	    `((when ,predicate-p
		(unless (or ,@(loop for pred in subtype-predicates
				    collect `(eql ,predicate ,pred)))
		  (setq ,predicate (merge-predicates ,new-predicate ,predicate))))))
	  ,(if type
	       `(with-type-decoded (nil nil pr-args) ,type
		   (merge-meta-args ,new-type pr-args ,recurse ,function ,predicate))
	     `(funcall ,recurse ,new-type ,function ,predicate))))

(defvar *print-function-specs-by-source-language* nil)    ;; default for function-spec printer
(defvar *enable-per-language-function-spec-printing* t)   ;; T means obey keyword, NIL reverts
                                                          ;; to pre-patch behavior (i.e. ignore
							  ;; all language-specific stuff).

(define-presentation-type function (() &key (abbreviate-p *abbreviate-function-specs*)
				    (language-specific *print-function-specs-by-source-language*))
   :no-deftype t
   :parser ((stream)
	    (let ((fspec (accept '((sys:function-spec :defined-p t)) :stream stream
				 :prompt nil)))
	      (fdefinition fspec)))
   :printer
   ((object stream &key acceptably)
    (let ((fname (if (and *enable-per-language-function-spec-printing* language-specific)
		     (dbg:lframe-function-name (dbg:find-language-for-function object)
					       object (and abbreviate-p (not acceptably)))
		     (sys:function-name object))))
      (function-spec-printer
	fname
	stream (and abbreviate-p (not acceptably) (not (stringp fname))))))
   :map-over-supertypes
   ((function predicate &key recurse type predicate-p)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'expression
				:new-predicate #'functionp
				:subtype-predicates (#'zl:subrp
						     #'generic-function-p
						     #'dynamic-closure-p
						     #'lexical-closure-p
						     #'funcallable-instance-p)))

   :map-over-subtypes
   ((function predicate &key recurse type predicate-p for-lookup)
    (when (not for-lookup)
      (funcall recurse 'compiled-function function predicate)
      (funcall recurse 'generic-function function predicate)
      (funcall recurse 'lexical-closure function predicate)
      (funcall recurse 'dynamic-closure function predicate)
      ;; Only if CLOS is loaded
      (when (clos:find-class 'clos-internals:funcallable-instance nil)
	(funcall recurse 'clos-internals:funcallable-instance function predicate)))
    ;; Plus restricted cases of symbol and list
    (when predicate-p
      (let ((new-predicate (merge-predicates #'functionp predicate)))
	(funcall recurse 'symbol function new-predicate)
	(funcall recurse 'cons function new-predicate))))

   :description "a function")

(define-presentation-translator function-to-form
   (function sys:form
    :gesture :select)
   (function)
  (if (and (symbolp function)
	   (not (boundp function)))
      ;; Sometimes things presented as 1symbol0s can come through here.
      ;; Don't activate them if they're not useful in some way.
      (values function 'sys:form :activate nil)
    function))

(define-presentation-translator function-spec-to-compiled-function
   (((sys:function-spec :defined-p t)) compiled-function
    :tester ((object) (and (fdefinedp object)
			   (compiled-function-p
			     (fdefinition object)))))
   (fspec)
  (values (si:fdefinition fspec) 'compiled-function))

(define-presentation-translator compiled-function-to-function-spec
   (compiled-function ((sys:function-spec :defined-p t)))
   (function)
  (values (sys:function-name function) '((sys:function-spec :defined-p t))))

(define-presentation-translator function-spec-to-function
   (((sys:function-spec :defined-p t)) function
    :tester ((object) (fdefinedp object)))
   (fspec)
  (values (si:fdefinition fspec) 'function))

(define-presentation-translator function-to-function-spec
   (function ((sys:function-spec :defined-p t)))
   (function)
  (values (sys:function-name function) '((sys:function-spec :defined-p t))))

(define-presentation-type compiled-function
      (() &key (abbreviate-p *abbreviate-function-specs*))
   :no-deftype t
   :parser ((stream)
	    (let ((fspec (accept '((sys:function-spec :defined-p t)) :stream stream
				 :prompt nil)))
	      (unless (compiled-function-p (sys:fdefinition fspec))
		(si:parse-ferror "~S is not a compiled function." fspec))
	      (fdefinition fspec)))
   :printer ((object stream &key acceptably)
	     (function-spec-printer (sys:function-name object)
				    stream (and abbreviate-p (not acceptably))))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'function :new-predicate #'zl:subrp))

   :map-over-subtypes ((function predicate) (ignore function predicate))

   :description "a compiled function")

(define-presentation-type generic-function
      (() &key (abbreviate-p *abbreviate-function-specs*))
   :no-deftype t
   :parser ((stream)
	    (let* ((name (accept 'generic-function-name :stream stream :prompt nil))
		   (gf (flavor:find-generic-function name nil)))
	      (unless gf
		(si:parse-ferror "~S is not the name of a generic function." name))
	      gf))
   :printer ((object stream &key acceptably)
	     (function-spec-printer (sys:function-name object)
				    stream (and abbreviate-p (not acceptably))))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'function :new-predicate #'generic-function-p))

   :map-over-subtypes ((function predicate) (ignore function predicate))

   :description "a generic function")

(define-presentation-type clos-internals:funcallable-instance
      (() &key (abbreviate-p *abbreviate-function-specs*))
   :no-deftype t
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'function :new-predicate #'funcallable-instance-p))

   :map-over-subtypes ((function predicate) (ignore function predicate))

   :description "a funcallable instance")

(define-presentation-type lexical-closure ()
   :no-deftype t
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'function :new-predicate #'lexical-closure-p))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :description "a lexical closure")

(define-presentation-type dynamic-closure ()
   :no-deftype t
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'function :new-predicate #'dynamic-closure-p))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :description "a dynamic closure")

(define-presentation-type compiled-function-pc (() &rest options)
   :no-deftype t
   :history t
   :printer ((pc stream)
	     (multiple-value-bind (function offset)
		 (si:decode-pc pc)
	       (write-string "PC " stream)
	       (write offset :stream stream :base 8 :radix nil :integer-length nil)
	       (write-string " in " stream)
	       (present function 'function
			:stream stream
			:single-box t)))
   :parser ((stream)
	    (let* ((offset (accept '((integer 0) :description "an offset")
				   :stream stream
				   :prompt "offset"
				   :additional-activation-chars '(#\Space)))
		   (ch (dw:read-char-for-accept stream)))
	      (unless (dw:compare-char-for-accept ch #\space)
		(dw:unread-char-for-accept ch stream)
		(sys:parse-error "The PC must be followed by the name of a function."))
	      (let ((function (accept 'function
				      :stream stream
				      :additional-blip-chars '(#\Space))))
		(condition-case (.error.)
		     (si:%make-pc function offset)
		   (error (sys:parse-error "~A" .error.))))))	      
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (with-type-decoded (nil nil pr-args) type
       (let ((predicate (when predicate-p
			  (merge-predicates #'cli::compiled-function-pc-p predicate))))
	 (merge-meta-args '((expression) :escape nil) pr-args recurse function predicate))))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :description "a program counter location")

(define-presentation-type compiler:compiled-function-and-pc
      (() &key (pc-only nil) (bpt nil))
   :printer ((function-and-pc stream)
	     (if pc-only
		 (let ((*print-sensitive* nil)
		       (pc (second function-and-pc)))
		   ;; Can't call FORMAT here, it doesn't respect *print-sensitive*
		   (when (< pc #o100)
		     (write-char #\space stream))
		   (when (< pc #o10)
		     (write-char #\space stream))
		   (write pc :stream stream :base 8 :radix nil)
		   (write-char (if bpt #\* #\space) stream)
		   (write-char #\space stream))
		 (format stream "~S" (first function-and-pc))
		 (with-character-face (:italic)
		   (format stream " at pc "))
		 (format stream "~O" (second function-and-pc)))))

(define-presentation-type character ()
   :no-deftype t
   :parser ((stream)
	    (loop for char = (send stream :any-tyi)
		  when (typep char 'character)
		    return char
		  when (and (listp char)
			    (or (eq (car char) :activation)
				(eq (car char) :blip-character))
			    (typep (second char) 'character))
		    return (second char)
		  do (beep)))
   :printer ((char stream)
	     (format stream "~:C" char))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type '((expression) :escape nil)
				:new-predicate #'characterp
				:subtype-predicates (#'cli::standard-char-type-p
						     #'string-char-p)))
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :description "a character")


(define-presentation-type standard-char ()
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type 'string-char
				:new-predicate #'cli::standard-char-type-p))
   :description "a standard character")


(define-presentation-type string-char ()
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type 'character
				:new-predicate #'string-char-p
				:subtype-predicates (#'cli::standard-char-type-p)))
   :description "a string character")

(define-presentation-type simple-string ((&optional (size '*)) &rest options)
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (with-type-decoded (nil nil pr-args) type
       (labels ((do-supertype (new-type-name)
		  (stack-let ((new-type `((,new-type-name ,size) ,@pr-args)))
		    (stack-let ((new-type-1 `((,new-type-name) ,@pr-args)))
		      (stack-let ((new-type-2 `(,new-type-name ,size)))
			(cond ((and (null pr-args) (eq size '*))
			       (setq new-type new-type-name))
			      ((null pr-args)
			       (setq new-type new-type-2))
			      ((eq size '*)
			       (setq new-type new-type-1)))
			(standard-recurse-supertype function predicate
						    :recurse recurse :predicate-p predicate-p
						    :new-type new-type
						    :new-predicate #'simple-string-p))))))
	 (do-supertype 'string)
	 (do-supertype 'simple-vector))))
   :description "a simple string")

(define-presentation-type unbound-logic-variable ()
   :no-deftype t
   :history nil							;history doesn't make sense
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type 'expression
				:new-predicate #'unbound-logic-variable-p))
   :description "an unbound logic variable")

(define-presentation-type hash-table ()
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :type type :predicate-p predicate-p
				:new-type '(or si:basic-hash-table cli::basic-table)
				:new-predicate #'hash-table-p))
   :description "the Lisp representation of a hash-table")


(define-presentation-type declare ((declaration-type))
   :no-deftype t
   :map-over-supertypes-and-subtypes
   ((function predicate &key recurse predicate-p type for-lookup supertype-p keys-seen)
    (labels ((recurse-looking-for-array (new-type key predicate)
	       (ignore key)
	       (with-type-decoded (type-name data-args pr-args) new-type
		  (case type-name
		    ((array vector)
		     (labels ((recurse-on-array (new-element-type key predicate)
				(ignore key)
				(stack-let ((new-array-type `((,type-name ,new-element-type
							       ,@(cdr data-args)
							       ,@pr-args))))
				  (funcall recurse new-array-type function predicate))))
		       (map-over-type-hierarchy (car data-args) supertype-p for-lookup
			  #'recurse-on-array predicate predicate-p)))
		    (otherwise (funcall recurse new-type function predicate))))))
      (map-over-type-hierarchy declaration-type supertype-p for-lookup
	 #'recurse-looking-for-array predicate predicate-p keys-seen))))

;;; +++ This really wants some of the same hair that 1array0 has for canonicalization
;;; +++ within the type itself.  Sigh.
(define-presentation-type simple-array ((&optional element-type dimensions) &rest options)
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (with-type-decoded (nil data-args pr-args) type
       (stack-let ((new-type `((array ,@data-args) ,@pr-args))
		   (new-type-1 `(array ,@data-args)))
	 (when (null pr-args)
	   (setq new-type new-type-1)
	   (when (null data-args)
	     (setq new-type 'array)))
	 (standard-recurse-supertype function predicate
				     :recurse recurse :predicate-p predicate-p
				     :new-type new-type
				     :new-predicate #'cli::array-is-simple-p))))
   :description "a simple array")

(define-presentation-type readtable ()
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type 'zl:readtable
				:new-predicate #'readtablep))
   :description "a readtable")

(define-presentation-type locative ()
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type '((expression) :escape nil)
				:new-predicate #'locativep))
   :description "a locative")

;;; +++ This needs some of the hair of 1array
0(define-presentation-type simple-bit-vector ((&optional (size '*)) &rest options)
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (with-type-decoded (nil nil pr-args) type
       (labels ((do-supertype (new-type-name)
		  (stack-let ((new-type `((,new-type-name ,size) ,@pr-args))
			      (new-type-1 `((,new-type-name) ,@pr-args)))
		    (when (eq size '*)
		      (setq new-type new-type-1))
		    (when (null pr-args)
		      (setq new-type (car new-type)))
		    (when (and (eq size '*) (null pr-args))
		      (setq new-type new-type-name))
		    (standard-recurse-supertype function predicate
						:recurse recurse :predicate-p predicate-p
						:new-type new-type
						:new-predicate #'cli::array-is-simple-p))))
	 (do-supertype 'bit-vector)
	 (do-supertype 'simple-vector))))
   :description "a simple bit vector")

;;; This could use a lot more hair
(define-presentation-type atom ()
   :no-deftype t
   :map-over-subtypes
   ((function predicate &key recurse)
    (funcall recurse '(not cons) function predicate))
   :map-over-supertypes
   ((function predicate &key recurse type predicate-p)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type '(not cons)
				:new-predicate #'atom)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type 'expression
				:new-predicate #'atom))
   :description "an atom")

(define-presentation-type stream ()
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse predicate-p type)
    (standard-recurse-supertype function predicate
				:recurse recurse :predicate-p predicate-p :type type
				:new-type '((expression) :escape nil)
				:new-predicate #'streamp)))

;;; No explicit 1deftype0's needed for 1bit0, 1signed-byte0, 1unsigned-byte0, 1mod

0(define-presentation-type common (() &rest options)
  :no-deftype t
  :map-over-subtypes
  ((function predicate &key recurse predicate-p)
   (funcall recurse 'cons function predicate)
   (funcall recurse 'symbol function predicate)
   (funcall recurse '(array t) function predicate)
   (funcall recurse '(array fixnum) function predicate)
   (funcall recurse '(array (signed-byte 32)) function predicate)
   (funcall recurse '(array (unsigned-byte 16)) function predicate)
   (funcall recurse '(array (unsigned-byte 8)) function predicate)
   (funcall recurse '(array (unsigned-byte 4)) function predicate)
   (funcall recurse '(array (unsigned-byte 2)) function predicate)
   (funcall recurse '(array (unsigned-byte 1)) function predicate)
   (funcall recurse '(array boolean) function predicate)
   (when predicate-p
     (let ((predicate (merge-predicates #'cli::common-array-p predicate)))
       (funcall recurse 'array function predicate)))
   (funcall recurse 'number function predicate)
   (funcall recurse 'standard-char function predicate)
   (funcall recurse 'hash-table function predicate)
   (funcall recurse 'readtable function predicate)
   (funcall recurse 'package function predicate)
   (funcall recurse 'pathname function predicate)
   (funcall recurse 'stream function predicate)
   (funcall recurse 'random-state function predicate)
   (funcall recurse 'structure function predicate))

  :map-over-supertypes
  ((function predicate &key recurse predicate-p type)
   (stack-let ((new-type `((expression) ,@options)))
     (standard-recurse-supertype function predicate
				 :recurse recurse :predicate-p predicate-p
				 :new-type new-type 
				 :new-predicate #'commonp
				 :subtype-predicates (#'cli::standard-char-type-p
						      #'symbolp
						      #'consp
						      #'listp
						      #'zl:listp
						      #'stringp
						      #'complexp
						      #'single-float-p
						      #'double-float-p
						      #'rationalp
						      #'hash-table-p
						      #'readtablep
						      #'packagep
						      #'pathnamep
						      #'streamp
						      #'random-state-p))))
  :description "any Common Lisp object")




(defmacro accept-presentation-type-case ((stream . arglist) &body clauses)
  `(accept-presentation-type-case-internal
     ,stream
     . ,(loop for ((type . options) . action) in clauses
	      collect type
	      collect `(list . ,options)
	      collect `(lambda ,arglist (ignore . ,(remove 'ignore arglist)) . ,action))))

(defun accept-presentation-type-case-internal (stream &rest types-and-actions)
  (let ((no-good-token nil))
    (block done
      (with-input-editing (stream)
	(let ((start-pos (send stream :read-location)))
	  (loop for (type options action) on types-and-actions by 'cdddr doing
	    (condition-case (value type-read)
		 (apply #'accept type :stream stream :prompt nil options)
	       (input-not-of-required-type
		 (setq no-good-token (send value :string)))
	       (sys:parse-error )
	       (:no-error
		 (return-from done
		   (funcall action value type-read))))
	    (send stream :set-location start-pos))))
      (error 'input-not-of-required-type
	     :string no-good-token
	     :type `((or ,@(loop for (type) on types-and-actions by 'cddr
				 collect type)))))))

;;;; Simple tests

#||

(defun prompt-and-accept-test (type &rest prompt-args)
  (multiple-value-bind (object object-type)
      (apply #'prompt-and-accept type prompt-args)
    (terpri)
    (write-string "Read an instance of type ")
    (if (atom object-type)
	(prin1 object-type)
	(pprint object-type))
    (terpri)
    (write-string "  that is, ")
    (describe-presentation-type object-type *standard-output*)
    (write-char #\,)
    (terpri)
    (write-string "  specifically, ")
    (present object object-type)
    (write-char #\.)
    (terpri)))


(defun test-presentations-from-zwei (&optional eval)
  (zwei:with-editor-stream
    (s
      :interval zwei:*interval*
      :start (zwei:point))
    (loop for x = (read s)
	  while x
	  when (eq (car x) 'prompt-and-accept-test)
	    if eval do (send zwei:*typein-window* :clear-window)
		       (eval x)
		       (send zwei:*typein-window* :tyi)
	  else do
		 (send zwei:*typein-window* :clear-window)
		 (prin1 (cadadr x) zwei:*typein-window*)
		 (terpri zwei:*typein-window*)
		 (describe-presentation-type (cadadr x) zwei:*typein-window*)
		 (read-char *query-io*))))

(defun accept-cp-arg (presentation-type &key stream default prompt)
  (let ((ch (peek-char-for-accept stream)))
    (when (equal ch '(:blip-character #\Space nil :stop-completing))
      (read-char-for-accept stream)))
  (let ((value (accept presentation-type
		       :inherit-context nil
		       :prompt (or prompt :enter-type)
		       :prompts-in-line t	;Because it's not a detectable recursion yet
		       :additional-blip-chars si:*cp-arg-terminators*
		       :stream stream
		       :default default)))
    (when
      (member (peek-char-for-accept stream) si:*cp-arg-terminators*
	      :test #'compare-char-for-accept)
      (read-char-for-accept stream))
    value)
  )

||#

(define-presentation-type satisfies ((satisfies-function))
   :no-deftype t
   :data-arguments-are-disjoint t
   :disallow-atomic-type t
   :map-over-supertypes-and-subtypes
     ((function predicate &key predicate-p supertype-p type)
      (when (or predicate-p supertype-p)
	(with-type-decoded (ignore ignore original-pr-args) type
	   (merge-meta-args 'expression original-pr-args function 'expression
			    (compute-satisfies-predicate satisfies-function predicate)))))
   :key-function
     ((function original-type-name)
      (stack-let ((key `(,original-type-name
			 ,(if (consp satisfies-function)
			      (%make-pointer dtp-locative satisfies-function)
			    satisfies-function))))
	(funcall function key)))
   :presentation-subtypep
     ((type1 type2)
      (unless (or (atom type1)
		  (atom type2))
	(if (eql (second type1) (second type2))
	    (values t t)
	  (values nil nil))))
   :describer
     ((stream &key plural-count)
      (case plural-count
	((nil)
	 (princ "the representation of any Lisp object" stream))
	((t)
	 (princ "the representations of any Lisp objects" stream))
	(otherwise
	  (if (numberp plural-count)
	      (format stream "the representations of ~R Lisp objects" plural-count)
	    (princ plural-count stream))))
      (format stream " satisfying ~S" satisfies-function)))

;;; We really want to build a stack-closure, and copy it to the heap
;;; if we need to store it.
(defun compute-satisfies-predicate (satisfies existing-predicate)
  (if (not existing-predicate)
      satisfies
    (encache-predicate ((unlist satisfies) existing-predicate)
      (compute-satisfies-predicate-internal
	(sys:copy-if-necessary satisfies *predicate-area*)
	existing-predicate))))

;;; Split to avoid consing closures unless needed.
(defun compute-satisfies-predicate-internal (satisfies existing-predicate)
  (labels ((satisfies-predicate (obj)
	     (declare (copyable-closure))
	     (and (funcall existing-predicate obj)
		  (funcall satisfies obj))))
    #'satisfies-predicate))

(define-presentation-type data-type ((data-type-code))
   :data-arguments-are-disjoint t
   :expander 'expression
   :typep ((object) (eql (sys:data-type object) data-type-code)))

(define-presentation-type cli::equivalent ((&rest types))
   :no-deftype t
   :disallow-atomic-type t
   :key-function ((function original-type-name)
		  (stack-let ((data-args `(,original-type-name ,@types)))
		    (call-with-presentation-type-keys function data-args)))

   :with-cache-key ((function original-type-name)
		    (stack-let ((data-args `(,original-type-name ,@types)))
		      (call-with-presentation-type-cache-keys function data-args)))

   :presentation-subtypep
   ((type1 type2)
    (with-type-decoded (t1args) type1
      (with-type-decoded (t2args) type2
	(loop initially (when (and t2args (null t1args))
			  (return (values nil t)))
	      for t1 in t1args
	      do
	  (loop for t2 in t2args
		do
	    (multiple-value-bind (subtypep known-p)
		(presentation-subtypep t1 t2)
	      (when known-p
		(return-from cli::equivalent
		  (values subtypep known-p)))))))))
    
   :map-over-supertypes-and-subtypes
   ((function predicate &key recurse)
    (macrolet ((recurse-possible-cl-type (type fun pred)
		 `(cond ((or (atom ,type)
			     (not (atom (car ,type))))
			 (funcall recurse ,type ,fun ,pred))
			(t (stack-let ((type `(,,type)))
			     (funcall recurse type ,fun ,pred))))))
      (loop for tp in types
	    do
	(funcall recurse tp function predicate)))))

(define-presentation-type instance ((&optional (flavor '* flavor-p)))
   :no-deftype t
   :key-generator (progn (ignore flavor-p)
			 (if (eq flavor '*)
			     'instance
			   flavor))

   :map-over-subtypes
   ((function predicate &key for-lookup)
    (ignore function predicate for-lookup)
    ;; This would take up too much space, and isn't necessary.
    ;; Without it, matches will still occur, because for-lookup
    ;; references to flavors explicitly look at 1instance0.
    #+ignore
    (unless for-lookup
      (loop for flav in flavor:*all-flavor-names*
	    do (funcall function flav flav predicate))))

   :map-over-supertypes
   ((function predicate &key type recurse)
    (with-type-decoded (nil nil pr-args) type
       (unless (eq flavor '*)
	 ;; Canonicalize it to the flavor name
	 (merge-meta-args flavor pr-args function flavor predicate))
       (when flavor-p
	 (merge-meta-args 'instance pr-args recurse function predicate))
       (merge-meta-args '((expression) :escape nil) pr-args
			recurse function predicate)))

   )

(define-presentation-type clos-internals:member-of-class ((&optional (class '* class-p)))
   :no-deftype t
   :key-generator (progn (ignore class-p)
			 (if (eq class '*)
			     'clos-internals:member-of-class
			   class))

   :map-over-subtypes
   ((function predicate &key for-lookup)
    (ignore function predicate for-lookup)
    ;; This would take up too much space, and isn't necessary.
    ;; Without it, matches will still occur, because for-lookup
    ;; references to classes explicitly look at 1instance0.
    #+ignore
    (unless for-lookup
      (loop for cl in clos-internals:*all-class-names*
	    do (funcall function cl cl predicate))))

   :map-over-supertypes
   ((function predicate &key type recurse)
    (with-type-decoded (nil nil pr-args) type
       (unless (eq class '*)
	 ;; Canonicalize it to the class name
	 (merge-meta-args class pr-args function class predicate))
       (when class-p
	 (merge-meta-args 'clos-internals:member-of-class
			  pr-args recurse function predicate))
       (merge-meta-args '((expression) :escape nil) pr-args
			recurse function predicate)))

   )

(define-presentation-type clos-internals::member-of-class-named
      ((&optional (class-name '* class-name-p)))
   :no-deftype t
   :key-generator (progn (ignore class-name-p)
			 (if (eq class-name '*)
			     'clos-internals::member-of-class-named
			   class-name))

   :map-over-subtypes
   ((function predicate &key for-lookup)
    (ignore function predicate for-lookup)
    ;; This would take up too much space, and isn't necessary.
    ;; Without it, matches will still occur, because for-lookup
    ;; references to classes explicitly look at 1instance0.
    #+ignore
    (unless for-lookup
      (loop for cl in clos-internals:*all-class-names*
	    do (funcall function cl cl predicate))))

   :map-over-supertypes
   ((function predicate &key type recurse)
    (with-type-decoded (nil nil pr-args) type
       (unless (eq class-name '*)
	 ;; Canonicalize it to the class name
	 (merge-meta-args class-name pr-args function class-name predicate))
       (when class-name-p
	 (merge-meta-args 'clos-internals::member-of-class-named
			  pr-args recurse function predicate))
       (merge-meta-args '((expression) :escape nil) pr-args
			recurse function predicate)))

   )

(define-presentation-type structure ((&optional (structure-name '* structure-name-p)))
   :no-deftype t
   :key-generator (progn structure-name-p
			 (if (eq structure-name '*)
			     'structure
			   structure-name))

   :map-over-subtypes
   ((function predicate &key for-lookup)
    (ignore function predicate for-lookup)
    ;; This would take up too much space, and isn't necessary.
    ;; Without it, matches will still occur, because for-lookup
    ;; references to structures explicitly look at1 structure0.
    ;; 1cli::*all-structure-names*0 doesn't exist, anyway.
    #+ignore
    (unless for-lookup
      (loop for flav in cli::*all-structure-names*
	    do (funcall function flav flav predicate))))

   :map-over-supertypes
   ((function predicate &key recurse type)
    (with-type-decoded (nil nil pr-args) type
       (unless (eq structure-name '*)
	 ;; Canonicalize it to the structure name
	 (merge-meta-args structure-name pr-args function structure-name predicate))
       (when structure-name-p
	 (merge-meta-args 'structure pr-args recurse function predicate))
       (merge-meta-args '((expression) :escape nil) pr-args
			recurse function predicate)))
   )


#||

;;; start here for print-presentations-from-zwei
(test-presentations-from-zwei t)

(test-presentations-from-zwei)

(prompt-and-accept-test 'integer)

(prompt-and-accept-test '((integer 0 10)))

(prompt-and-accept-test '((integer 0 8) :base 8) "Type frammis coefficient, octal")

(prompt-and-accept-test 'fs:pathname "Input file")

(prompt-and-accept-test '((and boolean ((satisfies identity)))))

(prompt-and-accept-test 'boolean)

(prompt-and-accept-test '((member :foo :bar)))

(prompt-and-accept-test '((sequence integer)))

(prompt-and-accept-test '((sequence-enumerated fixnum fixnum float)))

(prompt-and-accept-test '((or float integer)) "Enter new garbage generator coefficient")

(prompt-and-accept-test '((sequence ((integer) :base 8))))

(prompt-and-accept-test '((sequence-enumerated ((integer) :base 8) ((integer) :base 8))))
		      
(prompt-and-accept-test '((sequence zwei:address)))

(prompt-and-accept-test 'time:time-interval)

(prompt-and-accept-test '((or null integer)))

(prompt-and-accept-test '((or integer pathname)))

(prompt-and-accept-test '((or integer time:time-interval) :description
			"a retention number or time interval"))

(prompt-and-accept-test '((sequence string)))

(prompt-and-accept-test '(:type ((sequence ((or null time:time-interval zwei:address))))
			  :provide-default nil))

(prompt-and-accept-test '((sequence-enumerated
			    ((or null time:time-interval zwei:address))
			    ((or null time:time-interval zwei:address))
			    ((or null time:time-interval zwei:address)))))

(prompt-and-accept-test '((and integer ((satisfies oddp))) :description "an odd integer")
			"Enter frammis number")

(prompt-and-accept-test '((and ((integer 0 4)) ((satisfies oddp))) :description
			  "a small odd integer")
			"Enter frammis number")

(prompt-and-accept-test '((or integer fs:pathname) :description "a microcode number")
		      "Enter frammisette number")

(prompt-and-accept-test 'net:local-host)

(prompt-and-accept-test '(:type ((sequence ((or net:local-host net:host))))
			  :provide-default nil)
			"Retrieval hosts, or Locals")

(prompt-and-accept-test '((sequence pathname)))

(prompt-and-accept-test '((sequence time:universal-time)))

(present (prompt-and-accept 'time:universal-time)
	 '((time:universal-time) :long-date t))

(prompt-and-accept-test '((time:universal-time) :past-p t))

(prompt-and-accept-test '((sequence-enumerated ((or integer pathname)) time:universal-time)))

(prompt-and-accept-test '((sequence ((sequence-enumerated integer string)))))

(prompt-and-accept-test '((sequence ((sequence-enumerated integer string string)))))

(prompt-and-accept-test 'expression)

(prompt-and-accept-test 'flavor-name)

(prompt-and-accept-test 'sct:system)

(prompt-and-accept-test '((sct:system :loaded-only nil)))

(prompt-and-accept-test 'function-spec "Function to be traced")

(prompt-and-accept-test '((and function-spec ((satisfies zl:fdefinedp)))))

(prompt-and-accept-test '((sequence ((and function-spec ((satisfies zl:fdefinedp)))))))

(prompt-and-accept-test '((string) :delimiters (#\End)))

(prompt-and-accept-test '((or null expression)))

(prompt-and-accept-test `((or neti:namespace-class null)))

(prompt-and-accept-test '((sequence printer)))

(prompt-and-accept-test '(:type ((sequence ((or printer string))))
			  :provide-default nil))

(prompt-and-accept-test '((or character null)))

(prompt-and-accept-test '((subset :abel :baker :bozo :charlie)))

(prompt-and-accept-test '((or null
			      ((sequence-enumerated
				 pathname	;doesn't work for no keywords
				 ((subset :abel :baker :bozo :charlie)))))))


() ;;ends zwei test
||#
