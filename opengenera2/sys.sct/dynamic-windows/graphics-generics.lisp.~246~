;;; -*- Mode: LISP; Syntax: Common-lisp; Package: GRAPHICS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")graphics:draw-0this-and-that.

;;; Standard keyword arguments:
;;;  1:stream0 (default 1*standard-output*0)
;;;  1:alu0 (default 1:draw0).  A keyword or device specific alu.
;;;  1:thickness0 (default 100).  When outlining.
;;;  1:scale-thickness0 (default 1t0).  Whether in device or user space scale.
;;;  1:dashed0 (default 1nil0).  Draw dashed lines.
;;;  1:dash-pattern0 (default for screen1 #(10 10)0).  Segments that make up on-off pattern.
;;;  1:initial-dash-phase0 (default 100).  Starting offset into dashing pattern.
;;;  1:draw-partial-dashes0 (default 1t0).
;;;   If 1nil0, draw dashes up the end point of line segments, even if segments are distorted.
;;;  1:scale-dashes0 (default 1nil0).  Whether in device or user space scale.
;;;  1:line-end-shape0 (default 1:butt0).  One of 1:butt0,1 :square0, 1:round0, or 1:no-end-point0.
;;;  1:line-joint-shape0 (default 1:miter0).  One of 1:miter0, 1:bevel0, 1:round0, or 1:none0.
;;;  1:filled0 (default 1t0).  Otherwise just outline.
;;;  1:stipple0 (default 1nil0).  A bitmap replicated as the source with alu's.
;;;  1:tile0 (default 1nil0).  A bitmap replicated as the source pixel by pixel.
;;;  1:pattern0 (default 1nil0).  A more general pattern source.
;;;  1:opaque0 (default 1t0).  If t, bits off in the source pattern are cleared rather
;;;   than left alone.
;;;  1:gray-level0 (default 110).  A blackwhite level for grayscale.
;;;   Simulated with stippling on 1-bit devices.
;;;  1:mask0 (default 1nil0).  A bitmap of points to be affected.
;;;  1:mask-x0, 1:mask-y0 (default 0).  Position of mask.
;;;  1:return-presentation0 (default1 nil0).  Return a presentation object.

;;;  1with-scan-conversion-mode0 options are 1:round-coordinates0, 1:center-circles0, and
;;;   1:host-allowed0.  1:flatness0 is supposed by PostScript devices.  1:sketch0 is a catch-all.
;;;   1:anti-alias0 and so on can be added in the future.

;;; Keyword arguments that affect the coordinate system for this one operation:
;;;  1:rotation0 (default 100)
;;;  1:scale0 (default 110): scale both x and y
;;;  1:scale-x0 (default1 10): scale just x
;;;  1:scale-y0 (default 110): scale just y
;;;  1:translation0 (default1 nil0): list of (x y)
;;;  1:transform0 (default 1nil0): an arbitrary transform matrix.

;;; Flavors involved:
;;;  1standard-graphics-mixin0: defines default handlers.  Shared by LGP2 and TV, e.g.
;;;   This is where standard whoppers to handle transformation from the argument list
;;;   are handled.
;;;  1raster-graphics-mixin0: output by rows of pixels.  Shared by TV and LGP1 kind of thing.
;;;   Relies on implementation of the standard stream protocol graphics portion.
;;;  1tv:graphics-mixin0: output to sheets.  Uses microcoded implementation for primitive
;;;   stream operations.

;;;; General 2-D transformation matrices

;;; The transformation matrix [R11 R12 0
;;; 			       R21 R22 0
;;; 			        TX  TY 1]
;;; is stored as a this six-element list.
(defstruct (graphics-transform :list )
  r11
  r12
  r21
  r22
  tx
  ty)

(defsubst make-identity-transform ()
  (list 1 0 0 1 0 0))

(defparameter *identity-transform* (make-identity-transform))

;;; Apply coordinate transform.
(defun transform-point (x y transform)
  (destructuring-bind (a b c d tx ty) transform
    (values (+ (* x a) (* y c) tx)
	    (+ (* x b) (* y d) ty))))

(defun untransform-point (x y transform)
  (destructuring-bind (a b c d tx ty) transform
    (decf x tx)
    (decf y ty)
    (let ((scale (- (* a d) (* b c))))
      (values (/ (- (* d x) (* c y)) scale)
	      (/ (- (* a y) (* b x)) scale)))))

(defun transform-distance (x y transform)
  (destructuring-bind (a b c d ignore ignore) transform
    (values (+ (* x a) (* y c))
	    (+ (* x b) (* y d)))))

(defun untransform-distance (x y transform)
  (destructuring-bind (a b c d ignore ignore) transform
    (let ((scale (- (* a d) (* b c))))
      (values (/ (- (* d x) (* c y)) scale)
	      (/ (- (* a y) (* b x)) scale)))))

;;; Destructively modify 1transform0 to be 1additional-transform . transform0.
(defun compose-transforms (transform additional-transform)
  (destructuring-bind (a1 b1 c1 d1 tx1 ty1) transform
    (destructuring-bind (a2 b2 c2 d2 tx2 ty2) additional-transform
      (setf (first transform) (+ (* a1 a2) (* c1 b2)))
      (setf (second transform) (+ (* b1 a2) (* d1 b2)))
      (setf (third transform) (+ (* c1 d2) (* a1 c2)))
      (setf (fourth transform) (+ (* d1 d2) (* b1 c2)))
      (setf (fifth transform) (+ tx1 (* a1 tx2) (* c1 ty2)))
      (setf (sixth transform) (+ ty1 (* d1 ty2) (* b1 tx2)))))
  transform)

;;; Break a transform into a scale + a rotation [+ an x scale] + a translation,
;;;  as if applied in that order.  I.e.
;;; (building-graphics-transform ()
;;;   (with-graphics-translation (t translate-x translate-y)
;;;     (with-graphics-scale (t skew-x 1)
;;;       (with-graphics-rotation (t rotation)
;;;         (with-graphics-scale (t scale-x scale-y)
;;;           ...)))))
;;; The first x scale (last value) will be 1 from anything made by 1build-graphics-transform0.
;;; It accounts for shear.
(defun decompose-transform (transform)
  (declare (values rotation scale-x scale-y translate-x translate-y skew-x))
  (destructuring-bind (a b c d tx ty) transform
    (if (and (= b 0) (= c 0))
	(values 0 a d tx ty 1)
	(cond ((< (abs b) 1.0e-5)
	       ;; Next to no rotation.
	       (values 0 a d tx ty 1))
	      ((< (abs a) 1.0e-5)
	       ;; Next to 90 degree rotation.
	       (values (/ pi 2) b (- c) tx ty 1))
	      (t
	       (let* ((z (sqrt (abs (/ (* a c) (* b d)))))
		      (theta (atan b (/ a z)))
		      (sin (sin theta))
		      (cos (cos theta)))
		 (values theta (/ b sin) (/ d cos) tx ty z)))))))

;;; Return a transform which is the inverse of this one.
(defun invert-transform (transform &optional (into-transform (make-graphics-transform)))
  (destructuring-bind (a b c d x y) transform
    (let ((scale (- (* a d) (* b c))))
      (setf (first into-transform) (/ d scale))
      (setf (second into-transform) (/ (- b) scale))
      (setf (third into-transform) (/ (- c) scale))
      (setf (fourth into-transform) (/ a scale))
      (setf (fifth into-transform) (/ (- (* c y) (* d x)) scale))
      (setf (sixth into-transform) (/ (- (* b x) (* a y)) scale))))
  into-transform)

;;; Perform1 body0 while 1stream0 has a modifiable copy of its current transformation matrix.
(defmacro saving-graphics-transform ((&optional stream) &body body)
  (dw::format-output-macro-default-stream stream)
  `(saving-graphics-transform-internal
     (dw::named-continuation saving-graphics-transform (,stream) . ,body)
     ,stream))

;;; We just share transformation matrices.  Then when any output operation is done, we
;;; modify that matrix to take into account our additional offsets.
(defmethod (stream-transform dw::encapsulating-output-stream) ()
  (stream-transform dw::stream))

;;; Call 1continuation0 on 1xstream0 with 1transform0 as the CTM.
(defgeneric with-new-stream-transform (stream transform continuation xstream)
  (:function (funcall (flavor:generic with-new-stream-transform)
		      (si:follow-syn-stream stream) transform continuation xstream))
  )

(defmethod (with-new-stream-transform dw::encapsulating-output-stream) (&rest args)
  (apply #'with-new-stream-transform dw::stream args))

(defun saving-graphics-transform-internal (continuation xstream)
  (declare (downward-funarg continuation))
  (unless (cli::null-streamp xstream)
    (stack-let ((.transform. (make-graphics-transform)))
      (replace .transform. (stream-transform xstream))
      (with-new-stream-transform xstream .transform. continuation xstream))))

;;; Perform 1body0 with 1transform0 composed with 1stream0's CTM.
(defmacro with-graphics-transform ((stream transform) &body body)
  (dw:format-output-macro-default-stream stream)
  `(saving-graphics-transform (,stream)
     (stack-let ((.transform. ,transform))
       (stream-compose-transforms ,stream .transform.))
     . ,body))

;;; Perform 1body0 with a translation along the current axes.
(defmacro with-graphics-translation ((stream delta-x delta-y) &body body)
  (dw::format-output-macro-default-stream stream)
  `(saving-graphics-transform (,stream)
     (graphics-translate ,delta-x ,delta-y :stream ,stream)
     . ,body))

;;; Modify 1stream0's CTM to account for translation along the current axes.
;;; Should be used within a 1savings-graphics-transform0 someplace; for instance
;;; within a 1draw-path0 function.
(defun graphics-translate (delta-x delta-y &key (stream *standard-output*))
  (stream-compose-transform-rest stream 1 0 0 1 delta-x delta-y))

;;; Perform 1body0 with x and y coordinates stretched.
(defmacro with-graphics-scale ((stream x-scale &optional (y-scale nil y-scale-p))
			       &body body
			       &environment env)
  (declare (arglist (stream scale &optional (y-scale scale)) &body body))
  (dw::format-output-macro-default-stream stream)
  (once-only (x-scale &environment env)
    `(saving-graphics-transform (,stream)
       (graphics-scale ,x-scale ,(if y-scale-p y-scale x-scale) :stream ,stream)
       . ,body)))

;;; Stretch the CTM.
;;; Should be used within a 1savings-graphics-transform0 someplace; for instance
;;; within a 1draw-path0 function.
(defun graphics-scale (x-scale &optional (y-scale x-scale) &key (stream *standard-output*))
  (stream-compose-transform-rest stream x-scale 0 0 y-scale 0 0))

;;; Perform 1body0 with the axes rotated.
(defmacro with-graphics-rotation ((stream theta) &body body &environment env)
  (dw::format-output-macro-default-stream stream)
  (once-only (theta &environment env)
    `(saving-graphics-transform (,stream)
       (graphics-rotate ,theta :stream ,stream)
       . ,body)))

;;; Rotate the axes of the CTM.
;;; Should be used within a 1savings-graphics-transform0 someplace; for instance
;;; within a 1draw-path0 function.
(defun graphics-rotate (theta &key (stream *standard-output*))
  (cond ((zerop theta))
	;; Use EQL so that we don't bother coercing single floats or rationals which cannot
	;; possibly be equal.
	((eql theta (/ pi 2))
	 (stream-compose-transform-rest stream 0 1 -1 0 0 0))
	((eql theta (/ pi -2))
	 (stream-compose-transform-rest stream 0 -1 1 0 0 0))
	(t
	 (let ((cos (cos theta))
	       (sin (sin theta)))
	   (stream-compose-transform-rest stream cos sin (- sin) cos 0 0)))))

;;; Compose general transform
;;; Should be used within a 1savings-graphics-transform0 someplace; for instance
;;; within a 1draw-path0 function.
(defun graphics-transform (transform &key (stream *standard-output*))
  (stream-compose-transforms stream transform))

(defun stream-compose-transforms (stream transform)
  (compose-transforms (stream-transform stream) transform))

(defun stream-compose-transform-rest (stream &rest transform)
  (compose-transforms (stream-transform stream) transform))

(defun stream-transform-point (x y stream)
  (transform-point x y (stream-transform stream)))

(defun stream-untransform-point (x y stream)
  (untransform-point x y (stream-transform stream)))

(defmacro with-graphics-identity-transform ((&optional stream) &body body)
  (dw::format-output-macro-default-stream stream)
  `(saving-graphics-transform (,stream)
     (replace (stream-transform ,stream) *identity-transform*)
     . ,body))

(defmacro transform-window-points (stream &rest points)
  `(multiple-value-bind (.window. .x-offset. .y-offset.)
       (send ,stream :window-and-offsets)
     . ,(loop for (x y) on points by 'cddr
	      collect `(multiple-value-setq (,x ,y)
			 (stream-transform-point ,x ,y .window.))
	      collect `(setq ,x (+ (round ,x) .x-offset.)
			     ,y (+ (round ,y) .y-offset.)))))

(defmacro untransform-window-points (stream &rest points)
  `(multiple-value-bind (.window. .x-offset. .y-offset.)
       (send ,stream :window-and-offsets)
     . ,(loop for (x y) on points by 'cddr
	      collect `(multiple-value-setq (,x ,y)
			 (stream-untransform-point (- ,x .x-offset.) (- ,y .y-offset.)
						   .window.)))))

;;; Return the result of executing 1body0 on the stream's graphics transform.
(defmacro building-graphics-transform ((&optional stream) &body body)
  (dw::format-output-macro-default-stream stream)
  ;; Any old stream will do, this happens to be an otherwise harmless resource.
  ;; We could use the window directly, but the body might just do some output, too.
  `(using-resource (,stream dw::pixel-width-stream :stream tv:initial-lisp-listener)
     (with-graphics-identity-transform (,stream)
       (progn . ,body)
       (copy-seq (stream-transform ,stream)))))

;;; Make up a transform out of pieces, but without expliciting having a stream in hand.
;;; Order of application is the standard one: scale, rotate, translate.
(defun build-graphics-transform (&key (rotation 0)
				      (scale 1)
				      (scale-x 1)
				      (scale-y 1)
				      (translation nil)
				      (transform nil))
  (building-graphics-transform (stream)
    (when transform
      (stream-compose-transforms stream transform))
    (when translation
      (graphics-translate (first translation) (second translation) :stream stream))
    (unless (zerop rotation)
      (graphics-rotate rotation :stream stream))
    (unless (and (= scale 1) (= scale-x 1) (= scale-y 1) )
      (graphics-scale (* scale scale-x) (* scale scale-y) :stream stream))))

(defun build-multiple-point-transform (points)
  (labels ((line-length (from-x from-y to-x to-y)
	     (sqrt (+ (expt (- to-x from-x) 2) (expt (- to-y from-y) 2))))
	   (coord-scale (from-x1 from-y1 from-x2 from-y2 from-x3 from-y3
			 to-x1 to-y1 to-x2 to-y2 to-x3 to-y3)
	     (list (/ (line-length to-x1 to-y1 to-x2 to-y2)
		      (line-length from-x1 from-y1 from-x2 from-y2)) 0
		   0 (/ (line-length to-x3 to-y3 to-x2 to-y2)
			(line-length from-x3 from-y3 from-x2 from-y2))
		   0 0))
	   (lines-angle (x1 y1 x2 y2 x3 y3)
	     (let ((angle (- (atan (- y3 y2) (- x3 x2)) (atan (- y1 y2) (- x1 x2)))))
	       (when (> angle pi) (setq angle (- angle 2pi)))
	       (when (< angle (- pi)) (setq angle (+ angle 2pi)))
	       angle))
	   (coord-system (x1 y1 x2 y2 x3 y3)
	     (let* ((angle (lines-angle x1 y1 x2 y2 x3 y3))
		    (slant (- (atan (- y1 y2) (- x1 x2))))
		    (scale (sin angle))
		    (r11 (/ (sin (- angle slant)) scale))
		    (r12 (/ (sin (- angle slant (/ pi 2))) scale))
		    (r21 (/ (sin slant) scale))
		    (r22 (/ (sin (+ slant (/ pi 2))) scale)))
	       (list r11 r21 r12 r22
		     (+ (* r11 (- x2)) (* r12 (- y2))) (+ (* r21 (- x2)) (* r22 (- y2)))))))
    (ecase (length points)
      (4 (destructuring-bind (from-x from-y to-x to-y) points
	   (list 1 0 0 1 (- to-x from-x) (- to-y from-y))))
      (8 (destructuring-bind (from-x1 from-y1 from-x2 from-y2 to-x1 to-y1 to-x2 to-y2) points
	   (building-graphics-transform (t)
	     (graphics-translate to-x1 to-y1)
	     (graphics-rotate (- (atan (- to-y2 to-y1) (- to-x2 to-x1))
				 (atan (- from-y2 from-y1) (- from-x2 from-x1))))
	     (graphics-scale (/ (line-length to-x2 to-y2 to-x1 to-y1)
				(line-length from-x2 from-y2 from-x1 from-y1)))
	     (graphics-translate (- from-x1) (- from-y1)))))
      (12 (destructuring-bind (from-x1 from-y1 from-x2 from-y2 from-x3 from-y3
			       to-x1 to-y1 to-x2 to-y2 to-x3 to-y3)
	     points
	    (let ((scale (coord-scale from-x1 from-y1 from-x2 from-y2 from-x3 from-y3
				      to-x1 to-y1 to-x2 to-y2 to-x3 to-y3))
		  (matrix1 (coord-system from-x1 from-y1 from-x2 from-y2 from-x3 from-y3))
		  (matrix2 (coord-system to-x1 to-y1 to-x2 to-y2 to-x3 to-y3)))
	      (invert-transform matrix2 matrix2)
	      (compose-transforms scale matrix1)
	      (compose-transforms matrix2 scale)
	      matrix2))))))

;;; Translate points specified in according to the CTM into standard plane coordinates.
(defmacro-in-flavor (transform-points standard-graphics-mixin) (&rest points)
  `(let ((.transform. (stream-transform self)))
     . ,(loop for (x y) on points by 'cddr
	      collect `(multiple-value-setq (,x ,y)
			 (transform-point ,x ,y .transform.)))))

(defmacro fix-points (&rest numbers)
  `(progn . ,(loop for number in numbers
		   collect `(unless (integerp ,number)
			      (setf ,number (round ,number))))))

;;; Translate point and make the coordinates integers.
(defun transform-and-fix-point (x y transform)
  (multiple-value-setq (x y)
    (transform-point x y transform))
  (fix-points x y)
  (values x y))

;;; Translate and fix.
(defmacro transform-and-fix-points-internal (transform &rest points &environment env)
  (once-only (transform &environment env)
    `(progn
       . ,(loop for (x y) on points by 'cddr
		collect `(multiple-value-setq (,x ,y)
			   (transform-and-fix-point ,x ,y ,transform))))))

;;; Translate a sequence of points.  Should be called within a 1with-data-stack0.
(defun transform-and-fix-point-set-internal (transform points &optional (closed nil))
  (let ((new-points (make-stack-array (if closed (+ (length points) 2) (length points)))))
    (let ((i 0))
      (map-points #'(lambda (x y ignore)
		      (multiple-value-setq (x y)
			(transform-and-fix-point x y transform))
		      (setf (aref new-points i) x
			    (aref new-points (1+ i)) y)
		      (incf i 2))
		  points)
      (when closed
	(setf (aref new-points i) (aref new-points 0)
	      (aref new-points (1+ i)) (aref new-points 1))))
    new-points))

(defmacro-in-flavor (transform-and-fix-points standard-graphics-mixin) (&rest points)
  `(transform-and-fix-points-internal (stream-transform self) . ,points))

(defsubst-in-flavor (transform-and-fix-point-set standard-graphics-mixin)
		    (points &optional closed)
  (transform-and-fix-point-set-internal (stream-transform self) points closed))


(defmacro with-physical-device-scale ((stream scale unit) &body body)
  (dw::format-output-macro-default-stream stream)
  `(with-graphics-scale (,stream (physical-device-scale ,scale ,unit :stream ,stream))
     . ,body))

(defun physical-device-scale (scale unit &key (stream *standard-output*))
  (* scale
     (case unit
       (:inch (* .0254 (send stream :physical-unit-scale-factor :meter)))
       (:centimeter (* .01 (send stream :physical-unit-scale-factor :meter)))
       (:mica (* 1e-5 (send stream :physical-unit-scale-factor :meter)))
       (otherwise (send stream :physical-unit-scale-factor unit)))))

(defmethod (:physical-unit-scale-factor dw::encapsulating-output-stream) (unit)
  (send dw::stream :physical-unit-scale-factor unit))


;;;; Further support for special host specific graphics functions.

;;; The idea is that the screen passes the normal function and points to the window,
;;; which calls it back.  Dynamic windows convert the points for the current viewport,
;;; and remember the call.  If the dynamic window history is somehow replayed when attached
;;; to a different kind of screen, a default function is called which translates the host
;;; specific state description back into a generic description.

(defgeneric screen-specific-two-point-graphics (window
						screen-type default-function screen-function
						left top right bottom alu
						bounding-box refined-position-test refined-box
						&rest more-args))

(defgeneric screen-specific-n-point-graphics (window
					      screen-type default-function screen-function
					      points alu
					      bounding-box refined-position-test refined-box
					      &rest more-args))

(defmethod (screen-specific-two-point-graphics raster-graphics-mixin)
	   (screen-type default-function screen-function &rest args)
  (ignore screen-type screen-function)
  (apply default-function self args))

(defmethod (screen-specific-n-point-graphics raster-graphics-mixin)
	   (screen-type default-function screen-function &rest args)
  (ignore screen-type screen-function)
  (apply default-function self args))

(defmethod (screen-specific-two-point-graphics tv:graphics-mixin) (&rest args)
  (apply #'%screen-specific-two-point-graphics tv:screen self args))

(defmethod (screen-specific-n-point-graphics tv:graphics-mixin) (&rest args)
  (apply #'%screen-specific-n-point-graphics tv:screen self args))

(defmethod (%screen-specific-two-point-graphics tv:basic-screen)
	   (sheet screen-type default-function screen-function &rest args)
  (ignore screen-type screen-function)
  (apply default-function sheet args))

(defmethod (%screen-specific-n-point-graphics tv:basic-screen)
	   (sheet screen-type default-function screen-function &rest args)
  (ignore screen-type screen-function)
  (apply default-function sheet args))

(defmacro define-screen-specific-graphics-type (type two-point-handler n-point-handler)
  `(progn
     (defmethod (%screen-specific-two-point-graphics ,type)
		(sheet screen-type default-function screen-function &rest args)
       (unless (and (eq screen-type ',type)
		    (apply #',two-point-handler sheet screen-function args))
	 (apply default-function sheet args)))
     (defmethod (%screen-specific-n-point-graphics ,type)
		(sheet screen-type default-function screen-function &rest args)
       (unless (and (eq screen-type ',type)
		    (apply #',n-point-handler sheet screen-function args))
	 (apply default-function sheet args)))))

(defmacro screen-specific-graphics (&key type
				    (stream 'stream)
				    (drawing-state `(get-drawing-state ,stream))
				    default-function (default-arguments nil)
				    (default-drawing-arguments nil)
				    screen-function (screen-arguments nil)
				    argument-type point-arguments (transform-points t)
				    alu bounding-box refined-position-test refined-box
				    other-arguments)
  (let ((n-point-p (member argument-type '(:n-point :n-point-closed))))
    `(,(if n-point-p 'with-data-stack 'progn)
      (when ,transform-points
	,(if n-point-p
	     `(setf ,(first point-arguments)
		    (transform-and-fix-point-set-internal
		      (drawing-state-transform ,drawing-state)
		      ,(first point-arguments)
		      ,(eq argument-type :n-point-closed)))
	     `(transform-and-fix-points-internal
		(drawing-state-transform ,drawing-state)
		. ,point-arguments)))
      (let ,(if n-point-p
		`((left (elt ,(first point-arguments) 0))
		  (top (elt ,(first point-arguments) 1)))
		`((left ,(first point-arguments))
		  (top ,(second point-arguments))))
	(multiple-value-bind (bleft btop bright bbottom)
	    ,bounding-box
	  (stack-let ((bounding-box (list (- (min bleft bright) left)
					  (- (min btop bbottom) top)
					  (- (max bleft bright) left)
					  (- (max btop bbottom) top))))
	    (,(if n-point-p
		  'graphics::screen-specific-n-point-graphics
		  (ecase argument-type
		    (:two-point 'graphics::screen-specific-two-point-graphics)))
	     ,stream ,type
	     #'(lambda (,stream ,@point-arguments alu bounding-box refined-position-test
			refined-box ,@screen-arguments &rest more-args)
		 (ignore bounding-box refined-position-test refined-box)
		 (stack-let ((all-args (list* ,@point-arguments more-args))
			     (def-args (list ,@default-arguments)))
		   (apply #'screen-specific-default-handler-1 ,stream ,default-function
			  (append all-args def-args) :alu alu . ,default-drawing-arguments)))
	     ,screen-function
	     ,@point-arguments ,alu
	     bounding-box
	     ,(when refined-position-test
		`#'(lambda (,@(first refined-position-test) ,@point-arguments)
		     . ,(rest refined-position-test)))
	     ,(when refined-box
		`#'(lambda ,point-arguments ,refined-box))
	     ,@screen-arguments ,@other-arguments)))))))

(defun screen-specific-default-handler-1 (stream function function-args &rest drawing-args)
  (graphics:with-graphics-identity-transform (stream)
    (progn	;--- standard state too
      (apply #'with-drawing-state-internal stream function stream function-args
	     drawing-args))))


;;;; Essential methods on graphics flavors

(defun graphics-stream-p (stream)
  (send-if-handles stream :graphics-stream-p))

(defmethod (:graphics-stream-p standard-graphics-mixin) () t)

(defmethod (:graphics-stream-p dw::encapsulating-output-stream) ()
  (graphics-stream-p dw::stream))

;;; Call 1function0 with x,y and last-point-p for a sequence of points are alternating x and y.
(defun map-points (function points)
  (declare (downward-funarg function))
  (etypecase points
    (list
      (loop for (x y . rest) on points by 'cddr do
	(funcall function x y (null rest))))
    (vector
      (let ((length (sys:array-active-length points)))
	(loop for i below length by 2 do
	  (funcall function (aref points i) (aref points (1+ i)) (= i (- length 2))))))))

;;; Useful macro that accounts for different coordinate system and axes in windows.
;;; Perform 1body0 with the axes so that y points up and 0,0 is the bottom of the graphics
;;; area.  1height0 is the amount of vertical room required.  The stream cursor is positioned
;;; after the output area when done.
(defmacro with-room-for-graphics ((&optional stream height
				   &rest options)
				  &body body)
  (declare (arglist (&optional stream height &key (fresh-line t) (move-cursor t))
		    &body body))
  (dw::format-output-macro-default-stream stream)
  `(with-room-for-graphics-internal
     (dw::named-continuation with-room-for-graphics (,stream) . ,body)
     ,stream ,height ,@options))

(defun with-room-for-graphics-internal (continuation stream height &rest args
					&key (fresh-line t) &allow-other-keys)
  (declare (downward-funarg continuation))
  (if (not (equal (graphics:stream-transform stream) *identity-transform*))
      (funcall continuation stream)
      (when (null height)
	(multiple-value-bind (nil nil nil nil nil top)
	    (dw:continuation-output-size
	      #'(lambda (stream)
		  (with-graphics-transform (stream (list 1 0 0 -1 1000 1000))
		    (funcall continuation stream)))
	      stream)
	  (setq height (- 1000 top))))
      (when fresh-line (send-if-handles stream :fresh-line))
      (si:with-rem-keywords (new-args args '(:fresh-line))
	(apply #'with-room-for-graphics-internal-1
	       (si:follow-syn-stream stream) continuation stream height new-args))))

(defmethod (with-room-for-graphics-internal-1 standard-graphics-mixin)
	   (continuation stream height &rest options)
  (ignore height options)
  (funcall continuation stream))

(defun tv-with-room-for-graphics-internal-1 (continuation stream height
					     &key (fresh-line t) (move-cursor t))
  (ignore fresh-line)
  (multiple-value-bind (x y)
      (send stream :read-cursorpos)
    (incf y height)
    (when move-cursor
      ;; Glitch the screen to get end position visible first.
      (dw:with-output-truncation (stream)	;Really go there, don't limit to inside.
	(send stream :set-cursorpos x (ceiling y)))
      (send stream :increment-cursorpos 0 0))	;Handle exceptions.
    (multiple-value-prog1
      (with-graphics-transform (stream (list 1 0 0 -1 x y))
	(funcall continuation stream))
      (when move-cursor
	(send stream :increment-cursorpos 0 (send stream :line-height))))))

;;; Should already be the upside down variety by this point.
(defmethod (with-room-for-graphics-internal-1 dw::encapsulating-output-stream) (&rest args)
  (apply #'tv-with-room-for-graphics-internal-1 args))

(defmethod (with-room-for-graphics-internal-1 tv:graphics-mixin) (&rest args)
  (apply #'tv-with-room-for-graphics-internal-1 args))

(defmacro formatting-graphics-cell ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream &key (align-x :left) (align-y :bottom) (float-origin t)
			       dont-snapshot-variables)
		    &body body))
  (dw:format-output-macro-default-stream stream)
  `(formatting-graphics-cell-internal
     ,stream
     (dw:format-output-macro-continuation (:name formatting-graphics-cell
					   :dont-snapshot-variables
					   ,(dw::option-remf options :dont-snapshot-variables))
					  (,stream)
       . ,body)
     . ,options))

(defun formatting-graphics-cell-internal (stream continuation
					  &key (align-x :left) (align-y :bottom)
					       (float-origin t))
  (send-if-handles stream :check-set-cursorpos-simulating-stream-no-cursor-back :graphics)
  (multiple-value-bind (right bottom nil nil left top)
      (dw:continuation-output-size
	#'(lambda (stream)
	    (with-graphics-transform (stream (list 1 0 0 -1 1000 1000))
	      (funcall continuation stream)))
	stream)
    (setq left (- (or left right) 1000)
	  top (- (or top bottom) 1000)
	  right (- right 1000)
	  bottom (- bottom 1000))
    (formatting-cell (stream :align-x align-x :align-y align-y)
      (with-room-for-graphics (stream 0 :fresh-line nil :move-cursor nil)
	(if float-origin
	    (with-graphics-translation (stream (- left) (+ top))
	      (funcall continuation stream))
	    (funcall continuation stream)))
      (send stream :increment-cursorpos (- right left) (- bottom top)))))

(defmacro with-output-as-graphics-presentation ((&optional stream &rest args) &body body)
  `(dw:with-output-as-presentation (:stream ,stream . ,args)
     . ,body))

(defmacro with-graphics-subroutine ((&optional (stream '*standard-output*)
				     &rest special-variable-arguments)
				    &body body &environment environment)
  (let ((all-vars
	  (remove 'self
		  (cons stream
			(append special-variable-arguments
				(lt::form-free-variables-and-symbol-macros
				  `#'(sys:named-lambda with-graphics-subroutine
						       (,stream . ,special-variable-arguments)
				       . ,body) environment))))))
    `(with-graphics-subroutine-internal ,stream
					#'(sys:named-lambda with-graphics-subroutine
							    ,all-vars . ,body)
					. ,all-vars)))

(defgeneric with-graphics-subroutine-internal (stream continuation xstream &rest args)
  (:function (apply (flavor:generic with-graphics-subroutine-internal)
		    (si:follow-syn-stream stream)
		    continuation xstream args))
  (:method (standard-graphics-mixin) (apply continuation xstream args)))

(defmethod (with-graphics-subroutine-internal dw::encapsulating-output-stream)
	   (continuation xstream &rest args)
  (apply (flavor:generic with-graphics-subroutine-internal)
	 (si:follow-syn-stream dw::stream) continuation xstream args))

;;;; Drawing state

(defmethod (get-drawing-state drawing-state-graphics-mixin) ()
  (or drawing-state (setq drawing-state (make-new-drawing-state self))))

(defmethod (make-new-drawing-state drawing-state-graphics-mixin) () (make-drawing-state))

(defmethod (stream-transform drawing-state-graphics-mixin) ()
  (drawing-state-transform (get-drawing-state self)))

(defmethod (with-new-stream-transform drawing-state) (new-transform continuation xstream)
  (letf ((transform new-transform)
	 (flags (dpb -1 %%drawing-state-new-transform flags)))
    (funcall continuation xstream)))

(defmethod (with-new-stream-transform drawing-state-graphics-mixin)
	   (transform continuation xstream)
  (with-new-stream-transform (get-drawing-state self) transform continuation xstream))

(defvar *default-scan-conversion-flags* 0)

(defun get-drawing-state-scan-conversion-flags (drawing-state)
  (or (drawing-state-scan-conversion-flags drawing-state)
      *default-scan-conversion-flags*))

(defun set-default-scan-conversion-mode (&rest args)
  (declare (arglist &key round-coordinates center-circles host-allowed sketch))
  (setq *default-scan-conversion-flags* (apply #'set-scan-conversion-mode-internal
					       *default-scan-conversion-flags*
					       args))
  (let ((on (not (ldb-test %%scan-conversion-host-allowed *default-scan-conversion-flags*))))
    (dolist (screen tv:all-the-screens)		;--- cold load implications?
      (setf (tv:screen-genera-graphics-compatibility screen) on))))

(defun set-scan-conversion-mode (stream &rest args)
  (declare (arglist stream &key round-coordinates center-circles host-allowed sketch))
  (let ((drawing-state (get-drawing-state (si:follow-syn-stream stream))))
    (setf (drawing-state-scan-conversion-flags drawing-state)
	  (apply #'set-scan-conversion-mode-internal
		 (drawing-state-scan-conversion-flags drawing-state) args))))

(defun set-scan-conversion-mode-internal (scan-conversion-flags
					  &key round-coordinates center-circles host-allowed
					       (sketch nil sketch-p)
					  &allow-other-keys)
  (unless scan-conversion-flags
    (setq scan-conversion-flags *default-scan-conversion-flags*))
  (when sketch-p
    (setq round-coordinates sketch
	  host-allowed sketch))
  (setf (ldb-test %%scan-conversion-round-coordinates
		  scan-conversion-flags) round-coordinates
	(ldb-test %%scan-conversion-center-circles
		  scan-conversion-flags) center-circles
	(ldb-test %%scan-conversion-host-allowed
		  scan-conversion-flags) host-allowed)
  scan-conversion-flags)

(set-default-scan-conversion-mode :sketch t)	;Establish default state

(defun scan-conversion-mode-option (default-p default &rest accept-args)
  (let* ((no-sketch 0)
	 (sketch (set-scan-conversion-mode-internal no-sketch :sketch t)))
    (apply #'accept `((token-or-type (("Fast" . ,sketch)
				      ("Accurate" . ,no-sketch)
				      . ,(when default-p
					   '(("Default" . nil))))
				     ((integer) :description "Specific flag mask")))
	   :default default accept-args)))

(defmacro with-scan-conversion-mode ((stream &rest options) &body body)
  (declare (arglist (stream &key round-coordinates center-circles host-allowed sketch) &body body))
  (dw::format-output-macro-default-stream stream)
  `(with-scan-conversion-mode-internal-0
     (dw:named-continuation with-scan-conversion-mode (,stream) . ,body)
     ,stream . ,options))

(defun with-scan-conversion-mode-internal-0 (continuation xstream &rest options)
  (declare (downward-funarg continuation))
  (apply #'with-scan-conversion-mode-internal (si:follow-syn-stream xstream)
	 continuation xstream options))

(defmethod (with-scan-conversion-mode-internal drawing-state-graphics-mixin) (&rest args)
  (apply #'with-scan-conversion-mode-internal (get-drawing-state self) args))

(defmethod (with-scan-conversion-mode-internal dw::encapsulating-output-stream) (&rest args)
  (apply #'with-scan-conversion-mode-internal (si:follow-syn-stream dw::stream) args))

;;; If sizing pass, alter our own state, else affect what gets output.
(defmethod (with-scan-conversion-mode-internal dw::redisplay-helper-stream) (&rest args)
  (apply #'with-scan-conversion-mode-internal
	 (if (eq dw::state :displaying)
	     (si:follow-syn-stream dw::stream)
	     (get-drawing-state self))
	 args))

(defmethod (with-scan-conversion-mode-internal drawing-state)
	   (continuation xstream &rest args)
  ;; Could set a changed flag bit if it made a difference.
  (letf ((scan-conversion-flags (apply #'set-scan-conversion-mode-internal
				       scan-conversion-flags args)))
    (funcall continuation xstream)))

;;; Compatibility
(defmacro with-coordinate-mode ((stream mode) &body body)
  (dw::format-output-macro-default-stream stream)
  (let ((args (cdr (assoc mode '((:exact :round-coordinates nil :center-circles nil)
				 (:integer :round-coordinates t :center-circles nil)
				 (:center :round-coordinates t :center-circles t))))))
    (if args
	`(with-scan-conversion-mode (,stream . ,args) . ,body)
	;; Not known until runtime
	`(with-coordinate-mode-internal-0
	   (dw:named-continuation with-coordinate-mode (,stream) . ,body)
	   ,stream ,mode))))

(defun (compiler:style-checker compiler:make-obsolete with-coordinate-mode) (form)
  (destructuring-bind (nil (stream mode) &body ignore) form
    (let ((args (cdr (assoc mode '((:exact :round-coordinates nil :center-circles nil)
				   (:integer :round-coordinates t :center-circles nil)
				   (:center :round-coordinates t :center-circles t))))))
      (if args
	  (warn `(:obsolete t)
		"(~S ~S ...) is obsolete.
Use (~S ~S ...) instead."
		'with-coordinate-mode (list stream mode)
		'with-scan-conversion-mode (cons stream args))
	  (warn `(:obsolete t)
		"~S is obsolete.  Use ~S instead."
		'with-coordinate-mode 'with-scan-conversion-mode)))))

(defun with-coordinate-mode-internal-0 (continuation stream mode)
  (inhibit-style-warnings
    (ecase mode
      (:exact
	(with-scan-conversion-mode (stream :round-coordinates nil :center-circles nil) 
	  (funcall continuation stream)))
      (:integer
	(with-scan-conversion-mode (stream :round-coordinates t :center-circles nil)
	  (funcall continuation stream)))
      (:center
	(with-scan-conversion-mode (stream :round-coordinates t :center-circles t)
	  (funcall continuation stream))))))

(defmacro with-drawing-state ((stream &rest args) &body body)
  (dw::format-output-macro-default-stream stream)
  `(with-drawing-state-internal-0
     (dw:named-continuation with-drawing-state (,stream) . ,body)
     ,stream . ,args))

(eval-when (eval load compile)
(defparameter *drawing-state-arguments*
  '(thickness scale-thickness line-end-shape line-joint-shape dashed
    dash-pattern initial-dash-phase draw-partial-dashes scale-dashes alu
    pattern stipple tile gray-level color opaque))
(defparameter *drawing-state-argument-keywords*
  (map 'list #'(lambda (x) (intern (symbol-name x) "")) *drawing-state-arguments*))
  
)

(defun with-drawing-state-internal-0 (continuation xstream &rest args)
  (si:validate-keywords-internal *drawing-state-argument-keywords* args)
  (apply #'with-drawing-state-internal (si:follow-syn-stream xstream)
				       continuation xstream nil args))

(defmethod (with-drawing-state-internal drawing-state-graphics-mixin) (&rest args)
  (apply #'with-drawing-state-internal (get-drawing-state self) args))

(defmethod (with-drawing-state-internal dw::encapsulating-output-stream) (&rest args)
  (apply #'with-drawing-state-internal (si:follow-syn-stream dw::stream) args))

;;; If sizing pass, alter our own state, else affect what gets output.
(defmethod (with-drawing-state-internal dw::redisplay-helper-stream) (&rest args)
  (apply #'with-drawing-state-internal
	 (if (eq dw::state :displaying)
	     (si:follow-syn-stream dw::stream)
	     (get-drawing-state self))
	 args))

(defmethod (with-drawing-state-internal drawing-state)
	   (continuation xstream other-continuation-args &rest args)
  (let ((last-pattern-instance nil)
	(next-pattern-instance nil))
    (labels ((do-bindings (&rest args)
	       (declare (downward-function))
	       (%with-binding-stack-level
		 (unless next-pattern-instance	;i.e. recursive
		   (%bind-location (locf flags)
				   (dpb -1 %%drawing-state-new-parameters flags)))
		 (setq last-pattern-instance next-pattern-instance
		       next-pattern-instance nil)
		 ;; In order to preserve &key precedence order semantics, we have to read
		 ;; the value again for each known keyword, to make sure we have the first
		 ;; occurrence in the list.
		 (loop for (keyword) on args by 'cddr as value = (getf args keyword) doing
		   (when (eq keyword :pattern)
		     (etypecase value
		       ;; Some data types are synonyms for the corresponding data patterns.
		       (array (setq keyword :stipple))
		       (color:color (setq keyword :color))
		       ;; For compatibility, :pattern t means all ones.
		       (boolean (setq value nil))
		       (basic-pattern
			 ;; If the same as last time, bind the pattern instance variable
			 ;; to the instance, giving it control of the device specific
			 ;; means of resolving things.  Otherwise, bind pattern to nil, in
			 ;; case there was one before, and remember to give new instance a
			 ;; chance to specify parameters right now.
			 (unless (eq value last-pattern-instance)
			   (setq next-pattern-instance value
				 value nil)))))
		   (macrolet ((bind-it ()
				`(case keyword
				   . ,(loop for name in *drawing-state-arguments*
					    collect `(,(intern (symbol-name name) "")
						      (%bind-location (locf ,name)
								      value))))))
		     (bind-it)))
		 (if next-pattern-instance
		     (pattern-call-with-drawing-parameters next-pattern-instance
							   #'do-bindings xstream self)
		     (apply continuation xstream other-continuation-args)))))
      (apply #'do-bindings args))))

;;; Should be used to get the stroke thickness by any method that needs it.
(defun-in-flavor (standardize-thickness drawing-state-graphics-mixin) ()
  (declare (values x-thickness/2 y-thickness/2))
  (multiple-value-bind (x-thickness y-thickness)
      (drawing-state-scaled-thickness (get-drawing-state self))
    (if (and (< x-thickness 1) (< y-thickness 1))
	;; 0 is the thinnest line that can be displayed.
	(values 0 0)
	(values (/ x-thickness (if (and (integerp x-thickness) (evenp x-thickness)) 2 2.0))
		(/ y-thickness (if (and (integerp y-thickness) (evenp y-thickness)) 2 2.0))))))

(defmethod (drawing-state-scaled-thickness drawing-state) ()
  (if (or (not scale-thickness) (null thickness) (zerop thickness))
      (let ((thick (or thickness 0)))
	(values thick thick))
      ;; Construct a basis which is rectilinear in device space and whose components
      ;; have the correct length in user space.
      (destructuring-bind (a b c d nil nil) transform
	(if (and (= b 0) (= c 0))
	    ;; A simple scaling without additional rotation.
	    (values (abs (* thickness a))
		    (abs (* thickness d)))
	    (values (multiple-value-bind (dx dy)
			(untransform-distance 1 0 transform)
		      (let ((length (sqrt (+ (expt dx 2) (expt dy 2)))))
			(if (< (abs (1- length)) 1e-6)
			    thickness		;Was rotated, but not actually scaled.
			    (let ((scale (/ thickness length)))
			      (multiple-value-bind (dx dy)
				  (transform-distance (* dx scale) (* dy scale) transform)
				;; Temporary check that not losing greatly.
				(assert (and (< (abs dy) 1e-6) ( dx 0)))
				dx)))))
		    (multiple-value-bind (dx dy)
			(untransform-distance 0 1 transform)
		      (let ((length (sqrt (+ (expt dx 2) (expt dy 2)))))
			(if (< (abs (1- length)) 1e-6)
			    thickness
			    (let ((scale (/ thickness length)))
			      (multiple-value-bind (dx dy)
				  (transform-distance (* dx scale) (* dy scale) transform)
				(assert (and (< (abs dx) 1e-6) ( dy 0)))
				dy))))))))))

;;; Must be called from within a with-data-stack.
(defmethod (drawing-state-scaled-dash-pattern drawing-state) ()
  (declare (values dashed dash-pattern dash-phase literal-p))
  (when dashed
    (let ((pattern dash-pattern)
	  (phase initial-dash-phase))
      (when scale-dashes
	(setq pattern (make-stack-array (length pattern) :initial-contents pattern))
	(let ((scale (multiple-value-bind (nil x-scale y-scale)
			 (decompose-transform transform)
		       (max (abs x-scale) (abs y-scale)))))
	  (dotimes (i (length pattern))
	    (setf (elt pattern i) (max 1 (* scale (elt pattern i)))))
	  (setq phase (* phase scale))))
      (values t
	      pattern
	      (round phase)
	      draw-partial-dashes))))

(defmethod (drawing-state-line-shapes drawing-state) ()
  (values line-end-shape line-joint-shape))

(defmethod (drawing-state-initialize drawing-state)
	   (&optional (new-transform *identity-transform*))
  (replace transform new-transform)
  (setq flags (if (eq new-transform *identity-transform*) 0
		  ;; Suppress optimized drawing functions.
		  (dpb -1 %%drawing-state-transform-modified 0))
	thickness nil
	scale-thickness t
	line-end-shape :butt
	line-joint-shape :miter
	dashed nil
	dash-pattern #(10 10)
	initial-dash-phase 0
	draw-partial-dashes t
	scale-dashes nil
	alu :draw
	pattern t
	stipple nil
	tile nil
	gray-level 1
	color nil
	opaque t
	scan-conversion-flags nil
	))

;;;; Operation definition

(eval-when (eval load compile)

(defprop define-graphics-generic defun zwei:definition-function-spec-type)

;;; A list of arguments standardly available for a graphics operation.
;;; Each element of a list of (type inherited-types . own-args).
;;; Own args are lists of (name default type).
(defvar *standard-additional-arguments*
  '((:lines ()
      (thickness nil number)
      (scale-thickness t boolean)
      (line-end-shape :butt ((member :butt :square :round :no-end-point)))
      (line-joint-shape :miter ((member :miter :bevel :round :none)))
      (dashed nil boolean) (dash-pattern #(10 10) dash-pattern)
      (initial-dash-phase 0 integer)
      (draw-partial-dashes t boolean) (scale-dashes nil boolean))
    (:outline (:lines) (filled t boolean))
    ))

(defun standard-additional-arguments (type)
  (let ((elem (assoc type *standard-additional-arguments*)))
    (assert (not (null elem)) (elem) "~S is not a known standard argument type" type)
    (let ((arguments (rest (rest elem))))
      (loop for inherit in (second elem) do
	(setq arguments (append arguments (standard-additional-arguments inherit))))
      arguments)))

)

;;; Note that when encoded in character files, the lower numbers take half as much room,
;;; so they are to be preferred.

;;Next available operation opcode is 28
(defvar *binary-graphics-operation-opcodes* (make-array 256))
;;Next available command opcode is 73
(defvar *binary-graphics-command-opcodes* (make-array 256))

(defun register-binary-graphics-command (name opcode)
  (when (aref *binary-graphics-operation-opcodes* opcode)
    (warn () "The command ~S is also an operation ~S as ~D.  ~
This isn't likely to work." name (aref *binary-graphics-operation-opcodes* opcode) opcode))
  (let ((old (aref *binary-graphics-command-opcodes* opcode)))
    (unless (eq old name)
      (unless (null old)
	(warn () "The command ~S is being installed in place of ~S as ~D.  ~
This is likely to break existing files." name opcode old))
      (setf (aref *binary-graphics-command-opcodes* opcode) name))))

(defun register-binary-graphics-operation (name opcode)
  (when (aref *binary-graphics-command-opcodes* opcode)
    (warn () "The operation ~S is also an command ~S as ~D.  ~
This isn't likely to work." name (aref *binary-graphics-command-opcodes* opcode) opcode))
  (let ((old (aref *binary-graphics-operation-opcodes* opcode)))
    (unless (eq old name)
      (unless (null old)
	(warn () "The operation ~S is being installed in place of ~S as ~D.  ~
This is likely to break existing files." name opcode old))
      (setf (aref *binary-graphics-operation-opcodes* opcode) name))))

(defun register-graphics-generic (name &key binary-opcode)
  (pushnew name (getf (flavor::flavor-plist (flavor:find-flavor 'standard-graphics-mixin))
		      :required-methods))
  (when binary-opcode
    (register-binary-graphics-operation name binary-opcode)))

;;; Note that the various transformation possibilities are applied in the standard
;;; arglist order, not the order you give them in.  As a matter of
;;; style, I'd think that giving more than one in a single function is
;;; going to confuse.

;;; The keyword rest arg is separated in the whole argument list by an arbitrary number of
;;; position args.  Hence the two-rest arg problem.  One at compile time, one at runtime.
(defmacro apply-graphics-generic (generic stream keyword-args &rest pos-args)
  `(flet ((do-it (,stream &rest some-args)
	    (apply (flavor:generic ,generic) ,stream ,@pos-args some-args)))
     (apply #'apply-graphics-generic-internal #'do-it ,stream ,keyword-args)))

(eval-when (eval load compile)
(defparameter *apply-graphics-generic-argument-keywords*
  `(:rotation :scale :scale-x :scale-y :translation :transform
    :mask :mask-x :mask-y
    :stream :return-presentation
    . ,*drawing-state-argument-keywords*))
)

(defun apply-graphics-generic-internal (continuation stream
					&rest args
					&key (return-presentation nil)
					     (rotation 0)
					     (scale 1)
					     (scale-x 1)
					     (scale-y 1)
					     (translation nil)
					     (transform nil)
					     (mask nil) (mask-x 0) (mask-y 0)
					&allow-other-keys)
  (declare (downward-funarg continuation))
  (setq stream (si:follow-syn-stream stream))
  (when (null args)
    (return-from apply-graphics-generic-internal
      (funcall continuation stream)))
  (saving-graphics-transform (stream)
    (when transform
      (stream-compose-transforms stream transform))
    (when translation
      (graphics-translate (first translation) (second translation) :stream stream))
    (unless (zerop rotation)
      (graphics-rotate rotation :stream stream))
    (unless (and (= scale 1) (= scale-x 1) (= scale-y 1) )
      (graphics-scale (* scale scale-x) (* scale scale-y) :stream stream))
    (si:with-rem-keywords (some-args args *apply-graphics-generic-argument-keywords*)
      (macrolet ((do-it ()
		   `(do-it-0))
		 (do-it-0 ()
		   `(if mask
			(with-clipping-mask (stream mask :left mask-x :top mask-y)
			  (apply #'with-drawing-state-internal stream
				 continuation stream some-args args))
			(apply #'with-drawing-state-internal stream
			       continuation stream some-args args))))
      (if return-presentation
	  (with-output-as-graphics-presentation (stream)
	    (do-it))
	  (do-it))))))

;;; Define a 1graphics:draw-0xxx generic function.  1arglist0 is the operation specific argument
;;; list.  Possible options are:
;;;  (1:standard-arguments0 . types)
;;;  (1:default-method 0. handler for 1standard-graphics-mixin0)
;;;  (1:binary-opcode0 op)
;;;  (1:argument-types0 . (type . names)...)
;;;  (1:new-path-position0 new-point-form)
;;;  (1:optimize0 . (into arglist)...)
;;;  (1:screen-method0 handler-name screen-handler-name)
(defmacro define-graphics-generic (name arglist &body options)
  (let ((pos-args arglist)
	(method-rest-arg (member '&rest arglist))
	(key-args (member '&key arglist))
	(allow-other-keys-arg (member '&allow-other-keys arglist))
	(automatic-key-args '((alu :draw)
			      (pattern nil) (stipple nil) (tile nil)
			      (color nil) (gray-level 1)
			      (opaque t)
			      (mask nil) (mask-x 0) (mask-y 0)
			      ))
	(argument-types nil)
	(binary-opcode nil) (binary-line-p nil)
	(new-path-position nil)
	(default-method nil)
	(screen-method nil)
	(optimizers nil)
	(obsolete-keywords nil)
	all-key-args method-automatic-key-args method-arglist)
    (when (or method-rest-arg key-args)
      (setq pos-args (ldiff pos-args (or method-rest-arg key-args))))
    (when (and method-rest-arg key-args)
      (setq method-rest-arg (ldiff method-rest-arg key-args)))
    (setq key-args (ldiff (rest key-args) allow-other-keys-arg))
    (loop for (key . rest) in options do
      (ecase key
	(:standard-arguments
	  (dolist (type rest)
	    (case type
	      (:lines
		(setq binary-line-p t))
	      (:outline
		(setq binary-line-p '(not (getf key-args :filled t)))))
	    (let ((standard (standard-additional-arguments type)))
	      (setq automatic-key-args
		    (append automatic-key-args
			    (loop for elem in standard
				  if (atom elem)
				    collect elem
				  else collect (list (first elem) (second elem))
				       and do
			      (unless (member (first elem)
					      *apply-graphics-generic-argument-keywords*
					      :test #'string=)
				(push (list (first elem)
					    (third elem))
				      argument-types))))))))
	(:argument-types
	  (loop for (type . args) in rest
		do (if (eq type 'point)
		       (loop for (x y) in args
			     do (push (list x 'point-x) argument-types)
				(push (list y 'point-y) argument-types))
		     (dw:check-presentation-type-argument type :evaluated nil)
		     (dolist (arg args)
		       (push (list arg type) argument-types)))))
	(:default-method
	  (setq default-method (or rest ''nil)))
	(:screen-method
	  (setq screen-method (or rest '(nil nil))))
	(:binary-opcode
	  (setq binary-opcode (first rest)))
	(:new-path-position
	  (setq new-path-position (first rest)))
	(:obsolete-keywords
	  (setq obsolete-keywords rest))
	(:optimize
	  (setq optimizers rest))))
    (setq all-key-args `(,@key-args
			 ,@automatic-key-args
			 (stream *standard-output*)
			 (return-presentation nil)
			 (rotation 0)
			 (scale 1)
			 (scale-x 1) (scale-y 1)
			 (translation nil)
			 (transform nil))
	  method-automatic-key-args
	    (loop for arg in automatic-key-args
		  unless (member (if (consp arg) (first arg) arg)
				 *apply-graphics-generic-argument-keywords*
				 :test #'string=)
		    collect arg)
	  method-arglist `(,@pos-args ,@method-rest-arg &key ,@key-args
							     ,@method-automatic-key-args
							,@(when allow-other-keys-arg
							    '(&allow-other-keys)))
	  argument-types (nreverse argument-types))
    `(progn
       (defgeneric ,name (,@pos-args &rest .args.
				     &key (stream *standard-output*)
				     &allow-other-keys)
	 (declare (arglist ,@pos-args &key ,@all-key-args ,@(when allow-other-keys-arg
							      '(&allow-other-keys)))
		  (compiler:arglist-types . ,argument-types))
	 (:function
	   ,@(loop for obsolete in obsolete-keywords
		   collect `(graphics-generic-process-obsolete-keyword .args. . ,obsolete))
	   ,(multiple-value-bind (valid)
		(loop for arg in all-key-args
		      collect (intern (symbol-name (if (consp arg) (first arg) arg)) ""))
	      (unless allow-other-keys-arg
		`(si:validate-keywords-internal ',valid .args.)))
	   (apply-graphics-generic ,name stream .args. . ,pos-args))
	 (:method-arglist . ,method-arglist))
       ,@(when (or default-method screen-method)
	   (let ((default-name (if screen-method
				   (or (second screen-method) (fintern "DEFAULT-~A" name))
				   name))
		 (default-flavor (if default-method
				     'standard-graphics-mixin
				     'raster-graphics-mixin)))
	     (append
	       (when screen-method
		 (setq screen-method (or (third screen-method) (fintern "%SCREEN-~A" name)))
		 `((defgeneric ,default-name (stream . ,method-arglist))
		   (defmethod (,name ,default-flavor) (&rest args)
		     (apply #',default-name self args))
		   (defmethod (,screen-method tv:basic-screen) (sheet &rest args)
		     (declare (function-parent ,name defun))
		     (apply #',default-name sheet args))
		   (defmethod (,name tv:graphics-mixin) (&rest args)
		     (apply #',screen-method tv:screen self args))))
	       (when default-method
		 `((defmethod (,default-name ,default-flavor)
			      (,@pos-args ,@method-rest-arg &key ,@key-args &allow-other-keys)
		     (declare (function-parent ,name defun))
		     . ,default-method))))))
       (defmethod (,name dw::new-coordinates-stream) (&rest args)
	 (apply #'pass-on-with-additional-translation (flavor:generic ,name) args))
       (defwhopper (,name dw::redisplay-helper-stream) (&rest args)
	 (if (eq dw::state :displaying)
	     ;; When displaying, let stream handle at high level.
	     (apply (flavor:generic ,name) (si:follow-syn-stream dw::stream) args)
	     ;; When sizing, use raster-graphics-mixin methods to get size right.
	     (lexpr-continue-whopper args)))
       ,(when binary-opcode
	  `(defmethod (,name binary-graphics-stream) (,@pos-args &rest key-args)
	     (binary-encode-graphics-operation ,name ,binary-opcode
					       :rest-arg-name key-args
					       :pos-args ,pos-args
					       :key-args (,@key-args
							  ,@method-automatic-key-args)
					       :argument-types ,argument-types
					       :new-path-position ,new-path-position
					       :line-p ,binary-line-p)))
       (register-graphics-generic ',name :binary-opcode ,binary-opcode)
       ,@(loop for obsolete in obsolete-keywords
	       collect `(define-graphics-obsolete-keyword-style-checker
			  ,name ,pos-args . ,obsolete))
       ,@(loop for (optimized-into arglist) in optimizers
	       collect `(define-graphics-optimizer ,name ,optimized-into ,arglist
						   ,pos-args ,all-key-args))
       )))

;;; When doing output, apply out additional offsets to the stream's CTM.
(defun-in-flavor (pass-on-with-additional-translation dw::new-coordinates-stream)
		 (generic &rest args)
  (saving-graphics-transform (dw::stream)
    (let ((transform (stream-transform dw::stream)))
      (incf (graphics-transform-tx transform) dw::x-offset)
      ;; Increment in desired direction of stream.
      ;; This test recognizes a dw::new-coordinates-stream or its encapsulation.
      ;; Too bad the only way to do it is so very slow (send-if-handles).
      (if (eql (send-if-handles dw::stream :real-set-cursorpos) :simulated-hardcopy)
	  (decf (graphics-transform-ty transform) dw::y-offset)
	  (incf (graphics-transform-ty transform) dw::y-offset))
      (apply generic (si:follow-syn-stream dw::stream) args))))

(defmacro graphics-generic-process-obsolete-keyword (rest-arg old-keywords &rest new-keywords)
  `(let ,(loop for old-keyword in old-keywords
	       collect `(,old-keyword (getf ,rest-arg ,(intern (symbol-name old-keyword) "")
					    (locf ,rest-arg))))
     (unless (and . ,(loop for old-keyword in old-keywords
			   collect `(eq ,old-keyword (locf ,rest-arg))))
       ,@(loop for old-keyword in old-keywords
	       collect `(when (eq ,old-keyword (locf ,rest-arg))
			  (setq ,old-keyword nil)))
       (setq ,rest-arg (list* ,@new-keywords :allow-other-keys t ,rest-arg)))))

(defmacro define-graphics-obsolete-keyword-style-checker
	  (function-name pos-args old-keywords &rest new-keywords)
  `(defun (compiler:style-checker ,(dw::fintern "GRAPHICS-OBSOLETE-KEYWORD-STYLE-CHECKER-~A"
						(first old-keywords))
				  ,function-name)
	  (form)
     (graphics-obsolete-keyword-style-checker-internal form
						       ',function-name ,(1+ (length pos-args))
						       ',old-keywords ',new-keywords)))

(defun graphics-obsolete-keyword-style-checker-internal
       (form function-name n-pos-args old-keywords new-keywords)
  (multiple-value-bind (bad-keywords bad-variables bad-values)
      (loop for (keyword value) on (nthcdr n-pos-args form) by 'cddr
	    as tem = (find keyword old-keywords :test #'string=)
	    when (and tem (not (member keyword bad-keywords)))
	      collect keyword into bad-keywords
	      and collect tem into bad-variables
	      and collect value into bad-values
	    finally (return (values bad-keywords bad-variables bad-values)))
    (when bad-keywords
      (let ((old-subform (loop for keyword in bad-keywords
			       for value in bad-values
			       collect keyword collect value))
	    (new-subform (copy-tree new-keywords)))
	(loop for unseen in old-keywords
	      unless (member unseen bad-keywords :test #'string=)
		do (push nil bad-values)
		   (push unseen bad-variables))
	(setq new-subform (lt:let-subst bad-variables bad-values new-subform))
	(when (loop for (nil value) on old-subform by 'cddr
		    always (and (atom value) (constantp value)))
	  (block error
	    (ignore-errors
	      (setq new-subform (loop for (keyword value) on new-subform by 'cddr
				      collect keyword
				      collect (let ((value (eval value)))
						(when (or (instancep value)
							  (and (arrayp value)
							       (not (stringp value))))
						  (return-from error))
						(if (and (atom value) (constantp value))
						    value
						    `',value)))))))
	(warn () "~{~S~^ ~} ~:[is an~;are~] obsolete keyword~P to ~S.
It should be replaced by ~{~S~^ ~}"
	      old-subform (> (length bad-keywords) 1) (length bad-keywords) function-name
	      new-subform)))))

(defmacro define-graphics-optimizer (name optimized-into arglist pos-args key-args)
  (assert (and (eq (car arglist) 'stream)
	       (loop for pos-arg in pos-args
		     for opt-arg in (rest arglist)
		     always (eq pos-arg opt-arg)))
	  ()
	  "The first argument must be stream ~
and the following arguments must be the positional ones.")
  (let ((optimizer-function (dw::fintern "~A-INTO-~A" name optimized-into))
	(unoptimized-function `((declare (notinline ,name))
				(,name ,@pos-args :stream self
				  . ,(loop for arg in (nthcdr (1+ (length pos-args)) arglist)
					   collect (intern (symbol-name arg) "")
					   collect arg)))))
    `(progn
       (defgeneric ,optimized-into (stream &rest args)
	 (:method-arglist . ,(rest arglist))
	 (:method (standard-graphics-mixin) . ,unoptimized-function)
	 (:method (dw::encapsulating-output-stream) . ,unoptimized-function)
	 (:function
	   (apply (flavor:generic ,optimized-into) (si:follow-syn-stream stream) args)))
       (defun ,optimizer-function (form)
	 (graphics-optimizer-internal form ',name ',optimized-into
				      ',arglist ',pos-args ',key-args))
       (compiler:add-optimizer ,name ,optimizer-function ,optimized-into))))

(defun graphics-optimizer-internal (form name optimized-into arglist pos-args key-args)
  (let ((original-form form)
	(vars nil)
	(vals nil))
    (flet ((fail ()
	     (return-from graphics-optimizer-internal original-form))
	   (find-keyword-entry (arg)
	     (dolist (entry key-args)
	       (when (string= arg (if (consp entry) (first entry) entry))
		 (return (if (consp entry) entry (list entry ''nil))))))
	   (next-arg (name value)
	     (push name vars)
	     (push value vals)))
      (unless (eql (pop form) name)
	(fail))
      (loop while pos-args do
	(when (null form)
	  (fail))
	(next-arg (pop pos-args) (pop form)))
      (loop while form do
	(let ((keyword (pop form)))
	  (unless (keywordp keyword)
	    (fail))
	  (unless form
	    (fail))
	  (let ((arg-name (find keyword arglist :test #'string=)))
	    (if (null arg-name)
		(let ((form-given (pop form))
		      (keyword-entry (find-keyword-entry keyword)))
		  (unless (and keyword-entry
			       (compiler:constant-form-p form-given)
			       (compiler:constant-form-p (second keyword-entry))
			       (eql (compiler:constant-evaluator form-given)
				    (compiler:constant-evaluator (second keyword-entry))))
		    (fail)))
		(when (member arg-name vars)	;Duplicate keywords
		  (fail))
		(next-arg arg-name (pop form))))))
      (dolist (arg arglist)
	(unless (member arg vars)
	  (let ((keyword-entry (find-keyword-entry arg)))
	    (unless keyword-entry
	      (fail))
	    (next-arg arg (second keyword-entry)))))
      (lt:let-subst (nreverse vars) (nreverse vals)
		    (cons optimized-into arglist)))))

(defun decode-point-relative-graphics-form (point-arglist forms &key environment)
  (declare (values function points relative-ps
		   additional-args additional-keywords drawing-keywords
		   free-vars))
  (when (and (= (length point-arglist) 2)
	     (= (length forms) 1))
    (block fail
      (let* ((form (first forms))
	     (function (pop form))	;1form0 is now all arguments to 1function
0	     (points nil)
	     (relative-ps nil)
	     (additional-args nil)
	     (other-free-vars nil))
	(multiple-value-bind (arglist nil type arglist-types nil)
	    (arglist function t)
	  (unless (and (null type) arglist-types)
	    (return-from fail nil))
	  (block collect
	    (lt:map-over-lambda-list arglist
	      #'(lambda (argform type)
		  (ecase type
		    ((:required :optional)
		     (when (null form)
		       (if (eq type :required)
			   (return-from fail nil)	;not enough required args supplied
			   (return-from collect)))	;done
		     (let* ((arg (if (atom argform) argform (first argform)))
			    (type (second (assoc arg arglist-types)))
			    (subform (pop form))
			    (free-vars
			      (lt::form-free-variables-and-symbol-macros form environment)))
		       (let ((point-free-vars (intersection free-vars point-arglist)))
			 (setq other-free-vars (union other-free-vars
						      (set-difference free-vars
								      point-free-vars)))
			 (flet ((do-subform (subform point-free-vars type)
				  (cond ((null point-free-vars)
					 ;; Drawing a constant point
					 (push subform points)
					 (push nil relative-ps))
					((and (null (rest point-free-vars))
					      (eq (first point-free-vars)
						  (if (eq type 'point-x)
						      (first point-arglist)
						      (second point-arglist))))
					 ;; Drawing some form of X or Y
					 (cond ((atom subform)
						;; Drawing exactly X or Y
						(push 0 points)
						(push t relative-ps))
					       ((and (member (first subform) '(+ -))
						     (eq (second subform)
							 (first point-free-vars)))
						;; Drawing an offset from X or Y
						(let* ((rest-form (cons (first subform)
									(rest (rest subform))
									))
						       (free-vars
							 (lt::form-free-variables-and-symbol-macros
							   rest-form environment)))
						  (unless (null (intersection free-vars
									      point-arglist
									      ))
						    (return-from fail nil))
						  (push rest-form points)
						  (push t relative-ps)))
					       (t
						;; Couldn't figure it out
						(return-from fail nil))))
					(t
					 (return-from fail nil)))))
			   (case type
			     (point-sequence
			       (unless (member (first subform) '(list vector))
				 (return-from fail nil))
			       (loop for subsubform in (rest subform)
				     for type = 'point-x then (if (eq type 'point-x)
								  'point-y 'point-x)
				     do (do-subform
					  subsubform
					  (intersection
					    (lt::form-free-variables-and-symbol-macros
					      subsubform environment)
					    point-arglist)
					  type)))
			     ((point-x point-y)
			      (do-subform subform point-free-vars type))
			     (otherwise
			       (if (null point-free-vars)
				   (push subform additional-args)
				   (return-from fail nil))))))))
		    ((:rest :key)
		     (return-from collect))))))
	  (setq points (nreverse points)
		relative-ps (coerce (nreverse relative-ps) '(vector boolean))
		additional-args (nreverse additional-args))
	  (multiple-value-bind (additional-keywords drawing-keywords)
	      (loop for (keyword value) on form by 'cddr
		    do (unless (keywordp keyword)
			 (return-from fail nil))
		       (let ((free-vars
			       (lt::form-free-variables-and-symbol-macros value environment)))
			 (unless (null (intersection free-vars point-arglist))
			   (return-from fail nil))
			 (setq other-free-vars (union other-free-vars free-vars)))
		    when (member keyword *drawing-state-argument-keywords*)
		      collect keyword into drawing-keywords
		      and collect value into drawing-keywords
		    else
		      collect keyword into additional-keywords
		      and collect value into additional-keywords
		    finally
		      (return (values additional-keywords drawing-keywords)))
	    (values function points relative-ps additional-args
		    additional-keywords drawing-keywords
		    other-free-vars)))))))

;;;; The actual operations

;;; Change pixel at 1x0,1y0 to 1new-value0 with specified alu.
(define-graphics-generic draw-point (x y)
  (:argument-types (point (x y)))
  (:binary-opcode 1)
  (:screen-method )
  (:default-method
    (draw-line x y x y :thickness 1 :scale-thickness nil :stream self))
  (:obsolete-keywords ((new-value) :alu (color:sc-fill-alu new-value -1)))
  (:optimize
    (optimized-draw-point (stream x y alu)))
  )

;;; Draw a line from 1start-x0,1start-y0 to 1end-x0,1end-y0.
(define-graphics-generic draw-line (start-x start-y end-x end-y)
  (:standard-arguments :lines)
  (:argument-types (point (start-x start-y)
			  (end-x end-y)))
  (:binary-opcode 2)
  (:screen-method )
  (:default-method
    (with-stack-list (points start-x start-y end-x end-y)
      (draw-lines points :stream self)))
  (:obsolete-keywords ((draw-end-point)
		       :line-end-shape (if draw-end-point :butt :no-end-point))
		      ((dash-spacing dash-length)
		       :dash-pattern (let* ((dash-spacing (or dash-spacing 20))
					    (dash-length
					      (or dash-length (floor dash-spacing 2))))
				       (list dash-length (max 0
							      (- dash-spacing dash-length)))))
		      )
  (:optimize
    (optimized-draw-line (stream start-x start-y end-x end-y alu)))
  )

;;; Draw a line out of horizontal slices.
;;; 1slice-function0 is called with width, height, x, y.
(defun draw-line-driver (x1 y1 x2 y2 draw-end-point slice-function)
  (declare (downward-funarg slice-function))
  (let ((draw-x1 t) (draw-x2 draw-end-point))
    (when (> x1 x2)
      (rotatef x1 x2)
      (rotatef y1 y2)
      (rotatef draw-x1 draw-x2))
    (let ((dx (- x2 x1))
	  (dy (- y2 y1)))
      (let ((dir-y (if (minusp dy) -1 1))
	    (dy (abs dy)))
	(cond ((zerop dy)
	       (if (and draw-x1 draw-x2)
		   (incf dx)
		   (or draw-x1 (incf x1)))
	       (funcall slice-function dx 1 x1 y1))
	      ((zerop dx)
	       (if (and draw-x1 draw-x2)
		   (incf dy)
		   (if (not draw-x1) (incf y1 dir-y) (decf y2 dir-y)))
	       (loop repeat dy
		     for y from (min y1 y2)
		     do (funcall slice-function 1 1 x1 y)))
	      (( dx dy)			;X is larger step
	       (do ((ox x1)
		    (x x1 (1+ x))
		    (rem (ceiling dx 2) (+ rem dy))
		    (first-p (not draw-x1))
		    (done-p))
		   (nil)
		 (setq done-p (cond ((= x x2) (not draw-x2))
				    ((> x x2) t)))
		 ;; In the original L machine version of this macrocode, this > was a .
		 ;; However, in converting the inner loop to microcode, it ended up this way.
		 ;; As a result, initial conditions also need to changed from floor to ceiling.
		 ;; (Actually, the original version did a LDB for a fast floor.)
		 ;; Evidently the author of the microcode didn't see any reason to compare
		 ;; results.
		 (cond ((or done-p (> rem dx))
			(let ((width (- x ox))) 
			  (when first-p
			    (incf ox)
			    (decf width)
			    (setq first-p nil))
			  (funcall slice-function width 1 ox y1))
			(and done-p (return nil))
			(setq ox x
			      y1 (+ y1 dir-y)
			      rem (- rem dx))))))
	      (t				;Y is larger step
	       (do ((i 0 (1+ i))
		    (oy y1)
		    (y y1 (+ y dir-y))
		    (rem (ceiling dy 2) (+ rem dx))
		    (first-p (not draw-x1))
		    (done-p))
		   (nil)
		 (setq done-p (cond ((= i dy) (not draw-x2))
				    ((> i dy) t)))
		 (cond ((or done-p (> rem dy))
			(when first-p
			  (incf oy dir-y)
			  (setq first-p nil))
			(loop repeat (abs (- y oy))
			      for y from oy by dir-y
			      do (funcall slice-function 1 1 x1 y))
			(and done-p (return nil))
			(setq oy y
			      x1 (1+ x1)
			      rem (- rem dy)))))))))))

;;; Draw lines between adjacent elements of 1points0, a sequence of alternating x and y.
;;; 1:closed0: also draw a line from the final point back to the initial.
(define-graphics-generic draw-lines (points &rest args
					    &key (closed nil) (join-to-path nil))
  (:standard-arguments :lines)
  (:argument-types (point-sequence points)
		   (boolean closed join-to-path))
  (:binary-opcode 3)
  (:screen-method )
  (:default-method 
    (flet ((draw-points (stream &optional started-p)
	     (map-points #'(lambda (x y ignore)
			     (if started-p
				 (draw-line-to x y :stream stream)
			       (set-current-position x y :stream stream)
			       (setq started-p t)))
			 points)
	     (when closed
	       (close-path :stream stream))))
      (if join-to-path
	  (draw-points self (eq join-to-path 't))
	  (si:with-rem-keywords (some-args args '(:closed :join-to-path))
	    (apply #'draw-path #'draw-points :filled nil :stream self some-args)))))
  )

;;; Draw a rectangular region between two corners.
;;;  (No other args are operation specific.  So, possibilities are 1:filled,0 1:thickness,0 etc.)
(define-graphics-generic draw-rectangle (left top right bottom &rest args)
  (:standard-arguments :outline)
  (:argument-types (point (left top)
			  (right bottom)))
  (:binary-opcode 4)
  (:screen-method )
  (:default-method
    (with-stack-list (points left top right top right bottom left bottom)
      (apply #'draw-polygon points :points-are-convex-p t :stream self args)))
  (:optimize
    (optimized-draw-rectangle (stream left top right bottom alu))))

;;; Draw a triangular region between three vertices.
;;;  (No other args are operation specific).
(define-graphics-generic draw-triangle (x1 y1 x2 y2 x3 y3 &rest args)
  (:standard-arguments :outline)
  (:argument-types (point (x1 y1) (x2 y2) (x3 y3)))
  (:binary-opcode 5)
  (:screen-method )
  (:default-method
    (with-stack-list (points x1 y1 x2 y2 x3 y3)
      (apply #'draw-polygon points :points-are-convex-p t :stream self args)))
  (:optimize
    (optimized-draw-triangle (stream x1 y1 x2 y2 x3 y3 alu))))

;;; Draw a triangle out of horizontal slices.
;;; 1slice-function0 is called with width, height, x, y.
(defun draw-triangle-driver (x1 y1 x2 y2 x3 y3 slice-function)
  (declare (downward-funarg slice-function))
  ;; First sort.  Y3  Y2  Y1
  (when (> y1 y2)
    (rotatef x1 x2)
    (rotatef y1 y2))
  (when (> y1 y3)
    (rotatef x1 x3)
    (rotatef y1 y3))
  (when (> y2 y3)
    (rotatef x2 x3)
    (rotatef y2 y3))
  ;; Compute determinant ((X1 - X2) * (Y1 - Y3)) - ((Y1 - Y2) * (X1 - X3))
  (let ((det (- (* (- x2 x1) (- y3 y1)) (* (- y2 y1) (- x3 x1)))))
    (unless (zerop det)			;Unless colinear
      (let (y
	    left-x left-dx left-dy left-f left-mx left-mxf
	    right-x right-dx right-dy right-f right-mx right-mxf)
	(labels ((setup (x1 y1 x2 y2 right-p)
		   ;; We deal with double differences so that things tend to be integers
		   ;; when dealing with lattice or half-lattice points.
		   (let ((dy (* (- y2 y1) 2))
			 (y (ceiling (- y1 0.5))))
		     (if (zerop dy)
			 (values y dy)
			 (let* ((y0 (+ y 0.5))
				(dx (* (- x2 x1) 2))
				(x (ceiling (- x1 0.5)))
				;; Since the right value is exclusive, the point being
				;; tested is the half-lattice point before; for left it's
				;; the one after.
				(x0 (+ x (if right-p -0.5 0.5)))
				(f (- (* (- x0 x2) dy) (* (- y0 y2) dx)))
				;; Yes, really truncate.  This is the minimum amount that
				;; x will step each time y steps, without any danger of
				;; crossing a boundary condition.
				(mx (truncate dx dy))
				(mxf (* mx dy)))
			   (cond ((check-nearly-integer-p dx dy)
				  (setq f #+ignore (floor f) #-ignore (ceiling f)
					mxf (round mxf)))
				 ((and (< (abs dx) 1_15) (< (abs dy) 1_15)
				       (< (abs f) 1_15) (< (abs mxf) 1_15))
				  ;; Use integer arithmetic if we won't get bignums.
				  (flet ((scale-to-int (x)
					   (round (* x 1_16))))
				    (setq dx (scale-to-int dx)
					  dy (scale-to-int dy)
					  f (scale-to-int f)
					  mxf (scale-to-int mxf)))))
			   (values y dy x dx f mx mxf)))))
		 (setup1 (x1 y1 x2 y2)
		   (multiple-value-bind (y0 dy x dx f mx mxf)
		       (setup x1 y1 x2 y2 (plusp det))
		     (unless y (setq y y0))
		     (when x
		       (if (minusp det)
			   (setq left-x x left-dx dx left-dy dy left-f f
				 left-mx mx left-mxf mxf)
			   (setq right-x x right-dx dx right-dy dy right-f f
				 right-mx mx right-mxf mxf)))
		     (setq det (- det))))
		 (draw-loop (ylim)
		   ;; Draw triangle uses the inverse boundary condition predicate as
		   ;; the one adopted by draw-circle-driver and friends from X-windows.
		   ;; For now, it seems better to be compatible between the microcode and
		   ;; macrocode.  For later, we can perhaps change the microcode.
		   (macrolet #+ignore
			     ((left-pred (f) `(< ,f 0))
			      (right-pred (f) `( ,f 0)))
			     #-ignore
			     ((left-pred (f) `( ,f 0))
			      (right-pred (f) `(> ,f 0)))
		     (unless (integerp ylim)
		       (setq ylim (ceiling (- ylim 0.5))))
		     (loop until ( y ylim) do
		       (if (minusp left-dx)
			   ;; Keep right of decreasing left.
			   (loop do
			     (let ((nf (- left-f left-dy)))
			       (when (left-pred nf)
				 (return))
			       (decf left-x)
			       (setq left-f nf)))
			   ;; Keep right of increasing left.
			   (loop while (left-pred left-f) do
			     (incf left-x)
			     (incf left-f left-dy)))
		       (if (minusp right-dx)
			   ;; Keep left of decreasing right.
			   (loop while (right-pred right-f) do
			     (decf right-x)
			     (decf right-f right-dy))
			   ;; Keep left of increasing right.
			   (loop do
			     (let ((nf (+ right-f right-dy)))
			       (when (right-pred nf)
				 (return))
			       (incf right-x)
			       (setq right-f nf))))
		       (when (> right-x left-x)
			 (funcall slice-function (- right-x left-x) 1 left-x y))
		       (incf y)
		       (decf left-f left-dx)
		       (incf left-x left-mx)
		       (incf left-f left-mxf)
		       (decf right-f right-dx)
		       (incf right-x right-mx)
		       (incf right-f right-mxf)))))
	  (setup1 x1 y1 x2 y2)
	  (setup1 x1 y1 x3 y3)
	  (when (and left-x right-x) (draw-loop y2))
	  (setup1 x2 y2 x3 y3)
	  (when (and left-x right-x) (draw-loop y3)))))))

#||
;;; This is like the version that runs in microcode.  It's funny control structure
;;; was bummed for macrocode on the CADR ages ago.
(defun integer-draw-triangle-driver (x1 y1 x2 y2 x3 y3 slice-function)
  (declare (downward-funarg slice-function))
  ;; First sort.  Y1 > Y2 > Y3
  (cond ((> y2 y1)
	 (rotatef x1 x2)
	 (rotatef y1 y2)))
  (cond ((> y3 y1)
	 (rotatef x1 x3)
	 (rotatef y1 y3)))
  (cond ((> y3 y2)
	 (rotatef x2 x3)
	 (rotatef y2 y3)))
  (flet ((setup (x1 y1 x2 y2 xl xlir xli xlr xr xrir xri xrr ly ry det
		 &aux dx dy l b i q r)
	   (declare (values xl xlir xli xlr xr xrir xri xrr ly ry det))
	   (setq det (- det)
		 dy (- y1 y2))
	   (when (not (zerop dy))
	     (setq dx (- x1 x2)
		   l (- (* (1+ (* x1 2)) dy) dx)
		   dy (* 2 dy)
		   dx (* 2 dx))
	     (multiple-value-setq (b i)
	       (floor l dy))
	     (multiple-value-setq (q r)
	       (floor dx dy))
	     (if (minusp det)
		 (setq ly dy xl b xlr i xlir r xli q)	;Left
		 (setq ry dy xr b xrr i xrir r xri q)))
	   (values xl xlir xli xlr xr xrir xri xrr ly ry det)))
    ;; Compute determinant ((X1 - X2) * (Y1 - Y3)) - ((Y1 - Y2) * (X1 - X3))
    (let ((det (- (* (- x1 x2) (- y1 y3)) (* (- y1 y2) (- x1 x3)))))
      (unless (zerop det)			;Unless colinear
	(prog (xl xlir xli xlr xr xrir xri xrr ly ry y ylim)
	  (multiple-value-setq (xl xlir xli xlr xr xrir xri xrr ly ry det)
	    (setup x1 y1 x2 y2 xl xlir xli xlr xr xrir xri xrr ly ry det))
	  (multiple-value-setq (xl xlir xli xlr xr xrir xri xrr ly ry det)
	    (setup x1 y1 x3 y3 xl xlir xli xlr xr xrir xri xrr ly ry det))
	  (setq y (1- y1) ylim y2)
       loop
	  (and ( y ylim) (go loop-1))
       half-done
	  (and (< y y3) (return t))		;All done
	  (setq ylim y3)
	  (multiple-value-setq (xl xlir xli xlr xr xrir xri xrr ly ry det)
	    (setup x2 y2 x3 y3 xl xlir xli xlr xr xrir xri xrr ly ry det))
       loop-1
	  (funcall slice-function (- xr xl) 1 xl y)
	  (decf y)
	  (decf xlr xlir)
	  (decf xl xli)
	  (and (< xlr 0) (go xlr-negate))
	  (and ( xlr ly) (go xlr-wrap))
       incr-1
	  (decf xrr xrir)
	  (decf xr xri)
	  (and (< xrr 0) (go xrr-negate))
	  (and (< xrr ry) (go loop))
       xrr-wrap
	  (decf xrr ry)
	  (incf xr)
	  (go loop)
       xlr-negate
	  (incf xlr ly)
	  (decf xl)
	  (go incr-1)
       xlr-wrap
	  (decf xlr ly)
	  (incf xl)
	  (go incr-1)
       xrr-negate
	  (incf xrr ry)
	  (decf xr)
	  (go loop))))))
||#

;;; Three point form of a circle.
(defun triangle-circumscribed-circle (x1 y1 x2 y2 x3 y3)
  (declare (values center-x center-y radius))
  (let* ((dx12 (- x2 x1))
	 (dy12 (- y2 y1))
	 (dx13 (- x3 x1))
	 (dy13 (- y3 y1))
	 (q (* (- (* dx12 dy13) (* dx13 dy12)) 2))
	 (l12 (sqrt (+ (expt dx12 2) (expt dy12 2))))
	 (l13 (sqrt (+ (expt dx13 2) (expt dy13 2))))
	 (l23 (sqrt (+ (expt (- x3 x2) 2) (expt (- y3 y2) 2)))))
    (values (+ x1 (/ (+ (- (* dx12 dx12 dy13) (* dx13 dx13 dy12))
			(* dy12 dy13 (- dy12 dy13)))
		     q))
	    (+ y1 (/ (+ (- (* dx12 dy13 dy13) (* dx13 dy12 dy12))
			(* dx12 dx13 (- dx13 dx12)))
		     q))
	    (abs (/ (* l12 l13 l23) q)))))

(compiler:make-obsolete draw-convex-polygon
			"Use GRAPHICS:DRAW-POLYGON with :POINTS-ARE-CONVEX-P T")

;;; Draw the polygonal figure with vertices on a given sequence of points.
;;;  1:points-are-convex-p0: as given, the polygon is convex.
;;;  A convex polygon is one which is convex from the perspective of its first vertex.
;;;  Given this, we can just draw triangles without checking for intersections and so on.
(define-graphics-generic draw-polygon (points &rest args
					      &key (points-are-convex-p nil)
					      &allow-other-keys)
  (:standard-arguments :outline)
  (:argument-types (point-sequence points)
		   (boolean points-are-convex-p))
  (:binary-opcode 6)
  (:screen-method )
  (:default-method
    (ignore points-are-convex-p)
    (si:with-rem-keywords (some-args args '(:points-are-convex-p))
      (apply #'draw-path
	     #'(lambda (stream) (draw-lines points :join-to-path :new :closed t
					    :stream stream))
	     :stream self some-args))))

;;; Return the next complete polygon by eliminating common edges.
(defun triangle-next-polygon (triangles)
  (let ((index (loop for index below (fill-pointer triangles) by 7 do
		 (unless (aref triangles index)	;Marked already
		   (setf (aref triangles index) t)
		   (return index)))))
    (unless (null index)
      (let ((polygon (make-stack-array (length triangles) :fill-pointer 6))) 
	(replace polygon triangles :start2 (1+ index) :end1 6)
	(let ((index 0))
	  (loop
	    (when ( index (fill-pointer polygon))
	      (return))
	    (let ((next-index (+ index 2)))
	      (when ( next-index (fill-pointer polygon))
		(setq next-index 0))
	      (let* ((from-x (aref polygon index))
		     (from-y (aref polygon (1+ index)))
		     (to-x (aref polygon next-index))
		     (to-y (aref polygon (1+ next-index))))
		(multiple-value-bind (other-x other-y)
		    (loop for index below (fill-pointer triangles) by 7 do
		      (unless (aref triangles index)
			(flet ((match-index (x y)
				 (loop for i below 3
				       for jndex from (1+ index) by 2 do
				   (let ((tx (aref triangles jndex))
					 (ty (aref triangles (1+ jndex))))
				     (when (and (= tx x) (= ty y))
				       (return i))))))
			  (let ((from-index (match-index from-x from-y)))
			    (when from-index
			      (let ((to-index (match-index to-x to-y)))
				(when to-index
				  (let ((odd-index (loop for i below 3
							 for jndex from (1+ index) by 2 do
						     (unless (or (= i from-index)
								 (= i to-index))
						       (return jndex)))))
				    (setf (aref triangles index) t)
				    (return
				      (values (aref triangles odd-index)
					      (aref triangles (1+ odd-index))
					      ))))))))))
		  (if other-x
		      (let ((at-index (+ index 2)))
			(vector-push-extend nil polygon)
			(vector-push-extend nil polygon)
			(unless ( (+ at-index 2) (fill-pointer polygon))
			  (replace polygon polygon :start2 at-index :start1 (+ at-index 2)))
			(setf (aref polygon at-index) other-x)
			(setf (aref polygon (1+ at-index)) other-y))
		      (incf index 2)))))))
	polygon))))

#|

 TRIANGUATE-POLYGON

 This does the hard part of reducing an arbitrary line list to triangles.  The
 basic contract is to produce the same set of triangles that the "finger of god"
 algorithm does, which is to say, all areas "inside" the polygon are drawn
 and all areas "outside" are not.

 The basic determinant of "insideness" is that a line drawn from a point possibly
 inside, to a point definitely outside, crosses an ODD number of lines if it is
 in fact inside, and an EVEN number of lines if it in fact outside.  All bets are
 off if that line passes tangent to a vertex.

 Given this definion, polygons that define topologically complex objects are 
 seen as full of holes.  

 We Modify the basic algorithm by moving all the intersection points to exact coordinates.
 This makes the footprint a little different from Finger of god, but keeps the coordinates
 for all the triangles as integers.


 The algorithm:

  First, un-twist the polygon, so it is a simple circuit with no crossing lines.

  Thereafter, find a polygon which is "inside" and which doesn't contain any other
  vertices or line segments.  Some theorem or other guarantees there will be one.

  Call the client function on the found triangle

  Splice out the midpoint of the triangle just found.  This is guaranteed to be an
  outside point, though I'm not quite sure why.

  Iterate.


  In all this, care is taken to minimize the potential screw cases due to  floating point.
  
|#

(defun triangulate-polygon (triangle-function points)
  (declare (downward-funarg triangle-function))
  (let* ((points (if (listp points) (copy-list points) (coerce points 'list)))
	 (outside-x (1- (loop for i in points by #'cddr minimize i)))
	 ;; outside x and outside y are a guaranteed outside the poly
	 (outside-y (- (cadr points) 2))
	 (points-remaining (length points)))
    (assert (not (oddp points-remaining)))
    (multiple-value-setq (points points-remaining)
      (un-twist-polygon points points-remaining))
    (setf (cdr (last points)) points)  ; circularize the list
    (loop with new-triangle and triangle-type and knot and twist
	  while ( points-remaining 6) ; 3 pair of points
	  do 
      (multiple-value-setq (new-triangle triangle-type)
	(find-inside-triangle outside-x outside-y points))
      (cond (new-triangle
	     (setq knot nil twist nil)
	     (unless (eq triangle-type :degenerate)
	       (let ((n new-triangle))
		 (funcall triangle-function (pop n) (pop n) (pop n)
			  (pop n) (pop n) (pop n))))
	     ;; Splice out the corner point
	     (setf (cddr new-triangle) (cddr (cddr new-triangle)))
	     (decf points-remaining 2)
	     (setq points new-triangle))
	    ((and (not knot)
						;try un-knotting
		  (setq knot t)
		  (setq new-triangle (un-knot-polygon points)))
	     )
	    ((not twist)
	     (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");lets twist again, like we did last summer...
0	     2;..Due to the wonder of floating point arithmetic, a list which was originally untwisted
	     ;..can later appear twisted when some of its points are removed.
0	     (let ((p (cddr points)))
						;linearize the list
	       (setf (cddr points) nil)
	       (multiple-value-setq (new-triangle points-remaining)
		 (un-twist-polygon p points-remaining))
	       (setf (cdr (last new-triangle)) new-triangle)
	       (setq twist t)
	       ))
	    (t (loop-finish))
	    )
	    )))

;;; This is a subroutine of TRIANGULATE-POLYGON.  It isn't intended for
;;; public consumption primarily because POINTS is a circular list at
;;; the time we are called.
(defun find-inside-triangle (outside-x outside-y points)
  (loop with p = points and type
	and last = (loop for i on points when (eq (cdr i) points) do (return i))
	when (and (progn (setf (cdr last) nil)
			 (prog1 (not (or (apply #'some-point-inside-triangle-p p)
					 (apply #'some-line-intersects-triangle-p p)
					 ))
				(setf (cdr last) p)))
		  (setq type (first-triangle-inside-poly outside-x outside-y p)))
	  do (return (values p type))
	do
    (setq p (cddr p))
    (setq last (cddr last))
	until (eq p points)
	finally (return nil)))

;;; Un twist any twisted polygons.  Points is a list of points, which is
;;; descructively modified to splice in new points as necessary.  The
;;; resulting list is guaranteed to be one complete circuit (assuming
;;; first and last were connected, which they aren't yet) with no
;;; crossing lines and some number of kissing corners.  The new corners
;;; are forced to integer coordinates.
(defun un-twist-polygon (points &optional (points-remaining (length points)))

  (loop as some = nil
	do
    (loop with p = points
	  as px1 = (first p)
	  as py1 = (second p)
	  as px2 = (third p)
	  as py2 = (fourth p)
	  when (null p) do (return)
	  do
      (loop with ix and iy
	    and q = (cddr (cddr p))
	    as qx1 = (first q)
	    as qy1 = (second q)
	    as qx2 = (or (third q) (car points))
	    as qy2 = (or (fourth q) (cadr points))
	    while q 
	    when
	      (multiple-value-setq (ix iy)
		(line-intersection px1 py1 px2 py2  qx1 qy1 qx2 qy2 :open))
	      do
		
	;; This requires a big comment to justify all these SETFs

	;; We have found two lines which intersect.  Considering the lines as vectors,
	;; the geometry is A -> B  ...  C -> D
	;; with A-C intersecting C-D

	;; we want to splice in a new point, E, such that the result is
	;; A -> E -> C  ... B -> E -> D

	;; Note that this requires reversing the direction of all the segments between B and C
		
		(setq ix (round ix)
		      iy (round iy))
	;; lines intersect so splice in a point
		
		(let* ((a p)
		       (b (cddr a))
		       (c q)
		       (d (cddr c)))
		  
		  ;; reverse the segment from b to c
		  (loop for i on b by #'cddr
			do
		    ;; swap x and y, so when reversed they will be right again
		    (rotatef (car i) (cadr i))
		    
			when (eq (cddr i) c)
			  do
			    
		    ;; we found the end of the segment and zap it
			    (setf (cddr i) nil)
			    (setq b (nreverse b))
			    (return))
		  
		  ;; link A to the new point
		  (setf (cddr a) (list ix iy))
		  (setq a (cddr a))
		  
		  ;; link the new point to c
		  (setf (cddr a) c)
		  
		  ;; link c to the reverse b-c segment
		  (setf (cddr c) b)
		  
		  ;; splice in another copy of the new point
		  (setq b (last b))
		  (setf (cdr b) (setq q (list ix iy)))
		  (setq b (cddr b))
		  
		  ;;link to the ramainder of the list
		  (setf (cdr b) d)
		  (incf points-remaining 4)
		  (setq px2 ix 	; note that the original segment is now shorter!
			py2 iy)
		  (setq some t)
		  )
	    do (setq q (cddr q)))
	  do (setq p (cddr p))
	     )
	until (null some))
    (values points points-remaining))

(defun un-knot-polygon (points)	
  (loop with p = points and winnage
	;as px1 = (first p)
	;as py1 = (second p)
	as px2 = (third p)
	as py2 = (fourth p)
	when (or (null p)
		 (setq winnage
		       (loop with q = (cddr (cddr p))
			     ;as qx1 = (first q)
			     ;as qy1 = (second q)
			     as qx2 = (or (third q) (car points))
			     as qy2 = (or (fourth q) (cadr points))
			     while (and q (neq p p))
			     when (and (= px2 qx2) (= py2 qy2))
			       do
				 
			 ;; this is just like un-twist-polygon, except that we
			 ;; have found a point where the poly ties itself in a knot.
			 ;; we relink the enpoints to remove the knot.
				 
			 ;; we have A -> E -> B  ...  C -> E -> D
			 ;; we relink A -> E -> C ... B -> E -> D
			 ;; which requires reversing B..C
				 
				 (let* ((e1 (cdddr p))
					(b (cdr e1))
					bc
					(e2 (cddr q))
					(c q))
				   
				   ;; reverse the segment from b to c
				   (loop for i on b by #'cddr
					 do
				     ;; swap x and y, so when reversed they will
				     ;;  be right again
				     (rotatef (car i) (cadr i))
				     
					 when (eq i c)
					   do
				     ;; we found the end of the segment and zap it
					     (setf (cddr i) nil)
					     (setq bc (nreverse b))	;destructive reverse
					     (return))
				   
				   (setf (cdr e1) bc)
				   (setf (cdr b) e2))
				 (return t)
			     do (setq q (cddr q)))))
	  do (return (and winnage points))
	do (setq p (cddr p))
	when (eq p points) do (return nil)))

;;; Discover if the first triangle of POINTS is inside, ie, a candidate for drawing.
;;; To do this, we count the number of line intersections. 
(defun first-triangle-inside-poly (outside-x outside-y points)
  (multiple-value-bind (mx my)
      (triangle-midpoint-not-degenerate
	(first points) (second points)
	(third points) (fourth points)
	(fifth points) (sixth points))
    (if (and mx my)
	(loop with val
	      and p = points 
	      when (line-intersection outside-x outside-y mx my
				      (first p) (second p) (third p) (fourth p) :half-open)
		do (setq val (not val))
	      do (setq p (cddr p))
	      until (eq p points)
	      finally (return val))
	:degenerate)))

;;; Examine all the other points in the poly, and return the location of
;;; the first which is inside.  A matching vertex is not inside, but a
;;; point ON the triangle is.
(defun some-point-inside-triangle-p (x1 y1 x2 y2 x3 y3 &rest coords)
  ;; You'd never guess that Gosper wrote the following, would you?  -Weav
  (let ((area #(x2-x1)*(y3-y1)-(y2-y1)*(x3-x1)))	;actually 2*area
    (unless (zerop area)
      (when (minusp area)
	(rotatef x2 x3)
	(rotatef y2 y3))
      (loop while coords
	    as x = (pop coords)
	    as y = (pop coords)
	    thereis (origin-inside-ccw-triangle-p
		      (- x1 x) (- y1 y)
		      (- x2 x) (- y2 y)
		      (- x3 x) (- y3 y))))))

(defun origin-inside-ccw-triangle-p (x1 y1 x2 y2 x3 y3)
  (cond ((or (and (zerop x1) (zerop y1))	; coincident with some vertex
	     (and (zerop x2) (zerop y2))	; count as outside
	     (and (zerop x3) (zerop y3)))
	 nil)
	((not (or (minusp #x2*y3-x3*y2)
		  (minusp #x1*y2-x2*y1)
		  (minusp #x3*y1-x1*y3))))))

;;; Assuming that the triangle plus the points are a poly, check each of
;;; the exterior lines to see if it intersects the triangle.  Trivial intersection
;;; at a vertex is not considered as a hit.
(defun some-line-intersects-triangle-p (x1 y1 x2 y2 x3 y3 &rest points )
  (loop with exit 
	and p = points
	as px1 = x3 then px2
	as py1 = y3 then py2
	as px2 = (or (pop p) x1)
	as py2 = (or (pop p) y1)
	when (and
	       (or (and (= px1 x3) (= py1 y3)) (and (= px2 x3) (= py2 y3)))
	       (line-intersection px1 py1 px2 py2  x1 y1 x2 y2 :open))
	  do (return (values px1 py1 px2 py2))
	when (and
	       (or (and (= px1 x1) (= py1 y1)) (and (= px2 x1) (= py2 y1)))
	       (line-intersection px1 py1 px2 py2  x3 y3 x2 y2 :open))
	  do (return (values px1 py1 px2 py2))
	when (and
	       (or (and (= px1 x2) (= py1 y2)) (and (= px2 x2) (= py2 y2)))
	       (line-intersection px1 py1 px2 py2  x3 y3 x1 y1 :open))
	  do (return (values px1 py1 px2 py2))
	do
    (setq px1 px2
	  py1 py2)
	when exit do (return nil)
	when (null p) do (setq exit t)))
 
;;; Find the midpoint by bisection.  Floating point errors can easily
;;; return an "intersection" of a triangle which is in fact degenerate.
(defmacro triangle-midpoint (x1 y1 x2 y2 x3 y3)
  `(values (/ (+ ,x1 ,x2 ,x3) 3.0)
	   (/ (+ ,y1 ,y2 ,y3) 3.0)))

(defun triangle-midpoint-not-degenerate (x1 y1 x2 y2 x3 y3)
  ;; Find the midpoint of a triangle, except that degenerate triangles
  (unless (or (and (= x1 x2) (= y1 y2))
	      (and (= x1 x3) (= y1 y3))
	      (and (= x2 x3) (= y2 y3)))
    (triangle-midpoint x1 y1 x2 y2 x3 y3)))

;;; Return the intersection point of two lines, or NIL if the two
;;; are colinear, parallel, or nonintersecting.

;;; INTERVAL can be T to indicate you want the intersection point wherever it is.
;;; 		   :OPEN to indicate the endpoints don't count as matching
;;;  		   :CLOSED (default) to include endpoints
;;;                :HALF-OPEN if one pair of endpoints is considered connected but the
;;;			other is considered disconnected.   This mode is correct for
;;;    			inside/outside determination	      
(defun line-intersection
       (x1 y1 x2 y2   x3 y3 x4 y4 &optional (interval :closed) &aux x-inter y-inter)

  (cond ((and (or (eq interval :half-open)
		  (eq interval :open))
	      (or (and (= x1 x4) (= y1 y4))
		  (and (= x2 x3) (= y2 y3))
		  ))
	 ;; if the interval is open, and an endpoint is shared, the lines do not intersect
	 nil)
	((and (eq interval :open) 
	   (or (and (= x1 x3) (= y1 y3))
	       (and (= x2 x4) (= y2 y4))))
	 ;; if the interval is open, and an endpoint is shared, the lines do not intersect
	 nil)
	((and (or (eq interval :closed) (eq interval :half-open))
	      (or (and (= x1 x3) (= y1 y3) (setq x-inter x1 y-inter y1))
		  (and (= x1 x4) (= y1 y4) (setq x-inter x1 y-inter y1))
		  (and (= x2 x3) (= y2 y3) (setq x-inter x2 y-inter y2))
		  (and (= x2 x4) (= y2 y4) (setq x-inter x2 y-inter y2))))
	 ;; if the interval is closed, and an endpoint is shared, the lines DO intersect
	 ;; we do it here rather than rely on calculating it because of floating point
	 ;; lossage
	 (values x-inter y-inter))
	(t (let* ((a0 (- y2 y1))
		  (b0 (- x1 x2))
		  (c0 (+ (* (- x2 x1) y1) (* (- y1 y2) x1)))
		  (a1 (- y4 y3))
		  (b1 (- x3 x4))
		  (c1 (+ (* (- x4 x3) y3) (* (- y3 y4) x3)))
		  (determinant (float (- (* a0 b1)
					 (* a1 b0)))))
	     (if (zerop determinant)
		 nil
		 (setq x-inter (cond ((= x1 x2) x1)
				     ((= x3 x4) x3)
				     (t (/ (- (* b0 c1) (* b1 c0)) determinant)))
		       y-inter (cond ((= y1 y2) y1)
				     ((= y3 y4) y3)
				     (t (/ (- (* a1 c0) (* a0 c1)) determinant))))
		 (cond ((and (or (eq interval :half-open)
				 (eq interval :open))
			     (or (and (= x1 x-inter) (= y1 y-inter))
				 (and (= x4 x-inter) (= y4 y-inter))
				 ))
			;; if the interval is half open, and an endpoint is shared,
			;the lines do not intersect
			nil)
		       ((and (eq interval :open)
			     (or (and (= x2 x-inter) (= y2 y-inter))
				 (and (= x3 x-inter) (= y3 y-inter))))
			nil)  ;; open interval, and we intersect at an endpoint
		       (t (case interval
			    ((:closed :open :half-open)
			     (and 
			       (or ( x1 x-inter x2) ( x2 x-inter x1))
			       (or ( y1 y-inter y2) ( y2 y-inter y1))
			       (or ( x3 x-inter x4) ( x4 x-inter x3))
			       (or ( y3 y-inter y4) ( y4 y-inter y3))
			       (values x-inter y-inter)))
			    (otherwise
			      (values x-inter y-inter))))))))))

;;; Draw a polygon of 1number-of-sides0 with an edge along 1start-x0,1start-y 0to1 end-x0,1end-y0.
;;; 1:handedness0 (default 1:left0): which of the two possible polygons with this edge to draw.
;;;  Standing at start-x,start-y looking at end-x,end-y, the figure is on the 1handedness
0;;;   side of the given line.
(define-graphics-generic draw-regular-polygon (start-x start-y end-x end-y number-of-sides
					       &rest args
					       &key (handedness :left)
					       &allow-other-keys)
  (:standard-arguments :outline)
  (:argument-types (point (start-x start-y)
			  (end-x end-y))
		   (((integer (0))) number-of-sides)
		   (((member :left :right)) handedness))
  (:binary-opcode 7)
  (:default-method
    (si:with-rem-keywords (some-args args '(:handedness))
      (apply #'draw-path
	     #'(lambda (*standard-output*)
		 (let ((theta (* (float (* pi (/ 2.0 number-of-sides)) 0.0)
				 (ecase handedness
				   (:left +1)
				   (:right -1))))
		       (dx (- end-x start-x))
		       (dy (- end-y start-y)))
		   (set-current-position start-x start-y)
		   (graphics-origin-to-current-position)
		   (dotimes (i number-of-sides)
		     (declare (ignore i))
		     (draw-line-to dx dy)
		     (graphics-origin-to-current-position)
		     (graphics-rotate theta))
		   (close-path)))
	     :stream self some-args))))

;;; Draw a line with an arrowhead at the end of it from 1from-x0,1from-y 0to1 to-x0,1to-y.
0;;; 1:arrow-head-length0 (default 10): Ratio of length of the arrowhead to 1:thickness0 of
;;;   the line.
;;; 1:arrow-base-width0 (default 5): Ratio of width of the base of the arrowhead to 1:thickness
0;;;  of the line.
(defvar *default-arrow-length* 10
  "Ratio of length of the arrowhead to width of the line.")
(defvar *default-arrow-width* 5
  "Ratio of width of the base of the arrowhead to width of the line.")
(defun draw-arrow (from-x from-y to-x to-y
		   &rest args
		   &key (thickness 1)
			(arrow-head-length *default-arrow-length*)
			(arrow-base-width  *default-arrow-width*)
			(from-arrow-head nil)
			(to-arrow-head t)
		   &allow-other-keys)
  (declare (compiler:arglist-types (from-x point-x) (from-y point-y)
				   (to-x point-x) (to-y point-y)))
  (setq arrow-head-length (* arrow-head-length (max 1 thickness))
	arrow-base-width (* arrow-base-width (max 1 thickness)))
  (let* ((delta-x (- to-x from-x))
	 (delta-y (- to-y from-y))
	 (length-of-line (sqrt (+ (expt delta-x 2) (expt delta-y 2)))))
    (unless (zerop length-of-line)
      ;; If length-of-line = 0, we do nothing and return nil
      (let* (;; Angle of inclination of the line
	     (cos-theta (/ delta-x length-of-line))
	     (sin-theta (/ delta-y length-of-line))
	     ;; Changes from endpoint to arrow base.
	     (delta-x-base (* arrow-head-length cos-theta))
	     (delta-y-base (* arrow-head-length sin-theta))
	     ;; Changes from arrow base to corners.
	     (delta-x-corner (/ (* arrow-base-width sin-theta) 2.0))
	     (delta-y-corner (/ (* arrow-base-width cos-theta) -2.0))
	     ;; Adjusted for ends to be drawn.
	     (line-start-x from-x)
	     (line-start-y from-y)
	     (line-end-x to-x)
	     (line-end-y to-y))
	(when from-arrow-head
	  (incf line-start-x delta-x-base)
	  (incf line-start-y delta-y-base))
	(when to-arrow-head
	  (decf line-end-x delta-x-base)
	  (decf line-end-y delta-y-base))
	(si:with-rem-keywords (some-args args '(:arrow-head-length :arrow-base-width
						:from-arrow-head :to-arrow-head))
	  (when from-arrow-head
	    ;; Draw the first arrowhead
	    (apply #'draw-triangle
		   from-x from-y
		   (+ line-start-x delta-x-corner) (+ line-start-y delta-y-corner)
		   (- line-start-x delta-x-corner) (- line-start-y delta-y-corner)
		   some-args))
	  ;; Draw the line -- don't overlap with arrowhead in case alu is :flip.
	  (apply #'draw-line line-start-x line-start-y line-end-x line-end-y some-args)
	  ;; Draw the final arrowhead
	  (when to-arrow-head
	    ;; Draw the first arrowhead
	    (apply #'draw-triangle
		   to-x to-y
		   (+ line-end-x delta-x-corner) (+ line-end-y delta-y-corner)
		   (- line-end-x delta-x-corner) (- line-end-y delta-y-corner)
		   some-args))))
      ;; Return t if actually drew something
      t)))

;;;; Circles and ellipses

(defconstant 2pi (* pi 2))

;;; Is this sector (from end-angle to start-angle) the improper part of arc?
;;; Ordinarily, we ignore factors of 2, so that -/4 is the same 7/4.
;;; This makes things more convenient for use with the result of atan, e.g.
;;; However, angleangle is special cased against angleangle+2.
(defun sector-wide-p (start-angle end-angle)
  (let ((diff (mod (- end-angle start-angle) 2pi)))
    (if (zerop diff)
	( end-angle start-angle)
	(> diff pi))))

(defun full-circle-p (start-angle end-angle)
  (or (and (= start-angle 0)
	   (<  -.000001 (- end-angle 2pi) .000001)
	   #+ignore
	   (eql end-angle 2pi))
      (and ( start-angle end-angle)
	   ;; (= (mod (- end-angle start-angle) 2pi) 0)
	   (multiple-value-bind (multiple residue)
	       (truncate (- end-angle start-angle) 2pi)
	     (let ((absmultiple (abs multiple)))
	       (< (* -.000001 multiple) residue (* .000001 absmultiple))))
	   #+ignore
	   (si:double-= (sys:%multiple-value-call-n
			  si:%double-floating-mod
			  (si:double-- (si:double-dfloat end-angle)
				       (si:double-dfloat start-angle))
			  2
			  (si:double-components 2pi)
			  2)
			0.0d0))))

(defun angle-between-angles-p (theta theta-1 theta-2)
  (if (< theta-1 theta-2)
      (if (< theta-1 theta)
	  (< theta theta-2)
	  (< (+ theta 2pi) theta-2))
      (if (< theta-1 theta)
	  (< theta (+ theta-2 2pi))
	  (< theta theta-2))))

;;; Draw a circle centered at 1center-x0,1center-y0 with radius 1radius0.
;;; 1:inner-radius0 (default 0): actually draw a ring.
;;; 1:start-angle0 (default 0), 1:end-angle0 (default 2): actually draw a
;;;  sector between the two angles.
;;; 1:clockwise0 (default nil): affects the interpretation of 1:start-angle0 and 1:end-angle0 and
;;;  the direction of the path for 1draw-path0 with 1:winding-rule :non-zero0.

;;; Note that we draw circles by calling the ellipse drawer.  If after applying the
;;; current scaling, it's still a circle, we can used optimized output methods.  This
;;; way allows explicit ellipses to get stetched back into circles and benefit from the
;;; same optimization.
(defun draw-circle (center-x center-y radius
		    &rest args
		    &key (inner-radius 0)
		    &allow-other-keys)
  (declare (arglist center-x center-y radius 
	    &key (inner-radius 0) (start-angle 0) (end-angle 2pi)
		 (alu :draw) (filled t) (color nil) 1(gray-level 1)
		 (tile nil) (stipple nil) (return-presentation nil)
0		 (pattern nil) (opaque t)
		 (mask nil) (mask-x 0) (mask-y 0)
		 (thickness nil) (scale-thickness t)
		 (line-end-shape :butt) (line-joint-shape :miter)
		 (dashed nil) dash-pattern (initial-dash-phase 0)
		 (draw-partial-dashes t) (scale-dashes nil)
		 (stream *standard-output*) (rotation 0) (clockwise nil) (join-to-path nil)
		 (scale 1) (scale-x 1) (scale-y 1) (translation nil) (transform nil)))
  (si:with-rem-keywords (some-args args '(:inner-radius))
    (if ( inner-radius 0)
	(apply #'draw-ellipse center-x center-y radius radius
	       :inner-x-radius inner-radius some-args)
	(apply #'draw-ellipse center-x center-y radius radius some-args))))

;;; Draw an ellipse centered at 1center-x0,1center-y0 with semi axes of 1x-radius0 and 1y-radius0.
;;;  1:inner-x-radius0 (default 0),
;;;  1:inner-y-radius0 (default (/ (* inner-x-radius y-radius) x-radius)):
;;;   actually draw an elliptical ring.
;;; 1:start-angle0 (default 0), 1:end-angle0 (default 2): as for 1draw-circle0.
;;; 1:clockwise: as0 for 1draw-circle0.
(define-graphics-generic draw-ellipse
			 (center-x center-y x-radius y-radius
			  &key (inner-x-radius 0)
			       (inner-y-radius (/ (* inner-x-radius y-radius) x-radius))
			       (start-angle 0) (end-angle 2pi) (clockwise nil)
			       (join-to-path nil))
  (:standard-arguments :outline)
  (:argument-types (point (center-x center-y))
		   (number x-radius y-radius inner-x-radius inner-y-radius)
		   (angle start-angle end-angle)
		   (boolean clockwise join-to-path))
  (:binary-opcode 8)
  (:screen-method )
  )

;;; If the coordinates are pretty close to lattice points, use the somewhat faster
;;; integer versions.  Note that the non-integer version still doesn't use non-integer
;;; arithmetic in the inner loop, so the difference isn't profound.
(defmacro check-nearly-integer-p (&rest nums)
  (let ((gens (loop for num in nums do (ignore num) collect (gensym))))
    `(cond ((and . ,(loop for num in nums collect `(integerp ,num))) t)
	   (t
	    (let ,gens
	      (when (and . ,(loop for num in nums
				  for gen in gens
				  collect `(multiple-value-bind (nnum res)
					       (round ,num)
					     (when (< (abs res) .01)
					       (setq ,gen nnum)
					       t))))
		(setq . ,(loop for num in nums
			       for gen in gens
			       collect num collect gen))
		t))))))

;;; If the coordinates are half lattice points, we still need the full asymmetrical
;;; initial conditions.  However, the partial derivative will be an integer (x^2  2x),
;;; which means we'll always add an integer to the difference, which therefore may as well
;;; be an integer, since only its sign matters.
(defmacro check-integer-f-and-dfs (dfy right-f right-dfx left-f left-dfx)
  `(let ((yp (multiple-value-bind (idf res)
		 (round ,dfy)
	       (when (< (abs res) .0001)
		 (setq ,dfy idf)
		 t))))
     ;; Right is checked  0, so positive now becomes 0.
     ;; Left is checked > 0, so positive now must become more positive.
     (check-integer-f-and-df yp floor ,right-f ,right-dfx)
     (check-integer-f-and-df yp ceiling ,left-f ,left-dfx)))

(defmacro check-integer-f-and-df (yp integrator f dfx)
  `(when (and (multiple-value-bind (idf res)
		  (round ,dfx)
		(when (< (abs res) .0001)
		  (setq ,dfx idf)
		  t))
	      ,yp)
     (setq ,f (,integrator ,f))))

(defmacro shape-slice-driver (y fy direction fyy rcx
			      right-x right-f right-fx
			      left-x left-f left-fx fxx)
  `(loop named top doing
     (loop while (and ( ,right-f 0) (> ,right-fx (- ,fxx))) do
       (decf ,right-x)
       (when (< ,right-x ,rcx)
	 (return-from top nil))
       (decf ,right-fx ,fxx)
       (decf ,right-f ,right-fx))
     (loop while (and (> ,left-f 0) (minusp ,left-fx)) do
       (incf ,left-x)
       (incf ,left-f ,left-fx)
       (incf ,left-fx ,fxx))
     (funcall slice-function (- ,right-x ,left-x) 1 ,left-x ,y)
	 . ,(ecase direction
	      (incf
		`((incf ,y)
		  (incf ,right-f ,fy)
		  (incf ,left-f ,fy)
		  (incf ,fy ,fyy)))
	      (decf
		`((decf ,y)
		  (decf ,fy ,fyy)
		  (decf ,right-f ,fy)
		  (decf ,left-f ,fy))))))

(defmacro circle-initial-f (x0 y0 radius)
  `(+ (* ,x0 ,x0) (* ,y0 ,y0) (- (* ,radius ,radius))))

(defmacro circle-initial-fx (x0)
  `(1+ (* 2 ,x0)))

;;; Draw a circle of radius 1radius0 as horizonal slices.
;;; This is more or less the same as the Pitteway-Bresenham algorithm, except that the
;;; initial condition is (x,y)=(r-1/2,1/2).  Since the x and y only move by integral steps,
;;; we don't actually keep the 1/2's along as we go.  Similarly, since only the sign of F
;;; matters and it only changes by integers, we start it at its floor.  And finally, instead
;;; of drawing the nearest point each step, we draw slices to the rightmost half-lattice point
;;; which is strictly to the left of the circle.
;;; Slice function is called with width, height, x, y.
(defun draw-circle-driver (center-x center-y radius slice-function)
  (declare (downward-funarg slice-function))
  (if (check-nearly-integer-p center-x center-y radius)
      ;; Integral case.  Because of the integer initial conditions, it is impossible for a
      ;; half-lattice point to lie on the circle.  Note that this figure is symmetrical
      ;; about the real center, i.e. the corner of the center pixel, not the center of
      ;; that pixel, like the old :draw-circle message.
      (let* ((x radius)
	     (y 0)
	     (f (- 1 x))
	     (fx (* radius 2))
	     (fy 2))
	(loop named top doing
	  (loop while (> f 0) do
	    (decf x)
	    (when (minusp x)
	      (return-from top nil))
	    (decf fx 2)
	    (decf f fx))
	  (let ((2x (+ x x))
		(start-x (- center-x x)))
	    (funcall slice-function 2x 1 start-x (+ center-y y))
	    (funcall slice-function 2x 1 start-x (- center-y (1+ y))))
	  (incf y)
	  (incf f fy)
	  (incf fy 2)))
      ;; This is the same as the above, except that the radius and center are not lattice
      ;; points.  We have to be a little more careful about the initial conditions, and
      ;; the figure may not be symmetrical, or may be symmetrical about a half-lattice
      ;; point.
      (macrolet ((half-circle (y direction)
		   `(let* ((rcx (round center-x))
			   (y ,y)
			   (y0 (- y center-y -0.5))
			   (fy (1+ (* 2 y0)))
			   (right-x (ceiling (+ center-x radius -0.5)))
			   (right-x0 (- right-x center-x 0.5))
			   (right-f (circle-initial-f right-x0 y0 radius))
			   (right-fx (circle-initial-fx right-x0))
			   (left-x (floor (- center-x radius 0.5)))
			   (left-x0 (- left-x center-x -0.5))
			   (left-f (circle-initial-f left-x0 y0 radius))
			   (left-fx (circle-initial-fx left-x0)))
		      (check-integer-f-and-dfs fy right-f right-fx left-f left-fx)
		      (shape-slice-driver y fy ,direction 2 rcx
					  right-x right-f right-fx left-x left-f left-fx 2))))
	(half-circle (floor center-y) incf)
	(half-circle (1- (floor center-y)) decf))))

;;; separate-quadrants means that the caller wants to get all points for any one
;;; quadrant before moving on to the next.  This is needed when converting the
;;; points into line segments.
(defun draw-unfilled-circle-driver (center-x center-y radius point-function
				    &optional (separate-quadrants nil))
  (declare (downward-funarg point-function))
  (unless (integerp center-x)
    (setq center-x (round center-x)))
  (unless (integerp center-y)
    (setq center-y (round center-y)))
  (unless (integerp radius)
    (setq radius (round radius)))
  (if (not separate-quadrants)
      (let ((y 0)
	    (f 0)
	    (x radius))
	(loop do 
	  (funcall point-function (+ center-x x) (+ center-y y))
	  (funcall point-function (- center-x x) (- center-y y))
	  (funcall point-function (+ center-x y) (- center-y x))
	  (funcall point-function (- center-x y) (+ center-y x))
	  (setq f (+ f y y 1) y (1+ y))
	  (when ( f x)
	    (setq f (- f x x -1) x (1- x)))
	  (when (> y x)
	    (return))
	  (funcall point-function (+ center-x x) (- center-y y))
	  (funcall point-function (- center-x x) (+ center-y y))
	  (funcall point-function (+ center-x y) (+ center-y x))
	  (funcall point-function (- center-x y) (- center-y x))
	  (when (= y x) (return))))
    	(dotimes (q 4)
	  (macrolet ((quadrant-point (q0 x y)
		       `(when (= q ,q0)
			  (funcall point-function (+ center-x ,x) (+ center-y ,y)))))
	    (let ((y 0)
		  (f 0)
		  (x radius))
	      (loop do 
		(quadrant-point 0 (+ x) (+ y))
		(quadrant-point 2 (- x) (- y))
		(quadrant-point 3 (+ y) (- x))
		(quadrant-point 1 (- y) (+ x))
		(setq f (+ f y y 1) y (1+ y))
		(when ( f x)
		  (setq f (- f x x -1) x (1- x)))
		(when (> y x)
		  (return)))
	      (setq f (- f))
	      (loop do 
		(quadrant-point 0 (+ x) (+ y))
		(quadrant-point 2 (- x) (- y))
		(quadrant-point 3 (+ y) (- x))
		(quadrant-point 1 (- y) (+ x))
		(setq f (+ f x x -1) x (1- x))
		(when ( f y)
		  (setq f (- f y y 1) y (1+ y)))
		(when ( x 0)
		  (return))))))))

;;; 1scale0 is any integer larger than any value of a necessary denominator.
;;; Several times the radius is a safe bet.
(defsubst angle-clipping-line (angle scale)
  (values (round (* scale (sin angle)))
	  (round (* scale (cos angle)))))

;;; Intersect a sector boundary line with the current slice edge.
(defsubst clip-with-start-angle (x y clipping-x clipping-y)
  (if (minusp (- (* clipping-y y) (* clipping-x x)))
      (if (= 0 clipping-x) 0 (round (* clipping-y y) clipping-x))
      x))

(defsubst clip-with-end-angle (x y clipping-x clipping-y)
  (if (plusp (- (* clipping-y y) (* clipping-x x)))
      (if (= 0 clipping-x) 0 (round (* clipping-y y) clipping-x))
      x))

(defmacro shape-ring-slice-driver (y inner-fy outer-fy direction inner-fyy outer-fyy rcx
				   inner-right-x inner-right-f inner-right-fx
				   inner-left-x inner-left-f inner-left-fx inner-fxx
				   outer-right-x outer-right-f outer-right-fx
				   outer-left-x outer-left-f outer-left-fx outer-fxx)
  `(loop named top doing
     (unless (< ,inner-right-x ,rcx)
       (loop while ( ,inner-right-f 0) do
	 (decf ,inner-right-x)
	 (when (< ,inner-right-x ,rcx)
	   (return nil))
	 (decf ,inner-right-fx ,inner-fxx)
	 (decf ,inner-right-f ,inner-right-fx)))
     (unless (< ,inner-right-x ,rcx)
       (loop while (> ,inner-left-f 0) do
	 (incf ,inner-left-x)
	 (incf ,inner-left-f ,inner-left-fx)
	 (incf ,inner-left-fx ,inner-fxx)))
     (loop while ( ,outer-right-f 0) do
       (decf ,outer-right-x)
       (when (< ,outer-right-x ,rcx)
	 (return-from top nil))
       (decf ,outer-right-fx ,outer-fxx)
       (decf ,outer-right-f ,outer-right-fx))
     (loop while (> ,outer-left-f 0) do
       (incf ,outer-left-x)
       (incf ,outer-left-f ,outer-left-fx)
       (incf ,outer-left-fx ,outer-fxx))
     (if (< ,inner-right-x ,rcx)
	 (funcall slice-function (- ,outer-right-x ,outer-left-x) 1 ,outer-left-x ,y)
       (funcall slice-function (- ,outer-right-x ,inner-right-x) 1 ,inner-right-x ,y)
       (funcall slice-function (- ,inner-left-x ,outer-left-x) 1 ,outer-left-x ,y))
	 . ,(ecase direction
	      (incf
		`((incf ,y)
		  (incf ,inner-right-f ,inner-fy)
		  (incf ,inner-left-f ,inner-fy)
		  (incf ,inner-fy ,inner-fyy)
		  (incf ,outer-right-f ,outer-fy)
		  (incf ,outer-left-f ,outer-fy)
		  (incf ,outer-fy ,outer-fyy)))
	      (decf
		`((decf ,y)
		  (decf ,inner-fy ,inner-fyy)
		  (decf ,inner-right-f ,inner-fy)
		  (decf ,inner-left-f ,inner-fy)
		  (decf ,outer-fy ,outer-fyy)
		  (decf ,outer-right-f ,outer-fy)
		  (decf ,outer-left-f ,outer-fy))))))

;;; This runs two copies of draw-circle-driver at once.  You step them separately, so that
;;; the y's stay in synch even though the slopes aren't the same.  When the inner is exhausted,
;;; it turns into just the same as a single version for the outer.
(defun draw-circular-ring-driver (center-x center-y inner-radius outer-radius slice-function)
  (declare (downward-funarg slice-function))
  (assert (> outer-radius inner-radius))
  (if (check-nearly-integer-p center-x center-y inner-radius outer-radius)
      (let* ((inner-x inner-radius)
	     (inner-f (- 1 inner-x))
	     (inner-fx (* inner-radius 2))
	     (inner-fy 2)
	     (outer-x outer-radius)
	     (outer-f (- 1 outer-x))
	     (outer-fx (* outer-radius 2))
	     (outer-fy 2)
	     (y 0))
	(loop named top doing
	  (unless (minusp inner-x)
	    (loop while (> inner-f 0) do
	      (decf inner-x)
	      (when (minusp inner-x)
		(return nil))
	      (decf inner-fx 2)
	      (decf inner-f inner-fx)))
	  (loop while (> outer-f 0) do
	    (decf outer-x)
	    (when (minusp outer-x)
	      (return-from top nil))
	    (decf outer-fx 2)
	    (decf outer-f outer-fx))
	  (if (minusp inner-x)
	      (let ((2x (+ outer-x outer-x))
		    (start-x (- center-x outer-x)))
		(funcall slice-function 2x 1 start-x (+ center-y y))
		(funcall slice-function 2x 1 start-x (- center-y (1+ y))))
	      (let ((dx (- outer-x inner-x))
		    (-y (- center-y (1+ y))))
		(funcall slice-function dx 1 (+ center-x inner-x) (+ center-y y))
		(funcall slice-function dx 1 (+ center-x inner-x) -y)
		(let ((start-x (- center-x outer-x)))
		  (funcall slice-function dx 1 start-x (+ center-y y))
		  (funcall slice-function dx 1 start-x -y))))
	  (incf y)
	  (incf inner-f inner-fy)
	  (incf inner-fy 2)
	  (incf outer-f outer-fy)
	  (incf outer-fy 2)))
      (macrolet ((half-circle (y direction)
		   `(let* ((rcx (round center-x))
			   (y ,y)
			   (y0 (- y center-y -0.5))
			   (inner-fy (1+ (* 2 y0)))
			   (outer-fy inner-fy)
			   (inner-right-x (ceiling (+ center-x inner-radius -0.5)))
			   (inner-right-x0 (- inner-right-x center-x 0.5))
			   (inner-right-f (circle-initial-f inner-right-x0 y0 inner-radius))
			   (inner-right-fx (circle-initial-fx inner-right-x0))
			   (inner-left-x (floor (- center-x inner-radius 0.5)))
			   (inner-left-x0 (- inner-left-x center-x -0.5))
			   (inner-left-f (circle-initial-f inner-left-x0 y0 inner-radius))
			   (inner-left-fx (circle-initial-fx inner-left-x0))
			   (outer-right-x (ceiling (+ center-x outer-radius -0.5)))
			   (outer-right-x0 (- outer-right-x center-x 0.5))
			   (outer-right-f (circle-initial-f outer-right-x0 y0 outer-radius))
			   (outer-right-fx (circle-initial-fx outer-right-x0))
			   (outer-left-x (floor (- center-x outer-radius 0.5)))
			   (outer-left-x0 (- outer-left-x center-x -0.5))
			   (outer-left-f (circle-initial-f outer-left-x0 y0 outer-radius))
			   (outer-left-fx (circle-initial-fx outer-left-x0)))
		      (check-integer-f-and-dfs inner-fy
					       inner-right-f inner-right-fx
					       inner-left-f inner-left-fx )
		      (check-integer-f-and-dfs outer-fy
					       outer-right-f outer-right-fx
					       outer-left-f outer-left-fx)
		      (shape-ring-slice-driver y inner-fy outer-fy ,direction 2 2 rcx
					       inner-right-x inner-right-f inner-right-fx
					       inner-left-x inner-left-f inner-left-fx 2
					       outer-right-x outer-right-f outer-right-fx
					       outer-left-x outer-left-f outer-left-fx 2))))
	(half-circle (floor center-y) incf)
	(half-circle (1- (floor center-y)) decf))))

(defmacro ellipse-initial-f (x0 y0 a2 b2)
  `(- (+ (* ,b2 (* ,x0 ,x0)) (* ,a2 (* ,y0 ,y0))) (* ,a2 ,b2)))

(defmacro ellipse-initial-fx (x0 b2)
  `(* ,b2 (1+ (* 2 ,x0))))

;;; This is more or less the same as draw-circle-driver, except that the formula for
;;; the curve is b^2*x^2+a^2*y^2-a^2*b^2, so the initial conditions are a little different.
(defun draw-ellipse-driver (center-x center-y x-radius y-radius slice-function)
  (declare (downward-funarg slice-function))
  (if (check-nearly-integer-p center-x center-y x-radius y-radius)
      (let* ((x x-radius)
	     (y 0)
	     (a2 (* x-radius x-radius))
	     (b2 (* y-radius y-radius))
	     (f (floor (+ (* b2 (1+ (* x-radius (1- x-radius) 4)))
			  a2
			  (* a2 b2 -4))
		       4))
	     (fx (* 2 b2 x-radius))
	     (fy (* 2 a2))
	     (fxx (* b2 2))
	     (fyy (* a2 2)))
	(loop named top doing
	  (loop while (> f 0) do
	    (decf x)
	    (when (minusp x)
	      (return-from top nil))
	    (decf fx fxx)
	    (decf f fx))
	  (let ((2x (+ x x))
		(start-x (- center-x x)))
	    (funcall slice-function 2x 1 start-x (+ center-y y))
	    (funcall slice-function 2x 1 start-x (- center-y (1+ y))))
	  (incf y)
	  (incf f fy)
	  (incf fy fyy)))
      (macrolet ((half-ellipse (y direction)
		   `(let* ((rcx (round center-x))
			   (y ,y)
			   (y0 (- y center-y -0.5))
			   (a2 (* x-radius x-radius))
			   (b2 (* y-radius y-radius))
			   (fy (ellipse-initial-fx y0 a2))
			   (fyy (* a2 2))
			   (fxx (* b2 2))
			   (right-x (ceiling (+ center-x x-radius -0.5)))
			   (right-x0 (- right-x center-x 0.5))
			   (right-f (ellipse-initial-f right-x0 y0 a2 b2))
			   (right-fx (ellipse-initial-fx right-x0 b2))
			   (left-x (floor (- center-x x-radius 0.5)))
			   (left-x0 (- left-x center-x -0.5))
			   (left-f (ellipse-initial-f left-x0 y0 a2 b2))
			   (left-fx (ellipse-initial-fx left-x0 b2)))
		      (when (check-nearly-integer-p fxx fyy)
			(check-integer-f-and-dfs fy right-f right-fx left-f left-fx))
		      (shape-slice-driver y fy ,direction fyy rcx
					  right-x right-f right-fx
					  left-x left-f left-fx fxx))))
	(half-ellipse (floor center-y) incf)
	(half-ellipse (1- (floor center-y)) decf))))

(defun draw-elliptical-ring-driver (center-x center-y
				    inner-x-radius inner-y-radius
				    outer-x-radius outer-y-radius
				    slice-function)
  (declare (downward-funarg slice-function))
  (assert (> outer-x-radius inner-x-radius))
  (assert (> outer-y-radius inner-y-radius))
  (if (check-nearly-integer-p center-x center-y
			      inner-x-radius inner-y-radius
			      outer-x-radius outer-y-radius)
      (let* ((inner-x inner-x-radius)
	     (inner-a2 (* inner-x-radius inner-x-radius))
	     (inner-b2 (* inner-y-radius inner-y-radius))
	     (inner-f (floor (+ (* inner-b2 (1+ (* inner-x-radius (1- inner-x-radius) 4)))
				inner-a2
				(* inner-a2 inner-b2 -4))
			     4))
	     (inner-fx (* 2 inner-b2 inner-x-radius))
	     (inner-fy (* 2 inner-a2))
	     (inner-fxx (* inner-b2 2))
	     (inner-fyy (* inner-a2 2))
	     (outer-x outer-x-radius)
	     (outer-a2 (* outer-x-radius outer-x-radius))
	     (outer-b2 (* outer-y-radius outer-y-radius))
	     (outer-f (floor (+ (* outer-b2 (1+ (* outer-x-radius (1- outer-x-radius) 4)))
				outer-a2
				(* outer-a2 outer-b2 -4))
			     4))
	     (outer-fx (* 2 outer-b2 outer-x-radius))
	     (outer-fy (* 2 outer-a2))
	     (outer-fxx (* outer-b2 2))
	     (outer-fyy (* outer-a2 2))
	     (y 0))
	(loop named top doing
	  (unless (minusp inner-x)
	    (loop while (> inner-f 0) do
	      (decf inner-x)
	      (when (minusp inner-x)
		(return nil))
	      (decf inner-fx inner-fxx)
	      (decf inner-f inner-fx)))
	  (loop while (> outer-f 0) do
	    (decf outer-x)
	    (when (minusp outer-x)
	      (return-from top nil))
	    (decf outer-fx outer-fxx)
	    (decf outer-f outer-fx))
	  (if (minusp inner-x)
	      (let ((2x (+ outer-x outer-x))
		    (start-x (- center-x outer-x)))
		(funcall slice-function 2x 1 start-x (+ center-y y))
		(funcall slice-function 2x 1 start-x (- center-y (1+ y))))
	      (let ((dx (- outer-x inner-x))
		    (-y (- center-y (1+ y))))
		(funcall slice-function dx 1 (+ center-x inner-x) (+ center-y y))
		(funcall slice-function dx 1 (+ center-x inner-x) -y)
		(let ((start-x (- center-x outer-x)))
		  (funcall slice-function dx 1 start-x (+ center-y y))
		  (funcall slice-function dx 1 start-x -y))))
	  (incf y)
	  (incf inner-f inner-fy)
	  (incf inner-fy inner-fyy)
	  (incf outer-f outer-fy)
	  (incf outer-fy outer-fyy)))
      (macrolet ((half-ellipse (y direction)
		   `(let* ((rcx (round center-x))
			   (y ,y)
			   (y0 (- y center-y -0.5))
			   (inner-a2 (* inner-x-radius inner-x-radius))
			   (inner-b2 (* inner-y-radius inner-y-radius))
			   (inner-fy (ellipse-initial-fx y0 inner-a2))
			   (inner-fyy (* inner-a2 2))
			   (inner-fxx (* inner-b2 2))
			   (inner-right-x (ceiling (+ center-x inner-x-radius -0.5)))
			   (inner-right-x0 (- inner-right-x center-x 0.5))
			   (inner-right-f (ellipse-initial-f inner-right-x0 y0
							     inner-a2 inner-b2))
			   (inner-right-fx (ellipse-initial-fx inner-right-x0 inner-b2))
			   (inner-left-x (floor (- center-x inner-x-radius 0.5)))
			   (inner-left-x0 (- inner-left-x center-x -0.5))
			   (inner-left-f (ellipse-initial-f inner-left-x0 y0
							    inner-a2 inner-b2))
			   (inner-left-fx (ellipse-initial-fx inner-left-x0 inner-b2))
			   (outer-a2 (* outer-x-radius outer-x-radius))
			   (outer-b2 (* outer-y-radius outer-y-radius))
			   (outer-fy (ellipse-initial-fx y0 outer-a2))
			   (outer-fyy (* outer-a2 2))
			   (outer-fxx (* outer-b2 2))
			   (outer-right-x (ceiling (+ center-x outer-x-radius -0.5)))
			   (outer-right-x0 (- outer-right-x center-x 0.5))
			   (outer-right-f (ellipse-initial-f outer-right-x0 y0
							     outer-a2 outer-b2))
			   (outer-right-fx (ellipse-initial-fx outer-right-x0 outer-b2))
			   (outer-left-x (floor (- center-x outer-x-radius 0.5)))
			   (outer-left-x0 (- outer-left-x center-x -0.5))
			   (outer-left-f (ellipse-initial-f outer-left-x0 y0
							    outer-a2 outer-b2))
			   (outer-left-fx (ellipse-initial-fx outer-left-x0 outer-b2)))
		      (when (check-nearly-integer-p inner-fxx inner-fyy)
			(check-integer-f-and-dfs inner-fy
						 inner-right-f inner-right-fx
						 inner-left-f inner-left-fx))
		      (when (check-nearly-integer-p outer-fxx outer-fyy)
			(check-integer-f-and-dfs outer-fy
						 outer-right-f outer-right-fx
						 outer-left-f outer-left-fx))
		      (shape-ring-slice-driver y inner-fy outer-fy ,direction
					       inner-fyy outer-fyy rcx
					       inner-right-x inner-right-f inner-right-fx
					       inner-left-x inner-left-f inner-left-fx
					       inner-fxx
					       outer-right-x outer-right-f outer-right-fx
					       outer-left-x outer-left-f outer-left-fx
					       outer-fxx))))
	(half-ellipse (floor center-y) incf)
	(half-ellipse (1- (floor center-y)) decf))))

;;; Used for :thickness 0, hence a faster algorithm.
(defun draw-unfilled-ellipse-driver (center-x center-y x-radius y-radius point-function
				     &optional (separate-quadrants nil))
  (declare (downward-funarg point-function))
  (unless (integerp center-x)
    (setq center-x (round center-x)))
  (unless (integerp center-y)
    (setq center-y (round center-y)))
  (unless (integerp x-radius)
    (setq x-radius (round x-radius)))
  (unless (integerp y-radius)
    (setq y-radius (round y-radius)))
  (flet ((quadrant (a b point-function)
	   (declare (sys:downward-funarg point-function))
	   (let* ((x a)
		  (y 0)
		  (asq (* a a))
		  (bsq (* b b))
		  (t8 (* 4 a bsq))
		  (d1 (+ (- (* asq 2) (* a bsq 2)) (/ bsq 2)))
		  (d2 (+ (- (/ asq 2) t8) (* 2 bsq)))
		  (4asq (* 4 asq))
		  (2asq (* 2 asq))
		  (4bsq (* 4 bsq))
		  (2bsq (* 2 bsq))
		  (temp 0))
	     (loop while (minusp d2)		;"Y major" half of the ellipse.
		   do
	       (funcall point-function x y)
	       (incf y)
	       (incf temp 4asq)
	       (cond ((< d1 0)
		      (setq d1 (+ d1 temp 2asq))
		      (incf d2 temp))
		     (t
		      (decf x)
		      (decf t8 4bsq)
		      (setq d1 (- (+ d1 temp 2asq) t8))
		      (setq d2 (- (+ d2 temp 2bsq) t8)))))
	     (loop do				;"X major" half of the ellipse.
	       (funcall point-function x y)
	       (decf x)
	       (decf t8 4bsq)
	       (cond ((< d2 0)
		      (incf y)
		      (incf temp 4asq)
		      (setq d2 (- (+ d2 2bsq temp) t8)))
		     (t
		      (setq d2 (- (+ d2 2bsq) t8))))
		   until (minusp x)))))
    (if (not separate-quadrants)
	(quadrant x-radius y-radius
		  #'(lambda (x y)
		      (funcall point-function (+ center-x x) (+ center-y y))
		      (funcall point-function (- center-x x) (+ center-y y))
		      (when (plusp y)
			(funcall point-function (- center-x x) (- center-y y))
			(funcall point-function (+ center-x x) (- center-y y)))))
      (quadrant x-radius y-radius
		#'(lambda (x y)
		    (funcall point-function (+ center-x x) (+ center-y y))))
      (quadrant y-radius x-radius
		#'(lambda (y x)
		    (funcall point-function (- center-x x) (+ center-y y))))
      (quadrant x-radius y-radius
		#'(lambda (x y)
		    (funcall point-function (- center-x x) (- center-y y))))
      (quadrant y-radius x-radius
		#'(lambda (y x)
		    (funcall point-function (+ center-x x) (- center-y y)))))))

;;; Given a tilted ellipse, return the location of the two of the four
;;; maxima for each of the two coordinates -- the other two maxima being
;;; reflections of these two about the center.
(defun ellipse-limits (x-radius y-radius rotation shear-x)
  (declare (values max-x y-at-max-x x-at-max-y max-y x-at-y=0))
  ;; Symmetrical about the center, keep answers positive.
  (setq rotation (mod rotation pi))
  (let ((sin (sin rotation))
	(cos (cos rotation)))
    (cond ((zerop sin)
	   (values (* cos x-radius shear-x) 0 0 (* cos y-radius) (* cos x-radius shear-x)))
	  ((zerop cos)
	   (values (* sin y-radius shear-x) 0 0 (* sin x-radius) (* sin y-radius shear-x)))
	  (t
	   (let* ((tan (tan rotation))
		  (yr2 (expt y-radius 2))
		  (sqr1 (sqrt (+ (expt (/ (* y-radius tan) x-radius) 2) 1)))
		  (sqr2 (sqrt (+ (expt (/ y-radius (* x-radius tan)) 2) 1)))
		  (max-x (+ (/ (* x-radius cos) sqr1)
			    (/ (* yr2 sin tan) (* x-radius sqr1))))
		  (max-x-y (- (/ (* x-radius sin) sqr1)
			      (/ (* yr2 cos tan) (* x-radius sqr1))))
		  (max-y-x (- (/ (* x-radius cos) sqr2)
			      (/ (* yr2 sin) (* x-radius sqr2 tan))))
		  (max-y (+ (/ (* x-radius sin) sqr2)
			    (/ (* yr2 cos) (* x-radius sqr2 tan))))
		  (x0 (sqrt (let ((theta (- (atan (* tan (/ x-radius y-radius))))))
			      (+ (expt (* x-radius (cos theta)) 2)
				 (expt (* y-radius (sin theta)) 2))))))
	     (setq max-x (* max-x shear-x)
		   max-y-x (* max-y-x shear-x)
		   x0 (* x0 shear-x))
	     (when (minusp max-x)
	       (setq max-x (- max-x) max-x-y (- max-x-y)))
	     (when (minusp max-y)
	       (setq max-y (- max-y) max-y-x (- max-y-x)))
	     (values (float max-x 0.0) (float max-x-y 0.0)
		     (float max-y-x 0.0) (float max-y 0.0)
		     (float x0 0.0)))))))

;;; Draw a Be'zier parameterization of a cubic parabola.
;;; The curve passes through 1start-x0,1start-y0 and 1end-x0,1end-y0.  The vector from
;;; 1start-x,start-y0 to 1control-1-x,control-1-y0 determines the slope of the curve there.
;;; It's length determines the next derivative.  Similarly at the other end.
;;; The parametic form of the curve is 2t0^3*P2+(1-2t0)^3*P1-32t0(1-2t0)^2*Pc1+32t0^2(1-2t0)*Pc2.
;;; Thus the curve is also bounded by the quadrilateral determined by the four points.
(define-graphics-generic draw-bezier-curve (start-x start-y end-x end-y
					    control-1-x control-1-y control-2-x control-2-y
					    &key (number-of-samples 10))
  (:standard-arguments :lines)
  (:argument-types (point (start-x start-y)
			  (end-x end-y)
			  (control-1-x control-1-y)
			  (control-2-x control-2-y))
		   (integer number-of-samples))
  (:binary-opcode 9)
  (:screen-method )
  (:default-method
    (draw-path #'(lambda (stream)
		   (set-current-position start-x start-y :stream stream)
		   (draw-bezier-curve-to end-x end-y
					 control-1-x control-1-y
					 control-2-x control-2-y
					 :number-of-samples number-of-samples
					 :stream self))
	       :filled nil :stream self))
  )

(defmacro with-points-from-x-and-y-vectors ((points px py &optional npoints)
					    &body body)
  `(with-data-stack
     (let ((,points (copy-points-from-x-and-y-vectors ,px ,py ,npoints)))
       . ,body)))

(defun copy-points-from-x-and-y-vectors (px py npoints)
  (let* ((npoints (or npoints (vector-length px)))
	 (points (make-stack-array (* npoints 2))))
    (loop for i below npoints
	  for j from 0 by 2
	  do
      (setf (aref points j) (aref px i))
      (setf (aref points (1+ j)) (aref py i)))
    points))

;;; Draw a smooth curve through a sequence of points.  Each piece of the curve is a section
;;; of a cubic chosen to keep the slopes the same.
;;;  (see below for argument descriptions).
(define-graphics-generic draw-cubic-spline
			 (points &rest args
				 &key (start-relaxation :relaxed)
				      (end-relaxation start-relaxation)
				      start-slope-dx start-slope-dy
				      end-slope-dx end-slope-dy
				      (number-of-samples 20)
				 &allow-other-keys)
  (:standard-arguments :lines)
  (:argument-types (point-sequence points)
		   (((member :relaxed :clamped :cyclic :anti-cyclic))
		    start-relaxation end-relaxation)
		   (number start-slope-dx start-slope-dy end-slope-dx end-slope-dy)
		   (((integer (0))) number-of-samples))
  (:binary-opcode 10)
  (:default-method
    (with-data-stack 
      (let ((result-points (compute-cubic-spline-points-internal points
			     :start-relaxation start-relaxation
			     :end-relaxation end-relaxation
			     :start-slope-dx start-slope-dx :start-slope-dy start-slope-dy
			     :end-slope-dx end-slope-dx :end-slope-dy end-slope-dy
			     :number-of-samples number-of-samples)))
	(si:with-rem-keywords (some-args args '(:start-relaxation :end-relaxation
						:start-slope-dx :start-slope-dy
						:end-slope-dx :end-slope-dy
						:number-of-samples))
	  (apply (flavor:generic draw-lines) self result-points
		 :closed (member start-relaxation '(:cyclic :anti-cyclic))
		 some-args))))))

(defun compute-cubic-spline-points (points &rest args)
  (declare (arglist (points &key (start-relaxation :relaxed)
				 (end-relaxation start-relaxation)
				 start-slope-dx start-slope-dy
				 end-slope-dx end-slope-dy
				 (number-of-samples 20)))
	   (values points))
  (with-data-stack
    (copy-seq (apply #'compute-cubic-spline-points-internal points args))))

;;; Must be called within a with-data-stack.  Returns a data-stack array of points.
(defun compute-cubic-spline-points-internal (points &key (start-relaxation :relaxed)
							 (end-relaxation start-relaxation)
							 start-slope-dx start-slope-dy
							 end-slope-dx end-slope-dy
							 (number-of-samples 20)	;?
							 )
  (let* ((npoints (floor (length points) 2))
	 (px (make-stack-array npoints))
	 (py (make-stack-array npoints)))
    (let ((i 0)
	  (ox nil)
	  (oy nil))
      (map-points #'(lambda (x y ignore)
		      (unless (and (eql x ox) (eql y oy))	;Doesn't like duplicates.
			(setf (aref px i) x)
			(setf (aref py i) y)
			(setq ox x oy y)
			(incf i)))
		  points)
      (unless (= i npoints)
	(adjust-array px i)
	(adjust-array py i)
	(setq npoints i)))
    #||						;would this be better
    (unless number-of-samples
      (setq number-of-samples (max (loop as ox = nil then x
					 for x being the array-elements of px
					 when ox
					   maximize (abs (- x ox)))
				   (loop as oy = nil then y
					 for y being the array-elements of py
					 when oy
					   maximize (abs (- y oy))))))
    ||#
    (let* ((result-npoints (+ npoints (* number-of-samples (1- npoints))))
	   (result-x (make-stack-array result-npoints))
	   (result-y (make-stack-array result-npoints)))
      (multiple-value-setq (result-x result-y result-npoints)
	(compute-cubic-spline px py number-of-samples result-x result-y
			      start-relaxation end-relaxation
			      start-slope-dx start-slope-dy end-slope-dx end-slope-dy))
      (copy-points-from-x-and-y-vectors result-x result-y result-npoints))))

;;; Cubic splines from Rogers and Adams, "Mathematical Elements
;;; for Computer Graphics".  This began as a translation from
;;; a BASIC program, but has been changed a bit.  The original
;;; program uses a full matrix inversion when the boundary conditions
;;; are cyclic or anti-cyclic, which is inefficient; in this version
;;; the special-case tridiagonal solver is extended to handle the
;;; cyclic and anti-cyclic end conditions.  (Also, the original program
;;; has a bug wherein it neglects to initialize one diagonal of the M matrix.)

;;; The caller has a sequence of points, in PX and PY, through which he
;;; wants a smooth curve drawn.  This program generates Z intermediate
;;; points between each pair of points, returning a sequence of points
;;; in CX and CY that includes the original points with the intermediate
;;; points inserted.  The caller can then plot lines between successive
;;; pairs of points of CX and CY to draw the curve.

;;; The caller may pass in arrays to be filled in with the answers (used as
;;; CX and CY); they should be (+ N (* Z (- N 1))) long.  If NIL is passed,
;;; this function creates the arrays itself.  If they are not long enough,
;;; they are adjusted with ADJUST-ARRAY-SIZE.  The optional argument C1 is
;;; the initial end condition, one of :RELAXED, :CLAMPED, :CYCLIC, or
;;; :ANTI-CYCLIC; C2 is the final end condition, one of :RELAXED or
;;; :CLAMPED.  The first defaults to :RELAXED, and the second defaults
;;; to the first.  The second must be the same as the first if the
;;; first is :CYCLIC or :ANTI-CYCLIC.  The last four arguments are
;;; the X and Y values to which the endpoints are being clamped if
;;; the corresponding boundary condition is :CLAMPED.  For cyclic splines
;;; that join themselves, the caller must pass the same point twice, as
;;; both the first point and the last point.

;;; Three values are returned: The two arrays CX and CY, and the number
;;; of elements in the original P array.

(defun compute-cubic-spline (px py z &optional cx cy (c1 :relaxed) (c2 c1)
			     p1-prime-x p1-prime-y pn-prime-x pn-prime-y
			     &aux n n-1 n-2 n-3 bx by l ux uy n1 n2 n3 n4 sign)
 (without-floating-underflow-traps
   (with-data-stack
     (setq n (sys:array-active-length px)		;The number of points
	   n-1 (1- n)
	   n-2 (1- n-1)
	   n-3 (1- n-2))
   
     ;; Create the arrays if they were not given them, or redimension them if needed.
     (let ((clen (+ n (* n-1 z))))
       (cond ((null cx)
	      (setq cx (make-array clen)))
	     ((< (sys:array-length cx) clen)
	      (setq cx (sys:adjust-array-size cx clen))))
       (cond ((null cy)
	      (setq cy (make-array clen)))
	     ((< (sys:array-length cy) clen)
	      (setq cy (sys:adjust-array-size cy clen)))))
   
     ;; Set up L to hold the approximate spline segment lengths.
     ;; The Nth element of L holds the distance between the Nth and N+1st
     ;; points of PX,PY.  The last element of L is not used.
     (setq l (make-stack-array n))
     (loop for j from 0 to n-2
	   do (setf (aref l j)
		    (sqrt (+ (expt (- (aref px (1+ j)) (aref px j)) 2)
			     (expt (- (aref py (1+ j)) (aref py j)) 2)))))
   
     ;; The bulk of the code here is concerned with solving a set of
     ;; simultaneous linear equations, expressed by the matrix equation
     ;; M * U = B.  M is an N by N square matrix, and B and U are N by 1
     ;; column matricies.  U will hold the values of the slope of the curve
     ;; at each point PX, PY.
   
     ;; The M matrix is tridiagonal for :RELAXED and :CLAMPED end conditions.
     ;; We represent it by storing M(I,I-1) in N1(I), M(I,I) in N2(I), and
     ;; M(I,I+1) in N3(I).  This means N1(0) and N3(N-1) are unused.
     (setq n1 (make-stack-array n)
	   n2 (make-stack-array n)
	   n3 (make-stack-array n))
   
     ;; These quantities are meaningless, but they get referred to as part
     ;; of array bound conditions; these values just prevent errors from happening.
     (setf (aref n1 0) 0.0)
     (setf (aref n3 n-1) 0.0)
   
     (ecase c1
       ((:cyclic :anti-cyclic)
	;; With these conditions, the M matrix is not quite tri-diagonal;
	;; it is initialize with a 1 in the upper-right hand corner, and
	;; during the solution of the equations the whole right column
	;; gets non-zero values.  Also, it is only N-1 by N-1!  So the upper
	;; right corner is M(0, N-2).  N4 represents the N-2 column; element
	;; M(I,N-2) is stored in N4(I).  The last two elements are not
	;; used, because N4(N-2) = N2(N-2) and N4(N-3) = N3(N-3).  We also
	;; set up this handy SIGN variable.
	(setq n4 (make-stack-array (1- n)))
	(setq sign (if (eq c1 :cyclic) 1.0 -1.0)))
       ((:relaxed :clamped) ))
     ;; B is just a column vector, represented normally.
     (setq bx (make-stack-array n)
	   by (make-stack-array n))
   
     ;; Set up the boundary conditions.
     ;; The 0th row of M and B are determined by the initial boundary conditions,
     ;; and the N-1st row is determined by the final boundary condition.
     ;; Note that the 0th row of M is implemented as the 0th element of N2, N3,
     ;; and sometimes N4; N1(0) is not used.  A similar thing is true of the
     ;; N-1st row.
     (ecase c1
       (:clamped
	  (setf (aref n2 0) 1.0)
	  (setf (aref n3 0) 0.0)
	  (setf (aref bx 0) p1-prime-x)
	  (setf (aref by 0) p1-prime-y))
       (:relaxed
	  (setf (aref n2 0) 1.0)
	  (setf (aref n3 0) 0.5)
	  (let ((tem (/ 3.0 (* 2.0 (aref l 0)))))
	    (setf (aref bx 0) (* tem (- (aref px 1) (aref px 0))))
	    (setf (aref by 0) (* tem (- (aref py 1) (aref py 0))))))
       ((:cyclic :anti-cyclic)
	  (let ((s3 (/ (aref l n-2) (aref l 0))))
	    (setf (aref n2 0) (+ 2.0 (* s3 2.0)))
	    (setf (aref n3 0) s3)
	    (setf (aref n4 0) sign)
	    (let ((tem (/ 3.0 (aref l 0))))
	      (setf (aref bx 0)
		    (* tem (+ (* s3 (- (aref px 1) (aref px 0)))
			      (* sign (/ (- (aref px n-1) (aref px n-2)) s3)))))
	      (setf (aref by 0)
		    (* tem (+ (* s3 (- (aref py 1) (aref py 0)))
			      (* sign (/ (- (aref py n-1) (aref py n-2)) s3)))))))))
     (ecase c2
       (:clamped
	  (setf (aref n1 n-1) 0.0)
	  (setf (aref n2 n-1) 1.0)
	  (setf (aref bx n-1) pn-prime-x)
	  (setf (aref by n-1) pn-prime-y))
       (:relaxed
	  (setf (aref n1 n-1) 2.0)
	  (setf (aref n2 n-1) 4.0)
	  (let ((tem (/ 6.0 (aref l n-2))))
	    (setf (aref bx n-1) (* tem (- (aref px n-1) (aref px n-2))))
	    (setf (aref by n-1) (* tem (- (aref py n-1) (aref py n-2))))))
       ;; Note: there are no final end conditions for :CYCLIC and :ANTI-CYCLIC,
       ;; since they are the same at each end.  The M matrix has no N-1st row,
       ;; either, as it is smaller by one row and one column.
       ((:cyclic :anti-cyclic))
       )
   
     ;; Now fill in the insides of M and B arrays.
     (loop for j from 1 to n-2
	   as l0 = (aref l 0) then l1
	   as l1 = (aref l 1) then (aref l j)
	   as px0 = (aref px 0) then px1
	   as px1 = (aref px 1) then px2
	   as px2 = (aref px (1+ j))
	   as py0 = (aref py 0) then py1
	   as py1 = (aref py 1) then py2
	   as py2 = (aref py (1+ j))
	   do
       (setf (aref n1 j) l1)
       (setf (aref n2 j) (* 2 (+ l0 l1)))
       (setf (aref n3 j) l0)
       (if n4 (setf (aref n4 j) 0.0))
       (setf (aref bx j)
	     (/ (* 3.0 (+ (* (expt l0 2) (- px2 px1)) (* (expt l1 2) (- px1 px0))))
		(* l0 l1)))
       (setf (aref by j)
	     (/ (* 3.0 (+ (* (expt l0 2) (- py2 py1)) (* (expt l1 2) (- py1 py0))))
		(* l0 l1))))
   
     ;; Now that we have the matricies filled in, we solve the equations.
     ;; We use Gaussian elimination, with a special version that takes
     ;; advantage of the sparsity of this tridiagonal or almost-tridiagonal
     ;; matrix to run in time O(n) instead of O(n**3).  No pivoting is used,
     ;; because for any real dat (not all zeroes, for example) the matrix
     ;; is both irreducible and diagonally-dominant, and therefore pivoting
     ;; is not needed (Forsythe and Moler, p. 117,  exercise 23.10).
     ;; The first step is to make the matrix upper-triangular, by making all of
     ;; N1 be zero.
     (let ((q (aref n2 0)))				;Normalize row 0.
       (setf (aref n3 0) (/ (aref n3 0) q))
       (if n4 (setf (aref n4 0) (/ (aref n4 0) q)))
       (setf (aref bx 0) (/ (aref bx 0) q))
       (setf (aref by 0) (/ (aref by 0) q)))
     (loop for i from 1 to (if (null n4) n-1 n-2)
	   as n1i = (aref n1 i)
	   when (not (zerop n1i))				;If it is zero already, OK.
	   do (let ((d (/ 1.0 n1i)))
		;; D = M(I-1, I-1) / M(I, I-1)  so multiply row I
		;;   by D and subtract row I-1 from row I.
		(setf (aref n2 i) (- (* d (aref n2 i)) (aref n3 (1- i))))
		(setf (aref n3 i) (* d (aref n3 i))) ; Uses N3(N-1), a garbage element.
		(cond (n4
		       (setf (aref n4 i) (- (* d (aref n4 i)) (aref n4 (1- i))))
		       (if (= i n-3)
			   ;; In this case, N4(N-4) is above N3(N-3), so
			   ;; it must be subtracted out.
			   (setf (aref n3 i) (- (aref n3 i) (aref n4 (1- i)))))))
		(setf (aref bx i) (- (* d (aref bx i)) (aref bx (1- i))))
		(setf (aref by i) (- (* d (aref by i)) (aref by (1- i))))
		)
	   ;; Next normalize, by dividing row I through by M(I,I).
	   ;; This leaves the center diagonal all 1.0, which the
	   ;; back-solver in R&A doesn't take advantage of.
	      (let ((q (aref n2 i)))
		(setf (aref n3 i) (/ (aref n3 i) q))
		(if n4 (setf (aref n4 i) (/ (aref n4 i) q)))
		(setf (aref bx i) (/ (aref bx i) q))
		(setf (aref by i) (/ (aref by i) q))))
   
     ;; Create the arrays to hold the answers.
     (setq ux (make-stack-array n)		;Tangent vector matrix
	   uy (make-stack-array n))
   
     ;; Backsolve the upper-triangular matrix.
     (cond ((not n4)
	    ;; Simpler version if there is no N4.
	    (setf (aref ux n-1) (aref bx n-1))
	    (setf (aref uy n-1) (aref by n-1))
	    (loop for j from n-2 downto 0
		  do (let ((n3j (aref n3 j)))
		       (setf (aref ux j) (- (aref bx j) (* n3j (aref ux (1+ j)))))
		       (setf (aref uy j) (- (aref by j) (* n3j (aref uy (1+ j))))))))
	   (t
	    ;; Hairier version with N4.
	    (let ((uxn-2 (aref bx n-2))
		  (uyn-2 (aref by n-2)))
	      (setf (aref ux n-2) uxn-2)
	      (setf (aref uy n-2) uyn-2)
	      (setf (aref ux n-3) (- (aref bx n-3) (* (aref n3 n-3) uxn-2)))
	      (setf (aref uy n-3) (- (aref by n-3) (* (aref n3 n-3) uyn-2)))
	      (loop for j from (1- n-3) downto 0
		    do (let ((n3j (aref n3 j))
			     (n4j (aref n4 j)))
			 (setf (aref ux j)
			       (- (aref bx j)
				  (* n3j (aref ux (1+ j)))
				  (* n4j uxn-2)))
			 (setf (aref uy j)
			       (- (aref by j)
				  (* n3j (aref uy (1+ j)))
				  (* n4j uyn-2))))))
	    (setf (aref ux n-1) (* sign (aref ux 0)))
	    (setf (aref uy n-1) (* sign (aref uy 0)))))
   
     (multiple-value-setq (cx cy)
       (cubic-spline-curgen n px py z cx cy l ux uy))		; Generate it
   
     (values cx cy (sys:array-active-length cx)))))

;;; Generate the spline curve points.
;;; This is a separate function because if it got merged, there would
;;; be too many local variables.

(defun cubic-spline-curgen (n px py z cx cy l ux uy)
  (loop with i = 0
	for j from 0 to (- n 2)
	for len = (aref l j)
	for len^2 = (expt len 2)
	for len^3 = (* len^2 len)
	for fx1 = (aref px j)
	for fx2 = (aref ux j)
	for temx = (- (aref px (1+ j)) fx1)
	for temx1 = (+ (aref ux (1+ j)) fx2)
	for fx3 = (- (* (/ 3.0 len^2) temx) (/ (+ temx1 fx2) len))
	for fx4 = (+ (* (/ -2.0 len^3) temx) (/ temx1 len^2))
	for fy1 = (aref py j)
	for fy2 = (aref uy j)
	for temy = (- (aref py (1+ j)) fy1)
	for temy1 = (+ (aref uy (1+ j)) fy2)
	for fy3 = (- (* (/ 3.0 len^2) temy) (/ (+ temy1 fy2) len))
	for fy4 = (+ (* (/ -2.0 len^3) temy) (/ temy1 len^2))
	;;+++ I suspect this'd be somewhat faster if it used the
	;;coefficients in difference formulae to avoid the exponentiation.
	do (loop repeat (1+ z)
		 for x from 0 by (/ len (1+ z))
		 do (setf (aref cx i) (+ fx1 (* fx2 x) (* fx3 (expt x 2)) (* fx4 (expt x 3))))
		    (setf (aref cy i) (+ fy1 (* fy2 x) (* fy3 (expt x 2)) (* fy4 (expt x 3))))
		    (setq i (1+ i)))
	finally (progn (setf (aref cx i) (float (aref px (1- n))))
		       (setf (aref cy i) (float (aref py (1- n))))
		       (return (values cx cy)))))

;;; A path is just a function of a stream that draws lines, curves, and so on.
;;; 1:winding-rule0 (default :non-zero): controls filling of the region.
;;;  1:non-zero0: a point is within the area to be filled if a line from infinity to the point
;;;   passes through the curve going up a different number of times than it passes through
;;;   going down.
;;;  1:odd-even0: a point is within the area to be filled if a line from infinity to the point
;;;   passes through the curve an odd number of times.
(define-graphics-generic draw-path (path-function &key (winding-rule :non-zero))
  (:standard-arguments :outline)
  (:argument-types (output-function path-function)
		   (((member :non-zero :odd-even)) winding-rule))
  (:binary-opcode 11)
  )

;;; Like 1draw-path0, but with 1progn0 semantics.
;;; Note that this has to collect the values itself, because not enough of the draw-path
;;; methods can be relied on to return the path function's values.
(defmacro drawing-path ((&optional stream &rest draw-path-args)
			&body body)
  (dw::format-output-macro-default-stream stream)
  `(let ((.values. nil))
     (draw-path (dw::named-continuation drawing-path (,stream)
		  (setq .values. (multiple-value-list (progn . ,body))))
		:stream ,stream . ,draw-path-args)
     (values-list .values.)))

(defstruct (line-entry :grouped-array (:constructor nil) (:copier nil))
  x1 y1 x2 y2)

;;; This is optimized for a large number of small lines, making it better for filling
;;; blobs than polygons.  But since we have special polygon drawing, that's okay.
;;; 1slice-function0 is called with start-x,end-x,y.
(defun fill-from-lines (lines minimum-y maximum-y winding-rule slice-function)
  (when (zerop (fill-pointer lines))
    (return-from fill-from-lines nil))
  (let ((nlines (1+ (- maximum-y minimum-y))))
    (with-data-stack
      (let ((line-intersections (make-stack-array nlines)))
	(loop for index below (fill-pointer lines) by 4 do
	  (let* ((line-y1 (line-entry-y1 index lines))
		 (line-y2 (line-entry-y2 index lines))
		 (dy (- line-y2 line-y1))
		 (line-x1 (line-entry-x1 index lines))
		 (line-x2 (line-entry-x2 index lines))
		 (dx (- line-x2 line-x1)))
	    (if (zerop dy)
		;; Horizontal line doesn't affect boundaries when scanning this way.
		(funcall slice-function (min line-x2 line-x1) (max line-x2 line-x1) line-y1)
	      (loop repeat (abs dy)
		    for y from (min line-y1 line-y2)
		    do
		(multiple-value-bind (intersection-x vertex-p)
		    (cond ((= y line-y1) (values line-x1 t))
			  ((= y line-y2) (values line-x2 t))
			  (t
			   (values
			     (let ((delta-x (* (- y line-y1) dx)))
			       (+ line-x1
				  (/ (if (and (integerp delta-x)
					      (not (zerop (mod delta-x dy))))
					 ;; Avoid ratios, since they cons
					 (float delta-x)
					 delta-x)
				     dy))))))
		  (let ((matching-lines (aref line-intersections (- y minimum-y))))
		    (when (null matching-lines)
		      (setq matching-lines (make-stack-array (* 3 4) :fill-pointer 0))
		      (setf (aref line-intersections (- y minimum-y)) matching-lines))
		    (vector-push-extend intersection-x matching-lines)
		    (vector-push-extend (signum dy) matching-lines)
		    (vector-push-extend (and vertex-p index) matching-lines)))))))
	(dotimes (raster-y nlines)
	  (let ((slice-y (+ raster-y minimum-y))
		(matching-lines (aref line-intersections raster-y)))
	    (when matching-lines
	      (sort-grouped-array matching-lines 3 #'<)
	      ;; Check for the scan line intersecting a vertex that isn't a local maximum
	      ;; or minimum.  In this case, we will mistakenly count two transitions for
	      ;; what is really one point.  So, remove one of the offenders.
	      (let ((length (- (fill-pointer matching-lines) 3)))
		(loop for match below length by 3 do
		  (let ((x (aref matching-lines match)))
		    (when (= x (aref matching-lines (+ match 3)))
		      (flet ((which-way (match)
			       (let ((index (aref matching-lines (+ match 2))))
				 (when index	;A vertex of one kind of another
				   (let ((x1 (line-entry-x1 index lines))
					 (x2 (line-entry-x2 index lines))
					 (y1 (line-entry-y1 index lines))
					 (y2 (line-entry-y2 index lines)))
				     (cond ((= x x1) (values (> y2 y1) t))
					   ((= x x2) (values (> y1 y2) t))))))))
			(multiple-value-bind (this-a-max this-a-corner)
			    (which-way match)
			  (multiple-value-bind (that-a-max that-a-corner)
			      (which-way (+ match 3))
			    (when (and this-a-corner that-a-corner
				       (neq this-a-max that-a-max))
			      ;; This is a vertex, but not a maximum or minimum, remove
			      ;; one of the entries.
			      (when (< match length)
				(replace matching-lines matching-lines
					 :start1 match :start2 (+ match 3)))
			      (setf (fill-pointer matching-lines) length)
			      (decf length 3)
			      (when (zerop length)
				(return))
			      (decf match 3)))))))))
	      (ecase winding-rule
		((:non-zero)
		 (let ((old-x nil)
		       (winding 0))
		   (loop for match below (fill-pointer matching-lines) by 3 do
		     (let ((x (aref matching-lines match))
			   (direction (aref matching-lines (1+ match))))
		       (incf winding direction)
		       (if (zerop winding)
			   (when old-x
			     (funcall slice-function old-x (ceiling x) slice-y)
			     (setq old-x nil))
			   (when (null old-x)
			     (setq old-x (floor x))))))))
		((:odd-even)
		 (let ((old-x nil))
		   (loop for x being the array-elements of matching-lines by 3 do
		     (if (not old-x)
			 (setq old-x (floor x))
			 (funcall slice-function old-x (ceiling x) slice-y)
			 (setq old-x nil)))))))))))))

(defun raster-array-correct-width (width element-type)
  (let ((elements-per-word (array-elements-per-q
			     (symbol-value
			       (cli::type-array-element-type element-type)))))
    (* elements-per-word (ceiling width elements-per-word))))

(defun make-raster-array-with-correct-width (width height
					     &rest args
					     &key (element-type t)
					     &allow-other-keys)
  (apply #'make-raster-array (raster-array-correct-width width element-type) height args))

(defmacro with-stack-raster-array-with-correct-width ((var width height
							   &rest args
							   &key (element-type 't)
							   &allow-other-keys)
						      &body body)
    `(stack-let* ((.dims. (list ,height (raster-array-correct-width ,width ,element-type)))
		  (,var (make-array .dims. . ,args)))
       . ,body))

(pushnew '(make-raster-array-with-correct-width 2 nil
	   with-stack-raster-array-with-correct-width)
	 si:*stack-let-operations*
	 :replace t :key #'first)

;;; Generate a bitmap from the filled in version of an outline.
(defun fill-path-into-raster (path-function
			      &key result-raster (winding-rule :non-zero)
						 (transform *identity-transform*)
						 (pattern nil) (temporary-raster nil))
  (using-resource (path-stream line-path-stream)
    (send path-stream :initialize :transform transform)
    (funcall path-function path-stream)
    (multiple-value-bind (min-x min-y max-x max-y)
	(send path-stream :point-limits)
      (when (null result-raster)
	(let ((width (raster-array-correct-width (- max-x min-x) 'bit))
	      (height (- max-y min-y)))
	  (setq result-raster (if temporary-raster
				  (with-stack-list (dims height width)
				    (tv:allocate-temp-sheet-raster-and-header dims
									      :type 'art-1b))
				  (make-raster-array width height :element-type 'bit)))))
      (fill-from-lines (send path-stream :lines) min-y max-y winding-rule
		       #'(lambda (start-x end-x line-y)
			   (%draw-rectangle (- end-x start-x) 1
					    (- start-x min-x) (- line-y min-y)
					    tv:alu-ior result-raster)))
      (when (arrayp pattern)
	(bitblt tv:alu-and (- max-x min-x) (- max-y min-y) pattern 0 0 result-raster 0 0))
      (values result-raster min-x min-y max-x max-y))))

;;; Execute 1body0 with 1raster0 bond to such a (temporary) bitmap.
(defmacro with-fill-path-into-raster ((raster &rest dims) (function . args) &body body)
  (declare (arglist (raster &optional left top right bottom)
		    (path-function &key (winding-rule :non-zero))
		    &body body))
  `(let (,raster . ,dims)
     (unwind-protect
	 (progn
	   (multiple-value-setq (,raster . ,dims)
	     (fill-path-into-raster ,function :temporary-raster t . ,args))
	   . ,body)
       (tv:deallocate-temp-sheet-raster-and-header ,raster))))

(defmacro decoding-raster-by-byte-rows (((result-var bytes-var
					  &key row-bytes raster-row-bytes index row)
					 (width height depth)
					 &key note-progress fill-pointer named)
					row-form &body body)
  (unless row-bytes (setq row-bytes (gensym)))
  (unless raster-row-bytes (setq raster-row-bytes (gensym)))
  (unless index (setq index (gensym)))
  (unless row (setq row (gensym)))
  `(sys:with-data-stack
     (multiple-value-bind (,result-var ,bytes-var ,row-bytes ,raster-row-bytes)
	 (decoding-raster-by-byte-rows-1 ,width ,height ,depth
				    . ,(and fill-pointer `(:fill-pointer ,fill-pointer)))
       (,@(if note-progress '(tv:noting-progress ("Decoding image rows")) '(progn))
	(loop ,@(and named `(named ,named))
	      for ,row below ,height
	      for ,index from 0 by ,raster-row-bytes
	      do
	  (progn
	    ,(when note-progress
	       `(tv:note-progress ,row ,height))
	    ,(when fill-pointer
	       `(setf (fill-pointer ,bytes-var) ,index))
	    ,row-form)))
       . ,body)))

(defun decoding-raster-by-byte-rows-1 (width height depth &key fill-pointer)
  (declare (values raster bytes row-bytes raster-row-bytes))
  (let* ((row-bytes (ceiling (* width depth) 8))
	 (word-width (ceiling (* width depth) 32))
	 (raster-row-bytes (* word-width 4))
	 (raster (make-raster-array (/ (* word-width 32) depth) height
				    :element-type `(unsigned-byte ,depth))))
    (values raster
	    (make-stack-array (* raster-row-bytes height)
			      :element-type '(unsigned-byte 8)
			      :displaced-to raster
			      :fill-pointer (and fill-pointer 0))
	    row-bytes raster-row-bytes)))

(defmacro encoding-raster-by-byte-rows (((bytes-var &key row-bytes raster-row-bytes index row)
					 (raster &optional width height depth)
					 &key note-progress named)
					row-form &body body)
  (unless row-bytes (setq row-bytes (gensym)))
  (unless raster-row-bytes (setq raster-row-bytes (gensym)))
  (unless index (setq index (gensym)))
  (unless row (setq row (gensym)))
  `(sys:with-data-stack
     (multiple-value-bind (,bytes-var ,row-bytes ,raster-row-bytes)
	 (encoding-raster-by-byte-rows-1 ,raster ,width ,height ,depth)
       (,@(if note-progress '(tv:noting-progress ("Encoding image rows")) '(progn))
	(loop ,@(and named `(named ,named))
	      for ,row below ,height
	      for ,index from 0 by ,raster-row-bytes
	      do
	  (progn
	    ,(when note-progress
	       `(tv:note-progress ,row ,height))
	    ,row-form)))
       . ,body)))

(defun encoding-raster-by-byte-rows-1 (raster &optional width height depth)
  (declare (values raster bytes row-bytes raster-row-bytes))
  (multiple-value-bind (rwidth rheight span)
      (decode-raster-array raster)
    (unless width
      (setq width rwidth))
    (unless height
      (setq height rheight))
    (unless depth
      (setq depth (array-element-byte-size raster)))
    (let* ((row-bytes (ceiling (* width depth) 8))
	   (raster-row-bytes (/ (* span depth) 8)))
      (values (make-stack-array (* raster-row-bytes height)
				:element-type '(unsigned-byte 8)
				:displaced-to raster)
	      row-bytes raster-row-bytes))))

;;; Like 1draw-string0, but the character images are scaled and rotated, not just the baseline
;;; for the upright fixed size characters.
;;; 1:character-size0 (default 1nil0): if given, pick a font as close to this size as possible,
;;; implicitly overriding the size field of the character style.
(define-graphics-generic draw-string-image (string x y
					    &key (attachment-y :baseline) (attachment-x :left)
						 (character-style nil) (character-size nil)
						 (string-width nil) (scale-down-allowed t))
  (:argument-types (string string)
		   (point (x y))
		   (((member :baseline :top :bottom :center)) attachment-y)
		   (((member :left :right :center)) attachment-x)
		   (character-style character-style)
		   (((null-or-type number)) character-size string-width)
		   (boolean scale-down-allowed))
  (:binary-opcode 17)
  (:screen-method )
  )

(compiler:make-obsolete draw-pattern
			"Use GRAPHICS:DRAW-RECTANGLE with :PATTERN for stippling;
 use GRAPHICS:DRAW-IMAGE for tilted or sampled bitmaps.")

;;; Cannot reliably translate into either draw-image or draw-rectangle. 
;;; Just include the code from 7.0.
(defun draw-pattern (left top pattern
		     &key (stream *standard-output*) (alu :draw)
		          (right nil) (bottom nil)
			  (pattern-left 0) (pattern-top 0) (copy-pattern nil))
  (multiple-value-bind (raster-width raster-height)
      (decode-raster-array pattern)
    (unless right
      (setq right (+ left raster-width)))
    (unless bottom
      (setq bottom (+ top raster-height))))
  (let ((width (- right left))
	(height (- bottom top)))
    (when copy-pattern
      (let ((new-pattern (make-array (raster-width-and-height-to-make-array-dimensions
				       width height)
				     :element-type (array-element-type pattern))))
	(bitblt tv:alu-seta width height
		pattern pattern-left pattern-top
		new-pattern 0 0)
	(setq pattern new-pattern
	      pattern-left 0
	      pattern-top 0)))
    (send stream :draw-1-bit-raster width height
	  pattern pattern-left pattern-top left top
	  alu :noop)))

;;; Draw a bitmap image with scaling.
;;; 1left0,1top0: the corner of the rectangle to draw.
;;; 1image0: the 2d source array.
;;; 1:image-left0, 1:image-top0, 1:image-right0, 1:image-bottom0 (default 0,0,width,height):
;;;   portion of source array.
;;; 1:copy-image0 (default 1nil0): save a copy of the pattern if output is going into a history
;;;  and will not have to be scaled.
(define-graphics-generic draw-image (image left top
				     &key (image-left 0) (image-top 0)
					  (image-right nil) (image-bottom nil)
					  (copy-image nil))
  (:argument-types (bitmap image)
		   (point (left top))
		   (integer image-left image-top)
		   (((null-or-type integer)) image-right image-bottom)
		   (boolean copy-image))
  (:binary-opcode 16)
  (:screen-method )
  )


;;; Draw 1string0 at 1x0,1y0.  The character glyphs are always vertical.  The line joining their
;;; baselines is optionally tilted.
;;; 1:character-style:0 to be merged against the styles in the string's characters.
;;; 1:attachment-x0 (default 1:left0), 1:attachment-y0 (default 1:baseline0): specify where
;;;  on the bounding box of the string the given point lies.
;;; 1:to-x0,1 :to-y0: specify the other end of a vector toward which the output points.
;;; 1:stretch-p0 (default1 nil0): actually extend the string to come as close to 1to-x0,1to-y0 as
;;;  possible.
(define-graphics-generic draw-string (string x y
				      &key (attachment-y :baseline) (attachment-x :left)
					   (toward-x (1+ start-x)) (toward-y start-y)
					   (stretch-p nil) (character-style nil)
					   (record-as-text nil))
  (:argument-types (string string)
		   (point (x y)
			  (toward-x toward-y))
		   (((member :baseline :top :bottom :center)) attachment-y)
		   (((member :left :right :center)) attachment-x)
		   (boolean stretch-p record-as-text)
		   (character-style character-style))
  (:binary-opcode 12)
  (:screen-method )
  )

(defmethod (:draw-string-size dw::encapsulating-output-stream) (&rest args)
  (lexpr-send stream :draw-string-size args))

;;; Draw a character glyph from a given font at a given point.
(define-graphics-generic draw-glyph (index font x y &rest args)
  (:argument-types (integer index)
		   (font font)
		   (point (x y)))
  (:binary-opcode 13)
  (:screen-method )
  (:default-method (apply #'draw-glyph-image index font x y args))
  )

;;;; Erasing.

(defun erase-rectangle (left top right bottom &key (stream *standard-output*))
  (send stream :clear-region left top right bottom))

(defun erase-graphics-presentation (presentation &rest args
						 &key (stream *standard-output*)
						 &allow-other-keys)
  (declare (arglist presentation &key (stream *standard-output*)
				      (redisplay-overlapping-presentations t)))
  (si:with-rem-keywords (some-args args '(:stream))
    (lexpr-send stream :erase-displayed-presentation presentation some-args)))

(defmacro replacing-graphics-presentation ((stream presentation &rest args)
					   &body body)
  (declare (arglist (stream presentation &key (bitmap-stream t)) &body body))
  (dw::format-output-macro-default-stream stream)
  `(replacing-graphics-presentation-internal
     (dw::named-continuation replacing-graphics-presentation (,stream)
       . ,body)
     ,stream ,presentation
     . ,args))

(defun replacing-graphics-presentation-internal (continuation xstream presentation
						 &key pattern-array (bitmap-stream t))
  (ignore pattern-array)			;Former argument, no longer used.
  (if (null presentation)
      ;; No previous presentation, make a new one.
      (with-output-as-graphics-presentation (xstream)
	(funcall continuation xstream))
      (let ((clobbered-box (dw::copy-box (dw:presentation-displayed-box presentation))))
	;; Make window history correct.
	(dw:with-output-recording-enabled (xstream :history-only)
	  (let ((old-priority (dw:graphics-displayed-presentation-priority presentation)))
	    ;; Remove old presentation
	    (send xstream :erase-displayed-presentation presentation
			  :enable-recording nil
			  :redisplay-overlapping-presentations nil)
	    ;; Make new presentation (only in history).
	    (setq presentation (with-output-as-graphics-presentation
				   (xstream :type (dw:presentation-type presentation)
					    :object (dw:presentation-object presentation))
				 (funcall continuation xstream)))
	    ;; Back priority to same as previous.
	    (dw::graphics-displayed-presentation-reorder-priority presentation old-priority)))
	(dw::box-extend-to-box clobbered-box (dw:presentation-displayed-box presentation))
	;; Copy history onto screen.
	(if (null bitmap-stream)
	    ;; Do not use a bitmap, just refresh directly.
	    (send xstream :redraw-inside-sets clobbered-box)
	    (flet ((use-bitmap-stream (bitmap-stream)
		     (multiple-value-bind (left top right bottom)
			 (dw:box-edges clobbered-box)
		       (send bitmap-stream :assure-room-for-output left top right bottom))
		     ;; Redraw into bitmap.
		     (send xstream :redraw-inside-sets clobbered-box nil bitmap-stream)
		     ;; And copy onto the screen from there.
		     (multiple-value-bind (bitmap origin-x origin-y left top right bottom)
			 (send bitmap-stream :bitmap-and-edges)
		       (dw:with-output-recording-enabled (xstream nil)
			 (send xstream :bitblt tv:alu-seta (- right left) (- bottom top)
			       bitmap (- left origin-x) (- top origin-y) left top)))))
	      (if (eq bitmap-stream 't)
		  (with-output-to-bitmap-stream (bitmap-stream :for-stream xstream
							       :host-allowed t)
		    (use-bitmap-stream bitmap-stream))
		(send bitmap-stream :reset :for-stream xstream)
		(use-bitmap-stream bitmap-stream))))
	presentation)))

;;;; Operations that obey the graphics cursor.

;;; Return the stream's graphics cursor.
(defgeneric current-position (&key (stream *standard-output*))
  (:function (funcall (flavor:generic current-position) (si:follow-syn-stream stream)))
  (:method-arglist ))

(defmethod (current-position dw::encapsulating-output-stream) ()
  (current-position :stream dw::stream))

;;; Move the graphics cursor.
;;;  1:explicit0 (default 1t0): whether this movement counts as opening up a new portion of
;;; a path for 1draw-path0.  Operations which do output and move the cursor should specify
;;; 1nil0 for this.
(defgeneric set-current-position (new-x new-y &key (stream *standard-output*) (explicit t))
  (:function (funcall (flavor:generic set-current-position) (si:follow-syn-stream stream)
		      new-x new-y :explicit explicit))
  (:method-arglist new-x new-y &key (explicit t)))

(defmethod (set-current-position dw::encapsulating-output-stream)
	   (new-x new-y &key (explicit t))
  (set-current-position new-x new-y :stream dw::stream :explicit explicit))

;;; Move the center of the graphics axes to the current graphics cursor position.
;;+++ Could be generic if LGP2 wanted to optimize, e.g.
(defun graphics-origin-to-current-position (&key (stream *standard-output*))
  (multiple-value-bind (x y) (current-position :stream stream)
    (graphics-translate x y :stream stream)))

;;; Draw a line from the graphics cursor position to the specied point, moving the cursor
;;; there when done.  Other arguments as to 1draw-line0.
(define-graphics-generic draw-line-to (end-x end-y &rest args)
  (:standard-arguments :lines)
  (:argument-types (point (end-x end-y)))
  (:binary-opcode 18)
  (:new-path-position (stream-transform-point end-x end-y self))
  (:default-method
   (with-stack-list (points end-x end-y)
     (apply #'draw-lines points :join-to-path t :stream self args))))

;;; Draw a line to the beginning of the current path segment and close the path off.
;;; The beginning is specified by the last 1set-current-position0 operation.
(define-graphics-generic close-path (&rest args)
  (:standard-arguments :lines)
  (:binary-opcode 19)
  (:new-path-position (values nil nil))
  (:default-method
    (apply #'draw-lines nil :join-to-path t :closed t :stream self args)))

;;; This is like the PostScript 1arcto0 operator.  Draw a piece of a
;;; circle tangent to two lines of a given radius.  The first line
;;; starts at the current position and goes to the corner.  The second
;;; line comes from there toward the third argument.  The cursor is
;;; moved to the intersection along the second line.  Values returned
;;; are these intersection points.
(define-graphics-generic draw-circular-arc-to
			 (to-x to-y tangent-intersection-x tangent-intersection-y radius
			  &rest args)
  (:standard-arguments :lines)
  (:argument-types (point (to-x to-y)
			  (tangent-intersection-x tangent-intersection-y))
		   (number radius))
  (:binary-opcode 14)
  (:default-method
    (multiple-value-bind (from-x from-y)
	(current-position :stream self)
      (multiple-value-bind (center-x center-y
			    theta-1 theta-2 clockwise
			    tangent-point-x1 tangent-point-y1
			    tangent-point-x2 tangent-point-y2)
	  (draw-circular-arc-to-compute-points from-x from-y to-x to-y
					       tangent-intersection-x tangent-intersection-y
					       radius)
	(when (and theta-1 theta-2)
	  (apply #'draw-circle center-x center-y radius
		 :start-angle theta-1 :end-angle theta-2 :clockwise clockwise
		 :filled nil :join-to-path t :stream self args))
	(values tangent-point-x1 tangent-point-y1 tangent-point-x2 tangent-point-y2)))))

(defun draw-circular-arc-to-compute-points (from-x from-y to-x to-y
					    tangent-intersection-x tangent-intersection-y
					    radius)
  (declare (values center-x center-y theta-1 theta-2 clockwise
		   tangent-point-x1 tangent-point-y1 tangent-point-x2 tangent-point-y2))
  (let* ((dx1 (- from-x tangent-intersection-x))
	 (dy1 (- from-y tangent-intersection-y))
	 (l1 (sqrt (+ (expt dx1 2) (expt dy1 2))))
	 (dx2 (- to-x tangent-intersection-x))
	 (dy2 (- to-y tangent-intersection-y))
	 (l2 (sqrt (+ (expt dx2 2) (expt dy2 2))))
	 (q (- (* dx2 dy1) (* dx1 dy2)))
	 (direction (signum q))
	 (clockwise nil))
    (when (zerop q)
      ;; Points are colinear, and so no corner is possible.
      (return-from draw-circular-arc-to-compute-points
	(values tangent-intersection-x tangent-intersection-y nil nil nil
		tangent-intersection-x tangent-intersection-y
		tangent-intersection-x tangent-intersection-y)))
    (flet ((try-it ()
	     (let* ((center-x (+ tangent-intersection-x
				 (/ (* radius (+ (* dx1 l2) (* dx2 l1))) q)))
		    (center-y (+ tangent-intersection-y
				 (/ (* radius (+ (* dy1 l2) (* dy2 l1))) q)))
		    (tangent-dx1 (* (/ (* radius dy1) l1) (- direction)))
		    (tangent-point-x1 (+ center-x tangent-dx1))
		    (tangent-dy1 (* (/ (* radius dx1) l1) (+ direction)))
		    (tangent-point-y1 (+ center-y tangent-dy1))
		    (tangent-dx2 (* (/ (* radius dy2) l2) (+ direction)))
		    (tangent-point-x2 (+ center-x tangent-dx2))
		    (tangent-dy2 (* (/ (* radius dx2) l2) (- direction)))
		    (tangent-point-y2 (+ center-y tangent-dy2))
		    (theta-1 (atan tangent-dy1 tangent-dx1))
		    (theta-2 (atan tangent-dy2 tangent-dx2)))
	       (values center-x center-y theta-1 theta-2
		       tangent-point-x1 tangent-point-y1 tangent-point-x2 tangent-point-y2))))
      (multiple-value-bind (center-x center-y theta-1 theta-2
			    tangent-point-x1 tangent-point-y1
			    tangent-point-x2 tangent-point-y2)
	  (try-it)
	(when (sector-wide-p theta-1 theta-2)
	  (rotatef dx1 dx2) (rotatef dy1 dy2) (rotatef l1 l2)
	  (setq q (- q) direction (- direction) clockwise t)
	  (multiple-value-setq (center-x center-y theta-2 theta-1
					 tangent-point-x1 tangent-point-y1
					 tangent-point-x2 tangent-point-y2)
	    (try-it)))
	(values center-x center-y theta-1 theta-2 clockwise
		tangent-point-x1 tangent-point-y1 tangent-point-x2 tangent-point-y2)))))

;;; This is the InterPress 1arcto0 operator.  An arc is drawn through
;;; three points.  The first is the current position.  The final
;;; position is the second.  The third also lies along the circle.
(define-graphics-generic draw-circular-arc-through-point-to
			 (to-x to-y through-x through-y &rest args)
  (:standard-arguments :lines)
  (:argument-types (point (to-x to-y)
			  (through-x through-y)))
  (:binary-opcode 15)
  (:default-method
    (multiple-value-bind (from-x from-y)
	(current-position :stream self)
      (multiple-value-bind (center-x center-y radius)
	  (triangle-circumscribed-circle from-x from-y through-x through-y to-x to-y)
	(let ((theta-1 (atan (- from-y center-y) (- from-x center-x)))
	      (theta-2 (atan (- through-y center-y) (- through-x center-x)))
	      (theta-3 (atan (- to-y center-y) (- to-x center-x))))
	  (apply #'draw-circle center-x center-y radius
		 :start-angle theta-1 :end-angle theta-3
		 :clockwise (not (angle-between-angles-p theta-2 theta-1 theta-3))
		 :filled nil :stream self :join-to-path t args))))
    (set-current-position to-x to-y :stream self :explicit nil)))

;;; Draw a Be'zier curve from the graphics cursor position to the specified end point,
;;; using the two other specified points as cubic control points.  Move the cursor to the
;;; end point when done.
(define-graphics-generic draw-bezier-curve-to (px4 py4 px2 py2 px3 py3
						   &key (number-of-samples 10))
  (:standard-arguments :lines)
  (:argument-types (point (px4 py4) (px2 py2) (px3 py3)) (integer number-of-samples))
  (:binary-opcode 25)
  (:default-method
    (multiple-value-bind (px1 py1)
	(current-position :stream self)
      (draw-bezier-curve px1 py1 px4 py4 px2 py2 px3 py3
			 :stream self :number-of-samples number-of-samples))
    (set-current-position px4 py4 :stream self :explicit nil)))

;;; This is like the InterPress 1conicto0 operator.  A portion of a conic
;;; section is drawn through two points, tangent to two lines, whose intersection
;;; is given.
;;; The shape parameter is deviation of the conic from a parabola.
;;;2 s0=1 is a parabola, 2s0<1 is an ellipse, and 2s0>1 is a hyperbola.
;;; The default for the shape is the one for the curve of least
;;; eccentricity.  So, if the bounding triangle is a right triangle, an
;;; elliptical arc is drawn whose axes are parallel to the sides.  For an
;;; isosceles triangle, a circular arc is drawn.
;;; Parametrically, the curve is the Be'zier parabola 2t0^2*P2+22s*t0(1-2t0)*Pc+(1-2t0)^2*P1.
(define-graphics-generic draw-conic-section
			 (from-x from-y to-x to-y tangent-x tangent-y
			  &key shape)
  (:standard-arguments :lines)
  (:argument-types (point (from-x from-y)
			  (to-x to-y)
			  (tangent-x tangent-y))
		   (((null-or-type number)) shape))
  (:binary-opcode 26)
  (:screen-method )
  (:default-method
    (draw-path #'(lambda (stream)
		   (set-current-position from-x from-y :stream stream)
		   (draw-conic-section-to to-x to-y
					  tangent-x tangent-y
					  :shape shape
					  :stream self))
	       :filled nil :stream self)))

(define-graphics-generic draw-conic-section-to
			 (to-x to-y tangent-x tangent-y &key shape)
  (:standard-arguments :lines)
  (:argument-types (point (to-x to-y)
			  (tangent-x tangent-y))
		   (((null-or-type number)) shape))
  (:binary-opcode 27)
  (:default-method
    (multiple-value-bind (from-x from-y)
	(current-position :stream self)
      (draw-conic-section from-x from-y to-x to-y tangent-x tangent-y
			  :shape shape :stream self))
    (set-current-position to-x to-y :stream self :explicit nil)))

(defun draw-oval (center-x center-y x-radius y-radius &rest args
						      &key (filled t)
						      &allow-other-keys)
  (let ((left (- center-x x-radius))
	(right (+ center-x x-radius))
	(top (- center-y y-radius))
	(bottom (+ center-y y-radius)))
    (cond ((or (= x-radius y-radius) (zerop x-radius))
	   (apply #'draw-circle center-x center-y x-radius args))
	  ((zerop y-radius)
	   (apply #'draw-circle center-x center-y y-radius args))
	  ((> x-radius y-radius)
	   (let ((rect-left (+ left y-radius))
		 (rect-right (- right y-radius)))
	     (if filled
		 (apply #'draw-rectangle rect-left top rect-right bottom args)
	       (apply #'draw-line rect-left top rect-right top
		      :allow-other-keys t args)
	       (apply #'draw-line rect-left bottom rect-right bottom
		      :allow-other-keys t args))
	     (let ((north (float (* pi 1/2) 0.0))
		   (south (float (* pi 3/2) 0.0)))
	       (apply #'draw-circle rect-left center-y y-radius
		      :start-angle north :end-angle south args)
	       (apply #'draw-circle rect-right center-y y-radius
		      :start-angle south :end-angle north args))))
	  (t
	   (let ((rect-top (+ top x-radius))
		 (rect-bottom (- bottom x-radius)))
	     (if filled
		 (apply #'draw-rectangle left rect-top right rect-bottom args)
	       (apply #'draw-line left rect-top left rect-bottom
		      :allow-other-keys t args)
	       (apply #'draw-line right rect-top right rect-bottom
		      :allow-other-keys t args))
	     (let ((east 0.0)
		   (west (float pi 0.0)))
	       (apply #'draw-circle center-x rect-top x-radius
		      :start-angle west :end-angle east args)
	       (apply #'draw-circle center-x rect-bottom x-radius
		      :start-angle east :end-angle west args)))))))

(defun draw-rounded-corner-lines (points radius &rest args &key closed &allow-other-keys)
  (apply #'draw-path
	 #'(lambda (stream)
	     (if (not closed)
		 (set-current-position (elt points 0) (elt points 1) :stream stream)
		 (let* ((length (length points))
			(x0 (elt points 0)) (y0 (elt points 1))
			(xl (elt points (- length 2))) (yl (elt points (- length 1)))
			(xl-1 (elt points (- length 4))) (yl-1 (elt points (- length 3))))
		   (set-current-position (/ (+ xl xl-1) 2) (/ (+ yl yl-1) 2) :stream stream)
		   (draw-circular-arc-to x0 y0 xl yl radius :stream stream)))
	     (let ((last-x nil) (last-y nil) (have-point closed))
	       (map-points
		 #'(lambda (x y last-p)
		     (when (and last-x last-y)
		       (if have-point
			   (draw-circular-arc-to x y last-x last-y radius :stream stream)
			   (setq have-point t)))
		     (setq last-x x last-y y)
		     (when last-p
		       (if (not closed)
			   (draw-line-to last-x last-y :stream stream)
			   (close-path :stream stream))))
		 points)))
	 :allow-other-keys t args))

;;;; Clipping

;;; This takes a path function and uses the inside of that path for the clipping region.
(defmacro with-clipping-path ((stream path-function &rest path-filling-args) &body body)
  (dw::format-output-macro-default-stream stream)
  `(with-clipping-path-internal (si:follow-syn-stream ,stream)
				(dw::named-continuation with-clipping-path (,stream)
				  . ,body)
				,stream ,path-function
				. ,path-filling-args))

;;; This takes a body that does output, such as calling draw-circle to generate the
;;; clipping region.
(defmacro with-clipping-from-output ((stream &body clipping-region-body) &body output-body)
  (dw::format-output-macro-default-stream stream)
  `(with-clipping-from-output-internal
     (si:follow-syn-stream ,stream)
     (dw::named-continuation with-clipping-from-output-body (,stream)
       . ,output-body)
     (dw::named-continuation with-clipping-from-output-clipping-region-body (,stream)
       . ,clipping-region-body)
     ,stream))

;;; This takes an image and uses it as the clipping region.
(defmacro with-clipping-mask ((stream mask &rest mask-args) &body body)
  (dw::format-output-macro-default-stream stream)
  `(with-clipping-mask-internal (si:follow-syn-stream ,stream)
				(dw::named-continuation with-clipping-mask (,stream)
					  . ,body)
				,stream ,mask . ,mask-args))

(defmethod (with-clipping-path-internal standard-graphics-mixin)
	   (continuation xstream path-function &key (winding-rule :non-zero))
  (with-clipping-from-output-internal self
				      continuation
				      #'(lambda (xstream)
					  (declare (downward-function))
					  (draw-path path-function
						     :stream xstream
						     :winding-rule winding-rule))
				      xstream))
