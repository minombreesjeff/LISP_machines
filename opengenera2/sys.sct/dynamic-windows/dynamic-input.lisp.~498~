;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Very low level DW mouse-handling substrate (context hacking, etc.)

(defparameter *mouse-wakeup-delay* 20)		;1/3 second

(define-presentation-type si:input-editor ())

(defun peek-for-presentation-blip (stream presentation-type)
  (when (and sys:rubout-handler
	     (eq (si:follow-syn-stream si:*input-editor-stream*)
		 (si:follow-syn-stream stream)))
    (let ((char (peek-char-for-accept stream nil)))
      (when (and (listp char)
		 (= (length char) 3)
		 (zl:mouse-char-p (second char))
		 (presentation-subtypep
		   ;; if the blip is subtypep of
		   ;; what we're looking for.
		   (first char)
		   presentation-type))
	(read-char-for-accept stream)))))

;;; TV:MOUSE-WINDOW if dynamic
(defun dynamic-mouse-window (message stream)
  (when (variable-boundp tv:mouse-window)
    (let* ((screen (and stream (send-if-handles stream :screen)))
	   (mouse (and screen (tv:sheet-mouse screen)))
	   (window (and mouse (tv:mouse-window mouse))))
      (when (and (instancep window)
		 (operation-handled-p window message))
	(values window mouse)))))

(defun stream-console (stream)
  (let ((screen (send-if-handles stream :screen)))
    (if screen
	(tv:sheet-console screen)
	*console*)))

;;; Does this stream appear to be reading from the selected input context?
(defun stream-selected-p (stream)
  (let ((stream-buffer (send-if-handles stream :io-buffer)))
    (and stream-buffer
	 (let ((console (stream-console stream)))
	   (and console
		(eq stream-buffer (console-selected-io-buffer console)))))))

;;; Not allowed to send :LISTEN from the input editor.
(defun stream-typeahead-p (stream)
  (let ((io-buffer (send-if-handles stream :io-buffer)))
    (when io-buffer
      (tv:console-io-buffer-listen (stream-console stream) io-buffer))))

(defun mouse-motion-pending (stream)
  (when (stream-selected-p stream)
    (let ((window (dynamic-mouse-window :mouse-motion-pending stream)))
      (when window
	(send window :mouse-motion-pending)))))

(defvar-resettable *mouse-handling-recursion-level* 0)

(defun update-highlighted-presentation (stream)
  (when (stream-selected-p stream)
    (unless (stream-typeahead-p stream)
      (let ((*mouse-handling-recursion-level* (1+ *mouse-handling-recursion-level*)))
	(if (> *mouse-handling-recursion-level* 2)
	    (let ((window (dynamic-mouse-window :clear-mouse-motion stream)))
	      (when window
		;; Have to explicitly ignore it or the input wait won't wait.
		(send window :clear-mouse-motion)))
	  (let ((window (dynamic-mouse-window :update-highlighted-presentation stream)))
	    (when window
	      (send window :update-highlighted-presentation))))))))

(zl:defvar-resettable *presentation-input-context* nil)
(zl:defvar-resettable *presentation-more-break-input-context* nil)
(defvar *presentation-input-context-tick* 0)

(defsubst presentation-input-context-option (presentation-input-context indicator)
  (getf (presentation-input-context-options presentation-input-context) indicator))

(defun clear-presentation-input-context ()
  (setq *presentation-input-context* nil)
  (mouse-wakeup))

(defun note-presentation-input-context-change (&optional (stream *terminal-io*))
  (multiple-value-bind (window mouse)
      (dynamic-mouse-window :set-highlighted-presentation stream)
    (when window
      (incf *presentation-input-context-tick*)
      (send window :set-highlighted-presentation nil nil)
      (tv:mouse-maybe-wakeup *mouse-wakeup-delay* mouse)))
  nil)

(defun inherit-presentation-context (&key (inherit t) &allow-other-keys)
  (when inherit
    *presentation-input-context*))

(defun new-presentation-input-context (new-context)
  (incf *presentation-input-context-tick*)
  (if (and *presentation-input-context*
	   (not (getf (presentation-input-context-options *presentation-input-context*)
			 :allow-inheritance t)))
      *presentation-input-context*
      new-context))


(defun presentation-input-blip-handler (blip stream)
  (let ((new-blip (send stream :presentation-input-blip-handler blip)))
    (or new-blip blip)))


;;; Note that presentation-1 is assumed to be from real structure, and presentation-2 possibly
;;; less specific.
(defun presentation-equal (presentation-1 presentation-2)
  (and (eq (presentation-object presentation-1)
	   (presentation-object presentation-2))
       (let ((location-1 (presentation-form-or-location presentation-1))
	     (location-2 (presentation-form-or-location presentation-2)))
	 (or (null location-2)
	     (eq location-1 location-2)))
       (presentation-subtypep (presentation-type presentation-2)
			      (presentation-type presentation-1))))

;;; An anonymous presentation is one that is used as a placeholder in the hierarchy,
;;; as opposed to coming from sensitive output in some program.
(defmethod (presentation-anonymous-p presentation) () nil)

(defmethod (presentation-object-and-types presentation) ()
  (declare (values object object-type displayed-type))
  (values object (type-of object) type))

(defmethod (position-inside-presentation presentation :default) (x y)
  ;; We use this method for deciding when to throw out of mouse sensitivity
  ;; computations, so if we can't answer definitively, answer T.
  (ignore x y)
  t)

(defmacro with-inverse-mouse-sensitivity (&body body)
  `(with-input-editing-options
       ((:input-wait nil #'ignore)
	(:input-wait-handler #'ignore)
	(:dynamic-blip-handler #'inverse-presentation-input-blip-handler))
     . ,body))

(defun inverse-presentation-input-blip-handler (blip stream)
  (when (eq (first blip) :mouse-click)
    (let ((x (fourth blip))
	  (y (fifth blip)))
      (multiple-value-setq (x y)
	(track-mouse-sensitivity (si:follow-syn-stream stream) x y))
      (when (null x)
	(return-from inverse-presentation-input-blip-handler nil))
      (setf (fourth blip) x
	    (fifth blip) y)))
  (presentation-input-blip-handler blip stream))

(defun track-mouse-sensitivity (stream x y)
  (let* ((mouse (tv:sheet-mouse stream))
	 (last-buttons (mouse-buttons mouse)))
    (when (zerop last-buttons)
      (return-from track-mouse-sensitivity (values x y)))
    (loop do
      (process-wait "Release mouse"
	#'(lambda (mouse last-buttons stream)
	    (or (neq (mouse-buttons mouse) last-buttons)
		(mouse-motion-pending stream)))
	mouse last-buttons stream)
      (update-highlighted-presentation stream)
      (unless (eq (mouse-buttons mouse) last-buttons)
	(return))))
    (let ((window (dynamic-mouse-window :mouse-motion-pending stream)))
      (when window
	(values (send window :mouse-x-position)
		(send window :mouse-y-position)))))

;;; Conventions:
;;;  Shifts:
;;;   Shift - effectively increases button space.  Same as without shift.
;;;   None - application specific.
;;;   Meta - additional application specific, but with usually larger presentation.
;;;          (Shift-Meta = window commands)
;;;   Hyper - reserved for user.
;;;   Super - commands related to presentations themselves.
;;;   Control-Meta - debugging (not necessarily debugger) related commands.
;;;   Control - single character marking and yanking commands
;;;  Buttons:
;;;   Left - selects
;;;   Right - menu

(defvar *gesture-name-array* (make-array 250 :fill-pointer 0))
(defvar *gesture-name-array-char-array* (make-array 250 :fill-pointer 0))
(defvar *char-gesture-array* (make-array '(32 3)))
(defvar *shift-state-mouse-array* (make-array 32))

(defun initialize-mouse-char-tables (gesture-alist)
  (setf (fill-pointer *gesture-name-array*) 0
	(fill-pointer *gesture-name-array-char-array*) 0)
  (zl:fillarray *char-gesture-array* nil)
  (fill *shift-state-mouse-array* nil)
  (dotimes (bits 32)
    (dotimes (button 3)
      (let* ((char (si:make-mouse-char button bits))
	     (gesture (intern (nstring-upcase
				(with-output-to-string (stream)
				  (format:format-character-bits stream bits t
								(logtest bits #o20))
				  (write-string (nth button '("Left" "Middle" "Right"))
						stream)))
			      "")))
	(push char (aref *shift-state-mouse-array* bits))
	(push gesture (aref *char-gesture-array* bits button))
	(vector-push-extend gesture *gesture-name-array*)
	(vector-push-extend char *gesture-name-array-char-array*))))
  (loop for (char . gestures) in gesture-alist
	for bits = (si:mouse-char-bits char)
	for button = (si:mouse-char-button char)
	do
    (dolist (gesture gestures)
      (push gesture (aref *char-gesture-array* bits button))
      (vector-push-extend gesture *gesture-name-array*)
      (vector-push-extend char *gesture-name-array-char-array*)))
  (dotimes (bits 32)
    (dotimes (button 3)
      (setf (aref *char-gesture-array* bits button)
	    (nreverse (copy-list (aref *char-gesture-array* bits button)))))
    (setf (aref *shift-state-mouse-array* bits)
	  (nreverse (copy-list (aref *shift-state-mouse-array* bits))))))

(initialize-mouse-char-tables
  '((#\mouse-l :select)
    (#\mouse-m :describe :select-and-edit)
    (#\mouse-r :menu)
    (#\sh-mouse-l :select-and-activate :alternate-select)
    (#\sh-mouse-m :inspect :delete :remove)
    (#\sh-mouse-r :system-menu)
    
    (#\c-mouse-l :hold-and-mark-region)
    (#\c-mouse-m :yank-word)
    (#\c-mouse-r :marking-and-yanking-menu)
    (#\c-sh-mouse-m :mark-word)
    
    (#\m-mouse-l :edit-function :edit-definition)
    (#\m-mouse-m :evaluate-form :disassemble)
    (#\m-sh-mouse-r :window-operation-menu)
    
    (#\s-mouse-l :select-object)
    (#\s-mouse-m :describe-presentation)
    (#\s-mouse-r :presentation-debugging-menu)
    (#\s-sh-mouse-l :reprint-differently)
    (#\s-sh-mouse-m :edit-viewspecs)

    (#\c-m-mouse-l :set-breakpoint)
    (#\c-m-mouse-m :clear-breakpoint)
    (#\c-m-mouse-r :modify :set-complex-breakpoint)
    (#\c-m-sh-mouse-l :monitor-location)
    (#\c-m-sh-mouse-m :unmonitor-location)

    ))

(defun mouse-char-gestures (mouse-char)
  (aref *char-gesture-array*
	(si:mouse-char-bits mouse-char)
	(si:mouse-char-button mouse-char)))

(defun mouse-char-gesture (mouse-char)
  (first (mouse-char-gestures mouse-char)))

(defun blip-gesture (blip)
  (mouse-char-gesture (second blip)))

(defun mouse-char-for-gesture (gesture)
  (let* ((start-loc (locf (aref *gesture-name-array* 0)))
	 (loc (%block-search-eq gesture start-loc (fill-pointer *gesture-name-array*))))
    (when loc
      (let ((index (%pointer-difference loc start-loc)))
	(values (aref *gesture-name-array-char-array* index)
		loc
		index)))))

;;; Advertised way to store is (setf (mouse-char-for-gesture :yank-word) #\hyper-mouse-left)
(defsetf mouse-char-for-gesture set-mouse-char-for-gesture)

;;; I guess this should really be #'(SETF MOUSE-CHAR-FOR-GESTURE)?
(defun set-mouse-char-for-gesture (gesture mouse-char)
  (multiple-value-bind (old-char ignore index)
      (mouse-char-for-gesture gesture)
    (when (eql old-char mouse-char)
      (return-from set-mouse-char-for-gesture nil))
    (without-interrupts
      (if old-char
	  (let ((old-bits (si:mouse-char-bits old-char))
		(old-button (si:mouse-char-button old-char)))
	    (setf (aref *gesture-name-array-char-array* index) mouse-char
		  (aref *char-gesture-array* old-bits old-button)
		  (delete gesture (aref *char-gesture-array* old-bits old-button))
		  (aref *shift-state-mouse-array* old-bits)
		  (delete gesture (aref *shift-state-mouse-array* old-bits))))
	  (when mouse-char
	    (vector-push-extend gesture *gesture-name-array*)
	    (vector-push-extend mouse-char *gesture-name-array-char-array*)))
      (when mouse-char
	(let ((new-bits (si:mouse-char-bits mouse-char))
	      (new-button (si:mouse-char-button mouse-char)))
	  (setf (aref *char-gesture-array* new-bits new-button)
		(copy-list (append (aref *char-gesture-array* new-bits new-button)
				   (ncons gesture))))
	  (when (or (member gesture *gestures-which-require-raw-text*)
		    (member gesture *gestures-which-describe-presentations*)
		    (member gesture *gestures-which-always-appear*))
	    (initialize-gesture-mouse-char-bits)))))
    (clear-handler-caches)))

(defun mouse-chord-possible-mouse-chars (bits)
  (aref *shift-state-mouse-array* bits))

;; This controls the generation of raw-text presentations.  Normally, we
;; never produce them, but things like the character-style p-t need to be
;; able to get at them with unshifted gestures.  If you want to be able
;; to "debug" text presentations, set *DEBUG-ANONYMOUS-PRESENTATIONS* to T.
(defvar-standard *allow-sensitive-raw-text-override* nil)

;;; Turn this on to get ar RAW-TEXT too when debugging real low levels.
(defvar *debug-anonymous-presentations* nil)

;;; Initially, Control- and Control-Shift-
(defvar *gestures-which-require-raw-text*
	'(:hold-and-mark-region :yank-word :mark-word :marking-and-yanking-menu))
(defvar *raw-text-mouse-chars*)

;;; Initially, Super- and Super-Shift-
(defvar *gestures-which-describe-presentations*
	'(:select-object :describe-presentation :presentation-debugging-menu
	  :reprint-differently :edit-viewspecs))
(defvar *describe-presentation-mouse-chars*)

;;; Initially, Shift-, Control-, Super-, and Meta-Shift-
(defvar *gestures-which-always-appear*
	'(:system-menu :marking-and-yanking-menu
	  :presentation-debugging-menu :window-operation-menu))
(defvar *always-appear-mouse-char-mask*)

(defun initialize-gesture-mouse-char-bits ()
  (flet ((bits-for-gestures (gestures)
	   (let ((bits nil))
	     (dolist (gesture gestures)
	       (let ((mouse-char (mouse-char-for-gesture gesture)))
		 (when mouse-char
		   (pushnew (si:mouse-char-bits mouse-char) bits))))
	     (copy-list (sort bits #'<))))
	 (mask-for-gestures (gestures)
	   (let ((mask 0))
	     (dolist (gesture gestures)
	       (let ((mouse-char (mouse-char-for-gesture gesture)))
		 (when mouse-char
		   (setf (%logldb (byte 1 (si:mouse-char-bits mouse-char)) mask) 1))))

	     mask)))
    (setq *raw-text-mouse-chars* (bits-for-gestures
				   *gestures-which-require-raw-text*)
	  *describe-presentation-mouse-chars* (bits-for-gestures
						*gestures-which-describe-presentations*)
	  *always-appear-mouse-char-mask* (mask-for-gestures
					    *gestures-which-always-appear*))))

(initialize-gesture-mouse-char-bits)


(defmethod (presentation-shares-superiors-boxes presentation) (super)
  (presentation-visibly-equal self super))

(defmethod (presentation-visibly-equal presentation) (ignore) nil)

;;; Find the outermost sensitive item in the innermost sensitive box.
(defun innermost-sensitive-presentation (presentation window mouse-chars
					 &optional (not-for-highlighting nil))
  (declare (values presentation context))
  (when (null presentation)
    (setq presentation *null-presentation*))
  (let ((context-independent-one nil)
	(sensitive nil)
	(in-context nil)
	(menu-presentation nil)
	(menu-context nil))
    (loop doing
      (multiple-value-bind (found context)
	  (block found
	    (map-over-presentation-mouse-handlers
	      presentation window mouse-chars
	      (lambda (handler context gesture mouse-char)
		(ignore gesture mouse-char)
		(when (and sensitive (context-inside-p in-context context))
		  ;; No need to search contexts outside the one we already found
		  (return-from found nil))
		(destructuring-bind (&key (suppress-highlighting nil)
					  (context-independent nil)
					  (defines-menu nil)
				     &allow-other-keys)
				    (presentation-mouse-handler-property-list handler)
		  (when (eq suppress-highlighting :within-menu)
		    (setq suppress-highlighting nil))
		  (if context-independent
		      ;; If this is context independent, we might find a better spread at
		      ;; another level.  This one will work there too, after all.
		      (unless context-independent-one
			(setq context-independent-one presentation))
		      (unless (and (not not-for-highlighting) suppress-highlighting)
			(return-from found
			  (values t context)))
		      (when (and (eq suppress-highlighting :defines-menu)
				 defines-menu)
			(unless menu-presentation
			  ;; Only if menu is suitable for highlighting
			  (when (presentation-menu-p presentation window defines-menu
						     context t)
			    (setq menu-presentation presentation
				  menu-context context)))))))))
	(when found
	  (setq sensitive presentation
		in-context context)))
      (let ((superior (presentation-superior presentation)))
	(when (and sensitive
		   (or (null superior)
		       (and (let ((type (presentation-type presentation)))
			      (not (or (eq type 'no-type)
				       (equal type '((no-type))))))
			    (not (presentation-shares-superiors-boxes
				   presentation superior)))))
	  (return (values sensitive in-context)))
	(when (null superior)
	  (when menu-presentation
	    (return (values menu-presentation menu-context)))
	  (return context-independent-one))
	(setq presentation superior)))))

(defmethod (presentation-redisplay-place-holder presentation) ()
  (eq type 'redisplay-structure))

;;; T, NIL, or :CARELESS
(defvar *maintain-second-mouse-line* :careless)
(zl:defvar-standard *skip-expensive-presentation-computations* nil)

;;; Find the outermost sensitive item in the innermost sensitive box.
;;; March up presentations, the innermost that is sensitive is put in sensitive-xxx,
;;; the outermost of those that has the same size box goes in result-xxx;
;;; continue marching all the way up to fill out handlers for other gestures for the second
;;; line.
;;; Context-independent-xxx saves handlers found anywhere that say :context-independent t.
;;; Normally, we will find some sensitive context further out, and since context doesn't
;;; matter to these handlers, they'll apply there too.  In the odd case where they matched
;;; on the outermost context, they become the result.
(defun find-innermost-sensitive-presentation (presentation window mouse-chars
					      documentation-string
					      &optional (not-for-highlighting nil)
							(mouse-motion-cell nil))
  (declare (values presentation first-documentation-line second-documentation-line))
  (ignore mouse-motion-cell)			;--- no longer used, but we may want it back
  (when (null presentation)
    (setq presentation *null-presentation*))
  (with-data-stack
    (let ((documentation-window (dynamic-mouse-documentation-window window))
	  (need-second-line *maintain-second-mouse-line*)
	  (top-context *presentation-input-context*)
	  (just-this-one nil)
	  (context-independent-presentation nil)
	  (context-independent-gestures nil)
	  (context-independent-mouse-chars nil)
	  (context-independent-handlers nil)
	  (context-independent-highlight nil)
	  (sensitive-presentation nil)
	  (sensitive-context nil)
	  (sensitive-mouse-chars nil)
	  (sensitive-gestures nil)
	  (sensitive-handlers nil)
	  (menu-presentation nil)
	  (menu-context nil)
	  (menu-mouse-chars nil)
	  (menu-gestures nil)
	  (menu-handlers nil)
	  (menu-highlight nil)
	  (result-presentation nil)
	  (result-context nil)
	  (result-mouse-chars nil)
	  (result-gestures nil)
	  (result-handlers nil)
	  (mouse-shifts-found *always-appear-mouse-char-mask*)
	  (highlighting-done not-for-highlighting))
      ;; Special case speedup for menus.  Maybe restrict the search if we know that all
      ;; gestures will be accounted for within it.
      (multiple-value-setq (presentation top-context just-this-one)
	(special-presentation-hook presentation top-context))
      (block found-all
	(labels ((return-result ()
		   (let (presentation context handlers gestures mouse-chars
			 (result-highlight t))
		     (cond (result-presentation
			    (setq presentation result-presentation
				  context result-context
				  gestures result-gestures
				  handlers result-handlers
				  mouse-chars result-mouse-chars))
			   (sensitive-presentation
			    (setq presentation sensitive-presentation
				  context sensitive-context
				  gestures sensitive-gestures
				  handlers sensitive-handlers
				  mouse-chars sensitive-mouse-chars))
			   (menu-presentation
			    ;; Found nothing sensitive at all, but there is a menu
			    (setq presentation menu-presentation
				  context menu-context
				  gestures menu-gestures
				  handlers menu-handlers
				  mouse-chars menu-mouse-chars
				  result-highlight menu-highlight))
			   (t
			    (setq presentation context-independent-presentation
				  result-highlight context-independent-highlight
				  context nil
				  gestures context-independent-gestures
				  handlers context-independent-handlers
				  mouse-chars context-independent-mouse-chars)))
		     (return-from found-all
		       (values (and result-highlight presentation)
			       (and presentation documentation-window
				    (compose-mouse-documentation presentation window
								 context gestures handlers
								 documentation-window
								 mouse-chars
								 documentation-string))
			       (and need-second-line documentation-window
				    (compose-second-mouse-documentation
				      mouse-shifts-found)))))))
	 (loop as sensitive-context-found = nil
	       as sensitive-mouse-chars-found = (make-stack-array 3 :initial-element 0) doing
	   (multiple-value-bind (object object-type displayed-presentation-type)
	       (presentation-object-and-types presentation)
	     (declare (ignore object))
	     (flet ((do-one-context (context)
		      (let ((handler-alist (presentation-context-mouse-handlers
					     object-type displayed-presentation-type context))
			    (presentation-mouse-chars (make-stack-array 3))
			    (presentation-gestures (make-stack-array 3))
			    (presentation-handlers (make-stack-array 3))
			    (old-mouse-char nil)
			    (bit nil)
			    (button nil))
			(map-over-handler-alist-and-mouse-chars-in-context
			  presentation window handler-alist mouse-chars context
			  (lambda (handler-entry gesture mouse-char gesture-match-p)
			    ;; This original throw did abort computations, but it left
			    ;; the old blinker lit.  It also threw more often than it
			    ;; had to, since the mouse may have moved within the current
			    ;; presentation.
			    #+++ignore
			    (when (and mouse-motion-cell
				       (location-contents mouse-motion-cell))
			      (throw 'skip-mouse-update nil))
			    (unless (eql mouse-char old-mouse-char)
			      (setq old-mouse-char mouse-char)
			      (when mouse-char
				(setq bit (si:mouse-char-bits mouse-char)
				      button (si:mouse-char-button mouse-char))))
			    (when (and ;; Has to have an assigned mouse character to do
				       ;; anything.
				       mouse-char
				       ;; If there is already a sensitive handler on that
				       ;; mouse character, it must be higher priority.
				       (zerop (logand (aref sensitive-mouse-chars-found button)
						      (rot 1 bit)))
				       ;; If we are done with sensitivity, that mouse character
				       ;; has to not already be in the shift mask, or this
				       ;; handler cannot contribute anything to the second
				       ;; mouse documentation line.
				       (or (and (null result-presentation)
						(not sensitive-context-found))
					   (zerop (logand (rot 1 bit) mouse-shifts-found))))
			      (let ((handler (if (atom handler-entry)
						 handler-entry
					       (first handler-entry))))
				(destructuring-bind (&key (suppress-highlighting nil)
							  (context-independent nil)
							  (defines-menu nil)
						     &allow-other-keys)
				    (presentation-mouse-handler-property-list handler)
				  (when (eq suppress-highlighting :within-menu)
				    (setq suppress-highlighting nil))
				  ;; Context-independent handlers don't have to be tested
				  ;; once we have found the sensitive context.  Any work
				  ;; for outer contexts will just be duplication.
				  (when (and (not (and context-independent
						       sensitive-context-found))
					     (progn
					       (maybe-skip-mouse-update
						 presentation 'handler-lookup)
					       (test-handler handler-entry presentation
							     window context gesture
							     mouse-char)))
				    (when (or context-independent
					      (or not-for-highlighting
						  (not suppress-highlighting)))
				      (setq mouse-shifts-found (logior (rot 1 bit)
								       mouse-shifts-found))
				      (when (or (not context-independent)
						(eq context sensitive-context))
					(setf (aref sensitive-mouse-chars-found button)
					      (logior (aref sensitive-mouse-chars-found button)
						      (rot 1 bit)))))
				    (when gesture-match-p
				      (unless (aref presentation-handlers button)
					(setf (aref presentation-handlers button) handler)
					(setf (aref presentation-mouse-chars button)
					      mouse-char)
					(setf (aref presentation-gestures button) gesture))
				      (cond (context-independent
					     ;; If this is context independent, we might find
					     ;; a better spread at another level.  This one
					     ;; will work there too, after all.
					     (unless context-independent-presentation
					       (setq context-independent-presentation
						       presentation
						     context-independent-highlight
						       (or context-independent-highlight
							   not-for-highlighting
							   (not suppress-highlighting))
						     context-independent-mouse-chars
						       presentation-mouse-chars
						     context-independent-gestures
						       presentation-gestures
						     context-independent-handlers
						       presentation-handlers)))
					    ((and (eq suppress-highlighting :defines-menu)
						  (not not-for-highlighting)
						  defines-menu)
					     (unless (or sensitive-presentation
							 menu-highlight)
					       ;; This menu passes test-handler, but is not
					       ;; supposed to affect the choice of sensitive
					       ;; presentation if there are any other
					       ;; sensitive handlers.  So just save the menu
					       ;; to use if we don't find anything else.
					       ;; Also, the menu hasn't yet been shown to be
					       ;; suitable for highlighting, so call
					       ;; presentation-menu-p to test that.
					       ;; We will use the innermost menu that is
					       ;; suitable for highlighting, or if there isn't
					       ;; one, the innermost menu.
					       (let ((highlight (presentation-menu-p
								  presentation window
								  defines-menu context t)))
						 (when (or highlight (not menu-presentation))
						   (setq menu-presentation presentation
							 menu-context context
							 menu-mouse-chars
							   presentation-mouse-chars
							 menu-gestures presentation-gestures
							 menu-handlers presentation-handlers
							 menu-highlight highlight)))))
					    (t
					     (unless (or (and (not not-for-highlighting)
							      suppress-highlighting)
							 sensitive-context-found)
					       ;; These variables remember what we found at
					       ;; the innermost context where we found
					       ;; anything for the current presentation with
					       ;; the current shift keys pressed
					       (setq sensitive-presentation presentation
						     sensitive-context context
						     sensitive-mouse-chars
						       presentation-mouse-chars
						     sensitive-gestures presentation-gestures
						     sensitive-handlers presentation-handlers)
					       ;; As soon as we know which box will be
					       ;; highlighted, do so.  Later update the
					       ;; documentation after more computation.
					       (unless (or highlighting-done
							   (eq sensitive-presentation
							       *null-presentation*))
						 (multiple-value-bind (old-1 old-2)
						     (send window
							   :who-line-documentation-string)
						   (send window :set-highlighted-presentation
							 sensitive-presentation
							 old-1 nil old-2))
						 (send window :update-blinker-motion-pending)
						 (setq highlighting-done t)))))))))))
			  t)	;ignore-nil-handlers
			;; After processing all handlers in sensitive-context, set
			;; sensitive-context-found so we know that outer contexts
			;; aren't relevant, in two senses: context-independent handlers
			;; don't matter any more, and if we go out to a superior
			;; presentation, we will only consider contexts inside or equal
			;; to sensitive-context, not outer contexts.
			;; This prevents confusion between a one-element sequence and
			;; its element (they have the same box).
			(when (and highlighting-done
				   (eq context sensitive-context))
			  (setq sensitive-context-found t)))))
	       ;; If this presentation could possibly contribute
	       (when (or (member (si:mouse-char-bits (first mouse-chars))
				 *describe-presentation-mouse-chars*)
			 (not (presentation-redisplay-place-holder presentation)))
		 (if just-this-one
		     (do-one-context top-context)
		   (map-over-input-contexts #'do-one-context top-context)))))
	   (maybe-skip-mouse-update nil 'after-handler-lookup)
	   (unless result-presentation
	     ;; If we have found a sensitive box, keep going out while the boxes are the same
	     ;; size and the superiors continue to be sensitive.
	     (when sensitive-presentation
	       (let ((superior (let ((*skip-expensive-presentation-computations*
				       (eq need-second-line :careless)))
				 (presentation-superior presentation))))
		 (when (or (null superior)
			   (and (let ((type (presentation-type sensitive-presentation)))
				  (not (or (eq type 'no-type)
					   (equal type '((no-type))))))
				(not (presentation-shares-superiors-boxes
				       sensitive-presentation superior))))
		   (setq result-presentation sensitive-presentation
			 result-context sensitive-context
			 result-mouse-chars sensitive-mouse-chars
			 result-gestures sensitive-gestures
			 result-handlers sensitive-handlers)))))
	   (when just-this-one
	     (return-result))
	   (when (and result-presentation (not need-second-line))
	     (return-result))
	   (let ((superior (let ((*skip-expensive-presentation-computations*
				   (and (eq need-second-line :careless)
					(not (null result-presentation)))))
			     (presentation-superior presentation))))
	     (if superior
		 (setq presentation superior)
		 (return-result)))))))))

;;; True if context-1 is nested inside context-2, and they are not equal
(defun context-inside-p (context-1 context-2)
  (loop for context = (presentation-input-context-superior context-1)
		    then (presentation-input-context-superior context)
	until (null context)
	when (eq context context-2)
	  return t))

;;; The generalization of this kludge is the presence of a :gesture t
;;; handler that always applies to the first thing you find in the
;;; hierarchy after "uninteresting stuff" like table formatting.

(defun special-presentation-hook (presentation top-context)
  (let* ((ct (presentation-input-context-superior
	       (presentation-input-context-superior
		 top-context)))
	 (context-type (presentation-type-name
			 (presentation-input-context-presentation-type ct))))
    (when (member context-type '(menu-alist-element presentation-handler-menu-choice))
      (loop for pres = presentation then (presentation-superior pres) while pres
	    when (eq (presentation-type-name (presentation-type pres)) context-type)
	      do (return-from special-presentation-hook
		   (values pres ct t)))))
  (values presentation top-context))

(defun compose-mouse-documentation (presentation window context gestures handlers
				    documentation-window mouse-chars documentation-string)
  (stack-let ((documentations (make-stack-array 4))
	      (some-found nil))
    (dotimes (i 3)
      (maybe-skip-mouse-update nil
			       (aref #(first-line-left first-line-middle first-line-right) i))
      (let ((handler (aref handlers i)))
	(when handler
	  (multiple-value-bind (documentation prefix)
	      (presentation-mouse-handler-context-documentation
		:presentation presentation :input-context context
		:handler handler :window window
		:gesture (aref gestures i) :mouse-char (aref mouse-chars i)
		:string-buffer (make-stack-array 30 :element-type 'character
						 :fill-pointer 0))
	    (when (and prefix (null (aref documentations 0)))
	      (setf (aref documentations 0) prefix))
	    (setf (aref documentations (1+ i)) documentation))
	  (setq some-found t))))
    (unless some-found
      (return-from compose-mouse-documentation ""))
    (maybe-skip-mouse-update nil 'before-compression)
    (command-menu-mouse-documentation-hook documentations)
    (compose-mouse-documentation-compress documentations documentation-window mouse-chars
					  documentation-string)))

(defvar-standard *inside-handler-documentation-phase* nil)

(defun presentation-mouse-handler-context-documentation (&rest arguments
							 &key handler input-context
							 presentation (for-menu-p nil)
							 (string-buffer nil)
							 &allow-other-keys)
  (let ((package *package*)
	(readtable *readtable*))
    (with-standard-io-environment
      ;; +++ There is an issue of what to do aboutD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") *print-base*0.
      ;; +++ It is unclear whether it is better to always use 10., or
      ;; +++ to use the current base, which may not have been what something was
      ;; +++ presented with.
      (let* ((*package* package)
	     (*readtable* readtable)
	     (*print-length* 3)
	     (*print-level* 2)
	     (*print-string-length* 30)
	     (*print-abbreviate-quote* t)	;Discourages line breaking
	     (*print-pretty* nil)
	     (*print-circle* nil)
	     (*print-array* nil)
	     (*print-structure-contents* nil)
	     (*print-readably* nil)
	     (*inside-handler-documentation-phase* t)
	     (for-menu-presentation (and for-menu-p presentation))
	     (*present-for-documentation-menu-presentation* for-menu-presentation)
	     (dbg:*printing-monitor-message* t)
	     (documentation (presentation-mouse-handler-documentation-or-function handler)))
	(if (stringp documentation)
	    documentation
	  (with-stack-list* (arguments (presentation-object presentation) arguments)
	    (if (null documentation)
		(if (getf (presentation-mouse-handler-property-list handler) :do-not-compose)
		    "(no documentation for handler)"
		  (multiple-value-call
		    ;; passed the result(s) of invoking the handler on the presentation
		    (lambda (value &optional (type nil type-received)
			     &key quoted-expression
				  (activate nil activate-p) &allow-other-keys)
		      (declare (sys:downward-function))
		      (unless type-received
			(setq type (merge-handler-and-context-presentation-types
				     handler input-context)))
		      (if (and (not type-received)
			       (null value))
			  ""
			;; fortify against errors in the type's printer
			(condition-case ()
			     (flet ((output (stream)
				      (if quoted-expression
					  (progn
					    (write-char #\' stream)
					    (present-for-documentation (second value)
								       quoted-expression
								       stream
								       for-menu-presentation))
					(present-for-documentation value type stream
								   for-menu-presentation))
				      (when activate-p
					(write-string (if activate
							  " [activate]"
							" [will not activate]")
						      stream))))
			       (if (null string-buffer)
				   (with-output-to-string (stream)
				     (output stream))
				 (with-output-to-string (stream string-buffer)
				   (output stream))
				 string-buffer))
			   ;; report trouble in mouse doc line and menus
			   (error "(error getting description)"))))
		    ;; Get the mouse-line value by invoking the handler
		    (apply (presentation-mouse-handler-value-function handler)
			   arguments)))
	    (multiple-value-bind (documentation maybe-prefix)
		(apply documentation arguments)
	      (unless documentation
		;; Distinguish no handler / no documentation from one that refused to
		;; document itself.  Perhaps the no documentation constant above would be
		;; better?
		(setq documentation ""))
	      (when maybe-prefix
		;; For compatibility, guard against extraneous illegal values.
		;; (An extraneous string will do no more damage than looking wrong.)
		(unless (stringp maybe-prefix)
		  (setq maybe-prefix nil)))
	      (values documentation maybe-prefix)))))))))

(defvar *present-for-documentation-menu-presentation* nil)

(defun present-for-documentation (object type stream &optional (for-menu-presentation nil))
  (let ((package *package*)
	(readtable *readtable*))
    (with-standard-io-environment
      ;; +++ There is an issue of what to do about1 *print-base*0.
      ;; +++ It is unclear whether it is better to always use 10., or
      ;; +++ to use the current base, which may not have been what something was
      ;; +++ presented with.
      (let ((*package* package)
	    (*readtable* readtable)
	    (*print-length* 3)
	    (*print-level* 2)
	    (*print-string-length* 30)
	    (*print-abbreviate-quote* t)	;Discourages line breaking
	    (*print-pretty* nil)
	    (*print-circle* nil)
	    (*print-array* nil)
	    (*print-structure-contents* nil)
	    (*print-readably* nil)
	    (*present-for-documentation-menu-presentation* for-menu-presentation))
      (present object type :stream stream)))))

(defun write-abbreviated-command-name-for-menu-documentation
       (command-name presentation stream)
  (let ((end-index (let ((type-name (string
				      (presentation-type-name
					(presentation-type presentation)))))
		     (and (> (string-length command-name)
			     (string-length type-name))
			  (let ((index (- (string-length command-name)
					  (string-length type-name))))
			    (and (plusp index)
				 (string-equal command-name type-name :start1 index)
				 (char-equal (aref command-name (1- index)) #\Space)
				 (1- index)))))))
    (write-string command-name stream :end end-index)))

(defun compose-mouse-documentation-compress (documentations documentation-window
					     mouse-chars string)
  (setf (fill-pointer string) 0)
  (stack-let ((end-indices (make-array 4 :initial-value 0))
	      (output-indices (make-array 4 :initial-value 0)))
    (dotimes (i 4)
      (let ((string (aref documentations i)))
	(when string
	  (setf (aref end-indices i)
		(or (string-search-char #\Return string)
		    (string-length string))))))
    (flet ((print-mouse-char (char stream)
	     (declare (downward-function))
	     (format:format-mouse-character stream char nil nil nil nil)))
      (let ((first-p t))
	(with-output-to-string (stream string)
	  (dotimes (i 4)
	    (let ((string (aref documentations i)))
	      (when (and string (plusp (string-length string)))
		(when (plusp i)
		  (if first-p
		      (setq first-p nil)
		      (write-string "; " stream))
		  (print-mouse-char (aref mouse-chars (1- i)) stream)
		  (loop for j from (1+ i) below 4 do
		    (when (let ((other-string (aref documentations j)))
			    (and other-string
				 (string= string other-string)))
		      (write-string ", -" stream)
		      (write-char (aref " LMR" j) stream)
		      (setf (aref documentations j) nil)))
		  (write-string ": " stream))
		(write-string string stream :end (aref end-indices i))
		(setf (aref output-indices i) (send stream :read-pointer))
		(when (zerop i)
		  (write-string ".  " stream)))))
	  (write-char #\. stream)))
      (let ((width (send documentation-window :inside-size)))
	(when (> (fill-pointer string) 50)	;Quick check for much less
	  (let* ((string-width (send documentation-window :string-length string))
		 (excess (- string-width width)))
	    (when (plusp excess)
	      (stack-let ((widths (make-array 4 :initial-value 0)))
		(dotimes (i 4)
		  (let ((string (aref documentations i)))
		    (when string
		      (setf (aref widths i)
			    (send documentation-window :string-length string 0
				  (aref end-indices i))))))
		(let* ((overhead (- string-width (loop for i below 4 sum (aref widths i))))
		       (my-share (floor (- width overhead)
					(loop for i below 4
					      count (aref documentations i))))
		       (number-over (loop for i below 4
					  count (let ((string (aref documentations i)))
						  (and string
						       (> (aref widths i) my-share)))))
		       (excess-share (round excess number-over)))
		  (dotimes (i 4)
		    (when (aref documentations i)
		      (when (> (aref widths i) my-share)
			(multiple-value-bind (nil new-index)
			    (send documentation-window :string-length (aref documentations i) 0
				  (aref end-indices i) (- (aref widths i) excess-share))
			  (when new-index
			    (let* ((amount-to-trim (- (aref end-indices i) new-index))
				   (output-index (aref output-indices i))
				   (fill-pointer (fill-pointer string))
				   (new-fill-pointer (- fill-pointer amount-to-trim)))
			      (copy-array-portion string output-index fill-pointer
						  string (- output-index amount-to-trim)
						  new-fill-pointer)
			      (setf (fill-pointer string) new-fill-pointer)
			      (loop for j from i below 4
				    do (decf (aref output-indices j) amount-to-trim)))
			    (setf (aref end-indices i) new-index))))))))))))))
  string)

(defun command-menu-mouse-documentation-hook (documentations)
  (let ((str3 (aref documentations 3))
	(nstr3 nil)
	(idx3 nil)
	(nstr1 nil))
    (when str3
      (cond ((%string= str3 0 "Menu for " 0 9)
	     (setq nstr3 "Menu"
		   idx3 9))
	    ((%string= str3 0 "Choose arguments for " 0 21)
	     (setq nstr3 "Choose arguments"
		   idx3 21))))
    (when nstr3
      (let* ((len3 (vector-length str3))
	     (plen (- len3 idx3))
	     (str1 (aref documentations 1)))
	(when str1
	  (cond ((%string= str1 0 str3 idx3 plen)
		 (let ((len1 (vector-length str1)))
		   (if (= len1 plen)
		       (setq nstr1 "Default arguments")
		       (when (char= (aref str1 plen) #\space)
			 (setq nstr1 (make-stack-array (- len1 plen 1)
						       :type (array-type str1)))
			 (copy-array-portion str1 (1+ plen) len1
					     nstr1 0 (- len1 plen 1))))))
		((%string= str1 0 "Read arguments for " 0 19)
		 (setq nstr1 "Read arguments"))))
	(when nstr1
	  (setf (aref documentations 1) nstr1)
	  (setf (aref documentations 3) nstr3)
	  (when (null (aref documentations 0))
	    (let ((prefix (make-stack-array plen :type (array-type str3))))
	      (copy-array-portion str3 idx3 len3 prefix 0 plen)
	      (setf (aref documentations 0) prefix))))))
    (when (and (or (and nstr1 nstr3)
		   (string= (aref documentations 1) (aref documentations 3)))
	       (let ((str2 (aref documentations 2)))
		 (and str2 (%string= str2 0 "Help about " 0 11))))
      (setf (aref documentations 2) "Help")
      (unless nstr1
	(unless (aref documentations 0)
	  (setf (aref documentations 0) (aref documentations 1)))
	(setf (aref documentations 1) (setf (aref documentations 3) "Default arguments")))))
  (let ((str0 (aref documentations 0)))
    (when str0
      (loop for i from 1 below 4 do
	(when (eql (aref documentations i) str0)
	  (setf (aref documentations i) "Default arguments")))))
  documentations)

(defvar *last-more-mouse-documentation-shifts* nil)
(defvar *last-more-mouse-documentation-result* nil)
(defvar *more-commands-available-documentation-cache* (make-hash-table))

(defun compose-second-mouse-documentation (shifts)
  ;; Very high performance single-level cache.  This shouldn't really be necessary, but
  ;; it was already there.
  (if (eql *last-more-mouse-documentation-shifts* shifts)
      *last-more-mouse-documentation-result*
      (let ((string (gethash shifts *more-commands-available-documentation-cache*)))
	(when (null string)
	  (setq string (compose-second-mouse-documentation-1
			 (loop for i below 16
			       when (not (zerop (%logldb (byte 1 i) shifts)))
				 collect i
			       as sh-i = (+ i 16)
			       when (not (zerop (%logldb (byte 1 sh-i) shifts)))
				 collect sh-i)))
	  (setf (gethash shifts *more-commands-available-documentation-cache*) string))
	(setq *last-more-mouse-documentation-shifts* shifts
	      *last-more-mouse-documentation-result* string)
	string)))

(defun compose-second-mouse-documentation-1 (shifts)
  (with-output-to-string (stream)
    (labels ((shift-p (shift-symbolic-name bits)
	       (si:bit-test (si:name-bit shift-symbolic-name) bits))
	     (format-shift (shift-bits stream &aux (shift-bit (logtest #o20 shift-bits)))
	       (cond ((zerop shift-bits) nil)	;this clause should never happen
		     (t
		      (cond ((= shift-bits 3)
			     ;; We like Control-Meta better than Meta-Control.
			     (write-string "Control-Meta" stream))
			    (t
			     (let ((printed-one nil)
				   (shift-bits (logand shift-bits #o17)))
			       (loop for shift in '(:hyper :super :meta :control)
				     when (shift-p shift shift-bits)
				       do (when printed-one
					    (write-char #\- stream))
					  (format stream "~:(~A~)" shift)
					  (setq printed-one t))
			       (when shift-bit
				 (when printed-one
				   (write-char #\- stream))
				 (write-string "Shift" stream)))))))))
      (unless (or (null shifts) (equal shifts '(0)))
	(format stream "To see other commands, press ")
	(formatting-textual-list (stream :conjunction "or")
	  (loop for shift in shifts
		when (not (zerop shift))
		  doing
		    (maybe-skip-mouse-update nil 'second-doc-line)
		    (formatting-textual-list-element (stream)
		      (format-shift shift stream))))
	(write-char #\. stream)))))

(defflavor dead-blip (mouse-char) (condition)
  :readable-instance-variables
  :initable-instance-variables)

(defmethod (:report dead-blip) (stream)
  (if (variable-boundp mouse-char)
      (format stream "~:C is not defined in this context." mouse-char)
      (format stream "Unhandled mouse click.")))

(compile-flavor-methods dead-blip)


;;; Standard thing to use in :PRESENTATION-INPUT-BLIP-HANDLER method
(defun call-presentation-mouse-handler (presentation &rest arguments
						     &key mouse-char window &allow-other-keys)
  (stack-let ((mouse-chars (list mouse-char)))
    (when (null mouse-char)
      (setq mouse-chars nil))
    (flet ((try-this-presentation (outer-presentation &optional (in-context nil context-p))
	     (when outer-presentation
	       (map-over-presentation-mouse-handlers
		 outer-presentation window mouse-chars
		 (lambda (handler context gesture ignore)
		   (when gesture
		     (when (or (not context-p) (eq context in-context))
		       (return-from call-presentation-mouse-handler
			 (apply #'call-presentation-mouse-handler-handler
				:handler handler :input-context context
				:presentation outer-presentation
				:original-presentation presentation
				:gesture gesture
				arguments)))))))))
      ;; First try to match handlers for this subset of clicks that
      ;; correspond to what we actually highlighted.
      (multiple-value-bind (outer-presentation in-context)
	  (innermost-sensitive-presentation presentation window
					    (mouse-chord-possible-mouse-chars
					      (char-mouse-bits mouse-char)))
	(when outer-presentation
	  (try-this-presentation outer-presentation in-context)
	  (try-this-presentation outer-presentation)))
      ;; If that doesn't work, take any handler that matches, even if :SUPPRESS-HIGHLIGHTING
      ;; was on for it.
      (try-this-presentation
	(innermost-sensitive-presentation presentation window mouse-chars t))))
  ;; An explicit dead blip (as opposed to a menu moved out of.)
  (unless (signal 'dead-blip :mouse-char mouse-char)
    (beep))
  '(dead-blip))

(defun call-presentation-mouse-handler-handler (&rest arguments
						&key handler input-context presentation mouse-char
						&allow-other-keys)
  (multiple-value-call
    (lambda (value &optional (type nil type-p) &rest options
	     &key already-blip-p &allow-other-keys)
      (if ;; Just returning NIL means no value.  To return NIL as a
	;; value, you must also explicitly return a type.
	(or (and (null value)
		 (or (null type)
		     (not type-p)))
	    (equal value '(dead-blip)))
	'(dead-blip)
	(unless type-p
	  (setq type (merge-handler-and-context-presentation-types
		       handler input-context)))
	(let ((new-blip (if already-blip-p
			    value
			  (list* type mouse-char value (copy-list options))))
	      (throw-tag (and (not already-blip-p)	;if already-blip-p, this came from an
							;inner call of this same function, via
							;call-presentation-menu, which already
							;took care of throwing to the right
							;context if that was needed.
			      (presentation-input-context-throw-p input-context)
			      input-context)))
	  (if throw-tag
	      (throw throw-tag new-blip)
	    new-blip))))
    (apply (presentation-mouse-handler-value-function handler)
	   (presentation-object presentation)
	   (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;;--- circumvent 357-only bugs
0	   :allow-other-keys t
	   arguments)))

;;; Extract information from CONTEXT that additionally qualifies HANDLER.
(defun merge-handler-and-context-presentation-types (handler context)
  (let ((handler-type (presentation-mouse-handler-context-presentation-type handler))
	(context-type (presentation-input-context-presentation-type context)))
    (block merged
      (when (eq handler-type 't)
	(return-from merged context-type))
      (when (atom handler-type)
	(let ((type (merge-handler-and-context-presentation-types-1
		      handler-type context-type)))
	  (when type
	    (return-from merged type))))
      handler-type)))

(defun merge-handler-and-context-presentation-types-1 (handler-type context-type)
  (when (consp context-type)
    (with-type-decoded (type-symbol data-args) context-type
      (cond ((eq type-symbol handler-type)
	     context-type)
	    ((eq type-symbol 'or)
	     ;;--- RWK sez this is completely bogus.
	     (loop for subtype in data-args
		   thereis (merge-handler-and-context-presentation-types-1
			     handler-type subtype)))
	    (t
	     (let ((expander
		     (new-get-symbol-type-property type-symbol
						   #'presentation-type-expansion-function)))
	       (when expander
		 (merge-handler-and-context-presentation-types-1
		   handler-type
		   (funcall expander context-type)))))))))

(defun echo-presentation-blip (stream blip &optional (start-bp (send stream :read-location))
						     for-context-type)
  (destructuring-bind (&key (activate t activate-p) (echo t) suffix (dont-quote nil)
		       &allow-other-keys)
		      (presentation-blip-options blip)
    (when echo	;Better hope that anyone doing 1:echo nil0 knows this isn't the editable middle.
      (multiple-value-bind (subtypep nil nil)
	  (or (null for-context-type)
	      ;; We don't want to hack predicates here because we are
	      ;; looking for the most specific possible type, not looking
	      ;; for something which can stand in the place of the type
	      ;; of the blip.  That is, we prefer the 1for-context-type
0	      ;; unless the blip has a more specific type.
	      (presentation-subtypep (presentation-blip-presentation-type blip)
				     for-context-type nil))
	(condition-case (unparse)
	     (present-to-string (presentation-blip-object blip)
				(if subtypep
				    (presentation-blip-presentation-type blip)
				  for-context-type)
				:acceptably :very
				:for-context-type
				  (if subtypep
				      for-context-type
				    (presentation-blip-presentation-type blip)))
	   (print-not-readable (send stream :insert-input-blip blip start-bp))
	   ;; Use presentation-replace-input instead of :replace-input directly to get
	   ;; quotification behavior.
	   (:no-error (presentation-replace-input stream start-bp unparse
						  :dont-quote dont-quote))))
      (when suffix
	(send stream :replace-input 0 suffix)))
    (when activate-p
      (if activate
	  (send stream :untyi (si:ie-make-blip :activation blip nil))
	  (send stream :force-rescan)))))


;;; This one is obsolete except for the call below.
(defun set-up-type-handler-table ()
  (clear-type-handler-caches)
  (let ((tick *type-tick*))			;In case it changes after we start.
    (fill-handler-table)
    (setq *type-handler-tables-valid-tick* tick)))


(defun initialize-presentation-substrate ()
  (set-up-type-handler-table)
  ;; Now that we have initially built the tables, we can turn on incremental updating.
  (setq *defer-type-change-processing* nil)
  (setq *update-types-incrementally* t)
  (verify-entire-handler-table)
  (run-background))

(add-initialization "Initialize presentation substrate" '(initialize-presentation-substrate)
		    () 'si:*after-loading-system-system-initialization-list*)
