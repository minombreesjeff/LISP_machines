;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defflavor program
	(name
	 pretty-name
	 command-table
	 (top-level '(default-command-top-level))
	 (command-evaluator nil)
	 (frame nil)
	 frame-options
	 (help nil)
	 (state-variables nil)
	 state-variable-choices)
	()
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (make-instance program) (&rest ignore)
  (setq command-table (cp:find-command-table name)
	state-variable-choices (loop for (var default . type) in state-variables
				     do (ignore default)
				     when (not (null type))
				       collect (list* (zl:locate-in-instance self var)
						      type))))

(defmethod (after-program-frame-activation-handler program :default) (frame)
  (ignore frame)
  ())

(defmethod (before-program-frame-deactivation-handler program :default) (frame)
  (ignore frame)
  ())

(defmethod (after-program-frame-selection-handler program :default) (frame)
  (ignore frame)
  ())

(defmethod (before-program-frame-deexpose-handler program :default) (frame)
  (ignore frame)
  ())

(defmethod (after-program-frame-deexpose-handler program :default) (frame)
  (ignore frame)
  )

(defmethod (before-program-frame-kill-handler program :default) (frame)
  (ignore frame)
  ())

(defmethod (program-frame-asynchronous-refresh-handler program :default) (frame)
  (ignore frame)
  ())

(defmethod (program-frame-override-name-for-select-handler program :default) (frame)
  (ignore frame)
  nil)

(flavor::define-make-instance-function make-program)

(defun extract-quoted-form (form)
  (declare (values form-unquoted form-was-quoted))
  (compiler:matchp form
    (('quote unquoted) (values unquoted T))
    (* (if (constantp form)
	   (values form T)
	   nil))))

#||
;;; This needs to be deferred
(defun (compiler:style-checker program-is-program make-program) (form)
  (let ((flavor-name-form (second form)))
    (when (and flavor-name-form
	       (listp flavor-name-form)
	       (eq (car flavor-name-form) 'quote))
      (if (not (symbolp (second flavor-name-form)))
	(warn "~S is not a symbol, and could not be the name of a flavor."
	      (second flavor-name-form))
	(let ((flavor (flavor:find-flavor (second flavor-name-form) nil 'flavor::compile)))
	  (when (and flavor ; might be defined later, use for a deferred warning
		     (not (member 'program (flavor:get-all-flavor-components flavor))))
	    (warn "~S is not a defined PROGRAM flavor."
		  (flavor::flavor-name flavor))))))))
||#

(defun make-program (name &rest options)
  (apply #'make-instance name options))

(defmacro getf-if ((variable plist property-name)
		   &body if-clauses)		   
  `(multiple-value-bind (,variable .there.)
       (si:multiple-value-get (locf ,plist) ,property-name)
     (if .there. ,@if-clauses)))

(define-modify-macro setf-merge-getf (keyword value) setf-merge-getf-internal)
(defun setf-merge-getf-internal (plist keyword new-value)
  (getf-if (ignore plist keyword)
    ()
    ;; only set when it wasn't found
    (setf (getf plist keyword) new-value))
  plist)

(defun merge-plists (pl1 pl2)
  (append pl1
	  (loop for (keyword value) on pl2 by #'cddr
		unless (loop for (foo) on pl1 by #'cddr
			     thereis (eq foo keyword))
		  collect keyword
		  and collect value)))

;; Compatibility with frames created before the p-f-o patch was loaded
(defgeneric program-frame-options-options (program-frame-options)
  (:function
    (if (typep program-frame-options 'program-frame-options)
	(funcall (flavor:generic program-frame-options-options) program-frame-options)
	program-frame-options)))

;; This exists only to hide multi-screen list structure when describing program instances
(defflavor program-frame-options
	(options)
	()
  (:constructor make-program-frame-options (&key options))
  (:writable-instance-variables))

(compile-flavor-methods program-frame-options)

;;; DEFINE-PROGRAM-FRAMEWORK

(defvar *program-option-keywords*
	'(:name :pretty-name :top-level :command-evaluator :state-variables
		:help))

(defvar *definition-time-option-keywords*
	'(:command-table :selectable :select-key :system-menu :pretty-name :superior))

(defvar *non-frame-option-keywords*
	'(:command-definer :command-table
	  :selectable :select-key :system-menu
	  :program-name :label-pane :help
	  :pretty-name :state-variables
	  :top-level :command-evaluator
	  :other-defflavor-options))

(defprop define-program-framework "Program" si:definition-type-name)

(defmacro define-program-framework
	  (name &key command-definer 
	   &rest options &allow-other-keys)
  (declare (arglist name
		    &key
		    pretty-name
		    (command-definer nil)
		    (command-table nil)
		    (top-level '(default-command-top-level))
		    (command-evaluator nil)
		    (panes '(main :listener))
		    selected-pane
		    query-io-pane
		    terminal-io-pane
		    label-pane
		    (configurations nil)
		    (state-variables nil)
		    (selectable t)
		    (select-key nil)
		    (system-menu nil)
		    (size-from-pane nil)
		    (inherit-from '(program))
		    (other-defflavor-options nil))
	   (zwei:indentation . 1))
  ;; Make sure that all the D-P-F options supplied are either handled by
  ;; this function or are init options to the frame.  Are there any frame
  ;; options that we want to exclude?
  (let ((compiler:default-warning-definition-type 'define-program-framework)
	(compiler:default-warning-function name)
	(program-options (si:rem-keywords options
					  '(:command-definer
					    :inherit-from :other-defflavor-options))))
    (setf-merge-getf program-options :pretty-name (string-capitalize-words name))
    (setf-merge-getf program-options :top-level '(default-command-top-level))
    (setf-merge-getf program-options :program-name name)
    (setq program-options (parse-program-layout program-options))
    (multiple-value-bind (program-flavor-options frame-options definition-time-options)
	(split-apart-program-options program-options)
      ;; Make sure the program-frame flavor will accept all the frame-options
      (validate-options-against-flavor frame-options *non-frame-option-keywords*
				       'program-frame
				       "DEFINE-PROGRAM-FRAMEWORK")
      (let* ((instance-variables
	       ;; A state variable clause looks like (name default description type).
	       ;; Take the name and default value, but not the description
	       ;; or presentation type.
	       (loop for (var default) in (getf program-options :state-variables)
		     collect (list var default)))
	     (frame-option-function-name (fintern "~a PROGRAM-FRAME-OPTIONS" name)))
	`(progn
	   ,@(when command-definer
	       ;; value of COMMAND-DEFINER is a command-defining macro name or
	       ;; T, meaning generate a macro with the program name in it.
	       (when (eq command-definer t)
		 (setq command-definer (fintern "DEFINE-~A-COMMAND" name))
		 ;; don't let the user replace the definition of DEFINE-PROGRAM-COMMAND.
		 (when (eq command-definer 'define-program-command)
		   (compiler:warn '(:fatal t)
				  "The COMMAND-DEFINER cannot be called DEFINE-PROGRAM-COMMAND. Choose another name.")))
	       `((defmacro ,command-definer ((name . options) arglist &body body)
		   (declare (zwei:indentation 1 3 2 2)
			    (sys:function-parent ,name define-program-framework))
		   `(define-program-command (,name ,',name ,@options) ,arglist
		      . ,body))
		 (defprop ,command-definer cp:define-command
			  zwei:definition-function-spec-type)
		 (setf (get ',command-definer 'zwei:definition-function-spec-finder)
		       (get 'cp:define-command 'zwei:definition-function-spec-finder))
		 (defprop ,command-definer "Program Command" si:definition-type-name)))
	   ;; Compile the frame-option constructor so it doesn't take a zillion page-faults
	   ;; in the interpreter just to select the frame for the first time.
	   (defun ,frame-option-function-name ()
	     (declare (sys:function-parent ,name define-program-framework))
	     (make-program-frame-options
	       :options ,(enquote-as-possible `(list ,@frame-options))))
	   ;; Define a new flavor for each program, with the state variables as
	   ;; IV's.  Stash the init info for the associated program frame in the init plist.
	   (defflavor ,name ,instance-variables ,(getf options :inherit-from '(program))
	     :writable-instance-variables
	     (:default-init-plist :name ',name
				  ,@program-flavor-options
				  :frame-options (,frame-option-function-name))
	     ,@(getf options :other-defflavor-options))
	   (define-program-1 ',name ,@definition-time-options)
	   ,(when (or si:*redo-defvars-p* fs:this-is-a-patch-file)
	      `(redefine-program-frames ',name :program-options
					(list ,@program-flavor-options) ,@frame-options))
	   )))))

(defun split-apart-program-options (options)
  (declare (values program-options frame-options definition-time-options))
  (loop for (keyword value) on options by #'cddr
	when (member keyword *program-option-keywords*)
	  do
	    (compiler:matchp value
	      (('quote ignore)
	       (compiler:warn '(:bad-style t)
			      "Don't quote the value for the ~S option."
			      keyword)))
	  and append `(,keyword ',value) into program-options
	when (member keyword *definition-time-option-keywords*)
	  ;; Do not quote definition-time-options here.
	  ;; Of course, pretty-name is shared with *program-option-keywords*
	  ;; which warns if it's quoted.
	  append (case keyword
		   ((:command-table)
		    `(,keyword ,(enquote-as-possible `(list ,@value))))
		   ((:superior)
		    `(,keyword ',value))
		   (otherwise
		     `(,keyword ,value)))
	    into definition-time-options
	unless (member keyword *non-frame-option-keywords*)
	  append (list keyword value) into frame-options
	finally (return (values program-options frame-options definition-time-options))))

(defun define-program-1 (program-name &key pretty-name command-table
			 (selectable t) select-key system-menu superior)
  (declare (ignore superior))
  (unless (record-source-file-name program-name 'define-program-framework)
    (return-from define-program-1 nil))

  (destructuring-bind (&rest options
			     &key (name program-name) (kbd-accelerator-p nil)
			     &allow-other-keys)
      command-table
    ;; Re-use the command table once it's created.  We need to advertise ways
    ;; to delete some or all the commands from a command-table.
    (apply #'cp:make-command-table name
	   :if-exists :update-options
	   :kbd-accelerator-p kbd-accelerator-p	;Override normal default
	   (si:rem-keywords options '(:name))))
  
  (when (and selectable
	     (cli::define-activity 'cli::program-activity :name pretty-name
				   :description pretty-name :program-name program-name))
    (when select-key
      (set-select-key-activity select-key pretty-name))
    (when system-menu
      (tv:add-activity-to-system-menu-programs-column pretty-name)
      (tv:add-to-system-menu-create-menu  (if (stringp system-menu) system-menu pretty-name)
					  `'(program-frame :program ,program-name)
					  (format () "A ~A program frame." pretty-name))))
  )

;;; This is one of those painful syntax-checking functions that has infinite
;;; clauses to validate the specified options against the possibilities.
;;; Simple for now.  Eventually, allow for multiple configurations,
;;; escape for more kinds of panes, etc. etc.
(defun parse-program-layout (frame-options-argument)
  (declare (values parsed-panes frame-options))
  (let ((frame-options (copy-list frame-options-argument)))
    ;; Global program-frame parameters, with defaults generated by analyzing
    ;; the panes for likely candidates.
    (let ((panes (getf frame-options :panes
		       '((main :listener))))) 	;--- should PANES have a default?
      ;; Sanity check on the frame options: make sure that the named pane
      ;; actually exists in the :PANES list.
      (dolist (pane-keyword '(:label-pane :selected-pane :terminal-io-pane :query-io-pane
			      :size-from-pane))
	(let ((pane-name (getf frame-options pane-keyword)))
	  (when pane-name
	    (unless (assoc pane-name panes)
	      (compiler:warn '(:bad-style t)
			     "The value of the ~S option, ~S, is not one of the defined panes."
			     pane-keyword pane-name)))))
      (let ((all-pane-options
	      (loop for pane-desc in panes
		    collect (process-pane-options pane-desc frame-options))))
	(when (null (getf frame-options :terminal-io-pane))
	  (loop for (pane-name pane-type . pane-option-plist) in all-pane-options
		for typeout-window = (getf pane-option-plist :typeout-window)
		do (ignore pane-type)
		when typeout-window
		  do (setf (getf frame-options :terminal-io-pane) `',pane-name)
		     (return)))
	(flet ((important-pane (frame-option-to-check frame-option-to-use possible-pane-types)
		 (getf-if (user-specified-frame-pane frame-options frame-option-to-check)
		   (setf (getf frame-options frame-option-to-check) `',user-specified-frame-pane)
		   ;; no explicitly supplied pane, assign one
		   (let ((frame-pane (and frame-option-to-use (getf frame-options frame-option-to-use))))
		     (if frame-pane
			 (setf (getf frame-options frame-option-to-check) frame-pane)
			 (dolist (pane-type possible-pane-types)
			   (let ((pane-options (find pane-type all-pane-options :key #'second)))
			     (when pane-options
			       (setf (getf frame-options frame-option-to-check) `',(first pane-options))
			       (return nil)))))))))
	  (important-pane :query-io-pane () '(:listener :interactor :display))
	  ;; If no explicit :selected-pane, try for an explicit :query-io-pane
	  ;; else interrogate the usual suspects.
	  (important-pane :selected-pane :query-io-pane '(:listener :interactor :display))
	  (important-pane :terminal-io-pane () '(:listener :display))
	  (important-pane :label-pane () '(:listener :interactor :display)))
	;; Make sure the label-pane has a label
	(getf-if (label-pane-name frame-options :label-pane)
	  (let ((label-pane-options (assoc label-pane-name all-pane-options)))
	    (setf-merge-getf label-pane-options :margin-components
			     `((margin-borders)
			       (margin-white-borders)
			       (margin-label :string ,(or (getf frame-options :pretty-name)
							  (error "No pretty name?"))
					     :style (:swiss :italic :normal))))))
	(getf-if (user-specified-frame-pane frame-options :size-from-pane)
	  (setf (getf frame-options :size-from-pane) `',user-specified-frame-pane))
	;; All pane descriptions have been parsed at this point.
	;; Make sure that a pane has been assigned to each important pane duty.
	(flet ((check-missing-pane (description keyword)
		 (unless (getf frame-options keyword)
		   (compiler:warn '(:bad-style t)
				  "No ~A can be determined from the panes description.~@
					Use ~S to specify one."
				  description keyword))))
	  (check-missing-pane "selected pane" :selected-pane)
	  (check-missing-pane "query-io pane" :query-io-pane)
	  (check-missing-pane "terminal-io pane" :terminal-io-pane))
	;; Sort out our mixture of program-frame-options, window-system-pane-options,
	;; and constraint-frame-constraints into the places they should go.
	(multiple-value-bind (all-pane-names parsed-panes all-panes-for-tv-system level-one-constraints)
	    (loop for (pane-name pane-type . pane-option-plist) in all-pane-options
		  when (getf pane-option-plist :size-from-output)
		    collect `(,pane-name :ask-window self :size-for-pane ,pane-name)
		      into level-one-constraints
		  when (getf pane-option-plist :height-in-lines)
		    collect `(,pane-name ,(getf pane-option-plist :height-in-lines)
			      :lines ,pane-name)
		      into level-one-constraints
		  collect pane-name into all-pane-names
		  collect `(list ',pane-name :type ',pane-type
				 ,@(getf-if (val pane-option-plist :typeout-window)
				     (if (member val '(t nil))
					 `(:typeout-window ,val)
					 (compiler:warn
					   '(:bad-style t)
					   "The value for the :TYPEOUT-WINDOW option must be T or NIL, not ~S." val)))
				 ,@(loop for key in '(:redisplay-function
						      :redisplay-string
						      :incremental-redisplay
						      :redisplay-after-commands
						      :automatically-remove-typeout-window)
					 append (getf-if (val pane-option-plist key)
						  (list key val))))
		    into parsed-panes
		  collect `(list ',pane-name ',(getf pane-option-plist :flavor 'dynamic-window-pane)
				 ,@(si:rem-keywords pane-option-plist
						    '(:flavor :typeout-window
						      :automatically-remove-typeout-window
						      :size-from-output
						      :height-in-lines
						      :redisplay-function
						      :redisplay-string
						      :incremental-redisplay
						      :redisplay-after-commands
						      ;; :command-menu type
						      :menu-level
						      :rows :columns :extend-width
						      :center-p :equalize-column-widths
						      ;; :accept-values type
						      :accept-values-function
						      :queries-are-independent 
						      :changed-value-overrides-default
						      :program-modifies-state
						      )))
		    into all-panes-for-tv-system
		  finally (return (values all-pane-names
					  parsed-panes
					  all-panes-for-tv-system
					  level-one-constraints)))
	  ;; Return the new frame options generated by parsing all panes
	  ;; SETF them into the plist to avoid disturbing the options that we
	  ;; aren't dealing with.
	  (setf (getf frame-options :configurations)
		(parse-configurations (getf frame-options :configurations)
				      all-pane-names level-one-constraints))
	  (setf (getf frame-options :parsed-panes) (cons 'list parsed-panes))
	  (setf (getf frame-options :panes) (cons 'list all-panes-for-tv-system))
	  frame-options)))))

;;; Returns pane-options, which is like (pane-name pane-type ,@pane-option-plist)
;;; where the plist has both program-frame-options and window-system-options.
(defun process-pane-options (desc program-options)
  (destructuring-bind (pane-name pane-type &rest desc-options)
		      desc
    (let ((pane-options (validate-pane-options pane-name pane-type desc-options)))
      (let ((hook (get pane-type 'process-pane-options)))
	(when hook
	  (setq pane-options (funcall hook
				      :pane-name        pane-name
				      :pane-type        pane-type
				      :pane-options     pane-options
				      :program-options  program-options
				      :allow-other-keys t))))
      (flet ((exclusive (excl1 excl2)
	       (when (and (getf pane-options excl1)
			  (getf pane-options excl2))
		 (compiler:warn
		   '(:bad-style t)
		   "You cannot specify ~s and ~s at the same time." excl1 excl2))))
	(exclusive :redisplay-function :redisplay-string)
	(exclusive :incremental-redisplay :redisplay-string))
      (when (getf pane-options :typeout-window)
	(let ((flavor (getf pane-options :flavor 'dynamic-window-pane)))
	  ;; If the flavor already has typeout in it, leave it be.
	  (unless
	    ;; or if we can't learn anything about the flavor yet.
	    (or (not (flavor:find-flavor flavor nil 'flavor::compile))
		(subtypep flavor 'tv:essential-window-with-typeout-mixin))
	    (if (subtypep flavor 'dynamic-window-pane)
		(setf (getf pane-options :flavor) 'dynamic-window-pane-with-typeout)
		(warn "The flavor ~S does not appear to include typeout window functionality, but you have specified :typeout-window t"
		       flavor)))))
      (list* pane-name pane-type pane-options))))

(defun (:property :command-menu process-pane-options) (&key pane-options)
  (setf (getf pane-options :redisplay-function)
	`(construct-command-menu-redisplay-function ,@(copy-list pane-options)))
  (setf (getf pane-options :redisplay-after-commands) nil)
  pane-options)

(defun (:property :accept-values process-pane-options) (&key pane-options)
  (setf (getf pane-options :redisplay-function)
	`(construct-accept-values-pane-redisplay-function ,@(copy-list pane-options)))
  pane-options)

(defun (:property :title process-pane-options) (&key pane-options program-options)
  (unless (or (getf pane-options :redisplay-function)
	      (getf pane-options :redisplay-string))
    (setf (getf pane-options :redisplay-string)
	  (getf program-options :pretty-name)))
  pane-options)

;;; ---obsolete version needed for existing programs in 344 world.  Remove
;;; it later.
(defun make-command-menu-redisplay-function (redisplay-function menu-level)
  (lambda (program stream)
    (apply redisplay-function
	   program stream
	   menu-level
	   *pane-sizing-options*)))

(defun construct-command-menu-redisplay-function (&rest pane-options
						  &key redisplay-function menu-level
						  &allow-other-keys)
  (let ((options (copy-list pane-options)))
    (lambda (program stream)
      (apply redisplay-function
	     program stream
	     menu-level
	     (append options
		     *pane-sizing-options*)))))

(defun validate-pane-options (pane-name pane-type desc-options)
  (let* ((type (find-program-pane-type pane-type)))
    (if (null type)
	(compiler:warn '(:bad-style t)
		       "~S is an unrecognized pane type."
		       pane-type)
	;; First validate the specified options against those provided.
	;; Look at the declared options for the pane type as well as the
	;; init options for the pane flavor
	(validate-options-against-flavor desc-options
					 (program-pane-type-allowed-options type)
					 (getf desc-options :flavor 'dynamic-window-pane)
					 (format nil "pane ~S of type ~S"
						 pane-name pane-type))
       ;; Augment the pane's init-plist by merging the default plist into it.
	(setf desc-options
	      (merge-plists desc-options (program-pane-type-default-init-plist type)))))
  desc-options)

(defun validate-options-against-flavor (proffered-plist allowed-keywords flavor string)
  (let* ((flavor-exists-p (flavor:find-flavor flavor nil))
	 (flavor-options (when flavor-exists-p
			   (flavor:flavor-allowed-init-keywords flavor)))
	 (bad-options (loop for (keyword) on proffered-plist by #'cddr
			    unless (or (member keyword flavor-options)
				       (member keyword allowed-keywords))
			      collect keyword)))
    (when bad-options
      (compiler:warn
	'(:bad-style t)
	"The option~P ~A ~:[are~;is~] not allowed for ~A.~@
			Valid options are ~:[~*~;~A,~%  plus ~]those accepted by the flavor ~s"
	(length bad-options)
	(with-output-to-string (s)
	  (format-textual-list bad-options #'prin1
			       :stream s :conjunction "and"))
	(= (length bad-options) 1)
	string
	(not (null allowed-keywords))
	(with-output-to-string (s)
	  (format-textual-list allowed-keywords #'prin1
			       :stream s :conjunction "and"))
	flavor))))

(defun parse-configurations (configurations all-pane-names level-one-constraints)
  (if (null configurations)
      ;; Default to all in one column
      `',(parse-configurations-1 (copy-tree
				   `((only
				       (:layout (only :column ,@all-pane-names)))))
				 level-one-constraints)
      (compiler:matchp configurations
	(('quote stuff)
	 `',(parse-configurations-1 (copy-tree stuff)
				    level-one-constraints))
	(* configurations))))

;;; Destructively alter each configuration clause to insert :sizes spec
;;; if necessary.
(defun parse-configurations-1 (configurations level-one-constraints)
  (dolist (configuration configurations)
    (when (null (assoc :sizes (cdr configuration)))
      (let ((sizes-spec
	      (loop for (name nil . infs) in (cdr (assoc :layout (cdr configuration)))
		    collect
		      (cons name
			    ;; First all infs D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")in0 level-one-constraints,
			    ;; then :then,
			    ;; then each inf 1not0 in level-one-constraints,
			    ;;    wrapped up with (,inf :even).
			    (let ((unconstrained
				    (loop for inf in infs
					  as level-one =
					     (assoc inf level-one-constraints)
					  when level-one collect level-one))
				  (constrained
				    (loop for inf in infs
					  unless (assoc inf level-one-constraints)
					    collect `(,inf :even))))
			      (if unconstrained
				  (if constrained
				      (nconc unconstrained (list :then) constrained)
				      unconstrained)
				  constrained))))))
	(setf (cdr configuration)
	      (nconc (cdr configuration)
		     (ncons `(:sizes ,@sizes-spec)))))))
  configurations)


;;; Turn (list :foo '(mumble)) into '(:foo (mumble))
(defun enquote-as-possible (list)
  (if (and (listp list) (member (car list) '(list list*)))
      (let ((new-args (mapcar #'enquote-as-possible (rest list))))
	(let (list-args constant-args)
	  (dolist (arg new-args)
	    (cond ((constantp arg)
		   (setq constant-args (nconc constant-args (ncons arg))))
		  (T
		   ;; Found a non-constant one.  What we had thought were constant-args
		   ;; we now know need to be evaluated, because they preceed this one.
		   (setq list-args (nconc list-args
					  constant-args
					  (ncons arg))
			 constant-args nil))))
	  (if (null constant-args)
	      `(si:xr-bq-list ,@list-args)
	      (let ((requoted-constant-args
		      ;; Factor inner QUOTEs into an outer one
		      `',(mapcar (lambda (thing)
				   (compiler:matchp thing
				     (('quote x) x)
				     (* thing)))
			      constant-args)))
		(if (null list-args)
		    requoted-constant-args
		    `(si:xr-bq-list*
		       ,@(mapcar
			   ;; So we don't see `(,:foo ...)
			   (lambda (x) (if (keywordp x) `',x x))
			   list-args)
		       ,requoted-constant-args))))))
      list))

;;; --- no one calls this, what is it for?
(defun configuration-layout-names-used (layout-spec configuration-name)
  (let ((panes nil)
	(place-holders nil)
	(pending (list configuration-name)))
    (loop while pending do
      (let ((name (pop pending)))
	(cond ((member name panes))
	      ((member name place-holders))
	      (t
	       (let ((sub (assoc name layout-spec)))
		 (if (null sub)
		     (push name panes)
		     (push name place-holders)
		     (setq pending (append pending (cddr sub)))))))))
    (append (delete configuration-name (nreverse place-holders)) (nreverse panes))))

;;; Program commands

(define-presentation-type window-wakeup-call-menu-handler ()
   :expander 'window-wakeup)

(define-presentation-type window-wakeup-redisplay ()
   :expander 'window-wakeup)

(defun use-typeout-window-for-help ()
  (and (send-if-handles *standard-output* :typeout-window-p)
       (multiple-value-bind (nil height)
	   (send-if-handles *query-io* :size-in-characters)
	 (or (null height) (< height 10)))))

(defmacro with-typeout-help-stream-if-appropriate (&body body)
  `(zl:with-input-editing-options-if
         (use-typeout-window-for-help)
       ((:help-stream *standard-output*))
     . ,body))

(defun program-typeout-window-intercept-character (character)
  (cond ((member character kbd-standard-suspend-characters)
	 (send *terminal-io* :expose-for-typeout)
	 (tv:window-call-relative (*terminal-io* :make-complete)
	   (let ((rubout-handler nil))
	     (kbd-intercept-character character)))
	 ;; Cannot do this in as the final-action for the window-call-relative, because
	 ;; when the typeout window's superior was the selected-pane, the expose-for-typeout
	 ;; will make it the selected-pane, and hence the window that gets selected on
	 ;; cleanup.  When there's a separate interactor pane, it starts out selected, and
	 ;; the expose-for-typeout doesn't select -- hence the need for the select-relative.
	 (send *terminal-io* :remove-self)
	 (throw 'abort-command-read t))
	((member character kbd-standard-abort-characters)
	 (kbd-intercept-character character
				  (if (send *terminal-io* :exposed-p)
				      *terminal-io*
				      *query-io*)))
	(t
	 (kbd-intercept-character character))))

(defun read-program-command (program &rest options
			     &key (stream *query-io*)
			     (prompt nil prompt-p)
			     (dispatch-mode :command-only)
			     (keyboard-accelerators nil keyboard-accelerators-p)
			     environment
			     (window-wakeup nil)
			     (input-wait-handler nil)
			     (intercept-function nil intercept-function-p)
			     &allow-other-keys)
  (labels ((prompt (stream &optional ignore)
	     (declare (downward-function))
	     (format stream "~A command: " (program-pretty-name program)))
	   (handle-wakeup (blip)
	     (declare (downward-function))
	     (case window-wakeup
	       ((nil) )
	       ((:return)
		(return-from read-program-command
		  (values nil blip :wakeup)))
	       (otherwise
		 (funcall window-wakeup blip))))
	   (combined-input-wait-handler (stream)
	     (declare (downward-function))
	     (update-highlighted-presentation stream)
	     (funcall input-wait-handler)))
    (when (not prompt-p)
      (setq prompt #'prompt))
    ;; compatibilility
    (cond ((eq dispatch-mode :accelerated-command)
	   (setq dispatch-mode :command-only keyboard-accelerators t
		 keyboard-accelerators-p t))
	  ((eq dispatch-mode :accelerated-form)
	   (setq dispatch-mode :form-only keyboard-accelerators t
		 keyboard-accelerators-p t)))
    (let ((command-table (program-command-table program))
	  (typeout-window-p (and (send-if-handles *terminal-io* :typeout-window-p)
				 (operation-handled-p (send *terminal-io* :superior)
						      :remove-typeout-window))))
      (setq keyboard-accelerators (if keyboard-accelerators-p keyboard-accelerators
				      (cp::command-table-kbd-accelerator-p command-table)))
      (catch 'return-from-read-command
	(loop named done doing
	  (catch 'abort-command-read
	    (return-from done
	      (with-presentation-input-context ((and window-wakeup
						     'window-wakeup-redisplay)
						:stream stream)
					       (blip)
	           (with-typeout-help-stream-if-appropriate
		     ;; Need to decide whether to read accelerators or
		     ;; full commands.
		     (if keyboard-accelerators
			 (si:with-rem-keywords (options options '(:dispatch-mode :environment
								  :keyboard-accelerators))
			   (when (and (not intercept-function-p)
				      typeout-window-p)
			     ;; If there is a typeout window, must intercept specially.
			     (setq intercept-function
				     #'program-typeout-window-intercept-character
				   intercept-function-p t))
			   (apply #'cp:read-accelerated-command
				  :command-table command-table
				  :prompt prompt
				  :intercept-function intercept-function
				  :suspend-chars
				  (and intercept-function-p kbd-standard-suspend-characters)
				  :abort-chars
				  (and intercept-function-p kbd-standard-abort-characters)
				  :help-stream
				  (if (use-typeout-window-for-help)
				      *standard-output*
				      stream)
				  :form-p (eq dispatch-mode :form-only)
				  :unknown-accelerator-reader-prompt #'ignore
				  :unknown-accelerator-reader
				  #'(lambda ()
				      (declare (sys:downward-function))
				      (apply #'read-program-command
					     program
					     :environment environment
					     :dispatch-mode dispatch-mode
					     :keyboard-accelerators nil
					     :prompt nil
					     options))
				  options))
			 (zl:with-input-editing-options-if
			     typeout-window-p
			     ((:intercept-character
				#'program-typeout-window-intercept-character))
			   (zl:with-input-editing-options-if window-wakeup
							     ((:window-wakeup #'handle-wakeup))
			     (zl:with-input-editing-options-if input-wait-handler
							       ((:input-wait-handler #'combined-input-wait-handler stream))
			       (if (eq dispatch-mode :command-only)
				   (si:with-rem-keywords (some-options
							   options
							   '(:stream :dispatch-mode
							     :environment
							     :unknown-accelerator-reader-prompt
							     :command-prompt
							     :handle-clear-input
							     :input-wait
							     :timeout
							     :keyboard-accelerators
							     :unknown-accelerator-is-command
							     :window-wakeup
							     :input-wait-handler))
				     (multiple-value-bind (command arguments)
					 (apply #'cp:read-command stream
						:command-table command-table
						:prompt prompt
						some-options)
				       (let ((full-rubout-flag 
					       (first (si:input-editor-option :full-rubout))))
					 (if (and full-rubout-flag
						  (eq arguments full-rubout-flag))
					     (values nil nil full-rubout-flag)
					     (values command arguments :command)))))
				   (si:with-rem-keywords (some-options
							   options
							   '(:stream
							      :keyboard-accelerators
							      :echo-accelerators
							      :command-prompt
							      :timeout :input-wait
							      :unknown-accelerator-is-command
							      :window-wakeup
							      :input-wait-handler))
				     (multiple-value-bind (form type)
					 (apply #'cp:read-command-or-form
						stream
						:command-table command-table
						:prompt prompt
						some-options)
				       (if type
					   (let ((full-rubout-flag
						   (first
						     (si:input-editor-option :full-rubout))))
					     (if (and full-rubout-flag
						      (eq type full-rubout-flag))
						 (values nil nil full-rubout-flag)
						 (values form nil :form)))
					   (values nil nil :blank-line))))))))))
		 (t
		   (handle-wakeup blip)
		   (throw 'abort-command-read t))))))))))

(defprop define-program-command cp:define-command zwei:definition-function-spec-type)

;;; Kill Definition support. 
;;;
;;; define-program-command just borrows CP:DEFINE-COMMAND-AND-PARSER for
;;; record source file name purposes.  So Kill Definition undefines it
;;; as a command.  This is OK as far as it goes, but leaves the program
;;; methods around.  All this only works because the command name
;;; namespace is shared among programs.
;;;
;;; To make this work all the way, define-program-command would
;;; have to record-source-file-name, and pass
;;; CP:DEFINE-COMMAND-AND-PARSER an argument telling it not to
;;; record-source-file-name, and to make the function parents of the
;;; parser and body be the define-program-command.  Then there would
;;; still need to be a way for undefine-program-command to find out what
;;; program we are talking about.  Moon's Kill Definition always calls
;;; the handler with "the name."  The function spec for the
;;; define-program-command call to record source file name would have to
;;; be a list that included the program name and the command name.
;;; Things in FSPEC and who-calls would have to be fixed to support
;;; that, since they currently only really work for list function specs
;;; of type DEFUN.

;;; To get the program state variables (i.e. the instance variables of the
;;; instance of the proper program flavor) to be lexically available, we
;;; write a method that contains the actual command body and a command
;;; "trampoline" that just calls the method.  This requires a lot of decoding
;;; of the command specification, which seems a bit gross.
;;; Presumably we need a define-command-and-parser version of this...
(defmacro define-program-command ((name program-name
					&rest options
					&key
					(keyboard-accelerator nil)
					(echo t)
					(menu-accelerator nil)
					(menu-level '(:top-level))
					(menu-documentation t)
					(menu-documentation-include-defaults nil)
					(provide-output-destination-keyword nil)
					&allow-other-keys
					
					)
				  arglist &body body &environment env)
  ;; The name-and-options field of define-program-command has some options that
  ;; define-command doesn't want, so build a proper command name-and-options.
  (let* ((cp-name-and-options `(,name :provide-output-destination-keyword nil
				;; Use a special CP hack to give the
				;; command body-function an argument
				;; list that will facilitate forwarding
				;; the call to the program-flavor method
				;; that actually implements it.
				      :explicit-arglist (&rest command-args)
				,@(si:rem-keywords options
						   '(:redisplaying
						     :keyboard-accelerator
						     :echo
						     :menu-accelerator
						     :menu-level
						     :menu-documentation
						     :menu-documentation-include-defaults
						     :explicit-arglist
						     :provide-output-destination-keyword))))
	 ;; This is the one that has provide-output-destination-keyword correct.
	 ;; Some of the routines want it, others want the above, since we generate some of
	 ;; the provide-output-destination-keyword code ourselves.
	 (cp-name-and-options-1 (if (not provide-output-destination-keyword)
				    cp-name-and-options
				    `(,name :provide-output-destination-keyword t
				      . ,(cdddr cp-name-and-options))))
         documentation)
    (multiple-value-bind (declarations body)
	(find-body-declarations body env arglist)
      (setq documentation (find-if #'stringp declarations))
      (setq declarations (loop for dcl in declarations
			       unless (stringp dcl)
				 append (cdr dcl)))
      ;; Decode the define-command-style arguments into the internals necessary to
      ;; build the method and the "trampoline" command.
      (multiple-value-bind (define-command-arglist automatically-written-parser)
	  (cp::expand-cp-arguments cp-name-and-options-1 arglist)
	(multiple-value-bind (command-name command-options)
	    (cp::decode-cp-name-and-options cp-name-and-options-1)
	  (let ((method-name (fintern "~A-INTERNAL" name))
		(parser-method-name (fintern "~A-PARSER" name)))
	    (multiple-value-bind (real-function-arglist)
		(cp::add-cp-options-to-arglist define-command-arglist command-options)
	      `(progn
		 (defmethod (,method-name ,program-name)
			    ,real-function-arglist
		   (declare (function-parent ,name cp:define-command)
			    . ,declarations)
		   (block ,name
		     . ,(if provide-output-destination-keyword
			    `((cp::with-standard-output-and-more-processing-bound
				cp::.output-destination.
				cp::.more-processing.
				. ,body))
			    body)))
		 ,(when documentation
		    `(setf (documentation ',name 'defun) ',documentation))
		 (defmethod (,parser-method-name ,program-name) (cp::argument-parser)
		   (declare (function-parent ,name cp:define-command))
		   ;; We need to use cp::argument-parser here, because write-parser-body
		   ;; writes code that references it and there really isn't any reason
		   ;; to remodularize this further.
		   ,(let ((extra-cp-keywords nil))
		      (when provide-output-destination-keyword
			(multiple-value-setq (nil extra-cp-keywords)
			  (cp::add-cp-options-to-arglist nil
							 '(:provide-output-destination-keyword t))))
		      (cp::write-parser-body automatically-written-parser
					     real-function-arglist extra-cp-keywords)))
		 (cp:define-command-and-parser ,(append cp-name-and-options
							`(:explicit-parser-body-p t))
					       ,define-command-arglist
		   (funcall ',parser-method-name *program* cp::argument-parser)
		   ;; CP::ARGUMENT-PARSER is the name you MUST use, as the cp constructs a parser
		   ;; whose argument list is (CP::ARGUMENT-PARSER).  This is the ONLY piece
		   ;; of magic in this function.
		   (apply ',method-name *program* command-args))
		 (sys:local-declare ((sys:function-parent ,name cp:define-command))
		  ,(when keyboard-accelerator
		     `(define-standard-keyboard-accelerator (,name :echo ,echo) ,program-name
			,keyboard-accelerator))
		  ,(when menu-accelerator
		     (when (eq menu-accelerator t)
		       (setq menu-accelerator (or (getf options :name)
						  (cp::generate-command-pretty-name
						    command-name))))
		     `(define-standard-menu-accelerator ,name ,program-name ,menu-accelerator
							,menu-level ,menu-documentation
							,menu-documentation-include-defaults)))
		 (define-program-command-1 ',name ',program-name
		   . ,(si:rem-keywords options
				       '(:keyboard-accelerator :echo
					 :menu-accelerator :menu-level
					 :menu-documentation
					 :menu-documentation-include-defaults
					 :provide-output-destination-keyword)))))))))))

(defprop accelerator-for t si:debug-info)

(defmacro define-standard-keyboard-accelerator (name-and-options program-name characters)
  (destructuring-bind (name . options)
      (if (listp name-and-options) name-and-options (list name-and-options))
    (cp::define-command-accelerator-internal name `',program-name
      `',characters options nil
      `((declare (accelerator-for ,name))
	(cons ',name (read-arguments-for-keyboard-accelerated-command ',name))))))

(defun read-arguments-for-keyboard-accelerated-command (command)
  ;; Since single-key accelerators can't read arguments, see if
  ;; any need to be read.  Use the same utility that the command
  ;; menu code uses, with the options used to build click-left commands.
  (let ((mode (cp::select-best-choose-arguments-mode
		command 
		;; simplest command line
		:for-select-gesture t)))
    ;; Always read command args via keyboard
    (unless (eq mode :none)			; don't want :menu, :accept-values
      (setq mode :keyboard))
    (cp:choose-command-arguments command :mode mode)))

(defparameter *standard-menu-command-assigned-buttons* '(:left :right))

(defmacro define-standard-menu-accelerator (name program-name menu-name
					    &optional (menu-level ':top-level)
						      (menu-documentation t)
						      (include-defaults nil))
  (define-command-menu-handler-internal menu-name program-name
					menu-level *standard-menu-command-assigned-buttons*
					menu-documentation nil
					'(&rest args)
					(if include-defaults
					    `((declare (accelerator-for ,name))
					      (apply #'program-command-menu-handler-defaults
						     ',name ',program-name
						     args))
					    `((declare (accelerator-for ,name))
					      (apply #'standard-command-menu-handler
						     ',name
						     :command-table ',program-name
						     args)))))

(defun define-program-command-1 (command-name program-name &key (name nil)
								(command-table nil ct-p)
								(redisplaying nil))
  (when (or command-table (not ct-p))
    (cp::command-table-install-command (cp:find-command-table (or command-table program-name))
				command-name name)
    (when redisplaying
      (setf (get command-name 'redisplaying) t))
    ))

(defun default-window-wakeup-handler (blip)
  (multiple-value-bind (handle-p force-p)
      (presentation-blip-case blip
	(window-wakeup-refresh
	  (values t t))
	(window-wakeup-redisplay
	  (values t nil))
	(window-wakeup-call-menu-handler
	  (destructuring-bind (program menu-level menu-item)
	      (presentation-blip-object blip)
	    (call-menu-handler program (get-menu-handler program menu-level menu-item)))
	  (values nil nil)))
    (when handle-p
      (let ((window (presentation-blip-object blip)))
	(if (typep window 'program-frame)
	    (send window :redisplay force-p)
	    (progn
	      (send-if-handles (send window :superior) :redisplay-pane window force-p)
	      (when (eq window (si:follow-syn-stream *query-io*))
		;; exit the command read so we get a new prompt
		(throw 'abort-command-read t))))))))

(defun flush-pending-wakeups (stream)
  (loop
    (let ((ch (send stream :any-tyi-no-hang)))
      (when (null ch)
	(return nil))
      (unless (and (consp ch)
		   (presentation-blip-p ch)
		   (presentation-blip-typep ch 'window-wakeup))
	(send stream :untyi ch)
	(return nil)))))

(defun default-command-top-level (program &rest options
					  &key (window-wakeup #'default-window-wakeup-handler)
					       (abort-exits nil)
					       (command-evaluator
						 (program-command-evaluator program))
					       (form-evaluator si:*command-loop-eval-function*)
					       (environment nil environment-p)
					       (form-values-print-function
						 si:*command-loop-print-function*)
					       (initial-redisplay t)
					  &allow-other-keys)
  (let ((unread-type nil)
	(unread-command nil)
	(unread-arguments nil)
	(program-help (program-help program)))
    (when (null command-evaluator)
      (setq command-evaluator #'(lambda (ignore command arguments)
				  (apply command arguments))))
    (si:with-command-loop-variable-bindings
      (si:with-process-interactive-priority ()
	(labels ((body ()
		   (si:with-rem-keywords (options options '(:abort-exits
							    :command-evaluator :form-evaluator
							    :form-values-print-function
							    :initial-redisplay))
		     (catch 'return-to-command-loop
		       (condition-bind
			   ((command-error #'(lambda (condition)
					       (beep)
					       (fresh-line *query-io*)
					       (dbg:report condition *query-io*)
					       (throw 'return-to-command-loop t))))
			 (with-accept-help-if program-help
			     ((:top-level-help
				(lambda (stream string-so-far)
				  (declare (downward-function))
				  (typecase program-help
				    (string (write-string program-help stream))
				    (function
				      (funcall program-help
					       program
					       stream
					       string-so-far))))))
			   (loop
			     (flet ((unread-blip (blip)
				      (when (getf (presentation-blip-options blip) :echo t)
					(present (presentation-blip-object blip)
						 (presentation-blip-presentation-type blip)
						 :stream *query-io*))
				      (fresh-line *query-io*)
				      (destructuring-bind (command . arguments)
					 (presentation-blip-object blip)
					(setq unread-type :command
					      unread-command command
					      unread-arguments arguments))))
			       (with-presentation-input-context
				  ;; So can click at space to flush
				  (`((cp:command
				       :command-table ,(program-command-table program)))
				   :stream *query-io*)
				  (blip)
				    (program-redisplay program initial-redisplay)
				    (t (unread-blip blip)))
			       (when initial-redisplay
				 (flush-pending-wakeups *query-io*)
				 (setq initial-redisplay nil))
			       (multiple-value-bind (command arguments type)
				   (if unread-type
				       (multiple-value-prog1
					 (values unread-command unread-arguments unread-type)
					 (setq unread-type nil
					       unread-command nil
					       unread-arguments nil))
				     (apply #'read-program-command program
					    :window-wakeup window-wakeup
					    options))
				 (case type
				   ((:command :accelerator)
				    (when command
				      (with-presentation-more-break-input-context
					 (`((cp:command
					      :command-table ,(program-command-table program))))
					 (blip)
					   (si:with-process-non-interactive-priority ()
					     (funcall command-evaluator program
									command arguments))
					 (t (unread-blip blip)))))
				   (:form
				     (shiftf +++ ++ + -)
				     (setq - command)
				     (let ((unread
					     (catch 'si:command-loop-new-form
					       (si:with-process-non-interactive-priority ()
						 (let ((values
							 (multiple-value-list
							   (if environment-p
							       (funcall form-evaluator
									command environment)
							       (funcall form-evaluator
									command)))))
						   (when values
						     ;; don't change ***, etc
						     ;; if there aren't values.
						     (shiftf /// // / values)
						     (si:set-value-for-* (first values))
						     (funcall form-values-print-function
							      values))
						   ))
					       nil)))
				       (when unread
					 (setq unread-type :form
					       unread-command unread))))))))))))))
	  (if abort-exits
	      (error-restart-loop ((error)
				   "~A top level" (program-pretty-name program))
		(body))
	      (error-restart-loop ((error abort)
				   "~A top level" (program-pretty-name program))
		(body))))))))

(defvar *program*)
(defmethod (run-program-top-level program) (&rest args)
  ;; Lookup any new version of the command-table that may have been defined
  ;; by recompilation of the D-P-F form.
  (setq command-table (cp:find-command-table (cp::command-table-name command-table)))
  (let ((*program* self)
	(cp:*command-table* command-table))
    (apply (first top-level) self (append args (rest top-level)))))

(defmethod (program-redisplay program) (&optional force-p)
  (let ((frame (or frame *program-frame*)))	;Allow binding for compatibility.
    (when frame
      (send frame :redisplay force-p))))

(defmethod (reset-program-state-variables program) (state-variables)
  (loop for (var init) in state-variables
	do (zl:set-in-instance self var init)))

(defun choose-program-state-variables (&optional (program *program*)
				       &key (prompt nil prompt-p))
  (accept-variable-values (program-state-variable-choices program)
			  :prompt (if prompt-p
				      prompt
				      (format nil "~A state" (program-pretty-name program)))
			  :own-window t))

(defun accept-values-program-state-variables (program stream)
  (loop for (place prompt type) in (program-state-variable-choices program)
	do (setf (location-contents place)
		 (accept type :stream stream :prompt prompt
			      :default (location-contents place) :provide-default t))))

(defflavor command-error () (dbg:error))
(defflavor command-ferror () (dbg:ferror command-error))

(defmethod (:report command-error) (ignore) )

(defun command-error (&optional format-string &rest format-args)
  (error (cond ((null format-string) 'command-error)
	       ((typep format-string 'condition)
		(make-condition 'command-ferror :format-string "~A"
						:format-args (list format-string)))
	       (t
		(make-condition 'command-ferror :format-string format-string
						:format-args (copy-list format-args))))))

;;;; Redisplay top level

#||
(defvar *default-redisplay-timeout* 300)
(defvar *redisplay-timeout*)

(defun redisplaying-command-top-level (program &key (timeout *default-redisplay-timeout*)
						    (initial-command nil)
						    )
  (si:with-process-interactive-priority ()
    (let* ((command-form initial-command)
	   (command-name nil)
	   (*redisplay-timeout* timeout))
      (flet ((execute-the-command (command arguments)
	       (if (not (null (program-command-evaluator program)))
		   (funcall (program-command-evaluator program) program command arguments)
		   (apply command arguments))))
	(send *terminal-io* :set-redisplay-function
	      (lambda ()
		(independently-redisplayable-format t "~A at ~\\TIME\\ (~D):~2%"
						    command-name (get-universal-time) (zl:time))
		(execute-the-command (first command-form) (rest command-form))))
	(error-restart-loop ((error abort) "~A top level" (program-pretty-name program))
	  (loop
;--- Commented out and replaced with the following two lines due to compiler bug
;        (multiple-value-bind (command arguments flag)
        (let (command arguments flag)
	  (multiple-value-setq (command arguments flag)
	    (read-program-command program
				  :whostate (and command-form "Tyi or timeout")
				  :window-wakeup :return
				  :timeout (and command-form *redisplay-timeout*)))
	  (ecase flag
	    ((:command :accelerator)
	     (if (get command 'redisplaying)
		 (setq command-form (cons command arguments)
		       command-name nil)
		 (si:with-process-non-interactive-priority ()
		   (execute-the-command command arguments))))
	    ((:timeout :blank-line) )
	    ((:wakeup) (default-window-wakeup-handler arguments)))
	  (unless (send *standard-input* :listen)
	    (when command-form
	      (when (null command-name)
		(setq command-name (cp:unparse-command (first command-form)
						       (rest command-form)
						       (program-command-table program)))
		(send *terminal-io* :clear-history))
	      (send *program-frame* :redisplay))))))))))
||#

(defflavor program-frame
	(program
	 parsed-panes
	 terminal-io-pane
	 query-io-pane
	 size-from-pane
	 (alias-for-selected-windows nil))	;don't make this gettable!
	(dynamic-window-frame margin-mixin
	 tv:process-mixin tv:constraint-frame-with-shared-io-buffer
	 tv:basic-frame tv:essential-mouse)			;???
  (:init-keywords :program-state-variables)
  (:gettable-instance-variables program parsed-panes size-from-pane
				terminal-io-pane query-io-pane)
  :initable-instance-variables
  (:default-init-plist :save-bits :delayed :process '(program-frame-top-level)
		       :margin-components '((margin-borders ))))

(defflavor program-frame-with-pane-mixin ()
	   (tv:pane-mixin program-frame))

(defmethod (:init program-frame :before) (plist)
  (let ((program-name program)
	(options nil))
    (when (consp program)
      (setf `(,program-name . ,options) program))
    (setq program (apply #'make-program program-name :frame self options)))
  (let ((state-variables (getf (location-contents plist) :program-state-variables)))
    (when state-variables
      (reset-program-state-variables program state-variables)))
  ;; This used to check (variable-boundp tv:name), but that IV is already
  ;; bound to window system's gensymed name.
  (unless (getf (location-contents plist) :name) 
    ;; this property-on-the-program-symbol stuff is a bit gross, but if
    ;; its good enough for the window system its good enough for me.
    (let ((index (get (program-name program) 'unnamed-instance-count 1)))
      (setq tv:name (format nil "~A ~D" (program-pretty-name program) index))
      (setf (get (program-name program) 'unnamed-instance-count 0) (1+ index))))
  (let ((frame-options (program-frame-options-options (program-frame-options program))))
    ;; Merge in all the frame-options specified in the D-P-F form with
    ;; the init plist provided from the make-window call.
    (loop for (keyword value) on frame-options by #'cddr
	  do
      (getf-if (ignore (location-contents plist) keyword)
	nil
	(setf (getf (location-contents plist) keyword) value)))
    (setq tv:panes (getf frame-options :panes)
	  tv:selected-pane (getf frame-options :selected-pane)
	  parsed-panes (copy-tree (getf frame-options :parsed-panes))	;should be writable
	  terminal-io-pane (getf frame-options :terminal-io-pane)
	  query-io-pane (getf frame-options :query-io-pane)
	  size-from-pane (getf frame-options :size-from-pane))))

#|| ;; Patch only
(defun fix-all-program-frame-parsed-panes ()
  (let ((to-do 900)				;empirically derived in 369.7
	(done 0))
    (tv:noting-progress ("Fixing program frame parsed-panes")
      (si:map-over-objects-in-area
	tv:sheet-area
	#'si:region-predicate-structure
	(sys:named-lambda per-object (ignore ignore object ignore ignore)
	  (tv:note-progress (incf done) to-do)
	  (when (typep object 'program-frame)
	    (setf (symbol-value-in-instance object 'parsed-panes)
		  (copy-tree (send object :parsed-panes)))))))))
(fix-all-program-frame-parsed-panes)
||#

(defmethod (:init program-frame :after) (ignore)
  (when (null tv:selected-pane)
    (let ((frame-options (program-frame-options-options (program-frame-options program))))
      (let ((computed-selected-pane (getf frame-options :selected-pane)))
	(cerror "leave it NIL -- the window system might not select the frame"
		"The frame currently has NIL for its selected-pane.~@
		 Perhaps the pane chosen to be selected-pane, ~s,~@
		  is not in the frame's default configuration, ~s"
		computed-selected-pane (send self :configuration))))))

(defmethod (:activate program-frame :after) ()
  (after-program-frame-activation-handler program self))

(defmethod (:deactivate program-frame :before) ()
  (before-program-frame-deactivation-handler program self))

(defmethod (:select program-frame :after) (&rest ignore)
  (after-program-frame-selection-handler program self)
  (console-select-program-after (tv:sheet-console self) program))

;;; for symmetry's sake, would like to put this on (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB"):deselect0, but
;;; 2:deselect0ion doesn't seem to be a guaranteed part of the interface.
;;; Fortunately, we're moving towards the world where you'll likely
;;; select another program soon after deexposing this one, so this is a
;;; moot point.
(defmethod (:deexpose program-frame :before) (&rest ignore)
  (before-program-frame-deexpose-handler program self))

(defmethod (:deexpose program-frame :after) (&rest ignore)
  (after-program-frame-deexpose-handler program self)
  (console-deexpose-program-after (tv:sheet-console self) program))

(defmethod (:kill program-frame :before) (&rest ignore)
  (before-program-frame-kill-handler program self))

(defmethod (:refresh program-frame :after) (&rest ignore)
  (program-frame-asynchronous-refresh-handler program self))

(defwhopper (:name-for-selection program-frame) (&rest args)
  (or (program-frame-override-name-for-select-handler program self)
      (lexpr-continue-whopper args)))

(defwhopper-subst (:alias-for-selected-windows program-frame) ()
  (or alias-for-selected-windows (continue-whopper)))

(defmethod (:set-alias-for-selected-windows program-frame) (window)
  (setq alias-for-selected-windows window))

(defmethod (:with-alias-for-selected-windows-1 program-frame) (alias continuation)
  (letf ((alias-for-selected-windows alias))
    (funcall continuation)))

;;; Looks through the parsed-panes for one that has a value for
;;; the specified option.
(defmethod (:find-flagged-pane program-frame) (flag)
  (loop for (pane-name . options) in parsed-panes do
    (when (getf options flag)
      (let ((pane (send self :get-pane pane-name)))
	(when (member pane tv:exposed-panes)
	  (return pane))))))

(defmethod (:terminal-streams program-frame) ()
  (declare (values *terminal-io* *query-io* *standard-output* *standard-input*))
    (values (or (and terminal-io-pane
		     (send self :get-pane terminal-io-pane))
		(let ((pane (send self :find-flagged-pane :typeout-window)))
		  (and pane (send pane :typeout-window)))
		(send self :selected-pane)
		tv:default-background-stream)
	    (or (and query-io-pane
		     (send self :get-pane query-io-pane))
		syn-terminal-io)
	    syn-terminal-io
	    syn-terminal-io))

(defmacro with-program-terminal-streams ((&optional (program '*program*)) &body body)
  `(with-program-terminal-streams-1 ,program (dw:named-continuation with-program-terminal-streams
								    ()
					       ,@body)))

(defmethod (with-program-terminal-streams-1 program) (continuation)
  (let ((*program* self))
    (if frame
	(let ((*program-frame* frame))
	  (multiple-value-bind (*terminal-io* *query-io* *standard-output* *standard-input*)
	      (send *program-frame* :terminal-streams)
	    (funcall continuation)))
      (funcall continuation))))

;;; Suppress the asynchronous redisplay in favor of the synchronous one.
(defmethod (:refresh program-frame :before) (&optional (type ':complete-redisplay))
  (when (and (eq type ':complete-redisplay) tv:*asynchronous-window-operation*)
    (let ((tv:*asynchronous-window-operation* nil))
      (dolist (desc parsed-panes)
	(let ((pane (send self :get-pane (first desc))))
	  (when (and (member pane tv:exposed-panes)
		     (or (getf (cdr desc) :redisplay-function)
			 (getf (cdr desc) :redisplay-string)))
	    (send-if-handles pane :clear-history :refresh nil)))))))

(defmethod (:redisplay program-frame) (&optional (force-p nil))
  (dolist (desc parsed-panes)
    (when (member (send self :get-pane (first desc)) tv:exposed-panes)
      (send self :redisplay-pane-internal desc force-p))))

;;; This is an external interface that accepts pane-name symbols, looks up the
;;; parsed-panes info for that pane, and calls :redisplay-pane-internal.
(defmethod (:redisplay-pane program-frame) (pane &optional (force-p nil))
  (etypecase pane
    ;; pane is a symbol naming a pane
    (symbol )
    (tv:sheet
      ;; pane is really the pane object, get its name
      (setq pane (send self :pane-name pane))))
  (let ((desc (assoc pane parsed-panes)))
    (when desc
      (send self :redisplay-pane-internal desc force-p))))

;;; This is the real pane redisplayer.
(defmethod (:redisplay-pane-internal program-frame) (desc force-p)
  (destructuring-bind (pane-name &key redisplay-function redisplay-string
				 incremental-redisplay redisplayer typeout-window
				 (redisplay-after-commands t)
				 (automatically-remove-typeout-window t)
				 &allow-other-keys)
     desc
    (catch-error-restart ((error) "Skip redisplay of pane ~A" pane-name)
      (let ((pane (send self :get-pane pane-name))
	    (has-redisplayer nil)
	    (clear-history t)
	    (limit-to-viewport nil))
	(ecase incremental-redisplay
	  ((nil))
	  ((t)
	   (setq has-redisplayer t))
	  ((:limit-to-viewport)
	   (setq has-redisplayer t
		 limit-to-viewport t))
	  ((:own-redisplayer)
	   (setq clear-history nil)))
	(when (and typeout-window automatically-remove-typeout-window)
	  (remove-window-typeout-window pane))
	;; When the user wants a full, "forced" redisplay, clear out the incremental
	;; redisplay function and make a new one.
	(when (and force-p (neq force-p :use-old-bits) has-redisplayer)
	  (send pane :clear-history)
	  (setf (getf (cdr desc) :redisplayer) nil)
	  (setq redisplayer nil))
	(when (and (or redisplay-after-commands
		       (case force-p
			 (:use-old-bits
			   (not (send pane :save-bits)))
			 ((NIL) nil)
			 (otherwise t)))
		   (or redisplay-function redisplay-string))
	  ;; DEFINE-PROGRAM-FRAMEWORK ensures that :INCREMENTAL-REDISPLAY
	  ;; is never specified along with :REDISPLAY-STRING
	  (when (and has-redisplayer (null redisplayer))
	    ;; create a redisplayer for all incremental-redisplay panes
	    (setq redisplayer (let ((function redisplay-function))
				(redisplayer (pane)
				  ;;--- This should pass along FORCE-P
				  (funcall function program pane))))
	    (setf (getf (cdr desc) :redisplayer) redisplayer))
	  ;; Do the actual redisplay
	  (tv:with-blinker-off (pane)
	    (with-output-truncation (pane)
	      (if has-redisplayer
		  (unwind-protect-case ()
		      (do-redisplay redisplayer pane
				    :limit-to-viewport limit-to-viewport
				    :truncate-p nil)	;We're doing it already.
		    (:abort (remf (cdr desc) :redisplayer)))
		(when clear-history
		  (send pane :clear-history))
		(cond (redisplay-function
		       ;;--- This should pass along FORCE-P
		       (funcall redisplay-function program pane))
		      (redisplay-string
		       (send pane :display-centered-string redisplay-string)))))))))))

;; pane is either a symbol or a real pane
(defmethod (:clear-pane program-frame) (pane)
  (let ((clear-history t)
	real-pane)
    (etypecase pane
      (symbol (setq real-pane (send self :get-pane pane)))
      (tv:sheet (setq real-pane pane
		      pane (send self :pane-name pane))))
    (let ((desc (assoc pane parsed-panes)))
      (when desc
	(destructuring-bind (pane-name &key incremental-redisplay &allow-other-keys)
	    desc
	  (ignore pane-name)
	  (ecase incremental-redisplay
	    (nil)
	    (:own-redisplayer (setq clear-history nil))
	    ((t :limit-to-viewport)
	     (setf (getf (cdr desc) :redisplayer) nil))))))
    (when clear-history
      (send real-pane :clear-history))))

(defun remove-window-typeout-window (window &key (prompt-p t))
  (when prompt-p
    (let ((typeout-window (send window :typeout-window)))
      (when (send typeout-window :incomplete-p)
	(tv:window-call-relative (typeout-window :make-complete)
	  (read-character typeout-window
			  :prompt "Type any character to refresh this display: "
			  :presentation-context t)))))
  (send window :remove-typeout-window))

(defun set-program-frame-configuration (configuration-name
					&optional (frame *program-frame*))
  (let ((process (send frame :process)))
    (loop
      (cond ((eq sys:current-process process)
	     (return))
	    (t
	     (cerror "Set the configuration of ~A from this process anyway.~
	            ~%~'iNote:~ This operation should not be performed casually."
		     "There was an attempt to set the configuration of ~A (to ~A)~
		    ~%from process ~A; this operation is expected to be done from ~A."
		     frame configuration-name sys:current-process process)
	     (when (yes-or-no-p "Continuing from here will SETQ the stream variables ~
			         *TERMINAL-IO*, *QUERY-IO*, *STANDARD-OUTPUT*, ~
			       ~%and *STANDARD-INPUT*. ~
			         You should generally only do this from process ~A. ~
			       ~%Are you sure you want to continue? "
			        process)
	       (return)))))
    (send frame :synchronous-set-configuration configuration-name)))

(defmethod (:synchronous-set-configuration program-frame) (configuration-name)
  (let ((old-exposed-panes (loop for pane in tv:exposed-panes
				 collect (cons pane
					       (multiple-value-list (send pane :size))))))
    (send self :set-configuration configuration-name)
    (dolist (new-pane tv:exposed-panes)
      (let ((elem (assoc new-pane old-exposed-panes)))
	(cond ((null elem)
	       ;; Redisplay because not previously visible.
	       (send self :redisplay-pane new-pane t))
	      ((multiple-value-bind (width height)
		   (send new-pane :size)
		 (or ( width (second elem))
		     ( height (third elem))))
	       ;; Redisplay because different size than before.
	       (send self :redisplay-pane new-pane :change-of-size-or-margins))))))
  (multiple-value-setq (*terminal-io* *query-io* *standard-output* *standard-input*)
    (send self :terminal-streams)))

(defvar *pane-sizing-options* nil)
(defmethod (:size-for-pane program-frame)
	   (remaining-width remaining-height total-width total-height stacking pane-name)
  (let* ((pane (send self :get-pane pane-name))
	 (vertical-margins (+ (tv:sheet-top-margin-size pane)
			      (tv:sheet-bottom-margin-size pane)))
	 (horizontal-margins (+ (tv:sheet-left-margin-size pane)
				(tv:sheet-right-margin-size pane))))
    (multiple-value-bind (width height)
	(with-stack-list (*pane-sizing-options*
			   :remaining-width (max 0 (- remaining-width horizontal-margins))
			   :remaining-height (max 0 (- remaining-height vertical-margins))
			   :total-width total-width
			   :total-height total-height)
	  (send self :inside-size-for-pane pane pane-name))
      (if (eq stacking :vertical)   
	  (+ height vertical-margins)
	  (+ width horizontal-margins)))))

(defmethod (:inside-size-for-pane program-frame) (pane pane-name)
  (let ((desc (assoc pane-name parsed-panes)))
    (destructuring-bind (&key redisplay-function redisplay-string
			      incremental-redisplay redisplayer
			      &allow-other-keys)
       (rest desc)
      (cond (redisplay-string
	     (values (send pane :string-length redisplay-string)
		     (send pane :line-height)))
	    ((and redisplay-function
		  (functionp redisplay-function))	;Delay blowout until user process.
	     (when (null redisplayer)
	       (setq redisplayer (let ((function redisplay-function))
				   (redisplayer (pane)
				     (funcall function *program* pane)))))
	     (when (eq incremental-redisplay t)
	       (setf (getf (rest desc) :redisplayer) redisplayer))
	     (let ((*program* program)
		   (*program-frame* self))
	       (redisplayer-output-size redisplayer pane)))
	    (t
	     (send pane :inside-size))))))

(defmethod (:maybe-size-from-pane program-frame) ()
  (when size-from-pane
    (let ((pane (send self :get-pane size-from-pane)))
      (multiple-value-bind (width height)
	  (send self :inside-size-for-pane pane size-from-pane)
	(incf width (- (send self :width) (send pane :inside-width)))
	(incf height (- (send self :height) (send pane :inside-height)))
	(multiple-value-bind (sup-width sup-height)
	    (send (send self :superior) :inside-size)
	  (send self :set-size (min width sup-width)
		(min height sup-height)))))))

(defmethod (:call-program program-frame)
	   (remaining-width remaining-height total-width total-height stacking
	    function &optional pane-name &rest other-args)
  (let* ((pane (and pane-name (send self :get-pane pane-name)))
	 (size (apply function program
		      stacking pane
		      remaining-width remaining-height total-width total-height
		      other-args)))
    (when pane
      (case stacking
	(:horizontal
	  (incf size (+ (tv:sheet-left-margin-size pane) (tv:sheet-right-margin-size pane))))
	(:vertical
	  (incf size (+ (tv:sheet-top-margin-size pane) (tv:sheet-bottom-margin-size pane))))
	))
    size))

;;; Until redisplay really works
(defmethod (:clear-all program-frame) ()
  (tv:sheet-validate-deactivated-screen-array self)
  (dolist (pane tv:exposed-inferiors)
    (send-if-handles pane :clear-history))
  (dolist (desc parsed-panes)
    (remf (cdr desc) :redisplayer)))

;;;+++ Maybe this could manage to find a better description in the title pane, if any?
(defmethod (:name-for-selection program-frame) () tv:name)

(defvar *program-frame*)
(defun program-frame-top-level (window &rest args)
  (let* ((*program-frame* window))
    (multiple-value-bind (*terminal-io* *query-io* *standard-output* *standard-input*)
	(send window :terminal-streams)
      (apply #'run-program-top-level (send window :program) args))))

(defun get-program-pane (name &key (if-does-not-exist :error))
  (or (send *program-frame* :get-pane name)
      (ecase if-does-not-exist
	((nil) nil)
	(:error (error "There is no ~S pane of ~S" name *program-frame*)))))

(defun default-console-and-superior-for-activity (console superior)
  (when (null console)
    (setf console (if superior
		      (tv:sheet-console superior)
		      *console*)))
  (if (null superior)
      (setf superior (console-screen console))
      (unless (eq (tv:sheet-console superior) console)
	(error "CONSOLE and SUPERIOR are not compatible.")))
  (values console superior))


(defun dw::reset-program-frame-and-state-variables (window program-state-variables)
  (when (and window program-state-variables)
    (reset-program-state-variables (send window :program) program-state-variables)
    (let ((tv:*asynchronous-window-operation* t))
      (send window :clear-all))
    (let ((process (send window :process)))
      (when process
	(process:reset process)))))

(defun find-program-window (program-name &rest make-window-options &key
			    (create-p t) (activate-p t) (selected-ok t) (reuse-test nil)
			    console superior
			    program-state-variables
			    &allow-other-keys)
  (multiple-value-bind (window created)
      (cli::find-frame-for-activity
	console superior
	#'(lambda (window)
	    (and (typep window 'program-frame)
		 (let ((program (send window :program)))
		   (and (eql (program-name program) program-name)
			(or (null reuse-test)
			    (funcall reuse-test window program))))))
	(and create-p
	     #'(lambda (&rest init-keywords)
		 (si:with-rem-keywords
		   (new-options make-window-options
				'(:create-p :activate-p :selected-ok :reuse-test
					    :console :program-state-variables))
		   (let ((window (apply #'tv:make-window 'program-frame
					:program program-name
					:program-state-variables program-state-variables
					:activate-p activate-p
					(append init-keywords new-options))))
		     (send window :maybe-size-from-pane)
		     window))))
	:force-create (eql create-p :force)
	:selected-ok selected-ok)
    (unless created (reset-program-frame-and-state-variables window program-state-variables))
    window))

(defun find-program-window-for-select-key (program-name force-create &rest options)
  (apply #'find-program-window program-name :create-p (if force-create :force t) options))

(defun find-and-select-program-window (name &rest options)
  (let ((frame (apply #'find-program-window name :selected-ok nil options)))
    (send frame :select)
    frame))

(defmethod (:same-program-type-p program-frame) (other-window)
  (and (typep other-window 'program-frame)
       (equal (type-of (send other-window :program))
	      (type-of program))))

(defflavor program-frame-resource () (program-frame)
  (:init-keywords :temporary-p)
  (:mixture (:temporary-p tv:temporary-window-mixin)))

(defvar *redefine-program-frames* :ask)

(defun redefine-program-frames (program-name &rest options)
  (flet ((ask-about-frame (window)
	   (ecase *redefine-program-frames*
	     ((nil) nil)
	     ((t) t)
	     ((:ask)
	      (or inhibit-fdefine-warnings
		  fs:this-is-a-patch-file	;+++
		  (yes-or-no-p "Update ~S for the new definition? " window))))))
    (let ((tv:*asynchronous-window-operation* t))	;Not called from program.
      (loop for window being the array-elements of tv:previously-selected-windows doing
	(when (and (typep window 'program-frame)
		   (eq (program-name (send window :program)) program-name)
		   (ask-about-frame window))
	  (lexpr-send window :update-frame-options options)))
      (map-resource 'program-frame
		    (lambda (window &rest ignore)
		      (when (and (eq (program-name (send window :program)) program-name)
				 (ask-about-frame window))
			(lexpr-send window :update-frame-options options)))))))

(defmethod (:update-frame-options program-frame)
	   (&key program-options
		 panes selected-pane configurations
		 ((:parsed-panes new-parsed-panes))
		 ((:terminal-io-pane new-terminal-io-pane))
		 ((:query-io-pane new-query-io-pane))
		 ((:size-from-pane new-size-from-pane))
	    &allow-other-keys)
  (if (ecase *redefine-program-frames*
	((nil) nil)
	((t) t)
	((:ask)
	 (unless (or inhibit-fdefine-warnings fs:this-is-a-patch-file)
	   (yes-or-no-p 
	     " Replace program for ~S with a new instance
  (reinitializing all state variables)? "
	     self))))
      (structure-forward program		;Take care of binding of *program* elsewhere.
			 (setq program (apply #'make-program (program-name program)
					      :frame self program-options)))
      (apply #'program-update-options program program-options))
  (setq parsed-panes new-parsed-panes
	terminal-io-pane new-terminal-io-pane
	query-io-pane new-query-io-pane
	size-from-pane new-size-from-pane)
  (setq tv:panes panes
	tv:internal-panes
	  (loop for (name . desc) in tv:panes
		collect (cons name
			      (if (typep desc 'tv:sheet)
				  desc
				(let ((old (cdr (assoc name tv:internal-panes))))
				  (if (or (not old)
					  (neq (type-of old) (first desc)))
				      (lexpr-send self :create-pane name desc)
				    (lexpr-send-if-handles
				      old :update-pane-options (rest desc))
				    old)))))
	tv:constraints (tv:convert-configurations configurations tv:panes)
	tv:parsed-constraints
	  (loop for (name . constr) in tv:constraints
		collect (cons name
			      (tv:constraint-frame-parse-constraints self constr))))
  (send self :set-configuration (first (first tv:parsed-constraints)))
  (when selected-pane
    (send self :select-pane (send self :get-pane selected-pane)))
  (tv:sheet-force-access (self :no-prepare)
    (send self :refresh)))

(defmethod (program-update-options program) (&key ((:top-level new-top-level)
						   '(default-command-top-level))
						  ((:pretty-name new-pretty-name) pretty-name)
						  ((:frame-options new-frame-options)
						   frame-options)
						  ((:help new-help) help)
						  ((:state-variables new-state-variables)
						   state-variables)
					     &allow-other-keys)
  (setq top-level new-top-level
	pretty-name new-pretty-name
	help new-help
	frame-options new-frame-options
	state-variables new-state-variables
	state-variable-choices (loop for (var default . type) in state-variables
				     do (ignore default)
				     when (not (null type))
				       collect (list* (zl:locate-in-instance self var)
						      type))))

;;; This isn't systematic, but I think it's better than nothing.
(defmethod (:update-pane-options dynamic-window-pane)
	   (&key (blinker-p t) (blinker-flavor 'tv:rectangular-blinker)
		 (blinker-deselected-visibility :on)
		 (deexposed-typein-action :normal)
		 (deexposed-typeout-action :normal)
		 (end-of-page-mode :default)
		 (label nil label-p)
		 (margin-components `((margin-borders )
				      (margin-white-borders )
				      (margin-label ))
				    margin-components-p)
		 (more-p t)
	    &allow-other-keys)
  (let ((following-blinker (tv:sheet-following-blinker self)))
    (if blinker-p
	(when (null following-blinker)
	  (tv:make-blinker self blinker-flavor
			   :follow-p t
			   :deselected-visibility blinker-deselected-visibility))
	(when following-blinker
	  (send following-blinker :set-visibility nil)
	  (setq tv:blinker-list (delete following-blinker tv:blinker-list)))))
  (send self :set-deexposed-typein-action deexposed-typein-action)
  (send self :set-deexposed-typeout-action deexposed-typeout-action)
  (send self :set-end-of-page-mode end-of-page-mode)
  (send self :set-margin-components margin-components)
  (when (or label-p (not margin-components-p))
    (send self :set-label label))
  (send self :set-more-p more-p))

(define-presentation-type 2named-program-pane0 ((&key program (test #'true))
					      &key test-description)
   :parser ((stream &key original-type initially-display-possibilities)
	    (let* ((parsed-panes (getf (program-frame-options-options
					 (program-frame-options program))
				       :parsed-panes)))
	      (values
		(completing-from-suggestions (stream :type original-type
						     :initially-display-possibilities
						     initially-display-possibilities)
		  (loop for pane-info in parsed-panes
			when (funcall test pane-info)
			do
		    (suggest (string (first pane-info)) pane-info))))))
   :printer ((pane-info stream)
	     (write-string (string (first pane-info)) stream))
   :describer ((stream &key plural-count)
	       (when (numberp plural-count)
		 (if (> plural-count 1)
		     (setq plural-count t)
		     (setq plural-count nil)))
	       (format stream "~:[a ~;~]pane~:*~:[~;s~] of program ~A~@[ ~A~]"
		       plural-count (program-name program) test-description)))

(define-presentation-type 2symbol-naming-program0 ()
   :expander '((and flavor:flavor-name ((satisfies symbol-names-program-p))))
   :describer ((stream &key plural-count)
	       (format stream "~:[a ~;~]symbol~:*~:[~;s~] naming a program" plural-count)))

(defun 2symbol-names-program-p0 (symbol)
  (and symbol
       (flavor:find-flavor symbol nil)
       (subtypep symbol 'program)))



(defflavor program-debugging-frame
	()
	(dynamic-window-frame margin-mixin
	 tv:constraint-frame-with-shared-io-buffer tv:basic-frame))

(defflavor program-frame-debugging-pane
	((debugging-options nil))
	(program-frame tv:pane-mixin)
  :initable-instance-variables
  :gettable-instance-variables)

(defun debug-program (program-name &rest options)
  (declare (arglist program-name &key (start-p t)))
  (let ((frame (tv:make-window 'program-debugging-frame
			       :panes `((program program-frame-debugging-pane
						 :program ,program-name
						 :process (program-debugging-top-level)
						 :debugging-options ,(copy-list options))
					(debug dynamic-window-pane
					       :margin-components
					       ((margin-borders )
						(margin-white-borders )
						(margin-label 
						  :string "Program Debugger"
						  :style (:swiss :italic :normal)))))
			       :configurations `((debugging
						   (:layout (debugging :column program debug))
						   (:sizes (debugging
							     (program :even)
							     (debug :even)))))
			       :selected-pane 'program
			       )))
    (send frame :select)
    frame))

(defun program-debugging-top-level (window)
  (destructuring-bind (&key (start-p t))
		      (send window :debugging-options)
    (let* ((debug (send (send window :superior) :get-pane 'debug))
	   (*debug-io* debug)
	   (*trace-output* debug))
      (when (not start-p)
	(let ((*terminal-io* debug)
	      (*query-io* syn-terminal-io))
	  (tv:window-call-relative (debug)
	    (prompt-and-accept 'character
			       "Type any character to start up ~A:"
			       (send window :name)))))
      (program-frame-top-level window))))

;;; --- We should figure out some way to get control over menu item ordering.
;;; There needs to be a way to get at the program defininition information (which
;;; presumably could contain an ordered list of menu items or something) or have
;;; a user-supplied function that does the menu formatting (or ordering).
;;; This is intended for use as the redisplay-function for command menus.
(defmethod (display-command-menu program) (menu menu-level &rest args)
  (apply #'display-command-table-command-menu command-table menu-level menu args))

;;; --- menu-level is also passed in as one of the keyword arguments, but
;;; there are callers in the environment that expect to be able to pass it
;;; in as a positional.  I could recompile all the program frameworks...
(defun display-command-table-command-menu (command-table menu-level stream
					   &key (rows nil rows-p)
						(columns nil columns-p)
						(box-p nil)
						(center-p nil)
						(equalize-column-widths center-p)
						(extend-width nil ew-p)
						remaining-width remaining-height
					   &allow-other-keys)
  (multiple-value-bind (menu-items presentation-type)
      (command-table-command-menu-item-list command-table menu-level)
    ;; Only attempt formatting if there are any items, either from the
    ;; table or from the user, even if their handlers are not defined.
    (if (or menu-items (and rows-p (consp rows)) (and columns-p (consp columns)))
	(labels ((print-item (item stream)
		   (if box-p
		       (with-output-as-presentation (:stream stream :object item
							     :type presentation-type
							     :allow-sensitive-inferiors nil)
			 (surrounding-output-with-border (stream :move-cursor nil)
			   (present item presentation-type
				    :stream stream)))
		       (present item presentation-type :stream stream)))
		 (format-item-cell (item stream)
		   (format-cell item #'print-item :stream stream
						  :align (and center-p :center))))
	  ;; :extend-width defaults to t when you give :rows.
	  (cond ((and rows-p (listp rows))
		 (let ((row-members (apply #'append rows)))
		   (formatting-table (stream :extend-width (and (null remaining-width)
								(if ew-p extend-width t)))
		     (dolist (row rows)
		       (formatting-row (stream)
			 (dolist (item row)
			   ;; Choose the equivalent version that will have faster lookup
			   ;; for sensitivity, if possible.
			   (setq item (or (find item menu-items :test #'string-equal) item))
			   (format-item-cell item stream))))
		     ;; Format any items that weren't explicitly listed
		     ;; in the :ROWS spec in a separate row.
		     (formatting-row (stream)
		       (dolist (item (set-difference menu-items row-members
						     :test #'string-equal))
			 (format-item-cell item stream))))))
		((and columns-p (listp columns))
		 (let ((column-members (apply #'append columns)))
		   (formatting-table (stream :extend-width (and (null remaining-width)
								(if ew-p extend-width t)))
		     (dolist (column columns)
		       (formatting-column (stream)
			 (dolist (item column)
			   (setq item (or (find item menu-items :test #'string-equal) item))
			   (format-item-cell item stream))))
		     ;; Format any items that weren't explicitly listed
		     ;; in the :COLUMNS spec in a separate column.
		     (formatting-column (stream)
		       (dolist (item (set-difference menu-items column-members
						     :test #'string-equal))
			 (format-item-cell item stream))))))
		(t
		 ;; Just print them out -- should allow more geometry control here.
		 (let ((n-rows nil)
		       (n-columns nil)
		       (spacing (if center-p
				    tv:menu-intercolumn-spacing
				    (* 2 (send stream :char-width)))))
		   (when (and rows-p (integerp rows))
		     (setq n-rows rows))
		   (when (and columns-p (integerp columns))
		     (setq n-columns columns))
		   (when (and (null n-rows) (null n-columns))
		     (setq n-rows 1))		;Preferred orientation is wide and short.
		   (formatting-item-list	;Don't bother with FORMAT-ITEM-LIST.
		     (stream :row-wise center-p :output-row-wise t
			     :n-rows n-rows :n-columns n-columns
			     :inter-column-spacing spacing
			     :equalize-column-widths equalize-column-widths
			     :inside-width (and (null remaining-width)
						extend-width
						(send stream :inside-size))
			     :max-width remaining-width
			     :max-height remaining-height)
		     (dolist (item menu-items)
		       (format-item-cell item stream)))))))
	;; MENU-ITEMS is NIL
	;; If we are sizing, we might not have any menu items yet, so print one
	;; line of dummy text, hopefully in the right style
	(write-string "(No menu items)" stream))))

(defun program-command-menu-item-list (program &optional (menu-level :top-level))
  (command-table-command-menu-item-list (program-command-table program) menu-level))

(defun command-table-command-menu-item-list (&optional (command-table cp:*command-table*)
						       (menu-level :top-level)
						       )
  (let ((cache-entry (assoc menu-level
			    (cp::command-table-menu-accelerator-cache command-table)
			    :test #'equal)))
    (values (menu-accelerator-cache-item-list cache-entry)
	    (menu-accelerator-cache-presentation-type cache-entry))))

;;;; Menu command accelerators

(defvar *command-menu-test-phase* nil)

(defstruct (command-menu-handler :named :conc-name
				 (:constructor make-command-menu-handler
					       (command-name menu-levels gestures
						documentation tester function)))
  command-name
  menu-levels
  gestures
  documentation	;String or function that returns string or command form
  function
  tester
  )

(defstruct (menu-accelerator-cache-entry :list (:conc-name menu-accelerator-cache-))
  menu-level
  gesture-handler-alist
  item-list
  presentation-type
  )

(defmacro define-command-menu-handler ((command-name command-table menu-levels
					&key (gesture :left)
					     (documentation t)
					     (tester nil))
				       arglist &body command-form)
  (define-command-menu-handler-internal command-name command-table menu-levels
					gesture documentation tester
					arglist command-form))

;;; Use this to add items to the command menu if you don't use :menu-accelerator t
;;; or to add synonyms.
(defun add-standard-menu-accelerator (command-table command-symbol
				      &optional accelerator-name
				      (menu-level '(:top-level)))
  (unless accelerator-name
    (setq accelerator-name (cp::generate-command-pretty-name command-symbol)))
  (when (atom menu-level)
    (setq menu-level (list menu-level)))
  (add-command-menu-handler accelerator-name command-table menu-level
			    *standard-menu-command-assigned-buttons* nil
			    #'(lambda (&rest args)
				(declare (accelerator-for name))
				(apply #'standard-command-menu-handler
				       command-symbol
				       :command-table command-table
				       args))))

;;; --- should we support options like :character-style in the command name?
(eval-when (eval load compile)
(defun define-command-menu-handler-internal (command-name command-table menu-levels
					     gesture documentation tester
					     arglist command-form)
  (when (atom gesture)
    (setq gesture (list gesture)))
  (when (atom menu-levels)
    (setq menu-levels (list menu-levels)))
  (unless (member '&rest arglist)
    (if (member '&key arglist)
	(unless (member '&allow-other-keys arglist)
	  (setq arglist `(,@arglist &allow-other-keys)))
	(setq arglist `(,@arglist &rest ignore))))
  (let* ((function-name (fintern "~A-ON-~A-AT-~A-~A-MENU-COMMAND"
				 (first gesture) (string-upcase command-name)
				 (first menu-levels) command-table))
	 (documentation-function (when (and documentation (not (stringp documentation)))
				   (if (eq documentation 't) function-name
				       (fintern "~A-DOCUMENTATION" function-name))))
	 (tester-function (unless (symbolp tester)
			    (fintern "~A-TESTER" function-name))))
    (when (and (consp documentation)
	       (or (keywordp (first documentation))
		   (and (consp (first documentation))
			(keywordp (first (first documentation))))))
      (setq documentation `((&rest args &key gesture &allow-other-keys)
			    (case gesture
			      ,@(loop for (gesture doc) on documentation by 'cddr
				      collect (list gesture doc))
			      (otherwise (apply #',function-name args))))))
    `(progn
       (defun ,function-name ,arglist . ,command-form)
       ,(when (and documentation-function (neq documentation-function function-name))
	  `(defun ,documentation-function . ,documentation))
       ,(when tester-function
	  `(defun ,tester-function . ,tester))
       (add-command-menu-handler ',command-name ',command-table ',menu-levels
				 ',gesture
				 ',(or documentation-function documentation)
				 ',function-name
				 ',(or tester-function tester))))))

(defun add-command-menu-handler (command-name command-table menu-levels
				 gestures documentation function
				 ;; Optional for compatibility with old .bin files.
				 &optional tester)
  (setq command-table (cp:find-command-table command-table))
  (setf (cp::command-table-menu-accelerator-table command-table)
	(cons (make-command-menu-handler command-name menu-levels gestures
					 documentation tester function)
	      (delete-if (lambda (handler)
			   (loop for menu-level in menu-levels
				 thereis (command-menu-handler-match-p
					   handler command-name
					   menu-level gestures)))
			 (cp::command-table-menu-accelerator-table command-table))))
  (cp::command-table-clear-menu-accelerator-cache command-table))

(defun delete-command-menu-handler (command-name command-table menu-levels gestures)
  (setq command-table (cp:find-command-table command-table))
  (setf (cp::command-table-menu-accelerator-table command-table)
	(delete-if (lambda (handler)
		     (loop for menu-level in menu-levels
			   thereis (command-menu-handler-match-p handler command-name
								 menu-level gestures)))
		   (cp::command-table-menu-accelerator-table command-table)))
  (cp::command-table-clear-menu-accelerator-cache command-table))

;;; This isn't used any more, and it's pretty slow to boot.
(defun find-command-menu-handler (command-name command-table menu-level gestures)
  (declare (values handler mouse-type-matched))
  (cp::map-over-command-table-inheritance (cp:find-command-table command-table)
    #'(lambda (command-table)
	(dolist (handler (cp::command-table-menu-accelerator-table command-table))
	  (let ((mouse-type-matched
		  (command-menu-handler-match-p handler command-name menu-level gestures)))
	    (when mouse-type-matched
	      (return-from find-command-menu-handler
		(values handler mouse-type-matched))))))))

(defun command-menu-handler-match-p (handler command-name menu-level gestures)
  (declare (values mouse-type-matched))
  (when (and (string-equal (command-menu-handler-command-name handler) command-name)
	     (member menu-level (command-menu-handler-menu-levels handler) :test #'equal))
    (loop for type in (command-menu-handler-gestures handler)
	  when (member type gestures)
	    return type)))

(defun fill-menu-accelerator-cache (top-command-table)
  (let ((cache nil))
    (cp::map-over-command-table-inheritance top-command-table
      #'(lambda (command-table)
	  (dolist (handler (cp::command-table-menu-accelerator-table command-table))
	    (dolist (level (command-menu-handler-menu-levels handler))
	      (let ((level-entry (assoc level cache :test #'equal)))
		(when (null level-entry)
		  (setq level-entry (make-menu-accelerator-cache-entry
				      :menu-level level
				      :presentation-type `((command-menu-item
							     :command-table ,top-command-table
							     :menu-level ,level))))
		  (push level-entry cache))
		(let ((name (command-menu-handler-command-name handler))
		      (names (menu-accelerator-cache-item-list level-entry)))
		  (let ((old (find name names :test #'string-equal)))
		    (if old
			(unless (eql name old)
			  ;; Share the item names if possible.
			  (setf (command-menu-handler-command-name handler) old))
			(setf (menu-accelerator-cache-item-list level-entry)
			      (cons name names)))))
		(dolist (gesture (command-menu-handler-gestures handler))
		  (let ((gesture-entry (assoc gesture
					      (menu-accelerator-cache-gesture-handler-alist
						level-entry))))
		    (when (null gesture-entry)
		      (setq gesture-entry (ncons gesture))
		      (push gesture-entry (menu-accelerator-cache-gesture-handler-alist
					    level-entry)))
		    ;; This means that a handler from a superior command table only shadows
		    ;; exact matching gesture combinations, not the whole handler.
		    (pushnew handler (cdr gesture-entry)
			     :key #'command-menu-handler-command-name
			     :test #'string-equal))))))))
    (setq cache (nreverse cache))
    (let ((top-entry (assoc :top-level cache)))
      (when top-entry
	(setq cache (cons top-entry (delete top-entry cache)))))
    (dolist (level-entry cache)
      (setf (menu-accelerator-cache-item-list level-entry)
	    (sort (menu-accelerator-cache-item-list level-entry) #'string-lessp))
      (setf (menu-accelerator-cache-gesture-handler-alist level-entry)
	    (sort (menu-accelerator-cache-gesture-handler-alist level-entry) #'<
		  :key #'(lambda (entry)
			   (let ((mouse-char (mouse-char-for-gesture (car entry))))
			     (if (null mouse-char) 9999
				 (dpb (si:mouse-char-bits mouse-char)
				      (byte 8 8) (si:mouse-char-button mouse-char)))))))
      (dolist (gesture-entry (menu-accelerator-cache-gesture-handler-alist level-entry))
	(setf (cdr gesture-entry) (sort (cdr gesture-entry) #'string-lessp
					:key #'command-menu-handler-command-name))))
    (copy-tree cache)))				;Localize and cdr-code.  :area ??

(defun command-menu-item-handler (command-table menu-level menu-item gesture)
  (let ((level-entry (assoc menu-level 
			    (cp::command-table-menu-accelerator-cache command-table)
			    :test #'equal)))
    (when level-entry
      (let ((gesture-entry (assoc gesture
				  (menu-accelerator-cache-gesture-handler-alist level-entry))))
	(when gesture-entry
	  (unless (atom menu-item)
	    (setq menu-item (tv:menu-execute-no-side-effects menu-item)))
	  ;; Since the item most likely came from the handler cache, first try EQL for the
	  ;; name.  If that fails, then try string-equal, since there may have been a
	  ;; redefinition since the table was displayed.
	  (or (find menu-item (cdr gesture-entry) :key #'command-menu-handler-command-name)
	      (find menu-item (cdr gesture-entry) :key #'command-menu-handler-command-name
						  :test #'string-equal)))))))

(define-presentation-type command-menu-item ((&key menu-level command-table) &key arguments)
   ;;--- If the printer ever uses the command table, then this will
   ;;--- need a 2:typep0 method.
   :printer ((item stream)
	     (if (atom item)
		 (princ item stream)
		 (write-string (first item) stream))))

(define-presentation-translator command-menu-translator
				(command-menu-item cp:command
				 :gesture t
				 :do-not-compose t
				 :tester standard-command-menu-tester
				 :documentation standard-command-menu-documentation)
				(object &rest args)
  (apply #'standard-command-menu-translator :value object args))

(defun standard-command-menu-tester (menu-item &rest keywords
				     &key input-context handler
				     &allow-other-keys)
  (let ((command-form (catch 'command-menu-test-phase
			(let ((*command-menu-test-phase* t))
			  (values (apply #'standard-command-menu-translator
					 :test menu-item keywords))))))
    (and command-form
	 (standard-command-translator-tester-1 command-form handler input-context))))

(defvar *command-menu-documentation-prefix* nil)

(defun standard-command-menu-documentation (menu-item &rest keywords
					    &key input-context &allow-other-keys)
  (multiple-value-bind (command-form prefix)
      (let ((*command-menu-documentation-prefix* nil)
	    (*command-menu-test-phase* :documentation))
	(values
	  (catch 'command-menu-test-phase
	    (apply #'standard-command-menu-translator :documentation menu-item keywords))
	  *command-menu-documentation-prefix*))
    (values
      (cond ((or (null command-form) (stringp command-form)) command-form)
	    ;; This will cause the normal hook to substitute Default
	    ;; arguments, but still give something better looking for
	    ;; the presentation inspector, etc.
	    ((and prefix (null (rest command-form))) prefix)
	    (t (cp:unparse-command (first command-form) (rest command-form)
				   (let ((presentation-type
					   (presentation-input-context-presentation-type
					     input-context)))
				     (case (presentation-type-name presentation-type)
				       (cp:command
					 (with-presentation-type-arguments
					   (cp:command presentation-type)
					   cp::command-table))
				       (cp:command-or-form
					 (with-presentation-type-arguments
					   (cp:command-or-form presentation-type)
					   cp::command-table))
				       (otherwise cp:*command-table*))))))
      prefix)))

(defun standard-command-menu-translator (mode menu-item
					 &key presentation gesture window
					 &allow-other-keys)
  (with-inherited-presentation-type-arguments
      (command-menu-item (presentation-type presentation) :error-p nil)
    (let ((menu-handler (command-menu-item-handler command-table menu-level
						   menu-item gesture)))
    (if (null menu-handler)
	(when (eq mode :value)
	  (cp::accelerator-error "~@(~A~) on ~A ~:[in ~:(~A~) ~]is not a defined command."
				 gesture (if (atom menu-item) menu-item (first menu-item))
				 (eq menu-level :top-level)
				 menu-level))
	(block special
	  (when (eq mode :test)
	    (let ((function (command-menu-handler-tester menu-handler)))
	      (when function
		(unless (funcall function
				 :menu-level menu-level
				 :arguments arguments
				 :window window
				 :gesture gesture)
		  (return-from special nil)))))
	  (let ((function (command-menu-handler-function menu-handler)))
	    (when (eq mode :documentation)
	      (let ((other (command-menu-handler-documentation menu-handler)))
		(when other
		  (if (stringp other)
		      (if (rest (command-menu-handler-gestures menu-handler))
			  ;; If this is used for more than one gesture, return as prefix
			  ;; and continue to calculate arguments.
			  (setq *command-menu-documentation-prefix* other)
			  (return-from special other))
		      (setq function other)))))
	    (funcall function
		     :menu-level menu-level
		     :arguments arguments
		     :window window
		     :gesture gesture)))))))

;;; No one seems to be using this, and it isn't exported, but then again, it's easy to
;;; be compatible.
(deff command-table-menu-accelerator-alist 'command-table-command-menu-item-list)

(defun standard-command-menu-handler (command-name &rest args)
  (when (eq *command-menu-test-phase* 't)
    (throw 'command-menu-test-phase `(,command-name)))
  (cons command-name (apply #'command-menu-choose-arguments command-name args)))

(defun command-menu-choose-arguments (command-name &rest args
						   &key (initial-arguments nil)
							(command-table cp:*command-table*)
							(gesture :left)
							(mode nil) (own-window nil)
							(full-rubout t)
						   &allow-other-keys)
  (setq command-table (cp:find-command-table command-table))
  (multiple-value-bind (mode own-window)
      (if mode
	  (values mode own-window)
	  (apply #'cp::select-best-choose-arguments-mode command-name
		 :command-table command-table :for-select-gesture (eq gesture :left)
		 :allow-other-keys t args))
    (when (eq *command-menu-test-phase* :documentation)
      (throw 'command-menu-test-phase
	(if (eq mode :none)
	    `(,command-name)
	    (with-output-to-string (stream)
	      (case mode
		((:keyboard) (write-string "Read arguments for " stream))
		((:menu) (write-string "Menu for " stream))
		((:accept-values) (write-string "Choose arguments for " stream)))
	      (present (cons command-name initial-arguments)
		       `((cp:command :command-table ,command-table))
		       :stream stream)))))
    (let ((args (with-typeout-help-stream-if-appropriate
		  (apply #'cp:choose-command-arguments command-name
			 :stream *query-io*
			 :typeout-stream (si:input-editor-flag :help-stream)
			 :mode mode :own-window own-window
			 :full-rubout full-rubout :erase-input-editor t
			 :command-table command-table :allow-other-keys t args))))
      (when (eq args :full-rubout)
	(throw 'abort-command-read t))
      args)))

(defun program-command-menu-handler-defaults (command-name program-name &rest args
					      &key gesture window &allow-other-keys)
  (case *command-menu-test-phase*
    ((t)
     (throw 'command-menu-test-phase `(,command-name)))
    ((:documentation)
     (when (eq gesture :left)
       (let ((program (current-program :window window :type program-name :error-p nil)))
	 (when program
	   (throw 'command-menu-test-phase
	     (cons command-name
		   (let ((*program* program))
		     (cp::default-positional-arguments command-name
						       :command-table program-name)))))))))
  (cons command-name (apply #'command-menu-choose-arguments command-name
			    :command-table program-name args)))

;;; Hook it up to the UI.  If the top-level remote-program doesn't handle this
;;; click, see if the currently "selected" program will.
(defmethod (call-menu-handler program) (handler)
  (with-program-terminal-streams (self)
    (when handler
      (apply (first handler) (rest handler)))))

(defmethod (lookup-menu-handler program) (menu-level menu-item &key (gesture ':left))
  (command-menu-item-handler command-table menu-level menu-item gesture))

(defmethod (get-menu-handler program) (menu-level menu-item &key (gesture ':left))
  (let ((handler (lookup-menu-handler self menu-level menu-item :gesture gesture)))
    (when handler
      (let ((command (funcall (command-menu-handler-function handler)
				:command-table command-table
				:menu-level menu-level
				:gesture gesture)))
	  command))))

(defmethod (synchronous-call-menu-handler program) (&rest args)
  (declare (arglist menu-level menu-item))
  (with-program-terminal-streams (self)
    (send *standard-input* :force-kbd-input
	  (make-presentation-blip :presentation-type 'window-wakeup-call-menu-handler
				  :object (cons self (copy-list args))))))

(defun current-program (&key (window nil) (type 'program) (error-p t))
  (when window
    (loop for window = window then (send window :superior)
	  while window
	  when (typep window 'program-frame)
	    do (let ((program (send window :program)))
		 (when (typep program type)
		   (return-from current-program program)))))
  (when (and (variable-boundp *program*)
	     (typep *program* type))
    (return-from current-program *program*))
  (when error-p
    (command-error "The current program is not a ~S" type)))

;;--- Can this make use of CURRENT-PROGRAM?
(defun selected-program ()
  (when tv:selected-window
    (let ((alias (send tv:selected-window :alias-for-selected-windows)))
      (when alias
	(send-if-handles alias :program)))))

(defvar *command-table-command-menu-default-item* (make-hash-table :test 'equal))

(defun command-table-command-menu-default-item (command-table menu-level)
  (setq command-table (cp:find-command-table command-table))
  (stack-let ((key (list command-table menu-level)))
    (gethash key *command-table-command-menu-default-item*)))

(defun set-command-table-command-menu-default-item (command-table menu-level default)
  (setq command-table (cp:find-command-table command-table))
    (setf (gethash (list command-table menu-level) *command-table-command-menu-default-item*)
	  default))

(defsetf command-table-command-menu-default-item set-command-table-command-menu-default-item)

(defmethod (sort-subcommand-menu program :default) (menu-items &rest ignored)
  menu-items)

(defun invoke-subcommand-menu (menu-level prompt
			       &rest args
			       &key (command-table cp:*command-table*)
				    (gesture :right)
				    window
			       &allow-other-keys)
  (multiple-value-bind (menu-items type)
      (command-table-command-menu-item-list command-table menu-level)
    (unless (or *inside-handler-test-phase*
		*inside-handler-documentation-phase*)
      ;; Don't do this expensive operation unless truly needed.
      ;; This will fail if the sort guy is allowed to eliminate items, thereby
      ;; making them inaccessible, because they won't get eliminated during the
      ;; test phase, but I think we can legislate that out of existance.
      (when (and (variable-boundp *program*)
		 (operation-handled-p *program* 'sort-subcommand-menu))
	(setq menu-items (apply 'sort-subcommand-menu *program* menu-items menu-level prompt
				args))))
    (let ((default (command-table-command-menu-default-item command-table menu-level)))
      (setq default (find default menu-items :test #'string=))
      (let ((fake-presentation (make-instance 'presentation :type type)))
	(flet ((do-one (class item &optional (gesture gesture))
		 (setf (presentation-object fake-presentation) item)
		 (apply #'standard-command-menu-translator class item
			:presentation fake-presentation :gesture gesture args)))
	  (case *command-menu-test-phase*
	    ((t)
	     (case gesture
	       ((:left) (and default (do-one :test default)))
	       (otherwise (loop for item in menu-items thereis (do-one :test item)))))
	    ((:documentation)
	     (case gesture
	       ((:left)
		(do-one :documentation default))
	       (otherwise (throw 'command-menu-test-phase "Menu of more commands"))))
	    (otherwise
	      (case gesture
		((:left) (and default (do-one :value default)))
		(otherwise
		  (let ((item
			  (menu-choose-from-set menu-items type
						:superior (tv:mouse-default-superior window)
						:prompt prompt
						:default default)))
		    (when item
		      (setf (command-table-command-menu-default-item command-table menu-level)
			    item)
		      (do-one :value item :left))))))))))))

(defprop subcommand-menu-handler t si:debug-info)

(defmacro define-subcommand-menu-handler (menu-name command-table in-menu-level to-menu-level)
  `(define-command-menu-handler (,menu-name ,command-table ,in-menu-level
				 :gesture (:left :right))
				(&rest args)
     (declare (subcommand-menu-handler ,to-menu-level))
     (apply #'invoke-subcommand-menu ',to-menu-level ',menu-name args)))

;;;; 2Menu-choose

0(define-presentation-type menu-alist-element ((&key alist) )
   :printer ((alist-element stream)
	     (let ((style (and (consp alist-element)
			       (consp (cdr alist-element))
			       (getf (cdddr alist-element) :style))))
	       (if style
		   (with-character-style (style stream :bind-line-height t)
		     (write-string (token-element-string alist-element) stream))
		   (write-string (token-element-string alist-element) stream))))
   :key-generator (progn alist 'menu-alist-element)	;To get the next to run
   )

(define-presentation-translator menu-choose-alist-element
   (menu-alist-element menu-alist-element
    :tester ((menu-item &key input-context presentation)
	     (and (or (not (listp menu-item))
		      (atom (cdr menu-item))
		      (neq (second menu-item) :no-select))	;don't need GET(F)
		  ;because :NO-SELECT must appear 2nd
		  (eq (presentation-type presentation)
		      (presentation-input-context-presentation-type input-context))))
    :gesture t
    :exclude-other-handlers t
    :documentation ((item &key gesture)
		    (block use-this
		      (unless (or (atom item) (atom (cdr item)))
			(when (eq (second item) :buttons)
			  (let ((mouse-char (mouse-char-for-gesture gesture)))
			    (when mouse-char
			      (let ((bitem (nth (si:mouse-char-button mouse-char)
						(third item))))
				(when (atom bitem)
				  (return-from use-this (string bitem)))
				(when (consp (rest bitem))
				  (let ((doc (getf (zl:rest3 bitem) :documentation)))
				    (when doc
				      (return-from use-this doc))))
				(return-from use-this (string (car bitem)))))))
			(let ((doc (getf (zl:rest3 item) :documentation)))
			  (when doc
			    (return-from use-this
			      (let ((length (string-length doc)))
				(if (and (plusp length)
					 (char-equal (aref doc (1- length)) #\.))
				    (substring doc 0 (1- length))
				    doc))))))
		      "Select this choice")))
   (item)
  item)

(define-presentation-type presentation-handler-menu-choice
      ((&key alist presentation original-presentation window x y
	     original-program)			;Since *program* will be the menu.
       )
   :expander `((menu-alist-element :alist ,alist))
   :key-generator (progn alist presentation original-presentation window x y original-program
			 'presentation-handler-menu-choice)
   )

(define-presentation-translator presentation-handler-menu-choice
   (presentation-handler-menu-choice presentation-handler-menu-choice
    :tester ((ignore &key input-context presentation)
	     (eq (presentation-type presentation)
		 (presentation-input-context-presentation-type input-context)))
    :gesture t
    :documentation ((item &key presentation gesture mouse-char)
		    (with-presentation-type-arguments (presentation-handler-menu-choice
							(presentation-type presentation))
		      (destructuring-bind (ignore ignore (handler context) . ignore)
			 item
			(let ((*program* original-program))
			  (presentation-mouse-handler-context-documentation
			    :handler handler :input-context context	;From item
			    :presentation presentation :window window :x x :y y	;From type
			    :gesture gesture :mouse-char mouse-char	;From mouse
			    ))))))
   (handler)
  handler)

(defun menu-choose (item-alist &rest options &key presentation-type &allow-other-keys)
  (declare (arglist item-list &key
		    (prompt nil)
		    (default nil)
		    (presentation-type nil)
		    (printer nil)
		    (near-mode '(:mouse))
		    (alias-for-selected-windows nil)
		    (superior (tv:mouse-default-superior))
		    (row-wise t)
		    (center-p *default-menu-center-p*)
		    (character-style '(:jess :roman :large))
		    (momentary-p t)
		    (temporary-p momentary-p)
		    minimum-width minimum-height)
	   (values choice item mouse-char))
  (unless presentation-type
    (setq presentation-type
	  `((menu-alist-element :alist ,item-alist))))
  (multiple-value-bind (item mouse-char)
      (apply #'menu-choose-from-set item-alist
	     presentation-type
	     (si:rem-keywords options '(:presentation-type)))
    (when item
      (loop while (and (consp item) (consp (rest item)) (eq (second item) :buttons))
	    do (setq item (nth (si:mouse-char-button mouse-char) (third item))))
      (values (tv:menu-execute item)
	      item
	      mouse-char))))

;;; Who knows why this isn't defined someplace else.
(defmethod (:maximum-exposable-inside-size dynamic-window) ()
  (sheet-maximum-exposable-inside-size self))

(defun sheet-maximum-exposable-inside-size (sheet)
  (values (- (tv:sheet-inside-width (tv:sheet-superior sheet))
	     (tv:sheet-left-margin-size sheet)
	     (tv:sheet-right-margin-size sheet))
	  (* (floor (- (tv:sheet-inside-height (tv:sheet-superior sheet))
		       (tv:sheet-top-margin-size sheet)
		       (tv:sheet-bottom-margin-size sheet))
		    (tv:sheet-line-height sheet))
	     (tv:sheet-line-height sheet))))

(defmethod (:maximum-exposable-inside-size dynamic-window-pane) ()
  (multiple-value-bind (width height)
      (sheet-maximum-exposable-inside-size tv:superior)
    (values (- width tv:left-margin-size tv:right-margin-size)
	    (- height tv:top-margin-size tv:bottom-margin-size))))

(defvar *default-menu-center-p* nil)
(defvar *menu-choose-margin-choices*
	`((margin-drop-shadow-borders )
	  (margin-label :box :inside :margin :top)
	  (margin-white-borders :thickness 2)
	  (margin-scroll-bar :visibility :if-needed)))

(defun menu-choose-from-set (list presentation-type &rest args
			     &key prompt default
				  (center-p *default-menu-center-p*)
				  (row-wise t)
				  printer
			     &allow-other-keys)
  (declare (arglist list presentation-type &key
		    (printer nil)
		    (prompt nil)
		    (default nil)
		    (near-mode '(:mouse))
		    (superior (tv:mouse-default-superior))
		    alias-for-selected-windows
		    (row-wise t)
		    (center-p *default-menu-center-p*)
		    (character-style '(:jess :roman :large))
		    (momentary-p t)
		    (temporary-p momentary-p)
		    minimum-width minimum-height))
  (when (remote-terminal-p)
    (return-from menu-choose-from-set
      (values (accept presentation-type :prompt (if (consp prompt)
						    (getf prompt :string)
						    prompt)
					:default default)
	      nil)))
  (when (null list)
    (return-from menu-choose-from-set nil))
  (apply #'menu-choose-from-drawer
    (zl:named-lambda drawer (stream &key max-width max-height)
		     (draw-menu-choices list presentation-type stream
					:printer printer
					:max-width max-width
					:max-height max-height
					:row-wise row-wise
					:center-p center-p))
    presentation-type (si:rem-keywords args '(:printer))))

;; The 1drawer0 is funcalled (perhaps several times, within 2redisplayer0)
;; given 1stream0 and the keyword arguments 1:max-width0 and 1:max-height0.
;; It is to return a list of presentations.
(defun menu-choose-from-drawer (drawer presentation-type &key
				(prompt nil)
				(default nil)
				(near-mode '(:mouse))
				(superior (tv:mouse-default-superior))
				(alias-for-selected-windows nil)
				(row-wise t)
				(center-p *default-menu-center-p*)
				(character-style *default-menu-character-style*)
				(momentary-p t)
				(temporary-p momentary-p)
				(use-redisplay t)
				minimum-width minimum-height)
  (ignore center-p row-wise)
  (let ((rubout-handler nil)			;Not us.
	(*input-editor-options* nil)
	(*presentation-input-context* nil)
	(presentations nil))
    ;; Use a specialized resource of menus so that we don't have to do very
    ;; much initialization (e.g. of margin components).
    (using-resource (menu dynamic-menu superior
			  :momentary-p momentary-p :temporary-p temporary-p)
      (when alias-for-selected-windows
	(send menu :set-alias-for-selected-windows alias-for-selected-windows))
      (multiple-value-setq (presentations)
	(menu-choose-call-drawer menu drawer :label prompt
					     :character-style character-style
					     :use-redisplay use-redisplay
					     :minimum-width minimum-width
					     :minimum-height minimum-height))
      (menu-choose-internal menu presentation-type presentations
			    :default-presentation
			    (when default
			      (dolist (presentation presentations)
				(when (and presentation
					   (eq (presentation-object presentation)
					       default))
				  (return presentation))))
			    :center-p center-p
			    :near-mode near-mode))))

(defun menu-choose-call-drawer (menu drawer &key (label nil)
				(character-style *default-menu-character-style*)
				(mouse-blinker-character #\mouse:times)
				(use-redisplay nil)
				minimum-width minimum-height)
  (when (null minimum-width) (setq minimum-width 0))
  (when (null minimum-height) (setq minimum-height 0))
  (let ((*presentation-area* working-storage-area)
	(label-width nil) (label-height nil)
	(presentations nil))
    (when label
      (multiple-value-setq (label-width label-height)
	(margin-label-size label menu)))
    (when label-height
      (multiple-value-bind (iw ih)
	  (send menu :inside-size)
	;; If there isn't already a label, or the new label is taller than the old label,
	;; the inside-height will be decreased to make room for the label.  If this makes
	;; the inside-height negative, we will blow out.  So make the inside-height large
	;; enough for the worst case while we :set-label.  The inside-size will be
	;; adjusted again twice more before we are done.
	(when (> label-height ih)
	  (send menu :set-inside-size iw label-height))))
    (send menu :set-label label)
    (send menu :set-mouse-blinker-character mouse-blinker-character)
    ;; Use default-character-style so that redisplay doesn't mess up with baseline adjust.
    (send menu :set-default-character-style character-style)
    (multiple-value-bind (max-width max-height)
	(send menu :maximum-exposable-inside-size)
      (let ((redisplayer (and use-redisplay
			      (redisplayer (stream)
				(setq presentations (funcall drawer stream
							     :max-width max-width
							     :max-height max-height))))))
	(let ((scroll-bar (find-margin-component menu 'margin-scroll-bar)))
	  (let ((old-visibility (and scroll-bar
				     (margin-scroll-bar-visibility scroll-bar))))
	    (unwind-protect
		(progn
		  (when scroll-bar
		    (setf (margin-scroll-bar-visibility scroll-bar) :suppressed))
		  ;; Draw the contents of the menu into its output history.
		  ;; The inside-height had better be zero here, because this does
		  ;; not copy any bits back from the pixmap to the menu's bit-array.
		  (send menu :set-inside-size 0 0)
		  (tv:with-temporary-sheet-bit-raster (pixmap menu (tv:sheet-width menu)
								   (tv:sheet-height menu))
		    (tv:with-off-screen-drawing-2 (tv:sheet-screen menu) menu pixmap
		      #'(lambda ()
			  (tv:sheet-force-access (menu :no-prepare)
			    (send menu :clear-history)
			    (with-output-truncation (menu)
			      (if redisplayer
				  (do-redisplay redisplayer menu :once-only t)
				  (setq presentations (funcall drawer menu
							       :max-width max-width
							       :max-height max-height)))))))))
	      (when scroll-bar
		(setf (margin-scroll-bar-visibility scroll-bar) old-visibility))))
	  (multiple-value-bind (width height)
	      (if redisplayer
		  (box-size (redisplay-piece-new-box redisplayer))
		  (values (send menu :maximum-x-position)
			  (send menu :maximum-y-position)))
	    (when label
	      (maxf width label-width))
	    (when scroll-bar
	      (maxf height (margin-scroll-bar-minimum-height scroll-bar)))
	    (incf width) (incf height 2)	;Compensate for VSP and exception test
	    (minf width max-width)
	    (minf height max-height)
	    ;; This will draw the contents of the menu from its output history
	    (send menu :set-inside-size (max width minimum-width)
					(max height minimum-height))
	    ;; System will have tried to make box size an integral number of lines,
	    ;; which isn't good for menus.
	    (set-box-size (send menu :cursor-viewport) width height)))))
    presentations))

(defun draw-menu-choices (list presentation-type stream
			  &key (center-p *default-menu-center-p*) (row-wise t)
			       max-width max-height printer)
  (let ((align (and center-p :center)))
    (with-stack-array (presentations (length list))
      (formatting-item-list (stream :max-width max-width :max-height max-height
				    :row-wise row-wise :output-row-wise t)
	(loop for item in list
	      for index from 0
	      do
	  (formatting-cell (stream :align align)
	    (setf (aref presentations index)
		  (if printer
		      (with-output-as-presentation (:stream stream :object item
						    :type presentation-type
						    :single-box t
						    :allow-sensitive-inferiors nil
						    :allow-sensitive-raw-text nil)
			(funcall printer item stream))
		      (present item presentation-type :stream stream
			       :single-box t
			       :allow-sensitive-inferiors nil
			       :allow-sensitive-raw-text nil))))))
      (coerce presentations 'list))))

(defun position-window-near-carefully (window near-mode)
  (tv:expose-window-near window near-mode nil nil)
  (multiple-value-bind (left top right bottom)
      (send window :edges)
    (multiple-value-bind (sleft stop sright sbottom)
	(send (send window :superior) :inside-edges)
      (cond ((< left sleft)
	     (psetq left sleft
		    right (min sright (+ sleft (- right left)))))
	    ((> right sright)
	     (psetq right sright
		    left (max sleft (- sright (- right left))))))
      (cond ((< top stop)
	     (psetq top stop
		    bottom (min sbottom (+ stop (- bottom top)))))
	    ((> bottom sbottom)
	     (psetq bottom sbottom
		    top (max stop (- sbottom (- bottom top)))))))
    (send window :set-edges left top right bottom)))

;; This could be a function that would get the character style for the menu
;; and then using the width of a space, calculate the width of about 2 chars.
(defvar *default-menu-choose-x-offset* 2)	;number of characters

(defun menu-choose-internal (menu presentation-type item-presentations
			     &key (default-presentation nil)
				  (center-p nil)
				  (near-mode '(:mouse)))
  (position-window-near-carefully menu near-mode)		;Position without exposing
  (let ((*presentation-area* working-storage-area)
	(*terminal-io* menu)
	(x-offset (if center-p
		      99999
		      (round (* *default-menu-choose-x-offset*
				(send menu :char-width))))))
    (tv:saving-mouse-position menu
      (multiple-value-bind (left top right bottom)
	  (send menu :visible-cursorpos-limits)
	(multiple-value-bind (x y)
	    (if default-presentation
		(let* ((box (presentation-displayed-box default-presentation))
		       (center-x (min (box-center-x box) (+ (box-left box) x-offset)))
		       (center-y (box-center-y box)))
		  ;; If desired item is not visible, move it into the viewport.
		  (unless (and ( (box-left box) left)
			       ( (box-right box) right)
			       ( (box-top box) top)
			       ( (box-bottom box) bottom))
		    (tv:sheet-force-access (menu t)	;Not exposed yet
		      (send menu :scroll-to-visible-cursor
				   (if (< (box-left box) left) (box-left box) (box-right box))
				   (if (< (box-top box) top) (box-top box) (box-bottom box)))
		      (multiple-value-setq (left top right bottom)
			(send menu :visible-cursorpos-limits))))
		  (values center-x center-y))
		;; No default presentation, center mouse vertically but near left edge
	      (values (min (floor (+ left right) 2) x-offset)
		      (floor (+ top bottom) 2)))
	  ;; Warp mouse before exposing menu
	  ;; x and y are window coordinates
	  (send menu :set-mouse-position x y nil))
      (zl:with-notification-mode (:pop-up menu)
	(tv:window-call (menu :deactivate)
	  (let* ((program (dynamic-menu-resource-menu-program menu))
		 (help-window nil)
		 (*help-displayer*
		   (lambda (continuation stream)
		     (setq help-window (display-own-window-help help-window menu "menu"
								continuation stream)))))
	    (reset-program-state-variables program
					   `((menu ,menu)
					     (highlighted-presentation nil)
					     (keyboard-choice-string nil)
					     (presentation-type ,presentation-type)
					     (item-presentations ,item-presentations)))
	    (multiple-value-bind (item mouse-char)
		(unwind-protect
		    (run-program-top-level program)
		  (deallocate-help-window help-window))
	      (tv:restore-mouse-position-if-necessary item)
	      (values item mouse-char)))))))))

(defun menu-choose-from-copy-of-window-contents
       (window presentation-type &key (prompt nil)
				      (default nil)
				      (near-mode '(:mouse))
				      (superior (tv:mouse-default-superior window))
				      (momentary-p t)
				      (temporary-p momentary-p))
  (let ((rubout-handler nil)			;Not us.
	(*input-editor-options* nil)
	(*presentation-input-context* nil))
    (using-resource (menu dynamic-menu superior
			  :momentary-p momentary-p :temporary-p temporary-p)
      (send menu :set-label prompt)
      (multiple-value-bind (width height)
	  (send window :inside-size)
	(send menu :set-inside-size width height))
      (tv:sheet-force-access (menu)
	(copy-presentations-in-region window menu :clear-history-first t
				      :set-cursor-boundaries-after t)
	(maxf (send menu :minimum-y-position) 0)
	(send menu :refresh))
      (let ((presentations (coerce (send menu :displayed-presentations) 'list)))
	(menu-choose-internal menu presentation-type presentations
			      :default-presentation
			       (when default
				 (dolist (presentation presentations)
				   (when (and presentation
					      (eq (presentation-object presentation)
						  default))
				     (return presentation))))
			      :near-mode near-mode)))))

;;; This does not need any frames, panes, or such.  It just wants a command loop,
;;; program state variables, command reading, and such.

(define-program-framework menu-program
  :command-definer t
  :command-table (:kbd-accelerator-p t
		  :inherit-from '("standard arguments"))
  :top-level (menu-command-loop)
  :selectable nil
  :state-variables ((menu)
		    (presentation-type)
		    (item-presentations nil)
		    (highlighted-presentation nil)
		    (keyboard-choice-string nil)))

;;; A few defun-in-flavors.  These have to be up front, since I don't have my
;;; hands on the defflavor for menu-program.

(defvar *menu-selection-highlighting-mode* :underline)

(defun-in-flavor (set-new-highlighted-menu-presentation menu-program)
		 (new-highlighted-presentation)
  (if (null new-highlighted-presentation)
      (beep)
    (when highlighted-presentation
      (displayed-presentation-clear-highlighting highlighted-presentation menu
						 *menu-selection-highlighting-mode*))
    (setq highlighted-presentation new-highlighted-presentation)
    (displayed-presentation-set-highlighting highlighted-presentation menu
					     *menu-selection-highlighting-mode*)))

(defun-in-flavor (update-for-new-choice-string menu-program) ()
  (dolist (presentation item-presentations)
    (multiple-value-bind (displayed-string start-index end-index)
	(displayed-presentation-string-equal-start presentation keyboard-choice-string)
      (when displayed-string
	(when highlighted-presentation
	  (displayed-presentation-clear-highlighting highlighted-presentation menu
						     *menu-selection-highlighting-mode*))
	(send menu :add-region-string displayed-string start-index end-index
	      *menu-selection-highlighting-mode*)
	(setq highlighted-presentation presentation)
	(return t)))))

;;; Trimmed down version of standard method, doesn't invoke
;;; find-command-table, calls menu top-level function directly.
(defmethod (run-program-top-level menu-program) ()
  (let ((*program* self)
	(cp:*command-table* command-table))
    (menu-command-loop self)))

(defmethod (menu-command-loop menu-program) ()
  ;; rely on menu-choose-internal to have reset the state vars
  (si:with-process-interactive-priority ()
    (catch 'return-from-menu			;thrown to by kbd-accel for #\End
      (catch-error-restart (abort "Abort this menu choice")
	(with-presentation-input-context (presentation-type :stream menu) (blip)
	     (loop doing
	       (multiple-value-bind (command arguments kind)
		   (read-program-command self :stream menu :echo-stream #'ignore
					 :prompt nil :status :exposed
					 :notification nil :intercept-function nil
					 :unknown-accelerator-tester #'graphic-char-p)
		 (case kind
		   (:status (return nil))
		   (:unknown (menu-program-add-character-to-choice-string self arguments))
		   (otherwise 
		     ;; We consider the menu commands to be entirely interactive, like the
		     ;; input-editor's commands.
		     (apply command arguments)))))
	   (t
	     (values (presentation-blip-object blip)
		     (presentation-blip-mouse-char blip))))))))

;;; This runs as a "command" for random graphics chars typed at the menu.
(defmethod (menu-program-add-character-to-choice-string menu-program) (character)
  (when (null keyboard-choice-string)
    (setq keyboard-choice-string (make-array 10 :element-type 'string-char
					     :fill-pointer 0)))
  (vector-push-extend character keyboard-choice-string)
  (update-for-new-choice-string))

(define-menu-program-command (menu-stupid-help :keyboard-accelerator #\Help) ()
  "Print this description"
  (funcall *help-displayer*
	   (lambda (stream)
	     (declare (sys:downward-function))
	     (let ((*standard-output* stream))
	       (format t "~&Click on a menu item to choose it, or~@
			enter its name from the keyboard.~%")
	       (cp::read-accelerated-command-minimal-help
		 (cp:find-command-table 'menu-program))))
	   *standard-output*))

(define-menu-program-command (com-highlight-next-item) ((count 'integer :default 1))
  (let ((new-highlighted-presentation (nth (max 0
						(min
						  (if highlighted-presentation
						      (+ count
							 (position highlighted-presentation
								   item-presentations))
						      (1- count))
						  (1- (length item-presentations))))
					   item-presentations)))
    (set-new-highlighted-menu-presentation new-highlighted-presentation)))

(cp:define-command-accelerator highlight-next-item menu-program #\c-N () (ignore arg)
  "Move down to next menu item"
  `(com-highlight-next-item ,arg))

(cp:define-command-accelerator highlight-previous-item menu-program #\c-P () (ignore arg)
  "Move up to previous menu item"
  `(com-highlight-next-item ,(- arg)))

(define-menu-program-command (com-choose-highlighted-item :keyboard-accelerator #\End) ()
  "Choose underlined item"
  (if highlighted-presentation
      (throw 'return-from-menu
	(presentation-object highlighted-presentation))
      (beep)))

(define-menu-program-command (com-menu-abort :keyboard-accelerator #\Abort) ()
   "Abort from this menu"
   (signal 'abort))

(define-menu-program-command (com-delete-last-choice-string-char
			       :keyboard-accelerator #\Rubout) ()
  "Delete last character typed"
  (if (or (null keyboard-choice-string)
	  (zerop (fill-pointer keyboard-choice-string)))
      (beep)
    (decf (fill-pointer keyboard-choice-string))
    (update-for-new-choice-string)))

;;; Clear-input sort of puts it all back at the start
(define-menu-program-command (com-delete-all-choice-string-chars
			       :keyboard-accelerator #\Clear-input) ()
  "Delete all typed input"
  (when keyboard-choice-string
    (setf (fill-pointer keyboard-choice-string) 0))
  (when highlighted-presentation
    (displayed-presentation-clear-highlighting highlighted-presentation menu)
    (setq highlighted-presentation nil)))

;;;---These belong somewhere else.
(defmethod (displayed-presentation-string-equal-start displayed-presentation) (string)
  (dolist (inferior inferiors)
    (multiple-value-bind (str start end)
	(displayed-presentation-string-equal-start inferior string)
      (when str
	(return (values str start end))))))

(defmethod (displayed-presentation-string-equal-start text-displayed-presentation) (string)
  (and (string-equal string (displayed-string-string displayed-string)
		     :end2 (vector-length string))
       (values displayed-string 0 (vector-length string))))



(compile-flavor-methods program-frame program-frame-with-pane-mixin
			program-frame-resource
			program-debugging-frame program-frame-debugging-pane)

(tv:defwindow-resource program-frame (program-name &key temporary-p
							(process '(program-frame-top-level)))
  :initial-copies nil
  :initializer (send object :clear-all)
  :reusable-when :deactivated
  :make-window (program-frame-resource :program program-name
				       :temporary-p temporary-p
				       :process process
				       :margin-components (if temporary-p
							       `((margin-drop-shadow-borders)
								 (margin-borders))
							       '((margin-borders)))))

(compile-flavor-methods menu-program)
