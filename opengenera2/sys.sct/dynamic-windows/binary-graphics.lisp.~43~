;;; -*- Mode: LISP; Syntax: Common-lisp; Package: GRAPHICS; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;Next available operation opcode is 28
;;Next available command opcode is 75

;;; defvar too, as it happens
(defprop define-binary-graphics-command defun zwei:definition-function-spec-type)

(defmacro define-binary-graphics-command (name opcode arglist &body body)
  `(progn
     (defun ,name ,arglist
       . ,body)
     (defconstant ,name ,opcode)
     (register-binary-graphics-command ',name ,opcode)))

(defmacro define-binary-graphics-command-for-value (name opcode arglist &body body)
  `(define-binary-graphics-command ,name ,opcode ,arglist
     (values (progn . ,body) t)))

(defmacro define-binary-graphics-command-for-effect (name opcode arglist &body body)
  `(define-binary-graphics-command ,name ,opcode ,arglist
     ,@body
     (values)))

(defparameter *format-version* 1)

(define-binary-graphics-command-for-effect %op-format-version 51 (input-stream)
  (unless (= (read-byte input-stream) *format-version*)
    (error "Data has incorrect format.")))

(define-binary-graphics-command %op-end 50 (&rest ignore)
  (throw 'end nil))

(define-presentation-type point-x () :expander 'number)
(define-presentation-type point-y () :expander 'number)

;;; The presentation type system isn't really geared up for this kind of distributed
;;; definition.
;;; RWK is "on vacation" today (8/14/87) so I changed this to clear
;;; out the cache entry for (D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")TYPE0 BINARY-GRAPHICS).  -- Doughty
(defmacro define-binary-graphics-dumper (type arglist &body body)
  `(progn
     (remhash '(,type binary-graphics) dw::*type-method-cache*)
     ,(dw::def-pres-type-fngenerate type (cons arglist body)
	(dw::presentation-type-arglist type)
	'binary-graphics)))

(define-binary-graphics-command-for-value %op-small-integer 52 (input-stream)
  (+ (read-byte input-stream) -128))

(define-binary-graphics-command-for-value %op-medium-integer 53 (input-stream)
  (+ (+ (read-byte input-stream) (ash (read-byte input-stream) 8)) #o-100000))

(define-binary-graphics-command-for-value %op-large-integer 54 (input-stream)
  (let ((n 0))
    (loop repeat 4 for shift from 0 by 8 do
      (setq n (%logdpb (read-byte input-stream) (byte 8 shift) n)))
    n))

(define-binary-graphics-command-for-value %op-very-large-integer 55 (input-stream)
  (let ((length (+ (read-byte input-stream) (ash (read-byte input-stream) 8)))
	(n 0))
    (loop repeat (ceiling length 8) for shift from 0 by 8 do
      (setq n (dpb (read-byte input-stream) (byte 8 shift) n)))
    n))

(define-binary-graphics-command-for-value %op-very-large-negative-integer 61 (input-stream)
  (let ((length (+ (read-byte input-stream) (ash (read-byte input-stream) 8)))
	(n 0))
    (loop repeat (ceiling length 8) for shift from 0 by 8 do
      (setq n (dpb (read-byte input-stream) (byte 8 shift) n)))
    (- n)))

(define-binary-graphics-command-for-value %op-ratio 56 (input-stream)
  (/ (binary-graphics-next-value input-stream)
     (binary-graphics-next-value input-stream)))

(define-binary-graphics-command-for-value %op-single-float 57 (input-stream)
  (let ((n 0))
    (loop repeat 4 for shift from 0 by 8 do
      (setq n (%logdpb (read-byte input-stream) (byte 8 shift) n)))
    (%flonum n)))

(define-binary-graphics-command-for-value %op-double-float 58 (input-stream)
  (si:%make-double
    (%logdpbs (read-byte input-stream) (byte 8. 0.)
	      (read-byte input-stream) (byte 8. 8.)
	      (read-byte input-stream) (byte 8. 16.)
	      (read-byte input-stream) (byte 8. 24.) 0)
    (%logdpbs (read-byte input-stream) (byte 8. 0.)
	      (read-byte input-stream) (byte 8. 8.)
	      (read-byte input-stream) (byte 8. 16.)
	      (read-byte input-stream) (byte 8. 24.) 0)))

;;; Note that we make no strong attempt to distinguish integers and
;;; floats in the resultant output, since they are assumed to not be
;;; distinguished by the output operations.
(define-binary-graphics-dumper number (number stream)
  (flet ((output-integer (n)
	   (cond (( -128 n 127)
		  (write-byte %op-small-integer stream)
		  (write-byte (- n -128) stream))
		 (( #o-100000 n #o77777)
		  (write-byte %op-medium-integer stream)
		  (write-byte (ldb (byte 8 0) (- n #o-100000)) stream)
		  (write-byte (ldb (byte 8 8) (- n #o-100000)) stream))
		 ((sys:fixnump n)
		  (write-byte %op-large-integer stream)
		  (loop repeat 4 for shift from 0 by 8 do
		    (write-byte (%logldb (byte 8 shift) n) stream)))
		 (t
		  (if (plusp n)
		      (write-byte %op-very-large-integer stream)
		      (write-byte %op-very-large-negative-integer stream)
		      (setq n (- n)))
		  (let ((length (integer-length n)))
		    (write-byte (ldb (byte 8 0) length) stream)
		    (write-byte (ldb (byte 8 8) length) stream)
		    (loop repeat (ceiling length 8) for shift from 0 by 8 do
		      (write-byte (ldb (byte 8 shift) n) stream)))))))
    (etypecase number
      (integer
	(output-integer number))
      (ratio
	(write-byte %op-ratio stream)
	(output-integer (numerator number))
	(output-integer (denominator number)))
      (float
	(block as-int
	  (when ( #o-100000 number #o77777)
	    (multiple-value-bind (integer error)
		(round number)
	      (when ( (abs error) 1e-10)
		(output-integer integer)
		(return-from as-int))))
	  (cond ((single-float-p number)
		 (write-byte %op-single-float stream)
		 (let ((int (%fixnum number)))
		   (loop repeat 4 for shift from 0 by 8 do
		     (write-byte (%logldb (byte 8 shift) int) stream))))
		((double-float-p number)
		 (write-byte %op-double-float stream)
		 (let ((high (double-high number)))
		   (write-byte (%logldb (byte 8 0) high) stream)
		   (write-byte (%logldb (byte 8. 8.) high) stream)
		   (write-byte (%logldb (byte 8. 16.) high) stream)
		   (write-byte (%logldb (byte 8. 24.) high) stream))
		 (let ((low (double-low number)))
		   (write-byte (%logldb (byte 8 0) low) stream)
		   (write-byte (%logldb (byte 8. 8.) low) stream)
		   (write-byte (%logldb (byte 8. 16.) low) stream)
		   (write-byte (%logldb (byte 8. 24.) low) stream)))))))
    number))

(define-binary-graphics-command-for-value %op-point-sequence 59 (input-stream)
  (let* ((length (binary-graphics-next-value input-stream))
	 (sequence (make-array (* length 2))))
    (loop for i below (* length 2)
	  do
      (setf (aref sequence i) (binary-graphics-next-value input-stream)))
    sequence))

(define-presentation-type point-sequence ()
   :expander '((sequence number))
   )

(define-binary-graphics-dumper point-sequence (points stream)
  (write-byte %op-point-sequence stream)
  (let ((length (floor (length points) 2)))
    (write-typed-argument length 'integer stream)
    (map-points #'(lambda (x y ignore)
		    (write-typed-argument x 'point-x stream)
		    (write-typed-argument y 'point-y stream))
		points)))

(define-binary-graphics-command-for-value %op-dash-pattern 72 (input-stream)
  (let* ((length (binary-graphics-next-value input-stream))
	 (pattern (make-array length)))
    (dotimes (i length)
      (setf (aref pattern i) (binary-graphics-next-value input-stream)))
    pattern))

(define-presentation-type dash-pattern ()
   :expander '((sequence ((number (0)))))
   )

(define-binary-graphics-dumper dash-pattern (pattern stream)
  (write-byte %op-dash-pattern stream)
  (let ((length (length pattern)))
    (write-typed-argument length 'integer stream)
    (dotimes (i length)
      (write-typed-argument (elt pattern i) 'number stream))))

;;; We choose a scale that will make common angles be integers
(define-binary-graphics-command-for-value %op-angle 60 (input-stream)
  (/ (* (binary-graphics-next-value input-stream) 2pi) 3600.0))

(define-presentation-type angle ()
   :expander 'number
   )

(define-binary-graphics-dumper angle (angle stream)
  (write-byte %op-angle stream)
  (write-typed-argument (/ (* angle 3600.0) 2pi) 'number stream))

(define-binary-graphics-command-for-value %op-true 62 (ignore) t)
(define-binary-graphics-command-for-value %op-false 63 (ignore) nil)

(define-binary-graphics-dumper boolean (object stream)
  (write-byte (if object %op-true %op-false) stream))

(eval-when (compile load eval)
(defvar *binary-graphics-keywords* (make-array 256))

(defun add-binary-graphics-keywords (&rest keywords)
  (loop for i from 0 for keyword in keywords do
    (setf (aref *binary-graphics-keywords* i) keyword)))

;;; Do not ever change what's in this list, just add to the end.
(add-binary-graphics-keywords 
  :bevel :butt :miter :none :round :square
  :draw :erase :flip
  :baseline :bottom :center :left :right :top
  :anti-cyclic :clamped :cyclic :relaxed
  :non-zero :odd-even
  :alu :attachment-x :attachment-y :character-style :clockwise :closed :copy-image
  :dash-pattern :scale-dashes :dashed :draw-end-point :draw-partial-dashes :end-angle
  :end-relaxation :end-slope-dx :end-slope-dy :filled :gray-level :handedness :image-bottom
  :image-left :image-right :image-top :initial-dash-phase :inner-x-radius :inner-y-radius
  :join-to-path :line-end-shape :line-joint-shape :mask :new-value :number-of-samples :opaque
  :pattern :points-are-convex-p :start-angle :start-relaxation :start-slope-dx :start-slope-dy
  :stretch-p :thickness :toward-x :toward-y :winding-rule
  :scale-thickness :character-size :string-width :scale-down-allowed :mask-x :mask-y
  :color :stipple :tile :shape :record-as-text :scan-conversion-mode
  :round-coordinates :center-circles :host-allowed :sketch :flatness
  :object :type :single-box :allow-sensitive-inferiors)
); End EVAL-WHEN

(define-binary-graphics-command-for-value %op-keyword 64 (input-stream)
  (aref *binary-graphics-keywords* (read-byte input-stream)))

(define-binary-graphics-dumper keyword (keyword stream)
  (write-byte %op-keyword stream)
  (write-byte (or (position keyword *binary-graphics-keywords*)
		  (error "Keyword ~S is not registered." keyword))
	      stream))

(define-binary-graphics-dumper member (object stream)
  (etypecase object
    (keyword (write-typed-argument object 'keyword stream))))

(define-binary-graphics-dumper null-or-type (object stream)
  (if (null object)
      (write-byte %op-false stream)
      (write-typed-argument object dw:presentation-type stream)))

(define-binary-graphics-dumper token-or-type (object stream)
  (typecase object
    (keyword (write-typed-argument object 'keyword stream))
    (boolean (write-typed-argument object 'boolean stream))
    (otherwise (write-typed-argument object dw::otherwise-type stream))))

(define-binary-graphics-command-for-value %op-thin-string 20 (input-stream)
  (let* ((length (read-byte input-stream))
	 (string (make-array length :element-type 'string-char)))
    (dotimes (i length)
      (setf (aref string i) (code-char (read-byte input-stream))))
    string))

(define-binary-graphics-command-for-value %op-fat-string 21 (input-stream)
  (let* ((length (binary-graphics-next-value input-stream))
	 (string (make-array length :element-type 'character)))
    (using-resource (translating-stream si:epsilon-decoding-input-stream input-stream)
      (dotimes (i length)
	(setf (aref string i) (read-char translating-stream))))
    string))

(define-binary-graphics-dumper string (string stream)
  (cond ((or (and (string-fat-p string)
		  (some #'char-fat-p string))
	     ( (string-length string) #o400))
	 (write-byte %op-fat-string stream)
	 (write-typed-argument (string-length string) 'integer stream)
	 (using-resource (translating-stream si:epsilon-encoding-output-stream stream)
	   (write-string string translating-stream)
	   (send translating-stream :force-output)))
	(t
	 (write-byte %op-thin-string stream)
	 (write-byte (string-length string) stream)
	 (loop for char being the array-elements of string do
	   (write-byte (char-code char) stream)))))

(define-binary-graphics-command-for-value %op-path-function 22 (input-stream)
  `#'(lambda (*standard-output*) . ,(binary-decode-graphics-into-forms input-stream)))

(define-presentation-type output-function ()
   :expander 'function)

(define-binary-graphics-dumper output-function (function stream &key encoding-stream)
  (write-byte %op-path-function stream)
  (funcall function encoding-stream)
  (write-byte %op-end stream))

(define-binary-graphics-command-for-value %op-raster-image 23 (input-stream)
  (let* ((byte-size (read-byte input-stream))
	 (width (binary-graphics-next-value input-stream))
	 (height (binary-graphics-next-value input-stream))
	 (raster (make-raster-array width height :element-type `(unsigned-byte ,byte-size)))
	 (byte-length (multiple-value-bind (byte-width leftover)
			  (ceiling (* width byte-size) 8)
			(assert (zerop leftover))
			(* byte-width height))))
    (with-stack-array (byte-array byte-length :element-type '(unsigned-byte 8)
					      :displaced-to raster)
      (send input-stream :string-in "Unexpected EOF in the middle of an image"
				    byte-array 0 byte-length))
    raster))

(define-presentation-type bitmap ()
   :expander 'array)

(define-binary-graphics-dumper bitmap (raster stream)
  (write-byte %op-raster-image stream)
  (multiple-value-bind (width height)
      (decode-raster-array raster)
    (let* ((byte-size (array-element-size raster))
	   (byte-length (multiple-value-bind (byte-width leftover)
			    (ceiling (* width byte-size) 8)
			  (assert (zerop leftover))
			  (* byte-width height))))
      (write-byte byte-size stream)
      (write-typed-argument width 'integer stream)
      (write-typed-argument height 'integer stream)
      (with-stack-array (byte-array byte-length :element-type '(unsigned-byte 8)
				    :displaced-to raster)
	(send stream :string-out byte-array 0 byte-length)))))

(define-binary-graphics-command-for-value %op-color 73 (input-stream)
  (let* ((r (binary-graphics-next-value input-stream))
	 (g (binary-graphics-next-value input-stream))
	 (b (binary-graphics-next-value input-stream)))
    (color:make-color :rgb (list r g b))))

(define-binary-graphics-dumper color:color (color stream)
  (multiple-value-bind (r g b)
      (color:color-rgb color)
    (write-byte %op-color stream)
    (write-typed-argument r 'number stream)
    (write-typed-argument g 'number stream)
    (write-typed-argument b 'number stream)))

(defmacro define-type-encoded-as-string (name opcode presentation-type)
  `(progn
     (define-binary-graphics-command-for-value ,name ,opcode (input-stream)
       (let ((length (read-byte input-stream)))
	 (with-stack-array (string length :element-type 'string-char)
	   (dotimes (i length)
	     (setf (aref string i) (code-char (read-byte input-stream))))
	   (accept-from-string ',presentation-type string))))
     (define-binary-graphics-dumper ,presentation-type (object stream)
       (let ((string (present-to-string object ',presentation-type)))
	 (assert (and (< (string-length string) #o400)
		      (not (some #'char-fat-p string))))
	 (write-byte ,opcode stream)
	 (write-byte (string-length string) stream)
	 (loop for char being the array-elements of string do
	   (write-byte (char-code char) stream))))))

(define-type-encoded-as-string %op-character-style 24 character-style)

(defparameter *drawing-state-argument-keyword-types*
  (loop for keyword in *drawing-state-argument-keywords*
	collect (let ((elem (assoc keyword (standard-additional-arguments :lines)
				   :test #'string=)))
		  (if elem
		      (list keyword (third elem))
		      (or (assoc keyword '((:alu ((member :draw :erase :flip)))
					   (:pattern ((token-or-type (t) bitmap)))
					   (:stipple bitmap) (:tile bitmap)
					   (:color color:color)
					   (:gray-level ((number 0 1)))
					   (:opaque boolean)))
			  (error "Don't know type for ~S." keyword))))))

(defmacro binary-encode-graphics-operation
	  (name opcode
	   &key rest-arg-name pos-args key-args argument-types new-path-position
		continuations (continuation-xstream 'self) (drawing-arguments t) (line-p t))
  (ignore name)
  `(progn
     (force-out-transform-matrix)
     (write-byte ,opcode stream)
     ,@(loop for continuation in continuations
	     append `((funcall ,continuation ,continuation-xstream)
		      (write-byte %op-end stream)))
     ,@(loop for name in pos-args
	     as type = (second (assoc name argument-types))
	     when (null type)
	       do (warn () "No type for ~S argument.  It will not be properly output." name)
	     collect `(write-typed-argument ,name ',type stream))
     ,(when rest-arg-name
	`(write-keyword-arguments ,rest-arg-name
				  ',(loop for var in (set-difference key-args
								     lambda-list-keywords)
					  when (consp var)
					    do (setq var (first var))
					  as keyword = (intern (symbol-name var)
							       si:pkg-keyword-package)
					  unless (position keyword *binary-graphics-keywords*)
					    do (warn () 
 "~S is not a registered keyword (in ~S).
It will not be properly output." keyword '*binary-graphics-keywords*)
					  as type = (second (assoc var argument-types))
					  when (null type)
					    do (warn () "No type for ~S argument.  ~
It will not be properly output." var)
					  collect (list keyword type))
				  stream))
     ,(when drawing-arguments
	`(write-keyword-arguments (binary-drawing-state-get-drawing-arguments drawing-state
									      ,line-p)
				  *drawing-state-argument-keyword-types* stream))
     (write-byte %op-end stream)
     ,(when new-path-position
	`(multiple-value-bind (x y)
	     ,new-path-position
	   (binary-drawing-state-set-position drawing-state x y)))))

(push '(:binary-graphics presentation-type-binary-graphics)
      dw::*presentation-type-methods-to-preserve*)

(dw::defmethod-type-descriptor (presentation-type-binary-graphics
				 dw:presentation-type-descriptor :search-p nil)
			       ()
  (dw::handler-or binary-graphics))

(defun write-typed-argument (object presentation-type stream)
  (dw::with-type-method ((real-presentation-type function)
			 presentation-type #'presentation-type-binary-graphics)
    (funcall function object stream real-presentation-type presentation-type
	     *encoding-stream*)))

(defun write-keyword-arguments (args types stream)
  (loop for (keyword value) on args by 'cddr do
    (let ((type (second (assoc keyword types))))
      ;; We presume that if we see something we don't know, that means :allow-other-keys
      ;; or else there would be an error.  So, just ignore it.
      (when type
	(write-typed-argument keyword 'keyword stream)
	(write-typed-argument value type stream)))))

(defmethod (binary-drawing-state-get-drawing-arguments binary-drawing-state)
	   (&optional (line-p t))
  (when (not (zerop (ldb %%drawing-state-parameters-unwritten flags)))
    (setq drawing-argument-list nil)

    (macrolet ((unless-default-do (variable default)
		 `(unless (equalp ,variable ,default)
		    (setf (getf drawing-argument-list ,(intern (symbol-name variable) ""))
			  ,variable)))
	       (do-defaults (&rest vars-and-defaults)
		 `(progn . ,(loop for (variable default) on vars-and-defaults by 'cddr
				  collect `(unless-default-do ,variable ,default)))))
      ;; Defaults in synch with flavor drawing-state's initializations.
      (when line-p
	(do-defaults thickness nil
		     scale-thickness t
		     line-end-shape :butt
		     line-joint-shape :miter
		     dashed nil
		     dash-pattern #(10 10)
		     initial-dash-phase 0
		     draw-partial-dashes t
		     scale-dashes nil))
      (do-defaults alu :draw
		   pattern t
		   stipple nil
		   tile nil
		   gray-level 1
		   color nil
		   opaque t))

    (setf (ldb %%drawing-state-parameters-unwritten flags) 0))
  drawing-argument-list)

;;; Arrange for set-stream-transform to be usable within the body.
;;; Save a copy of the current transform, to which we will compose the static transforms
;;; determined at encoding time.
;;; Also, save the stream's transform against our destructive modification.  This means that
;;; functions cannot be encoded which rely on destruction of it, which isn't any good anyhow.
(defmacro with-saved-transform (&body body)
  `(saving-graphics-transform ()
     (stack-let ((saved-stream-transform (make-graphics-transform)))
       (replace saved-stream-transform (stream-transform *standard-output*))
       . ,body)))

;;; Shares lexical variable from above.
(defmacro set-stream-transform (matrix)
  `(set-stream-transform-internal saved-stream-transform ,matrix))

(defun set-stream-transform-internal (starting-matrix new-matrix)
  (replace (stream-transform *standard-output*) starting-matrix)
  (stream-compose-transforms *standard-output* new-matrix))

(define-binary-graphics-command %op-transform-matrix 68 (input-stream)
  (let ((matrix (make-graphics-transform)))
    (loop for i below 6 do
      (setf (elt matrix i) (binary-graphics-next-value input-stream)))
    (values `(set-stream-transform ',matrix) :form)))

(defun-in-flavor (force-out-transform-matrix binary-graphics-stream) ()
  (let ((transform-now (stream-transform self))
	(last-transform (binary-drawing-state-last-transform drawing-state)))
    (unless (equal transform-now last-transform)
      (write-byte %op-transform-matrix stream)
      (map () #'(lambda (element) (write-typed-argument element 'number stream))
	   transform-now)
      (replace last-transform transform-now))))

(defmethod (binary-drawing-state-position binary-drawing-state) ()
  (values position-x position-y))

(defmethod (binary-drawing-state-set-position binary-drawing-state) (new-x new-y)
  (setq position-x new-x position-y new-y))

(defmethod (current-position binary-graphics-stream) ()
  (multiple-value-bind (x y)
      (binary-drawing-state-position drawing-state)
    (stream-untransform-point x y self)))

(define-binary-graphics-command %op-set-position 67 (input-stream)
  (values (list 'set-current-position
		(binary-graphics-next-value input-stream)
		(binary-graphics-next-value input-stream))
	  :form))

(defmethod (set-current-position binary-graphics-stream) (new-x new-y &key explicit)
  (ignore explicit)
  (write-byte %op-set-position stream)
  (write-typed-argument new-x 'point-x stream)
  (write-typed-argument new-y 'point-y stream)
  (multiple-value-setq (new-x new-y)
    (stream-transform-point new-x new-y self))
  (binary-drawing-state-set-position drawing-state new-x new-y))

(define-binary-graphics-command %op-subroutine-call 66 (input-stream)
  (values (list (first (aref *defined-subroutines* (read-byte input-stream))))
	  :form))

(define-binary-graphics-command %op-subroutine-definition 65 (input-stream)
  (let ((name (gensym)))
    (setf (aref *defined-subroutines* (read-byte input-stream))
	  (cons name (binary-decode-graphics-into-forms input-stream)))
    (values (list name) :form)))

(defmethod (with-graphics-subroutine-internal binary-graphics-stream)
	   (continuation xstream &rest args)
  (force-out-transform-matrix)
  (with-stack-list (key (function-name continuation) args)
    (let ((index (gethash key subroutine-hash-table)))
      (when index
	(write-byte %op-subroutine-call stream)
	(write-byte index stream)
	(return-from with-graphics-subroutine-internal nil)))
    (when ( subroutine-number #o400)
      (return-from with-graphics-subroutine-internal
	(apply continuation xstream args)))
    (setq key (copy-if-necessary key))
    (setf (gethash key subroutine-hash-table) subroutine-number)
    (write-byte %op-subroutine-definition stream)
    (write-byte subroutine-number stream)
    (incf subroutine-number)
    (with-graphics-identity-transform (xstream)
      (apply continuation xstream args))
    (write-byte %op-end stream)))

(define-binary-graphics-command %op-clip-from-output 69 (input-stream)
  (let ((clipping-forms (binary-decode-graphics-into-forms input-stream))
	(output-forms (binary-decode-graphics-into-forms input-stream)))
    (values `(with-clipping-from-output (t . ,clipping-forms)
	       . ,output-forms)
	    :form)))

(defmethod (with-clipping-from-output-internal binary-graphics-stream)
	   (output-continuation clipping-continuation xstream)
  (binary-encode-graphics-operation clipped-output %op-clip-from-output
				    :continuations (clipping-continuation output-continuation)
				    :continuation-xstream xstream
				    :drawing-arguments nil))

(define-binary-graphics-command %op-clip-from-mask 70 (input-stream)
  (let ((output-forms (binary-decode-graphics-into-forms input-stream))
	(args (decode-binary-graphics-operation 'with-clipping-mask input-stream)))
    (values `(with-clipping-mask (t . ,(rest args))
	       . ,output-forms)
	    :form)))

(defmethod (with-clipping-mask-internal binary-graphics-stream)
	   (continuation xstream mask &rest args)
  (binary-encode-graphics-operation clipped-output-from-mask %op-clip-from-mask
				    :rest-arg-name args
				    :pos-args (mask)
				    :key-args (left top right bottom)
				    :argument-types ((mask bitmap)
						     (left integer) (top integer)
						     (right integer) (bottom integer))
				    :continuations (continuation)
				    :continuation-xstream xstream))

(define-binary-graphics-command %op-clip-from-path 71 (input-stream)
  (let ((path-forms (binary-decode-graphics-into-forms input-stream))
	(output-forms (binary-decode-graphics-into-forms input-stream))
	(args (decode-binary-graphics-operation 'with-clipping-path input-stream)))
    (values `(with-clipping-path (t #'(lambda (*standard-output*) . ,path-forms)
				    . ,(rest args))
	       . ,output-forms)
	    :form)))

(defmethod (with-clipping-path-internal binary-graphics-stream)
	   (continuation xstream path-function &rest args)
  (binary-encode-graphics-operation clipped-output-from-path %op-clip-from-path
				    :rest-arg-name args
				    :key-args (winding-rule)
				    :argument-types ((winding-rule
						       ((member :non-zero :odd-even))))
				    :continuations (path-function continuation)
				    :continuation-xstream xstream))

(define-binary-graphics-command %op-scan-conversion-mode 74 (input-stream)
  (let ((output-forms (binary-decode-graphics-into-forms input-stream))
	(args (decode-binary-graphics-operation 'with-scan-conversion-mode input-stream)))
    (values `(with-scan-conversion-mode (t . ,(rest args))
	       . ,output-forms)
	    :form)))

(defmethod (with-scan-conversion-mode-internal binary-graphics-stream)
	   (continuation xstream &rest args)
  (binary-encode-graphics-operation scan-conversion-mode %op-scan-conversion-mode
				    :rest-arg-name args
				    :key-args (round-coordinates center-circles host-allowed
					       sketch flatness)
				    :argument-types ((round-coordinates boolean)
						     (center-circles boolean)
						     (host-allowed boolean)
						     (sketch boolean)
						     (flatness number))
				    :continuations (continuation)
				    :continuation-xstream xstream))

(defvar *binary-encodable-ptypes* nil) 

(defmacro define-binary-encoding-for-ptype
	  ((type-name &optional pretty-name)
	   &key
	   (encode-object '((object type) (present-to-string object type :acceptably t)))
	   (decode-object '((string type) (accept-from-string type string)))
	   (decode-object-printably
	     '((string type)
	       (let* ((type-name (dw:presentation-type-name type))
		      (printable-type
			(funcall (get type-name 'binary-graphics-decode-type-printably)
				 (funcall (get type-name 'binary-graphics-encode-type) type))))
		 `(accept-from-string ',printable-type ,string))))
	   (encode-type '((type) (format nil "(~S)" type)))
	   (decode-type '((string) (read-from-string string)))
	   (decode-type-printably '((string) (read-from-string string)))
	   &body clauses)
  (declare (ignore clauses))
  (let ((forms nil))
    (flet ((write-function (name spec)
	     (push `(defun (,type-name ,(intern (string-append "BINARY-GRAPHICS-" name)
						(find-package "graphics")))
			   ,@spec)
		   forms)))
      (write-function 'encode-object encode-object)
      (write-function 'decode-object decode-object)
      (write-function 'decode-object-printably decode-object-printably)
      (write-function 'encode-type encode-type)
      (write-function 'decode-type decode-type)
      (write-function 'decode-type-printably decode-type-printably))
    `(sys:multiple-definition ,type-name define-binary-encoding-for-ptype
       (pushnew '(,(or pretty-name (string-capitalize type-name)) ,type-name)
		*binary-encodable-ptypes*
		:test #'equal
		:replace t)
       ,@forms)))

(defun (:property define-binary-encoding-for-ptype zwei:definition-function-spec-finder) (bp)
  (and (setq bp (zwei:forward-over zwei:*whitespace-chars* bp))
       (if (char-equal (zwei:bp-char bp) #\open-parenthesis)
	   (zwei:forward-list bp 1 nil -1 t)
	   bp)))

(defun encode-presentation-object (object ptype)
  (declare (values encoded-object encoded-type))
  (with-standard-io-environment
    (let ((type-name (dw:presentation-type-name ptype)))
      (values
	(funcall (get type-name 'binary-graphics-encode-object) object ptype)
	(funcall (get type-name 'binary-graphics-encode-type) ptype)))))

(defun decode-presentation-object (encoded-object encoded-type)
  (declare (values (object ptype)))
  (with-standard-io-environment
    (destructuring-bind (type-name &rest arguments)
	(read-from-string encoded-type)
      (declare (ignore arguments))
      (let ((type (funcall (get type-name 'binary-graphics-decode-type) encoded-type)))
	(values
	  (funcall (get type-name 'binary-graphics-decode-object) encoded-object type)
	  type)))))

(defun make-presentation-object-printable (object ptype)
  (declare (values (object-generating-form type-generating-form)))
  (with-standard-io-environment
    (let* ((type-name (dw:presentation-type-name ptype)))
      (values
	(funcall (get type-name 'binary-graphics-decode-object-printably)
		 (funcall (get type-name 'binary-graphics-encode-object)
			  object ptype)
		 ptype)
	(funcall (get type-name 'binary-graphics-decode-type-printably)
		 (funcall (get type-name 'binary-graphics-encode-type)
			  ptype))))))

(define-binary-encoding-for-ptype (cp:command)
  :encode-type ((type)
		(if (symbolp type)
		    (format nil "(~S)" type)
		    (destructuring-bind ((name &key command-table)) type
		      (format nil "(~S ~S)" name
			      (etypecase command-table
				(cp:command-table (cp:command-table-name command-table))
				(string command-table))))))
  :decode-type ((string)
		(destructuring-bind (name &optional command-table-name)
		    (read-from-string string)
		  (let ((command-table (cp:find-command-table command-table-name
							      :if-does-not-exist nil)))
		    (if command-table
			`((,name :command-table ,command-table))
			name))))
  :decode-type-printably ((string)
			  (destructuring-bind (name &optional command-table-name)
			      (read-from-string string)
			    (if command-table-name
				`((,name :command-table ,command-table-name))
				name))))

(define-binary-encoding-for-ptype (fs:pathname))

(define-binary-encoding-for-ptype (sys:form "Lisp Form"))

(define-binary-graphics-command %op-output-as-graphics-presentation 75 (input-stream)
  (let ((output-forms (binary-decode-graphics-into-forms input-stream))
	(args (rest (decode-binary-graphics-operation 'with-output-as-graphics-presentation
						      input-stream))))
    (multiple-value-bind (object ptype)
	(decode-presentation-object (getf args :object) (getf args :type))
      (setf (getf args :object) `',object
	    (getf args :type) `',ptype))
    (values `(with-output-as-graphics-presentation (t . ,args)
	       . ,output-forms)
	    :form)))

(defmethod (:output-as-presentation-1 binary-graphics-stream)
	   (continuation continuation-args &rest args)
  (multiple-value-bind (encoded-object encoded-type)
      (encode-presentation-object (getf args :object) (getf args :type))
    (setf (getf args :object) encoded-object
	  (getf args :type) encoded-type))
  (binary-encode-graphics-operation output-as-graphics-presentation
				    %op-output-as-graphics-presentation
				    :rest-arg-name args
				    :key-args (object type single-box
						      allow-sensitive-inferiors)
				    :argument-types ((object string)
						     (type string)
						     (single-box boolean)
						     (allow-sensitive-inferiors boolean))
				    :continuations (#'(lambda (stream)
							(apply continuation stream
							       (cdr continuation-args))))
				    :drawing-arguments nil))

(defmethod (:initialize binary-graphics-stream) (new-stream)
  (setq stream new-stream)
  (binary-drawing-state-initialize drawing-state)
  (clrhash subroutine-hash-table)
  (setq subroutine-number 0)
  )

(defmethod (binary-drawing-state-initialize binary-drawing-state) ()
  (drawing-state-initialize self *identity-transform*)
  (fill last-transform nil)
  (setq drawing-argument-list nil)
  )

(defvar *encoding-stream*)

(defun binary-encode-graphics (function stream)
  (using-resource (encoding-stream binary-graphics-stream)
    (send encoding-stream :initialize stream)
    (write-byte %op-format-version stream)
    (write-byte *format-version* stream)
    (let ((*encoding-stream* encoding-stream))
      (funcall function encoding-stream))))

(defun binary-encode-graphics-to-array (function)
  (using-resource (output-stream si:8bit-array-output-stream)
    (with-open-stream (output-stream output-stream)
      (binary-encode-graphics function output-stream))
    (copy-seq (send output-stream :array))))

(defun write-encoded-graphics-as-characters (array stream)
  (loop for byte being the array-elements of array do
    (cond ((< byte 90)
	   (write-char (code-char (+ byte #o41)) stream))
	  ((< byte 180)
	   (write-char (code-char #o176) stream)
	   (write-char (code-char (+ (- byte 90) #o41)) stream))
	  (t
	   (write-char (code-char #o175) stream)
	   (write-char (code-char (+ (- byte 180) #o41)) stream)))))

(defun read-encoded-graphics-as-characters (stream)
  (with-stack-array (array 1000 :element-type '(unsigned-byte 8) :fill-pointer 0)
    (let ((alength 1000)
	  (aindex 0)
	  (line "")
	  (line1 nil)
	  (lindex 0)
	  (llength 0))
      (declare (array-register array line))
      (block done
	(flet ((refill ()
		 (when line1
		   (send stream :advance-input-buffer))
		 (multiple-value-setq (line1 lindex llength)
		   (send stream :read-input-buffer))
		 (when (null line1)
		   (return-from done))
		 (let ((aend (+ aindex (- llength lindex))))
		   (when (> aend alength)
		     (setq alength aend)
		     (setq array (sys:adjust-array-size array alength))))
		 line1))
	  (macrolet ((next-char ()
			 `(progn
			    (loop until (< lindex llength)
				  do (setq line (refill)))
			    (prog1 (aref line lindex) (incf lindex))))
		       (next-byte (byte)
			 `(progn
			    (setf (aref array aindex) ,byte)
			    (incf aindex))))
	    (loop
	      (let ((code (char-code (next-char))))
		(if ( #o41 code #o174)
		    (next-byte (- code #o41))
		    (case code
		      (#o176
		       (next-byte (+ (- (char-code (next-char)) #o41) 90)))
		      (#o175
		       (next-byte (+ (- (char-code (next-char)) #o41) 180)))
		      (#.(char-subindex #\)
		       (error "An  was seen in the input stream.
Probably it has accidentally been style encoded."))
		      (#.(char-subindex #\space)
		       )
		      (otherwise
			(error "The garbage character ~C was seen in the input stream."
			       (code-char code))))))))))
      (setf (fill-pointer array) aindex))
    (copy-seq array)))

(defun binary-decode-graphics-into-forms (input-stream)
  (let ((forms nil))
    (catch 'end
      (loop
	(let ((byte (read-byte input-stream nil nil)))
	  (when (null byte)
	    (return nil))
	  (let ((command (aref *binary-graphics-command-opcodes* byte)))
	    (if command
		(multiple-value-bind (value value-type)
		    (funcall command input-stream)
		  (ecase value-type
		    ((nil) )
		    ((t) (error "A for-value command was seen at top-level."))
		    ((:form) (push value forms))))
		(let ((operation (aref *binary-graphics-operation-opcodes* byte)))
		  (if operation
		      (push (decode-binary-graphics-operation operation input-stream) forms)
		      (error "The garbage byte ~D was seen in the input." byte))))))))
    (nreverse forms)))

(defvar *defined-subroutines*)

(defun binary-decode-graphics-into-function (input-stream &key compile)
  (with-stack-array (*defined-subroutines* 256)
    (let* ((forms (binary-decode-graphics-into-forms input-stream))
	   (body (if compile (split-into-compilable-pieces forms) forms))
	   (subroutines (loop for subr being the array-elements of *defined-subroutines*
			      when subr
				collect (destructuring-bind (name . body) subr
					  `(,name () (with-saved-transform . ,body)))))
	   (function `(lambda (*standard-output*)
			(labels ,subroutines
			  (with-saved-transform . ,body)))))
      (if compile
	  (compile nil function)
	  function))))

(defun binary-decode-graphics-from-array-into-function (array &rest args)
  (declare (arglist array &key compile))
  (using-resource (input-stream si:binary-array-input-stream)
    (send input-stream :reset array)
    (with-open-stream (input-stream input-stream)
      (apply #'binary-decode-graphics-into-function input-stream args))))

(defun decode-binary-graphics-operation (operation input-stream)
  (with-stack-array (arguments 10 :fill-pointer 0)
    (catch 'end
      (loop
	(let ((argument (binary-graphics-next-value input-stream)))
	  (unless (or (and (atom argument) (constantp argument))
		      (and (listp argument) (eq (first argument) 'function)))
	    (setq argument `',argument))
	  (vector-push-extend argument arguments))))
    (cons operation (coerce arguments 'list))))

(defun binary-graphics-next-value (input-stream)
  (loop
    (let ((byte (read-byte input-stream)))
      (let ((command (aref *binary-graphics-command-opcodes* byte)))
	(if command
	    (multiple-value-bind (value value-p)
		(funcall command input-stream)
	      (when value-p
		(return value)))
	    (error "The garbage byte ~D was seen in the input." byte))))))

(defun split-into-compilable-pieces (forms &optional (max-n-consts 200))
  (declare (values new-forms changed-p))
  (labels ((how-many-constants (form)
	     (cond ((consp form)
		    (loop for subform in (if (eql (car form) 'flet) (cddr form) (cdr form))
			  sum (how-many-constants subform)))
		   ((numberp form)
		    (if (or (not (integerp form)) ( -256 form 255)) 1 0))
		   (T 0)))
	   (split-body-of-form (form max-n-consts)
	     (let ((bi (position '&body (arglist (car form)))))
	       (if bi
		   (multiple-value-bind (new-body changed-p)
		       (split-into-compilable-pieces (subseq form (1+ bi)) max-n-consts)
		     (if changed-p
			 (values `(,.(subseq form 0 (1+ bi)) ,.new-body) T)
			 (values form nil)))
		   (values form nil)))))
    (let ((subseqs nil) (changed-p nil))
      (loop with subseq with consts = 0 with local-changed-p
	    for form in forms
	    for nc = (how-many-constants form)
	    finally (push (nreverse subseq) subseqs) do
	(when (> nc max-n-consts)
	  ;; single form has too many constants - descend into it
	  (multiple-value-setq (form local-changed-p) (split-body-of-form form max-n-consts))
	  (when local-changed-p
	    (setq changed-p t nc (how-many-constants form))))
	(when (> (+ nc consts) max-n-consts)
	  ;; next form would cross threshold - save as a group to be turned into a subr
	  (push (nreverse subseq) subseqs)
	  (setq consts 0 subseq nil))
	(push form subseq)
	(incf consts nc))
      (if (= (length subseqs) 1)
	  (values (first subseqs) changed-p)
	  (values `(,(loop for i from 0
			   for subr = (fintern "SUBR-~D" i)
			   for subseq in (nreverse subseqs)
			   if (> (length subseq) 1)
			     collect `(,subr () . ,subseq) into definitions
			     and collect `(,subr) into calls
			   else collect (first subseq) into calls
			   finally (return `(flet ,definitions ,.calls))))
		  T)))))


#||
()
;;; test-arg for split-into-compilable-pieces (try it with max-n-consts = 30,40,45,...)
(defvar test-case
 '((GRAPHICS::SET-STREAM-TRANSFORM '(1 0 0 1 0 0))
   (GRAPHICS:WITH-SCAN-CONVERSION-MODE (T :SKETCH NIL :SCALE-DASHES T)
    (GRAPHICS::SET-STREAM-TRANSFORM '(1 0 0 1 -70 -68))
    (GRAPHICS:DRAW-LINE 258.63483 298.69232 258.41385 315 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 311.02722 193.50613 345.0039 210.46902 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 218.1034 147.11319 179.5774 127.878815 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 257.09744 297.91187 257.29153 297.80255 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 249.5706 287.77945 250.72603 287.12997 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 257.29153 297.80255 250.72603 287.12997 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 242.17165 268.21338 244.28882 267.02338 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 250.72603 287.12997 244.28882 267.02338 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 234.86786 241.60843 237.9468 239.87828 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 244.28882 267.02338 237.9468 239.87828 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 227.61499 211.28412 231.65485 209.01343 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 237.9468 239.87828 231.65485 209.01343 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 220.3621 180.92717 225.36372 178.11635 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 231.65485 209.01343 225.36372 178.11635 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 213.0633 153.98524 219.02625 150.63428 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 225.36372 178.11635 219.02625 150.63428 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 205.68213 133.12271 212.60641 129.2312 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 217.94655 147.03487 212.60641 129.2312 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 219.02625 150.63428 217.94655 147.03487 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 212.60641 129.2312 208.3373 120.18146 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 151.92201 141.25452 165.57692 133.58043 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 144.24413 142.26788 158.86038 134.05365 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 165.57692 133.58043 158.86038 134.05365 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 136.62253 139.11682 152.20053 130.36246 :GRAY-LEVEL 0.25)
    (GRAPHICS:DRAW-LINE 158.86038 134.05365 152.20053 130.36246 :GRAY-LEVEL 0.25))))

||#



;;; This is a kludge, but continuation-output-size needs it to know how large to make
;;; things.  Must assume an arbitrary device.
(defmethod (:draw-string-size binary-graphics-stream) (&rest args)
  (using-resource (some-window dw:dynamic-window)
    (lexpr-send some-window :draw-string-size args)))
