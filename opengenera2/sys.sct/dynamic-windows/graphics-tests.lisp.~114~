;;; -*- Mode: LISP; Syntax: Common-lisp; Package: (GRAPHICS-TESTS :use SCL); Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Main entry point: comprehensive-tests &key (hardcopy-p t) (screen-p t) (report-p nil)

;;; This file is in its own package to approximate an application program more closely.

;;;; Sort of like filling-output for graphics
(defflavor graphics-sample
	(continuation
	 (title nil)
	 left top right bottom
	 title-width
	 total-width
	 x)
	()
  (:constructor make-graphics-sample (continuation title))
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (graphics-sample-compute-size graphics-sample) (&rest args
							   &key stream
							   &allow-other-keys)
  (multiple-value-setq (right bottom nil nil left top)
    (dw:continuation-output-size
      #'(lambda (stream)
	  (graphics:with-graphics-transform (stream (list 1 0 0 -1 1000 1000))
	    (si:with-rem-keywords (some-args args '(:stream :hardcopy-p))
	      (apply #'graphics::apply-graphics-generic-internal continuation stream
		     some-args))))
      stream))
  (decf left 1000) (decf right 1000)
  (setq bottom (- 1000 bottom)
	top (- 1000 top))
  (setq title-width (if title (send stream :string-length title) 0)
	total-width (max (- right left) title-width)))

(defmethod (graphics-sample-width graphics-sample) () (- right left))

(defmethod (graphics-sample-height graphics-sample) () (- top bottom))

(compile-flavor-methods graphics-sample)

(defmacro formatting-graphics-sample ((&optional stream &key title) &body body)
  (dw:format-output-macro-default-stream stream)
  `(make-graphics-sample (dw:named-value-snapshot-continuation formatting-graphics-sample
							       (,stream)
			   . ,body)
			 ,title))

(defun format-graphics-samples (samples &rest args
					&key (stream *standard-output*)
					     (hardcopy-p nil)
					&allow-other-keys)
  (dolist (sample samples)
    (apply #'graphics-sample-compute-size sample :stream stream args))
  (let ((width (send stream :inside-size))
	(margin (if hardcopy-p 9 25)))
    (loop while samples do
      (let* ((subset (let ((x margin))
		       (loop for rest on samples as (sample) = rest do
			 (setf (graphics-sample-x sample) x)
			 (let ((new-x (+ x (graphics-sample-total-width sample))))
			   (when (> new-x width)
			     (return rest))
			   (setq x (+ new-x margin))))))
	     (max-height (loop for list = samples then (cdr list) until (eq list subset)
			       as (sample) = list
			       maximize (graphics-sample-height sample))))
	(flet ((draw-em (stream)
		 (let ((center-y (/ max-height 2)))
		   (loop for list = samples then (cdr list) until (eq list subset)
			 as (sample) = list do
		     (graphics:with-graphics-translation
		         (stream
			   (- (+ (graphics-sample-x sample)
				 (/ (graphics-sample-total-width sample) 2))
			      (/ (graphics-sample-width sample) 2)
			      (graphics-sample-left sample))
			   (- (+ center-y (/ (graphics-sample-height sample) 2))
			      (graphics-sample-top sample)))
		       (si:with-rem-keywords (some-args args '(:stream :hardcopy-p))
			 (apply #'graphics::apply-graphics-generic-internal
				(graphics-sample-continuation sample) stream some-args)))))))
	  (graphics:with-room-for-graphics (stream max-height)
	    (draw-em stream)))
	(when (loop for list = samples then (cdr list) until (eq list subset)
		    as (sample) = list thereis (graphics-sample-title sample))
	  (loop for list = samples then (cdr list) until (eq list subset)
		as (sample) = list do
	    (when (graphics-sample-title sample)
	      (send stream :set-cursorpos
			   (- (+ (graphics-sample-x sample)
				 (floor (graphics-sample-total-width sample)
					2))
			      (floor (graphics-sample-title-width sample) 2))
			   nil)
	      (send stream :string-out (graphics-sample-title sample))))
	  (terpri stream))
	(setq samples subset)))))

(defvar *maintain-functions-tested* nil)
(defvar *functions-tested*)
(defvar *keywords-tested*)

(defun bold-lower-prin1 (object &optional (stream *standard-output*))
  (with-character-face (:bold stream)
    (write object :stream stream :case :downcase)))

(defun comprehensive-tests (&key (hardcopy-p t)
				 (screen-p t)
				 (report-p nil))
  (fresh-line)
  (let ((*maintain-functions-tested* t)
	(*functions-tested* nil)
	(*keywords-tested* nil))
    (when hardcopy-p
      (let ((printer (accept 'sys:printer :prompt "Printer for test"
					  :default hardcopy:*default-text-printer*)))
	(with-open-stream (stream (hardcopy:make-hardcopy-stream printer))
	  (with-character-family (:dutch stream :bind-line-height t)
	    (most-output-tests :stream stream :hardcopy-p t)
	    (business-graphics-test :stream stream)))))
    (transform-primitives-test)
    (when screen-p
      (with-character-family (:dutch t :bind-line-height t)
	(most-output-tests )
	(encoded-graphics-test)
	(opaque-test)
	(attachment-test)
	(attachment-test :tilted-p t)
	(erase-test)
	(driver-tests)
	(business-graphics-test)
	(animation-test)
	))
    (when report-p
      (let ((drawing-methods (getf (flavor::flavor-plist
				     (flavor:find-flavor 'graphics:standard-graphics-mixin))
				   :required-methods))
	    (methods-not-tested nil)
	    (other-functions-not-tested nil))
	(do-external-symbols (sym "GRAPHICS")
	  (when (fdefinedp sym)
	    (unless (member sym *functions-tested*)
	      (if (member sym drawing-methods)
		  (push sym methods-not-tested)
		  (push sym other-functions-not-tested)))))
	(setq methods-not-tested (sort methods-not-tested #'string-lessp))
	(format t "~2&Drawing methods not tested: ")
	(format-textual-list methods-not-tested #'bold-lower-prin1 :filled t)
	(setq other-functions-not-tested (sort other-functions-not-tested #'string-lessp))
	(format t "~&Other functions not tested: ")
	(format-textual-list other-functions-not-tested #'bold-lower-prin1 :filled t))
      (format t "~&Registered keywords not tested: ")
      (format-textual-list (sort (set-difference
				   (delete 'nil
					   (coerce graphics::*binary-graphics-keywords* 'list))
				   *keywords-tested*)
				 #'string-lessp)
			   #'bold-lower-prin1 :filled t))))

(defun testing-function (function &rest arguments)
  (when *maintain-functions-tested*
    (check-type function symbol)
    (pushnew function *functions-tested*)
    (dolist (arg arguments)
      (when (keywordp arg)
	(pushnew arg *keywords-tested*)))))

(defun testing-funcall (function &rest arguments)
  (apply #'testing-function function arguments)
  (apply function arguments))

(defun transform-primitives-test ()
  (labels ((nearly-equal (x y)
	     (etypecase x
	       (number (< (abs (- x y)) 1e-6))
	       (sequence (loop for i below (length x)
			       always (nearly-equal (elt x i) (elt y i)))))))
    (let ((transform (testing-funcall 'graphics:build-graphics-transform
				      :rotation (/ pi 3) :scale 4 :scale-x 2
				      :translation '(100 200))))
      (assert (nearly-equal transform
			    (graphics:with-graphics-identity-transform ()
			      (graphics::apply-graphics-generic-internal
				#'graphics:stream-transform
				*standard-output*
				:rotation (/ pi 3) :scale 4
				:scale-x 2
				:translation '(100 200)))))
      (multiple-value-bind (rot sx sy tx ty)
	  (testing-funcall 'graphics:decompose-transform transform)
	(assert (and (nearly-equal rot (/ pi 3))
		     (nearly-equal sx 8)
		     (nearly-equal sy 4)
		     (nearly-equal tx 100)
		     (nearly-equal ty 200))))
      (let ((inv (testing-funcall 'graphics:invert-transform transform)))
	(assert (nearly-equal (testing-funcall 'graphics:invert-transform inv) transform))
	(assert (nearly-equal (testing-funcall 'graphics:compose-transforms (copy-seq inv)
					       transform)
			      graphics:*identity-transform*))
	(loop for (x y) in '((0 0) (1 0) (0 1) (1 1) (2 5) (3.5 7.25))
	      do (multiple-value-bind (x1 y1)
		     (testing-funcall 'graphics:transform-distance x y transform)
		   (multiple-value-bind (x1p y1p)
		       (testing-funcall 'graphics:transform-distance x1 y1 inv)
		     (assert (and (nearly-equal x1p x)
				  (nearly-equal y1p y))))
		   (multiple-value-bind (x1p y1p)
		       (testing-funcall 'graphics:untransform-distance x1 y1 transform)
		     (assert (and (nearly-equal x1p x)
				  (nearly-equal y1p y)))))
		 (multiple-value-bind (x1 y1)
		     (testing-funcall 'graphics:transform-point x y transform)
		   (multiple-value-bind (x1p y1p)
		       (testing-funcall 'graphics:transform-point x1 y1 inv)
		     (assert (and (nearly-equal x1p x)
				  (nearly-equal y1p y))))
		   (multiple-value-bind (x1p y1p)
		       (testing-funcall 'graphics:untransform-point x1 y1 transform)
		     (assert (and (nearly-equal x1p x)
				  (nearly-equal y1p y))))))))
    (dotimes (r 32)
      (dolist (scale-x '(1/2 -1 1 2 4))
	(dolist (scale-y '(1/3 -1 1 2 4))
	  (let* ((transform (graphics:building-graphics-transform ()
			      (graphics:graphics-translate 100 200)
			      (graphics:graphics-scale scale-x scale-y)
			      (graphics:graphics-rotate (* pi (/ r 16)))))
		 ;; Need a way to return skew.
		 (recomposed (multiple-value-bind (rotation scale-x scale-y
						   translate-x translate-y
						   shear-x)
				 (graphics:decompose-transform transform)
			       (if (nearly-equal shear-x 1)
				   (graphics:build-graphics-transform :rotation rotation
								      :scale-x scale-x
								      :scale-y scale-y
								      :translation
								      (list translate-x
									    translate-y))
				   (graphics:building-graphics-transform ()
				     (graphics:graphics-translate translate-x translate-y)
				     (graphics:graphics-scale shear-x 1)
				     (graphics:graphics-rotate rotation)
				     (graphics:graphics-scale scale-x scale-y))))))
	    (assert (nearly-equal transform recomposed))))))
    ))

(defun most-output-tests (&rest args)
  (apply #'shapes-test args)
  (apply #'all-pattern-tests args)
  (apply #'dashed-test args)
  (apply #'line-joint-test args)
  (apply #'line-end-test args)
  (apply #'scale-thickness-test args)
  (apply #'arrow-test args)
  (apply #'conic-test args)
  (apply #'transformed-ellipse-test args)
  (apply #'coordinate-mode-test args)
  (apply #'path-test args)
  (apply #'clipping-test args)
  (apply #'string-test args)
  (apply #'image-test args)
  (apply #'physical-scale-test args)
  )

(defparameter *basic-shapes* 
  '(("Square" graphics:draw-rectangle 0 0 2 2)
    ("Circle" graphics:draw-circle 0 0 1)
    ("Triangle" graphics:draw-triangle -1 -1 0 1 1 -1)))

(defun compute-other-shapes ()
  `(("Closed spline" graphics:draw-cubic-spline (-1.5 0 0 1 1.5 0 1 -1 -1 -1 -1.5 0)
						:start-relaxation :cyclic)
    ("Open spline" graphics:draw-lines
		   ,(graphics:compute-cubic-spline-points '(-2 -1 0 0 1.5 1)))
    ("Anti-cyclic spline" graphics:draw-cubic-spline (0 0 -1 1 -1 -1 0 -1 1 -1 1 1 0 0)
						     :start-relaxation :anti-cyclic)
    ("Glyph" graphics:draw-glyph ,(char-code #\Z) ,fonts:43vxms 0 0)
    ("Regular polygon" graphics:draw-regular-polygon 0 -1 1 -1 7 :handedness :left)
    ("Nonconvex polygon" graphics:draw-polygon (0 0 1 2 2 1 3 2 4 1 5 2 6 0))
    ("Complex polygon" graphics:draw-polygon (0 0 -1 1 -1 -1 1 1 1 -1 2 0))
    ("Oval" graphics:draw-oval 0 0 2 1)))

(defun format-graphics-samples-with-scale (samples &rest args
						   &key (scale 1)
							hardcopy-p
						   &allow-other-keys)
  (with-stack-list* (args :scale (* scale (if hardcopy-p 9 25)) args)
    (apply #'format-graphics-samples samples args)))

(defun shapes-test (&rest args
		    &key (stream *standard-output*)
		    &allow-other-keys)
  (setq args (append args '(:scale-thickness nil)))
  (let ((samples (loop for draw-args in '(nil
					  (:filled nil :thickness 0)
					  (:filled nil :thickness 1)
					  (:filled nil :thickness 2))
		       nconc
		   (loop for (title function . args) in *basic-shapes*
			 collect (formatting-graphics-sample (stream :title title)
				   (apply #'testing-funcall function
					  `(,@args :stream ,stream . ,draw-args)))))))
    (header-line "Basic shapes" stream)
    (apply #'format-graphics-samples-with-scale samples args)
    (header-line "More shapes" stream)
    (apply #'format-graphics-samples-with-scale
	   (loop for (title function . args) in (compute-other-shapes)
			 collect (formatting-graphics-sample (stream :title title)
				   (apply #'testing-funcall function
					  `(,@args :stream ,stream))))
	   args)
    (header-line "Scaling" stream)
    (apply #'format-graphics-samples-with-scale samples :scale 1/2 args)
    (apply #'format-graphics-samples-with-scale samples :scale 2 args)
    (apply #'format-graphics-samples-with-scale samples :scale-x 2 args)
    (header-line "Rotating" stream)
    (apply #'format-graphics-samples-with-scale samples :rotation (/ pi 2) args)
    (apply #'format-graphics-samples-with-scale samples :rotation (/ pi 3) args)
    (apply #'format-graphics-samples-with-scale samples :scale-y 2 :rotation (* pi 5/6)
	   args)
    ))

(defparameter *elliptical-arcs*
  `((1 1 0 ,graphics:2pi)
    (1 1 ,(/ pi 3) ,(/ pi 2))
    (1 2 0 ,graphics:2pi)
    (2 1 ,(/ pi 2) ,pi)
    (1 1 ,(* pi 3/2) ,pi)))

(defun conic-test (&rest args
		   &key (stream *standard-output*)
		   &allow-other-keys)
  (header-line "Circles, ellipses arcs, etc." stream)
  (let ((samples (loop for draw-args in '(nil
					  (:filled nil :thickness 0)
					  (:filled nil :thickness 1 :scale-thickness nil)
					  (:filled nil :thickness 2 :scale-thickness nil))
		       nconc
		   (loop for (x y theta-1 theta-2) in *elliptical-arcs*
			 collect (formatting-graphics-sample ()
				   (apply #'testing-funcall 'graphics:draw-ellipse
					  `(0 0 ,x ,y
					    :start-angle ,theta-1 :end-angle ,theta-2
					    . ,draw-args)))))))
    (apply #'format-graphics-samples-with-scale samples args)
    (apply #'format-graphics-samples-with-scale samples :scale 1/2 args)
    (apply #'format-graphics-samples-with-scale samples :scale 2 args)
    (apply #'format-graphics-samples-with-scale samples :scale-x 2 args)
    (apply #'format-graphics-samples-with-scale samples :rotation (/ pi 2) args)
    (apply #'format-graphics-samples-with-scale samples :rotation (/ pi 3) args)
    (apply #'format-graphics-samples-with-scale samples :scale-y 2 :rotation (* pi 5/6)
	   args)
    ))

(defparameter *string-shapes*
  '(("Normal" graphics:draw-string)
    ("Tilted" graphics:draw-string :toward-y 0)
    ("Scaled" graphics:draw-string :toward-x 100 :stretch-p t)
    ("Scaled with fixed font" graphics:draw-string-image :scale-down-allowed nil)
    ("Scaled by size" graphics:draw-string-image :character-size 1 :scale-down-allowed nil)
    ("Scaled by width" graphics:draw-string-image :string-width 100 :scale-down-allowed nil)
    ))

(defun string-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Strings" stream)
  (let ((samples (loop for (title function . args) in *string-shapes*
		       collect (formatting-graphics-sample (stream :title title)
				 (apply #'testing-funcall function
					"Foo" 0 0 :character-style '(:fix :roman :large)
					:stream stream args)))))
    (apply #'format-graphics-samples samples args)
    (apply #'format-graphics-samples samples :scale 1/2 args)
    (apply #'format-graphics-samples samples :scale 2 args)
    (apply #'format-graphics-samples samples :scale-x 2 args)
    (apply #'format-graphics-samples samples :rotation (/ pi 2) args)
    (apply #'format-graphics-samples samples :rotation (/ pi 3) args)))

(defvar *pinhead*
  (let ((a '#2A((1073741823 8388606) (536842239 8388604) (268374015 8388604)
		(1207832575 8388604) (-470003713 8388604) (-201797633 8388604)
		(2033438719 8388604) (17813503 8388604) (522293247 8388607)
		(-101183489 8388607) (-2146496513 8388607) (262143 8388606)
		(65535 8388604) (638975 8388600) (319487 8388600)
		(454655 8388592) (452607 8388592) (423935 8388576)
		(424959 8388576) (227839 8388576) (228607 8388544)
		(212511 8388544) (212895 8388480) (212991 8388480)
		(212991 8388480) (204799 8388352) (73727 8388352)
		(106495 8388096) (102399 8388096) (102399 8387584)
		(53247 8386560) (51199 8384512) (26623 8384512)
		(25599 8380416) (-4180993 8380352) (2120249855 8382336)
		(-7333377 8363969) (-532666113 7926371) (-870310657 8152871)
		(-872384257 8020515) (-1069565823 8360003) (-1839103 8064899)
		(1132490781 8259202) (57661 8126600) (33126 8126726)
		(16500 7864582) (16509 7864839) (-2147458959 7864832)
		(1073750065 7864832) (-536846301 7866112) (-268378042 7866879)
		(-939409202 7870591) (100778142 8130672) (125927582 8380640)
		(41877535 8372288) (33423391 8241152) (29163543 8224768)
		(3932641 8290304) (3932608 6430716) (-65535872 458815)
		(3145856 65536) (1075839168 65792) (-2147483520 65791)
		(-2147483456 32783) (-1072693118 32769) (1073741952 32768)
		(1073742080 311296) (768 16384) (3584 16384)
		(14592 16384) (57344 24576) (491520 24576)
		(1835008 8192) (15728672 4096) (260063232 134144)
		(-134217728 2047) (16 511) (4096 526335)
		(-2145382392 4095) (-1072693240 8191) (-535820280 16383)
		(-268435456 32767) (-267909120 16767) (-134215672 57599)
		(-134215680 2154719) (-134217728 2203851) (-66846720 110723)
		(-67106800 108672) (2080901136 107520) (2080374800 2204256)
		(2013268000 2134080) (-2012737504 36896) (-2013265920 1085456)
		(135274497 36897) (268435459 2115681) (268451854 1591362))))
    (multiple-value-bind (width height)
	(decode-raster-array a)
      (let ((b (make-raster-array (* width 32) height :element-type 'bit :displaced-to a))
	    (c (make-raster-array (* width 32) height :element-type 'bit)))
	(bitblt tv:alu-seta (* width 32) height b 0 0 c 0 0)
	c))))

(defun image-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Images" stream)
  (apply #'format-graphics-samples
	 (loop for draw-args in `(nil (:scale 1/2) (:scale 2)
				      (:rotation ,(/ pi 2)) (:rotation ,(/ pi 3)))
	       collect (formatting-graphics-sample (stream)
			 (apply #'testing-funcall 'graphics:draw-image
				*pinhead* 0 0
				:image-right 50 :scale-y -1
				:stream stream draw-args)))
	 args))

(defun header-line (string &optional (stream *standard-output*))
  (fresh-line stream)
  (with-character-size (:large stream :bind-line-height t)
    (write-line string stream)))

(defun draw-logo (&optional (stream *standard-output*)
		  &key (scale 50))
  (graphics:with-graphics-scale (stream scale)
    (graphics:draw-regular-polygon .75 .5 1.25 .5 4 :stream stream :gray-level .25)
    (graphics:draw-regular-polygon 0 0 1 0 3 :stream stream :gray-level .75)
    (graphics:draw-circle 1.5 .5 .4 :stream stream :gray-level .5 :opaque t)))

(defun encoded-graphics-test ()
  (header-line "Binary encoding")
  (let* ((encoded (testing-funcall 'graphics:binary-encode-graphics-to-array #'draw-logo))
	 (chars (with-output-to-string (stream)
		  (testing-funcall 'graphics:write-encoded-graphics-as-characters
				   encoded stream)))
	 (recoded (with-input-from-string (stream chars)
		    (testing-funcall 'graphics:read-encoded-graphics-as-characters stream)))
	 (decoded (graphics:binary-decode-graphics-from-array-into-function recoded
									    :compile t)))
    (assert (equalp encoded recoded))
    (assert (every #'standard-char-p chars))
    (format-graphics-samples (list (make-graphics-sample #'draw-logo nil)
				   (make-graphics-sample decoded nil)))))

(defun overlapping-draw-logo (&key (stream *standard-output*)
				   (opaque t)
				   (scale 50))
  (graphics:with-graphics-scale (stream scale)
    (list
      (testing-funcall 'graphics:draw-regular-polygon .75 .5 1.25 .5 4
		       :stream stream :gray-level .25 :return-presentation t)
      (testing-funcall 'graphics:draw-regular-polygon .25 0 1.25 0 3
		       :stream stream :gray-level .75 :opaque opaque :return-presentation t)
      (testing-funcall 'graphics:draw-ellipse 1.5 .5 .4 .4
		       :stream stream :gray-level .5 :opaque opaque
		       :return-presentation t))))

(defun opaque-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Opaque" stream)
  (apply #'format-graphics-samples
	 (list (formatting-graphics-sample (stream :title "Yes")
		 (overlapping-draw-logo :stream stream :opaque t))
	       (formatting-graphics-sample (stream :title "No")
		 (overlapping-draw-logo :stream stream :opaque nil)))
	 args))

(defun erase-test (&key (stream *standard-output*))
  (header-line "Erasing" stream)
  (graphics:with-room-for-graphics (stream 50)
    (overlapping-draw-logo :stream stream)
    (testing-funcall 'graphics:graphics-translate 200 0 :stream stream)
    (let ((pres (overlapping-draw-logo :stream stream)))
      (testing-funcall 'graphics:erase-graphics-presentation (first pres)))))

(defun dashed-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Dashes" stream)
  (apply #'format-graphics-samples-with-scale
	 (loop for draw-args in '(nil (:dash-pattern (4 2)) (:dash-pattern (10 5 2 1))
				      (:thickness 2) (:thickness 2 :dash-pattern (4 2)))
	       nconc
		 (loop for (title function . args) in *basic-shapes*
		       collect (formatting-graphics-sample (stream :title title)
				 (apply #'testing-funcall function
					`(,@args :stream ,stream :filled nil
						 :dashed t :scale-thickness nil
						 . ,draw-args)))))
	 args))

(defun path-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Paths" stream)
  (flet ((star-drawer (&optional (*standard-output* *standard-output*))
	   (testing-funcall 'graphics:set-current-position 0 0)
	   (dotimes (i 4)
	     (testing-funcall 'graphics:draw-line-to 1 0)
	     (testing-funcall 'graphics:graphics-origin-to-current-position)
	     (testing-funcall 'graphics:graphics-rotate (float (* -4/5 pi) 0.0)))
	   (testing-funcall 'graphics:close-path))
	 (bz-drawer (*standard-output*)
	   (graphics:set-current-position 0 0)
	   (testing-funcall 'graphics:draw-bezier-curve-to 1 1 1/2 3/2 3/4 -1/2)
	   (graphics:draw-line-to 1 -1)
	   (graphics:close-path))
	 (arc-drawer (*standard-output*)
	   (graphics:set-current-position -1 1)
	   (testing-funcall 'graphics:draw-circular-arc-to 1 1 0 0 1/2)
	   (graphics:draw-line-to 1 1)
	   (graphics:close-path))
	 (arc2-drawer (*standard-output*)
	   (graphics:set-current-position 0 0)
	   (graphics:draw-line-to -1 1)
	   (testing-funcall 'graphics:draw-circular-arc-through-point-to 1 1 0 3/2)
	   (graphics:close-path)))
    (loop for draw-args in '(nil
			     (:winding-rule :odd-even)
			     (:filled nil)
			     (:filled nil :thickness 2 :scale-thickness nil)
			     (:filled nil :dashed t :dash-pattern #(2 2)))
	  do
      (apply #'format-graphics-samples-with-scale
	     (list (formatting-graphics-sample ()
		     (apply #'testing-funcall 'graphics:draw-path #'star-drawer draw-args))
		   (formatting-graphics-sample ()
		     (apply #'testing-funcall 'graphics:draw-path #'bz-drawer draw-args))
		   (formatting-graphics-sample ()
		     (apply #'testing-funcall 'graphics:draw-path #'arc-drawer draw-args))
		   (formatting-graphics-sample ()
		     (apply #'testing-funcall 'graphics:draw-path #'arc2-drawer draw-args)))
	     args))))

(defun clipping-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (dolist (fun 'graphics:(with-clipping-path with-clipping-from-output))
    (testing-function fun))
  (header-line "Clipping" stream)
  (flet ((star-drawer (&optional (*standard-output* *standard-output*))
	   (graphics:set-current-position 0 0)
	   (dotimes (i 4)
	     (graphics:draw-line-to 2 0)
	     (graphics:graphics-origin-to-current-position)
	     (graphics:graphics-rotate (float (* -4/5 pi) 0.0)))
	   (graphics:close-path))
	 (circle-drawer (&optional (*standard-output* *standard-output*))
	   (graphics:draw-circle 0 0 1)))
    (apply #'format-graphics-samples-with-scale
	   (list (formatting-graphics-sample ()
		   (graphics:draw-path #'star-drawer))
		 (formatting-graphics-sample ()
		   (circle-drawer))
		 (formatting-graphics-sample ()
		   (graphics:with-clipping-path (t #'star-drawer)
		     (circle-drawer)))
		 (formatting-graphics-sample ()
		   (graphics:with-clipping-from-output (t (circle-drawer))
		     (graphics:draw-path #'star-drawer))))
	   args)))

(defun line-joint-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Line joints" stream)
  (apply #'format-graphics-samples-with-scale
	 (loop for triangle in '((0 0 0 1 2 0)
				 (-2 0 0 1 2 0))
	       nconc
	   (loop for shape in '(:miter :bevel :round)
		 collect (formatting-graphics-sample (t :title (string-capitalize shape))
			   (apply #'testing-funcall 'graphics:draw-triangle
				  `(,@triangle :filled nil :thickness 8 :scale-thickness nil
					       :line-joint-shape ,shape)))))
	 args))

(defun line-end-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Line ends" stream)
  (let ((samples (loop for shape in '(:butt :square :round)
		       collect (formatting-graphics-sample (t :title (string-capitalize
								       shape))
				 (testing-funcall 'graphics:draw-line -1 0 1 0
						  :thickness 8 :scale-thickness nil
						  :line-end-shape shape)))))
    (dolist (rotation (list 0 (/ pi 3) (/ pi 4) (/ pi 2)))
      (apply #'format-graphics-samples-with-scale samples :rotation rotation args))))

(defun arrow-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Arrows" stream)
  (let ((samples (loop for args in '(nil
				     (:thickness 4)
				     (:arrow-head-length 15)
				     (:arrow-head-length 15 :thickness 2))
		       collect (formatting-graphics-sample ()
				 (apply #'testing-funcall 'graphics:draw-arrow -50 0 50 0
					args)))))
    (dolist (rotation (list 0 (/ pi 3) (/ pi 4) (/ pi 2)))
      (apply #'format-graphics-samples samples :rotation rotation args))))

(defun scale-thickness-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Scale thickness / dashes" stream)
  (let ((samples (loop for args in '(nil
				     (:dashed t)
				     (:scale-thickness t)
				     (:dashed t :scale-dashes t)
				     (:dashed t :scale-dashes t :scale-thickness t))
		       collect (formatting-graphics-sample ()
				 (apply #'testing-funcall 'graphics:draw-line 0 0 100 0
					:thickness 1 args)))))
    (dolist (scale '(1 1/2 2))
      (apply #'format-graphics-samples samples :scale scale args))))

(defun physical-scale-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Physical scale" stream)
  (testing-function 'graphics:with-physical-device-scale)
  (let ((samples (loop for unit in '(:centimeter :line)
		       collect (formatting-graphics-sample
				   (t :title (format nil "1 ~(~A~)" unit))
				 (graphics:with-physical-device-scale (t 1 unit)
				   (graphics:draw-circle 0 0 1))))))
    (apply #'format-graphics-samples samples args)))

(defparameter *1/4-attachment-angles* '((0 :left :center)
					(1/4 :left :baseline)
					(1/2 :center :bottom)
					(3/4 :right :baseline)
					(1 :right :center)
					(5/4 :right :top)
					(3/2 :center :top)
					(7/4 :left :top)))
(defparameter *1/6-attachment-angles* '((0 :left :center)
					(1/6 :left :baseline)
					(1/3 :left :baseline)
					(1/2 :center :bottom)
					(2/3 :right :baseline)
					(5/6 :right :baseline)
					(1 :right :center)
					(7/6 :right :top)
					(4/3 :right :top)
					(3/2 :center :top)
					(5/3 :left :top)
					(11/6 :left :top)))

(defun attachment-test (&rest args
			&key (tilted-p nil) (stretch-p nil) (image-p nil)
			     (angles *1/4-attachment-angles*)
			     (stream *standard-output*)
			&allow-other-keys)
  (header-line (format nil "~@(~:[~;tilted ~]~:[~;stretched ~]~:[~;image ~]attachment~)"
		       tilted-p stretch-p image-p)
	       stream)
  (si:with-rem-keywords (some-args args '(:tilted-p :stretch-p :image-p :angles))
    (apply #'format-graphics-samples
	   (list (formatting-graphics-sample (stream)
		   (graphics:with-graphics-translation (stream 300 100)
		     (loop for (angle xa ya) in angles
			   do
		       (setq angle (* pi angle))
		       (multiple-value-bind (x y)
			   (graphics:drawing-path (stream :filled nil)
			     (graphics:set-current-position 0 0 :stream stream)
			     (graphics:draw-line-to 100 0 :stream stream
							  :rotation angle)
			     (graphics:current-position :stream stream))
			 (let* ((string (format nil "~(~A+~A~)" xa ya))
				(style '(:swiss :bold :large))
				(width (* (with-character-style (style stream)
					    (send stream :string-length string))
					  1.5)))
			   (if image-p
			       (graphics:with-graphics-translation (stream x y)
				 (graphics:with-graphics-rotation (stream
								    (if tilted-p angle 0))
				   (graphics:draw-string-image string 0 0
							       :character-style style
							       :string-width (and stretch-p
										  width)
							       :stream stream
							       :attachment-x xa
							       :attachment-y ya)))
			       (multiple-value-bind (to-x to-y)
				   (if tilted-p
				       (graphics:transform-point (+ width 100) 0
					 (graphics:build-graphics-transform :rotation angle))
				       (values (+ x width) y))
				 (graphics:draw-string string x y 
						       :toward-x to-x
						       :toward-y to-y
						       :stretch-p stretch-p
						       :character-style style
						       :stream stream
						       :attachment-x xa
						       :attachment-y ya)))))))))
	   some-args)))

(defun all-attachment-test (&rest args)
  (labels ((with-keys (to-go &rest args)
	     (if to-go
		 (destructuring-bind (key . rest) to-go
		   (dolist (val '(nil t))
		     (apply #'with-keys rest key val args)))
		 (apply #'attachment-test args))))
    (apply #'with-keys '(:image-p :tilted-p :stretch-p) args))
  (apply #'attachment-test :tilted-p t :angles *1/6-attachment-angles* args))

(defun animation-test ()
  (header-line "Animation")
  (dolist (fun 'graphics:(replacing-graphics-presentation with-output-to-bitmap-stream
			  with-room-for-graphics))
    (testing-function fun))
  (graphics:with-room-for-graphics (t 150)
    (graphics:with-output-to-bitmap-stream (bitmap-stream :for-stream *standard-output*
							  :host-allowed t)
      (let ((old-output nil)
	    (old-pattern nil))
	(loop for i to 25
	      as x = (+ 100 (* i 16))
	      do
	  (multiple-value-setq (old-output old-pattern)
	    (graphics:replacing-graphics-presentation (t old-output
							 :pattern-array old-pattern
							 :bitmap-stream bitmap-stream)
	      (graphics:with-graphics-translation (t x 100)
		(graphics:draw-circle 0 0 20)
		(let ((angle (/ (* pi i) 25)))
		  (graphics:draw-triangle 20 0 40 0 40 10 :rotation angle)
		  (graphics:draw-circle 0 0 30 :inner-radius 20 :start-angle angle))))))))))

(defun transformed-ellipse-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "More ellipses" stream)
  (apply #'format-graphics-samples-with-scale
	 (loop for (name . options) in `(("Normal" )
					 ("Scale" :scale 2)
					 ("Scale-x" :scale-x 2)
					 ("Scale-y" :scale-y 2)
					 ("Rotate" :rotate 1)
					 ("Rotate, then scale" :rotate .5 :scale-x 2)
					 ("Scale, then rotate" :scale-x 2 :rotate 1)
					 )
	       collect (formatting-graphics-sample (stream :title name)
			 (graphics:saving-graphics-transform (stream)
			   (loop for (key val) on options by 'cddr do
			     (ecase key
			       (:scale (graphics:graphics-scale val val :stream stream))
			       (:scale-x (graphics:graphics-scale val 1 :stream stream))
			       (:scale-y (graphics:graphics-scale 1 val :stream stream))
			       (:rotate (graphics:graphics-rotate val :stream stream))
			       ))
			   (graphics:draw-rectangle -2 -1 2 1 :stream stream)
			   (graphics:draw-ellipse 0 0 2 1 :stream stream :gray-level 0))))
	 args))

(defun coordinate-mode-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Coordinate modes" stream)
  (let ((samples (loop for mode in '(:exact :integer :center)
		       append (loop for offset in '(0 .5 .25)
				    collect (formatting-graphics-sample
					        (t :title (format nil "~(~A~) ~S" mode offset))
					      (graphics:with-coordinate-mode (t mode)
						(graphics:draw-circle offset offset
								      (+ 8 offset))))))))
    (apply #'format-graphics-samples samples args)))

(defun driver-tests ()
  (header-line "Drivers")
  (line-driver-test)
  (triangle-driver-test)
  (circle-driver-test)
  (circle-driver-test-2)
  )

(defmacro testing-driver ((point-function slice-function new-value &rest options)
			  &body body)
  (declare (arglist (point-function slice-function new-value &key (show-result t))
		    &body body))
  `(let ((,new-value 1))
     (testing-driver-internal (lambda (,point-function ,slice-function)
				(ignore point-function slice-function)
				. ,body)
			      (locf ,new-value)
			      . ,options)))

(defun testing-driver-internal (continuation new-value-location &key (show-result t))
  (declare (sys:downward-funarg continuation))
  (multiple-value-bind (width height x-offset y-offset)
      (let ((min-x 0)
	    (min-y 0)
	    (max-x 0)
	    (max-y 0))
	(funcall continuation #'(lambda (x y)
				  (minf min-x x)
				  (minf min-y y)
				  (maxf max-x (1+ x))
				  (maxf max-y (1+ y)))
			      #'(lambda (width height x y)
				  (minf min-x x)
				  (minf min-y y)
				  (maxf max-x (+ x width))
				  (maxf max-y (+ y height))))
	(values (- max-x min-x) (- max-y min-y) min-x min-y))
    (setf (location-contents new-value-location) 1)
    (let ((raster (make-raster-array width height :initial-element 0)))
      (funcall continuation #'(lambda (x y)
				(incf (raster-aref raster (- x x-offset) (- y y-offset))
				      (location-contents new-value-location)))
			    #'(lambda (width height x y)
				(loop for y from y repeat height do
				  (loop for x from x repeat width do
				    (incf (raster-aref raster (- x x-offset) (- y y-offset))
					  (location-contents new-value-location))))))
      (if show-result
	  (with-character-style ('(:fix :roman :very-small))
	    (loop for y below height do
	      (loop for x below width do
		(write-char (case (raster-aref raster x y)
			      ((0) #\space)
			      ((1) #\.)
			      ((2) #\O)
			      ((3) #\*)
			      (otherwise (digit-char (raster-aref raster x y) 16)))))
	      (terpri)))
	  (loop for y below height do
	    (loop for x below width do
	      (case (raster-aref raster x y)
		((0 3) )
		(otherwise
		  (format t "~&~D,~D: ~D~%" (+ x x-offset) (+ y y-offset)
					    (raster-aref raster x y))))))))))

(defmacro drawing-into-slices ((point-function stream &optional y-inversion) &body body)
  `(multiple-value-bind (raster x-offset y-offset)
       (graphics:with-output-to-bitmap (,stream)
	 . ,body)
     (multiple-value-bind (width height)
	 (decode-raster-array raster)
       (loop for y below height do
	 (loop for x below width do
	   (when (not (zerop (raster-aref raster x y)))
	     (funcall ,point-function
		      (+ x x-offset)
		      ,(if y-inversion
			   `(- ,y-inversion (+ y y-offset))
			   `(+ y y-offset)))))))))

(defun line-driver-test ()
  (write-line "line-driver draws the same as microcode.")
  (testing-driver (point-function slice-function value)
    (let ((points '((5 5 15 5 t) (20 0 20 10 t)
		    (25 2 45 10 nil) (50 14 65 3 nil))))
      (loop for (x1 y1 x2 y2 draw-end-point) in points do
	(testing-funcall 'graphics:draw-line-driver x1 y1 x2 y2 draw-end-point slice-function))
      (setq value #b10)
      (drawing-into-slices (point-function stream 20)
	(loop for (x1 y1 x2 y2 draw-end-point) in points do
	  (send stream :draw-line x1 (- 20 y1) x2 (- 20 y2) boole-ior draw-end-point))))))

(defun triangle-driver-test ()
  (write-line "triangle-driver draws the same as microcode.")
  (testing-driver (point-function slice-function value)
    (let ((triangles '((0 8 8 0 16 8)
		       (20 0 20 10 30 0)
		       (40 7 52 0 60 4))))
      (loop for (x1 y1 x2 y2 x3 y3) in triangles do
	(testing-funcall 'graphics:draw-triangle-driver x1 y1 x2 y2 x3 y3 slice-function))
      (setq value #b10)
      (drawing-into-slices (point-function stream)
	(loop for (x1 y1 x2 y2 x3 y3) in triangles do
	  (send stream :draw-triangle x1 y1 x2 y2 x3 y3 boole-ior))))))

(defun circle-driver-test ()
  (write-line "Circle has proper rectangle bounding box.")
  (testing-driver (point-function slice-function value)
    (funcall slice-function (* 8 2) (* 8 2) (- 15 8) (- 10 8))
    (funcall slice-function (* 16 2) (* 8 2) (- 65 16) (- 10 8))
    (setq value #b10)
    (testing-funcall 'graphics:draw-circle-driver 15 10 8 slice-function)
    (testing-funcall 'graphics:draw-ellipse-driver 65 10 16 8 slice-function))
  #||	;Unfilled now incorrect.
  (write-line "Circle joins with its outline.")
  (testing-driver (point-function slice-function value)
    (testing-funcall 'graphics:draw-circle-driver 15 10 9 slice-function)
    (testing-funcall 'graphics:draw-ellipse-driver 65 10 15 9 slice-function)
    (setq value #b10)
    (testing-funcall 'graphics:draw-unfilled-circle-driver 15 10 9 point-function)
    (testing-funcall 'graphics:draw-unfilled-ellipse-driver 65 10 15 9 point-function))
  ||#
  (write-line "Circle correctly meets mathematical rasterization test")
  (testing-driver (point-function slice-function value)
    (testing-funcall 'graphics:draw-circle-driver 15 10 7 slice-function)
    (testing-funcall 'graphics:draw-ellipse-driver 65 10 15 7 slice-function)
    (setq value #b10)
    (loop for y from -10 to 10 do
      (loop for x from -10 to 10 do
	(when (point-inside-elliptical-ring-p x y 0 0 7 7 0 0)
	  (funcall point-function (+ 15 x) (+ 10 y)))))
    (loop for y from -10 to 10 do
      (loop for x from -20 to 20 do
	(when (point-inside-elliptical-ring-p x y 0 0 15 7 0 0)
	  (funcall point-function (+ 65 x) (+ 10 y))))))
  #||
  (testing-driver (point-function slice-function value)
    (testing-funcall 'graphics:draw-unfilled-circle-driver 15 10 7 point-function)
    (testing-funcall 'graphics:draw-unfilled-ellipse-driver 65 10 15 7 point-function)
    (setq value #b10)
    (loop for y from -10 to 10 do
      (loop for x from -10 to 10 do
	(when (point-inside-elliptical-ring-p x y 0 0 7.5 7.5 6.5 6.5)
	  (funcall point-function (+ 15 x) (+ 10 y)))))
    (loop for y from -10 to 10 do
      (loop for x from -20 to 20 do
	(when (point-inside-elliptical-ring-p x y 0 0 15.5 7.5 14.5 6.5)
	  (funcall point-function (+ 65 x) (+ 10 y))))))
  ||#
  (write-line "A circle plus a ring equals a larger circle")
  (testing-driver (point-function slice-function value)
    (testing-funcall 'graphics:draw-circle-driver 15 10 5 slice-function)
    (testing-funcall 'graphics:draw-circular-ring-driver 15 10 5 10 slice-function)
    (setq value #b10)
    (testing-funcall 'graphics:draw-circle-driver 15 10 10 slice-function))
  (write-line "Half-lattice circle same as :draw-filled-in-circle")
  (testing-driver (point-function slice-function value)
    (testing-funcall 'graphics:draw-circle-driver 15.5 10.5 10.5 slice-function)
    (setq value #b10)
    (drawing-into-slices (point-function stream)
      (send stream :draw-filled-in-circle 15 10 10))))

(defun circle-driver-test-2 ()
  (write-line "Drawing functions call drivers properly.")
  (format-graphics-samples
    (list
      (formatting-graphics-sample (t :title "Circle+Square")
	(graphics:draw-circle 0 0 10)
	(graphics:draw-rectangle -10 -10 10 10 :alu :flip))
      (formatting-graphics-sample (t :title "Ellipse+Rectangle")
	(graphics:draw-ellipse 0 0 20 10)
	(graphics:draw-rectangle -20 -10 20 10 :alu :flip))
      (formatting-graphics-sample (t :title "Circle+Outline")
	(graphics:draw-circle 0 0 10 :gray-level .25)
	(graphics:draw-circle 0 0 10 :filled nil))
      (formatting-graphics-sample (t :title "Ellipse+Outline")
	(graphics:draw-ellipse 0 0 20 10 :gray-level .25)
	(graphics:draw-ellipse 0 0 20 10 :filled nil))
      (formatting-graphics-sample (t :title "Circle+ring")
	(graphics:draw-circle 0 0 5)
	(graphics:draw-circle 0 0 10 :inner-radius 5 :alu :flip))
      (formatting-graphics-sample (t :title "Circle-sector")
	(graphics:draw-circle 0 0 10)
	(graphics:draw-circle 0 0 10 :end-angle (/ pi 2) :alu :flip))
      (formatting-graphics-sample (t :title "Circle-arc")
	(graphics:draw-circle 0 0 10 :filled nil)
	(graphics:draw-circle 0 0 10 :filled nil :start-angle (- (/ pi 2)) :alu :flip))
      (formatting-graphics-sample (t :title "Ellipse-sector")
	(graphics:draw-ellipse 0 0 20 10)
	(graphics:draw-ellipse 0 0 20 10 :alu :flip :start-angle (* pi 5/6) :end-angle (* pi 7/6)))
      (formatting-graphics-sample (t :title "Ellipse-arc")
	(graphics:draw-ellipse 0 0 20 10 :filled nil)
	(graphics:draw-ellipse 0 0 20 10 :alu :flip :filled nil :start-angle (* pi 7/4)))
      )))

;;; This implements the direct (slow) mathematical version of inside-ness.

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL NIL :SMALL) "TVFONT");;; A pixel is inside the region if the center point (which is offset from the addressing point
;;; by (1/2,1/2)) of the pixel is inside and the center point is not on the boundary.  If the
;;; center point is on the boundary, the pixel is inside if and only if the region interior is
;;; immediately to the right (increasing x).  If the center is along a boundary whose tangent
;;; is horizontal, then the pixel is inside if the interior is immediately above (increasing y).
0(defun point-inside-elliptical-ring-p (x y center-x center-y
				       outer-x-radius outer-y-radius
				       inner-x-radius inner-y-radius)
  (let* ((px (+ (- x center-x) .5))
	 (py (+ (- y center-y) .5)))
    (flet ((within-border (x-radius y-radius)
	     (let ((f (- (+ (/ (expt px 2) (expt x-radius 2))
			    (/ (expt py 2) (expt y-radius 2)))
			 1)))
	       (cond ((minusp f) t)
		     ((plusp f) nil)
		     ((minusp px) t)
		     ((plusp px) nil)
		     ((minusp py) t)
		     (t nil)))))
      (and (within-border outer-x-radius outer-y-radius)
	   (or (zerop inner-x-radius) (zerop inner-y-radius)
	       (not (within-border inner-x-radius inner-y-radius)))))))

;;; draw-line-driver doesn't work with fractional arguments.
;;; draw-line-driver blows out trying to ash it.  If you replace the ash with floor 2, it
;;; fails to pass the slice function integers.
(defvar *big-driver-forms*
  '(("Line" (graphics:draw-line-driver 0 0 4 3 nil))

    ("Normal triangle" (graphics:draw-triangle-driver 0 0 10 1 5 4))
    ("Very oblique triangle" (graphics:draw-triangle-driver 0 -1 0 1 20 0))
    ("Slightly off" (graphics:draw-triangle-driver 0 0 4.1 1 2 3.9))
    ("Half-centered" (graphics:draw-triangle-driver 0.5 0.5 5.5 -0.5 3.5 6.5))

    ("Normal circle" (graphics:draw-circle-driver 100 100 10))
    ("Half-centered (like old (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB"):draw-circle0)" (graphics:draw-circle-driver 50.5 50.5 10.5))
    ("Slightly off center" (graphics:draw-circle-driver 0.02 0 8))
    ("1/4 off center (asymmetrical)" (graphics:draw-circle-driver 5.25 5.3333 10))

    ("Normal ellipse" (graphics:draw-ellipse-driver 100 100 10 5))
    ("Half-centered (like old 2:draw-filled-in-simple-ellipse0)"
     (graphics:draw-ellipse-driver 50.5 50.5 10.5 5.5))
    ("Slightly off center" (graphics:draw-ellipse-driver 0.02 0 8 4))
    ("1/4 off center (asymmetrical)" (graphics:draw-ellipse-driver 5.25 5.3333 10 5))
    ))

(defun big-driver-test ()
  (loop for (description (function . arguments)) in *big-driver-forms* do
    (big-driver function arguments)
    (write-line description)))

(defun big-driver (driver-function arguments &key (window-margin 50) (pixel-margin 2))
  (send *standard-output* :clear-window)
  (multiple-value-bind (wleft wtop wright wbottom)
      (send *standard-output* :visible-cursorpos-limits)
    ;; Leave room at the bottom for typeout and more processing.
    (decf wbottom (* (send *standard-output* :line-height) 2))
    (send *standard-output* :set-cursorpos wleft wbottom)
    (let ((drawing-function (driver-drawing-function driver-function)))
      (multiple-value-bind (dright dbottom nil nil dleft dtop)
	  (dw:continuation-output-size
	    #'(lambda (*standard-output*)
		;; continuation-output-size's stream cannot deal with negative numbers
		;; and would just clip.
		(graphics:with-graphics-translation (t 1000 1000)
		  (apply drawing-function arguments)))
	    *standard-output*)

	(decf dleft (+ 1000 pixel-margin))
	(decf dtop (+ 1000 pixel-margin))
	(decf dright (- 1000 pixel-margin))
	(decf dbottom (- 1000 pixel-margin))
  
	(let ((scale
		(max 3 (min (floor (- wright wleft (* window-margin 2)) (- dright dleft))
			    (floor (- wbottom wtop (* window-margin 2)) (- dbottom dtop))))))
	  (unless (oddp scale)
	    ;; Make sure center pixels are evenly spaced.
	    (decf scale))
	  (graphics:saving-graphics-transform ()
	    (graphics:graphics-translate (floor (+ wleft wright) 2)
					 (floor (+ wtop wbottom) 2))
	    (graphics:graphics-scale scale)
	    (graphics:graphics-translate (- (floor (+ dleft dright) 2))
					 (- (floor (+ dtop dbottom) 2)))

	    (graphics:map-points #'(lambda (x y ignore)
				     (graphics:draw-circle x y (/ 2 scale)))
				 (driver-control-points driver-function arguments))
  
	    (let ((character-style (list nil nil (cond ((< scale 10) :tiny)
						       ((< scale 25) :small)
						       (t nil)))))
	      (loop for x from dleft to dright do
		(graphics:draw-line x dtop x dbottom)
		(graphics:draw-string (format nil "~D" x) x dtop
				      :character-style character-style
				      :attachment-x :center :attachment-y :bottom))
	      (loop for y from dtop to dbottom do
		(graphics:draw-line dleft y dright y)
		(graphics:draw-string (format nil "~D" y) dleft y
				      :character-style character-style
				      :attachment-x :right :attachment-y :center)))
	    (loop for x from dleft below dright do
	      (loop for y from dtop below dbottom do
		(graphics:draw-point (+ x .5) (+ y .5))))
  
	    (apply drawing-function (append arguments '(:filled nil)))
	    (apply driver-function
		   (append arguments
		      (ncons
			#'(lambda (width height x y)
			    (graphics:draw-rectangle x y (+ x width) (+ y height)
						     :gray-level .25 :opaque nil)))))))))))

(defun draw-rectangle-driver (start-x start-y end-x end-y slice-function)
  (flet ((min-max (x1 x2 min-p pred)
	   (multiple-value-bind (rx rem)
	       (floor (if min-p (min x1 x2) (max x1 x2)))
	     ;; See comment on (graphics:draw-rectangle graphics:raster-graphics-mixin)
	     (if (funcall pred rem .5) (1+ rx) rx))))
    (let ((left (min-max start-x end-x t #'))
	  (top (min-max start-y end-y t #'>))
	  (right (min-max start-x end-x nil #'))
	  (bottom (min-max start-y end-y nil #'>)))
      (funcall slice-function (- right left) (- bottom top) left top))))

(defun driver-control-points (driver-function arguments)
  (ecase driver-function
    ((graphics:draw-circle-driver graphics:draw-ellipse-driver
      graphics:draw-unfilled-circle-driver graphics:draw-unfilled-ellipse-driver
      graphics:draw-circular-ring-driver graphics:draw-elliptical-ring-driver)
     (subseq arguments 0 2))
    ((graphics:draw-triangle-driver) arguments)
    ((graphics:draw-line-driver) (subseq arguments 0 4))
    ((draw-rectangle-driver) nil)))

(defun driver-drawing-function (driver-function)
  (ecase driver-function
    (graphics:draw-circle-driver #'graphics:draw-circle)
    (graphics:draw-ellipse-driver #'graphics:draw-ellipse)
    (graphics:draw-circular-ring-driver
      #'(lambda (center-x center-y inner-radius outer-radius &rest other-args)
	  (apply #'graphics:draw-circle center-x center-y outer-radius
					:inner-radius inner-radius
					other-args)))
    (graphics:draw-elliptical-ring-driver
      #'(lambda (center-x center-y inner-x-radius inner-y-radius outer-x-radius outer-y-radius
		 &rest other-args)
	  (apply #'graphics:draw-ellipse center-x center-y outer-x-radius outer-y-radius
		 :inner-x-radius inner-x-radius :inner-y-radius inner-y-radius
		 other-args)))
    (graphics:draw-triangle-driver #'graphics:draw-triangle)
    (graphics:draw-line-driver
      #'(lambda (start-x start-y end-x end-y draw-end-point &rest other-args)
	  (ignore draw-end-point)
	  (graphics:with-graphics-translation (t start-x start-y)
	    (graphics:with-graphics-rotation (t (atan (- end-y start-y) (- end-x start-x)))
	      (apply #'graphics:draw-rectangle -1/2 -1/2
					       (+ (sqrt (+ (expt (- end-x start-x) 2)
							   (expt (- end-y start-y) 2)))
						  +1/2)
					       1/2 other-args)))))
    (draw-rectangle-driver #'graphics:draw-rectangle)
    ))

(defun driver-inside-predicate (driver-function arguments)
  (ecase driver-function
    (graphics:draw-circle-driver
      (destructuring-bind (center-x center-y radius) arguments
	#'(lambda (x y)
	    (point-inside-elliptical-ring-p x y center-x center-y radius radius 0 0))))
    (graphics:draw-ellipse-driver
      (destructuring-bind (center-x center-y x-radius y-radius) arguments
	#'(lambda (x y)
	    (point-inside-elliptical-ring-p x y center-x center-y x-radius y-radius 0 0))))
    (graphics:draw-circular-ring-driver
      (destructuring-bind (center-x center-y inner-radius outer-radius) arguments
	#'(lambda (x y)
	    (point-inside-elliptical-ring-p x y center-x center-y
					    outer-radius outer-radius
					    inner-radius inner-radius))))
    (graphics:draw-elliptical-ring-driver
      (destructuring-bind (center-x center-y inner-x-radius inner-y-radius
			   outer-x-radius outer-y-radius)
	  arguments
	#'(lambda (x y)
	    (point-inside-elliptical-ring-p x y center-x center-y
					    outer-x-radius outer-y-radius
					    inner-x-radius inner-y-radius))))
    (graphics:draw-triangle-driver
      (destructuring-bind (x1 y1 x2 y2 x3 y3) arguments
	#'(lambda (x y)
	    (graphics::some-point-inside-triangle-p x1 y1 x2 y2 x3 y3 x y))))
    ))

(defun driver-point-p (driver-function)
  (member driver-function '(graphics:draw-unfilled-circle-driver
			    graphics:draw-unfilled-ellipse-driver)))

(defun general-big-driver (drawing-function drivers
			   &key (window-margin 50) (pixel-margin 2))
  (send *standard-output* :clear-window)
  (multiple-value-bind (wleft wtop wright wbottom)
      (send *standard-output* :visible-cursorpos-limits)
    ;; Leave room at the bottom for typeout and more processing.
    (decf wbottom (* (send *standard-output* :line-height) 2))
    (send *standard-output* :set-cursorpos wleft wbottom)
    (multiple-value-bind (dright dbottom nil nil dleft dtop)
	(dw:continuation-output-size
	  #'(lambda (*standard-output*)
	      ;; continuation-output-size's stream cannot deal with negative numbers
	      ;; and would just clip.
	      (graphics:with-graphics-translation (t 1000 1000)
		(funcall drawing-function)))
	  *standard-output*)

      (decf dleft (+ 1000 pixel-margin))
      (decf dtop (+ 1000 pixel-margin))
      (decf dright (- 1000 pixel-margin))
      (decf dbottom (- 1000 pixel-margin))
  
      (let ((scale
	      (max 3 (min (floor (- wright wleft (* window-margin 2)) (- dright dleft))
			  (floor (- wbottom wtop (* window-margin 2)) (- dbottom dtop))))))
	(unless (oddp scale)
	  ;; Make sure center pixels are evenly spaced.
	  (decf scale))
	(graphics:saving-graphics-transform ()
	  (graphics:graphics-translate (floor (+ wleft wright) 2)
				       (floor (+ wtop wbottom) 2))
	  (graphics:graphics-scale scale)
	  (graphics:graphics-translate (- (floor (+ dleft dright) 2))
				       (- (floor (+ dtop dbottom) 2)))

	  (loop for (driver-function nil . arguments) in drivers do
	    (graphics:map-points #'(lambda (x y ignore)
				     (graphics:draw-circle x y (/ 2 scale)))
				 (driver-control-points driver-function arguments)))
  
	  (let ((character-style (list nil nil (cond ((< scale 10) :tiny)
						     ((< scale 25) :small)
						     (t nil)))))
	    (loop for x from dleft to dright do
	      (graphics:draw-line x dtop x dbottom)
	      (graphics:draw-string (format nil "~D" x) x dtop
				    :character-style character-style
				    :attachment-x :center :attachment-y :bottom))
	    (loop for y from dtop to dbottom do
	      (graphics:draw-line dleft y dright y)
	      (graphics:draw-string (format nil "~D" y) dleft y
				    :character-style character-style
				    :attachment-x :right :attachment-y :center)))
	  (loop for x from dleft below dright do
	    (loop for y from dtop below dbottom do
	      (graphics:draw-point (+ x .5) (+ y .5))))
  
	  (loop for (driver-function gray-level . arguments) in drivers do
	    (labels ((slice-function (width height x y)
		       (graphics:draw-rectangle x y (+ x width) (+ y height)
						:gray-level gray-level :opaque nil))
		     (point-function (x y)
		       (slice-function 1 1 x y)))
	      (apply driver-function
		     (append arguments (ncons (if (driver-point-p driver-function)
						  #'point-function
						  #'slice-function))))))
	  (funcall drawing-function))))))

(defun big-unfilled-circle (center-x center-y radius)
  (general-big-driver #'(lambda ()
			  (graphics:draw-circle center-x center-y radius
						:filled nil :alu :flip)
			  (graphics:draw-circle center-x center-y (- radius 1/2)
						:filled nil :alu :flip)
			  (graphics:draw-circle center-x center-y (+ radius 1/2)
						:filled nil :alu :flip))
		      `((graphics:draw-circle-driver .25
						     ,center-x ,center-y ,radius)
			(graphics:draw-unfilled-circle-driver .75
							      ,center-x ,center-y ,radius))))

(defun test-driver-rasterization (driver-function arguments &key (show-result t))
  (fresh-line)
  (testing-driver (point-function slice-function value :show-result show-result)
    (apply #'testing-funcall driver-function (append arguments (ncons slice-function)))
    (setq value #b10)
    (multiple-value-bind (dright dbottom nil nil dleft dtop)
	(let ((drawing-function (driver-drawing-function driver-function)))
	  (dw:continuation-output-size
	    #'(lambda (*standard-output*)
		;; continuation-output-size's stream cannot deal with negative numbers
		;; and would just clip.
		(graphics:with-graphics-translation (t 1000 1000)
		  (apply drawing-function arguments)))
	    *standard-output*))

      (decf dleft (+ 1000 10))
      (decf dtop (+ 1000 10))
      (decf dright (- 1000 10))
      (decf dbottom (- 1000 10))

      (let ((predicate (driver-inside-predicate driver-function arguments)))
	(loop for y from dtop to dbottom do
	  (loop for x from dleft to dright do
	    (when (funcall predicate x y)
	      (funcall point-function x y))))))))

(defvar *more-driver-rasterizations*
  '((graphics:draw-circle-driver 0 0 2)
    (graphics:draw-circle-driver 0.5 0 2)
    (graphics:draw-circle-driver 0 0.5 2)
    (graphics:draw-circle-driver 0.5 0.5 2)
    (graphics:draw-circle-driver 0 0 2.5)
    (graphics:draw-circle-driver 0.5 0 2.5)
    (graphics:draw-circle-driver 0 0.5 2.5)
    (graphics:draw-circle-driver 0.5 0.5 2.5)

    (graphics:draw-ellipse-driver 0 0 4 2)
    (graphics:draw-ellipse-driver 0.5 0 4 2)
    (graphics:draw-ellipse-driver 0 0.5 4 2)
    (graphics:draw-ellipse-driver 0.5 0.5 4 2)
    (graphics:draw-ellipse-driver 0 0 4.5 2.5)
    (graphics:draw-ellipse-driver 0.5 0 4.5 2.5)
    (graphics:draw-ellipse-driver 0 0.5 4.5 2.5)
    (graphics:draw-ellipse-driver 0.5 0.5 4.5 2.5)

    (graphics:draw-circular-ring-driver 0 0 1 2)
    (graphics:draw-circular-ring-driver 0.5 0 1 2)
    (graphics:draw-circular-ring-driver 0 0.5 1 2)
    (graphics:draw-circular-ring-driver 0.5 0.5 1 2)
    (graphics:draw-circular-ring-driver 0 0 1.5 2.5)
    (graphics:draw-circular-ring-driver 0.5 0 1.5 2.5)
    (graphics:draw-circular-ring-driver 0 0.5 1.5 2.5)
    (graphics:draw-circular-ring-driver 0.5 0.5 1.5 2.5)

    (graphics:draw-elliptical-ring-driver 0 0 2 1 4 2)
    (graphics:draw-elliptical-ring-driver 0.5 0 2 1 4 2)
    (graphics:draw-elliptical-ring-driver 0 0.5 2 1 4 2)
    (graphics:draw-elliptical-ring-driver 0.5 0.5 2 1 4 2)
    (graphics:draw-elliptical-ring-driver 0 0 2.5 1.5 4.5 2.5)
    (graphics:draw-elliptical-ring-driver 0.5 0 2.5 1.5 4.5 2.5)
    (graphics:draw-elliptical-ring-driver 0 0.5 2.5 1.5 4.5 2.5)
    (graphics:draw-elliptical-ring-driver 0.5 0.5 2.5 1.5 4.5 2.5)
    ))

(defun test-more-driver-rasterizations (&key (show-result t))
  (header-line "More rasterizations")
  (dolist (elem *more-driver-rasterizations*)
    (format t "~&~S~%" elem)
    (test-driver-rasterization (first elem) (rest elem) :show-result show-result)))

;;; Can use this if you make a major change to the algorithm.

(defun compare-driver-implementations (driver-1 driver-2 arguments)
  (stack-let* ((nargs (length arguments))
	       (args (make-array (1+ nargs) :type 'sys:art-q-list :initial-contents arguments))
	       (argl (g-l-p args)))
    (multiple-value-bind (height y-offset)
	(let ((min-x 0)
	      (min-y 0)
	      (max-x 0)
	      (max-y 0))
	  (setf (aref args nargs)
		#'(lambda (width height x y)
		    (declare (sys:downward-function))
		    (minf min-x x)
		    (minf min-y y)
		    (maxf max-x (+ x width))
		    (maxf max-y (+ y height))))
	  (apply driver-1 argl)
	  (apply driver-2 argl)
	  (values (- max-y min-y) min-y))
      (stack-let ((xs (make-array height))
		  (widths (make-array height)))
	(setf (aref args nargs)
	      #'(lambda (width height x y)
		  (declare (sys:downward-function))
		  (when (plusp width)
		    (loop for j from (- y y-offset) repeat height do
		      (when (aref xs j)
			(error "~S Driver-1 did ~S slice twice." arguments (+ j y-offset)))
		      (setf (aref xs j) x)
		      (setf (aref widths j) width)))))
	(apply driver-1 argl)
	(setf (aref args nargs)
	      #'(lambda (width height x y)
		  (declare (sys:downward-function))
		  (when (plusp width)
		    (loop for j from (- y y-offset) repeat height do
		      (when (null (aref xs j))
			(error "~S Driver-2 did ~S slice twice." arguments (+ j y-offset)))
		      (unless (eql (aref xs j) x)
			(format t "~&X Discrepency for ~S at ~S: ~S vs. ~S.~%"
				arguments (+ j y-offset) x (aref xs j)))
		      (unless (eql (aref widths j) width)
			(format t "~&Width Discrepency for ~S at ~S: ~S vs. ~S.~%"
				arguments (+ j y-offset) width (aref widths j)))
		      (setf (aref xs j) nil)))))
	(apply driver-2 argl)))))

(defun all-pattern-tests (&rest args)
  (apply #'stipple-test args)
  (apply #'tile-test args)
  (apply #'grays-test args)
  (apply #'colors-test args)
  (apply #'pattern-logo-test args)
  (apply #'patterns-test args)
  )

(defun stipple-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Stippled shapes" stream)
  (apply #'format-graphics-samples-with-scale
	 (loop for (title function . args) in *basic-shapes*
	       collect (formatting-graphics-sample (stream :title title)
			 (apply #'testing-funcall function
				`(,@args :stream ,stream :stipple ,stipples:hearts))))
	 args))

(defun tile-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (unless #+3600 nil
	  #+IMach (and (color:color-stream-p stream)
		       (not (variable-boundp #'color:%draw-masked-bits-internal)))
    (header-line "Tiled shapes" stream)
    (testing-function 'graphics:with-output-to-bitmap)
    (apply #'format-graphics-samples-with-scale
	   (let ((tile (graphics:with-output-to-bitmap (bstream :for-stream stream)
			 (graphics:with-graphics-scale (bstream 1 -1)
			   (draw-logo bstream :scale 30)))))
	     (loop for (title function . args) in *basic-shapes*
		   collect (formatting-graphics-sample (stream :title title)
			     (apply #'testing-funcall function
				    `(,@args :stream ,stream :tile ,tile)))))
	   args)))

(defun grays-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Grays" stream)
  (apply #'format-graphics-samples
	 (loop for gray from 0 to 1 by .125
	       collect (formatting-graphics-sample (t :title (format nil "~$" gray))
			 (graphics:draw-triangle 0 0 60 0 30 50 :gray-level gray)))
	 args))

(defun colors-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Colors" stream)
  (apply #'format-graphics-samples
	 (loop for color in '(:red :blue :green :cyan :magenta :yellow)
	       collect (formatting-graphics-sample (t :title (string-downcase color))
			 (graphics:draw-circle 0 0 25 :color color)))
	 args))

(defun draw-pattern-logo (square-pattern circle-pattern triangle-pattern
			  &optional (stream *standard-output*)
			  &key (scale 50))
  (graphics:with-graphics-scale (stream scale)
    (graphics:draw-regular-polygon .75 .5 1.25 .5 4 :stream stream :pattern square-pattern)
    (graphics:draw-regular-polygon 0 0 1 0 3 :stream stream :pattern triangle-pattern)
    (graphics:draw-circle 1.5 .5 .4 :stream stream :pattern circle-pattern :opaque t)))

(defun construct-pattern-logo-patterns ()
  (list (list "Colors"
	      (testing-funcall 'graphics:make-simple-pattern :color :red)
	      (testing-funcall 'graphics:make-simple-pattern :color :blue)
	      (testing-funcall 'graphics:make-simple-pattern :color :green))
	(list "Pattern/color"
	      (testing-funcall 'graphics:make-device-conditional-pattern
		`((:color :color :yellow)
		  (otherwise :stipple ,stipples:southeast-rain)))
	      (graphics:make-device-conditional-pattern
		`((:color :color :cyan)
		  (otherwise :stipple ,stipples:southwest-rain)))
	      (graphics:make-device-conditional-pattern
		`((:color :color :magenta)
		  (otherwise :stipple ,stipples:horizontal-dashes))))
	(list* "Contrasting"
	       (loop for i below 3
		     collect (testing-funcall 'graphics:make-contrasting-pattern i 3)))
	))

(defun pattern-logo-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (header-line "Adjacent patterns" stream)
  (apply #'format-graphics-samples
	 (loop for (title square-pattern circle-pattern triangle-pattern)
	       in (construct-pattern-logo-patterns)
	       collect 
		 (formatting-graphics-sample (t :title title)
		   (draw-pattern-logo square-pattern circle-pattern triangle-pattern)))
	 args))

(defflavor random-pattern
	(phase)
	(graphics:raster-slice-device-pattern lgp:postscript-device-pattern)
  (:constructor make-random-pattern (phase)))

(defmethod (graphics:pattern-draw-raster-slice random-pattern)
	   (width height x y ones-alu zeros-alu stream ignore)
  (let ((raster (graphics:make-raster-array-with-correct-width width height
							       :element-type 'bit)))
    (loop for real-y from y
	  for y from 0 below height
	  do
      (loop repeat (floor (* width (mod real-y phase)) phase)
	    do
	(setf (raster-aref raster (random width) y) 1)))
    (send stream :draw-1-bit-raster width height raster 0 0 x y ones-alu zeros-alu)))

(defmethod (lgp:pattern-output-postscript-code random-pattern)
	   (device-stream filled ignore ignore)
  (format device-stream "8 0 {pop pop 1 rand and} setscreen .25 setgray ")
  (write-string (if filled "fill" "stroke") device-stream))

(compile-flavor-methods random-pattern)

(defun construct-patterns (stream)
  (list (list "Black" nil)
	(list "Gray" (graphics:make-simple-pattern :gray-level .5))
	(list "Stipple" (graphics:make-simple-pattern :stipple stipples:parquet))
	(list "Tile" (graphics:make-simple-pattern
		       :tile (graphics:with-output-to-bitmap
			       (bstream :for-stream stream)
			       (graphics:with-graphics-scale (bstream 1 -1)
				 (draw-pattern-logo
				   (graphics:make-contrasting-pattern 1 4)
				   (graphics:make-contrasting-pattern 2 4)
				   (graphics:make-contrasting-pattern 3 4)
				   bstream :scale 30)))))
	(list "Gray stipple" (graphics:make-simple-pattern :stipple stipples:weave8
							   :gray-level .5))
	(list "2-color stipple" (graphics:make-two-color-stipple stipples:filled-diamonds
								 :red :yellow))
	(list "Random" (make-random-pattern 8))
	))

(defun patterns-test (&rest args &key (stream *standard-output*) &allow-other-keys)
  (unless #+3600 nil
	  #+IMach (and (color:color-stream-p stream)
		       (not (variable-boundp #'color:%draw-masked-bits-internal)))
    (header-line "Patterns" stream)
    (apply #'format-graphics-samples
	   (loop for (title pattern) in (construct-patterns stream)
		 collect (formatting-graphics-sample (t :title title)
			   (graphics:draw-regular-polygon 0 0 25 0 6 :pattern pattern)))
	   args)))

(defun business-graphics-test (&key (stream *standard-output*))
  (let ((*standard-output* stream))
    (header-line "Business graphics")
    (pie-chart '(("Executive Parties" 1.0) ("Corporate Jet" .75)
		 ("Salaries" .1) ("Miscellaneous" .2)))))

(defun pie-chart (names-and-fractions)
  (let ((nitems (length names-and-fractions))
        (total (loop for (nil fraction) in names-and-fractions sum fraction)))
    (graphics:with-scan-conversion-mode (t :sketch t)
      (graphics:with-room-for-graphics (t 300)
	(graphics:with-graphics-translation (t 350 150)
	  (loop for ((name fraction) . rest) on names-and-fractions
		for angle = (* pi 1/2) then nangle
		as nangle = (if rest (- angle (* graphics:2pi (/ fraction total))) (* pi 5/2))
		for item-no from 0
		do
	    (flet ((arc (&rest drawing-args)
		     (apply #'graphics:draw-circle 0 0 50
			    :start-angle angle :end-angle nangle :clockwise t
			    drawing-args)))
	      (dw:with-output-as-presentation
		  (:object fraction :type 'number
			   :highlighting-boxes (dw:computing-outline-from-path
						 (t :filled-allowed t
						    :transform (graphics:stream-transform
								 *standard-output*))
						 (arc)))
		(arc :pattern (graphics:make-contrasting-pattern item-no nitems)))
	      (arc :filled nil :thickness 2))
	    (multiple-value-bind (x y)
		(graphics:drawing-path (t :filled nil)
		  (graphics:with-graphics-rotation (t (/ (+ angle nangle) 2))
		    (graphics:set-current-position 50 0)
		    (graphics:draw-line-to 75 0))
		  (graphics:current-position))
	      (graphics:draw-string name x y
				    :attachment-x (if (minusp x) :right :left)
				    :attachment-y :center))))))))

;;;; Timing runs.

(defvar *static-timing-window* (tv:make-window 'tv:window
					       :name "Static timing window"))
(defvar *dynamic-timing-window* (tv:make-window 'dw:dynamic-window
						:name "Dynamic timing window"))

(defvar *message-drawing-times-templates*
  '(((:draw-point 100 100)
     (graphics:draw-point 100 100))

    ((:draw-line 10 10 110 10)
     (graphics:draw-line 10 10 110 10)
     (:draw-line 10 10 10 110)
     (graphics:draw-line 10 10 10 110)
     (:draw-line 10 10 110 110)
     (graphics:draw-line 10 10 110 110)
     (:draw-line -3 -10 25 57)
     (graphics:draw-line -3 -10 25 57))

    ((:draw-dashed-line 10 10 110 10)
     (graphics:draw-line 10 10 110 10 :dashed t)
     (:draw-dashed-line 10 10 10 110)
     (graphics:draw-line 10 10 10 110 :dashed t)
     (:draw-dashed-line 10 10 110 110)
     (graphics:draw-line 10 10 110 110 :dashed t))

    ((:draw-lines :draw 100 100 100 200 200 200 200 100 100 100)
     (graphics:draw-lines (100 100 100 200 200 200 200 100 100 100)))
    ((:draw-lines :draw 200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100
			200 100)
     (:draw-curve #(200 100 100 200 300 400 400 300 200)
		  #(100 200 300 400 400 300 200 100 100))
     (:draw-closed-curve #(200 100 100 200 300 400 400 300)
			 #(100 200 300 400 400 300 200 100))
     (graphics:draw-lines (200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100
			       200 100))
     (graphics:draw-lines (200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100)
			  :closed t))

    ((:draw-rectangle 100 100 10 10)
     (graphics:draw-rectangle 10 10 110 110))

    ((:draw-triangle 0 100 200 100 100 20)
     (graphics:draw-triangle 0 100 200 100 100 20))

    ((:draw-circle 100 100 20)
     (graphics:draw-circle 100 100 20 :filled nil))
    ((:draw-circular-arc 100 100 20 0.0 1.0)
     (graphics:draw-circle 100 100 20 :filled nil :end-angle 1.0))
    ((:draw-filled-in-circle 100 100 20)
     (graphics:draw-circle 100 100 20)
     (graphics:draw-circle 100.5 100.5 20.5))
    ((:draw-filled-in-sector 100 100 20 0.0 1.0)
     (graphics:draw-circle 100 100 20 :end-angle 1.0))
    ((:draw-ring 100 100 20 40)
     (graphics:draw-circle 100 100 40 :inner-radius 20))
    ((:draw-simple-ellipse 100 100 40 20)
     (graphics:draw-ellipse 100 100 40 20 :filled nil))
    ((:draw-filled-in-simple-ellipse 100 100 40 20)
     (graphics:draw-ellipse 100 100 40 20))

    ((:draw-polygon :draw 200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100
		    200 100)
     (graphics:draw-polygon (200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100
			     200 100))
     (:draw-convex-polygon :draw 200 100 100 200 100 300 200 400 300 400 400 300 400 200
			   300 100 200 100)
     (graphics:draw-polygon (200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100
				 200 100)
			    :points-are-convex-p t))

    ((:draw-regular-polygon 100 100 200 100 5)
     (graphics:draw-regular-polygon 100 100 200 100 5))

    ((:draw-wide-curve #(100 100 200 200 100) #(100 200 200 100 100) 10)
     (graphics:draw-lines (100 100 100 200 200 200 200 100 100 100) :thickness 10))
    ((:draw-wide-curve #(200 100 100 200 300 400 400 300 200)
		       #(100 200 300 400 400 300 200 100 100) 10)
     (graphics:draw-lines (200 100 100 200 100 300 200 400 300 400 400 300 400 200 300 100
			   200 100)
			  :thickness 10))

    ((:draw-cubic-spline #(200 100 100 200 300 400 400 300)
			 #(100 200 300 400 400 300 200 100)
			 20)
     (graphics:draw-cubic-spline (200 100 100 200 100 300 200 400 300 400 400 300 400 200
				  300 100)))

    ))

(defvar *option-drawing-times-templates*
  '(((graphics:draw-line 10 10 110 10)
     ((graphics:draw-line 10 10 110 10) :thickness (0 1 2 10)))
    ((graphics:draw-line 10 10 10 110)
     ((graphics:draw-line 10 10 10 110) :thickness (0 1 2 10)))
    ((graphics:draw-line 10 10 110 110)
     ((graphics:draw-line 10 10 110 110) :thickness (0 1 2 10)))

    ((graphics:draw-rectangle 210 210 310 310)
     ((graphics:draw-rectangle 0 0 100 100 :translation (200 200))
      :scale-x (1 2) :rotation (0 1)))

    ((graphics:draw-triangle 0 100 200 100 100 20))
    ((graphics:draw-regular-polygon 100 100 200 100 5))

    ((graphics:draw-circle 200 200 20)
     ((graphics:draw-circle 0 0 20 :translation (200 200))
      :scale-x (1 2) :rotation (0 1)))
    ((graphics:draw-circle 200 200 20 :filled nil)
     ((graphics:draw-circle 0 0 20 :filled nil :translation (200 200))
      :scale-x (1 2) :rotation (0 1)))

    (((graphics:draw-cubic-spline (200 100 100 200 100 300 200 400 300 400 400 300 400 200
				   300 100 200 100)
				  :start-relaxation :cyclic)
      :thickness (0 1 2 10)))
    ))

(defun collect-drawing-times-table (templates
				    &key operations
					 (drawing-mode :alternate) (coordinate-mode :exact)
					 (pause-p nil))
  (loop for template in templates
	when (or (null operations)
		 (member (caar template) operations))
	  collect (loop for template in template
			with (operation arguments optionals)
			do (if (consp (first template))
			       (setf `((,operation . ,arguments) . ,optionals) template)
			       (setf `(,operation . ,arguments) template))
			nconc (labels ((collect-with-more-optionals (arguments optionals)
					 (if (null optionals)
					     (ncons (collect-drawing-times-row
						      operation arguments
						      :drawing-mode drawing-mode
						      :coordinate-mode coordinate-mode
						      :pause-p pause-p))
					     (destructuring-bind (keyword values . rest)
						 optionals
					       (loop for value in values
						     append (collect-with-more-optionals
							      `(,@arguments ,keyword ,value)
							      rest))))))
				(collect-with-more-optionals arguments optionals)))))

(defun collect-drawing-times-row (operation arguments
				  &key (drawing-mode :alternate)
				       (coordinate-mode :exact)
				       (pause-p nil))
  (flet ((operation-compatible-with-mode-p (operation mode)
	   (or (not (keywordp operation))
	       (neq mode :with-room))))
    `((,operation . ,arguments)
      . ,(cond ((eq drawing-mode :alternate)
		(loop for mode in '(:static :dynamic :own-coordinates :with-room)
		      collect (and (operation-compatible-with-mode-p operation mode)
				   (collect-drawing-time operation arguments :drawing-mode mode
							 :coordinate-mode coordinate-mode
							 :pause-p pause-p))))
	       ((eq coordinate-mode :alternate)
		(loop for mode in '(:exact :integer :center)
		      collect (collect-drawing-time operation arguments
						    :drawing-mode drawing-mode
						    :coordinate-mode mode
						    :pause-p pause-p)))
	       (t
		(ncons (collect-drawing-time operation arguments
						    :drawing-mode drawing-mode
						    :coordinate-mode coordinate-mode
						    :pause-p pause-p)))))))

(defun collect-drawing-time (operation arguments
			     &key (drawing-mode :static) (coordinate-mode :exact)
				  (pause-p t))
  (let ((function (compile nil `(lambda (stream)
				  ,(if (keywordp operation)
				       `(send stream ,operation . ,arguments)
				       `(,operation
					 ,@(map 'list
						#'(lambda (thing)
						    (if (consp thing)
							`',thing
							thing))
						arguments)
					 :stream stream))))))
    (labels ((time-it (stream)
	       (if (eq coordinate-mode :exact)
		   (time-it-1 stream)
		   (graphics:with-coordinate-mode (stream coordinate-mode)
		     (time-it-1 stream))))
	     (time-it-1 (stream)
	       (without-interrupts
		 (dotimes (i 5)
		   (funcall function stream))
		 (let ((start-time (sys:%microsecond-clock)))
		   (dotimes (i 10)
		     (funcall function stream))
		   (let ((end-time (sys:%microsecond-clock)))
		     (floor (time-difference end-time start-time) 10))))))
      (let ((stream (if (eq drawing-mode :static)
			*static-timing-window*
			*dynamic-timing-window*)))
	(tv:window-call (stream :deactivate)
	  (send stream (if (eq drawing-mode :static) :clear-window :clear-history))
	  (multiple-value-prog1
	    (ecase drawing-mode
	      ((:static :dynamic)
	       (time-it stream))
	      ((:own-coordinates)
	       (dw:with-own-coordinates (stream)
		 (time-it stream)))
	      ((:with-room)
	       (graphics:with-room-for-graphics (stream 500)
		 (time-it stream))))
	    (when pause-p
	      (read-char stream))))))))

(defun format-drawing-times-table (table &optional (columns-mode :drawing-mode))
  (fresh-line)
  (formatting-table ()
    (ecase columns-mode
      (:drawing-mode
	(formatting-column-headings ()
	  "Method"
	  "Static"
	  "Dynamic"
	  (formatting-cell ()
	    (with-character-size (:smaller)
	      (prin1 'dw:with-own-coordinates)))
	  (formatting-cell ()
	    (with-character-size (:smaller)
	      (prin1 'graphics:with-room-for-graphics)))))
      (:coordinate-mode
	(formatting-column-headings () "Function" "Exact" "Integer" "Center")))
    (dolist (result table)
      (let ((nominal-time (second (first result))))
	(dolist (entry result)
	  (formatting-row ()
	    (formatting-cell ()
	      (with-character-size (:smaller)
		(let ((gprint:*overriding-line-length* 75))
		  (write (first entry) :level 1))))
	    (dolist (time (cdr entry))
	      (formatting-cell ()
		(if (null time)
		    (write-string "n/a")
		    (print-time-and-nominal-fraction time nominal-time)))))))
      (formatting-row ()
	(formatting-cell ()
	  (princ " "))))))

;;; This doesn't do too good, because there's no way to get a smaller lisp font.
(defun format-drawing-times-table-for-sage (table stream
					    &optional (columns-mode :drawing-mode))
  (fresh-line)
  (ecase columns-mode
    (:drawing-mode
      (dolist (tag '("Method" "Static" "Dynamic"))
	(write-string tag stream)
	(write-char #\editor-symbols:tab stream))
      (with-character-style ('(nil sage::lisp nil) stream)
	(write-string "dw:with-own-coordinates" stream))
      (terpri stream)
      (dolist (tag '("" "" "" ""))
	(write-string tag stream)
	(write-char #\editor-symbols:tab stream))
      (with-character-style ('(nil sage::lisp nil) stream)
	(write-string "graphics:with-room-for-graphics" stream)))
    (:coordinate-mode
      (dolist (tag '("Function" "Exact" "Integer" "Center"))
	(write-string tag stream)
	(write-char #\editor-symbols:tab stream))))
  (terpri stream)
  (dolist (result table)
    (let ((nominal-time (second (first result))))
      (dolist (entry result)
	(with-character-style ('(nil sage::lisp nil) stream)
	  (let ((*print-case* :downcase)
		(*print-pretty* nil)
		(*print-array* t))
	    (filling-output (stream :fill-column (* 70 (or (send-if-handles stream :char-width)
							   1))
				    :after-line-break "  ")
	      (prin1 (first entry) stream))))
	(terpri stream)
	(dolist (time (cdr entry))
	  (write-char #\editor-symbols:tab stream)
	  (if (null time)
	      (write-string "n/a" stream)
	      (print-time-and-nominal-fraction time nominal-time stream)))
	(terpri stream)))
    (terpri stream)))

(defun print-time-and-nominal-fraction (time nominal-time &optional (stream *standard-output*))
  (prin1 time stream)
  (unless (= time nominal-time)
    (write-string " (" stream)
    (let ((fract (/ time nominal-time)))
      (cond ((> fract 10)
	     (format stream "~D" (round fract)))
	    ((> fract 1)
	     (format stream "~1$" fract))
	    ((> fract .01)
	     (format stream "~$" fract))
	    (t
	     (prin1 fract stream))))
    (write-string ")" stream)))
