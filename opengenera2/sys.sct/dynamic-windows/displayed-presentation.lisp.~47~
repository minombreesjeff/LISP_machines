;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defmacro coordinate-convert-points (window to-what where &rest points)
  `(progn
     . ,(loop for (x y) on points by 'cddr
	      collect `(multiple-value-setq (,x ,y)
			 (send ,window (ecase ,to-what
					 (:absolute :convert-to-absolute-coordinates)
					 (:relative :convert-to-relative-coordinates))
			       ,x ,y ,where)))))

(defflavor viewport
	((displayed-x-position 0)
	 (displayed-y-position 0)
	 (separator-displayed nil))
	(box)
  (:constructor make-viewport
		(left top right bottom
		      &optional (displayed-x-position 0) (displayed-y-position 0)))
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (set-viewport-displayed-position viewport) (x y)
  (setq displayed-x-position x
	displayed-y-position y))

(defmethod (viewport-displayed-offsets viewport) ()
  (values (- left displayed-x-position)
	  (- top displayed-y-position)))

(defmethod (viewport-displayed-right viewport) ()
  (+ displayed-x-position (- right left)))

(defmethod (viewport-displayed-bottom viewport) ()
  (+ displayed-y-position (- bottom top)))

;;; Clip so as to only draw within the viewport so that scrolling doesn't leave turds.
;;; We cannot just change the inside size to be the same, because it would then only
;;; get smaller as we reshaped.
;;; Don't need to change left and top margins because we have already accounted for
;;; non top viewports via coordinate transformation and these messages don't allow
;;; negative numbers.
(defmacro with-viewport-margins ((&optional (viewport
					      '(or secondary-viewport cursor-viewport)))
				 &body body
				 &environment env)
  (once-only (viewport &environment env)
    `(letf ((tv:right-margin-size (max tv:right-margin-size
				       (- tv:width
					  (+ tv:left-margin-size
					     (viewport-displayed-right ,viewport)))))
	    (tv:bottom-margin-size (max tv:bottom-margin-size
					(- tv:height
					   (+ tv:top-margin-size
					      (viewport-displayed-bottom ,viewport))))))
       . ,body)))

(defmacro with-integral-bottom-margin (&body body)
  `(letf ((original-bottom-margin (or original-bottom-margin tv:bottom-margin-size))
	  (tv:bottom-margin-size (max tv:bottom-margin-size
				      (- tv:height
					 (+ tv:top-margin-size
					    (if secondary-viewport
						(viewport-integral-height)
						(viewport-displayed-bottom
						  cursor-viewport)))))))
     . ,body))

(defflavor displayed-presentation
	(;(viewport nil)		;Into our own inferiors, not used yet.
	 (highlighting-boxes nil)
	 displayed-box
	 (flag-word 0))
	(presentation)
  :initable-instance-variables
  (:readable-instance-variables (presentation-displayed-box displayed-box)
				(presentation-flags flag-word))
  (:writable-instance-variables highlighting-boxes)
  (:init-keywords :single-box :displayed-box-valid
		  :allow-sensitive-inferiors :allow-sensitive-raw-text
		  :redisplay-place-holder :check-type)
  (:constructor make-displayed-presentation-1 (object type superior displayed-box))
  (:default-init-plist :area *presentation-area*))

(defun make-displayed-presentation (&rest options)
  (apply #'make-instance 'displayed-presentation options))

;; Macro to defines bits within the presentation's flag-word
(defvar *presentation-flag-names* ())

(defmacro define-presentation-boolean (name bit-number
				       &optional (flavor 'displayed-presentation))
  #|| ;;This check confuses compile-time with load-time.
  (let ((old (find bit-number *presentation-flag-names* :key #'second)))
    (when (and old (neq name (car old)))
      (cerror "Redefine the bit to have the new name"
	      "You are trying to define bit ~D as ~S~%when it is already defined as ~S"
	      bit-number name (car old))))
  ||#
  (let ((method-name (fintern "~A-~A" flavor name)))
    `(progn
       (defmethod (,method-name ,flavor) ()
	 (declare (sys:function-parent ,name define-presentation-boolean))
	 (ldb-test (byte 1 ,bit-number) flag-word))
       (defmethod ((setf ,method-name) ,flavor) (new-value)
	 (declare (sys:function-parent ,name define-presentation-boolean))
	 (setf (ldb-test (byte 1 ,bit-number) flag-word) new-value)
	 new-value)
       (pushnew (list ',name ,bit-number)
		*presentation-flag-names*
		:key #'first :replace t))))

(defun describe-presentation-booleans (thing)
  (flet ((doit (integer)
	   (if (zerop integer)
	       (format T "(none)")
	     (loop with first = T
		   for bit-number from 0
		   for n = integer then (ash n -1)
		   until (zerop n)
		   when (oddp n)
		     do (let ((name (first (find bit-number *presentation-flag-names*
						 :key #'second :test #'=))))
			  (if first (setq first nil) (format t ", "))
			  (if name
			      (format t "~@(~A~)" name)
			    (format t "<~D>" bit-number)))))))
    (etypecase thing
      ((and integer (not (satisfies minusp)))
       (doit thing))
      (displayed-presentation
	(doit (presentation-flags thing))))))

(defmethod (:describe displayed-presentation :after) ()
  (format t "~&  Flags (#o~O) decode as " flag-word)
  (describe-presentation-booleans self))

(define-presentation-boolean single-box 0 displayed-presentation)
(define-presentation-boolean allow-sensitive-inferiors 1 displayed-presentation)
(define-presentation-boolean displayed-box-valid 2 displayed-presentation)
(define-presentation-boolean allow-sensitive-raw-text 3 displayed-presentation)
(define-presentation-boolean redisplay-place-holder 4 displayed-presentation)
(define-presentation-boolean shares-superiors-boxes 5 displayed-presentation)
(define-presentation-boolean shares-superiors-boxes-valid 6 displayed-presentation)

(defmethod (make-instance displayed-presentation) (&key (single-box nil)
							(allow-sensitive-inferiors t)
							(displayed-box-valid nil)
							(allow-sensitive-raw-text t)
							(redisplay-place-holder nil)
						   &allow-other-keys)
  (setf (displayed-presentation-single-box self) single-box)
  (setf (displayed-presentation-allow-sensitive-inferiors self) allow-sensitive-inferiors)
  (setf (displayed-presentation-displayed-box-valid self) displayed-box-valid)
  (setf (displayed-presentation-allow-sensitive-raw-text self) allow-sensitive-raw-text)
  (setf (displayed-presentation-redisplay-place-holder self) redisplay-place-holder))

;;; Minimal
(defmethod (presentation-set-displayed-box displayed-presentation) (new-box
								     &optional mark-table)
  (when (cond ((null mark-table) t)
	      ((gethash self mark-table) nil)
	      (t (setf (gethash self mark-table) t) t))
    (multiple-value-bind (delta-x delta-y)
	(box-position-deltas new-box displayed-box)
      (unless (and (zerop delta-x) (zerop delta-y))
	(dolist (inf inferiors)
	  (presentation-set-displayed-box inf
					  (let ((box (presentation-displayed-box inf)))
					    (box-copy-with-offsets box delta-x delta-y
								   :area (%area-number box)))
					  mark-table))))
    (setq displayed-box new-box)))

(defmethod (extend-presentation-displayed-box displayed-presentation) (left top right bottom)
  (minf (box-left displayed-box) left)
  (minf (box-top displayed-box) top)
  (maxf (box-right displayed-box) right)
  (maxf (box-bottom displayed-box) bottom)
  (dolist (inferior inferiors)
    (extend-presentation-displayed-box inferior left top right bottom)))

;PRESENTATION-VISIBLE-BOXES-STACK-LIST does something like PRESENTATION-MOUSE-SENSITIVE-BOXES,
;except without a window and without consing.
;This default method gives an empty list.
(defmethod (presentation-visible-boxes-stack-list presentation) (funarg)
  (declare (sys:downward-funarg funarg))
  (funcall funarg nil))

(defmethod (presentation-visible-boxes-stack-list displayed-presentation) (funarg)
  (declare (sys:downward-funarg funarg))
  (if (or (displayed-presentation-single-box self) (null inferiors))
      (stack-let ((list (list displayed-box)))
	(funcall funarg list))
    (stack-let ((array (zl:make-array (* (list-length inferiors) 2)	;initial guess
				      :type art-q-list :fill-pointer 0)))
      (dolist (presentation inferiors)
	(presentation-visible-boxes-stack-list presentation
	   (lambda (list)
	     (dolist (box list)
	       (vector-push-extend box array)))))
      (funcall funarg (g-l-p array)))))

;;--- Does anything (like box-moving in redisplay) need to flush this cache?
(defmethod (presentation-shares-superiors-boxes displayed-presentation) (super)
  (if (displayed-presentation-shares-superiors-boxes-valid self)
      (displayed-presentation-shares-superiors-boxes self)
    (setf (displayed-presentation-shares-superiors-boxes-valid self) t)
    (setf (displayed-presentation-shares-superiors-boxes self)
	  (presentation-visibly-equal self super))))

;;; Do this (superior) displayed object occupy the same box?
(defmethod (presentation-visibly-equal displayed-presentation) (other-displayed-presentation)
  (and ;; Same bounding box (test this first because it is fast)
       (box-equal displayed-box (presentation-displayed-box other-displayed-presentation))
       ;; Same mouse-sensitive-boxes inside the bounding box
       (presentation-visible-boxes-stack-list other-displayed-presentation
	 (lambda (other-list)
	   (presentation-visible-boxes-stack-list self
	     (lambda (list)
	       (equal list other-list)))))))

(defmethod (presentation-at-position displayed-presentation)
	   (window x y &optional eol-p (allow-raw-text t))
  (if (> y (box-bottom displayed-box))
      (values nil t)
      (when (box-contains-point-p displayed-box x y)
	(or (if (displayed-presentation-allow-sensitive-inferiors self)
		(if (and allow-raw-text
			 (displayed-presentation-allow-sensitive-raw-text self))
		    ;; Allow access to inferior presentations of all sorts.
		    ;; No need to pass on allow-raw-text, since it's true.
		    (let ((best nil)
			  (best-priority nil))
		      (dolist (presentation inferiors)
			(let ((offer (presentation-at-position presentation window x y eol-p)))
			  (when offer
			    (let ((priority (graphics-displayed-presentation-priority
					      presentation)))
			      (when (null priority)
				(setq best offer)
				(return))
			      (when (or (null best-priority) (> priority best-priority))
				(setq best offer
				      best-priority priority))))))
		      best)
		    ;; Don't allow access to the text of some presentations.  This prevents
		    ;; the consing of all the single-character raw-text presentations while
		    ;; you wave the mouse around.
		    (let ((best nil)
			  (best-priority nil))
		      (dolist (presentation inferiors)
			(if (presentation-anonymous-p presentation)
			    ;; Anonymous.  Rather than returning a piece of text within
			    ;; it, return ourselves if within it.
			    (when (position-inside-presentation presentation x y)
			      (let ((priority (graphics-displayed-presentation-priority
						presentation)))
				;; Not graphics, use self right away.
				(when (null priority)
				  (setq best self)
				  (return))
				;; Graphics, use other inferior if any, else self at end.
				(when (or (null best-priority) (> priority best-priority))
				  (setq best self
					best-priority priority))))
			    ;; Non anonymous, try to find something within it.
			    (let ((offer (presentation-at-position presentation window x y
								   eol-p allow-raw-text)))
			      (when offer
				(let ((priority (graphics-displayed-presentation-priority
						  presentation)))
				  (when (null priority)
				    (setq best offer)
				    (return))
				  (when (or (null best-priority) (> priority best-priority))
				    (setq best offer
					  best-priority priority)))))))
		      best))
	        (if (and allow-raw-text
			 (displayed-presentation-allow-sensitive-raw-text self))
		    ;; Allow access to text but not to other presentations.
		    (loop for presentation in inferiors
			  when (presentation-anonymous-p presentation)
			    thereis (presentation-at-position presentation window x y eol-p))
		    ;; Both nil -- never allow inferiors to supersede self
		    (loop for presentation in inferiors
			  when (position-inside-presentation presentation x y)
			    return self)))
	    ;; Didn't find anything in an inferior.  If we are declared to have the whole box,
	    ;; return ourselves.  Otherwise, only if we have no inferiors.  If we have
	    ;; inferiors, then they should have picked up the ball unless we are in the part
	    ;; of the box which doesn't actually have text, due to a newline in the middle
	    ;; of the presentation in TTY mode.
	    (and (or (displayed-presentation-single-box self) (null inferiors))
		 self)))))

(defmethod (position-inside-presentation displayed-presentation) (x y)
  (box-contains-point-p displayed-box x y))

;;; Blinker boxes are constructed in outside coordinates.
(defun displayed-box-mouse-sensitive-boxes (displayed-box window &optional vsp-adjust)
  (let ((viewport (send window :viewport-containing-box displayed-box)))
    (multiple-value-bind (viewport-left viewport-top viewport-right viewport-bottom)
	(box-edges viewport)
      (multiple-value-bind (left top right bottom)
	  (box-edges displayed-box)
	(unless (or (< right viewport-left)
		    (< bottom viewport-top)
		    (> left viewport-right)
		    (> top viewport-bottom))
	  (when vsp-adjust
	    (decf bottom (send window :vsp)))
	  (let ((margin-left-adjust (tv:sheet-left-margin-size window))
		(margin-top-adjust (tv:sheet-top-margin-size window)))
	    (multiple-value-bind (viewport-x-offset viewport-y-offset)
		(viewport-displayed-offsets viewport)
	      `((,(+ (max 0 (- left viewport-x-offset)) margin-left-adjust)
		 ,(+ (max 0 (- top viewport-y-offset)) margin-top-adjust)
		 ,(+ (- (min right viewport-right) viewport-x-offset) margin-left-adjust)
		 ,(+ (- (min bottom viewport-bottom) viewport-y-offset) margin-top-adjust)
		 )))))))))

;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")defsubst0 so it could be used with 1stack-let0, if desired, maybe.
(defsubst make-fast-eq-cache (&optional (size 25))
  (make-array (* size 2) :fill-pointer 0))

(defun fast-eq-cache (cache key)
  (let* ((start (locf (aref cache 0)))
	 (length (vector-length cache)))
    (if (not (and ( length 0)
		  ( length (array-total-size cache))
		  (evenp length)))
	(error "~S is a bogus cache." cache)
      (loop for ptr = (%block-search-eq key start length)
	    while ptr
	    do
	(if (evenp (%pointer-difference ptr start))
	    (return (values (%p-contents-offset ptr 1) t))
	  (setq length (- length (%pointer-difference ptr start) 1)
		start (%make-pointer-offset dtp-locative ptr 1)))))))

(defsetf fast-eq-cache store-fast-eq-cache)

(defun store-fast-eq-cache (cache key value)
  (without-interrupts
    (let* ((start (locf (aref cache 0)))
	   (length (vector-length cache))
	   (total (array-total-size cache)))
      (if (not (and ( length 0)
		    ( length (array-total-size cache))
		    (evenp length)
		    (evenp total)))
	  (error "~S is a bogus cache." cache)
	  (if (< length total)
	      (progn (vector-push key cache)
		     (vector-push value cache)))
	  (%block-gc-copy (%make-pointer-offset dtp-locative start 2)
			  start (- length 2))
	  (setf (aref cache (- total 2)) key
		(aref cache (- total 1)) value)))))

(defvar *fast-sensitive-boxes-function-cache* (make-fast-eq-cache))

(defmethod (presentation-mouse-sensitive-boxes displayed-presentation)
	   (window &optional (vsp-adjust t))
  (cond (highlighting-boxes
	 (if (eq highlighting-boxes :inverse-video)
	     (multiple-value-bind (boxes lines)
		 (letf ((highlighting-boxes nil))
		   (presentation-mouse-sensitive-boxes self window vsp-adjust))
	       ;; Make the hollow boxes solid.
	       (values nil lines boxes))
	     (highlighting-boxes-mouse-sensitive-boxes highlighting-boxes
						       displayed-box window)))
	;; There was fast-eq-caching going on here.  Diked out for the moment,
	;; since it now needs to remember the presentation-types.  It's not clear
	;; whether it's worth putting it back in.  Maybe later.
	((with-type-method ((real-pres-type highlighting-box-function)
			    type #'presentation-type-find-highlighting-box-function
			    :error-p nil)
	   #+++ignore		;don't cache if we're never going to use it
	   (setf (fast-eq-cache *fast-sensitive-boxes-function-cache* type)
		 highlighting-box-function)
	   (return-from presentation-mouse-sensitive-boxes
	     (highlighting-boxes-mouse-sensitive-boxes
	       (setq highlighting-boxes		;cache them for next time
		     (computing-outline-from-path (window :filled-allowed t)
		       (funcall highlighting-box-function
				window self
				(box-left displayed-box) (box-top displayed-box)
				real-pres-type type)))
	       displayed-box window))))
	((or (displayed-presentation-single-box self) (null inferiors))
	 (displayed-box-mouse-sensitive-boxes displayed-box window vsp-adjust))
	((null (rest inferiors))
	 (presentation-mouse-sensitive-boxes (first inferiors) window vsp-adjust))
	(t
	 (setq vsp-adjust
	       (and vsp-adjust
		    (multiple-value-bind (nil first-top nil first-bottom)
			(box-edges (presentation-displayed-box (first inferiors)))
		      (loop for presentation in (rest inferiors)
			    always (multiple-value-bind (nil next-top nil next-bottom)
				       (box-edges (presentation-displayed-box presentation))
				     (and (= next-top first-top)
					  (= next-bottom first-bottom)))))))
	 (loop for presentation in inferiors
	       with (boxes lines)
	       do (multiple-value-setq (boxes lines)
		    (presentation-mouse-sensitive-boxes presentation window vsp-adjust))
	       append boxes into all-boxes
	       append lines into all-lines
	       finally (return (values all-boxes all-lines))))))

(defun highlighting-boxes-mouse-sensitive-boxes (refined-boxes displayed-box window)
  (declare (values hollow-boxes slanted-lines solid-boxes))
  (let ((viewport (send window :viewport-containing-box displayed-box)))
    (multiple-value-bind (viewport-left viewport-top viewport-right viewport-bottom)
	(box-edges viewport)
      (multiple-value-bind (viewport-x-offset viewport-y-offset)
	  (viewport-displayed-offsets viewport)
	(destructuring-bind (&key boxes lines (hollow-boxes boxes) solid-boxes) refined-boxes
	  (flet ((offset-boxes (boxes)
		   (let ((margin-left-adjust (tv:sheet-left-margin-size window))
			 (margin-top-adjust (tv:sheet-top-margin-size window)))
		     (loop for (left top right bottom) in boxes
			   unless (or (< right viewport-left)
				      (< bottom viewport-top)
				      (> left viewport-right)
				      (> top viewport-bottom))
			     collect
			       (list (+ (max 0 (- left viewport-x-offset)) margin-left-adjust)
				     (+ (max 0 (- top viewport-y-offset)) margin-top-adjust)
				     (+ (- (min right viewport-right) viewport-x-offset)
					margin-left-adjust)
				     (+ (- (min bottom viewport-bottom) viewport-y-offset)
					margin-top-adjust))))))
	    (values
	      (offset-boxes hollow-boxes)
	      (loop for (x1 y1 x2 y2) in lines
		    when (multiple-value-setq (x1 y1 x2 y2)
			   (tv:clip-and-offset-line-internal window
							     (- x1 viewport-x-offset)
							     (- y1 viewport-y-offset)
							     (- x2 viewport-x-offset)
							     (- y2 viewport-y-offset)))
		      collect (list x1 y1 x2 y2))
	      (offset-boxes solid-boxes))))))))

;;; AT-END is an optimization for normal style output.  It means the
;;; presentation can only be at the front of the inferiors list if
;;; anywhere.  This is not true when re-presenting.
(defmethod (displayed-presentation-add-inferior displayed-presentation)
	   (inferior &optional (at-end t))
  (unless (if at-end
	      (eql inferior (first inferiors))
	      (member inferior inferiors))
    (setq inferiors (cons-in-area inferior inferiors *presentation-area*))
    (setf (displayed-presentation-displayed-box-valid self) nil)))

(defmethod (displayed-presentation-delete-inferior displayed-presentation) (inferior)
  (setq inferiors (delete inferior inferiors))
  (setf (displayed-presentation-displayed-box-valid self) nil))

(defmethod (update-displayed-presentation-box displayed-presentation) ()
  (unless (displayed-presentation-displayed-box-valid self)
    (when inferiors
      (let (min-left min-top max-right max-bottom)
	(dolist (presentation inferiors)
	  (multiple-value-bind (left top right bottom)
	      (box-edges (update-displayed-presentation-box presentation))
	    (macrolet ((min-max (type limit-value box-value)
			 `(when (or (null ,limit-value)
				    (,(ecase type
					(min '<)
					(max '>))
				     ,box-value ,limit-value))
			    (setf ,limit-value ,box-value))))
	      (min-max min min-left left)
	      (min-max min min-top top)
	      (min-max max max-right right)
	      (min-max max max-bottom bottom))))
	(set-box-edges displayed-box min-left min-top max-right max-bottom)))
    (setf (displayed-presentation-displayed-box-valid self) t))
  displayed-box)

(defmethod (presentation-near-mode displayed-presentation) (window)
  (multiple-value-bind (left top right bottom)
      (box-edges displayed-box)
    (coordinate-convert-points window :relative :outside left top right bottom)
    (multiple-value-bind (x-off y-off)
	(tv:sheet-mouse-offsets window)
      `(:rectangle ,(+ left x-off) ,(+ top y-off) ,(+ right x-off) ,(+ bottom x-off)))))

;;; This percolates down until it finds a string leaf, which it closes.
(defmethod (displayed-presentation-close-string displayed-presentation)
	   (&optional end-line)
  ;; This knows that only one can be open, and that it will be on the front of the list
  (when inferiors
    (displayed-presentation-close-string (first inferiors) end-line)))

(defmethod (redraw-displayed-presentation displayed-presentation) (window box)
  (with-stack-array (to-draw (length inferiors) :fill-pointer 0)
    (dolist (presentation inferiors)
      (when (boxes-overlap-p (presentation-displayed-box presentation) box)
	(vector-push-extend presentation to-draw)))
    (loop for i downfrom (fill-pointer to-draw) above 0 do
      (redraw-displayed-presentation (aref to-draw (1- i)) window box))))

(defmethod (erase-displayed-presentation displayed-presentation)
	   (window &optional recursive as-single-box (clear-inferiors t))
  (if (or (null inferiors) as-single-box)
      (multiple-value-bind (left top right bottom)
	  (box-edges displayed-box)
	(send window :clear-region left top right bottom))
      (dolist (presentation inferiors)
	(erase-displayed-presentation presentation window t nil clear-inferiors))
      (when clear-inferiors
	(setq inferiors nil)))
  (unless recursive
    (send window :delete-displayed-presentation self)))

;;; This collects text output by :TYO/:STRING-OUT, which has funny shapes because of TTY
;;; style wraparound.  Contrast output by :DRAW-STRING, which is really graphics.
(defflavor displayed-string
	((string nil)
	 displayed-box
	 (highlighted-intervals nil)
	 (baseline nil)
	 (default-character-style nil))
	()
  (:initable-instance-variables string baseline default-character-style displayed-box)
  (:readable-instance-variables string highlighted-intervals
				baseline default-character-style
				(presentation-displayed-box displayed-box))
  (:writable-instance-variables baseline default-character-style)
  (:constructor make-displayed-string-1
		(string baseline default-character-style displayed-box))
  (:default-init-plist :area *presentation-area*))

(defun make-displayed-string (string baseline default-character-style
			      &optional box-left box-top box-right box-bottom window)
  (let ((displayed-box
	  (make-box box-left box-top
		    (or box-right box-left)
		    (or box-bottom (+ box-top
				      (send window :current-line-height)))))
	(baseline
	  (or baseline (send window :current-baseline)))
	(default-character-style
	  (or default-character-style (send window :default-character-style))))
    (make-displayed-string-1 string baseline default-character-style displayed-box)))

(defmethod (make-instance displayed-string) (&rest options)
  (ignore options)
  (unless string
    (setq string (make-array 20. :element-type 'string-char :fill-pointer 0
				 :area *presentation-area*))))

(defmethod (print-self displayed-string) (stream ignore slashify-p)
  slashify-p
  (printing-random-object (self stream :typep)
    (prin1 string stream)))

(defmethod (displayed-string-add-char displayed-string)
	   (char &optional (style si:*null-style*))
  (unless (eq style si:*null-style*)
    (setq char (si:make-merged-char char style)))
  (when (and (not (string-fat-p string))
	     (char-fat-p char))
    (setq string (make-string-fat string)))
  (let ((default-cons-area *presentation-area*))
    (vector-push-extend char string 10.)))

(defmethod (displayed-string-add-string displayed-string)
	   (add-string &optional (start 0) end (style si:*null-style*))
  (when (and (not (string-fat-p string))
	     (or (string-fat-p add-string)
		 (neq style si:*null-style*)))
    (setq string (make-string-fat string)))
  (let ((default-cons-area *presentation-area*))
    (string-nconc-portion-merging-style string add-string start end style)))

(defun make-string-fat (thin-string)
  (let ((fat-string (make-array (sys:array-length thin-string)
				:element-type 'character :area (%area-number thin-string)
				:leader-length (array-leader-length thin-string))))
    (copy-array-contents-and-leader thin-string fat-string)
    (structure-forward thin-string fat-string)
    fat-string))

(defmethod (displayed-string-note-new-right displayed-string) (new-right)
  (setf (box-right displayed-box) (max (box-right displayed-box) new-right)))

;;; Messages that are part of the protocol shared between displayed strings and displayed
;;; presentations.

(defmacro with-displayed-string-baseline ((window displayed-string) &body body)
  `(letf (((tv:sheet-line-height ,window)
	   (box-height (presentation-displayed-box ,displayed-string)))
	  ((tv:sheet-baseline ,window) (displayed-string-baseline ,displayed-string))
	  ((tv:sheet-current-baseline ,window) (displayed-string-baseline ,displayed-string))
	  ((tv:sheet-default-style ,window)
	   (displayed-string-default-character-style ,displayed-string)))
     . ,body))

(defmethod (redraw-displayed-presentation displayed-string) (window box)
  (with-displayed-string-baseline (window self)
    (send window :string-out-explicit-within-boxes string displayed-box box)
    (when highlighted-intervals
      (send window :highlight-string-intervals string highlighted-intervals
					       displayed-box box))))

(defun displayed-box-contains-point-p (displayed-box x y window eol-p)
  (if eol-p
      (and ( y (box-top displayed-box))
	   (< y (box-bottom displayed-box))
	   ( x (box-right displayed-box))
	   (< x (+ (box-right displayed-box) (send window :char-width))))
      (box-contains-point-p displayed-box x y)))

(defmethod (presentation-at-position displayed-string) (window x y &optional eol-p ignore)
  (if (> y (box-bottom displayed-box))
      (values nil t)
      (when (displayed-box-contains-point-p displayed-box x y window eol-p)
	(multiple-value-bind (nx nil index)
	    (send window :compute-motion string 0 nil
		  (box-left displayed-box) (box-top displayed-box) nil
		  x (box-top displayed-box) (box-bottom displayed-box)
		  (box-right displayed-box))
	  (raw-text-presentation-at-index self window
					  (if index
					      (if (= x nx) index (max 0 (1- index)))
					      (string-length string)))))))

(defmethod (raw-text-presentation-at-index displayed-string) (window index)
  ;; Generate the new box and presentation in WORKING-STORAGE-AREA so that
  ;; the EGC can clean it up quickly.
  (let* ((box (copy-box displayed-box :area working-storage-area))
	 (presentation (make-text-displayed-presentation-2
			 box self index (1+ index) (list string index) 'raw-text
			 :area working-storage-area)))
    (let* ((left (send window :compute-motion string 0 index (box-left box) nil))
	   (right (if (= index (fill-pointer string))
		      (+ left (send window :char-width))
		    (send window :compute-motion string index (1+ index) left nil))))
      (setf (box-left box) left)
      (setf (box-right box) right))
    presentation))

(defmethod (position-inside-presentation displayed-string) (x y)
  (box-contains-point-p displayed-box x y))

(defmethod (set-displayed-string-highlighted-intervals displayed-string)
	   (intervals window)
  (tv:sheet-force-access (window :no-prepare)
    (with-displayed-string-baseline (window self)
      (when highlighted-intervals
	;; Erase old
	(send window :highlight-string-intervals string highlighted-intervals displayed-box))
      (when intervals
	;; Draw new
	(send window :highlight-string-intervals string intervals displayed-box))))
  (setq highlighted-intervals intervals))

;;; Compatibility only.
(defun output-displayed-strings-as-text (stream window)
  (output-output-history-as-text window stream))

(defgeneric output-output-history-as-text (window &optional (stream *standard-output*))
  (:method-arglist (stream))
  (:function (funcall (flavor:generic output-output-history-as-text) window stream)))

(defmethod (output-output-history-as-text dynamic-window) (stream)
  (let* ((last-x nil)
	 (last-y nil)
	 (last-baseline nil)
	 (n-strings (zl:array-active-length displayed-strings)))
    (with-stack-array (sorted-strings n-strings
				      :fill-pointer n-strings
				      :initial-contents displayed-strings)
      ;; We can't destructively sort the displayed-strings array since DW needs
      ;; it in the order it is currently in, so sort a copy of it instead.
      (setq sorted-strings (sort-displayed-strings sorted-strings))
      (loop for displayed-string being the array-elements of sorted-strings doing
	(multiple-value-setq (last-x last-y last-baseline)
	  (output-displayed-string-as-text displayed-string stream self
					   last-x last-y last-baseline))))))

(defun sort-displayed-strings (strings
			       &optional (n-strings (zl:array-active-length strings)))
  (let ((strings strings))
    (declare (sys:array-register strings))
    ;; A bubble sort will actually be faster than a quicksort because the
    ;; displayed-strings will be almost sorted, and bubble sort performs
    ;; much better than quicksort on such data (actual measurement shows
    ;; it being about 10 times faster).
    (loop for i downfrom (1- n-strings) to 0 
	  as swapped-one = nil
	  do (loop for j below i doing
	       (unless (displayed-string-precedes (aref strings j) (aref strings (1+ j)))
		 (rotatef (aref strings j) (aref strings (1+ j)))
		 (setq swapped-one t)))
	  while swapped-one)
    strings))

(defun displayed-string-precedes (string-1 string-2)
  (multiple-value-bind (x1 y1)
      (box-edges (presentation-displayed-box string-1))
    (multiple-value-bind (x2 y2)
	(box-edges (presentation-displayed-box string-2))
      (let ((baseline-1 (displayed-string-baseline string-1))
	    (baseline-2 (displayed-string-baseline string-2)))
	(if (= (+ y1 baseline-1) (+ y2 baseline-2))
	    (< x1 x2)
	  (< (+ y1 baseline-1) (+ y2 baseline-2)))))))

(defparameter *maximum-number-of-yanked-blank-lines* 5)

(defun output-displayed-string-as-text (displayed-string stream window
					last-x last-y last-baseline
					&optional (start 0) end)
  (declare (values right top baseline))
  (multiple-value-bind (left top right)
      (box-edges (presentation-displayed-box displayed-string))
    (let ((string (displayed-string-string displayed-string))
	  (line-height (send window :line-height))
	  (char-width (send window :char-width))
	  (baseline (displayed-string-baseline displayed-string)))
      (unless (zerop start)
	(setq left (send window :compute-motion string 0 start left top)))
      (when (null end)
	(setq end (string-length string)))
      (unless (= end (string-length string))
	(setq right (send window :compute-motion string start end left top)))
      (when (and last-y ( (+ last-y last-baseline) (+ top baseline)))
	(dotimes (i (min (max 1 (round (- top last-y) line-height))
			 *maximum-number-of-yanked-blank-lines*))
	  (declare (ignore i))
	  (send stream :tyo #\Return)
	  (setq last-x 0)))
      (when (and last-x ( last-x left))
	;; Doing floor first, and then subtracting, tends to do the best job of
	;; aligning columns of tables.
	(dotimes (i (max 1 (- (floor left char-width) (floor last-x char-width))))
	  (declare (ignore i))
	  (send stream :tyo #\Space)))
      (send stream :string-out (displayed-string-string displayed-string) start end)
      (values right top baseline))))

(defun displayed-strings-search (key strings window start-index start-position
				 &key from-end listen repeat
				 &aux (listen-time (time:fixnum-microsecond-time)))
  (flet ((listen ()
	   (and listen
		(time-elapsed-p 100000 listen-time (time:fixnum-microsecond-time))
		(setq listen-time (time:fixnum-microsecond-time))
		(send window :listen))))
    ;; If search backwards and :repeat t, key might be found right where we start
    (when (and from-end repeat start-position
	       (eq (text-displayed-presentation-displayed-string start-position)
		   (aref strings start-index))
	       ;; Note that %string-equal returns nil if string is too short
	       (%string-equal key 0 (displayed-string-string (aref strings start-index))
			      (text-displayed-presentation-start-index start-position)
			      (string-length key)))
      (return-from displayed-strings-search (values start-index start-position)))
    ;; Now search in specified direction
    (if from-end
	(loop for dstring being the array-elements of strings
			  using (index dindex)
	      downfrom (if start-position start-index (1- start-index))
	      until (listen)
	      do
	  (let ((index (string-search
			 key (displayed-string-string dstring)
			 :from-end t
			 :end2 (and start-position
				    (eq (text-displayed-presentation-displayed-string
					  start-position)
					dstring)
				    (text-displayed-presentation-start-index
				      start-position)))))
	    (when index
	      (return (values dindex
			      (raw-text-presentation-at-index dstring window index))))))
	(loop for dstring being the array-elements of strings
			  using (index dindex)
	      from start-index
	      until (listen)
	      do
	  (let ((index (string-search
			 key (displayed-string-string dstring)
			 :start2 (if (and start-position
					  (eq (text-displayed-presentation-displayed-string
						start-position)
					      dstring))
				      (+ (text-displayed-presentation-start-index
					   start-position)
					 (if repeat 0 1))
				      0))))
	    (when index
	      (return (values dindex
			      (raw-text-presentation-at-index dstring window index)))))))))

(defstruct (coordinate-sorted-set :named-array-leader
				  (:constructor-make-array-keywords (length 100)))
  (fill-pointer 0)
  (tallest-box-height 0))

(defstruct (displayed-strings-array :named-array-leader
				    (:include coordinate-sorted-set)
				    (:constructor-make-array-keywords (length 100)))
  (region-strings nil))

;;; These are the leaves of the presentation hierarchy for TTY output
;;; Note that they don't have a REDRAW-... method, since text is handled separately as
;;; a whole bunch.
(defflavor text-displayed-presentation
	((object nil)
	 (type 'no-type)
	 displayed-string
	 (start-index 0)
	 (end-index nil))
	(displayed-presentation)
  :initable-instance-variables
  (:constructor make-text-displayed-presentation-1 (superior displayed-string))
  (:constructor make-text-displayed-presentation-2 (displayed-box displayed-string
						    start-index end-index object type
						    &key (area working-storage-area)))
  :readable-instance-variables
  (:writable-instance-variables displayed-string start-index end-index)
  (:default-init-plist :area *presentation-area*))

(defun make-text-displayed-presentation (&rest options)
  (apply #'make-instance 'text-displayed-presentation options))

(defmethod (presentation-anonymous-p text-displayed-presentation) () t)

(defmethod (presentation-present-self text-displayed-presentation)
	   (stream &optional verbose)
  (when verbose
    (format stream "Text "))
  (write-char #\" stream)
  (with-character-size (:smaller stream)
    (let* ((string (displayed-string-string displayed-string))
	   (length (fill-pointer string)))
      (when (> start-index 5)
	(write-string "..." stream))
      (write-string string stream :start (max 0 (- start-index 5)) :end start-index)
      (when (< start-index length)
	(with-character-face (:bold stream)
	  (write-string string stream :start start-index :end end-index))
	(when end-index
	  (write-string string stream
			:start end-index :end (min (+ end-index 5) length))
	  (when (< (+ end-index 5) length)
	    (write-string "..." stream))))))
  (write-char #\" stream))

(defmethod (open-text-displayed-presentation text-displayed-presentation) ()
  (setq start-index (fill-pointer (displayed-string-string displayed-string)))
  (setq displayed-box (let ((box (presentation-displayed-box displayed-string)))
			(copy-box box :area (%area-number box))))
  (setf (box-left displayed-box) (box-right displayed-box)))

(defmethod (displayed-presentation-close-string text-displayed-presentation)
	   (&optional end-line)
  (when (null end-index)
    (let* ((string (displayed-string-string displayed-string))
	   (length (fill-pointer string)))
      (setq end-index length)
      (when end-line
	;; Trim off excess string at end.  This is likely to win since
	;; it's its own area.
	(sys:adjust-array-size string length)))
    (setf (box-right displayed-box)
	  (box-right (presentation-displayed-box displayed-string)))
    t))

(defmethod (presentation-at-position text-displayed-presentation) (window x y
								   &optional eol-p ignore)
  (if (> y (box-bottom displayed-box))
      (values nil t)
      (when (displayed-box-contains-point-p displayed-box x y window eol-p)
	(let ((raw-presentation (presentation-at-position displayed-string window x y
							  eol-p)))
	  (when (and raw-presentation
		     ( start-index (second (presentation-object raw-presentation)))
		     (or (null end-index)
			 (> end-index (second (presentation-object raw-presentation)))))
	    (setf (presentation-superior raw-presentation) self)
	    raw-presentation)))))

(defmethod (presentation-redisplay-place-holder displayed-presentation) ()
  (or (eq type 'redisplay-structure)
      (displayed-presentation-redisplay-place-holder self)))

(defun top-displayable-index (array top &key (start 0) end
					     (key #'presentation-displayed-box))
  (setq start (coordinate-sorted-set-index-for-position array 0 top
							:start start :end end :key key))
  (loop for object being the array-elements of array
		   using (index index) from start
		   below (or end (fill-pointer array))
	when (> (box-bottom (funcall key object)) top)
	  return index
	finally (return index)))

(defun bottom-displayable-index (array bottom &key (start 0) end
						   (key #'presentation-displayed-box))
  (let ((limit (+ bottom (coordinate-sorted-set-tallest-box-height array)))
	(end (or end (fill-pointer array))))
    (loop for index from start below end
	  when (> (box-bottom (funcall key (aref array index))) limit)
	    return index
	  finally (return end))))

(defun clear-coordinate-sorted-set (array)
  ;; Remove all the entries for the GC
  (si:fill-array array nil nil)
  (setf (coordinate-sorted-set-fill-pointer array) 0
	(coordinate-sorted-set-tallest-box-height array) 0))

(defun add-to-coordinate-sorted-set (object array &key (key #'presentation-displayed-box))
  (let ((box (funcall key object)))
    (maxf (coordinate-sorted-set-tallest-box-height array) (box-height box))
    (multiple-value-bind (right bottom)
	(box-bottom-right box)
      ;; Quick check for doing output at the bottom of the window
      (if (let ((length (fill-pointer array)))
	    (or (zerop length)
		(let ((other-object (aref array (1- length))))
		  (when (eq other-object object)
		    (return-from add-to-coordinate-sorted-set nil))
		  (let* ((other-box (funcall key other-object))
			 (other-bottom (box-bottom other-box)))
		    (or (> bottom other-bottom)
			(and (= bottom other-bottom) ( right (box-right other-box))))))))
	  ;; Should get extended in area it's in now.
	  (vector-push-extend object array)
	  (let ((index (coordinate-sorted-set-index-for-position array right bottom
								 :key key)))
	    (insert-array-element object array index))))))

(defun insert-array-element (object array index)
  (let ((fill-pointer (fill-pointer array)))
    (when (= fill-pointer (zl:array-length array))
      (zl:adjust-array-size array (max 200 (* fill-pointer 2))))
    (let ((array array))
      (declare (array-register array))
      (loop for idx from fill-pointer downto (1+ index)
	    do (setf (aref array idx) (aref array (1- idx))))
      (setf (fill-pointer array) (1+ fill-pointer))
      (setf (aref array index) object))))

(defun delete-from-coordinate-sorted-set (object array
					  &key (key #'presentation-displayed-box))
  (let ((index (coordinate-sorted-set-position object array :key key)))
    (when index
      (let ((length (fill-pointer array)))
	(unless (= index (1- length))
	  (copy-array-portion array (1+ index) length array index (1- length)))
	(setf (fill-pointer array) (1- length)))
      index)))

(defun coordinate-sorted-set-position (object array &key (key #'presentation-displayed-box))
  (multiple-value-bind (right bottom)
      (box-bottom-right (funcall key object))
    ;; Binary search to find where this one goes.
    (let ((search-index (coordinate-sorted-set-index-for-position array right bottom
								   :key key))
	  (limit (fill-pointer array)))
      ;; Search back over things in the same place.
      (when (< search-index limit)
	(loop for index downfrom search-index to 0 do
	  (let ((element (aref array index)))
	    (when (eq element object)
	      (return-from coordinate-sorted-set-position index))
	    (multiple-value-bind (other-right other-bottom)
		(box-bottom-right (funcall key element))
	      (unless (and (= right other-right) (= bottom other-bottom))
		(return)))))
	;; Search forward too.
	(loop for index from (1+ search-index) below limit do
	  (let ((element (aref array index)))
	    (when (eq element object)
	      (return index))
	    (when (> (box-bottom (funcall key element)) bottom)
	      (return nil))))))))

;;; Binary search; dictionary order Y, X.
(defun coordinate-sorted-set-index-for-position (array right bottom
						 &key (start 0) end
						      (key #'presentation-displayed-box))
  (let ((below start)
	(above (or end (fill-pointer array))))
    (assert ( below above))			;Binary search will loop otherwise.
    (loop doing
      (when (= above below)
	(return above))
      (let* ((index (floor (+ above below) 2))
	     (other-box (funcall key (aref array index))))
	(multiple-value-bind (other-right other-bottom)
	    (box-bottom-right other-box)
	  (cond ((or (< bottom other-bottom)
		     (and (= bottom other-bottom) (< right other-right)))
		 (setq above index))
		((or (> bottom other-bottom)
		     (and (= bottom other-bottom) (> right other-right)))
		 (if (= below index)
		     (return above)
		     (setq below index)))
		(t
		 (return index))))))))

(defun sort-coordinate-sorted-set (array &key (start 0) end
					      (key #'presentation-displayed-box))
  (flet ((position-lessp (object-1 object-2)
	   (multiple-value-bind (right-1 bottom-1)
	       (box-bottom-right (funcall key object-1))
	     (multiple-value-bind (right-2 bottom-2)
		 (box-bottom-right (funcall key object-2))
	       (or (< bottom-1 bottom-2)
		   (and (= bottom-1 bottom-2) (< right-1 right-2)))))))
    (if (and (zerop start) (null end))
	(sort array #'position-lessp)
      (unless end
	(setq end (fill-pointer array)))
      (with-stack-array (copy (- end start))
	(replace copy array :start2 start :end2 end)
	(sort copy #'position-lessp)
	(replace array copy :start1 start :end1 end)))))

;;; Faster than (position presentation (send window :displayed-presentations))
(defun displayed-presentation-still-visible (presentation stream)
  (loop as superior = (presentation-superior presentation)
	always (if (null superior)
		   (let ((presentations (send stream :displayed-presentations)))
		     (and presentations
			  (coordinate-sorted-set-position presentation presentations)))
		   (member presentation (presentation-inferiors superior)))
	while superior
	do (setq presentation superior)))

(defun check-coordinate-sorted-set (array &key (key #'presentation-displayed-box))
  (let ((x -1)
	(y -1))
    (dotimes (i (fill-pointer array))
      (let* ((object (aref array i))
	     (box (funcall key object)))
	(multiple-value-bind (left top right bottom)
	    (box-edges box)
	  (unless (or ( bottom y)
		      (and (= bottom y) ( right x)))
	    (zl:fsignal "Object ~S at index ~D out of order.
Previous at ~D, ~D.  This at ~D, ~D, ~D, ~D."
			object i x y left top right bottom))
	  (setq x right y bottom))))))
