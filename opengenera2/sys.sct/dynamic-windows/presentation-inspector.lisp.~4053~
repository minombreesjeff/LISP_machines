;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DW; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun graph-around-presentation (presentation)
  (with-output-truncation ()
    (with-character-size (:small)
      (let ((superior (presentation-superior presentation)))
	(format-graph-from-root
	  (or superior presentation)
	  #'(lambda (object stream) 
	      (present-for-documentation object 'presentation stream))
	  #'presentation-inferiors
	  :border nil
	  :cutoff-depth (if superior 3 2)
	  :orientation :horizontal)))))

(defun display-presentation-hierarchy (current-presentation)
  (let ((top (loop for pres = current-presentation then superior
		   as superior = (presentation-superior pres)
		   while superior
		   finally (return pres))))
    (labels ((display-presentation (presentation depth)
	       (write-string (if (eq presentation current-presentation) " " "  "))
	       (format t "~v@T" (* depth 2))
	       (let ((*print-length* 3))
		 (present presentation 'presentation :allow-sensitive-inferiors nil))
	       (terpri)
	       (dolist (inferior (presentation-inferiors presentation))
		 (display-presentation inferior (1+ depth)))))
      (display-presentation top 0))))

(define-presentation-type presentation-mouse-handler ()
   :no-deftype t
   :parser ((stream)
	    (completing-from-suggestions (stream :force-complete t
						 :type 'presentation-mouse-handler)
	      (loop for handler-functions in *presentation-mouse-handler-functions*
		    for name = (presentation-mouse-handler-functions-name
				 handler-functions)
		    do (suggest (write-to-string name)
				(first (gethash name *presentation-mouse-handlers-table*))))))
   :printer ((presentation-mouse-handler stream)
	     (prin1 (presentation-mouse-handler-functions-name
		      (presentation-mouse-handler-handler-functions
			presentation-mouse-handler))
		    stream))
   :description "a presentation mouse handler")

(defun briefly-describe-handler-translation (handler)
  (let ((*print-length* 2)
	(*print-level* 2))
    (let ((presentation-type (presentation-mouse-handler-displayed-presentation-type handler)))
      (format t "~S" presentation-type))
    (format t "  ~S" (presentation-mouse-handler-context-presentation-type handler))))

(defflavor handler-explanation (handler presentation context
				debugging-description tested-p reason
				mouse-char (menu)
				(shadowed-by))
	   ()
  :initable-instance-variables
  (:required-init-keywords :handler :presentation :context
			   :debugging-description :tested-p :reason :mouse-char)
  :writable-instance-variables
  (:constructor
   make-handler-explanation (&key handler presentation context debugging-description tested-p
				  reason mouse-char)))

(defmethod (print-self handler-explanation) (stream ignore slashify-p)
  (if slashify-p
      (printing-random-object (self stream :typep)
	(prin1 (presentation-mouse-handler-functions-name
		 (presentation-mouse-handler-handler-functions handler))
	       stream))
    (write-string debugging-description stream)
    (case reason
      (shadowed
	(write-string " (shadowed by " stream)
	(prin1 (presentation-mouse-handler-functions-name
		 (presentation-mouse-handler-handler-functions handler))
	       stream)
	(write-string ")" stream)))))

(defun show-mouse-char (mouse-char &optional (stream *standard-output*))
  (stack-let ((bits-buffer (make-array 11	;c-m-s-h-sh-
				       :element-type 'string-char
				       :fill-pointer 0)))
    (if (eq mouse-char t)
	;; I don't think we can GET to the presentation inspector in this case!
	(write-string "*** All ***" stream)
      (with-output-to-string (string-stream bits-buffer)
	(format:format-character-bits string-stream (si:mouse-char-bits mouse-char) nil
				      (logbitp 4 (si:mouse-char-bits mouse-char))))
      (write-string "           " stream
		    :end (- 11 (fill-pointer bits-buffer)))
      (write-string bits-buffer stream)
      (write-string (ecase (si:mouse-char-button mouse-char)
		      (0 "Left  ")
		      (1 "Middle")
		      (2 "Right "))
		    stream))))

(defmethod (explanation-match-p handler-explanation) (reason-p menu-p)
  (and (or (eq reason-p :any)
	   (if (atom reason-p)
	       (eq reason reason-p)
	     (member reason reason-p)))
       (or (eq menu-p :any)
	   (if (atom menu-p)
	       (eq menu menu-p)
	     (member menu menu-p)))))

(defmethod (present-handler-explanation handler-explanation)
	   (stream &key show-mouse-char show-shadowed show-context show-presentation)
  (with-output-as-presentation (:stream stream
				:object handler
				:type 'presentation-mouse-handler)
    (when show-mouse-char
      (show-mouse-char mouse-char stream)
      (format stream " : (priority ~D) " (compute-priority self)))
    (write-string debugging-description stream)
    (labels ((with-indentation-body (stream)
	       (when (and show-shadowed shadowed-by)
		 (format stream "~&Shadowed-by: (priority ~D) ~@\\Presentation\\"
			 (compute-priority shadowed-by)
			 (handler-explanation-handler shadowed-by)
			 'presentation-mouse-handler))
	       (when show-presentation
		 (format stream "~&From presentation ~@\\Presentation\\"
			 presentation 'presentation))
	       (when show-context
		 (format stream "~&To context ~@\\Presentation\\"
			 context 'presentation-input-context))))
      (if show-mouse-char
	  (with-indentation (stream 20)
	    (with-indentation-body stream))
	(with-indentation (stream 2)
	  (with-indentation-body stream))))))

(define-presentation-type handler-explanation (() &key show-mouse-char show-shadowed
					       show-presentation show-context)
   :no-deftype t
   :printer ((object stream)
	     (present-handler-explanation object stream
					  :show-mouse-char show-mouse-char
					  :show-shadowed show-shadowed
					  :show-presentation show-presentation
					  :show-context show-context)))

(compile-flavor-methods handler-explanation)

(defun compute-presentation-possible-handlers (presentation window context complete-p program)
  (let ((result-list nil)
	(*program* program))
    (when (eq *program* :unbound)
      (variable-makunbound *program*))
    (loop for presentation = presentation then (when complete-p
						 (presentation-superior presentation))
	  while presentation
	  do
      (map-over-presentation-mouse-handlers-all presentation window t
       (lambda (handler-entry context gesture mouse-char)
	 (multiple-value-bind (tested-p reason)
	     (test-handler handler-entry presentation window context gesture mouse-char)
	   (let* ((handler (if (atom handler-entry) handler-entry (first handler-entry)))
		  (handler-explanation
		    (make-handler-explanation
		      :handler handler
		      :presentation presentation
		      :context context
		      :debugging-description 
		      (condition-case-if (null tested-p) ()
			   (presentation-mouse-handler-debugging-description
			     :handler handler :input-context context
			     :presentation presentation
			     :window window :gesture gesture :mouse-char mouse-char)
			 ;; We cannot count on this working if it isn't supposed to be run.
			 (error (write-to-string
				  (presentation-mouse-handler-functions-name
				    (presentation-mouse-handler-handler-functions handler)))))
		      :tested-p (not (null tested-p))
		      :reason reason
		      :mouse-char mouse-char)))
	     (labels ((handler-subsumes (new old)
			(let ((new-name
				(presentation-mouse-handler-functions-name
				  (presentation-mouse-handler-handler-functions
				    (handler-explanation-handler new))))
			      (old-name
				(presentation-mouse-handler-functions-name
				  (presentation-mouse-handler-handler-functions
				    (handler-explanation-handler old)))))
			  (and (eq new-name old-name)
			       (eq (handler-explanation-reason new)
				   (handler-explanation-reason old))))))
	       (pushnew handler-explanation result-list
			:test #'handler-subsumes)))))
						context))
    ;; We used D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")pushnew0; the original list was in priority order.
    (setq result-list (nreverse result-list))
    result-list))

(defmethod (shadows-self-p handler-explanation) ()
  (and shadowed-by
       (let ((shadowed-by-handler (handler-explanation-handler shadowed-by)))
	 (or (eq shadowed-by-handler handler)	;Shouldn't happen, eh?
	     (eq (presentation-mouse-handler-handler-functions handler)
		 (presentation-mouse-handler-handler-functions shadowed-by-handler))))))

(defmethod (compute-priority handler-explanation) ()
  (multiple-value-bind (nil nil displayed-type)
      (presentation-object-and-types presentation)
    (let ((context-type (presentation-input-context-presentation-type context))
	  (priority (getf (presentation-mouse-handler-property-list handler) :priority 0)))
      (with-type-decoded (context-name) context-type
	 (with-type-decoded (displayed-name) displayed-type
	    (with-type-decoded (handler-context-name)
		  (presentation-mouse-handler-context-presentation-type handler)
	       (with-type-decoded (handler-displayed-name)
		     (presentation-mouse-handler-displayed-presentation-type
		       handler)
		  (when (eql context-name handler-context-name)
		    (incf priority *context-priority*))
		  (when (eql displayed-name handler-displayed-name)
		    (incf priority *displayed-priority*))))))
      priority)))

(defun shadow-presentation-possible-handlers (result-list)
  ;; Figure out the shadowing or lack of gestures involved, and what
  ;; menus they may appear on.
  (let ((menu-list nil))
    (stack-let ((gesture-array (make-array '(32 3))))
      (loop for explanation in result-list
	    for reason = (handler-explanation-reason explanation)
	    for handler = (handler-explanation-handler explanation)
	    for gesture = (presentation-mouse-handler-gesture handler)
	    for mouse-char = (handler-explanation-mouse-char explanation)
	    for menu-spec = (getf (presentation-mouse-handler-property-list handler)
				  :menu t)
	    for menu = (if (consp menu-spec)
			   (car menu-spec)
			 menu-spec)
	    do
	(when (null reason)
	  (if gesture
	      (if (and (eq gesture t) (null mouse-char))
		  (loop for i below 32
			do
		    (loop for j below 3
			  do
		      (unless (aref gesture-array i j)
			(setf (aref gesture-array i j) explanation
			      (handler-explanation-mouse-char explanation) t))))
		(if mouse-char
		    (let* ((bits (si:mouse-char-bits mouse-char))
			   (button (si:mouse-char-button mouse-char))
			   (shadowed-by (aref gesture-array bits button)))
		      (if shadowed-by
			  (setf (handler-explanation-reason explanation) 'shadowed
				(handler-explanation-shadowed-by explanation) shadowed-by
				(handler-explanation-mouse-char explanation) mouse-char)
			(setf (aref gesture-array bits button) explanation
			      (handler-explanation-mouse-char explanation) mouse-char)))
		  (setf (handler-explanation-reason explanation) 'no-mouse-char)))
	    (setf (handler-explanation-reason explanation) 'no-gesture))
	  (setf (handler-explanation-menu explanation) menu)
	  (pushnew menu menu-list)))
      (setq result-list (remove-if #'shadows-self-p result-list))
      (values result-list menu-list))))

(defun sort-presentation-possible-handlers (result-list)
  (labels ((explanation-lessp (e1 e2)
	     (let* ((r1 (handler-explanation-reason e1))
		    (r2 (handler-explanation-reason e2)))
	       (if (neq r1 r2)
		   (let ((precedence
			   #(nil shadowed no-gesture no-mouse-char
				 tester menu value object-predicate context-predicate)))
		     (< (position r1 precedence)
			(position r2 precedence)))
		 (case r1
		   ((nil)
		     (let* ((char-1 (handler-explanation-mouse-char e1))
			    (bits-1 (si:mouse-char-bits char-1))
			    (button-1 (si:mouse-char-button char-1))
			    (char-2 (handler-explanation-mouse-char e2))
			    (bits-2 (si:mouse-char-bits char-2))
			    (button-2 (si:mouse-char-button char-2)))
		       (if (= bits-1 bits-2)
			   (if (= button-1 button-2)
			       (error "Found two successful handlers with the same buttons, ~@
				       but shadowing wasn't detected.")
			     (< button-1 button-2))
			 (< (dpb (ldb (byte 4 0) bits-1) (byte 4 1)
				 (ldb (byte 1 4) bits-1))
			    (dpb (ldb (byte 4 0) bits-2) (byte 4 1)
				 (ldb (byte 1 4) bits-2))))))
		   ((no-mouse-char no-gesture shadowed)
		    (let ((menu-1 (handler-explanation-menu e1))
			  (menu-2 (handler-explanation-menu e2)))
		      (if (eq menu-1 menu-2)
			  (alphalessp (handler-explanation-debugging-description e1)
				      (handler-explanation-debugging-description e2))
			(if (not (and (symbolp menu-1)	;Don't blow out just because the
				      (symbolp menu-2)))	;user does something stupid.
			    (alphalessp (handler-explanation-debugging-description e1)
					(handler-explanation-debugging-description e2))
			  (if (and (symbolp menu-1)
				   (symbolp menu-2)
				   (string-equal menu-1 menu-2))
			      (alphalessp (package-name (symbol-package menu-1))
					  (package-name (symbol-package menu-2)))
			    (alphalessp menu-1 menu-2))))))
		   (otherwise
		     (alphalessp (handler-explanation-debugging-description e1)
				 (handler-explanation-debugging-description e2))))))))
    (sort result-list #'explanation-lessp)))

(defun presentation-possible-handlers (presentation window context &key (sort-p t) complete-p
				       program)
  (declare (values explanations menus))
  (let* ((explanations (compute-presentation-possible-handlers presentation window context
							       complete-p program))
	 (menus))
    (multiple-value-setq (explanations menus)
      (shadow-presentation-possible-handlers explanations))
    (values (if (not sort-p)
		explanations
	      (sort-presentation-possible-handlers explanations))
	    menus)))

(defun list-presentation-handlers (presentation window original-context
				   &key complete-p show-presentation show-context
				   (program *program*))
  (with-output-truncation (*standard-output* :horizontal t)
    (if complete-p
	(format t "~&Searching the presentation and context hierarchies, for handlers~%")
      (format t "~&from just one presentation, but searching the contexts:~%"))
    (format t "~&from presentation ~@\\Presentation\\.~%" presentation 'presentation)
    (format t "~&to context ~@\\Presentation\\.~%"
	      original-context 'presentation-input-context)
    (multiple-value-bind (explanations menus)
	(presentation-possible-handlers presentation window original-context
					:sort-p t
					:complete-p complete-p
					:program program)
      (labels ((show-some (reason-p menu prefix &rest prefix-format-args)
		 (when (loop for explanation in explanations
			     thereis (explanation-match-p explanation reason-p menu))
		   (with-character-face (:bold)
		     (format t "~&--- ~? ---~%" prefix prefix-format-args))
		   (loop for explanation in explanations
			 do
		     (when (explanation-match-p explanation reason-p menu)
		       (present explanation `((handler-explanation)
					      :show-mouse-char ,(or (null reason-p)
								    (eq reason-p 'shadowed))
					      :show-shadowed ,(eq reason-p 'shadowed)
					      :show-presentation ,show-presentation
					      :show-context ,show-context))
		       (fresh-line))))))
	(show-some nil :any "Handlers appearing on mouse buttons")
	(show-some 'shadowed :any "Handlers which have been shadowed by other handlers")
	(loop for menu in menus
	      do
	  (unless (eq menu nil)
	    (show-some '(shadowed no-mouse-char no-gesture nil) menu
		       "Handlers appearing in ~@?"
		       (case menu
			 ((t) "the standard Right menu~*")
			 (:blank-area "the blank area menu~*")
			 (otherwise "the ~S menu"))
		       menu)))
	(show-some 'no-mouse-char :any
		   "Handlers not appearing on mouse buttons because their gesture does not ~
		    have a mouse character")
	(show-some 'no-gesture :any
		   "Handlers not appearing on mouse buttons because they have no gesture")
	(show-some '(shadowed no-mouse-char no-gesture) nil
		   "Successful handlers not on any mouse buttons or menus")
	(show-some 'tester :any "Handlers whose test functions failed")
	(show-some 'menu :any "Handlers for empty menus")
	(show-some 'value :any "Handlers which did not return a value")
	(show-some 'object-predicate :any
		   "Handlers who failed predicates derived from their object and ~
		    presentation types")
	(show-some 'context-predicate :any
		   "Handlers who failed the predicate derived from the context")))))


(define-program-framework presentation-inspector
  :selectable nil
  :command-definer define-presentation-inspector-command
  :command-table (:inherit-from '("Global")
		  :kbd-accelerator-p nil)
  :panes ((title :title
		 :size-from-output t
		 :redisplay-function 'display-presentation-inspector-title
		 :default-style '(:swiss :bold :large))
	  (listener :listener
		    :margin-components '((margin-borders)
					 (margin-white-borders)
					 (margin-scroll-bar)
					 (margin-whitespace :margin :left :thickness 7)))
	  (command-menu :command-menu
			:equalize-column-widths t
			:columns '(("Exit" "Help")
				   ("Show Handlers All Presentations"
				    "Show Handlers This Presentation"
				    ""
				    "Show Presentation Hierarchy"
				    "Show Input Context")
				   ("Show Handler Applicability"
				    "Show Handler Context Applicability"
				    "Describe Handler"
				    ""
				    "Set Presentation"))))
  :state-variables ((original-presentation)
		    (presentation)
		    (original-window)
		    (original-context)
		    (original-program))
  )

(defvar *test*)

(defun invoke-presentation-inspector (&key presentation original-presentation window
				      &allow-other-keys)
  (let* ((rubout-handler nil)			(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Not us.
0	 (old-context (copy-tree *presentation-input-context*))
	 2;; Establish enough binding to convince 1accept2 that we're not recursive.
0	 (*presentation-input-context* nil)
	 (*input-editor-options* nil)
	 (*accept-active* nil)
	 (*accept-help* nil))
    (using-resource (frame program-frame 'presentation-inspector
					 (send window :screen) :process nil)
      (initialize-presentation-inspector (send frame :program) frame
							       original-presentation
							       presentation
							       window
							       old-context
							       (if (variable-boundp *program*)
								   *program*
								 :unbound))
      (position-window-near-carefully frame (presentation-near-mode presentation window))
      (tv:with-window-shadowed-for-selection (window frame :reselect t)
	(catch 'exit-presentation-inspector
	  (tv:window-call (frame :deactivate)
	    (program-frame-top-level frame)))))))

(defmethod (initialize-presentation-inspector presentation-inspector)(frame
								      the-original-presentation
								      the-presentation
								      the-original-window
								      the-original-context
								      the-original-program)
  
  (setf original-presentation the-original-presentation
	presentation the-presentation
	original-window the-original-window
	original-context the-original-context
	original-program the-original-program)
  (send frame :set-size (send frame :size)
			(let ((window-height (send (send original-window :screen) :height)))
			  (if (< window-height 666)
			      (min 500 (round (* window-height 9/10)))
			    (round (* window-height 3/4)))))
  2;; Can't use 1set-program-frame-configuration2 as it sets 1*terminal-io*2!
0  (send frame :set-configuration 'only))

(defmethod (before-program-frame-deactivation-handler presentation-inspector) (frame)
  (setf original-presentation nil
	presentation nil
	original-window nil
	original-context nil)
  (send frame :clear-all))

(defmethod (display-presentation-inspector-title presentation-inspector) (stream)
  (if (null presentation)
      (write-string "Presentation Inspector" stream)
    (with-output-truncation (stream :horizontal t)
      (format stream "Inspecting presentation ")
      (with-indentation (stream (+ 24 2))	2;Why is the fudge factor (2) needed?
0	(abbreviating-output (stream :height 5 :show-abbreviation t)
	  (let ((*print-length* 3))
	    (present presentation 'presentation :stream stream))))
      (terpri stream)
      (with-character-style ('(nil :roman :small) stream :bind-line-height t)
	(if (null original-context)
	    (write-string "in the null context." stream)
	  (write-string "in context " stream)
	  (with-indentation (stream (+ 11 2))	2;Why is the fudge factor (2) needed?
0	    (abbreviating-output (stream :height 5 :show-abbreviation t)
	      (present original-context '((presentation-input-context) :recursive-p t)
		       :stream stream))))))))

;;; Heuristically find a lowest level presentation that we might have been
;;; pointing at, given a higher-level presentation.
(defmethod (find-text-presentation presentation-inspector) (this-presentation)
  (labels ((pass1 (this-presentation)
	     (if (eql this-presentation original-presentation)
		 (pass2 this-presentation)
	       (loop for p in (presentation-inferiors this-presentation)
		     do (pass1 p))))
	   (pass2 (this-presentation)
	     (if (and (null (presentation-inferiors this-presentation))
		      (operation-handled-p this-presentation #'presentation-displayed-box))
		 (let* ((box (presentation-displayed-box this-presentation))
			(text-presentation
			  (presentation-at-position this-presentation original-window
						    (box-left box) (box-top box)
						    nil t)))
		   (when text-presentation
		     (return-from find-text-presentation text-presentation)))
	       (loop for p in (presentation-inferiors this-presentation)
		     do (pass2 p))))
	   (pass3 (this-presentation)
	     (let ((inferiors (presentation-inferiors this-presentation)))
	       (if (null inferiors)
		   (return-from find-text-presentation this-presentation)
		 (pass3 (first inferiors))))))
    ;; First try finding one that we know about.
    (pass1 this-presentation)
    ;; That failed.  Try finding the raw text at the start of this presentation.
    (pass2 this-presentation)
    ;; That failed, must not have been any text.  Try the lowest one we can find.
    (pass3 this-presentation)
    ;; The above was guarenteed to return, but if it didn't, just return this one.
    this-presentation))

;;; This wants a nice 1:multiple-accept-displayer0, if I could only figure out how
;;; to make that work right.
(define-presentation-type presentation-range ()
   :abbreviation-for '((token-or-type (:text :current :all) presentation)))

(define-presentation-inspector-command (com-show-handlers-this-presentation
					 :menu-accelerator "Show handlers this presentation")
    (&key
      (presentation-range 'presentation-range
			  :documentation
			    "The range of the presentation hierarchy to show handlers for."
			  :default :current)
      (show-presentation 'boolean :default nil :mentioned-default t
			 :documentation "Show the presentation that this handler applies to.")
      (show-context 'boolean :default nil :mentioned-default t
		    :documentation "Show the context that this handler applies to."))
   (list-presentation-handlers (case presentation-range
				 ((:text :all) (find-text-presentation self presentation))
				 (:current presentation)
				 (otherwise presentation-range))
			       original-window original-context
			       :complete-p (eq presentation-range :all)
			       :show-presentation show-presentation
			       :show-context show-context
			       :program original-program))

(define-presentation-inspector-command (com-show-handlers-all-presentations
					 :menu-accelerator "Show handlers all presentations")
    (&key
      (show-presentation 'boolean :default nil :mentioned-default t
			 :documentation "Show the presentation that this handler applies to.")
      (show-context 'boolean :default nil :mentioned-default t
		    :documentation "Show the context that this handler applies to."))
   (list-presentation-handlers (find-text-presentation self presentation)
			       original-window original-context
			       :complete-p t
			       :show-presentation show-presentation
			       :show-context show-context
			       :program original-program))

(define-presentation-to-command-translator com-show-presentation-handlers
					   (presentation :gesture :describe)
  (presentation)
  `(com-show-handlers-this-presentation :presentation-range ,presentation))

(define-presentation-inspector-command (com-describe-handler
					 :menu-accelerator "Describe handler")
    ((handler 'presentation-mouse-handler
	      :documentation "a handler to call 1describe0 on."
	      :confirm t))
  (describe-presentation-mouse-handler handler))

(define-presentation-to-command-translator com-describe-handler
					   (presentation-mouse-handler :gesture :describe)
					   (handler)
  `(com-describe-handler ,handler))

(defun describe-presentation-mouse-handler (handler)
  (let ((*print-structure-contents* nil))
    (describe (presentation-mouse-handler-handler-functions handler))
    (describe handler)))

(define-presentation-inspector-command (com-show-handler-applicability
					 :menu-accelerator "Show Handler Applicability")
    ((handler 'presentation-mouse-handler
	      :documentation "A handler to show where in the context hierarchy is applicable"
	      :confirm t)
     &key
     (detailed 'boolean :default nil
	       :mentioned-default t
	       :documentation "show more detailed information"))
  ;;+++ Bit of a kludge here.  User really was referring to the
  ;;handler-function's name we assume.
  (explain-handler-applicability (presentation-mouse-handler-functions-name
				   (presentation-mouse-handler-handler-functions
				     handler))
				 :presentation presentation
				 :input-context original-context
				 :window original-window
				 :detailed detailed))


(define-presentation-type presentation-input-context-level ()
   :expander 'presentation-input-context
   :printer ((presentation-input-context-level stream)
	     (if (null presentation-input-context-level)
		 (write-string "2<null context>0" stream)
	       (let ((*print-level* 3)
		     (*print-length* 4)
		     (*print-structure-contents* nil)
		     (*print-pretty* nil))
		 (present (presentation-input-context-presentation-type
			    presentation-input-context-level)
			  'presentation-type
			  :allow-sensitive-inferiors nil
			  :stream stream)))))

(define-presentation-type presentation-input-context (() &key recursive-p)
   :no-deftype t
   :description "a presentation input context"
   :printer ((presentation-input-context stream &key original-type)
	     (present presentation-input-context
		      'presentation-input-context-level
		      :stream stream)
	     (when presentation-input-context
	       (when recursive-p
		 (with-indentation (stream 2)
		   (terpri stream)
		   (present (presentation-input-context-superior presentation-input-context)
			    original-type
			    :stream stream)))))
   :parser ((stream) (loop do (dw:read-char-for-accept stream))))

(define-presentation-inspector-command (com-show-handler-context-applicability
					 :menu-accelerator
					   "Show Handler Context Applicability")
    ((handler 'presentation-mouse-handler
	      :documentation "A handler to show what context applies it to"
	      :confirm t)
     (input-context 'presentation-input-context-level
		    :prompt "select a level of context with the mouse"
		    :documentation
		      "An single input context level to show the handler's applicability in."
		    :confirm t))
  (explain-handler-context-applicability (list handler) :input-context input-context
					 :presentation presentation
					 :window original-window))

(defun explain-handler-applicability (handler-name &rest options
						   &key input-context
						   &allow-other-keys)
  (let ((handlers (let ((handler-functions (find-presentation-mouse-handler-functions
					     handler-name)))
		    (loop for handler in *presentation-mouse-handlers*
			      when (eq (presentation-mouse-handler-handler-functions
					 handler)
				       handler-functions)
				collect handler))))
    (labels ((one-context (context)
	       (apply #'explain-handler-context-applicability handlers
		      :input-context context options)
	       (unless (null context)
		 (one-context (presentation-input-context-superior context)))))
      (one-context input-context))))

(define-presentation-type handler-in-context ()
   :printer ((object stream &key acceptably)
	     (if acceptably
		 (format stream "~\\Presentation\\ ~S" (first object) (second object))
	       (format stream "~\\Presentation\\ ~S"
		       (first object)
		       (presentation-input-context-presentation-type (second object)))))
   :parser ((stream)
	    (list (accept 'presentation-mouse-handler :stream stream)
		  (accept 'presentation-input-context :stream stream)))
   )

(defun explain-handler-context-applicability (handlers &key presentation input-context
							    window (detailed t))
  (ignore detailed)
  (let ((*print-level* 2))
    (format t "~&For context ")
    (present input-context 'presentation-input-context)
    (format t ": "))
  (multiple-value-bind (object presentation-object-type presentation-displayed-type)
      (presentation-object-and-types presentation)
    (let ((table-handler-list (presentation-context-mouse-handlers
				presentation-object-type
				presentation-displayed-type
				input-context))
	  (*inside-handler-test-phase* t))
      (with-type-hierarchy-for-stand-in (presentation-displayed-type presentation-object-type)
	(labels ((handler-table-entry-functions (handler-table-entry)
		   (presentation-mouse-handler-handler-functions
		     (if (atom handler-table-entry)
			 handler-table-entry
		       (handler-table-entry-handler handler-table-entry)))))
	  (loop for handler in handlers
		for functions = (presentation-mouse-handler-handler-functions handler)
		for gesture = (presentation-mouse-handler-gesture handler)
		for tester = (presentation-mouse-handler-tester-function handler)
		for do-not-compose = (getf (presentation-mouse-handler-property-list handler)
					   :do-not-compose)
		for defines-menu = (getf (presentation-mouse-handler-property-list handler)
					 :defines-menu)
		for handler-table-entries =
		    (loop for (nil . entries) in table-handler-list
			  append (remove functions entries
					 :test-not #'eql
					 :key #'handler-table-entry-functions))
		for handler-context-type =
		    (presentation-mouse-handler-context-presentation-type handler)
		for handler-displayed-type =
		    (presentation-mouse-handler-displayed-presentation-type handler)
		for context-presentation-type =
		    (and input-context
			 (presentation-input-context-presentation-type
			   input-context))
		for handler-match-p = nil	;Handler types match context & presentation
		for displayed-match-p = nil	;Displayed-type's predicate matches
		for returned-values = nil	;Values from the handler's body
		for context-match-p = nil	;Result of applying the context predicate
		for defines-menu-ok = nil	;The handler does define a menu
		for failure-reason = nil	;Why it failed
		do
	    (multiple-value-bind (context-subtypep context-known context-predicate)
		(if (eq handler-context-type t)
		    (values t t nil)		;Match crock elsewhere.
		  (presentation-subtypep handler-context-type context-presentation-type t))
	      (multiple-value-bind (displayed-subtypep displayed-known displayed-predicate)
		  (presentation-subtypep presentation-displayed-type handler-displayed-type t)
		(ignore displayed-known context-known)
		(block failed
		  (macrolet ((until-failure (reason &body body)
			       `(unless (progn ,@body)
				  (setq failure-reason ',reason)
				  (return-from failed))))
		    ;; Group all three under a single failure reason, so we can report
		    ;; all of them that fail.  It may save the user a couple debug cycles.
		    (until-failure :handler-match
				   (setq handler-match-p
					 (and context-subtypep displayed-subtypep)))
		    (when displayed-predicate
		      (setq displayed-match-p
			    (funcall displayed-predicate object)))
		    (when displayed-predicate
		      (until-failure :predicate-match displayed-match-p))
		    (when tester
		      (until-failure :tester
		        (funcall tester object
				 :handler handler
				 :gesture gesture
				 :mouse-char (when gesture
					       (mouse-char-for-gesture gesture))
				 :presentation presentation
				 :presentation-type presentation-displayed-type
				 :window window
				 :input-context input-context)))
		    (unless do-not-compose
		      (setq returned-values
			    (multiple-value-list 
			      (funcall (presentation-mouse-handler-value-function handler)
				       object
				       2;;;--- the next line is to keep 357 handlers working
0				       2;;;--- in the face of poorly formed arglists.
0				       :allow-other-keys t
				       :handler handler
				       :gesture gesture
				       :mouse-char (when gesture
						     (mouse-char-for-gesture gesture))
				       :presentation presentation
				       :presentation-type presentation-displayed-type
				       :window window
				       :input-context input-context)))
		      (until-failure :handler-value
		        (and returned-values
			     (or (first returned-values)
				 (second returned-values)))))
		    (when context-predicate
		      (until-failure :context-predicate
		        (setq context-match-p
			      (funcall context-predicate (first returned-values)))))
		    (when defines-menu
		      (until-failure :menu
		        (setq defines-menu-ok
			      (presentation-menu-p presentation window
						   defines-menu input-context))))))
		(with-output-as-presentation (:type 'handler-in-context
					      :object (list handler input-context))
		  (let ((*print-structure-contents* nil))
		    (format t "~& Handler ~A " handler))
		  (briefly-describe-handler-translation handler)
		  (ecase failure-reason
		    (:handler-match
		      (let ((count 0))
			(unless context-subtypep (incf count))
			(unless displayed-subtypep (incf count))
			(format t "~&  The handler failed because it failed to match the ")
			(formatting-textual-list (*standard-output* :conjunction "and")
			  (labels ((format-item (string)
				     (formatting-textual-list-element (*standard-output*)
				       (write-string string *standard-output*))))
			    (unless context-subtypep
			      (format-item "context"))
			    (unless displayed-subtypep
			      (format-item "displayed"))))
			(format t " presentation type~:[s~;~]." (= count 1))))
		    (:predicate-match
		      (labels ((predicate-failure (type)
				 (format t "~&  The handler failed because the predicate ~
						derived~@
					    ~2@Tfrom the handler's ~A type failed to match."
					 type)))
			(when (and displayed-predicate (not displayed-match-p))
			  (predicate-failure "displayed"))))
		    (:tester
		      (format t "~&  The handler failed because its tester returned ~S."
			      nil))
		    (:handler-value
		      (format t "~&  The handler failed because it's value was ~S."
			      nil))
		    (:context-predicate
		      (format t "~&  The handler failed because the predicate derived from~@
			         ~2@Tthe context type failed when applied to the results of ~
			             the handler."))
		    (:menu
		      (format t "~&  The handler failed because it defines a menu for which~@
			         ~2@Tno handlers were found.  The empty menu was suppressed."))
		    ((nil)
		     (if do-not-compose
			 (format t "~&  The handler succeeded.")
		       (format t "~&  The handler succeeded and returned values:")
		       (with-indentation (*standard-output* 5)
			 (loop for val in returned-values
			       do (prin1 val)
				  (terpri))))
		     (unless handler-table-entries
		       (format t
			   "~&  *** This handler was not found in the handler tables~@
			    ~2@T*** under these types.  This would indicate a defect in~@
			    ~2@T*** the handler tables or the cache.  Please report this~@
			    ~2@T*** bug.")))))))))))))

(define-presentation-to-command-translator com-show-handler-applicability
					   (presentation-mouse-handler)
					   (handler)
  `(com-show-handler-applicability ,handler))


(define-presentation-to-command-translator com-show-handler-context-applicability
					   (handler-in-context)
					   (handler-and-context)
  `(com-show-handler-context-applicability ,(first handler-and-context)
					   ,(second handler-and-context)))

(define-presentation-inspector-command (com-show-input-context
					 :menu-accelerator "Show input context")
    ()
   (format t "~&Current presentation input context:~%")
   (let ((description (get 'presentation-input-context 'si:defstruct-description)))
     (loop for first-p = t then nil
	   for context = original-context
		       then (presentation-input-context-superior context)
	   while context
	   do
       (with-output-as-presentation (:object context
				     :type 'presentation-input-context-level
				     :single-box t)
	 (unless first-p
	   (format t "~&Superior (inherited) context:~%"))
	 (loop for (name . slot-description) in (si:defstruct-description-slot-alist
						  description)
	       doing
	   (unless (eq name 'superior)
	     (let ((form `(,(si:defstruct-slot-description-ref-macro-name slot-description)
			   ',context))
		   (*print-pretty* (case name
				     (options :plist)
				     (presentation-type :code)
				     (otherwise :data))))
	       (present form `((dbg:named-form-slot) :symbol ,name :structure ,context
			       :indentation 30)))
	     (terpri)))))))

(define-presentation-inspector-command (com-show-presentation-hierarchy
					 :menu-accelerator "Show presentation hierarchy")
				       (&key
					(format '((member :text :graph))
						:default :text
						:documentation
						  "Display textually or graphically."))
  (ecase format
    (:text
      (display-presentation-hierarchy presentation))
    (:graph
      (graph-around-presentation presentation))))

(define-presentation-inspector-command (com-set-presentation
					 :menu-accelerator "Set presentation")
    ((new-presentation 'presentation
		       :documentation "a presentation to investigate handlers for"
		       :confirm t))
  (setq presentation new-presentation)
  (send (program-frame self) :set-configuration 'only)
  (send (program-frame self) :redisplay-pane 'title t))

(define-presentation-to-command-translator com-set-presentation (presentation) (presentation)
  `(com-set-presentation ,presentation))

(define-presentation-to-command-translator edit-presentation-mouse-handler
					   (presentation-mouse-handler
					     :gesture :edit-function
					     )
					   (presentation-mouse-handler)
  `(si:com-edit-definition ,(presentation-mouse-handler-functions-name
			      (presentation-mouse-handler-handler-functions
				presentation-mouse-handler))
			   define-presentation-translator))

(define-presentation-to-command-translator edit-presentation-type
					   (presentation-type
					     :gesture :edit-function
					     )
					   (presentation-type)
  `(si:com-edit-definition ,(presentation-type-name presentation-type)
			   define-presentation-type))


(cp:define-command (com-show-presentation-handlers-from-type :command-table "Presentation")
				       ((type 'presentation-type)
					&key
					(include-t 'boolean
						   :documentation
						     "Include the handlers defined on T"
						   :default nil :mentioned-default t))
  (let ((list))
    (tv:dolist-noting-progress (handler *presentation-mouse-handlers*
					"Searching mouse handlers")
      (let ((handler-type (presentation-mouse-handler-displayed-presentation-type handler)))
	(block not-applicable
	  (when (or (neq handler-type 't)
		    include-t)
	    (when (presentation-subtypep type handler-type nil)
	      (push handler list))))))
    (setq list
	  (remove-duplicates list :key #'presentation-mouse-handler-handler-functions))
    (setq list (sort list #'string-lessp 
		     :key #'(lambda (handler)
			      (presentation-mouse-handler-functions-name
				(presentation-mouse-handler-handler-functions handler)))))
    (dolist (handler list)
      (fresh-line)
      (present handler 'presentation-mouse-handler)
      (format t " is defined on ")
      (let ((handler-type (presentation-mouse-handler-displayed-presentation-type handler)))
	(present handler-type 'presentation-type)))))

(defvar *presentation-inspector-help*
	'("You are inspecting a presentation and an input context, to find out what
handlers are available or not, and why.

The top pane tells you which presentation in the hierarchy of presentations
you are inspecting.  You can change it by clicking on ~'i~@\\Presentation\\~ and
selecting one of the presentations it shows.

The top pane also shows you an abbreviated version of the input context.  You
can see more detail by doing ~'i~@\\Presentation\\~.  You can also click on this
to specify a context for commands that take a context.

~'i~@\\Presentation\\~ and ~'i~@\\Presentation\\~ show the handlers whose types
match the presentation(s) and contexts, and tell you why they were or were
not applicable.  ~'i~@\\Presentation\\~ shows the handlers for the entire chain
of presentations as if you had pointed the mouse at the selected presentation.
~'i~@\\Presentation\\~ lets you investigate this on a per-presentation basis.

The handlers shown by the above commands may be given to the ~'i~@\\Presentation\\~
and ~'i~@\\Presentation\\~ commands, for additional information.
~'i~@\\Presentation\\~ shows this information for all the contexts, while
~'i~@\\Presentation\\~ lets you specify which one."

	  com-show-presentation-hierarchy cp:command-name
	  com-Show-Input-Context cp:command-name

	  com-show-Handlers-all-presentations cp:command-name
	  com-show-Handlers-this-presentation cp:command-name
	  com-show-Handlers-all-presentations cp:command-name
	  com-show-Handlers-this-presentation cp:command-name

	  com-show-handler-applicability cp:command-name
	  com-show-handler-context-applicability cp:command-name
	  com-show-handler-applicability cp:command-name
	  com-show-handler-context-applicability cp:command-name))

(define-presentation-inspector-command (com-presentation-inspector-help
					 :name "Help"
					 :menu-Accelerator "Help") ()
   (fresh-line)
   (apply #'format t *presentation-inspector-help*))

(define-presentation-inspector-command (com-program-frame-exit :name "Exit"
							       :menu-accelerator "Exit")
				       ()
  (throw 'exit-presentation-inspector t))


(define-presentation-action invoke-presentation-inspector
  (t t :gesture ()
       :tester ((ignore &key presentation)
		(presentation-debug-p presentation))
       :documentation "Presentation Inspector"
      ;:context-independent t
       :blank-area t				;This lets you look at the context at least.
       :menu :presentation-debugging)
  (ignore &rest args)
  (apply #'invoke-presentation-inspector args))

