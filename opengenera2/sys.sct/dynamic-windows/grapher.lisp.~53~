;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DW; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; These variables are the defaults for the various options to formatting-graph
;;; and format-graph-from-root.

(defparameter *default-graph-orientation* :vertical)
(defparameter *default-graph-inverted-center* nil)
(defparameter *default-graph-balance-evenly* nil)
(defparameter *default-graph-row-spacing* 40)
(defparameter *default-graph-within-row-spacing* 20)
(defparameter *default-graph-column-spacing* 30) ;--- was 20 before patch
(defparameter *default-graph-within-column-spacing* 10)
(defparameter *default-graph-branch-point* :between-generations)
(defparameter *default-graph-allow-overlap* t)

(defflavor redisplay-piece-graph
	((nodes-to-be-displayed nil)
	 (displayed-nodes nil)
	 (connections-to-be-displayed nil)
	 (displayed-connections nil)
	 (graph-options nil))
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defmacro formatting-graph ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream
		     &key (orientation *default-graph-orientation*)
			  (inverted-center *default-graph-inverted-center*)
			  (balance-evenly *default-graph-balance-evenly*)
			  (row-spacing *default-graph-row-spacing*)
			  (within-row-spacing *default-graph-within-row-spacing*)
			  (column-spacing *default-graph-column-spacing*)
			  (within-column-spacing *default-graph-within-column-spacing*)
			  (branch-point *default-graph-branch-point*)
			  (allow-overlap *default-graph-allow-overlap*)
			  (default-drawing-mode :line)
			  (default-drawing-options nil)
			  (dont-snapshot-variables nil))
		    &body body))
  (format-output-macro-default-stream stream)
  `(format-graph-internal
     (format-output-macro-continuation (:name formatting-graph
					:dont-snapshot-variables
					 ,(option-remf options :dont-snapshot-variables))
				       (ignore ,stream ignore) . ,body)
     ,stream . ,options))

(defun format-graph-internal (continuation stream &rest options)
  (if (operation-handled-p stream :format-graph-contents)
      (send stream :format-graph-contents options continuation)
      (let ((piece (redisplayer (stream)
		     (send stream :format-graph-contents options continuation))))
	(do-redisplay piece stream :once-only t :truncate-p t
				   :full-set-cursorpos :graphics))))

(defmethod (:format-graph-contents redisplay-helper-stream) (options continuation)
  (check-table-state :format-graph-contents self table-state '(nil :cell :graph-node))
  (send-if-handles stream :check-set-cursorpos-simulating-stream-no-cursor-back :graphics)
  (letf ((table-state :graph))
    (send self :display-internal continuation self
	  :piece-flavor 'redisplay-piece-graph
	  :piece-hook (lambda (piece)
			(declare (sys:downward-function))
			(setf (redisplay-piece-graph-graph-options piece)
			      (copy-list options))))))

(defflavor redisplay-piece-graph-node
	(continuation
	 (nodes-below nil)
	 (nodes-above nil)
	 (nodes-right nil)
	 (nodes-left nil)
	 parent-node
	 (x-position -1)
	 (y-position -1)
	 width
	 height
	 total-width
	 total-height)
	(redisplay-piece)
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (print-self redisplay-piece-graph-node) (stream print-depth slashify-p)
  (ignore print-depth)
  (printing-random-object (self stream :typep)
    (write unique-id :stream stream :escape slashify-p)))

(defmacro formatting-graph-node ((&optional stream &rest options) &body body)
  (declare (arglist (&optional stream
		     &key id connections
			  (drawing-mode t)
			  (drawing-options nil)
			  (id-test #'eql)
			  (dont-snapshot-variables nil))
		    &body body))
  (format-output-macro-default-stream stream)
  `(format-table-operation :format-graph-node
     ,stream
     (format-output-macro-continuation (:name formatting-graph-node
					:dont-snapshot-variables
					 ,(option-remf options :dont-snapshot-variables))
				       (ignore ,stream ignore) . ,body)
     . ,options))

(defun-in-flavor (current-graph-piece redisplay-helper-stream) ()
  (loop for piece = current-redisplay-piece then (redisplay-piece-superior piece)
	when (null piece) do (error "Could not find any graph in the piece hierarchy.")
	when (typep piece 'redisplay-piece-graph) return piece))

(defmethod (:format-graph-node redisplay-helper-stream) (continuation
							 &key id connections
							      (drawing-mode t)
							      (drawing-options nil)
							      (id-test #'eql))
  (check-table-state :format-graph-node self table-state '(:graph))
  (let ((node (letf ((table-state :graph-node)
		     (x-position x-position)
		     (y-position y-position))
		(send self :display-internal continuation self
		      :unique-id id :id-test id-test
		      :piece-flavor 'redisplay-piece-graph-node))))
    (case state
      (:collecting
	(push node (redisplay-piece-graph-nodes-to-be-displayed (current-graph-piece)))
	(connect-graph-nodes-internal self node connections
				      :drawing-mode drawing-mode
				      :drawing-options drawing-options))
      (:displaying
	(push node (redisplay-piece-graph-displayed-nodes (current-graph-piece)))))
    node))

(defmethod (redisplay-piece-collect-inferiors redisplay-piece-graph :before) (ignore)
  (setq nodes-to-be-displayed nil
	connections-to-be-displayed nil))

(defmethod (redisplay-piece-collect-inferiors redisplay-piece-graph :after) (ignore)
  (layout-graph self))

(defmethod (redisplay-piece-collect-inferiors redisplay-piece-graph-node :before) (ignore)
  (setq nodes-below nil
	nodes-above nil
	nodes-right nil
	nodes-left nil
	parent-node nil))

(defmethod (redisplay-piece-prepare-for-layout redisplay-piece-graph-node) ()
  (setq nodes-above (nreverse nodes-above)
	nodes-below (nreverse nodes-below)
	nodes-left (nreverse nodes-left)
	nodes-right (nreverse nodes-right))
  (multiple-value-setq (width height)
    (box-size new-box))
  (setq x-position -1
	y-position -1
	parent-node nil)
  (variable-makunbound total-width)
  (variable-makunbound total-height))

(defmethod (layout-graph redisplay-piece-graph) ()
  (destructuring-bind (&key (orientation *default-graph-orientation*)
			    (inverted-center *default-graph-inverted-center*)
			    (balance-evenly *default-graph-balance-evenly*)
			    (row-spacing *default-graph-row-spacing*)
			    (within-row-spacing *default-graph-within-row-spacing*)
			    (column-spacing *default-graph-column-spacing*)
			    (within-column-spacing *default-graph-within-column-spacing*)
			    (branch-point *default-graph-branch-point*)
			    (allow-overlap *default-graph-allow-overlap*)
			    &allow-other-keys)
      graph-options
    ;; Setf the default values of various options into the graph-options IV so that
    ;; (for example) draw-graph-node-connection can look at the row- and column-spacing
    ;; values that were used to draw this graph regardless of whether they were explicitly
    ;; supplied or defaulted.
    (macrolet ((remember-graph-option-defaults (&rest option-vars)
		 (let ((clauses nil))
		   (dolist (var option-vars)
		     (push `(when ,var
			      (setf (getf graph-options ',(intern (symbol-name var) 'keyword))
				    ,var))
			   clauses))
		   `(progn ,@clauses))))
      (remember-graph-option-defaults orientation inverted-center balance-evenly row-spacing
				      within-row-spacing column-spacing within-column-spacing
				      branch-point))
    ;; Compute size for all the output pieces.
    (dolist (node nodes-to-be-displayed)
      (redisplay-piece-prepare-for-layout node))
    ;; Determine real positions along the primary axis in the presence of shared and
    ;; circular links.
    (let ((primary-position-function #'redisplay-piece-graph-node-y-position)
	  (primary-position-set-function #'(setf redisplay-piece-graph-node-y-position))
	  (primary-children-function #'redisplay-piece-graph-node-nodes-below)
	  (primary-children-set-function #'(setf redisplay-piece-graph-node-nodes-below))
	  (primary-ancestor-function #'redisplay-piece-graph-node-nodes-above)
	  (primary-ancestor-set-function #'(setf redisplay-piece-graph-node-nodes-above))
	  
	  (secondary-position-function #'redisplay-piece-graph-node-x-position)
	  (secondary-set-position-function #'(setf redisplay-piece-graph-node-x-position))
	  (secondary-balance-function #'redisplay-piece-graph-node-balance-x-position)
	  (layout-function #'redisplay-piece-graph-node-x-layout)
	  
	  (primary-spacing row-spacing)
	  (within-spacing within-row-spacing)
	  
	  (primary-compute-size-function #'redisplay-piece-graph-node-compute-total-height)
	  (secondary-compute-size-function #'redisplay-piece-graph-node-compute-total-width)
	  )
      (ecase orientation
	(:vertical )
	(:horizontal
	  (setq primary-position-function #'redisplay-piece-graph-node-x-position
		primary-position-set-function #'(setf redisplay-piece-graph-node-x-position)
		primary-children-function #'redisplay-piece-graph-node-nodes-right
		primary-children-set-function #'(setf redisplay-piece-graph-node-nodes-right)
		primary-ancestor-function #'redisplay-piece-graph-node-nodes-left
		primary-ancestor-set-function #'(setf redisplay-piece-graph-node-nodes-left)
		primary-spacing column-spacing
		within-spacing within-column-spacing
		secondary-position-function #'redisplay-piece-graph-node-y-position
		secondary-set-position-function #'(setf redisplay-piece-graph-node-y-position)
		secondary-balance-function #'redisplay-piece-graph-node-balance-y-position
		layout-function #'redisplay-piece-graph-node-y-layout
		)
	  (rotatef primary-compute-size-function secondary-compute-size-function)))
      (let ((ancestor-function primary-ancestor-function)
	    (ancestor-set-function primary-ancestor-set-function)
	    (children-function primary-children-function)
	    (children-set-function primary-children-set-function))
	(when inverted-center
	  (rotatef ancestor-function children-function)
	  (rotatef ancestor-set-function children-set-function))
	(labels ((propagate-position (node position ancestor)
		   (when (> position (funcall primary-position-function node))
		     ;; union with any connections already present, so that in
		     ;; :dont-draw-duplicates t mode all connections are recorded
		     (funcall ancestor-set-function node
			      (union ancestor (funcall ancestor-function node)))
		     (funcall primary-position-set-function node position)
		     ;; Parent node is the one that puts this node bottomost on the primary
		     ;; axis and leftmost on the secondary axis; nil if this is a root.
		     (setf (redisplay-piece-graph-node-parent-node node) (first ancestor))
		     (let ((new-position (1+ position))
			   (new-ancestor (list node)))
		       (dolist (child (funcall children-function node))
			 (propagate-position child new-position new-ancestor))))))
	  ;; First start with the obvious roots.
	  (dolist (node nodes-to-be-displayed)
	    (when (null (funcall ancestor-function node))
	      (propagate-position node 0 nil)))
	  ;;+++ check for minor axis links here...
	  ;; May be leftovers if circular.
	  (dolist (node nodes-to-be-displayed)
	    (propagate-position node 0 nil)))
	;; Prune links.
	(dolist (node nodes-to-be-displayed)
	  (funcall children-set-function node
		   (delete-if-not (lambda (child)
				    (member node (funcall ancestor-function child)))
				  (funcall children-function node)))))
      (let ((root-nodes (remove-if-not (lambda (node)
					 (zerop (funcall primary-position-function node)))
				       nodes-to-be-displayed)))
	;; Compute the absolute positions along the primary axis.
	(let ((primary-axis-range (loop for node in nodes-to-be-displayed
					maximize (funcall primary-position-function node))))
	  (when inverted-center
	    (dolist (node nodes-to-be-displayed)
	      (funcall primary-position-set-function node
		       (- primary-axis-range (funcall primary-position-function node)))))
	  (incf primary-axis-range)
	  (with-stack-array (sizes primary-axis-range :initial-value 0)
	    (dolist (node nodes-to-be-displayed)
	      (maxf (aref sizes (funcall primary-position-function node))
		    (funcall primary-compute-size-function node t
			     balance-evenly within-spacing inverted-center)))
	    (let ((running-primary-axis-total 0))
	      (dotimes (i primary-axis-range)
		(let ((size (aref sizes i)))
		  (setf (aref sizes i) running-primary-axis-total)
		  (incf running-primary-axis-total (+ size primary-spacing)))))
	    (dolist (node nodes-to-be-displayed)
	      (funcall primary-position-set-function node
		       (aref sizes (funcall primary-position-function node))))))
	;; Balance along the secondary axis.
	(if (or balance-evenly (not allow-overlap))
	    ;; In this case, don't try to crowd the graph
	    (let ((running-secondary-axis-total 0))
	      (dolist (root root-nodes)
		(let ((total-size (funcall secondary-compute-size-function root nil
					   balance-evenly within-spacing inverted-center)))
		  (funcall secondary-balance-function root
			   (+ running-secondary-axis-total (floor total-size 2))
			   balance-evenly within-spacing inverted-center)
		  (incf running-secondary-axis-total (+ total-size within-spacing)))))
	    ;; Assign positions bottom up so graph is more compact:  Subtrees can overlap
	    ;; in one axis so long as they don't overlap in both.
	    (with-stack-array (fringe (length nodes-to-be-displayed) :fill-pointer 0)
	      (dolist (root root-nodes)
		(funcall layout-function root fringe within-spacing inverted-center)))))
      (when balance-evenly
	;; The tree is now balanced about the center.  However, if there
	;; is more stuff to the right than the left, it can be shoved
	;; over as a whole.  This improves the incremental redisplay
	;; case, because it keeps the graph from creeping to the right.
	(let ((min-pos (loop for node in nodes-to-be-displayed
			     minimize (funcall secondary-position-function node))))
	  (when (plusp min-pos)
	    (dolist (node nodes-to-be-displayed)
	      (funcall secondary-set-position-function node
		       (- (funcall secondary-position-function node) min-pos))))))))
  (let ((maximum-x-position nil)
	(maximum-y-position nil))
    (multiple-value-bind (graph-left graph-top)
	(box-position new-box)
      (dolist (node nodes-to-be-displayed)
	(multiple-value-bind (dx dy)
	    (multiple-value-bind (left top)
		(box-position (redisplay-piece-new-box node))
	      (values (- (+ graph-left (redisplay-piece-graph-node-x-position node)) left)
		      (- (+ graph-top (redisplay-piece-graph-node-y-position node)) top)))
	  (labels ((adjust-box (piece)
		     (let ((box (redisplay-piece-new-box piece)))
		       (multiple-value-bind (left top)
			   (box-position box)
			 (set-box-position box (+ left dx) (+ top dy))))
		     (dolist (inf (redisplay-piece-inferiors-to-be-displayed piece))
		       (adjust-box inf))))
	    (adjust-box node)))
	(multiple-value-bind (nil nil right bottom)
	    (box-edges (redisplay-piece-new-box node))
	  (maxf-or maximum-x-position right)
	  (maxf-or maximum-y-position bottom)))
      (when maximum-x-position
	(set-box-edges new-box graph-left graph-top maximum-x-position maximum-y-position)
	(setq end-cursor-x 0	;was (- maximum-x-position graph-left)
	      end-cursor-y (- maximum-y-position graph-top)))))
  ;; Fake out any pieces between the graph and the nodes.  Their new-box is all wrong,
  ;; and should be recomputed from their node children.
  (labels ((fake-out-piece (piece)
	     (unless (typep piece 'redisplay-piece-graph-node)
	       (let ((min-x 99999) (min-y 99999)
		     (max-x 0) (max-y 0))
		 (dolist (inferior (redisplay-piece-inferiors-to-be-displayed piece))
		   (fake-out-piece inferior)
		   (multiple-value-bind (left top right bottom)
		       (box-edges (redisplay-piece-new-box inferior))
		     (minf min-x left)
		     (minf min-y top)
		     (maxf max-x right)
		     (maxf max-y bottom)))
		 (set-box-edges new-box min-x min-y max-x max-y)
		 (setq end-cursor-x 0	;was (- max-x min-x)
		       end-cursor-y (- max-y min-y))))))
    (dolist (piece inferiors-to-be-displayed)
      (fake-out-piece piece))))

(defmacro define-symmetrical-node-handlers-1
	  (graph-node-balance-position graph-node-compute-total-length
	   position length total-length nodes-after nodes-before
	   graph-node-layout graph-node-shift-subtree
	   other-axis-position other-axis-length
	   graph-node-get-other-axis-position graph-node-get-other-axis-length
	   graph-node-get-position graph-node-get-length)
  `(progn
 
 (defmethod (,graph-node-balance-position redisplay-piece-graph-node)
	    (center balance-evenly within-spacing inverted-center)
   (setq ,position (- center (floor ,length 2)))
   (let ((children (if inverted-center ,nodes-before ,nodes-after)))
     (when children
       (if balance-evenly
	   (loop for child in children
		 ;; Only consider children really being displayed here
		 when (eq (redisplay-piece-graph-node-parent-node child) self)
		   maximize (,graph-node-compute-total-length child nil balance-evenly
							      within-spacing inverted-center)
		     into maximum-child-length
		   and count t into n-children
		 finally
		   (let ((running-center
			   (- center (floor (* (+ maximum-child-length within-spacing)
					       (1- n-children))
					    2))))
		     (dolist (child children)
		       ;; Only consider children really being displayed here
		       (when (eq (redisplay-piece-graph-node-parent-node child) self)
			 (,graph-node-balance-position child running-center balance-evenly
						       within-spacing inverted-center)
			 (incf running-center (+ maximum-child-length within-spacing))))))
	   (let ((running-top (- center (floor ,total-length 2))))
	     (dolist (child children)
	       ;; Only consider children really being displayed here
	       (when (eq (redisplay-piece-graph-node-parent-node child) self)
		 (let ((size (,graph-node-compute-total-length child nil balance-evenly
							       within-spacing
							       inverted-center)))
		   (,graph-node-balance-position child (+ running-top (floor size 2))
						 balance-evenly within-spacing
						 inverted-center)
		   (incf running-top (+ size within-spacing))))))))))

 (defmethod (,graph-node-compute-total-length redisplay-piece-graph-node)
	    (primary-axis-p balance-evenly within-spacing inverted-center)
   (unless (variable-boundp ,total-length)	;Cache to speed things up
     (let ((children (if inverted-center ,nodes-before ,nodes-after)))
       (setq ,total-length
	     (if (or primary-axis-p (null children))
		 ,length		;+++ check for secondary connections
		 (max ,length
		      (let* ((child-length
			       (if balance-evenly
				   (loop for child in children
					 ;; Only consider children really being displayed here
					 when (eq (redisplay-piece-graph-node-parent-node
						    child) self)
					   maximize (,graph-node-compute-total-length child
						     nil balance-evenly within-spacing
						     inverted-center))
				   (loop for child in children
					 ;; Only consider children really being displayed here
					 when (eq (redisplay-piece-graph-node-parent-node
						    child) self)
					   sum (,graph-node-compute-total-length child
						nil balance-evenly within-spacing
						inverted-center))))
			     (nchildren
			       (loop for child in children
				     count (eq (redisplay-piece-graph-node-parent-node child)
					       self))))
			(+ (if balance-evenly
			       (* child-length nchildren)
			       child-length)
			   (* within-spacing (1- nchildren)))))))))
   ,total-length)

 (defmethod (,graph-node-layout redisplay-piece-graph-node)
	    (fringe within-spacing inverted-center)
   ;; All comments in this function that refer to left, right, above, etc. are
   ;; written assuming :orientation :vertical
   ;; Assume this node goes as far to the left as possible without bumping into
   ;; another node in the fringe
   (let ((where (loop for node being the array-elements of fringe
		      as top = (,graph-node-get-other-axis-position node)
		      as bottom = (+ (,graph-node-get-other-axis-length node) top)
		      when (and (< top (+ ,other-axis-position ,other-axis-length))
				(< ,other-axis-position bottom))
			maximize (+ (,graph-node-get-position node)
				    (,graph-node-get-length node)
				    within-spacing)))
	 (children (if inverted-center ,nodes-before ,nodes-after)))
     ;; Before assigning positions to this node, assign positions to its children,
     ;; which might require this node to be moved to the right
     (let ((first-child nil)
	   ;(last-child nil)
	   (n-children 0))
       (dolist (child children)
	 ;; Only consider children really being displayed here
	 (when (eq (redisplay-piece-graph-node-parent-node child) self)
	   (unless first-child
	     (setq first-child child))
	   ;(setq last-child child)
	   (incf n-children)
	   (,graph-node-layout child fringe within-spacing inverted-center)))
       ;; Now center this node over its immediate children
       (when first-child
	 (let ((center
		 ;This would center it geometrically over the extremes of the children
		 ;(floor (+ (,graph-node-get-position first-child)
		 ;          (,graph-node-get-position last-child)
		 ;          (,graph-node-get-length last-child))
		 ;        2)
		 ;A better algorithm is to ignore the extremes and center it over the
		 ;middle child (if odd) or between the middle two children (if even).
		 ;This looks better when some subtree is extra wide, causing the children
		 ;not to be spaced evenly.
		 (multiple-value-bind (half odd) (floor n-children 2)
		   (dolist (child children)
		     ;; Only consider children really being displayed here
		     (when (eq (redisplay-piece-graph-node-parent-node child) self)
		       (when (zerop (decf half))
			 (setq first-child child))	;(nth (1- half) children)
		       (when (minusp half)
			 ;; child = (nth half children)
			 (return
			   (if (zerop odd)
			       (floor (+ (,graph-node-get-position first-child)
					 (,graph-node-get-position child)
					 (,graph-node-get-length child))
				      2)
			       (+ (,graph-node-get-position child)
				  (floor (,graph-node-get-length child)
					 2))))))))))
	   ;; If this node would be just slightly off centered over one of its
	   ;; children, jiggle it so it lines up exactly
	   (dolist (child children)
	     ;; Only consider children really being displayed here
	     (when (eq (redisplay-piece-graph-node-parent-node child) self)
	       (let ((child-center (+ (,graph-node-get-position child)
				      (floor (,graph-node-get-length child) 2))))
		 (when (< (abs (- child-center center)) 10)	;--- symbolic name??
		   (return (setq center child-center))))))
	   ;; Change to coordinate of left edge instead of coordinate of center
	   (decf center (floor ,length 2))
	   ;; If that would put us too far to the left, shift the children to the right
	   ;; Otherwise shift this node to the right so it is centered over its children
	   (if (< center where)
	       (dolist (child children)
		 ;; Only consider children really being displayed here
		 (when (eq (redisplay-piece-graph-node-parent-node child) self)
		   (,graph-node-shift-subtree child (- where center) inverted-center)))
	       (setq where center))
	   ;;--- Now ought to worry about some children being too far to the left
	   ;;--- because a later child got shifted to the right by a constraint.
	   ;;--- However, I don't see how to detect that situation without making
	   ;;--- the 'fringe' data structure a lot more complex.
	   )))
     ;; Plunk this node down
     (setq ,position where)
     ;; Add it to the fringe, possibly removing something to its left
     (loop with n = (fill-pointer fringe)
	   for i upfrom 0 while (< i n)
	   as node = (aref fringe i)
	   as top = (,graph-node-get-other-axis-position node)
	   as bottom = (+ (,graph-node-get-other-axis-length node) top) do
       (when (and ( top ,other-axis-position)
		  ( bottom (+ ,other-axis-position ,other-axis-length))
		  ( (+ where ,length)
		     (+ (,graph-node-get-position node) (,graph-node-get-length node))))
	 (copy-array-portion fringe (1+ i) n fringe i (decf n))
	 (decf i)
	 (setf (fill-pointer fringe) n)))
     (vector-push self fringe)))

 (defmethod (,graph-node-shift-subtree redisplay-piece-graph-node) (amount inverted-center)
   (incf ,position amount)
   (dolist (child (if inverted-center ,nodes-before ,nodes-after))
     ;; Only consider children really being displayed here
     (when (eq (redisplay-piece-graph-node-parent-node child) self)
       (,graph-node-shift-subtree child amount inverted-center))))
 ))

(defmacro define-symmetrical-node-handlers (&body changes)
  `(progn
     (define-symmetrical-node-handlers-1 . ,(loop for (x y) on changes by 'cddr
						  do (ignore y)
						  collect x))
     (define-symmetrical-node-handlers-1 . ,(loop for (x y) on changes by 'cddr
						  do (ignore x)
						  collect y))))

(define-symmetrical-node-handlers
  redisplay-piece-graph-node-balance-x-position redisplay-piece-graph-node-balance-y-position
  redisplay-piece-graph-node-compute-total-width
    redisplay-piece-graph-node-compute-total-height
  x-position y-position
  width height
  total-width total-height
  nodes-below nodes-right
  nodes-above nodes-left
  redisplay-piece-graph-node-x-layout redisplay-piece-graph-node-y-layout
  redisplay-piece-graph-node-x-shift-subtree redisplay-piece-graph-node-y-shift-subtree
  y-position x-position
  height width
  redisplay-piece-graph-node-y-position redisplay-piece-graph-node-x-position
  redisplay-piece-graph-node-height redisplay-piece-graph-node-width
  redisplay-piece-graph-node-x-position redisplay-piece-graph-node-y-position
  redisplay-piece-graph-node-width redisplay-piece-graph-node-height)

(defstruct (graph-connection (:constructor make-graph-connection
					   (node-1 node-2 orientation drawing-options)))
  node-1
  node-2
  orientation
  drawing-options
  presentation)

(defmethod (find-graph-node redisplay-helper-stream) (id &key (key #'identity) (test #'eql))
  (flet ((find-it (sequence)
	   (find id sequence
		 :key (lambda (node)
			(declare (downward-function))
			(funcall key (redisplay-piece-unique-id node)))
		 :test test)))
    (let ((graph (current-graph-piece)))
      (if (eq state :displaying)
	  (find-it (redisplay-piece-graph-displayed-nodes graph))
	  (find-it (redisplay-piece-graph-nodes-to-be-displayed graph))))))

(defun connect-graph-nodes (stream &rest args)
  (declare (arglist stream node connections
		    &key (drawing-mode :line)
			 (drawing-options nil)
			 (propagate-position-p t)))
  (apply #'connect-graph-nodes-internal stream args))

(defmethod (connect-graph-nodes-internal redisplay-helper-stream) (&rest args)
  (unless (eq table-state :graph)
    (error "Cannot connect nodes when in state ~S" table-state))
  (apply #'connect-graph-nodes-internal (current-graph-piece) args))

(defmethod (connect-graph-nodes-internal redisplay-piece-graph)
	   (node connections &key (drawing-mode t) (drawing-options nil)
				  (propagate-position-p t))
  (destructuring-bind (&key (orientation :vertical)
			    (default-drawing-mode :line)
			    (default-drawing-options nil)
			    &allow-other-keys)
		      graph-options
    (when (eq drawing-mode t)
      (setq drawing-mode default-drawing-mode))
    (setq drawing-options (append drawing-options default-drawing-options))
    D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;;--- compatibility with the documentation
0    (when (listp (car connections))
      (setq connections (loop for (type other) in connections collect type collect other)))
    (loop for (connection-type other) on connections by 'cddr
	  doing
      (case connection-type
	(:before
	  (setq connection-type (if (eq orientation :vertical) :above :left)))
	(:after
	  (setq connection-type (if (eq orientation :vertical) :below :right))))
      (flet ((add-graph-connection (node-1 node-2 connection-orientation)
	       (let ((drawing-mode drawing-mode))
		 (case drawing-mode
		   (:reverse-arrow
		     (setq drawing-mode :arrow)
		     (rotatef node-1 node-2))
		   (:reverse-dashed-arrow
		     (setq drawing-mode :dashed-arrow)
		     (rotatef node-1 node-2)))
		 (when (null drawing-mode)
		   (setf (getf drawing-options :invisible) t))
		 (when (member drawing-mode '(:arrow :dashed-arrow))
		   (setf (getf drawing-options :arrow) t))
		 (when (member drawing-mode '(:dashed-line :dashed-arrow))
		   (setf (getf drawing-options :dashed) t)))
	       (push (make-graph-connection node-1 node-2
					    connection-orientation drawing-options)
		     connections-to-be-displayed))
	     (add-vertical-node-link (node-above node-below)
	       (when propagate-position-p
		 (pushnew node-above (redisplay-piece-graph-node-nodes-above node-below))
		 (pushnew node-below (redisplay-piece-graph-node-nodes-below node-above))))
	     (add-horizontal-node-link (node-left node-right)
	       (when propagate-position-p
		 (pushnew node-left (redisplay-piece-graph-node-nodes-left node-right))
		 (pushnew node-right (redisplay-piece-graph-node-nodes-right node-left)))))
	(ecase connection-type
	  (:above
	    (add-vertical-node-link node other)
	    (add-graph-connection node other :vertical))
	  (:below
	    (add-vertical-node-link other node)
	    (add-graph-connection node other :vertical))
	  (:left
	    (add-horizontal-node-link node other)
	    (add-graph-connection node other :horizontal))
	  (:right
	    (add-horizontal-node-link other node)
	    (add-graph-connection node other :horizontal)))))))

(defun graph-connection-equal (connection-1 connection-2)
  (and (eq (graph-connection-node-1 connection-1) (graph-connection-node-1 connection-2))
       (eq (graph-connection-node-2 connection-1) (graph-connection-node-2 connection-2))
       (eql (graph-connection-orientation connection-1)
	    (graph-connection-orientation connection-2))
       (equal (graph-connection-drawing-options connection-1)
	      (graph-connection-drawing-options connection-2))))

(defmethod (redisplay-piece-copy-phase redisplay-piece-graph :before) (stream)
  (dolist (connection displayed-connections)
    (let ((new (find connection connections-to-be-displayed :test #'graph-connection-equal)))
      (if (and new
	       (box-equal (redisplay-piece-displayed-box (graph-connection-node-1 connection))
			  (redisplay-piece-new-box (graph-connection-node-1 connection)))
	       (box-equal (redisplay-piece-displayed-box (graph-connection-node-2 connection))
			  (redisplay-piece-new-box (graph-connection-node-2 connection))))
	  (setf (graph-connection-presentation new) (graph-connection-presentation connection))
	(let ((presentation (graph-connection-presentation connection)))
	  (if presentation
	      (graphics:erase-graphics-presentation presentation
						    :stream stream
						    :redisplay-overlapping-presentations nil)
	      (draw-graph-node-connection stream connection :erase graph-options)))
	(setq displayed-connections (delete connection displayed-connections))))))

(defmethod (redisplay-piece-display-phase redisplay-piece-graph :before) (ignore)
  (setq displayed-nodes nil))

(defmethod (redisplay-piece-display-phase redisplay-piece-graph :after) (stream)
  (setq connections-to-be-displayed (nreverse connections-to-be-displayed))
  (graphics:with-graphics-identity-transform (stream)
    (let ((transform (send-if-handles stream :border-box-transform)))
      (when transform
	(graphics:graphics-transform transform :stream stream)))
    (dolist (connection connections-to-be-displayed)
      (unless (member connection displayed-connections :test #'graph-connection-equal)
	(setf (graph-connection-presentation connection)
	      (graphics:with-output-as-graphics-presentation (stream)
		(draw-graph-node-connection stream connection :draw graph-options))))))
  (setq displayed-connections connections-to-be-displayed))

(defwhopper (redisplay-piece-call-displayer redisplay-piece-graph-node) (stream)
  (send stream :output-with-cell-left-margin (send stream :read-cursorpos)
	#'(lambda (stream)
	    (declare (downward-function))
	    (continue-whopper stream))
	stream))

(defmethod (redisplay-piece-display-phase redisplay-piece-graph-node :before) (stream)
  (multiple-value-bind (x y) (redisplay-piece-new-start-position self)
    (send stream :set-window-cursorpos x y)))

(defun draw-graph-node-connection (stream graph-connection
				   &optional (alu :draw) graph-options)
  (flet ((find-box (piece)
	   (or (redisplay-piece-displayed-box piece)
	       (redisplay-piece-new-box piece))))
    (let* ((drawing-options (graph-connection-drawing-options graph-connection))
	   (node-1 (graph-connection-node-1 graph-connection))
	   (box-1 (find-box node-1))
	   (node-2 (graph-connection-node-2 graph-connection))
	   (box-2 (find-box node-2))
	   (swap-p t)
	   x-1 x-1a y-1 y-1a x-2 y-2
	   (branch-point (getf graph-options :branch-point))
	   (inverted-center (getf graph-options :inverted-center))
	   margin)
      (check-type branch-point (member :at-parent :between-generations))
      (unless (getf drawing-options :invisible)
	(ecase (graph-connection-orientation graph-connection)
	  (:horizontal
	   (unless ( (box-center-x box-1) (box-center-x box-2))
	     (rotatef box-1 box-2)
	     (rotatef node-1 node-2)
	     (setq swap-p nil))
	   (setq margin (getf graph-options :column-spacing)
		 x-1 (box-right box-1)
		 x-1a (and (eq branch-point :between-generations)
			   (if inverted-center
			       (+ (loop for node
					    in (redisplay-piece-graph-node-nodes-left node-2)
				    maximize (box-right (find-box node)))
				  margin)
			       (- (loop for node
					    in (redisplay-piece-graph-node-nodes-right node-1)
					minimize (box-left (find-box node)))
				  margin)))
		 y-1 (box-center-y box-1)
		 x-2 (1- (box-left box-2))
		 y-2 (box-center-y box-2)))
	  (:vertical
	   (unless ( (box-center-y box-1) (box-center-y box-2))
	     (rotatef box-1 box-2)
	     (rotatef node-1 node-2)
	     (setq swap-p nil))
	   (setq margin (getf graph-options :row-spacing)
		 x-1 (box-center-x box-1)
		 y-1 (box-bottom box-1)
		 y-1a (and (eq branch-point :between-generations)
			   (if inverted-center
			       (+ (loop for node
					    in (redisplay-piece-graph-node-nodes-above node-2)
					maximize (box-bottom (find-box node)))
				  margin)
			       (- (loop for node
					    in (redisplay-piece-graph-node-nodes-below node-1)
					minimize (box-top (find-box node)))
				  margin)))
		 x-2 (box-center-x box-2)
		 y-2 (1- (box-top box-2)))))
	(when swap-p
	  (rotatef x-1 x-2)
	  (rotatef y-1 y-2))
	(multiple-value-setq (x-1 y-1)
	  (translate-from-window-coordinates stream x-1 y-1))
	(multiple-value-setq (x-2 y-2)
	  (translate-from-window-coordinates stream x-2 y-2))
	(when (and x-1a ( x-1a x-1))
	  (multiple-value-setq (x-1a nil)
	    (translate-from-window-coordinates stream x-1a y-1))
	  (apply #'graphics:draw-line x-1 y-1 x-1a y-1
		 :stream stream :alu alu :allow-other-keys t drawing-options)
	  (setq x-1 x-1a))
	(when (and y-1a ( y-1a y-1))
	  (multiple-value-setq (nil y-1a)
	    (translate-from-window-coordinates stream x-1 y-1a))
	  (apply #'graphics:draw-line x-1 y-1 x-1 y-1a
		 :stream stream :alu alu :allow-other-keys t drawing-options)
	  (setq y-1 y-1a))
	(apply (if (getf drawing-options :arrow) #'graphics:draw-arrow #'graphics:draw-line)
	       x-1 y-1 x-2 y-2 :stream stream :alu alu :allow-other-keys t drawing-options)
	))))

(compile-flavor-methods redisplay-piece-graph redisplay-piece-graph-node)

;;;; Coroutine interface, like in SGR's thing.

(defun format-graph-from-root (root-object object-printer inferior-producer
			       &key (stream *standard-output*)
				    (dont-draw-duplicates nil) (key #'identity) (test #'eql)
				    (root-is-sequence nil)	;Hmm
				    (direction :after)
				    (default-drawing-mode :line)
				    (default-drawing-options nil)
				    (cutoff-depth nil)
				    (border '(:shape :rectangle))

				    (orientation *default-graph-orientation*)
				    (balance-evenly *default-graph-balance-evenly*)
				    (row-spacing *default-graph-row-spacing*)
				    (within-row-spacing *default-graph-within-row-spacing*)
				    (column-spacing *default-graph-column-spacing*)
				    (within-column-spacing *default-graph-within-column-spacing*)
				    (branch-point *default-graph-branch-point*)
				    (allow-overlap *default-graph-allow-overlap*))
  (labels ((do-one (object depth stream &rest connections)
	     (let* ((object-id (funcall key object))
		    (node (and dont-draw-duplicates
			       (find-graph-node stream object-id :test test))))
	       (if node
		   (connect-graph-nodes stream node connections)
		   (setq node (formatting-graph-node (stream :id object-id :id-test test
							     :connections connections)
				(flet ((inside (stream)
					 (funcall object-printer object stream)))
				  (if border
				      (apply #'surrounding-output-with-border-1 #'inside
					     stream :move-cursor nil
					     (append (etypecase border
						       (list border)
						       (keyword `(:shape ,border))
						       (integer `(:thickness ,border)))
						     default-drawing-options))
				      (inside stream)))))
		   (let ((new-depth (1+ depth)))
		     (unless (and cutoff-depth ( new-depth cutoff-depth))
		       (map 'nil
			    (lambda (object)
			      (do-one object new-depth stream direction node))
			    (funcall inferior-producer object)))))
	       node)))
    (formatting-graph (stream :orientation orientation :balance-evenly balance-evenly
			      :inverted-center (member direction '(:before :left :above))
			      :default-drawing-mode default-drawing-mode
			      :default-drawing-options default-drawing-options
			      :row-spacing row-spacing :within-row-spacing within-row-spacing
			      :column-spacing column-spacing
			      :within-column-spacing within-column-spacing
			      :branch-point branch-point
			      :allow-overlap allow-overlap)
      (if root-is-sequence
	  (map 'nil
	       (lambda (object)
		 (do-one object 0 stream))
	       root-object)
	  (do-one root-object 0 stream)))))
