;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; System wide handlers and presentation translators

(defun standard-command-translator-tester (object &rest arguments
					   &key handler input-context &allow-other-keys)
  (let ((command (apply (presentation-mouse-handler-value-function handler)
			object arguments)))
    (and command
	 (standard-command-translator-tester-1 command handler input-context))))

(defun standard-command-translator-tester-1 (command handler input-context)
  (with-presentation-type-arguments (cp:command (merge-handler-and-context-presentation-types
						  handler input-context))
    (when cp::command-table
      (cp:command-in-command-table-p (first command)
				     (cp:find-command-table cp::command-table)))))


;;;; Standard handlers

(defun t-to-t-identity-translate-p (presentation-type object-type desired-type object)
  (with-type-hierarchy-for-stand-in (presentation-type object-type)
    (presentation-type-applies-p presentation-type desired-type object)))

(defun presentation-type-applies-p (presentation-type desired-type object)
  (with-key-for-cache (desired-key desired-type)
    (with-key-for-cache (type-key presentation-type)
      (stack-let ((key (list desired-key type-key)))
	(multiple-value-bind (value success)
	    (gethash key *t-to-t-select-cache*)
	  (let ((pred-or-t
		  (if success
		      value
		    (multiple-value-bind (value known-p predicate)
			(presentation-subtypep presentation-type
					       desired-type t)
		      (ignore known-p)
		      (when value
			(setq value (or predicate value)))
		      (setf (gethash (copy-tree key *handler-dynamic-area*)
				     *t-to-t-select-cache*)
			    value)
		      value))))
	    (if (not pred-or-t)
		nil
	      (if (eq pred-or-t t)
		  t
		(funcall pred-or-t object)))))))))

;;; Useful for putting in testers when you want the handler to not apply to more
;;; general contexts.  For example, you don't want a translator from D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")raw-text 0to
;;;1 si:character-style0 to apply in 1expression0 context, because it would apply to
;;; the character-level presentations instead of the larger ones.  (Even if this were
;;; not true, it would be clutter and a distraction).  The use of 1presentation-subtypep-cached
0;;; rather than exact matching means that a type which expands into 
;;; 1((and si:character-style ((satisfies fully-specified-character-style-p))))
0;;; will still match (assuming the predicate is satisfied by the object returned).

(defun handler-applies-in-limited-context-p (context limiting-context-type)
  (labels ((do-one-input-context (context)
	     (when context
	       (when (presentation-subtypep-cached
		       (presentation-input-context-presentation-type context)
		       limiting-context-type)
		 (return-from handler-applies-in-limited-context-p t)))))
    (map-over-input-contexts #'do-one-input-context context)))

(defun command-name-input-context-p (type)
  (presentation-subtypep-cached type 'cp:command-name))

(define-presentation-type top-level-command-context ()
   :abbreviation-for '(and cp:command form zwei:presentation-command))

(define-presentation-translator identity
  (t t
   :tester ((ignore &key presentation input-context)
	    (when (not (null input-context))
	      (let ((desired-type (presentation-input-context-presentation-type
				    input-context)))
		(presentation-type-applies-p (presentation-type presentation) desired-type
					     (presentation-object presentation))))))
  (object &key presentation input-context)
  (if (command-name-input-context-p
	(presentation-input-context-presentation-type input-context))
      (values object (presentation-type presentation)
	      :activate nil :dont-quote t :suffix " ")
    (values object
	    (presentation-type presentation))))

(define-presentation-translator expression-identity
  (expression t
   :priority 1.5
   :tester ((ignore &key presentation input-context)
	    (when (not (null input-context))
	      (let ((desired-type (presentation-input-context-presentation-type
				    input-context)))
		(multiple-value-bind (object object-type presentation-type)
		    (presentation-object-and-types presentation)
		  (t-to-t-identity-translate-p presentation-type object-type
					       desired-type object))))))
  (object &key presentation input-context)
  (values object
	  (if (presentation-type-applies-p (presentation-type presentation)
					   (presentation-input-context-presentation-type
					     input-context)
					   object)
	      (presentation-type presentation)
	      (type-of object))))

;; Boost the priority of identity in the case where the from and to presentation types match
;; The from-presentation-type of this can't be t or it will always be shadowed
(define-presentation-translator exact-identity
  (expression t
   :priority 6	;(+ *context-priority* *displayed-priority*)
   :tester ((ignore &key presentation input-context)
	    (when (not (null input-context))
	      (let ((desired-type
		      (presentation-input-context-presentation-type input-context))
		    (displayed-type (presentation-type presentation)))
		(with-type-decoded (desired-type-name) desired-type
		   (with-type-decoded (displayed-type-name) displayed-type
		      (and (eq desired-type-name displayed-type-name)
			   (presentation-type-applies-p displayed-type desired-type
							(presentation-object presentation)))
		      ))))))
  (object &key presentation input-context)
  (if (command-name-input-context-p
	(presentation-input-context-presentation-type input-context))
      (values object (presentation-type presentation)
	      :activate nil :dont-quote t :suffix " ")
    (values object
	    (presentation-type presentation))))


;;; Select an object regardless of how it was presented.

;;; This is really 1(presentation-subtypep ... 'raw-text)0, but faster.
(defun raw-text-presentation-p (presentation)
  (let ((ptn (presentation-type-name (presentation-type presentation))))
    ;; Much faster then using MEMBER
    (or (eql ptn 'raw-text)
	(eql ptn 'zwei:bp))))

(define-presentation-translator select-object
  (t t
   :gesture :select-object
   :menu nil
   :tester ((object &key presentation input-context)
	    (when (not (null input-context))
	      (unless (raw-text-presentation-p presentation)
		(presentation-type-applies-p (type-of object)
					     (presentation-input-context-presentation-type
					       input-context)
					     object)))))
  (object)
  (values object 'expression))

;;; Same, but for when in 1form0 context, we quote it.

(define-presentation-translator select-object-quoted
  (t form
   :gesture :select-object
   :menu nil
   :tester ((object &key presentation input-context)
	    (ignore object)
	    (and (not (null input-context))
		 (not (raw-text-presentation-p presentation)))))
  (object)
  (when object
    ;; Don't select an object of 1nil0 to
    ;; help keep down the confusion factor for people doing graphics and other things where
    ;; they don't expect a presentation to have an object.
    (typecase object
      ((or keyword boolean)
       object)
      ((or symbol cons)
       (values `',object 'form :quoted-expression 'expression))
      (t object))))

(define-presentation-translator select-expression-and-activate
  (expression t
   :gesture :select-and-activate
   :tester ((ignore &key presentation input-context)
	    (when (not (null input-context))
	      (let ((desired-type (presentation-input-context-presentation-type
				    input-context)))
		(multiple-value-bind (object object-type presentation-type)
		    (presentation-object-and-types presentation)
		  (t-to-t-identity-translate-p presentation-type object-type
					       desired-type object))))))
  (object &key presentation input-context)
  (values object
	  (if (presentation-type-applies-p (presentation-type presentation)
					   (presentation-input-context-presentation-type
					     input-context)
					   object)
	      (presentation-type presentation)
	      (type-of object))
	  :activate t))

(define-presentation-translator select-and-activate
  (t t
   :gesture :select-and-activate
   :tester ((object &key presentation input-context)
	    (when (not (null input-context))
	      (let ((desired-type (presentation-input-context-presentation-type
				    input-context)))
		(presentation-type-applies-p (presentation-type presentation) desired-type
					     object)))))
  (object &key presentation)
  (values object
	  (presentation-type presentation)
	  :activate t))

(define-presentation-translator quoted-expression
   (expression form
    :priority 1.5			;This is our primary thing for 1form 0context
    :tester ((object &key presentation input-context)
	     (ignore object)
	     ;; Kludge, don't do FORM  FORM via quoting again.
	     (and (not (presentation-subtypep-cached (presentation-type presentation) 'form))
		  (when (not (null input-context))
		    (unless (raw-text-presentation-p presentation)
		      ;; Limit this to presentations of forms or expressions.
		      (dw:presentation-subtypep-cached 'form
						       (presentation-type presentation)))))))
   (expression)
  (typecase expression
    ((or keyword boolean)
     expression)
    ((or symbol cons)
     (values `',expression 'form :quoted-expression 'expression))
    (t expression)))

(define-presentation-translator evaluated-expression
   (expression form
    :priority 1.5
    :gesture :select-and-activate
    :tester ((object &key presentation input-context)
	     (ignore object)
	     ;; Kludge, don't do FORM  FORM via quoting again.
	     (and (not (presentation-subtypep-cached (presentation-type presentation) 'form))
		  (when (not (null input-context))
		    (unless (raw-text-presentation-p presentation)
		      ;; Limit this to presentations of forms or expressions.
		      (dw:presentation-subtypep-cached 'form
						       (presentation-type presentation)))))))
   (expression)
  expression)

(defun context-limited-to-lisp-objects (presentation input-context type)
  (when input-context
    (unless (raw-text-presentation-p presentation)
      ;; Limit this to presentations of expressions and only in the context
      ;; of looking for a genuine 1form0.  This keeps the 1describe0 translators
      ;; from running when we are looking for a 1list0 or a 1cons0.
      (and (presentation-subtypep type (presentation-type presentation))
	   (block found
	     (labels ((do-one-input-context (context)
			(when context
			  (when (presentation-subtypep
				  'sys:form
				  (presentation-input-context-presentation-type context))
			    (return-from found t)))))
	       (map-over-input-contexts #'do-one-input-context input-context)))))))

(define-presentation-translator describe
   ;; Now this is only for things that clearly partake of Lisp Dharma, as visible
   ;; to the naked I.
   (expression form
    :gesture :describe
    :priority 1.5			;see comment for quoted-expression
    :tester ((object &key presentation input-context)
	     (ignore object)
	     (context-limited-to-lisp-objects presentation input-context 'expression)))
   (object &key)
  `(describe ,(typecase object
		((or keyword boolean)
		 object)
		((or symbol cons)
		 `',object)
		(t object))))

(define-presentation-translator describe-form
  (form form
   :gesture :describe
   :priority 1.5				;see comment for quoted-expression
   :tester ((object &key presentation input-context)
	    (ignore object)
	    (context-limited-to-lisp-objects presentation input-context 'form)))
   (object)
  `(describe ,object))

(define-presentation-translator inspect-expression
  (expression form
   :gesture :inspect
   :tester ((object &key presentation input-context)
	    (ignore object)
	    (context-limited-to-lisp-objects presentation input-context 'expression)))
  (object &key)
  `(inspect ,(typecase object
	       ((or keyword boolean)
		object)
	       ((or symbol cons)
		`',object)
	       (t object))))

(define-presentation-translator inspect-form
  (form form
   :gesture :inspect
   :tester ((object &key presentation input-context)
	    (ignore object)
	    (context-limited-to-lisp-objects presentation input-context 'form)))
   (object)
  `(inspect ,object))

;;--- This should translate from 1dbg:location-or-unbound0, except that there
;;--- are bootstrapping problems.  See more comments on that type.
(define-presentation-action replace
   (expression top-level-command-context
    :tester ((ignore &key presentation window)
	     (and (presentation-object-value-replace-p presentation)
		  window
		  (operation-handled-p window
				       :replace-object-value)))
    :documentation "Modify this structure slot"
    :gesture :modify)
   (ignore &key presentation window)
  (send window :replace-object-value presentation))

#||
;; The beginning of the great blip-intent heuristicating Command System.
(define-presentation-to-command-translator si:com-copy-file-to-lib
   (fs:pathname
     ;; This tester is so :Show File doesn't show up in the click-right menu
     ;; for directories and binary files
     :gesture nil
     :tester ((pathname &key presentation)
	      (and (neq (presentation-type presentation) 'fs:directory-pathname)
		   ;; ZL:GET so it doesn't blow up on strings
		   (not (zl:get (send pathname :canonical-type) :binary-file-byte-size))
		   (fs:pathname-sequentially-accessible-p pathname))))
   (pathname)
  `(copyf ,pathname ,#P"lib|host:backup:"))
||#

(define-presentation-to-command-translator si:com-show-file
   (fs:pathname
     ;; This tester is so :Show File doesn't show up in the click-right menu
     ;; for directories and binary files
     :tester ((pathname &key presentation)
	      (and (neq (presentation-type presentation) 'fs:directory-pathname)
		   ;; ZL:GET so it doesn't blow up on strings
		   (not (zl:get (send pathname :canonical-type) :binary-file-byte-size))
		   (fs:pathname-sequentially-accessible-p pathname))))
   (pathname)
  `(si:com-show-file (,pathname)))

;; This Load File handler is here just to override Show File on a path with
;; :canonical-type :bin.
(define-presentation-to-command-translator si:com-load-binary-file
   (fs:pathname
     :gesture :select
     ;; boost it over Show File when tester succeeds
     :priority 0.5
     :tester ((pathname)
	      (eq (send pathname :canonical-type) si:*default-binary-file-type*)))
   (pathname)
  `(si:com-load-file ,(list pathname)))

;; This Load File handler is for all other pathnames.  It is on no specific gesture.
;; It shouldn't show up when the other one does.
(define-presentation-to-command-translator si:com-load-file
   (fs:pathname
     :gesture nil
     :tester ((pathname &key presentation)
	      ;; Exclusive with other load file handler, but don't load directories
	      (and (neq (send pathname :canonical-type) si:*default-binary-file-type*)
		   (neq (presentation-type presentation) 'fs:directory-pathname)
		   (fs:pathname-sequentially-accessible-p pathname))))
   (pathname)
  `(si:com-load-file ,(list pathname)))

;; It would be too expensive to make this handler only work on undeleted
;; files and the next one only work on deleted files.
(define-presentation-to-command-translator si:com-delete-file
   (fs:pathname
     :gesture nil)
   (pathname)
  `(si:com-delete-file ,(list pathname)))

(define-presentation-to-command-translator si:com-undelete-file
   (fs:pathname
     :gesture nil)
   (pathname)
  `(si:com-undelete-file ,(list pathname)))

(defun presentation-menu-p (presentation window menu-types context &optional for-highlighting)
  (if (atom menu-types)
      (presentation-menu-p-internal presentation window menu-types context
				    for-highlighting)
    (loop for menu-type in menu-types
	  thereis (presentation-menu-p-internal presentation window menu-type context
						for-highlighting))))

;; If any menu item is sensitive, menu is sensitive
(defun presentation-menu-p-internal
       (presentation window menu-type context &optional for-highlighting)
  (multiple-value-bind (object object-type displayed-presentation-type)
      (presentation-object-and-types presentation)
    (ignore object)
    (let ((handler-alist (presentation-context-mouse-handlers object-type
							      displayed-presentation-type
							      context)))
      (map-over-handler-alist-and-mouse-chars-in-context
	presentation window handler-alist t context
	(lambda (handler-entry gesture mouse-char gesture-match-p)
	  (declare (dbg:invisible-frame :presentation-handler-search))
	  (ignore gesture)
	  (when gesture-match-p
	    ;; Unmodular, but I really don't want to put all of this into TEST-HANDLER.  --SWM
	    (let* ((handler (if (atom handler-entry)
				handler-entry
				(handler-cache-entry-handler handler-entry)))
		   (plist (presentation-mouse-handler-property-list handler))
		   (handler-menu (getf plist :menu t)))
	      (when (eq (if (consp handler-menu)
			    (first handler-menu)
			    handler-menu)
			menu-type)
		;; This handler belongs in this menu.  For purposes of highlighting,
		;; discount uninteresting menu items.
		(when (or (not for-highlighting)
			  (not (or (getf plist :suppress-highlighting)
				   (getf plist :defines-menu))))
		  ;; If this handler is sensitive, then the menu is sensitive and don't
		  ;; test any more handlers.
		  (when (test-handler handler-entry presentation window context
				      nil mouse-char t)
		    (return-from presentation-menu-p-internal t)))))))))))

(defmethod (presentation-near-mode presentation) (ignore)
  '(:mouse))

(define-presentation-action menu
  (t t
   :documentation "Menu"
   :gesture :menu
   :suppress-highlighting :defines-menu
   :menu nil
   :defines-menu t)
  (ignore &rest args)
  (return-from menu
    (apply #'call-presentation-menu 't args)))

(define-presentation-action blank-area-menu
   (no-type t
    :blank-area t
    :documentation "Menu"
    :gesture :menu
    :defines-menu :blank-area
    :context-independent t			;All of the suboperations are, so this can be.
    :menu nil)
   (ignore &rest args)
  (return-from blank-area-menu
    (apply #'call-presentation-menu :blank-area :label "Operation:" args)))

(defun call-presentation-menu (menu-type &key presentation original-presentation window
					      label x y
					 &allow-other-keys)
  (let ((handler-list nil))
    (map-over-presentation-mouse-handlers presentation window t
      (lambda (handler context gesture mouse-char)
	(let* ((handler-menu-type (getf (presentation-mouse-handler-property-list handler)
					:menu 't))
	       (handler-item-options nil))
	  (when handler-menu-type
	    (when (consp handler-menu-type)
	      (setf `(,handler-menu-type . ,handler-item-options) handler-menu-type))
	    (when (eq handler-menu-type menu-type)
	      (push (list* (string-trim-to-one-line
			     (presentation-mouse-handler-context-documentation
			       :handler handler
			       :gesture gesture :mouse-char mouse-char
			       :input-context context :window window
			       :presentation presentation :for-menu-p t))
			   :value (list handler context)
			   handler-item-options)
		    handler-list))))))
    (setq handler-list (delete-duplicates
			 handler-list
			 :test
			  (lambda (elem-1 elem-2)
			    (destructuring-bind (doc-1 ignore (handler-1 context-1) . ignore)
						elem-1
			      (destructuring-bind (doc-2 ignore (handler-2 context-2)
							 . ignore)
						  elem-2
				;; This eliminates some stuff that might
				;; be different, but if you cannot tell
				;; which one to select, there really
				;; isn't any point.
				(or (string= doc-1 doc-2)
				    (and (eq (presentation-mouse-handler-value-function
					       handler-1)
					     (presentation-mouse-handler-value-function
					       handler-2))
					 (or (eq context-1 context-2)
					     (getf
					       (presentation-mouse-handler-property-list
						 handler-1)
					       :context-independent)))))))))
    (setq handler-list (sort handler-list
			     #'(lambda (item-1 item-2)
				 (let ((style-1 (getf (cdr item-1) :style))
				       (style-2 (getf (cdr item-2) :style)))
				   (if (eq (not (null style-1)) (not (null style-2)))
				       (string-lessp (first item-1) (first item-2))
				       (null style-1))))))
    (when (null handler-list)
      (beep)
      (return-from call-presentation-menu nil))
    (multiple-value-bind (item mouse-char)
	(let ((presentation-type `((presentation-handler-menu-choice
				     :alist ,handler-list
				     :presentation ,presentation
				     :original-presentation ,original-presentation
				     :original-program ,(and (boundp '*program*) *program*)
				     :window ,window :x ,x :y ,y))))
	  (menu-choose-from-drawer
	    #'(lambda (stream &rest ignore)
		(loop for item in handler-list
		      collect (present item presentation-type :stream stream
				       :single-box t :allow-sensitive-inferiors nil
				       :allow-sensitive-raw-text nil)
		      do (send stream :tyo #\return)))
	    presentation-type
	    :use-redisplay nil			;Gains a little speed
	    :prompt (or label (presentation-menu-label "Operation on " presentation))
	    :near-mode (presentation-near-mode presentation window)
	    :superior (tv:mouse-default-superior window)
	    :alias-for-selected-windows (and window (send window :alias-for-selected-windows))
	    :default (presentation-menu-last-choice menu-type handler-list)))
      (when item
	(presentation-menu-update-last-choice menu-type item)
	(destructuring-bind (handler context) (third item)
	  (values (call-presentation-mouse-handler-handler :handler handler
							   :input-context context
							   :presentation presentation
							   :original-presentation
							    original-presentation
							   :mouse-char mouse-char
							   :window window :x x :y y)
		  t :already-blip-p t))))))

;;; Temporary control variable for experimentation
(defvar *remember-presentation-last-choices* t)
(defvar *presentation-menu-last-choices* ())

(defun presentation-menu-last-choice (menu-type item-list)
  (when *remember-presentation-last-choices*
    (let ((elem (assoc menu-type *presentation-menu-last-choices*)))
      (and elem (assoc (second elem) item-list :test #'string-equal)))))

(defun presentation-menu-update-last-choice (menu-type item)
  (when *remember-presentation-last-choices*
    (pushnew (list menu-type (first item)) *presentation-menu-last-choices*
	     :key #'first :replace t)))

(defun presentation-menu-label (prefix presentation)
  (when (presentation-type presentation)	;No label when null-presentation
    (string-trim-to-one-line
      (with-output-to-string (stream)
	(write-string prefix stream)
	(presentation-present-self presentation stream nil)
	(write-string ":" stream)))))

;;; Magic numbers to this suck completely, how should it really work?
(defun string-trim-to-one-line (string)
  (check-type string string)
  (let ((idx (string-search-char #\Return string)))
    (when idx
      (setq string (substring string 0 idx))))
  string)

(define-presentation-type presentation-type ()
   :history t
   :printer ((object stream)
	     (write-for-present object :stream stream
				       :pretty :data))
   :expander '(or presentation-type-name
		  (and cons (satisfies presentation-type-p))))

(define-presentation-type presentation ()
   :no-deftype t
   :printer ((presentation stream)
	     (presentation-present-self presentation stream t)))

(defmethod (presentation-present-self presentation) (stream &optional verbose)
  (when verbose
    (present type 'presentation-type :stream stream)
    (write-char #\Space stream))
  (let ((p-type type))
    ;; Force honouring of level and length
    (when (and (consp p-type) (eq (first p-type) 'expression))
      (setq p-type 'expression))
    (if verbose
	(present object p-type :stream stream)
      (present-for-documentation object p-type stream))))

(defmethod (presentation-present-self null-presentation) (stream &optional verbose)
  (when verbose
    (present 'no-type 'presentation-type :stream stream)))

(defgeneric viewspec-choices-p (presentation-type-descriptor))

(defmethod (viewspec-choices-p presentation-type-descriptor) ()
  (variable-boundp viewspec-choices))

;;; Poor man's viewspecs from presentation types
(define-presentation-action edit-viewspecs
   (t t
      :tester ((ignore &key presentation window)
	       (and (operation-handled-p window
					 :represent-presentation)
		    (let* ((type (presentation-type presentation))
			   (desc (presentation-type-descriptor type nil)))
		      (when desc
			(viewspec-choices-p desc)))))
      :documentation "Edit viewspecs"
      :gesture :edit-viewspecs
      :context-independent t
      :suppress-highlighting :within-menu)
   (ignore &key presentation window)
  (multiple-value-bind (presentation-type cvv-choices)
      (presentation-cvv-choices presentation)
    (with-presentation-input-context (nil :inherit nil) ()
	 (accept-variable-values cvv-choices
				 :own-window t
				 :prompt "Output parameters"
				 :near-mode (presentation-near-mode presentation window)))
    (send window :represent-presentation presentation presentation-type)))

(define-presentation-action represent-differently
   (t t
      :tester ((ignore &key presentation)
	       (presentation-clever-new-presentation-type
		 presentation t))
      :documentation "Reprint differently"
      :gesture :reprint-differently
      :context-independent t
      :suppress-highlighting :within-menu)
   (ignore &key presentation window)
  (send window :represent-presentation presentation
	(presentation-clever-new-presentation-type presentation)))

(defun presentation-clever-new-presentation-type (presentation &optional (for-predicate nil))
  (let* ((presentation-type (presentation-type presentation))
	 (new-presentation-type nil))
    (labels ((presentation-type-keyword (keyword &optional default)
	       (if (atom presentation-type) default
		   (getf (cdr presentation-type) keyword default)))
	     (set-presentation-type-keyword (keyword value)
	       (if for-predicate
		   (return-from presentation-clever-new-presentation-type t)
		   (unless new-presentation-type
		     (setq new-presentation-type (if (atom presentation-type)
						     (list (list presentation-type))
						     (copy-list presentation-type))))
		   (setf (getf (cdr new-presentation-type) keyword) value)))
	     (toggle-presentation-type-keyword (keyword default)
	       (set-presentation-type-keyword keyword
					      (not (presentation-type-keyword keyword
									      default))))
	     (find-superior-expression-with-keyword (keyword)
	       ;; The global state is really the superior state.
	       (loop until (neq (presentation-type-keyword keyword 'not-present) 'not-present)
		     for pres = presentation then superior
		     as superior = (presentation-superior pres)
		     while superior
		     as new-type = (presentation-type superior)
		     while (eq (presentation-type-name new-type) 'expression)
		     do (setq presentation-type new-type))))
      ;; Not PRESENTATION-SUBTYPECASE because presentation arguments aren't inherited.
      (case (presentation-type-name presentation-type)
	(expression
	  (let ((object (presentation-object presentation)))
	    (typecase object
	      (rational
		(let* ((original-presentation
			 ;; Find the most-superior presentation for this object
			 ;; so that we can find the base and radix it was originally
			 ;; presented with.
			 (loop for p = presentation then superior
			       as superior = (presentation-superior p)
			       while (and superior (eq object (presentation-object p)))
			       finally (return p)))
		       (original-type
			 (presentation-type original-presentation))
		       (original-base
			 (if (atom original-type) *print-base*
			     (getf (cdr original-type) :base *print-base*)))
		       (original-radix
			 (if (atom original-type) *print-radix*
			     (getf (cdr original-type) :radix *print-radix*))))
		  (find-superior-expression-with-keyword :base)
		  ;; The intent of this is to first reprint the number with the
		  ;; radix explicitly displayed, then to show the number in base
		  ;; 8 (or 10 if it started in 8), then base 10 (or 8 if it started
		  ;; in 10), then show it as it was originally presented.  Of
		  ;; course, "duplicate steps" are elided, so things printed in
		  ;; base 8 or 10 only cycle through three states.  Also skip the
		  ;; initial step of adding a radix specifier if the base is default,
		  ;; since switching to another base is more interesting.
		  (let* ((old-base (presentation-type-keyword :base *print-base*))
			 (old-radix (presentation-type-keyword :radix *print-radix*))
			 (new-base (if (eql old-base original-base)
				       (if (and (null original-radix)
						(null old-radix)
						(not (eql original-base *print-base*)))
					   original-base
					 (if (eql original-base 10) 8 10))
				     (if (eql old-base 10) 8 original-base)))
			 (new-radix (if (eql new-base original-base)
					(if (and (null original-radix)
						 (null old-radix))
					    t original-radix)
				      t)))
		    (set-presentation-type-keyword :base new-base)
		    (set-presentation-type-keyword :radix new-radix))))
	      (float
		(find-superior-expression-with-keyword :exact-float-value)
		(toggle-presentation-type-keyword :exact-float-value
						  *print-exact-float-value*))
	      (array
		(cond ((named-structure-p object)
		       (find-superior-expression-with-keyword :structure-contents)
		       (toggle-presentation-type-keyword :structure-contents
							 *print-structure-contents*))
		      (t
		       (find-superior-expression-with-keyword :array)
		       (toggle-presentation-type-keyword :array *print-array*))))
	      (list
		(set-presentation-type-keyword :length nil)
		(set-presentation-type-keyword :level nil)))))))
    new-presentation-type))

(define-presentation-action system-menu
   (t t
      :tester ((ignore &key window)
	       (console-system-menu-enabled (tv:sheet-console window)))
      :documentation "System menu"
      :gesture :system-menu
      :context-independent t
      ;; Don't want everything highlighting when shift pressed.
      :suppress-highlighting t
      :menu (t :style (nil :italic nil)))
   (ignore &key window)
  (tv:mouse-call-system-menu (send window :screen)))

(define-presentation-action system-menu-blank-area
   (no-type t
	    :tester ((ignore &key window)
		     (console-system-menu-enabled (tv:sheet-console window)))
	    :documentation "System menu"
	    :gesture :system-menu
	    :context-independent t
	    :blank-area t
	    :menu (:blank-area :style (nil :italic nil)))
   (ignore &key window)
  (tv:mouse-call-system-menu (send window :screen)))

(define-presentation-action window-operation-menu
   (t t
      :tester true
      :documentation "Window operation menu"
      :gesture :window-operation-menu
      :context-independent t
      :suppress-highlighting t
      :menu (t :style (nil :italic nil)))
   (ignore &key window x y)
  (let ((window-x x) (window-y y))
    (when (operation-handled-p window :convert-to-absolute-coordinates)
      ;; Dealing with the old window system, we'd better use its coordinate system.
      (coordinate-convert-points window :relative :outside window-x window-y))
    (process-run-function "Edit Window" #'tv:call-window-editor window
			  :alias nil
			  :window-x window-x :window-y window-y)))

(define-presentation-action window-operation-menu-blank-area
   (no-type t
    :tester true
    :documentation "Window operation menu"
    :gesture :window-operation-menu
    :context-independent t
    :suppress-highlighting t
    :blank-area t
    :menu (:blank-area :style (nil :italic nil)))
   (ignore &key window x y)
  (let ((window-x x) (window-y y))
    (when (operation-handled-p window :convert-to-absolute-coordinates)
      ;; Dealing with the old window system, we'd better use its coordinate system.
      (coordinate-convert-points window :relative :outside window-x window-y))
    (process-run-function "Edit Window" #'tv:call-window-editor window
			  :alias nil
			  :window-x window-x :window-y window-y)))

(define-presentation-action select-window
   (no-type t
    :tester ((ignore &key window)
	     (neq (send window :alias-for-selected-windows)
		  (let ((sw (sys:console-selected-window (tv:sheet-console window))))
		    (and sw (send sw :alias-for-selected-windows)))))
    :documentation "Select this window"
    :context-independent t
    :do-not-compose t
    :menu (:blank-area :style (nil :italic nil)))
   (ignore &key window)
  (send window :mouse-select))

;;;; Text only commands.  These are made available only in input buffer
;;;; context, even though some might work elsewhere to keep the noise
;;;; down.
(define-presentation-type raw-text ()
   :expander 't)

(define-presentation-type si:history-and-element ()
   :printer ((elem stream)
	     (write-string
	       (let ((string (cdr elem)))
		 (if (and (flavor:find-flavor 'zwei:kill-ring-interval nil)
			  (typep string 'zwei:kill-ring-interval))
		     (zwei:string-interval string)
		     (string string)))
	       stream)))

(define-presentation-translator yank-from-history
   (si:history-and-element si:input-editor
    :documentation ((history-and-element)
		    (present-to-string
		      history-and-element
		      'si:history-and-element))
    :tester true)
   (history-and-element)
  (send (car history-and-element) :note-element-yanked (cdr history-and-element))
  (cdr history-and-element))

(define-presentation-translator yank-word
   (raw-text si:input-editor
    :tester ((string-and-index)
	     (context-delimited-indices-around-index
	       (first string-and-index)
	       (second string-and-index)
	       (presentation-input-context-presentation-type
		 *presentation-input-context*)))
    :do-not-compose t
    :documentation ((string-and-index &rest args)
		    (let ((string (first string-and-index)))
		      (multiple-value-bind (start-index end-index)
			  (context-delimited-indices-around-index
			    string (second string-and-index)
			    (presentation-input-context-presentation-type
			      *presentation-input-context*))
			(and start-index
			     (apply #'yank-word-documentation-interval
				    string start-index end-index args)))))
    :gesture :yank-word
    :menu :marking-and-yanking)
   (string-and-index)
  (context-delimited-string-around-index
    (first string-and-index) (second string-and-index)
    ;; Not the context we matched, that's inside the interesting one.
    (presentation-input-context-presentation-type *presentation-input-context*)))

(defun yank-word-documentation-interval (string start-index end-index
					 &key string-buffer &allow-other-keys)
  (setq start-index (or (string-search-not-set si:*whitespace* string :end end-index
					       :start start-index)
			end-index)
	end-index (let ((idx (string-search-not-set si:*whitespace* string
						    :end end-index :start start-index
						    :from-end t)))
		    (if idx (1+ idx) start-index)))
  (let ((length (- end-index start-index)))
    (if (null string-buffer)
	(setq string-buffer (make-array length :element-type 'character))
	(when (> length (sys:array-length string-buffer))
	  (sys:adjust-array-size string-buffer length))
	(setf (fill-pointer string-buffer) length))
    (copy-string-eliminating-style string start-index end-index
				   string-buffer 0 length)
    string-buffer))

;;; I cannot seem to find an installed version of this.
(defun copy-string-eliminating-style (from-string from-start from-end
				      to-string to-start to-end)
  (if (= (array-type-field from-string) art-string)
      (copy-array-portion from-string from-start from-end to-string to-start to-end)
      (let* ((from-length (- from-end from-start))
	     (to-length (- to-end to-start)))
	(let ((from-string from-string) (to-string to-string))
	  (declare (array-register-1d from-string to-string))
	  (let ((index-from from-start)
		(index-to to-start))
	    (let ((elements (min from-length to-length)))
	      (loop repeat elements
		    do  (let ((char (%1d-aref from-string index-from)))
			  (setf (si:char-style-index char) 0)
			  (%1d-aset char to-string index-to))
			(incf index-from)
			(incf index-to)))
	    (when (< index-to to-end)
	      (loop do (%1d-aset #\  to-string index-to)
		       (incf index-to)
		    while (< index-to to-end))))))))

(define-presentation-action mark-word
   (raw-text si:input-editor
    :tester ((string-and-index &key window)
	     (and (operation-handled-p window :add-region-string)
		  (context-delimited-indices-around-index
		    (first string-and-index)
		    (second string-and-index)
		    (presentation-input-context-presentation-type
		      *presentation-input-context*))))
    :documentation ((string-and-index)
		    (if (= (second string-and-index)
			   (fill-pointer (first string-and-index)))
			"Mark this line"
		      "Mark this word"))
    :gesture :mark-word
    :menu :marking-and-yanking)
   (string-and-index &key presentation window)
  (multiple-value-bind (start-index end-index)
      (context-delimited-indices-around-index
	(first string-and-index) (second string-and-index)
	(presentation-input-context-presentation-type *presentation-input-context*))
    (send window :add-region-string
	  (text-displayed-presentation-displayed-string presentation)
	  start-index end-index)))

(defun context-delimited-string-around-index (string index presentation-type)
  (multiple-value-bind (index-before index-after)
      (context-delimited-indices-around-index string index presentation-type)
    (when index-before
      (substring string index-before index-after))))

;; Pretty measly for now: no context specific delimiters, no multiple-line expressions
;; (which would be difficult because STRING only refers to a single line)
;; The syntax rules used by this are copied from ZWEI:DEFAULT-MARK-THING
;; Kill smarts are assumed to be the responsibility of the yanker, not here
(defun context-delimited-indices-around-index (string index presentation-type)
  (ignore presentation-type)
  (if (= index (fill-pointer string))
      (values 0 index)
    (let* ((string string) (char (aref string index)) start end tem)
      (declare (sys:array-register string))
      (cond ((or (char-equal char #\space) (char-equal char #\tab))
	     (if (string-search-not-set '(#\space #\tab) string :end index :from-end t)
		 ;; Between words, take next word
		 (return-from context-delimited-indices-around-index
		   (context-delimited-indices-around-index string
		     (or (string-search-not-set '(#\space #\tab) string :start index)
			 (fill-pointer string))
		     presentation-type))
		 ;; In indentation, take whole line
		 (setq start 0 end (fill-pointer string))))
	    ((setq tem (assoc char '((#\( . #\)) (#\[ . #\]) (#\< . #\>) (#\{ . #\}))
			      :test #'char-equal))
	     (setq tem (cdr tem))
	     (setq start index)
	     (setq end (loop for i from index below (fill-pointer string) with level = 0
			     as ch = (aref string i) finally (return i) do
			 (cond ((char-equal ch char) (incf level))
			       ((char-equal ch tem)
				(unless (plusp (decf level))
				  (return (1+ i))))))))
	    ((setq tem (rassoc char '((#\( . #\)) (#\[ . #\]) (#\< . #\>) (#\{ . #\}))
			       :test #'char-equal))
	     (setq tem (car tem))
	     (setq end (1+ index))
	     (setq start (loop for i downfrom index to 0 with level = 0
			       as ch = (aref string i) finally (return 0) do
			   (cond ((char-equal ch char) (incf level))
				 ((char-equal ch tem)
				  (unless (plusp (decf level))
				    (return i)))))))
	    (t
	     (let ((si:*syntax-table* 'zwei:*atom-word-syntax-table*))
	       (setq start (loop for i downfrom index to 0 finally (return 0) do
			     (unless (si:ie-alphabetic? (aref string i))
			       (return (1+ i)))))
	       (setq end (loop for i from index below (fill-pointer string) finally (return i)
			       do (unless (si:ie-alphabetic? (aref string i))
				    (return i)))))))
      (when (> end start)
	(values start end)))))

(define-presentation-translator yank-marked-text
   (t si:input-editor
    :tester ((ignore &key window)
	     (send-if-handles window :marked-text))
    :documentation "Yank marked text"
    :gesture ()
    :menu :marking-and-yanking
    :do-not-compose t
    :blank-area t)
   (ignore &key window)
  (send window :marked-text :return-as-string t :unmark t))

(define-presentation-translator yank-from-kill-ring
   (t si:input-editor
    :tester ((ignore)
	     (plusp (send zwei:*kill-history* :length)))
    :documentation "Yank top of kill ring"
    :gesture ()
    :menu :marking-and-yanking
    :do-not-compose t
    :blank-area t)
   (ignore)
  (let ((interval (send zwei:*kill-history* :yank)))
    (unless (stringp interval)
      (setq interval (zwei:string-interval interval)))))

(define-presentation-action save-marked-text
   (t si:input-editor
    :tester ((ignore &key window)
	     (send-if-handles window :marked-text))
    :documentation "Push marked text on kill ring"
    :gesture ()
    :menu :marking-and-yanking
    :blank-area t)
   (ignore &key window)
  (kill-ring-push-marked-text window))

(define-presentation-action unmark-marked-text
   (t si:input-editor
    :tester ((ignore &key window)
	     (send-if-handles window :marked-text))
    :documentation "Unmark marked text"
    :gesture ()
    :menu :marking-and-yanking
    :blank-area t)
   (ignore &key window)
  (send window :marked-text :unmark t))

(defun kill-ring-push-marked-text (window)
  (let ((string (send window :marked-text :return-as-string t :unmark t)))
    (when string
      (zwei:kill-ring-push string))))

(define-presentation-translator clear-marked-text
   (t si:input-editor
    :tester ((ignore &key window)
	     (and (send-if-handles window :marked-text)
		  (operation-handled-p window :compress-output-history)))
    :documentation "Clear marked text"
    :gesture ()
    :menu :marking-and-yanking
    :do-not-compose t
    :blank-area t)
   (ignore &key window)
  (send window :compress-output-history :marked-text :clear))

(define-presentation-action marking-and-yanking-menu
  (t si:input-editor
   :documentation "Marking and yanking menu"
   :gesture :marking-and-yanking-menu
   :menu (t :style (nil :italic nil))
   :defines-menu :marking-and-yanking)
  (ignore &key presentation (original-presentation presentation) window x y)
  (let ((use-presentation (or original-presentation presentation)))
    (return-from marking-and-yanking-menu
      (call-presentation-menu :marking-and-yanking 
			      :label (when (eq use-presentation *null-presentation*)
				       "Marking and yanking operations")
			      :presentation use-presentation
			      :window window :x x :y y))))

(define-presentation-action marking-and-yanking-menu-blank-area
  (no-type si:input-editor
   :documentation "Marking and yanking menu"
   :gesture :marking-and-yanking-menu
   :menu (:blank-area :style (nil :italic nil))
   :defines-menu :marking-and-yanking
   :blank-area t)
  (ignore &key presentation (original-presentation presentation) window x y)
  (let ((use-presentation (or original-presentation presentation)))
    (return-from marking-and-yanking-menu-blank-area
      (call-presentation-menu :marking-and-yanking 
			      :label (when (eq use-presentation *null-presentation*)
				       "Marking and yanking operations")
			      :presentation use-presentation
			      :window window :x x :y y))))

(define-presentation-action click-and-hold-mark-region
   (t si:input-editor
    :tester ((ignore &key window)
	     (operation-handled-p window :displayed-strings))
    :documentation "Mark a region starting with this position"
    :gesture :hold-and-mark-region
    :menu ()
    :blank-area t)
   (thing &key presentation window x y)
  (apply #'click-and-hold-mark-region
	 window x y
	 (when (raw-text-presentation-p presentation)
	   (list (text-displayed-presentation-displayed-string presentation)
		 (second thing)))))

(define-presentation-action click-and-hold-mark-region-menu
   (t si:input-editor
    :tester ((ignore &key window)
	     (operation-handled-p window :displayed-strings))
    :documentation "Mark a region using the mouse"
    :gesture ()
    :menu :marking-and-yanking
    :blank-area t)
   (ignore &key window)
  (click-and-hold-mark-region window))

(defun click-and-hold-mark-region (window &optional start-x start-y start-dstring start-index)
  (unless (and start-x start-y)
    (multiple-value-setq (start-x start-y)
      (tracking-mouse (window :who-line-documentation-string "Start region here.")
	(:mouse-click (click x y)
	 (unless (eql click #\mouse-l)
	   (signal 'sys:abort))
	 (return (values x y))))))
  (unless start-dstring
    (multiple-value-setq (start-dstring start-index)
      (let* ((*allow-sensitive-raw-text-override* t)
	     (presentation (send window :displayed-presentation-at-position start-x start-y)))
	(when (and presentation
		   (raw-text-presentation-p presentation))
	  (values (text-displayed-presentation-displayed-string presentation)
		  (second (presentation-object presentation)))))))
  (let ((last-region-strings nil)
	(region-strings nil))
    (tracking-mouse (window :who-line-documentation-string
			    "Mark region while button is held down.")
      (:release-mouse ()
       (return-from click-and-hold-mark-region nil))
      (:mouse-motion-hold (end-x end-y)
       (setq region-strings (region-strings-between-cursorposes window
								start-x start-y
								end-x end-y
								start-dstring start-index))
       (loop for elem in last-region-strings
	     unless (member elem region-strings :test #'equal)
	       do (lexpr-send window :delete-region-string elem))
       (loop for elem in region-strings
	     unless (member elem last-region-strings :test #'equal)
	       do (lexpr-send window :add-region-string elem))
       (setq last-region-strings region-strings)))))


(defun region-strings-between-cursorposes (window start-x start-y end-x end-y
					   start-dstring start-index)
  (let ((highlighting-mode (case (and (boundp 'zwei:*region-marking-mode*)
				      zwei:*region-marking-mode*)
			     (:underline :underline)
			     (:reverse-video :inverse-video)
			     (otherwise :underline))))
    (multiple-value-bind (end-dstring end-index)
	(let* ((*allow-sensitive-raw-text-override* t)
	       (presentation (send window :displayed-presentation-at-position end-x end-y)))
	  (when (and presentation
		     (raw-text-presentation-p presentation))
	    (values (text-displayed-presentation-displayed-string presentation)
		    (second (presentation-object presentation)))))
      (if (and start-dstring (eq start-dstring end-dstring))
	  (list (list start-dstring (min start-index end-index) (max start-index end-index)
		      highlighting-mode nil))
	(let* ((forward-p (multiple-value-bind (y1 y2)
			      (cond ((and start-dstring end-dstring)
				     (values (box-top
					       (presentation-displayed-box start-dstring))
					     (box-top
					       (presentation-displayed-box end-dstring))))
				    (start-dstring
				     (values (box-top
					       (presentation-displayed-box start-dstring))
					     end-y))
				    (end-dstring
				     (values start-y
					     (box-bottom
					       (presentation-displayed-box end-dstring))))
				    (t
				     (values start-y end-y)))
			    (if (= y2 y1)
				(> end-x start-x)
				(> y2 y1))))
	       (region-start-y (if forward-p
				   (if start-dstring
				       (box-top (presentation-displayed-box start-dstring))
				       start-y)
				   (if end-dstring
				       (box-top (presentation-displayed-box end-dstring))
				       end-y)))
	       (region-end-y (if (not forward-p)
				 (if start-dstring
				     (box-bottom (presentation-displayed-box start-dstring))
				     start-y)
				 (if end-dstring
				     (box-bottom (presentation-displayed-box end-dstring))
				     end-y)))
	       (region-start-x start-x)
	       (region-end-x end-x)
	       (region-start-dstring start-dstring)
	       (region-end-dstring end-dstring)
	       (region-strings nil))
	  (when (not forward-p)
	    (rotatef region-start-x region-end-x)
	    (rotatef region-start-dstring region-end-dstring))
	  (send window :map-over-overlapping-presentations nil region-start-y nil region-end-y
		#'(lambda (displayed-string)
		    (cond ((eq displayed-string start-dstring)
			   (push (list displayed-string
				       (if forward-p start-index 0)
				       (if forward-p
					   (string-length
					     (displayed-string-string displayed-string))
					   start-index)
				       highlighting-mode (null end-dstring))
				 region-strings))
			  ((eq displayed-string end-dstring)
			   (push (list displayed-string
				       (if forward-p 0 end-index)
				       (if forward-p
					   end-index
					   (string-length
					     (displayed-string-string displayed-string)))
				       highlighting-mode (null start-dstring))
				 region-strings))
			  ((multiple-value-bind (left top right bottom)
			       (box-edges (presentation-displayed-box displayed-string))
			     (and (or (> top region-start-y)
				      (and (= top region-start-y)
					   (> left region-start-x))
				      (and (null region-start-dstring)
					   (> bottom region-start-y)
					   (> left region-start-x)))
				  (or (< bottom region-end-y)
				      (and (= bottom region-end-y)
					   (< right region-end-x))
				      (and (null region-end-dstring)
					   (< top region-end-y)
					   (< right region-end-x)))))
			   (push (list displayed-string 0
				       (string-length
					 (displayed-string-string displayed-string))
				       highlighting-mode t)
				 region-strings))))
		:presentations nil :strings t)
	  (nreverse region-strings))))))

(define-presentation-action extend-marked-text
   (t si:input-editor
    :tester ((ignore &key window)
	     (and (operation-handled-p window :displayed-strings)
		  (send-if-handles window :marked-text)))
    :documentation "Extend marked text"
    :gesture nil
    :menu :marking-and-yanking
    :do-not-compose t
    :blank-area t)
   (ignore &key window x y)
  ;; Find the nearest end of some marked text, using linear text string
  ;; distance, not as-the-crow-flies distance, so we don't skip any lines
  (let ((nearest-x 0) (nearest-y most-positive-fixnum) nearest-dstring nearest-index)
    (loop for pres in (send window :marked-text)
	  as string = (displayed-string-string pres)
	  as style = (displayed-string-default-character-style pres)
	  as box = (presentation-displayed-box pres)
	  as left = (box-left box)
	  as ypos = (box-top box) do
      (loop for interval in (displayed-string-highlighted-intervals pres) do
	(flet ((try-point (index)
		 (let ((xpos (send window :string-length string 0 index nil style left)))
		   (when (if (= ypos nearest-y)
			     (< (abs (- xpos x)) (abs (- nearest-x x)))
			     (< (abs (- ypos y)) (abs (- nearest-y y))))
		     (setq nearest-x xpos
			   nearest-y ypos
			   nearest-dstring pres
			   nearest-index index)))))
	  (try-point (first interval))		;first character in marked text
	  (try-point (second interval)))))	;last character +1 in marked text
    ;; Always include the character that was pointed at by the mouse gesture
    (when (or (< nearest-y y)
	      (and (= nearest-y y) (< nearest-x x)))
      (let* ((*allow-sensitive-raw-text-override* t)
	     (presentation (send window :displayed-presentation-at-position x y)))
	(when (and presentation
		   (raw-text-presentation-p presentation))
	  (let* ((dstring (text-displayed-presentation-displayed-string presentation))
		 (string (displayed-string-string dstring))
		 (box (presentation-displayed-box dstring))
		 (style (displayed-string-default-character-style dstring)))
	    (with-character-style (style window)
	      (setq x (send window :compute-motion string 0 nil (box-left box) (box-top box)
						   nil x (box-top box))))))))
    ;; Mark the text between here and there
    (dolist (elem (region-strings-between-cursorposes window nearest-x nearest-y x y
						      nearest-dstring nearest-index))
      (lexpr-send window :add-region-string elem))))

(defmacro with-in-band-menu ((&rest options) &body body)
  `(with-presentation-input-context (`((in-band-menu) . ,',options)) ()
	(progn . ,body)
      ))

(define-presentation-type in-band-menu (() &key name))

(define-presentation-translator in-band-menu
   (no-type in-band-menu
    :gesture :menu
    :menu nil
    :blank-area t
    :documentation
    ((ignore &key input-context)
     (let ((type (presentation-input-context-presentation-type
		   input-context)))
       (or (and (listp type) (getf (cdr type) :name))
	   "Menu"))))
   (ignore)
  (values t 'in-band-menu :once-only t))

;;; Support for displaying help in a pop-up window
;;; See the function DISPLAY-HELP

(defun display-own-window-help (help-window near-window label continuation stream)
  (declare (values help-window))
  (declare (sys:downward-funarg continuation))
  (ignore stream)
  (cond (help-window
	 (send help-window :deactivate))		;pop down so can change size cleanly
	(t
	 (setq help-window (allocate-resource 'dynamic-window
					      (tv:sheet-superior near-window)
					      :temporary-p t :blinker-p nil
					      ;; This next line gives it a scroll bar that
					      ;; is only visible when the help doesn't fit
					      :margin-components *menu-choose-margin-choices*
					      ))
	 (send help-window :set-label (format nil "Help for ~A" label))))
  (send help-window :clear-history)
  (send help-window :full-screen)		;continuation-output-size might depend on width
  (loop with *default-display-possibilities-query-cutoff-length* = nil	;suppress query
	with *help-displayer* = 'funcall	;don't recurse
	with (width height)
	for overlap = nil then t do
    (multiple-value-setq (width height)
      (continuation-output-size continuation help-window))
    (send help-window :set-inside-size width height)
    (position-window-near-carefully help-window `(:window ,near-window))
    (when (tv:sheet-overlaps-sheet-p help-window near-window)
      ;; We'd rather scroll through the help than have the windows overlap
      (let* ((superior-height (tv:sheet-inside-height (tv:sheet-superior near-window)))
	     (available-height (- superior-height (tv:sheet-height near-window))))
	(cond ((and (> available-height (* superior-height 0.4))
		    (< available-height (tv:sheet-height help-window)))
	       (send help-window :set-size (tv:sheet-width help-window) available-height)
	       (position-window-near-carefully help-window `(:window ,near-window))))))
    (cond ((and (not overlap)
		(tv:sheet-overlaps-sheet-p help-window near-window))
	   ;; The two windows overlap, so go around the loop again with a bigger display
	   (setq continuation (let ((continuation continuation))
				(lambda (stream)
				  (funcall continuation stream)
				  (format stream "~&Press any key to remove this window: ")))))
	  (t
	   (send help-window :expose nil :clean)
	   ;; Must truncate output because if the output ends in a carriage return,
	   ;; continuation-output-size doesn't count the blank line at the end
	   (with-output-truncation (help-window :horizontal t :vertical t)
	     (funcall continuation help-window))
	   ;; If the two windows overlap, can't leave the help window up while interacting
	   ;; with the other window, so let user press a key to pop it down
	   (when overlap
	     (tv:window-call (help-window :deactivate)
	       (send help-window :clear-input)
	       (send help-window :tyi)))
	   (return))))
  help-window)

(defun deallocate-help-window (help-window)
  (when help-window
    (send help-window :deactivate)
    (deallocate-resource 'dynamic-window help-window)))
