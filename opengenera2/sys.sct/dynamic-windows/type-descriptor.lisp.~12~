;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun get-type-property-stack (presentation-type property function &key (error-p t))
  (declare (sys:downward-funarg function)
	   (dbg:invisible-frame :accept-internals))
  (map-over-type-hierarchy presentation-type t 'get-type-property-stack
   (lambda (type key predicate)
     (declare (ignore key predicate))
     (let ((type-name (presentation-type-name type)))
       (multiple-value-bind (val prop-function)
	   (new-get-symbol-type-property type-name property)
	 (when val
	   (return-from get-type-property-stack
	     (funcall function val type prop-function)))))))
  (when error-p
    (error "No ~S property for the type ~S was found."
	   property presentation-type)))


(defun new-get-symbol-type-property (name function)
  (declare (sys:downward-funarg function))
  (let ((descriptor (symbol-presentation-type-descriptor name)))
    ;; We don't search up the hierarchy in this function, the caller does that, so it can
    ;; handle presentation-arguments, etc.
    (when descriptor
      (funcall function name))))


(defmacro define-presentation-type-descriptor
	  (&key arglists other-functions other-values)
  (let ((handler-instance-vars
	  (loop for (handler-name) in arglists
		collect `,handler-name)))
    (flet ((define-functions-for-variables (var-list &optional writable)
	     (loop for var-spec in var-list
		   for var = (if (atom var-spec) var-spec (car var-spec))
		   for accessor-name = (intern (string-append "PRESENTATION-TYPE-" var) "DW")
		   collect
		   `(defgeneric ,accessor-name (presentation-type)
		      (:function
			(funcall (flavor:generic ,accessor-name)
				 (if (not (instancep presentation-type))
				     (presentation-type-descriptor presentation-type)
				   ;; Not a symbol or list, must be a type-descriptor.
				   presentation-type))))
		   when writable
		     collect
		       `(defgeneric (setf ,accessor-name) (presentation-type value)
			  (:function
			    (funcall (flavor:generic (setf ,accessor-name))
				     (if (not (instancep presentation-type))
					 (presentation-type-descriptor presentation-type)
				       ;; Not a symbol or list, must be a type-descriptor.
				       presentation-type)
				     value)))))
	   (define-specs-for-functions (functions)
	     (loop for fun-var in functions
		   collect
		     `(defmethod (fdefinition-location-internal presentation-type-descriptor
								,fun-var)
				 (&optional (error-p t))
			(ignore error-p)
			(locf ,fun-var)))))
      `(progn
	 (defparameter *presentation-function-arglists*
		       ',arglists)
	 (defparameter *presentation-function-valid-specs*
		       '(,@handler-instance-vars ,@other-functions))
	 ,@(define-functions-for-variables handler-instance-vars)
	 ,@(define-functions-for-variables other-functions)
	 ,@(define-functions-for-variables other-values t)
	 (defflavor presentation-type-descriptor
		 (name ,@handler-instance-vars
		       ,@other-functions
		       ,@other-values)
		 ()
	   :initable-instance-variables
	   (:conc-name presentation-type-)
	   (:readable-instance-variables
	    ,@handler-instance-vars
	    ,@(loop for f in other-functions
		    collect (if (atom f) f (car f)))
	    ,@(loop for v in other-values
		    collect (if (atom v) v (car v))))
	   (:writable-instance-variables
	    ,@(loop for v in other-values
		    collect (if (atom v) v (car v))))
	   (:init-keywords :data-arguments-required :disallow-atomic-type
			   :explicit-type-function :cl-type-allowed :version)
	   (:default-init-plist :area *presentation-type-area*))
	 ,@(define-specs-for-functions handler-instance-vars)
	 ,@(define-specs-for-functions other-functions)))))

;;; Define a function on a type name that really is a generic on the
;;; descriptor.

(defmacro defmethod-type-descriptor ((generic-function flavor &key (search-p t))
				     arglist &body body
				     &environment env)
  (multiple-value-bind (required apply lambda-list)
      (lt:lambda-list-arguments arglist)
    (let ((declarations (assoc 'declare (si:find-body-declarations body env arglist))))
      `(progn (defgeneric ,generic-function (name ,@lambda-list)
		(declare (sys:function-parent
			   (flavor:method ,generic-function ,flavor)
			   defmethod-type-descriptor))
		(declare (arglist . (name ,@arglist)))
		,@(when declarations
		    (list declarations))
		(:function
		  ,@(when (assoc 'sys:downward-funarg (cdr declarations))
		      `((declare ,(assoc 'sys:downward-funarg (cdr declarations)))))
		 ,@(find-lambda-vars arglist)
		 (let ((desc (if (and (instancep name)
				      ;; FLAVORS-INSTANCE-P assumes the thing is
				      ;; already INSTANCEP.
				      (flavor-instance-p name))
				 name
			       ,(if search-p
				    `(presentation-type-descriptor name)
				  `(with-type-decoded (type-name) name
				      (symbol-presentation-type-descriptor type-name))))))
		   ,@(unless search-p
		       `((unless desc
			   (return-from ,generic-function nil))))
		   (,(if apply 'apply 'funcall)
		    (flavor:generic ,generic-function)
		    desc
		    ,@required))))
	      (defmethod (,generic-function ,flavor) ,arglist
		(declare (sys:function-parent
			   (flavor:method ,generic-function ,flavor)
			   defmethod-type-descriptor))
		,@body)))))

(defun (:property defmethod-type-descriptor zwei:definition-function-spec-parser)
       (bp-after-defmethod)
  ;; The next SEXP has to be `(FSPEC FLAVOR . OTHER-THINGS)
  ;; We return (FLAVOR:METHOD FSPEC FLAVOR OTHER-THINGS
  (let ((after-method-bp (zwei:forward-sexp bp-after-defmethod)))
    (when after-method-bp
      (multiple-value-bind (method-spec error-p)
	  (zwei:read-fspec-item-from-interval bp-after-defmethod after-method-bp)
	(if (or error-p (symbolp method-spec))
	    (values nil nil nil t)
	    (let ((fspec (list* 'flavor:method method-spec))
		  (name (first method-spec)))
	      (if 
		(si:validate-function-spec fspec)
		(values name 'defun (string name) nil)
		(values nil nil nil t))))))))

;;; Generic for implementing the function-spec protocol.
;;; This generic function handles dispatch on the third argument,
;;; translating it to a locative, or optionally signalling an error if
;;; it is not known.  This is the core on which the entire rest of
;;; the protocol is based.

(defgeneric fdefinition-location-internal (descriptor handler-type &optional (error-p t))
  (:method-combination :case))

;;; Here is the definition for the parts that make up the presentation-type.

(define-presentation-type-descriptor
  :arglists ((printer (object stream &key type original-type acceptably for-context-type))
	     (viewspec-choices (&key type original-type presentation))
	     (parser (stream &key type original-type predicate
			     initially-display-possibilities
			     default default-supplied default-type))
	     (presentation-type-printer (stream &key type plural-count original-type))
	     (input-history-expander (&key type original-type))
	     (default-preprocessor (object &key type original-type default-type))
	     (history-postprocessor (object &key default object-type original-type type))
	     (highlighting-box-function (stream &key presentation x y type original-type))
	     (choose-displayer (stream object query-identifier &key type original-type))
	     (accept-values-displayer (stream object query-identifier
					      &key type original-type provide-default))
	     (menu-displayer (stream object query-identifier &key type original-type))
	     (map-over-subtypes (function predicate &key recurse type original-type
					  supertype-p for-lookup key keys-seen
					  predicate-p))
	     (map-over-supertypes (function predicate &key recurse type original-type
					    supertype-p for-lookup key keys-seen
					    predicate-p))
	     (graphics::binary-graphics (object stream &key type original-type
							    encoding-stream))
	     )
  :other-functions (data-type-generator		;Remove for 8.0
		    data-type-generator-stack
		    data-type-equivalent	;Remove for 8.0
		    data-type-equivalent-stack
		    old-arglist-transformer	;Disabled, needs smarts in
		    				;D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")with-presentation-type-arguments0.
		    presentation-subtypep
		    key-generator
		    do-compiler-warnings
		    ;; This next one is for a predicate to see if this really applies.
		    ;; This should eventually replace the TYPEP property for the
		    ;; CL type system.  It takes (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")object 0&rest 2data-args0.
		    typep-function
		    ;; Same as 1typep-function0, but implies equivalence.  I'm not sure if
		    ;; the distinction is useful, but I'd rather just do one pass classifying
		    ;; stuff.
		    full-typep-function
		    ;; This one is for a predicate which just implements the data arguments
		    ;; It takes 2object 0&rest 2data-args0.
		    data-typep-function
		    ;; This one is for a predicate which just impelements the bare type, with
		    ;; no data arguments.  It takes 2object0 as an argument.
		    bare-typep-function
		    ;; This subsumes the ones above; it takes 2object0 &rest 2data-args0,
		    ;; and returns a predicate.  It may close over the 2data-args0, and
		    ;; it may preprocess some of the data-args.
		    typep-function-generator
		    ;; This takes 2function original-type-name 0&rest 2data-args0 and
		    ;; invokes 2function0 on a key that reflects all the data arguments.
		    with-cache-key
		    ;; This takes 2function0 2type0 and invokes 2function0 on a key that reflects
		    ;; the entire type
		    with-full-cache-key
		    ;; The rest are for converting the CL type system someday.
		    typep-expander		;To replace TYPEP-EXPANDER property
		    type-expander		;To replace DEFTYPE property
		    )
  :other-values ((arglist)			;Real argument list
		 ;; 2old-arglist0 is disabled, pending large smarts in
		 ;; 1with-presentation-type-argument0.
		 #+ignore
		 (old-arglist)			;Obsolete argument list to be converted on
						;being encountered.
		 (presentation-type-arguments)	;Arguments which are themselves types.
		 (obsolete)			;Flag declaring this type obsolete.
						;Set to T or the name of the type to use
						;instead.
		 (type-pretty-name)
		 (input-history-type)
		 (presentation-type-history)
		 (statice-info)			;Statice storage handler flavor or function
		 (flags 1)			;Contains the following fields (right to left)
		 ;; (presentation-only t)	;  Only available for presentations.
		 ;; (explicit-type-function)	;  Says we defined our own TYPEP function, and
		 ;; (disallow-atomic-type)	;Don't allow this type by itself.
		 ;; (cl-type-allowed)		;The presentation type is just adding to the
		 ;; 				;CL type definition.
		 ;; 				;we shouldn't clobber it with CL's version.
		 ;; data-arguments-required	;Says data arguments are required.  This
		 ;; 				;caches info from the arglist without having
		 ;; 				;to include the arglist in the working-set.
		 ;; <gap>
		 ;; (version 0 (unsigned-byte 8));Format/protocol version
		 ))

(defmacro-in-flavor (presentation-only presentation-type-descriptor) ()
  `(ldb-test (byte 1 0) flags))
(defmacro-in-flavor (explicit-type-function presentation-type-descriptor) ()
  `(ldb-test (byte 1 1) flags))
(defmacro-in-flavor (disallow-atomic-type presentation-type-descriptor) ()
  `(ldb-test (byte 1 2) flags))
(defmacro-in-flavor (cl-type-allowed presentation-type-descriptor) ()
  `(ldb-test (byte 1 3) flags))
(defmacro-in-flavor (data-arguments-required presentation-type-descriptor) ()
  `(ldb-test (byte 1 4) flags))
(defmacro-in-flavor (version presentation-type-descriptor) ()
  `(%logldb (byte 8 24) flags))

(defmethod (:print-self presentation-type-descriptor) (stream &rest ignore)
  (printing-random-object (self stream :typep)
    (prin1 name stream)))

(defmethod (:describe presentation-type-descriptor :after) ()
  (format t "~&Flags decoded:  Version ~D~:[~;, presentation-only~]~
	     ~:[~;, explicit-type-function~]~:[~;, disallow-atomic-type~]~
	     ~:[~;, cl-type-allowed~]~:[~;, data-arguments-required~:]~%"
	  (version)
	  (presentation-only)
	  (explicit-type-function)
	  (disallow-atomic-type)
	  (cl-type-allowed)
	  (data-arguments-required)))

(defmacro do-all-types ((&optional type-name type-desc progress-note-action) &body body)
  `(flet ((do-all-types (,(or type-name 'ignore) ,(or type-desc 'ignore))
	    ,@body))
     (let ((action ,progress-note-action))
       (tv:maphash-noting-progress #'do-all-types *presentation-type-descriptors*
				   (format nil "~A all presentation types."
					   (if action (string-capitalize action)
					     "Mapping over"))))))

#||

;;; This is useful to call in patch files that patch the above.
;;; It transforms the instances, and updates the hash table to point to the
;;; transformed version.
(defun recons-presentation-type-descriptors ()
  (do-all-types (name desc "Recons")
    (setf (symbol-presentation-type-descriptor name)
	  (follow-structure-forwarding desc))))

(recons-presentation-type-descriptors)

(fundefine 'recons-presentation-type-descriptors)

||#


;;; Version System      Change
;;;   0     7.1
;;;   1     Early 7.2   Types can be CL syntax
;;;   2     Proto 7.2   1parser0 get full info.
;;;        		1printer0 get full info.
;;;			1highlighting-box-function0 gets type & original-type
;;;			1presentation-type-printer0 gets arguments in standard order
;;;			1with-full-cache-key0 gets 2original-type-name0 argument.

(defvar *type-method-compatibility-table*
	'(((parser 2) 2-make-compatible-parser)
	  ((printer 2) 2-make-compatible-printer)
	  ((with-full-cache-key 2) 2-make-compatible-with-full-cache-key)
	  ((highlighting-box-function 2) 2-make-highlighting-box-function)
	  ((presentation-type-printer 1) 1-make-presentation-type-printer)
	  ((viewspec-choices 1) 1-make-skip-0-type-2-compatible-type-method)
	  ((input-history-expander 1) 1-make-skip-0-type-2-compatible-type-method)
	  ((default-preprocessor 1) 1-make-default-preprocessor)
	  ((history-postprocessor 1) 1-make-history-postprocessor)
	  ((choose-displayer 1) 1-make-skip-3-type-2-compatible-type-method)
	  ((accept-values-displayer 1) 1-make-skip-3-type-2-compatible-type-method)
	  ((menu-displayer 1) 1-make-skip-3-type-2-compatible-type-method)
	  ((map-over-subtypes 1) 1-make-mapper-type-method)
	  ((map-over-supertypes 1) 1-make-mapper-type-method)
	  ;; binary-graphics didn't exist for version 0
	  ;; We don't care about the non-stack versions, but do them anyway
	  ((data-type-generator 1) 1-make-1-type-compatible-type-method)
	  ((data-type-generator-stack 1) 1-make-1-type-compatible-type-method)
	  ((data-type-equivalent 1) 1-make-1-type-compatible-type-method)
	  ((data-type-equivalent-stack 1) 1-make-1-type-compatible-type-method)
	  ((do-compiler-warnings 1) 1-make-1-type-compatible-type-method)
	  ))

(defmethod (lookup-handler-compatibility-function presentation-type-descriptor) (method)
  (labels ((test (method spec)
	     (destructuring-bind (spec-method spec-version) spec
	       (and (eql method spec-method)
		    (< (version) spec-version)))))
    (let ((entry (find method *type-method-compatibility-table*
		       :test #'test :key #'car)))
      (when entry
	(destructuring-bind (spec maker) entry
	  (ignore spec)
	  maker)))))

;;; First, the generic type-argument processors

(defmacro reconsing-type (type-var &body body)
  (let ((new-type-var (gensymbol "NEW-TYPE-")))
    `(stack-let ((,new-type-var `(,,type-var))
		 (,type-var ,type-var))
       (when (and (consp ,type-var)
		  (atom (car ,type-var)))
	 (setq ,type-var ,new-type-var))
       ,@body)))

;; presentation-function-same-as-function-from-name knows the exact format
;; of the closures this generates, so be careful if you change this
;; or if you create more things like this
(defmacro define-1-type-translator (name arglist type-args &body body)
  (let ((function (gensymbol "TYPE-METHOD-")))
    (multiple-value-bind (arguments apply lambda-list)
	(lt:lambda-list-arguments arglist)
      (let ((body `(,@body
		    (,(if apply 'apply 'funcall)
		     ,function
		     ,@arguments))))
	(loop for var in type-args
	      do
	  (setq body `((reconsing-type ,var ,@body))))
	`(defun ,name (,function)
	   (flet ((translate-and-call ,lambda-list
		    (declare (dbg:invisible-frame :presentation-handler-search))
		    ,@body))
	     #'translate-and-call))))))

(define-1-type-translator 1-make-1-type-compatible-type-method
			  (type &rest args)
			  (type))
(define-1-type-translator 1-make-skip-0-type-2-compatible-type-method
			  (type original-type &rest args)
			  (type original-type))
(define-1-type-translator 1-make-skip-3-type-2-compatible-type-method
			  (frob1 frob2 frob3 type original-type &rest args)
			  (type original-type))
(define-1-type-translator 1-make-default-preprocessor
			  (object type original-type default-type &rest args)
			  (type original-type default-type))
(define-1-type-translator 1-make-history-postprocessor
			  (object default object-type original-type type &rest args)
			  (object-type original-type type))
(define-1-type-translator 1-make-presentation-type-printer
			  (stream type plural-count original-type)
			  (type original-type))
(define-1-type-translator 1-make-mapper-type-method
			  (function predicate recurse type original-type
				    supertype-p for-lookup key keys-seen
				    predicate-p)
			  (type original-type))

;;; The body (if supplied) should use 1(call-method0 ...1)0 or 1(apply-method0 ...1)
0;;;  to run the old method.
;;; presentation-function-same-as-function-from-name knows the exact format
;;; of the closures this generates, so be careful if you change this
;;; or if you create more things like this
(defmacro define-type-method-translator (name new-arglist &body body)
  (let ((function (gensymbol "TYPE-METHOD-")))
    `(defun ,name (,function)
       (declare (sys:function-parent ,name define-type-method-translator))
       (flet ((translate-and-call ,new-arglist
		(declare (dbg:invisible-frame :presentation-handler-search))
		(macrolet ((call-method (&rest args)
			     `(funcall ,',function ,@args))
			   (apply-method (&rest apply-args)
			     `(apply ,',function ,@apply-args)))
		  ,@body)))
	 #'translate-and-call))))

(define-type-method-translator 2-make-compatible-parser
			       (stream type original-type predicate
				       initially-display-possibilities
				       default default-supplied default-type)
  (ignore default-type default-supplied predicate)
  (let ((old-type type)
	(old-original-type type))
    (reconsing-type type
      (reconsing-type original-type
	(multiple-value-bind (object return-type)
	    (call-method stream type original-type default initially-display-possibilities)
	  (unless (eq old-type type)
	    (when (eq type return-type)
	      (heap-copy-presentation-type-if-necessary return-type)))
	  (unless (eq old-original-type original-type)
	    (when (eq original-type return-type)
	      (heap-copy-presentation-type-if-necessary return-type)))
	  (values object return-type))))))

(define-type-method-translator 2-make-compatible-printer
			       (object stream type original-type acceptably for-context-type)

  (ignore for-context-type)
  (reconsing-type type
    (reconsing-type original-type
      (call-method object stream type original-type acceptably))))

(define-type-method-translator 2-make-highlighting-box-function
			       (stream presentation x y type original-type)

  (ignore type original-type)
  (call-method stream presentation x y))


;; Make the CL typep stuff be up-to-date

(defmethod (fixup-cl-type-info presentation-type-descriptor) ()
  (unless (explicit-type-function)
    (variable-makunbound typep-function)
    (variable-makunbound typep-expander)
    (variable-makunbound type-expander)
    (condition-case ()
	 (let ((deftype (get name 'deftype)))
	   (when deftype
	     (let ((cltype (funcall deftype)))
	       (setf (presentation-only)
		     (and (listp cltype) (eq (car cltype) 'presentation-only-type))))))
       (sys:too-few-arguments))
    (let ((fun (get name 'typep)))
      (when fun (setq typep-function fun)))
    (let ((fun (get name 'cli::typep-expander)))
      (when fun (setq typep-expander fun)))
    (let ((fun (get name 'deftype)))
      (when fun (setq type-expander fun)))
    (unless (cl-type-allowed)
      (when (or (variable-boundp typep-function) (variable-boundp typep-expander))
	(error "~S is multiply defined." name)))))

(defun fix-all-presentation-types (&optional (phase 1) (n-phases 1))
  (loop with denominator = (length *all-presentation-types*)
	with numerator = 0
	for pt in *all-presentation-types*
	do (tv:note-progress-in-phases (incf numerator) denominator phase1 0n-phases)
	   (fixup-cl-type-info (symbol-presentation-type-descriptor pt))))

(defun args-match-p (arglist args &key additional-keyword-args)
  (condition-case ()
       (lt:match-args-to-lambda-list arglist args
				     :additional-keyword-args additional-keyword-args)
     (lt::lambda-list-match-error nil)
     (:no-error t)))

(defvar *warn-about-old-types* :error
  "One of T, NIL, :NO-HANDLER, or :ERROR, or a list of types to signal an error on.")

;(defun decode-old-presentation-type (type &key atomic-ok (warn-p *warn-about-old-types*))
;  (declare (ignore warn-p))
;  (multiple-value-bind (type-name data-args pr-args old-p)
;      (etypecase type
;	(null (return-from decode-old-presentation-type nil))
;	(symbol (values type nil nil))
;	(list (cond ((atom (car type))
;		     (values (car type) (cdr type) nil t))
;		    ((atom (caar type))
;		     (values (caar type) (cdar type) (cdr type) nil))
;		    (t (error "Too many levels of parenthesis in presentation type ~S."
;			      type)))))
;    (let ((new-type (if (or old-p
;			    (and (not atomic-ok)
;				 (atom type)))
;			`((,type-name ,@data-args) ,@pr-args)
;		      type)))
;      (if atomic-ok
;	  new-type
;	(if (atom new-type)
;	    `((,new-type))
;	  new-type)))))

;;; 1:exact-only0 1t0 never signals an error; it just calls it on 1nil0, just like
;;; :1error-p0 1nil0 would.
(defmacro with-type-descriptor (((descriptor expanded-type-var) type
				 &key (error-p t) exact-only)
				&body body)
  ;; RWK likes LABELS better then SYS:NAMED-LAMBDA
  `(labels ((with-type-descriptor-body (,descriptor ,expanded-type-var)
	      (declare (sys:downward-function)
		       (dbg:invisible-frame :presentation-handler-search))
	      ,@body))
     (with-type-descriptor-internal ,type ,error-p ,exact-only #'with-type-descriptor-body)))

(defun with-type-descriptor-internal (type error-p exact-only continuation)
  (declare (sys:downward-funarg continuation)
	   (dbg:invisible-frame :presentation-handler-search))
  (stack-let ((new-type (list type)))
    ;; For the sake of compatibility, until Release 8, because 7.0's
    ;; 1with-presentation-type-arguments0 didn't handle the (foo . data-args) format.
    (when (and (consp type)
	       (atom (car type)))
      (setq type new-type))
    (with-type-decoded (type-name data-args presentation-args) type
      (macrolet ((try-value ((value-var value-form) &body body)
		   `(let ((,value-var ,value-form))
		      (when ,value-var
			(return-from with-type-descriptor-internal
			  (progn ,@body)))))
		 (invoke (descriptor &optional (type 'type))
		   `(funcall continuation ,descriptor ,type))
		 (with-new-type ((new-type-var new-type-name) &body body)
		   `(stack-let ((,new-type-var `((,,new-type-name ,@data-args)
						 ,@presentation-args)))
		      ,@body))
		 (invoke-new-type (descriptor new-type-name)
		   `(with-new-type (new-type ,new-type-name)
		      (return-from with-type-descriptor-internal
			(invoke ,descriptor new-type))))
		 (try-value-simple (value-form)
		   `(try-value (value ,value-form)
		      (invoke value))))
	(if (typep type-name 'presentation-type-descriptor)
	    (invoke type-name)
	  (try-value-simple (symbol-presentation-type-descriptor type-name))
	  (multiple-value-bind (flavor-or-class structure-p deftype-fun
				typep-fun atomic-subtype-parent)
	      (symbol-flavor-or-cl-type type-name)
	    (ignore typep-fun)
	    (if exact-only
		(invoke nil)
	      (when structure-p
		(invoke-new-type (symbol-presentation-type-descriptor 'structure) 'structure))
	      (when flavor-or-class
		(map-over-type-hierarchy type t 'get-type-property-stack
		  (lambda (expanded-type key predicate)
		    (declare (ignore key predicate))
		    (try-value (desc (symbol-presentation-type-descriptor
				       (presentation-type-name expanded-type)))
		      (invoke desc expanded-type))))
		;; If the above didn't exit, try this on.  This should be redundant.
		(if (instancep flavor-or-class)	;CLOS class descriptors are instances
		    (invoke-new-type
		      (symbol-presentation-type-descriptor 'clos-internals:member-of-class)
		      'clos-internals:member-of-class)
		  (invoke-new-type
		    (symbol-presentation-type-descriptor 'instance) 'instance)))
	      (try-value (fun deftype-fun)
	        (let ((ntype (apply fun data-args)))
		  (if (atom ntype)
		      (stack-let ((expanded-type `((,ntype) ,@presentation-args)))
			(with-type-descriptor-internal expanded-type error-p exact-only
						       continuation))
		    (stack-let ((expanded-type `(,ntype ,@presentation-args)))
		      (with-type-descriptor-internal expanded-type error-p exact-only
						     continuation)))))
	      (try-value (parent atomic-subtype-parent)
	        (with-new-type (new-type parent)
		  ;; There is a requirement that all atomic-subtype-parent's have the same
		  ;; arglist or a presentation-type-descriptor.
		  (with-type-descriptor-internal new-type error-p exact-only continuation)))
	      (if (not error-p)
		  (invoke nil)
	        (heap-copy-presentation-type-if-necessary type)
		(if (not (presentation-type-p type))
		    (error "~S is not a presentation type" type)
		  (error "~S satisfies ~S, but we didn't find the descriptor."
			 type 'presentation-type-p))))))))))

(defun initialize-presentation-type (type-name &rest make-instance-arguments
				     &key cl-type-allowed (full-reinitialization nil)
				     (version 0) (record-source-file-name t)
				     &allow-other-keys)
  (when record-source-file-name
    (si:record-definition-source-file type-name 'define-presentation-type))
  ;; Tell the flavor system to compose this, so any type methods are found in
  ;; the right order.
  (compose-flavor-for-dw type-name type-name 'define-presentation-type)
  (prepare-for-type-change type-name)
  (case version
    (0 (enqueue-finish-type-redefinition type-name)))
  (let* ((compiler:default-warning-function type-name)
	 (compiler:default-warning-definition-type 'define-presentation-type)
	 (source-file-props (si:function-spec-get type-name :source-file-name))
	 (this-type (assoc 'deftype (and (not (atom source-file-props))
					 source-file-props)))
	 (old-file (loop for file in (cdr this-type)
			 unless (funcall file ':get ':patch-file)
			   return file)))
    (unless cl-type-allowed
      (cond ((member type-name *standard-terminal-types*)
	     (error "You cannot redefine the ~S type." type-name))
	    ((flavor:find-flavor type-name nil)
	     (when (and old-file
			(si:query-about-redefinition type-name fdefine-file-pathname
						     'deftype
						     old-file))
	       (warn "~S was defined as a ~S.  The ~S definition is being removed."
		     type-name 'defflavor 'defflavor)
	       (flavor:remove-flavor type-name))))
      ;; Two COND's, since we may be redefining both if things are adaquately screwed up.
      (cond ((defstruct-type-p type-name)
	     (when (and old-file
			(si:query-about-redefinition type-name fdefine-file-pathname
						     'deftype
						     old-file))
	       (warn "~S was defined as a ~S.  The ~S definition is being removed."
		     type-name 'defstruct 'defstruct)
	       (remprop type-name 'si:defstruct-description)
	       (remprop type-name 'si:named-structure-invoke)))
	    ((get type-name 'si:named-structure-invoke)
	     (error "~S is a non-standard structure type, I don't know how to redefine it."
		    type-name))))
    (si:with-rem-keywords (make-instance-arguments make-instance-arguments
						   '(:full-reinitialization :old-arglist
						     :record-source-file-name))
      (when (null (symbol-presentation-type-descriptor type-name))
	(setq full-reinitialization t))
      (if full-reinitialization
	  (apply #'create-presentation-type type-name make-instance-arguments)
	    
	  (apply #'create-presentation-type
		 type-name
		 (append
		   (loop for (keyword finder-function)
			     in *presentation-type-methods-to-preserve*
			 as method = (funcall finder-function type-name)
			 when method
			   append `(,keyword ,method))
		   make-instance-arguments)))
      (cond (( version 0)
	     (if *update-types-incrementally*
		 (enqueue-finish-type-redefinition type-name)
		 (inhibit-style-warnings
		   (invalidate-type-handler-tables))))
	    (t ())))))

;;; This is a function, with a stub in the cold load, instead of
;;; just being open-coded in the expansion of the various macros,
;;; because the cold-load generator cannot hack generic-functions
;;; at top-level, only in compiled functions.
;;; [The above reason must be bogus, because 1check-type-redefinition
0;;;  isn't a generic function, and it worked fine that way in 7.1.
;;;  (1check-type-redefinition0 is a compiled function that calls a
;;;   generic function.)  But this is better than putting all that
;;;  cruft into the expansion, which is a quite adaquate reason.  --RWK]

(defun maybe-check-type-redefinition (type for-definition &key 7.2-type)
  (when (and (variable-boundp *presentation-type-descriptors*)
	     (symbol-presentation-type-descriptor type))
    (check-type-redefinition type for-definition :7.2-type 7.2-type))
  (when (member for-definition '(defstruct zl:defstruct))
    (if 7.2-type
	(finish-type-redefinition type)
      ;; circa 369, this gets called twice in the expansion of defstruct,
      ;; and at the wrong time.
      (enqueue-finish-type-redefinition type))))

(defmethod-type-descriptor (check-type-redefinition presentation-type-descriptor :search-p nil)
			   (for-definition &key 7.2-type)
  (ignore 7.2-type)
  (unless (cl-type-allowed)
    (warn "~S was defined as a presentation type,~@
	   but is being redefined as a ~S.~@
	   The presentation type will be removed."
	  name for-definition)
    (setq *all-presentation-types* (delete name *all-presentation-types*))
    (remhash name *presentation-type-descriptors*)))

(defmethod (presentation-type-explicit-type-function presentation-type-descriptor) ()
  (explicit-type-function))

(defmethod (presentation-type-disallow-atomic-type presentation-type-descriptor) ()
  (disallow-atomic-type))

(defmethod-type-descriptor (presentation-type-presentation-only presentation-type-descriptor
								:search-p nil) ()
  (presentation-only))

(defun ensure-presentation-type-descriptor-exists (type-name)
  (unless (symbol-presentation-type-descriptor type-name)
    (create-presentation-type type-name)))

(defun create-presentation-type (type-name &rest make-instance-arguments
				 &key arglist disallow-atomic-type
				 &allow-other-keys)
  (pushnew type-name *all-presentation-types* :localize t)
  (let* ((required-arguments (and (caar arglist)
				  (not (member (caar arglist) '(&optional &rest &key)))))
	 (old-descriptor (symbol-presentation-type-descriptor type-name))
	 (new-descriptor (apply #'make-instance 'presentation-type-descriptor
				:name type-name
				:data-arguments-required required-arguments
				:disallow-atomic-type (or disallow-atomic-type
							  required-arguments)
				:area (if old-descriptor default-cons-area
					  *presentation-type-area*)
				make-instance-arguments)))
    (cond ((not old-descriptor)
	   (setf (symbol-presentation-type-descriptor type-name) new-descriptor))
	  (t
	   ;; Already exists, update the existing instance so that the type "method"
	   ;; function cells remain where they were
	   (without-interrupts
	     (send old-descriptor :which-operations)	;Force transform-instance if needed
	     (setq old-descriptor (follow-structure-forwarding old-descriptor)
		   new-descriptor (follow-structure-forwarding new-descriptor))
	     (flavor::%block-copy-allow-null
	       (%make-pointer-offset dtp-locative new-descriptor 1)
	       (%make-pointer-offset dtp-locative old-descriptor 1)
	       (1- (min (%structure-total-size old-descriptor)
			(%structure-total-size new-descriptor))))
	     old-descriptor)))))

(defmethod (make-instance presentation-type-descriptor) (&key presentation-only
							      explicit-type-function
							      disallow-atomic-type
							      cl-type-allowed
							      data-arguments-required
							      (version 0)
							      &allow-other-keys)
  (setf (version) version
	(presentation-only) presentation-only
	(explicit-type-function) explicit-type-function
	(disallow-atomic-type) disallow-atomic-type
	(cl-type-allowed) cl-type-allowed
	(data-arguments-required) data-arguments-required))

(defprop define-presentation-type delete-presentation-type zwei:kill-definition)

(defun delete-presentation-type (type-name)
  (catch-error-restart (error "Skip deleting type ~S." type-name)
    (let ((handlers (gethash type-name *handlers-affected-by-types-table*)))
      (labels ((obsolete-handler-p (handler)
		 (null (gethash handler *presentation-mouse-handlers-table*))))
	(setq handlers (delete-if #'obsolete-handler-p handlers)))
      (when handlers
	;; +++ Provide restart to flush the handlers?
	(error "Cannot remove type ~A, it has the following mouse handler~P:~@
	      ~{~A~^, ~}."
	       type-name (length handlers) handlers)))
    (prepare-for-type-change type-name)
    (etypecase type-name
      (symbol)
      (presentation-type-descriptor
	(setq type-name
	      (presentation-type-descriptor-name type-name))))
    (setq *all-presentation-types* (delete type-name *all-presentation-types*))
    (remprop type-name 'presentation-type-descriptor)
    (remhash type-name *presentation-type-descriptors*)
    (finish-type-redefinition type-name)))


;;; Get the descriptor object for a presentation type.
(defun presentation-type-descriptor (type &optional (error-p t))
  (with-type-descriptor ((descriptor ignore) type :error-p error-p)
    descriptor))

(defmethod (fdefinition-location-internal presentation-type-descriptor :otherwise)
	   (handler-type &optional (error-p t))
  (when error-p
    (error "~S is not the name of a presentation handler." handler-type))
  nil)

(defmethod (presentation-type-descriptor-arglist presentation-type-descriptor) ()
  arglist)

;;; The following is a kludge to get around the compiler's confusion of
;;; target vs local environments.  The compiler wants to use a locative
;;; to the function cell as a marker, but of course the function cell may
;;; not exist locally, but only in the target environment.  So we dummy
;;; up a cell to use locally.

(defvar *compiler-dummy-function-cells* (make-hash-table :test 'equal))

(si:define-function-spec-handler presentation-function
				 (operation function-spec &optional arg1 arg2)
  (case operation
    (validate-function-spec
      (and (loop for x on function-spec
		 while x
		 when (atom x)
		   return nil
		 finally (return t))
	   (= (length function-spec) 3)
	   (destructuring-bind (nil presentation-type handler-type) function-spec
	     (and (or (symbolp presentation-type)
		      (typep presentation-type 'presentation-type-descriptor))
		  (symbolp handler-type)
		  (member handler-type *presentation-function-valid-specs*)))))
    ;; T for si:definition-has-location-p would mean that it is okay to forward
    ;; the function cell (instance variable slot) into the compiled-function.  We
    ;; certainly don't want that for these, it would greatly complicate redefinition
    ;; and it can only slow down execution.
    (si:definition-has-location-p nil)
    (otherwise
      (destructuring-bind (nil presentation-type handler-type . others) function-spec
	(case operation
	  ((fdefine fdefinedp fdefinition fdefinition-location fundefine)
	   (let* ((desc (symbol-presentation-type-descriptor presentation-type))
		  (loc (when desc (fdefinition-location-internal desc handler-type))))
	     (when (and (neq operation 'fdefinedp)
			(not (and (eq operation 'fdefinition-location)
				  arg1))
			(null desc))
	       (error "There is no presentation type named ~S." presentation-type))
	     (ecase operation
	       (fdefine
		 ;; We don't hack standard-full-cache-key-generator.
		 (unless (eq (sys:function-name arg1) 'standard-full-cache-key-generator)
		   (let ((maker (lookup-handler-compatibility-function desc handler-type)))
		     (when maker
		       (setq arg1 (funcall maker arg1)))))
		 (setf (location-contents loc) arg1))
	       (fdefinedp (when loc (location-boundp loc)))
	       (fdefinition (location-contents loc))
	       (fdefinition-location
		 (when (and arg1 (null loc))
		   (setq loc (gethash function-spec *compiler-dummy-function-cells*))
		   (unless loc
		     (setq loc (locf (car (list nil))))
		     (setf (gethash function-spec *compiler-dummy-function-cells*) loc)))
		 loc)
	       (fundefine (location-makunbound loc handler-type)))))
	  (otherwise
	    (unless (eq handler-type (third function-spec))
	      (setq function-spec `(presentation-function ,presentation-type ,handler-type
							  ,@others)))
	    (si:function-spec-default-handler operation function-spec arg1 arg2)))))))

;; Called by FUNCTION-SAME-AS-FUNCTION-FROM-NAME
;; Name is (PRESENTATION-FUNCTION presentation-type-name method-name)
(defun presentation-function-same-as-function-from-name (function name definition)
  (when (typep definition 'lexical-closure)
    (let ((elem (assoc (third name) *type-method-compatibility-table* :key #'car))
	  (translate-and-call (function-name (closure-function definition))))
      (when (and (listp translate-and-call)
		 (eq (first translate-and-call) ':internal)
		 (eq (second translate-and-call) (second elem))
		 (eq (fourth translate-and-call) 'translate-and-call))
	;; This function has been wrapped in a compatibility closure, the only
	;; remaining check is whether function is the current definition or an old one.
	;; The translate-and-call flet always closes over nothing but the function.
	(eq function (first (lexical-closure-environment definition)))))))

