;;; -*- Mode: LISP; Syntax: Common-lisp; Package: (FORMATTED-OUTPUT-TESTS :use SCL); Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains some simple uses of the user interface output formatting
;;; facilities.  While they are mainly for testing purposes, many of them provide
;;; realistic examples of proper use of the facilities.

;;;; Simple test programs

(defun format-test-1 (list)
  (fresh-line)
  (formatting-textual-list (()
			  :after-line-break "  "
			  :conjunction "and")
    (dolist (x list)
      (formatting-textual-list-element ()
	(princ x)))))

;;; Use :style '(:dutch nil :small) to test variable width
(defun format-test-b (list &key (filled t) (style nil) (printer #'princ)
				(stream *standard-output*))
  (fresh-line stream)
  (with-character-style (style stream)
    (format-textual-list list printer :stream stream :conjunction "and" :filled filled)))

(defun format-test-2 (&key (stream *standard-output*) (style nil))
  (fresh-line stream)
  (with-character-style (style stream)
    (formatting-table (stream)
      (formatting-column-headings (stream)
	"Area"
	(formatting-cell (stream :align :right)
	  "#"))
      (dolist (area sys:area-list)
	(formatting-row (stream)
	  (formatting-cell (stream)
	    (write area :stream stream))
	  (formatting-cell (stream :align :right)
	    (write (symbol-value area) :base 10 :stream stream)))))))

(defun format-test-2r (&optional (stream *standard-output*))
  (fresh-line stream)
  (formatting-table (stream)
    (formatting-column-headings (stream)
      (formatting-cell (stream :align :right)
	"#")
      "Name")
    (dolist (area sys:area-list)
      (formatting-row (stream)
	(formatting-cell (stream :align :right)
	  (write (symbol-value area) :base 10 :stream stream))
	(formatting-cell (stream)
	  (write area :stream stream))))))

(defun format-test-2i ()
  (fresh-line)
  (formatting-table ()
    (formatting-column-headings ()
      "Area"
      (formatting-cell (nil :align :right) "#"))
    (dolist (area sys:area-list)
      (formatting-row ()
	(formatting-cell ()
	  (with-character-face (:italic)
	    (write area)))
	(formatting-cell (nil :align :right)
	  (with-character-face (:bold)
	    (write (symbol-value area) :base 10)))))))

(defun format-test-x-list ()
  (loop for sym in sys:area-list
	collect (list sym (symbol-value sym))))

(defun format-test-x (&optional (list (format-test-x-list)))
  (fresh-line)
  (formatting-table ()
    (loop for (x y) in list doing
      (formatting-row ()
	(formatting-cell ()
	  (princ x))
	(formatting-cell ()
	  (write y :radix 10.))))))

(defun format-test-a (list &key (stream *standard-output*) (style nil))
  (setq list (sort (copy-list list) #'string-lessp))
  (fresh-line stream)
  (with-character-style (style stream)
    (formatting-multiple-columns (stream)
      (dolist (x list)
	(princ x stream)
	(terpri stream)))))

(defun format-test-2a (&key (style nil) (nareas nil) (multiple-p t) (equalize-p nil)
			    (output-row-wise t))
  (fresh-line)
  (with-character-style (style)
    (formatting-table (t :multiple-columns multiple-p
			 :output-multiple-columns-row-wise output-row-wise
			 :equalize-multiple-column-widths equalize-p)
      (formatting-column-headings (t :underline-p t)
	(formatting-cell () "Area")
	(formatting-cell (nil :align :right) "#"))
      (dolist (area (subseq sys:area-list 0 nareas))
	(formatting-row ()
	  (formatting-cell ()
	    (write area))
	  (formatting-cell (nil :align :right)
	    (with-character-face (:bold)
	      (write (symbol-value area) :base 10))))))))

(defun format-test-il (&key (style nil) (row-wise nil) (output-row-wise t))
  (fresh-line)
  (with-character-style (style)
    (formatting-item-list (t :row-wise row-wise
			     :output-row-wise output-row-wise)
      (dotimes (i 9)
	(format-cell i #'prin1)))))

(defun fancy-member-printer (value type)
  (format-item-list (cdar type)
		    :fresh-line nil
		    :order-columnwise nil
		    :optimal-number-of-rows 1
		    :additional-indentation 0
		    :printer (lambda (object stream)
			       (if (eql object value)
				   (with-character-face (:bold)
				     (present object type :stream stream))
				   (present object type :stream stream)))))

(defun format-test-il-1 ()
  (fancy-member-printer 'foo '((member foo bar blort))))

(defun format-test-il-2 ()
  (format t "~&Current area: ")
  (fancy-member-printer 'working-storage-area `((member . ,sys:area-list))))

(defun format-test-s (list &key (how :alpha) style (printer #'princ))
  (setq list (copy-list list))			;Just in case
  (dw:with-resortable-output ((list how)
			      (:alpha
				#'string-lessp)
			      (:length
				#'(lambda (x y)
				    (< (string-length x) (string-length y)))))
    nil
    (with-character-style (style)
      (format t "~&Here is some list:~%")
      (format-textual-list list printer :filled t))))

(defun test-presentation-recording-string ()
  (dw:with-output-to-presentation-recording-string (stream)
    (format stream "The file ~A; ~S"
	    (fs:default-pathname) '(a (b cd) (ef gh (i)) (jk) (lmnop)))))

(define-presentation-type test-area ()
   :expander `((and expression
		    ((member ,@sys:area-list))))
   :description "a valid area")

(defun format-test-areas ()
  (format t "~&Here are the areas:~%")
  (let ((areas (copy-list sys:area-list))
	(how :number))
    (dw:with-resortable-output ((areas how)
				(:alpha #'string-lessp)
				(:number (sys:named-lambda sort-number (x y)
					   (< (symbol-value x) (symbol-value y)))))
			       ()
      (formatting-table (t :multiple-columns t)
	(formatting-column-headings ()
	  (with-underlining ()
	    (with-character-face (:italic)
	      (formatting-cell () "Name")
	      (formatting-cell (t :align :right) "Value"))))
	(loop ;;repeat 7
	      for area in areas
	      do
	  (formatting-row ()
	    (dw:with-output-as-presentation (:object area :type 'test-area)
	      (formatting-cell ()
		(write-string (string-downcase area)))
	      (formatting-cell (t :align :right)
		(format t "~D" (symbol-value area))))))))))

(define-presentation-translator test-area
  (test-area sys:form :gesture :describe)
  (object)
  `(describe-area ',object))

(defun system-menu-format-test (&optional (stream *standard-output*))
  (terpri stream)
  (with-character-style ('(:jess :roman :large) stream :bind-line-height t)
    (formatting-table (stream :equalize-column-widths t)
      (flet ((docol (header list &key align)
	       (formatting-column (stream)
		 (formatting-cell (stream :align align)
		   (with-underlining (stream)
		     (with-character-style ('(:sans-serif :italic :normal) stream)
		       (princ header stream))))
		 (dolist (item list)
		   (formatting-cell (stream :align align)
		     (with-character-style ('(:jess nil :large))
		       (princ (first item) stream)))))))
	(docol "Windows" tv:*system-menu-windows-column* :align :center)
	(docol "This window" tv:*system-menu-this-window-column* :align :center)
	(docol "Programs" tv:*system-menu-programs-column* :align :center)
	#+ignore ;;---The following doesn't work
	(formatting-column (stream)
	  (with-underlining (stream)
	    (with-character-style ('(:sans-serif :italic :normal) stream)
	      (formatting-cell (stream) "Programs")))
	  (formatting-cell (stream)
	    (formatting-multiple-columns (stream :number-of-columns 2) 
	      (dolist (item tv:*system-menu-programs-column*)
		(with-character-style ('(:jess nil :large))
		  (princ (first item) stream)
		  (terpri stream))))))))))

(defvar *calc-layout* '((7 8 9 +) (4 5 6 -) (1 2 3 *) ("Enter" 0 "." /)))

(define-presentation-type calc-key ()
   :parser ((stream)
	    (multiple-value-bind (nil nil thing)
		(dw:completing-from-suggestions (stream :force-complete t :type 'calc-key)
		  (dolist (row *calc-layout*)
		    (dolist (cell row)
		      (dw:suggest (string cell) cell))))
	      thing))
   :printer ((key stream)
	     (princ key stream)))

(defun format-test-calc (&optional (stream *standard-output*))
  (fresh-line stream)
  (surrounding-output-with-border (stream :thickness 3 :margin 3)
    (formatting-table (stream :inter-row-spacing 5 :inter-column-spacing 10)
      (dolist (sublist *calc-layout*)
	(formatting-row (stream)
	  (dolist (key-value sublist)
	    (formatting-cell (stream :align :center)
	      (dw:with-output-as-presentation (:object key-value :type 'calc-key :single-box t)
		(surrounding-output-with-border (stream :shape :oval)
		  (with-character-size ((if (> (zl:flatsize key-value) 1) :large :very-large)
					stream :bind-line-height t)
		    ;; :sensitive nil makes the bigger box the only box.
		    (present key-value 'calc-key :stream stream :sensitive nil)))))))))))

(defun bordered-table-test-2 ()
  (surrounding-output-with-border (t :thickness 2)
    (format-sequence-as-table-rows (subseq sys:area-list 0 4)
				   #'(lambda (area stream)
				       (format-cell (expt 10 (symbol-value area))
						    #'prin1 :stream stream)
				       (format-cell area #'prin1 :stream stream)))))

;;;; Redisplay Test Cases

(defvar *l*)

(defvar *debugging-display* ())			;used when debugging, to highlight boxes

(defun redisplay-test-1 ()
  (fresh-line)
  (setq *l* (copy-list '("foo" "bar" "blort")))
  (let ((*debugging-display* t)
	(displayer (dw:redisplayer ()
		     (dolist (thing *l*)
		       (dw:redisplayable-present thing 'string :unique-id thing)
		       (terpri)))))
    (dw:do-redisplay displayer)
    (read-char)
    (push "x" *l*)
    (dw:do-redisplay displayer)
    (read-char)
    (pop (cddr *l*))
    (dw:do-redisplay displayer)
    (read-char)
    displayer))

(defun redisplay-test-1x ()
  (fresh-line)
  (setq *l* (copy-list '("foo" "bar" "blort")))
  (let ((*debugging-display* t)
	(displayer (dw:redisplayer ()
		     (dolist (thing *l*)
		       (dw:redisplayable-present thing 'string :unique-id thing)
		       (terpri)))))
    (dw:do-redisplay displayer)
    (read-char)
    (push "x" *l*)
    (dw:do-redisplay displayer)
    (read-char)
    (rotatef (first *l*) (second *l*))
    (dw:do-redisplay displayer)
    (read-char)
    displayer))

(defun redisplay-test-2 (&optional (stream *standard-output*))
  (redisplay-test-2-internal (dw:redisplayer ()
			       (dolist (thing *l*)
				 (dw:with-redisplayable-output (:unique-id thing)
				   (dw:redisplayable-format t "~S: " thing)
				   (dw:redisplayable-present (eval thing) 'expression))
				 (terpri)))
			     stream))

(defun redisplay-test-2a (&optional (stream *standard-output*))
  (redisplay-test-2-internal (dw:redisplayer ()
			       (dolist (thing *l*)
				 (dw:with-redisplayable-output (:unique-id thing)
				   (dw:independently-redisplayable-format t "~S: ~S~%"
								       thing (eval thing)))))
			     stream))

(defun redisplay-test-3 (&optional (stream *standard-output*))
  (redisplay-test-2-internal (dw:redisplayer ()
			       (formatting-table ()
				 (dolist (thing *l*)
				   (dw:with-redisplayable-output (:unique-id thing)
				     (formatting-row ()
				       (formatting-cell ()
					 (dw:redisplayable-format t "~S: " thing))
				       (formatting-cell ()
					 (dw:redisplayable-present (eval thing) 'expression))
				       )))))
			     stream))

(defun redisplay-test-2-internal (displayer &optional (stream () stream-p))
  (let-if stream-p ((*standard-output* stream))
    (let (;;(*debugging-display* t)
	  )
      (fresh-line)
      (setq *l* (loop for (symbol . value) in '((*a* . a)
						(*bb* . b)
						(*c* . cc))
		      do (set symbol value)
		      collect symbol))
      (dw:do-redisplay displayer)
      (read-char)
      (set '*@* 'ddd) (push '*@* (cddr *l*))
      (dw:do-redisplay displayer)
      (read-char)
      (set '*c* 'not-c)
      (dw:do-redisplay displayer)
      (read-char)
      (pop (cdr *l*))
      (dw:do-redisplay displayer)
      (read-char)
      displayer)))

(defun redisplay-test-0 (&optional (stream *standard-output*))
  (let ((*standard-output* stream)
	;;(*debugging-display* t)
	(displayer (dw:redisplayer ()
		     (formatting-table ()
		       (dolist (thing *l*)
			 (formatting-row () 
			   ;;---(dw:with-redisplayable-output (:unique-id thing)
			   (formatting-cell ()
			     (prin1 thing))
			   (formatting-cell ()
			     (prin1 (eval thing)))))))))
    (fresh-line)
    (setq *l* (loop for (symbol . value) in '((*a* . a))
		    do (set symbol value)
		    collect symbol))
    (dw:do-redisplay displayer)
    (read-char)
    (set '*a* 'asdfgh)
    (dw:do-redisplay displayer)
    (read-char)
    (setf (first *l*) '*bb*)
    (dw:do-redisplay displayer)
    (read-char)
    displayer))

(defun redisplay-test-0a (&optional (stream *standard-output*))
  (let ((*standard-output* stream)
	;;(*debugging-display* t)
	(displayer (dw:redisplayer ()
		     (formatting-table ()
		       (dolist (thing *l*)
			 (dw:with-redisplayable-output (:unique-id thing)
			   (formatting-row () 
			     (formatting-cell ()
			       (prin1 thing))
			     (formatting-cell ()
			       (prin1 (eval thing))))))))))
    (fresh-line)
    (setq *l* (loop for (symbol . value) in '((*a* . a))
		    do (set symbol value)
		    collect symbol))
    (dw:do-redisplay displayer)
    (read-char)
    (set '*a* 'asdfgh)
    (dw:do-redisplay displayer)
    (read-char)
    (setf (first *l*) '*bb*)
    (dw:do-redisplay displayer)
    (read-char)
    displayer))

;;; This one is sort of like peek in that you have to be careful about
;;; when the values are allowed to change.  Note that even though the
;;; number goes up by 100 each time, the position of the right thing
;;; isn't affected by the change in width between phases.
(defun redisplay-test-4 ()
  (fresh-line)
  (setq *l* 1)
  (let ((displayer (dw:redisplayer ()
		     (dw:redisplayable-format t "Foo: ~D. " (setq *l* (* *l* 10)))
		     (dw:redisplayable-present 'fixed))))
    (loop
      (dw:do-redisplay displayer)
      (read-char))))

(defun redisplay-xtest-2 (&optional (stream *standard-output*))
  (let ((*standard-output* stream))
    (fresh-line)
    (formatting-table ()
      (formatting-column-headings ()
	"Area"
	(formatting-cell (() :align :right)
	  "#"))
      (loop repeat 5
	    for area in sys:area-list
	    do
	(let ((area area))
	  (formatting-row ()
	    (formatting-cell ()
	      (write area))
	    (formatting-cell (() :align :right)
	      (write (symbol-value area) :base 10))))))))

;; This verifies that table redisplay not at top level within redisplayer
;; happens at the right place.  It used to scribble all over itself.
(defun redisplay-test-9 (&optional (stream *standard-output*))
  #||
  (setf (fill-pointer zzs) 0)
  (setq kk nil)
  ||#
  (fresh-line stream)
  (flet ((foobar (stream)
	   (format stream "Foo ~a" (fs:default-pathname))
	   (formatting-table (stream)
	     (loop for j below 2
		   for stuff = (nthcdr (* j 5) sys:area-list)
		   do
	       (formatting-row (stream)
		 (loop repeat 2
		       for area in stuff
		       do
		   (formatting-cell (stream)
		     (present area (type-of area) :stream stream))))))
	   (format stream "~%Line following table ~s" 'foobar)))
    (let ((redisplayer
	    (dw:redisplayer (stream)
	      (foobar stream))))
      (send stream :increment-cursorpos 20 0 :character)
      (dw:do-redisplay redisplayer stream)
      (read-char)
      (fresh-line stream))))

;;---BUG ALERT! This feels like it gets slower as (n/2)^2 or so.  
(defun redisplay-xtest-2a (&optional stream debugging-display)
  (when (or (null stream) (eq stream t))
    (setq stream *standard-output*))
  (fresh-line stream)
  (let ((redisplayer
	  (dw:redisplayer (stream)
	    (formatting-table (stream)
	      #+ignore
	      (formatting-column-headings (stream)
		"Area"
		(formatting-cell (stream :align :right)
		  "#"))
	      (loop repeat 2
		    for area in *l*
		    do
		(let ((area area))
		  (formatting-row (stream)	; :unique-id area :cache-value (eval area)
		    (formatting-cell (stream)
		      (write area :stream stream))
		    (formatting-cell (stream :align :right)
		      (write (symbol-value area) :stream stream :base 10)))))))))
    (let ((*debugging-display* debugging-display)
	  (*l* sys:area-list))
      (loop do
	(let ((from (time:microsecond-time)))
	  (dw:do-redisplay redisplayer stream)
	  (format t "~&...~$ sec" (/ (time:time-difference (time:microsecond-time) from) 1e6)))
	(when (eql (read-char) #\end)
	  (return))
	(pop *l*)))
    redisplayer))
      
;;; Nested WITH-REDISPLAYABLE-OUTPUT's
(defun redisplay-test-6 ()
  (fresh-line)
  (let ((displayer (dw:redisplayer ()
		     (loop repeat 4
			   for i from 0 by 5
			   do (let ((i i))
				(dw:with-redisplayable-output (:unique-id i)
				  (dw:redisplayable-format t "Set #~d~%" i)))))))
    (loop
      (dw:do-redisplay displayer)
      (read-char))))

;;; Funny motion that requires compacting and expanding in the correct order.
(defun redisplay-test-7 ()
  (fresh-line)
  (let* ((pass 1)
	 (displayer (dw:redisplayer ()
		      (ecase pass
			((1)
			 (dw:with-redisplayable-output (:unique-id 'foo)
			   (princ "foo"))
			 (dw:with-redisplayable-output (:unique-id 'bar :cache-value 'bar)
			   (princ " bar"))
			 (terpri)
			 (dw:with-redisplayable-output (:unique-id 'baz)
			   (dw:independently-redisplayable-format t "~S ~S" 'baz-1 'baz-2)))
			((2)
			 (dw:with-redisplayable-output (:unique-id 'baz)
			   (dw:independently-redisplayable-format t "~S ~S" 'baz-1 'x))
			 (dw:with-redisplayable-output (:unique-id 'bar :cache-value 'bar)
			   (princ " bar")))))))
    (loop
      (dw:do-redisplay displayer)
      (read-char)
      (incf pass)
      (when (> pass 2)
	(return nil)))))

(defun redisplay-test-8 ()
  (fresh-line)
  (let* ((val 'foo)
	 (displayer (dw:redisplayer ()
		      (dw:with-redisplayable-output (:unique-id 'all :cache-value val)
			(dw:with-redisplayable-output (:unique-id 'first :cache-value 'first)
			  (princ "First: "))
			(prin1 val)))))
    (dw:do-redisplay displayer)
    (read-char)
    (setq val 'not-foo)
    (dw:do-redisplay displayer)))

(defun redisplay-test-arrow (&optional (n 5))
  (fresh-line)
  (let* ((*n* 0)
	 (disp (dw:redisplayer ()
		 (formatting-table ()
		   (dotimes (i n)
		     (formatting-row ()
		       (formatting-cell ()
			 (dw:with-redisplayable-output (:unique-id `(,i :arrow)
							:cache-value (= i *n*)
							:id-test #'equal)
			   (when (= i *n*)
			     (write-char #\arrow:right-open-arrow))))
		       (formatting-cell ()
			 (dw:with-redisplayable-output (:unique-id i :cache-value t)
			   (format t "~R" i)))))))))
    (loop
      (dw:do-redisplay disp)
      (case (read-char)
	(#\n (setq *n* (mod (1+ *n*) n)))
	(#\p (setq *n* (mod (1- *n*) n)))
	(#\r (setq *n* (random n)))))))

(defun redisplay-test-10 ()
  (fresh-line)
  (let* ((alist (copy-tree '((a . 1) (b . 2) (cc . 4) (dd . 8))))
	 (displayer (dw:redisplayer ()
		      (formatting-item-list (t :n-columns 2)
			(loop for (tag . value) in alist do
			  (formatting-cell ()
			    (dw:with-redisplayable-output (:unique-id tag)
			      (dw:independently-redisplayable-format t "~S ~S"
								     tag value))))))))
    (dw:do-redisplay displayer)
    (read-char)
    (dw:do-redisplay displayer)
    (read-char)
    (setf (cdr (assoc 'cc alist)) 3)
    (dw:do-redisplay displayer)
    displayer))

(defun redisplay-test-10a ()
  (fresh-line)
  (let* ((alist (copy-tree '((a . 1) (b . 2) (cc . 4) (dd . 8))))
	 (displayer (dw:redisplayer ()
		      (formatting-item-list (t :n-columns 2)
			(loop for (tag . value) in alist do
			  (formatting-cell ()
			    (progn
			      (dw:independently-redisplayable-format t "~S ~S"
								     tag value))))))))
    (dw:do-redisplay displayer)
    (read-char)
    (dw:do-redisplay displayer)
    (read-char)
    (setf (cdr (assoc 'cc alist)) 3)
    (dw:do-redisplay displayer)
    displayer))

(defun redisplay-test-* (&optional (report-p t))
  (fresh-line)
  (flet ((display-list (list uid tick)
	   (dw:with-redisplayable-output (:unique-id uid :cache-value tick)
	     (dolist (item list)
	       (dw:with-redisplayable-output (:unique-id item :cache-value t)
		 (prin1 item))
	       (terpri))))
	 (modify-list (list tick action)
	   (ecase action
	     ((:noop))
	     ((:add-start :add-middle :add-end)
	      (let ((new (1+ (reduce #'max list))))
		(case action
		  (:add-start (push new list))
		  (:add-end (setq list (nconc list (ncons new))))
		  (:add-middle (push new (cdr list)))))
	      (incf tick))
	     ((:delete-start :delete-middle :delete-end)
	      (case action
		(:delete-start (pop list))
		(:delete-end (setq list (nbutlast list)))
		(:delete-middle (pop (cdr list))))
	      (incf tick)))
	   (values list tick)))
    (let* ((l1 (loop for i from 101 repeat 9 collect i))
	   (t1 0)
	   (l2 (loop for i from 201 repeat 9 collect i))
	   (t2 0)
	   (displayer (dw:redisplayer ()
			(display-list l1 1 t1)
			(display-list l2 2 t2))))
      (dw:do-redisplay displayer)
      (dolist (action1 '(:noop :add-start :delete-start :add-middle :delete-middle
			       :add-end :delete-end))
	(dolist (action2 '(:noop :add-start :delete-start :add-middle :delete-middle
				 :add-end :delete-end))
	  (when report-p
	    (send *standard-output* :clear-rest-of-line)
	    (format t "1:~A 2:~A" action1 action2))
	  (read-char)
	  (multiple-value-setq (l1 t1)
	    (modify-list l1 t1 action1))
	  (multiple-value-setq (l2 t2)
	    (modify-list l2 t2 action2))
	  (dw:do-redisplay displayer))))))

(defun tmenu-1 (&optional (row-wise t))
  (fresh-line)
  (formatting-item-list (() :n-columns 3 :row-wise row-wise)
    (loop for x in (sort (copy-list sys:area-list) #'string-lessp)
	  do (formatting-cell ()
	       (write x :escape ())))))

(defun tmenu-2 (n)
  (fresh-line)
  (formatting-item-list ()
    (formatting-cell () (write n))
    (loop repeat n do (formatting-cell () "foo"))))

(defun tmenu-3 ()
  (fresh-line)
  (let ((inside-width (send *standard-output* :inside-width)))
    (surrounding-output-with-border ()
      (with-character-style ('(:jess :roman :large) () :bind-line-height t)
	(formatting-item-list (() :inside-width inside-width)
	  (loop for x in sys:area-list
		do (formatting-cell (() :align :center)
		     (write x :escape ()))))))))

(defun format-test-borders ()
  (fresh-line)
  (formatting-item-list (t :n-rows 1 :inter-row-spacing (send *standard-output* :line-height)
			   :return-at-end nil)
    (dolist (shape '(:rectangle :diamond :circle :oval))
      (loop for (filled thickness gray) in '((nil 0 1) (nil 1 1) (nil 10 1)
					     (t 1 1) (nil 10 .75)) do
	(formatting-cell (t :align-x :center :align-y :center)
	  (surrounding-output-with-border (t :shape shape :thickness thickness :filled filled
					     :gray-level gray)
	    (with-character-size (:tiny)
	      (format t "~S ~S ~S ~S" shape filled thickness gray))))))))

;;;; Grapher tests

(defun grapher-test-1 ()
  (fresh-line)
  (labels ((do-one (code &rest connections)
	     (let ((node (formatting-graph-node (t :id code :connections connections)
			   (surrounding-output-with-border ()
			     (prin1 code)))))
	       (unless (atom code)
		 (dolist (inf code)
		   (do-one inf :below node))))))
    (formatting-graph ()
      (do-one '((a b c) (e f) d)))))

;;; More or less same thing, using the standard generator.
(defun grapher-test-1a (&rest options &key stream &allow-other-keys)
  (fresh-line stream)
  ;; Make formatting consistent.
  (let ((gprint:*overriding-line-length* (send *standard-output* :size-in-characters)))
    (apply #'format-graph-from-root
	   '((a b c) (e f) d) #'prin1
	   (lambda (code) (unless (atom code) code))
	   options)))

(defun grapher-test-2 (&rest options &key stream &allow-other-keys)
  (fresh-line stream)
  (apply #'format-graph-from-root
	 '((a b c) (e b) d) #'prin1
	 (lambda (code) (unless (atom code) code))
	 :dont-draw-duplicates t
	 options))

(defun grapher-test-3 (direction dont-draw-duplicates)
  (format-graph-from-root '((a b) b c d e)
			  (lambda (o s) (write o :level 0 :length 0 :stream s))
			  (lambda (o) (unless (atom o) o))
			  :orientation :horizontal
			  :dont-draw-duplicates dont-draw-duplicates
			  :direction direction))

(defun grapher-test-4 (&key (branch-point :between-generations) (dont-draw-duplicates t)
			    (allow-overlap t))
  (let ((roots '(one two))
	(inferiors (make-hash-table :test #'equal)))
    (setf (gethash 'three inferiors) '(four five six seven))
    (setf (gethash 'two inferiors) '(six eight))
    (setf (gethash 'seven inferiors) '(four five))
    (setf (gethash 'eight inferiors) '(four seven three))
    (setf (gethash 'one inferiors) '(five six))
    (setf (gethash 'nine inferiors) '(ten))
    (setf (gethash 'eleven inferiors) '(nine))
    (setf (gethash 'ten inferiors) '(twelve))
    (fresh-line)
    (format-graph-from-root
      roots
      #'prin1
      #'(lambda (sup) (gethash sup inferiors))
      :test #'equal
      :branch-point branch-point
      :root-is-sequence t
      :allow-overlap allow-overlap
      :dont-draw-duplicates dont-draw-duplicates)))

(defun grapher-test-5 (&key (branch-point :between-generations) (dont-draw-duplicates t)
			    (allow-overlap t))
  (let ((roots '((+ 1 LN1A) T2))
	(inferiors (make-hash-table :test #'equal))
	(strings (make-hash-table :test #'equal)))
    (setf (gethash '(+ 2 LN2A) inferiors) '(LN2A LN1A LN2B (+ 1 LN2A)))
    (setf (gethash 'T2 inferiors) '(LN2B (+ 10 LN2A)))
    (setf (gethash '(+ 1 LN2A) inferiors) '(LN2A LN1A))
    (setf (gethash '(+ 10 LN2A) inferiors) '(LN2A (+ 1 LN2A) (+ 2 LN2A)))
    (setf (gethash '(+ 1 LN1A) inferiors) '(LN1A LN2B))
    (setf (gethash '2 inferiors) '(1))
    (setf (gethash '10 inferiors) '(2))
    (setf (gethash '1 inferiors) '(0))
    (setf (gethash '(+ 2 LN2A) strings) " (+ LN2A (* 2 DELTA)) = (+ 2 LN2A) 
 (-1e,+1e) ")
    (setf (gethash '(+ 1 LN2A) strings) " (+ DELTA LN2A) = (+ 1 LN2A) 
 (-1e,+1e) ")
    (setf (gethash 'T2 strings) " UN2A = T2 
 (-1e,+1e) ")
    (setf (gethash '(+ 10 LN2A) strings) " (+ T1 (* 10 DELTA)) = (+ LN2A (* 10 DELTA)) = (+ 10 LN2A) 
 (-1e,+1e) ")
    (setf (gethash '(+ 1 LN1A) strings) " (+ DELTA LN1A) = (+ 1 LN1A) 
 (-1e,+1e) ")
    (setf (gethash 'LN1A strings) " LN1A 
 (-1e,+1e) ")
    (setf (gethash 'LN2A strings) " T1 = LN2A 
 (-1e,+1e) ")
    (setf (gethash 'LN2B strings) " LN2B 
 (-1e,+1e) ")
    (fresh-line)
    (format-graph-from-root
      roots
      #'(lambda (x stream)
	  (dw:with-output-as-presentation
	    (:stream stream :object x :type (type-of x) :allow-sensitive-inferiors nil)
	    (princ (gethash x strings) stream)))
      #'(lambda (sup) (gethash sup inferiors))
      :test #'equal
      :branch-point branch-point
      :root-is-sequence t
      :allow-overlap allow-overlap      
      :dont-draw-duplicates dont-draw-duplicates)))

(defun grapher-test-6 (direction dont-draw-duplicates)
  (format-graph-from-root '((c1 c2) ((c1 c2 c3)) dddddd)
			  (lambda (o s) (write o :level 0 :length 0 :stream s))
			  (lambda (o) (unless (atom o) o))
			  :orientation :horizontal
			  :dont-draw-duplicates dont-draw-duplicates
			  :direction direction
			  :allow-overlap t
			  :default-drawing-mode ':arrow))

(defun grapher-test (list &rest options &key stream &allow-other-keys)
  (fresh-line stream)
  (apply #'format-graph-from-root
	 list 
	 #'(lambda (code stream) (write code :stream stream :level 0 :length 0))
	 #'(lambda (code) (unless (atom code) code))
	 options))

(defun flavor-components (flavor-name)
  (flavor::flavor-local-components
    (flavor:find-flavor flavor-name)))

(defun present-flavor (flavor-name &optional (stream *standard-output*))
  (present flavor-name 'flavor:flavor-name :stream stream))

(cp:define-command (com-show-flavor-tree :command-table "Global")
    ((root-flavor-name 'flavor:flavor-name))
  (fresh-line)
  (format-graph-from-root root-flavor-name #'present-flavor #'flavor-components))

;;; This is like the SGR and Gooch things.
(defun sideways-flavor-grapher (root-flavor-name)
  (fresh-line)
  (format-graph-from-root root-flavor-name #'present-flavor #'flavor-components
			  :default-drawing-mode :arrow
			  :orientation :horizontal
			  :border nil))

;;; A slightly more complicated version that shows how to do your own flow control.
(defun format-graph-with-duplicate-tags (root printer inferior-producer
					 &key (orientation :vertical))
  (let ((duplicate-table (make-hash-table)))
    (let ((index 0))
      (labels ((find-duplicates (node)
		 (modify-hash duplicate-table node
			      #'(lambda (ignore value ignore)
				  (case value
				    ((t) (incf index))
				    ((nil) t)
				    (otherwise value))))
		 (map () #'find-duplicates (funcall inferior-producer node))))
	(find-duplicates root)))
    (formatting-graph (t :orientation orientation)
      (labels ((do-tag-node (tag connections)
		 (formatting-graph-node (t :connections connections)
		   (surrounding-output-with-border (t :shape :circle)
		     (prin1 tag))))
	       (do-one (node connections)
		 (let ((tag (gethash node duplicate-table)))
		   (when (numberp tag)
		     (let ((old-node (dw:find-graph-node *standard-output* node)))
		       (when old-node
			 (return-from do-one (do-tag-node tag connections))))
		     (let ((intermediate (do-tag-node tag connections)))
		       (setq connections `(:after ,intermediate)))))
		 (let ((this-node (formatting-graph-node (t :connections connections
							    :id node)
				    (surrounding-output-with-border ()
				      (funcall printer node)))))
		   (dolist (inferior (funcall inferior-producer node))
		     (do-one inferior `(:after ,this-node))))))
	(do-one root nil)))))

(cp:define-command (com-show-flavor-tree :command-table "Global")
    ((root-flavor-name 'flavor:flavor-name)
     &key
     (orientation '((member :horizontal :vertical)) :default :vertical))
  (fresh-line)
  (format-graph-with-duplicate-tags root-flavor-name #'present-flavor #'flavor-components
				    :orientation orientation))

zwei:
(define-zmail-top-level-command com-zmail-show-conversation-graph
				"Show the current conversation as a tree" ()
  (dw:format-graph-from-root (send *sequence* :array)
    (lambda (msg stream)
      (let ((tem (summarize-recipients (msg-get msg :from) 10.)))
	(dw:with-output-as-presentation
	  (:type 'msg :object msg :stream stream)
	  (cl:write-string (if (equal tem "") user-id tem) stream))))
    (lambda (msg)
      (let ((list (get-multiple-references msg (msg-references msg) *sequence*)))
	(remq msg list)))
    :dont-draw-duplicates t
    :direction :above
    :root-is-sequence t)
  dis-none)

#||
(defun fact (n)
  (if (zerop n)
      1
    (print n)
    (* n (fact (1- n)))))
||#

;;; This mostly works, except that there isn't any constraint
;;; propagation to move the conditionals down next to their lefthand
;;; connection.
(defun flow-chart-test-1 (function)
  (fresh-line)
  (labels ((draw-progn (form to-return-p previous)
	     (loop for (form . rest) on form
		   with first = nil
		   as prev = previous then node
		   as node = (draw-form form (and to-return-p (null rest)) prev)
		   when (null first) do (setq first node)
		   finally (return first)))
	   (draw-conditional (cond true-forms false-forms to-return-p previous)
	     (let ((cond-node (draw-form-box cond previous :diamond)))
	       (draw-progn true-forms to-return-p cond-node)
	       (let ((false-branch (draw-progn false-forms to-return-p nil)))
		 (dw:connect-graph-nodes *standard-output* false-branch
					 `(:right ,cond-node)))))
	   (draw-form (form to-return-p previous)
	     (cond ((and (listp form) (eq (first form) 'if))
		    (draw-conditional (second form) (list (third form))
				      (cdddr form) to-return-p previous))
		   (t
		    (draw-form-box form previous
				   (cond ((not to-return-p) :rectangle)
					 ((atom form) :circle)
					 (t :oval))))))
	   (draw-form-box (form previous shape)
	     (formatting-graph-node (t :connections (and previous `(:below ,previous)))
	       (surrounding-output-with-border (t :shape shape)
		 (prin1 form)))))
    (let ((definition (cadr (assoc :interpreted-form (debugging-info function)))))
      (unless definition
	(error "Cannot find interpreted definition of ~S." function))
      (destructuring-bind (nil nil arglist . body) definition
	(formatting-graph ()
	  (let ((input (if (null (cdr arglist))
			   (draw-form-box (first arglist) nil :circle)
			   (draw-form-box arglist nil :oval))))
	    (draw-progn body t input)))))))

;;; This database loses a lot, but RWK seems to be a fair test case user.
;;; Also, this one is hard to write using FORMAT-GRAPH-FROM-ROOT and avoiding having to either
;;; call FIND-OBJECT-NAMED twice or check for STRINGP somewhere.
(cp:define-command (com-show-organization :command-table "Global")
    ((seed-user 'net:user))
  (fresh-line)
  (labels ((do-user (user-name &rest connections)
	     (let ((old-node (dw:find-graph-node *standard-output* user-name
						 :test #'string-equal)))
	       (if old-node
		   (dw:connect-graph-nodes *standard-output* old-node connections)
		   (condition-case (user-object)
		       (net:find-object-named :user user-name)
		     (net:object-not-found
		      (formatting-graph-node (t :id user-name :connections connections)
			(surrounding-output-with-border ()
			  (write-string user-name))))
		     (:no-error
		      (let ((node (formatting-graph-node (t :id user-name
							:connections connections)
				    (surrounding-output-with-border ()
				      (dw::centering-lines ()
					(dw:with-output-as-presentation
					    (:object `(:user ,user-object)
					     :type 'cp::user-at-host-or-site)
					  (write-string
					    (send user-object
						  :personal-name-first-name-first)))
					(let ((project (send user-object :project)))
					  (when project
					    (terpri)
					    (with-character-size (:small)
					      (write-string project)))))))))
			(let ((super (send user-object :supervisor)))
			  (when super
			    (do-user super :above node)))
			(flet ((do-infs (key)
				 (dolist (inf (net:find-objects-from-property-list
						:user :supervisor key))
				   (do-user inf :below node))))
			  (do-infs (string user-object))
			  (do-infs (send user-object :personal-name-first-name-first)))
			node)))))))
    (net:keeping-namespace-server
      (formatting-graph ()
	(do-user seed-user)))))

;;;; Combinations

(defun nested-formatting-1 (&optional (ntables 2) (nrows 3) (ncols 2))
  (fresh-line)
  (formatting-item-list (t :n-rows 1)
    (dotimes (i ntables)
      (formatting-cell ()
	(formatting-item-list (t :n-rows nrows :n-columns ncols)
	  (dotimes (row nrows)
	    (dotimes (col ncols)
	      (formatting-cell ()
		(format t "Cell ~D,~D" row col)))))))))

(defun nested-formatting-1a (&optional (ntables 2) (nrows 3) (ncols 2))
  (fresh-line)
  (formatting-table ()
    (formatting-column-headings ()
      (dotimes (table ntables)
	(with-character-style ('(nil :bold :large) t :bind-line-height t)
	  (formatting-cell (t :align-x :center)
	    (format t "Table #~D" table)))))
    (formatting-row ()
      (dotimes (table ntables)
	(formatting-cell ()
	  (formatting-table ()
	    (formatting-column-headings ()
	      (dotimes (col ncols)
		(formatting-cell ()
		  (format t "Column #~D" col))))
	    (dotimes (row nrows)
	      (formatting-row ()
		(dotimes (col ncols)
		  (formatting-cell ()
		    (format t "Cell ~D,~D" row col)))))))))))

(defun nested-formatting-2 (&optional (tree '(((1 2 3 4) ((5 6 7))) ((9 10 11)))))
  (fresh-line)
  (format-graph-from-root tree
			  #'(lambda (node stream)
			      (if (consp (first node))
				  (with-character-size (:large stream :bind-line-height t)
				    (princ "*" stream))
				  ;; Note how this functional interface differs from
				  ;; formatting-item-list in its defaults.
				  (format-item-list node :stream stream
							 :optimal-number-of-rows 2
							 :fresh-line nil
							 :additional-indentation 0)))
			  #'(lambda (node)
			      (and (consp (first node)) node))))

(defun nested-formatting-3 (&optional (tree '((a b c) (e f) d)))
  (fresh-line)
  (formatting-table ()
    (formatting-column-headings ()
      (dotimes (graph 2)
	(with-character-style ('(nil :bold :large) t :bind-line-height t)
	  (formatting-cell (t :align-x :center)
	    (format t "Graph #~D" graph)))))
    (formatting-row ()
      (dolist (orientation '(:horizontal :vertical))
	(formatting-cell ()
	  (format-graph-from-root tree #'prin1 #'(lambda (code) (unless (atom code) code))
				  :orientation orientation))))))

;;;; Accept-values tests

(defun accept-values-on-sequence-test (l)
  (fresh-line *query-io*)
  (let ((x l))
    (dw:accepting-values (*query-io* :resynchronize-every-pass t)
      (setq x
	    (dw:accept-values-on-sequence
	      x
	      #'(lambda (elt stream index last-p)
		  (let ((qbase-increment 0))
		    (flet ((qid ()
			     (+ (* 100000 index) (if last-p 10000 0)
				(incf qbase-increment))))
		      (with-character-face ((if last-p :italic nil) *query-io*)
			(list (accept 'pathname :default (car elt) :stream stream
				      :query-identifier (qid)
				      :prompt (format nil "File ~D" index))
			  (accept 'boolean :default (cadr elt) :stream stream
				  :query-identifier (qid)
				  :prompt (format nil " Options ~D" index))))))))))))

(defun accept-values-test (&key (own-window nil) (temporary-p own-window))
  (fresh-line)
  (dw:accepting-values (t :own-window own-window :temporary-p temporary-p)
    (let ((x (accept '((member :file :number :nothing))
		     :prompt "Do you want a file, number, or nothing"
		     :default :file)))
      (values x
	      (ecase x
		(:file (prompt-and-accept 'pathname "Name of the input file"))
		(:nothing)
		(:number (prompt-and-accept '(:type integer :default 3) "Cuts of Pork")))))))

(defun accept-values-test-a (&key (own-window nil) (temporary-p own-window))
  (fresh-line)
  (dw:accepting-values (t :own-window own-window :temporary-p temporary-p)
    (let ((x (accept '((alist-member :alist (("File" :value :file :documentation "A file")
					     ("Number" :value :number :documentation "A num")
					     ("Nothing" :value :nothing))))
		     :prompt "Do you want a file, number, or nothing"
		     :default :file)))
      (values x
	      (ecase x
		(:file (prompt-and-accept 'pathname "Name of the input file"))
		(:nothing)
		(:number (prompt-and-accept '(:type integer :default 3) "Cuts of Pork")))))))

(defun accept-values-test-1 ()
  (fresh-line)
  (dw:accepting-values ()
    (when (accept 'boolean :default t)
      (prompt-and-accept 'string "Foo then"))))

(defun accept-values-test-2 ()
  (fresh-line)
  (dw:accepting-values ()
    (loop for type in (accept '((subset :file :number :nothing))
			      :prompt "Which kinds"
			      :default '(:file))
	  collect (ecase type
		    (:file (prompt-and-accept 'pathname "Name of the input file"))
		    (:nothing)
		    (:number (prompt-and-accept '(:type integer :default 3)
						"Cuts of Pork"))))))

(defun accept-values-test-3 ()
  (fresh-line)
  (dw:accepting-values ()
    (let* ((one (accept '((member :foo :bar)) :default :foo))
	   (two (accept '((member :bar :foo)) :default one)))
      (values one two))))

(defun accept-values-test-4 ()
  (fresh-line)
  (dw:accepting-values ()
    (when (accept 'boolean :prompt "Foo")
      (accept '((member :foo-1 :foo-2)) :prompt "Which foo"))
    (accept '((member :foo :bar)) )))

(defun accept-values-test-5 ()
  (fresh-line)
  (dw:accepting-values ()
    (list (multiple-value-list (accept 'number))
	  (multiple-value-list (accept '((member :foo :bar)))))))

(defun accept-values-test-6 ()
  (fresh-line)
  (dw:accept-values '((((member "first
choice" "second
choice")) :prompt "choice"))))

;;; If you change the FORMAT in PROMPT-AND-ACCEPT to REDISPLAYABLE-FORMAT, instead
;;; of getting out of synch, this clears completely!
(defun accept-values-test-cs ()
  (fresh-line)
  (dw:accepting-values ()
    (let ((cstyle (accept 'character-style)))
      (values cstyle
	      (prompt-and-accept 'string "String to display in ~A" cstyle)))))

(defun accept-values-test-disappear ()
  (fresh-line)
  (let ((foo t))
    (dw:accepting-values (t :resynchronize-every-pass t)
      (if foo
	  (setq foo (accept 'boolean :default foo :prompt "foo"))
	  (accept 'integer)))))

(defun accept-values-test-error ()
  (fresh-line)
  (dw:accepting-values ()
    (let* ((host (accept 'net:host :default net:*local-host*))
	   (file (accept 'pathname :default (fs:user-homedir))))
      (let ((check (cond ((neq host (send file :host))
			  "Host does not match pathname.")
			 (t nil))))
	(when check
	  (dw:redisplayable-format t "Inconsistent arguments:~%")
	  (dw:redisplayable-format t "  ~A~%" check)))
      (values host file))))

(defun run-test-cases (&optional (cases '(:formatting :redisplay :grapher :accept-values)))
  (flet ((do-tests (name tests)
	   (when (member name cases)
	     (format t "~&~:(~A~).~%" name)
	     (dolist (form tests)
	       (format t "~&~S~%" form)
	       (catch-error-restart ((sys:abort error) "Skip to next test")
		 (eval form))))))
    (do-tests :formatting '((format-test-1 (subseq sys:area-list 0 5))
			    (format-test-b (subseq sys:area-list 5 10))
			    (format-test-b (subseq sys:area-list 0 10)
					   :style '(:dutch nil :small))
			    (format-test-2)
			    (format-test-2r)
			    (format-test-2i)
			    (format-test-x-list)
			    (format-test-x)
			    (format-test-a (subseq sys:area-list 0 7))
			    (format-test-2a)
			    (format-test-il)
			    (format-test-il-1)
			    (format-test-il-2)
			    (format-test-s sys:area-list)
			    (princ (test-presentation-recording-string))
			    (read)
			    (format-test-areas)
			    (system-menu-format-test)
			    (format-test-calc)
			    (bordered-table-test-2)
			    (tmenu-1)
			    (tmenu-2 3)
			    (tmenu-3)
			    (nested-formatting-1)
			    (nested-formatting-1a)
			    (format-test-borders)))
    (do-tests :redisplay '((redisplay-test-1)
			   (redisplay-test-1x)
			   (redisplay-test-2)
			   (redisplay-test-2a)
			   (redisplay-test-3)
			   (redisplay-test-0)
			   (redisplay-test-0a)
			   (redisplay-test-4)
			   (redisplay-xtest-2)
			   (redisplay-test-9)
			   (redisplay-xtest-2a)
			   (redisplay-test-6)
			   (redisplay-test-7)
			   (redisplay-test-8)
			   (redisplay-test-10)
			   (redisplay-test-10a)
			   (redisplay-test-arrow)))
    (do-tests :grapher '((grapher-test-1)
			 (grapher-test-1a)
			 (grapher-test-1a :balance-evenly t)
			 (grapher-test-1a :orientation :horizontal)
			 (grapher-test-1a :orientation :horizontal :direction :before)
			 (grapher-test-2)
			 (grapher-test-2 :border '(:thickness 2 :shape :oval))
			 ;; Should be free of lines overlapping boxes as of 369.17
			 (grapher-test '((a)
					 (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
					 ((c1 c2 c3 c4 c5))
					 (dddddddddddddddddddddddddddddd)
					 (e))
				       :orientation :horizontal)
			 (grapher-test-3 :after nil)
			 ;; This shows the unresolved problem of lines overlapping boxes
			 ;; when eliminating duplicates.
			 (grapher-test-3 :after t)
			 (grapher-test-3 :before nil)
			 ;; So does this
			 (grapher-test-3 :before t)
			 ;; These two should not blow out in spite of multiple roots and
			 ;; duplicated nodes.  Still a mess of overlapping lines, though.
			 (grapher-test-4)
			 (grapher-test-5)
			 (grapher-test-6 ':after nil)
			 (grapher-test-6 ':after t)
			 (nested-formatting-2)
			 (nested-formatting-3)
			 (com-show-flavor-tree 'tv:window)
			 (sideways-flavor-grapher 'fs:lmfs-pathname)))
    (do-tests :accept-values '((accept-values-test)
			       (accept-values-test-a)
			       (accept-values-test-1)
			       (accept-values-test-2)
			       (accept-values-test-3)
			       (accept-values-test-4)
			       (accept-values-test-5)
			       (accept-values-test-6)
			       (accept-values-test-disappear)
			       (accept-values-test-error)))
    ))

;;;; Combinatorial tests

(defparameter *ctest-device-types* '(:window :lgp2 :string :buffer :file))
(defvar *ctests* nil)

(defstruct ctest
  function-name
  (devices *ctest-device-types*)
  (parameters nil)
  (error-cases nil))

(defprop defctest defun zwei:definition-function-spec-type)

(defmacro defctest (name (stream &rest arguments) (&rest options) &body body)
  `(progn
     (defun ,name (&optional (,stream *standard-output*)
		   &key . ,(loop for (var def) in arguments collect (list var def)))
       . ,body)
     (defctest-internal ',name
			:parameters ',(loop for (var def vals) in arguments
					    when vals
					      collect (list* (intern (symbol-name var) "")
							     vals))
			. ,(loop for (key val) on options by 'cddr
				 collect key collect `',val))))

(defun defctest-internal (function-name &rest options)
  (pushnew (apply #'make-ctest :function-name function-name options)
	   *ctests* :replace t :key #'ctest-function-name))

(defun run-ctest-cases (&key (devices *ctest-device-types*) (error-cases t))
  (dolist (device devices)
    (flet ((do-one-set (stream)
	     (dolist (ctest (reverse *ctests*))
	       (when (member device (ctest-devices ctest))
		 (run-function-ctest-cases ctest stream)))))
      (let ((value (call-with-device-stream device #'do-one-set)))
	(case device
	  (:lgp2
	    (format t "~&Hardcopy output sent to ~A.~%" value))
	  (:string
	    (setf (symbol-value '*ctest-output*) value)
	    (format t "~&String output stored in ~S.~%" '*ctest-output*))
	  (:buffer
	    (format t "~&Buffer output in ~A.~%" value))
	  (:file
	    (format t "~&File output in ~A.~%" value))))))
  (when error-cases
    (dolist (ctest (reverse *ctests*))
      (dolist (parameters (ctest-error-cases ctest))
	(apply #'run-ctest-expecting-error (ctest-function-name ctest) parameters))))
  )

(defun run-function-ctest-cases (function &optional (stream *standard-output*))
  (when (symbolp function)
    (setq function (find function *ctests* :key #'ctest-function-name)))
  (labels ((call-with-more-parameters (more-parameters &rest parameters)
	     (if more-parameters
		 (destructuring-bind ((keyword . values) . rest) more-parameters
		   (dolist (value values)
		     (apply #'call-with-more-parameters rest keyword value parameters)))
		 (catch-error-restart ((error sys:abort) "Move to next test")
		   (apply #'do-test (ctest-function-name function) parameters))))
	   (do-test (function &rest parameters)
	     (format stream "~2&")
	     (print-ctest-options function parameters stream)
	     (terpri stream)
	     (apply function stream parameters)))
    (call-with-more-parameters (ctest-parameters function))))

(defun print-ctest-options (function args &optional (stream *standard-output*))
  (format stream "~S " function)
  (when args
    (write args :stream stream :pretty :plist)))

(defun run-ctest-expecting-error (function &rest args &key (device :window) &allow-other-keys)
  (flet ((do-it (stream)
	   (condition-case (error)
		(si:with-rem-keywords (some-args args '(:device))
		  (apply function stream some-args))
	      (error
		(fresh-line)
		(print-ctest-options function args)
		(format t " got an error (as expected) (~S).~%  ~~A~~%"
			(type-of error) error))
	      (:no-error
		(fresh-line)
		(print-ctest-options function args)
		(format t " failed to get an error.")))))
    (call-with-device-stream device #'do-it)))

(defun call-with-device-stream (device function &rest args)
  (ecase device
    (:window
      (apply function *terminal-io* args)
      nil)
    (:lgp2
      (with-open-stream (stream (hardcopy:make-hardcopy-stream
				  hardcopy:*default-text-printer*))
	(condition-bind ((hardcopy:hardcopy-outside-of-bounding-box
			   #'hardcopy:simple-formatter-exception-interceptor))
	  (apply function stream args)))
      hardcopy:*default-text-printer*)
    (:string
      (with-output-to-string (stream)
	(apply function stream args)))
    (:buffer
      (with-open-stream (stream (zwei:open-editor-stream :buffer-name "CTest output"))
	(apply function stream args)
	(zwei:bp-top-level-node (send stream :read-bp))))
    (:file
      (with-open-file (stream (send (fs:user-homedir) :new-pathname :name "CTEST-OUTPUT"
				    :type :text :version :newest)
			      :direction :output)
	(apply function stream args)
	(send stream :close)
	(send stream :truename)))))

;;; The actual test cases.

(defctest ctest-abbreviating-output (stream (list sys:area-list)) ()
  (abbreviating-output (stream :width 20 :height 2 :show-abbreviation t)
    (prin1 list stream)))

(defctest ctest-abbreviating-output-in-cell (stream) ()
  (formatting-table (stream)
    (loop repeat 10
	  for i from 0 by 4
	  do
      (formatting-row (stream)
	(format-cell i #'prin1 :stream stream :align :right)
	(formatting-cell (stream)
	  (ctest-abbreviating-output stream :list (subseq sys:area-list i (+ i 4))))))))

(defctest ctest-filling-output (stream
				 (fill-column '(50 :character))
				 (type :basic (:basic :gprint))
				 (underline-p nil (nil t)))
	  ()
  (labels ((do-it (stream)
	     (filling-output (stream :fill-column fill-column)
	       (ecase type
		 (:basic (write-string (substitute #\space #\null
						   (subseq sage::*keyword-token-characters*
							   0 250))
				       stream))
		 (:gprint (prin1 sys:area-list stream))))))
    (if underline-p
	(with-underlining (stream :underline-whitespace nil)
	  (do-it stream))
	(do-it stream))))

(defctest ctest-formatting-graph (stream
				   (orientation :vertical (:vertical :horizontal)))
				 (:devices (:window :lgp2)
				  :error-cases ((:device :string)))
  (format-graph-from-root 
    '((a b c) (e f) d) #'prin1
    (lambda (code) (unless (atom code) code))
    :stream stream :orientation orientation))

(defctest ctest-formatting-item-list (stream
				       (type :basic (:basic :gprint :styled))
				       (n-rows nil (nil 2 5))
				       (row-wise t (t nil)))
				     ()
  (formatting-item-list (stream :row-wise row-wise :n-rows n-rows)
    (dotimes (n 20)
      (formatting-cell (stream)
	(ecase type
	  (:basic (format stream "~R" n))
	  (:gprint (prin1 (subseq sys:area-list (* n 3) (* (1+ n) 3)) stream))
	  (:styled
	    (let ((style (si:parse-character-style
			   (list (nth (mod n 3) '(nil :dutch :swiss))
				 (nth (mod (floor n 3) 3) '(nil :bold :italic))
				 (nth (mod (floor n 9) 2) '(nil :small :large))))))
	      (with-character-style (style stream :bind-line-height t)
		(present style 'si:character-style :stream stream)))))))))

(defctest ctest-formatting-table (stream
				   (type :numeric (:numeric :english :gprint :styled))
				   (multiple-columns nil (nil t 2)))
				 ()
  (formatting-table (stream :multiple-columns multiple-columns)
    (dotimes (n 20)
      (if (eq type :styled)
	  (let ((style (si:parse-character-style
			 (list (nth (mod n 3) '(nil :dutch :swiss))
			       (nth (mod (floor n 3) 3) '(nil :bold :italic))
			       (nth (mod (floor n 9) 2) '(nil :small :large))))))
	    (formatting-row (stream)
	      (formatting-cell (stream)
		(present style 'si:character-style :stream stream))
	      (formatting-cell (stream)
		(with-character-style (style stream :bind-line-height t)
		  (format stream "~R" n)))))
	  (formatting-row (stream)
	    (format-cell n #'prin1 :align :right :stream stream)
	    (formatting-cell (stream)
	      (ecase type
		(:numeric (prin1 (* n n) stream))
		(:english (format stream "~R" n))
		(:gprint (prin1 (subseq sys:area-list (* n 3) (* (1+ n) 3)) stream)))))))))

(defctest ctest-formatting-column-headings (stream
					     (type :normal (:normal :multi-line))
					     (underline-p nil (nil t)))
					   (:error-cases ((:type :duplicate)))
  (formatting-table (stream)
    (formatting-column-headings (stream :underline-p underline-p)
      (dolist (cell (if (eq type :multi-line)
			'("N" "N~%Squared" "N~%Cubed")
			'("N" "Squared" "Cubed")))
	(formatting-cell (stream)
	  (format stream cell))))
    (when (eq type :duplicate)
      (formatting-column-headings (stream)
	(dotimes (i 3)
	  (format-cell i #'prin1 :stream stream))))
    (dotimes (i 5)
      (formatting-row (stream)
	(format-cell i #'prin1 :stream stream :align :right)
	(format-cell (expt i 2) #'prin1 :stream stream :align :right)
	(format-cell (expt i 3) #'prin1 :stream stream :align :right)))))

(defctest ctest-formatting-column (stream (multi-line nil (nil t))) ()
  (formatting-table (stream)
    (dotimes (m 3)
      (formatting-column (stream)
	(dotimes (n 5)
	  (formatting-cell (stream)
	    (when multi-line (format stream "~R~%" (+ n (* m 10))))
	    (prin1 (+ n (* m 10)) stream)))))))

(defctest ctest-formatting-graphics-cell (stream) (:devices (:window :lgp2)
						   :error-cases ((:device :string)))
  (let ((stipples (map 'list #'symbol-value 'stipples:(vertical-lines horizontal-lines
						       filled-diamonds hearts))))
    (formatting-table (stream :inter-row-spacing 10)
      (formatting-row (stream)
	(format-cell "Gray" #'princ :stream stream)
	(dolist (stipple stipples)
	  (format-cell stipple #'princ :stream stream)))
      (loop for gray from 0 to 1 by 1/4 do
	(formatting-row (stream)
	  (format-cell gray #'prin1 :align-y :center :stream stream)
	  (dolist (stipple stipples)
	    (graphics:formatting-graphics-cell (stream :align-x :center :align-y :center)
	      (graphics:draw-circle 0 0 30 :gray-level gray :stipple stipple :stream stream)))
	  )))))

(defctest ctest-formatting-multiple-columns (stream
					      (inside :basic (:basic :gprint)))
					    (:error-cases ((:inside :table)))
  (formatting-multiple-columns (stream :number-of-columns 2)
    (ecase inside
      (:basic
	(dotimes (i 20)
	  (format stream "~D ~R~%" i i)))
      (:gprint
	(let ((gprint:*overriding-line-length* 25))
	  (prin1 sys:area-list stream)))
      (:table
	(ctest-formatting-table stream)))))

(defctest ctest-table-state-error (stream (extra-output nil))
	  (:devices ()
	   :error-cases ((:extra-output :fresh-line)
			 (:extra-output :terpri)
			 ()))
  (formatting-table (stream)
    (case extra-output
      (:fresh-line
	(fresh-line stream))
      (:terpri
	(terpri stream)))
    (formatting-row ()
      (formatting-cell (stream)
	(ignore stream)))))

(defctest ctest-nested-tables (stream
				(inside :table (:table :menu :graph))
				(outside :table (:table :menu :graph)))
			      (:devices (:window :lgp2))
  (labels ((inside (stream n)
	     (ecase inside
	       (:table
		 (formatting-table (stream)
		   (loop for m from (* n 5) repeat 4 do
		     (formatting-row (stream)
		       (format-cell m #'prin1 :stream stream :align :right)
		       (format-cell (expt m 2) #'prin1 :stream stream :align :right)))))
	       (:menu
		 (formatting-item-list (stream)
		   (loop for m from (* n 5) repeat 4 do
		     (formatting-cell (stream)
		       (format stream "~R" m)))))
	       (:graph
		 (ctest-formatting-graph stream)))))
    (ecase outside
      (:table
	(formatting-table (stream)
	  (formatting-column-headings (stream)
	    (dotimes (table 3)
	      (with-character-style ('(nil :bold :large) stream :bind-line-height t)
		(formatting-cell (stream :align-x :center)
		  (format stream "Subtable #~D" (1+ table))))))
	  (formatting-row (stream)
	    (dotimes (table 3)
	      (formatting-cell (stream)
		(inside stream table))))))
      (:menu
	(formatting-item-list (stream :n-columns 2)
	  (dotimes (table 4)
	    (formatting-cell (stream)
	      (inside stream table)))))
      (:graph
	(format-graph-from-root '((1 2) 3 (4))
				#'(lambda (node stream)
				    (if (consp node)
					(prin1 node stream)
					(inside stream node)))
				#'(lambda (node)
				    (and (consp node) node))
				:default-drawing-options '(:thickness 2) :stream stream)))))

(defctest ctest-formatting-textual-list (stream
					  (type :basic (:basic :gprint :styled :underline))
					  (filled t))
					()
  ;--- declared arglist :fill-column??
  (formatting-textual-list (stream :filled filled)
    (dotimes (n 20)
      (formatting-textual-list-element (stream)
	(ecase type
	  (:basic
	    (format stream "~R" n))
	  (:underline
	    ;--- This one seems to fail.
	    (with-underlining (stream :underline-whitespace nil)
	      (format stream "~R" n)))
	  (:styled
	    (let ((style (si:parse-character-style
			   (list (nth (mod n 3) '(nil :dutch :swiss))
				 (nth (mod (floor n 3) 4) '(nil :bold :italic :bold-italic))
				 (nth (mod (floor n 12) 2) '(nil :small))))))
	      (with-character-style (style stream)
		(present style 'si:character-style :stream stream))))
	  (:gprint
	    (prin1 (subseq sys:area-list (* n 3) (* (1+ n) 3)) stream)))))))

(defctest ctest-surrounding-output-with-border (stream
						 (type :basic (:basic :table :item-list
							       :filled))
						 (shape :rectangle (:rectangle :oval)))
					       ()
  (surrounding-output-with-border (stream :shape shape)
    (ecase type
      (:basic (write-string "Inside" stream))
      (:table (ctest-formatting-table stream :multiple-columns 2))
      (:item-list (ctest-formatting-item-list stream :n-rows 5))
      (:filled (ctest-filling-output stream :underline-p t)))))

(defctest ctest-with-underlining (stream
				   (underline-whitespace nil (nil t))
				   )
				 ()
  (with-underlining (stream :underline-whitespace underline-whitespace)
    (write-string (subseq (documentation 'zl:format) 0 400) stream)))
