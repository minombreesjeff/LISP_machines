;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Definitions for all of the DW input substrate

;;; Yet again
(defun fintern (format-string &rest format-args)
  (intern (let ((package *package*))
	    (with-standard-io-environment
	      (let ((*package* package))
		(apply #'format () format-string format-args))))))


(defvar *all-presentation-types* nil :localize t)

;;;Miscellaneous areas
;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*handler-dynamic-area*0 holds objects infrequently used objects
;;; which can become garbage, such as the lists of handlers affected
;;; by redefinitions of a type.
;;; 1*handler-ephemeral-area*0 holds objects used for only a short time.
;;; These are the general utility areas.  The other areas are limited
;;; to specific uses, often by requirements of the way they are full-GC'd.

(defvar *handler-dynamic-area*
	(make-area :name '*handler-dynamic-area*
		   :gc :dynamic
		   :region-size 100000))

(defvar *handler-ephemeral-area*
	(make-area :name '*handler-ephemeral-area*
		   :gc :ephemeral
		   :capacity 10000
		   :capacity-ratio 2
		   :region-size 100000))

(defvar *presentation-type-area* (make-area :name '*presentation-type-area*
					    :gc :static))

(defvar *handler-area* (make-area :name '*handler-area*))

;;; This contains only the predicates, which are used extensively at final wave-the-mouse
;;; time, and shared among the many cache entries.  These are together so they can stay
;;; in virtually all the time: faulting on one brings in most of them.
;;; Actually, these aren't GC'd at all, because it would only hurt more than it helped.
;;; We'd have to empty the table, and we can't rebuild it because we can't reconstruct
;;; the keys.  If we saved the keys away in the environments somehow, we could do it,
;;; but it doesn't seem worth it.
(defvar *predicate-area*
	(make-area :name '*predicate-area*
		   ;; No point in GCing until 1*predicate-cache*0 is cleared.
		   :gc :static
		   :region-size 20000))

;;; This contains the keys for the predicates, which are used extensively at table-build,
;;; cache-fill, and only occasionally wave-the-mouse-around time.
;;; No point in GCing; 1*predicate-cache*0 will hold on to things here just like for
;;; 1*predicate-area*0.
(defvar *predicate-key-area*
	(make-area :name '*predicate-key-area*
		   ;; No point in GCing until 1*predicate-cache*0 is cleared.
		   :gc :static
		   :region-size 20000))


(defvar *handler-table-area*
	(make-area :name '*handler-table-area*
		   :gc :static
		   :region-size 200000))

;;; This holds the top-level lists and the presentation-types.
;;; It's separate from the above area only because we wish to be able
;;; to linearly scan the area and identify which objects are which
;;; things, so we can put them back into the right table after a full-gc.
;;; This holds lists of handler-table-entries, which point into 1*handler-table-area*
0;;; and have a mouse handler either in their 1car0 or their 1caar0.
;;; +++ This can be merged with 1*handler-table-area*0 by putting a special
;;; +++ marker in the 1car0, if we don't mind always being CDR-coded.  Perhaps
;;; +++ do this later.
(defvar *handler-lists-area*
	(make-area :name '*handler-lists-area*
		   :gc :static
		   :region-size 20000))

;;; This holds the presentation-types.  Because of the arbitrariness possible in
;;; their arguments, they have to live in a separate area, so we can identify
;;; which table to stick them into.  Unfortunately, this increases the working-set.
;;; +++ Actually, there doesn't seem to be enough of them to be worth eq-ifying.
;;; +++ (i.e. about .5 pages!)  But we do want them to all live together, and a
;;; +++ separate area is the easiest way to accomplish this.  Not necessarily the
;;; +++ best, if someone wants to go to additional work.
(defvar *handler-types-area*
	(make-area :name '*handler-types-area*
		   :gc :static
		   :region-size 20000))



(defstruct (presentation-input-context :list* :conc-name
				       (:constructor make-presentation-input-context
						     (presentation-type superior options
						      &key throw-p)))
  presentation-type
  superior
  (throw-p nil)
  (options nil)
  )


(defmacro with-presentation-input-editor-context ((stream presentation-type . options)
					     (&optional (blip-var '.blip.) start-loc-var)
					     non-blip-form
					     &body blip-cases)
  (declare (zwei:indentation 0 2 2 4 3 2))
  `(with-dynamic-input-editor-options (,stream)
     (si:with-clim-compatible-input-editing (,stream)
       (let ,(and start-loc-var `((,start-loc-var (send ,stream :read-location))))
	 (with-presentation-input-context (,presentation-type :stream ,stream . ,options)
					  (,blip-var)
	      ,non-blip-form
	    . ,blip-cases)))))

(defmacro with-dynamic-input-editor-options ((stream) &body body)
  `(with-input-editing-options-if (operation-handled-p ,stream :mouse-motion-pending)
	((:input-wait nil #'mouse-motion-pending (si:follow-syn-stream ,stream))
	 (:input-wait-handler #'update-highlighted-presentation ,stream)
	 (:dynamic-blip-handler #'presentation-input-blip-handler))
     . ,body))

(defmacro with-presentation-input-context ((presentation-type &rest options)
					   (&optional (blip-var '.blip.))
					   non-blip-form
					   &body blip-cases)
  (declare (zwei:indentation 0 2 2 4 3 2))
  (with-presentation-input-context-internal
    '*presentation-input-context*
    presentation-type options blip-var non-blip-form blip-cases))

(defmacro with-presentation-more-break-input-context ((presentation-type &rest options)
						      (&optional (blip-var '.blip.))
						      non-blip-form
						      &body blip-cases)
  (declare (zwei:indentation 0 2 2 4 3 2))
  (with-presentation-input-context-internal
    '*presentation-more-break-input-context*
    presentation-type options blip-var non-blip-form blip-cases))

(defun with-presentation-input-context-internal (var presentation-type options
						 blip-var non-blip-form blip-cases
						 &aux (stream (getf options :stream)))
  (setq options (si:rem-keywords options '(:stream)))
  (check-presentation-type-argument presentation-type)
  `(unwind-protect
       (zl:stack-let ((.options. (list . ,options)))
	 ,(if (null blip-cases)  
	      `(zl:stack-let ((.new-context. (make-presentation-input-context
					       ,presentation-type
					       (apply #'inherit-presentation-context
						      .options.)
					       .options.)))
		 (let ((,var (new-presentation-input-context .new-context.)))
		   (note-presentation-input-context-change ,@(and stream (list stream)))
		   ,non-blip-form))
	    (let ((presentation-type-var (make-symbol "PRESENTATION-TYPE")))
	      `(zl:stack-let* ((,presentation-type-var ,presentation-type)
			       (.new-context. (make-presentation-input-context
						,presentation-type-var
						(apply #'inherit-presentation-context
						       .options.)
						.options.
						:throw-p t)))
		 (block .no-blip.
		   (let ((,blip-var (catch .new-context.
				      (let ((,var (new-presentation-input-context
						    .new-context.)))
					(note-presentation-input-context-change
					  ,@(and stream (list stream)))
					,(if stream
					     `(or (peek-for-presentation-blip
						    ,stream
						    ,presentation-type-var)
						  (return-from .no-blip. ,non-blip-form))
					     `(return-from .no-blip. ,non-blip-form))))))
		     (,(if (or (assoc 't blip-cases)
			       (assoc 'otherwise blip-cases))
			   'presentation-blip-case 'presentation-blip-ecase)
		      ,blip-var . ,blip-cases)))))))
     (note-presentation-input-context-change ,@(and stream (list stream)))))

(defmacro presentation-blip-case (blip &body clauses &environment env)
  (once-only (blip &environment env)
    `(cond ,@(loop for clause in clauses
		   collect `(,(let ((type (first clause)))
				(if (member type '(t otherwise)) 't
				    `(presentation-blip-typep ,blip ',type)))
			     . ,(rest clause))))))

(defmacro presentation-blip-ecase (blip &body clauses)
  `(presentation-blip-case ,blip
     ,@clauses
     (otherwise (dbg:check-type-1 ',blip ,blip ,`'(or . ,(mapcar #'first clauses)) nil t))))


;;; Macro to replace 1decode-presentation-type0 and 1decode-old-presentation-type0.
;;; And most especially to replace doing it by hand.

(defmacro with-type-decoded ((type-name-var &optional data-args-var presentation-args-var)
			     type &body body)
  (declare (compiler:do-not-record-macroexpansions)
	   (zwei:indentation 0 10 1 5 2 2))
  (let ((type-var (make-symbol "TYPE"))
	(temp (make-symbol "TEMP")))
    `(multiple-value-bind (,type-name-var
			   ,@(when data-args-var
			       `(,data-args-var))
			   ,@(when presentation-args-var
			       `(,presentation-args-var)))
	 (let ((,type-var ,type)
	       (,temp))
	   (cond ((atom ,type-var)
		  ,type-var)
		 ((atom (setq ,temp (car ,type-var)))
		  (values ,temp ,@(when data-args-var
				    `((cdr ,type-var)))))
		 (t (values (car ,temp)
			    ,@(when data-args-var
				`((cdr ,temp)))
			    ,@(when presentation-args-var
				`((cdr ,type-var)))))))
       ,@body)))

;;; type-method is the new name for what used to be called type properties.
;;; (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")type-var0 gets the (possibly expanded) type to use with the method.
;;; 2predicate-var0 gets the predicate derived in the expansion process.
;;; 2method-type-var0 gets the second return value from the search function
;;;   (i.e. the 2method0 argument).
(defmacro with-type-method (((type-var method-var &optional method-type-var predicate-var)
			     presentation-type method
			     &rest options &key (error-p t) (supertype-p t) existing-predicate)
			    &body body)
  (ignore supertype-p existing-predicate)
  `(with-type-method-internal ,presentation-type ,method ,error-p
     (sys:named-lambda with-type-method (,type-var ,method-var
					   ,(or method-type-var 'ignore)
					   ,(or predicate-var 'ignore))
       (declare (sys:downward-function)
		(dbg:invisible-frame :presentation-handler-search))
       ,@body)
     ,@(when predicate-var
	 `(:predicate-p t))
     ,@options))



(defflavor presentation
	(object				;the object contained in this presentation
	 (type t)			;its type
	 (form-or-location nil)		;a locative or a setfable form
	 (inferiors nil)		;a list of inferiors
	 (superior nil)			;a single superior
	 )
	()
  (:init-keywords :form :location)
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (sys:print-self presentation) (stream ignore ignore)
  (sys:printing-random-object (self stream)
    (let ((type (type-of self)))
      (present type 'sys:flavor-name :stream stream)
      (write-char #\Space stream))
    (with-character-size (:smaller stream)
      (let ((*print-pretty* nil))
	(abbreviating-output (stream :width 15 :height 1 :lozenge-returns t
				     :show-abbreviation t
				     :abbreviate-initial-whitespace t)
	  (prin1 object stream))
	(write-char #\Space stream)
	(let ((*print-length* 3))
	  (present type 'presentation-type :stream stream))))))

;A separate function so that the make-instance method does not copy
;its environment into the heap on every call.
#+3600
(defun-in-flavor (cleanup-stack-object-when-exit presentation) ()
  ;; Don't need to do this for locatives, their presentations don't indirect through them
  (when (locativep object)
    (return-from cleanup-stack-object-when-exit nil))
  (multiple-value-bind (nil nil nil nil sg stack-type)
      (si:decode-stack-address object)
    (let ((frame (case stack-type
		   (:data (si:control-stack-frame-for-data-stack-address sg object))
		   (:control (loop for frame = (if (eq sg %current-stack-group)
						   (sys:%stack-frame-pointer)
						   (sg-frame-pointer sg))
					     then (frame-previous-frame frame)
				   while frame do
			       (when (%pointer-lessp frame object)
				 (return frame)))))))
      (flet ((cleanup-stack-object ()
	       (setq object 'stack-object-flushed
		     type 'no-type
		     form-or-location nil)))
	(when (null frame)
	  ;; Can't find the frame, better bash it now.  This happens when it is on
	  ;; the binding stack, or when it is on the data stack and created by
	  ;; code compiled with the old version of the with-data-stack macro.
	  (return-from cleanup-stack-object-when-exit 
	    (cleanup-stack-object)))
	(unless dbg:*exit-trap-frame-actions*
	  (setq dbg:*exit-trap-frame-actions*
		(make-hash-table :test 'eq)))	;+++ What locking do I really want?
	(let ((bucket (gethash frame dbg:*exit-trap-frame-actions*)))
	  (unless bucket
	    (setq bucket (ncons (not (zerop (sys:frame-trace-bit frame))))))
	  (push #'cleanup-stack-object (cdr bucket))
	  (setf (gethash frame dbg:*exit-trap-frame-actions*) bucket
		(frame-trace-bit frame) 1)))
      nil)))

#+imach
(defun-in-flavor (cleanup-stack-object-when-exit presentation) ()
  ;; Don't need to do this for locatives, their presentations don't indirect through them
  (when (locativep object)
    (return-from cleanup-stack-object-when-exit nil))
  (multiple-value-bind (nil nil nil nil sg stack-type)
      (si:decode-stack-address object)
    (multiple-value-bind (frame control-loc)
	(case stack-type
	  (:data (si:control-stack-frame-for-data-stack-address sg object))
	  (:control
	    (block find-frame
	      (dbg:map-over-frames-in-stack
		sg
		#'(lambda (frame control-loc pc)
		    (declare (ignore pc))
		    (when (%pointer-lessp frame object)
		      (return-from find-frame (values frame control-loc))))
		:none))))
      (flet ((cleanup-stack-object ()
	       ;; (setq object 'stack-object-flushed) being careful w.r.t. logic variables
	       (%p-store-contents (locf object) 'stack-object-flushed)
	       (setq type 'no-type
		     form-or-location nil)))
	(when (null frame)
	  ;; Can't find the frame, better bash it now.  This happens when it is on
	  ;; the binding stack, or when it is on the data stack and created by
	  ;; code compiled with the old version of the with-data-stack macro.
	  (return-from cleanup-stack-object-when-exit 
	    (cleanup-stack-object)))
	;;--- We know that the next-active-frame is one word before
	;;--- the saved control register.  Someone should fix this
	;;--- modularity.
	(dbg:register-trap-on-exit-client
	  frame (%pointer-plus control-loc -1) sg self #'cleanup-stack-object 1))
      nil)))

(defmethod (make-instance presentation) (&key location form &allow-other-keys)
  (when (not (variable-boundp object))
    (cond ((and location (location-boundp location))
	   (setq object (location-contents location)))
	  (form
	   (setq object (eval form)))
	  (t
	   ;; Putting NIL here isn't right, but it keeps things from blowing out.
	   (setq object nil))))
  (setq form-or-location (or location (and form (if (locativep form) `',form form))))
  (heap-copy-presentation-type-if-necessary type)
  ;; all of below only applies to pointers, skip otherwise
  (when (%pointerp object)
    (if (and #+3600
	     ( (ldb %%vma-equals-amem (%pointer object)) %vma-equals-amem)
	     (let ((region-number (%region-number object)))
	       (or (null region-number)
		   #+IMach
		   (eql si:fep-area region-number))))
	(setq object (%pointer object)
	      type 'expression
	      form-or-location nil)
	(when (or (consed-in-control-stack object)
		  (consed-in-data-stack object))
	  (cleanup-stack-object-when-exit)))))

(defmethod (presentation-form presentation) ()
  (unless (locativep form-or-location) form-or-location))

(defmethod ((setf presentation-form) presentation) (form)
  (setq form-or-location (if (locativep form) `',form form)))

(defmethod (presentation-location presentation) ()
  (when (locativep form-or-location) form-or-location))

(defmethod ((setf presentation-location) presentation) (location)
  (setq form-or-location location))

(defmethod (presentation-object-value-replace-p presentation) ()
  (not (null form-or-location)))

(defmethod (replace-presentation-object-value presentation) (new-value)
  (setq object new-value)
  (cond ((locativep form-or-location)
	 (setf (location-contents form-or-location) new-value))
	(form-or-location
	 (eval `(setf ,form-or-location ',new-value)))
	(t
	 (error "Don't know how to replace this value."))))

(defflavor null-presentation
	((object nil)
	 (type 'no-type))
	(presentation))

(defmethod (presentation-object-and-types null-presentation) ()
  (values nil 'no-type 'no-type))

;;; This is used when the mouse isn't over anything
(defvar *null-presentation* (make-instance 'null-presentation))


(defstruct (presentation-blip (:type :list*) :conc-name)
  presentation-type
  mouse-char
  object
  options)					;el CDDDDD...R

(defun presentation-blip-p (blip)
  (and (consp blip)
       (presentation-type-p (first blip))))

(defun presentation-blip-typep (blip type)
  (presentation-subtypep (presentation-blip-presentation-type blip) type))

(defun (presentation-blip-typep compiler:style-checker) (form)
  (warning-on-error presentation-blip-typep
    (destructuring-bind (ignore blip type) form
      (when (constantp blip)
	(check-presentation-type-argument
	  (presentation-blip-presentation-type
	    (lt:evaluate-constant blip
				  compiler:*interpreter-lexical-environment*))
	  :evaluated nil))
      (check-presentation-type-argument type))))


(defvar *presentation-type-descriptors* (make-good-table :test #'eql :name "Type descriptor"))

(defsubst symbol-presentation-type-descriptor (symbol)
  (if (and (instancep symbol) (not (clos-instance-p symbol)))
      symbol
    (gethash symbol *presentation-type-descriptors*)))

(defsetf symbol-presentation-type-descriptor (symbol) (value)
  `(setf (gethash ,symbol *presentation-type-descriptors*) ,value))


(defun fringe-eql (a b)
  (labels ((fringe-eql-recurse (a b)
	     (loop for ax = a then (cdr ax)
		   for bx = b then (cdr bx)
		   when (eql ax bx)
		     do (return t)
		   when (atom ax)
		     do (return-from fringe-eql nil)
		   when (atom bx)
		     do (return-from fringe-eql nil)
		   do (fringe-eql-recurse (car ax) (car bx)))))
    (cond ((eql a b)
	   (return-from fringe-eql t))
	  ((atom a)
	   (return-from fringe-eql nil))
	  ((atom b)
	   (return-from fringe-eql nil))
	  (t (fringe-eql-recurse a b)))))

;; Compiler should optimize (and (symbolp x) (gc-dependence x)) into this, but it doesn't
(defsubst gc-dependence-pointer (x)
  (if (sys:%ephemeralp x)
      %gc-dependence-ephemeral
      (let ((region (sys:%region-number x)))
	(if region
	    (progn
	      (selector (level-type (ldb sys:%%region-level (sys:region-bits region))) =
		(%level-type-dynamic %gc-dependence-dynamic)
		(%level-type-static  %gc-dependence-static)
		(otherwise	     %gc-dependence-none)))
	    %gc-dependence-none))))

(defun fringe-eql-hash (frob)
  (typecase frob
    ((or symbol array locative)
     (let ((gc-dependence (gc-dependence-pointer frob)))  ;Must do %ephemeralp before %pointer
       (values (%pointer frob) gc-dependence)))
    (cons		;Rotate car by 11. and cdr by 7, but do it efficiently
      (do ((rot 4) (hash 0) (gc-dependence %gc-dependence-none) y)
	  ((atom frob)
	   (or (null frob)
	       (setq hash (logxor (rot (multiple-value-bind (h f)
					   (fringe-eql-hash frob)
					 (maxf gc-dependence f)
					 h)
				       (- rot 4))
				  hash)))
	   (values (si:non-negative-fixnum hash) gc-dependence))
	(setq y (car frob) frob (cdr frob))
	;; (or (< (setq rot (+ rot 7)) 32.) (setq rot (- rot 32.)))
	(setq rot (ldb (byte 5 0) (+ rot 7)))	;rot = mod(rot+7,32)
	(setq hash (logxor (rot (typecase y
				  ((or symbol array locative)
				   (let ((f (gc-dependence-pointer y)))
				     (maxf gc-dependence f))
				   (%pointer y))
				  (fixnum (%32-bit-plus y 13.))
				  (otherwise
				    (multiple-value-bind (h f)
					(fringe-eql-hash y)
				      (maxf gc-dependence f)
				      h)))
				rot)
			   hash))))
    (fixnum 	 ;; offset it so that 0 doesn't hash to 0
      (values (si:non-negative-fixnum (%32-bit-plus (si:fixnum-multiply-by-prime frob) 31.))
	      %gc-dependence-none))
    (integer		;; Bignum
      (values (logxor (ldb (byte 01 31) frob) (ldb (byte 31 00) frob))
	      %gc-dependence-none))
    (single-float 	 ;; offset it so that 0.0 doesn't hash to 0
      (values (si:non-negative-fixnum (%32-bit-plus (%fixnum frob) 89.))
	      %gc-dependence-none))
    (double-float
      ;; offset it so that 0.0d0 doesn't hash to 0
      (values (si:non-negative-fixnum
		(%32-bit-plus
		  (logxor (double-high frob)
			  (double-low frob))
		  107.))
	      %gc-dependence-none))
    (rational
      (values (logxor (fringe-eql-hash (rational-numerator frob))
		      (fringe-eql-hash (rational-denominator frob)))
	      %gc-dependence-none))
    (character
      (values (si:non-negative-fixnum (rot (%pointer frob) 3))
	      %gc-dependence-none))
    (complex
      ;; do something so it's not commutative and #c(frob frob) doesn't hash to 0
      (values (logxor (fringe-eql-hash (complex-realpart frob))
		      (si:non-negative-fixnum (rot (fringe-eql-hash (complex-imagpart frob))
						   7)))
	      %gc-dependence-none))
    (otherwise
      (let ((gc-dependence (gc-dependence frob)))	;Must do %ephemeralp before %pointer
	(values (%pointer frob) gc-dependence)))))

;;; This is indexed by (method-search-function cache-key-for-the-p-t . key-for-pres-args)
;;; Result is (p-t method-function real-method-type predicate)
(defvar *type-method-cache* (make-good-table :test #'fringe-eql
					     :hash-function #'fringe-eql-hash
					     :store-hash-code t
					     :size 1500
					     :name "Type method cache"))


(defvar *common-supertypes-cache*
	(make-good-table :test #'fringe-eql
			 :hash-function #'fringe-eql-hash
			 :name "Common supertypes cache"))


;;; This does not need to be cleared when the types change.
;;; It might be cleared at 1:full-gc0 time, but it's not clear there's any point.
;;; It can be reconstructed by scanning the area.

;;; *** This is supposed to be a 1:number-of-values 00 table, but I missed.
;;; *** After the release, fix it (and be careful of the callers).

(defvar *handler-table-presentation-type-cache*
	(make-good-table :test #'fringe-eql :hash-function #'fringe-eql-hash
			 :store-hash-code t
			 :name "HTE type cache"))

(defvar *handler-table-presentation-type-non-events* 0)
(defvar *handler-table-presentation-type-cache-events* 0)
(defvar *handler-table-presentation-type-cache-misses* 0)


(defvar *handler-table-top-level-list-cache*
	(make-good-table :test 'equal
			 :store-hash-code t
			 :number-of-values 0
			 :name "HT list cache"))
(defvar *handler-table-top-level-list-cache-events* 0)
(defvar *handler-table-top-level-list-cache-misses* 0)


(defstruct (handler-cache-entry (:type list))
  handler
  handler-predicate
  context-predicate)

(defvar *context-priority* 2)
(defvar *displayed-priority* 4)

;;; Put these together in their own area.  These are intensely shared
;;; (by 20 to 1 or more) by the handler alists.  No point in diluting
;;; them with other consing, or by handler alists themselves.
(defvar *cache-entry-area* (make-area :name '*cache-entry-area*
				      ;; No point in trying to GC until 1*cache-entry-cache*
0				      ;; is cleared at 1:full-gc0 time.
				      :gc :static
				      :region-size 50000))

;;; This one saves about 581 pages of cache entries!
;;; It also doesn't need to be cleared when the type hierarchy changes.
;;; It could be cleared at 1:full-gc0 time, though.
;;; These are shared extensivly between handler-alists.
(defvar *cache-entry-cache* (make-good-table :test 'equal
					     :store-hash-code t
					     :number-of-values 0
					     :size 6000
					     :name "Cache entry cache"))
(defvar *cache-entry-events* 0)
;; Number of times we've had to add to the cache
(defvar *cache-entry-misses* 0)
;; Lookups optimized out by singleton-ness
(defvar *cache-entry-single* 0)
;;; Conses saved by the optimization.  This is beyond those saved by singleton
;;; entries.  Since we don't even look at the cache for those, we don't know
;;; how many conses we might have saved with those.
(defvar *cache-entry-conses-saved* 0)



;;; We install both buckets and the entire alists in here.
;;; Since these are used at roughly the same time as the keys
;;; to look them up, (that is, we don't then encache the alist
;;; after we look them up; they're the final cache), we'll store the keys
;;; here too.

;;; Variable 1dw::*handler-alist-area*0:  This holds the final gesturehandler
;;;   alist buckets, the alist built out of those buckets, and the keys used
;;;   to look up those alists, since all three are used at approximately the
;;;   same time.

(defvar *handler-alist-area* (make-area :name '*handler-alist-area*
					;; No point in GCing until 1*handler-alist-bucket-cache*
0					;; is 1clrhash0'd, at 1:full-gc0 time.
					:gc :static
					:region-size 100000))


;;; We install both buckets and the entire alists in here.
;;; It doesn't need to be cleared when the type system changes,
;;; but it probably should be at 1:full-gc0 time.
(defvar *handler-alist-bucket-cache* (make-good-table :test 'equal
						      :store-hash-code t
						      :number-of-values 0
						      :size 2000
						      :area *handler-dynamic-area*
						      :name "Alist bucket cache"))
(defvar *handler-alist-bucket-events* 0)
(defvar *handler-alist-bucket-misses* 0)

;;; Clear the caches, all the caches, and nothing but the caches.
(defun clear-type-handler-caches ()
  (clear-non-handler-caches)
  (clear-handler-caches))

(defun clear-non-handler-caches ()
  (clrhash *t-to-t-select-cache*)
  (clrhash *presentation-subtypep-cache*)
  (clrhash *common-supertypes-cache*)
  (clrhash *flavor-or-cl-type-cache*)
  (clrhash *type-method-cache*))

(defun clear-handler-caches ()
  (clrhash *context-mouse-handlers-cache*))

(defun invalidate-type-handler-tables ()
  (unless *update-types-incrementally*
    (process:with-lock (*type-handler-tables-lock*)
      (incf *type-tick*))
    ;; Invalidate the non-handler caches right away; there's no reason to make
    ;; them be slow to clear.
    (clear-non-handler-caches)))

(compiler:make-obsolete invalidate-type-handler-tables
  "   It has been replaced with DW:PREPARE-FOR-TYPE-CHANGE
   and DW:FINISH-TYPE-REDEFINITION.

   Changing a type definition requires that you tell DW both
   before and after the type is changed.  Call DW:PREPARE-FOR-TYPE-CHANGE
   (with the name of the type) before changing the type.  Once the change
   to the type is completed, call DW:FINISH-TYPE-REDEFINITION, again with
   the name of the type.")

;;; The background grabs this for 1:write0.  When the foreground wants to lock out
;;; the background, it should grab it for 1:read0.

(defvar *background-process-lock* (make-good-table :name "Background process lock"))



;;; If you patch this, be sure to clear the caches.  It's going to affect the cache keys.
;;; The odds of collision are low, but you're likely to render the entire content of the
;;; cache inaccessible and hence garbage.  Do the GC a favor and add a
;;; 1(dw::clear-type-handler-caches)0 form to your patch!  --RWK

(defparameter *meta-presentation-keywords*
	      '(:description))


;;; Keys are (context-type displayed-type)
;;; Values are boolean, whether 1identity0 should match.
(defvar *t-to-t-select-cache*
	(make-good-table :test #'fringe-eql :hash-function #'fringe-eql-hash
			 :store-hash-code t
			 :area *handler-dynamic-area*
			 :name "TT Select cache"))

;;; Keys are (subtype supertype)
;;; Values are 1t0 (for 1(values t t)0), 1nil0 (for 1(values nil t)0),
;;;   or 1:unknown0 (for 1(values nil nil)0).
(defvar *presentation-subtypep-cache*
	(make-good-table :test #'fringe-eql :hash-function #'fringe-eql-hash
			 :store-hash-code t
			 :area *handler-dynamic-area*
			 :name "Subtypep cache"))

;;; <Don't patch this>
(defvar *presentation-mouse-handlers-table*
	(make-good-table :size 700
			 :name "Mouse handlers by name"))

(defvar *presentation-type-mouse-handler-table*
	(make-good-table :test #'fringe-eql :hash-function #'fringe-eql-hash
			 :store-hash-code t
			 :name "Mouse handler table"))



;;; This does not need to be cleared when types change.
;;; It can be cleared at 1:full-gc0 time, but it's unlikely to have much
;;; garbage, so doubling all the non-garbage (when the cache misses)
;;; will leave us worse off than before.
(defvar *predicate-cache* (make-good-table :test #'fringe-eql
					   :hash-function #'fringe-eql-hash
					   :store-hash-code t
					   :size 500
					   :name "Predicate cache"))
(defvar *predicate-creations* 0)
(defvar *predicate-cache-misses* 0)
(defvar *predicate-arg-copies* 0)

	    
(defun n-value-return-if (n tag body)
  (let ((gens (loop repeat n collect (gensym))))
    `(let ,(loop for g in gens collect `(,g nil))
       (multiple-value-setq ,gens (progn . ,body))
       (and ,(car gens) (return-from ,tag (values . ,gens))))))

(defmacro double-value-return-if (tag &body body)
  (n-value-return-if 2 tag body))

(defmacro triple-value-return-if (tag &body body)
  (n-value-return-if 3 tag body))



(defvar *background-update-queue* nil)

(defun background-queue-push (function)
  (prog1
    (without-interrupts
      (setq *background-update-queue*
	    (nconc *background-update-queue* (ncons function))))
    (when *type-background-process*
      (process:process-wakeup *type-background-process*))))


(defvar *presentation-type-methods-to-preserve*
	'((:statice-info presentation-type-statice-info)
	  (:obsolete presentation-type-obsolete)))

(defvar *pending-type-changes* ())

(defun enqueue-finish-type-redefinition (type-name)
  (when si:*functions-to-call-on-bin-load-done-enable*
    (with-good-lock (*handler-table-entries-possibly-changed* :write)
      ;; 1:write0, because we make modifications to entries in 1dw::*pending-type-changes*0.
      (let ((type-change (find type-name *pending-type-changes* :key #'type-change-type)))
	(unless type-change
	  (error "Attempt to enqueue a finish-type-redefinition for the end of file, but~@
		  there is no type change pending."))
	(setf (type-change-status type-change) :pending-eof)	;Pending end of file.
	(labels ((update-old-type ()
		   ;; See if the bucket is still there.
		   (let ((type-change (find type-name *pending-type-changes*
					    :key #'type-change-type)))
		     (when type-change
		       (merge-changes-for-type type-name)
		       (setf (type-change-status type-change) :completed)))))
	  (push #'update-old-type si:*functions-to-call-on-bin-load-done*))))))



(defflavor presentation-arg-mismatch
	(args arglist presentation-typename portion)
	(error)
  :gettable-instance-variables
  :initable-instance-variables)

(defmethod (:report presentation-arg-mismatch) (stream)
  (labels ((print-arglist ()
	     (print-type-arglist arglist)))
    (let ((pretty-argtype (when portion
			    (string-downcase portion))))
      (format stream "The presentation type supplied, ~~@\\PRESENTATION\\~,~@
		    does not match the ~:[~*~;~A ~]arguments of the type ~@\\PRESENTATION\\.~@
		    The type's arglist is ~~Q~."
	      args 'presentation-type
	      pretty-argtype pretty-argtype
	      presentation-typename 'presentation-type-name
	      #'print-arglist))))

(defflavor presentation-arg-wrong-type
	(presentation-typename presentation-typevar)
	(error)
  :gettable-instance-variables
  :initable-instance-variables)

(defmethod (:report presentation-arg-wrong-type) (stream)
  (let ((*print-length* 20))
    (format stream "Wrong type supplied.  We expected ~S, but got ~S."
      presentation-typename
      (if (atom presentation-typevar)
	  presentation-typevar
	(caar presentation-typevar)))))

(compile-flavor-methods presentation-arg-mismatch presentation-arg-wrong-type)


(defun presentation-arg-mismatch (type-name arglist args &optional portion)
  (declare (dbg:error-reporter))
  ;; Canonicalize the type, to make the matching between the type and the
  ;; arglist more obvious.
  (when (atom args)
    (setq args (list args)))
  (when (atom (car args))
    (setq args (list args)))
  (error 'presentation-arg-mismatch
	 :presentation-typename type-name
	 :arglist arglist
	 :args args
	 :portion portion))

(defun presentation-arg-wrong-type (type-name type-var)
  (declare (dbg:error-reporter))
  (error 'presentation-arg-wrong-type
	 :presentation-typename type-name
	 :presentation-typevar type-var))

;;;  Get the presentation type arglist from the compiler environment or real environment
(defun presentation-type-arglist-in-environment (type)
  (with-type-decoded (type-name) type
    (if (let ((local-arglist (assoc 'presentation-type-arglist local-declarations)))
	  (and local-arglist
	       (eq (second local-arglist) type-name)))
	(third (assoc 'presentation-type-arglist local-declarations))
      (if (compiler:file-declaration type-name 'define-presentation-type)
	  (compiler:file-declaration type-name 'presentation-type-arglist)
	(if (compiler:file-declaration type-name 'deftype)
	    (list (arglist (compiler:file-declaration type-name 'deftype)))
	  (if (symbol-presentation-type-descriptor type-name)
	      (presentation-type-arglist type-name)
	    (let ((pr-args
		    ;; Use the type for the expansion, except we may have the wrong
		    ;; number of data arguments.  Try dropping them until we win.
		    ;; This is to help give winning diagnostics, not because it's some
		    ;; model of correctness.
		    (loop named success
			  for type = type then (unless (atom type) (butlast type))
			  while type
			  do
		      (condition-case (descriptor)
			   (presentation-type-descriptor type nil)
			 (error nil)
			 (:no-error
			   (return-from success
			     (when descriptor
			       (cdr (presentation-type-descriptor-arglist descriptor)))))))))
	      (multiple-value-bind (nil nil deftype typep)
		  (symbol-flavor-or-cl-type type-name)
		(or (when deftype
			  (cons (arglist deftype) pr-args))
		    (when typep
		      (cons (cdr (arglist typep)) pr-args)))))))))))

(defun presentation-type-defined-in-environment (type-name)
  (or (presentation-type-name-p type-name)
      (let ((local-arglist (assoc 'presentation-type-arglist local-declarations)))
	(and local-arglist
	     (eq (second local-arglist) type-name)))
      (compiler:file-declaration type-name 'define-presentation-type)
      (presentation-type-descriptor type-name nil)
      (compiler:file-declaration type-name 'deftype)
      (get type-name 'typep)
      (flavor:find-flavor type-name nil 'compile)
      (clos:find-class type-name nil 'future-common-lisp:compile-file)
      (defstruct-type-p type-name)))

(defun presentation-wrong-type (right-name actual-name)
  (error "Wrong type supplied.  We expected ~S, but got ~S."
	 right-name actual-name))

(defun presentation-type-matches (type desired-type)
  (or (eq type desired-type)
      (atomic-subtype-subtypep type desired-type)))

;;; This is about ten times faster and touches many fewer pages and conses less
;;; than doing a 1set-difference0 on the fly.
(defflavor meta-keyword-cache
	((old-meta-keywords nil)
	 (cached-new-list)
	 (keywords-used))
	()
  (:initable-instance-variables keywords-used)
  (:default-init-plist :area compiled-function-area)
  (:constructor make-meta-keyword-cache (keywords-used)))

(defmethod (:fasd-form meta-keyword-cache) ()
  `(lookup-meta-keyword-cache ',keywords-used))

#| ; I think it's better from a paging standpoint to have separate ones
(defvar *meta-keyword-caches* (make-hash-table :test 'equal))

(defun lookup-meta-keyword-cache (keywords-used)
  (labels ((keyword-lessp (k1 k2)
	     (and (neq k1 k2)
		  (or (string-lessp k1 k2)
		      (and (string-equal k1 k2)
			   (string-lessp (package-name (symbol-package k1))
					 (package-name (symbol-package k2))))))))
    (setq keywords-used
	  (sort (copy-list keywords-used) #'keyword-lessp))
    (or (gethash keywords-used *meta-keyword-caches*)
	(setf (gethash keywords-used *meta-keyword-caches*)
	      (make-meta-keyword-cache keywords-used)))))
|#

(defun lookup-meta-keyword-cache (keywords-used)
  (make-meta-keyword-cache keywords-used))

(defmethod (check-meta-keywords meta-keyword-cache) ()
  (if (eq *meta-presentation-keywords* old-meta-keywords)
      cached-new-list
    (setq cached-new-list
	  (set-difference *meta-presentation-keywords* keywords-used)
	  old-meta-keywords *meta-presentation-keywords*)
    cached-new-list))

(compile-flavor-methods meta-keyword-cache)

(defun find-meta-presentation-keywords-filter (arglist &optional force)
  (let ((keywords)
	(rest-p))
    (labels ((body (argl type)
	       (let ((arg (first argl)))		;God knows why
		 (case type
		   (:key
		     (let ((key-name (lt::key-key-name arg)))
		       (push key-name keywords)))
		   (:rest
		     (unless (string-equal arg 'ignore)
		       (setq rest-p t)))))))
      (multiple-value-bind (nil allow-other-keys)
	  (lt:map-over-lambda-list arglist #'body)
	(when (or force (and rest-p (not allow-other-keys)))
	  (if keywords
	      `(check-meta-keywords ,(lookup-meta-keyword-cache keywords))
	    `*meta-presentation-keywords*))))))

(defmacro with-presentation-type-arguments ((type-name type) &body body
					    &environment env)
  (unless (presentation-type-defined-in-environment type-name)
    (warn "Cannot expand ~S, because ~S is not defined."
	  'with-presentation-type-arguments type-name))
  (let ((pattern (presentation-type-arglist-in-environment type-name)))
    (if (or (null pattern)
	    (and (null (car pattern))
		 (null (cdr pattern))))
	`(progn ,type ,@body)
      (let ((success (gensymbol "WITH-PRESENTATION-TYPE-ARGUMENTS-"))
	    (mismatch (gensymbol "MISMATCH-"))
	    (mismatched-arglist (gensymbol "MISMATCHED-ARGLIST-"))
	    (wrong-type (gensymbol "WRONG-TYPE-"))
	    (type-var (gensymbol "TYPE-"))
	    (type-name-var (gensymbol "PRESENTATION-TYPE-NAME-"))
	    (data-args-var (gensymbol "DATA-ARGUMENTS-"))
	    (pr-args-var (gensymbol "PRESENTATION-ARGUMENTS-")))
	(destructuring-bind (data-arglist . pr-arglist) pattern
	  (if (null pr-arglist)
	      (setq body
		    `((unless (validate-presentation-keywords ,pr-args-var nil)
			(go ,mismatch))
		      ,@body))
	    (setq body
		  (multiple-value-bind (bindings additional-forms)
		      (si:translate-destructuring pr-arglist
						  (if data-arglist
						      pr-args-var
						    `(if (presentation-type-matches
							   ,type-name-var ',type-name)
							 ,pr-args-var
						       (progn (setq ,mismatched-arglist
								    :presentation)
							      (go ,wrong-type))))
						  `(go ,mismatch)
						  'validate-presentation-keywords)
		    (multiple-value-bind (declarations body)
			(find-body-declarations body env)
		      `((let* ,bindings
			  ,@declarations
			  ,@additional-forms
			  ,@(delete "IGNORE" (find-lambda-vars pr-arglist)
				    :test #'string-equal)
			  ,@body)))))
	    (let ((meta-keywords-filter
		    (find-meta-presentation-keywords-filter pr-arglist)))
	      (when meta-keywords-filter
		(setq body
		      `((si:with-rem-keywords (,pr-args-var ,pr-args-var ,meta-keywords-filter)
			  ,@body))))))
	  (setq body
		(multiple-value-bind (bindings additional-forms)
		    (si:translate-destructuring data-arglist
						`(if (presentation-type-matches
						       ,type-name-var ',type-name)
						     ,data-args-var
						   (go ,wrong-type))
						`(go ,mismatch))
		  (multiple-value-bind (declarations body)
		      (find-body-declarations body env)
		    `((let* ,bindings
			,@declarations
			,@additional-forms
			,@(find-lambda-vars data-arglist)
			,@body)))))
	  `(let ((,mismatched-arglist :data)
		 (,type-var ,type))
	     (block ,success
	       (with-type-decoded (,type-name-var ,data-args-var ,pr-args-var) ,type-var
		 (tagbody
		   (return-from ,success
		     (progn ,@body))
		   ;; This could do better error recovery.
		   ,mismatch
		   (return-from ,success (presentation-arg-mismatch ',type-name
								    ',pattern ,type-var
								    ,mismatched-arglist))
		   ,wrong-type
		   (return-from ,success
		     (presentation-wrong-type ',type-name ,type-name-var)))))))))))

;Support for &KEY in presentation arguments
(defun validate-presentation-keywords (list keys)
  (and (evenp (length list))
       (loop for k in list by #'cddr
	     always (or (member k keys)
			(member k *meta-presentation-keywords*)))))

(defmacro with-inherited-presentation-type-arguments ((type-name type &key (error-p t))
						      &body body)
  (declare (zwei:indentation 0 3 1 1))
  (let ((super-type (sys:gensymbol "SUPER-TYPE-"))
	(error-p-var (sys:gensymbol)))
    `(let ((,super-type ,type)
	   (,error-p-var ,error-p))
       (block matched
	 (map-over-type-hierarchy ,super-type t t
	    #'(lambda (,super-type ignore ignore)
		(when (eq (presentation-type-name ,super-type) ',type-name)
		  (return-from matched
		    (with-presentation-type-arguments (,type-name ,super-type)
		      ,@body)))))
	 (when ,error-p-var
	   (presentation-wrong-type ',type-name ,super-type))))))


; Maybe this needs to be merged into a different file for the sake of wobbling?

;;; Is this consed in my control stack?
(defsubst consed-in-control-stack (object)
  (and (sys:%pointerp object)
       (not (or (%pointer-lessp object %control-stack-low)
		(%pointer-lessp (progn #+3600 %control-stack-limit
				       #+imach(%read-internal-register
						%register-control-stack-limit))
				object)))))

;;; Is this consed in my data stack?
(defsubst consed-in-data-stack (object)
  (and (sys:%pointerp object)
       (let ((sg %current-stack-group))
	 (and (sg-data-stack-low sg)		;process might not have a data-stack
	      (not (or (%pointer-lessp object (sg-data-stack-low sg))
		       (%pointer-lessp (sg-data-stack-limit sg) object)))))))

;;; This is fast; use it without fear, everywhere you're going to store a presentation-type.
(defmacro heap-copy-presentation-type-if-necessary (presentation-type-reference
						    &environment env)
  (let ((p-t (make-symbol "PRESENTATION-TYPE")))
    (multiple-value-bind (vars vals stores store-form access-form)
	(get-setf-method presentation-type-reference env)
      (lt:let-subst vars vals
       (lt:let-subst stores
		     `((let ((,p-t ,access-form))
			 (if (consed-in-control-stack ,p-t)
			     ;; It's in our stack
			     (heap-copy-presentation-type ,p-t)
			     ;; not in our stack, at least
			     ,p-t)))
		     store-form
		     env)
       env))))

;;; This is like 1sys:copy-if-necessary0, but less drastic.  It doesn't
;;; walk over the entire structure looking for things in the stack.
;;; It also doesn't worry about copying atomic types from the stack,
;;; or about temporary areas.

;;; force-n-levels will force that many levels of list into the specified area.

;;; This really wants to walk over the types as types.
(defun heap-copy-presentation-type (presentation-type &optional (area working-storage-area)
				    (force-n-levels 0))
  (labels ((copy (list force-n-levels recurse-p)
	     (declare (dbg:invisible-frame :presentation-handler-search))	;---
	     (typecase list
	       (cons (if (not (or (consed-in-control-stack list)
				  (and (> force-n-levels 0)
				       ( area working-storage-area)
				       ( (%area-number list) area))))
			 list
		       (loop with next-recurse = (atom (car list))
			     for x on list
			     until (atom x)
			     count t into length
			     finally
			       (loop with new-type = (make-list (if x (1+ length) length)
								:area area)
				     for do-recurse = recurse-p then next-recurse
				     for previous-n = nil then n
				     for n = new-type then (cdr n)
				     for x = list then (cdr x)
				     until (atom x)
				     do (setf (car n)
					      (if (not do-recurse)
						  (if (consed-in-control-stack (car x))
						      '<<stack-consed-pointer>>
						    (car x))
						(copy (car x) (1- force-n-levels)
						      do-recurse)))
				     finally
				       (when n
					 ;; We have allocated an extra cell for the CDR
					 (if (not previous-n)
					     (setq new-type x)	;Redundant check
					   (setf (car n) x)
					   (%change-list-to-cons previous-n)))
				       (return-from copy new-type)))))
	       (otherwise list))))
    (copy presentation-type force-n-levels t)))

;;; Interface to the flavor system, to let the flavor system know DW is making explicit
;;; use of this flavor.  It is recommended you wrap a 1flavor::with-pending-dw-updates
0;;; around the whole thing, if you might do more than one of these.
(defun compose-flavor-for-dw (type &optional handler-name
			      (definition-type 'define-presentation-translator))
  (when type					;1find-flavor0 doesn't like 1nil
0    (let ((flav (flavor:find-flavor type nil)))
      (let-if handler-name
	      ((compiler:default-warning-function handler-name)
	       (compiler:default-warning-definition-type definition-type))
	(when (and flav (not (flavor::flavor-components-composed flav)))
	  (flavor::compose-flavor-combination type :error-p nil))))))
