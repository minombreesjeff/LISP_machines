;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defsubst-in-flavor (viewport-integral-height dynamic-window) ()
  (if cursor-viewport-even-number-of-lines
      (* tv:line-height (floor (tv:sheet-inside-height) tv:line-height))
      (tv:sheet-inside-height)))

(defmacro with-output-truncation ((&optional stream &rest options) &body body)
  (format-output-macro-default-stream stream)
  `(with-output-truncation-internal ,stream
				    (named-continuation with-output-truncation (,stream)
				      . ,body)
				    ,stream
				    . ,(or options '(:horizontal t :vertical t))))

(defun with-output-truncation-internal (stream continuation xstream &rest options)
  (if (operation-handled-p stream :with-output-truncation)
      (lexpr-send stream :with-output-truncation continuation xstream options)
      (funcall continuation xstream)))

(defmethod (:with-output-truncation encapsulating-output-stream)
	   (continuation xstream &rest options)
  (apply #'with-output-truncation-internal stream continuation xstream options))

(defmacro tv:with-auto-line-height ((&optional stream enabled) &body body)
  (format-output-macro-default-stream stream)
  `(with-auto-line-height-internal ,stream
				    (named-continuation tv:with-auto-line-height (,stream)
				      . ,body)
				    ,stream ,enabled))

(defun with-auto-line-height-internal (stream continuation xstream enabled)
  (if (operation-handled-p stream :with-auto-line-height)
      (send stream :with-auto-line-height continuation xstream enabled)
      (funcall continuation xstream)))

(defmethod (:with-auto-line-height encapsulating-output-stream)
	   (continuation xstream enabled)
  (with-auto-line-height-internal stream continuation xstream enabled))

(defun-in-flavor (make-cursor-viewport dynamic-window) ()
  (setq cursor-viewport (make-viewport 0 0
				       (tv:sheet-inside-width) (viewport-integral-height)))

  (setq displayed-presentations (make-coordinate-sorted-set)
	displayed-strings (make-displayed-strings-array)
	displayed-graphics (make-coordinate-sorted-set))
  )

(defmethod (:init dynamic-window :after) (ignore)
  (let ((truncate-p (eq (send self :defaulted-end-of-page-mode) :truncate)))
    (setf (tv:sheet-truncate-output-vertical-flag) (if truncate-p 1 0))
    (when truncate-p
      (setq asynchronous-scroll-handler t
	    tv:more-vpos nil)))
  (make-cursor-viewport))

(defmethod (tv:reset-dynamic-state dynamic-window) ()
  ;; Leave no sensitive object open -- lest all output become inferior to it and never rooted.
  (setq current-output-displayed-string nil
	current-output-displayed-presentation nil
	current-output-displayed-presentation-text nil
	current-more-position nil
	string-out-state nil)
  
  (setq output-recording-enabled t
	coordinate-transformation-enabled t)
  
  (setf (tv:sheet-truncate-output-vertical-flag)
	(if (eq (send self :defaulted-end-of-page-mode) :truncate) 1 0))

  ;; Might be something left on the stack.
  (setq gprint-event-noter nil)

  (setq original-bottom-margin nil)

  (send self :close-secondary-viewport nil))

(defwhopper (:change-of-size-or-margins dynamic-window)
	    (&rest args
	     &key ((:height new-height))
	     &allow-other-keys
	     &aux old-x old-y)
  ;; Try to save the part of the screen near the cursor.  Either slice off the top or
  ;; the bottom -- taking a bit of the middle would probably be too confusing.
  (when (and new-height
	     (neq (send self :defaulted-end-of-page-mode) :wrap)
	     (< new-height tv:height)
	     cursor-viewport
	     (> (+ tv:cursor-y tv:line-height) (- new-height tv:bottom-margin-size)))
    ;; Keep cursor in same position relative to the bottom of the window.
    (tv:sheet-force-access (self)
      (tv:sheet-bitblt tv:alu-seta tv:width new-height
		       nil 0 (- tv:height new-height) nil 0 0))
    (multiple-value-setq (old-x old-y) (send self :read-cursorpos))
    (incf (box-top cursor-viewport) (- tv:height new-height)))
  (let ((old-inside-height (tv:sheet-inside-height))
	(old-inside-width (tv:sheet-inside-width)))
    (lexpr-continue-whopper args)
    (setq secondary-viewport nil)
    (when cursor-viewport
      (let ((new-inside-width (tv:sheet-inside-width))
	    (new-inside-height (viewport-integral-height)))
	(set-box-size cursor-viewport new-inside-width new-inside-height)
	(when (or (> new-inside-width old-inside-width)
		  (> new-inside-height old-inside-height))
	  (setq viewport-displayed-strings-end-index nil
		viewport-displayed-graphics-end-index nil
		viewport-displayed-presentations-end-index nil))
	(tv:sheet-force-access (self)
	  (when (> new-inside-width old-inside-width)
	    (send self :redraw-inside-sets
		  (make-temporary-box (+ (box-left cursor-viewport) old-inside-width)
				      (box-top cursor-viewport)
				      (box-right cursor-viewport)
				      (+ (box-top cursor-viewport) old-inside-height))
		  nil))
	  (when (> new-inside-height old-inside-height)
	    (send self :redraw-inside-sets
		  (make-temporary-box (box-left cursor-viewport)
				      (+ (box-top cursor-viewport) old-inside-height)
				      (box-right cursor-viewport)
				      (box-bottom cursor-viewport))
		  nil))
	  (if old-x
	      (with-output-truncation (self)
		(send self :set-cursorpos old-x old-y))
	      (send self :adjust-cursor-position-and-visibility 0 0)))))))

;;; Where refers to the arguments.  Absolute coordinate values are always marginless.
(defmethod (:convert-to-absolute-coordinates dynamic-window)
	   (x y &optional (where :inside))
  (ecase where
    (:inside )
    (:outside
      (when x (decf x tv:left-margin-size))
      (when y (decf y tv:top-margin-size))))
  (when (and coordinate-transformation-enabled cursor-viewport)
    (multiple-value-bind (delta-x delta-y)
	(viewport-displayed-offsets
	  (if (and secondary-viewport y
		   ( y (viewport-displayed-y-position secondary-viewport)))
	      secondary-viewport
	      cursor-viewport))
      (when x (incf x delta-x))
      (when y (incf y delta-y))))
  (values x y))

;;; Where refers to the values here.
(defmethod (:convert-to-relative-coordinates dynamic-window)
	   (x y &optional (where :inside))
  (when (and coordinate-transformation-enabled cursor-viewport)
    (multiple-value-bind (delta-x delta-y)
	(viewport-displayed-offsets
	  (if (and secondary-viewport y
		   (box-contains-point-p secondary-viewport (or x 0) y))
	      secondary-viewport
	      cursor-viewport))
      (when x (decf x delta-x))
      (when y (decf y delta-y))))
  (ecase where
    (:inside )
    (:outside
      (when x (incf x tv:left-margin-size))
      (when y (incf y tv:top-margin-size))))
  (values x y))

;;; This is part of the DYNAMIC-MOUSE-MIXIN protocol.
(defmethod (:convert-to-inside-coordinates dynamic-window) (x y)
  (coordinate-convert-points self :absolute :outside x y)
  (values x y))

(defmethod (:check-current-output-displayed-string dynamic-window)
	   (&optional (do-exceptions t))
  (when (and do-exceptions (not (zerop (tv:sheet-exceptions))))
    (send self :handle-exceptions))		;Do this here since :TYO does SEND SELF
  (let ((new-string nil))
    (when (null current-output-displayed-string)
      (multiple-value-bind (x y)
	  (send self :read-cursorpos)
	(setq current-output-displayed-string
	      (make-displayed-string nil nil nil
				     x y nil nil self)))
      (let ((box (presentation-displayed-box current-output-displayed-string)))
	(setq maximum-y-position (max maximum-y-position (box-bottom box))))
      (setq new-string t))
    (when (and current-output-displayed-presentation
	       (or new-string
		   (null current-output-displayed-presentation-text)))
      (let ((text-displayed-presentation
	      (make-text-displayed-presentation-1 current-output-displayed-presentation
						  current-output-displayed-string)))
	(open-text-displayed-presentation text-displayed-presentation)
	(send self :add-displayed-presentation text-displayed-presentation)
	(when current-output-displayed-presentation
	  (setq current-output-displayed-presentation-text text-displayed-presentation)))))
  current-output-displayed-string)

(defmethod (:close-current-output-displayed-string dynamic-window) ()
  (when current-output-displayed-string
    (add-to-coordinate-sorted-set current-output-displayed-string displayed-strings)
    (setq displayed-strings (follow-structure-forwarding displayed-strings))
    (let ((box (presentation-displayed-box current-output-displayed-string)))
      (setq maximum-x-position (max maximum-x-position (box-right box))))
    (let ((string (displayed-string-string current-output-displayed-string)))
      ;; Trim off excess string at end.  This is likely to win since
      ;; it's its own area.
      (sys:adjust-array-size string (fill-pointer string)))
    (setq current-output-displayed-string nil))
  (when current-output-displayed-presentation
    (displayed-presentation-close-string current-output-displayed-presentation t)))

(defmethod (:add-displayed-presentation dynamic-window)
	   (displayed-presentation &optional (at-end t))
  (if current-output-displayed-presentation
      (displayed-presentation-add-inferior current-output-displayed-presentation
					   displayed-presentation at-end)
    (add-to-coordinate-sorted-set displayed-presentation displayed-presentations)
    (setq displayed-presentations (follow-structure-forwarding displayed-presentations))))

(defmethod (:delete-displayed-presentation dynamic-window) (displayed-presentation)
  (let ((superior (presentation-superior displayed-presentation)))
    (if superior
	(displayed-presentation-delete-inferior superior displayed-presentation)
	(when (delete-from-coordinate-sorted-set displayed-presentation
						 displayed-presentations)
	  (let ((new-length (fill-pointer displayed-presentations)))
	    (minf viewport-displayed-presentations-start-index new-length)
	    (when viewport-displayed-presentations-end-index
	      (minf viewport-displayed-presentations-end-index new-length)))))))

(defmethod (:presentation-output-internal dynamic-window)
	   (continuation xstream presentation-options &optional no-end-presentation-output)
  ;; End of association between open sensitive output and its own string inferior.
  (when current-output-displayed-presentation
    (displayed-presentation-close-string current-output-displayed-presentation)
    (setq current-output-displayed-presentation-text nil))
  (let* ((explicit-box (getf presentation-options :displayed-box))
	 (displayed-presentation
	   (apply #'make-displayed-presentation
		  :superior current-output-displayed-presentation
		  :displayed-box (or explicit-box
				     ;; The position of this is only preserved if nothing gets
				     ;; output that is remembered, which would be weird.
				     (multiple-value-bind (x y)
					 (send self :read-cursorpos)
				       (make-box x y x y)))
		  presentation-options)))
    (unwind-protect
	(letf ((current-output-displayed-presentation displayed-presentation))
	  (funcall continuation xstream))
      (unless no-end-presentation-output
	(send self :end-presentation-output displayed-presentation
	      :update-box (null explicit-box))))
    displayed-presentation))

;;; Second half of the above function, needs to be called separated for GPRINT crock below.
(defmethod (:end-presentation-output dynamic-window) (displayed-presentation
						       &key (update-box t)
							    (at-end t))
  (displayed-presentation-close-string displayed-presentation
				       (null current-output-displayed-presentation))
  (setq current-output-displayed-presentation-text nil)
  (unless (when update-box
	    (update-displayed-presentation-box displayed-presentation)
	    (not (box-well-formed-p (presentation-displayed-box displayed-presentation))))
    (send self :add-displayed-presentation displayed-presentation at-end)))

(defmethod (:presentation-output-internal-1 dynamic-window)
	   (continuation continuation-args presentation-options
	    &optional no-end-presentation-output)
  ;; End of association between open sensitive output and its own string inferior.
  (when current-output-displayed-presentation
    (displayed-presentation-close-string current-output-displayed-presentation)
    (setq current-output-displayed-presentation-text nil))
  (let* ((explicit-box (getf presentation-options :displayed-box))
	 (displayed-presentation
	   (apply #'make-displayed-presentation
		  :superior current-output-displayed-presentation
		  :displayed-box (or explicit-box
				     ;; The position of this is only preserved if nothing gets
				     ;; output that is remembered, which would be weird.
				     (multiple-value-bind (x y)
					 (send self :read-cursorpos)
				       (make-box x y x y)))
		  presentation-options)))
    (unwind-protect
	(letf ((current-output-displayed-presentation displayed-presentation))
	  (apply continuation continuation-args))
      (unless no-end-presentation-output
	(send self :end-presentation-output displayed-presentation
	      :update-box (null explicit-box))))
    displayed-presentation))

(defflavor object-not-of-required-type
	(object)
	(error presentation-type-error-mixin)
  :gettable-instance-variables
  :initable-instance-variables)

(defmethod (make-instance object-not-of-required-type :after) (&rest ignore)
  (heap-copy-presentation-type-if-necessary object))

(defmethod (:report object-not-of-required-type) (stream)
  (format stream "The object about to be presented, ~S, is not of the required type, ~S."
    object type))

(defmethod (:proceed object-not-of-required-type :no-action) ()
  "Present the object anyway"
  :no-action)

(defmacro check-presentation-type (check-type object type)
  `(when (and ,check-type
	      ,type
	      (not (ptypep ,object ,type)))
     (let ((*present-checks-type* nil))
       (signal 'object-not-of-required-type
	       :object ,object
	       :type ,type
	       :proceed-types '(:no-action)))))

(defmethod (:output-as-presentation dynamic-window)
	   (continuation xstream &rest object-options
	    &key (object nil) (type t) (check-type *present-checks-type*)
	    &allow-other-keys)
  (check-presentation-type check-type object type)
  (with-type-decoded (type-name nil pr-args) type
    (cond ((or (null type)
	       (and (eq type-name 'expression)
		    (not (getf pr-args :escape *print-escape*))
		    (stringp object))		;No sensitivity for PRINC of a string
	       (and current-output-displayed-presentation
		    (not (displayed-presentation-allow-sensitive-inferiors
			   current-output-displayed-presentation))))
	   (funcall continuation xstream)
	   nil)
	  (t (send self :presentation-output-internal continuation xstream object-options)))))

(defmethod (:output-as-presentation-1 dynamic-window)
	   (continuation continuation-args
	    &rest object-options
	    &key (object nil) (type t) (check-type *present-checks-type*)
	    &allow-other-keys)
  (check-presentation-type check-type object type)
  (with-type-decoded (type-name nil pr-args) type
    (cond ((or (null type)
	       (and (eq type-name 'expression)
		    (not (getf pr-args :escape *print-escape*))
		    (stringp object))		;No sensitivity for PRINC of a string
	       (and current-output-displayed-presentation
		    (not (displayed-presentation-allow-sensitive-inferiors
			   current-output-displayed-presentation))))
	   (apply continuation continuation-args)
	   nil)
	  (t (send self :presentation-output-internal-1
		   continuation continuation-args object-options)))))

(defmethod (push-presentation-stack dynamic-window) (output-stack &rest options)
  (let ((displayed-presentation
	  (catch 'coroutine
	    (send self :presentation-output-internal
		  (lambda (ignore)		;stream
		    (declare (sys:downward-function))
		    (throw 'coroutine current-output-displayed-presentation))
		  '#:|shouldn't be calling this|
		  (copy-list options)
		  t))))
    (cl:vector-push-extend current-output-displayed-presentation output-stack)
    (setq current-output-displayed-presentation displayed-presentation)))

(defmethod (pop-presentation-stack dynamic-window) (output-stack)
  (let ((displayed-presentation current-output-displayed-presentation))
    (setq current-output-displayed-presentation (vector-pop output-stack))
    (send self :end-presentation-output displayed-presentation
	  :update-box (zerop (fill-pointer output-stack)))
    displayed-presentation))

;;; Crock for GPRINT -- can we work with queue?
(defmethod (:note-print-event dynamic-window) (key output-stack
						   &key (type 'sys:expression) location)
  (unless (and current-output-displayed-presentation
	       (not (displayed-presentation-allow-sensitive-inferiors
		      current-output-displayed-presentation)))
    (ecase key
      (:start
	(push-presentation-stack self
				 output-stack
				 :location (and (locativep location) location)
				 :form (and (not (locativep location)) `(cdr ',location))
				 :type type))
      (:end
	(pop-presentation-stack self output-stack)))))

(defun make-gprint-event-noter (stream)
  (let ((gprint-output-stack (make-array 10 :fill-pointer 0)))
    (lambda (type &rest args)
      (lexpr-send stream :note-print-event type gprint-output-stack args))))

(defmethod (:gprint dynamic-window) (object suggested-format xstream)
  (let ((gprint:*inspecting* (or gprint-event-noter
				 (setq gprint-event-noter (make-gprint-event-noter self)))))
    (si:gprint-with-sensitivity xstream object suggested-format)))

(defmethod (:print dynamic-window) (&rest args)
  (apply #'si:print-with-sensitivity self args))

(defmethod (:fake-presentation-out dynamic-window) (object type string initial-x initial-y)
  (let ((displayed-presentation (make-displayed-presentation-1
				  object type
				  current-output-displayed-presentation
				  (make-box initial-x initial-y initial-x initial-y)))
	(displayed-string nil))
    (labels ((output-string-portion (string start end finish-off-p)
	       (unless end
		 (setq end (string-length string)))
	       (unless (= start end)
		 (multiple-value-bind (x y)
		     (send self :compute-motion string start end initial-x initial-y)
		   (if (null displayed-string)
		       (setq displayed-string
			     (make-displayed-string nil nil nil
						    initial-x initial-y x nil self))
		       (displayed-string-note-new-right displayed-string x))
		   (setq initial-x x initial-y y))
		 (displayed-string-add-string displayed-string string start end
					      tv:current-style))
	       (when finish-off-p
		 (if displayed-string
		     (displayed-string-close)
		     (setq initial-x 0 initial-y (+ initial-y tv:line-height)))))
	     (displayed-string-close ()
	       (when displayed-string
		 (add-to-coordinate-sorted-set displayed-string displayed-strings)
		 (setq displayed-strings (follow-structure-forwarding displayed-strings))
		 (let ((text (make-text-displayed-presentation
			       :displayed-box (presentation-displayed-box displayed-string)
			       :displayed-string displayed-string
			       :superior displayed-presentation)))
		   (displayed-presentation-add-inferior displayed-presentation text))
		 (setq initial-x 0 initial-y (box-bottom (presentation-displayed-box
							   displayed-string)))
		 (setq displayed-string nil))))
      (letf ((output-recording-enabled nil))
	(do-delimited-substrings ((string) (ignore start-index end-index))
	    (labels ((string-out (string &optional (start 0) end)
		       (loop
		       (let ((fold-index (string-search-char #\Return string
							     :start start :end end)))
			 (multiple-value-bind (nil nil index)
			     (send self :compute-motion string start (or fold-index end)
				   initial-x initial-y
				   nil 0 (1+ initial-y))
			   (when index
			     (setq fold-index index)))
			 (when (null fold-index)
			   (output-string-portion string start end nil)
			   (return))
			 (output-string-portion string start fold-index t)
			 (setq start fold-index)
			 (when (char-equal (aref string fold-index) #\Return)
			   (incf start))))
		       nil)
		     (string-out-in-echo-style (&rest args)
		       (with-character-style (si:echo-style self)
			 (ignore self)		;Crock -- we know it doesn't use xstream.
			 (apply #'string-out args))))
	      (if (si:input-editor-buffer-p string)
		  (si:map-over-input-editor-buffer string start-index end-index
						   #'string-out-in-echo-style
						   #'string-out	;it takes care of n.s. style.
						   #'string-out)
		  (string-out string start-index end-index)))
	  (#\Return
	   (if displayed-string
	       (displayed-string-close)
	       (incf initial-y tv:line-height))))
	(displayed-string-close))
      (setq maximum-y-position (max maximum-y-position initial-y)))
    (update-displayed-presentation-box displayed-presentation)
    (send self :add-displayed-presentation displayed-presentation)
    displayed-presentation))

(defmethod (:implode-presentations dynamic-window) (presentations &rest superior-options
								  &key displayed-box
								  &allow-other-keys)
  (let* ((superior-superior (presentation-superior (first presentations)))
	 (superior (apply #'make-instance 'displayed-presentation
			  :superior superior-superior
			  :displayed-box (or displayed-box (make-box 0 0 0 0))
			  :inferiors presentations
			  superior-options)))
    (update-displayed-presentation-box superior)
    (cond (superior-superior
	   (setf (presentation-inferiors superior-superior)
		 (nset-difference (presentation-inferiors superior-superior) presentations))
	   (displayed-presentation-add-inferior superior-superior superior))
	  (t
	   (dolist (presentation presentations)
	     (delete-from-coordinate-sorted-set presentation displayed-presentations))
	   (add-to-coordinate-sorted-set superior displayed-presentations)))
    (dolist (presentation presentations)
      (setf (presentation-superior presentation) superior))
    (when (send self :still-the-mouse-window)
      (mouse-wakeup (tv:sheet-mouse self)))    
    superior))

(defmethod (:explode-presentation dynamic-window) (presentation)
  (let ((superior (presentation-superior presentation))
	(inferiors (presentation-inferiors presentation)))
    (setf (presentation-inferiors presentation) nil)
    (dolist (inferior inferiors)
      (setf (presentation-superior inferior) superior))
    (cond (superior
	   (setf (presentation-inferiors superior)
		 (nconc inferiors (delete presentation (presentation-inferiors superior)))))
	  (t
	   (delete-from-coordinate-sorted-set presentation displayed-presentations)
	   (dolist (inferior inferiors)
	     (add-to-coordinate-sorted-set inferior displayed-presentations))))
    (when (send self :still-the-mouse-window)
      (mouse-wakeup (tv:sheet-mouse self)))    
    inferiors))

;;; This happens to get called at the right time for more or less the right reason.
(defmethod (:adjust-blinker dynamic-window :after) (&rest ignore)
  (block on
    (when (eq rubout-handler :tyi)
      (let* ((point (si:ieb-typein-pointer))
	     (match (case (si:input-editor-flag :blink-matching-character)
		      (:lisp
			(when (and (plusp point)
				   (char-equal (aref si:input-editor-buffer (1- point))
					       #\)))
			  (multiple-value-bind (match found)
			      (si:ie-search-backward-parens point nil)
			    (when found match)))))))
	(when match
	  (unless matching-character-blinker
	    (setq matching-character-blinker
		  (tv:make-blinker self 'tv:character-blinker :half-period 8
				   :char #\(	;Always set, but needed for init method
				   :visibility nil :deselected-visibility :off)))
	  (multiple-value-bind (x y)
	      (si:input-editor-compute-motion-from-start match)
	    (let ((char (aref si:input-editor-buffer match)))
	      (multiple-value-bind (index font)
		  (tv:sheet-get-char-index-and-font char)
		(ignore index)
		(incf y (tv:sheet-get-top-of-font font)))
	      (when (box-contains-point-p cursor-viewport x y)
		(coordinate-convert-points self :relative :inside x y)
		(without-interrupts
		  (tv:blinker-set-character matching-character-blinker char)
		  (tv:blinker-set-cursorpos matching-character-blinker x y)
		  (tv:blinker-set-visibility matching-character-blinker :blink))
		(return-from on)))))))
    (when matching-character-blinker
      (tv:blinker-set-visibility matching-character-blinker nil)))
  nil)

(defmethod (:refresh dynamic-window :after) (&optional reason)
  (cond ((not tv:restored-bits-p)
	 (tv:prepare-sheet (self)
	   (send self :redraw-inside-sets cursor-viewport nil)
	   (when secondary-viewport
	     (send self :draw-viewport-separator-line secondary-viewport)
	     (send self :redraw-inside-sets secondary-viewport nil))))
	((and (eq reason :size-changed) secondary-viewport)
	 (tv:prepare-sheet (self)
	   (send self :close-secondary-viewport nil)
	   (send self :redraw-inside-sets cursor-viewport t)))))

(defmethod (tv:refresh-rectangle dynamic-window) (left top right bottom)
  (tv:prepare-sheet (self)
    (labels ((do-viewport (viewport left top right bottom)
	       (multiple-value-bind (box-left box-top box-right box-bottom)
		   (box-edges viewport)
		 ;; Compute the intersection of the refresh rectangle with the viewport
		 ;; in drawing surface coordinates
		 (coordinate-convert-points self :absolute :outside left top right bottom)
		 (maxf left box-left)
		 (maxf top box-top)
		 (minf right box-right)
		 (minf bottom box-bottom)
		 ;; If the intersection is not empty, redraw its contents
		 (when (and (> right left) (> bottom top))
		   (stack-let ((box (make-box left top right bottom)))
		     (send self :redraw-inside-sets box nil))))))
      (if (not secondary-viewport)
	  ;; Easy case is only one viewport
	  (do-viewport cursor-viewport left top right bottom)
	  ;; Hard case is two viewports with a line between
	  (let ((boundary (+ (viewport-displayed-y-position secondary-viewport)
			     (tv:sheet-inside-top))))
	    (do-viewport cursor-viewport left (min top (1- boundary))
				         right (min bottom (1- boundary)))
	    (do-viewport secondary-viewport left (max top boundary)
				            right (max bottom boundary))	  
	    ;; Redraw the line if the refresh rectangle overlaps it
	    (when (and (< top boundary)
		       ( bottom (- boundary *viewport-separator-line-height*)))
	      (send self :draw-viewport-separator-line secondary-viewport))))
      ;; Refresh other stuff displayed in the window but not in the output history
      (when current-more-position
	(send self :refresh-more-prompt))
      (tv:refresh-margins-rectangle self left top right bottom))))

;;; This should be called with the window prepared.
(defmethod (:redraw-inside-sets dynamic-window) (&optional (box cursor-viewport)
							   (clear-first t)
							   (stream self))
  (letf ((output-recording-enabled nil))	;Information is already there
    (when clear-first
      (erase-box box stream nil))
    (redraw-displayed-set displayed-strings stream
			  viewport-displayed-strings-start-index
			  viewport-displayed-strings-end-index
			  box)
    (when (and current-output-displayed-string
	       (boxes-overlap-p box (presentation-displayed-box
				      current-output-displayed-string)))
      (redraw-displayed-presentation current-output-displayed-string stream box))
    (if (eq box cursor-viewport)
	(redraw-prioritized-displayed-set displayed-graphics self
					  viewport-displayed-graphics-start-index
					  viewport-displayed-graphics-end-index
					  box stream)
	(multiple-value-bind (box-left box-top box-right box-bottom)
	    (box-edges box)
	  (coordinate-convert-points stream :relative :outside
				     box-left box-top box-right box-bottom)
	  (maxf box-left (tv:sheet-inside-left))
	  (maxf box-top (tv:sheet-inside-top))
	  (minf box-right (tv:sheet-inside-right))
	  (minf box-bottom (tv:sheet-inside-bottom))
	  (tv:with-sheet-clipping-region (box-left box-top box-right box-bottom)
	    (redraw-prioritized-displayed-set displayed-graphics self
					      viewport-displayed-graphics-start-index
					      viewport-displayed-graphics-end-index
					      box stream))))))

(defun redraw-displayed-set (array window &optional (start-index 0) end-index viewport)
  (when (null viewport)
    (setq viewport (send window :cursor-viewport)))
  (setq start-index (top-displayable-index array (box-top viewport)
					   :start start-index :end end-index))
  (when (null end-index)
    (setq end-index (bottom-displayable-index array (box-bottom viewport)
					      :start start-index)))
  (loop for object being the array-elements of array
	from start-index below end-index
	when (boxes-overlap-p viewport (presentation-displayed-box object))
	  do (redraw-displayed-presentation object window viewport)))

;;; Output items in the set that overlap box in priority order.
(defun redraw-prioritized-displayed-set
       (array window &optional (start-index 0) end-index box (stream window))
  (let* ((viewport (send window :cursor-viewport)))
    (setq start-index (top-displayable-index array (box-top viewport)
					     :start start-index :end end-index))
    (with-stack-array (presentations (if end-index (- end-index start-index) 100)
				     :fill-pointer 0)
      (let ((array array))
	(declare (array-register array))
	(when (null end-index)
	  (setq end-index (bottom-displayable-index array (box-bottom viewport)
						    :start start-index)))
	(loop for object being the array-elements of array
		  from start-index below end-index do
	  (let ((object-box (presentation-displayed-box object)))
	    (when (boxes-overlap-p box object-box)
	      (vector-push-extend (graphics-displayed-presentation-priority object)
				  presentations)
	      (vector-push-extend object presentations)))))
      #||
      ;; This relatively interesting propagation code isn't necessary any more, since
      ;; we strictly limit the sheet clipping region for the redisplay to the destination box,
      ;; so nothing can get clobbered outside of that.
      (unless (eq viewport box)
	;; Check for overlap outside of original box.
	(loop for check-index below (fill-pointer presentations) by 2 do
	  (let ((check-priority (aref presentations check-index)))
	    (when check-priority
	      (let ((check-box (presentation-displayed-box
				 (aref presentations (1+ check-index)))))
		(when (not (box-contains-box-p box check-box))
		  ;; This one is being drawn and has some bits outside of the desired box.
		  (labels ((check-this (check-priority check-box)
			     (loop for other-index below (fill-pointer presentations) by 2 do
			       (when (not (aref presentations other-index))
				 ;; We do not plan on drawing this, yet ...
				 (let* ((other-object (aref presentations (1+ other-index)))
					(other-box (presentation-displayed-box other-object))
					(other-priority
					  (graphics-displayed-presentation-priority
					    other-object)))
				   (when (and (> other-priority check-priority)
					      (boxes-overlap-p other-box check-box))
				     ;; ... and it overlaps, and is of higher priority.
				     ;; We must draw it, too.
				     (setf (aref presentations other-index) other-priority)
				     ;; And if we won't get to it later in the top pass,
				     ;; check for it's spreading out, as well.
				     (when (> other-index check-index)
				       (check-this other-priority other-box))))))))
		    (check-this check-priority check-box)))))))
	;; Flush presentations that we didn't end up having to display.
	(let ((write-index 0))
	  (loop for read-index below (fill-pointer presentations) by 2 do
	    (when (aref presentations read-index)
	      (unless (= read-index write-index)
		(setf (aref presentations write-index) (aref presentations read-index))
		(setf (aref presentations (1+ write-index))
		      (aref presentations (1+ read-index))))
	      (incf write-index 2)))
	  (setf (fill-pointer presentations) write-index)))
      ||#
      (when (plusp (fill-pointer presentations))
	(sort-grouped-array presentations 2 #'<)
	(loop for index below (fill-pointer presentations) by 2 do
	  (redraw-displayed-presentation (aref presentations (1+ index)) stream box))))))

;;; BOX is what we have to draw within.  OTHER-BOX is a box with which
;;; we should draw the overlapping part.
(defmethod (:string-out-explicit-within-boxes dynamic-window) (string box other-box)
  (multiple-value-bind (left top right bottom)
      (box-edges box)
    (let ((start-index 0)
	  (end-index (string-length string)))
      (unless (or (eq other-box cursor-viewport)
		  (eq other-box secondary-viewport))
	;; Don't need to draw all of it.  Note that we want to draw the at least the
	;; necessary portion of the string.  :COMPUTE-MOTION likes to advise you to draw
	;; at most the necessary.
	(let ((start-left (box-left other-box)))
	  (multiple-value-bind (nil nil index)
	      (send self :compute-motion string start-index end-index left top nil
								      start-left top)
	    (setq start-index (if index (max 0 (1- index)) end-index))
	    (setq left (send self :compute-motion string 0 start-index left top))))
	(let ((end-right (box-right other-box)))
	  (multiple-value-bind (nil nil index)
	      (send self :compute-motion string start-index end-index left top nil
								      end-right top)
	    (when index
	      (setq end-index index)))))
      (coordinate-convert-points self :relative :inside left top right bottom)
      (unless (< top 0)
	(letf ((coordinate-transformation-enabled nil))
	  (multiple-value-bind (width height)
	      (let ((viewport (cond ((eq other-box secondary-viewport)
				     other-box)
				    ((eq other-box cursor-viewport)
				     other-box)
				    ((and secondary-viewport
					  (box-contains-box-p secondary-viewport other-box))
				     secondary-viewport)
				    (t cursor-viewport))))
		(values (+ (viewport-displayed-x-position viewport)
			   (box-width viewport))
			(+ (viewport-displayed-y-position viewport)
			   (box-height viewport))))
	    (when (< left 0)
	      ;; This would be simpler of course if we could say start negative and work
	      ;; to positive, but that doesn't work with the crazy way :COMPUTE-MOTION is
	      ;; coded.
	      (multiple-value-bind (delta-left nil new-index)
		  (send self :compute-motion string start-index end-index 0 top nil
			(- left) top bottom 99999)
		(incf left delta-left)
		(setq start-index new-index)))
	    (when (and start-index
		       (< left width)
		       ( bottom height))
	      ;; Now that we have done all the bounds checking in the right coordinate system
	      ;; get set for :STRING-OUT-EXPLICIT.
	      (incf left tv:left-margin-size)
	      (incf top tv:top-margin-size)
	      (setq right (min right width))
	      (incf right tv:left-margin-size)
	      (tv:prepare-sheet (self)
		(do-delimited-substrings ((string :start start-index :end end-index)
					  (char start-index end-index))
		    (unless (= start-index end-index)
		      ;; Beats me why only the -INTERNAL version takes a style argument.
		      (setq left (send self :string-out-explicit-internal string
				       left top right
				       tv:char-aluf start-index end-index
				       tv:default-style)))
		  (#\Tab
		   (incf left (tv:next-tab-distance left)))
		  (#\Backspace
		   (setq left (max (- left tv:char-width) tv:left-margin-size)))))))))))
  string)

(defmethod (:viewport-containing-box dynamic-window) (box)
  (if (and secondary-viewport
	   (box-contains-box-p secondary-viewport box))
      secondary-viewport
      cursor-viewport))

(defvar *viewport-separator-line-height* 2)

(defmethod (:draw-viewport-separator-line dynamic-window) (viewport
							   &optional (erase-p nil))
  (tv:prepare-sheet (self)
    (tv:%draw-rectangle-clipped
      (tv:sheet-inside-width) *viewport-separator-line-height*
      (tv:sheet-inside-left) (+ (tv:sheet-inside-top)
				(- (viewport-displayed-y-position viewport)
				   *viewport-separator-line-height*))
      (if erase-p tv:erase-aluf tv:char-aluf) self))
  (setf (viewport-separator-displayed viewport) (not erase-p)))

(defmethod (:open-secondary-viewport dynamic-window) (new-top)
  (when (and secondary-viewport
	     (viewport-separator-displayed secondary-viewport))
    (send self :draw-viewport-separator-line secondary-viewport t))
  (when (null secondary-viewport)
    (setq secondary-viewport (make-viewport (box-left cursor-viewport) 0
					    (box-right cursor-viewport) 0)))
  (setf (box-bottom secondary-viewport) new-top)
  (let ((new-y (+ tv:line-height *viewport-separator-line-height*)))
    (setf (box-top secondary-viewport) (min (+ (box-top cursor-viewport) new-y) new-top))
    (setf (viewport-displayed-y-position secondary-viewport) new-y))
  (set-box-edges cursor-viewport (box-left cursor-viewport) new-top
		 (box-right cursor-viewport) (+ new-top tv:line-height))
  (send self :draw-viewport-separator-line secondary-viewport)
  ;; Scrolling needs to be rethought.
  (send self :new-scroll-position))

(defmethod (:move-secondary-viewport-boundary dynamic-window) (&optional bottom)
  (when secondary-viewport
    (when (null bottom)
      (setq bottom tv:(+ (- cursor-y top-margin-size) line-height)))
    (let* ((new-box-bottom (+ (box-top cursor-viewport) bottom))
	   (delta (- new-box-bottom (box-bottom cursor-viewport))))
      (when (plusp delta)
	(setf (box-bottom cursor-viewport) new-box-bottom)
	(setf (box-top secondary-viewport)
	      ;; Keep it well formed.  We won't actually do any output
	      ;; when the viewport's empty, because of exceptions.
	      (min (+ (box-top secondary-viewport) delta) (box-bottom secondary-viewport)))
	(incf (viewport-displayed-y-position secondary-viewport) delta)))
    (send self :draw-viewport-separator-line secondary-viewport)
    (send self :new-scroll-position)))

(defmethod (:include-graphics-in-cursor-viewport dynamic-window) ()
  (when secondary-viewport
    (let ((visible-bottom (min (viewport-displayed-bottom secondary-viewport)
			       (- maximum-y-position (box-top cursor-viewport)))))
      (when (> visible-bottom (box-height cursor-viewport))
	(when (viewport-separator-displayed secondary-viewport)
	  (send self :draw-viewport-separator-line secondary-viewport t))
	(send self :move-secondary-viewport-boundary visible-bottom)))))

(defmethod (:close-secondary-viewport dynamic-window) (&optional (update-display-p t))
  (when secondary-viewport
    (let ((old-sv secondary-viewport))
      (setq secondary-viewport nil)
      (when update-display-p
	(multiple-value-bind (x y)
	    (send self :read-cursorpos)
	  (tv:with-temporary-sheet-bit-raster
	    (temporary-array self (box-width old-sv) (box-height old-sv))
	    (letf ((output-recording-enabled nil)
		   (coordinate-transformation-enabled nil))
	      (when (viewport-separator-displayed old-sv)
		(send self :draw-viewport-separator-line old-sv t))
	      (send self :bitblt-from-sheet tv:alu-seta
		    (box-width old-sv) (box-height old-sv)
		    (viewport-displayed-x-position old-sv)
		    (viewport-displayed-y-position old-sv)
		    temporary-array 0 0)
	      (send self :bitblt-within-sheet tv:alu-seta
		    (box-width cursor-viewport) (- (box-height cursor-viewport))
		    (viewport-displayed-x-position cursor-viewport)
		    (viewport-displayed-y-position cursor-viewport)
		    (viewport-displayed-x-position old-sv)
		    (box-height old-sv))
	      (send self :bitblt tv:alu-seta
		    (box-width old-sv) (box-height old-sv)
		    temporary-array 0 0
		    (viewport-displayed-x-position cursor-viewport)
		    (viewport-displayed-y-position cursor-viewport))
	      (multiple-value-bind (left top)
		  (box-position old-sv)
		(set-box-position cursor-viewport left top))))
	  (send self :set-cursorpos x y)))
      (setf (viewport-separator-displayed old-sv) nil))
    (set-viewport-displayed-position cursor-viewport 0 0)
    (set-box-size cursor-viewport (tv:sheet-inside-width) (viewport-integral-height))))

(defmethod (:console-cut/copy dynamic-window) (cutp)
  (let ((history (and (typep self 'tv:sheet) (console-kill-history (tv:sheet-console self)))))
    (if (null history)
	(beep)
	(let ((strings
		(loop for window in (cp::windows-for-marking-and-yanking :window self)
		      for text = (send window :marked-text :return-as-string t :unmark t
				       :delete cutp)
		      when text collect text)))
	  (if (null strings)
	      (beep)
	      (let ((string (apply #'string-append strings)))
		(send zwei:*kill-history* :push string)
		(send history :push string)))))))

(defwhopper (:asynchronous-character-p dynamic-window) (character)
  (or (continue-whopper character)
      (member character '(#\Keyboard:Cut #\Keyboard:Copy))
      (and asynchronous-scroll-handler
	   (member character '(#\Scroll #\Meta-scroll #\Super-scroll #\Meta-super-scroll
			       #\Keyboard:Back-Scroll #\Super-Keyboard:Back-Scroll)))))

(defwhopper (:handle-asynchronous-character dynamic-window) (character)
  (let ((handler asynchronous-scroll-handler))
    (cond ((and handler
		(member character '(#\Scroll #\Meta-scroll #\Super-scroll #\Meta-super-scroll
				    #\Keyboard:Back-Scroll #\Super-Keyboard:Back-Scroll)))
	   (multiple-value-bind (x y)
	       (case character
		 (#\Scroll (values 0 1))
		 ((#\Meta-scroll #\Keyboard:Back-Scroll) (values 0 -1))
		 (#\Super-scroll (values 1 0))
		 ((#\Meta-super-scroll #\Super-Keyboard:Back-Scroll) (values -1 0)))
	     (if (eq handler t)
		 (process-run-function "Scroll" #'do-pending-scroll self x y)
		 (funcall handler x y))))
	  ((member character '(#\Keyboard:Cut #\Keyboard:Copy))
	   (process-run-function "Cut/Copy"
	     self :console-cut/copy (char= character #\Keyboard:Cut)))
	  (t
	   (continue-whopper character)))))

(defvar *default-end-of-page-mode* :scroll)
(defvar *default-end-of-page-scroll-factor* 1)

(defun set-default-end-of-page-mode (new-end-of-page-mode
				     &optional (new-scroll-factor nil nf-p))
  (check-type new-end-of-page-mode (member :scroll :wrap :truncate))
  (when nf-p
    (setq *default-end-of-page-scroll-factor* new-scroll-factor))
  (unless (eq *default-end-of-page-mode* new-end-of-page-mode)
    (setq *default-end-of-page-mode* new-end-of-page-mode)
    ;; There ought to be a better way to do this
    (si:map-over-objects-in-area tv:sheet-area #'si:region-predicate-structure
       #'(lambda (ignore ignore window ignore ignore)
	   (when (and (typep window 'dynamic-window) (zerop (tv:sheet-dead window)))
	     (let ((epm (send window :end-of-page-mode)))
	       (when (eq epm :default)
		 (send window :set-end-of-page-mode epm))))))))

(defun (:property set-default-end-of-page-mode :undo-function) (form)
  (destructuring-bind (ignore end-of-page-mode &optional (new-scroll-factor nil nf-p))
     form
    (ignore end-of-page-mode new-scroll-factor)
    `(set-default-end-of-page-mode ,*default-end-of-page-mode*
				   . ,(when nf-p
					`(,*default-end-of-page-scroll-factor*)))))

(defmethod (:defaulted-end-of-page-mode dynamic-window) ()
  (values (if (eq end-of-page-mode :default)
	      *default-end-of-page-mode*
	      end-of-page-mode)
	  (or scroll-factor *default-end-of-page-scroll-factor*)))

(defmethod (:set-end-of-page-mode dynamic-window) (new-mode)
  (check-type new-mode (member :default :scroll :wrap :truncate))
  (setq end-of-page-mode new-mode)
  (setq new-mode (send self :defaulted-end-of-page-mode))
  (unless (eq new-mode :scroll)
    (when secondary-viewport
      (tv:sheet-force-access (self)
	(send self :close-secondary-viewport))))
  (let ((truncate-p (eq new-mode :truncate)))
    (setf (tv:sheet-truncate-output-vertical-flag) (if truncate-p 1 0))
    (when truncate-p
      ;; Cannot do :SET-MORE-P T, because we don't know whether the
      ;; window wasn't supposed to have it in the first place.
      ;; But if truncating, we know we don't want it.
      (send self :set-more-p nil)))
  (when (eq new-mode :truncate)
    (setq asynchronous-scroll-handler t)))

(defmacro with-deferred-asynchronous-scrolling (&body body)
  `(let ((pending-x 0)
	 (pending-y 0))
     (flet ((increment-pending-scroll (x y)
	      (declare (downward-function))
	      (incf pending-x x)
	      (incf pending-y y)))
       (multiple-value-prog1
	 (let-globally-if (eq asynchronous-scroll-handler t)
			  ((asynchronous-scroll-handler #'increment-pending-scroll))
	   . ,body)
	 (do-pending-scroll self pending-x pending-y)))))

(defun do-pending-scroll (window dx dy)
  (unless (zerop dx)
    (cp::scroll-window-command-internal :screen dx :x window))
  (unless (zerop dy)
    (cp::scroll-window-command-internal :screen dy :y window)))

(defmethod (:highlight-string-intervals dynamic-window) (string intervals box
							 &optional other-box)
  (when (null other-box)
    (setq other-box (send self :viewport-containing-box box)))
  (multiple-value-bind (start-x start-y)
      (box-edges box)
    (dolist (interval intervals)
      (destructuring-bind (start-index end-index &optional (highlighting-mode :underline)
							   ignore)
			  interval
	(let* ((x1 (send self :compute-motion string 0 start-index start-x start-y
			 nil 0 nil 99999 99999 nil))
	       (x2 (send self :compute-motion string start-index end-index x1 start-y
			 nil 0 nil 99999 99999 nil)))
	  (unless (or (eq other-box cursor-viewport)
		      (eq other-box secondary-viewport))
	    (multiple-value-bind (left nil right)
		(box-edges other-box)
	      (setq x1 (max x1 left)
		    x2 (min x2 right))))
	  (multiple-value-bind (y height)
	      (ecase highlighting-mode
		(:underline
		  (values (+ start-y tv:baseline) 1))
		(:inverse-video
		  (values start-y (box-height box))))
	    (letf ((output-recording-enabled nil))
	      (send self :draw-rectangle (- x2 x1) height x1 y :flip))))))))

;;;; Normal stream (TTY) output.

(defvar *fake-presentation*)

;;; This is a separate function because it won't compile inline in the
;;; cleanup clause of an unwind-protect.
(defun-in-flavor (dynamic-window-input-editor-finish dynamic-window) ()
  (when (and (eq output-recording-enabled t)
	     ;; Recursive input editing will have saved the input buffer, and turned
	     ;; on output recording, and we cannot know what the level was outside of
	     ;; that save.  We need a new special form to enclose save/restore that
	     ;; could then inhibit and save/fake outside itself as appropriate.
	     (not *input-editor-typein*))
    (let ((string si:last-input))
      (when string
	(when (null *fake-presentation*)
	  (send self :set-input-buffer-presentation string))
	(destructuring-bind (object type &optional superior processor)
			    *fake-presentation*
	  (flet ((fake-out (stream)
		   (let ((presentation
			   (send stream :fake-presentation-out object type
				 string
				 input-editor-initial-x input-editor-initial-y)))
		     (when processor
		       (funcall processor stream presentation)))))
	    (if superior
		(send self :output-for-re-presentation superior #'fake-out self)
		(fake-out self)))))))
  (when matching-character-blinker
    (tv:blinker-set-visibility matching-character-blinker nil)))

(defun-in-flavor (maybe-wait-for-cursor-visible dynamic-window) (&optional reset-p)
  (when (eq (send self :defaulted-end-of-page-mode) :truncate)
    ;; Only do this if the cursor is user-visible.  That's a kludge to distinguish
    ;; listener type applications (where we want to give the user a chance to
    ;; use the scroll key, rather than the mouse, to scroll the window back to
    ;; a position where the prompt and the input are visible) from viewer type
    ;; applications, as in the Document Examiner, where this is unwanted.
    ;; Also it would be nice if tracking-mouse-internal could prevent control
    ;; from ever reaching this point, e.g. when the user pressed control-mouse-Left,
    ;; however that's difficult to implement.
    (when (send self :following-blinker)
      (letf ((end-of-page-mode :scroll))
	(when (multiple-value-bind (nil y)
		  (send self :read-cursorpos)
		(> (- y last-typein-y) (tv:sheet-inside-height)))
	  (wait-for-cursor-visible self))))
    (when reset-p
      (setq end-of-page-mode :scroll))))

(defwhopper (:input-editor dynamic-window) (&rest args)
  (send self :close-current-output-displayed-string)	;Close off current output
  (let ((*fake-presentation* nil))
    (multiple-value-bind (initial-x initial-y)
	(send self :read-cursorpos)
      (letf ((input-editor-initial-x initial-x)
	     (input-editor-initial-y initial-y))
	(unwind-protect
	    (letf ((end-of-page-mode end-of-page-mode))
	      (maybe-wait-for-cursor-visible t)
	      (setf (tv:sheet-truncate-output-flag) 0)
	      (letf ((output-recording-enabled (and output-recording-enabled :clear-region)))
		(lexpr-continue-whopper args)))
	  (setf (tv:sheet-truncate-output-flag)
		(if (eq (send self :defaulted-end-of-page-mode) :truncate) 2 0))
	  (dynamic-window-input-editor-finish))))))

(defwhopper-subst (:any-tyi dynamic-window) (&rest args)
  (let-globally ((asynchronous-scroll-handler nil))
    (lexpr-continue-whopper args)))

;;; Wait for user to scroll through output and then set to allow output
;;; while doing editing.
(defun wait-for-cursor-visible (window)
  (unwind-protect
      (flet ((cursor-visible ()
	       (declare (downward-function))
	       (zerop (tv:sheet-end-page-flag window))))
	(loop while (not (cursor-visible))
	      as char = (read-character window
					:input-wait #'cursor-visible
					:input-wait-handler (lambda ()
							      (declare (downward-function))
							      (when (cursor-visible)
								(return)))
					:whostate "Scroll tyi")
	      do (selector char char-equal
		   ((#\Scroll #\Space)
		    (do-pending-scroll window 0 +1))
		   ((#\Meta-scroll #\Backspace #\Keyboard:Back-Scroll)
		    (do-pending-scroll window 0 -1))
		   ((#\Meta->) (return))
		   ((#\Keyboard:Cut #\Keyboard:Copy)
		    (send-if-handles window :console-cut/copy (char= char #\Keyboard:Cut)))
		   (otherwise (beep)))))
    (send window :scroll-for-end-of-page))
  t)

;;; Should be similar communication for noise strings.
(defmethod (:display-prompt dynamic-window) (continuation) 
  (letf ((output-recording-enabled t))
    (funcall continuation))
  (unless (eq output-recording-enabled t)
    (multiple-value-setq (input-editor-initial-x input-editor-initial-y)
      (send self :read-cursorpos))))

(defmethod (:start-typeout dynamic-window :before) (&rest ignore)
  (setf output-recording-enabled t))

(defmethod (:finish-typeout dynamic-window :before) (&rest ignore)
  (setf output-recording-enabled :clear-region)
  (multiple-value-setq (input-editor-initial-x input-editor-initial-y)
    (send self :read-cursorpos)))

(defwhopper (:with-saved-state-for-break dynamic-window) (&rest args)
  (send self :with-normal-presentation-state
	#'(lambda () (lexpr-continue-whopper args))))

(defmethod (:with-normal-presentation-state dynamic-window) (continuation &rest args)
  (send self :close-current-output-displayed-string)
  (letf ((output-recording-enabled t)
	 (coordinate-transformation-enabled t)
	 (current-output-displayed-presentation nil)
	 ;;This one really belongs on a graphics mixin.
	 (graphics::drawing-state nil))
    (apply continuation args)))

(defmethod (:set-input-buffer-presentation dynamic-window)
	   (object &optional (type (type-of object))
			     superior-presentation presentation-processor)
  (setq *fake-presentation* (list object type superior-presentation
				  presentation-processor)))

(defvar-resettable *truncate-output-catch* nil)

(defmacro truncate-output-catch (&body body)
  `(catch 'truncate-output
     (let ((*truncate-output-catch* t))
       . ,body)))

(defmacro get-displayed-string-unless-truncating ()
  `(loop named no-truncate do
     (truncate-output-catch
       (return-from no-truncate
	 (send self :check-current-output-displayed-string (not truncate-p))))
     (when truncate-p
       (error "Truncation without exceptions?"))
     (setq truncate-p t)
     (multiple-value-setq (start-x start-y)
       (send self :read-cursorpos))))

(defwhopper (:tyo dynamic-window) (char)
  (tv:prepare-sheet (self)
    (let ((return-p (char-equal char #\Return)))
      (when (and return-p secondary-viewport
		 (viewport-separator-displayed secondary-viewport))
	(send self :draw-viewport-separator-line secondary-viewport t))
      (when (and return-p (plusp (box-left cursor-viewport))
		 (zerop (tv:sheet-end-page-flag)))
	(multiple-value-bind (nil y)
	    (send self :read-cursorpos)
	  (with-output-truncation (self)
	    (send self :set-cursorpos 0 (+ y tv:current-line-height))))
	tv:(setq current-line-height line-height
		 current-baseline baseline)
	(send self :clear-rest-of-line)
	(return-from :tyo char))
      (flet ((do-it ()
	       (with-integral-bottom-margin
		 (continue-whopper char))
	       (when (and secondary-viewport
			  (not (viewport-separator-displayed secondary-viewport)))
		 (send self :move-secondary-viewport-boundary))))
	(if (neq output-recording-enabled t)
	    (do-it)
	    (with-deferred-asynchronous-scrolling
	      (let* ((displayed-string nil)
		     (truncate-p (tv:sheet-truncate-output-p))
		     (was-truncate-p truncate-p)
		     start-x start-y
		     end-x end-y)
		(when truncate-p
		  (multiple-value-setq (start-x start-y) (send self :read-cursorpos))
		  (if return-p
		      (setq end-x 0
			    end-y (+ start-y tv:current-line-height))
		      (setq end-x (+ start-x (send self :character-width char))
			    end-y start-y))
		  (when (or (if return-p
				(not (tv:sheet-truncate-output-p self :vertical))
				(not (tv:sheet-truncate-output-p self :horizontal)))
			    (box-contains-point-p cursor-viewport end-x
						  (if (tv:sheet-truncate-output-p
							self :vertical)
						      end-y
						      (box-top cursor-viewport))))
		    ;; Still on the screen
		    (when (or (not (tv:sheet-truncate-output-p self :vertical))
			      (zerop (tv:sheet-end-page-flag)))
		      (setq truncate-p nil))))
		(if return-p
		    (send self :close-current-output-displayed-string)
		    (setq displayed-string (get-displayed-string-unless-truncating)))
		(block normal-output
		  (unless truncate-p
		    (truncate-output-catch
		      (letf ((output-recording-enabled (if output-recording-enabled
							   :clear-region
							   nil)))
			(do-it))
		      (when displayed-string
			(when current-output-displayed-string	;Might change on continuation
			  (setq displayed-string current-output-displayed-string))
			(setq end-x (send self :read-cursorpos)))
		      (when (and was-truncate-p return-p
				 (not (box-contains-point-p cursor-viewport start-x start-y)))
			(send self :adjust-cursor-position-and-visibility 0 0))
		      (return-from normal-output)))
		  (unless return-p
		    (maxf maximum-x-position end-x))
		  (multiple-value-bind (dx dy)
		      (cond (start-x
			     (values (- end-x start-x) (- end-y start-y)))
			    (return-p
			     (values 0 tv:current-line-height))
			    (t
			     (values (send self :character-width char) 0)))
		    (send self :adjust-cursor-position-and-visibility dx dy))
		  (when return-p
		    tv:(setq current-line-height line-height
			     current-baseline baseline)
		    (send self :clear-rest-of-line)))
		(when displayed-string
		  (displayed-string-add-char displayed-string char tv:current-style)
		  (displayed-string-note-new-right displayed-string end-x)))))))))

(defwhopper (:string-out dynamic-window) (string &optional (start 0) end)
  (setq string (string string))
  (tv:prepare-sheet (self)
    (if (neq output-recording-enabled t)
	(continue-whopper string start end)
      (with-deferred-asynchronous-scrolling
	(do-delimited-substrings ((string :start start :end end)
				  (char start-index end-index))
	    (unless (= start-index end-index)
	      (multiple-value-bind (start-x start-y)
		  (send self :read-cursorpos)
		(let ((truncate-p (tv:sheet-truncate-output-p self :horizontal))
		      new-right)
		  (when truncate-p
		    (when (or (box-contains-point-p cursor-viewport start-x start-y)
			      (and (not (tv:sheet-truncate-output-p self :vertical))
				   (box-contains-point-p cursor-viewport start-x
							 (box-top cursor-viewport))))
		      ;; Not all off the screen, we need to try to output some.
		      (when (or (not (tv:sheet-truncate-output-p self :vertical))
				(zerop (tv:sheet-end-page-flag)))
			(setq truncate-p nil))))
		  (with-stack-list (state (get-displayed-string-unless-truncating)
					  string start-index end-index start-x start-y)
		    (block normal-output
		      (unless truncate-p
			(truncate-output-catch
			  (letf ((output-recording-enabled (if output-recording-enabled
							       :clear-region
							       nil))
				 (string-out-state state))
			    (continue-whopper string start-index end-index))
			  (setq new-right (send self :read-cursorpos))
			  (return-from normal-output))
			(setq truncate-p t))
		      (setf `(ignore ignore ,start-index ignore ,start-x ,start-y)
			    state)
		      (setq new-right (send self :compute-motion string start-index end-index
					    start-x start-y nil 0 nil 100000 100000))
		      (maxf maximum-x-position new-right)
		      (setq start-x (send self :read-cursorpos))
		      (send self :adjust-cursor-position-and-visibility (- new-right start-x)
			    0))
		    (let ((string string))
		      (declare (sys:array-register string))
		      (loop for i from start-index below end-index
			    for old-type = 0 then type
			    for type = (si:char-type (aref string i))
			    unless (= type old-type)
			      do
				(let* ((new-char (aref string i))
				       (new-style (si:char-style new-char))
				       (merged-style (si:merge-character-styles
						       new-style
						       tv:merged-current-style))
				       (new-char-set (si:char-char-set-and-index new-char))
				       (font
					 (or (si:cache-lookup tv:charset&stylefont-cache
							      #'si:get-font
							      tv:display-device-type
							      new-char-set
							      merged-style
							      nil)
					     (si:cache-lookup tv:charset&stylefont-cache
							      #'si:get-font
							      tv:display-device-type
							      new-char-set
							      si:*undefined-character-style*))
					 ))
				   (maxf tv:current-line-height
					 (+ (si:font-char-height font) tv:vsp)))))
		    (destructuring-bind (displayed-string ignore start-index
					 ignore ignore ignore)
					state
		      (displayed-string-add-string displayed-string string start-index
						   end-index tv:current-style)
		      (displayed-string-note-new-right displayed-string new-right))
		    (when (and truncate-p (zerop (tv:sheet-end-page-flag)))
		      ;; Oops, looks like we came in from the left.
		      (send self :redisplay-between-cursorposes start-x start-y
								new-right start-y))))))
	  (#\Return
	   (send self :tyo char))))))
  string)

(defmethod (:real-set-cursorpos dynamic-window) () t)

(defmethod (:read-cursorpos dynamic-window) (&optional (unit :pixel))
  ;; Everything that affects the relationship between the viewport and tv:cursor-x/y
  ;; does so without-interrupts, so that locking is not necessary here.
  ;; :read-cursorpos is done more frequently while printing than you would probably believe.
  (multiple-value-bind (x y)
      (send self :convert-to-absolute-coordinates tv:cursor-x tv:cursor-y :outside)
    (ecase unit
      (:pixel (values x y))
      (:character (values (truncate x tv:char-width) (truncate y tv:line-height))))))

(defmethod (:visible-cursorpos-limits dynamic-window) (&optional (unit :pixel))
  (multiple-value-bind (left top right bottom)
      (if cursor-viewport
	  (box-edges cursor-viewport)
	  (values 0 0 (tv:sheet-inside-width) (viewport-integral-height)))
    (ecase unit
      (:pixel (values left top right bottom))
      (:character (values (floor left tv:char-width) (floor top tv:line-height)
			  (floor right tv:char-width) (floor bottom tv:line-height))))))

(defwhopper (:increment-cursorpos dynamic-window) (dx dy &optional (unit :pixel))
  (tv:prepare-sheet (self)
    (send self :close-current-output-displayed-string)
    (unless dx (setq dx 0))
    (unless dy (setq dy 0))
    (multiple-value-bind (old-x old-y)
	(send self :read-cursorpos)
      (ecase unit
	(:pixel )
	(:character
	  (if (not (zerop dx))
	      (setq dx (- (* dx tv:char-width) (rem old-x tv:char-width))))
	  (if (not (zerop dy))
	      (setq dy (- (* dy tv:line-height) (rem old-y tv:line-height))))))
      (let ((truncate-p (tv:sheet-truncate-output-p))
	    (was-truncate-p nil))
	(when truncate-p
	  (let ((new-x (+ old-x dx))
		(new-y (+ old-y dy)))
	    (when (selector (tv:sheet-truncate-output-flag) =
		    (0 t)
		    (1 (setq was-truncate-p (not (box-contains-point-p cursor-viewport
								   old-x old-y)))
		       (or (not (box-contains-point-p cursor-viewport old-x old-y))
			   (box-contains-point-p cursor-viewport new-x old-y)))
		    (2 (box-contains-point-p cursor-viewport old-x new-y))
		    (3 (setq was-truncate-p (not (box-contains-point-p cursor-viewport
								       old-x old-y)))
		       (box-contains-point-p cursor-viewport new-x new-y)))
	      (setq truncate-p nil))))
	(block normal-output
	  (unless truncate-p
	    (when (and secondary-viewport (plusp dy)
		       (viewport-separator-displayed secondary-viewport))
	      (send self :draw-viewport-separator-line secondary-viewport t))
	    (truncate-output-catch
	      (continue-whopper dx dy :pixel)
	      (when was-truncate-p
		(send self :adjust-cursor-position-and-visibility 0 0))
	      (when (and secondary-viewport
			 (not (viewport-separator-displayed secondary-viewport)))
		(send self :move-secondary-viewport-boundary))
	      (return-from normal-output t)))
	  (send self :adjust-cursor-position-and-visibility dx dy))))))

(defwhopper (:set-cursorpos dynamic-window) (x y &optional (unit :pixel))
  (tv:prepare-sheet (self)
    (ecase unit
      (:pixel )
      (:character
       (when x (setq x (* x tv:char-width)))
       (when y (setq y (* y tv:line-height)))))
    (send self :close-current-output-displayed-string)
    (multiple-value-bind (old-x old-y)
	(send self :read-cursorpos)
      (when (and secondary-viewport y (> y old-y)
		 (viewport-separator-displayed secondary-viewport))
	(send self :draw-viewport-separator-line secondary-viewport t))
      (let ((was-truncate-p nil))
	(if (let ((x (or x old-x))
		  (y (or y old-y)))
	      (selector (tv:sheet-truncate-output-flag) =
		;; Moving from one invisible point to another, don't let clipping interfere.
		(0 (and (not (box-contains-point-p cursor-viewport old-x old-y))
			(not (box-contains-point-p cursor-viewport x y))))
		;; Horizontal clipping only
		(1 (setq was-truncate-p (not (box-contains-point-p cursor-viewport
								   old-x old-y)))
		   (and (box-contains-point-p cursor-viewport old-x y)
			(not (box-contains-point-p cursor-viewport x y))))
		;; Vertical clipping only
		(2 (not (box-contains-point-p cursor-viewport x old-y)))
		;; Both
		(3 (setq was-truncate-p (not (box-contains-point-p cursor-viewport
								   old-x old-y)))
		   (not (box-contains-point-p cursor-viewport x y)))))
	    (send self :adjust-cursor-position-and-visibility (if x (- x old-x) 0)
							      (if y (- y old-y) 0))
	    (multiple-value-bind (x y)
		(send self :convert-to-relative-coordinates x y)
	      (letf ((coordinate-transformation-enabled nil)
		     (tv:more-vpos tv:more-vpos))	;Don't let this get reset
		(continue-whopper x y :pixel)))
	    (when was-truncate-p
	      (send self :adjust-cursor-position-and-visibility 0 0))
	    (when (and secondary-viewport
		       (not (viewport-separator-displayed secondary-viewport)))
	      (send self :move-secondary-viewport-boundary)))))))

(defwhopper (:compute-motion dynamic-window) (string &optional (start 0) (end nil)
							       start-x start-y cr-at-end-p
							       (stop-x 0) stop-y
							       bottom-limit right-limit
							       account-for-continuation-after
							       )
  (multiple-value-bind (current-x current-y)
      (send self :read-cursorpos)
    (when (null start-x)
      (setq start-x current-x))
    (when (null start-y)
      (setq start-y current-y)))
  (coordinate-convert-points self :relative :inside
			     start-x start-y stop-x stop-y right-limit bottom-limit)
  (when (null stop-y)
    (setq stop-y 999999))
  (when (null bottom-limit)
    (setq bottom-limit 999999))		;No limit
  (multiple-value-bind (end-x end-y index)
      (letf ((coordinate-transformation-enabled nil))
	(continue-whopper string start end start-x start-y cr-at-end-p
			  stop-x stop-y bottom-limit right-limit
			  account-for-continuation-after))
    (coordinate-convert-points self :absolute :inside end-x end-y)
    (values end-x end-y index)))

(defun copy-string-with-fill-pointer (string &optional (start 0) end)
  (when (null end)
    (setq end (fill-pointer string)))
  (let* ((length (- end start))
	 (new-string (make-array length :element-type 'character :fill-pointer length
				 :area (%area-number string))))
    (copy-array-portion string start end new-string 0 length)
    new-string))

(eval-when (eval load compile)
(defun viewport-displayed-array-index-names (array-name)
  (ecase array-name
    (displayed-presentations
      (values 'viewport-displayed-presentations-start-index
	      'viewport-displayed-presentations-end-index))
    (displayed-strings
      (values 'viewport-displayed-strings-start-index
	      'viewport-displayed-strings-end-index))
    (displayed-graphics
      (values 'viewport-displayed-graphics-start-index
	      'viewport-displayed-graphics-end-index))))
)

(defun-in-flavor (note-end-of-viewport-clobbered dynamic-window) (end-clobbered)
  (when end-clobbered
    (let ((max 0))
      (flet ((max-in (array)
	       (let ((length (fill-pointer array)))
		 (when (plusp length)
		   (maxf max (box-bottom (presentation-displayed-box 
					   (aref array (1- length)))))))))
	(max-in displayed-presentations)
	(max-in displayed-strings)
	(max-in displayed-graphics))
      (setq maximum-y-position max)))
  (send self :new-scroll-position))

;;; Coordinates can be NIL, meaning to the end in this direction
(defmethod (:note-region-clobbered dynamic-window)
	   (left top right bottom &optional protected-presentations)
  (tv:lock-sheet (self)
    ;; Clear out remembered stuff
    (flet ((index-range (array window-start-index)
	     (declare (values start-index end-index))
	     (let ((length (fill-pointer array)))
	       (when (or (zerop length)
			 (multiple-value-bind (lleft ltop lright lbottom)
			     (box-edges (presentation-displayed-box (aref array (1- length))))
			   (ignore lleft)
			   (and top
				(or ( top lbottom)
				    (and (= top ltop) left
					 ( left lright))))))
		 (return-from index-range
		   (values length length))))
	     (let ((start-index (cond ((null top) 0)
				      (( top (box-top cursor-viewport))
				       (top-displayable-index array top
							      :start window-start-index))
				      (t (top-displayable-index array top)))))
	       (values start-index
		       (if bottom
			   (bottom-displayable-index array bottom :start start-index)
			   (fill-pointer array))))))
      (macrolet ((do-overlapping-boxes ((object (array array-var) box index) &body body)
		   (multiple-value-bind (array-start-idx array-end-idx)
		       (viewport-displayed-array-index-names array)
		     `(multiple-value-bind (start-index end-index)
			  (index-range ,array ,array-start-idx)
			(unless (= start-index end-index)
			  (let ((,array-var ,array))
			    (declare (array-register ,array-var))
			    (loop for ,object being the array-elements of ,array-var
				      from start-index below end-index
					      using (index ,index)
						    doing
			      (let ((,box (presentation-displayed-box ,object)))
				(when (box-overlaps-region-p ,box left top right bottom)
				  . ,body)))
			    (let ((write-index start-index)
				  (end-clobbered (let ((end (fill-pointer ,array-var)))
						   (and (plusp end)
							(null (aref ,array-var (1- end)))))))
			      (loop for read-index from start-index below end-index doing
				(let ((thing (aref ,array-var read-index)))
				  (when thing
				    (unless (= read-index write-index)
				      (setf (aref ,array-var write-index) thing))
				    (incf write-index))))
			      (unless (= write-index end-index)
				(let ((nremoved (- end-index write-index)))
				  (loop for read-index from end-index
						       below (fill-pointer ,array-var)
					doing
				    (setf (aref ,array-var write-index)
					  (aref ,array-var read-index))
				    (incf write-index))
				  (setf (fill-pointer ,array-var) write-index)
				  ;; Indices into viewport portion may now be out of bounds.
				  (setf ,array-start-idx (max 0 (min write-index
								     (- ,array-start-idx
									nremoved))))
				  (when ,array-end-idx
				    (minf ,array-end-idx write-index))
				  (note-end-of-viewport-clobbered end-clobbered))))))))))
	;; Remember which presentations are left in the clobbered area, they
	;; will need to get their displayed-string instance variables updated any new
	;; shorten strings that get constructed.
	(with-stack-array (overlapping-presentations-remaining 10 :fill-pointer 0)
	  ;; First the presentations.  Clear out terminal presentations that
	  ;; overlap, and all non terminal all of whose inferiors were terminated.
	  (do-overlapping-boxes (displayed-presentation (displayed-presentations array)
							box index)
	    (labels ((flush-inferiors (presentation)
		       (unless (find presentation protected-presentations)
			 (let ((inferiors (delete-if
					    #'(lambda (inferior)
						(and (let ((box (presentation-displayed-box
								  inferior)))
						       ;; Overlapping requires a non-zero
						       ;; area, containing does not.
						       (if (box-well-formed-p box)
							   (box-overlaps-region-p
							     box left top right bottom)
							   (box-contained-in-region-p
							     box left top right bottom)))
						     (flush-inferiors inferior)))
					    (presentation-inferiors presentation))))
			   (setf (presentation-inferiors presentation) inferiors)
			   (null inferiors)))))
	      (if (flush-inferiors displayed-presentation)
		  (setf (aref array index) nil)
		  (vector-push-extend displayed-presentation
				      overlapping-presentations-remaining))))
	  ;; Then the strings.  Any characters that are erased are forgotten.  This can
	  ;; require splitting the string into two pieces.
	  (with-stack-array (strings-to-be-added 10 :fill-pointer 0)
	    (do-overlapping-boxes (displayed-string (displayed-strings array) box index)
	      (if (box-contained-in-region-p box left top right bottom)
		  (setf (aref array index) nil)
		  (let ((string (displayed-string-string displayed-string)))
		   (multiple-value-bind (bleft btop bright bbottom)
		       (box-edges box)
		    (multiple-value-bind (salvage-left-end nil salvage-left-end-index)
			(if (null left)
			    (values bleft nil 0)
			    (send self :compute-motion string 0 nil bleft btop nil left btop))
		      (when (null salvage-left-end-index)
			(setq salvage-left-end-index (fill-pointer string)))
		      (multiple-value-bind (salvage-right-start nil salvage-right-start-index)
			  (if (null right)
			      (values bright nil nil)
			      (send self :compute-motion string salvage-left-end-index nil
				    salvage-left-end btop nil right btop))
			(when (null salvage-right-start-index)
			  (setq salvage-right-start-index (fill-pointer string)))
			;; Now have [new-left] [erased] [new-right]
			;;                            
			;;                    left-end right-start
			(let ((new-left-string nil)
			      (new-right-string nil))
			  (unless (= salvage-right-start-index (fill-pointer string))
			    (if (plusp salvage-left-end-index)
				;; Need to save two pieces.  In this case, we must cons a
				;; new string.
				(setq new-right-string
				      (make-displayed-string
					(copy-string-with-fill-pointer
					  string salvage-right-start-index)
					(displayed-string-baseline displayed-string)
					(displayed-string-default-character-style
					  displayed-string)
					 salvage-right-start btop bright bbottom))
			      ;; Only need to save right portion.  Can reuse old string after
			      ;; shifting contents.
			      (setq new-right-string displayed-string)
			      (let* ((old-length (fill-pointer string))
				     (new-length (- old-length salvage-right-start-index)))
				(copy-array-portion string salvage-right-start-index old-length
						    string 0 new-length)
				(setf (fill-pointer string) new-length))
			      (setf (box-left box) salvage-right-start)))
			  ;; Save left by just truncating fill-pointer.
			  (unless (zerop salvage-left-end-index)
			    (setq new-left-string displayed-string)
			    (setf (fill-pointer string) salvage-left-end-index)
			    (setf (box-right box) salvage-left-end))
			  ;; Now walk down presentations that remained and see if any text
			  ;; leaves are concerned with the one we just changed.  Use the
			  ;; geometry to limit the recursion.
			  (labels ((convert-text (presentation)
			      (when (box-overlaps-region-p
				      (presentation-displayed-box presentation)
				      bleft btop bright bbottom)
				(if (typep presentation 'text-displayed-presentation)
				    (when (eq displayed-string
					      (text-displayed-presentation-displayed-string
						presentation))
				      (cond (( (text-displayed-presentation-end-index
						  presentation)
						salvage-left-end-index)
					     (setf (text-displayed-presentation-displayed-string
						     presentation)
						   new-left-string))
					    (( (text-displayed-presentation-start-index
						  presentation)
						salvage-right-start-index)
					     (setf (text-displayed-presentation-displayed-string
						     presentation)
						   new-right-string)
					     (decf (text-displayed-presentation-start-index
						     presentation)
						   salvage-right-start-index)
					     (when (text-displayed-presentation-end-index
						     presentation)
					       (decf (text-displayed-presentation-end-index
						       presentation)
						     salvage-right-start-index)))))
				    (map () #'convert-text
					 (presentation-inferiors presentation))))))
			    (map () #'convert-text overlapping-presentations-remaining))
			  ;; Arrange for new string(s) to get into array.
			  (if (null new-left-string)
			      (setf (aref array index) new-right-string)
			    (setf (aref array index) new-left-string)
			    (when new-right-string
			      (vector-push-extend new-right-string strings-to-be-added)))))))))
	      ;; Forget any highlighting in strings that get touched.
	      (setf (displayed-strings-array-region-strings displayed-strings)
		    (delete displayed-string
			    (displayed-strings-array-region-strings displayed-strings))))
	    (loop for new being the array-elements of strings-to-be-added do
	      (add-to-coordinate-sorted-set new displayed-strings))))
	;; Finally any graphics.  If touched at all, they are completely forgotten.
	(do-overlapping-boxes (graphics-presentation (displayed-graphics array) box index)
	  (setf (aref array index) nil))))))

(defmethod (:clear-region dynamic-window) (left top right bottom)
  (unless (zerop (tv:sheet-exceptions))
    (cond ((tv:sheet-truncate-output-p)
	   (when (not (zerop (tv:sheet-output-hold-flag)))
	     (send self :output-hold-exception)))
	  (t
	   (send self :handle-exceptions))))	;Make position visible
  (when output-recording-enabled
    (send self :note-region-clobbered left top right bottom))
  ;; Do the actual erase on the visible part of the screen
  (flet ((erase-internal (left top right bottom)
	   (coordinate-convert-points self :relative :inside left top right bottom)
	   (letf ((coordinate-transformation-enabled nil)
		  (output-recording-enabled nil))
	     (multiple-value-bind (width height)
		 (send self :inside-size)
	       (let ((erase-left (if (or (null left) (minusp left)) 0 left))
		     (erase-top (if (or (null top) (minusp top)) 0 top))
		     (erase-right (if (or (null right) (> right width)) width right))
		     (erase-bottom (if (or (null bottom) (> bottom height)) height bottom)))
		 (send self :draw-rectangle
		       (- erase-right erase-left) (- erase-bottom erase-top)
		       erase-left erase-top :erase))))))
    (cond ((and secondary-viewport top bottom
		(box-contains-point-p secondary-viewport (or left 0) top)
		(not (box-contains-point-p secondary-viewport (or right 0) bottom)))
	   (erase-internal left top right (1- (box-bottom secondary-viewport)))
	   (erase-internal left (box-top cursor-viewport) right bottom))
	  (t
	   (erase-internal left top right bottom))))
  (when (send self :still-the-mouse-window)
    (mouse-wakeup (tv:sheet-mouse self) t)))

(defmethod (:clear-between-cursorposes dynamic-window) (start-x start-y end-x end-y
							&optional (unit :pixel))
  (ecase unit
    (:pixel)
    (:character
      (setq start-x (* start-x tv:char-width)
	    start-y (* start-y tv:line-height))
      (setq end-x (* end-x tv:char-width)
	    end-y (* end-y tv:line-height))))
  (if (= start-y end-y)
      (send self :clear-region start-x start-y end-x (+ end-y tv:line-height))
    ;; Rest of current line
    (send self :clear-region start-x start-y nil (+ start-y tv:line-height))
    ;; Start of finishing line
    (send self :clear-region nil end-y end-x (+ end-y tv:line-height))
    (let ((next-line (+ start-y tv:line-height)))
      (unless (= next-line end-y)
	(send self :clear-region nil next-line nil end-y)))))

(defun-in-flavor (clear-rest-of-region-cursor-check dynamic-window) ()
  (declare (values noop-p x y))
  (multiple-value-bind (x y)
      (send self :read-cursorpos)
    (values (macrolet ((check-one (array)
			 `(let ((length (fill-pointer ,array)))
			    (or (zerop length)
				(multiple-value-bind (lleft ltop lright lbottom)
				    (box-edges
				      (presentation-displayed-box (aref ,array (1- length))))
				  (ignore lleft)
				  (or ( y lbottom) (and (= y ltop) ( x lright))))))))
	      (and (eq output-recording-enabled t)
		   (or (null cursor-viewport)
		       (and (check-one displayed-strings)
			    (check-one displayed-graphics)))))
	    x y)))

(defmethod (:clear-rest-of-line dynamic-window) ()
  ;; Do this before picking up the cursor position in case exceptions move it.
  (unless (or (zerop (tv:sheet-exceptions))
	      (tv:sheet-truncate-output-p))
    (send self :handle-exceptions))
  (when (and secondary-viewport
	     (not (viewport-separator-displayed secondary-viewport)))
    (send self :move-secondary-viewport-boundary))
  (multiple-value-bind (past-p x y)
      (clear-rest-of-region-cursor-check)
    (unless past-p
      (send self :clear-region x y nil (+ y tv:current-line-height)))))

(defmethod (:clear-rest-of-window dynamic-window) ()
  (unless (or (zerop (tv:sheet-exceptions))
	      (tv:sheet-truncate-output-p))
    (send self :handle-exceptions))
  (multiple-value-bind (past-p x y)
      (clear-rest-of-region-cursor-check)
    (unless past-p
      (send self :clear-region x y nil (+ y tv:current-line-height))
      (send self :clear-region nil (+ y tv:current-line-height) nil nil))))

(defmethod (:clear-char dynamic-window) (&optional char)
  (multiple-value-bind (past-p x y)
      (clear-rest-of-region-cursor-check)
    (unless past-p
      (send self :clear-region x y
	    (+ x (if char
		     (send self :character-width-in-font char)
		     tv:char-width))
	    (+ y tv:current-line-height)))))

(defmethod (:insert-line dynamic-window) (&optional (line-count 1) (unit :character))
  (ecase unit
    (:character (setq line-count (if ( line-count 0)
				     0
				     (+ (* (1- line-count) tv:line-height)
					tv:current-line-height))))
    (:pixel ))
  (multiple-value-bind (nil y)
      (send self :read-cursorpos)
    (send self :move-region (max (tv:sheet-inside-width) maximum-x-position)
			    (max (tv:sheet-inside-height) maximum-y-position)
			    0 y 0 (+ y line-count))))

(defmethod (:delete-line dynamic-window) (&optional (line-count 1) (unit :character))
  (ecase unit
    (:character (setq line-count (if ( line-count 0)
				     0
				     (+ (* (1- line-count) tv:line-height)
					tv:current-line-height))))
    (:pixel ))
  (multiple-value-bind (nil y)
      (send self :read-cursorpos)
    (send self :move-region (max (tv:sheet-inside-width) maximum-x-position)
			    (max (tv:sheet-inside-height) maximum-y-position)
			    0 (+ y line-count) 0 y)))

(defmethod (:insert-char dynamic-window) (&optional (char-count 1) (unit :character))
  (ecase unit
    (:character (setq char-count (* char-count tv:char-width)))
    (:pixel ))
  (multiple-value-bind (x y)
      (send self :read-cursorpos)
    (send self :move-region (max (tv:sheet-inside-width) maximum-x-position)
			    tv:current-line-height
			    x y (+ x char-count) y)))

(defmethod (:delete-char dynamic-window) (&optional (char-count 1) (unit :character))
  (ecase unit
    (:character (setq char-count (* char-count tv:char-width)))
    (:pixel ))
  (multiple-value-bind (x y)
      (send self :read-cursorpos)
    (send self :move-region (max (tv:sheet-inside-width) maximum-x-position)
			    tv:current-line-height
			    (+ x char-count) y x y)))

(defmethod (:move-region dynamic-window) (width height from-x from-y to-x to-y)
  (let ((x-for ( to-x from-x))
	(y-for ( to-y from-y)))
    (send self :bitblt-within-sheet tv:alu-seta
	  (if (and (= to-y from-y) x-for) (- width) width)
	  (if y-for (- height) height)
	  from-x from-y to-x to-y)
    (when output-recording-enabled
      (send self :note-box-shift (make-temporary-box to-x to-y (+ to-x width) (+ to-y height))
	    (- to-x from-x) (- to-y from-y)))
    ;; Tall skinny erase
    (let ((left (if x-for from-x (max from-x (+ to-x width))))
	  (top from-y)
	  (right (if x-for (min to-x (+ from-x width)) (+ from-x width)))
	  (bottom (+ from-y height)))
      ;; Bitblt in from "off screen"
      (unless x-for
	(send self :redraw-inside-sets (make-temporary-box (- (box-right cursor-viewport)
							      (- from-x to-x))
							   top
							   (box-right cursor-viewport)
							   bottom)))
      (when (> right left)
	(send self :clear-region left top right bottom)))
    ;; Short fat erase
    (let ((left (if x-for (min to-x (+ from-x width)) from-x))
	  (top (if y-for from-y (max from-y (+ to-y height))))
	  (right (if x-for (+ from-x width) (max from-x (+ to-x width))))
	  (bottom (if y-for (min to-y (+ from-y height)) (+ from-y height))))
      (when (> bottom top)
	(send self :clear-region left top right bottom)))))

;;; Coordinates can be NIL, meaning to the end in this direction
(defmethod (:map-over-overlapping-presentations dynamic-window)
	   (left top right bottom function
	    &key (presentations t) (strings nil) (graphics nil))
  (labels ((index-range (array window-start-index)
	     (declare (values start-index end-index))
	     (let ((start-index (cond ((null top) 0)
				      (( top (box-top cursor-viewport))
				       (top-displayable-index array top
							      :start window-start-index))
				      (t (top-displayable-index array top)))))
	       (values start-index
		       (if bottom
			   (bottom-displayable-index array bottom :start start-index)
			   (fill-pointer array)))))
	   (do-array (array start-index end-index)
	     (loop for object being the array-elements of array
		       from start-index below end-index do
	       (do-one object)))
	   (do-one (object)
	     (let ((box (presentation-displayed-box object)))
	       (when (box-overlaps-region-p box left top right bottom)
		 (funcall function object)))))
    (macrolet ((do-set (array)
		 (multiple-value-bind (array-start-idx array-end-idx)
		     (viewport-displayed-array-index-names array)
		   `(let ((array ,array))
		      (declare (array-register array))
		      (multiple-value-bind (start-index end-index)
			  (index-range array ,array-start-idx)
			(do-array array start-index end-index))))))
      (when presentations
	(do-set displayed-presentations)
	(when current-output-displayed-presentation
	  (do-one current-output-displayed-presentation)))
      (when strings
	(do-set displayed-strings)
	(when current-output-displayed-string
	  (do-one current-output-displayed-string)))
      (when graphics
	(do-set displayed-graphics)))))

;; Return all presentations of type D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")presentation-type0 in the rectangle bounded by
;; 1left0, 1top0, 1right0, and 1bottom0.
(defun presentations-of-type-in-region (presentation-type window left top right bottom
					&key (sort t))
  (let ((presentations nil))
    (labels ((collect (presentation)
	       (when (and (ptypep (presentation-object presentation) presentation-type)
			  (box-overlaps-region-p
			    (presentation-displayed-box presentation)
			    left top right bottom))
		 (pushnew presentation presentations))
	       (map nil #'collect (presentation-inferiors presentation))))
      (send window :map-over-overlapping-presentations
		   left top right bottom #'collect)
      (when (and presentations sort)
	(setq presentations (sort-presentations-by-position presentations)))
      presentations)))

;; Presentations at the upper-left come before ones at the lower-right.
(defun sort-presentations-by-position (presentations)
  (sort presentations
	#'(lambda (p1 p2)
	    (box-position-lessp (presentation-displayed-box p1)
				(presentation-displayed-box p2)))))

(defmethod (:clear-history dynamic-window) (&rest args)
  (declare (arglist &key (refresh t) &allow-other-keys))
  ;; damn, in 7.0 this function took two optional arguments which it ignored
  ;; now in 7.2 we must detect this obsolete calling sequence.
  ;; I suppose this test could be (keywordp (first args)) ??
  (let* ((even-#-of-args-p (and args (evenp (length args))))
	 (refresh t))
    (when even-#-of-args-p
      (setq refresh (getf args :refresh t)))
    (when cursor-viewport				;If used before
      (tv:lock-sheet (self)
	(clear-coordinate-sorted-set displayed-presentations)
	(clear-coordinate-sorted-set displayed-graphics)
	(clear-coordinate-sorted-set displayed-strings)
	(setf (displayed-strings-array-region-strings displayed-strings) nil)
	(setq current-output-displayed-string nil)
	(setq current-output-displayed-presentation nil)
	(setq last-highlighted-presentation nil)
	(set-box-position cursor-viewport 0 0)
	(send self :close-secondary-viewport nil)
	(setq maximum-y-position 0
	      maximum-x-position 0
	      last-typein-y 0)
	(setq viewport-displayed-presentations-start-index 0
	      viewport-displayed-presentations-end-index nil
	      viewport-displayed-strings-start-index 0
	      viewport-displayed-strings-end-index nil
	      viewport-displayed-graphics-start-index 0
	      viewport-displayed-graphics-end-index nil)))
    (send self :home-cursor)
    (tv:sheet-force-access (self :no-prepare)
      (when refresh
	;; Do this even if we don't appear to be in the input editor, so that if we get
	;; cleared from another process, we refresh synchronously in the correct place.
	(setq si:buffer-x 0
	      si:buffer-y 0
	      si:prompt-x 0
	      si:prompt-y 0
	      input-editor-initial-x 0
	      input-editor-initial-y 0)
	(send self :refresh)
	(send self :adjust-cursor-position-and-visibility 0 0)
	(when (and rubout-handler (eq self si:*input-editor-stream*))
	  (send self :refresh-rubout-handler :refresh)))))
  (values))

(defmethod (:compress-output-history dynamic-window) (&key (marked-text :keep)
							   (keep-screenfuls 0)
							   (keep-all-text nil))
 (tv:lock-sheet (self)
  (send self :close-secondary-viewport nil)
  (send self :close-current-output-displayed-string)
  (when (and marked-text
	     (null (displayed-strings-array-region-strings displayed-strings)))
    (case marked-text
      (:keep (setq marked-text nil))
      (:clear (return-from :compress-output-history))))
  (when (and (null marked-text)
	     (zerop keep-screenfuls)
	     (null keep-all-text))
    ;; Fast case of getting rid of everything.
    (return-from :compress-output-history
      (send self :clear-history t)))
  (labels ((combine-ranges (ranges threshold)
	     (setq ranges (sort ranges #'< :key #'first))
	     (let ((prev-range nil))
	       (loop for sublist on ranges as range = (car sublist) do
		 (when (and prev-range
			    ( (+ (second prev-range) threshold) (first range)))
		   (setf (second prev-range) (second range))
		   (setf (car sublist) 'nil))))
	     (delete 'nil ranges))
	   (keep-within-region (set ranges)
	     (if (null ranges)
		 (clear-coordinate-sorted-set set)
		 (let ((write-index 0)
		       (tallest-box 0))
		   (dotimes (read-index (fill-pointer set))
		     (let* ((object (aref set read-index))
			    (box (presentation-displayed-box object))
			    (keep nil))
		       (dolist (range ranges)
			 (when (destructuring-bind (top bottom) range
				 (box-overlaps-region-p box nil top nil bottom))
			   (minf (first range) (box-top box))
			   (maxf (second range) (box-bottom box))
			   (setq keep t)))
		       (when keep
			 (maxf tallest-box (box-height box))
			 (unless (= read-index write-index)
			   (setf (aref set write-index) object))
			 (incf write-index))))
		   (setf (fill-pointer set) write-index)
		   (setf (coordinate-sorted-set-tallest-box-height set) tallest-box)))
	     set)
	   (compress-regions (set ranges tops adjust-p)
	     (dotimes (index (fill-pointer set))
	       (let ((box (presentation-displayed-box (aref set index))))
		 ;; Could optimize this by walking in parallel, but that's error prone,
		 ;; especially with odd shaped boxes.
		 (loop for range in ranges
		       for ntop in tops
		       do
		   (destructuring-bind (top bottom) range
		     (when (box-overlaps-region-p box nil top nil bottom)
		       (set-box-position box (box-left box)
					 (+ (box-top box) (- ntop top)))
		       (when adjust-p
			 (presentation-adjust-for-box-move (aref set index) 0 (- ntop top)))
		       (return))))))))
    (let ((y-ranges-to-keep nil)
	  (present-y (multiple-value-bind (nil y) (send self :read-cursorpos) y))
	  (present-top (box-top cursor-viewport))
	  (present-max-y maximum-y-position))
      ;; Keep last n screenfuls, add region at the end of the history.
      (when (plusp keep-screenfuls)
	(push (list (max minimum-y-position
			 (- maximum-y-position (* keep-screenfuls (viewport-integral-height))))
		    maximum-y-position)
	      y-ranges-to-keep))
      ;; Keeping text, add region for each marked line.
      (when marked-text
	(ecase marked-text
	  (:keep
	    (dolist (displayed-string (displayed-strings-array-region-strings
					displayed-strings))
	      (multiple-value-bind (nil top nil bottom)
		  (box-edges (presentation-displayed-box displayed-string))
		(push (list top bottom) y-ranges-to-keep))))
	  (:clear
	    (loop for prev = minimum-y-position then bottom
		  for displayed-string in (sort (copy-seq
						  (displayed-strings-array-region-strings
						    displayed-strings))
						#'displayed-string-precedes)
		  with (top bottom)
		  do (multiple-value-setq (nil top nil bottom)
		       (box-edges (presentation-displayed-box displayed-string)))
		     (push (list prev top) y-ranges-to-keep)
		  finally (push (list prev maximum-y-position) y-ranges-to-keep))))
	(send self :clear-region-strings))	;Good idea?
      ;; Include whitespace of up to a few lines.
      (setq y-ranges-to-keep (combine-ranges y-ranges-to-keep
					     (* *maximum-number-of-yanked-blank-lines*
						tv:line-height)))
      ;; Flush the displayed presentations outside the regions.
      (keep-within-region displayed-presentations y-ranges-to-keep)
      (keep-within-region displayed-graphics y-ranges-to-keep)
      (when (not keep-all-text)
	;; If flushing strings, do the same.  Note that there are no pointers from the
	;; displayed strings to the displayed presentations, so we don't need to worry about
	;; clearing anything for presentations that went away.
	(keep-within-region displayed-strings y-ranges-to-keep))
      ;; If any large presentations increased things to now overlap, combine them.
      (setq y-ranges-to-keep (combine-ranges y-ranges-to-keep 0))
      (let ((new-range-tops (loop for (top bottom) in y-ranges-to-keep
				  collect running-total
				  sum (- bottom top) into running-total)))
	(compress-regions displayed-strings y-ranges-to-keep new-range-tops nil)
	(compress-regions displayed-graphics y-ranges-to-keep new-range-tops t))
      (labels ((adjust-one (object)
		 (setf (displayed-presentation-displayed-box-valid object) nil)
		 (if (typep object 'text-displayed-presentation)
		     (let ((box (presentation-displayed-box object))
			   (sbox (presentation-displayed-box
				   (text-displayed-presentation-displayed-string
				     object))))
		       (set-box-edges box (box-left box) (box-top sbox)
				      (box-right box) (box-bottom sbox)))
		     (map () #'adjust-one (presentation-inferiors object))))
	       (adjust-top (object)
		 (adjust-one object)
		 (update-displayed-presentation-box object)))
	(map () #'adjust-top displayed-presentations))
      (setq minimum-y-position 0)
      (note-end-of-viewport-clobbered t)
      (send self :update-viewport-indices)
      (send self :new-scroll-position)
      (tv:sheet-force-access (self :no-prepare)
	(let ((total-delta-y (- maximum-y-position present-max-y)))
	  (set-box-position cursor-viewport (box-left cursor-viewport)
			    (max 0 (+ present-top total-delta-y)))
	  (send self :set-cursorpos nil (max 0 (+ present-y total-delta-y))))
	(send self :redraw-inside-sets))
      nil))))

(defmethod (:output-history-as-bitmap dynamic-window) ()
  (multiple-value-bind (raster left top right bottom)
      (tv:with-output-to-bitmap (stream :for-stream self)
	(send stream :assure-room-for-output 0 0 1 1)	;Make sure corner visible
	(let ((box (make-temporary-box 0 0 maximum-x-position maximum-y-position)))
	  (redraw-displayed-set displayed-strings stream 0 nil box)
	  (when current-output-displayed-string
	    (redraw-displayed-presentation current-output-displayed-string stream  box))
	  (with-stack-array (presentations (* (fill-pointer displayed-graphics) 2)
					   :fill-pointer 0)
	    (loop for object being the array-elements of displayed-graphics do
	      (vector-push-extend (graphics-displayed-presentation-priority object)
				  presentations)
	      (vector-push-extend object presentations))
	    (when (plusp (fill-pointer presentations))
	      (sort-grouped-array presentations 2 #'<)
	      (loop for index below (fill-pointer presentations) by 2 do
		(redraw-displayed-presentation (aref presentations (1+ index)) stream box))))))
    (values raster (- right left) (- bottom top))))

;;; Note that this does not move presentations.  That is handled by redisplay itself.
(defmethod (:note-box-shift dynamic-window) (destination-box delta-x delta-y
					     &optional mark-table protected-boxes
						       protected-presentations)
  (multiple-value-bind (destination-left destination-top destination-right destination-bottom)
      (box-edges destination-box)
    (let ((clobbered-left destination-left)
	  (clobbered-top destination-top)
	  (clobbered-right destination-right)
	  (clobbered-bottom destination-bottom))
      ;; The area that will be clobbered is the area in the destination that doesn't come
      ;; from the source.
      (cond ((zerop delta-x))
	    ((minusp delta-x)			;Moving left
	     (setq clobbered-right (min clobbered-right (- clobbered-left delta-x))))
	    (t
	     (setq clobbered-left (max clobbered-left (- clobbered-right delta-x)))))
      (cond ((zerop delta-y))
	    ((minusp delta-y)			;Moving up
	     (setq clobbered-bottom (min clobbered-bottom (- clobbered-top delta-y))))
	    (t
	     (setq clobbered-top (max clobbered-top (- clobbered-bottom delta-y)))))
      (if protected-boxes
	  (dolist (box (box-set-difference
			 (list (make-temporary-box clobbered-left clobbered-top
						   clobbered-right clobbered-bottom))
			 protected-boxes))
	    (multiple-value-call #'send self :note-region-clobbered (box-edges box)
				 protected-presentations))
	  (send self :note-region-clobbered clobbered-left clobbered-top
					    clobbered-right clobbered-bottom
					    protected-presentations)))
    (let ((source-left (- destination-left delta-x))
	  (source-top (- destination-top delta-y))
	  (source-right (- destination-right delta-x))
	  (source-bottom (- destination-bottom delta-y)))
      (flet ((move-boxes (array adjust-p)
	       (let (start-index new-start-index end-index new-end-index)
		 (if (< source-top destination-top)
		     (setq start-index (top-displayable-index array source-top)
			   new-start-index (top-displayable-index array destination-top
								  :start start-index))
		     (setq new-start-index (top-displayable-index array destination-top)
			   start-index (top-displayable-index array source-top
							      :start new-start-index)))
		 (if (< source-bottom destination-bottom)
		     (setq end-index (bottom-displayable-index array source-bottom
							       :start start-index)
			   new-end-index (bottom-displayable-index array destination-bottom
								   :start end-index))
		     (setq new-end-index (bottom-displayable-index array destination-bottom
								   :start new-start-index)
			   end-index (bottom-displayable-index array source-bottom
							       :start new-end-index)))
		 (loop for object being the array-elements of array
			   from start-index below end-index do
		   (let ((box (presentation-displayed-box object)))
		     (when (and (box-overlaps-region-p box source-left source-top
							   source-right source-bottom)
				(cond ((null mark-table) t)
				      ((gethash box mark-table) nil)
				      (t (setf (gethash box mark-table) t) t)))
		       (set-box-edges box
				      (+ (box-left box) delta-x)
				      (+ (box-top box) delta-y)
				      (+ (box-right box) delta-x)
				      (+ (box-bottom box) delta-y))
		       (when adjust-p
			 (presentation-adjust-for-box-move object delta-x delta-y)))))
		 (sort-coordinate-sorted-set array
					     :start (min start-index new-start-index)
					     :end (max end-index new-end-index)))))
	(move-boxes displayed-strings nil)
	(move-boxes displayed-graphics t)))))

(defmethod (:viewport-position dynamic-window) ()
  (box-position cursor-viewport))

;;; Used while without-interrupts inside of (:set-viewport-position dynamic-window)
;;; This avoids consing in *box-area*, which is not ephemeral
(defvar *temporary-viewport* (make-instance 'viewport))

;;; Scrolling primitive
(defmethod (:set-viewport-position dynamic-window) (new-left new-top)
  (tv:prepare-sheet (self)
    (send self :close-secondary-viewport)
    (when (null new-left)
      (setq new-left (box-left cursor-viewport)))
    (when (null new-top)
      (setq new-top (box-top cursor-viewport)))
    (setq new-left (max 0 (min maximum-x-position new-left))
	  new-top (max 0 (min maximum-y-position new-top)))
    ;; Save cursor position before bashing cursor-viewport
    (multiple-value-bind (x y) (send self :read-cursorpos)
      (let ((new-viewport cursor-viewport)
	    (old-viewport *temporary-viewport*))
	;; Set the cursor-viewport to the new position and set the
	;; old-viewport to the former position of the cursor-viewport
	(%multiple-value-call-n set-box-edges old-viewport 1 (box-edges new-viewport) 4)
	(set-box-edges new-viewport new-left new-top (+ new-left (tv:sheet-inside-width))
				    (+ new-top (viewport-integral-height)))
	;; Set the range for mouse sensitivity searches and redisplay
	(let ((forward-p (> (box-top new-viewport) (box-top old-viewport))))
	  (macrolet ((update-indices (array)
		       (multiple-value-bind (start-index end-index)
			   (viewport-displayed-array-index-names array)
			 `(multiple-value-setq (,start-index ,end-index)
			    (send self :inside-set-search-range ,array new-viewport
				  (if forward-p (min (fill-pointer ,array) ,start-index) 0)
				  nil x y)))))
	    (update-indices displayed-presentations)
	    (update-indices displayed-strings)
	    (update-indices displayed-graphics)))
	;;+++ Should set MAXIMUM-X-POSITION according to subset of boxes overlapping in Y.
	;; (Requires faster box stuff.)
	(cond ((not (boxes-overlap-p old-viewport new-viewport))
	       ;; Complete redisplay if no overlap of old bits.
	       (send self :redraw-inside-sets))
	      (t
	       (multiple-value-bind (tall-skinny-box short-fat-box)
		   (letf ((coordinate-transformation-enabled nil)
			  (output-recording-enabled nil))
		     (shift-viewport-box old-viewport new-viewport self nil))
		 (flet ((redraw-in-box (box)
			  (when box
			    (multiple-value-bind (x y)
				(box-position box)
			      (set-box-position box (+ x new-left) (+ y new-top)))
			    (send self :redraw-inside-sets box))))
		   (redraw-in-box tall-skinny-box)
		   (redraw-in-box short-fat-box)))))
	(let ((window-bottom (or original-bottom-margin tv:bottom-margin-size))
	      (viewport-bottom (with-integral-bottom-margin tv:bottom-margin-size)))
	  (unless (= window-bottom viewport-bottom)
	    (tv:prepare-sheet (self)
	      (tv:sheet-draw-rectangle (tv:sheet-inside-width)
				       (- viewport-bottom window-bottom)
				       (tv:sheet-inside-left) (- tv:height viewport-bottom)
				       tv:erase-aluf))))
	(multiple-value-bind (delta-x delta-y)
	    (box-position-deltas new-viewport old-viewport)
	  (send self :adjust-cursor-position-and-visibility (- delta-x) (- delta-y) t))
	(when (and rubout-handler (eq self si:*input-editor-stream*))
	  (when (not (box-contains-point-p old-viewport
					   input-editor-initial-x input-editor-initial-y))
	    (send self :refresh-rubout-handler-buffer-if-visible)))
	(when current-more-position
	  (when (and (not (box-contains-point-p old-viewport 0 current-more-position))
		     (box-contains-point-p cursor-viewport 0 current-more-position))
	    (send self :refresh-more-prompt)))))))

(defmethod (:refresh-rubout-handler-buffer-if-visible dynamic-window) ()
  (when (and (variable-boundp si:input-editor-buffer)
	     (or (box-contains-point-p cursor-viewport
				       input-editor-initial-x input-editor-initial-y)
		 (and secondary-viewport
		      (box-contains-point-p secondary-viewport
					    input-editor-initial-x input-editor-initial-y))))
    (send self :set-cursorpos si:buffer-x si:buffer-y)
    ;; If the history has been cleared completely, redraw the prompt too.
    ;; Flagged by same position for start and end of prompt.  This is also true when
    ;; there is no prompt, in which case refreshing is presumably harmless.
    (when (and (= si:buffer-x si:prompt-x) (= si:buffer-y si:prompt-y)
	       (si:input-editor-option :prompt))
      (si:display-prompt-option self
			   (si:input-editor-option :prompt)
			   nil :refresh)
      (multiple-value-setq (si:buffer-x si:buffer-y)
	(send self :read-cursorpos)))
    (si:input-editor-string-out)
    (si:input-editor-refresh self)))

(defmethod (:new-scroll-position dynamic-window :after) (&rest ignore)
  (when (send self :still-the-mouse-window)
    (mouse-wakeup (tv:sheet-mouse self) t)))

(defmethod (:adjust-cursor-position-and-visibility dynamic-window) (delta-x delta-y
								    &optional set-exception)
  (send self :new-scroll-position)
  (tv:prepare-sheet (self)
    (incf tv:cursor-x delta-x)
    (incf tv:cursor-y delta-y)
    (multiple-value-bind (x y)
	(send self :read-cursorpos)
      (when (minusp x)
	(decf tv:cursor-x x)
	(setq x 0))
      (when (minusp y)
	(decf tv:cursor-y y)
	(setq y 0))
      (let ((invisible (and (not (box-contains-point-p cursor-viewport x y))
			    (or (eq output-recording-enabled t)
				(null secondary-viewport)
				(not (box-contains-point-p secondary-viewport x y))))))
	(setf (tv:sheet-end-page-flag)
	      (if (or ;; If the cursor goes off the screen because of explicit scrolling,
		      ;; or output in truncate mode, set exception against additional output.
		      ;; Also if already set, don't clear it accidentally.
		      (and invisible
			   (or set-exception (tv:sheet-truncate-output-p self)
			       (not (zerop (tv:sheet-end-page-flag)))))
		      ;; Also do the window system's test to make sure wrap mode happens.
		      tv:(> (+ cursor-y current-line-height) (sheet-inside-bottom)))
		  1 0))
	(let ((blinker (dolist (blinker tv:blinker-list)
			 (when (send blinker :follow-p)
			   (return blinker)))))
	  (when blinker
	    (send blinker :set-visibility (cond (invisible nil)
						((eq self (sys:console-selected-window
							    (tv:sheet-console self)))
						 :blink)
						(t (tv:blinker-deselected-visibility blinker))
						))))
	(when (not invisible)
	  (setq viewport-displayed-strings-end-index nil
		viewport-displayed-graphics-end-index nil
		viewport-displayed-presentations-end-index nil))))))

(defmethod (:update-viewport-indices dynamic-window) ()
  (macrolet ((update-indices (array)
	       (multiple-value-bind (start-index end-index)
		   (viewport-displayed-array-index-names array)
		 `(multiple-value-setq (,start-index ,end-index)
		    (send self :inside-set-search-range ,array)))))
    (update-indices displayed-presentations)
    (update-indices displayed-strings)
    (update-indices displayed-graphics)))

(defmethod (:inside-set-search-range dynamic-window)
	   (array &optional (new-viewport cursor-viewport) (start-index 0) end-index x y)
  (unless y
    (multiple-value-setq (x y) (send self :read-cursorpos)))
  (let ((start (top-displayable-index array (box-top new-viewport)
				      :start start-index :end end-index)))
    (values start
	    (if (box-contains-point-p new-viewport x y)
		;; Might do some output soon, always check to the end
		nil
		;; Cannot draw at this point, can restrict end too
		(bottom-displayable-index array (box-bottom new-viewport)
					  :start start)))))

;;; Assume this means scroll everything away.  To really clear, use :CLEAR-HISTORY.
(defmethod (:clear-window dynamic-window) (&optional (margins-p nil))
  (ignore margins-p)
  (setq tv:more-vpos (and tv:more-vpos 99999))
  (send self :fresh-line)
  (multiple-value-bind (x y)
      (send self :read-cursorpos)
    (setq y (max maximum-y-position y))
    (setq maximum-y-position y)
    (send self :set-cursorpos x y))
  (send self :set-viewport-position nil maximum-y-position)
  (when tv:more-vpos
    (setq tv:more-vpos (tv:sheet-deduce-more-vpos))))

(defun copy-presentations-in-region (from-dynamic-window to-dynamic-window
				     ;; These from- edges can be NIL, which is why
				     ;; they are not boxed.
				     &key from-left from-top from-right from-bottom
				     clear-history-first set-cursor-boundaries-after
				     set-viewport-y)
  (when clear-history-first (send to-dynamic-window :clear-history))
  (let ((bounding-box nil))
    (flet ((copy-them (from-seq to-seq)
	     (setf (fill-pointer to-seq) 0)
	     (map nil
		  (lambda (x)
		    (let ((box (presentation-displayed-box x)))
		      (when (box-contained-in-region-p box from-left from-top
						       from-right from-bottom)
			(vector-push-extend x to-seq)
			(setq bounding-box (augment-bounding-box box bounding-box)))))
		  from-seq)))
      (copy-them (send from-dynamic-window :displayed-presentations)
		 (send to-dynamic-window :displayed-presentations))
      (copy-them (send from-dynamic-window :displayed-strings)
		 (send to-dynamic-window :displayed-strings))
      (copy-them (send from-dynamic-window :displayed-graphics)
		 (send to-dynamic-window :displayed-graphics)))
    (multiple-value-bind (top bottom)
	(if bounding-box
	    (values (box-top bounding-box) (box-bottom bounding-box))
	    (values 0 0))
      (when set-cursor-boundaries-after
	(zl:set-in-instance to-dynamic-window 'minimum-y-position top)
	(zl:set-in-instance to-dynamic-window 'maximum-y-position bottom))
      (send to-dynamic-window :set-viewport-position
	    0
	    (if set-viewport-y
		(max top (min bottom set-viewport-y))
	    top)))))

(defmethod (:notice dynamic-window :or) (event &rest ignore)
  (when (eq event :input-wait)
    ;; Pieces copied from (:METHOD SHEET :NOTICE); seems that many things are being done
    ;; by this one message here.
    (when (and (not tv:exposed-p)
	       (not (zerop (tv:sheet-deexposed-typein-notify))))
      (send self :notice :input))
    (maybe-wait-for-cursor-visible)
    (send self :notice-input-wait-internal)
    t))

(defmethod (:notice-input-wait-internal dynamic-window) ()
  (setf (tv:sheet-more-flag) 0)
  (multiple-value-setq (nil last-typein-y)
    (send self :read-cursorpos))
  (when (and tv:more-vpos cursor-viewport)
    (case (send self :defaulted-end-of-page-mode) 
      (:wrap
	;; Don't more until wrap around here again.
	(setq tv:more-vpos (with-integral-bottom-margin
			     (if (< (* (- (tv:sheet-inside-bottom)
					  tv:cursor-y)
				       4)	;More than 3/4 way down window?
				    (tv:sheet-inside-height))
				 ;; Wrap around and more just before the current line
				 (+ #o100000 (- tv:cursor-y tv:line-height))
				 (tv:sheet-deduce-more-vpos)))))
      (:scroll
	;; Don't more until glitch.
	(unless (= last-typein-y (box-top cursor-viewport))
	  (setq tv:more-vpos 99999))
	))))

(defwhopper (:more-exception dynamic-window) ()
  (unless (zerop (tv:sheet-more-flag))
    (multiple-value-prog1
      (letf ((output-recording-enabled nil))
	(if (null *presentation-input-context*)
	    (unwind-protect
		(let ((*presentation-input-context* *presentation-more-break-input-context*))
		  (continue-whopper))
	      (note-presentation-input-context-change))
	    (continue-whopper)))
      (letf ((tv:more-vpos tv:more-vpos))
	(send self :notice-input-wait-internal)))))

(defmethod (:more-exception dynamic-window) ()
  (unless (zerop (tv:sheet-more-flag))
    (multiple-value-bind (nil y)
	(send self :read-cursorpos)
      (let-globally ((current-more-position y))
	(tv:sheet-more-handler :more-tyi)))))

(defmethod (:refresh-more-prompt dynamic-window) ()
  (send self :set-cursorpos 0 current-more-position)
  (send self :clear-rest-of-line)
  (send self :string-out "**MORE**"))

(defmethod (:more-tyi dynamic-window) ()
  (unwind-protect-case ()
      (loop as character = (sys:read-character self :notification nil :refresh nil
						    :presentation-context t)
	    while (null (intercept-scroll-key self character))
	    finally (setq current-more-position nil)
		    (return character))
    (:abort
      (let ((epf (tv:sheet-end-page-flag)))
	(setf (tv:sheet-end-page-flag) 0)
	(send self ':string-out "**FLUSHED**")
	(setf (tv:sheet-end-page-flag) epf)))))

;;; Returns the character normally, but NIL if it has been intercepted
(defun intercept-scroll-key (window character)
  (cond ((member character '(#\Scroll #\Control-Scroll #\Meta-Scroll #\Control-Meta-Scroll
			     #\Super-Scroll #\Super-Meta-Scroll
			     #\Keyboard:Back-Scroll #\Control-Keyboard:Back-Scroll
			     #\Super-Keyboard:Back-Scroll))
	 (multiple-value-bind (x y)
	     (case character
	       ((#\Scroll #\Control-Scroll) (values 0 1))
	       ((#\Meta-Scroll #\Control-Meta-Scroll
		 #\Keyboard:Back-Scroll #\Control-Keyboard:Back-Scroll) (values 0 -1))
	       (#\Super-Scroll (values 1 0))
	       ((#\Super-Meta-Scroll #\Super-Keyboard:Back-Scroll) (values -1 0)))
	   (do-pending-scroll window x y)
	   nil))
	((member character '(#\Keyboard:Cut #\Keyboard:Copy))
	 (send-if-handles window :console-cut/copy (char= character #\Keyboard:Cut))
	 nil)
	(t
	 character)))

(defmethod (:set-more-p dynamic-window :after) (ignore)
  (when (and (eq (send self :defaulted-end-of-page-mode) :scroll)
	     tv:more-vpos cursor-viewport
	     ( last-typein-y (box-top cursor-viewport)))
    ;; Delay the effect until after the next scroll.
    (setq tv:more-vpos 99999)))

(defun-in-flavor (update-string-out-state dynamic-window) ()
  (destructuring-bind (displayed-string string start-index end-index start-x start-y)
      string-out-state
    (multiple-value-bind (x y)
	(send self :read-cursorpos)
      (multiple-value-bind (nil nil index)
	  (send self :compute-motion string start-index end-index
		start-x start-y nil x y nil 9999)
	(assert (not (null index)))
	(displayed-string-add-string displayed-string string start-index
				     index tv:current-style)
	(displayed-string-note-new-right displayed-string x)
	(setf (third string-out-state) index)))))

(defwhopper (:end-of-line-exception dynamic-window) ()
  (if (and (tv:sheet-truncate-output-p self :horizontal)
	   *truncate-output-catch*)
      (throw 'truncate-output t)
    (when (and secondary-viewport
	       (viewport-separator-displayed secondary-viewport))
      (send self :draw-viewport-separator-line secondary-viewport t))
    (let ((was-string (not (null current-output-displayed-string))))
      (when was-string
	(when string-out-state
	  (update-string-out-state))
	(send self :close-current-output-displayed-string))
      (continue-whopper)
      (when was-string
	(send self :check-current-output-displayed-string nil)
	(when string-out-state
	  (multiple-value-bind (x y)
	      (send self :read-cursorpos)
	    (setf (first string-out-state) current-output-displayed-string)
	    (setf (fifth string-out-state) x)
	    (setf (sixth string-out-state) y)))))))

(defwhopper (:end-of-page-exception dynamic-window) ()
  (when (and (or (tv:sheet-truncate-output-p self :vertical)
		 (and (tv:sheet-truncate-output-p self :horizontal)
		      (letf ((coordinate-transformation-enabled t))
			( (send self :read-cursorpos)
			   (box-right cursor-viewport)))))
	     *truncate-output-catch*)
    (throw 'truncate-output t))
  (ecase (send self :defaulted-end-of-page-mode)
    (:scroll
      (send self :scroll-for-end-of-page))
    (:wrap
      (if (and (null secondary-viewport)
	       (or (< (box-bottom cursor-viewport) maximum-y-position)
		   (minusp tv:cursor-y)))
	  ;; Exception because of scrolling
	  (send self :scroll-for-end-of-page)
	  ;; Exception because of real wrapping
	  (when (not (zerop (tv:sheet-end-page-flag)))
	    (multiple-value-bind (nil y)
		(letf ((coordinate-transformation-enabled t))
		  (send self :read-cursorpos))
	      (with-integral-bottom-margin
		(letf ((output-recording-enabled nil)
		       (tv:cursor-x tv:cursor-x))
		  (continue-whopper)))
	      ;; Cursor might have scrolled just past the bottom,
	      ;; in which case it isn't visible.
	      (send self :adjust-cursor-position-and-visibility 0 0)
	      (send self :open-secondary-viewport y)))))
    (:truncate
      ;; This odd case happens when the output catch was not in effect, or the truncate
      ;; flag failed to get set because it happened asynchronously.  Fix things up.
      ;; Do like scroll one time.
      (setf (tv:sheet-truncate-output-vertical-flag) 1)
      (send self :scroll-for-end-of-page))))

(defmethod (:scroll-to-visible-cursor dynamic-window) (&optional x-position y-position)
  (if (or x-position y-position)
      (multiple-value-bind (current-x current-y)
	  (send self :read-cursorpos)
	(unless (or (null cursor-viewport)
		    (box-contains-point-p cursor-viewport
					  (or x-position current-x) (or y-position current-y)))
	  (let ((new-scroll-x (if (or (null x-position)
				      (box-contains-point-p cursor-viewport
							    x-position current-y))
				  (box-left cursor-viewport)
				  (- (min (+ current-x (box-width cursor-viewport))
					  x-position)
				     (box-width cursor-viewport))))
		(new-scroll-y (if (or (null y-position)
				      (box-contains-point-p cursor-viewport
							    current-x y-position))
				  (box-top cursor-viewport)
				  (- (min (+ (- current-y tv:line-height)
					     (box-height cursor-viewport))
					  y-position)
				     (box-height cursor-viewport)))))
	    (send self :set-viewport-position new-scroll-x new-scroll-y))))
      (when (not (zerop (tv:sheet-end-page-flag)))
	(block handled
	  (truncate-output-catch
	    (send self :end-of-page-exception)
	    (return-from handled t))
	  ;; Scroll, even though we're in trucation mode.
	  (send self :scroll-for-end-of-page)))))

(defvar *last-ditch-scroll-debug-stream* nil
  "If nonnull, a stream to use for *DEBUG-IO* when :SCROLL-FOR-END-OF-PAGE can't clear 
TV:SHEET-END-PAGE-FLAG.  
If you provide a string, it will use the cold load stream instead.")
		 
;;; Competing constraints:
;;;  1. Put point in the window.
;;;  2. Don't move last **more** out of window before another **more**.
;;;  3. Keep a line boundary at the top of the screen.
(defmethod (:scroll-for-end-of-page dynamic-window) ()
  (flet ((x-to-desire (xpos)
	   ;; Move it to x=0 if that will work, else as little as possible.
	   (cond ((and ( 0 xpos) (< xpos (box-width cursor-viewport)))
		  0)
		 ((< xpos (box-left cursor-viewport))
		  xpos)
		 (t (+ (box-left cursor-viewport)
		       ;; 1+ to just get it inside the right edge
		       (1+ (- xpos (box-right cursor-viewport))))))))
    (loop for pass below 5
	  while (not (zerop (tv:sheet-end-page-flag)))
	  doing
      (multiple-value-bind (x-position y-position)
	  (send self :read-cursorpos)
	(setq maximum-y-position (max maximum-y-position y-position))
	(cond ((= pass 0)
	       ;; When the x,y cursorpos is outside the visible region,
	       ;; and ypos is inside, and we're not truncating horizontally,
	       ;; move the viewport sideways.
	       (when (and (not (box-contains-point-p cursor-viewport x-position y-position))
			  (box-contains-point-p cursor-viewport (box-left cursor-viewport)
						y-position)
			  (not (tv:sheet-truncate-output-p self :horizontal)))
		 (send self :set-viewport-position (x-to-desire x-position) nil)))
	      ((= pass 3)
	       (send self :set-viewport-position (x-to-desire x-position) maximum-y-position))
	      ((= pass 4)
	       (if (and (tv:sheet-truncate-output-p self)
			*truncate-output-catch*)
		   (throw 'truncate-output t)
		   (if *last-ditch-scroll-debug-stream*
		       ;; Really try hard not to erro
		       (let ((*debug-io* *last-ditch-scroll-debug-stream*))
			 (break "Last pass.  You'd better <resume> to :CLEAR-HISTORY")
			 (send self :clear-history))
		       (send self :clear-history))))
	      (t
	       ;; Scroll the screen the desired amount, rounding to a line boundary
	       (let ((arrange-to-more nil))
		 (let ((new-y (- maximum-y-position
				 (multiple-value-bind (nil defaulted-scroll-factor)
				     (send self :defaulted-end-of-page-mode)
				   (if (< defaulted-scroll-factor 1)
				       (round (* (box-height cursor-viewport)
						 (- 1 defaulted-scroll-factor)))
				       (- (box-height cursor-viewport)
					  (* defaulted-scroll-factor
					     tv:current-line-height)))))))
		   
		   (setq new-y (send self :viewport-integral-top new-y t))

		   ;; If moreing, don't scroll more than last typein.
		   (when (and (not (null tv:more-vpos))
			      tv:more-processing-truly-global-enable
			      tv:more-processing-global-enable
			      (or (not rubout-handler)
				  ;; This really means inside with-ie-typeout, for
				  ;; which there doesn't seem to be a special
				  ;; rubout-handler state.
				  output-recording-enabled)
			      ( last-typein-y (+ new-y (+ tv:line-height
							   tv:current-line-height))))
		     (setq arrange-to-more t)
		     #+ignore ;;maybe hiding a bug, but definitely causing bogosity -- Reti
		     (when (= pass 1)		;Probably hiding some bug someplace.
		       (setq new-y last-typein-y)))
		   
		   ;; Move the X too.
		   (send self :set-viewport-position (x-to-desire x-position) new-y))
		 (when tv:more-vpos
		   (setq tv:more-vpos (if arrange-to-more
					  (with-integral-bottom-margin
					    (tv:sheet-deduce-more-vpos))
					  999999))))))))))

;;; Try to align the top of the screen with the top of some existing box that
;;; contains the location requested as new-top.  This makes it look like we scroll by
;;; lines.  If GLITCHING-FORWARD, insist on forward progress.
;;; If scrolling-backwards, reverse the direction of round off.
(defmethod (:viewport-integral-top dynamic-window) (new-top
						    &optional (glitching-forward nil)
							      (scrolling-backwards nil))
  (setq new-top (max (min new-top maximum-y-position) 0))
  (when (plusp new-top)
    (let* ((index ;; Find the highest displayed-string that ends below where the
	          ;; the mouse is.  This is the one that we will want to have at the
	          ;; top of the viewport, because it lies over the mouse position, except
		  ;; when scrolling-backwards, we'll want the bottom of this at the top.
		  ;; ("top" = direction of decreasing Y coordinates)
	          (coordinate-sorted-set-index-for-position
		      displayed-strings (box-left cursor-viewport) (1+ new-top)
		      :start (if (> new-top (box-top cursor-viewport))
				 viewport-displayed-strings-start-index
				 0)))
	   (length (fill-pointer displayed-strings))
	   (bot-top (if (plusp length)
			(max (if current-output-displayed-string
				 (box-top (presentation-displayed-box
					    current-output-displayed-string))
				 0)
			     (box-top (presentation-displayed-box
					(aref displayed-strings (1- length)))))
			maximum-y-position))
	   (integral-new-top (cond (( index length)
				    bot-top)
				   (scrolling-backwards
				    (box-bottom (presentation-displayed-box
						  (aref displayed-strings index))))
				   (t
				    (let ((possible-y (box-top (presentation-displayed-box
								 (aref displayed-strings
								       index)))))
				      (if ( possible-y new-top)
					  possible-y
					  ;; This displayed-string starts below where the mouse
					  ;; is, so there must be blank space above it.  Try to
					  ;; position into that blank space, at what would be
					  ;; the top of a blank line if the blank space were
					  ;; constructed out of blank lines.
					  (max (- possible-y (* (ceiling (- possible-y new-top)
									 tv:line-height)
								tv:line-height))
					       ;; But if not an integer number of blank lines, 
					       ;; don't go above the top of the blank space.
					       (if (plusp index)
						   (box-bottom (presentation-displayed-box
								 (aref displayed-strings
								       (1- index))))
						   0))))))))
      (setq integral-new-top (min ;; Never scroll to complete invisibility, i.e. keep the
				  ;; bottommost box within the viewport
				  (if (> (abs (- bot-top maximum-y-position))
					 (+ tv:line-height tv:current-line-height))
				      maximum-y-position
				      bot-top)
				  ;; If too far from where requested, punt the attempt
				  ;; to make it look like we scroll by lines
				  (if (> (abs (- integral-new-top new-top))
					 (+ tv:line-height tv:current-line-height))
				      new-top integral-new-top)))      
      (cond ((not glitching-forward)
	     (setq new-top integral-new-top))
	    ((let ((delta-y (- integral-new-top (box-top cursor-viewport))))
	       (and (plusp delta-y)
		    (not (> (+ (- tv:cursor-y delta-y) tv:current-line-height)
			    (tv:sheet-inside-bottom)))))
	     (setq new-top integral-new-top))
	    ((> (box-top cursor-viewport) new-top)
	     (setq new-top (box-top cursor-viewport))))))
  new-top)
  
(defmethod (:y-scroll-position dynamic-window) ()
  (declare (values top-displayed height-displayed minimum-y maximum-y))
  (values (if secondary-viewport
	      (min (box-top secondary-viewport)
		   (box-top cursor-viewport))
	      (box-top cursor-viewport))
	  (if secondary-viewport
	      (+ (box-height secondary-viewport)
		 (box-height cursor-viewport))
	      (box-height cursor-viewport))
	  minimum-y-position
	  (max maximum-y-position (box-bottom cursor-viewport))))

;; For use within scroll methods.
(defmethod (calculate-new-viewport-position dynamic-window) (x-or-y type position &optional (context-nlines 1))
  (declare (values viewport-left viewport-top))
  (ecase x-or-y
    (:y
      (ecase type
	(:relative-jump
	  (send self :close-secondary-viewport)
	  (unless (zerop position)
	    (let ((index viewport-displayed-strings-start-index)
		  (max-index (fill-pointer displayed-strings))
		  (y (box-top cursor-viewport))
		  (inc (signum position)))
	      (labels ((index-ok-p (index)
			 (and ( index 0)
			      (< index max-index))))
		(loop repeat (abs position)
		      do (loop doing
			   (let ((new-index (+ index inc)))
			     (unless (index-ok-p new-index)
			       (loop-finish))
			     (setq index new-index))
			   (let ((new-top (box-top (presentation-displayed-box
						     (aref displayed-strings index)))))
			     (when ( new-top y)
			       (setq y new-top)
			       (loop-finish))))
		      while (index-ok-p index))
		(when (index-ok-p index)
		  (let ((new-top (box-top (presentation-displayed-box
					    (aref displayed-strings index)))))
		    (values (box-left cursor-viewport) new-top)))))))
	(:relative 
	  (let ((new-top (let ((viewport (if (and secondary-viewport
						  ( position
						     (viewport-displayed-y-position
						       secondary-viewport)))
					     secondary-viewport
					     cursor-viewport)))
			   (+ (box-top viewport)
			      (- position (viewport-displayed-y-position viewport))))))
	    (send self :close-secondary-viewport)
	    (values (box-left cursor-viewport)
		    (send self :viewport-integral-top new-top
			  nil (minusp position)))))
	(:absolute
	  (send self :close-secondary-viewport)
	  (values (box-left cursor-viewport)
		  (send self :viewport-integral-top position)))
	(:screenful
	  (if (minusp position)
	      (let ((top (box-top cursor-viewport))
		    (index viewport-displayed-strings-start-index)
		    (limit-index (fill-pointer displayed-strings)))
		(loop when ( index limit-index)
			return (setq top maximum-y-position)
		      do (let ((new-bot (box-bottom (presentation-displayed-box
						      (aref displayed-strings index)))))
			   ;; If this line is too far down past whitespace, give up on
			   ;; overlap.
			   (when (> (- new-bot top) (+ tv:current-line-height
						       (* tv:line-height 3)))
			     (return))
			   (setq top new-bot))
		      while (plusp (decf context-nlines))
		      do (loop while (< index limit-index)
			       while (= (box-bottom (presentation-displayed-box
						      (aref displayed-strings index)))
					top)
			       do (incf index)))
		(values (box-left cursor-viewport)
			(send self :viewport-integral-top
			      (- top (box-height cursor-viewport)))))
	      ;; Same thing in reverse.
	      (let ((bottom (box-bottom cursor-viewport))
		    (index (1- (or viewport-displayed-strings-end-index
				   (fill-pointer displayed-strings)))))
		(loop while (plusp index)
		      until ( (box-bottom (presentation-displayed-box
					     (aref displayed-strings index)))
			       bottom)
		      do (decf index))
		(loop while (plusp index)
		      do (let ((new-top (box-top (presentation-displayed-box
						   (aref displayed-strings index)))))
			   (when (> (- bottom new-top) (+ tv:current-line-height
							  (* tv:line-height 3)))
			     (return))
			   (setq bottom new-top))
		      while (plusp (decf context-nlines))
		      do (loop while (plusp index)
			       while (= (box-top (presentation-displayed-box
						   (aref displayed-strings index)))
					bottom)
			       do (decf index)))
		(values (box-left cursor-viewport)
			(send self :viewport-integral-top bottom)))))


		))
    (:x
      (ecase type
	(:relative-jump
	  (calculate-new-viewport-position self :x :relative (* position tv:char-width)))
	(:relative
	  (values (+ (box-left cursor-viewport)
		     (* tv:char-width (floor position tv:char-width)))
		  (box-top cursor-viewport)))
	(:absolute
	  (values position (box-top cursor-viewport)))))))

(defmethod (:y-scroll-to dynamic-window) (position type)
  (let ((new-top nil))
    (when scroll-position-function
      (multiple-value-setq (nil new-top)
	(funcall scroll-position-function self :y type position)))
    (unless new-top
      (multiple-value-setq (nil new-top)
	(calculate-new-viewport-position self :y type position)))
    (send self :set-viewport-position nil new-top)))

(defmethod (:scroll-one-screenful dynamic-window) (backward-p &optional (context-nlines 1))
  (if secondary-viewport
      ;; Scroll to about the same position already shown, but without a window shade.
      (multiple-value-bind (left top)
	  (box-position cursor-viewport)
	(send self :set-viewport-position left
	      (send self :viewport-integral-top (- top (box-height secondary-viewport)))))
      (let ((new-top nil))
	(when scroll-position-function
	  (multiple-value-setq (nil new-top)
	    (funcall scroll-position-function self :y :screenful (if backward-p -1 +1))))
	(unless new-top
	  (when cursor-viewport
	    (multiple-value-setq (nil new-top)
	      (calculate-new-viewport-position
		self :y :screenful (if backward-p -1 +1) context-nlines))))
	(when new-top
	  (send self :set-viewport-position nil new-top)))))

;;; This is different from (:scroll-relative margin-mixin :default), which works for zwei
;;; because it scales by the ratio of the viewport width or height to the window width or
;;; height.  On a zwei window, the viewport height is in lines, but on a dynamic window
;;; everything is in pixels, but that ratio is not identically 1 because the viewport
;;; height is truncated to an integral number of lines.  For dynamic windows, everything
;;; is in pixels and we don't want any scaling.
(defmethod (:scroll-relative dynamic-window) (from to)
  (multiple-value-bind (from-number from-range from-msg)
      (scroll-relative-1 from self)
    (multiple-value-bind (to-number to-range to-msg)
	(scroll-relative-1 to self)
      (ignore from-range to-range)
      (when (or (and (null from-msg) (null to-msg))
		(and (not (null from-msg))
		     (not (null to-msg))
		     (neq from-msg to-msg)))
	(error "Incompatible arguments to :SCROLL-RELATIVE."))
      (send self (or from-msg to-msg) (- from-number to-number) :relative))))

(defmethod (:x-scroll-position dynamic-window) ()
  (values (box-left cursor-viewport)
	  (box-width cursor-viewport)
	  minimum-x-position
	  (max maximum-x-position (box-right cursor-viewport))))

(defmethod (:x-scroll-to dynamic-window) (position type)
  (let ((new-left nil))
    (when scroll-position-function
      (multiple-value-setq (new-left nil)
	(funcall scroll-position-function self :x type position)))
    (unless new-left
      (setq new-left
	    (calculate-new-viewport-position self :x type position)))
    (send self :set-viewport-position new-left nil)))

(defmethod (:ragged-borders-p dynamic-window) ()
  (when cursor-viewport
    (values (> (box-left cursor-viewport) 0)
	    (or (not (null secondary-viewport))
		(> (box-top cursor-viewport) 0))
	    (< (box-right cursor-viewport) maximum-x-position)
	    (or (not (null secondary-viewport))
		(< (box-bottom cursor-viewport) maximum-y-position)))))

(defwhopper (tv:move-for-line-height-change dynamic-window)
	    (movement-height movement height-increase)
  (tv:sheet-draw-rectangle (tv:sheet-inside-width) height-increase
			   (tv:sheet-inside-left) (+ tv:cursor-y movement-height)
			   tv:erase-aluf)
  (tv:reserve-vertical-space-for-output self (+ movement-height height-increase))
  (when string-out-state
    (unless current-output-displayed-string
      (send self :check-current-output-displayed-string nil)))
    (when current-output-displayed-presentation
      (let ((new-line-bottom (multiple-value-bind (nil line-top-y)
				 (send self :read-cursorpos)
			       (+ line-top-y (+ movement-height height-increase)))))
	(labels ((move-presentation (presentation)
		   (let ((box (presentation-displayed-box presentation)))
		     (maxf (box-bottom box) new-line-bottom))
		   (let ((superior (presentation-superior presentation)))
		     (when superior
		       (move-presentation superior)))))
	  (move-presentation current-output-displayed-presentation)
	  (when current-output-displayed-presentation-text
	    (move-presentation current-output-displayed-presentation-text)))))
    (when (or current-output-displayed-string
	      (and rubout-handler (eq self si:*input-editor-stream*)))
      #||	;I'm not sure what piece of state this is trying to update, but when it's
	        ;called here, the cursor position isn't anyplace reasonable.
      (when string-out-state
	;; We haven't updated the string yet, so we have to fix it up
	(update-string-out-state))
      ||#
      (cond (current-output-displayed-string
	     (incf (displayed-string-baseline current-output-displayed-string) movement)
	     (let ((box (presentation-displayed-box current-output-displayed-string)))
	       (send self :move-overlapping-presentations box
		     (box-width box) (+ (box-height box) height-increase))
	       (incf (box-bottom box) height-increase)))
	    (t
	     (let ((box (copy-box cursor-viewport)))
	       (multiple-value-bind (nil y)
		   (send self :read-cursorpos)
		 (setf (box-top box) y
		       (box-bottom box) (+ y tv:current-line-height)))
	       (send self :move-overlapping-presentations box
		     (box-width box) (+ (box-height box) height-increase)))))
      (continue-whopper movement-height movement height-increase)))

(defwhopper (tv:reserve-vertical-space-for-output dynamic-window) (output-height)
  (tv:prepare-sheet (self)
    (multiple-value-bind (defaulted-end-of-page-mode defaulted-scroll-factor)
	(send self :defaulted-end-of-page-mode)
      (ecase defaulted-end-of-page-mode
	(:scroll
	  (multiple-value-bind (nil start-y)
	      (send self :read-cursorpos)
	    (flet ((ideal-new-y (&optional account-for-more)
		     (let* ((desired-bottom (+ start-y output-height))
			    (new-y (- desired-bottom
				      (if (< defaulted-scroll-factor 1)
					  (round (* (box-height cursor-viewport)
						    (- 1 defaulted-scroll-factor)))
					  (- (box-height cursor-viewport)
					     (* defaulted-scroll-factor
						tv:current-line-height)))))
			    (arrange-to-more nil))
		       (setq new-y (send self :viewport-integral-top new-y t))
		       (when (and account-for-more
				  (not (null tv:more-vpos))
				  tv:more-processing-truly-global-enable
				  tv:more-processing-global-enable
				  ( last-typein-y (+ new-y tv:current-line-height)))
			 (setq new-y last-typein-y
			       arrange-to-more t))
		       (setq new-y (max new-y
					(box-top cursor-viewport)
					(- desired-bottom (box-height cursor-viewport))))
		       (values new-y arrange-to-more))))
	      (let ((old-y tv:cursor-y))
		(with-integral-bottom-margin
		  (tv:sheet-check-more-position output-height))
		(when (or (not (zerop (tv:sheet-more-flag)))
			  (and (not (zerop (tv:sheet-end-page-flag)))
			       (not (null tv:more-vpos))
			       tv:more-processing-truly-global-enable
			       tv:more-processing-global-enable
			       (< last-typein-y (ideal-new-y))))
		  (setf (tv:sheet-end-page-flag) 0)
		  (setf (tv:sheet-more-flag) 1)
		  (setq tv:more-vpos (with-integral-bottom-margin
				       (tv:sheet-deduce-more-vpos)))
		  (setq tv:cursor-y old-y)
		  (send self :handle-exceptions)))
	      (when (not (zerop (tv:sheet-end-page-flag)))
		(multiple-value-bind (new-y arrange-to-more)
		    (ideal-new-y t)
		  (send self :set-viewport-position nil new-y)
		  (when tv:more-vpos
		    (setq tv:more-vpos (if arrange-to-more
					   (with-integral-bottom-margin
					     (tv:sheet-deduce-more-vpos))
					   999999))))))))
	(:wrap
	  (when (and secondary-viewport
		     (viewport-separator-displayed secondary-viewport))
	    (send self :draw-viewport-separator-line secondary-viewport t))
	  (with-integral-bottom-margin
	    (continue-whopper output-height))
	  (when secondary-viewport
	    ;; Too bad this has to draw it twice at end of page.
	    (when (viewport-separator-displayed secondary-viewport)
	      (send self :draw-viewport-separator-line secondary-viewport t))
	    (send self :move-secondary-viewport-boundary
		  ;; +++ This output-height didn't include extra-space-below when this code
		  ;; +++ was part of :allocate-vertical-space-for-output
		  (+ tv:(- cursor-y top-margin-size) output-height))))
	(:truncate)))))

(defwhopper (:allocate-vertical-space-for-output dynamic-window)
	    (output-height extra-space-above)
  (let ((motion-distance (+ extra-space-above (max 0 (- output-height
							tv:current-line-height)))))
    (multiple-value-bind (defaulted-end-of-page-mode defaulted-scroll-factor)
	(send self :defaulted-end-of-page-mode)
      (tv:prepare-sheet (self)
	(send self :close-current-output-displayed-string)
	(ecase defaulted-end-of-page-mode
	  (:scroll
	    (ignore defaulted-scroll-factor)
	    (multiple-value-bind (start-x start-y)
		(send self :read-cursorpos)
	      (tv:reserve-vertical-space-for-output self (+ output-height extra-space-above))
	      (tv:sheet-increment-bitpos 0 (+ output-height extra-space-above))
	      (send self :set-cursorpos start-x (+ start-y motion-distance))))
	  (:wrap
	   (multiple-value-bind (start-x start-y)
	       (send self :read-cursorpos)
	     (with-integral-bottom-margin
	       (continue-whopper output-height extra-space-above))
	     (let ((new-y (+ start-y motion-distance)))
	       (when secondary-viewport
		 ;; Too bad this has to draw it twice at end of page.
		 (when (viewport-separator-displayed secondary-viewport)
		   (send self :draw-viewport-separator-line secondary-viewport t))
		 (when (< new-y (box-top cursor-viewport))
		   ;; The allocation procedure has caused a wraparound but the desired new
		   ;; cursor position is in the old part of the history.  Make it be at the top
		   ;; of screen instead, shortening the height of the old stuff accordingly.
		   (setf (box-bottom secondary-viewport) new-y)
		   (setf (box-bottom cursor-viewport) (+ new-y (box-height cursor-viewport)))
		   (setf (box-top cursor-viewport) new-y)
		   (tv:prepare-sheet (self)
		     (tv:sheet-draw-rectangle (tv:sheet-inside-width) tv:line-height
					      (tv:sheet-inside-left) (tv:sheet-inside-top)
					      tv:erase-aluf)))
		 (send self :move-secondary-viewport-boundary
		       (- (+ new-y tv:line-height) (box-top cursor-viewport))))
	       (send self :set-cursorpos start-x new-y))))
	  (:truncate
	   (send self :increment-cursorpos 0 motion-distance)))))))

(defmethod (:choose-attributes dynamic-window) ()
  (let ((end-of-page-mode (accept '((member :default :scroll :truncate :wrap))
				  :prompt "End of screen action"
				  :default end-of-page-mode)))
    (list* :set-end-of-page-mode end-of-page-mode
      (unless (eq (if (eq end-of-page-mode :default)
		      *default-end-of-page-mode* end-of-page-mode)
		  :wrap)
	(list :set-scroll-factor (accept '((token-or-type (("Default" . nil)) number))
					 :prompt "Amount to scroll by"
					 :provide-default t
					 :default scroll-factor))))))

;;; Hopefully the contract of these for non-dynamic windows will be vague enough that it
;;; will be alright that we adjust the coordinate systems a little more.
(defmethod (:mouse-position dynamic-window) ()
  (multiple-value-bind (x y)
      (tv:sheet-mouse-position self)
    (coordinate-convert-points self :absolute :outside x y)
    (values x y)))

(defwhopper (:set-mouse-position dynamic-window) (x y &optional (error-p t))
  (coordinate-convert-points self :relative :outside x y)
  (continue-whopper x y error-p))

(defmethod (:erase-displayed-presentation dynamic-window)
	   (presentation
	    &key (redisplay-overlapping-presentations t)
		 (delete-too t) (clear-inferiors t)
		 (enable-recording t)
		 )
  (letf ((coordinate-transformation-enabled t)
	 (output-recording-enabled (or enable-recording output-recording-enabled)))
    (erase-displayed-presentation presentation self t nil clear-inferiors)
    (when delete-too
      (send self :delete-displayed-presentation presentation))
    (when redisplay-overlapping-presentations
      (send self :redraw-inside-sets (presentation-displayed-box presentation) nil))))

(defmethod (:unerase-displayed-presentation dynamic-window)
	   (presentation &key redisplay-overlapping-presentations)
  (send self :add-displayed-presentation presentation nil)
  (labels ((add-graphics (presentation)
	     (if (typep presentation 'graphics-displayed-presentation)
		 (add-to-coordinate-sorted-set presentation displayed-graphics)
		 (map () #'add-graphics (presentation-inferiors presentation)))))
    (add-graphics presentation))
  (when redisplay-overlapping-presentations
    (send self :redraw-inside-sets (presentation-displayed-box presentation) nil)))

(defun find-presentation-at-position (array window x y &optional (start 0) end
								 (anonymous-too t)
								 (eol-p nil))
  (loop for object being the array-elements of array
	    downfrom (1- (if (null end) (vector-length array)
			     (min end (vector-length array))))
		   to start
	do (multiple-value-bind (find too-far)
	       (presentation-at-position object window x y eol-p)
	     (when (and find
			(or anonymous-too
			    (not (loop for x first find then (presentation-superior x)
				       while x
				       always (presentation-anonymous-p x)))))
	       (return find))
	     (when too-far (return nil)))))

(defun find-presentation-at-prioritized-position (array window x y
						  &optional (start 0) end
							    (anonymous-too t)
							    (allow-raw-text t))
  (let ((best nil)
	(best-priority nil))
    (loop for object being the array-elements of array
	      downfrom (1- (if (null end) (vector-length array)
			       (min end (vector-length array))))
		     to start
	do (multiple-value-bind (find too-far)
	       (presentation-at-position object window x y nil allow-raw-text)
	     (when (and find
			(or anonymous-too
			    (not (loop for x first find then (presentation-superior x)
				       while x
				       always (presentation-anonymous-p x))))
			(let ((priority (graphics-displayed-presentation-priority find)))
			  (when (null priority)
			    (return-from find-presentation-at-prioritized-position find))
			  (when (or (null best) (> priority best-priority))
			    (setq best find
				  best-priority priority))))
	       (setq best find))
	     (when too-far (return))))
    best))

;;--- There is a race condition here: if another process does a 1:note-region-clobbered
0;;--- on this window, then this can blow out becase the arrays of presentations can
;;--- change.  This could be fixed by wrapping a 1tv:prepare-sheet0 around this, but
;;--- that's pretty expensive, so we'll just leave it for now.  Only 1nvt-window0's
;;--- seem subject to that right now, and that already has a wrapper.  Split-screen
;;--- Lisp Listeners can lose, too.
(defmethod (:displayed-presentation-at-position dynamic-window) (x y &optional mouse-char)
  (when (or (box-contains-point-p cursor-viewport x y)
	    (and secondary-viewport (box-contains-point-p secondary-viewport x y)))
    (or 
      ;; Allow a user hook for a presentation never actually presented.
      (and sub-presentation-presentation-function
	   (funcall sub-presentation-presentation-function self x y mouse-char))
      (let ((allow-raw-text
	      (or *allow-sensitive-raw-text-override*
		  (let ((shifts (if mouse-char
				    (si:mouse-char-bits mouse-char)
				    (tv:mouse-chord-shifts (tv:sheet-mouse self)))))
		    (or (member shifts *raw-text-mouse-chars*)
			(and *debug-anonymous-presentations*
			     (= shifts
				(si:mouse-char-bits
				  (mouse-char-for-gesture :presentation-debugging-menu)))))))))
       (or
	;; First look at actual presentations.  Need to do this first because string
	;; presentations don't properly point to actual presentation superiors here.
	(find-presentation-at-prioritized-position displayed-presentations self x y
						   viewport-displayed-presentations-start-index
						   viewport-displayed-presentations-end-index
						   nil allow-raw-text)
	;; Include any presentation being written now.
	(and current-output-displayed-presentation
	     ;; This can only happen during a more break while doing output,
	     ;; so hopefully it won't make things much slower.
	     ;; Partially root the partial output and see if we're in it.
	     (let ((top (loop for presentation = current-output-displayed-presentation
					       then superior
			      as superior = (presentation-superior presentation)
			      while superior
			      do (displayed-presentation-add-inferior superior presentation)
			      finally (return presentation))))
	       (update-displayed-presentation-box top)
	       (presentation-at-position top self x y allow-raw-text)))
	(and allow-raw-text
	     (or
	       ;; Look for a string character in the string.
	       (find-presentation-at-position displayed-strings self x y
					      viewport-displayed-strings-start-index
					      viewport-displayed-strings-end-index)
	       ;; Include the current line.
	       (and current-output-displayed-string
		    (presentation-at-position current-output-displayed-string self x y))
	       ;; Then look for the virtual character space at the end of a line.
	       (find-presentation-at-position displayed-strings self x y
					      viewport-displayed-strings-start-index
					      viewport-displayed-strings-end-index
					      t t)))))
      ;; Finally look for a terminal graphics presentation.
      (find-presentation-at-prioritized-position displayed-graphics self x y
						 viewport-displayed-graphics-start-index
						 viewport-displayed-graphics-end-index))))


(defmethod (:add-region-string dynamic-window) (displayed-string start-index end-index
						&optional (highlighting-mode :underline)
							  (include-left nil))
  (let ((highlighted-intervals (displayed-string-highlighted-intervals displayed-string)))
    (let* ((extends-to-right (dolist (interval highlighted-intervals)
			       (when (and ( (first interval) start-index)
					  ( (second interval) start-index)
					  (eq (third interval) highlighting-mode))
				 (setq highlighted-intervals
				       (remove interval highlighted-intervals))
				 (return
				   (list (min (first interval) start-index)
					 (max (second interval) end-index)
					 highlighting-mode include-left)))))
	   (extends-to-left (dolist (interval highlighted-intervals)
			      (when (and ( (first interval) end-index)
					 ( (second interval) end-index)
					 (eq (third interval) highlighting-mode))
				(setq highlighted-intervals
				      (remove interval highlighted-intervals))
				(when extends-to-right
				  (setf (second extends-to-right)
					(max (second extends-to-right)
					     (second interval)))
				  (when (and include-left (not (fourth extends-to-right)))
				    (setf (fourth extends-to-right) include-left))
				  (return nil))
				(return
				  (list (min (first interval) start-index)
					(max (second interval) end-index)
					highlighting-mode include-left))))))
      (unless (or extends-to-right extends-to-left)
	(push (list start-index end-index highlighting-mode include-left)
	      highlighted-intervals))
      (when extends-to-right
	(push extends-to-right highlighted-intervals))
      (when extends-to-left
	(push extends-to-left highlighted-intervals)))
    (set-displayed-string-highlighted-intervals displayed-string highlighted-intervals
						self))
  (pushnew displayed-string (displayed-strings-array-region-strings displayed-strings)))

(defmethod (:delete-region-string dynamic-window) (displayed-string start-index end-index
						   &optional (highlighting-mode :underline)
							     ignore)
  (let ((highlighted-intervals (displayed-string-highlighted-intervals displayed-string))
	(changed-p nil))
    (dolist (interval highlighted-intervals)
      (when (eq (third interval) highlighting-mode)
	(let ((left (first interval))
	      (right (second interval)))
	  (unless (or (< right start-index)
		      (< end-index left))
	    (setq highlighted-intervals (remove interval highlighted-intervals))
	    (when (> start-index left)
	      (push (list left start-index highlighting-mode) highlighted-intervals))
	    (when (> right end-index)
	      (push (list end-index right highlighting-mode) highlighted-intervals))
	    (setq changed-p t)))))
    (when changed-p
      (set-displayed-string-highlighted-intervals displayed-string highlighted-intervals
						  self)
      (when (null highlighted-intervals)
	(setf (displayed-strings-array-region-strings displayed-strings)
	      (delete displayed-string
		      (displayed-strings-array-region-strings displayed-strings)))))))

(defmethod (:region-strings dynamic-window) ()
  (and displayed-strings
       (displayed-strings-array-region-strings displayed-strings)))

(defmethod (:clear-region-strings dynamic-window) ()
  (let ((region-strings (displayed-strings-array-region-strings displayed-strings)))
    (dolist (displayed-string region-strings)
      (set-displayed-string-highlighted-intervals displayed-string nil self)))
  (setf (displayed-strings-array-region-strings displayed-strings) nil))

(defmethod (:region-strings-into-string dynamic-window) ()
  (when displayed-strings
    (let ((region-strings (displayed-strings-array-region-strings displayed-strings)))
      (when region-strings
	;; It's OK to do a destructive sort here, since we're about to throw
	;; the region-strings away anyhow.  Can't use 1sort-displayed-strings
0	;; because the region-strings are not in an array (who cares, the
	;; list of them is usually pretty small).
	(setq region-strings (sort region-strings #'displayed-string-precedes))
	(let ((string (with-output-to-string (stream)
			(let ((last-x nil)
			      (last-y nil)
			      (last-baseline nil))
			  (dolist (displayed-string region-strings)
			    (let ((intervals (displayed-string-highlighted-intervals
					       displayed-string)))
			      (setq intervals (sort intervals #'< :key #'first))
			      (loop for (start end highlighting-mode include-left)
					in intervals doing
				(ignore highlighting-mode)
				(when (and include-left (null last-x))
				  (setq last-x 0))
				(multiple-value-setq (last-x last-y last-baseline)
				  (output-displayed-string-as-text
				    displayed-string stream self
				    last-x last-y last-baseline
				    start end))))
			    (set-displayed-string-highlighted-intervals
			      displayed-string nil self))))))
	  (setf (displayed-strings-array-region-strings displayed-strings) nil)
	  string)))))

;;; Protocol shared with editor.
(defmethod (:marked-text dynamic-window) (&key return-as-string unmark delete)
  (cond (return-as-string
	 (send self :region-strings-into-string))
	((or unmark delete)			;Don't distinguish.
	 (prog1 (send self :region-strings)
		(send self :clear-region-strings)))
	(t
	 (send self :region-strings))))

(defmethod (displayed-presentation-set-highlighting displayed-presentation)
	   (window &optional (highlighting-mode :underline))
  (dolist (inferior inferiors)
    (displayed-presentation-set-highlighting inferior window highlighting-mode)))

(defmethod (displayed-presentation-set-highlighting text-displayed-presentation)
	   (window &optional (highlighting-mode :underline))
  (send window :add-region-string displayed-string start-index
				  (or end-index
				      (vector-length
					(displayed-string-string displayed-string)))
				  highlighting-mode))

(defmethod (displayed-presentation-clear-highlighting displayed-presentation)
	   (window &optional (highlighting-mode :underline))
  (dolist (inferior inferiors)
    (displayed-presentation-clear-highlighting inferior window highlighting-mode)))

(defmethod (displayed-presentation-clear-highlighting text-displayed-presentation)
	   (window &optional (highlighting-mode :underline))
  (send window :delete-region-string displayed-string start-index
				     (or end-index
					 (vector-length
					   (displayed-string-string displayed-string)))
				     highlighting-mode))

;;;; Re-presentation stuff.  This is all a little suspect.

(defmethod (:replace-object-value dynamic-window) (displayed-presentation)
  (with-output-truncation (self)
    (si:with-ie-typeout-if-appropriate (self)
      (let ((abort-p t)
	    (end-x 0) (end-y 0))
	(multiple-value-bind (save-x save-y)
	    (send self :read-cursorpos)
	  (multiple-value-bind (start-x start-y)
	      (box-position (presentation-displayed-box displayed-presentation))
	    (unwind-protect
		(progn
		  ;; Erase from screen, but don't forget the data.
		  (letf ((output-recording-enabled nil))
		    (erase-displayed-presentation displayed-presentation self))
		  (send self :set-cursorpos start-x start-y)
		  (let* ((object-type (presentation-type displayed-presentation))
			 (type (if (eq object-type 'dbg:unbound) 'sys:expression object-type))
			 (value (letf ((output-recording-enabled nil))
				  (with-input-editing-options (((:prompt :override) nil)
							       ((:reprompt :override) nil))
				    ;;+++ How should EXPRESSION turn into EVAL-FORM here?
				    ;;  or should it?
				    (si:with-ie-typein (self)
				      (letf ((output-recording-enabled nil))
					(accept type
						:prompt nil
						:default (presentation-object
							   displayed-presentation)
						:stream self)))))))
		    (multiple-value-setq (end-x end-y)
		      (send self :read-cursorpos))
		    (replace-presentation-object-value displayed-presentation value)
		    (send self :set-cursorpos start-x start-y)
		    ;; Erase input editor echo.
		    (letf ((output-recording-enabled nil))
		      (send self :clear-between-cursorposes start-x start-y end-x end-y))
		    (incf end-y tv:current-line-height)
		    ;; Can now forget the data too, since it's invalid anyway.
		    (erase-displayed-presentation displayed-presentation self)
		    (loop for presentation = displayed-presentation then superior
			  as superior = (presentation-superior presentation)
			  while superior
			  do (pushnew presentation (presentation-inferiors superior)))
		    (send self :output-for-re-presentation displayed-presentation
			  (lambda (stream) (present value type :stream stream)) self)
		    (multiple-value-setq (start-x start-y)
		      (send self :read-cursorpos))
		    (setq abort-p nil)))
	      (when abort-p
		(multiple-value-bind (x y)
		    (send self :read-cursorpos)
		  (cond ((< y end-y))
			((= y end-y)
			 (setq end-x (max end-x x)))
			(t
			 (setq end-y y end-x x)))))
	      (send self :redisplay-between-cursorposes start-x start-y end-x end-y)
	      (send self :set-cursorpos save-x save-y))))))))

(defmethod (:represent-presentation dynamic-window)
	   (displayed-presentation
	     &optional (presentation-type (presentation-type displayed-presentation)))
 (send self :close-secondary-viewport)
 (with-output-truncation (self)
   (letf ((output-recording-enabled t))
     ;; Get rid of sub-presentations associated with this one, and clear the area about
     ;; to be bitblted.
     (multiple-value-bind (new-width new-height)
	 (continuation-output-size #'(lambda (stream)
				       (present (presentation-object displayed-presentation)
						presentation-type
						:stream stream))
				   self)
       (tv:delaying-mouse-wakeup
	 (erase-displayed-presentation displayed-presentation self t t))
       ;; Make sure any sibling presentations are still accessible.
       (loop for presentation = displayed-presentation then superior
	     as superior = (presentation-superior presentation)
	     when (eq superior current-output-displayed-presentation)
	       return (send self :end-presentation-output presentation :update-box nil)
	     do (pushnew presentation (presentation-inferiors superior))
		(setf (displayed-presentation-displayed-box-valid superior) nil))
       ;; Shove over things that will conflict with a larger box.
       (send self :move-overlapping-presentations
	     (presentation-displayed-box displayed-presentation) new-width new-height))
     (multiple-value-bind (save-x save-y)
	 (send self :read-cursorpos)
       (multiple-value-bind (start-x start-y)
	   (box-position (presentation-displayed-box displayed-presentation))
	 (send self :set-cursorpos start-x start-y)
	 ;; Do the new output in the freshly cleared area.
	 (send self :output-for-re-presentation displayed-presentation
	       (lambda (stream) (present (presentation-object displayed-presentation)
					 presentation-type
					 :stream stream
					 ;; This keeps us from getting another level of
					 ;; presentation.
					 :sensitive nil))
	       self))
       ;; Make sure whole hierarchy has correctly sized boxes for new pieces.
       (update-displayed-presentation-box
	 (loop for presentation = displayed-presentation then superior
	       as superior = (presentation-superior presentation)
	       do (setf (displayed-presentation-displayed-box-valid presentation) nil)
	       when (null superior)
		 return presentation))
       (send self :set-cursorpos save-x save-y))))
  (setf (presentation-type displayed-presentation) presentation-type)
  displayed-presentation)

;;; Anything that's in the new box this presentation will occupy has to get out of the way.
(defmethod (:move-overlapping-presentations dynamic-window) (old-box new-width new-height)
  (multiple-value-bind (left top old-right old-bottom)
      (box-edges old-box)
    (let* ((old-width (- old-right left))
	   (old-height (- old-bottom top))
	   (new-right (+ left new-width))
	   (new-bottom (+ top new-height))
	   (dy (- new-bottom old-bottom))
	   (dx (- new-right old-right)))
      ;;--- Someday this should move things up/left when the new-height/width
      ;;--- is less than the old-height/width.
      (unless (and ( new-width old-width) ( new-height old-height))
	(letf ((output-recording-enabled nil))
	  ;; Move things in the same vertical region to the right and clear the new slice
	  ;; on the right.
	  (let ((width (- (box-right cursor-viewport) new-right))
		(height (- (min (box-bottom cursor-viewport) old-bottom) top)))
	    (when (and (plusp width) (plusp height))
	      (send self :bitblt-within-sheet tv:alu-seta (- width) height
		    old-right top new-right top)))
	  (send self :draw-rectangle (- new-right old-right) old-height old-right top :erase)
	  ;; Move things below further down and clear the new vertical slice.
	  (multiple-value-bind (nil y)
	      (send self :read-cursorpos)
	    (maxf maximum-y-position (+ y tv:current-line-height)))
	  (let ((height (min (- maximum-y-position old-bottom)
			     ;; Copy rest of viewport which exists.
			     (- (box-bottom cursor-viewport) new-bottom))))
	    (when (plusp height)
	      (send self :bitblt-within-sheet tv:alu-seta
		    (box-width cursor-viewport) (- height)
		    (box-left cursor-viewport) old-bottom
		    (box-left cursor-viewport) new-bottom)))
	  (send self :draw-rectangle (box-width cursor-viewport) (- new-bottom old-bottom)
		(box-left cursor-viewport) old-bottom :erase))
	;; Move presentations in the same region in the same way.
	(flet ((index-range (array window-start-index)
		 (declare (values start-index end-index))
		 (let ((start-index
			 (if ( top (box-top cursor-viewport))
			     (top-displayable-index array top
						    :start window-start-index)
			   (top-displayable-index array top))))
		   (values start-index (fill-pointer array))))
	       (move-box (box boxes-moved &optional object)
		 (unless (or (box-contained-in-region-p box left top old-right old-bottom)
			     (gethash box boxes-moved))
		   (multiple-value-bind (box-dx box-dy)
		       (if ( (box-bottom box) old-bottom)
			   (values dx 0)
			 (values 0 dy))
		     (set-box-position box (+ (box-left box) box-dx)
					   (+ (box-top box) box-dy))
		     (when object
		       (presentation-adjust-for-box-move object box-dx box-dy)))
		   (setf (gethash box boxes-moved) t)))
	       (box-should-move (box)
		 (or (box-overlaps-region-p box left top nil old-bottom)
		     (and (plusp dy) ( (box-bottom box) old-bottom)))))
	  (sys:with-data-stack
	    (let* ((approximate-n-boxes
		     (macrolet ((approximate-number-of-boxes (array)
				  (multiple-value-bind (array-start-idx array-end-idx)
				      (viewport-displayed-array-index-names array)
				    `(multiple-value-bind (start-index end-index)
					 (index-range ,array ,array-start-idx)
				       (1+ (- end-index start-index))))))
		       (+ (approximate-number-of-boxes displayed-strings)
			  (approximate-number-of-boxes displayed-presentations)
			  (approximate-number-of-boxes displayed-graphics))))
		   (boxes-moved (make-hash-table :size (floor (* 1.5 approximate-n-boxes))
						 :area :stack
						 :number-of-values 0)))
	      (macrolet ((do-overlapping-boxes ((object array box) &body body)
			   (multiple-value-bind (array-start-idx array-end-idx)
			       (viewport-displayed-array-index-names array)
			     `(multiple-value-bind (start-index end-index)
				  (index-range ,array ,array-start-idx)
				(loop for ,object being the array-elements of ,array
					  from start-index below end-index do
				  (let ((,box (presentation-displayed-box ,object)))
				    (when (box-should-move ,box)
				      . ,body)))))))
		(do-overlapping-boxes (displayed-string displayed-strings box)
		  (move-box box boxes-moved))
		(do-overlapping-boxes (graphics displayed-graphics box)
		  (move-box box boxes-moved graphics))
		(do-overlapping-boxes (presentation displayed-presentations box)
		  (labels ((move-one (presentation box)
			     (dolist (inferior (presentation-inferiors presentation))
			       (let ((inferior-box (presentation-displayed-box inferior)))
				 (when (box-should-move inferior-box)
				   (move-one inferior inferior-box))))
			     (move-box box boxes-moved)))
		    (move-one presentation box)))))))
	;; Update various saved cursor positions that might be in the same region.
	(flet ((move-point (x y)
		 (declare (values x y moved-p))
		 (cond (( y old-bottom)
			(values x (+ y dy) t))
		       ((and ( y top) (< y old-bottom)
			     ( x left) (< x old-right))
			(values (+ x dx) y t))
		       (t (values x y nil)))))
	  (when (and rubout-handler (eq self si:*input-editor-stream*))
	    (multiple-value-setq (si:buffer-x si:buffer-y)
	      (move-point si:buffer-x si:buffer-y))
	    (multiple-value-setq (input-editor-initial-x input-editor-initial-y)
	      (move-point input-editor-initial-x input-editor-initial-y)))
	  (multiple-value-bind (ox oy)
	      (send self :read-cursorpos)
	    (multiple-value-bind (nx ny moved-p)
		(move-point ox oy)
	      (when moved-p
		(send self :set-cursorpos nx ny)))))))))

(defmethod (:output-for-re-presentation dynamic-window) (displayed-presentation printer
										xstream)
  (letf ((current-output-displayed-presentation displayed-presentation)
	 (current-output-displayed-presentation-text nil))
    (tv:delaying-mouse-wakeup
      (funcall printer xstream)))
  (loop for presentation = displayed-presentation then (presentation-superior presentation)
	while presentation do
    (setf (displayed-presentation-displayed-box-valid presentation) nil))
  (flet ((find-pres-whose-sup-is ()
	   (loop for presentation = displayed-presentation then superior
		 as superior = (presentation-superior presentation)
		 when (eq superior current-output-displayed-presentation)	;NIL or a D-P
		   return presentation
		 while superior)))
    ;; Find the presentation that's rooted here and put it back in,
    ;; making everything sensitive again.
    ;; Find the d-p whose superior is current-output-displayed-presentation.
    ;; A weird case is (redisplay (sensitive-output (table-redisplay ...)))
    ;; where the sensitive-output introduces a new display-presentation
    ;; each time its done, stranding the table's d-p.  So, scan back up
    ;; the superior chain from both current-output-d-p and d-p, finding the
    ;; point of difference, and if we're confident enough, change the
    ;; superior of d-p to be the new one.
    (let ((presentation (find-pres-whose-sup-is)))
      (if presentation 
	  (send self :end-presentation-output presentation :at-end nil)
	  (multiple-value-bind (old-sup new-sup)
	      (find-differing-display-presentation-superiors
		displayed-presentation current-output-displayed-presentation)
	    ;;+++ If we're really going to enforce this single-level-superior
	    ;; business, find-differing-display-presentation-superiors
	    ;; could be simplified considerably.
	    (cond ((eq (presentation-superior displayed-presentation) old-sup)
		   (setf (presentation-superior displayed-presentation) new-sup)
		   (let ((presentation (find-pres-whose-sup-is)))
		     (if presentation
			 (send self :end-presentation-output presentation)
			 (error "Even after splicing superior of ~s from ~s to ~s, ~
				 can't re-root it"
				displayed-presentation old-sup new-sup))))
		  (t (error "OLD-SUP ~s is not superior of ~s (to set superior to ~s)"
			    old-sup displayed-presentation new-sup))))))))

(defun find-differing-display-presentation-superiors (old-pres new-pres)
  (with-data-stack
    (multiple-value-bind (old-stack new-stack)
	(flet ((pres-stack (pres)
		 (let ((stack (make-stack-array
				(loop for p = pres then (presentation-superior p)
				      while p
				      count 1))))
		   (loop for i from 0
			 for p = pres then (presentation-superior p)
			 while p
			 do (setf (aref stack i) p))
		   (nreverse stack)
		   stack)))
	  (values (pres-stack old-pres)
		  (pres-stack new-pres)))
      (let ((diff (mismatch old-stack new-stack)))
	(values (aref old-stack diff) (aref new-stack diff))))))

(defmethod (:redisplay-between-cursorposes dynamic-window) (start-x start-y end-x end-y)
  (tv:prepare-sheet (self)
    (let ((box (if (= start-y end-y)
		   (make-temporary-box start-x start-y end-x (+ end-y tv:current-line-height))
		   (make-temporary-box (box-left cursor-viewport) start-y
				       (box-right cursor-viewport) end-y))))
      (send self :redraw-inside-sets box nil))))

(defmethod (:with-output-recording-enabled dynamic-window) (continuation xstream enabled)
  (letf ((output-recording-enabled enabled))
    (funcall continuation xstream)))

(defmethod (:with-output-truncation dynamic-window :before) (ignore ignore
							     &key (vertical nil)
							     &allow-other-keys)
  (when vertical
    (when secondary-viewport
      ;; Scroll to about the same position already shown, but without a window shade.
      ;; This seems to look best and keeps table display from getting confused.
      (multiple-value-bind (left top)
	  (box-position cursor-viewport)
	(send self :set-viewport-position left top)))))

;;; This manages to get all the exceptions handled correctly without
;;; doing a :clear-end-of-line.
(defmethod (:newline-without-erasing dynamic-window) ()
  (multiple-value-bind (x y)
      (send self :read-cursorpos)
    (if (and (zerop (tv:sheet-truncate-output-flag))
	     (> x (box-right cursor-viewport)))
	;; If the cursor has been left too far to the right from a no
	;; longer active with-output-truncation, quietly get it back in
	;; without handling exceptions, which would horizontally glitch.
	(with-output-truncation (self)
	  (send self :set-cursorpos 0 (+ y tv:current-line-height)))
	(send self :increment-cursorpos (- x) tv:current-line-height)))
  (when (and (not (zerop (tv:sheet-end-page-flag)))
	     (not (tv:sheet-truncate-output-p self :vertical)))
    (send self :handle-exceptions)))

;;; IE scrolling command support
(defun scroll-search-internal (window &optional (direction :backward) index)
  (let ((strings (send window :displayed-strings))
	(viewport (send window :cursor-viewport))
	(highlighted-intervals nil)
	(search-found-length 0)			;next 3 vars are state of last success
	(search-found-position nil)
	(search-found-index nil)
	(input-state 0)
	(search-state 0))
    ;; Arrays to hold the state of incremental search
    ;; Except for search-key, these are indexed by input-state and search-state
    ;; input-state increases by 1 each time a key is pressed, except rubout which decrements
    ;; search-state is the highest one whose succeed/fail status has been determined
    ;; ( search-state input-state) is always true
    (stack-let ((search-key (make-array 30 :element-type 'character :fill-pointer 0))
		(index-array (make-array 30))		;where in window
		(position-array (make-array 30))	;..
		(direction-array (make-array 30))	;:forward, :backward
		(status-array (make-array 30))		;:fail, :succeed, :search
		(length-array (make-array 30)))		;search-key fill-pointer at this level
      ;; Initialize search state
      (setf (aref index-array 0) (or index (fill-pointer strings)))
      (setf (aref position-array 0) nil)
      (setf (aref direction-array 0) direction)
      (setf (aref status-array 0) ':succeed)
      (setf (aref length-array 0) 0)
      (flet ((push-state ()
	       (incf input-state)
	       (when ( input-state (vector-length index-array))
		 (macrolet ((grow (array)
			      `(setq ,array (replace (make-stack-array (* input-state 2))
						     ,array))))
		   (grow index-array)
		   (grow position-array)
		   (grow direction-array)
		   (grow status-array)
		   (grow length-array)))
	       (setf (aref direction-array input-state)
		     (aref direction-array (1- input-state)))
	       (setf (aref length-array input-state)
		     (aref length-array (1- input-state)))
	       (setf (aref status-array input-state) ':search))
	     (clear-highlighted-intervals ()
	       (loop for (displayed-string . intervals) in highlighted-intervals
		     do (set-displayed-string-highlighted-intervals
			  displayed-string
			  (set-difference (displayed-string-highlighted-intervals
					    displayed-string)
					  intervals)
			  window))
	       (setq highlighted-intervals nil))
	     (redisplay-highlighted-intervals ()
	       (loop for (displayed-string . intervals) in highlighted-intervals
		     do (set-displayed-string-highlighted-intervals
			  displayed-string
			  (append (displayed-string-highlighted-intervals displayed-string)
				  intervals)
			  window))))
	(unwind-protect
	    (loop
	      (let ((char (sys:read-character window
			    :no-hang (< search-state input-state)
			    :whostate (let ((prefix
					      (if (eq (aref status-array input-state) ':fail)
						  (case (aref direction-array input-state)
						    (:forward "Failing search: ")
						    (:backward
						      "Failing reverse search: "))
						  (case (aref direction-array input-state)
						    (:forward "Search: ")
						    (:backward "Reverse search: ")))))
					(when (> (+ (string-length prefix)
						    (fill-pointer search-key))
						 28)
					  ;; Make it shorter so the search-key is visible
					  (setq prefix
						(if (eq (aref status-array input-state)
							':fail)
						    (case (aref direction-array input-state)
						      (:forward "Fail: ")
						      (:backward
							"Fail rev: "))
						    (case (aref direction-array input-state)
						      (:forward "Search: ")
						      (:backward "Rev search: ")))))
				      (string-append prefix search-key)))))
		(when char
		  (selector char char-equal
		    (#\Rubout
		     (cond ((plusp input-state)
			    (decf input-state)
			    (setq search-state (min input-state search-state))
			    (setf (fill-pointer search-key) (aref length-array input-state))
			    (loop for state downfrom search-state to 0 do
			      (when (eq (aref status-array state) ':succeed)
				(setq search-found-length (aref length-array state)
				      search-found-position (aref position-array state)
				      search-found-index (aref index-array state))
				(return))))
			   (t (beep))))
		    ((#\Super-S #\Control-S)
		     (push-state)
		     (setf (aref direction-array input-state) ':forward))
		    ((#\Super-R #\Control-R)
		     (push-state)
		     (setf (aref direction-array input-state) ':backward))
		    ((#\End)
		     (return nil))
		    (otherwise
		      (cond ((zerop (char-bits char))
			     (vector-push-extend char search-key)
			     (push-state)
			     (setf (aref length-array input-state) (fill-pointer search-key)))
			    (t 
			     ;; If the user issues any IE command, stop searching
			     (send window :untyi char)
			     (return nil)))))))
	      (when (> input-state search-state)
		(multiple-value-bind (index position)
		    (displayed-strings-search search-key strings window
					      (aref index-array search-state)
					      (aref position-array search-state)
					      :from-end (eq (aref direction-array input-state)
							    ':backward)
					      :repeat
					        ;; If search key got longer, new key can
					        ;; be found at same place as old key.
					        ;; If didn't get longer, this is search-again.
						(> (fill-pointer search-key)
						   (aref length-array search-state))
					      :listen t)
		  (when (or index (not (send window :listen)))
		    (incf search-state)
		    (setf (aref index-array search-state)
			  (or index (aref index-array (1- search-state))))
		    (setf (aref position-array search-state)
			  (or position (aref position-array (1- search-state))))
		    (setf (aref status-array search-state) (if position ':succeed ':fail))
		    (cond (position
			   (setq search-found-length (fill-pointer search-key)
				 search-found-position position
				 search-found-index index))
			  ((= search-state input-state)
			   (beep)		;Announce search failure
			   ;; Discard redundant failing searches so rubout works better
			   (loop with direction = (aref direction-array search-state)
				 with length = (aref length-array search-state)
				 while (> input-state 0)
				 while (eq (aref status-array (1- input-state)) ':fail)
				 while (eq (aref direction-array (1- input-state)) direction)
				 while (= (aref length-array (1- input-state)) length)
				 do (decf input-state)
				    (decf search-state)))))))
	      (unless (send window :listen)
		(clear-highlighted-intervals)
		(when (plusp search-found-length)
		  (when search-found-position
		    (setq highlighted-intervals
			  (list
			    (list
			      (text-displayed-presentation-displayed-string
				search-found-position)
			      (let ((index (text-displayed-presentation-start-index
					     search-found-position)))
				(list index (+ index search-found-length) :inverse-video))))))
		  (redisplay-highlighted-intervals)
		  (when search-found-index
		    (multiple-value-bind (x y)
			(box-edges (presentation-displayed-box search-found-position))
		      (unless (box-contains-point-p viewport x y)
			(send window :set-viewport-position
			      (if (< x (box-width viewport)) 0 x)
			      (send window :viewport-integral-top
				    (max (send window :minimum-y-position)
					 (min (send window :maximum-y-position)
					      (- y (floor (* (box-height viewport)
							     (case direction
							       (:forward 3)
							       (:backward 1)))
							  4))))))))))))
	  (clear-highlighted-intervals))))))
