;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(define-presentation-type string  ((&optional (size '*)) &key delimiters)
   :no-deftype t
   :history t
   :parser ((stream &key default)
	    (if (neq size '*)
		(stack-let ((string (make-array size :element-type 'character)))
		  (loop for i below size
			for ch = (read-char-for-accept stream)
			when (not (characterp ch))
			  do (sys:parse-ferror
			       "The string ~S is not of the required length, ~D"
			       (substring string 0 i) size)
			do (setf (char string i) ch))
		  (heapify-string (thinify-string string)))
	      (with-input-editing-options-if
		  delimiters
		  (((:activation :override) #'member delimiters))
		(multiple-value-bind (string explicitly-quoted)
		    (read-standard-token stream)
		  (when (and (not (null default))
			     (not explicitly-quoted)
			     (string-equal string ""))
		    ;; trigger default-supplying mechanism
		    (zl:parse-ferror "The NULL string is not allowed"))
		  string))))
   :printer ((object stream &key acceptably)
	     (cond ((null acceptably) (write-string object stream))
		   ((eq acceptably :very) (error 'print-not-readable :object object))
		   (t (let ((si:print-readably acceptably)
			    (si:*print-sensitive* -1)
			    (*readtable* *readtable-for-expression*))
			(write object :stream stream)))))
   :describer ((stream &key plural-count)
	       (presentation-string-pluralize "a string" stream plural-count)
	       (cond ((neq size '*)
		      (format stream " ~D characters long" size))
		     ((null delimiters))
		     (t (write-string " (end with " stream)
			(write--or--sequence
			  delimiters stream
			  #'(lambda (c s)
			      (if (char= c #\Return)
				  (write-string "Return" s)
				  (format s "~C" c))))
			(write-string ")" stream))))
   :typep ((object)
	   (and (stringp object)
		(or (eql size '*)
		    (= (length object) size))))
   :map-over-supertypes
   ((function predicate &key predicate-p recurse type)
    (with-type-decoded (nil nil pr-args) type
      (when predicate-p
	(if (eql size '*)
	    (setq predicate (merge-predicates #'stringp predicate)))	;Optimization
	(with-type-decoded (nil dargs) type
	  (setq predicate
		(compute-type-predicate #'(presentation-function string typep-function)
					dargs predicate))))
      (stack-let ((or-type `(or (vector string-char ,size) (vector character ,size))))
	;; Provide bum's rush past (vector ...) and (sequence ...)
	(merge-meta-args or-type
			 pr-args recurse function predicate)))))


(defun presentation-type-parser-lookahead (stream desired-type
					   &key
					   delimiter-char echo-space echo-string-before-blip)
  "MORE-TO-COME is NIL for nothing left, T for go ahead and accept some more,
and :ACCEPTED for `The next item is in OBJECT and TYPE.'"
  (declare (values more-to-come object type))
  (with-presentation-input-context (desired-type :stream stream) (blip)
       (progn
	 (when delimiter-char
	   (let ((ch (peek-char-for-accept stream t)))
	     (unless (compare-char-for-accept ch delimiter-char)
	       (return-from presentation-type-parser-lookahead nil))
	     (read-char-for-accept stream)
	     (when echo-space
	       (if (compare-char-for-accept (peek-char-for-accept stream) #\Space)
		   (read-char-for-accept stream)
		   (presentation-replace-input stream (send stream :read-location) " " :dont-quote t)))))
	 t)
     (t
       (when echo-string-before-blip
	 (presentation-replace-input stream (send stream :read-location)
				     echo-string-before-blip :dont-quote t))
       (echo-presentation-blip stream blip (send stream :read-location) desired-type)
       (values :accepted (presentation-blip-object blip)
	       (presentation-blip-presentation-type blip)))))

(defun sequence-check-end (stream next-type first-p)
  (declare (values more-to-come object type))
  (presentation-type-parser-lookahead
    stream next-type
    :delimiter-char #\,
    :echo-space t
    :echo-string-before-blip (and (not first-p) ", ")))

(defun recurse-subtype-if-expression-element (element-type typep-function bare-type-function
					      type predicate-p recurse function predicate)
  (when predicate-p
    (with-type-decoded (nil data-args) type
      (when (and element-type
		 (presentation-subtypep-cached element-type 'expression))
	(let* ((predicate (if (not predicate-p) predicate
			    (merge-predicates predicate bare-type-function)))
	       (predicate
		 (if (and predicate-p
			  (neq element-type '*)
			  (neq element-type 'T))
		     (compute-type-predicate typep-function data-args predicate)
		   predicate)))
	  (funcall recurse 'expression function predicate))))))

(defun recurse-supertype-if-expression-element (element-type typep-function type predicate-p
						recurse function predicate
						&optional sequence-p)
  (with-type-decoded (type-name data-args pr-args) type
     (when (or (eq element-type '*)
	       (presentation-subtypep-cached element-type 'expression))
       (let ((predicate
	       (if (and predicate-p
			(neq element-type '*)
			(neq element-type 'T))
		   (compute-type-predicate typep-function
					   data-args predicate)
		 predicate)))
	 (when sequence-p
	   (merge-meta-args type-name pr-args recurse function predicate))
	 (merge-meta-args '((expression) :escape nil) pr-args recurse function predicate)))))

(defun D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")invoke-default-preprocessor0 (object type original-type
				    &optional (default-type (type-of object)))
  (declare (values object type unchanged-p))
;  (when (t-to-t-identity-translate-p default-type (type-of object)
;				     type object)
;    (return-from invoke-default-preprocessor
;      (values object original-type t)))		;no coercion?
  (with-type-method ((real-presentation-type default-preprocessor)
		     type #'presentation-type-find-default-preprocessor
		     :error-p nil :supertype-p nil)
    (multiple-value-bind (obj type)
	(funcall default-preprocessor
		 object real-presentation-type
		 original-type default-type)
      (when (or obj type)
	(return-from invoke-default-preprocessor (values obj (or type original-type))))))
  ;; this gets called if there isn't a default preprocessor
  (values object original-type t))

(defun 1common-sequence-default-preprocessor
0       (default
	element-type	;type of each element in sequence, e.g. 1sys:printer
0	type		;type currently being accepted, e.g. 1((sequence sys:printer))
0	original-type	;top-level type, e.g. 1((token-or-type (:all) ((sequence sys:printer))))
0	default-type	;best guess as to the type of the default as determined by caller
	coercer)	;e.g., #'list
  (declare (sys:downward-funarg coercer) (values object type))
  (let ((element-type
	  (if (eq element-type '*) t element-type)))
    (flet ((presentation-subtypep-masking-bug (object subtype supertype)
	     (multiple-value-bind (subtypep ignore predicate)
		 (presentation-subtypep subtype supertype t)
	       (if (or (null subtypep) (null predicate))
		   subtypep
		 (funcall predicate object)))))
      ;; If the default is already of the type we are looking for, then we're done.
      ;; (That is, the default-type is presentation-subtypep of the original-type.)
      (when (and (presentation-subtypep-masking-bug default default-type original-type)
		 ;; Already a sequence?
		 ;;--- Special kludge for 1token-or-type0, do the "right thing" later
		 (with-type-decoded (name data-args) default-type
		    (let ((default-type (if (eq name 'token-or-type)
					    (second data-args)
					  default-type)))
		      (t-to-t-identity-translate-p default-type
						   (type-of default)
						   type default))))
	(flet ((coerce-elements (default)
		 (invoke-default-preprocessor
		   default element-type original-type default-type)))
	  ;; Still might need to coerce the elements of the sequence...
	  (let ((new-default (map 'list #'coerce-elements default)))
	    (return-from common-sequence-default-preprocessor
	      (values new-default original-type t))))))
    (when (ptypep default element-type)
      ;; If this thing is of element-type, then try to coerce it
      (multiple-value-bind (obj type unchanged-p)
	  (invoke-default-preprocessor
	    default element-type original-type default-type)
	(ignore unchanged-p)
	(funcall coercer obj type)))))

(define-presentation-type 1sequence
0      ((&optional (element-type '*))
       &key (sequence-delimiter #\,) (echo-space t)
       (element-default nil element-default-p))
   :no-deftype t
   :disallow-atomic-type t

   ;; give this a default-preprocessor that uses the default-preprocessor
   ;; for element-type, if any.
   ;;                      "string"   'sequence   'string     'string
   :default-preprocessor ((default &key type original-type default-type)
			  (common-sequence-default-preprocessor
			    default element-type type original-type default-type
			    (lambda (thing type) (values (ncons thing)
							 (if (eq (presentation-type-name type)
								 'sequence)
							     type
							     `((sequence ,type)))))))
   :history (()
	    (when (eq element-type '*)
	      (setq element-type t))
	    (values (find-accept-history element-type)))

   :presentation-type-arguments (element-type)
   :parser ((stream &key default initially-display-possibilities)
	    (when (eq element-type '*)
	      (setq element-type 'expression))
	    ;; Don't blame me, that's what he called it.
	    ;; This was too gross in LOOP.
	    (zwei:zcollecting-into (values types)
	      (loop named top
		    for provided-default = (if element-default-p
					       element-default
					       (and (plusp (length default)) (elt default 0)))
					 then (first (last values)) do
		(multiple-value-bind (val typ)
		    (accept element-type :stream stream
			    :prompt nil
			    ;; supply a default pathname to merge against, but DO NOT
			    ;; offer it as the default
			    :default provided-default
			    :provide-default nil
			    :initially-display-possibilities initially-display-possibilities
			    :additional-blip-chars `(,sequence-delimiter))
		  (zwei:zcollect values val)
		  (zwei:zcollect types typ))
		(loop
		  (multiple-value-bind (more-to-come val typ)
		      (presentation-type-parser-lookahead
			stream element-type
			:delimiter-char sequence-delimiter
			:echo-space echo-space
			:echo-string-before-blip (unless (null values)
						   (if echo-space
						       (string-append sequence-delimiter
								      #\Space)
						       (string sequence-delimiter))))

		    (ecase more-to-come
		      ((nil)
		       (return-from top
			 (values values `((sequence-enumerated . ,types)))))
		      ((t)
		       (return))
		      ((:accepted)
		       (zwei:zcollect values val)
		       (zwei:zcollect types typ))))))))
   
   :printer ((sequence stream &key acceptably)
	     (flet ((printer (elt stream)
		      (present elt element-type :stream stream :acceptably acceptably)))
	       (cond ((stringp sequence) (princ sequence stream))
		     (t
		      (format-textual-list sequence #'printer :stream stream
					   :separator (if echo-space
							  (string-append
							    sequence-delimiter #\Space)
							  (string sequence-delimiter))
					   :conjunction (and (not acceptably)
							     (char= sequence-delimiter #\,)
							     "and"))))))
   
   :describer ((stream &key plural-count)
	       (cond ((null plural-count)
		      ;; Benson's improvement 
		      ;;(WRITE-STRING "a sequence of " STREAM)
		      )
		     ((eq plural-count t) (write-string "sequences of " stream))
		     ((numberp plural-count) (format stream "~R sequences of " plural-count))
		     (t (format stream "~A sequences of " plural-count)))
	       (case element-type
		 ((*) (write-string "any type of object" stream))
		 (otherwise (describe-presentation-type
			      element-type stream t))))

   :key-function ((function original-type-name)
		  (if (eq element-type '*)
		      (funcall function original-type-name)
		    (with-presentation-type-key (inner-key element-type)
		      (stack-let ((new-type `(,original-type-name ,inner-key)))
			(funcall function new-type)))))

   :with-cache-key ((function original-type-name)
		    (if (eq element-type '*)
			(funcall function original-type-name)
		      (with-key-for-cache (inner-key element-type)
			(stack-let ((new-type `(,original-type-name ,inner-key)))
			  (funcall function new-type)))))

   :presentation-subtypep
   ((type-1 type-2)
    (cond ((or (atom type-2)
	       (null (cdr type-2))
	       (eq (second type-2) '*))
	   (values t t))
	  ((or (atom type-1)
	       (null (cdr type-1))
	       (eq (second type-1) '*))
	   (values nil t))
	  (t (presentation-subtypep (second type-1) (second type-2)))))

   :typep ((object)
	   (and (typep object 'sequence)
		;; Eliminate dotted pairs.
		(not (and (consp object)
			  (not (null (cdr (last object))))))
		(or (eq element-type '*)
		    (every (sys:named-lambda every (obj) (ptypep obj element-type))
			   object))))

   :map-over-subtypes
   ((function predicate &key for-lookup predicate-p recurse type keys-seen)
    (when (neq element-type '*)
      (labels ((recurse-on-sequence (subtype subkey element-predicate)
		 (declare (sys:downward-function)
			  (dbg:invisible-frame :presentation-handler-search))
		 (unless (eql subtype element-type)
		   (let ((predicate
			   (when predicate-p
			     (merge-predicates
			       (compute-sequence-predicate element-type element-predicate)
			       predicate))))
		     (stack-let ((sequence-type `((sequence ,subtype)))
				 (sequence-key `(sequence ,subkey)))
		       (with-key-for-cache (key sequence-type)
			 (removing-stack-key (key keys-seen)
			   (unless (already-seen-p key keys-seen)
			     (funcall function sequence-type sequence-key predicate)))))))))
	(map-over-type-hierarchy element-type nil for-lookup #'recurse-on-sequence
				 nil predicate-p)))
    (when predicate-p
      (let ((predicate (merge-predicates (compute-sequence-predicate element-type nil)
					 predicate)))
	(funcall recurse 'sequence function predicate)
	(funcall recurse 'vector function predicate)
	(funcall recurse 'list function predicate)))
    (flet ((sequence-p (object)
	     (or (consp object)
		 (vectorp object))))
      (recurse-subtype-if-expression-element element-type
					     #'(presentation-function sequence typep-function)
					     #'sequence-p
					     type predicate-p
					     recurse function predicate)))

   :map-over-supertypes
   ((function predicate &key for-lookup predicate-p recurse type keys-seen)
    (with-type-decoded (nil nil pr-args) type
      (when (neq element-type '*)
	(labels ((recurse-on-sequence (supertype superkey element-predicate)
		   (declare (sys:downward-function)
			    (dbg:invisible-frame :presentation-handler-search))
		   (unless (eql supertype element-type)
		     (let ((predicate
			     (when predicate-p
			       (merge-predicates
				 (compute-sequence-predicate element-type element-predicate)
				 predicate))))
		       (stack-let ((sequence-type `((sequence ,supertype) ,@pr-args))
				   (sequence-key `(sequence ,superkey)))
			 (with-key-for-cache (key sequence-type)
			   (removing-stack-key (key keys-seen)
			     (unless (already-seen-p key keys-seen)
			       (funcall function sequence-type sequence-key predicate)))))))))
	  (stack-let ((super-type `(or vector list)))
	    (with-key-for-cache (key super-type)
	      (removing-stack-key (key keys-seen)
		(unless (already-seen-p key keys-seen)
		  (let ((predicate (when predicate-p
				     (if (eql element-type '*)
					 predicate
				       (merge-predicates
					 (compute-sequence-predicate element-type nil)
					 predicate)))))
		    (merge-meta-args super-type pr-args recurse function predicate))))))
	  (when element-type
	    (map-over-type-hierarchy element-type t for-lookup #'recurse-on-sequence
				     nil predicate-p))))
      (recurse-supertype-if-expression-element
	element-type 
	#'(presentation-function sequence typep-function)
	type predicate-p recurse function predicate t)))
   )

(defvar *object-to-sequence-of-object-activate-p* nil)

;; Beware, this is extremely prone to breakage
;;--- This should really be fixed at the level of the 1or0 parser
(define-presentation-translator object-to-sequence-of-object
   ;; This odd to-type ensures that this only runs for true sequences,
   ;; not Lisp expressions
   (t (sequence nil)
    :tester ((ignore &key presentation input-context)
	     (when (not (null input-context))
	       (stack-let ((type `(sequence ,(presentation-type presentation)))
			   (object (list (presentation-object presentation))))
		 (let ((desired-type (presentation-input-context-presentation-type
				       input-context)))
		   ;; We need to really be in a sequence context (not reading a vanilla
		   ;; expression, for example), and the object we are pointing at has
		   ;; to be of the same type as the sequence we're looking for.
		   (and (presentation-subtypep '(sequence nil) desired-type)
			(presentation-type-applies-p type desired-type object)))))))
   (object &key presentation)
  ;; This bit of magic makes this translator complete the field when reading a
  ;; command (without activating the command), and never activate anywhere else.
  (if *object-to-sequence-of-object-activate-p*
      (values (list object) `(sequence ,(presentation-type presentation)))
    ;; :ACTIVATE NIL is not the same as not specifying :ACTIVATE at all!
    (values (list object) `(sequence ,(presentation-type presentation))
	    :activate nil)))

;;; Map over a sequence.
(defsubst compute-sequence-predicate (type predicate)
  (with-key-for-cache (key type)
    (encache-predicate (key predicate)
      (compute-sequence-predicate-internal
	(heap-copy-presentation-type type *predicate-area* 2)
	predicate))))

(defun compute-sequence-predicate-internal (type predicate)
  (sys:named-lambda predicate (object)
    (declare (copyable-closure))
    (block predicate
      (and (typep object 'sequence)
	   (or (eql type 'expression)		;speedy kludge
	       (etypecase object
		 (vector (every (lambda (x) (ptypep x type)) object))
		 (null t)
		 (cons (loop for i = object then (cdr i)
			     until (atom i)
			     unless (ptypep (first i) type)
			       do (return-from predicate nil)
			     finally
			       (if i		;Bad end, not a sequence.
				   (return-from predicate nil)
				 (return t))))))
	   (or (null predicate)
	       (etypecase object
		 (vector (every predicate object))
		 (null t)
		 (cons (loop for i = object then (cdr i)
			     until (atom i)
			     unless (funcall predicate (first i))
			       do (return-from predicate nil)
			     finally
			       (if i
				   (return-from predicate  nil)
				 (return t))))))))))


(defun compute-vector-predicate (type size predicate)
  (if (and (eq type '*)
	   (eq size '*))
      (merge-predicates #'vectorp predicate)
    (with-key-for-cache (key type)
      (encache-predicate (key (unlist size) predicate)
	(compute-vector-predicate-internal
	  (heap-copy-presentation-type type *predicate-area* 2)
	  size predicate)))))

(defun compute-vector-predicate-internal (type size predicate)
  (labels ((predicate (object)
	     (declare (copyable-closure))
	     (and (typep object 'vector)
		  (or (eq size '*)
		      (= size (length object)))
		  (or (eq type '*)
		      (let ((array-type (array-element-type object)))
			(or (equal type array-type)
			    (and (presentation-subtypep-cached type array-type)
				 (presentation-subtypep-cached array-type type)))))
		  (or (null predicate)
		      (funcall predicate object)))))
    #'predicate))

(define-presentation-type vector ((&optional (element-type '*) (size '*)) &rest options)
   :no-deftype t
   :data-arguments-are-disjoint t
   :presentation-type-arguments (element-type)

   :history (()
	     (when (eq element-type '*)
	       (setq element-type t))
	     (values (find-accept-history element-type)
		     ;; we have extended the protocol for :HISTORY to return both the
		     ;; history to use and a function to funcall on each history element
		     ;; to convert it to one of the correct type.  This will probably only
		     ;; be used by SEQUENCE.  (And VECTOR!)
		     #'(lambda (history-element)
			 (make-presentation-history-element
			   :object (make-array 1
				    :initial-element (pres-hist-elt-object history-element))
			   :type `((vector ,element-type ,size))))))

   :parser ((stream &key default type original-type)
	    (let ((value (let ((default (or default
					    (presentation-type-default original-type))))
			   (accept `((sequence ,element-type))
				   :original-type original-type
				   :stream stream
				   :prompt nil
				   :default default))))
	      (unless (or (eq size '*)
			  (= (length value) size))
		(error 'object-parsed-not-of-type
		       :object value :type original-type))
	      (with-type-decoded (type-name type-dargs) type
		(coerce value `(,type-name ,@type-dargs)))))
   
   :describer ((stream &key plural-count)
	       (unless (eq size '*)
		 (format stream "~D " size))
	       (cond ((null plural-count)
		      ;; Benson's improvement 
		      ;;(WRITE-STRING "a vector of " STREAM)
		      )
		     ((eq plural-count t) (write-string "vectors of " stream))
		     ((numberp plural-count) (format stream "~R vectors of " plural-count))
		     (t (format stream "~A vectors of " plural-count)))
	       (case element-type
		 ((*) (write-string "any type of object" stream))
		 (otherwise (describe-presentation-type
			      element-type stream t))))

   :key-function ((function original-type-name)
		  (if (and (eq element-type '*) (eq size '*))
		      (funcall function original-type-name)
		    (with-presentation-type-key (inner-key element-type)
		      (if (eq size '*)
			  (stack-let ((new-type `(,original-type-name ,inner-key)))
			    (funcall function new-type))
			(stack-let ((new-type `(,original-type-name ,inner-key ,size)))
			  (funcall function new-type))))))

   :with-cache-key ((function original-type-name)
		    (if (and (eq element-type '*) (eq size '*))
			(funcall function original-type-name)
		      (with-key-for-cache (inner-key element-type)
			(if (eq size '*)
			    (stack-let ((new-type `(,original-type-name ,inner-key)))
			      (funcall function new-type))
			  (stack-let ((new-type `(,original-type-name ,inner-key ,size)))
			    (funcall function new-type))))))

   :presentation-subtypep
   ((type-1 type-2)
    (let ((size-1 (or (third type-1) '*))
	  (size-2 (or (third type-2) '*)))
      (cond ((or (atom type-2)
		 (null (cdr type-2))
		 (eq (second type-2) '*))
	     (values (or (eq size-2 '*)
			 (eql size-1 size-2))
		     t))
	    ((or (atom type-1)
		 (null (cdr type-1))
		 (eq (second type-1) '*))
	     (values nil t))
	    ((and (or (eq size-2 '*)
		      (eql size-1 size-2)))
	     (values (let ((t-1 (second type-1))
			   (t-2 (second type-2)))
		       (or (eql t-1 t-2)
			   (eql t-2 '*)
			   (and (presentation-subtypep (second type-1) (second type-2))
				(presentation-subtypep (second type-2) (second type-1)))))
		     t))
	    (t (values nil t)))))

   :typep ((object)
	   (and (vectorp object)
		(or (eq size '*) (null size) (= (vector-length object) size))
		(or (eq element-type '*)
		    (let ((array-type (array-element-type object)))
		      (or (equal array-type element-type)
			  (and (presentation-subtypep-cached array-type element-type)
			       (presentation-subtypep-cached element-type array-type)))))))

   :map-over-subtypes
   ((function predicate &key predicate-p recurse type keys-seen)
    (let ((predicate (when predicate-p
		       (compute-vector-predicate element-type size predicate))))
      (macrolet ((do-type ((var type) &body body)
		   (let ((type-key (gensymbol "TYPE-KEY-"))
			 (cache-key (gensymbol "TYPE-KEY-")))
		     `(stack-let ((,var ,type))
			(with-presentation-type-key (,type-key ,var)
			  (with-key-for-cache (,cache-key ,var)
			    (removing-stack-key (,cache-key keys-seen)
			      (unless (already-seen-p ,cache-key keys-seen)
				(funcall function ,var ,type-key predicate))
			      ,@body)))))))
	(do-type (vector-type `(vector ,element-type ,size))
	  (do-type (array-type `(array ,element-type (,size)))
	    (recurse-subtype-if-expression-element
	      element-type
	      #'(presentation-function vector typep-function)
	      #'vectorp type predicate-p
	      recurse function predicate))))))

   :map-over-supertypes
   ((function predicate &key predicate-p recurse type keys-seen)
    (with-type-decoded (nil nil pr-args) type
      (let ((predicate (when predicate-p
			 (compute-vector-predicate element-type size predicate))))
	(macrolet ((do-type ((var type &key merge-meta) &body body)
		     (let ((type-key (gensymbol "TYPE-KEY-"))
			   (cache-key (gensymbol "TYPE-KEY-")))
		       `(stack-let ((,var ,type))
			  (with-presentation-type-key (,type-key ,var)
			    (with-key-for-cache (,cache-key ,var)
			      (removing-stack-key (,cache-key keys-seen)
				(unless (already-seen-p ,cache-key keys-seen)
				  ,(if merge-meta
				       `(merge-meta-args ,var pr-args
							 function ,type-key predicate)
				     `(funcall function ,var ,type-key predicate)))
				,@body)))))))
	  (stack-let ((size-key `(,size)))
	    (when (eq size '*)
	      (setq size-key nil))
	    (do-type (vector-type `((vector ,element-type ,size) ,@pr-args))
	      (when size-key
		(do-type (vector-type `((vector ,element-type) ,@pr-args))))
	      (unless (already-seen-p 'vector keys-seen)
		(merge-meta-args 'vector pr-args function 'vector predicate))
	      (stack-let ((type-1 `((array ,element-type ,size) ,@pr-args))
			  (type-2 `((array ,element-type (,size)) ,@pr-args)))
		(do-type (array-type (if (eq size '*) type-2 type-1))
		  (when size-key
		    (do-type (array-type `((array ,element-type) ,@pr-args))))
		  (unless (already-seen-p 'array keys-seen)
		    (merge-meta-args 'array pr-args function 'array predicate))
		  (do-type (sequence-type `(sequence ,element-type) :merge-meta t)
		    (unless (already-seen-p 'sequence keys-seen)
		      (merge-meta-args 'sequence pr-args
				       function 'sequence predicate))
		    (recurse-supertype-if-expression-element
		      element-type
		      #'(presentation-function vector typep-function)
		      type predicate-p recurse function predicate))))))))))

   )

(define-presentation-type array ((&optional (element-type '*) (dimensions '*))
				 &rest write-options
				 &key (print-contents t print-contents-supplied-p)
				 (initial-element nil initial-element-supplied-p)
				 (initial-contents nil initial-contents-supplied-p)
				 adjustable fill-pointer area leader-length
				 named-structure-symbol
				 (leader-element-types '(integer expression))
				 &allow-other-keys)
   :no-deftype t
   :data-arguments-are-disjoint t
   :presentation-type-arguments (element-type)

   :history nil

   ;;--- This should also establish a top-level context for an array of
   ;;--- the same element types and dimensions, so that clicking on the
   ;;--- whole thing will cause the whole thing to be accepted.  Later...
   :parser
     ((stream)
      (let ((ch))
	(when (eq dimensions '*)
	  (setq dimensions
		(make-list
		  (accept `((integer 0 (,array-rank-limit))
			    :description
			    ,(format nil "an array rank (less than ~D)"
			       array-rank-limit))
			  :provide-default nil
			  :prompt
			  (format nil
			      "number of dimensions (less than ~D)"
			    array-rank-limit)
			  :activation-chars '(#\End)
			  :additional-blip-chars '(#\Space #\Return)
			  :stream stream)
		  :initial-element '*))
	  ;; Gobble the delimiter
	  (setq ch (read-char-for-accept stream)))
	(when (integerp dimensions)
	  (setq dimensions (make-list dimensions :initial-element '*)))
	(unless (listp dimensions)
	  (error "~S is neither an array rank nor a list of array dimensions" dimensions))
	(unless (< (length dimensions) array-rank-limit)
	  (error "~S is too many dimensions for an array." (length dimensions)))
	(loop for i from 1 to (length dimensions)
	      do
	  (when (eq (nth (1- i) dimensions) '*)
	    (setf (nth (1- i) dimensions)
		  (accept `((integer 0 (,array-dimension-limit))
			    :description ,(format nil "the ~:R dimension" i))
			  :provide-default nil
			  :activation-chars '(#\End)
			  :additional-blip-chars '(#\Space #\, #\Return)
			  :stream stream)))
	  ;; Gobble (and ignore) the delimiter
	  (setq ch (read-char-for-accept stream)))
	(dolist (dim dimensions)
	  (unless (< dim array-dimension-limit)
	    (error "~D exceeds the limit on array dimensions." dim)))
	(unless (< (apply #'* dimensions) array-total-size-limit)
	  (parse-error "The dimensions ~D result in an array that is too large.~@
			      The limit is ~D."
		       dimensions
		       array-total-size-limit))
	(let ((array (make-array dimensions
				 :element-type
				 (cond ((eq element-type '*) t)
				       ((presentation-subtypep element-type 'bit)
					'(unsigned-byte 1))
				       ((presentation-subtypep element-type
							       '(unsigned-byte 2))
					'(unsigned-byte 2))
				       ((presentation-subtypep element-type
							       '(unsigned-byte 4))
					'(unsigned-byte 4))
				       ((presentation-subtypep element-type
							       '(unsigned-byte 8))
					'(unsigned-byte 8))
				       ((presentation-subtypep element-type
							       '(unsigned-byte 16))
					'(unsigned-byte 16))
				       ((presentation-subtypep element-type 'fixnum)
					'fixnum)
				       ((presentation-subtypep element-type 'boolean)
					'boolean)
				       ((presentation-subtypep element-type 'string-char)
					'string-char)
				       ((presentation-subtypep element-type 'character)
					'character)
				       (t t))					     
				 :initial-element initial-element
				 :initial-contents initial-contents
				 :adjustable adjustable
				 :fill-pointer fill-pointer
				 :area area
				 :leader-length leader-length
				 :named-structure-symbol named-structure-symbol)))
	  (when (or leader-length fill-pointer)
	    (loop for i below (max (if fill-pointer 0 1)
				   (if leader-length leader-length 0))
		  for previous-type = nil then (or type previous-type)
		  for type in leader-element-types
		  do
	      (setf (array-leader array i)
		    (accept type
			    :prompt (format nil "leader element ~D:" i)
			    :activation-chars '(#\End)
			    :additional-blip-chars '(#\Space #\Return)
			    :stream stream))
	      (setq ch (read-char-for-accept stream))))
	  (si:with-rem-keywords (options write-options
				 '(:print-contents :fill-pointer
				   :initial-contents :adjustable
				   :initial-element :area
				   :leader-length
				   :named-structure-symbol
				   :leader-element-types))
	    (stack-let ((expression-type `((expression) ,@options)))
	      (if (null dimensions)
		  (setf (aref array) 
			(prog1
			  (multiple-value-call
			    #'accept
			    (if (eq element-type '*) expression-type element-type)
			    :activation-chars '(#\End)
			    :additional-blip-chars '(#\Space #\Return)
			    :prompt "[]:"
			    (if (or initial-element-supplied-p
				    initial-contents-supplied-p)
				(values :default (aref array)
					:provide-default t)
			      (values)))
			  (setq ch (read-char-for-accept stream))))
		(let ((location (make-list (length dimensions) :initial-element 0)))
		  (labels ((increment (location-list dimensions superior)
			     (declare (sys:downward-function))
			     (let ((new (incf (first location-list))))
			       (if (< new dimensions)
				   t
				 (setf (first location-list) 0)
				 (if (not superior)
				     nil
				   (funcall superior)))))
			   (call-incrementer (continuation &optional (location-list location)
							   (size-list dimensions)
							   superior)
			     (declare (sys:downward-function))
			     (labels ((incrementer ()
					(declare (sys:downward-function))
					(increment location-list (first size-list) superior)))
			       (if location-list
				   (call-incrementer continuation (rest location-list)
						     (rest size-list)
						     #'incrementer)
				 (funcall continuation superior))))
		       (accept-elements (incrementer)
			 (declare (sys:downward-function))
			 (unless (equal location dimensions)	;All dimensions zero
			   (loop do
			     (setf (apply #'aref array location)
				   (multiple-value-call
				     #'accept
				     (if (eq element-type '*)
					 expression-type
				       element-type)
				     :activation-chars '(#\End)
				     :additional-blip-chars '(#\Space #\Return)
				     :prompt (format nil "[~{~D~^,~}]:" location)
				     (if (or initial-element-supplied-p
					     initial-contents-supplied-p)
					 (values :default (apply #'aref array location)
						 :provide-default t)
				       (values))))
			     (setq ch (read-char-for-accept stream))
				 while (funcall incrementer)))))
		    (call-incrementer #'accept-elements))))))
	  ;; Put the last delimiter back.
	  (unread-char-for-accept ch stream)
	  array)))

   :printer
     ((object stream &key acceptably original-type)
      (si:with-rem-keywords (other-options write-options
			     '(:print-contents :initial-element
			       :initial-contents :adjustable :fill-pointer
			       :area :leader-length
			       :named-structure-symbol
			       :leader-element-types))
	(present object `((expression)
			  :array ,(if print-contents-supplied-p
				      print-contents
				    (getf other-options :array print-contents))
			  ,@other-options)
		 :acceptably acceptably
		 :original-type original-type
		 :stream stream)))
   :description "an array"
   :key-function
     ((function original-type-name)
      ;; Canonicalize (* * *) to 3
      (let ((ndimensions (if (and (listp dimensions)
				  (loop for dim in dimensions
					always (eq dim '*)))
			     (length dimensions)
			     dimensions)))
	(if (and (eq element-type '*) (eq dimensions '*))
	    (funcall function original-type-name)
	  (with-presentation-type-key (inner-key element-type)
	    (if (eq dimensions '*)
		(stack-let ((new-type `(,original-type-name ,inner-key)))
		  (funcall function new-type))
	      (stack-let ((new-type `(,original-type-name ,inner-key ,ndimensions)))
		(funcall function new-type)))))))

   :with-cache-key
     ((function original-type-name)
      ;; Canonicalize (* * *) to 3
      (let ((ndimensions (if (and (listp dimensions)
				  (loop for dim in dimensions
					always (eq dim '*)))
			     (length dimensions)
			     dimensions)))
	(if (and (eq element-type '*) (eq dimensions '*))
	    (funcall function original-type-name)
	  (with-key-for-cache (inner-key element-type)
	    (if (eq dimensions '*)
		(stack-let ((new-type `(,original-type-name ,inner-key)))
		  (funcall function new-type))
	      (stack-let ((new-type `(,original-type-name ,inner-key ,ndimensions)))
		(funcall function new-type)))))))

   :typep
     ((object)
      (and (arrayp object)
	   (cond ((eq dimensions '*))
		 ((integerp dimensions)
		  (and (= (array-rank object) 1)
		       (= (length object) dimensions)))
		 ((listp dimensions)
		  (and (= (length dimensions) (array-rank object))
		       (loop for dim in dimensions
			     for i from 0
			     always (or (eq dim '*)
					(= dim (array-dimension object i)))))))
	   (or (eq element-type '*)
	       (let ((array-type (array-element-type object)))
		 (or (eql element-type array-type)
		     (equal element-type array-type)
		     (and (presentation-subtypep-cached array-type element-type)
			  (presentation-subtypep-cached element-type array-type)))))))

   :presentation-subtypep
     ((type-1 type-2)
      (let ((dimensions-1 (if (atom type-1) '* (or (third type-1) '*)))
	    (dimensions-2 (if (atom type-2) '* (or (third type-2) '*))))
	;; Canonicalize (* * *) to 3
	(when (and (listp dimensions-1)
		   (loop for dim in dimensions-1
			 always (eq dim '*)))
	  (setq dimensions-1 (length dimensions-1)))
	(when (and (listp dimensions-2)
		   (loop for dim in dimensions-2
			 always (eq dim '*)))
	  (setq dimensions-2 (length dimensions-2)))
	(let ((dimensions-subtypep (cond ((eq dimensions-2 '*) t)
					 ((eq dimensions-1 '*) nil)
					 ((equal dimensions-1 dimensions-2) t)
					 ((and (integerp dimensions-2)
					       (listp dimensions-1)
					       (equal (length dimensions-1) dimensions-2))
					  t)
					 ((not (listp dimensions-2)) nil)
					 ((not (listp dimensions-1)) nil)
					 ((not (= (length dimensions-1) (length dimensions-2)))
					  nil)
					 (t (loop for s1 in dimensions-1
						  for s2 in dimensions-2
						  always (or (eql s1 s2)
							     (eql s2 '*)))))))
	  (cond ((or (atom type-2)
		     (null (cdr type-2)))
		 (values t t))
		((eq (second type-2) '*)
		 (values dimensions-subtypep t))
		((or (atom type-1)
		     (null (cdr type-1))
		     (eq (second type-1) '*))
		 (values nil t))
		(dimensions-subtypep
		 (values (let ((t-1 (second type-1))
			       (t-2 (second type-2)))
			   (or (eql t-1 t-2)
			       (equal t-1 t-2)
			       (and (presentation-subtypep-cached t-1 t-2)
				    (presentation-subtypep-cached t-2 t-1))))
			 t))
		(t (values nil t))))))

   :map-over-subtypes
     ((function predicate &key for-lookup predicate-p recurse type keys-seen)
      (when (neq element-type '*)
	(let ((vector-p (or (eql dimensions 1)
			    (and (listp dimensions)
				 (= (length dimensions) 1)))))
	  ;;--- We need to compute-array-predicate somewhere, but where?
	  (macrolet ((do-type ((var type) &body body)
		       (let ((type-key (gensymbol "TYPE-KEY-"))
			     (cache-key (gensymbol "TYPE-KEY-")))
			 `(stack-let ((,var ,type))
			    (with-presentation-type-key (,type-key ,var)
			      (with-key-for-cache (,cache-key ,var)
				(removing-stack-key (,cache-key keys-seen)
				  (unless (already-seen-p ,cache-key keys-seen)
				    (funcall function ,var ,type-key predicate))
				  ,@body)))))))

	    (unless (or (and for-lookup vector-p)
			(eql type element-type))
	      (unless (eql type element-type)
		(do-type (array-type `(array ,element-type ,dimensions))))
	      (unless for-lookup
		(when vector-p
		  (do-type (vector-type `(vector ,element-type ,(if (listp dimensions)
								    (first dimensions)
								    '*))))))))))
      (recurse-subtype-if-expression-element element-type
					     #'(presentation-function array typep-function)
					     #'arrayp type predicate-p
					     recurse function predicate))

   :map-over-supertypes
     ((function predicate &key for-lookup predicate-p recurse type keys-seen)
      (with-type-decoded (nil nil pr-args) type
	 (when element-type
	   (let ((predicate (when predicate-p
			      (compute-array-predicate element-type dimensions predicate))))
	     (macrolet ((do-type ((var type &key merge-meta) &body body)
			  (let ((type-key (gensymbol "TYPE-KEY-"))
				(cache-key (gensymbol "TYPE-KEY-")))
			    `(stack-let ((,var ,type))
			       (with-presentation-type-key (,type-key ,var)
				 (with-key-for-cache (,cache-key ,var)
				   (removing-stack-key (,cache-key keys-seen)
				     (unless (already-seen-p ,cache-key keys-seen)
				       ,(if merge-meta
					    `(merge-meta-args ,var pr-args
							      function ,type-key predicate)
					  `(funcall function ,var ,type-key predicate)))
				     ,@body)))))))
	       (do-type (array-type `((array ,element-type ,dimensions) ,@pr-args))
		 (unless (eq dimensions '*)
		   (do-type (array-type `((array ,element-type) ,@pr-args))))
		 (when (and (not for-lookup)
			    (or (eql dimensions 1)
				(and (listp dimensions)
				     (= (length dimensions) 1))))
		   (do-type (vector-type `((vector ,element-type ,(if (listp dimensions)
								      (first dimensions)
								    '*))
					   ,@pr-args))
		     (unless (eq dimensions '*)	;nugatory test
		       (do-type (vector-type `((vector ,element-type) ,@pr-args))))
		     ;; Sequences lack a dimensions, so pass in a predicate.
		     (do-type (sequence-type `((sequence ,element-type)) :merge-meta t)
		       (unless (already-seen-p 'sequence keys-seen)
			 (merge-meta-args 'sequence pr-args
					  function 'sequence predicate)))))
		 (recurse-supertype-if-expression-element
		   element-type
		   #'(presentation-function array typep-function)
		   type predicate-p
		   recurse function predicate)))))))

     )

;;; Map over an array.
(defun compute-array-predicate (type dimensions predicate)
  (when (and (listp dimensions)
	     (null (cdr dimensions))
	     (not (eql (car dimensions) '*)))
    (setq dimensions (car dimensions)))
  (when (eql (presentation-type-name type) 'sys:expression)
    (setq type t))
  (with-key-for-cache (key type)
    (encache-predicate (key dimensions predicate)
      (compute-array-predicate-internal
	(heap-copy-presentation-type type *predicate-area*)
	(copy-if-necessary dimensions *predicate-area*)
	predicate))))

;; Separate function to avoid consing the environment until we're ready.
(defun compute-array-predicate-internal (type dimensions predicate)
  (labels ((predicate (object)
	     (declare (copyable-closure))
	     (and (typep object 'array)
		  (or (eql dimensions '*)
		      (if (atom dimensions)
			  (and (= (array-rank object) 1)
			       (= dimensions (array-dimension object 0)))
			(and (= (array-rank object) (length dimensions))
			     (loop for s in dimensions
				   for i from 0
				   always (or (eql s '*)
					      (= s (array-dimension object i)))))))
		  (or (eql type '*)
		      (let ((array-type (array-element-type object)))
			(or (eql array-type type)
			    (equal array-type type)
			    (and (presentation-subtypep-cached array-type type)
				 (presentation-subtypep-cached type array-type)))))
		  (or (null predicate)
		      (funcall predicate object)))))
    #'predicate))

(define-presentation-type bit-vector ((&optional (size '*)))
   :no-deftype t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse type predicate-p)
    (when predicate-p
      (setq predicate (merge-predicates #'bit-vector-p predicate)))
    (with-type-decoded (ignore ignore pr-args) type
      (stack-let ((new-type `((vector bit ,size) ,@pr-args)))
	(funcall recurse new-type function predicate))))
   :description "a bit vector")

(define-presentation-type simple-vector ((&optional (element-type '*) (size '*)))
   :no-deftype t
   :data-arguments-are-disjoint t
   :map-over-subtypes ((function predicate) (ignore function predicate))
   :map-over-supertypes
   ((function predicate &key recurse type predicate-p)
    (when predicate-p
      (setq predicate (merge-predicates #'cli::array-is-simple-p predicate)))
    (labels ((do-supertype (new-type-name)
	       (with-type-decoded (nil data-args pr-args) type
		  (stack-let ((new-type `((,new-type-name ,@data-args) ,@pr-args)))
		    (when (null pr-args)
		      (setq new-type (car new-type))
		      (when (null data-args)
			(setq new-type (car new-type))))
		    (funcall recurse new-type function predicate)))))
      (do-supertype 'vector)
      (do-supertype 'simple-array)))
   :description "a simple vector")

(defun construct-vector-size-predicate (predicate size)
  (if (or (null size)
	  (eq size '*))
      predicate
    (encache-predicate (predicate size)
      (construct-vector-size-predicate-internal predicate size))))

;;; Split to avoid consing closures if not needed.
(defun construct-vector-size-predicate-internal (predicate size)
  (labels ((check-vector-size (object)
	     (declare (copyable-closure))
	     (and (or (null predicate)
		      (funcall predicate object))
		  (vectorp object)
		  ( size (length object)))))
    #'check-vector-size))

(defun construct-array-size-predicate (predicate size)
  (if (or (null size)
	  (eq size '*))
      predicate
    (encache-predicate (predicate size)
      (construct-array-size-predicate-internal
	predicate
	(sys:copy-if-necessary size *predicate-area*)))))

;;; Split to avoid consing closures if not needed.
(defun construct-array-size-predicate-internal (predicate size)
  (labels ((check-array-size (object)
	     (declare (copyable-closure))
	     (and (or (null predicate)
		      (funcall predicate object))
		  (if (listp size)
		      (loop for i from 0
			    for s in size
			    for d = (array-dimension object i)
			    always (or (null s)
				       (eq s '*)
				       (and d ( s d))))
		    ( size (length object))))))
    #'check-array-size))


(defflavor sequence-enumerated-needs-more-inputs (which-more)
	   (object-parsed-not-of-type)
  :initable-instance-variables)

(defmethod (:report sequence-enumerated-needs-more-inputs) (stream)
  (write-string "Not enough values entered.  We still need " stream)
  (describe-presentation-type
    (if (= (length which-more) 1)
	(car which-more)
	`((sequence-enumerated . ,which-more)))
    stream)
  (write-char #\. stream))

(compile-flavor-methods sequence-enumerated-needs-more-inputs)

(defun clever-sequence-enumerated-presentation-type-expansion (types)
  (let ((new-types (delete-duplicates types)))
    (if (= (length new-types) 1)
	(first new-types)
      `(or ,@new-types))))

(define-presentation-type sequence-enumerated
      ((&rest data-types)
       &key (sequence-delimiter #\,) (echo-space t) (element-defaults nil element-defaults-p))
   :presentation-type-arguments (data-types)
   :parser ((stream &key original-type initially-display-possibilities)
	    (let ((types-to-go data-types)
		  (element-defaults-to-go element-defaults))
	      (zwei:zcollecting-into (values types)
		(loop
		  (multiple-value-bind (val typ)
		      (accept (pop types-to-go)
			      :stream stream
			      :prompt nil
			      :provide-default (and element-defaults-p element-defaults-to-go)
			      :display-default nil
			      :default (pop element-defaults-to-go)
			      :initially-display-possibilities initially-display-possibilities
			      :additional-blip-chars `(,sequence-delimiter))
		    (zwei:zcollect values val)
		    (zwei:zcollect types typ))
		  (when types-to-go
		    (loop
		      (multiple-value-bind (more-to-come val typ)
			  (presentation-type-parser-lookahead
			    stream (first types-to-go)
			    :delimiter-char sequence-delimiter
			    :echo-space echo-space
			    :echo-string-before-blip (unless (null values)
						       (if echo-space
							   (string-append sequence-delimiter
									  #\Space)
							   (string sequence-delimiter))))
			(ecase more-to-come
			  ((nil)
			   (error 'sequence-enumerated-needs-more-inputs
				  :type original-type :object values
				  :which-more types-to-go))
			  ((t)
			   (return))
			  ((:accepted)
			   (zwei:zcollect values val)
			   (zwei:zcollect types typ)
			   (pop types-to-go)
			   (when (null types-to-go)
			     (return)))))))
		  (when (null types-to-go)
		    (return (values values `((sequence-enumerated . ,types)))))))))

   :printer ((object stream &key acceptably)
	     ;;(WRITE-STRING "a sequence of " STREAM)
	     ;; Double walk needed here, can't use write--and--sequence.
	     ;; Also, have to worry about ACCEPTABLY
	     (formatting-textual-list (stream :conjunction (and (not acceptably)
								(char= sequence-delimiter #\,)
								"and")
					      :separator (if echo-space
							     (string-append
							       sequence-delimiter #\Space)
							     (string sequence-delimiter)))
	       (map nil
		    #'(lambda (elem type)
			(formatting-textual-list-element (stream)
			  (present elem type :stream stream :acceptably acceptably)))
		    object
		    data-types)))

   :describer ((stream &key plural-count)
	       (cond ((null plural-count)
		      ;; Benson's improvement  (i.e., the commenting-out thereof)
		      ;;(WRITE-STRING "a sequence of " STREAM)
		      )
		     ((eq plural-count t) (write-string "sequences of " stream))
		     ((numberp plural-count) (format stream "~R sequences of " plural-count))
		     (t (format stream "~A sequences of " plural-count)))

	       (write--and--sequence
		 (summarize-list-contents data-types) stream
		 (lambda (element stream)
		   (destructuring-bind (count . type) element
		     (describe-presentation-type type stream count)))))

   :key-function ((function original-type-name)
		  (stack-let ((name-and-types `(,original-type-name ,@data-types)))
		    (call-with-presentation-type-keys function name-and-types)))

   :with-cache-key ((function original-type-name)
		    (stack-let ((name-and-types `(,original-type-name ,@data-types)))
		      (call-with-presentation-type-cache-keys function name-and-types)))

   :presentation-subtypep
     ((type-1 type-2)
      (cond ((eql type-1 type-2)
	     (values t t))
	    ((and (atom type-1) (atom type-2))
	     (values nil t))
	    ((or (atom type-1) (atom type-2))
	     (values nil t))
	    ((equal type-1 type-2)
	     (values t t))
	    (( (length type-1) (length type-2))
	     (values nil t))
	    (t (loop with value = t
		     with known = t
		     for t1 in (cdr type-1)
		     for t2 in (cdr type-2)
		     do
		 (multiple-value-bind (element-subtypep element-known-p)
		     (presentation-subtypep t1 t2)
		   (when (null element-subtypep)
		     (setq value nil))
		   (if (not element-known-p)
		       (setq known nil)
		     (when (null element-subtypep)
		       (return (values nil t)))))
		     finally (return (values value known))))))

   :typep ((object)
	   (and (ptypep object 'sequence)
		;; Eliminate dotted pairs.
		(not (and (consp object)
			  (not (null (cdr (last object))))))
		(= (length object) (length data-types))
		(every #'ptypep object data-types)))

   :map-over-supertypes-and-subtypes
     ((function predicate &key type recurse keys-seen predicate-p supertype-p)
      (with-type-decoded (nil nil pr-args) type
	 (when data-types
	   ;; Same kludge as the one we need for 1member0 for the same reason
	   (already-seen-p 'sequence-enumerated keys-seen))
	 (if data-types
	     (when (or predicate-p supertype-p)
	       (let ((pred (compute-type-predicate
			     #'(presentation-function sequence-enumerated typep-function)
			     data-types predicate)))
		 ;;--- This filters out too much, but that's better than
		 ;;--- not filtering enough.  For example, without this,
		 ;;--- the following takes 30 seconds to return:
		 ;;--- (ptypep '((1 1) (2 2)) '(sequence (sequence-enumerated integer integer)))
		 (stack-let ((sequence-type `((sequence-enumerated ,@data-types) ,@pr-args)))
		   (with-key-for-cache (key sequence-type)
		     (removing-stack-key (key keys-seen)
		       (unless (already-seen-p key keys-seen)
			 (stack-let ((element-type `(or ,@data-types)))
			   (when (null (cdr data-types))	;(= (length data-types) 1)
			     (setq element-type (first data-types)))
			   (stack-let ((sequence `(sequence ,element-type)))
			     (merge-meta-args sequence pr-args recurse function pred)))1))))0))
	   (merge-meta-args nil pr-args recurse function predicate))))
   )

;;; Just like sequence-element, but intersecting with the expression hierarchy.
(define-presentation-type member-sequence ((sequence &key (test #'eql))
					   &key (partial-completers '(#\Space)))
   :disallow-atomic-type t

   :abbreviation-for `((sequence-element ,sequence :test ,test)
		       :name-key ,#'token-element-string
		       :partial-completers ,partial-completers)

   ;; Why can't you inherit these?
   :describer ((stream &key plural-count original-type)
	       (member-describer sequence stream plural-count original-type))


   :typep
     ((elem)
      (position elem sequence :test test))

   :map-over-supertypes-and-subtypes
     ((function predicate &key type recurse keys-seen predicate-p supertype-p)
      (with-type-decoded (nil dargs pr-args) type
	 (let ((length (length sequence)))
	   (unless (zerop length)
	     (already-seen-p 'member-sequence keys-seen))
	   (stack-let ((se-type `((sequence-element ,sequence :test ,test)
				  :name-key ,#'token-element-string
				  :partial-completers ,partial-completers)))
	     (merge-meta-args se-type pr-args recurse function predicate))
	   (if (not (zerop length))
	       (when (or predicate-p supertype-p)
		 (let ((pred (compute-type-predicate
			       #'(presentation-function member-sequence typep-function)
			       dargs predicate)))
		   (merge-meta-args '((sys:expression) :escape nil) pr-args
				    recurse function pred)))
	     (merge-meta-args nil pr-args recurse function predicate)))))

     )

;;; HIGHLIGHTING-TEST is a presentation argument rather than a data argument because
;;; it can't be a data argument because the data argument is an &REST list of things.
;;; If it were a data argument we'd call it TEST.  Since we can't make it a data argument,
;;; we decided to call it HIGHLIGHTING-TEST, leaving only this comment as a note
;;; to future generations.
(define-presentation-type member ((&rest elements)
				  &key (partial-completers '(#\Space))
				       (highlighting-test #'eq))
   :no-deftype t

   :typep ((elem) (member elem elements))

   :choose-displayer ((stream object query-identifier &key original-type)
		      (accept-values-choose-from-sequence stream elements
							  object query-identifier
							  :highlighting-test highlighting-test
							  :type original-type))
				 
   :parser ((stream &key type original-type initially-display-possibilities)
	    (values
	      (complete-from-sequence elements stream
				      :type original-type
				      :name-key #'token-element-string
				      :initially-display-possibilities
				       initially-display-possibilities
				      :partial-completers partial-completers
				      :complete-activates (accept-activation-p #\Complete))
	      type))

   :printer ((object stream)
	     (write-string (token-element-string object) stream))
   
   :presentation-subtypep ((type-1 type-2)
			   (with-type-decoded (nil data-1) type-1
			     (with-type-decoded (nil data-2) type-2
			       (member-subtypep data-1 data-2))))

   :describer ((stream &key plural-count original-type)
	       (member-describer elements stream plural-count original-type))

   :map-over-supertypes-and-subtypes
     ((function predicate &key type recurse keys-seen predicate-p supertype-p)
      (with-type-decoded (nil nil pr-args) type
	(when elements
	  ;; Weird kludge; 1(member)0 is not a supertype of 1(member :foo)0.
	  (already-seen-p 'member keys-seen))
	(if elements
	    (when (or predicate-p supertype-p)
	      (let ((pred (compute-type-predicate
			    #'(presentation-function member typep-function)
			    elements predicate)))
		(merge-meta-args '((sys:expression) :escape nil) pr-args
				 recurse function pred)))
	  (merge-meta-args nil pr-args recurse function predicate)))))

#||
;;--- Cannot do this because 1member0 is a CL type whose position is already
;;--- determined in the type lattice.
;;; HIGHLIGHTING-TEST is a presentation argument rather than a data argument because
;;; it can't be a data argument because the data argument is an &REST list of things.
;;; If it were a data argument we'd call it TEST.  Since we can't make it a data argument,
;;; we decided to call it HIGHLIGHTING-TEST, leaving only this comment as a note
;;; to future generations.
(define-presentation-type member ((&rest elements)
				  &key (partial-completers '(#\Space))
				       (highlighting-test #'eq))
   :disallow-atomic-type t
   :no-deftype t

   :abbreviation-for `((member-sequence ,elements :test ,highlighting-test)
		       :partial-completers partial-completers)

   ;; Why can't you inherit these?
   :describer ((stream &key plural-count original-type)
	       (member-describer sequence stream plural-count original-type))

   )
||#

;;; The following values need to be tuned to better reflect reality --
;;;    However we can't do this until the table sytem stops making such consistantly poor
;;;    choices for the implementations of tables of different sizes.  (E.g., the table
;;;    system is an order of magnitude slower for a table of size 250 vs. size 200.)
;;;  -- RWK

;;; Number of 1eq0 comparisons we can do faster than the table system.
(defparameter *member-subtypep-hash-threshold* 2000)

;;; Ratio of 1eql0 comparison to 1eq0 comparison.
(defparameter *member-subtypep-eql-ratio* 8)

;;; This flavor of optimization really belongs in 1cl:subsetp0...
(defun member-subtypep (data-1 data-2)
  (let ((length-1 (length data-1))
	(length-2 (length data-2)))
    (values 
      (cond #+ignore ((> length-1 length-2) nil)	;Allow duplicates in 1data-10.
	    ((= length-1 0) t)			;Empty set is a subtype of everything.
	    ((= length-2 0) nil)		;No non-empty set is a subtype of emtpy set.
	    ((and (< length-2 *member-subtypep-hash-threshold*)
		  #+ignore
		  ;; In general, it costs us more to compute this "optimization" than it will
		  ;; save us in the very rare cases that we actually use it!
		  (< (+ length-2
			(* *member-subtypep-eql-ratio*
			   (loop for item in data-1
				 count (typep item '(data-type dtp-extended-number)))))
		     *member-subtypep-hash-threshold*))
	     (stack-let ((buffer (make-array length-2 :initial-contents data-2)))
	       (let ((pointer (locf (aref buffer 0))))
		 (loop for thing in data-1
		       always
			 (or (%block-search-eq thing pointer length-2)
			     #+3600
			     (typecase thing
			       ((data-type dtp-extended-number)
				(let ((p (%make-pointer-offset dtp-locative pointer
							       -1)))
				  (loop repeat (lsh length-2 -1)
					thereis (eql (%p-contents-increment-pointer p)
						     thing)
					thereis (eql (%p-contents-increment-pointer p)
						     thing)
					finally
					  (when (oddp length-2)
					    (when (eql (%p-contents-increment-pointer p)
						       thing)
					      (return t)))))))
			     #+imach
			     (when (type-member thing
						dtp-big-ratio dtp-bignum dtp-double-float)
			       (with-block-registers (1)
				 (setf (%block-register 1) pointer)
				 (loop repeat (lsh length-2 -1)
				       doing
				   (let ((word1 (%block-read 1 :cycle-type %memory-scavenge
							     :prefetch nil))
					 (word2 (%block-read 1 :cycle-type %memory-scavenge
							     :prefetch nil)))
				     (when (or (eql word1 thing)
					       (eql word2 thing))
				       (return thing)))
				       finally
					 (when (oddp length-2)
					   (when (eql (%block-read
							1
							:cycle-type %memory-scavenge
							:prefetch nil
							:no-increment t)
						      thing)
					     (return thing))))))
			     )))))
	    (t
	     ;; 1make-hash-table0 will always "cons" about 45 words of list structure
	     ;; while hacking the table flavor's init-options.  But who cares as we
	     ;; hardly ever have to use this extreme case.
	     (stack-let ((table (make-hash-table :size length-2 :number-of-values 0
						 :locking nil :mutating nil)))
	       (loop for item in data-2
		     do (setf (gethash item table) t))
	       (loop for item in data-1
		     always (gethash item table)))))
      t)))					(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");We always give the correct answer ...

0;(define-presentation-translator t-to-sequence
;   (t sequence
;    :tester ((ignore &key presentation input-context)
;	     (when (not (null input-context))
;	       (let ((desired-type (presentation-input-context-presentation-type
;				     input-context)))
;		 (map-over-type-hierarchy desired-type nil t
;		   (lambda (type ignore ignore)
;		     (with-type-decoded (name) type
;		       (when (eq name 'sequence)
;			 (return-from t-to-sequence
;			   (with-presentation-type-arguments (sequence type)
;			     (presentation-type-applies-p
;			       (presentation-type presentation) element-type
;			       (presentation-object presentation))))))))))))
;   (object &key presentation)
;  (values (list object)
;	  `(sequence ,(presentation-type presentation))))

;;; Clear as mud, theories sought.
(defun member-describer (sequence stream plural-count original-type
			 &optional (name-key #'token-element-string)
				   (value-key #'identity))
  (flet ((preamble (word &optional suppress-singular)
	   (cond ((null plural-count)
		  (unless suppress-singular
		    (format stream "a ~A" word)
		    t))
		 ((eq plural-count t)
		  (format stream "~As" word)
		  t)
		 ((numberp plural-count)
		  (format stream "~R ~As" plural-count word)
		  t)
		 (t
		  (format stream "~A ~As" plural-count word)
		  t))))
    (cond ((eq *describe-presentation-type-reason* :possibilities)
	   (preamble "choice"))
	  ((and (eq *describe-presentation-type-reason* :help)
		(> (length sequence) 5))
	   (preamble "choice")
	   (format stream " from ~D possibilities" (length sequence)))
	  (t
	   (when (preamble "occurrence" t)
	     (format stream " of "))
	   (formatting-textual-list (stream :conjunction "or" :filled t :after-line-break "  ")
	     (member-describer-internal sequence stream original-type name-key value-key))))))

(defun member-describer-internal (sequence stream original-type name-key value-key)
  (let ((count 0))
    (block too-many
      (flet ((print-item (element)
	       (if (< (incf count) 5)
		   (formatting-textual-list-element (stream)
		     (with-output-as-presentation (:stream stream
						   :object (funcall value-key element)
						   :type original-type)
		       (write-string (funcall name-key element) stream)))
		   (formatting-textual-list-element (stream)
		     (write-string "..." stream))
		   (return-from too-many))))
	(map nil #'print-item sequence)))))

(define-presentation-type subset ((&rest keywords) &key (highlighting-test #'eq))
   :disallow-atomic-type t
   :abbreviation-for `((sequence-subset ,keywords :test ,highlighting-test)
						  :name-key ,#'token-element-string)
   :describer ((stream &key plural-count)
	       (subset-describer keywords stream plural-count
				 `((subset ,keywords))
				 #'token-element-string))
   )

(define-presentation-type alist-subset ((&key alist) &key (convert-spaces-to-dashes nil)
							  (style-keyword :style)
							  (highlighting-test #'eql)
							  (fill-p nil) (row-wise t))

   :disallow-atomic-type t
   :abbreviation-for `((sequence-subset ,alist :value-key ,#'tv:menu-execute-no-side-effects)
		       :name-key ,(if convert-spaces-to-dashes
				      #'token-element-dashed-string
				      #'token-element-string)
		       :documentation-key ,#'(lambda (alist-element)
					       (alist-element-property alist-element
								       :documentation))
		       :style-key ,#'(lambda (alist-element)
				       (alist-element-property alist-element :style))
		       :highlighted-style-key ,#'(lambda (alist-element)
						   (alist-element-property alist-element
									   :selected-style))
		       :sensitive-predicate ,#'(lambda (alist-element)
						 (not (and (consp alist-element)
							   (consp (cdr alist-element))
							   (eq (second alist-element)
							       :no-select))))
		       :fill-p ,fill-p :row-wise ,row-wise)

   :describer ((stream &key plural-count)
	       (subset-describer alist stream plural-count
				 `((alist-member :alist ,alist))
				 (if convert-spaces-to-dashes
				     #'token-element-dashed-string
				     #'token-element-string)
				 #'tv:menu-execute-no-side-effects))
   )


;;; Counts conses (not Q's!), and returns 1nil0 if it exceeds max.
(defun tree-size (tree &optional (max 20))
  (when (consp tree)
    (let ((size-so-far 0))
      (labels ((tree-size-recurse (tree)
		 (declare (sys:downward-function))
		 (loop for l on tree
		       until (atom l)
		       doing
		   (incf size-so-far)
		   (when ( size-so-far max)
		     (return-from tree-size nil)))
		 ;; Breadth first; faster, I think.  Fewer function calls
		 (loop for l on tree
		       until (atom l)
		       doing
		   (when (consp (car l))
		     (tree-size-recurse (car l))))))
	(tree-size-recurse tree)
	size-so-far))))

(define-presentation-type sequence-element ((sequence &key (test #'eql)
							   (value-key #'identity))
					    &key (name-key #'string)
						 (documentation-key #'ignore)
						 (style-key #'ignore)
						 (highlighted-style-key #'ignore)
						 (sensitive-predicate #'true)
						 (partial-completers '(#\Space))
						 (fill-p nil)
						 (row-wise t))
   :disallow-atomic-type t

   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (complete-from-sequence sequence stream
				      :type original-type
				      :name-key name-key
				      :value-key value-key
				      :predicate sensitive-predicate
				      :documenter
				       (lambda (object stream)
					 (unless (eql documentation-key #'ignore)
					   (let ((element (find object sequence
								:key value-key :test test)))
					     (when element
					       (let ((documentation
						       (funcall documentation-key element)))
						 (when documentation
						   (write-string documentation stream)))))))
				      :document (unless (eql documentation-key #'ignore)
						  (loop for element in sequence
							thereis (not (null (funcall documentation-key element)))))
				      :initially-display-possibilities
				       initially-display-possibilities 
				      :partial-completers partial-completers
				      :complete-activates (accept-activation-p #\Complete))
	      original-type))
   :printer ((object stream)
	     (let* ((element (find object sequence :key value-key :test test))
		    (style (funcall style-key element)))
	       (with-character-style (style stream)
		 (write-string (funcall name-key element) stream))))
   :describer ((stream &key plural-count original-type)
	       (member-describer sequence stream plural-count original-type
				 name-key value-key))

   :choose-displayer ((stream object query-identifier &key original-type)
		      (accept-values-choose-from-sequence
			stream sequence object query-identifier
			:key value-key
			:type original-type
			:sensitive-predicate sensitive-predicate
			:documentation-key documentation-key
			:highlighted-type
			`((sequence-element ,sequence :test ,test :value-key ,value-key)
			  :name-key ,name-key :style-key ,highlighted-style-key)
			:id-test test
			:fill-p fill-p
			:row-wise row-wise))


;   :key-function ((function original-type-name)
;		  (stack-let ((key (list original-type-name
;					 test value-key
;					 (if (tree-size sequence)
;					     sequence
;					   (%make-pointer dtp-locative sequence)))))
;		    (funcall function key)))
;   :with-cache-key ((function original-type-name)
;		    (stack-let ((key (list original-type-name
;					   test value-key
;					   (if (tree-size sequence)
;					       sequence
;					     (%make-pointer dtp-locative sequence)))))
;		      (funcall function key)))

   :presentation-subtypep
     ((type-1 type-2)
      (with-presentation-type-arguments (sequence-element type-1)
	(let ((sequence-1 sequence)
	      (test-1 test)
	      (key-1 value-key))
	  (with-presentation-type-arguments (sequence-element type-2)
	    (let ((sequence-2 sequence)
		  (test-2 test)
		  (key-2 value-key))
	      (values
		(and (eq test-1 test-2)
		     (eq key-1 key-2)
		     (every #'(lambda (x)
				(position (funcall key-1 x)
					  sequence-2
					  :test test-1
					  :key key-1))
			  sequence-1))
		T))))))
   :typep
     ((elem)
      (position elem sequence :test test :key value-key)))

(defun alist-element-property (alist-element indicator)
  (and alist-element
       (consp alist-element)
       (consp (cdr alist-element))
       (getf (cdddr alist-element) indicator)))

(define-presentation-type alist-member ((&key alist) &key (convert-spaces-to-dashes nil)
							  (style-keyword :style)
							  (highlighting-test #'eql)
							  (fill-p nil) (row-wise t))

   :disallow-atomic-type t

   :abbreviation-for `((sequence-element ,alist :value-key ,#'tv:menu-execute-no-side-effects
					 :test ,highlighting-test)
		       :name-key ,(if convert-spaces-to-dashes
				      #'token-element-dashed-string
				      #'token-element-string)
		       :documentation-key ,#'(lambda (alist-element)
					       (alist-element-property alist-element
								       :documentation))
		       :style-key ,#'(lambda (alist-element)
				       (alist-element-property alist-element :style))
		       :highlighted-style-key ,#'(lambda (alist-element)
						   (alist-element-property alist-element
									   :selected-style))
		       :sensitive-predicate ,#'(lambda (alist-element)
						 (not (and (consp alist-element)
							   (consp (cdr alist-element))
							   (eq (second alist-element)
							       :no-select))))
		       :fill-p ,fill-p :row-wise ,row-wise)

   ;; Why can't you inherit these?
   :describer ((stream &key plural-count original-type)
	       (member-describer alist stream plural-count original-type
				 (if convert-spaces-to-dashes
				     #'token-element-dashed-string
				     #'token-element-string)
				 #'tv:menu-execute-no-side-effects))

   ;; Yeah, why aren't they inherited??
   ;; This code is borrowed (with modifications only to make it destructure correctly,
   ;; and to optimize out uselessly general branches) from what SEQUENCE-ELEMENT
   ;; does, since it's my belief it should have been inherited from SEQUENCE-ELEMENT.
   ;; -kmp 22-Jul-92
   :presentation-subtypep
     ((type-1 type-2)
      (with-presentation-type-arguments (alist-member type-1)
	(let ((sequence-1 alist)
	      (test-1 highlighting-test))
	  (with-presentation-type-arguments (alist-member type-2)
	    (let ((sequence-2 alist)
		  (test-2 highlighting-test))
	      (values
		(and (eq test-1 test-2)
		     (every #'(lambda (x)
				(position (tv:menu-execute-no-side-effects x)
					  sequence-2
					  :test test-1
					  :key #'tv:menu-execute-no-side-effects))
			  sequence-1))
		T))))))
   )

(defun subset-describer (sequence stream plural-count type
			 &optional (name-key #'token-element-string)
				   (value-key #'identity))
  (presentation-string-pluralize "a subset" stream plural-count)
  ;; You have to be moby, moby sick to ASK for two subsets of the keywords,
  ;; and how could it ever figure out the boundary?  But printing the
  ;; description is not pointless.
  (cond ((eq *describe-presentation-type-reason* :possibilities)
	 )
	((and (eq *describe-presentation-type-reason* :help)
	      (> (length sequence) 5))
	 (format stream " of ~D possibilities" (length sequence)))
	(t
	 (write-string " of " stream)
	 (formatting-textual-list (stream :conjunction "and" :filled t
					  :after-line-break "  ")
	   (member-describer-internal sequence stream type name-key value-key)))))

;;; This is like sequence-element, but you choose a subset instead.
(define-presentation-type sequence-subset ((sequence &key (test #'eql)
							  (value-key #'identity))
					   &key (name-key #'string)
						(documentation-key #'ignore)
						(style-key #'ignore)
						(highlighted-style-key #'ignore)
						(sensitive-predicate #'true)
						(partial-completers '(#\Space))
						(fill-p nil)
						(row-wise t))

   :disallow-atomic-type t

   :choose-displayer ((stream object query-identifier &key original-type)
		      (accept-values-choose-from-sequence
			stream sequence object query-identifier
			:key value-key
			:type original-type
			:sensitive-predicate sensitive-predicate
			:documentation-key documentation-key
			:multiple-choices t
			:printer (lambda (element stream)
				   (write-string (funcall name-key element) stream))
			:id-test test
			:select-action (lambda (new list)
					 (cond ((nlistp list)
						(list new))
					       ((member new list :test test)
						(remove new list :test test))
					       (t
						(adjoin new list :test test))))
			:fill-p fill-p
			:row-wise row-wise))

   :presentation-subtypep
     ((type-1 type-2)
      (with-presentation-type-arguments (sequence-subset type-1)
	(let ((sequence-1 sequence)
	      (test-1 test)
	      (key-1 value-key))
	  (with-presentation-type-arguments (sequence-subset type-2)
	    (let ((sequence-2 sequence)
		  (test-2 test)
		  (key-2 value-key))
	      (and (eq test-1 test-2)
		   (eq key-1 key-2)
		   (every #'(lambda (x)
			      (position x sequence-2 :test test-1 :key key-1))
			  sequence-1)))))))

   :describer ((stream &key plural-count)
	       (subset-describer sequence stream plural-count
				 `((sequence-element ,sequence
				     :test ,test :value-key ,value-key))
				 name-key value-key))
			     
   :printer ((set stream &key acceptably)
	     (flet ((printer (object stream)
		      (let ((element (find object sequence :key value-key :test test)))
			(write-string (funcall name-key element) stream))))
	       (cond (acceptably
		      (format-textual-list set #'printer :stream stream))
		     ((null set)
		      (write-string "no tokens selected" stream))
		     (t
		      (format-textual-list set #'printer :stream stream :separator " ")))))

   :parser ((stream &key initially-display-possibilities)
	    (delete-duplicates
	      (accept `(or null
			   (parse-error-wall
			     (sequence ((sequence-element ,sequence
					 :test ,test :value-key ,value-key)
					:name-key ,name-key
					:documentation-key ,documentation-key
					:partial-completers ,partial-completers))))
		      :stream stream :prompt nil
		      :initially-display-possibilities initially-display-possibilities))))

;;; Sequence selection by means if enclosing a region with the mouse

(defun find-innermost-sequence-context (context)
  (labels ((do-one-input-context (context)
	     (when (and context
			(presentation-subtypep
			  '(sequence nil)
			  (presentation-input-context-presentation-type context)))
	       (return-from find-innermost-sequence-context context))))
    (map-over-input-contexts #'do-one-input-context context)))

;; Set this to 1nil0 if don't like the presentations to be highlighted.
(defvar *region-to-sequence-highlight-presentations* t)

;; What kind of highlighting to use.  1nil0 means inverse video.
(defvar *region-to-sequence-highlighting-stipple* tv:10%-gray)

;; Notice that this is a translator from 1t0 on the 1:select0 gesture.  This means
;; that any more specific presentation will get preference over it, which means
;; that the easiest way to use this is to click over a blank region, then start
;; the surround operation from there.  If there is no convenient blank region,
;; click Right, and select the translator from the menu.
(define-presentation-action region-to-sequence
   (t (sequence nil)
    :tester ((ignore &key window input-context)
	     (and (send-if-handles window :mouse-position)
		  ;; Only run this when we are really looking for a sequence
		  (find-innermost-sequence-context input-context)))
    :documentation "Select all objects of matching type in region"
    :gesture :select
    :blank-area t
    :suppress-highlighting t)
   (ignore &key window x y input-context mouse-char)
  (let ((initial-x x)
	(initial-y y)
	last-x last-y
	(presentations nil)
	(presentation-cache nil)
	(presentation-cache-bounds nil))
    (when (or (null initial-x) (null initial-y))
      (multiple-value-setq (initial-x initial-y)
	(send window :mouse-position)))
    (when (or (null initial-x) (null initial-y)
	      (not (get-handler-for window :map-over-overlapping-presentations)))
      (return-from region-to-sequence (values nil nil)))
    (maxf initial-x 0)
    (maxf initial-y 0)
    (let* ((context
	     (find-innermost-sequence-context input-context))
	   (sequence-type
	     (when context
	       (let ((type (presentation-input-context-presentation-type context)))
		 (block get-sequence-type
		   (map-over-type-hierarchy type nil nil
		      #'(lambda (type ignore ignore)
			  (with-type-decoded (name) type
			     (when (eq name 'sequence)
			       (return-from get-sequence-type
				 (si:copy-if-necessary type))))))))))
	   (element-type
	     ;; This is the object type we are really looking for
	     (when sequence-type
	       (with-presentation-type-arguments (sequence sequence-type)
		 element-type)))
	   (whostate
	     (when element-type
	       (with-output-to-string (s)
		 (princ "Enclose " s)
		 (describe-presentation-type element-type s t)))))
      (when (null element-type)
	(return-from region-to-sequence (values nil nil)))
      ;; Now let the user draw a box around some presentations
      (macrolet ((canonicalize-corners (left top right bottom)
		   `(progn
		      (when (< ,right ,left) (rotatef ,right ,left))
		      (when (< ,bottom ,top) (rotatef ,bottom ,top)))))
	(labels ((draw-box (x y)
		   (graphics:draw-rectangle initial-x initial-y x y
		     :filled nil :opaque nil :alu :flip
		     :dashed t :dash-pattern #(4 4 4 4)
		     :stream window))
		 (highlight-presentations (x y last-x last-y)
		   (declare (values presentations))
		   (ignore last-x last-y)
		   (let ((old-left initial-x)
			 (old-top initial-y)
			 (old-right last-x)
			 (old-bottom last-y)
			 (new-left initial-x)
			 (new-top initial-y)
			 (new-right x)
			 (new-bottom y)
			 (new-presentations nil))
		     (when last-x
		       (canonicalize-corners old-left old-top old-right old-bottom))
		     (canonicalize-corners new-left new-top new-right new-bottom)
		     (if (null last-x)
			 ;; First time through
			 (setq new-presentations
			       (presentations-in-box new-left new-top new-right new-bottom))
		       ;; This hair probably doesn't buy much in the face of the
		       ;; presentation-cache, but what the heck...
		       (cond ((< new-top old-top)
			      ;; Box grew upwards
			      (setq new-presentations
				    (presentations-in-box
				      (min old-left new-left) new-top
				      (max old-right new-right) old-top)))
			     ((> new-bottom old-bottom)
			      ;; Box grew downwards
			      (setq new-presentations
				    (presentations-in-box
				      (min old-left new-left) old-bottom
				      (max old-right new-right) new-bottom))))
		       (cond ((< new-left old-left)
			      ;; Box grew to the left
			      (setq new-presentations
				    (nconc new-presentations
					   (presentations-in-box
					     new-left (min old-top new-top)
					     old-left (max old-bottom new-bottom)))))
			     ((> new-right old-right)
			      ;; Box grew to the right
			      (setq new-presentations
				    (nconc new-presentations
					   (presentations-in-box
					     old-right (min old-top new-top)
					     new-right (max old-bottom new-bottom)))))))
		     (setq new-presentations (delete-duplicates new-presentations))
		     (let* ((presentations-to-erase
			      ;; Erase presentations which used to be in the region
			      ;; but aren't any longer
			      (loop for p in presentations
				    unless (box-overlaps-region-p
					     (presentation-displayed-box p)
					     new-left new-top new-right new-bottom)
				      collect p))
			    (presentations-to-highlight
			      ;; Highlight all the presentations not currently highlighted
			      (loop for p in new-presentations
				    when (not (member p presentations))
				      collect p)))
		       (gray-over-presentations presentations-to-erase)
		       (gray-over-presentations presentations-to-highlight)
		       (setq presentations
			     (nconc (set-difference presentations presentations-to-erase)
				    presentations-to-highlight)))))
		 (presentations-in-box (left top right bottom)
		   (cond ((null presentation-cache-bounds)
			  ;; Fill the cache with the entire visible part of the window
			  (multiple-value-bind (left top right bottom)
			      (box-edges (send window :cursor-viewport))
			    (setq presentation-cache
				  (presentations-of-type-in-region
				    element-type window
				    left top right bottom
				    :sort nil))
			    (setq presentation-cache-bounds (list left top right bottom))))
			 ((or (< left (nth 0 presentation-cache-bounds))
			      (< top (nth 1 presentation-cache-bounds))
			      (> right (nth 2 presentation-cache-bounds))
			      (> bottom (nth 3 presentation-cache-bounds)))
			  (multiple-value-bind (width height)
			      (send window :inside-size)
			    (let ((left (max 0 (- left (floor width 2))))
				  (top (max 0 (- top (floor height 2))))
				  (right (+ right (floor width 2)))
				  (bottom (+ bottom (floor width 2))))
			      ;; Grow the cache
			      (minf (nth 0 presentation-cache-bounds) left)
			      (minf (nth 1 presentation-cache-bounds) top)
			      (maxf (nth 2 presentation-cache-bounds) right)
			      (maxf (nth 3 presentation-cache-bounds) bottom)
			      (setq presentation-cache
				    (presentations-of-type-in-region
				      element-type window
				      (nth 0 presentation-cache-bounds)
				      (nth 1 presentation-cache-bounds)
				      (nth 2 presentation-cache-bounds)
				      (nth 3 presentation-cache-bounds)
				      :sort nil))))))
		   (loop for presentation in presentation-cache
			 when (box-overlaps-region-p
				(presentation-displayed-box presentation)
				left top right bottom)
			   collect presentation))
		 (gray-over-presentations (presentations)
		   (loop for presentation in presentations doing
		     (multiple-value-bind (left top right bottom)
			 (box-edges (presentation-displayed-box presentation))
		       (graphics:draw-rectangle left top right bottom
			 :filled t :opaque nil :alu :flip
			 :stipple *region-to-sequence-highlighting-stipple*
			 :stream window)))))
	  (block enclose-presentations
	    (with-output-recording-disabled (window)
	      ;;--- Use new 1:mouse-motion-feedback0 clause
	      (tracking-mouse (window
			       :whostate whostate
			       :who-line-documentation-string
				 (format nil "~A; release mouse button when done"
				   whostate))
		(:release-mouse ()
		 (when last-x
		   ;; Erase final rectangle
		   (draw-box last-x last-y)
		   (when *region-to-sequence-highlight-presentations*
		     ;; Erase any presentation highlighting
		     (gray-over-presentations presentations)))
		 (return-from enclose-presentations))
		(:mouse-motion-hold (x y)
		 (maxf x 0)
		 (maxf y 0)
		 (when (or (neq x last-x) (neq y last-y))
		   (when last-x
		     ;; Erase the previous feedback rectangle
		     (draw-box last-x last-y))
		   ;; Draw new rectangle
		   (draw-box x y)
		   (when *region-to-sequence-highlight-presentations*
		     ;; Draw new presentation highlighting
		     (highlight-presentations x y last-x last-y))
		   (setq last-x x
			 last-y y)))))))
	(when last-x
	  (if *region-to-sequence-highlight-presentations*
	      (setq presentations (sort-presentations-by-position presentations))
	    (canonicalize-corners initial-x initial-y last-x last-y)
	    (setq presentations
		  (presentations-of-type-in-region element-type window
						   initial-x initial-y last-x last-y)))
	  (let ((objects
		  (loop for presentation in (delete-duplicates presentations)
			collect (presentation-object presentation))))
	    (when objects
	      ;; Package up a blip and throw out to the correct input context.
	      ;; We need to do it this way because of optimizations which cause
	      ;; mouse-motion to throw out of the sensitivity computation.
	      (throw context
		(make-presentation-blip
		  :mouse-char mouse-char
		  :presentation-type sequence-type
		  :object objects
		  :options '(:dont-quote t))))))))))
