;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Normal presentation types.

(defvar *boolean-alist* '(("Yes" . t) ("No" . nil)))

(define-presentation-type boolean ()
   :no-deftype t
   ;; We cannot just expand into alist-member because we're also a common lisp type.
   :parser ((stream &key type initially-display-possibilities)
	    (values
	      (accept `((alist-member :alist ,*boolean-alist*))
		      :initially-display-possibilities initially-display-possibilities
		      :stream stream :prompt nil)
	      type))
   :choose-displayer ((stream object query-identifier)
		      (accept-values-choose-from-sequence
			stream *boolean-alist*
			object query-identifier
			:type 'boolean
			:key #'cdr))
   :printer ((choice stream)
	     (when choice
	       ;; Canonicalize this to T, so it matches the choice below.
	       (setq choice t))
	     (present choice `((alist-member :alist ,*boolean-alist*))
		      :stream stream))
   :describer ((stream &key plural-count)
	       (describe-presentation-type `((alist-member :alist ,*boolean-alist*))
					   stream plural-count)))

(defvar *inverted-boolean-alist* '(("Yes" . nil) ("No" . t)))

;;; We need the D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*inverted-boolean-alist*0 so the alist can be 1eq0 in the two uses
;;; below.
(define-presentation-type inverted-boolean ()
   ;; This ought to be more symetric with boolean, above.
   :abbreviation-for `((alist-member :alist ,*inverted-boolean-alist*))
   :describer ((stream &key plural-count)
	       (describe-presentation-type `((alist-member :alist ,*inverted-boolean-alist*))
					   stream plural-count)))

(define-presentation-type t ()
   :no-deftype t
   :printer ((object stream)
	     (write-for-present object :stream stream :escape nil))
   :describer ((stream &key original-type)
	       (with-type-decoded (type-name) original-type
		  (if (eq type-name t)
		      (write-string "anything at all" stream)
		    (let ((string (string-downcase type-name)))
		      (when (find #\- string)
			(setq string (substitute #\Space #\- string)))
		      (if (zerop (length string))
			  (write-string " a ||" stream)	;Damned silly case.
			(write-string (string-a-or-an string nil :downcase) stream)
			(write-char #\Space stream)
			(write-string string stream)))))))

(define-presentation-type nil ()
   :no-deftype t)

(define-presentation-type pathname (() &key (default-version :newest default-version-p)
					    (default-type nil default-type-p)
					    (default-name nil default-name-p)
					    dont-merge-default (direction :read)
					    (format :normal))
   :no-deftype t
   :history t

   ;; coerce the default to respect the various presentation-args
   :default-preprocessor
     ((default)
      (when default-version-p
	(setq default (send default :new-version default-version)))
      (when default-type-p
	(setq default (send default :new-type default-type)))
      (when default-name-p
	(setq default (send default :new-name default-name)))
      default)
    :history-postprocessor
     ((object &key default)
      (when (or dont-merge-default
		(and (null default-version) default-version-p)
		(and (null default-name) default-name-p)
		(and (null default-type) default-type-p))
	;; +++ Kludge alert!
	(unless (pathnamep default)		;Might be from OR type.
	  (setq default nil))
	;; If we didn't merge when parsing, do so when pushing into the history.
	(setq object (fs:merge-pathnames (fs:merge-pathnames object default))))
      object)

   :printer
     ((pathname stream)
      (write-string (send pathname (ecase format
				     (:normal :string-for-printing)
				     (:dired :string-for-dired)
				     (:directory :string-for-directory)
				     (:editor :string-for-editor)))
		    stream))
   
   :parser
     ((stream &key default type)
      (si:with-parse-ferror (fs:pathname-error)
	(let ((si:*syntax-table* (if (boundp 'zwei:*pname-word-syntax-table*)
				     'zwei:*pname-word-syntax-table*
				   si:*syntax-table*))
	      (loc (send stream :read-location)))
	  (labels 
	    ((funny-pathname-lessp (f1 f2 &aux tem)
	       ;; Sort pathnames in ascending alphabetical order, 
	       ;; with version numbers are in descending order.
	       (multiple-value-bind
		 (f1-host f1-dev f1-dir f1-name f1-type f1-ver)
		   (send f1 :all-components)
		 (multiple-value-bind
		   (f2-host f2-dev f2-dir f2-name f2-type f2-ver)
		     (send f2 :all-components)
		   (and (zerop (setq tem (fs:pathname-component-compare f1-host f2-host)))
			(zerop (setq tem (fs:pathname-component-compare f1-dev f2-dev)))
			(zerop (setq tem (fs:pathname-component-compare f1-dir f2-dir)))
			(zerop (setq tem (fs:pathname-component-compare f1-name f2-name)))
			(zerop (setq tem (fs:pathname-component-compare f1-type f2-type)))
			(setq tem (fs:pathname-component-compare f2-ver f1-ver)))
		   (minusp tem))))
	     (possibilities (pattern newest-p)
	       (let ((pathnames (sort (cdr (fs:directory-list pattern :fast))
				      #'funny-pathname-lessp
				      :key #'car)))
		 (loop for (pathname) in pathnames
		       do (when newest-p
			    (setq pathname (send pathname :new-version nil)))
		       collect (list (string pathname) pathname)))))
	    (multiple-value-bind (nil nil string)
		(complete-input
		  stream
		  (lambda (string &optional (action :complete))
		    (ecase action
		      ((:complete :complete-limited :complete-maximal)
		       (multiple-value-bind (string success)
			   (fs:complete-pathname default
						 string
						 default-type default-version
						 direction)
			 (values string success)))
		      (:possibilities
			;; Not the greatest, but better than nothing.
			(condition-case (e)
			     (let* ((pathname
				      (fs:merge-pathnames string
							  (send (fs:default-pathname default)
								:new-pathname
								:name :wild :type :wild)))
				    (name (send pathname :name))
				    (type (send pathname :type))
				    (canonical-type (send pathname :canonical-type))
				    (pattern (send pathname :new-pathname
						   :name (cond ((or (eq name :wild)
								    (equal name ""))
								:wild)
							       ;; On some hosts a missing type
							       ;; in 'string' will produce
							       ;; :unspecific after the merge.
							       ;; Either way, if there is no
							       ;; type in 'string', the name
							       ;; is subject to completion.
							       ((or (eq type :wild)
								    (eq type :unspecific))
								(string-append name "*"))
							       (t name))
						   :type (if (or (eq type :wild)
								 (eq type :unspecific)
								 (equal type ""))
							     :wild
							     (string-append type "*"))
						   :version :newest)))
			       ;; The gist here is to look up all versions if the file name
			       ;; and type have been fully supplied, otherwise just .newest
			       ;; The canonical-type business makes the assumption that if
			       ;; the type that has been input so far is a known canonical
			       ;; type, it probably does not need further completion, so
			       ;; treat it as fully supplied and look up all versions.
			       (if (or (send pattern :name-wild-p)
				       (and (send pattern :type-wild-p)
					    (or (not (symbolp canonical-type))
						(member canonical-type
							'(nil :unspecific :wild)))))
				   (possibilities pattern t)
				   (possibilities (send pattern :new-version :wild) nil)))
			   (error (cp::cp-error t "~A" e))))
		      ((:apropos-possibilities :apropos-initial-possibilities)
		       ;; Decompose the pathname and change the name part of it
		       ;; to *name*.  :apropos-initial-possibilities isn't any
		       ;; different from :apropos-possibilities, since pathnames
		       ;; don't complete by chunks.
		       ;; Unlike :possibilities, :apropos-possibilities always looks up
		       ;; the newest version only, since the name is always wild
		       (condition-case (e)
			    (let* ((pathname
				     (fs:merge-pathnames string
							 (send (fs:default-pathname default)
							       :new-pathname
							       :name :wild :type :wild)))
				   (name (send pathname :name))
				   (type (send pathname :type))
				   (apropos-name (if (or (eq type :wild) (eq type :unspecific))
						     (if (eq name :wild) "*" name)
						     (send pathname :string-for-dired)))
				   (apropos-pathname
				     (send pathname :new-pathname
					   :name (if (stringp name)
						     (string-append "*" name "*")
						     name)
					   :type (if (eq type :unspecific) :wild type)
					   :version :newest)))
			      (values (possibilities apropos-pathname t)
				      (ncons apropos-name)))
			  (error (cp::cp-error t "~A" e))))
		      ((:apropos-possibilities-quick-length
			 :apropos-initial-possibilities-quick-length
			 :possibilities-quick-length)
		       ;; No easier way to know than to list them.
		       nil)))
		  :help-offers-possibilities nil
		  :allow-any-input t
		  :compression-delimiter #\-)
	      (when (equal string "")
		(error 'input-not-of-required-type :type 'pathname :string ""))
	      (let ((pathname (pathname string default)))
		(when default
		  (unless dont-merge-default
		    (setq pathname (merge-pathnames pathname default default-version))))
	      
		(presentation-replace-input stream loc
					    (send pathname :string-for-printing))
		(values pathname (type-of pathname))))))))
   
   :describer
     ((stream &key plural-count)
      (princ
	(cond ((null plural-count) "the pathname of a file")
	      ((eq plural-count t) "pathnames of files")
	      ((numberp plural-count)
	       (format nil "the pathnames of ~R files" plural-count))
	      (t (format nil "the pathnames of ~A files" plural-count)))
	stream)))

;;; A file that is a directory
(define-presentation-type fs:directory-pathname (() &rest pathname-presentation-args)
   :expander `((fs:pathname) ,@pathname-presentation-args))

;;; A pathname that has wildcards and so can be directory listed.
(define-presentation-type fs:wildcard-pathname (() &rest pathname-presentation-args)
   :expander `((fs:pathname) ,@pathname-presentation-args))

(define-presentation-type fs:open-file ()
   :typep ((object) (streamp object))
   :parser ((stream &key type initially-display-possibilities)
	    (values
	      (complete-from-sequence fs:all-open-streams stream
				      :name-key #'(lambda (stream)
						    (string (send stream :pathname)))
				      :initially-display-possibilities
				       initially-display-possibilities
				      :partial-completers '(#\Space)
				      :type type)))
   :printer ((open-file stream)
	     (write-string (string (send open-file :pathname)) stream)))

(defun token-element-string (element)
  (typecase element
    (null (symbol-name element))		;"NIL"
    (cons (string (first element)))
    (symbol (string-capitalize (symbol-name element)))
    (string element)
    (otherwise (present-to-string element))))

(defun token-element-dashed-string (element)
  (substitute #\- #\Space (token-element-string element)))

(defun item-from-menu-value (value item-list &key (test #'eq))
  (dolist (item item-list)
    (when (funcall test (tv:menu-execute-no-side-effects item) value)
      (return (values item t)))))

;;; This old name is still in some code.
(define-presentation-type menu-choose ((&key alist) &key (convert-spaces-to-dashes nil))
   :abbreviation-for `((alist-member :alist ,alist)
		       :convert-spaces-to-dashes ,convert-spaces-to-dashes)
   :describer ((stream &key plural-count)
	       (describe-presentation-type `((alist-member :alist ,alist)
					     :convert-spaces-to-dashes
					      ,convert-spaces-to-dashes)
					   stream plural-count)))

(setf (presentation-type-obsolete 'menu-choose) 'dw:alist-member)

(defparameter *special-token-special-sets*
	      '(((t nil) ("Yes" . t) ("No" . nil))
		((nil) ("None" . nil))))

(defun set-eqv (s1 s2)
  (and (subsetp s1 s2 :test #'equal)
       (subsetp s2 s1 :test #'equal)))

(defun special-token-set (special-tokens)
  (let ((special-set (assoc special-tokens *special-token-special-sets* :test #'set-eqv)))
    (if special-set
	(rest special-set)
	special-tokens)))

(define-presentation-type token-or-type ((special-tokens otherwise-type))
  :abbreviation-for `(or ((alist-member :alist ,(special-token-set special-tokens))
			  :description "special token")
			 ,otherwise-type)
  :presentation-type-arguments (otherwise-type)
  :printer ((thing stream &key acceptably)
	    (present thing
		     (if (multiple-value-bind (nil found-p)
			     (item-from-menu-value thing special-tokens)
			   found-p)
			 `(alist-member :alist ,(special-token-set special-tokens))
			 otherwise-type)
		     :stream stream
		     :acceptably acceptably))
  :describer ((stream)
	      (formatting-textual-list (stream :conjunction "or")
		(formatting-textual-list-element (stream)
		  (describe-presentation-type otherwise-type stream))
		(let ((tokens (loop for tok-val in (special-token-set special-tokens)
				    when (consp tok-val)
				      collect (cons (car tok-val)
						    (tv:menu-execute-no-side-effects tok-val))
				    else collect (cons (string-capitalize-words tok-val)
						       tok-val))))
		  (if (< (length tokens) 5)
		      (loop with alist-member-type =
			    `(alist-member :alist ,(special-token-set special-tokens))
			    for tok in tokens
			    do (formatting-textual-list-element (stream)
				 (with-output-as-presentation (:stream stream
							       :object (cdr tok)
							       :type alist-member-type
							       :allow-sensitive-inferiors nil
							       :single-box t)
				   (write-string (car tok) stream))))
		      (formatting-textual-list-element (stream)
			(write-string "a special token" stream))))))
 #|| this should work, but doesn't
		(member-describer-internal (special-token-set special-tokens) stream)
 ||#
  :accept-values-displayer
   ((stream object query-identifier &key original-type provide-default)
    (standard-accept-values-displayer (stream object query-identifier provide-default)
      ;; First a row of special tokens
      (let ((alist (special-token-set special-tokens)))
	(accept-values-choose-from-sequence stream alist object query-identifier
					    :type `((alist-member :alist ,alist))
					    :key #'tv:menu-execute-no-side-effects))
      (write-string "  " stream)
      ;; Now the other choice(s)
      (multiple-value-setq (x y) (send stream :read-cursorpos))
      (block nil
	(values object original-type
		(accept-values-dispatch (otherwise-type)
		  ;; accept-values-displayer returns all the values
		  (return)
		  ;; choose-displayer, menu-displayer return just a presentation
		  (progn)
		  ;; No special handler, just print unless it's a special token
		  (present-editable-choice object otherwise-type
					   (multiple-value-bind (nil found-p)
					       (item-from-menu-value object special-tokens)
					     found-p)))
		x y)))))

(define-presentation-type null-or-type ((presentation-type))
   ;; --- Shouldn't the description come from the description of the
   ;; abbreviation-for type?
   :describer ((stream &key plural-count)
	       (describe-presentation-type presentation-type stream plural-count)
	       (write-string " or None" stream))
   :abbreviation-for `((token-or-type (("None" . nil)) ,presentation-type))
   :presentation-type-arguments (presentation-type))

(define-presentation-type type-or-string ((presentation-type &key reject-null-string)
					  &key string-if-quoted)
   :expander `((or ,presentation-type string))
   :presentation-type-arguments (presentation-type)
   :printer ((thing stream)
	     (if (and string-if-quoted (stringp thing)) (write-char #\" stream))
	     (present thing
		      (if (stringp thing)
			  'string
			  presentation-type)
		      :stream stream)
	     (if (and string-if-quoted (stringp thing)) (write-char #\" stream)))
   :parser ((stream &key default initially-display-possibilities)
	    (let ((read-loc (send stream :read-location)))
	      (condition-case (e)
		   (if string-if-quoted
		       ;; Since we have to peek for a quote, we can't pass through the
		       ;; display of possibilities, or it will happen after the first
		       ;; char is typed.  Anyway, this expresses a stronger preference
		       ;; for quoted stuff, so really everything is a possibility anyway.
		       (let ((ch (peek-char-for-accept stream t)))
			 (if (and (characterp ch) (char-equal ch #\"))
			     (accept 'string
				     :stream stream
				     :provide-default (stringp default)
				     :default default
				     :display-default nil
				     :prompt nil)
			     (accept `((or ,presentation-type string))
				     :stream stream
				     :provide-default (and default (not (stringp default)))
				     :default default
				     :display-default nil
				     :prompt nil)))
		       ;; Try to read the real presentation-type
		       (accept presentation-type
			       :stream stream
			       :default default
			       :provide-default (and default (not (stringp default)))
			       :initially-display-possibilities
			         initially-display-possibilities
			       :prompt nil))
		 ((sys:parse-error)
		  (send stream :set-location read-loc)
		  ;; If we can't read it, then read a string instead...
		  (let ((string (accept 'string
					:stream stream
					:default default
					:provide-default (stringp default)
					:prompt nil)))
		    (when (and (or (not (null default))
				   reject-null-string)
			       (string-equal string ""))
		      ;; trigger default-supplying mechanism
		      (zl:parse-ferror "The NULL string is not allowed"))
		    (values string 'string))))))

   :describer ((stream)
	       (describe-presentation-type presentation-type stream))
   )

(define-presentation-type time:universal-time
      (() &key base-time past-p must-have timezone long-date brief
	       (replace-relative-time nil) present-based)
   :history t
   :typep ((object) (integerp object))
   :parser ((stream)
	    (macrolet ((must-have (x)
			 `(or (eq must-have ,x)
			      (and (listp must-have) (member ,x must-have)))))
	      (si:with-parse-ferror (time:parse-error)
		(let ((loc (send stream :read-location))
		      (token (read-standard-token stream)))
		  (multiple-value-bind (universal-time relative-p time-specified-p)
		      (if present-based
			  (time:parse-present-based-universal-time token)
			(time:parse-universal-time
			  token
			  0 nil
			  (not past-p)
			  base-time
			  (must-have :time)
			  (must-have :year)
			  (must-have :second)))	;day-must-be-valid defaulted
		    (ignore time-specified-p)
		    (when (or (not relative-p) replace-relative-time)
		      (presentation-replace-input
			stream loc
			;; How to return other values (relative-p, time-specified-p)?
			(time:print-universal-time universal-time nil)))
		    universal-time)))))
   :printer ((time stream)
	     (write-string
	       (with-output-to-string (stream)
		 (cond ((null time)
			(princ "Never" stream))
		       (long-date (time:print-universal-date time stream timezone))
		       (brief
			(unless base-time (setq base-time (get-universal-time)))
			(time:print-brief-universal-time time stream base-time))
		       (t (time:print-universal-time time stream timezone))))
	       stream))
   :describer ((stream &key plural-count)
	       (presentation-string-pluralize "a universal time" stream plural-count)
	       (unless present-based
		 (when past-p
		   (write-string " in the past" stream))
		 (when base-time
		   (write-string " (base time is " stream)
		   (time:print-brief-universal-time base-time stream)
		   (write-char #\) stream))
		 (when must-have
		   (write-string ", " stream)
		   (write--and--sequence must-have stream (lambda (e s) (format s "~(~A~)" e)))
		   (write-string
		     (if (null (cdr must-have))
			 " is required"
		       " are required")
		     stream)))))

(define-presentation-type time:time-interval ()
   :history t
   :typep ((object) (integerp object))
   :parser ((stream &key type)
	    (si:with-parse-ferror (time:parse-error)
	      (let ((loc (send stream :read-location))
		    (token (read-standard-token stream)))
		(when (string-equal token "")
		  (error 'input-not-of-required-type :type type :string token))
		(let ((answer (time:parse-interval-or-never token)))
		  (presentation-replace-input stream loc
					      (with-output-to-string (s)
						(time:print-interval-or-never
						  answer s)))
		  answer))))
   :printer ((interval stream)
	     (time:print-interval-or-never interval stream)))

(define-presentation-type time:time-interval-60ths ()
   :history t
   :typep ((object) (integerp object))
   :parser ((stream &key type)
	    (si:with-parse-ferror (time:parse-error)
	      (let ((loc (send stream :read-location))
		    (token (read-standard-token stream)))
		(when (string-equal token "")
		  (error 'input-not-of-required-type :type type :string token))
		(let ((answer (time:parse-interval-or-never token)))
		  (presentation-replace-input stream loc
					      (with-output-to-string (s)
						(time:print-interval-or-never
						  answer s)))
		  (and answer (* answer 60))))))
   :printer ((interval stream)
	     (time:print-interval-or-never (and interval (round interval 60)) stream))
   :description "a time interval")

(define-presentation-type time:timezone-symbol (()
						&key force-numeric-p)
   :typep ((object) (and (numberp object)
			 ( -12 object +12)))
   :parser ((stream &key initially-display-possibilities type)
	    (values
	      (dw:completing-from-suggestions
		(stream :force-complete t
			:partial-completers '(#\Space)
			:initially-display-possibilities
			initially-display-possibilities
			:type type
			)
		(loop for zone in time:*timezones*
		      when (second zone)
			do (dw:suggest (second zone) (first zone))
		      when (third zone)
			do (dw:suggest (third zone) (1+ (first zone)))))))
   :printer ((timezone stream)
	     (write-string
	       (time:timezone-string timezone  (time:daylight-savings-p timezone)
						;:FORCE-NUMERIC-P
				     force-numeric-p)
	       stream))
   :description "a defined timezone symbol")

(define-presentation-type time:timezone-number ()
   :history nil
   :typep ((object) (and (numberp object)
			 ( -12 object +12)))
   :parser ((stream &key type)
	    (let* ((number-string (dw:read-standard-token stream))
		   (leading-char (unless (string-equal number-string "")
				   (aref number-string 0)))
		   number)
	      (unless (and leading-char (member leading-char '(#\+ #\-) :test #'char-equal))
		(zl:parse-ferror
		  "A timezone number must begin with + or -~:[~;; you typed ~:*\"~C\"~]."
		  leading-char))
	      (setq number (accept-from-string 'number number-string))
	      (unless (= 5 (string-length number-string))
		(zl:parse-ferror
		  "A timezone number must be four digits long."))
	      (values 
		(- (let* ((minutes (rem number 100.))
			  (zone (truncate number 100.)))
		     (cond ((> (abs zone) 12.)
			    (zl:parse-ferror
			      "Time zone hours must be in the range -12 to 12."))
			   ((not (or (= (abs minutes) 0) (= (abs minutes) 30)))
			    (zl:parse-ferror
			      "Time zone minutes must be on the half hour (either 00 or 30)"))
			   ((zerop minutes)
			    zone)
			   (t
			    (+ zone (/ (float minutes) 60.))))))
		type)))
   :printer ((timezone stream)
	     (write-string
	       (time:timezone-string
		 timezone (time:daylight-savings-p timezone) t) stream))
   :description "an hour offset from GMT such as +0500 (east of GMT) or -0330 (west of GMT)")

;;;Notice that this calls TIME:TIMEZONE-STRING the "new" way, with keyword args.
(define-presentation-type time:timezone (() &key force-numeric-p)
   :abbreviation-for '((or time:timezone-symbol time:timezone-number))
   :printer ((timezone stream)
	     (write-string 
	       (time:timezone-string timezone (time:daylight-savings-p timezone)
						;:FORCE-NUMERIC-P
				     force-numeric-p)
	       stream))
   :describer ((stream &key plural-count)
	       (when plural-count
		 (write-string "one or more of the following: " stream))
	       (dw:describe-presentation-type 'time:timezone-symbol stream)
	       (write-string " or " stream)
	       (dw:describe-presentation-type 'time:timezone-number stream)))


;;; We don't implement :loaded-only yet.
(define-presentation-type font ((&key #+ignore (loaded-only t)))
   :history t
   :no-deftype t
   :parser ((stream &key initially-display-possibilities)
;	    loaded-only				; Note the bug here: we don't really
						; implement LOADED-ONLY.
	    (values
	      (completing-from-suggestions (stream :partial-completers `(#\Space)
						   :type 'font	;; This makes it always
						   ;; complain about "loaded font"'s
						   :initially-display-possibilities
						   initially-display-possibilities)
		(do-symbols (s si:pkg-fonts-package)
		  (when (boundp s)
		    (suggest (symbol-name s) (symbol-value s)))))))

   :describer ((stream)
	       (if t ;loaded-only
		   (princ "a loaded font" stream)
		   (princ "a font" stream))))

(define-presentation-type sys:font-name ()
   :expander 'symbol
   :history t
   :parser ((stream)
	    (multiple-value-bind (nil nil token)
	      (completing-from-suggestions (stream :allow-any-input t :type 'sys:font-name)
		(do-symbols (s si:pkg-fonts-package)
		  (when (fed:font-boundp s)
		    (dw:suggest (symbol-name s) s))))
	      (when (equal token "")
		(error 'input-not-of-required-type :type 'sys:font-name :string token))
	      ;; prevent random typein character styles from affecting the result
	      (intern (nstring-upcase (string-thin token)) si:pkg-fonts-package)))
   :printer ((symbol stream)
	     (princ symbol stream))
   :description "a font name")

;; Benson suggests a dwim that goes looking for nonloaded even if you didn't ask,
;; and asks you.  Too bad it's so slow to do this  --SWM
(define-presentation-type sct:system ((&key (patchable-only nil)))
   :history t
   :no-deftype t

   :printer ((system stream)
	     (write-string (sct:system-pretty-name system) stream))

   :parser ((stream &key original-type initially-display-possibilities)
	    (parse-system-name stream original-type
			       (if patchable-only
				   sct:*patchable-systems-aarray*
				 sct:*true-systems-aarray*)
			       initially-display-possibilities))

   :describer ((stream)
	       (if patchable-only
		   (princ "a patchable system" stream)
		 (princ "a system" stream)))

   :presentation-subtypep
     ((type-1 type-2)
      (with-presentation-type-arguments (sct:system type-1)
	(let ((po-1 patchable-only))
	  (with-presentation-type-arguments (sct:system type-2)
	    (let ((po-2 patchable-only))
	      ;; Patchable-only is a subtype of everything, but not vice-versa
	      (or po-1 (eql po-1 po-2)))))))

   :typep ((system)
	   (or (not patchable-only)
	       (sct:system-patchable system))))


;; This is a misnomer, since the subsystem aarray contains subsystems and systems.
;; All users of this should really use 1'((or sct:subsystem sct:system))
0(define-presentation-type sct:subsystem ()
   :history sct:system
   :no-deftype t

   :printer ((system stream)
	     (write-string (sct:system-pretty-name system) stream))

   :parser ((stream &key original-type initially-display-possibilities)
	    (parse-system-name stream original-type
			       sct:*subsystems-aarray*
			       initially-display-possibilities))

   :describer ((stream)
	       (princ "a subsystem" stream)))

(defun parse-system-name (stream type completion-aarray
			  &optional initially-display-possibilities)
  (multiple-value-bind (string success system)
      ;; Keep your hands off 1:allow-any-input0 1nil0, it's so that this
      ;; only accepts loaded systems.  If you want to be able to type
      ;; in unknown systems, use 1(scl:type-or-string ((sct:system ...)))
0      ;; Even though the system aarrays are "whole-cdr" aarrays, we don't
      ;; bother to pass 1:whole-cdr0 1t0, because then we have to write our
      ;; own possibility presenter, (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")et cetera0.
      (complete-input-from-aarray
	completion-aarray stream
	:type type
	:allow-any-input nil
	:initially-display-possibilities initially-display-possibilities
	:partial-completers `(#\Space))
    (ignore string success)
    ;; No need to check for the case where STRING is NIL, since we use
    ;; a "whole-cdr" aarray for system objects
    (values system type)))

(define-presentation-type sct:system-version ((&key system))
   :typep ((object)
	   system
	   (or (keywordp object)
	       (integerp object)))

   :printer ((version stream)
	     (let ((*print-base* 10))
	       (format stream "~@(~A~)" version)))

   :parser ((stream &key type default initially-display-possibilities)
	    (let ((system (and system (sct:find-system-named system nil t))))
	      (multiple-value-bind (plist all-versions)
		  (and system (sct:get-system-defined-versions system :error-p nil))
		(multiple-value-bind (ptype default)
		    (if all-versions
			(values
			  `((member
			      ,@(cl:delete-duplicates
				  `(:latest :newest
				    ,@(loop for (key val) on plist by #'cddr
					    do (ignore val)
					    collect key)
				    ,@all-versions)))
			    :description ,(format nil "A version of ~A"
					    (sct:system-pretty-name system)))
			  (or default (getf plist :released) :latest))
			(values
			  '(type-or-string
			     ((or ((cl:member :released :latest :newest))
				  ((cl:integer (0))))))
			  (or default :released)))
		  (dw:with-accept-help-if (null all-versions)
		      (((:subhelp :override)
			(lambda (stream string-so-far)
			  (ignore string-so-far)
			  (format stream "Released, Latest, Newest, a positive integer, or some other designator"))))
		    (let ((version (accept ptype
					   :initially-display-possibilities
					     initially-display-possibilities
					   :stream stream :prompt nil
					   :default default)))
		      (values (if (not (stringp version))
				  version
				(if (or (null version)
					(string-equal version ""))
				    default
				  (intern (string-thin
					    (string-upcase (si:string-trim-whitespace version))
					    :remove-bits t :error-if :fat)
					  si:pkg-keyword-package)))
			      type)))))))

   :describer ((stream) (format stream "a version designator~@[ for ~A~]"
				(and system
				     (let ((s (sct:find-system-named system nil)))
				       (and s (sct:system-pretty-name s)))))))
   
(scl:define-presentation-type sct:system-branch ((&key system) &key (private-ok-p t))
   :history t

   :typep ((object)
	   system
	   (or (keywordp object)
	       (stringp object)))

   :printer ((branch stream)
	     (format stream "~@(~A~)" (string branch)))

   :parser ((stream &key type initially-display-possibilities default)
	    ;; Returns a keyword if it's a real system-branch, or a string
	    ;; if it's, say, a private branch
	    (let ((system (and system (sct:find-system-named system nil nil))))
	      (if system
		  (let ((branch-catalog
			  (delete-duplicates
			    (loop for branch-spec in (sct:system-branch-mapping system)
				  when (listp branch-spec)
				    append (car branch-spec)))))
		    (values
		      (accept
			(if private-ok-p
			    `((type-or-string ((member-sequence ,branch-catalog))))
			    `((member-sequence ,branch-catalog)))
			;; this is a kludge to get past a bug in TYPE-OR-STRING / or
			;; where null input is the null string instead of the top level
			;; default.
			:default default
			:stream stream
			:initially-display-possibilities initially-display-possibilities
			:prompt nil)
		      type))
		  (values (read-standard-token stream) type))))

   :describer ((stream)
	       (let ((system (and system (sct:find-system-named system nil nil))))
		 (if system
		     (format stream "a branch for ~A" (sct:system-pretty-name system))
		   (format stream "a system branch")))))


(define-presentation-type symbol-name ()
   :abbreviation-for 'string
   :parser ((stream)
	    (let ((fspec (let ((si:*reader-intern* #'make-symbol))
			   (accept 'function-spec :stream stream :prompt nil
				   :provide-default nil))))
	      (unless (symbolp fspec)
		(zl:parse-ferror "~S is not a symbol" fspec))
	      ;;The pname given to make-symbol was stack consed.
	      (values (copy-seq (symbol-name fspec)))))
   :description "a symbol name")


;;; Flavor inheritance brings all the other types right here.
(define-presentation-type net:object ((&key class))
   :history t
   :no-deftype t
   :data-arguments-are-disjoint t
   :parser ((stream &key initially-display-possibilities original-type default
			    default-supplied)
	    (block found
	      (when (null class)
		(setf class (neti:namespace-class-for-presentation-type original-type)))
	      (with-accept-help
		((:subhelp #'(lambda (stream ignore)
			       (cond ((or (null class) (eq class :object))
				      (format stream
					      "Enter the name of a namespace class ~
					       followed by the name of an object ~
					       of that class."))
				     ((with-type-decoded (the-type data-args)
					    original-type
					 (and (eq the-type 'net:object)
					      (or (null data-args)
						  (equal data-args '(:class :object)))))
				      (write-string "Enter " stream)
				      (describe-presentation-type `(neti:namespace-object
								     ,class)
								  stream))))))
		(when (or (null class) (eq class :object))
		  (setq class (accept `neti:namespace-class
				      :stream stream
				      :prompt nil
				      :default (or (and default-supplied
							default (send default :class))
						   (presentation-type-default
						     'neti:namespace-class))
				      :additional-blip-chars `(#\space)))
		  ;; check for space?
		  (let ((delimiter (peek-char-for-accept stream)))
		    (flet ((proper-accept-activation-p (char)
			     ;; why doesn't2 1accept-activation-p0 use 1compare-char-for-accept2?
0			     (loop for l in *accept-activation-chars*
				   thereis (member char l :test #'compare-char-for-accept))))
		      (cond
			((proper-accept-activation-p delimiter)
			 ;; stick in a space
			 (presentation-replace-input stream (send stream :read-location) " "
						     :dont-quote t))
			((compare-char-for-accept delimiter #\Space)
			 ;; get it out
			 (read-char-for-accept stream))
			(t
			 (cp::cp-error nil "You must supply a ~A object" class)))
		      (when (and default-supplied default
				 (proper-accept-activation-p delimiter))
			(presentation-replace-input
			  stream (send stream :read-location) (present-to-string default))
			(return-from found (values default (type-of default)))))))
		(values
		  (accept `(neti:namespace-object ,class)
			  :stream stream
			  :prompt nil
			  :default (if default-supplied default
				       (presentation-type-default
					 `((net:object :class ,class))))
			  :initially-display-possibilities
			    initially-display-possibilities)))))
   :printer ((object stream &key acceptably original-type)
	     (when (and acceptably (or (null class) (eq class :object))
			(eq (presentation-type-name original-type) 'net:object))
	       (present (send object :class) 'neti:namespace-class
			:stream stream :acceptably acceptably)
	       (write-char #\space stream))
	     (princ object stream))
   :typep ((object)
	   (or (null class)
	       (eq class :object)
	       (eql class (send object :class))))
   :describer ((stream &key plural-count original-type)
	       (when (null class)
		 (setf class (neti:namespace-class-for-presentation-type original-type)))
	       (if (or (null class) (eq class ':object))
		   (format stream "~:[a ~;~]namespace object~:*~:[~;s~]" plural-count)
		 (let ((class-describer (get class 'class-describer)))
		   (if class-describer
		       (funcall class-describer stream :plural-count plural-count)
		     (format stream "~:[a ~;~]~(~A~)~:[~;s~]"
			     plural-count class plural-count))))))

(define-presentation-type neti:namespace-class ()
   :abbreviation-for `((member-sequence ,neti:*all-classes*))
   :description "a namespace class")

(define-presentation-type neti:namespace-object1 0((class))
   :abbreviation-for `(net:object :class ,class)
   :parser ((stream &key initially-display-possibilities original-type default
			 default-supplied)
	    (let ((special-parser (get class 'class-parser)))
	      (values
		(object-presentation-parser stream class special-parser
					    :type original-type
					    :default (if default-supplied
							 default
							 (presentation-type-default
							   `((net:object :class ,class))))
					    :help-offers-possibilities nil
					    :initially-display-possibilities
					      initially-display-possibilities))))
   :printer ((object stream)
	     (princ object stream))
   :typep ((object)
	   (or (null class)
	       (eql class (send object :class))))
   :describer ((stream &key plural-count)
	       (let ((class-describer (get class 'class-describer)))
		 (if class-describer
		     (funcall class-describer stream :plural-count plural-count)
		     (format stream "~:[a ~;~]~(~A~)~:[~;s~]"
			     plural-count class plural-count)))))

(defun object-presentation-parser (stream class &optional special-parser
						&rest complete-input-options
						&key default
						&allow-other-keys)
  (flet ((parser (string)
	   (si:with-parse-ferror ((net:object-not-found net:unknown-host-name))
	     (if (string-equal string "")
		 string
	       (if special-parser
		   (funcall special-parser string)
		   (net:find-object-named class string))))))
    (let ((loc (send stream :read-location)))
      (macrolet ((replacer (thing)
		   `(presentation-replace-input stream loc ,thing)))
	(multiple-value-bind (object nil string)
	    (si:with-rem-keywords (complete-input-options complete-input-options '(:default))
	      (apply #'complete-input stream
		     (lambda (string action)
		       (neti:complete-namespace-object-name class string action))
		     :allow-any-input t
		     :parser #'parser
		     complete-input-options))
	  (cond ((and (null object) (string-equal string ""))
		 (setq object default))
		((null object)
		 (setq object (parser string))))
	  (let ((name (string object)))
	    (cond ((eq class :user)
		   (let ((lispm-name (send object :lispm-name)))
		     (if (string-equal lispm-name name)
			 (replacer lispm-name)
			 (replacer name))))
		  (t (replacer name))))
	  (values object (type-of object)))))))


;;; How to do hosts:

;;; Tell 1net:object0's 1:parser0 how to parse a 1:host0.
(defprop :host net:parse-host class-parser)
;;; Ditto for the 1:describer0.
(defun (:property :host class-describer) (stream &key plural-count &allow-other-keys)
  (princ
    (cond ((null plural-count) "the name of a host")
	  ((eq plural-count t) "names of hosts")
	  ((numberp plural-count)
	   (format nil "the names of ~R hosts" plural-count))
	  (t (format nil "the names of ~A hosts" plural-count)))
    stream))

(defun local-host-p (host)
  (neti:ns-eq host net:*local-host*))

(define-presentation-type net:local-host ()
   :expander `(and net:host (satisfies local-host-p))
   :parser ((stream &key initially-display-possibilities original-type)
	    (let ((local-host (follow-structure-forwarding net:*local-host*)))
	      (values
		(complete-from-sequence
		  (list "Local" (send local-host :pretty-name))
		  stream
		  :value-key #'(lambda (ignore) local-host)
		  :initially-display-possibilities initially-display-possibilities
		  :type original-type))))
   :printer "Local"
   :description "the name of the local host")

;;; Allow Local as a site name
(defun (:property :site class-parser) (string)
  (if (string-equal string "local")
      net:*local-site*
      (net:find-object-named :site string)))

;;; Allow Local as a namespace name
(defun (:property :namespace class-parser) (string)
  (if (string-equal string "local")
      net:*namespace*
      (net:find-object-named :namespace string)))

(defun neti:local-network-p (network)
  (neti:ns-memq network neti:*local-networks*))

(define-presentation-type neti:local-network ()
   :abbreviation-for `(and (or net:network si:fband-network)
			   (satisfies neti:local-network-p))
   :history t
   :parser ((stream &key initially-display-possibilities original-type)
	    (values
	      (complete-from-sequence neti:*local-networks* stream
				      :partial-completers '(#\Space)
				      :type original-type
				      :initially-display-possibilities
				       initially-display-possibilities)))
   :printer ((network stream)
	     (write-string (string network) stream))
   :description "the name of a local network")


(defun local-printer-p (printer)
  (neti:ns-memq printer hci::*last-hardcopy-device-list*))

(define-presentation-type local-printer ()
   :abbreviation-for '(and hci::printer (satisfies local-printer-p))
   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (complete-from-sequence (hardcopy:get-hardcopy-device-alist) stream
				      :name-key #'car :value-key #'cdr
				      :partial-completers `(#\Space)
				      :type original-type
				      :initially-display-possibilities
				      initially-display-possibilities)))
   :description "a local printer")

(define-presentation-type printer ()
   :abbreviation-for '((or local-printer hci:printer))
   :history t
   :printer ((printer stream) (princ (send printer :pretty-name) stream))
   :description "a printer")

;;;

(define-presentation-type tv:sheet ()
   :no-deftype t
   :history t
   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (completing-from-suggestions (stream
					     :partial-completers '(#\Space)
					     :type original-type
					     :initially-display-possibilities
					      initially-display-possibilities)
		;; When the system is fixed to not keep all these in its
		;; working set all the time, consider some other way
		;; to get all these.
		(labels ((suggest-sheet-and-inferiors (sheet)
			   (declare (dbg:invisible-frame :accept-internals))
			   (when (ptypep sheet original-type)
			     (suggest (tv:sheet-name sheet) sheet))
			   (dolist (inferior (tv:sheet-inferiors sheet))
			     (suggest-sheet-and-inferiors inferior))))
		  (dolist (screen tv:all-the-screens)
		    (suggest-sheet-and-inferiors screen))))))
   :printer ((window stream)
	     (write-string (tv:sheet-name window) stream))
   :description "a window")

;;; These descriptions aren't really right; they don't take into account
;;; inheritance.

;; These use the flavor-archy to do the type inheritance
(define-presentation-type tv:window ()
   :no-deftype t
   :description "an old-style window")

(define-presentation-type dw:dynamic-window ()
   :no-deftype t
   :description "a dynamic window")

(defparameter *drawing-alu-alist*
	      `(("Write Zeroes" :value ,boole-andc1)
		("Write Ones" :value ,boole-ior)
		("Complement" :value ,boole-xor)
		("Do Nothing" :value ,boole-2)))

(defparameter *general-alu-alist*
	      `(("Zeroes" :value ,boole-clr)
		("S*D" :value ,boole-and)
		("(~S)*D" :value ,boole-andc1)
		("D" :value ,boole-2)
		("S*(~D)" :value ,boole-andc2)
		("S#D" :value ,boole-xor)
		("S+D" :value ,boole-ior)
		("(~S)*(~D)" :value ,boole-nor)
		("S=D" :value ,boole-eqv)
		("~S" :value ,boole-c1)
		("(~S)+D" :value ,boole-orc1)
		("~D" :value ,boole-c2)
		("S+(~D)" :value ,boole-orc2)
		("(~S)+(~D)" :value ,boole-nand)
		("Ones" :value ,boole-set)))

(define-presentation-type tv:microcoded-graphics-alu ((&key (drawing t)))
   :description "an ALU"
   :history t
   :abbreviation-for `((token-or-type ,(if drawing *drawing-alu-alist* *general-alu-alist*)
				      (or ((unsigned-byte 4))
					  color:general-sc-color-alu))))

(define-presentation-type tv:alu-for-sheet ((sheet))
   :description "an ALU"
   :abbreviation-for (tv:screen-alu-presentation-type (tv:sheet-screen sheet)))

;;;

(defun resource-name-p (sym)
  (get sym 'defresource))

;; resource-name and not resource because users aren't supposed to fool with
;; resource descriptors

(define-presentation-type si:resource-name ()
   :history t
   :description "a resource name"
   :abbreviation-for '((and symbol (cl:satisfies resource-name-p))))

(defun initialization-list-name-p (symbol)
  (or (si:initialization-list-symbol-p symbol)
      (assoc symbol si:initialization-keywords)))

(define-presentation-type si:initialization-list-name ()
   :abbreviation-for `(and symbol (satisfies initialization-list-name-p))
   :history t
   :parser
   ((stream &key original-type initially-display-possibilities)
    (let* ((set (nconc (loop for (keyword list-name) in si:initialization-keywords
			     when list-name
			       collect keyword)
		       (loop for list-name in si:*additional-initialization-lists*
			     collect list-name)))
	   (list-name (complete-input-from-symbol-set stream set original-type
						      initially-display-possibilities)))
      (or (second (assoc list-name si:initialization-keywords))
	  list-name)))
   :description "an initialization list name")

(define-presentation-translator si:symbol-to-initialization-list-name
   (symbol si:initialization-list-name)
   (sym)
  (second (assoc sym si:initialization-keywords :test #'string-equal)))

(define-presentation-type fs:pathname-host ()
   :typep ((object) (typep object 'net:host))
   :printer ((host stream)
	     (princ host stream))
   :parser ((stream &key type)
	    (let* ((loc (send stream :read-location))
		   (name (dw:read-standard-token stream)))
	      (condition-case (host)
		   (fs:get-pathname-host name)
		 (fs:unknown-pathname-host
		   (error 'dw:input-not-of-required-type :string name :type type))
		 (:no-error
		   (dw::presentation-replace-input stream loc (string host))
		   (values host))))))


(define-presentation-type flavor-name ()
   :history t
   :abbreviation-for `((and symbol ((satisfies flavor-name-p))))
   :parser ((stream &key initially-display-possibilities original-type)
	    (complete-input-from-symbol-set stream *all-flavor-names-aarray* original-type
					    initially-display-possibilities))
   :printer ((object stream) (prin1 object stream))
   :description "a flavor name")

(defun flavor-name-p (x)
  (and (typep x '(and symbol (not null)))
       (flavor:find-flavor x nil)))

(define-presentation-type clos:class-name ()
   :history t
   :abbreviation-for `((and symbol ((satisfies class-name-p))))
   :parser ((stream &key initially-display-possibilities original-type)
	    (complete-input-from-symbol-set
	      stream
	      (locally
		(declare (special clos-internals:*all-class-names-aarray*))
		clos-internals:*all-class-names-aarray*)
	      original-type
	      initially-display-possibilities))
   :printer ((object stream) (prin1 object stream))
   :description "a class name")

(defun class-name-p (x)
  (and (typep x '(and symbol (not null)))
       (clos:find-class x nil)))

;;; Even less general version of the above.  A little bit of specific
;;; knowledge in the interest of greatly smaller completion tables.
(defun complete-generic-function-name (string action aarray
				       &optional suggester
						 (setf-symbol 'setf) (locf-symbol 'locf))
  (declare (values new-string success object new-character-pos nmatches))
  (let ((package *package*)
	(package-name nil)
	(suggest-name t)
	(suggest-setf t)
	(suggest-locf t)
	(cl-prefix-p nil)
	(name string))
    (when (plusp (string-length string))
      (let ((first-char (aref string 0)))
	(if (char-equal first-char #\()
	    (let ((start-index 1)
		  (end-index (string-length string)))
	      (when (char-equal (aref string (1- end-index)) #\))
		(decf end-index))
	      (when (string-equal string "CL:" :start1 start-index :end1 (+ start-index 3))
		(incf start-index 3)
		(setq cl-prefix-p t))
	      (let ((word-end (or (string-search-char #\Space string :start start-index)
				  end-index)))
		(setq suggest-name nil
		      ;; Might allow both if nothing before the space.
		      suggest-setf (string-equal string 'setf :start1 start-index
							      :end1 word-end
							      :end2 (- word-end start-index))
		      suggest-locf (string-equal string 'locf :start1 start-index
							      :end1 word-end
							      :end2 (- word-end start-index))
		      start-index (if (< word-end end-index) (1+ word-end) word-end))
		;; Because of space overloading in the CP, this will get called for the first
		;; part, no matter what the user manages to type.  So, a little fib in the
		;; interest of efficiency, since we know no one needs the real answer.
		(when (and (or suggest-setf suggest-locf)
			   (eq action :complete-limited)
			   (= start-index end-index))
		  (let ((answer (string-append #\( (if cl-prefix-p "CL:" "")
					       (cond ((and suggest-setf suggest-locf) "")
						     (suggest-setf 'setf)
						     (suggest-locf 'locf))
					       (if (= word-end end-index) "" #\Space))))
		    (return-from complete-generic-function-name
		      (values answer t nil (string-length answer) 69)))))
	      (let ((index (string-search-char #\: string :start start-index :end end-index)))
		(when index
		  (setq package (find-package (substring string start-index index))
			index (1+ (string-search-char #\: string
						      :start start-index
						      :end end-index
						      :from-end t))
			package-name (substring string start-index index)
			start-index index)))
	      (setq name (substring string start-index end-index)))
	  (unless (member action *completion-needs-full-set*)
	    (setq suggest-setf nil suggest-locf nil))
	  (let ((index (string-search-char #\: string)))
	    (when index
	      (setq package (find-package (substring string 0 index))
		    index (1+ (string-search-char #\: string :from-end t))
		    package-name (substring string 0 index)
		    name (substring string index)))))))
    (suggestion-completer (string :action action :delimiters zwei:*completing-delims*)
      (let ((subset (if (or (member action *completion-needs-full-set*)
			    (equal name ""))
			aarray			;Need to look at everything
			(multiple-value-bind (nil completions)
			    (zwei:complete-string name aarray zwei:*completing-delims*)
			  completions))))
	(flet ((map-over-matches (function)
		 (declare (downward-funarg function))
		 (if package-name
		     (when package
		       (map 'nil
			    (lambda (element)
			      (let* ((name (if (consp element)
					       (car element)
					       (symbol-name element)))
				     (accessible (intern-soft name package)))
				(when (and accessible
					   (if (consp element)
					       (member accessible (cdr element))
					       (eq accessible element)))
				  (funcall function name accessible))))
			    subset))
		     (map 'nil
			  (lambda (element)
			    (let ((name (if (consp element)
					    (car element)
					    (symbol-name element))))
			      (cond ((atom element)
				     (funcall function name element))
				    ((null (cddr element))
				     ;; Only one, offer it.
				     (funcall function name (cadr element)))
				    (t
				     (let ((preferred (intern-soft name package)))
				       (if (member preferred (cdr element))
					   (funcall function name preferred)
					   (dolist (symbol (cdr element))
					     (funcall function name symbol))))))))
			  subset))))
	  (if (and (not suggest-setf) (not suggest-locf) (null package-name))
	      ;; Most common case, just the symbol names themselves without package prefixes.
	      ;; No need for string consing.
	      (when suggest-name
		(map-over-matches #'suggest))
	      (when package
		(labels ((suggest-subset (prefix suffix type)
			   (map-over-matches
			     #'(lambda (name symbol)
				 (if (null type)
				     (suggest (string-append prefix name suffix) symbol)
				     (stack-let ((whole-name (list type symbol)))
				       (let ((suggestion (funcall suggester whole-name)))
					 (when suggestion
					   (suggest (string-append prefix name suffix)
						    suggestion))))))))
			 (suggest-type (type)
			   (suggest-subset (nstring-upcase
					     (string-append "(" (if cl-prefix-p "CL:" "")
							    type " " (or package-name "")))
					   ")" type)))
		  (when suggest-name
		    (suggest-subset (if package-name (nstring-upcase package-name) "") "" nil))
		  (when suggest-setf
		    (suggest-type setf-symbol))
		  (when suggest-locf
		    (suggest-type locf-symbol))))))))))

(define-presentation-type generic-function-name ((&key defined) &key show-compatible-message)
   :no-deftype t				;type is already defined
   :history t
   :parser ((stream &key initially-display-possibilities original-type)
	    (flavor::standardize-generic-function-name
	      (complete-input-from-symbol-set
		stream *all-generic-function-names-aarray*
		original-type
		initially-display-possibilities
		#'(lambda (string
			   &optional
			   (action :complete)
			   (aarray *all-generic-function-names-aarray*))
		    (complete-generic-function-name
		      string action aarray
		      #'(lambda (whole-name)
			  (let ((gf (flavor:find-generic-function whole-name nil)))
			    (when gf
			      (generic-function-name gf)))))))))
   :printer ((name stream &key original-type)
	     ;; Prevent the inside printing from being sensitive, to avoid confusion
	     (with-output-as-presentation (:stream stream
					   :object name :type original-type
					   :allow-sensitive-inferiors nil)
	       (prin1 name stream)
	       (when show-compatible-message
		 (let* ((gf (flavor:find-generic-function name nil))
			(message (and gf (generic-function-compatible-message gf))))
		   (when message
		     (format stream " (~S)" message))))))
   :description "a Flavors generic function name")

(define-presentation-type clos-internals:generic-function-name
      ((&key defined))
   :no-deftype t				;type is already defined
   :history t
   :parser ((stream &key initially-display-possibilities original-type)
	    (complete-input-from-symbol-set
	      stream
	      (locally
		(declare (special clos-internals:*all-generic-function-names-aarray*))
		clos-internals:*all-generic-function-names-aarray*)
	      original-type
	      initially-display-possibilities
	      #'(lambda (string
			 &optional
			 (action :complete)
			 (aarray clos-internals:*all-generic-function-names-aarray*))
		  (declare (special clos-internals:*all-generic-function-names-aarray*))
		    (complete-generic-function-name
		      string action aarray
		      #'(lambda (whole-name)
			  (let ((fi (si:valid-function-definition whole-name)))
			    (when (clos-internals::generic-function-p fi)
			      (clos-internals:function-name-object fi))))
		      'future-common-lisp:setf 'locf))))
   :printer ((name stream &key original-type)
	     ;; Prevent the inside printing from being sensitive, to avoid confusion
	     (with-output-as-presentation (:stream stream
					   :object name :type original-type
					   :allow-sensitive-inferiors nil)
	       (prin1 name stream)))
   :description "a CLOS generic function name")

;;; Instance variable accessors are almost like function specs, but not quite
;;; This is output-only and most of the function-spec commands don't work on these
(scl:define-presentation-type flavor:instance-variable-accessor ()
   :printer ((function-spec *standard-output*)
	     (flavor::print-method-spec function-spec nil)
	     (format t " of flavor ~S" (flavor:method-flavor function-spec))))

(defun function-spec-any-definition (fspec)
  (and (si:validate-function-spec fspec)
       (or (fdefinedp fspec)
	   (si:function-spec-get fspec :source-file-name)
	   (si:function-spec-get fspec 'zwei:zmacs-buffers)
	   (si:function-spec-get fspec 'flavor:generic))))

(defun abbreviate-function-spec (fspec &optional (stream *standard-output*))
  (labels ((brains (fspec stream)
	     (cond ((not (consp fspec))
		    (format stream "~S" fspec))
		   ((member (car fspec) flavor:*fdefinable-method-types*)
		    (format stream "~:(~A~) ~S" (car fspec) (cdr fspec)))
		   (t
		    (case (car fspec)
		      (:internal
			;; we blow out all the unnamed layers
			(write-string "Internal " stream)
			(loop with spec = fspec
			      do
			  (destructuring-bind (ignore next-spec index &optional name) spec
			    (if name (format stream "~S " name)
				(format stream "~D " index))
			    (write-string "of " stream)
			    (when (or (not (consp next-spec))
				      (neq (car next-spec) ':internal))
			      (brains next-spec stream)
			      (return nil))
			    (setq spec next-spec))))
		      (:format
			(format stream "Format Directive ~s" (second fspec)))
		      ((cp::command-parser cp::command-parser-function)
		       (format stream "Command Parser ~s" (second fspec)))
		      (:property
			(format stream "Property ~s on ~s" (third fspec) (second fspec)))
		      ((dw::presentation-function dw::presentation-mouse-handler)
		       (write-string
			 (ecase (first fspec)
			   (dw::presentation-function "Presentation")
			   (dw::presentation-mouse-handler "Pres-Mouse-Handler"))
			 stream)
		       (when (third fspec) (format stream " ~:(~a~)" (third fspec)))
		       (format stream " for ~s" (second fspec)))
		      (otherwise (format stream "~S" fspec)))))))
    (brains fspec stream)))


(defvar-standard *abbreviate-function-specs* nil nil nil)

(defun function-spec-printer (spec stream abbreviate-p)
  (if abbreviate-p
      (abbreviate-function-spec spec stream)
      ;; Leave :pretty set to whatever the caller set it to, because it is bound by
      ;; things like present-for-documentation, to avoid unwanted carriage returns.
      (write spec :stream stream
		  :level nil
		  :length nil
		  :abbreviate-quote t)))

;;;--- Default for DEFINED-P should be * when that works
(define-presentation-type function-spec ((&key defined-p)
					 &key (partial-completers '(#\Space))
					      (abbreviate-p *abbreviate-function-specs*))
   :history t
   :abbreviation-for (ecase defined-p
		       ((nil)
			`((and expression
			       ((satisfies si:validate-function-spec)))))
		       ((t)
			`((and expression
				((satisfies si:validate-function-spec))
				((satisfies si:fdefinedp)))))
		       ((:any)
			`((and expression
			       ((satisfies function-spec-any-definition))))))
   :printer ((object stream &key acceptably)
	     (function-spec-printer object stream
				    (and abbreviate-p (not acceptably))))

   :parser ((stream &key type initially-display-possibilities)
	    ;; Temporary until there is a completion b-tree instead
	    (multiple-value-bind (string success returned-fspec)
		(complete-input-from-aarray zwei:*zmacs-completion-aarray* stream
					    :type type
					    :allow-any-expression-input t
					    :allow-any-input t
					    :initially-display-possibilities
					     initially-display-possibilities
					    :help-offers-possibilities ':within-token
					    :partial-completers partial-completers)
	      ;; Always read, rather than using objects in aarray, since
	      ;; package might be wrong.
	      (multiple-value-bind (read-fspec error-p)
		  (when string
		    (si:with-parse-ferror (zwei:barf)
		      (let ((*query-io* stream))	;In case it asks.
			(zwei:symbol-from-string string nil t))))
		(let ((fspec
			(cond ((and success (null string)
				    (not (null returned-fspec)))
			       ;; The user clicked on something, just use it
			       returned-fspec)
			      ((not (or error-p
					(and success
					     (symbolp read-fspec)
					     (eq (symbol-package read-fspec)
						 zwei:*utility-package*))))
			       read-fspec)
			      (success
			       returned-fspec)
			      (t
			       (cond ((or (eq error-p t)
					  (null error-p))
				      (zl:parse-ferror
					"~A is not a valid function-spec" read-fspec))
				     (t
				      (zl:parse-ferror "~A" error-p)))))))
		  (if (cond ((null defined-p)
			     (si:validate-function-spec fspec))
			    ((eq defined-p t)
			     (and (si:validate-function-spec fspec)
				  (si:fdefinedp fspec)))
			    (t			;must be :ANY
			     (let* ((char (peek-char-for-accept stream))
				    (real-char (if (listp char) (second char) char))
				    (any-definition
				      (or (eq success t)
					  (function-spec-any-definition fspec))))
			       ;; Don't let the person use #\End to type in a bogus
			       ;; function spec.  #\Return is OK, though...
			       (if (eql real-char #\End)
				   any-definition
				 (si:validate-function-spec fspec)))))
		      fspec
		    (zl:parse-ferror "~S is not a defined function spec." fspec))))))
   :describer ((stream)
	       (format stream
		   (if defined-p "a defined function spec" "a function spec"))))



(define-presentation-type si:lisp-syntax ()
   :no-deftype t
   :parser ((stream)
	    (multiple-value-bind (syntax success name)
		(dw:completing-from-suggestions (stream :force-complete t
							:partial-completers '(#\sp))
		  (loop for x in si:*known-lisp-syntaxes* do
		    (dw:suggest (si:lisp-syntax-external-name x) x)))
	      (ignore success name)
	      (values syntax 'si:lisp-syntax)))
   :description "a lisp syntax name"
   :printer ((syntax stream)
	     (when (keywordp syntax) (setq syntax (si:lisp-syntax-from-keyword syntax)))
	     (cl:write-string (si:lisp-syntax-external-name syntax) stream))) 


2;;; Define the keyword value pairs presentation type.  
;;; This takes an argument of the form
;;; (accept '(k0eyword-value-pairs
;;;             '((SAVE-BUFFERS '((MEMBER :YES :NO :ASK)) 
;;;                             :DEFAULT :ASK 
;;;                             :DOCUMENTATION "Save modified buffers before logging out")
;;;                ...))
;;; and returns the keywords with either their mentioned values or their
;;; default values

(define-presentation-type keyword-value-pairs ((arg-specs))
   :description "keyword value pairs"
   :parser ((stream) (parse-keyword-value-pairs stream arg-specs))
   :printer ((object stream)
	     (loop for spec on object by 'cddr do
	       (present spec `((keyword-value-pair ,arg-specs))
			:stream stream))))

(defun parse-keyword-value-pairs (stream arg-specs)
  (let
    ((pairs nil)
     (pair nil)
     (objs arg-specs))
    (block done-with-the-parse
      (condition-bind ((dw::input-not-of-required-type
			 #'(lambda (e)
			     (when (and (dw:presentation-subtypep (send e :type)
								  'cp::keyword-argument)
					(string-equal (send e :string) ""))
			       (return-from done-with-the-parse)))))
	(loop
	  (when (dw:compare-char-for-accept (dw:peek-char-for-accept stream) #\return)
	    (return))
	  (setq pair (accept `((keyword-value-pair ,objs))
			     :stream stream
			     :prompt nil
			     :additional-blip-chars '(#\space)))
	  (setq objs (remove (car pair) objs :key #'car))
	  (setq pairs (append pairs pair)))))
    pairs))

(defun merge-keyword-value-pairs (pairs arg-specs)
  (let ((l '()))
    (dolist (spec arg-specs)
      (let ((key (car spec)))
	(unless (loop for (explicit-key) on pairs by 'cddr thereis (eq key explicit-key))
	  (setq l (list* (eval (getf (cddr spec) :default)) key l)))))
    (nreconc l pairs)))
	   
(define-presentation-type keyword-value-pair ((arg-specs))
   :parser ((stream)
	    (parse-keyword-value-pair stream arg-specs))
   :printer ((object stream) ;object is a subtail of a keyword-value-pairs
	     (let ((key (car object))
		   (val (cadr object)))
	       (format stream ":~A ~@\\PRESENTATION\\~:[~; ~]"
		       (string-capitalize-words key)
		       val
		       (eval (cadr (or (assoc key arg-specs)
				       (error "~S is not a valid keyword." key))))
		       (cddr object)))))

(defun parse-keyword-value-pair (stream arg-specs)
  (sys:check-arg arg-specs (every #'(lambda (spec)
				      (and (listp spec)
					   (keywordp (car spec))
					   (loop for (key) on (cddr spec) by 'cddr
						 always
						   (member key '(:default
								 :prompt
								 :mentioned-default
								 :documentation)))))
				  arg-specs)
		 "a keyworded alist")
  (let ((evaluated-argspecs (mapcar #'(lambda (spec) (mapcar #'eval spec)) arg-specs)))
    (labels ((get-keyword-spec (key) (assoc key evaluated-argspecs))
	     (get-presentation-type (key) (cadr (get-keyword-spec key)))
	     (get-keyword-prompt (key) (getf (cddr (get-keyword-spec key)) :prompt))
	     (get-keyword-mentioned-default (key)
	       (let ((options (cddr (get-keyword-spec key))))
		 (getf options :mentioned-default (getf options :default))))
	     (get-keywords-and-arguments ()
	       (mapcar #'(lambda (obj)
			   (destructuring-bind (key ignore . options) obj
			     (cons key options)))
		       evaluated-argspecs)))
      (let* ((keyword (accept `(cp::keyword-argument ,@(get-keywords-and-arguments))
			      :additional-blip-chars '(#\space)
			      :stream stream
			     ;What was this?? -kmp
			     ;:prompt-after nil
			      :provide-default nil
			      :prompt nil
			      :prompts-in-line t))
	     (presentation-type (get-presentation-type keyword))
	     (pair nil))
	(unless (dw:compare-char-for-accept (dw:read-char-for-accept stream) #\space)
	  (sys:parse-error "Must terminate with space"))
	(setq pair (list keyword
			 (accept (let* ((prompt (get-keyword-prompt keyword)))
				   (if (not prompt)
				       presentation-type
				       (let ((presentation-type
					       (cond ((atom presentation-type)
						      (list (list presentation-type)))
						     ((atom (car presentation-type))
						      (list presentation-type))
						     (t
						       (copy-list presentation-type)))))
					 (setf (getf (cdr presentation-type) :description)
					       prompt)
					 presentation-type)))
				 :stream stream
				 :additional-blip-chars '(#\space)
				 :default (get-keyword-mentioned-default keyword))))
	(when (dw:compare-char-for-accept (dw:peek-char-for-accept stream) #\space)
	  (dw:read-char-for-accept stream))
	pair))))

(define-presentation-type tv:window-flavor ((&key required-init-option))
   :abbreviation-for
   `(and flavor-name
	 (cl:satisfies
	   (lambda (fl)
	     (let ((wt (flavor:find-flavor fl nil)))
	       (and wt
		    (zl:memq 'tv:sheet (flavor:flavor-all-components wt))
		    (if ,required-init-option 
			(flavor-allows-init-keyword-p fl ,required-init-option)
			t)))))
	 ))
