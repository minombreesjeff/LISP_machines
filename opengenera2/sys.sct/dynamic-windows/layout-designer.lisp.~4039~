;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DW; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; These size functions are used to simulate the constraint frame layout
;;; code for various pane types.
;;; Some day this should USE the constraint frame code.
(defun command-menu-size-function (direction ignore ignore
				   &key columns rows &allow-other-keys)
  (ecase direction
    (:vertical (values (cond ((null rows) 2)
			     ((listp rows) (length rows))
			     ((numberp rows) rows)
			     (t 2))
		       :character))
    (:horizontal (and columns (values (* 10	;Average item size
					 (cond ((listp columns) (length columns))
					       ((numberp columns) columns)))
				      :character)))))

(defun interactor-size-function (direction ignore ignore &key height-in-lines
							 &allow-other-keys)
  (case direction
    (:vertical (and height-in-lines (values height-in-lines :character)))))

(defun title-size-function (direction ignore ignore &key (height-in-lines 1)
							 &allow-other-keys)
  (case direction
    (:vertical (and height-in-lines (values height-in-lines :character)))))

;;; Associate size functions with pane types
(defvar *type-size-functions*
	'((:interactor interactor-size-function)
	  (:display interactor-size-function)
	  (:command-menu command-menu-size-function)
	  (:title title-size-function)))

(defflavor layout-pane
	(box
	 name
	 type
	 (options nil)
	 (stacking-direction :vertical)
	 (superior nil)
	 (inferiors nil))
	()
  (:conc-name layout-pane-)
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (sys:print-self layout-pane) (stream ignore ignore)
  (printing-random-object (self stream :typep)
    (write name :stream stream)
    (write-string " " stream)
    (write type :stream stream)))

(defmethod (make-instance layout-pane) (&rest ignore)
  (unless (variable-boundp name)
    (setq name 'pane))
  (let ((type-info (find-program-pane-type type)))
    ;; We are using some "phony" pane types (:ROW and :COLUMN) which
    ;; don't have any define-program-framework definitions, so there may
    ;; not be any type-info
    (when type-info
      ;; pick up default options for the pane type
      (setq options (merge-plists options (program-pane-type-default-init-plist type-info)))
      ;; Prune the set to include only those that the user is allowed
      ;; to modify.
      (setq options (zwei:some-plist options
				     (program-pane-type-allowed-options type-info))))))

;;; Pane option selection AVV code.

;;; These macros hide the fact that we have to quote all the
;;; pane option values that we read with various ACCEPT calls.

;;; Get the value out of the list, stripping a quote if it has one.
(defmacro get-option-value (options indicator)
  `(multiple-value-bind (value supplied)
       (si:multiple-value-get (locf ,options) ,indicator)
     (values (if (and (listp value)
		      (eq (first value) 'quote))
		 (second value)
		 value)
	     supplied)))
;;; Put a value back into the options list, quoting it if necessary
;;; So this doesn't follow the CL SETF model.  So sue me.
(defmacro set-option-value (options indicator value &environment env)
  ;; avoid multiple calls to ACCEPT inside an AVV
  (once-only (value &environment env)
    `(setf (getf ,options ,indicator)
	   (if (constantp ,value)
	       ,value
	       `',,value))))

;;; Called by Set Pane Options, present pane options as AVV.
(defun choose-pane-type-and-options (pane)
  (format t "~&Options for pane ~S:~%" (layout-pane-name pane))
  (multiple-value-bind (name type options)
      (let ((options (copy-list (layout-pane-options pane)))
	    (options-are-for-type (layout-pane-type pane)))
	(with-typeout-window-for-accept-values
	  ;; :resynchronize-every-pass needed due to complex display
	  (accepting-values (t :resynchronize-every-pass t)
	    ;; read name, and type for all panes
	    (let* ((name (accept 'symbol :default (layout-pane-name pane)
				 :prompt "Pane name"))
		   (type (accept `((member ,@(map 'list #'program-pane-type-name
						  *program-pane-types*)))
				 :default (layout-pane-type pane) :prompt "Pane type"))
		   (type-info (find-program-pane-type type)))
	      (when (neq type options-are-for-type)
		;; The options stored in the pane structure are stale if the
		;; user changes the pane type.  Refresh them.
		(setq options (copy-list (if (eq type (layout-pane-type pane))
					     (layout-pane-options pane)
					     (program-pane-type-default-init-plist
					       type-info)))
		      options-are-for-type type))
	      ;; a list of option D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")names0 allowed for this pane
	      (let ((unhandled-options (program-pane-type-allowed-options type-info)))
		;; Handle certain sets of related options in separate functions.
		;; Each function returns the list of options it didn't handle and
		;; the updated options list.
		;; special-case redisplay options because of interrelationships
		(multiple-value-setq (unhandled-options options)
		  (handle-redisplay-options unhandled-options options))
		;; ditto menu options
		(multiple-value-setq (unhandled-options options)
		  (handle-menu-options unhandled-options options))
		;; Take care of all options that weren't special-cased above
		(loop for option in unhandled-options
		      for value = (get-option-value options option)
		      do
		  (multiple-value-bind (new-value nil unchanged-p)
		      ;; option-info includes a presentation type used to read it
		      (let ((option-info (or (assoc option *program-pane-options*)
					     ;; no info, read an expression, prompting
					     ;; with option name
					     `(foo expression
						   ,(string-capitalize-words option)))))
			(destructuring-bind (ignore presentation-type prompt)
			   option-info
			  (accept presentation-type :prompt prompt :default value)))
		    (unless unchanged-p
		      (if (eq option :flavor)
			  (setf (getf options option) new-value)
			  (set-option-value options option new-value)))))
		;; still inside the accepting-values
		;; return values to the multiple-value-bind way back at the beginning
		(values name type options))))))
    ;; put the options in the pane structure.
    (setf (layout-pane-name pane) name
	  (layout-pane-type pane) type
	  (layout-pane-options pane) options)))

;; Handle the interdependent redisplay-related pane options
;; (assume that :redisplay-function and :redisplay-string always travel
;; together, and that anywhere :redisplay-function is allowed,
;; :incremental-redisplay is allowed as well)
(defun handle-redisplay-options (unhandled-options options)
  (let ((redisplay-options '(:redisplay-function :redisplay-string :incremental-redisplay)))
    (when (not (null (intersection redisplay-options
				   unhandled-options)))
      (let* ((function-value (get-option-value options :redisplay-function))
	     (string-value  (get-option-value options :redisplay-string))
	     (incremental-value (get-option-value options :incremental-redisplay))
	     (redisplay-type (cond (function-value 'function)
				   (string-value 'string)
				   (t 'none))))
	(setq redisplay-type (accept '((alist-member
					 :alist (("None" :value none
						  :documentation "No automatic redisplay for this pane")
						 ("String" :value string
						  :documentation "Specify a string to display in this pane")
						 ("Function" :value function
						  :documentation "Specify a function to call to generate output for this pane"))))
				     :prompt "Redisplay output generator"
				     :default redisplay-type))
	(ecase redisplay-type
	  (none
	    (remf options :redisplay-function)
	    (remf options :redisplay-string)
	    (remf options :incremental-redisplay))
	  (string
	    (remf options :incremental-redisplay)
	    (remf options :redisplay-function)
	    (set-option-value options :redisplay-string
			      (accept 'string :prompt "Redisplay string"
				      :default string-value)))
	  (function
	    (remf options :redisplay-string)
	    (set-option-value options :redisplay-function
			      (accept 'sys:function-spec
				      :prompt "Redisplay function"
				      :default function-value))
	    (set-option-value options :incremental-redisplay
			      (accept 'boolean :prompt "Incremental redisplay"
				      :default incremental-value))))))
    ;; remove the redisplay-related options
    (values (set-difference unhandled-options redisplay-options)
	    options)))

(defun handle-menu-options (unhandled-options options)
  (let ((menu-options '(:rows :columns)))
    (when (not (null (intersection menu-options
				   unhandled-options)))
      ;; first find out the values of options already in the list
      (multiple-value-bind (rows-value rows-supplied)
	  (get-option-value options :rows)
	(multiple-value-bind (columns-value columns-supplied)
	    (get-option-value options :columns)
	  (let (new-value rows-or-columns which-way prompt-string)
	    ;; pick starting values for options based on plist
	    (setq rows-or-columns (cond (rows-supplied
					 :rows)
					(columns-supplied
					 :columns)
					(t
					 :default)))
	    ;; accept these two parameters independently, use results to SETF the
	    ;; appropriate options to the appropriate values
	    (setq rows-or-columns (accept '((alist-member
					      :alist (("Default" :value :default
						       :documentation "Use the default menu geometry")
						      ("Rows" :value :rows
						       :documentation "Specify menu by rows")
						      ("Columns" :value :columns
						       :documentation "Specify menu by columns"))))
					  :prompt "Menu geometry"
					  :default rows-or-columns))
	    (case rows-or-columns
	      ;; lucky for me "row" and "column" both pluralize simply
	      (:rows (setq new-value rows-value
			   prompt-string "row"))
	      (:columns (setq new-value columns-value
			      prompt-string "column")))
	    (setq which-way (if (numberp new-value)
				'number
				'contents))
	    ;; only read which-way and values if specifying geometry
	    (unless (eq rows-or-columns :default)
	      (setq which-way (accept '((member number contents))
				      :default which-way
				      :prompt (format nil "Specify number of ~As or ~A contents"
						      prompt-string prompt-string)))
	      (ecase which-way
		(number
		  (unless (numberp new-value)
		    (setq new-value 1))
		  (setq new-value (accept 'integer
					  :prompt (format nil "Number of ~As"
							  prompt-string)
					  :default new-value)))
		(contents
		  (unless (listp new-value)
		    (setq new-value nil))
		  (setq new-value (read-menu-list new-value (format nil prompt-string))))))
	    ;; set the options in the plist depending on which modes the user chose
	    (ecase rows-or-columns
	      (:default
		(remf options :columns)
		(remf options :rows))
	      (:rows
		(remf options :columns)
		(set-option-value options :rows new-value))
	      (:columns
		(remf options :rows)
		(set-option-value options :columns new-value)))))))
    ;; remove the redisplay-related options
    (values (set-difference unhandled-options menu-options)
	    options)))

;;; This function (called inside accepting-values) reads menu items one
;;; row (or column) at a time.  Each row is read as a sequence of
;;; strings.  One more row prompt is displayed than there are existing
;;; rows, allowing the user to add a new row at the end (sort of like the
;;; namespace editor options).
(defun read-menu-list (item-list name)
  (let ((cache (make-array (length item-list)
			   :fill-pointer t
			   :initial-contents item-list)))
    ;; read each existing row or column, plus one new one
    (loop for count below (length cache)
	  for item = (elt cache count)
	  finally (let ((last (accept '((sequence string))
				      :prompt (format nil "Items in ~A ~D" name (1+ count))
				      :default nil)))
		    (when last
		      (vector-push-extend last cache)))
	  do
      (let ((new-item (accept '((sequence string))
			      :prompt (format nil "Items in ~A ~D" name (1+ count))
			      :default item)))
	(setf (elt cache count)
	      new-item)))
    (coerce cache 'list)))

;;; The layout designer program itself

(define-program-framework layout-designer
  :pretty-name "Frame-Up"			;funny how this is the "Pretty" name...Yecch.
  :select-key #\Q
  :system-menu "Frame-Up"
  :top-level (layout-designer-top-level)
  :command-definer t
  :command-table (:kbd-accelerator-p nil
		  :inherit-from nil)
  :panes ((title :title
		 :redisplay-function 'display-layout-title)
	  (output :display
		  :typeout-window t
		  :redisplay-function 'display-layout)
	  (interactor :interactor)
	  (command-menu :command-menu
			:columns '(("Set Program Options" "Select Configuration"
				    "Reset Configuration" "Preview" "Done")
				   ("Set Pane Options" "Set Pane Name" "Split Pane"
				    "Swap Panes" "Delete Pane"))))
  :state-variables ((package nil)
		    (top-pane nil)
		    (configuration-name 'main "Configuration name" symbol)
		    (program-name 'user::dummy-program "Program name" symbol)
		    (program-state-variables nil "State variables"
					     ((sequence ((sequence-enumerated
							   symbol
							   expression
							   string
							   presentation-type)))))
		    (program-command-definition-macro t "Name of command-defining macro"
						      symbol)
		    (program-command-table-components '("colon full command"
							"standard arguments"
							"input editor compatibility")
						      "Command tables to inherit from"
						      ((sequence
							 ((type-or-string
							    cp::command-table)))))
		    (program-command-table-uses-kbd-accelerators
		      nil "Read single-character command accelerators" boolean)
		    (program-select-key nil "Select key" ((null-or-type character)))
		    ))

(defun layout-designer-top-level (program &rest options)
  (let-if (layout-designer-package program)
	  ((*package* (find-package (layout-designer-package program))))
    (apply #'default-command-top-level program options)))

(defmethod (make-instance layout-designer :after) (&rest ignore)
  (setq top-pane (make-new-pane self :display)))

(defmethod (make-new-pane layout-designer) (type &rest args
						 &key (name nil name-supplied) &allow-other-keys)
  ;; no name supplied, generate one from the type
  (unless name-supplied
    ;; call display panes "display", others by their names
    (setq name (case type
		 (:display "PANE")
		 (otherwise (string type)))))
  ;; add a number to the end of the name
  (setq name (generate-unique-pane-name self (string-append name "-")))
  (apply #'make-instance 'layout-pane
	 :type type :name name (si:rem-keywords args '(:name))))

(defun-in-flavor (map-over-all-panes layout-designer) (function)
  (map-over-layout-panes top-pane function))

;;; --- bug here if a standard layout contains more than one pane of
;;; a given type
(defmethod (generate-unique-pane-name layout-designer) (&optional (name-root "PANE-"))
  (let ((max-number 0))
    (map-over-all-panes
      #'(lambda (pane)
	  (let ((pane-name (string (layout-pane-name pane))))
	    (when (string-equal pane-name
				name-root
				:end1 (length name-root))
	      ;; when the first part of the name matches, try to extract the number
	      (let ((pane-number (si:parse-number pane-name (length name-root) nil 10 t)))
		(when pane-number
		  ;; if we could parse a number, see if it is the largest so far
		  (setq max-number (max pane-number max-number))))))))
    ;; make the new name
    (fintern "~A~D" name-root (1+ max-number))))

(defmethod (display-layout-title layout-designer) (stream)
  (independently-redisplayable-format
    stream
    "Layout for program ~S"  ; until we do configurations: ", configuration ~A."
    program-name ; configuration-name
    ))

;;; remember the FUNDEFINE when this is patched
(defun map-over-layout-panes (root-pane function)
  (declare (downward-funarg function))
  (labels ((map-one (pane)
	     (when (not (null pane))
	       (funcall function pane)
	       (dolist (inferior (layout-pane-inferiors pane))
		 (map-one inferior)))))
    (map-one root-pane)))

(define-presentation-type layout-pane ((&key top-pane))
   :no-deftype t
   :description "pane"
   :history nil
   :parser ((stream &key type)
	    (multiple-value-bind (object)
		(completing-from-suggestions (stream :allow-any-input nil :type type)
		  (map-over-layout-panes (or top-pane
					     (layout-designer-top-pane *program*))
		    (lambda (pane)
		      ;; only suggest leaf-node panes
		      (when (null (layout-pane-inferiors pane))
			(suggest (string (layout-pane-name pane)) pane)))))
	      (values object 'layout-pane)))
   :printer ((pane stream)
	     (write-string (string (layout-pane-name pane)) stream)))

;;; Layout designer pane redisplay
;;; Again, this is a 1sumulation0 of the constraint frame layout code.

(defmethod (display-layout layout-designer) (stream)
  (setf (layout-pane-box top-pane)
	(compute-top-level-layout-box stream))
  (lay-out-pane-inferiors top-pane)
  (multiple-value-bind (left top right bottom)
      (box-edges (layout-pane-box top-pane))
    ;; Outermost borders
    (display-hollow-box (make-box (1- left) (1- top) (1+ right) (1+ bottom)) stream))
  (display-layout-pane-as-box top-pane stream))

(defun compute-top-level-layout-box (window)
  (let ((screen (send window :screen)))
    (multiple-value-bind (window-width window-height)
	(send window :inside-size)
      (multiple-value-bind (screen-width screen-height)
	  (send screen :inside-size)
	(multiple-value-bind (top-x top-y)
	    (send window :viewport-position)
	  (let* ((box-width (round (* window-width 2) 3))
		 (box-height (round (* box-width screen-height) screen-width))
		 (box-width/2 (floor box-width 2))
		 (box-height/2 (floor box-height 2))
		 (left (+ (- (floor window-width 2) box-width/2) top-x))
		 (top (+ (- (floor window-height 2) box-height/2) top-y)))
	    (make-box left top (+ left box-width) (+ top box-height))))))))

;;; Obviously, this should just be using the normal layout stuff or supplement it.
(defun lay-out-pane-inferiors (pane)
  (let ((inferiors (layout-pane-inferiors pane)))
    (when inferiors
      (multiple-value-bind (left top right bottom)
	  (box-edges (layout-pane-box pane))
	(let ((stacking-direction (layout-pane-stacking-direction pane))
	      (total-width (- right left))
	      (total-height (- bottom top))
	      (constrained-panes nil)
	      (unconstrained-panes nil))
	  (dolist (inferior inferiors)
	    (let ((size (layout-pane-size-constraint inferior stacking-direction
						      total-width total-height)))
	      (if size
		  (push (list inferior size) constrained-panes)
		  (push inferior unconstrained-panes))))
	  (let ((ninferiors (length unconstrained-panes))
		(remaining-width total-width)
		(remaining-height total-height)
		(inferior-left left)
		(inferior-top top))
	    (ecase stacking-direction
	      (:vertical
		(loop for (nil size) in constrained-panes do
		  (decf remaining-height size)))
	      (:horizontal
		(loop for (nil size) in constrained-panes do
		  (decf remaining-width size))))
	    (loop for inferior in inferiors
		  do
	      (let ((inferior-right right)
		    (inferior-bottom bottom))
		(let ((constr (assoc inferior constrained-panes)))
		  (case stacking-direction
		    (:vertical
		      (if constr
			  (setq inferior-bottom (+ inferior-top (second constr)))
			  ;; If this is the last pane in a stack, let it fill to the edge.
			  ;; The FIRST pane in the list is really the last pane in the stack.
			  (setq inferior-bottom
				(+ inferior-top (if (eq inferior (first unconstrained-panes))
						    (ceiling remaining-height ninferiors)
						    (floor remaining-height ninferiors))))))
		    (:horizontal
		      (if constr
			  (setq inferior-right (+ inferior-left (second constr)))
			  ;; If this is the last pane in a stack, let it fill to the edge.
			  ;; The FIRST pane in the list is really the last pane in the stack.
			  (setq inferior-right (+ inferior-left
						  (if (eq inferior (first unconstrained-panes))
						      (ceiling remaining-width ninferiors)
						      (floor remaining-width ninferiors))))))))
		(setf (layout-pane-box inferior) (make-box inferior-left inferior-top
							    inferior-right inferior-bottom))
		(case stacking-direction
		  (:vertical
		    (setq inferior-top inferior-bottom))
		  (:horizontal
		    (setq inferior-left inferior-right))))))))
      (dolist (inferior inferiors)
	(lay-out-pane-inferiors inferior)))))

(defun layout-pane-size-constraint (pane stacking-direction total-width total-height)
  (let* ((type (layout-pane-type pane))
	 ;; --- temporary kludge
	 (function (second (assoc type *type-size-functions*))))
    (when function
      (multiple-value-bind (value unit)
	  (apply function stacking-direction total-width total-height
		 (layout-pane-options pane))
	(when value
	  (ecase unit
	    (:character
	      (* value 20))			;Scale factor
	    ))))))

(defmacro with-output-centered-in-box ((stream box &rest options) &body body)
  (format-output-macro-default-stream stream)
  `(with-output-centered-in-box-1 (lambda (,stream) . ,body) ,stream ,box . ,options))

(defun with-output-centered-in-box-1 (continuation stream box)
  (multiple-value-bind (width height)
      (continuation-output-size continuation stream)
    (multiple-value-bind (left top right bottom)
	(box-edges box)
      (in-sub-window (stream (- (floor (+ right left) 2) (floor width 2))
			     (- (floor (+ bottom top) 2) (floor height 2))
			     width height)
	(centering-lines (stream)
	  (funcall continuation stream))))))

(defun display-layout-pane-as-box (pane stream)
  (progn;displaying (:unique-id pane)
    (let ((type `((layout-pane :top-pane ,(layout-designer-top-pane *program*)))))
      (with-output-as-presentation (:object pane :type type :single-box t)
	(display-hollow-box (layout-pane-box pane) stream)
	(if (layout-pane-inferiors pane)
	    (dolist (inferior (layout-pane-inferiors pane))
	      (display-layout-pane-as-box inferior stream))
	    (with-output-centered-in-box (stream (layout-pane-box pane))
	      (present pane type :stream stream)
	      (format stream "  ~S" (layout-pane-type pane))
;	      (print-interesting-pane-options pane stream)
	      ))))))

#||
;; old code to print the various options for a pane in the
;; pane's space during layout designer redisplay
(defun print-interesting-pane-options (pane stream)
  ;; --- not yet converted
  (when nil
    (let ((type-options (program-pane-type-default-init-plist (layout-pane-type pane))))
      (when (loop for (indicator value) on (program-pane-options pane) by 'cddr
		  thereis (let ((kind-desc (assoc indicator kind-parameters)))
			    (not (eql value (eval (second kind-desc))))))
	(terpri stream)
	(formatting-textual-list (stream :separator "  ")
	  (loop for (indicator value) on parameters by 'cddr do
	    (let ((kind-desc (assoc indicator kind-parameters)))
	      (unless (eql value (eval (second kind-desc)))
		(formatting-textual-list-element (stream)
		  (format stream "~:(~A~): " indicator)
		  (present value (third kind-desc) :stream stream))))))
	(terpri stream)))))
||#

(defun display-hollow-box (box &optional (stream *standard-output*))
  (progn;displaying (:cache-value box)
    (multiple-value-bind (left top right bottom)
	(box-edges box)
      (decf right) (decf bottom)
      (send stream :draw-line left top left bottom)
      (send stream :draw-line left top right top)
      (send stream :draw-line right top right bottom)
      (send stream :draw-line left bottom right bottom))))

;;; Layout designer commands.

;; Instead of burying the visible pane under new inferiors, make the pane
;; BE one of the "inferiors" and create a parent pane to hold it and its
;; newborn sibling.
(defun-in-flavor (split-layout-pane layout-designer) (pane stacking-direction)
  (when (layout-pane-inferiors pane)
    (error "This pane already has inferiors"))
  (let* ((new-stacking-direction (invert-stacking-direction stacking-direction))
	 (parent (layout-pane-superior pane))
	 ;; use "phony" pane types :ROW and :COLUMN, internal to layout-designer
	 ;; they had better not get out to define-program-framework
	 (desired-parent-type (if (eq stacking-direction :horizontal) ':row ':column))
	 (new-sibling (make-new-pane self :display
				     :stacking-direction new-stacking-direction)))
    ;; next time we split this pane, do it the other way
    (setf (layout-pane-stacking-direction pane) new-stacking-direction)
    ;; Decide whether to include the new pane as a child of the current
    ;; pane's parent, or to make both the new and old panes be children
    ;; of a new parent that takes the old pane's place as a child of the
    ;; original parent.  Still with me?
    ;; If we could explicitly point at rows and columns, it would be better to
    ;; have Split Pane really split the current pane, but since we can't it seems
    ;; better to make split pane really mean split the row or column to which the
    ;; pane belongs if the splitting direction is the same...
    (cond ((and (not (null parent))
		(eq desired-parent-type (layout-pane-type parent)))
	   (setf (layout-pane-superior new-sibling) parent)
	   ;; insert the new pane directly after the old one in the list
	   (let ((position (member pane (layout-pane-inferiors parent))))
	     (if (null position)
		 (error "Pane ~S is not a child of its parent, ~S" pane parent)
		 (push new-sibling (cdr position)))))
	  ;; old parent didn't exist or was the wrong type
	  (t (let ((new-parent (make-new-pane self desired-parent-type
					      :stacking-direction stacking-direction)))
	       (setf (layout-pane-superior new-parent) parent)
	       (setf (layout-pane-superior pane) new-parent)
	       (setf (layout-pane-superior new-sibling) new-parent)
	       (setf (layout-pane-inferiors new-parent) (list pane new-sibling))
	       (if (not (null parent))
		   ;; If there was an old parent, substitute the new parent for the original
		   ;; pane, i.e. make the old parent a grandparent
		   (setf (layout-pane-inferiors parent)
			 (subst new-parent pane (layout-pane-inferiors parent)))
		   ;; no superior means that this was the top pane, so make the new parent
		   ;; be the top pane
		   (setq top-pane new-parent)))))))

;;; Note the difference between "horizontally" and :horizontal
(define-layout-designer-command (com-split-pane :menu-accelerator t)
				((pane `((layout-pane :top-pane ,top-pane)))
				 (direction '((member horizontally vertically))))
  (split-layout-pane
    pane
    ;; To people, "Split Pane horizontally" means draw a horizontal line across
    ;; the pane to make it into two panes.
    ;; To the constraint language, this is a :VERTICAL stack of panes.
    (ecase direction
      (horizontally :vertical)
      (vertically :horizontal))))

(defun invert-stacking-direction (direction)
  (ecase direction
    (:horizontal :vertical)
    (:vertical :horizontal)))

;;; Two presentation-to-command translators for Split Pane, once for each
;;; direction.

(define-presentation-to-command-translator split-pane-vertical
					   (layout-pane :gesture :shift-left)
  (pane)
  (unless (layout-pane-inferiors pane)
    `(com-split-pane ,pane vertically)))

(define-presentation-to-command-translator split-pane-horizontal
					   (layout-pane :gesture :left)
  (pane)
  (unless (layout-pane-inferiors pane)
    `(com-split-pane ,pane horizontally)))

(define-layout-designer-command (com-swap-panes :menu-accelerator t)
    ((pane-1 `((layout-pane :top-pane ,top-pane)))
     (pane-2 `((layout-pane :top-pane ,top-pane))))
   (flet ((barf (&rest format-args)
	    (beep)
	    (fresh-line *error-output*)
	    (apply #'format *error-output* format-args)))
     (let ((superior (layout-pane-superior pane-1)))
       (cond ((eq pane-1 pane-2)
	      (barf "You cannot swap a pane with itself"))
	     ((null superior)
	      (barf "You cannot swap the top pane"))
	     ((eq superior (layout-pane-superior pane-2))
	      (let ((inferiors (layout-pane-inferiors superior))
		    (place-holder (gensym)))
		;; perform standard cell swap
		(setq inferiors (subst place-holder pane-1 inferiors))
		(setq inferiors (subst pane-1 pane-2 inferiors))
		(setq inferiors (subst pane-2 place-holder inferiors))
		(setf (layout-pane-inferiors superior)
		      inferiors)))
	     (t (barf "Panes ~A and ~A are not both members of the same row or column."
		      (layout-pane-name pane-1)
		      (layout-pane-name pane-2)))))))

(define-layout-designer-command (com-delete-pane :menu-accelerator t)
				((pane `((layout-pane :top-pane ,top-pane))))
  (let ((parent (layout-pane-superior pane)))
    (cond ((not (null parent))
	   (let ((survivors (setf (layout-pane-inferiors parent)
				  (delete pane (layout-pane-inferiors parent)))))
	     ;; eliminate useless "hidden" panes that only have one child
	     ;; by collapsing the tree by one level
	     (when (= (length survivors) 1)
	       ;; promote the surviving sibling to the parent's position
	       (let ((survivor (first survivors))
		     (grandparent (layout-pane-superior parent)))
		 (cond ((not (null grandparent))
			(setf (layout-pane-inferiors grandparent)
			      (subst survivor parent (layout-pane-inferiors grandparent)))
			(setf (layout-pane-superior survivor) grandparent)
			(setf (layout-pane-stacking-direction survivor)
			      (invert-stacking-direction
				(layout-pane-stacking-direction grandparent))))
		       ;; No grandparent means that the parent was the top pane, so promote
		       ;; the survivor to  be the top pane.
		       (t (setf (layout-pane-superior survivor) nil)
			  (setq top-pane survivor)))))))
	  ;; null parent means attempt to delete the top pane
	  (t (format *error-output* "~&Don't delete the only pane, edit it.")))))

(define-presentation-to-command-translator com-delete-pane (dw::layout-pane :gesture nil)
  (pane)
  `(com-delete-pane ,pane))

;;; Code to write DEFINE-PROGRAM-FRAMEWORK forms.

;;; Put the definition here until we can figure out how to get in into
;;; the right editor buffer.
(defvar *layout-designer-results* nil)
;;; used to communicate existance of new definition
(defvar *layout-designer-results-tick* 0)

(defun-in-flavor (generate-define-program-framework layout-designer) ()
  (when (block found-one
	  (map-over-all-panes
	    #'(lambda (pane)
		(when (eql (layout-pane-type pane) :accept-values)
		  (return-from found-one T))))
	  nil)
    (pushnew "accept-values-pane" program-command-table-components :test #'string-equal))
  `(define-program-framework ,program-name
     ,@(when program-select-key
	 `(:select-key ,program-select-key))
     :command-definer ,program-command-definition-macro
     :command-table (:inherit-from ',(map 'list
					  ;; Elements are ((type-or-string command-table))
					  #'(lambda (comtab)
						    (if (stringp comtab)
							comtab
							(cp::command-table-name comtab)))
					  program-command-table-components)
		     :kbd-accelerator-p ',program-command-table-uses-kbd-accelerators)
     :state-variables ,program-state-variables
     :panes ,(construct-pane-description self)
     :configurations ',(construct-configurations-description self)
     ))

(define-layout-designer-command (com-done :menu-accelerator t) ()
  (pushnew (generate-define-program-framework)
	   *layout-designer-results*
	   ;; only one definition for a given program
	   :key #'second :replace t)
  (incf *layout-designer-results-tick*)
  (send *program-frame* :deselect))

(define-layout-designer-command (com-preview :menu-accelerator t)
				()
  (let ((si:*redo-defvars-p* t)			;Force thinking about redefinition in place.
	(*redefine-program-frames* t))
    (eval (generate-define-program-framework)))
  (using-resource (frame program-frame program-name (send *program-frame* :superior)
			 :process nil)
    (tv:window-call (frame :deactivate)
      (multiple-value-bind (*terminal-io* *query-io* *standard-output* *standard-input*)
	  (send frame :terminal-streams)
	  ;; prevent I/O buffer from filling with refresh blips
	(send *query-io* :clear-input)
	(loop for (name) in (send frame :parsed-panes)
	      for pane = (send frame :get-pane name)
	      do
	  (format pane "~S" name))
	(read-character *query-io*
			:prompt "Type a space to return to Frame-Up.")))))

(defmethod (construct-pane-description layout-designer) ()
  (let ((panes nil))
    (map-over-all-panes
      #'(lambda (pane)
	  (when (null (layout-pane-inferiors pane))
	    (setq panes
		  (nconc panes
			 `((,(layout-pane-name pane)
			    ,(layout-pane-type pane)
			    ;; Only write out those options that are acceptable to D-P-F
			    ;; as options for this pane type.
			    ,@(zwei:some-plist
				(layout-pane-options pane)
				(program-pane-type-allowed-options
				  (find-program-pane-type (layout-pane-type pane)))))))))))
    panes))

(defmethod (construct-configurations-description layout-designer) ()
  ;; should be something like (loop for configuration in configurations collect...)
  (let ((layout (construct-layout-description top-pane configuration-name))
	(sizes (construct-size-description top-pane configuration-name)))
    ;; --- These WHEN clauses are a last-minute rel 7 fix for the case
    ;; where someone tries to create an instance of the default layout.
    ;; Basically, the code in construct-layout-description and
    ;; construct-size-description isn't prepared to deal with
    ;; inferior-less top-level panes, so the functions return NIL.
    ;; This should probably be fixed for real by making the default
    ;; layout be a column with one inferior display pane.
    (when (null layout)
      (setq layout `((,configuration-name :column ,(layout-pane-name top-pane)))))
    (when (null sizes)
      (setq sizes `((,configuration-name (,(layout-pane-name top-pane) :even)))))
  `((,configuration-name
     (:layout ,@layout)
     (:sizes ,@sizes)))))

;;; sometimes we pass in an explicit pane name to be used in the construction of
;;; the layout description (i.e. the very top pane may be ROW-1 as far as the layout designer
;;; is concerned, but we have to use the name of the configuration when building the
;;; :LAYOUTS description
(defun construct-layout-description (pane &optional pane-name)
  (let ((inferiors (layout-pane-inferiors pane))
	(actual-pane-name (layout-pane-name pane)))
    (unless pane-name
      (setq pane-name actual-pane-name))
    (when inferiors
      (loop for inferior in inferiors
	    collect (layout-pane-name inferior) into layout
	    append (construct-layout-description inferior) into inferior-layouts
	    finally (return (values `((,pane-name
				       ,(layout-pane-type pane)
				       ,@layout)
				      ,@inferior-layouts)))))))

;;; see the comment at the beginning of construct-layout-description
(defun construct-size-description (pane &optional (pane-name (layout-pane-name pane)))
  (let ((inferiors (layout-pane-inferiors pane)))
    (when inferiors
      (loop for inferior in inferiors
	    for size-info = (get-size-info inferior)
	    ;; size-info will just be the pane-name if there was no
	    ;; specific size specification for that pane
	    if (atom size-info)
	      collect `(,size-info :even) into even-panes
	    else
	      collect size-info into explicitly-sized-panes
	    append (construct-size-description inferior) into inferior-sizes
	    finally (return (values `((,pane-name
				       ,@(append explicitly-sized-panes
						 (when (not (null explicitly-sized-panes))
						   '(:then))
						 even-panes))
				      ,@inferior-sizes)))))))

(defmethod (get-size-info layout-pane) ()
  (let* ((program-pane-type (find-program-pane-type type))
	 (merged-options
	   (when program-pane-type
	     (merge-plists options (program-pane-type-default-init-plist
				     program-pane-type)))))
    (getf-if (height merged-options :height-in-lines)
      `(,name ,height :lines)
      (getf-if (ignore merged-options :size-from-output)
	`(,name :ask-window self :size-for-pane ,name)
	name))))

(define-layout-designer-command (com-set-program-options :menu-accelerator t) ()
  (format t "~&Options for program ~S:~%" program-name)
  (with-typeout-window-for-accept-values
    (accept-values-then-setf ()
      ((name program-name 'symbol :prompt "Program name" :default program-name)
       (select-key program-select-key 'character :prompt "Select key")
       (def-mac program-command-definition-macro
		'symbol :prompt "Name of command-defining macro"
		:default program-command-definition-macro)
       (kbd-accl program-command-table-uses-kbd-accelerators
		 'boolean :default program-command-table-uses-kbd-accelerators
		 :prompt "Read single-character command accelerators")
       (inherit-from program-command-table-components
		     `((sequence ((type-or-string cp::command-table))))
		     :default program-command-table-components
		     :provide-default t
		     :prompt "Inherit commands from command tables"))))
  (send *program-frame* :redisplay-pane 'title t))

;;; Is it reasonable to specify state variables at all in the layout designer,
;;; or should we make the user type them into the D-P-F form?
;;; At any rate, the code below doesn't work very well.
;    (loop for var-desc in program-state-variables do
;      (setf (first var-desc) (accept 'symbol :prompt "State variable name"
;				     :default (first var-desc)))
;      (setf (second var-desc) (accept 'sys:expression :prompt "Default value"
;				     :default (second var-desc)))
;      (setf (third var-desc) (accept 'string :prompt "Description"
;				    :default (third var-desc)))
;      (setf (fourth var-desc) (accept 'presentation-type :prompt "Presentation type"
;				     :default (fourth var-desc))))
;    (push (list (accept 'symbol :prompt "State variable name")
;		nil nil nil)
;	  state-variables)


;;; More layout designer commands

(define-layout-designer-command (com-set-pane-name :menu-accelerator t)
				((pane `((layout-pane :top-pane ,top-pane)))
				 (new-name 'symbol :default (and pane (layout-pane-name pane))
					   :prompt "new name"))
  (setf (layout-pane-name pane) new-name))

(define-presentation-to-command-translator com-set-pane-name
				(layout-pane :gesture nil)
  (pane)
  (values `(com-set-pane-name ,pane)
	  'cp:command
	  :activate nil))

(define-layout-designer-command (com-set-pane-options :menu-accelerator t)
				((pane `((layout-pane :top-pane ,top-pane))))
  (choose-pane-type-and-options pane))

(define-presentation-to-command-translator com-set-pane-options
				(layout-pane :gesture :middle) (pane)
  `(com-set-pane-options ,pane))

;;; Code to provide a library of standard configurations.

(defvar *standard-layouts-alist* nil)

(defmacro define-standard-layout (name &body options)
  `(add-standard-layout ',name . ,options))

(defun add-standard-layout (name &rest options)
  (pushnew `(,name :value (,name ,@(copy-list options)))
	   *standard-layouts-alist*
	   :key #'first :test #'string-equal :replace t))

(define-standard-layout "title display command-menu interactor"
  :inferiors '((:type :title)
	       (:type :command-menu)
	       (:type :display)
	       (:type :interactor
		:options (:height-in-lines 4))))

(define-standard-layout "command-menu listener"
  :inferiors '((:type :command-menu)
	       (:type :listener)))

;;; --- install panes as you go along so they get named correctly
(defun-in-flavor (expand-standard-layout layout-designer)
		 (&rest options &key (type :column) inferiors &allow-other-keys)
  (let ((new-pane (apply #'make-new-pane self type
			 (si:rem-keywords options '(:inferiors :type)))))
    (setq inferiors (loop for inferior in inferiors
			  for expanded-inferior = (apply #'expand-standard-layout inferior)
			  do
		      (setf (layout-pane-superior expanded-inferior) new-pane)
			  collect expanded-inferior))
    (setf (layout-pane-inferiors new-pane)
	  inferiors)
    new-pane))

(define-layout-designer-command (com-select-configuration :menu-accelerator t)
				((configuration `((menu-choose
						    :alist ,*standard-layouts-alist*)
						  :description "a standard configuration")
						:prompt "standard configuration"
						:documentation 
 "Select the layout of panes for this program from commonly used configurations."))
 
  (beep)
  (when (yes-or-no-p "Destroy the current configuration? ")
    (setq top-pane nil)
    (setq top-pane (apply #'expand-standard-layout :name 'branch-node (rest configuration)))))

(define-layout-designer-command (com-reset-configuration :menu-accelerator t)
				()
  (beep)
  (when (yes-or-no-p "Destroy the current configuration? ")
    (setq top-pane nil)
    (setq top-pane (make-new-pane self :display))))

;;; Editor interface

(defun zwei:insert-form-at-point (form)
  (let ((output-stream (zwei:open-interval-stream (zwei:point) (zwei:point) t
					     :flavor
					     'zwei:presentation-recording-interval-stream)))
    (zwei:point-pdl-push (zwei:point) zwei:*window*)
    (let ((pkg *package*)
	  (rdtbl *readtable*))
      (with-standard-io-environment
	(let ((*print-pretty* t)
	      (*package* pkg)
	      (*readtable* rdtbl))
	  (let-if (send zwei:*interval* :get :lowercase)
	       ((*print-case* :downcase))
	    (prin1 form output-stream)))))
    (zwei:move-point (funcall output-stream :read-bp))))

(zwei:defcom zwei:com-create-program-definition
	     "Invokes Frame-Up to create a DEFINE-PROGRAM-FRAMEWORK form.
When Frame-Up is exited, the resulting DEFINE-PROGRAM-FRAMEWORK form
is inserted at point in the current buffer."
	     ()
  (let ((designer (find-program-window 'layout-designer)))
    (unless designer
      (zwei:barf "No layout designer can be found."))
    (let ((program-name (zwei:typein-line-read "Name for new program")))
      (reset-program-state-variables (send designer :program)
				     `((program-name ,program-name)
				       (package ,*package*)
				       (top-pane ,(make-new-pane (send designer :program)
								 :display))
				       )))
    ;; Cause a window-wakeup-refresh blip to be inserted in
    ;; the layout designer's input-buffer.
    (let ((tv:*asynchronous-window-operation* t))
      ;; clear out all the pane display and update for new data
      (send designer :clear-all)
      (send (send designer :process) :reset)
      (send designer :select)))
  (wait-for-layout-designer-and-insert-result)
  zwei:dis-text)

(defun wait-for-layout-designer-and-insert-result (&optional old-result)
  (zwei:typein-line "Waiting for Frame-Up.  Type c-Abort to continue editing")
  (let ((tick *layout-designer-results-tick*))
    (process-wait "Wait for Frame-Up"
      #'(lambda ()
	  (> *layout-designer-results-tick* tick))))
  (when old-result
    (zwei:delete-interval old-result))
  (zwei:insert-form-at-point (first *layout-designer-results*))
  (zwei:typein-line "")
  )

(zwei:defcom zwei:com-insert-program-definition
	     "Inserts a DEFINE-PROGRAM-FRAMEWORK form created by Frame-Up at point in the current buffer."
	     ()
  (unless *layout-designer-results*
    (zwei:barf "No layouts have been created yet."))
  (let ((design (zwei:typein-line-accept `((member ,@(map 'list #'second
							  *layout-designer-results*)))
					 :default (second
						    (first *layout-designer-results*)))))
    (zwei:insert-form-at-point (find design *layout-designer-results* :key #'second)))
  zwei:dis-text)

(zwei:defcom zwei:com-edit-program-definition
	     "Invoke Frame-Up on DEFINE-PROGRAM-FRAMEWORK here.
Note: this does not yet know enough to parse the layout back into Frame-Up." ()
  (let* ((int (zwei:definition-interval (zwei:point) 1 nil nil))
	 (form (and int (read (zwei:interval-stream int)))))
    (unless (eq (first form) 'define-program-framework)
      (zwei:barf "This form does not appear to be a program definition."))
    (let ((real-form (first *layout-designer-results*))
	  (confirm nil))
      (when (or (null real-form) (neq (second real-form) (second form)))
	(zwei:barf "This program is not the last one created by Frame-Up."))
      (loop for (key val) on (cddr form) by 'cddr do
	(let ((real-val (getf (cddr real-form) key 'newly-added)))
	  (unless (equal val real-val)
	    (if (eq real-val 'newly-added)
		(format t "Warning: you have added a ~S option, it will be lost." key)
		(format t "Warning: you have edited the ~S option, the change will be lost."
			key))
	    (setq confirm t))))
      (loop for (key real-val) on (cddr real-form) by 'cddr do
	(when (eq (getf (cddr form) key 'gone) 'gone)
	  (format t "Warning: you have deleted the ~S option, it will come back." key)
	  (setq confirm t)))
      (when confirm
	(unless (zwei:typeout-beep-yes-or-no-p "Continue anyway? ")
	  (zwei:abort-current-command))))
    (find-and-select-program-window 'layout-designer)
    (wait-for-layout-designer-and-insert-result int)
    zwei:dis-text))

(zwei:defcom zwei:com-edit-program-redisplay-function
	     "Edits the redisplay function for a program.
Prompts for the program, then for the name of a pane of that program."
	     ()
  (let ((program-name (zwei:typein-line-accept 'symbol-naming-program)))
    (flet ((pane-redisplay-function (pane-info)
	     (getf (cdr pane-info) :redisplay-function)))
      (let* ((program (make-program program-name))	;no better way?
	     (pane-options (zwei:typein-line-accept
			     `((named-program-pane :program ,program
						   :test ,#'pane-redisplay-function)
			       :test-description "with a redisplay function"))))
	(let ((redisplay-function (pane-redisplay-function pane-options)))
	  (if redisplay-function
	      (ed redisplay-function)
	      (zwei:barf "The ~A pane ~a has no explicit redisplay function."
			 program-name
			 (string (first pane-options)))))))))

(zwei:set-comtab zwei:*standard-comtab* nil
		 (zwei:make-command-alist
		   '(zwei:com-create-program-definition
		     zwei:com-edit-program-definition
		     zwei:com-insert-program-definition
		     zwei:com-edit-program-redisplay-function)))

(compile-flavor-methods layout-designer)

;;; Debugging tools
#||

;;; debugging utility to make sure the pane inferior/superior chain is OK
(defun graph-nodes (top-pane)
  (fresh-line)
  (labels ((print-pane (pane)
	     (with-output-as-presentation (:type 'sys:expression
					   :object pane)
	       (princ (layout-pane-name pane))))
	   (draw-node-and-inferiors (pane superior superior-node)
	     (let ((new-node (formatting-graph-node (t :connections (when superior-node
								      `(:below ,superior-node))
							)
			       (if (eq (layout-pane-superior pane)
				       superior)
				   ;; print the name of this pane
				   (print-pane pane)
				   (surrounding-output-with-border (t :thickness 2 :pattern tv:50%-gray)
				     (print-pane pane)
				     ;; if the pane that generated this inferior is not
				     ;; this inferior's superior, note the fact!
				     (write-string "  ")
				     (print-pane (layout-pane-superior pane)))))))
	       (loop for inf in (layout-pane-inferiors pane) do
		 (draw-node-and-inferiors inf pane new-node)))))
  (formatting-graph ()
    (draw-node-and-inferiors top-pane nil nil))))

(defun test-read-menu-list ()
  (let ((item-list nil))
    (fresh-line)
    (accepting-values (t :resynchronize-every-pass t)
      (setq item-list
	    (read-menu-list item-list "row")))))

||#
