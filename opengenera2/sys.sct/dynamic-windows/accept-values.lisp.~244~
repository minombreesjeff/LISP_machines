;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DW; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defmethod (accept-1 encapsulating-output-stream) (presentation-type &rest args)
  (declare (dbg:invisible-frame :accept-internals))
  (apply #'accept-1 stream presentation-type args))

(defmethod (:read-location encapsulating-output-stream) (&rest args)
  (lexpr-send stream :read-location args))

(defmethod (:following-blinker encapsulating-output-stream) (&rest args)
  (lexpr-send stream :following-blinker args))

(defmethod (:sizing-inside-size encapsulating-output-stream) ()
  (or (send-if-handles stream :sizing-inside-size)
      (multiple-value-bind (left nil right)
	  (send stream :visible-cursorpos-limits)
	(- right left))))

(defmethod (:real-set-cursorpos encapsulating-output-stream) ()
  (send-if-handles stream :real-set-cursorpos))

(defmethod (cp::arg-terminated-p encapsulating-output-stream) (chars)
  (cp::arg-terminated-p stream chars))

(defmacro with-typeout-window-for-accept-values (&body body)
  `(let ((*query-io* si:syn-terminal-io))
     (fresh-line *query-io*)
     (tv:window-call-relative (*query-io* :remove-self)
       . ,body)))

(defmacro tv:with-input-editor-subwindow ((stream left top right bottom) &body body)
  `(send ,stream :with-input-editor-subwindow
		 ,left ,top ,right ,bottom
		 #'(lambda () ,@body)))

(defmethod (:with-input-editor-subwindow tv:stream-mixin) (left top right bottom
							   continuation)
  (letf ((tv:left-margin-size (+ tv:left-margin-size (if left (max 0 left) 0)))
	 (tv:top-margin-size (+ tv:top-margin-size (if top (max 0 top) 0)))
	 (tv:right-margin-size (+ tv:right-margin-size
				  (if right (max 0 (- (tv:sheet-inside-width) right)) 0)))
	 (tv:bottom-margin-size (+ tv:bottom-margin-size
				   (if bottom (max 0 (- (tv:sheet-inside-height) bottom)) 0))))
    (funcall continuation)))

(defwhopper (:with-input-editor-subwindow dynamic-window) (left top right bottom continuation)
  (send self :scroll-to-visible-cursor left top)
  (coordinate-convert-points self :relative :inside left top right bottom)
  (continue-whopper left top right bottom continuation))

(defvar *accept-values-old-program* nil)

(defmacro accepting-values ((&optional stream &rest args) &body body)
  (declare (arglist (&optional (stream '*query-io*)
		     &key (own-window nil) (display-exit-boxes (not own-window))
			  (temporary-p own-window)
			  (label "Multiple accept") (near-mode '(:mouse))
			  (initially-select-query-identifier nil)
			  (resynchronize-every-pass nil)
			  (queries-are-independent nil)
			  (changed-value-overrides-default t)
			  (query-entry-mode :inline))
		    &body body))
  (when (eq stream 't)
    (setq stream nil))
  (let ((the-stream (or stream '*query-io*))
	(real-stream-var (gensym))
	(accept-values-stream-var (gensym)))
    `(let ((,real-stream-var ,the-stream)
	   (*accept-values-old-program* (and (boundp '*program*) *program*)))
       (using-resource (,accept-values-stream-var accept-values-stream ,real-stream-var)
	 (let ((,the-stream ,accept-values-stream-var))
	   (accept-values-internal
	     ,real-stream-var ,the-stream
	     (named-continuation accepting-values (,the-stream)
	       (let ,(unless stream
		       `((*standard-input* ,the-stream)
			 (*standard-output* ,the-stream)))
		 (let-if *accept-values-old-program*
			 ((*program* *accept-values-old-program*))
		   . ,body)))
	     . ,args))))))

(defvar *accept-values-counter* 0)

(defflavor accept-values-stream
	((stream nil)
	 (state :displaying)
	 (query-table (make-hash-table :test 'equal))
	 (counter (incf *accept-values-counter*))

	 (last-displayer nil)
	 (cursor-highlighted-presentations nil)
	 (cursor-query nil)
	 (cursor-choice nil)
	 (queries-are-independent nil)
	 (redisplay-necessary t)
	 (changed-value-overrides-default t)
	 (query-entry-mode :inline)
	 )
	(full-encapsulating-stream)
  (:readable-instance-variables stream query-table counter
				cursor-highlighted-presentations cursor-query cursor-choice)
  (:writable-instance-variables state queries-are-independent
				redisplay-necessary changed-value-overrides-default
				query-entry-mode)
  (:locatable-instance-variables state)
  )
  
(defwhopper (:which-operations accept-values-stream) ()
  (or which-operations
      (setq which-operations (append (continue-whopper)
				     (send stream :which-operations)))))

(defmethod (:operation-handled-p accept-values-stream) (op)
  (or (member op '(:which-operations :unclaimed-message))
      (and stream (send stream :operation-handled-p op))
      (member op (send self :which-operations))))

(defmethod (:send-if-handles accept-values-stream) (op &rest args)
  (when (send self :operation-handled-p op)
    (lexpr-send self op args)))

(defmethod (:unclaimed-message accept-values-stream) (&rest args)
  (unless (member state '(:returning :resynchronizing))
    (lexpr-send stream args)))

(defmethod (:deinitialize accept-values-stream) ()
  (clrhash query-table)
  (setq which-operations nil)
  ;; Need to reset these state variables back to NIL so that c-N, etc. don't get confused.
  (setq cursor-highlighted-presentations nil
	cursor-query nil
	cursor-choice nil))

(defmethod (:initialize accept-values-stream) (new-stream)
  (setq stream new-stream
	state :displaying
	counter (incf *accept-values-counter*)
	changed-value-overrides-default t
	query-entry-mode :inline
	redisplay-necessary t)
  (send self :deinitialize))

(defmethod (cp::arg-terminated-p accept-values-stream) (ignore) t)

(defmethod (:sizing-inside-size accept-values-stream) ()
  (when (eq state :sizing)
    (send self :maximum-exposable-inside-size)))

(defmethod (:clear-query-changed-p accept-values-stream) (query-identifier)
  (let ((query (gethash query-identifier query-table)))
    (when query
      (setf (accept-values-query-changed-p query) nil))))

(compile-flavor-methods accept-values-stream)

(defresource accept-values-stream (stream)
  :constructor (make-instance 'accept-values-stream)
  :initializer (send object :initialize stream)
  :deinitializer (send object :deinitialize))

(defflavor accept-values-query
	((other-accept-options nil)
	 (object nil)				;The "default"
	 presentation-type
	 presentation-type-read
	 (provide-default t)
	 (changed-p nil)
	 (redisplay-piece nil)
	 (presentation nil)
	 start-x start-y
	 stream counter help)
	()
  :readable-instance-variables
  (:initable-instance-variables presentation-type other-accept-options stream counter)
  (:writable-instance-variables object presentation-type presentation-type-read
				provide-default changed-p
				redisplay-piece presentation start-x start-y help))

(defmethod (find-query accept-values-stream) (query-identifier 
						 &optional (if-does-not-exist :error))
  (multiple-value-bind (query found)
      (gethash query-identifier query-table)
    (if found query
	(ecase if-does-not-exist
	  ((nil) nil)
	  ((:error) (error "No query found in table for ~S." query-identifier))))))

(defmethod (add-query accept-values-stream) (query-identifier &rest init-args)
  (setf (gethash query-identifier query-table)
	(apply #'make-instance 'accept-values-query :stream self :counter counter init-args)))

(defun accept-values-counter-valid-tester (ignore &key presentation window &allow-other-keys)
  (eql (let ((program (current-program :window window :type 'accept-values :error-p nil)))
	 (if (null program)
	     'no-program
	     (accept-values-stream-counter (accept-values-stream program))))
       (loop for presentation = presentation then (presentation-superior presentation)
	     while presentation
	     do (when (eq (presentation-type presentation) 'redisplay-structure)
		  (let ((unique-id (redisplay-piece-unique-id
				     (presentation-object presentation))))
		    (when (typep unique-id 'accept-values-query)
		      ;; Cannot use accept-values-query-stream's counter, because of
		      ;; accept-values-stream's resource.
		      (return (accept-values-query-counter unique-id))))))))

(defmethod (accept-1 accept-values-stream)
	   (presentation-type &rest options
			      &key (stream *query-io*) query-identifier
				   (default nil def-p) (default-type presentation-type)
				   (provide-default 'unless-default-is-nil)
				   (prompt nil) (separate-inferior-queries nil)
				   (newline-after-query t)
				   (changed-value-overrides-default
				     changed-value-overrides-default)
			      &allow-other-keys)
  (declare (dbg:invisible-frame :accept-internals))

  (when separate-inferior-queries
    (return-from accept-1
      (apply #'accept-2 presentation-type options)))

  (when (null query-identifier)
    (setq query-identifier (if (stringp prompt)
			       `(**prompt** ,prompt)
			       `(**type** ,presentation-type)
			       )))
  (let ((query (find-query self query-identifier nil)))
    (when (null query)
      (setq query (add-query self query-identifier
			     :other-accept-options
			     ;; Known to cons a new list
			     (zwei:some-plist-not options
						  '(:stream :default :default-type
						    :provide-default :display-default
						    :present-default :query-identifier
						    :initially-display-possibilities
						    )))))
    (setf (accept-values-query-presentation-type query) presentation-type)
    (when (not (accept-values-query-changed-p query))
      (when def-p
	(setf (accept-values-query-object query) default))
      (setf (accept-values-query-provide-default query) provide-default)
      (setf (accept-values-query-presentation-type-read query) default-type))
    (when (eq state :displaying)
      (setf (accept-values-query-help query) (copy-if-necessary *accept-help*)))
    (flet ((accept-internal (stream)
	      (multiple-value-bind (object type presentation x y)
		  (let ((rest-options (accept-values-query-other-accept-options query)))
		    (with-stack-list* (options-plus-default
					:default (accept-values-query-object query)
					rest-options)
		      ;; Unfortunately, ACCEPT-2 does supplied-p on this one and
		      ;; uses that to check the history sometimes.
		      (when (or def-p (accept-values-query-changed-p query))
			(setq rest-options options-plus-default))
		      (with-stack-list* (options-plus-prompt :prompt nil rest-options)
			(when (and (stringp prompt)
				   (plusp (string-length prompt))
				   (lower-case-p (aref prompt 0)))
			  (let ((new (string-append prompt)))
			    (setf (aref new 0) (char-upcase (aref prompt 0)))
			    (setf (second options-plus-prompt) new)
			    (setq rest-options options-plus-prompt)))
			(apply #'accept-2 
			       (accept-values-query-presentation-type query)
			       :stream stream :query-identifier query
			       :default-type (accept-values-query-presentation-type-read
					       query)
			       :provide-default (accept-values-query-provide-default query)
			       :display-default nil :present-default :accept-values
			       rest-options))))
		;; Make positions box relative
		(when presentation
		  (multiple-value-bind (px py)
		      (box-position (presentation-displayed-box presentation))
		    (multiple-value-bind (ignore dx dy)
			;; Convert from box coordiantes to stream.
			(stream-window-and-offsets stream)
		      (setq x (- (+ x dx) px)
			    y (- (+ y dy) py))))
		  (setf (accept-values-query-start-x query) x)
		  (setf (accept-values-query-start-y query) y))
		(setf (accept-values-query-presentation query) presentation)
		(setf (accept-values-query-presentation-type-read query) type)
		(setf (accept-values-query-object query) object))))
      (macrolet ((advance-cursorpos-appropriately-after (&body body)
		   `(multiple-value-bind (ignore y)
			(send stream :read-cursorpos)
		      ,@body
		      (when newline-after-query
			(let* ((piece (accept-values-query-redisplay-piece query))
			       (box (and piece (redisplay-piece-new-box piece))))
			  (if box
			      (multiple-value-bind (ignore height)
				  (box-size box)
				(send stream :set-cursorpos 0 (+ y height)))
			      (terpri stream)))))))
	(ecase state
	  ((:returning :resynchronizing) )
	  
	  (:displaying
	    (advance-cursorpos-appropriately-after
	      (with-redisplayable-output
		(:unique-id query
		 :stream stream
		 :piece-hook (lambda (x)
			       (setf (accept-values-query-redisplay-piece query) x))
		 :cache-value (if (accept-values-query-changed-p query)
				  (accept-values-query-object query)
				  default))	;Be consistent each time.
		(accept-internal stream))))
	  (:sizing
	    (advance-cursorpos-appropriately-after
	      (accept-internal stream)))))

      (values (accept-values-query-object query)
	      (accept-values-query-presentation-type-read query)
	      (prog1 (not (accept-values-query-changed-p query))
		     (when (and (eq state :resynchronizing)
				(not changed-value-overrides-default))
		       (setf (accept-values-query-changed-p query) nil)))))))

(define-program-framework accept-values
  :command-definer define-accept-values-command
  :command-table (:kbd-accelerator-p t
		  :inherit-from '("standard scrolling"
				  "standard arguments"))
  :top-level (accept-values-top-level)
  :panes ((title :title :redisplay-function 'accept-values-draw-title)
	  (choices :display :more-p nil :blinker-p t
			    :margin-components '((margin-ragged-borders )
						 (margin-scroll-bar )
						 (margin-white-borders )))
	  (command-menu :command-menu :columns '(("Done") ("Abort"))))
  :label-pane nil
  :selectable nil
  :state-variables ((title nil)
		    (displayer)
		    (stream )
		    (real-stream ))
  )

(defmethod (accept-values-draw-title accept-values) (stream)
  (let ((title (accept-values-title *program*)))
    (when title
      (write-string title stream))))

(defun accept-values-internal (real-stream stream continuation
			       &rest args
			       &key (own-window nil)
				    (display-exit-boxes (not own-window))
				    (accept-values-program-name 'accept-values)
			       &allow-other-keys)
  (cond ((not (operation-handled-p real-stream :screen))
	 ;; A remote terminal or the cold load stream or a foreign window.
	 ;; Just ask the questions serially.
	 (funcall continuation real-stream))
	(own-window
	 (apply #'accept-values-internal-own-window stream continuation args))
	((not (operation-handled-p real-stream :displayed-presentations))
	 ;; A non dynamic window.  Use own-window on its screen.
	 (apply #'accept-values-internal-own-window stream continuation
		:own-window t args))
	(t
	 (fresh-line real-stream)
	 (let ((program (make-program accept-values-program-name)))
	   (setf (accept-values-displayer program)
		 (if display-exit-boxes
		     (redisplayer (stream)
		       (funcall continuation stream)
		       (accept-values-display-exit-boxes :program program :stream stream))
		     (redisplayer (stream)
		       (funcall continuation stream))))
	 (lexpr-send real-stream :with-normal-presentation-state 
		     #'accept-values-internal-1 program real-stream
						stream continuation args)))))

(defun accept-values-internal-own-window (stream continuation
					  &rest args
					  &key (label "Multiple accept")
					       (near-mode '(:mouse))
					       (temporary-p t)
					       (superior (tv:mouse-default-superior stream))
					       (accept-values-program-name 'accept-values)
					       (minimum-width)
					       (minimum-height)
					  &allow-other-keys)
  (let* ((tv:*ASYNCHRONOUS-WINDOW-OPERATION* nil)
	 (*presentation-area* working-storage-area)
	 (rubout-handler nil)			;Not us
	 (*input-editor-options* nil)
	 (*accept-active* nil)
	 (frame (allocate-resource 'program-frame accept-values-program-name superior
				     :temporary-p temporary-p :process nil))
	 (window (send frame :get-pane 'choices))
	 (program (send frame :program))
	 (help-window nil)
	 (*help-displayer* (lambda (continuation stream)
			     (setq help-window (display-own-window-help help-window frame
									label continuation
									stream))))
	 (displayer (redisplayer (stream) (funcall continuation stream))))

    (send stream :initialize window)
    (multiple-value-bind (width height)
	(letf (((accept-values-stream-state stream) :sizing))
	  (redisplayer-output-size displayer stream))
      (incf width)				;Here could add in a user extra margin.
      (let ((scroll-bar (find-margin-component window 'margin-scroll-bar)))
	(when scroll-bar
	  (maxf height (margin-scroll-bar-minimum-height scroll-bar))))
      (let ((frame-x-margin (- (send frame :width) (send window :inside-width)))
	    (frame-y-margin (- (send frame :height) (send window :inside-height))))
	(maxf width (let ((pane (send frame :get-pane 'command-menu)))
		      (+ (with-stack-list (*pane-sizing-options*
			   :remaining-width (- (send (send frame :superior) :inside-width)
					       frame-x-margin))
			   (send frame :inside-size-for-pane pane 'command-menu))
			 (- (send pane :width) (send pane :inside-width)))))
	(incf width frame-x-margin)
	(incf height frame-y-margin))
      (when label
	(let ((title-pane (send frame :get-pane 'title)))
	  (maxf width (+ (- (send frame :width) (send title-pane :inside-width))
			 (send title-pane :string-length label)))))
      (when minimum-width (setq width (min (send superior :inside-width)
					   (max width minimum-width))))
      (when minimum-height (setq height (min
					  (send superior :inside-height)
					  (setq height (max height minimum-height)))))
      (send frame :set-size width height)
      (position-window-near-carefully frame near-mode)
      (multiple-value-bind (width height)
	  (send frame :inside-size)
	(send frame :set-mouse-position (round width 2) (round height 2) nil)))

    (setf (accept-values-title program) label)
    (setf (accept-values-displayer program) displayer)
    (tv:window-call (frame :deactivate)
      (let ((*program* program))
	(send frame :redisplay t))		;Draw the menu (shouldn't do this ourselves)!
      (unwind-protect
	  (let ((*program-frame* frame))
	    (multiple-value-bind (*terminal-io* *query-io* *standard-output* *standard-input*)
		(send frame :terminal-streams)
	      ;; Prevent the input-editor from fresh-lining our window when Help is pressed
	      (with-input-editing-options (((:help-stream :override)
					    tv:default-background-stream))
		;; Even though redisplay will supply truncation on output, we need
		;; it on input too.
		(with-output-truncation (window :vertical t)
		  (sys:with-stack-list* (args :temporary-p temporary-p args)
		    (apply #'accept-values-internal-1
			   program window stream continuation args))))))
	(deallocate-help-window help-window)))))

(defun accept-values-internal-1 (program real-stream stream continuation &rest args)
  (setf (accept-values-stream program) stream
	(accept-values-real-stream program) real-stream)
  (tv:with-notification-mode (:always-pop-up real-stream)
    (apply #'run-program-top-level program :continuation continuation args))
  (letf (((accept-values-stream-state stream) :returning))
    (funcall continuation stream)))

(defmethod (accept-values-top-level accept-values)
	   (&key temporary-p
		 initially-select-query-identifier
		 continuation
		 (changed-value-overrides-default t)
		 (query-entry-mode :inline)
		 (resynchronize-every-pass (not changed-value-overrides-default))
		 queries-are-independent
		 &allow-other-keys)
  (setf (accept-values-stream-changed-value-overrides-default stream)
	  changed-value-overrides-default
	(accept-values-stream-queries-are-independent stream) queries-are-independent
	(accept-values-stream-query-entry-mode stream) query-entry-mode
	(accept-values-stream-redisplay-necessary stream) t)
  (let ((*presentation-more-break-input-context* nil)
	(*accept-help* nil)
	(resynchronize-this-pass nil))
    (tv:with-blinker-visibility (stream nil)
      (catch 'accept-values-return
	(unwind-protect
	    (loop
	      ;; I wonder whether we could manage to get this to be the redisplay-function for
	      ;; the choices pane?
	      (when (and (accept-values-stream-redisplay-necessary stream)
			 (or resynchronize-every-pass resynchronize-this-pass))
		(letf (((accept-values-stream-state stream) :resynchronizing))
		  (funcall continuation stream))
		(setq resynchronize-this-pass nil))
	      (accept-values-stream-do-redisplay stream displayer)
	      (cond (initially-select-query-identifier
		     (read-new-value stream
				     (find-query stream initially-select-query-identifier))
		     (setf (accept-values-stream-redisplay-necessary stream) t)
		     (setq initially-select-query-identifier nil))
		    (t
		     (setq resynchronize-this-pass
			   (catch 'accept-values-resynchronize
			     (multiple-value-bind (command arguments kind)
				 (read-program-command self
						       :stream real-stream
						       :echo-stream #'ignore
						       :status (and temporary-p :exposed)
						       :window-wakeup
						         #'default-window-wakeup-handler)
			       (case kind
				 (:status (signal 'abort))
				 (otherwise (when command (apply command arguments))))))))))
	  (clear-accept-values-stream-cursor-highlighting stream))))))

(defun accept-values-display-exit-boxes (&key program (stream *query-io*) (level :top-level))
  (when (send stream :read-cursorpos)		;Not if called by user and on returning pass.
    (with-redisplayable-output (:stream stream :cache-value level :unique-id '#,(gensym))
      (let* ((command-table (if program
				(program-command-table program)
				(cp:find-command-table 'accept-values)))
	     (presentation-type `((command-menu-item :menu-level ,level
						     :command-table ,command-table)))
	     (menu-items (cp::command-table-menu-accelerator-table command-table)))
	(formatting-textual-list (stream :filled t)
	  (dolist (handler menu-items)
	    (when (member level (command-menu-handler-menu-levels handler))
	      (let ((name (command-menu-handler-command-name handler)))
		(formatting-textual-list-element (stream)
		  (with-output-as-presentation (:type presentation-type :object name
						:stream stream)
		    (selector name string-equal
		      ("Abort"
		       (format stream "~C aborts" #\Abort))
		      ("Done"
		       (format stream "~C uses these values" #\End))
		      (otherwise
			(write-string name stream)))))))))
	(terpri stream)
	;; Make sure the blinker is off after any potential scrolling
	(let ((blinker (send stream :following-blinker)))
	  (when blinker
	    (send blinker :set-visibility nil)))))))

(defmethod (read-new-value accept-values-stream)
	   (query &key (edit-old nil) (reset-to-nil nil)
	    &aux qx qy entry-mode)
  (clear-accept-values-stream-cursor-highlighting self)
  (multiple-value-bind (ox oy) (send stream :read-cursorpos)
    (multiple-value-bind (vx vy) (send stream :viewport-position)
      (let ((presentation (accept-values-query-presentation query))
	    (erase-presentation nil))
	(if reset-to-nil
	    (setq entry-mode :reset-to-nil)
	    (ecase (setq entry-mode (getf (accept-values-query-other-accept-options query)
					  :query-entry-mode query-entry-mode))
	      ((:inline :inline-limited)
	       (setq erase-presentation t))
	      ((:at-end :own-window))))
	(when (and presentation erase-presentation)
	  (multiple-value-bind (px py)
	      (box-position (presentation-displayed-box presentation))
	    (setq qx (+ px (accept-values-query-start-x query))
		  qy (+ py (accept-values-query-start-y query)))
	    (with-output-truncation (stream)
	      (send stream :set-cursorpos qx qy)))
	  (erase-displayed-presentation presentation stream nil t)
	  (send stream :delete-displayed-presentation presentation)
	  ;; In case there are other queries on the same line, this makes entering look
	  ;; nicer.  Redisplay will redraw them when done.
	  (unless (eq entry-mode :inline-limited)
	    (send stream :clear-rest-of-line))
	  ;; Now reinstantiate the top-level
	  (let ((superior (presentation-superior presentation)))
	    (send stream :output-for-re-presentation superior #'ignore stream)))
	(unless qx
	  (setq qx ox qy oy)))
      (flet ((force-query-redisplay ()
	       (multiple-value-bind (x y)
		   (send stream :read-cursorpos)
		 (send stream :clear-between-cursorposes qx qy x y))
	       (setf (redisplay-piece-cache-value (accept-values-query-redisplay-piece query))
		     '#,(gensym))))
	(multiple-value-bind (nil aborted-p)
	    (catch-error-restart (abort "Skip entering this field")
	      (multiple-value-bind (object type provide-default)
		  (case entry-mode
		    (:reset-to-nil
		      (values nil (accept-values-query-presentation-type query) nil))
		    ((:inline :inline-limited :at-end)
		      (tv:with-blinker-visibility (stream :blink)
			(if (eq entry-mode :inline-limited)
			    (multiple-value-bind (left top right bottom)
				(box-edges (presentation-displayed-box
					     (accept-values-query-presentation query)))
			      (send stream :with-input-editor-subwindow
			        left top right bottom
				#'(lambda ()
				    (read-new-value-internal stream query edit-old nil))))
			    (read-new-value-internal stream query edit-old
						     (eq entry-mode :at-end)))))
		    (:own-window
		      (using-resource (window dw:dynamic-window (send stream :screen)
					      :temporary-p t)
			(send window :set-label nil)
			(let ((box (presentation-displayed-box
				     (accept-values-query-presentation query))))
			  (multiple-value-bind (width height)
			      (box-size box)
			    (send window :set-size (max width 250) (max height 100))))
			(tv:window-call (window :deactivate)
			  (read-new-value-internal window query edit-old t)))))
		;; Force redisplay, since input echo may not look right.
		(force-query-redisplay)
		(unless (eq type :full-rubout)
		  (setf (accept-values-query-object query) object)
		  (setf (accept-values-query-changed-p query) t)
		  (setf (accept-values-query-provide-default query) provide-default)
		  (setf (accept-values-query-presentation-type-read query) type)))
	      (loop for presentation = (accept-values-query-presentation query) then superior
		    while presentation
		    as superior = (presentation-superior presentation)
		    do (setf (displayed-presentation-displayed-box-valid presentation) nil)
		       (when superior
			 (pushnew presentation (presentation-inferiors superior))))
	      (update-displayed-presentation-box
		(loop for presentation = (accept-values-query-presentation query) then superior
		      as superior = (presentation-superior presentation)
		      when (null superior)
			return presentation)))
	  (when aborted-p
	    (force-query-redisplay))
	  (multiple-value-bind (nvx nvy)
	      (send stream :viewport-position)
	    (unless (and (= vx nvx) (= vy nvy))
	      (send stream :set-viewport-position vx vy)))
	  (with-output-truncation (stream)
	    (send stream :set-cursorpos ox oy))))))
  (accept-values-stream-set-appropriate-redisplay-necessary self query)
  query)

(defun read-new-value-internal (stream query edit-old prompt-p)
  (let ((presentation-type (accept-values-query-presentation-type query))
	(old-text (and edit-old
		       (if (case (accept-values-query-provide-default query)
			     ((t) t)
			     ((nil) t)
			     ((unless-default-is-nil)
			      (or (not (null (accept-values-query-object query)))
				  (presentation-type-null-default-provide-default
				    (accept-values-query-presentation-type-read query)))))
			   (present-to-string
			     (accept-values-query-object query)
			     (accept-values-query-presentation-type-read query)
			     :acceptably t)
			   "")))
	(*accept-help* (accept-values-query-help query)))
    (loop for rubbed-out = nil then t doing
      (multiple-value-bind (object type)
	  (with-input-editing-options ((:limited-full-rubout nil))
	    (with-input-editing-options-if (and edit-old (not rubbed-out))
					   ((:initial-input old-text))
	      (stack-let* ((other-options (accept-values-query-other-accept-options query))
			   (no-prompt-options (list* :display-default nil
						     :prompts-in-line t :prompt nil
						     other-options)))
		(apply #'accept-2
		       presentation-type
		       :stream stream :query-identifier query
		       #||
		       :input-sensitizer
		         (lambda (astream object ignore ignore)
			   (declare (sys:downward-function))
			   (send astream :set-input-buffer-presentation
				 (make-accept-values-value :object object
							   :presentation-type presentation-type
							   :query-identifier query)
				 'accept-values-value-display
				 (presentation-superior
				   (accept-values-query-presentation query))
				 (lambda (ignore presentation)
				   (setf (accept-values-query-presentation query)
					 presentation))))
		       ||#
		       :default (accept-values-query-object query)
		       :default-type (accept-values-query-presentation-type-read query)
		       :provide-default (accept-values-query-provide-default query)
		       (if prompt-p other-options no-prompt-options)))))
	(if (neq type :full-rubout)
	    (return (values object type t))
	    (let ((peek (send stream :tyi)))
	      (when (eql peek #\Rubout)
		(return (values nil :full-rubout t)))
	      (send stream :untyi peek)))))))

(define-accept-values-command (com-edit-accept-values-query-value)
    ((query 'accept-values-query-display)
     &key
     (edit-old 'boolean :default nil :mentioned-default t)
     (reset-to-nil 'boolean :default nil))
   (let-if *accept-values-old-program*
	   ((*program* *accept-values-old-program*))
     (read-new-value stream query :edit-old edit-old :reset-to-nil reset-to-nil)))

(define-presentation-to-command-translator accept-values-new-value
   (accept-values-value-display
     :gesture :select
     :documentation "Replace this field"
     :tester accept-values-counter-valid-tester)
   (accept-values-value)
  `(com-edit-accept-values-query-value
     ,(accept-values-value-query-identifier accept-values-value)))

(define-presentation-to-command-translator accept-values-edit-value
   (accept-values-value-display
     :gesture :select-and-edit
     :documentation "Edit this field"
     :tester accept-values-counter-valid-tester)
   (accept-values-value)
  `(com-edit-accept-values-query-value
     ,(accept-values-value-query-identifier accept-values-value)
     :edit-old t))

(define-presentation-to-command-translator accept-values-remove-value
   (accept-values-value-display
     :gesture :remove
     :documentation "Remove this field")
   (accept-values-value)
  `(com-edit-accept-values-query-value
     ,(accept-values-value-query-identifier accept-values-value)
     :reset-to-nil t))


(defstruct accept-values-choices
  query-identifier
  sequence
  select-action
  )

(define-presentation-type accept-values-choices-display ())

(defstruct accept-values-choice
  choices
  choice
  value
  documentation
  )

(defun accept-values-choose-from-sequence (stream sequence value query-identifier
					   &key
					   (type 't)
					   (highlighted-type nil)
					   (printer nil)
					   (key #'identity)
					   (highlighting-test #'eq highlighting-test-provided)
					   (id-test #'eq id-test-provided)
					   highlighting-function
					   ;; highlighting-function gets called with
					   ;; continuation &rest continuation-args
					   ;; where the continuation-args currently
					   ;; are choice, stream, and type.
					   (select-action #'(lambda (new ignore) new))
					   (sensitive-predicate #'true)
					   (documentation-key #'ignore)
					   (row-wise t)
					   (fill-p nil)
					   (multiple-choices nil)
					   (single-box t))
  (let ((choices (make-accept-values-choices :query-identifier query-identifier
					     :sequence sequence
					     :select-action select-action)))
    (labels ((do-one (choice stream)
	       ;; FORMAT-ITEM-LIST now remembers the printer passed to it.
	       ;;(declare (downward-function))
	       (let* ((choice-value (funcall key choice))
		      (highlighted-p (if (and highlighting-test-provided
					      (not id-test-provided))
					 (funcall highlighting-test choice-value value)
					 (if multiple-choices 
					     (member choice-value value :test id-test)
					     (funcall id-test choice-value value))))
		      (sensitive-p (funcall sensitive-predicate choice)))
		 ;;+++ UID from the value, not the element.  This keeps down redisplay if
		 ;; the type keeps getting consed by the user.  However, it will mess
		 ;; up if the sequence contains more than one element representing the same
		 ;; object.
		 (with-redisplayable-output (:unique-id choice-value
					     :id-test (if id-test-provided
							  id-test
							  (if (and highlighting-test-provided
								   (not multiple-choices))
							      highlighting-test
							      #'eq))
					     :cache-value highlighted-p
					     :stream stream)
		   (with-output-as-presentation
		       (:stream stream
			:single-box single-box
			:type (and sensitive-p 'accept-values-choice-display)
			:allow-sensitive-inferiors sensitive-p
			:object (make-accept-values-choice
				  :choices choices :choice choice
				  :value choice-value
				  :documentation (funcall documentation-key choice)))
		     (flet ((print-it (choice stream &optional (type type))
			      (if printer
				  (funcall printer choice stream)
				  (present choice-value type :stream stream))))
		       (if highlighted-p
			   (if highlighting-function
			       (funcall highlighting-function #'print-it
					choice stream (or highlighted-type type))
			       (with-character-face (:bold stream)
				 (print-it choice stream (or highlighted-type type))))
			   (print-it choice stream))))))))
      
      (with-output-as-presentation (:type 'accept-values-choices-display :object choices
					  :stream stream)
	(if fill-p
	    (si:with-indentation (stream (send stream :read-cursorpos))
	      (format-textual-list sequence #'do-one :stream stream
				   :separator "  " :filled t))
	    (format-item-list sequence
			      :stream stream
			      :fresh-line nil :return-at-end nil
			      :order-columnwise (not row-wise) :optimal-number-of-rows 1
			      :additional-indentation 0
			      :max-width (- (or (send-if-handles stream :sizing-inside-size)
						(multiple-value-bind (left nil right)
						    (send stream :visible-cursorpos-limits)
						  (- right left)))
					    (send stream :read-cursorpos))
			      :printer #'do-one))))))

(define-accept-values-command (com-accept-values-choose-value)
			      ((choice 'accept-values-choice-display))
  (accept-values-choose-value choice))

(defun accept-values-choose-value (choice)
  (let* ((choices (accept-values-choice-choices choice))
	 (query (accept-values-choices-query-identifier choices)))
    (setf (accept-values-query-object query)
	  (funcall (accept-values-choices-select-action choices)
		   (accept-values-choice-value choice)
		   (accept-values-query-object query)))
    (setf (accept-values-query-changed-p query) t)
    (let* ((presentation-type (accept-values-query-presentation-type query))
	   (history (find-accept-history presentation-type))
	   (object (accept-values-query-object query)))
      ;; I don't think we need to run all the post-processing hair
      ;; from accept-2, since we're dealing with a pre-enumerated set of 
      ;; objects here.
      (when history
	(push-for-presentation-type history object
				    (accept-values-query-presentation-type-read query))))
    (accept-values-stream-set-appropriate-redisplay-necessary
      (accept-values-query-stream query) query)
    query))

(define-presentation-to-command-translator com-accept-values-choose-value
    (accept-values-choice-display
      :documentation ((item)
		      (or (accept-values-choice-documentation item)
			  "Select this choice"))
      :tester accept-values-counter-valid-tester)
  
  (choice)
  `(com-accept-values-choose-value ,choice))

(define-accept-values-command (accept-values-refresh :keyboard-accelerator #\Refresh)
			      ()
  "Force complete redisplay"
  (force-redisplay displayer real-stream)
  (setf (accept-values-stream-redisplay-necessary stream) t))	;Needless to say.

(define-accept-values-command (accept-values-stupid-help :keyboard-accelerator #\Help)
			      ()
  "Print this description"
  (funcall *help-displayer*
	   (lambda (stream)
	     (declare (sys:downward-function))
	     (let ((*standard-output* stream))
	       (format t "~&Accepting values.~@
			Click on a displayed value to enter a new value.~@
			Click middle to edit the old value.~%")
	       (cp::read-accelerated-command-minimal-help
		 (dw:program-command-table self))))
	   real-stream))

(defun-in-flavor (check-for-unconfirmed-queries accept-values) ()
  (dolist (piece (redisplay-piece-displayed-inferiors displayer))
    (let ((query (redisplay-piece-unique-id piece)))
      (when (and (typep query 'accept-values-query)
		 (or (getf (accept-values-query-other-accept-options query) :ensure-object)
		     (getf (accept-values-query-other-accept-options query) :confirm))
		 (ecase (accept-values-query-provide-default query)
		   ((t) nil)
		   ((nil) t)
		   ((unless-default-is-nil)
		    (and (null (accept-values-query-object query))
			 (not (presentation-type-null-default-provide-default
				(accept-values-query-presentation-type-read query)))))))
	;; then we must move to this query and beep
	(send stream :beep)
	(read-new-value stream query)
	(setf (accept-values-stream-redisplay-necessary stream) t)
	(throw 'accept-values-resynchronize t)))))

(define-accept-values-command (accept-values-exit :keyboard-accelerator #\End
						  :menu-accelerator "Done")
			      ()
  "Use these choices"
  (check-for-unconfirmed-queries)
  (throw 'accept-values-return t))

(define-accept-values-command (accept-values-abort :keyboard-accelerator #\Abort
						   :menu-accelerator "Abort")
			      ()
  "Abort these choices"
  (signal 'abort))

(defmacro with-independent-accept-values-queries ((&optional stream) &body body)
  (when (member stream '(t nil))
    (setq stream '*query-io*))
  `(with-redisplayable-output (:stream ,stream
			       :piece-flavor 'independent-queries-marker
			       :dont-snapshot-variables t)
     . ,body))

(defmethod (independent-queries-marker-p redisplay-piece) () nil)
(defflavor independent-queries-marker () (redisplay-piece))
(defmethod (independent-queries-marker-p independent-queries-marker) () t)

(defmethod (accept-values-stream-set-appropriate-redisplay-necessary accept-values-stream)
	   (query)
  (let ((piece (accept-values-query-redisplay-piece query)))
    (setq redisplay-necessary (or (and (or queries-are-independent
					   (getf (accept-values-query-other-accept-options
						   query)
						 :independent-query nil))
				       piece)
				  (do ((piece piece (redisplay-piece-superior piece)))
				      ((null piece) nil)
				    (when (independent-queries-marker-p piece)
				      (return piece)))
				  t))))

(defmethod (accept-values-stream-do-redisplay accept-values-stream)
	   (displayer &key (truncate-p t))
  (when (not redisplay-necessary)
    (return-from accept-values-stream-do-redisplay nil))
  (let ((piece displayer)
	(single-piece nil))
    (when (neq redisplay-necessary t)
      (when (let ((changed-pieces (clear-before-redisplay displayer self)))
	      (loop for piece in changed-pieces
		    always (loop for piece = piece then (redisplay-piece-superior piece)
				 while piece
				 thereis (eq piece redisplay-necessary))))
	(setq piece redisplay-necessary
	      single-piece t)))
    (unless single-piece
      (setq last-displayer displayer))
    (when cursor-highlighted-presentations
      (dolist (presentation cursor-highlighted-presentations)
	(displayed-presentation-clear-highlighting presentation stream))
      (setq cursor-highlighted-presentations nil))
    (do-redisplay piece self :save-cursor-position single-piece :truncate-p truncate-p)
    (setq cursor-highlighted-presentations
	  (block pres
	    (when cursor-choice
	      (let ((pres (find cursor-choice (accept-values-stream-cursor-query-choices)
				:key #'presentation-object
				:test (if (typep cursor-choice 'accept-values-choice)
					  (lambda (c1 c2)
					    (and (typep c2 'accept-values-choice)
						 (eql (accept-values-choices-sequence
							(accept-values-choice-choices c1))
						      (accept-values-choices-sequence
							(accept-values-choice-choices c2)))
						 (eql (accept-values-choice-choice c1)
						      (accept-values-choice-choice c2))))
					  (lambda (v1 v2)
					    (and (typep v2 'accept-values-value)
						 (eql (accept-values-value-presentation-type
							v1)
						      (accept-values-value-presentation-type
							v2)
						      )))))))
		(when pres
		  (setq cursor-choice (presentation-object pres))
		  (return-from pres (list pres))))
	      ;; If can no longer locate this choice, forget it and move to superior.
	      (setq cursor-choice nil))
	    (when cursor-query
	      (let ((pres (accept-values-query-correct-presentations cursor-query)))
		(when pres
		  (return-from pres pres)))
	      ;; Cannot locate this either, forget it and move to top.
	      ;; Slightly better than getting lost.
	      (setq cursor-query nil))))
    (dolist (presentation cursor-highlighted-presentations)
      (displayed-presentation-set-highlighting presentation stream)))
  (setq redisplay-necessary nil))

(defmethod (clear-accept-values-stream-cursor-highlighting accept-values-stream) ()
  (dolist (presentation cursor-highlighted-presentations)
    (displayed-presentation-clear-highlighting presentation stream))
  (setq cursor-highlighted-presentations nil))

(defun-in-flavor (set-accept-values-stream-cursor-highlighting accept-values-stream)
		 (presentations)
  (clear-accept-values-stream-cursor-highlighting self)
  (dolist (presentation presentations)
    (displayed-presentation-set-highlighting presentation stream))
  (setq cursor-highlighted-presentations presentations))

(defun accept-values-query-correct-presentations (query)
  ;; Return a list of all accept-values-choices-display and accept-values-value-display
  ;; presentations for this query.  c-N highlights all of these.
  (loop for presentation in (presentation-inferiors
			      ;; The redisplay-structure that covers the whole query
			      (presentation-superior (accept-values-query-presentation query)))
	when (member (presentation-type-name (presentation-type presentation))
		     '(accept-values-choices-display accept-values-value-display))
	  collect presentation))

(defun-in-flavor (set-accept-values-stream-cursor-query accept-values-stream) (query)
  (setq cursor-query query
	cursor-choice nil)
  (set-accept-values-stream-cursor-highlighting
    (accept-values-query-correct-presentations query)))

(defun-in-flavor (accept-values-stream-next-query accept-values-stream) (count current-query)
  (loop repeat count
	as query = (let ((previous nil))
		     (loop for piece in (redisplay-piece-displayed-inferiors last-displayer) do
		       (let ((query (redisplay-piece-unique-id piece)))
			 (when (typep query 'accept-values-query)
			   (when (eq previous current-query)
			     (return query))
			   (setq previous query)))))
	while query
	do (setq current-query query)
	finally (return query)))

(defun-in-flavor (accept-values-stream-previous-query accept-values-stream)
		 (count current-query)
  (loop repeat count
	as query = (let ((previous nil))
		     (loop for piece in (redisplay-piece-displayed-inferiors last-displayer) do
		       (let ((query (redisplay-piece-unique-id piece)))
			 (when (typep query 'accept-values-query)
			   (when (eq current-query query)
			     (return previous))
			   (setq previous query)))))
	while query
	do (setq current-query query)
	finally (return query)))

(defmethod (accept-values-stream-move-to-next-query accept-values-stream)
	   (&optional (count 1))
  (let ((query
	  (cond ((minusp count) (accept-values-stream-previous-query (- count) cursor-query))
		((plusp count) (accept-values-stream-next-query count cursor-query))
		(t cursor-query))))
    (setq redisplay-necessary nil)
    (if (null query)
	(beep)
	(set-accept-values-stream-cursor-query query))))

(defun-in-flavor (accept-values-stream-cursor-query-choices accept-values-stream) ()
  (when cursor-query
    (let ((list nil))
      (labels ((find-them (presentation)
		 (when (member (presentation-type-name (presentation-type presentation))
			       '(accept-values-choice-display accept-values-value-display))
		   (push presentation list))
		 (dolist (inf (presentation-inferiors presentation))
		   (find-them inf))))
	;; Start from the top-level presentation for this query
	(find-them (loop for piece in (redisplay-piece-displayed-inferiors last-displayer)
			 when (eq (redisplay-piece-unique-id piece) cursor-query)
			   return (redisplay-piece-displayed-presentation piece))))
      ;; Return in standard left-right order regardless of how stored.
      (sort list #'box-position-lessp :key #'presentation-displayed-box))))

(defun-in-flavor (set-accept-values-stream-cursor-choice accept-values-stream)
		 (choice presentation)
  (setq cursor-choice choice)
  (set-accept-values-stream-cursor-highlighting (list presentation)))
 
(defun-in-flavor (accept-values-stream-next-choice accept-values-stream) (count current-choice)
  (loop repeat count
	with (choice presentation)
	do (multiple-value-setq (choice presentation)
	     (loop as previous = nil then choice
		   for presentation in (accept-values-stream-cursor-query-choices)
		   as choice = (presentation-object presentation)
		   when (eq current-choice previous)
		     return (values choice presentation)))
	while choice
	do (setq current-choice choice)
	finally (return (values choice presentation))))

(defun-in-flavor (accept-values-stream-previous-choice accept-values-stream)
		 (count current-choice)
  (loop repeat count
	with (choice presentation)
	do (multiple-value-setq (choice presentation)
	     (loop for (presentation next) on (accept-values-stream-cursor-query-choices)
		   while next
		   when (eq current-choice (presentation-object next))
		     return (values (presentation-object presentation) presentation)))
	while choice
	do (setq current-choice choice)
	finally (return (values choice presentation))))

(defmethod (accept-values-stream-move-to-next-choice accept-values-stream)
	   (&optional (count 1))
  (multiple-value-bind (choice presentation)
      (cond ((minusp count) (accept-values-stream-previous-choice (- count) cursor-choice))
	    ((plusp count) (accept-values-stream-next-choice count cursor-choice))
	    (t cursor-choice))
    (setq redisplay-necessary nil)
    (if (null choice)
	(beep)
	(set-accept-values-stream-cursor-choice choice presentation))))

(defun accept-values-stream-cursor-edit-command (stream choice-command query-command
					  &key edit-old reset-to-nil)
  (let ((cursor-choice (accept-values-stream-cursor-choice stream))
	(cursor-query (accept-values-stream-cursor-query stream)))
    (cond ((typep cursor-choice 'accept-values-choice)
	   (if reset-to-nil
	       (cp::accelerator-error "Can't remove this field.")
	       `(,choice-command ,cursor-choice)))
	  (cursor-query
	   `(,query-command ,cursor-query :edit-old ,edit-old :reset-to-nil ,reset-to-nil))
	  (t
	   (cp::accelerator-error "Nothing highlighted.")))))


(cp:define-command-accelerator replace-highlighted-choice accept-values #\Space () ()
  "Enter a value for the highlighted question"
  (accept-values-stream-cursor-edit-command (accept-values-stream *program*)
					    'com-accept-values-choose-value
					    'com-edit-accept-values-query-value
					    :edit-old nil))

(cp:define-command-accelerator edit-highlighted-choice accept-values #\c-E () ()
  "Edit the highlighted question's value"
  (accept-values-stream-cursor-edit-command (accept-values-stream *program*)
					    'com-accept-values-choose-value
					    'com-edit-accept-values-query-value
					    :edit-old t))

(cp:define-command-accelerator remove-highlighted-choice accept-values #\c-D () ()
  "Remove the highlighted question's value"
  (accept-values-stream-cursor-edit-command (accept-values-stream *program*)
					    'com-accept-values-choose-value
					    'com-edit-accept-values-query-value
					    :reset-to-nil t))

(define-accept-values-command (com-accept-values-next-query) ((count 'integer :default 1))
  (accept-values-stream-move-to-next-query stream count))

(cp:define-command-accelerator com-accept-values-next-query accept-values
			       #\c-N () (ignore arg)
  "Move down to next question"
  `(com-accept-values-next-query ,arg))

(define-accept-values-command (com-accept-values-previous-query) ((count 'integer :default 1))
  (accept-values-stream-move-to-next-query stream (- count)))

(cp:define-command-accelerator com-accept-values-previous-query accept-values
			       #\c-P () (ignore arg)
  "Move up to previous question"
  `(com-accept-values-previous-query ,arg))

(define-accept-values-command (com-accept-values-next-choice)
			      ((count 'integer :default 1))
  (accept-values-stream-move-to-next-choice stream count))

(cp:define-command-accelerator com-accept-values-next-choice accept-values
			       #\c-F () (ignore arg)
  "Move to next choice in an enumeration"
  `(com-accept-values-next-choice ,arg))

(define-accept-values-command (com-accept-values-previous-choice)
			      ((count 'integer :default 1))
  (accept-values-stream-move-to-next-choice stream (- count)))

(cp:define-command-accelerator com-accept-values-previous-choice accept-values
			       #\c-B () (ignore arg)
  "Move to previous choice in an enumeration"
  `(com-accept-values-previous-choice ,arg))

(define-presentation-type accept-values-sample ((&key original-type))
   )

(defmethod (accept-values-stream-find-matching-query accept-values-stream) (type object)
  (let ((queries ()))
    (maphash #'(lambda (ignore query)
		 (multiple-value-bind (subtype-p ignore predicate)
		     (presentation-subtypep type (accept-values-query-presentation-type query))
		   ;; I don't understand how RWK's recent changes broke this,
		   ;; but this never ( before 8/17/87) had to mess with the 
		   ;; predicate before.  -- doughty
		   (when subtype-p
		     (let* ((presentation (accept-values-query-presentation query)))
		       (when (and (or (null predicate)
				      (funcall predicate object))
				  (displayed-presentation-still-visible presentation stream))
			 (push query queries))))))
	     query-table)
    (if (rest queries)
	(first (sort queries #'< :key #'(lambda (query)
					  (box-top
					    (presentation-displayed-box
					      (accept-values-query-presentation query))))))
	(first queries))))

(define-accept-values-command (com-accept-values-use-sample )
    ((type 'presentation-type)
     (value 'expression))
   (let ((query (accept-values-stream-find-matching-query stream type value)))
     (cond (query
	    (setf (accept-values-query-object query) value)
	    (setf (accept-values-query-changed-p query) t)
	    (accept-values-stream-set-appropriate-redisplay-necessary stream query))
	   (t
	    (beep)))))

(define-presentation-to-command-translator accept-values-use-this-sample
   (accept-values-sample
     :tester ((object &key presentation)
	      (and (boundp '*program*) (typep *program* 'accept-values)
		   (with-presentation-type-arguments (accept-values-sample
						       (presentation-type presentation))
		     (accept-values-stream-find-matching-query
		       (accept-values-stream *program*)
		       original-type
		       object))))
     :documentation ((object &key presentation)
		     (let ((query (with-presentation-type-arguments
				    (accept-values-sample (presentation-type presentation))
				    (accept-values-stream-find-matching-query
				      (accept-values-stream *program*)
				      original-type
				      object))))
		       (or (and query
				(let ((prompt (getf (accept-values-query-other-accept-options
						      query)
						    :prompt)))
				  (and (stringp prompt)
				       (format nil "Use this value for ~A" prompt))))
			   "Use this value"))))
   (value &key presentation)
  (values
    (with-presentation-type-arguments (accept-values-sample (presentation-type presentation))
      `(com-accept-values-use-sample ,original-type ,value))
    'cp:command :echo nil))

(defun accept-variable-values (variables &key (prompt "Choose Variable Values")
					      (near-mode '(:mouse))
					      (delayed t)
					      (stream *query-io*)
					      (own-window nil) (temporary-p own-window)
					      (initially-select-query-identifier nil))
  (when (not own-window)
    (si:display-prompt-option stream prompt)
    (fresh-line stream))
  (flet ((accept-one-thing (thing stream)
	   (destructuring-bind (place &optional (prompt :enter-type)
				      (type 'expression))
	      thing
	     (let* ((boundp (if (locativep place)
				(location-boundp place)
				(boundp place)))
		    (value (and boundp
				(if (locativep place)
				    (location-contents place)
				    (symbol-value place)))))
	       (accept type :stream stream :prompt prompt
		       :provide-default boundp
		       :default value :query-identifier place))))
	 (update-one-thing (thing value)
	   (let ((place (first thing)))
	     (if (locativep place)
		 (setf (location-contents place) value)
		 (setf (symbol-value place) value)))))
    (if delayed
	(catch-error-restart (abort "Abort these changes")
	  (loop for val in (accepting-values (stream :own-window own-window
						     :temporary-p temporary-p
						     :near-mode near-mode :label prompt
						     :initially-select-query-identifier
						      initially-select-query-identifier)
			     (loop for thing in variables
				   collect (accept-one-thing thing stream)))
		for thing in variables
		do (update-one-thing thing val)))
	(accepting-values (stream :own-window own-window :temporary-p temporary-p
				  :near-mode near-mode :label prompt
				  :initially-select-query-identifier
				   initially-select-query-identifier)
	  (dolist (thing variables)
	    (update-one-thing thing (accept-one-thing thing stream)))))))

(defun accept-values (descriptions &rest args)
  (declare (arglist descriptions &key (prompt nil)
				      (near-mode '(:mouse))
				      (stream *query-io*)
				      (own-window nil) (temporary-p own-window)
				      (initially-select-query-identifier nil))
	   (values &rest values))
  (values-list (apply #'accept-values-into-list descriptions args)))

(defun accept-values-into-list (descriptions &key (prompt nil)
						  (near-mode '(:mouse))
						  (stream *query-io*)
						  (own-window nil) (temporary-p own-window)
						  (initially-select-query-identifier nil))
  (when (not own-window)
    (si:display-prompt-option stream prompt)
    (fresh-line stream))
  (accepting-values (stream :own-window own-window :temporary-p temporary-p
			    :near-mode near-mode :label prompt
			    :queries-are-independent t
			    :initially-select-query-identifier
			     initially-select-query-identifier)
    (loop for descriptions on descriptions
	  as ((type . options)) = descriptions
	  collect (apply #'accept type :stream stream
			 :query-identifier (getf options :query-identifier (locf (car descriptions)))
			 options))))

(defmacro let*-accept-values ((&optional (stream '*query-io*) &rest accepting-values-args)
			      (&rest name-descriptions)
			      &body body)
  (loop for (name . description) in name-descriptions
	collect `(,name) into let-forms
	collect name into local-names
	collect description into descriptions
	finally
	  (return
	    `(let ,let-forms
	       (accepting-values (,stream ,@accepting-values-args)
		 ,@(loop for (type . options) in descriptions
			 for name in local-names 
			 collect `(setq ,name (accept ,type :stream ,stream
						      . ,options))))
	       ,@body))))

(defmacro accept-values-then-setf
	  ((&optional (stream '*query-io*) &rest accepting-values-args)
	   (&rest name-place-descriptions))
  (loop for (name place . description) in name-place-descriptions
	collect place into places
	collect name into names
	collect (list* name description) into l*av-descs
	finally
	  (return
	    `(setf (values ,@places)
		   (let*-accept-values (,stream ,@accepting-values-args)
				       ,l*av-descs
		     (values ,@names))))))

(defmacro accepting-values-then-setf
	  ((&optional (stream '*query-io*) &rest accepting-values-args)
	   (&rest name-place-pairs)
	   &body body)
  (loop for (name place) in name-place-pairs
	collect `(,name ,(or place name)) into let-forms
	collect name into local-names
	collect (or place name) into place-forms
	do (check-type name symbol)
	finally
	  (return
	    `(setf (values ,@place-forms)
		   (let ,let-forms
		     (accepting-values (,stream ,@accepting-values-args)
		       (progn ,@body)
		       (values ,@local-names)))))))

;;; Like write-line, but properly interacts with AVV redisplay.
(defun accept-values-fixed-line (string &optional (stream *query-io*))
  (with-redisplayable-output (:unique-id string
			      :cache-value string
			      :stream stream)
    (terpri stream)
    #||
    (format stream " ~%")
    (when (equal string "")
      (write-char #\space stream))
    ||#
    (write-line string stream)))

(defmethod (accept-values-for-defaults-internal accept-values-stream) (continuation)
  (letf ((state :returning))
    (funcall continuation self)))

(defun accept-values-for-defaults (continuation)
  (using-resource (stream accept-values-stream *standard-input*)
    (accept-values-for-defaults-internal stream continuation)))

(defstruct (accept-values-command-button :list*
	     (:constructor make-accept-values-command-button
	      (continuation documentation &rest options)))
  continuation
  documentation
  options)

(define-presentation-type accept-values-command-button ())

(defmacro accept-values-command-button ((&optional stream &rest options) prompt
					&body conditional-forms)
  (declare (arglist (&optional (stream *standard-output*)
		     &key who-line-documentation-string
			  short-prompt
			  query-identifier default-p
			  (cache-value t) (cache-test #'eql))
		    prompt &body conditional-forms))
  (format-output-macro-default-stream stream)
  `(accept-values-command-button-internal
     ,(if (stringp prompt) prompt `(dw:named-continuation prompt (,stream) ,prompt))
     (sys:named-lambda accept-values-command-button () . ,conditional-forms)
     ,stream . ,options))

(defun accept-values-command-button-internal (prompt continuation stream &rest args)
  (apply #'accept-values-command-button-internal-1 stream prompt continuation stream args))

(defmethod (accept-values-command-button-internal-1 encapsulating-output-stream) (&rest args)
  (apply #'accept-values-command-button-internal-1 stream args))

(defmethod (accept-values-command-button-internal-1 accept-values-stream)
	   (prompt continuation stream
	    &key (who-line-documentation-string
		   (if (stringp prompt)
		       prompt
		       (with-output-to-string (stream) (funcall prompt stream))))
		 (query-identifier `(**button** ,who-line-documentation-string))
		 (cache-value t) (cache-test #'eql)
		 short-prompt default-p)
  (ignore short-prompt default-p)
  (with-redisplayable-output (:unique-id query-identifier :id-test #'equal
			      :cache-value cache-value :cache-test cache-test
			      :stream stream)
    (with-output-as-presentation (:stream stream
				  :object (make-accept-values-command-button
					    continuation who-line-documentation-string)
				  :type 'accept-values-command-button)
      (if (stringp prompt)
	  (write-line prompt stream)
	  (funcall prompt stream)))))

(defmethod (accept-values-toggle-command-button accept-values-stream) (button)
  (maphash #'(lambda (ignore query)
	       (setf (accept-values-query-changed-p query) nil))
	   query-table)
  (setq redisplay-necessary t)
  (funcall (accept-values-command-button-continuation button)))

(define-accept-values-command (com-accept-values-toggle-command-button )
    ((button 'accept-values-command-button))
   (accept-values-toggle-command-button stream button)
   (throw 'accept-values-resynchronize t))

(define-presentation-to-command-translator toggle-accept-values-command-button
   (accept-values-command-button
     :documentation ((button) (accept-values-command-button-documentation button)))
   (button)
  `(com-accept-values-toggle-command-button ,button))

;;; Support for accept-values panes

(defflavor accept-values-pane-stream
	(program accept-values-function)
	(accept-values-stream)
  :initable-instance-variables)

;;*** Note that if you add arguments here, you must correct the magic number
;;*** (currently 6) in D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")accept-values-pane-stream0 to access the first captured
;;*** local below.
(defun construct-accept-values-pane-redisplay-function (&key accept-values-function
							     (queries-are-independent nil)
							     (changed-value-overrides-default
							       nil)
							     (query-entry-mode :inline)
							     (program-modifies-state t)
							&allow-other-keys)
  (let ((accept-values-stream nil)
	(displayer nil))
    (lambda (program stream &aux init)
      (when (or (null displayer)
		;; If the history gets explicitly cleared, make a new one, like the
		;; non :own-redisplayer code would do.
		(let ((presentation (redisplay-piece-displayed-presentation displayer)))
		  (and presentation
		       (not (displayed-presentation-still-visible presentation stream)))))
	(setq init t
	      displayer (redisplayer (stream)
			  (let ((rubout-handler nil)
				(*input-editor-options* nil)
				(*accept-active* nil)
				(*accept-help* nil))
			    (funcall accept-values-function program stream)))))
      (when (null accept-values-stream)
	(setq accept-values-stream (make-instance 'accept-values-pane-stream
						  :accept-values-function
						   accept-values-function
						  :program program)))
      (when (or init (neq (accept-values-stream-stream accept-values-stream) stream))
	(send accept-values-stream :initialize stream)
	(setf (accept-values-stream-changed-value-overrides-default accept-values-stream)
	        changed-value-overrides-default
	      (accept-values-stream-queries-are-independent accept-values-stream)
	        queries-are-independent
	      (accept-values-stream-query-entry-mode accept-values-stream)
	        query-entry-mode))
      (with-output-truncation (accept-values-stream)	;Use given size.
	(accept-values-stream-do-redisplay accept-values-stream displayer :truncate-p nil))
      ;; A command must explicitly override the default of full redisplay, either to none
      ;; or a specific subpiece.
      (setf (accept-values-stream-redisplay-necessary accept-values-stream)
	    program-modifies-state)))) 

;;; Compatibility with old program binaries
(defun make-accept-values-pane-redisplay-function (accept-values-function)
  (construct-accept-values-pane-redisplay-function
    :accept-values-function accept-values-function))

(defmethod (accept-values-pane-resynchronize-and-reset accept-values-pane-stream) ()
  (letf ((state :resynchronizing))
    (funcall accept-values-function program self)))

(compile-flavor-methods accept-values-pane-stream)

(defvar *accept-values-pane-command-table* (cp:make-command-table "accept-values-pane"
								  :inherit-from nil))

(define-presentation-type accept-values-query-display ()
   :printer ((query stream)
	     (ignore query)
	     (princ "query" stream)))

(cp:define-command (com-edit-accept-values-pane-query-value
		     :command-table "accept-values-pane"
		     :provide-output-destination-keyword nil)
    ((query 'accept-values-query-display)
     &key
     (edit-old 'boolean :default nil :mentioned-default t)
     (reset-to-nil 'boolean :default nil))
  (let ((stream (accept-values-query-stream query)))
    (tv:window-call ((accept-values-stream-stream stream))
      (read-new-value stream query :edit-old edit-old :reset-to-nil reset-to-nil))
    (accept-values-pane-resynchronize-and-reset stream)))

(define-presentation-to-command-translator accept-values-pane-new-value
   (accept-values-value-display
     :gesture :select
     :documentation "Replace this field")
   (accept-values-value)
  (values
    `(com-edit-accept-values-pane-query-value
       ,(accept-values-value-query-identifier accept-values-value))
    'cp:command :echo nil))

(define-presentation-to-command-translator accept-values-pane-edit-value
   (accept-values-value-display
     :gesture :select-and-edit
     :documentation "Edit this field")
   (accept-values-value)
  (values
    `(com-edit-accept-values-pane-query-value
       ,(accept-values-value-query-identifier accept-values-value)
       :edit-old t)
    'cp:command :echo nil))

(define-presentation-to-command-translator accept-values-pane-remove-value
   (accept-values-value-display
     :gesture :remove
     :documentation "Remove this field")
   (accept-values-value)
  (values
    `(com-edit-accept-values-pane-query-value
       ,(accept-values-value-query-identifier accept-values-value)
       :reset-to-nil t)
    'cp:command :echo nil))

(define-presentation-type accept-values-choice-display ()
   :printer ((choice stream)
	     (ignore choice)
	     (princ "choice" stream)))

(cp:define-command (com-accept-values-pane-choose-value
		     :command-table "accept-values-pane"
		     :provide-output-destination-keyword nil)
    ((choice 'accept-values-choice-display))
  (accept-values-pane-resynchronize-and-reset
    (accept-values-query-stream (accept-values-choose-value choice))))

(define-presentation-to-command-translator com-accept-values-pane-choose-value
    (accept-values-choice-display
      :documentation ((item)
		      (or (accept-values-choice-documentation item)
			  "Select this choice")))
  
  (choice)
  (values
    `(com-accept-values-pane-choose-value ,choice)
    'cp:command :echo nil))

(cp:define-command (com-accept-values-pane-toggle-command-button
		     :command-table "accept-values-pane"
		     :provide-output-destination-keyword nil)
    ((button 'accept-values-command-button))
   (let ((stream (accept-values-pane-stream)))
     (accept-values-toggle-command-button stream button)
     (accept-values-pane-resynchronize-and-reset stream)))

(define-presentation-to-command-translator toggle-accept-values-pane-command-button
   (accept-values-command-button
     :documentation ((button) (accept-values-command-button-documentation button)))
   (button)
  (values `(com-accept-values-pane-toggle-command-button ,button) 'cp:command
	  :echo nil))

;;; A program could redefine this if it had some multiplexing.
(defmethod (program-accept-values-pane program) ()
  (loop for desc in (send frame :parsed-panes)
	when (eq (getf (cdr desc) :type) :accept-values)
	  return (first desc)))

(defun accept-values-pane-stream (&optional (program *program*))
  (let ((pane-name (program-accept-values-pane program)))
    (when pane-name
      (let ((displayer (getf (cdr (assoc pane-name
					 (send (program-frame program) :parsed-panes)))
			     :redisplay-function)))
	(when (typep displayer 'lexical-closure)
	  ;;*** This 1sixth0 is in the captured local block after the arguments.
	  ;;*** it is the accept-values-stream variable
	  ;;*** See 1construct-accept-values-pane-redisplay-function0.
	  (sixth (lexical-closure-environment displayer)))))))

(defmethod (accept-values-pane-inhibit-redisplay program) ()
  (not (accept-values-stream-redisplay-necessary (accept-values-pane-stream self))))

(defmethod ((setf accept-values-pane-inhibit-redisplay) program) (new-value)
  (setf (accept-values-stream-redisplay-necessary (accept-values-pane-stream self))
	(not new-value)))

(defvar *accept-values-pane-with-keyboard-commands-command-table*
	(cp:make-command-table "accept-values-pane-with-keyboard-commands"
			       :inherit-from '("accept-values-pane")))

(cp:define-command-accelerator replace-highlighted-choice-pane
			       accept-values-pane-with-keyboard-commands
			       #\Space (:echo nil) ()
  "Enter a value for the highlighted question"
  (accept-values-stream-cursor-edit-command (accept-values-pane-stream)
					    'com-accept-values-pane-choose-value
					    'com-edit-accept-values-pane-query-value
					    :edit-old nil))

(cp:define-command-accelerator edit-highlighted-choice-pane
			       accept-values-pane-with-keyboard-commands
			       #\c-E (:echo nil) ()
  "Edit the highlighted question's value"
  (accept-values-stream-cursor-edit-command (accept-values-pane-stream)
					    'com-accept-values-pane-choose-value
					    'com-edit-accept-values-pane-query-value
					    :edit-old t))

(cp:define-command-accelerator remove-highlighted-choice-pane
			       accept-values-pane-with-keyboard-commands
			       #\c-D (:echo nil) ()
  "Remove the highlighted question's value"
  (accept-values-stream-cursor-edit-command (accept-values-pane-stream)
					    'com-accept-values-pane-choose-value
					    'com-edit-accept-values-pane-query-value
					    :reset-to-nil t))

(cp:define-command (com-accept-values-pane-next-query
		     :command-table "accept-values-pane-with-keyboard-commands"
		     :provide-output-destination-keyword nil)
    ((count 'integer :default 1))
  (accept-values-stream-move-to-next-query (accept-values-pane-stream) count))

(cp:define-command-accelerator com-accept-values-pane-next-query
			       accept-values-pane-with-keyboard-commands
			       #\c-N (:echo nil) (ignore arg)
  "Move down to next question"
  `(com-accept-values-pane-next-query ,arg))

(cp:define-command (com-accept-values-pane-previous-query
		     :command-table "accept-values-pane-with-keyboard-commands"
		     :provide-output-destination-keyword nil)
    ((count 'integer :default 1))
  (accept-values-stream-move-to-next-query (accept-values-pane-stream) (- count)))

(cp:define-command-accelerator com-accept-values-pane-previous-query
			       accept-values-pane-with-keyboard-commands
			       #\c-P (:echo nil) (ignore arg)
  "Move up to previous question"
  `(com-accept-values-pane-previous-query ,arg))

(cp:define-command (com-accept-values-pane-next-choice
		     :command-table "accept-values-pane-with-keyboard-commands"
		     :provide-output-destination-keyword nil)
    ((count 'integer :default 1))
  (accept-values-stream-move-to-next-choice (accept-values-pane-stream) count))

(cp:define-command-accelerator com-accept-values-pane-next-choice
			       accept-values-pane-with-keyboard-commands
			       #\c-F (:echo nil) (ignore arg)
  "Move to next choice in an enumeration"
  `(com-accept-values-pane-next-choice ,arg))

(cp:define-command (com-accept-values-pane-previous-choice
		     :command-table "accept-values-pane-with-keyboard-commands"
		     :provide-output-destination-keyword nil)
    ((count 'integer :default 1))
  (accept-values-stream-move-to-next-choice (accept-values-pane-stream) (- count)))

(cp:define-command-accelerator com-accept-values-pane-previous-choice
			       accept-values-pane-with-keyboard-commands
			       #\c-B (:echo nil) (ignore arg)
  "Move to previous choice in an enumeration"
  `(com-accept-values-pane-previous-choice ,arg))

(defstruct (template-helper
	     (:constructor make-template-helper (keyword when
						 prompt reader printer documentation value
						 other-properties)))
  keyword
  when
  prompt
  reader
  printer
  documentation
  value
  other-properties)

(defmacro define-template-helper (defining-form variable &key other-properties)
  (macrolet ((do-slots ((var name) form)
	       `(macrolet ((do-1-slot (,var ,name) ',form))
		  (loop for (var name) in '((when when-name)
					    (prompt prompt-name)
					    (reader reader-name)
					    (printer printer-name)
					    (documentation documentation-name)
					    (value value-name))
			collect (do-1-slot var name)))))
    `(progn
       (defvar ,variable nil)
       (defmacro ,defining-form (keyword &body options)
	 (declare (arglist &key when prompt reader printer documentation value
			   . ,(loop for key in other-properties
				    collect (intern (symbol-name key)))))
	 (si:with-rem-keywords (some-options options ',other-properties)
	   (destructuring-bind (&key when prompt reader printer documentation value)
	       some-options
	     (let ,(do-slots (var name)
			     `(,name
			       (and (consp ,var)
				    (sys:fintern "~A-~A-~A" keyword ',defining-form ',var))))
	       `(progn
		  ,@(list . ,(do-slots (var name)
				       `(when (consp ,var) `(defun ,,name . ,,var))))
		  (define-template-helper-2 ',',variable ',keyword
		    ,@(list . ,(do-slots (var name) `(list 'quote (or ,name ,var))))
		    ',(zwei:some-plist options ',other-properties))))))))))

(defun define-template-helper-2 (variable keyword when
				 prompt reader printer documentation value
				 other-properties)
  (when (null prompt)
    (setq prompt (nsubstitute #\space #\- (string-capitalize keyword))))
  (pushnew (make-template-helper keyword when prompt reader printer documentation value
				 other-properties)
	   (symbol-value variable)
	   :replace t :key #'template-helper-keyword))

(defun call-helper-accept (list prompt set &optional preamble (stream *query-io*))
  (let ((keyword (first list)))
    (setq keyword (accept `((scl:alist-member
			      :alist ,(let ((result nil))
					(dolist (helper set)
					  (when (let ((function (template-helper-when helper)))
						  (or (null function) (funcall function)))
					    (push
					      `(,(template-helper-prompt helper)
						:value ,(template-helper-keyword helper)
						,@(let ((doc (call-helper-documentation
							       helper preamble)))
						    (when doc `(:documentation ,doc))))
					      result)))
					result)))
			  :prompt prompt
			  :default keyword))
    (list* keyword (call-helper-field (if (eq keyword (first list)) list (list keyword)) set
				      #'template-helper-reader stream))))

(defun call-helper-documentation (helper preamble)
  (when helper
    (let ((function (template-helper-documentation helper)))
      (if (stringp function)
	  function
	  (with-output-to-string (stream)
	    (if function
		(funcall function stream)
		(when preamble
		  (write-string preamble stream))
		(call-helper-printer-1 helper stream nil)))))))

(defun call-helper-value (list set &rest args)
  (apply #'call-helper-field list set #'template-helper-value args))

(defun call-helper-printer (list set stream)
  (let ((helper (find (first list) set :key #'template-helper-keyword)))
    (call-helper-printer-1 helper stream (rest list))))

(defun call-helper-printer-1 (helper stream args)
  (when helper
    (let ((function (template-helper-printer helper)))
      (if (stringp function)
	  (write-string function stream)
	  (when function
	    (apply function stream args))))))

(defun call-helper-field (list set field &rest args)
  (let ((helper (find (first list) set :key #'template-helper-keyword)))
    (when helper
      (let ((function (funcall field helper)))
	(when function
	  (apply function (append args (rest list))))))))

(defun get-helper-property (list set indicator &optional default)
  (let ((helper (find (first list) set :key #'template-helper-keyword)))
    (when helper
      (getf (template-helper-other-properties helper) indicator default))))

;;; Utility for namespace-editor style lists of items with template
;;; for the next one.  They can't all be on the same line yet, 
;;; unfortunately.


(defflavor value-changed-p-stream (any-value-changed-p) (full-encapsulating-stream)
  (:readable-instance-variables any-value-changed-p)
  )

(defmethod ((setf value-changed-p-stream-stream) value-changed-p-stream) (new-stream)
  (setq stream new-stream
	any-value-changed-p nil
	which-operations nil))

(defmethod (accept-1 value-changed-p-stream) (&rest args)
  (multiple-value-bind (value type unedited-p)
      (apply #'accept-1 stream args)
    (unless unedited-p
      (setq any-value-changed-p t))
    (values value type unedited-p)))
  
(defwhopper (:which-operations value-changed-p-stream) ()
  (or which-operations
      (setq which-operations (append (continue-whopper)
				     (send stream :which-operations)))))

(defmethod (:operation-handled-p value-changed-p-stream) (op)
  (or (member op '(:which-operations :unclaimed-message))
      (and stream (send stream :operation-handled-p op))
      (member op (send self :which-operations))))

(defmethod (:send-if-handles value-changed-p-stream) (op &rest args)
  (when (send self :operation-handled-p op)
    (lexpr-send self op args)))

(defmethod (:unclaimed-message value-changed-p-stream) (&rest args)
  (apply stream args))

(compile-flavor-methods value-changed-p-stream)

(defresource value-changed-p-stream (stream)
  :constructor (make-instance 'value-changed-p-stream)
  :initializer (setf (value-changed-p-stream-stream object) stream)
  :deinitializer (setf (value-changed-p-stream-stream object) nil))

(defun accept-values-on-sequence (sequence parsing-continuation
				  &key (stream *query-io*) (default nil))
  "This must be called inside an accepting-values :resynchronize-every-pass t.
The parsing-continuation is called with:
  (item-datum stream item-index template-p)
the supplied default item, a stream, the index into the sequence of this item,
and NIL for values already given by the user and T for the template.  
The parsing-continuation should accept an item using the supplied item as the initial
values for the fields. Deletion of items isn't supported yet. "
  (sys:with-stack-array (new-sequence (length sequence) :initial-contents sequence
				      :fill-pointer (length sequence))
    (dotimes (i (length new-sequence))
      (setf (aref new-sequence i)
	    (funcall parsing-continuation (elt sequence i) stream i nil)))
    (using-resource (special-stream value-changed-p-stream stream)
      (let ((new-value (funcall parsing-continuation default special-stream
				(length sequence) t)))
	(when (value-changed-p-stream-any-value-changed-p special-stream)
	  (vector-push-extend new-value new-sequence)
	  )))
    (coerce new-sequence (if (listp sequence) 'list 'vector))))

(defun accept-subfield (separator presentation-type &rest args
						    &key (stream *query-io*)
							 (prompt nil prompt-p)
						    &allow-other-keys)
  (stack-let* ((delimiters (list (aref separator 0)))
	       (more-args (list* :prompt prompt :additional-blip-chars delimiters args)))
    (when prompt-p
      (setq more-args (cddr more-args)))
    (multiple-value-prog1
      (apply #'accept presentation-type more-args)
      (if (compare-char-for-accept (peek-char-for-accept stream)
				   (aref separator 0))
	  (read-char-for-accept stream)
	  (presentation-replace-input stream (send stream :read-location) separator
				      :dont-quote t)))))

(defmacro with-accept-subfields ((&optional (stream '*query-io*) &key (separator " "))
				 variables-and-types &body body
				 &environment env)
  (declare (zwei:indentation 1 3 2 1))
  (once-only (separator stream &environment env)
    `(let* ,(loop for (variable presentation-type . accept-args) in variables-and-types
		  collect `(,variable (accept-subfield ,separator ,presentation-type
						       :stream ,stream . ,accept-args)))
       . ,body)))

(compile-flavor-methods accept-values)
