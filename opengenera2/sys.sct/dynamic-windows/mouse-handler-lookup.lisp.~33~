;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Handler tables and handler lookup routines

;;; This really should be an instance, but...
(defstruct (handler-table-entry (:type list))
  handler
  types)

(defstruct (handler-table-types (:type list))
  context-type
  displayed-type
  predicate)

(defstruct (handler-table-types-2 (:type list))
  context-type
  displayed-type)

(defsubst handler-table-entry-predicate (handler-table-entry)
  (handler-table-types-predicate
    (handler-table-entry-types handler-table-entry)))

(defsubst handler-table-entry-context-type (handler-table-entry)
  (handler-table-types-context-type
    (handler-table-entry-types handler-table-entry)))

(defsubst handler-table-entry-displayed-type (handler-table-entry)
  (handler-table-types-displayed-type
    (handler-table-entry-types handler-table-entry)))

(defun presentation-type-equal (type-1 type-2)
  (or (eql type-1 type-2)
      (and (listp type-1)
	   (listp type-2)
	   (loop for l1 = type-1 then (cdr l1)
		 for l2 = type-2 then (cdr l2)
		 when (and (null l1) (null l2))
		   do (return t)
		 when (not (eql l1 l2))
		   do (return nil)))
      (with-key-for-cache (key-1 type-1)
	(with-key-for-cache (key-2 type-2)
	  (fringe-eql key-1 key-2)))))

;;; Compare two handler table entries to see if we can eliminate one as a duplicate.
;;; This isn't guarenteed to find all that are equivalent, but it is guarenteed to not
;;; say things are equivalent when they are not.
(defun handler-table-entry-equal (he-1 he-2)
  (and (let ((handler-1 (handler-table-entry-handler he-1))
	     (handler-2 (handler-table-entry-handler he-2)))
	 (or (eql handler-1 handler-2)
	     (eql (presentation-mouse-handler-handler-functions handler-1)
		  (presentation-mouse-handler-handler-functions handler-2))))
       (or (eq (handler-table-entry-types he-1)
	       (handler-table-entry-types he-2))
	   (and (eql (handler-table-entry-predicate he-1)
		     (handler-table-entry-predicate he-2))
		(presentation-type-equal (handler-table-entry-context-type he-1)
					 (handler-table-entry-context-type he-2))
		(presentation-type-equal (handler-table-entry-displayed-type he-1)
					 (handler-table-entry-displayed-type he-2))))))

(defun handler-table-entry-hash (entry)
  (declare (values hash gc-flag))
  (let ((rot 0)
	(hash 0)
	(flag %gc-dependence-none))
    (labels ((do-frob (frob)
	       (multiple-value-bind (frob-hash frob-flag)
		   (fringe-eql-hash frob)
		 (setq hash (logxor hash
				    (rot frob-hash rot)))
		 (setq rot (ldb (byte 5 0) (+ rot 7)))
		 (maxf flag frob-flag)))
	     (do-type (type)
	       (with-key-for-cache (key type)
		 (do-frob key))))
      (do-frob (presentation-mouse-handler-handler-functions
		 (handler-table-entry-handler entry)))
      (do-frob (handler-table-entry-predicate entry))
      (do-type (handler-table-entry-context-type entry))
      (do-type (handler-table-entry-displayed-type entry)))
    (values hash flag)))

(defun handler-table-type-equal (htt-1 htt-2)
  (or (eql htt-1 htt-2)
      (and (eql (handler-table-types-predicate htt-1)
		(handler-table-types-predicate htt-2))
	   (presentation-type-equal (handler-table-types-context-type htt-1)
				    (handler-table-types-context-type htt-2))
	   (presentation-type-equal (handler-table-types-displayed-type htt-1)
				    (handler-table-types-displayed-type htt-2)))))

(defun handler-table-type-hash (entry)
  (declare (values hash gc-flag))
  (let ((rot 0)
	(hash 0)
	(flag %gc-dependence-none))
    (labels ((do-frob (frob)
	       (multiple-value-bind (frob-hash frob-flag)
		   (fringe-eql-hash frob)
		 (setq hash (logxor hash
				    (rot frob-hash rot)))
		 (setq rot (ldb (byte 5 0) (+ rot 7)))
		 (maxf flag frob-flag)))
	     (do-type (type)
	       (with-key-for-cache (key type)
		 (do-frob key))))
      (do-frob (handler-table-types-predicate entry))
      (do-type (handler-table-types-context-type entry))
      (do-type (handler-table-types-displayed-type entry)))
    (values hash flag)))

;;; Same as above but he-2 hasn't been consed yet, so its components are passed individually
(defun handler-table-entry-components-equal (he-1 handler-2 predicate-2
					     context-type-2 displayed-type-2)
  (and (let ((handler-1 (handler-table-entry-handler he-1)))
	 (or (eql handler-1 handler-2)
	     (eql (presentation-mouse-handler-handler-functions handler-1)
		  (presentation-mouse-handler-handler-functions handler-2))))
       (eql (handler-table-entry-predicate he-1) predicate-2)
       (presentation-type-equal (handler-table-entry-context-type he-1) context-type-2)
       (presentation-type-equal (handler-table-entry-displayed-type he-1) displayed-type-2)))


;;; This does not need to be cleared when the types change, but it
;;; should be cleared at D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB"):full-gc0 time.
;;; It can be reconstructed by scanning the area.
(defvar *handler-table-entry-cache*
	(make-good-table :test #'handler-table-entry-equal
			 :hash-function #'handler-table-entry-hash
			 :store-hash-code t
			 :number-of-values 0
			 :name "HTE cache"))

;;; Ditto.
(defvar *handler-table-type-cache*
	(make-good-table :test #'handler-table-type-equal
			 :hash-function #'handler-table-type-hash
			 :store-hash-code t
			 :number-of-values 0
			 :name "HTE type-list cache"))

(defvar *handler-table-entry-cache-events* 0)
(defvar *handler-table-entry-cache-misses* 0)
(defvar *handler-table-entry-types-misses* 0)


(defun create-handler-table-list (handler existing-list)
  (setf *handler-table-top-level-list-cache-events*
	(%32-bit-plus 1 *handler-table-top-level-list-cache-events*))
  (stack-let ((new-list (cons handler existing-list)))
    (multiple-value-bind (ignore found-p old-list)
	(gethash new-list *handler-table-top-level-list-cache*)
      (if found-p old-list
	(let ((new-list (cons-in-area handler existing-list *handler-lists-area*)))
	  (setf *handler-table-top-level-list-cache-misses*
		(%32-bit-plus 1 *handler-table-top-level-list-cache-misses*))
	  (setq new-list (lt::localize-list new-list *handler-lists-area*))
	  (setf (gethash new-list *handler-table-top-level-list-cache*) new-list)
	  new-list)))))

(defun uniquify-handler-table-list (new-list)
  (setf *handler-table-top-level-list-cache-events*
	(%32-bit-plus 1 *handler-table-top-level-list-cache-events*))
  (multiple-value-bind (ignore found-p old-list)
      (gethash new-list *handler-table-top-level-list-cache*)
    (if found-p old-list
      (let ((new-list (copy-list new-list *handler-lists-area*)))
	(setf *handler-table-top-level-list-cache-misses*
	      (%32-bit-plus 1 *handler-table-top-level-list-cache-misses*))
	(setf (gethash new-list *handler-table-top-level-list-cache*) new-list)
	new-list))))

(defun create-handler-table-entry (handler predicate context-new-type displayed-new-type)
  (labels ((copy-type (type)
	     (if (atom type)
		 (progn (setf *handler-table-presentation-type-non-events*
			      (%32-bit-plus 1 *handler-table-presentation-type-non-events*))
			type)
	       (setf *handler-table-presentation-type-cache-events*
		     (%32-bit-plus 1 *handler-table-presentation-type-cache-events*))
	       (with-key-for-cache (key type)
		 (multiple-value-bind (ntype found-p)
		     (gethash key *handler-table-presentation-type-cache*)
		   (unless found-p
		     (setf *handler-table-presentation-type-cache-misses*
			   (%32-bit-plus 1 *handler-table-presentation-type-cache-misses*))
		     ;; We can't copy the presentation-types into 1*handler-table-area*0,
		     ;; since then our GC wouldn't be able to distinguish them from
		     ;; a types structure.
		     (setf ntype (heap-copy-presentation-type type
							      *handler-types-area*
							      4)
			   key (copy-tree key *handler-dynamic-area*)
			   (gethash key *handler-table-presentation-type-cache*) ntype))
		   ntype)))))
    (setq context-new-type (copy-type context-new-type)
	  displayed-new-type (copy-type displayed-new-type))
    (stack-let* ((types (make-handler-table-types
			  :context-type context-new-type
			  :displayed-type displayed-new-type
			  :predicate predicate))
		 (types2 (make-handler-table-types
			  :context-type context-new-type
			  :displayed-type displayed-new-type))
		 (test (make-handler-table-entry
			 :handler handler
			 :types types)))
      (unless predicate
	(setq types types2))
      (multiple-value-bind (nil found-p ntypes)
	  (gethash types *handler-table-type-cache*)
	(if found-p
	    (setf (handler-table-entry-types test) ntypes)
	  (setf *handler-table-entry-types-misses*
		(%32-bit-plus 1 *handler-table-entry-types-misses*))
	  (setf types (copy-list types *handler-table-area*))
	  (setf (handler-table-entry-types test) types)
	  (setf (gethash types *handler-table-type-cache*) types)))
      (setf *handler-table-entry-cache-events*
	    (%32-bit-plus 1 *handler-table-entry-cache-events*))
      (multiple-value-bind (nil found-p hte)
	  (gethash test *handler-table-entry-cache*)
	(if found-p
	    hte
	  (setf *handler-table-entry-cache-misses*
		(%32-bit-plus 1 *handler-table-entry-cache-misses*))
	  (setq test (copy-list test *handler-table-area*))
	  (setf (gethash test *handler-table-entry-cache*) test)
	  test)))))

(defvar *handlers-affected-by-types-table*
	(make-good-table :test 'eq
			 :name "Handlers on types"))

;;; This contains tables, indexed by 1((2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")context-key1 2displayed-key1)0, and
;;; yielding 2handler-table-entry0's.
;;; It is indexed by 2type-being-redefined0.

(defvar *handler-table-entries-possibly-changed*
	(make-good-table :test #'fringe-eql
			 :hash-function #'fringe-eql-hash
			 :name "Entries changed"))

;;; This controls initial allocation of a few tables.
(defparameter *large-context-table-sizes*
	      '(((t zwei:presentation-command cp:command expression) 190)
		((form) 123)
		((nil) 30)))

(defun delete-stale-handler-entries (handler handler-list)
  (let ((handler-name (presentation-mouse-handler-name handler)))
    (labels ((stale-handler-p (test-entry)
				       (let ((test-handler
					       (handler-table-entry-handler test-entry)))
					 (and (neq handler test-handler)
					      (eql (presentation-mouse-handler-name
						     test-handler)
						   handler-name)))))
      (delete-if #'stale-handler-p handler-list))))

(defun make-handler-table-internal-table (context-type)
  (let ((size (or (second (assoc context-type *large-context-table-sizes*
				 :test #'member))
		  20)))		;Turns into 30, enough for most of the tables
    (make-hash-table :test #'fringe-eql :hash-function #'fringe-eql-hash
		     :locking nil
		     :store-hash-code t
		     :size size
		     :area *handler-dynamic-area*)))


;;; The locking order:
;;;  1)  The changes table (1:write0)
;;;    2)  The handlers-affected-by-types table (1:write0)
;;;      3)  The handler table (1:write0)
;;; This only locks the inner two, as it is unaffected by the changes table.

(defun enter-handler-in-table-with-predicates
       (handler &optional (table *presentation-type-mouse-handler-table*)
	(put-in-dispatch-area t))
  ;; Insert it, then take care of any flavor changes we've wrought by composing components.
  ;; This is a way of making sure that any entries we make in the table for flavors are for
  ;; composed flavors.  This guarentees that a table entry will either not exist, or will
  ;; have 2all0 of the handlers for that entry.
  (flavor::with-pending-dw-updates
    (let ((handler-name (presentation-mouse-handler-name handler))
	  (context-type (presentation-mouse-handler-context-presentation-type handler))
	  (displayed-type (presentation-mouse-handler-displayed-presentation-type handler))
	  (types-seen))
      (when (eq context-type t)			;T means "be a subtype of everything
	(setq context-type nil))
      (with-good-lock (*handlers-affected-by-types-table* :write)
	(with-good-lock (table :write)
	  (labels ((collector (type)
		     (if (atom type)
			 ;; Faster, and avoids 1dw::no-type
0			 (collect-one-type type)
			 (map-over-types-relevant-to-type type #'collect-one-type type)))
		   (collect-one-type (type)
		     (declare (sys:downward-function))
		     (unless (atom type)
		       (error "~S is the wrong thing." type))
		     (unless (member type types-seen)
		       ;; Move to dynamic area if we're going to save this list.
		       (push type types-seen)
		       (compose-flavor-for-dw type handler-name)
		       (pushnew (presentation-mouse-handler-name handler)
				(gethash type *handlers-affected-by-types-table*)
				:area *handler-dynamic-area*))))
	    (map-over-type-hierarchy context-type t nil
	       (lambda (found-context-type subkey predicate)
		 (collector found-context-type)
		 (ignore predicate)		;I suppose this might be applied to the result
						;of the translator, and an error signaled.
		 (let ((displayed-subtable (gethash subkey table)))
		   (unless displayed-subtable
		     (setf displayed-subtable
			   (setf (gethash (copy-tree subkey *handler-dynamic-area*) table)
				 (make-handler-table-internal-table context-type))))
		   (map-over-type-hierarchy displayed-type nil nil
		      (lambda (found-displayed-type subkey predicate)
			(collector found-displayed-type)
			;; Don't put duplicates into handler-list
			(let ((handler-list (gethash subkey displayed-subtable)))
			  (macrolet ((simple-type (type)
				       ;; Discard the presentation arguments.  We know
				       ;; that the user of this information uses modern
				       ;; macrology, so it can deal with CL-syntax types.
				       `(let ((typetem ,type))
					  (with-type-decoded (type-name type-data)
						typetem
					     (if (null type-data)
						 type-name
						 (if (atom (car typetem))
						     typetem	;already a CL-syntax type
						     (car typetem)))))))
			    (let ((simple-context-type (simple-type found-context-type))
				  (simple-displayed-type (simple-type found-displayed-type)))
			      (unless (dolist (handler-entry handler-list)
					(when (handler-table-entry-components-equal
						handler-entry handler predicate
						simple-context-type simple-displayed-type)
					  (return t)))
				(let ((handler-entry
					(create-handler-table-entry handler predicate
								    simple-context-type
								    simple-displayed-type)))
				  (setq handler-list
					(delete-stale-handler-entries handler handler-list))
				  (push handler-entry handler-list)
				  (setf (gethash (copy-tree subkey *handler-dynamic-area*)
						 displayed-subtable)
					(if put-in-dispatch-area
					    (copy-list handler-list *handler-lists-area*)
					    handler-list))))))))
		     nil))))))))))

(defun presentation-mouse-handler-name (handler)
  (presentation-mouse-handler-functions-name
    (presentation-mouse-handler-handler-functions
      handler)))


(defvar *background-update-check-interval* 60)	;1 minutes
(defvar *background-notifies-for-missing-handlers* t)
(defvar *background-notifies-for-wrong-handlers* t)
(defvar *redefinition-file-loading-timeout* (* 60 60 3))

;;; How soon to first notify if the type didn't get redefined.
(defvar *redefinition-initial-notify-timeout* (* 60 5))
;;; How often to notify if the type didn't get redefined.
(defvar *redefinition-repeat-notify-interval* (* 60 60))

(defflavor type-change
	(type					;Name of the type being changed
	 (start-time (get-universal-time))	;Time this change started
	 (time-last-warning)			;Time this change was last warned about
	 (warning-count 0)			;# of times this has been warned about
	 (warning-file sys:fdefine-file-pathname)	;File this occurred during loading
	 (status :incomplete))			;1:incomplete0, 1:pending-eof0,1 :completed,0 1:failed
0	()
  (:initable-instance-variables type)
  :readable-instance-variables
  (:writable-instance-variables status)
  (:constructor make-type-change (type)))

(defmethod (sys:print-self type-change) (stream print-depth slashify-p)
  (ignore print-depth)
  (labels ((body (stream)
	     (present type 'presentation-type :stream stream)
	     (write-string " (" stream)
	     (present status '(member :incomplete :pending-eof :completed :failed)
		      :stream stream)
	     (write-string ") started at " stream)
	     (present start-time 'time:universal-time :stream stream)
	     (write-char #\. stream)))
    (if slashify-p
	(printing-random-object (self stream :typep :no-pointer)
	  (body stream))
      (write-string "A change to the type " stream)
      (with-output-as-presentation (:object self :type (type-of self) :stream stream)
	(body stream)))))

(defun notify-or-error (format-string &rest format-args)
  (declare (dbg:error-reporter))
  (case *background-notifies-for-missing-handlers*
    ((:error) (apply #'cerror "Fix the problem and proceed." format-string format-args))
    ((:format) (apply #'format t format-string format-args))
    ((nil) nil)
    (otherwise (apply #'tv:notify nil format-string format-args))))

(defmethod (maybe-issue-type-change-warning type-change) (&key force stream)
  (let ((time (get-universal-time)))
    (labels ((tell (format-string &rest format-args)
	       (declare (dbg:error-reporter))
	       (let ((new-format-string
		       "~?~&~@
		        This may be forced to completion with the following form,~@
		        but the result may not be completely consistent.~@
		        ~'b~@\\PRESENTATION\\~")
		     (form `(dw:finish-type-redefinition ',type :force-p t)))
		 (if (not stream)
		     (notify-or-error new-format-string
				      format-string format-args
				      form 'sys:form)
		 (format stream new-format-string format-string format-args form)))
	       (incf warning-count)
	       (setf time-last-warning time))
	     (warn-p (initial-timeout)
	       (or force
		   (if (not time-last-warning)	;First time
		       ( (+ start-time initial-timeout) time)
		     ( (+ time-last-warning
			   (* warning-count *redefinition-repeat-notify-interval*))
			time)))))
      (ecase status
	((:completed :failed)
	 ;; Change is all done.  Remove it from the list.
	 ;; Should already be gone, but...
	 (with-good-lock (*handler-table-entries-possibly-changed* :write)
	   (setq *pending-type-changes* (delete self *pending-type-changes*))))
	(:pending-eof
	  (when (warn-p *redefinition-file-loading-timeout*)
	    ;; It's very old, & enqueued for rel-7 end-of-file handling
	    ;; Probably loading the file blew out, and it's still sitting in
	    ;; the debugger.
	    (tell "The file ~A is still in the process of loading.~@
		   ~A~@
		   Until the file completes loading, or is aborted, the mouse sensitivity~@
		   tables (and other things) will be inconsistent.  It is possible that this~@
		   type has been only partially defined, but the redefinition of this type~@
		   started ~@\\PRESENTATION\\ ago, so it is probably intact."
		  warning-file
		  self
		  (- time start-time) 'time:time-interval)))
	(:incomplete
	  (when (warn-p *redefinition-initial-notify-timeout*)
	    ;; It's old, & never enqueued any end-of-file processing.  May be rel-7.2 and
	    ;; was aborted, or might be 7.1 and never got that far.
	    (let ((deftype-file
		    (or warning-file
			(si:get-source-file-name type 'deftype nil t)))
		  (presentation-type-file
		    (or warning-file
			(si:get-source-file-name type 'define-presentation-type nil t))))
	      (tell "~:[~*~;While loading file ~A:~%~]~
		   ~A~@
		   Until this definition is completed, the type,~@
		   and the mouse sensitivity tables will be inconsistent.~@
		   It is suggested you first retry the definition, to try~@
		   to install a complete definition for the type.  If that~@
		   is successful, you will need to force the type to completion~@
		   manually, as shown below.~:[~@
		   (This type is not defined in any file.)~*~*~*~;~@
~@
		   This type definition should be found in the file~P~@
		   ~A~:[~; and ~A~].~]"
		    warning-file warning-file
		    self
		    (or deftype-file presentation-type-file)
		    (if (and deftype-file presentation-type-file
			     (neq deftype-file presentation-type-file))
			2 1)
		    (or deftype-file presentation-type-file)
		    (and deftype-file presentation-type-file
			 (neq deftype-file presentation-type-file))
		    presentation-type-file)))))))
  (when force
    ;; About to disk-save.  When we come back up, start the sequence over again.
    (setf warning-count 0)))

;;; This datastructure should be merged with the one above, since they are managed
;;; exactly in parallel.  But this wouldn't be a minimal change just before a release,
;;; so we won't do it right now.

(defflavor type-redefinition-info
	(type-name				;Name of the type being redefined
	 (definers nil)				;Processes redefining.
	 table)					;Table of handler-table entries
	()
  (:initable-instance-variables type-name)
  (:readable-instance-variables type-name table)
  (:constructor make-type-redefinition-info (type-name)))

(defmethod (make-instance type-redefinition-info) (&rest ignore)
  (unless (variable-boundp table)
    (setq table
	  (make-hash-table :test #'fringe-eql :hash-function #'fringe-eql-hash
			   :mutating nil	;Get around table system's bug
			   :locking nil))))

(defmethod (sys:print-self type-redefinition-info) (stream ignore ignore)
  (sys:printing-random-object (self stream :typep)
    (format stream
	    "~S (~D entr~@:P, ~:[forced to completion~;~:[no~*~;~D~] definer~:P active~])"
	    type-name
	    (hash-table-count table)
	    (neq definers :force)
	    definers
	    (when (neq definers :force)
	      (length definers)))))


;;; Must be called with 1*handler-table-entries-possibly-changed*0 locked for write.
(defmethod (note-redefinition type-redefinition-info) ()
  (when (eq definers :force)
    ;; We've been forced to completion, but a new definition is starting.
    ;; Anything old which tries to finish after this point will error.
    (setq definers nil))
  (push *current-process* definers))

;;; Must be called with 1*handler-table-entries-possibly-changed*0 locked for write.
;;; Returns non-null iff the caller gets to do the finishing.
;;; This will return 1:force0 if completion was forced.  However, we don't actually
;;; do anything with that, prefering to have any old pending redefiners get an error
;;; if they ever do complete.  After all, if they did finally do any further definition,
;;; they would need the redefinition info, which is long gone.  (I suppose we could have
;;; made a copy of it to bring back in that case, but it doesn't seem worth it.)

(defmethod (finish-redefinition type-redefinition-info) ()
  (if (eq definers :force)			;It's been forced to completion
      :force
    (unless (member *current-process* definers)
      (error "This process is attempting to finish redefining type ~S.~@
	      This type is being redefined by ~{~A~^, ~}."
	     type-name
	     definers))
    (setq definers
	  (delete *current-process* definers :count 1))
    (null definers)))


;;; Force this redefinition to be completed by the next 1dw:finish-type-redefinition0.
(defmethod (force-redefinition-complete type-redefinition-info) ()
  (setq definers :force)
  t)

(compile-flavor-methods type-change type-redefinition-info)

(defun warn-about-incomplete-type-changes ()
  (with-good-lock (*handler-table-entries-possibly-changed* :write)
    ;; 1:write0, because notifying modifies the entries on 1*pending-type-changes*0.
    (dolist (type-change *pending-type-changes*)
      (maybe-issue-type-change-warning type-change :force t :stream *standard-output*))))

(add-initialization "Warn about incomplete type changes" '(warn-about-incomplete-type-changes)
		    '(:before-cold))


;;; Build a table of current handler table entries for this type, so we can update the
;;; table afterwards.
;;; The locking order:
;;;  1)  The changes table (1:write0)
;;;    2)  The handlers-affected-by-types table (1:write0)
;;;      3)  The handler table (1:write0)

(defvar *defer-type-change-processing* t)	;Cleared later in the loading process.

(defun prepare-for-type-change (type)
  (unless *defer-type-change-processing*
    (with-good-lock (*background-process-lock* :read)
      ;; Start the background-process's timeout for changes.
      (without-interrupts
	(setq *pending-type-changes*
	      (delete type *pending-type-changes* :key #'type-change-type))
	(push (make-type-change type) *pending-type-changes*))
      (let ((state :search)
	    (table)
	    (new nil))
	(with-good-lock (*handler-table-entries-possibly-changed* :write)
	  (let ((entry (gethash type *handler-table-entries-possibly-changed*)))
	    (unless entry
	      (setf new t)
	      (setf entry (make-type-redefinition-info type)))
	    ;; Already have changes pending?  If so, merge with them, else make a new table
	    (setq table (type-redefinition-info-table entry))
	    (note-redefinition entry)
	    (with-good-lock (*handlers-affected-by-types-table* :read)
	      (with-good-lock (*presentation-type-mouse-handler-table* :write)
		(tv:dolist-noting-progress (handler-name
					     (gethash type *handlers-affected-by-types-table*)
					     (format nil
						     "Recording handler table entries for ~A"
						     type))
		  (dolist (handler (gethash handler-name *presentation-mouse-handlers-table*))
		    (labels ((check-state (expanded-type)
			       (or (eq state :found)
				   (when (or (eql expanded-type type)
					     (eql (presentation-type-name expanded-type) type))
				     (setq state :found)
				     t)))
			     (check-missing (string table key)
			       (unless table
				 (notify-or-error
				   "For type ~@\\PRESENTATION\\:~@
				Missing ~A for ~@\\PRESENTATION\\, under key ~S.~@
				It should fix itself when the type~@
				finishes redefinition.  Please report this."
				   type 'presentation-type-name
				   string handler 'presentation-mouse-handler key))))
		      (let ((context-type 
			      (presentation-mouse-handler-context-presentation-type handler)))
			(when (eql context-type t)
			  (setq context-type nil))
			(map-over-type-hierarchy context-type t nil
			   (lambda (context-type context-key context-predicate)
			     (ignore context-predicate)
			     (check-state context-type)
			     (let ((displayed-table
				     (gethash context-key
					      *presentation-type-mouse-handler-table*))
				   (displayed-type
				     (presentation-mouse-handler-displayed-presentation-type
				       handler)))
			       #||
			       ;; Don't do this, because we would then have to lock the table
			       ;; for write for the entire thing.  We can't just get the when
			       ;; we need it; that would be a source of deadlocks.  We'll let
			       ;; the ones that do write lock the table do the update.
			       (unless displayed-table
				 (check-missing "displayed-type table"
						displayed-table context-key)
				 (setf displayed-table
				       (make-handler-table-internal-table context-type))
				 (setf (gethash (copy-tree context-key *handler-dynamic-area*) 
						*presentation-type-mouse-handler-table*)
				       displayed-table)) ||#
			       (when displayed-table
				 (map-over-type-hierarchy displayed-type nil nil
				    (lambda (displayed-type displayed-key displayed-predicate)
				      (check-state displayed-type)
				      (macrolet ((simple (type)
						   `(cond ((atom ,type) ,type)
							  ((atom (car ,type)) ,type)
							  (t (car ,type)))))
					(let ((entry-list (gethash displayed-key
								   displayed-table))
					      (entry (create-handler-table-entry
						       handler
						       displayed-predicate
						       (simple context-type)
						       (simple displayed-type))))
					  (unless (member entry entry-list)
					    (check-missing "table entry" nil displayed-key)
					    #||
					    ;; Don't do this.  It would mean locking the table
					    ;; for write for the entire duration, if deadlocks
					    ;; are to be avoided.  Besides, this put it in the
					    ;; wrong area (it forgot to call
					    ;; 1create-handler-table-list0)
					    ;; (Also, it would need to update the
					    ;; 1*handlers-affected-by-types-table*0).
					    (push entry entry-list)
					    ;; Grab the outer write-lock while we frob the
					    ;; inner table.
					    (with-good-lock
					      (*presentation-type-mouse-handler-table* :write)
					      (setf (gethash displayed-key displayed-table)
						    entry-list))
					    ||#
					    )
					  (when (eq state :found)
					    (let ((key `(,(copy-tree (simple context-key))
							 ,(copy-tree (simple displayed-key)))))
					      (setf (gethash key table) entry))))))
				   nil)))))))))))
	    ;; Probably this should be done above when the entry is created, but
	    ;; I don't want to change it close to a release.  --RWK
	    (setf (gethash type *handler-table-entries-possibly-changed*) entry)
	    new))))))


;;; Finish the redefinition of a type, with error-checking and recovery for missing
;;; type-redefinition info.

(defun finish-type-redefinition (type &key (error-p t) force-p)
  (sys:without-aborts ("The type ~@\\PRESENTATION\\ is being redefined.  Aborting now will~@
			leave the mouse handler tables inconsistent, and will result in~@
			notifications until the definition is completed by hand."
		       type 'presentation-type-name)
    (unless *defer-type-change-processing*
      (if (and (not *update-types-incrementally*)
	       (not force-p))
	  (inhibit-style-warnings
	    (invalidate-type-handler-tables))
	(when force-p
	  (setq error-p nil))
	(block info-missing
	  (with-good-lock (*handler-table-entries-possibly-changed* :write)
	    (let ((redefinition-info (gethash type *handler-table-entries-possibly-changed*)))
	      (when error-p
		;; Except in Release 7.1.5, we want to signal an error if
		;; we don't find the table.
		(unless redefinition-info
		  ;; *** Massive kludge: c-sh-C evaluates each form twice!
		  (unless (and (variable-boundp compiler:qc-file-load-flag)
			       compiler:qc-file-load-flag)
		    (return-from info-missing))))
	      (if (null redefinition-info)
		  (return-from info-missing)
		(when force-p
		  ;; Forget about all those pending 
		  (force-redefinition-complete redefinition-info))
		(return-from finish-type-redefinition
		  (merge-changes-for-type type))))))
	;; Signal the error here, with the lock unlocked!
	(cerror "Proceed, as if the type were new.  May leave stale mouse handlers."
		"Cannot finish redefining type ~S; redefinition info missing."
		type)
	(prepare-for-type-change type)
	(finish-type-redefinition type)))))

;;; Update the table with the changes to 2type0.
;;; The locking order:
;;;  1)  The changes table (1:write0)
;;;    2)  The handlers-affected-by-types table (1:write0)
;;;      3)  The handler table (1:write0)

(defun merge-changes-for-type (type)
  (unless *defer-type-change-processing*
    (let ((table)
	  (desc)
	  (entry))
      (block failed
	(with-good-lock (*handler-table-entries-possibly-changed* :write)
	  ;; Look while we have the lock, but scope it outside, so the
	  ;; 1cerror0 cal look at it.
	  (setq entry (gethash type *handler-table-entries-possibly-changed*))
	  (when (and entry
		     (finish-redefinition entry))
	    (setq table (type-redefinition-info-table entry)
		  desc (symbol-presentation-type-descriptor type))
	    (when desc
	      (fixup-cl-type-info desc))
	    (with-good-lock (*handlers-affected-by-types-table* :write)
	      (with-good-lock (*presentation-type-mouse-handler-table* :write)
	        (tv:dolist-noting-progress (handler-name
					     (gethash type
						      *handlers-affected-by-types-table*)
					     (format nil
						     "Merging changes to type ~A"
						     type))
		  (dolist (handler (gethash handler-name
					    *presentation-mouse-handlers-table*))
		    (merge-changes-for-handler type handler table)))
		(remove-orphan-handlers-for-type type table)
		(when (not (zerop (hash-table-count table)))
		  (return-from failed))
		(remhash type *handler-table-entries-possibly-changed*)))
	    (without-interrupts
	      (setq *pending-type-changes*
		    (delete type *pending-type-changes* :key #'type-change-type)))
	    (if (or desc table)
		(clear-type-handler-caches)
	      (clear-non-handler-caches)))
	  (return-from merge-changes-for-type type)))
      ;; Signal the error without the locks locked.
      (cerror "Proceed, possibly leaving stale handlers for ~*~S."
	      "Change table ~S for type ~S did not become empty."
	      table type))))

;;; Verify that all the relevant entries are in the table.  If missing, add them.
;;; If present, remove them from the table of entries needing processing.
;;; Must be called with the following tables write-locked (in order):
;;; 1*handler-table-entries-possibly-changed*
0;;; 1*handlers-affected-by-types-table*
0;;; 1*presentation-type-mouse-handlers-table*
0(defun merge-changes-for-handler (type handler table)
  (ignore type)
  (flavor::with-pending-dw-updates
    (labels ()
      (let ((handler-name (presentation-mouse-handler-name handler))
	    (context-type (presentation-mouse-handler-context-presentation-type handler))
	    (displayed-type (presentation-mouse-handler-displayed-presentation-type handler)))
	(when (eq context-type t)		;T means "be a subtype of everything
	  (setq context-type nil))
	(map-over-type-hierarchy context-type t nil
	   (lambda (context-type context-key context-predicate)
	     (ignore context-predicate)
	     (let ((displayed-table (gethash context-key
					     *presentation-type-mouse-handler-table*)))
	       (unless displayed-table
		 (setq displayed-table (make-handler-table-internal-table context-type))
		 (setf (gethash (copy-tree context-key *handler-dynamic-area*)
				*presentation-type-mouse-handler-table*)
		       displayed-table))
	       (map-over-type-hierarchy displayed-type nil nil
		  (lambda (displayed-type displayed-key displayed-predicate)
		    (macrolet ((simple (type)
				 `(cond ((atom ,type) ,type)
					((atom (car ,type)) ,type)
					(t (car ,type)))))
		      (let ((entry-list (gethash displayed-key displayed-table))
			    (entry (create-handler-table-entry
				     handler displayed-predicate
				     (simple context-type)
				     (simple displayed-type))))
			(unless (member entry entry-list)
			  (setf entry-list
				(delete-stale-handler-entries handler entry-list))
			  (labels ((note-handler (type)
				     (declare (sys:downward-function))
				     ;; If we're going to make an entry, make sure this
				     ;; flavor is composed (it's a flavor)
				     (with-type-decoded (type-name) type
					(compose-flavor-for-dw type-name handler-name)
					(pushnew handler-name
						 (gethash type-name
							  *handlers-affected-by-types-table*)
						 :area *handler-dynamic-area*
						 :localize t))))
			    (if (not (presentation-type-p displayed-type))
				(note-handler displayed-type)
			      (map-over-types-relevant-to-type displayed-type #'note-handler
							       displayed-type))
			    (if (not (presentation-type-p displayed-type))
				(note-handler context-type)
			      (map-over-types-relevant-to-type context-type #'note-handler
							       context-type)))
			  (setq entry-list
				(create-handler-table-list entry entry-list))
			  (setf (gethash (copy-tree displayed-key *handler-dynamic-area*)
					 displayed-table) entry-list))
			;; We saw this entry, so remove it from the table of changes
			;; so we don't remove it from the main table later as an orphan.
			(stack-let ((key `(,(simple context-key)
					   ,(simple displayed-key))))
			  (remhash key table)))))
		 nil))))))))


;;; This removes obsolete handlers, and reconses the entries to minimize paging.
(defun fix-up-handlers-affected-by-types-table ()
  (with-good-lock (*handlers-affected-by-types-table* :write)
    (labels ((valid-handler-name-p (handler-name)
	       (gethash handler-name *presentation-mouse-handlers-table*))
	     (fix-one-entry (key entry)
	       (setf (gethash key *handlers-affected-by-types-table*)
		     (copy-list (remove-if-not #'valid-handler-name-p entry)
				*handler-dynamic-area*))))
      (tv:maphash-noting-progress #'fix-one-entry *handlers-affected-by-types-table*
				  "Removing obsolete handler names"))))

;;; Remove from the table all the handler entries which weren't confirmed by
;;; the 1merge-changes-for-handler0 pass.
;;; Must be called with the following tables write-locked (in order):
;;; 1*handler-table-entries-possibly-changed*
0;;; 1*handlers-affected-by-types-table*
0;;; 1*presentation-type-mouse-handlers-table*
0(defun remove-orphan-handlers-for-type (type table)
  (labels ((error-if-not-found (string table key entry)
	     (unless table
	       (notify-or-error "No ~A was found under key ~S.~@
				 While removing orphans for ~@\\PRESENTATION\\,~@
				 for entry ~A.~@
				 One will be created.  Please report this problem."
				string key
				type 'presentation-type
				entry)))
	   (remove-entry (key entry)
	     (destructuring-bind (context-key displayed-key) key
	       (let ((displayed-table
		       (gethash context-key *presentation-type-mouse-handler-table*)))
		 (error-if-not-found "displayed table" displayed-table context-key entry)
		 (when displayed-table
		   (let ((handler-list (gethash displayed-key displayed-table)))
		     (error-if-not-found "handler list" handler-list displayed-key entry)
		     (when (member entry handler-list :test #'eq)
		       (setq handler-list (remove entry handler-list :test #'eq))
		       (setq handler-list (uniquify-handler-table-list handler-list))
		       (setf (gethash displayed-key displayed-table) handler-list))
		     (remhash key table))
		   ;; Possibly remove it from the table of handlers needing this type
		   (reconsider-handler type (handler-table-entry-handler entry)))))))
    (tv:maphash-noting-progress #'remove-entry table
				(format nil "Removing obsolete handler table entries for ~A"
					type))))

;;; This handler has just been removed from the table somewhere.
;;; Consider removing it from the table of handlers needing this type.
;;; write-locks 1*handlers-affected-by-types-table*
0(defun reconsider-handler (type handler)
  (with-good-lock (*handlers-affected-by-types-table* :write)
    (unless (block in-use
	      (labels ((check-in-use-1-type (expanded-type)
			 (declare (sys:downward-function))
			 (when (eq (presentation-type-name expanded-type) type)
			   (return-from in-use t)))
		       (check-in-use (expanded-type)
			 (map-over-types-relevant-to-type expanded-type #'check-in-use-1-type
							  expanded-type)))
		(let ((context-type
			(presentation-mouse-handler-context-presentation-type handler)))
		  (when (eql context-type t)
		    (setq context-type nil))
		  (map-over-type-hierarchy context-type t nil
		     (lambda (expanded-context ignore ignore)
		       (check-in-use expanded-context)
		       (map-over-type-hierarchy
				(presentation-mouse-handler-displayed-presentation-type
				  handler)
				  nil nil
			  (lambda (expanded-displayed-type ignore ignore)
			    (check-in-use expanded-displayed-type)) 
			 nil))))))
      (setf (gethash type *handlers-affected-by-types-table*)
	    (delete (presentation-mouse-handler-name handler)
		    (gethash type *handlers-affected-by-types-table*))))))


;;; +++ Need verify-random-entry-still-valid

;;; The locking order:
;;;  1)  The handlers-affected-by-types table (1:write0)
;;;    2)  The handler table (1:read0 on first pass, 1:write0 on second pass if need to modify)
;;;        The first pass, with read-lock, takes all the page faults, hence all the time.
(defun verify-handler-entry-in-table (handler)
  (with-good-lock (*handlers-affected-by-types-table* :write)
    (let ((handler-name (presentation-mouse-handler-name handler))
	  (context-type (presentation-mouse-handler-context-presentation-type handler))
	  (displayed-type (presentation-mouse-handler-displayed-presentation-type handler)))
      (flavor::with-pending-dw-updates
	(labels ((collect-types (type-name)
		   (declare (sys:downward-function))
		   (compose-flavor-for-dw type-name handler-name)
		   (pushnew (presentation-mouse-handler-name handler)
			    (gethash type-name *handlers-affected-by-types-table*))))
	  (when (eq context-type t)		;T means "be a subtype of everything"
	    (setq context-type nil))
	  (loop for mode = :read then :write as need-second-pass = nil do
	    (with-good-lock (*presentation-type-mouse-handler-table* mode)
	      (map-over-type-hierarchy context-type t nil
		 (lambda (context-type context-key context-predicate)
		   (ignore context-predicate)
		   (let ((displayed-table
			   (or (gethash context-key *presentation-type-mouse-handler-table*)
			       (and (eq mode :write)
				    (setf (gethash (copy-tree context-key
							      *handler-dynamic-area*)
						   *presentation-type-mouse-handler-table*)
					  (make-handler-table-internal-table context-type))))))
		     (map-over-type-hierarchy displayed-type nil nil
		       (lambda (displayed-type displayed-key displayed-predicate)
			 (macrolet ((simple (type)
				      `(cond ((atom ,type) ,type)
					     ((atom (car ,type)) ,type)
					     (t (car ,type)))))
			   (let ((entry-list (and displayed-table
						  (gethash displayed-key displayed-table)))
				 (entry (create-handler-table-entry	;interned
					  handler displayed-predicate
					  (simple context-type)
					  (simple displayed-type))))
			     (cond ((member entry entry-list))		;All okay
				   ((eq mode :read)
				    ;; Will need to run again.  But don't abort this pass,
				    ;; it's still doing useful work, paging stuff in.
				    (setq need-second-pass t))
				   (t
				    ;; This is the second pass, fix things up
				    (when *background-notifies-for-missing-handlers*
				      (heap-copy-presentation-type-if-necessary context-type)
				      (heap-copy-presentation-type-if-necessary displayed-type)
				      (labels ((print-abbreviated (val)
						 (abbreviating-output
						       (t :width 80
							  :newline-substitute " "
							  :show-abbreviation "...")
						   (princ val))))
					(notify-or-error
					  "An inconsistency was found in the mouse handler ~
						tables~@
					   ~@\\PRESENTATION\\ is missing from the table~@
					   at context = ~~@\\PRESENTATION\\~~@
					   and displayed = ~~@\\PRESENTATION\\~~@
					   Entry = ~vQ,~@
					   Entry-list = ~vQ.~@
					   It will be automatically corrected."
					  handler 'presentation-mouse-handler
					  context-type 'presentation-type
					  displayed-type 'presentation-type
					  entry #'print-abbreviated
					  entry-list #'print-abbreviated)))
				    (unless (eq (presentation-type-name context-type)
						'no-type)
				      (map-over-types-relevant-to-type context-type
								       #'collect-types 
								       context-type))
				    (unless (eq (presentation-type-name displayed-type)
						'no-type)
				      (map-over-types-relevant-to-type displayed-type
								       #'collect-types
								       displayed-type))
				    (setq entry-list
					  (create-handler-table-list entry entry-list))
				    (setf (gethash (copy-tree displayed-key
							      *handler-dynamic-area*)
						   displayed-table)
					  entry-list))))))
		       nil)))))
	    while need-second-pass))))))

(defun verify-entire-handler-table ()
  (tv:dolist-noting-progress (handler *presentation-mouse-handlers*
				      "Verifying mouse handler table")
    (verify-handler-entry-in-table handler)))

#||
(defun make-background-orphan-checker ()
  (let ((top-level-array (make-array (list (table-size *presentation-type-mouse-handler-table*)
					   2)))
	(top-level-array-fill 0)
	(top-level-index 0)
	(subtable-array (make-array '(30 2)))
	(subtable-array-limit 0)
	(subtable-index 0)
	(table-entry-index 0))
    (labels ((check-top-level-array-full ()
	       (when ( top-level-array-fill (array-dimension top-level-array 0))
		 (setq top-level-array
		       (make-array (list (ceiling (* top-level-array-fill 1.3)) 2)))))
	     (enter-top-level-array (key value)
	       (check-top-level-array-full)
	       (setf (aref top-level-array top-level-array-fill 0) key
		     (aref top-level-array top-level-array-fill 1) value)
	       (incf top-level-array-fill))
	     (refill-top-level-array ()
	       (setf top-level-array-fill 0)
	       (setf top-level-index 0)
	       (maphash #'enter-top-level-array *presentation-type-mouse-handler-table*))
	     (check-subtable-array-full ()
	       (when ( subtable-array-fill (array-dimension subtable-array 0))
		 (setq subtable-array
		       (make-array (list (ceiling (* subtable-array-fill 1.3)) 2)))))
	     (enter-subtable-array (key value)
	       (check-subtable-array-full)
	       (setf (aref subtable-array subtable-array-fill 0) key
		     (aref subtable-array subtable-array-fill 1) value)
	       (incf subtable-array-fill))
	     (refill-subtable-array ()
	       (setf sutable-array-fill 0
		     subtable-array-index 0)
	       (incf top-level-index)
	       (when ( top-level-index top-level-array-fill)
		 (refill-top-level-array)))
	     (get-table-entry ()
	       (incf index) ...)))))
||#

;;; The locking order:
;;;  1)  The changes table (1:read0)
;;;    2)  The handlers-affected-by-types table (1:write0)
;;;      3)  The handler table (1:write0)

(defun background-type-update-process ()
  (let ((handler-number 0))
    (labels ((verify-one-handler-or-notify ()
	       ;; Lock the handler-table entries possibly changed, as proxy for
	       ;; 1*pending-type-changes*0.
	       (with-good-lock (*handler-table-entries-possibly-changed* :read)
		 (if (null *pending-type-changes*)
		     (verify-one-handler)
		   ;; We can't verify anything if there's pending changes.
		   ;; We 2especially0 can't 2fix0 anything!
		   (dolist (type-change *pending-type-changes*)
		     (maybe-issue-type-change-warning type-change)))))

	     (verify-one-handler ()
	       (let ((length (length *presentation-mouse-handlers*))
		     (handler (nth handler-number *presentation-mouse-handlers*)))
		 (incf handler-number)
		 (when ( handler-number length)
		   (setq handler-number 0))
		 (verify-handler-entry-in-table handler)))

	     (type-update-request ()
	       (not (null *background-update-queue*))))

      (error-restart (abort "Restart with next request")
	(error-restart (error "Restart with empty queue")
	  (loop do
	    (process:process-block-with-timeout
	      *background-update-check-interval* "Type update" #'type-update-request)
	    (with-good-lock (*background-process-lock* :write)
	      (let ((request (without-interrupts (pop *background-update-queue*))))
		(when request
		  (funcall request)))
	      (verify-one-handler-or-notify))))
	  (setq *background-update-queue* nil)))))

(defvar *type-background-process* nil)

(defun run-background ()
  (setq *type-background-process*
	(process:make-process "Type definition background"
			      :initial-function #'background-type-update-process
			      :priority (process:make-process-priority :foreground -1)
			      :warm-boot-action 'process::process-warm-boot-delayed-restart
			      :system-process t)))

;;; We won't start up the background until we start doing incremental updates.
;;; We don't have 1get-universal-time0 yet.

(defun remove-handler-from-table (handler)
  (let ((context-type (presentation-mouse-handler-context-presentation-type handler))
	(displayed-type (presentation-mouse-handler-displayed-presentation-type handler)))
    (when (eq context-type t)			;T means "be a subtype of everything
      (setq context-type nil))
    (with-good-lock (*presentation-type-mouse-handler-table* :write)
      (map-over-type-hierarchy context-type t nil
	 (lambda (ignore subkey ignore)
	   (let ((displayed-subtable (gethash subkey *presentation-type-mouse-handler-table*)))
	     (when displayed-subtable
	       (map-over-type-hierarchy displayed-type nil nil
		  (lambda (ignore subkey ignore)
		    (let ((handlers (gethash subkey displayed-subtable)))
		      (flet ((handler-name (handler)
			       (when (consp handler)
				 (setq handler (car handler)))
			       (presentation-mouse-handler-functions-name
				 (presentation-mouse-handler-handler-functions handler))))
			(when handlers
			  (setf (gethash subkey displayed-subtable)

				(delete (handler-name handler) handlers
					:key #'handler-name))))))
		 nil t))))))))

;;; Callers need 1(declare (sys:downward-function))0, since it's too hard to coerce this
;;; into having the right declaration.
(defmethod-type-descriptor (map-over-types-relevant-to-type presentation-type-descriptor)
			   (function type)
  (if (atom type)
      (funcall function type)
    (with-type-decoded (type-name data-args) type
       (funcall function type-name)
       (when presentation-type-arguments
	 (let ((no-more nil)
	       (parameters data-args))
	   (labels ((recurse (type)
		      (if (atom type)
			  (funcall function type)
			(map-over-types-relevant-to-type type function type)))
		    (collect (arg state)
		      (setq arg (first arg))	;Why is 1lt::map-over-lambda-list0 nuts?
		      (when no-more
			(error "~S seen after a ~S argument declared with ~S.~@
				    This is illogical -- keywords aren't presentation types."
			       '&key '&rest :presentation-type-arguments))
		      (let ((arg-name (lt::arg-name arg)))
			(ecase state
			  ((:required :optional)
			   (if (not (member arg-name presentation-type-arguments))
			       (pop parameters)
			     (recurse (pop parameters))))
			  (:rest
			    ;; &rest doesn't remove parameters
			    (when (member arg-name presentation-type-arguments)
			      (mapc #'recurse parameters)
			      (setq no-more t)))
			  (:key
			    (let* ((key (lt::key-key-name arg))
				   (val (getf parameters key)))
			      (when val
				(recurse val))))))))
	     (lt::map-over-lambda-list (first arglist)	;Only data-args matter to table
				       #'collect))))))
  nil)

;;; Optimize both levels of the table, plus each handler list.
(defun optimize-handler-table (&optional (ctable *presentation-type-mouse-handler-table*)
					 (phase 1) (n-phases 1))
  (let ((numerator (hash-table-count ctable))
	(denominator 0))
    (with-good-lock (ctable :write)
      (maphash
	(lambda (ckey dtable)
	  (tv:note-progress-in-phases (incf numerator) denominator phase n-phases)
	  (setf (gethash ckey ctable) (follow-structure-forwarding dtable))
	  (maphash
	    (lambda (dkey handler-list)
	      (ignore dkey handler-list)
	      (setf *handler-table-top-level-list-cache-events*
		    (%32-bit-plus 1 *handler-table-top-level-list-cache-events*))
	      (multiple-value-bind (ignore found-p canonical-list)
		  (gethash handler-list *handler-table-top-level-list-cache*)
		(unless found-p
		  (setf *handler-table-top-level-list-cache-misses*
			(%32-bit-plus 1 *handler-table-top-level-list-cache-misses*)
			canonical-list
			(copy-list handler-list *handler-lists-area*)
			(gethash canonical-list *handler-table-top-level-list-cache*)
			canonical-list))
		(setf (gethash dkey dtable) canonical-list)))
	    dtable))
	ctable))))

(defun fill-handler-table (&optional (table *presentation-type-mouse-handler-table*))
  (with-good-lock (table :write)
    (let* ((priority (process-priority *current-process*))
	   (note (if (< priority 0)
		     "Updating mouse sensitivity table in background"
		   "Updating mouse sensitivity table in foreground")))
      (tv:noting-progress (note)
	(let ((n-phases 3))
	  (fix-all-presentation-types 1 n-phases)
	  (loop with denominator = (length *presentation-mouse-handlers*)
		with numerator = 0
		for handler in *presentation-mouse-handlers*
		do (tv:note-progress-in-phases (incf numerator) denominator 2 n-phases)
		   (enter-handler-in-table-with-predicates handler table nil))
	  (optimize-handler-table table 3 n-phases))))))


(defvar *type-handler-tables-valid-tick* 0)
(defvar *type-tick* 0)
(defvar *type-handler-tables-lock* (process:make-lock "Type Handler Tables Lock" :recursive t))
(defvar-resettable *type-handler-tables-update-process* nil)


;;; This wouldn't appear to need a CONTINUATION argument, but take one anyway
;;; for more flexibility in patching.
(defun with-type-handler-tables-valid-internal (continuation)
  (declare (sys:downward-funarg continuation))
  (when (zerop si:*inhibit-lengthy-background-updates*)
    (with-type-handler-tables-valid-internal-1))
  ;; The continuation is done without the lock held.
  (funcall continuation))

(defun with-type-handler-tables-valid-internal-1 ()
  (process:with-lock (*type-handler-tables-lock*)
    (unless (or *update-types-incrementally*
		(eql *type-handler-tables-valid-tick* *type-tick*))
      (unless *type-handler-tables-update-process*
	(setq *type-handler-tables-update-process*
	      (process-run-function '(:name "Update type handler tables"
				      :priority -1)
		(lambda ()
		  (unwind-protect
		      ;; Temporary kludge until we flush this process
		      (let ((*handler-dynamic-area* *handler-ephemeral-area*))
			(update-handler-tables-immediately))
		    (setq *type-handler-tables-update-process* nil)))))))))

(si:define-postponed-lengthy-background-update
  (with-type-handler-tables-valid-internal-1))

(defun update-handler-tables-immediately ()
  (si:with-ephemeral-migration-mode :collect
    ;; Lock out any attempt to modify the old table.  Lock the changed-entries table
    ;; to try to keep anyone from even trying to wait to write on the old one.
    (with-good-lock (*handler-table-entries-possibly-changed* :write)
      (with-good-lock (*presentation-type-mouse-handler-table* :read)
	(let ((tick *type-tick*)
	      (new-table (make-good-table :test #'fringe-eql
					  :hash-function #'fringe-eql-hash
					  :store-hash-code t
					  :name "Mouse handler table")))
	  (with-good-lock (new-table :write)
	    (fill-handler-table new-table)
	    (process:with-lock (*type-handler-tables-lock*)
	      (setq *presentation-type-mouse-handler-table* new-table)
	      ;; Do the SETQ above before the cache-clearing below, so the caches
	      ;; can only get the new stuff.
	      (clear-type-handler-caches)
	      (setq *pending-type-changes* nil)
	      (clrhash *handler-table-entries-possibly-changed*)
	      (setq *background-update-queue* nil)
	      (setq *type-handler-tables-valid-tick* tick))))))))

(defmacro with-type-handler-tables-valid (&body body)
  `(with-type-handler-tables-valid-internal
     (lambda () ,@body)))



;;; Tasks done:
;;; *presentation-mouse-handlers*
;;;     It's a list of structures of type presentation-mouse-handler
;;;	copy the structures into *handler-area*; compact the list in w-s-a
;;;	copy each handler's h-f immediately after the handler, if not yet copied.
;;;	copy the plists of for each presentation-mouse-handler into *handler-area*
;;;	copy the type lists (trees) for each presentation-mouse-handler
;;;  	  that is: context-presentation-type and displayed-presentation-type
;;;	  into *handler-area*
;;; *presentation-mouse-handler-functions*
;;;     It's a list of structures of type presentation-mouse-handler-functions
;;;	copy the structures into *handler-area*; compact the list in w-s-a
;;;	copy the tester-function for each presentation-mouse-handler-functions
;;;	  into *eql-dispatch-area* where all the other predicates go
;;;       2No, it doesn't.  (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")copy-predicate-into-area2 only copies closures, not
0;;;       3dtp-compiled-function2's.  --RWK
0;;; 	copy the h-f doc string (if it's a string) into *handler-area*; 
;;;	  use a unique copy of those which are string=
;;; Incf the type-tick, and call (set-up-type-handler-table) to do:
;;;    - recompute *presentation-type-mouse-handler-table*
;;;    - clear the various caches
;;; 
;;; It is another task to unify the hte's (cache test-handler result; reduce working set)
;;; It is another task (related to hte unification) to better compute the composed predicates

(defun localize-presentation-mouse-handlers ()
  (macrolet ((copy-type (access)
	       `(setf ,access (heap-copy-presentation-type ,access *handler-area* 2)))
	     (with-hf-key ((key hf) &body body)
	       `(stack-let
		  ((,key
		    (list
		      (presentation-mouse-handler-functions-name ,hf)
		      (presentation-mouse-handler-functions-tester-function ,hf)
		      (presentation-mouse-handler-functions-value-function ,hf)
		      (presentation-mouse-handler-functions-documentation-or-function ,hf))))
		  ,@body)))
    (let ((hf-copied (make-hash-table :test #'equal))
	  (string-table (make-hash-table :test #'string=)))
      (dolist (handler *presentation-mouse-handlers*)
	(setq handler (follow-structure-forwarding handler))
	(let ((new-handler (copy-presentation-mouse-handler handler)))
	  (setf (presentation-mouse-handler-property-list new-handler)
		(copy-list (presentation-mouse-handler-property-list new-handler)
			   *handler-area*))
	  (copy-type (presentation-mouse-handler-context-presentation-type new-handler))
	  (copy-type (presentation-mouse-handler-displayed-presentation-type new-handler))
	  ;; We need the following hair because some handlers share m-h-functions
	  ;; (Also because earlier versions of this localizer may have duplicated hf's)
	  (let ((hf (presentation-mouse-handler-handler-functions new-handler)))
	    (setq hf (follow-structure-forwarding hf))
	    (with-hf-key (key hf)
	      (let ((new-hf (gethash key hf-copied)))
		(unless new-hf
		  (setq new-hf (copy-presentation-mouse-handler-functions hf))
		  (let ((doc (presentation-mouse-handler-functions-documentation-or-function
			       new-hf)))
		    (when (stringp doc)
		      (let ((new-string (gethash doc string-table)))
			(when (null new-string)
			  (setf new-string (copy-seq doc *handler-area*))
			  (setf (gethash doc string-table) new-string))
			(setf (presentation-mouse-handler-functions-documentation-or-function
				new-hf)
			      new-string))))
		  (setf (gethash (copy-tree key) hf-copied) new-hf)
		  (structure-forward hf new-hf))
		(setf (presentation-mouse-handler-handler-functions new-handler) new-hf))))
	  (structure-forward handler new-handler)))
      (labels ((redo-list (list finder)
		 (declare (sys:downward-funarg finder))
		 (let ((new-list (make-list (length list))))	;leave it in w-s-a
		   (mapl (sys:named-lambda replacer (new-tail old-tail)
			  (setf (first new-tail)
				(or (funcall finder (first old-tail))
				    (error "Replacing ~s with NIL" (first old-tail)))))
			 new-list list)
		   new-list)))
	(setq *presentation-mouse-handlers*
	      (redo-list *presentation-mouse-handlers* #'follow-structure-forwarding)
	      *presentation-mouse-handler-functions*
	      (redo-list *presentation-mouse-handler-functions*
			 (sys:named-lambda new-hf (hf)
			  (with-hf-key (key hf)
			    (or (gethash key hf-copied)
				(error "H-F not in table ~s" hf)))))))))
  ;; Completely rebuild the table, since its structures are all unforwarded.
  (tv:with-mouse-usurped
    (incf *type-tick*)
    (clrhash *presentation-type-mouse-handler-table*)
    ;; I guess the below is commented out on the theory that this is just being called as part
    ;; of some larger world-optimization, and that this rebuilding will be done soon
    ;; anyway, so the total lack of handlers in the meantime isn't important.
    ;; I guess the reason to 1clrhash0 the table in the meantime is so that we can
    ;; GC the old contents.  I presume this was intended to be called from a
    ;; 1:full-gc0 initialization, or some similar circumstance.
    ;;(set-up-type-handler-table)
    ))

;;; Handle frobbing less specific type-hierarchy types into the appropriate
;;; more specific type.
(defparameter *stand-ins-for-type-hierarchies* '(expression form code-fragment))

(defmacro with-type-hierarchy-for-stand-in ((displayed-type object-type) &body body)
  (let ((new-type (gensymbol "NEW-TYPE-")))
    `(stack-let ((,new-type `(and ,,displayed-type ,,object-type)))
       (with-type-decoded (displayed-type-name) ,displayed-type
	  (when (member displayed-type-name *stand-ins-for-type-hierarchies*)
	    (setq ,displayed-type ,new-type)
	    ;; But if it was 1sys:expression0, we optimize it to just the object type.
	    (when (eq displayed-type-name 'expression)
	      (setq ,displayed-type ,object-type))))
       ,@body)))

;;; This must be cleared when the types change, or when the handlers change
;;; Keys are (context-presentation-type displayed-presentation-type)
;;; Values are alists of (gesture . <list-of-handler-table-entries>)

(defvar *context-mouse-handlers-cache*
	(make-good-table :test #'fringe-eql :hash-function #'fringe-eql-hash
			 :area *handler-dynamic-area*
			 :store-hash-code t
			 :size 4000
			 :name "Context handler cache"))

(defvar *context-mouse-handlers-events* 0)
(defvar *context-mouse-handlers-misses* 0)

(defun presentation-context-mouse-handlers (object-type displayed-presentation-type context)
  ;; If displayed-presentation-type is no-type, then if object-type is anything
  ;; other than no-type, this is a text-displayed-presentation and there are never any
  ;; handlers for it, so return nil immediately.  Otherwise the blank-area handlers
  ;; would be sensitive here (they used to be suppressed via object-type).
  (when (or (eq displayed-presentation-type 'no-type)
	    (equal displayed-presentation-type '((no-type))))
    (unless (eq object-type 'no-type)
      (return-from presentation-context-mouse-handlers nil)))
  (with-type-hierarchy-for-stand-in (displayed-presentation-type object-type)
    (setf *context-mouse-handlers-events*
	  (%32-bit-plus 1 *context-mouse-handlers-events*))
    ;; Make sure the type system doesn't change while we're looking at it.
    (with-good-lock (*presentation-type-mouse-handler-table* :read)
      (let ((context-type (and context
			       (presentation-input-context-presentation-type context))))
	(with-key-for-cache (context-key context-type)
	  (with-key-for-cache (displayed-presentation-key displayed-presentation-type)
	    (with-stack-list (key context-key displayed-presentation-key)
	      (multiple-value-bind (handlers-alist found)
		  (gethash key *context-mouse-handlers-cache*)
		(if found handlers-alist
		  (setq handlers-alist
			(presentation-context-mouse-handlers-search
			  displayed-presentation-type
			  context-type))
		  (setf *context-mouse-handlers-misses*
			(%32-bit-plus 1 *context-mouse-handlers-misses*))
		  ;; Unfortunately, this puts the key after the alist; we'd like
		  ;; faulting on the key to bring in the alist!
		  (setf (gethash (copy-tree key *handler-alist-area*)
				 *context-mouse-handlers-cache*)
			handlers-alist)
		  handlers-alist)))))))))


(defun make-cache-entry (handler handler-predicate context-predicate)
  (setf *cache-entry-events*
	(%32-bit-plus 1 *cache-entry-events*))
  (when (and (not handler-predicate)
	     (not context-predicate))
    ;; Hurrah!  No need to page-fault on a list to get to the handler, and
    ;; best of all, no need to do a 1gethash0 at all to get this entry!
    (setf *cache-entry-single*
	  (%32-bit-plus 1 *cache-entry-single*))
    (return-from make-cache-entry
      handler))
  (multiple-value-bind (nil found-p entry)
      (stack-let ((key1 (list handler handler-predicate context-predicate))
		  (key2 (list handler handler-predicate)))
	(gethash (if context-predicate key1 key2) *cache-entry-cache*))
    (if found-p
	entry
      (setf *cache-entry-misses*
	    (%32-bit-plus 1 *cache-entry-misses*))
      (setq entry
	    (cond ;; both-predicates-nil case already handled above.
		  ((not context-predicate)
		   (setf *cache-entry-conses-saved*
			 (%32-bit-plus 1 *cache-entry-conses-saved*))
		   ;Save a cons
		   (list-in-area *cache-entry-area* handler handler-predicate))
		  (t (list-in-area *cache-entry-area*
				   handler handler-predicate context-predicate))))
      (setf (gethash entry *cache-entry-cache*) entry)
      entry)))



(defun copy-handler-alist-bucket (alist-bucket)
  (setf *handler-alist-bucket-events*
	(%32-bit-plus 1 *handler-alist-bucket-events*))
  (multiple-value-bind (nil found-p new-bucket)
      (gethash alist-bucket *handler-alist-bucket-cache*)
    (if found-p
	new-bucket
      (setf *handler-alist-bucket-misses*
	    (%32-bit-plus 1 *handler-alist-bucket-misses*))
      (setq alist-bucket
	    (copy-list alist-bucket *handler-alist-area*))
      (setf (gethash alist-bucket *handler-alist-bucket-cache*) alist-bucket)
      alist-bucket)))



#||
(defun display-mouse-handler-table-contents (displayed-presentation-type context-type)
  (when (eql context-type t)
    (setq context-type nil))
  (with-good-lock (*presentation-type-mouse-handler-table* :read)
    (map-over-type-hierarchy context-type t nil
       (lambda (context-type context-key context-predicate)
	 (let ((displayed-table
		 (gethash context-key *presentation-type-mouse-handler-table*)))
	   (if (not displayed-table)
	       (format-nothing-found context-type context-key
				     *presentation-type-mouse-handler-table*
				     "top-level context")
	     (map-over-type-hierarchy displayed-presentation-type nil nil
		(lambda (displayed-type displayed-key displayed-predicate)
		  (ignore displayed-predicate)
		  (with-indentation (*standard-output* 3)
		    (let ((alist (gethash displayed-key displayed-table)))
		      (if (not alist)
			  (format-nothing-found displayed-type displayed-key displayed-table
						"displayed-type")
			(format-handler-table-entry-list displayed-type
							 displayed-key
							 context-type
							 context-key
							 context-predicate
							 alist)))))))))
      nil))
  (format t "~&Done...")
  (values))

(defun format-nothing-found (type key table table-name)
  (fresh-line)
  (with-output-as-presentation (:object table :type 'expression)
    (present type 'presentation-type)
    (format t " [key = ~S] was not found in the ~A table" key table-name)))

(defun display-table-which-entry (displayed-type displayed-key
				  context-type context-key context-predicate)
  (labels ((label-table ()
	     (formatting-table (t)
	       (formatting-column (t)
		 (formatting-cell (t :align-x :right)
		   (write-string " "))
		 (formatting-cell (t :align-x :right)
		   (write-string "Type"))
		 (formatting-cell (t :align-x :right)
		   (write-string "Key"))
		 (formatting-cell (t :align-x :right)
		     (write-string "Predicate")))))
	   (body-table ()
	     (formatting-table (t)
	       (formatting-column-headings (t :underline-p t)
		 (dolist (col '("Context" "Displayed"))
		   (formatting-cell (t)
		     (write-string col))))
	       (formatting-row (t)
		 (formatting-cell (t)
		   (present context-type 'presentation-type))
		 (formatting-cell (t)
		   (present displayed-type 'presentation-type)))
	       (formatting-row (t)
		 (formatting-cell (t)
		   (prin1 context-key))
		 (formatting-cell (t)
		   (prin1 displayed-key)))
	       (formatting-row (t)
		 (formatting-cell (t)
		   (present context-predicate 'function))
		 (formatting-cell ())
		 (formatting-cell ())))))
  (surrounding-output-with-border (t :label-alignment :center)
    (formatting-table (t)
      (formatting-row (t)
	(formatting-cell (t)
	  (label-table))
	(formatting-cell (t)
	  (body-table)))))))

(defun format-handler-table-entry-list (displayed-type displayed-key
					context-type context-key context-predicate
					alist)
  (let ((width (send *standard-output* :inside-width)))
    (fresh-line)
    (surrounding-output-with-border (t :thickness 4 :gray-level .75
				       :label "Table Found"
				       :label-position :top
				       :label-separator-line t)
      (formatting-table (t)
	(formatting-row (t :single-column t)
	  (formatting-cell (t)
	    (display-table-which-entry displayed-type displayed-key
				       context-type context-key context-predicate)))
	#+ignore
	(formatting-row (t :single-column t)
	  (formatting-cell (t)
	    (graphics:with-room-for-graphics (t 6 :fresh-line nil)
	      (graphics:draw-line 0 6 width 6))))
	(formatting-column-headings (t :underline-p t)
	  (dolist (col '("Handler" "Predicate" "Displayed type" "Context type"))
	    (formatting-cell (t)
	      (write-string col))))
	#+ignore
	(formatting-row (t :single-column t)
	  (formatting-cell (t)
	    (graphics:with-room-for-graphics (t 6 :fresh-line nil)
	      (graphics:draw-line 0 6 width 6))))
	(loop for entry in alist
	      do
	  (with-output-as-presentation (:stream *standard-output*
					:single-box t
					:object entry
					:type 'expression)
	    (formatting-row (t)
	      (formatting-cell (t)
		(present (handler-table-entry-handler entry)))
	      (formatting-cell (t)
		(present (handler-table-entry-predicate entry)
			 'function))
	      (formatting-cell (t)
		(present (handler-table-entry-displayed-type entry) 'presentation-type))
	      (formatting-cell (t)
		(present (handler-table-entry-context-type entry) 'presentation-type)))
	    (formatting-row (t :single-column t)
	      (formatting-cell (t)
		(write-string "")
		(graphics:with-room-for-graphics (t 6 :fresh-line nil)
		  (graphics:draw-line 0 6 width 6
				      :gray-level .25
				      :thickness 1)))))))
      (terpri) (terpri))))

||#

;;; Lookup the handlers for an object type, a presented type, and a context type.
;;; The result is not cached (that's the caller's job; see e.g.
;;; 1presentation-context-mouse-handlers0), but the consing done *is*.

;;; This canonicalizes the ordering of its return value to help maximize
;;; sharing.

(defun presentation-context-mouse-handlers-search (displayed-presentation-type context-type)
  (let ((handlers-alist))
    (macrolet ((non-t-handler-p (handler)
		 `(neq (presentation-mouse-handler-displayed-presentation-type ,handler)
		       t))
	       (mouse-char (handler-entry)
		 `(let ((gesture (presentation-mouse-handler-gesture
				   (handler-table-entry-handler ,handler-entry))))
		    (if (or (null gesture) (eq gesture t))
			gesture
			(mouse-char-for-gesture gesture))))
	       (bucket-best (bucket)
		 `(cadr ,bucket))
	       (bucket-worst (bucket)
		 `(cddr ,bucket))
	       (find-bucket (handler-entry)
		 `(let ((mouse-char (mouse-char ,handler-entry)))
		    (or (assoc mouse-char handlers-alist)
			(let ((bucket (list* mouse-char nil nil)))
			  (push bucket handlers-alist)
			  bucket)))))
      (with-good-lock (*presentation-type-mouse-handler-table* :read)
	(map-over-type-hierarchy context-type nil t
	   (lambda (context-subtype context-key context-predicate)
	     (declare (sys:downward-function)
		      (dbg:invisible-frame :presentation-handler-search))
	     (let ((displayed-subtable (gethash context-key
						*presentation-type-mouse-handler-table*)))
	       (when displayed-subtable
		 (map-over-type-hierarchy displayed-presentation-type t t
		    (lambda (displayed-supertype displayed-key predicate)
		      (declare (sys:downward-function)
			       (dbg:invisible-frame :presentation-handler-search))
		      (ignore predicate)
		      (let ((found-handlers (gethash displayed-key displayed-subtable)))
			;; We need to use the above ignored stuff to trim the list of
			;; found handlers.  Avoid doing the full hair unless the
			;; types we get from the handlers are actually lists.
			(loop for handler-entry in found-handlers
			      for bucket = (find-bucket handler-entry)
			      ;; This is a first cut at "conflict resolution" when
			      ;; multiple handlers apply: prefer an exact match
			      ;; over any other matches.
			      as handler-1 = (handler-table-entry-handler handler-entry)
			      as pred-1 = (handler-table-entry-predicate handler-entry)
			      unless
				(or (dolist (elt (bucket-best bucket))
				      (and
					(or (eq handler-1 (if (atom elt) elt
							    (first elt)))
					    (eq (presentation-mouse-handler-handler-functions
						  handler-1)
						(unless (atom elt)
						  (presentation-mouse-handler-handler-functions
						    (first elt)))))
					   (eq pred-1 (unless (atom elt)
							(second elt)))
					   (return t)))
				    (dolist (elt (bucket-worst bucket))
				      (and
					(or (eq handler-1 (if (atom elt) elt
							    (first elt)))
					    (eq (presentation-mouse-handler-handler-functions
						  handler-1)
						(unless (atom elt)
						  (presentation-mouse-handler-handler-functions
						    (first elt)))))
					   (eq pred-1 (unless (atom elt)
							(second elt)))
					   (return t))))
				do (let ((handler (handler-table-entry-handler
						    handler-entry)))
				     (when (handler-subtypep
					     (handler-table-entry-context-type handler-entry)
					     (handler-table-entry-displayed-type
					       handler-entry)
					     context-subtype context-key
					     displayed-supertype displayed-key)
				       (setq handler-entry
					     (make-cache-entry
					       handler
					       (handler-table-entry-predicate handler-entry)
					       context-predicate))
				       (if (non-t-handler-p handler)
					   (push handler-entry (bucket-best bucket))
					 (push handler-entry
					       (bucket-worst bucket))))))))))))
	  nil))
      (with-type-decoded (context-name) context-type
	(with-type-decoded (displayed-name) displayed-presentation-type
	  (macrolet ((context-type-name (handler)
		       `(with-type-decoded (type-name)
			      (presentation-mouse-handler-context-presentation-type ,handler)
			   type-name))
		     (displayed-type-name (handler)
		       `(with-type-decoded (type-name)
			      (presentation-mouse-handler-displayed-presentation-type ,handler)
			   type-name)))
	    (labels ((entry-lessp (entry-1 entry-2)
		       (declare (sys:downward-function))
			 ;;; These shouldn't really be list-based structures.
		       (let* ((handler-1 (if (atom entry-1) entry-1
					   (handler-cache-entry-handler entry-1)))
			      (context-1 (context-type-name handler-1))
			      (displayed-1 (displayed-type-name handler-1))
			      (handler-2 (if (atom entry-2) entry-2
					   (handler-cache-entry-handler entry-2)))
			      (context-2 (context-type-name handler-2))
			      (displayed-2 (displayed-type-name handler-2))
			      (priority-1 (getf (presentation-mouse-handler-property-list
						  handler-1)
						:priority 0))
			      (priority-2 (getf (presentation-mouse-handler-property-list
						  handler-2)
						:priority 0))
			      (handler-name-1
				(presentation-mouse-handler-functions-name
				  (presentation-mouse-handler-handler-functions handler-2)))
			      (handler-name-2
				(presentation-mouse-handler-functions-name
				  (presentation-mouse-handler-handler-functions handler-2))))
			 (macrolet ((match-priority (type-1 type-2 supplied-type increment)
				      `(with-type-decoded (name-1) ,type-1
					  (when (eql name-1 ,supplied-type)
					    (incf priority-1 ,increment))
					  (with-type-decoded (name-2) ,type-2
					     (when (eql name-2 ,supplied-type)
					       (incf priority-2 ,increment))))))
			   (match-priority context-1 context-2 context-name
					   *context-priority*)
			   (match-priority displayed-1 displayed-2 displayed-name
					   *displayed-priority*))
			 (or (> priority-1 priority-2)
			     (and (eql priority-1 priority-2)
				  (not (eql handler-name-1 handler-name-2))
				  (or (string-lessp handler-name-1 handler-name-2)
				      (and (string-equal handler-name-1 handler-name-2)
					   (string-lessp
					     (package-name (symbol-package handler-name-1))
					     (package-name (symbol-package handler-name-2))
					     ))))))))
						      
	      (loop for bucket in handlers-alist
		    do (setf (cdr bucket)
			     (nconc (sort (bucket-best bucket) #'entry-lessp)
				    (sort (bucket-worst bucket) #'entry-lessp))))))))
      ;; Share all our buckets
      (loop for bucket-ptr on handlers-alist
	    do (setf (car bucket-ptr)
		     (copy-handler-alist-bucket (car bucket-ptr))))
      ;; +++ This needs reconsidering now that we have preference hacking.
      ;; +++ Thank mechanism may be sufficient.
      ;; Prefer 1:gesture t 0handlers over all others,
      ;;  and make ones with :exclude-other-handlers the only thing there,
      ;;  and put gestures with only context-independent handlers at the end
      ;;  since find-innermost-sensitive-presentation has optimizations that assume this.
      (labels ((gesture-lessp (g1 g2)
		 (unless (eq g1 g2)
		   (cond ((eq g1 t) t)
			 ((eq g2 t) nil)
			 ((eq g1 nil) nil)
			 ((eq g2 nil) t)
			 ((not (and (mouse-char-p g1)
				    (mouse-char-p g2)))
			  (alphalessp g1 g2))
			 (t (< (dpb (si:mouse-char-bits g1) (byte 4 3)
				    (dpb (ldb (byte 1 4) (si:mouse-char-bits g1))
					 (byte 1 2)
					 (si:mouse-char-button g1)))
			       (dpb (si:mouse-char-bits g2) (byte 4 3)
				    (dpb (ldb (byte 1 4) (si:mouse-char-bits g2))
					 (byte 1 2)
					 (si:mouse-char-button g2))))))))
	       (handler-entry-lessp (x y)
		 (macrolet ((context-independent (h)
			      `(getf (presentation-mouse-handler-property-list
				       (if (atom ,h) ,h (handler-cache-entry-handler ,h)))
				     ':context-independent)))
		   (if (loop for h in (cdr x)
			     always (context-independent h))
		       ;; A context-independent gesture can only precede another such
		       (and (loop for h in (cdr y)
				  always (context-independent h))
			    (gesture-lessp (car x) (car y)))
		     ;; A context-dependent gesture precedes all context-independent ones
		     (or (loop for h in (cdr y)
			       always (context-independent h))
			 (gesture-lessp (car x) (car y)))))))
	;; Implement :exclude-other-handlers
	(let ((elem (assoc t handlers-alist)))
	  (when (and elem
		     (loop for h in (cdr elem)
			   thereis (getf (presentation-mouse-handler-property-list
					   (if (atom h) h (handler-cache-entry-handler h)))
					 ':exclude-other-handlers)))
	    (setq handlers-alist (list elem))))
	(setq handlers-alist
	      (sort handlers-alist #'handler-entry-lessp))
	;; Internalize the list, too.
	(setq handlers-alist
	      (copy-handler-alist-bucket handlers-alist))
	handlers-alist))))


(defmethod-type-descriptor (presentation-type-subtypep-function presentation-type-descriptor
								:search-p nil)
			   ()
  (when (variable-boundp presentation-subtypep)
    presentation-subtypep))

(defun handler-subtypep (handler-context handler-type
			 context-subtype context-key displayed-supertype displayed-key)
  (if (and (symbolp handler-context)
	   (symbolp handler-type))
      ;; Usual, simple case.  All are symbols, just compare for EQLness
      ;; we don't worry about the displayed-key or object-key being a list,
      ;; because if they are, the search will find us on the simpler key as well.
      (and (or (eql handler-context context-key)
	       (eql handler-context t))
	   (or (eql handler-type displayed-key)
	       (eql handler-type t)))
    (labels ((subtypep-compare (subtype subtype-key supertype supertype-key)
	       (with-type-decoded (supertype-name supertype-dargs) supertype
		 (with-type-decoded (subtype-name) subtype
		   (cond ((eq supertype-name t)
			  (return-from subtypep-compare t))
			 ((and (eq subtype-name supertype-name)
			       (null supertype-dargs))
			  t)
			 (t
			  (with-type-method ((subtype-type subtype-fun)
					     subtype #'presentation-type-subtypep-function
					     :error-p nil)
			    (with-type-method ((supertype-type supertype-fun)
					       supertype #'presentation-type-subtypep-function
					       :error-p nil)
			      (when (eq subtype-fun supertype-fun)
				(with-type-decoded (subtype-name subtype-dargs) subtype-type
				  (with-type-decoded (supertype-name supertype-dargs)
						     supertype-type
				    (return-from subtypep-compare
				      (stack-let ((subtype `(,subtype-name ,@subtype-dargs))
						  (supertype `(,supertype-name
							       ,@supertype-dargs)))
					(funcall subtype-fun subtype supertype))))))))
			  (when (eq subtype-name supertype-name)
			    (return-from subtypep-compare
			      (fringe-eql-subtypep subtype-key supertype-key)))
			  (map-over-type-hierarchy subtype t t
			   (sys:named-lambda map-over-type-hierarchy
					     (subtype subtype-key ignore)
			     (declare (dbg:invisible-frame :presentation-handler-search))
			     (with-type-decoded (subtype-name) subtype
			       (when (eq subtype-name supertype-name)
				 (return-from subtypep-compare
				   (fringe-eql-subtypep subtype-key
							supertype-key))))))
			  nil))))))
      (with-presentation-type-key (handler-context-key handler-context)
	(and (subtypep-compare handler-context handler-context-key
			       context-subtype context-key)
	     (with-presentation-type-key (handler-displayed-key handler-type)
	       (subtypep-compare displayed-supertype displayed-key
				 handler-type handler-displayed-key)))))))

(defun map-over-handler-alist-and-mouse-chars-in-context
       (presentation window handler-alist mouse-chars-to-match context function
	&optional ignore-nil-handlers)
  (declare (sys:downward-funarg function))
  (labels ((expunge-menu-handlers (array context)
	       ;; Remove all menu handlers whose tester fails.
	     (let ((array array))
	       (declare (sys:array-register array))
	       (loop with j = 0
		     for i below (fill-pointer array)
		     for handler-entry = (aref array i)
		     for handler = (if (consp handler-entry) (first handler-entry)
				     handler-entry)
		     do
		 (when (or (null presentation)	;So we can call it when debugging
			   (test-handler handler-entry presentation window context
					 (presentation-mouse-handler-gesture handler)
					 t))
		   (setf (aref array j) handler-entry)
		   (incf j))
		     finally
		       (setf (fill-pointer array) j)))))
    (macrolet ((do-all-gestures ((gesture mouse-char) &body body)
		 `(let ((name-array *gesture-name-array*)
			(char-array *gesture-name-array-char-array*))
		    (declare (array-register name-array char-array))
		    (dotimes (index (fill-pointer name-array))
		      (let ((,gesture (aref name-array index))
			    (,mouse-char (aref char-array index)))
			. ,body))))
	       (handler-entry-gesture (handler-entry)
		 `(let ((handler (if (atom ,handler-entry) ,handler-entry
				     (first ,handler-entry))))
		    (presentation-mouse-handler-gesture handler))))
      (if (eq mouse-chars-to-match t)
	  (loop for (mouse-char . handlers) in handler-alist do
	    (if (eq mouse-char t)
		(do-all-gestures (gesture mouse-char)
		  (dolist (handler handlers)
		    (funcall function handler gesture mouse-char t)))
		(dolist (handler handlers)
		  (funcall function handler (handler-entry-gesture handler)
			   mouse-char t))))
	(stack-let ((menu-handlers (make-array 32 :fill-pointer 0)))
	  (declare (sys:array-register menu-handlers))
	  (loop with nil-handlers = nil
		for (handler-mouse-char . handlers) in handler-alist
		do
	    (if (null handler-mouse-char)
		(unless ignore-nil-handlers
		  (setq nil-handlers handlers))	;Do these last
		(macrolet ((funcall-for-match (handler-entry gesture mouse-char)
			     `(progn
				;; First, if this is a menu handler, we need to remember
				;; it.  Pass it along to the mapping function, which might
				;; test it.  But we don't test it outselves yet.  If we're
				;; lucky, we won't ever need to look at it.
				(when (let ((handler (if (atom ,handler-entry) ,handler-entry
						       (first ,handler-entry))))
					(getf (presentation-mouse-handler-property-list
						handler)
					      :defines-menu))
				  (unless (%block-search-eq handler
							    (locf (aref menu-handlers 0))
							    (fill-pointer menu-handlers))
				    (vector-push-extend handler menu-handlers)))
				(funcall function ,handler-entry ,gesture ,mouse-char t))))
		  (if (eq handler-mouse-char t)
		      (do-all-gestures (gesture mouse-char)
			(when (member mouse-char mouse-chars-to-match)
			  (dolist (handler handlers)
			    (funcall-for-match handler gesture mouse-char))))
		      (if (not (member handler-mouse-char mouse-chars-to-match))
			  (dolist (handler handlers)
			    (funcall function handler
				     (handler-entry-gesture handler) handler-mouse-char nil))
			  (dolist (handler handlers)
			    (funcall-for-match handler (handler-entry-gesture handler)
					       handler-mouse-char))))))
		finally
		  (when nil-handlers
		    (expunge-menu-handlers menu-handlers context))
		  ;; Now that we've found all the menu handlers, we can process
		  ;; the handlers for :GESTURE NIL that might be in those menus
		  (loop for handler-entry in nil-handlers
			for handler = (if (atom handler-entry)
					  handler-entry
					(first handler-entry))
			for handler-plist = 
			    (presentation-mouse-handler-property-list handler)
			for handler-menu-type = (or (getf handler-plist :menu) t)
			do
		    (when (consp handler-menu-type)
		      (setq handler-menu-type (first handler-menu-type)))
		    (loop for i below (fill-pointer menu-handlers)
			  for menu-handler-entry = (aref menu-handlers i)
			  for menu-handler = (if (atom menu-handler-entry)
						 menu-handler-entry
					       (first menu-handler-entry))
			  for menu-handler-plist =
			      (presentation-mouse-handler-property-list menu-handler)
			  for defined-menu-type =
			      (getf menu-handler-plist :defines-menu)
			  do
		      ;;--- This really needs to check that this menu-handler
		      ;;--- either has its gesture apply, or appears in a menu
		      ;;--- who's gesture applies.
		      ;;--- We should also be handling gestures without character assignments.
		      (when (if (atom defined-menu-type)
				(eq handler-menu-type defined-menu-type)
			      (member handler-menu-type defined-menu-type))
			(funcall function handler-entry nil nil nil)
			(return))))))))))


(defun map-over-input-contexts (function &optional (top *presentation-input-context*))
  (declare (sys:downward-funarg function))
  (if (null top)
      (funcall function nil)
      (loop for context = top then (presentation-input-context-superior context)
	    until (null context) do
	;; Avoid duplicate contexts.  It isn't necessary to check the options here.
	;; Using EQ to compare presentation-types eliminates most duplicates,
	;; so it isn't worth using a slower predicate.
	(loop with ptype = (presentation-input-context-presentation-type context)
	      for c = top then (presentation-input-context-superior c)
	      until (eq c context)
	      when (eq (presentation-input-context-presentation-type c) ptype)
		return nil
	      ;; Not a duplicate, so call the funarg
	      finally (funcall function context)))))


(defun map-over-mouse-handlers (object-type-to-match displayed-presentation-type-to-match
				mouse-chars-to-match presentation window function
				&optional (context *presentation-input-context*))
  (declare (sys:downward-funarg function))
  (map-over-input-contexts
    (lambda (context)
      (declare (dbg:invisible-frame :presentation-handler-search))
      (let ((handler-alist (presentation-context-mouse-handlers
			     object-type-to-match displayed-presentation-type-to-match
			     context)))
	(map-over-handler-alist-and-mouse-chars-in-context
	  presentation window handler-alist mouse-chars-to-match context
	  (lambda (handler-entry gesture mouse-char gesture-match-p)
	    (declare (dbg:invisible-frame :presentation-handler-search))
	    (when gesture-match-p
	      (funcall function handler-entry context gesture mouse-char)))
	  t)))	;ignore-nil-handlers
    context))

;; Communications variable needed for cp:build-command to not blowout on
;; translators to program-commands.
(defvar-standard *inside-handler-test-phase* nil)

(defun test-handler (handler-entry presentation window context gesture mouse-char
		     &optional menu-item-found)
  (let* ((handler (if (atom handler-entry)
		      handler-entry
		    (handler-cache-entry-handler handler-entry)))
	 (*inside-handler-test-phase* t))
    (let ((object-tester (unless (atom handler-entry)
			   (handler-cache-entry-handler-predicate handler-entry))))
      (unless (or (null object-tester)
		  (funcall object-tester (presentation-object presentation)))
	(return-from test-handler (values nil 'object-predicate))))
    (let ((tester (presentation-mouse-handler-tester-function handler))
	  (value-function (presentation-mouse-handler-value-function handler))
	  (do-not-compose (getf (presentation-mouse-handler-property-list handler)
				:do-not-compose)))
      (multiple-value-bind (object object-type presentation-type)
	  (presentation-object-and-types presentation)
	(with-type-hierarchy-for-stand-in (presentation-type object-type)
	  (unless (or (null tester)
		      ;; If the tester and the value-function are the same function,
		      ;; and we'll run the value-function below, then don't bother
		      ;; running the tester
		      ;;--- RWK says that nobody should be using :TESTER T (that
		      ;;--- is, the case where the tester and the value-function
		      ;;--- are the same should not occur), but there appear to
		      ;;--- be a lot of translators which violate this.
		      ;;--- Straighten this out in Release 8.
		      (and (eq tester value-function) (not do-not-compose))
		      (funcall tester object :handler handler
			       :gesture gesture
			       :mouse-char mouse-char
			       :presentation presentation
			       :presentation-type presentation-type
			       :window window
			       :input-context context))
	    (return-from test-handler (values nil 'tester)))
	  (unless (or do-not-compose
		      (multiple-value-bind (object type)
			  (funcall value-function
				   object
				   ;;--- The next line is to keep 357 handlers working
				   ;;--- in the face of poorly formed arglists.
				   :allow-other-keys t
				   :handler handler
				   :gesture gesture
				   :mouse-char mouse-char
				   :presentation presentation
				   :presentation-type presentation-type
				   :window window
				   :input-context context)
			(when (and (null object) (null type))
			  (return-from test-handler (values nil 'value)))
			(let ((context-object-tester
				(unless (atom handler-entry)
				  (handler-cache-entry-context-predicate handler-entry))))
			  ;; This checks that the result applies, for instance, in a
			  ;; command translator, is the command in the current comtab
			  (or (null context-object-tester)
			      (funcall context-object-tester object)))))
	    (return-from test-handler (values nil 'context-predicate))))))
    (let ((defines-menu (unless menu-item-found
			  (getf (presentation-mouse-handler-property-list handler)
				:defines-menu))))
      (unless (or (null defines-menu)
		  (presentation-menu-p presentation window defines-menu context))
	(return-from test-handler (values nil 'menu))))
    t))

(zwei:defindentation (map-over-presentation-mouse-handlers-all 3 1))
(defun map-over-presentation-mouse-handlers-all (presentation window mouse-chars function
						 &optional
						   (context *presentation-input-context*))
  (declare (sys:downward-funarg function))
  (multiple-value-bind (object object-type displayed-presentation-type)
      (presentation-object-and-types presentation)
    (declare (ignore object))
    (map-over-mouse-handlers object-type displayed-presentation-type mouse-chars
			     presentation window
     (lambda (handler context gesture mouse-char)
       (declare (dbg:invisible-frame :presentation-handler-search))
       (funcall function handler context gesture mouse-char))
     context)))

(defun map-over-presentation-mouse-handlers (presentation window mouse-chars function)
  (declare (sys:downward-funarg function))
  (when (or (eq mouse-chars t)
	    (member (si:mouse-char-bits (first mouse-chars))
		    *describe-presentation-mouse-chars*)
	    (not (presentation-redisplay-place-holder presentation)))
    (map-over-presentation-mouse-handlers-all presentation window mouse-chars
      (lambda (handler-entry context gesture mouse-char)
	(declare (dbg:invisible-frame :presentation-handler-search))
	(when (test-handler handler-entry presentation window context gesture mouse-char)
	  (let ((handler (if (atom handler-entry) handler-entry (first handler-entry))))
	    (funcall function handler context gesture mouse-char)))))))

(si:define-gc-optimization cleanup-dw-tables :layered-system-release
  (:documentation "Clear DW meters and caches for the extent of the garbage collection")
  (:before-flip (ignore)
    ;; Clean up our static areas
    ;;   Clear various caches and meters, and make various static areas dynamic.
    ;;   We will rebuild some of the tables after the GC finishes, by parsing the areas
    ;;   in question.
    (with-good-lock (*background-process-lock* :write)
      (send *type-background-process* :arrest-reason 'cleanup-dw-tables))

    (verify-entire-handler-table)
    (fix-up-handlers-affected-by-types-table)
    (let ((areas))
  
      (clrhash *cache-entry-cache*)
      (setq *cache-entry-events* 0
	    *cache-entry-misses* 0
	    *cache-entry-single* 0
	    *cache-entry-conses-saved* 0)
      (push '*cache-entry-area* areas)
  
      (clrhash *handler-alist-bucket-cache*)
      (setq *handler-alist-bucket-events* 0
	    *handler-alist-bucket-misses* 0)
      (push '*handler-alist-area* areas)
  
      #+ignore ;; Don't do this until we flush the background-updator, just 1clrhash0 for now.
      (setq *handler-table-entry-cache*
	    (make-good-table :test #'handler-table-entry-equal
			     :hash-function #'handler-table-entry-hash
			     :store-hash-code t
			     :number-of-values 0
			     :name "HTE cache"))
      (clrhash *handler-table-entry-cache*)
      (setq *handler-table-presentation-type-non-events* 0
	    *handler-table-presentation-type-cache-events* 0)
  
      #+ignore ;; Don't do this until we flush the background-updator, just 1clrhash0 for now.
      (setq *handler-table-type-cache*
	    (make-good-table :test #'handler-table-type-equal
			     :hash-function #'handler-table-type-hash
			     :store-hash-code t
			     :number-of-values 0
			     :name "HTE type-list cache"))
      (clrhash *handler-table-type-cache*)
      (setq *handler-table-presentation-type-cache-misses* 0)
  
      (clrhash *handler-table-presentation-type-cache*)
      (setq *handler-table-presentation-type-non-events* 0
	    *handler-table-presentation-type-cache-events* 0
	    *handler-table-presentation-type-cache-misses* 0)
      (push '*handler-table-area* areas)
      
      (clrhash *handler-table-top-level-list-cache*)
      (setq *handler-table-top-level-list-cache-events* 0
	    *handler-table-top-level-list-cache-misses* 0)
      (push '*handler-lists-area* areas)
  
      (nreverse areas)))
  (:after-reclaim-oldspace (ignore)
    ;;   1*handler-alist-bucket-cache*0 and 1*cache-entry-cache*0:  Continuously in use
    ;;     and not huge.
    ;;   1*handler-table-entry-cache*0 and 1*handler-table-type-cache*0:  Temporary.
    ;;     These are large, but until we flush the background updater, we'll end
    ;;     up consing it all back immediately anyway, so doing this saves the time
    ;;     to do it later.  This eats up about 200 pages that otherwise wouldn't
    ;;     be there, or about the whole amount we saved, but we've improved locality
    ;;     and we will get this back soon.
    (labels ((reintern-objects-in-area (area cache &optional filter)
	       (labels ((reintern (ignore ignore object ignore ignore)
			  (when (or (null filter)
				    (funcall filter object))
			    (setf (gethash object cache) object))))
		 (si:map-over-objects-in-area area #'si:region-predicate-list
					      #'reintern)))
	     (handler-alist-p (object &optional recurse)
	       (and (listp object)
		    (or (null (car object))	;handlers on 1:gesture nil
0			(eq t (car object))	;handlers on 1:gesture0 1t
0			(typep (car object) 'si:mouse-char)
			(and (consp (car object))
			     (not recurse)
			     (handler-alist-p (car object) t)))))
	     (reintern-handler-area (ignore ignore object ignore ignore)
	       (when (listp object)
		 (etypecase (car object)
		   ((and atom presentation-mouse-handler)
		    (setf (gethash object *handler-table-entry-cache*) object))
		   ((or symbol cons)
		     (setf (gethash object *handler-table-type-cache*) object))))))
		    
      (reintern-objects-in-area *handler-alist-area* *handler-alist-bucket-cache*
				#'handler-alist-p)
      (reintern-objects-in-area *cache-entry-area* *cache-entry-cache*)
      (reintern-objects-in-area *handler-lists-area* *handler-table-top-level-list-cache*)
      (reintern-objects-in-area *handler-types-area* *handler-table-presentation-type-cache*)
      (si:map-over-objects-in-area *handler-table-area* #'si:region-predicate-list
				   #'reintern-handler-area)
      ;; We don't try to get back the handler-presentation-types
      (send *type-background-process* :revoke-arrest-reason 'cleanup-dw-tables)
      nil
      )))
