;;; -*- Mode: LISP; Syntax: Common-lisp; Package: DYNAMIC-WINDOWS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The guts of D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")accept0 and 1present

0;;;--- At a major system boundary, it is alright to change this to a position argument
;;; to the describer function.
(defvar-standard *describe-presentation-type-reason* nil)

(defun describe-presentation-type (type &optional (stream *standard-output*)
						  (plural-count nil)
						  (reason nil))
  (when (eql plural-count 1)
    (setq plural-count nil))
  (labels ((presentation-type-pretty-name-or-description (type)
	     (with-type-decoded (nil nil pr-args) type
		(or (getf pr-args :description)
		    (presentation-type-pretty-name type)))))
    (with-type-method ((present-type present-info handler-name predicate)
		       type #'presentation-type-pretty-name-or-description
		       ;; Suppress initial predicates (checked specially by
		       ;; 1map-over-type-hierarchy0)
		       :supertype-p 'describe-presentation-type)
      (ignore handler-name)
      (cond ((stringp present-info)
	     (presentation-string-pluralize present-info stream plural-count))
	    (t (flet ((doit (stream)
			(let ((*describe-presentation-type-reason* reason))
			  (funcall present-info stream
				   present-type
				   plural-count
				   type
				   ))))
		 (cond ((null plural-count) (doit stream))
		       ((si:debugging-info-user-entry present-info 'plural-count)
			(doit stream))
		       (t (presentation-string-pluralize
			    (with-output-to-string (ick)
			      (doit ick))
			    stream
			    plural-count))))))
      (when (and predicate (not (typep predicate 'lexical-closure)))
	(write-string " that satisfies " stream)
	(prin1 (sys:function-name predicate) stream)))))

(defun presentation-string-pluralize (string stream count)
  (cond ((null count)
	 (write-string string stream))
	(t
	 (let ((sl (string-length string)))
	   (cond ((< sl 3))
		 ((string-equal string "a " :end1 2)
		  (setq string (substring string 2)))
		 ((string-equal string "an " :end1 3)
		  (setq string (substring string 3))))
	   (cond ((numberp count)
		  (format stream "~R " count))
		 ((eq count t))
		 (t (write-string count stream)
		    (write-char #\Space stream)))
	   (write-string (string-pluralize string) stream)))))

(defun prompt-and-accept (presentation-type-or-args &optional format-string &rest format-args)
  ;; Simple cases first
  (flet ((prompter (stream &rest ignore)
	   (apply #'format stream format-string format-args)))
    (cond ((or (atom presentation-type-or-args)
	       (not (keywordp (car presentation-type-or-args))))
	   (if format-string
	       (accept presentation-type-or-args :query-identifier format-string
						 :prompt #'prompter)
	       (accept presentation-type-or-args)))
							    
	  (t (let ((presentation-type (or (getf presentation-type-or-args ':type)
					  (getf presentation-type-or-args ':presentation-type)
					  (error  "No presentation type supplied.")))
		   (prompt (getf presentation-type-or-args ':prompt)))
	       (if (and format-string prompt)
		   (error "Format string and prompt both supplied."))

	       (si:with-rem-keywords (args presentation-type-or-args
					   '(:type :presentation-type))
		 (cond (prompt (apply #'accept presentation-type :prompt prompt args))
		       (format-string (apply #'accept presentation-type
					     :query-identifier format-string
					     :prompt #'prompter args))
		       (t (apply #'accept presentation-type args)))))))))

;;; These two flavors' contract are blurred.
(defflavor object-parsed-not-of-type (object (write-keywords nil))
	   (sys:parse-error presentation-type-error-mixin)
  :gettable-instance-variables
  :initable-instance-variables)

(defflavor input-not-of-required-type (string)
	   (sys:parse-error presentation-type-error-mixin)
  :gettable-instance-variables
  :initable-instance-variables)

(defmethod (:report object-parsed-not-of-type) (stream)
  (write-string "The object read, " stream)
  (apply #'write object :stream stream write-keywords)
  (write-string ", was not " stream)
  (describe-presentation-type type stream)
  (write-char #\. stream))

(defmethod (:report input-not-of-required-type) (stream)
  (format stream "The input read, ~A, was not " (if (string-equal string "")
						    "\"\""
						    string))
  (if (null type)
      (format stream "of the appropriate type")
      (describe-presentation-type type stream))
  (write-char #\. stream))

(defflavor input-not-of-required-type-unless-control-return ()
	   (input-not-of-required-type))

(defmethod (:report input-not-of-required-type-unless-control-return :after) (stream)
  (format stream "~&Type ~:C to make a new one by that name." #\Control-return))

(compile-flavor-methods object-parsed-not-of-type
			input-not-of-required-type
			input-not-of-required-type-unless-control-return)

(defvar-standard *accept-activation-chars* '((#\Return #\End)))

(defmacro with-accept-activation-chars ((additional-characters &key override) &body body)
  (if (characterp additional-characters)
      (setq additional-characters `'(,additional-characters)))
  `(with-stack-list* (*accept-activation-chars*
		      ,additional-characters
		      ,(if override
			   `(and (not ,override) *accept-activation-chars*)
			   `*accept-activation-chars*))
     . ,body))

(defun accept-activation-p (char)
  (and
    (loop for l in *accept-activation-chars*
	  thereis (member char l :test #'char-equal))
    (not (accept-blip-p char))))

(defvar-standard *accept-blip-chars* nil)
(defvar-standard *accept-active* nil)
(defvar *accept-cut-flag* nil)

(defmacro with-accept-blip-chars ((additional-characters &key override) &body body)
  (if (characterp additional-characters)
      (setq additional-characters `'(,additional-characters)))
  `(with-stack-list* (*accept-blip-chars*
		      ,additional-characters
		      ,(if override
			   `(and (not ,override) *accept-blip-chars*)
			   `*accept-blip-chars*))
     . ,body))

(defun accept-blip-p (char)
  (loop for l in *accept-blip-chars*
	thereis (and (characterp char) (member char l :test #'char-equal))))

;;; Output an object as a specific presentation type.
;;; ACCEPTABLY means the output should be parsable as the same type.
;;; SENSITIVE shouldn't be used except on special occasions; it inhibits making the output
;;;  sensitive.
(defun present (object &optional (presentation-type (type-of object))
		       &rest options
		       &key (stream *standard-output*) (acceptably nil) (sensitive t)
			    for-context-type
			    (original-type nil original-type-supplied)
		       &allow-other-keys)
  (declare (arglist object &optional (presentation-type (type-of object))
			   &key (stream *standard-output*) (acceptably nil) (sensitive t)
				for-context-type (form nil) (location nil)
				(check-type *present-checks-type*)
				(single-box nil)
				(allow-sensitive-inferiors t) (allow-sensitive-raw-text t)
				(redisplay-place-holder nil)
				original-type))
  (with-type-method ((real-presentation-type function) presentation-type
		     #'presentation-type-find-printer)
    (flet ((present-internal (stream)
	     (funcall function object stream
		      real-presentation-type
		      (if original-type-supplied
			  original-type
			  presentation-type)
		      acceptably
		      for-context-type)))
      (if sensitive
	  (si:with-rem-keywords (some-options options '(:stream :sensitive :original-type
							:acceptably :for-context-type))
	    (lexpr-send stream :output-as-presentation #'present-internal stream
			:object object
			:type presentation-type
			some-options))
	(present-internal stream)
	nil))))

(defun write-for-present (object &rest write-keywords &key &allow-other-keys)
  (with-standard-io-environment
    (let ((si:*print-sensitive* -1)
	  (*package* si:*user-package*)
	  (*print-array* nil)
	  (*print-structure-contents* nil)
	  (*print-readably* nil)
	  (*readtable-for-expression*))
      (apply #'cl:write object write-keywords))))

(defun (write-for-present compiler:style-checker) (form)
  (destructuring-bind (function object &key stream &allow-other-keys) form
    (ignore object)
    (unless stream
      (warn "You must supply a ~S argument to ~S.~@
	     This should come from the (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")stream0 parameter for the type's printer."
	    :stream function))))


(defvar-standard *accept-help* nil)

;(FUNCALL *HELP-DISPLAYER* continuation stream)
(defvar-standard *help-displayer* 'funcall)

;;; Try to make <Help> better
(defun display-help (stream string-so-far)
  (funcall *help-displayer*
	   (lambda (stream)
	     (declare (sys:downward-function)
		      (dbg:invisible-frame :accept-internals))
	     (flet ((find-help-clauses-named (help-name)
		      (loop for clause in *accept-help*
			    when (eq (caar clause) help-name)
			      collect clause))
		    (display-help-clauses (help-clauses)
		      (loop for clause in (reverse help-clauses)
			    as (type . args) = clause
			    do
			(ignore type)
			(fresh-line stream)
			(typecase (car args)
			  (string (format stream (car args)))
			  (function
			    (apply (car args) stream string-so-far (cdr args)))))))
	       (let ((reverse-top-level-help-clauses
		       (find-help-clauses-named :top-level-help))
		     (reverse-subhelp-clauses
		       (find-help-clauses-named :subhelp)))
		 (cond ((null reverse-top-level-help-clauses)
			(format stream "~&No top-level help specified.  Check the code."))
		       (t (display-help-clauses reverse-top-level-help-clauses)))
		 (when reverse-subhelp-clauses
		   (display-help-clauses reverse-subhelp-clauses)))))
	   stream))

;;; WITH-ACCEPT-HELP is like ZL:WITH-INPUT-EDITOR-OPTIONS, except that
;;; for each option (:TOP-LEVEL-HELP, :SUBHELP) there are four possible
;;; ways to combine it.
;;; Specifying (<help-option> :ESTABLISH-UNLESS-OVERRIDDEN) means "Establish <help-option>
;;; at this level, unless someone above has established <help-option>."  It does not imply
;;; :APPENDING.
;;; Specifying (:SUBHELP :APPEND) means append no matter what.
;;; Specifying :SUBHELP means "Append to previous subhelp, unless an outer
;;; context has established an :OVERRIDE".  (This seems to be the most useful
;;; behavior.)
;;; Specifying (:SUBHELP :OVERRIDE) means "This is the subhelp, (subject to
;;; lower-level explicit :APPENDs) unless someone above has already :OVERRIDden us.
(defmacro with-accept-help (options &body body)
  (declare (zwei:indentation 0 3 1 1))
  (zl:check-arg options (and (listp options)
			     (every #'listp options))
		"a list of help options")
  (loop for option in options
	as option-name-spec = (if (symbolp (car option)) `(,(car option) :NORMAL)
				  (car option))
	as (option-name option-type) = option-name-spec
	as override-p = (eq option-type :override)
	as append-p = (eq option-type :append)
	as establish-unless-overridden-p = (eq option-type :establish-unless-overridden)
	as option-args = (cdr option)
	do
    (setq body
	  `((stack-let ((*accept-help*
			  (cons (list ',option-name-spec . ,option-args)
				*accept-help*)))
	      ,@(cond (override-p
		       `((cond ((assoc (caar *accept-help*)
				       (cdr *accept-help*)
				       :test #'(lambda (a b)
						 (and (eq (car a) (car b))
						      (member ':override (cdr b)))))
				(pop *accept-help*))
			       (t
				(setq *accept-help*
				      (cons (car *accept-help*)
					    (delete ,option-name
						    (cdr *accept-help*)
						    :test #'(lambda (a b)
							      (eq (caar b) a)))))))))
		      (append-p ())
		      (establish-unless-overridden-p
		       `((if (progn (assoc (caaar *accept-help*)
					   (cdr *accept-help*)
					   :key #'car))
			     (pop *accept-help*))))
		      (t
		       ;; normal-p
		       `((if (assoc (caar *accept-help*)
				    (cdr *accept-help*)
				    :test #'(lambda (a b)
					      (and (eq (car a) (car b))
						   (member :override (cdr b)))))
			     (pop *accept-help*)))))
	      . ,body))))
    `(progn . ,body))

(defmacro with-accept-help-if (cond options &body body)
  (declare (zwei:indentation 0 3 2 1))
  `(let ((.old-accept-help. *accept-help*))
     (ignore .old-accept-help.)
     (with-accept-help ,options
       (unless ,cond
	 (setq *accept-help* .old-accept-help.))
       . ,body)))

(defun show-help-for-presentation-type (type &optional (stream *standard-output*)
						       (stuff-so-far "")
						       (action :then-return))
  (flet ((funny-stream (op &rest args)
	   (case op
	     ((:any-tyi :tyi)
	      (throw 'dw::done-displaying-possibilities nil))
	     ;; Yecch, but as MMcM says, "I guess if this is called
	     ;; funny-stream, it can be arbitrarily funny!"
	     (:interactive t)			;Outright bold-faced lie
	     (:stuff-so-far stuff-so-far)
	     (:input-editor (funcall (first args)))
	     (:read-location nil)
	     (:rescanning-p nil)
	     (otherwise (lexpr-send stream op args)))))
      (catch 'dw::done-displaying-possibilities
	(accept type
		:prompt nil
		:initially-display-possibilities action
		:stream #'funny-stream))))

(defun complete-for-presentation-type (type string &optional (action :complete-maximal))
  (declare (values string beeped index))
  (stack-let ((buffer (make-array (+ (string-length string) 20) :element-type 'character
				  :fill-pointer (string-length string)
				  :initial-contents string))
	      (read-index 0)
	      (gave-complete nil)
	      (beeped nil)
	      (good-location nil))
    (labels ((funny-stream (op &rest args)
	       (let ((ops '(:tyi :any-tyi :interactive :beep
			    :input-editor :read-location :set-location :set-typein-location
			    :rescanning-p :replace-input-since)))
		 (ecase op
		   (:which-operations ops)
		   (:operation-handled-p (member op ops))
		   (:send-if-handles (when (member op ops) (apply #'funny-stream args)))
		   ((:tyi :any-tyi)
		    (cond ((< read-index (fill-pointer buffer))
			   (prog1 (aref buffer read-index)
				  (incf read-index)))
			  ((and (eq op :any-tyi)
				(= read-index (fill-pointer buffer))
				(not gave-complete))
			   (incf read-index)
			   (setq gave-complete t)
			   (list :activation (ecase action
					       (:complete #\Complete)
					       (:complete-maximal #\Super-Complete))))
			  (t (throw 'complete-for-presentation-type nil))))
		   (:untyi
		     (when (> read-index (fill-pointer buffer))
		       (setq gave-complete nil))
		     (decf read-index))
		   (:interactive t)
		   (:input-editor (funcall (first args)))
		   (:read-location read-index)
		   (:set-location (setq read-index (first args)))
		   (:set-typein-location (setq good-location (second args)))
		   (:rescanning-p gave-complete)
		   (:beep (setq beeped t))
		   (:replace-input-since
		     (destructuring-bind (loc string &optional (begin 0) end &rest ignore)
			 args
		       (setf (fill-pointer buffer) loc)
		       (vector-push-portion-extend buffer string begin end))
		     (setq read-index (fill-pointer buffer)))))))
	(catch 'complete-for-presentation-type
	  (accept type :prompt nil :stream #'funny-stream))
	(values (copy-seq buffer) beeped (or good-location (fill-pointer buffer))))))

;;; Style checker for old-style ACCEPT keywords.
(defun check-for-obsolete-accept-keywords (form)
  (let* ((keyword-pairs (cddr form))
	 (default (member :default-value keyword-pairs)))
    (when (and default (evenp (length keyword-pairs)) (evenp (length default)))
      (compiler:warn '(:obsolete t)
     "The keyword :DEFAULT-VALUE to ACCEPT is obsolete, use :DEFAULT instead."))))

(defgeneric accept-1 (stream presentation-type &rest args)
  "Internal interface dispatched to by ACCEPT"
  (declare (arglist (stream presentation-type
			    &key (stream *query-io*)
			    (prompt :enter-type)
			    (prompt-mode :normal)
			    (original-type presentation-type)
			    activation-chars additional-activation-chars
			    blip-chars additional-blip-chars
			    (inherit-context t)
			    (default t default-supplied)
			    (provide-default 'unless-default-is-nil)
			    (default-type original-type)
			    (display-default prompt)
			    present-default
			    history
			    (prompts-in-line *accept-active*)
			    (initially-display-possibilities nil)
			    input-sensitizer
			    (handler-type 'parser)
			    query-identifier
			    (separate-inferior-queries nil)
			    (independent-query nil)
			    (changed-value-overrides-default t)
			    (newline-after-query t)
			    (query-entry-mode :inline)
			    (confirm nil)
			    (ensure-object nil))))
  (:method-arglist (presentation-type
		     &key (stream *query-io*)
		     (prompt :enter-type)
		     (prompt-mode :normal)
		     (original-type presentation-type)
		     activation-chars additional-activation-chars
		     blip-chars additional-blip-chars
		     (inherit-context t)
		     (default t default-supplied)
		     (provide-default 'unless-default-is-nil)
		     (default-type original-type)
		     (display-default prompt)
		     present-default
		     history
		     (prompts-in-line *accept-active*)
		     (initially-display-possibilities nil)
		     input-sensitizer
		     (handler-type 'parser)
		     query-identifier
		     (separate-inferior-queries nil)))
  (:function (declare (dbg:invisible-frame :accept-internals))
	     (if (and (instancep stream) (operation-handled-p stream 'accept-1))
		 (apply (flavor:generic accept-1) stream presentation-type args)
		 (apply #'accept-2 presentation-type args))))

(defparameter *check-type-of-default* nil)

;;; Input an object of a specific type.
(defun accept-2 (presentation-type &key (stream *query-io*)
		 (prompt :enter-type)
		 (prompt-mode :normal)
		 prompt-after			;useful for CP.  Probably needs better name
		 activation-chars additional-activation-chars
		 blip-chars additional-blip-chars
		 (inherit-context t)
		 (default nil default-supplied)
		 (provide-default 'unless-default-is-nil)
		 (display-default prompt)
		 present-default
		 history
		 (prompts-in-line *accept-active*)
		 (initially-display-possibilities nil)
		 input-sensitizer
		 (handler-type #'presentation-type-find-parser)
		 (original-type presentation-type)
		 (default-type original-type)
		 query-identifier (independent-query nil) (changed-value-overrides-default t)
		 (separate-inferior-queries nil) (newline-after-query t)
		 (query-entry-mode :inline)
		 (confirm nil) (ensure-object nil)
		 (top-level nil) (top-level-blank-line-mode :reprompt)
		 &aux (recurse *accept-active*) (*accept-active* t))
  (declare (values object presentation-type)
	   (dbg:invisible-frame :accept-internals))
  ;;Makes no difference to us; for ACCEPT-VALUES or the CP.
  (declare (ignore independent-query changed-value-overrides-default separate-inferior-queries
		   newline-after-query query-entry-mode
		   confirm ensure-object))

  (cond ((null history)
	 (setq history
	   ;; For purposes of finding a history and filtering items from it,
	   ;; we want to use the original type.  presentation-type is possibly
	   ;; a super-type of the originally-requested type.
	   ;; We are counting on the protocol that parsers that accept
	   ;; sub-objects do not pass down original-type, while those
	   ;; that invoke another parser to do the whole job do.
	   (find-accept-history original-type)))
	((typep history 'zwei:history))
	(t
	 (setq history
	       (find-accept-history history))))
  
  (when provide-default				;either T or UNLESS-DEFAULT-IS-NIL
    (when (not default-supplied)
      ;; Caller specified PROVIDE-DEFAULT but no default value,
      ;; get the default off the top of the history if possible
      (if history
	  (multiple-value-bind (object type found)
	      (yank-for-presentation-type history default-type)
	    (if (not found)
		;; If the caller asked for the default to be provided (from the history)
		;; and there IS a history, but there are no values in it yet (i.e. the
		;; top value is NIL), then declare that for this call it's ok if
		;; no default is provided.  (Presumably the history will get its first
		;; element after this call to ACCEPT.  No need to blow out the first time
		;; we ACCEPT a printer.)
		(setq provide-default nil)
		(setq default object default-type type)))
	  (if (eq provide-default t)
	      ;; Only error if :PROVIDE-DEFAULT T was explicitly
	      ;; specified and we can't generate a default.
	      (error ":PROVIDE-DEFAULT was specified, but no default value was supplied and there is no history for the presentation-type ~A" presentation-type)
	      ;; We would like to provide a default when possible, but
	      ;; if we can't find one, give up.
	      (setq provide-default nil))))
    
    (when (case provide-default
	    ((unless-default-is-nil) default)
	    ((nil) nil)
	    (otherwise t))	    
      ;; if default, preprocess it if necessary
      (multiple-value-bind (obj type)
	  (invoke-default-preprocessor default presentation-type original-type default-type)
	(setq default obj
	      default-type type)))

    ;; At this point, we've done our best to get a default.
    ;; If it's NIL, and if PROVIDE-DEFAULT wasn't explicitly specified, let's
    ;; not actually provide this default.  Except for the BOOLEAN presentation type, where
    ;; NIL is an obvious good default.
    (when (eq provide-default 'unless-default-is-nil)
      (when (and (null default)
		 (not (presentation-type-null-default-provide-default presentation-type)))
	(setq provide-default nil))))
  
  (with-accept-activation-chars ((or activation-chars additional-activation-chars)
				 :override
				 (not (null activation-chars)))
    (with-accept-blip-chars ((or blip-chars additional-blip-chars)
			     :override
			     (not (null blip-chars)))
      
      (flet ((standard-prompt (stream ignore)
	       (declare (downward-function))
	       (unless prompts-in-line
		 (write-string "Enter " stream))
	       (describe-presentation-type original-type stream))
	     (prompt (stream reason)
	       (declare (downward-function))
	       (ecase prompt-mode
		 (:raw
		   ;; :RAW means don't print the defaults, the parens, the colon or anything
		   (when prompt
		     (si:display-prompt-option stream prompt nil reason)))
		 (:normal
		   ;; do as much work as possible for the user
		   (when prompts-in-line
		     (write-string "(" stream))
		   (when prompt
		     (si:display-prompt-option stream prompt nil reason))
		   (when (and display-default provide-default)
		     (when prompt
		       (write-string " [" stream))
		     (write-string "default " stream)
		     (present default default-type :stream stream :acceptably t)
		     (when prompt
		       (write-string "]" stream)))
		   (write-string
		     (if prompts-in-line ") " ": ") stream))))
	     
	     (push-history (object object-type stream &optional start-loc)
	       (declare (downward-function))
	       ;; In addition to the obvious type checking, this typep check makes sure
	       ;; that sequences don't get put on the histories of their element types
	       (when (and history
			  (presentation-subtypep-cached object-type (send history :type)))
		 (heap-copy-presentation-type-if-necessary object-type)
		 (let ((string (and start-loc
				    (send-if-handles stream :copy-input-since start-loc))))
		   (unless (plusp (string-length string))
		     (setq string nil))
		   (multiple-value-setq (object object-type string)
		     (invoke-history-postprocessor presentation-type original-type
						   object object-type string default))
		   (push-for-presentation-type history object object-type string)))
	       (if input-sensitizer
		   (funcall input-sensitizer stream object object-type t)
		   (send-if-handles stream :set-input-buffer-presentation
				    object object-type)))
	     
	     (check-for-null-default (start-loc)
	       (declare (downward-function))
	       (let ((pt (send stream :read-location)))
		 (send stream :set-location start-loc)
		 (cond ((true-null-parser stream nil)
			(send stream :set-location pt)
			nil)
		       (t
			(presentation-replace-input
			  stream start-loc
			  (with-output-to-string (s)
			    (present default default-type :stream s :acceptably t)))
			(if input-sensitizer
			    (funcall input-sensitizer stream default default-type nil))
			(return-from accept-2 (values default default-type)))))))

	(let ((prompt-key prompt))
	  (when (eq prompt :enter-type)
	    (setq prompt #'standard-prompt))
	  (when (and provide-default
		     *check-type-of-default*)
	    (unless (and (ptypep default default-type)
			 (ptypep default presentation-type ))
	      (error "~S was provided as a default, but was not of the type ~S."
		     default default-type)))
	  (when present-default
	    (if (eq present-default :accept-values)
		(with-redisplayable-output (:stream stream :unique-id 'prompt
					    :cache-value prompt-key
					    :cache-test (if (stringp prompt)
							    #'string-equal
							    #'eql))
		  (with-output-as-presentation (:object query-identifier
						:type 'accept-values-query-display
						:stream stream)
		    (prompt stream nil)))
	      (when prompt
		(prompt stream nil)))
	    (return-from accept-2
	      (accept-present-default stream default provide-default
				      presentation-type query-identifier
				      present-default))))

	(let ((already-prompt-p (not (null (si:input-editor-option :prompt))))
	      ;; This only really works reliably if this call
	      ;; establishes the input editor context.  Otherwise,
	      ;; rescanning will rebind this.
	      (already-displayed-possibilities nil))
	  ;;Don't make a reprompt if the prompt won't take.
	 (with-input-editing-options-if
	    (and (or (and provide-default display-default) prompt)
		 (not prompts-in-line)
		 (not already-prompt-p))
	    ((:prompt (unless initially-display-possibilities #'prompt))
	     (:reprompt #'prompt))

	  (with-type-method ((real-presentation-type function nil predicate)
			     presentation-type handler-type)
	    (with-input-editing-options-if
		(not (null history))
		(((:input-history :override) history)
		 ((:input-history-presentation-type-for-yanking :override) presentation-type)
		 ((:no-input-save :override) t))
	      
	      (with-input-editing-options
		  ;; this is probably wrong --- there wants to be another argument
		  ;; to control this.  There are probably some presentation types
		  ;; that do :default <thing> :provide-default <some-test>.
		  ;; For now, I'm relying on the assumption that if there's a default
		  ;; there for whatever reason, it's better to use that for c-m-Y
		  ;; than it is to use something out of the history.
		  ;; This makes SEQUENCE work properly.
		  (((:input-history-default :override) (and 1default #+ignore0 provide-default
							    (if history
								(list default default-type)
							      (present-to-string
								default
								default-type
								:acceptably t))))
		   ((:activation :override) #'accept-activation-p)
		   ((:blip-character :override) #'ignore)
		   ((:rescan :override) #'(sys:named-lambda rescan (char old-test)
					    (declare (downward-function))
					    (or (eql char #\Help)
						(and old-test
						     (apply (first old-test)
							    char (rest old-test)))))
		    (si:input-editor-option :rescan))
		   )
		
		(with-accept-help
		    (((:top-level-help :establish-unless-overridden)
		      ;; :ESTABLISH-... here because we want sequence pathname's help,
		      ;; not both sequence pathname and pathname.
		      (sys:named-lambda top-level-help (stream ignored)
			(declare (downward-function))
			(write-string "You are being asked to enter " stream)
			(describe-presentation-type original-type stream nil :help)
			(write-char #\. stream))))
		  
		  (loop named top doing
		    ;;--- The compiler doesn't generate correct code when this is lexical.
		    (catch 'reprompt		;BLOCK REPROMPT
		      (return-from top
			(with-presentation-input-editor-context
			   (stream presentation-type
				   :inherit inherit-context)
			   (blip start-loc)
			     (let ((sl (send stream :read-location)))
			       ;; +++ DLW & RWK are suspicious of the modularity here.
			       ;; +++ This establishes a completion help context that's
			       ;; +++ uses the entire string input to this call to 1accept0.
			       ;; +++ But we may only be completing over a substring of that.
			       ;; +++ It seems the start of the string should be determined
			       ;; +++ by the start of the completion, not by the start of the
			       ;; +++ accept.  Perhaps this is OK as a default, but then
			       ;; +++ 1complete-input0 should override it, with essentially what
			       ;; +++ appears here.
			       (with-input-editing-options
				   ;; Make this :complete-help so that all the
				   ;; annoying control-character info doesn't
				   ;; get printed.
				   (((:complete-help :override)
				     (sys:named-lambda complete-help (s)
				       (declare (sys:downward-function))
				       (display-help
					 s
					 (or (send-if-handles stream :copy-input-since sl)
					     "")))))
				 
				 (multiple-value-bind (object object-type)
				     (condition-bind-if
				       provide-default
				       ((parse-error
					  (sys:named-lambda parse-error-condition-handler
							    (ignore)
					    (declare (downward-function))
					    (check-for-null-default start-loc))))
				       
				       (let-if (not recurse)
					       ((*accept-cut-flag* nil))
					 
					 (when (and prompts-in-line
						    (or (and provide-default display-default)
							prompt))
					   
					   (accept-noise-string-out 
					     (with-output-to-presentation-recording-string (s)
					       (prompt s nil))
					     stream)
						; --- Needed by CP.  Needs BSG's approval
					   (when prompt-after
					     (funcall prompt-after)))
					 
					 (when top-level
					   (ecase (skip-over-whitespace-and-reprompt-on-newline
						    stream top-level-blank-line-mode)
					     ((nil) )
					     ((:return-nil)
					      (return-from top
						(values nil nil)))
					     ((:reprompt)
					      (throw 'reprompt t)
						;(RETURN-FROM REPROMPT T)
					      )))
					 
					 (condition-bind-if top-level
					   ((end-of-file
					      (sys:named-lambda end-of-file-condition-handler 
								(ignore)
						(declare (downward-function))
						(let ((char (peek-char-for-accept stream)))
						  (when (and (consp char)
							     (eq (first char) ':activation))
						    ;; If the problem was caused by an
						    ;; activator like end, get rid of it and
						    ;; just beep.  Otherwise, the error might
						    ;; mean something and rescanning will
						    ;; probably repeat it.
						    (read-char-for-accept stream)
						    (beep)
						    (send stream :force-rescan))))))
					   (heap-copy-presentation-type-if-necessary
					     real-presentation-type)
					   (heap-copy-presentation-type-if-necessary
					     original-type)
					   (let ((initially-display
						   (and
						     (prog1
						       (not
							 (or (not (send stream :interactive))
							     (send stream :rescanning-p)
							     already-displayed-possibilities))
						       (setq already-displayed-possibilities
							     t))
						     initially-display-possibilities)))
					     (multiple-value-bind (object object-type)
						 (funcall function
							  stream real-presentation-type
							  original-type predicate
							  initially-display
							  default
							  (if (eq provide-default
								  'unless-default-is-nil)
							      (not (null default))
							    provide-default)
							  default-type)
					       (when predicate
						 (unless (and (funcall predicate object)
							      (ptypep object
								      real-presentation-type))
						   (error 'object-parsed-not-of-type
							  :object object
							  :type original-type)))
					       (values object object-type))))))
				   
				   ;; If the parser didn't return us a type, use the most
				   ;; specific type as a default.
				   (unless object-type
				     (setq object-type original-type))
				   (heap-copy-presentation-type-if-necessary object-type)
				   (push-history object object-type stream start-loc)
				   (values object object-type))))
			   
			   (otherwise
			     (push-history
			       (presentation-blip-object blip)
			       (presentation-blip-presentation-type blip)
			       stream)
			     ;; When we are rescanning, don't try to insert the blips back into
			     ;; the input buffer since it will cause useless input replacement.
			     (unless (send stream :rescanning-p)
			       (echo-presentation-blip stream blip start-loc
						       presentation-type))
			     (values (presentation-blip-object blip)
				     (presentation-blip-presentation-type blip))
			     )))))))))))))))

(defmethod (accept-1 si:input-stream) (presentation-type &rest args)
  (declare (dbg:invisible-frame :accept-internals))
  (apply #'accept-2 presentation-type args))

(defun accept (presentation-type &rest args &key (stream *query-io*) &allow-other-keys)
  (declare (arglist
	     presentation-type
	     &key (stream *query-io*)
	     (prompt :enter-type)
	     (prompt-mode :normal)
	     (original-type presentation-type)
	     activation-chars additional-activation-chars
	     blip-chars additional-blip-chars
	     (inherit-context t)
	     (default t default-supplied)
	     (provide-default 'unless-default-is-nil)
	     (default-type original-type)
	     (display-default prompt)
	     present-default
	     history
	     (prompts-in-line *accept-active*)
	     (initially-display-possibilities nil)
	     input-sensitizer
	     (handler-type #'presentation-type-find-parser)
	     query-identifier
	     (changed-value-overrides-default t)
	     (newline-after-query t)
	     (query-entry-mode :inline)
	     (separate-inferior-queries nil)
	     (confirm nil)
	     (ensure-object nil))
	   (values object type))
  (apply #'accept-1 (si:follow-syn-stream stream) presentation-type args))

(defun accept-from-string (presentation-type string
			   &rest args
			   &key index (start 0) end
			   &allow-other-keys)
  (declare (values object type index))
  (si:with-rem-keywords (new-args args '(:index :start :end))
    (let (object type)
      (with-input-from-string (string-stream string :index index :start start :end end)
	(multiple-value-setq (object type)
	  (apply #'accept presentation-type
		 :prompt nil :stream string-stream :provide-default nil new-args)))
      (values object type index))))

(defun present-to-string (object
			  &optional (presentation-type (type-of object))
			  &key (string nil string-p) (index nil index-p)
			       acceptably for-context-type
			       (original-type presentation-type)
			       (check-type *present-checks-type*))
  (if string-p
      (if index-p
	  (with-output-to-string (string-stream string :index index)
	    (present object presentation-type :stream string-stream
		     :acceptably acceptably :for-context-type for-context-type
		     :original-type original-type :check-type check-type))
	  (with-output-to-string (string-stream string)
	    (present object presentation-type :stream string-stream
		     :acceptably acceptably :for-context-type for-context-type
		     :original-type original-type :check-type check-type)))
      (with-output-to-string (string-stream)
	(present object presentation-type :stream string-stream
		 :acceptably acceptably :for-context-type for-context-type
		 :original-type original-type :check-type check-type))))

(defun skip-over-whitespace-and-reprompt-on-newline (stream blank-line-mode)
  (loop
    (let ((char (read-char-for-accept stream)))
      (cond ((and (consp char) (eq (first char) :activation))
	     (ecase blank-line-mode
	       (:ignore )
	       (:reprompt
		(when (eql (second char) #\Return)
		  (terpri stream))
		(return :reprompt))
	       (:beep
		(beep))
	       (:return-nil
		(return :return-nil))
	       (:end-returns-nil
		(case (second char)
		  (#\Return
		   (terpri)
		   (return :reprompt))
		  (#\End
		   (return :return-nil))))))
	    ((member char si:*whitespace* :test #'compare-char-for-accept)
	     )
	    (t
	     (unread-char-for-accept char stream)
	     (return nil))))))

;;;--- Should really be a type method
(defun presentation-type-null-default-provide-default (presentation-type)
  (eq (presentation-type-name presentation-type) 'boolean))

(defstruct accept-values-value 
  object
  presentation-type
  query-identifier)

;;; When unparsing or doing ACCEPT-VALUES, ACCEPT turns into PRESENT of the default.
(defun accept-present-default (stream default provide-default
			       presentation-type query-identifier present-default)
  (declare (values object presentation-type presentation x y))
  (flet ((present-default-internal (stream)
	   (if provide-default
	       (present default presentation-type :stream stream
			:acceptably (neq present-default :accept-values))
	       (with-character-face (:italic stream)
		 (describe-presentation-type presentation-type stream))
	       nil)))
    (when (not (member present-default '(:accept-values :menu)))
      ;; Definitely not from CHOOSE-COMMAND-ARGUMENTS.  Must just be unparsing.
      (return-from accept-present-default
	(values default presentation-type (present-default-internal stream))))
    (multiple-value-bind (x y)
	(send stream :read-cursorpos)
      (values
	default
	presentation-type
	(with-type-method ((ptype handler htype) presentation-type
			   (ecase present-default
			     (:accept-values
			       #'presentation-type-displayer-for-accept-values)
			     (:menu #'presentation-type-displayer-for-menu)))
	  ;; htype can be accept-values-displayer, choose-displayer, menu-displayer,
	  ;; or printer (the default used if none of the specialized ones are found)
	  (cond ((and handler (eq htype 'accept-values-displayer))
		 ;; accept-values-displayer controls all five values returned
		 (return-from accept-present-default
		   (funcall handler stream default query-identifier
			    ptype presentation-type provide-default)))
		((and handler (member htype '(menu-displayer choose-displayer)))
		 ;; choose-displayer and menu-displayer return only a presentation
		 (funcall handler stream default query-identifier
			  ptype presentation-type))
		(t 	;(eq htype 'printer)
		 (let ((value-object (make-accept-values-value :object default
							       :presentation-type
							       presentation-type
							       :query-identifier
							       query-identifier)))
		   (with-output-as-presentation (:object value-object
						 :type 'accept-values-value-display
						 :stream stream)
		     (present-default-internal stream)
		     (multiple-value-bind (nx ny) (send stream :read-cursorpos)
		       (when (and (eql x nx) (eql y ny))
			 (or (send-if-handles stream :force-non-empty-presentation)
			     (write-char #\Space stream)))))))))
	x y))))

(defun accept-noise-string-out (string stream)
  (when (send stream :interactive)
    (when ( (+ (send stream :read-cursorpos)
		(send stream :string-length string))
	     (multiple-value-bind (nil nil right nil)
		 (send stream :visible-cursorpos-limits)
	       right))
      (setq string (string-append "
  " string)))
    (send stream :noise-string-out string)))

;;; This macro is useful for writing :accept-values-displayer presentation "methods".
;;; The arguments at the front are the :accept-values-displayer arguments
;;; Within the body, (present-editable-choice object presentation-type) shows one
;;; choice of the kind that is an editable field rather than a simple menu item,
;;; and returns the presentation.
;;; Within the body, (accept-values-dispatch (type) accept-values menu printer)
;;; is a macro that aids dispatching to accept-values on another presentation-type.
;;; accept-values and menu are pieces of forms glued in for that case.
;;; printer is the form evaluated when type has no special handler.
;;; Body must return (values object original-type presentation x y).
(defmacro standard-accept-values-displayer ((stream object query-identifier provide-default)
					    &body body)
  `(multiple-value-bind (x y)
       (send ,stream :read-cursorpos)
     (let ((satisfactory-value-shown nil))
       (labels ((present-editable-choice (object presentation-type
					  &optional dont-present dont-highlight)
		  (let ((value-object (make-accept-values-value
					:object object :presentation-type presentation-type
					:query-identifier ,query-identifier)))
		    (cond ((and ,provide-default
				(not dont-present)
				(not satisfactory-value-shown)
				(ptypep object presentation-type))
			   (setq satisfactory-value-shown t)
			   (with-output-as-presentation (:object value-object
							 :type 'accept-values-value-display
							 :stream ,stream)
			     (if dont-highlight
				 (present object presentation-type :stream ,stream
					  :acceptably nil)
				 ;; We can get away with emboldening this item because
				 ;; the call to 1ptypep0 ensures that this object is the
				 ;; currently selected default, and because the only
				 ;; way we use this format ensures that the displayer
				 ;; for the other types will highlight them correctly.
				 (with-character-face (:bold ,stream)
				   (present object presentation-type :stream ,stream
					    :acceptably nil)))))
			  (t
			   ;; The display would glitch less if this used
			   ;; with-redisplayable-output, but I can't make it work
			   (with-output-as-presentation (:object value-object
							 :type 'accept-values-value-display
							 :stream ,stream)
			     (with-character-face (:italic ,stream)
			       (describe-presentation-type presentation-type ,stream))))))))
	 (macrolet ((accept-values-dispatch ((type) accept-values menu printer)
		      `(with-type-method ((ptype handler htype) ,type
					  #'presentation-type-displayer-for-accept-values)
			 (cond ((and handler (eq htype 'accept-values-displayer))
				(,@accept-values (funcall handler ,',stream ,',object
							  ,',query-identifier ptype ,type
							  ,',provide-default)))
			       ((and handler (member htype '(menu-displayer choose-displayer)))
				(,@menu (funcall handler ,',stream ,',object
						 ,',query-identifier ptype ,type)))
			       (t		;(eq htype 'printer)
				(multiple-value-setq (x y) (send ,',stream :read-cursorpos))
				,printer)))))
	   ,@body)))))

(defun find-accept-history (presentation-type)
  (with-type-method ((final-pt val nil pred) presentation-type #'presentation-type-history
		     :error-p nil)
    ;; We shouldn't ignore 2pred0, but the modularity is wrong.
    (ignore pred)
    ;;really could tell what exactly which prop we got back
    (typecase val
      (null nil)
      ;; :NONE means no history for this type, even if it would otherwise
      ;; inherit one.
      (symbol (cond ((eq val :none) nil)
		    (t (error "INPUT-HISTORY-TYPE not handled yet"))))
      (instance val)
      (cons (ecase (first val)
	      (:use (find-accept-history (second val)))))
      (otherwise
	;; We now have code that relies on FIND-ACCEPT-HISTORY returning all the
	;; values that result from this funcall.  Don't change it. (see SEQUENCE)
	(funcall val final-pt presentation-type)))))

(defun invoke-history-postprocessor (presentation-type original-type
				     object object-type string default)
  (with-type-method ((real-presentation-type history-postprocessor)
		     presentation-type #'presentation-type-find-history-postprocessor
		     :error-p nil :supertype-p nil)
    (multiple-value-bind (new-object new-object-type)
	(funcall history-postprocessor
		 object default
		 object-type original-type real-presentation-type)
      (unless (eq object new-object)
	(setq object new-object
	      string nil))
      (when new-object-type
	(setq object-type new-object-type))))
  (values object object-type string))

(define-presentation-type accept-values-value-display ())


;;;  Input reading/completion system

(defun read-char-for-accept (stream)
  (let ((char (loop thereis (send stream :any-tyi)
		      until (not (send stream :interactive )))))	;bug in IE
    (cond ((listp char) char)
	  ((accept-blip-p char)
	   (list ':accept char nil))
	  (t char))))

(defun unread-char-for-accept (char stream)
  (cond ((characterp char) (send stream :untyi char))
	((listp char)
	 (send stream :untyi (if (eq (first char) ':accept)
				 (second char)
				 char)))
	(t (error "Don't know how to unread ~S" char))))

(defun peek-char-for-accept (stream &optional hang)
  (let ((ch (and (or hang (not (send stream :interactive)) (send stream ':rescanning-p))
		 (read-char-for-accept stream))))
    (when ch
      (unread-char-for-accept ch stream))
    ch))

(defun compare-char-for-accept (char-from-accept comparandum)
  (and char-from-accept
       (typecase char-from-accept
	 (character (char-equal comparandum char-from-accept))
	 (list (and (member (first char-from-accept) '(:activation :blip-character :accept))
		    (characterp (second char-from-accept))
		    (char-equal comparandum (second char-from-accept)))))))
  
(defun heapify-string (string)
  (if (si:in-stack string)
      ;; Only evacuate the string if it's really in the stack
      (let* ((length (zl:array-active-length string))
	     (new-string (zl:make-array length
					:type (array-type-field string))))
	(copy-array-portion string 0 length new-string 0 length)
	new-string)
    string))

;;; EXPLICITLY-QUOTED can have three values:  :FIRST, :BOTH, or NIL
;;; Note that we don't need the DELIMITERS any more.
(defun read-standard-token (stream &key quote-p)
  (declare (values string explicitly-quoted))
  (flet ((skip-whitespace ()
	   (declare (dbg:invisible-frame :accept-internals))
	   (loop for ch = (read-char-for-accept stream)
		 unless (and (characterp ch) (or (char= ch #\Sp) (char= ch #\Tab)))
		   return (unread-char-for-accept ch stream))))
    (skip-whitespace)
    ;; Note well that this string has to be copied out of the stack before it
    ;; is returned.  HEAPIFY-STRING will do this optimally
    (with-stack-array (string 100. :element-type 'character :fill-pointer 0)
      (loop with char
	    for first-p = t then nil
	    do
	(let-if quote-p ((*accept-blip-chars* nil))
	  (setq char (read-char-for-accept stream)))
	(macrolet ((char-is-quote ()
		    `(compare-char-for-accept char #\")))
	  (cond ((and quote-p
		      (char-is-quote))
		 (return-from read-standard-token
		   (values (prog1 (heapify-string (thinify-string string))
				  (skip-whitespace)) ':both)))
		((and first-p
		      (char-is-quote))
		 ;; quotes are only special when they're the first character read
		 ;; (after whitespace)
		 (setq quote-p ':first))
		(t
		 (when (and (eq quote-p ':first)
			    (compare-char-for-accept char #\\))
		   (setq char (let ((*accept-blip-chars* nil)
				    (*accept-activation-chars* nil))
				(read-char-for-accept stream))))
		 (if (characterp char)
		     (vector-push-extend char string)
		   (unread-char-for-accept char stream)
		   (return (values (heapify-string (thinify-string string)) quote-p))))))))))

;;; This function quotes a string if it isn't quoted already and it
;;; contains blip characters other than those explicitly allowed by
;;; the caller (such as the partial completers in complete input).  The
;;; idea is to avoid quoting things that have spaces in them when space
;;; is a partial completer and the string will rescan OK (e.g. command names).
;;; For efficiency it places the quoted string in a caller-supplied buffer
;;; rather than consing the result string.
(defun quotify-if-necessary (old-string result &optional allowable-blip-chars)
  (flet ((complete-input-quotify-trigger-p (string)
	   ;; Always (?) quote the null string.
	   (or (zerop (string-length old-string))
	       ;; Don't quote already-quoted strings
	       (and (not (char-equal (aref old-string 0) #\"))
		    (not (char-equal (aref old-string (1- (string-length old-string))) #\"))
		    ;; make sure that they string contains "dangerous" characters
		    (some #'(lambda (ch)
			      (and (not (member ch allowable-blip-chars
						:test #'char-equal))
				   (accept-blip-p ch)))
			  string)))))
    (let ((quote-p (complete-input-quotify-trigger-p old-string))
	  (start-idx 0)
	  (len (string-length old-string)))
      (when quote-p
	(setf (aref result start-idx) #\")
	(incf start-idx))
      (si:copy-string-portion old-string 0 len
			      result
			      start-idx
			      (+ start-idx len))
      (incf start-idx len)
      (when quote-p
	(setf (aref result start-idx) #\")
	(incf start-idx))
      (when (array-has-fill-pointer-p result)
	(setf (fill-pointer result) start-idx))))
  ;; no return value, quoted string is in RESULT
  (values))

;;; These two functions should be combined at some point.
(defun add-quotes-appropriately (old-string new-string how-quoted &optional trim-space?)
  (let ((start-idx 0)
	(len (string-length old-string)))
    (when (and trim-space?
	       (> len 0)
	       (char-equal (aref old-string (1- len)) #\Space))
      (decf len))

    (when how-quoted
      (setf (aref new-string start-idx) #\")
      (incf start-idx))
    (si:copy-string-portion old-string 0 len new-string start-idx (+ start-idx len))
    (incf start-idx len)
    (when (eq how-quoted ':both)
      (setf (aref new-string start-idx) #\")
      (incf start-idx))
    (when (array-has-fill-pointer-p new-string)
      (setf (fill-pointer new-string) start-idx)))
  (values))

;; Don't use SCL:STRING-THIN as a replacement for this!  The object of this is
;; to make a string as thin as possible, while consing as little as possible,
;; as fast as possible.  SCL:STRING-THIN is more general and can cons more.
;; Open-code the CL string functions for speed, too.
(defun thinify-string (string)
  (let ((fat-p (string-fat-p string)))
    (if (not fat-p)
	string
      (let ((length (string-length string))
	    (string string))
	(declare (sys:array-register string))
	(if (loop for i below length
		  thereis (char-fat-p (aref string i)))
	    ;; Needs to be left fat
	    string
	  ;; Thinify it
	  (let ((new-string (make-string (length string) :element-type 'string-char)))
	    (declare (sys:array-register new-string))
	    (loop for i below length
		  do (setf (aref new-string i) (aref string i)))
	    new-string))))))

;;; --- If the user types quotes around a token that contains no blip chars,
;;; the quotes will be discarded on rescan.  This is functionally correct
;;; but visually noisy.
(defun presentation-replace-input (stream loc new
				   &key dont-quote)
  (when (send stream :interactive)		;--- Is that the right predicate?
    (if dont-quote
	;; do it the old way
	(send stream :replace-input-since loc new 0 nil :enable)
	(with-stack-array (temp (+ (string-length new) 2) :type 'art-fat-string
				:fill-pointer 0)
	  (quotify-if-necessary new temp)
	  (send stream :replace-input-since loc temp 0 nil :enable)))))
