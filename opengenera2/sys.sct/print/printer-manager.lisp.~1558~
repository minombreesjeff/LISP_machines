D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; -*- Mode: LISP; Syntax: Common-Lisp; Package: Print; Base: 10.; Lowercase: Yes0 1-*-
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(defflavor(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") printer-manager-state
0	((state :uninitialized)
	 (reason nil)
	 (at-time (get-universal-time))
	 (device-state :unknown)
	 (device-state-description ""))
	()
  (:readable-instance-variables state device-state))

(defmethod 2(:print-self0 2printer-manager-state)0 (stream ignore slashify-p)
  (let ((state-string (string-capitalize (format nil "~A" state))))
    (if slashify-p
	(si:printing-random-object (self stream)
	  (format stream "State ~A, entered at ~\\time\\~@[: ~A~]"
		  state-string at-time reason))
	(send stream :string-out state-string))))

(defvar 2*printer-manager-states*
0	'(:uninitialized			; don't accept new queue entries
	  :booting				; don't accept new queue entries
	  :crashed				; If disaster strikes. 
	  :suspended				; suspended by operator
	  :idle					; waiting to print a request
	  :printing))				; printing a request

(defmethod 2(set-state printer-manager-state)0 (new-state new-reason)
  (unless (member new-state *printer-manager-states*)
    (error "The state ~A is not a valid printer manager state." new-state))
  (setf state new-state)
  (setf reason new-reason)
  (setf at-time (get-universal-time)))
(defmethod 2(note-change-of-state printer-manager-state)0 (state description)
  (setq device-state state
	device-state-description description))
(defmethod 2(summarize-status printer-manager-state)0 ()
  (with-output-to-string (stream)
    (format stream "Spooler: ~@(~A~)" state)
    (when (and reason (not (string-equal reason state)))
      (format stream ": ~A" reason))
    (format stream "; Device: ")
    (case device-state
      (:irrecoverable-device-error
	(format stream "Irrecoverable error: ~A" device-state-description))
      (:recoverable-device-error
	(format stream "Needs intervention: ~A" device-state-description))
      (otherwise
	(format stream "~@(~A~)" device-state)))))

(defflavor 2printer-property-list-component
0	(printer)
	()
  :initable-instance-variables)

(defmethod 2(su:stable-directory printer-property-list-component)0 ()
  (get-printer-directory printer))

(defmethod 2(su:stable-name printer-property-list-component)0 ()
  (send (send printer :name) :string))

(defflavor 2printer-characteristics
0	()
	(printer-property-list-component su:carefully-saved-stable-property-list))

(defmethod 2(su:stable-type printer-characteristics)0 ()  "chars")
(defmethod 2(su:temp-type   printer-characteristics)0 () "tchars")

(defflavor 2queue-policies
0	()
	(printer-property-list-component su:carefully-saved-stable-property-list))

(defmethod 2(su:stable-type queue-policies)0 ()  "pols")
(defmethod 2(su:temp-type   queue-policies)0 () "tpols")

(compile-flavor-methods2 printer-characteristics queue-policies0)



(defvar2 *printer-managers*0 nil)

(defvar1 2*default-timeout-threshold*0 (time:parse-interval-or-never "4 minutes")
  "Default timeout-threshold for warning about printer timeouts. Can be
overridden by namespace.")

(defflavor 2printer-manager
0	(printer
	 (state (make-instance 'printer-manager-state))
	 process
1	 ;; 0The following four 1get initialized in the printer manager process
0	 (stream nil)
	 printer-characteristics 
	 queue-policies
	 queue
1	 ;; The following IV0 1is used by the timeout warning mechanism. 
	 ;; It0 1may be initialized by same-named option value in the host namespace object
	 ;; (under spooled-printer options). NIL means that there's no timeout check.
0	 (timeout-threshold *default-timeout-threshold*)1	; in time-interval units (seconds)
0	 (print-cover-page t))
	()
  (:readable-instance-variables printer  process state queue timeout-threshold)
  (:writable-instance-variables          process state timeout-threshold)
  (:initable-instance-variables printer  process timeout-threshold)
  (:required-init-keywords     :printer :process))


(defmethod 2(:print-self printer-manager)0 (stream ignore slashify-p)
  (flet ((inner (stream)
	   (format stream "for ~A" (send printer :pretty-name))))
    (if slashify-p
	(si:printing-random-object (self stream :typep)
	  (inner stream))
	(inner stream))))

(defmethod2 (make-instance printer-manager)0 (&rest ignore)
  (setf queue (make-instance 'request-queue :printer printer))
  (setf printer-characteristics (make-instance 'printer-characteristics :printer printer))
  (setf queue-policies (make-instance 'queue-policies :printer printer)))

;;; Special var to keep track of current timeout threshold within
;;; with-request-timeout-checking macro.
(defvar 2*current-timeout-threshold*0)

1;; Resets the current timeout threshold
0(defmacro 2with-request-timeout-checking0 ((printer-manager) &body body)
  `(let ((*current-timeout-threshold* (printer-manager-timeout-threshold ,printer-manager)))
    ,@body))

(defmethod2 (update-printer-manager-from-namespace printer-manager)0 ()
1  ;; Initialize IV's that may be overridden by Namespace info.
  ;;
  ;; Host should always be the local host, but in the tradition of
  ;; paranoia, I'll get the host the same way GET-PRINTER-DIRECTORY does.
0  (let ((su:*log* *print-spooler-log*))
    (letf (((su:log-process-id su:*log*) "MA")
	   ((su:log-herald     su:*log*) "Printer "))
      (let* ((hosts (hci::printer-spooler-hosts printer :error-p nil))
	     (first-spooling-host (if (member neti:local-host hosts)
				  neti:local-host
				  (first hosts))))
    (unless (null first-spooling-host)
      (let* ((spooled-printers-on-host (send first-spooling-host :spooled-printer))
	     (spooled-printer-options (second (assoc printer spooled-printers-on-host))))
	(if (null (assoc printer spooled-printers-on-host))
	    (su:log-event :problem  "The printer ~A says it's spooled by host ~A, but the host object doesn't ~
		      specify the printer as a spooled printer."
			  printer first-spooling-host)
	    (set-timeout-threshold-from-spooler-options self first-spooling-host spooled-printer-options)
	    (set-cover-page-switch-from-spooler-options self first-spooling-host spooled-printer-options)
	    )))))))

(defun 2update-print-spooler-options-if-necessary0 ()
  (loop for pm in *printer-managers*
	do (update-printer-manager-from-namespace pm)))

1;;; Make sure the printer managers get new spooler options if the local
;;; host object has changed.
0(add-initialization "Update Print Spooler Options" '(update-print-spooler-options-if-necessary)
		    '(:normal) 'net:local-name-initialization-list)


(defmethod 2(set-timeout-threshold-from-spooler-options printer-manager)0 (host spooler-options)
  (let ((timeout-warnings-setting (second (assoc :warnings-after-timeout spooler-options)))
	(timeout-threshold-setting (second (assoc :printer-output-timeout spooler-options)))
	(warning-option-was-no nil))
    (when (and timeout-warnings-setting (stringp timeout-warnings-setting))
      (cond ((string-equal "YES" timeout-warnings-setting)
	     (setq timeout-threshold *default-timeout-threshold*))
	    ((string-equal "NO" timeout-warnings-setting)
	     (setf warning-option-was-no T)			;let the code below know
	     (setq timeout-threshold nil))
	    (T						;; invalid value
	     (send self :report-change-of-state-to-printer-manager
		   :problem
		   (format nil "The Spooler option WARNINGS-AFTER-TIMEOUT on Host ~A for Printer ~A has~&~
				    an invalid value. It must be Yes or No." host
			   (send printer :pretty-name))))))
    (when (and timeout-threshold-setting (stringp timeout-threshold-setting))
      (let ((timeout-interval (condition-case () (time:parse-interval-or-never timeout-threshold-setting)
				   (time:parse-error :error))))
	(if (eq timeout-interval :error)
	    (send self :report-change-of-state-to-printer-manager
		  :problem 
		  (format nil "The spooler option PRINTER-OUTPUT-TIMEOUT on Host ~A for Printer ~A has ~
				    an invalid value. It must be a string representing a valid time interval."
			  host (send printer :pretty-name)))
	    (unless warning-option-was-no
	      (setq timeout-threshold timeout-interval)))))
    1;; Let the log know what the current state is.
0    (send self :report-change-of-state-to-printer-manager
	  :log
	  (if (null timeout-threshold)
	      (format nil "The Printer Manager for Printer ~A will NOT check for Printer Output Timeouts."
		      (send printer :pretty-name))
	      (format nil "Printer Output Timeouts on Printer ~A will be reported after ~@\\presentation\\."
		      (send printer :pretty-name) timeout-threshold '((time:time-interval)))))
    ))

(defmethod2 (set-cover-page-switch-from-spooler-options0 2printer-manager)0 (host spooler-options)
  (let ((print-cover-page-setting (second (assoc :print-cover-page spooler-options))))
    (if print-cover-page-setting
	(cond ((string-equal "YES" print-cover-page-setting)
	       (setq print-cover-page t))
	      ((string-equal "NO" print-cover-page-setting)
	       (setf print-cover-page nil))
	      (T						;; invalid value
	       (send self :report-change-of-state-to-printer-manager
		     :problem
		     (format nil "The Spooler option PRINT-COVER-PAGE on Host ~A for Printer ~A has~&~
				    an invalid value. It must be Yes or No. The default will be taken instead." host
			     (send printer :pretty-name)))))
	(setq print-cover-page T))
    1;; Let the log know what the current state is.
0    (send self :report-change-of-state-to-printer-manager
	  :log
	  (format nil "The Printer Manager for Printer ~A will ~@[NOT~] print cover pages."
		  (send printer :pretty-name) (not print-cover-page))
	  )))



;; ** This binding of LOG-PROCESS-ID is totally bogus because it is completely unrelated to
;; which process is sending this message.  Fix later. **
(defmethod 2(su:with-access-path-logging-internal printer-manager)0 (continuation)
  (su:with-log-bindings continuation :log *print-spooler-log* :user-id "Printer Queue Server" :log-process-id "SE" :log-herald nil))

(defprop define-printer-manager "Printer Manager" si:definition-type-name)

(defmacro2 define-printer-manager0 (printer-type &key flavor)
  `(progn
     (record-source-file-name ,printer-type 'define-printer-manager)
     (defprop ,printer-type ,flavor printer-manager-flavor)
     (si:defflavor-with-parent (,printer-type define-printer-manager)
			       ,flavor () (printer-manager))))

(defun 2find-printer-manager-for-printer0 (printer &optional (error-p t))
  (loop for printer-manager in *printer-managers*
	when (eq (printer-manager-printer printer-manager) printer)
	  do (return printer-manager)
	finally (when error-p (signal 'unknown-printer :printer printer))))

(defun2 locally-managed-printers0 ()
  (loop for printer-manager in *printer-managers*
	collect (printer-manager-printer printer-manager)))

(defun2 set-up-printer-manager-for-printer0 (printer)
  (flet ((make-printer-manager-process (printer)
	   (let* ((process-name (format nil "Printer ~A" (or (send printer :pretty-name)
							     (send (send printer :name) :string))))
		  (process (make-process process-name)))
	     process)))
    (let ((existing-printer-manager (find-printer-manager-for-printer printer nil)))
      (let* ((printer-type (send printer :type))
	     (printer-interface (send printer :interface))
	     (printer-flavor (get printer-type 'printer-manager-flavor)))
	(if (null printer-flavor)
	    (su:log-event :problem
			  (format nil "For printer ~A: Printers of type ~A connected via a ~A interface are not supported."
				  (send printer :pretty-name) printer-type printer-interface))
	    (let ((printer-directory (get-printer-directory printer)))
	      (unless (su:probe-path :directory printer-directory)
		(su:create-server-directory printer-directory))
	      (if existing-printer-manager
		  (let ((printer-manager-process (or (printer-manager-process existing-printer-manager)
						     (make-printer-manager-process printer))))
		    (printer-shutdown existing-printer-manager)
		    (setf (printer-manager-process existing-printer-manager) printer-manager-process)
		    (process-preset printer-manager-process #'printer-manager-top-level existing-printer-manager)
		    (set-state (printer-manager-state existing-printer-manager) :uninitialized "setup for re-use")
		    (su:log-event :normal "Re-using existing printer manager for ~A" (send printer :pretty-name))
		    existing-printer-manager)
		  (let* ((printer-manager-process (make-printer-manager-process printer))
			 (printer-manager (make-instance printer-flavor :printer printer :process printer-manager-process)))
		    (process-preset printer-manager-process #'printer-manager-top-level printer-manager)
		    (push printer-manager *printer-managers*)
		    (su:log-event :normal "Creating printer manager for ~A" (send printer :pretty-name))
		    printer-manager))))))))

(defflavor 2printer-manager-control0 () (condition))

(defflavor 2shutdown
0	()
	(printer-manager-control)) 

(defmethod2 (:report shutdown)0 (stream)
  (ignore stream))

(defflavor 2intervention
0	(type
	 qid
	 extent
	 page-spec
	 disposition
	 reason
1	 ;; this gets set in the printer manager process
0	 error)
	(printer-manager-control)
  (:writable-instance-variables error)
  (:readable-instance-variables type   qid  extent  page-spec  disposition  reason  error)
  (:initable-instance-variables type   qid  extent  page-spec  disposition  reason  error)
  (:required-init-keywords      :type :qid :extent :page-spec :disposition :reason :error)) 

(defmethod 2(:report intervention)0 (stream)
  (ignore stream))

(defmethod2 (:proceed intervention :no-action)0 ()
  (when (null (car error))
    (rplaca error t)))

(defflavor2 asap-intervention0 () (intervention))

(defflavor2 after-extent-intervention0 () (intervention))

(defun 2start-printer-manager 0(printer-manager)
  (let ((process (printer-manager-process printer-manager)))
    (when process
      (process-enable process))))

(defun 2start-print-spooler 0()
  ;; This is needed until the log utilities (SU) knows how to
  ;; deal with this. The wait is necessary because on embedded hosts,
  ;; services may be enabled before the window system is up.
  (unless TV:*WINDOW-INITIALIZATIONS-RUN*
    (process-wait "Window Init" #'(lambda () TV:*WINDOW-INITIALIZATIONS-RUN*)))
  (fs:with-automatic-login-to-sys-host
    (let ((zl:user-id "Print-Spooler"))
      (initialize-log :cold)
      (let ((su:*log* *print-spooler-log*))
	(letf (((su:log-process-id su:*log*) "ST")
	       ((su:log-herald     su:*log*) "Manager Setup"))
	  (su:log-event :normal "Done initializing log")
	  (let ((printers (send net:*local-host* :spooled-printer)))
	    (su:log-event :normal "Starting printer managers for spooled printers")
	    (loop for (printer . nil) in printers
		  for printer-manager = (set-up-printer-manager-for-printer printer)
		  when printer-manager collect it into startees
		  finally (loop for startee in startees
				do (start-printer-manager startee)))
	    (su:log-event :normal "Done starting printer managers for spooled printers")
	    (su:log-event :normal "Done cold-booting Print Spooler")))))))

(defun 2halt-print-spooler 0()
  ;; This is needed until the log utilities (SU) know how to
  ;; deal with this. The wait is necessary because on embedded hosts,
  ;; services may be enabled before the window system is up.
  (unless TV:*WINDOW-INITIALIZATIONS-RUN*
    (process-wait "Window Init" #'(lambda () TV:*WINDOW-INITIALIZATIONS-RUN*)))
  (when *print-spooler-log*
    (let ((su:*log* *print-spooler-log*))
      (letf (((su:log-process-id su:*log*) "HA"))
	(letf (((su:log-herald   su:*log*) "Manager Shutdown"))
	  (loop for printer-manager in *printer-managers*
		do (printer-shutdown printer-manager)))
	(letf (((su:log-herald   su:*log*) "Log Shutdown"))
	  (shutdown-log))))))

;;; Start spooler at enable-services time when we have (at least) one printer
;;; and we offer (at least) hardcopy service.
;;; In theory, ADD-INITIALIZATION should be used to do this instead of
;;; defining property functions. 
(defun2 (:property :printer-queue neti:enable-services)0 (ignore)
  (when (and (send net:*local-host* :spooled-printer)
	     (assoc :hardcopy (send net:*local-host* :service)))
    ;; Spin off process because it'll go into output hold on
    ;; embedded systems until the window system is initialized.
    (process:process-run-function "Print Spooler Startup"
				  'start-print-spooler)))

(defun2 (:property :printer-queue neti:disable-services)0 (ignore)
  ;; Spin off process because it'll go into output hold on
  ;; embedded systems until the window system is initialized.
  (process:process-run-function "Print Spooler Shutdown"
				  'halt-print-spooler))


(defun2 request-from-qid0 (qid)
  (loop for printer-manager in *printer-managers*
	for request = (condition-case (error)
			   (get-request-with-qid (printer-manager-queue printer-manager) qid)
			 (entry-not-found nil))
	when request do (return request)
	finally (error 'entry-not-found :entry qid)))

(defmethod 2(queue-query printer-manager)0 (request-pattern-to-match request-data-to-return)
  `(,(when (member :queue-summary request-data-to-return)
       (multiple-value-bind (summary-string request-count) (summarize queue)
	 `(,(format nil "~A.~%~A for printer ~A~:[:~;.~]"
		    (summarize-status state)
		    summary-string
		    (send printer :pretty-name)
		    (zerop request-count)))))
    ,@(map-over-matching-requests
	queue
	#'(lambda (request)
	    (loop for returnee in request-data-to-return
		  unless (eq returnee :queue-summary)
		  for datum = (get-request-property request returnee)
		  when datum nconc `(,returnee ,datum) into data
		  finally (when data (return `(,(get-request-property request :qid) ,@data)))))
	request-pattern-to-match)))

(defmethod 2(queue-modify-entry printer-manager)0 (qid property value)
  (let ((request (get-request-with-qid queue qid)))
    (set-request-property request property value)
    (save request)))

(defmethod2 (queue-delete-entry printer-manager)0 (qid)
  (let ((request (get-request-with-qid queue qid)))
    (delete-request-from-queue queue request)
    (destroy request)))

(defmethod 2(queue-query-policies printer-manager) 0()
  (loop for (constraint . (range reject-p)) on (su:list-properties-and-values queue-policies) by #'cddr
	collect `(,constraint ,range ,reject-p)))

(defmethod2 (queue-modify-policy printer-manager)0 (constraint value rejection)
  (let* ((template (get-queue-policy-template constraint))
	 (desired-type (queue-policy-template-type template)))
    (unless (typep value desired-type)
      (signal 'bad-constraint-value :constraint constraint :value value))
    (su:set-property queue-policies constraint `(,value ,rejection))))



(defmethod2 (printer-query-characteristics printer-manager)0 ()
  (su:list-properties-and-values printer-characteristics))

(defmethod2 (printer-modify-characteristic printer-manager)0 (characteristic value)
  (let* ((template (get-printer-characteristic-template characteristic))
	 (desired-type (printer-characteristic-template-type template)))
    (unless (typep value desired-type)
      (signal 'bad-characteristic-value :characteristic characteristic :value value))
    (su:set-property printer-characteristics characteristic value)))



(defun2 intervene-in-process0 (process type qid urgency extent page-spec disposition reason)
  (declare (values error-object-or-nil))
1  ;; arg check in the(3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI") user1 process, since it's so painful to blow out in printer manager.
  ;; 2boldfaced1 keywords below are "escape clauses"
0  (ecase type ((:restart :suspend :reset)))
  (unless (member urgency '(:asap :after-extent))
    (signal 'unknown-urgency :urgency urgency))
  (unless (member extent '(:entire :copy 2:reset0))
    (signal 'unknown-extent :extent extent))
  #| Page Spec Extent Control Not Fully Implemented |
  (unless 2(and (eq type :reset) (eq page-spec :reset))
0    (unless (member (first page-spec) `(:abs :+ :-))
      (signal 'unknown-page-spec :page-spec-type (first page-spec) :page-spec-value (second page-spec)))
    (unless (typep (second page-spec) '(integer 0 *))
      (signal 'bad-page-spec-value :page-spec (first page-spec) :value (second page-spec))))
  ||#
  (unless (member disposition '(:restart :hold :delete))
    (signal 'unknown-disposition :disposition disposition))
  (unless (typep reason '(string *))
    (signal 'bad-reason-value :reason reason))
  (let ((error (ncons nil)))
    (process-interrupt process
	  #'signal (ecase urgency
		     (:asap 'asap-intervention)
		     (:after-extent 'after-extent-intervention))
	  :type type
	  :qid qid 
	  :extent extent
	  :page-spec page-spec
	  :disposition disposition
	  :reason reason
	  :error error)
    (process-wait "Printer Intervention" #'(lambda () (not (null (first error)))))
    (let ((result (first error)))
      ;; If the callers wouldn't understand it, don't bother returning it.  This also
      ;; turns T [meaning successfull completion] into '() [meaning no returned values].
      (when result
	(when (typep result 'printer-queue-protocol-error)
	  result)))))


(defmacro 2resignalling-any-printer-manager-error0 (&body body)
  (let ((error (gensym)))
    `(let ((,error (progn
		       ,@body)))
       (when ,error
	 (apply #'signal (type-of ,error) `(,@(error-variables-and-values ,error)))))))

(defmacro2 if-active-printer-manager-process0 ((process printer-manager) &body body)
  `(let ((,process (printer-manager-process ,printer-manager)))
    (when (and ,process
	       (null (send ,process :arrest-reasons))
	       (not (null (send ,process :run-reasons))))
      . ,body)))

(defmethod2 (printer-shutdown printer-manager)0 ()
  (if-active-printer-manager-process (process self)
    (progn
      (su:log-event :normal "Ordering ~A to halt" (send printer :pretty-name))
      (send process :interrupt #'signal 'shutdown))))

(defmethod2 (printer-reset printer-manager) 0(printer qid disposition reason)
  (if-active-printer-manager-process (process self)
    (resignalling-any-printer-manager-error
      (su:log-event :normal "Resetting printer ~A, request: ~A, disposition: ~A, reason: ~A"
		    (send (printer-from-printer-string printer) :pretty-name) (or qid "None") disposition
		    (or reason "Unknown"))
      (intervene-in-process process :reset qid :asap :reset :reset disposition reason))))

(defmethod2 (printer-restart printer-manager)0 (printer qid extent page-spec)
1  ;; QID should always be provided, although this code is capable of handling a QID of NIL.
0  (if-active-printer-manager-process (process self)
    (let ((printer-manager (find-printer-manager-for-printer
			     (printer-from-printer-string printer))))
      (let* ((request (if qid (get-request-with-qid queue qid)
1			  ;; If QID is not provided, get the QID of the request being printed.
0			  (first (second (queue-query printer-manager '(:state :being-printed) '(:qid))))))
	     (request-state (when request (request-state request))))
	(case request-state
	  (:held
	    1;; But request back to :Waiting-to-be-printed
0	    1;; Since it's on hold, there's no timing issue here with
0	    1;; the printer manager process.
0	    (change-request-disposition
	      printer-manager
	      request :restart)
	    '(:held)
	    )
	  (:being-printed 
	    (su:log-event :normal "Restarting printer ~A, request: ~A, extent: ~A, page-spec: ~A"
			  (send (printer-from-printer-string printer) :pretty-name)
			  (or qid "None") extent page-spec)
	    (resignalling-any-printer-manager-error
	      (intervene-in-process process :restart qid :asap extent page-spec :restart "request restarted"))
	    '(:being-printed))
	  (otherwise
	    ;; We can't do anything with it.
	    (ncons request-state)
	    ))))))

(defmethod2 (printer-suspend printer-manager)0 (printer qid urgency extent page-spec disposition reason)
  (ignore printer)
  (if-active-printer-manager-process (process self)
    (resignalling-any-printer-manager-error
      (su:log-event :normal "Suspending printer ~A, request ~A, urgency ~A, extent ~A, page-spec ~A, disposition ~A, reason ~A"
		    (send (printer-from-printer-string printer) :pretty-name)
		    qid urgency extent page-spec disposition reason)
      (intervene-in-process process :suspend qid urgency extent page-spec disposition reason))))

(defmethod2 (printer-resume printer-manager)0 (printer)
  (when process
    (when (eq (printer-manager-state-state state) :suspended)
      (su:log-event :normal "Resuming printer ~A" (send (printer-from-printer-string printer) :pretty-name))
      (set-state state :idle "printer resumed"))
    (process-enable process)))




(defmethod 2(validate-printer printer-manager)0 ()
1  ;; some namespace magic
0  )

1;;; Default method rebuilds the stream to avoid being stuck in xoff
;;; or similar condition (i.e. start from scratch.)
0(defmethod 2(reset-printer-stream printer-manager)0 ()
  (close-printer-stream self)
  (let ((new-stream (open-printer-stream self)))
    (unless new-stream
      (error "Stream for printer ~A wasn't created or returned" printer))
    (setf stream new-stream)))

(defmethod2 (close-printer-stream printer-manager)0 ()
  (when stream
    (send stream :close :abort)
    (setf stream nil)))

(defmethod 2(open-printer-stream printer-manager)0 ()
  (let ((printer-host (send printer :host)))
    (if (neti:ns-eq printer-host net:*local-host*)
	(send printer
	      :hardcopy-hardware-stream
	      :printer printer
	      :status-message-routing `(:printer-manager-notification ,self))
	1;; +++ This needs badly to be rethought.
0	(net:invoke-service-on-host :hardcopy printer-host printer '(:direct t)))))

(defmethod 2(:report-change-of-state-to-printer-manager printer-manager) 0(type description)
  ;; Device errors should be sent to the log as well as problems/log entries.
  (let ((log-type (cond ((member type '(:irrecoverable-device-error :recoverable-device-error))
			 :problem)
			((member type '(:log :operational :informational)) :normal)
			(t type))))
    (su:log-event log-type "~A" description))
  ;; Notify users of change of printer state or if disaster struck.
  (when (or (member type '(:irrecoverable-device-error :recoverable-device-error :disaster))
	    (and (eq type :operational) (neq (printer-manager-state-device-state state) :operational)))
    (notify-users-of-printer-manager
      self
      (case type
	((:irrecoverable-device-error :disaster) "Irrecoverable error on printer \"~A\": ~A")
	(  :recoverable-device-error "Printer \"~a\" needs intervention: ~A")
	(:operational "Printer \"~a\" is now operating: ~A"))
      (send printer :pretty-name)
      description))
  ;; if type is one of :irrecoverable-device-error, :recoverable-device-error, or :operational
  ;; Then the printer state changed. Otherwise, the report is about the printer manager
  ;; itself.
  (when (member type '(:irrecoverable-device-error :recoverable-device-error :operational))
    (note-change-of-state state type description)))


(defgeneric2 start-request0 (printer-manager request)
  (:method (printer-manager :default) (ignore request)))
(defgeneric 2print-start-header0 (printer-manager request)
  (:method (printer-manager :default) (ignore request)))
(defgeneric 2print-error-log0 (printer-manager request)
  (:method (printer-manager :default) (ignore request)))
(defgeneric 2print-end-header0 (printer-manager request)
  (:method (printer-manager :default) (ignore request)))
(defgeneric 2end-request0 (printer-manager request)
  (:method (printer-manager :default) (ignore request)))

(defmethod 2(request-prelude printer-manager)0 (request)
  (start-request self request)
  (when (and print-cover-page
	     (get-request-property request :print-cover-pages))
    (print-start-header self request))
  (send stream :force-output)
  (send stream :finish))

(defmethod2 (request-postlude printer-manager)0 (request)
  (print-error-log self request)
  (when (and print-cover-page
	     (get-request-property request :print-cover-pages))
    (print-end-header self request))
  (end-request self request)
  (send stream :force-output)
  (send stream :finish))

(defmethod2 (log-request-completion printer-manager)0 (request &optional completion-note)
  (let ((title (get-request-property-as-string request :title)))
    (su:log-event :normal "Printed \"~A\"~@[ ~A~]"
		  title completion-note)))

(defmethod2 (change-request-disposition printer-manager)0 (request disposition)
  (ecase disposition
    (:delete
      (set-request-state request :deleted)
      (delete-request-from-queue queue request)
      (destroy request))
    (:restart
      (set-request-state request :waiting-to-be-printed)
      (save request))
    (:hold
      (hold request))))

(defmethod2 (users-of-printer-manager printer-manager)0 ()
  (declare (values table-by-host))
  (let* ((parties-for-all-requests (map-over-matching-requests
				     queue
				     #'(lambda (r) (interested-parties r))
				     '()))
	 (table-by-host (make-hash-table :test #'eq	1;Should really be 2neti:ns-eq1!
0					 :size (length parties-for-all-requests))))
    (loop for parties-per-request in parties-for-all-requests do
      (loop for (user host) in parties-per-request
	    do (cl:push user (gethash host table-by-host))))
    table-by-host))

(defmethod2 (notify-users-of-printer-manager printer-manager)0 (format-ctl-string &rest args)
  (let ((notification (apply #'format nil format-ctl-string args))
	(table-by-host (users-of-printer-manager self)))
    (loop for users-on-host being the hash-elements of table-by-host with-key host
	  for system-type = (send host :system-type) do
      (if (eq system-type :lispm)
	  1;; If we were really politically correct here, we'd either finger the
0	  1;; host to see who's on it right now, or we'd extract the user by
0	  1;; looking at the most recently queued request.  Using #'last here
0	  1;; is a cheap approximation to this last.
0	  (notify-user-at-host (first (last users-on-host)) host notification)
	  (loop for user in users-on-host do
	    (notify-user-at-host user host notification))))))


1;;; This method sends a message to the owner of a new request if the printer
;;; is currently in an error state.
0(defmethod2 (notify-user-if-printer-nonoperational printer-manager-state)0 (new-request)
  (unless (and (eq device-state :operational) (member state '(:idle :printing)))
    (notify-parties-to-request
      new-request
      "~A~&Your request will not be printed until the ~
				~:[printer~;spooler~] is operational again."
      (if (eq device-state :operational)
				   ;;; Spooler is wedged. 
	  (format nil "The spooler for ~A is ~@(~A~)~:[~;: ~A~]"
		  (send (request-printer new-request) :pretty-name)
		  state
		  (and reason (not (string-equal reason state)))
		  reason)
	  (format nil
		  (case device-state
		    ((:irrecoverable-device-error :disaster) "Irrecoverable error on printer \"~A\": ~A")
		    (  :recoverable-device-error "Printer \"~a\" needs intervention: ~A")
		    1;; This clause shouldn't be called, but just in case.
0		    (otherwise "The printer \"~A\" has the following problem: ~A"))
		  (send (request-printer new-request) :pretty-name)
		  device-state-description))
      (eq device-state :operational))))




(defun-in-flavor2 (log-intervention-in-request printer-manager)0 (intervention request copies-printed)
  (notify-parties-to-request request "Your request of ~A (\"~A\"), printing on ~A, has been ~A;~:
                                      ~A copies were printed before this intervention.~:
                                      The request will be ~A.~:
                                      ~@[Reason given was ~A~]"
			     (get-request-property-as-string request :queue-entry-time)
			     (get-request-property-as-string request :title)
			     (send printer :pretty-name)
			     (case (intervention-type intervention)
			       (:restart "restarted")
			       (:suspend "suspended")
			       (:reset   "reset"))
			     copies-printed
			     (case (intervention-disposition intervention)
			       (:restart "restarted")
			       (:delete  "deleted")
			       (:hold    "held"))
			     (intervention-reason intervention)))

(defun-in-flavor 2(log-problem-and-hold-request printer-manager)0 (problem-description request)
  (notify-parties-to-request request
			       "The following problem occured printing your request of ~A (\"~A\");~@
				~A ~A.~@
				Your request will be held for later processing."
			       (get-request-property-as-string request :queue-entry-time)
			       (get-request-property-as-string request :title)
			       problem-description
			       (send printer :pretty-name))
  (su:log-event :problem "~A ~A while printing a request for ~A~@
                          (request ~A, titled \"~A\");~@
                          the request will be held for later processing."
		problem-description
		(send printer :pretty-name)
		(get-request-property-as-string request :recipient)
		(get-request-property-as-string request :qid)
		(get-request-property-as-string request :title))
  (change-request-disposition self request :hold))


(export '2*warn-after-printer-timeout*0)
(defvar2 *warn-after-printer-timeout*0 t
  "Boolean value that indicates whether or not to warn about printer timeouts.
This value (in combination with the 'warn' value per printer) controls timeout warnings.")

;; This method is called when the device stream has timed out trying
;; to output data to the printer. This occurs when the process is
;; stuck in "Serial Out" or "Serial Finish" for longer than the timeout
;; period (normally 2 minutes). If the process/stream is "stuck" (often
;; by an Xoff) then printer may be "hung" ; however, the printer may just
;; be taking a long time (Postscript programs may run for hours!)
;;
;; The goal of this method is let the users (and "print spooler manager")
;; know that a timeout has occured sending data to the printer. 
;; Normally (the non-fatal case), just a notification is enough. However,
;; if FATAL is T, then we scream until we get help.
;;
;; Small nit: Serial Timeouts can occur at input time as well as 
;; output. However: 1) the same timeout rules hold and 2) 
;; They most likely occur here since the printer is generally a
;; one-way device. The exception to this rule is LGP2/3 status
;; messages, but those are handled by code that has its own timeout.
;;
;; NOTE: This timeout is low level and is NOT the same as 
;; the lgp2's timeout waiting for a SYNC character to be returned
;; by the printer. 
;;
;; Timeouts are reported given the following conditions:
;;    - The global *WARN-AFTER-PRINTER-TIMEOUT* is T.
;;    - The special *CURRENT-TIMEOUT-THRESHOLD* (initially set from
;;         the printer-manager IV TIMEOUT-THRESHOLD) is a non-nil time interval.
;;    - The printer stream returns a non-nil timeout value (number).
;;    - The total timeout time is greater than the timeout threshold.
;;
;; The timeout count for the stream is reset upon entry into the
;; request loop.
;; 
(defmethod2 (handle-device-output-timeout printer-manager)0 (cond &key (fatal nil))
1  ;; This method does not handle requests. Therefore, either FATAL should only be T
  ;; when no request is being handled or the caller of this method must "dispose of"
  ;; the request before calling this.
  ;; Also: when the pm has a threshold, but we're not withing the 
  ;; with-request-timeout-checking macro, then it's fatal.
0  (when (or fatal1							; stream is stuck in serial-out or whatever0.
	    (and timeout-threshold
		 (null *current-timeout-threshold*)))
    ;; To be caught by the top-level loop 
    (error 'hardcopy:device-not-responding
	   :printer printer
	   :stream stream
	   :stimulus-description "output being sent"
	   :expected-response "continue accepting data.")
    )
  (when (and *current-timeout-threshold* *warn-after-printer-timeout*)
    1;; The process timed out trying to output characters to stream.
0    1;; If we hit a timeout threshold, tell all interested parties.
0    (let ((timeout-count (hci::basic-printer-stream-timeout-count stream))
	  (timeout-length (hci::get-stream-timeout stream)))	;60th of seconds or NIL
      (when timeout-length
	(let ((total-timeout (* (round timeout-length 60) timeout-count)))	;convert to seconds.
	  (when (>= total-timeout *current-timeout-threshold*)
	    (send self :report-change-of-state-to-printer-manager
		  :recoverable-device-error
		  (format nil
			  "The printer has not responded in ~@\\presentation\\ while~@
			   printing the current request.~@
	    		   You may want to see if ~
 			   the printer is still operating." total-timeout '((time:time-interval))))
	    ;; Up the timeout-threshold - increase the *current-timeout-threshold* by a multiple.
	    (setf *current-timeout-threshold*
		  (round
		    (* *current-timeout-threshold*
		       (if (= *current-timeout-threshold* timeout-threshold) 2 1.5)))))))))
  ;; Continue as if nothing happened.
  (send cond :proceed :continue))

(defun-in-flavor2 (handle-request-hardcopy-error printer-manager)0 (e)
  (declare (special request))
  (su:log-event :problem "~A" e)
  (when request
    1;; Treat like an asap Restart Hold, so the user doesn't have to recreate the bits
0    1;; for the device, yet the request doesn't jam up the queue.
0    (etypecase e
      (hardcopy:irrecoverable-device-error
	(log-problem-and-hold-request "Irrecoverable device error on" request)
	(reset-printer-stream self)
	(request-postlude self request))
      (hardcopy:device-not-responding
	(log-problem-and-hold-request "Couldn't get response from" request))
      (hardcopy:nonexistent-device
	(log-problem-and-hold-request "Lost signal path to" request)))
    (setf request nil))
  (typecase e
    (hardcopy:nonexistent-device
      (signal 'hardcopy:nonexistent-device :printer printer))
    (hardcopy:device-not-responding
      (signal 'hardcopy:device-not-responding
	      :stimulus-description (send e :stimulus-description)
	      :expected-response (send e :expected-response)
	      :stream (send e :stream)
	      :printer printer))))

(defun-in-flavor2 (handle-asap-intervention printer-manager)0 (e)
  (declare (special request))
  (let ((qid (or (intervention-qid e)
		 (when request
		   (get-request-property request :qid)))))
    (cond ((and qid
		(or (null request)
		    (not (string-equal qid (get-request-property request :qid)))))
	   (setf (first (intervention-error e))
		 (make-instance 'entry-not-printing :entry qid)))
	  #| *** No longer Needed |
	  ((and (null qid)
		request)
	   (setf (first (intervention-error e))
		 (make-instance 'entry-is-printing :entry (get-request-property request :qid))))
	  ||#
	  (t
	   (reset-printer-stream self)
	   (when request
	     (request-postlude self request))
	   (ecase (intervention-type e)
	     (:restart
	       (when request
		 (close-any-data-stream request)))
	     ((:suspend :reset)
	      (when (eq (intervention-type e) :suspend)
		(set-state state :suspended (intervention-reason e)))))
	   (when request
	     (change-request-disposition self request (intervention-disposition e)))
	   (setf request nil)
	   (setf (first (intervention-error e)) t)))))

(defun2 handle-after-extent-intervention0 (e)
  (declare (special after-extent-intervention request))
  (let ((qid (intervention-qid e)))
    (if qid
	(if (and request (string-equal qid (get-request-property request :qid)))
	    (progn
	      (setf after-extent-intervention e)
	      (setf (first (intervention-error e)) t)
	      (send e :proceed :no-action))
	    (progn
	      (setf (first (intervention-error e)) (make-instance 'entry-not-printing :entry qid))
	      (send e :proceed :no-action))
	    (if request
		(progn
		  (setf (first (intervention-error e))
			(make-instance 'entry-is-printing :entry (get-request-property request :qid)))
		  (send e :proceed :no-action))
		1;; If there is no current extent, then after-extent intervention reduces to ASAP.
0		(signal 'asap-intervention
			:type (intervention-type e)
			:qid nil
			:extent (intervention-extent e)
			:page-spec (intervention-page-spec e)
			:disposition (intervention-disposition e)
			:reason (intervention-reason e)
			:error (intervention-error e)))))))

(defmethod 2(print-request printer-manager)0 (request)
  (declare (special after-extent-intervention))
  (block printing-request
    (request-prelude self request)
    (with-open-stream (real-data-stream (get-data-stream request :input))
      (loop with data-stream = (if (subtypep (stream-element-type stream)
					     'cl:character)
				   (si:thin-character-stream real-data-stream)
				   real-data-stream)
	    with starting-point = (send data-stream :read-location)
	    for first-time first t then nil
	    for copy from 1
	    for number-of-copies = (or (get-request-property request :copies) 1)
	    while ( copy number-of-copies) do
		   
	(unless first-time (send data-stream :set-location starting-point))
	1;; someday handle page-extent synchronous intervention in here
0	(stream-copy-until-eof data-stream stream)
	(send stream :force-output)
	(send stream :finish)
		   
	1;; handle copy-extent synchronous intervention
0	(when (and after-extent-intervention
		   (eq (intervention-extent after-extent-intervention) :copy))
	  (request-postlude self request)
	  (log-intervention-in-request after-extent-intervention request
				       (format nil "~D" copy))
	  (change-request-disposition self request
				      (intervention-disposition after-extent-intervention))
	  (ecase (intervention-type after-extent-intervention)
	    (:restart
	      (decf copy))
	    (:suspend
	      (set-state state :suspended
			 (intervention-reason after-extent-intervention))
	      (return-from printing-request))
	    (:reset
	      (reset-printer-stream self)
	      (return-from printing-request))))))
    (request-postlude self request)
		 
    1;; handle request-extent synchronous intervention
0    (when (and after-extent-intervention
	       (eq (intervention-extent after-extent-intervention) :entire))
      (handle-request-extent-intervention self after-extent-intervention request)
      (return-from printing-request))
    1;; handle no intervention at all...
0    (finish-request self request)
    ))

(defmethod2 (handle-request-extent-intervention printer-manager)0 (intervention request)
  (change-request-disposition self request
			  (intervention-disposition intervention))
  (log-intervention-in-request intervention request "all")
  (ecase (intervention-type intervention)
	1;; if you want to restart the request, then up the copy count.
0	(:restart)
	(:suspend
	  (set-state state :suspended (intervention-reason intervention)))
	(:reset 
	  (reset-printer-stream self))))


(defmethod2 (finish-request printer-manager)0 (request)
  (log-request-completion self request)
  (notify-parties-to-request request
			       "Your request of ~A (\"~A\") has finished printing on ~A."
			       (get-request-property-as-string request :queue-entry-time)
			       (get-request-property-as-string request :title)
			       (send printer :pretty-name))
  (change-request-disposition self request :delete))

1;; This Function checks to see whether the printer is even responding
;; before handling a new print request. Each printer-manager flavor
;; should have the appropriate methods define for this function that 
;; "Do The Right Thing".
;;
;; The default method only knows how to check if the printer exists.
0(defgeneric 2check-printer-status0 (printer-manager)
  (:method (printer-manager :default)
1   ;; Just in case the printer stream doesn't reset the timeout counter itself.
0   (hci::reset-timeout-counter stream)
   (unless (send stream :exists-p)
     (signal 'hci:nonexistent-device :printer printer))))

(defun-in-flavor 2(wait-for-request printer-manager)0 (request)
  (process-wait (if (eq (printer-manager-state-state state) :suspended)
		    "Suspended"
		    "Idle")
    #'(lambda (current-request)
	(unless (or (eq (printer-manager-state-state state) :suspended)
		    (eq (printer-manager-state-state state) :idle))
	  (set-state state :idle "idle"))
	(and (not (eq (printer-manager-state-state state) :suspended))
	     (or current-request (not (request-queue-nothing-waiting-to-be-printed queue)))))
    request)
1  ;; Check printer status after exiting the wait.
0  (check-printer-status self))



(defun-in-flavor 2(request-loop printer-manager)0 ()
  (let ((after-extent-intervention nil)
	(request nil))
    (declare (special after-extent-intervention request))
    (loop doing
      (unwind-protect
	  (with-request-timeout-checking (self)			1; set up request timeout checking
0	    (condition-case (e)
	     (condition-bind
	       ((after-extent-intervention
		  'handle-after-extent-intervention))
	       (wait-for-request request)
	       1;; Get next request
0	       (when (null request) (setf request (highest-priority-request-in-queue queue)))
	       (set-state state :printing "printing")
	       (set-request-state request :being-printed)

	       (print-request self request)
	       1;; cleanup from print0-1request block
0	       (setf request nil)
	       (setf after-extent-intervention nil))
	 
	   1;; handler for asap-intervention; 3e1 is bound to condition object
0	   (asap-intervention
	     (handle-asap-intervention e))
	 
	   ((hardcopy:irrecoverable-device-error
	      hardcopy:device-not-responding
	      hardcopy:nonexistent-device)
	    (handle-request-hardcopy-error e))
	 
	   (shutdown
	     (when request
	       1;; Set this one up as eligible to print when we set up shop again.
0	       (set-request-state request :waiting-to-be-printed)
	       (save request))
	     1;; Now resignal, so that our caller runs the neccessary unwind-protects.
0	     (signal 'shutdown))))
1	;; Clean up the request if it still is in a "printing" state.
0	(when (and request
		   (eq (request-state request) :being-printed))
	  ;; Either the process got reset or Something bad happened.
	  (log-problem-and-hold-request "The printing process was aborted/reset for" request))))))




(defmethod2 (handle-top-level-hardcopy-error printer-manager)0 (original-error)
  ;; Called if a hardcopy-error occurs while the printer stream is being opened.
  ;;
  ;; Make sure device state is correct.
  (note-change-of-state state :irrecoverable-device-error
			(format nil "~A" original-error))
  (let ((type-of-last-error nil))
    (flet ((handle-nonexistent-device (error)
	     (when (neq type-of-last-error 'handle-nonexistent-device)
	       (su:log-event :problem
			     "Printer ~A doesn't seem to be attached to this machine;~@
			      Spooler will periodically check to see if it is attached."
			     (send (send error :printer) :pretty-name))
	       (setq type-of-last-error 'handle-nonexistent-device)))
	   (handle-device-not-responding (error)
	     (when (neq type-of-last-error 'handle-device-not-responding)
	       (su:log-event :problem
			     "Printer ~A doesn't seem to be responding;~@
			      Spooler will periodically check to see if starts to behave normally."
			     (send (send error :printer) :pretty-name))
	       (setq type-of-last-error 'handle-device-not-responding))
	     (let ((recalcitrant-stream (send error :stream)))
	       (when recalcitrant-stream
		 1;; Device-not-responding errors might already have an open stream
0		 1;; by the time the error is signalled.  Close it this way instead
0		 1;; of (setf stream recalcitrant-stream) and (close-printer-stream)
0		 1;; because we might be unwound before we got a chance to abort
0		 1;; recalcitrant-stream, and thus not be able to prevent the spread
0		 1;; of the unresponsive stream.
0		 (send recalcitrant-stream :close :abort)))))
      (etypecase original-error
	(hardcopy:nonexistent-device (handle-nonexistent-device original-error))
	(hardcopy:device-not-responding (handle-device-not-responding original-error)))
      (loop named find-stream-to-printer do
	(condition-case (recurring-error)
	     (progn
	       (si:process-sleep (floor (* 60 60 2.5)) "Where's the printer?")
	       (condition-case (cond)
		    (setf stream (open-printer-stream self))
		  (hci::device-output-timed-out
		    (handle-device-output-timeout self cond :fatal t))))
	   (hardcopy:nonexistent-device
	     (handle-nonexistent-device recurring-error))
	   (hardcopy:device-not-responding
	     (handle-device-not-responding recurring-error))
	   (:no-error
	     (let ((notify-string (format nil "Printer ~A is attached and responding again."
					  (send printer :pretty-name))))
	       (send self :report-change-of-state-to-printer-manager
		     :operational notify-string)
	       (return-from find-stream-to-printer nil))))))))

(defmethod (2handle-intervention-at-top-level printer-manager)0 (e)
1  ;; No requests at this level to deal with.
0  (ecase (intervention-type e)
    (:suspend
      (set-state state :suspended (intervention-reason e)))
    (:restart)
    (:reset
      (condition-case (ignore)
	   (when stream
	     (reset-printer-stream self))
	 ((hardcopy:nonexistent-device
	    hardcopy:device-not-responding) nil))))
  (send e :proceed :no-action))

;;  Borrowed and modified from the Mailer.
(defmethod2 (top-level-error printer-manager)0 (error)
  (typecase error
    ;; Currently no special error handled.
    (otherwise
      (set-state state :crashed (dbg:report-string error))
      (su:log-event :disaster "Error in process ~A of type ~A~%~A"
		    (process-name scl:*current-process*) (zl:typep error) error)
      nil)))

(defmethod 2(printer-manager-top-level printer-manager)0 ()
  (fs:with-automatic-login-to-sys-host
    (let ((zl:user-id "Print-Spooler")
	  (su:*log* *print-spooler-log*))
      (letf (((su:log-process-id su:*log*) "MA")
	     ((su:log-herald     su:*log*) (format nil "~A" (send (send printer :name) :string))))
	(condition-bind-default ((intervention #'(lambda (e) (send e :proceed :no-action)))
				 (error #'(lambda (e) (top-level-error self e))))
1	  ;; Get up to date info from namespace
0	  (error-restart (error "Restart the Printer Manager for ~A" printer)
	  (update-printer-manager-from-namespace self)
1	  ;; This loop is run through every time the printer is connected.  If someone trips
	  ;; over the cable and pulls it out, the error is signalled, any request is held,
	  ;; the error is resignalled, we catch it and run this loop again.
0	  (loop doing
	    (condition-case (condition)
		 (unwind-protect
		     (condition-case (original-error)
			  (condition-bind
			    ((intervention
			       'handle-intervention-at-top-level)
			     (hci::device-output-timed-out
			       1;; perhaps stuck in serial-out/serial-finish? Or just waiting for postscript
0			       1;; to churn away? At least let the user and spooler manager know.
0			       #'(lambda (condition)
				   (handle-device-output-timeout self condition))))
			    1;; What do we do if these forms fail?
0			    (set-state state :booting "booting")
			    (close-printer-stream self)
			    (setf stream (open-printer-stream self))
			    (su:restore printer-characteristics)
			    (su:restore queue-policies)
			    (restore queue)
			    (letf (((su:log-herald su:*log*) (send printer :pretty-name)))
			      (request-loop)))
			((hardcopy:nonexistent-device
			     hardcopy:device-not-responding)
			   (handle-top-level-hardcopy-error self original-error)))

		   (when stream
1		     ;; Kill it now. Upon re-entry of the loop the stream
		     ;; will be regenerated.
0		     (close-printer-stream self)))
	       
	       1;; If we have trouble on the :close :abort, just ignore it.
0	       ((hardcopy:nonexistent-device
		  hardcopy:device-not-responding) nil)
	       
	       (shutdown
		 (close-printer-stream self)	; make dead sure it's closed!
		 (set-state state :suspended "Operator shutdown")
		 (send process :arrest-reason "shutdown")
		 1;; Arresting a process doesn't take until the first process-wait.
0		 (sleep 1 :sleep-reason "Await Arrest"))))))))))




1;;; +++ This is here for the benefit of the olde LGP-QUEUE server.  Remove before
;;; +++ Release 8 ships, perhaps.

0(defun 2print-old-style-queue-listing0 (printer stream)
  (let ((pretty-name (send printer :pretty-name))
	(printer-manager (find-printer-manager-for-printer printer nil)))
    (when printer-manager
      (format stream "~%")
      (map-over-matching-requests
	(printer-manager-queue printer-manager)
	#'(lambda (r)
	    (format stream "~&For ~A: Request of ~A for ~A"
		    pretty-name
		    (get-request-property-as-string r :queue-entry-time)
		    (get-request-property-as-string r :title)))
	'()))))
