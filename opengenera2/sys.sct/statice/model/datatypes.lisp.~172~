;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice-model; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
 
;;; Given a presentation type and the null-ok flag, create and return
;;; a handler instance of the appropriate flavor.
(defun get-storage-handler (presentation-type no-nulls &key (if-does-not-exist :error))
  (multiple-value-bind (class type)
      (get-storage-handler-class presentation-type no-nulls
				 :if-does-not-exist if-does-not-exist)
    (when class
      (make-instance class
		     :original-presentation-type presentation-type
		     :presentation-type type
		     :no-nulls no-nulls))))

;;; Note that the info is now a class name - jga 10 Sept 92

(dw::defmethod-type-descriptor (presentation-type-statice-info dw:presentation-type-descriptor
							       :search-p nil)
			       ()
  (dw::handler-or dw::statice-info))

;;; Given a presentation type and the null-ok flag, return the handler
;;; class and the looked-up presentation type.  (Used to be get-storage-handler-flavor - jga 10 Sept 92.)
(defun get-storage-handler-class (presentation-type no-nulls &key (if-does-not-exist :error))
  (cond ((dw:presentation-type-p presentation-type)
	 (multiple-value-bind (class type)
	     (dw::with-type-method ((type info)
				    presentation-type #'dw::presentation-type-statice-info
				    :error-p nil)
	       (values
		 (ecase (first info)
		   (:class (second info))
		   (:function (funcall (second info) type no-nulls)))
		 type))
	   (values (cond (class)
			 ((eq if-does-not-exist :error)
			  (error "Statice does not know how to store values of type ~S"
				 presentation-type))
			 (t nil))
		   type)))
	((eq if-does-not-exist :error)
	 (error "Statice does not know how to store values of type ~S"
		presentation-type))
	(t nil)))

;;; Set the statice-info for a given presentation-type.  The
;;; statice-info should either be (:class storage-handler-name) or
;;; (:function storage-handler-finder).
(defun set-statice-info (presentation-type statice-info)
  (cl:setf (dw::presentation-type-statice-info
	  (dw:presentation-type-descriptor presentation-type))
	statice-info)
  ;; The following form clears statice-info out of the DW caches so that
  ;; the setf below will actually take effect.
  (maphash #'(cl:lambda (key value)
	       (cl:ignore value)
	       (when (eq (first key) #'presentation-type-statice-info)
		 (remhash key dw::*type-method-cache*)))
	   dw::*type-method-cache*)
  ;; This is to help speed up presentation-type-p, which see.
  (when (symbolp presentation-type)
    (cl:setf (get presentation-type 'statice-presentation-type) t)))

;;; Macro to generate the usual body of the check-spec method.  Note
;;; that the argument to the method must be named spec.  Both subforms
;;; are evaluated.
;;; Note that '(null . anything) is allowable.
(defmacro check-spec-standard (type operator-list &optional (typep-function 'typep))
  `(or (,typep-function spec ,type)
       (and (listp spec)
	    (or (and (= (length spec) 2)
		     (member (first spec) ,operator-list)
		     (,typep-function (second spec) ,type))
		(eq (first spec) 'null)))))

;;; TEMPORARILY MOVED TO DEFS.LISP DUE TO FLAVOR SYSTEM PROBLEM
;;;  Even after the CLOS conversion, I left the definition in DEFS.LISP - jga 11 Sept 92
;;; Base flavor for all storage handlers.
;;; (defflavor storage-handler () ()
;;;   (:required-methods statice-typep read-value))

;;; This gets used when we make an attribute with a logical type whose
;;; ultimate implementation is a built-in type.
(defmethod store-handler-info ((handler storage-handler) att)
  (declare (ignore att))
  nil)

;;; Base class for storage handlers for value types, as opposed to entity types.
(defclass value-storage-handler
	  (storage-handler)
    ((statice-type:original-presentation-type :initarg :original-presentation-type
					      :reader value-storage-handler-original-presentation-type)
     (statice-type:presentation-type :initarg :presentation-type
				     :reader value-storage-handler-presentation-type)
     (statice-type:no-nulls :initarg :no-nulls :reader value-storage-handler-no-nulls)))

(defmethod print-object ((handler value-storage-handler) stream)
  (with-slots (statice-type:original-presentation-type) handler
    (sys:printing-random-object (handler stream :typep)
      (prin1 (if (slot-boundp handler 'statice-type:original-presentation-type)
		 statice-type:original-presentation-type
		 ;; Can be unbound if it's the basis of an unknown-logical-handler.
		 (type-of handler))
	     stream))))

(defmethod store-handler-info ((handler value-storage-handler) att)
  (setf (attribute-handler-kind att) *handler-kind-builtin*)
  (setf (attribute-handler-info att) (storage-handler-builtin-encode (type-of handler))))

;;; Default method for all value types.
(defmethod statice-typep ((handler value-storage-handler) value)
  (with-slots (statice-type:original-presentation-type) handler
    (dw::ptypep value statice-type:original-presentation-type)))

;;; value is the object to print if value-not-null-p is true.  If
;;; value-not-null-p is false, print the null value.  This subdispatch is here
;;; primarily for the benefit of logical types.  The method is not allowed to
;;; depend on any of the instance variables that are derived from the
;;; presentation type's data arguments, so that the dummy instances used by
;;; unknown-logical-handler can work.
(defgeneric format-value-internal (storage-handler value value-not-null-p stream))

;;; Formatting values, by default, calls read-value and dispatches via
;;; format-value-internal.  Provide your own format-data-internal if you
;;; want to avoid going through read-value, which would probably be
;;; because you think it could fail in an arbitrary Lisp environment.
(defmethod format-data-internal ((handler value-storage-handler) addressor
				 descriptor stream database)
  (if (null addressor)
      (format-value-internal handler nil nil stream)
      (let ((value (read-value handler addressor descriptor database)))
	(if (eq value *null-value*)
	    (format-value-internal handler nil nil stream)
	    (format-value-internal handler value t stream)))))

;;; This handler is the default.  If you write a new handler, be careful that
;;; this will work for your new type, and otherwise write your own.  In
;;; particular, this handler assumes that NIL is not a possible object,
;;; because it uses it for the null value.  That doesn't work for the boolean
;;; handlers, for example.
(defmethod format-value-internal ((handler value-storage-handler) value
				  value-not-null-p stream)
  (prin1 (when value-not-null-p value) stream))

(defmethod unformat-data ((handler value-storage-handler) value table)
  (declare (ignore table))
  (if (null value)
      (values nil t)
      value))

;;; Maps from presentation type names (symbols) into small integer codes.
(defparameter *builtin-type-code-table* (cl:make-hash-table :locking nil))

;;; Maps from small integer codes into presentation type names (symbols).
(defparameter *builtin-type-code-vector* (cl:make-array 20))

(defun set-builtin-type-numeric-code (presentation-type integer)
  (cl:setf (cl:gethash presentation-type *builtin-type-code-table*) integer)
  (cl:setf (aref *builtin-type-code-vector* integer) presentation-type))

;;; Given any presentation type, see if it's one of the ones that we can
;;; represent compactly with a small integer.  If so, return that
;;; integer.  Otherwise, return nil.  Note that we can only encode
;;; symbols, even though some non-symbol presentation types are built
;;; into Statice.  They just get represented in spelled-out form in the
;;; attribute record.
(defun att-type-builtin-encode (presentation-type)
  (cl:gethash presentation-type *builtin-type-code-table*))

;;; Given one of the small integers that came from
;;; att-type-builtin-encode, return the encoded presentation type.
(defun att-type-builtin-decode (integer)
  (aref *builtin-type-code-vector* integer))

;;; Used to be *builtin-handler-flavor-name-list* :
;;;     List of all built-in storage handler flavors, for
;;;     compile-flavor-methods purposes.
;;; Now handlers are classes, we may still need to do load-time compilation of combined methods
;;;  so keep this around. - jga 14 Sept 92
(defvar *builtin-handler-class-name-list* nil)

;;; Maps from storage handler flavor names  (symbols) into small integer codes.
(defparameter *builtin-handler-code-table* (cl:make-hash-table :locking nil))

;;; Maps from small integer codes into storage handler flavor names (symbols).
(defparameter *builtin-handler-code-vector* (cl:make-array 20))

(defun set-builtin-handler-numeric-code (presentation-type integer)
  (cl:setf (cl:gethash presentation-type *builtin-handler-code-table*) integer)
  (cl:setf (aref *builtin-handler-code-vector* integer) presentation-type))

;;; Given the name of a flavor of a built in storage handler, return
;;; the corresponding integer code.
(defun storage-handler-builtin-encode (presentation-type)
  (cl:gethash presentation-type *builtin-handler-code-table*))

;;; Given one of the small integers that came from
;;; storage-handler-builtin-encode, return the encoded flavor name.
(defun storage-handler-builtin-decode (integer)
  (aref *builtin-handler-code-vector* integer))

(defmacro define-builtin-type (type-name type-numeric-code handler-numeric-code
			       &optional instance-variables mixin-classes)
  (let ((handler-name (intern (string-append type-name "-HANDLER"))))
    `(progn
       (set-statice-info ',type-name '(:class ,handler-name))
       (set-builtin-type-numeric-code ',type-name ,type-numeric-code)
       (set-builtin-handler-numeric-code ',handler-name ,handler-numeric-code)
       (pushnew ',handler-name *builtin-handler-class-name-list*)
       (defclass ,handler-name
		 (,@mixin-classes value-storage-handler)
	   (,@instance-variables)))))

;;; Use this with define-storage-handler.
(defmacro define-builtin-type-with-finder (type-name type-numeric-code finder-name)
  `(progn
     (set-statice-info ',type-name '(:function ,finder-name))
     (set-builtin-type-numeric-code ',type-name ,type-numeric-code)))

;;; Use this with define-builtin-type-with-finder.
(defmacro define-storage-handler (handler-name handler-numeric-code
				  &optional instance-variables mixin-classes)
  `(progn
     (pushnew ',handler-name *builtin-handler-class-name-list*)
     (set-builtin-handler-numeric-code ',handler-name ,handler-numeric-code)
     (defclass ,handler-name
	       (,@mixin-classes value-storage-handler)
	 (,@instance-variables))))

;;; Use this when the type already exists and the handler already exists,
;;; and you just want to hook them up, e.g. number and lisp-object-handler.
;;; To see the ptype objects that this statice-info goes onto, use DW::SYMBOL-PRESENTATION-TYPE-DESCRIPTOR
;;; e.g. (dw::presentation-type-statice-info (dw::symbol-presentation-type-descriptor 'single-float))
(defmacro assign-type-to-handler (type-name handler-name)
  `(set-statice-info ',type-name '(:class ,handler-name)))

(define-builtin-type single-float 1 1)

;;; The bit pattern used to represent the null value is a floating point
;;; NAN (Not A Number) whose error code is something that the Lisp
;;; system never uses.
(defconstant *single-float-null*
	     (sys:%flonum (dpb sys:%single-exponent-max sys:%%single-exponent #o10000000)))

(defmethod statice-typep ((handler single-float-handler) int)
  (with-slots (statice-type:original-presentation-type) handler
    (and (typep int 'single-float)
	 (or (eq statice-type:original-presentation-type 'single-float)
	     (dw::ptypep int statice-type:original-presentation-type)))))

(defmethod check-spec ((handler single-float-handler) spec)
  (check-spec-standard 'single-float '(> <   >= <= = equal eql)))

(defmethod check-operator ((handler single-float-handler) operator)
  (member operator '(equal eql > <   >= <= =)))

(defmethod fixed-space ((handler single-float-handler))
  (values 32 0))

(defmethod read-value ((handler single-float-handler) addressor descriptor database &rest keyword-args)
  (declare (ignore database keyword-args))
  (single-float-read-value (read-record-word addressor descriptor)))

(defun single-float-read-value (fixed-word)
  (let ((val (sys:%flonum fixed-word)))
    (if (eql val *single-float-null*) *null-value* val)))

(defmethod write-value ((handler single-float-handler) flo addressor descriptor free
			database transition-table size)
  (declare (ignore database transition-table size))
  (setf (read-record-word addressor descriptor) (single-float-write-value flo))
  free)

(defun single-float-write-value (flo)
  (sys:%fixnum (if (eq flo *null-value*) *single-float-null* flo)))

(defmethod value-equal ((handler single-float-handler) addressor descriptor flo database)
  (declare (ignore database))
  (single-float-value-equal (read-record-word addressor descriptor) flo))

(defun single-float-value-equal (fixed-word flo)
  (let ((val (sys:%flonum fixed-word)))
    (unless (eql val *single-float-null*)
      (= val flo))))

(defmethod record-equal ((handler single-float-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let ((val-1 (sys:%flonum (read-record-word addressor-1 descriptor-1)))
	(val-2 (sys:%flonum (read-record-word addressor-2 descriptor-2))))
    (and (not (eql val-1 *single-float-null*))
	 (eql val-1 val-2))))

(defmethod value-null-p ((handler single-float-handler) addressor descriptor)
  (eql (sys:%flonum (read-record-word addressor descriptor)) *single-float-null*))

(defmethod comparable-p ((handler single-float-handler)) t)

(defmethod value-compare ((handler single-float-handler) addressor descriptor value database &rest case-sensitive)
  (declare (ignore database case-sensitive))
  (let ((record-value (sys:%flonum (read-record-word addressor descriptor))))
    (cond ((eql record-value *single-float-null*) *null-value*)
	  ((eql value *single-float-null*) :lessp)
	  ((< record-value value) :lessp)
	  ((> record-value value) :greaterp)
	  (t :equal))))

(defmethod record-compare ((handler single-float-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (let ((val-1 (sys:%flonum (read-record-word addressor-1 descriptor-1)))
	(val-2 (sys:%flonum (read-record-word addressor-2 descriptor-2))))
    (cond ((eql val-1 *single-float-null*)
	   (if (eql val-2 *single-float-null*) :equal :greaterp))
	  ((eql val-2 *single-float-null*) :lessp)
	  ((< val-1 val-2) :lessp)
	  ((> val-1 val-2) :greaterp)
	  (t :equal))))

#|

This is almost easy, because you can almost treat an IEEE
single-precision floating point number as if it were a 32-bit signed
fixed-point number, for purposes of comparison.  Unfortunately, the NAN
(Not A Number) values are hiding in there.  It appears that the right
thing to do with a NAN is to treat it as if it were greater than any
other number.  This is consistent with the way we generally treat the
null value.  In fact, we represent the null value by one of the NANs, so
this guarantees correct treatment of the null value as well.

A NAN is a number with either sign, exponent sys:%single-exponent-max,
and fraction non-zero.  If we pick up the 32 bits out of the record and
look at them as fixnums, we get what I'll call "raw flonums".  The range
of the raw flonums has four segments, as follows:

(1) most-negative-fixnum  X  #o-40000000	Numbers

(2) #o40000000 < X < 0				NANs

(3) 0  X  #o17740000000			Numbers

(4) #o17740000000 < X  most-positive-fixnum	NANs

In order to bring all the NANs up to the top, we'll perform a
mapping on the raw flonums before encoding them as if they
were fixnums.  The mapping switches the positions of segments
2 and 3.

But wait, there's more.  So this is all well and good except that
before any key is passed to Statice-Index, we switch b31 by doing a
(zl:32-bit-plus n (lsh 1 31)) on it (see make-key-from-values).  So to
do the mapping above, the function would look like this:

(defun map-raw-flonum (raw-flonum)
  (cond (( raw-flonum #o-40000000) raw-flonum)
	((minusp raw-flonum) (+ raw-flonum #o17740000000))
	(( raw-flonum #o17740000000) (- raw-flonum #o40000000))
	(t raw-flonum)))

So effectively, we have to undo this 32-bit add before we return our
key.  The new function with #o-20000000000 added to all the constants
looks like this:
|#

(defun map-raw-flonum (raw-flonum)
  (cond (( raw-flonum #o-40000000) (zl:%32-bit-plus (scl:lsh 1 31) raw-flonum))
	((minusp raw-flonum) (- raw-flonum #o40000000))
	(( raw-flonum #o17740000000) (zl:%32-bit-plus raw-flonum #o17740000000))
	(t raw-flonum (- raw-flonum #o20000000000))))

(define-builtin-type double-float 10 10)

;;; The bit pattern used to represent the null value is a floating point
;;; NAN (Not A Number) whose error code is something that the Lisp
;;; system never uses.
(defconstant *double-float-null*
	     (si:%make-double (dpb sys:%double-exponent-max sys:%%double-exponent #o1000000)
			      0))

(defmethod statice-typep ((handler double-float-handler) int)
  (with-slots (statice-type:original-presentation-type) handler
    (and (typep int 'double-float)
	 (or (eql statice-type:original-presentation-type 'double-float)
	     (dw::ptypep int statice-type:original-presentation-type)))))

(defmethod check-spec ((handler double-float-handler) spec)
  (check-spec-standard 'double-float '(> <   >= <= = equal eql)))

(defmethod check-operator ((handler double-float-handler) operator)
  (member operator '(equal eql > <   >= <= =)))

(defmethod fixed-space ((handler double-float-handler))
  (values 64 0))

(defmethod read-value ((handler double-float-handler) addressor descriptor database &rest keyword-args)
  (declare (ignore database &rest keyword-args))
  (let ((val (si:%make-double (read-record-word addressor descriptor)
			      (read-record-word addressor (1+ descriptor)))))
    (if (eql val *double-float-null*) *null-value* val)))

(defmethod write-value ((handler double-float-handler) flo addressor descriptor free
			database table size)
  (declare (ignore database table size))
  (let ((val (if (eq flo *null-value*) *double-float-null* flo)))
    (setf (read-record-word addressor descriptor) (si:double-high val))
    (setf (read-record-word addressor (1+ descriptor)) (si:double-low val)))
  free)

(defmethod value-equal ((handler double-float-handler) addressor descriptor flo database)
  (declare (ignore database))
  (let ((val (si:%make-double (read-record-word addressor descriptor)
			      (read-record-word addressor (1+ descriptor)))))
    (unless (eql val *double-float-null*)
      (= val flo))))

(defmethod record-equal ((handler double-float-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let ((val-1 (si:%make-double (read-record-word addressor-1 descriptor-1)
				(read-record-word addressor-1 (1+ descriptor-1))))
	(val-2 (si:%make-double (read-record-word addressor-2 descriptor-2)
				(read-record-word addressor-2 (1+ descriptor-2)))))
    (and (not (eql val-1 *double-float-null*))
	 (eql val-1 val-2))))

(defmethod value-null-p ((handler double-float-handler) addressor descriptor)
  (let ((val (si:%make-double (read-record-word addressor descriptor)
			      (read-record-word addressor (1+ descriptor)))))
    (eql val *double-float-null*)))

(defmethod comparable-p ((handler double-float-handler)) t)

(defmethod value-compare ((handler double-float-handler) addressor descriptor value database &rest case-sensitive)
  (declare (ignore database case-sensitive))
  (let ((record-value (si:%make-double (read-record-word addressor descriptor)
				       (read-record-word addressor (1+ descriptor)))))
    (cond ((eql record-value *double-float-null*)
	   *null-value*)
	  ((eql value *double-float-null*) :lessp)
	  ((< record-value value) :lessp)
	  ((> record-value value) :greaterp)
	  (t :equal))))

(defmethod record-compare ((handler double-float-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (let ((val-1 (si:%make-double (read-record-word addressor-1 descriptor-1)
				(read-record-word addressor-1 (1+ descriptor-1))))
	(val-2 (si:%make-double (read-record-word addressor-2 descriptor-2)
				(read-record-word addressor-2 (1+ descriptor-2)))))
    (cond ((eql val-1 *double-float-null*)
	   (if (eql val-2 *double-float-null*) :equal :greaterp))
	  ((eql val-2 *double-float-null*) :lessp)
	  ((< val-1 val-2) :lessp)
	  ((> val-1 val-2) :greaterp)
	  (t :equal))))

;;; See the long comment at map-raw-flonum for an explanation.
(defun map-raw-double-flonum (high)
  (zl:%32-bit-plus
    (scl:lsh 1 31.)
    (cond (( high #o-4000000) high)
	  ((minusp high) (+ high #o17774000000))
	  (( high #o17774000000) (- high #o4000000))
	  (t high))))

;;; These are necessary because the presentation type system is arranged
;;; so that single inherits from short, and double inherits from long,
;;; rather than the other way around as you'd expect.  Oh, well.

(assign-type-to-handler short-float single-float-handler)

(assign-type-to-handler long-float double-float-handler)

;;; This mixin is used by all of the boolean storage handlers.
(defclass boolean-handler-mixin () ())

(defmethod statice-typep ((handler boolean-handler-mixin) int)
  (with-slots (statice-type:original-presentation-type) handler
    (and (typep int 'boolean)
	 (or (eq statice-type:original-presentation-type 'boolean)
	     (dw::ptypep int statice-type:original-presentation-type)))))

(defmethod check-spec ((handler boolean-handler-mixin) spec)
  (check-spec-standard 'boolean '(equal eql eq)))

(defmethod check-operator ((handler boolean-handler-mixin) operator)
  (member operator '(equal eql eq)))

(defmethod format-value-internal ((handler boolean-handler-mixin) value value-not-null-p stream)
  (prin1 (if value-not-null-p value 'the-null-value) stream))

(defmethod unformat-data ((handler boolean-handler-mixin) value table)
  (declare (ignore table))
  (if (eq value 'the-null-value)
      (values nil t)
      value))

(defmethod nil-is-valid-value ((handler boolean-handler-mixin))
  t)

;;; word-boolean is a special internal storage handler.  Its values are
;;; boolean, but are stored in an entire word instead of one or two
;;; bits.  It is only used for system attributes.  These system
;;; attributes never take on the null value, so it's not handled.  They
;;; cannot be written directly, so there is no write-value method.  The
;;; purpose of this is to relieve us of the need to maintain separate
;;; bits to say things like whether a relation or domain is indexed, or
;;; whether an attribute is group indexed.
(scl:define-presentation-type word-boolean ()
   :abbreviation-for 'boolean)

(define-builtin-type word-boolean 2 2 () (boolean-handler-mixin))

(defmethod fixed-space ((handler word-boolean-handler))
  (values 32 0))

(defmethod read-value ((handler word-boolean-handler) addressor descriptor database &rest keyword-args)
  (declare (ignore database &rest keyword-args))
  (not (zerop (read-record-word addressor descriptor))))

(defmethod value-equal ((handler word-boolean-handler) addressor descriptor value database)
  (declare (ignore database))
  (if (not (zerop (read-record-word addressor descriptor)))
      value
      (not value)))

(defmethod record-equal ((handler word-boolean-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let ((val-1 (read-record-word addressor-1 descriptor-1))
	(val-2 (read-record-word addressor-2 descriptor-2)))
    (if (zerop val-1) (zerop val-2) (not (zerop val-2)))))

(defmethod value-null-p ((handler word-boolean-handler) addressor descriptor)
  (declare (ignore addressor descriptor))
  nil)

(defmethod comparable-p ((self word-boolean-handler)) nil)

;;; String can take one of two formats depending on their size, and
;;; whether they are fat or thin.  Bit 31 and bit 30 of the descriptor
;;; word determine long/shortness and fat/thinness, respectively.

;;; Thin: If the length of the string is  *max-short-size* bytes, the
;;; rest of the descriptor word is split into two fields -- size (in
;;; bytes), and offset (in words) to the var part of the record which
;;; stores the bytes of the string.  These two bytes are defined by
;;; *short-size* and *short-offset*.  Because the short format can only
;;; offset up to 2**18 words, the max record size with strings is
;;; limited to 262k words.  We could eventually add in a mutator which
;;; would mutate the record up to the long format.  If the length of the
;;; string is > *max-short-size*, then the rest of the descriptor word
;;; points to the var portion of the record (defined by *long-offset*).
;;; The first var word contains the size of the string (in 8bit bytes).

;;; Fat: If the length of the string in words (i.e. the number of words
;;; required to store the fat string in some 8-bit representation) is 
;;; *max-short-size*, then the one word descriptor format applies with
;;; the size holding the number of words needed to hold the string in
;;; the var part, INCLUDING this size word, and offset pointing to the
;;; var part.  If it is a long fat string, then the last 30 bits of the
;;; descriptor are the offset to the var part, and the first var word
;;; contains the number of words in the var part, NOT including the
;;; first word itself.   Note that the :string-dimensions message is
;;; used to determine the number of "fat" characters needed to represent
;;; the string in fat format.  This number is store internally in the
;;; first word or so of the var part (past the size word if we're
;;; talking about the long format).

(define-builtin-type string 3 3)

(eval-when (compile cl:load eval)
  (defconstant *long-short-byte* (byte 1 31))	;1=long
  (defconstant *fat-thin-byte* (byte 1 30))	;1=fat
  (defconstant *long-offset* (byte 30 0))
  (defconstant *short-size* (byte 12 18))
  (defconstant *short-offset* (byte 18 0))
  (defconstant *max-short-size* (1- (expt 2 12)))
  (defconstant *max-short-offset* (1- (expt 2 18)))
);eval-when

(defmethod statice-typep ((handler string-handler) string)
  (with-slots (statice-type:original-presentation-type) handler
    (and (stringp string)
	 (or (eq statice-type:original-presentation-type 'string)
	     (dw::ptypep string statice-type:original-presentation-type)))))

;;; Note that this list inclues equal and eql.
(eval-when (compile load eval)
  (defparameter *string-operators*
		'(string-search scl:string-search-exact string-prefix string-prefix-exact
		  string< string string<=
		  string> string string>=
		  string-lessp string-greaterp string-not-lessp string-not-greaterp
		  string-equal string= equal)))

(defmethod check-spec ((handler string-handler) spec)
  (check-spec-standard 'string *string-operators*))

(defmethod check-operator ((handler string-handler) operator)
  (member operator *string-operators*))

(defmethod fixed-space ((handler string-handler))
  (values 32 0))

(defmethod size-of-value ((handler string-handler) string free database)
  (declare (ignore database))
  (string-size-of-value string free))

(defun string-size-of-value (string free)
  (multiple-value-bind (fat-p n-words n-chars transition-table)
      (string-info string)
    (let ((size (cl:if fat-p n-words n-chars)))
      (values (cl:if (or (> size *max-short-size*) (> free *max-short-offset*))
		  (1+ n-words)
		  n-words)
	      transition-table))))

(defmethod size-of-field ((handler string-handler) addressor descriptor)
  (string-size-of-field addressor (read-record-word addressor descriptor)))

(defun string-size-of-field (addressor fixed-word)
  (let* ((thin-p (zerop (sys:%logldb *fat-thin-byte* fixed-word))))
    (if (zerop (sys:%logldb *long-short-byte* fixed-word))
	(if thin-p
	    (ceiling (sys:%logldb *short-size* fixed-word) 4)
	    (sys:%logldb *short-size* fixed-word))
	(let ((size (read-record-word addressor (sys:%logldb *long-offset* fixed-word))))
	  (if thin-p
	      (1+ (ceiling size 4))
	      size)))))

(defmethod length-of-array ((handler string-handler) addressor descriptor)
  (string-length-of-record-string-in-bytes addressor (read-record-word addressor descriptor)))

(defun string-length-of-record-string-in-bytes (addressor desc)
  (let* ((thin-p (zerop (sys:%logldb *fat-thin-byte* desc)))
	 (short-p (zerop (sys:%logldb *long-short-byte* desc))))
    (if thin-p
	(if short-p
	    (sys:%logldb *short-size* desc)
	    (read-record-word addressor (sys:%logldb *long-offset* desc)))
	(let ((offset (cl:if short-p
			  (sys:%logldb *short-offset* desc)
			  (1+ (sys:%logldb *long-offset* desc)))))
	  (send addressor :set-pointer offset)
	  (using-resource (sizing-loader bin:unsigned-byte-32-loader)
	    (bin::initialize-loader sizing-loader nil t addressor t)
	    (send sizing-loader :string-dimensions))))))

(defmethod start-of-field ((handler string-handler) addressor descriptor)
  (string-start-of-field (read-record-word addressor descriptor)))

(defun string-start-of-field (fixed-word)
  (if (zerop (sys:%logldb *long-short-byte* fixed-word))
      (sys:%logldb *short-offset* fixed-word)
      (sys:%logldb *long-offset* fixed-word)))

(defmethod read-value ((handler string-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (string-read-value addressor (read-record-word addressor descriptor)
		     database into-string stack-cons-if-appropriate))

(defun string-read-value (addressor fixed-word database into-string stack-cons-if-appropriate)
  (if (zerop fixed-word)
      *null-value*
      (let* ((thin-p (zerop (sys:%logldb *fat-thin-byte* fixed-word)))
	     (short-p (zerop (sys:%logldb *long-short-byte* fixed-word)))
	     (string-start (if short-p
			       (sys:%logldb *short-offset* fixed-word)
			       (1+ (sys:%logldb *long-offset* fixed-word)))))
	(cond (thin-p
	       (let ((n-bytes (if short-p
				  (sys:%logldb *short-size* fixed-word)
				  (read-record-word
				    addressor
				    (sys:%logldb *long-offset* fixed-word)))))
		 (when stack-cons-if-appropriate
		   (when into-string
		     (model-bug "into-string and stack-cons-if-appropriate both specified"))
		   (setq into-string
			 (sys:make-stack-array n-bytes :element-type 'string-char)))
		 (read-string-from-record addressor n-bytes string-start
					  :into-string into-string)))
	      (t
	       (using-resource (sizing-loader bin:unsigned-byte-32-loader)
		 (bin::initialize-loader sizing-loader
					 nil
					 t
					 addressor
					 (database-table-of-character-encodings database))
		 (send addressor :set-pointer string-start)
		 (unless into-string
		   (setq into-string
			 (prog1
			   (if stack-cons-if-appropriate
			       (sys:make-stack-array (send sizing-loader :string-dimensions)
						     :element-type 'character)
			       (cl:make-string (send sizing-loader :string-dimensions)
					    :element-type 'character))
			   (send sizing-loader :finish-input nil)
			   (send addressor :set-pointer string-start))))
		 (send sizing-loader :load-string nil nil into-string)))))))

;;; This is the string type, all right.
(defmethod string-type-p ((handler string-handler)) t)

(defmethod map-over-subvalues ((handler string-handler) addressor descriptor database
			       delimiter continuation create-function)
  (declare (sys:downward-funarg continuation create-function))
  (let ((desc (read-record-word addressor descriptor)))
    (unless (zerop desc)
      ;; we're not dealing with the null value
      (let* ((thin-p (zerop (sys:%logldb *fat-thin-byte* desc)))
	     (short-p (zerop (sys:%logldb *long-short-byte* desc)))
	     (string-start (if short-p
			       (sys:%logldb *short-offset* desc)
			       (1+ (sys:%logldb *long-offset* desc)))))
	(cond (thin-p
	       (sys:with-data-stack
		 (let* ((n-bytes (if short-p
				     (sys:%logldb *short-size* desc)
				     (read-record-word addressor (1- string-start))))
			(n-words (ceiling n-bytes 4))
			(words (read-multiple-record-word
				 addressor string-start (+ string-start n-words)))
			(delimiter-subindex (si:char-subindex delimiter))
			(found-p nil))
		   (declare (sys:array-register words))
		   (loop with start-word = 0 and start-byte = 0 and substring-bytes = 0
			 for word-number from 0
			 repeat n-words
			 for word = (aref words word-number) do
		     (loop for byte-num from 0 below 4
			   for position from 0 by 8
			   until (zerop n-bytes) do
		       (setq found-p nil)
		       (cond ((= (case position
				   (0  (sys:%logldb (byte 8  0) word))
				   (8  (sys:%logldb (byte 8  8) word))
				   (16 (sys:%logldb (byte 8 16) word))
				   (24 (sys:%logldb (byte 8 24) word)))
				 delimiter-subindex)
			      (setq found-p t)
			      (funcall continuation
				       (read-string-from-record
					 addressor
					 substring-bytes
					 start-word
					 :into-string (funcall
							create-function substring-bytes t)
					 :record-words words
					 :start-byte start-byte))
			      (setq substring-bytes 0)
			      (if (= byte-num 3)
				  (setq start-word (1+ word-number)
					start-byte 0)
				  (setq start-word word-number
					start-byte (1+ byte-num))))	;skip delimiter
			     (t (incf substring-bytes)))
		       (decf n-bytes))
			 finally
			   (unless (zerop substring-bytes)
			     (funcall continuation
				      (read-string-from-record
					addressor
					substring-bytes
					start-word
					:into-string (funcall
						       create-function substring-bytes t)
					:record-words words
					:start-byte start-byte)))
			   (when found-p
			     (funcall continuation ""))))))
	      (t
	       (using-resource (partial-loader bin:unsigned-byte-32-partial-loader)
			       (bin::initialize-loader partial-loader
						       nil
						       t
						       addressor
						       (database-table-of-character-encodings database))
			       (send addressor :set-pointer string-start)
			       (send partial-loader :map-substrings
				     continuation
				     #'(lambda (length)
					 (declare (sys:downward-function))
					 (funcall create-function length nil))
				     delimiter))))))))


#||
;;; For debugging
(defun describe-descriptor (desc)
  (let ((long-short (sys:%logldb *long-short-byte* desc))
	(thin-fat (sys:%logldb *fat-thin-byte* desc)))
    (format t "~&~[short~;long~] ~[thin~;fat~] " long-short thin-fat)
    (if (zerop long-short)
	(format t "size=~S  offset=~S"
		(sys:%logldb *short-size* desc)
		(sys:%logldb *short-offset* desc))
	(format t "offset=~S" (sys:%logldb *long-offset* desc))))
  desc)
||#

(defmethod write-value ((handler string-handler) string addressor descriptor free
			database transition-table size)
  (multiple-value-bind (new-fixed-word free)
      (string-write-value string addressor free database transition-table size)
    (setf (read-record-word addressor descriptor) new-fixed-word)
    free))

(defun string-write-value (string addressor free database transition-table size)
  (declare (values new-fixed-word free))
  (if (eq string *null-value*)
      (values 0 free)
      (let ((new-fixed-word 0))
	(cond ((string-really-fat-p string)
	       (let* ((long-p (or (> size *max-short-size*)
				  (> free *max-short-offset*))))
		 (cl:setf (sys:%logldb *fat-thin-byte* new-fixed-word) 1)
		 (cond (long-p
			(cl:setf (sys:%logldb *long-short-byte* new-fixed-word) 1)
			(cl:setf (sys:%logldb *long-offset* new-fixed-word) free)
			(cl:setf (read-record-word addressor free) size)
			(send addressor :set-pointer (1+ free)))
		       (t (cl:setf (sys:%logldb *long-short-byte* new-fixed-word) 0)
			  (cl:setf (sys:%logldb *short-size* new-fixed-word) size)
			  (cl:setf (sys:%logldb *short-offset* new-fixed-word)
				(if (zerop free) 1 free))
			  (send addressor :set-pointer free)))
		 (write-fat-string string addressor database transition-table)
		 (values new-fixed-word (+ free size))))
	      (t
	       (let* ((n-bytes (length string))
		      (long-p (or (> n-bytes *max-short-size*)
				  (> free *max-short-offset*))))
		 (cl:setf (sys:%logldb *long-short-byte* new-fixed-word) (if long-p 1 0))
		 (cl:setf (sys:%logldb *fat-thin-byte* new-fixed-word) 0)
		 (cond (long-p
			(cl:setf (sys:%logldb *long-offset* new-fixed-word) free)
			(cl:setf (read-record-word addressor free) n-bytes)
			(incf free))
		       (t
			(cl:setf (sys:%logldb *short-offset* new-fixed-word)
			      (if (zerop free) 1 free))
			(cl:setf (sys:%logldb *short-size* new-fixed-word) n-bytes)))
		 (values new-fixed-word
			 (write-string-to-record addressor n-bytes free string))))))))

(defmethod value-equal ((handler string-handler) addressor descriptor
			value database)
  (string-value-equal addressor (read-record-word addressor descriptor) value database))

(defun string-value-equal (addressor desc value database)
  (let* ((short-p (zerop (sys:%logldb *long-short-byte* desc)))
	 (thin-p (zerop (sys:%logldb *fat-thin-byte* desc)))
	 (start-offset (if short-p
			   (sys:%logldb *short-offset* desc)
			   (1+ (sys:%logldb *long-offset* desc))))
	 (n-bytes (string-length-of-record-string-in-bytes addressor desc)))
    (unless (zerop desc)
      (string-value-equal-internal
	value addressor database start-offset n-bytes thin-p
	(unless thin-p
	  (if short-p
	      (sys:%logldb *short-size* desc)
	      (1- (read-record-word addressor (- start-offset 1)))))))))

;;; Doesn't handle fat strings right now.  Or does it?
(defmethod record-equal ((handler string-handler) addressor-1 addressor-2
			 descriptor-1 descriptor-2)
  (let ((n-bytes-1 (length-of-array handler addressor-1 descriptor-1))
	;; can use start-of-field here since the two record must occupy
	;; the same number of words to be equal.
	(start-offset-1 (start-of-field handler addressor-1 descriptor-1))
	(n-bytes-2 (length-of-array handler addressor-2 descriptor-2))
	(start-offset-2 (start-of-field handler addressor-2 descriptor-2)))
    (when (and (plusp start-offset-1) (plusp start-offset-2) (= n-bytes-1 n-bytes-2))
      (compare-strings-from-records addressor-1 addressor-2 n-bytes-1
				    start-offset-1 start-offset-2))))

(defmethod value-null-p ((handler string-handler) addressor descriptor)
  (zerop (read-record-word addressor descriptor)))

(defmethod case-insensitive-type-p ((handler string-handler)) nil)

(defmethod comparable-p ((handler string-handler)) t)

(defmethod value-compare ((handler string-handler) addressor descriptor value database
			  &key case-sensitive)
  (let* ((desc (read-record-word addressor descriptor))
	 (short-p (zerop (sys:%logldb *long-short-byte* desc)))
	 (thin-p (zerop (sys:%logldb *fat-thin-byte* desc)))
	 (start-offset (if short-p
			   (sys:%logldb *short-offset* desc)
			   (1+ (sys:%logldb *long-offset* desc))))
	 (record-n-bytes (length-of-array handler addressor descriptor)))
    (cond ((zerop desc) *null-value*)
	  ((eq value *null-value*) :lessp)
	  ((and thin-p (not (string-really-fat-p value)))
	   (compare-string-from-record
	     addressor record-n-bytes start-offset value case-sensitive))
	  (t
	   (sys:with-data-stack
	     (let ((string (read-value handler addressor descriptor database
				       :stack-cons-if-appropriate t)))
	       (case (signum (funcall (if case-sensitive
					  #'sys:%string-exact-compare
					  #'sys:%string-compare)
				      string 0 value 0 nil))
		 (-1 :lessp)
		 (0 :equal)
		 (1 :greaterp))))))))

(defmethod record-compare
	   ((handler string-handler) addressor-1 addressor-2 descriptor-1
	    descriptor-2 database-1 database-2)
  (let* ((desc-1 (read-record-word addressor-1 descriptor-1))
	 (desc-2 (read-record-word addressor-2 descriptor-2))
	 (thin-p-1 (zerop (sys:%logldb *fat-thin-byte* desc-1)))
	 (thin-p-2 (zerop (sys:%logldb *fat-thin-byte* desc-2)))
	 (start-offset-1 (start-of-field handler addressor-1 descriptor-1))
	 (start-offset-2 (start-of-field handler addressor-2 descriptor-2)))
    ;; shouldn't these be (zerop desc-1) (zerop desc-2)?
    (cond ((zerop start-offset-1)
	   (if (zerop start-offset-2) :equal :greaterp))
	  ((zerop start-offset-2) :lessp)
	  ((and thin-p-1 thin-p-2)
	   ;; should probably subst this inline since only one caller
	   (record-compare-strings
	     addressor-1
	     (length-of-array handler addressor-1 descriptor-1)
	     start-offset-1
	     addressor-2
	     (length-of-array handler addressor-2 descriptor-2)
	     start-offset-2))
	  (t
	   (sys:with-data-stack
	     (let* ((n-bytes-1 (length-of-array handler addressor-1 descriptor-1))
		    (n-bytes-2 (length-of-array handler addressor-2 descriptor-2))
		    (string-1 (sys:make-stack-array n-bytes-1 :element-type 'character))
		    (string-2 (sys:make-stack-array n-bytes-2 :element-type 'character)))
	       (read-value handler addressor-1 descriptor-1 database-1 :into-string string-1)
	       (read-value handler addressor-2 descriptor-2 database-2 :into-string string-2)
	       (compare-strings-case-sensitive-style-insensitive
		 string-1 n-bytes-1 string-2 n-bytes-2
		 (database-table-of-character-types database-1)
		 (database-table-of-character-types database-2))))))))


(defmethod adjust-variable-words ((handler string-handler) addressor descriptor added-n)
  (let ((fixed-word (read-record-word addressor descriptor)))
    (unless (zerop fixed-word)
      (setf (read-record-word addressor descriptor)
	    (string-adjust-variable-words fixed-word added-n)))))


(defun string-adjust-variable-words (fixed-word added-n)
  (cl:if (zerop (sys:%logldb *long-short-byte* fixed-word))
      (incf (sys:%logldb *short-offset* fixed-word) added-n)
      (incf (sys:%logldb *long-offset* fixed-word) added-n))
  fixed-word)

;;; entity-storage-handler-mixin is a mixin flavor that implements a
;;; storage format in which entities are stored in one fixed word, by
;;; storing their RID.  This mixin is used by the entity-handle value
;;; type, and also by all entity types (i.e. domains).  It's an
;;; independent mixin so that domain-handle can partake of its behavior
;;; without inheriting from value-storage-handler.

;;; TEMPORARILY MOVED TO DEFS.LISP DUE TO FLAVOR SYSTEM PROBLEM
;;;  Even after the CLOS conversion, I left the definition in DEFS.LISP - jga 11 Sept 92
;;; (defflavor entity-storage-handler-mixin () ())


;;; When the type is an unknown entity, that means it's really some
;;; domain that lives somewhere else.  We can't tell whether the
;;; argument is of the right type, so by policy we always say that it
;;; isn't.  This is part of the Model Level semantics.
(defmethod statice-typep ((handler unknown-entity-handle) value)
  (declare (ignore value))
  nil)

;;; The domain-handle flavor inherits from entity-handle-handler.  It's
;;; different because it restricts the values to be entities of this
;;; type, and analogously restricts do-relation specs.
(defmethod statice-typep ((handler domain-handle) entity-handle)
  (and (typep entity-handle 'known-entity-handle)
       (labels ((check (dh)
		  (or (eq handler dh)
		      (loop for d in (domain-handle-list-of-parent-domains dh)
			    thereis (check d)))))
	 (check (known-entity-handle-domain entity-handle)))))

(defmethod check-spec ((handler domain-handle) spec)
  (check-entity-spec spec handler))


;;; The spec should be an entity.  If domain is null, it can be any
;;; entity.  Otherwise, domain is a domain handle, and the entity must
;;; be of that domain.  
(defun check-entity-spec (spec domain)
  (flet ((check-entity (entity)
	   ;; The entity handle is being touched by the transaction,
	   ;; make sure it's validated, etc.
	   (check-entity-handle entity)
	   (or (null domain)
	       ;; The entity handle must be known, and must be from this
	       ;; database, and must be of the domain's type.
	       (and (handle-rid entity)
		    (eq (domain-handle-database (known-entity-handle-domain entity))
			(domain-handle-database domain))
		    (statice-typep domain entity)))))
    (typecase spec
      (entity-handle (check-entity spec))
      (list
	(or (and (= (length spec) 2)
		 (case (first spec)
		   ((equal eql eq)
		    (when (typep (second spec) 'entity-handle)
		      (check-entity (second spec))
		      t))
		   (domain
		     (when (typep (second spec) 'domain-handle)
		       (check-domain-handle (second spec))
		       t))))
	    (eq (first spec) 'null))))))

;;; This storage handler can store any entity.  This used to be known as
;;; "the any-entity datatype".
(define-builtin-type entity-handle 4 4 () (entity-storage-handler-mixin))

(defmethod statice-typep ((handler entity-handle-handler) entity-handle)
  (typep entity-handle 'entity-handle))

(defmethod check-spec ((handler entity-handle-handler) spec)
  (check-entity-spec spec nil))

(defmethod check-operator ((handler entity-storage-handler-mixin) operator)
  (member operator '(equal eql eq domain)))

(defmethod fixed-space ((handler entity-storage-handler-mixin))
  (values 32 0))

(defmethod entity-type-p ((handler entity-storage-handler-mixin))
  t)

(defmethod read-value ((handler entity-storage-handler-mixin) addressor descriptor database &key &allow-other-keys)
  (let ((rid (read-record-word addressor descriptor)))
    (if (zerop rid) *null-value* (find-entity-handle-given-rid rid database))))

(defmethod write-value ((handler entity-storage-handler-mixin) entity-handle addressor descriptor
			 free database translation-table size)
  (declare (ignore translation-table size))
  (setf (read-record-word addressor descriptor)
	(if (eq entity-handle *null-value*)
	    0
	    (find-entity-record-in-database entity-handle database :create t)))
  free)

(defmethod value-null-p ((handler entity-storage-handler-mixin) addressor descriptor)
  (zerop (read-record-word addressor descriptor)))

(defmethod value-equal ((handler entity-storage-handler-mixin) addressor descriptor entity-handle database)
  (entity-value-equal (read-record-word addressor descriptor) entity-handle database))

(defun entity-value-equal (ent-rid entity-handle database)
  (cond ((zerop ent-rid) nil)
	((and (typep entity-handle 'known-entity-handle)
	      (eq database (domain-handle-database
			     (known-entity-handle-domain entity-handle))))
	 ;; Fast: This is entity-handle's home database, so we can just compare RIDs.
	 (= ent-rid (handle-rid entity-handle)))
	(t
	 ;; Slow: Need to look inside the record to get the UID.
	 (with-record (ent (database-opening database) ent-rid :read)
	   (and (= (entity-uid-word-1 ent) (entity-handle-uid-word-1 entity-handle))
		(= (entity-uid-word-2 ent) (entity-handle-uid-word-2 entity-handle))
		(= (entity-uid-word-3 ent) (entity-handle-uid-word-3 entity-handle)))))))

(defmethod record-equal ((handler entity-storage-handler-mixin) addressor-1 addressor-2
			 descriptor-1 descriptor-2)
  (let ((ent-rid-1 (read-record-word addressor-1 descriptor-1))
	(ent-rid-2 (read-record-word addressor-2 descriptor-2)))
    (unless (or (zerop ent-rid-1) (zerop ent-rid-2))
      ;; These are two records from the same database, so the only way the entities
      ;; can be the same is if the rid values are exactly equal.
      (= ent-rid-1 ent-rid-2))))

;;; Note that for a null value, this prints 0 and for a foreign entity
;;; handle, it prints the rid of the foreign entity handle.  For now, it
;;; won't work for foreign entity handles, because there's no :entity
;;; line for them.  ++ This needs to be fixed!
(defmethod format-data-internal ((handler entity-storage-handler-mixin) addressor descriptor stream database)
  (declare (ignore database))
  (princ (cond ((null addressor) nil)
	       ((integerp addressor) addressor)
	       (t (read-record-word addressor descriptor)))
	 stream))

(defmethod unformat-data ((handler entity-storage-handler-mixin) value
			  entity-handle-table)
  (unless (or (null value) (zerop value))
    (multiple-value-bind (entity-handle found)
	(gethash value entity-handle-table)
      (unless found (error "Couldn't find entity in cached entities."))
      entity-handle)))

(scl:defflavor binary-32bit-dumping-stream
	(next-word
	 addressor
	 pending-byte
	 (buffer (cl:make-array 100 :element-type 'fixnum)))
	(si:buffered-character-stream))

;;; Dummy stream for binary dumper to write to so that we can size
;;; things up.
(scl:defflavor binary-32bit-sizing-only-stream
	(size)
	(binary-32bit-dumping-stream))

(scl:defflavor ascii-dumping-mixin () ())

(scl:defflavor ascii-32bit-dumping-stream ()
	   (ascii-dumping-mixin
	    binary-32bit-dumping-stream))

(defresource binary-32bit-dumping-stream ()
  :constructor (scl:make-instance 'binary-32bit-dumping-stream))

(defresource binary-32bit-sizing-stream ()
  :constructor (scl:make-instance 'binary-32bit-sizing-only-stream))

(defresource ascii-32bit-dumping-stream ()
  :constructor (scl:make-instance 'ascii-32bit-dumping-stream ))

(scl:defmethod (:new-output-buffer binary-32bit-dumping-stream) ()
  (declare (values array start end))
  (values buffer 0 (length buffer)))

(scl:defmethod (:send-output-buffer binary-32bit-dumping-stream) (array end cl:ignore)
  (let ((start 0)
	(array array)
	word)
    (declare (sys:array-register array))
    (when pending-byte
      (setq word (aref array 0))
      (cl:setf (sys:%logldb (byte 16 16) word) pending-byte)
      (cl:setf (read-record-word addressor next-word) word)
      (incf next-word)
      (setq start 1))
    (multiple-value-bind (count extra) (floor (- end start) 2)
      (cl:loop for record-word from next-word
	    repeat count
	    for i from start by 2 do
	(setq word (aref array i))
	(cl:setf (sys:%logldb (byte 16 16) word) (aref array (1+ i)))
	(cl:setf (read-record-word addressor record-word) word)
	    finally
	      (unless (zerop extra)
		(setq pending-byte (aref array (1- end))))
	      (incf next-word count)))))

(scl:defmethod (:send-output-buffer binary-32bit-sizing-only-stream) (cl:ignore end cl:ignore)
  (incf size end))

(scl:defmethod (:send-output-buffer ascii-32bit-dumping-stream) (array end cl:ignore)
  (let ((array array))
    (declare (sys:array-register array))
    (cl:loop for i from 0 below end do (cl:push (aref array i) addressor))))

(scl:defmethod (:discard-output-buffer binary-32bit-dumping-stream) (cl:ignore))

(scl:defmethod (:discard-input-buffer binary-32bit-dumping-stream) (cl:ignore))

(scl:defmethod (:next-input-buffer binary-32bit-dumping-stream) (&optional no-hang-p)
  (declare (cl:ignore no-hang-p) (values array start end eof-p))
  (let* ((array-size (length buffer))
	 (words-left (- (get-record-size addressor) next-word))
	 (words-to-return (min words-left (/ array-size 2)))
	 (buffer buffer))
    (declare (sys:array-register buffer))
    (cl:loop repeat words-to-return
	  for idx from 0 by 2 do
      (let ((word (read-record-word addressor next-word)))
	(cl:setf (aref buffer (1+ idx)) (sys:%logldb (byte 16 16) word))
	(cl:setf (aref buffer idx) (sys:%logldb (byte 16 0) word)))
      (incf next-word))
    (values buffer 0 (* 2 words-to-return) (= words-to-return words-left))))

(scl:defmethod (:next-input-buffer ascii-32bit-dumping-stream) (&optional no-hang-p)
  (declare (cl:ignore no-hang-p) (values array start end eof-p))
  (let ((buffer buffer))
    (declare (sys:array-register buffer))
    (cl:loop with words-this-buffer = 0
	  for byte in (nthcdr next-word addressor)
	  for i from 0 below (length buffer) do
      (cl:setf (aref buffer i) byte)
      (incf next-word)
      (incf words-this-buffer)
	  finally
	    (return (values buffer
			    0
			    words-this-buffer
			    (= words-this-buffer (- (length addressor) next-word)))))))

(scl:defmethod (:set-pointer binary-32bit-dumping-stream) (new-pointer)
  (setq pending-byte nil)
  (setq next-word new-pointer))

(scl:defmethod (initialize-sizing-stream binary-32bit-sizing-only-stream) ()
  (setq pending-byte nil
	size 0))

(scl:defmethod (output-size binary-32bit-sizing-only-stream) ()
  (ceiling size 2))

(scl:defmethod (:close binary-32bit-dumping-stream) (&rest cl:ignore)
  (when pending-byte
    (cl:setf (read-record-word addressor next-word) pending-byte)
    (setq si:stream-input-buffer nil)
    (setq pending-byte nil)))

(scl:defmethod (:close binary-32bit-sizing-only-stream) (&rest cl:ignore)
  (when pending-byte
    (incf size)))

(scl:defmethod (:truename binary-32bit-dumping-stream) ())

(scl:defmethod (:generic-pathname-and-plist binary-32bit-dumping-stream) ())

(scl:defmethod (:info binary-32bit-dumping-stream) ())

(scl:defmethod (initialize-stream binary-32bit-dumping-stream) (addressor-arg)
  (setq pending-byte nil
	addressor addressor-arg
	si:stream-input-buffer nil))

(scl:defmethod (:truename binary-32bit-sizing-only-stream) ())

;;; In 369.117 MMcM changed the bin dumper to send a :info message
;;; at the end of dumping.  This method is here so that we won't
;;; signal an error; we don't have any info to return.
(scl:defmethod (:info binary-32bit-sizing-only-stream) ())

(scl:compile-flavor-methods binary-32bit-dumping-stream binary-32bit-sizing-only-stream
			ascii-32bit-dumping-stream)	   

(defmacro binary-output-to-stream (stream forms)
  `(progn (let ((si:*bin-dump-table*
		  (cl:make-hash-table :test #'eql :locking nil)))
	    (si:start-bin-file ,stream)
	    (let ((si:*bin-dump-index* 0)
		  (si:*bin-dump-package* *statice-model-package*)
		  (si:*bin-dump-syntax* (si:find-lisp-syntax *statice-model-syntax*)))
	      (si:dump-attribute-list nil ,stream)
	      (dolist (form ,forms)
		(si:dump-form-to-eval form ,stream))))
	  (si:end-bin-file ,stream)))


;;; Utility functions for handling strings in records.

;;; The first code is stored in the lowest byte of the word.  Note that
;;; this is the opposite of PDP-10 byte ordering.

;;; start-byte is between 0 and 3
(defun read-string-from-record (addressor n-bytes start-offset
				&key into-string record-words start-byte)
  (multiple-value-bind (n-words n-leftovers)
      (floor n-bytes 4) 
    (sys:with-data-stack
      (let ((string (or into-string (cl:make-string n-bytes)))
	    (words (or record-words
		       (when (plusp n-bytes)
			 (read-multiple-record-word addressor
						    start-offset
						    (+ start-offset
						       n-words
						       (cl:if (zerop n-leftovers) 0 1))))))
	    (offset (cl:if record-words start-offset 0)))
	(when start-byte
	  (let ((word (aref words start-offset)))
	    (cl:loop for byte-num from start-byte below 4
		  for byte from 0
		  for position from (* 8 start-byte) by 8
		  while (plusp n-bytes) do
	      (cl:ignore byte-num)
	      (cl:setf (aref string byte) (cl:code-char (sys:%logldb (byte 8 position) word)))
	      (decf n-bytes)))
	  (incf offset)
	  (multiple-value-setq (n-words n-leftovers)
	    (floor n-bytes 4)))
	(cl:loop for byte from (cl:if start-byte
				(- 4 start-byte)
				0)
		       by 4
	      repeat n-words do
	  (let ((word (aref words offset)))
	    (cl:setf (aref string byte)       (cl:code-char (sys:%logldb (byte 8  0) word)))
	    (cl:setf (aref string (+ byte 1)) (cl:code-char (sys:%logldb (byte 8  8) word)))
	    (cl:setf (aref string (+ byte 2)) (cl:code-char (sys:%logldb (byte 8 16) word)))
	    (cl:setf (aref string (+ byte 3)) (cl:code-char (sys:%logldb (byte 8 24) word))))
	  (incf offset)
	      finally
		(when (plusp n-leftovers)
		  (let ((word (aref words offset)))
		    (cl:loop for i from 0 below n-leftovers
			  for byte from byte do
		      (cl:setf (aref string byte)
			    (cl:code-char (sys:%logldb (byte 8 (* i 8)) word))))))
		(return string))))))

(defun write-string-to-record (addressor n-bytes start-offset string)
  (multiple-value-bind (n-words n-leftovers)
      (floor n-bytes 4) 
    (sys:with-data-stack
      (let* ((n-total-words (+ n-words (cl:if (zerop n-leftovers) 0 1)))
	     (array (sys:make-stack-array n-total-words :type 'zl:art-fixnum)))
	(cl:loop for offset from 0
	      for byte from 0 by 4
	      repeat n-words do
	  (cl:setf (aref array offset)
		(sys:%logdpb (char-code (aref string (+ byte 3)))
			     (byte 8 24)
			     (sys:%logdpb (char-code (aref string (+ byte 2)))
					  (byte 8 16)
					  (sys:%logdpb (char-code (aref string (+ byte 1)))
						       (byte 8 8)
						       (char-code (aref string byte))))))
	      finally
		(when (plusp n-leftovers)
		  (cl:setf (aref array offset)
			(cl:loop with word = 0
			      for i from 0 below n-leftovers
			      for byte from byte do
			  (setq word
				(sys:%logdpb
				  (char-code (aref string byte)) (byte 8 (* i 8)) word))
			      finally
				(return word)))
		  (incf offset))
		(when (plusp n-total-words)
		  (write-multiple-record-word addressor
					      start-offset
					      (+ start-offset n-total-words)
					      array))
		(return (+ start-offset offset)))))))

;;; Return t if the value stored in the record is less than the value
;;; supplied as an argument.
(defun lessp-string-from-record (addressor record-n-bytes start-offset string)
  (let ((string-n-bytes (length string))
	(offset start-offset)
	(position 32)
	(word 0))
    (cl:loop for n-bytes from 0 do
      (when ( n-bytes string-n-bytes) (return nil))
      (when ( n-bytes record-n-bytes) (return t))
      (when (= position 32)
	(setq position 0)
	(setq word (read-record-word addressor offset))
	(incf offset))
      (let ((string-char (aref string n-bytes))
	    (record-char (cl:code-char (sys:%logldb (byte 8 position) word))))
	(incf position 8)
	(cond ((char< record-char string-char) (return t))
	      ((char> record-char string-char) (return nil)))))))


;;; Compare string in a record to string.  Return :lessp, :equal, or :greaterp.
(defun compare-string-from-record (addressor record-n-bytes start-offset string case-sensitive)
  (let ((string-n-bytes (length string))
	(offset start-offset)
	(position 32)
	(word 0)
	(char<-function (cl:if case-sensitive #'char< #'char-lessp))
	(char>-function (cl:if case-sensitive #'char> #'char-greaterp)))
    (cl:loop for n-bytes from 0 do
      (when ( n-bytes string-n-bytes)
	(return (cl:if (= record-n-bytes string-n-bytes) :equal :greaterp)))
      (when ( n-bytes record-n-bytes) (return :lessp))
      (when (= position 32)
	(setq position 0)
	(setq word (read-record-word addressor offset))
	(incf offset))
      (let ((string-char (aref string n-bytes))
	    (record-char (cl:code-char (sys:%logldb (byte 8 position) word))))
	(incf position 8)
	(cond ((funcall char<-function record-char string-char) (return :lessp))
	      ((funcall char>-function record-char string-char) (return :greaterp))))
      finally :equal)))


(defun compare-strings-from-records (addressor-1 addressor-2 n-bytes
				     start-offset-1 start-offset-2)
  (multiple-value-bind (n-words n-leftovers)
      (floor n-bytes 4) 
    (cl:loop for offset-1 from start-offset-1
	  for offset-2 from start-offset-2
	  repeat n-words do
      (unless (= (read-record-word addressor-1 offset-1)
		 (read-record-word addressor-2 offset-2))
	(return nil))
	  finally
	    (return
	      (or (zerop n-leftovers)
		  (let ((word-1 (read-record-word addressor-1 offset-1))
			(word-2 (read-record-word addressor-2 offset-1)))
		    (cl:loop for i from 0 below n-leftovers
			  always (= (sys:%logldb (byte 8 (* i 8)) word-1)
				    (sys:%logldb (byte 8 (* i 8)) word-2)))))))))


(defun record-compare-strings (addressor-1 n-bytes-1 start-offset-1
			       addressor-2 n-bytes-2 start-offset-2)
  (let ((offset-1 start-offset-1)
	(offset-2 start-offset-2)
	(position 32)
	(word-1 0)
	(word-2 0))
    (cl:loop for n-bytes from 0 do
      (when ( n-bytes n-bytes-2) (return (cl:if ( n-bytes n-bytes-1) :equal :greaterp)))
      (when ( n-bytes n-bytes-1) (return :lessp))
      (when (= position 32)
	(setq position 0)
	(setq word-1 (read-record-word addressor-1 offset-1))
	(setq word-2 (read-record-word addressor-2 offset-2))
	(incf offset-1)
	(incf offset-2))
      (let ((char-1 (cl:code-char (sys:%logldb (byte 8 position) word-1)))
	    (char-2 (cl:code-char (sys:%logldb (byte 8 position) word-2))))
	(incf position 8)
	(cond ((char< char-1 char-2) (return :lessp))
	      ((char> char-1 char-2) (return :greaterp)))))))


(defun compare-strings-case-sensitive-style-insensitive
       (string-1 n-bytes-1 string-2 n-bytes-2 type-map-1 type-map-2)
  (cl:loop for n-bytes from 0 do
    (when ( n-bytes n-bytes-2) (return (cl:if ( n-bytes n-bytes-1) :equal :greaterp)))
    (when ( n-bytes n-bytes-1) (return :lessp))
    (let* ((char-1 (aref string-1 n-bytes))
	   (char-2 (aref string-2 n-bytes))
	   (char-code-1 (char-code char-1))
	   (char-code-2 (char-code char-2))
	   (char-type-1 (si:char-type char-1))
	   (char-type-2 (si:char-type char-2)))
      (cond ((< char-code-1 char-code-2) (return :lessp))
	    ((> char-code-1 char-code-2) (return :greaterp))
	    (t
	     (let ((char-type-code-1 (cl:gethash char-type-1 type-map-1))
		   (char-type-code-2 (cl:gethash char-type-2 type-map-2)))
	       (cond
		 ((< char-type-code-1 char-type-code-2) (return :lessp))
		 ((> char-type-code-1 char-type-code-2) (return :greaterp)))))))))

;;; Examine a Lisp string and return the following information:
;;;  fat-p: t if the string is "really fat", nil otherwise.
;;;  n-words: the number of words to store the characters of the string
;;;  n-chars: the number of characters in the string
;;;  transition-table: the transition table, if the string is "really fat".
;;; This is useful for size-of-value methods, which should add in any
;;; extra var-words they use for length or package code or whatever.
(defun string-info (string)
  (declare (values fat-p n-words n-chars transition-table))
  (let ((n-chars (string-length string)))
    (cond ((string-really-fat-p string)
	   (using-resource (sizing-dumper bin:unsigned-byte-32-dumper-sizing-mixin)
	     ;;; +++ kludge until next system recompile
	     (let* ((old-array (zl:symeval-in-instance sizing-dumper 'si:transition-table))
		    (length (length old-array))
		    (new-array (zl:make-array 1000
					      :fill-pointer length
					      :type 'sys:art-fixnum)))
	       (cl:if old-array
		   (when (eq (zl:array-type
			       (zl:symeval-in-instance sizing-dumper 'si:transition-table))
			     'sys:art-16b)
		     (scl:copy-array-portion old-array 0 length new-array 0 length)
		     (cl:setf (zl:symeval-in-instance sizing-dumper 'si:transition-table)
			   new-array))
		   (cl:setf (zl:symeval-in-instance sizing-dumper 'si:transition-table)
			 new-array)))
	     (send sizing-dumper :initialize-dumper
		   ;; char-dumper-cont char-dumper-cont-p leader
		   ;; use-fill-pointer-p underlying-stream char-type-continuation
		   ;; dump-character-types
		   #'cl:ignore t nil t 'si:null-stream nil nil)
	     (send sizing-dumper :dump-string string 0 nil)
	     (values t
		     (send sizing-dumper :dump-string-bytes-needed)
		     n-chars
		     (send sizing-dumper :transition-table))))
	  (t (values nil
		     (ceiling n-chars 4)
		     n-chars
		     nil)))))

;;; The symbol handler is similar to the string handler in many ways;
;;; please examine the comments at the definition of the string
;;; handler.  Details of the ideas behind the design of this format can
;;; be found in >dlw>statice>new-datatypes.

;;; ++ Note: all the "max" variables are exclusive limits, which is
;;; consistent with Common Lisp conventions, but inconsistent with the
;;; "string" handler's constants.  The "string" handler ought to be
;;; changed.

;;; The representation of the size and offset of the string vary
;;; depending on fat v. thin and short v. long.

;;;  Offset is always measured in words.  The start of the variable area is:
;;;    Short: the *symbol-short-offset* field of the fixed word.
;;;    Long:  the *symbol-long-offset* field of the fixed word, and the first
;;;              two words of the variable area are the length and package code.

;;;  Size is more complicated:
;;;    Short, thin: In bytes, in the *symbol-short-size* field of the fixed word.
;;;    Short, fat : In words, in the *symbol-short-size* field of the fixed word.
;;;    Long, thin : In bytes, in the first word of the variable part.  This is
;;;                    then length of the string, and does NOT count the two words.
;;;    Long, fat  : In words, in the first word of the variable part.  This is
;;;                    the length of the variable part, and DOES count the two words.

(define-builtin-type symbol 5 5)

(eval-when (compile cl:load eval)
  (defconstant *symbol-long-short-byte* (byte 1 31))	;1=long
  (defconstant *symbol-fat-thin-byte* (byte 1 30))	;1=fat
  (defconstant *symbol-long-offset* (byte 30 0))
  (defconstant *symbol-short-package-code* (byte 5 25))
  (defconstant *symbol-max-short-package-code* (expt 2 5))
  (defconstant *symbol-short-size* (byte 7 18))
  (defconstant *symbol-max-short-size* (expt 2 7))
  (defconstant *symbol-short-offset* (byte 18 0))
  (defconstant *symbol-max-short-offset* (expt 2 18))
  (defparameter *symbol-operators* (list* 'eq 'eql *string-operators*))
);eval-when

(defmethod statice-typep ((handler symbol-handler) symbol)
  (with-slots (statice-type:original-presentation-type) handler
    (and (symbolp symbol)
	 (or (eql statice-type:original-presentation-type 'symbol)
	     (dw::ptypep symbol statice-type:original-presentation-type)))))

(defmethod check-spec ((handler symbol-handler) spec)
  (check-spec-standard 'symbol *symbol-operators*))

(defmethod check-operator ((handler symbol-handler) operator)
  (member operator *string-operators*))

(defmethod fixed-space ((handler symbol-handler))
  (values 32 0))

(defmethod size-of-value ((handler symbol-handler) symbol free database)
  (symbol-size-of-value symbol free database))

(defun symbol-size-of-value (symbol free database)
  (multiple-value-bind (fat-p n-words n-chars transition-table)
      (string-info (zl:get-pname symbol))
    (values (cl:if (or ( (cl:if fat-p n-words n-chars) *symbol-max-short-size*)
		    ( (encode-package symbol database) *symbol-max-short-package-code*)
		    ( free *symbol-max-short-offset*))
		(+ n-words 2)
		n-words)
	    transition-table)))

(defmethod size-of-field ((handler symbol-handler) addressor descriptor)
  (symbol-size-of-field addressor (read-record-word addressor descriptor)))

(defun symbol-size-of-field (addressor fixed-word)
  (let ((thin-p (zerop (sys:%logldb *symbol-fat-thin-byte* fixed-word))))
    (cl:if (zerop (sys:%logldb *symbol-long-short-byte* fixed-word))
	(cl:if thin-p
	    (ceiling (sys:%logldb *symbol-short-size* fixed-word) 4)	;Short, thin
	    (sys:%logldb *symbol-short-size* fixed-word))	;Short, fat
	(let ((size (read-record-word addressor
				      (sys:%logldb *symbol-long-offset* fixed-word))))
	  (cl:if thin-p
	      (+ 2 (ceiling size 4))		;Long, thin
	      size)))))				;Long, fat

(defmethod length-of-array ((handler symbol-handler) addressor descriptor)
  (symbol-length-of-record-string-in-bytes addressor (read-record-word addressor descriptor)))

(defun symbol-length-of-record-string-in-bytes (addressor desc)
  (let* ((thin-p (zerop (sys:%logldb *symbol-fat-thin-byte* desc)))
	 (short-p (zerop (sys:%logldb *symbol-long-short-byte* desc))))
    (cl:if thin-p
	(cl:if short-p
	    (sys:%logldb *symbol-short-size* desc)
	    (read-record-word addressor (sys:%logldb *symbol-long-offset* desc)))
	(let ((offset (cl:if short-p
			  (sys:%logldb *symbol-short-offset* desc)
			  (+ 2 (sys:%logldb *symbol-long-offset* desc)))))
	  (send addressor :set-pointer offset)
	  (using-resource (sizing-loader bin:unsigned-byte-32-loader)
	    (bin::initialize-loader sizing-loader nil t addressor t)
	    (send sizing-loader :string-dimensions))))))

(defmethod start-of-field ((handler symbol-handler) addressor descriptor)
  (symbol-start-of-field (read-record-word addressor descriptor)))

(defun symbol-start-of-field (fixed-word)
  (cl:if (zerop (sys:%logldb *symbol-long-short-byte* fixed-word))
      (sys:%logldb *symbol-short-offset* fixed-word)
      (sys:%logldb *symbol-long-offset* fixed-word)))

(defmethod read-value ((handler symbol-handler) addressor descriptor database &key &allow-other-keys)
  (symbol-read-value addressor (read-record-word addressor descriptor) database))

(defun symbol-read-value (addressor fixed-word database)
  (si:with-data-stack
    (multiple-value-bind (print-name package-code)
	(read-symbol-internal addressor fixed-word database)
      (cl:if (eq print-name *null-value*)
	  *null-value*
	  ;; Note: if intern makes a new symbol, it copies the print
	  ;; name off the data stack into a static area.
	  (values (cl:intern print-name (decode-package package-code database print-name)))))))

;;; The addressor and descriptor point to a symbol datum.  Read the
;;; print-name of the symbol into a stack-consed string, and return this
;;; string and the package code.  The caller must bind the data stack.
;;; If the value is null, return *null-value* and nil.

(defun read-symbol-internal (addressor fixed-word database)
  (declare (values print-name package-code))
  (cl:if (zerop fixed-word)
      *null-value*
      (let* ((thin-p (zerop (sys:%logldb *symbol-fat-thin-byte* fixed-word)))
	     (short-p (zerop (sys:%logldb *symbol-long-short-byte* fixed-word)))
	     (package-code (cl:if short-p
			       (sys:%logldb *symbol-short-package-code* fixed-word)
			       (read-record-word
				 addressor 
				 (1+ (sys:%logldb *symbol-long-offset* fixed-word)))))
	     (string-start (cl:if short-p
			       (sys:%logldb *symbol-short-offset* fixed-word)
			       (+ 2 (sys:%logldb *symbol-long-offset* fixed-word)))))
	(cond (thin-p
	       (let* ((n-bytes (cl:if short-p
				   (sys:%logldb *symbol-short-size* fixed-word)
				   (read-record-word
				     addressor
				     (sys:%logldb *symbol-long-offset* fixed-word))))
		      (into-string (sys:make-stack-array n-bytes :element-type 'string-char)))
		 (read-string-from-record addressor n-bytes string-start
					  :into-string into-string)
		 (values into-string package-code)))
	      (t
	       (using-resource (sizing-loader bin:unsigned-byte-32-loader)
		 (bin::initialize-loader sizing-loader
					 nil
					 t
					 addressor
					 (database-table-of-character-encodings database))
		 (send addressor :set-pointer string-start)
		 (let ((into-string (sys:make-stack-array
				      (send sizing-loader :string-dimensions)
				      :element-type 'character)))
		   (send sizing-loader :finish-input nil)
		   (send addressor :set-pointer string-start)
		   (send sizing-loader :load-string nil nil into-string)
		   (values into-string package-code))))))))


(defmethod write-value ((handler symbol-handler) symbol addressor descriptor free database transition-table size)
  (multiple-value-bind (new-fixed-word free)
      (symbol-write-value symbol addressor free database transition-table size)
    (setf (read-record-word addressor descriptor) new-fixed-word)
    free))


(defun symbol-write-value (symbol addressor free database transition-table size)
  (declare (values new-fixed-word free))
  (cond ((eq symbol *null-value*)
	 (values 0 free))
	(t
	 (let ((new-fixed-word 0)
	       (string (zl:get-pname symbol))
	       (package-code (encode-package symbol database)))
	   (cond ((string-really-fat-p string)
		  (let* ((long-p (or ( size *symbol-max-short-size*)
				     ( free *symbol-max-short-offset*)
				     ( package-code *symbol-max-short-package-code*))))
		    (cl:setf (sys:%logldb *symbol-fat-thin-byte* new-fixed-word) 1)
		    (cond (long-p
			   (cl:setf (sys:%logldb *symbol-long-short-byte* new-fixed-word) 1)
			   (cl:setf (sys:%logldb *symbol-long-offset* new-fixed-word) free)
			   (cl:setf (read-record-word addressor free) size)
			   (cl:setf (read-record-word addressor (1+ free)) package-code)
			   (send addressor :set-pointer (+ 2 free)))
			  (t
			   (cl:setf (sys:%logldb *symbol-long-short-byte* new-fixed-word) 0)
			   (cl:setf (sys:%logldb *symbol-short-size* new-fixed-word) size)
			   (cl:setf (sys:%logldb *symbol-short-offset* new-fixed-word)
				 (cl:if (zerop free) 1 free))	;**********
			   (cl:setf (sys:%logldb *symbol-short-package-code* new-fixed-word)
				 package-code)
			   (send addressor :set-pointer free)))
		    (write-fat-string string addressor database transition-table)
		    (values new-fixed-word (+ free size))))
		 (t
		  (let* ((n-bytes (length string))
			 (long-p (or ( n-bytes *symbol-max-short-size*)
				     ( free *symbol-max-short-offset*)
				     ( package-code *symbol-max-short-package-code*))))
		    (cl:setf (sys:%logldb *symbol-long-short-byte* new-fixed-word)
			  (cl:if long-p 1 0))
		    (cl:setf (sys:%logldb *symbol-fat-thin-byte* new-fixed-word) 0)
		    (cond (long-p
			   (cl:setf (sys:%logldb *symbol-long-offset* new-fixed-word) free)
			   (cl:setf (read-record-word addressor free) n-bytes)
			   (cl:setf (read-record-word addressor (1+ free)) package-code)
			   (incf free 2))
			  (t
			   (cl:setf (sys:%logldb *symbol-short-size* new-fixed-word) n-bytes)
			   (cl:setf (sys:%logldb *symbol-short-offset* new-fixed-word)
				 (cl:if (zerop free) 1 free))
			   (cl:setf (sys:%logldb *symbol-short-package-code* new-fixed-word)
				 package-code)))
		    (values new-fixed-word
			    (write-string-to-record addressor n-bytes free string)))))))))

(defun write-fat-string (string addressor database transition-table)
  (let (pending-encodings)
    (using-resource (sizing-dumper bin:unsigned-byte-32-dumper)
      (let* ((old-array (zl:symeval-in-instance sizing-dumper 'si:transition-table))
	     (length (length old-array))
	     (new-array (zl:make-array 1000
				       :fill-pointer length
				       :type 'sys:art-fixnum)))
	;;; +++ kludge this until the next system recompile.
	(cl:if old-array
	    (when (eq (zl:array-type
			(zl:symeval-in-instance sizing-dumper 'si:transition-table))
		      'sys:art-16b)
	      (scl:copy-array-portion old-array 0 length new-array 0 length)
	      (cl:setf (zl:symeval-in-instance sizing-dumper 'si:transition-table) new-array))
	    (cl:setf (zl:symeval-in-instance sizing-dumper 'si:transition-table)
		  new-array)))
      (send sizing-dumper :initialize-dumper
	    ;; char-dumper-cont char-dumper-cont-p leader
	    ;; use-fill-pointer-p underlying-stream
	    ;; char-type-continuation dump-character-types
	    #'cl:ignore t nil t addressor
	    #'(cl:lambda (index char-type char-set char-style bits offset)
		(note-schema-modified database)
		(let ((style (si:unparse-character-style char-style)))
		  ;; We can't call make-system-tuple here because
		  ;; we are getting called from within :dump-string. 
		  ;; :dump-string has pointers right into the record's
		  ;; word in the page.  make-system-tuple can
		  ;; cause compress-page to be called which moves the
		  ;; position of the record on the page.  Seems easier
		  ;; to just queue the new %%char-encoding tuples
		  ;; until afterwards
		  (cl:macrolet ((full-symbol-name (symbol)
			       `(string-append (cl:package-name (symbol-package ,symbol))
					       ":"
					       (symbol-name ,symbol))))
		    (cl:push (list index
				(or char-set (symbol-name char-set))
				(full-symbol-name (first style))
				(full-symbol-name (second style))
				(full-symbol-name (third style))
				bits
				offset)
			  pending-encodings))
		  (cl:setf (aref (database-table-of-character-encodings database) index)
			char-type)))
	    nil
	    :reuse-char-type-table-p
	    (database-table-of-character-types database))
      ;; string start end reuse-transition-table
      (send sizing-dumper :dump-string string 0 nil transition-table))
    (cl:loop for (index char-set family face size bits offset)
	      in pending-encodings do
      (make-system-tuple database "%%character-encoding"
			 "epsilon-code" index
			 "character-set" char-set
			 "family" family
			 "face" face
			 "size" size
			 "bits" bits
			 "offset" offset))))

(defmethod value-equal ((handler symbol-handler) addressor descriptor symbol database)
  (symbol-value-equal addressor (read-record-word addressor descriptor) symbol database))

(defun symbol-value-equal (addressor fixed-word symbol database)
  (let* ((short-p (zerop (sys:%logldb *symbol-long-short-byte* fixed-word)))
	 (thin-p (zerop (sys:%logldb *symbol-fat-thin-byte* fixed-word)))
	 (start-offset (cl:if short-p
			   (sys:%logldb *symbol-short-offset* fixed-word)
			   (+ 2 (sys:%logldb *symbol-long-offset* fixed-word))))
	 (package-code (cl:if short-p
			   (sys:%logldb *symbol-short-package-code* fixed-word)
			   (read-record-word addressor (- start-offset 1))))
	 (n-bytes (symbol-length-of-record-string-in-bytes addressor fixed-word)))
    (unless (zerop fixed-word)
      (and (= (encode-package symbol database) package-code)
	   (string-value-equal-internal
	     (zl:get-pname symbol) addressor database start-offset n-bytes thin-p
	     (unless thin-p
	       (cl:if short-p
		   (sys:%logldb *symbol-short-size* fixed-word)
		   (- (read-record-word addressor (- start-offset 2)) 2))))))))

;;; Compare a Lisp string and the Statice representation of a string for
;;; equality, considering case and style to be significant, a la
;;; string=.  n-bytes is the length of the Statice string, in bytes.   
;;; thin-p says whether the Statice string is "really thin" (all
;;; characters nil.nil.nil in char set 0) or not. n-words is the number
;;; of words of storage occupied by the representation of the string
;;; itself, not counting extra words for lengths or package codes; this
;;; argument is only provided if thin-p is false (the string is fat).
(defun string-value-equal-internal (string addressor database
				    start-offset n-bytes thin-p n-words)
  (cond (thin-p
	 (when (and (= n-bytes (length string)) (not (string-really-fat-p string)))
	   (multiple-value-bind (n-words n-leftovers)
	       (floor n-bytes 4) 
	     (cl:loop for offset from start-offset 
		   for byte from 0 by 4
		   repeat n-words do
	       (let ((word (read-record-word addressor offset)))
		 (unless (and
			   (= (char-code (aref string byte))
			      (sys:%logldb (byte 8  0) word))
			   (= (char-code (aref string (+ byte 1)))
			      (sys:%logldb (byte 8  8) word))
			   (= (char-code (aref string (+ byte 2)))
			      (sys:%logldb (byte 8 16) word))
			   (= (char-code (aref string (+ byte 3)))
			      (sys:%logldb (byte 8 24) word)))
		   (return nil)))
		   finally
		     (return
		       (or (zerop n-leftovers)
			   (let ((word (read-record-word addressor offset)))
			     (cl:loop for i from 0 below n-leftovers
				   for byte from byte
				   always (= (char-code (aref string byte))
					     (sys:%logldb (byte 8 (* i 8)) word))))))))))
	(t
	 ;; You know?  It's just so hard to find good honest legal
	 ;; help these days.  It's just too damn bad that this is
	 ;; consing up the same encoded stack array for value every
	 ;; time this is called.
	 (sys:with-data-stack
	   (let* ((record-words (read-multiple-record-word
				  addressor start-offset (+ start-offset n-words))))
	     (multiple-value-bind (nil size nil transition-table)
		 (string-info string)
	       (let ((stack-string (make-stack-vector size)))
		 (using-resource (array-writing-stream array-writing-byte-32-stream)
		   (initialize-array-writing-stream array-writing-stream stack-string)
		   (using-resource (sizing-dumper bin:unsigned-byte-32-dumper)
		     ;;; +++ kludge this until the next system recompile.
		     (let* ((old-array (zl:symeval-in-instance
					 sizing-dumper 'si:transition-table))
			    (length (length old-array))
			    (new-array (zl:make-array 1000
						      :fill-pointer length
						      :type 'sys:art-fixnum)))
		       (cl:if old-array
			   (when (eq (zl:array-type
				       (zl:symeval-in-instance
					 sizing-dumper 'si:transition-table))
				     'sys:art-16b)
			     (scl:copy-array-portion old-array 0 length new-array 0 length)
			     (cl:setf (zl:symeval-in-instance sizing-dumper 'si:transition-table)
				   new-array))
			   (cl:setf (zl:symeval-in-instance sizing-dumper 'si:transition-table)
				 new-array)))
		     (send sizing-dumper :initialize-dumper
			   #'cl:ignore t nil t array-writing-stream #'cl:ignore nil
			   :reuse-char-type-table-p
			   (database-table-of-character-types database))
		     (send sizing-dumper :dump-string string 0 nil transition-table))
		   (cl:loop for i below n-words
			 always (= (aref stack-string i) (aref record-words i)))))))))))

(defmethod value-null-p ((handler symbol-handler) addressor descriptor)
  (zerop (read-record-word addressor descriptor)))

(defmethod case-insensitive-type-p ((handler symbol-handler)) nil)

(defmethod comparable-p ((handler symbol-handler)) t)

(defmethod value-compare ((handler symbol-handler) addressor descriptor symbol database &key case-sensitive)
  (let* ((string (zl:get-pname symbol))
	 (fixed-word (read-record-word addressor descriptor))
	 (short-p (zerop (sys:%logldb *symbol-long-short-byte* fixed-word)))
	 (thin-p (zerop (sys:%logldb *symbol-fat-thin-byte* fixed-word)))
	 (start-offset (if short-p
			   (sys:%logldb *symbol-short-offset* fixed-word)
			   (+ 2 (sys:%logldb *symbol-long-offset* fixed-word)))))
    (cond ((zerop fixed-word) *null-value*)
	  ((eq symbol *null-value*) :lessp)
	  ((and thin-p (not (string-really-fat-p string)))
	   (compare-string-from-record
	     addressor
	     (length-of-array handler addressor descriptor)
	     start-offset
	     string
	     case-sensitive))
	  (t
	   (sys:with-data-stack
	     (case (signum (funcall (if case-sensitive
					#'sys:%string-exact-compare
					#'sys:%string-compare)
				    (string (read-value handler addressor descriptor database))
				    0 string 0 nil))
	       (-1 :lessp)
	       (0 :equal)
	       (1 :greaterp)))))))

(defmethod record-compare ((handler symbol-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (let* ((desc-1 (read-record-word addressor-1 descriptor-1))
	 (desc-2 (read-record-word addressor-2 descriptor-2))
	 (thin-p-1 (zerop (sys:%logldb *symbol-fat-thin-byte* desc-1)))
	 (thin-p-2 (zerop (sys:%logldb *symbol-fat-thin-byte* desc-2)))
	 (start-offset-1 (start-of-field handler addressor-1 descriptor-1))
	 (start-offset-2 (start-of-field handler addressor-2 descriptor-2)))
    (cond ((zerop start-offset-1)
	   (if (zerop start-offset-2) :equal :greaterp))
	  ((zerop start-offset-2) :lessp)
	  ((and thin-p-1 thin-p-2)
	   ;; should probably subst this inline since only one caller
	   (record-compare-strings
	     addressor-1
	     (length-of-array handler addressor-1 descriptor-1)
	     start-offset-1
	     addressor-2
	     (length-of-array handler addressor-2 descriptor-2)
	     start-offset-2))
	  (t
	   (sys:with-data-stack
	     (let* ((n-bytes-1 (length-of-array handler addressor-1 descriptor-1))
		    (n-bytes-2 (length-of-array handler addressor-2 descriptor-2))
		    (string-1 (sys:make-stack-array n-bytes-1 :element-type 'character))
		    (string-2 (sys:make-stack-array n-bytes-2 :element-type 'character)))
	       (read-value handler addressor-1 descriptor-1 database-1 :into-string string-1)
	       (read-value handler addressor-2 descriptor-2 database-2 :into-string string-2)
	       (compare-strings-case-sensitive-style-insensitive
		 string-1 n-bytes-1 string-2 n-bytes-2
		 (database-table-of-character-types database-1)
		 (database-table-of-character-types database-2))))))))

(defmethod adjust-variable-words ((handler symbol-handler) addressor descriptor added-n)
  (let ((fixed-word (read-record-word addressor descriptor)))
    (unless (zerop fixed-word)
      (setf (read-record-word addressor descriptor)
	    (symbol-adjust-variable-words (read-record-word addressor descriptor) added-n)))))

(defmethod format-data-internal ((handler symbol-handler) addressor descriptor stream database)
  (prin1 (when addressor
	   (si:with-data-stack
	     (multiple-value-bind (print-name package-code)
		 (read-symbol-internal addressor
				       (read-record-word addressor descriptor)
				       database)
	       (unless (eq print-name *null-value*)
		 (list (string-append print-name)
		       (decode-package-name package-code database))))))
	 stream))

(defmethod unformat-data ((handler symbol-handler) value table)
  (declare (ignore table))
  (if (null value)
      (values nil t)
      (values (intern (first value) (find-package (second value))) nil)))

(defun symbol-adjust-variable-words (fixed-word added-n)
  (if (zerop (sys:%logldb *symbol-long-short-byte* fixed-word))
      (incf (sys:%logldb *symbol-short-offset* fixed-word) added-n)
      (incf (sys:%logldb *symbol-long-offset* fixed-word) added-n))
  fixed-word)

(define-builtin-type-with-finder integer 6 integer-handler-finder)

(defun integer-handler-finder (presentation-type no-nulls)
  (multiple-value-bind (nil nil width)
      (decode-integer-data-args presentation-type no-nulls)
    (if (and (integerp width)
	     (<= width 32))
	'packed-integer
	'integer-handler)))

;;; Given a presentation type for an integer, return the start, end, and
;;; width in bits, or nil if something is wrong.
(defun decode-integer-data-args (presentation-type no-nulls)
  (declare (values start end width))
    (dw:with-type-decoded (nil data-args) presentation-type
       (unless (and (consp data-args)
		    (consp (rest data-args))
		    (null (rest (rest data-args))))
	 ;; length 2
	 (return-from decode-integer-data-args nil))
       (let ((start (first data-args))
	     (end (second data-args)))
	 (cond ((integerp start))
	       ((and (consp start)
		     (integerp (first start))
		     (null (rest start)))
		(setq start (1+ (first start))))
	       (t (return-from decode-integer-data-args nil)))
	 (cond ((integerp end)
		(setq end (1+ end)))		;end is one greater
	       ((and (consp end)
		     (integerp (first end))
		     (null (rest end)))
		(setq end (first end)))
	       (t (return-from decode-integer-data-args nil)))
	 (unless (> end start)
	   (return-from decode-integer-data-args nil))
	 (values start
		 end
		 (integer-length (- end start (cl:if no-nulls 1 0)))))))


;;; integer-key-mixin is a mixin flavor used by more than one
;;; storage-handler each of which stores integers in a different way.
;;; They all do keys the same way.
(defclass integer-key-mixin () ())

;;; In the integer-handler storage handler, the representation of
;;; integer has one fixed word.  If the value is an integer fits in 31
;;; bits, its low 31 bits are stored in the low 31 bits of the word, and
;;; the high bit of the word is zero.  If the value is the null value,
;;; the high bit of the word is one, and the rest of the word is zero.
;;; Otherwise, the value must be a large integer: the high bit of the
;;; word is one, and the rest of the word holds an offset to variable
;;; storage.  The first word of variable storage holds the size of the
;;; variable storage, not including the first word itself.  The
;;; remaining variable words hold the absolute value of the integer,
;;; broken into 31-bit pieces, least-significant first.  The sign bit of
;;; the integer is stored in the sign bit of the first (least
;;; significant) word.

(define-storage-handler integer-handler 6 nil (integer-key-mixin))

;;; Constants for integer-handler.
(defconstant *integer-tag* (byte 1 31))
(defconstant *integer-offset* (byte 31 0))
(defconstant *integer-short-max* (expt 2 30))	;exclusive
(defconstant *integer-short-min* (- (expt 2 30)))	;inclusive
(defconstant *integer-null-value* (sys:%logdpb 1 *integer-tag* 0))

;;; Check for the null value before you call this.
(defun integer-short-p (integer)
  (and (< integer *integer-short-max*)
       ( integer *integer-short-min*)))

(defmethod statice-typep ((handler integer-handler) int)
  (with-slots (statice-type:original-presentation-type) handler
    (and (integerp int)
	 (or (eq statice-type:original-presentation-type 'integer)
	     (dw::ptypep int statice-type:original-presentation-type)))))

(defmethod check-spec ((handler integer-handler) spec)
  (check-spec-standard 'integer '(equal eql > <   >= <= =)))

(defmethod check-operator ((handler integer-handler) operator)
  (member operator '(equal eql > <   >= <= =)))

(defmethod fixed-space ((handler integer-handler))
  (values 32 0))

(defmethod size-of-value ((handler integer-handler) int free database)
  (declare (ignore free database))
  (integer-size-of-value int))

(defun integer-size-of-value (int)
  (if (integer-short-p int) 0 (1+ (ceiling (zl:haulong (abs int)) 31))))

(defmethod size-of-field ((handler integer-handler) addressor descriptor)
  (integer-size-of-field addressor (read-record-word addressor descriptor)))

(defun integer-size-of-field (addressor fixed-word)
  (cl:if (zerop (sys:%logldb *integer-tag* fixed-word))
      0
      (let ((offset (sys:%logldb *integer-offset* fixed-word)))
	(cl:if (zerop offset)
	    0
	    (1+ (read-record-word addressor offset))))))

(defmethod start-of-field ((handler integer-handler) addressor descriptor)
  (integer-start-of-field (read-record-word addressor descriptor)))

(defun integer-start-of-field (fixed-word)
  (if (zerop (sys:%logldb *integer-tag* fixed-word))
      0
      (sys:%logldb *integer-offset* fixed-word)))

(defmethod read-value ((handler integer-handler) addressor descriptor database &rest keyargs)
  (declare (ignore database keyargs))
  (integer-read-value addressor (read-record-word addressor descriptor)))

(defun integer-read-value (addressor fixed-word)
  (cl:if (zerop (sys:%logldb *integer-tag* fixed-word))
      ;; Short integer, sign-extend it.
      (cl:if (zerop (sys:%logldb (byte 1 30) fixed-word))
	  fixed-word
	  (sys:%logdpb 1 (byte 1 31) fixed-word))
      ;; Long integer or null value.
      (let ((start-of-field (sys:%logldb *integer-offset* fixed-word)))
	(cl:if (zerop start-of-field)
	    *null-value*
	    (let* ((n-words (read-record-word addressor start-of-field))
		   (start-offset (1+ start-of-field))
		   (first-word (read-record-word addressor start-offset))
		   (answer (ldb (byte 31 0) first-word)))
	      (sys:with-data-stack
		(cl:loop with n-words-1 = (1- n-words)
		      with start-offset+1 = (1+ start-offset)
		      with words = (when (plusp n-words-1)
				     (read-multiple-record-word
				       addressor
				       start-offset+1
				       (+ start-offset+1 n-words-1)))
		      for offset from 0
		      for shift from 31 by 31
		      repeat n-words-1 do
		  (incf answer (ash (aref words offset) shift))))
	      (cl:if (minusp first-word) (- answer) answer))))))

(defmethod write-value ((handler integer-handler) int addressor descriptor free database table size)
  (declare (ignore database table size))
  (multiple-value-bind (new-fixed-word free)
      (integer-write-value int addressor free)
    (setf (read-record-word addressor descriptor) new-fixed-word)
    free))

(defun integer-write-value (int addressor free)
  (values
    (cond ((eq int *null-value*)
	   *integer-null-value*)
	  ((integer-short-p int)
	   (sys:%logldb (byte 31 0) int))
	  (t
	   (sys:with-data-stack
	     (let* ((new-fixed-word (sys:%logdpb 1 *integer-tag* free))
		    (n-words (ceiling (zl:haulong (abs int)) 31))
		    (abs-int (abs int))
		    (data-array (sys:make-stack-array (1+ n-words) :type 'zl:art-fixnum)))
	       (cl:setf (aref data-array 0) n-words)
	       (cl:setf (aref data-array 1)
		     (logior (ldb (byte 31 0) abs-int)
			     (cl:if (minusp int) (scl:lsh 1 31) 0)))
	       (cl:loop for position from 31 by 31
		     for data-array-index from 2
		     repeat (1- n-words) do
		 (cl:setf (aref data-array data-array-index)
		       (ldb (byte 31 position) abs-int)))
	       (write-multiple-record-word addressor
					   free
					   (setq free (+ free n-words 1))
					   data-array)
	       new-fixed-word))))
    free))

(defmethod value-equal ((handler integer-handler) addressor descriptor int database)
  (declare (ignore database))
  (integer-value-equal addressor (read-record-word addressor descriptor) int))

(defun integer-value-equal (addressor fixed-word int)
  (cl:if (zerop (sys:%logldb *integer-tag* fixed-word))
      ;; Short integer, sign-extend it.
      (= int (cl:if (zerop (sys:%logldb (byte 1 30) fixed-word))
		 fixed-word
		 (sys:%logdpb 1 (byte 1 31) fixed-word)))
      ;; Long integer or null value.
      (let ((start-of-field (sys:%logldb *integer-offset* fixed-word)))
	(unless (zerop start-of-field)
	  (let* ((n-words (read-record-word addressor start-of-field))
		 (start-offset (1+ start-of-field))
		 (abs-int (abs int)))
	    (and (= n-words (ceiling (zl:haulong abs-int) 31))
		 (= (read-record-word addressor start-offset)
		    (logior (ldb (byte 31 0) abs-int)
			    (cl:if (minusp int) (scl:lsh 1 31) 0)))
		 (cl:loop for offset from (1+ start-offset)
		       for position from 31 by 31
		       repeat (1- n-words)
		       always (= (read-record-word addressor offset)
				 (ldb (byte 31 position) abs-int)))))))))

(defmethod record-equal ((handler integer-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let ((fixed-word-1 (read-record-word addressor-1 descriptor-1))
	(fixed-word-2 (read-record-word addressor-2 descriptor-2)))
    (cond ((zerop (sys:%logldb *integer-tag* fixed-word-1))
	   (= fixed-word-1 fixed-word-2))
	  ((or (zerop (sys:%logldb *integer-tag* fixed-word-2))
	       (= fixed-word-1 *integer-null-value*)
	       (= fixed-word-2 *integer-null-value*))
	   nil)
	  (t
	   ;; They are both long numbers and not null values.
	   (let* ((start-of-field-1 (sys:%logldb *integer-offset* fixed-word-1))
		  (start-of-field-2 (sys:%logldb *integer-offset* fixed-word-2))
		  (n-words-1 (read-record-word addressor-1 start-of-field-1))
		  (n-words-2 (read-record-word addressor-2 start-of-field-2)))
	     (and (= n-words-1 n-words-2)
		  (loop for offset-1 from (1+ start-of-field-1)
			for offset-2 from (1+ start-of-field-2)
			repeat n-words-1
			always (= (read-record-word addressor-1 offset-1)
				  (read-record-word addressor-2 offset-2)))))))))

(defmethod value-null-p ((handler integer-handler) addressor descriptor)
  (= (read-record-word addressor descriptor)
     *integer-null-value*))

(defmethod comparable-p ((handler integer-handler)) t)

;;; Maybe someday this will work w/o consing, eh?
(defmethod value-compare ((handler integer-handler) addressor descriptor value database &rest keyargs)
  (declare (ignore database keyargs))
  (let ((fixed-word (read-record-word addressor descriptor)))
    (if (= fixed-word *integer-null-value*)
	*null-value*
	(let ((n
		(if (zerop (sys:%logldb *integer-tag* fixed-word))
		    ;; Short integer, sign-extend it.
		    (if (zerop (sys:%logldb (byte 1 30) fixed-word))
			fixed-word
			(sys:%logdpb 1 (byte 1 31) fixed-word))
		    (read-value handler addressor descriptor nil))))
	  (cond ((< n value) :lessp)
		((> n value) :greaterp)
		(t :equal))))))

(defmethod record-compare ((handler integer-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (let ((value-1 (read-value handler addressor-1 descriptor-1 nil))
	(value-2 (read-value handler addressor-2 descriptor-2 nil)))
    (cond ((eq value-1 *null-value*)
	   (if (eq value-2 *null-value*) :equal :greaterp))
	  ((eq value-2 *null-value*) :lessp)
	  ((< value-1 value-2) :lessp)
	  ((> value-1 value-2) ::greaterp)
	  (t :equal))))

(defmethod adjust-variable-words ((handler integer-handler) addressor descriptor added-n)
  (let ((new-fixed-word
	  (integer-adjust-variable-words (read-record-word addressor descriptor) added-n)))
    (when new-fixed-word
      (setf (read-record-word addressor descriptor) new-fixed-word))))

(defun integer-adjust-variable-words (fixed-word added-n)
  (unless (zerop (sys:%logldb *integer-tag* fixed-word))
    (let ((offset (sys:%logldb *integer-offset* fixed-word)))
      (when (plusp offset)
	(sys:%logdpb 1 *integer-tag* (+ offset added-n))))))

;;; Storage handler for integers of limited range, which can be packed
;;; into a field of fixed size.  start is the lowest integer that can be
;;; represented, inclusively.  end is the highest number that can be
;;; represented, exclusively.  width is the width of the byte field,
;;; in bits.
(define-storage-handler packed-integer 11 (start end width) (integer-key-mixin))

;;; Take apart the presentation type data arguments, make sure they're OK,
;;; examine them along with no-nulls, and initialize the start, end, width,
;;; and nulls-allowed instance variables.
(defmethod clos:initialize-instance :after ((handler packed-integer) &rest initargs)
  (declare (ignore initargs))
  (with-slots (start end width
	       statice-type:presentation-type
	       statice-type:no-nulls
	       statice-type:original-presentation-type) handler
    (multiple-value-setq (start end width)
      (decode-integer-data-args statice-type::presentation-type statice-type:no-nulls))
    (compiler:%error-unless start
      (error "Internal error -- ~S presentation type should not get here"
	     statice-type::original-presentation-type))))

(defmethod statice-typep ((handler packed-integer) value)
  (with-slots (statice-type:original-presentation-type start end) handler
    (and (integerp value)
	 (>= value start)
	 (< value end)
	 (or (and (consp statice-type:original-presentation-type)
		  (eq (first statice-type:original-presentation-type) 'integer))
	     (dw::ptypep value statice-type:original-presentation-type)))))

(defmethod check-spec ((handler packed-integer) spec)
  (check-spec-standard 'integer '(equal eql > <   >= <= =)))

(defmethod check-operator ((handler packed-integer) operator)
  (member operator '(equal eql > <   >= <= =)))

(defmethod fixed-space ((handler packed-integer))
  (with-slots (width) handler
    (values width 1)))

(defmethod read-value ((handler packed-integer) addressor descriptor database &rest keyargs)
  (declare (ignore database keyargs))
  (with-slots (start end width) handler
    (let ((int (+ start
		  (ldb (byte width (desc-bit-offset descriptor))
		       (read-record-word addressor (desc-word-offset descriptor))))))
      (if (= int end) *null-value* int))))

(defmethod write-value ((handler packed-integer) value addressor descriptor free database table size)
  (declare (ignore database table size))
  (with-slots (start end width) handler
    (setf (sys:%logldb (byte width (desc-bit-offset descriptor))
		       (read-record-word addressor (desc-word-offset descriptor)))
	  (- (if (eq value *null-value*) end value) start))
    free))

(defmethod value-equal ((handler packed-integer) addressor descriptor value database)
  (declare (ignore database))
  (with-slots (start end width) handler
    (let ((int (+ start
		  (ldb (byte width (desc-bit-offset descriptor))
		       (read-record-word addressor (desc-word-offset descriptor))))))
      (unless (= int end)
	(= int value)))))

(defmethod record-equal ((handler packed-integer) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (with-slots (start end width) handler
    (let ((int-1 (+ start
		    (ldb (byte width (desc-bit-offset descriptor-1))
			 (read-record-word addressor-1
					   (desc-word-offset descriptor-1)))))
	  (int-2 (+ start
		    (ldb (byte width (desc-bit-offset descriptor-2))
			 (read-record-word addressor-2
					   (desc-word-offset descriptor-2))))))
      (unless (= int-1 end)
	(= int-1 int-2)))))

(defmethod value-null-p ((handler packed-integer) addressor descriptor)
  (with-slots (start end width) handler
    (= end (+ start
	      (ldb (byte width (desc-bit-offset descriptor))
		   (read-record-word addressor (desc-word-offset descriptor)))))))

(defmethod comparable-p ((handler packed-integer)) t)

(defmethod value-compare ((handler packed-integer) addressor descriptor value database &rest keyargs)
  (declare (ignore database keyargs))
  (with-slots (start end width) handler
    (let ((int (+ start
		  (ldb (byte width (desc-bit-offset descriptor))
		       (read-record-word addressor (desc-word-offset descriptor))))))
      (cond ((= int end) *null-value*)
	    ((< int value) :lessp)
	    ((> int value) :greaterp)
	    (t :equal)))))

(defmethod record-compare ((handler packed-integer) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (with-slots (start end width) handler
    (let ((int-1 (+ start
		    (ldb (byte width (desc-bit-offset descriptor-1))
			 (read-record-word addressor-1
					   (desc-word-offset descriptor-1)))))
	  (int-2 (+ start
		    (ldb (byte width (desc-bit-offset descriptor-2))
			 (read-record-word addressor-2
					   (desc-word-offset descriptor-2))))))
      (cond ((= int-1 end)
	     (if (= int-2 end) :equal :greaterp))
	    ((= int-2 end) :lessp)
	    ((< int-1 int-2) :lessp)
	    ((> int-1 int-2) :greaterp)
	    (t :equal)))))

(scl:define-presentation-type lisp-object ()
   :abbreviation-for t)

(assign-type-to-handler t lisp-object-handler)

(define-builtin-type lisp-object 7 7)

(defvar *lisp-object* nil)
(defconstant *lisp-object-tag* (byte 4 28))
(defconstant *lisp-object-offset* (byte 28 0))
(defconstant *lisp-object-null* 1)
(defconstant *lisp-object-nil* 2)
(defconstant *lisp-object-integer* 3)
(defconstant *lisp-object-string* 4)
(defconstant *lisp-object-symbol* 5)
(defconstant *lisp-object-single-float* 6)
(defconstant *lisp-object-entity* 7)
(defconstant *lisp-object-dumper* 8)

(defmethod statice-typep ((handler lisp-object-handler) object)
  (with-slots (statice-type:original-presentation-type) handler
    (or (eq statice-type:original-presentation-type 'lisp-object)
	(dw::ptypep object statice-type:original-presentation-type))))

(defmethod check-spec ((handler lisp-object-handler) spec)
  (cond ((or (and (listp spec)
		  (= (length spec) 2)
		  (typep (second spec) 'entity-handle))
	     (and (listp spec) (eq (first spec) 'null)))
	 (check-entity-spec spec nil))
	(t t)))

(defmethod check-operator ((handler lisp-object-handler) operator)
  (member operator '(equal eql eq)))

(defmethod fixed-space ((handler lisp-object-handler))
  (values 64 0))

(defmethod size-of-value ((handler lisp-object-handler) value free database)
  (cond ((eq value *null-value*) 0)
	((null value) 0)
	(t
	 (typecase value
	   (integer (integer-size-of-value value))
	   (string (string-size-of-value value free))
	   (symbol (symbol-size-of-value value free database))
	   (single-float 0)
	   (entity-handle 0)
	   (t
	     (using-resource (sizing-stream binary-32bit-sizing-stream)
	       (initialize-sizing-stream sizing-stream)
	       (binary-output-to-stream sizing-stream (list `(setq *lisp-object* ',value)))
	       (output-size sizing-stream)))))))

(defmethod size-of-field ((handler lisp-object-handler) addressor descriptor)
  (let ((first-word (read-record-word addressor descriptor)))
    (zl:select (sys:%logldb *lisp-object-tag* first-word)
      (*lisp-object-null* 0)
      (*lisp-object-nil* 0)
      (*lisp-object-integer*
	(integer-size-of-field addressor (read-record-word addressor (1+ descriptor))))
      (*lisp-object-string*
	(string-size-of-field addressor (read-record-word addressor (1+ descriptor))))
      (*lisp-object-symbol*
	(symbol-size-of-field addressor (read-record-word addressor (1+ descriptor))))
      (*lisp-object-single-float* 0)
      (*lisp-object-entity* 0)
      (*lisp-object-dumper* (read-record-word addressor (1+ descriptor))))))

(defmethod start-of-field ((handler lisp-object-handler) addressor
			   descriptor)
  (let ((first-word (read-record-word addressor descriptor)))
    (zl:select (sys:%logldb *lisp-object-tag* first-word)
      (*lisp-object-null* 0)
      (*lisp-object-nil* 0)
      (*lisp-object-integer*
	(integer-start-of-field (read-record-word addressor (1+ descriptor))))
      (*lisp-object-string*
	(string-start-of-field (read-record-word addressor (1+ descriptor))))
      (*lisp-object-symbol*
	(symbol-start-of-field (read-record-word addressor (1+ descriptor))))
      (*lisp-object-single-float* 0)
      (*lisp-object-entity* 0)
      (*lisp-object-dumper* (sys:%logldb *lisp-object-offset* first-word)))))

(defmethod entity-type-p ((handler lisp-object-handler))
  t)

(defmethod read-value ((handler lisp-object-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (let ((first-word (read-record-word addressor descriptor)))
    (zl:select (sys:%logldb *lisp-object-tag* first-word)
      (*lisp-object-null* *null-value*)
      (*lisp-object-nil* nil)
      (*lisp-object-integer*
	(integer-read-value addressor (read-record-word addressor (1+ descriptor))))
      (*lisp-object-string*
	(string-read-value addressor (read-record-word addressor (1+ descriptor))
			   database into-string stack-cons-if-appropriate))
      (*lisp-object-symbol*
	(symbol-read-value addressor (read-record-word addressor (1+ descriptor)) database))
      (*lisp-object-single-float*
	(single-float-read-value (read-record-word addressor (1+ descriptor))))
      (*lisp-object-entity*
	(find-entity-handle-given-rid (read-record-word addressor (1+ descriptor)) database))
      (*lisp-object-dumper*
	(let ((*lisp-object* nil))
	  (using-resource (loading-stream binary-32bit-dumping-stream)
	    (send loading-stream :set-pointer (sys:%logldb *lisp-object-offset* first-word))
	    (initialize-stream loading-stream addressor)
	    (si:bin-load-file-internal loading-stream *statice-model-package* t))
	  *lisp-object*)))))

(defmethod write-value ((handler lisp-object-handler) value addressor descriptor free
			database transition-table size)
  (let ((first-word 0)
	(second-word nil)
	(tag-value nil)
	(new-free free))
    (cond ((eq value *null-value*)
	   (setq tag-value *lisp-object-null*))
	  ((null value)
	   (setq tag-value *lisp-object-nil*))
	  (t
	   (typecase value
	     (integer
	       (setq tag-value *lisp-object-integer*)
	       (multiple-value-setq (second-word new-free) 
		 (integer-write-value value addressor free)))
	     (string
	       (setq tag-value *lisp-object-string*)
	       (multiple-value-setq (second-word new-free)
		 (string-write-value value addressor free database transition-table size)))
	     (symbol
	       (setq tag-value *lisp-object-symbol*)
	       (multiple-value-setq (second-word new-free)
		 (symbol-write-value value addressor free database transition-table size)))
	     (single-float
	       (setq tag-value *lisp-object-single-float*)
	       (setq second-word (single-float-write-value value)))
	     (entity-handle
	       (setq tag-value *lisp-object-entity*)
	       (setq second-word
		     (find-entity-record-in-database value database :create t)))
	     (t
	       (setq tag-value *lisp-object-dumper*)
	       (let ((form (list `(setq *lisp-object* ',value))))
		 (using-resource (dumping-stream binary-32bit-dumping-stream)
		   (setq first-word free)
		   (setq second-word size)
		   (setq new-free (+ free size))
		   (send dumping-stream :set-pointer free)
		   (initialize-stream dumping-stream addressor)
		   (binary-output-to-stream dumping-stream form)))))))
    (setf (read-record-word addressor descriptor)
	  (sys:%logdpb tag-value *lisp-object-tag* first-word))
    (when second-word
      (setf (read-record-word addressor (1+ descriptor)) second-word))
    new-free))

(defmethod value-null-p ((handler lisp-object-handler) addressor descriptor)
  (let ((first-word (read-record-word addressor descriptor)))
    (= (sys:%logldb *lisp-object-tag* first-word) *lisp-object-null*)))

(defmethod value-equal ((handler lisp-object-handler) addressor descriptor value database)
  (let ((first-word (read-record-word addressor descriptor)))
    (zl:select (sys:%logldb *lisp-object-tag* first-word)
      (*lisp-object-null* nil)
      (*lisp-object-nil* (null value))
      (*lisp-object-integer*
	(and (integerp value)
	     (integer-value-equal
	       addressor (read-record-word addressor (1+ descriptor)) value)))
      (*lisp-object-string*
	(and (stringp value)
	     (string-value-equal addressor (read-record-word addressor (1+ descriptor))
				 value database)))
      (*lisp-object-symbol*
	(and (symbolp value)
	     (symbol-value-equal addressor (read-record-word addressor (1+ descriptor))
				 value database)))
      (*lisp-object-single-float*
	(and (typep value 'single-float)
	     (single-float-value-equal (read-record-word addressor (1+ descriptor)) value)))
      (*lisp-object-entity*
	(and (typep value 'entity-handle)
	     (entity-value-equal (read-record-word addressor (1+ descriptor))
				 value database)))
      (*lisp-object-dumper*
	(unless (or (null value)
		    (integerp value)
		    (stringp value)
		    (symbolp value)
		    (typep value 'single-float)
		    (typep value 'entity-handle))
	  (eql value
	       (let ((*lisp-object* nil))
		 (using-resource (loading-stream binary-32bit-dumping-stream)
		   (send loading-stream :set-pointer
			 (sys:%logldb *lisp-object-offset* first-word))
		   (initialize-stream loading-stream addressor)
		   (si:bin-load-file-internal loading-stream *statice-model-package* t))
		 *lisp-object*)))))))

(defmethod adjust-variable-words ((handler lisp-object-handler) addressor descriptor added-n)
  (let ((first-word (read-record-word addressor descriptor)))
    (zl:select (sys:%logldb *lisp-object-tag* first-word)
      (*lisp-object-null*)
      (*lisp-object-nil*)
      (*lisp-object-integer*
	(let ((new-fixed-word (integer-adjust-variable-words
				(read-record-word addressor (1+ descriptor)) added-n)))
	  (when new-fixed-word 
	    (setf (read-record-word addressor (1+ descriptor))
		  new-fixed-word))))
      (*lisp-object-string*
	(setf (read-record-word addressor (1+ descriptor))
	      (string-adjust-variable-words
		(read-record-word addressor (1+ descriptor)) added-n)))
      (*lisp-object-symbol*
	(setf (read-record-word addressor (1+ descriptor))
	      (symbol-adjust-variable-words
		(read-record-word addressor (1+ descriptor)) added-n)))
      (*lisp-object-single-float*)
      (*lisp-object-entity*)
      (*lisp-object-dumper*
	(setf (read-record-word addressor descriptor)
	      (sys:%logdpb (+ (sys:%logldb *lisp-object-offset* first-word)
			      added-n)
			   *lisp-object-offset*
			   first-word))))))

(defmethod format-value-internal ((handler lisp-object-handler) value value-not-null-p stream)
  (prin1 (if value-not-null-p
	     (let ((form (list `(setq *lisp-object* ',value))))
	       (using-resource (dumping-stream ascii-32bit-dumping-stream)
		 (initialize-stream dumping-stream nil)
		 (binary-output-to-stream dumping-stream form)
		 (nreverse (zl:symeval-in-instance dumping-stream 'addressor))))
	     'the-null-value)
	 stream))

(defmethod unformat-data ((handler lisp-object-handler) value eh-table)
  (declare (ignore eh-table))
  (if (eq value 'the-null-value)
      (values nil t)
       (let ((*lisp-object* nil))
	 (using-resource (loading-stream ascii-32bit-dumping-stream)
	   (initialize-stream loading-stream value)
	   (send loading-stream :set-pointer 0)
	   (si:bin-load-file-internal
	     loading-stream *statice-model-package* t))
	 *lisp-object*)))

(defmethod nil-is-valid-value ((handler lisp-object-handler))
  t)

(defmethod comparable-p ((handler lisp-object-handler))
  (with-slots (statice-type:original-presentation-type) handler
    (eq statice-type:original-presentation-type 'number)))

;;Needs some efficiency work at some point.
(defmethod value-compare ((handler lisp-object-handler) addressor descriptor value database &rest keyargs)
  (declare (ignore database keyargs))
  (let ((record-value (read-value handler addressor descriptor *current-database*)))
    (cond ((eq record-value *null-value*)
	   *null-value*)
	  ((eq value *null-value*) :lessp)
	  ((< record-value value) :lessp)
	  ((> record-value value) :greaterp)
	  (t :equal))))

(scl:define-presentation-type att-type ()
   :abbreviation-for '(or dw:presentation-type domain-handle))

(define-builtin-type att-type 8 8)

;;; Given any presentation type, return a string containing its printed
;;; representation.  Signal sys:print-not-readable if the argument
;;; cannot be printed in a readable way.
(defun convert-presentation-type-to-string (presentation-type)
  (with-standard-io-environment
    (let ((*package* (cl:find-package 'cl)))
      (prin1-to-string presentation-type))))

;;; Given a printed representation of a presentation type from
;;; convert-presentation-type-to-string, return the presentation type.
(defun convert-string-to-presentation-type (string)
  (with-standard-io-environment
    (let ((*package* (cl:find-package 'cl)))
      (read-from-string string))))

(defconstant *att-type-tag* (byte 4 28))
(defconstant *att-type-offset* (byte 28 0))
(defconstant *att-type-null* 1)
(defconstant *att-type-builtin* 2)
(defconstant *att-type-string* 3)
(defconstant *att-type-entity* 4)

;;; No checking is needed here, because the only way any value can land
;;; here is via make-attribute, which already checks the type itself.
(defmethod statice-typep ((handler att-type-handler) object)
  (declare (ignore object))
  t)

(defmethod fixed-space ((handler att-type-handler))
  (values 64 0))

(defmethod size-of-value ((handler att-type-handler) value free database)
  (declare (ignore database))
  (cond ((eq value *null-value*) 0)
	((typep value 'domain-handle) 0)
	((att-type-builtin-encode value) 0)
	(t (string-size-of-value (convert-presentation-type-to-string value) free))))

(defmethod size-of-field ((handler att-type-handler) addressor descriptor)
  (let ((first-word (read-record-word addressor descriptor)))
    (if (= (sys:%logldb *att-type-tag* first-word) *att-type-string*)
	(string-size-of-field addressor (read-record-word addressor (1+ descriptor)))
	0)))

(defmethod start-of-field ((handler att-type-handler) addressor descriptor)
  (let ((first-word (read-record-word addressor descriptor)))
    (if (= (sys:%logldb *att-type-tag* first-word) *att-type-string*)
	(string-start-of-field (read-record-word addressor (1+ descriptor)))
	0)))

(defmethod entity-type-p ((handler att-type-handler))
  t)

(defmethod read-value ((handler att-type-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (let ((first-word (read-record-word addressor descriptor)))
    (zl:select (sys:%logldb *att-type-tag* first-word)
      (*att-type-null* *null-value*)
      (*att-type-builtin*
	(att-type-builtin-decode (sys:%logldb *att-type-offset* first-word)))
      (*att-type-string*
	(convert-string-to-presentation-type 
	  (string-read-value addressor (read-record-word addressor (1+ descriptor))
			     database into-string stack-cons-if-appropriate)))
      (*att-type-entity*
	(find-entity-handle-given-rid
	  (read-record-word addressor (1+ descriptor)) database)))))

(defmethod write-value ((handler att-type-handler) value addressor descriptor free database transition-table size)
  (let ((first-word 0)
	(second-word nil)
	(tag-value nil)
	(new-free free))
    (cond ((eq value *null-value*)
	   (setq tag-value *att-type-null*))
	  ((typep value 'entity-handle)
	   (setq tag-value *att-type-entity*)
	   (setq second-word
		 (find-entity-record-in-database value database :create t)))
	  (t
	   (let ((int (att-type-builtin-encode value)))
	     (cond (int
		    (setq tag-value *att-type-builtin*)
		    (setq first-word int))
		   (t
		    (setq tag-value *att-type-string*)
		    (multiple-value-setq (second-word new-free)
		      (string-write-value
			(convert-presentation-type-to-string value)
			addressor free database transition-table size)))))))
    (setf (read-record-word addressor descriptor)
	  (sys:%logdpb tag-value *att-type-tag* first-word))
    (when second-word
      (setf (read-record-word addressor (1+ descriptor)) second-word))
    new-free))

(defmethod value-equal ((handler att-type-handler) addressor descriptor value database)
  (declare (ignore addressor descriptor value database))
  nil)

(defmethod adjust-variable-words ((handler att-type-handler) addressor descriptor added-n)
  (let ((first-word (read-record-word addressor descriptor)))
    (when (= (sys:%logldb *att-type-tag* first-word) *att-type-string*)
      (setf (read-record-word addressor (1+ descriptor))
	    (string-adjust-variable-words
	      (read-record-word addressor (1+ descriptor)) added-n)))))

(defmethod format-value-internal ((handler att-type-handler) value value-not-null-p stream)
  (prin1 (when value-not-null-p
	   (if (typep value 'domain-handle)
	       (list 'domain-handle (domain-handle-name value))
	       value))
	 stream))

(defmethod unformat-data ((handler att-type-handler) value table)
  (declare (ignore table))
  (if (and (listp value)
	   (= (length value) 2)
	   (eq (first value) 'domain-handle))
      (get-domain (second value))
      value))

(defconstant *vf-long-short-byte* (byte 1 31))	;1=long
(defconstant *vf-long-offset* (byte 31 0))
(defconstant *vf-short-size* (byte 17 14))
(defconstant *vf-short-offset* (byte 14 0))
(defconstant *vf-max-short-size* (expt 2 17))
(defconstant *vf-max-short-offset* (expt 2 14))

;;; This mixin provides the format-data and unformat-data methods for
;;; fixed storage handlers, both known and unknown.
(defclass fixed-dumper-mixin () ())

;;; This mixin provides the format-data and unformat-data methods for
;;; variable storage handlers, both known and unknown.
(defclass variable-dumper-mixin () ())

(defclass fixed-format-handler
	  (fixed-dumper-mixin value-storage-handler)
    ())

(defclass variable-format-handler
	  (variable-dumper-mixin value-storage-handler)
    ())

(defun format-binary-word (word stream)
  (send stream :tyo #\")
  (cl:loop for pos below 32 by 4 do
    (send stream :tyo (cl:code-char (+ #.(char-code #\A) (sys:%logldb (byte 4 pos) word)))))
  (write-string "\" " stream))

(defun unformat-binary-word (string)
  (cl:loop with word = 0
	for pos below 32 by 4
	for i from 0 do
    (cl:setf (sys:%logldb (byte 4 pos) word) (- (char-code (aref string i)) #.(char-code #\A)))
    finally (return word)))

;;; This flavor acts like a record addressor, but the data is really in
;;; a Lisp array.  It's used by unformat-data for physical extended
;;; datatypes.  The binary data from the dumper file is placed into this
;;; array, and then the read-value routine is invoked to build the
;;; actual object, so that Load Database can give the object to
;;; make-clustered-tuple.
(scl:defflavor fake-record ((words (cl:make-array 100))
			(size 100))
	   ()
  (:constructor make-fake-record))

(defresource fake-record ()
  :constructor (make-fake-record))

(scl:defmethod (read-record-word fake-record) (index &key buffer-p)
  (declare (cl:ignore buffer-p))
  (aref words index))

(scl:defmethod (write-record-word fake-record) (index new-value &key buffer-p)
  (declare (cl:ignore buffer-p))
  (unless (< index size)
    (setq size (max index (* 2 size)))
    (cl:adjust-array words size))
  (cl:setf (aref words index) new-value))

(scl:defmethod (read-multiple-record-word fake-record) (start-index end-index &key into into-start)
  (let* ((n-words (- end-index start-index))
	 (array (or into (sys:make-stack-array n-words :type 'zl:art-fixnum))))
    (declare (sys:array-register array))
    (cl:loop for i from start-index
	  for array-index from (or into-start 0)
	  repeat n-words do
      (cl:setf (aref array array-index)
	    (aref words i)))
    array))

(scl:defmethod (write-multiple-record-word fake-record) (start-index end-index new-value)
  (let ((array new-value))
    (declare (sys:array-register array))
    (unless (< end-index size)
      (setq size (max end-index (* 2 size)))
      (cl:adjust-array words size))
    (cl:loop for i from start-index below end-index
	  for array-index from 0 do
      (cl:setf (aref words i)
	    (aref array array-index)))))

(scl:compile-flavor-methods fake-record)

(defmethod format-data-internal ((handler variable-dumper-mixin) addressor descriptor stream database)
  (declare (ignore database))
  (if (null addressor)
      (prin1 nil stream)
      (let ((fixed-word (read-record-word addressor descriptor)))
	(if (zerop fixed-word)
	    (prin1 nil stream)
	    (let (offset size)
	      (cond ((zerop (sys:%logldb *vf-long-short-byte* fixed-word))
		     (setq offset (sys:%logldb *vf-short-offset* fixed-word))
		     (setq size (sys:%logldb *vf-short-size* fixed-word)))
		    (t
		     (let ((long-offset (sys:%logldb *vf-long-offset* fixed-word)))
		       (setq offset (1+ long-offset))
		       (setq size (read-record-word addressor long-offset)))))
	      (format stream "(~D. " size)
	      (loop for i from offset
		    repeat size do
		(format-binary-word (read-record-word addressor i) stream))
	      (write-string ")" stream))))))

;;; No, we gotta phony this up to look like a VAR record!
(defmethod unformat-data ((handler variable-format-handler) value table)
  (declare (ignore table))
  (if (null value)
      (values nil t)
      (using-resource (record fake-record)
	(let ((size (first value))
	      (start-i))
	  (cond ((< size *vf-max-short-size*)
		 (setf (read-record-word record 0)
		       (sys:%logdpb 1 *vf-short-offset* (sys:%logdpb size *vf-short-size* 0)))
		 (setq start-i 1))
		(t
		 (setf (read-record-word record 0)
		       (sys:%logdpb 0 *vf-long-offset* (sys:%logdpb 1 *vf-long-short-byte* 0)))
		 (setf (read-record-word record 1) size)
		 (setq start-i 2)))
	  (loop for i from start-i
		for w in (rest value) do
	    (setf (read-record-word record i) (unformat-binary-word w)))
	  (let ((raw (read-value handler record 0 nil)))
	    (if (eq raw *null-value*)
		(values nil t)
		(values raw nil)))))))

(defmethod format-data-internal ((handler fixed-dumper-mixin) addressor descriptor stream database)
  (declare (ignore database))
  (if (null addressor)
      (prin1 nil stream)
      (let* ((word-offset (desc-word-offset descriptor))
	     (bit-offset (desc-bit-offset descriptor))
	     (bits (fixed-space handler)))
	(format stream "(")
	(cond ((<= (+ bit-offset bits) 32)
	       (format-binary-word (sys:%logldb (byte bits bit-offset)
						(read-record-word addressor word-offset))
				   stream))
	      ((zerop bit-offset)
	       (loop for wo from word-offset 
		     for b from bits by -32 while (plusp b) do
		 (format-binary-word (read-record-word addressor wo) stream)))
	      (t
	       (loop with word = (read-record-word addressor word-offset)
		     for i from (1+ word-offset)
		     for b from bits by -32 do
		 (when (<= (+ bit-offset b) 32)
		   ;; The rest of the bits are all in this word.
		   (format-binary-word (sys:%logldb (byte b bit-offset)
						    (read-record-word addressor word-offset))
				       stream)
		   (return nil))
		 (let ((word2 (read-record-word addressor i)))
		   (format-binary-word
		     (sys:%logdpb
		       (sys:%logldb (byte bit-offset 0) word2)
		       (byte bit-offset (- 32 bit-offset))
		       (sys:%logldb (byte (- 32 bit-offset) bit-offset) word))
		     stream)
		   (setq word word2)))))
	(format stream ")"))))

(defmethod unformat-data ((handler fixed-format-handler) value table)
  (declare (ignore table))
  (if (null value)
      (values nil t)
      (using-resource (record fake-record)
	(loop for i from 0
	      for w in value do
	  (setf (read-record-word record i) (unformat-binary-word w)))
	(let ((raw (read-value handler record 0 nil)))
	  (if (eq raw *null-value*)
	      (values nil t)
	      (values raw nil))))))

(defmethod store-handler-info ((handler variable-format-handler) att)
  (setf (attribute-handler-kind att) *handler-kind-variable*))

;;; In long format, the length is stored in the first word of the
;;; variable portion.  The stored length does NOT include the first word
;;; itself.

(defmethod fixed-space ((handler variable-format-handler))
  (values 32 0))

(defmethod size-of-value ((handler variable-format-handler) value free database)
  (declare (ignore database))
  (let ((n-words (statice-type:size-of-value handler value)))
    (if (or (>= n-words *vf-max-short-size*)
	    (>= free *vf-max-short-offset*))
	(1+ n-words)
	n-words)))

(defmethod size-of-field ((handler variable-format-handler) addressor descriptor)
  (let ((fixed-word (read-record-word addressor descriptor)))
    (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word))
	(sys:%logldb *vf-short-size* fixed-word)
	(1+ (read-record-word addressor (sys:%logldb *vf-long-offset* fixed-word))))))

(defmethod start-of-field ((handler variable-format-handler) addressor descriptor)
  (let ((fixed-word (read-record-word addressor descriptor)))
    (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word))
	(sys:%logldb *vf-short-offset* fixed-word)
	(sys:%logldb *vf-long-offset* fixed-word))))

(defmethod read-value ((handler variable-format-handler) addressor descriptor database &rest keyargs)
  (declare (ignore database keyargs))
  (let ((fixed-word (read-record-word addressor descriptor)))
    (cond ((zerop fixed-word)
	   *null-value*)	  
	  ((zerop (sys:%logldb *vf-long-short-byte* fixed-word))
	   (statice-type:read-value handler
				    addressor
				    (sys:%logldb *vf-short-offset* fixed-word)
				    (sys:%logldb *vf-short-size* fixed-word)))
	  (t
	   (let ((long-offset (sys:%logldb *vf-long-offset* fixed-word)))
	     (statice-type:read-value handler
				      addressor
				      (1+ long-offset)
				      (read-record-word addressor long-offset)))))))

(defmethod write-value ((handler variable-format-handler) value addressor descriptor free database table size)
  (declare (ignore database table))
  (cond ((eq value *null-value*)
	 (setf (read-record-word addressor descriptor) 0))	 
	((and (< size *vf-max-short-size*)
	      (< free *vf-max-short-offset*))
	 (statice-type:write-value handler value addressor free size)
	 (setf (read-record-word addressor descriptor)
	       (sys:%logdpb free *vf-short-offset* (sys:%logdpb size *vf-short-size* 0)))
	 (+ free size))
	(t
	 (statice-type:write-value handler value addressor (1+ free) (1- size))
	 (setf (read-record-word addressor descriptor)
	       (sys:%logdpb free *vf-long-offset* (sys:%logdpb 1 *vf-long-short-byte* 0)))
	 (setf (read-record-word addressor free) (1- size))
	 (+ free size))))

(defmethod value-equal ((handler variable-format-handler) addressor descriptor value database)
  (declare (ignore database))
  (let ((fixed-word (read-record-word addressor descriptor)))
    (cond ((zerop fixed-word)
	   nil)
	  ((zerop (sys:%logldb *vf-long-short-byte* fixed-word))
	   (statice-type:value-equal handler
				     value
				     addressor
				     (sys:%logldb *vf-short-offset* fixed-word)
				     (sys:%logldb *vf-short-size* fixed-word)))
	  (t
	   (let ((long-offset (sys:%logldb *vf-long-offset* fixed-word)))
	     (statice-type:value-equal handler
				       value
				       addressor
				       (1+ long-offset)
				       (read-record-word addressor long-offset)))))))

(defmethod record-equal ((handler variable-format-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let ((fixed-word-1 (read-record-word addressor-1 descriptor-1))
	(fixed-word-2 (read-record-word addressor-2 descriptor-2)))
    (cond ((zerop fixed-word-1) nil)
	  ((zerop fixed-word-2) nil)
	  ((/= fixed-word-1 fixed-word-2) nil)
	  (t
	   (let ((length-1
		   (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-1))
		       (sys:%logldb *vf-short-size* fixed-word-1)
		       (read-record-word addressor-1
					 (sys:%logldb *vf-long-offset* fixed-word-1))))
		 (length-2
		   (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-2))
		       (sys:%logldb *vf-short-size* fixed-word-2)
		       (read-record-word addressor-2
					 (sys:%logldb *vf-long-offset* fixed-word-2))))
		 (start
		   (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-1))
		       (sys:%logldb *vf-short-offset* fixed-word-1)
		       (1+ (sys:%logldb *vf-long-offset* fixed-word-1)))))
	     (and (= length-1 length-2)
		  (loop for offset from start
			repeat length-1
			always (= (read-record-word addressor-1 offset)
				  (read-record-word addressor-2 offset)))))))))

(defmethod value-null-p ((handler variable-format-handler) addressor descriptor)
  (zerop (read-record-word addressor descriptor)))

(defmethod value-compare ((handler variable-format-handler) addressor descriptor value database &rest keyargs)
  (declare (ignore database keyargs))
  (let ((fixed-word (read-record-word addressor descriptor)))
    (cond ((zerop fixed-word)
	   *null-value*)
	  ((zerop (sys:%logldb *vf-long-short-byte* fixed-word))
	   (statice-type:value-compare handler
				       value
				       addressor
				       (sys:%logldb *vf-short-offset* fixed-word)
				       (sys:%logldb *vf-short-size* fixed-word)))
	  (t
	   (let ((long-offset (sys:%logldb *vf-long-offset* fixed-word)))
	     (statice-type:value-compare handler
					 value
					 addressor
					 (1+ long-offset)
					 (read-record-word addressor long-offset)))))))

(defmethod record-compare ((handler variable-format-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (let ((fixed-word-1 (read-record-word addressor-1 descriptor-1))
	(fixed-word-2 (read-record-word addressor-2 descriptor-2)))
    (cond ((zerop fixed-word-1)
	   (if (zerop fixed-word-2) :equal :greaterp))
	  ((zerop fixed-word-2) :lessp)
	  (t
	   (statice-type:record-compare
	     handler
	     addressor-1
	     (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-1))
		 (sys:%logldb *vf-short-offset* fixed-word-1)
		 (1+ (sys:%logldb *vf-long-offset* fixed-word-1)))
	     (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-1))
		 (sys:%logldb *vf-short-size* fixed-word-1)
		 (read-record-word addressor-1
				   (sys:%logldb *vf-long-offset* fixed-word-1)))
	     addressor-2 
	     (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-2))
		 (sys:%logldb *vf-short-offset* fixed-word-2)
		 (1+ (sys:%logldb *vf-long-offset* fixed-word-2)))
	     (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word-2))
		 (sys:%logldb *vf-short-size* fixed-word-2)
		 (read-record-word addressor-2
				   (sys:%logldb *vf-long-offset* fixed-word-2))))))))

(defmethod adjust-variable-words ((handler variable-format-handler) addressor descriptor added-n)
  (let ((fixed-word (read-record-word addressor descriptor)))
    (unless (zerop fixed-word)
      (if (zerop (sys:%logldb *vf-long-short-byte* fixed-word))
	  (incf (sys:%logldb *vf-short-offset* fixed-word) added-n)
	  (incf (sys:%logldb *vf-long-offset* fixed-word) added-n))
      (setf (read-record-word addressor descriptor) fixed-word))))

;;; store-handler-info is a distinct function so that it can be called
;;; not only from make-attribute but also from logical-format-handler's
;;; hook on underlying types.
(defmethod store-handler-info ((handler fixed-format-handler) att)
  (setf (attribute-handler-kind att) *handler-kind-fixed*)
  (multiple-value-bind (n-bits alignment)
      (fixed-space handler)
    (setf (attribute-handler-info att) (dpb n-bits (byte 8 8) alignment))))

(defmethod read-value ((handler fixed-format-handler) addressor descriptor database &rest keyargs)
  (declare (ignore database keyargs))
  (statice-type:read-value handler
			   addressor
			   (desc-word-offset descriptor)
			   (desc-bit-offset descriptor)))

(defmethod write-value ((handler fixed-format-handler) value addressor descriptor free database table size)
  (declare (ignore free database table size))
  (statice-type:write-value handler
			    value
			    addressor
			    (desc-word-offset descriptor)
			    (desc-bit-offset descriptor)))

(defmethod value-equal ((handler fixed-format-handler) addressor descriptor value database)
  (declare (ignore database))
  (statice-type:value-equal handler
			    value
			    addressor
			    (desc-word-offset descriptor)
			    (desc-bit-offset descriptor)))

(defmethod record-equal ((handler fixed-format-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (statice-type:record-equal handler
			     addressor-1
			     (desc-word-offset descriptor-1)
			     (desc-bit-offset descriptor-1)
			     addressor-2
			     (desc-word-offset descriptor-2)
			     (desc-bit-offset descriptor-2)))

(defmethod value-null-p ((handler fixed-format-handler) addressor descriptor)
  (statice-type:value-null-p handler
			     addressor
			     (desc-word-offset descriptor)
			     (desc-bit-offset descriptor)))

(defmethod value-compare ((handler fixed-format-handler) addressor descriptor value database &rest keyargs)
  (declare (ignore database keyargs))
  (statice-type:value-compare handler
			      value
			      addressor
			      (desc-word-offset descriptor)
			      (desc-bit-offset descriptor)))

(defmethod record-compare ((handler fixed-format-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (statice-type:record-compare handler
			       addressor-1
			       (desc-word-offset descriptor-1)
			       (desc-bit-offset descriptor-1)
			       addressor-2
			       (desc-word-offset descriptor-2)
			       (desc-bit-offset descriptor-2)))

(defclass logical-format-handler
	  (value-storage-handler)
    ((underlying-handler)))

(defmethod clos:initialize-instance :after ((handler logical-format-handler) &key based-on based-on-function &allow-other-keys)
  (with-slots (statice-type::presentation-type statice-type:no-nulls
	       statice-type::original-presentation-type underlying-handler) handler
    (cond (based-on-function
	   (setq based-on (funcall based-on-function statice-type::presentation-type))
	   (unless based-on
	     (error "The :based-on-function, ~S, returned NIL" based-on-function)))
	  ((null based-on)
	   (model-error "No :based-on presentation type provided for logical type ~S"
			statice-type::original-presentation-type)))
    (unless (dw::ptypep based-on 'dw:presentation-type)
      (model-error
	"The :based-on parameter for type ~S was ~S, which is not a presentation type"
	statice-type::original-presentation-type based-on))
    (setf underlying-handler (get-storage-handler based-on statice-type:no-nulls))))

(defmethod store-handler-info ((handler logical-format-handler) att)
  (with-slots (underlying-handler) handler
    (store-handler-info underlying-handler att)))

;;; The default methods do an identity transformation.  This is useful
;;; for types that are just restricted subsets of existing types.
(defmethod statice-type:encode-value ((handler logical-format-handler) value)
  value)

(defmethod statice-type:decode-value ((handler logical-format-handler) value)
  value)

(defsubst encode-value (handler value)
  (if (eq value *null-value*)
      *null-value*
      (statice-type:encode-value handler value)))

(defsubst decode-value (handler value)
  (if (eq value *null-value*)
      *null-value*
      (statice-type:decode-value handler value)))

(defmethod fixed-space ((handler logical-format-handler))
  (with-slots (underlying-handler) handler
    (fixed-space underlying-handler)))

(defmethod size-of-value ((handler logical-format-handler) value free database)
  (with-slots (underlying-handler) handler
    (size-of-value underlying-handler (encode-value handler value) free database)))

(defmethod size-of-field ((handler logical-format-handler) addressor descriptor)
  (with-slots (underlying-handler) handler
    (size-of-field underlying-handler addressor descriptor)))

(defmethod start-of-field ((handler logical-format-handler) addressor descriptor)
  (with-slots (underlying-handler) handler
    (start-of-field underlying-handler addressor descriptor)))

(defmethod read-value ((handler logical-format-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (with-slots (underlying-handler) handler
    (decode-value
      handler
      (read-value underlying-handler addressor descriptor database
		  :into-string into-string
		  :stack-cons-if-appropriate stack-cons-if-appropriate))))

(defmethod write-value ((handler logical-format-handler) value addressor descriptor
			free database transition-table size)
  (with-slots (underlying-handler) handler
    (write-value underlying-handler (encode-value handler value) addressor descriptor
		 free database transition-table size)))

(defmethod value-equal ((handler logical-format-handler) addressor
			descriptor value database)
  (with-slots (underlying-handler) handler
    (value-equal underlying-handler
		 addressor
		 descriptor
		 (encode-value handler value)
		 database)))

(defmethod record-equal ((handler logical-format-handler) addressor-1 addressor-2
			 descriptor-1 descriptor-2)
  (with-slots (underlying-handler) handler
    (record-equal underlying-handler addressor-1 addressor-2 descriptor-1 descriptor-2)))

(defmethod value-null-p ((handler logical-format-handler) addressor descriptor)
  (with-slots (underlying-handler) handler
    (value-null-p underlying-handler addressor descriptor)))

(defmethod comparable-p ((handler logical-format-handler))
  (with-slots (underlying-handler) handler
    (comparable-p underlying-handler)))

(defmethod value-compare ((handler logical-format-handler) addressor descriptor
			  value database &key case-sensitive)
  (with-slots (underlying-handler) handler
    (value-compare underlying-handler
		   addressor
		   descriptor
		   (encode-value handler value)
		   database
		   :case-sensitive case-sensitive)))

(defmethod record-compare ((handler logical-format-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (with-slots (underlying-handler) handler
    (record-compare underlying-handler
		    addressor-1 addressor-2 descriptor-1 descriptor-2 database-1 database-2)))

(defmethod adjust-variable-words ((handler logical-format-handler) addressor descriptor added-n-fixed-words)
  (with-slots (underlying-handler) handler
    (adjust-variable-words underlying-handler addressor descriptor added-n-fixed-words)))

;;; We must format values of logical types the same way regardless of
;;; whether the logical type is known or unknown, so that the model
;;; dumper uses a consistent representation in all cases.  So we always
;;; dump the underlying value using its own formatter.
(defmethod format-data-internal ((handler logical-format-handler) addressor descriptor stream database)
  (with-slots (underlying-handler) handler
    (format-data-internal underlying-handler addressor descriptor stream database)))

(defmethod unformat-data ((handler logical-format-handler) thing entity-handle-table)
  (with-slots (underlying-handler) handler
    (multiple-value-bind (value value-null-p)
	(unformat-data underlying-handler thing entity-handle-table)
      (if value-null-p
	  (values value value-null-p)
	  (values (decode-value handler value))))))

(define-builtin-type-with-finder boolean 9 boolean-handler-finder)

(defun boolean-handler-finder (presentation-type no-nulls)
  (declare (ignore presentation-type))
  (if no-nulls 'one-bit-boolean 'two-bit-boolean))

(define-storage-handler one-bit-boolean 9 () (boolean-handler-mixin))

(defmethod fixed-space ((handler one-bit-boolean))
  (values 1 1))

(defmethod read-value ((handler one-bit-boolean) addressor descriptor database &rest keyargs)
  (declare (ignore database keyargs))
  (= 1 (sys:%logldb (byte 1 (desc-bit-offset descriptor))
		    (read-record-word addressor (desc-word-offset descriptor)))))

(defmethod write-value ((handler one-bit-boolean) value addressor descriptor free database table size)
  (declare (ignore database table size))
  (setf (sys:%logldb (byte 1 (desc-bit-offset descriptor))
		     (read-record-word addressor (desc-word-offset descriptor)))
	(if value 1 0))
  free)

(defmethod value-equal ((handler one-bit-boolean) addressor descriptor value database)
  (declare (ignore database))
  (= (sys:%logldb (byte 1 (desc-bit-offset descriptor))
		  (read-record-word addressor (desc-word-offset descriptor)))
     (if value 1 0)))

(defmethod record-equal ((handler one-bit-boolean) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (= (sys:%logldb (byte 1 (desc-bit-offset descriptor-1))
		  (read-record-word addressor-1 (desc-word-offset descriptor-1)))
     (sys:%logldb (byte 1 (desc-bit-offset descriptor-2))
		  (read-record-word addressor-2 (desc-word-offset descriptor-2)))))

(defmethod value-null-p ((handler one-bit-boolean) addressor descriptor)
  (declare (ignore addressor descriptor))
  nil)

(define-storage-handler two-bit-boolean 12 () (boolean-handler-mixin))

;;; 0 = false   1 = true   2 = null
(defmethod fixed-space ((handler two-bit-boolean))
  (values 2 1))

(defmethod read-value ((handler two-bit-boolean) addressor descriptor database &rest keyargs)
  (declare (ignore database keyargs))
  (let ((code (sys:%logldb (byte 2 (desc-bit-offset descriptor))
			   (read-record-word addressor (desc-word-offset descriptor)))))
    (if (= code 2) *null-value* (= 1 code))))

(defmethod write-value ((handler two-bit-boolean) value addressor descriptor free database table size)
  (declare (ignore database table size))
  (setf (sys:%logldb (byte 2 (desc-bit-offset descriptor))
		     (read-record-word addressor (desc-word-offset descriptor)))
	(cond ((eq value *null-value*) 2)
	      (value 1)
	      (t 0)))
  free)

(defmethod value-equal ((handler two-bit-boolean) addressor descriptor value database)
  (declare (ignore database))
  (let ((code (sys:%logldb (byte 2 (desc-bit-offset descriptor))
			   (read-record-word addressor (desc-word-offset descriptor)))))
    (unless (= code 2)
      (= code (if value 1 0)))))

(defmethod record-equal ((handler two-bit-boolean) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let ((code-1 (sys:%logldb (byte 2 (desc-bit-offset descriptor-1))
			     (read-record-word addressor-1 (desc-word-offset descriptor-1))))
	(code-2 (sys:%logldb (byte 2 (desc-bit-offset descriptor-2))
			     (read-record-word addressor-2 (desc-word-offset descriptor-2)))))
    (unless (or (= code-1 2) (= code-2 2))
      (= code-1 code-2))))

(defmethod value-null-p ((handler two-bit-boolean) addressor descriptor)
  (= 2 (sys:%logldb (byte 2 (desc-bit-offset descriptor))
		    (read-record-word addressor (desc-word-offset descriptor)))))

;;; Objects of this type are Lisp thin strings with no more than limit
;;; characters and that don't use character code 128 or
;;; character code #377 (integeral sign).  The data argument must be a
;;; positive integer.  (limit is inclusive, not exclusive!)
(dw:define-presentation-type limited-string ((limit))
   :expander 'string
   :typep ((object)
	   (and (typep object '(vector string-char))
		(<= (length object) limit)))
   :describer ((stream &key type)
	       (let ((limit (cadar type)))
		 (format stream "a limited string (~D character maximum)" limit))))

(define-builtin-type limited-string 13 13 (len))

(defmethod clos:initialize-instance :after ((handler limited-string-handler) &key &allow-other-keys)
  (declare (ignore initargs))
  (with-slots (len statice-type:presentation-type
	       statice-type:original-presentation-type) handler
    (dw:with-type-decoded (nil data-args) statice-type:presentation-type
       (unless (and (= (length data-args) 1)
		    (integerp (first data-args))
		    (plusp (first data-args)))
	 (error "~S is not a valid presentation type" statice-type:original-presentation-type))
       (setq len (first data-args)))))

(defmethod statice-typep ((handler limited-string-handler) object)
  (with-slots (len) handler
    (and (typep object '(vector cl:string-char))
	 (<= (length object) len))))

(defmethod check-spec ((handler limited-string-handler) spec)
  (check-spec-standard 'string *string-operators*))

(defmethod check-operator ((handler limited-string-handler) operator)
  (member operator *string-operators*))

(defmethod fixed-space ((handler limited-string-handler))
  (with-slots (len) handler
    (values (* 8 len) 8)))

(defmethod read-value ((handler limited-string-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (declare (ignore database))
  (with-slots (len) handler
    (let* ((word-offset (desc-word-offset descriptor))
	   (bit-offset (desc-bit-offset descriptor))
	   (word (read-record-word addressor word-offset))
	   (code (sys:%logldb (byte 8 bit-offset) word)))
      (cond ((= code 255) *null-value*)
	    ((= code 128) "")
	    (t
	     (let ((string (cond (into-string)
				 (stack-cons-if-appropriate
				  (sys:make-stack-array len :element-type 'character))
				 (t (make-string len)))))
	       (loop for string-offset from 0 below len do
		 (setf (aref string string-offset) (code-char code))
		     until (= string-offset (1- len)) do
		 (incf bit-offset 8)
		 (when (= bit-offset 32)
		   (setq bit-offset 0)
		   (incf word-offset)
		   (setq word (read-record-word addressor word-offset)))
		 (setq code (sys:%logldb (byte 8 bit-offset) word))
		     until (= code 128)
		     finally
		       (unless into-string
			 (adjust-array string (min len (1+ string-offset)))))
	       string))))))

;;; Return "free", which is just what we were passed.
(defmethod write-value ((handler limited-string-handler) string addressor descriptor
			free database table size)
  (declare (ignore database table size))
  (with-slots (len) handler
    (let ((word-offset (desc-word-offset descriptor))
	  (bit-offset (desc-bit-offset descriptor)))
      (if (eq string *null-value*)
	  (setf (sys:%logldb (byte 8 bit-offset) (read-record-word addressor word-offset))
		255)
	  (loop with word = (read-record-word addressor word-offset)
		with slen = (string-length string)
		for i below (min len (1+ slen)) do
	    (when (= bit-offset 32)
	      (setf (read-record-word addressor word-offset) word)
	      (setq bit-offset 0)
	      (incf word-offset)
	      (setq word (if (> (- slen i) 4) 0 (read-record-word addressor word-offset))))
	    ;; Write the character's code, or zero if we're written the whole string.
	    (setf (sys:%logldb (byte 8 bit-offset) word)
		  (if (= i slen) 128 (char-code (aref string i))))
	    (incf bit-offset 8)
		finally
		  (setf (read-record-word addressor word-offset) word))))
    free))

(defmethod value-equal ((handler limited-string-handler) addressor descriptor string database)
  (declare (ignore database))
  (with-slots (len) handler
    (let* ((word-offset (desc-word-offset descriptor))
	   (bit-offset (desc-bit-offset descriptor))
	   (word (read-record-word addressor word-offset))
	   (code (sys:%logldb (byte 8 bit-offset) word))
	   (string-length (string-length string)))
      (unless (= code 255)
	(or (and (= code 128) (= string-length 0))
	    (loop for string-offset from 0 below (min len string-length) do
	      (unless (= (char-code (aref string string-offset)) code)
		(return nil))
		  until (= string-offset (1- len)) do
	      (incf bit-offset 8)
	      (when (= bit-offset 32)
		(setq bit-offset 0)
		(incf word-offset)
		(setq word (read-record-word addressor word-offset)))
	      (setq code (sys:%logldb (byte 8 bit-offset) word))
		  until (= code 128)
		  finally (return (= string-length (min len (1+ string-offset))))))))))

(defmethod record-equal ((handler limited-string-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (with-slots (len) handler
    (let* ((word-offset-1 (desc-word-offset descriptor-1))
	   (bit-offset-1 (desc-bit-offset descriptor-1))
	   (word-1 (read-record-word addressor-1 word-offset-1))
	   (code-1 (sys:%logldb (byte 8 bit-offset-1) word-1)))
      (unless (= code-1 255)
	(let* ((word-offset-2 (desc-word-offset descriptor-2))
	       (bit-offset-2 (desc-bit-offset descriptor-2))
	       (word-2 (read-record-word addressor-2 word-offset-2))
	       (code-2 (sys:%logldb (byte 8 bit-offset-2) word-2)))
	  (unless (= code-2 255)
	    (loop repeat len do
	      (unless (= code-1 code-2)
		(return nil))
	      (when (= code-1 128)
		(return t))
	      (incf bit-offset-1 8)
	      (when (= bit-offset-1 32)
		(setq bit-offset-1 0)
		(incf word-offset-1)
		(setq word-1 (read-record-word addressor-1 word-offset-1)))
	      (setq code-1 (sys:%logldb (byte 8 bit-offset-1) word-1))
	      (incf bit-offset-2 8)
	      (when (= bit-offset-2 32)
		(setq bit-offset-2 0)
		(incf word-offset-2)
		(setq word-2 (read-record-word addressor-2 word-offset-2)))
	      (setq code-2 (sys:%logldb (byte 8 bit-offset-2) word-2))
		  finally (return t))))))))

(defmethod value-null-p ((handler limited-string-handler) addressor descriptor)
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 8 bit-offset) word)))
    (= code 255)))

(defmethod case-insensitive-type-p ((handler limited-string-handler)) nil)

(defmethod comparable-p ((handler limited-string-handler)) t)

(defmethod value-compare ((handler limited-string-handler) addressor descriptor string database &key case-sensitive)
  (declare (ignore database))
  (with-slots (len) handler
    (let* ((word-offset (desc-word-offset descriptor))
	   (bit-offset (desc-bit-offset descriptor))
	   (word (read-record-word addressor word-offset))
	   (code (sys:%logldb (byte 8 bit-offset) word))
	   (slen (string-length string)))
      (cond ((= code 255) *null-value*)
	    ((eq string *null-value*) :lessp)
	    ((zerop slen) :greaterp)
	    (t
	     (loop with char<-function = (if case-sensitive #'char< #'char-lessp)
		   with char>-function = (if case-sensitive #'char> #'char-greaterp)
		   as record-char = (code-char code)
		   with string-offset = 0 do
	       ;; We have at least one character in the record and one in the string.
	       (let ((string-char (aref string string-offset)))
		 (cond ((funcall char<-function record-char string-char) (return :lessp))
		       ((funcall char>-function record-char string-char) (return :greaterp))))
	       (incf string-offset)
	       (cond ((= string-offset len)
		      (setq code 128))
		     (t
		      (incf bit-offset 8)
		      (when (= bit-offset 32)
			(setq bit-offset 0)
			(incf word-offset)
			(setq word (read-record-word addressor word-offset)))
		      (setq code (sys:%logldb (byte 8 bit-offset) word))))
	       (cond ((= code 128)
		      (return (if (= string-offset slen) :equal :lessp)))
		     ((= string-offset slen) (return :greaterp)))))))))

(defmethod record-compare ((handler limited-string-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (with-slots (len) handler
    (let* ((word-offset-1 (desc-word-offset descriptor-1))
	   (bit-offset-1 (desc-bit-offset descriptor-1))
	   (word-1 (read-record-word addressor-1 word-offset-1))
	   (code-1 (sys:%logldb (byte 8 bit-offset-1) word-1))
	   (word-offset-2 (desc-word-offset descriptor-2))
	   (bit-offset-2 (desc-bit-offset descriptor-2))
	   (word-2 (read-record-word addressor-2 word-offset-2))
	   (code-2 (sys:%logldb (byte 8 bit-offset-2) word-2)))
      (cond ((= code-1 255)
	     (if (= code-2 255) :equal :greaterp))
	    ((= code-2 255) :lessp)
	    (t
	     (loop repeat len do
	       (let ((char-1 (code-char code-1))
		     (char-2 (code-char code-2)))
		 (cond ((char< char-1 char-2) (return :lessp))
		       ((char> char-1 char-2) (return :greaterp))))
	       (incf bit-offset-1 8)
	       (when (= bit-offset-1 32)
		 (setq bit-offset-1 0)
		 (incf word-offset-1)
		 (setq word-1 (read-record-word addressor-1 word-offset-1)))
	       (setq code-1 (sys:%logldb (byte 8 bit-offset-1) word-1))
	       (incf bit-offset-2 8)
	       (when (= bit-offset-2 32)
		 (setq bit-offset-2 0)
		 (incf word-offset-2)
		 (setq word-2 (read-record-word addressor-2 word-offset-2)))
	       (setq code-2 (sys:%logldb (byte 8 bit-offset-2) word-2))
	       (cond ((= code-1 128)
		      (return (if (= code-2 128) :equal :lessp)))
		     ((= code-2 128)
		      (return :greaterp)))
		   finally (return :equal)))))))

(define-builtin-type-with-finder vector 14 vector-handler-finder)

;;; (vector fixnum) and (vector (unsigned-byte 32)) use vector-fixnum-handler.
;;; (vector (unsigned-byte anything-but-32)) uses vector-unsigned-handler.
;;; No other cases are supported.  The size data argument is ignored.
(defun vector-handler-finder (presentation-type no-nulls)
  (declare (cl:ignore no-nulls))
  (dw:with-type-decoded (nil data-args) presentation-type
     (let ((vector-type (first data-args)))
       (cond ((null data-args) (cl:error "~S is not a valid statice type" presentation-type))
	     ((or (eq vector-type 'fixnum)
		  (equal vector-type '(unsigned-byte 32)))
	      'vector-fixnum-handler)
	     ((and (listp vector-type) (= (length vector-type) 2))
	      (case (first vector-type)		;in case we ever allow signed-byte
		(unsigned-byte 'vector-unsigned-handler)
		(t (cl:error "The vector type must be unsigned-byte"))))
	     ((listp vector-type)
	      (if (> (length vector-type) 2)
		  (cl:error "Only the element-type data argument is supported for vector")
		  (cl:error "You must supply a byte size")))
	     (t (cl:error "Illegal vector type ~S" vector-type))))))

;;; This mixin is shared between vector-fixnum-handler and
;;; vector-unsigned-handler, for behavior that is common to all
;;; unsigned-byte vectors.
(defclass vector-handler-mixin () ())

;;; A vector of fixnums is just a block of words in the record.  The
;;; fixed portion is two words: the first word is the size, and the
;;; second the pointer to the variable part of the record.  If the
;;; pointer is zero, then the value is null.
(define-storage-handler vector-fixnum-handler 14 nil (vector-handler-mixin))

(defmethod statice-typep ((handler vector-fixnum-handler) vector)
  (with-slots (statice-type:original-presentation-type) handler
    (and (typep vector statice-type:original-presentation-type)
	 (dw::ptypep vector statice-type:original-presentation-type))))

(defmethod check-spec ((handler vector-handler-mixin) spec)
  (eq (first spec) 'null))

(defmethod check-operator ((handler vector-handler-mixin) operator)
  (declare (ignore operator))
  nil)

(defmethod fixed-space ((handler vector-fixnum-handler))
  (values 64 0))

(defmethod size-of-value ((handler vector-fixnum-handler) vector free database)
  (declare (ignore free database))
  (length vector))

(defmethod size-of-field ((handler vector-handler-mixin) addressor descriptor)
  (read-record-word addressor descriptor))

(defmethod start-of-field ((handler vector-handler-mixin) addressor descriptor)
  (read-record-word addressor (1+ descriptor)))

(defparameter *read-value-vector-buffer-size* 283 "For yucks")

(defmethod read-value ((handler vector-fixnum-handler) addressor descriptor database
		       &key stack-cons-if-appropriate into-string)
  (declare (ignore database))
  (let ((data-size (read-record-word addressor descriptor))
	(data-start (read-record-word addressor (1+ descriptor))))
    (if (zerop data-start)
	*null-value*
	(let ((into-array (or into-string
			      (if stack-cons-if-appropriate
				  (sys:make-stack-array data-size :element-type 'fixnum)
				  (make-array data-size :element-type 'fixnum)))))
	  (read-multiple-record-word addressor data-start (+ data-start data-size)
				     :into into-array)))))

(defmethod read-value-portion ((handler vector-fixnum-handler) addressor descriptor database
			       &key start end into into-start)
  (declare (ignore database))
  (let ((data-size (read-record-word addressor descriptor))
	(data-start (read-record-word addressor (1+ descriptor))))
    (if (zerop data-start)
	*null-value*
	(let* ((n-words (- end start)))
	  (unless end (setq end (- data-size start)))
	  (let* ((read-start (+ data-start start))
		 (read-end (+ read-start n-words)))
	    (when (or (minusp n-words) (minusp end) (minusp start))
	      (error "Bad parameters"))
	    (when (> n-words data-size)
	      (error "Trying to read more than there is"))
	    (unless (zerop n-words)
	      (read-multiple-record-word addressor read-start read-end
					 :into into :into-start into-start))
	    into)))))

(defmethod set-value-portion ((handler vector-fixnum-handler) addressor descriptor database
			      &key start end from from-start)
  (declare (ignore database))
  (let ((data-size (read-record-word addressor descriptor))
	(data-start (read-record-word addressor (1+ descriptor)))
	(n-words (- end start)))
    (unless end (setq end (- data-size start)))
    (let* ((write-start (+ data-start start))
	   (write-end (+ write-start n-words)))
      (when (or (minusp n-words) (minusp end) (minusp start))
	(error "Bad parameters"))
      (when (> n-words data-size)
	(error "Trying to set more than there is"))
      (unless (zerop n-words)
	(sys:with-stack-array (offset-array n-words
					    :element-type 'fixnum
					    :displaced-to from
					    :displaced-index-offset from-start)
	  (write-multiple-record-word addressor write-start write-end offset-array))))))

(defmethod write-value ((handler vector-fixnum-handler) vector addressor descriptor
			free database table size)
  (declare (ignore database table))
  (cond ((eq vector *null-value*)
	 (setf (read-record-word addressor descriptor) 0
	       (read-record-word addressor (1+ descriptor)) 0)
	 free)
	(t
	 (setf (read-record-word addressor descriptor) size
	       (read-record-word addressor (1+ descriptor)) free)
	 (let ((end (+ free size)))
	   (write-multiple-record-word addressor free end vector)
	   (+ free size)))))

(defmethod value-equal ((handler vector-handler-mixin) addressor descriptor value database)
  (declare (ignore addressor descriptor value database))
  nil)

(defmethod record-equal ((handler vector-handler-mixin) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (declare (ignore addressor-1 addressor-2 descriptor-1 descriptor-2))
  nil)

(defmethod value-null-p ((handler vector-handler-mixin) addressor descriptor)
  (zerop (read-record-word addressor (1+ descriptor))))

(defmethod comparable-p ((handler vector-handler-mixin)))

(defmethod adjust-variable-words ((handler vector-handler-mixin) addressor descriptor added-n)
  (incf (read-record-word addressor (1+ descriptor)) added-n))

(defmethod array-type-p ((handler vector-handler-mixin)) t)

(defmethod indexable-p ((handler vector-handler-mixin)) nil)

(defmethod length-of-array ((handler vector-fixnum-handler) addressor descriptor)
  (read-record-word addressor descriptor))

(defmethod format-value-internal ((handler vector-fixnum-handler) value value-not-null-p stream)
  (prin1 (when value-not-null-p
	   (cons (length value) (zl:listarray value)))
	 stream))

(defmethod unformat-data ((handler vector-fixnum-handler) value table)
  (declare (ignore table))
  (if value
      (make-array (car value) :element-type 'fixnum :initial-contents (cdr value))
      (values nil t)))

;;; This storage handler is for vectors of unsigned-bytes where the byte
;;; size is not 32.  The first fixed word holds the size-of-field, and
;;; the second fixed word holds the start-of-field.  The
;;; *byte-vector-odd-bytes* field of the third fixed word says how many
;;; extra bytes there are in the last variable word, or zero if the last
;;; variable word is full of useful bytes.  The rest of the third
;;; word is reserved for future expansion, perhaps multi-d arrays.
(define-storage-handler vector-unsigned-handler 15 (byte-size bytes-per-word)
			(vector-handler-mixin))

(defconstant *byte-vector-odd-bytes* (byte 5 0))

(defmethod clos:initialize-instance :after ((handler vector-unsigned-handler) &key &allow-other-keys)
  (with-slots (statice-type:presentation-type statice-type:original-presentation-type
	       byte-size bytes-per-word) handler
    (dw:with-type-decoded (nil data-args) statice-type:presentation-type
       (let ((n-bits (second (first data-args))))
	 (unless (and (= (length data-args) 1)
		      (integerp n-bits)
		      (plusp n-bits))
	   (error "~S is not a valid presentation type"
		  statice-type:original-presentation-type))
	 (unless (= n-bits (scl:lsh 1 (1- (zl:haulong n-bits))))
	   (error "~S is not a valid presentation type because ~S is not a power of 2"
		  statice-type:original-presentation-type n-bits))
	 (when (> n-bits 32)
	   (error "~S is not a valid presentation type because ~S is greater than 32"
		  statice-type:original-presentation-type n-bits))
	 (setq byte-size n-bits bytes-per-word (/ 32 n-bits))))))

(defmethod statice-typep ((handler vector-unsigned-handler) vector)
  (with-slots (statice-type:original-presentation-type) handler
    (and (typep vector statice-type:original-presentation-type)
	 (dw::ptypep vector statice-type:original-presentation-type))))

(defmethod fixed-space ((handler vector-unsigned-handler))
  (values 96 0))

(defmethod size-of-value ((handler vector-unsigned-handler) vector free database)
  (declare (ignore free database))
  (with-slots (bytes-per-word) handler
    (ceiling (length vector) bytes-per-word)))

(defmethod read-value ((handler vector-unsigned-handler) addressor descriptor database
		       &key stack-cons-if-appropriate into-string)
  (declare (ignore database))
  (with-slots (bytes-per-word byte-size statice-type:presentation-type) handler
    (let* ((data-size (read-record-word addressor descriptor))
	   (data-start (read-record-word addressor (1+ descriptor)))
	   (odd-bytes (sys:%logldb *byte-vector-odd-bytes*
				   (read-record-word addressor (+ 2 descriptor))))
	   (n-bytes (+ odd-bytes (* (- data-size (if (zerop odd-bytes) 0 1)) bytes-per-word))))
      (if (zerop data-start)
	  *null-value*
	  (let* ((odd-bytes (mod n-bytes bytes-per-word))
		 (whole-words (floor n-bytes bytes-per-word))
		 (into-array (or into-string
				 (let ((type (dw:with-type-decoded (typnam data-args)
						   statice-type:presentation-type
						(declare (ignore typnam))
						(first data-args))))
				   (if stack-cons-if-appropriate
				       (sys:make-stack-array n-bytes :element-type type)
				       (make-array n-bytes :element-type type))))))
	    (unless (< n-bytes bytes-per-word)
	      (sys:with-stack-array (indirect-array data-size
						    :element-type 'fixnum
						    :displaced-to into-array)
		(read-multiple-record-word addressor data-start (+ data-start whole-words)
					   :into indirect-array)))
	    (unless (zerop odd-bytes)
	      (loop with last-word = (read-record-word addressor (+ data-start whole-words))
		    for byte from 0
		    for i from (* whole-words bytes-per-word) repeat odd-bytes do
		(setf (aref into-array i)
		      (sys:%logldb (byte byte-size (* byte byte-size)) last-word))))
	    into-array)))))

;;; The caller is mostly responsible for doing the parameter checking.
(defmethod read-value-portion ((handler vector-unsigned-handler) addressor descriptor database
			       &key start end into into-start)
  (declare (ignore database))
  (with-slots (bytes-per-word byte-size) handler
    (let* ((data-size (read-record-word addressor descriptor))
	   (data-start (read-record-word addressor (1+ descriptor)))
	   (odd-bytes (sys:%logldb *byte-vector-odd-bytes*
				   (read-record-word addressor (+ 2 descriptor))))
	   (n-bytes (+ odd-bytes (* (- data-size (if (zerop odd-bytes) 0 1)) bytes-per-word)))
	   (into into)
	   (into-index into-start))
      (declare (sys:array-register into))
      (unless (and (<= start end) (<= start n-bytes) (<= end n-bytes))
	(model-error "You requested more data than there is.  There are only ~A bytes available"
		     n-bytes))
      (if (zerop data-start)
	  *null-value*
	  (multiple-value-bind (start-read-word start-read-byte)
	      (floor start bytes-per-word)
	    (multiple-value-bind (end-read-word end-read-byte)
		(floor end bytes-per-word)
	      (incf start-read-word data-start)
	      (incf end-read-word data-start)
	      (let* ((bytes-to-copy (- end start))
		     (first-is-whole (and (zerop start-read-byte)
					  (< bytes-per-word bytes-to-copy)))
		     (last-is-whole (zerop end-read-byte))
		     (whole-words 
		       (max 0
			    (floor (- bytes-to-copy
				      (if first-is-whole 0 (- bytes-per-word start-read-byte))
				      (if last-is-whole 0 end-read-byte))
				   bytes-per-word)))
		     (into-end (+ into-start bytes-to-copy)))
		(unless first-is-whole
		  (loop with first-word = (read-record-word addressor start-read-word)
			for byte-num from start-read-byte below bytes-per-word
			while (< into-index into-end) do
		    (setf (aref into into-index)
			  (sys:%logldb (byte byte-size (* byte-size byte-num)) first-word))
		    (incf into-index))
		  (incf start-read-word))
		(unless (zerop whole-words)
		  (cond ((zerop (mod into-index bytes-per-word))
			 ;; into-start is on a whole word boundary  Use it.
			 (sys:with-stack-array (indirect-array
						 whole-words
						 :element-type 'fixnum
						 :displaced-to into
						 :displaced-index-offset
						 (floor into-index bytes-per-word))
			   (read-multiple-record-word addressor
						      start-read-word
						      (+ start-read-word whole-words)
						      :into indirect-array)
			   (incf into-index (* whole-words bytes-per-word))))
			(t
			 ;; gotta do it the slow way
			 (sys:with-data-stack
			   (let ((words (read-multiple-record-word
					  addressor start-read-word
					  (+ start-read-word whole-words))))
			     (declare (sys:array-register words))
			     (loop for from-index from 0 repeat whole-words do
			       (let ((word (aref words from-index)))
				 (loop for byte-num from 0 below bytes-per-word do
				   (setf (aref into into-index)
					 (sys:%logldb (byte byte-size (* byte-num byte-size))
						      word))
				   (incf into-index)))))))))
		(unless last-is-whole
		  (when (< into-index into-end)
		    (loop with last-word = (read-record-word addressor end-read-word)
			  for byte-num from 0 below end-read-byte do
		      (setf (aref into into-index)
			    (sys:%logldb (byte byte-size (* byte-size byte-num)) last-word))
		      (incf into-index)))))))))))

;;; The caller is mostly responsible for doing the parameter checking.
;;; YOW! Massive code duplication here.
(defmethod set-value-portion ((handler vector-unsigned-handler) addressor descriptor database
			      &key start end from from-start)
  (declare (ignore database))
  (with-slots (bytes-per-word byte-size) handler
    (let* ((data-size (read-record-word addressor descriptor))
	   (data-start (read-record-word addressor (1+ descriptor)))
	   (odd-bytes (sys:%logldb *byte-vector-odd-bytes*
				   (read-record-word addressor (+ 2 descriptor))))
	   (n-bytes (+ odd-bytes (* (- data-size (if (zerop odd-bytes) 0 1)) bytes-per-word)))
	   (from from)
	   (from-index from-start))
      (declare (sys:array-register from))
      (unless (and (<= start end) (<= start n-bytes) (<= end n-bytes))
	(model-error "You are trying to set more data than there is.~@
                    There are only ~A bytes available"
		     n-bytes))
      (multiple-value-bind (start-write-word start-write-byte)
	  (floor start bytes-per-word)
	(multiple-value-bind (end-write-word end-write-byte)
	    (floor end bytes-per-word)
	  (incf start-write-word data-start)
	  (incf end-write-word data-start)
	  (let* ((bytes-to-copy (- end start))
		 (first-is-whole (and (zerop start-write-byte)
				      (< bytes-per-word bytes-to-copy)))
		 (last-is-whole (zerop end-write-byte))
		 (whole-words 
		   (max 0
			(floor (- bytes-to-copy
				  (if first-is-whole 0 (- bytes-per-word start-write-byte))
				  (if last-is-whole 0 end-write-byte))
			       bytes-per-word)))
		 (from-end (+ from-start bytes-to-copy)))
	    (unless (zerop bytes-to-copy)
	      (unless first-is-whole
		(loop with first-word = (read-record-word addressor start-write-word)
		      for byte-num from start-write-byte below bytes-per-word
		      while (< from-index from-end) do
		  (setf (sys:%logldb (byte byte-size (* byte-size byte-num)) first-word)
			(aref from from-index))
		  (incf from-index)
		      finally
			(setf (read-record-word addressor start-write-word) first-word))
		(incf start-write-word))
	      (unless (zerop whole-words)
		(cond ((zerop (mod from-index bytes-per-word))
		       ;; into-start is on a whole word boundary  Use it.
		       (sys:with-stack-array (indirect-array whole-words
							     :element-type 'fixnum
							     :displaced-to from
							     :displaced-index-offset
							     (floor from-index bytes-per-word))
			 (write-multiple-record-word addressor
						     start-write-word
						     (+ start-write-word whole-words)
						     indirect-array)
			 (incf from-index (* whole-words bytes-per-word))))
		      (t
		       ;; gotta do it the slow way
		       (sys:with-data-stack
			 (let* ((end-write-word (+ start-write-word whole-words))
				(words (read-multiple-record-word
					 addressor start-write-word end-write-word)))
			   (declare (sys:array-register words))
			   (loop for word-index from 0 repeat whole-words do
			     (let ((word (aref words word-index)))
			       (loop for byte-num from 0 below bytes-per-word do
				 (setf (sys:%logldb (byte byte-size (* byte-num byte-size))
						    word)
				       (aref from from-index))
				 (incf from-index))
			       (setf (aref words word-index) word)))
			   (write-multiple-record-word
			     addressor start-write-word end-write-word words))))))
	      (unless last-is-whole
		(when (< from-index from-end)
		  (loop with last-word = (read-record-word addressor end-write-word)
			for byte-num from 0 below end-write-byte do
		    (setf (sys:%logldb (byte byte-size (* byte-size byte-num)) last-word)
			  (aref from from-index))
		    (incf from-index)
			finally
			  (write-record-word addressor end-write-word last-word)))))))))))

(defmethod length-of-array ((handler vector-unsigned-handler) addressor descriptor)
  (with-slots (bytes-per-word) handler
    (let* ((data-size (read-record-word addressor descriptor))
	   (odd-bytes (sys:%logldb *byte-vector-odd-bytes*
				   (read-record-word addressor (+ 2 descriptor)))))
      (if (zerop odd-bytes)
	  (* data-size bytes-per-word)
	  (+ odd-bytes (* (1- data-size) bytes-per-word))))))

(defmethod write-value ((handler vector-unsigned-handler) vector addressor descriptor free database table size)
  (declare (ignore database table))
  (with-slots (bytes-per-word byte-size) handler
    (cond ((eq vector *null-value*)
	   (setf (read-record-word addressor descriptor) 0
		 (read-record-word addressor (1+ descriptor)) 0
		 (read-record-word addressor (+ 2 descriptor)) 0)
	   free)
	  (t
	   (let* ((n-bytes (length vector))
		  (odd-bytes (mod n-bytes bytes-per-word))
		  (whole-words (floor n-bytes bytes-per-word)))
	     (setf (read-record-word addressor descriptor) size
		   (read-record-word addressor (1+ descriptor)) free
		   (sys:%logldb *byte-vector-odd-bytes*
				(read-record-word addressor (+ 2 descriptor))) odd-bytes)
	     (sys:with-stack-array (indirect-array whole-words
						   :element-type 'fixnum
						   :displaced-to vector)
	       (let ((end (+ free whole-words)))
		 (unless (zerop whole-words)
		   (write-multiple-record-word addressor free end indirect-array))
		 (unless (zerop odd-bytes)
		   (loop with last-word = 0
			 for byte from 0
			 for i from (* whole-words bytes-per-word) repeat odd-bytes do
		     ;; unfold this
		     (setf (sys:%logldb (byte byte-size (* byte byte-size)) last-word)
			   (aref vector i))
			 finally
			   (setf (read-record-word addressor end) last-word))))
	       (+ free size)))))))

(defmethod format-value-internal ((handler vector-unsigned-handler) value value-not-null-p stream)
  (with-slots (byte-size) handler
    (prin1 (when value-not-null-p
	     (list byte-size (length value) (zl:listarray value)))
	   stream)))

(defmethod unformat-data ((handler vector-unsigned-handler) value table)
  (declare (ignore table))
  (with-slots (byte-size) handler
    (if value
	(let ((byte-size (first value))
	      (n-elements (second value))
	      (elements (third value)))
	  (sys:with-stack-list (type 'unsigned-byte byte-size)
	    (make-array n-elements :element-type type :initial-contents elements)))
	(values nil t))))

(eval-when (compile cl:load eval)
  (defparameter *character-operators*
		'(char< char char<= char> char char>=
			char-lessp char-greaterp char-not-lessp char-not-greaterp
			char-equal char= equal eql)))

(define-builtin-type string-char 16 16)

(defmethod statice-typep ((handler string-char-handler) object)
  (with-slots (statice-type:original-presentation-type) handler
    (and (typep object 'string-char)
	 (or (eq statice-type:original-presentation-type 'string-char)
	     (dw::ptypep object statice-type:original-presentation-type)))))

(defmethod check-spec ((handler string-char-handler) spec)
  (check-spec-standard 'string-char *character-operators*))

(defmethod check-operator ((handler string-char-handler) operator)
  (member operator *character-operators*))

(defmethod fixed-space ((handler string-char-handler))
  (values 8 8))

(defmethod read-value ((handler string-char-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (declare (ignore database into-string stack-cons-if-appropriate))
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 8 bit-offset) word)))
    (if (= code 255)
	*null-value*
	(code-char code))))

;;; Return "free", which is just what we were passed.
(defmethod write-value ((handler string-char-handler) char addressor descriptor free
			database table size)
  (declare (ignore database table size))
  (let ((word-offset (desc-word-offset descriptor))
	(bit-offset (desc-bit-offset descriptor)))
    (setf (sys:%logldb (byte 8 bit-offset) (read-record-word addressor word-offset))
	  (if (eq char *null-value*) 255 (char-code char))))
  free)

(defmethod value-equal ((handler string-char-handler) addressor descriptor char database)
  (declare (ignore database))
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 8 bit-offset) word)))
    (unless (= code 255)
      (= code (char-code char)))))

(defmethod record-equal ((handler string-char-handler) addressor-1 addressor-2 descriptor-1 descriptor-2)
  (let* ((word-offset-1 (desc-word-offset descriptor-1))
	 (bit-offset-1 (desc-bit-offset descriptor-1))
	 (word-1 (read-record-word addressor-1 word-offset-1))
	 (code-1 (sys:%logldb (byte 8 bit-offset-1) word-1)))
    (unless (= code-1 255)
      (let* ((word-offset-2 (desc-word-offset descriptor-2))
	     (bit-offset-2 (desc-bit-offset descriptor-2))
	     (word-2 (read-record-word addressor-2 word-offset-2))
	     (code-2 (sys:%logldb (byte 8 bit-offset-2) word-2)))
	(unless (= code-2 255)
	  (= code-1 code-2))))))

(defmethod value-null-p ((handler string-char-handler) addressor descriptor)
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 8 bit-offset) word)))
    (= code 255)))

(defmethod case-insensitive-type-p ((handler string-char-handler)) nil)

(defmethod comparable-p ((handler string-char-handler)) t)

(defmethod value-compare ((handler string-char-handler) addressor descriptor char database
			  &key case-sensitive)
  (declare (ignore database))
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 8 bit-offset) word)))
    (cond ((= code 255) *null-value*)
	  ((eq char *null-value*) :lessp)
	  ((funcall (if case-sensitive #'char< #'char-lessp) (code-char code) char) :lessp)
	  ((funcall (if case-sensitive #'char> #'char-greaterp) (code-char code) char)
	   :greaterp)
	  (t :equal))))

(defmethod record-compare ((handler string-char-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 database-1 database-2)
  (declare (ignore database-1 database-2))
  (let* ((word-offset-1 (desc-word-offset descriptor-1))
	 (bit-offset-1 (desc-bit-offset descriptor-1))
	 (word-1 (read-record-word addressor-1 word-offset-1))
	 (code-1 (sys:%logldb (byte 8 bit-offset-1) word-1))
	 (word-offset-2 (desc-word-offset descriptor-2))
	 (bit-offset-2 (desc-bit-offset descriptor-2))
	 (word-2 (read-record-word addressor-2 word-offset-2))
	 (code-2 (sys:%logldb (byte 8 bit-offset-2) word-2)))
    (cond ((= code-1 255)
	   (if (= code-2 255) :equal :greaterp))
	  ((= code-2 255) :lessp)
	  (t
	   (let ((char-1 (code-char code-1))
		 (char-2 (code-char code-2)))
	     (cond ((char< char-1 char-2) :lessp)
		   ((char> char-1 char-2) :greaterp)
		   (t :equal)))))))

(eval-when (compile cl:load eval)			;do this since this isn't in defs,
(defconstant *character-null-value* #o177777)	;and it's used in other.lisp
)						;eval-when

(define-builtin-type character 17 17)

(defmethod statice-typep ((handler character-handler) object)
  (with-slots (statice-type:original-presentation-type) handler
    (and (characterp object)
	 (or (eq statice-type:original-presentation-type 'character)
	     (dw::ptypep object statice-type:original-presentation-type)))))

(defmethod check-spec ((handler character-handler) spec)
  (check-spec-standard 'character *character-operators*))

(defmethod check-operator ((handler character-handler) operator)
  (member operator *character-operators*))

(defmethod fixed-space ((handler character-handler))
  (values 16 16))

(defmethod read-value ((handler character-handler) addressor descriptor database
		       &key into-string stack-cons-if-appropriate)
  (declare (ignore into-string stack-cons-if-appropriate))
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 16 bit-offset) word)))
    (if (= code *character-null-value*)
	*null-value*
	(decode-char code database))))

(defun decode-char (sub-index-and-type database)
  (let ((type (aref (database-table-of-character-encodings database)
		    (sys:%logldb (byte 8 8) sub-index-and-type))))
    (si:%make-character (sys:%logdpb type si:%%char-all-but-subindex sub-index-and-type))))

;;; Return "free", which is just what we were passed.
(defmethod write-value ((handler character-handler) char addressor descriptor free database table size)
  (declare (ignore table size))
  (let ((word-offset (desc-word-offset descriptor))
	(bit-offset (desc-bit-offset descriptor))
	pending-encodings)
    (setf (sys:%logldb (byte 16 bit-offset) (read-record-word addressor word-offset))
	  (if (eq char *null-value*)
	      *character-null-value*
	      (let* ((table-of-types (database-table-of-character-types database))
		     (char-type (si:char-type char))
		     (type-code (gethash char-type table-of-types)))
		(unless type-code
		  (note-schema-modified database)
		  ;; new character style for this datbase
		  (setq type-code (1+ (loop for e being the hash-values of table-of-types
					    maximize e)))
		  (setf (gethash char-type table-of-types) type-code)
		  (setf (aref (database-table-of-character-encodings database) type-code)
			char-type)
		  ;; We can't call make-system-tuple here because
		  ;; the addressor has pointers right into the record's
		  ;; word in the page.  make-system-tuple can
		  ;; cause compress-page to be called which moves the
		  ;; position of the record on the page.  Seems easier
		  ;; to just queue the new %%char-encoding tuples
		  ;; until afterwards
		  (let ((style (si:unparse-character-style (si:char-style char))))
		    (multiple-value-bind (bits char-set offset)
			(si:compute-character-type-info char)
		      (macrolet ((full-symbol-name (symbol)
				   `(string-append (package-name (symbol-package ,symbol))
						   ":"
						   (symbol-name ,symbol))))
			(push (list type-code
				    (or char-set (symbol-name char-set))
				    (full-symbol-name (first style))
				    (full-symbol-name (second style))
				    (full-symbol-name (third style))
				    bits
				    offset)
			      pending-encodings)))))
		(sys:%logdpb type-code si:%%char-all-but-subindex (si:char-subindex char)))))
    (loop for (index char-set family face size bits offset)
	      in pending-encodings do
      (make-system-tuple database "%%character-encoding"
			 "epsilon-code" index
			 "character-set" char-set
			 "family" family
			 "face" face
			 "size" size
			 "bits" bits
			 "offset" offset)))
  free)

(defmethod value-equal ((handler character-handler) addressor descriptor char database)
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 16 bit-offset) word)))
    (unless (= code *character-null-value*)
      (and (= (si:char-subindex char) (sys:%logldb (byte 8 0) code))
	   (= (si:char-type char) (aref (database-table-of-character-encodings database)
					(sys:%logldb (byte 8 8) code)))))))

(defmethod record-equal ((handler character-handler) addressor-1 addressor-2
			 descriptor-1 descriptor-2)
  (let* ((word-offset-1 (desc-word-offset descriptor-1))
	 (bit-offset-1 (desc-bit-offset descriptor-1))
	 (word-1 (read-record-word addressor-1 word-offset-1))
	 (code-1 (sys:%logldb (byte 16 bit-offset-1) word-1)))
    (unless (= code-1 *character-null-value*)
      (let* ((word-offset-2 (desc-word-offset descriptor-2))
	     (bit-offset-2 (desc-bit-offset descriptor-2))
	     (word-2 (read-record-word addressor-2 word-offset-2))
	     (code-2 (sys:%logldb (byte 16 bit-offset-2) word-2)))
	(unless (= code-2 *character-null-value*)
	  (= code-1 code-2))))))

(defmethod value-null-p ((handler character-handler) addressor descriptor)
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 16 bit-offset) word)))
    (= code *character-null-value*)))

(defmethod case-insensitive-type-p ((handler character-handler)) nil)

(defmethod comparable-p ((handler character-handler)) t)

(defmethod value-compare ((handler character-handler) addressor descriptor char database
			  &key case-sensitive)
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 16 bit-offset) word)))
    (if (= code *character-null-value*)
	*null-value*
	(let ((record-char (decode-char (sys:%logldb (byte 16 bit-offset) word) database)))
	  (cond ((eq char *null-value*) :lessp)
		((funcall (if case-sensitive #'char< #'char-lessp) record-char char)
		 :lessp)
		((funcall (if case-sensitive #'char> #'char-greaterp) record-char char)
		 :greaterp)
		(t :equal))))))

(defmethod record-compare ((handler character-handler) addressor-1 addressor-2
			   descriptor-1 descriptor-2 db1 db2)
  (declare (ignore db1 db2))
  (let* ((word-offset-1 (desc-word-offset descriptor-1))
	 (bit-offset-1 (desc-bit-offset descriptor-1))
	 (word-1 (read-record-word addressor-1 word-offset-1))
	 (code-1 (sys:%logldb (byte 16 bit-offset-1) word-1))
	 (word-offset-2 (desc-word-offset descriptor-2))
	 (bit-offset-2 (desc-bit-offset descriptor-2))
	 (word-2 (read-record-word addressor-2 word-offset-2))
	 (code-2 (sys:%logldb (byte 16 bit-offset-2) word-2)))
    (cond ((= code-1 *character-null-value*)
	   (if (= code-2 *character-null-value*) :equal :greaterp))
	  ((= code-2 *character-null-value*) :lessp)
	  (t
	   (let ((char-1 (code-char code-1))
		 (char-2 (code-char code-2)))
	     (cond ((char< char-1 char-2) :lessp)
		   ((char> char-1 char-2) :greaterp)
		   (t :equal)))))))

(scl:define-presentation-type all-but-entity ()
   :abbreviation-for 'lisp-object)

(define-builtin-type all-but-entity 18 18 nil (lisp-object-handler))

(defmethod statice-typep ((handler all-but-entity-handler) object)
  (with-slots (statice-type:original-presentation-type) handler
    (unless (typep object 'entity-handle)
      (or (eq statice-type:original-presentation-type 'lisp-object)
	  (dw::ptypep object statice-type:original-presentation-type)))))

(defmethod entity-type-p ((handler all-but-entity-handler))
  nil)

(statice-type:define-value-type member
   (:format :logical)
   (:based-on-function member-based-on))

(defun member-based-on (presentation-type)
  (dw:with-type-decoded (nil data-args)
	presentation-type
     `(integer 0 (,(length data-args)))))

(defmethod statice-type:encode-value ((handler member-handler) value)
  (with-slots (statice-type:presentation-type) handler
    (dw:with-type-decoded (nil data-args) statice-type:presentation-type
       (position value data-args))))

(defmethod statice-type:decode-value ((handler member-handler) integer)
  (with-slots (statice-type:presentation-type) handler
    (dw:with-type-decoded (nil data-args) statice-type:presentation-type
       (nth integer data-args))))

(statice-type:define-value-type scl:alist-member
   (:format :logical)
   (:based-on-function alist-member-based-on))

;;; The presentation type system is currently somewhat confused when it
;;; comes to alist-member.  Until this gets fixed up, change it to use
;;; equalp as far as Statice is concerned.
(defmethod statice-typep ((handler alist-member-handler) value)
  (with-slots (statice-type:presentation-type) handler
    (dw::with-type-decoded (nil data-args) statice-type:presentation-type
       (member value (getf data-args :alist)
	       :test #'equalp
	       :key #'tv:menu-execute-no-side-effects))))

(defun alist-member-based-on (presentation-type)
  (dw::with-type-decoded (nil data-args) presentation-type
     `(integer 0 (,(length (getf data-args :alist))))))

(defmethod statice-type:encode-value ((handler alist-member-handler) value)
  (with-slots (statice-type:presentation-type) handler
    (dw::with-type-decoded (nil data-args) statice-type:presentation-type
       (position value (getf data-args :alist)
		 :test #'equalp
		 :key #'tv:menu-execute-no-side-effects))))

(defmethod statice-type:decode-value ((handler alist-member-handler) integer)
  (with-slots (statice-type:presentation-type) handler
    (dw::with-type-decoded (nil data-args) statice-type:presentation-type
       (tv:menu-execute-no-side-effects (nth integer (getf data-args :alist))))))

(statice-type:define-value-type dw:member-sequence
   (:format :logical)
   (:based-on-function member-sequence-based-on))

(defun member-sequence-based-on (presentation-type)
  (dw::with-type-decoded (nil data-args) presentation-type
     `(integer 0 (,(length (first data-args))))))

(defmethod statice-type:encode-value ((handler member-sequence-handler) value)
  (with-slots (statice-type:presentation-type) handler
    (dw::with-type-decoded (nil data-args) statice-type:presentation-type
       (position value (first data-args) :test #'equalp))))

(defmethod statice-type:decode-value ((handler member-sequence-handler) integer)
  (with-slots (statice-type:presentation-type) handler
    (dw::with-type-decoded (nil data-args) statice-type:presentation-type
       (nth integer (first data-args)))))

(assign-type-to-handler time:universal-time integer-handler)

(assign-type-to-handler time:time-interval integer-handler)

(assign-type-to-handler time:time-interval-60ths integer-handler)

(statice-type:define-value-type cl:pathname
  (:format :logical)
  (:based-on string))

;;; replaced without-interrupts with process:without-preemption - jga 15 Sept 92
(defmethod statice-type:encode-value ((handler pathname-handler) pathname)
  ;; The following code is copied from FULLY-QUALIFIED-PATHNAME-STRING
  ;; in Zmail.  I didn't want Statice to depend on Zmail's being loaded.
  ;; This functionality really belongs in the core system.
  (when (eq (send pathname :system-type) :logical)
    (setq pathname (send pathname :translated-pathname)))
  (process:without-preemption
    (send pathname :decache-host-name)
    (prog1
      (let* ((neti:*namespace* neti:*distribution-namespace*)
	     (neti:*namespace-search-list* (send neti:*namespace* :search-rules))
	     (net:*local-host* neti:*distribution-local-host*)
	     (si:local-host net:*local-host*))
	(string pathname))
      (send pathname :decache-host-name))))

(defmethod statice-type:decode-value ((handler pathname-handler) string)
  (fs:parse-pathname string))

;;; An image value is a 2-d bit array.  Either the width is a multiple
;;; of 32, or the array is an indirect array conformally displaced to an
;;; underlying array whose width is a multiple of 32.  Otherwise the
;;; array is not an image.
(scl:define-presentation-type image (())
   :expander '(array bit (* *)))

;;; Word   Meaning
;;;   0    image width
;;;   1    image height
;;;   2    array width, a multiple of 32.
;;;   3    array height
(statice-type:define-value-type image
   (:format :variable))

(defmethod statice-type:size-of-value ((handler image-handler) value)
  (let* ((real-array (or (si:array-indirect-to value) value))
	 (array-width (array-dimension real-array 1))
	 (array-height (array-dimension real-array 0))
	 (n-words (/ (* array-width array-height) 32)))
    (+ 4 n-words)))

(defmethod statice-type:read-value ((handler image-handler) addressor offset size)
  (declare (ignore size))
  (let* ((image-width (read-record-word addressor offset))
	 (image-height (read-record-word addressor (1+ offset)))
	 (array-width (read-record-word addressor (+ offset 2)))
	 (array-height (read-record-word addressor (+ offset 3)))
	 (n-words (/ (* array-width array-height) 32))
	 (real-array (make-raster-array array-width array-height :element-type 'bit)))
    (read-multiple-record-word addressor (+ offset 4) (+ offset 4 n-words)
			       :into (make-array n-words :displaced-to real-array))
    (if (= image-width array-width)
	real-array
	(make-raster-array image-width image-height
			   :displaced-to real-array
			   :displaced-conformally t
			   :element-type 'bit))))

(defmethod statice-type:write-value ((handler image-handler) value addressor offset size)
  (declare (ignore size))
  (let* ((image-width (array-dimension value 1))
	 (image-height (array-dimension value 0))
	 (real-array (or (si:array-indirect-to value) value))
	 (array-width (array-dimension real-array 1))
	 (array-height (array-dimension real-array 0))
	 (n-words (/ (* array-width array-height) 32)))
    (unless (zerop (mod array-width 32))
      (error "The array ~S was provided as a value of type IMAGE, but it is not~@
              built out of an array whose width is a multiple of 32." value))
    (setf (read-record-word addressor offset) image-width)
    (setf (read-record-word addressor (1+ offset)) image-height)
    (setf (read-record-word addressor (+ offset 2)) array-width)
    (setf (read-record-word addressor (+ offset 3)) array-height)
    (write-multiple-record-word
      addressor (+ offset 4) (+ offset 4 n-words)
      (make-array n-words :displaced-to real-array))
    (+ offset 4 n-words)))

(defmethod statice-type:value-equal ((handler image-handler) value addressor offset size)
  (declare (ignore value addressor offset size))
  nil)

;;; Base class for all the unknown storage handler classes.
(defclass unknown-handler
	  (value-storage-handler)
    ())

;;; Storage handler for a logical type that's based on a builtin type
;;; and whose definition is not in the Lisp world.
(defclass unknown-logical-handler
	  (unknown-handler)
    ((underlying-handler :initarg :underlying-handler)))

(defmethod format-data-internal ((handler unknown-logical-handler) addressor
				 descriptor stream database)
  (with-slots (underlying-handler) handler
    (format-data-internal underlying-handler addressor descriptor stream database)))

;;; Storage handler for a fixed type whose definition is not loaded in
;;; the Lisp world, or a logical type whose definition is not loaded in
;;; the Lisp world and that is based on a fixed type.
(defclass unknown-fixed-handler
	  (fixed-dumper-mixin unknown-handler)
    ((n-bits :initarg :n-bits)
     (alignment :initarg :alignment)))

(defmethod fixed-space ((handler unknown-fixed-handler))
  (with-slots (n-bits alignment) handler
    (values n-bits alignment)))

;;; Storage handler for a variable type whose definition is not loaded in
;;; the Lisp world, or a logical type whose definition is not loaded in
;;; the Lisp world and that is based on a variable type.
(defclass unknown-variable-handler
	  (variable-dumper-mixin unknown-handler)
    ())

;;; Given an attribute record that designates a presentation type that
;;; is not a known presentation type in the Lisp world, or that is a
;;; presentation type for which no Statice info is available, return a
;;; storage handler instance to represent this unknown type.  This is to
;;; be called by encache-attributes.
(defun get-unknown-storage-handler (att presentation-type no-nulls)
  (let ((kind (attribute-handler-kind att))
	(info (attribute-handler-info att)))
    (zl:select kind
      (*handler-kind-fixed*
	(make-instance 'unknown-fixed-handler
		       :n-bits (ldb (byte 8 8) info)
		       :alignment (ldb (byte 8 0) info)
		       :original-presentation-type presentation-type
		       :no-nulls no-nulls))
      (*handler-kind-variable*
	(make-instance 'unknown-variable-handler
		       :original-presentation-type presentation-type
		       :no-nulls no-nulls))
      (*handler-kind-builtin*
	(make-instance 'unknown-logical-handler
		       :underlying-handler (make-instance
					     (storage-handler-builtin-decode info))
		       :original-presentation-type presentation-type
		       :no-nulls no-nulls))
      (otherwise
	(model-error "Invalid value in attribute-handler-kind field of ~S" att)))))

;;; Whop this generic function for the unknown handlers, and if error-method
;;; is true, generate a primary method that signals an error.
;;; This gets a little more complicated than in the flavored version,
;;; (it was called add-become-known-whopper)
;;; as clos methods are required to have consistent lambda lists - JGA 10 Aug 92

(defmacro add-become-known-around-method (generic-function &optional error-method)
  (let ((ampersands '(&optional &rest &key &allow-other-keys))
	(keyword-package (find-package "")))
    (flet ((caller-arglist (arglist)
	     ;; turn (foo bar &key baz biff) into (foo bar :baz baz :biff biff)
	     (let ((new-args nil) (in-keys nil) (on-rest nil))
	       (dolist (arg arglist)
		 (if (member arg ampersands)
		     (case arg
		       (&key (setq in-keys t))
		       (&rest (setq on-rest t)))
		     (cond (on-rest (setq on-rest nil))
			   (T (when in-keys
				(push (intern (symbol-name arg) keyword-package) new-args))
			      (push arg new-args)))))
	       (nreverse new-args))))
      (let ((arglist (arglist generic-function)))
	(if arglist
	    (pop arglist) ; treat the first arg specially
	    (error "Couldn't find an arglist for ~S" generic-function))
	(let ((ignore-args (set-difference arglist ampersands))
	      (caller-args (caller-arglist arglist)))			     
	  `(progn
	     (record-source-file-name ',generic-function 'add-become-known-around-method)
	     (defmethod ,generic-function :around ((handler unknown-handler) ,@arglist)
	       (declare (sys:function-parent ,generic-function add-become-known-around-method))
	       (let ((new-class (get-new-class-for-storage-handler handler)))
		 (cond (new-class
			(change-classD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 0handler new-class)
			;; Initialization generic function will go here.
			(,generic-function handler ,@caller-args))
		       (t (call-next-method handler ,@caller-args)))))
	     ,(when error-method
		`(defmethod ,generic-function ((handler unknown-handler) ,@arglist)
		   (declare (sys:function-parent ,generic-function add-become-known-around-method)
			    (ignore ,@ignore-args))
		   (with-slots (statice-type:original-presentation-type) handler
		     (error "The type ~S is not known by Statice"
			    statice-type:original-presentation-type))))))))))

(defmethod get-new-class-for-storage-handler ((handler value-storage-handler))
  (with-slots (statice-type:original-presentation-type
	       statice-type:no-nulls statice-type:presentation-type) handler
    (multiple-value-bind (class type)
	(get-storage-handler-class statice-type:original-presentation-type
				   statice-type:no-nulls
				   :if-does-not-exist nil)
      (when class
	(setq statice-type:presentation-type type))
      class)))

(add-become-known-around-method statice-typep t)
(add-become-known-around-method check-spec t)
(add-become-known-around-method check-operator t)
(add-become-known-around-method fixed-space t)
(add-become-known-around-method size-of-value t)
(add-become-known-around-method size-of-field t)
(add-become-known-around-method length-of-array t)
(add-become-known-around-method start-of-field t)
(add-become-known-around-method read-value t)
(add-become-known-around-method entity-type-p t)
(add-become-known-around-method string-type-p t)
(add-become-known-around-method map-over-subvalues t)
(add-become-known-around-method write-value t)
(add-become-known-around-method value-equal t)
(add-become-known-around-method record-equal t)
(add-become-known-around-method value-null-p t)
(add-become-known-around-method case-insensitive-type-p t)
(add-become-known-around-method comparable-p t)
(add-become-known-around-method value-compare t)
(add-become-known-around-method record-compare t)
(add-become-known-around-method adjust-variable-words t)
(add-become-known-around-method format-data-internal)
(add-become-known-around-method unformat-data t)

;;; maybe add some combined-method compilation hackery sometime - jga 15 Sept 92
;;; (scl:compile-flavor-methods unknown-logical-handler unknown-fixed-handler
;;;			        unknown-variable-handler)
