;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Statice Function Level

 

;;; These need to come before the defflavor to avoid redefinition
;;; warnings.
(scl:defgeneric schema-types (schema))

(scl:defgeneric schema-name (schema))

(scl:defgeneric type-attributes (entity-type))

(scl:defgeneric type-parent-names (entity-type &optional (just-entities nil)))

(scl:defgeneric type-name (entity-type))

(scl:defgeneric type-area-name (entity-type))

(scl:defgeneric type-set-exists (entity-type))

(scl:defgeneric type-multiple-indexes (entity-type))

(scl:defgeneric attribute-name (attribute))

(scl:defgeneric attribute-function-name (attribute))

(scl:defgeneric attribute-type (attribute))

(scl:defgeneric attribute-value-type (attribute))

(scl:defgeneric attribute-value-is-set (attribute))

(scl:defgeneric attribute-value-foreign (attribute))

(scl:defgeneric attribute-unique (attribute))

(scl:defgeneric attribute-read-only (attribute))

(scl:defgeneric attribute-area-name (attribute))

(scl:defgeneric attribute-set-exists (attribute))

(scl:defgeneric attribute-index-exists (attribute))

(scl:defgeneric attribute-index-average-size (attribute))

(scl:defgeneric attribute-inverse-index-exists (attribute))

(scl:defgeneric attribute-inverse-index-exact-exists (attribute))

(scl:defgeneric attribute-inverse-index-average-size (attribute))

(scl:defgeneric attribute-no-nulls (attribute))

(scl:defgeneric attribute-inverse-function-name (attribute))

(scl:defgeneric multiple-index-attribute-names (multiple-index))

(scl:defgeneric multiple-index-case-sensitive (multiple-index))

(scl:defgeneric multiple-index-unique (multiple-index))

(scl:defflavor basic-schema
  (name)					; Name of the schema.
  ()
  (:conc-name schema-)
  (:initable-instance-variables)
  (:readable-instance-variables name))

;;; A Statice template schema.  This is stored on the schema property of
;;; the name.  needs-checking is turned on when the schema is modified
;;; by a define-entity-type.  When various places need to use the
;;; schema, they do the checking if it's needed, and turn off the flag.
(scl:defflavor template-schema
  (type-names					; List of names of entity types.
   (needs-checking nil)				; T if error-checking needed.
   (table-version 1))				; Version number of schema table layout.
  (basic-schema)
  (:conc-name schema-)
  (:initable-instance-variables)
  (:readable-instance-variables type-names table-version)
  (:writable-instance-variables type-names table-version))

(scl:defflavor real-schema
  (cl:pathname
   types
   area-vector
   version)					;A list of real-entity-type instances.
  (basic-schema)
  (:conc-name schema-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defmethod (sys:print-self basic-schema) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream)
    (write-string "Schema " stream)
    (princ name stream)))

(scl:defflavor basic-entity-type
  (name						; Name of the type.
   parent-names					; List of symbols naming the parents.
   (functions nil)				; List of function instances.
   area-name					; Area name for entity records.
   set-exists					; B-set on the domain? 
   multiple-indexes				; List of multiple-index instances.
   own-cluster)					; Each new one gets its own-cluster?
  ()
  (:conc-name type-)
  (:initable-instance-variables)
  (:readable-instance-variables name functions area-name set-exists
				multiple-indexes own-cluster)
  (:writable-instance-variables multiple-indexes functions))

(scl:defmethod (type-parent-names basic-entity-type) (&optional (just-entities nil))
  (if just-entities
      (loop for parent-name in parent-names
	    when (get parent-name 'entity-type)
	      collect parent-name)
      parent-names))

(scl:defmethod ((scl:setf type-parent-names) basic-entity-type) (new-parent-names)
  (setq parent-names new-parent-names))

;;; Instances of this flavor represent Statice entity types.  For each
;;; instance, there is a corresponding flavor.  The name of the flavor
;;; is the same as the value of the "name" instance variable herein.
;;; This instance is stored on the entity-type property of the name.
(scl:defflavor template-entity-type
  (conc-name
   domain-tag					; Schema table tag of domain handle.
   relation-tag					; Schema table tag of relation handle.
   soo-att-tag					; Schema table tag of soo-att handle.
   flavor-keywords)				; Keywords to init i.v.'s or init-keywords.
  (basic-entity-type)
  (:conc-name type-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor real-entity-type
  (domain-handle
   relation-handle)
  (basic-entity-type)
  (:conc-name type-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defmethod (sys:print-self basic-entity-type) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream)
    (write-string "Entity-Type " stream)
    (princ name stream)))

;;; A table mapping from entity type names to lists of schema
;;; names.  Given a type, what schemas use this entity type?
(defvar *schemas-using-entity-type* (cl:make-hash-table))

(scl:defflavor basic-function
  (slot-name					; Name of slot.
   full-name					; Name of function; concatenated name.
   argument-type-name				; Type (name) of argument.
   value-type-name				; Type (name) of value returned.
   value-is-set					; True if set-valued, false if single-valued.
   value-foreign				; True if the value is of foreign type.
   (unique nil)					; This is a :unique function?
   (read-only nil)				; True is this is a read-only function.
   implementation				; Name of the implementation of fn, a symbol.
   cached					; This function is cached. (t or group-name)
   cache-transaction-name			; The iv which holds the trnid for this cache
   cache-name					; The iv name for this cache %$slot-name
   cache-null-name				; The iv name for "not" null flag
   (inverse-function-name nil)			; The function name of the inverse
   (inverse-cache-transaction-name nil))	; The function has an inverse which is cached
  ()
  (:conc-name function-)
  (:initable-instance-variables)
  (:readable-instance-variables))

;;; Instances of this flavor represent Statice functions.  Note that
;;; these exist both for normal functions and for inverse functions.
;;; This instance is stored on the statice-function property of the
;;; function name.  Note: the reason that we store entity-type names
;;; instead of entity-type instances is that the type referred to might
;;; be defined after we are.  And it has to be that way in both
;;; directions, because of inverse functions.
(scl:defflavor template-function
  (relation-tag					; Schema table tag of rel handle.
   of-attribute-tag				; Schema table tag of "of" att handle.
   is-attribute-tag)				; Schema table tag of "is" att handle.
  (basic-function)
  (:conc-name function-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor basic-forward-function
  ((area-name nil)				; Area name for tuple records or nil.
   (set-exists nil)				; B-set on the relation? or nil.
   (cluster nil)				; This attribute is a child attribute
   (index-exists nil)				; A forward index should be created?
   (index-average-size nil)			; Average size for the forward index, or nil.
   (inverse-index-exists nil)			; An inverse index should be created?
   (inverse-index-exact-exists nil)		; A case-sensitive inverse "    " ?
   (inverse-index-average-size nil)		; Average size for the inverse index, or nil.
   (no-nulls nil))				; If true, forbid null values.
  (basic-function)
  (:conc-name function-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor template-forward-function
  (keyword-name					; Keyword version of slot name.
   (init-function nil))				; Function to produce initial value, or nil.
  (template-function basic-forward-function)
  (:conc-name function-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor real-forward-function
  (relation
   of-attribute
   is-attribute)
  (basic-forward-function)
  (:conc-name function-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor basic-inverse-function () (basic-function))

(scl:defflavor template-inverse-function () (template-function basic-inverse-function))

;;; Flavors used at run-time.
(scl:defflavor functional-database
	((schema-table nil)
	 (schema-table-version 0)
	 (schema-name nil))
	(statice-model::database)
  (:initable-instance-variables)
  (:writable-instance-variables))

(defclass functional-entity-handle
	  (statice-model::known-entity-handle)
    ((schema-table :accessor functional-entity-handle-schema-table)))

(defmethod clos:initialize-instance :after ((handle functional-entity-handle) &key &allow-other-keys)
  (with-slots (schema-table) handle
    (setf schema-table (functional-database-schema-table (home-database-of handle)))))

;;; I'm not sure this ever will get used.  If not, remember to
;;; delete it from the compile-flavor-methods as well as here.
(scl:defflavor real-inverse-function () (basic-inverse-function))

(scl:defmethod (forward-function-p basic-forward-function) () t)

(scl:defmethod (forward-function-p basic-inverse-function) () nil)

;;; This is the flavor that actually gets instantiated, so that it will
;;; look right to callers, but it's really the same thing as
;;; forward-function.
(scl:defflavor template-attribute () (template-forward-function))

(scl:defflavor real-attribute () (real-forward-function))

(scl:defmethod (sys:print-self basic-function) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream)
    (write-string "Attribute " stream)
    (princ slot-name stream)
    (write-string " of " stream)
    (princ argument-type-name stream)))

(scl:defmethod (sys:print-self basic-inverse-function) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream)
    (write-string "Inverse Function " stream)
    (princ full-name stream)
    (write-string " of " stream)
    (princ value-type-name stream)))

(scl:defmethod (describe-attribute basic-forward-function) (stream)
  (scl:filling-output (stream)
    (format stream "~&~S is a slot in entity-type ~S with ~
                    accessor function ~S and type ~S.~%~@
                    It is ~:[single~;set~] valued, ~
                    ~:[not ~]unique, ~
                    ~:[modifiable~;read only~], ~
                    ~:[not ~]cached, ~
                    and is in ~:[the default area~*~;area ~S~].  ~
                    It ~:[does not have an inverse~*~;has an inverse named ~S~]."
	    slot-name argument-type-name full-name value-type-name value-is-set
	    unique read-only cached area-name area-name
	    inverse-function-name inverse-function-name)))

(scl:defmethod (describe-attribute basic-inverse-function) (stream)
  (scl:filling-output (stream)
    (format stream "~&~S is an inverse function in entity-type ~S with ~
                    accessor function ~S and argument type ~S.~%~@
                    It is ~:[single~;set~] valued, ~
                    ~:[not ~]unique, ~
                    ~:[modifiable~;read only~], and ~
                    ~:[not ~]cached."
	    slot-name argument-type-name full-name value-type-name value-is-set
	    unique read-only cached)))

;;; A volatile object representing a multiple index.
(scl:defflavor basic-multiple-index
  (type						; The type that this index is part of.
   slot-names					; List of symbols naming the slots.
   unique					; Whether it's unique or not.
   case-sensitive)				; Whether it's case-sensitive or not.
  ()
  (:conc-name multiple-index-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor template-multiple-index
  ()
  (basic-multiple-index)
  (:conc-name multiple-index-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defflavor real-multiple-index
  (attribute-handles)
  (basic-multiple-index)
  (:conc-name multiple-index-)
  (:initable-instance-variables)
  (:readable-instance-variables))

(scl:defmethod (sys:print-self basic-multiple-index) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream)
    (write-string "Multiple-Index on " stream)
    (format:print-list stream "~A" slot-names)
    (write-string " of " stream)
    (princ (type-name type) stream)))

;;; inside-function-level

;;; This macro should get expanded around every context in which it is
;;; guaranteed to be the case that every Statice model level operation
;;; that happens within the dynamic extent of its body is, in fact,
;;; operating directly on behalf of function level.  We may add more
;;; things to this macro in the future.  I don't want to make it use an
;;; internal function, because I'm a bit worried about the overhead that
;;; would cause, but that means everything has to be recompiled when
;;; this changes.

;;; Currently, the macro sets up a condition-bind handler that
;;; transforms model level uniqueness-violation errors into function
;;; level uniqueness-violation errors, so that the calling program, or
;;; the user, gets an error report in understandable terms.

;;; inside-function-level also calls check-transaction, so that the
;;; client will get a reasonable error if it is not inside a transaction.

;;; If database is provided, it must be a symbol.  It is made into a
;;; lexical variable, initially bound to the value of the current
;;; database.  Also, a check is made to make sure there is a current
;;; database, and signal an comprehensible error otherwise.  Some
;;; function level procedures never look at the current database
;;; explicitly, and this is made optional so that those procedures
;;; aren't slowed down.  Note that model level entrypoints always check
;;; their database arguments, so we don't have to worry about them.

;;; If database-form is provided, database must be provided as well.
;;; database-form is evaluated, and the result is the database object to
;;; bind the variable to, rather than the current-database.

(scl:defsubst current-database ()
  statice-model::*current-database*)

(defmacro inside-function-level ((&optional database database-form) &body body)
  (let ((basic-form
	  `(condition-bind ((statice-model:uniqueness-violation
			      'uniqueness-violation-handler))
	     (check-transaction)
	     . ,body)))
    (if database
	`(let ((,database ,(or database-form '(current-database))))
	   (unless ,database (error-no-current-database))
	   ,basic-form)
	basic-form)))

;;; Every function-level error is built on this flavor.
(scl:defflavor function-error () (cl:error))

(scl:defflavor no-current-database () (function-error))

(scl:defmethod (dbg:report no-current-database) (stream)
  (format stream "There is no current database"))

;;; I know this is a trivial function, but I'm making it a function so
;;; that we can change what it does, without requiring everyone to
;;; recompile everything.
(defun error-no-current-database ()
  (cl:error 'no-current-database))

;;; Internal function called when define-schema is evaluated.
(defun define-schema-internal (schema-name entity-type-names)
  (let ((schema (or (get schema-name 'schema)
		    (setf (get schema-name 'schema)
			  (scl:make-instance 'template-schema :name schema-name)))))    
    (setf (schema-type-names schema) entity-type-names)
    ;; Cause all the schema tables to be recomputed to reflect the new
    ;; set of entity types.
    (incf (schema-table-version schema)))
  (dolist (tn entity-type-names)
    (pushnew schema-name (cl:gethash tn *schemas-using-entity-type*))))

;;; Cache invalidation for the schema tables.  The type named
;;; entity-type-name has been defined, or redefined.  Find all schemas
;;; that include this entity type, and increment their
;;; schema-table-version, to signal to all the databases based on this
;;; schema that they have to reload their schema table.
(defun invalidate-schema-tables (entity-type-name)
  (dolist (sd-name (cl:gethash entity-type-name *schemas-using-entity-type*))
    (incf (schema-table-version (get sd-name 'schema)))))

;;; Return a list of all the ancestor entity-type instances,
;;; including self, in no particular order.
(scl:defmethod (ancestors basic-entity-type) ()
  (let ((result nil))
    (labels ((mark (type)
	       (unless (member type result)
		 (push type result)
		 (dolist (parent-name (type-parent-names type))
		   (let ((parent (get parent-name 'entity-type)))
		     (when parent
		       (mark parent)))))))
      (mark self))
    result))

(defun fsubtypep (subtype supertype)
  (if (or (keywordp subtype) (keywordp supertype))
      (eq subtype supertype)
      (subtypep subtype supertype)))

;;; What the phuk is this doing here, and not beside the definition of define-entity-type?
;;; I don't know, but I'll leave it here for now. - jga 16 Sept 92 

(defprop define-entity-type "Statice Entity Type" si:definition-type-name)

;;; This is called whenever someone does a setf on any attribute in an entity.
(defgeneric attribute-changed (functional-entity-handle &optional function)
  (:method-combination progn)
  (:method progn ((handle functional-entity-handle) &optional function)
   (declare (ignore function))
   nil))

;;; The approved way of bumping a tick.
(defgeneric change-version-number (functional-entity-handle function)
  (:method ((handle functional-entity-handle) function)
   (declare (ignore function))
   nil))

;;; Called whenever an accessor finds that the transaction iv for the
;;; attribute it's is accessing differs from the
;;; dbfs:current-transaction-id (and hence is about to update the
;;; cache).  Methods may update the cache themselves, and indicate to
;;; the caller that they did so by returning t.  If they didn't touch
;;; the cache, then they should return nil.
(defgeneric validate-cache (functional-entity-handle function)
  (:method ((handle functional-entity-handle) function)
   (declare (ignore function)) nil))

;;; Called when a validate-cache method wishes to only update the
;;; transaction id tags since the cache is still valid.
(defgeneric update-transaction-tags (functional-entity-handle group-name)
  (:method-combination progn))

;;; Called when we wish to refresh the cache for all attributes in the entity.
(defgeneric load-entity (functional-entity-handle group-name)
  (:method-combination progn))

;;; Called to find out what the group mapping is for this entity type.
;;; Also returns the total groups.
;;; +++ What about update-schema?
(defgeneric map-group-name (functional-entity-handle group-name)
  (declare (values group-number n-total-groups)))

;;; Called to set up the group mapping for an entity type.
;;; This is a kludge if you ask me.
(defgeneric make-group-map (functional-entity-handle)
  (:method-combination nconc)
  (:method nconc ((handle functional-entity-handle)) (list t)))

;;; clos-internals::class-direct-init-keywords ==> keys allow-other-keys
;;; only returns "direct" keywords - i.e. not those of its superclasses
;;; use class-precedence-list to get the superclasses - jga 25 Jun 92

(defun get-type-maker-keywords (type-name &optional (flavor-keywords-only? nil))
  (let ((type (get type-name 'entity-type)))
    (if type
	(let ((local-keywords
		(nconc (unless flavor-keywords-only?
			 (loop for function in (type-functions type)
			       when (typep function 'template-attribute)
				 collect (function-keyword-name function)))
		       (type-flavor-keywords type)))
	      (parent-keywords (loop for parent in (type-parent-names type)
				     append (get-type-maker-keywords parent
								     flavor-keywords-only?))))
	  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; The order of these is significant, because we don't want to change the
	  ;; list structure at the end of local-keywords, (type-flavor-keywords type)).
	  ;; This is the same reason that (type-flavor-keywords type) is the last
	  ;; argument to nconc in local-keywords.  Oh, the pains we go to in order to
	  ;; keep from copying list structure...
0	  (nconc parent-keywords local-keywords))
	(loop for class in (clos:class-precedence-list (find-class type-name))
	      append (clos-internals::class-direct-init-keywords class)))))

(defun get-type-maker-arglist (function)
  (let* ((function-name (etypecase function
			  (symbol function)
			  (function (si:compiled-function-name function))))
	 (type-name (get function-name 'entity-type))
	 (type (get type-name 'entity-type)) 
	 (type-package (symbol-package function-name)))
    (when type
      (nconc (list '&key)
	     (map 'list
		  #'(lambda (sym) (intern (symbol-name sym) type-package))
		  (get-type-maker-keywords type-name))))))

(defun error-in-caching ()
  (error "cache-transaction was set, but cache was empty"))

(scl:defflavor value-not-a-set
	()
	(function-error)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report value-not-a-set) (stream)
  (format stream "Expected a list of values"))

(defun value-not-a-set ()
  (cl:error 'value-not-a-set))

(defvar *current-cluster* nil
  "The current cluster, if any.  Values are NIL (no clustering), T (create a new cluster),
   or a handle (some handle from the current cluster)")

(defvar *inside-with-cluster* nil
  "T if currently inside a with-cluster form")

(defmacro with-cluster ((cluster-spec) &environment env &body body)
  (scl:once-only (cluster-spec &environment env)
    `(let ((*inside-with-cluster* t)
	   (*current-cluster*
	     (cond ((eq ,cluster-spec :new) t)
		   ((eq ,cluster-spec :none) nil)
		   ((typep ,cluster-spec 'handle) ,cluster-spec)
		   (t (cl:error "Unknown specification for a with-cluster clause ~S"
			     ,cluster-spec)))))
       . ,body)))

(defmacro maintaining-*current-cluster* (&body body)
  (let ((handle-sym (cl:gensym)))
    `(let ((,handle-sym . ,body))
       (when (eq *current-cluster* t) (setq *current-cluster* ,handle-sym))
       ,handle-sym)))

(scl:defflavor wrong-type-entity
	(entity-handle
	 expected-type)
	(function-error)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report wrong-type-entity) (stream)
  (format stream "The entity-handle ~S is not of type ~S"
	  entity-handle expected-type))

;;; Dynamic accessor to read any attribute's value from the database.
;;; Takes an entity-handle, an attribute object or the name of an
;;; attribute (long or short name), and a keyword :into which is for
;;; string types.  If the attribute is cached, the cache is updated.
;;; This may be called outside a transaction if the attribute is cached.
(defun attribute-value (entity-handle attribute &key into force-refresh)
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (when into (check-type into string))
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (let ((cache-name (function-cache-name attribute))
	(cache-transaction-name (function-cache-transaction-name attribute))
	(cache-null-name (function-cache-null-name attribute)))
    (flet ((refresh-cache ()
	     (if (and (null force-refresh)
		      (validate-cache entity-handle (function-full-name attribute)))
		 (values (slot-value entity-handle cache-name)
			 (slot-value entity-handle cache-null-name))
		 (multiple-value-bind (value not-null-p)
		     (attribute-value-internal entity-handle attribute :into into)
		   (setf (slot-value entity-handle cache-name) value
			 (slot-value entity-handle cache-transaction-name)
			 (and dbfs::*process-transaction* (dbfs:current-transaction-id))
			 (slot-value entity-handle cache-null-name) not-null-p)
		   (values value not-null-p)))))
      (cond
	(cache-name
	 (cond ((and (function-read-only attribute)
		     (slot-boundp entity-handle cache-name))
		(values (slot-value entity-handle cache-name)
			(slot-value entity-handle cache-null-name)))
	       ((and dbfs::*process-transaction*
		     (eql (dbfs:current-transaction-id)
			  (slot-value entity-handle cache-transaction-name)))
		(if (slot-boundp entity-handle cache-name)
		    (values (slot-value entity-handle cache-name)
			    (slot-value entity-handle cache-null-name))
		    (error-in-caching)))
	       (dbfs::*process-transaction* (refresh-cache))
	       ((slot-value entity-handle cache-transaction-name)
		(if (slot-boundp entity-handle cache-name)
		    (values (slot-value entity-handle cache-name)
			    (slot-value entity-handle cache-null-name))
		    (error-in-caching)))
	       (t
		(with-transaction () (refresh-cache)))))
	(t (attribute-value-internal entity-handle attribute :into into))))))

;;; This does the actual accessing from the database for attribute-value.
(defun attribute-value-internal (entity-handle attribute &key into)
  (inside-function-level (database)
    (let ((implementation (function-implementation attribute))
	  (schema-table (functional-database-schema-table database)))
      (ecase implementation
	(type-relation
	  (statice-model::%get-value-from-entity
	    entity-handle (or (cl:gethash (function-is-attribute-tag attribute) schema-table)
			      (no-function-named (function-full-name attribute)))
	    :into-string into))
	((binary-relation other-relation)
	 (let ((of-handle (or (cl:gethash (function-of-attribute-tag attribute) schema-table)
			      (no-function-named (function-full-name attribute))))
	       (is-handle (or (cl:gethash (function-is-attribute-tag attribute) schema-table)
			      (no-function-named (function-full-name attribute)))))
	   (cond ((function-value-is-set attribute)
		  (when into
		    (error ":INTO is not applicable to attribute ~S in entity ~S"
			   attribute entity-handle))
		  (let (answer)
		    (do-attribute (value not-null-p is-handle (:where of-handle entity-handle))
		      (push value answer))
		    answer))
		 (t
		  (block top
		    (if into
			(do-relation (r (or (gethash (function-relation-tag attribute)
						     schema-table)
					    (no-function-named
					      (function-full-name attribute)))
					(:where of-handle entity-handle))
			  (return-from top
			    (get-value-into-string r is-handle into)))
			(do-attribute (value not-null-p is-handle
					     (:where of-handle entity-handle))
			  (return-from top (values value not-null-p))))
		    (values nil nil))))))))))

;;; Like attribute-value, but just returns t if the value is non-null
;;; and nil if it is null.  Useful in cases where get-value is noticably
;;; expensive, and you don't care about the value itself.  This does not
;;; actually ever refresh the cache, since its whole purpose in life is
;;; to avoid calling get-value.
(defun attribute-value-null-p (entity-handle attribute &key force-refresh)
  (declare (scl:arglist entity-handle attribute))
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (let ((cache-name (function-cache-name attribute))
	(cache-transaction-name (function-cache-transaction-name attribute))
	(cache-null-name (function-cache-null-name attribute)))
    (flet ((refresh-cache ()
	     (if (and (null force-refresh)
		      (validate-cache entity-handle (function-full-name attribute)))
		 (not (slot-value entity-handle cache-null-name))
		 (attribute-value-null-p-internal entity-handle attribute))))
      (cond (cache-name
	     (cond ((and (function-read-only attribute)
			 (slot-boundp entity-handle cache-name))
		    (not (slot-value entity-handle cache-null-name)))
		   ((and dbfs::*process-transaction*
			 (eql (dbfs:current-transaction-id)
			      (slot-value entity-handle cache-transaction-name)))
		    (if (slot-boundp entity-handle cache-name)
			(not (slot-value entity-handle cache-null-name))
			(error-in-caching)))
		   (dbfs::*process-transaction* (refresh-cache))
		   ((slot-value entity-handle cache-transaction-name)
		    (if (slot-boundp entity-handle cache-name)
			(not (slot-value entity-handle cache-null-name))
			(error-in-caching)))
		   (t
		    (with-transaction () (refresh-cache)))))
	    (t (attribute-value-null-p-internal entity-handle attribute))))))

;;; Actually look in the database to see if the value is null.
(defun attribute-value-null-p-internal (entity-handle attribute)
  (inside-function-level (database)
    (let ((implementation (function-implementation attribute))
	  (schema-table (functional-database-schema-table database)))
      (ecase implementation
	(type-relation
	  (statice-model::%get-value-null-p-from-entity
	    entity-handle (or (gethash (function-is-attribute-tag attribute) schema-table)
			      (no-function-named (function-full-name attribute)))))
	((binary-relation other-relation)
	 (let ((of-handle (or (gethash (function-of-attribute-tag attribute) schema-table)
			      (no-function-named (function-full-name attribute))))
	       (is-handle (or (gethash (function-is-attribute-tag attribute) schema-table)
			      (no-function-named (function-full-name attribute)))))
	   (unless (function-value-is-set attribute)
	     (block top
	       (do-attribute (value not-null-p is-handle (:where of-handle entity-handle))
		 (return-from top (values value not-null-p)))
	       t))))))))

;;; Dynamic accessor to read a portion of an array valued attribute.
;;; Takes an entity-handle, an attribute object or the name of an
;;; attribute (long or short name), the start and end boundaries to
;;; read from, the array to read into, and where to start reading into
;;; in the target.  If the attribute is cached, the cache is updated.
;;; This may be called outside a transaction if the attribute is cached.
(defun attribute-value-array-portion (entity-handle attribute
				      from-start from-end into-array into-start
				      &key force-refresh)
  (declare (scl:arglist entity-handle attribute from-start from-end into-array into-start))
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (let ((cache-name (function-cache-name attribute))
	(cache-transaction-name (function-cache-transaction-name attribute))
	(cache-null-name (function-cache-null-name attribute)))
    (flet ((refresh-cache ()
	     (if (and (null force-refresh)
		      (validate-cache entity-handle (function-full-name attribute)))
		 (values (slot-value entity-handle cache-name)
			 (slot-value entity-handle cache-null-name))
		 (multiple-value-bind (value not-null-p)
		     (attribute-value-internal entity-handle attribute :into into-array)
		   (setf (slot-value entity-handle cache-name) value
			 (slot-value entity-handle cache-transaction-name)
			 (and dbfs::*process-transaction* (dbfs:current-transaction-id))
			 (slot-value entity-handle cache-null-name) not-null-p)
		   (values value not-null-p)))))
      (cond
	(cache-name
	 (cond ((and (function-read-only attribute)
		     (slot-boundp entity-handle cache-name))
		(values (slot-value entity-handle cache-name)
			(slot-value entity-handle cache-null-name)))
	       ((and dbfs::*process-transaction*
		     (eql (dbfs:current-transaction-id)
			  (slot-value entity-handle cache-transaction-name)))
		(if (slot-boundp entity-handle cache-name)
		    (values (slot-value entity-handle cache-name)
			    (slot-value entity-handle cache-null-name))
		    (error-in-caching)))
	       (dbfs::*process-transaction* (refresh-cache))
	       ((slot-value entity-handle cache-transaction-name)
		(if (slot-boundp entity-handle cache-name)
		    (values (slot-value entity-handle cache-name)
			    (slot-value entity-handle cache-null-name))
		    (error-in-caching)))
	       (t
		(with-transaction () (refresh-cache)))))
	(t (attribute-value-array-portion-internal
	     entity-handle attribute from-start from-end into-array into-start :from))))))

;;; This does the actual accessing from the database for
;;; get-attribute-value-array-portion.
(defun attribute-value-array-portion-internal (entity-handle attribute
					       from-start from-end into-array into-start
					       from-to)
  (inside-function-level (database)
    (let* ((schema-table (functional-database-schema-table database))
	   (of-handle (or (gethash (function-of-attribute-tag attribute) schema-table)
			  (no-function-named (function-full-name attribute))))
	   (is-handle (or (gethash (function-is-attribute-tag attribute) schema-table)
			  (no-function-named (function-full-name attribute)))))
	(cond ((function-value-is-set attribute)
	       (error "attribute-value-array-portion is not applicable to attribute~@
                       ~S in entity ~S"
		      attribute entity-handle))
	      (t
	       (block top
		 (do-relation (r (or (gethash (function-relation-tag attribute)
					      schema-table)
				     (no-function-named
				       (function-full-name attribute)))
				 (:where of-handle entity-handle))
		   (return-from top
		     (funcall (ecase from-to
				(:from #'get-value-array-portion)
				(:to #'set-value-array-portion))
		       r is-handle
		       from-start from-end into-array into-start)))))))))

;;; Dynamic accessor to write any attribute's value in the database.
;;; Takes an enttiy-handle, an attribute object or the name of an
;;; attribute (long or short name).
(defun set-attribute-value-array-portion (entity-handle attribute start end from from-start)
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (when (function-read-only attribute)
    (error "The attribute ~S is :READ-ONLY" attribute))
  (attribute-value-array-portion-internal
    entity-handle attribute start end from from-start :to)
  (when (function-cached attribute)
    (let ((cache-array
	    (slot-value entity-handle (function-cache-name attribute))))
      (when cache-array
	(copy-array-portion from from-start (+ from-start (- end start)) cache-array start end)
	(setf (slot-value entity-handle (function-cache-transaction-name attribute))
	       (dbfs:current-transaction-id)
	      (slot-value entity-handle (function-cache-null-name attribute))
	       t)))))

;;; Dynamic accessor to write any attribute's value in the database.
;;; Takes an entity-handle, an attribute object or the name of an
;;; attribute (long or short name).
(defun set-attribute-value (entity-handle attribute new-value)
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (when (function-read-only attribute)
    (error "The attribute ~S is :READ-ONLY" attribute))
  (inside-function-level (database)
    (let* ((implementation (function-implementation attribute))
	   (schema-table (functional-database-schema-table database))
	   (is-handle (or (gethash (function-is-attribute-tag attribute) schema-table)
			  (no-function-named (function-full-name attribute)))))
      (case implementation
	(type-relation
	  (statice-model::%set-value-from-entity entity-handle is-handle new-value))
	(otherwise
	  (let ((rel-handle (or (gethash (function-relation-tag attribute) schema-table)
				(no-function-named (function-full-name attribute))))
		(of-handle (or (gethash (function-of-attribute-tag attribute) schema-table)
			       (no-function-named (function-full-name attribute)))))
	    (cond ((function-value-is-set attribute)
		   (unless (listp new-value)
		     (value-not-a-set))
		   (ecase implementation
		     (binary-relation
		       (do-relation (r rel-handle (:where of-handle entity-handle))
			 (delete-tuple r))
		       (dolist (value new-value)
			 (maintaining-*current-cluster*
			   (make-clustered-tuple rel-handle *current-cluster*
						 of-handle entity-handle is-handle value))))
		     (other-relation
		       (do-relation (r rel-handle (:where of-handle entity-handle))
			 (set-to-null-value r of-handle))
		       (dolist (value new-value)
			 (do-relation (r rel-handle (:where is-handle value))
			   (unless (get-value-null-p r of-handle)
			     (other-relation-uniqueness-error
			       (function-full-name attribute) entity-handle value))
			   (set-value r of-handle entity-handle))))))
		  (t
		   (block top
		     (do-relation (r rel-handle (:where of-handle entity-handle))
		       (set-value r is-handle new-value)
		       (return-from top new-value))
		     ;; No tuple was found.  This can only happen for the binary
		     ;; implementation, not for the type-relation implementation.
		     (maintaining-*current-cluster*
		       (make-clustered-tuple rel-handle *current-cluster*
					     of-handle entity-handle is-handle
					     new-value))))))))
      (attribute-changed entity-handle (function-full-name attribute))
      (when (function-cached attribute)
	(setf (slot-value entity-handle (function-cache-name attribute))
	       new-value
	      (slot-value entity-handle (function-cache-transaction-name attribute))
	       (dbfs:current-transaction-id)
	      (slot-value entity-handle (function-cache-null-name attribute))
	       (or (not (null new-value))
		   (statice-model::%nil-is-valid-value is-handle)))))))

(defsetf attribute-value set-attribute-value)

;;; setf which will open a transaction and set the attribute value.
;;; This is used when we click c-m-R on an attribute value after a
;;; describe.
(defmethod (setf browser-attribute-value) ((handle functional-entity-handle)
					   attribute new-value)
  (let ((portal statice-model::(database-opening
				 (domain-handle-database
				   (known-entity-handle-domain handle)))))
    (with-database (db portal)
      (with-transaction ()
	(set-attribute-value handle attribute new-value)))))

;;; Given a symbol which names an attribute in the statice-entity-type
;;; named by the symbol in-type, find the attribute object for it.  The
;;; attribute may be a long or short name.  If it's the short name, it
;;; may name an attribute which is inherited by a parent type of
;;; in-type.
(defun get-attribute-definition (attribute in-type)
  (let ((function (get attribute 'statice-function)))
    ;; first check for a long name
    (if function
	(setq attribute function)
	;; not a long name.  Try a short name on this entity type and all parents
	(labels ((attribute-in-type (entity-type)
		   (let ((type-definition (or (get entity-type 'entity-type)
					      (no-entity-type-named entity-type))))
		     (or (find attribute (type-functions type-definition)
			       :test
			       #'(cl:lambda (attribute-name function)
				   (and (eq (function-slot-name function) attribute-name)
					(forward-function-p function))))
			 (cl:loop for parent in (type-parent-names type-definition)
			       when (attribute-in-type parent)
				 return it)))))
	  (let ((function (attribute-in-type in-type)))
	    (if function
		(setq attribute function)
		(cl:error "The attribute ~S does not seem to be an attribute in type ~S"
		       attribute in-type)))))))

(scl:defflavor schema-not-loaded
	(cl:pathname
	 schema-description-name)
	(function-error)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report schema-not-loaded) (stream)
  (format stream "The database ~A contains the symbol ~S, ~@
                  and expects to find that ~S is defined, ~@
                  in the Lisp environment, as a Statice schema.~@
                  However, it is not.  Perhaps the application~@
                  program is not loaded, not all loaded, or loaded~@
                  into some other package than ~A.~@
                  If the schema is in fact loaded, and the symbol contained~@
                  in the database (shown above) is incorrect, you may use the~@
                  ~\\presentation\\ to change it."
	  cl:pathname schema-description-name
	  schema-description-name (symbol-package schema-description-name)
	  (or (si:ignore-errors
		(scl:accept-from-string 'sage:record-group "Set Database Schema Name Command"))
	      "Set Database Schema Name Command")))

;;; Like the model level version, but never creates a database, and uses
;;; the functional-database flavor automatically. ok-if-not-found means
;;; that if some of the template schema refers to pieces of the real
;;; schema that don't exist, simply don't fill in those slots, rather
;;; than complaining.  ok-if-not-found is used by update-schema.
(defun open-database (pathname &optional ok-if-not-found)
  (let* ((database (statice-model:open-database pathname :flavor 'functional-database))
	 (sdname (functional-database-schema-name database)))
    (when (or (null sdname)
	      (null (functional-database-schema-table database))
	      (< (functional-database-schema-table-version database)
		 (schema-table-version (get sdname 'schema))))
      (with-current-database (database)
	(with-transaction ()
	  (inside-function-level ()
	    (when (null sdname)
	      (let* ((sdinfo (get-relation "%%$sdinfo"))
		     (name-att (get-attribute sdinfo "name")))
		(do-attribute (value not-null-p name-att)
		  (setf (functional-database-schema-name database) value)
		  (return nil))))
	    (let* ((sdname (functional-database-schema-name database))
		   (sd (get sdname 'schema)))
	      (unless sd
		(let ((*package* (cl:find-package "CL")))
		  (error 'schema-not-loaded :pathname pathname
			 :schema-description-name sdname)))
	      (get-schema-table database sd ok-if-not-found))))))
    database))

;;; Set up schema-table and entity-handles.  Assumes that a transaction
;;; is in progress and the current database is set up.  ok-if-not-found
;;; means that if some of the template schema refers to pieces of the
;;; real schema that don't exist, simply don't fill in those slots,
;;; rather than complaining.  ok-if-not-found is used by update-schema.
;;; If a schema-table already exists, use it rather than making a new
;;; one, since the entity handles refer directly to it.
(scl:defmethod (get-schema-table functional-database) (sd &optional ok-if-not-found)
  (let ((st (or (and schema-table (clrhash schema-table))
		(cl:make-hash-table :locking nil)))
	(ef (cl:make-hash-table :locking nil)))
    ;; Iterate over all types in the schema.
    (dolist (type-name (schema-type-names sd))
      (let ((type (get type-name 'entity-type)))
	(condition-case-if ok-if-not-found ()
	     (let ((dom (get-domain (string type-name))))
	       (setf (cl:gethash (type-domain-tag type) st) dom)
	       (setf (cl:gethash dom ef) type-name))
	   (domain-not-found))
	(condition-case-if ok-if-not-found ()
	     (let ((rel (get-relation (string type-name))))
	       (setf (cl:gethash (type-relation-tag type) st) rel)
	       (setf (cl:gethash (type-soo-att-tag type) st) (get-attribute rel "%$OF"))
	       (dolist (function (type-functions type))
		 (condition-case-if ok-if-not-found ()
		      (when (forward-function-p function)
			(case (function-implementation function)
			  (type-relation
			    (setf (cl:gethash (function-is-attribute-tag function) st)
				  (get-attribute rel (string (function-slot-name function)))))
			  (other-relation
			    (setf (cl:gethash (function-of-attribute-tag function) st)
				  (get-attribute
				    (get-relation (string (function-value-type-name function)))
				    (string-append "%$" (function-full-name function)))))
			  (binary-relation
			    (let ((brel (get-relation
					  (string-append "%$" (function-full-name function)))))
			      (setf (cl:gethash (function-relation-tag function) st) brel)
			      (setf (cl:gethash (function-of-attribute-tag function) st)
				    (get-attribute brel "OF"))
			      (setf (cl:gethash (function-is-attribute-tag function) st)
				    (get-attribute brel "IS"))))))
		    (attribute-not-found)
		    (relation-not-found))))
	   (relation-not-found))))
    (setq schema-table st)
    (setq statice-model::entity-flavors ef)
    (setq schema-table-version (schema-table-version sd))))

;;; Make a new database in the given file, according to the associated
;;; schema.  The value of the databases argument is a list.
;;; Every element of the list is a two-list, where the first element is
;;; the (fully qualified) name of a function whose type is foreign, and
;;; the second is a database object.
(defun make-database (pathname schema-name &key databases (if-exists :error))
  (let ((sd (get schema-name 'schema)))
    (unless sd
      (error "There is no schema named ~S" schema-name))
    (make-database-from-sd sd pathname databases if-exists)))

;;; For template schemas, first check that all those names are really types.
(scl:defmethod (check-and-order-types template-schema :before) ()
  (dolist (type-name type-names)
    (unless (get type-name 'entity-type)
      (error "Schema ~S lists ~S among its entity types, but ~S is not a defined entity type"
	     name type-name type-name))))

;;; Do error checking on the list of types, and return a copy of the
;;; list of type instances, in order so that parents preceed children.
(scl:defmethod (check-and-order-types basic-schema) ()
  ;; First check each type individually, to make sure that it is really
  ;; defined as an entity-type and that it's listed in the schema.
  (let* ((types (schema-types self))
	 (input-queue (cl:copy-list types))
	 (output-queue nil))
    (dolist (type types)
      (dolist (type (all-related-types type self))
	(pushnew type input-queue)))
    ;; Sort the parents before the children.
    (cl:loop for did-some-work = nil do
      (dolist (type input-queue)
	;; See whether we can do this type yet.
	(when (cl:loop for parent-name in (type-parent-names type t)
		    always (let ((parent (get parent-name 'entity-type)))
			     (or (null parent) (member parent output-queue))))
	  ;; All of the bona-fide parents are done, so we can do this one.
	  (push type output-queue)
	  (setq input-queue (delete type input-queue))
	  (setq did-some-work t)))
      (when (null input-queue)
	;; All types are processed, so we're finished.
	(return nil))
      (unless did-some-work
	;; There are still types to process, but we didn't do any work.
	(cl:error "There's a circular dependency among types in schema ~S involving ~S"
	       name input-queue)))
    (check-types-for-duplicates output-queue self)
    (nreverse output-queue)))

(defvar *types* nil)

(defun all-related-types (type schema)
  (let ((*types* nil))
    (all-related-types-1 type schema t)
    *types*))

(defun all-related-parent-types (type schema)
  (let ((*types* nil))
    (all-related-types-1 type schema nil)
    *types*))

(defun all-related-types-1 (type schema related-by-functions-p)
  (when related-by-functions-p
    (types-related-by-functions type schema))
  (dolist (type-name (type-parent-names type))
    (let ((type (and (or (find-class type-name nil 'compile)
			 (cl:error "Entity type ~S lists ~S among its parents,~@
                                 but that is not a defined type"
				(type-name type) type-name))
		     (get type-name 'entity-type))))
      (when (and type (not (member type *types*)))
	(push type *types*)
	(all-related-types-1 type schema related-by-functions-p)))))

(defun types-related-by-functions (type schema)
  (dolist (function (type-functions type))
    (when (typep function 'basic-forward-function)
      (let ((value-type-name (function-value-type-name function)))
	(when (symbolp value-type-name)
	  (let ((val-type (get value-type-name 'entity-type)))
	    (when (and val-type (not (member val-type *types*)))
	      (push val-type *types*)
	      (all-related-types-1 val-type schema t))))))))

(defun check-types-for-duplicates (type-list schema)
  (cl:loop for type1 on type-list do
    (cl:loop for attribute in (type-functions (first type1)) do
      (when (forward-function-p attribute)
	(let ((att-name (function-keyword-name attribute)))
	  (cl:loop for type2 on (all-related-parent-types (first type1) schema) do
	    (cl:loop for attribute in (type-functions (first type2)) do
	      (when (and (forward-function-p attribute)
			 (eq (function-keyword-name attribute) att-name))
		(cl:error "In schema ~S, entity-type ~S and ~S~@
                      both have an attribute named ~S."
		       (schema-name schema)
		       (type-name (first type1))
		       (type-name (first type2))
		       (string (function-keyword-name attribute)))))))))))

;;; Given an area name during the making of a new database, return the
;;; corresponding area number, or allocate a new area number and return that.
;;; Area number zero is forbidden by model level, so it gets an impossible name.
;;; Area number 1 is the default area and corresponds to NIL.  New names start
;;; with number two.
(defun intern-area (area-vector area-name)
  (check-type area-name symbol)
  (or (position area-name area-vector)
      (vector-push-extend area-name area-vector)))	 

(scl:defmethod (make-database-from-sd template-schema) (cl:pathname databases if-exists)
  (declare (ignore databases))
  (statice-model:with-database
    (database cl:pathname :create-p t :flavor 'functional-database :if-exists if-exists)
    (unless database
      ;; if-exists was nil and it already existed.
      (return-from make-database-from-sd nil))
    (with-transaction ()
      (inside-function-level ()
	(let ((schema-table (cl:make-hash-table :locking nil))
	      (entity-flavors (cl:make-hash-table :locking nil))
	      (area-vector (make-array 7 :fill-pointer 2))
	      (types (check-and-order-types self)))
	  (setf (aref area-vector 0) (scl:ncons nil))
	  ;; Make the schema table and store it in the database object.
	  (setf (functional-database-schema-table database) schema-table)
	  (setf (functional-database-schema-table-version database) table-version)
	  (setf (statice-model::database-entity-flavors database) entity-flavors)
	  (setf (functional-database-schema-name database) name)
	  ;; Store the schema name into the database.
	  (let* ((sdinfo (make-relation "%%$sdinfo"))
		 (name-att (make-attribute sdinfo "name" 'symbol)))
	    (make-tuple sdinfo name-att name))
	  ;; Make the domains.
	  (dolist (type types)
	    (let* ((type-name (type-name type))
		   (dom (make-domain
			  (string type-name)
			  (cl:loop for parent in (type-parent-names type)
				as parent-desc = (get parent 'entity-type)
				when parent-desc
				  collect (cl:gethash (type-domain-tag parent-desc) schema-table))
			  :area (intern-area area-vector (type-area-name type))
			  :domain-index-p (type-set-exists type))))
	      (setf (gethash (type-domain-tag type) schema-table) dom)
	      (setf (gethash dom entity-flavors) type-name)))
	  ;; Make the surrogate-optimized relations.  We have to make all of
	  ;; these before we process the individual functions, because one
	  ;; type can refer to the relation of another type.  Also make the
	  ;; soo-att's, while we're at it.
	  (dolist (type types)
	    ;; Since this relation is surrogate-optimized, the relation-index
	    ;; won't ever be used by query processing.
	    (let ((rel (make-relation (string (type-name type))
				      :area (intern-area area-vector (type-area-name type))
				      :relation-index-p nil)))
	      (setf (gethash (type-relation-tag type) schema-table) rel)
	      (setf (gethash (type-soo-att-tag type) schema-table)
		    (make-attribute rel "%$OF"
				    (gethash (type-domain-tag type) schema-table)
				    :unique-p t :surrogate-p t))))
	  ;; Now we're ready to go through the functions, creating
	  ;; attributes and sometimes relations.
	  (dolist (type types)
	    (let ((cluster-present nil))
	      (dolist (function (type-functions type))
		(when (and (forward-function-p function) (function-cluster function))
		  (if cluster-present
		      (cl:error "For entity type ~S, both ~S and ~S are :CLUSTERed"
			     (type-name type) (function-full-name function)
			     (function-full-name cluster-present))
		      (setq cluster-present function)))
		(make-function function schema-table area-vector))))
	  ;; Multiple indexes
	  (dolist (type types)
	    (make-multiple-indexes type schema-table))
	  ;; Store the area vector into the database.
	  (let* ((areas (make-relation "%%$areas"))
		 (name (make-attribute areas "name" 'symbol))
		 (number (make-attribute areas "number" 'integer)))
	    (loop for i from 1 below (fill-pointer area-vector) do
	      (make-tuple areas name (aref area-vector i) number i)))))))
  t)

(defun make-multiple-indexes (type schema-table)
  (let ((relation-tag nil))
    (dolist (mi (type-multiple-indexes type))
      (statice-model:make-index
	(loop for slot-name in (multiple-index-slot-names mi)
	      collect
		(loop for function in (type-functions type) do
		  (when (and (eq slot-name (function-slot-name function))
			     (forward-function-p function))
		    (let ((rt (function-relation-tag function)))
		      (cond (relation-tag
			     (unless (eq rt relation-tag)
			       (cl:error "Not all of the slots ~S are~@
                                       in the same relation in the multiple index.")))
			    (t (setq relation-tag rt))))
		    (return (gethash (function-is-attribute-tag function)
				     schema-table)))
		      finally
			(error "~S is not a valid slot-name for ~@
                                a multiple-index of type ~S"
			       slot-name (type-name type))))
	:unique-p (multiple-index-unique mi)
	:case-sensitive (multiple-index-case-sensitive mi)))))

(scl:defmethod (make-function template-inverse-function) (schema-table area-vector)
  (declare (ignore schema-table area-vector))
  nil)

(scl:defmethod (make-function template-forward-function) (schema-table area-vector)
  (let* ((argument-type (get argument-type-name 'entity-type))
	 (type-domain (or (cl:gethash (type-domain-tag argument-type) schema-table)
			  (no-entity-type-named argument-type-name)))
	 (value-is-domain (subtypep value-type-name 'functional-entity-handle))
	 (value-type (if value-is-domain
			 (cl:gethash (type-domain-tag (or (get value-type-name 'entity-type)
						       (no-entity-type-named value-type-name)))
				  schema-table)
			 value-type-name)))
    (flet ((process-index (att)
	     (when index-exists
	       (cond (index-average-size
		      (make-group-index att :average-size index-average-size))
		     (t
		      (make-group-index att)))))
	   (process-inverse-index (att)
	     (when inverse-index-exists
	       (cond ((not value-is-domain)
		      (statice-model:make-index (list att)
						:case-sensitive nil
						:unique-p unique))
		     (inverse-index-average-size
		      (make-group-index att :average-size inverse-index-average-size))
		     (t
		      (make-group-index att))))
	     (when inverse-index-exact-exists
	       (statice-model:make-index (list att)
					 :case-sensitive t
					 :unique-p unique))))
      (case implementation
	(type-relation
	  ;; Single-valued same-area function.
	  (let ((att (make-attribute
		       (gethash (type-relation-tag argument-type) schema-table)
		       (string slot-name)
		       value-type
		       :delete-nullifies value-is-domain
		       :unique-p unique
		       :no-nulls no-nulls)))
	    (setf (cl:gethash is-attribute-tag schema-table) att)
	    (process-inverse-index att)))
	(other-relation
	  ;; Set-valued, entity-typed, unique, non-foreign function.
	  ;; Surrogate-optimize on the value's type.
	  (let ((att (make-attribute
		       (gethash (type-relation-tag (get value-type-name 'entity-type))
				schema-table)
		       (string-append "%$" full-name)
		       type-domain
		       :delete-nullifies t)))
	    (setf (gethash of-attribute-tag schema-table) att)
	    (process-index att)))
	(binary-relation
	  ;; Single-valued other-area function, and the set-valued functions that
	  ;; aren't implemented as other-relation.
	  (let ((rel (make-relation
		       (string-append "%$" full-name)
		       :area (intern-area area-vector area-name)
		       :relation-index-p set-exists)))
	    (setf (gethash relation-tag schema-table) rel)
	    (let ((of-att (make-attribute rel "OF" type-domain :unique-p (not value-is-set))))
	      (setf (gethash of-attribute-tag schema-table) of-att)
	      (process-index of-att))
	    (let ((att (make-attribute rel
				       "IS"
				       value-type
				       :unique-p unique
				       :no-nulls (or value-is-set no-nulls))))
	      (setf (cl:gethash is-attribute-tag schema-table) att)
	      (process-inverse-index att))))))))

;;; make-xxx functions.

;;; General optimizer for any make-1type0 form.  Any make-1type0 call just
;;; optimizes into a make-entity call, which may then get further
;;; optimized.  Each type pushes an (add-optimizer make-1type
0;;; make-xxx-optimizer) form on top-forms.  A call to make-entity then
;;; gets optimized by make-entity-optimizer.  make-entity-optimizer
;;; checks to see if all the args are constants.  If so, then the
;;; make-entity call gets turned into a make-1type0-macro call which gets
;;; expanded into various model level calls.  The make-1type0-macro is
;;; built by make-functional-entity-maker at compile time.
(defun make-xxx-optimizer (form)
  `(make-entity ',(get (first form) 'entity-type)
		,@(rest form)))

#|
(defvar *disable-constructor-optimization* nil
  "T if entity constructor optimization should not be done during compilation")
|#

(compiler:add-optimizer make-entity make-entity-optimizer)

(defun make-entity-optimizer (form)
  (if nil
      #+ignore
      (and (compiler:constant-form-p (second form))
	   (cl:loop for (keyword value) on (cddr form) by #'cddr
		 always (compiler:constant-form-p keyword))
	   (null *disable-constructor-optimization*))
      (let ((macro-name (get (eval (second form)) 'make-macro-symbol)))
	(if macro-name
	    (list* macro-name (cddr form))
	    form))
      form))

;;; We could probably improve on the amount of consing that happens here.
(defun make-entity (type-name &rest keywords-and-values)
  (inside-function-level (database)
    (check-type type-name symbol)
    (loop for (kwd nil) on keywords-and-values by #'cddr do
      (unless (keywordp kwd) (error "~S is not a keyword" kwd)))
    (let ((type (get type-name 'entity-type)))
      (unless type
	(error "There is no defined type named ~S" type-name))
      (let ((ancestors (ancestors type))
	    (function-keywords nil)
	    (flavor-keywords (get-type-maker-keywords type-name t))
	    (flavor-list nil)
	    (type-relation-list nil)
	    (other-relation-list nil)
	    (binary-relation-list nil)
	    (cache-init-forms nil)
	    (cluster (not (null (type-own-cluster type)))))
	;; First find all the init keywords, each of which either
	;; signifies an instance variable or is an init keyword.
	(loop for (kwd val) on keywords-and-values by #'cddr do
	  (when (member kwd flavor-keywords)
	    (push kwd flavor-list)
	    (push val flavor-list)))
	;; Next go over all the functions, finding specified or default
	;; initialization forms, and partition them into three lists.
	(flet ((classify-init (function form)
		 (unless cluster
		   (when (function-cluster function)
		     (setq cluster form)))
		 (ecase (function-implementation function)
		   (type-relation
		     (push function type-relation-list)
		     (push form type-relation-list))
		   (other-relation
		     (push function other-relation-list)
		     (push form other-relation-list))
		   (binary-relation
		     (push function binary-relation-list)
		     (push form binary-relation-list)))))
	  (dolist (atype ancestors)
	    (dolist (f (type-functions atype))
	      (when (forward-function-p f)
		(or (loop with function-keyword-name = (function-keyword-name f)
			  for (kwd val) on keywords-and-values by #'cddr do
		      (when (eq kwd function-keyword-name)
			(classify-init f val)
			(push kwd function-keywords)
			(let ((inverse-name (function-inverse-function-name f)))
			  (when (and inverse-name
				     (symbolp (function-value-type-name f))
				     (get (function-value-type-name f) 'entity-type))
			    (if (function-value-is-set f)
				(if (listp val)
				    (dolist (ent val)
				      (let ((ic (slot-value ent '%$inverse-cache)))
					(when ic
					  (setf (gethash
						  (function-inverse-cache-transaction-name f) ic)
						nil))))
				    (value-not-a-set))
				(when val
				  (let ((ic (slot-value val '%$inverse-cache)))
				    (when ic
				      (setf (gethash
					      (function-inverse-cache-transaction-name f) ic)
					    nil)))))))
			(return t)))
		    (let ((ifun (function-init-function f)))
		      (when ifun
			(classify-init f (funcall (get (function-full-name f) 'initform)))))
		    (when (function-cached f)
		      (push f cache-init-forms)))))))
	(setq flavor-list (nreverse flavor-list))
	(setq type-relation-list (nreverse type-relation-list))
	(setq other-relation-list (nreverse other-relation-list))
	(setq binary-relation-list (nreverse binary-relation-list))
	;; Any leftover keywords?
	(let ((leftovers (nset-difference
			   (nset-difference
			     (loop for (kwd) on keywords-and-values by #'cddr
				   collect kwd)
			     function-keywords)
			   flavor-keywords)))
	  (when leftovers
	    (error "These keywords are not known for type ~S: ~S" type-name leftovers)))
	(let-if (null *inside-with-cluster*)
		((*current-cluster* cluster))
	  (let* ((statice-model::*make-instance-arguments* flavor-list)
		 (st (functional-database-schema-table database))
		 (td (get type-name 'entity-type))
		 (ent
		   (maintaining-*current-cluster*
		     ;; Make the entity, and all the type-relation function values.
		     (apply #'make-clustered-entity-and-tuples
			    (or (gethash (type-domain-tag td) st)
				(no-entity-type-named type-name))
			    *current-cluster*
			    (loop for (fun val) on type-relation-list by #'cddr
				  as function = (get (function-full-name fun)
						     'statice-function)
				  collect (or (gethash (function-is-attribute-tag function) st)
					      (no-function-named
						(function-full-name function)))
				  collect val)))))
	    ;; set any unspecified cached values
	    (loop for f in cache-init-forms do
	      (setf (slot-value ent (function-cache-name f)) nil
		    (slot-value ent (function-cache-null-name f)) nil
		    (slot-value ent (function-cache-transaction-name f))
		     (when dbfs::*process-transaction* (dbfs:current-transaction-id))))
	    ;; cache any :cached attributes in the type-relation
	    (loop for (fun val) on type-relation-list by #'cddr
		  as function = (get (function-full-name fun) 'statice-function)
		  do
	      (when (function-cached function)
		(setf (slot-value ent (function-cache-name function)) val
		      (slot-value ent (function-cache-transaction-name function))
		       (and dbfs::*process-transaction* (dbfs:current-transaction-id))
		      (slot-value ent (function-cache-null-name function))
		       (or (not (null val))
			   (statice-model::%nil-is-valid-value
			     (or (gethash (function-is-attribute-tag function) st)
				 (no-function-named (function-full-name function))))))))
	    ;; we may have relations in the hierarchy that didn't have
	    ;; any values spec'd for their attributes.  Make sure that
	    ;; there is a tuple for those anyway.
	    (dolist (type (ancestors td))
	      (unless (do-relation (r (or (gethash (type-relation-tag type) st)
					  (no-entity-type-named (type-name type)))
				      (:where (gethash (type-soo-att-tag type) st) ent))
			(return r))
		(maintaining-*current-cluster*
		  (make-clustered-tuple (gethash (type-relation-tag type) st) *current-cluster*
					(gethash (type-soo-att-tag type) st)
					ent))))
	    ;; Make all the binary-relation function values.
	    (loop for (fun val) on binary-relation-list by #'cddr do
	      (let* ((fun-desc (get (function-full-name fun) 'statice-function))
		     (rel (or (gethash (function-relation-tag fun-desc) st)
			      (no-function-named (function-full-name fun))))
		     (of-att (or (gethash (function-of-attribute-tag fun-desc) st)
				 (no-function-named (function-full-name fun))))
		     (is-att (or (gethash (function-is-attribute-tag fun-desc) st)
				 (no-function-named (function-full-name fun)))))
		(cond ((function-value-is-set fun)
		       (unless (listp val)
			 (value-not-a-set))
		       (dolist (v val)
			 (maintaining-*current-cluster*
			   (make-clustered-tuple rel *current-cluster* of-att ent is-att v))))
		      (t
		       (maintaining-*current-cluster*
			 (make-clustered-tuple rel *current-cluster* of-att ent is-att val))))
		(when (function-cached fun-desc)
		  (setf (slot-value ent (function-cache-name fun-desc)) val
			(slot-value ent (function-cache-transaction-name fun-desc))
			 (when dbfs::*process-transaction* (dbfs:current-transaction-id))
			(slot-value ent (function-cache-null-name fun-desc))
			 (or (not (null val))
			     (statice-model::%nil-is-valid-value is-att))))))
	    ;; Make all the other-relation function values.
	    (loop for (fun val) on other-relation-list by #'cddr do
	      (let* ((vtype-var (get (function-value-type-name fun) 'entity-type))
		     (fun-desc (get (function-full-name fun) 'statice-function))
		     (of-att-var (or (gethash (function-of-attribute-tag fun-desc) st)
				     (no-entity-type-named (function-value-type-name fun)))))
		(unless (listp val)
		  (value-not-a-set))
		(dolist (v val)
		  (do-relation (tuple-var
				 (gethash (type-relation-tag vtype-var) st)
				 (:where (or (gethash (type-soo-att-tag vtype-var) st)
					     (no-entity-type-named
					       (function-value-type-name fun)))
				  v))
		    (set-value tuple-var of-att-var ent)
		    (return nil))
		  (when (function-cached fun-desc)
		    (setf (slot-value ent (function-cache-name fun-desc)) val
			  (slot-value ent (function-cache-transaction-name fun-desc))
			   (when dbfs::*process-transaction* (dbfs:current-transaction-id))
			  (slot-value ent (function-cache-null-name fun-desc))
			   (or (not (null val))
			       (statice-model::%nil-is-valid-value of-att-var)))))))
	    ;; Finally, return the entity handle.
	    ent))))))

;;; NOTE: Still have to support special :database keyword.

;;; type-name is a symbol, the name of a type.  keywords-and-value-forms
;;; Is a list of keywords and forms.  This function returns a form
;;; which, when evaluated, evaluates all of the forms, and creates and
;;; returns an entity of the given type, using the values of the forms
;;; for initialization.  NOTE: This probably does not guarantee to
;;; evaluate the forms in order.  Is this a problem?  Also, you have to
;;; provide actual keywords, NOT forms that evaluate to keywords as in a
;;; regular function.  The user has to know that this is a macro. 
(defun make-functional-entity-maker (type-name keywords-and-value-forms)
  (check-type type-name symbol)
  (loop for (kwd nil) on keywords-and-value-forms by #'cddr do
    (unless (keywordp kwd) (error "~S is not a keyword" kwd)))
  (let ((type (get type-name 'entity-type)))
    (unless type
      (error "There is no defined type named ~S" type-name))
    (let ((ancestors (ancestors type))
	  (function-keywords nil)
	  (flavor-keywords (get-type-maker-keywords type-name t))
	  (flavor-list nil)
	  (type-relation-list nil)
	  (other-relation-list nil)
	  (binary-relation-list nil)
	  (cache-init-forms nil)
	  (inverse-cache-init-forms nil)
	  (cluster (not (null (type-own-cluster type)))))
      ;; First find all the flavor keywords, each of which either
      ;; signifies an instance variable or is an init keyword.
      (loop for (kwd val) on keywords-and-value-forms by #'cddr do
	(when (member kwd flavor-keywords)
	  (push kwd flavor-list)
	  (push val flavor-list)))
      ;; Next go over all the functions, finding specified or default
      ;; initialization forms, and partition them into three lists.
      (flet ((classify-init (function form)
	       (unless cluster
		 (when (function-cluster function)
		   (setq cluster function)))
	       (ecase (function-implementation function)
		 (type-relation
		   (push function type-relation-list)
		   (push form type-relation-list))
		 (other-relation
		   (push function other-relation-list)
		   (push form other-relation-list))
		 (binary-relation
		   (push function binary-relation-list)
		   (push form binary-relation-list)))))
	(dolist (atype ancestors)
	  (dolist (f (type-functions atype))
	    (when (forward-function-p f)
	      (or (loop with function-keyword-name = (function-keyword-name f)
			for (kwd val) on keywords-and-value-forms by #'cddr do
		    (when (eq kwd function-keyword-name)
		      (classify-init f val)
		      (push kwd function-keywords)
		      (let ((inverse-name (function-inverse-function-name f)))
			(when (and inverse-name
				   (symbolp (function-value-type-name f))
				   (get (function-value-type-name f) 'entity-type))
			  (cond ((function-value-is-set f)
				 (push
				   `(dolist (ent ,val)
				      (let ((ic (slot-value ent '%$inverse-cache)))
					(when ic
					  (setf (gethash
						  ',(function-inverse-cache-transaction-name f)
						  (slot-value ent '%$inverse-cache))
						nil))))
				   inverse-cache-init-forms))
				(t
				 (push `(when ,val
					  (let ((ic (slot-value ,val '%$inverse-cache)))
					    (when ic
					      (setf
						(gethash
						  ',(function-inverse-cache-transaction-name f)
						  (slot-value ,val '%$inverse-cache))
						nil))))
				       inverse-cache-init-forms)))))
		      (return t)))
		  (let ((ifun (function-init-function f)))
		    (when ifun
		      (classify-init f `(funcall (get ',(function-full-name f) 'initform)))))
		  (when (function-cached f)
		    (push (list (function-cache-name f)
				(function-cache-null-name f)
				(function-cache-transaction-name f))
			  cache-init-forms)))))))
      (setq flavor-list (nreverse flavor-list))
      (setq type-relation-list (nreverse type-relation-list))
      (setq other-relation-list (nreverse other-relation-list))
      (setq binary-relation-list (nreverse binary-relation-list))
      ;; Any leftover keywords?
      (let ((leftovers (nset-difference
			 (nset-difference
			   (loop for (kwd) on keywords-and-value-forms by #'cddr
				 collect kwd)
			   function-keywords)
			 flavor-keywords)))
	(when leftovers
	  (error "These keywords are not known for type ~S: ~S" type-name leftovers)))
      ;; Now generate code
      (let* ((st-var (gentemp "ST"))
	     (ent-var (gentemp "ENT"))
	     (td-var (gentemp "TD"))
	     (tuple-var (gentemp "TUPLE"))
	     (iter-var (gentemp "ITER"))
	     (of-att-var (gentemp "OF-ATT"))
	     (fun-var (gentemp "FUN"))
	     (vtype-var (gentemp "VTYPE"))
	     (basic-form
	       ;; Extract the schema-table from the database instance.
	       `(let-if (null *inside-with-cluster*)
			((*current-cluster*
			   ,(or (eq cluster t)
				(and (typep cluster 'basic-forward-function)
				     (getf keywords-and-value-forms
					   (function-keyword-name cluster))))))
		  (let* ((,st-var (functional-database-schema-table database))
			 (,td-var (get ',type-name 'entity-type))
			 (,ent-var
			  ;; Make the entity, and all the type-relation function values.
			  (maintaining-*current-cluster*
			    (make-clustered-entity-and-tuples
			      (or (gethash (type-domain-tag ,td-var) ,st-var)
				  (no-entity-type-named ',type-name))
			      *current-cluster*
			      . ,(loop for (fun val) on type-relation-list by #'cddr
				       collect `(or (gethash (function-is-attribute-tag
							       (get ',(function-full-name fun)
								    'statice-function))
							     ,st-var)
						    (no-function-named
						      ',(function-full-name fun)))
				       collect val)))))
		    ,@inverse-cache-init-forms
		    ,@(loop for (name null-name transaction-name) in cache-init-forms
			    collect
			      `(setf (slot-value ,ent-var ',name) nil
				     (slot-value ,ent-var ',null-name) nil
				     (slot-value ,ent-var ',transaction-name)
				     (and dbfs::*process-transaction*
					  (dbfs:current-transaction-id))))
		    ,@(loop for (fun val) on type-relation-list by #'cddr
			    collect
			      (when (function-cached fun)
				`(setf (slot-value ,ent-var ',(function-cache-name fun)) ,val
				       (slot-value ,ent-var ',(function-cache-transaction-name fun))
				        (when dbfs::*process-transaction* (dbfs:current-transaction-id))
				       (slot-value ,ent-var ',(function-cache-null-name fun))
				        (or (not (null ,val))
					    (statice-model::%nil-is-valid-value
					      (or (gethash ',(function-is-attribute-tag
							       (get (function-full-name fun)
								    'statice-function))
							   ,st-var)
						  (no-function-named
						    ',(function-full-name fun))))))))
		    ;; we may have relations in the hierarchy that didn't have
		    ;; any values spec'd for their attributes.  Make sure that
		    ;; there is a tuple for those anyway.
		    (dolist (type (ancestors ,td-var))
		      (unless (do-relation (r (or (gethash (type-relation-tag type) ,st-var)
						  (no-entity-type-named (type-name type)))
					      (:where
						(gethash (type-soo-att-tag type)
							 ,st-var)
						,ent-var))
				(return r))
			(maintaining-*current-cluster*
			  (make-clustered-tuple (gethash (type-relation-tag type) ,st-var)
						*current-cluster*
						(gethash (type-soo-att-tag type) ,st-var)
						,ent-var))))
		    ;; Make all the binary-relation function values.
		    ,@(loop for (fun val) on binary-relation-list by #'cddr
			    collect
			      (flet
				((make-one (is-form)
				   `(maintaining-*current-cluster*
				      (make-clustered-tuple
					(or (gethash (function-relation-tag ,fun-var) ,st-var)
					    (no-function-named (function-full-name ,fun-var)))
					*current-cluster*
					(gethash (function-of-attribute-tag ,fun-var) ,st-var)
					,ent-var
					(gethash (function-is-attribute-tag ,fun-var) ,st-var)
					,is-form))))
				`(let ((,fun-var (get ',(function-full-name fun)
						      'statice-function)))
				   ,(if (function-value-is-set fun)
					`(progn
					   (unless (listp ,val)
					     (value-not-a-set))
					   (dolist (,iter-var ,val)
					     ,(make-one iter-var)))
					(make-one val))
				   (when (function-cached ,fun-var)
				     (setf (slot-value ,ent-var (function-cache-name ,fun-var)) ,val
					   (slot-value ,ent-var (function-cache-transaction-name ,fun-var))
					    (when dbfs::*process-transaction* (dbfs:current-transaction-id))
					   (slot-value ,ent-var (function-cache-null-name ,fun-var))
					    (or (not (null ,val))
						(statice-model::%nil-is-valid-value
						  (gethash (function-is-attribute-tag ,fun-var)
							   ,st-var))))))))
		    ;; Make all the other-relation function values.
		    ,@(loop for (fun val) on other-relation-list by #'cddr
			    collect
			      `(let* ((,vtype-var (get ',(function-value-type-name fun) 'entity-type))
				      (,fun-var (get ',(function-full-name fun) 'statice-function))
				      (,of-att-var
				       (or (gethash (function-of-attribute-tag ,fun-var)
						    ,st-var)
					   (no-function-named
					     (function-full-name ,fun-var)))))
				 (unless (listp ,val)
				   (value-not-a-set))
				 (dolist (,iter-var ,val)
				   (do-relation (,tuple-var 
						 (or (gethash (type-relation-tag ,vtype-var)
							      ,st-var)
						     (no-entity-type-named
						       (type-name ,vtype-var)))
						 (:where
						   (gethash (type-soo-att-tag ,vtype-var)
							    ,st-var)
						   ,iter-var))
				     (set-value ,tuple-var ,of-att-var ,ent-var)
				     (return nil)))
				 (when (function-cached ,fun-var)
				   (setf (slot-value ,ent-var (function-cache-name ,fun-var))
					  ,val
					 (slot-value ,ent-var (function-cache-transaction-name ,fun-var))
					  (and dbfs::*process-transaction* (dbfs:current-transaction-id))
					 (slot-value ,ent-var (function-cache-null-name ,fun-var))
					  (or (not (null ,val))
					      (statice-model::%nil-is-valid-value ,of-att-var))))))
		    ;; Finally, return the entity handle.
		    ,ent-var))))
	  ;; Now we have the basic-form.  If there is anything on flavor-list,
	  ;; wrap it with a let to bind *make-instance-arguments*.
	  (cond ((null flavor-list)
		 `(inside-function-level (database)
		    ,basic-form))
		(t
		 `(with-stack-list (statice-model::*make-instance-arguments* . ,flavor-list)
		    (inside-function-level (database)
		      ,basic-form))))))))

;;; The default string creator for do-text-lines and do-text-lines*.
(defun default-string-create-function (length thin-p)
  (cl:make-string length :element-type (if thin-p 'cl:string-char 'character)))

(defmacro do-text-lines ((var string-valued-function-call
			      &key
			      (delimiter '#\Return)
			      (create-function '#'default-string-create-function))
			 &body body)
  (let ((stvar (gentemp "st")))
    (multiple-value-bind (fun entity-handle-form)
	(get-set-args string-valued-function-call
		      :if-read-only nil
		      :if-single-valued nil
		      :if-set-valued :error)
      `(inside-function-level (database)
	 (let ((fun (get ',(function-full-name fun) 'statice-function))
	       (,stvar (functional-database-schema-table database)))
	   (do-relation (r (or (cl:gethash (function-relation-tag fun) ,stvar)
			       (no-function-named ',(function-full-name fun)))
			   (:where (cl:gethash (function-of-attribute-tag fun) ,stvar)
			    ,entity-handle-form))
	     (statice-model:do-text-lines (,var r (cl:gethash (function-is-attribute-tag fun)
							   ,stvar)
					   :delimiter ,delimiter
					   :create-function ,create-function)
	       . ,body)))))))

(defun do-text-lines* (function entity-handle attribute
		       &key
		       (delimiter '#\Return)
		       (create-function #'default-string-create-function))
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (cl:error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (when (function-value-is-set attribute)
    (cl:error "It is not meaningful to call do-text-lines* on a set valued attribute"))
  (inside-function-level (database)
    (let* ((schema-table (functional-database-schema-table database))
	   (is-att (or (cl:gethash (function-is-attribute-tag attribute) schema-table)
		       (no-function-named (function-full-name attribute)))))
      (do-relation (r (cl:gethash (function-relation-tag attribute) schema-table)
		      (:where (cl:gethash (function-of-attribute-tag attribute) schema-table)
		       entity-handle))
	(statice-model::map-over-text-lines-internal
	  r is-att function create-function delimiter)))))

(defun attribute-value-length (entity-handle attribute)
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (cl:error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (when (function-value-is-set attribute)
    (cl:error "It is not meaningful to call attribute-value-length on a set valued attribute"))
  (inside-function-level (database)
    (let* ((schema-table (functional-database-schema-table database))
	   (is-att (or (gethash (function-is-attribute-tag attribute) schema-table)
		       (no-function-named (function-full-name attribute)))))
      (do-relation (r (gethash (function-relation-tag attribute) schema-table)
		      (:where (cl:gethash (function-of-attribute-tag attribute) schema-table)
		       entity-handle))
	(return (get-array-length r is-att))))))

(defun inverse-attribute-value (entity-type attribute value &key (exact t))
  ;; I don't know if this is too slow or not, but until someone
  ;; meters it, I'm leaving it like this.
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute entity-type)))
  (check-type attribute basic-forward-function)
  (check-type entity-type symbol)
  (let ((unique-p (function-unique attribute))
	(results nil))
    (for-each* #'(cl:lambda (entity-handle)
		   (if unique-p
		       (return-from inverse-attribute-value entity-handle)
		       (push entity-handle results)))
	       entity-type
	       ;; this could be slightly faster if for-each* would take attributes
	       ;; instead of just attribute names
	       :where `((,(function-full-name attribute) ,(if exact 'equal 'string-equal)
			 ,value)))
    results))

;;; function is a function of one arg (the entity-handle)
;;; entity-type is a symbol naming the entity type
;;; :where is a list of ((fcn-symbol operator value)) or
;;;                     (and (fcn-symbol operator value) (fcn-symbol operator value) (...)) or
;;;                     (nil typep type)
;;; :order-by is a list of (fcn dir fcn dir ...)
;;; :count is a form which specifies the limit on the number of entities to be iterated over
;;; database is a database
(defun for-each* (function entity-type
		  &key where order-by count (database (current-database)))
  (declare (sys:downward-funarg function))
  (check-type entity-type symbol)
  (for-each-internal #'(lambda (is-att relation-handle &key where order-by count)
			 (map-relation-dynamic
			   #'(lambda (tuple-handle)
			       (let ((entity-handle (get-value tuple-handle is-att)))
				 (funcall function entity-handle)))
			   relation-handle
			   :where where :order-by order-by :count count))
		     entity-type
		     :where where :order-by order-by :count count :database database))

(defun count-entities* (entity-type &key where (database (current-database)))
  (check-type entity-type symbol)
  (for-each-internal #'(lambda (is-att relation-handle &key where order-by count)
			 (declare (ignore is-att order-by count))
			 (count-relation-dynamic relation-handle :where where))
		     entity-type
		     :where where :database database))

(defun for-each-internal (function entity-type
			  &key
			  where order-by count (database (current-database)))
  (declare (sys:downward-funarg function))
  (inside-function-level (db database)
    (let ((map-over-type (or (get entity-type 'entity-type)
			     (no-entity-type-named entity-type)))
	  (st (functional-database-schema-table db)))
      (multiple-value-bind (where-clauses where-ffr)
	  (when where
	    (process-dynamic-where-clauses entity-type where st database))
	(multiple-value-bind (order-by-clauses order-by-ffr)
	    (process-dynamic-order-by-clauses entity-type order-by st)
	  (let* ((fun-for-rel
		   (cond ((and where-ffr order-by-ffr)
			  ;; both where and order-by specified
			  (unless (eq (function-relation-tag where-ffr)
				      (function-relation-tag order-by-ffr))
			    (error "The :WHERE and :ORDER-BY clauses are ~@
                                    from two relations"))
			  where-ffr)
			 (where-ffr)
			 (order-by-ffr)))
		 (relation-handle (if fun-for-rel
				      (or (gethash (function-relation-tag fun-for-rel) st)
					  (no-function-named
					    (function-full-name fun-for-rel)))
				      (or (gethash (type-relation-tag map-over-type) st)
					  (no-entity-type-named (type-name map-over-type)))))
		 (is-att (gethash (if fun-for-rel
				      (function-of-attribute-tag fun-for-rel)
				      (type-soo-att-tag map-over-type))
				  st)))
	    (when (and fun-for-rel
		       (loop for (nil spec) on where-clauses by #'cddr
			     never (and (listp spec)
					(eq (first spec) 'domain)))
		       (not (eql (function-argument-type-name fun-for-rel) entity-type)))
	      (push (list 'domain (cl:gethash (type-domain-tag map-over-type) st))
		    where-clauses)
	      (push (gethash (function-of-attribute-tag fun-for-rel) st) where-clauses))
	    (funcall function is-att relation-handle
		     :where where-clauses :order-by order-by-clauses :count count)))))))

(defun process-dynamic-where-clauses (type where-clauses st database)
  (declare (values where-clauses where-fun-for-rel))
  (let ((ffr nil))
    ;; where-clauses should be (sym x x) or (and (sym x x) (sym x x) ...)
    ;; for compatibility with earlier versions, we also allow the forms
    ;; ((sym x x)) and (:and (sym x x) (sym x x) ...)
    ;; Canonicalize it to ((sym x x) (sym x x) ...).
    (let ((fw (first where-clauses)))
      (setq where-clauses
	    (cond ((member fw '(and :and)) (rest where-clauses))
		  ((symbolp fw) (list where-clauses))
		  (t where-clauses))))
    (unless (listp (first where-clauses))
      (error "for-each-dynamic should be a list of lists."))
    (loop for (fcn-symbol operator value) in where-clauses
	  with result = nil do
      (cond (fcn-symbol
	     (let ((function (get-attribute-definition fcn-symbol type)))
	       (unless function
		 (error "~S is not a valid function name for type ~S" fcn-symbol type))
	       (cond ((null ffr)
		      (setq ffr function))
		     ((and ffr (not (eq (function-relation-tag function)
					(function-relation-tag ffr))))
		      (error "Clause ~S specifies a different relation
                                than did previous clauses."
			     (list fcn-symbol operator value))))
	       (push (list operator value) result)
	       (push (or (gethash (function-is-attribute-tag function) st)
			 (no-function-named (function-full-name function)))
			 result)))
	    (t
	     ;; a typep
	     (unless (eq operator 'typep)
	       (error "~S is not a valid operator" operator))
	     (unless (symbolp value)
	       (error "The argument to the typep criterion, ~S was not a symbol" value))
	     (let ((function (or (and ffr (function-of-attribute-tag ffr))
				 (type-soo-att-tag type))))
	       (push (list 'domain (get-domain (string value) :database database)) result)
	       (push (or (gethash function st)
			 (if (and ffr (function-of-attribute-tag ffr))
			     (no-function-named (function-full-name ffr))
			     (no-entity-type-named type))) result))))
	  finally
	    (return (values result ffr)))))

(defun process-dynamic-order-by-clauses (type order-by-clauses st)
  (declare (values order-by-clauses order-by-fun-for-rel))
  (let ((ffr nil))
    (values (loop for (fcn-symbol direction) on order-by-clauses by #'cddr
		  with result = nil do
	      (let ((function (get-attribute-definition fcn-symbol type)))
		(unless function
		  (error "~S is not a valid function name for type ~S" fcn-symbol type))
		(cond ((null ffr)
		       (setq ffr function))
		      ((and ffr (not (eq (function-relation-tag function)
					 (function-relation-tag ffr))))
		       (error "Clause ~S specifies a different relation
                                than did previous clauses."
			      (list fcn-symbol direction))))
		(push (list (or (gethash (function-is-attribute-tag function) st)
				(no-function-named (function-full-name function)))
			    (ecase direction (ascending :ascending) (descending :descending)))
		      result))
		  finally (return result))
	    ffr)))

;;; Utility function.  Make sure set-valued-function-call is what it claims
;;; to be.  Return a forward-function and the argument form.
(defun get-set-args (set-valued-function-call
		     &key
		     (if-read-only :error)
		     if-set-valued
		     (if-single-valued :error))
  (declare (values forward-function argument-form))
  (unless (and (listp set-valued-function-call)
	       (= (length set-valued-function-call) 2))
    (error "~S is not a properly formed function call form" set-valued-function-call))
  (destructuring-bind (fname arg-form) set-valued-function-call
    (unless (symbolp fname)
      (error "~S is not a symbol in ~S" fname set-valued-function-call))
    (let ((fun (or (get fname 'statice-function)
		   (no-function-named fname))))
      (if (function-value-is-set fun)
	  (when (eq if-set-valued :error)
	    (error "~S is a set-valued function" fname))
	  (when (eq if-single-valued :error)
	    (error "~S is not a set-valued function" fname)))
      (when (function-read-only fun)
	(when (eq if-read-only :error)
	  (error "~S is a read-only function" fname)))
      (values fun arg-form))))

(defmacro add-to-set (set-valued-function-call value)
  (multiple-value-bind (fun arg-form)
      (get-set-args set-valued-function-call)
    (let ((stvar (gentemp "ST"))
	  (entvar (gentemp "ENT"))
	  (valvar (gentemp "VAL")))
      `(inside-function-level ()
	 (let* ((,entvar ,arg-form)
		(,valvar ,value)
		(,stvar (functional-entity-handle-schema-table ,entvar)))
	   ,(ecase (function-implementation fun)
	      (binary-relation
		`(maintaining-*current-cluster*
		   (make-clustered-tuple
		     (or (gethash ',(function-relation-tag fun) ,stvar)
			 (no-entity-type-named ',(function-argument-type-name fun)))
		     *current-cluster*
		     (gethash ',(function-of-attribute-tag fun) ,stvar)
		     ,entvar
		     (or (gethash ',(function-is-attribute-tag fun) ,stvar)
			 (no-function-named ',(function-full-name fun)))
		     ,valvar)))
	      (other-relation
		`(let ((of-att (or (gethash ',(function-of-attribute-tag fun) ,stvar)
				   (no-function-named ',(function-full-name fun)))))
		   (unless (statice-model::%get-value-null-p-from-entity
			     ,valvar of-att)
		     (other-relation-uniqueness-error
		       ',(function-full-name fun) ,valvar ,entvar))
		   (statice-model::%set-value-from-entity
		     ,valvar of-att ,entvar))))
	   (attribute-changed ,entvar ',(function-full-name fun))
	   ;; It might be better to just push the new value into the cache here,
	   ;; but that would mean that we'd have to cons up all sorts of code
	   ;; to check if the cache var was bound yet.  If it's an inverse that
	   ;; we're adding to here, then it's even worse since the hash table
	   ;; creation is deferred.
	   ,@(when (function-cached fun)
	       (etypecase fun
		 (template-forward-function
		   `((setf (slot-value ,entvar ',(function-cache-transaction-name fun))
			   nil)			;skew transactions to force recache
		     (,(function-full-name fun) ,entvar :force-refresh t)))
		 (template-inverse-function
		   `((let ((cache (slot-value ,entvar '%$inverse-cache)))
		       (when cache
			 (setf (gethash ',(function-cache-transaction-name fun) cache) nil)))
		     (,(function-full-name fun) ,entvar :force-refresh t)))))
	   ,@(when (function-inverse-cache-transaction-name fun)
	       (etypecase fun
		 (template-forward-function
		   `((let ((cache (slot-value ,valvar '%$inverse-cache)))
		       (when cache
			 (setf (gethash ',(function-inverse-cache-transaction-name fun)
					cache)
			   nil)))
		     (,(function-inverse-function-name fun) ,valvar :force-refresh t)))
		 (template-inverse-function
		   `((setf (slot-value ,valvar ',(function-inverse-cache-transaction-name fun))
			   nil)
		     (,(function-inverse-function-name fun) ,valvar :force-refresh t))))))))))

;;; Dynamic version of above
(defun add-to-set* (entity-handle attribute value)
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (inside-function-level ()
    (let ((schema-table (functional-entity-handle-schema-table entity-handle)))
      (ecase (function-implementation attribute)
	(binary-relation
	  (maintaining-*current-cluster*
	    (make-clustered-tuple
	      (or (gethash (function-relation-tag attribute) schema-table)
		  (no-entity-type-named (function-argument-type-name attribute)))
	      *current-cluster*
	      (gethash (function-of-attribute-tag attribute) schema-table)
	      entity-handle
	      (or (gethash (function-is-attribute-tag attribute) schema-table)
		  (no-function-named (function-full-name attribute)))
	      value)))
	(other-relation
	  (let ((of-att (or (gethash (function-of-attribute-tag attribute) schema-table)
			    (no-function-named (function-full-name attribute)))))
	    (unless (statice-model::%get-value-null-p-from-entity value of-att)
	      (other-relation-uniqueness-error
		(function-full-name attribute) value entity-handle))
	    (statice-model::%set-value-from-entity value of-att entity-handle))))
      (attribute-changed entity-handle attribute)
      ;; It might be better to just push the new value into the cache here,
      ;; but that would mean that we'd have to cons up all sorts of code
      ;; to check if the cache var was bound yet.  If it's an inverse that
      ;; we're adding to here, then it's even worse since the hash table
      ;; creation is deferred.
      (when (function-cache-name attribute)
	(etypecase attribute
	  (template-forward-function
	    (setf (slot-value entity-handle (function-cache-transaction-name attribute))
		  nil))
	  (template-inverse-function
	    (let ((cache (slot-value entity-handle '%$inverse-cache)))
	      (when cache
		(setf (gethash (function-cache-transaction-name attribute) cache) nil)))))
	(attribute-value entity-handle attribute :force-refresh t))
      (when (function-inverse-cache-transaction-name attribute)
	(etypecase attribute
	  (template-forward-function
	    (let ((cache (slot-value value '%$inverse-cache)))
	      (when cache
	    (setf (gethash (function-inverse-cache-transaction-name attribute) cache) nil))))
	  (template-inverse-function
	    (setf (slot-value
		    value (function-inverse-cache-transaction-name attribute))
		  nil)))
	(attribute-value entity-handle attribute :force-refresh t)))))

(scl:defflavor entity-not-found-in-set
	(entity-handle
	 set-of-entities)
	(function-error)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report entity-not-found-in-set) (stream)
  (format stream "The value ~S was not found in the set ~S"
	  entity-handle set-of-entities))

(defmacro delete-from-set (set-valued-function-call value)
  (multiple-value-bind (fun arg-form)
      (get-set-args set-valued-function-call)
    (let ((stvar (gentemp "ST"))
	  (entvar (gentemp "ENT"))
	  (valvar (gentemp "VAL"))
	  (tuplevar (gentemp "TUPLE")))
      `(inside-function-level ()
	 (let* ((,entvar ,arg-form)
		(,valvar ,value)
		(,stvar (functional-entity-handle-schema-table ,entvar)))
	   ,(ecase (function-implementation fun)
	      (binary-relation
		`(or (do-relation
		       (,tuplevar (or (gethash ',(function-relation-tag fun) ,stvar)
				      (no-entity-type-named
					',(function-argument-type-name fun)))
			(:where (:and (gethash ',(function-of-attribute-tag fun)
					       ,stvar)
				 ,entvar
				 (or (gethash ',(function-is-attribute-tag fun) ,stvar)
				     (no-function-named ',(function-full-name fun)))
				 ,valvar)))
		       (delete-tuple ,tuplevar)
		       (return t))
		     (error 'entity-not-found-in-set
			    :entity-handle ,valvar
			    :set-of-entities ,set-valued-function-call)))
	      (other-relation
		`(progn
		   ,entvar			;Must use it to prevent warning.
		   (statice-model::%set-to-null-value-from-entity
		     ,valvar
		     (or (gethash ',(function-of-attribute-tag fun) ,stvar)
			 (no-function-named ',(function-full-name fun)))))))
	   (attribute-changed ,entvar ',(function-full-name fun))
	   ,@(when (function-cached fun)
	       (etypecase fun
		 (template-forward-function
		   `((setf (slot-value ,entvar ',(function-cache-transaction-name fun))
			   nil)			;skew transactions to force recache
		     (,(function-full-name fun) ,entvar :force-refresh t)))
		 (template-inverse-function
		   `((let ((cache (slot-value ,entvar '%$inverse-cache)))
		       (when cache
			 (setf (gethash ',(function-cache-transaction-name fun) cache) nil)))
		     (,(function-full-name fun) ,entvar :force-refresh t)))))
	   ,@(when (function-inverse-cache-transaction-name fun)
	       (etypecase fun
		 (template-forward-function
		   `((let ((cache (slot-value ,valvar '%$inverse-cache)))
		       (when cache
			 (setf (gethash ',(function-inverse-cache-transaction-name fun)
					cache)
			       nil)))
		     (,(function-inverse-function-name fun) ,valvar :force-refresh t)))
		 (template-inverse-function
		   `((setf (slot-value ,valvar ',(function-inverse-cache-transaction-name fun))
			   nil)
		     (,(function-inverse-function-name fun) ,valvar :force-refresh t))))))))))

;;; dynamic version of above
(defun delete-from-set* (entity-handle attribute value)
  (when (symbolp attribute)
    (setq attribute (get-attribute-definition attribute (type-of entity-handle))))
  (check-type attribute basic-forward-function)
  (unless (typep entity-handle (function-argument-type-name attribute))
    (error 'wrong-type-entity
	   :entity-handle entity-handle
	   :expected-type (function-argument-type-name attribute)))
  (inside-function-level ()
    (let ((schema-table (functional-entity-handle-schema-table entity-handle)))
      (ecase (function-implementation attribute)
	(binary-relation
	  (or (do-relation
		(r (or (gethash (function-relation-tag attribute) schema-table)
		       (no-entity-type-named (function-argument-type-name attribute)))
		   (:where
		     (:and
		       (gethash (function-of-attribute-tag attribute) schema-table)
		       entity-handle
		       (or (gethash (function-is-attribute-tag attribute) schema-table)
			   (no-function-named (function-full-name attribute)))
		       value)))
		(delete-tuple r)
		(return t))
	      (error 'entity-not-found-in-set
		     :entity-handle value
		     :set-of-entities (list (function-full-name attribute) entity-handle))))
	(other-relation
	  (statice-model::%set-to-null-value-from-entity
	    value
	    (or (gethash (function-of-attribute-tag attribute) schema-table)
		(no-function-named (function-full-name attribute))))))
      (attribute-changed entity-handle attribute)
      (when (function-cache-name attribute)
	(etypecase attribute
	  (template-forward-function
	    (setf (slot-value entity-handle (function-cache-transaction-name attribute))
		  nil))
	  (template-inverse-function
	    (let ((cache (slot-value entity-handle '%$inverse-cache)))
	      (when cache
		(setf (gethash (function-cache-transaction-name attribute) cache) nil)))))
	(attribute-value entity-handle attribute :force-refresh t))
      (when (function-inverse-cache-transaction-name attribute)
	(etypecase attribute
	  (template-forward-function
	    (let ((cache (slot-value value '%$inverse-cache)))
	      (when cache
		(setf (gethash (function-inverse-cache-transaction-name attribute)
			       cache)
		      nil))))
	  (template-inverse-function
	    (setf (slot-value value (function-inverse-cache-transaction-name attribute))
		  nil)))
	(attribute-value entity-handle attribute :force-refresh t)))))

(defun set-attribute-value-to-null (entity-handle attribute)
  (check-type attribute symbol)
  (let ((fun (or (get attribute 'statice-function)
		 (no-function-named attribute))))
    (unless (forward-function-p fun)
      (error "~S is an inverse function; it cannot be set to the null value" attribute))
    (when (function-value-is-set fun)
      (error "~S is a set-valued function; it cannot be set to the null value" attribute))
    (when (function-no-nulls fun)
      (error "~S is a no-nulls function; it cannot be set to the null value" attribute))
    (when (function-read-only fun)
      (error "The function ~S is :READ-ONLY" fun))
    (inside-function-level (database)
      (let* ((st (functional-database-schema-table database))
	     (rel (or (gethash (function-relation-tag fun) st)
		      (no-entity-type-named (function-argument-type-name fun))))
	     (of-att (gethash (function-of-attribute-tag fun) st))
	     (is-att (or (gethash (function-is-attribute-tag fun) st)
			 (no-function-named (function-full-name fun)))))
	(do-relation (r rel (:where of-att entity-handle))
	  (set-to-null-value r is-att))))
    (when (function-cached fun)
      (setf (slot-value entity-handle (function-cache-name fun)) nil
	    (slot-value entity-handle (function-cache-transaction-name fun))
	     (and dbfs::*process-transaction* (dbfs:current-transaction-id))
	    (slot-value entity-handle (function-cache-null-name fun)) nil))
    (attribute-changed entity-handle attribute)
    t))

;;; making and deleting indexes
(defun get-function-for-index-operation (function-name must-be-single)
  (check-type function-name symbol)
  (let ((fun (get function-name 'statice-function)))
    (unless fun (no-function-named function-name))
    (unless (forward-function-p fun)
      (error "~S is an inverse function;~@
              index operations can only be done on forward functions" function-name))
    (when must-be-single
      (unless (function-value-is-set fun)
	(unless (eq (function-implementation fun) 'binary-relation)   ; area used for this one
	(error "It is not meaningful to make an index for ~S, a single-valued function"
	       function-name))))
    fun))

(defun make-index (function-name &key index-average-size)
  (inside-function-level (database)
    (let* ((fun (get-function-for-index-operation function-name t))
	   (att (or (gethash (function-of-attribute-tag fun)
			     (functional-database-schema-table database))
		    (no-function-named function-name))))
      (unless att (no-function-named function-name))
      (cond (index-average-size
	     (make-group-index att :average-size index-average-size))
	    (t
	     (make-group-index att))))))

(defun delete-index (function-name)
  (inside-function-level (database) 
    (let ((fun (get-function-for-index-operation function-name t)))
      (delete-group-index
	(or (gethash (function-of-attribute-tag fun)
		     (functional-database-schema-table database))
	    (no-function-named function-name))))))

(defun index-exists (function-name)
  (inside-function-level (database)
    (let* ((fun (get-function-for-index-operation function-name t))
	   (att (or (cl:gethash (function-of-attribute-tag fun)
			     (functional-database-schema-table database))
		    (no-function-named function-name)))
	   (attribute-rel (get-relation "%%attribute"))
	   (attribute-is (get-attribute attribute-rel "is"))
	   (attribute-group-indexed (get-attribute attribute-rel "group-indexed")))
      (do-attribute (value not-null-p attribute-group-indexed (:where attribute-is att))
	(return (values value not-null-p))))))

(defun make-inverse-index (function-name &key inverse-index-average-size
			   (unique nil unique-arg-supplied-p) exact silent)
  (inside-function-level (database)
    (let* ((fun (get-function-for-index-operation function-name nil))
	   (schema-unique-p (attribute-unique fun))
	   (att (or (cl:gethash
		      (cl:ecase (function-implementation fun)
			(other-relation
			  (cl:error "It is not meaningful to make an inverse index for ~S,~@
                                  an entity-valued set-valued unique function" function-name))
			((type-relation binary-relation)
			 (function-is-attribute-tag fun)))
			     (functional-database-schema-table database))
		    (no-function-named function-name)))
	   (type-name (function-value-type-name fun)))
      (cond (unique-arg-supplied-p
	     (unless (or silent (eq unique schema-unique-p))
	       (cl:warn "Creating a ~:[non-unique~;unique~] index for a ~:[non-unique~;unique~] ~
 		      function, which is incompatible.  Unpredictable results may occur."
		     unique schema-unique-p)))
	    (t
	     (setf unique schema-unique-p)))
      (when exact
	(check-use-of-exact type-name "specify :exact" function-name))
      (cond ((not (subtypep type-name 'functional-entity-handle))
	     (statice-model:make-index (list att)
				       :unique-p unique
				       :case-sensitive exact))
	    (inverse-index-average-size
	     (make-group-index att :average-size inverse-index-average-size))
	    (t
	     (make-group-index att))))))

(defun delete-inverse-index (function-name &key exact)
  (inside-function-level (database)
    (let* ((fun (get-function-for-index-operation function-name nil))
	   (att (or (cl:gethash
		      (cl:ecase (function-implementation fun)
			(other-relation
			  (cl:error "It is not meaningful to have an inverse index for ~S,~@
                                  an entity-valued set-valued unique function" function-name))
			((type-relation binary-relation)
			 (function-is-attribute-tag fun)))
			     (functional-database-schema-table database))
		    (no-function-named function-name)))
	   (type-name (function-value-type-name fun)))
      (when exact 
	(check-use-of-exact type-name  "delete an inverse index" function-name))
      (cond ((not (subtypep type-name 'functional-entity-handle))
	     (statice-model:delete-index (list att) :case-sensitive exact))
	    (t
	     (delete-group-index att))))))

(defun inverse-index-exists (function-name &key exact)
  (inside-function-level (database) 
    (let* ((fun (get-function-for-index-operation function-name nil))
	   (att (or (cl:gethash
		      (cl:ecase (function-implementation fun)
			(other-relation
			  (cl:error "It is not meaningful to have an inverse index for ~S,~@
                                  an entity-valued set-valued unique function" function-name))
			((type-relation binary-relation)
			 (function-is-attribute-tag fun)))
			     (functional-database-schema-table database))
		    (no-function-named function-name))))
      (cond ((not (subtypep (function-value-type-name fun) 'functional-entity-handle))
	     (let* ((rel (cl:gethash (function-relation-tag fun)
				  (functional-database-schema-table database)))
		    (index-rel (get-relation "%%index"))
		    (index-on (get-attribute index-rel "on"))
		    (index-is (get-attribute index-rel "is"))
		    (index-case-sensitive (get-attribute index-rel "case-sensitive"))
		    (index-attribute-rel (get-relation "%%index-attribute"))
		    (index-attribute-of (get-attribute index-attribute-rel "of"))
		    (index-attribute-is (get-attribute index-attribute-rel "is")))
	       ;; Try every index of the relation.
	       (do-attribute (value not-null-p index-is (:where (:and index-on rel
							   index-case-sensitive exact)))
		 (unless (do-attribute (ia not-null-p index-attribute-is
					  (:where index-attribute-of value))
			   (unless (eq ia att)
			     (return t)))
		   (return-from inverse-index-exists t))))
	     nil)
	    (t
	     (let* ((attribute-rel (get-relation "%%attribute"))
		    (attribute-is (get-attribute attribute-rel "is"))
		    (attribute-group-indexed (get-attribute attribute-rel "group-indexed")))
	       (do-attribute (value not-null-p attribute-group-indexed
				    (:where attribute-is att))
		 (return (values value not-null-p)))))))))

(defun multiple-index-get-att-list (list-of-function-names st)
  (check-type list-of-function-names list)
  (cl:loop for fname in list-of-function-names do
    (unless (symbolp fname) (no-function-named fname))
	collect
	  (let ((fun (get fname 'statice-function)))
	    (unless fun (no-function-named fname))
	    (unless (forward-function-p fun)
	      (cl:error "~S is an inverse function"))
	    (unless (eq (function-implementation fun) 'type-relation)
	      (cl:error "~S is not a single-valued same-area function" fname))
	    (or (cl:gethash (function-is-attribute-tag fun) st)
		(no-function-named fname)))))

(defun make-multiple-index (list-of-function-names &key unique exact)
  (inside-function-level (database)
    (statice-model:make-index
      (multiple-index-get-att-list
	list-of-function-names
	(functional-database-schema-table database))
      :unique-p unique
      :case-sensitive exact)))

(defun delete-multiple-index (list-of-function-names &key exact)
  (inside-function-level (database)
    (statice-model:delete-index
      (multiple-index-get-att-list
	list-of-function-names
	(functional-database-schema-table database))
      :case-sensitive exact)))

(defun multiple-index-exists (list-of-function-names &key exact)
  (inside-function-level (database)
    (let* ((st (functional-database-schema-table database))
	   (att-list (multiple-index-get-att-list list-of-function-names st))
	   (rel (or (cl:gethash (function-relation-tag (get (first list-of-function-names)
							 'statice-function))
			     st)
		    (no-function-named (first list-of-function-names))))
	   (index-rel (get-relation "%%index"))
	   (index-on (get-attribute index-rel "on"))
	   (index-is (get-attribute index-rel "is"))
	   (index-case-sensitive (get-attribute index-rel "case-sensitive"))
	   (index-attribute-rel (get-relation "%%index-attribute"))
	   (index-attribute-of (get-attribute index-attribute-rel "of"))
	   (index-attribute-is (get-attribute index-attribute-rel "is")))
      (do-attribute (value not-null-p index-is
			   (:where (:and index-on rel index-case-sensitive exact)))
	(let ((this-att-list nil))
	  (do-attribute (ia not-null-p index-attribute-is
			   (:where index-attribute-of value))
	    (push ia this-att-list))
	  (when (and (= (length att-list) (length this-att-list))
		     (null (set-difference att-list this-att-list)))
	    (return-from multiple-index-exists t))))
      nil)))

;;; A uniqueness constraint, of one kind of another, was violated.
(scl:defflavor uniqueness-violation () (function-error))

;;; A uniqueness constraint on a function (that is, the :unique keyword
;;; on an attribute) was violated.  type is the type instance, and
;;; function is the function instance, for the function that was
;;; violated.
(scl:defflavor function-uniqueness-violation
	(type
	 function)
	(uniqueness-violation)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report function-uniqueness-violation) (stream)
  (format stream "There was an attempt to violate the uniqueness constraint~@
                  of function ~S, in type ~S"
	  (function-full-name function) (type-name type)))

;;; A uniqueness constraint on an index was violated.  type is the type
;;; index, and functions is a list of the function instances of the
;;; index.
(scl:defflavor index-uniqueness-violation
	(type
	 functions)
	(uniqueness-violation)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report index-uniqueness-violation) (stream)
  (format stream "There was an attempt to violate the uniqueness constraint~@
                  of the index in type ~S on functions " (type-name type))
  (scl:format-textual-list (mapcar #'function-full-name functions)
		       #'cl:prin1
		       :conjunction "and"))

;;; ++ Kludge, fix later.
(scl:defsubst attribute-handle-name (attribute-handle)
  (statice-model::attribute-handle-name attribute-handle))

;;; ++ Kludge, fix later.
(scl:defsubst relation-handle-name (relation-handle)
  (statice-model::relation-handle-name relation-handle))

#||

other-relation:

  (shirts (set-of shirt) :unique-p t		; One to many.  Other-relation.
     :inverse owner-of-shirt)			; Many to one.

It's an error if we try to have more than one owner of the
same shirt.  (make-relation ... new-guy old-shirt).
Now actually this is surrogated onto the shirt-type relation.
So the unique attribute here is the soo-att of the shirt relation.
Unfortunately, there's no way to find the function!?
Maybe work on this after the rest of everything else is debugged...

||#

;;; This is a condition-bind handler, invoked when
;;; statice-model:uniqueness-violation is signalled.
(defun uniqueness-violation-handler (cl:error)
  (let* ((relation (uniqueness-violation-relation-handle cl:error))
	 (attribute (uniqueness-violation-attribute-handle cl:error))
	 (attribute-list (uniqueness-violation-attribute-handles cl:error))
	 (database (home-database-of relation)))
    (unless (typep database 'functional-database)
      ;; The error was on some other database.  This isn't for us.
      (return-from uniqueness-violation-handler nil))
    (let* ((sdname (functional-database-schema-name database))
	   (sd (get sdname 'schema)))
      (flet ((find-type (type-name-string)
	       ;; Given a symbol or string naming an entity type in this
	       ;; schema, return the type instance.
	       (or (dolist (type-name (schema-type-names sd))
		     (when (string-equal type-name type-name-string)
		       (return (get type-name 'entity-type))))
		   (return-from uniqueness-violation-handler nil)))
	     (find-function (att-name type)
	       ;; Find the forward function in type whose values are
	       ;; implemented by the attribute named att-name.
	       ;; Returns a forward-function instance or nil.
	       (dolist (fun (type-functions type))
		 (when (and (forward-function-p fun)
			    (string-equal (function-slot-name fun) att-name))
		   (return fun)))))
	(cond ((and (null attribute)
		    (> (length attribute-list) 1))
	       ;; A multiple-index uniqueness violation.  Every function
	       ;; must be implemented as a type-relation.  So the name
	       ;; of the relation is the name of the type, and the name
	       ;; of the attribute is the slot-name of the function.
	       (let ((type (find-type (relation-handle-name relation))))
		 (cl:error 'index-uniqueness-violation
			:type type
			:functions (cl:loop for att in attribute-list
					 collect (find-function (attribute-handle-name att)
								type)))))
	      (t
	       ;; A function uniqueness violation.  This can manifest
	       ;; itself as an attribute-list of length 1 if there is an
	       ;; index on the unique attribute.
	       (let ((rel-name (relation-handle-name relation)))
		 (cond ((and (> (string-length rel-name) 2)
			     (string-equal rel-name "%$" :end1 2))
			;; It's a binary function, single-valued other-area.
			(dolist (type-name (schema-type-names sd))
			  (let ((type (get type-name 'entity-type)))
			    (dolist (fun (type-functions type))
			      (when (string-equal rel-name
						  (function-full-name fun)
						  :start1 2)
				(cl:error 'function-uniqueness-violation
				       :type type
				       :function fun))))))
		       (t
			;; It's either a type-relation or
			;; other-relation.  So the name of the relation
			;; is the name of the type.
			(let* ((type (find-type rel-name))
			       (att-name (attribute-handle-name
					   (or attribute (first attribute-list)))))
			  (cond ((string-equal att-name "%$OF")
				 ;; It's an other-relation.
				 (cl:error "Statice bug: a uniqueness constraint was violated~@
                                         on a set-valued, entity-valued, :unique function,~@
                                         but the error was not signalled properly.  Please~@
                                         report this to the Statice maintainers.  Thanks."))
				(t
				 ;; It's a type-relation.
				 (cl:error 'function-uniqueness-violation
					:type type
					:function (find-function att-name type))))))))))))))

(defun other-relation-uniqueness-error (function-name entity value)
  (declare (ignore entity value))
  (let ((fun (get function-name 'statice-function)))
    (cl:error 'function-uniqueness-violation
	   :type (get (function-argument-type-name fun) 'entity-type)
	   :function fun)))

(scl:defflavor no-function-named
	(function-name)
	(function-error)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report no-function-named) (stream)
  (format stream "There is no function named ~S in ~A"
	  function-name (current-database)))

(scl:defflavor no-entity-type-named
	(entity-type-name)
	(function-error)
  :initable-instance-variables
  :readable-instance-variables)

(scl:defmethod (dbg:report no-entity-type-named) (stream)
  (format stream "There is no entity type named ~S in ~A~@
                  Perhaps you left this entity type out of the define-schema form?"
	  entity-type-name (current-database)))

(defun no-function-named (function-name)
  (cl:error 'no-function-named :function-name function-name))

(defun no-entity-type-named (entity-type-name)
  (cl:error 'no-entity-type-named :entity-type-name entity-type-name))

;;; Call this function if the caller specifies exactness, and you want
;;; to check whether that's OK for this type.  type-name is the argument
;;; of the inverse function.  function-name is the name of the inverse
;;; function.  message is a string saying what the caller was trying to
;;; do.

(defun check-use-of-exact (type message function-name)
  (unless (or (stringlike-type-p type) (charlike-type-p type))
    (cl:error "It is not meaningful to ~A for function ~A,~@
            because its type is neither a string type nor a symbol type"
	   message function-name)))

;;; This is a kludge.  I'm not sure what the right thing is.
(defun stringlike-type-p (type)
  (dw:with-type-decoded (type-name) type
    (member type-name '(string symbol cl:simple-string))))

;;; This is a kludge too.
(defun charlike-type-p (type)
  (dw:with-type-decoded (type-name) type
    (member type-name '(cl:string-char character))))

#||

other-relation:

  (shirts (set-of shirt) :unique-p t		; One to many.  Other-relation.
     :inverse owner-of-shirt)			; Many to one.

It's an error if we try to have more than one owner of the
same shirt.  (make-relation ... new-guy old-shirt).
Now actually this is surrogated onto the shirt-type relation.
So the unique attribute here is the soo-att of the shirt relation.
Unfortunately, there's no way to find the function!?
Maybe work on this after the rest of everything else is debugged...

||#

(scl:defmethod (schema-types template-schema) ()
  (cl:loop for type-name in type-names
	collect (get type-name 'entity-type)))

(scl:defmethod (type-attributes basic-entity-type) ()
  (cl:loop for function in functions
	when (forward-function-p function)
	  collect function))

(scl:defmethod (attribute-name basic-forward-function) () slot-name)

(scl:defmethod (attribute-function-name basic-forward-function) () full-name)

(scl:defmethod (attribute-type basic-forward-function) ()
  (get argument-type-name 'entity-type))

(scl:defmethod (attribute-value-type basic-forward-function) ()
  (if (subtypep value-type-name 'functional-entity-handle)
      (get value-type-name 'entity-type)
      value-type-name))

(scl:defmethod (attribute-value-is-set basic-forward-function) () value-is-set)

(scl:defmethod (attribute-value-foreign basic-forward-function) () value-foreign)

(scl:defmethod (attribute-unique basic-forward-function) () unique)

(scl:defmethod (attribute-read-only basic-forward-function) () read-only)

(scl:defmethod (attribute-area-name basic-forward-function) () area-name)

(scl:defmethod (attribute-set-exists basic-forward-function) () set-exists)

(scl:defmethod (attribute-index-exists basic-forward-function) () index-exists)

(scl:defmethod (attribute-index-average-size basic-forward-function) () index-average-size)

(scl:defmethod (attribute-inverse-index-exists basic-forward-function) () inverse-index-exists)

(scl:defmethod (attribute-inverse-index-exact-exists basic-forward-function) () inverse-index-exact-exists)

(scl:defmethod (attribute-inverse-index-average-size basic-forward-function) () inverse-index-average-size)

(scl:defmethod (attribute-no-nulls basic-forward-function) () no-nulls)

(scl:defmethod (attribute-inverse-function-name basic-forward-function) ()
  (dolist (function (type-functions (get argument-type-name 'entity-type)))
    (when (and (eq (function-slot-name function) slot-name)
	       (not (forward-function-p function)))
      (return (function-full-name function)))))

(scl:defmethod (multiple-index-attribute-names basic-multiple-index) () slot-names)

(defun get-template-schema (schema-name)
  (check-type schema-name symbol)
  (let ((template-schema (get schema-name 'schema)))
    (unless template-schema
      (cl:error "~S is not the name of a defined schema" schema-name))
    template-schema))

(defun get-template-entity-type (entity-type-name)
  (let ((template-entity-type (get entity-type-name 'entity-type)))
    (unless template-entity-type
      (cl:error "~S is not the name of a defined entity-type" entity-type-name))
    template-entity-type))

(scl:compile-flavor-methods template-schema real-schema
			template-entity-type real-entity-type
			template-attribute real-attribute real-forward-function
			template-inverse-function real-inverse-function
			template-multiple-index real-multiple-index)

(scl:compile-flavor-methods functional-database )

(scl:compile-flavor-methods no-current-database schema-not-loaded wrong-type-entity
			entity-not-found-in-set
			function-uniqueness-violation index-uniqueness-violation)

