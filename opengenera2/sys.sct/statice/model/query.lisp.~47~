;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice-model; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
 
(defparameter *operators*
	      '(> <   >= <= = domain equal eql eq
		  string-search scl:string-search-exact string-prefix string-prefix-exact
		  string< string string<=
		  string> string string>=
		  string-lessp string-greaterp string-not-lessp string-not-greaterp
		  string-equal string=
		  char< char char<= char> char char>=
		  char-lessp char-greaterp char-not-lessp char-not-greaterp
		  char-equal char= equal))

(defparameter *greater-than-operators*
	      '(>  >= 
		  string> string string>= string-greaterp string-not-lessp
		  char> char char>= char-greaterp char-not-lessp))

(defparameter *less-than-operators*
	      '(<  <= 
		  string< string string<= string-lessp string-not-greaterp
		  char< char char<= char-lessp char-not-greaterp))

;;; Check the validity of the arguments to do-relation.
(defun check-attribute-types (relation-handle where order-by)
  (if (listp relation-handle)
      (check-do-relation-arguments-with-join relation-handle where order-by)
      (check-do-relation-arguments-no-join relation-handle where order-by)))

(defun check-do-relation-arguments-no-join (relation-handle where order-by)
  ;(check-relation-handle relation-handle) ;; already done in map-relation-1
  (unless (evenp (length where))
    (model-error "The list of specifications and attributes, ~S, was of odd length" where))
  (flet ((check-attribute (ah)
	   (check-attribute-handle ah)
	   (unless (eq relation-handle (attribute-handle-relation ah))
	     (model-error "The attribute ~S is not from the relation ~S" ah relation-handle))))
    (loop for (attribute-handle spec) on where by #'cddr do
      (check-attribute attribute-handle)
      (unless (check-spec (attribute-handle-type attribute-handle) spec)
	(model-error "The spec ~S is not valid for the attribute ~S" spec attribute-handle)))
    (loop for (attribute-handle) in order-by do
      (check-attribute attribute-handle)
      (unless (comparable-p (attribute-handle-type attribute-handle))
	(model-error "The attribute ~S is of type ~S, whose elements can't be compared."
		     attribute-handle (attribute-handle-type attribute-handle))))))

(defun check-do-relation-arguments-with-join (relation-alist where order-by)
  (loop for (nil relation-handle) in relation-alist do
    (check-relation-handle relation-handle))
  (unless (evenp (length where))
    (model-error
      "The list of specifications and attributes, ~S, was of odd length" where))
  (flet ((check-attribute-spec (attribute-spec)
	   ;; Check attribute-spec to see if it is a valid attribute
	   ;; specifier, and return the spec's attribute handle.
	   (cond ((listp attribute-spec)
		  ;; attribute-spec is qualified.  Use its qualifying
		  ;; symbol to find the corresponding relation from the
		  ;; relation-alist.
		  (let ((key-symbol (first attribute-spec))
			(a-h (second attribute-spec)))
		    (unless (and (symbolp key-symbol) (= (length attribute-spec) 2))
		      (model-error "~S is not a well-formed attribute spec" attribute-spec))
		    (check-attribute-handle a-h)
		    (let ((r-h (second (assoc key-symbol relation-alist))))
		      (unless (eq r-h (attribute-handle-relation a-h))
			(if r-h
			    (model-error "The attribute ~S is not from the relation ~S"
					 a-h r-h)
			    (model-error "The attribute spec ~S uses the variable ~S,@~
                                          which was not found in the list ~S."
					 attribute-spec key-symbol relation-alist))))
		    a-h))
		 (t
		  ;; attribute-spec is unqualified.  Make sure that its
		  ;; relation appears in the relation-alist once and only
		  ;; once.
		  (check-attribute-handle attribute-spec)
		  (let ((count (cl:loop with r-h = (attribute-handle-relation
						  attribute-spec)
				     for (nil relation-handle) in relation-alist
				     count (eq relation-handle r-h))))
		    (cond ((zerop count)
			   (model-error "The attribute ~S is not from any of the relations~@
                                         in the list ~S."
					attribute-spec relation-alist))
			  ((> count 1)
			   (model-error
			     "The attribute ~S is in more than one of the relations in the~@
                              list ~S.  The attribute must be replaced with a qualified spec."
			     attribute-spec relation-alist))))
		  attribute-spec))))
    ;; Check the :where clause, for each attribute/spec pair.
    (cl:loop for (attribute-spec spec) on where by #'cddr do
      (let* ((attribute-handle (check-attribute-spec attribute-spec))
	     (join-attribute-spec nil)
	     (join-operator 'equal))
	;; Analyze the spec to see whether it is a join spec or not.  If
	;; it is a join spec, set join-attribute-spec, and join-operator
	;; (which defaults to 'equal).
	(typecase spec
	  (attribute-handle
	    ;; The spec is an unqualified attribute spec.
	    (setq join-attribute-spec spec))
	  (list
	    (let ((f (first spec))
		  (s (second spec)))
	      (typecase s
		(attribute-handle
		  ;; The second element of the list is an attribute
		  ;; handle.  This is definitely a join spec, but we
		  ;; must deterimine whether the spec is a qualified
		  ;; attribute spec, or an operator with an unqualified
		  ;; attribute spec.
		  (cond ((not (= (length spec) 2))
			 (model-error "~S is not a valid spec" spec))
			((member f *operators*)
			 (setq join-operator f
			       join-attribute-spec s))
			((assoc f relation-alist)
			 (setq join-attribute-spec spec))
			(t
			 (model-error "~S is not a valid spec" spec))))
		(list
		  ;; The second element of the list must be a qualified
		  ;; attribute spec, and the first must be an operator.
		  (setq join-operator f
			join-attribute-spec s))))))
	(cond ((null join-attribute-spec)
	       ;; It's not a join spec, just an ordinary spec.
	       (unless (check-spec (attribute-handle-type attribute-handle) spec)
		 (model-error "The spec ~S is not valid for the attribute ~S"
			      spec attribute-handle)))
	      (t
	       ;; It is a join spec.
	       (let* ((join-attribute-handle (check-attribute-spec join-attribute-spec))
		      (attribute-type (attribute-handle-type attribute-handle))
		      (join-attribute-type (attribute-handle-type join-attribute-handle)))
		 ;; Check for type compatibility between the two
		 ;; attributes.  Special note: the old version of this
		 ;; code had a special hack to declare the types
		 ;; compatible if either type was the "%%attribute"
		 ;; domain.  We can't remember why this was in, so we're
		 ;; leaving it out for now.  Perhaps we'll find out the
		 ;; hard way.
		 (unless (typecase attribute-type
			   (domain-handle
			     (typecase join-attribute-type
			       (domain-handle
				 ;; They are both domains.
				 (or (child-of-p attribute-type join-attribute-type)
				     (child-of-p join-attribute-type attribute-type)))
			       (t
				 (entity-type-p join-attribute-type))))
			   (t
			     (typecase join-attribute-type
			       (domain-handle
				 (entity-type-p attribute-type))
			       (t
				 ;; They are both value-type storage handles.
				 (let ((join-pt
					 (value-storage-handler-presentation-type
					   join-attribute-type))
				       (att-pt
					 (value-storage-handler-presentation-type
					   attribute-type)))
				   (or (equal join-pt att-pt)
				       (dw:presentation-subtypep join-pt att-pt)
				       (dw:presentation-subtypep att-pt join-pt)))))))
		   (model-error "The types of attributes ~S and ~S are not compatible"
				attribute-type join-attribute-type))
		 ;; Check the operator against the attribute's type.
		 (unless (check-operator attribute-type join-operator)
		   (model-error "The operator ~S cannot be used with attribute ~S"
				join-operator attribute-type)))))))
    ;; Check the :order-by clause.
    (cl:loop for (attribute-spec) in order-by do
      (let ((attribute-handle (check-attribute-spec attribute-spec)))
	(unless (comparable-p (attribute-handle-type attribute-handle))
	  (model-error "The attribute ~S is of type ~S, whose elements can't be compared"
		       attribute-handle (attribute-handle-type attribute-handle)))))))

;;; Given a relation-handle, a list of atts and specs (where clause),
;;; and a list of attributes and directions to sort the results by, call
;;; function for each element of the relation which meets the specs.
(defun map-relation (function relation-handle where order-by &optional count)
  (declare (sys:downward-funarg function))
  (map-relation-1 function relation-handle nil where order-by count))

;;; Given an attribute-handle, a list of atts and specs (where clauses),
;;; and a list of attributes and directions to sort the results by, apply
;;; function to each attribute-value in the relation which meets the specs.
;;; This is almost the same as map-relation except that we don't cons a
;;; tuple-handle in order to get the value.

(defun map-attribute (function attribute-handle where order-by count)
  (declare (sys:downward-funarg function))
  (map-relation-1 function nil attribute-handle where order-by count))

(defun map-relation-1 (function relation-handle attribute-handle where order-by count)
  (restart-testing-check)
  (when attribute-handle
    (if relation-handle
	(model-error "relation-handle and attribute-handle both specified to map-relation-1")
	(setq relation-handle (attribute-handle-relation attribute-handle))))
  (check-relation-handle relation-handle)
  (prepare-database (relation-handle-database relation-handle))
  (check-attribute-types relation-handle where order-by)
  (when count (check-type count integer))
  (let* ((rt *restart-testing*)
	 (iteration-count 0)
	 (rt-function (if rt
			  #'(zl:named-lambda map-relation-restart-testing-internal (&rest args)
			      (let ((*restart-testing* (or (and (eq rt :all) rt)
							   (and (eq rt :some)
								(zerop iteration-count)
								:some))))
				(apply function args)
				(incf iteration-count)))
			  function)))
    (cond ((null order-by)
	   (cond ((null where)
		  ;; no :where, no :order-by.  Just walk the relation.
		  (map-relation-all-test
		    rt-function relation-handle attribute-handle nil count))
		 (t
		  ;; :WHERE, but no :ORDER-BY.  Try to find some indexes
		  ;; which are useful for retrieving.
		  (sys:with-data-stack
		    (multiple-value-bind (rid-arrays rest-of-attributes-and-specs)
			(find-useful-indexes relation-handle where)
		      (if (null rid-arrays)
			  ;; No index does any good.  So do it the slow way; map
			  ;; over all tuples.
			  (map-relation-all-test
			    rt-function relation-handle attribute-handle where count)
			  ;; There were one or more useful indexes.
			  (map-relation-over-rid-array
			    rt-function
			    relation-handle
			    attribute-handle
			    (intersect-rid-arrays rid-arrays)
			    rest-of-attributes-and-specs
			    count)))))))
	  (t
	   ;; Some sort of sorting specified (no pun intended).
	   (map-relation-sorted
	     rt-function relation-handle attribute-handle where order-by count)))))

;;; Rather specialized function which returns an attribute's value given
;;; a tuple rid.  This is used by any functions which have a rid of a tuple
;;; and wish to avoid consing a tuple handle, just for the sake of passing
;;; it to get-value.  The caller guarantees that attribute-handle is from
;;; relation-handle.
(defun get-value-given-tuple-rid (tuple-rid relation-handle attribute-handle database opening
				  addressor-or-rid)
  (let* ((soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (type (attribute-handle-type attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (if (eq addressor-or-rid :addressor)
	(let ((addressor tuple-rid))
	  (get-value-internal (addressor descriptor :rid-or-handle :addressor)
	    (let ((value (read-value type addressor descriptor database)))
	      (unless (eq value *null-value*)
		value))))
	(get-value-internal (addressor descriptor :rid-or-handle :rid)
	  (let ((value (read-value type addressor descriptor database)))
	    (unless (eq value *null-value*)
	      (values value t)))))))

;;; External entrypoint for calls who don't go through do-relation.
(defun map-relation-dynamic (function relation-handle &key where order-by count)
  (declare (sys:downward-funarg function))
  (map-relation function relation-handle where order-by count))

;;; Apply the function to every tuple in the relation for which
;;; the values of the given attributes match the given specs.  This
;;; function never uses indexes; it gets called when there are no
;;; applicable indexes whatsoever, and so we really have to iterate over
;;; all tuples.
;;; If attribute-handle is passed, then apply function to the value of 
;;; the attribute in the tuple and not-null-p so that we don't cons an entity handle.
;;; The callers guarantees that attribute-handle is from relation-handle.
(defun map-relation-all-test (function relation-handle attribute-handle
			      attributes-and-specs count)
  (declare (sys:downward-funarg function))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (actual-count 0))
    (when *windy-index-checking*
      (format t "~&Walking relation ~S with specs = ~S" relation-handle attributes-and-specs))
    (cond ((not (fast-string= (relation-handle-name relation-handle) "%%entity-domain"))
	   ;; This is a normal relation.
	   (map-over-tuples
	     relation-handle
	     #'(lambda (tuple tuple-rid tuple-version)
		 (declare (ignore tuple-version))
		 (when (test-tuple tuple relation-handle attributes-and-specs tuple-rid)
		   (if attribute-handle
		       (multiple-value-bind (value not-null-p)
			   (get-value-given-tuple-rid
			     tuple-rid relation-handle attribute-handle
			     database opening :rid)
			 (funcall function value not-null-p))
		       (funcall function
				(find-tuple-handle-given-rid tuple-rid relation-handle)))
		   (when count
		     (incf actual-count)
		     (unless (< actual-count count)
		       (return-from map-relation-all-test nil)))))))
	  (t
	   ;; This is the Entity-Domain system relation.  What that really means is
	   ;; that we are to iterate over all entities in the database.
	   (do-domains (domain-handle database)
	     (map-over-entity-records
	       domain-handle
	       #'(lambda (ent-rid)
		   (with-record (ent opening ent-rid :read)
		     (when (test-tuple ent relation-handle attributes-and-specs ent-rid)
		       (if attribute-handle
			   (multiple-value-bind (value not-null-p)
			       (get-value-given-tuple-rid
				 ent relation-handle attribute-handle
				 database opening :addressor)
			     (funcall function value not-null-p))
			   (funcall function
				    (find-tuple-handle-given-rid ent-rid relation-handle)))
		       (when count
			 (incf actual-count)
			 (unless (< actual-count count)
			   (return-from map-relation-all-test nil))))))))))))

;;; Given a particular relationhip, specified by its addressor and
;;; relation-handle, check to see whether it meets all of the
;;; constraints of the attributes and specs.  Return T if it does and
;;; NIL if it doesn't.  Note that null values never meet any specs.
;;; The record can be a tuple record or an entity record.
(defun test-tuple (addressor relation-handle attributes-and-specs addressor-rid)
  (or (null attributes-and-specs)		; If no constraints, return T.
      (let ((database (relation-handle-database relation-handle))
	    (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
	;; Each of the specified attributes must be present, and must
	;; meet the corresponding spec.
	(loop for (att spec) on attributes-and-specs by #'cddr
	      always (if (eq att soo-att)
			 (test-spec-soo-att addressor spec database)
			 (let ((ver (if soo-att
					(search-table-for-domain
					  (attribute-handle-layout-version att)
					  (find-domain-handle-given-entity-rid addressor-rid
									       database)
					  :if-not-found nil)
					(attribute-handle-layout-version att))))
			   (and (not (null ver))
				(<= ver
				   (if soo-att
				       (local-entity-version addressor)
				       (tuple-version addressor)))
				(test-spec addressor att spec database
					   addressor-rid soo-att))))))))

;;; Check whether a value meets a spec.  The value resides in the
;;; record, and is described by att, which is an attribute handle.
;;; The caller guarantees that versions have been checked appropriately,
;;; and that the attribute is not the soo-att.

(defun test-spec (addressor att spec database addressor-rid surrogate-p)
  (let ((type (attribute-handle-type att))
	(desc (let ((desc (attribute-handle-descriptor att)))
		(if surrogate-p
		    (search-table-for-domain
		      desc (find-domain-handle-given-entity-rid addressor-rid database))
		    desc))))
    (if (or (null spec) (not (listp spec)))
	(value-equal type addressor desc spec database)
	(if (eq spec *null-value*)		;could get this from find-useful-indexes
	    (value-null-p type addressor desc)	;if there are any remaining specs of (null)
	    (ecase (first spec)
	      ((equal eql = eq string= char=)
	       (value-equal type addressor desc (second spec) database))
	      ((string-equal char-equal)
		(eq (value-compare type addressor desc (second spec) database
				   :case-sensitive nil)
		    :equal))
	      ((> string> char>)
	       (sys:with-data-stack
		 (eq (value-compare type addressor desc (second spec) database
				    :case-sensitive t)
		     :greaterp)))
	      ((< string< char<)
	       (sys:with-data-stack
		 (eq (value-compare type addressor desc (second spec) database
				    :case-sensitive t)
		     :lessp)))
	      ((string-lessp char-lessp)
		(sys:with-data-stack
		  (eq (value-compare type addressor desc (second spec) database
				     :case-sensitive nil)
		      :lessp)))
	      ((string-greaterp char-greaterp)
		(sys:with-data-stack
		  (eq (value-compare type addressor desc (second spec) database
				     :case-sensitive nil)
		      :greaterp)))
	      (( >= string string>= char char>=)
	       (sys:with-data-stack
		 (let ((result (value-compare type addressor desc (second spec) database
					      :case-sensitive t)))
		   (or (eq result :greaterp) (eq result :equal)))))
	      (( <= string string<= char char<=)
	       (sys:with-data-stack
		 (let ((result (value-compare type addressor desc (second spec) database
					      :case-sensitive t)))
		   (or (eq result :equal) (eq result :lessp)))))
	      ((string-not-greaterp char-not-greaterp)
		(sys:with-data-stack
		  (let ((result (value-compare type addressor desc (second spec) database
					 :case-sensitive nil)))
		    (or (eq result :lessp) (eq result :equal)))))
	      ((string-not-lessp char-not-lessp)
		(sys:with-data-stack
		  (let ((result (value-compare type addressor desc (second spec) database
					       :case-sensitive nil)))
		    (or (eq result :greaterp) (eq result :equal)))))
	      ((string-search scl:string-search-exact)
	       (sys:with-data-stack
		 (and (not (value-null-p type addressor desc))
		      (let ((value (read-value type addressor desc database
					       :stack-cons-if-appropriate t)))
			(or (zerop (string-length (second spec)))
			    (funcall (first spec)
				     (second spec)
				     (if (symbolp value) (sys:get-pname value) value)))))))
	      ((string-prefix string-prefix-exact)
	       (sys:with-data-stack
		 (and (not (value-null-p type addressor desc))
		      (let* ((db-value (read-value type addressor desc database
						   :stack-cons-if-appropriate t))
			     (value (if (symbolp db-value) (sys:get-pname db-value) db-value))
			     (spec-length (string-length (second spec)))
			     (value-length (string-length value)))
			(or (zerop spec-length)
			    (and (>= value-length spec-length)
				 (funcall (if (eq (first spec) 'string-prefix)
					      #'string-equal
					      #'string=)
					  value
					  (second spec)
					  :end1 spec-length)))))))
	      (domain
		(let ((value (read-value type addressor desc database)))
		  (and (not (eq *null-value* value))
		       (statice-typep (second spec) value))))
	      (null
		(value-null-p type addressor desc)))))))


;;; This function is just like test-spec above, except that att is the
;;; soo-att of the relation.  (The relation is surrogate-optimized.)  So
;;; instead of using the att's type and descriptor to pick up the
;;; attribute value from the addressor, the attribute value IS the
;;; addressor, which must be addressing a local entity record.  Since we know that
;;; the attribute is entity-valued, the only kinds of specs that we can possibly
;;; be given are entity-handles for exact matches, or domains for typep matches.
(defun test-spec-soo-att (addressor spec database)
  (cond ((or (not (listp spec)) (eq (first spec) 'equal) (eq (first spec) 'eq))
	 (let ((entity-handle (if (listp spec) (second spec) spec)))
	   (cond ((and (typep entity-handle 'known-entity-handle)
		       (eq database (domain-handle-database
				     (known-entity-handle-domain entity-handle))))
		  ;; Fast: This is entity-handle's home database, we can just compare RIDs.
		  (= (get-addressor-rid addressor) (handle-rid entity-handle)))
		 (t
		  ;; Slow: Need to look inside the record to get the UID.
		  (and (= (entity-uid-word-1 addressor)
			  (entity-handle-uid-word-1 entity-handle))
		       (= (entity-uid-word-2 addressor)
			  (entity-handle-uid-word-2 entity-handle))
		       (= (entity-uid-word-3 addressor)
			  (entity-handle-uid-word-3 entity-handle)))))))
	((eq (first spec) 'domain)
	 (statice-typep
	   (second spec)
	   (find-entity-handle-given-rid (get-addressor-rid addressor) database)))
	((eq (first spec) 'null) nil)		;can never happen
	(t
	 (model-bug "Bad spec for soo-att ~S" spec))))		   

;;; Call the function for each of the records in rid-array that pass the
;;; specs provided.  rid-array can have some zero elements, which are
;;; "holes" to be ignored.  rid-array can also be null, in which case don't
;;; do anything at all.
;;; If attribute-handle is non-null, then apply function to the attribute's
;;; value in the tuple of the rid and not-null-p so as to avoid consing a tuple handle.
;;; The caller guarantees that attribute-handle is from relation-handle.
(defun map-relation-over-rid-array (function relation-handle attribute-handle rid-array
				    attributes-and-specs count)
  (declare (sys:downward-funarg function))
  (when rid-array
    (let* ((database (relation-handle-database relation-handle))
	   (opening (database-opening database))
	   (rid-array rid-array)
	   (actual-count 0))
      (declare (sys:array-register rid-array))
      (with-stack-list* (*all-rid-arrays* relation-handle rid-array *all-rid-arrays*)
	(if (null attributes-and-specs)
	    ;; No testing needed, so no need to access the records.
	    (dotimes (i (length rid-array))
	      (let ((rid (aref rid-array i)))
		(unless (zerop rid)
		  (if attribute-handle
		      (multiple-value-bind (value not-null-p)
			  (get-value-given-tuple-rid
			    rid relation-handle attribute-handle database opening :rid)
			(funcall function value not-null-p))
		      (funcall function 
			       (find-tuple-handle-given-rid rid relation-handle)))
		  (when count
		    (incf actual-count)
		    (unless (< actual-count count)
		      (return nil))))))
	    ;; Testing is needed.
	    (dotimes (i (length rid-array))
	      (let ((rid (aref rid-array i)))
		(unless (zerop rid)
		  (with-record (addressor opening rid :read)
		    (when (test-tuple addressor relation-handle attributes-and-specs rid)
		      (if attribute-handle
			  (multiple-value-bind (value not-null-p)
			      (get-value-given-tuple-rid
				addressor relation-handle attribute-handle
				database opening :addressor)
			    (funcall function value not-null-p))
			  (funcall function
				   (find-tuple-handle-given-rid rid relation-handle)))
		      (when count
			(incf actual-count)
			(unless (< actual-count count)
			  (return nil)))))))))))))

;;; Given a list of arrays of rids, return an array containing the
;;; intersection of the rids.  The returned array can be one of the
;;; arrays in the list.  It can contain elements of value -1, which are
;;; "holes" that the caller must ignore.  (This avoids the need to cons
;;; up a new array to hold the answer.)  All of the given arrays can be
;;; bashed by this function!
(defun intersect-rid-arrays (rid-arrays)
  (cond ((null (cdr rid-arrays))
	 ;; If there's only one rid-array, just return it.  This is a common
	 ;; special case.
	 (car rid-arrays))
	(t
	 (let* ((rid-array (first rid-arrays))
		(size (length rid-array)))
	   ;; Build the answer in the smallest array passed in.
	   (dolist (a rid-arrays)
	     (let ((s (length a)))
	       (when (< s size)
		 (setq size s)
		 (setq rid-array a))))
	   ;; Only if there is something worth intersecting
	   (unless (zerop (length rid-array))
	     ;; Pairwise intersect rid-array with each of the others.
	     (sort rid-array #'<)
	     (let ((rid-array rid-array))
	       (declare (compiler:array-register rid-array))
	       (dolist (other rid-arrays)
		 (let ((other other))
		   (declare (compiler:array-register other))
		   (unless (eq other rid-array)
		     (sort other #'<)
		     (let ((other-idx 0)
			   (other-length (length other)))
		       (dotimes (i size)
			 (let ((rid (aref rid-array i)))
			   ;; If we can't find the value rid in the other
			   ;; array, then zap it by storing a zero.
			   (unless (cl:loop until ( other-idx other-length) do
				     (let ((other-rid (aref other other-idx)))
				       (when (= other-rid rid)
					 (incf other-idx)
					 (return t))
				       (when (> other-rid rid)
					 (return nil)))
				     (incf other-idx))
			     (setf (aref rid-array i) 0))))))))))
	   rid-array))))

;;; Find some indexes of relation-handle such that all tuples
;;; that conform to attribute-and-specs are in each index.  Run each
;;; index, to produce a rid-array.  The first value returned is the list
;;; of these rid-arrays.  The second value returned is a modified
;;; version of attributes-and-specs, from which has been removed all of
;;; the attribute-spec pairs that have already been satisfied by one of
;;; the indexes.  Since the caller is receiving stack-arrays, it should
;;; do a sys:with-data-stack around this call.
(defun find-useful-indexes (relation-handle attributes-and-specs)
  (declare (values rid-arrays rest-of-attributes-and-specs))
  (let ((indexes (relation-handle-list-of-indexes relation-handle))
	(soo-att-present nil)
	(database (relation-handle-database relation-handle)))
    ;; indexes is sorted by the number of attributes, putting the indexes
    ;; with the most attributes towards the beginning of the list.
    (let ((as (convert-null-specs (copy-list-simply attributes-and-specs)))
	  (opening (database-opening (relation-handle-database relation-handle)))
	  (rid-arrays nil))
      ;; The following code is the heart of the query-optimization
      ;; strategy, in which a bunch of indexes have to be matched up
      ;; with a bunch of attribute-spec pairs.  First, attempts are made
      ;; to utilize group indexes.  Following that, b-tree indexes are
      ;; used.  [Is this the right order to procede in?]  I'm not sure
      ;; that group indexes should take precedence over b-trees.
      ;; Something to consider.
      (multiple-value-setq (rid-arrays as soo-att-present)
	(group-index-check relation-handle as))
      (if soo-att-present
	  (when (null rid-arrays)
	    ;; soo att was specified, but the tuple was not present on the entity
	    ;; ensure that no walking over rid arrays is performed.
	    (when *query-trace-p*
	      (push (list :soo-att-but-no-tuple) *query-trace-list*))
	    (push (sys:make-stack-array 0 :type 'zl:art-fixnum) rid-arrays))
	  ;; No need to look through b-tree indexes if soo-att was spec'd.  Or should
	  ;; we be obnoxious and tell them if any b-tree indexes are found?
	  (let ((index (pop indexes)))
	    (loop while (and index as)
		  for index-atts = (index-handle-list-of-attributes index) do
	      (multiple-value-bind (index-function args remaining-atts-and-specs)
		  (index-check index-atts as database index)
		(when index-function
		  (setq as remaining-atts-and-specs)
		  (push (apply index-function
			       opening
			       (index-handle-index-identifier index)
			       args)
			rid-arrays))
	      (setq index (pop indexes))))))
      (values rid-arrays as))))

;;; Iterate over an att-spec list and convert (null) specs to *null-value*
;;; This side-effects the list
(defun convert-null-specs (list)
  (when list
    (loop for spec on (cdr list) by #'cddr do
      (when (and (listp (first spec)) (eq (first (first spec)) 'null))
	(setf (first spec) *null-value*)))
    (loop for prev-sublist = nil then sublist
	  for sublist on list by #'cddr
	  for (att spec) on list by #'cddr do
      (when (and (attribute-handle-no-nulls att)
		 (or (equal spec '(string-prefix ""))
		     (equal spec '(string-prefix-exact ""))
		     (equal spec '(string-search ""))
		     (equal spec '(scl:string-search-exact ""))))
	  (if prev-sublist
	      (setf (cddr prev-sublist) (cddr sublist))
	      (setq list (cddr sublist)))
	  (setf (cddr sublist) nil)))
    list))

;;; Look over some attributes and specs to see which one(s) is the
;;; soo-att or have group indexes.  If the soo-att is given, just return
;;; a rid-array with one value (the rid of the entity of the spec
;;; given).  Since we are walking over the att/spec list here, this
;;; seems like an appropriate time to check for the soo-att being
;;; spec'd.  Use the GI's of those that do, and return the attributes
;;; and specs list minus the group-index attributes and specs that were
;;; used for the query.  Since the atts-and-specs arg gets modified, the
;;; caller may want to copy it before calling.
(defun group-index-check (relation-handle atts-and-specs)
  (declare (values rid-arrays remaining-atts-and-specs soo-att-present))
  (let* ((rid-arrays nil)
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att-present nil))
    (loop for prev-sublist = nil then sublist
	  for sublist on atts-and-specs by #'cddr
	  for (att spec) on atts-and-specs by #'cddr
	  with soo-att = (relation-handle-surrogate-optimized-on relation-handle) do
      (let ((eql-spec (equality-spec-p spec)))
	(when (and eql-spec (listp spec) (or (eq (first spec) 'equal) (eq (first spec) 'eq)))
	  (setq spec (second spec)))
	;; Check for soo-att specified.
	(when (and (eq soo-att att) eql-spec)
	  ;; This att/spec pair is the soo-att.  Just get the entity using the spec.
	  (setq soo-att-present t)
	  (when *windy-index-checking*
	    (format t "~&soo-att (~S) specified and used" att))
	  (when *query-trace-p*
	    (push (list :soo-att-eql) *query-trace-list*))
	  (let ((ent-rid (handle-rid spec)))
	    (when ent-rid
	      (let* ((domain-handle (find-domain-handle-given-entity-rid ent-rid database))
		     (byte-spec
		       (byte 1 (search-table-for-domain
				 (relation-handle-entity-bit-map-number relation-handle)
				 domain-handle))))
		;; entity-domain relation is always present on an entity
		(when (or (with-record (ent opening ent-rid :read)
			    (= (ldb byte-spec (local-entity-tuples-present ent)) 1))
			  (equal (relation-handle-name relation-handle) "%%entity-domain"))
		  (push (sys:make-stack-array 1
					      :element-type 'fixnum
					      :initial-element ent-rid)
			rid-arrays)))))
	  (if prev-sublist
	      (setf (cddr prev-sublist) (cddr sublist))
	      (setq atts-and-specs (cddr sublist)))
	  (setf (cddr sublist) nil))
	;; Find group index attributes which were specified.
	(when (and (attribute-handle-group-index-offset att)
		   eql-spec
		   (let ((domain-handle (attribute-handle-type att)))
		     (and (typep spec 'known-entity-handle)
			  (child-of-p domain-handle (known-entity-handle-domain spec)))))
	  (when *windy-index-checking*
	    (format t "~&group-index on att ~S found and used" att))
	  (when *query-trace-p*
	    (push (list :group-index (attribute-handle-name att)) *query-trace-list*))
	  ;; Have a group-index for this att.  Run it.  Take the att-spec pair off the list.
	  (let ((rid-array (rid-array-of-group-index spec att)))
	    (if rid-array
		(push rid-array rid-arrays)
		(push (sys:make-stack-array 0 :type 'zl:art-fixnum) rid-arrays)))
	  (if prev-sublist
	      (setf (cddr prev-sublist) (cddr sublist))
	      (setq atts-and-specs (cddr sublist)))
	  (setf (cddr sublist) nil))
	;; domain-index is useful for entity-domain queries
	(when (fast-string= (relation-handle-name relation-handle) "%%entity-domain")
	  (let (domain-handle)
	    (when (or (when (fast-string= (attribute-handle-name att) "is")
			(setq domain-handle spec))
		      (when (and (listp spec)
				 (eq (first spec) 'domain)
				 (fast-string= (attribute-handle-name att) "of"))
			(setq domain-handle (second spec))))
	      (let ((bid (domain-handle-bset-iid domain-handle)))
		(when bid
		  (when *windy-index-checking*
		    (format t "~&bset-domain-index on att ~S found and used" att))
		  (when *query-trace-p*
		    (push (list :bset-domain-index (attribute-handle-name att))
			  *query-trace-list*))
		  (let ((rid-array (lookup-bset-values opening bid)))
		    (if rid-array
			(push rid-array rid-arrays)
			(push (sys:make-stack-array 0 :type 'zl:art-fixnum) rid-arrays))
		    (if prev-sublist
			(setf (cddr prev-sublist) (cddr sublist))
			(setq atts-and-specs (cddr sublist)))
		    (setf (cddr sublist) nil)))))))))
    (when (and soo-att-present (> (length rid-arrays) 1))
      ;; Most likely this shouldn't be a model-error.
      (model-error "Soo-att was passed along with other atts which have Group indexes.~@
                    This may be excessive"))
    (values rid-arrays atts-and-specs soo-att-present)))

;;; Given an entity that contains a pointer to a group-index record,
;;; return a stack-consed rid-array.  The caller should bind the data
;;; stack.  entity-handle is the entity that points to the group-index
;;; record.  attribute-handle is the attribute indexed on.  It returns
;;; NIL if there isn't actually any array.
(defun rid-array-of-group-index (entity-handle attribute-handle)
  (let* ((entity-domain (known-entity-handle-domain entity-handle))
	 (gio (search-table-for-domain
		(attribute-handle-group-index-offset attribute-handle)
		entity-domain))
	 (gilv (search-table-for-domain
		 (attribute-handle-group-index-layout-version attribute-handle)
		 entity-domain))
	 (opening (database-opening
		    (relation-handle-database (attribute-handle-relation attribute-handle)))))
    (with-record (ent opening (handle-rid entity-handle) :read)
      (when (>= (local-entity-version ent) gilv)
	(let ((gi-bid (read-record-word ent gio)))
	  (unless (zerop gi-bid)
	    (if (or (= 1 (sys:%logldb (byte 1 31) gi-bid))
		    (attribute-handle-unique attribute-handle))
		;; bid is actually rid of tuple record
		(sys:make-stack-array 1
				      :element-type 'fixnum
				      :initial-element (ldb (byte 31 0) gi-bid))
		(lookup-bset-values opening gi-bid))))))))

;;; Given a list of attributes in an index and a list of attributes and
;;; specifications, perform various checks against the index to
;;; determine how (if at all) it might be used for the query.  Return
;;; several values.  remaining-atts-and-specs is the modified version of
;;; the atts-and-specs arg (hence, the caller should copy atts-and-specs
;;; before calling index-check if it should not be changed) reflecting
;;; the part of the query which was not able to be performed by using
(defun index-check (index-atts atts-and-specs database index-handle)
  (declare (values index-function args remaining-atts-and-specs))
  (let ((case-sensitive (index-handle-case-sensitive index-handle)))
    (sys:with-stack-list* (as atts-and-specs)
      (multiple-value-bind (index-atts-and-values remaining-atts-and-specs)
	  (try-exact-index index-atts atts-and-specs case-sensitive)
	(when index-atts-and-values
	  (when *query-trace-p*
	    (trace-query-av :exact-match index-atts-and-values))
	  (when *windy-index-checking*
	    (format t "~&Exact match found for ~S using~@
                         index ~S~@
                         remaining a's&v's=~S" as index-atts remaining-atts-and-specs))
	  (return-from index-check
	    (values #'lookup-index-values
		    (list (apply #'make-key-from-values
				 database index-handle index-atts-and-values))
		    remaining-atts-and-specs))))
      (multiple-value-bind (index-atts-and-values remaining-atts-and-specs
			    last-att-spec-pair other-spec)
	  (try-prefix-with-other index-atts atts-and-specs case-sensitive)
	(when index-atts-and-values
	  (when *query-trace-p*
	    (trace-query-av :prefix-with-other
			    (if other-spec
				(append index-atts-and-values
					(list (first index-atts-and-values)
					      (second other-spec)))
				index-atts-and-values)))
	  (when *windy-index-checking*
	    (format t "~&Prefix with other found for ~S using~@
                         index ~S~@
                         remaining a's&v's=~S~@[ other-spec=~S~]"
		    as index-atts remaining-atts-and-specs other-spec))
	  (return-from index-check
	    (values #'scan-index-range
		    (let* ((spec (second last-att-spec-pair))
			   (spec-type (first spec)))
		      (cond ((case spec-type
			       (string-prefix-exact case-sensitive)
			       (string-prefix (not case-sensitive)))
			     (when (plusp (string-length (second spec)))
			       (list :not-lessp
				     (apply #'make-key-from-values
					    database index-handle index-atts-and-values)
				     :lessp
				     (apply #'make-next-key-from-values
					    database index-handle index-atts-and-values))))
			    (other-spec
			     ;; Two explicit ends have been provided, so we don't have
			     ;; to worry about null values.
			     (list (get spec-type 'compare-keyword)
				   (apply #'make-key-from-values
					  database index-handle
					  index-atts-and-values)
				   (get (first other-spec) 'compare-keyword)
				   (make-key-from-values database index-handle
							 (first index-atts-and-values)
							 (second other-spec))))
			    ((= (length index-atts-and-values) 2)
			     ;; some type of less or greater than clause
			     ;; on the front of the spec.  This makes
			     ;; use of the knowledge that null-values are
			     ;; the highest value possible.
			     (let ((compare-keyword (get spec-type 'compare-keyword)))
			       (if (or (eq compare-keyword :not-lessp)
				       (eq compare-keyword :greaterp))
				   ;; special case so that we don't get back any
				   ;; null-values in the range comparison.  Need to
				   ;; do the > or  but < *null-value* also.
				   (list compare-keyword
					 (apply #'make-key-from-values
						database index-handle index-atts-and-values)
					 :lessp
					 (apply #'make-key-from-values
						database index-handle
						(progn (setf (second index-atts-and-values)
							     *null-value*)
						       index-atts-and-values)))
				   ;; the args are two: a keyword and a value
				   (list compare-keyword 
					 (apply #'make-key-from-values
						database index-handle
						index-atts-and-values)))))
			    ((member spec-type
				     '(>  >= string> string string>= char> char char>=
				       string-greaterp string-not-lessp
				       char-greaterp char-not-lessp))
			     ;; Comparison match.
			     (list (get spec-type 'compare-keyword)
				   (apply #'make-key-from-values
					  database index-handle index-atts-and-values)
				   :lessp
				   (progn (setf (first (last index-atts-and-values))
						*null-value*)
					  (apply #'make-key-from-values
						 database
						 index-handle
						 index-atts-and-values))))
			    ((member spec-type
				     '(<  <= string< string string<= char< char char<=
				       string-lessp string-not-greaterp
				       char-lessp char-not-greaterp))
			     ;; Comparison match.
			     (list (get spec-type 'compare-keyword)
				   (apply #'make-key-from-values
					  database index-handle index-atts-and-values)))
			    (t (model-bug "Ran out of choices for prefix-with-other"))))
		    remaining-atts-and-specs))))
      (multiple-value-bind (index-atts-and-values remaining-atts-and-specs)
	  (try-prefix-index index-atts atts-and-specs case-sensitive)
	(when index-atts-and-values
	  (when *query-trace-p*
	    (trace-query-av :prefix index-atts-and-values))
	  (when *windy-index-checking*
	    (format t "~&Prefix match found for ~S using~@
                         index ~S~@
                         remaining a's&v's=~S" as index-atts remaining-atts-and-specs))
	  (return-from index-check
	    (values #'scan-index-range
		    (list :not-lessp
			  (apply #'make-key-from-values
				 database index-handle index-atts-and-values)
			  :lessp
			  (apply #'make-next-key-from-values
				 database index-handle index-atts-and-values))
		    remaining-atts-and-specs)))))))

;;; Given a list of attributes in an index and a list of attributes and
;;; specs from a query, determine if all the attributes in the index
;;; have equality specs in the query-atts-and-specs list.  Return (1)
;;; the list of equality atts and values to be used for the
;;; index-lookup, and (2) the list of query atts and specs that weren't
;;; used by the index.  Note that this function mungs the structure of
;;; the query-atts-and-specs arg, so it may be necessary to copy it
;;; before calling.
(defun try-exact-index (index-atts query-atts-and-specs case-sensitive)
  (declare (values index-atts-and-values remaining-query-atts-and-specs))
  (labels ((find-atts (index-atts)
	     (block found-atts
	       ;; Given a list of index-atts, see whether all index-atts
	       ;; have an equality-spec.  If they all do, then remove
	       ;; all the atts and specs from query-atts-and-specs and
	       ;; return a list of the the values that the index-atts
	       ;; must be equal to.  Else leave as untouched and return
	       ;; nil.  If we're dealing with a case-insensitive index,
	       ;; then it is possible to do case-sensitive queries as
	       ;; long as we keep that case-sensitive spec on the
	       ;; rem-atts-and-specs list so that test-spec can verify
	       ;; against case later.
	       (loop with index-att = (car index-atts)
		     with dont-prune-from-specs = nil
		     for (query-att spec) on query-atts-and-specs by #'cddr do
		 (when (and (eq query-att index-att)
			    ;; The index-att is mentioned in the query,
			    ;; but is the spec an equality spec?
			    (if (or case-sensitive
				    (case-insensitive-type-p
				      (attribute-handle-type query-att)))
				(equality-spec-p spec)
				;; The index is case-insensitive, and this attribute has a
				;; concept of case.  If the spec was a string-equal, it's
				;; fine.  If the spec was for strict equality, proceed,
				;; but don't prune the spec.
				(or (case-insensitive-equality-spec-p spec)
				    (setq dont-prune-from-specs
					  (equality-spec-p spec)))))
		   ;; Win, index-att is in the query with an equality spec.
		   (let ((rest-of-answer nil))
		     ;; Recurse to see if we win for the rest of the index-atts.
		     (when (or (null (cdr index-atts))
			       (setq rest-of-answer (find-atts (cdr index-atts))))
		       ;; They've all been found: we have a useful
		       ;; index.  Remove the index atts and
		       ;; corresponding specs from query-atts-and-specs.
		       (loop for prev-sublist = nil then sublist
			     for sublist on query-atts-and-specs by #'cddr do
			 (when (and (eq query-att (first sublist))
				    (eq spec (second sublist)))
			   (cond (dont-prune-from-specs
				  ;; Keep this att and spec on returned list.
				  (return-from found-atts
				    (list* query-att
					   (if (listp spec) (second spec) spec)
					   rest-of-answer)))
				 (t
				  ;; Prune the att/spec pair from query-atts-and-specs.
				  (if (null prev-sublist)
				      (setq query-atts-and-specs (cddr query-atts-and-specs))
				      (setf (cddr prev-sublist) (cddr sublist)))
				  ;; Build up the list of atts and values by reusing the
				  ;; conses of the as list, which are conveniently set up.
				  (setf (second sublist)
					(if (listp spec) (second spec) spec))
				  (setf (cddr sublist) rest-of-answer)
				  (return-from found-atts sublist))))))))))))
    (values (find-atts index-atts) query-atts-and-specs)))

;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")(1) If there is an index on N attributes, for N > 1, and the query
0;;; 1contains equality specs for the first M attributes of the index, for
0;;; 1N  M  1, then that index can take care of all of those specs.

0;;; Given a list of attributes in an index and a list of attributes and
;;; specs, determine which attributes in the prefix of the index have
;;; equality specs in the atts and specs list.  Return (1) the list of
;;; equality specs and values contained in the first M attributes of the
;;; index, (2) the list of atts and specs that weren't used by the
;;; index, and (3) nil if all atts in the index didn't get used.  Note
;;; that this function mungs the structure of the atts-and-specs arg, so
;;; it may be necessary to copy it before calling.

;;; Note that if we're dealing with a case-insensitive index, we can use
;;; it for case-sensitive queries by leaving that att/spec pair on the
;;; remaining-atts-and-specs list for later use by test-spec.

;;; Also note.  We always leave the atts-and-specs on the
;;; remaining-atts-and-specs list.  Consider the case where we have an
;;; index on atts a1 a2 & a3.  Then we pass in the spec [att1
;;; (string-equal "foo")].  If there is an entry in the index for att1
;;; "foobar" and a2, and aa3 anything else, then index-check will
;;; generate :not-lessp "foo" :lessp "fop" which will retrieve "foobar".
;;; Can't have that, so we just use the index to narrow things down.
(defun try-prefix-index (index-atts atts-and-specs case-sensitive)
  (declare (values index-atts-and-values remaining-atts-and-specs))
  (loop for ia in index-atts
	nconc
	  (loop for sublist on atts-and-specs by #'cddr
		for att = (first sublist)
		for spec = (second sublist)
		when (and (eq ia att)
			  (if (or case-sensitive
				  (case-insensitive-type-p (attribute-handle-type att)))
			      (equality-spec-p spec)
			      (or (case-insensitive-equality-spec-p spec)
				  (equality-spec-p spec))))
		  ;; found the att in the index.  add it to the index-atts-and-specs list.
		  do
	    ;; need to make a copy of this att/spec pair for
	    ;; consing onto index-atts-and-values
			(setq sublist (list att spec))
	    ;; trim the tail of the sublist, and convert to an
	    ;; attr/value pair with no equality spec.
		    (setf (cddr sublist) nil)
		    (when (listp spec) (setf (second sublist) (second spec)))
		    (return sublist)
		finally
		  ;; this index att was not found in the query.  finish here.
		  (return-from try-prefix-index
		    (values index-atts-and-values atts-and-specs)))
	  into index-atts-and-values
	finally
	  (model-bug "try-prefix-index found all of them, but that~@
                      should have been done before by try-exact-index.")))

;;; 1(2) If there is an index on N attributes, for N > 1, and the query
0;;; 1contains equality specs for the first N - 1 attributes, and any
0;;; 1index-resolvable spec for the Nth attribute, then that index can
0;;; 1take0 1care of all of those specs.

0;;; Given a list of attributes in an index and a list of attributes and
;;; specs, see if the first n-1 attributes of the index have equality
;;; specs and the nth index attribute has an index-resolvable spec in
;;; the query.  If so, then remove all of the index's attributes from
;;; the atts-and-specs list and return them with the appropriate values
;;; from the query.  The second value returned is the list of remaining
;;; atts/vals specs that couldn't be used in this query.  The third
;;; value is returned for convenience and is the last attribute and spec
;;; pair in the list.  atts-and-specs is modified, so the caller may
;;; need to copy it before calling.  The first value returned also
;;; includes the last-att-spec-pair.  The fourth value is used if
;;; there were no equality specs, just the inequality spec, and we
;;; also found another inequality spec in the other direction for the
;;; same attribute.  This lets us do two-ended range queries.  The fourth
;;; value is the second spec; there's no need to return the attribute
;;; since it's the same as for the other inequality.
(defun try-prefix-with-other (index-atts atts-and-specs case-sensitive)
  (declare (values index-atts-and-values remaining-atts-and-specs
		   last-att-spec-pair other-spec))
  (let ((last-index-att (first (last index-atts))))
    ;; just check if the spec for the last index att is index-resolvable
    (cl:loop with dont-prune-from-specs = nil
	  for (att spec) on atts-and-specs by #'cddr do
      (when (and (eq att last-index-att)
		 (if (or case-sensitive
			 (case-insensitive-type-p (attribute-handle-type att)))
		     (or (equality-spec-p spec)
			 (and (listp spec)
			      (or (member (first spec) '(> <   >= <= string< string>
							 string string>= string string<=
							 char< char> char char>=
							 char char<=))
				  (eq (first spec) 'string-prefix-exact))))
		     (or (case-insensitive-equality-spec-p spec)
			 (and (listp spec)
			      (setq dont-prune-from-specs
				    (or (member (first spec)
						'(string-greaterp string-lessp
						  string-not-lessp string-not-greaterp
						  char-greaterp char-lessp
						  char-not-lessp char-not-greaterp))
					(eq (first spec) 'string-prefix)))))))
	;; last spec is i-r.  Go ahead and try for equality specs on first N attrs
	(multiple-value-bind (index-atts-and-values remaining-atts-and-specs)
	    (try-exact-index (butlast index-atts) atts-and-specs case-sensitive)
	  (when (or index-atts-and-values (= (length index-atts) 1))
	    ;; equality specs found for first N - 1 index atts were found
	    ;; Have to remove the spec for the last-index-att from
	    ;; the remaining atts and specs and add it to the index-atts-and-values.
	    (loop for prev-sublist = nil then sublist
		  for sublist on remaining-atts-and-specs by #'cddr do
	      (when (eq (first sublist) last-index-att)
		(cond (dont-prune-from-specs)
		      (t
		       (if prev-sublist
			   (setf (cddr prev-sublist) (cddr sublist))
			   (setf remaining-atts-and-specs (cddr sublist)))
		       (setf (cddr sublist) nil)))
		(let ((other-spec
			;; Search for another att-spec pair for the same att where
			;; an opposite spec is used.  If we find one, possibly prune
			;; it from the specs, and return the spec.
			(when (and (null index-atts-and-values) (listp spec))
			  (let ((inverse-operators
				  (cond ((member (first spec) *greater-than-operators*)
					  *less-than-operators*)
					((member (first spec) *less-than-operators*)
					 *greater-than-operators*))))
			    (when inverse-operators
			      (cl:loop for prev-xsublist = nil then xsublist
				    for xsublist on remaining-atts-and-specs by #'cddr do
				(when (and (eq (first xsublist) att)
					   (listp (second xsublist))
					   (member (first (second xsublist))
						   inverse-operators))
				  (unless dont-prune-from-specs
				    (if prev-xsublist
					(setf (cddr prev-xsublist) (cddr xsublist))
					(setf remaining-atts-and-specs (cddr xsublist))))
				  (return (second xsublist)))))))))
		  (return-from try-prefix-with-other
		    (values (nconc index-atts-and-values
				   (list last-index-att (if (listp spec) (second spec) spec)))
			    remaining-atts-and-specs
			    sublist
			    other-spec)))))))))))

;;; Assumes that data stack is bound before calling.  Return a rid array
;;; for relation-handle in which all rids are for tuples matching
;;; the specs in where and are ordered by the specs in order-by.  Use
;;; indexes if any are applicable.  Probably map-relation should use
;;; this.
(defun find-rid-array (relation-handle where order-by)
  (cond (order-by
	 (find-rid-array-sorted	relation-handle where order-by))
	(t
	 (multiple-value-bind (rid-arrays rest-of-attributes-and-specs)
	     (find-useful-indexes relation-handle where)
	   (if (null rid-arrays)
	       ;; No index does any good.  So do it the slow way; map
	       ;; over all tuples.
	       (find-rid-array-for-relation relation-handle where)
	       ;; There were one or more useful indexes.
	       (let ((rid-array (intersect-rid-arrays rid-arrays)))
		 (declare (sys:array-register rid-array))
		 (when rest-of-attributes-and-specs
		   (let* ((database (relation-handle-database relation-handle))
			  (opening (database-opening database)))
		     (dotimes (i (length rid-array))
		       (let ((rid (aref rid-array i)))
			 (unless (zerop rid)
			   (with-record (addressor opening rid :read)
			     (unless (test-tuple addressor
						 relation-handle
						 rest-of-attributes-and-specs
						 rid)
			       (setf (aref rid-array i) 0))))))))
		 rid-array))))))

;;; Given a relation-handle, return an array of rids in the relation
;;; which meet the where specs.  The caller should do a
;;; sys:with-data-stack before calling.
(defun find-rid-array-for-relation (relation-handle where)
  (when *query-trace-p*
    (push (list :rid-array-all) *query-trace-list*))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 array)
    (cond ((not (fast-string= (relation-handle-name relation-handle) "%%entity-domain"))
	   ;; This is a surrogate-optimized relation.  Search through the entities.
	   (setq array (sys:make-stack-array 100 :fill-pointer 0))
	   (map-over-tuples
	     relation-handle
	     #'(lambda (ent tuple-rid version)
		 (declare (ignore ent version))
		 (with-record (tuple opening tuple-rid :read)
		   (when (test-tuple tuple relation-handle where tuple-rid)
		     (vector-push-extend tuple-rid array 100))))))
	  (t
	   ;; This is the Entity-Domain system relation.  What that really means is
	   ;; that we are to iterate over all entities in the database.
	   (setq array (sys:make-stack-array 100 :fill-pointer 0))
	   (do-domains (domain-handle database)
	     (map-over-entity-records
	       domain-handle
	       #'(lambda (ent-rid)
		   (vector-push-extend ent-rid array 100))))))
    (adjust-array array (fill-pointer array))
    array))

;;; gets the attribute handle out of an order-by attribute spec.  in a
;;; :order-by, the specs take the form of either (attribute direction)
;;; or ((key attribute) direction).  The key doesn't seem to be too
;;; useful just yet.
(defsubst order-by-att (attribute-spec)
  (if (listp attribute-spec) (second attribute-spec) attribute-spec))

;;; The main entry for joins.  Call function for each set of tuples
;;; from the relations in relation-handles which match the specs in where
;;; and sorted by order-by.  relation-handles' form is 
;;; ((var relation-handle) (var relation-handle) ...).  function is called with
;;; a plist of the vars from relation-handles and the corresponding tuples.
;;; It is function's responsibility to pull out the tuples from the plist.
(defun map-relations-joined (function relation-handles where order-by &optional count)
  (declare (sys:downward-funarg function))
  (restart-testing-check)
  (check-attribute-types relation-handles where order-by)
  (when count (check-type count integer))
  ;; relation-specs starts as just the list of vars.
  (let* ((relation-specs (cl:loop for (var) in relation-handles
			       collect (list var)))
	 (join-specs (cl:loop for (var) in relation-handles
			       collect (list var))))
    ;; Seperate the :where specs into join specs and specs which are applied
    ;; to individual relations.  If the former, then tack them onto 1join-specs0;
    ;; if the former, then put them on the relation-specs alist.
    (cl:loop for (att spec) on where by #'cddr do
      (let ((spec-att (and spec (if (listp spec) (order-by-att (second spec)) spec))))
	(cond ((or (and spec-att (typep spec-att 'attribute-handle))
		   (typep spec 'attribute-handle))
	       ;; a join spec -- put on both relation's join-specs
	       (let ((spec-list-1 (assoc (car (find (attribute-handle-relation
						      (order-by-att att))
						    relation-handles
						    :key #'second))
					 join-specs))
		     (spec-list-2 (assoc (car (find (attribute-handle-relation spec-att)
						    relation-handles
						    :key #'second))
					 join-specs)))
		 (setf (cdr spec-list-1) (list* att spec (cdr spec-list-1)))
		 (setf (cdr spec-list-2) (list* att spec (cdr spec-list-2)))))
	      (t
	       ;; a "normal" where spec
	       (if (listp att)
		   ;; we have a (key att-handle) form for attribute
		   (let ((spec-list (assoc (first att) relation-specs)))
		     (setf (cdr spec-list) (list* (second att) spec (cdr spec-list))))
		   ;; we have a simple attribute-handle
		   (let* ((r-key (cl:loop for (key r-h) in relation-handles
				       with att-relation = (attribute-handle-relation att)
				       when (eq r-h att-relation)
					 return key))
			  (spec-list (assoc r-key relation-specs)))
		     (setf (cdr spec-list) (list* att spec (cdr spec-list)))))))))
    ;; relation-specs now contains an alist of var with any :where specs
    ;; which apply to that relation.  Convert the specs to a rid array.
    ;; The rid array contains the rids of all tuples in that relation which
    ;; match the specs.  While we're at it, we can do the :order-by specs.
    ;; If we have a complex sort, then we only take the first group of attributes
    ;; and specs for each relation.
    (sys:with-data-stack
      (cl:loop for relation-and-specs in relation-specs do
	(when (cdr relation-and-specs)
	  (let ((relation-handle (second (assoc (first relation-and-specs) relation-handles))))
	    (setf (cdr relation-and-specs)
		  (find-rid-array relation-handle (cdr relation-and-specs) nil)))))
      (let* ((*joined-tuple-rids* nil)
	     (rt *restart-testing*)
	     (iteration-count 0)
	     (rt-function
	       (if rt
		   #'(zl:named-lambda map-relation-restart-testing-internal (&rest args)
		       (let ((*restart-testing* (or (and (eq rt :all) rt)
						    (and (eq rt :some)
							 (zerop iteration-count)
							 :some))))
			 (apply function args)
			 (incf iteration-count)))
		   function)))
	;; a simple join.  Recursively walk down through the rid-arrays
	;; taking the cross product.
	(let ((actual-count 0))
	  ;; sort so that relations that had :where specs and have rid arrays are first
	  (setq relation-specs (sort relation-specs #'(lambda (x y)
							(declare (ignore y))
							x)
				     :key #'cdr))
	  (block nil
	    (cond (order-by
		   (sys:with-stack-array (join-array 1000 :fill-pointer 0)
		     (declare (sys:array-register join-array))
		     (map-one-relation-of-join
		       #'(lambda (joined-tuple-rids)
			   (declare (sys:downward-function))
			   (vector-push-extend
			     (copy-list joined-tuple-rids) join-array))
		       relation-specs
		       relation-handles
		       join-specs)
		     (sort join-array
			   #'(lambda (x y)
			       (tuple-set-lessp x y order-by relation-handles)))
		     (dotimes (i (length join-array))
		       (funcall rt-function (aref join-array i)))))
		  (t
		   (map-one-relation-of-join
		     ;; have to do it this way because m-o-r-o-j is recursive
		     #'(lambda (joined-tuple-rids)
			 (declare (sys:downward-function))
			 (funcall rt-function joined-tuple-rids)
			 (when count
			   (incf actual-count)
			   (unless (< actual-count count)
			     (return nil))))
		     relation-specs
		     relation-handles
		     join-specs)))))))))

;;; The main workhorse for joins.  Calls function for each set of tuples
;;; in the join.  relation-specs is of the form ((var . rid-array) (var
;;; . rid-array) ...).  relation-handles is ((var relation-handle) (var
;;; relation-handle) ...).  join specs is of the form (att spec att spec
;;; ...) where att is either an attribute or a list of a var and an
;;; attribute.  Spec is either an attribute, a list of a var and an
;;; attribute, or a list of an operator and an attribute (where
;;; attribute might be an attribute or a list of a var and an
;;; attribute).  This recursively forms the cross product of the rid
;;; arrays and checks join specs during the recursion.
(defun map-one-relation-of-join (function relation-specs relation-handles join-specs)
  (declare (sys:downward-funarg function))
  (destructuring-bind ((key . rid-array) . rest-of-relations) relation-specs
    (unless rid-array
      (multiple-value-bind (where-specs forget-it)
	  (make-where-specs-for-join key join-specs relation-handles)
	(when forget-it
	  (return-from map-one-relation-of-join nil))
	(setq rid-array
	      (find-rid-array (second (find key relation-handles :key #'first :test #'eq))
			      where-specs nil))))
    (let ((rid-array rid-array))
      (declare (sys:array-register rid-array))
      (dotimes (i (length rid-array))
	(let ((rid (aref rid-array i)))
	  (unless (zerop rid)
	    (with-stack-list* (*joined-tuple-rids* key rid *joined-tuple-rids*)
	      ;; loop through the join specs that may apply to the tuple
	      ;; that we are iterating over and see if it meets the criteria.
	      (when (do-join-specs join-specs relation-handles key)
		(if rest-of-relations
		    (map-one-relation-of-join
		      function rest-of-relations relation-handles join-specs)
		    (funcall function *joined-tuple-rids*))))))))))

;;; Given a key (a var for a relation), find all the where specs in join-specs
;;; which are associated with the relation spec'd by this key.  Note that only
;;; join-specs for which the other part (i.e. the half of the spec not spec'd
;;; by key) has already been put on the *joined-tuple-rids* list can be done.
(defun make-where-specs-for-join (key join-specs relation-handles)
  (let ((relation-join-specs (cdr (assoc key join-specs)))
	where-specs)
    (when relation-join-specs
      (cl:loop for (att spec) on relation-join-specs by #'cddr do
	(multiple-value-bind (left-key left-attribute operator right-key right-attribute)
	    (destructure-att-spec att spec relation-handles)
	  (let ((right-rid (getf *joined-tuple-rids* right-key))
		(left-rid (getf *joined-tuple-rids* left-key)))
	    (or (and (eq left-key key)
		     right-rid
		     (push (list operator
				 (let* ((relation-handle
					  (attribute-handle-relation right-attribute))
					(database (relation-handle-database relation-handle))
					(opening (database-opening database))
					(value
					  (get-value-given-tuple-rid
					    right-rid relation-handle right-attribute
					    database opening :rid)))
				   (unless (statice-typep
					     (attribute-handle-type left-attribute)
					     value)
				     (return-from make-where-specs-for-join (values nil t)))
				   value))
			   where-specs)
		     (push left-attribute where-specs))
		(and (eq right-key key)
		     left-rid
		     (push (list (cdr (assoc operator *operator-inverse*))
				 (let* ((relation-handle
					  (attribute-handle-relation left-attribute))
					(database (relation-handle-database relation-handle))
					(opening (database-opening database))
					(value
					  (get-value-given-tuple-rid
					    left-rid relation-handle left-attribute
					    database opening :rid)))
				   (unless (statice-typep
					     (attribute-handle-type right-attribute)
					     value)
				     (return-from make-where-specs-for-join (values nil t)))
				   value))
			   where-specs)
		     (push right-attribute where-specs)))))))
    where-specs))

(defun do-join-specs (join-specs relation-handles key)
  (cl:loop for (att spec) on (cdr (assoc key join-specs)) by #'cddr 
    always
      (multiple-value-bind (left-key left-attribute operator right-key right-attribute)
	  (destructure-att-spec att spec relation-handles)
	(let* ((left-rid (getf *joined-tuple-rids* left-key))
	       (right-rid (getf *joined-tuple-rids* right-key)))
	  (or (null left-rid)
	      (null right-rid)
	      (let* ((left-relation (attribute-handle-relation left-attribute))
		     (right-relation (attribute-handle-relation right-attribute))
		     (left-database (relation-handle-database left-relation))
		     (right-database (relation-handle-database right-relation))
		     (left-opening (database-opening left-database))
		     (right-opening (database-opening right-database))
		     (left-soo (relation-handle-surrogate-optimized-on left-relation))
		     (right-soo (relation-handle-surrogate-optimized-on right-relation))
		     (compare-keywords (get operator 'compare-keywords-list)))
		(with-record (r1 left-opening left-rid :read)
		  (with-record (r2 right-opening right-rid :read)
		    (let* ((desc1 (let ((desc (attribute-handle-descriptor left-attribute)))
				    (if left-soo
					(when desc
					  (search-table-for-domain
					    desc (find-domain-handle-given-entity-rid
						   left-rid left-database)))
					desc)))
			   (desc2 (let ((desc (attribute-handle-descriptor right-attribute)))
				    (if right-soo
					(when desc
					  (search-table-for-domain
					    desc (find-domain-handle-given-entity-rid
						   right-rid right-database)))
					desc)))
			   (left-type (attribute-handle-type left-attribute)))
		      ;; check for a match on the join specs
		      (cond (compare-keywords
			     (member (record-compare left-type
						     r1 r2
						     desc1 desc2
						     left-database right-database)
				     compare-keywords
				     :test #'eq))
			    (t
			     ;; it was an equality spec.  If we are involved
			     ;; with a soo-att comparison, then we must use
			     ;; value-equal.
			     (let ((left-is-soo (eq left-soo left-attribute))
				   (right-is-soo (eq right-soo right-attribute)))
			       (cond ((and left-is-soo right-is-soo)
				      ;; both atts were soo-atts. compare uids
				      (if (eq left-database right-database)
					  ;; easy case-compare rids
					  (= left-rid right-rid)
					  ;; hard case -- compare uids
					  (and (= (entity-uid-word-1 r1)
						  (entity-uid-word-1 r2))
					       (= (entity-uid-word-2 r1)
						  (entity-uid-word-2 r2))
					       (= (entity-uid-word-3 r1)
						  (entity-uid-word-3 r2)))))
				     ((or left-is-soo right-is-soo)
				      ;; only one att was soo-att -- have to
				      ;; cons an entity-handle and use
				      ;; value-equal
				      (let (type addressor descriptor value database)
					(if left-is-soo
					    (setq type (attribute-handle-type right-attribute)
						  addressor r2
						  descriptor desc2
						  value
						  (find-entity-handle-given-rid
						    left-rid left-database)
						  database right-database)
					    (setq type left-type
						  addressor r1
						  descriptor desc1
						  value
						  (find-entity-handle-given-rid
						    right-rid right-database)
						  database left-database))
					(value-equal
					  type addressor descriptor value database)))
				     (t
				      ;; neither was soo-att
				      (record-equal left-type r1 r2 desc1 desc2)))))))))))))))

;;; compare two tuple-sets which consist of a var/rid style plist.
(defun tuple-set-lessp (x y order-by relation-handles)
  (cl:loop for (att direction) in order-by do
    ;; we have to get the database each time since the attributes might
    ;; be coming from different databases.
    (let* ((att (order-by-att att))
	   (relation (attribute-handle-relation att))
	   (soo-att (relation-handle-surrogate-optimized-on relation))
	   (database (relation-handle-database relation))
	   (key (cl:loop for (key relation-handle) in relation-handles
		      when (eq relation relation-handle)
			return key))
	   (x-rid (or (getf x key) (model-bug "no x-rid found")))
	   (y-rid (or (getf y key) (model-bug "no y-rid found"))))
      (ecase (compare-records-using-rids x-rid y-rid att database soo-att)
	(:equal)
	(:lessp (return (eq direction :ascending)))
	(:greaterp (return (eq direction :descending)))))))

;;; Break an att spec pair into left variable, left-attribute, the
;;; spec's operator and the right variable and right attribute.  Not a
;;; simple destructure since att might be either attribute or (var
;;; attribute).  Same for spec part.
(defun destructure-att-spec (att spec relation-handles)
  (declare (values left-key left-attribute operator right-key right-attribute))
  (let (left-key left-attribute operator right-key right-attribute)
    (if (listp att)
	(setq left-key (first att)
	      left-attribute (second att))
	(setq left-key (cl:loop for (key r-h) in relation-handles
			     with att-relation = (attribute-handle-relation att)
			     when (eq r-h att-relation)
			       return key
			     finally
			       (error "Attribute ~S is not from any of the~@
                                                     argument relations"
				      att))
	      left-attribute att))
    (if (listp spec)
	(let ((attribute-part (second spec)))
	  (if (listp attribute-part)
	      ;; have (op (key att))
	      (setq operator (first spec)
		    right-key (first attribute-part)
		    right-attribute (second attribute-part))
	      ;; have either (key att) or (op att)
	      (cond ((member (first spec) *operators*)
		     (setq operator (first spec)
			   right-attribute attribute-part
			   right-key (cl:loop for (key r-h) in relation-handles
					   with att-relation =
					     (attribute-handle-relation attribute-part)
					   when (eq r-h att-relation)
					     return key
					   finally
					     (error "Attribute ~S is not from any of the~@
                                                     argument relations"
						    attribute-part))))
		    (t (setq operator 'equal
			     right-key (first spec)
			     right-attribute attribute-part)))))
	;; spec is just an attribute
	(let ((right-relation (attribute-handle-relation spec)))
	  (setq right-attribute spec
		right-key (cl:loop for (key r-h) in relation-handles
				when (eq r-h right-relation)
				  return key
				finally
				  (error "Attribute ~S is not from any of~@
                                                     the argument relations"
					 att))
		operator 'equal)))
    (values left-key left-attribute operator right-key right-attribute)))

;;; Compare the tuples as specified by rid-1 and rid-2 in database.  Return
;;; t is value 1 < value 2.  nil otherwise.
(defun compare-records-using-rids (rid-1 rid-2 att database soo-att)
  (let ((opening (database-opening database)))
    (with-record (addressor-1 opening rid-1 :read)
      (with-record (addressor-2 opening rid-2 :read)
	(let* ((att-version (attribute-handle-layout-version att))
	       (no-1 (> (if soo-att
			    (or (search-table-for-domain
				  att-version
				  (find-domain-handle-given-entity-rid
				    rid-1 database)
				  :if-not-found nil)
				-1)
			    att-version)
			(if soo-att
			    (local-entity-version addressor-1)
			    (tuple-version addressor-1))))
	       (no-2 (> (if soo-att
			    (or (search-table-for-domain
				  att-version
				  (find-domain-handle-given-entity-rid
				    rid-2 database)
				  :if-not-found nil)
				-1)
			    att-version)
			(if soo-att
			    (local-entity-version addressor-2)
			    (tuple-version addressor-2)))))
	  (if no-1
	      (if no-2 :equal :greaterp)
	      (if no-2
		  :lessp
		  (record-compare
		    (attribute-handle-type att)
		    addressor-1
		    addressor-2
		    (let ((desc (attribute-handle-descriptor att)))
		      (if soo-att
			  (search-table-for-domain
			    desc
			    (find-domain-handle-given-entity-rid
			      rid-1
			      database))
			  desc))
		    (let ((desc (attribute-handle-descriptor att)))
		      (if soo-att
			  (search-table-for-domain
			    desc
			    (find-domain-handle-given-entity-rid
			      rid-2
			      database))
			  desc))
		    database
		    database))))))))

;;; Call function once for each entity in the specified domain. 
;;; Function is a function of one argument, the entity rid.  If there is
;;; a bset for the domain, use it.  Otherwise, do an area walk comparing
;;; the entity-domain field to the domain-handle's rid.
(defun map-over-entity-records (domain-handle function)
  (declare (sys:downward-funarg function))
  (let* ((database (domain-handle-database domain-handle))
	 (opening (database-opening database))
	 (bid (domain-handle-bset-iid domain-handle)))
    (cond (bid
	   ;; Have a b-set.  Use it.
	   (when *windy-index-checking*
	     (format t "~&b-set used for scan over domain ~S" domain-handle))
	   (when *query-trace-p*
	     (push (list :domain-index (domain-handle-name domain-handle))
		   *query-trace-list*))
	   (map-over-bset opening bid function))
	  (t
	   ;; no b-set.  map over the domain's area looking for the entities
	   (when *windy-index-checking*
	     (format t "~&area scan for domain ~S" domain-handle))
	   (when *query-trace-p*
	     (push (list :domain-area-scan (domain-handle-name domain-handle))
		   *query-trace-list*))
	   (let ((dom-rid (handle-rid domain-handle)))
	     (map-over-area opening
			    (domain-handle-area domain-handle)
			    #'(lambda (rid)
				(when (= (with-record (e opening rid :read)
					   (entity-domain e))
					 dom-rid)
				  (funcall function rid)))))))))

;;; Call function on all the tuples of relation-handle.  The
;;; first argument is the record's rid.  The record will always be a
;;; tuple record (as opposed to an entity record which has
;;; tuples optimzied onto it).  If there is a b-set for the
;;; relation, use it.  Otherwise, do an area walk.  The caller agrees to
;;; do the check for relation-handle being surrogate optimized (and will
;;; not call this if it is).
(defun map-over-tuple-records (relation-handle function)
  (declare (sys:downward-funarg function))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (bid (relation-handle-bset-iid relation-handle)))
    (cond (bid
	   ;; Have b-set, will travel.
	   (when *windy-index-checking*
	     (format t "~&Mapping relation ~S with b-set" relation-handle))
	   (when *query-trace-p*
	     (push (list :relation-index (relation-handle-name relation-handle))
		   *query-trace-list*))
	   (map-over-bset opening bid function))
	  (t
	   (let ((rel-rid (handle-rid relation-handle)))
	     ;; no bset.  Gotta map over the area.
	     (when *windy-index-checking*
	       (format t "~&area scan for relation ~S" relation-handle))
	     (when *query-trace-p*
	       (push (list :relation-area-scan
			   (relation-handle-name relation-handle))
		     *query-trace-list*))
	     (map-over-area opening
			    (relation-handle-area relation-handle)
			    #'(lambda (rid)
				(when (= rel-rid (with-record (r opening rid :read)
						     (tuple-relation r)))
				  (funcall function rid)))))))))

;;; Call function on all the tuples of relation-handle.  The
;;; first argument is the record, the second argument is the record's
;;; RID, the third is the record's version.  The record might be a
;;; tuple record or an entity record.  If there is a b-set for
;;; the relation (or domain in the soo-att case), use it.  Otherwise, do
;;; an area walk.
(defun map-over-tuples (relation-handle function)
  (declare (sys:downward-funarg function))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (cond ((null soo-att)
	   (map-over-tuple-records
	     relation-handle
	     #'(lambda (rid)
		 (with-record (tuple opening rid :read)
		   (funcall function tuple rid (tuple-version tuple))))))
	  (t
	   ;; This is a surrogate-optimized relation.  Search through the entities.
	   (let ((soo-domain (attribute-handle-type soo-att)))
	     (do-children (domain-handle soo-domain database)
	       (let ((byte-spec
		       (byte 1 (search-table-for-domain
				 (relation-handle-entity-bit-map-number relation-handle)
				 domain-handle))))
		 (map-over-entity-records
		   domain-handle
		   #'(lambda (rid)
		       (with-record (ent opening rid :read)
			 (when (= (ldb byte-spec
				       (local-entity-tuples-present ent))
				  1)
			   (funcall
			     function ent rid (local-entity-version ent)))))))))))))

;;; Given a relation-handle, a list of retrieval specs (the where arg),
;;; a list of sort specs (the order-by arg), and a function, call the
;;; function with the tuple handles of each tuple in the
;;; relation which meets the specs in where, in the order specified by
;;; order-by.
;;; If attribute-handle is supplied, then apply function to the value of
;;; attribute-handle in the tuples and not-null-p so as to avoid consing a tuple-handle.
;;; The caller gaurantees that attribute-handle is from relation.
(defun map-relation-sorted (function relation-handle attribute-handle where order-by count)
  (declare (sys:downward-funarg function))
  (sys:with-data-stack
    (let* ((rid-array (find-rid-array-sorted relation-handle where order-by))
	   (database (when attribute-handle (relation-handle-database relation-handle)))
	   (opening (when database (database-opening database)))
	   (actual-count 0))
      (declare (sys:array-register rid-array))
      (dotimes (i (length rid-array))
	(let ((rid (aref rid-array i)))
	  (when (plusp rid)
	    (if attribute-handle
		(multiple-value-bind (value not-null-p)
		    (get-value-given-tuple-rid
		      rid relation-handle attribute-handle database opening :rid)
		  (funcall function value not-null-p))
		(funcall function
			 (find-tuple-handle-given-rid rid relation-handle)))
	    (when count
	      (incf actual-count)
	      (unless (< actual-count count)
		(return nil)))))))))

;;; Same contract as find-rid-array, only this is doing the work for it
;;; when there is an order-by.
(defun find-rid-array-sorted (relation-handle where order-by)
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (testing-not-needed nil))
    ;; First try to use indexes for sorting purposes.
    (multiple-value-bind (sort-rid-array remaining-where-specs
			  remaining-sort-specs direction)
	(find-useful-indexes-for-sorting relation-handle where order-by)
      ;; Next try to use indexes on any remaining where specifications
      ;; which remain after the sort indexes were used.
      (multiple-value-bind (rid-arrays remaining-where-specs)
	  (when remaining-where-specs 
	    (find-rid-array relation-handle remaining-where-specs nil))
	(declare (sys:array-register rid-arrays))
	(if sort-rid-array
	    (if rid-arrays
		(setq rid-arrays (with-stack-list (rid-arrays sort-rid-array rid-arrays)
				   (intersect-rid-arrays-preserving-order rid-arrays)))
		;; Index only found for sorting.
		(setq rid-arrays sort-rid-array))
	    (unless rid-arrays
	      (setq testing-not-needed t
		    rid-arrays (find-rid-array-for-relation relation-handle where))))
	;; If a sorting index was found, then we must walk the
	;; sort-rid-array in the order specified.
	(cond ((null sort-rid-array)
	       (sort-chunk relation-handle order-by remaining-where-specs rid-arrays 0
			   (length rid-arrays))
	       rid-arrays)
	      (rid-arrays
	       ;; Find chunks of rids, sort each chunk based on other-atts, and call function.
	       (cl:loop with rid-array-length = (length rid-arrays)
		     with i = 0
		     while (< i rid-array-length) do
		 (let ((limit (cl:loop for j from i do
				(when (or ( j rid-array-length)
					  (zerop (aref rid-arrays j)))
				  (return j)))))
		   ;; The section from i below limit is a chunk.
		   (cond ((= (1+ i) limit)
			  (let ((rid (aref rid-arrays i)))
			    (unless (or testing-not-needed
					(with-record (rel opening rid :read)
					  (test-tuple
					    rel relation-handle remaining-where-specs rid)))
			      (setf (aref rid-arrays i) 0))))
			 (t (sort-chunk relation-handle remaining-sort-specs
					remaining-where-specs rid-arrays i limit)))
		   (setq i (1+ limit))))
	       (if (eq direction :descending) (nreverse rid-arrays) rid-arrays))
	      (t
	       (sys:make-stack-array 0 :type 'zl:art-fixnum)))))))

;;; Given a list of arrays of rids, return an array containing the
;;; intersection of the rids.  The returned array is the first one in
;;; the list, and the order of the elements is preserved.
(defun intersect-rid-arrays-preserving-order (rid-arrays)
  (cond ((null (cdr rid-arrays))
	 ;; Optimize a common case: if there's only one, return it.
	 (first rid-arrays))
	(t
	 (let* ((rid-array (first rid-arrays))
		(size (length rid-array)))
	   ;; Only if there is something worth intersecting
	   (when (cl:loop for r in rid-arrays
		       never (zerop (length r)))
	     ;; Pairwise intersect rid-array with each of the others.
	     (let ((rid-array rid-array))
	       (declare (compiler:array-register rid-array))
	       (dolist (other (cdr rid-arrays))
		 (let ((other other))
		   (declare (compiler:array-register other))
		   (sort other #'<)
		   (let ((other-length (length other)))
		     (dotimes (i size)
		       (let ((rid (aref rid-array i))
			     (other-idx 0))
			 ;; If we can't find the value rid in the other
			 ;; array, then zap it by storing a zero.
			 (unless (cl:loop until ( other-idx other-length) do
				   (let ((other-rid (aref other other-idx)))
				     (when (= other-rid rid)
				       (incf other-idx)
				       (return t))
				     (when (> other-rid rid)
				       (return nil)))
				   (incf other-idx))
			   (setf (aref rid-array i) 0)))))))
	       rid-array))))))

;;; Sort the chunk of rid-array.  The tuples are all from the
;;; specified relation.  The list other-atts is a list of attributes of
;;; that relation, and the sorting order which should be performed on
;;; these attributes.  The chunk is a section of rid-array between i and
;;; (exclusive!) j.  The caller guarantees that other-atts are all
;;; comparable, which means that none of the other-atts is the soo-att
;;; (entities are not comparable).  If j < i, then the array should be
;;; walked backwards (i.e. always from i up/downto j).
(defun sort-chunk (relation-handle other-atts where rid-array i j)
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    ;; If descending order is asked for, then copy the array backwards.
    (when (> i j)
      (incf j)
      (decf i)
      (rotatef i j))
    (let* ((array-length (- j i))
	   (new-array (sys:make-stack-array array-length
					    :displaced-to rid-array
					    :displaced-index-offset i)))
      (declare (sys:array-register new-array))
      (when where
	(dotimes (from-index array-length)
	  (let ((rid (aref new-array from-index)))
	    (when (and rid (plusp rid))
	      (with-record (rel opening rid :read)
		(unless (test-tuple rel relation-handle where rid)
		  (setf (aref new-array from-index) 0)))))))
      (when other-atts
	(sort new-array
	      ;; This is a normal relation.  The rids point into tuple handles.
	      #'(lambda (rid-1 rid-2)
		  (block doit
		    (cond ((zerop rid-1)
			   (return-from doit (eq (second (first other-atts)) :ascending)))
			  ((zerop rid-2)
			   (return-from doit (eq (second (first other-atts)) :descending)))
			  (t
			   (cl:loop for (att direction) in other-atts do
			     (ecase (compare-records-using-rids
				      rid-1 rid-2 (order-by-att att) database soo-att)
			       (:equal)
			       (:lessp (return (eq direction :ascending)))
			       (:greaterp (return (eq direction :descending)))))))))))
      new-array)))

;;; Given a relation-handle, a list of retrieval specs (the where
;;; clause), and a list of sorting specifications (the order-by
;;; clause), try to find some useful indexes for performing the sort.
;;; The values returned are a rid array (or nil if no useful indexes
;;; were found), the rest of the where clause, and the rest of the sort
;;; clauses which weren't used.  Since the where and order-by clauses
;;; may be modified, the caller may want to copy them beforehand.
(defun find-useful-indexes-for-sorting (relation-handle where order-by)
  (declare (values sort-rid-array remaining-where-specs remaining-sort-specs direction))
  (let* ((indexes (relation-handle-list-of-indexes relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database)))
    ;; Try a suffix index for sorting
    (multiple-value-bind (index-function args remaining-where-specs direction)
	(try-suffix-sort-index indexes where order-by database)
      (when index-function
	(return-from find-useful-indexes-for-sorting
	  (values (apply index-function opening args)
		  remaining-where-specs
		  nil
		  direction))))
    ;; No suffix index.  Try a prefix index.
    (multiple-value-bind (index-function args remaining-sort-specs direction)
	(try-prefix-sort-index indexes order-by)
      (when index-function
	(return-from find-useful-indexes-for-sorting
	  (values (apply index-function opening args)
		  where
		  remaining-sort-specs
		  direction))))
    ;; no index useful for sorting
    (values nil where order-by :ascending)))

;;; 1If there is an index I on N attributes, and there is an :order-by
0;;; 1clause0 1that has a list of M attributes for M  N, and the last M
0;;; 1attributes of0 1I are the same as the M attributes in the :order-by
0;;; 1clause, and for each0 1of the first N - M attributes there is an
0;;; 1equality spec in the :where0 1clause, then this is a relevant index.
0;;; 1If there is more than one such0 1relevant index, pick the one for
0;;; 1which N is smallest.  We merge the RID0 1arrays, but in such a way as
0;;; 1to preserve the order of index I.  We then0 1retrieve each of the
0;;; 1surviving records, and apply the remaining specs to0 1knock out any
0;;; 1that don't qualify, again preserving order.  Now there's0 1no need for
0;;; 1a sorting phase; it's all done.

0;;; 1"special case to make LMFS fast"

0;;; Given a list of indexes, a list of att/spec pairs (the where
;;; clause), and a list of order-by clauses (atts and directions),
;;; find the indexes in the list such that the order-by clauses form a
;;; suffix on the list of index attributes, and each of the attributes
;;; in the prefix of the list of index attributes (after the order-by
;;; attributes are removed) has an equality spec in the :where clause.
;;; If such an index is located, then the sorting is all finished.
;;; Since the sorting phase is all done, there is no need to return a
;;; modified order-by list.  All order-by clauses in the prefix must
;;; be in the same direction.
(defun try-suffix-sort-index (indexes where order-by database)
  (declare (values index-function args remaining-where-specs direction))
  (let ((direction nil))
    ;; Check to see that all order-by specs are in the same direction.
    (and (cl:loop for (nil dir) in order-by
	       with first-direction = nil
	       unless first-direction
		 do (setq first-direction dir)
	       when (not (eql first-direction dir))
		 do (return nil)
	       finally
		 (setq direction first-direction)
		 (return t))
	 (let ((n-sort-atts (length order-by))
	       (sort-atts (cl:loop for (att) in order-by
				collect (order-by-att att)))
	       (best-index nil)
	       (best-index-prefix-length 0)
	       (best-index-loa nil))
	   (cl:loop while indexes do
	     (let* ((index (car indexes))
		    (index-loa (index-handle-list-of-attributes index))
		    (prefix-length (- (length index-loa) n-sort-atts))
		    (case-sensitive (index-handle-case-sensitive index)))
	       (and (not (minusp prefix-length))
		    (equal (nthcdr prefix-length index-loa) sort-atts)
		    (or case-sensitive
			(cl:loop for att in sort-atts
			      always (case-insensitive-type-p (attribute-handle-type att))))
		    (cl:loop repeat prefix-length
			  for ia in index-loa
			  always
			    (cl:loop for (att spec) on where by #'cddr
				  when (let ((att (order-by-att att)))
					 (and (eq ia att)
					      (if (or case-sensitive
						      (case-insensitive-type-p
							(attribute-handle-type att)))
						  (equality-spec-p spec)
						  (case-insensitive-equality-spec-p spec))))
				    do (return t)))
		    ;; Tail and suffix match.  Remember this index, but
		    ;; search on for better.
		    (setq best-index index
			  best-index-prefix-length prefix-length
			  best-index-loa index-loa)))
	     (pop indexes))
	   (when best-index
	     ;; Have the best index decided now.  Compute the args for SCAN-INDEX-RANGE
	     (multiple-value-bind (index-atts-and-specs remaining-where-specs)
		 (try-exact-index (butlast best-index-loa n-sort-atts)
				  where
				  (index-handle-case-sensitive best-index))
	       (when (and (null index-atts-and-specs) (plusp best-index-prefix-length))
		 (model-bug "Equality specs match in try-suffix-sort-index,~@
                             but not in try-exact-index."))
	       (when *query-trace-p*
		 (trace-query-a :suffix-sort best-index-loa))
	       (when *windy-index-checking*
		 (format t "~&Found a suffix index for :order-by clause:~@
                            list-of-atts = ~S" best-index-loa))
	       (return-from try-suffix-sort-index
		 (values
		   #'scan-index-range
		   `(,(index-handle-index-identifier best-index) .
		     ,(when index-atts-and-specs
			`(:not-lessp
			   ,(apply #'make-key-from-values
				   database best-index index-atts-and-specs)
			   :not-greaterp
			   ,(apply #'make-next-key-from-values
				   database best-index index-atts-and-specs))))
		   remaining-where-specs
		   direction))))))))

;;; 1If there is an :order-by clause that has a list of M attributes,
0;;; 1examine0 1each index, and find the length of the leading common
0;;; 1subsequence of0 1attributes in the :order-by clause and the index.  If
0;;; 1there is no such0 1index, then return nil0.1  Otherwise, pick the0 1index
0;;; 1for which the0 1length of the common subsequence is the longest.0  1This
0;;; 1is the relevant0 1index.

0;;; After scanning over the list of indexes, if any relavent index is
;;; found, return the index function to use (scan-index-range) with the
;;; args to call it with (after the opening which is supplied by the
;;; caller).  Since the index cannot provide a fully sorted order on the
;;; rids, no other args besides the index identifier are returned.  The
;;; remaining-sort-specs which the index did not handle are returned as
;;; the third arg.  The direction (:ascending or :descending) which the
;;; rids should be walked over (those obtained from apply the index
;;; function to the args) is returned in the fourth value.  Note that
;;; the order-by arg is munged, so the caller may want to copy it
;;; beforehand.
(defun try-prefix-sort-index (indexes order-by)
  (declare (values index-function args remaining-sort-specs direction))
  (let* ((other-specs nil)
	 (direction nil)
	 ;; Find the prefix of the index atts which have the same
	 ;; direction.
	 (index-atts (cl:loop for successive-cdrs on order-by
			   for pair = (car successive-cdrs)
			   for dir = (second pair)
			   with first-direction = nil
			   unless first-direction
			     do (setq first-direction dir)
			   when (eq first-direction dir)
			     collect pair into prefix-specs
			   else do (scl:loop-finish)
			   finally
			     (setq other-specs successive-cdrs)
			     (setq direction first-direction)
			     (return prefix-specs)))
	 (n-index-atts (length index-atts)))
    ;; Find the index on the longest possible leading sublist of the
    ;; list of attributes.  indexes are sorted by n-atts, downward.
    (cl:loop until (null index-atts) do
      ;; Look for an index on index-atts.
      (cl:loop while indexes do
	(let* ((index (car indexes))
	       (index-loa (index-handle-list-of-attributes index)))
	  (when (< (length index-loa) n-index-atts)
	    (return nil))
	  (when (and (cl:loop for (att) in index-atts
			   for ia in index-loa
			   always (eq (order-by-att att) ia))
		     (or (index-handle-case-sensitive index)
			 (cl:loop for (att) in index-atts
			       always
				 (or (case-insensitive-type-p
				       (attribute-handle-type (order-by-att att)))
				     ;; if we have a case-sensitive index, we can still
				     ;; use it, but we have to sort things again starting
				     ;; with the first case-sensitive attribute found.
				     ;; Hence, leave the rest of the atts and dirs on
				     ;; the other-specs list starting with that
				     ;; case-sensitve one.
				     (let ((last-spec (car (last index-atts))))
				       (and (eq att (car last-spec))
					    (push (if (eq (second last-spec) :ascending)
						      last-spec
						      (list (car last-spec) :ascending))
						  other-specs)))))))
	    (when *query-trace-p*
	      (trace-query-o :prefix-sort (zl:firstn n-index-atts index-atts)))
	    (when *windy-index-checking*
	      (format t "~&Found a prefix index:~@
                           List-of-attributes = ~S" index-loa))
	    (return-from try-prefix-sort-index
	      (values #'scan-index-range
		      (list (index-handle-index-identifier index))
		      other-specs
		      direction))))
	(pop indexes))
      ;; No index on this sublist, try a shorter one.
      (push (car (last index-atts)) other-specs)
      (setq index-atts (nbutlast index-atts))	;I've always wanted to use that function...
      (decf n-index-atts))))

;;; Given a relation-handle, and a list of atts and specs (where clause),
;;; call return the count of the tuples which match the specs.
(defun count-relation-dynamic (relation-handle &key where)
  (declare (values count))
  (restart-testing-check)
  (prepare-database (relation-handle-database relation-handle))
  (check-attribute-types relation-handle where nil)
  (if where
      (count-relation relation-handle :where where)
      (count-relation-all relation-handle)))

;;; Until we re-do the query optimizer, here's a cheap version
(defun count-relation (relation-handle &key where)
  (sys:with-data-stack
    (cl:loop for rid being the array-elements of (find-rid-array relation-handle where nil)
	  count (not (zerop rid)))))

(defun count-relation-all (relation-handle)
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (bid (relation-handle-bset-iid relation-handle))
	 loi)
    (cond (bid
	   ;; have a bset -- use it.  Most will be this since
	   ;; relation-index-p defaults to t.
	   (when *query-trace-p*
	     (push (list :count-using-relation-index (relation-handle-name relation-handle))
		   *query-trace-list*))
	   (count-bset-values opening bid))
	  ((setq loi (relation-handle-list-of-indexes relation-handle))
	   ;; any index will do here
	   (when *query-trace-p*
	     (push (list :count-using-b-tree-index (relation-handle-name relation-handle))
		   *query-trace-list*))
	   (count-index-range opening (index-handle-index-identifier (car loi))))
	  (t
	   ;; no index support.  Use map-over-tuples for the slow way.
	   (when *query-trace-p*
	     (push (list :count-using-area-scan (relation-handle-name relation-handle))
		   *query-trace-list*))
	   (let ((count 0))
	     (map-over-tuples relation-handle
				     #'(lambda (&rest ignore1)
					 (declare (ignore ignore1))
					 (incf count)))
	     count)))))

;;; Is this spec a test for equality?
(defun equality-spec-p (spec)
  (or (null spec)
      (not (listp spec))
      (let ((spec (first spec)))
	(or (eq spec 'equal)
	    (eq spec 'eql)
	    (eq spec '=)
	    (eq spec 'eq)
	    (eq spec 'string=)
	    (eq spec 'char=)))))

;;; Is this spec a test for case-insensitive string-equality?
(defun case-insensitive-equality-spec-p (spec)
  (and (listp spec)
       (or (eq (first spec) 'string-equal)
	   (eq (first spec) 'char-equal))))

(defun put-compare-keyword-properties (x property)
  (cl:loop for (symbol value) in x do (setf (get symbol property) value)))

(put-compare-keyword-properties '((> :greaterp)
				  (< :lessp)
				  ( :not-lessp)
				  ( :not-greaterp)
				  (>= :not-lessp)
				  (<= :not-greaterp)
				  (string< :lessp)
				  (string> :greaterp)
				  (string :not-lessp)
				  (string>= :not-lessp)
				  (string :not-greaterp)
				  (string<= :not-greaterp)
				  (string-lessp :lessp)
				  (string-greaterp :greaterp)
				  (string-not-lessp :not-lessp)
				  (string-not-greaterp :not-greaterp)
				  (char< :lessp)
				  (char> :greaterp)
				  (char :not-lessp)
				  (char>= :not-lessp)
				  (char :not-greaterp)
				  (char<= :not-greaterp)
				  (char-lessp :lessp)
				  (char-greaterp :greaterp)
				  (char-not-lessp :not-lessp)
				  (char-not-greaterp :not-greaterp))
				'compare-keyword)

(put-compare-keyword-properties '((> (:greaterp))
				  (< (:lessp))
				  ( (:greaterp :equal))
				  ( (:lessp :equal))
				  (>= (:greaterp :equal))
				  (<= (:lessp :equal))
				  (string< (:lessp))
				  (string> (:greaterp))
				  (string (:greaterp :equal))
				  (string>= (:greaterp :equal))
				  (string (:lessp :equal))
				  (string<= (:lessp :equal))
				  (string-lessp (:lessp))
				  (string-greaterp (:greaterp))
				  (string-not-lessp (:greaterp :equal))
				  (string-not-greaterp (:lessp :equal))
				  (char< (:lessp))
				  (char> (:greaterp))
				  (char (:greaterp :equal))
				  (char>= (:greaterp :equal))
				  (char (:lessp :equal))
				  (char<= (:lessp :equal))
				  (char-lessp (:lessp))
				  (char-greaterp (:greaterp))
				  (char-not-lessp (:greaterp :equal))
				  (char-not-greaterp (:lessp :equal)))
				'compare-keywords-list)

(defun trace-query-a (keyword attribute-handles)
  (push (cons keyword (cl:loop for a in attribute-handles
			    collect (attribute-handle-name a)))
	*query-trace-list*))

(defun trace-query-av (keyword attributes-and-values)
  (push (cons keyword (cl:loop for (a) on attributes-and-values by #'cddr
			    collect (attribute-handle-name a)))
	*query-trace-list*))

(defun trace-query-o (keyword order-by)
  (push (cons keyword (cl:loop for (a) in order-by
			    collect (attribute-handle-name a)))
	*query-trace-list*))

