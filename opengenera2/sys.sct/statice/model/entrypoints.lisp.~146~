;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice-model; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; External entrypoints of Statice model level.
 
;;; Make a new entity and return a handle to it.
(defun make-entity (domain-handle &key cluster)
  (restart-testing-check)
  (check-user-domain-handle domain-handle)
  (and cluster (or (eq cluster t) (check-type cluster handle)))
  (prepare-database (domain-handle-database domain-handle))
  (make-entity-internal domain-handle :cluster (and cluster (or (eq cluster t)
								(handle-rid cluster)))))

;;; Special entrypoint for the dumper/reloader tool.  Normal Statice
;;; programs should not use this function.
(defun recreate-entity (domain-handle uid-word-1 uid-word-2 uid-word-3 &key cluster)
  (check-user-domain-handle domain-handle)
  (and cluster (or (eq cluster t) (check-type cluster handle)))
  (prepare-database (domain-handle-database domain-handle))
  (make-entity-internal domain-handle
			:uid-word-1 uid-word-1
			:uid-word-2 uid-word-2
			:uid-word-3 uid-word-3
			:cluster (and cluster (or (eq cluster t) (handle-rid cluster)))))

(defun make-entity-internal (domain-handle
			     &key uid-word-1 uid-word-2 uid-word-3
			     (n-var-words 0)
			     cluster)
  (let ((area (domain-handle-area domain-handle)))
    (when (and (not (= area 1)) cluster)
      (error "Can't specify :CLUSTER because ~S uses the :AREA option" domain-handle))
    (let* ((database (domain-handle-database domain-handle))
	   (opening (database-opening database))
	   (dom-rid (handle-rid domain-handle))
	   (ver (1- (domain-handle-next-layout-version domain-handle)))
	   (size (+ (fixed-space-for-version
		      (get-domain-allocation-map domain-handle)
		      ver)
		    n-var-words))
	   (ent-rid (make-record opening size
				 :area (domain-handle-area domain-handle)
				 :near cluster))
	   (entity-handle (make-new-entity-handle ent-rid domain-handle nil nil nil))
	   (bid (domain-handle-bset-iid domain-handle)))
      (with-record (ent opening ent-rid :write)
	(set-new-entity-uid ent entity-handle uid-word-1 uid-word-2 uid-word-3)
	(when bid
	  (let ((new-bid (insert-bset-key opening bid ent-rid)))
	    (unless (= bid new-bid)
	      (note-schema-modified database)
	      (with-record (dom opening (handle-rid domain-handle) :write)
		(setf (domain-bset-iid dom) new-bid))
	      (setf (domain-handle-bset-iid domain-handle) new-bid))))
	(setf (entity-domain ent) dom-rid)
	(setf (local-entity-version ent)
	      (1- (domain-handle-next-layout-version domain-handle)))
	(setf (local-entity-tuples-present ent) 0)
	(loop for i from (record-size local-entity) below size do
	  (setf (read-record-word ent i) 0)))
      (setf (gethash (list ent-rid database) (new-entity-handles)) entity-handle)
      entity-handle)))

(defun make-new-entity-handle (rid domain uid-word-1 uid-word-2 uid-word-3)
  (apply #'make-instance
	 (let ((entity-flavors (database-entity-flavors (domain-handle-database domain))))
	   (cond ((null entity-flavors) 'known-entity-handle)
		 ((fast-gethash domain entity-flavors))
		 (t 'known-entity-handle)))
	 :rid rid
	 :domain domain
	 :uid-word-1 uid-word-1
	 :uid-word-2 uid-word-2
	 :uid-word-3 uid-word-3
	 *make-instance-arguments*))

(defun delete-entity (entity-handle &optional (database *current-database*))
  (restart-testing-check)
  (check-user-entity-handle entity-handle)
  (check-type database database)
  (prepare-database database)
  ;; Note: even if it's a known-entity-handle, database might not be its home.
  (multiple-value-bind (ent-rid home-database-p)
      (find-entity-record-in-database entity-handle database)
    (when ent-rid
      (let ((opening (database-opening database)))
	;; Must call this first, because it does integrity checking, and
	;; might signal an error, so we should not have any side effects
	;; until after this is called.
	(delete-tuples-containing-entity entity-handle database)
	(unless (handle-rid entity-handle)
	  ;; Delete an unknown entity handle.
	  ;; It's possible that this entity is actually a domain, back in its home.
	  ;; If any attribute in this database is using the entity as a type constraint,
	  ;; then the entire relation has to be deleted.  This can only come up if the
	  ;; entity is unknown, because if it were known, the entity handle would be
	  ;; a domain handle, and we would have signalled an error already.
	  (do-relations (relation database)
	    (when (loop for attribute in (relation-handle-list-of-attributes relation)
			thereis (eq (attribute-handle-type attribute) entity-handle))
	      (delete-relation-internal relation))))
	(cond (home-database-p
	       (let* ((domain-handle (known-entity-handle-domain entity-handle))
		      (bid (domain-handle-bset-iid domain-handle)))
		 ;; Unlink the entity.
		 (when bid
		   (let ((new-bid (delete-bset-key opening bid ent-rid)))
		     (unless (= bid new-bid)
		       (note-schema-modified database)
		       (with-record (d opening (handle-rid domain-handle) :write)
			 (setf (domain-bset-iid d) new-bid))
		       (setf (domain-handle-bset-iid domain-handle) new-bid))))
		 ;; Deleting an entity from its home database.  At the end of the
		 ;; transaction, remove it from database-known-entity-handles.
		 (nullify-entity-handle entity-handle)))
	      (t
	       ;; It's a foreign-entity, so the head is in the database header.
	       (with-record (ent opening ent-rid :read)
		 (let ((next-rid (foreign-entity-next ent))
		       (previous-rid (foreign-entity-previous ent)))
		   (unless (zerop previous-rid)
		     (with-record (prev opening previous-rid :write)
		       (setf (foreign-entity-next prev) next-rid)))
		   (unless (zerop next-rid)
		     (with-record (next opening next-rid :write)
		       (setf (foreign-entity-previous next) previous-rid)))
		   (with-record (seg opening (database-rid-of-header database) :write)
		     (downreference-foreign-database (foreign-entity-foreign-database ent)
						     database)
		     (when (= (database-header-list-of-foreign-entities seg) ent-rid)
		       (setf (database-header-list-of-foreign-entities seg) next-rid)))))))
	;; Deallocate the entity record.
	(delete-record opening ent-rid))))
  t)

;;; Delete all tuples in the database that contain the given
;;; entity as an attribute value.  local-p says whether the entity is a
;;; local entity or a foreign entity.  The caller guarantees that it
;;; will delete the entity itself, after this function returns.  Note:
;;; if we ever allow cross-database inheritance, then the typep check for
;;; foreign entities has to allow domain-handles as well.
(defun delete-tuples-containing-entity (entity-handle database)
  ;; Examine all attributes to see if a some tuple of the attribute's
  ;; relation might be harboring the target entity in this attribute's
  ;; values.  Classify such attributes into two categories, protector
  ;; and hot.  A protector attribute is one that, if an entity is found, the
  ;; deletion fails outright.  A hot attribute means we should seek out those
  ;; tuples and either delete them, or nullify the value, depending on
  ;; the delete-nullifies quality of this attribute.  Explicitly
  ;; exclude the entity-domain system relation, for obvious reasons.  If the
  ;; layout-version is nil, then no tuples have non-null values for this
  ;; attribute, so it cannot be hot.  (This saves a check later.)
  (let ((known-p (typep entity-handle 'known-entity-handle))
	(protector-attributes nil)
	(hot-attributes nil))
    (do-relations (relation-handle database)
      (unless (relation-handle-system-relation-p relation-handle)
	(let ((soo-att (relation-handle-surrogate-optimized-on relation-handle)))
	  (dolist (attribute-handle (relation-handle-list-of-attributes relation-handle))
	    (when (and (or (attribute-handle-layout-version attribute-handle)
			   ;; soo-att's layout-version is always nil
			   (eq attribute-handle soo-att))
		       (let ((type (attribute-handle-type attribute-handle)))
			 (if known-p
			     (statice-typep type entity-handle)
			     (and (entity-type-p type)
				  (not (typep type 'domain-handle))))))
	      (if (and (attribute-handle-no-nulls attribute-handle)
		       (attribute-handle-delete-nullifies attribute-handle))
		  (push attribute-handle protector-attributes)
		  (push attribute-handle hot-attributes)))))))
    (when protector-attributes
      (dolist (attribute-handle protector-attributes)
	(do-relation (tuple (attribute-handle-relation attribute-handle)
			    (:where attribute-handle entity-handle))
	  (error "Attempt to delete ~S which is in use by :no-nulls attribute ~A"
		 entity-handle attribute-handle))))
    (when hot-attributes
      (dolist (attribute-handle hot-attributes)
	(do-relation (tuple (attribute-handle-relation attribute-handle)
			    (:where attribute-handle entity-handle))
	  (if (attribute-handle-delete-nullifies attribute-handle)
	      (set-to-null-value tuple attribute-handle)
	      (delete-tuple tuple)))))))

(defun domain-of (entity-handle)
  (check-type entity-handle entity-handle)
  (when (eq (handle-rid entity-handle) :deleted)
    (cl:error 'entity-handle-deleted :entity-handle entity-handle))
  (typecase entity-handle
    (known-entity-handle (known-entity-handle-domain entity-handle))
    (unknown-entity-handle :unknown)))

;;; Make an entity, and make one or many tuples for relations that are
;;; surrogate-optimized onto that entity.  Defined to be semantically
;;; equivalent to make-entity followed by one or many calls to
;;; make-tuple, but more efficient because it allocates all of the
;;; storage at once, which avoids the need for indirect descriptors at
;;; storage level.  The soo-att and soo-att's value are implied for all
;;; relations, and must not be passed as arguments.
(defun make-entity-and-tuples (domain-handle &rest attributes-and-values)
  (apply #'make-clustered-entity-and-tuples domain-handle nil attributes-and-values))

(defun make-clustered-entity-and-tuples (domain-handle cluster &rest attributes-and-values)
  (restart-testing-check)
  (check-user-domain-handle domain-handle)
  (and cluster (or (eq cluster t) (check-type cluster handle)))
  (let ((database (domain-handle-database domain-handle)))
    (prepare-database (domain-handle-database domain-handle))
    ;; Pass 1 over the attributes-and-values.  Do error-checks, and figure out
    ;; how many words of storage we will need in addition to the fixed words.
    (let ((n-var-words 0)
	  (opening (database-opening database))
	  unsupplied-and-null-attributes relation-handles)
      (using-resource (attribute-size-map tables)
	(using-resource (attribute-transition-table-map tables)
	  (flet ((write-attribute-values (addressor first-var-word)
		   ;; For every attribute specified by the caller, store the value.
		   (loop with free = first-var-word
			 for (attribute-handle value) on attributes-and-values by #'cddr do
		       (unless (member attribute-handle unsupplied-and-null-attributes)
			 (let ((ad (search-table-for-domain
				     (attribute-handle-descriptor attribute-handle)
				     domain-handle)))
			   (setq free
				 (write-value
				   (attribute-handle-type attribute-handle)
				   value
				   addressor
				   ad
				   free
				   database
				   (gethash attribute-handle
					    attribute-transition-table-map)
				   (gethash attribute-handle attribute-size-map))))))
		   ;; For every attribute not specified by the caller, store the null value.
		   (loop for attribute-handle in unsupplied-and-null-attributes do
		     (let ((ad (search-table-for-domain
				 (attribute-handle-descriptor attribute-handle)
				 domain-handle)))
		       (write-value (attribute-handle-type attribute-handle)
				    *null-value*
				    addressor
				    ad
				    nil
				    nil
				    nil
				    0)))))
	    (when (domain-handle-new-layout-needed domain-handle)
	      (compute-new-domain-layout domain-handle))
	    (let ((ver (1- (domain-handle-next-layout-version domain-handle))))
	      (loop with free = (fixed-space-for-version
				  (get-domain-allocation-map domain-handle)
				  ver)
		    for (attribute-handle value) on attributes-and-values by #'cddr do
		(check-user-attribute-handle attribute-handle)
		(when (eq value *null-value*)
		  ;; This should never happen any more.  This check is for paranoia purposes.
		  (error "Internal null value object passed to make-entity-and-tuples"))
		(let ((relation-handle (attribute-handle-relation attribute-handle)))
		  (unless (member relation-handle (domain-handle-relations-optimized-on
						    domain-handle))
		    (model-error "The attribute ~S is not in a relation which is~@
                                  surrogate-optimized onto domain ~S"
				 attribute-handle domain-handle))
		  (when (eq attribute-handle (relation-handle-surrogate-optimized-on
					       relation-handle))
		    (model-error "The attribute ~S should not be supplied in an~@
                                  attribute-value pair since it is the~@
                                  surrogate-optimized attribute."
				 attribute-handle))
		  (let* ((type (attribute-handle-type attribute-handle))
			 (statice-typep (statice-typep type value))
			 (null-value-p (and (not statice-typep) (null value))))
		    (unless (or statice-typep null-value-p)
		      (error 'wrong-type-value :value value :storage-handler type))
		    ;; Keep track of which attributes were never supplied.
		    (cond ((not (member (attribute-handle-relation attribute-handle)
					relation-handles))
			   ;; This is the first attribute from this
			   ;; relation that we've seen so far.  Put all the attributes
			   ;; of this relation onto the list of unsupplied attributes,
			   ;; except the soo-att, and except this one itself so long
			   ;; as it isn't a null value.
			   (push relation-handle relation-handles)
			   (let ((soo-att
				   (relation-handle-surrogate-optimized-on relation-handle)))
			     (dolist (ah (relation-handle-list-of-attributes relation-handle))
			       (unless (or (and (eq ah attribute-handle) statice-typep)
					   (eq ah soo-att))
				 (push ah unsupplied-and-null-attributes)))))
			  (statice-typep
			   ;; This attribute is supplied.  Remove it from the list.
			   (setq unsupplied-and-null-attributes
				 (delete attribute-handle unsupplied-and-null-attributes))))
		    (unless null-value-p
		      (when (and (attribute-handle-unique attribute-handle)
				 (not (attribute-handle-indexed attribute-handle)))
			(check-unique-attribute-value attribute-handle value "make"))
		      (multiple-value-bind (size transition-table)
			  (size-of-value type value free database)
			(setf (gethash attribute-handle attribute-size-map) size)
			(setf (gethash attribute-handle attribute-transition-table-map)
			      transition-table)
			(incf n-var-words size)
			(incf free size))))))
	      ;; Make sure all "no-null" attributes have been supplied.
	      (dolist (attribute-handle unsupplied-and-null-attributes)
		(unless (eq attribute-handle
			    (relation-handle-surrogate-optimized-on
			      (attribute-handle-relation attribute-handle)))
		  (when (attribute-handle-no-nulls attribute-handle)
		    (model-error
		      "No value was specified for attribute ~A, which specified no-nulls"
		      attribute-handle))))
	      (let* ((entity-handle
		       (make-entity-internal domain-handle
					     :n-var-words n-var-words
					     :cluster (and cluster (or (eq cluster t)
								       (handle-rid cluster)))))
		     (entity-rid (handle-rid entity-handle)))
		(with-record (ent opening entity-rid :write)
		  (upgrade-entity ent domain-handle)
		  (write-attribute-values ent (- (get-record-size ent) n-var-words))
		  (dolist (relation-handle relation-handles)
		    (dolist (a (relation-handle-list-of-attributes relation-handle))
		      (insert-into-group-index ent entity-rid relation-handle ver a))
		    (insert-into-indexes ent entity-rid relation-handle ver "make" nil)
		    ;; make it for real by setting the bit map in the entity
		    (setf (local-entity-tuples-present ent)
			  (dpb 1
			       (byte 1 (search-table-for-domain
					 (relation-handle-entity-bit-map-number
					   relation-handle)
					 domain-handle))
			       (local-entity-tuples-present ent)))))
		entity-handle))))))))

(defun make-tuple (relation-handle &rest attributes-and-values)
  (apply #'make-clustered-tuple relation-handle nil attributes-and-values))

(defun make-clustered-tuple (relation-handle cluster &rest attributes-and-values)
  (restart-testing-check)
  (check-user-relation-handle relation-handle)
  (and cluster (or (eq cluster t) (check-type cluster handle)))
  (let ((database (relation-handle-database relation-handle))
	(area (relation-handle-area relation-handle)))
    (when (and (not (= area 1)) cluster)
      (error "Can't specify :CLUSTER because ~S uses the :AREA option" relation-handle))
    (prepare-database database)
    ;; Pass 1 over the attributes-and-values.  Do error-checks, and figure out
    ;; how many words of storage we will need in addition to the fixed words.
    (let ((opening (database-opening database))
	  (unsupplied-and-null-attributes
	    (copy-list-simply (relation-handle-list-of-attributes relation-handle))))
      (using-resource (attribute-size-map tables)
	(using-resource (attribute-transition-table-map tables)
	  (flet ((compute-variable-size (free)
		   ;; pass 1 in which we determine the number of var words needed
		   (let ((n-var-words 0))
		     (loop for (attribute-handle value) on attributes-and-values by #'cddr do
		       (check-attribute-handle attribute-handle)
		       (when (eq value *null-value*)
			 ;; This should never happen any more.  This check
			 ;; is for paranoia purposes.
			 (error "Internal null value object passed to~@
                                make-entity-and-tuples"))
		       (unless (eq relation-handle (attribute-handle-relation
						     attribute-handle))
			 (model-error "The attribute ~S is not from the relation ~S"
				      attribute-handle relation-handle))
		       (let ((type (attribute-handle-type attribute-handle)))
			 (cond ((statice-typep type value)
				(when (and (attribute-handle-unique attribute-handle)
					   (not (attribute-handle-indexed attribute-handle)))
				  (check-unique-attribute-value attribute-handle value "make"))
				(setq unsupplied-and-null-attributes
				      (delete
					attribute-handle unsupplied-and-null-attributes))
				(multiple-value-bind (size transition-table)
				    (size-of-value type value free database)
				  (setf (gethash attribute-handle attribute-size-map) size)
				  (setf (gethash attribute-handle
						 attribute-transition-table-map)
					transition-table)
				  (incf n-var-words size)
				  (incf free size)))
			       ((null value)
				;; they're passing us the null value.  Just leave it
				;; on unsupplied-and-null-attributes
				)
			       (t
				(error 'wrong-type-value
				       :value value
				       :storage-handler type)))))
		     (dolist (attribute-handle unsupplied-and-null-attributes)
		       (when (attribute-handle-no-nulls attribute-handle)
			 (model-error
			   "No value was specified for attribute ~A, which specified no-nulls"
			   attribute-handle)))
		     n-var-words))
		 ;; Pass 2, in which we actually store the values.  We have to determine
		 ;; which record to use, based on whether the relation is surrogate-optimized.
		 (write-attribute-values (addressor first-var-word soo-att)
		   (let ((soo-domain (when soo-att
				       (known-entity-handle-domain
					 (loop for (attribute-handle value)
						   on attributes-and-values by #'cddr
					       do (when (eq attribute-handle soo-att)
						    (return value)))))))
		     ;; Third arg is soo-att if surrogate-optimized, else nil.
		     ;; For every attribute specified by the caller, store the value.
		     (loop with free = first-var-word
			   for (attribute-handle value) on attributes-and-values by #'cddr
			   unless (or (eq attribute-handle soo-att)
				      (member attribute-handle unsupplied-and-null-attributes))
			     do
			       (let ((ad (attribute-handle-descriptor attribute-handle)))
				 (setq free
				       (write-value (attribute-handle-type attribute-handle)
						    value
						    addressor
						    (if soo-att
							(search-table-for-domain ad soo-domain)
							ad)
						    free
						    database
						    (gethash attribute-handle
							     attribute-transition-table-map)
						    (gethash
						      attribute-handle attribute-size-map)))))
		     ;; For every attribute not specified by the caller, store the null value.
		     (loop for attribute-handle in unsupplied-and-null-attributes
			   do
		       (let ((ad (attribute-handle-descriptor attribute-handle)))
			 (write-value (attribute-handle-type attribute-handle)
				      *null-value*
				      addressor
				      (if soo-att
					  (search-table-for-domain ad soo-domain)
					  ad)
				      nil
				      nil
				      nil
				      0))))))
	    (let ((soo-att (relation-handle-surrogate-optimized-on relation-handle)))
	      (cond ((null soo-att)
		     ;; This is a normal relation.
		     (when (relation-handle-new-layout-needed relation-handle)
		       (compute-new-relation-layout relation-handle))
		     (let* ((ver (1- (relation-handle-next-layout-version relation-handle)))
			    (first-var-word (fixed-space-for-version
					      (get-relation-allocation-map relation-handle)
					      ver))
			    (n-var-words (compute-variable-size first-var-word))
			    (rid (make-record opening
					      (+ first-var-word n-var-words)
					      :area (relation-handle-area relation-handle)
					      :near (and cluster (or (eq cluster t)
								     (handle-rid cluster)))))
			    (insert-completed-ok nil)
			    (bid (relation-handle-bset-iid relation-handle)))		 
		       (unwind-protect
			   (progn
			     (with-record (tuple opening rid :write)
			       (setf (tuple-relation tuple)
				     (handle-rid relation-handle))
			       (setf (tuple-version tuple) ver)
			       ;; Write all the attribute values, and insert into index.
			       (write-attribute-values tuple first-var-word nil)
			       (dolist (a (relation-handle-list-of-attributes
					    relation-handle))
				 (insert-into-group-index tuple rid relation-handle ver a))
			       (insert-into-indexes tuple rid relation-handle ver "make" nil)
			       (when bid
				 (let ((new-bid (insert-bset-key opening bid rid)))
				   (unless (= bid new-bid)
				     (note-schema-modified database)
				     (with-record (r opening (handle-rid relation-handle)
						     :write)
				       (setf (relation-bset-iid r) new-bid))
				     (setf (relation-handle-bset-iid relation-handle)
					   new-bid))))
			       (setq insert-completed-ok t))
			     (unless insert-completed-ok
			       (delete-record opening rid))))
		       ;; Make and return a tuple handle.
		       (let ((tuple-handle
			       (make-tuple-handle rid relation-handle)))
			 (setf (gethash rid (tuple-handles)) tuple-handle)
			 tuple-handle)))
		    (t
		     ;; This is a surrogate-optimized relation.  It's a user
		     ;; relation, so we can be sure that the type of soo-att
		     ;; is a domain.
		     (let* ((entity-handle
			      (or (loop for (attribute-handle value) on attributes-and-values
							      by #'cddr do
				    (when (eq attribute-handle soo-att)
				      (return value)))
				  (model-error "No value provided for attribute ~S" soo-att)))
			    (entity-rid (handle-rid entity-handle))
			    (domain-handle (known-entity-handle-domain entity-handle))
			    (bid (relation-handle-bset-iid relation-handle)))
		       (check-domain-handle domain-handle)	; Paranoia.
		       (when (domain-handle-new-layout-needed domain-handle)
			 (compute-new-domain-layout domain-handle))
		       (with-record (ent opening entity-rid :write)
			 ;; If the entity has an old version, bring it up
			 ;; to the current version.
			 (upgrade-entity ent domain-handle)
			 (let* ((old-size (get-record-size ent))
				(n-var-words (compute-variable-size old-size))
				(ppss (byte 1 (search-table-for-domain
						(relation-handle-entity-bit-map-number
						  relation-handle)
						domain-handle)))
				(bit-map (local-entity-tuples-present ent)))
			   ;; Make sure the tuple isn't already
			   ;; present, just for paranoia.
			   (unless (zerop (ldb ppss bit-map))
			     (model-bug "A tuple of ~S with value ~S for attribute ~S~@
                                   exists, but this should have been caught earlier."
					relation-handle entity-handle soo-att))
			   ;; Enlarge the entity to hold the var words of the new values.
			   (set-record-size ent (+ old-size n-var-words))
			   ;; Write the attribute values
			   (write-attribute-values ent old-size soo-att)
			   (let ((ver (local-entity-version ent)))
			     (dolist (a (relation-handle-list-of-attributes relation-handle))
			       (insert-into-group-index ent entity-rid relation-handle ver a))
			     (insert-into-indexes
			       ent entity-rid relation-handle ver "make" nil)
			     (when bid
			       (let ((new-bid (insert-bset-key opening bid entity-rid)))
				 (unless (= bid new-bid)
				   (note-schema-modified database)
				   (with-record (r opening (handle-rid relation-handle)
						   :write)
				     (setf (relation-bset-iid r) new-bid))
				   (setf (relation-handle-bset-iid relation-handle)
					 new-bid)))))
			   ;; If we get this far, make it for real.
			   (setf (local-entity-tuples-present ent)
				 (dpb 1 ppss bit-map))))
		       ;; Make and return a tuple handle.
		       (let ((tuple-handle
			       (make-tuple-handle entity-rid relation-handle)))
			 (setf (gethash entity-rid (tuple-handles)) tuple-handle)
			 tuple-handle)))))))))))

(defun delete-tuple (tuple-handle)
  (restart-testing-check)
  (check-user-tuple-handle tuple-handle)
  ;; tuple handles aren't long-lived, so no need to call
  ;; prepare-database here
  (let* ((rid (handle-rid tuple-handle))
	 (relation-handle (tuple-handle-relation tuple-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (cond ((null soo-att)
	   ;; This is a normal relation.  Unlink the tuple record.
	   (let ((tuple-rid rid)
		 (bid (relation-handle-bset-iid relation-handle)))
	     (with-record (tuple opening tuple-rid :write)
	       (let ((ver (tuple-version tuple)))
		 (dolist (a (relation-handle-list-of-attributes relation-handle))
		   (delete-from-group-index tuple tuple-rid relation-handle ver a))
		 (delete-from-indexes tuple tuple-rid relation-handle ver)))
	     (when bid
	       (let ((new-bid (delete-bset-key opening bid tuple-rid)))
		 (unless (= new-bid bid)
		   (note-schema-modified database)
		   (with-record (r opening (handle-rid relation-handle) :write)
		     (setf (relation-bset-iid r) new-bid))
		   (setf (relation-handle-bset-iid relation-handle) new-bid))))
	     (delete-record opening tuple-rid)))
	  (t
	   ;; This is a surrogate-optimized relation.
	   (let* ((ent-rid rid)
		  (ent-domain
		    (find-domain-handle-given-entity-rid ent-rid database)))
	     (with-record (ent opening ent-rid :write)
	       (let ((ver (local-entity-version ent)))
		 (dolist (a (relation-handle-list-of-attributes relation-handle))
		   (delete-from-group-index ent ent-rid relation-handle ver a))
		 (delete-from-indexes ent ent-rid relation-handle ver))
	       (deallocate-tuple-from-entity
		 ent
		 relation-handle
		 ent-domain
		 soo-att)))))
    (remove-tuple-from-rid-arrays rid relation-handle)
    (nullify-tuple-handle tuple-handle)))

(defun relation-of (tuple-handle)
  (check-tuple-handle tuple-handle)
  (tuple-handle-relation tuple-handle))

;;; The caller should provide two variables, one for addressor and one
;;; for descriptor.  The record is opened and the value is examined.  If
;;; the value is the null value, get-value-internal returns nil and nil.
;;; If the attribute-handle is the soo-att, get-value-internal returns
;;; the entity handle and t.  Otherwise, get-value-internal executes the
;;; body, and returns the body's first value as its first value and no
;;; second value (the caller is responsible for that).

;;; The caller's environment must contain variables named soo-att,
;;; opening, tuple-handle/tuple-rid, att-version, attribute-handle, and
;;; database.  This is really only intended to be used by a
;;; closely-related group of similar functions.

;;; If :rid-or-handle is :handle, then tuple-handle must be present in the
;;; callers environment.  If :rid-or-handle is :rid, then tuple-rid must
;;; be present in the caller's environment.
(defmacro get-value-internal ((addressor descriptor &key (rid-or-handle :handle)) &body body)
  `(cond ((null soo-att)
	  ;; This is a normal relation.
	  (,@(if (eq rid-or-handle :addressor)
		 '(progn)
		 `(with-record (,addressor
				opening
				,(ecase rid-or-handle
				   (:handle '(handle-rid tuple-handle))
				   (:rid 'tuple-rid))
				:read)))
	    (if (or (null att-version)
		    (and (plusp att-version)
			 (< (tuple-version ,addressor) att-version)))
		(values nil nil)
		(let ((,descriptor (attribute-handle-descriptor attribute-handle)))
		  (progn . ,body)))))
	 (t
	  ;; This is a surrogate-optimized relation.
	  (let* ((ent-rid ,(ecase rid-or-handle
			     (:handle '(handle-rid tuple-handle))
			     (:rid 'tuple-rid)
			     (:addressor '(get-addressor-rid addressor))))
		 (entity-handle (find-entity-handle-given-rid ent-rid database))
		 (domain-handle (known-entity-handle-domain entity-handle)))
	    domain-handle
	    (if (eq attribute-handle soo-att)
		(values entity-handle t)
		(,@(if (eq rid-or-handle :addressor)
		       '(progn)
		       `(with-record (,addressor opening ent-rid :read)
			  (let ((att-version (search-table-for-domain att-version domain-handle
								      :if-not-found nil)))
			    (if (or (null att-version)
				    (and (plusp att-version)
					 (< (local-entity-version ,addressor) att-version)))
				(values nil nil)
				(let ((,descriptor
				       (search-table-for-domain
					 (attribute-handle-descriptor attribute-handle)
					 domain-handle)))
				  (progn . ,body))))))))))))

(defun get-value (tuple-handle attribute-handle)
  (declare (values value value-not-null-p))
  (restart-testing-check)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error
	"Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (get-value-internal (addressor descriptor)
      (let ((value (read-value type addressor descriptor database)))
	(if (eq value *null-value*)
	    (values nil nil)
	    (values value t))))))

(defun get-value-null-p (tuple-handle attribute-handle)
  (restart-testing-check)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error
	"Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (get-value-internal (addressor descriptor)
      (value-null-p type addressor descriptor))))

(defmacro do-text-lines ((var tuple-handle attribute-handle
			      &key
			      (delimiter '#\Return)
			      (create-function
				#'(lambda (length thin-p)
				    (make-string length
						 :element-type (if thin-p
								   'string-char
								   'character)))))
			 &body body)
  `(block nil
     (map-over-text-lines-internal ,tuple-handle ,attribute-handle
				   #'(lambda (,var)
				       . ,body)
				   ,create-function
				   ,delimiter)))

(defun map-over-text-lines-internal (tuple-handle attribute-handle continuation create-function delimiter)
  (declare (sys:downward-funarg continuation create-function))
  (restart-testing-check)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error
	"Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (unless (string-type-p type)
      (model-error "Attribute ~S is not a string" attribute-handle))
    (get-value-internal (addressor descriptor)
      (map-over-subvalues type addressor descriptor database delimiter continuation
			  create-function))))

(defun get-value-into-string (tuple-handle attribute-handle into-string)
  (declare (values value value-not-null-p))
  (restart-testing-check)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((type (attribute-handle-type attribute-handle))
	 (relation-handle (tuple-handle-relation tuple-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error "Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (unless (string-type-p type)
      (model-error "Attribute ~S is not a string" attribute-handle))
    (get-value-internal (addressor descriptor)
      (let ((value (read-value type addressor descriptor database :into-string into-string)))
	(if (eq value *null-value*)
	    (values nil nil)
	    (values value t))))))

(defun get-value-array-portion (tuple-handle attribute-handle from-start from-end
				into-array into-start)
  (declare (values value value-not-null-p))
  (restart-testing-check)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  (check-type from-start fixnum)
  (check-type from-end fixnum)
  (check-type into-start fixnum)
  (check-type into-array array)
  ;; should check into-array element type here
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((type (attribute-handle-type attribute-handle))
	 (relation-handle (tuple-handle-relation tuple-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error "Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (unless (array-type-p type)
      (model-error "Attribute ~S is not a vector" attribute-handle))
    (let ((n-bytes (- from-end from-start)))
      (when (minusp n-bytes)
	(model-error "from-end is less than from-start"))
      (unless (<= n-bytes (- (length into-array) into-start))
	(model-error "Can't fit the number of bytes requested (~S) into the target-array~@
                      starting at ~S" n-bytes into-start)))
    (get-value-internal (addressor descriptor)
      (let ((value (read-value-portion type addressor descriptor database
				       :into into-array
				       :start from-start
				       :end from-end
				       :into-start into-start)))
	(if (eq value *null-value*)
	    (values nil nil)
	    (values value t))))))

(defun get-array-length (tuple-handle attribute-handle)
  (declare (values value value-not-null-p))
  (restart-testing-check)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error
	"Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (unless (or (array-type-p type) (string-type-p type))
      (model-error "Attribute ~S is not of type array." attribute-handle))
    (get-value-internal (addressor descriptor)
      (let ((size (length-of-array type addressor descriptor)))
	(values size (not (value-null-p type addressor descriptor)))))))

;;; If value is nil, and nil is not a valid value for the type of the
;;; attribute, store the null value.
(defun set-value (tuple-handle attribute-handle value)
  (restart-testing-check)
  (check-user-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  (when (eq value *null-value*)
    ;; This should never happen any more.  This check is for paranoia purposes.
    (error "The internal null value object was used as an argument to set-value"))
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (let* ((type (attribute-handle-type attribute-handle))
	 (of-type (statice-typep type value)))
    (unless (or of-type (null value))
      (error 'wrong-type-value :value value :storage-handler type))
    (when (and (attribute-handle-unique attribute-handle)
	       (not (attribute-handle-indexed attribute-handle)))
      (check-unique-attribute-value attribute-handle value "set" (handle-rid tuple-handle)))
    (set-value-internal tuple-handle attribute-handle (if of-type value *null-value*)))
  t)

(defun set-value-array-portion (tuple-handle attribute-handle start end from from-start)
  (restart-testing-check)
  (check-user-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  (check-type start fixnum)
  (check-type end fixnum)
  (check-type from array)
  (check-type from-start fixnum)
  (unless (array-type-p (attribute-handle-type attribute-handle))
    (error "Attribute ~S is not of type vector" attribute-handle))
  (when (minusp from-start)
    (error "FROM-START is negative"))
  (when (> from-start (- (length from) (- end start)))
    (error "You can't put ~A elements into the array ~A starting at ~A"
	   (- end start) from from-start))
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error "Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (cond ((null soo-att)
	  ;; This is a normal relation.
	   (with-record (addressor opening (handle-rid tuple-handle) :write)
	     (let ((descriptor (attribute-handle-descriptor attribute-handle)))
	       (if (or (null att-version)
		       (and (plusp att-version)
			    (< (tuple-version addressor) att-version))
		       (value-null-p type addressor descriptor))
		   (model-error "The value of attribute ~S in tuple ~S is the null value"
				attribute-handle tuple-handle)
		   (set-value-portion type addressor descriptor database
				      :start start
				      :end end
				      :from from
				      :from-start from-start)))))
	 (t
	  ;; This is a surrogate-optimized relation.
	  (let* ((ent-rid (handle-rid tuple-handle))
		 (entity-handle (find-entity-handle-given-rid ent-rid database))
		 (domain-handle (known-entity-handle-domain entity-handle)))
	    (if (eq attribute-handle soo-att)
		;; this is an internal error
		(model-bug "attribute-handle ~S passed the array-type-p test but it is~@
                            the soo-att"
			   attribute-handle)
		(with-record (addressor opening ent-rid :write)
		  (let ((att-version (search-table-for-domain att-version domain-handle
							       :if-not-found nil))
			(descriptor (search-table-for-domain
				      (attribute-handle-descriptor attribute-handle)
				      domain-handle)))
		    (if (or (null att-version)
			    (and (plusp att-version)
				 (< (local-entity-version addressor) att-version))
			    (value-null-p type addressor descriptor))
			(model-error "The value of attribute ~S in tuple ~S is the null value"
				     attribute-handle tuple-handle)
			(set-value-portion type addressor descriptor database
					   :start start
					   :end end
					   :from from
					   :from-start from-start))))))))))

(defun set-to-null-value (tuple-handle attribute-handle)
  (restart-testing-check)
  (check-user-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (when (attribute-handle-no-nulls attribute-handle)
    (model-error "~A is no-nulls, values cannot be set to the null value"
		 attribute-handle))
  (set-value-internal tuple-handle attribute-handle *null-value*)
  t)

(defun set-value-internal (tuple-handle attribute-handle value)
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error
	"Attribute ~A is not part of relation ~A" attribute-handle relation-handle))
    (cond ((null soo-att)
	   ;; This is a normal relation.
	   (when (relation-handle-new-layout-needed relation-handle)
	     (compute-new-relation-layout relation-handle))
	   (let ((tuple-rid (handle-rid tuple-handle)))
	     (with-record (tuple opening tuple-rid :write)
	       (let ((ver (tuple-version tuple)))
		 (delete-from-indexes tuple tuple-rid relation-handle ver attribute-handle)
		 (delete-from-group-index
		   tuple tuple-rid relation-handle ver attribute-handle))
	       (upgrade-tuple tuple relation-handle)
	       (put-value type value tuple (attribute-handle-descriptor attribute-handle)
			  database relation-handle nil)
	       (let ((ver (tuple-version tuple)))
		 (insert-into-group-index
		   tuple tuple-rid relation-handle ver attribute-handle)
		 (insert-into-indexes
		   tuple tuple-rid relation-handle ver "set" attribute-handle)))))
	  (t
	   ;; This is a surrogate-optimized relation.  It's a user relation, so we can
	   ;; be sure that the type of the attribute is a domain.
	   (let* ((soo-domain (attribute-handle-type soo-att))
		  (ent-rid (handle-rid tuple-handle))
		  (domain-handle
		    (find-domain-handle-given-entity-rid ent-rid database)))
	     (when (domain-handle-new-layout-needed soo-domain)
	       (compute-new-domain-layout soo-domain))
	     (if (eq attribute-handle soo-att)
		 (set-soo-att-value ent-rid value relation-handle domain-handle database
				    opening tuple-handle soo-att)
		 (with-record (ent opening ent-rid :write)
		   (let ((ver (local-entity-version ent)))
		     (delete-from-indexes ent ent-rid relation-handle ver attribute-handle)
		     (delete-from-group-index
		       ent ent-rid relation-handle ver attribute-handle))
		   (upgrade-entity ent domain-handle)
		   (put-value type value ent
			      (search-table-for-domain
				(attribute-handle-descriptor attribute-handle)
				domain-handle)
			      database domain-handle t)
		   (let ((ver (local-entity-version ent)))
		     (insert-into-group-index
		       ent ent-rid relation-handle ver attribute-handle)
		     (insert-into-indexes
		       ent ent-rid relation-handle ver "set" attribute-handle)))))))))

(defsetf get-value set-value)

;;; Special case of set-value in which the relation is surrogate-optimized,
;;; and the attribute being set is the soo-att, i.e. the entity-valued
;;; attribute that the surrogate optimization was applied to.  All of the
;;; other attribute values of the tuple are residing an entity record.
;;; They must all be moved to the new entity record specified as the new
;;; value, and this could be from a new domain.
(defun set-soo-att-value (old-ent-rid value relation-handle domain-handle database
			  opening tuple-handle soo-att)
  (check-entity-handle value)
  (let* ((new-ent-rid (handle-rid value))
	 (new-domain (known-entity-handle-domain value))
	 (old-byte-spec
	   (byte 1 (search-table-for-domain
		     (relation-handle-entity-bit-map-number relation-handle)
		     domain-handle)))
	 (new-byte-spec
	   (byte 1 (search-table-for-domain
		     (relation-handle-entity-bit-map-number relation-handle)
		     new-domain))))
    (unless (= new-ent-rid old-ent-rid)		; If setting to self, all done.
      (with-record (old-ent opening old-ent-rid :write)
	(with-record (new-ent opening new-ent-rid :write)
	  ;; Remove this tuple from all indexes.
	  (let ((ver (local-entity-version old-ent)))
	    (delete-from-indexes old-ent value relation-handle ver)
	    (dolist (a (relation-handle-list-of-attributes relation-handle))
	      (delete-from-group-index old-ent old-ent-rid relation-handle ver a)))
	  ;; Tidy up the new home in preparation for the new residents.  This
	  ;; makes sure space is allocated for all the fixed spaces of all
	  ;; the tuple's attributes.
	  (upgrade-entity new-ent domain-handle)
	  ;; The variable words of the tuple are all in one contiguous
	  ;; range within the old entity record.  Note where that range is.
	  ;; They'll all get appended to the end of the new entity record.
	  (multiple-value-bind (old-first-var-word n-var-words)
	      (range-of-var-words old-ent relation-handle soo-att domain-handle)
	    (let ((var-word-delta (- (get-record-size new-ent) old-first-var-word)))
	      ;; Copy the fixed areas of each attribute from the old entity
	      ;; record to the new one.
	      (dolist (a (relation-handle-list-of-attributes relation-handle))
		(unless (eq a soo-att)
		  (let* ((type (attribute-handle-type a))
			 (desc (attribute-handle-descriptor a))
			 (old-desc (search-table-for-domain desc domain-handle))
			 (new-desc (search-table-for-domain desc new-domain)))
		    ;; Copy the contents of the fixed area to their new site.
		    (copy-fixed-area type old-ent old-desc new-ent new-desc)
		    ;; Adjust the pointers in the fixed area to take into
		    ;; account the new home of the variable area.
		    (adjust-variable-words type new-ent new-desc var-word-delta)
		    ;; If the attribute is group-indexed, move the pointer.
		    (let ((offset (attribute-handle-group-index-offset a)))
		      (when offset
			(setf (read-record-word new-ent
						(search-table-for-domain
						  offset
						  (find-domain-handle-given-entity-rid
						    new-ent-rid database)))
			      (read-record-word old-ent
						(search-table-for-domain
						  offset
						  (find-domain-handle-given-entity-rid
						    old-ent-rid database))))))))))
	    ;; Copy the variable words, allocating in new-ent and deallocating in old-ent.
	    (unless (zerop n-var-words)
	      (let* ((new-total-size (adjust-record-size new-ent n-var-words))
		     (new-first-var-word (- new-total-size n-var-words)))
		(adjust-all-in-entity old-ent domain-handle old-first-var-word (- n-var-words))
		(loop for source from old-first-var-word
		      for dest from new-first-var-word
		      repeat n-var-words do
		  (setf (read-record-word new-ent dest) (read-record-word old-ent source))))
	      (close-gap old-ent old-first-var-word n-var-words)
	      (adjust-record-size old-ent (- n-var-words))))
	  ;; Mark the non-existence of the tuple in the old entity
	  ;; record, and existence in the new entity record.
	  (setf (local-entity-tuples-present old-ent)
		(dpb 0 old-byte-spec (local-entity-tuples-present old-ent)))
	  (setf (local-entity-tuples-present new-ent)
		(dpb 1 new-byte-spec (local-entity-tuples-present new-ent)))
	  (setf (handle-rid tuple-handle) new-ent-rid)
	  ;; Put this tuple back into the indexes.
	  (let ((ver (local-entity-version new-ent)))
	    (dolist (a (relation-handle-list-of-attributes relation-handle))
	      (insert-into-group-index new-ent new-ent-rid relation-handle ver a))
	    (insert-into-indexes new-ent new-ent-rid relation-handle ver "set" nil)))))))

;;; Given an attribute handle, return t if the attribute's type can store nil
;;; as a value.  nil means that nil for this attribute is the null value.
(defun %nil-is-valid-value (attribute-handle)
  (check-attribute-handle attribute-handle)
  (nil-is-valid-value (attribute-handle-type attribute-handle)))

;;; Special-purpose entrypoint, which should only be used by function
;;; level.  The attribute-handle must be from a relation that is
;;; surrogate optimized onto the domain of entity-handle.
;;; attribute-handle must not be the soo-att.  The caller had better not
;;; be wrong about these things!
(defun %get-value-from-entity (entity-handle attribute-handle &key into-string)
  (declare (values value value-not-null-p))
  (restart-testing-check)
  (check-entity-handle entity-handle)
  (check-attribute-handle attribute-handle)
  (let ((database (relation-handle-database (attribute-handle-relation attribute-handle)))
	(type (attribute-handle-type attribute-handle)))
    (when into-string
      (unless (string-type-p type)
	(model-error "Attribute ~S is not a string" attribute-handle)))
    (prepare-database database)
    (let ((ent-rid (handle-rid entity-handle))
	  (domain-handle (known-entity-handle-domain entity-handle)))
      (with-record (addressor (database-opening database) ent-rid :read)
	(let ((att-version
		(search-table-for-domain
		  (attribute-handle-layout-version attribute-handle)
		  domain-handle :if-not-found nil)))
	  (if (or (null att-version)
		  (and (plusp att-version)
		       (< (local-entity-version addressor) att-version)))
	      (values nil nil)
	      (let* ((descriptor
		       (search-table-for-domain
			 (attribute-handle-descriptor attribute-handle)
			 domain-handle))
		     (value (read-value type addressor descriptor database
					:into-string into-string)))
		(if (eq value *null-value*)
		    (values nil nil)
		    (values value t)))))))))

;;; Like %get-value-from-entity but returns t if the value is null and
;;; nil otherwise.
(defun %get-value-null-p-from-entity (entity-handle attribute-handle)
  (declare (values value value-not-null-p))
  (restart-testing-check)
  (check-entity-handle entity-handle)
  (check-attribute-handle attribute-handle)
  (let ((database (relation-handle-database (attribute-handle-relation attribute-handle)))
	(type (attribute-handle-type attribute-handle)))
    (prepare-database database)
    (let ((ent-rid (handle-rid entity-handle))
	  (domain-handle (known-entity-handle-domain entity-handle)))
      (with-record (addressor (database-opening database) ent-rid :read)
	(let ((att-version
		(search-table-for-domain
		  (attribute-handle-layout-version attribute-handle)
		  domain-handle :if-not-found nil)))
	  (or (null att-version)
	      (and (plusp att-version)
		   (< (local-entity-version addressor) att-version))
	      (value-null-p type addressor (search-table-for-domain
					     (attribute-handle-descriptor attribute-handle)
					     domain-handle))))))))

;;; Special-purpose entrypoint, which should only be used by function
;;; level.  The attribute-handle must be from a relation that is
;;; surrogate optimized onto the domain of entity-handle.
;;; attribute-handle must not be the soo-att.  The caller had better not
;;; be wrong about these things!
(defun %set-value-from-entity (entity-handle attribute-handle value)
  (restart-testing-check)
  (check-entity-handle entity-handle)
  (check-attribute-handle attribute-handle)
  (let* ((type (attribute-handle-type attribute-handle))
	 (of-type (statice-typep type value)))
    (unless (or of-type (null value))
      (error 'wrong-type-value :value value :storage-handler type))
    (when (and (attribute-handle-unique attribute-handle)
	       (not (attribute-handle-indexed attribute-handle)))
      (check-unique-attribute-value attribute-handle value "set" (handle-rid entity-handle)))
    (%set-value-from-entity-internal
      entity-handle
      attribute-handle
      (if of-type value *null-value*)))
  t)

;;; Special-purpose entrypoint, which should only be used by function
;;; level.  The attribute-handle must be from a relation that is
;;; surrogate optimized onto the domain of entity-handle.
;;; attribute-handle must not be the soo-att.  The caller had better not
;;; be wrong about these things!
(defun %set-to-null-value-from-entity (entity-handle attribute-handle)
  (restart-testing-check)
  (check-entity-handle entity-handle)
  (check-attribute-handle attribute-handle)
  (when (attribute-handle-no-nulls attribute-handle)
    (model-error "Attribute ~A is no-nulls, values cannot be set to the null value"
		 attribute-handle))
  (%set-value-from-entity-internal entity-handle attribute-handle *null-value*)
  t)

(defun %set-value-from-entity-internal (entity-handle attribute-handle value)
  (let* ((relation-handle (attribute-handle-relation attribute-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (ent-rid (handle-rid entity-handle))
	 (domain-handle (known-entity-handle-domain entity-handle)))
    (prepare-database database)
    (let ((soo-domain (attribute-handle-type
			(relation-handle-surrogate-optimized-on relation-handle))))
      (when (domain-handle-new-layout-needed soo-domain)
	(compute-new-domain-layout soo-domain)))
    (with-record (ent opening ent-rid :write)
      (let ((ver (local-entity-version ent)))
	(delete-from-indexes ent ent-rid relation-handle ver attribute-handle)
	(delete-from-group-index
	  ent ent-rid relation-handle ver attribute-handle))
      (upgrade-entity ent domain-handle)
      (put-value type value ent
		 (search-table-for-domain
		   (attribute-handle-descriptor attribute-handle)
		   domain-handle :if-not-found nil)
		 database domain-handle t)
      (let ((ver (local-entity-version ent)))
	(insert-into-group-index
	  ent ent-rid relation-handle ver attribute-handle)
	(insert-into-indexes ent ent-rid relation-handle ver "set" attribute-handle)))))

;;; External entrypoint for generic database inspector et al.
(defun format-value (tuple-handle attribute-handle stream)
  (check-tuple-handle tuple-handle)
  (check-attribute-handle attribute-handle)
  ;; no need to call prepare-database since a tuple-handle is being
  ;; passed in here
  (format-data (attribute-handle-type attribute-handle) attribute-handle tuple-handle stream))

;;; This is the entrypoint used by the model dumper.  This function does
;;; something much like get-value and get-value-internal to obtain an
;;; addressor and descriptor, and then calls the generic function
;;; format-data-internal to dispatch on the handler type.
;;; Unfortunately, it can't use the get-value-internal macro itself,
;;; because the macro sometimes does not run its body.
(defun format-data (type attribute-handle tuple-handle stream)
  (let* ((relation-handle (tuple-handle-relation tuple-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
      (model-error
	"Attribute ~S is not part of relation ~S" attribute-handle relation-handle))
    (cond ((null soo-att)
	   ;; This is a normal relation.
	   (with-record (addressor opening (handle-rid tuple-handle) :read)
	     (if (or (null att-version)
		     (and (plusp att-version)
			  (< (tuple-version addressor) att-version)))
		 (format-data-internal type nil nil stream database)
		 (format-data-internal type
				       addressor
				       (attribute-handle-descriptor attribute-handle)
				       stream
				       database))))
	  (t
	   ;; This is a surrogate-optimized relation.
	   (let* ((ent-rid (handle-rid tuple-handle))
		  (entity-handle (find-entity-handle-given-rid ent-rid database))
		  (domain-handle (known-entity-handle-domain entity-handle)))
	     (if (eq attribute-handle soo-att)
		 (format-data-internal type ent-rid nil stream database)
		 (with-record (addressor opening ent-rid :read)
		   (let ((att-version (search-table-for-domain att-version domain-handle
							       :if-not-found nil)))
		     (if (or (null att-version)
			     (and (plusp att-version)
				  (< (local-entity-version addressor) att-version)))
			 (format-data-internal type nil nil stream database)
			 (format-data-internal
			   type
			   addressor
			   (search-table-for-domain
			     (attribute-handle-descriptor attribute-handle)
			     domain-handle)
			   stream
			   database))))))))))

(defun make-domain (name &optional parent-domain-handles
		    &key (database *current-database*) (area 1) (domain-index-p nil))
  (restart-testing-check)
  (check-transaction)
  (check-type name string)
  (check-type database database)
  (check-type area (integer (0) *))
  (prepare-database database)
  (dolist (pdh parent-domain-handles)
    (check-domain-handle pdh)
    (unless (eq database (domain-handle-database pdh))
      (model-error "The parent domain is not in database ~S" database)))
  (when (fast-gethash name (database-table-of-domains database))
    (error 'domain-already-exists :name name :database database))
  (note-schema-modified database)
  (let* ((opening (database-opening database))
	 (name-n-bytes (length name))
	 (the-domain-domain (find-domain-handle-given-name "%%domain" database))
	 (dom-rid (make-record opening (+ (record-size domain) (ceiling name-n-bytes 4))))
	 (domain-handle
	   (make-instance 'domain-handle
			  :rid dom-rid
			  :domain the-domain-domain
			  :database database
			  :name name
			  :list-of-parent-domains (copy-seq parent-domain-handles)
			  :next-layout-version 1
			  :new-layout-needed nil
			  :system-domain-p nil
			  :relations-optimized-on nil
			  :allocation-map nil
			  :group-indexed-attributes nil
			  :area area
			  :bset-iid nil)))
    ;; Layout the new domain for any relations which are opt'md onto parent domains.
    (let ((next-bit-number -1))
      (do-domains (d database)
		   (when (and (child-of-p d domain-handle)
			      (not (domain-handle-system-domain-p d)))
		     (when (not (domain-handle-system-domain-p d))
		       (dolist (r (domain-handle-relations-optimized-on d))
			 (unless (member r
					 (domain-handle-relations-optimized-on domain-handle))
			   (push r (domain-handle-relations-optimized-on domain-handle))
			   (setf (domain-handle-new-layout-needed domain-handle) t)
			   (with-record (dom opening (handle-rid domain-handle) :write)
			     (setf (domain-new-layout-needed dom) 1))
			   (add-domain-to-bit-table opening r domain-handle
						    (incf next-bit-number))))))))
    ;; Initialize the group-index-attributes list.
    (dolist (pdh parent-domain-handles)
      (dolist (gi-atts (domain-handle-group-indexed-attributes pdh))
	(setf (domain-handle-new-layout-needed domain-handle) t)
	(with-record (dom opening (handle-rid domain-handle) :write)
	  (setf (domain-new-layout-needed dom) 1))
	(push gi-atts (domain-handle-group-indexed-attributes domain-handle))))
    ;; Initialize the contents of the domain record.
    (with-record (dom opening dom-rid :write)
      (setf (domain-word-of-flags dom) 0)
      (set-new-entity-uid dom domain-handle)
      (let* ((bid (domain-handle-bset-iid the-domain-domain))
	     (new-bid (insert-bset-key opening bid dom-rid)))
	  (unless (= bid new-bid)
	    (with-record (r opening (handle-rid the-domain-domain) :write)
	      (setf (domain-bset-iid r) new-bid))
	    (setf (domain-handle-bset-iid the-domain-domain) new-bid)))
      (setf (entity-domain dom) (handle-rid the-domain-domain))
      (setf (local-entity-version dom) 0)
      (setf (local-entity-tuples-present dom) 1)
      (setf (domain-bset-iid dom) 0)
      (setf (domain-area dom) area)
      (setf (domain-name-n-bytes dom) name-n-bytes)
      (setf (domain-name-start-word dom) (record-size domain))
      (setf (domain-next-layout-version dom) 1)
      (write-string-to-record dom name-n-bytes (record-size domain) name)
      (setf (domain-mbz0 dom) 0)
      (setf (domain-mbz1 dom) 0)
      (setf (domain-mbz2 dom) 0)
      (setf (domain-mbz3 dom) 0)
      (case (length parent-domain-handles)
	(0 (setf (domain-list-of-parent-domains dom) 0))
	(1 (setf (domain-list-of-parent-domains dom)
		 (handle-rid (first parent-domain-handles))))
	(otherwise
	  (setf (domain-many-parent-domains dom) 1)
	  (setf (domain-list-of-parent-domains dom)
		(let ((prev 0)
		      (spdc (record-size parent-domain-cons)))
		  (dolist (pdh parent-domain-handles)
		    (let ((pdc-rid (make-record opening spdc)))
		      (with-record (pdc opening pdc-rid :write)
			(setf (parent-domain-cons-parent-domain pdc) (handle-rid pdh))
			(setf (parent-domain-cons-next pdc) prev))
		      (setq prev pdc-rid)))
		  prev)))))
    ;; Make a tuple in the "%%subdomain" domain for every parent domain.
    (dolist (pdh parent-domain-handles)
      (make-system-tuple database "%%subdomain" "of" pdh "is" domain-handle))
    (setf (gethash (list dom-rid database) (new-entity-handles)) domain-handle)
    (when domain-index-p
      (make-domain-index-internal domain-handle opening))
    ;; To ensure that delete-domain deletes from the bottom up, the new domain is
    ;; put on the front.  Hence, descendents precede parents on the list.  See
    ;; delete-domain for details.
    (setf (gethash name (database-table-of-domains database)) domain-handle)
    domain-handle))

(defun get-domain (name &key (database *current-database*))
  (restart-testing-check)
  (check-transaction)
  (check-type database database)
  (check-type name string)
  (prepare-database database)
  (let ((handle (find-domain-handle-given-name name database)))
    (setf (gethash handle (checked-entity-handles)) t)
    handle))

(defun delete-domain (domain-handle parent-relations)
  (restart-testing-check)
  (check-user-domain-handle domain-handle)
  (let ((database (domain-handle-database domain-handle)))
    (prepare-database database)
    (note-schema-modified database)
    ;; The trick is that the argument to delete-domain-internal must not
    ;; have any children of its own.  That is, the sublattice of domains
    ;; has to be deleted from the bottom up.
    (let ((kids (scl:make-hash-table :locking nil)))
      ;; The kids table maps from a domain to a list of the immediate
      ;; children of the domain.
      (do-domains (d database)
	(dolist (p (domain-handle-list-of-parent-domains d))
	  (scl:modify-hash kids p #'(lambda (key value found-p)
				      (declare (ignore key found-p))
				      (cons d value)))))
      ;; Next, gather the set of domains to be deleted, in no order.
      (let ((set nil))
	(labels ((walk (dh)
		   (push dh set)
		   (mapc #'walk (fast-gethash dh kids))))
	  (walk domain-handle))
	;; Next, build the final answer by adding handles to the list only
	;; if none of the parents of the handle are still in the set.
	(let ((answer nil))
	  (loop until (null set) do
	    (dolist (dh set)
	      (when (loop for p in (domain-handle-list-of-parent-domains dh)
			  never (member p set))
		(push dh answer)
		(setq set (delete dh set)))))
	  (mapc #'(lambda (an-answer)
		    (declare (sys:downward-function))
		    (delete-domain-internal an-answer parent-relations))
		answer)))))
  t)

;;; The caller guarantees that domain-handle is a user domain.
(defun delete-domain-internal (domain-handle parent-relations)
  (let* ((database (domain-handle-database domain-handle))
	 (opening (database-opening database))
	 (dom-rid (handle-rid domain-handle)))
    ;; Delete all tuples, in the remaining relations, that contain any
    ;; entities of the domain.
    (delete-tuples-using-domain domain-handle)
    ;; Delete each relation that is surrogate-optimized on this domain,
    ;; and any attribute whose type is domain-handle.
    (when (domain-handle-bset-iid domain-handle)
      (delete-domain-index-internal domain-handle opening))
    (map-over-entity-records domain-handle
			     #'(lambda (ent-rid)
				 (with-record (ent opening ent-rid :write)
				   (let ((version (local-entity-version ent)))
				     (loop for pr in parent-relations do
				       (delete-from-indexes ent ent-rid pr version))))
				 (delete-record opening ent-rid)
				 (nullify-entity-given-rid ent-rid database)))
    (do-relations (r database)
      (let ((soo-att (relation-handle-surrogate-optimized-on r)))
	(cond ((and soo-att (eq (attribute-handle-type soo-att) domain-handle))
	       (delete-relation-internal r))
	      (t
	       (dolist (a (relation-handle-list-of-attributes r))
		 (cond ((eq (attribute-handle-type a) domain-handle)
			(delete-attribute a))
		       ((and soo-att
			     (not (relation-handle-system-relation-p r))
			     (attribute-handle-descriptor a)
			     (search-table-for-domain (attribute-handle-descriptor a)
						      domain-handle
						      :if-not-found nil))
			;;This is an attribute of a surrogate-optimized relation which
			;;happens to have a layout for the domain we are deleting.
			;;Be sure to remove this information from the database
			;;and the schema cache.  -- Feinberg 9/10/91
			(let ((cons-rid-to-delete
				(loop with prev-rid = nil
				      with current-rid =
					(with-record (att opening (handle-rid a) :read)
					  (attribute-descriptor att))
				      until (zerop current-rid) do
				  (with-record (cons opening current-rid :write)
				    (when (= (attribute-desc-and-layout-cons-domain cons)
					     dom-rid)
				      ;;We found the cons, now splice it out of the
				      ;;database.
				      (cond (prev-rid
					     (with-record (prev-cons opening prev-rid
								     :write)
					       (setf (attribute-desc-and-layout-cons-next
						       prev-cons)
						     (attribute-desc-and-layout-cons-next
						       cons))))
					    (t
					     (with-record (att opening (handle-rid a)
							       :write)
					       (setf (attribute-descriptor att)
						     (attribute-desc-and-layout-cons-next
						       cons)))))
				      (return current-rid))
				    ;;Didn't find the cons, move onto the next, if there
				    ;;is one.
				    (setf prev-rid current-rid)
				    (setf current-rid (attribute-desc-and-layout-cons-next
							cons)))
				      finally (return nil))))
			  (when cons-rid-to-delete
			    (delete-record opening cons-rid-to-delete))
			  ;;Update the cache
			  (delete-domain-from-table (attribute-handle-descriptor a)
						    domain-handle)
			  (delete-domain-from-table (attribute-handle-layout-version a)
						    domain-handle)
			  (when (zerop (length (attribute-handle-descriptor a)))
			    (setf (attribute-handle-descriptor a) nil)
			    (setf (attribute-handle-layout-version a) nil))))))
	       (when (and soo-att (domain-in-entity-bit-map r domain-handle))
		 ;;Splice out this domain from the entity-bit-map-number table
		 ;;of any relation which contains the domain in its table.
		 ;;First, prune the physical database.
		 (let ((cons-rid-to-delete 
			 (splice-out-entity-bit-map-number-entry-for-domain r domain-handle)))
		   (when cons-rid-to-delete
		     (delete-record opening cons-rid-to-delete)))
		 ;;Then clean up the encached schema
		 (remove-domain-from-schema-entity-bit-map r domain-handle))))))
    (when (domain-handle-bset-iid domain-handle)
      (delete-domain-index-internal domain-handle opening))
    (map-over-entity-records domain-handle
			     #'(lambda (ent-rid)
				 (delete-record opening ent-rid)
				 (nullify-entity-given-rid ent-rid database)))
    (let* ((dd (find-domain-handle-given-name "%%domain" database))
	   (bid (domain-handle-bset-iid dd))
	   (new-bid (delete-bset-key opening bid dom-rid)))
      (unless (= new-bid bid)
	(with-record (d opening dd :write)
	  (setf (domain-bset-iid d) new-bid))
	(setf (domain-handle-bset-iid dd) new-bid)))
    (delete-record opening dom-rid)
    (remhash (domain-handle-name domain-handle) (database-table-of-domains database))
    (push domain-handle (database-deleted-domains database))
    (delete-system-tuples database "%%subdomain" "is" domain-handle)
    (nullify-entity-handle domain-handle)))

(defun delete-domain-from-table (table domain)
  (let ((index (position domain table :key #'car)))
    (cond (index
	   (cl:loop for i from (+ index 1) below (length table) do
	     (setf (aref table (- i 1))
		   (aref table i)))
	   (decf (fill-pointer table)))
	  (t
	   (model-bug "Domain ~S missing from table." domain)))))


(defmethod domain-in-entity-bit-map ((handle relation-handle) domain-handle)
  (with-slots (entity-bit-map-number) handle
    (and entity-bit-map-number
	 (search-table-for-domain entity-bit-map-number domain-handle
				  :if-not-found nil))))

(defmethod splice-out-entity-bit-map-number-entry-for-domain ((handle relation-handle) domain)
  (declare (values entity-bit-table-cons-rid-to-delete))
  (with-slots (database rid) handle
    (let ((opening (database-opening database)))
      (with-record (rel opening rid :read)
	(loop with previous-cons-rid = nil
	      with cons-rid = (relation-entity-bit-map-list rel)
	      until (zerop cons-rid) do
	  (with-record (cons opening cons-rid :read)
	    (let ((domain-rid (entity-bit-table-cons-domain cons)))
	      (unless (= domain-rid 1)
		(let ((d (find-domain-handle-given-rid domain-rid database)))
		  (when (eq d domain)
		    (let ((next-cons-rid (entity-bit-table-cons-next cons)))
		      (cond ((null previous-cons-rid)
			     (upgrade-record-mode rel :write)
			     (setf (relation-entity-bit-map-list rel)
				   next-cons-rid))
			    (t
			     (with-record (previous-cons opening previous-cons-rid :write)
			       (setf (entity-bit-table-cons-next previous-cons)
				     next-cons-rid)))))
		    (return cons-rid)))))
	    (shiftf previous-cons-rid cons-rid (entity-bit-table-cons-next cons)))
	      finally (return nil))))))


(defmethod remove-domain-from-schema-entity-bit-map ((handle relation-handle) domain-handle)
  (with-slots (entity-bit-map-number) handle
    (loop with relocate-index = nil
	  for i from 0 below (length entity-bit-map-number)
	  as (possible-delete-domain) = (aref entity-bit-map-number i) do
      (cond ((eq possible-delete-domain domain-handle)
	     (when relocate-index
	       (error "Statice system bug: multiple copies of domain in ~
				         entity-bit-map-number table."))
	     (setf relocate-index i))
	    ((not (null relocate-index))
	     (setf (aref entity-bit-map-number relocate-index)
		   (aref entity-bit-map-number i))
	     (incf relocate-index)))
	  finally
	    (when relocate-index
	      (decf (fill-pointer entity-bit-map-number))))))

;;; Delete all tuples in domain-handle's database that contain any
;;; entity of that domain as an attribute value.  The caller guarantees
;;; that it will delete the entities itself, after this function
;;; returns.  The caller also guarantees that it has already deleted any
;;; relations that have attributes whose type is equal to domain-handle.
;;; Note:  if we ever allow cross-database inheritance, then this will
;;; need improvement.   == Does not yet use indexes, but should.
(defun delete-tuples-using-domain (domain-handle)
  (let* ((database (domain-handle-database domain-handle))
	 (opening (database-opening database))
	 (domain-rid (handle-rid domain-handle)))
    (do-relations (relation-handle database)
      ;; Is it possible that some tuple of this relation contains
      ;; an entity of domain-handle?  Check each attribute, and build up
      ;; a list of "hot" attributes, namely the ones that might have
      ;; allowed such an entity as an attribute value.  Explicitly
      ;; exclude the entity-domain system relation, for obvious reasons.
      ;; If the layout-version is nil, then no tuples have
      ;; non-null values for this attribute, so it cannot be hot.  (This
      ;; saves a check later.)
      (let* ((entity-domain-relation
	       (find-relation-handle-given-name "%%entity-domain" database))
	     (protector-attributes nil)
	     (hot-attributes nil))
	(unless (eq relation-handle entity-domain-relation)
	  (dolist (attribute-handle (relation-handle-list-of-attributes relation-handle))
	    (when (and (not (null (attribute-handle-layout-version
					      attribute-handle)))
				 (let ((type (attribute-handle-type attribute-handle)))
				   (and (typep type 'domain-handle)
					(labels
					  ((type-is-parent-of (d)
					     (or (eq d type)
						 (loop for p
						  in (domain-handle-list-of-parent-domains d)
					      thereis (type-is-parent-of p)))))
					  (type-is-parent-of domain-handle)))))
	      (if (and (attribute-handle-no-nulls attribute-handle)
		       (attribute-handle-delete-nullifies attribute-handle))
		  (push attribute-handle protector-attributes)
		(push attribute-handle hot-attributes)))))
	(when (or hot-attributes protector-attributes)
	  ;; This relation might have some tuples to be deleted.
	  (let ((soo-att (relation-handle-surrogate-optimized-on relation-handle))
		(combined-attributes (nconc protector-attributes hot-attributes)))
	    (cond ((null soo-att)
		   ;; This is a normal relation.  Loop over all the tuples,
		   ;; and delete those that contain entities of type domain-handle.
		   (let ((bid (relation-handle-bset-iid relation-handle)))
		     (map-over-tuple-records
		       relation-handle
		       #'(lambda (tuple-rid)
			   (with-record (tuple opening tuple-rid :read)
			     (let ((tuple-version (tuple-version tuple)))
			       (when (loop for a in combined-attributes do
				       (when (and (>= tuple-version
						     (attribute-handle-layout-version a))
						  (let ((entity-rid
							  (read-record-word
							    tuple
							    (attribute-handle-descriptor a))))
						    (unless (zerop entity-rid)
						      (with-record
							(ent opening entity-rid :read)
							(= domain-rid
							   (entity-domain ent))))))
					 (cond ((member a protector-attributes)
						(error "Attempt to delete ~S which is in use ~
							by :no-nulls attribute ~A."
						       domain-handle a))
					       ((attribute-handle-delete-nullifies a)
						(set-to-null-value tuple a))
					       (t
						(return t))))
				       finally (return nil))
				 ;; There's the entity of our domain.
				 ;; Delete this tuple.
				 ;; Think about making a delete-tuple-internal some day,
				 ;; and calling that instead.  -- Feinberg 9/11/91
				 (dolist (a (relation-handle-list-of-attributes
					      relation-handle))
				   (delete-from-group-index tuple
							    tuple-rid
							    relation-handle
							    tuple-version
							    a))
				 (when bid
				   (let ((new-bid (delete-bset-key opening bid tuple-rid)))
				     (unless (= new-bid bid)
				       (note-schema-modified database)
				       (with-record (r opening (handle-rid relation-handle)
						       :write)
					 (setf (relation-bset-iid r) new-bid))
				       (setf (relation-handle-bset-iid relation-handle)
					     new-bid))))
				 (delete-from-indexes
				   tuple tuple-rid relation-handle tuple-version)
				 (delete-record opening tuple-rid)
				 (nullify-tuple-given-rid
				   tuple-rid relation-handle))))))))
		  (t
		   ;; This is a surrogate-optimized relation.  The soo-att
		   ;; itself cannot be hot, because either its type is our
		   ;; domain, in which case we would have already deleted the
		   ;; relation, or its type is a parent, in which case we
		   ;; would have also deleted it.
		   (when (member soo-att hot-attributes)
		     (model-bug "soo-att should not be a hot attribute"))
		   (let ((soo-domain-handle (attribute-handle-type soo-att)))
		     (do-children (d soo-domain-handle database)
		       (let ((byte-spec
			       (byte 1 (search-table-for-domain
					 (relation-handle-entity-bit-map-number
					   relation-handle)
					 d)))
			     (bid (relation-handle-bset-iid relation-handle)))
			 (map-over-entity-records
			   d
			   #'(lambda (ent-rid)
			       (with-record (ent opening ent-rid :read)
				 (let ((present (local-entity-tuples-present ent)))
				   (when (loop for a in combined-attributes do
					   (let ((desc (search-table-for-domain
							 (attribute-handle-descriptor a)
							 d :if-not-found nil)))
					     (when (and
						     (= 1 (ldb byte-spec present))
						     (>= (local-entity-version ent)
							(or (search-table-for-domain
							      (attribute-handle-layout-version
								a)
							      d :if-not-found nil)
							  0))
						     (when desc
						       (let ((entity-rid
							       (read-record-word
								 ent
								 desc)))
							 (unless (zerop entity-rid)
							   (with-record
							     (ent opening entity-rid :read)
							     (= domain-rid
								(entity-domain ent)))))))
					       (cond ((member a protector-attributes)
						      (error "Attempt to delete ~S which is ~
 							      in use by :no-nulls attribute ~
							      ~A."
							     domain-handle a))
						     ((attribute-handle-delete-nullifies a)
						      (when desc
							(with-record (ent opening ent-rid
									  :write)
							  (write-record-word ent desc 0))))
						     (t
						      (return t)))))
					       finally (return nil))
				     ;; There's the entity of our domain.
				     ;; Delete this tuple.
				     ;; +++ Probably should delete the whole entity?
				     ;; -- Feinberg 9/11/91
				     (upgrade-record-mode ent :write)
				     (let ((ver (local-entity-version ent)))
				       (dolist (a (relation-handle-list-of-attributes
						    relation-handle))
					 (delete-from-group-index
					   ent ent-rid relation-handle ver a))
				       (delete-from-indexes ent ent-rid relation-handle ver))
				     (when bid
				       (let ((new-bid (delete-bset-key opening bid ent-rid)))
					 (unless (= new-bid bid)
					   (note-schema-modified database)
					   (with-record
					     (r opening (handle-rid relation-handle) :write)
					     (setf (relation-bset-iid r) new-bid))
					   (setf (relation-handle-bset-iid relation-handle)
						 new-bid))))
				     (deallocate-tuple-from-entity
				       ent relation-handle d soo-att)
				     (nullify-tuple-given-rid
				       ent-rid relation-handle)))))))))))))))))

(defun make-relation (name &key (database *current-database*) (area 1) (relation-index-p t))
  (restart-testing-check)
  (check-transaction)
  (check-type database database)
  (check-type name string)
  (check-type area (integer (0) *))
  (prepare-database database)
  (when (fast-gethash name (database-table-of-relations database))
    (error 'relation-already-exists :name name :database database))
  (note-schema-modified database)
  (let* ((opening (database-opening database))
	 (name-n-bytes (length name))
	 (the-relation-domain (find-domain-handle-given-name "%%relation" database))
	 (rel-rid (make-record opening (+ (record-size relation) (ceiling name-n-bytes 4))))
	 (relation-handle
	   (make-instance 'relation-handle
			  :rid rel-rid
			  :domain the-relation-domain
			  :database database
			  :name name
			  :list-of-attributes nil
			  :list-of-indexes nil
			  :surrogate-optimized-on nil
			  :next-layout-version 0
			  :new-layout-needed t
			  :allocation-map nil
			  :system-relation-p nil
			  :entity-bit-map-number nil
			  :area area
			  :bset-iid nil)))
    ;; Initialize the contents of the relation record.
    (with-record (rel opening rel-rid :write)
      (setf (relation-word-of-flags rel) 0)
      (set-new-entity-uid rel relation-handle)
      (let* ((bid (domain-handle-bset-iid the-relation-domain))
	     (new-bid (insert-bset-key opening bid rel-rid)))
	(unless (= bid new-bid)
	  (with-record (r opening (handle-rid the-relation-domain) :write)
	    (setf (domain-bset-iid r) new-bid))
	  (setf (domain-handle-bset-iid the-relation-domain) new-bid)))
      (setf (entity-domain rel) (handle-rid the-relation-domain))
      (setf (local-entity-version rel) 0)
      (setf (local-entity-tuples-present rel) 1)
      (setf (relation-list-of-attributes rel) 0)
      (setf (relation-list-of-indexes rel) 0)
      (setf (relation-surrogate-optimized-on rel) 0)
      (setf (relation-next-layout-version rel) 0)
      (setf (relation-new-layout-needed rel) 1)
      (setf (relation-bset-iid rel) 0)
      (setf (relation-area rel) area)
      (setf (relation-name-n-bytes rel) name-n-bytes)
      (setf (relation-name-start-word rel) (record-size relation))
      (setf (relation-mbz0 rel) 0)
      (setf (relation-mbz1 rel) 0)
      (setf (relation-mbz2 rel) 0)
      (setf (relation-mbz3 rel) 0)
      (setf (relation-entity-bit-map-list rel) 0)
      (write-string-to-record rel name-n-bytes (record-size relation) name))
    (when relation-index-p
      (make-relation-index relation-handle))
    (setf (gethash name (database-table-of-relations database)) relation-handle)
    (setf (gethash (list rel-rid database) (new-entity-handles)) relation-handle)
    relation-handle))

(defun get-relation (name &key (database *current-database*))
  (restart-testing-check)
  (check-transaction)
  (check-type name string)
  (check-type database database)
  (prepare-database database)
  (let ((handle (find-relation-handle-given-name name database)))
    (setf (gethash handle (checked-entity-handles)) t)
    handle))

(defun delete-relation (relation-handle)
  (restart-testing-check)
  (check-user-relation-handle relation-handle)
  (prepare-database (relation-handle-database relation-handle))
  (delete-relation-internal relation-handle)
  t)

;;; The caller guarantees that the relation is a user relation
(defun delete-relation-internal (relation-handle)
  (when (relation-handle-system-relation-p relation-handle)	;Extra-safe.
    (model-bug "delete-relation-internal of a system relation"))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (rel-rid (handle-rid relation-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))    
    (note-schema-modified database)
    ;; Delete all the group indexes.
    (dolist (a (relation-handle-list-of-attributes relation-handle))
      (when (attribute-handle-group-index-offset a)
	(delete-group-index a)))
    ;; Delete all the tuples.
    (cond ((null soo-att)
	   ;; This is a normal relation.
	   (map-over-tuple-records
	     relation-handle
	     #'(lambda (tuple-rid)
		 (nullify-tuple-given-rid tuple-rid relation-handle)
		 (delete-record opening tuple-rid))))
	  (t
	   (let ((soo-domain (attribute-handle-type soo-att)))
	     (do-children (domain-handle soo-domain database)
	       ;; This is a surrogate-optimized relation.
	       (let* ((byte-spec 
			(byte 1 (search-table-for-domain
				  (relation-handle-entity-bit-map-number relation-handle)
				  domain-handle))))
		 (map-over-entity-records
		   domain-handle
		   #'(lambda (ent-rid)
		       (with-record (ent opening ent-rid :read)
			 (let ((present (local-entity-tuples-present ent)))
			   (when (= 1 (ldb byte-spec present))
			     (upgrade-record-mode ent :write)
			     (nullify-tuple-given-rid ent-rid relation-handle)
			     (deallocate-tuple-from-entity
			       ent relation-handle domain-handle soo-att))))))
		 (setf (domain-handle-relations-optimized-on domain-handle)
		       (delete relation-handle
			       (domain-handle-relations-optimized-on domain-handle))))))))
    ;; Delete all of the relation's indexes.
    (dolist (index-handle (relation-handle-list-of-indexes relation-handle))
      (delete-index-internal index-handle))
    ;; Delete all of the relation's attributes.
    (let ((the-attribute-domain (find-domain-handle-given-name "%%attribute" database))
	  (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
      (dolist (attribute-handle (relation-handle-list-of-attributes relation-handle))
	(let ((att-rid (handle-rid attribute-handle)))
	  (with-record (att opening att-rid :write)
	    ;; Remove the attribute from the database-wide list of attributes.
	    (let* ((bid (domain-handle-bset-iid the-attribute-domain))
		   (new-bid (delete-bset-key opening bid att-rid)))
	      (unless (= new-bid bid)
		(with-record (ad opening (handle-rid the-attribute-domain) :write)
		  (setf (domain-bset-iid ad) new-bid))
		(setf (domain-handle-bset-iid the-attribute-domain) new-bid)))
	    ;; If this attribute is part of a optm'd relation, delete the
	    ;; attribute-descriptor-cons records.
	    (when (and soo-att (not (eql soo-att attribute-handle)))
	      (let ((att-cons-rid (attribute-descriptor att))
		    (next nil))
		(loop until (zerop att-cons-rid) do
		  (with-record (att-cons opening att-cons-rid :write)
		    (setq next (attribute-desc-and-layout-cons-next att-cons)))
		  (delete-record opening att-cons-rid)
		  (setq att-cons-rid next)))))
	  (delete-record opening att-rid))
	(push attribute-handle (database-deleted-attributes database))
	(nullify-entity-handle attribute-handle)))
    ;; Remove relation from the list of relations.
    (let* ((rd (find-domain-handle-given-name "%%relation" database))
	   (bid (domain-handle-bset-iid rd))
	   (new-bid (delete-bset-key opening bid rel-rid)))
      (unless (= new-bid bid)
	(with-record (rd opening (handle-rid rd) :write)
	  (setf (domain-bset-iid rd) new-bid))
	(setf (domain-handle-bset-iid rd) new-bid)))
    (remhash (relation-handle-name relation-handle) (database-table-of-relations database))
    (push relation-handle (database-deleted-relations database))
    (delete-record opening rel-rid)
    (nullify-entity-handle relation-handle)))

(defun make-attribute (relation-handle name type
		       &key unique-p surrogate-p delete-nullifies no-nulls)
  (restart-testing-check)
  (check-user-relation-handle relation-handle)
  (check-type name string)
  (let ((database (relation-handle-database relation-handle))
	(type-is-a-domain (typep type 'domain-handle)))
    ;; Instate the following line when typep learns about presentation
    ;; types and does it in less then geological time.
    ;;(check-type type (or domain-handle dw:presentation-type))
    (unless (or type-is-a-domain (presentation-type-p type))
      (model-error "~S is not a valid attribute type, for attribute ~S of ~S"
		   type name relation-handle ))
    (when type-is-a-domain
      (check-entity-handle type))			;Is this really needed?
    (prepare-database database)
    (dolist (a (relation-handle-list-of-attributes relation-handle))
      (when (string-equal name (attribute-handle-name a))
	(error 'attribute-already-exists :name name :relation relation-handle)))
    (let ((soo-att (relation-handle-surrogate-optimized-on relation-handle))
	  (not-empty-relation-p
	    ;; Only compute this if we're going to need it.
	    (when (or surrogate-p no-nulls)
	      (block tuples-exist
		(map-over-tuples relation-handle
				 #'(lambda (tuple rid version)
				     (declare (ignore tuple rid version))
				     (return-from tuples-exist t))))))
	  (opening (database-opening database))
	  entity-bit-map-number)
      (when surrogate-p
	(unless unique-p
	  (model-error "Can't make attribute ~S of relation ~S~@
                        surrogate since it is not unique"
		       name relation-handle))
	(when not-empty-relation-p
	  (model-error "Can't make attribute ~S of relation ~S~@
                        surrogate since tuples already exist"
		       name relation-handle))
	(when soo-att
	  (model-error "Can't make attribute ~S of relation ~S~@
                        surrogate since ~S is already surrogate"
		       name relation-handle soo-att))	
	(unless type-is-a-domain
	  (model-error "Can't make attribute ~S of relation ~S~@
                        surrogate since its type is not a domain"
		       name relation-handle))
	(unless (eq (relation-handle-database relation-handle)
		    (domain-handle-database type))
	  (model-error "Can't make attribute ~S of relation ~S~@
                        surrogate since it does not reside in the~@
                      same database as its type domain"
		       name relation-handle))
	(unless (eq (relation-handle-area relation-handle)
		    (domain-handle-area type))
	  (model-error "Can't make attribute ~S of relation ~S~@
                        surrogate since it does not reside in the~@
                        same area as its type domain"
		       name relation-handle))
	(setq entity-bit-map-number
	      (let ((domains-and-bits nil))
		(do-children (domain-handle type database)
		  (let ((roo (domain-handle-relations-optimized-on domain-handle))
			(max-bit -1))
		    (dolist (r roo)
		      (let ((bit-array (relation-handle-entity-bit-map-number r)))
			(setq max-bit (max max-bit
					   (search-table-for-domain bit-array
								    domain-handle)))))
		    (push (cons domain-handle (1+ max-bit)) domains-and-bits)))
		domains-and-bits)))
      (when delete-nullifies
	(unless type-is-a-domain
	  (model-error "Can't set delete-nullifies on attribute ~S of relation ~S~@
                        since its type is not a domain." soo-att relation-handle)))
      (when (and no-nulls not-empty-relation-p)
	;; no-nulls requested, and relations already exist.  Don't allow
	;; since implies null values for this attribute in all existing tuples.
	(model-error
	  "Can't create :no-nulls attribute named ~S since tuples already exist"
	  name))
      (let* ((name-n-bytes (length name))
	     (name-n-words (ceiling name-n-bytes 4))
	     (the-attribute-domain (find-domain-handle-given-name "%%attribute" database))
	     (the-attribute-relation (find-relation-handle-given-name "%%attribute" database))
	     (att-type-handler (attribute-handle-type
				 (find-attribute-handle-given-name
				   "type" the-attribute-relation)))
	     (partial-size (+ (record-size attribute) name-n-words))
	     (size-of-type (size-of-value att-type-handler type partial-size database))
	     (att-rid (make-record opening (+ partial-size size-of-type)))
	     (rel-rid (handle-rid relation-handle))
	     (storage-handler (if type-is-a-domain
				  type
				  (get-storage-handler type no-nulls)))
	     (attribute-handle
	       (make-instance 'attribute-handle
			      :rid att-rid
			      :domain the-attribute-domain
			      :relation relation-handle
			      :name name
			      :type storage-handler
			      :descriptor nil
			      :layout-version nil
			      :unique (not (null unique-p))
			      :delete-nullifies delete-nullifies
			      :indexed nil
			      :group-index-offset nil
			      :group-index-layout-version nil
			      :group-index-average-size 0
			      :no-nulls no-nulls)))
	(note-schema-modified database)
	;; Initialize the contents of the attribute record.
	(with-record (att opening att-rid :write)
	  (setf (attribute-word-of-flags att) 0)
	  (with-record (rel opening rel-rid :write)
	    (set-new-entity-uid att attribute-handle)
	    (let* ((bid (domain-handle-bset-iid the-attribute-domain))
		   (new-bid (insert-bset-key opening bid att-rid)))
	      (unless (= bid new-bid)
		(with-record (ad opening (handle-rid the-attribute-domain) :write)
		  (setf (domain-bset-iid ad) new-bid))
		(setf (domain-handle-bset-iid the-attribute-domain) new-bid)))
	    (setf (entity-domain att) (handle-rid the-attribute-domain))
	    (setf (local-entity-version att) 0)
	    (setf (local-entity-tuples-present att) 1)
	    (setf (attribute-surrogate-p att) 0)
	    (cond ((not surrogate-p)
		   (cond ((null soo-att)
			  (setf (relation-handle-new-layout-needed relation-handle) t)
			  (setf (relation-new-layout-needed rel) 1))
			 (t
			  ;; The relation is already surrogate-optimized
			  ;; on some other attribute.  This is not the
			  ;; %%entity-domain relation, so the type of
			  ;; the soo-att must be a domain.
			  (let ((soo-domain (attribute-handle-type soo-att)))
			    (do-children (domain-handle soo-domain database)
			      (setf (domain-handle-new-layout-needed domain-handle) t)
			      (with-record (dom opening (handle-rid domain-handle) :write)
				(setf (domain-new-layout-needed dom) 1)))))))
		  (t
		   ;; We are making the surrogate attribute of the relation.
		   ;; undo assumptions made in make-relation about this not being optimized
		   (setf (relation-handle-new-layout-needed relation-handle) nil)
		   (setf (relation-new-layout-needed rel) 0)
		   (setf (relation-handle-next-layout-version relation-handle) nil)
		   (setf (relation-next-layout-version rel) 0)
		   ;; set up rest of relation to be surrogate-optimized
		   (setf (relation-handle-surrogate-optimized-on relation-handle)
			 attribute-handle)
		   (setf (relation-surrogate-optimized-on rel) att-rid)
		   (setf (attribute-surrogate-p att) 1)
		   (setf (relation-handle-entity-bit-map-number relation-handle) nil)
		   ;; start by placing the bit-map entries previously decided on in the
		   ;; entity-bit-map-tables of the relation.
		   (loop for (domain-handle . bit-number) in entity-bit-map-number do
		     (when (> bit-number 24)
		       (model-error "Can't make ~S the soo-att because there is~@
                              maximum of 24 relations which may be optimized~@
                              onto domain ~S"
				    attribute-handle domain-handle))
		     (add-domain-to-bit-table opening relation-handle domain-handle bit-number))
		   (do-domains (d database)
		     (unless (domain-handle-system-domain-p d)
		       (when (child-of-p type d)
			 ;; Parent and child domains are both created.  A
			 ;; relation has just been soo-opt'd onto the parent
			 ;; domain, so set up all the descendant domains to
			 ;; handle the new relation.
			 (push relation-handle (domain-handle-relations-optimized-on d))
			 (with-record (dom opening (handle-rid d) :write)
			   (setf (domain-handle-new-layout-needed d) t)
			   (setf (domain-new-layout-needed dom) 1)))))))
	    (setf (attribute-delete-nullifies att) (if delete-nullifies 1 0))
	    (let ((air-rid (relation-list-of-attributes rel)))
	      (setf (attribute-next-attribute-in-relation att) air-rid)
	      (setf (relation-list-of-attributes rel) att-rid))
	    (setf (attribute-relation att) rel-rid)
	    (setf (attribute-descriptor att) 0)
	    (setf (attribute-layout-version att) -1)
	    (setf (attribute-name-n-bytes att) name-n-bytes)
	    (setf (attribute-name-start-word att) (record-size attribute))
	    (setf (attribute-unique att) (if unique-p 1 0))
	    (setf (attribute-group-index-offset att) 0)
	    (setf (attribute-group-index-layout-version att) -1)
	    (setf (attribute-group-index-average-size att) 0)
	    (setf (attribute-no-nulls att) (if no-nulls 1 0))
	    (setf (attribute-mbz0 att) 0)
	    (setf (attribute-mbz1 att) 0)
	    (setf (attribute-mbz2 att) 0)
	    (setf (attribute-mbz3 att) 0)
	    (write-string-to-record att name-n-bytes (record-size attribute) name)
	    (write-value att-type-handler type att (word-offset 'attribute-type)
			 partial-size database nil size-of-type)
 	    (store-handler-info storage-handler att)))
	(setf (gethash (list att-rid database) (new-entity-handles)) attribute-handle)
	(push attribute-handle (relation-handle-list-of-attributes relation-handle))
	attribute-handle))))

;;; Do the same thing as (dw::ptypep type 'dw:presentation-type), but
;;; don't take all day.  Metering shows that this dw::ptypep check takes
;;; 16.75ms in System 369.221.
(defconstant common-type-names
	     '(integer string boolean symbol entity-handle
		       single-float double-float lisp-object limited-string))

(defun presentation-type-p (type)
  (dw:with-type-decoded (type-name) type
     (when (or (member type-name common-type-names)
	       (and (symbolp type-name) (get type-name 'statice-presentation-type)))
       (return-from presentation-type-p t)))
  (dw:presentation-type-p type))

(defun get-attribute (relation-handle name)
  (restart-testing-check)
  (check-relation-handle relation-handle)
  (check-type name string)
  (prepare-database (relation-handle-database relation-handle))
  (let ((handle (find-attribute-handle-given-name name relation-handle)))
    (setf (cl:gethash handle (checked-entity-handles)) t)
    handle))

(defun delete-attribute (attribute-handle)
  (restart-testing-check)
  (check-user-attribute-handle attribute-handle)
  (let* ((relation-handle (attribute-handle-relation attribute-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (att-rid (handle-rid attribute-handle))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (when (eq attribute-handle soo-att)
      (model-error "delete-attribute cannot be used on a surrogate attribute"))
    (prepare-database database)
    (note-schema-modified database)
    ;; Delete any group index on this attribute.
    (when (attribute-handle-group-index-offset attribute-handle)
      (delete-group-index attribute-handle))
    ;; Delete any indexes on this attribute.
    (dolist (index-handle (relation-handle-list-of-indexes relation-handle))
      (when (member attribute-handle (index-handle-list-of-attributes index-handle))
	(delete-index-internal index-handle)))
    (let ((the-attribute-domain (find-domain-handle-given-name "%%attribute" database)))
      (with-record (att opening att-rid :write)
	;; Remove the attribute from the database-wide list of attributes.
	(let* ((bid (domain-handle-bset-iid the-attribute-domain))
	       (new-bid (delete-bset-key opening bid att-rid)))
	  (unless (= new-bid bid)
	    (with-record (ad opening (handle-rid the-attribute-domain) :write)
	      (setf (domain-bset-iid ad) new-bid))
	    (setf (domain-handle-bset-iid the-attribute-domain) new-bid)))
	;; Remove the attribute from the relation's list of attributes.
	(with-record (rel opening (handle-rid relation-handle) :write)
	  (let ((list-att-rid (relation-list-of-attributes rel)))
	    (cond ((= list-att-rid att-rid)
		   (setf (relation-list-of-attributes rel)
			  (attribute-next-attribute-in-relation att)))
		  (t
		   (loop with next-att-rid do
		     (with-record (list-att opening list-att-rid :write)
		       (setq next-att-rid (attribute-next-attribute-in-relation list-att))
		       (when (= next-att-rid att-rid)
			 (setf (attribute-next-attribute-in-relation list-att)
			       (attribute-next-attribute-in-relation att))
			 (return nil)))
		     (setq list-att-rid next-att-rid))))))
	(setf (relation-handle-list-of-attributes relation-handle)
	      (delete attribute-handle (relation-handle-list-of-attributes relation-handle)))
	;; If this attribute is part of a optm'd relation, delete the
	;; attribute-descriptor-cons records.
	(when soo-att
	  (let ((att-cons-rid (attribute-descriptor att))
		(next nil))
	    (loop until (zerop att-cons-rid) do
	      (with-record (att-cons opening att-cons-rid :write)
		(setq next (attribute-desc-and-layout-cons-next att-cons)))
	      (delete-record opening att-cons-rid)
	      (setq att-cons-rid next))))))
    (delete-record opening att-rid)
    (push attribute-handle (database-deleted-attributes database))
    (nullify-entity-handle attribute-handle))
  t)

;;; Making and deleting indexes.
(defun make-index (list-of-attribute-handles &key unique-p case-sensitive)
  (restart-testing-check)
  (when (null list-of-attribute-handles)
    (model-error "An index must be on at least one attribute"))
  (check-user-attribute-handle (first list-of-attribute-handles))
  (when (typep unique-p 'attribute-handle)
    (model-error "The UNIQUE-P argument was an attribute handle; probably a syntax error"))
  (let* ((first-attribute-handle (first list-of-attribute-handles))
	 (n-attributes (length list-of-attribute-handles))
	 (relation-handle (attribute-handle-relation first-attribute-handle))
	 (database (relation-handle-database relation-handle)))
    (prepare-database database)
    (do ((att-handle-tail list-of-attribute-handles (cdr att-handle-tail)))
	((null att-handle-tail))	 
      (let ((att-handle (car att-handle-tail)))
	(check-attribute-handle att-handle)
	(unless (eq relation-handle (attribute-handle-relation att-handle))
	  (model-error "The attribute ~S is not from the same relation as the attribute ~S"
		 att-handle first-attribute-handle))
	(unless (indexable-p (attribute-handle-type att-handle))
	  (model-error "An index cannot be created on attributes of type ~S"
		       (attribute-handle-type att-handle)))
	(when (member att-handle (cdr att-handle-tail))
	  (model-error "The attribute ~S was specified twice" att-handle))))
    (dolist (index (relation-handle-list-of-indexes relation-handle))
      (when (and (equal list-of-attribute-handles (index-handle-list-of-attributes index))
		 (eq case-sensitive (index-handle-case-sensitive index)))
	(error 'index-already-exists
	       :relation relation-handle
	       :attribute-handles list-of-attribute-handles
	       :case-sensitive case-sensitive)))
    (note-schema-modified database)
    (let* ((opening (database-opening database))
	   (the-index-domain (find-domain-handle-given-name "%%index" database))
	   (idx-rid (make-record opening (+ (record-size index) n-attributes)))
	   (idx-iid (make-btree-index opening))
	   (index-handle
	     (make-instance 'index-handle
			    :rid idx-rid
			    :domain the-index-domain
			    :relation relation-handle
			    :unique (not (null unique-p))
			    :case-sensitive case-sensitive
			    :list-of-attributes (copy-list list-of-attribute-handles)
			    :index-identifier idx-iid
			    :index-depth 1)))
      ;; Initialize the contents of the index record.
      (with-record (idx opening idx-rid :write)
	(set-new-entity-uid idx index-handle)
	(setf (index-word-of-flags idx) 0)
	(let* ((bid (domain-handle-bset-iid the-index-domain))
	       (new-bid (insert-bset-key opening bid idx-rid)))
	  (unless (= bid new-bid)
	    (with-record (id opening (handle-rid the-index-domain) :write)
	      (setf (domain-bset-iid id) new-bid))
	    (setf (domain-handle-bset-iid the-index-domain) new-bid)))
	(setf (entity-domain idx) (handle-rid the-index-domain))
	(setf (local-entity-version idx) 0)
	(setf (local-entity-tuples-present idx) 1)
	(with-record (rel opening (handle-rid relation-handle) :write)
	  (let ((air-rid (relation-list-of-indexes rel)))
	    (setf (index-next-index-in-relation idx) air-rid)
	    (setf (relation-list-of-indexes rel) idx-rid)))
	(setf (index-relation idx) (handle-rid relation-handle))
	(setf (index-index-identifier idx) idx-iid)
	(setf (index-unique idx) (if unique-p 1 0))
	(setf (index-case-sensitive idx) (if case-sensitive 1 0))
	(loop for att in list-of-attribute-handles
	      for offset from (record-size index) do
	  (setf (read-record-word idx offset) (handle-rid att)))
	(setf (index-index-depth idx) 1)
	(setf (index-mbz1 idx) 0))
      ;; Sort the list of indexes, set attribute-handle-indexed, update schema.
      ;; Maybe this should do an insert into the list instead of a sort every time.
      (setf (relation-handle-list-of-indexes relation-handle)
	    (sort-list-of-indexes (cons index-handle
					(relation-handle-list-of-indexes relation-handle))))
      (when (and (null (cdr list-of-attribute-handles)))
	(setf (attribute-handle-indexed (car list-of-attribute-handles)) t))
      (loop for i from 0
	    for attribute-handle in list-of-attribute-handles do
	(make-system-tuple database "%%index-attribute"
			   "of" index-handle "is" attribute-handle "order" i))
      (setf (gethash (list idx-rid database) (new-entity-handles)) index-handle)
      ;; If there are any existing tuples, put them into the index.
      (unwind-protect-case ()
	  (fill-new-index index-handle relation-handle database opening)
	(:abort
	  ;; If there was a uniqueness-violation, the index cannot be made.
	  (delete-index-internal index-handle)))))
  t)

(defun fill-new-index (index-handle relation-handle database opening)
  (let ((idx-iid (index-handle-index-identifier index-handle))
	(idx-depth (index-handle-index-depth index-handle))
	(soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (map-over-tuples
      relation-handle
      #'(lambda (addressor rid version)
	  (condition-bind ((statice-index::too-many-values-for-insert
			     #'(lambda (cond)
				 (declare (ignore cond))
				 (error 'uniqueness-violation
					:relation-handle relation-handle
					:index-handle index-handle
					:verb "index"))))
	    (sys:with-data-stack
	      (multiple-value-bind (key any-null-p)
		  (make-key-from-record
		    index-handle addressor version soo-att
		    (when soo-att
		      (find-entity-handle-given-rid rid database))
		    database)
		(let ((new-idx-iid
			(insert-index-value opening
					    idx-iid
					    key
					    rid
					    idx-depth
					    (and (index-handle-unique index-handle)
						 (not any-null-p)))))
		  (unless (= idx-iid new-idx-iid)
		    (note-schema-modified database)
		    (setq idx-depth (compute-index-depth opening new-idx-iid))
		    (with-record (idx opening (handle-rid index-handle) :write)
		      (setf (index-index-identifier idx) new-idx-iid
			    (index-index-depth idx) idx-depth))
		    (setf (index-handle-index-identifier index-handle) new-idx-iid
			  (index-handle-index-depth index-handle) idx-depth
			  idx-iid new-idx-iid))))))))))

(defun delete-index (list-of-attribute-handles &key case-sensitive)
  (restart-testing-check)
  (when (null list-of-attribute-handles)
    (model-error "An index must be on at least one attribute"))
  (dolist (att-handle list-of-attribute-handles)
    (check-user-attribute-handle att-handle))
  (let* ((relation-handle (attribute-handle-relation (first list-of-attribute-handles)))
	 (database (relation-handle-database relation-handle)))
    (prepare-database database)
    (or (dolist (index-handle (relation-handle-list-of-indexes relation-handle))
	  (when (and (equal (index-handle-list-of-attributes index-handle)
			    list-of-attribute-handles)
		     (eq case-sensitive (index-handle-case-sensitive index-handle)))
	    (note-schema-modified database)
	    (delete-index-internal index-handle)
	    (return t)))
	(error 'index-not-found
	       :relation relation-handle
	       :attribute-handles list-of-attribute-handles
	       :case-sensitive case-sensitive)))
  t)

(defun delete-index-internal (index-handle)
  (let* ((relation-handle (index-handle-relation index-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (idx-rid (handle-rid index-handle))
	 (attribute-handles (index-handle-list-of-attributes index-handle)))
    ;; Remove it from the relation-handle's list.
    (setf (relation-handle-list-of-indexes relation-handle)
	  (delete index-handle (relation-handle-list-of-indexes relation-handle)))
    ;; Delete the underlying index itself.
    (delete-btree-index opening (index-handle-index-identifier index-handle))
    ;; Remove it from the relation's list in the database.
    (with-record (rel opening (handle-rid relation-handle) :read)
      (let ((prev-rid 0)
	    (this-rid (relation-list-of-indexes rel)))
	(loop until (zerop this-rid) do
	  (let ((next-rid (with-record (this opening this-rid :read)
			    (index-next-index-in-relation this))))
	    (when (= this-rid idx-rid)
	      (cond ((zerop prev-rid)
		     (upgrade-record-mode rel :write)
		     (setf (relation-list-of-indexes rel) next-rid))
		    (t
		     (with-record (prev opening prev-rid :write)
		       (setf (index-next-index-in-relation prev) next-rid))))
	      (return t))
	    (setq prev-rid this-rid)
	    (setf this-rid next-rid))
	      finally (model-bug "The index was not found."))))
    ;; Remove the index from the list of all indexes in the database.
    (let* ((id (find-domain-handle-given-name "%%index" database))
	   (bid (domain-handle-bset-iid id))
	   (new-bid (delete-bset-key opening bid idx-rid)))
      (unless (= new-bid bid)
	(with-record (id opening (handle-rid id) :write)
	  (setf (domain-bset-iid id) new-bid))
	(setf (domain-handle-bset-iid id) new-bid)))
    ;; Turn off attribute-handle-indexed, delete the record, delete from schema.
    (when (and (null (cdr attribute-handles)))
      (setf (attribute-handle-indexed (car attribute-handles)) nil))
    (delete-record opening idx-rid)
    (delete-system-tuples database "%%index-attribute" "of" index-handle)
    (nullify-entity-handle index-handle)))

;;; B-Sets
(defun make-relation-index (relation-handle)
  (restart-testing-check)
  (check-transaction)
  (check-relation-handle relation-handle)
  (when (relation-handle-bset-iid relation-handle)
    (model-error "Relation ~S already has a B-Set index" relation-handle))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (bid (make-bset-index opening)))
    (prepare-database database)
    (note-schema-modified database)
    ;; add existing records to the bset
    (map-over-tuple-records
      relation-handle
      #'(lambda (tuple-rid)
	  (setq bid (insert-bset-key opening bid tuple-rid))))
    (setf (relation-handle-bset-iid relation-handle) bid)
    (with-record (r opening (handle-rid relation-handle) :write)
      (setf (relation-bset-iid r) bid)))
  t)

(defun delete-relation-index (relation-handle)
  (restart-testing-check)
  (check-relation-handle relation-handle)
  (unless (relation-handle-bset-iid relation-handle)
    (model-error "Relation ~S does not have a B-Set index" relation-handle))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database)))
    (prepare-database database)
    (note-schema-modified database)
    (delete-bset-index opening (relation-handle-bset-iid relation-handle))
    (setf (relation-handle-bset-iid relation-handle) nil)
    (with-record (r opening (handle-rid relation-handle) :write)
      (setf (relation-bset-iid r) 0)))
  nil)

(defun make-domain-index (domain-handle &key (do-descendents-too nil))
  (restart-testing-check)
  (check-transaction)
  (check-domain-handle domain-handle)
  (let* ((database (domain-handle-database domain-handle))
	 (opening (database-opening database)))
    (prepare-database database)
    (note-schema-modified database)
    (if do-descendents-too
	(do-children (d domain-handle database)
	  (make-domain-index-internal d opening))
	(make-domain-index-internal domain-handle opening)))
  t)

(defun make-domain-index-internal (domain-handle opening)
  (let ((bid (make-bset-index opening)))
    (map-over-entity-records domain-handle
			     #'(lambda (ent-rid)
				 (setq bid (insert-bset-key opening bid ent-rid))))
    (setf (domain-handle-bset-iid domain-handle) bid)
    (with-record (d opening (handle-rid domain-handle) :write)
      (setf (domain-bset-iid d) bid))))

(defun delete-domain-index (domain-handle &key (do-descendents-too nil))
  (check-domain-handle domain-handle)
  (unless (domain-handle-bset-iid domain-handle)
    (model-error "Domain ~S does not have a B-Set index" domain-handle))
  (let* ((database (domain-handle-database domain-handle))
	 (opening (database-opening database)))
    (prepare-database database)
    (if do-descendents-too
	(do-children (d domain-handle database)
	  (delete-domain-index-internal d opening))
	(delete-domain-index-internal domain-handle opening)))
  nil)

(defun delete-domain-index-internal (domain-handle opening)
  (delete-bset-index opening (domain-handle-bset-iid domain-handle))
  (setf (domain-handle-bset-iid domain-handle) nil)
  (with-record (dom opening (handle-rid domain-handle) :write)
	       (setf (domain-bset-iid dom) 0)))

(defun find-available-area (&key (database *current-database*))
  (declare (values first-unused highest-used))
  (check-type database database)
  (prepare-database database)
  (let ((max-used 0))
    (sys:with-stack-array (areas-used statice-storage::*max-area-number*
				      :element-type 'boolean :initial-element nil)
      (do-domains (domain-handle database)
	(let ((area-number (domain-handle-area domain-handle)))
	  (maxf max-used area-number)
	  (setf (aref areas-used (- area-number 1)) t)))
      (do-relations (relation-handle database)
	(let ((area-number (relation-handle-area relation-handle)))
	  (maxf max-used area-number)
	  (setf (aref areas-used (- area-number 1)) t)))
      (dotimes (i statice-storage::*max-area-number*)
	(unless (aref areas-used i)
	  (return-from find-available-area (values (1+ i) max-used)))))))

(defun home-database-of (entity-handle)
  (check-type entity-handle entity-handle)
  (when (eq (handle-rid entity-handle) :deleted)
    (error 'entity-handle-deleted :entity-handle entity-handle))
  (typecase entity-handle
    (known-entity-handle (domain-handle-database (known-entity-handle-domain entity-handle)))
    (unknown-entity-handle :unknown)))

(defun entity-type-of (entity-handle)
  (declare (values entity-type-of system-relation-p))
  (check-type entity-handle entity-handle)
  (when (eq (handle-rid entity-handle) :deleted)
    (error 'entity-handle-deleted :entity-handle entity-handle))
  (entity-type-of-internal entity-handle))

;;; This internal version is also used internally, by
;;; check-entity-handle, to determine whether the entity is a schema
;;; entity or not.
(defgeneric entity-type-of-internal (entity-handle))

(defmethod entity-type-of-internal ((handle relation-handle))
  (with-slots (system-relation-p) handle
    (values :relation system-relation-p)))

(defmethod entity-type-of-internal ((handle attribute-handle))
  (with-slots (relation) handle
    (values :attribute (relation-handle-system-relation-p relation))))

(defmethod entity-type-of-internal ((handle index-handle))
  :index)

(defmethod entity-type-of-internal ((handle domain-handle))
  (with-slots (system-domain-p) handle
    (values :domain system-domain-p)))

(defmethod entity-type-of-internal ((handle unknown-entity-handle))
  :unknown)

(defmethod entity-type-of-internal ((handle known-entity-handle)) :entity)

(defun find-greatest (relation-handle attribute-handle)
  (find-greatest-or-least relation-handle attribute-handle t))

(defun find-least (relation-handle attribute-handle)
  (find-greatest-or-least relation-handle attribute-handle nil))

(defun find-greatest-or-least (relation-handle attribute-handle greatest-p)
  (restart-testing-check)
  (check-relation-handle relation-handle)
  (check-attribute-handle attribute-handle)
  (unless (eq (attribute-handle-relation attribute-handle) relation-handle)
    (model-error
      "The attribute ~S is not from the relation ~S" attribute-handle relation-handle))
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (type (attribute-handle-type attribute-handle))
	 (desc (attribute-handle-descriptor attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (prepare-database database)
    (unless (comparable-p type)
      (model-error "Values of type ~S cannot be compared" type))
    (let ((index-handle (dolist (i (relation-handle-list-of-indexes relation-handle))
			  (let ((la (index-handle-list-of-attributes i)))
			    (when (and (eq (first la) attribute-handle)
				       (null (rest la)))
			      (return i))))))
      (cond (index-handle
	     ;; There's an index on this attribute, so the index can immediately
	     ;; provide us with the answer.
	     (sys:with-data-stack
	       (let ((answer (funcall (if greatest-p
					  #'lookup-greatest-index-value
					  #'lookup-least-index-value)
				      opening
				      (index-handle-index-identifier index-handle))))
		 (loop for rid across answer
		       collect
			 (find-tuple-handle-given-rid rid relation-handle)))))
	    (t
	     ;; There's no index; we'll have to search for it/them.
	     (sys:with-stack-array (m-rids 5 :fill-pointer 0)
	       (let ((m-value nil)		; Best candiate value so far.
		     (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
		 (map-over-tuples
		   relation-handle
		   #'(lambda (addressor rid version)
		       (let ((dom-rid (when soo-att
					(find-domain-handle-given-entity-rid rid database))))
			 (cond ((or (null att-version) (< version
							  (if soo-att
							      (search-table-for-domain
								att-version
								dom-rid)
							      att-version)))
				;; The value is a null value, which is never the answer.
				nil)
			       ((null m-value)
				;; We don't have any candidate yet, so this value
				;; will be our initial candidate.
				(setq m-value (read-value
						type
						addressor
						(if soo-att
						    (search-table-for-domain
						      desc
						      dom-rid)
						    desc)
						database))
				(vector-push rid m-rids))
			       ((value-equal
				  type
				  addressor
				  (if soo-att
				      (search-table-for-domain
					desc
					dom-rid)
				      desc)
				  m-value
				  database)
				;; This value is the same as the best candidate so
				;; far, so add it to the list of winners.
				(vector-push-extend rid m-rids 10))
			       (t
				;; Compare this value with the best candidate so far.
				(let ((vl (eq (value-compare
						type
						addressor
						(if soo-att
						    (search-table-for-domain
						      desc
						      dom-rid)
						    desc)
						m-value
						database)
					      :lessp)))
				  (cond ((eq vl *null-value*)
					 ;; Record contains null values, ignore it.
					 nil)
					((if (not greatest-p) vl (not vl))
					 ;; This beats the previous candidate.
					 (setq m-value
					       (read-value
						 type
						 addressor
						 (if soo-att
						     (search-table-for-domain
						       desc
						       dom-rid)
						     desc)
						 database))
					 (setf (fill-pointer m-rids) 0)
					 (vector-push rid m-rids)))))))))
		 (loop for rid across m-rids
		       collect (find-tuple-handle-given-rid
				 rid relation-handle)))))))))

;;; Transactions.

;;; This is called on a database after the schema is initialized or
;;; encached.  It is always called from within a transaction, and the
;;; argument is always the current database when this is called.
(scl:defgeneric after-reading-schema (database))

;;; The default method doesn't do anything.
(scl:defmethod (after-reading-schema database) () nil)

;;; This function is called whenever a model level entrypoint touches a
;;; database and can't tell whether or not the database has been touched
;;; before by this transaction.  If this is not the first time, don't do
;;; anything.  This function is called inside a transaction.
(defsubst prepare-database (database)
  (compiler:%error-unless (assoc database (db-info-list))
    ;; This is the first time this transaction has touched this database.
    (prepare-database-internal database)))

(defun prepare-database-internal (database)
  (let ((opening (database-opening database)))
    (when (listp opening)
      (cl:error 'database-terminated :function (first opening) :time (second opening)))
    ;; See whether the schema cache is up to date.
    (with-record (seg opening (database-rid-of-header database) :read)
      ;; Check to see if some other process has re-created this
      ;; database, that is, opened with :create-p t and built a
      ;; whole new database, since the last time we encached
      ;; the schema.
      (with-record (dom-dom opening (database-header-domain-domain seg) :read)
	(unless (and (= (database-uid-1 database) (entity-uid-word-1 dom-dom))
		     (= (database-uid-2 database) (entity-uid-word-2 dom-dom))
		     (= (database-uid-3 database) (entity-uid-word-3 dom-dom)))
	  (cl:error 'database-deleted :pathname (database-opening database))))
      (cond ((and (= (database-schema-version-id-1 database)
		     (database-header-schema-version-id-1 seg))
		  (= (database-schema-version-id-2 database)
		     (database-header-schema-version-id-2 seg))
		  (= (database-schema-version-id-3 database)
		     (database-header-schema-version-id-3 seg)))
	     ;; If there were any deleted domains etc. left over
	     ;; from previous successful transactions, free them
	     ;; so they can be GC'ed.
	     (setf (database-deleted-domains database) nil)
	     (setf (database-deleted-relations database) nil)
	     (setf (database-deleted-attributes database) nil))
	    (t
	     ;; The old scheme cache is obsolete.
	     (recache-schema database)))))
  (push (make-db-info :database database :new-schema-version nil) (db-info-list))
  ;; If the database is still in version 10, upgrade it.
  (when (= (database-model-level-version database) 10)
    (upgrade-to-version-11 database))
  ;; Same for 11 to 12.
  (when (= (database-model-level-version database) 11)
    (upgrade-to-version-12 database))
  ;; Same for 12 to 13.
  (when (= (database-model-level-version database) 12)
    (upgrade-to-version-13 database))
  ;; Invoke the per-flavor hook.
  (after-reading-schema database))

;;; This function is called by every model level entrypoint that modifies
;;; the schema of the database, such as make-domain, delete-domain,
;;; make-relation, delete-relation, etc.
(defun note-schema-modified (database)
  (let ((db-info (assoc database (db-info-list))))
    (unless db-info
      (model-bug "note-schema-modified did not find the database on db-info-list"))
    (unless (db-info-new-schema-version db-info)
      ;; This is the first time that this transaction has modified the
      ;; schema of this database.  Create a new schema version id and
      ;; schema version number.  Store them into both the database and the
      ;; schema cache.
      (with-record (seg (database-opening database) (database-rid-of-header database)
			:write)
	(multiple-value-bind (uid1 uid2 uid3)
	    (uid:unique-id)
	  (setf (database-header-schema-version-id-1 seg) uid1)
	  (setf (database-header-schema-version-id-2 seg) uid2)
	  (setf (database-header-schema-version-id-3 seg) uid3)
	  (setf (database-schema-version-id-1 database) uid1)
	  (setf (database-schema-version-id-2 database) uid2)
	  (setf (database-schema-version-id-3 database) uid3)
	  (incf (database-header-schema-version-number seg))))
      (setf (db-info-new-schema-version db-info) t))))

(defun generate-transaction-id ()
  (loop for old = *transaction-id-generator*
	for new = (1+ old) do
    (when (scl:store-conditional (scl:locf *transaction-id-generator*) old new)
      (return new))))

(defun with-transaction-1 (transaction-body
			   &key (automatic-retry 'dbfs:restartable-transaction-abort))
  (let ((nested-p *transaction-info*))
    (let-if (not nested-p)
	    ((*transaction-info* (allocate-transaction-info)))
      (unwind-protect
	  (dbfs:with-transaction (:finish-form (finish-transaction)
				  :automatic-retry automatic-retry)
	    (unless nested-p
	      (reset-transaction-info *transaction-info*))
	    (multiple-value-prog1
	      (with-transaction-internal ()
		(funcall transaction-body))))
	(unless nested-p
	  (deallocate-transaction-info *transaction-info*))))))

(defun allocate-transaction-info ()
  (let ((info (with-transaction-info-pool-lock
		(let* ((pool *transaction-info-pool*)
		       (fillp (fill-pointer pool)))
		  (when (plusp fillp)
		    (setf (fill-pointer pool) (1- fillp))
		    (aref pool (1- fillp)))))))
    (cond ((null info)
	   (make-transaction-info :transaction-id (generate-transaction-id)))
	  (t
	   ;; This need not call reset-transaction-info, because
	   ;; with-transaction-1 is going to call it inside the DBFS
	   ;; transaction.
	   (setf (entry-number-to-abort-on info) 0)
	   (setf (current-entry-number info) 0)
	   info))))

(defun reset-transaction-info (info)
  (fast-clrhash (tuple-handles info))
  (fast-clrhash (checked-entity-handles info))
  (fast-clrhash (new-entity-handles info))
  (fast-clrhash (deleted-entity-handles info))
  (setf (db-info-list info) nil)
  (setf (transaction-id info) (generate-transaction-id))
  info)

(defun finish-transaction ()
  (restart-testing-check)
  ;; Remove (deleted-entity-handles) entries from
  ;; database-known-entity-handles.  Do this first, because maybe
  ;; delete-entity freed up an rid, and then a new entity was created
  ;; later in the transaction with the same rid.
  (fast-maphash #'(lambda (key entity-handle)
		    (setf (handle-rid entity-handle) :deleted)
		    (let ((database (second key)))
		      (with-database-known-entity-handles-lock (database)	;43 usec
			(remhash (first key) (database-known-entity-handles database)))))
		(deleted-entity-handles))
  ;; Move (new-entity-handles) entries to database-known-entity-handles.
  (fast-maphash #'(lambda (key entity-handle)
		    (let ((database (second key)))
		      (with-database-known-entity-handles-lock (database)	;43 usec
			(setf (gethash (first key) (database-known-entity-handles database))
			      entity-handle))))
		(new-entity-handles)))

(defun deallocate-transaction-info (info)
  (when info
    (with-transaction-info-pool-lock
      (vector-push-extend info *transaction-info-pool*))))

(defun open-database (pathname &key create-p flavor (if-exists :error))
  (when (stringp pathname) (setq pathname (fs:merge-pathnames pathname)))
  (check-type pathname dbfs:basic-portal "a DBFS portal")
  (let ((*restart-testing* nil))
    (if create-p
	(open-new-database pathname flavor if-exists)
	(open-existing-database pathname flavor))))

;;; The structure of this function is made complicated by the restriction
;;; against touching a database while holding the open-database lock.
(defun open-existing-database (pathname flavor)
  (let ((file-uid
	  (dbfs:with-transaction ()
	    (error-restart (error "Retry opening existing database with pathname ~A" pathname)
	      (dbfs::validate-portal pathname))
	    ;; The file-unique-id of a portal can change, if some other
	    ;; process deletes and re-creates the file.  To prevent a
	    ;; timing window here, we must lock a page of the file
	    ;; before getting the file-unique-id.
	    (unless (dbfs:read-page pathname 0 :if-does-not-exist nil)
	      (model-error "The database ~S does not exist" pathname))
	    (dbfs::file-unique-id pathname))))
    (let ((database (with-open-database-lock
		      (fast-gethash file-uid *databases*))))
      (cond ((null database)
	     ;; The file has never been opened before in this Lisp world.
	     ;; Create a database object and put it into the table.
	     (setq database (make-instance (or flavor 'database) :opening pathname))
	     (with-transaction ()
	       (init-file pathname nil pathname)
	       (encache-schema database))
	     (let ((uid-key (list (database-uid-1 database)
				  (database-uid-2 database)
				  (database-uid-3 database))))
	       (with-open-database-lock
		 (let ((other-database (fast-gethash file-uid *databases*)))
		   (cond (other-database
			  ;; While we were doing all that, someone else was
			  ;; doing the same thing, and beat us to it.
			  (setq database other-database))
			 (t
			  ;; OK, no concurrency problems.  Next, check for
			  ;; other databases with the same UID.
			  (let ((db (gethash uid-key *databases-by-uid*)))
			    (when db
			      (let ((old-pathname (database-opening db)))
				(when (dbfs:with-transaction () (dbfs:file-extant-p old-pathname))
				  (cerror "Terminate database ~S"
					  "The database ~S exists and has the same unique ID as~@
                                      the database in file ~S"
					  db pathname))
			   ;;; database might have nil as dbfs:file-id, but still be in
			   ;;; *databases*
				(let ((uid (block nil (maphash #'(lambda (key item)
								   (when (eq item db)
								     (return-from nil key)))
							       *databases*))))
				  (terminate-database-internal uid)))))
			  ;; No problems.  Install our new database.
			  (setf (gethash uid-key *databases-by-uid*) database)
			  (setf (gethash file-uid *databases*) database)))))))
	    ((not (eql pathname (database-opening database)))
	     ;; UIDs match but the file was renamed
	     (with-open-database-lock
	       ;; make sure no other process beat us to it
	       (when (not (eql pathname (database-opening database)))
		 (setf (database-opening database) pathname)))))
      (when (and flavor (not (typep database flavor)))
	;; Minor kludge: The database has already been opened,
	;; but not using the specified flavor.  This can happen
	;; if it's created by model level and then used with
	;; function level, for example if it was created by the
	;; loader and then used.  Fix up the flavor.
	(flavor:change-instance-flavor database flavor))
      database)))

;;; The structure of this function is made complicated by the restriction
;;; against touching a database while holding the open-database lock.
;;; if-exists can be :create, :error, or nil.
(defun open-new-database (pathname flavor if-exists)
  (let (database)
    (multiple-value-bind (old-file-uid create-file-value new-file-uid)
	(with-transaction ()
	  ;; these have double colons since the defs are loaded after this file
	  (error-restart (error "Retry opening new database with pathname ~A" pathname)
	    (dbfs::validate-portal pathname))
	  (values (error-restart (error "Retry opening new database with pathname ~A" pathname)
		    (dbfs::file-extant-p pathname))
		  (dbfs:create-file pathname :if-exists if-exists)
		  (dbfs::file-unique-id pathname)))
      (unless create-file-value
	;; The file does not exist and the caller wants nil in that case.
	(return-from open-new-database nil))
      (with-open-database-lock
	(let ((old-database (fast-gethash old-file-uid *databases*)))
	  (when old-database
	    ;; This file has been opened before and used as a database.
	    ;; We are "re-creating", i.e.  overwriting, it.  Get
	    ;; rid of the database instance and all entity handles.
	    (remhash old-file-uid *databases*))))
      (setq database (scl:make-instance (or flavor 'database) :opening pathname))
      (with-transaction ()
	;; Storage level initialization.
	(init-file pathname t pathname)
	;; Build the system schema.
	(initialize-schema database))
      (with-open-database-lock
	;; Create a database object and put it into the table, now that the
	;; database-uid has been initialized.
	(when (gethash new-file-uid *databases*)
	  ;; I'm not sure what to do here.  I don't think this will ever really happen.
	  (error "Statice problem: Another process created this database concurrently"))
	(setf (gethash new-file-uid *databases*) database)
	(setf (gethash (list (database-uid-1 database)
			     (database-uid-2 database)
			     (database-uid-3 database))
		       *databases-by-uid*)
	      database))
      database)))

(defmacro with-current-database ((database) &body body)
  `(let ((*current-database* ,database))
     . ,body))

(defmacro with-database ((variable pathname &key create-p flavor (if-exists :error))
			 &body body)
  `(let ((,variable (open-database ,pathname
				   :create-p ,create-p
				   :flavor ,flavor
				   :if-exists ,if-exists)))
     (with-current-database (,variable)
       . ,body)))

;;; Return t if actually terminated the database.  Return nil if the
;;; database wasn't activated in the first place.
(defun terminate-database (cl:pathname)
  (when (stringp cl:pathname) (setq cl:pathname (fs:merge-pathnames cl:pathname)))
  (let ((file-uid (dbfs::file-unique-id cl:pathname)))
    (terminate-database-internal file-uid)))

(defun terminate-database-internal (file-uid)
  (with-open-database-lock
    (let ((database (fast-gethash file-uid *databases*)))
      (when database
	(remhash file-uid *databases*)
	(remhash (list (database-uid-1 database)
		       (database-uid-2 database)
		       (database-uid-3 database))
		 *databases-by-uid*)
	;; Alter the database instance so that if anyone tries to use
	;; it, he'll get an error.
	(setf (database-opening database)
	      (list 'terminate-database (time:get-universal-time)))
	;; clear out entity handles so that maybe they can be gc'd
	(with-database-known-entity-handles-lock (database)	; for yucks
	  (clrhash (database-known-entity-handles database)))
	t))))

(defun reset-statice ()
  (let ((utime (time:get-universal-time)))
    (maphash #'(cl:lambda (key database)
		 (declare (cl:ignore key))
		 (setf (database-opening database) (list 'reset-statice utime)))
	     *databases*))
  (clrhash *databases*)
  (clrhash *databases-by-uid*)
  nil)
