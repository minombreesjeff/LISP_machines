;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice; Base: 10; Lowercase: Yes -*-
;;;> 
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Statice function level: get-real-schema and update-schema



;;;;Command table for use by CP commands related to Statice
(cp::define-command-subset statice::*statice-command-table*
			  "Statice" "File")

 
;;; Build the real- structures from an actual database.
(defun get-real-schema (pathname)
  (when (stringp pathname) (setq pathname (fs:merge-pathnames pathname)))
  (statice-model:with-database (database pathname :flavor 'functional-database)
    (with-transaction ()
      (let* ((area-vector (get-area-vector))
	     (schema-name (real-schema-name-internal))
	     (package (symbol-package schema-name)))
	(multiple-value-bind (types indexed-attributes)
	    (get-real-types package area-vector)
	  (get-real-attributes types indexed-attributes package area-vector)
	  (flavor:make-instance 'real-schema
	    :name schema-name
	    :types types
	    :area-vector area-vector
	    :pathname pathname
	    :version (database-schema-version)))))))

(defun get-real-schema-name (pathname)
  (when (stringp pathname) (setq pathname (fs:merge-pathnames pathname)))
  (statice-model:with-database (database pathname :flavor 'functional-database)
    (with-transaction ()
      (real-schema-name-internal))))

;;; Returns the real schema name, a symbol.  This is an internal function,
;;; and the caller must provide a current open database and a transaction.
(defun real-schema-name-internal ()
  (let* ((sdinfo (get-relation "%%$sdinfo"))
	 (name-att (get-attribute sdinfo "name")))
    (do-attribute (value not-null-p name-att)
      (return value))))

;;; types is a list of real-entity-type instances for every type in the
;;; database.  indexed-attributes is a alist of attribute-handles for
;;; every attribute for which there is a B-tree index on just that
;;; attribute, which means an :inverse-index.  Each element of
;;; indexed-attributes is a 3-list of attribute-handle, unique-p,
;;; case-sensitive-p.  The "functions" slots of the entity-type entities
;;; are nil at this point; they are filled in later.
(defun get-real-types (package area-vector)
  (declare (values types indexed-attributes))
  (let* ((%%domain (get-relation "%%domain"))
	 (domain-is (get-attribute %%domain "is"))
	 (domain-name (get-attribute %%domain "name"))
	 (domain-domain-indexed (get-attribute %%domain "domain-indexed"))
	 (domain-area (get-attribute %%domain "area"))
	 (types nil)
	 (indexed-attributes nil))
    (do-relation (d %%domain)
      (let ((name-string (get-value d domain-name)))
	(cond ((not (string-equal name-string "%%" :end1 2))
	       ;; This domain represents a function-level type.
	       (let ((name (intern name-string package)))
		 (push (flavor:make-instance 'real-entity-type
			 :domain-handle (get-value d domain-is)
			 :relation-handle (get-relation (string name))
			 :name name
			 :parent-names nil
			 :functions nil
			 :area-name (aref area-vector (get-value d domain-area))
			 :set-exists (get-value d domain-domain-indexed)
			 :multiple-indexes nil)
		       types))))))
    ;;; Fill in the parent-names slot.
    (flet ((get-type (domain-handle)
	     (dolist (type types)
	       (when (eq (type-domain-handle type) domain-handle)
		 (return type)))))
      (let* ((%%subdomain (get-relation "%%subdomain"))
	     (subdomain-of (get-attribute %%subdomain "of"))
	     (subdomain-is (get-attribute %%subdomain "is")))
	(do-relation (s %%subdomain)
	  (push (type-name (get-type (get-value s subdomain-of)))
		(type-parent-names (get-type (get-value s subdomain-is)))))))
    ;;; Fill in the multiple-indexes slot.
    (let* ((%%index (get-relation "%%index"))
	   (index-on (get-attribute %%index "on"))
	   (index-is (get-attribute %%index "is"))
	   (index-unique (get-attribute %%index "unique"))
	   (index-case-sensitive (get-attribute %%index "case-sensitive"))
	   (%%index-attribute (get-relation "%%index-attribute"))
	   (index-attribute-of (get-attribute %%index-attribute "of"))
	   (index-attribute-is (get-attribute %%index-attribute "is"))
	   (index-attribute-order (get-attribute %%index-attribute "order")))
      (do-relation (i %%index)
	(let ((attribute-handles nil))
	  (do-relation (ia %%index-attribute
			   (:where index-attribute-of (get-value i index-is)))
	    (push (cons (get-value ia index-attribute-is)
			(get-value ia index-attribute-order))
		  attribute-handles))
	  (setq attribute-handles (mapcar #'car (sort attribute-handles #'< :key #'cdr)))
	  (cond ((= (length attribute-handles) 1)
		 (push (list (first attribute-handles)
			     (get-value i index-unique)
			     (get-value i index-case-sensitive))
		       indexed-attributes))
		(t
		 ;; It's a multiple-index.
		 (let ((type (dolist (type types)
			       (when (eq (type-relation-handle type) (get-value i index-on))
				 (return type)))))
		   (push (flavor:make-instance 'real-multiple-index
			   :type type
			   :slot-names
			   (mapcar
			     #'(lambda (a) (intern (attribute-handle-name a) package))
			     attribute-handles)
			   :unique (get-value i index-unique)
			   :case-sensitive (get-value i index-case-sensitive)
			   :attribute-handles attribute-handles)
			 (type-multiple-indexes type))))))))
     (values types indexed-attributes)))

;;; Store the real-attribute instances on the type-function lists.



(defun get-real-attributes (types indexed-attributes package area-vector)
  (let* ((%%relation (get-relation "%%relation"))
	 (relation-is (get-attribute %%relation "is"))
	 (relation-name (get-attribute %%relation "name"))
	 (relation-relation-indexed (get-attribute %%relation "relation-indexed"))
	 (relation-area (get-attribute %%relation "area"))
	 (%%attribute (get-relation "%%attribute"))
	 (attribute-of (get-attribute %%attribute "of"))
	 (attribute-is (get-attribute %%attribute "is"))
	 (attribute-type (get-attribute %%attribute "type"))
	 (attribute-name (get-attribute %%attribute "name"))
	 (attribute-unique (get-attribute %%attribute "unique"))
	 (attribute-group-indexed (get-attribute %%attribute "group-indexed"))
	 (attribute-group-index-average-size
	   (get-attribute %%attribute "group-index-average-size"))
	 (attribute-no-nulls (get-attribute %%attribute "no-nulls")))
    (do-relation (r %%relation)
      (flet ((get-att-tuple (attribute-handle)
	       (do-relation (a %%attribute (:where attribute-is attribute-handle))
		 (return a)))
	     (name-of-type (raw-type)
	       (if (typep raw-type 'domain-handle)
		   (dolist (type types)
		     (when (eq (type-domain-handle type) raw-type)
		       (return (type-name type))))
		   raw-type)))
	(let ((rel (get-value r relation-is))
	      (rel-name-string (get-value r relation-name)))
	  (cond ((string-equal rel-name-string "%$" :end1 2)
		 ;; This relation implements a binary function.
		 (let* ((of-att (get-attribute rel "OF"))
			(is-att (get-attribute rel "IS"))
			(of-att-tuple (get-att-tuple of-att))
			(is-att-tuple (get-att-tuple is-att))
			(arg-domain (get-value of-att-tuple attribute-type))
			(type (dolist (type types)
				(when (eq (type-domain-handle type) arg-domain)
				  (return type))))
			(conc-name (type-conc-name (get (type-name type) 'entity-type)))
			(value-is-set (not (get-value of-att-tuple attribute-unique)))
			(of-att-gi (get-value of-att-tuple attribute-group-indexed))
			(is-att-gi (get-value is-att-tuple attribute-group-indexed))
			(is-att-idx (assoc is-att indexed-attributes)))
		   (push
		     (flavor:make-instance 'real-attribute
		       :slot-name (intern (substring
					    rel-name-string
					    (+ 2 (string-length conc-name)))
					  package)
		       :full-name (intern (substring rel-name-string 2) package)
		       :argument-type-name (type-name type)
		       :value-type-name (name-of-type (get-value is-att-tuple attribute-type))
		       :value-is-set value-is-set
		       :value-foreign nil	;not yet implemented.
		       :unique (get-value is-att-tuple attribute-unique)
		       :read-only nil		;we can't tell!
		       :implementation 'binary-relation
		       :area-name (aref area-vector (get-value r relation-area))
		       :set-exists (get-value r relation-relation-indexed)
		       :index-exists of-att-gi
		       :index-average-size
		       (when of-att-gi
			 (get-value of-att-tuple attribute-group-index-average-size))
		       :inverse-index-exists (or is-att-gi
						 (and is-att-idx (not (third is-att-idx))))
		       :inverse-index-exact-exists (and is-att-idx (third is-att-idx))
		       :inverse-index-average-size
		       (when is-att-gi
			 (get-value is-att-tuple attribute-group-index-average-size))
		       :no-nulls (and (not value-is-set)
				      (get-value is-att-tuple attribute-no-nulls))
		       :relation rel
		       :of-attribute of-att
		       :is-attribute is-att)
		     (type-functions type))))		     
		((not (string-equal rel-name-string "%%" :end1 2))
		 ;; This is the type relation of some type.
		 (let* ((rel-name (intern rel-name-string package))
			(rel-type (dolist (type types)
				    (when (eq (type-name type) rel-name)
				      (return type))))
			(soo-att (get-attribute rel "%$OF")))
		   (do-relation (a %%attribute
				   (:where attribute-of (get-value r relation-is)))
		     (let ((att (get-value a attribute-is)))
		       (unless (eq att soo-att)
			 (let ((att-name-string (get-value a attribute-name))
			       (att-raw-type (get-value a attribute-type)))
			   (cond ((string-equal att-name-string "%$" :end1 2)
				  ;; This is the other-relation implementation.  The function
				  ;; is unique-p, set-valued, not foreign, and entity typed.
				  (let* ((att-type
					   (dolist (type types)
					     (when (eq (type-domain-handle type) att-raw-type)
					       (return type))))
					 (conc-name (type-conc-name (get (type-name att-type)
									 'entity-type))))
				    (push
				      (flavor:make-instance 'real-attribute
					:slot-name
					(intern (substring
						  att-name-string
						  (+ 2 (string-length conc-name)))
						package)
					:full-name (intern (substring att-name-string 2)
							   package)
					:argument-type-name (type-name att-type)
					:value-type-name (type-name rel-type)
					:value-is-set t
					:value-foreign nil
					:unique t
					:read-only nil	;We can't know.
					:implementation 'other-relation
					:area-name (type-area-name rel-type)
					:set-exists nil	;+But it doesn't stop you from asking.
					:index-exists (get-value a attribute-group-indexed)
					:index-average-size
					(get-value a attribute-group-index-average-size)
					:inverse-index-exists nil
					:inverse-index-exact-exists nil
					:inverse-index-average-size nil
					:no-nulls nil
					:relation rel
					:of-attribute att
					:is-attribute soo-att)
				      (type-functions att-type))))
				 (t
				  ;; This is the type-relation implementation.  The 
				  ;; function is single-valued, same-area.
				  (let ((gi (get-value a attribute-group-indexed))
					(idx (assoc att indexed-attributes)))
				    (push
				      (flavor:make-instance 'real-attribute
					:slot-name (intern att-name-string package)
					:full-name (intern (string-append rel-name-string
									  "-"
									  att-name-string)
							   package)
					:argument-type-name rel-name
					:value-type-name (name-of-type att-raw-type)
					:value-is-set nil
					:value-foreign nil
					:unique (get-value a attribute-unique)
					:read-only nil	;We can't know.
					:implementation 'type-relation
					:area-name (type-area-name rel-type)
					:set-exists nil	;+But it doesn't stop you from asking.
					:index-exists nil
					:index-average-size nil
					:inverse-index-exists (or gi
								  (and idx (not (third idx))))
					:inverse-index-exact-exists (and idx (third idx))
					:inverse-index-average-size
					(when gi
					  (get-value a attribute-group-index-average-size))
					:no-nulls (get-value a attribute-no-nulls)
					:relation rel
					:of-attribute soo-att
					:is-attribute att)
				      (type-functions rel-type)))))))))))))))))

(defun get-area-vector ()
  (let* ((areas (get-relation "%%$areas"))
	 (name (get-attribute areas "name"))
	 (number (get-attribute areas "number"))
	 (length (1+ (get-value (car (find-greatest areas number)) number)))
	 (vector (make-array (+ 5 length) :fill-pointer length)))
    (do-relation (tuple areas)
      (setf (aref vector (get-value tuple number))
	    (get-value tuple name)))
    (setf (aref vector 0) '(nosuch))		;Don't ever use area zero.
    vector))

;;; Return a list that encodes the schema version of the current databases.
;;; Compare two such lists with EQUAL to see if the version is the same.
(defun database-schema-version ()
  (list (statice-model::database-schema-version-id-1 statice-model::*current-database*)
	(statice-model::database-schema-version-id-2 statice-model::*current-database*)
	(statice-model::database-schema-version-id-3 statice-model::*current-database*)))

(defstruct rt-info
  rt
  (children nil))

(scl:defgeneric report-update-effect (update-action stream)
  (:documentation
    "Print on the stream the effect of performing this update-action."))

(scl:defgeneric report-update-reasons (update-action stream &optional fresh-line)
  (:documentation
    "Print on the stream the reasons that this update-action is called for."))

(scl:defgeneric report-update-warnings (update-action stream)
  (:documentation
    "Print on the stream any alarming things about what this update-action would do."))

(scl:defgeneric perform-update-action (update-action database schema-table area-vector)
  (:documentation
    "Perform the update-action.  This function must be called from inside a transaction.
     The database being updated must be the current database as well as the argument."))

(scl::defflavor basic-update-action
	((reasons nil)) ()
  (:initable-instance-variables)
  (:required-methods report-update-effect perform-update-action))

(scl:defmethod (report-update-reasons basic-update-action) (stream &optional fresh-line)
  (let ((n-reasons (length reasons)))
    (cond ((= n-reasons 1)
	   (when fresh-line (scl:send stream :fresh-line))
	   (format stream "because ~A" (first reasons)))
	  ((> n-reasons 1)
	   (when fresh-line (scl:send stream :fresh-line))
	   (format stream "because:")
	   (dolist (reason reasons)
	     (format stream "~% -- ~A" reason))))))

(scl:defmethod (report-update-warnings basic-update-action) (stream)
  (declare (ignore stream)))

;;; Note: if the new entity type has any multiple indexes, they are not added
;;; by this action, but by a separate update-add-multiple-index action.
(scl:defflavor update-add-entity-type
	(template-entity-type)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-entity-type (template-entity-type reasons)))

(scl:defmethod (report-update-effect update-add-entity-type) (stream)
  (format stream "Add entity type ~A" (type-name template-entity-type)))

(scl:defmethod (perform-update-action update-add-entity-type)
	       (database schema-table area-vector)
  (let* ((entity-flavors (statice-model::database-entity-flavors database))
	 (type-name (type-name template-entity-type))
	 (area (intern-area area-vector (type-area-name template-entity-type)))
	 (domain (make-domain
		   (string type-name)
		   (loop for parent in (type-parent-names template-entity-type t)
			 as parent-desc = (get parent 'entity-type)
			 when parent-desc
			   collect (gethash (type-domain-tag parent-desc)
					    schema-table))
		   :area area
		   :domain-index-p (type-set-exists template-entity-type)))
	 (relation (make-relation (string type-name) :area area)))
    (setf (gethash (type-domain-tag template-entity-type) schema-table) domain)
    (setf (gethash domain entity-flavors) type-name)
    (setf (gethash (type-relation-tag template-entity-type) schema-table) relation)
    (setf (gethash (type-soo-att-tag template-entity-type) schema-table)
	  (make-attribute relation "%$OF" domain
			  :unique-p t :surrogate-p t))))

;;; This must be a distinct action from add-entity-type because it needs to be
;;; postponed until all new entity types are created, because of the
;;; other-relation implementation.
(scl:defflavor update-add-all-attributes
	(template-entity-type)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-all-attributes (template-entity-type reasons)))

(scl:defmethod (report-update-effect update-add-all-attributes) (stream)
  (format stream "Add attribute~P "
	  (loop with count = 0
		for f in (type-functions template-entity-type) do
	    (when (forward-function-p f)
	      (incf count))
	    finally (return count)))
  (print-attribute-names template-entity-type stream)
  (format stream " of entity type ~A: " (type-name template-entity-type)))

(defun print-attribute-names (entity-type stream)
  (scl:format-textual-list (nreverse (loop for f in (type-functions entity-type)
				       when (forward-function-p f)
					 collect (function-slot-name f)))
		       #'princ
		       :stream stream :finally " and "))

(scl:defmethod (perform-update-action update-add-all-attributes)
	   (database schema-table area-vector)
  (declare (ignore database))
  (dolist (function (type-functions template-entity-type))
    (make-function function schema-table area-vector))
  (make-multiple-indexes template-entity-type schema-table))

(scl:defflavor update-remove-entity-type
	(real-entity-type
	 rt-info-list)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-entity-type (real-entity-type rt-info-list reasons)))

(scl:defmethod (report-update-effect update-remove-entity-type) (stream)
  (format stream "Remove entity type ~A" (type-name real-entity-type))
  (when (type-functions real-entity-type)
    (format stream "~%   and its attribute~P: " (length (type-functions real-entity-type)))
    (print-attribute-names real-entity-type stream))
  (let ((descendants nil))
    (labels ((get-descendants (rt)
	       (dolist (child (rt-info-children
				(car (member rt rt-info-list :key #'rt-info-rt))))
		 (unless (member child descendants)
		   (push child descendants)
		   (get-descendants child)))))
      (get-descendants real-entity-type)
      (when descendants
	(format stream "~%   and its descendent~P: " (length descendants))
	(scl:format-textual-list (mapcar #'type-name descendants) #'princ
			     :stream stream :finally " and "))
      (loop with removed-types = (cons real-entity-type descendants)
	    with removed-attributes = nil
	    for rt-info in rt-info-list do
	(let ((rt (rt-info-rt rt-info)))
	  (unless (member rt removed-types)
	    (dolist (function (type-functions rt))
	      (when (forward-function-p function)
		(when (member (function-value-type-name function)
			      removed-types
			      :key #'type-name
			      :test #'type-name-equal)
		  (push (list rt function) removed-attributes))))))
	    finally
	      (when removed-attributes
		(format stream "~%   and attribute~P whose type has been removed: "
			(length removed-attributes))
		(scl:format-textual-list removed-attributes
				     #'(lambda (object stream)
					 (format stream "~A of ~A"
						 (function-slot-name (second object))
						 (type-name (first object))))
				     :stream stream :finally " and "))))))

(scl:defmethod (perform-update-action update-remove-entity-type)
	   (database schema-table area-vector)
  (declare (ignore database area-vector))
  ;; The binary-relation and other-relation functions must be removed
  ;; explicitly.  The type-relation functions will go away by themselves when
  ;; we delete the type relation itself.
  (dolist (function (type-functions real-entity-type))
    (when (forward-function-p function)
      (case (function-implementation function)
	(other-relation
	  (delete-attribute (function-of-attribute function)))
	(binary-relation
	  (delete-relation (function-relation function))))))
  ;; destroy all references to the entity type
  (let ((descendants nil))
    (labels ((get-descendants (rt)
	       (dolist (child (rt-info-children
				(car (member rt rt-info-list :key #'rt-info-rt))))
		 (unless (member child descendants)
		   (push child descendants)
		   (get-descendants child)))))
      (get-descendants real-entity-type)
      (loop with removed-types = (cons real-entity-type descendants)
	    for rt-info in rt-info-list do
	(let ((rt (rt-info-rt rt-info)))
	  (unless (member rt removed-types)
	    (dolist (function (type-functions rt))
	      (when (forward-function-p function)
		(when (member (function-value-type-name function)
			      removed-types
			      :key #'type-name
			      :test #'type-name-equal)
		  (case (function-implementation function)
		    (other-relation
		      (delete-attribute (function-of-attribute function)))
		    (binary-relation
		      (delete-relation (function-relation function))))))))))))
  (let ((parent-relations
	  (loop for a in (ancestors real-entity-type) 
		as template-type = (get (type-name a) 'entity-type)
		when (and template-type (gethash (type-relation-tag template-type)
						 schema-table))
		  collect (gethash (type-relation-tag template-type)
				   schema-table))))
    (delete-relation (type-relation-handle real-entity-type))
    (delete-domain (type-domain-handle real-entity-type) parent-relations)))

(scl:defflavor update-add-attribute
	(template-attribute)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-attribute (template-attribute reasons)))

(scl:defmethod (report-update-effect update-add-attribute) (stream)
  (format stream "Add attribute ~A of entity type ~A"
	  (function-slot-name template-attribute)
	  (function-argument-type-name template-attribute)))

(scl:defmethod (perform-update-action update-add-attribute) (database schema-table area-vector)
  (declare (ignore database))
  (make-function template-attribute schema-table area-vector))

(scl:defflavor update-remove-attribute
	(real-attribute)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-attribute (real-attribute reasons)))

(scl:defmethod (report-update-effect update-remove-attribute) (stream)
  (format stream "Remove attribute ~A of entity type ~A"
	  (function-slot-name real-attribute)
	  (function-argument-type-name real-attribute)))

(scl:defmethod (perform-update-action update-remove-attribute)
	       (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (case (function-implementation real-attribute)
    (type-relation
      (delete-attribute (function-is-attribute real-attribute)))
    (other-relation
      (delete-attribute (function-of-attribute real-attribute)))
    (binary-relation
      (delete-relation (function-relation real-attribute)))))

(scl:defflavor update-add-index
	(template-attribute)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-index (template-attribute reasons)))

(scl:defmethod (report-update-effect update-add-index) (stream)
  (format stream "Add an index to attribute ~A of entity type ~A"
	  (function-slot-name template-attribute)
	  (function-argument-type-name template-attribute))
  (let ((index-average-size (function-index-average-size template-attribute)))
    (when index-average-size
      (format stream " with average size ~D" index-average-size))))

(scl:defmethod (perform-update-action update-add-index) (database schema-table area-vector)
  (declare (ignore database area-vector))
  (let ((att (gethash (function-of-attribute-tag template-attribute) schema-table))
	(index-average-size (function-index-average-size template-attribute)))
    (cond (index-average-size
	   (make-group-index att :average-size index-average-size))
	  (t
	   (make-group-index att)))))

(scl:defflavor update-remove-index
	(real-attribute)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-index (real-attribute reasons)))

(scl:defmethod (report-update-effect update-remove-index) (stream)
  (format stream "Remove index from attribute ~A of entity type ~A"
	  (function-slot-name real-attribute)
	  (function-argument-type-name real-attribute)))

(scl:defmethod (perform-update-action update-remove-index) (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (delete-group-index (function-of-attribute real-attribute)))

(scl:defflavor update-add-inverse-index
	(template-attribute
	 exact)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-inverse-index (template-attribute exact reasons)))

(scl:defmethod (report-update-effect update-add-inverse-index) (stream)
  (format stream "Add an inverse index to attribute ~A of entity type ~A"
	  (function-slot-name template-attribute)
	  (function-argument-type-name template-attribute))
  (let ((index-average-size (function-index-average-size template-attribute)))
    (when index-average-size
      (format stream " with average size ~D" index-average-size))))

(scl:defmethod (perform-update-action update-add-inverse-index)
	       (database schema-table area-vector)
  (declare (ignore database area-vector))
  (let ((att (gethash (function-is-attribute-tag template-attribute) schema-table))
	(inverse-index-average-size (function-inverse-index-average-size template-attribute)))
    (cond ((not (subtypep (function-value-type-name template-attribute)
			  'functional-entity-handle))
	   (statice-model:make-index (list att)
				     :unique-p (function-unique template-attribute)
				     :case-sensitive exact))
	  (inverse-index-average-size
	   (make-group-index att :average-size inverse-index-average-size))
	  (t
	   (make-group-index att)))))

(scl:defflavor update-remove-inverse-index
	(real-attribute
	 exact)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-inverse-index (real-attribute exact reasons)))

(scl:defmethod (report-update-effect update-remove-inverse-index) (stream)
  (format stream "Remove inverse index from attribute ~A of entity type ~A"
	  (function-slot-name real-attribute)
	  (function-argument-type-name real-attribute)))

(scl:defmethod (perform-update-action update-remove-inverse-index)
	   (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (let ((att (function-is-attribute real-attribute)))
    (cond ((not (subtypep (function-value-type-name real-attribute)
			  'functional-entity-handle))
	   (statice-model:delete-index (list att)
				       :case-sensitive exact))
	  (t
	   (delete-group-index att)))))

(scl:defflavor update-add-multiple-index
	(template-multiple-index)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-multiple-index (template-multiple-index reasons)))

(scl:defmethod (report-update-effect update-add-multiple-index) (stream)
  (report-multiple-index-effect "Add" stream template-multiple-index))

(defun report-multiple-index-effect (verb stream multiple-index)
  (format stream "~A multiple index on attributes " verb)
  (scl:format-textual-list (multiple-index-slot-names multiple-index) #'princ
		       :stream stream :finally " and ")
  (format stream " of entity type ~A" (type-name (multiple-index-type multiple-index))))

(scl:defmethod (perform-update-action update-add-multiple-index)
	   (database schema-table area-vector)
  (declare (ignore database area-vector))
  (let ((type (multiple-index-type template-multiple-index))
	(relation-tag nil))
    (statice-model:make-index
      (loop for slot-name in (multiple-index-slot-names template-multiple-index)
	    collect
	      (loop for function in (type-functions type) do
		(when (and (eq slot-name (function-slot-name function))
			   (forward-function-p function))
		  (let ((rt (function-relation-tag function)))
		    (cond (relation-tag
			   (unless (eq rt relation-tag)
			     (error "Not all of the slots ~S are~@
                                     in the same relation in the multiple index."
				    (multiple-index-slot-names template-multiple-index))))
			  (t (setq relation-tag rt))))
		  (return (gethash (function-is-attribute-tag function)
				   schema-table)))
		    finally
		      (error "~A is not a valid slot-name for ~@
                                         a multiple-index of entity-type ~S"
			     slot-name (type-name type))))
      :unique-p (multiple-index-unique template-multiple-index)
      :case-sensitive (multiple-index-case-sensitive template-multiple-index))))

(scl:defflavor update-remove-multiple-index
	(real-multiple-index)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-multiple-index (real-multiple-index reasons)))

(scl:defmethod (report-update-effect update-remove-multiple-index) (stream)
  (report-multiple-index-effect "Remove" stream real-multiple-index))

(scl:defmethod (perform-update-action update-remove-multiple-index)
	   (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (statice-model:delete-index
    (multiple-index-attribute-handles real-multiple-index)
    :case-sensitive (multiple-index-case-sensitive real-multiple-index)))

(scl:defflavor update-add-type-set
	(real-entity-type)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-type-set (real-entity-type reasons)))

(scl:defmethod (report-update-effect update-add-type-set) (stream)
  (format stream "Add a type-set to entity-type ~S" (type-name real-entity-type)))

(scl:defmethod (perform-update-action update-add-type-set)
	   (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (make-domain-index (type-domain-handle real-entity-type)))

(scl:defflavor update-remove-type-set
	(real-entity-type)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-type-set (real-entity-type reasons)))


(scl:defmethod (report-update-effect update-remove-type-set) (stream)
  (format stream "Remove the type-set from entity-type ~S" (type-name real-entity-type)))

(scl:defmethod (perform-update-action update-remove-type-set)
	   (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (delete-domain-index (type-domain-handle real-entity-type)))

(scl:defflavor update-add-function-set
	(real-attribute)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-add-function-set (real-attribute reasons)))

(scl:defmethod (report-update-effect update-add-function-set) (stream)
  (format stream "Add a function-set to attribute ~S of entity type ~S"
	  (function-slot-name real-attribute)
	  (function-argument-type-name real-attribute)))

(scl:defmethod (perform-update-action update-add-function-set)
	   (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (when (eq (function-implementation real-attribute) 'binary-relation)
    (make-relation-index (function-relation real-attribute))))

(scl:defflavor update-remove-function-set
	(real-attribute)
	(basic-update-action)
  (:initable-instance-variables)
  (:readable-instance-variables)
  (:constructor make-update-remove-function-set (real-attribute reasons)))

(scl:defmethod (report-update-effect update-remove-function-set) (stream)
  (format stream "Remove the function-set from attribute ~S of entity type ~S"
	  (function-slot-name real-attribute)
	  (function-argument-type-name real-attribute)))

(scl:defmethod (perform-update-action update-remove-function-set)
	   (database schema-table area-vector)
  (declare (ignore database schema-table area-vector))
  (when (eq (function-implementation real-attribute) 'binary-relation)
    (delete-relation-index (function-relation real-attribute))))

;;; STILL TO DO: Warnings when data is going to be lost.  Note that
;;; whenever a domain is deleted, every entity of that type is also
;;; deleted, and so many tuples as well.  So if an attribute is of
;;; type domain D, and domain D is deleted, the attribute is deleted
;;; and every last tuple of the relation is deleted, but the relation
;;; and the other attributes still exist.

(cp:define-command (com-update-database-schema :command-table "Statice")
    ((pathname 'fs:dbfs-pathname))
   (update-schema pathname)
   (values))

;;; Returns t if it did something, nil if the schema was already up-to-date.
;;; silent suppresses printing, although it does not suppress the question and
;;; its prompt.  force means instead of asking the question, assume the user
;;; would type yes.  no-effect means do not do anything to the database, and
;;; don't even ask the question (so no-effect overrides force), but return t
;;; to indicate that we would have done something.
(defun update-schema (pathname &key silent force no-effect)
  (when (stringp pathname) (setq pathname (fs:merge-pathnames pathname)))
  (let* ((real-schema (get-real-schema pathname))
	 (plan (form-update-plan real-schema)))
    (cond ((null plan)
	   (unless silent (format t "~&The schema of ~A is already up-to-date." pathname))
	   nil)
	  (t
	   (unless silent
	     (format t "~&Plan for updating the schema of ~A:~%" pathname)
	     (dolist (p plan)
	       (report-update-effect p *standard-output*)
	       (report-update-reasons p *standard-output* t)
	       (terpri)))
	   (when (and (not no-effect) (or force (yes-or-no-p "Go ahead? ")))
	     (let ((database (open-database pathname t)))
	       (with-current-database (database)
		 (with-transaction ()
		   (unless (equal (database-schema-version) (schema-version real-schema))
		     (error "Someone else updated the schema of ~S~@
                             while you were doing update-schema" pathname))
		   (perform-update-plan plan database real-schema))))
	     (unless silent (format t "~&Done.")))
	   t))))

(defun make-rt-info-list (type-list)
  (let ((rt-info-list
	  (loop for rt in type-list collect (make-rt-info :rt rt))))
    (dolist (child-info rt-info-list)
      (let ((child (rt-info-rt child-info)))
	(dolist (parent-name (type-parent-names child))
	  (push child
		(rt-info-children
		  (car (member parent-name rt-info-list
			       :key #'(lambda (rt-info)
					(type-name (rt-info-rt rt-info))))))))))
    rt-info-list))

;;; Given a list of real-entity-type instances, return a corresponding
;;; list of rt-info structures, with all the info filled in.
(defun perform-update-plan (plan database real-schema)
  (let* ((schema-table (functional-database-schema-table database))
	 (area-vector (schema-area-vector real-schema))
	 (area-vector-fill-pointer (fill-pointer area-vector)))
    (dolist (p plan)
      (perform-update-action p database schema-table area-vector))
    (when (> (fill-pointer area-vector) area-vector-fill-pointer)
      ;; New areas are being used.
      (let* ((areas (get-relation "%%$areas"))
	     (name (get-attribute areas "name"))
	     (number (get-attribute areas "number")))
	(loop for i from area-vector-fill-pointer below (fill-pointer area-vector) do
	  (make-tuple areas name (aref area-vector i) number i))))))

(defun form-update-plan (real-schema)
  (let* ((template-schema (get (schema-name real-schema) 'schema))
	 (tt-name-list (copy-list (schema-type-names template-schema)))
	 (rt-info-list (make-rt-info-list (schema-types real-schema)))
	 (rt-removed nil)			;Attributes look at this to see if removed.
	 (rt-remove-actions nil)
	 (tt-added-actions-1 nil)
	 (tt-added-actions-2 nil)
	 (rt-tt-kept nil)
	 (type-actions nil))
    (flet ((add-type (type reason)
	     (push (make-update-add-entity-type type (scl:ncons reason))
		   tt-added-actions-1)
	     D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Only add attributes if there are any to add.
0	     (loop for att in (type-functions type)
		   until (when (forward-function-p att)
			   (push (make-update-add-all-attributes type nil)
				 tt-added-actions-2)))))
      ;; Do some error checking on the new template schema, first.    
      (check-and-order-types template-schema)
      (dolist (rt-info rt-info-list)
	;; The following invariants is always true at this point.  If any real
	;; type R is on rt-remove-actions, none of R's descendants is on
	;; rt-remove-actions, and R is on rt-removed.  If any real type R is on
	;; rt-removed, all of R's descendants are on rt-removed.
	(let* ((rt (rt-info-rt rt-info))
	       (tt-name (car (member (type-name rt) tt-name-list :test #'string-equal))))
	  (unless (member rt rt-removed)
	    (labels
	      ((remove-type (reasons)
		 (push (rt-info-rt rt-info) rt-removed)
		 (push (make-update-remove-entity-type rt rt-info-list reasons)
		       rt-remove-actions)
		 (remove-descendants rt-info))
	       ;; Given an rt-info, put this rt and all its
	       ;; descendents onto the rt-removed list.
	       (remove-descendants (rt-info)
		 (dolist (child (rt-info-children rt-info))
		   (let ((a (member child rt-remove-actions
				    :key #'update-remove-entity-type-real-entity-type)))
		     (cond (a
			    (setq rt-remove-actions (delete (car a) rt-remove-actions)))
			   ((not (member child rt-removed))
			    (push child rt-removed)
			    (remove-descendants
			      (car (member child rt-info-list :key #'rt-info-rt)))))))))
	      (cond ((null tt-name)
		     (remove-type '("it is no longer part of the schema")))
		    (t
		     (let* ((tt (get tt-name 'entity-type))
			    (reasons (types-compatible-p rt tt)))
		       (cond (reasons
			      (remove-type reasons)
			      (add-type tt "it was changed incompatibly"))
			     (t
			      (push (list rt tt) rt-tt-kept)))
		       (setq tt-name-list (delete tt-name tt-name-list)))))))))
      (dolist (tt-name tt-name-list)
	(let ((tt (get tt-name 'entity-type)))
	  (add-type tt "it was added to the schema")))
      (loop for (rt tt) in rt-tt-kept do
	;; If we first saw this type and thought it was compatible, but later
	;; decided to remove it because its parent was removed, then what really
	;; happened is that the type was deleted and must be recreated as if it
	;; had been changed incompatibly.
	(cond ((member rt rt-removed)
	       (add-type tt "its ancestor was changed incompatibly"))
	      (t
	       (setq type-actions
		     (nconc type-actions (form-update-plan-for-type rt tt rt-removed))))))
      (setq tt-added-actions-1 (sort-add-entity-actions tt-added-actions-1))
      (nconc rt-remove-actions tt-added-actions-1 tt-added-actions-2 type-actions))))

;;; The argument is a list of update-add-entity-type actions.  We return the
;;; list, sorted so that parents are before their children.
(defun sort-add-entity-actions (actions)
  (let ((input-queue actions)
	(output-queue nil))
    (loop for did-some-work = nil do
      (dolist (action input-queue)
	;; See whether we can do this action yet.
	(when (loop for parent-name in (type-parent-names
					 (update-add-entity-type-template-entity-type
					   action))
		    never (let ((parent (get parent-name 'entity-type)))
			    (and parent
				 (member parent input-queue
					 :key
					 #'update-add-entity-type-template-entity-type))))
	  ;; All of the bona-fide parents are done, so we can do this one.
	  (push action output-queue)
	  (setq input-queue (delete action input-queue))
	  (setq did-some-work t)))
      (when (null input-queue)
	;; All types are processed, so we're finished.
	(return nil))
      (unless did-some-work
	;; There are still types to process, but we didn't do any work.
	(error "There's a circular dependency among types in the schema")))
    (nreverse output-queue)))

;;; Given a real-type and a template-type whose names are the same, examine them
;;; to see whether the real-type can be made to conform to the new template
;;; without deleting and re-creating it.  If not, return a list of strings that
;;; give the reason for the problem.  Otherwise return nil.
(defun types-compatible-p (real-type template-type)
  (let* ((reasons nil))
    (let ((real-parents (type-parent-names real-type t))
	  (template-parents (type-parent-names template-type t)))
      (unless (set-string-equal real-parents template-parents)	;Packages.
	(push (format nil "the list of parents has changed from ~A to ~A"
		      real-parents template-parents)
	      reasons)))
    (let ((real-area-name (type-area-name real-type))
	  (template-area-name (type-area-name template-type)))
      (unless (string-equal real-area-name template-area-name)
	(push (format nil "the area has changed from ~A to ~A"
		      real-area-name template-area-name)
	      reasons)))
    reasons))

;;; Compare a real type with the new template type.  The caller promises that
;;; they are compatible.  Return a list of action instances.  rt-removed is the
;;; list of real-entity-types that get deleted earlier in the process; these
;;; deletions can wipe out attributes as a side-effect.  This includes all of
;;; the entity-types that get deleted, including children and other innocent
;;; bystanders.
(defun form-update-plan-for-type (real-type template-type rt-removed)
  (let ((actions nil)
	(remove-actions nil)
	(add-actions nil)
	(remove-mi-actions nil)
	(add-mi-actions nil))
    ;; Add or remove a type-set.
    (let ((real-set-exists (type-set-exists real-type))
	  (template-set-exists (type-set-exists template-type)))
      (when (and real-set-exists (not template-set-exists))
	(push (make-update-remove-type-set real-type nil) actions))
      (when (and (not real-set-exists) template-set-exists)
	(push (make-update-add-type-set real-type nil) actions)))
    ;; Add or remove multiple indexes.
    (let ((real-multiple-indexes (type-multiple-indexes real-type))
	  (template-multiple-indexes (type-multiple-indexes template-type)))
      (let ((tmis (copy-list template-multiple-indexes)))
	(dolist (rmi real-multiple-indexes)
	  (let ((m (member rmi tmis :test #'multiple-index-equal)))
	    (if m
		(setq tmis (delete (car m) tmis))
		(push (make-update-remove-multiple-index rmi nil) remove-mi-actions))))
	(dolist (tmi tmis)
	  (push (make-update-add-multiple-index tmi nil) add-mi-actions))))
    ;; Compare the attributes.
    (let ((tas (delete-if #'(lambda (ta) (typep ta 'basic-inverse-function))
			  (copy-list (type-functions template-type)))))
      (dolist (ra (type-functions real-type))
	;; Ignore inverse functions, and ignore functions that got deleted when
	;; the real-entity-types were getting deleted.  Of course this will not
	;; print a message about any changes in the attribute, but maybe that's
	;; really right since we are, after all, re-creating it.
	(unless (or (typep ra 'basic-inverse-function)
		    (member (function-value-type-name ra)
			    rt-removed
			    :key #'type-name
			    :test #'type-name-equal))
	  (let ((ta (car (member (function-slot-name ra) tas
				 :key #'function-slot-name
				 :test #'string-equal))))			;Packages.
	    (cond ((null ta)
		   (push (make-update-remove-attribute ra nil) remove-actions))
		  (t
		   (let ((reasons (attributes-compatible-p ra ta)))
		     (cond (reasons
			    (push (make-update-remove-attribute ra reasons) remove-actions)
			    (push (make-update-add-attribute
				    ta
				    '("it was changed incompatibly"))
				  add-actions))
			   (t
			    (setq actions
				  (nconc (form-update-plan-for-attribute ra ta) actions)))))
		   (setq tas (delete ta tas)))))))
      (dolist (ta tas)
	(push (make-update-add-attribute ta nil) add-actions)))
    (nconc remove-mi-actions remove-actions add-actions add-mi-actions actions)))

;;; If the real attribute cannot be turned into the template attribute, but must
;;; be deleted and re-created, return a list of reasons.  Otherwise return nil.
(defun attributes-compatible-p (real-attribute template-attribute)
  (let* ((reasons nil))
    ;; The two arguments are known to have the same slot name and the same
    ;; argument-type-name.  value-foreign is not yet implemented.  read-only and
    ;; full-name aren't stored in the real schema and only affect the Lisp
    ;; functions.  implementation is implied by the other values.
    (let ((real-value-type-name (function-value-type-name real-attribute))
	  (template-value-type-name (function-value-type-name template-attribute)))
      (unless (type-name-equal real-value-type-name template-value-type-name)	;Packages.
	(push (format nil "the attribute's type has changed from ~A to ~A"
		      real-value-type-name template-value-type-name)
	      reasons)))
    (let ((real-value-is-set (function-value-is-set real-attribute))
	  (template-value-is-set (function-value-is-set template-attribute))
	  (real-unique (function-unique real-attribute))
	  (template-unique (function-unique template-attribute)))
      (unless (and (equal real-value-is-set template-value-is-set)
		   (equal real-unique template-unique))
	(push (format nil "the attribute has changed from ~:[one~;many~]-to-~:[one~;many~] ~
                         to ~:[one~;many~]-to-~:[one~;many~]"
		      (not real-unique) real-value-is-set
		      (not template-unique) template-value-is-set)
	      reasons)))
    (let ((real-area-name (function-area-name real-attribute))
	  (template-area-name (function-area-name template-attribute)))
      (unless (string-equal real-area-name template-area-name)			;Packages.
	(push (format nil "the area has changed from ~A to ~A"
		      real-area-name template-area-name)
	      reasons)))
    (let ((real-no-nulls (function-no-nulls real-attribute))
	  (template-no-nulls (function-no-nulls template-attribute)))
      (unless (eql real-no-nulls template-no-nulls)
	(push (format nil "the no-nulls option has changed from ~S to ~S"
		      real-no-nulls template-no-nulls)
	      reasons)))
    reasons))

;;; Compare a real function with the new template function.  Returns a list of
;;; actions to update the real function to be in line with the template.
(defun form-update-plan-for-attribute (real-attribute template-attribute)
  (let ((actions nil))
    ;; The function is compatible.
    (let ((real-set-exists (function-set-exists real-attribute))
	  (template-set-exists (function-set-exists template-attribute)))
      (when (and real-set-exists (not template-set-exists))
	(push (make-update-remove-function-set real-attribute nil) actions))
      (when (and (not real-set-exists) template-set-exists)
	(push (make-update-add-function-set real-attribute nil) actions)))
    (let ((real-index-exists (function-index-exists real-attribute))
	  (template-index-exists (function-index-exists template-attribute)))
      (when (and real-index-exists (not template-index-exists))
	(push (make-update-remove-index real-attribute nil) actions))
      (when (and (not real-index-exists) template-index-exists)
	(push (make-update-add-index template-attribute nil) actions)))
    (let ((real-inverse-index-exists (function-inverse-index-exists real-attribute))
	  (template-inverse-index-exists (function-inverse-index-exists template-attribute)))
      (when (and real-inverse-index-exists (not template-inverse-index-exists))
	(push (make-update-remove-inverse-index real-attribute nil nil) actions))
      (when (and (not real-inverse-index-exists) template-inverse-index-exists)
	(push (make-update-add-inverse-index template-attribute nil nil) actions)))
    (let ((real-inverse-index-exact-exists
	    (function-inverse-index-exact-exists real-attribute))
	  (template-inverse-index-exact-exists
	    (function-inverse-index-exact-exists template-attribute)))
      (when (and real-inverse-index-exact-exists (not template-inverse-index-exact-exists))
	(push (make-update-remove-inverse-index real-attribute t nil) actions))
      (when (and (not real-inverse-index-exact-exists) template-inverse-index-exact-exists)
	(push (make-update-add-inverse-index template-attribute t nil) actions)))
    actions))

(defun multiple-index-equal (mi1 mi2)
  (and (list-string-equal (multiple-index-slot-names mi1)	;Packages.
			  (multiple-index-slot-names mi2))
       (eq (multiple-index-unique mi1)
	   (multiple-index-unique mi2))
       (eq (multiple-index-case-sensitive mi1)
	   (multiple-index-case-sensitive mi2))))

(defun list-string-equal (list1 list2)
  (and (= (length list1) (length list2))
       (loop for str1 in list1
	     for str2 in list2
	     always (string-equal str1 str2))))

(defun set-string-equal (set1 set2)
  (and (= (length set1) (length set2))
       (null (set-difference set1 set2 :test #'string-equal))))

(defun type-name-equal (type-name-1 type-name-2)
  (or (and (symbolp type-name-1)
	   (symbolp type-name-2)
	   (string-equal type-name-1 type-name-2))
      (equal type-name-1 type-name-2)))

(defun attribute-equal-p (attribute-1 attribute-2)
  (and (string-equal (function-argument-type-name attribute-1)
		     (function-argument-type-name attribute-2))
       (string-equal (function-slot-name attribute-1)
		     (function-slot-name attribute-2))))

(defun multiple-index-equal-p (mi-1 mi-2)
  (and (string-equal (multiple-index-type mi-1)
		     (multiple-index-type mi-2))
       (let ((set-1 (multiple-index-slot-names mi-1))
	     (set-2 (multiple-index-slot-names mi-2)))
	 (and (= (length set-1) (length set-2))
	      (null (set-difference set-1 set-2 :test #'string-equal))))))

(scl:compile-flavor-methods
  update-add-entity-type update-add-all-attributes update-remove-entity-type
  update-add-attribute update-remove-attribute
  update-add-index update-remove-index
  update-add-inverse-index update-remove-inverse-index
  update-add-multiple-index update-remove-multiple-index
  update-add-type-set update-remove-type-set
  update-add-function-set update-remove-function-set)
