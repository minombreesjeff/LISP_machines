;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice-model; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
 
;;; Encaching and initializing the schema, and other functions that
;;; deal with system entities and system tuples.

;;; Build the schema cache for an existing database.

;;; Given a fresh database instance, build the schema for the database.
;;; Version is the schema version, from the database header.
(defun encache-schema (database)
  (check-transaction)
  (let* ((opening (database-opening database))
	 (rid-of-header (get-root-rid opening)))
    (with-record (db opening rid-of-header :write)     ;;Used to be :probable-write
      ;; Lock for probable-writing, to keep anyone else from building
      ;; the schema cache.  A :probably-write lock is exclusive, but
      ;; doesn't invalidate pages cached by file level.
      ;; ++ Yeah buddy, in your dreams.  OPEN-RECORD never has supported :probable-write.
      ;; Furthermore, DBFS's current implementation of :probable-write is not exclusive
      ;; against pure read lockers.  To really fix this right requires a schema encache
      ;; lock for both function and model layers.  Fixed in the great integration.
      (let ((model-level-version (database-header-model-level-version db)))
	(unless (or (= 10 model-level-version)
		    (= 11 model-level-version)
		    (= 12 model-level-version)
		    (= 13 model-level-version))
	  (model-error
	    "Incompatible version of model level loaded (~S)~%Database version is ~S"
	    *statice-model-level-version* model-level-version))
	(setf (database-model-level-version database) model-level-version)
	(setf (database-rid-of-header database) rid-of-header)
	(setf (database-deleted-domains database) nil)
	(setf (database-deleted-relations database) nil)
	(setf (database-deleted-attributes database) nil)
	(encache-domains database)
	(encache-relations database)
	(encache-character-encodings database)
	(setf (database-schema-version-id-2 database)
	      (database-header-schema-version-id-2 db))
	(setf (database-schema-version-id-3 database)
	      (database-header-schema-version-id-3 db))
	(setf (database-schema-version-id-1 database)
	      (database-header-schema-version-id-1 db))))))

;;; The database has a schema cache, but at least one transaction has done
;;; some schema modification since our cache was last accurate.  Either a
;;; transaction on any host modified the schema and committed, or else some
;;; transaction on this host modified the schema and then aborted, leaving
;;; the schema cache showing changes that were never made.  In either case,
;;; bring the cache up to date.  Be careful to reuse existing system entity
;;; handles.  The cache is locked, because the caller has locked the
;;; database header record for reading.  We are inside a transaction.
(defun recache-schema (database)
  (let* ((opening (database-opening database))
	 (rid-of-header (get-root-rid opening)))
    (with-record (db opening rid-of-header :write) ;;Used to be :probable-write
      ;; ++ OPEN-RECORD never has supported :probable-write.
      ;; Furthermore, DBFS's current implementation of :probable-write is not exclusive
      ;; against pure read lockers.
      (let ((model-level-version (database-header-model-level-version db)))
	(unless (or (= 10 model-level-version)
		    (= 11 model-level-version)
		    (= 12 model-level-version)
		    (= 13 model-level-version))
	  (model-error
	    "Incompatible version of model level loaded (~S)~%Database version is ~S"
	    *statice-model-level-version* model-level-version))
	(setf (database-model-level-version database) model-level-version)
	(setf (database-rid-of-header database) rid-of-header)
	(encache-domains database)
	(encache-relations database)
	(encache-character-encodings database)
	(setf (database-deleted-domains database) nil)
	(setf (database-deleted-relations database) nil)
	(setf (database-deleted-attributes database) nil)
	;;Don't forget, packages have a cache, too.  -- Feinberg 9/6/91
	(recache-packages database)
	;; The recaching is finished.  Mark the schema cache to show that
	;; it's now up-to-date.
	(setf (database-schema-version-id-1 database)
	      (database-header-schema-version-id-1 db))
	(setf (database-schema-version-id-2 database)
	      (database-header-schema-version-id-2 db))
	(setf (database-schema-version-id-3 database)
	      (database-header-schema-version-id-3 db))))))

(defun recache-packages (database)
  (process:with-lock ((database-package-lock database))
    (let ((package-vector (database-package-vector database))
	  (package-name-vector (database-package-name-vector database)))
      (when package-vector
	(fill package-vector nil)
	(setf (fill-pointer package-vector) 0))
      (when package-name-vector
	(fill package-name-vector nil)
	(setf (fill-pointer package-name-vector) 0)))
    (when (database-package-name-table database)
      (clrhash (database-package-name-table database)))
    (update-package-structures database)))

(defun encache-domains (database)
  (let* ((new-table-of-domains
	   (scl:make-hash-table :test #'string-equal :locking nil :ignore-gc t))
	 (opening (database-opening database))
	 (domain-domain-rid
	   (with-record (db opening (database-rid-of-header database) :read)
	     (database-header-domain-domain db)))
	 (domain-bid nil)
	 (the-domain-domain nil))
    (with-record (dom-dom opening domain-domain-rid :read)
      (setq domain-bid (domain-bset-iid dom-dom))
      ;; Initialize the database's uid from the domain domain entity.
      (setf (database-uid-1 database) (entity-uid-word-1 dom-dom))
      (setf (database-uid-2 database) (entity-uid-word-2 dom-dom))
      (setf (database-uid-3 database) (entity-uid-word-3 dom-dom)))
    (map-over-bset
      opening
      domain-bid
      #'(lambda (domain-rid)
	  (with-record (dom opening domain-rid :read)
	    (let* ((uid1 (entity-uid-word-1 dom))
		   (uid2 (entity-uid-word-2 dom))
		   (uid3 (entity-uid-word-3 dom))
		   (domain-handle
		     (or (and (database-table-of-domains database)
			      (do-domains (dh database)
				(when (and (= uid1 (entity-handle-uid-word-1 dh))
					   (= uid2 (entity-handle-uid-word-2 dh))
					   (= uid3 (entity-handle-uid-word-3 dh)))
				  (return dh))))
			 (dolist (dh (database-deleted-domains database))
			   (when (and (= uid1 (entity-handle-uid-word-1 dh))
				      (= uid2 (entity-handle-uid-word-2 dh))
				      (= uid3 (entity-handle-uid-word-3 dh)))
			     (return dh)))
			 (make-instance
			   'domain-handle
			   :rid domain-rid
			   :uid-word-1 uid1
			   :uid-word-2 uid2
			   :uid-word-3 uid3
			   ;; :domain gets filled in later.
			   :database database
			   :area (domain-area dom)
			   :name (read-string-from-record
				   dom (domain-name-n-bytes dom) (domain-name-start-word dom))
			   :system-domain-p (= (domain-system-domain-p dom) 1)
			   :list-of-parent-domains
			   ;; Build a list of RIDs, since the domain handles don't exist yet.
			   (let ((lpd (domain-list-of-parent-domains dom)))
			     (cond ((not (zerop (domain-many-parent-domains dom)))
				    (loop with parent-list = nil
					  with cons-rid = lpd
					  until (zerop cons-rid) do
				      (with-record (cons opening cons-rid :read)
					(push (parent-domain-cons-parent-domain cons)
					      parent-list)
					(setq cons-rid (parent-domain-cons-next cons)))
					  finally (return parent-list)))
				   ((zerop lpd) nil)
				   (t (list lpd))))))))
	      (setf (domain-handle-next-layout-version domain-handle)
		    (domain-next-layout-version dom))
	      (setf (domain-handle-new-layout-needed domain-handle)
		    (= (domain-new-layout-needed dom) 1))
	      (setf (domain-handle-allocation-map domain-handle) nil)
	      (setf (domain-handle-bset-iid domain-handle)
		    (let ((bid (domain-bset-iid dom)))
		      (unless (zerop bid) bid)))
	      ;; Set later by encache-relations
	      (setf (domain-handle-relations-optimized-on domain-handle) nil)
	      ;; Pushed on later by encache-attributes
	      (setf (domain-handle-group-indexed-attributes domain-handle) nil)
	      (when (= domain-rid domain-domain-rid)
		(setq the-domain-domain domain-handle))
	      (with-database-known-entity-handles-lock (database)
		(setf (gethash domain-rid (database-known-entity-handles database))
		      domain-handle))
	      (setf (gethash (domain-handle-name domain-handle) new-table-of-domains)
		    domain-handle)))))
    (when (null the-domain-domain)
      (model-bug "Database ~S has no domain domain" database))
    (setf (database-table-of-domains database) new-table-of-domains)
    ;; Each element in a list of parent domains might be a rid, or might be
    ;; a real domain object if we're recaching and the entity isn't new.
    (do-domains (d database)
      (setf (known-entity-handle-domain d) the-domain-domain)
      (loop for c on (domain-handle-list-of-parent-domains d) do
	(let ((rid (car c)))
	  (when (numberp rid)
	    (setf (car c)
		  (or (do-domains (p database)
			(when (= (handle-rid p) rid)
			  (return p)))
		      (model-bug "No domain handle for parent RID ~S" rid)))))))))

(defun encache-relations (database)
  (let* ((new-table-of-relations
	   (scl:make-hash-table :test #'string-equal :locking nil :ignore-gc t))
	 (opening (database-opening database))
	 (the-relation-domain (find-domain-handle-given-name "%%relation" database))
	 (relation-bid (with-record (rd opening (handle-rid the-relation-domain) :read)
			 (domain-bset-iid rd)))
	 (att-type-handler (make-instance 'att-type-handler
					  :original-presentation-type 'att-type
					  :presentation-type 'att-type
					  :no-nulls nil)))
    (map-over-bset
      opening
      relation-bid
      #'(lambda (relation-rid)
	  (with-record (rel opening relation-rid :read)
	    (let* ((soo-att-rid (relation-surrogate-optimized-on rel))
		   (uid1 (entity-uid-word-1 rel))
		   (uid2 (entity-uid-word-2 rel))
		   (uid3 (entity-uid-word-3 rel))
		   (relation-handle
		     (or (and (database-table-of-relations database)
			      (do-relations (rh database)
				(when (and (= uid1 (entity-handle-uid-word-1 rh))
					   (= uid2 (entity-handle-uid-word-2 rh))
					   (= uid3 (entity-handle-uid-word-3 rh)))
				  (return rh))))
			 (dolist (rh (database-deleted-relations database))
			   (when (and (= uid1 (entity-handle-uid-word-1 rh))
				      (= uid2 (entity-handle-uid-word-2 rh))
				      (= uid3 (entity-handle-uid-word-3 rh)))
			     (return rh)))
			 (make-instance
			   'relation-handle
			   :rid relation-rid
			   :uid-word-1 uid1
			   :uid-word-2 uid2
			   :uid-word-3 uid3
			   :domain the-relation-domain
			   :database database
			   :area (relation-area rel)
			   :system-relation-p (= (relation-system-relation-p rel) 1)
			   :name (read-string-from-record
				   rel
				   (relation-name-n-bytes rel)
				   (relation-name-start-word rel))
			   :list-of-attributes nil))))	;for encache-attributes
	      (setf (relation-handle-bset-iid relation-handle)
		    (let ((bid (relation-bset-iid rel)))
		      (unless (zerop bid) bid)))
	      (cond ((zerop soo-att-rid)
		     ;; This is a normal relation.
		     (setf (relation-handle-surrogate-optimized-on relation-handle) nil)
		     (setf (relation-handle-new-layout-needed relation-handle)
			   (= (relation-new-layout-needed rel) 1))
		     (setf (relation-handle-next-layout-version relation-handle)
			   (relation-next-layout-version rel))
		     (setf (relation-handle-allocation-map relation-handle) nil))
		    (t
		     ;; This is a surrogate-optimized relation.
		     ;; relation-handle-surrogate-optimized-on will be
		     ;; set by encache-attributes.
		     (setf (relation-handle-entity-bit-map-number relation-handle)
			   ;; entity-bit-map-number field is rid
			   ;; of list to build table with
			   (let ((desc-array
				   (loop with array-elements = nil
					 with cons-rid = (relation-entity-bit-map-list rel)
					 until (zerop cons-rid) do
				     (with-record (cons opening cons-rid :read)
				       (push (cons
					       (let ((domain-rid
						       (entity-bit-table-cons-domain cons)))
						 (if (= domain-rid 1)
						     'any-domain
						     (find-domain-handle-given-rid
						       domain-rid
						       database)))
					       (entity-bit-table-cons-bit-number cons))
					     array-elements)
				       (setq cons-rid (entity-bit-table-cons-next cons)))
					 finally (return array-elements))))
			     (make-array (length desc-array) :adjustable t
					 :fill-pointer t
					 :initial-contents desc-array)))
		     (unless (= (relation-entity-domain rel) 1)
		       (let ((root-domain (with-record (att opening soo-att-rid :read)
					    (find-domain-handle-given-rid
					      (attribute-type-word-2 att) database))))
			 (do-children (domain-handle root-domain database)
			   (push relation-handle
				 (domain-handle-relations-optimized-on domain-handle)))))))
	      (encache-attributes relation-handle rel soo-att-rid database att-type-handler)
	      (encache-indexes relation-handle rel database)
	      (with-database-known-entity-handles-lock (database)
		(setf (gethash relation-rid (database-known-entity-handles database))
		      relation-handle))
	      (setf (gethash (relation-handle-name relation-handle) new-table-of-relations)
		    relation-handle)))))
    (setf (database-table-of-relations database) new-table-of-relations)))

;;; relation-handle is a relation-handle but it's still being built.
;;; rel is the Storage Level addressor for the relation record.
;;; soo-att-rid is the relation-surrogate-optimized-on field from the relation.
;;; If it is zero, this is a normal relation.  Otherwise it is the RID of
;;; the entity-valued attribute that this relation is surrogate optimized on.
;;; Note that relation-handle-surrogate-optimized-on hasn't been filled in
;;; yet, because the attribute-handles have not been made yet.  So we fix it up.
;;; database is the database instance for this database.
(defun encache-attributes (relation-handle rel soo-att-rid database att-type-handler)
  (let* ((opening (database-opening database))
	 (new-list-of-attributes nil)
	 (old-list-of-attributes
	   (append (database-deleted-attributes database)
		   (relation-handle-list-of-attributes relation-handle)))
	 (attribute-rid (relation-list-of-attributes rel))
	 (the-attribute-domain (find-domain-handle-given-name "%%attribute" database)))
    (loop until (zerop attribute-rid) do
      (with-record (att opening attribute-rid :read)
	(let* ((name-n-bytes (attribute-name-n-bytes att))
	       (uid1 (entity-uid-word-1 att))
	       (uid2 (entity-uid-word-2 att))
	       (uid3 (entity-uid-word-3 att))
	       (no-nulls (not (zerop (attribute-no-nulls att))))
	       (attribute-handle
		 (or (dolist (ah old-list-of-attributes)
		       (when (and (= uid1 (entity-handle-uid-word-1 ah))
				  (= uid2 (entity-handle-uid-word-2 ah))
				  (= uid3 (entity-handle-uid-word-3 ah)))
			 (return ah)))
		     (make-instance
		       'attribute-handle
		       :rid attribute-rid
		       :uid-word-1 uid1
		       :uid-word-2 uid2
		       :uid-word-3 uid3
		       :domain the-attribute-domain
		       :relation relation-handle
		       :name (read-string-from-record
			       att name-n-bytes (attribute-name-start-word att))
		       :type (let ((value (read-value att-type-handler
						      att
						      (word-offset 'attribute-type)
						      database)))
			       (if (typep value 'entity-handle)
				   value
				   (or (get-storage-handler value no-nulls
							    :if-does-not-exist nil)
				       (get-unknown-storage-handler att value no-nulls))))
		       :unique (= (attribute-unique att) 1)
		       :delete-nullifies (= (attribute-delete-nullifies att) 1)
		       :indexed nil		; Filled in later, see below.
		       :group-index-offset nil
		       :group-index-layout-version nil
		       :group-index-average-size (attribute-group-index-average-size att)
		       :no-nulls no-nulls))))
	  (let ((ad (attribute-descriptor att))
		(av (attribute-layout-version att)))
	    (cond ((zerop soo-att-rid)
		   (setf (attribute-handle-descriptor attribute-handle) ad)
		   (setf (attribute-handle-layout-version attribute-handle)
			 (unless (minusp av) av)))
		  (t
		   (let (desc-array ver-array)
		     (loop with cons-rid = ad
			   until (zerop cons-rid) do
		       (with-record (cons opening cons-rid :read)
			 (let ((domain-rid (attribute-desc-and-layout-cons-domain cons)))
			   (push (cons (if (= domain-rid 1)
					   'any-domain
					   (find-domain-handle-given-rid domain-rid database))
				       (attribute-desc-and-layout-cons-descriptor cons))
				 desc-array)
			   (push (cons (if (= domain-rid 1)
					   'any-domain
					   (find-domain-handle-given-rid domain-rid database))
				       (attribute-desc-and-layout-cons-layout-version cons))
				 ver-array))
			 (setq cons-rid (attribute-desc-and-layout-cons-next cons))))
		     (setf (attribute-handle-descriptor attribute-handle)
			   (make-array (length desc-array)
				       :fill-pointer t
				       :initial-contents desc-array))
		     (setf (attribute-handle-layout-version attribute-handle)
			   (make-array (length ver-array)
				       :fill-pointer t
				       :initial-contents ver-array))))))
	  ;; Group index offset
	  (let (offset-array layout-array)
	    (loop with cons-rid = (attribute-group-index-offset att)
		  until (zerop cons-rid) do
	      (with-record (cons opening cons-rid :read)
		(let ((domain (find-domain-handle-given-rid
				(attribute-group-index-info-cons-domain cons) database)))
		  (push (cons domain (attribute-group-index-info-cons-offset cons))
			offset-array)
		  (push (cons domain (attribute-group-index-info-cons-layout-version cons))
			layout-array))
		(setq cons-rid (attribute-group-index-info-cons-next cons))))
	    (when offset-array
	      (setf (attribute-handle-group-index-offset attribute-handle)
		    (make-array (length offset-array) :adjustable t
				:fill-pointer t
				:initial-contents offset-array))
	      (setf (attribute-handle-group-index-layout-version attribute-handle)
		    (make-array (length layout-array) :adjustable t
				:fill-pointer t
				:initial-contents layout-array))))
	  ;; Is this the attribute that this relation is surrogate optimized on?
	  (when (= soo-att-rid attribute-rid)
	    ;; Fix up the relation-handle, and set descriptor to nil.
	    (setf (relation-handle-surrogate-optimized-on relation-handle)
		  attribute-handle)
	    (setf (attribute-handle-descriptor attribute-handle) nil))
	  ;; Build domain-handle-group-indexed-attributes.
	  (when (attribute-handle-group-index-offset attribute-handle)
	    (let ((domain-handle (attribute-handle-type attribute-handle)))
	      (do-children (child domain-handle database)
		(push attribute-handle (domain-handle-group-indexed-attributes child)))))
	  (with-database-known-entity-handles-lock (database)
	    (setf (gethash attribute-rid (database-known-entity-handles database))
		  attribute-handle))
	  (push attribute-handle new-list-of-attributes))
	(setq attribute-rid (attribute-next-attribute-in-relation att))))
    ;; End of loop over attributes.
    (setf (relation-handle-list-of-attributes relation-handle) new-list-of-attributes)))

(defun encache-indexes (relation-handle rel database)
  (let ((list-of-indexes nil)
	(index-rid (relation-list-of-indexes rel))
	(atts (relation-handle-list-of-attributes relation-handle))
	(the-index-domain (find-domain-handle-given-name "%%index" database)))
    (loop until (zerop index-rid) do
      (with-record (index (database-opening database) index-rid :read)
	(let* ((attributes
		 (loop for offset from (record-size index) below (get-record-size index)
		       collect (let ((rid (read-record-word index offset)))
				 (or (dolist (a atts)
				       (when (= (handle-rid a) rid) (return a)))
				     (model-bug "Can't find index attribute")))))
	       (index-handle
		 (make-instance
		   'index-handle
		   :rid index-rid
		   :uid-word-1 (entity-uid-word-1 index)
		   :uid-word-2 (entity-uid-word-2 index)
		   :uid-word-3 (entity-uid-word-3 index)
		   :domain the-index-domain
		   :relation relation-handle
		   :unique (= (index-unique index) 1)
		   :case-sensitive (= (index-case-sensitive index) 1)
		   :list-of-attributes attributes
		   :index-identifier (index-index-identifier index)
		   :index-depth (index-index-depth index))))
	  (with-database-known-entity-handles-lock (database)
	    (setf (gethash index-rid (database-known-entity-handles database)) index-handle))
	  (push index-handle list-of-indexes)
	  (when (null attributes)
	    (model-bug "Index ~S has no attributes" index-handle))
	  (when (null (cdr attributes))
	    (setf (attribute-handle-indexed (car attributes)) t)))
	(setq index-rid (index-next-index-in-relation index))))
    (setf (relation-handle-list-of-indexes relation-handle)
	  (sort-list-of-indexes list-of-indexes))))

(defun encache-character-encodings (database)
  (let* ((table-of-character-encodings (make-array 256 :adjustable t))
	 (table-of-character-types (make-hash-table :rehash-threshold 20))
	 (opening (database-opening database))
	 (the-character-encoding-relation
	   (find-relation-handle-given-name "%%character-encoding" database))
	 (character-encoding-bid
	   (with-record (ced opening (handle-rid the-character-encoding-relation) :read)
	     (relation-bset-iid ced)))
	 (kw-pkg (find-package 'keyword)))
    (setf (aref table-of-character-encodings 0) 0)
    (setf (gethash 0 table-of-character-types) 0)
    (macrolet ((parse-and-intern (package-and-symbol-string)
		 `(let ((package kw-pkg)
			(colon (string-search #\: ,package-and-symbol-string)))
		    (when colon
		      (setq package (substring ,package-and-symbol-string 0 colon)))
		    (intern (substring ,package-and-symbol-string
				       (if colon (1+ colon) 0)) package))))
      (map-over-bset
	opening
	character-encoding-bid
	#'(lambda (ce-rid)
	    (with-record (ced opening ce-rid :read)
	      (let* ((family (string-upcase
			       (read-string-from-record
				 ced
				 (character-encoding-family-name-n-bytes ced)
				 (character-encoding-family-name-start-word ced))))
		     (face (string-upcase
			     (read-string-from-record
			       ced
			       (character-encoding-face-name-n-bytes ced)
			       (character-encoding-face-name-start-word ced))))
		     (size (string-upcase
			     (read-string-from-record
			       ced
			       (character-encoding-size-name-n-bytes ced)
			       (character-encoding-size-name-start-word ced))))
		     (char-style
		       (sys:with-stack-list (s (and (not (sys:%string= family 0 "NIL" 0 nil))
						    (parse-and-intern family))
					       (and (not (sys:%string= face 0 "NIL" 0 nil))
						    (parse-and-intern face))
					       (and (not (sys:%string= size 0 "NIL" 0 nil))
						    (parse-and-intern size)))
			 (si:parse-character-style s)))
		     (style-index (si:style-index char-style t))
		     (charset (si:lookup-character-set
				(let ((cs-name
					(read-string-from-record
					  ced
					  (character-encoding-cs-name-n-bytes ced)
					  (character-encoding-cs-name-start-word ced))))
				  (unless (sys:%string= cs-name 0 "NIL" 0 nil)
				    cs-name))))
		     (charset-index (send charset :decode-offset
					  (character-encoding-offset-word ced)))
		     (bits (character-encoding-bits-word ced)))
		(let ((epsilon-code (character-encoding-epsilon-code ced))
		      (char-type (ldb sys:%%char-all-but-subindex
				      (dpb bits sys:%%char-bits
					   (dpb charset-index sys:%%char-char-set
						(dpb style-index sys:%%char-style 0))))))
		  (setf (aref table-of-character-encodings epsilon-code) char-type)
		  (setf (gethash char-type table-of-character-types) epsilon-code)))))))
    (setf (database-table-of-character-encodings database) table-of-character-encodings)
    (setf (database-table-of-character-types database) table-of-character-types)))

;;; Initialize the schema and the schema cache for a new database.

;;; Given a fresh database instance to a new, empty database, initialize
;;; the schema in the database and build the corresponding schema cache.
;;; A schema-version number of zero corresponds to the schema as it is
;;; originally built, with system objects and no user objects.  As soon
;;; as any user domain or relation is created, the schema-version has to
;;; be incremented.
(defun initialize-schema (database)
  (let* ((opening (database-opening database))
	 (database-header-rid (make-record opening (record-size database-header))))
    (multiple-value-bind (uid1 uid2 uid3) (uid:unique-id)
      (set-root-rid opening database-header-rid)
      (setf (database-model-level-version database) *statice-model-level-version*)
      (setf (database-rid-of-header database) database-header-rid)
      (setf (database-deleted-domains database) nil)
      (setf (database-deleted-relations database) nil)
      (setf (database-deleted-attributes database) nil)
      (setf (database-schema-version-id-1 database) uid1)
      (setf (database-schema-version-id-2 database) uid2)
      (setf (database-schema-version-id-3 database) uid3)
      (setf (database-table-of-character-encodings database) (make-array 256 :adjustable t))
      (setf (aref (database-table-of-character-encodings database) 0) 0)
      (setf (database-table-of-character-types database)
	    (make-hash-table :rehash-threshold 20))
      ;; The actual entry in %%character-encoding gets built later
      (setf (gethash 0 (database-table-of-character-types database)) 0)
      (with-record (db opening database-header-rid :write)
	(setf (database-header-domain-domain db)
	      (initialize-system-domains database))
	(initialize-system-relations database)
	(setf (database-header-model-level-version db) *statice-model-level-version*)
	(setf (database-header-list-of-foreign-entities db) 0)
	(setf (database-header-schema-version-number db) 0)
	(setf (database-header-list-of-foreign-databases db) 0)
	(setf (database-header-schema-version-id-1 db) uid1)
	(setf (database-header-schema-version-id-2 db) uid2)
	(setf (database-header-schema-version-id-3 db) uid3)
	(setf (database-header-mabz db) 0)
	(setf (database-header-package-vector db) 0)
	(setf (database-header-mbz0 db) 0)
	(setf (database-header-mbz1 db) 0)
	(setf (database-header-mbz2 db) 0)
	(setf (database-header-mbz3 db) 0))
      (make-system-tuple database "%%character-encoding"
			 "epsilon-code" 0
			 "character-set" "NIL"
			 "family" "COMMON-LISP:NIL"
			 "face" "COMMON-LISP:NIL"
			 "size" "COMMON-LISP:NIL"
			 "bits" 0
			 "offset" 0))))

(defun initialize-system-domains (database)
  (let ((opening (database-opening database))
	(the-domain-domain nil)
	(the-domain-domain-rid 0)
	(the-domain-domain-bid nil)
	(domain-handles (scl:make-hash-table :test #'string-equal :locking nil :ignore-gc t)))
    (flet ((init-domain (name)
	     (let* ((name-n-bytes (length name))
		    (rid (make-record opening
				      (+ (record-size domain) (ceiling name-n-bytes 4))))
		    (bid (make-bset-index opening :expected-size 10))
		    (domain-handle
		      (make-instance 'domain-handle
				     :rid rid
				     :domain the-domain-domain
				     :database database
				     :area 1
				     :bset-iid bid
				     :name name
				     :list-of-parent-domains nil
				     :next-layout-version nil
				     :new-layout-needed nil
				     :system-domain-p t
				     :relations-optimized-on nil
				     :allocation-map nil
				     :group-indexed-attributes nil
				     )))
	       (setf (gethash (list rid database) (new-entity-handles)) domain-handle)
	       (setf (gethash name domain-handles) domain-handle)
	       (with-record (dom opening rid :write)
		 (set-new-entity-uid dom domain-handle)
		 (setf (entity-domain dom) the-domain-domain-rid)
		 (setf (domain-word-of-flags dom) 0)
		 (setf (local-entity-version dom) 0)
		 (setf (local-entity-tuples-present dom) 1)
		 (setf (domain-list-of-parent-domains dom) 0)
		 (setf (domain-area dom) 1)
		 (unless the-domain-domain-bid
		   (setq the-domain-domain-bid bid))
		 (setf (domain-bset-iid dom) bid)
		 (let ((new-bid (insert-bset-key opening the-domain-domain-bid rid)))
		   (unless (= new-bid the-domain-domain-bid)
		     (with-record (dd opening the-domain-domain-rid :write)
		       (setf (domain-bset-iid dd) new-bid))
		     (setf (domain-handle-bset-iid the-domain-domain) new-bid)
		     (setq the-domain-domain-rid new-bid)))
		 (setf (domain-system-domain-p dom) 1)
		 (setf (domain-name-n-bytes dom) name-n-bytes)
		 (setf (domain-name-start-word dom) (record-size domain))
		 (write-string-to-record dom name-n-bytes (record-size domain) name)
		 (setf (domain-mbz0 dom) 0)
		 (setf (domain-mbz1 dom) 0)
		 (setf (domain-mbz2 dom) 0)
		 (setf (domain-mbz3 dom) 0)))))
      ;; Bootstrapping kludges.
      (setf (database-uid-1 database) 0)
      (init-domain "%%domain")
      (setq the-domain-domain (fast-gethash "%%domain" domain-handles))
      (setq the-domain-domain-rid (handle-rid the-domain-domain))
      (setf (known-entity-handle-domain the-domain-domain) the-domain-domain)
      (with-record (dd opening the-domain-domain-rid :write)
	(setf (entity-domain dd) the-domain-domain-rid))
      (remhash (list the-domain-domain-rid database) (new-entity-handles))
      (setf (database-uid-1 database) (entity-handle-uid-word-1 the-domain-domain))
      (setf (database-uid-2 database) (entity-handle-uid-word-2 the-domain-domain))
      (setf (database-uid-3 database) (entity-handle-uid-word-3 the-domain-domain))
      (setf (gethash (list the-domain-domain-rid database) (new-entity-handles))
	    the-domain-domain)
      (init-domain "%%relation")
      (init-domain "%%attribute")
      (init-domain "%%index"))
    (setf (database-table-of-domains database) domain-handles)
    the-domain-domain-rid))

(defun initialize-system-relations (database)
  (let* ((the-domain-domain     (find-domain-handle-given-name "%%domain" database))
	 (the-relation-domain   (find-domain-handle-given-name "%%relation" database))
	 (the-attribute-domain  (find-domain-handle-given-name "%%attribute" database))
	 (the-index-domain      (find-domain-handle-given-name "%%index" database))
	 (first-attribute-rid 0)
	 (opening (database-opening database))
	 (the-relation-domain-rid (handle-rid the-relation-domain))
	 (the-relation-domain-bid (domain-handle-bset-iid the-relation-domain))
	 (relation-handles (scl:make-hash-table :test #'string-equal :locking nil :ignore-gc t))
	 (att-type-handler (make-instance 'att-type-handler)))
    (flet ((make-rel (name surrogate-p bset-p &rest attribute-descriptions)
	     ;; Make one system relation, with its attributes.
	     (let* ((name-n-bytes (length name))
		    (rid (make-record opening
				      (+ (record-size relation) (ceiling name-n-bytes 4))))
		    (relation-handle (make-instance 'relation-handle
						    :rid rid
						    :domain the-relation-domain
						    :database database
						    :area 1
						    :bset-iid nil
						    :name name
 						    :list-of-indexes nil
						    :system-relation-p t
						    :allocation-map nil
						    :entity-bit-map-number nil)))
	       (setf (gethash (list rid database) (new-entity-handles)) relation-handle)
	       (setf (gethash name relation-handles) relation-handle)
	       (with-record (rel opening rid :write)
		 (set-new-entity-uid rel relation-handle)
		 (setf (relation-word-of-flags rel) 0)
		 (setf (entity-domain rel) the-relation-domain-rid)
		 (setf (local-entity-version rel) 0)
		 (let ((new-bid (insert-bset-key opening the-relation-domain-bid rid)))
		   (unless (= new-bid the-relation-domain-bid)
		     (with-record (rd opening the-relation-domain-rid :write)
		       (setf (domain-bset-iid rd) new-bid))
		     (setf (domain-handle-bset-iid the-relation-domain) new-bid)
		     (setq the-relation-domain-bid new-bid)))
		 (setf (relation-area rel) 1)
		 (setf (local-entity-tuples-present rel) 1)
		 (setf (relation-list-of-indexes rel) 0)
		 (setf (relation-name-n-bytes rel) name-n-bytes)
		 (setf (relation-name-start-word rel) (record-size relation))
		 (write-string-to-record rel name-n-bytes (record-size relation) name)
		 (setf (relation-bset-iid rel) 0)
		 (when bset-p
		   (let ((bid (make-bset-index opening :expected-size 10)))
		     (setf (relation-handle-bset-iid relation-handle) bid)
		     (setf (relation-bset-iid rel) bid)))
		 (setf (relation-mbz0 rel) 0)
		 (setf (relation-mbz1 rel) 0)
		 (setf (relation-mbz2 rel) 0)
		 (setf (relation-mbz3 rel) 0)
		 (setf (relation-entity-bit-map-list rel) 0)
		 (setf (relation-system-relation-p rel) 1)
		 (setq first-attribute-rid
		       (initialize-attributes
			 relation-handle rel surrogate-p attribute-descriptions
			 first-attribute-rid the-attribute-domain database
			 att-type-handler))))))
      ;; Make each of the eight system relations.
      (let ((fixed-start (record-size tuple)))
	(make-rel "%%subdomain" nil t
		  "of" the-domain-domain fixed-start
		  "is" the-domain-domain (1+ fixed-start))
	(make-rel "%%domain" t nil
		  "is" the-domain-domain nil
		  "name" 'string (word-offset 'domain-name-word)
		  "domain-indexed" 'word-boolean (word-offset 'domain-bset-iid)
		  "area" 'integer (word-offset 'domain-area))
	(make-rel "%%entity-domain" 'entity-domain nil
		  "of" 'entity-handle nil
		  "is" the-domain-domain (word-offset 'entity-domain))
	(make-rel "%%relation" t nil
		  "is" the-relation-domain nil
		  "name" 'string (word-offset 'relation-name-word)
		  "relation-indexed" 'word-boolean (word-offset 'relation-bset-iid)
		  "area" 'integer (word-offset 'relation-area))
	(make-rel "%%attribute" t nil
		  "of" the-relation-domain (word-offset 'attribute-relation)
		  "is" the-attribute-domain nil
		  "type" 'att-type (word-offset 'attribute-type)
		  "name" 'string (word-offset 'attribute-name-word)
		  "unique" 'boolean (field-desc 'attribute-unique)
		  "surrogate-p" 'boolean (field-desc 'attribute-surrogate-p)
		  "delete-nullifies" 'boolean (field-desc 'attribute-delete-nullifies)
		  "no-nulls" 'boolean (field-desc 'attribute-no-nulls)
		  "group-indexed" 'word-boolean (word-offset 'attribute-group-index-offset)
		  "group-index-average-size" 'integer
		          (word-offset 'attribute-group-index-average-size))
	(make-rel "%%index" t nil
		  "on" the-relation-domain (word-offset 'index-relation)
		  "is" the-index-domain nil
		  "unique" 'boolean (field-desc 'index-unique)
		  "case-sensitive" 'boolean (field-desc 'index-case-sensitive))
	(make-rel "%%index-attribute" nil t
		  "of" the-index-domain fixed-start
		  "is" the-attribute-domain (1+ fixed-start)
		  "order" 'integer (+ 2 fixed-start))
	(make-rel "%%character-encoding" nil t
		  "epsilon-code" 'integer
		  (word-offset 'character-encoding-epsilon-code)
		  "character-set" 'string
		  (word-offset 'character-encoding-character-set-name-word)
		  "family" 'string
		  (word-offset 'character-encoding-family-name-word)
		  "face" 'string
		  (word-offset 'character-encoding-face-name-word)
		  "size" 'string
		  (word-offset 'character-encoding-size-name-word)
		  "bits" 'integer
		  (word-offset 'character-encoding-bits-word)
		  "offset" 'integer
		  (word-offset 'character-encoding-offset-word))))
    (setf (database-table-of-relations database) relation-handles)))

;;; surrogate-p can be nil, t, or entity-domain.
(defun initialize-attributes (relation-handle rel surrogate-p attribute-descriptions
			      first-rid the-attribute-domain database att-type-handler)
  (let* ((opening (database-opening database))
	 (the-attribute-domain-rid (handle-rid the-attribute-domain))
	 (the-attribute-domain-bid (domain-handle-bset-iid the-attribute-domain))
	 (attribute-handles nil)
	 (next-rid-in-relation 0)
	 (soo-att-type nil)
	 (entity-domain-p (eq surrogate-p 'entity-domain))
	 (surrogate-optimized-on nil))
    ;; Determine the surrogate attribute type ahead of time.
    (when surrogate-p
      (loop for (nil type desc) on attribute-descriptions by #'cdddr do
	(when (null desc)
	  (return (setq soo-att-type type)))
	finally (model-error "Surrogate-p set, but no nil descriptor while initializing ~S"
			     relation-handle)))
    (loop for (name type desc) on attribute-descriptions by #'cdddr do
      (let* ((name-n-bytes (length name))
	     (name-n-words (ceiling name-n-bytes 4))
	     (partial-size (+ (record-size attribute) name-n-words))
	     (size-of-type (size-of-value att-type-handler type partial-size database))
	     (rid (make-record opening (+ partial-size size-of-type)))
	     (attribute-handle (make-instance
				 'attribute-handle
				 :rid rid
				 :domain the-attribute-domain
				 :relation relation-handle
				 :name name
				 :type (if (typep type 'domain-handle)
					   type
					   (get-storage-handler type t))
				 :descriptor
				 (if (and surrogate-p desc)
				     (make-array 1
						 :adjustable t
						 :fill-pointer t
						 :initial-contents
						 (list (cons (if entity-domain-p 
								 'any-domain
								 soo-att-type)
							     desc)))
				     desc)
				 :layout-version
				 (if surrogate-p
				     (make-array 1
						 :adjustable t
						 :fill-pointer t
						 :initial-contents
						 (list (cons (if entity-domain-p 
								 'any-domain
								 soo-att-type)
							     0)))
				     0)
				 :unique (null desc)
				 :delete-nullifies nil
				 :indexed nil
				 :group-index-offset nil
				 :group-index-layout-version nil
				 :no-nulls t)))
	(setf (gethash (list rid database) (new-entity-handles)) attribute-handle)
	(push attribute-handle attribute-handles)
	(with-record (att opening rid :write)
	  (set-new-entity-uid att attribute-handle)
	  (setf (attribute-word-of-flags att) 0)
	  (let ((new-bid (insert-bset-key opening the-attribute-domain-bid rid)))
	    (unless (= new-bid the-attribute-domain-bid)
	      (with-record (ad opening the-attribute-domain-rid :write)
		(setf (domain-bset-iid ad) new-bid))
	      (setf (domain-handle-bset-iid the-attribute-domain) new-bid)
	      (setq the-attribute-domain-bid new-bid)))
	  (setq first-rid rid)
	  (setf (entity-domain att) the-attribute-domain-rid)
	  (setf (local-entity-version att) 0)
	  (setf (local-entity-tuples-present att) 1)
	  (setf (attribute-next-attribute-in-relation att) next-rid-in-relation)
	  (setq next-rid-in-relation rid)
	  (setf (attribute-relation att) (handle-rid relation-handle))
	  (let ((d (or desc 0))
		att-desc)
	    (if (and surrogate-p desc)
		(let ((cons-rid (make-record opening
					     (record-size attribute-desc-and-layout-cons))))
		  (with-record (cons opening cons-rid :write)
		    (setf (attribute-desc-and-layout-cons-domain cons)
			  (if entity-domain-p 1 (handle-rid soo-att-type)))
		    (setf (attribute-desc-and-layout-cons-descriptor cons) d)
		    (setf (attribute-desc-and-layout-cons-layout-version cons) 0)
		    (setf (attribute-desc-and-layout-cons-next cons) 0))
		  (setq att-desc cons-rid))
		(setq att-desc d))
	    (setf (attribute-descriptor att) att-desc)
	    (setf (attribute-layout-version att) 0))
	  (setf (attribute-name-n-bytes att) name-n-bytes)
	  (setf (attribute-name-start-word att) (record-size attribute))
	  (write-string-to-record att name-n-bytes (record-size attribute) name)
	  (write-value att-type-handler type att (word-offset 'attribute-type)
		       partial-size database nil size-of-type)
	  (setf (attribute-unique att) (if desc 0 1))
	  (setf (attribute-group-index-offset att) 0)
	  (setf (attribute-group-index-layout-version att) -1)
	  (setf (attribute-no-nulls att) 1)
	  (setf (attribute-mbz1 att) 0)
	  (setf (attribute-mbz2 att) 0)
	  (setf (attribute-mbz3 att) 0))
	;; Set surrogate-optimized-on to the attribute handle that we're
	;; optimizing on, or nil if we're not doing the surrogate optimization.
	(when (null desc)
	  (unless surrogate-p
	    (model-bug "Extraneous surrogate attribute"))
	  (when surrogate-optimized-on
	    (model-bug "Multiple surrogate attributes"))
	  (setq surrogate-optimized-on attribute-handle))))
    (cond (surrogate-p
	   (unless surrogate-optimized-on
	     (model-bug "Missing surrogate attribute"))
	   (setf (relation-handle-surrogate-optimized-on relation-handle)
		 surrogate-optimized-on)
	   (setf (relation-surrogate-optimized-on rel)
		 (handle-rid surrogate-optimized-on))
	   (cond (entity-domain-p
		  (add-domain-to-bit-table opening relation-handle 'entity-domain 0)
		  ;; Special dispensation, because there isn't any domain.
		  (setf (relation-entity-domain rel) 1))
		 (t
		  (add-domain-to-bit-table opening relation-handle soo-att-type 0)
		  ;; NOTE: This code depends on the fact that no system domain
		  ;; is surrogated on by more than one system relation!
		  (let ((domain-handle (attribute-handle-type surrogate-optimized-on)))
		    (with-record (domain opening (handle-rid domain-handle) :write)
		      (setf (domain-next-layout-version domain) 1)
		      (setf (domain-handle-next-layout-version domain-handle) 1)
		      (setf (domain-new-layout-needed domain) 0)
		      (setf (domain-handle-new-layout-needed domain-handle) nil)
		      (setf (domain-handle-allocation-map domain-handle) nil)
		      (setf (domain-handle-relations-optimized-on domain-handle)
			    (list relation-handle)))))))
	  (t
	   (setf (relation-handle-surrogate-optimized-on relation-handle) nil)
	   (setf (relation-surrogate-optimized-on rel) 0)
	   (setf (relation-handle-next-layout-version relation-handle) 1)
	   (setf (relation-next-layout-version rel) 1)
	   (setf (relation-handle-new-layout-needed relation-handle) nil)
	   (setf (relation-new-layout-needed rel) 0)
	   (setf (relation-handle-allocation-map relation-handle) nil)))
    (setf (relation-list-of-attributes rel) next-rid-in-relation)
    (setf (relation-handle-list-of-attributes relation-handle) attribute-handles)
    first-rid))

;;; Making and deleting system tuples.

;;; Make a new tuple in a system relation of database.  The caller
;;; guarantees that the relation is a system relation, that it is not
;;; surrogate-optimized, that the attribute names and types are all
;;; completely valid, that all attributes are supplied, that no
;;; uniqueness checks are needed.
(defun make-system-tuple (database relation-name &rest attributes-and-values)
  ;; Pass 1 over the attributes-and-values.  Figure out how many words
  ;; of storage we will need in addition to the fixed words.  Clobber
  ;; the attribute names into attribute handles.
  (let* ((n-var-words 0)
	 (relation-handle (find-relation-handle-given-name relation-name database))
	 (first-var-word
		 (fixed-space-for-version
		   (get-relation-allocation-map relation-handle)
		   0))
	 (opening (database-opening database)))
    (using-resource (attribute-size-map tables)
      (using-resource (attribute-transition-table-map tables)
	(loop with free = first-var-word
	      for av on attributes-and-values by #'cddr do
	  (let ((attribute-handle
		  (find-attribute-handle-given-name (first av) relation-handle)))
	    (setf (first av) attribute-handle)
	    (multiple-value-bind (size transition-table)
		(size-of-value (attribute-handle-type attribute-handle)
			       (second av)
			       free
			       database)
	      (setf (gethash attribute-handle attribute-size-map) size)
	      (setf (gethash attribute-handle attribute-transition-table-map)
		    transition-table)
	      (incf n-var-words size)
	      (incf free size))))
	;; Pass 2, in which we actually store the values.
	(let* ((rid (make-record opening (+ first-var-word n-var-words)))
	       (rel-rid (handle-rid relation-handle)))
	  (with-record (tuple opening rid :write)
	    (let ((bid (relation-handle-bset-iid relation-handle)))
	      (when bid
		(let ((new-bid (insert-bset-key opening bid rid)))
		  (unless (= new-bid bid)
		    (with-record (r opening rel-rid :write)
		      (setf (relation-bset-iid r) new-bid))
		    (setf (relation-handle-bset-iid relation-handle) new-bid)
		    (setq bid new-bid)))))
	    ;; Set the version number field.
	    (setf (tuple-version tuple) 0)
	    ;; set the tuple-relation field.
	    (setf (tuple-relation tuple) rel-rid)
	    ;; For every attribute, store the value.
	    (loop with free = first-var-word
		  for (attribute-handle value) on attributes-and-values by #'cddr do
	      (setq free (write-value (attribute-handle-type attribute-handle)
				      value
				      tuple
				      (attribute-handle-descriptor attribute-handle)
				      free
				      database
				      (gethash attribute-handle
					       attribute-transition-table-map)
				      (gethash attribute-handle attribute-size-map)))))))))
  t)

;;; Delete some tuples in a system relation of database.  In
;;; particular, delete all the ones for which the given attributes match
;;; the given values.   The caller guarantees that the relation is a
;;; system relation, that it is not surrogate-optimized, that the
;;; attribute names and types are all completely valid, that none of
;;; the values is a null value.
(defun delete-system-tuples (database relation-name &rest attributes-and-values)
  (let* ((relation-handle (find-relation-handle-given-name relation-name database))
	 (bid (relation-handle-bset-iid relation-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database)))
    (loop for av on attributes-and-values by #'cddr do
      (setf (first av) (find-attribute-handle-given-name (first av) relation-handle)))
    (map-over-tuple-records
      relation-handle
      #'(lambda (tuple-rid)
	  (with-record (tuple opening tuple-rid :read)
	    (when (loop for (a value) on attributes-and-values by #'cddr
			always (value-equal (attribute-handle-type a)
					    tuple
					    (attribute-handle-descriptor a)
					    value
					    database))
	      ;; The values all match.  Delete this tuple.
	      (when bid
		(let ((new-bid (delete-bset-key opening bid tuple-rid)))
		  (unless (= new-bid bid)
		    (with-record (r opening (handle-rid relation-handle) :write)
		      (setf (relation-bset-iid r) new-bid))
		    (setf (relation-handle-bset-iid relation-handle) new-bid))))
	      (delete-record opening tuple-rid)
	      (nullify-tuple-given-rid tuple-rid relation-handle)))))))

;;; The caller guarantees that the database's model level version is
;;; currently 10.  Fix up all the indexes and upgrade the version number.
(defun upgrade-to-version-11 (database)
  (note-schema-modified database)
  (let ((opening (database-opening database)))
    (do-relations (relation database)
      (dolist (index (relation-handle-list-of-indexes relation))
	(let* ((iid (index-handle-index-identifier index))
	       (header-page (dbfs::read-page opening iid))
	       (new-iid (aref header-page 5)))
	  (setf (index-handle-index-identifier index) new-iid)
	  (with-record (idx opening (handle-rid index) :write)
	    (setf (index-index-identifier idx) new-iid))
	  (statice-storage::deallocate-whole-page opening iid))))
    (setf (database-model-level-version database) 11)
    (with-record (db opening (get-root-rid opening) :write)
      (setf (database-header-model-level-version db) 11))))

;;; The caller guarantees that the database's model level version is
;;; currently 11.  Fix up all the indexes and upgrade the version number.
(defun upgrade-to-version-12 (database)
  (note-schema-modified database)
  (let ((opening (database-opening database)))
    (tv:noting-progress ("Upgrading Indexes to Model Level Version 12")
      (let ((i 0)
	    (count (hash-table-count (database-table-of-relations database))))
	(do-relations (relation database)
	  (tv:note-progress i count)
	  (dolist (index (relation-handle-list-of-indexes relation))
	    (let* ((depth (compute-index-depth opening (index-handle-index-identifier index))))
	      (setf (index-handle-index-depth index) depth)
	      (with-record (idx opening (handle-rid index) :write)
		(setf (index-index-depth idx) depth))))
	  (incf i))))
    (setf (database-model-level-version database) 12)
    (with-record (db opening (get-root-rid opening) :write)
      (setf (database-header-model-level-version db) 12))))

;;; The caller guarantees that the database's model level version is
;;; currently 12.  All we have to do is bump the version number as
;;; the only difference between versions 12 and 13 is the use of two
;;; previously unused bits to encode larger key offsets.
(defun upgrade-to-version-13 (database)
  (note-schema-modified database)
  (let ((opening (database-opening database)))
    (setf (database-model-level-version database) 13)
    (with-record (db opening (get-root-rid opening) :write)
      (setf (database-header-model-level-version db) 13))))
