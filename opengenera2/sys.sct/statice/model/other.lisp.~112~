;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice-model; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Other functions in Statice model level.
 
;;; Checking uniqueness of unique attributes The attribute is declared to be
;;; unique, so we have to see whether there's already a tuple with this value.
;;; If there is, signal an error.  If except-rid is provided, it must be the
;;; rid of a tuple handle from the relation, and it means that it's OK if a
;;; duplicate is found as long as it's this tuple.  (If the relation is known
;;; to be surrogate-optimized, it's the rid of the entity handle, of course.)
;;; The caller says the attribute is not indexed on by any index, so we have
;;; to do it the slow way.  The caller guarantees that the relation isn't
;;; "undecided" any more.  The caller also assures us that value is of the
;;; attribute's type, and that the relation is a user relation (so we needn't
;;; worry about Entity-Domain).  The verb argument is for the error message
;;; and should be something like "make" or "set".
(defun check-unique-attribute-value (attribute-handle value verb &optional except-rid)
  (let* ((relation-handle (attribute-handle-relation attribute-handle))
	 (database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (type (attribute-handle-type attribute-handle))
	 (descriptor (attribute-handle-descriptor attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (cond ((null soo-att)
	   ;; This is a normal relation.  Search through the tuples.
	   (map-over-tuple-records
	     relation-handle
	     #'(lambda (tuple-rid)
		 (with-record (tuple opening tuple-rid :read)
		   (let ((tuple-version (tuple-version tuple)))
		     (when (and att-version
				(>= tuple-version att-version)
				(value-equal type tuple descriptor value database))
		       (unless (eql except-rid tuple-rid)
			 (error 'uniqueness-violation
				:relation-handle relation-handle
				:attribute-handle attribute-handle
				:verb verb))))))))
	  ;; special case if checking the soo-att.  Only need to retrieve the entity
	  ;; and check the bit map to see if the relation to which this attribute
	  ;; belongs is opt'd onto this entity.
	  ((eq soo-att attribute-handle)
	   (let* ((ent-rid (handle-rid value))
		  (byte-spec
		    (byte 1 (search-table-for-domain
			      (relation-handle-entity-bit-map-number relation-handle)
			      (find-domain-handle-given-entity-rid ent-rid database)))))
	     (with-record (ent opening ent-rid :read)
	       (when (and (typep value 'known-entity-handle)
			  (= (ldb byte-spec (local-entity-tuples-present ent)) 1))
		 (error 'uniqueness-violation
			:relation-handle relation-handle
			:attribute-handle attribute-handle
			:verb verb)))))
	  (t
	   ;; This is a surrogate-optimized relation.  Search through the entities.
	   ;; If there are no tuples present, then the descriptor will be an
	   ;; empty array.
	   (when (plusp (length descriptor))
	     (let ((soo-domain (attribute-handle-type soo-att)))
	       (do-children (domain-handle soo-domain database)
		 (let ((descriptor (search-table-for-domain descriptor domain-handle
							    :if-not-found nil))
		       (att-version (or (search-table-for-domain att-version domain-handle
							     :if-not-found nil)
					0))
		       (byte-spec
			 (byte 1 (search-table-for-domain
				   (relation-handle-entity-bit-map-number relation-handle)
				   domain-handle))))
		   (map-over-entity-records
		     domain-handle
		     #'(lambda (ent-rid)
			 (with-record (ent opening ent-rid :read)
			   (when (and (= (ldb byte-spec (local-entity-tuples-present ent)) 1)
				      att-version
				      (>= (local-entity-version ent) att-version)
				      (value-equal type ent descriptor value database))
			     (unless (eql except-rid ent-rid)
			       (error 'uniqueness-violation
				      :relation-handle relation-handle
				      :attribute-handle attribute-handle
				      :verb verb))))))))))))))

;;; Add a new bit number entry to the relation's table of bit map numbers (index by
;;; domain.  Update the table in the schema also.  The domain-handle argument
;;; can also have the special value 'entity-domain, for the "%%entity-domain"
;;; system relation.
(defun add-domain-to-bit-table (opening relation-handle domain-handle bit-number)
  ;; add the entry to the relation-handle table
  (let ((new-rid (make-record opening (record-size entity-bit-table-cons)))
	(rel-rid (handle-rid relation-handle))
	(bit-map-table (relation-handle-entity-bit-map-number relation-handle))
	(dh (if (eq domain-handle 'entity-domain) 'any-domain domain-handle)))
    (if bit-map-table
	(vector-push-extend (cons dh bit-number) bit-map-table)
	(setf (relation-handle-entity-bit-map-number relation-handle)
	      (make-array 1
			  :adjustable t
			  :fill-pointer 1
			  :initial-contents (list (cons dh bit-number)))))
    ;; add it to the schema
    (with-record (rel opening rel-rid :write)
      (with-record (new-cons opening new-rid :write)
	(setf (entity-bit-table-cons-domain new-cons)
	      (if (eq domain-handle 'entity-domain) 1 (handle-rid domain-handle)))
	(setf (entity-bit-table-cons-bit-number new-cons) bit-number)
	(setf (entity-bit-table-cons-next new-cons) (relation-entity-bit-map-list rel)))
      (setf (relation-entity-bit-map-list rel) new-rid))))

(defun domain-has-no-subdomains (domain-handle)
  (not (do-domains (d (domain-handle-database domain-handle))
	 (when (member domain-handle (domain-handle-list-of-parent-domains d))
	   (return t)))))

;;; Allocation maps
;;; Make sure that the relation-handle-allocation-map exists for this relation.
(defun get-relation-allocation-map (relation-handle)
  (or (relation-handle-allocation-map relation-handle)
      (let ((am (flavor:make-instance
		  'allocation-map
		  :start-word (record-size tuple)
		  :versions (relation-handle-next-layout-version relation-handle))))
	(dolist (att (relation-handle-list-of-attributes relation-handle))
	  (let ((version (attribute-handle-layout-version att))
		(descriptor (attribute-handle-descriptor att)))
	    ;; If version is null, this attribute hasn't been laid out yet.
	    (when version
	      (allocate-existing-attribute am att descriptor version))))
	(setf (relation-handle-allocation-map relation-handle) am))))

;;; Make sure that the domain-handle-allocation-map exists for this domain.
(defun get-domain-allocation-map (domain-handle)
  (or (domain-handle-allocation-map domain-handle)
      (let ((am (flavor:make-instance
		  'allocation-map
		  :start-word (record-size local-entity)
		  :versions (domain-handle-next-layout-version domain-handle))))
	;; Find every attribute of every relation that is soo-opt'ed onto this
	;; domain, except the soo-att of such relations.
	(dolist (rel (domain-handle-relations-optimized-on domain-handle))
	  (let ((soo-att (relation-handle-surrogate-optimized-on rel)))
	    (dolist (att (relation-handle-list-of-attributes rel))
	      (unless (eq att soo-att)
		(when (attribute-handle-layout-version att)
		  ;; When there is no table, no attribute has been laid out yet.
		  (let ((version (search-table-for-domain
				   (attribute-handle-layout-version att) domain-handle
				   :if-not-found nil))
			(descriptor (search-table-for-domain
				      (attribute-handle-descriptor att) domain-handle
				      :if-not-found nil)))
		    (when version
		      ;; If version is null, this attribute hasn't been laid out yet.
		      (allocate-existing-attribute am att descriptor version))))))))
	;; Find all group indexes that have been defined on a type that is this
	;; domain, or a parent of this domain.
	(dolist (att (domain-handle-group-indexed-attributes domain-handle))
	  (allocate-existing-group-index am att domain-handle))
	(setf (domain-handle-allocation-map domain-handle) am))))


;;; While building an allocation map from the schema cache.  Take this
;;; attribute-handle and mark the space its value uses up as "allocated".
;;; descriptor and version are taken from attribute-handle.
;;; +++ The various ways of allocating things should all share code.  Things
;;; are very precarious right now.  --Feinberg 2/7/89
(scl:defmethod (allocate-existing-attribute allocation-map) (attribute-handle descriptor version)
  (multiple-value-bind (n-total-bits alignment)
      (fixed-space (attribute-handle-type attribute-handle))
    (multiple-value-bind (n-words n-bits)
	(floor n-total-bits 32)
      (let ((end-word-of-att
	      ;; Return the word-offset of the end of the space used by this
	      ;; att, that is, the highest word not used by this att.
	      (cond ((and (zerop n-bits) (zerop alignment))
		     ;; Handle the common case first.  It takes an integer number of
		     ;; words and is word-aligned.
		     (+ descriptor n-words))
		    (t
		     ;; General case.
		     (let ((word-offset (desc-word-offset descriptor))
			   (bit-offset (desc-bit-offset descriptor)))
		       ;; Note: During the following, if an entry in the gap-table is
		       ;; nil, that can either mean that the word is all free or that
		       ;; it is all allocated.  This seems ambiguous but it actually
		       ;; doesn't cause any problems.  By the time we're done, it will
		       ;; always mean that the word is all allocated.
		       (flet ((allocate-byte (wordo start end)
				;; Mark a byte (contig bit field) as allocated.
				(when (plusp n-bits)
				  (let ((runs (gethash wordo gap-table)))
				    (cond ((null runs)
					   ;; The whole word is free.
					   (setq runs (allocate-byte-from-word start end)))
					  (t
					   ;; Because the stored database is assumed to
					   ;; be consistent, we know that the byte is
					   ;; contained in exactly one run.  Find it.
					   (dolist (run runs)
					     (when (and (>= start (run-start run))
							(<= end (run-end run)))
					       (setq runs
						     (allocate-byte-from-run
						       start end run runs))
					       (return nil)))))
				    #|| (when *debug* (dbg:dbg)) ||#
				    (setf (gethash wordo gap-table) runs)))))
			 ;; Update end-word.  What's the highest word used?
			 (let* ((last-bit-n (+ n-total-bits bit-offset))
				;;Used to be (ceiling last-bit-n 32), but I can't
				;;see how that could be right.  --Feinberg 2/1/89
				(last-word-offset (+ word-offset (floor last-bit-n 32))))
			   (cond ((= word-offset last-word-offset)
				  ;; A byte field within one word.
				  (allocate-byte word-offset bit-offset (+ bit-offset n-bits)))
				 (t
				  ;; The allocated region crosses a word boundary.
				  (allocate-byte word-offset bit-offset 32)
				  (allocate-byte last-word-offset 0 (mod last-bit-n 32))))
			   ;;The end-word instance variable points to the next free, not
			   ;;the last used, thus this is (1+ last-word-offset), not
			   ;;word-offset.  --Feinberg 11/28/89
			   (1+ last-word-offset))))))))	
	(setq end-word (max end-word-of-att end-word))
	(loop for v from version below (fill-pointer end-word-by-version) do
	  (setf (aref end-word-by-version v)
		(max end-word-of-att (aref end-word-by-version v))))))))


;;; Allocate the range specified by start and end, out of the free space
;;; described by run.  Returns the possibly-modified runs list, which the
;;; caller must put back where it came from.  The caller guarantees that
;;; the range is entirely within the run.
(defun allocate-byte-from-run (start end run runs)
  (let ((r-start (run-start run))
	(r-end (run-end run)))
    (cond ((= start r-start)
	   (cond ((= end r-end)
		  ;; The byte uses up the entire run.
		  (setq runs (delete run runs)))
		 (t
		  ;; The byte is at the low end of the run.
		  (setf (run-start run) end))))
	  (t
	   (cond ((= end r-end)
		  ;; The byte is at the high end of the run.
		  (setf (run-end run) start))
		 (t
		  ;; The byte is in the middle of the run.
		  (setf (run-end run) start)
		  (push (make-run :start end :end r-end) runs))))))
  runs)

;;; Allocate the range specified by start and end from an empty word.
;;; Return a list of runs describing the free space left in the word.
(defun allocate-byte-from-word (start end)
  (let ((runs nil))
    (flet ((add-run (r-start r-end)
	     (cl:push (make-run :start r-start :end r-end)
		   runs)))
      (cond ((zerop start)
	     (cond ((= end 32)
		    ;; The range uses up the whole word.  Do nothing.
		    )
		   (t
		    ;; The range is at the low end of the word.
		    (add-run end 32))))
	    (t
	     (cond ((= end 32)
		    ;; The range is at the high end of the word.
		    (add-run 0 start))
		   (t
		    ;; The range is in the middle of the word.
		    (add-run 0 start)
		    (add-run end 32))))))
    runs))

;;; We are building an allocation map from the schema cache.  Take this
;;; attribute-handle and mark the space its group index uses up as "allocated".
(scl:defmethod (allocate-existing-group-index allocation-map) (attribute-handle domain-handle)
  (let ((gio (attribute-handle-group-index-offset attribute-handle)))
    ;; If gio is nil or t, there isn't any group index here.
    (unless (symbolp gio)
      (let ((offset (search-table-for-domain gio domain-handle :if-not-found nil))
	    (version (search-table-for-domain
		       (attribute-handle-group-index-layout-version attribute-handle)
		       domain-handle :if-not-found nil)))
	;; If offset is zero, there isn't any group index here.
	(when offset
	  (setq offset (1+ offset))
	  (setq end-word (max offset end-word))
	  (loop for v from version below (fill-pointer end-word-by-version) do
	    (setf (aref end-word-by-version v) (max offset (aref end-word-by-version v)))))))))

;;; Allocate new space in the layout of this kind of record for an attribute
;;; of the given type.  Update the allocation map, and return a descriptor
;;; word pointing to the location of the fixed space.
(scl:defmethod (allocate-fixed-area allocation-map) (type)
  (multiple-value-bind (n-total-bits alignment)
      (fixed-space type)
    (multiple-value-bind (n-words n-bits)
	(floor n-total-bits 32)
      (cond ((and (zerop n-bits) (zerop alignment))
	     ;; Handle the common case first.  It needs an integer number of
	     ;; words and is word-aligned.
	     (let ((desc end-word))
	       (incf end-word n-words)
	       desc))
	    (t
	     ;; Compute the total number of bits.
	     (or (and (< n-total-bits 32)
		      (allocate-fixed-area-within-run self n-total-bits alignment))
		 (allocate-fixed-area-at-end self n-total-bits alignment)))))))

;;; Allocate one word in the layout of this kind of record.  Update the
;;; allocation map, and return the location of the word, relative to the
;;; beginning of the record.
(scl:defmethod (allocate-one-word allocation-map) ()
  (prog1 end-word (incf end-word)))

;;; Allocate a range of size tbits, on the given alignment, where tbits < 32.
;;; Try to find a run of free bits within the existing free area and take the
;;; space from there.  Update the allocation map, and return a descriptor
;;; word pointing to the location of the fixed space.  Return NIL if there's
;;; no suitable run.
(scl:defmethod (allocate-fixed-area-within-run allocation-map) (tbits alignment)
  (cl:loop for runs being the hash-elements of gap-table
		 with-key word-offset do
    (dolist (run runs)
      ;; Examine every run of free space in every word of the fixed area
      ;; that has such runs.
      (let* ((start (* alignment (ceiling (run-start run) alignment)))
	     (end (+ start tbits)))
	(when ( end (run-end run))
	  ;; It fits into this run.
	  (setf (cl:gethash word-offset gap-table)
		(allocate-byte-from-run start end run runs))
	  (return-from allocate-fixed-area-within-run
	    (make-desc :bit-offset start :word-offset word-offset))))))
  nil)


;;; Allocate a range of size tbits, on the given alignment, at the end of the
;;; existing fixed space, expanding the fixed space if necessary.  tbits can
;;; be any value.  Update the allocation map, and return a descriptor word
;;; pointing to the location of the fixed space.
;;; +++ The various ways of allocating things should all share code.  Things
;;; are very precarious right now.  --Feinberg 2/7/89
(scl:defmethod (allocate-fixed-area-at-end allocation-map) (tbits alignment)
  (flet ((extend-n-bits (nbits)
	   ;; Extend the fixed area so that it can hold nbits, and update the
	   ;; allocation map accordingly.
	   (multiple-value-bind (nwords nbits)
	       (floor nbits 32)
	     (incf end-word nwords)
	     (when (plusp nbits)
	       #|| (when *debug* (dbg:dbg)) ||#
	       (setf (gethash end-word gap-table)
		     (allocate-byte-from-word 0 nbits))
	       (incf end-word)))))
    ;; First, see if there is space at the end of the last word of
    ;; the fixed area, and see if we can start our field in that run.
    (let* ((lastw (1- end-word))
	   (lastw-runs (cl:gethash lastw gap-table))
	   (end-run (dolist (run lastw-runs)
		      (when (= (run-end run) 32)
			(return run)))))
      ;; If there is free space at the end of the last word,
      ;; then end-run says where it starts.
      (when end-run
	(let ((start (* alignment (ceiling (run-start end-run) alignment))))
	  ;;This used to be (< start 32), which can't possibly be right.
	  ;;--Feinberg 2/7/89
	  (when (< (+ start tbits) 32)
	    #|| (when *debug* (dbg:dbg)) ||#
	    (cl:setf (cl:gethash lastw gap-table)
		  ;;This used to be (a-b-f-r start 32 end-run lastw-runs), which
		  ;;would always allocate to the end of the word, even if that
		  ;;wasn't necessary.  Changed 32 to (+ start tbits).  --Feinberg 2/7/89
		  (allocate-byte-from-run start (+ start tbits) end-run lastw-runs))
	    (extend-n-bits (- tbits (- 32 start)))
	    (return-from allocate-fixed-area-at-end
	      (make-desc :word-offset lastw :bit-offset start))))))
    ;; Second, if there's no space there, just extend the fixed area.
    (let ((wordo end-word))
      (extend-n-bits tbits)
      (make-desc :word-offset wordo :bit-offset 0))))


;;; Given a version number, return the end-word value for that version.
(scl:defmethod (fixed-space-for-version allocation-map) (version)
  (unless (and ( version 0) (< version (zl:array-length end-word-by-version)))
    (model-bug "There is no such version as ~D" end-word-by-version))
  (aref end-word-by-version version))

;;; Assign a new version number, with the current state of allocation.
(scl:defmethod (set-new-version allocation-map) ()
  (vector-push-extend end-word end-word-by-version))

;;; Compute a new layout for a normal relation that needs a new layout.
(defun compute-new-relation-layout (relation-handle)
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (version (relation-handle-next-layout-version relation-handle))
	 (am (get-relation-allocation-map relation-handle)))
    (dolist (attribute-handle (relation-handle-list-of-attributes relation-handle))
      (unless (attribute-handle-layout-version attribute-handle)
	;; A new attribute.  Allocate its fixed storage and store the descriptor.
	(let ((descriptor (allocate-fixed-area am (attribute-handle-type attribute-handle))))
	  (setf (attribute-handle-descriptor attribute-handle) descriptor)
	  (setf (attribute-handle-layout-version attribute-handle) version)
	  (with-record (att opening (handle-rid attribute-handle) :write)
	    (setf (attribute-descriptor att) descriptor)
	    (setf (attribute-layout-version att) version)))))
    (setf (relation-handle-next-layout-version relation-handle) (1+ version))
    (setf (relation-handle-new-layout-needed relation-handle) nil)
    (with-record (rel opening (handle-rid relation-handle) :write)
      (note-schema-modified database)
      (setf (relation-next-layout-version rel) (1+ version))
      (setf (relation-new-layout-needed rel) 0))
    (set-new-version am)))

;;; Compute a new layout for a single domain.
(defun compute-new-domain-layout-internal (domain-handle database)
  (let ((opening (database-opening database))
	(version (domain-handle-next-layout-version domain-handle))
	(am (get-domain-allocation-map domain-handle)))
    (dolist (relation-handle (domain-handle-relations-optimized-on domain-handle))
      (let ((soo-att (relation-handle-surrogate-optimized-on relation-handle)))
	(dolist (attribute-handle (relation-handle-list-of-attributes relation-handle))
	  (unless (eq attribute-handle soo-att)
	    (let ((null-av (null (attribute-handle-layout-version attribute-handle))))
	      (when null-av
		(setf (attribute-handle-layout-version attribute-handle)
		      (make-array 0 :fill-pointer 0)))
	      (unless (attribute-handle-descriptor attribute-handle)
		(setf (attribute-handle-descriptor attribute-handle)
		      (make-array 0 :fill-pointer 0)))
	      (when (or null-av
			(null (search-table-for-domain
				 (attribute-handle-descriptor attribute-handle)
				 domain-handle :if-not-found nil)))
		;; A new attribute, or an attribute which hasn't yet been given a location
		;; for this domain.  Allocate its fixed storage and store the descriptor.
		(let ((descriptor (allocate-fixed-area
				    am (attribute-handle-type attribute-handle))))
		  (vector-push-extend (cons domain-handle descriptor)
				      (attribute-handle-descriptor attribute-handle))
		  (vector-push-extend (cons domain-handle version)
				      (attribute-handle-layout-version attribute-handle))
		  ;; Need to create a new attribute-desc-and-layout-cons
		  ;; for this new descriptor, and plug it into the list.
		  (let ((new-desc-cons-rid (make-record
					     opening
					     (record-size attribute-desc-and-layout-cons)))
			(domain-rid (handle-rid domain-handle)))
		    (with-record (att opening (handle-rid attribute-handle) :write)
		      (with-record (nc opening new-desc-cons-rid :write)
			(setf (attribute-desc-and-layout-cons-domain nc) domain-rid)
			(setf (attribute-desc-and-layout-cons-descriptor nc) descriptor)
			(setf (attribute-desc-and-layout-cons-next nc)
			      (attribute-descriptor att))
			(setf (attribute-desc-and-layout-cons-layout-version nc) version))
		      (setf (attribute-descriptor att) new-desc-cons-rid))))))))))
    (dolist (attribute-handle (domain-handle-group-indexed-attributes domain-handle))
      (when (eq (attribute-handle-group-index-offset attribute-handle) t)
	;; A new group index has been created since the last layout.
	(setf (attribute-handle-group-index-offset attribute-handle)
	      (make-array 0 :fill-pointer 0))
	(setf (attribute-handle-group-index-layout-version attribute-handle)
	      (make-array 0 :fill-pointer 0)))
      (let ((gio (attribute-handle-group-index-offset attribute-handle))
	    (gilv (attribute-handle-group-index-layout-version attribute-handle)))
	(unless (search-table-for-domain gio domain-handle :if-not-found nil)
	  ;; This domain is not present in the table.  Add it.
	  (let ((offset (allocate-one-word am)))
	    (vector-push-extend (cons domain-handle offset) gio)
	    (vector-push-extend (cons domain-handle version) gilv)
	    (with-record (att opening (handle-rid attribute-handle) :write)
	      (let ((new-cons-rid (make-record
				    opening
				    (record-size attribute-group-index-info-cons))))
		(with-record (nc opening new-cons-rid :write)
		  (setf (attribute-group-index-info-cons-domain nc)
			(handle-rid domain-handle))
		  (setf (attribute-group-index-info-cons-offset nc) offset)
		  (setf (attribute-group-index-info-cons-next nc)
			(attribute-group-index-offset att))
		  (setf (attribute-group-index-info-cons-layout-version nc) version))
		(setf (attribute-group-index-offset att) new-cons-rid))
	      (setf (attribute-group-index-average-size att)
		    (attribute-handle-group-index-average-size attribute-handle)))))))
    (setf (domain-handle-next-layout-version domain-handle) (1+ version))
    (setf (domain-handle-new-layout-needed domain-handle) nil)
    (with-record (dom opening (handle-rid domain-handle) :write)
      (note-schema-modified database)
      (setf (domain-next-layout-version dom) (1+ version))
      (setf (domain-new-layout-needed dom) 0))
    (set-new-version am)))

(defun child-of-p (domain child)
  (or (eq domain child)
      (loop for d in (domain-handle-list-of-parent-domains child)
	    thereis (child-of-p domain d))))

;;; A domain needs a new layout, so do it and all its children.
(defun compute-new-domain-layout (domain-handle)
  (let ((database (domain-handle-database domain-handle)))
    (do-children (d domain-handle database)
      (when (domain-handle-new-layout-needed d)
	(compute-new-domain-layout-internal d database)))))

;;; Upgrading tuple and entity records to the latest layout.

;;; The caller guarantees that no new layout is needed; that is, the
;;; caller is required to compute a new layout, if one is needed, before
;;; calling this function.  tuple must be in :write mode.
(defun upgrade-tuple (tuple relation-handle)
  (let ((relation-version (1- (relation-handle-next-layout-version relation-handle)))
	(tuple-version (tuple-version tuple)))
    (when (> relation-version tuple-version)
      ;; The tuple record needs to be enlarged.  Allocate new
      ;; fixed words, and initialize their values to the null value.
      (let* ((am (get-relation-allocation-map relation-handle))
	     (existing-fixed-space (fixed-space-for-version am tuple-version))
	     (new-fixed-space (fixed-space-for-version am relation-version))
	     (added-fixed-space (- new-fixed-space existing-fixed-space)))
	;; Take all the variable storage, slide it down by added-fixed-space
	;; from where it used to be, and adjust the contents of the existing
	;; fixed words to point the new location of their associated variable
	;; words.  Set all the values of the new attributes to the null value.
	(adjust-record-size tuple added-fixed-space)
	(open-gap tuple existing-fixed-space added-fixed-space)
	(dolist (a (relation-handle-list-of-attributes relation-handle))
	  (let ((type (attribute-handle-type a))
		(descriptor (attribute-handle-descriptor a)))
	    (if (let ((ver (attribute-handle-layout-version a)))
		  (and ver (<= ver tuple-version)))
		(adjust-variable-words type tuple descriptor added-fixed-space)
		(write-value type *null-value* tuple descriptor nil nil nil 0)))))
      (setf (tuple-version tuple) relation-version))))

;;; The caller guarantees that no new layout is needed; that is, the
;;; caller is required to compute a new layout, if one is needed, before
;;; calling this function.  ent is a local-entity-handle.  The caller is
;;; required to make sure that at least one bit of tuples-present
;;; ends up set to one, before it returns to its own caller.  ent must be
;;; in :write mode.  Domain-handle is the domain of the entity.
(defun upgrade-entity (ent domain-handle)
  (let* ((domain-version (1- (domain-handle-next-layout-version domain-handle)))
	 (gia (domain-handle-group-indexed-attributes domain-handle))
	 (ent-version (local-entity-version ent))
	 (tuples-present (local-entity-tuples-present ent)))
    (when (> domain-version ent-version)
      ;; The entity record needs to be enlarged.  For each attribute in
      ;; each relation which is opt'd onto this entity, allocate new
      ;; fixed words, and initialize their values to the null value.
      (let* ((am (get-domain-allocation-map domain-handle))
	     (existing-fixed-space (fixed-space-for-version am ent-version))
	     (new-fixed-space (fixed-space-for-version am domain-version))
	     (added-fixed-space (- new-fixed-space existing-fixed-space)))
	;; Take all the variable storage, slide it down by added-fixed-space
	;; from where it used to be, and adjust the contents of the existing
	;; fixed words to point the new location of their associated variable
	;; words. Set all the values of the new attributes to the null value.
	(adjust-record-size ent added-fixed-space)
	(open-gap ent existing-fixed-space added-fixed-space)
	(dolist (r (domain-handle-relations-optimized-on domain-handle))
	  (let ((soo-att (relation-handle-surrogate-optimized-on r))
		(bit-number
		  (search-table-for-domain (relation-handle-entity-bit-map-number r)
					   domain-handle)))
	    (when (= 1 (ldb (byte 1 bit-number) tuples-present))
	      (dolist (a (relation-handle-list-of-attributes r))
		(unless (eq a soo-att)
		  (let ((type (attribute-handle-type a))
			(descriptor (search-table-for-domain (attribute-handle-descriptor a)
							     domain-handle)))
		    (if (let ((ver
				(search-table-for-domain (attribute-handle-layout-version a)
							 domain-handle :if-not-found nil)))
			       ver (<= ver ent-version))
			(adjust-variable-words type ent descriptor added-fixed-space)
			(write-value type *null-value* ent descriptor nil nil nil 0))))))))
	;; Set all the group-index-offset slots to zero, meaning no index yet.
	(dolist (a gia)
	  (unless (let ((ver (search-table-for-domain
			       (attribute-handle-group-index-layout-version a)
			       domain-handle)))
		    (and ver (<= ver ent-version)))
	    (setf (read-record-word ent (search-table-for-domain
					  (attribute-handle-group-index-offset a)
					  domain-handle)) 0))))
      (setf (local-entity-version ent) domain-version))))

;;; find-entity-record-in-database (a.k.a. import-entity)

;;; Given an entity-handle, search in the database for an entity record
;;; whose UID matches that of the specified entity.  If found, return
;;; its RID.  If not found, and :create is false, return NIL.  If not
;;; found, and :create is true, create a foreign entity record in the
;;; database, and return its RID.  Return a second value, which is T iff
;;; database is the home database of this entity.  If the second value
;;; is NIL, and the first value is non-NIL, then the first value is the
;;; RID of a foreign entity record.
(defun find-entity-record-in-database (entity-handle database &key create)
  (declare (values rid home-database-p))
  (check-entity-handle entity-handle)
  (let ((rid (handle-rid entity-handle))
	(opening (database-opening database)))
    ;; If rid is non-nil, this is a known entity handle.
    (cond ((and rid (eq database (domain-handle-database
				   (known-entity-handle-domain entity-handle))))
	   ;; This is the home database, so return the rid and t.
	   (values rid t))
	  (t
	   ;; At this point, either the entity handle is a known entity
	   ;; handle but the database we're looking for is not its home,
	   ;; or the entity handle is unknown.  Therefore, we know the
	   ;; entity must be foreign, or non-existent.
	   (let ((uid-word-1 (entity-handle-uid-word-1 entity-handle))
		 (uid-word-2 (entity-handle-uid-word-2 entity-handle))
		 (uid-word-3 (entity-handle-uid-word-3 entity-handle)))
	     ;; Search the list of foreign entities.
	     (loop with fe-rid = (with-record
				   (seg opening (database-rid-of-header database) :read)
				   (database-header-list-of-foreign-entities seg))
		   until (zerop fe-rid) do
	       (with-record (fent opening fe-rid :read)
		 (when (and (= uid-word-1 (entity-uid-word-1 fent))
			    (= uid-word-2 (entity-uid-word-2 fent))
			    (= uid-word-3 (entity-uid-word-3 fent)))
		   ;; Found the foreign entity record.  Return its RID,
		   ;; and nil as the second value.
		   (return fe-rid))
		 (setq fe-rid (foreign-entity-next fent)))
	       finally
		 (when create
		   ;; The entity does not exist in the database, and the
		   ;; caller asked for creation, so create a new foreign
		   ;; entity in the database and return the rid and nil.
		   (return (make-foreign-entity entity-handle uid-word-1 uid-word-2 uid-word-3
						database opening)))))))))

;;; Make a foreign entity record in the given database for
;;; entity-handle, which refers to an entity whose home database is not
;;; the given database.  The entity might be known or unknown.  Return
;;; the RID of the new foreign entity record.
(defun make-foreign-entity (entity-handle uid-word-1 uid-word-2 uid-word-3 database opening)
  (let ((fe-rid (make-record opening (record-size foreign-entity))))
    (with-record (fent opening fe-rid :write)
      ;; Link the foreign-entity into the database header's list.
      (with-record (seg opening (database-rid-of-header database) :write)
	(let ((head-rid (database-header-list-of-foreign-entities seg)))
	  (unless (zerop head-rid)
	    (with-record (head opening head-rid :write)
	      (setf (foreign-entity-previous head) fe-rid))))
	(setf (foreign-entity-next fent)
	      (database-header-list-of-foreign-entities seg))
	(setf (database-header-list-of-foreign-entities seg) fe-rid)
	(setf (foreign-entity-previous fent) 0)
	;; Store the UID.
	(setf (entity-uid-word-1 fent) uid-word-1)
	(setf (entity-uid-word-2 fent) uid-word-2)
	(setf (entity-uid-word-3 fent) uid-word-3)
	;; Mark the entity record as unknown.
	(setf (entity-domain fent) 0)
	(setf (foreign-entity-foreign-database fent)
	      (multiple-value-bind (fdw1 fdw2 fdw3)
		  (entity-handle-db-uid entity-handle)
		(loop with fd-rid = (database-header-list-of-foreign-databases seg)
		      until (zerop fd-rid) do
		  (with-record (fd opening fd-rid :write) ;;Used to be possible-write
			       ;;which is totally bogus.  Probably meant probable-write
			       ;;except even probable-write is broken.
		    (when (and (= fdw1 (foreign-database-uid-word-1 fd))
			       (= fdw2 (foreign-database-uid-word-2 fd))
			       (= fdw3 (foreign-database-uid-word-3 fd)))
		      ;; Found.  Increment the reference count and return.
		      (upgrade-record-mode fd :write)
		      (incf (foreign-database-reference-count fd))
		      (return fd-rid)))
		  finally
		    ;; Not found.  Create a new foreign database record.
		    (let ((fd-rid (make-record opening (record-size foreign-database))))
		      (with-record (fd opening fd-rid :write)
			(setf (foreign-database-mabz fd) 0)
			(setf (foreign-database-uid-word-1 fd) fdw1)
			(setf (foreign-database-uid-word-2 fd) fdw2)
			(setf (foreign-database-uid-word-3 fd) fdw3)
			(setf (foreign-database-reference-count fd) 1)
			(setf (foreign-database-next fd)
			      (database-header-list-of-foreign-databases seg))
			(setf (database-header-list-of-foreign-databases seg) fd-rid)
			(setf (foreign-database-previous fd) 0))
		      (return fd-rid)))))))
    fe-rid))

(defgeneric entity-handle-db-uid (entity-handle)
  (declare (values uid-word-1 uid-word-2 uid-word-3)))

(defmethod entity-handle-db-uid ((handle unknown-entity-handle))
  (with-slots (db-uid-word-1 db-uid-word-2 db-uid-word-3) handle
    (values db-uid-word-1 db-uid-word-2 db-uid-word-3)))

(defmethod entity-handle-db-uid ((handle known-entity-handle))
  (with-slots (domain) handle
    (let ((db (domain-handle-database domain)))
      (values (database-uid-1 db) (database-uid-2 db) (database-uid-3 db)))))

;;; Make keys for B-tree indexes.

;;; Make a key out of the values of the attributes in the index's
;;; attribute list, found in the record specified by addressor.  Returns
;;; a single art-fixnum array on the data stack that has the bytes
;;; stored within it, from element 0 upward, with the first byte in the
;;; most significant position of its fixnum.  Furthermore, the
;;; high-order bit of each word is complemented, so that signed
;;; comparison functions can be used to compare two such arrays
;;; word-by-word and get the effect of an unsigned byte-by-byte
;;; comparison.  The length of the array says how many words of the
;;; array are being used.  Since the array is on the data stack, the
;;; caller should do a sys:with-data-stack.  If the relation is
;;; surrogate-optimized, then soo-att is the attribute and entity-handle
;;; is the value of that attribute for this tuple.
;;; Return a second value that's true if any of the indexed value was
;;; a null value.
(defun make-key-from-record (index-handle addressor version soo-att entity-handle database)
  (declare (values key any-null-p))
  (let* ((atts (index-handle-list-of-attributes index-handle))
	 (last-att (car (last atts)))
	 (case-sensitive (index-handle-case-sensitive index-handle))
	 (any-null-p nil)
	 (n-bytes (loop for a in atts
			summing (cond ((eq a soo-att)
				       (size-of-key-from-value (attribute-handle-type a)
							       entity-handle
							       (eq a last-att)
							       case-sensitive))
				      ((let ((att-version
					       (if soo-att
						   (search-table-for-domain
						     (attribute-handle-layout-version a)
						     (known-entity-handle-domain
						       entity-handle)
						     :if-not-found nil)
						   (attribute-handle-layout-version a))))
					 (or (null att-version)
					     (< version att-version)))
				       (setq any-null-p t)
				       (size-of-key-from-value (attribute-handle-type a)
							       *null-value*
							       (eq a last-att)
							       case-sensitive))
				      (t
				       (let ((type (attribute-handle-type a))
					     (descriptor
					       (if soo-att
						   (search-table-for-domain
						     (attribute-handle-descriptor a)
						     (known-entity-handle-domain
						       entity-handle))
						   (attribute-handle-descriptor a))))
					 (when (value-null-p type addressor descriptor)
					   (setq any-null-p t))
					 (size-of-key-from-record
					   type
					   addressor
					   descriptor
					   (eq a last-att)
					   case-sensitive))))))
	 (n-words (ceiling n-bytes 4))
	 (array (make-stack-vector n-words))
	 (offset 0))
    (dolist (a atts)
      (let ((att-type (attribute-handle-type a)))
      (setq offset
	    (cond ((eq a soo-att)
		   (write-key-from-value att-type
					 entity-handle
					 array
					 offset
					 database
					 (eq a last-att)
					 case-sensitive))
		  ((let ((att-version
			   (if soo-att
			       (search-table-for-domain
				 (attribute-handle-layout-version a)
				 (known-entity-handle-domain
				   entity-handle)
				 :if-not-found nil)
			       (attribute-handle-layout-version a))))
		     (or (null att-version)
			 (< version att-version)
			 (value-null-p att-type
				       addressor
				       (if soo-att
					   (search-table-for-domain
					     (attribute-handle-descriptor a)
					     (known-entity-handle-domain entity-handle))
					   (attribute-handle-descriptor a)))))
		   (write-key-from-value att-type
					 *null-value*
					 array
					 offset
					 database
					 (eq a last-att)
					 case-sensitive))
		  (t
		   (write-key-from-record att-type
					  addressor
					  (if soo-att
					      (search-table-for-domain
						(attribute-handle-descriptor a)
						(known-entity-handle-domain entity-handle))
					      (attribute-handle-descriptor a))
					  array
					  offset
					  database
					  (eq a last-att)
					  case-sensitive))))))
    (dotimes (i n-words)
      (setf (aref array i)
	    (zl:%32-bit-plus (aref array i) #.(si:lsh 1 31.))))
    (values array any-null-p)))

;;; The ORDER of attributes-and-values MUST be the same as the ordering
;;; of the attributes in index-handle-attribute-list!
;;; [If that turns out to be a bad idea, we could pass in index-handle
;;; as an argument, and have this code search through attributes-and-values
;;; to get the ones it wants, in order.]
;;; The caller insures that none of the values are null values.
(defun make-key-from-values (database index-handle &rest attributes-and-values)
  (declare (values array last-offset))
  (let* ((last-att (car (nthcdr (- (length attributes-and-values) 2) attributes-and-values)))
	 (case-sensitive (index-handle-case-sensitive index-handle))
	 (n-bytes
	   (loop for (a v) on attributes-and-values by #'cddr
		 summing (size-of-key-from-value (attribute-handle-type a)
						 v
						 (eq a last-att)
						 case-sensitive)))
	 (n-words (ceiling n-bytes 4))
	 (array (make-stack-vector n-words))
	 (offset 0))
    (loop for (a v) on attributes-and-values by #'cddr do
      (setq offset (write-key-from-value (attribute-handle-type a)
					 v
					 array
					 offset
					 database
					 (eq a last-att)
					 case-sensitive)))
    (cl:dotimes (i n-words)
      (cl:setf (aref array i)
	    (zl:%32-bit-plus (aref array i) #.(si:lsh 1 31.))))
    (values array offset)))

;;; Given a list of attributes and values, return the array which represents the
;;; next highest key.
(defun make-next-key-from-values (database index-handle &rest attributes-and-values)
  (loop with as = (copy-list-simply attributes-and-values)
	while as do
    (let* ((last-att-val-pair (nthcdr (- (length as) 2) as))
	   (next (next-value (attribute-handle-type (first last-att-val-pair))
			     (second last-att-val-pair))))
      (when next
	(return (apply #'make-key-from-values
		       database
		       index-handle
		       (nconc (nbutlast as)
			      (list next)))))
      ;; that was already the highest.  Drop back a single att/val pair.
      (setq as (nbutlast as 2)))
	finally
	  ;; No value was found which could be "one-plussed".  Just add one to the
	  ;; last element of the array.
	  (return (multiple-value-bind (low-key next-offset)
		      (apply #'make-key-from-values
			     database index-handle attributes-and-values)
		    (declare (sys:array-register low-key))
		    (loop for i from (1- next-offset) by -1
			  as byte = (get-byte low-key i)
			  when (not (= byte 255))
			    do (store-byte low-key i (1+ byte))
			       (return low-key))))))

;;; Note that the byte order is the opposite of sys:octet-aref-8
(defsubst get-byte (array offset)
  (multiple-value-bind (word-offset byte-number)
      (floor offset 4)
    (let ((word (aref array word-offset)))
      (case byte-number
	(0 (zl:%logldb (byte 8 24) word))
	(1 (zl:%logldb (byte 8 16) word))
	(2 (zl:%logldb (byte 8 08) word))
	(3 (zl:%logldb (byte 8 00) word))))))

(defun store-byte (array offset byte)
  (multiple-value-bind (word-offset byte-number)
      (floor offset 4)
    (cl:setf (aref array word-offset)
	  (case byte-number
	    (0 (zl:%logdpb byte (byte 8 24) 0))		; Leftmost byte.  Zero new word.
	    (1 (zl:%logdpb byte (byte 8 16) (aref array word-offset)))
	    (2 (zl:%logdpb byte (byte 8 08) (aref array word-offset)))
	    (3 (zl:%logdpb byte (byte 8 00) (aref array word-offset)))))))

;;; Type-specific methods for making keys.

;;; If it is possible to construct a b-tree index on elements of this
;;; type, this function should return T, otherwise NIL.  If the value is
;;; T, then the handler must provide methods for size-of-key-from-record,
;;; size-of-key-from-value, write-key-from-record, write-key-from-value,
;;; and next-value.  If you don't supply a method, the default is NIL.
(defgeneric indexable-p (type)
  (:method ((handler storage-handler)) nil))

;;; In each of the next four generics, last-p indicates if the function
;;; is being called on behalf of the last attribute in the index.  This
;;; allows certain optimizations to be made in shrinking the size of the
;;; resulting index entry.

;;; Read the value from the addressed record, according to the
;;; descriptor, and return the size in bytes of the key for that value.
;;; The value is guaranteed not to be null.
(defgeneric size-of-key-from-record (type addressor descriptor last-p case-sensitive))

;;; Return the size in bytes of the key for this Lisp value.
;;; The value is guaranteed not to be null.
(defgeneric size-of-key-from-value (type value last-p case-sensitive))

;;; Read the value from the addressed record, according to the
;;; descriptor, and write the bytes of the key into array, starting at
;;; offset.  array is the fixnum array into which the key is being
;;; built.  offset is the offset into that array, in bytes, of the first
;;; free byte, into which the first byte of the key of the value should
;;; be put.  Return the updated value of the offset argument, for the
;;; next write-key-from-record.  The write-key-from-record method is
;;; required to insure that any remaining bytes at the end of the last
;;; utilized word of the array are zero.  The value may be the null
;;; value.  The descriptions of how the null value is represented is
;;; given with each method.  The null value is always greater than any
;;; other value.
(defgeneric write-key-from-record
	    (type addressor descriptor array offset database last-p case-sensitive))

;;; Encode the given Lisp value, and write the bytes of the key into
;;; array, starting at offset.  Otherwise it's the same as
;;; write-key-from-record.  The value may be the null value.
(defgeneric write-key-from-value (type value array offset database last-p case-sensitive))

;;; Return the next highest value.  Used for scanning an index between
;;; two values.  Return nil if the value is already the highest allowed
;;; for the type.
(defgeneric next-value (type value))

;;; Integers are encoded by storing first the sign bit, then the length
;;; of the integer in bytes, and then the bytes of the integer starting
;;; with the highest order byte.  In greater detail: the high bit of the
;;; first byte always holds the sign of the number, inverted, such that
;;; a one means a positive number and a zero means a negative number.
;;; The rest of the bytes encode the absolute value of the integer,
;;; which I'll just call "the integer" for short.  There are two
;;; different formats, depending on whether the integer is "small" or
;;; "large".  A "small" integer is one whose representation, not
;;; counting this initial control byte, can fit in fewer than #o176
;;; bytes.  If the integer is "small", the length of its representation
;;; in bytes is stored in the low seven bits of the initial byte, and
;;; that many bytes follow containing the representation itself.  If the
;;; integer is "large", then #o176 is stored in the low seven bits of
;;; the initial byte, and the length of the integer is stored in the
;;; next four bytes, followed by that many bytes containing the
;;; representation itself.  The number zero, as a special case, is
;;; stored as if it were a small positive number with length zero, and
;;; therefore it consists of just the initial byte, with value #o200.
;;; The null value is stored as a #o377 in the initial byte.

;;; "Small" numbers end up being those of magnitude < 10 to the 304
;;; approximately, so the "large" format isn't going to come up very
;;; often in practice.  Bignums in the 3600 architecture have a length
;;; field, expressed in words, that's 23 bits wide.  So the length in
;;; bytes could take up 25 bits, so you need four bytes of length
;;; information.  Future architectures may allow even larger bignums,
;;; but using four bytes gives us a pretty comfortable margin for
;;; expansion.

(defmethod indexable-p ((handler integer-key-mixin)) t)

;;; Given a non-negative integer, return the number of bytes it takes up.
(defun size-of-integer (integer)
  (if (eq *null-value* integer)
      0
      (let ((integer (abs integer)))
	(cond ((zerop integer) 0)
	      ((< integer #.(ash 1  8)) 1)
	      ((< integer #.(ash 1 16)) 2)
	      ((< integer #.(ash 1 24)) 3)
	      ((< integer #.(ash 1 32)) 4)
	      (t (ceiling (integer-length integer) 8))))))

(defmethod size-of-key-from-record ((handler integer-key-mixin) addressor descriptor last-p case-sensitive)
  (size-of-key-from-value handler (read-value handler addressor descriptor nil) last-p case-sensitive))

(defmethod size-of-key-from-value ((handler integer-key-mixin) integer last-p case-sensitive)
  (declare (ignore last-p case-sensitive))
  (let ((nbytes (size-of-integer integer)))
    (+ nbytes (if (or (< nbytes #o176) (eq *null-value* integer)) 1 5))))
 
(defmethod write-key-from-record ((handler integer-key-mixin) addressor descriptor array offset
				  database last-p case-sensitive)
  (write-key-from-value handler
			(read-value handler addressor descriptor nil)
			array
			offset
			database
			last-p
			case-sensitive))

(defmethod write-key-from-value ((handler integer-key-mixin) integer array offset database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (let* ((initial-byte #o200)
	 (null-value-p (eq integer *null-value*))
	 (negative-p (and (not null-value-p) (minusp integer))))
    (if null-value-p
	(setq initial-byte #o377)
	(when negative-p
	  (setq initial-byte 0)))
    (flet ((store-integer (i n-bytes)
	     (loop repeat n-bytes
		   for position = (* 8 (1- n-bytes)) then (- position 8) do
	       (store-byte array offset (load-byte i position 8))
	       (incf offset))))
      (let ((size (size-of-integer integer)))
	(cond ((< size #o176)
	       ;; Use the "small" format.
	       (store-byte array
			   offset
			   (if negative-p
			       (- #o177 size)
			       (+ initial-byte size)))
	       (incf offset))
	      (t
	       ;; Use the "large" format.
	       (store-byte array
			   offset
			   (if negative-p
			       (- #o17777777777 size)
			       (+ initial-byte #o176)))
	       (incf offset)
	       (store-integer size 4)))
	(store-integer integer size))))
  offset)

;;; Since an integer can be any number, just return the next highest.
(defmethod next-value ((handler integer-key-mixin) integer)
  (1+ integer))

;;; Packed integers don't always have a next value.  This is
;;; particularly important for logical types built on packed-integer,
;;; e.g. member, which really doesn't have value after the last one.
(defmethod next-value ((handler packed-integer) integer)
  (with-slots (end) handler
    (unless (= (1+ integer) end)
      (1+ integer))))

(defmethod indexable-p ((handler single-float-handler)) t)

(defmethod size-of-key-from-record ((handler single-float-handler) addressor descriptor lastp case-sensitive)
  (declare (ignore addressor descriptor lastp case-sensitive))
  4)

(defmethod size-of-key-from-value ((handler single-float-handler) float lastp case-sensitive)
  (declare (ignore float lastp case-sensitive))
  4)

(defmethod write-key-from-record ((handler single-float-handler) addressor descriptor array
				  offset database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (write-four-byte-key (map-raw-flonum (read-record-word addressor descriptor))
		       array
		       offset))

(defmethod write-key-from-value ((handler single-float-handler) single-float array offset
				 database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (write-four-byte-key (map-raw-flonum (sys:%fixnum (if (eq single-float *null-value*)
							*single-float-null*
							single-float)))
		       array
		       offset))

;;; integer should be a one-word number, whose values are stored starting with
;;; the high-order byte.  Returns the modified offset.
(defun write-four-byte-key (integer array offset)
  (store-byte array offset (sys:%logldb (byte 8 24) integer))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 16) integer))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 8) integer))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 0) integer))
  (incf offset))

(defmethod next-value ((handler single-float-handler) single-float)
  (let ((fixnum (sys:%fixnum single-float)))
    (unless (= fixnum most-positive-fixnum)
      (sys:%flonum (1+ fixnum)))))

(defmethod indexable-p ((handler double-float-handler)) t)

(defmethod size-of-key-from-record ((handler double-float-handler) addressor descriptor
				    last-p case-sensitive)
  (declare (ignore addressor descriptor last-p case-sensitive))
  8)

(defmethod size-of-key-from-value ((handler double-float-handler) doublefloat lastp case-sensitive)
  (declare (ignore doublefloat lastp case-sensitive))
  8)

(defmethod write-key-from-record ((handler double-float-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (write-double-integer-key
    (map-raw-double-flonum (read-record-word addressor descriptor))
    (read-record-word addressor (1+ descriptor))
    array
    offset))

(defmethod write-key-from-value ((handler double-float-handler) double-float array offset
				 database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (let ((val (if (eq double-float *null-value*)
		 *double-float-null*
		 double-float)))
    (write-double-integer-key
      (map-raw-double-flonum (si:double-high val)) (si:double-low val) array offset)))

(defun write-double-integer-key (high low array offset)
  (store-byte array offset (sys:%logldb (byte 8 24.) high))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 16.) high))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 8) high))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 0) high))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 24.) low))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 16.) low))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 8) low))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 0) low))
  (incf offset))

(defmethod next-value ((handler double-float-handler) double-float)
  (let ((low (si:double-low double-float))
	(high (si:double-high double-float)))
    (if (= low most-positive-fixnum)
	(unless (= high most-positive-fixnum)
	  (si:%make-double (1+ high) 0))
	(si:%make-double high (1+ low)))))

(defmethod indexable-p ((handler boolean-handler-mixin)) t)

(defmethod size-of-key-from-record ((handler boolean-handler-mixin) addressor descriptor
				    last-p case-sensitive)
  (declare (ignore addressor descriptor last-p case-sensitive))
  1)

(defmethod size-of-key-from-value ((handler boolean-handler-mixin) bit lastp case-sensitive)
  (declare (ignore bit lastp case-sensitive))
  1)

(defmethod write-key-from-record ((handler boolean-handler-mixin) addressor descriptor array
				  offset database last-p case-sensitive)
  (write-key-from-value handler
			(read-value handler addressor descriptor nil)
			array
			offset
			database
			last-p
			case-sensitive))

(defmethod write-key-from-value ((handler boolean-handler-mixin) value array offset
				 database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (store-byte array offset (cond ((eq *null-value* value) 2)
				 ((null value) 0)
				 ((eq value 'boolean-high-value) 3)
				 (t 1)))
  (incf offset))

(defmethod next-value ((handler boolean-handler-mixin) value)
  (cond ((eq *null-value* value) 'boolean-high-value)
	((null value) t)
	(t *null-value*)))

(defmethod indexable-p ((handler symbol-handler)) t)

(defmethod size-of-key-from-record ((handler symbol-handler) addressor descriptor last-p case-sensitive)
  (declare (ignore case-sensitive))
  (+ 4 (size-of-key-from-record-internal
	 (length-of-array handler addressor descriptor)
	 addressor
	 descriptor
	 last-p
	 t					;always case-sensitive
	 *symbol-fat-thin-byte*)))

(defmethod size-of-key-from-value ((handler symbol-handler) symbol last-p case-sensitive)
  (if (eq *null-value* symbol)
      (+ 4 (size-of-string-key 0))
      (let* ((value (zl:get-pname symbol))
	     (n-bytes (length value)))
	(+ 4 (size-of-string-key n-bytes) (if (and case-sensitive
						   (or (null last-p)
						       (string-really-fat-p value)))
					      n-bytes
					      0)))))

(defun size-of-key-from-record-internal
       (n-bytes addressor descriptor last-p case-sensitive fat-thin-byte)
  (let ((desc (read-record-word addressor descriptor)))
    (+ (size-of-string-key n-bytes) (cl:if (or (and (zerop (sys:%logldb fat-thin-byte desc))
						 last-p)
					    (null case-sensitive))
					0
					n-bytes))))

(defmethod write-key-from-record ((handler symbol-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (let* ((position 32)
	 (desc (read-record-word addressor descriptor))
	 (thin-p (zerop (sys:%logldb *symbol-fat-thin-byte* desc)))
	 (short-p (zerop (sys:%logldb *symbol-long-short-byte* desc)))
	 (word-offset (if short-p
			  (sys:%logldb *symbol-short-offset* desc)
			  ;; Address of length word
			  (sys:%logldb *symbol-long-offset* desc)))
	 (n-bytes (if (value-null-p handler addressor descriptor)
		      -1
		      (length-of-array handler addressor descriptor)))
	 (word))
    (cond ((and thin-p last-p)
	   (sys:with-data-stack
	     (let* (;; Size of entire field, including length/package for long
		    (n-words (size-of-field handler addressor descriptor))
		    (words (unless (zerop n-words)
			     (read-multiple-record-word
			       addressor word-offset (+ n-words word-offset))))
		    (package-code (cond (short-p
					 (setq word-offset 0)
					 (sys:%logldb *symbol-short-package-code* desc))
					(t
					 ;; length at 0, pkg at 1, data at 2
					 (setq word-offset 2)
					 (aref words 1)))))
	       (store-byte array offset (sys:%logldb (byte 8 24) package-code))
	       (incf offset)
	       (store-byte array offset (sys:%logldb (byte 8 16) package-code))
	       (incf offset)
	       (store-byte array offset (sys:%logldb (byte 8 8) package-code))
	       (incf offset)
	       (store-byte array offset (sys:%logldb (byte 8 0) package-code))
	       (incf offset)
	       (write-string-key n-bytes
				 array
				 offset
				 #'(lambda ()
				     (when (>= position 32)
				       (setq word (aref words word-offset))
				       (incf word-offset)
				       (setq position 0))
				     (prog1 (case position
					      (0  (sys:%logldb (byte 8  0) word))
					      (8  (sys:%logldb (byte 8  8) word))
					      (16 (sys:%logldb (byte 8 16) word))					      (24 (sys:%logldb (byte 8 24) word)))
					    (incf position 8)))
				 case-sensitive))))
	  (t
	   (let ((table-of-char-types (database-table-of-character-types database))
		 (byte-offset)
		 (position -1))
	     (multiple-value-bind (print-name package-code)
		 (read-symbol-internal
		   addressor (read-record-word addressor descriptor) database)
	       (store-byte array offset (sys:%logldb (byte 8 24) package-code))
	       (incf offset)
	       (store-byte array offset (sys:%logldb (byte 8 16) package-code))
	       (incf offset)
	       (store-byte array offset (sys:%logldb (byte 8 8) package-code))
	       (incf offset)
	       (store-byte array offset (sys:%logldb (byte 8 0) package-code))
	       (incf offset)
	       (setq byte-offset
		     (write-string-key n-bytes
				       array
				       offset
				       #'(lambda ()
					   (char-code (aref print-name (incf position))))
				       case-sensitive))
	       (when case-sensitive
		 (loop for i from 0 below n-bytes do
		   (store-byte array
			       byte-offset
			       (gethash (si:char-type (aref print-name i))
					table-of-char-types))
		   (incf byte-offset))))
	     byte-offset)))))

(defconstant *max-char-type* #o377)

(defmethod write-key-from-value ((handler symbol-handler) symbol array
				 offset database last-p case-sensitive)
  (let* ((null-value-p (eq symbol *null-value*))
	 (string (unless null-value-p (zl:get-pname symbol)))
	 (package-code (if null-value-p -1 (encode-package symbol database))))
    (store-byte array offset (sys:%logldb (byte 8 24) package-code))
    (incf offset)
    (store-byte array offset (sys:%logldb (byte 8 16) package-code))
    (incf offset)
    (store-byte array offset (sys:%logldb (byte 8 8) package-code))
    (incf offset)
    (store-byte array offset (sys:%logldb (byte 8 0) package-code))
    (incf offset)
    (let* ((position -1)
	   (byte-offset (write-string-key (if null-value-p -1 (length string))
					  array
					  offset
					  #'(lambda ()
					      (char-code (aref string (incf position))))
					  case-sensitive)))
      (unless null-value-p
	(let ((fat-p (string-really-fat-p string))
	      (table-of-char-types (database-table-of-character-types database)))
	  (when (or (null last-p) fat-p)
	    (when case-sensitive
	      (loop for i from 0 below (length string) do
		(store-byte array
			    byte-offset
			    (or (gethash (si:char-type (aref string i)) table-of-char-types)
				*max-char-type*))
		(incf byte-offset))))))
      byte-offset)))

;;; This is bad to intern this.
(defmethod next-value ((handler symbol-handler) symbol)
  (intern (next-string (symbol-name symbol)) (symbol-package symbol)))

;;; Strings are encoded as described below, with one minor addition.  In
;;; order to make sure that the correct collating sequence is observed
;;; in the face of fat strings and character styles, the character style
;;; information is added onto the end of the key, one 8 bit byte per
;;; character.  The style is looked up in the table-of-character-types
;;; in the database object so that the sorting sequence is on a per
;;; database basis, rather than a per cold boot basis.  If the string is
;;; not fat, and it is being stored as the last attribute in the index,
;;; the type info is not stored (to save some space).

;;; Note that currently, the style information gets written out at the
;;; end of the key, even if the string only has thin characters.   If
;;; the string is the last attribute in the index, no style info would
;;; need to be written if all the chars were thin.

(defmethod indexable-p ((handler string-handler)) t)

(defmethod size-of-key-from-record ((handler string-handler) addressor descriptor last-p case-sensitive)
  (size-of-key-from-record-internal
    (length-of-array handler addressor descriptor)
    addressor
    descriptor
    last-p
    case-sensitive
    *fat-thin-byte*))

(defmethod size-of-key-from-value ((handler string-handler) value last-p case-sensitive)
  (if (eq *null-value* value)
      (size-of-string-key 0)
      (let ((n-bytes (length value)))
	(+ (size-of-string-key n-bytes) (if (and case-sensitive
						 (or (null last-p)
						     (string-really-fat-p value)))
					    n-bytes
					    0)))))

(defmethod write-key-from-record ((handler string-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (let* ((position 32)
	 (desc (read-record-word addressor descriptor))
	 (thin-p (zerop (sys:%logldb *fat-thin-byte* desc)))
	 (short-p (zerop (sys:%logldb *long-short-byte* desc)))
	 (word-offset (if short-p
			  (sys:%logldb *short-offset* desc)
			  ;; Address of length word
			  (sys:%logldb *long-offset* desc)))
	 (n-bytes (if (value-null-p handler addressor descriptor)
		      -1
		      (length-of-array handler addressor descriptor)))
	 (word))
    (sys:with-data-stack
      (cond ((and thin-p last-p)
	     (let* (;; Size of entire field, including length/package for long
		    (n-words (size-of-field handler addressor descriptor))
		    (words (unless (zerop n-words)
			     (read-multiple-record-word
			       addressor word-offset (+ n-words word-offset)))))
	       ;; skip length field on long
	       (setq word-offset (if short-p 0 1))
	       (write-string-key n-bytes
				 array
				 offset
				 #'(lambda ()
				     (when (>= position 32)
				       (setq word (aref words word-offset))
				       (incf word-offset)
				       (setq position 0))
				     (prog1 (case position
					      (0  (sys:%logldb (byte 8  0) word))
					      (8  (sys:%logldb (byte 8  8) word))
					      (16 (sys:%logldb (byte 8 16) word))
					      (24 (sys:%logldb (byte 8 24) word)))
					    (incf position 8)))
				 case-sensitive)))
	    (t
	     (let* ((string (sys:make-stack-array n-bytes :element-type 'character))
		    (table-of-char-types (database-table-of-character-types database))
		    (byte-offset)
		    (position -1))
	       (read-value handler addressor descriptor database :into-string string)
	       (setq byte-offset
		     (write-string-key n-bytes
				       array
				       offset
				       #'(lambda ()
					   (char-code (aref string (incf position))))
				       case-sensitive))
	       (when case-sensitive
		 (loop for i from 0 below n-bytes do
		   (store-byte array
			       byte-offset
			       (gethash (si:char-type (aref string i)) table-of-char-types))
		   (incf byte-offset)))
	       byte-offset))))))

(defmethod write-key-from-value ((handler string-handler) string array offset database last-p case-sensitive)
  (let* ((position -1)
	 (byte-offset
	   (write-string-key (if (eq string *null-value*)
				 -1
				 (length string))
			     array
			     offset
			     #'(lambda ()
				 (char-code (aref string (incf position))))
			     case-sensitive)))
    (unless (eq string *null-value*)
      (let ((fat-p (string-really-fat-p string))
	    (table-of-char-types (database-table-of-character-types database)))
	(when (or (null last-p) fat-p)
	  (when case-sensitive
	    (loop for i from 0 below (length string) do
	      (store-byte array
			  byte-offset
			  (or (gethash (si:char-type (aref string i)) table-of-char-types)
			      *max-char-type*))
	      (incf byte-offset))))))
    byte-offset))

(defmethod next-value ((handler string-handler) string)
  (next-string string))

;;; Strings are encoded using the algorithm described in "An Encoding
;;; Method for Multifield Sorting and Indexing", by Blasgen, Casey, and
;;; Eswaren, CACM (20) 11 Nov 1977.  Every Nth byte is a "control byte".
;;; The string is padded to be a multiple of N bytes long.  The control
;;; bytes inserted between databases are #377, and the final control byte
;;; has the value N - r where r is the number of padding characters.

;;; Thin strings are sorted based on the value of the char-codes of the
;;; characters.  If the string has a fill pointer, only the active part
;;; is used.

;;; The initial byte determines the null value.  It is #o377 if the
;;; string is the null value, and #o376 if it is not.  Hence, the null
;;; value always compares higher than any string.  #o001 is the zero
;;; length string.

(defconstant *control-byte-frequency* 5)

(defun size-of-string-key (n-bytes)
  (+ (* (1+ *control-byte-frequency*) (ceiling n-bytes *control-byte-frequency*)) 2))

;;; n-bytes is the length of the string.  array is a key array being
;;; built up.  byte-offset is where to start putting bytes into array.
;;; get-next-char is a generator function of no arguments that returns
;;; the next character.  Returns the final byte-offset.
(defun write-string-key (n-bytes array byte-offset get-next-char case-sensitive)
  (declare (sys:downward-funarg get-next-char))
  (unless (plusp n-bytes)
    (store-byte array byte-offset (cl:if (minusp n-bytes) #o377 #o001))
    (return-from write-string-key (1+ byte-offset)))
  (store-byte array byte-offset #o376)
  (incf byte-offset)
  (cl:macrolet ((code-upcase (char-code)
	       `(cl:if ( #.(char-code #\a) ,char-code #.(char-code #\z))
		    (logxor #o40 ,char-code)
		    ,char-code)))
    (let ((next-char 0))
      (cl:loop while (< (+ next-char *control-byte-frequency*) n-bytes) do
	(cl:loop repeat *control-byte-frequency* do
	  (store-byte array byte-offset (let ((char-code (funcall get-next-char)))
					  (cl:if case-sensitive
					      char-code
					      (code-upcase char-code))))
	  (incf byte-offset)
	  (incf next-char))
	(store-byte array byte-offset #o377)
	(incf byte-offset))
      (let ((leftovers (- n-bytes next-char)))
	(cl:loop while (< next-char n-bytes) do
	  (store-byte array byte-offset (let ((char-code (funcall get-next-char)))
					  (cl:if case-sensitive
					      char-code
					      (code-upcase char-code))))
	  (incf byte-offset)
	  (incf next-char))
	(cl:loop repeat (- *control-byte-frequency* leftovers) do
	  (store-byte array byte-offset #o000)
	  (incf byte-offset))
	(store-byte array byte-offset leftovers)
	(incf byte-offset))))
  byte-offset)

(defmethod indexable-p ((handler entity-storage-handler-mixin)) t)

(defmethod size-of-key-from-record ((handler entity-storage-handler-mixin) addressor descriptor
				    last-p case-sensitive)
  (declare (ignore addressor descriptor last-p case-sensitive))
  4)

(defmethod size-of-key-from-value ((handler entity-storage-handler-mixin) ent-handle lastp case-sensitive)
  (declare (ignore ent-handle lastp case-sensitive))
  4)

(defmethod write-key-from-record ((handler entity-storage-handler-mixin) addressor descriptor
				  array offset database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (write-key-from-rid (read-record-word addressor descriptor) array offset))

(defmethod write-key-from-value ((handler entity-storage-handler-mixin)
				 entity-handle array offset database last-p case-sensitive)
  (declare (ignore database last-p case-sensitive))
  (write-key-from-rid (if (eq entity-handle *null-value*)
			  *integer-short-max*
			  (handle-rid entity-handle))
		      array
		      offset))

(defun write-key-from-rid (rid array offset)
  (store-byte array offset (sys:%logldb (byte 8 24) rid))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 16) rid))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 8) rid))
  (incf offset)
  (store-byte array offset (sys:%logldb (byte 8 0) rid))
  (incf offset))

;;; Fake up a handle whose RID is one greater than the RID of our
;;; argument.  Also set the domain, so that the print-self doesn't die.
(defmethod next-value ((handler entity-storage-handler-mixin) entity-handle)
  (make-instance 'known-entity-handle
		 :rid (1+ (handle-rid entity-handle))
		 :domain (known-entity-handle-domain entity-handle)))

(defmethod indexable-p ((handler limited-string-handler))
  t)

(defmethod size-of-key-from-record ((handler limited-string-handler) addressor descriptor
				    last-p case-sensitive)
  (declare (ignore addressor descriptor last-p case-sensitive))
  (with-slots (len) handler
    len))

(defmethod size-of-key-from-value ((handler limited-string-handler) string lastp case-sensitive)
  (declare (ignore string lastp case-sensitive))
  (with-slots (len) handler
    len))

(defmethod write-key-from-record ((handler limited-string-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (declare (ignore database last-p))
  (with-slots (len) handler
    (let* ((word-offset (desc-word-offset descriptor))
	   (bit-offset (desc-bit-offset descriptor))
	   (word (read-record-word addressor word-offset))
	   (code (sys:%logldb (byte 8 bit-offset) word))
	   (null-value (= code 255))
	   (end-of-string nil))
      (loop for string-offset from 0 below len
	    for byte-offset from offset do
	(when (= code 128) (setq end-of-string t))
	(store-byte array
		    byte-offset
		    (cond (null-value #o377)
			  (end-of-string 0)
			  (case-sensitive code)
			  ((<= #.(char-code #\a) code #.(char-code #\z)) (logxor #o40 code))
			  (t code)))
	(unless (= string-offset (1- len))
	  (incf bit-offset 8)
	  (when (= bit-offset 32)
	    (setq bit-offset 0)
	    (incf word-offset)
	    (setq word (read-record-word addressor word-offset)))
	  (setq code (sys:%logldb (byte 8 bit-offset) word)))))
    (+ offset len)))

(defmethod write-key-from-value ((handler limited-string-handler) string array offset database last-p case-sensitive)
  (declare (ignore database last-p))
  (with-slots (len) handler
    (loop with slen = (if (eq string *null-value*) len (string-length string))
	  for i below len
	  for byte-offset from offset do
      (store-byte array
		  byte-offset
		  (cond ((eq string *null-value*) #o377)
			((>= i slen) 0)
			(t
			 (let ((char-code (char-code (aref string i))))
			   (if case-sensitive
			       char-code
			       (if (<= #.(char-code #\a) char-code #.(char-code #\z))
				   (logxor #o40 char-code)
				   char-code)))))))
    (+ offset len)))

(defmethod next-value ((handler limited-string-handler) string)
  (next-string string))

(defmethod indexable-p ((handler string-char-handler))
  t)

(defmethod size-of-key-from-record ((handler string-char-handler) addressor descriptor
				    last-p case-sensitive)
  (declare (ignore addressor descriptor last-p case-sensitive))
  1)

(defmethod size-of-key-from-value ((handler string-char-handler) char lastp case-sensitive)
  (declare (ignore char lastp case-sensitive))
  1)

(defmethod write-key-from-record ((handler string-char-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (declare (ignore database last-p))
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 8 bit-offset) word))
	 (null-value (= code 255)))
    (store-byte array
		offset
		(cond (null-value #o377)
		      (case-sensitive code)
		      ((<= #.(char-code #\a) code #.(char-code #\z)) (logxor #o40 code))
		      (t code)))
    (1+ offset)))

(defmethod write-key-from-value ((handler string-char-handler) char array offset database last-p case-sensitive)
  (declare (ignore database last-p))
  (store-byte array
	      offset
	      (cond ((eq char *null-value*) #o377)
		    (t
		     (let ((char-code (char-code char)))
		       (if case-sensitive
			   char-code
			   (if (<= #.(char-code #\a) char-code #.(char-code #\z))
			       (logxor #o40 char-code)
			       char-code))))))
  (1+ offset))

(defmethod next-value ((handler string-char-handler) value)
  (cond ((eq *null-value* value) nil)
	(t (code-char (1+ (char-code value))))))

(defmethod indexable-p ((handler character-handler))
  t)

(defmethod size-of-key-from-record ((handler character-handler) addressor descriptor
				    last-p case-sensitive)
  (declare (ignore addressor descriptor last-p case-sensitive))
  2)

(defmethod size-of-key-from-value ((handler character-handler) char lastp case-sensitive)
  (declare (ignore char lastp case-sensitive))
  2)

(defmethod write-key-from-record ((handler character-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (declare (ignore last-p database))
  (let* ((word-offset (desc-word-offset descriptor))
	 (bit-offset (desc-bit-offset descriptor))
	 (word (read-record-word addressor word-offset))
	 (code (sys:%logldb (byte 16 bit-offset) word))
	 (subindex (sys:%logldb (byte 8 0) code))
	 (type (sys:%logldb (byte 8 8) code))
	 (null-value (= code *character-null-value*)))
    (store-byte array
		offset
		(if null-value #o377 type))
    (store-byte array
		(1+ offset)
		(cond (null-value #o377)
		      (case-sensitive subindex)
		      ((<= #.(char-code #\a) subindex #.(char-code #\z)) (logxor #o40 subindex))
		      (t code)))
    (+ offset 2)))

(defmethod write-key-from-value ((handler character-handler) char
				 array offset database last-p case-sensitive)
  (declare (ignore last-p))
  (store-byte array
	      offset
	      (if (eq char *null-value*) 
		  #o377
		  (gethash (si:char-type char)
			   (database-table-of-character-types database))))
  (store-byte array
	      (1+ offset)
	      (cond ((eq char *null-value*) #o377)
		    (t
		     (let ((subindex (si:char-subindex char)))
		       (if case-sensitive
			   subindex
			   (if (<= #.(char-code #\a) subindex #.(char-code #\z))
			       (logxor #o40 subindex)
			       subindex))))))
  (+ offset 2))

(defmethod next-value ((handler character-handler) value)
  (cond ((eq *null-value* value) nil)
	(t (si:%make-character (dpb (1+ (char-code value)) sys:%%char-subindex
				    (si:char-ldb-internal sys:%%char-all value))))))

(defmethod indexable-p ((handler logical-format-handler))
  (with-slots (underlying-handler) handler
    (indexable-p underlying-handler)))

(defmethod size-of-key-from-record ((handler logical-format-handler) addressor descriptor
				    last-p case-sensitive)
  (with-slots (underlying-handler) handler
    (size-of-key-from-record underlying-handler
			     addressor descriptor last-p case-sensitive)))

(defmethod size-of-key-from-value ((handler logical-format-handler) value last-p case-sensitive)
  (with-slots (underlying-handler) handler
    (size-of-key-from-value underlying-handler
			    (encode-value handler value) last-p case-sensitive)))

(defmethod write-key-from-record ((handler logical-format-handler) addressor descriptor
				  array offset database last-p case-sensitive)
  (with-slots (underlying-handler) handler
    (write-key-from-record underlying-handler
			   addressor descriptor array offset database last-p case-sensitive)))

(defmethod write-key-from-value ((handler logical-format-handler) value array
				 offset database last-p case-sensitive)
  (with-slots (underlying-handler) handler
    (write-key-from-value underlying-handler
			  (encode-value handler value)
			  array offset database last-p case-sensitive)))

(defmethod next-value ((handler logical-format-handler) value)
  (with-slots (underlying-handler) handler
    (let ((next (next-value underlying-handler (encode-value handler value))))
      (and next (decode-value handler next)))))

;;; The indexes provided by Storage level store values which are
;;; fixnums.  Model level always stores RIDs of tuples as those
;;; values.  It is possible for many tuples to have the same RID,
;;; if there are many relations surrogate optimized onto the same
;;; domain.  But each index refers to one specific relation, and any
;;; given RID can only refer to one tuple within any specific
;;; relation.  So there isn't any ambiguity.
;;; Given an addressor to a record that holds a tuple, whose
;;; relation is relation-handle, insert the tuple into all
;;; relevant indexes, storing value in the index entry.  Furthermore, if
;;; any index's constraints are violated, signal an error.  If the
;;; attribute-handle argument is non-nil, then only insert into those
;;; indexes that have attribute-handle on their attribute list.
;;; The verb argument is for the error message and should be something
;;; like "make" or "set".
(defun insert-into-indexes (addressor value relation-handle version verb attribute-handle)
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (dolist (index-handle (relation-handle-list-of-indexes relation-handle))
      (let ((atts (index-handle-list-of-attributes index-handle))
	    (idx-iid (index-handle-index-identifier index-handle))
	    (case-insensitive-type-attribute-present nil))
	(when (or (null attribute-handle)
		  (member attribute-handle atts))
	  (condition-bind ((statice-index::too-many-values-for-insert
			     #'(lambda (cond)
				 (declare (ignore cond))
				 (error 'uniqueness-violation
					:relation-handle relation-handle
					:index-handle index-handle
					:verb verb))))
	    (sys:with-data-stack
	      ;; if index is unique and case-insensitive, or, there are
	      ;; any atts present which are unique, we may have to look
	      ;; at any tuples in the index to determine uniqueness.
	      (multiple-value-bind (key any-null-p)
		  (make-key-from-record
		    index-handle addressor version soo-att
		    (when soo-att
		      (find-entity-handle-given-rid (get-addressor-rid addressor) database))
		    database)
		(when (and (or (and (index-handle-unique index-handle)
				    (not (index-handle-case-sensitive index-handle)))
			       (loop for att in atts thereis (attribute-handle-unique att)))
			   ;; are there any tuples pointed to in the
			   ;; index that have matching values (exactly)
			   ;; to the one we're about to insert?
			   (loop for att in atts
				 thereis
				   (let* ((type (attribute-handle-type att))
					  (new-rid (get-addressor-rid addressor)))
				     (and (setq case-insensitive-type-attribute-present
						(or (null (case-insensitive-type-p type))
						    case-insensitive-type-attribute-present))
					  (block nil
					    ;; too bad we have to cons a tuple handle
					    (let ((tuple (find-tuple-handle-given-rid
							   new-rid relation-handle)))
					      (multiple-value-bind (value not-null-p)
						  (get-value tuple att)
						(when not-null-p
						  (let ((rid-array (lookup-index-values
								     opening idx-iid key)))
						    (declare (sys:array-register rid-array))
						    (dotimes (i (length rid-array))
						      (let ((rid (aref rid-array i)))
							(unless (or (= rid new-rid)
								    (zerop rid))
							  (with-record (r opening rid :read)
							    (when (test-spec
								    r att value
								    database rid soo-att)
							      (return t)))))))))))))))
		  (error 'uniqueness-violation
			 :relation-handle relation-handle
			 :index-handle index-handle
			 :verb verb))
		;; try inserting into the index and let it signal if uniqueness violation
		(let* ((idx-depth (index-handle-index-depth index-handle))
		       (new-idx-iid
			 (insert-index-value
			   opening idx-iid key value idx-depth
			   (and (index-handle-unique index-handle)
				(null case-insensitive-type-attribute-present)
				(not any-null-p)))))
		  (unless (= idx-iid new-idx-iid)
		    (note-schema-modified database)
		    (setq idx-depth (compute-index-depth opening new-idx-iid))
		    (with-record (idx opening (handle-rid index-handle) :write)
		      (setf (index-index-identifier idx) new-idx-iid
			    (index-index-depth idx) idx-depth))
		    (setf (index-handle-index-identifier index-handle) new-idx-iid
			  (index-handle-index-depth index-handle) idx-depth)))))))))))


;;; Given an addressor to a record that holds a tuple, whose
;;; Given an addressor to a record that holds a tuple, whose
;;; relevant indexes, removing value in the index entry.
(defun delete-from-indexes (addressor value relation-handle version &optional attribute-handle)
  (let* ((database (relation-handle-database relation-handle))
	 (opening (database-opening database))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (dolist (index-handle (relation-handle-list-of-indexes relation-handle))
      (let ((atts (index-handle-list-of-attributes index-handle)))
	(when (and (or (null attribute-handle)
		       (member attribute-handle atts)))
		(let* ((idx-iid (index-handle-index-identifier index-handle))
		       (idx-depth (index-handle-index-depth index-handle))
		       (new-idx-iid
			 (sys:with-data-stack
			   (delete-index-value opening
					       idx-iid
					       (make-key-from-record
						 index-handle addressor version soo-att
						 (when soo-att
						   (find-entity-handle-given-rid
						     (get-addressor-rid addressor) database))
						 database)
					       value
					       idx-depth))))
		  (unless (= idx-iid new-idx-iid)
		    (note-schema-modified database)
		    (setq idx-depth (compute-index-depth opening new-idx-iid))
		    (with-record (idx opening (handle-rid index-handle) :write)
		      (setf (index-index-identifier idx) new-idx-iid
			    (index-index-depth idx) idx-depth))
		    (setf (index-handle-index-identifier index-handle) new-idx-iid
			  (index-handle-index-depth index-handle) idx-depth))))))))


;;; Allocation and deallocation of words within records.

;;; Return the storage occupied by the tuple of relation-handle
;;; in the given entity record.  Also turn off the bit in the
;;; tuples-present field for this tuple.  The caller
;;; guarantees that the relation is surrogate optimized, of course.  The
;;; record is a local-entity; ent is an addressor to it and ent-rid is
;;; its rid.  domain-handle is the domain of the entity.  ent must be
;;; in :write mode.
(defun deallocate-tuple-from-entity (ent relation-handle domain-handle soo-att)
  (declare (ignore soo-att))
  (let ((new-present
	  (dpb 0 (byte 1 (search-table-for-domain
			   (relation-handle-entity-bit-map-number relation-handle)
			   domain-handle))
	       (local-entity-tuples-present ent))))
    ;; There may be tuples present, so leave the fixed words alone.  We
    ;; assume at this point that all of the variable words occupied by
    ;; the tuple are contiguous.  Find the boundaries.
    (cond ((zerop new-present)
	   ;; This is the only tuple present in the entity record.  Very easy case!
	   (let ((gia (domain-handle-group-indexed-attributes domain-handle)))
	     (cond (gia
		    (set-record-size
		      ent
		      (loop for attribute-handle in gia
			    maximize
			      (or (1+ (search-table-for-domain
					(attribute-handle-group-index-offset attribute-handle)
					domain-handle
					:if-not-found nil))
				  (record-size local-entity)))))
		   (t
		    (set-record-size ent (record-size local-entity))
		    ;; Set its version back to zero so that upgrade will reallocate
		    ;; the fixed space next time a tuple is created.
		    (setf (local-entity-version ent) 0)))))
	  (t 
	   #||
	   ;;;Dont bother to deallocate any partial variable words in the record,
	   ;;;since the whole record tends to be deallocated anyway when the last
           ;;;tuple is deleted.  This GC algorithm is buggy anyway, when the
           ;;;variable sized portion attributes are sandwiched multi-type style.
           ;;;--Feinberg 6/8/89
	   (multiple-value-bind (first-var-word n-var-words)
	       (range-of-var-words ent relation-handle soo-att domain-handle)
	     (unless (zerop n-var-words)
	       ;; Slide up all the variable words that follow the contiguous region.
	       (close-gap ent first-var-word n-var-words)
	       ;; Free up the unused storage.
	       (adjust-record-size ent (- n-var-words))
	       ;; Find all attributes of all relations that live in this entity.
	       ;; If their variable portion was in the part that we slid, adjust
	       ;; the contents of their fixed words to point at the new home of
	       ;; the variable words.
	       (adjust-all-in-entity ent domain-handle first-var-word (- n-var-words))))
	   ||#))
    (setf (local-entity-tuples-present ent) new-present)))

;;; Copy the contents of the fixed area of an attribute from one record
;;; to another record.  For each record, we are given a record
;;; addressor, and a descriptor word pointing to the fixed area.  type
;;; is a storage handler instance that tells us the size of the fixed
;;; area.
(defun copy-fixed-area (type old-ent old-desc new-ent new-desc)
  (multiple-value-bind (n-total-bits alignment)
      (fixed-space type)
    (multiple-value-bind (n-words n-bits)
	(floor n-total-bits 32)
      (cond ((and (zerop n-bits) (zerop alignment))
	     ;; Easy case: the fixed space is just a set of words.
	     (cl:loop for old-offset from old-desc
		   for new-offset from new-desc
		   repeat n-words do
	       (cl:setf (read-record-word new-ent new-offset)
		     (read-record-word old-ent old-offset))))
	    (t
;	   (let ((old-wordo (desc-word-offset old-desc))
;		 (old-bito (desc-bit-offset old-desc))
;		 (new-wordo (desc-word-offset new-desc))
;		 (new-bito (desc-bit-offset new-desc)))
;	     )
	     ;; ++++ Really gotta write this one of these days.  This case cannot
	     ;; occur if you're using function level, so it's extremely unlikely
	     ;; that anybody will run into this.
	     (model-error "Obscure case of copy-fixed-area has not been coded yet."))))))

;;; The relation is surrogate-optimized, and the entity record holds one
;;; tuple of the relation.  Return the range of contiguous
;;; storage within the entity record that is used by the variable words
;;; of the tuple.
(defun range-of-var-words (ent relation-handle soo-att ent-dom)
  (declare (values first-var-word n-var-words))
  (let ((first-var-word #.(ash 1 33))
	(n-var-words 0))
    (dolist (a (relation-handle-list-of-attributes relation-handle))
      (unless (eq a soo-att)
	(let* ((type (attribute-handle-type a))
	       (desc (search-table-for-domain (attribute-handle-descriptor a) ent-dom))
	       (att-version (search-table-for-domain (attribute-handle-layout-version a)
						     ent-dom :if-not-found nil))
	       (s-o-f (start-of-field type ent desc)))
	  (when (and att-version (>= (local-entity-version ent) att-version)
		     (not (zerop s-o-f)))
	    (setq first-var-word (min s-o-f first-var-word))
	    (incf n-var-words (size-of-field type ent desc))))))
    (values first-var-word n-var-words)))

;;; Open up a gap of new words inside a record.  addressor must be in :write mode.
(defun open-gap (addressor start-of-gap size-of-gap)
  (let ((total-size-minus-1 (1- (get-record-size addressor))))
    (loop for source from (- total-size-minus-1 size-of-gap) by -1
	  for dest from total-size-minus-1 by -1
	  until (< source start-of-gap) do
      (setf (read-record-word addressor dest) (read-record-word addressor source)))))

;;; Close up a gap of unused words inside a record.  addressor must be in :write mode.
(defun close-gap (addressor start-of-gap size-of-gap)
  (let ((first-word-beyond-gap (+ start-of-gap size-of-gap)))
    (loop for source from first-word-beyond-gap
	  for dest from start-of-gap
	  repeat (- (get-record-size addressor) first-word-beyond-gap) do
      (setf (read-record-word addressor dest) (read-record-word addressor source)))))

;;; Given a tuple record, adjust the contents of the fixed words
;;; of the attribute values that live in the record.  Those fixed words
;;; that point past first-var-word are adjusted by delta-words.  tuple
;;; must be in :write mode.
(defun adjust-all-in-tuple (tuple relation-handle first-var-word delta-words)
  (dolist (a (relation-handle-list-of-attributes relation-handle))
    (let ((type (attribute-handle-type a))
	  (desc (attribute-handle-descriptor a))
	  (att-version (attribute-handle-layout-version a)))
      (when (and att-version
		 ( (tuple-version tuple) att-version)
		 (> (start-of-field type tuple desc) first-var-word))
	(adjust-variable-words type tuple desc delta-words)))))

;;; Given an entity in a domain, adjust the contents of the fixed words
;;; of the attribute values that live in the entity record.  Those fixed
;;; words that point past first-var-word are adjusted by delta-words.
;;; ent must be in :write mode.
(defun adjust-all-in-entity (ent domain-handle first-var-word delta-words)
  (dolist (r (domain-handle-relations-optimized-on domain-handle))
    (let ((soo-att (relation-handle-surrogate-optimized-on r)))
      (dolist (a (relation-handle-list-of-attributes r))
	(unless (eq a soo-att)
	  (let ((type (attribute-handle-type a))
		(desc (search-table-for-domain
			(attribute-handle-descriptor a)
			domain-handle))
		(att-version (search-table-for-domain (attribute-handle-layout-version a)
						      domain-handle :if-not-found nil)))
	    (when (and att-version
		       ( (local-entity-version ent) att-version)
		       (> (start-of-field type ent desc) first-var-word))
	      (adjust-variable-words type ent desc delta-words))))))))

;;; Put the value into the record, deallocating variable words used
;;; by the old value, and allocating new variable words for the new
;;; value.  The caller guarantees to upgrade the record.  addressor
;;; must be in :write mode.
(defun put-value (type value addressor descriptor database r-or-d-handle surrogate-p)
  (let ((old-start (start-of-field type addressor descriptor))
	(old-size (size-of-field type addressor descriptor)))
    (multiple-value-bind (new-size transition-table)
	(size-of-value type value old-start database)
      (cond ((= old-size new-size)		; Easy case
	     (write-value
	       type value addressor descriptor old-start database transition-table new-size))
	    (t
	     ;; Deallocate the variable words used by the old value.
	     (unless (zerop old-size)
	       (close-gap addressor old-start old-size))
	     ;; wasn't same size, so have to recompute size with new value of "free"
	     (let ((new-size (size-of-value type value (get-record-size addressor) database)))
	       (unless (zerop old-size)
		 (if surrogate-p
		     (adjust-all-in-entity
		       addressor r-or-d-handle old-start (- old-size))
		     (adjust-all-in-tuple
		       addressor r-or-d-handle old-start (- old-size))))
	       ;; Allocate room for the new value and write it.
	       (let ((new-total-size (adjust-record-size addressor (- new-size old-size))))
		 (write-value type value addressor descriptor
			      (- new-total-size new-size) database
			      transition-table new-size))))))))
;;; Group indexes.

(defun make-group-index (attribute-handle &key (average-size 5))
  (prepare-database (relation-handle-database (attribute-handle-relation attribute-handle)))
  (check-user-attribute-handle attribute-handle)
  (when (attribute-handle-group-index-offset attribute-handle)
    (model-error "There is already a group index on attribute ~S" attribute-handle))
  ;; if this is the soo-att then just return quietly.
  (when (eq (relation-handle-surrogate-optimized-on
	      (attribute-handle-relation attribute-handle))
	    attribute-handle)
    (return-from make-group-index t))
  (let* ((domain-handle (attribute-handle-type attribute-handle))
	 (database (domain-handle-database domain-handle)))
    (check-type domain-handle domain-handle)
    (unless (eq (relation-handle-database (attribute-handle-relation attribute-handle))
		database)
      (model-error "The attribute ~S cannot have a group index, because domain ~S is foreign"
		   attribute-handle domain-handle))
    (when (domain-handle-system-domain-p domain-handle)
      (model-error "The attribute ~S cannot have a group index, because ~S is a system domain"
		   attribute-handle domain-handle))
    (note-schema-modified database)
    ;; This is a special signal to compute-new-domain-layout, which will convert
    ;; this t into a number, and set up the attribute record.
    (setf (attribute-handle-group-index-offset attribute-handle) t)
    (setf (attribute-handle-group-index-average-size attribute-handle) average-size)
    (do-children (descendant domain-handle database)
      (with-record (dom (database-opening database)
			(handle-rid descendant) :write)
	(setf (domain-handle-new-layout-needed descendant) t)
	(setf (domain-new-layout-needed dom) 1))
      (push attribute-handle (domain-handle-group-indexed-attributes descendant)))
    (compute-new-domain-layout domain-handle)
    ;; Go over the tuples of the relation, if any, and build the
    ;; initial state of the index.
    (fill-new-group-index attribute-handle domain-handle))
  t)

;;; Find all tuples in the relation.  For every tuple
;;; where the value of the attribute is from the domain, that value is
;;; an entity, which must be upgraded if necessary and given a group
;;; index record if necessary.  Insert the tuple into the group
;;; record.  The caller guarantees that there is a group index on this attribute.
(defun fill-new-group-index (attribute-handle domain-handle)
  (let* ((relation-handle (attribute-handle-relation attribute-handle))
	 (opening (database-opening (domain-handle-database domain-handle)))
	 (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	 (desc (attribute-handle-descriptor attribute-handle))
	 (gio (attribute-handle-group-index-offset attribute-handle))
	 (att-version (attribute-handle-layout-version attribute-handle)))
    (map-over-tuples
      relation-handle
      #'(lambda (addressor rid version)
	  (insert-into-group-index-internal
	    addressor rid domain-handle desc att-version opening gio version soo-att
	    (attribute-handle-unique attribute-handle)
	    (attribute-handle-group-index-average-size attribute-handle))))))

(defun delete-group-index (attribute-handle)
  (check-user-attribute-handle attribute-handle)
  (let* ((gio (attribute-handle-group-index-offset attribute-handle))
	 (gilv (attribute-handle-group-index-layout-version attribute-handle))
	 (domain-handle (attribute-handle-type attribute-handle))
	 (database (domain-handle-database domain-handle))
	 (opening (database-opening database)))
    (prepare-database database)
    (unless gio (model-error "There is no group index on attribute ~S" attribute-handle))
    (note-schema-modified database)
    ;; Iterate over all entities of type domain-handle.
    (do-children (descendant domain-handle database)
      (let ((gio (search-table-for-domain gio descendant)))
	(map-over-entity-records
	  domain-handle
	  #'(lambda (ent-rid)
	      (with-record (ent opening ent-rid :write)
		(when (>= (local-entity-version ent) (search-table-for-domain gilv descendant))
		  (let ((gi-bid (read-record-word ent gio)))
		    (unless (zerop gi-bid)
		      (cond ((or (logbitp 31 gi-bid)
				 (attribute-handle-unique attribute-handle))
			     (setf (read-record-word ent gio) 0))
			    (t
			     (delete-bset-index opening gi-bid)
			     (setf (read-record-word ent gio) 0))))))))))
      (setf (domain-handle-group-indexed-attributes descendant)
	    (delete attribute-handle
		    (domain-handle-group-indexed-attributes descendant))))
    (setf (attribute-handle-group-index-offset attribute-handle) nil)
    (setf (attribute-handle-group-index-layout-version attribute-handle) nil)
    (setf (attribute-handle-group-index-average-size attribute-handle) 0)
    (with-record (att opening (handle-rid attribute-handle) :write)
      (let ((cons-rid (attribute-group-index-offset att)))
	(loop with next-rid = nil
	      until (zerop cons-rid) do
	  (with-record (cons opening cons-rid :read)
	    (setq next-rid (attribute-group-index-info-cons-next cons)))
	  (delete-record opening cons-rid)
	  (setq cons-rid next-rid)))
      (setf (attribute-group-index-offset att) 0)
      (setf (attribute-group-index-layout-version att) -1)
      (setf (attribute-group-index-average-size att) 0))
    t))

;;; If there is a group index for this attribute, add this record to it.
;;; There is a tuple being inserted here: addressor and rid indicate the record
;;; that it lives in, and relation-handle is its relation.  version is the version of
;;; the record.  attribute-handle is the attribute that we hope to find a group index on.
(defun insert-into-group-index (addressor rid relation-handle version attribute-handle)
  (let ((gio (attribute-handle-group-index-offset attribute-handle))
	(soo-att (relation-handle-surrogate-optimized-on relation-handle)))
    (when gio
      (insert-into-group-index-internal
	addressor
	rid
	(attribute-handle-type attribute-handle)
	(attribute-handle-descriptor attribute-handle)
	(attribute-handle-layout-version attribute-handle)
	(database-opening (relation-handle-database relation-handle))
	gio
	version
	soo-att
	(attribute-handle-unique attribute-handle)
	(attribute-handle-group-index-average-size attribute-handle)))))

;;; We have a tuple to be added to a group index.  addressor and rid indicate
;;; the record that the tuple lives in.  domain-handle is the type of the
;;; indexed attribute.  desc is the descriptor and att-version is the layout-version
;;; of the attribute.  opening is the usual thing.  gio is the group-index-offset of
;;; the attribute.  version is the version number of the record.  Note that the
;;; attribute-value in the tuple must either be the null value, or an entity
;;; of type domain-handle, and if it's the latter, that entity record points to the
;;; group index.
(defun insert-into-group-index-internal
       (addressor rid domain-handle desc att-version
	opening gio version soo-att att-unique avg-size)
  (let ((database (domain-handle-database domain-handle)))
    (when (and soo-att)
      (let ((ent-dom (find-domain-handle-given-entity-rid rid database)))
	(setq desc (search-table-for-domain desc ent-dom :if-not-found nil))
	(setq att-version (search-table-for-domain att-version ent-dom :if-not-found nil))))
    ;; If the value is null, this tuple doesn't go into the index at all.
    (unless (or (null desc)
		(null att-version)
		(< version att-version)
		(value-null-p domain-handle addressor desc))
      ;; This knowledge of how to get the ent-rid is a slight
      ;; unmodularity, but I can't see how there should be
      ;; another generic function on types to do this, and I
      ;; don't want to pay the expense of getting a handle.
      (let* ((ent-rid (read-record-word addressor desc))
	     (domain-handle (find-domain-handle-given-entity-rid ent-rid database)))
	(when (domain-handle-new-layout-needed domain-handle)
	  (compute-new-domain-layout domain-handle))
	(with-record (ent opening ent-rid :write)
	  ;; If the entity has an old version, bring it up to the current version.
	  (upgrade-entity ent domain-handle)
	  (let* ((gio (search-table-for-domain gio domain-handle))
		 (gi-bid (read-record-word ent gio)))
	    (cond ((or att-unique (zerop gi-bid))
		   (setf (read-record-word ent gio) (sys:%logdpb 1 (byte 1 31) rid)))
		  (t
		   (when (logbitp 31 gi-bid)
		     ;; This entity doesn't have a group-index record yet.
		     (let ((new-bid (make-bset-index opening :expected-size avg-size)))
		       (insert-bset-key opening new-bid (sys:%logdpb 0 (byte 1 31) gi-bid))
		       (setq gi-bid new-bid))
		     (setf (read-record-word ent gio) gi-bid))
		   (let ((new-bid (insert-bset-key opening gi-bid rid)))
		     (unless (= new-bid gi-bid)
		       (setf (read-record-word ent gio) new-bid)))))))))))

(defun delete-from-group-index (addressor rid relation-handle version attribute-handle)
  (let ((gio (attribute-handle-group-index-offset attribute-handle)))
    (when gio
      (let* ((domain-handle (attribute-handle-type attribute-handle))
	     (desc (attribute-handle-descriptor attribute-handle))
	     (att-version (attribute-handle-layout-version attribute-handle))
	     (database (relation-handle-database relation-handle))
	     (opening (database-opening database))
	     (soo-att (relation-handle-surrogate-optimized-on relation-handle))
	     (gilv (attribute-handle-group-index-layout-version attribute-handle)))
	(when soo-att
	  (let ((ent-dom (find-domain-handle-given-entity-rid rid database)))
	    (setq desc (search-table-for-domain desc ent-dom))
	    (setq att-version (search-table-for-domain att-version ent-dom
						       :if-not-found nil))))
	(unless (or (null att-version)
		    (< version att-version)
		    (value-null-p domain-handle addressor desc))
	  (let* ((ent-rid (read-record-word addressor desc))
		 (ent-dom (find-domain-handle-given-entity-rid ent-rid database)))
	    (with-record (ent opening ent-rid :read)
	      (when (>= (local-entity-version ent) (search-table-for-domain gilv ent-dom))
		(let* ((gio (search-table-for-domain gio ent-dom))
		       (gi-bid (read-record-word ent gio)))
		  ;; gi-bid is the record that holds the array of pointers.
		  (unless (zerop gi-bid)
		    (cond ((or (logbitp 31 gi-bid)
			       (attribute-handle-unique attribute-handle))
			   (upgrade-record-mode ent :write)
			   (setf (read-record-word ent gio) 0))
			  (t
			   (let ((new-bid (delete-bset-key opening gi-bid rid)))
			     (unless (= new-bid gi-bid)
			       (upgrade-record-mode ent :write)
			       (setf (read-record-word ent gio) new-bid)))))))))))))))
