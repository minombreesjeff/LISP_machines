;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice-model; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Miscellaneous utility functions for Statice model level.
 
;;; Get a new UID, and initialize the entity record.
(defun set-new-entity-uid (addressor entity-handle &optional w1 w2 w3)
  (unless w1
    (multiple-value-setq (w1 w2 w3) (uid:unique-id)))
  (setf (entity-uid-word-1 addressor) w1)
  (setf (entity-uid-word-2 addressor) w2)
  (setf (entity-uid-word-3 addressor) w3)
  (setf (entity-handle-uid-word-1 entity-handle) w1)
  (setf (entity-handle-uid-word-2 entity-handle) w2)
  (setf (entity-handle-uid-word-3 entity-handle) w3)
  nil)

;;; Copy a list, creating a new list out of normal conses to avoid
;;; cdr-coding.  This is useful when you know you're planning to delete
;;; a lot of elements.
(defun copy-list-simply (list)
  (when list
    (let* ((first-cons (cons (car list) nil))
	   (last-cons first-cons))
      (dolist (element (cdr list))
	(let ((new-cons (cons element nil)))
	  (setf (cdr last-cons) new-cons)
	  (setq last-cons new-cons)))
      first-cons)))

;;; Given a string, return the string that follows it in lexical order
;;; with the same length.  
(defun next-string (string)
  (when (equal string "")
    (return-from next-string nil))
  (let ((idx (1- (length string)))
	(new-string (cl:copy-seq string)))
    (setf (aref new-string idx)
	  (cl:code-char (1+ (char-code (aref new-string idx)))))
    new-string))

;;; Sort the list of indexes by the number of attributes, putting the indexes
;;; with the most attributes towards the beginning of the list.
(defun sort-list-of-indexes (index-handles)
  (sort index-handles
	#'(lambda (ih1 ih2)
	    (let ((loa1 (index-handle-list-of-attributes ih1))
		  (loa2 (index-handle-list-of-attributes ih2)))
	      (if (equal loa1 loa2)
		  (index-handle-case-sensitive ih1)
		  (> (length loa1) (length loa2)))))))

(defun nullify-tuple-handle (tuple-handle)
  (remhash (handle-rid tuple-handle) (tuple-handles))
  (setf (handle-rid tuple-handle) :deleted)
  t)

(defun nullify-entity-handle (entity-handle)
  (with-stack-list (key (handle-rid entity-handle)
			(domain-handle-database (known-entity-handle-domain entity-handle)))
    (cond ((fast-gethash key (new-entity-handles))
	   ;; Deleting an entity that was created during this transaction.
	   (setf (handle-rid entity-handle) :deleted)
	   (remhash key (new-entity-handles)))
	  (t
	   ;; Put it on the list of entities that were deleted during this transaction.
	   (setf (gethash (copy-list key) (deleted-entity-handles)) entity-handle))))
  ;; If caller tries to use it again, get an error in check-entity-handle.
  (remhash entity-handle (checked-entity-handles))
  t)

;;; If there is a handle for the known entity with this rid, nullify it.
;;; The caller has written in the local entity record, so this
;;; transaction has it locked.
(defun nullify-entity-given-rid (rid database)
    (let ((entity-handle
	    (or (with-stack-list (key rid database)
		  (fast-gethash key (new-entity-handles)))
		(with-database-known-entity-handles-lock (database)
		  (fast-gethash rid (database-known-entity-handles database))))))
      (when entity-handle
	(nullify-entity-handle entity-handle))))

;;; If there is a handle for the tuple with this rid, nullify it.
(defun nullify-tuple-given-rid (rid relation-handle)
  (remove-tuple-from-rid-arrays rid relation-handle)
  (let ((h (fast-gethash rid (tuple-handles))))
    (when (and h (eq (tuple-handle-relation h) relation-handle))
      (nullify-tuple-handle h)
      nil)))

(defun remove-tuple-from-rid-arrays (rid relation-handle)
  (loop for (rh rid-array) on *all-rid-arrays* by #'cddr do
    (when (eq rh relation-handle)
      (dotimes (i (length rid-array))
	(when (= (aref rid-array i) rid)
	  (setf (aref rid-array i) 0))))))

(defun find-domain-handle-given-name (name database)
  (or (fast-gethash name (database-table-of-domains database))
      (cl:error 'domain-not-found :database database :name name)))

(defun find-domain-handle-given-rid (rid database)
  (or (do-domains (d database)
	(when (= rid (handle-rid d))
	  (return d)))
      (error "Database ~S has no domain with rid ~S" database rid)))

(defun find-relation-handle-given-name (name database)
  (or (fast-gethash name (database-table-of-relations database))
      (error 'relation-not-found :database database :name name)))

(defun find-attribute-handle-given-name (name relation-handle)
  (or (dolist (a (relation-handle-list-of-attributes relation-handle))
	(when (string-equal name (attribute-handle-name a))
	  (return a)))
      (error 'attribute-not-found :relation relation-handle :name name)))

;;; Given the rid of a record (either a tuple record or a local
;;; entity record), and a relation, return a handle to the tuple
;;; thus uniquely described.
(defun find-tuple-handle-given-rid (rid relation-handle)
  (check-type relation-handle relation-handle)
  ;; See if a handle already exists.
  (or (let ((h (fast-gethash rid (tuple-handles))))
	(when (and h
		   (eq (tuple-handle-relation h) relation-handle))
	  h))
      ;; No, we have to create one.
      (let ((tuple-handle (make-tuple-handle rid relation-handle)))
	(setf (gethash rid (tuple-handles)) tuple-handle)
	tuple-handle)))

;;; Given a handle and a UID, is this an entity handle with that UID?
(defgeneric handle-uid-equal-p (entity-handle uid-word-1 uid-word-2 uid-word-3))

(defmethod handle-uid-equal-p ((handle entity-handle) w1 w2 w3)
  (with-slots (uid-word-1 uid-word-2 uid-word-3) handle
    (and (= uid-word-1 w1) (= uid-word-2 w2) (= uid-word-3 w3))))

(defmethod handle-uid-equal-p ((handle tuple-handle) w1 w2 w3)
  (declare (ignore w1 w2 w3))
  nil)

;;; Given the rid of an entity record, return a handle to the entity.
;;; The rid is within the given database.  This function is complicated
;;; because of concurrency issues: some other process might be doing
;;; find-entity-handle-given-rid on this same arguments.  Note that we
;;; must not hold the all-entity-handles lock while touching the
;;; database, which also means we must not hold it while we call
;;; see-if-known or find-entity-rid-given-uid.
(defun find-entity-handle-given-rid (ent-rid database)
  ;; See if a handle already exists.  First try the easy and fast case,
  ;; hoping to find a known-entity-handle with this RID in this database.
  (with-stack-list (key ent-rid database)
    ;; First try the table of entities created during this transaction.
    (let ((h (fast-gethash key (new-entity-handles))))
      (when h
	(return-from find-entity-handle-given-rid h)))
    ;; Then check the long-lived table of entity handles.
    ;; new-entity-handles takes precedence, in case a rid was freed
    ;; and then reallocated during the transaction.
    (let ((h (with-database-known-entity-handles-lock (database)
	       (let ((h (fast-gethash ent-rid (database-known-entity-handles database))))
		 (when h
		   (unless (fast-gethash h (checked-entity-handles))
		     (setf (gethash h (checked-entity-handles)) t))
		   h)))))
      (when h
	(cond ((fast-verify-uid-equal h database)
	       (return-from find-entity-handle-given-rid h))
	      (t
		(with-database-known-entity-handles-lock (database)
		  (when (eq h (fast-gethash ent-rid (database-known-entity-handles database)))
		    (remhash ent-rid (database-known-entity-handles database))
		    (remhash h (checked-entity-handles)))))))))
  ;; See comments below about the flag value.
  (multiple-value-bind (handle flag)
      (catch 'found
	(find-entity-handle-given-rid-part-2 ent-rid database))
    (when flag
      (see-if-we-know handle))
    handle))

;;; return t if the uid in the handle is the same as the uid in the
;;; entity-record at ent-rid.
(defun fast-verify-uid-equal (handle database)
  (sys:with-data-stack
    (let ((uid (read-multiple-record-word-given-rid (database-opening database)
						    (handle-rid handle)
						    (word-offset 'entity-uid-word-1)
						    (1+ (word-offset 'entity-uid-word-3)))))
      (declare (sys:array-register uid))
      (and (= (aref uid 0) (entity-handle-uid-word-1 handle))
	   (= (aref uid 1) (entity-handle-uid-word-2 handle))
	   (= (aref uid 2) (entity-handle-uid-word-3 handle))))))

;;; At this point, either there is no known-entity-handle for this
;;; entity, or this entity is foreign (or both).  To find out, we have
;;; to look inside the entity record itself.  Our caller has released
;;; the database-known-entity-handles lock, so we can touch the database.  The
;;; second returned value is a flag: true means call see-if-we-know on
;;; the returned handle.  This is weird modularity but necessary to get
;;; see-if-we-know called outside of the lock.
(defun find-entity-handle-given-rid-part-2 (ent-rid database)
  (let ((checked-entity-handles (checked-entity-handles)))
    (with-record (ent (database-opening database) ent-rid :read)
      (let ((w1 (entity-uid-word-1 ent))
	    (w2 (entity-uid-word-2 ent))
	    (w3 (entity-uid-word-3 ent))
	    (dom-rid (entity-domain ent)))
	(with-all-unknown-entity-handles-lock
	  (with-database-known-entity-handles-lock (database)
	    ;; At this point, some other process might have made an entity
	    ;; handle, so we have to check database-known-entity-handles again.
	    (let ((h (fast-gethash ent-rid (database-known-entity-handles database))))
	      (when h
		(unless (fast-gethash h checked-entity-handles)
		  (setf (gethash h checked-entity-handles) t))
		(throw 'found h)))
	    ;; OK, there's still nothing in the database-known-entity-handles table.
	    ;; Now, check whether the entity record was for a local entity
	    ;; or a foreign entity.
	    (when (not (zerop dom-rid))
	      ;; This is a local entity record, so the entity is known, but
	      ;; there's no handle yet.  The entity was not created by this
	      ;; transaction, because it was not on (new-entity-handles). 
	      ;; So make a new long-lived entity handle for it and return.
	      (let ((eh (make-new-entity-handle
			  ent-rid
			  (find-domain-handle-given-rid dom-rid database)
			  w1 w2 w3)))
		(setf (gethash ent-rid (database-known-entity-handles database)) eh)
		(setf (gethash eh checked-entity-handles) t)
		(throw 'found eh)))
	    ;; This is a foreign entity.  See if a known entity handle already exists.
	    (find-existing-entity-handle-for-foreign w1 w2 w3)
	    ;; Release the all-entities-handle lock at this point.
	    ))
	(find-entity-handle-given-rid-part-3
	  ent-rid database (foreign-entity-foreign-database ent) w1 w2 w3)))))

;;; See if there is already an entity handle for the entity.  If so,
;;; throw the handle to 'found, otherwise do nothing.  The caller
;;; asserts that the entity is foreign.  The caller is holding the
;;; all-unknown-entities-handle lock.
(defun find-existing-entity-handle-for-foreign (w1 w2 w3)
  (let ((checked-entity-handles (checked-entity-handles)))
    (with-open-database-lock
      (loop for database being the hash-values of *databases* do
	(with-database-known-entity-handles-lock (database)
	  (loop for h being the hash-values of (database-known-entity-handles database) do
	    (when (handle-uid-equal-p h w1 w2 w3)
	      (unless (fast-gethash h checked-entity-handles)
		(setf (gethash h checked-entity-handles) t))
	      (throw 'found h))))))
    ;; See if an unknown entity handle already exists.
    (with-stack-list (key w1 w2 w3)
      (let ((h (gethash key *all-unknown-entity-handles*)))
	(when h
	  (unless (fast-gethash h checked-entity-handles)
	    (setf (gethash h checked-entity-handles) t))
	  ;; If we've never seen this entity handle during this
	  ;; transaction, it might have become known.  So return
	  ;; a second value to t so that see-if-known is called.
	  (throw 'found (values h t)))))
    ;; See if we created the entity during this transaction.  Note
    ;; that the order in which we do these searches does not
    ;; matter the way it does way above, because the key is a
    ;; unique ID, and they cannot be reused.
    (loop for h being the hash-values of (new-entity-handles) do
      (when (handle-uid-equal-p h w1 w2 w3)
	(throw 'found h)))))


;;; At this point, we know that the entity is foreign and that there is
;;; no entity handle for it.  We don't know yet whether the new entity
;;; handle that we create ought to be known or not.  Actully we have
;;; released the all-entities-handle lock, so someone might make an
;;; entity handle while we're examining the database.
;;; foreign-database-rid is the RID of a foreign-database record
;;; describing the entity's home database.  w1 w2 w3 are the UID of the
;;; entity.
(defun find-entity-handle-given-rid-part-3 (ent-rid database foreign-database-rid w1 w2 w3)
  (let (fdw1 fdw2 fdw3)
    ;; Get the unique ID of the home database of the entity.
    (with-record (fd (database-opening database) foreign-database-rid :read)
      (setq fdw1 (foreign-database-uid-word-1 fd))
      (setq fdw2 (foreign-database-uid-word-2 fd))
      (setq fdw3 (foreign-database-uid-word-3 fd)))
    (let ((db (with-open-database-lock
		(with-stack-list (key fdw1 fdw2 fdw3)
		  (gethash key *databases-by-uid*)))))
      (cond (db
	     ;; We've found the home database.  The entity is
	     ;; foreign but known.
	     (multiple-value-bind (local-ent-rid dh)
		 (find-entity-rid-given-uid w1 w2 w3 db)
	       (unless local-ent-rid
		 (error 'foreign-entity-deleted
			:referencing-database database
			:home-database db))
	       (with-all-unknown-entity-handles-lock
		 (with-database-known-entity-handles-lock (database)
		   ;; See if someone created it while we were not holding the lock.
		   (find-existing-entity-handle-for-foreign w1 w2 w3)
		   (let ((eh (make-new-entity-handle local-ent-rid dh w1 w2 w3)))
		     ;; Hash it under its home address.
		     (setf (gethash ent-rid (database-known-entity-handles database)) eh)
		     (setf (gethash eh (checked-entity-handles)) t)
		     eh)))))
	    (t
	     ;; It is unknown.
	     (with-all-unknown-entity-handles-lock
	       ;; See if someone created it while we were not holding the lock.
	       (find-existing-entity-handle-for-foreign w1 w2 w3)
	       (let ((eh (make-unknown-entity-handle nil w1 w2 w3 fdw1 fdw2 fdw3)))
		 (setf (gethash (list w1 w2 w3) *all-unknown-entity-handles*) eh)
		 eh)))))))

;;; Given the unique ID of an entity, and the home database of the
;;; entity, find the local-entity-record of the entity in that database.
;;; Return the RID of the entity and the domain-handle of its domain, or
;;; NIL if not found.
(defun find-entity-rid-given-uid (w1 w2 w3 database)
  (declare (values entity-rid domain-handle))
  ;; Look in each domain of the home database to find its
  ;; local-entity-record in db.  Someday we should make this search use
  ;; an index, but right now it just works slowly.
  (let ((opening (database-opening database)))
    (do-domains (dh database)
      (map-over-entity-records
	dh
	#'(lambda (ent-rid)
	    (with-record (ent opening ent-rid :read)
	      (when (and (= (entity-uid-word-1 ent) w1)
			 (= (entity-uid-word-2 ent) w2)
			 (= (entity-uid-word-3 ent) w3))
		(return-from find-entity-rid-given-uid (values ent-rid dh)))))))))

;;; Given an unknown entity handle, see whether it is now known, because
;;; its home database has been opened since it was created.  If it is
;;; now known, make it known.  No returned value.  This function is
;;; complicated because of concurrency issues: some other process might
;;; be doing see-if-we-know on this same entity-handle.  Note that we
;;; must not hold the all-entity-handles lock while touching the
;;; database, which means we must not hold it while we call
;;; find-entity-rid-given-uid.  Also, since we do touch the database,
;;; our caller must not hold the all-entity-handles lock when calling us.
(defun see-if-we-know (entity-handle)
  (let ((home-database
	  ;; First get the UID of the database from the
	  ;; unknown-entity-handle.  This must be done under the
	  ;; protection of the all-entity-handles lock to make sure the
	  ;; handle stays unknown while we examine it.
	  (let (db-uid-word-1 db-uid-word-2 db-uid-word-3)
	    (with-all-unknown-entity-handles-lock
	      ;; Make sure that entity-handle is still unknown.
	      (when (typep entity-handle 'known-entity-handle)
		;; Someone has already made it known.  Punt.
		(return-from see-if-we-know nil))
	      (setq db-uid-word-1 (unknown-entity-handle-db-uid-word-1 entity-handle)
		    db-uid-word-2 (unknown-entity-handle-db-uid-word-2 entity-handle)
		    db-uid-word-3 (unknown-entity-handle-db-uid-word-3 entity-handle)))
	    ;; Look up the UID of the database in *databases-by-uid*
	    ;; to see whether it has appeared since this handle was created.
	    (with-open-database-lock
	      (with-stack-list (key db-uid-word-1 db-uid-word-2 db-uid-word-3)
		(gethash key *databases-by-uid*))))))
    (when home-database
      ;; The unknown becomes known.  Search through the home database
      ;; for the entity record whose UID matches, finding the RID and
      ;; the domain handle.
      (let ((uid1 (entity-handle-uid-word-1 entity-handle))
	    (uid2 (entity-handle-uid-word-2 entity-handle))
	    (uid3 (entity-handle-uid-word-3 entity-handle)))
	(multiple-value-bind (entity-rid domain-handle)
	    (find-entity-rid-given-uid uid1 uid2 uid3 home-database)
	  (with-all-unknown-entity-handles-lock
	    ;; Make sure that entity-handle is still unknown.
	    (when (typep entity-handle 'known-entity-handle)
	      ;; Someone has already made it known.  Punt.
	      (return-from see-if-we-know nil))
	    ;; It's still an unknown-entity-handle but it's known.
	    ;; Go ahead and actually "commit" the deed.
	    (remhash (list uid1 uid2 uid3) *all-unknown-entity-handles*)
	    (change-class entity-handle 'known-entity-handle)
	    (setf (handle-rid entity-handle) entity-rid)
	    (setf (known-entity-handle-domain entity-handle) domain-handle)
	    (with-database-known-entity-handles-lock (home-database)
	      (setf (gethash entity-rid (database-known-entity-handles home-database))
		    entity-handle))))))))

;;; ent-rid is the RID of a local-entity record in the given database.
;;; Return the domain-handle of the domain of the entity.
(defun find-domain-handle-given-entity-rid (ent-rid database)
  (known-entity-handle-domain (find-entity-handle-given-rid ent-rid database)))

#||
;;; Leave this here for now so I can look at it more closely later -- DLW 3/29/88
(defun old-find-domain-handle-given-entity-rid (ent-rid database)
  (with-database-known-entity-handles-lock (database)
    ;; See if a known-entity-handle already exists for the entity.
    ;; First try the easy and fast case, hoping to find a
    ;; known-entity-handle with this RID in this database.
    (with-stack-list (key ent-rid database)
      ;; First try the table of entities created during this transaction.
      (let ((h (fast-gethash key (new-entity-handles))))
	(when h
	  (return-from find-domain-handle-given-entity-rid (known-entity-handle-domain h))))
      ;; Then check the long-lived table of entity handles.
      (let ((h (fast-gethash ent-rid (database-known-entity-handles database))))
	(when h
	  (return-from find-domain-handle-given-entity-rid (known-entity-handle-domain h))))))
  ;; At this point, we have a local-entity for which no handle exists.
  ;; So do it the slow way: get the domain's RID, and work from there.
  ;; It's OK to release the all-entity-handles-lock at this point
  ;; because the above was only a most-common-case accelerator.
  (with-record (ent (database-opening database) ent-rid :read)
    (find-domain-handle-given-rid (entity-domain ent) database)))
||#

;;; Functions to check arguments passed into Model Level.
(defsubst check-transaction ()
  (compiler:%error-unless *transaction-info*
    (cl:error 'not-inside-transaction)))

(defsubst restart-testing-check ()
  (compiler:%error-when *restart-testing* (restart-testing-check-internal)))

(defun restart-testing-check-internal ()
  (let ((info *transaction-info*))
    (cond ((< (current-entry-number info) (entry-number-to-abort-on info))
	   (incf (current-entry-number info)))
	  (t
	   (setf (current-entry-number info) 0)
	   (incf (entry-number-to-abort-on info))
	   (dbfs:abort-transaction :error 'restart-testing-restartable-abort)))))

;;; Make sure the argument is a tuple handle, from this transaction.
(defun check-tuple-handle (handle)
  (check-transaction)
  (let ((htid (tuple-handle-transaction-id handle)))
    (unless (eql (transaction-id) htid)
      (model-error "Handle ~S is from transaction ~S, but this is transaction ~S"
		   handle htid (transaction-id))))
  (check-type handle tuple-handle)
  (when (eq (handle-rid handle) :deleted)
    (model-error "The tuple referred to by ~S has been deleted." handle)))

;;; Make sure it's not a system relation.
(defun check-user-tuple-handle (handle)
  (check-tuple-handle handle)
  (let* ((relation-handle (tuple-handle-relation handle)))
    (when (relation-handle-system-relation-p relation-handle)
      (model-error "~S is a tuple of the ~A system relation; invalid"
	     handle (relation-handle-name relation-handle)))))

;;; Make sure the argument is an entity handle, from this transaction.
(defun check-entity-handle (handle)
  (check-transaction)
  (check-type handle entity-handle)
  (let ((rid (handle-rid handle)))
    (when (eq rid :deleted)
      (error 'entity-handle-deleted :entity-handle handle))
    (unless (fast-gethash handle (checked-entity-handles))
      (when (null rid)
	;; This unknown entity handle has never been used in this
	;; transaction before.  It might have become known in the
	;; meantime, if a database was opened.
	(see-if-we-know handle))
      ;; The rid of the handle could have been changed by that.
      (setq rid (handle-rid handle))
      ;; This entity handle has never been used in this transaction
      ;; before.  Make sure it hasn't been deleted since last time.
      ;; Note: unknown entity handles are always considered valid.
      (unless (null rid)
	(let* ((domain-handle (known-entity-handle-domain handle))
	       (database (domain-handle-database domain-handle))
	       (opening (database-opening database)))
	  (cond ((listp opening)
		 (error 'database-terminated :function (first opening) :time (second opening)))
		((with-stack-list (key rid database)
		   (fast-gethash key (deleted-entity-handles)))
		 ;; This entity was created and deleted during this transaction.
		 (error 'entity-handle-deleted :entity-handle handle))
		;; Any schema entity that reaches this point must still
		;; exist, because of the lock on the schema cache.
		((not (eq (entity-type-of-internal handle) :entity)))
		;; Make sure that the RID still points to a valid record.
		((and (validate-rid opening rid)
		      ;; It does.  Examine the record; does it look right?
		      (with-record (ent opening rid :read)
			(and (>= (get-record-size ent) (record-size local-entity))
			     (= (entity-uid-word-1 ent) (entity-handle-uid-word-1 handle))
			     (= (entity-uid-word-2 ent) (entity-handle-uid-word-2 handle))
			     (= (entity-uid-word-3 ent) (entity-handle-uid-word-3 handle))
			     (= (entity-domain ent) (handle-rid domain-handle)))))
		 ;; OK, it checks out.
		 (setf (gethash handle (checked-entity-handles)) t))
		((with-database-known-entity-handles-lock (database)
		   (fast-gethash rid (database-known-entity-handles database)))
		 (error 'entity-handle-deleted :entity-handle handle))
		(t
		 ;; A weird one.  Must be "uncommitted".
		 (error 'entity-handle-not-committed :entity-handle handle))))))))

;;; Make sure it's not from a system domain.
;;; NOTE: Unknown entities always pass this test.  I'm not sure if that's
;;; right in general, but the only current case is delete-entity.
(defun check-user-entity-handle (handle)
  (check-entity-handle handle)
  (when (and (typep handle 'known-entity-handle)
	     (domain-handle-system-domain-p (known-entity-handle-domain handle)))
    (model-error "~S is an entity of the ~A system domain; invalid"
	   handle (domain-handle-name (known-entity-handle-domain handle)))))

;;; Make sure the argument is a domain handle, from this transaction.
(defun check-domain-handle (handle)
  (check-entity-handle handle)
  (check-type handle domain-handle))

(defun check-user-domain-handle (handle)
  (check-domain-handle handle)
  (when (domain-handle-system-domain-p handle)
    (model-error "~A is a system domain; invalid" (domain-handle-name handle))))

;;; Make sure the argument is a relation handle, from this transaction.
(defun check-relation-handle (handle)
  (check-entity-handle handle)
  (check-type handle relation-handle))

(defun check-user-relation-handle (handle)
  (check-relation-handle handle)
  (when (relation-handle-system-relation-p handle)
    (model-error "~A is a system relation; invalid" (relation-handle-name handle))))

;;; Make sure the argument is an attribute handle, from this transaction.
(defun check-attribute-handle (handle)
  (check-entity-handle handle)
  (check-type handle attribute-handle))

;;; Make sure it's not an attribute of a system relation.
(defun check-user-attribute-handle (handle)
  (check-attribute-handle handle)
  (let* ((relation-handle (attribute-handle-relation handle)))
    (when (relation-handle-system-relation-p relation-handle)
      (model-error "~S is an attribute of the ~A system relation; invalid"
	     handle (relation-handle-name relation-handle)))))

;;; Given a descriptor table and a domain, search through the table for the entry, and
;;; return the descriptor part.  If table is nil, return nil; this can happen if we
;;; do a make-attribute and then immediately give it to get-value before a new layout
;;; is computed, in which case the table for attribute-layout-version has not been
;;; created yet.  The :if-not-found argument is often used with attribute-layout-version,
;;; because it can happen if an attribute exists but has not been assigned any version
;;; number yet (we are in the "new version needed" state) because no values have been
;;; stored yet.
(defun search-table-for-domain (table domain &key (if-not-found :error))
  (when table
    (or (let ((array table))
	  (declare (sys:array-register array))
	  (cl:dotimes (i (length array))
	    (let* ((a-cell (aref array i))
		   (domain-entry (car a-cell)))
	      (when (or (eq domain-entry domain) (eq domain-entry 'any-domain))
		(return (cdr a-cell))))))
	(cl:ecase if-not-found
	  ((nil))
	  (:error (cl:error "~S not found in descriptor table ~S" domain table))))))

;;; Given a RID to a foreign-database record, decrement its reference
;;; count.  If the reference count goes to zero, delete the record.
(defun downreference-foreign-database (fd-rid database)
  (let ((opening (database-opening database)))
    (with-record (fd opening fd-rid :write)
      (let ((count (- (foreign-database-reference-count fd) 1)))
	(cond ((plusp count)
	       (setf (foreign-database-reference-count fd) count))
	      (t
	       ;; Count is zero.  Delete the record.
	       (let ((next-fd (foreign-database-next fd))
		     (previous-fd (foreign-database-previous fd)))
		 (unless (zerop previous-fd)
		   (with-record (prev opening previous-fd :write)
		     (setf (foreign-database-next prev) next-fd)))
		 (unless (zerop next-fd)
		   (with-record (next opening next-fd :write)
		     (setf (foreign-database-previous next) previous-fd)))
		 (with-record (header opening
				      (database-rid-of-header database)
				      :write) ;;Used to be :probable-write
		  ;; ++ OPEN-RECORD never has supported :probable-write.
		  ;; Furthermore, DBFS's current implementation of
		  ;; :probable-write is not exclusive against
		  ;; pure read lockers.
		   (when (= (database-header-list-of-foreign-databases header) fd-rid)
		     (upgrade-record-mode header :write)
		     (setf (database-header-list-of-foreign-databases header) next-fd))))
	       (delete-record opening fd-rid)))))))

(defmethod clos:initialize-instance :after ((handle entity-handle) &key &allow-other-keys)
  (setf (gethash handle (checked-entity-handles)) t))

;;; +++ The database-package-lock ought to be ordered with respect to
;;; DBFS page locks, to avoid deadlocks.  As it is now, deadlocks could
;;; occur.  The symptom you'd see would be that one of the processes is
;;; waiting forever for a database-package-lock and another is holding
;;; the lock and waiting inside DBFS.  In practice, this is unlikely to
;;; arise, but this should be fixed eventually. -- DLW 1/7/88

;;; Given a Lisp symbol, return the numeric encoding of the package of
;;; the symbol.
(defun encode-package (symbol database)
  (let ((package (symbol-package symbol)))
    (or (position package *commonly-used-packages*)
	(+ *number-of-commonly-used-packages*
	   ;; The package isn't one of the commonly-used ones.  See if it's
	   ;; in the package vector.
	   (process:with-lock ((database-package-lock database))
	     (let ((package-name-table (database-package-name-table database)))
	       (unless package-name-table
		 (initialize-package-structures database)
		 (setq package-name-table (database-package-name-table database)))
	       (cond ((cl:gethash (cl:package-name package) package-name-table))
		     (t
		      ;; The package was not found in the virtual-memory
		      ;; package-name-table.  Update the virtual-memory
		      ;; structures from the database and try again.
		      (update-package-structures database)
		      (or (cl:gethash (cl:package-name package) package-name-table)
			  ;; The package really isn't known by the
			  ;; database.  Add it.
			  (insert-new-package package database))))))))))

;;; Given the numeric encoding of a package, return the Lisp package.
;;; If symbol-print-name is true, use it for resignalling errors.
(defun decode-package (code database &optional symbol-print-name)
  (if (< code *number-of-commonly-used-packages*)
      (aref *commonly-used-packages* code)
      ;; It's not one of the commonly used packages.
      (process:with-lock ((database-package-lock database))
	(let ((package-vector (database-package-vector database)))
	  ;; Initialize the package structures if this is the first time.
	  (unless package-vector
	    (initialize-package-structures database)
	    (setq package-vector (database-package-vector database)))
	  (let ((vector-index (- code *number-of-commonly-used-packages*)))
	    ;; If the index is greater than the fill-pointer, some other
	    ;; host must have added new packages since we last initialized
	    ;; or updated the package structures.
	    (when ( vector-index (fill-pointer package-vector))
	      (update-package-structures database))
	    ;; At this point, the name vector is fully up-to-date, but
	    ;; possibly this package name has never been looked up
	    ;; before with pkg-find-package.
	    (or (aref package-vector vector-index)
		;; The package name has not yet been looked up.
		(let ((package
			(block use-this-package
			  (flet
			    ((pnf (err)
			       (return-from use-this-package
				 (scl:signal-proceed-case
				   ((val) 'symbol-package-not-found
				    :name (send err :name)
				    :relative-to (send err :relative-to)
				    :print-name symbol-print-name)
				   (:create-package
				     (si:make-package-for-syntax (send err :name) :use val))
				   (:new-name
				     (scl:pkg-find-package val
						       :error
						       (send err :relative-to)))
				   (:no-action
				     (scl:pkg-find-package (send err :name)
						       :error
						       (send err :relative-to)))))))
			    (scl:condition-bind-default-if symbol-print-name
						       ((sys:package-not-found #'pnf))
			      (scl:pkg-find-package
				(aref (database-package-name-vector database)
				      vector-index)))))))
		  (setf (aref package-vector vector-index) package)
		  package)))))))

;;; Given the numeric encoding of a package, return the name of the Lisp
;;; package.  This must work even if the package by that name does not
;;; exist in the Lisp world.
(defun decode-package-name (code database)
  (if (< code *number-of-commonly-used-packages*)
      (cl:package-name (aref *commonly-used-packages* code))
      ;; It's not one of the commonly used packages.
      (process:with-lock ((database-package-lock database))
	(let ((package-name-vector (database-package-name-vector database)))
	  ;; Initialize the package structures if this is the first time.
	  (unless package-name-vector
	    (initialize-package-structures database)
	    (setq package-name-vector (database-package-name-vector database)))
	  (let ((vector-index (- code *number-of-commonly-used-packages*)))
	    ;; If the index is greater than the fill-pointer, some other
	    ;; host must have added new packages since we last initialized
	    ;; or updated the package structures.
	    (when ( vector-index (fill-pointer package-name-vector))
	      (update-package-structures database))
	    ;; Now we know that the name vector is fully up-to-date.
	    (aref package-name-vector vector-index))))))

;;; Set up the package-xxx instance variables of the database instance
;;; from the package vector in the real database.  This gets called the
;;; first time anybody cares about packages for this database, and never
;;; again for this database.  The caller must lock the database-package-lock.
(defun initialize-package-structures (database)
  (let* ((opening (database-opening database))
	 (pv-rid (with-record (db opening (database-rid-of-header database) :read)
		   (database-header-package-vector db))))
    (cond ((zerop pv-rid)
	   ;; There are no packages at all yet.
	   (setf (database-package-vector database) (cl:make-array 10 :fill-pointer 0))
	   (setf (database-package-name-vector database) (cl:make-array 10 :fill-pointer 0))
	   (setf (database-package-name-table database)
		 (cl:make-hash-table :locking nil :test 'string-equal))
	   (setq pv-rid (make-record opening (+ 10 (record-size package-vector))))
	   (with-record (pv opening pv-rid :write)
	     (setf (package-vector-mbza pv) 0)
	     (setf (package-vector-fill-pointer pv) 0))
	   (with-record (db opening (database-rid-of-header database) :write)
	     (setf (database-header-package-vector db) pv-rid)))
	  (t
	   (with-record (pv opening pv-rid :read)
	     (let* ((n-packages (package-vector-fill-pointer pv))
		    (package-vector (cl:make-array n-packages
						:fill-pointer n-packages
						:initial-element nil))
		    (package-name-vector (cl:make-array n-packages
						     :fill-pointer n-packages))
		    (package-name-table (cl:make-hash-table :locking nil :test 'string-equal)))
	       (cl:dotimes (index n-packages)
		 (let ((ps-rid (read-record-word pv (+ index (record-size package-vector)))))
		   (with-record (ps opening ps-rid :read)
		     (let* ((length (package-string-length ps))
			    (name (read-string-from-record
				    ps length (record-size package-string))))
		       (setf (aref package-name-vector index) name)
		       (setf (cl:gethash name package-name-table) index)))))
	       (setf (database-package-vector database) package-vector)
	       (setf (database-package-name-vector database) package-name-vector)
	       (setf (database-package-name-table database) package-name-table)))))))

;;; Make sure that the package structures in virtual memory are up to
;;; date; some other host might have added new packages.  The contract
;;; of this function is that whatever the situation is before it is
;;; called, it promises that after it is called, the virtual memory
;;; structure reflects properly the state of the database.  The caller
;;; only promises that the package structures are initialized in the
;;; database and in virtual memory (the arrays have been created, etc).
;;; The caller must lock the database-package-lock.
(defun update-package-structures (database)
  (let* ((opening (database-opening database))
	 (pv-rid (with-record (db opening (database-rid-of-header database) :read)
		   (database-header-package-vector db))))
    (unless (zerop pv-rid)
      (with-record (pv opening pv-rid :read)
	(let* ((package-vector (database-package-vector database))
	       (package-name-vector (database-package-name-vector database))
	       (package-name-table (database-package-name-table database))
	       (old-n-packages (fill-pointer package-vector))
	       (new-n-packages (package-vector-fill-pointer pv)))
	  (unless (= old-n-packages new-n-packages)
	    ;; Grow the vectors large enough to hold the new packages,
	    ;; plus some room for future growth.
	    (cl:adjust-array package-vector (+ new-n-packages 5))
	    (cl:adjust-array package-name-vector (+ new-n-packages 5))
	    (cl:loop for index from old-n-packages below new-n-packages do
	      (let ((ps-rid (read-record-word pv (+ index (record-size package-vector)))))
		(with-record (ps opening ps-rid :read)
		  (let* ((length (package-string-length ps))
			 (name (read-string-from-record
				 ps length (record-size package-string))))
		    (setf (aref package-vector index) nil)
		    (setf (aref package-name-vector index) name)
		    (setf (cl:gethash name package-name-table) index)))))
	    (setf (fill-pointer package-vector) new-n-packages)
	    (setf (fill-pointer package-name-vector) new-n-packages)))))))

;;; The caller guarantees that this package is not included in the
;;; package vector of this database.  The caller also guarantees that
;;; the database's package structure has been initialized and has been
;;; updated, and so corresponds to what's really in the database.  Put
;;; it in, and return the index into the vector of the package name.
;;; The caller must lock the database-package-lock.
(defun insert-new-package (package database)
  (let* ((opening (database-opening database))
	 (pv-rid (with-record (db opening (database-rid-of-header database) :read)
		   (database-header-package-vector db))))
    ;;Caller is supposed to make sure structures are initialized, but a transaction
    ;;abort could leave VM structures inconsistent.
    (when (zerop pv-rid)
      (initialize-package-structures database)
      (setf pv-rid
	    (with-record (db opening (database-rid-of-header database) :read)
		   (database-header-package-vector db))))
    (with-record (pv opening pv-rid :write)
      (let ((n-packages (package-vector-fill-pointer pv))
	    (rec-size (get-record-size pv)))
	;; If more room is needed, grow the record.
	(when ( n-packages rec-size)
	  (adjust-record-size pv rec-size))
	(let* ((name (cl:package-name package))
	       (length (string-length name))
	       (package-vector (database-package-vector database))
	       (package-name-vector (database-package-name-vector database))
	       (package-name-table (database-package-name-table database))
	       (n-packages+1 (1+ n-packages))
	       (ps-rid (make-record opening
				    (+ (ceiling length 4) (record-size package-string)))))
	  (with-record (ps opening ps-rid :write)
	    (setf (package-string-mbza ps) 0)
	    (setf (package-string-length ps) length)
	    (write-string-to-record ps length (record-size package-string) name))
	  (setf (read-record-word pv (+ n-packages (record-size package-vector))) ps-rid)
	  ;;Be sure to trigger a schema recache if this transaction is aborted.  Otherwise
	  ;;we will blithly use an integer to represent a package which is not encoded
	  ;;persistently in the database.  -- Feinberg 9/6/91
	  (note-schema-modified database)
	  (vector-push-extend package package-vector 5)
	  (vector-push-extend name package-name-vector 5)
	  (setf (cl:gethash name package-name-table) n-packages)
	  (setf (package-vector-fill-pointer pv) n-packages+1)
	  n-packages)))))
