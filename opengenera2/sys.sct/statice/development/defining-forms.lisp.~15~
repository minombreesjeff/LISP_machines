;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; DEFINE-SCHEMA, DEFINE-ENTITY-TYPE, and friends...

(defmacro define-schema (schema-name entity-types)
  (when (and (listp schema-name)
	     (eq (first schema-name) 'quote))
    (warn "The schema-name in define-schema, ~S, should not be quoted." schema-name)
    (setq schema-name (second schema-name)))
  (when (and (listp entity-types)
	     (eq (first entity-types) 'quote)
	     (listp (second entity-types)))
    (warn "The entity-types list given to define-schema, ~S, should not be quoted."
	  entity-types)
    (setq entity-types (second entity-types)))
  (check-type schema-name symbol)
  (check-type entity-types list)
  (dolist (tn entity-types)
    (unless (symbolp tn)
      (cl:error "~S, in the list of entity types, is not a symbol" tn)))
  `(eval-when (compile load eval)
     (define-schema-internal ',schema-name ',entity-types)))

;;; Make one of our internally-used tag symbols.  The user never sees these.
(defun make-tag-symbol (base-symbol suffix-string)
  (intern (string-append base-symbol suffix-string)))

(defun forbid-reserved-name (symbol what)
  (let ((pname (string symbol)))
    (when (and (>= (string-length pname) 2)
	       (or (string-equal pname "%%" :start1 0 :end1 2)
		   (string-equal pname "%$" :start1 0 :end1 2)))
      (cl:error "The ~A name ~S is invalid, because names starting with ~S are reserved"
	     what pname (substring pname 0 2)))))


(defmacro define-entity-type (type-name parent-types function-clauses &rest options)
  (when (and (listp type-name)
	     (eq (first type-name) 'quote))
    (warn "The type-name in define-entity-type, ~S, should not be quoted." type-name)
    (setq type-name (second type-name)))
  (check-type type-name symbol)
  (check-type parent-types list)
  (check-type function-clauses list)
  (forbid-reserved-name type-name "type")
  (dolist (p parent-types)
    (when (null p)
      (error "In define-entity-type of ~S, NIL is not a valid parent type" type-name))
    (when (listp p)
      (error "In define-entity-type of ~S, the list ~S was found as an element of the~@
              parent-list, where a symbol was expected.  Perhaps you omitted the parent list."
	     type-name p))
    (unless (symbolp p)
      (error "In define-entity-type of ~S, ~S was found as an element of the~@
              parent-list, where a symbol was expected." type-name p)))
  ;; Check for a particular syntax error that's easy to fall into.
  (when (and (= (length function-clauses) 1)
	     (plusp (length options))
	     (listp (first options))
	     (not (null (first (first options))))
	     (not (keywordp (first (first options)))))
    (error "~S is not valid define-entity-type option.~@
             If you intended that ~S be the name of an attribute,~@
             perhaps you have put in too many parentheses."
	   (first (first options)) (first (first options))))
  (let ((functions (gentemp "FUNCTIONS"))
	(conc-name nil)
	(multiple-indexes nil)
	(type-area-name nil)
	(type-set t)
	(documentation nil)
	(constructor nil)
	(own-cluster nil)
	(default-initargs nil)
	(init-keywords nil)
	(instance-variables nil))
    ;; Pre-scan the type options to get information needed by function definition.
    (dolist (option options)
      (let ((option-keyword-name (first option)))
	;; Introduce this variable just to make the ecase error message
	;; more expresive.
	(ecase option-keyword-name
	  (:conc-name (setq conc-name (string (or (second option) ""))))
	  (:multiple-index
	    (destructuring-bind (slot-names &key unique) (rest option)
	      (push (list slot-names unique) multiple-indexes)))
	  (:multiple-index-exact
	    (destructuring-bind (slot-names &key unique) (rest option)
	      (push (list slot-names unique t) multiple-indexes)))
	  (:area (setq type-area-name (second option)))
	  (:own-cluster (setq own-cluster (second option)))
	  (:type-set (setq type-set (second option)))
	  (:documentation (setq documentation (second option)))
	  (:constructor (setq constructor (second option)))
	  (:instance-variables (setq instance-variables (rest option)))
	  (:default-initargs (setq default-initargs (rest option)))
	  (:init-keywords (setq init-keywords (rest option))))))
    (unless conc-name (setq conc-name (string-append type-name "-")))
    ;; Define the functions.
    (let* ((domain-tag   (make-tag-symbol type-name "-D"))
	   (relation-tag (make-tag-symbol type-name "-R"))
	   (soo-att-tag  (make-tag-symbol type-name "-SA"))
	   (all-cache-related-instance-variables nil)
	   (cache-value-instance-variables nil)
	   (inside-forms nil)
	   (top-forms nil))
      (dolist (clause function-clauses)
	;; iv-list is all cache-names (%$iv's to hold values) and all
	;; %$foo-not-null-p iv's.  accessor-name is the name of the
	;; accessor function.  transaction-iv is the %$foo-transaction-iv
	;; name.
	(multiple-value-bind (if tf iv-list accessor-name transaction-iv cache-group-name)
	    (process-function clause type-name functions conc-name
			      type-area-name relation-tag soo-att-tag)
	  (setq inside-forms (nconc inside-forms if)
		top-forms (nconc top-forms tf))
	  (when iv-list
	    (push (list accessor-name cache-group-name transaction-iv)
		  cache-value-instance-variables)
	    (setq all-cache-related-instance-variables
		  (nconc all-cache-related-instance-variables iv-list)))))
      (when all-cache-related-instance-variables
	(let (load-forms load-all-forms upd-trn-forms upd-all-trn-forms)
	  (loop for (accessor-name cache-group-name transaction-slot)
		    in cache-value-instance-variables do
	    (cond ((eq t cache-group-name)
		   (push `(,accessor-name entity :force-refresh t) load-all-forms)
		   (push `(setf (slot-value entity ',transaction-slot)
				transaction-id)
			 upd-all-trn-forms))
		  (t
		   (cond ((assoc cache-group-name load-forms)
			  (push `(,accessor-name entity :force-refresh t)
				(cdr (assoc cache-group-name load-forms)))
			  (push `(setf (slot-value entity ',transaction-slot)
				       transaction-id)
				(cdr (assoc cache-group-name upd-trn-forms))))
			 (t
			  (push (list cache-group-name `(,accessor-name entity :force-refresh t))
				load-forms)
			  (push (list cache-group-name
				      `(setf (slot-value entity ',transaction-slot)
					     transaction-id))
				upd-trn-forms))))))
	  (push `(defmethod load-entity progn ((entity ,type-name) group-name)
		   ,@load-all-forms
		   (case group-name
		     . ,load-forms))
		top-forms)
	  (push `(defmethod update-transaction-tags progn ((entity ,type-name) group-name)
		   (let ((transaction-id (dbfs:current-transaction-id)))
		     ,@upd-all-trn-forms
		     (case group-name
		       . ,upd-trn-forms)))
		top-forms)
	  (push `(defmethod make-group-map nconc ((entity ,type-name))
		   (list ,@(loop for (group-name) in load-forms
				 collect `',group-name)))
		top-forms)
	  (push `(defmethod map-group-name ((entity ,type-name) group-name)
		   (let ((group-map (or (get ',type-name 'group-map)
					;; damn it -- this has to go on the database object
					(setf (get ',type-name 'group-map)
					      (nreverse (make-group-map entity))))))
		     (values (position group-name group-map) (length group-map))))
		top-forms)))
      (push `(invalidate-schema-tables ',type-name) top-forms)
      (push `(record-source-file-name ',type-name 'define-entity-type) top-forms)
      (let* ((make-string (if constructor
			      (string constructor)
			      (string-append "MAKE-" type-name)))
	     (make-symbol (or constructor (intern make-string)))
	     (make-macro-symbol (intern (string-append make-string "-MACRO"))))
	(push `(defmacro ,make-macro-symbol (&rest keywords-and-values)
		 (declare (sys:function-parent ,type-name define-entity-type))
		 (make-functional-entity-maker ',type-name keywords-and-values))
	      top-forms)
	(push `(compiler:add-optimizer ,make-symbol make-xxx-optimizer) top-forms)
	(push `(setf (get ',type-name 'statice::make-symbol) ',make-symbol) top-forms)
	(push `(setf (get ',type-name 'statice::make-macro-symbol) ',make-macro-symbol) top-forms)
	(push `(setf (get ',make-symbol 'entity-type) ',type-name) top-forms)
	(push `(defun ,make-symbol (&rest keywords-and-values)
		 (declare (sys:function-parent ,type-name define-entity-type))
		 (declare (compiler:arglist-finder get-type-maker-arglist))
		 (apply #'make-entity ',type-name keywords-and-values))
	      top-forms))
      (setq inside-forms
	    ;; This has to be after the processed functions, so that the
	    ;; "functions" variable will be set up.
	    (nconc 
	      inside-forms
	      (let ((etvar (gentemp "ENTITY-TYPE-")))
		`((let* ((,etvar
			  (flavor:make-instance
			    'template-entity-type
			    :name ',type-name
			    :parent-names ',parent-types
			    :functions ,functions
			    :area-name ',type-area-name
			    :set-exists ,type-set
			    :own-cluster ,own-cluster
			    :conc-name ,conc-name
			    :domain-tag ',domain-tag
			    :relation-tag ',relation-tag
			    :soo-att-tag ',soo-att-tag
			    :flavor-keywords 
			    ',(append init-keywords
				      (loop for (iv) in instance-variables
					    collect (intern (string iv)
							    si:pkg-keyword-package))))))
		    (setf (type-multiple-indexes ,etvar)
			  (list . ,(loop for mi in multiple-indexes
					 collect `(flavor:make-instance
						    'template-multiple-index
						    :type ,etvar
						    :slot-names ',(first mi)
						    :unique ',(second mi)
						    :case-sensitive ',(third mi)))))
		    (setf (get ',type-name 'entity-type) ,etvar))))))
      (push
	;; This has to be before the processed functions, because you
	;; have to define the class before you can define its methods.
	`(defclass ,type-name
	    ;; Component classes
	    ,(append parent-types '(functional-entity-handle))
	    ;; Slots
	    ,(append '((%$inverse-cache :initform nil))
		     (loop for cr-iv in all-cache-related-instance-variables
			   collect `(,cr-iv))
		     (loop for (nil nil transaction-slot) in cache-value-instance-variables
			   collect `(,transaction-slot :initform nil))				
		     (loop for clause in instance-variables
			   do (destructuring-bind (name &key
							initarg
							initform
							(accessor nil accessor-p)
							(reader nil reader-p)
							(writer nil writer-p))
				  clause
				(declare (ignore name initarg initform accessor reader writer))
				(when (and accessor-p (or writer-p reader-p))
				  (error ":ACCESSOR specified with ~:[:WRITER~;:READER~]"
					 reader-p)))
			   collect clause))
	   ,@(when documentation `((:documentation ,documentation)))
	   ,@(when default-initargs `((:default-initargs . ,default-initargs)))
	   ,@(when init-keywords `((:init-keywords . ,init-keywords))))
	top-forms)
      `(eval-when (compile load eval)
	 ,@top-forms
	 (let ((,functions 'nil))
	   . ,inside-forms)))))


;;; Given a clause of a define-entity-type, and some per-type information,
;;; return a two lists of forms to be part of the expansion of
;;; define-entity-type, inside a let and at top level respectively.  The
;;; value of functions is a variable that will accumulate the
;;; description instances at runtime.
;;; +++ I think there is a problem with inverses that are cached 
;;; not getting cached by load-entity at the right time.
(defun process-function (clause type-name functions D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")prefix 0type-area-name
			 type-relation-tag type-soo-att-tag)
  (declare (values inside-forms top-forms instance-variable-list
		   accessor-name transaction-iv cache-group-name))
  (when (symbolp clause)
    (error "In the definition of entity type ~S, the symbol ~S was found~@
            where a clause was expected.  Perhaps a level of parentheses is missing."
	   type-name clause))
  (unless (and (listp clause) (symbolp (first clause)))
    (error "In the definition of entity type ~S, ~S~@
              was found where a clause was expected."
	   type-name clause))
  (let (name type unique initform initform-p inverse inverse-exact
	index index-average-size
	cached suppress-attribute-changed cluster
	inverse-index inverse-index-average-size inverse-index-exact inverse-cached
	area area-specified-p (attribute-set t) read-only foreign no-nulls
	accessor accessor-p reader reader-p writer writer-p)
    (setq name (first clause))
    (when (null name)
      (error "NIL is not a valid attribute name, in clause ~S" clause))
    (when (keywordp name)
      (error "Keywords are not valid attribute names, in clause ~S" clause))
    (setq type (second clause))
    (when (and (listp type)
	       (eq (first type) 'quote))
      (warn "The type, ~S, for attribute ~S of entity type ~S, should not be quoted."
	    type name type-name)
      (setq type (second type)))
    (unless (or (symbolp type) (listp type))
      (error "~S is not a valid type, for attribute ~S of entity type ~S"
	     type name type-name))
    (when (oddp (length clause))
      (error "~S is not a legal function specification.  ~@
	      It should be (name type {keyword value} ...)"
	     clause))
    (loop for (clause-option-keyword value) on (cddr clause) by #'cddr do
      (ecase clause-option-keyword
	(:unique (setq unique value))
	(:initform (setq initform value initform-p t))
	(:inverse (setq inverse value))
	(:inverse-exact (setq inverse-exact value))
	(:index (setq index value))
	(:index-average-size (setq index-average-size value))
	(:cached (setq cached value))
	(:suppress-attribute-changed (setq suppress-attribute-changed value))
	(:inverse-index (setq inverse-index value))
	(:inverse-index-average-size (setq inverse-index-average-size value))
	(:inverse-index-exact (setq inverse-index-exact value))
	(:inverse-cached (setq inverse-cached value))
	(:cluster (setq cluster value))
	(:area (setq area value area-specified-p t))
	(:attribute-set (setq attribute-set value))
	(:function-set (setq attribute-set value))	;compatibility
	(:read-only (setq read-only value))
	(:foreign (setq foreign value))
	(:no-nulls (setq no-nulls value))
	(:accessor (setq accessor value accessor-p t))
	(:reader (setq reader value reader-p t))
	(:writer (setq writer value writer-p t))))
    (when (and accessor-p (or reader-p writer-p))
      (error ":ACCESSOR specified with ~:[:WRITER~;:READER~]" reader-p))
    (let ((inside-forms nil)
	  (top-forms nil)
	  (value-is-set nil)
	  (value-is-domain nil)
	  (full-name (or (when reader-p reader)	;the read function name
			 (when accessor-p accessor)
			 (intern (string-append prefix name))))
	  (full-setf-name (or (when writer-p writer)
			      (when accessor-p accessor)
			      (intern (string-append prefix name))))
	  (cache-name nil)
	  (inverse-cache-name nil)
	  (cache-transaction-name nil)
	  (inverse-cache-transaction-name nil)
	  (cache-null-name nil)
	  (inverse-cache-null-name nil))
      (forbid-reserved-name type-name "function")
      (when (and (listp type)
		 (= (length type) 2)
		 (eq (first type) 'set-of))
	(setq value-is-set t)
	(setq type (second type)))
      ;; Can't do much to validate the type right now, since it
      ;; could always be a forward reference.
      (unless (and (not (null type))
		   (or (symbolp type) (listp type)))
	(error "~S is not a valid type, in clause ~S" type clause))
      (setq value-is-domain
	    ;; The type appears to be an entity-type (a domain)
	    ;; rather than a value-type if it is a symbol, and the
	    ;; symbol is defined as a functional-entity-handle
	    ;; flavor, OR if it is a symbol and it does not appear
	    ;; to be a value-type (forward reference).  Any
	    ;; user-defined value-types had better be defined in
	    ;; advance!
	    (and (symbolp type)
		 (or (and (find-class type nil 'compile)
			  (subtypep type 'functional-entity-handle))
		     (not (dw:presentation-type-p type)))))
      (check-type unique scl:boolean)
      (check-type inverse symbol)
      (check-type inverse-exact symbol)
      (check-type index scl:boolean)
      (check-type inverse-index scl:boolean)
      (check-type inverse-index-exact scl:boolean)
      (check-type cluster scl:boolean)
      (check-type area symbol)
      (check-type attribute-set scl:boolean)
      (check-type foreign scl:boolean)
      (check-type no-nulls scl:boolean)
      (when (and foreign (not value-is-domain))
	(error "Function clause ~S specifies a :BUILT-IN with a value type" clause))
      (let ((area-name
	      ;; The default area for a function is the type-area.
	      (if (not area-specified-p) type-area-name area)))
	(when inverse-exact
	  (statice::check-use-of-exact type "specify :INVERSE-EXACT" full-name))
	(when (and index (not value-is-set) (not area-specified-p))
	  (error "It is not meaningful to specify :INDEX for ~S,~@
                    a single-valued function since Statice is able to access~@
                    this value directly.  For more information, see the section~@
                    ~\\presentation\\ in the Statice documentation."
		 full-name
		 (or (ignore-errors
		       (scl:accept-from-string 'sage:record-group
					   "Using Indexes to Increase Database Performance"))
		     "Using Indexes to Increase Database Performance")))
	(when inverse-index-exact
	  (statice::check-use-of-exact type "specify :INVERSE-INDEX-EXACT" full-name))
	(when (and inverse-index-average-size inverse-index-exact)
	  (error "It is not meaningful to specify :INVERSE-INDEX-EXACT and~@
                       :INVERSE-INDEX-AVERAGE-SIZE together"))
	(when (and (not index) index-average-size)
	  (error "It is not meaningful to specify :INDEX-AVERAGE-SIZE without :INDEX"))
	(when (and (not inverse-index) inverse-index-average-size)
	  (error "It is not meaningful to specify :INVERSE-INDEX-AVERAGE-SIZE~@
                       without :INVERSE-INDEX"))
	(when (and no-nulls value-is-set)
	  (error "It is not meaningful to specify :NO-NULLS for a set-valued function"))
	(when cluster
	  (unless (and value-is-domain (null value-is-set))
	    (error "It is not meaningful to specify :CLUSTER on a value-typed function")))
	(check-type cached symbol)
	(check-type inverse-cached symbol)
	(when (and inverse-cached (not inverse))
	  (error "It is not meaningful to specify :INVERSE-CACHED without :INVERSE"))
	(when (and inverse-cached (not value-is-domain))
	  (error "It is not meaningful to specify :INVERSE-CACHED on ~@
                       a non-entity-valued attribute."))
	(multiple-value-bind (implementation rel-tag of-att-tag is-att-tag)
	    (cond ((and (not value-is-set) (eq area-name type-area-name))
		   ;; Single-valued same-area function.
		   (values 'type-relation
			   type-relation-tag
			   type-soo-att-tag
			   (make-tag-symbol full-name "-IS")))
		  ((and value-is-set unique value-is-domain (not foreign))
		   (when inverse-index
		     (error "It is not meaningful to specify :INVERSE-INDEX for~@
                                  ~S, an entity-valued set-valued unique function"))
		   (when inverse-index-exact
		     (error "It is not meaningful to specify :INVERSE-INDEX-EXACT for~@
                                  ~S, an entity-valued set-valued unique function"))
			;; Set-valued, entity-typed, unique, non-foreign function.
			(values 'other-relation
				(make-tag-symbol type "-R")
				(make-tag-symbol full-name "-OF")
				(make-tag-symbol type "-SA")))
		  (t
		   ;; Set-valued function, or single-valued other-area function.
		   (values 'binary-relation
			   (make-tag-symbol full-name "-RF")
			   (make-tag-symbol full-name "-OF")
			   (make-tag-symbol full-name "-IS"))))
	       (when cached
		 (let ((symbol-string (string-append "%$" (symbol-name full-name))))
		   (setq cache-name (intern symbol-string)
			 cache-transaction-name
			 (intern (string-append symbol-string "-TRANSACTION"))
			 cache-null-name
			 (intern (string-append symbol-string "-NOT-NULL-P")))))
	       (when inverse-cached
		 (let ((symbol-string (string-append "%$" (symbol-name inverse))))
		   (setq inverse-cache-name (intern symbol-string)
			 inverse-cache-transaction-name
			 (intern (string-append symbol-string "-TRANSACTION"))
			 inverse-cache-null-name
			 (intern (string-append symbol-string "-NOT-NULL-P")))))
	       ;; Make a form that will create a forward-function instance for this function.
	       (push
		 (let ((fdi (gentemp "FDI")))
		   `(let ((,fdi (flavor:make-instance
				  'statice::template-attribute
				  :slot-name ',name
				  :full-name ',full-name
				  :keyword-name ',(intern (string name) si:pkg-keyword-package)
				  :argument-type-name ',type-name
				  :value-type-name ',type
				  :value-is-set ',value-is-set
				  :value-foreign ',foreign
				  :cached ',cached
				  :cache-name ',cache-name
				  :cache-transaction-name ',cache-transaction-name
				  :cache-null-name ',cache-null-name
				  :cluster ,cluster
				  :inverse-function-name ',inverse
				  :inverse-cache-transaction-name ',inverse-cache-transaction-name
				  ,@(when initform-p `(:init-function
							(get ',full-name 'initform)))
				  ,@(when unique '(:unique t))
				  ,@(when index '(:index-exists t))
				  ,@(when index-average-size
				      `(:index-average-size ,index-average-size))
				  ,@(when inverse-index '(:inverse-index-exists t))
				  ,@(when inverse-index-exact
				      '(:inverse-index-exact-exists t))
				  ,@(when inverse-index-average-size
				      `(:inverse-index-average-size
					 ,inverse-index-average-size))
				  :area-name ',area-name
				  :set-exists ',(and (eq implementation 'binary-relation)
						     attribute-set)
				  ,@(when read-only '(:read-only t))
				  :implementation ',implementation
				  :relation-tag ',rel-tag
				  :of-attribute-tag ',of-att-tag
				  :is-attribute-tag ',is-att-tag
				  ,@(when no-nulls '(:no-nulls t)))))
		      (setf (get ',full-name 'statice-function) ,fdi)
		      (push ,fdi ,functions)))
		 inside-forms)
	       ;; Make the functions in the forward direction.
	       (setq top-forms
		     (append (if (eq implementation 'type-relation)
				 (make-optimized-single-functions
				   full-name full-setf-name type-name read-only
				   type-name is-att-tag
				   cache-name cache-transaction-name cache-null-name
				   nil suppress-attribute-changed)
				 (funcall (if value-is-set
					      #'make-set-functions
					      #'make-single-functions)
					  full-name full-setf-name type-name implementation
					  read-only type-name rel-tag
					  of-att-tag is-att-tag 'equal
					  cache-name cache-transaction-name cache-null-name
					  nil suppress-attribute-changed nil))
			     top-forms))
	       (when initform-p
		 (push `(scl:defun (,full-name initform) ()
			  (declare (sys:function-parent ,full-name define-entity-type))
			  ,initform)
		       top-forms))
	       ;; If there is an inverse, then make a form that will
	       ;; create an inverse-function.
	       (flet
		 ((do-inverse (inverse exact-p)
		    (push
		      (let ((ifdi (gentemp "IFDI")))
			`(let ((,ifdi (flavor:make-instance
					'statice::template-inverse-function
					:slot-name ',name
					:full-name ',inverse
					:argument-type-name ',type
					:value-type-name ',type-name
					:value-is-set ',(not unique)
					:unique ',(not value-is-set)
					,@(when read-only '(:read-only t))
					:cached ',inverse-cached
					:cache-name ',inverse-cache-name
					:cache-transaction-name ',inverse-cache-transaction-name
					:cache-null-name ',cache-null-name
					:inverse-function-name ',full-name
					:inverse-cache-transaction-name ',cache-transaction-name
					:implementation ',implementation
					:relation-tag ',rel-tag
					:of-attribute-tag ',is-att-tag
					:is-attribute-tag ',of-att-tag)))
			   (setf (get ',inverse 'statice-function) ,ifdi)
			   (push ,ifdi ,functions)))
		      inside-forms)
		    ;; Make the functions in the inverse direction.
		    (setq top-forms
			  (append (funcall
				    (if value-is-domain
					(if unique
					    #'make-single-functions
					    #'make-set-functions)
					(if unique
					    #'make-single-functions-of-data
					    #'make-set-functions-of-data))
				    inverse inverse type implementation
				    (or read-only (not value-is-domain))
				    type-name rel-tag is-att-tag of-att-tag
				    (if exact-p
					(if (stringlike-type-p type) 'string= 'char=)
					(if (stringlike-type-p type)
					    'string-equal
					    (if (charlike-type-p type)
						'char-equal
						'equal)))
				    inverse-cache-name inverse-cache-transaction-name
				    inverse-cache-null-name t nil t)
				  top-forms))
		    (when value-is-domain
		      ;; type is a class that might not have been defined yet.
		      (push `(unless (find-class ',type nil 'compile)
			       (let ((sys:fdefine-file-pathname nil))
				 (defclass ,type
					   (functional-entity-handle)
				     (%$inverse-cache))))
			    top-forms))))
		 (when inverse (do-inverse inverse nil))
		 (when inverse-exact (do-inverse inverse-exact t)))))
	   (values (nreverse inside-forms)
		   top-forms
		   (when cached
		     (list cache-name cache-null-name))
		   full-name
		   cache-transaction-name
		   cached))))

(defun make-accessor-template (defun-or-defmethod function-name setf-function-name class-name
			       parent-name cache-name cache-transaction-name cache-null-name
			       cache-is-inverse suppress-attribute-changed read-only
			       entity-var database-accessing-form setf-form)
  `((,@(ecase defun-or-defmethod
	 (defun `(defun ,function-name
			(,entity-var ,@(when cache-name '(&key force-refresh)))))
	 (defmethod `(defmethod ,function-name
				((,entity-var ,class-name)
				 ,@(when cache-name '(&key force-refresh))))))
     (declare (sys:function-parent ,parent-name define-entity-type)
	      (scl:arglist ,class-name))
     (with-slots (schema-table
		   ,@(if cache-name
			 `(,cache-name ,cache-null-name ,cache-transaction-name
			   ,@(if cache-is-inverse '(%$inverse-cache)
				 nil))
			 nil))
		 ,entity-var
       (flet ,(when cache-name
		`((refresh-cache
		    ()
		    (if (and (null force-refresh)
			     (validate-cache ,entity-var ',function-name))
			,(if cache-is-inverse
			     `(and %$inverse-cache
				   (values (gethash ',cache-name %$inverse-cache)
					   (gethash ',cache-null-name %$inverse-cache)))
			     `(values ,cache-name ,cache-null-name))
			(multiple-value-bind (value not-null-p)
			    ,database-accessing-form
			  ,(if cache-is-inverse
			       `(progn
				  (unless %$inverse-cache
				    (setq %$inverse-cache (scl:make-hash-table :locking nil)))
				  (setf (gethash ',cache-name %$inverse-cache) value
					(gethash ',cache-transaction-name %$inverse-cache)
					(and dbfs::*process-transaction*
					     (dbfs:current-transaction-id))
					(gethash ',cache-null-name %$inverse-cache)
					not-null-p))
			       `(setq ,cache-name value
				      ,cache-transaction-name
				      (and dbfs::*process-transaction*
					   (dbfs:current-transaction-id))
				      ,cache-null-name not-null-p))
			  (values value not-null-p))))))
	 ,(cond
	    (cache-name
	     `(cond ,@(when read-only
			`((,(if cache-is-inverse
				`(when %$inverse-cache
				   (gethash ',cache-transaction-name %$inverse-cache))
				cache-transaction-name)
			   ,(if cache-is-inverse
				`(multiple-value-bind (value found)
				     (and %$inverse-cache
					  (gethash ',cache-name %$inverse-cache))
				   (if found
				       (values value
					       (gethash ',cache-null-name %$inverse-cache))
				       (error-in-caching)))
				`(if (slot-boundp ,entity-var ',cache-name)
				     (values ,cache-name ,cache-null-name)
				     (error-in-caching))))))
		    ((and dbfs::*process-transaction*
			  (eql (dbfs:current-transaction-id)
			       ,(if cache-is-inverse
				    `(when %$inverse-cache
				       (gethash ',cache-transaction-name %$inverse-cache))
				    cache-transaction-name)))
		     ,(if cache-is-inverse
			  `(multiple-value-bind (value found)
			       (and %$inverse-cache (gethash ',cache-name %$inverse-cache))
			     (if found
				 (values value (gethash ',cache-null-name %$inverse-cache))
				 (error-in-caching)))
			  `(if (slot-boundp ,entity-var ',cache-name)
			       (values ,cache-name ,cache-null-name)
			       (error-in-caching))))
		    (dbfs::*process-transaction*
		     (refresh-cache))
		    (,(if cache-is-inverse
			  `(multiple-value-bind (nil found)
			       (and %$inverse-cache
				    (gethash ',cache-transaction-name %$inverse-cache))
			     found)
			  cache-transaction-name)
		     ,(if cache-is-inverse
			  `(multiple-value-bind (value found)
			       (and %$inverse-cache (gethash ',cache-name %$inverse-cache))
			     (if found
				 (values value (gethash ',cache-null-name %$inverse-cache))
				 (error-in-caching)))
			  `(if (slot-boundp ,entity-var ',cache-name)
			       (values ,cache-name ,cache-null-name)
			       (error-in-caching))))
		    (t
		     (with-transaction () (refresh-cache)))))
	    (t database-accessing-form)))))
    ,@(when (not read-only)
	`((,@(ecase defun-or-defmethod
	       (defun `(defsetf ,setf-function-name (,entity-var) (new-value)))
	       (defmethod `(defmethod (setf ,setf-function-name) (new-value (,entity-var ,class-name)))))
	   (declare (sys:function-parent ,parent-name define-entity-type))
	   (with-slots (schema-table
			 ,@(if cache-name
			       `(,cache-name ,cache-null-name ,cache-transaction-name
				 ,@(if cache-is-inverse '(%$inverse-cache)
				       nil))
			       nil))
		       ,entity-var
	     (let ((is-att ,setf-form))
	       is-att
	       ,@(when cache-name
		   (if cache-is-inverse
		       `((progn
			   (unless %$inverse-cache
			     (setq %$inverse-cache (scl:make-hash-table :locking nil)))
			   (setf (gethash ',cache-name %$inverse-cache) new-value
				 (gethash ',cache-transaction-name %$inverse-cache)
				 (and dbfs::*process-transaction*
				      (dbfs:current-transaction-id))
				 (gethash ',cache-null-name %$inverse-cache)
				 (not (null new-value)))))
		       `((setq ,cache-name new-value
			       ,cache-transaction-name (and dbfs::*process-transaction*
							    (dbfs:current-transaction-id))
			       ,cache-null-name (or (not (null new-value))
						    (statice-model::%nil-is-valid-value
						      is-att)))))))
	     ,@(unless suppress-attribute-changed
		 `((attribute-changed ,entity-var ',function-name)))
	     new-value))))))

(defun make-single-functions (function-name setf-function-name class-name implementation
			      read-only parent-name rel-tag of-att-tag is-att-tag predicate
			      cache-name cache-transaction-name cache-null-name
			      cache-is-inverse suppress-attribute-changed inverse-p)
  (make-accessor-template
    'defmethod function-name setf-function-name class-name parent-name cache-name
    cache-transaction-name cache-null-name cache-is-inverse suppress-attribute-changed
    read-only 'entity-handle
    `(inside-function-level ()
       (block top
	 (do-attribute
	   (value not-null-p (or (gethash ',is-att-tag schema-table)
				 (no-function-named ',function-name))
		  (:where
		    (or (gethash ',of-att-tag schema-table)
			(no-function-named ',function-name))
		    (list ',predicate entity-handle)))
	   (return-from top (values value not-null-p)))
	 (values nil nil)))
    `(inside-function-level ()
       (block top
	 ,(case implementation
	    (type-relation
	      `(let ((is-handle (or (gethash ',(if inverse-p of-att-tag is-att-tag)
					     schema-table)
				    (no-function-named ',function-name))))
		 ,(if inverse-p
		      `(statice-model::%set-value-from-entity new-value is-handle entity-handle)
		      `(statice-model::%set-value-from-entity entity-handle is-handle new-value))))
	    (other-relation
	      `(let* ((rel-handle (or (gethash ',rel-tag schema-table)
				      (no-entity-type-named ',parent-name)))
		      (of-handle (or (gethash ',of-att-tag schema-table)
				     (no-function-named ',setf-function-name)))
		      (is-handle (or (gethash ',is-att-tag schema-table)
				     (no-function-named ',setf-function-name))))
		 (do-relation (r rel-handle
				 (:where of-handle (list ',predicate entity-handle)))
		   (set-value r is-handle new-value)
		   (return-from top is-handle))
		 (maintaining-*current-cluster*
		   (make-clustered-tuple rel-handle *current-cluster*
					 of-handle entity-handle is-handle new-value))
		 is-handle))
	    (t
	      `(let* ((rel-handle (or (gethash ',rel-tag schema-table)
				      (no-entity-type-named ',parent-name)))
		      (of-handle (or (gethash ',(if inverse-p is-att-tag of-att-tag)
					      schema-table)
				     (no-function-named ',setf-function-name)))
		      (is-handle (or (gethash ',(if inverse-p of-att-tag is-att-tag)
					      schema-table)
				     (no-function-named ',setf-function-name))))
		 (do-relation (r rel-handle
				 (:where of-handle (list ',predicate entity-handle)))
		   (set-value r is-handle new-value)
		   (return-from top is-handle))
		 ;; No tuple was found.  This can only happen for the binary
		 ;; implementation, not for the type-relation implementation.
		 (maintaining-*current-cluster*
		   (make-clustered-tuple rel-handle *current-cluster*
					 of-handle entity-handle is-handle new-value))
		 is-handle)))))))

(defun make-optimized-single-functions (function-name setf-function-name class-name read-only
					parent-name is-att-tag
					cache-name cache-transaction-name cache-null-name
					cache-is-inverse suppress-attribute-changed)
  (make-accessor-template
    'defmethod function-name setf-function-name class-name parent-name
    cache-name cache-transaction-name cache-null-name cache-is-inverse
    suppress-attribute-changed read-only 'entity-handle
    `(inside-function-level ()
       (statice-model::%get-value-from-entity entity-handle
			       (or (gethash ',is-att-tag schema-table)
				   (no-function-named ',function-name))))
    `(inside-function-level ()
       (let ((is-att (or (gethash ',is-att-tag schema-table)
			 (no-function-named ',setf-function-name))))
	 (statice-model::%set-value-from-entity entity-handle is-att new-value)
	 is-att))))

(defun make-set-functions (function-name setf-function-name class-name implementation
			   read-only parent-name rel-tag of-att-tag is-att-tag predicate
			   cache-name cache-transaction-name cache-null-name
			   cache-is-inverse suppress-attribute-changed inverse-p)
  (make-accessor-template
    'defmethod function-name setf-function-name class-name parent-name
    cache-name cache-transaction-name cache-null-name cache-is-inverse
    suppress-attribute-changed read-only 'entity-handle
    `(inside-function-level ()
       (let* ((answer nil)
	      (is-att (or (gethash ',is-att-tag schema-table)
			  (no-function-named ',function-name))))
	 (do-attribute (item not-null-p is-att
			     (:where
			       (or (gethash ',of-att-tag schema-table)
				   (no-function-named ',function-name))
			       (list ',predicate entity-handle)))
	   (push item answer))
	 (values answer t)))
    `(inside-function-level ()
       (let* ((rel-handle (or (gethash ',rel-tag schema-table)
			      (no-entity-type-named ',parent-name)))
	      (of-handle (or (gethash ',of-att-tag schema-table)
			     (no-function-named ',setf-function-name)))
	      (is-handle (or (gethash ',is-att-tag schema-table)
			     (no-function-named ',setf-function-name))))
	 (unless (listp new-value)
	   (value-not-a-set))
	 ,(case implementation
	    (other-relation
	      `(progn
		 (do-relation (r rel-handle (:where of-handle entity-handle))
		   (set-to-null-value r of-handle))
		 (dolist (value new-value)
		   (do-relation (r rel-handle (:where is-handle value))
		     (unless (get-value-null-p r of-handle)
		       (other-relation-uniqueness-error ',function-name entity-handle value))
		     (set-value r of-handle entity-handle)))))
	    (binary-relation
	      `(progn
		 (do-relation (r rel-handle (:where of-handle
					     (list ',predicate entity-handle)))
		   (delete-tuple r))
		 (dolist (value new-value)
		   (maintaining-*current-cluster*
		     (make-clustered-tuple rel-handle *current-cluster*
					   of-handle entity-handle is-handle value)))))
	    (t
	      `(progn
		 (do-relation (r rel-handle (:where of-handle
					     (list ',predicate entity-handle)))
		   ,(if inverse-p
			'(set-to-null-value r of-handle)
			'(delete-tuple r)))
		 (dolist (value new-value)
		   ,(if inverse-p
			'(statice-model::%set-value-from-entity value of-handle entity-handle)
			'(maintaining-*current-cluster*
			   (make-clustered-tuple rel-handle *current-cluster*
						 of-handle entity-handle is-handle value)))))))
	 is-handle))))

(defun make-single-functions-of-data (function-name setf-function-name type-name
				      implementation read-only parent-name rel-tag of-att-tag
				      is-att-tag predicate cache-name cache-transaction-name
				      cache-null-name cache-is-inverse
				      suppress-attribute-changed inverse-p)
  (declare (ignore implementation inverse-p))
  (let ((argvar (intern (string (dw::with-type-decoded (type-symbol) type-name
				  type-symbol)))))
    (make-accessor-template
      'defun function-name setf-function-name argvar parent-name
      cache-name cache-transaction-name cache-null-name cache-is-inverse
      suppress-attribute-changed read-only argvar
      `(inside-function-level (database)
	 (block top
	   (let ((schema-table (functional-database-schema-table database)))
	     (do-attribute (value not-null-p (or (gethash ',is-att-tag schema-table)
						 (no-function-named ',function-name))
				  (:where
				    (or (gethash ',of-att-tag schema-table)
					(no-function-named ',function-name))
				    (list ',predicate ,argvar)))
	       (return-from top (values value not-null-p)))
	     (values nil nil))))
    `(block top
       (inside-function-level (database)
	 (let* ((schema-table (functional-database-schema-table database))
		(rel-handle (or (gethash ',rel-tag schema-table)
				(no-entity-type-named ',parent-name)))
		(of-handle (or (gethash ',of-att-tag schema-table)
			       (no-function-named ',function-name)))
		(is-handle (or (gethash ',is-att-tag schema-table)
			       (no-function-named ',function-name))))
	   (do-relation (r rel-handle (:where of-handle (list ',predicate ,argvar)))
	     (set-value r is-handle new-value)
	     (return-from top new-value))
	   ;; No tuple was found.  This can only happen for the binary
	   ;; implementation, not for the type-relation implementation.
	   (maintaining-*current-cluster*
	     (make-clustered-tuple rel-handle *current-cluster*
				   of-handle ,argvar is-handle new-value))
	   is-handle))))))

(defun make-set-functions-of-data (function-name setf-function-name type-name implementation
				   read-only parent-name rel-tag of-att-tag is-att-tag
				   predicate cache-name cache-transaction-name cache-null-name
				   cache-is-inverse suppress-attribute-changed inverse-p)
  (declare (ignore implementation inverse-p))
  (let ((argvar (intern (string (dw::with-type-decoded (type-symbol) type-name
				  type-symbol)))))
    (make-accessor-template
      'defun function-name setf-function-name argvar parent-name
      cache-name cache-transaction-name cache-null-name cache-is-inverse
      suppress-attribute-changed read-only argvar
      `(inside-function-level (database)
	 (let* ((schema-table (functional-database-schema-table database))
		(answer nil)
		(is-att (or (gethash ',is-att-tag schema-table)
			    (no-function-named ',function-name))))
	   (do-attribute (value not-null-p is-att
				(:where
				  (or (gethash ',of-att-tag schema-table)
				      (no-function-named ',function-name))
				  (list ',predicate ,argvar)))
	     (push value answer))
	   (values answer t)))
    `(inside-function-level (database)
       (let* ((schema-table (functional-database-schema-table database))
	      (rel-handle (or (gethash ',rel-tag schema-table)
			      (no-entity-type-named ',parent-name)))
	      (of-handle (or (gethash ',of-att-tag schema-table)
			     (no-function-named ',function-name)))
	      (is-handle (or (gethash ',is-att-tag schema-table)
			     (no-function-named ',function-name))))
	 (unless (listp new-value)
	   (value-not-a-set))
	 (do-relation (r rel-handle (:where of-handle (list ',predicate ,argvar)))
	   (delete-tuple r))
	 (dolist (value new-value)
	   (maintaining-*current-cluster*
	     (make-clustered-tuple rel-handle *current-cluster*
				   of-handle ,argvar is-handle value)))
	 is-handle)))))

