;;; -*- Mode: LISP; Syntax: Common-lisp; Package: statice; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defvar *entity-type-attributes-lock*
	(process:make-lock "Browser Entity Type Attribute Lock" :recursive t)
  "D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Lock on *entity-type-attributes* table0")

(defvar *entity-type-attributes* (lisp:make-hash-table :locking nil :test 'eq))

(defvar *initial-query-result-set-size* 1000
  "1Initial size of query result set arrays0")

(defvar *all-results-sets* nil
  "1List0 1of all results sets by time they were created -- per process.0")

(defvar *results-set-tick* nil
  "1Unique-ID for candidate and query panes0")

(defvar *entity-max-attribute-name-length-table-lock*
	(process:make-lock "Browser Entity Max Attribute Name Length Table Lock" :recursive t)
  "1Lock for below0")

(defvar *entity-max-attribute-name-length-table*
	(lisp:make-hash-table :locking nil :test 'eq)
  "1Table of entity-type names to max attribute name lengths0")

(defvar *sva-initial-entries-displayed* 3
  "1Max number of entries to display in a set0")

(defvar *internal-null-value* (list "The internal null value")
  "1Cons used as the internal null value0")

(defvar *default-compare-attributes* :changed
  "1Which attributes to compare for differences between0 1editing and commit0")

(defvar *default-difference-action* :query
  "1Action to take when a difference is found in a value between editing and commit0")

(dw:define-program-framework Statice-Browser
  :pretty-name "Statice Browser"
  :system-menu t
  :top-level (toplevel)
  :command-definer t
  :inherit-from (dw:help-program)
  :command-table
  (:inherit-from
    '("help-program" "colon full command" "standard arguments" "standard scrolling")
   :kbd-accelerator-p t)
  :help dw:help-program-help
  :state-variables ((pathname nil)		;pathname of currently open database
		    (schema nil)		;schema object of same
		    (viewer-pane nil)		;what it says
		    (candidate-pane nil)	;  "
		    (query-pane nil)		;  "
		    (typeout-pane nil)		;  "
		    (command-pane nil)		;  "
		    (current-candidate nil)	;index into results in current-results-set
		    (current-candidate-line nil);line number in candidate-pane of cur-cand.
		    (current-results-set nil)	;results-set instance of currently selected
		    (editing-entities nil)	;record of changes made to entities
		    (saved-label nil))		;old label while editing entities
  :panes
  ((title-pane :title
	       :redisplay-string "Statice Browser"
	       :default-character-style '(:eurex :italic :huge))
   (viewer-pane :display
		:typeout-window t
		:automatically-remove-typeout-window nil
		:blinker-p nil
		:more-p nil
		:end-of-page-mode :truncate
		:margin-components
		`((dw:margin-ragged-borders :thickness 1)
		  (dw:margin-whitespace :margin :left :thickness 2)
		  (dw:margin-scroll-bar)
		  (dw:margin-whitespace :margin :bottom :thickness 2)
		  (dw:margin-scroll-bar :margin :bottom)
		  (dw:margin-white-borders :thickness 2)))
   (candidate-pane :display
		   :more-p nil
		   :incremental-redisplay t
		   :redisplay-function #'redisplay-candidates
		   :margin-components
		   `((dw:margin-pattern :margin :left :thickness 1 :pattern T)
		     (dw:margin-pattern :margin :top :thickness 1 :pattern tv:50%-gray)
		     (dw:margin-pattern :margin :right :thickness 1 :pattern T)
		     (dw:margin-pattern :margin :bottom :thickness 1 :pattern T)
		     (dw:margin-whitespace :margin :left :thickness 2)
		     (dw:margin-scroll-bar)
		     (dw:margin-white-borders :thickness 2)
		     (dw:margin-label :style (:swiss :bold-italic :normal) 
				      :string "Current Candidates"
				      :margin :top)))
   (query-pane :display
	       :more-p nil
	       :incremental-redisplay t
	       :redisplay-function #'redisplay-queries
	       :margin-components
	       `((dw:margin-pattern :margin :left :thickness 1 :pattern T)
		 (dw:margin-pattern :margin :top :thickness 1 :pattern tv:50%-gray)
		 (dw:margin-pattern :margin :right :thickness 1 :pattern T)
		 (dw:margin-pattern :margin :bottom :thickness 1 :pattern T)
		 (dw:margin-whitespace :margin :left :thickness 2)
		 (dw:margin-scroll-bar)
		 #+ignore (dw:margin-scroll-bar :margin :bottom)
		 (dw:margin-white-borders :thickness 2)
		 (dw:margin-label :string "Queries"
				  :style (:swiss :bold-italic :normal)
				  :margin :top)))
   (menu-pane :command-menu
	      :menu-level :top-level
	      :columns `(("Open Database" "Query" )
			 ("Begin Edits" "End Edits" "Abort Edits" "Help"))
	      :center-p t
	      :margin-components
	      `(;(dw:margin-pattern :margin :left :thickness 1 :pattern T)
		(dw:margin-pattern :margin :top :thickness 1 :pattern tv:50%-gray)
		(dw:margin-pattern :margin :right :thickness 1 :pattern T)
		(dw:margin-pattern :margin :bottom :thickness 1 :pattern T)
		(dw:margin-whitespace :margin :left :thickness 2)
		(dw:margin-white-borders :thickness 2)))
   (command-pane :interactor
		 :more-p nil
		 :end-of-page-mode :scroll
		 :margin-components
		 `((dw:margin-pattern :margin :left :thickness 1 :pattern T)
		   (dw:margin-pattern :margin :top :thickness 1 :pattern tv:50%-gray)
		   ;(dw:margin-pattern :margin :right :thickness 1 :pattern T)
		   (dw:margin-pattern :margin :bottom :thickness 1 :pattern T)
		   (dw:margin-whitespace :margin :left :thickness 4)
		   (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")(dw:margin-scroll-bar)
0		   (dw:margin-white-borders :thickness 2)
		   (dw:margin-label :string "(3 0 (NIL 0) (:SWISS :BOLD-ITALIC NIL) "HL12BI")Commands0";(4 0 (NIL 0) (:SWISS :ITALIC NIL) "HL12I") (Completion; end with Return)0"
				    :style (:swiss :roman :normal)
				    :margin :top))))
  :configurations
  '((main
      (:layout (main :column top-part bottom-part)
       (top-part :row title&viewer-pane candidates&queries)
       (bottom-part :row command-pane menu-pane)
       (title&viewer-pane :column title-pane viewer-pane)
       (candidates&queries :column candidate-pane query-pane))
      (:sizes
	(main (bottom-part 4 :lines command-pane) :then (top-part :even))
	(bottom-part (command-pane 0.65) :then (menu-pane :even))
	(top-part (title&viewer-pane 0.65) :then (candidates&queries :even))
	(title&viewer-pane (title-pane 1 :lines) :then (viewer-pane :even))
	(candidates&queries (candidate-pane 0.5) :then (query-pane :even))))))

;;; Presentation types
(scl:define-presentation-type criterion-for-type (() &key presentation-type)
   :no-deftype t
   :describer ((stream) (format stream "A query spec for type ~A" presentation-type))
   :parser ((stream &key default)
	    (let ((operator (dw:accept '(member = scl: < > scl: scl: any
					     eq eql equal
					     string-prefix string-prefix-exact
					     scl:string-search scl:string-search-exact
					     string-equal string-greaterp string-lessp
					     string-not-greaterp string-not-lessp
					     string= scl:string string< string> scl:string scl:string)
				    :stream stream
				    :default (first default)
				    :additional-blip-chars '(#\space)
				    :prompt nil)))
	      (unless (eq operator 'any)
		(unless (dw:compare-char-for-accept (dw:read-char-for-accept stream) #\space)
		  (sys:parse-ferror "You must supply a value"))
		(list operator
		      (scl:accept `((scl:null-or-type ,presentation-type))
			      :stream stream :default (second default)
			      :prompt nil)))))
   :printer ((object stream)
	     (let ((operator (first object))
		   (value (second object)))
	       (cond ((member operator '(nil any))
		      (write-string "Any" stream))
		     (t
		      (format stream "~A " operator)
		      (scl:present value `((scl:null-or-type ,presentation-type)) :stream stream))))))

(scl:define-presentation-type attribute-and-spec (() &key entity-type)
   :no-deftype t
   :description "an attribute and spec"
   :parser ((stream)
	    (let ((att (scl:accept `((attribute) :entity ,entity-type)
			       :stream stream
			       :default nil
			       :additional-blip-chars '(#\space)
			       :prompt nil)))
	      (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream) #\space)
		(sys:parse-ferror "You must supply a value"))
	      (list* att
		     (scl:accept `((criterion-for-type)
			       :presentation-type ,(function-value-type-name att))
			     :stream stream :default nil :prompt nil))))
   :printer ((object stream)
	     (let ((att (first object))
		   (spec (second object)))
	       (scl:present att 'attribute :stream stream)
	       (princ #\space stream)
	       (scl:present spec `((criterion-for-type)
			       :presentation-type ,(function-value-type-name att))
			:stream stream))))

(scl:define-presentation-type entity-type-from (() &key schema)
   :describer ((stream)
	       (unless schema
		 (sys:parse-ferror "No open database~%"))
	       (format stream "an entity-type from schema ~A" (schema-name schema)))
   :parser ((stream)
	    (unless schema
	      (sys:parse-ferror "No open database~%"))
	    (dw:completing-from-suggestions (stream)
	      (dolist (type (schema-type-names schema))
		(dw:suggest (string type) (get type 'entity-type)))))
   :printer ((type stream)
	     (format stream "~A" (type-name type))))

(scl:define-presentation-type results-set ()
   :no-deftype t
   :history t
   :description "a browser query"
   :printer ((results-set stream &key acceptably)
	     (lisp:if acceptably
		 (lisp:write (acceptable-string results-set) :stream stream)
		 (format stream "[Query on ~A (~A entities)]"
			 (type-name (results-set-entity-type results-set))
			 (length (results-set-results results-set)))))
   :parser ((stream &key original-type initially-display-possibilities)
	    (unless *all-results-sets*
	      (sys:parse-ferror "You must be inside the browser"))
	    (dw:completing-from-suggestions (stream
					      :partial-completers `(#\space)
					      :type original-type
					      :initially-display-possibilities
					      initially-display-possibilities)
	      (dolist (rs *all-results-sets*)
		(dw:suggest (acceptable-string rs) rs)))))

(scl:define-presentation-type candidate ()
   :no-deftype t
   :history t
   :parser ((stream &key original-type initially-display-possibilities)
	    (unless (and (scl:variable-boundp dw:*program*)
			 (typep dw:*program* 'statice-browser))
	      (sys:parse-ferror "You must be inside the browser"))
	    (let ((current-results-set (scl:accept 'results-set
					       :stream stream
					       :provide-default nil
					       :additional-blip-chars '(#\space)
					       :prompt nil)))
	      (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream) #\space)
		(sys:parse-ferror "You must supply a value"))
	      (cons current-results-set
		    (dw:completing-from-suggestions (stream
						      :partial-completers `(#\space)
						      :type original-type
						      :initially-display-possibilities
						      initially-display-possibilities)
		      (let ((results (results-set-results current-results-set)))
			(declare (sys:array-register results))
			(lisp:dotimes (i (length results))
			  (let ((entity-handle (aref results i)))
			    (dw:suggest (statice-model::acceptable-string entity-handle)
					entity-handle))))))))
   :printer ((candidate stream)
	     (princ (cdr candidate) stream)))

(scl:define-presentation-type abbreviated-set ()
   :no-deftype t)

(scl:define-presentation-type maybe-abbreviated-set (()
						 &key tab-to initial-newline (initial-paren t))
   :expander 'sys:expression
   :parser ((stream)
	    (scl:accept 'list :stream stream :prompt nil))
   :printer ((values stream)
	     (when initial-newline
	       (format stream "~%~VT" (1- tab-to)))
	     (princ (lisp:if initial-paren "(" " ") stream)
	     (lisp:loop with show-ellipses = nil
		   for ent in values
		   for i from 0 do
	       (unless (< i *sva-initial-entries-displayed*)
		 (setq show-ellipses t)
		 (scl:loop-finish))
	       (unless (zerop i)
		 (format stream "~%~VT" tab-to))
	       (princ ent stream)
		   finally
		     (when show-ellipses
		       (format stream " ")
		       (let ((rest (nthcdr i values)))
			 (dw:with-output-as-presentation
			     (:stream stream
			      :object rest
			      :type 'abbreviated-set
			      :single-box t)
			   (format stream "... (~A more)" (length rest)))))
		     (princ ")" stream))))

(scl:define-presentation-type attribute (() &key short-name entity)
   :no-deftype t
   :history t
   :printer ((attribute stream)
	     (format stream "~A" (lisp:if short-name
				     (function-slot-name attribute)
				     (function-full-name attribute))))
   :parser ((stream)
	    (cond (entity
		   (let ((atts (entity-type-attributes entity)))
		     (dw:completing-from-suggestions (stream)
		       (dolist (att atts)
			 (dw:suggest (function-slot-name att) att)))))
		  (t
		   (let* ((att-name (scl:accept 'symbol
					    :stream stream :prompt nil :provide-default nil))
			  (att (get att-name 'statice-function)))
		     (or att
			 (sys:parse-ferror "~A is not a valid function" att-name)))))))

(scl:define-presentation-action expand-set
   (abbreviated-set t
		    :gesture nil
		    :documentation "Display more of the set")
   (lisp:ignore &key window presentation)
  (let ((tab-to (getf (lisp:loop for p = presentation then (dw:presentation-superior p)
			    when (dw:with-type-decoded (lisp:ignore lisp:ignore presentation-args)
				       (dw:presentation-type p) presentation-args)
			      return it)
		      :tab-to)))
    (send window :represent-presentation presentation
	  `((maybe-abbreviated-set) :tab-to ,tab-to :initial-newline t :initial-paren nil))))

(scl:define-presentation-to-command-translator describe-attribute
   (attribute :gesture :middle)
   (attribute)
  `(com-describe-attribute ,attribute))

(scl:defmethod (toplevel statice-browser) (&rest args)
  (setq viewer-pane (dw:get-program-pane 'viewer-pane)
	candidate-pane (dw:get-program-pane 'candidate-pane)
	query-pane (dw:get-program-pane 'query-pane)
	typeout-pane (send viewer-pane :typeout-window)
	command-pane (dw:get-program-pane 'command-pane))
  (let ((*standard-output* typeout-pane)
	(*debug-io* typeout-pane)
	(*results-set-tick* 0)
	(*all-results-sets* nil)
	(*default-difference-action* *default-difference-action*)	;make parms per process
	(*default-compare-attributes* *default-compare-attributes*))
    (unwind-protect
	(apply 'dw:default-command-top-level self
	       :prompt "Browser command: "
	       :unknown-accelerator-is-command t
	       :window-wakeup
	       (lisp:lambda (blip)
		 (dw:presentation-blip-case blip
		   (dw::window-wakeup-viewport-position-changed
		     (let ((window (dw:presentation-blip-object blip)))
		       (when (eq window candidate-pane)
			 ;; Only bother when we scrolled in Y
			 (destructuring-bind (nil y)
			     (dw:presentation-blip-options blip)
			   (when (and (not (null y)) current-candidate)
			     (incf *results-set-tick*)
			     (send dw:*program-frame* :redisplay-pane window)))))))
		 (dw:help-program-check-for-help-wakeup blip))
	       args)
      (dolist (rs *all-results-sets*)
	(scl:deallocate-resource 'query-result-set (results-set-results rs))))))

;;; Help interface -- stolen from MI and NS Editor

(dw:define-command-menu-handler ("Help" statice-browser :top-level
				 :gesture (:left :right)) ()
  `(dw:com-help))
		 
(scl:defmethod (dw::map-command-menu-item-to-help-topic statice-browser) (string)
  (if (string-equal string "help")
      `("browser help command")
      `(,string "command")))

(scl:defmethod (dw::map-command-name-to-help-topic statice-browser) (symbol)
  (format () "~@\\presentation\\ command"
	  symbol `((cp:command-name :command-table ,(dw:program-command-table self)))))

(scl:defmethod (dw::map-program-name-to-help-topic statice-browser) (name)
  `(,name))

(cp:define-command-accelerator help-key
			       "Statice-Browser" (#\help)
			       (:echo nil) ()
  `(dw:com-help))

(define-statice-browser-command (com-clear) ()
   (clear-all self))

(defun fixed-line (string &optional unique-id)
  (dw:with-redisplayable-output (:unique-id (or unique-id string)
				 :cache-value string :stream *query-io*)
    (write-line string *query-io*)))

(scl:defmethod (clear-all statice-browser) ()
   (send typeout-pane :clear-history)
   (send candidate-pane :clear-history)
   (send query-pane :clear-history)
   (send viewer-pane :clear-history)
   (setq pathname nil schema nil current-candidate nil current-results-set nil)
   (dolist (rs *all-results-sets*)
     (scl:deallocate-resource 'query-result-set (results-set-results rs)))
   (setq *all-results-sets* nil))

(define-statice-browser-command (com-remove-typeout-window :keyboard-accelerator #\Space
							   :echo nil)
    ()
   (send typeout-pane :remove-self))

(define-statice-browser-command (com-open-database :menu-accelerator t)
    ((set-to-pathname 'fs:dbfs-pathname :provide-default nil))
   (clear-all self)
   (setq pathname set-to-pathname)
   (setq schema
	 (get (block doit
		(scl:error-restart-loop (schema-not-loaded
				      "Retry finding the schema after loading it")
		  (with-database (db pathname)
		    (with-transaction ()
		      (let* ((sdinfo (get-relation "%%$sdinfo"))
			     (name (get-attribute sdinfo "name")))
			(do-relation (sdi sdinfo)
			  (return-from doit (get-value sdi name))))))))
	   'schema))
   (send viewer-pane :set-label (format nil "~vBrowsing:~ ~v~A~"
					'(:swiss :bold-italic nil)
					'(:swiss :italic nil)
					pathname))
   (setq current-results-set nil
	 current-candidate nil))

;;; return a list of functions in entity-type, and it's parents
(defun entity-type-attributes (entity-type)
  (process:with-lock (*entity-type-attributes-lock*)
    (or (lisp:gethash entity-type *entity-type-attributes*)
	(lisp:setf (lisp:gethash entity-type *entity-type-attributes*)
	      (gather-entity-attributes entity-type)))))

(defun gather-entity-attributes (entity-type)
  (nconc (loop for entity-name in (type-parent-names entity-type t)
	       nconc (gather-entity-attributes
		       (or (get entity-name 'entity-type)
			   (error "Schema inconsistent.  Expected to find a definition~@
                                   for type ~A, but couldn't" entity-name))))
	 (nreverse (loop for f in (type-functions entity-type)
			 unless (typep f 'template-inverse-function)
			   collect f))))

(scl:defresource query-result-set ()
  :constructor (lisp:make-array *initial-query-result-set-size*
			   :fill-pointer 0 :element-type 'functional-entity-handle)
  :initializer (lisp:setf (fill-pointer object) 0))

(scl:defflavor results-set
	((entity-type nil)
	 (query nil)
	 (results nil)
	 (time (get-universal-time)))
	()
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(scl:defmethod (acceptable-string results-set) ()
  (format nil "~A (~A)" (type-name entity-type) (time:print-universal-time time nil)))

(define-statice-browser-command (com-query :menu-accelerator t)
    ((entity-type `((entity-type-from) :schema ,schema) :prompt nil :provide-default nil))
   (let* ((query (prompt-for-query self entity-type))
	  (count (count-query self entity-type query)))
     (when (or (< count dw::*default-display-possibilities-query-cutoff-length*)
	       1(0y-or-n-p "There are ~A candidates in the query.  ~
Do you want to see them all?  "
			 count))
       (let ((results (execute-query self entity-type query count)))
	 (set-current-candidate self results 0)
	 (view-current-entity self viewer-pane)))))

(scl:defmethod (set-current-candidate statice-browser) (results candidate-index)
  (let ((old-line current-candidate-line))
    (setq current-results-set results
	  current-candidate candidate-index
	  current-candidate-line
	  (+ (lisp:loop with line = 1
		   for rs in *all-results-sets*
		   until (eq rs results)
		   ;; 1+ is for query presentation in candidate-pane
		   do (incf line (1+ (length (results-set-results rs))))
		   finally (return line))
	     candidate-index))
    (multiple-value-bind (lisp:ignore viewport-top lisp:ignore viewport-bottom)
	(send candidate-pane :visible-cursorpos-limits :character)
      (unless (and (<= viewport-top current-candidate-line)
		   (<= current-candidate-line viewport-bottom))
	(send candidate-pane :y-scroll-to
	      (* (send candidate-pane :line-height)
		 (- current-candidate-line old-line))
	      :relative)))))

(defun clipped-p (object-position viewport-top viewport-bottom)
  (unless (and viewport-top
	       (< object-position viewport-bottom)
	       (<= viewport-top object-position))
    :clipped))

(defun clipped-cache-test (old new)
  (or (eq new :clipped)
      (eq new old)))

(scl:defmethod (redisplay-candidates statice-browser) (stream)
  (multiple-value-bind (lisp:ignore viewport-top lisp:ignore viewport-bottom)
      (send-if-handles stream :visible-cursorpos-limits :character)
    (dw:with-redisplayable-output (:stream stream :cache-value *results-set-tick*)
      (loop for line-number = 1 then (+ line-number (length (results-set-results rs)) 1)
	    for rs in *all-results-sets* do
	(scl:with-character-size (:smaller stream)
	  (format stream "  ~@\\presentation\\" rs 'results-set))
	(terpri stream)
	(dw:with-redisplayable-output (:stream stream :unique-id rs)
	  (let ((results (results-set-results rs))
		(current-rs-p (eq current-results-set rs)))
	    (declare (sys:array-register results))
	    (dotimes (i (length results))
	      (let* ((current-candidate-p (and current-rs-p
					       (= i current-candidate)))
		     (cache-value (or (clipped-p (+ line-number i)
						 viewport-top viewport-bottom)
				      current-candidate-p))
		     (candidate (aref results i))
		     (result&candidate (cons rs candidate)))
		(dw:with-redisplayable-output (:stream stream
					       :unique-id result&candidate
					       :id-test #'equal
					       :cache-value cache-value
					       :cache-test #'clipped-cache-test)
		  (cond ((eq cache-value :clipped)
			 (send stream :tyo #\space)
			 (terpri stream))
			(t
			 (cond (current-candidate-p 
				(princ #\arrow:right-open-arrow stream)
				(princ " " stream))
			       (t
				(princ "  " stream)))
			   (scl:present result&candidate 'candidate :stream stream)
			   (terpri stream))))))))))))

(scl:defmethod (redisplay-queries statice-browser) (stream)
  (multiple-value-bind (lisp:ignore viewport-top lisp:ignore viewport-bottom)
      (send-if-handles stream :visible-cursorpos-limits :character)
    (dw:with-redisplayable-output (:stream stream :cache-value *results-set-tick*)
      (loop for rs in *all-results-sets*
	    for line-number from 0 do
	(let* ((current-results-p (eq current-results-set rs))
	       (cache-value (or (clipped-p line-number viewport-top viewport-bottom)
				current-results-p)))
	  (dw:with-redisplayable-output (:stream stream :unique-id rs
						 :cache-value cache-value
						 :cache-test #'clipped-cache-test)
	    (cond ((eq cache-value :clipped)
		   (send stream :tyo #\space)
		   (terpri stream))
		  (t
		   (cond (current-results-p
			  (princ #\arrow:right-open-arrow stream)
			  (princ " " stream))
			 (t
			  (princ "  " stream)))
		   (scl:present rs 'results-set :stream stream)
		   (terpri stream)))))))))

(scl:defmethod (prompt-for-query statice-browser) (entity-type)
  (let* ((unspecified (list nil))
	 (atts (entity-type-attributes entity-type))
	 (criteria (loop for att in atts
			 collect (list (function-full-name att) (list (lisp:gensym) unspecified)))))
    (dw:with-typeout-window-for-accept-values
      (dw:accepting-values (*query-io* :label "Query:" :resynchronize-every-pass t)
	(dolist (att atts)
	  (let ((name (function-full-name att)))
	    (loop for entry in criteria do
	      (destructuring-bind (crit-name (uid value)) entry
		(when (eq crit-name name)
		  (multiple-value-bind (new-value nil unchanged)
		      (scl:accept `((criterion-for-type)
				:presentation-type ,(function-value-type-name att))
			      :prompt (string name)
			      :default nil
			      :provide-default t
			      :query-identifier uid)
		    (unless unchanged
		      (lisp:setf (second (second entry)) (or new-value unspecified))
		      (when (and (not (eq value unspecified)) (null new-value))
			(setq criteria (delete entry criteria)))
		      (when (and new-value (eq value unspecified))
			(lisp:push (list name (list (lisp:gensym) unspecified)) criteria)
			;; I'm too lazy to insert into the list
			(setq criteria
			      (sort criteria
				    #'(lisp:lambda (x y)
					(let ((x-name (first x))
					      (y-name (first y)))
					  (cond ((string-equal x-name y-name)
						 (string< (first (second x))
							  (first (second y))))
						(t
						 (string< x-name y-name)))))))))))))))))
    (let ((criteria (delete-if #'(lambda (item)
				   (eq (second (second item)) unspecified))
			       criteria)))
      (loop for entry in criteria do
	(setf (cdr entry) (second (second entry))))
      criteria)))

(scl:defmethod (count-query statice-browser) (entity-type query)
  (tv:noting-progress ("Counting")
    (with-database (db pathname)
      (with-transaction ()
	(count-entities* (type-name entity-type) :where query)))))

(scl:defmethod (execute-query statice-browser) (entity-type query count)
  (let ((results (scl:allocate-resource 'query-result-set))
	(n-entities 0))
    (tv:noting-progress-if count ("Executing Query")
      (with-database (db pathname)
	(with-transaction ()
	  (lisp:setf (fill-pointer results) 0)
	  (for-each* #'(lisp:lambda (ent) 
			 (vector-push-extend ent results)
			 (incf n-entities)
			 (tv:note-progress n-entities count))
		     (type-name entity-type)
		     :where query))))
    (let ((rs (scl:make-instance 'results-set
			     :entity-type entity-type
			     :query query
			     :results results)))
      (incf *results-set-tick*)
      (setq *all-results-sets* (nconc *all-results-sets* (list rs)))
      rs)))

(scl:defresource values-table ()
  :constructor (lisp:make-hash-table :test 'eq :locking nil)
  :initializer (clrhash object))

(defun entity-max-attribute-name-length (entity-type)
  (let ((ename (type-name entity-type)))
    (process:with-lock (*entity-max-attribute-name-length-table-lock*)
      (or (lisp:gethash ename *entity-max-attribute-name-length-table*)
	  (lisp:setf (lisp:gethash ename *entity-max-attribute-name-length-table*)
		(lisp:loop for att in (entity-type-attributes entity-type)
		      maximize (length (string (function-slot-name att)))))))))

(scl:defmethod (view-current-entity statice-browser) (stream)
  (prepare-window self viewer-pane)
  (when current-results-set
    (let ((results (results-set-results current-results-set)))
      (unless (zerop (length results))
	(browser-view-entity self stream pathname (aref results current-candidate))))))

(scl:defmethod (browser-view-entity statice-browser) (stream pathname entity-handle)
  (view-entity stream pathname entity-handle
	       #'(lisp:lambda (entity-handle fname)
		   `(browser-editing-entities ,entity-handle ',fname))))

(defun (lisp:setf browser-editing-entities) (entity-handle fname new-value)
  (let ((editing-entities
	  (scl:symbol-value-in-instance (or dw:*program* (error "No program")) 'editing-entities)))
    (cond (editing-entities
	   (let* ((already-touched (lisp:gethash entity-handle editing-entities))
		  (editing-entry (or already-touched
				     (lisp:setf (lisp:gethash entity-handle editing-entities)
					   (list (scl:allocate-resource 'values-table)
						 (scl:allocate-resource 'values-table)))))
		  (old-values (first editing-entry))
		  (new-values (second editing-entry))
		  (entity-type (get (type-of entity-handle) 'entity-type))
		  (attributes (entity-type-attributes entity-type)))
	     (unless already-touched
	       (gather-entity-values (scl:symbol-value-in-instance dw:*program* 'pathname)
				     entity-handle
				     attributes
				     old-values))
	     (lisp:setf (lisp:gethash fname new-values) new-value)))
	  (t
	   (lisp:setf (browser-attribute-value entity-handle fname) new-value)))))

(define-statice-browser-command (com-begin-edits :menu-accelerator t) ()
   (cond (editing-entities
	  (format command-pane "Edits are already in progress"))
	 (t
	  (setq editing-entities (scl:allocate-resource 'values-table)
		saved-label (send viewer-pane :label))
	  (send viewer-pane :set-label (string-append saved-label "(5 0 (NIL 0) (:SWISS :BOLD NIL) "HL12B")   (Editing Entities)0")))))

(define-statice-browser-command (com-abort-edits :menu-accelerator t) ()
   (cond (editing-entities
	  (send viewer-pane :set-label saved-label)
	  (setq saved-label nil)
	  (deallocate-edits editing-entities)
	  (setq editing-entities nil))
	 (t
	  (format command-pane "No edits in progress"))))

(define-statice-browser-command (com-end-edits :menu-accelerator t)
    (&key
      (compare-attributes '(member :none :changed :all)
			  :default *default-compare-attributes*
			  :documentation "Which attributes to compare for differences between~@
                                          editing and commit.")
      (difference-action '(member :query :abort :ignore)
			 :default *default-difference-action*
			 :documentation "Action to take when a difference is found in an~@
                                         attribute's value between editing it and committing~@
                                         it."))
   (cond (editing-entities
	  (commit-edits self :difference-action difference-action
			:compare-attributes compare-attributes)
	  (send viewer-pane :set-label saved-label)
	  (setq saved-label nil)
	  (deallocate-edits editing-entities)
	  (setq editing-entities nil))
	 (t
	  (format command-pane "No edits in progress"))))

(scl:defmethod (commit-edits statice-browser) (&key difference-action compare-attributes)
  (with-database (db pathname)
    (lisp:loop until
	    (block nil
	      (with-transaction ()
		(unless (eq compare-attributes :none)			    
		  (unless (or (compare-attributes-of-entities
				editing-entities compare-attributes)
			      (eq difference-action :ignore))
		    (lisp:ecase difference-action
		      (:abort
			(format command-pane "~&Differences found -- edits aborted")
			(return t))
		      (:query (return nil)))))
		(tv:maphash-noting-progress
		  #'(lisp:lambda (entity-handle entry)
		      (let ((new-values (second entry)))
			(maphash #'(lisp:lambda (fname new-value)
				     (lisp:setf (attribute-value entity-handle fname) new-value))
				 new-values)))
		  editing-entities
		  (format nil "Commiting edits for ~A entities"
			  (hash-table-count editing-entities)))
		t))
	  do
      (resolve-conflicts self editing-entities compare-attributes))))

;;; return t if everything compares ok.  compare-attributes is
;;; (member :none :changed :all).
(defun compare-attributes-of-entities (editing-entities compare-attributes)
  (with-transaction ()
    (maphash #'(lisp:lambda (entity-handle entry)
		 (unless (compare-entity-attributes entity-handle entry compare-attributes)
		   (return-from compare-attributes-of-entities nil)))
	     editing-entities))
  t)

;;; compare the attributes of one entity given a handle an an entry.
;;; Return nil if they don't match, t if they do.  compare-attributes
;;; says which attributes to compare.
(defun compare-entity-attributes (entity-handle entry compare-attributes)
  (let ((st (functional-database-schema-table
	      (statice-model::domain-handle-database
		(statice-model::known-entity-handle-domain entity-handle)))))
    ;; I don't believe I just did that.
    (destructuring-bind (old-values new-values) entry
      (lisp:ecase compare-attributes
	(:changed (maphash
		    #'(lisp:lambda (fname lisp:ignore)
			(let* ((function (get fname 'statice-function))
			       (att (lisp:gethash (function-is-attribute-tag function) st)))
			  (when (statice-model::indexable-p
				  (statice-model::attribute-handle-type att))
			    (multiple-value-bind (current-value not-null-p)
				(funcall fname entity-handle)
			      (unless not-null-p
				(setq current-value *internal-null-value*))
			      (unless (equal current-value
					     (lisp:gethash fname old-values))
				(return-from compare-entity-attributes nil))))))
		    new-values))
	(:all (maphash #'(lisp:lambda (fname value)
			   (let* ((function (get fname 'statice-function))
				  (att (lisp:gethash (function-is-attribute-tag function) st)))
			     (when (statice-model::indexable-p
				     (statice-model::attribute-handle-type att))
			       (multiple-value-bind (current-value not-null-p)
				   (funcall fname entity-handle)
				 (unless not-null-p
				   (setq current-value *internal-null-value*))
				 (unless (equal current-value value)
				   (return-from compare-entity-attributes nil))))))
		       old-values)))))
  t)

;;; compare-attributes is (member :none :changed :all)
(scl:defmethod (resolve-conflicts statice-browser) (editing-entities compare-attributes)
  (dw:with-typeout-window-for-accept-values
    (maphash
      #'(lambda (entity-handle entry)
	  (resolve-entity-conflicts entity-handle entry compare-attributes))
      editing-entities)))

(defun resolve-entity-conflicts (entity-handle entry compare-attributes)
  (unless (with-transaction ()
	    (compare-entity-attributes entity-handle entry compare-attributes))
    ;; some difference for this entity
    (let* ((entity-type (get (type-of entity-handle) 'entity-type))
	   (attributes (entity-type-attributes entity-type))
	   current-values)
      (unwind-protect
	  (progn
	    (setq current-values (scl:allocate-resource 'values-table))
	    (gather-entity-values (scl:symbol-value-in-instance dw:*program* 'pathname)
				  entity-handle
				  attributes
				  current-values)
	    (destructuring-bind (old-values new-values) entry
	      (dw:accepting-values (*query-io*)
		;; since :label doesn't seem to work when accepting inside typeout window
		(fixed-line (format nil "~'iResolve conflicts for ~A~" entity-handle))
		(maphash #'(lisp:lambda (name new-value)
			     (let ((choices nil))
			       (lisp:pushnew (lisp:gethash name old-values) choices :test #'equal)
			       (lisp:pushnew (lisp:gethash name current-values) choices
					:test #'equal)
			       (lisp:pushnew new-value choices :test #'equal)
			       (lisp:setf (lisp:gethash name new-values)
				     (scl:accept `(member ,@choices)
					     :stream *query-io*
					     :prompt (string name)
					     :default new-value))))
			 new-values)
	      (lisp:setf (first entry) current-values)
	      (setq current-values old-values)))
	(when current-values
	  (scl:deallocate-resource 'values-table current-values)))))))

(defun deallocate-edits (edit-table)
  (maphash #'(lambda (key entry)
	       (declare (ignore key))
	       (scl:deallocate-resource 'values-table (first entry))
	       (scl:deallocate-resource 'values-table (second entry)))
	   edit-table)
  (scl:deallocate-resource 'values-table edit-table))

(defun make-browser-attribute-value-setf (entity-handle fname)
  `(browser-attribute-value ,entity-handle ',fname))

(defun view-entity (stream pathname entity-handle
		    &optional
		    (setf-function #'make-browser-attribute-value-setf)
		    values)
  (declare (sys:downward-funarg setf-function)
	   (scl:arglist stream pathname entity-handle
			    &optional (setf-function #'make-browser-attribute-value-setf)))
  (let ((entity-values (or values (scl:allocate-resource 'values-table))))
    (unwind-protect
	(let* ((entity-type (get (type-of entity-handle) 'entity-type))
	       (attributes (entity-type-attributes entity-type)))
	  (scl:present entity-handle (type-name entity-type) :stream stream)
	  (format stream "~v  (type ~S)~" '(nil nil :smaller) (type-of entity-handle))
	  (gather-entity-values pathname entity-handle attributes entity-values)
	  (dolist (att attributes)
	    (let* ((fname (function-full-name att))
		   (att-type (or (get fname 'browser-presentation-type)
				 (function-value-type-name att)))
		   (tab-to (+ 4 (entity-max-attribute-name-length entity-type)))
		   (values (lisp:gethash fname entity-values))
		   (set-p (function-value-is-set att)))
	      (terpri stream)
	      (scl:present att '((attribute) :short-name t) :stream stream)
	      (format stream ":~VT" tab-to)
	      (multiple-value-bind (thing ptype)
		  (cond ((and set-p values)
			 (cond ((eq values *internal-null-value*)
				(values "1(Null value)0" '((sys:expression) :escape nil)))
			       ((null values)
				(values nil '((sys:expression) :escape nil)))
			       (t
				(values values
					`((maybe-abbreviated-set) :tab-to ,(1+ tab-to))))))
			(t
			 (cond ((eq values *internal-null-value*)
				(values "1(Null value)0" '((sys:expression) :escape nil)))
			       ((null values)
				(values nil '((sys:expression) :escape nil)))
			       (t
				(values values att-type)))))
		(if set-p
		    (scl:present thing ptype
			     :form (and (not (function-read-only att))
					(funcall setf-function entity-handle fname))
			     :stream stream)
		    (scl:abbreviating-output (stream :height 3 :show-abbreviation t)
		      (scl:present thing ptype
			       :form (and (not (function-read-only att))
					  (funcall setf-function entity-handle fname))
			       :stream stream)))))))
      (unless values (scl:deallocate-resource 'values-table entity-values))))
  (fresh-line stream))

(defun edit-entity (stream pathname entity-handle)
  (let* ((entity-type (get (type-of entity-handle) 'entity-type))
	 (attributes (entity-type-attributes entity-type)))
    (scl:using-resource (old-values values-table)
      (scl:using-resource (new-values values-table)
	(gather-entity-values pathname entity-handle attributes old-values)
	(maphash #'(lambda (key item)
		     (lisp:setf (lisp:gethash key new-values) item))
		 old-values)
	(view-entity stream pathname entity-handle
		     #'(lambda (entity-handle fname)
			 entity-handle
			 `(lisp:gethash ',fname ,new-values))
		     new-values)))))

(lisp:defun gather-entity-values (pathname entity-handle attributes values-table)
  (with-database (db pathname)
    (with-transaction ()
      (dolist (att attributes)
	(let ((fname (function-full-name att))
	      (set-valued-p (function-value-is-set att)))
	  (multiple-value-bind (value not-null-p)
	      (funcall fname entity-handle)
	    (lisp:setf (lisp:gethash fname values-table)
		  (if (or not-null-p set-valued-p) value *internal-null-value*))))))))

(define-statice-browser-command (com-describe-attribute :menu-accelerator nil)
    ((attribute 'attribute :provide-default nil))
   (describe-attribute attribute typeout-pane))

(define-statice-browser-command (com-next-candidate :menu-accelerator nil)
    ((n 'integer :default 1 :prompt nil))
   (when current-results-set
     (let* ((n-results (length (results-set-results current-results-set)))
	    (new-cc (min (+ current-candidate n) (1- n-results))))
       (set-current-candidate self current-results-set new-cc)
       (incf *results-set-tick*)
       (view-current-entity self viewer-pane))))

(cp:define-command-accelerator c-n-accelerator statice-browser (#\c-n)
			       ()
			       (arg-p arg)
  (case arg-p
    ((:control-u :digits) `(com-next-candidate ,arg))
    (otherwise `(com-next-candidate 1))))

(define-statice-browser-command (com-previous-candidate :menu-accelerator nil)
    ((n 'integer :default 1 :prompt nil))
   (when current-results-set
     (let ((new-cc (max (- current-candidate n) 0)))
       (set-current-candidate self current-results-set new-cc)
       (incf *results-set-tick*)
       (view-current-entity self viewer-pane))))

(cp:define-command-accelerator c-p-accelerator statice-browser (#\c-p)
			       ()
			       (arg-p arg)
  (case arg-p
    ((:control-u :digits) `(com-previous-candidate ,arg))
    (otherwise `(com-previous-candidate 1))))

(define-statice-browser-command (com-select-candidate :menu-accelerator nil)
    ((candidate 'candidate :provide-default nil))
   (set-current-candidate self (car candidate)
			  (position (cdr candidate)
				    (results-set-results (car candidate))))
   (incf *results-set-tick*)
   (view-current-entity self viewer-pane))

(scl:define-presentation-to-command-translator select-candidate
   (candidate :gesture :left)
   (candidate)
  `(com-select-candidate ,candidate))

(define-statice-browser-command (com-view-entity :menu-accelerator nil)
    ((entity-handle 'functional-entity-handle :provide-default nil :prompt "an entity"))
   (terpri viewer-pane)
   (let ((eopm (send viewer-pane :end-of-page-mode)))
     (unwind-protect
	 (progn (send viewer-pane :set-end-of-page-mode :scroll)
		(prepare-window self viewer-pane)
		(browser-view-entity self viewer-pane pathname entity-handle))
       (send viewer-pane :set-end-of-page-mode eopm))))

(scl:define-presentation-to-command-translator view-entity
   (functional-entity-handle
     :gesture :left
     :tester ((lisp:ignore)
	      (and (scl:variable-boundp dw:*program*)
		   (typep dw:*program* 'statice-browser))))
   (entity-handle)
  `(com-view-entity ,entity-handle))

(define-statice-browser-command (com-select-query :menu-accelerator nil)
    ((results-set 'results-set :provide-default nil))
   (set-current-candidate self results-set 0)
   (incf *results-set-tick*)
   (view-current-entity self viewer-pane))

(scl:define-presentation-to-command-translator select-query
   (results-set :gesture :left)
   (results-set)
  `(com-select-query ,results-set))

(scl:define-presentation-type pop-up-image ()
   :no-deftype t
   :printer ((lisp:ignore stream)
	     (format stream "~v[Click here to display image]~" '(nil :italic nil))))

(scl:define-presentation-action show-image
			   (pop-up-image t
					 :documentation "Show Image"
					 :gesture t)
  (image)
  (pop-up-image image))

(defun pop-up-image (image)
  (destructuring-bind (h w) (array-dimensions image)
    (scl:using-resource (stream dw:dynamic-window tv:default-screen :temporary-p t :blinker-p nil)
      (multiple-value-bind (left top right bottom) (send tv:default-screen :inside-edges)
	(let* ((sup-w (- right left))
	       (sup-h (- bottom top))
	       (w/2 (ash (- sup-w w) -1))
	       (h/2 (ash (- sup-h h) -1))
	       (left-edge (+ left w/2))
	       (top-edge (+ top h/2)))
	  (send stream :set-edges left-edge top-edge (+ left-edge w) (+ top-edge h))))
      (send stream :set-label `(:margin :bottom
				:string "Type any character:"))
      (send stream :set-more-p nil)
      (tv:window-mouse-call (stream :deactivate)
	(let ((*terminal-io* stream)
	      (*query-io* stream))
	  (sys:page-in-raster-array image)
	  (graphics:with-room-for-graphics (stream nil :fresh-line nil)
	    (graphics:with-graphics-transform (stream (list 1 0 0 -1 0 0))
	      (graphics:draw-image image 0 0 :stream stream :alu :flip)))
	  (send stream :tyi))))))

(lisp:setf (get 'image 'browser-presentation-type) 'pop-up-image)

(scl:defmethod (prepare-window statice-browser) (window)
  (multiple-value-bind (lisp:ignore y)
      (send window :read-cursorpos)
    (unless (zerop y)
      (let ((line-y (+ y (ash (send window :line-height) -1))))
	(send window :draw-dashed-line 0 line-y (1- (send window :inside-width)) line-y))
      (terpri window)
      (send window :clear-window))))
