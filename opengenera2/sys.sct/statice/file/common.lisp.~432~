;;; -*- Syntax: Common-Lisp; Base: 10; Mode: LISP; Lowercase: T; Package: DBFS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Definitions common to multiple DBFS modules but which don't require recompilation
;;; of callers when the definitions are changed.  Also parameters go here just to
;;; make life easier even if they just alter the behavior of one module.

;;++ eventually go through this using defgeneric

#|

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")OBJECT LEXICON:

(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")PAGE:

FILE:0  The file object is an internal cache of information about the
file.  There is only one file object per unique file-id.  The basic file
object maps page numbers (which are unique only within a file) to the
page in the database buffer.  There are two types of file objects:

2   LOCAL-FILE:0  A local file resides on the local machine, and can be
accessed without going through the server level.  Local files consist
of local-pages.

2   REMOTE-FILE:0  A remote file represents a file which resides on a
remote server.  The remote file is accessed by (essentially) a
remote-procedure call protocol to the server, which in turn operates
on its own local files corresponding to the remote file.  Remote
files consist of remote-pages.

2FILE-SYSTEM:0  The file system contains some per file system information.
As with files, there are 2LOCAL-FILE-SYSTEM0s and 2REMOTE-FILE-SYSTEM0s
depending on whether the file system resides on the local machine or not.

2SERVER:

TRANSACTION:0  The transaction object embodies a concept visible to the
external interface, but is not actually externally accessible itself.
That is, a transaction object exists per BEGIN-TRANSACTION and
END-TRANSACTION (or ABORT-TRANSACTION) interval, but is internally
maintained and is not passed to the client.  This is because since only
one transaction is permitted per process, a transaction object does not
convey meaning to the user, unlike an opening which is used as a handle
to name multiple files.

2TRANSACTION-ELEMENT:

0|#



;;; Options (visible to the client level)
(defparameter *full-verification* nil "T to turn on full complement of error detection.")
(defparameter *optimistic-locking* t "T if local lock success assumes global lock success.")
(defparameter *selective-pessimism* t "T to enable automatic adaptation to hot spots.")
(defparameter *force-out-optimistic-commands* nil "T to force out optimistic net requests.")
(defparameter *automatic-selective-pessimisim* nil 
  "T to selectively turn off optimistic locking for pages with a high rate of contention.")
(defparameter *wait-for-checkpoint* t "T to give checkpoint a chance to run.")
(defparameter *transaction-retry-limit* 100
  "Number of times to let transactions automatically execute.")
(defparameter *checkpoint-priority* 0 "Priority of the checkpoint process.")
(defparameter *check-writes* t
  "Read compares of any data written to the disk if T or eq to sys:*io-board-type*")
(defparameter *check-writes-retry-limit* 10 "# times to retry writing data before halting.")
(defparameter *use-noting-progress-for-page-locked-remotely* nil
  "Use tv:noting-progress to tell the user that we are waiting for a remotely-locked page.")
(defparameter *deadlock-detector-interval* 3)
(defparameter *mark-turnaround-timeout* (* 10 60 60)
  "Wait ten seconds for server to turn around a mark before closing the connection.")
;;++This is probably excessive.  Fix at some point.
(defparameter *dbfs-connect-timeout* (* 5 60 60)
  "Wait five minutes before timing out of a connect.")

;;; Internal options
(defvar *debug-net* nil "T when debugging network.")
(defvar *enable-trace* nil "When true transaction activity is traced in *dbfs-trace*")
(defvar *enable-full-trace* nil "When true internal state changes are traced.")
(defvar *enable-deadlock-trace* nil "When true trace deadlock detection in *deadlock-trace*")
(defvar *debug-mark* nil "T when debugging problems with marks in byte streams")
(defvar *mark-trace* nil "Trace of events relevant to marks")

(defvar *dbfs-trace* nil "When *enable-trace* is true, transaction trace stored here.")

(defun insert-trace (name &rest args)
  (atomically
    (push (list* name (get-universal-time) (copy-list args)) *dbfs-trace*)))

;;; Parameters
(defvar *maximum-client-id* (* 32 4) "The highest client-id currently allocated.")
(defvar *network-error-retry-count* 10)
(defvar *dbfs-page-server-priority* 1 "The priority of DBFS-PAGE server processes.")

;;; Internal variables
;;; If *dbfs-shutdown* is nil, DBFS is up and running.  Otherwise, DBFS is entirely
;;; disabled on this host, including all DBFS file systems on this host, and the
;;; value is a string giving a reason.
(defvar *dbfs-shutdown* "DBFS was just loaded and the warm-init list has not been run yet")
(defvar *transaction-sequence-number* 0)
(defvar *remote-id-sequence-number* 0)
(defvar *initialization-timestamp* 0)
(defvar *deadlock-trace* nil "When *enable-deadlock-trace* is true, trace deadlock detection.")
(sys:defvar-resettable *inside-dbfs* nil nil
		       "True when this process is inside DBFS itself, to disable validate.")

;;;+ should only be defined if *full-verification* is true.
(defvar *read-only-array-area* (make-area :name '*read-only-array-area*
					  :read-only t
					  :gc :static))

(defresource read-only-array (size)
  :constructor (make-array size
			   :element-type 'fixnum
			   :area *read-only-array-area*))


;;Serializes commits and aborts.
(defvar *global-commit-lock* (make-ordered-lock "Global Commit Lock" %global-commit-lock))
;;Bound to the creation time of the current transaction for this process.
(defvar *process-transaction-creation-time* nil)


;;; Meters
(defvar *count-network-errors* 0)
(defvar *network-error-table* (make-hash-table :locking nil))
(defvar *process-kills* 0)
(defvar *count-disk-write-errors* 0)
(defvar *count-network-protocol-sync-errors* 0)

(si:define-meters *dbfs-client-meters*
  *count-transactions*
  *count-nested-commits*
  *count-top-level-commits*
  *count-aborts*
  *count-pages-invalidated-by-server*
  *count-pages-not-invalidated-by-server*
  *count-server-invalidations*
  *count-lock-waits*
  *count-read-pages*
  *count-read-hits*
  *count-read-misses*
  *count-write-pages*
  *count-write-hits*
  *count-write-misses*
  #+dbfs-internal-metering *count-page-cache-lookups*
  #+dbfs-internal-metering *count-page-cache-hits*
  )

;;;; Flavors which define SETF accessors which are required early on


;;; Buffer replacement:

;; Each machine (client or server) has a pool of pages.  This pool is
;; divided up into various page sizes, and local vs remote pages.  When
;; a page is needed which does not have a buffer and/or page instance
;; already resident, the buffer replacement mechanism either recycles
;; them, or creates them.

;; get-page-queues (file-page-size) Gets the page queues of a buffer pool
;; enqueue-in-primary (nwords)	If there is room in the primary queue, 
;;				decrement space in the primary queue, and
;;				return the count, else do nothing and return NIL.
;; dequeue-from-primary (nwords)	Take note that NWORDS have been removed from the
;; 				primary queue.
;; page-pool-full ()		Returns T if all authorized buffers have been allocated.
;; note-page-allocated (nwords) Marks nwords as allocated.

;; Futher on, intermixed with basic-page and basic-file flavors and
;; methods you will find the following methods for manipulating the
;; queues in the page pool:

;; dequeue-page (page)		If the page is on a queue, remove it.
;; enqueue-page (page)		Place the page on the appropriate queue.
;; get-any-flushable-page (file) Take a flushable page, and press it into use.
;; get-any-page			Get a page, even if you have to make one.
;; get-page-buffer (file) 	Obtain a page buffer without getting a page instance.
;; return-page-buffer (file buffer) Release a page buffer not associated with a page instance.

(defflavor page-pool  (;;You could argue that we should have separate locks for
		       ;;the various page sizes and remote vs local.  If
		       ;;a global is losing, perhaps we will.  I bet it
		       ;;doesn't really matter much.
		       (lock (process:make-lock "Statice Page Pool" :recursive t))
		       ;;Hash table of local page queues keyed by page length
		       (local-queue-hash-table
			 (make-hash-table :size 10 :ignore-gc t :locking nil))
		       (local-flushed-queue (make-instance 'queue :type :FIFO))
		       ;;Hash table of local page queues keyed by page length
		       (remote-queue-hash-table
			 (make-hash-table :size 10 :ignore-gc t :locking nil))
		       (remote-flushed-queue (make-instance 'queue :type :FIFO))
		       (nwords-in-primary-queue 0)
		       (nwords-allowed)
		       (nwords-allocated 0))

	   ()
  (:readable-instance-variables nwords-in-primary-queue nwords-allocated nwords-allowed)
  (:writable-instance-variables nwords-allowed))


;;Called when a local file is created.
;;Returns the list of lock, primary-queue, secondary-queue, and flushed-queue
(defmethod (get-local-page-pool page-pool) (file-page-size)
  (process:with-lock (lock)
    (or (gethash file-page-size local-queue-hash-table)
	(setf (gethash file-page-size local-queue-hash-table)
	      (list lock (make-instance 'queue :type :FIFO)
		    (make-instance 'queue :type :LIFO) local-flushed-queue)))))

;;Called when a remote file is opened (the page size is not available until then).
;;Returns the list of lock, primary-queue, secondary-queue, and flushed-queue
(defmethod (get-remote-page-pool page-pool) (file-page-size)
  (declare (values lock primary-queue secondary-queue flushed-queue))
  (process:with-lock (lock)
    (or (gethash file-page-size remote-queue-hash-table)
	(setf (gethash file-page-size remote-queue-hash-table)
	      (list lock (make-instance 'queue :type :FIFO)
		    (make-instance 'queue :type :LIFO) remote-flushed-queue)))))

(defmethod (enqueue-in-primary page-pool) (nwords)
  (declare (values primary-enqueue-ok))
  (if (< nwords-in-primary-queue nwords-allowed)
      (incf nwords-in-primary-queue nwords)
    NIL))

(defmethod (dequeue-from-primary page-pool) (nwords)
  (decf nwords-in-primary-queue nwords))

(defmethod (note-page-allocated page-pool) (nwords)
  (incf nwords-allocated nwords))

(defmethod (page-pool-full page-pool) ()
  (> nwords-allocated nwords-allowed))

;;This should only be used by the test suites.
(defmethod (reset-page-pool page-pool) (&optional (allow-n-words nil))
  (process:with-lock (lock)
    (flet ((empty-it (ignore tables)
	     (destructuring-bind (ignore primary secondary ignore)
		 tables
	       (empty primary)
	       (empty secondary))))
      (maphash #'empty-it local-queue-hash-table)
      (empty local-flushed-queue)
      (maphash #'empty-it remote-queue-hash-table)
      (empty remote-flushed-queue))
    (setf nwords-in-primary-queue 0
	  nwords-allowed allow-n-words
	  nwords-allocated 0)))


;;The number of words of buffer that Statice is authorized to use as an LRU buffer 
;;is equal to page-pool-factor of (physical-memory - page-pool-reserve).
;;The user can specify page-pool-factor and page-pool-reserve.
(defmethod (set-buffer-replacement-limit page-pool) (&key (factor #-VLM 4 #+VLM 1/4) (limit (* 1024 1024)))
  (setf nwords-allowed
	(ceiling
	  (* factor
	     (max (- #-VLM 
		     (* storage:*count-usable-pages* 
			;; Remember page sizes are in words and already
			;; compensate for "data pages" being larger than
			;; "vm pages"
			sys:page-size)
		     ;; --- For the VLM, use suggested VM size (for now,
		     ;; need a better number though, I think; unless we
		     ;; believe Host's VM is so superior that letting
		     ;; buffers swap is preferable to re-fetching them.
		     ;; Which darn well may be true for remote
		     ;; buffers!!!)
		     #+VLM (sys:vlm-virtual-memory-size)
		     limit)
		  0)))))

(defvar *page-pool* (make-instance 'page-pool))

(defun set-buffer-replacement-parameters (&key (page-pool-factor #-VLM 4 #+VLM 1/4)
					       (page-pool-limit (* 1024 1024)))
  (set-buffer-replacement-limit *page-pool* :factor page-pool-factor :limit page-pool-limit))

;;Called by INITIALIZE-DBFS
(defun initialize-page-pool ()
  (unless (page-pool-nwords-allowed *page-pool*)
    (set-buffer-replacement-limit *page-pool*)))
	  

(defvar *dbfs-page-area* (make-area :name '*dbfs-page-area* :gc :static))

(defmacro with-page-pool ((primary-queue &optional secondary-queue (flushed-queue nil))
			  &body body)
  `(destructuring-bind (.lock. ,primary-queue
			 ,@(if secondary-queue
					       (append (ncons secondary-queue)
						       (if flushed-queue (ncons flushed-queue)
							   '(&rest ignore)))
					       '(&rest ignore)))

       page-pool
     (process:with-lock (.lock.)
       (sys:without-aborts ("Statice is in the process of updating its buffer data ~@
			     structures.  If you abort now, Statice may become unusable
			     until this machine is cold-booted.")
	 . ,body))))

;;Only maybe-make-flushable needs this
(defmacro with-page-pool-of-file ((file primary-queue
					&optional (secondary-queue nil) (flushed-queue nil))
				  &body body)
  `(destructuring-bind (.lock. ,primary-queue
			       ,@(if secondary-queue
				     (append (ncons secondary-queue)
					     (if flushed-queue (ncons flushed-queue)
						 '(&rest ignore)))
				     '(&rest ignore)))

       (file-page-pool ,file)
     (#+ignore process:with-lock
      #-ignore with-lock-no-hang (.lock.)
       (sys:without-aborts ("Statice is in the process of updating its buffer data ~@
			     structures.  If you abort now, Statice may become unusable
			     until this machine is cold-booted.")
	 . ,body))))


;;;; 1Pages
0(defflavor basic-page
	((lock (make-ordered-simple-lock "Page Latch" %page-lock))
	 ;;Only one process is allowed to commit at a time, so the commit lock
	 ;;arg is protected.
	 commit-lock-arg			; Lock argument used by commit and abort.
	 file					; Which file this page is an element of
	 (number nil)				; The page number within the file
	 transactions				; Transactions holding a lock on this page
	 (states 0)				2; what was state, lock-state, and
						; write-state, plus permanent
0	 pending				; Pending lockers
	 (data-array nil)			; The array with the local copy of the data
	 (byte-array nil)			; Bytes indirected to data-array.
	 (saved-data-array-vector nil))		; Saved copies of data array in recurs. trans.

	(doubly-linked-list-mixin)
  :abstract-flavor				; Should be mixed with a type of page
  (:conc-name "PAGE-")
  (:writable-instance-variables file)
  (:readable-instance-variables lock data-array byte-array
				transactions file number))

(defmethod (make-instance basic-page) (&rest options)
  (ignore options)
  (setf commit-lock-arg (process:make-lock-argument lock)))

#|

TRANSACTIONS is normally just the transaction holding the lock, although it
can also be a list of transactions running on the local processor sharing a
read lock.  If it is a list, the list will be very small, so using a list is
appropriate.

LOCK-STATE must be one of the values of *lock-states*

STATE can be one of the following values:

  UNINITIALIZED	The DATA-ARRAY is invalid, it is not known if the page exists or not.
  INVALID	The DATA-ARRAY is invalid and needs to be read from the server.  This
		  state is used when a transaction is aborted
		  which had modified the data array (i.e. an abort occurs when the
		  state had been 'mutable), causing the page to be invalidated so that
		  it will have to be reverted if it is accessed again.
  VALID		The DATA-ARRAY is valid.
  NONEXTANT	The page does not exist; the DATA-ARRAY is invalid.

PENDING is a list of transactions which are waiting to lock the page.

WRITE-STATE can be:
  NIL           The DATA-ARRAY is immutable.
  MUTABLE       The DATA-ARRAY can be modified.
  MODIFIED	The DATA-ARRAY has been modified.
  WRITTEN       The DATA-ARRAY is mutable, and has been modified, but not since
		the last REDO-PAGE record was written.

|#

(defmacro-in-flavor (permanent basic-page) ()
  '( (page-state-permanent states) 0))

(defmethod (page-permanent basic-page) ()
  (permanent))

(defmethod ((setf page-permanent) basic-page) (value)
  (setf (page-state-permanent states) (if value 1 0)))

(defmacro-in-flavor (data-state basic-page) ()
  '(page-state-data-state states))

(defmethod (page-data-state basic-page) ()
  (data-state))

(defmethod ((setf page-data-state) basic-page) (new-state)
  (setf (data-state) new-state))

(defmacro-in-flavor (write-state basic-page) ()
  '(page-state-write-state states))

(defmethod (page-write-state basic-page) ()
  (write-state))

(defmethod ((setf page-write-state) basic-page) (value)
  (setf (write-state) value))

(defmacro-in-flavor (lock-state basic-page) ()
  '(page-state-lock-state states))

(defmethod (page-lock-state basic-page) ()
  (lock-state))

(defmethod ((setf page-lock-state) basic-page) (value)
  (setf (lock-state) value))
;;;; 1Error objects

0(defflavor dbfs-error () (error))

(defflavor file-system-error (name error-string) (dbfs-error)
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :name :error-string))

(defmethod (:report file-system-error) (stream)
  (format stream "~A: file system name ~A." error-string name))

(defflavor nonextant-file-system () (file-system-error)
  (:default-init-plist :error-string "No such file system"))

(defflavor file-system-already-exists () (file-system-error)
  (:default-init-plist :error-string "File system already exists"))

(defflavor invalid-file-system () (file-system-error)
  (:default-init-plist :error-string "File system is not a DBFS file system"))

(defflavor disabled ((reason nil)) ()
  (:initable-instance-variables reason)
  (:readable-instance-variables reason))

(defmethod (:report disabled :after) (stream)
  (when reason
    (format stream "  ~A" reason)))

(defflavor file-system-disabled () (disabled file-system-error)
  (:default-init-plist :error-string "File system is disabled"))

(defmethod (dbg:proceed file-system-disabled :enable) ()
  "Enable the file system and proceed"
  (values ':enable))

(defflavor dbfs-disabled () (disabled dbfs-error)
  (:default-init-plist :reason "DBFS is disabled"))

(defmethod (:report dbfs-disabled) (stream)
  (format stream "DBFS is disabled."))

(defflavor no-transaction (attempt) (dbfs-error)
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :attempt))

(defmethod (:report no-transaction) (stream)
  (format stream "~A requires a current transaction - use WITH-TRANSACTION." attempt))

(defflavor transaction-retry-limit-exceeded () (dbfs-error))

(defmethod (:report transaction-retry-limit-exceeded) (stream)
  (format stream "Transaction retry limit exceeded."))

(defflavor file-error (portal error-string) (dbfs-error)
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :portal :error-string))

(defmethod (:report file-error) (stream)
  (format stream "For ~A: ~A" portal error-string))

(defflavor nonextant-file () (file-error)
  (:default-init-plist :error-string "file doesn't exist"))

(defflavor file-already-exists () (file-error)
  (:default-init-plist :error-string "file already exists"))

(defflavor invalid-file-operation (attempt) (file-error)
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :attempt))
  
(defmethod (:report invalid-file-operation) (stream)
  (format stream "Attempt to ~A using ~A: ~A." attempt portal error-string))

(defflavor file-id-invalid () (invalid-file-operation)
  (:default-init-plist :error-string "file ID invalid"))

(defflavor invalid-page-operation (page-n) (invalid-file-operation)
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :page-n))

(defmethod (:report invalid-page-operation) (stream)
  (format stream "Attempt to ~A of page number ~D. using ~A: ~A."
	  attempt page-n portal error-string))

(defflavor nonextant-page () (invalid-page-operation)
  (:default-init-plist :error-string "page does not exist"))

;;++ make a handler to create the page and continue

(defflavor page-already-exists () (invalid-page-operation)
  (:default-init-plist :error-string "page already exists"))

;;; Objects returned as the value of a transaction-abort throw.

(defflavor transaction-abort () (dbfs-error)
  (:documentation "All transaction aborts are based upon this flavor."))

(defmethod (:report transaction-abort) (stream)
  (format stream "Transaction aborted."))

(defflavor simple-transaction-abort (reason) (transaction-abort)
  (:documentation "Basic non-restartable transaction abort with a string reason.")
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :reason))

(defmethod (:report simple-transaction-abort) (stream)
  (format stream "Transaction aborted due to a ~A." reason))

(defflavor system-shutdown-transaction-abort () (simple-transaction-abort)
  (:default-init-plist :reason "system shutdown"))

(defflavor warm-boot-transaction-abort () (simple-transaction-abort)
  (:default-init-plist :reason "warm boot"))

(defflavor network-hard-error-transaction-abort
	(network-error)
	(sys:network-error transaction-abort)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (:report network-hard-error-transaction-abort) (stream)
  (format stream "Transaction aborted due to network error:~%~A" network-error))

(defflavor restartable-transaction-abort () (transaction-abort)
  (:documentation "All restartable transaction aborts are based upon this flavor."))

(defmethod (:report restartable-transaction-abort) (stream)
  (format stream "Restartable transaction abort."))

(defflavor simple-restartable-transaction-abort (reason) (restartable-transaction-abort)
  :initable-instance-variables
  :readable-instance-variables
  (:documentation "Basic restartable transaction abort with a string reason.")
  (:required-init-keywords :reason))

(defmethod (:report simple-restartable-transaction-abort) (stream)
  (format stream "Restartable transaction abort due to a ~A." reason))

(defflavor deadlock-restartable-transaction-abort ()
	   (simple-restartable-transaction-abort))

(defflavor two-transaction-deadlock-restartable-transaction-abort ()
	   (deadlock-restartable-transaction-abort)
  (:default-init-plist :reason "two-transaction deadlock"))

(defflavor n-transaction-deadlock-restartable-transaction-abort (n)
	   (deadlock-restartable-transaction-abort)
  (:default-init-plist :reason "n-transaction deadlock")
  (:initable-instance-variables n)
  (:readable-instance-variables n))

(defmethod (:report n-transaction-deadlock-restartable-transaction-abort) (stream)
  (format stream "Restartable transaction abort due to a ~D-transaction deadlock." n))

(defflavor cache-flush-restartable-transaction-abort ()
	   (simple-restartable-transaction-abort)
  (:default-init-plist :reason "cache flush"))

(defflavor cache-skew-restartable-transaction-abort ()
	   (simple-restartable-transaction-abort)
  (:default-init-plist :reason "cache skew"))

(defflavor network-error-restartable-transaction-abort ()
	   (simple-restartable-transaction-abort)
  (:default-init-plist :reason "network error"))

(defflavor server-restart-restartable-transaction-abort ()
	   (simple-restartable-transaction-abort)
  (:default-init-plist :reason "server restart"))

(defflavor page-invalid-restartable-transaction-abort ()
	   (simple-restartable-transaction-abort)
  (:default-init-plist :reason "page invalid"))

(compile-flavor-methods file-system-error no-transaction
			invalid-file-operation invalid-page-operation
			file-system-disabled dbfs-disabled
			transaction-abort restartable-transaction-abort
			simple-restartable-transaction-abort simple-transaction-abort
			transaction-retry-limit-exceeded file-error
			network-hard-error-transaction-abort
			n-transaction-deadlock-restartable-transaction-abort 

			#+ignore
			(;; These don't really need to be here as there are no methods
			 nonextant-file file-already-exists
			 invalid-file-system nonextant-file-system
			 file-system-already-exists
			 nonextant-page page-already-exists
			 system-shutdown-transaction-abort
			 two-transaction-deadlock-restartable-transaction-abort
			 cache-flush-restartable-transaction-abort
			 cache-skew-restartable-transaction-abort
			 network-error-restartable-transaction-abort
			 server-restart-restartable-transaction-abort
			 page-invalid-restartable-transaction-abort
			 warm-boot-transaction-abort))

;;; 1File-IDs

0;;; *file-id-table* maps from numeric unique IDs, expressed as 3-lists,
;;; to file-id instances.  It acts as a global "obarray"; there is never
;;; more than one file-id instance with the same numeric UID value.
;;; This table is never cleared, even on shutdown and initialization,
;;; because DBFS hands these out to callers who might store them.  In
;;; particular, model level stores them in *databases*.
(defvar *file-id-table* (make-hash-table :test 'equal :locking nil))
(defvar *file-id-table-lock* (make-ordered-lock "File ID Table Lock" %file-id-table-lock))

;;; *file-table* is a hash table mapping file-id instances into file
;;; instances.  It contains every file that has been allocated since
;;; DBFS was initialized.  +++ *file-table-lock* isn't used everywhere
;;; that ought to use it.
(defvar *file-table* (make-hash-table :locking nil))
(defvar *file-table-lock* (make-ordered-lock "File Table Lock" %file-table-lock))

(defun lookup-file-id (word0 word1 word2)
  (with-lock (*file-id-table-lock*)
    (lookup-file-id-internal word0 word1 word2)))

(defun lookup-file-id-internal (word0 word1 word2)
  (with-stack-list (id word0 word1 word2)
    (or (fast-gethash id *file-id-table*)
	(setf (gethash (list word0 word1 word2) *file-id-table*)
	      (make-file-id word0 word1 word2)))))

(defflavor file-id
	((timestamp nil)
	 (file nil))				; Cache
	(uid:unique-id)
  (:constructor make-file-id (uid::w0 uid::w1 uid::w2)))

(defgeneric lookup-file (file-id file-system-name &optional must-be-local-p disabled-ok-p)
  (:method (file-id)
   (declare (values file))
   ;; The cache lookup can occur outside of the lock since file objects are only created,
   ;; never destroyed.
   (or (and (eql timestamp *initialization-timestamp*) file)
       ;; Have to lookup the file-system just to ensure that it isn't shutdown.
       (let ((file-system (lookup-file-system file-system-name must-be-local-p
					      disabled-ok-p)))
	 (with-lock (*file-table-lock*)
	   ;; Try to find the file in *file-table*.  Make sure that we
	   ;; acually find a file, and that the file system instance
	   ;; matches.  It might not match if things have been
	   ;; reinitialized, mainly during Statice debugging.
	   (setq file (modify-hash *file-table* self
				   #'(lambda (key file found-p)
				       (declare (ignore key found-p))
				       (if (and file (eq (file-file-system file) file-system))
					   file
					   ;; Not found in *file-table*.  Allocate a new one.
					   (allocate-file file-system self))))))
	 (setq timestamp *initialization-timestamp*)
	 file))))

;;; For background invalidation.  We only have the file id.  If the file
;;; is still kicking around, return the file object which represents it.

(defmethod (cached-lookup-file file-id) ()
  (declare (values file))
  ;; The cache lookup can occur outside of the lock since file objects are only created,
  ;; never destroyed.
  (or (and (eql timestamp *initialization-timestamp*) file)
      (with-lock (*file-table-lock*)
	;; Try to find the file in *file-table*.  Make sure that we
	;; acually find a file, and that the file system instance
	;; matches.  It might not match if things have been
	;; reinitialized, mainly during Statice debugging.
	(fast-gethash self *file-table*))))


(defmethod (unlookup-file file-id) ()
  (with-lock (*file-table-lock*)
    (remhash self *file-table*)
    (setq file nil)))

(defgeneric file-id-words (file-id)
  (:method (file-id)
   (declare (values uid::w0 uid::w1 uid::w2))
   (values uid::w0 uid::w1 uid::w2)))

(defmethod (:print-self file-id) (stream print-depth slashify-p)
  (ignore print-depth)
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "File-ID [~D ~D ~D]" uid::w0 uid::w1 uid::w2))
      (format stream "File-ID [~D ~D ~D]" uid::w0 uid::w1 uid::w2)))

(compile-flavor-methods file-id)

;;;; 1Basic transactions

0(defflavor basic-transaction
	((lock (make-simple-lock "Transaction Lock"))
	 pending				; NIL or page the transaction is waiting on
	 creation-time				; The time that the transaction was created
	 error					; NIL or a transaction abort condition object
	 inter-process-abort			; T if some other process is aborting
						; this transaction.
	 depth
	 process
	 (elements (make-hash-table :locking nil :size 1))	; Maps commit-unit to element
	 (file-element (make-hash-table :locking nil :size 1))	; Maps file to element
	 file-element-cache)
	()
  :abstract-flavor
  (:conc-name "TRANSACTION-")
  (:readable-instance-variables lock error process creation-time)
  (:writable-instance-variables pending inter-process-abort error))

;;; initialize-transaction is the resource-initializer for the transaction
;;; resource, so this is called when a new top-level transaction is created.
(defgeneric initialize-transaction (transaction)
  (:method (basic-transaction)
   (setq process *current-process*
	 depth 0
	 error nil
	 inter-process-abort nil
	 pending nil
	 file-element-cache nil)
   (reset-lock lock)
   (clrhash elements)
   (clrhash file-element)
   ;;+ Have to use some way of sequencing transactions which works across
   ;; machines.  Universal times don't really solve this, and besides,
   ;; they cons bignums.
   (setq creation-time (or *process-transaction-creation-time*
			   (setf *process-transaction-creation-time* 
				 (si:incf* *transaction-sequence-number*))))))

;;; open-transaction is called when a process enters a transaction,
;;; whether starting a top level or a recursive transaction.
(defgeneric open-transaction (transaction)
  (:method (basic-transaction)
   (incf depth)))

(defgeneric lookup-file-element (transaction file)
  (:method (basic-transaction)
   ;; This is called frequently by the client interfaces, so has a one element
   ;; cache to optimize the usual case where primarily the same file system is being used
   ;; a number of successive times.
   ;; This can bypass the normal locking system since transaction elements are
   ;; only inserted into a transaction, and are never removed until the transaction
   ;; terminates.  And if the cache is wrong in that it misses something which is
   ;; being inserted, it will then fall into the code which will find it while
   ;; holding the correct lock.
   (let ((cache file-element-cache)
	 (commit-unit (atomic-commit-unit file)))
     (or (and cache
	      (eq commit-unit (transaction-element-atomic-commit-unit cache))
	      cache)
	 (setq file-element-cache
	       (or (fast-gethash file file-element)
		   (setf (gethash file file-element)
			 (or (fast-gethash commit-unit elements)
			     (setf (gethash commit-unit elements)
				   (allocate-transaction-element commit-unit self))))))))))

#+ignore
(defmethod (update-transaction basic-transaction) ()
  ;; Only do a commit when at top level.
  (with-lock (lock)
    (when (= 1 depth)
      (maphash #'(lambda (ignore element) (update element)) elements))))

;;Better have *global-commit-lock*
(defmethod (latch-all-transaction-element-pages basic-transaction) ()
  (declare (values successful losing-page))
  (let ((successful nil)
	(losing-page nil)
	(pending-in-elements t))
    (sys:with-stack-array (locked-elements (hash-table-count elements) :fill-pointer 0)
      (unwind-protect 
	  (block locking-all-elements
	    (maphash #'(lambda (ignore element)
			 (multiple-value-bind (win page)
			     (latch-all-pages element)
			   (if win
			       ;;remember that we locked this one
			       (vector-push element locked-elements)
			       (progn 
				 (setq losing-page page)
				 (return-from locking-all-elements)))))
		     elements)
	    (when (and pending
		       (not (holding-lock (page-lock pending))))
	      (setf pending-in-elements nil)
	      (unless (null (latch-page-no-wait pending))
		(setf losing-page pending)
		(return-from locking-all-elements)))
	    (setq successful t))
	(unless successful
	  (loop for element being the array-elements of locked-elements
		do (unlatch-all-pages element nil)))))
    (values successful losing-page pending-in-elements)))

;;Better have *global-commit-lock*
(defmethod (unlatch-all-transaction-element-pages basic-transaction) ()
  (maphash #'(lambda (ignore element)
	       (unlatch-all-pages element nil))
	   elements))


;;Better have *global-commit-lock*
(defmethod (carefully-unlatch-all-transaction-element-pages basic-transaction) ()
  (maphash #'(lambda (ignore element)
	       (carefully-unlatch-all-pages element))
	   elements))


(defmethod (check-state basic-transaction) (&optional attempt)
  "Make sure the transaction does not have an error."
  (when error
    (close-transaction self))
  (unless (plusp depth)
    (error 'no-transaction :attempt attempt)))

(defmethod (:print-self basic-transaction) (stream print-depth slashify-p)
  print-depth					; Ignore
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "~A" (type-of self)))
      (format stream "Transaction for ~A" process)))

(defmethod (show-status basic-transaction) (&key (stream *standard-output*))
  "Show the status of the transaction."
  (format stream "~&~A: depth ~D, process state: ~A" self depth
	  (and process (process:process-whostate process)))
  (tv:with-indentation (stream 2)
    (when error
      (format stream "~%Error: ~A" error))
    (when pending
      (format stream "~%Waiting to lock ~A" pending))
    (tv:with-indentation (stream 2)
      (maphash #'(lambda (ignore element)
		   (declare (sys:downward-function))
		   (show-status element :stream stream))
	       elements))
    (tv:with-indentation (stream 2)
      (maphash #'(lambda (open-file element)
		   (declare (sys:downward-function))
		   (format stream "~%Open file ~S maps to ~S" open-file element))
	       file-element))))

;;;; 1Basic transaction elements

0#|

Transaction-elements group together all the pages in use by a single
transaction which can be committed atomically as far as this client machine
is concerned.  That is, all the pages in use by the transaction for each
local file system will have a separate transaction-element since a local
file system is the atomic unit for commit.  However, all remote file systems
for a given server can be grouped into a single transaction-element since
the remote server will use a two-phase protocol itself to make the commit
atomic.

|#

(defvar *default-pages-size* 100)

(defflavor basic-transaction-element
	(transaction
	 atomic-commit-unit
	 (pages (make-insert-only-set *default-pages-size*))
	 modified-page-p			; Used to optimize read-only transactions
	 )
	()
  :abstract-flavor
  (:conc-name "TRANSACTION-ELEMENT-")
  (:readable-instance-variables transaction atomic-commit-unit)
  (:writable-instance-variables modified-page-p))

(defmethod (initialize-transaction-element basic-transaction-element) (tran commit-unit)
  (setq transaction tran
	atomic-commit-unit commit-unit
	modified-page-p nil)
  (clear-set pages))

;;Has daemons which do something useful for some flavors.
(defmethod (deinitialize-transaction-element basic-transaction-element) ()
  nil)

(defmethod (insert-page basic-transaction-element) (page)
  (set-push page pages))

(defmethod (commit basic-transaction-element) ()
  ;; First, write out all the modified pages to the log for this file system.
  (doing-over-set (page pages)
    (when (= %modified (page-write-state page))
      (if modified-page-p
	  (write-dbfs-page self page)
	  (error "Read-only commit called with modified pages."))))
  ;; Then atomically commit the changes.
  (sys:without-aborts ("The final stage of committing a transaction must be atomic.")
    (finish-commit self)))

;;; asynch-p is explained in the comment in front of the
;;; close-transaction method for transaction.  force-latch is used only
;;; by warm booting, and it means to abort-lock the page's latch.
(defmethod (abort basic-transaction-element) (asynch-p &optional force-latch)
  (doing-over-set (page pages)
    (when force-latch
      ;; During warm boot, there are no other processes running, and if
      ;; a page were to be left with its latch set, we'd wait forever.
      (abort-lock (page-lock page)))
    (when (and (sys:bit-member (page-write-state page)
			       (logior (rot 1 %modified) (rot 1 %written)))
	       (= (page-data-state page) %valid))
      (setf (page-data-state page) %invalid))
    (when ( (page-write-state page) %na)
      (abort-dbfs-page self page))
    (unlock-page page transaction t))
  (finish-abort self asynch-p))


;;; When entering a recursive transaction, save the data of all pages of
;;; this element.
(defmethod (save-data-of-element basic-transaction-element) (depth)
  (doing-over-set (page pages)
    (save-data-array page depth)))

;;; When aborting a recursive transaction, restore the data of all
;;; pages of this element from the saved data.
(defmethod (restore-data-of-element basic-transaction-element) (depth)
  (doing-over-set (page pages)
    (restore-data-array page depth)))

;;; acquire page latches on all pages in a transaction element.  if
;;; successfully acquire all of them, return t.  if fail, unlock the
;;; ones we locked, and return nil.
;;Better have *global-commit-lock*
(defmethod (latch-all-pages basic-transaction-element) ()
  (declare (values successful losing-page))
  ;; this is somewhat unmodular, but there appears to be no good way to
  ;; do what I need here, given the tools that exist...	
  (let* ((i 0)
	 (page-that-failed nil))
    (unwind-protect 
	(loop while (< i (fill-pointer pages))
	      for page = (aref pages i)
	      until (setf page-that-failed (latch-page-no-wait page))
	      do (incf i)
	      finally (return t))
      ;; if failed, unlock the ones that we've locked, and return the one
      ;; that we stumbled over.
      (unless (null page-that-failed)
	(loop for j below i
	      for page = (aref pages j)
	      do (unlock (page-lock page)))))
    (values (null page-that-failed) page-that-failed)))

;;Better have *global-commit-lock*
(defmethod (unlatch-all-pages basic-transaction-element) (prior-pending)
  ;; much easier; just unlatch them all
  (loop for i below (fill-pointer pages)
	as page = (aref pages i)
	do (unless (eq page prior-pending)
	     (unlatch-page page))))

;;Like above, but makes sure we haven't already unlocked it, and then
;;someone else locked it.
;;Better have *global-commit-lock*
(defmethod (carefully-unlatch-all-pages basic-transaction-element) ()
  (loop for i below (fill-pointer pages)
	do (carefully-unlatch-page (aref pages i))))

(defmethod (maybe-wakeup-process basic-transaction) ()
  ;;This forces the test to occur in the original process, not in this one.
  ;;We don't want to go blocked waiting for a latch for a different page
  ;;while we hold the latch for the page we are currently unlocking.
  (process:wakeup-without-test process))

(defun maybe-wakeup-transaction (pending)
  (maybe-wakeup-process (first pending)))

(defmethod (deallocate-element basic-transaction-element) ()
  (deallocate-transaction-element atomic-commit-unit self))


(defmethod (validate basic-transaction-element) () t)	; Normally don't need to do anything

(defmethod (:print-self basic-transaction-element) (stream print-depth slashify-p)
  print-depth					; Ignore
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "~A" (type-of self)))
      (format stream "Element of ~A" transaction)))

(defmethod (show-status basic-transaction-element) (&key (stream *standard-output*))
  (format stream "~&~A, ~A~:[~; (has modified pages)~]"
	  self atomic-commit-unit modified-page-p)
  (when (plusp (fill-pointer pages))
    (format stream "~%  Has the following pages locked:")
    (tv:with-indentation (stream 4)
      (doing-over-set (page pages)
	(format stream "~%~A" page)))))

;;;; 1Basic file systems

0(defvar *file-system-table* 
	(make-hash-table :test #'string= :locking nil))
(defvar *file-system-table-lock* (make-ordered-lock "File System Table Lock"
						    %file-system-table-lock))

(defvar *file-system-cache-lock* (process:make-lock "Statice file system cache"))
(defvar *file-system-cached-name* nil)
(defvar *file-system-cache* nil)

;;; If a file system is disabled, but this variable is bound to the file
;;; system, act as if it is enabled for purposes of this caller.  That
;;; is, you can bind this variable to a file-system object and it'll
;;; appear enabled even if it's disabled.  The cache is not set, so that
;;; the magic is not leaked to other callers.  This is a special side
;;; door for backup restore, which needs to get into the file system and
;;; make things consistent before the general public can see.
(defvar *specially-enabled-file-system* nil)

;;; name should be the name of a file system in the namespace.  Return
;;; the corresponding file-system object, the true name of the
;;; file-system object, and a host, signalling an error if anything is
;;; amiss.  If must-be-local is specified, the target host of the file
;;; system must be the local host.
(defun find-file-system-object-named (file-system-name &optional must-be-local)
  (declare (values file-system-object truename host))
  (let ((object (neti:find-object-named :file-system file-system-name)))
    (unless (member (send object :type) '(:dbfs :ufs)) ;++++ fix this later
      (error 'invalid-file-system :name file-system-name
	     :error-string "The TYPE field of the namespace object must be DBFS"))
    (let ((host (send object :host)))
      (when (and must-be-local (not (eq net:*local-host* host)))
	(error 'nonextant-file-system
	       :name file-system-name
	       :error-string (format nil "Attempt to use a file system on a remote host.~@
                                          The server for ~A is ~A but this host is ~A"
				     object host net:*local-host*)))
      (values object (send (send object :primary-name) :qualified-string) host))))

(defun lookup-file-system (file-system-name &optional must-be-local-p disabled-ok-p)
  ;; This happens with only medium frequency, but a cache doesn't hurt.  Especially
  ;; since it should have a fairly good hit ratio.
  ;; The cache can be done outside of the lock since file systems are essentially only
  ;; inserted into the table, and if another process is inserting, the cache will
  ;; simply miss and the right lookup will follow.  Or if it gets old cache data,
  ;; the file system it points to will still be valid.
  (multiple-value-bind (cached-name cache)
      (process:with-lock (*file-system-cache-lock*)
	(values *file-system-cached-name* *file-system-cache*))
      (let ((file-system (and cached-name
			      (string= cached-name file-system-name)
			      cache)))
	(unless file-system
	  (with-lock (*file-system-table-lock*)
	    (setq file-system (fast-gethash file-system-name *file-system-table*))
	    (unless file-system
	      ;; Lookup the file system in the namespace
	      (multiple-value-bind (object truename host)
		  (find-file-system-object-named file-system-name)
		;; Make sure the truename isn't cached
		(setq file-system (fast-gethash truename *file-system-table*))
		(if file-system
		    ;; The truename is cached, so the file system already exists.
		    ;; Might as well map the original name to the file system as
		    ;; well so that the namespace will not have to be
		    ;; used next time.
		    (setf (gethash file-system-name *file-system-table*)
			  file-system)
		    ;; Create a new file system
		    (progn
		      (setq file-system (if (eq host net:*local-host*)
					    (make-local-file-system
					      truename
					      object)
					    (make-remote-file-system
					      truename
					      (lookup-remote-server host))))
		      (setf (gethash truename *file-system-table*) file-system)
		      (unless (string= truename file-system-name)
			(setf (gethash file-system-name *file-system-table*)
			      file-system))
		      (when *dbfs-shutdown*
			(shutdown-file-system
			  file-system
			  (format nil "All file systems on host ~A are shut down:~%~A"
				  neti:*local-host*
				  *dbfs-shutdown*))))))))
	  (when (and (not disabled-ok-p)
		     (file-system-shutdown-reason file-system)
		     (not (eq file-system *specially-enabled-file-system*)))
	    (signal-proceed-case (()
				  'file-system-disabled
				  :name file-system-name
				  :reason (file-system-shutdown-reason file-system))
	      (:enable
		(enable-file-system file-system)
		nil)))
	  (unless (eq file-system *specially-enabled-file-system*)
	    (process:with-lock (*file-system-cache-lock*)
	      (setq *file-system-cached-name* file-system-name)
	      (setq *file-system-cache* file-system))))
	(when (and must-be-local-p
		   (not (local-p file-system)))
	  (error 'nonextant-file-system
		 :name file-system-name
		 :error-string "File system must be local"))
	file-system)))

;;; Remove all the names of this file-system from the name -> file-system
;;; translation maintained by *file-system-table* and its cache.
(defun remove-file-system (file-system)
  (let ((names nil))
    (with-lock (*file-system-table-lock*)
      (maphash #'(lambda (name fs)
		   (when (eq fs file-system)
		     (push name names)))
	       *file-system-table*)
      (dolist (name names)
	(remhash name *file-system-table*)))
    (process:with-lock (*file-system-cache-lock*)
      (when (eq file-system *file-system-cache*)
	(setq *file-system-cache* nil)
	(setq *file-system-cached-name* nil)))))
 
(defflavor basic-file-system
	(name)
	()
  :abstract-flavor
  (:conc-name "FILE-SYSTEM-")
  (:readable-instance-variables name)
  (:initable-instance-variables name))

(defgeneric local-p (basic-file-system)
  (:method (basic-file-system)
   nil))

(defmethod (file-system-shutdown-reason basic-file-system) nil)

(defmethod (shutdown-file-system basic-file-system) (&optional (reason "No reason given."))
  (ignore reason))

(defmethod (shutdown-file-system-server basic-file-system) ()
  nil)

(defmethod (enable-file-system basic-file-system) ())

(defmethod (:print-self basic-file-system) (stream print-depth slashify-p)
  print-depth					; Ignore
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "~A ~O" (type-of self) name))
      (format stream "File System ~A" name)))

;;;; 1Basic file caches

0(defvar *page-creation-lock* (make-ordered-lock "Page Creation Lock" %page-creation-lock))

(defflavor basic-file
	((lock (make-ordered-lock "File Lock" %file-lock))
	 file-id
	 file-system
	 page-size-in-words
	 (pages (make-hash-table :locking nil :ignore-gc t))
	 (remote-id nil)
	 page-pool)				;A list of lock, primary,
						;secondary, and flushed.
	()
  :abstract-flavor
  (:conc-name "FILE-")
  (:initable-instance-variables file-id file-system page-size-in-words page-pool)
  (:readable-instance-variables file-id file-system page-pool)
  (:writable-instance-variables page-size-in-words page-pool remote-id ))

;;; Caching is done at a higher level.
(defmethod (lookup-page basic-file) (page-n lock-arg)
  "Find the local copy of the specified page in the file's cache of pages.  If
   a local copy does not exist, create one and add it to the cache."
  ;;
  ;; lock-arg is incomplete at this point.  it's a stack-cons'ed list
  ;; (made in the WITH-PAGE) with it's LOCK slot set to NIL.  When we
  ;; find the page, fill in local-argument-lock with the page-lock.
  ;;
  (let ((page nil))
    ;;The page creation lock prevents someone from dequeuing during a
    ;;get-any-page and/or allocate-data-array operation.
    (with-lock (*page-creation-lock*)		; I suppose this could be made less global
      (with-page-pool (primary secondary)
	(setq page (fast-gethash page-n pages))
	(cond (page
	       (dequeue-page page primary page-size-in-words))
	      (t
	       (setq page (get-any-page self primary secondary))
	       (initialize-page page self page-n)
	       (setf (gethash page-n pages) page)))
	
	;; +++ this form used to be dented two spaces left.  somebody
	;; screw up their paren matching?
      ;; (break)
	(setf (process::lock-argument-lock lock-arg)	
	      (page-lock page))
	(ordered-lock (page-lock page) lock-arg))

      (allocate-data-array page))
    page))

;;; This function is called from the :abort clause of
;;; unwind-protect-case handlers of callers of lookup-page.  Whenever
;;; you call lookup-page, you bind some variable to the result, and
;;; around all this you set up an unwind-protect handler to abort-lock
;;; the page latch.  The argument to this function is that variable.
;;; The tricky case arises when the variable is still nil, i.e. the
;;; process is unwound before lookup-page returns.  That's when the
;;; second and third arguments are needed: they must be the same file
;;; and page-n that were passed to lookup page.
(defun recover-from-lookup-page (page file page-n &optional lock-arg)
  (cond (page
	 ;; Easy case: lookup-page returned the page.
	 (if lock-arg
	     (abort-lock (page-lock page) lock-arg)
	     (abort-lock (page-lock page))))
	(t
	 ;; Hard case: the unwind started before lookup-page returned.
	 ;; It is possible that the page-lock was seized.  If it was,
	 ;; the page must be in the file's "pages" table.
	 (let ((p (lookup-page-if-exists file page-n)))
	   (when p
	     (atomically
	       (when (holding-lock (page-lock p))
		 (if lock-arg
		     (abort-lock (page-lock p) lock-arg)
		   (abort-lock (page-lock p))))))))))

;;; Special entrypoint only for use by recover-from-lookup-page.  See
;;; the comments above.  This only returns the page if it's already in
;;; the "pages" table.  It's generally not a good idea to wait for
;;; things inside unwind-protect handlers, but in this case it seems
;;; harmless, because it's hard to see how *page-creation-lock* could be
;;; held for very long, except during debugging of another process
;;; that's holding it.  And there doesn't seem to be a good alternative.
(defmethod (lookup-page-if-exists basic-file) (page-n)
  (with-lock (*page-creation-lock*)
    (fast-gethash page-n pages)))

(defmethod (flush-cache basic-file) ()
  ;;+++ Needs locking, etc.
  (tv:maphash-noting-progress #'(lambda (ignore page)
				  (deinitialize-page page))
			      pages
			      "Flushing Statice file cache")
  (clrhash pages)
  (setq remote-id nil))

;;; This function is not just flush-cache, because there are daemons!
(defmethod (shutdown-file basic-file) ()
  (flush-cache self))

;;; This function is not just flush-cache, because there are daemons!
(defmethod (reinitialize-file basic-file) ()
  (flush-cache self))

(defmethod (fast-file-page-size basic-file) ()
  (and remote-id page-size-in-words))

(defmethod (:print-self basic-file) (stream print-depth slashify-p)
  print-depth					; Ignore
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "~A" (type-of self)))
      (format stream "File: ~A in ~A" file-id file-system)))

;;Should be called with queues locked.
;;Doesn't munge the PAGES hash table of pages.  Use get-any-page for that.
(defmethod (get-any-flushable-page basic-file) (primary secondary)
  (let ((primary-page (dequeue-element primary)))
    (cond (primary-page
	   (dequeue-from-primary *page-pool* page-size-in-words)
	   primary-page)
	  (t
	   (dequeue-element secondary)))))

;;Doesn't invalidate the page.  The caller should do that.
;;Assumes callers calls initialize-page very soon afterward.
(defmethod (get-any-page basic-file) (primary secondary)
  (let ((page-to-recycle (and (page-pool-full *page-pool*)
			      (get-any-flushable-page self primary secondary))))
    (cond (page-to-recycle
	   (recycle-page page-to-recycle))
	  (t
	   (allocate-page self)))))


(defwhopper (recycle-page basic-page) ()
  (if number
      (continue-whopper)
    self))

(defmethod (recycle-page basic-page) ()
  (recycle-page-in-file file self)
  self)

;;; ++++ Do we need the file lock to do this?
(defmethod (recycle-page-in-file basic-file) (page)
  (remhash (page-number page) pages))

(defmethod (get-page-buffer basic-file) ()
  (with-page-pool (primary secondary flushed)
    (let* ((page-to-flush (and (page-pool-full *page-pool*)
			       (get-any-flushable-page self primary secondary)))
	   (buffer (or (and page-to-flush (page-data-array page-to-flush))
		       (allocate-extra-data-array self))))
      (when page-to-flush
	(flush-page page-to-flush primary secondary flushed))
      buffer)))

;;Should be called with all the queues locked.
(defmethod (flush-page basic-page) (primary secondary flushed)
  (with-lock (lock)
    (setf data-array nil)
    (when byte-array
      (setf (si:array-indirect-pointer byte-array) nil))
    (setf (data-state) %uninitialized)
    (enqueue-page self primary secondary flushed)))

;;Should be called with all the queues locked.
(defmethod (unflush-page basic-page) (buffer primary secondary flushed)
  (setf data-array buffer)
  (when byte-array
    (setf (si:array-indirect-pointer byte-array) data-array))
  (enqueue-page self primary secondary flushed))

;;Should be called with all the queues locked.
(defmethod (return-page-buffer basic-file) (buffer primary secondary flushed)
  (let ((flushed-page (or (dequeue-element flushed)
			  (let ((new-page (allocate-page self)))
			    (setf (page-file new-page) self)
			    new-page))))
      (unflush-page flushed-page buffer primary secondary flushed)))

(defmethod (maybe-make-flushable basic-page) ()
  (with-page-pool-of-file (file primary secondary flushed)
    (let ((available nil))
      (process::with-stack-lock-argument (lock-arg lock)
	(unwind-protect ()
	  (progn 
	    (setq available (lock-no-hang lock lock-arg))
	    (when (and (or available (holding-lock lock))
		       (null transactions) (null pending) (null queue)
		       (not (permanent)))
	      (enqueue-page self primary secondary flushed)
	      (when saved-data-array-vector 
		(loop for array being the array-elements of saved-data-array-vector
		      for i from 0 do
		  (when array
		    (setf (aref saved-data-array-vector i) nil)
		    (return-page-buffer file array primary secondary flushed))))))
	  (when available (unlock lock lock-arg)))))))


(defmethod (allocate-extra-data-array basic-file) ()
  (make-array page-size-in-words :element-type 'fixnum
	      :area *dbfs-page-area*))

(defmethod (allocate-extra-data-array basic-file :after) ()
  (note-page-allocated *page-pool* page-size-in-words))


(defmethod (initialize-page basic-page) (file-cache page-n)
  (setf file file-cache
	number page-n
	(data-state) %uninitialized
	(lock-state) %unlocked
	transactions nil
	(write-state) %na
	pending nil)
  (reset-lock lock))

(defmethod (check-state basic-page) (attempt)
  (unless (= (data-state) %valid)
    (error "Trying to ~A page which is ~A." attempt (data-state))))

;;; Faster than using multiple instance variable accessors
(defmethod (page-address basic-page) ()
  (declare (values file page-number))
  (values file number))

(defmethod (page-cache-valid basic-page) (file-cache page-n lock-type transaction)
  (and (atomically (member-or-eql transaction transactions))
       (eq file file-cache)
       (= page-n number)
       ( (lock-state) lock-type)
       (= %valid (data-state))
       #+dbfs-internal-metering(incf *count-page-cache-hits*)
       data-array))

;;; The transaction is the entity which actually holds locks, not the
;;; transaction manager.  The reason for this is that a transaction will
;;; have multiple transaction managers when it is accessing files on different
;;; servers, and if the transaction manager held the locks deadlock detection
;;; would become more complex.  For example:
;;; Transaction T0 has page P0 on server S0 read locked (using T0S0),
;;; Transaction T1 has page P1 on server S1 read locked (using T1S1),
;;; Transaction T0 hangs trying to write lock page P1 (using T0S1),
;;; Transaction T1 hangs trying to write lock page P0 (using T1S0)
;;; must cause one of the transactions to abort due to a deadlock conflict.
;;; While only two transactions are involved, four transaction managers are involved.
(defun-in-flavor (lock-page-internal basic-page) (element lock-type transaction)
  "Set the state of the page to being locked by the transaction specified by the
   element  with the specified lock type.  If the lock state is not compatible with
   the lock request, hang until the request can be satisfied, aborting a transaction
   to recover from any deadlocks if they occur."
  ;; Try to set local lock.
  (unless (update-page-lock self element lock-type transaction)
    ;; Local lock did not succeed.  Update the queue of pending locks, and
    ;; perform a simple check for a two process deadlock.  If a deadlock exists,
    ;; abort the younger transaction, else wait for the pending lock to complete.
    (atomically
      (setq pending (nconc pending (ncons (cons transaction lock-type))))
      (setf (transaction-pending transaction) self))
    ;; Quick check for deadlocks.  This just checks the case of two transactions
    ;; being deadlocked, with any more complicated case being catched by a timeout.
    ;; This should work well since it avoids having to do the complicated check
    ;; in almost all cases since it is rare indeed for more than two transactions
    ;; to be involved in a deadlock (according to J.N. Gray and C.J. Date).
    (let ((deadlocked-with-tran
	    (block deadlock-detect
	      (flet ((deadlock-test (tran)
		       (let (pending-page pending-locks)
			 (when (and (neq tran transaction)
				    (setq pending-page (transaction-pending tran))
				    (setq pending-locks (page-transactions pending-page))
				    (member-or-eql transaction pending-locks))
			   (return-from deadlock-detect tran)))))
		(maplist-or-apply transactions deadlock-test)))))
      (when deadlocked-with-tran
	(let ((victim-transaction (if ( (transaction-creation-time transaction)
					 (transaction-creation-time deadlocked-with-tran))
				      transaction
				      deadlocked-with-tran)))
	  ;; Debugging trace to help find problems.  Normally off.
	  (when *enable-deadlock-trace*
	    (let ((other-transaction (if (eq transaction victim-transaction)
					 deadlocked-with-tran
					 transaction)))
	      #+ignore
	      (note-transaction-abort '2way other-transaction victim-transaction)
	      (push (format nil "~\\datime\\ 2way ~S ~S ~S ~S ~S ~S ~S ~S"
			    transaction
			    (transaction-creation-time victim-transaction)
			    (transaction-process victim-transaction)
			    (page-number (transaction-pending victim-transaction))
			    (transaction-creation-time other-transaction)
			    (transaction-process other-transaction)
			    (page-number (transaction-pending other-transaction))
			    (with-output-to-string (*standard-output*)
				     (process::describe-process-lock-for-debugger
				       (transaction-lock victim-transaction))))
		    *deadlock-trace*)))
	  (with-victim-locked-no-hang (victim-transaction transaction)
	    (when *enable-deadlock-trace*
	      (push (list "DONE" transaction victim-transaction) *deadlock-trace*))
	    (setf (transaction-inter-process-abort victim-transaction)
		  (neq transaction victim-transaction))
	    ;;Indicate an abort is in progress to avoid deadlock between client and
	    ;;background invalidation.
	    (setf (transaction-error victim-transaction)
		  'two-transaction-deadlock-restartable-transaction-abort)
	    (return-to-top-level 'deadlock victim-transaction self element lock-type))))
      ;; Release the internal latch on the page while blocked so that another
      ;; transaction can change the page's state to unlocked.  update-page-lock
      ;; will reaquire the latch.
      (return-to-top-level 'page-locked self element lock-type))))

(defmethod (lock-page basic-page) (element lock-type)
  (let* ((transaction (transaction-element-transaction element))
	 (tran-got-lock (member-or-eql transaction transactions)))
    ;; Optimize out the simple case where the transaction already has the page
    ;; locked with a stronger or equal lock.
    (or (and tran-got-lock ( (lock-state) lock-type))
	(lock-page-internal element lock-type transaction))))


;;Macro which cleanly grabs a transaction lock without waiting.  If it
;;gets the lock (or if it already has it), then the body is run.  If it
;;had grabbed the lock, and didn't own the lock before, then it is sure
;;to release the lock, even if aborts happen.

;;; If the lock state is compatible and the request is satisfied, update
;;; the state and return T.  Otherwise, simply return NIL.  This is
;;; called from scheduler context as a 'flush instruction' as well as
;;; from user level.  It must be careful not to touch element until it
;;; has verified that transaction has not been aborted by some other
;;; process, because that would deallocate element.
(defmethod (update-page-lock basic-page) (element lock-type transaction)
  "Attempt to set the state of the page to being locked by the transaction specified by the
   element with the specified lock type.  If the lock state is compatible and the
   request is satisfied, update the state and return T.  Otherwise, simply return NIL.
   This is called from scheduler context as a 'flush instruction' as well as from
   user level."
  (macrolet ((request-compatible-p (locktype lockstate)
	       ;; This predicate checks for lock compatibility between
	       ;; a request and the lock state.  Yes, it works because
	       ;; lock compatibility is regular.
	       `(< ,lockstate (- *n-lock-states* ,locktype))))
    (flet ((check-mutable ()
	     (when (= %write-lock lock-type)
	       (setf (write-state) %mutable)
	       (unless saved-data-array-vector
		 (setq saved-data-array-vector (make-array 5)))
	       (si:fill-array saved-data-array-vector nil nil))))
      (let* ((tran-got-lock (member-or-eql transaction transactions)))
	;; Make sure no other process is trying to run this check.  If the lock
	;; manager is busy and this is being called from the scheduler context, just
	;; return a NIL so that the test will be tried again later.
	(cond ((or (null transaction)
		   (transaction-error transaction))
	       ;; The transaction is no longer valid; return T.  The caller
	       ;; should check to see if the transaction is valid before
	       ;; assuming the page is locked.
	       t)
	      ((and tran-got-lock ( (lock-state) lock-type))
	       ;; This transaction already has the page locked with the same or
	       ;; equal strength lock; return T.
	       t)
	      ((and tran-got-lock (atom transactions))
	       ;; The transaction has the page locked with a weaker lock, and
	       ;; no other transactions have the page locked.  Promote the lock.
	       ;;+ This placement makes lock promotion work regardless of whether
	       ;; another transaction is already pending or not.  While this seems
	       ;; to violate complete fairness, if this was not done a deadlock would
	       ;; result.  The overhead of handling aborts isn't worth the gain of
	       ;; being completely fair, especially when you consider that this promotion
	       ;; can only occur once, so that the pending lock just will wait a bit
	       ;; longer, but a finite amount longer, and livelock cannot result.
	       (setf (lock-state) lock-type)
	       (check-mutable)
	       (atomically
		 (when (and pending (assoc transaction pending))
		   ;; Some other transaction just unlocked this page, have to
		   ;; pop this request from the pending queue.
		   (setq pending (delete transaction pending :test #'eq-car))
		   (setf (transaction-pending transaction) nil)))
	       t)
	      ((and pending (eq transaction (car (first pending))))
	       ;; This transaction is at the head of the pending queue; go ahead
	       ;; and see if the lock can be done.
	       (let ((holding-lock (holding-lock (transaction-lock transaction))))
		 (flet ((do-it ()
			  (cond ((request-compatible-p lock-type (lock-state))
				 ;; Pop the pending queue.
				 (unless (= (cdr (first pending)) lock-type)
				   (error "+++ Pending Lock type funny. 
			      Perhaps another process using tran?"))
				 (atomically
				   (setf (transaction-pending transaction) nil)
				   (pop pending)
				   ;; Set the lock.  See comment below regarding the
				   ;; conditional setq.
				   (when (> lock-type (lock-state))
				     (setf (lock-state) lock-type))
				   (push-or-setq transaction transactions)
				   (insert-page element self))
				 (check-mutable)
				 t)
				(t nil))))
		   ;; Don't attempt this unless we can get the transaction lock, otherwise
		   ;; we might insert a page into the transaction element just as
		   ;; another transaction is aborting us, despite the atomically clause.
		   (if holding-lock
		       (do-it)
		     (process::with-stack-lock-argument (lock-arg
							  (transaction-lock transaction))
		       (let ((tran-lock nil))
			 (unwind-protect
			     (progn (atomically
				      (setf tran-lock (lock-no-hang
							(transaction-lock transaction)
							lock-arg)))
				    (when tran-lock
				      (do-it)))
			   (when tran-lock (unlock (transaction-lock transaction)
						   lock-arg)))))))))
	      (pending
	       ;; The pending queue is not empty, return NIL since some other
	       ;; transaction is first in line and must succeed.
	       nil)
	      ((request-compatible-p lock-type (lock-state))
	       ;; Bump up the lock state.  The conditional here prevents a
	       ;; subsequent read locker from changing the lock-state to read locked
	       ;; if it was probable-write locked.  However, this has the
	       ;; misfeature of leaving the page probable-write locked when
	       ;; the initial locker terminates the transaction.  Erring
	       ;; this way (leaving it locked with the stronger lock) is
	       ;; more correct than letting weaker locks reset the state, and
	       ;; should be ok.  I don't think it is worth the additional
	       ;; complexity to make a "lock stack".
	       (let ((holding-lock (holding-lock (transaction-lock transaction))))
		 (flet ((do-it ()
			  (atomically
			    (when (> lock-type (lock-state))
			      (setf (lock-state) lock-type))
			    (unless tran-got-lock
			      ;; It is possible that the transaction already has the lock.
			      ;; For example, if transaction T1 and T2 have the page read
			      ;; locked, and then transaction T1 attempts to probable-write
			      ;; lock the page, the lock request is deemed compatible, this
			      ;; condition clause will be executed to promote the read lock.
			      (push-or-setq transaction transactions)
			      (insert-page element self))
			    (check-mutable))
			  t))
		   ;; Don't attempt this unless we can get the transaction lock, otherwise
		   ;; we might insert a page into the transaction element just as
		   ;; another transaction is aborting us, despite the atomically clause.
		   (if holding-lock
		       (do-it)
		     (process::with-stack-lock-argument (lock-arg
							  (transaction-lock transaction))
		       (let ((tran-lock nil))
			 (unwind-protect
			     (progn (atomically
				      (setf tran-lock (lock-no-hang
							(transaction-lock transaction)
							lock-arg)))
				    (when tran-lock
				      (do-it)))
			   (when tran-lock (unlock (transaction-lock transaction)
						   lock-arg))))))))))))))

;;; Common subroutine called by the page-locked handlers.
;;; Release and regain the transaction lock.
;;; Common subroutine called by the page-locked handlers.
;;; Release and regain the transaction lock.
(defun wait-for-page (page element lock-type transaction &optional connection)
  (loop do
    (process:without-lock ((transaction-lock transaction))
      (multiple-value-bind (got-page-lock got-page-latch)
	  (with-lock-when-no-hang ((page-lock page))
	    (update-page-lock page element lock-type transaction))
	(cond (got-page-lock t)
	      (got-page-latch
	       (process:block-with-timeout *deadlock-detector-interval* "Page Locked"
		 #'(lambda (transaction)
		     (declare (sys:downward-function))
		     (or (and connection (not (connection-valid-p connection)))
			 (multiple-value-bind (got-page-lock got-page-latch)
			     (with-lock-when-no-hang ((page-lock page))
			       (update-page-lock page element lock-type transaction))
			   (or got-page-lock
			       (not got-page-latch)
			       (transaction-error transaction)))))
		   ;;; This used to pass *process-transaction*, but that seems to
		   ;;; frequently be NIL on the server, thus causing much
		   ;;; much time to be wasted.  --Feinberg 5/5/92
		 transaction))
	      (t
	       (with-lock ((page-lock page))
		 (update-page-lock page element lock-type transaction)))))
      (when (and connection (not (connection-valid-p connection)))
	(handle-connection-killed transaction)))
    ;; Make sure the update-page-lock didn't return due to an abort.
    (check-state transaction)
    (when (page-owned-by-transaction page transaction lock-type)
      (return t))
    (deadlock-detector transaction)))


;;; Predicate: is this page locked by this transaction for this lock type?
(defmethod (page-owned-by-transaction basic-page) (transaction lock-type)
  (atomically
    (and (member-or-eql transaction transactions)
	 ( (lock-state) lock-type))))


;;Better have *global-commit-lock*
(defmethod (latch-page-no-wait basic-page) ()
  (declare (values losing-page))
  (without-interrupts
    (let ((holding-lock (holding-lock lock)))
      (if (and (process::lock-holder lock)
	       (not holding-lock))
	  ;;Someone is holding the lock, and it is not us.  Punt.
	  self
	;; We're not locked.  Get locked.
	(progn
	  (unless holding-lock
	    (setf (process::lock-argument-process commit-lock-arg) *current-process*)
	    (ordered-lock lock commit-lock-arg))
	  nil)))))

;;Better have *global-commit-lock*
(defmethod (unlatch-page basic-page) ()
  (unlock lock commit-lock-arg)
  (maybe-make-flushable self))

;;Better have *global-commit-lock*
(defmethod (carefully-unlatch-page basic-page) ()
  (when (holding-lock lock)
    (unlock lock commit-lock-arg)
    (maybe-make-flushable self)))

;;; Make sure that only one process at a time runs the deadlock detector,
;;; so that we don't have two processes finding the same loop.
(defvar *deadlock-detector-lock*
	(make-ordered-lock "Deadlock Detector Lock" %deadlock-detector-lock))

(defvar *deadlock-detector-transactions*)

;;; For metering only
(defvar *deadlock-detector-meter-entered* 0)

;;; For metering only
(defvar *deadlock-detector-meter-by-length* (make-array 30 :initial-element 0))

(defvar *abandoned-pages* 0)

(defmethod (maybe-abort-page basic-transaction) (page)
  (atomically
    (sys:without-aborts ("DBFS will be left in an inconsistent state.")
      (let ((holding-lock (holding-lock lock)))
	(when (or holding-lock (lock-no-hang lock))
	  (when (and error (zerop (hash-table-count elements)))
	    (unlock-page page self t)
	    (incf *abandoned-pages*))
	  (unless holding-lock
	    (unlock lock)))))))


;;If we can get the transaction lock on a transaction, and that
;;transaction has an error, go and finish up the aborting of that
;;transaction, at least to the point of releasing the locked pages,
;;which the deadlock detector below thinks might be holding us up.  This
;;is safe to do even if we are not in the process the transaction is
;;running in because CLOSE-TRANSACTION is careful about not signalling
;;when called from a different process.
(defmethod (maybe-abort-transaction basic-transaction) ()
  (sys:without-aborts ("DBFS will be left in an inconsistent state.")
    (let ((had-lock-but-did-not-abort
	    (with-victim-locked-no-hang (self nil)
	      (cond (error
		     (close-transaction self)
		     nil)
		    (t t)))))
      (when had-lock-but-did-not-abort
	(process:wakeup-without-test process)))))

(defun deadlock-detector (transaction)
  (with-lock (*deadlock-detector-lock*)
    (incf *deadlock-detector-meter-entered*)
    (let ((*deadlock-detector-transactions* nil))
      (labels ((maybe-at (tr)
		 (when tr
		   (maybe-abort-transaction tr)))
	       (follow-transaction (tr)
		 (let ((loop (member tr *deadlock-detector-transactions*)))
		   (when loop
		     ;; Victimize the youngest transaction.
		     (let* ((victim tr)
			    (victim-creation-time (transaction-creation-time victim))
			    (len 1))
		       (loop for v in *deadlock-detector-transactions* do
;			     until (eq v tr) do
			 (incf len)
			 (let ((v-time (transaction-creation-time v)))
			   (when (> v-time victim-creation-time)
			     (setq victim v
				   victim-creation-time v-time))))
		       (incf (aref *deadlock-detector-meter-by-length* len))
		       #+ignore
		       (note-transaction-abort 'nway transaction victim)
		       (when *enable-deadlock-trace*
			 (push
			   (format nil "~\\datime\\ nway ~S ~S ~S ~S ~S ~S ~S"
				   (transaction-creation-time victim)
				   (transaction-process victim)
				   (page-number (transaction-pending victim))
				   (transaction-creation-time transaction)
				   (transaction-process transaction)
				   (page-number (transaction-pending transaction))
				   (with-output-to-string (*standard-output*)
				     (process::describe-process-lock-for-debugger
				       (transaction-lock victim))))
			   *deadlock-trace*))
		       ;; If the victim is locked, give up and try again later.
		       (with-victim-locked-no-hang (victim *process-transaction*)
			 (when *enable-deadlock-trace*
			   (push (list "DONE" (transaction-creation-time transaction)
				       (transaction-creation-time victim)) *deadlock-trace*))
			 (setf (transaction-inter-process-abort victim)
			       (neq victim *process-transaction*))
			 (close-transaction
			   victim
			   :abort-error
			   (make-condition
			     'n-transaction-deadlock-restartable-transaction-abort
			     :n len)))
		       (return-from deadlock-detector t))))
		 (when tr
		   (with-stack-list* (*deadlock-detector-transactions*
				       tr *deadlock-detector-transactions*)
		     (let ((pa (transaction-pending tr)))
		       (when pa
			 (let ((trs (page-transactions pa)))
			   ;;+Probably not necessary.
			   (when (and trs (eq tr *process-transaction*))
			     (maplist-or-apply trs maybe-at))
			   (when trs
			     (cond ((atom trs)
				    (unless (and (eq trs tr)
						 (< (page-lock-state pa)
						      %write-lock))
				      (follow-transaction trs)))
				   (t
				    (loop for transaction-to-follow in trs do
				      (unless (and (eq transaction-to-follow tr)
						   (< (page-lock-state pa)
						      %write-lock))
					(follow-transaction transaction-to-follow)))))))))))))
	(follow-transaction transaction))))
  nil)

(defun reset-deadlock-meters ()
  (setq *deadlock-detector-meter-entered* 0)
  (fill *deadlock-detector-meter-by-length* 0))

(defun show-deadlock-meters ()
  (format t "~%The N-way deadlock detector was entered ~D times."
	  *deadlock-detector-meter-entered*)
  (let ((total 0))
    (dotimes (i (length *deadlock-detector-meter-by-length*))
      (let ((n (aref *deadlock-detector-meter-by-length* i)))
	(when (plusp n)
	  (format t "~%Deadlock loops of length ~D: ~D" i n))
	(incf total n)))
    (if (zerop total)
	(format t "~%No N-way deadlocks seen.")
	(format t "~%~D N-way deadlocks total." total))))

;;; This is called with the page latched.
(defmethod (set-page-modified basic-page) (transaction-element)
  (when ( %modified (write-state))
    (setf (write-state) %modified)
    (setf (transaction-element-modified-page-p transaction-element) t)))

;;; This is called with the page unlatched.  Even though the higher
;;; level lock is held, have to still latch the page since we need to
;;; synchronize against transactions doing changing the state of a page
;;; which is share locked.
(defmethod (unlock-page basic-page) (transaction abort-p)
  (unlock-page-1 self transaction abort-p))


;;; The caller guarrantees the page is already latched
(defmethod (unlock-page-1 basic-page) (transaction abort-p)
  (ignore abort-p)
  (delete-or-setq transaction transactions)
  (unless transactions
    ;; The page is no longer locked.  Add it to the flushable queue
    ;; and clear its lock state
    (setf (lock-state) %unlocked
	  (write-state) %na))
  (maplist-or-apply pending maybe-wakeup-transaction))

;;; This is called with the page unlatched.  Have to acquire the latch first
;;; to synchronize with the above code.
(defmethod (abort-pending basic-page) (transaction)
  (setq pending (delete transaction pending :test #'eq-car)))


;;; This is called with the page latched because the page is currently
;;; being invalidated.  See close-transaction.
(defmethod (abort-pending-no-lock basic-page) (transaction)
  (setq pending (delete transaction pending :test #'eq-car)))

;;;+++ This doesn't latch the page like it should really.
(defmethod (deinitialize-page basic-page) ()
  (when (or transactions pending)
    (let ((err 'cache-flush-restartable-transaction-abort))
      (loop for (tran) in pending do
	(with-nonordered-lock ((transaction-lock tran))
	  (close-transaction tran :signal-abort nil :abort-error err)))
      (cond ((listp transactions)
	     (loop for tran in transactions do
	       (with-nonordered-lock ((transaction-lock tran))
		 (close-transaction tran :signal-abort nil :abort-error err))))
	    (t
	     (with-nonordered-lock ((transaction-lock transactions))
	       (close-transaction transactions :signal-abort nil :abort-error err)))))))

;;; This is called with the page latched, but outside of a transaction (from
;;; the asynch server) so it can directly call close-transaction.
(defmethod (invalidate-page basic-page) ()
  (let ((err 'page-invalid-restartable-transaction-abort)
	(transactions-p (not (null transactions))))
    ;;Make a copy of the pending list, and the transaction list
    ;;before you release the page lock.
    (sys:with-stack-array (pending-to-punt (length pending) :initial-contents pending)
      (sys:with-stack-array (transactions-to-punt (if (atom transactions) 1
						    (length transactions)))
	(if (atom transactions)
	    (setf (aref transactions-to-punt 0) transactions)
	  (loop for trans in transactions
		for i from 0 do
	    (setf (aref transactions-to-punt i) trans)))
	(setf (data-state) %invalid)
	;;Release the page lock now to prevent deadlocks against the page pool queue
	;;lock and the transaction lock.
	(process:without-lock (lock)
	  (loop for (tran) being the array-elements of pending-to-punt do
	    (with-nonordered-lock ((transaction-lock tran))
	      (when (and (member tran pending :key #'car)
			 (null (transaction-error tran)))
		(close-transaction tran :signal-abort nil :abort-error err))))
	  (when transactions-p
	    (loop for tran being the array-elements of transactions-to-punt do
	      (with-nonordered-lock ((transaction-lock tran))
		;;Don't asyncronously abort if an error is already being processed for
		;;this transaction.
		(when (and (member-or-eql tran transactions)
			   (null (transaction-error tran)))
		  (close-transaction tran :signal-abort nil :abort-error err))))))))))


;; Caller (lookup-page) requires a specific page, and wants to mark the
;; page as unflushable for the duration of the current transaction.
;; Should caller have page locked?
;; Caller has pool locked.
(defmethod (dequeue-page basic-page) (primary page-size-in-words)
  (let ((q queue))
    (when (and (dequeue-element self)
	       (eq q primary))
      (dequeue-from-primary *page-pool* page-size-in-words))))


;; Caller knows that the page is not currently in use, and should be made
;; a candidate for flushing.  Precisely which queue the page ends up on will
;; Caller should have page locked.
;; Caller has pool locked.
(defmethod (enqueue-page basic-page) (primary secondary flushed)
  (if data-array
      (cond ((enqueue-in-primary *page-pool* (file-page-size-in-words file))
	     (enqueue-element primary self))
	    (t
	     (enqueue-element secondary self)))
      (enqueue-element flushed self)))

(defmethod (allocate-extra-data-array basic-page :after) ()
  (note-page-allocated *page-pool* (file-page-size-in-words file)))

;;; Save the state of the data into an extra data array.  This is called
;;; when we are entering a recursive transaction, before depth is
;;; incremented.  Note that element 0 of the vector is never used.
(defmethod (save-data-array basic-page) (depth)
  (when (and (sys:bit-member (write-state)
			     (logior (rot 1 %modified) (rot 1 %written)))
	     (= %valid (data-state)))
    (when ( depth (zl:array-length saved-data-array-vector))
      (setq saved-data-array-vector (adjust-array saved-data-array-vector (+ depth 5))))
    (let ((array (aref saved-data-array-vector depth)))
      (unless array
	(setq array (get-page-buffer file))
	(setf (aref saved-data-array-vector depth) array))
      (fast-copy-fixnum-array data-array nil array nil (zl:array-length array)))))

;;; Restore the state of the data from the extra data array into the
;;; real data array.  This is called when we are aborting a recursive
;;; transaction, after the depth is decremented.
(defmethod (restore-data-array basic-page) (depth)
  (when (and (sys:bit-member (write-state)
			     (logior (rot 1 %modified) (rot 1 %written)))
	     (= %valid (data-state)))
    (let ((array (aref saved-data-array-vector depth)))
      (cond (array
	     (fast-copy-fixnum-array array nil data-array nil (zl:array-length array)))
	    (t
	     ;; The page must have become modified during the recursive
	     ;; transaction.  It must have been unmodified before that.
	     ;; So make it invalid; it'll be brought back in from the
	     ;; disk.
	     (setf (data-state) %invalid))))))

(defmethod (allocate-read-only-array basic-page) ()
  (si:with-read-only-inhibited
    (allocate-resource 'read-only-array (file-page-size-in-words file))))

(defmethod (deallocate-read-only-array basic-page) (array)
  (deallocate-resource 'read-only-array array))

(defmethod (:print-self basic-page) (stream print-depth slashify-p)
  print-depth					; Ignore
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "~A" (type-of self)))
      (format stream "Page ~D of ~A" number file)))

(defmethod (show-status basic-page) (&key (stream *standard-output*))
  (format stream "~&~A: state ~A~:[~;, ~:*~A~]"
	  self
	  (nth (data-state) *page-data-states*)
	  (nth (write-state) *page-write-states*))
  (when ( (lock-state) %unlocked)
    (format stream "~%  ~A by" (nth (lock-state) *lock-states*))
    (flet ((print-tran (tran)
	     (format stream " ~A" tran)))
      (maplist-or-apply transactions print-tran)))
  (when pending
    (format stream "~%  Locks pending: ~S" pending)))

;;;; 1Network block accessor functions

0;;; These primitives define the field accessors for DEFNETBLOCK.
;;; Note that the SETF forms don't return meaningful values.

;;(defmacro aref-unsigned-integer (array offset n-bytes)
;;  `(neti:put-together-bytes :little ,array ,offset ,n-bytes))

;; these functions assume that they are dealing with byte-wide arrays
;; also, a 4-byte unsigned-integer can't be 32 bits long

;(remprop 'aref-unsigned-integer 'inline)
(defun aref-unsigned-integer (array offset n-bytes)
  (declare lt:(side-effects reader reducible))
  (let ((value 0))
    (loop for i downfrom (+ offset n-bytes -1) to offset
	  do (setq value (dpb (aref array i) (byte 8. 0) (ash value 8.))))
    value))

(compiler:defoptimizer (aref-unsigned-integer aref-unsigned-integer-expander) (form)
  (block optimizer
    (compiler:matchp (rest form)
      ((array offset n-bytes)
       (when (constantp n-bytes compiler:*optimizer-environment*)
	 (let ((n-bytes (lt:evaluate-constant n-bytes compiler:*optimizer-environment*)))
	   (when (typep n-bytes '(integer 1 4))
	     (labels ((build-dpb (n-bytes)
			(if (= n-bytes 1)
			    `(aref array offset)
			    `(sys:%logdpb (aref array (+ offset ,(1- n-bytes)))
					  (byte 8 ,(* (1- n-bytes) 8))
					  ,(build-dpb (1- n-bytes))))))
	       (return-from optimizer
		 (lt:let-subst '(array offset) `(,array ,offset)
			       (build-dpb n-bytes)
			       compiler:*optimizer-environment*))))))))
    form))

#|
(defmacro aset-unsigned-integer (array offset n-bytes value)
  `(progn
     ;;++ Can remove this check for speed later if desired.  But this is valuable
     ;; at least for now.
     (when ( ,value (expt 2 (* 8. ,n-bytes)))
       (error "~D is too large of a value to store into a ~D byte wide field."
	      ,value ,n-bytes))
     (neti:fill-in-bytes :little ,array ,offset ,value ,n-bytes nil)))
|#

;(remprop 'aset-unsigned-integer 'inline)
(defun aset-unsigned-integer (array offset n-bytes value)
  ;;++ Can remove this check for speed later if desired.  But this is valuable
  ;; at least for now.
  (compiler:%error-unless ( value (case n-bytes
				     (1 (1- (expt 2 8)))
				     (2 (1- (expt 2 16)))
				     (3 (1- (expt 2 24)))
				     (4 (1- (expt 2 31)))
				     (otherwise
				       (1- (expt 2 (* 8 n-bytes))))))
    (error "~D is too large to store into a ~D byte wide field." value n-bytes))
  (loop repeat n-bytes
	for i upfrom offset
	do (setf (aref array i) (ldb (byte 8. 0) value))
	   (setq value (ash value -8.))))

(compiler:defoptimizer (aset-unsigned-integer aset-unsigned-integer-expander) (form)
  ;; note that the function and optimizer differ only with treatment of the fixnum sign bit
  ;; but the optimizers for aref and aset agree
  (block optimizer
    (compiler:matchp (rest form)
      ((array offset n-bytes value)
       (when (constantp n-bytes compiler:*optimizer-environment*)
	 (let ((n-bytes (lt:evaluate-constant n-bytes compiler:*optimizer-environment*)))
	   (when (typep n-bytes '(integer 1 4))
	     (return-from optimizer
	       (lt:let-subst '(array offset value) `(,array ,offset ,value)
			     `(progn (compiler:%error-unless
				       ( value ,(case n-bytes
						   (4 (1- (expt 2 31)))
						   (otherwise (1- (expt 2 (* 8 n-bytes))))))
				       (error "~D is too large to store into a ~D byte wide field."
					      value ,n-bytes))
				     ,@(loop for i below n-bytes
					     collect `(setf (aref array (+ offset ,i))
							    (ldb (byte 8 ,(* 8 i)) value))))
			     compiler:*optimizer-environment*)))))))
    form))

(defsetf aref-unsigned-integer aset-unsigned-integer)

(defsubst aref-boolean (array offset)
  ( %false (aref array offset)))

(defsubst aset-boolean (array offset value)
  (setf (aref array offset) (if value %true %false)))

(defsetf aref-boolean aset-boolean)

;;++ Perhaps this could take an optional string-array to store the value into.
;; However, strings are only used for file-system-name when opening a file for
;; the first time, so it just isn't worth worrying about it now.

(defun aref-string (array offset)
  (let* ((n-bytes (aref array offset))
	 (string (make-string n-bytes)))
    (loop repeat n-bytes
	  for ai upfrom (1+ offset)
	  for si upfrom 0
	  doing (setf (aref string si) (code-char (aref array ai))))
    string))

;;+ This doesn't really need a limit check since the array bounds will be exceeded
;; if the string is too big.  This would have to be fixed if multiple strings
;; are ever permitted.
(defun aset-string (array offset value)
  (let ((n-bytes (string-length value)))
    (setf (aref array offset) n-bytes)		; Must be  255.
    (loop repeat n-bytes
	  for si upfrom 0
	  for ai upfrom (1+ offset)
	  doing (setf (aref array ai) (char-code (aref value si))))))

(defsetf aref-string aset-string)

;;;; 1Network connections

0(defun unexpected-reply (net-block)
  (error "Unexpected reply ~D (~A)"
	 (net-block-command net-block)
	 (nth (net-block-command net-block) *dbfs-commands*)))

(defresource net-block ()
  :constructor (make-array (+ *maximum-net-block-fixed-size*
			      *maximum-net-block-string-size*)
			   :element-type '(unsigned-byte 8)
			   :fill-pointer 0))

(defflavor dbfs-connection
	((byte-stream nil)
	 (lock (make-ordered-lock "DBFS Connection Lock" %dbfs-connection-lock))
	 (sequence-number 0)
	 (state 'closed)			; Only output automatically opens closed conn.
	 (being-zapped nil)
	 (server-id)
	 (marks-received 0)
	 (marks-sent 0))
	()
  :abstract-flavor
  (:readable-instance-variables byte-stream server-id marks-received marks-sent)
  (:writable-instance-variables server-id marks-received marks-sent))


;;; The internal transmitter of net blocks
(defmethod (send-net-blocks dbfs-connection) (force-p net-block more-net-blocks)
  (when (neq 'open state)
    (open-connection self))
  (let ((n-bytes (fill-pointer net-block)))
    (setf (net-block-n-bytes net-block) n-bytes
	  (net-block-n-bytes-copy net-block) n-bytes)
    ;;+++ Checksum?
    (send byte-stream :string-out net-block)
    (when more-net-blocks
      (loop for block in more-net-blocks
	    doing (send byte-stream :string-out block)))
    (when force-p
      (force-output byte-stream))))

;;; The internal receiver of net blocks
(defmethod (read-net-block dbfs-connection) (net-block)
  ;; Read in the bytes counts
  (send byte-stream :string-in nil net-block 0 %net-block-fixed-size)
  ;; Compare the byte count and its copy to gain confidence that the count is ok
  (let ((n-bytes (net-block-n-bytes net-block)))
    (unless (= n-bytes (net-block-n-bytes-copy net-block))
      (incf *count-network-protocol-sync-errors*)
      ;;+++ Maybe make better recovery (and error message) later when converted to UDP
      (error "Network connection out of synch or transmission error."))
    ;; Read in the rest of the net block
    (send byte-stream :string-in nil net-block %net-block-fixed-size n-bytes)))

;;++ this should be replaced with something better to read a page.
(defmethod (:string-in dbfs-connection) (&rest args)
  (lexpr-send byte-stream :string-in args))

(defmethod (connection-valid-p dbfs-connection) ()
  (send byte-stream :connected-p))

(defmethod (close-connection dbfs-connection) (&optional abort)
  (close byte-stream :abort abort)
  (setq state 'closed))

(defmethod (zap-connection dbfs-connection) ()
  (setq being-zapped t)
  (when byte-stream
    ;; The ignore-errors is just paranoia, as I don't have any
    ;; particular reason to expect errors here.  However, if there were
    ;; an error, we'd probably be better off if we ignored it than if we
    ;; let it cause further trouble.
    (ignore-errors
      (close byte-stream :abort t)
      #|| (send byte-stream :zap-connection) ||#)))

(defflavor dbfs-output-connection-mixin (host) (dbfs-connection)
  :abstract-flavor
  (:documentation "The DBFS-PAGE connection running on the client.  Establishes the conn."))

(defmethod (send-net-command dbfs-output-connection-mixin)
	   (element force-p net-block &rest more-net-blocks)
  (when (neq 'open state)
    (condition-case (open-err)
	 (open-connection self)
       (sys:network-error
	 (throw 'network-error (make-condition 'network-hard-error-transaction-abort
					       :network-error open-err)))))
  (condition-case (err)
       (progn
	 (when (and element
		    *optimistic-locking*
		    (send byte-stream :listen))
	   ;; Empty out all replies which haven't been read yet since there is
	   ;; probably a transaction abort in there.
	   (using-resource (reply-net-block net-block)
	     (loop doing (with-lock (lock)
			   ;;+++++ should make sure there is still input!  should be ok tho.
			   (read-net-block self reply-net-block))
			 (process-net-block element reply-net-block t)
		   while (send byte-stream :listen))))
	 (with-lock (lock)
	   (setf (net-block-sequence-number net-block) (incf sequence-number))
	   (send-net-blocks self force-p net-block more-net-blocks))
	 sequence-number)
     (sys:network-error
       (handle-network-error self err))))

(defsubst send-net-command-and-read-reply
	  (dbfs-output-connection element net-block
				  &optional handling-commands signal-network-errors)
  (let ((sequence-number (send-net-command dbfs-output-connection element t net-block)))
    (read-net-reply dbfs-output-connection element net-block sequence-number
		    handling-commands signal-network-errors)))

(defsubst send-simple-net-command (dbfs-output-connection element net-block cmd)
  (setf (net-block-command net-block) cmd
	(fill-pointer net-block) %net-header-fixed-size)
  (send-net-command dbfs-output-connection element t net-block))

;;; If signal-network-errors is false, errors of the form
;;; sys:network-error are handled internally; if it is true, errors are
;;; actually signalled and the caller handles them.
(defmethod (read-net-reply dbfs-output-connection-mixin)
	   (element net-block seq-no &optional handling-commands signal-network-errors)
  (condition-case-if (not signal-network-errors) (err)
       (progn
	 (with-lock (lock)
	   (loop doing (read-net-block self net-block)
		 until (or (not seq-no) (= seq-no (net-block-sequence-number net-block)))
		 do
	     (if element
		 (process-net-block element net-block t)
		 (error "Can't process asynch net reply without a transaction element."))))
	 (when (and element
		    (not (and handling-commands
			      (member (net-block-command net-block) handling-commands))))
	   (process-net-block element net-block nil)))
     (sys:network-error
       (handle-network-error self err))))

;;; If the connection is open, discard all pending input and output, and
;;; exchange a "mark" with the server.  This tells the server to abort
;;; and discard its server-transaction, if any, and restart the server
;;; command loop afresh.  This gets used if the client transaction is
;;; aborted in a synchronous fashion, i.e. async-p is nil.
(defmethod (synch-connection dbfs-output-connection-mixin) ()
  (when (eq 'open state)
    (condition-case (err)
	 (progn
	   (when (and *debug-mark* (typep byte-stream 'chaos:basic-stream))
	     (push (list (time:get-universal-time)
			 "Client is about to :send-mark"
			 host
			 sequence-number)
		   *mark-trace*))
	   (with-lock (lock)
	     (send byte-stream :clear-output)
	     (send byte-stream :clear-input)
	     (send byte-stream :send-mark)
	     (incf marks-sent)
	     (when (and *debug-mark* (typep byte-stream 'chaos:basic-stream))
	       (push (list (time:get-universal-time)
			   "Client sent mark, awaits a mark")
		     *mark-trace*))
	     ;;If server doesn't respond reasonably quickly, we must
	     ;;assume that some optimistic command has the server
	     ;;wedged.  We are holding the deadlock detector lock at
	     ;;this point, and we are holding things up if we just wait
	     ;;for the server.
	     (net:with-stream-timeout (byte-stream :input *mark-turnaround-timeout*)
	       (loop doing (send byte-stream :tyi)))))
       (neti:protocol-timeout (close-connection self t))
       (neti:mark-seen (incf marks-received))
       (sys:network-error))))


(defmethod (:force-output dbfs-output-connection-mixin) ()
  (send byte-stream :force-output))

(defmethod (handle-network-error dbfs-output-connection-mixin) (error)
  (when being-zapped
    (throw 'network-error (make-condition 'system-shutdown-transaction-abort)))
  (let ((error-type (type-of error)))
    (atomically
      (incf *count-network-errors*)
      (setf (gethash error-type *network-error-table*)
	    (1+ (or (fast-gethash error-type *network-error-table*) 0)))))
  (condition-case (open-err)
       (progn
	 (close-connection self t)
	 (open-connection self))
     (sys:network-error
       (throw 'network-error (make-condition 'network-hard-error-transaction-abort
					     :network-error open-err))))
  (throw 'network-error 'network-error-restartable-transaction-abort))

(defflavor dbfs-server-connection () (dbfs-connection)
  (:constructor make-dbfs-server-connection (byte-stream))
  (:documentation "The DBFS-PAGE connection invoked on the server."))

(defmethod (make-instance dbfs-server-connection) (&rest ignore)
  ;; The opened byte-stream is passed in upon initialization.
  (setq state 'open))

(defmethod (send-net-reply dbfs-server-connection) (force-p net-block &rest more-net-blocks)
  (with-lock (lock)
    (send-net-blocks self force-p net-block more-net-blocks)))

(defmethod (read-net-command dbfs-server-connection) (net-block)
  (with-lock (lock)
    (read-net-block self net-block)))

(defmethod (wait-for-synch-connection dbfs-server-connection) ()
  (send byte-stream :clear-input)
  ;; Just eat everything until a mark is received, which will cause a mark-seen
  ;; condition to be signalled.
  (when (and *debug-mark* (typep byte-stream 'chaos:basic-stream))
    (push (list (time:get-universal-time)
		"Server is about to wait for a mark"
		(send byte-stream :foreign-host)
		sequence-number)
	  *mark-trace*))
  (loop doing (send byte-stream :tyi)))

;;; A "mark" has been received from the client.  Discard all of our
;;; pending input and output, and send back a "mark" in confirmation.
;;; This method is called from the server-top-level when the user sends
;;; a mark, indicating a transaction abort.
(defmethod (synch-connection-response dbfs-server-connection) ()
  (send byte-stream :clear-output)
  (send byte-stream :clear-input)
  (when (and *debug-mark* (typep byte-stream 'chaos:basic-stream))
    (push (list (time:get-universal-time)
		"Server is about to :send-mark"
		(send byte-stream :foreign-host)
		sequence-number)
	  *mark-trace*))
  (send byte-stream :send-mark)
  (incf marks-sent))

(defsubst send-simple-net-reply (dbfs-server-connection net-block cmd)
  (setf (net-block-command net-block) cmd
	(fill-pointer net-block) %net-header-fixed-size)
  (send-net-reply dbfs-server-connection t net-block))

(defmethod (:force-output dbfs-server-connection) ()
  (send byte-stream :force-output))

(net:define-protocol :dbfs-page (:dbfs-page :byte-stream-with-mark)
  (:invoke (service-access-path)
    (net:get-connection-for-service service-access-path :characters nil)))

(chaos:add-contact-name-for-protocol :dbfs-page)

;;++ no registry for TCP ports?
(defconstant %dbfs-page-tcp-port 569. "The tcp port number for the DBFS-PAGE protocol.")

(tcp:add-tcp-port-for-protocol :dbfs-page %dbfs-page-tcp-port)

(defflavor dbfs-client-connection (remote-server)
	   (dbfs-output-connection-mixin dbfs-connection)
  (:constructor make-dbfs-client-connection (remote-server)))

(defmethod (open-connection dbfs-client-connection) ()
  (let ((tcp:*tcp-connect-timeout* *dbfs-connect-timeout*)) ;Wait five minutes
    (setq byte-stream (net:invoke-service-on-host :dbfs-page host)
	  state 'open))
  (validate-open-connection remote-server self))

(defmethod (make-instance dbfs-client-connection) (&rest ignore)
  (setq host (remote-server-host remote-server))
  (condition-case (open-err)
       (open-connection self)
     (sys:network-error
       (throw 'network-error (make-condition 'network-hard-error-transaction-abort
					     :network-error open-err)))))

(net:define-protocol :asynch-dbfs-page (:asynch-dbfs-page :byte-stream-with-mark)
  (:invoke (service-access-path)
    (net:get-connection-for-service service-access-path :characters nil)))

1(defconstant %asynch-dbfs-page-tcp-port 568.
  "0The tcp port number for the ASYNCH-DBFS-PAGE protocol.1")

(chaos:add-contact-name-for-protocol :asynch-dbfs-page)

(tcp:add-tcp-port-for-protocol :asynch-dbfs-page %asynch-dbfs-page-tcp-port)

0(defflavor dbfs-asynch-connection () (dbfs-output-connection-mixin dbfs-connection)
  (:constructor make-dbfs-asynch-connection (host)))

(defmethod (open-connection dbfs-asynch-connection) ()
  (setq byte-stream (net:invoke-service-on-host :asynch-dbfs-page host)
	state 'open))

(defmethod (make-instance dbfs-asynch-connection) (&rest ignore)
  (open-connection self))

(defmethod (:force-output dbfs-asynch-connection) ()
  (send byte-stream :force-output))

(compile-flavor-methods dbfs-client-connection dbfs-server-connection dbfs-asynch-connection)
