;;; -*- Mode: Lisp; Syntax: Common-lisp; Package: (DBFS SCL); Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; A little explanation of conventions used in this file to make searching easier:
;;;+++ Three plus signs means something which needs to be fixed and is considered a bug.
;;;++  Two plus signs indicates a misfeature or something which should be fixed sometime.
;;;+   One plus sign indicates something to think about in the future.

(defsubst lookup-client-transaction ()
  *process-transaction*)

(defsubst lookup-client-transaction-or-error (attempt)
  (or (lookup-client-transaction)
      (error 'no-transaction :attempt attempt)))

(defvar *transaction-creation-lock* (make-ordered-lock "Transaction Creation Lock"
						       %transaction-creation-lock))

;;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Portals

0(defun make-new-file-id ()
  (multiple-value-bind (id0 id1 id2) (uid:unique-id)
    (lookup-file-id id0 id1 id2)))

(defflavor basic-portal
	((file-id nil)
	 file-system-name
	 (timestamp nil)
	 (file nil))
	()
  :abstract-flavor
  (:conc-name "PORTAL-")
  (:readable-instance-variables file-id file-system-name)
  (:initable-instance-variables file-id file-system-name)
  (:required-init-keywords :file-system-name))

;;; Normally the body exits the loop with the values returned by the
;;; body.  But if return-to-top-level is called,
;;; handle-throw-to-top-level is invoked.  If a network error occurs,
;;; then the transaction is closed.
(defmacro portal-top-level ((attempt &key (error-p t) (file-p t)) &body body)
  `(let ((*inside-dbfs* t))
     (loop named portal-top-level doing
       (unless transaction
	 (setq transaction (lookup-client-transaction-or-error ,attempt)))
       ;;
       ;; this used to be with-lock-abort, which causes the lock to be
       ;; unlocked "as many times as necessary" at exit time.  Charlie
       ;; points out that that's a stupid idea, as it completely loses
       ;; in the case of nested calls to this on the same transaction.
       ;; It shouldn't be necesary anyhow.  
       ;; 
       ;; changed to with-nonordered-lock (which boils down to
       ;; process::with-lock) 9/11/90   -- jrd
       ;;
       (with-nonordered-lock ((transaction-lock transaction))	; with-lock-abort
	 (check-state transaction ,attempt)
	 (progn					; To make the compiler optimize this
	   ,(when file-p
	      `(check-file ,attempt ,error-p)))
	 (block network-error
	   (let ((abort-error
		   (catch 'network-error
		     (return-from network-error
		       (catch-with-handler (top-level-tag handle-throw-to-top-level self)
			 (return-from portal-top-level (progn ,@body)))))))
	     (close-transaction transaction :abort-error abort-error))))))) (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");eval-when

0(defmacro handler-top-level (&body body)
  `(loop named handler-top-level doing
     (check-state *process-transaction*)
     (block network-error
       (let ((abort-error
	       (catch 'network-error
		 (return-from network-error
		   (catch-with-handler (top-level-tag handle-throw-to-top-level self)
		     (return-from handler-top-level (progn ,@body)))))))
	 (close-transaction *process-transaction* :abort-error abort-error)))))

(defmethod (handle-throw-to-top-level basic-portal) (&rest catch-vals)
  ;; The handlers are partially ordered according to frequency of use
  (catch-handler-case catch-vals
    ;; remote only
    (page-locked-remotely (file-id page-n element)
      (incf *count-lock-waits*)
      (dbfs-internal-trace 'remote-lock-wait
			   (transaction-element-transaction element)
			   (process-name *current-process*)
			   file-id page-n)

      (if *use-noting-progress-for-page-locked-remotely*
	  (tv:noting-progress ("Waiting for remote page to be unlocked")
	    (page-locked-remotely-handler element file-id page-n))
	  (page-locked-remotely-handler element file-id page-n)))
    ;; remote only
    (cache-invalid (file-id page-n element invalid-array)
      (cache-invalid-handler element file-id page-n invalid-array))
    ;; remote only
    (remote-deadlock (transaction)
      (close-transaction
	transaction
	:abort-error 'two-transaction-deadlock-restartable-transaction-abort))
    (page-locked (page element lock-type)
      (incf *count-lock-waits*)
      (dbfs-internal-trace 'local-lock-wait
			   (transaction-element-transaction element)
			   (process-name *current-process*)
			   (file-file-id (page-file page))
			   (page-number page))
      (handler-top-level
	(page-locked-handler element page lock-type)))
    (deadlock (transaction page element lock-type)
      (close-transaction
	transaction
	:abort-error 'two-transaction-deadlock-restartable-transaction-abort)
      (incf *count-lock-waits*)
      (handler-top-level
	(page-locked-handler element page lock-type)))
    ;; remote only
    (nonextant-file (remote-id element)
      (nonextant-file-handler element remote-id))
    ;; remote-only
    (server-booted (server word1 word2 word3)
      (process:without-lock ((transaction-lock *process-transaction*))
	(invalidate-server server word1 word2 word3))
      (close-transaction *process-transaction*
			 :abort-error 'server-restart-restartable-transaction-abort))))

(defgeneric lookup-element (portal transaction &optional create-p (error-p t))
  "Lookup the transaction-element for the2 portal0 and 2transaction0, opening
   the file if it isn't already open.  This is a bit complex to make it interact
   with other dependent flavors - if opening the file doesn't work because the file
   is nonextant, then the 1nonextant-file0 method is called on the portal, which either errors,
   or else tries to map the portal into a different file-id to try.
   If 2create-p0 is true, the file is created.
   If 2error-p0 is true (the default), an error is signalled if the file is nonextant.
   Otherwise, 1nil0 is returned for nonextant files."
  (declare (values element-or-nil))
  (:method (basic-portal)
   (loop as element = (lookup-file-element transaction file)
	 until (or (file-remote-id file)
		   (open-dbfs-file element file create-p))
	 ;; The cached file object doesn't exist.  First, make sure the cache
	 ;; is correct, and if it is call nonextant-file to either error or
	 ;; perhaps find a new file-id to try.
	 do (when (eq file-id (file-file-id file))
	      (setq file-id (nonextant-file self error-p)))
	    (unless file-id
	      (setq file nil)
	      (return nil))
	    (setq file (lookup-file file-id file-system-name))
	 finally (return element))))

(defun-in-flavor (check-file-internal basic-portal) (attempt error-p)
  ;; If the file-id is not valid, call the handler.  If there is a higher level
  ;; directory, it will handle this method and map the higher level name to
  ;; a file-id.
  (unless (and file-id file-system-name)
    (setq file-id (invalid-file-id self attempt error-p)))
  (when file-id
    ;; Load the cache mapping of the portal to the file object.
    (setq file (lookup-file file-id file-system-name)
	  timestamp *initialization-timestamp*)))

(defsubst-in-flavor (check-file basic-portal) (attempt &optional (error-p t))
  "Ensure that the portal has a valid file-id, calling 1invalid-file-id0 if not.
   Cache the mapping between the portal and the file object in the portal."
  (compiler:%error-unless (and file (eql timestamp *initialization-timestamp*))
    (check-file-internal attempt error-p)))

(defgeneric invalid-file-id (portal attempt &optional (error-p t))
  "Called when a portal with an invalid file-id is used.
   The default handler just signals an error.  More sophisticated flavors using
   another level of naming should map the name into a file-id."
  (declare (values file-id))			; For methods which don't error.
  (:method (basic-portal)
   (when error-p
     (error 'file-id-invalid :attempt attempt :portal self))))

(defwhopper (invalid-file-id basic-portal) (&rest args)
  (let ((*inside-dbfs* nil)))
  (cond (*process-transaction*
	 (prog1
	   (process:without-lock ((transaction-lock *process-transaction*))
	     (lexpr-continue-whopper args))
	   (check-state *process-transaction*)))
	(t
	 ;; This can happen via terminate-database -> file-unique-id
	 ;; -> check-file.
	 (lexpr-continue-whopper args))))

(defgeneric nonextant-file (portal &optional (error-p t))
  "Called when a portal with a file-id to a nonextant file is used.
   The default handler just signals an error.  More sophisticated flavors using
   another level of naming should remap the name into a file-id to see if a new
   file-id is obtained, signalling an error if not, otherwise returning the
   new file-id."
  (declare (values file-id-or-nil))		; For methods which don't error
  (:method (basic-portal)
   (when error-p
     (error 'nonextant-file :portal self))))

(defwhopper (nonextant-file basic-portal) (&rest args)
  (let ((*inside-dbfs* nil))
    (prog1
      (process:without-lock ((transaction-lock *process-transaction*))
	(lexpr-continue-whopper args))
      (check-state *process-transaction*))))

;; This doesn't need a transaction since it doesn't actually open the file.
;; The reason for the create-id-p argument is simply to permit the caller to
;; indicate whether the file is being created, in case there is some higher
;; level action to be taken (such as to create a directory entry from a named
;; portal) if the higher level file doesn't exist.
(defgeneric file-unique-id (portal)
  "Return a unique identifier for the file for use in 1eq0 comparisons."
  (declare (values file-id))
  (:method (basic-portal)
   (check-file "FILE-UNIQUE-ID")
   file-id))

;; This does not call check-file since it is creating the file to begin with.
;; But this means that any portals built out of this which use the file-id as
;; a cache must have a :before method which initializes the file-id and the
;; file-system-name to valid values.
(defgeneric create-file (portal &key (if-exists :supersede) transaction)
  ":IF-EXISTS can be one of:
   :SUPERSEDE (or :CREATE) - Any extant file pointed to by this portal will be
      destroyed, a new file-id assigned, and a new file created.
   :OVERWRITE - If the portal already has a file-id assigned, the same file-id is
      used for creating the new file.  If a file already exists, it is simply reused.
   :ERROR - An error is signalled if the portal already points to an extant file.
   NIL - Simply return NIL if the portal already points to an extant file, otherwise
      return T."
  (:method (basic-portal)
   (portal-top-level ("CREATE-FILE" :file-p nil)
     (block create-file
       ;; First, deal with any old extant file
       (when (and file-id 
		  ;; Can't actually call file-extant-p since top level entrypoints
		  ;; can't be called recursively due to transaction lock.
		  (when file
		    (lookup-element self transaction nil nil)	; Don't error
		    file-id))
	 (case if-exists
	   ((:supersede :create)
	    (destroy-file-internal self :if-does-not-exist nil :transaction transaction)
	    (setq file-id nil))
	   (:error
	     (error 'file-already-exists :portal self))
	   ((nil)
	    (return-from create-file nil))))
       (unless file-id
	 (setq file-id (make-new-file-id)))
       (unless file-system-name
	 (invalid-file-id self "CREATE-FILE" nil))
       ;; Load the cache mapping of the portal to the file object.
       (setq file (lookup-file file-id file-system-name)
	     timestamp *initialization-timestamp*)
       ;; Open the dbfs file, creating it if it doesn't exist.
       (lookup-element self transaction t)
       (dbfs-trace 'create-file transaction (process-name *current-process*) self)
       t))))

(defgeneric destroy-file (portal &key (if-does-not-exist :error) transaction)
  "Makes the file nonextant."
  (:method (basic-portal)
   (portal-top-level ("DESTROY-FILE" :error-p  (eq if-does-not-exist :error))
     (destroy-file-internal self
			    :if-does-not-exist if-does-not-exist
			    :transaction transaction))))

(defmethod (destroy-file-internal basic-portal) (&key (if-does-not-exist :error) transaction)
  (when file
    (let ((element (lookup-element self transaction nil  (eq if-does-not-exist :error))))
      ;; This has to locally and remotely invalidate all the pages which happen to be
      ;; in the database buffer, and delete and expunge the UFS file, closing the
      ;; streams and returning the remote-ids.  Any transactions which have any of the
      ;; pages locked will simply be aborted.
      (when element
	(sys:without-aborts ("Your Statice file system will become inconsistent.")
	  (destroy-dbfs-file element file)
	  (unlookup-file (file-file-id file))
	  (setq timestamp nil)
	  (setq file nil)
	  (dbfs-trace 'destroy-file transaction (process-name *current-process*) self))
	t))))

(defgeneric file-extant-p (portal &key transaction)
  "Returns the file-id if the file is extant, else returns 1nil0."
  (declare (values extant-p))
  (:method (basic-portal)
   (prog1
     (portal-top-level ("FILE-EXTANT-P" :error-p nil)
       (when file
	 (lookup-element self transaction nil nil)	; Don't error
	 file-id))
     (dbfs-trace 'file-extant-p transaction (process-name *current-process*) self))))

;;;1 Page operations

0#|
While it might appear that the following function operate in a strange
way, what is really going on is that the modularity is structured to minimize
network exchanges, not to maximize readability.  Thus, pages are locally locked
first, and then depending upon the local state of the page the appropriate
network command is sent.  For example, if a page's state is not known, a
network command is sent to combine the remote locking of the page and state
determination along with the operation.  If the state is known, then only
the locking and operation need to be sent.  And if the operation can be
done completely locally, then only the lock request needs to be sent.

This is why there is a separate concept for local and remote locking of pages
instead of presenting an :after method for the lock-page generic function
for remote pages.

|#

(defmethod (create-page basic-portal) (page-n &key (if-exists :error) transaction)
  "Create the specified page in the file.  The page is left write-locked by
   the current transaction if a new page was created, otherwise the page
   is left read-locked preventing another transaction from changing the page's
   state until the current transaction commits.  Requires a current transaction."
  (declare (values data-array-if-created))
1  ;;+++ TEMPORARY
  (unless if-exists
    (setq if-exists :create))
0  (portal-top-level ("CREATE-PAGE")
    (let ((element (lookup-element self transaction)))
      ;; Get the page frame
      (with-page (page file page-n)
	(let ((createdp
		(if (or (= (page-data-state page) %uninitialized)
			(eq if-exists :create))
		    ;; The page is either nonextant or else its
		    ;; existance is unknown.  Go ahead and create the
		    ;; page if it is nonextant or if :if-exists :create
		    ;; is specified.  Do this in one network exchange.
		    ;; Returns NIL if the page was not created,
		    ;; otherwise returns T (with the page already write
		    ;; locked).
		    (create-dbfs-page element page page-n (eq if-exists :create))
		    ;; The page is locally known to be extant (and if-exists is not :create)
		    ;; Leave the page read-locked (so its existance cannot be changed)
		    (lock-dbfs-page element page %read-lock)
		    nil)))
	  (cond (createdp
		 ;; The page was either nonextant or else the caller didn't care.
		 (check-state page "CREATE-PAGE")
		 (dbfs-trace 'create-page transaction (process-name *current-process*)
			     self page-n)
		 (if *full-verification*
		     (writable-data-array transaction page)
		     (page-data-array page)))
		((eq if-exists :error)
		 (error 'page-already-exists
			:attempt "CREATE-PAGE"
			:page-n page-n
			:portal self))
		(if-exists
		 (error ":IF-EXISTS value of ~A unknown; must be :CREATE, :ERROR, or NIL."
			if-exists))))))))

(defmethod (destroy-page basic-portal) (page-n &key (if-does-not-exist :error) transaction)
  "Requires a current transaction"
  (declare (values destroyed-page-flag))
  (portal-top-level ("DESTROY-PAGE")
    ;; Get the page frame
    (let ((element (lookup-element self transaction))) 
      (with-page (page file page-n)
	(unless (destroy-dbfs-page element page)
	  ;; The page did not exist.
	  (ecase if-does-not-exist
	    ((nil) nil)
	    (:error
	      (error 'nonextant-page :attempt "DESTROY-PAGE"
		     :page-n page-n :portal self))))))))

(defmethod (page-extant-p basic-portal) (page-n &key transaction)
  "Requires a current transaction"
  (declare (values extant-flag))
  (portal-top-level ("PAGE-EXTANT-P")
    ;; Get the page frame
    (let ((element (lookup-element self transaction)))
      (with-page (page file page-n)
	(cond ((= %uninitialized (page-data-state page))
	       (dbfs-page-extant-p element page))
	      (t
	       (lock-dbfs-page element page %read-lock t)
	       t))))))

(defmethod (read-page basic-portal) (page-n &key
					    (if-does-not-exist :error)
					    (probable-write nil)
					    transaction)
  "Returns an ART-FIXNUM array filled with the specified page's data.  The page
   is read-locked preventing modification by another transaction until the
   current transaction commits.  Requires a current transaction."
  (declare (values page-data-array))
  (portal-top-level ("READ-PAGE")
    (let ((lock-type (if probable-write %probable-write-lock %read-lock)))
      ;; Check the cache.  Since only pages already locked by the transaction
      ;; can be in the cache, don't need to go and set any per-page latches or
      ;; play around with the transaction element, etc.
      (or (lookup-page-cache transaction file page-n lock-type)
	  ;; Get the page frame
	  (let ((element (lookup-element self transaction)))
	    (with-page (page file page-n)
	      (incf *count-read-pages*)
	      (select (page-data-state page)
		((%uninitialized %invalid)
		 (process:without-lock ((page-lock page))
		   (validate-when-optimistic element))))
	      (cond ((select (page-data-state page)
		       ((%uninitialized %invalid)
			(incf *count-read-misses*)
			(read-dbfs-page element page lock-type))
		       (%valid
			 (incf *count-read-hits*)
			 (lock-dbfs-page element page lock-type)
			 t)
		       (t (error "Illegal page data state")))
		     (check-state page "READ-PAGE")
		     (insert-page-cache transaction page page-n lock-type)
		     (if *full-verification*
			 (if ( (page-write-state page) %na)
			     (writable-data-array transaction page)
			     (read-only-data-array transaction page))
			 (page-data-array page)))
		    (t
		     (ecase if-does-not-exist
		       ((nil) nil)
		       (:error
			 (error 'nonextant-page
				:attempt "READ-PAGE" :portal self :page-n page-n)))))))))))

(defmethod (write-page basic-portal) (page-n &key
					     (if-does-not-exist :error)
					     transaction)
  "Returns an ART-FIXNUM array filled with the specified page's data.  The page
   is write-locked preventing any access by another transaction until the
   current transaction commits.  Requires a current transaction."
  (declare (values page-data-array))
  (portal-top-level ("WRITE-PAGE")
    ;; Get the page frame
    ;; Check the cache.  Since only pages already locked by the transaction
    ;; can be in the cache, don't need to go and set any per-page latches or
    ;; play around with the transaction element, etc.
    (or (lookup-page-cache transaction file page-n %write-lock)
	;; Get the page frame
	(let ((element (lookup-element self transaction))
	      (create-p (eq :create if-does-not-exist)))
	  (with-page (page file page-n)
	    (incf *count-write-pages*)
	    (select (page-data-state page)
	      ((%uninitialized %invalid)
	       (process:without-lock ((page-lock page))
		 (validate-when-optimistic element))))
	    (cond ((select (page-data-state page)
		     ((%uninitialized %invalid)
		      (incf *count-write-misses*)
		      (let ((extant-p (read-dbfs-page element page %write-lock create-p)))
			(when extant-p
			  ;; Can't distinguish write-lock from dirtying a page
			  (set-page-modified page element))
			extant-p))
		     (%valid
		       (incf *count-write-hits*)
		       (lock-dbfs-page element page %write-lock)
		       ;; Can't distinguish write-lock from dirtying a page
		       (set-page-modified page element)
		       t)
		     (t (error "Illegal page data state")))
		   (check-state page "WRITE-PAGE")
		   (insert-page-cache transaction page page-n %write-lock)
		   (if *full-verification*
		       (writable-data-array transaction page)
		       (page-data-array page)))
		  (t
		   (ecase if-does-not-exist
		     ((nil)
		      nil)
		     (:error
		       (error 'nonextant-page
			      :attempt "WRITE-PAGE" :portal self :page-n page-n))
		     (:create
		       ;; Should be impossible, but leave here just to
		       ;; see all the possibilities
		       (error ":if-does-not-exist :create did not create the page."))))))))))

(defmethod (file-page-size basic-portal) (&key transaction)
  "Returns the size in words of all the pages in the file."
  (declare (values page-size-in-words))
  ;; This is optimized to be fast since Statice uses this very frequently.
  (or (and (eql timestamp *initialization-timestamp*)
	   (fast-file-page-size file))
      ;; This doesn't call portal-top-level since it doesn't really ever touch the
      ;; network.  (;+++Maybe not true?)  However, since check-file can invalid-file-id,
      ;; the transaction lock needs to be seized.
      (progn
	(unless transaction
	  (setq transaction (lookup-client-transaction-or-error "FILE-PAGE-SIZE")))
	(with-nonordered-lock ((transaction-lock transaction))
	  (check-state transaction "FILE-PAGE-SIZE")
	  (check-file "FILE-PAGE-SIZE")
	  (lookup-element self transaction)
	  (file-page-size-in-words file)))))

(defmethod (file-page-length basic-portal) (&key transaction)
  "Returns the length of the file in pages, three different ways."
  (declare (values n-extant-pages first-nonextant-page-n free-page-n-after-last-extant-page))
  (portal-top-level ("FILE-PAGE-LENGTH")
    (let ((element (lookup-element self transaction)))
      (dbfs-file-page-length element file))))

;;; 1Instantiable Portal

0(defflavor portal () (basic-portal)
  (:constructor make-portal (file-system-name &optional file-id)))

(defmethod (:print-self portal) (stream print-depth slashify-p)
  (ignore print-depth)
  (if slashify-p
      (sys:printing-random-object (self stream)
	(format stream "~A ~A ~A" (type-of self) file-system-name file-id))
      (format stream "Portal to ~A, ~A" file-system-name file-id)))

(compile-flavor-methods basic-portal portal)

;;;; 1Transaction interface

0;;++ Need to generate catch tag only on outer transactions so aborts in a nested
;; transaction go to the outer handler for restart.
(defmacro with-transaction ((&rest options) &body body)
  (declare (arglist (&key (automatic-retry 'restartable-transaction-abort)) &body body))
  (let ((finish-form (getf options :finish-form)))
    `(with-transaction-internal-1
       #'(zl:named-lambda transaction-body ()
	   (declare (sys:downward-function))
	   . ,body)
       ,(when finish-form
	  `#'(zl:named-lambda transaction-finish ()
	       (declare (sys:downward-function))
	       ,finish-form))       
       . ,(si:rem-keywords options '(:finish-form)))))

(defun with-transaction-internal-1 (transaction-continuation finish-continuation
				    &key (automatic-retry 'restartable-transaction-abort)
				    &allow-other-keys)
  (flet ((run-transaction ()
	   (unwind-protect-case ()
	       (condition-bind-if *optimistic-locking*
				  ((error (lambda (ignore)
					    (unless *inside-dbfs*
					      (validate-transaction))
					    nil)))
		 (setq *process-transaction* (begin-transaction))
		 (multiple-value-prog1
		   (funcall transaction-continuation)
		   (sys:without-aborts
		     ("A Statice transaction is committing.  Aborting at this point could~@
                       leave Statice in an inconsistent state and cause bizarre errors~@
                       until the next time this machine is cold-booted.")
		     (end-transaction)
		     (when finish-continuation
		       (funcall finish-continuation)))))
	     (:abort
	       (abort-transaction-one-level)))))
    (if *process-transaction*
	;; This is a nested transaction
	(run-transaction)
	;; This is the outermost transaction
	(let ((*process-transaction* nil)		; Bind this variable per process.
	      (*process-transaction-creation-time* nil))
	  (loop repeat *transaction-retry-limit*
		as error = (catch 'transaction-abort
			     (return (run-transaction)))
		unless (and automatic-retry (typep error automatic-retry))
		  do (error error)
		do
	    ;;Might as well let others run, since we seem to have troubles.
	    (process:allow-preemption)
	    #+ignore
	    (let ((vct *process-transaction-creation-time*))
	      (setf (gethash vct *abort-events*)
		    (nconc (gethash vct *abort-events*)
			   (list (list 'retry vct i)))))
		finally (error 'transaction-retry-limit-exceeded))))))

(defmacro transaction-top-level ((attempt) &body body)
  `(let ((*inside-dbfs* t))
     (loop named transaction-top-level doing
       (unless transaction
	 (setq transaction (lookup-client-transaction-or-error ,attempt)))
       (with-nonordered-lock ((transaction-lock transaction))
	 (check-state transaction ,attempt)
	 (block network-error
	   (let ((abort-error
		   (catch 'network-error
		     (return-from network-error
		       (catch-with-handler
			 (top-level-tag handle-throw-to-top-level transaction)
			 (return-from transaction-top-level (progn ,@body)))))))
	     (close-transaction transaction :abort-error abort-error)))))))

;; This doesn't need a transaction-top-level because it doesn't go into the
;; network or the dbfs locking system.
(defun begin-transaction ()
  "Starts a new current transaction."
  (declare (values transaction))
  (incf *count-transactions*)
  (let* ((*inside-dbfs* t)
	 (tran (or (lookup-client-transaction)
		   (with-lock (*transaction-creation-lock*)
		     (let ((tr (allocate-resource 'transaction)))
		       (setf (gethash tr *active-transactions*) t)
		       tr)))))
    (open-transaction tran)
    (dbfs-trace 'begin-transaction tran (process-name *current-process*))
    tran))

(defun end-transaction (&key transaction)
  "Make all the modifications made by the current transaction permanent,
   releasing the locks held on all the pages the transaction referenced.
   Ends the transaction."			;++ nested transactions
  (declare (values committed-transaction-p))
  (transaction-top-level ("END-TRANSACTION")
    (close-transaction transaction)))

(defun mark-transaction (&key transaction)	;++ nested transactions
  "Make all modifications made by the current transaction permanent without
   changing the lock states of the pages or ending the transaction."
  (declare (values committed-transaction-p))
  (transaction-top-level ("MARK-TRANSACTION")
    #+ignore(update-transaction transaction)
    (error "Not implemented yet")
    t))

(defun abort-transaction (&key (error 'transaction-abort) (signal-abort t) transaction)
  "Undo all the modifications made by the current transaction, releasing
   the locks held on all the pages the transaction referenced.  Ends the
   current transaction."
  (let ((*inside-dbfs* t))
    ;; Have to manually code in the transaction-top-level because
    ;; abort-transaction needs to do special handling of errors.
    (unless transaction
      (setq transaction (lookup-client-transaction)))
    (when transaction
      (with-nonordered-lock ((transaction-lock transaction))
	;; Don't get a state error if the transaction is already aborted and
	;; signal-abort is nil.  This is especially useful for cleanup handlers
	;; in case the transaction was already aborted by some other means
	;; (system shutdown or deadlock), but the user aborted out of the
	;; transaction before trying to use the transaction so that the
	;; error was never signalled.
	(unless (and (transaction-error transaction) (not signal-abort))
	  (check-state transaction "ABORT-TRANSACTION"))
	(when (typep error 'symbol)
	  (setq error (make-condition error)))
	(unless (typep error 'transaction-abort)
	  (error "The value of the :ERROR keyword must be a condition object or flavor ~@
                based upon DBFS:TRANSACTION-ABORT."))
	(loop named portal-top-level doing
	  (catch-with-handler (top-level-tag handle-throw-to-top-level transaction)
	    (return-from portal-top-level
	      (close-transaction transaction
				 :abort-error error
				 :signal-abort signal-abort
				 :asynch-abort t))))))))

;;; This is called by the cleanup handler in with-transaction.
(defun abort-transaction-one-level ()
  (let ((*inside-dbfs* t))
    ;; Have to manually code in the transaction-top-level because
    ;; abort-transaction needs to do special handling of errors.
    (let ((transaction (lookup-client-transaction)))
      (when transaction
	;; Don't get a state error if the transaction is already aborted and
	;; signal-abort is nil.  This is especially useful for cleanup handlers
	;; in case the transaction was already aborted by some other means
	;; (system shutdown or deadlock), but the user aborted out of the
	;; transaction before trying to use the transaction so that the
	;; error was never signalled.
	(with-nonordered-lock ((transaction-lock transaction))
	  (unless (transaction-error transaction)
	    (check-state transaction "ABORT-TRANSACTION"))
	  (loop named portal-top-level doing
	    (catch-with-handler (top-level-tag handle-throw-to-top-level transaction)
	      (return-from portal-top-level
		(close-transaction-one-level transaction)))))))))

(defun validate-transaction (&key transaction)
  (transaction-top-level ("VALIDATE-TRANSACTION")
    (validate transaction)))

;;; The transaction object (used internally).

(defun current-transaction-id ()
  (let ((tran (lookup-client-transaction)))
    (and tran (transaction-id tran))))

(defconstant %page-cache-size 5)

(defflavor transaction
	(id
	 (page-cache nil)			; When init, an array of pages
	 page-cache-key				; Corresponding page num
	 page-cache-lock-type			; How the tran has the page locked
	 page-cache-pointer			; Current position into cache (circular)
	 page-cache-address			; Address of 0th word in cache (locative)
	 (indirect-arrays nil))			; Just used by *full-verification*
	(basic-transaction)
  (:readable-instance-variables id)
  (:constructor make-transaction ()))

;;; initialize-transaction is the resource-initializer for the transaction
;;; resource, so this is called when a new top-level transaction is created.
(defmethod (initialize-transaction transaction :after) ()
  (if page-cache
      (fill page-cache-key nil)
      (setq page-cache (make-array %page-cache-size)
	    page-cache-key (make-array %page-cache-size)
	    page-cache-lock-type (make-array %page-cache-size))
      (setq page-cache-address (locf (aref page-cache-key 0))))
  (setq page-cache-pointer 0)
  (when *full-verification*
    (if indirect-arrays
	(clrhash indirect-arrays)
	(setq indirect-arrays (make-hash-table :locking nil))))
  (setq id *count-transactions*))

(defmethod (deinitialize-transaction transaction) ()
  (with-lock (*transaction-creation-lock*)
    (setf (gethash self *active-transactions*) nil)
    (setq *process-transaction* nil)
    (deallocate-resource 'transaction self))) 

;;; open-transaction is called when a process enters a transaction,
;;; whether starting a top level or a recursive transaction.
(defmethod (open-transaction transaction :before) ()
  (when error
    ;; The transaction was previously aborted but never signalled.  This can
    ;; happen when the cleanup handler of with-transaction aborts the transaction
    ;; but cannot signal the abort from within the cleanup handler.  Just
    ;; reset the transaction
    (when indirect-arrays
      (revoke-indirect-arrays self))
    (initialize-transaction self))
  (when (plusp depth)
    ;; Entering a recursive transaction.  Save the contents of modified pages.
    (maphash #'(lambda (ignore element)
		 (declare (sys:downward-function))
		 (save-data-of-element element depth))
	     elements)))

(defmethod (handle-throw-to-top-level transaction) (&rest catch-vals)
  ;; The handlers are partially ordered according to frequency of use
  ;; Note that transaction-top-level can only get errors which are due to
  ;; remote pages, and furthermore, it can really only see asynchronous
  ;; replies (e.g. errors due to optimistic locking).
  (catch-handler-case catch-vals
    ;; Can never happen since only is a synchronous reply?
    #+ignore
    (page-locked-remotely (file-id page-n element)
      (incf *count-lock-waits*)
      (tv:noting-progress ("Waiting for remote page to be unlocked")
	(page-locked-remotely-handler element file-id page-n)))
    (cache-invalid (file-id page-n element invalid-array)
      (cache-invalid-handler element file-id page-n invalid-array))
    (remote-deadlock (transaction)
      (close-transaction
	transaction
	:abort-error 'two-transaction-deadlock-restartable-transaction-abort))
    (nonextant-file (remote-id element)
      (nonextant-file-handler element remote-id))
    (server-booted (server word1 word2 word3)
      (process:without-lock ((transaction-lock *process-transaction*))
	(invalidate-server server word1 word2 word3))
      (close-transaction self
			 :abort-error 'server-restart-restartable-transaction-abort))))

(defmethod (lookup-page-cache transaction) (file page-n lock-type)
  (declare (values page-data-array-or-NIL))
  #+dbfs-internal-metering(incf *count-page-cache-lookups*)
  (let ((hit (sys:%block-search-eq page-n page-cache-address %page-cache-size))
	index)
    (and hit
	 (setq index (sys:%pointer-difference hit page-cache-address))
	 (= lock-type (aref page-cache-lock-type index))
	 (page-cache-valid (setq hit (aref page-cache index)) file page-n lock-type self))))

(defmethod (insert-page-cache transaction) (page page-n lock-type)
  (let ((i (sys:%block-search-eq page-n page-cache-address %page-cache-size)))
    ;; If an old entry exists, reuse its slot to make lookup faster (so that
    ;; there can only be one entry with the most recent lock-type)
    (if i
	(setq i (sys:%pointer-difference i page-cache-address))
	(setq i page-cache-pointer)
	;; This is a bit faster than (mod (1+ i) %page-cache-size)
	(setq page-cache-pointer (if (= i (1- %page-cache-size)) 0 (1+ i))))
    (setf (aref page-cache-key i) page-n
	  (aref page-cache i) page
	  (aref page-cache-lock-type i) lock-type)))

;;++Unclear that this is even correct for non-server transactions.
;;Probably want to just treat this like a network error.
(defmethod (handle-connection-killed transaction) ()
  (deinitialize-transaction self)
  ;;++ Pretty big hammer.
  (incf *process-kills*)
  (process-kill *current-process*))

;;; Terminate the transaction.  If :ABORT-ERROR is NIL, the transaction
;;; is committed.  Otherwise, abort the transaction, signalling the
;;; abort (by throwing) if :SIGNAL-ABORT is true.  A null value for
;;; :SIGNAL-ABORT is used by unwind protect handlers (such as
;;; DBFS:WITH-TRANSACTION) to avoid signalling an error when unwinding.
;;; If the transaction is not associated with the current process, the
;;; transaction is aborted, but the signalling of the abort is deferred.
;;; This doesn't need a lock since a transaction can only belong to one
;;; process.  :ASYNCH-ABORT is used by warm boot and friends, explicit
;;; calls to ABORT-TRANSACTION such as the one in WITH-TRANSACTION.  It
;;; is not used for restartable aborts due to network errors, deadlocks,
;;; server restarts, cache skews, process was using a page of a
;;; flush-cache'd file, etc.  FORCE-LATCH is only used
;;; by warm booting, and means page latches should be forcibly unlocked.
(defmethod (close-transaction transaction)
	   (&key abort-error (signal-abort t) asynch-abort (force-latch nil))
  (declare (values committed-transaction-p))
  (when (plusp depth)
    ;; Don't do anything if the transaction is already closed or aborted.
    (cond ((or error abort-error)
	   (let ((cannot-get-lock nil)
		 (acquired-lock nil)
		 (same-process (eq process *current-process*)))
	     (process::with-stack-lock-argument (lock-arg lock)
	       (unwind-protect
		   (progn 
		     ;;Try to get the lock.  We must skip certain steps if we
		     ;;cannot get the transaction lock.
		     (cond
		       ;;If we have the lock, keep going
		       ((holding-lock lock) nil)
		       ;;If we don't, but we are in the same process, wait
		       ;;until we can get it.
		       (same-process
			(atomically (nonordered-lock lock lock-arg)
				    (setf acquired-lock t)))
		       (t
			(setf cannot-get-lock t)))
		     (when same-process
		       (setf inter-process-abort nil))
		     ;; Abort the transaction: either there is an abort pending,
		     ;; or the caller specifically wants to abort now.  error
		     ;; takes precendence over abort-error.  This is particularly
		     ;; important for shutdown-dbfs in which system-shutdown must
		     ;; be signalled rather than network-error.
		     (when error
		       (setq abort-error error))
		     ;; Make the abort error be a proper condition
		     (when (symbolp abort-error)
		       (setq abort-error (make-condition abort-error)))
		     (unless cannot-get-lock
		       (with-atomic-transaction (pending-in-elements-p self)
			 (let ((prior-pending nil))
			   ;; If the transaction was waiting for a lock, clear the
			   ;; pending state.
			   (without-interrupts
			     (when pending
			       (let* ((lock-arg (process::lock-holder (page-lock pending)))
				      (lock-arg-list-p (listp lock-arg))
				      (lock-arg-process (and lock-arg-list-p
							     (process::lock-argument-process
							       lock-arg))))
				 (unless 
				   (and lock-arg lock-arg-list-p
					(eq lock-arg-process
					    *current-process*))
				   (error
			     "Not holding latch of page which you are aborting pending.")))
			       (abort-pending pending self)
			       (unless pending-in-elements-p
				 (setf prior-pending pending)
				 (unlatch-page pending))
			       (setq pending nil)))
			   ;; Iterate over all transaction elements, aborting the element.
			   (maphash #'(lambda (key element)
					(declare (sys:downward-function))
					(abort element asynch-abort force-latch)
					(unlatch-all-pages element prior-pending)
					(remhash key elements)
					(deallocate-element element))
				    elements)))
		       ;; Update meters of what caused the abort.
		       (if (or (null error) (symbolp error))
			   (incf *count-aborts*)
			 ;; This transaction already was aborted.  While this abort
			 ;; still must proceed in case it should be signalled this time
			 ;; and to change the type of abort, the meters should be updated
			 ;; to show the new abort cause, which means decrementing the old
			 ;; abort cause meter.
			 (let* ((old-flavor (type-of error))
				(old-value (gethash old-flavor *abort-table*)))
			   ;; old-value can be nil if a warm boot is in progress,
			   ;; and dbfs has been reset, and this process is being
			   ;; unwound.  See bug mail of 1/22/87 for details.  -- DLW
			   (when old-value
			     (setf (gethash old-flavor *abort-table*) (1- old-value)))))
		       (let ((abort-flavor (type-of abort-error)))
			 (setf (gethash abort-flavor *abort-table*)
			       (1+ (or (fast-gethash abort-flavor *abort-table*) 0)))))
		     ;; Update the transaction state to remember the error.
		     (setq error abort-error)
		     (unless same-process
		       (process:wakeup-without-test process))
		     ;; Signal the abort as desired.
		     (dbfs-trace 'abort self (process-name process) abort-error signal-abort)
		     (when (and signal-abort same-process
				(not cannot-get-lock))
		       ;; Really abort the transaction
		       (when (and indirect-arrays *full-verification*)
			 (revoke-indirect-arrays self))
		       (deinitialize-transaction self)
		       (throw 'transaction-abort abort-error)))
		 ;; Unlock the transaction, so that if another process tries to lock
		 ;; it and then does check-transaction, it'll see what we did.
		 (when acquired-lock
		   (unlock lock lock-arg))))))
	  ((> depth 1)
	   ;; This is a nested transaction.  Have to validate the transaction,
	   ;; otherwise if this did some optimistic locking which turned out
	   ;; to be wrong, the next command we do might see an error it is
	   ;; not prepared to handle (i.e. file-extant-p or something could
	   ;; get a cache-invalid response).  This probably is not the right
	   ;; way to deal with this, but this will be rethought out when I
	   ;; redesign either nested transactions or the 'exit-with-page
	   ;; handling.
	   ;;++ I think this is no longer needed now that all commands have
	   ;; something like portal-top-level, so they call can handle
	   ;; asynch replies.
	   #+ignore(validate self)
	   (incf *count-nested-commits*)
	   (decf depth)
	   (dbfs-trace 'nested-commit self (process-name process)))
	  (t
	   ;;Before grabbing all the locks, and jamming things up, make
	   ;;sure any optimistic requests have been processed first.
	   (maphash #'(lambda (key element)
			(ignore key)
			(validate-when-optimistic element))
		    elements)
	   ;; Commit the transaction
	   (incf *count-top-level-commits*)
	   (sys:without-aborts ("Committing a transaction must be atomic.")
	     (with-atomic-transaction (pending-in-elements-p self)
	       (let ((prior-pending nil))
		 (without-interrupts
		   (when pending
		     (unless pending-in-elements-p
		       (setf prior-pending pending)
		       (unlatch-page pending))
		     (setf pending nil)))
		 (maphash #'(lambda (key element) 
			      (commit element)
			      (unlatch-all-pages element prior-pending)
			      (remhash key elements)
			      (deallocate-element element))
			  elements)))
	     (when (and indirect-arrays *full-verification*)
	       (revoke-indirect-arrays self))
	     (dbfs-trace 'commit self (process-name process))
	     (deinitialize-transaction self))
	   t))))

(defmethod (close-transaction-one-level transaction) ()
  (cond ((= depth 1)
	 (close-transaction self
			    :abort-error (make-condition 'transaction-abort)
			    :signal-abort nil
			    :asynch-abort t)
	 ;; close-transaction doesn't call deinitialize because we're
	 ;; not signalling abort ourselves.
	 (deinitialize-transaction self))
	((> depth 1)
	 (decf depth)
	 (maphash #'(lambda (ignore element)
		      (declare (sys:downward-function))
		      (restore-data-of-element element depth))
		  elements))))

(defmethod (validate transaction) ()
  (maphash #'(lambda (ignore element) (validate element)) elements))

;;; Zap the connections of all the transaction elements.
(defmethod (zap-all-connections transaction) ()
  (maphash #'(lambda (ignore element)
	       (declare (sys:downward-function))
	       (zap-all-connections element))
	   elements))

;;; The following methods are for *full-verification* to implement read-only arrays
;;; and revokable arrays.

#|

note: read-page's and write-page's contract is that they will always
return the same data array when called multiple times within a
transaction, so that when a read-only page is promoted to a writable
page, the same data array must be returned.

The implementation of read-only and revokable data arrays works by
always returning a per-transaction/page indirect array to the base
data-array.  The base array is located in either writable or read-only
areas in VM, requiring the data to be copied upon a transition.  (A VM
interface to change an array's read-only state is impractical since data
arrays have different sizes then VM pages, and it would waste too much
space to page align them.  Also, remember that copying is actually
faster than doing a number of page operations in VM.)

Every client transaction has an instance variable called indirect-arrays
which is NIL when *full-verification* is disabled.  When verification is
turned on, the indirect-array slot contains a hash table mapping the
internal page object into its corresponding indirect array for each
transaction.  This table must be per-transaction since multiple
processes can be sharing access to the same page, and when each
transaction terminates its own arrays must be revoked, leaving the other
transactions intact.  Besides, even if revokation weren't implemented,
I'd prefer to penalize the normal system with verification turned off by
having only one additional slot per transaction than per page.

writable arrays are implemented by simply making the indirect array
displaced to the page's actual data-array.

read-only arrays are making the indirect array point to a copy of the
page's data-array allocated from a resource of read-only-arrays
allocated in an area with the read-only property set.

revokation is implemented by simply smashing the indirect array's
indirect-pointer.  (Perhaps it would be safer to change its size
to 0?)

;+ One problem of this implementation is that si:with-read-only-inhibited
is not optimized for this type of use.  It might be faster to have
a VM interface to permit temporary writing of an address range.

;+ Another problem is that if multiple transactions are reading the same
page, they will each have their own copies of the data array in the
read-only area since the indirect array is per-transaction.  I believe
this is better (since multiple transactions using the same pages on the
same machine is fairly infrequent, especially when debugging which is
when verification is enabled) than making the data-array be an indirect
array itself, because each transaction requires its own indirect
array so it can be revoked when the transaction terminates, and I
think the little bit of wasted space is better than having two levels
of indirection for every single reference to a readable word.

+++ I THINK SOME WITHOUT-INTERRUPTS ARE NEEDED HERE.

|#

(defmethod (revoke-indirect-arrays transaction) ()
  (maphash #'(lambda (page indirect-array)
	       (let ((base-array (sys:array-indirect-pointer indirect-array)))
		 (when (= *read-only-array-area* (sys:%area-number base-array))
		   (deallocate-read-only-array page base-array)))
	       (setf (sys:array-indirect-pointer indirect-array) nil)
	       (sys:array-register-event)	;++ Does this have to be in inner loop?
	       nil)				; no value from array-register-event
	   indirect-arrays))

(defmethod (read-only-data-array transaction) (page)
  (let* ((indirect-array (fast-gethash page indirect-arrays))
	 (data-array (page-data-array page))
	 (page-size (length data-array)))
    (cond (indirect-array
	   (let ((base-array (sys:array-indirect-pointer indirect-array)))
	     (when ( *read-only-array-area* (sys:%area-number base-array))
	       (let ((copy-array (allocate-read-only-array page)))
		 (si:with-read-only-inhibited
		   (fast-copy-fixnum-array data-array nil copy-array nil page-size))
		 (setf (sys:array-indirect-pointer indirect-array) copy-array)
		 (sys:array-register-event)
		 nil)))				; no value from array-register-event
	   indirect-array)
	  (t
	   (setq indirect-array (make-array page-size
					    :element-type 'fixnum
					    :displaced-to (allocate-read-only-array page)))
	   (si:with-read-only-inhibited
	     (fast-copy-fixnum-array data-array nil indirect-array nil page-size))
	   (setf (gethash page indirect-arrays) indirect-array)))))

(defmethod (writable-data-array transaction) (page)
  (let* ((indirect-array (fast-gethash page indirect-arrays))
	 (data-array (page-data-array page))
	 (page-size (length data-array)))
    (cond (indirect-array
	   (let ((base-array (sys:array-indirect-pointer indirect-array)))
	     (when (= *read-only-array-area* (sys:%area-number base-array))
	       (deallocate-read-only-array page base-array))
	     (setf (sys:array-indirect-pointer indirect-array) data-array)
	     (sys:array-register-event)
	     nil)
	   indirect-array)
	  (t
	   (setq indirect-array (make-array page-size
					    :element-type 'fixnum
					    :displaced-to data-array))
	   (setf (gethash page indirect-arrays) indirect-array)))))


(compile-flavor-methods transaction)

(defresource transaction ()
  :constructor (make-transaction)
  :initializer (initialize-transaction object))

;;;; 1Top level

0(defun initialize-client ()
  (setq *process-transaction* nil)
  (clrhash *active-transactions*)
  (clrhash *abort-table*)
  (loop for meter in *dbfs-client-meters*
	doing (set meter 0))
  (setq	*transaction-sequence-number* 0)
  (multiple-value-setq (*client-unique-id-1* *client-unique-id-2* *client-unique-id-3*)
    (uid:unique-id)))

;;; This is called from reinitialize-dbfs (WARM init list and
;;; totally-reset-dbfs), and also from shutdown-dbfs-client.  It aborts
;;; all active transactions, and establishes a new boot ID.
(defun reinitialize-dbfs-client (error &optional force-p)
  ;; First zap all outstanding connections, because if a client process
  ;; is waiting in the network, we can't abort it, and worse yet it
  ;; could be holding latches that would make it impossible for us to
  ;; abort other client processes.
  (maphash #'(lambda (transaction val)
	       (declare (ignore val))
	       (when transaction
		 (zap-all-connections transaction)))
	   *active-transactions*)
  (maphash #'(lambda (transaction val)
	       (declare (ignore val))
	       (when transaction
		 (when force-p
		   (reset-lock (transaction-lock transaction)))
		 (with-nonordered-lock ((transaction-lock transaction))
		   (close-transaction transaction :signal-abort nil :abort-error error
				      :asynch-abort t :force-latch t))))
	   *active-transactions*)
  (setq *process-transaction* nil)
  (multiple-value-setq (*client-unique-id-1* *client-unique-id-2* *client-unique-id-3*)
    (uid:unique-id)))  

;;; This is called from SHUTDOWN-DBFS (BEFORE-COLD and totally-reset).
(defun shutdown-dbfs-client ()
  (reinitialize-dbfs-client 'system-shutdown-transaction-abort))

(defun show-client-status (&key (stream *standard-output*))
  (format stream "~3&~'bState of the local client:~~2%")
  (tv:with-indentation (stream 2)
    (maphash #'(lambda (transaction val)
		 (declare (ignore val))
		 (when transaction
		   (show-status transaction :stream stream)))
	     *active-transactions*)))

(defun show-client-meters (&key (stream *standard-output*))
  (format stream "~2&~'bLocal client meters:~~%")
  (tv:with-indentation (stream 2)
    (format stream "~&~D transaction~:P." *count-transactions*)
    (tv:with-indentation (stream 2)
      (format stream "~&~D commit~:P." *count-top-level-commits*)
      (format stream " (plus ~D nested commit~:P.)" *count-nested-commits*)
      (format stream "~&~D transaction abort~:P." *count-aborts*)
      (when (plusp *count-aborts*)
	(tv:with-indentation (stream 2)
	  (maphash #'(lambda (flavor count)
		       (declare (sys:downward-function))
		       (format stream "~&~A: ~D" flavor count))
		   *abort-table*))))
    (format stream "~&~D pages were invalidated by the server."
	    *count-pages-invalidated-by-server*)
    (format stream "~&~D pages were not invalidated by the server."
	    *count-pages-not-invalidated-by-server*)
    (format stream "~&~D server resets occurred." *count-server-invalidations*)
    (format stream "~&~D lock waits." *count-lock-waits*)
    (format stream "~&~D read pages." *count-read-pages*)
    (format stream "~&~D read cache hits." *count-read-hits*)
    (format stream "~&~D read cache misses." *count-read-misses*)
    (format stream "~&~D write pages." *count-write-pages*)
    (format stream "~&~D write cache hits." *count-write-hits*)
    (format stream "~&~D write cache misses." *count-write-misses*)
    #+dbfs-internal-metering
    (progn
      (when (plusp *count-page-cache-lookups*)
	(format stream "~&~D Page cache hits/~D lookups (~$%)"
		*count-page-cache-hits* *count-page-cache-lookups*
		(* 100.0 (/ (float *count-page-cache-hits*) *count-page-cache-lookups*)))))))
