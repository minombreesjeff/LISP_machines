;;; -*- Syntax: Common-lisp; Base: 10; Package: DBFS-DIR; Mode: LISP; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

 

;;; import:
;;;         dbfs-dir::unqualified-file-system-name

(defsubst fast-string= (str1 str2)
  (sys:%string= str1 0 str2 0 nil))

(define-schema dbfs-dir (dbfs-entity dbfs-file dbfs-directory root-directory rename-delete))

(define-entity-type dbfs-entity ()
  ((name string :accessor dbfs-entity-name)
   (parent dbfs-directory :accessor dbfs-entity-parent)
   (author string :accessor dbfs-entity-author)
   (creation-date integer :accessor dbfs-entity-creation-date)
   (comment string :accessor dbfs-entity-comment))
  (:multiple-index (parent name) :unique t))

;;;++ no way to specify that {id0 id1 id2} must be unique without specifying
;;; a multiple index.  If a multiple index is later created for mapping ids to
;;; a file, make sure to specify :unique t.
(define-entity-type dbfs-file (dbfs-entity)
  ((id0 integer)
   (id1 integer)
   (id2 integer)))

(define-entity-type dbfs-directory (dbfs-entity) ())

(define-entity-type root-directory (dbfs-directory) ())

(define-entity-type rename-delete ()
  ((tick integer :initform 1 :accessor rename-delete-tick))
  (:area rename-delete))

(defvar *dbfs-directories* (make-hash-table :test #'fast-string=
					    :hash-function #'sys:sxhash-string))

;;; This flavor of portal is used for portals to dbfs-directory
;;; databases themselves.  The flavor exists so that it can 
;;; have a special method for dbfs:nonextant-file.
(scl:defflavor directory-portal () (dbfs:portal))

;;; This should have a lock, but the real problem here is that the namespace
;;; itself does not provide synchronization (unlike statice).  Synchronizing
;;; between processes on just this one machine wouldn't accomplish much.
(defun initialize-directory-database (file-system-name &optional locally-only)
  "Create the schema."
  ;; Register the directory database portal in the namespace
  (let* ((portal (make-instance 'directory-portal :file-system-name file-system-name))
	 (object (net:find-object-named :file-system file-system-name))
	 (properties (send object :property-list))
	 (user-properties (getf properties :user-property))
	 (root-property (assoc :dbfs-dir-root-file-id user-properties)))
    (make-database portal 'dbfs-dir)
    ;; At this point the portal now has a file-id.  Get it.
    (multiple-value-bind (id0 id1 id2)
	(dbfs::file-id-words (dbfs:file-unique-id portal))
      ;; And shove it in the namespace object
      (let ((id-str (format nil "~D-~D-~D" id0 id1 id2)))
	(unless (member (send object :type) '(:dbfs :ufs)) ;++++ fix this later
	  (error "The file system must be a :DBFS file system, not a ~A file system."
		 (send object :type)))
	(cond (root-property
	       ;; There already was a dbfs-dir root.  Just replace the file-id string.
	       (setf (second root-property) id-str))
	      (user-properties
	       ;; There was no dbfs-dir root, but there is a user property.  Have
	       ;; to append the file-id association.
	       (nconc user-properties `((:dbfs-dir-root-file-id ,id-str))))
	      (t
	       ;; No user properties.
	       (nconc properties `(:user-property ((:dbfs-dir-root-file-id ,id-str))))))
	(loop for namespace in (send object :namespaces) doing
	  (net:update-object-permanently :file-system
					 namespace
					 (send object :primary-name)
					 properties
					 locally-only)))
      ;; Now initialize the directory database to point to itself.
      (with-database (dir portal)
	(with-transaction ()
	  ;; Create the root directory
	  (let ((root (make-root-directory :name "Root-directory"
					   :comment "The Root Directory"
					   :author zl:user-id
					   :creation-date (get-universal-time))))
	    ;; Put in an entry for the directory file itself.
	    (make-dbfs-file :name "Directory"
			    :parent root
			    :comment "The Directory Database"
			    :author zl:user-id
			    :creation-date (get-universal-time)
			    :id0 id0
			    :id1 id1
			    :id2 id2))))
      (setf (gethash file-system-name *dbfs-directories*) portal))))

(scl:defflavor dbfs-file-not-found () (fs:file-not-found))

(scl:defmethod (:report-without-pathname dbfs-file-not-found) (stream)
  (format stream "The file was not found"))

(scl:defflavor dbfs-directory-not-found ((component-directory nil)) (fs:directory-not-found)
  (:initable-instance-variables component-directory)
  (:readable-instance-variables component-directory))

(scl:defmethod (:report-without-pathname dbfs-directory-not-found) (stream)
  (if component-directory
      (format stream "Component ~A of the directory was not found" component-directory)
      (format stream "The directory was not found" component-directory)))

(scl:defflavor dbfs-directory-not-empty () (fs:directory-not-empty))

(scl:defmethod (:report-without-pathname dbfs-directory-not-empty) (stream)
  (format stream "The directory may not be deleted, for it is not empty."))

(scl:defflavor dbfs-file-already-exists () (fs:file-already-exists))

(scl:defmethod (:report-without-pathname dbfs-file-already-exists) (stream)
  (format stream "The file already exists"))

(scl:defflavor dbfs-wildcard-not-allowed (pathname op wild-non-dirs-ok)
	   (fs:wildcard-not-allowed)
  (:initable-instance-variables))

(scl:defmethod (:report-without-pathname dbfs-wildcard-not-allowed) (stream)
  (format stream "~:[Wildcard pathnames~;Directory wildcards~] are not allowed ~
	          for ~:[this~*~;the ~A~] operation."
	  wild-non-dirs-ok op op))

(scl:defflavor dbfs-open-not-probe () (fs:file-request-failure))

(scl:defmethod (:report-without-pathname dbfs-open-not-probe) (stream)
  (format stream "OPEN on a DBFS pathname requires that the :DIRECTION be~@
                  :PROBE, :PROBE-LINK, or :PROBE-DIRECTORY"))

;;; This doesn't really need a lock since if the first gethash fails, the puthash
;;; will always get the right value if the dbfs directory has been initialized,
;;; so multiple processes could just end up puthashing the same value, which is ok.
(defun lookup-directory-portal (file-system-name)
  (let ((canonical-name (send (send (net:find-object-named :file-system file-system-name)
				    :primary-name) :qualified-string)))
    (or (gethash canonical-name *dbfs-directories*)
	(setf (gethash canonical-name *dbfs-directories*)
	      (make-instance 'directory-portal
			     :file-system-name canonical-name
			     :file-id (directory-file-id canonical-name))))))

;;; Given the name of a file system, return the file-id of the directory
;;; database for that file system.
(defun directory-file-id (file-system-name)
  (let* ((object (net:find-object-named :file-system file-system-name))
	 (root-id (send object :user-get :dbfs-dir-root-file-id)))
	(unless (member (send object :type) '(:dbfs :ufs)) ;++++ fix this later
      (error "The file system must be a :DBFS file system, not a ~A file system."
	     (send object :type)))
    (unless root-id
      (error "The DBFS directory has not been initialized."))
    (let (id0 id1 id2 pos)
      (multiple-value-setq (id0 pos)
	(parse-integer root-id :junk-allowed t))
      (multiple-value-setq (id1 pos)
	(parse-integer root-id :junk-allowed t :start (1+ pos)))
      (setq id2 (parse-integer root-id :junk-allowed t :start (1+ pos)))
      (dbfs:lookup-file-id id0 id1 id2))))

#|^^^ needed?
;;; This is called if the directory database has been deleted.  Perhaps
;;; a new one has been created, e.g. the user ran
;;; initialize-directory-database again.  That can happen if a whole
;;; file system was wiped out and rebuilt under the original namespace
;;; name.  Check to see if that's what happened.
(scl:defmethod (dbfs:nonextant-file directory-portal) (&optional (error-p t))
  (let ((old-id dbfs::file-id))
    (setq dbfs::file-id (directory-file-id dbfs::file-system-name))
    (if (eq dbfs::file-id old-id)
	;; Didn't map to anything new.  This means that the name is in
	;; the directory, but the file just doesn't exist.  Signal the
	;; nonextant-file error.
	(when error-p
	  (error 'dbfs:nonextant-file :portal self))
	;; We got a new one.  Try it.
	dbfs::file-id)))
|#

(defun name-of-file-id (file-id file-system-name)
  (multiple-value-bind (id0 id1 id2) (dbfs::file-id-words file-id)
    (let ((portal (lookup-directory-portal file-system-name)))
      (with-database (dir portal)
	(with-transaction ()
	  (let ((file (for-each ((file dbfs-file)
				 (:where (and (= id0 (dbfs-file-id0 file))
					      (= id1 (dbfs-file-id1 file))
					      (= id2 (dbfs-file-id2 file)))))
			(return file))))
	    (when file
	      (let ((name (string-append ">" (dbfs-entity-name file)))
		    (root (for-each ((root root-directory))
			    (return root))))
		(loop for parent = (dbfs-entity-parent file) then (dbfs-entity-parent parent)
		      until (eq root parent)
		      do (setq name (string-append ">" (dbfs-entity-name parent) name)))
		(string-append file-system-name ":" name)))))))))

(defun name-of-file-id-words (id0 id1 id2 file-system-name)
  (name-of-file-id (dbfs:lookup-file-id id0 id1 id2) file-system-name))


(defsubst unqualified-file-system-name (file-system)
  (send (first (send file-system :names)) :string))

(scl:defmethod (update-dbfs-directory-file-id fs:dbfs-fs-mixin) (directory-file-id)
  ;; Register the directory database portal in the namespace
  (let* ((properties (send self :property-list))
	 (user-properties (getf properties :user-property))
	 (root-property (assoc :dbfs-dir-root-file-id user-properties))
	 (file-system-name (unqualified-file-system-name self)))
    ;; At this point the portal now has a file-id.  Get it.
    (destructuring-bind (id0 id1 id2) directory-file-id
      ;; And shove it in the namespace object
      (let ((id-str (format nil "~D-~D-~D" id0 id1 id2)))
	(unless (member (send self :type) '(:dbfs :ufs))	;++++ fix this later
	  (error "The file system must be a :DBFS file system, not a ~A file system."
		 (send self :type)))
	(cond (root-property
	       ;; There already was a dbfs-dir root.  
	       (if (string-equal (second root-property) id-str)
		   ;;The directory id hasn't changed, punt!
		   (return-from update-dbfs-directory-file-id t)
		 ;;Otherwise just replace the file-id string.
		 (setf (second root-property) id-str)))
	      (user-properties
	       ;; There was no dbfs-dir root, but there is a user property.  Have
	       ;; to append the file-id association.
	       (nconc user-properties `((:dbfs-dir-root-file-id ,id-str))))
	      (t
	       ;; No user properties.
	       (nconc properties `(:user-property ((:dbfs-dir-root-file-id ,id-str))))))
	(loop for namespace in (send self :namespaces) doing
	  (net:update-object-permanently :file-system
					 namespace
					 (send self :primary-name)
					 properties)))
      ;; Uncache current directory portal
      (setf (gethash file-system-name *dbfs-directories*) nil)
      ;; Reset the file-access-paths
      (dolist (ap fs:file-access-paths)
	(send ap :reset))			
      ;; Recache the right one
      (lookup-directory-portal file-system-name))))

(defun rename-file-id (old-file-id new-file-id file-system-name)
  (multiple-value-bind (old-id0 old-id1 old-id2) (dbfs::file-id-words old-file-id)
    (let ((portal (lookup-directory-portal file-system-name)))
      (with-database (dir portal)
	(statice:with-transaction ()
	  (let ((file (for-each ((file dbfs-file)	
				 (:where (and (= old-id0 (dbfs-file-id0 file))
					      (= old-id1 (dbfs-file-id1 file))
					      (= old-id2 (dbfs-file-id2 file)))))
			(return file))))
	    (when file 
	      (multiple-value-bind (new-id0 new-id1 new-id2) (dbfs::file-id-words new-file-id)
		(setf (dbfs-file-id0 file) new-id0)
		(setf (dbfs-file-id1 file) new-id1)
		(setf (dbfs-file-id2 file) new-id2))
	      (fs:increment-rename-delete-tick
		(send (net:find-object-named :file-system file-system-name)
		      :file-access-path)))))))))

#| 

A pathname-portal-mixin is intended to be mixed in with pathnames to
make them also behave as DBFS portals.  Unlike a DBFS portal which
is identified by its file-id, a pathname portal is identified by
its name, with the file-id merely being a cache.  The idea is that
if a file pointed to by a pathname portal is destroyed, but then a new
file is created with the same name, but now a new file-id, (such as
will happen when a database is recreated since it is truely a different
file), old pathnames with the same name will be remapped to the new file id.

The file-id cache is maintained by DBFS calling the methods invalid-file-id or 
nonextant-file when it gets an error.  When a pathname is created, the
file-id is NIL.  The first time this pathname is used, DBFS will call
invalid-file-id, which will then map the name of the pathname to the
file-id, or else signal an error if the file doesn't exist in the directory.
Once the file-id has been cached, it assumes that it does not need to
check the validity of the file-id since if the same name is mapped to a
new file, the old file is destroyed.  When a pathname is used with a file-id
to a nonextant file, dbfs calls the nonextant-file method, which tries
to remap the pathname to a new file-id, signalling an error only if the
file is no longer in the directory or if it did not find a new file-id to
try.

|#

;;; Moved this to dbfs-pathname.lisp in order to avoid bogus warnings from the
;;; flavor system that are distressing during world-building.
;;; (defflavor pathname-portal-mixin () (dbfs:basic-portal)
;;;   (:default-init-plist :file-id nil))

#| ok - here's a place where the two systems will have difficulty co-existing |#

(scl:defmethod (lookup-file-id pathname-portal-mixin) (&key create remap (error t))
  "If CREATE-P is false, this maps the pathname's file name in the dbfs directory
   into the file-id stored in the directory, caching the file-id in the pathname
   portal.  If REMAP is true, this will always do the lookup even if it already
   has the file-id cached, otherwise it only does the mapping if the cache is
   empty.  If the file name does not exist in the directory, an error is signalled
   if ERROR is true.
   If CREATE-P is true, the file-id in the portal object is stored in the directory,
   creating a new directory entry if need be."
  (unless (and dbfs::file-id dbfs::file-system-name (not create) (not remap))
    (unless dbfs::file-system-name
      (setq dbfs::file-system-name (send (send self :host) :name)))
    (let ((dir-portal (lookup-directory-portal dbfs::file-system-name))
	  (directory-list (send self :directory))
	  (name-string (send self :name)))
      (when (eq :wild name-string)
	(error "Invalid attempt to use a pathname without a file name: ~A"
	       (send self :string-for-printing)))
      (unless (or (listp directory-list)
		  (eq directory-list :root))
	(error "Invalid attempt to use a relative pathname: ~A"
	       (send self :string-for-printing)))
      (let ((result
	      ;; This form returns a file-id if it succeeds, or a
	      ;; condition object if it does not succeed.  This
	      ;; modularity is used so that errors are signalled outside
	      ;; of the transaction, so that recovery activities such as
	      ;; "create the missing directory" won't be aborted when
	      ;; the user tries to restart.
	      (block result
		(with-database (dir dir-portal)
		  (with-transaction ()
		    (let* ((root (for-each ((root root-directory))
				   (return root)))
			   (dir (if (eq directory-list :root)
				    root
				    (loop for dir = root
						  then (lookup-dbfs-directory dir-name dir)
					  for dir-name in directory-list
					  while dir
					  finally (unless dir
						    (return-from result
						      (make-instance
							'dbfs-directory-not-found
							:pathname self
							:component-directory dir-name)))
						  (return dir))))
			   (file (lookup-dbfs-file name-string dir)))
		      (cond (file
			     ;; The given name already exists.
			     (if create
				 ;; Replace the file-id in the directory with the new one.
				 (multiple-value-bind (id0 id1 id2)
				     (dbfs::file-id-words dbfs::file-id)
				   (setf (dbfs-file-id0 file) id0
					 (dbfs-file-id1 file) id1
					 (dbfs-file-id2 file) id2))
				 ;; Cache the file-id from the directory into the portal.
				 (setq dbfs::file-id (dbfs:lookup-file-id
						       (dbfs-file-id0 file)
						       (dbfs-file-id1 file)
						       (dbfs-file-id2 file)))))
			    (create
			     ;; The name does not exist; create a new one.
			     (multiple-value-bind (id0 id1 id2)
				 (dbfs::file-id-words dbfs::file-id)
			       (make-dbfs-file :name name-string
					       :parent dir
					       :author zl:user-id
					       :creation-date (get-universal-time)
					       :id0 id0
					       :id1 id1
					       :id2 id2)))
			    (error
			     (make-instance 'dbfs-file-not-found :pathname self)))))))))
	(if (typep result 'condition)
	    (error result)
	    result)))))

#| calls lookup-file-id (above) |#

(scl:defmethod (dbfs:invalid-file-id pathname-portal-mixin) (attempt &optional (error-p t))
  ;; This is called when the file-id has not yet been cached in the portal.
  ;; Try to lookup the pathname in the directory, caching the file-id in
  ;; the portal.  Signal an error if the name was not found.
  (lookup-file-id self :error error-p)
  (when (and error-p (null dbfs::file-id))
    (error 'dbfs:file-id-invalid :attempt attempt :portal self))
  dbfs::file-id)

(scl:defmethod (dbfs:nonextant-file pathname-portal-mixin) (&optional (error-p t))
  ;; This is called if the file specified by the file-id and
  ;; file-system-name of this portal doesn't exist (i.e. the cached
  ;; file-id is no longer valid and must be recached).  Check to see if
  ;; the name in the directory now maps to a new file-id, and if so, try
  ;; using it before signalling an error.
  (let ((old-id dbfs::file-id))
    ;; Get the most recent file-id in the directory.
    (lookup-file-id self :remap t :error error-p)
    (if (eq dbfs::file-id old-id)
	;; Didn't map to anything new.  This means that the name is in
	;; the directory, but the file just doesn't exist.  Signal the
	;; nonextant-file error.
	(when error-p
	  (error 'dbfs:nonextant-file :portal self))
	dbfs::file-id)))

(scl:defmethod (dbfs:create-file pathname-portal-mixin :before) (&key &allow-other-keys)
  ;; Have to map the name to the file-id in case we are superseding the old
  ;; file and the file-id has not been cached yet.
  (lookup-file-id self :error nil))

(scl:defmethod (dbfs:create-file pathname-portal-mixin :after) (&key &allow-other-keys)
  ;; Now that the file-id has been established, create the directory entry.
  (lookup-file-id self :create t))

(scl:defwhopper (dbfs:create-file pathname-portal-mixin) (&rest args)
  (let ((previously-extant (dbfs:file-extant-p self))
	(abort-p t))
    (unwind-protect
	(prog1
	  (lexpr-continue-whopper args)
	  (setf abort-p nil))
      (when (and abort-p (not previously-extant))
	(dbfs:with-transaction ()
	  (dbfs:destroy-file self :if-does-not-exist nil))))))

;;; Don't let anybody delete the dbfs-dir itself.  I'm not sure whether
;;; the dbfs-dir really ought to appear in the directory itself anyway;
;;; why did DanG do this?  -- DLW 7/18/88
(scl:defmethod (dbfs:destroy-file pathname-portal-mixin :before) (&rest ignore)
  (let ((dir-portal (lookup-directory-portal dbfs::file-system-name)))
    (when (eq dbfs::file-id (dbfs::portal-file-id dir-portal))
      (error "Attempt to delete the directory of the file system"))))

(scl:defmethod (dbfs:destroy-file pathname-portal-mixin :after) (&key &allow-other-keys)
  (let ((dir-portal (lookup-directory-portal dbfs::file-system-name))
	(directory (send self :directory))
	(name (send self :name)))
    (with-database (dir dir-portal)
      (with-transaction ()
	(let ((entity (lookup-dbfs-file name (lookup-directory directory))))
	  (when entity
	    (delete-entity entity)))))))

(defun lookup-dbfs-entity (name directory)
  (for-each ((entity dbfs-entity)
	     (:where (and (eq directory (dbfs-entity-parent entity))
			  (string-equal name (dbfs-entity-name entity)))))
    (return entity)))

(defun lookup-dbfs-directory (name parent)
  (for-each ((entity dbfs-directory)
	     (:where (and (eq parent (dbfs-entity-parent entity))
			  (string-equal name (dbfs-entity-name entity)))))
    (return entity)))

(defun lookup-dbfs-file (name parent)
  (for-each ((entity dbfs-file)
	     (:where (and (eq parent (dbfs-entity-parent entity))
			  (string-equal name (dbfs-entity-name entity)))))
    (return entity)))

(defun lookup-directory (directory-spec &optional (relative-parent nil))
  (declare (values entity printing-string))
  (let ((root-directory-entity (or relative-parent
				   (for-each ((root root-directory))
				     (return root)))))
    (when (eq directory-spec :root)
      (return-from lookup-directory
	(values root-directory-entity ">")))
    (let* ((bytes-needed (+ 1 (length directory-spec) (loop for s in directory-spec
							    sum (string-length s))))
	   (print-string (cl:make-string bytes-needed))
	   (i 1))
      (declare (sys:array-register print-string))
      (setf (aref print-string 0) #\>)
      (loop for parent = root-directory-entity then entity
	    for spec in directory-spec
	    for entity = (lookup-dbfs-entity spec parent)
	    while entity
	    do
	(let ((spec-length (string-length spec)))
	  (setf (subseq print-string i (+ i spec-length)) spec)
	  (incf i spec-length)
	  (setf (aref print-string i) #\>)
	  (incf i))
	    finally
	      (incf i)
	      (return (values entity print-string))))))


;;; Return the length of the file in pages, except be careful in case
;;; the file does not exist in the underlying DBFS.
(defun careful-file-page-length (pathname)
  (if (dbfs:file-extant-p pathname)
      (dbfs:file-page-length pathname)
      ;; While we might want to return something more expressive, the
      ;; :length-in-blocks field is basically defined to be either an
      ;; integer or nil, so we can't.
      nil))

;;; :noerror is handled by fs:directory-list.  :deleted can be ignored
;;; since there are no deleted files in a DBFS file system.  The
;;; extra-info referred to by :no-extra-info is just esoterica of LMFS,
;;; so we can ignore it too.  We have to handle :sorted.

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")#| this has to be a patch |#
0#|^^  I don't understand the above comment. JWatkins |#

(scl:defmethod (:directory-list fs:dbfs-pathname) (options)
  (with-database (database (lookup-directory-portal (send fs:host :name)))
    (with-transaction ()
      (cond ((eq fs:directory ':wild)
	     ;; Pathnames with directory :wild are manufactured by various old
	     ;; programs.  See, for example, :list-root in FSEdit.
	     (send self :directory-list
		   (send self :new-raw-directory '(:wild-inferiors))
		   options))
	    ((send self :wild-directory-p fs:directory)
	     (let ((all-dirs (send self :all-directories nil)))
	       (when (member :sorted options)
		 (setq all-dirs (sort all-dirs #'fs:pathname-lessp :key #'car)))
	       (cons '(())
		     (loop for (dir) in all-dirs
			   nconc (cdr (apply #'fs:directory-list
					     (send self :new-raw-directory
						   (send dir :raw-directory))
					     options))))))
	    (t
	     (let (results)
	       (multiple-value-bind (parent-entity printing-string)
		   (lookup-directory fs:directory)
		 (unless parent-entity
		   (error "Directory does not exist ~A" self))
		 (labels
		   ((cons-entry (f)
		      (let* ((ent-name (dbfs-entity-name f))
			     (directory-p (typep f 'dbfs-directory))
			     (pathname (fs:parse-pathname
					 (string-append (send (send self :host) :name) ":"
							printing-string ent-name))))
			(push (list pathname
				    :author (dbfs-entity-author f)
				    :creation-date (dbfs-entity-creation-date f)
				    :comment (unless directory-p
					       (file-comment f))
				    :directory directory-p
				    :length-in-blocks (unless directory-p
							(careful-file-page-length pathname)))
			      results))))
		   (cond ((eq fs:name :wild)
			  (for-each ((f dbfs-entity)
				     (:where (eq (dbfs-entity-parent f) parent-entity))
				     (:order-by (dbfs-entity-name f) ascending))
			    (cons-entry f)))
			 (t
			  (let ((wild-pos (string-search-char #\* fs:name)))
			    (cond ((null wild-pos)
				   (let ((entity  (lookup-dbfs-entity fs:name parent-entity)))
				     (when entity
				       (cons-entry entity))))
				  ((= wild-pos (1- (string-length fs:name)))
				   ;; foo* matching
				   (for-each ((f dbfs-entity)
					      (:where
						(and (eq (dbfs-entity-parent f) parent-entity)
						     (string-prefix (substring fs:name
									       0 wild-pos)
								    (dbfs-entity-name f)))))
				     (cons-entry f)))
				  (t
				   ;; brute force matching
				   (for-each ((f dbfs-entity)
					      (:where (eq (dbfs-entity-parent f)
							  parent-entity))
					      (:order-by (dbfs-entity-name f) ascending))
				     (if (fs:wildcard-match fs:name (dbfs-entity-name f))
					 (cons-entry f)))))))))
		 (push '(()) results))))))))

;;; :all-directories finds all of the directories in the file system
;;; that match the pattern in the directory component of the pathname
;;; argument.  It returns a list, with one element for each such
;;; directory; each element is a cons whose car is a pathname whose
;;; directory component represents the resulting directory.  The only
;;; meaningful option is :sorted.
(scl:defmethod (:all-directories fs:dbfs-pathname) (options)
  (let* ((dir (send self :raw-directory)))
    ;; Pathnames with directory :wild are manufactured by various old
    ;; programs.  See, for example, :list-root in FSEdit.
    (if (eq dir ':wild) (setq dir '(:wild-inferiors)))
    (let ((pathname (send self :new-pathname
			  :raw-directory dir	;so :UP-DIRECTORY-LEVEL works.
			  :name nil :type nil :version nil)))	;cleanliness
      ((lambda (answer) (if (member :sorted options)
			    (sort answer #'fs:pathname-lessp :key #'car)
			    answer))
       (if (and (listp dir)
		(eq (car (last dir)) :wild-inferiors))
	   (loop with new-p-as-d = (send pathname :up-directory-level)
		 ;; Expand possible wildness in part above final :wild-inferiors.
		 for match-dir in (if (send new-p-as-d :wild-p)
				      (mapcar #'car (send new-p-as-d :all-directories nil))
				      (list new-p-as-d))
		 collect (ncons match-dir)	;Guaranteed fully-instantiated...
		 nconc (loop for (subdir) in (send (send match-dir :down-directory-level :wild)
						   :all-directories nil)
			     ;; Recursion bottoms out when above :all-directories returns nil.
			     nconc (send (send subdir :down-directory-level :wild-inferiors)
					 :all-directories nil)))
	 
	   ;; Just ordinary, non-recursive wildness.  Maybe not even wild.
	   ;; Or recursive wildness not at the end.
	   (loop for (dir) in (cdr (fs:directory-list
				     (send pathname :directory-pathname-as-file)
				     :fast))
		 collect (ncons (send dir :pathname-as-directory))))))))


(defun prohibit-wildcards (pathname operation &optional wild-non-dirs-ok)
  (declare (dbg:error-reporter t))
  (let ((directory (send pathname :directory)))
    (when (or (and (not wild-non-dirs-ok)
		   (let ((name (send pathname :name)))
		     (or (eq name ':wild)
			 (and (stringp name) (string-search-char #\* name)))))
	      (eq directory ':wild)
	      (cond ((stringp directory) (string-search-char #\* directory))
		    ((null directory) nil)	;some other error, please
		    ((listp directory)
		     (loop for x in directory
			   thereis (or (member x '(:wild :wild-inferiors))
				       (and (stringp x) (string-search-char #\* x)))))))
      (error
	'dbfs-wildcard-not-allowed
	:pathname pathname
	:op operation
	:wild-non-dirs-ok wild-non-dirs-ok))))

(scl:defflavor dbfs-pseudoopening ()
	   (si:file-stream-mixin si:property-list-mixin))

(scl:defmethod (:truename dbfs-pseudoopening) ()
  (send self ':get ':truename))

(scl:defmethod (:qfaslp dbfs-pseudoopening) ()
  (send self ':get ':qfaslp))

(scl:defmethod (:length dbfs-pseudoopening) ()
  (send self ':get ':length))

(scl:defmethod (:close dbfs-pseudoopening) (&optional ignore)
  nil)

(scl:defmethod (:create-directory fs:dbfs-file-access-path) (pathname)
  (prohibit-wildcards pathname "create a directory" t)
  (let ((dir-list (send pathname :directory)))
    (when (eq :root dir-list)
      (error "Trying to create root directory.  Maybe you forgot a trailing '>' delimiter."))
    (with-database (database (lookup-directory-portal (send fs:host :name)))
      (with-transaction ()
	(loop for parent = (for-each ((root root-directory)) (return root)) then ent
	      for ent-name in dir-list
	      for ent = (or (lookup-dbfs-entity ent-name parent)
			    (make-dbfs-directory :name ent-name
						 :parent parent
						 :author zl:user-id
						 :creation-date (get-universal-time))))))))

(scl:defmethod (:complete-string fs:dbfs-file-access-path) (default string options)
  (declare (values string success) (ignore options))
  (block complete
    (with-database (database (lookup-directory-portal (send fs:host :name)))
      (with-transaction ()
	(let* ((pathname (condition-case ()
			      (fs:parse-pathname string nil default)
			    (fs:pathname-error
			      (return-from complete
				(values string nil)))))
	       (merged (fs:merge-pathnames pathname default))
	       (dir-ent (lookup-directory (send merged :directory))))
	  (unless dir-ent
	    (error 'dbfs-directory-not-found :pathname pathname))
	  (let ((name (send merged :name)))
	    ;; Use something better when we get the semantics of
	    ;; string-prefix-is worked out with case-insensitive indexes
	    (multiple-value-bind (completed-string success)
		(dw:suggestion-completer (name)
		  (for-each ((f dbfs-entity) (:where (eq dir-ent (dbfs-entity-parent f))))
		    (dw:suggest (dbfs-entity-name f))))
	      (values (string-append (send merged :string-for-directory) completed-string)
		      success))))))))

#| calls lookup-directory among other things |#

(scl:defmethod (:rename fs:dbfs-file-access-path) (old-pathname new-pathname)
  (prohibit-wildcards old-pathname "rename")
  (prohibit-wildcards new-pathname "rename")
  (unless (and (typep new-pathname 'fs:dbfs-pathname)
	       (eq (send old-pathname :host) (send new-pathname :host)))
    (error 'fs:rename-across-hosts :pathname old-pathname :new-pathname new-pathname))
  (with-database (db (lookup-directory-portal (send fs:host :name)))
    (with-transaction ()
      (let ((old-directory (lookup-directory (send old-pathname :directory)))
	    (new-directory (lookup-directory (send new-pathname :directory)))
	    (old-name (send old-pathname :name))
	    (new-name (send new-pathname :name)))
	(unless new-directory
	  (error 'dbfs-directory-not-found :pathname new-pathname))
	(unless old-directory
	  (error 'dbfs-directory-not-found :pathname old-pathname))
	(let ((file-ent (lookup-dbfs-entity old-name old-directory)))
	  (unless file-ent
	    (error 'dbfs-file-not-found :pathname old-pathname))
	  (when (lookup-dbfs-entity new-name new-directory)
	    (error 'dbfs-file-already-exists :pathname new-pathname))
	  (fs::increment-rename-delete-tick self)
	  (unless (eq old-directory new-directory)
	    (setf (dbfs-entity-parent file-ent) new-directory))
	  (unless (string-equal old-name new-name)
	    (setf (dbfs-entity-name file-ent) new-name)))))))

(scl:defmethod (:delete fs:dbfs-file-access-path) (pathname)
  (prohibit-wildcards pathname "delete")
  (with-database (db (lookup-directory-portal (send fs:host :name)))
    (with-transaction ()
      (let ((directory (lookup-directory (send pathname :directory)))
	    (name (send pathname :name)))
	(unless directory
	  (error 'dbfs-directory-not-found :pathname pathname))
	(let ((file-ent (lookup-dbfs-entity name directory)))
	  (unless file-ent
	    (error 'dbfs-file-not-found :pathname pathname))
	  (fs::increment-rename-delete-tick self)
	  (ecase (type-of file-ent)
	    (dbfs-file
	      ;; This deletes the entity as well
	      (dbfs:destroy-file pathname :if-does-not-exist nil))
	    (dbfs-directory
	      ;; I guess directory deletion should act like LMFS deletion does (that
	      ;; is, only empty directories can be deleted) and not like FEPFS deletion
	      ;; does (where deletion recurses, deleting all inferior files) since
	      ;; the LMFS philosophy is safer, although it makes deletion of a directory
	      ;; tree much more painful.
	      (for-each ((ent dbfs-entity) (:where (eq file-ent (dbfs-entity-parent ent))))
		;; Found an inferior entity
		(error 'dbfs-directory-not-empty :pathname pathname))
	      (delete-entity file-ent))))))))

(scl:defmethod (:properties fs:dbfs-file-access-path) (pathname)
  (prohibit-wildcards pathname "properties")
  (with-database (db (lookup-directory-portal (send fs:host :name)))
    (with-transaction ()
      (let ((directory (lookup-directory (send pathname :directory)))
	    (name (send pathname :name)))
	(unless directory
	  (error 'dbfs-directory-not-found :pathname pathname))
	(let ((file-ent (lookup-dbfs-entity name directory)))
	  (unless file-ent
	    (error 'dbfs-file-not-found :pathname pathname))
	  (let ((directory-p (typep file-ent 'dbfs-directory)))
	    (list pathname
		  :author (dbfs-entity-author file-ent)
		  :creation-date (dbfs-entity-creation-date file-ent)
		  :comment (unless directory-p
			     (file-comment file-ent))
		  :directory directory-p
		  :length-in-blocks (unless directory-p
				      (careful-file-page-length pathname)))))))))

;;; Return the full comment text for a file.  file-end should be a file
;;; entity, not a directory entity, and the caller must be within a
;;; transaction.
(defun file-comment (file-ent)
  (let ((id-string (format nil "ID (~D ~D ~D)"
			   (dbfs-file-id0 file-ent)
			   (dbfs-file-id1 file-ent)
			   (dbfs-file-id2 file-ent)))
	(comment-field (dbfs-entity-comment file-ent)))
    (if comment-field
	(string-append id-string ", " comment-field)
	id-string)))
(scl:defmethod (:change-properties fs:dbfs-file-access-path) (pathname &rest properties)
  (prohibit-wildcards pathname "change-properties")
  (with-database (db (lookup-directory-portal (send fs:host :name)))
    (with-transaction ()
      (let ((directory (lookup-directory (send pathname :directory)))
	    (name (send pathname :name)))
	(unless directory
	  (error 'dbfs-directory-not-found :pathname pathname))
	(let ((file-ent (lookup-dbfs-entity name directory)))
	  (unless file-ent
	    (error 'dbfs-file-not-found :pathname pathname))
	  (let ((directory-p (typep file-ent 'dbfs-directory)))
	    (loop for (property value) on properties by #'cddr do
	      (case property
		(:author (setf (dbfs-entity-author file-ent) value))
		(:creation-date (setf (dbfs-entity-creation-date file-ent) value))
		(:comment
		  (when directory-p
		    (error "The :COMMENT field is not meaningful; ~S is a directory"
			   pathname))
		  (setf (dbfs-entity-comment file-ent) value))
		(otherwise
		  (error "The property ~S cannot be set, for file ~S"
			 property pathname))))))))))

(scl:defmethod (fs:file-access-path-open fs:dbfs-file-access-path)
	       (pathname path &rest options)
  (declare (ignore path))
  (prohibit-wildcards pathname "open" (eq (getf options :direction) :probe-directory))
  (let ((direction (getf options :direction)))
    (unless (member direction '(:probe :probe-link :probe-directory))
      (error 'dbfs-open-not-probe :pathname pathname))
    (condition-case (err)
	 (with-database (db fs:portal)
	   (with-transaction ()
	     (let ((directory (lookup-directory (send pathname :directory)))
		   (name (send pathname :name)))
	       (cond ((and directory
			   (lookup-dbfs-entity name directory))
		      ;; The file exists.
		      (flavor:make-instance 'dbfs-pseudoopening
				     :pathname pathname
				     :property-list (list :truename pathname)))
		     ((eq (getf options :if-does-not-exist) :error)
		      (error 'dbfs-file-not-found :pathname pathname))
		     (t nil)))))
       (dbfs:nonextant-file
	 (cond ((eq fs:portal (dbfs::file-error-portal err))
		;; The DBFS-DIR itself does not exist.  This can happen after
		;; a DESTROY-CONTENTS-OF-ENTIRE-DBFS.
		nil)
	       (t
		(error "Unexpected nonextant-file-error: ~S" (send err :report-string))))))))

(scl:defmethod (:reset fs:dbfs-file-access-path) ()
  (setq fs:rename-delete nil))

(scl:defmethod (fs:file-access-path-login fs:dbfs-file-access-path) (login-p &key force-password)
  (declare (ignore login-p force-password)))

fs:
(defmethod (rename-delete-tick-value dbfs-file-access-path) ()
  (statice:with-database (database portal)
    (statice:with-transaction ()
      (unless rename-delete
	(upgrade-for-rename-delete self))
      (condition-case (error)
	   (dbfs-dir::rename-delete-tick rename-delete)
	 (statice-model:entity-handle-deleted
	   (setq rename-delete nil)
	   (upgrade-for-rename-delete self)
	   (dbfs-dir::rename-delete-tick rename-delete))))))

;;; Call this to increment the global rename-delete tick for this dbfs
;;; directory.  This function must be called from inside a transaction,
;;; with the dbfs-dir as the current database.
fs:
(defmethod (increment-rename-delete-tick dbfs-file-access-path) ()
  (unless rename-delete
    (upgrade-for-rename-delete self))
  (incf (dbfs-dir::rename-delete-tick rename-delete)))

fs:
(defmethod (upgrade-for-rename-delete dbfs-file-access-path) ()
  (statice:for-each ((rd dbfs-dir::rename-delete))
    (setq rename-delete rd))
  (unless rename-delete
    (setq rename-delete (dbfs-dir::make-rename-delete :tick 1))))

(scl:defwhopper (dbfs:destroy-file dbfs-dir:pathname-portal-mixin) (&rest args)
  (lexpr-continue-whopper args)
  (setf dbfs:file-id nil))


(scl:compile-flavor-methods fs:dbfs-file-access-path fs:dbfs-pathname
			 pathname-portal-mixin) 
		      


