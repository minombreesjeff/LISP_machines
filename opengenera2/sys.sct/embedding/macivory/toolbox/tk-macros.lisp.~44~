;;; -*- Mode: LISP; Syntax: Common-lisp; Package: MAC-TOOLBOX; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This is for use in this file.  It means to try to unwind-protect-cleanup,
;;; but allow you to abort if, for example, the RPC link stops working.
;;; Imagine that you can always reboot your Mac if necessary to clean up.
(defmacro D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")unwind-protect-try0 (protected-form &rest cleanup-forms)
  `(unwind-protect
       ,protected-form
     (sys:with-aborts-enabled (unwind-protect) ,@cleanup-forms)))

;;; Use cconstant-case and cconstant-ecase when the selector is a
;;; number defined by C.
(defmacro 1cconstant-case0 (test-object &body clauses)
  `(select ,test-object
     ,@(mtb::domap 'list ((clause clauses))
	 (destructuring-bind (keys &rest code) clause
	   (cond ((eql keys 'otherwise)
		  clause)
		 (T
		  (when (atom keys) (setq keys (list keys)))
		  `(,(mtb::domap 'list ((key keys)) `(cconstant ,key))
		    ,@code)))))))

(defmacro 1cconstant-ecase0 (test-object &body clauses)
  `(cconstant-case ,test-object
     ,@clauses
     (otherwise (error "The value of ~s, ~s, was not among the cconstants expected: ~s"
		       ',test-object ,test-object
		       ',(loop for clause in clauses
			       when (consp (first clause)) append (first clause)
			       else collect (first clause))))))

(eval-when (compile eval load)
;; Checking-subroutine for macros here
(defun 1check-handle/ptr0 (handle ptr)
  (when (and handle ptr)
    (error "You cannot supply both :HANDLE ~s and :PTR ~s" handle ptr))
  (unless (or handle ptr)
    (error "You must supply one of :HANDLE or :PTR")))
)

;;; saves/restores QuickDraw's port around the body.
(defmacro 1with-qd-port0 ((new-port) &body body)
  `(with-qd-port-1
     (sys:named-lambda with-qd-port () ,@body)
     ,new-port))

(defun 1with-qd-port-10 (continuation new-port)
  (declare (sys:downward-funarg continuation))
  (let ((old-port (_getport)))
    (unwind-protect-try
	(progn
	  (_setport new-port)
	  (funcall continuation))
      (when old-port
	(_setport old-port)))))

;;; Allocate a Mac window, binding a Lisp variable to its WindowPtr.
;;; :edges are Lispm order (left,top,right,bottom)
;;; :shape is one of :document (the default), :alert-box, :plain-box, :plain-box-with-shadow,
;;;    :document-nogrow, or :rounded-corner; or a list (:rounded-corner (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")radius0) or
;;;    (:custom 2ProcPtr0).
(defmacro 1with-window0 ((var &rest options) &body body)
  (declare (arglist (var &key edges title visible shape behind goawayflag refcon)
		    &body body))
  `(with-window-1
     (sys:named-lambda with-window (,var) ,@body)
     ,@options))

(defvar 1*untitled-window-count*0 0)

(defun 1with-window-10 (continuation &key edges title (visible nil visible-p)
		      shape behind goawayflag refcon)
  (declare (sys:downward-funarg continuation))
  (destructuring-bind (left top right bottom) (or edges '(5 38 470 370))
    (stack-let ((edge-rect (make-rect :left left :top top :right right :bottom bottom)))
      (when (null title) (setq title "Untitled"))
      (let ((title (or title (format nil "Untitled-~d" (incf *untitled-window-count*))))
	    (visible (if visible-p visible T))
	    (procid
	      (etypecase shape
		(symbol
		  (ecase shape
		    ((:document nil) (cconstant documentProc))
		    (:alert-box (cconstant dBoxProc))
		    (:plain-box (cconstant plainDBox))
		    (:plain-box-with-shadow (cconstant altDBoxProc))
		    (:document-nogrow (cconstant noGrowDocProc))
		    (:rounded-corner (cconstant rDocProc))))
		(cons
		  (destructuring-bind (key option) shape
		    (ecase key
		      (:rounded-corner
			(+ (cconstant rDocProc)
			   (ecase option
			     (16 0) (4 1) (6 2) (8 3) (10 4) (12 5) (20 6) (24 7))))
		      (:custom option))))))
	    (behind
	      (case behind
		((:none nil) -1)
		(:all 0)
		(otherwise
		  (check-type behind number)	;WindowPtr ---make window structure someday
		  behind))))
	(when (null refcon) (setq refcon 0))
	(check-type refcon number)
	(let (w)
	  (unwind-protect-try
	      (progn
		(setq w (_newwindow edge-rect (or title "")
				    visible procid behind goawayflag refcon))
		(funcall continuation w))
	    (when w (_disposewindow w))))))))

;;; Execute body with handle locked.  You can also pass in a computed boolean
;;; which if false means don't bother to lock.
(defmacro 1with-handle-locked0 ((handle &optional (lock 'T)) &body body)
  `(with-handle-locked-1
     (sys:named-lambda with-handle-locked () ,@body)
     ,handle ,lock))
(defun 1with-handle-locked-10 (continuation handle lock)
  (declare (sys:downward-funarg continuation))
  (let ((managed-to-lock nil))
    (if lock
	(unwind-protect-try
	  (progn
	    (_HLock handle)
	    ;; If it blew out trying to lock, don't blow out trying to unlock
	    (setq managed-to-lock T)
	    (funcall continuation))
	  (when managed-to-lock (_HUnlock handle)))
	(funcall continuation))))

;;; with-resource-handle and with-resource are similar in that the Mac gets
;;; a specified resource.  with-resource-handle binds a lisp var to the
;;; handle, while with-resource brings the resource contents over to Lisp
;;; and binds the lisp variable to the structure.
;;; resid-or-name is (unsigned-byte 16) or string.
;;; If lock, lock the resource around the body.
;;; If file, open and use it as resource file around the body.
;;; If sole-file, open and use it as resource file around the body, but look only
;;;   within that file
(defmacro 1with-resource-handle0 ((var restype resid-or-name &rest options) &body body)
  (declare (arglist (var restype resid-or-name &key lock file sole-file (direction :io))
		    &body body))
  `(with-resource-1
     (sys:named-lambda with-resource-handle (,var) ,@body)
     ,restype ,resid-or-name
     :read-data nil
     ,@options))

(defmacro 1with-resource0 ((var restype resid-or-name &rest options) &body body)
  (declare (arglist (var restype resid-or-name &key lock file sole-file (direction :io))
		    &body body))
  `(with-resource-1
     (sys:named-lambda with-resource (,var) ,@body)
     ,restype ,resid-or-name
     :read-data T
     ,@options))

(defun 1with-resource-10 (continuation restype resid-or-name
			&key read-data lock file sole-file (direction :io))
  (declare (sys:downward-funarg continuation))
  (labels ((doit ()
	     (let ((handle
		     (funcall (if sole-file
				  (etypecase resid-or-name
				    (number (lambda (type id)
					      (_get1resource-file type id sole-file)))
				    (string (lambda (type name)
					      (_get1namedresource-file type name sole-file))))
				  (etypecase resid-or-name
				    (number #'_getresource)
				    (string #'_getnamedresource)))
			      restype resid-or-name)))
	       (cond ((zerop handle)
		      (error "Resource type ~s isn't in any open resource file"
				 restype))
		     (T
		      (if read-data
			  (doit1 handle)
			  (with-handle-locked (handle lock)
			    (funcall continuation handle)))))))
	   (doit1 (handle)
	     (let ((len (_gethandlesize handle)))
	       (stack-let ((data (make-array len :element-type '(unsigned-byte 8)
					     :fill-pointer 0)))
		 (funcall continuation
			  (_read-opaque-bytes-from-handle handle len data))))))
    (unless file (setq file sole-file))
    (typecase file
      ((or null integer) (doit))
      (otherwise
	(let ((permission (ecase direction
			    ((:input nil) (cconstant fsRdPerm))
			    ((:output :io) (cconstant fsRdWrPerm)))))
	  (multiple-value-bind (resrefnum newly-opened)
	      (_OpenRFPerm-no-use file 0 permission)
	    (when sole-file (setq sole-file resrefnum))
	    (unwind-protect-try
		(doit)
	      (when newly-opened
		(_closeresfile resrefnum)))))))))

;;; Bring a structure in from the Mac and bind a Lisp variable to it.
;;; You say what the structure type is (not evaluated) and whether
;;; it's a Ptr or Handle.  Explicit NIL for structure type means
;;; just opaque bytes, with size determined from the Mac side.
(defmacro 1with-mac-struct0 ((lisp-var octet-structure-type &rest options &key handle ptr)
			   &body body)
  (check-handle/ptr handle ptr)
  `(with-mac-struct-1
     (sys:named-lambda with-mac-struct (,lisp-var) ,@body)
     ,(and octet-structure-type `(octet-structure-total-size (,octet-structure-type .x. 0)))
     ,@options))

(defun 1with-mac-struct-10 (continuation size &key handle ptr)
  (when (null size)
    (setq size (cond (handle (_gethandlesize handle))
		     (ptr (_getptrsize ptr))
		     (T (error "Neither Handle nor Ptr")))))
  (stack-let ((struct (make-array size :element-type '(unsigned-byte 8) :fill-pointer 0)))
    (funcall continuation
	     (cond (handle
		    (_read-opaque-bytes-from-handle handle size struct))
		   (ptr
		    (_read-opaque-bytes-from-pointer ptr size struct))
		   (T (error "Both :HANDLE and :PTR are null"))))))

;;; Allocate a data structure on the Mac for the duration of 2body0, binding
;;; a Lisp variable to its Ptr or Handle.  Its size is 0, or 2size0, or
;;; length of 2initial-contents0, which is downloaded into the Handle or Ptr.
;;; 
(defmacro 1with-mac-temp0 ((lisp-var &rest options &key handle ptr size initial-contents)
			 &body body)
  (ignore size initial-contents)
  (check-handle/ptr handle ptr)
  `(with-mac-temp-1
     (named-lambda with-mac-temp (,lisp-var) ,@body)
     ,@options))

(defun 1with-mac-temp-10 (continuation &key handle ptr size initial-contents)
  (check-type initial-contents (or null (vector (unsigned-byte 8))))
  (when (null size)
    ;; works for initial-contents = NIL!
    (setq size (length initial-contents)))
  (multiple-value-bind (constructor destructor writer)
      (cond (handle
	     (values #'_newhandle #'_disposhandle #'_write-opaque-bytes-into-handle))
	    (ptr
	     (values #'_newptr #'_disposptr #'_write-opaque-bytes-into-pointer))
	    (T (error "neither HANDLE nor PTR")))
    (let (h)
      (unwind-protect-try
	(progn
	  (setq h (funcall constructor size))
	  (when initial-contents
	    (funcall writer h size initial-contents))
	  (funcall continuation h))
	(when h
	  (condition-case ()
	       (funcall destructor h)
	     ;; You get memAZErr when you have a handle and do AddResource, ReleaseResource,
	     ;; and then try to DisposHandle
	     ((mac-os-error-memazerr mac-os-error-memwzerr) )))))))

;;; Bind the state of ResLoad to 2new
0(defmacro 1with-resload0 ((new) &body body)
  `(with-resload-1 (named-lambda with-resload () ,@body) ,new))
(defun 1with-resload-10 (continuation new)
  (declare (sys:downward-funarg continuation))
  (let ((current-resload (_currentresload)))
    (unwind-protect-try
      (progn
	(_setresload new)
	(funcall continuation))
    (_setresload current-resload))))

;;; Do UseResFile around the body, restoring previous value
(defmacro 1using-resfile0 ((refnum) &body body)
  `(using-resfile-1 ,refnum (named-lambda using-resfile () ,@body)))

(defun 1using-resfile-10 (refnum continuation)
  (declare (sys:downward-funarg continuation))
  (let ((old-resfile (_curresfile)))
    (if (eql old-resfile refnum)
	(funcall continuation)
	(unwind-protect-try
	  (progn
	    (_useresfile refnum)
	    (funcall continuation))
	  (_useresfile old-resfile)))))

;;; Open one or more resource files for body, binding Lisp variables to their refnums.
;;; (with-resfiles ((var name &optional direction) ...) body)
;;; where 2direction0 is :input (the default), or one of the synonyms :output, :io
(defmacro 1with-resfiles0 (vars-and-filenames &body body)
  (let (vars filenames-and-directions)
    (dolist (vf vars-and-filenames)
      (destructuring-bind (var filename &optional direction) vf
	(push var vars)
	(push filename filenames-and-directions)
	(push direction filenames-and-directions)))
    (setq vars (nreverse vars)
	  filenames-and-directions (nreverse filenames-and-directions))
    `(with-resfiles-1
       (named-lambda with-resfiles ,vars ,@body)
       ,@filenames-and-directions)))

(defun 1with-resfiles-10 (continuation &rest filenames-and-directions)
  (declare (sys:downward-funarg continuation))
  (let ((nfiles (floor (length filenames-and-directions) 2)))
    (stack-let ((refnums-to-use (make-array nfiles
					    :fill-pointer 0
					    :type 'sys:art-q-list))
		(refnums-to-close (make-array nfiles :fill-pointer 0)))
      (unwind-protect-try
	(progn
	  (loop for (filename direction) on filenames-and-directions by #'cddr do
	    (with-mac-os-error-args (rpc-file-error :pathname filename)
	      (setq filename (send filename :string-for-host))
	      (let* ((writable (ecase direction
				 ((:input nil) nil)
				 ((:output :io) T)))
		     (permission (if writable (cconstant fsRdWrPerm) (cconstant fsRdPerm)))
		     (refnum nil)
		     (newly-opened nil))
		(unwind-protect-try
		    (let ((first-time T))
		      (with-restart ()
			(condition-case-if (and first-time writable) ()
			     (multiple-value-setq (refnum newly-opened)
			       (_OpenRFPerm-no-use filename 0 permission))
			   (fs:file-not-found
			     (_createresfile filename)
			     (setq first-time nil)
			     (restart))))
		      (sys:without-aborts ("Storing refnums")
			(vector-push-extend refnum refnums-to-use)
			(when newly-opened
			  (vector-push-extend refnum refnums-to-close))
			(setq refnum nil)))
		  (when refnum (_closeresfile refnum))))))
	  (apply continuation (g-l-p refnums-to-use)))
	(domap () ((refnum refnums-to-close))
	  (_closeresfile refnum))))))

;;; Alist from RPC transport agent to scratch resource file reference number
(si:defvar-resettable 1*scratch-resfiles*0 nil)

;;; Do UseResFile of the scratch resource file around the body, restoring previous value
(defmacro 1using-scratch-resfile0 (() &body body)
  `(using-resfile-1 (scratch-resfile-refnum)
		    (named-lambda using-scratch-resfile () ,@body)))

(defun 1scratch-resfile-refnum0 ()
  ;; Create a resource file to hold scratch resources if we don't have one already.
  ;; To make the name unique among running MultiFinder applications, use the address
  ;; of the application heap.  This will probably break in virtual-memory MacOS.
  (or (cdr (assoc *default-transport-agent* *scratch-resfiles*))
      (let ((name (multiple-value-bind (volume directories vrefnum dir-id)
		      (get-blessed-volume-and-folder)
		    (ignore-errors		;create folder in case it doesn't exist
		      (let ((string (make-str255 nil t)))
			(format string "~A:~{~A:~}Ivory:Scratch"
				volume directories)
			(_PBDirCreate string vrefnum 0 dir-id)))
		    (format nil "~A:~{~A:~}Ivory:Scratch:scratch-resfile.~D"
			    volume directories (_ApplicZone)))))
	(ignore-errors (_FSDelete name 0))	;discard any obsolete file
	(_Create name 0 "IVRY" "rsrc")		;create the empty file
	(_CreateResFile name)			;initialize the resource map
	(let ((refnum (_OpenRFPerm name 0 (cconstant fsRdWrPerm))))
	  (push (cons *default-transport-agent* refnum) *scratch-resfiles*)
	  refnum))))

;; res-id can be nil to generate a unique ID
(defun 1download-resource0 (res-type res-name res-id res-attr data)
  (declare (values handle res-id))
  ;; Generate a unique, non-system-reserved res-id if requested
  (unless res-id
    (loop doing (setq res-id (_UniqueID res-type))
	  until (> res-id 127)))
  ;; Copy the data to host memory and insert it into the resource file
  ;; We wish we could avoid updating the file, since it is only temporary,
  ;; but if the resource is purgeable, the stupid memory manager never
  ;; writes it out, and when it's reloaded we would lose.
  (using-scratch-resfile ()
    (let ((handle (_NewHandle (length data))))
      (_write-opaque-bytes-into-handle handle (length data) data)
      (_AddResource handle res-type res-id res-name)
      (when (logtest (cconstant resPurgeable) res-attr)
	(_WriteResource handle))
      (_SetResAttrs handle res-attr)
      (when (logtest (cconstant resLocked) res-attr)
	(_HLock handle))
      (when (logtest (cconstant resPurgeable) res-attr)
	(_HPurge handle))
      (values handle res-id))))

;;; Iterate over restypes in one resource file (refnum) or all resource files (:all)
(defmacro 1do-restypes0 ((type-var refnum-or-all) &body body)
  `(do-restypes-1 (named-lambda do-restypes (,type-var) ,@body) ,refnum-or-all))

(defun 1do-restypes-10 (continuation refnum-or-all)
  (declare (sys:downward-funarg continuation))
  (etypecase refnum-or-all
    (integer 
      (dotimes (j (_count1types-file refnum-or-all))
	(funcall continuation (_get1indtype-file (1+ j) refnum-or-all))))
    ((member :all)
     (dotimes (j (_counttypes))
       (funcall continuation (_getindtype (1+ j)))))))

;;; Maybe I could think of a better name
;;; Iterate over resources of a given type, receiving a resource handle, id, and name.
;;; refnum-or-all is as in do-restypes; include :load T if you want resload
(defmacro 1do-rsrcs0 ((handle-var id-var name-var) (restype refnum-or-all &key load) &body body)
  `(do-rsrcs-1
     (named-lambda do-rsrcs (,handle-var ,id-var ,name-var) ,@body)
     ,restype ,refnum-or-all :load ,load))

(defun 1do-rsrcs-10 (continuation restype refnum-or-all &key load)
  (declare (sys:downward-funarg continuation))
  (labels ((doit (counter getter)
	     (let ((n-of-that-type (funcall counter restype)))
	       (with-resload (load)
		 (dotimes (j n-of-that-type)
		   (let ((h (funcall getter restype (1+ j))))
		     (with-str255 (name)
		       (multiple-value-bind (id ignore name) (_getresinfo h name)
			 (funcall continuation h id name)))))))))
    (etypecase refnum-or-all
      (integer
	(doit (lambda (type) (_Count1Resources-file type refnum-or-all))
	      (lambda (type index) (_Get1IndResource-file type index refnum-or-all))))
      ((member :all)
       (doit #'_countresources #'_getindresource)))))

;;; I guess this is mainly for debugging.  What is does is left as an exercise for the reader.
(defun 1describe-resource-handle0 (h)
  (condition-case ()
       (with-str255 (name)
	 (multiple-value-bind (id type name)
	     (_getresinfo h name)
	   (let ((attrs (_getresattrs h)))
	     (format T "~&Rsrc handle ~d, id ~d, type ~s, name ~s, attrs ~s, home refnum ~d"
		     h id type name
		     (let ((result ()))
		       (loop with n = (ldb (byte 8 0) attrs)
			     for (bit type) in '((1 "dirty")
						 (2 "preload")
						 (3 "protected")
						 (4 "locked")
						 (5 "purgeable")
						 (6 "sysheap"))
			     do
			 (when (ldb-test (byte 1 bit) n)
			   (push type result)
			   (setf (ldb-test (byte 1 bit) n) nil))
			     finally (when ( n 0) (push n result)))
		       (or (nreverse result) "none"))
		     (_homeresfile h)))))
     (macintosh-internals::mac-os-error-resNotFound
       (format T "~&Handle ~d is not a resource handle" h))))

(define-octet-structure (1resmap-stuff0 :access-type :byte-swapped-8)
  (header (vector cardinal-8 16))
  (next-handle cardinal-32)
  (refnum cardinal-16)
  (attrs cardinal-16)
  (offset-to-type-list cardinal-16)
  (offset-to-name-list cardinal-16))

(defun 1show-resfiles0 ()
  (let* ((topmaphndl #xa50)
	 (handle (_ptrfromhandle topmaphndl))
	 (current (_curresfile)))
    (loop
      (when (zerop handle) (return))
      (with-mac-struct (resmap resmap-stuff :handle handle)
	(let ((refnum (resmap-stuff-refnum resmap 0))
	      (next-handle (resmap-stuff-next-handle resmap 0)))
	  (stack-let ((fcb (make-fcbpbrec))
		      (name (make-str255)))
	    (_PBGetFCBInfo fcb name 0 refnum 0)
	    (format T "~&~a refnum ~4d (~a)"
		    (if (eql refnum current) "*" "  ")
		    refnum name))
	  (setq handle next-handle))))))

;;; Map over the elements in a Mac os queue
(defmacro 1map-over-mac-queue-elements0 ((element-var octet-structure-type queue-hdr-pointer)
				       &body body)
  `(with-mac-struct (qhdr qhdr :ptr ,queue-hdr-pointer)
     (loop with queue-next = (qhdr-qhead qhdr 0)
	   until (zerop queue-next) do
       (with-mac-struct (,element-var ,octet-structure-type :ptr queue-next)
	 ;;; Wow, just like C programming!
	 (setf queue-next (qelem-qlink ,element-var 0))
	 ,@body))))

#| Moved to file-formats.lisp in system macintosh-internals for MMcM serial file transfer
   stuff -- Kalman

(define-octet-structure-field-type 1pascal-string-640 nil (array index)
           :size
           64
           :data
           `(pascal-string-64-from-subarray ,array ,index))

(defun 1pascal-string-64-from-subarray0 (array index)
  (let ((len (aref array index)))
    (assert (< len 64))
    (let ((result (make-string len)))
      (dotimes (j len )
	(setf (aref result j) (code-char (aref array (+ j index 1)))))
      result)))

(defun 1set-pascal-string-64-from-subarray0 (array index value)
  (setq value (string value))
  (check-type value (vector string-char))
  (let ((len (length value)))
    (assert (< len 64))
    (setf (aref array index) len)
    (dotimes (j len) (setf (aref array (+ j index 1)) (char-code (aref value j)))))
  value)

(defsetf pascal-string-64-from-subarray set-pascal-string-64-from-subarray)

|#

;; Like with-open-file, except 
(defmacro 1with-open-refnum0 ((var pathn &rest options) &body body)
  (declare (arglist (var pathn &key vrefnum dirid permission resource-fork) &body body))
  `(with-open-refnum-1
     (named-lambda with-open-refnum (,var) ,@body)
     ,pathn ,@options))

(defun 1with-open-refnum-10 (continuation pathname
			   &key (vrefnum 0) (dirid 0)
			   (permission (cconstant fsRdPerm))
			   resource-fork)
  (declare (sys:downward-funarg continuation))
  (setq pathname (pathname pathname))
  (with-mac-os-error-args (fs:file-error :pathname pathname)
    (let ((refnum nil))
      (unwind-protect-try
	(progn
	  (setq refnum (funcall (if resource-fork #'_pbhopenrf #'_pbhopen)
				(send pathname :string-for-host)
				vrefnum permission dirid))
	  (funcall continuation refnum))
	(when refnum (_fsclose refnum))))))

(defmacro 1with-pict-from-file0 ((handle-var rect &rest options)
			       &body body)
  (declare (arglist (handle-var rect &key pathname refnum (temporary T)) &body body))
  `(with-pict-from-file-1
     (named-lambda with-pict-from-file (,handle-var ,rect) ,@body)
     ,@options))

(defun 1with-pict-from-file-10 (continuation &key pathname refnum (temporary T))
  (declare (sys:downward-funarg continuation))
  (labels ((have-pathname (pn)
	     (with-open-refnum (rn pn)
	       (have-refnum rn)))
	   (have-refnum (rn)
	     (let ((len (- (_geteof refnum) 512)))
	       (if temporary
		   (with-mac-temp (pict :handle t :size len)
		     (have-handle pict rn len))
		   (let ((pict (_newhandle len)))
		     (have-handle pict rn len)))))
	   (have-handle (pict rn len)
	     (_setfpos rn (cconstant fsFromStart) 512)
	     (let ((err (with-handle-locked (pict)
			  (_fsread-remote rn (_ptrfromhandle pict) len))))
	       (unless (zerop err)
		 (signal-mac-os-error err)))
	     (let ((pict-header-size (octet-structure-total-size (picture .x. 0))))
	       (stack-let ((pict-header
			     (make-array pict-header-size
					 :element-type '(unsigned-byte 8)
					 :fill-pointer 0)))
		 (_read-opaque-bytes-from-handle pict pict-header-size pict-header)
		 (let ((pict-rect (picture-picframe pict-header 0)))
		   (funcall continuation pict pict-rect))))))
    (cond (refnum (have-refnum refnum))
	  (pathname (have-pathname pathname))
	  (T (error "Must have either :refnum or :pathname")))))

(macintosh-internals::DEFINE-MAC-STRUCTURE-AND-FIELD-TYPE (1ezSFREPLY
0							    :EXPORT (:STRUCTURE-NAME :ACCESSORS :CONSTRUCTOR))
  (GOOD (boolean CHAR))
  (COPY CHAR)
  (FTYPE macintosh-internals::ostype)
  (VREFNUM macintosh-internals::short)
  (VERSION macintosh-internals::short)
  (FNAME pascal-string-64))

(defun 1sftypelist-from-strings0 (types)
  (let ((result (make-sequence 'vector 4 :initial-element 0)))
    (map-into result
	      (lambda (string)
		(check-type string (vector string-char 4))
		(stack-let* ((reversable-string
			       (make-array 4 :element-type 'string-char
					   :initial-contents string))
			     (fortran-equivalence
			       (make-array 1 :element-type 'fixnum
					   :displaced-to (nreverse reversable-string))))
		  (aref fortran-equivalence 0)))
	      types)))

(defun 1ez-sfgetfile0 (&key x-and-y (types nil types?))
  (declare (values vrefnum name type))
  (let ((point (etypecase x-and-y
		 (null
		   (make-point :x 100 :y 100))
		 (cons
		   (destructuring-bind (x y) x-and-y
		     (make-point :x x :y y)))
		 (vector x-and-y)))
	(types (sftypelist-from-strings types)))
    (let ((numtypes (length types)))
      (stack-let ((reply (make-ezsfreply)))
	(_sfgetfile point "" 0 (if types? numtypes -1) types 0 reply)
	(when (ezsfreply-good reply 0)
	  (values (ezsfreply-vrefnum reply 0)
		  (ezsfreply-fname reply 0)
		  (ezsfreply-ftype reply 0)))))))

;; (octet-ref-remote-ptr (windowrecord-controllist window))
;; (incf (octet-ref-remote-ptr (windowrecord-controllist window)) 999)
;; (octet-ref-remote-ptr (windowrecord-port window))
;; (setf-octet-ref-remote-ptr (windowrecord-port window) --x--)

(defmacro 1octet-ref-remote-ptr0 ((accessor ptr &optional (offset 0)))
  (octet-ref-remote-expander 'read-opaque-field-from-ptr accessor ptr offset))

(defmacro 1octet-ref-remote-handle0 ((accessor handle &optional (offset 0)))
  (octet-ref-remote-expander 'read-opaque-field-from-handle accessor handle offset))

(defun 1octet-ref-remote-expander0 (reader accessor ptr offset)
  (let ((rpc::*octet-structure-access-type* ':byte-swapped-8))
    (let ((reference `(,accessor .x. ,offset)))
      (multiple-value-bind (field structure array index)
	  (rpc::decode-octet-structure-field-reference reference)
	(ignore structure array index)
	(let ((type (rpc::octet-structure-field-type field)))
	  (let ((data-form (rpc::octet-structure-field-type-data type '.x. 0)))
	    (if (subtypep (rpc::octet-structure-field-type-result-type type '.x. 0) 'integer)
		`(sys:with-data-stack
		   (let ((.x. (,reader ,ptr
			       (octet-structure-field-index ,reference)
			       (octet-structure-field-size ,reference)
			       :area :stack)))
		     ,data-form))
		`(let ((.x. (,reader ,ptr
			     (octet-structure-field-index ,reference)
			     (octet-structure-field-size ,reference))))
		   ,data-form))))))))

;; ---I took some shortcuts here---
(define-setf-method octet-ref-remote-ptr ((accessor ptr &optional (offset 0)))
  (let ((store (sys:gensymbol "Store")))
    (values
      ()
      ()
      (list store)
      `(setf-octet-ref-remote-ptr (,accessor ,ptr ,offset) ,store)
      `(octet-ref-remote-ptr (,accessor ,ptr ,offset)))))

;; ---I took some shortcuts here---
(define-setf-method octet-ref-remote-handle ((accessor handle &optional (offset 0)))
  (let ((store (sys:gensymbol "Store")))
    (values
      ()
      ()
      (list store)
      `(setf-octet-ref-remote-handle (,accessor ,handle ,offset) ,store)
      `(octet-ref-remote-handle (,accessor ,handle ,offset)))))

(defmacro 1setf-octet-ref-remote-ptr0 ((accessor ptr &optional (offset 0)) value)
  (setf-octet-ref-remote-expander 'write-opaque-field-into-ptr
				 accessor ptr offset value))

(defmacro 1setf-octet-ref-remote-handle0 ((accessor handle &optional (offset 0)) value)
  (setf-octet-ref-remote-expander 'write-opaque-field-into-handle
				 accessor handle offset value))

(defun 1setf-octet-ref-remote-expander0 (writer accessor ptr offset value)
  (let ((rpc::*octet-structure-access-type* ':byte-swapped-8))
    (let ((reference `(,accessor .x. ,offset)))
      (multiple-value-bind (field structure array index)
	  (rpc::decode-octet-structure-field-reference reference)
	(ignore structure array index)
	(let ((data-form (rpc::octet-structure-field-type-data
			   (rpc::octet-structure-field-type field)
			   '.x. 0)))
	  `(stack-let* ((.size. (octet-structure-field-size ,reference))
			(.offset. (octet-structure-field-index ,reference))
			(.x. (make-array .size. :element-type '(unsigned-byte 8))))
	     (prog1 (setf ,data-form ,value)
		    (,writer ,ptr .offset. .size. .x.))))))))

(defun 1read-opaque-field-from-ptr0 (ptr offset size &key area)
  (let ((result (if (eql area :stack)
		    (sys:make-stack-array size
					  :element-type '(unsigned-byte 8)
					  :fill-pointer 0)
		    (make-array size
				:element-type '(unsigned-byte 8)
				:fill-pointer 0
				:area area))))
    (_read-opaque-bytes-from-pointer (+ ptr offset) size result)))

(defun 1read-opaque-field-from-handle0 (handle offset size &key area)
  (assert ( handle 0))
  (with-handle-locked (handle)
    (let ((ptr (_ptrfromhandle handle)))
      (assert ( ptr 0))
      (read-opaque-field-from-ptr ptr offset size :area area))))

(defun 1write-opaque-field-into-ptr0 (ptr offset size buffer)
  (_write-opaque-bytes-into-pointer (+ ptr offset) size buffer))

(defun 1write-opaque-field-into-handle0 (handle offset size buffer)
  (assert ( handle 0))
  (with-handle-locked (handle)
    (let ((ptr (_ptrfromhandle handle)))
      (assert ( ptr 0))
      (_write-opaque-bytes-into-pointer (+ ptr offset) size buffer))))

(defun 1write-remote-number0 (&key byte word long ptr handle offset value)
  (stack-let ((temp (make-array 4 :element-type '(unsigned-byte 8))))
    (let ((size (cond (byte
		       (check-type word null)
		       (check-type long null)
		       (setf (aref temp 0) (or value byte))
		       1)
		      (word
		       (check-type long null)
		       (setf (byte-swapped-8-aref-16 temp 0) (or value word))
		       2)
		      (long
		       (setf (byte-swapped-8-aref-32 temp 0) (or value long))
		       4)
		      (T (error "None of :byte, :word or :long was specified")))))
      (cond (ptr
	     (check-type handle null)
	     (write-opaque-field-into-ptr ptr (or offset 0) size temp))
	    (handle
	     (write-opaque-field-into-handle handle (or offset 0) size temp))
	    (T (error "Neither :ptr nor :handle was specified"))))))

(defun 1read-remote-number0 (&key byte word long ptr handle offset)
  (sys:with-data-stack
    (multiple-value-bind (size accessor)
	(cond (byte
	       (check-type word null)
	       (check-type long null)
	       (values 1 #'aref))
	      (word
	       (check-type long null)
	       (values 2 #'byte-swapped-8-aref-16))
	      (long
	       (values 4 #'byte-swapped-8-aref-32))
	      (T (error "None of :byte, :word or :long was specified")))
      (funcall accessor
	       (cond (ptr
		      (check-type handle null)
		      (read-opaque-field-from-ptr ptr (or offset 0) size :area :stack))
		     (handle
		      (read-opaque-field-from-handle handle (or offset 0) size :area :stack))
		     (T (error "Neither :ptr nor :handle was specified")))
	       0))))

(defsetf 1read-remote-number0 (&rest args) (value)
  `(write-remote-number :value ,value . ,args))

(defmacro 1with-rect0 ((var &rest edges) &body body)
  (declare (arglist (var &optional left top right bottom) &body body))
  `(sys:with-data-stack
     (let ((,var (make-stack-rect ,@edges)))
       ,@body)))

;; This could have been open coded but at considerable cost of code size
(defun 1make-stack-rect0 (&optional left top right bottom)
  (let ((r (sys:make-stack-array (octet-structure-total-size (rect .x. 0))
				 :element-type '(unsigned-byte 8))))
    (setf (rect-left r 0) (or left 0))
    (setf (rect-top r 0) (or top 0))
    (setf (rect-right r 0) (or right 0))
    (setf (rect-bottom r 0) (or bottom 0))
    r))

(defmacro 1with-point0 ((var x y) &body body)
  `(sys:with-data-stack
     (let ((,var (make-stack-point ,x ,y)))
       ,@body)))

(defun 1make-stack-point0 (x y)
  (let ((p (sys:make-stack-array (octet-structure-total-size (point .x. 0))
				 :element-type '(unsigned-byte 8))))
    (setf (point-x p 0) x)
    (setf (point-y p 0) y)
    p))

(defun 1describe-eventrecord0 (eventrecord)
  (let ((what (eventrecord-what eventrecord 0))
	(where (eventrecord-where eventrecord 0))
	(message (eventrecord-message eventrecord 0))
	(kinds '(nullevent mouseDown mouseUp keyDown keyUp autoKey updateEvt diskEvt
			   activateEvt networkEvt driverEvt app1Evt app2Evt app3Evt app4Evt))
	(modifier-codes '(activeFlag changeFlag btnState cmdKey shiftKey alphaLock
				     optionKey controlKey))
	)
    (let ((kind (or (find what kinds :key #'cconstant-1) what))
	  (modifiers-used
	    (let ((n (eventrecord-modifiers eventrecord 0))
		  (result ()))
	      (dolist (m modifier-codes)
		(let ((code (cconstant-1 m)))
		  (when (logtest n code)
		    (push m result)
		    (decf n code))))
	      (nreconc result (and ( n 0) (list n))))))
      (format T "~&EventRecord ~s has kind ~a, at time ~d, mouse at ~d,~d"
	      eventrecord
	      kind (eventrecord-when eventrecord 0)
	      (point-x where 0)
	      (point-y where 0))
      (format T "~&  Modifiers ~s" (or modifiers-used "None"))
      (ecase kind
	((keydown keyup autokey)
	 (let ((code (logand message (cconstant charcodemask))))
	   (format T "~&  Key #o~o (~:c)"
		   code (ascii-to-char code))))
	((nullevent mouseDown mouseUp) )
	((updateEvt activateEvt)
	 (format T "~&  Window ~d" message))
	(diskEvt
	  (let ((drive (ldb (byte 16 0) message))
		(fmgr-result (sys:sign-extend-16 (ldb (byte 16 16) message))))
	    (format T "~&  Drive ~d, FileMgr result ~d (~a)"
		    drive fmgr-result
		    (multiple-value-bind (ignore text)
			(macintosh-internals::lookup-mac-os-condition fmgr-result)
		      (or text "Unknown")))))
	((networkEvt driverEvt app1Evt app2Evt app3Evt app4Evt)
	 (format T "~&  Message #x~x" message)))
      )))

(defmacro 1with-temps0 ((&rest var-creator-destructor-triples) &body body)
  (multiple-value-bind (vars creators destructors)
      (loop for (var creator destructor) in var-creator-destructor-triples
	    collect var into vars
	    collect creator into creators
	    collect destructor into destructors
	    finally (return (values vars creators destructors)))
    `(let (,@vars)
       (unwind-protect-try
	 (progn
	   ,@(domap 'list ((var vars) (creator creators))
	       `(setq ,var (,creator)))
	   ,@body)
	 ,@(domap 'list ((var vars) (destructor destructors))
	     `(when ,var (,destructor ,var)))))))


#+IMACH
(defmacro with-reliable-mac-emb-agent-search ((&optional timeout-in-secs) &body body)
  (declare (values body-result successfully-completed-p))
  `(with-reliable-mac-emb-agent-search-internal
     (sys:named-lambda with-reliable-mac-emb-agent-search ()
       ,@body)
     ,timeout-in-secs))

#+IMACH
(defun with-reliable-mac-emb-agent-search-internal (continuation timeout)
  (check-type timeout (or null integer))
  (block success-block
    (dolist (agent rpc::*all-transport-agents*)
      (when (and (rpc:embedded-agent-p agent)
		 (rpc:agent-connected-p agent))			;so we won't hang until timeout
	;; bind the default-transport-agent to each transport agent
	(let ((*default-transport-agent* agent))
	  (condition-case ()
	       (if timeout
		   (process:with-timeout (timeout)
		     (return-from success-block
		       (values (funcall continuation) t)))
		   (return-from success-block
		     (values (funcall continuation) t)))
	     ((rpc-error mac-os-error)
	      nil)))))))

;;; These two are here because they have to be defined after the macros they use.

#+IMACH
(defparameter *mac-versions-for-herald-timeout* 10)

#+IMACH
(defun mac-applications-versions-for-herald ()
  (let ((apps))
    (dolist (agent rpc::*all-transport-agents*)
      (block skip-agent
	(when (and (rpc:embedded-agent-p agent)			;so mtb:_GetAppParms will work
		   (rpc:agent-connected-p agent))		;so we won't hang until timeout
	  ;; bind the default-tansport-agent to each transport agent
	  (let ((rpc:*default-transport-agent* agent))
	    (process:with-timeout (*mac-versions-for-herald-timeout*)
	      (condition-case ()
		   (multiple-value-bind (name resfile-refnum ignore)
		       (_GetAppParms)
		     (push (list name
				 (with-resource (mac-version "vers" 1
							     :direction :input
							     :sole-file resfile-refnum)
				   (mac-version-short-string mac-version)))
			   apps))
		 ;; Just in case the program doesn't have a version resource
		 ;; or something else goes wrong here - maybe this is a little too sloppy
		 ((rpc-error mac-os-error)
		  (return-from skip-agent nil))))))))
    apps))

#+IMach
(defun mac-rpc-server-versions-for-herald ()
  (let ((servers))
    (dolist (agent rpc::*all-transport-agents*)
      (block skip-agent
	(when (and (rpc:embedded-agent-p agent)
		   (rpc:agent-connected-p agent))
	  (let ((rpc:*default-transport-agent* agent))
	    (multiple-value-bind (ignore ignore ignore ignore module-table)
		(process:with-timeout (*mac-versions-for-herald-timeout*)
		  (condition-case ()
		       (disgorge-macintosh-rpc-server-status)
		     (rpc-error (return-from skip-agent nil))))
	      (when module-table
		(loop for mdef being the array-elements of module-table using (index i)
			       to (position 'empty module-table :from-end t :test-not #'eq
					    :key #'mdef-module-type)
		      with last-refnum = -1
		      do
		  (block skip-server
		    (when (and ( (mdef-resource-file mdef) -1)
			       ( (mdef-resource-file mdef) last-refnum))
		      (setf last-refnum (mdef-resource-file mdef))
		      (let ((fcb (make-fcbpbrec))
			    (name (make-str255)))
			(condition-case ()
			     (process:with-timeout (*mac-versions-for-herald-timeout*)
			       (_PBGetFCBInfo fcb name 0 last-refnum 0)
			       (push (list name
					   (with-resource (mac-version "vers" 1
								       :direction :input
								       :sole-file last-refnum)
					     (mac-version-short-string mac-version)))
				     servers))
			   ((rpc-error mac-os-error)
			    (return-from skip-server nil)))))))))))))
    (delete-duplicates servers :test #'equal)))



#+IMACH
(defun macintosh-internals::MacOS-version-for-herald ()
  (format-Macintosh-version-number (sys:MacIvory-MacOS-version)))

(defun format-Macintosh-version-number (version-as-number)
  (stack-let* ((version (make-array (octet-structure-field-index (mac-version-country version))
				    :element-type '(unsigned-byte 8)))
	       (kludge (make-array 1 :element-type '(unsigned-byte 32)
				   :displaced-to version :displaced-index-offset 0)))
    (setf (aref kludge 0) (rpc::byte-8-reverse-32 version-as-number))
    (flet ((decode-bcd (bcd)
	     (let ((tens (ldb (byte 4 4) bcd))
		   (units (ldb (byte 4 0) bcd)))
	       (if (and (< tens 10) (< units 10))
		   (+ (* tens 10) units)
		   bcd))))
      (format nil "~D.~D~:[.~D~;~*~]~A~:[~D~]" (decode-bcd (mac-version-major version))
					       (mac-version-minor version)
					       (zerop (mac-version-fix version))
					       (mac-version-fix version)
					       (select (mac-version-stage version)
						 (#x20 "d")
						 (#x40 "a")
						 (#x60 "b")
						 (#x80
						  (if (zerop (mac-version-devo-level version))
						      ""
						      "FC"))
						 (#x84 "p")
						 (otherwise "?"))
					       (and (= (mac-version-stage version) #x80)
						    (zerop (mac-version-devo-level version)))
					       (decode-bcd (mac-version-devo-level version)))
      )))

(defun get-blessed-volume-and-folder ()
  (declare (values volume-name directory-name-list vrefnum dirid))
  (stack-let ((rec (make-sysenvrec ))
	      (hfi (make-hfileinfo )))
    (labels ((dir-chain (vrefnum dirid root-dirid)
	       (let ((name (make-str255)))
		 (_pbgetcatinfo hfi name vrefnum -1 dirid)
		 (unless (= dirid root-dirid)
		   (cons name (dir-chain vrefnum (hfileinfo-ioflparid hfi 0) root-dirid)))))
	     (root-dirid (vrefnum name)
	       (stack-let ((the-name (make-str255 (string-append name ":"))))
		 (_pbgetcatinfo hfi the-name  vrefnum 0 0))
	       (hfileinfo-iodirid hfi 0)))
      (mtb::_sysenvirons 2 rec)
      (let (dir-name-list root-dirid
	    (wd-dirid (sysenvrec-sysvrefnum rec 0))
	    (vol-name (make-str255)))
	;; Find the volume name, volume reference number, and dirid of the system folder
	(multiple-value-bind (nil nil nil vrefnum dirid)
	    (_pbgetwdinfo vol-name wd-dirid 0 0 0)
	  (setf root-dirid (root-dirid vrefnum vol-name))
	  ;; The dirindex must be -1 to ignore the ionameptr and use the dirid 
	  (setf dir-name-list (nreverse (dir-chain vrefnum dirid root-dirid)))
	  (return-from get-blessed-volume-and-folder
	    (values vol-name dir-name-list vrefnum dirid)))))))


#+IMACH
(defparameter *mac-time-functions-timeout* 5)

#+IMACH
;;;These need to use the above macros.
(defun set-mac-time (&key year month day hour minute second dayofweek)
  (with-reliable-mac-emb-agent-search (*mac-time-functions-timeout*)
    (mtb:_settime
      (mtb::make-datetimerec :year year :month month :day day :hour hour
			     :minute minute :second second :dayofweek dayofweek))
    (return-from set-mac-time t)))

#+IMACH
(defun get-mac-time ()
  (with-reliable-mac-emb-agent-search (*mac-time-functions-timeout*)
    (mtb:_GetDateTime)))


;;; Do SetVol before running body, restoring old one when done
;; I could stand it if someone thought up a better name.
(defmacro 1with-setvol0 ((temp-volname temp-vrefnum) &body body)
  `(with-setvol-1 ,temp-volname ,temp-vrefnum (named-lambda with-setvol () ,@body)))

(defun 1with-setvol-10 (temp-volname temp-vrefnum continuation)
  (declare (sys:downward-funarg continuation))
  (multiple-value-bind (old-volname old-vrefnum)
      (_getvol)
    (unwind-protect-try
      (progn
	(_setvol temp-volname temp-vrefnum)
	(funcall continuation))
      (_setvol old-volname old-vrefnum))))

;; Convert a Lisp string into a fixnum the way C's single-quote string constant would be.
;; That is, (cardinal-32-from-ostype-string "ERIK") = 1163020619 = C's 'ERIK'
(defun 1cardinal-32-from-ostype-string0 (string)
  (check-type string (vector string-char 4))
  (stack-let* ((reversible (make-array 4
				       :element-type 'string-char
				       :initial-contents string))
	       (fortran-equivalence (make-array 1
						:element-type 'fixnum
						:displaced-to (nreverse reversible))))
    (aref fortran-equivalence 0)))

;; Given a vrefnum, dirid and name, construct a Lisp pathname.
;; Recursively looks up names of parent folders until reaching the root.
(defun 1mac-pathname-from-parts0 (vrefnum dirid name)
  (pathname (format nil "HOST:~{~a:~}~a"
		    (with-str255 (name)
		      (stack-let ((pb (make-hfileinfo)))
			(let ((names ()))
			  (loop
			    (_pbgetcatinfo pb name vrefnum -1 dirid)
			    (push (copy-seq name) names)
			    (setq dirid (hfileinfo-ioflparid pb 0))
			    (when (= dirid 1) (return)))
			  names)))
		    name)))

;; Bind var to an octet structure of the named type read at filepos from the file open on refnum 
(defmacro 1with-mac-file-struct0 ((var octet-structure-type filepos refnum) &body body)
  `(sys:with-data-stack
     (let ((,var (read-file-struct-1
		   (octet-structure-total-size (,octet-structure-type .x. 0))
		   ,filepos ,refnum)))
       ,@body)))

;; Bind var to an octet array (that is, element-type (unsigned-byte 8))
;; read form refnum at filepos
(defmacro 1with-mac-file-bytes0 ((var len filepos refnum) &body body)
  `(sys:with-data-stack
     (let ((,var (read-file-struct-1 ,len ,filepos ,refnum)))
       ,@body)))

;; Support for with-mac-file-struct and with-mac-file-bytes
(defun 1read-file-struct-10 (len filepos refnum)
  (let ((buf (sys:make-stack-array len :element-type '(unsigned-byte 8) :fill-pointer 0)))
    (_pbread 0 refnum buf len (cconstant fsFromStart) filepos)
    buf))

;; Iterate body over all mounted volume structures.  Caller receives volume name, its
;; refnum, and, if it wants it, a VolumeParam structure.
(defmacro 1do-mac-volumes0 ((volume-name volume-refnum &optional volumeparam) &body body)
  `(do-mac-volumes-1
     (named-lambda do-mac-volumes (,volume-name ,volume-refnum ,(or volumeparam 'ignore))
       ,@body)))

(defun 1do-mac-volumes-10 (continuation)
  (declare (sys:downward-funarg continuation))
  (stack-let ((pb (make-volumeparam)))
    (with-str255 (name)
      (loop for volindex from 1 do
	(condition-case ()
	     (_pbgetvinfo pb name 0 volindex)
	   (mac-os-error-nsverr (return))
	   (:no-error (funcall continuation name (volumeparam-iovrefnum pb 0) pb)))))))

;;;========================================
;;; Decoding resource file's resource map on the fly.  
;;; This is motivated by the long, long time it takes
;;; to open the finder's Desktop file.
;;;========================================

;; Find the resource of type rsrc-type, id rsrc-id (or name rsrc-name)
;; in file pathname, haul it over to the Lisp side, and bind var to it.
;; This could have been written using with-resfiles and with-resource sole-file,
;; but this bypasses Resource Manager for performance on files with excessively
;; large resource maps, like the Finder's Desktop file.
(defmacro 1with-one-mac-rsrc0 ((var pathname rsrc-type &rest options) &body body)
  (declare (arglist (var pathname rsrc-type &key rsrc-id rsrc-name (vrefnum 0) (dirid 0))
		    &body body))
  `(with-one-mac-rsrc-1
     (named-lambda with-one-mac-rsrc (,var) ,@body)
     ,pathname ,rsrc-type ,@options))

(defun 1with-one-mac-rsrc-10 (continuation pathname rsrc-type
			    &key rsrc-id rsrc-name (vrefnum 0) (dirid 0))
  (declare (sys:downward-funarg continuation))
  (assert (and (or rsrc-id rsrc-name) (not (and rsrc-id rsrc-name))) ()
	  "Caller must supply exactly one of :RSRC-ID or :RSRC-NAME")
  (assert (null rsrc-name) () "Can't hack rsrc-name for the time being ---")
  (with-open-refnum (rf pathname
			:vrefnum vrefnum :dirid dirid
			:permission (cconstant fsrdperm)
			:resource-fork T)
    (multiple-value-bind (data-offset map-offset data-length map-length)
	(with-mac-file-struct (header resource-fork-header 0 rf)
	  (values (resource-fork-header-data-offset header 0)
		  (resource-fork-header-map-offset header 0)
		  (resource-fork-header-data-length header 0)
		  (resource-fork-header-map-length header 0)))
      (ignore data-length map-length)
      (multiple-value-bind (nrsrcs-of-type reference-list-pos)
	  (one-mac-rsrc-find-reference-list-offset rf rsrc-type map-offset)
	(when nrsrcs-of-type
	  (let ((rsrc-pos (+ data-offset (one-mac-rsrc-find-data-offset
					   rf rsrc-id reference-list-pos nrsrcs-of-type))))
	    (let ((rsrc-len (with-mac-file-bytes (len (octet-structure-field-index
							(resource-fork-resource-data .x. 0))
						      rsrc-pos rf)
			      (resource-fork-resource-length len 0))))
	      (with-mac-file-bytes (rsrc-data rsrc-len
					      (+ rsrc-pos
						 (octet-structure-field-index
						   (resource-fork-resource-data .x. 0)))
					      rf)
		(funcall continuation rsrc-data)))))))))

(defun 1one-mac-rsrc-find-data-offset0 (rf rsrc-id reference-list-pos nrsrcs-of-type)
  (let ((rlen (octet-structure-total-size
		(resource-fork-reference-list .x. 0))))
    (with-mac-file-bytes (rlist (* nrsrcs-of-type rlen) reference-list-pos rf)
      (dotimes (j nrsrcs-of-type)
	(let ((index (* j rlen)))
	  (when (if rsrc-id
		    (eql (resource-fork-reference-list-id rlist index) rsrc-id)
		    (error "Can't hack rsrc-name for the time being---")
		    ;;(resource-fork-reference-list-name-list-offset rlist index)
		    )
	    (let ((data-offset (resource-fork-reference-list-data-offset rlist index)))
	      (return data-offset))))))))

(defun 1one-mac-rsrc-find-reference-list-offset0 (rf rsrc-type map-offset)
  (declare (values nrsrcs-of-type reference-list-pos))
  (let ((type-list-pos
	  (+ map-offset (with-mac-file-struct (map resource-fork-map map-offset rf)
			  (resource-fork-map-type-list-offset map 0)))))
    (let ((ntypes (with-mac-file-bytes (n-types 2 type-list-pos rf)
		    (resource-fork-type-list-ntypes n-types 0))))
      (with-mac-file-bytes
	(type-list (+ 2 (* ntypes (octet-structure-total-size
				    (resource-fork-type-list-entry .x. 0))))
		   type-list-pos rf)
	(loop for type-start being the octet-structure-field-elements
		  of (resource-fork-type-list-types type-list 0)
	      do (when (string= rsrc-type (resource-fork-type-list-entry-type
					    type-list type-start))
		   (return (values (1+ (resource-fork-type-list-entry-nresources
					 type-list type-start))
				   (+ type-list-pos
				      (resource-fork-type-list-entry-reference-list-offset
					type-list type-start))))))))))
