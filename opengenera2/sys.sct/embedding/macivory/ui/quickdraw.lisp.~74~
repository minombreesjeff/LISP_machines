;;; -*- Mode: LISP; Syntax: Common-lisp; Package: MACINTOSH-INTERNALS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Note:  There is no single resolution to the two data representations for graphics state.
;;; However, the general rule of thumb used is that things are kept in Macintosh format
;;; except when dealing directly with the Genera interfaces.  The alternative would be
;;; to convert at all QuickDraw boundaries.  That is problematic because they are more varied
;;; and less modular than the Genera interfaces, which are for the most part outside this file.
;;; The disadvantage of course is that octet structures are less efficient and more cumbersome
;;; to manipulate.


;;; Picture definition format.

;;; Quickdraw picture record opcodes
(defconstant =op-noop= #x00)
(defconstant =op-clip-region= #x01)
(defconstant =op-background-pattern= #x02)
(defconstant =op-text-font= #x03)
(defconstant =op-text-face= #x04)
(defconstant =op-text-mode= #x05)
(defconstant =op-space-extra= #x06)
(defconstant =op-pen-size= #x07)
(defconstant =op-pen-mode= #x08)
(defconstant =op-pen-pattern= #x09)
(defconstant =op-fill-pattern= #x0a)
(defconstant =op-oval-size= #x0b)
(defconstant =op-origin= #x0c)
(defconstant =op-text-size= #x0d)
(defconstant =op-foreground-color= #x0e)	;Old style
(defconstant =op-background-color= #x0f)

(defconstant =op-text-ratio= #x10)
(defconstant =op-picture-version= #x11)
(defconstant =op-background-color-pattern= #x12)	;Version 2
(defconstant =op-pen-color-pattern= #x13)
(defconstant =op-fill-color-pattern= #x14)
(defconstant =op-fractional-pen-position= #x15)
(defconstant =op-character-extra= #x16)
(defconstant =op-rgb-foreground-color= #x1a)
(defconstant =op-rgb-background-color= #x1b)
(defconstant =op-rgb-hilite-mode= #x1c)
(defconstant =op-rgb-hilite-color= #x1d)
(defconstant =op-default-hilite= #x1e)
(defconstant =op-rgb-op-color= #x1f)

(defconstant =op-line= #x20)
(defconstant =op-line-from= #x21)
(defconstant =op-short-line= #x22)
(defconstant =op-short-line-from= #x23)

(defconstant =op-long-text= #x28)
(defconstant =op-dh-text= #x29)
(defconstant =op-dv-text= #x2a)
(defconstant =op-dhdv-text= #x2b)

(defconstant =op-frame-rect= #x30)
(defconstant =op-paint-rect= #x31)
(defconstant =op-erase-rect= #x32)
(defconstant =op-invert-rect= #x33)
(defconstant =op-fill-rect= #x34)

(defconstant =op-frame-same-rect= #x38)
(defconstant =op-paint-same-rect= #x39)
(defconstant =op-erase-same-rect= #x3a)
(defconstant =op-invert-same-rect= #x3b)
(defconstant =op-fill-same-rect= #x3c)

(defconstant =op-frame-round-rect= #x40)
(defconstant =op-paint-round-rect= #x41)
(defconstant =op-erase-round-rect= #x42)
(defconstant =op-invert-round-rect= #x43)
(defconstant =op-fill-round-rect= #x44)

(defconstant =op-frame-same-round-rect= #x48)
(defconstant =op-paint-same-round-rect= #x49)
(defconstant =op-erase-same-round-rect= #x4a)
(defconstant =op-invert-same-round-rect= #x4b)
(defconstant =op-fill-same-round-rect= #x4c)

(defconstant =op-frame-oval= #x50)
(defconstant =op-paint-oval= #x51)
(defconstant =op-erase-oval= #x52)
(defconstant =op-invert-oval= #x53)
(defconstant =op-fill-oval= #x54)

(defconstant =op-frame-same-oval= #x58)
(defconstant =op-paint-same-oval= #x59)
(defconstant =op-erase-same-oval= #x5a)
(defconstant =op-invert-same-oval= #x5b)
(defconstant =op-fill-same-oval= #x5c)

(defconstant =op-frame-arc= #x60)
(defconstant =op-paint-arc= #x61)
(defconstant =op-erase-arc= #x62)
(defconstant =op-invert-arc= #x63)
(defconstant =op-fill-arc= #x64)

(defconstant =op-frame-same-arc= #x68)
(defconstant =op-paint-same-arc= #x69)
(defconstant =op-erase-same-arc= #x6a)
(defconstant =op-invert-same-arc= #x6b)
(defconstant =op-fill-same-arc= #x6c)

(defconstant =op-frame-poly= #x70)
(defconstant =op-paint-poly= #x71)
(defconstant =op-erase-poly= #x72)
(defconstant =op-invert-poly= #x73)
(defconstant =op-fill-poly= #x74)

(defconstant =op-frame-same-poly= #x78)
(defconstant =op-paint-same-poly= #x79)
(defconstant =op-erase-same-poly= #x7a)
(defconstant =op-invert-same-poly= #x7b)
(defconstant =op-fill-same-poly= #x7c)

(defconstant =op-frame-region= #x80)
(defconstant =op-paint-region= #x81)
(defconstant =op-erase-region= #x82)
(defconstant =op-invert-region= #x83)
(defconstant =op-fill-region= #x84)

(defconstant =op-frame-same-region= #x88)
(defconstant =op-paint-same-region= #x89)
(defconstant =op-erase-same-region= #x8a)
(defconstant =op-invert-same-region= #x8b)
(defconstant =op-fill-same-region= #x8c)

(defconstant =op-bits-rect= #x90)
(defconstant =op-bits-region= #x91)
(defconstant =op-pack-bits-rect= #x98)
(defconstant =op-pack-bits-region= #x99)
(defconstant =op-direct-bits-rect= #x9a)
(defconstant =op-direct-bits-region= #x9b)

(defconstant =op-short-comment= #xa0)
(defconstant =op-long-comment= #xa1)

(defconstant =op-end-of-picture= #xff)

;;; Source transfer modes
(defconstant =src-copy= 0)
(defconstant =src-or= 1)
(defconstant =src-xor= 2)
(defconstant =src-bic= 3)
(defconstant =not-src-copy= 4)
(defconstant =not-src-or= 5)
(defconstant =not-src-xor= 6)
(defconstant =not-src-bic= 7)

;;; Pattern transfer modes
(defconstant =pat-copy= 8)
(defconstant =pat-or= 9)
(defconstant =pat-xor= 10)
(defconstant =pat-bic= 11)
(defconstant =not-pat-copy= 12)
(defconstant =not-pat-or= 13)
(defconstant =not-pat-xor= 14)
(defconstant =not-pat-bic= 15)

(eval-when (eval load compile)
(defparameter *graf-verbs* '("frame" "paint" "erase" "invert" "fill"))
)

;;;; Basic streams

;;; Streams using the quickdraw graphics model for something.
(defflavor basic-quickdraw-stream () ()
  (:required-methods
;; SetOrigin  SetClip  BackPat
   set-origin set-clip background-pattern
;; GetPen  GetPenState   PenSize  PenMode  PenPat      MoveTo  Move LineTo  Line
   get-pen get-pen-state pen-size pen-mode pen-pattern move-to move line-to line
;; TextFont  TextFace  TextMode  TextSize  SpaceExtra  DrawChar  DrawString  DrawText
   text-font text-face text-mode text-size space-extra draw-char draw-string draw-text
;; CharWidth  StringWidth  TextWidth  GetFontInfo   ??
   char-width string-width text-width get-font-info text-ratio
;; RGBForeColor         ForeColor        BackColor
   rgb-foreground-color foreground-color background-color
;; FrameRect  PaintRect  EraseRect  InvertRect  FillRect
   frame-rect paint-rect erase-rect invert-rect fill-rect
;; FrameOval  PaintOval  EraseOval  InvertOval  FillOval
   frame-oval paint-oval erase-oval invert-oval fill-oval
;; FrameRoundRect   PaintRoundRect   EraseRoundRect   InvertRoundRect   FillRoundRect
   frame-round-rect paint-round-rect erase-round-rect invert-round-rect fill-round-rect
;; FrameArc  PaintArc  EraseArc  InvertArc  FillArc
   frame-arc paint-arc erase-arc invert-arc fill-arc
;; FrameRgn     PaintRgn     EraseRgn     InvertRgn     FillRgn
   frame-region paint-region erase-region invert-region fill-region
;; FramePoly  PaintPoly  ErasePoly  InvertPoly  FillPoly
   frame-poly paint-poly erase-poly invert-poly fill-poly
   ))

;; Bind this to 'warn if you don't want your program to end up in the debugger
(defvar *what-to-do-on-niy* 'error)		;or 'warn

(defgeneric niy (basic-quickdraw-stream operation &rest args)
  (:method (basic-quickdraw-stream)
   (apply #'niy1 "Cannot do ~S yet" operation args)))

;; Common subroutine function for niy methods
(defun niy1 (format-string &rest format-args)
  (funcall *what-to-do-on-niy*
	  "NIY: ~?" (or format-string "Not implemented yet") format-args))

(defmacro pen-state-pen-x (pen-state)
  `(point-x ,pen-state (octet-structure-field-index (pen-state-pen-loc ,pen-state))))

(defmacro pen-state-pen-y (pen-state)
  `(point-y ,pen-state (octet-structure-field-index (pen-state-pen-loc ,pen-state))))

(defmacro pen-state-pen-width (pen-state)
  `(point-x ,pen-state (octet-structure-field-index (pen-state-pen-size ,pen-state))))

(defmacro pen-state-pen-height (pen-state)
  `(point-y ,pen-state (octet-structure-field-index (pen-state-pen-size ,pen-state))))

(defmethod (get-pen basic-quickdraw-stream :default) ()
  (let ((state (get-pen-state self)))
    (values (pen-state-pen-x state) (pen-state-pen-y state))))

(defmethod (move basic-quickdraw-stream :default) (dx dy)
  (multiple-value-bind (x y)
      (get-pen self)
    (move-to self (+ x dx) (+ y dy))))

(defmethod (line basic-quickdraw-stream :default) (dx dy)
  (multiple-value-bind (x y)
      (get-pen self)
    (line-to self (+ x dx) (+ y dy))))

(defmethod (draw-char basic-quickdraw-stream :default) (char)
  (stack-let ((string (make-array 1 :element-type '(unsigned-byte 8) :initial-element char)))
    (draw-string self string)))

(defmethod (draw-text basic-quickdraw-stream :default) (string start count)
  (draw-string self string start (+ start count)))

(defmethod (char-width basic-quickdraw-stream :default) (char)
  (stack-let ((string (make-array 1 :element-type '(unsigned-byte 8) :initial-element char)))
    (string-width self string)))

(defmethod (text-width basic-quickdraw-stream :default) (string start count)
  (string-width self string start (+ start count)))

;;; Ref. Inside Mac V-69
(defparameter *standard-old-colors*
  '((33 0 0 0)					;black
    (30 #xFFFF #xFFFF #xFFFF)			;white
    (205 #xDD6B #x08C2 #x06A2)			;red
    (341 0 #x8000 #x11B0)			;green
    (409 0 0 #xD400)				;blue
    (273 #x0241 #xAB54 #xEAFF)			;cyan
    (137 #xF2D7 #x0856 #x84EC)			;magenta
    (69 #xFC00 #xF37D #x052F)			;yellow
    ))

(defvar *rgb-color-table* (make-hash-table :test 'equal))

(defun intern-rgb-color-fixed (r g b)
  (stack-let ((key (list r g b)))
    (multiple-value-bind (color found-p)
	(gethash key *rgb-color-table*)
      (if found-p color
	(setq color (make-rgb-color :red r :green g :blue b))
	(setf (gethash (copy-list key) *rgb-color-table*) color)
	color))))

(defun intern-rgb-color (r g b)
  (macrolet ((round-16 (x)
	       `(round (* ,x (1- 1_16)))))
    (intern-rgb-color-fixed (round-16 r) (round-16 g) (round-16 b))))

(defvar *rgb-color-white* (intern-rgb-color 1 1 1))
(defvar *rgb-color-black* (intern-rgb-color 0 0 0))

(defmethod (background-color basic-quickdraw-stream :default) (color)
  (let ((elem (assoc color *standard-old-colors*)))
    (rgb-background-color self (if elem
				   (apply #'intern-rgb-color-fixed (rest elem))
				   *rgb-color-white*))))

(defmethod (foreground-color basic-quickdraw-stream :default) (color)
  (let ((elem (assoc color *standard-old-colors*)))
    (rgb-foreground-color self (if elem
				   (apply #'intern-rgb-color-fixed (rest elem))
				   *rgb-color-black*))))

;;; Extended ALU abstraction for the MacIvory remote screen.  We record the
;;; RGB information in a Mac RGB-COLOR, which is retrieved at drawing time
;;; by QD-PEN-STATE-AND-COLOR, below.

(defflavor mac-color-alu
  ((color)
   (alu))
  ()
  (:initable-instance-variables)
  (:constructor make-mac-color-alu))

(defmethod (:1-bit-parameters mac-color-alu) (ignore)
  (values alu -1 -1))

(defmethod (:sc-parameters mac-color-alu) (sheet &optional sc-array)
  (declare (ignore sc-array)
	   (values array plane-mask pixel-mask fill-data alu))
  (let ((fill-data (mtb::_Color2Index color
				      :transport-agent (rpc::rpc-console-transport-agent
							 (send (send sheet :screen) :console))
				      )))
    (values :default -1 -1 fill-data alu)))

(defmethod (:decode-mac-color mac-color-alu) ()
  (values color alu))

(compile-flavor-methods mac-color-alu)


;;;; Streams that translate the Zetalisp / Genera output stream protocol into Quickdraw.

;;; Graphics state block

;;; pen-loc is the program visible cursor (both graphics and text)
;;; device's pen-loc is the version on the device, as last updated by move-to, line-to,
;;; draw-string, etc.  Except when a string is open, where device's pen-loc follows the
;;; text being filled in along so as to suppress excess forcing when the cursor moves
;;; in an uninteresting way.
(defflavor quickdraw-drawing-state
	((pen-state (make-pen-state))
	 (override-pen-size nil)
	 (foreground-color *rgb-color-black*)

	 (device-pen-state (make-pen-state))
	 (device-current-font nil)		;Don't know reliably.
	 (device-text-mode =src-or=)
	 (device-extra-space 0)
	 (device-foreground-color *rgb-color-black*)
	 )
	(graphics::drawing-state)
  (:conc-name qd-state-)
  :writable-instance-variables
  (:locatable-instance-variables override-pen-size)
  (:constructor make-quickdraw-drawing-state ()))

(defsubst pat-mode-src-mode (pat-mode)
  (- pat-mode (- =pat-copy= =src-copy=)))

(defun compute-pen-pattern (pattern pattern-index stipple tile gray-level)
  (stack-let ((raster (make-array '(8 32) :element-type 'bit :initial-element 1)))
    (when stipple
      (ecase (array-rank stipple)
	(2 (bitblt boole-and 32 8 stipple 0 0 raster 0 0))
	(1
	  ;; use art-8b indirect arrays
	  (dotimes (y 8)
	    (let ((stipple-row (bit-reverse-8 (aref stipple y))))
	      (dotimes (x 8) (setf (raster-aref raster x y)
				   (logand (raster-aref raster x y)
					   (ldb (byte 1 x) stipple-row)))))))))
    (when tile
      ;;---deserves above treatment
      (bitblt boole-and 32 8 tile 0 0 raster 0 0))
    (let ((stipple (graphics::gray-level-stipple gray-level)))
      (cond ((eql stipple t))
	    ((eql stipple nil)
	     (bitblt boole-clr 32 8 raster 0 0 raster 0 0))
	    (t
	     (bitblt boole-and 32 8 stipple 0 0 raster 0 0))))
    (dotimes (y 8)
      (setf (aref pattern (+ pattern-index y))
	    (let ((byte 0))
	      (dotimes (x 8)
		(setf (ldb (byte 1 x) byte) (raster-aref raster x y)))
	      (bit-reverse-8 byte))))))

;;; This takes an ALU function and returns a pat mode.
;;; For no-op we substitute =not-pat-or=, not knowing any better
(defun convert-alu-to-mode (alu)
  (aref '#,(vector =pat-bic= =not-pat-bic= =pat-bic=      =not-pat-or=
		   =pat-xor= =pat-copy=    =pat-xor=      =pat-or=
		   =pat-bic= =not-pat-xor= =not-pat-copy= =not-pat-or=
		   =pat-xor= =pat-or=      =pat-xor=      =pat-copy=)
	alu))

(defvar *pen-state-hash-table* (make-hash-table :test 'equal))

(defmethod (qd-state-pen-state-and-color graphics::drawing-state) (stream &optional color-p)
  (declare (values pen-state rgb-color alu))
  (setq color-p (or (and stream (color:color-stream-p stream)) color-p))
  ;;--- Reverse-video vs. :color <color> still doesn't work
  (stack-let* ((reverse-video (and stream (send-if-handles stream :reverse-video-p)))
	       (xform (list 1 0 0 1))
	       (size-key (list xform
			       graphics::thickness graphics::scale-thickness))
	       (mode-key (list graphics::alu graphics::opaque))
	       (color-key (list color-p graphics::color reverse-video))
	       (pattern-key (list color-key
				  graphics::stipple graphics::tile graphics::gray-level))
	       (total-key (list size-key mode-key pattern-key)))
    (loop for l1 on xform
	  for l2 = graphics::transform then (cdr l2)
	  do
      (setf (first l1) (first l2)))
    (multiple-value-bind (result found-p)
	(gethash total-key *pen-state-hash-table*)
      (unless found-p
	(let ((pen-state (make-pen-state)))
	  (multiple-value-bind (rgb-color alu)
	      (if (typep graphics::alu 'mac-color-alu)
		  (send graphics::alu :decode-mac-color)
		(values (cond ((not color-p)
			       *rgb-color-black*)
			      ((not graphics::color)
			       ;; A gray other than black or white on a color screen turns
			       ;; into that color of no hue
			       (cond ((= graphics::gray-level 1)
				      *rgb-color-black*)
				     ((= graphics::gray-level 0)
				      *rgb-color-white*)
				     (t (let ((intensity graphics::gray-level))
					  (unless reverse-video
					    (setq intensity (- 1 intensity)))
					  (setq intensity (sqrt (* intensity 3)))
					  (multiple-value-bind (r g b)
					      (color:ihs->rgb intensity 0 0)
					    (intern-rgb-color r g b))))))
			      (t (let ((color graphics::color))
				   ;; Decrease intensity per gray-level
				   (when ( graphics::gray-level 1)
				     (multiple-value-bind (i h s)
					 (color:color-ihs color)
				       (with-stack-list (ihs (* i graphics::gray-level) h s)
					 (setq color (color:make-color :ihs ihs)))))
				   (multiple-value-call #'intern-rgb-color
							(color:color-rgb color)))))
			(if graphics::opaque
			    (case graphics::alu
			      (:flip boole-xor)
			      (:erase (if reverse-video boole-1 boole-andc1))
			      (:draw (if reverse-video boole-andc1 boole-1))
			      (otherwise graphics::alu))
			  (case graphics::alu		     
			    (:flip boole-xor)
			    (:erase (if reverse-video boole-ior boole-andc1))
			    (:draw (if reverse-video boole-andc1 boole-ior))
			    (otherwise graphics::alu)))))
	    (multiple-value-bind (pen-x pen-y)
		(let ((thickness (or graphics::thickness 0)))
		  (cond ((not graphics::scale-thickness)
			 (values thickness thickness))
			(t
			 (graphics::transform-distance thickness thickness
						       graphics::transform))))
	      (set-point pen-state (octet-structure-field-index
				     (pen-state-pen-size device-pen-state))
			 (max 1 (round (abs pen-x))) (max 1 (round (abs pen-y)))))
	    (setf (pen-state-pen-mode pen-state) (convert-alu-to-mode alu))
	    (compute-pen-pattern pen-state (octet-structure-field-index
					     (pen-state-pen-pattern device-pen-state))
				 
				 graphics::stipple graphics::tile
				 (if color-p 1
				   (if graphics::color
				       (* graphics::gray-level
					  (/ (expt (color:color-intensity graphics::color) 2)
					     3))
				     graphics::gray-level)))
	    (setq result (list pen-state rgb-color alu))
	    (setf (gethash (copy-tree total-key) *pen-state-hash-table*) result))))
      (values-list result))))

(defmethod (qd-state-update-pen-state-and-color quickdraw-drawing-state) (stream &optional color-p)
  (multiple-value-bind (new-pen-state new-rgb-color)
      (qd-state-pen-state-and-color self stream color-p)
    (replace pen-state new-pen-state
	     :start1 (octet-structure-field-index (pen-state-pen-size pen-state))
	     :start2 (octet-structure-field-index (pen-state-pen-size new-pen-state)))
    (when override-pen-size
      (copy-octet-structure (pen-state-pen-size pen-state) (point override-pen-size 0)))
    (setq foreground-color new-rgb-color)))

(compile-flavor-methods quickdraw-drawing-state)

(defvar *normal-pen-state* (qd-state-pen-state-and-color (make-quickdraw-drawing-state) nil))

(defmethod (quickdraw-drawing-state-initialize quickdraw-drawing-state) ()
  (replace device-pen-state *normal-pen-state*)
  (set-point device-pen-state (octet-structure-field-index
				(pen-state-pen-loc device-pen-state))
	     -1 -1)
  (setq device-foreground-color *rgb-color-black*)
  (setq device-current-font nil
	device-text-mode =src-or=
	device-extra-space 0))

;;; Actual streams

(defflavor to-quickdraw-output-stream
	((color-p nil)

	 (string-buffer (make-array 256 :element-type '(unsigned-byte 8) :fill-pointer 0))
	 (string-open nil)
	 (display-device-type *mac-display-device*)
	 (default-character-style si:*standard-default-character-style*)
	 (current-character-style si:*null-style*)
	 merged-current-character-style
	 current-font

	 (graphics::drawing-state (make-quickdraw-drawing-state))
	 (path-initial-x nil)
	 (path-initial-y nil)
	 )

	(basic-quickdraw-stream graphics::drawing-state-graphics-mixin
	 si:line-output-stream-mixin si:character-stream si:output-stream)
  (:initable-instance-variables color-p)
  (:gettable-instance-variables display-device-type)
  )

(defun-in-flavor (force-pen-loc to-quickdraw-output-stream) ()
  (let* ((pen-state (qd-state-pen-state graphics::drawing-state))
	 (device-pen-state (qd-state-device-pen-state graphics::drawing-state))
	 (pen-width (pen-state-pen-width pen-state))
	 (pen-height (pen-state-pen-height pen-state))
	 )
    (unless (octet-structure-equal (pen-state-pen-loc pen-state)
				   (pen-state-pen-loc device-pen-state))
      (move-to self (- (pen-state-pen-x pen-state) (floor pen-width 2))
	       (- (pen-state-pen-y pen-state) (floor pen-height 2)))
      (copy-octet-structure (pen-state-pen-loc device-pen-state)
			    (pen-state-pen-loc pen-state)))))

(defun-in-flavor (open-string to-quickdraw-output-stream) ()
  (unless (eql (qd-state-device-text-mode graphics::drawing-state) =src-or=)
    (text-mode self =src-or=)
    (setf (qd-state-device-text-mode graphics::drawing-state) =src-or=))
  (force-pen-loc)
  (setq string-open t))

(defun-in-flavor (force-string to-quickdraw-output-stream) ()
  (when string-open
    (draw-string self string-buffer)
    (setf (fill-pointer string-buffer) 0)
    (setq string-open nil)))

(defmethod (get-font-number to-quickdraw-output-stream) (family-name)
  (let ((family (find family-name *mac-font-families*
		      :key #'qd-font-family-name
		      :test #'string-equal)))
    (if family (qd-font-family-number family) 0)))

(defun-in-flavor (send-font to-quickdraw-output-stream) (font)
  (let ((old-font (qd-state-device-current-font graphics::drawing-state)))
    (unless (eq old-font font)
      (destructuring-bind (old-family old-face old-size)
	  (if old-font
	      (qd-font-parameters old-font)
	      '(nil nil nil))
	(destructuring-bind (new-family new-face new-size)
	    (qd-font-parameters font)
	  (unless (equal old-family new-family)
	    (text-font self (get-font-number self new-family)))
	  (unless (eql old-face new-face)
	    (text-face self new-face))
	  (unless (eql old-size new-size)
	    (text-size self new-size))))))
  (setf (qd-state-device-current-font graphics::drawing-state) font))

(defun-in-flavor (font-for-character to-quickdraw-output-stream) (char)
  (let ((code (char-code char)))
    (if ( #o40 code #o176)		;Printing ASCII
	(values current-font code)
	(multiple-value-bind (index font)
	    (si:lookup-index-and-font char display-device-type merged-current-character-style)
	  (values font index)))))

(defun-in-flavor (update-paint-state to-quickdraw-output-stream) ()
  (force-string)
  (qd-state-update-pen-state-and-color graphics::drawing-state self color-p)
  (let ((pen-state (qd-state-pen-state graphics::drawing-state))
	(device-pen-state (qd-state-device-pen-state graphics::drawing-state)))
    (let ((pen-mode (pen-state-pen-mode pen-state)))
      (unless (= pen-mode (pen-state-pen-mode device-pen-state))
	(pen-mode self pen-mode)
	(setf (pen-state-pen-mode device-pen-state) pen-mode)))
    (unless (octet-structure-equal (pen-state-pen-pattern pen-state)
				   (pen-state-pen-pattern device-pen-state))
      (pen-pattern self (subseq pen-state
				(octet-structure-field-index
				  (pen-state-pen-pattern pen-state))
				(+ (octet-structure-field-index
				     (pen-state-pen-pattern pen-state))
				   (octet-structure-field-size
				     (pen-state-pen-pattern pen-state)))))
      (copy-octet-structure (pen-state-pen-pattern device-pen-state)
			    (pen-state-pen-pattern pen-state))))
  (let ((foreground-color (qd-state-foreground-color graphics::drawing-state)))
    (unless (eql foreground-color (qd-state-device-foreground-color graphics::drawing-state))
      (rgb-foreground-color self foreground-color)
      (setf (qd-state-device-foreground-color graphics::drawing-state) foreground-color))))

(defun-in-flavor (update-frame-state to-quickdraw-output-stream) ()
  (update-paint-state)
  (let ((pen-state (qd-state-pen-state graphics::drawing-state))
	(device-pen-state (qd-state-device-pen-state graphics::drawing-state)))
    (unless (octet-structure-equal (pen-state-pen-size pen-state)
				   (pen-state-pen-size device-pen-state))
      (pen-size self (point-x pen-state (octet-structure-field-index
					  (pen-state-pen-size pen-state)))
		     (point-y pen-state (octet-structure-field-index
					  (pen-state-pen-size pen-state))))
      (copy-octet-structure (pen-state-pen-size device-pen-state)
			    (pen-state-pen-size pen-state)))))

(defun-in-flavor (transform-rect to-quickdraw-output-stream) (left top right bottom)
  (graphics::transform-and-fix-points left top right bottom)
  (if (destructuring-bind (a b c d nil nil) (graphics:stream-transform self)
	  (or (and (= b 0) (= c 0))
	      (and (= a 0) (= d 0))))
      (values t (min left right) (min top bottom)
	      (max left right) (max top bottom))
      (values nil 0 0 0 0)))

;;; Remember that the Mac screen is also upside down relative to a Cartesian coordinate system.
;;; So, the sense of clockwise is inverted to agree with atan.
;;; Mac angles increase as you go clockwise.
;;; Lispm angles increase as you go counterclockwise.
(defun convert-to-mac-arc (start-angle end-angle clockwise)
  (declare (values mac-start-angle mac-arc-angle))
  (let* ((mac-start-angle (+ (round (* start-angle 180) pi) 90))
	 (mac-end-angle (+ (round (* end-angle 180) pi) 90))
	 (mac-arc-angle (mod (- mac-end-angle mac-start-angle) 360)))
    (values (mod mac-start-angle 360)
	    (if clockwise (- mac-arc-angle 360) mac-arc-angle))))

(defun convert-from-mac-arc (mac-start-angle mac-arc-angle)
  (declare (values start-angle end-angle clockwise))
  (let* ((start-angle (* pi (/ (mod (- mac-start-angle 90) 360) 180)))
	 (angle (* pi (/ mac-arc-angle 180))))
    (values start-angle
	    (+ start-angle angle)
	    (minusp mac-arc-angle))))

;;; A testing function...
#||
(defun mac-angle-tests ()
  (loop repeat 2 for mac-arc-angle = -90 then 90 do
    (loop for mac-start-angle from 0 to 360 by 1
	  do (multiple-value-bind (lisp-start-angle lisp-end-angle clockwise)
		 (convert-from-mac-arc mac-start-angle mac-arc-angle)
	       (multiple-value-bind (c2-mac-start-angle c2-mac-arc-angle)
		   (convert-to-mac-arc lisp-start-angle lisp-end-angle clockwise)
		 (unless (and (= mac-start-angle c2-mac-start-angle)
			      (= mac-arc-angle c2-mac-arc-angle))
		   (format t "~&MAC (~D ~D), LISP (~D ~D ~A), MAC (~D ~D)"
			   mac-start-angle mac-arc-angle lisp-start-angle
			   lisp-end-angle clockwise c2-mac-start-angle c2-mac-arc-angle)))
	       )
	     )))
||#


;;;; Graphics methods

(defmethod (color:color-stream-p to-quickdraw-output-stream) () color-p)

(defmethod (graphics::with-clipping-mask-internal to-quickdraw-output-stream) niy)
(defmethod (graphics::with-clipping-from-output-internal to-quickdraw-output-stream) niy)
(defmethod (graphics::with-clipping-path-internal to-quickdraw-output-stream) niy)

(defmethod (graphics:current-position to-quickdraw-output-stream) ()
  (let ((pen-state (qd-state-pen-state graphics::drawing-state)))
    (graphics:stream-untransform-point (pen-state-pen-x pen-state) (pen-state-pen-y pen-state)
				       self)))

(defmethod (graphics:set-current-position to-quickdraw-output-stream) (x y &key (explicit t))
  (graphics::transform-and-fix-points x y)
  (let ((pen-state (qd-state-pen-state graphics::drawing-state)))
    (setf (pen-state-pen-x pen-state) x
	  (pen-state-pen-y pen-state) y))
  (when explicit
    (setf path-initial-x x
	  path-initial-y y))
  )


(defmethod (graphics:draw-path to-quickdraw-output-stream)
	   (path-function &key (winding-rule :non-zero) (filled t))
  (ignore winding-rule)
  (if filled
      (funcall path-function self)
      (funcall path-function self)))


(defmethod (graphics:close-path to-quickdraw-output-stream)
	   (&rest ignore)
  (multiple-value-bind (x y)
      (graphics:stream-untransform-point path-initial-x path-initial-y self)
    (graphics:draw-line-to x y :stream self)))

(defmethod (graphics:draw-line-to to-quickdraw-output-stream) (x y &key)
  (update-frame-state)
  (force-pen-loc)
  (graphics::transform-and-fix-points x y)
  (let* ((pen-state (qd-state-pen-state graphics::drawing-state))
	 (pen-width (pen-state-pen-width pen-state))
	 (pen-height (pen-state-pen-height pen-state)))
    (line-to self (- x (floor pen-width 2))
	     (- y (floor pen-height 2))))
  (let ((pen-state (qd-state-pen-state graphics::drawing-state))
	(device-pen-state (qd-state-device-pen-state graphics::drawing-state)))
    (setf (pen-state-pen-x pen-state) x
	  (pen-state-pen-y pen-state) y)
    (copy-octet-structure (pen-state-pen-loc device-pen-state)
			  (pen-state-pen-loc pen-state))))
                                       
(defun-in-flavor (paint-or-frame to-quickdraw-output-stream) (filled paint frame &rest args)
  (cond ((not filled)
	 (update-frame-state)
	 (apply frame self args))
	(t
	 (update-paint-state)
	 (apply paint self args))))

(defmethod (graphics:draw-rectangle to-quickdraw-output-stream) (left top right bottom
								 &key (filled t))
  (multiple-value-bind (rect-p left top right bottom)
      (transform-rect left top right bottom)
    (if (not rect-p)
	(with-stack-list (points left top right top right bottom left bottom)
	  (apply (flavor:generic graphics:draw-polygon) self points
		 :points-are-convex-p t :filled (list filled)))
	(paint-or-frame filled #'paint-rect #'frame-rect
			left top right bottom))))

(defmethod (graphics:draw-ellipse to-quickdraw-output-stream)
	   (center-x center-y x-radius y-radius
		     &key (inner-x-radius 0)
			  (inner-y-radius (/ (* inner-x-radius y-radius) x-radius))
			  (start-angle 0) (end-angle graphics:2pi) (clockwise nil)
			  (filled t) (join-to-path nil))
  (flet ((draw-ellipse-internal (x-radius y-radius filled)
	   (let ((full-circle-p (graphics::full-circle-p start-angle end-angle))
		 (rotated-start-angle start-angle)
		 (rotated-end-angle end-angle)
		 (rotate-clockwise clockwise))
	     (when join-to-path
	       (multiple-value-bind (rotation scale-x scale-y)
		   (graphics:decompose-transform (graphics::stream-transform self))
		 (when (minusp scale-x)
		   (setq scale-x (- scale-x))
		   (setq rotated-start-angle (- pi rotated-start-angle)
			 rotated-end-angle (- pi rotated-end-angle))
		   (setq rotate-clockwise (not rotate-clockwise)))
		 (when (minusp scale-y)
		   (setq scale-y (- scale-y))
		   (setq rotated-start-angle (- rotated-start-angle)
			 rotated-end-angle (- rotated-end-angle))
		   (setq rotate-clockwise (not rotate-clockwise)))
		 (unless rotate-clockwise
		   (rotatef rotated-start-angle rotated-end-angle))
		 (unless (or full-circle-p (= scale-x scale-y))	;Still a circle
		   (unless (zerop (mod rotated-start-angle (/ pi 2)))
		     (let ((sin (sin rotated-start-angle))
			   (cos (cos rotated-start-angle)))
		       (unless (or (< (abs sin) 1e-5) (< (abs cos) 1e-5))	;...
			 (setq rotated-start-angle (atan (* sin scale-y) (* cos scale-x))))))
		   (unless (zerop (mod rotated-end-angle (/ pi 2)))
		     (let ((sin (sin rotated-end-angle))
			   (cos (cos rotated-end-angle)))
		       (unless (or (< (abs sin) 1e-5) (< (abs cos) 1e-5))	;...
			 (setq rotated-end-angle (atan (* sin scale-y) (* cos scale-x)))))))
		 (unless (zerop rotation)
		   (incf rotated-start-angle rotation)
		   (incf rotated-end-angle rotation)))
	       (multiple-value-bind (position-x ignore)
		   (graphics:current-position :stream self)
		 (when position-x
		   (graphics:draw-line-to (round (+ center-x
						    (* x-radius
						       (cos rotated-start-angle))))
					  (round (+ center-y
						    (* y-radius
						       (- (sin rotated-start-angle)))))))
		 (graphics:set-current-position (round (+ center-x
							  (* x-radius
							     (cos (if position-x
								      rotated-end-angle
								      rotated-start-angle)))))
						(round (+ center-y
							  (* y-radius
							     (- (sin (if position-x
									 rotated-end-angle
									 rotated-start-angle))))))
						:explicit (if position-x nil t))))
	     (update-frame-state)
	     (force-pen-loc)
	     (let* ((pen-state (qd-state-pen-state graphics::drawing-state))
		    (half-pen-width (floor (pen-state-pen-width pen-state) 2))
		    (half-pen-height (floor (pen-state-pen-height pen-state) 2)))
	       (multiple-value-bind (rect-p left top right bottom)
		   (transform-rect (- center-x x-radius half-pen-width)
				   (- center-y y-radius half-pen-height)
				   (+ center-x x-radius half-pen-width)
				   (+ center-y y-radius half-pen-height))
		 (cond ((not rect-p)
			(niy1 "Cannot draw tilted ellipses."))
		       ((graphics::full-circle-p start-angle end-angle)
			(paint-or-frame filled #'paint-oval #'frame-oval
					left top right bottom))
		       (t
			(multiple-value-bind (mac-start-angle mac-arc-angle)
			    (convert-to-mac-arc start-angle end-angle clockwise)
			  (paint-or-frame filled #'paint-arc #'frame-arc
					  left top right bottom
					  mac-start-angle mac-arc-angle))))))
	   )))
    (cond ((and (zerop inner-x-radius) (zerop inner-y-radius))
	   (draw-ellipse-internal x-radius y-radius filled))
	  (filled
	   (stack-let ((override-pen (make-point :x (- x-radius inner-x-radius)
						 :y (- y-radius inner-y-radius))))
	     (letf (((qd-state-override-pen-size graphics::drawing-state) override-pen))
	       (draw-ellipse-internal x-radius y-radius nil))))
	  (t
	   (draw-ellipse-internal x-radius y-radius nil)
	   (draw-ellipse-internal inner-x-radius inner-y-radius nil)))))
                                       
(defmethod (graphics:draw-polygon to-quickdraw-output-stream) (points
							       &key (points-are-convex-p nil)
								    (filled t))
  (ignore points-are-convex-p)
  (sys:with-data-stack
    (paint-or-frame filled #'paint-poly #'frame-poly
		    (graphics::transform-and-fix-point-set points t))))

(defmethod (:draw-string-size to-quickdraw-output-stream)
	   (string &optional character-style character-size &key (start 0) end)
  (declare (values total-width max-char-width total-height max-char-height max-baseline))
  (ignore character-size)			;---
  (with-character-style (character-style self)
    (let ((total-width 0)
	  (total-height 0)
	  (max-char-width 0)
	  (max-char-below-baseline 0)
	  (max-baseline 0))
      (loop for char being the array-elements of string
		from start below (or end (string-length string))
	    do
	(multiple-value-bind (font index)
	    (font-for-character char)
	  (let ((char-width (qd-font-char-width font index))
		(line-spacing (qd-font-line-spacing font))
		(baseline (qd-font-baseline font)))
	    (incf total-width char-width)
	    (incf total-height line-spacing)
	    (maxf max-char-width char-width)
	    (maxf max-char-below-baseline (- line-spacing baseline)) 
	    (maxf max-baseline baseline))))
      (values total-width max-char-width total-height
	      (+ max-char-below-baseline max-baseline) max-baseline))))

(defmethod (graphics:draw-string to-quickdraw-output-stream)
	   (string x y
		   &key (attachment-y :baseline) (attachment-x :left)
			(toward-x (1+ x)) (toward-y y)
			(stretch-p nil) (character-style nil)
			(record-as-text nil))
  (ignore record-as-text)
  (graphics::transform-and-fix-points x y toward-x toward-y)
  (unless (and (= toward-y y) ( #+Ignore > toward-x x) (not stretch-p))
    (niy1 "Cannot draw tilted or stretched string yet."))
  (force-string)
  (multiple-value-bind (width nil nil height baseline)
      (send self :draw-string-size string character-style)
    (cl:ecase attachment-x
      (:left )
      (:right (decf x width))
      (:center (decf x (floor width 2))))
    (cl:ecase attachment-y
      (:baseline )
      (:center (decf y (- baseline (floor height 2))))
      (:top (decf y baseline))
      (:bottom (incf y (- height baseline)))))
  (with-character-style (character-style self)
    (let ((pen-state (qd-state-pen-state graphics::drawing-state)))
      (let ((old-x (pen-state-pen-x pen-state))
	    (old-y (pen-state-pen-y pen-state)))
	(setf (pen-state-pen-x pen-state) x
	      (pen-state-pen-y pen-state) y)
	(send self :string-out string)
	(force-string)
	(setf (pen-state-pen-x pen-state) old-x
	      (pen-state-pen-y pen-state) old-y)))))

(defmethod (graphics:draw-string-image to-quickdraw-output-stream)
	   (string x y
		   &key (attachment-y :baseline) (attachment-x :left)
			(character-style nil) (character-size nil)
			(string-width nil) (scale-down-allowed t))
  (cond ((not (and (eq attachment-y :baseline) (eq attachment-x :left)))
	 (niy1 "Cannot do attachments yet."))
	((not (and (null character-size) (null string-width)))
	 (funcall (flavor:generic graphics:draw-string) self string x y
		  :character-style current-character-style))
	(t
	 (ignore scale-down-allowed)
	 ;--- temporary version
	 (funcall (flavor:generic graphics:draw-string) self string x y
		  :character-style character-style)))
  )

;; This started as (default-draw-bezier-curve raster-graphics-mixin),
;; and I threw away everything having to do with handling dashed lines,
;; dash pattern, thickness, etc, etc.  What's left is pretty minimal,
;; and isn't even very pretty.
(defmethod (graphics::default-draw-bezier-curve to-quickdraw-output-stream)
	   (px1 py1 px4 py4 px2 py2 px3 py3
	    &rest args
	    &key number-of-samples
	    &allow-other-keys)
  (declare (ignore args))
  (let ((eps (/ (float (or number-of-samples
			   (/ (max (- (max px4 px1 px2 px3) (min px4 px1 px2 px3))
				   (- (max py4 py1 py2 py3) (min py4 py1 py2 py3))
				   2)
			      2))))))
    (let ((tt 0) (1-tt 1))
      (labels ((line (x1 y1 x2 y2 draw-end-point)
		 (graphics:draw-line x1 y1 x2 y2
				     :line-end-shape (if draw-end-point
							 :miter :no-end-point)
				     ;; ---Should do dashed, dash pattern, thickness, etc, etc
				     :stream self))
	       (convex (a b) (+ (* a 1-tt) (* b tt)))
	       (bezier (a b c d)
		 (let ((convex-b-c (convex b c)))
		   (convex (convex (convex a b) convex-b-c)
			   (convex convex-b-c (convex c d))))))
	(let (xr yr (pxr (round px1)) (pyr (round py1)))
	  (loop
	    (incf tt eps)
	    (setq 1-tt (- 1 tt))
	    (when ( tt 1)
	      (line pxr pyr (round px4) (round py4) t)
	      (return))
	    (setq xr (round (bezier px1 px2 px3 px4))
		  yr (round (bezier py1 py2 py3 py4)))
	    (unless (and (= xr pxr) (= yr pyr))
	      (line pxr pyr (setq pxr xr) (setq pyr yr) nil))))))
    nil))


;;;; Text stuff

(defun-in-flavor (update-styles to-quickdraw-output-stream) ()
  (setq merged-current-character-style (si:merge-character-styles current-character-style
								  default-character-style)
	current-font (si:get-font display-device-type si:*standard-character-set*
				  merged-current-character-style)))

(defmethod (:with-character-style to-quickdraw-output-stream) (style continuation xstream
							       &optional ignore)
  (letf ((current-character-style (si:merge-character-styles style current-character-style))
	 (merged-current-character-style merged-current-character-style)
	 (current-font current-font))
    (update-styles)
    (funcall continuation xstream)))

(defmethod (:baseline to-quickdraw-output-stream) ()
  (qd-font-baseline current-font))

(defmethod (:line-height to-quickdraw-output-stream) ()
  (+ (qd-font-line-spacing current-font)
     (qd-font-vsp current-font)))

(defmethod (:vsp to-quickdraw-output-stream) ()
  (qd-font-vsp current-font))

(defmethod (:char-width to-quickdraw-output-stream) ()
  (qd-font-nominal-char-width current-font))

(defmethod (:character-width to-quickdraw-output-stream) (char)
  (multiple-value-bind (font index)
      (font-for-character char)
    (qd-font-char-width font index)))

(defmethod (:string-length to-quickdraw-output-stream) (string &optional (start 0) end)
  (loop for char being the array-elements of string from start
		 below (or end (string-length string))
	sum (send self :character-width char)))

(defmethod (:tyo to-quickdraw-output-stream) (char)
  (when ( (char-code char) #o200)
    (selector char char-equal
      (#\Newline
       (return-from :tyo
	 (multiple-value-bind (nil y)
	     (send self :read-cursorpos)
	   (send self :set-cursorpos 0 (+ y (send self :line-height))))))
      (#\Tab
       (return-from :tyo
	 (let ((x (send self :read-cursorpos :character)))
	   (send self :increment-cursorpos (- (* 8 (ceiling (1+ x) 8)) x) 0 :character))))
      (#\Backspace
       (return-from :tyo
	 (send self :increment-cursorpos -1 0 :character)))))
  (let ((pen-state (qd-state-pen-state graphics::drawing-state))
	(device-pen-state (qd-state-device-pen-state graphics::drawing-state)))
    (unless (octet-structure-equal (pen-state-pen-loc pen-state)
				   (pen-state-pen-loc device-pen-state))
      (force-string))
    (multiple-value-bind (font index)
	(font-for-character char)
      (unless (eq font (qd-state-device-current-font graphics::drawing-state))
	(force-string)
	(send-font font))
      (loop
	(when string-open
	  (when (vector-push index string-buffer)
	    (return))
	  (force-string))
	(open-string))
      (incf (pen-state-pen-x pen-state) (qd-font-char-width font index))
      (copy-octet-structure (pen-state-pen-loc device-pen-state)
			    (pen-state-pen-loc pen-state))))
  char)

(defmethod (:home-cursor to-quickdraw-output-stream) ()
  (send self :set-cursorpos 0 0))

(defmethod (:fresh-line to-quickdraw-output-stream) ()
  (unless (zerop (send self :read-cursorpos))
    (send self :tyo #\newline)))

(defmethod (:read-cursorpos to-quickdraw-output-stream) (&optional (unit :pixel))
  (let* ((pen-state (qd-state-pen-state graphics::drawing-state))
	 (x (pen-state-pen-x pen-state))
	 (y (- (pen-state-pen-y pen-state) (send self :baseline))))
    (ecase unit
      (:pixel )
      (:character
	(setq x (floor x (send self :char-width))
	      y (floor y (send self :line-height)))))
    (values x y)))

(defmethod (:set-cursorpos to-quickdraw-output-stream) (x y &optional (unit :pixel))
  (ecase unit
    (:pixel )
    (:character
      (when x
	(setq x (* x (send self :char-width))))
      (when y
	(setq y (* y (send self :line-height))))))
  (let ((pen-state (qd-state-pen-state graphics::drawing-state)))
    (when x
      (setf (pen-state-pen-x pen-state) x))
    (when y
      (setf (pen-state-pen-y pen-state) (+ y (send self :baseline))))))

(defmethod (:increment-cursorpos to-quickdraw-output-stream) (dx dy &optional (unit :pixel))
  (ecase unit
    (:pixel )
    (:character
      (setq dx (* dx (send self :char-width))
	    dy (* dy (send self :line-height)))))
  (let ((pen-state (qd-state-pen-state graphics::drawing-state)))
    (incf (pen-state-pen-x pen-state) dx)
    (incf (pen-state-pen-y pen-state) dy)))

(defmethod (:real-set-cursorpos to-quickdraw-output-stream) () t)	;Honest!

(defmethod (graphics::with-room-for-graphics-internal-1 to-quickdraw-output-stream)
	   (&rest args)
  (apply #'graphics::tv-with-room-for-graphics-internal-1 args))

;;;; Picture records

(defstruct (quickdraw-picture :named-array-leader
			      (:conc-name qd-picture-)
			      (:copier nil)
			      (:constructor-make-array-keywords
				(type 'sys:art-8b)
				(length 2)
				(displaced-to nil)
				(displaced-index-offset nil))
			      (:export :accessors :constructor))
  (fill-pointer 0)
  read-pointer
  bounding-box
  presentations
  unique-id-presentation-table)

(defflavor quickdraw-presentation
	((bounding-box nil)
	 unique-id
	 (chords 1))
	(dw:presentation)
  (:conc-name qd-presentation-)
  :initable-instance-variables
  :writable-instance-variables
  (:constructor make-qd-presentation (dw::object dw::type unique-id)))

;;; A stream that outputs to a Quickdraw picture
;;; start-pen-loc is the position to which the last move-to was done, or else the ending
;;; position of the last cursor moving command sent to the device.
;;; real-device-pen-loc is the position as of the last command really sent through.
;;; This is necessary because move-to cannot really take effect right away, but must just
;;; remember a position until the operation to be performed (text or line) becomes known.
(defflavor quickdraw-picture-stream
	(picture
	 format-version

	 (start-pen-loc (make-point :x -1 :y -1))
	 (real-device-pen-loc (make-point :x -1 :y -1))
	 (last-rect (dw:make-temporary-box 0 0 0 0))
	 (device-oval-size (make-point :x -1 :y -1))

	 bounding-box
	 current-presentation
	 presentations
	 presentation-unique-id
	 (sensitive-inferiors-allowed t)
	 )
	(to-quickdraw-output-stream)
  (:readable-instance-variables picture)
  (:conc-name qd-picture-stream-)
  (:constructor make-qd-picture-stream (&key color-p))
  )

(defmethod (get-font-info quickdraw-picture-stream) (&rest ignore)
  (niy self 'get-font-info))

(defmethod (get-pen-state quickdraw-picture-stream) (&rest ignore)
  (niy self 'get-pen-state))

(defun-in-flavor (extend-bounding-box-to-region quickdraw-picture-stream)
		 (left top right bottom)
  (if bounding-box
      (dw::box-extend-to-region bounding-box left top right bottom)
      (setq bounding-box (dw:make-temporary-box left top right bottom))))

(defsubst-in-flavor (append-picture-byte quickdraw-picture-stream) (byte)
  (vector-push-extend byte picture))

(defun-in-flavor (append-picture-word quickdraw-picture-stream) (word)
  (append-picture-byte (ldb (byte 8 8) word))
  (append-picture-byte (ldb (byte 8 0) word)))

(defun-in-flavor (append-picture-long quickdraw-picture-stream) (long)
  (append-picture-word (ldb (byte 16 16) long))
  (append-picture-word (ldb (byte 16 0) long)))

(defun-in-flavor (append-picture-op quickdraw-picture-stream) (op)
  (if (= format-version 1)
      (append-picture-byte op)
      (append-picture-word op)))

(defun-in-flavor (append-picture-point quickdraw-picture-stream) (x y)
  (append-picture-word y)
  (append-picture-word x))

(defun-in-flavor (append-picture-rect quickdraw-picture-stream) (left top right bottom)
  (append-picture-point left top)
  (append-picture-point right bottom))

(defun-in-flavor (append-picture-structure quickdraw-picture-stream) (structure)
  (vector-push-portion-extend picture structure))

(defun-in-flavor (maybe-pad-picture quickdraw-picture-stream) ()
  (when (and (> format-version 1)
	     (oddp (fill-pointer picture)))
    (append-picture-byte =op-noop=)))

;;; Just remember position; every operation has its own start and will use this.
;;; Also remember where device really is, since that will move along also.
(defmethod (move-to quickdraw-picture-stream) (x y)
  (set-point start-pen-loc 0 x y)
  (copy-octet-structure (point real-device-pen-loc 0)
			(pen-state-pen-loc
			  (qd-state-device-pen-state graphics::drawing-state))))

;;; Note that the string is really unsigned bytes.  Also note Genera like optional args.
(defmethod (draw-string quickdraw-picture-stream) (string &optional (start 0) end)
  (let* ((device-pen-state (qd-state-device-pen-state graphics::drawing-state))
	 (start-pen-x (point-x start-pen-loc 0))
	 (start-pen-y (point-y start-pen-loc 0))
	 (dx (- start-pen-x (point-x real-device-pen-loc 0)))
	 (dy (- start-pen-y (point-y real-device-pen-loc 0))))
    (ignore dx dy)
    (cond #+ignore #+ignore #+ignore	;Cannot seem to get these to work.
	  ((and (zerop dy) ( 0 dx 255))
	   (append-picture-op =op-dh-text=)
	   (append-picture-byte dx))
	  ((and (zerop dx) ( 0 dy 255))
	   (append-picture-op =op-dv-text=)
	   (append-picture-byte dy))
	  ((and ( 0 dx 255) ( 0 dy 255))
	   (append-picture-op =op-dhdv-text=)
	   (append-picture-byte dx)
	   (append-picture-byte dy))
	  (t
	   (append-picture-op =op-long-text=)
	   (append-picture-point start-pen-x start-pen-y)))
    (let* ((left start-pen-x)
	   (top (- start-pen-y (send self :baseline)))
	   (right (pen-state-pen-x device-pen-state))
	   (bottom (+ top (- (send self :line-height) (send self :vsp)))))
      (extend-bounding-box-to-region left top right bottom))
    (vector-push-extend (sys:vector-length string) picture)
    (vector-push-portion-extend picture string start end)
    (maybe-pad-picture)
    (copy-octet-structure (point start-pen-loc 0)
			  (pen-state-pen-loc device-pen-state))
    (copy-octet-structure (point real-device-pen-loc 0)
			  (pen-state-pen-loc device-pen-state))))

(defmethod (text-font quickdraw-picture-stream) (number)
  (append-picture-op =op-text-font=)
  (append-picture-word number))

(defmethod (text-face quickdraw-picture-stream) (face)
  (append-picture-op =op-text-face=)
  (append-picture-byte face)
  (maybe-pad-picture))

(defmethod (text-size quickdraw-picture-stream) (size)
  (append-picture-op =op-text-size=)
  (append-picture-word size))

(defmethod (text-mode quickdraw-picture-stream) (mode)
  (append-picture-op =op-text-mode=)
  (append-picture-word mode))

(defmethod (pen-mode quickdraw-picture-stream) (mode)
  (append-picture-op =op-pen-mode=)
  (append-picture-word mode))

(defmethod (pen-pattern quickdraw-picture-stream) (pattern)
  (append-picture-op =op-pen-pattern=)
  (append-picture-structure pattern))

(defmethod (pen-size quickdraw-picture-stream) (x y)
  (append-picture-op =op-pen-size=)
  (append-picture-point x y))

(defmethod (rgb-background-color quickdraw-picture-stream) (rgb-color)
  (append-picture-op =op-rgb-background-color=)
  (append-picture-structure rgb-color))

(defmethod (rgb-foreground-color quickdraw-picture-stream) (rgb-color)
  (append-picture-op =op-rgb-foreground-color=)
  (append-picture-structure rgb-color))

(defmethod (line-to quickdraw-picture-stream) (x y)
  (let* ((device-pen-state (qd-state-device-pen-state graphics::drawing-state))
	 (start-x (point-x start-pen-loc 0))
	 (start-y (point-y start-pen-loc 0))
	 (move-first (not (octet-structure-equal
			    (point start-pen-loc 0) (point real-device-pen-loc 0))))
	 (dx (- x start-x))
	 (dy (- y start-y)))
    (cond ((and (< (integer-length dx) 8)
		(< (integer-length dy) 8))
	   (append-picture-op (if move-first =op-short-line= =op-short-line-from=))
	   (when move-first
	     (append-picture-point start-x start-y))
	   (append-picture-byte dx)
	   (append-picture-byte dy))
	  (t
	   (append-picture-op (if move-first =op-line= =op-line-from=))
	   (when move-first
	     (append-picture-point start-x start-y))
	   (append-picture-point x y)))
    (extend-bounding-box-to-region (min x start-x) (min y start-y)
				   (max x start-x) (max y start-y))
    (setf (pen-state-pen-x device-pen-state) x
	  (pen-state-pen-y device-pen-state) y)
    (copy-octet-structure (point start-pen-loc 0) (pen-state-pen-loc device-pen-state))
    (copy-octet-structure (point real-device-pen-loc 0) (pen-state-pen-loc device-pen-state))
))

(defun-in-flavor (append-rect-op quickdraw-picture-stream)
		 (op left top right bottom)
  (if (dw::box-equals-region-p last-rect left top right bottom)
      (append-picture-op (+ op #x08))		;...Same...
    (dw::set-box-edges last-rect left top right bottom)
    (append-picture-op op)
    (append-picture-rect left top right bottom)
    (extend-bounding-box-to-region left top right bottom)))

(defmethod (frame-rect quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-frame-rect= left top right bottom))

(defmethod (paint-rect quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-paint-rect= left top right bottom))

(defmethod (erase-rect quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-erase-rect= left top right bottom))

(defmethod (invert-rect quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-invert-rect= left top right bottom))

(defmethod (fill-rect quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-fill-rect= left top right bottom))

(defun-in-flavor (update-oval-size quickdraw-picture-stream) (oval-width oval-height)
  (unless (and (= oval-width (point-x device-oval-size 0))
	       (= oval-height (point-y device-oval-size 0)))
    (append-picture-op =op-oval-size=)
    (append-picture-point oval-width oval-height)))

(defmethod (frame-round-rect quickdraw-picture-stream) (left top right bottom
							oval-width oval-height)
  (update-oval-size oval-width oval-height)
  (append-rect-op =op-frame-round-rect= left top right bottom))

(defmethod (paint-round-rect quickdraw-picture-stream) (left top right bottom
							oval-width oval-height)
  (update-oval-size oval-width oval-height)
  (append-rect-op =op-paint-round-rect= left top right bottom))

(defmethod (erase-round-rect quickdraw-picture-stream) (left top right bottom
							oval-width oval-height)
  (update-oval-size oval-width oval-height)
  (append-rect-op =op-erase-round-rect= left top right bottom))

(defmethod (invert-round-rect quickdraw-picture-stream) (left top right bottom
							 oval-width oval-height)
  (update-oval-size oval-width oval-height)
  (append-rect-op =op-invert-round-rect= left top right bottom))

(defmethod (fill-round-rect quickdraw-picture-stream) (left top right bottom
						       oval-width oval-height)
  (update-oval-size oval-width oval-height)
  (append-rect-op =op-fill-round-rect= left top right bottom))

(defmethod (frame-oval quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-frame-oval= left top right bottom))

(defmethod (paint-oval quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-paint-oval= left top right bottom))

(defmethod (erase-oval quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-erase-oval= left top right bottom))

(defmethod (invert-oval quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-invert-oval= left top right bottom))

(defmethod (fill-oval quickdraw-picture-stream) (left top right bottom)
  (append-rect-op =op-fill-oval= left top right bottom))

(defun-in-flavor (append-arc-op quickdraw-picture-stream) (op left top right bottom
							   start-angle arc-angle)
  (append-rect-op op left top right bottom)
  (append-picture-word start-angle)
  (append-picture-word arc-angle))

(defmethod (frame-arc quickdraw-picture-stream) (left top right bottom start-angle arc-angle)
  (append-arc-op =op-frame-arc= left top right bottom start-angle arc-angle))

(defmethod (paint-arc quickdraw-picture-stream) (left top right bottom start-angle arc-angle)
  (append-arc-op =op-paint-arc= left top right bottom start-angle arc-angle))

(defmethod (erase-arc quickdraw-picture-stream) (left top right bottom start-angle arc-angle)
  (append-arc-op =op-erase-arc= left top right bottom start-angle arc-angle))

(defmethod (invert-arc quickdraw-picture-stream) (left top right bottom start-angle arc-angle)
  (append-arc-op =op-invert-arc= left top right bottom start-angle arc-angle))

(defmethod (fill-arc quickdraw-picture-stream) (left top right bottom start-angle arc-angle)
  (append-arc-op =op-fill-arc= left top right bottom start-angle arc-angle))

(defun-in-flavor (append-poly-op quickdraw-picture-stream) (op points)
  (let ((min-x nil) (min-y nil)
	(max-x nil) (max-y nil))
    (graphics:map-points #'(lambda (x y &optional ignore)
			     (minf-or min-x x) (minf-or min-y y)
			     (maxf-or max-x x) (maxf-or max-y y))
			 points)
    (extend-bounding-box-to-region min-x min-y max-x max-y)
    (append-picture-op op)
    (append-picture-word (+ 10 (* (length points) 2)))	;Length of poly
    (append-picture-rect min-x min-y max-x max-y)
    (graphics:map-points #'(lambda (x y &optional ignore)
			     (append-picture-point x y))
			 points)))

(defmethod (frame-poly quickdraw-picture-stream) (points)
  (append-poly-op =op-frame-poly= points))

(defmethod (paint-poly quickdraw-picture-stream) (points)
  (append-poly-op =op-paint-poly= points))

(defmethod (erase-poly quickdraw-picture-stream) (points)
  (append-poly-op =op-erase-poly= points))

(defmethod (invert-poly quickdraw-picture-stream) (points)
  (append-poly-op =op-invert-poly= points))

(defmethod (fill-poly quickdraw-picture-stream) (points)
  (append-poly-op =op-fill-poly= points))

(defun-in-flavor (append-region-op quickdraw-picture-stream) (op region)
  (append-picture-op op)
  (ignore region)
  (niy1 "Cannot APPEND-REGION-OP yet"))

(defmethod (set-clip quickdraw-picture-stream) (region)
  (append-region-op =op-clip-region= region))

(defmethod (frame-region quickdraw-picture-stream) (region)
  (append-region-op =op-frame-region= region))

(defmethod (paint-region quickdraw-picture-stream) (region)
  (append-region-op =op-paint-region= region))

(defmethod (erase-region quickdraw-picture-stream) (region)
  (append-region-op =op-erase-region= region))

(defmethod (invert-region quickdraw-picture-stream) (region)
  (append-region-op =op-invert-region= region))

(defmethod (fill-region quickdraw-picture-stream) (region)
  (append-region-op =op-fill-region= region))

(defmethod (background-pattern quickdraw-picture-stream) (pattern)
  (append-picture-op =op-background-pattern=)
  (append-picture-structure pattern))

(defmethod (set-origin quickdraw-picture-stream) (dx dy)
  (append-picture-op =op-origin=)
  (append-picture-word dx)
  (append-picture-word dy))

(defmethod (space-extra quickdraw-picture-stream) (extra)
  (append-picture-op =op-space-extra=)
  (append-picture-word extra))

(defmethod (text-ratio quickdraw-picture-stream) (num-x num-y den-x den-y)
  (append-picture-op =op-text-ratio=)
  (append-picture-point num-x num-y)
  (append-picture-point den-x den-y))

(defmethod (string-width quickdraw-picture-stream) (string &optional (start 0) end)
  (loop for index being the array-elements of string from start below (or end (length string))
	sum (qd-font-char-width current-font index)))

(defmethod (picture-comment quickdraw-picture-stream) (kind &optional data)
  (append-picture-op (if data =op-long-comment= =op-short-comment=))
  (append-picture-word kind)
  (when data
    (append-picture-word (length data))
    (vector-push-portion-extend picture data)))

(defun-in-flavor (draw-image-internal quickdraw-picture-stream)
		 (image left top image-left image-top image-right image-bottom
			&optional color-map)
  (qd-state-update-pen-state-and-color graphics::drawing-state self color-p)
  (when (or (plusp image-left) (plusp image-top))
    (let ((copy (graphics::make-raster-array-with-correct-width
		  (- image-right image-left) (- image-bottom image-top)
		  :element-type (array-element-type image))))
      (bitblt boole-1 (- image-right image-left) (- image-bottom image-top)
	      image image-left image-top
	      copy 0 0)
      (psetq image copy
	     image-left 0 image-top 0
	     image-right (- image-right image-left)
	     image-bottom (- image-bottom image-top))))
  (let* ((depth (sys:array-element-byte-size image))
	 (pixmap-p (> format-version 1))
	 (row-bytes (* (ceiling (* image-right depth) 16) 2))
	 (direct-p (= depth 32))
	 (pack-p ( row-bytes 8))
	 (real-wide-p (> row-bytes 250)))
    (append-picture-op (cond (direct-p =op-direct-bits-rect=)
			     (pack-p =op-pack-bits-rect=)
			     (t =op-bits-rect=)))
    (when direct-p
      (append-picture-long #xFF))
    (append-picture-word (dpb (if pixmap-p 1 0) (byte 1 15) row-bytes))
    (append-picture-rect 0 0 (/ (* row-bytes 8) depth) image-bottom)
    (when pixmap-p
      (append-picture-word 0)			;version
      (append-picture-word (if direct-p 4 0))	;pack type
      (append-picture-long 0)			;pack size
      (append-picture-long (un-fixed-point 100.0))	;horizontal-resolution
      (append-picture-long (un-fixed-point 100.0))	;vertical-resolution
      (append-picture-word (if direct-p 16 0))	;pixel type
      (append-picture-word depth)		;pixel size
      (append-picture-word (if direct-p 3 1))	;component count
      (append-picture-word (if direct-p 8 depth))	;component size
      (dotimes (ignore 3) (append-picture-long 0))	;plane bytes, color table, reserved
      (unless direct-p
	(append-picture-long 0)			;seed
	(append-picture-word 0)			;flags
	(let ((ncells (if color-map
			  (send color-map :size)
			  (ash 1 depth))))
	  (append-picture-word (1- ncells))	;size
	  (dotimes (i ncells)		;color table
	    (append-picture-word i)		;pixel value
	    (if color-map
		(multiple-value-bind (r g b)
		    (send color-map :read-color-map i)
		  (append-picture-word (round (* r (1- 1_16))))
		  (append-picture-word (round (* g (1- 1_16))))
		  (append-picture-word (round (* b (1- 1_16)))))
		(let ((value (round (* i (1- 1_16)) (1- ncells))))
		  (dotimes (ignore 3)
		    (append-picture-word value))))))))
    (append-picture-rect image-left image-top image-right image-bottom)
    (let ((right (+ left image-right))
	  (bottom (+ top image-bottom)))
      (graphics::transform-and-fix-points left top right bottom)
      (append-picture-rect left top right bottom)
      (extend-bounding-box-to-region left top right bottom))
    (append-picture-word (pat-mode-src-mode
			   (pen-state-pen-mode
			     (qd-state-pen-state graphics::drawing-state))))
    (let ((span-row-bytes (multiple-value-bind (nil nil span)
			      (decode-raster-array image)
			    (/ (* span depth) 8))))
      (stack-let ((bytes (make-array (* image-bottom span-row-bytes)
				     :element-type '(unsigned-byte 8)
				     :displaced-to image))
		  (packed (make-array span-row-bytes :element-type '(unsigned-byte 8)
						     :fill-pointer 0))
		  (reverse-p (< depth 8)))	;--- Not good enough for 2 and 4 bit.
	(loop for y from 0 by span-row-bytes repeat image-bottom do
	  (if (not pack-p)
	      (loop for x from y repeat row-bytes do
		(let ((byte (aref bytes x)))
		  (when reverse-p
		    (setq byte (bit-reverse-8 byte)))
		  (append-picture-byte byte)))
	    (setf (fill-pointer packed) 0)
	    (if (not direct-p)
		(pack-bits bytes packed :start1 y :end1 (+ y row-bytes)
					:bit-reverse-p reverse-p)
		(stack-let* ((component-width (/ row-bytes 4))
			     (components (make-array component-width
						     :element-type '(unsigned-byte 8))))
		  (dotimes (i 3)
		    (loop for j below component-width
			  for x from (+ y i) by 4 do
		      (setf (aref components j) (aref bytes x)))
		    ;; Separately encode each component.
		    (pack-bits components packed :bit-reverse-p nil))))
	    (funcall (if real-wide-p #'append-picture-word #'append-picture-byte)
		     (fill-pointer packed))
	    (vector-push-portion-extend picture packed)))))
    ;; Packed result might not align.
    (when pack-p
      (maybe-pad-picture))))

(defmethod (graphics:draw-image quickdraw-picture-stream)
	   (image left top
		  &key (image-left 0) (image-top 0)
		       (image-right nil) (image-bottom nil)
		       (copy-image nil))
  (ignore copy-image)
  (multiple-value-bind (width height)
      (decode-raster-array image)
    (unless image-right
      (setq image-right width))
    (unless image-bottom
      (setq image-bottom height)))
  (draw-image-internal image left top image-left image-top image-right image-bottom))

(defun-in-flavor (end-presentation-output quickdraw-picture-stream) (presentation)
  (if current-presentation
      (push presentation (dw:presentation-inferiors current-presentation))
      (push presentation presentations))
  (if bounding-box
      (dw::box-extend-to-box bounding-box (qd-presentation-bounding-box presentation))
      (setq bounding-box (dw::copy-box (qd-presentation-bounding-box presentation)))))

(defmethod (:output-as-presentation-1 quickdraw-picture-stream)
	   (continuation continuation-args
	    &key (object nil)
		 (type t)
		 (allow-sensitive-inferiors t)
		 (redisplay-place-holder nil)
	    &allow-other-keys)
  (cond ((or (null type)
	     (and (listp type)
		  (eq (first type) 'expression)
		  (not (getf (rest type) :escape 't))
		  (stringp object))
	     redisplay-place-holder
	     (null sensitive-inferiors-allowed))
	 (apply continuation continuation-args)
	 nil)
	(t
	 (let ((presentation (make-qd-presentation object type
						   (prog1 presentation-unique-id
							  (incf presentation-unique-id)))))
	   (letf ((sensitive-inferiors-allowed allow-sensitive-inferiors)
		  (current-presentation presentation)
		  (bounding-box nil))
	     (multiple-value-prog1
	       (apply continuation continuation-args)
	       (force-string)
	       (if bounding-box
		   (setf (qd-presentation-bounding-box presentation) bounding-box)
		   (setq presentation nil))))	;Empty after all
	   (when presentation
	     (end-presentation-output presentation))
	   presentation))))

(defmethod (:output-as-presentation quickdraw-picture-stream) (continuation xstream &rest object-options)
  (stack-let ((continuation-args (list xstream)))
    (lexpr-send self :output-as-presentation-1 continuation continuation-args object-options)))

(defmethod (dw::push-presentation-stack quickdraw-picture-stream) (output-stack &rest options)
  (force-string)
  (let ((displayed-presentation
	  (catch 'coroutine
	    (lexpr-send self :output-as-presentation-1
			(lambda ()
			  (declare (sys:downward-function))
			  (throw 'coroutine current-presentation))
			()
			options))))
    (when current-presentation
      (setf (qd-presentation-bounding-box current-presentation) bounding-box))
    (cl:vector-push-extend (or current-presentation bounding-box) output-stack)
    (setq current-presentation displayed-presentation
	  bounding-box nil)))

(defmethod (dw::pop-presentation-stack quickdraw-picture-stream) (output-stack)
  (force-string)
  (let ((displayed-presentation current-presentation))
    (if bounding-box
	(setf (qd-presentation-bounding-box displayed-presentation) bounding-box)
	(setq displayed-presentation nil))
    (setq current-presentation (vector-pop output-stack)
	  bounding-box (cond ((null current-presentation) nil)
			     ((typep current-presentation 'dw::box)
			      (prog1 current-presentation (setq current-presentation nil)))
			     (t
			      (qd-presentation-bounding-box current-presentation))))
    (when displayed-presentation
      (end-presentation-output displayed-presentation))
    displayed-presentation))

(defmethod (:print quickdraw-picture-stream) (&rest args)
  (cl:apply #'si:print-with-sensitivity self args))

(defmethod (:gprint quickdraw-picture-stream) (object suggested-format xstream)
  (si:gprint-with-sensitivity xstream object suggested-format))

(defmethod (make-instance quickdraw-picture-stream) (&key &allow-other-keys)
  (qd-picture-stream-open-picture self))

(defmethod (make-instance to-quickdraw-output-stream :after) (&key &allow-other-keys)
  (update-styles)
  (send self :home-cursor))

(defmethod (:close quickdraw-picture-stream) (&optional abort-p)
  (unless abort-p
    (qd-picture-stream-close-picture self)))

(defmethod (qd-picture-stream-open-picture quickdraw-picture-stream) ()
  (setq format-version (if color-p 2 1))
  (setq picture (make-quickdraw-picture :length 100))
  (setf (fill-pointer picture)
	(if (= format-version 1)
	    (+ 2 8 2 11)	;size word + bounding rect + version + clip region
	    (+ 2 8 4 2 24 2 12)))	;"" + "" + "" + reserved + hilite + ""
  (setq bounding-box nil
	current-presentation nil
	presentations nil
	presentation-unique-id 1))

(defmethod (qd-picture-stream-close-picture quickdraw-picture-stream) ()
  (force-string)
  (append-picture-op =op-end-of-picture=)
  (when (null bounding-box)
    (setq bounding-box (dw:make-box 0 0 0 0)))
  (let ((length (fill-pointer picture)))
    (multiple-value-bind (left top right bottom)
	(dw:box-edges bounding-box)
      (letf (((fill-pointer picture) 0))
	(append-picture-word length)
	(append-picture-rect left top right bottom)
	(append-picture-op =op-picture-version=)
	(cond ((= format-version 1)
	       (append-picture-byte format-version))
	      (t
	       (append-picture-byte format-version)
	       (append-picture-byte -1)
	       (append-picture-op #x0c00)
	       (dotimes (ignore 24)
		 (append-picture-byte -1))
	       (append-picture-op =op-default-hilite=)))
	(append-picture-op =op-clip-region=)
	(append-picture-word 10)
	(append-picture-rect left top right bottom))))
  (setf (qd-picture-bounding-box picture) bounding-box
	(qd-picture-presentations picture) presentations)
  (let ((array (make-array presentation-unique-id)))
    (labels ((store-presentation (presentation)
	       (setf (aref array (qd-presentation-unique-id presentation)) presentation)
	       (map () #'store-presentation (dw:presentation-inferiors presentation))))
      (map () #'store-presentation presentations))
    (setf (qd-picture-unique-id-presentation-table picture) array)))

(defmacro with-output-to-quickdraw-picture ((&optional stream &rest args) &body body)
  (dw:format-output-macro-default-stream stream)
  `(with-output-to-qd-picture-1 (lambda (,stream) . ,body) . ,args))

(defun with-output-to-qd-picture-1 (continuation &rest args)
  (let ((stream (apply #'make-qd-picture-stream args)))
    (with-open-stream (stream stream)
      (funcall continuation stream))
    (qd-picture-stream-picture stream)))

(compile-flavor-methods quickdraw-picture-stream quickdraw-presentation)

;;;; Streams that translate from Quickdraw

(defflavor from-quickdraw-output-stream
	((text-cursor-x 0)
	 (text-cursor-y 0))
	(basic-quickdraw-stream)
  (:required-methods draw-string-dh draw-string-dhdv draw-string-dv draw-string-from
		     line-from line-from-to short-comment long-comment
		     note-noop note-end-of-picture note-fill-pattern note-oval-size
		     note-picture-format-version note-picture-frame note-picture-length
		     note-reserved-header note-apple-reserved))

(defmethod (draw-string-dh from-quickdraw-output-stream :default) (dx string)
  (incf text-cursor-x dx)
  (draw-string self string))

(defmethod (draw-string-dhdv from-quickdraw-output-stream :default) (dx dy string)
  (incf text-cursor-x dx)
  (incf text-cursor-y dy)
  (draw-string self string))

(defmethod (draw-string-dv from-quickdraw-output-stream :default) (dy string)
  (incf text-cursor-y dy)
  (draw-string self string))

(defmethod (draw-string-from from-quickdraw-output-stream :default) (x y string)
  (setq text-cursor-x x)
  (setq text-cursor-y y)
  (draw-string self string))

(defmethod (line-from from-quickdraw-output-stream :default) (start-x start-y dx dy)
  (move-to self start-x start-y)
  (line self dx dy))

(defmethod (line-from-to from-quickdraw-output-stream :default) (start-x start-y x y)
  (move-to self start-x start-y)
  (line-to self x y))

(defmethod (long-comment from-quickdraw-output-stream :default) (kind data)
  (picture-comment self kind data))

(defmethod (short-comment from-quickdraw-output-stream :default) (kind)
  (picture-comment self kind))

(defmethod (picture-comment from-quickdraw-output-stream :default) (kind &optional data)
  (ignore kind data)
  )

(defmethod (set-clip from-quickdraw-output-stream :default) (&rest ignore) )

(defmethod (note-noop from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-end-of-picture from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-fill-pattern from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-oval-size from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-picture-format-version from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-picture-frame from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-picture-length from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-reserved-header from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (note-apple-reserved from-quickdraw-output-stream :default) (&rest ignore)
  )

(defmethod (default-hilite from-quickdraw-output-stream :default) () )

(defmethod (rgb-hilite-color from-quickdraw-output-stream :default) (ignore) )

(defmethod (rgb-op-color from-quickdraw-output-stream :default) (ignore) )

;;; Stream that translates from Quickdraw to the Genera output stream protocol.
(defflavor from-quickdraw-drawing-stream
	((output-stream *standard-output*)
	 (pen-state (copy-seq *normal-pen-state*))
	 (foreground-color nil)
	 (text-mode =src-or=)
	 (text-font 4)
	 (text-size 9)
	 (text-face 0)
	 (last-rect (dw:make-temporary-box 0 0 0 0))
	 (last-poly nil)
	 (last-region nil))
	(from-quickdraw-output-stream)
  (:constructor make-from-quickdraw-drawing-stream (&key output-stream)))

(defmethod (background-pattern from-quickdraw-drawing-stream) niy)
(defmethod (rgb-background-color from-quickdraw-drawing-stream) niy)
(defmethod (space-extra from-quickdraw-drawing-stream) niy)
(defmethod (text-ratio from-quickdraw-drawing-stream) niy)

(defmethod (set-origin from-quickdraw-drawing-stream) (dx dy)
  (graphics:graphics-translate dx dy :stream output-stream))

(defmethod (pen-pattern from-quickdraw-drawing-stream) (pattern)
  (copy-octet-structure (pen-state-pen-pattern pen-state) (pattern pattern 0)))

(defmethod (rgb-foreground-color from-quickdraw-drawing-stream) (rgb-color)
  (setq foreground-color rgb-color))

(defmethod (pen-mode from-quickdraw-drawing-stream) (mode)
  (setf (pen-state-pen-mode pen-state) mode))

(defmethod (text-mode from-quickdraw-drawing-stream) (mode)
  (setq text-mode mode))

(defmethod (text-font from-quickdraw-drawing-stream) (font)
  (setq text-font font))

(defmethod (text-face from-quickdraw-drawing-stream) (face)
  (setq text-face face))

(defmethod (text-size from-quickdraw-drawing-stream) (size)
  (setq text-size size))

;;; This takes either a pat mode or a src mode and converts to an ALU function.
(defun convert-mode-to-alu (mode)
  (aref '#,(vector boole-1		;=src-copy= 0
		   boole-ior		;=src-or= 1
		   boole-xor		;=src-xor= 2
		   boole-andc1		;=src-bic= 3
		   boole-c1		;=not-src-copy= 4
		   boole-orc1		;=not-src-or= 5
		   boole-eqv		;=not-src-xor= 6
		   boole-and)		;=not-src-bic= 7
        (logand mode 7)))

(defun pen-state-drawing-args (pen-state &key color mode text-mode stream)
  (let ((value (and stream (list :stream stream))))
    (when color
      (let ((r (rgb-color-red color 0))
	    (g (rgb-color-green color 0))
	    (b (rgb-color-blue color 0)))
	(unless (and (zerop r) (zerop g) (zerop b))
	  (setf (getf value :color)
		(color:make-color :red (/ r (float (1- 1_15)))
				  :green (/ g (float (1- 1_15)))
				  :blue (/ b (float (1- 1_15))))))))
    (case mode
      (:text
	(setf (getf value :alu) (convert-mode-to-alu text-mode))
	(setf (getf value :opaque) nil))
      (:pen
	(let ((width (point-x pen-state (octet-structure-field-index
					  (pen-state-pen-size pen-state)))))
	  ;; ---Quickdraw allows non-square pen shape (widthheight).
	  ;; If width or height is < 1, it doesn't draw.  Inside Mac I-151.
	  (unless (eql width 1)
	    (setf (getf value :thickness) width)))
	(let ((pen-mode (pen-state-pen-mode pen-state)))
	  (unless (= pen-mode =pat-copy=)
	    (setf (getf value :alu) (convert-mode-to-alu pen-mode))))
	(let ((pen-pattern (subseq pen-state
				   (octet-structure-field-index
				     (pen-state-pen-pattern pen-state))
				   (+ (octet-structure-field-index
					(pen-state-pen-pattern pen-state))
				      (octet-structure-field-size
					(pen-state-pen-pattern pen-state))))))
	  (when (find #o377 pen-pattern :test #')
	    (setf (getf value :stipple) (convert-pattern-to-raster pen-pattern))))))
    value))

(defun-in-flavor (get-drawing-args from-quickdraw-drawing-stream) (&key mode)
  (pen-state-drawing-args pen-state :color foreground-color
			  :mode mode :text-mode text-mode
			  :stream output-stream))

(defmethod (get-pen-state from-quickdraw-drawing-stream) () pen-state)

(defmethod (pen-size from-quickdraw-drawing-stream) (x y)
  (set-point pen-state (octet-structure-field-index (pen-state-pen-size pen-state)) x y))

(defmethod (move-to from-quickdraw-drawing-stream) (x y)
  (set-point pen-state (octet-structure-field-index (pen-state-pen-loc pen-state)) x y))

(defmethod (line-to from-quickdraw-drawing-stream) (x y)
  (apply #'graphics:draw-line (pen-state-pen-x pen-state) (pen-state-pen-y pen-state) x y
	 (get-drawing-args :mode :pen))
  (set-point pen-state (octet-structure-field-index (pen-state-pen-loc pen-state)) x y))

(defsubst-in-flavor (get-font from-quickdraw-drawing-stream) ()
  (mac-bfd-for-font text-font text-size text-face))

(defun qd-string-width-internal (bfd string &optional (start 0) end)
  (loop for index being the array-elements of string
	    from start below (or end (length string))
	sum (fed:bcd-set-width
	      (or (and (< index (fed:bfd-fill-pointer bfd)) (aref bfd index))
		  (getf (fed:bfd-plist bfd) :missing-symbol)))))

(defmethod (string-width from-quickdraw-drawing-stream) (string &optional (start 0) end)
  (let ((bfd (get-font)))
    (qd-string-width-internal bfd string start end)))

(defmethod (get-font-info from-quickdraw-drawing-stream) ()
  (declare (values ascent descent width-max leading))
  (let ((bfd (get-font)))
    (values (fed:bfd-baseline bfd)
	    (- (fed:bfd-line-spacing bfd) (fed:bfd-baseline bfd))
	    (fed:bfd-char-width bfd)
	    (getf (fed:bfd-plist bfd) :vsp))))

(defun qd-draw-string-internal (bfd stream string x y
				&optional (start 0) end &rest drawing-args)
  (loop for index being the array-elements of string
	    from start below (or end (length string))
	do
    (let ((bcd (or (and (< index (fed:bfd-fill-pointer bfd)) (aref bfd index))
		   (getf (fed:bfd-plist bfd) :missing-symbol))))
      (apply #'graphics:draw-image bcd
	     (- x (fed:bcd-left-kern bcd))
	     (- y (+ (fed:bfd-baseline bfd) (fed:bcd-top-kern bcd)))
	     :image-right (fed::bcd-raster-width bcd) :stream stream
	     drawing-args)
      (incf x (fed:bcd-set-width bcd))))
  (values x y))

(defmethod (draw-string from-quickdraw-drawing-stream) (string &optional (start 0) end)
  (let* ((drawing-args (get-drawing-args :mode :text))
	 (bfd (get-font)))
    (let* ((old-alu (getf drawing-args :alu))
	   (new-alu
	     (case old-alu
	       (#.boole-ior :draw)
	       (#.boole-andc1 :erase)
	       (#.boole-xor :flip))))
      (when new-alu (setf (getf drawing-args :alu) new-alu)))
    (when bfd					;can't draw a font you don't have
      (apply #'qd-draw-string-internal bfd output-stream string
	     text-cursor-x text-cursor-y start end drawing-args))))

(defmacro define-drawing-graf-operations ((base-noun same-args same-setter
					   &rest different-args)
					  arglist &body body)
  `(progn
     . ,(loop for verb in *graf-verbs*
	      nconc (loop for same-p in '(t nil)
			  collect (let ((operation (intern
						     (string-upcase
						       (string-append verb
								      (if same-p "-same-" "-")
								      base-noun)))))
				    `(defmethod (,operation from-quickdraw-drawing-stream)
						(,@(and (not same-p) same-args)
						 ,@different-args
						 ,@(and (equal verb "fill") '(fill-pattern)))
				       ,(unless same-p same-setter)
				       (apply #'(lambda ,arglist . ,body)
					,@(selector verb equal
					    ("frame" '(:filled nil))
					    ("paint" nil)
					    ("erase" '(:alu :erase))
					    ("invert" '(:alu :flip))
					    ("fill" '(:stipple (convert-pattern-to-raster
								 fill-pattern))))
					(get-drawing-args
					  . ,(and (member verb '("frame" "paint") :test #'equal)
							  '(:mode :pen))))))))))

(define-drawing-graf-operations ("rect"
				 (left top right bottom)
				 (dw::set-box-edges last-rect left top right bottom))
				(&rest args)
  (multiple-value-bind (left top right bottom)
      (dw:box-edges last-rect)
    ;;Quickdraw won't draw if pen size<1: IM.I-151
    ;; This thickness=0 kludge should be propagated to all QD drawing
    (unless (and (null (getf args :filled T)) (eql (getf args :thickness) 0))
      (apply #'graphics:draw-rectangle left top right bottom args))))

(define-drawing-graf-operations ("round-rect"
				 (left top right bottom)
				 (dw::set-box-edges last-rect left top right bottom)
				 oval-width oval-height)
				(&rest args)
  (multiple-value-bind (left top right bottom)
      (dw:box-edges last-rect)
    ;; draw-rounded-corner-lines doesn't allow
    ;; differing oval-width/oval-height (although I
    ;; suppose maybe I could kludge it with different
    ;; graphics scale in Y than X) and I can never get
    ;; it to do what I want anyway.  Too bad, it seems
    ;; simpler.
    (apply #'draw-round-rect left top right bottom oval-width oval-height args)))

(defun draw-round-rect (left top right bottom oval-width oval-height &rest args)
  (apply #'graphics:draw-path 
	 (named-lambda draw-path (stream)
	   (draw-round-rect-path stream left top right bottom oval-width oval-height))
	 :allow-other-keys T
	 args))

(defun draw-round-rect-path (stream left top right bottom oval-width oval-height)
  (let* ((width (- right left))
	 (height (- bottom top))
	 (pi/2 (/ pi 2))
	 (-pi/2 (- pi/2)))
    (let ((ow2 (/ (min width oval-width) 2))
	  (oh2 (/ (min height oval-height) 2))
	  (did-one nil))
      (labels ((doing-one (x y)
		 (unless did-one
		   (setq did-one T)
		   (graphics:set-current-position x y :stream stream)))
	       (e (cx cy start-angle end-angle)
		 (graphics:draw-ellipse cx cy ow2 oh2
					:start-angle start-angle
					:end-angle end-angle
					:filled nil
					:clockwise t
					:stream stream))
	       (l (x1 y1 x2 y2) (graphics:draw-line x1 y1 x2 y2 :stream stream)))
	(if (> width oval-width)
	    (if (> height oval-height)
		(progn
		  (e (+ left ow2) (+ top oh2) pi pi/2)	; top left
		  (doing-one left (+ top oh2))
		  (l (+ left ow2) top (- right ow2) top)	; top
		  (e (- right ow2) (+ top oh2) pi/2 0)	; top right
		  (l right (+ top oh2) right (- bottom oh2))	; right
		  (e (- right ow2) (- bottom oh2) 0 -pi/2)	; bottom right
		  (l (- right ow2) bottom (+ left ow2) bottom)	; bottom
		  (e (+ left ow2) (- bottom oh2) -pi/2 pi)	; bottom left
		  (l left (- bottom oh2) left (+ top oh2)))	; left
		(progn
		  ;; not so tall as oval-height, so no left/right sides
		  (doing-one left (+ top oh2))
		  (e (+ left ow2) (+ top oh2) -pi/2 pi/2)	;left
		  (l (+ left ow2) top (- right ow2) top)	;top
		  (e (- right ow2) (+ top oh2) pi/2 -pi/2)	;right
		  (l (- right ow2) bottom (+ left ow2) bottom)))
	    (if (> height oval-height)
		(progn
		  ;; not so wide as oval-width, so no top/bottom sides
		  (doing-one (+ left ow2) (+ top oh2))
		  (e (+ left ow2) (+ top oh2) pi 0)	;top
		  (l right (+ top oh2) right (- bottom oh2))	;right
		  (e (- right ow2) (- bottom oh2) 0 pi)	;bottom
		  (l left (- bottom oh2) left (+ top oh2)))	;left
		(progn
		  ;; neither so wide as oval-width, nor so high as oval-height
		  ;; no sides at all, just one ellipse
		  (doing-one (+ left ow2) (+ top oh2))
		  (e (+ left ow2) (+ top oh2) 0 graphics:2pi))))))))

(define-drawing-graf-operations ("oval"
				 (left top right bottom)
				 (dw::set-box-edges last-rect left top right bottom))
				(&rest args)
  (multiple-value-bind (center-x center-y x-radius y-radius)
      (multiple-value-bind (left top right bottom)
	  (dw:box-edges last-rect)
	(values (/ (+ left right) 2) (/ (+ top bottom) 2)
		(/ (- right left) 2) (/ (- bottom top) 2)))
    (apply #'graphics:draw-ellipse center-x center-y x-radius y-radius args)))

(define-drawing-graf-operations ("arc"
				 (left top right bottom)
				 (dw::set-box-edges last-rect left top right bottom)
				 start-angle arc-angle)
				(&rest args)
  (multiple-value-bind (center-x center-y x-radius y-radius)
      (multiple-value-bind (left top right bottom)
	  (dw:box-edges last-rect)
	(values (/ (+ left right) 2) (/ (+ top bottom) 2)
		(/ (- right left) 2) (/ (- bottom top) 2)))
    (multiple-value-bind (start-angle end-angle clockwise)
	(convert-from-mac-arc start-angle arc-angle)
      (apply #'graphics:draw-ellipse center-x center-y x-radius y-radius
	     :start-angle start-angle
	     :end-angle end-angle
	     :clockwise clockwise
	     args))))

(define-drawing-graf-operations ("poly"
				 (left top right bottom poly)
				 (progn (ignore left top right bottom)
					(setq last-poly poly)))
				(&rest args)
  (apply #'graphics:draw-polygon last-poly args))

(define-drawing-graf-operations ("region"
				 (left top right bottom region)
				 (progn (ignore left top right bottom)
					(setq last-region region)))
				(&rest args)
  (ignore last-region args))

(compile-flavor-methods from-quickdraw-drawing-stream)

;;; For debugging, mostly
(defflavor from-quickdraw-describing-stream () (from-quickdraw-output-stream)
  (:constructor make-from-quickdraw-describing-stream ())
  )

(defmethod (get-font-info from-quickdraw-output-stream) niy)
(defmethod (get-pen-state from-quickdraw-output-stream) niy)
(defmethod (string-width from-quickdraw-output-stream) niy)

(defmacro define-describing-graf-operations (base-noun
					     same-args same-format-string
					     &optional different-args different-format-string)
  `(progn
     . ,(loop for verb in *graf-verbs*
	      nconc (loop for same-p in '(t nil)
			  collect (let ((operation (intern
						     (string-upcase
						       (string-append verb
								      (if same-p "-same-" "-")
								      base-noun)))))
				    `(defmethod (,operation from-quickdraw-describing-stream)
						(,@(and (not same-p) same-args)
						 ,@different-args
						 ,@(and (equal verb "fill") '(fill-pattern)))
				       (format t ,(string-append
						    verb " " (if same-p "same " "") base-noun
						    (if same-p "" 
							(string-append " " same-format-string))
						    (if different-format-string
							(string-append " "
								       different-format-string)
							""))
					       . ,(append (and (not same-p) same-args)
							  different-args
							  (and (equal verb "fill")
							       '(fill-pattern))))))))))

(defmacro define-describing-rect-operations (&rest operations)
  `(progn
     . ,(loop for (base-noun other-format . other-args) in operations
	      collect `(define-describing-graf-operations ,base-noun
			 (left top right bottom) "[~D,~D]  [~D,~D]"
			 ,other-args ,other-format))))

(define-describing-rect-operations
  ("rect")
  ("round-rect" "(~d,~d)" oval-width oval-height)
  ("oval")
  ("arc" "~D  +~D" start-angle arc-angle))

(define-describing-graf-operations "poly"
				   (left top right bottom poly) "[~D,~D]  [~D,~D] ~{~D~^,~}")

(define-describing-graf-operations "region"
				   (left top right bottom region) "[~D,~D]  [~D,~D]")

(defmethod (background-color from-quickdraw-describing-stream) (color)
  (format t "background color ~X" color))

(defun convert-pattern-to-raster (pattern)
  (let ((result (make-raster-array 32 8 :element-type 'bit)))
    (dotimes (y 8)
      (let ((byte (bit-reverse-8 (aref pattern y))))
	(dotimes (x 8)
	  (setf (raster-aref result x y) (ldb (byte 1 x) byte)))))
    (loop repeat 3 for x from 8 by 8 do
      (bitblt boole-1 8 8 result 0 0 result x 0))
    result))

(defun draw-pattern-sample (pattern)
  (if (not (operation-handled-p *standard-output* :draw-1-bit-raster))
      (prin1 pattern *standard-output*)
      (multiple-value-bind (x y)
	  (send *standard-output* :read-cursorpos)
	(send *standard-output* :draw-1-bit-raster 32 8
	      (convert-pattern-to-raster pattern) 0 0 x y)
	(send *standard-output* :increment-cursorpos 40 0))))

(defmethod (background-pattern from-quickdraw-describing-stream) (pattern)
  (format t "background pattern: ")
  (draw-pattern-sample pattern))

(defmethod (set-clip from-quickdraw-describing-stream) (region left top right bottom)
  (ignore region)
  (format t "clip region ~D,~D  ~D,~D" left top right bottom))

(defmethod (note-fill-pattern from-quickdraw-describing-stream) (pattern)
  (format t "fill pattern: ")
  (draw-pattern-sample pattern))

(defmethod (foreground-color from-quickdraw-describing-stream) (color)
  (format t "foreground color ~X" color))

(defmethod (rgb-foreground-color from-quickdraw-describing-stream) (rgb-color)
  (format t "RGB foreground color ~X ~X ~X"
	  (rgb-color-red rgb-color 0) (rgb-color-blue rgb-color 0)
	  (rgb-color-green rgb-color 0)))

(defmethod (rgb-background-color from-quickdraw-describing-stream) (rgb-color)
  (format t "RGB background color ~X ~X ~X"
	  (rgb-color-red rgb-color 0) (rgb-color-blue rgb-color 0)
	  (rgb-color-green rgb-color 0)))

(defmethod (move-to from-quickdraw-describing-stream) (x y)
  (format t "move to ~D ~D" x y))

(defmethod (line-from-to from-quickdraw-describing-stream) (start-x start-y end-x end-y)
  (format t "line ~D,~D  ~D,~D" start-x start-y end-x end-y))

(defmethod (line-from from-quickdraw-describing-stream) (start-x start-y dx dy)
  (format t "short line ~D,~D  +~D,+~D" start-x start-y dx dy))

(defmethod (line-to from-quickdraw-describing-stream) (end-x end-y)
  (format t "line from  ~D,~D" end-x end-y))

(defmethod (line from-quickdraw-describing-stream) (dx dy)
  (format t "short line from +~D,+~D" dx dy))

(defmethod (long-comment from-quickdraw-describing-stream) (kind contents)
  (format t "long comment ~D ~S" kind (ascii-to-string contents)))

(defmethod (note-noop from-quickdraw-describing-stream) ()
  (format t "noop"))

(defmethod (note-end-of-picture from-quickdraw-describing-stream) ()
  (format t "fim"))

(defmethod (note-picture-format-version from-quickdraw-describing-stream) (version)
  (format t "format version ~D" version))

(defmethod (note-picture-frame from-quickdraw-describing-stream) (left top right bottom)
  (format t "frame ~D,~D  ~D,~D" left top right bottom))

(defmethod (note-picture-length from-quickdraw-describing-stream) (picture length)
  (ignore picture)
  (format t "length ~D" length))

(defmethod (note-reserved-header from-quickdraw-describing-stream) ()
  (format t "reserved header"))

(defmethod (note-apple-reserved from-quickdraw-describing-stream) (&optional (contents nil))
  (when contents
    (format t "Apple reserved ~S" (ascii-to-string contents))))

(defmethod (set-origin from-quickdraw-describing-stream) (dx dy)
  (format t "origin ~D,~D" dx dy))

(defmethod (note-oval-size from-quickdraw-describing-stream) (x y)
  (format t "oval size ~Dx~D" x y))

(defmethod (pen-mode from-quickdraw-describing-stream) (mode)
  (format t "pen mode ~X" mode))

(defmethod (pen-pattern from-quickdraw-describing-stream) (pattern)
  (format t "pen pattern: ")
  (draw-pattern-sample pattern))

(defmethod (pen-size from-quickdraw-describing-stream) (x y)
  (format t "pen size ~Dx~D" x y))

(defmethod (short-comment from-quickdraw-describing-stream) (kind)
  (format t "short comment ~D" kind))

(defmethod (space-extra from-quickdraw-describing-stream) (extra)
  (format t "space extra ~S" extra))

(defmethod (text-face from-quickdraw-describing-stream) (face)
  (format t "text face ~O" face))

(defmethod (text-font from-quickdraw-describing-stream) (font)
  (format t "text font ~D" font))

(defmethod (draw-string-from from-quickdraw-describing-stream) (start-x start-y string)
  (format t "text ~D,~D: ~S" start-x start-y (ascii-to-string string)))

(defmethod (text-mode from-quickdraw-describing-stream) (mode)
  (format t "text mode ~X" mode))

(defmethod (text-ratio from-quickdraw-describing-stream) (num-x num-y den-x den-y)
  (format t "text ratio ~D,~D / ~D,~D" num-x num-y den-x den-y))

(defmethod (draw-string-dh from-quickdraw-describing-stream) (dx string)
  (format t "text dx ~D,: ~S" dx (ascii-to-string string)))

(defmethod (draw-string-dhdv from-quickdraw-describing-stream) (dx dy string)
  (format t "text dx dy ~D,~D: ~S" dx dy (ascii-to-string string)))

(defmethod (draw-string-dv from-quickdraw-describing-stream) (dy string)
  (format t "text dy ,~D: ~S" dy (ascii-to-string string)))

(defmethod (text-size from-quickdraw-describing-stream) (size)
  (format t "text size ~D" size))

(defmethod (draw-string from-quickdraw-describing-stream) (string &optional (start 0) end)
  (format t "draw string ~S" string start end))

(defmethod (default-hilite from-quickdraw-describing-stream) ()
  (format t "default hilite"))

(defmethod (rgb-hilite-color from-quickdraw-describing-stream) (color)
  (format t "hilite color: ~S" color))

(defmethod (rgb-op-color from-quickdraw-describing-stream) (color)
  (format t "op color: ~S" color))

(compile-flavor-methods from-quickdraw-describing-stream)

;;;; Decoding

(defun qd-picture-next-byte (picture)
  (prog1 (aref picture (qd-picture-read-pointer picture))
	 (incf (qd-picture-read-pointer picture))))

(defun qd-picture-next-word (picture)
  (let ((hi (qd-picture-next-byte picture))
	(lo (qd-picture-next-byte picture)))
    (dpb hi (byte 8 8) lo)))

(defun qd-picture-next-long (picture)
  (let ((hi (qd-picture-next-word picture))
	(lo (qd-picture-next-word picture)))
    (%logdpb hi (byte 16 16) lo)))

(defun qd-picture-next-point (picture)
  (let ((y (sign-extend-16 (qd-picture-next-word picture)))
	(x (sign-extend-16 (qd-picture-next-word picture))))
    (values x y)))

(defun qd-picture-next-rect (picture)
  (multiple-value-bind (left top)
      (qd-picture-next-point picture)
    (multiple-value-bind (right bottom)
	(qd-picture-next-point picture)
      (values left top right bottom))))

;;; Note that these return bytes, not a true string.
(defun qd-picture-next-string (picture)
  (qd-picture-next-string-internal picture (qd-picture-next-byte picture)))

(defun qd-picture-next-string-internal (picture length)
  (let ((result (make-array length :element-type '(unsigned-byte 8))))
    (copy-array-portion picture (qd-picture-read-pointer picture)
			(incf (qd-picture-read-pointer picture) length)
			result 0 length)
    result))

(defun qd-picture-next-fixed (picture)
  (/ (qd-picture-next-long picture) 1_16))

(defun qd-picture-next-pattern (picture)
  (let ((result (make-pattern)))
    (dotimes (i (length result))
      (setf (aref result i) (qd-picture-next-byte picture)))
    result))

(defun make-quickdraw-picture-from-bytes (bytes)
  (let* ((length (length bytes))
	 (picture (make-quickdraw-picture :length length :fill-pointer length
					  :displaced-to bytes)))
    (letf (((qd-picture-read-pointer picture) 0))
      (assert (= (qd-picture-next-word picture) (ldb (byte 16 0) length)))
      (multiple-value-bind (left top right bottom)
	  (qd-picture-next-rect picture)
	(setf (qd-picture-bounding-box picture)
	      (dw:make-temporary-box left top right bottom))))
    picture))

(defstruct (quickdraw-op-decoders
	     (:type :named-array-leader)
	     (:constructor-make-array-keywords (length)))
  (fill-pointer #x100)
  overflow-alist)

(defvar *quickdraw-op-decoders* (make-quickdraw-op-decoders :length #x100))

(defmacro define-qd-decoder (name code &body body)
  `(progn (defmethod (,name quickdraw-picture-decoder) ()
	    ;; Of course, this doesn't work.
	    (declare (sys:function-parent ,name define-qd-encoder))
	    ,@body)
	  (add-quickdraw-op-decoder ',name ,code)))

(defun add-quickdraw-op-decoder (name code)
  (if (< code (length *quickdraw-op-decoders*))
      (setf (aref *quickdraw-op-decoders* code) name)
      (let ((already-there (assoc code (quickdraw-op-decoders-overflow-alist
					 *quickdraw-op-decoders*))))
	(if already-there
	    (setf (second already-there) name)
	    (push (list code name)
		  (quickdraw-op-decoders-overflow-alist *quickdraw-op-decoders*)))))
  name)

(defun find-quickdraw-op-decoder (code &key (if-not-found :error))
  (or (if (< code (length *quickdraw-op-decoders*))
	  (aref *quickdraw-op-decoders* code)
	  (second (assoc code (quickdraw-op-decoders-overflow-alist
				*quickdraw-op-decoders*))))
      (and if-not-found
	   (error "Cannot find quickdraw op decoder for code ~d [#x~16r]" code code))))

(defflavor quickdraw-picture-decoder
	(picture stream byte-hook 
		 format-version
		 (rp 0)
		 fill-pattern
		 oval-width
		 oval-height
		 )
	()
  :initable-instance-variables)

(defun-in-flavor (call-operation quickdraw-picture-decoder) (operation &rest args)
  (when byte-hook (funcall byte-hook picture rp))
  (apply operation stream args))

(defun-in-flavor (call-operation-1 quickdraw-picture-decoder) (the-rp operation &rest args)
  (when byte-hook (funcall byte-hook picture the-rp))
  (apply operation stream args))

(defun decode-quickdraw-picture (picture stream &optional byte-hook)
  (letf (((qd-picture-read-pointer picture) 0))
    (let ((decoder (make-instance 'quickdraw-picture-decoder
				  :picture picture
				  :stream stream
				  :byte-hook byte-hook)))
      (decode-quickdraw-picture-1 decoder))))

(defmethod (decode-quickdraw-picture-1 quickdraw-picture-decoder) ()
  (setq rp (qd-picture-read-pointer picture))
  (let ((length (qd-picture-next-word picture)))
    ;; This is the only time we pass in the picture; if the stream needs it, it should
    ;; save it now.
    (call-operation #'note-picture-length picture length))
  (setq rp (qd-picture-read-pointer picture))
  (multiple-value-bind (left top right bottom)
      (qd-picture-next-rect picture)
    (call-operation #'note-picture-frame left top right bottom))
  (setq format-version (if (= (letf (((qd-picture-read-pointer picture)
				      (qd-picture-read-pointer picture)))
				(qd-picture-next-word picture))
			      =op-picture-version=)
			   ;; Temporarily determine whether long or short format for
			   ;; reading true version opcode.
			   2 1))
  (setq fill-pattern (let ((pattern (make-pattern)))
		       (compute-pen-pattern pattern 0 nil nil 1)
		       pattern))
  (setq oval-width nil
	oval-height nil)
  (catch 'end-of-picture
    (loop
      (qd-decoder-do-op self))))

(defmethod (qd-decoder-do-op quickdraw-picture-decoder) ()
  (setq rp (qd-picture-read-pointer picture))
  (let* ((op (if (= format-version 1)
		   (qd-picture-next-byte picture)
		   (when (oddp rp)
		     (setq rp (incf (qd-picture-read-pointer picture))))
		   (qd-picture-next-word picture))))
    (if (and ( op #x30) (< op #x90))
	(qd-decoder-do-shape-operation self op)
	(let ((decoder (find-quickdraw-op-decoder op :if-not-found nil)))
	  (if decoder
	      (funcall decoder self)
	      (do-apple-reserved-operation self op))))))

(defmethod (do-apple-reserved-operation quickdraw-picture-decoder) (op)
  (cond ((or ( #x17 op #x19)		;reserved by Apple (just opcode)
	     ( #x3d op #x3f)
	     ( #x4d op #x4f)
	     ( #x5d op #x5f)
	     ( #x7d op #x7f)
	     ( #x8d op #x8f)
	     ( #xb0 op #xcf)
	     ( #x8000 op #x80ff)
	     (call-operation #'note-apple-reserved nil)))
	((or ( #x24 op #x27)
	     ( #x2c op #x2f)
	     ( #x92 op #x97)
	     ( #x9a op #x9f)
	     ( #xa2 op #xaf))
	 (let* ((data-length (qd-picture-next-word picture))
		(contents (qd-picture-next-string-internal picture data-length)))
	   (call-operation #'note-apple-reserved contents)))
	((or ( #x35 op #x37)
	     ( #x45 op #x47)
	     ( #x55 op #x57))
	 (let* ((contents (qd-picture-next-string-internal picture 8.)))	;really a rectangle
	   (call-operation #'note-apple-reserved contents)))
	((or ( #x65 op #x67))
	 (let* ((contents (qd-picture-next-string-internal picture 12.)))	;really an arc
	   (call-operation #'note-apple-reserved contents)))
	((or ( #x7f00 op #x7fff))
	 (let* ((contents (qd-picture-next-string-internal picture 254.)))	;really a ?
	   (call-operation #'note-apple-reserved contents)))
	((or ( #x6d op #x6f)
	     ( #x200 op #xbff)
	     ( #xc01 op #x7eff))
	 (let* ((contents (qd-picture-next-string-internal picture 4.)))	;really a ?
	   (call-operation #'note-apple-reserved contents)))
	((or ( #x75 op #x77))
	 (error "Unable to decode Apple Reserved opcode with polygon argument"))
	((or ( #x85 op #x87))
	 (error "Unable to decode Apple Reserved opcode with region argument"))
	((or ( #xd0 op #xfe)
	     ( #x8100 op #xffff))
	 (let* ((data-length (qd-picture-next-long picture))
		(contents (qd-picture-next-string-internal picture data-length)))
	   (call-operation #'note-apple-reserved contents)))
	(t
	 (cerror "Try to interpret rest of picture"
		 "unknown op: ~X" op))))

(define-qd-decoder qd-decode-noop =op-noop= 
  (call-operation #'note-noop))

(define-qd-decoder qd-decode-clip-region =op-clip-region=
  (let ((length (qd-picture-next-word picture)))
    (multiple-value-bind (left top right bottom)
	(qd-picture-next-rect picture)
      (setq rp (incf (qd-picture-read-pointer picture) (- length 10)))
      (call-operation #'set-clip nil left top right bottom))))

(define-qd-decoder qd-decode-background-pattern =op-background-pattern=
  (let ((pattern (qd-picture-next-pattern picture)))
    (call-operation #'background-pattern pattern)))

(define-qd-decoder qd-decode-op-text-font =op-text-font=
  (let ((font (qd-picture-next-word picture)))
    (call-operation #'text-font font)))

(define-qd-decoder qd-decode-text-face =op-text-face=
  (let ((face (qd-picture-next-byte picture)))
    (call-operation #'text-face face)))

(define-qd-decoder qd-decode-text-mode =op-text-mode= 
  (let ((mode (qd-picture-next-word picture)))
    (call-operation #'text-mode mode)))

(define-qd-decoder qd-decode-space-extra =op-space-extra=
  (let ((extra (qd-picture-next-fixed picture)))
    (call-operation #'space-extra extra)))

(define-qd-decoder qd-decode-pen-size =op-pen-size=
  (multiple-value-bind (x y)
      (qd-picture-next-point picture)
    (call-operation #'pen-size x y)))

(define-qd-decoder qd-decode-pen-mode =op-pen-mode= 
  (let ((mode (qd-picture-next-word picture)))
    (call-operation #'pen-mode mode)))

(define-qd-decoder qd-decode-pen-pattern =op-pen-pattern= 
  (let ((pattern (qd-picture-next-pattern picture)))
    (call-operation #'pen-pattern pattern)))

(define-qd-decoder qd-decode-fill-pattern =op-fill-pattern= 
  (let ((pattern (qd-picture-next-pattern picture)))
    (setq fill-pattern pattern)
    (call-operation #'note-fill-pattern pattern)))

(define-qd-decoder qd-decode-oval-size =op-oval-size= 
  (multiple-value-bind (w h)
      (qd-picture-next-point picture)
    (setq oval-width w oval-height h)
    (call-operation #'note-oval-size w h)))

(define-qd-decoder qd-decode-origin =op-origin=
  (let ((dx (qd-picture-next-word picture))
	(dy (qd-picture-next-word picture)))
    (call-operation #'set-origin dx dy)))

(define-qd-decoder qd-decode-text-size =op-text-size= 
  (let ((size (qd-picture-next-word picture)))
    (call-operation #'text-size size)))

(define-qd-decoder qd-decode-foreground-color =op-foreground-color=
  (let ((color (qd-picture-next-long picture)))
    (call-operation #'foreground-color color)))

(define-qd-decoder qd-decode-background-color =op-background-color= 
  (let ((color (qd-picture-next-long picture)))
    (call-operation #'background-color color)))

(define-qd-decoder qd-decode-text-ratio =op-text-ratio=
  (multiple-value-bind (num-x num-y)
      (qd-picture-next-point picture)
    (multiple-value-bind (den-x den-y)
	(qd-picture-next-point picture)
      (call-operation #'text-ratio num-x num-y den-x den-y))))

(define-qd-decoder qd-decode-picture-version =op-picture-version=
  (let ((version (if (= format-version 1)
		     (qd-picture-next-byte picture)
		     (ldb (byte 8 8) (qd-picture-next-word picture)))))
    (setq format-version version)
    (call-operation #'note-picture-format-version version)))
  
(define-qd-decoder qd-decode-rgb-foreground-color =op-rgb-foreground-color=
  (call-operation #'rgb-foreground-color
		  (intern-rgb-color-fixed
		    (qd-picture-next-word picture)
		    (qd-picture-next-word picture)
		    (qd-picture-next-word picture))))
  
(define-qd-decoder qd-decode-rgb-hilite-color =op-rgb-hilite-color=
  (call-operation #'rgb-hilite-color
		  (intern-rgb-color-fixed
		    (qd-picture-next-word picture)
		    (qd-picture-next-word picture)
		    (qd-picture-next-word picture))))
  
(define-qd-decoder qd-decode-rgb-op-color =op-rgb-op-color=
  (call-operation #'rgb-op-color
		  (intern-rgb-color-fixed
		    (qd-picture-next-word picture)
		    (qd-picture-next-word picture)
		    (qd-picture-next-word picture))))

(define-qd-decoder qd-decode-default-hilite =op-default-hilite=
  (call-operation #'default-hilite))

(define-qd-decoder qd-decode-line =op-line=
  (multiple-value-bind (start-x start-y)
      (qd-picture-next-point picture)
    (multiple-value-bind (end-x end-y)
	(qd-picture-next-point picture)
      (call-operation #'line-from-to start-x start-y end-x end-y))))

(define-qd-decoder qd-decode-line-from =op-line-from= 
  (multiple-value-bind (end-x end-y)
      (qd-picture-next-point picture)
    (call-operation #'line-to end-x end-y)))

(define-qd-decoder qd-decode-short-line =op-short-line= 
  (multiple-value-bind (start-x start-y)
      (qd-picture-next-point picture)
    (let ((dx (sign-extend-8 (qd-picture-next-byte picture)))
	  (dy (sign-extend-8 (qd-picture-next-byte picture))))
      (call-operation #'line-from start-x start-y dx dy))))

(define-qd-decoder qd-decode-short-line-from =op-short-line-from=
  (let ((dx (sign-extend-8 (qd-picture-next-byte picture)))
	(dy (sign-extend-8 (qd-picture-next-byte picture))))
    (call-operation #'line dx dy)))
  
(define-qd-decoder qd-decode-long-text =op-long-text=
  (multiple-value-bind (start-x start-y)
      (qd-picture-next-point picture)
    (let ((string (qd-picture-next-string picture)))
      (call-operation #'draw-string-from start-x start-y string))))

(define-qd-decoder qd-decode-dh-text =op-dh-text=
  (let* ((dx (qd-picture-next-byte picture))
	 (string (qd-picture-next-string picture)))
    (call-operation #'draw-string-dh dx string)))

(define-qd-decoder qd-decode-dv-text =op-dv-text= 
  (let* ((dy (qd-picture-next-byte picture))
	 (string (qd-picture-next-string picture)))
    (call-operation #'draw-string-dv dy string)))

(define-qd-decoder qd-decode-dhdv-text =op-dhdv-text= 
  (let* ((dx (qd-picture-next-byte picture))
	 (dy (qd-picture-next-byte picture))
	 (string (qd-picture-next-string picture)))
    (call-operation #'draw-string-dhdv dx dy string)))

(defflavor qd-decode-copybits-state
	(
	 pixmap-or-bitmap
	 row-bytes
	 ;; bounding rectangle
	 bleft btop bright bbottom
	 ;; source rect
	 sleft stop sright sbottom
	 ;; dest rect
	 dleft dtop dright dbottom
	 mode
	 ;; Pixmap stuff, see IM V-104
	 version pack-type pack-size
	 (horizontal-resolution nil) (vertical-resolution nil)	;device resolution
	 (pixel-type 0) (pixel-size 1)
	 (component-count 1) (component-size 1)
	 plane-bytes
	 pmtable pmreserved
	 ;; 
	 ct-seed ct-flags (color-table nil) 
	 mask-left mask-top mask-right mask-bottom (mask-region nil)
	 ;;
	 image
	 )
	()
  (:constructor make-qd-decode-copybits-state (row-bytes))
  :writable-instance-variables)

(defmethod (make-instance qd-decode-copybits-state) (&rest ignore)
  (setq pixmap-or-bitmap (if (ldb-test (byte 1 15) row-bytes) :pixmap :bitmap)
	row-bytes (ldb (byte 14 0) row-bytes)))

(defmethod (qd-decode-copybits-state-take-pixmap qd-decode-copybits-state) (picture)
  (multiple-value-setq (bleft btop bright bbottom)
    (qd-picture-next-rect picture))
  (setq version (qd-picture-next-word picture))
  (setq pack-type (qd-picture-next-word picture))
  (setq pack-size (qd-picture-next-long picture))
  (setq horizontal-resolution (qd-picture-next-fixed picture)
	vertical-resolution (qd-picture-next-fixed picture))
  (setq pixel-type (qd-picture-next-word picture)
	pixel-size (qd-picture-next-word picture)
	component-count (qd-picture-next-word picture)
	component-size (qd-picture-next-word picture))
  (setq plane-bytes (qd-picture-next-long picture)
	pmtable (qd-picture-next-long picture)
	pmreserved (qd-picture-next-long picture)))

(defmethod (qd-decode-copybits-state-take-color-table qd-decode-copybits-state) (picture)
  (setq ct-seed (qd-picture-next-long picture)
	ct-flags (qd-picture-next-word picture))
  (let ((ctsize (qd-picture-next-word picture)))
    (setq color-table (make-array (list (1+ ctsize) 4)
				  :element-type '(unsigned-byte 16)))
    (dotimes (i (1+ ctsize))
      (let ((val (qd-picture-next-word picture))
	    (r (qd-picture-next-word picture))
	    (g (qd-picture-next-word picture))
	    (b (qd-picture-next-word picture)))
	(setf (aref color-table i 0) val)
	(setf (aref color-table i 1) r)
	(setf (aref color-table i 2) g)
	(setf (aref color-table i 3) b)))))

(defmethod (qd-decode-copybits-state-take-src-dst-rects qd-decode-copybits-state) (picture)
  (multiple-value-setq (sleft stop sright sbottom) (qd-picture-next-rect picture))
  (multiple-value-setq (dleft dtop dright dbottom) (qd-picture-next-rect picture)))

(defmethod (qd-decode-copybits-state-take-bounding-rect qd-decode-copybits-state) (picture)
  (multiple-value-setq (bleft btop bright bbottom) (qd-picture-next-rect picture)))

(defmethod (qd-decode-copybits-state-take-region qd-decode-copybits-state) (picture)
  (let ((size (qd-picture-next-word picture)))
    (multiple-value-setq (mask-left mask-top mask-right mask-bottom)
      (qd-picture-next-rect picture))
    (setq mask-region
	  (when (> size 10)
	    (let ((region (make-array (- size 10) :element-type '(unsigned-byte 8))))
	      (replace region picture :start2 (qd-picture-read-pointer picture))
	      (incf (qd-picture-read-pointer picture) (- size 10))
	      region)))))

(defmethod (qd-decode-copybits-state-take-pixdata qd-decode-copybits-state) (picture)
  (let* ((width (- bright bleft))
	 (element-type  (if (= pixel-size 32)
			    'fixnum		;Really signed.
			    `(unsigned-byte ,pixel-size)))
	 (spanning-width (graphics::raster-array-correct-width width element-type))
	 (height (- bbottom btop))
	 (separate-components nil)
	 (packed ( row-bytes 8))
	 (pad-byte nil))
    (case pixel-type
      (16
	(case pack-type
	  (1 (setq packed nil))
	  (2 (setq pad-byte t
		   packed nil))
	  (4 (setq separate-components t)))))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")    ;;this is horribly inefficient - the raster made here will probably be
    ;;discarded later, but only probably.  It doesn't use the raster resource
0    1;;because we're not smart enough to guess which rasters are keepers.

0    (setq image (make-raster-array spanning-width height :element-type element-type))

    (stack-let ((buffer (make-array row-bytes :element-type '(unsigned-byte 8)
					      :fill-pointer 0)))
      (tv:dotimes-noting-progress (y height "Decoding image rows")
	(let (source start end)
	  (if (not packed)
	      (setq source picture
		    start (qd-picture-read-pointer picture)
		    end (incf (qd-picture-read-pointer picture) row-bytes))
	    (setf (fill-pointer buffer) 0)
	    (let ((byte-count (if (> row-bytes 250)
				  (qd-picture-next-word picture)
				  (qd-picture-next-byte picture))))
	      (unpack-bits picture buffer
			   :start1 (qd-picture-read-pointer picture)
			   :end1 (incf (qd-picture-read-pointer picture) byte-count)
			   :bit-reverse-p nil))
	    (setq source buffer
		  start 0
		  end (fill-pointer buffer)))
	  (cond (separate-components
		 (let ((im image))
		     (declare (sys:array-register-1d im source))
		     (multiple-value-bind (ignore ignore d-span) (decode-raster-array im)
		     (macrolet ((process-component (n)
				  `(when ( component-count ,n)
				     (loop repeat width
					   for x from (* y d-span)
					   for index from (+ start (* width ,n))
					   do
				       (setf (aref im x)
					     (%logdpb (aref source index)
						      (byte 8 (* ,n 8))
						      (aref im x)))))))
		       (process-component 0)
		       (process-component 1)
		       (process-component 2)
		       (process-component 3))))
		 (when (> component-count 4)
		   (error "too many components!"))
		 )
		(( component-size 8)
		 (stack-let* ((chunk-size (* component-size component-count))
			      (bytes-per (/ chunk-size 8))
			      (extract-function (ecase chunk-size
						  (8 #'aref)
						  (16 #'byte-swapped-8-aref-16)
						  (32 #'byte-swapped-8-aref-32)
						  (24 (when pad-byte
							(incf chunk-size 8))
						      #'(lambda (array index)
							  (sys:%logdpb (aref array index)
								       (byte 8 16)
								       (byte-swapped-8-aref-16
									 array (1+ index)))))))
			      (spanning-bytes (ceiling (* spanning-width pixel-size)
						       chunk-size))
			      (as-bytes (make-array (* height spanning-bytes)
						    :element-type (if (= chunk-size 32)
								      'fixnum
								      `(unsigned-byte
									 ,component-size))
						    :displaced-to image)))
		   (loop for index from start below end by bytes-per
			 for x from (* y spanning-bytes)
			 do
		     (setf (aref as-bytes x) (funcall extract-function source index)))))
		((= component-size 1)
		 (stack-let* ((spanning-bytes (ceiling spanning-width 8))
			      (as-bytes (make-array (* height spanning-bytes)
						    :element-type '(unsigned-byte 8)
						    :displaced-to image)))
		   (loop for index from start below end
			 for x from (* y spanning-bytes)
			 do
		     (setf (aref as-bytes x) (bit-reverse-8 (aref source index))))))
		(t
		 (let ((per-byte (/ 8 component-size))
		       (reverse-function (ecase component-size
					   (2 #'sys:bit-reverse-2)
					   (4 #'sys:bit-reverse-4))))
		   (loop for index from start below end
			 for x from 0 by per-byte
			 do
		     (let ((source-byte (aref source index)))
		       (dotimes (i per-byte)
			 (setf (raster-aref image (+ x i) y)
			       (funcall reverse-function
					;; big-ender
					(ldb (byte component-size
						   (- 8 (* component-size (1+ i))))
					     source-byte))))))))))))))

(defmethod (decode-bits-rect-internal quickdraw-picture-decoder) (region-p direct-p)
  (when direct-p
    (assert (= (qd-picture-next-long picture) #xFF)))
  (let ((state (make-qd-decode-copybits-state (qd-picture-next-word picture))))
    (ecase (qd-decode-copybits-state-pixmap-or-bitmap state)
      (:bitmap
	(qd-decode-copybits-state-take-bounding-rect state picture))
      (:pixmap
	(qd-decode-copybits-state-take-pixmap state picture)
	(unless direct-p
	  (qd-decode-copybits-state-take-color-table state picture))))
    (qd-decode-copybits-state-take-src-dst-rects state picture)
    (setf (qd-decode-copybits-state-mode state)
	  (qd-picture-next-word picture))
    (when region-p
      (qd-decode-copybits-state-take-region state picture))
    (qd-decode-copybits-state-take-pixdata state picture)
    (call-operation #'draw-pixmap state)))

(define-qd-decoder qd-decode-bits-rect =op-bits-rect=
  (decode-bits-rect-internal self nil nil))

(define-qd-decoder qd-decode-bits-region =op-bits-region=
  (decode-bits-rect-internal self t nil))

(define-qd-decoder qd-decode-pack-bits-rect =op-pack-bits-rect=
  (decode-bits-rect-internal self nil nil))

(define-qd-decoder qd-decode-pack-bits-region =op-pack-bits-region=
  (decode-bits-rect-internal self t nil))

(define-qd-decoder qd-decode-direct-bits-rect =op-direct-bits-rect=
  (decode-bits-rect-internal self nil t))

(define-qd-decoder qd-decode-direct-bits-region =op-direct-bits-region=
  (decode-bits-rect-internal self t t))
  
(define-qd-decoder qd-decode-short-comment =op-short-comment=
  (let ((kind (qd-picture-next-word picture)))
    (call-operation #'short-comment kind)))

(define-qd-decoder qd-decode-long-comment =op-long-comment=
  (let* ((kind (qd-picture-next-word picture))
	 (contents (qd-picture-next-string-internal
		     picture (qd-picture-next-word picture))))
    (call-operation #'long-comment kind contents)))		    
  
(define-qd-decoder qd-decode-reserved-header #x0c00
  (incf (qd-picture-read-pointer picture) 24)
  (call-operation #'note-reserved-header))

(define-qd-decoder qd-decode-end-of-picture =op-end-of-picture=
  (call-operation #'note-end-of-picture)
  (throw 'end-of-picture T))

(defmethod (qd-decoder-do-shape-operation quickdraw-picture-decoder) (op)
  (let* ((base-op (logand op #xF0))
	 (verb (logand op #x07))		;frame, paint, erase, invert, fill
	 (fill-p (= verb #x04))
	 (same-p (logtest op #x08)))
    (macrolet ((rect-operation (base-noun)
		 (flet ((rect-verbs (base-noun same-p)
			  (loop for verb in *graf-verbs*
				collect (intern
					  (string-upcase
					    (string-append
					      verb
					      (if same-p "-same-" "-")
					      base-noun))))))
		   `(nth verb (if same-p
				  ',(rect-verbs base-noun t)
				  ',(rect-verbs base-noun nil))))))
      (flet ((rect-if ()
	       (unless same-p
		 (qd-picture-next-rect picture)))
	     (do-rect (operation left top right bottom &rest more-args)
	       (when fill-p
		 (setq more-args (append more-args (list fill-pattern))))
	       (if same-p
		   (apply #'call-operation operation more-args)
		   (apply #'call-operation operation left top right bottom
			  more-args))))
	(if ( verb (length *graf-verbs*))
	    (do-apple-reserved-operation self op)	;reserved operation
	    (selector base-op =
	      (=op-frame-rect=
		(multiple-value-bind (left top right bottom)
		    (rect-if)
		  (do-rect (rect-operation "rect") left top right bottom)))
	      (=op-frame-round-rect= 
		(multiple-value-bind (left top right bottom)
		    (rect-if)
		  (do-rect (rect-operation "round-rect") left top right bottom
			   oval-width oval-height)))
	      (=op-frame-oval= 
		(multiple-value-bind (left top right bottom)
		    (rect-if)
		  (do-rect (rect-operation "oval") left top right bottom)))
	      (=op-frame-arc= 
		(multiple-value-bind (left top right bottom)
		    (rect-if)
		  (let* ((start-angle (sign-extend-16
					(qd-picture-next-word picture)))
			 (angle (sign-extend-16
				  (qd-picture-next-word picture))))
		    (do-rect (rect-operation "arc") left top right bottom
			     start-angle angle))))
  
	      (=op-frame-poly=
		(multiple-value-bind (left top right bottom points)
		    (unless same-p
		      (let ((npoints (/ (- (qd-picture-next-word picture) 10) 4)))
			(multiple-value-bind (left top right bottom)
			    (qd-picture-next-rect picture)
			  (values left top right bottom
				  (loop repeat (* npoints 2)
					collect (qd-picture-next-word picture))))))
		  (let ((operation (rect-operation "poly")))
		    (if same-p
			(if fill-p
			    (call-operation operation fill-pattern)
			    (call-operation operation))
			(if fill-p
			    (call-operation operation left top right bottom
					    points fill-pattern)
			    (call-operation operation left top right bottom
					    points))))))
  
	      (=op-frame-region=
		(multiple-value-bind (left top right bottom region)
		    (unless same-p
		      (let* ((length (qd-picture-next-word picture))
			     (the-region (make-array (+ length 2) :element-type '(unsigned-byte 8))))
			(replace the-region picture :start2 (- (qd-picture-read-pointer picture) 2))
			(multiple-value-bind (left top right bottom)
			    (qd-picture-next-rect picture)
			  (incf (qd-picture-read-pointer picture) (- length 10))
			  (values left top right bottom the-region))))
		  (let ((operation (rect-operation "region")))
		    (if same-p
			(if fill-p
			    (call-operation operation fill-pattern)
			    (call-operation operation))
			(if fill-p
			    (call-operation operation left top right bottom
					    region fill-pattern)
			    (call-operation operation left top right bottom
					    region))))))))))))

;;; Assumes called in normal Cartesian quadrant; must invert (again) to simulate Mac screen.
(defun draw-quickdraw-picture (picture &optional (stream *standard-output*))
  (let ((bottom (if (qd-picture-bounding-box picture)
		    (dw:box-bottom (qd-picture-bounding-box picture))
		    (rect-bottom picture 2))))
    (graphics:with-scan-conversion-mode (stream :sketch t)	;Quickdraw doesn't match, so
						;might as well be fast.
      (graphics:with-graphics-transform (stream (list 1 0 0 -1 0 bottom))
	(decode-quickdraw-picture picture (make-from-quickdraw-drawing-stream :output-stream stream))))))

(defun describe-quickdraw-picture (picture &key (show-bytes t))
  (decode-quickdraw-picture picture
			    (make-from-quickdraw-describing-stream)
			    #'(sys:named-lambda byte-hook (picture start-pointer)
				(fresh-line)
				(when show-bytes
				  (loop for p from start-pointer
					      below (min (+ 100 start-pointer)
							 (qd-picture-read-pointer picture))
					do
				    (format t "~2,'0X " (aref picture p)))
				  (when (> (qd-picture-read-pointer picture)
					   (+ 100 start-pointer))
				    (format T "... "))))))

(defmethod (draw-pixmap from-quickdraw-describing-stream) (qd-decode-copybits-state)
  (describe-copybits-state qd-decode-copybits-state))

(defmethod (describe-copybits-state qd-decode-copybits-state) ()
  (format t "bits rect ~S [~D,~D  ~D,~D] from [~D,~D  ~D,~D] to [~D,~D  ~D,~D] mode: ~X"
       image bleft btop bright bbottom sleft stop sright sbottom dleft dtop dright dbottom
       mode)
  (when color-table
    (format t "~&  color table: ~S" color-table)))

(defmethod (draw-pixmap from-quickdraw-drawing-stream) (qd-decode-copybits-state)
  (apply #'draw-pixmap-1 qd-decode-copybits-state (get-drawing-args)))

(defmethod (draw-pixmap-1 qd-decode-copybits-state) (&rest args)
  ;;---ignores mask region; color; needs to be smart about incompatible depths; what else?
  #+ignore
  ;;--- Is this all?  Does it properly cover opacity?
  (apply #'graphics:draw-image
	 image dleft dtop
	 :image-left (- sleft bleft) :image-top (- stop btop)
	 :image-right (- sright bleft) :image-bottom (- sbottom btop)
	 :scale-x (if (= 0 (- sright sleft)) 1 (/ (- dright dleft) (- sright sleft)))
	 :scale-y (if (= 0 (- sbottom stop)) 1 (/ (- dbottom dtop) (- sbottom stop)))
	 :alu (convert-mode-to-alu mode)
	 args)
  #-ignore
  (labels ((doit (image alu opaque)
	     (let ((scale-x (if (= 0 (- sright sleft)) 1 (/ (- dright dleft) (- sright sleft))))
		   (scale-y (if (= 0 (- sbottom stop)) 1 (/ (- dbottom dtop) (- sbottom stop)))))
	       (graphics:with-graphics-translation (t dleft dtop)
		 (apply #'graphics:draw-image
			image 0 0
			:image-left (- sleft bleft) :image-top (- stop btop)
			:image-right (- sright bleft) :image-bottom (- sbottom btop)
			:scale-x scale-x
			:scale-y scale-y
			:alu alu :opaque opaque
			args))))
	   (simple (alu opaque) (doit image alu opaque))
	   (complement (alu opaque)
	     (multiple-value-bind (width height) (decode-raster-array image)
	       (stack-let ((complement-image
			     (make-array (list height width)
					 :element-type (array-element-type image))))
		 (bitblt boole-c1 width height image 0 0 complement-image 0 0)
		 (doit complement-image alu opaque)))))
    (mtb:cconstant-ecase mode
      (srcCopy (simple :draw T))
      (srcOr (simple :draw nil))
      (srcXor (simple :flip T))
      (srcBic (simple :erase nil))		;---is this right?
      (notSrcCopy (complement :draw T))
      (notSrcOr (complement :draw nil))
      (notSrcXor (complement :flip T))
      (notSrcBic (complement :erase nil)))))

(defmethod (copybits-parameters qd-decode-copybits-state) ()
  (values image color-table
	  bleft btop bright bbottom
	  sleft stop sright sbottom
	  dleft dtop dright dbottom
	  mode mask-region))

(compile-flavor-methods qd-decode-copybits-state)

#||
;;; Examples in TN #21 
(setq si:*read-extended-ibase-unsigned-number* t)

(setq qp (make-quickdraw-picture-from-bytes
	   (coerce
	     '#x(00 26 00 0a 00 14 00 af 00 78 11 01 01 00 0a 00 00 00 00 00 fa 01 90 
		    0b 00 04 00 05 40 00 0a 00 14 00 af 00 78 ff)
	     '(vector (unsigned-byte 8)))))

(setq qp2 (make-quickdraw-picture-from-bytes
	    (coerce
	      '#x(00 36 00 0a 00 14 00 af 00 78 11 01 01 00 0a 00 00 00 00 00 fa 01 90
		     61 00 0a 00 14 00 af 00 78 00 03 00 2d 08 00 0a 09 aa 55 aa 55 aa 55 aa 55
		     69 00 03 00 2d ff)
	      '(vector (unsigned-byte 8)))))

(setq qp3 (make-quickdraw-picture-from-bytes
	    (coerce
	      '#x(00 48 00 0a 00 14 00 af 00 78 11 01 01 00 0a 00 00 00 00 00 fa 01 90
		     31 00 0a 00 14 00 af 00 78 90 00 02 00 0a 00 14 00 0f 00 1c
		     00 0a 00 14 00 0f 00 19 00 00 00 00 00 14 00 1e 00 06
		     00 00 00 00 00 00 00 00 00 00 ff)
	      '(vector (unsigned-byte 8)))))
||#
