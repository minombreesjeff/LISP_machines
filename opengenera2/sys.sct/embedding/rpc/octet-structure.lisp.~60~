;;; -*- Mode: LISP; Syntax: LISP+C; Package: RPC; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")Table of contents

0Primitive bit operations (in the system, not this file, but relevant)
  (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")sign-extend-80 ((3 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")int80)
  2sign-extend-160 (3int160)
  2bit-reverse-20 (3int20)
  2bit-reverse-40 (3int40)
  2bit-reverse-80 (3int80)
  2bit-reverse-160 (3int160)
  2bit-reverse-320 (3int320)

Primitive big-endian array operations
  2byte-swapped-8-aref-160 (3array index0)
  2byte-swapped-8-aref-240 (3array index0)
  2byte-swapped-8-aref-320 (3array index0)

Byte oriented structure definitions
2define-octet-structure0 (3name-and-options 0&body3 fields0)
  3name-and-options0 can by just a symbol or cons of symbol and keyword,value pairs.
Defined keywords are 2:include0, 2:conc-name0, 2:constructor, :default-pointer0, and 2:default-index0,
more or less like 2defstruct0.  2:access-type0 specifies how references are made by default, as one
or 2:octet0, 2:unsigned-80, or 2:byte-swapped-80.  The default is :2octet0 for use with Symbolics
C.  2:define-accessors0 can be used to inhibit definition of macros.  2:export0, like 2defstruct0,
takes a list of keywords from the set (2:structure-name :accessors :constructor0).
Elements of 3fields0 are symbol for single unsigned byte field, of list of field name, and
type.  2*0 used for a name allocates space, but doesn't define accessors.  2*0 used as a type
defines subfields that overlap, such as bit fields.  2+0 used as a name defines unions.
 
2define-octet-structure-field-type0 (3name type-arglist reference-arglist 0&body3 clauses0)
 Used to define a new possible field type.  Clauses are :size, :data, or :expander.
2define-octet-structure-field-type-macro0 3(name arglist expansion)
0 Define a field type that is just an abbreviation for another.
2define-octet-structure-conversion-field-type0 (3name expansion 0&key3 (conversion 0'identity3)0)
 Define a field type that is built on another with just a final data conversion (e.g. sign
extension or bit reversal).

Normal structure element types
  2unsigned-byte0 (&optional3 0(3size 80))
  2signed-byte0 (3size0)
  [2unsigned-0]2integer-80/2160/2320 ()
 The obvious abbreviations.
  2padding0 (3base-type 0&optional3 (repeat 1)0)
 Just occupies space, field cannot be accessed.
  2vector0 (3type length0)
 3length0 can be a form that references earlier structure elements (e.g. initial byte count).
 Referencing returns a vector of the elements,
 or one can use the 2octet-structure-field-elements0 2loop0 iteration path.
  2load-byte0 (3base-type position size0)
  2bit0 (3base-type bit-number0)
  2boolean0 (3base-type0)
  2boolean-bit0 (3base-type bit-number0)
  2member0 (3base-type set0)
 3set0 is a form to evaluate to a sequence indexed by field.
  2subset0 (3base-type keywords0)
 One bit for each position to indicate presence of corresponding element.
2  character-80 ()
2  ascii-character-80 ()

Accessor forms
  2octet-structure-field-ref 0(3structure-name field-name array index0)
 Reference a field.
  2octet-structure-field-index0 (3reference0)
 Return index in array of start of this field.
3reference0 is of the form (conc'ed-name array index).
  2octet-structure-field-size0 (3reference0)
 Return size of this field in bytes (array elements)
  2octet-structure-total-size0 (3reference0)
 Return size of whole structure in bytes.
3reference0 is of the form (structure-accessor array index).
  2octet-structure-field-entry0 (3reference0)
 Reference a field pointed to directly by the index, rather than to the head of the 
whole structure.
  2with-octet-structure-access-type 0(3type &body body0)
 Override the default referencing mode, for using the same definition for more than one
data representation (such as Symbolics C and foreign system binary files).
  2with-octet-structure-fields0 (3(structure-name 0&rest3 reference-args) fields 0&body3 body0)
 Bind a bunch of lexical variables to structure slots.  Elements of 3fields0 either symbol
or list of local variable and field name.
  loop for 3index0 being the 2octet-structure-field-elements0 of 3reference
0 Map 3index0 over the the successive elements of a vector field.  Presumably the field type
is another structure type, whose accessors you then use to process each element.

Field operations
  2copy-octet-structure0 (3to-reference from-reference0)
  2octet-structure-equal0 (3reference-1 reference-20)

Flavor and structure synchronization
  2define-octet-structure-and-flavor0 (3structure-name inherit-from 0&body3 fields0)
 Define a flavor and structure that parallel one another.  The flavor has instance variables
with same names as field elements.
  2define-octet-structure-and-flavor-10 (3flavor-name inherit-from instance-vars fields 0&body3 defflavor-options0)
  2copy-fields-from-octet-structure0 (3instance array index0)
 Copies from the array into the instance, and returns the index past the end of the structure.
Uses appropriate method combination to get 3inherit-from0's fields too.

Debugging
  2describe-octet-structure0 (3structure-name array index0)
 Like 2describe-defstruct0.
|#

;;;; Structure types.

;;; Try to use existing symbols where they make some sense, but avoid ambiguous words like
;;; byte, or word.

(defprop define-octet-structure-field-type "Octet structure field type"
	 si:definition-type-name)

(defmacro define-octet-structure-field-type (name type-arglist reference-arglist
					     &body clauses)
  (flet ((property-name (type)
	   (ecase type
	     (:size 'octet-structure-field-type-size)
	     (:data 'octet-structure-field-type-data)
	     (:result-type 'octet-structure-field-type-result-type)
	     (:expander 'octet-structure-field-type-expander)
	     (:c 'octet-structure-field-type-c-tokens)))
	 (subform (form)
	   `((.type-args. .reference-args.)
	     (destructuring-bind ,type-arglist .type-args.
	       (ignore . ,(loop for x in type-arglist
				do (when (consp x) (setq x (first x)))
				unless (member x lambda-list-keywords)
				  collect x))
	       (destructuring-bind ,reference-arglist .reference-args.
		 (ignore . ,(loop for x in reference-arglist
				  do (when (consp x) (setq x (first x)))
				  unless (member x lambda-list-keywords)
				    collect x))
		 ,form)))))
    `(compiler:local-declare ((sys:function-parent ,name define-octet-structure-field-type))
       ,(when compiler:undo-declarations-flag	;I think this is the right flag to look at.
	  `(eval-when (compile)
	     . ,(loop for (type form) on clauses by 'cddr
		      collect `(setf (sys:getdecl ',name ',(property-name type))
				     #'(lambda . ,(subform form))))))
       . ,(loop for (type form) on clauses by 'cddr
		collect `(defun (,name ,(property-name type)) . ,(subform form))))))

(defun octet-structure-field-type-size (type &rest args)
  (call-octet-structure-field-type-function 'octet-structure-field-type-size type args))

(defun octet-structure-field-type-data (type &rest args)
  (call-octet-structure-field-type-function 'octet-structure-field-type-data type args))

(defun octet-structure-field-type-result-type (type &rest args)
  (call-octet-structure-field-type-function 'octet-structure-field-type-result-type type args
					    :default t))

(defun octet-structure-field-type-c-tokens (type)
  (let ((tokens (call-octet-structure-field-type-function 'octet-structure-field-type-c-tokens
							  type '(.not-array. 0)
							  :default t)))
    (if (eq tokens 't)
	(list (lisp-name-to-c-name (if (consp type) (first type) type)))
	tokens)))

(defun call-octet-structure-field-type-function (indicator type reference-args &key default)
  (let (type-name type-args)
    (loop
      (setq type-name type
	    type-args nil)
      (when (consp type)
	(setf `(,type-name . ,type-args) type))
      (let ((function (sys:getdecl type-name indicator)))
	(when function
	  (return (funcall function type-args reference-args)))
	(setq function (sys:getdecl type-name 'octet-structure-field-type-expander))
	(unless function
	  (if default
	      (return default)
	      (error "~S is not a structure field type" type)))
	(setq type (funcall function type-args reference-args))))))

(defvar *octet-structure-access-type* :default)	;or :unsigned-8 or :byte-swapped-8

(defmacro with-octet-structure-access-type ((type) &body body)
  `(compiler-let ((*octet-structure-access-type* ,type))
     . ,body))

(defvar *octet-structure-access-alist*
	'((:unsigned-8
	    (8 aref)
	    (16 unsigned-8-aref-16)
	    (32 unsigned-8-aref-32))
	  (:octet
	    (8 sys:octet-aref-8)
	    (16 sys:octet-aref-16)
	    (32 sys:octet-aref))
	  (:byte-swapped-8
	    (8 aref)
	    (16 byte-swapped-8-aref-16)
	    (24 byte-swapped-8-aref-24)
	    (32 byte-swapped-8-aref-32))
	  (:byte-swapped-octet
	    (8 sys:octet-aref-8)
	    (16 byte-swapped-octet-aref-16)
	    (32 byte-swapped-octet-aref))
	  (:byte-swapped-locative
	    (8 byte-swapped-locative-ref-8)
	    (16 byte-swapped-locative-ref-16)
	    (32 byte-swapped-locative-ref-32))))

(defun octet-structure-access-form (size array index
				    &optional (type *octet-structure-access-type*))
  (let ((entry (assoc type *octet-structure-access-alist*)))
    (unless entry
      (error "~S is not a structure access type" type))
    (setq entry (assoc size (rest entry)))
    (unless entry
      (error "~S is not a legal structure access size" size))
    `(,(second entry) ,array ,index)))

(defprop define-octet-structure-field-type-macro define-octet-structure-field-type
	 zwei:definition-function-spec-type)

(defmacro define-octet-structure-field-type-macro (name arglist expansion)
  `(define-octet-structure-field-type ,name ,arglist (&rest .args.)
     :expander ,expansion))

(defvar *byte-size-c-name-alist* (list (cons 8 #{char})
				       (cons 16 #{short})
				       (cons 32 #{long})))

(define-octet-structure-field-type unsigned-byte (&optional (size 8)) (array index)
  :result-type `(unsigned-byte ,size)
  :size (ceiling size 8)
  :data (octet-structure-access-form size array index)
  :c #{unsigned (rest (assoc size *byte-size-c-name-alist*)) })

(define-octet-structure-field-type signed-byte (&optional (size 8)) (array index)
  :result-type `(signed-byte ,size)
  :size (ceiling size 8)
  :data (list (second (assoc size '((8 sys:sign-extend-8) (16 sys:sign-extend-16)
				    (32 identity))))
	      (octet-structure-access-form size array index))
  :c #{(rest (assoc size *byte-size-c-name-alist*)) })

(define-octet-structure-field-type-macro integer-8 () `(signed-byte 8))
(define-octet-structure-field-type-macro integer-16 () `(signed-byte 16))
(define-octet-structure-field-type-macro integer-32 () `(signed-byte 32))
(define-octet-structure-field-type-macro cardinal-8 () `(unsigned-byte 8))
(define-octet-structure-field-type-macro cardinal-16 () `(unsigned-byte 16))
(define-octet-structure-field-type-macro cardinal-32 () `(unsigned-byte 32))

(rpc:define-octet-structure-field-type single-float () (array index)
  :result-type 'single-float
  :size 4
  :data `(sys:%flonum ,(rpc::octet-structure-access-form 32 array index))
  :c #{float }
  )

(rpc:define-octet-structure-field-type double-float () (array index)
  :result-type 'double-float
  :size 8
  :data (let ((first (rpc::octet-structure-access-form 32 array index))
	      (second (rpc::octet-structure-access-form 32 array `(+ ,index 4))))
	  (if (eq rpc::*octet-structure-access-type* :byte-swapped-8)
	      `(si:%make-double ,first ,second)
	      `(si:%make-double ,second ,first)))
  :c #{double }
  )

(define-octet-structure-field-type padding (base-type &optional (repeat 1)) (&rest args)
  :size `(* ,(apply #'octet-structure-field-type-size base-type args) ,repeat)
  :c #{char[(apply #'octet-structure-field-type-size base-type args) ]})

(define-octet-structure-field-type vector (type length) (array index)
  :size `(* ,length ,(octet-structure-field-type-size type array index))
  :data (let ((result-type (octet-structure-field-type-result-type type array index)))
	  (if (and (member *octet-structure-access-type* '(:unsigned-8 :byte-swapped-8))
		   (equal result-type '(unsigned-byte 8)))
	      ;; Don't waste open coding of this case.
	      `(subseq ,array ,index (+ ,index ,length))
	      ;; We could optimize other common cases into subroutines, like maybe strings.
	      `(let* ((.length. ,length)
		      (.result. (make-array .length. :element-type ',result-type)))
		 (loop for .aindex. below .length.
		       for .bindex. from ,index
				    by ,(octet-structure-field-type-size type array index)
		       do
		   (setf (aref .result. .aindex.)
			 ,(octet-structure-field-type-data type array '.bindex.)))
		 .result.)))
  :c #{(octet-structure-field-type-c-tokens type)
       [(and (integerp length) (list length)) ]})

(define-octet-structure-field-type load-byte (base-type position size) (&rest args)
  :size (apply #'octet-structure-field-type-size base-type args)
  :data `(ldb (byte ,size ,position) ,(apply #'octet-structure-field-type-data base-type args))
  :c #{(octet-structure-field-type-c-tokens base-type) })

(define-octet-structure-field-type-macro bit (base-type bit-number)
  `(load-byte ,base-type ,bit-number 1))

(define-octet-structure-field-type boolean (base-type) (&rest args)
  :result-type 'boolean
  :size (apply #'octet-structure-field-type-size base-type args)
  :data `(not-zerop ,(apply #'octet-structure-field-type-data base-type args))
  :c #{(octet-structure-field-type-c-tokens base-type) })

(define-octet-structure-field-type-macro boolean-bit (base-type bit-number)
  `(boolean (bit ,base-type ,bit-number)))

(define-octet-structure-field-type member (base-type set) (&rest args)
  :size (apply #'octet-structure-field-type-size base-type args)
  :data `(memelt ,set ,(apply #'octet-structure-field-type-data base-type args))
  ;--- some way to get an enum in here?
  :c #{(octet-structure-field-type-c-tokens base-type) })

(rpc:define-octet-structure-field-type enumeration (base-type symbols-and-values) (&rest args)
  :size (apply #'rpc::octet-structure-field-type-size base-type args)
  :data `(enumeration-data
	   ,symbols-and-values
	   ,(apply #'rpc::octet-structure-field-type-data base-type args))
  ;--- some way to get an enum in here?
  :c #{(octet-structure-field-type-c-tokens base-type) })

(define-octet-structure-field-type subset (base-type keywords) (&rest args)
  :size (apply #'octet-structure-field-type-size base-type args)
  :data `(bit-set-decode
	   ,(apply #'octet-structure-field-type-data base-type args)
	   ',keywords)
  :c #{(octet-structure-field-type-c-tokens base-type) })

(defprop define-octet-structure-conversion-field-type define-octet-structure-field-type
	 zwei:definition-function-spec-type)

(defmacro define-octet-structure-conversion-field-type (name expansion
							&key (conversion 'identity)
							     (result-type 't))
  `(define-octet-structure-field-type ,name () (&rest args)
     :size (apply #'octet-structure-field-type-size ',expansion args)
     :data `(,',conversion
	     ,(apply #'octet-structure-field-type-data ',expansion args))
     :c #{ (octet-structure-field-type-c-tokens ',expansion) }
     . ,(unless (eq result-type 't)
	  `(:result-type ,result-type))))

(define-octet-structure-conversion-field-type character-8 cardinal-8
  :conversion code-char
  :result-type 'string-char)

(define-octet-structure-conversion-field-type ascii-character-8 cardinal-8
  :conversion ascii-to-char
  :result-type 'string-char)

(rpc:define-octet-structure-field-type c-string (&optional size) (array index)
  :size (or size `(1+ (c-string-length ,array ,index)))
  :data `(asciz-substring ,array ,index)
  :c #{unsigned char [(and (integerp size) (list size)) ]}
  )

(define-octet-structure-field-type pascal-string (&optional size) (array index)
  :size (or size `(1+ ,(octet-structure-access-form 8 array index)))
  :data `(pascal-substring ,array ,index)
  :c #{unsigned char [(and (integerp size) (list size)) ]}
  )

(defprop define-octet-structure "Octet structure" si:definition-type-name)

(defmacro define-octet-structure (name-and-options &body fields)
  (let ((name name-and-options)
	(options nil))
    (when (consp name-and-options)
      (setf `(,name . ,options) name-and-options))
    (apply #'define-octet-structure-1 name fields options)))

(defun find-octet-structure (name)
  (sys:getdecl name 'octet-structure))

;; This will no longer be necessary with any System 3later than0 420
;; It's because the 3alignment0 slot was added to the octet-structure defstruct
;; with no tools for updating ones already created
(defsubst octet-structure-alignment-carefully (octet-structure)
  (condition-case (ignore)
       (octet-structure-alignment octet-structure)
     (sys:subscript-out-of-bounds nil)))


(defun define-octet-structure-1 (structure-name fields
				 &key (conc-name (string-append structure-name "-"))
				      default-pointer default-index include
				      (constructor nil constructor-p)
				      (default-type '(unsigned-byte 8))
				      (access-type :octet) (define-accessors t)
				      c-name export alignment)
  (when (null conc-name)
    (setq conc-name ""))
  (let ((forms nil)
	(structure-fields nil)
	(arglist (cond (default-pointer `(&optional (,structure-name ',default-pointer)
						    (index ',(or default-index 0))))
		       (default-index `(,structure-name &optional (index ',default-index)))
		       (t `(,structure-name index))))
	(exports (if (member :structure-name export)
		     (list structure-name)
		     ())))
    (labels
        ((emit-form (form)
	   (push form forms))
	 (emit-fields (fields predecessor structure-fields)
	   (labels 
	       ((emit-field (name type type-args predecessor)
		  (cond ((eq type '*)		;Nested field
			 (loop for (name type) in (rest type-args)
			       do (emit-field name (if (atom type) type (first type))
					      (cons (first type-args)
						    (unless (atom type) (rest type)))
					      predecessor))
			 (emit-field-1 name (first type-args) nil predecessor))
			(t
			 (emit-field-1 name type type-args predecessor))))
		(emit-field-1 (name type type-args predecessor)
		  (when define-accessors
		    (unless (eq name '*)
		      (emit-form
			(let ((accessor-name (intern (string-append conc-name name)
						     (symbol-package structure-name))))
			  (when (member :accessors export)
			    (push accessor-name exports))
			  `(defmacro ,accessor-name ,arglist
			     (si:xr-bq-list 'octet-structure-field-ref ',structure-name ',name
					    ,structure-name index))))))
		  (let ((field (make-octet-structure-field name (cons type type-args)
							   predecessor)))
		    (unless (eq name '*)
		      (push field structure-fields))
		    field)))
	     (dolist (field fields)
	       (block do-field
		 (let ((name field)
		       (type default-type)
		       (type-args nil))
		   (when (consp name)
		     (when (eq (first name) '+)
		       (let ((last nil)
			     (unions nil))
			 (dolist (fields (rest name))
			   (multiple-value-setq (last fields)
			     (emit-fields fields predecessor nil))
			   (push (nreverse fields) unions))
			 (setq predecessor last)
			 (push (nreverse unions) structure-fields)
			 (return-from do-field)))
		     (setf `(,name ,type) name))
		   (when (consp type)
		     (setf `(,type . ,type-args) type))
		   (setq predecessor (emit-field name type type-args predecessor)))))
	     (values predecessor structure-fields))))
      (let ((predecessor nil))
	(when include
	  (let ((structure (find-octet-structure include)))
	    (unless structure
	      (error "~S is not a structure for :INCLUDE" include))
	    (setq structure-fields (reverse (octet-structure-fields structure))))
	  (setq predecessor (octet-structure-field-predecessor (pop structure-fields))))
	(multiple-value-setq (predecessor structure-fields)
	  (emit-fields fields predecessor structure-fields))
	(push (make-octet-structure-field '.internal-end. '(*) predecessor)
	      structure-fields))
      (setq structure-fields (nreverse structure-fields))
      (when (and (null constructor) (not constructor-p))
	(setq constructor (intern (string-append "MAKE-" structure-name)
				  (symbol-package structure-name))))
      (when constructor
	(when (member :constructor export)
	  (push constructor exports))
	(let (constructor-arglist)
	  (if (consp constructor)
	      (setf `(,constructor ,constructor-arglist) constructor)
	      (setq constructor-arglist (list* '&key
					  (nset-difference
					    (labels 
					        ((do-subset (list)
						   (loop for field in list
							 if (atom field)
							   collect (octet-structure-field-name
								     field)
							 else nconc (do-subset field))))
					      (do-subset structure-fields))
					    '(* .internal-end.)))))
	  (emit-form
	    `(defmacro ,constructor (&rest args &environment env)
	       (declare (arglist . ,constructor-arglist))
	       (expand-octet-structure-constructor ',structure-name ',constructor-arglist
						   args env)))))
      (emit-form
	`(define-octet-structure-field-type ,structure-name () (array index)
	   :size (multiple-value-bind (field structure)
		     (find-octet-structure-field ',structure-name '.internal-end.)
		   `(- ,(octet-structure-field-index-1 structure field array index) ,index))
	   . ,(when c-name `(:c ,c-name))))
      (emit-form
	`(eval-when (eval load compile)
	   (define-octet-structure-2 ',structure-name ',structure-fields
				     :access-type ',access-type
				     :c-name ,c-name
				     :alignment ,alignment)))
      (unless (null exports)
	(emit-form
	  `(export ',(nreverse exports))))
      `(compiler:local-declare ((sys:function-parent ,structure-name define-octet-structure))
	 . ,(nreverse forms)))))

(defun find-octet-structure-field (structure-name field-name)
  (let ((structure (find-octet-structure structure-name)))
    (unless structure
      (error "~S is not a defined byte structure" structure-name))
    (let ((field (find-octet-structure-field-1 structure field-name)))
      (unless field
	(error "~S is not a field of ~S" field-name structure-name))
      (values field structure))))

(defun find-octet-structure-field-1 (structure field-name)
  (labels ((check-subset (fields)
	     (dolist (field fields)
	       (if (atom field)
		   (when (eq (octet-structure-field-name field) field-name)
		     (return-from find-octet-structure-field-1 field))
		   ;; A union always introduces two nested levels of lists, but we just
		   ;; always recurse for each one.
		   (check-subset field)))))
    (check-subset (octet-structure-fields structure))))

(defmacro octet-structure-field-ref (structure-name field-name array index)
  (multiple-value-bind (field structure)
      (find-octet-structure-field structure-name field-name)
    (substitute-octet-structure-field-references
      structure
      (let-if (eq *octet-structure-access-type* :default)
	      ((*octet-structure-access-type* (octet-structure-access-type structure)))
	(octet-structure-field-type-data (octet-structure-field-type field)
					 array
					 (octet-structure-field-index-1 structure field
									array index)))
      array index)))

(defun decode-octet-structure-field-reference (reference)
  (let ((form reference))
    (loop
      (when (and (consp form) (eq (first form) 'octet-structure-field-ref))
	(return))
      (let ((new-form (macroexpand-1 form)))
	(when (eq form new-form)
	  (error "~S is not an octet structure reference" reference))
	(setq form new-form)))
    (destructuring-bind (nil structure-name field-name array index) form
      (multiple-value-bind (field structure)
	  (find-octet-structure-field structure-name field-name)
	(values field structure array index)))))

(defmacro octet-structure-field-index (reference)
  (multiple-value-bind (field structure array index)
      (decode-octet-structure-field-reference reference)
    (octet-structure-field-index-1 structure field array index)))

(defun field-type-element-size (field-type array index)
  (labels ((type-expansion (type)
	     (let ((exp (call-octet-structure-field-type-function
			  'octet-structure-field-type-expander type (list array index)
			  :default :not-there)))
	       (if (eql exp :not-there) type
		   (type-expansion exp)))))
    (let ((expression (type-expansion field-type)))
      (if (and (consp expression)
	       (eql (car expression) 'vector))
	  (field-type-element-size (second expression) array index)
	  (octet-structure-field-type-size expression array index)))))

(defun octet-structure-field-index-1 (structure field array index)
  (let ((alignment (octet-structure-alignment-carefully structure)))
    (labels ((symbolically-evaluate-form (form)
	       (if (and (consp form) (member (first form) '(+ - * /)))
		   (let ((args (mapcar #'symbolically-evaluate-form (rest form))))
		     (if (every #'numberp args)
			 (reduce (first form) args)
			 form))
		   form))
	     (backtrack-fields (field)
	       (let ((predecessor (octet-structure-field-predecessor field)))
		 (if (null predecessor)
		     index
		     (let ((offset
			     (symbolically-evaluate-form
			       `(+ ,(backtrack-fields predecessor)
				   ,(octet-structure-field-type-size
				      (octet-structure-field-type predecessor)
				      array index)))))
		       (if (and alignment
				;; don't attempt to align at non-numeric offsets, because then
				;; we could never define variable-length structures!
				(numberp offset)
				;; Are we at the end of a static-length structure? Then always 
				;; align for LSC. Otherwise the alignment depends on the size 
				;; of the field or the size of the element type if the field 
				;; is a vector of some kind.
				(or (eql (octet-structure-field-name field) '.internal-end.)
				    ( (symbolically-evaluate-form
					 (field-type-element-size
					   (octet-structure-field-type field)
					   array index))
				       alignment))
 				)
			   (* alignment (ceiling offset alignment))
			   offset))))))
      (substitute-octet-structure-field-references
	structure (backtrack-fields field) array index))))


(defmacro octet-structure-field-size (reference)
  (multiple-value-bind (field structure array index)
      (decode-octet-structure-field-reference reference)
    (substitute-octet-structure-field-references structure 
      (octet-structure-field-type-size (octet-structure-field-type field) array index)
      array index)))

(defmacro octet-structure-total-size (reference)
  `(octet-structure-field-index
     (octet-structure-field-ref ,(first reference) .internal-end. . ,(rest reference))))

(defmacro octet-structure-field-indirect-array (reference &rest make-array-args)
  (multiple-value-bind (field structure array index)
      (decode-octet-structure-field-reference reference)
    `(make-array ,(substitute-octet-structure-field-references structure
		    (octet-structure-field-type-size (octet-structure-field-type field)
						     array index)
		    array index)
		 :displaced-to ,array
		 :displaced-index-offset ,(octet-structure-field-index-1 structure field
									 array index)
		 . ,make-array-args)))

(defvar *octet-structure-substitute-variables* t)

(defun substitute-octet-structure-field-references (structure form array index)
  (lt:copyforms #'(lambda (subform kind usage)
		    (ignore kind)
		    (cond ((and (member usage 'lt:(eval test)) (symbolp subform)
				(find-octet-structure-field-1 structure subform)
				*octet-structure-substitute-variables*)
			   `(octet-structure-field-ref ,(octet-structure-name structure)
						       ,subform ,array ,index))
			  ;; Compiler doesn't understand associativity.  We don't actually
			  ;; do the summing here: we just rearrange so that the compiler will
			  ;; do it.  That way the macro expansion is more informative.
			  ((and (eq usage 'eval) (consp subform)
				(eq (first subform) '+)
				(consp (second subform))
				(eq (first (second subform)) '+))
			   `(+ ,@(rest (second subform))
			       . ,(rest (rest subform))))
			  ;; A nested structure will have had its size computed with some
			  ;; redundancy.  Oh, for a system pattern matcher.
			  ((and (eq usage 'eval) (consp subform)
				(eq (first subform) '-)
				(consp (second subform))
				(null (cdddr subform))
				(eq (first (second subform)) '+)
				(eq (second (second subform))
				    (third subform)))
			   `(+ . ,(rest (rest (second subform)))))
			  (t subform)))
		form))

(defmacro with-octet-structure-fields ((structure-name array index) fields
				       &body body)
  `(let ,(loop for field in fields
	       collect (list (if (atom field) field (first field))
			     `(octet-structure-field-ref ,structure-name
						    ,(if (atom field) field (second field))
						    ,array ,index)))
     . ,body))

(defmacro octet-structure-field-entry (reference)
  (multiple-value-bind (field structure array index)
      (decode-octet-structure-field-reference reference)
    (let-if (eq *octet-structure-access-type* :default)
	    ((*octet-structure-access-type* (octet-structure-access-type structure)))
      (substitute-octet-structure-field-references
	structure
	(octet-structure-field-type-data (octet-structure-field-type field) array index)
	array index))))

(defun expand-octet-structure-copy-index (reference)
  (if (find-octet-structure (first reference))
      (list (second reference) (third reference) `(octet-structure-total-size ,reference))
      (list (second reference)
	    `(octet-structure-field-index ,reference)
	    `(+ (octet-structure-field-index ,reference)
		(octet-structure-field-size ,reference)))))

(defmacro copy-octet-structure (to-reference from-reference)
  `(copy-octet-structure-1 ,@(expand-octet-structure-copy-index to-reference)
			   ,@(expand-octet-structure-copy-index from-reference)))

(defmacro octet-structure-equal (reference-1 reference-2)
  `(octet-structure-equal-1 ,@(expand-octet-structure-copy-index reference-1)
			    ,@(expand-octet-structure-copy-index reference-2)))

(define-loop-path octet-structure-field-elements
		  octet-structure-field-elements-loop-expander
  (of))

(defun octet-structure-field-elements-loop-expander (iteration-path-name
						     index-var index-var-data-type
						     prep-phrases inclusive
						     allowed-prepositions data)
  (declare (ignore iteration-path-name allowed-prepositions data))
  (assert (not inclusive))
  (let ((reference-form (second (si:loop-tassoc 'of prep-phrases))))
    (when (null reference-form)
      (error "Missing OF in ~A iteration path of ~S"
	     'octet-structure-field-elements index-var))
    (multiple-value-bind (field nil array index)
	(decode-octet-structure-field-reference reference-form)
      (let ((type (octet-structure-field-type field)))
	(unless (eq (first type) 'vector)
	  (error "Can only iterate over vector fields presently"))
	(let* ((subtype (second type))
	       (limit-var (gensym))
	       (bindings `((,index-var () ,index-var-data-type)
			   (,limit-var () ())))
	       (prologue `((setq ,index-var (octet-structure-field-index ,reference-form)
				 ,limit-var (+ ,index-var
					       (octet-structure-field-size
						 ,reference-form)))))
	       (end-test `( ,index-var ,limit-var))
	       (steps `(,index-var (+ ,index-var
				      ,(octet-structure-field-type-size subtype
									array index)))))
	  (list bindings prologue nil steps end-test nil nil nil end-test nil))))))

;;; This should really try to be a real function with inlining or optimization, so that
;;; you have apply it.  Have to optimize out all the useless fields, though.
;--- automatic access-type keyword?
(defun expand-octet-structure-constructor (structure-name constructor-arglist args env)
  (let ((basic-form (let ((length-form (let ((*octet-structure-substitute-variables* nil))
					 ;; Don't turn length variables into their
					 ;; reference form; they come from the locals
					 ;; made here.
					 (multiple-value-bind (field structure)
					     (find-octet-structure-field structure-name
									 '.internal-end.)
					   (octet-structure-field-index-1 structure field
									  '.result. 0)))))
		      (case (if (eq *octet-structure-access-type* :default)
				(octet-structure-access-type
				  (find-octet-structure structure-name))
				*octet-structure-access-type*)
			(:octet
			  `(make-array (ceiling ,length-form 4) :element-type 'fixnum))
			(otherwise
			  `(make-array ,length-form :element-type '(unsigned-byte 8))))))
	(bindings (lt:match-args-to-lambda-list constructor-arglist args
						:return-bindings t)))
    (setq bindings (delete-if-not #'cdr bindings))
    (if (null bindings)
	basic-form
	;; We use let-subst in case the length form depends on a field argument.
	(lt:let*-subst (map 'list #'car bindings) (map 'list #'cdr bindings)
		       `(let ((.result. ,basic-form))
			  ,@(loop for (var) in bindings
				  collect `(setf (octet-structure-field-ref ,structure-name
									    ,var .result. 0)
						 ,var))
			  .result.)
		       env))))

(defun write-octet-structure-definitions-to-c-file (structure-names file
						    &key prologue postscript
							 incomplete-array-size)
  (multiple-value-bind (default-pathname truename)
      (current-compiler-source-file)
    (with-open-file (stream (fs:merge-pathname-defaults file default-pathname :c-include)
			    :direction :output)
      (format *error-output* "~&[Writing structure definitions to ~A.]~%" (pathname stream))
      (write-line "/* -*- Mode: C -*- */" stream)
      (format stream "~2%/* Written from ~A by ~A on ~\\date\\ */~2%"
	      truename si:user-id (time:get-universal-time))
      (write-c-token-list prologue stream)
      (format stream "~2&")
      (dolist (structure-name structure-names)
	(let* ((structure (find-octet-structure structure-name))
	       (c-name (or (octet-structure-c-name structure)
			   (list (lisp-name-to-c-name structure-name)))))
	  (write-c-token-list
	    #{typedef struct c-name {
	    (let ((unnamed-counter 0)
		   (union-counter 0))
	       (labels 
		   ((do-subset (fields)
		      (loop for field in fields append
			(if (atom field)
			    (unless (eq (octet-structure-field-name field)
					'.internal-end.)
			      (let* ((type-tokens (octet-structure-field-type-c-tokens
						    (octet-structure-field-type field)))
				     (name-token (condition-case ()
						      (lisp-name-to-c-name
							(octet-structure-field-name field))
						    (error
						      (intern (format nil "unnamed~D"
								      (incf unnamed-counter))
							      *rpc-package*))))
				     (array (search #{[} type-tokens)))
				(append (subseq type-tokens 0 array)
					(list name-token)
					(and array
					     (let ((rest (subseq type-tokens array)))
					       (if (and incomplete-array-size
							(equal rest #{[]}))
						   (cons (first rest)
							 (append incomplete-array-size
								 (rest rest)))
						   rest)))
					#{;}
					)))
			    #{ union { (loop for fields in field
					      for counter from 1
					      append (if (= (length fields) 1)
							 (do-subset fields)
							 #{ struct { (do-subset fields) }
					                    (intern (format nil "u~D"
									      counter)
								      *rpc-package*)
							    ;}
							    ))
					} (intern (format nil "union~D" (incf union-counter))
						    *rpc-package*)
					;}
					))))
		 (do-subset (octet-structure-fields structure))))
	    } c-name; }
	    stream))
	(terpri stream))
      (format stream "~2&")
      (write-c-token-list postscript stream))))

(defmacro define-octet-structure-and-flavor (structure-name inherit-from &body fields)
  `(define-octet-structure-and-flavor-1 ,structure-name ,inherit-from nil ,fields))

(defmacro define-octet-structure-and-flavor-1 (flavor-name inherit-from instance-vars fields
					       &body defflavor-options)
  (let ((structure-name (sys:fintern "~A-STRUCTURE" flavor-name)))
    `(progn
       (define-octet-structure (,structure-name 
				:access-type :byte-swapped-8	;---
				:include ,(and inherit-from
					       (sys:fintern "~A-STRUCTURE" inherit-from)))
			       . ,fields)
       (defflavor ,flavor-name
	       (,@instance-vars
		. ,(loop for field in fields
			 as name = (if (atom field) field (first field))
			 unless (eq name '*) collect name))
	       ,(and inherit-from (list inherit-from))
	 :writable-instance-variables
	 . ,defflavor-options)
       (defmethod (copy-fields-from-octet-structure ,flavor-name :before) (array index)
	 (ignore array index)
	 . ,(loop for field in fields
		  as name = (if (atom field) field (first field))
		  unless (eq name '*)
		    collect `(setq ,name (octet-structure-field-ref ,structure-name ,name
							       array index))))
       (defmethod (copy-fields-from-octet-structure ,flavor-name) (array index)
	 (ignore array index)
	 (octet-structure-total-size (,structure-name array index))))))

(defun describe-octet-structure (structure-name array index &key (access-type :default)
								 (indent 0))
  (let ((structure (find-octet-structure structure-name)))
    (unless structure
      (let ((name (gensym)))			;This lets you give the name of a field type
	(define-octet-structure-2 name
				  (let ((first (make-octet-structure-field structure-name
									   structure-name
									   nil)))
				    (list first
					  (make-octet-structure-field '.internal-end. '(*)
								      first))))
	(setq structure (find-octet-structure name))))
    (labels
      ((do-structure (structure index indent)
	 (labels
	   ((do-subset (fields)
	      (dolist (field fields)
		(if (atom field)
		    (let* ((*octet-structure-access-type* access-type)
			   (field-name (octet-structure-field-name field))
			   (form `(octet-structure-field-ref ,(octet-structure-name structure)
							     ,field-name ,array ,index)))
		      (unless (eq field-name '.internal-end.)
			(let ((field-index (eval `(octet-structure-field-index ,form))))
			  (format t "~&~@vT~A[~D]:~40T" indent field-name field-index)
			  (condition-case ()
			       (dw:with-output-as-presentation
				   (:type 'sys:expression :form form)
				 (prin1 (eval form)))
			     (error		;Should specialize perhaps
			       (let ((structure (let ((type (octet-structure-field-type
							      field)))
						  (and (consp type) (= (length type) 1)
						       (find-octet-structure (first type))))))
				 (if structure
				     (do-structure structure field-index (+ indent 2))
				     (format t "<<Error printing field>>"))))))))
		    (do-subset field)))))
	   (do-subset (octet-structure-fields structure)))))
      (do-structure structure index indent))))
