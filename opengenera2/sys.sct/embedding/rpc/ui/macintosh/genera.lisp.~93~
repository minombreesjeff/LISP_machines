;;; -*- Mode: LISP; Syntax: Common-lisp; Package: MACINTOSH-INTERNALS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


;;; If true, store bit-arrays in host memory if there is enough host memory
(defvar *automatically-generate-pixmap-correspondences* t)

;;; Variables develpers can use to restrict the size variation in the genera screen
(defvar *genera-screen-minimum-height* 200)
(defvar *genera-screen-minimum-width* 200)
(defvar *genera-screen-maximum-height* 2000)
(defvar *genera-screen-maximum-width* 2000)


;;; Enough host memory for bit arrays is this many times the size of the screen
;;; 4 allows for 3 resident bit arrays plus one temporary bit array
(defvar *pixmap-correspondence-memory-threshold* 4)


;;;; The Mac RPC specific console
(defflavor mac-rpc-console
	((font-number-cache (make-hash-table :test 'eq :locking :without-interrupts)))
	(rpc:rpc-console))

(defmethod (dw:console-remote-program mac-rpc-console) ()
  (find rpc::console-id *rpc-programs* :key #'rpc-program-application-id))

(defmethod (dw:console-select-program-after mac-rpc-console) (program)
  (let ((genera (dw::containing-remote-program program)))
    (when genera
      (change-menu-bars genera
			(upgrade-macintosh-menu-bar-ordering
			  program (macintosh-menu-bar-ordering program))))))

(defmethod (dw:console-deexpose-program-after mac-rpc-console) (program)
  (let ((genera (dw::containing-remote-program program)))
    (when genera
      (rpc-program-install-menus genera))))

(defmethod (download-font mac-rpc-console) (font)
  (condition-case ()
       (let ((*default-transport-agent* (rpc-program-transport-agent
					  (dw:console-remote-program self)))
	     (qd-family (qd-font-family-for-font font))
	     (style-code 0)
	     (point-size (tv:font-raster-height font)))
	 (let ((bfd (first (qd-font-family-bfds qd-family)))
	       (res-id (unique-NFNT-id)))
	   (download-resource "NFNT" (string (fed:bfd-name bfd)) res-id
			      %mac-resource-purgeable (font-resource-from-bfd bfd))
	     (setf (getf (fed:bfd-plist bfd) :resource-id) res-id)
	     (setf (getf (fed:bfd-plist bfd) :font-size) point-size)
	     (setf (getf (fed:bfd-plist bfd) :font-face) style-code))
	 (let ((res-id (next-free-font-family-id nil)))
	   (download-resource "FOND" (qd-font-family-name qd-family) res-id
			      %mac-resource-purgeable
			      (font-family-resource-from-qd-font-family qd-family))
	   (let ((number (sys:%logdpbs res-id (byte 16 16)
				       style-code (byte 8 8)
				       point-size (byte 8 0)
				       0)))
	     (setf (gethash font font-number-cache) number)
	     number)))
     ((mac-font-limit-exceeded mac-os-error)
       ;; Remember that this font can't be downloaded, so we won't try it again
       ;; A mac-os-error might be temporary, but there's no way to know that
       (setf (gethash font font-number-cache) nil))))

(defmethod (rpc::rpc-console-font-number mac-rpc-console) (font display-device-type)
  (ignore display-device-type)
  (block nil
    ;; Check the cache first
    (multiple-value-bind (number found)
	(gethash font font-number-cache)
      (when found
	(return number)))
    ;; If we expect this font to be in the resource file, get today's font number
    (let ((mac-info (qd-font-parameters font)))
      (when mac-info
	(destructuring-bind (family style size) mac-info
	  (flet ((lookup (family-name)
		   (let ((family-number (rpc-toolkit-get-font-number family-name
					  :transport-agent rpc::transport-agent)))
		     (when (zerop family-number)
		       (let ((actual-name (rpc-toolkit-get-font-name family-number
					    :transport-agent rpc::transport-agent)))
			 (unless (string-equal family-name actual-name)
			   (setq family-number nil))))
		     family-number)))
	    (let ((family-number (lookup family)))
	      (when (and (null family-number)
			 (eql (aref family 0) #\%))
		;; For compatibility with older versions of MacIvory-Support.rsrc,
		;; try the font name without the leading "%".
		(setq family-number (lookup (subseq family 1))))
	      (when family-number
		(let ((number (sys:%logdpbs family-number (byte 16 16)
					    style (byte 8 8)
					    size (byte 8 0)
					    0)))
		  (return (setf (gethash font font-number-cache) number)))))))))
    ;; The Macintosh doesn't know about this font, try downloading it
    (download-font self font)))

(defmethod (rpc::rpc-console-pixmap-flavor mac-rpc-console) ()
  'mac-rpc-pixmap-correspondence)

(defflavor mac-rpc-main-console () (cli::main-console mac-rpc-console))

(defflavor mac-rpc-drawable
	((device-pen-state *normal-pen-state*)
	 (device-foreground-color *rgb-color-black*)
	 (device-clipping-region (make-list 4)))
	()
  (:required-flavors rpc::rpc-drawable))

(defwhopper (rpc::set-normal-graphics-state mac-rpc-drawable)
	    (console alu fill-data plane-mask)
  (setq device-pen-state *normal-pen-state*
	device-foreground-color (and (= fill-data -1) *rgb-color-black*))
  (setf (first device-clipping-region) nil)
  (continue-whopper console alu fill-data plane-mask))

(defmethod (update-graphics-state mac-rpc-drawable) (alu pen-state foreground-color
						     clipping-region console)
  (unless (eql pen-state device-pen-state)
    (rpc::rpc-console-call console #'rpc-window-set-pen-state rpc::screen-id pen-state)
    (setq device-pen-state pen-state)
    (setq rpc::device-alu (convert-mode-to-alu (pen-state-pen-mode pen-state))))
  (unless (= alu rpc::device-alu)
    (rpc::rpc-console-call console #'rpc-window-pen-mode rpc::screen-id
			   (convert-alu-to-mode alu))
    (setq rpc::device-alu alu))
  (unless (eql foreground-color device-foreground-color)
    (rpc::rpc-console-call console #'rpc-window-rgb-foreground-color rpc::screen-id
			   foreground-color)
    (setq device-foreground-color foreground-color))
  (unless (equal clipping-region device-clipping-region)
    (apply #'rpc::rpc-console-call console #'rpc-window-clip-rect-points
				   rpc::screen-id clipping-region)
    (replace device-clipping-region clipping-region)))

(defflavor mac-rpc-screen () (rpc::rpc-screen))

(defmethod (rpc::rpc-screen-flavor mac-rpc-console) (who-line-p)
  (if who-line-p 'rpc::rpc-who-line-screen 'mac-rpc-screen))

(defmethod (:activate mac-rpc-screen :before) ()
  (when (not (member self tv:all-the-screens))
    (setf rpc::automatically-generate-pixmap-correspondences
	  (and *automatically-generate-pixmap-correspondences*
	       (let ((bytes-per-screen (floor (* tv:width tv:height tv:depth) 8))
		     (available-memory (let ((rpc:*default-transport-agent*
					       (rpc::rpc-console-transport-agent tv:console)))
					 (mtb:_FreeMem))))
		 (> available-memory
		    (* bytes-per-screen *pixmap-correspondence-memory-threshold*)))))
    (tv:sheet-resolve-inferior-time-stamps self)))

(defmethod (:compute-rgb-alu mac-rpc-screen) (alu r g b &rest ignore)
  (let ((color (make-rgb-color :red (if (= r 0) 0 (round (* r 65535)))
			       :green (if (= g 0) 0 (round (* g 65535)))
			       :blue (if (= b 0) 0 (round (* b 65535))))))
    (make-mac-color-alu :color color :alu alu)))

;;; --- There must be a better way
(defmethod (:exchange-two-colors-aluf mac-rpc-screen) (a b)
  (declare (ignore a b))
  boole-xor)

(defmacro-in-flavor (with-adjusted-graphics-offsets mac-rpc-screen)
		    ((sheet drawable dx dy clipping-region) &body body)
  `(let ((,dx 0) (,dy 0) array)
     (tv:prepare-sheet (,sheet)
       (let ((,drawable (tv:update-offsets ,sheet array ,dx ,dy)))
	 (when ,drawable
	   (stack-let ((,clipping-region (list nil nil nil nil)))
	     (let ((clipping-region ,clipping-region)
		   (sheet-clip (tv:sheet-clipping-region ,sheet)))
	       (setf (first clipping-region) (+ (pop sheet-clip) ,dx))
	       (pop clipping-region)
	       (setf (first clipping-region) (+ (pop sheet-clip) ,dy))
	       (pop clipping-region)
	       (setf (first clipping-region) (+ (pop sheet-clip) ,dx))
	       (pop clipping-region)
	       (setf (first clipping-region) (+ (pop sheet-clip) ,dy)))
	     (incf ,dx (tv:sheet-left-margin-size ,sheet))
	     (incf ,dy (tv:sheet-top-margin-size ,sheet))
	     (progn . ,body)
	     t))))))

(defun-in-flavor (mac-rpc-screen-two-point-graphics-call mac-rpc-screen)
		 (sheet function left top right bottom alu
		  bounding-box refined-position-test refined-box
		  pen-state foreground-color &rest args)
  (ignore bounding-box refined-position-test refined-box)
  (with-adjusted-graphics-offsets (sheet drawable dx dy clipping-region)
    (incf left dx) (incf top dy) (incf right dx) (incf bottom dy)
    rpc::
    (when buffered-string-font-number
      (send-buffered-string))
    (update-graphics-state drawable alu pen-state foreground-color clipping-region tv:console)
    (apply #'rpc::rpc-screen-call drawable function left top right bottom args)))

(defun-in-flavor (mac-rpc-screen-n-point-graphics-call mac-rpc-screen)
		 (sheet function points alu
		  bounding-box refined-position-test refined-box
		  pen-state foreground-color &rest args)
  (ignore bounding-box refined-position-test refined-box)
  (with-adjusted-graphics-offsets (sheet drawable dx dy clipping-region)
    (stack-let ((new-points (make-array (length points) :initial-contents points)))
      (loop for i from 0 by 2 below (length new-points) do
	(incf (aref new-points i) dx)
	(incf (aref new-points (1+ i)) dy))
      rpc::
      (when buffered-string-font-number
	(send-buffered-string))
      (update-graphics-state drawable alu pen-state foreground-color
			     clipping-region tv:console)
      (apply #'rpc::rpc-screen-call drawable function new-points args))))

(graphics::define-screen-specific-graphics-type mac-rpc-screen
						mac-rpc-screen-two-point-graphics-call
						mac-rpc-screen-n-point-graphics-call)

(defmacro mac-rpc-screen-specific-graphics (&key (stream 'stream)
						 (drawing-state
						   `(graphics::get-drawing-state ,stream))
						 default-function screen-function
						 argument-type point-arguments
						 (default-arguments nil)
						 (default-drawing-arguments nil)
						 (other-arguments nil)
						 (color-p nil)
						 bounding-box
						 refined-position-test refined-box)
  `(multiple-value-bind (pen-state foreground-color alu)
       (qd-state-pen-state-and-color ,drawing-state ,stream ,@(and color-p (ncons color-p)))
     (graphics::screen-specific-graphics
       :type 'mac-rpc-screen
       :stream ,stream :drawing-state ,drawing-state :alu alu
       :bounding-box ,bounding-box
       :refined-position-test ,refined-position-test :refined-box ,refined-box
       :default-function ,default-function
       :default-arguments ,default-arguments
       :default-drawing-arguments (,@default-drawing-arguments
				   (pen-state-drawing-args pen-state :color foreground-color
							   :mode :pen))
       :screen-function ,screen-function :screen-arguments (pen-state foreground-color)
       :argument-type ,argument-type :point-arguments ,point-arguments :transform-points t
       :other-arguments ,other-arguments)))

;;; We might also want to check that the inferior's screen array is in host memory
(defmethod (drawing-state-mac-rpc-scan-conversion-allowed graphics::drawing-state) ()
  (and (ldb-test graphics::%%scan-conversion-host-allowed
		 (graphics::get-drawing-state-scan-conversion-flags self))
       (not graphics::dashed)	;NIY
       ))

(defmethod (graphics::%screen-draw-point mac-rpc-screen) (sheet x y &key)
  (graphics::%screen-draw-line self sheet x y x y))

(defmethod (graphics::%screen-draw-line mac-rpc-screen)
	   (sheet start-x start-y end-x end-y &key)
  (let ((drawing-state (graphics::get-drawing-state sheet)))
    (if (drawing-state-mac-rpc-scan-conversion-allowed
	  (graphics::get-drawing-state sheet))
	(mac-rpc-screen-specific-graphics
	  :stream sheet :drawing-state drawing-state
	  :default-function (flavor:generic graphics::default-draw-line)
	  :screen-function #'rpc-window-draw-line-from-to
	  :argument-type :two-point
	  :point-arguments (start-x start-y end-x end-y)
	  :bounding-box (values (min start-x end-x)
				(min start-y end-y)
				(+ (max start-x end-x) (pen-state-pen-width pen-state))
				(+ (max start-y end-y) (pen-state-pen-height pen-state)))
	  :refined-position-test ((x y)
				  (dw::point-close-to-line-p x y start-x start-y end-x end-y
							     (pen-state-pen-width pen-state)))
	  :refined-box (dw::outline-line-with-hexagon start-x start-y end-x end-y
						      (pen-state-pen-width pen-state)))
	(graphics::default-draw-line sheet start-x start-y end-x end-y))))

(defmethod (graphics::%screen-draw-lines mac-rpc-screen)
	   (sheet points &rest args &key (closed nil) (join-to-path nil))
  (let ((drawing-state (graphics::get-drawing-state sheet)))
    (if (and (not join-to-path)
	     (drawing-state-mac-rpc-scan-conversion-allowed drawing-state))
	(if closed
	    (graphics::%screen-draw-polygon self sheet points :filled nil)
	    (mac-rpc-screen-specific-graphics
	      :stream sheet :drawing-state drawing-state
	      :default-function (flavor:generic graphics::default-draw-lines)
	      :screen-function #'rpc-window-frame-poly-points
	      :argument-type :n-point
	      :point-arguments (points)
	      :bounding-box (multiple-value-bind (left top right bottom)
				(dw::point-sequence-box points)
			      (values left top
				      (+ right (pen-state-pen-width pen-state))
				      (+ bottom (pen-state-pen-height pen-state))))))
	(apply #'graphics::default-draw-lines sheet points args))))

(defmethod (graphics::%screen-draw-rectangle mac-rpc-screen) (sheet left top right bottom
							      &key (filled t))
  (let ((drawing-state (graphics::get-drawing-state sheet)))
    (if (not (drawing-state-mac-rpc-scan-conversion-allowed drawing-state))
	(graphics::default-draw-rectangle sheet left top right bottom :filled filled)
	(cond ((not (zerop (graphics:decompose-transform
			     (graphics::drawing-state-transform drawing-state))))
	       ;; Rotated, might be any quadrilateral
	       (stack-let ((points (list left top left bottom right bottom right top)))
		 (graphics::%screen-draw-polygon self sheet points
						 :filled filled :points-are-convex-p t)))
	      (filled
	       (mac-rpc-screen-specific-graphics
		 :stream sheet :drawing-state drawing-state
		 :default-function (flavor:generic graphics::default-draw-rectangle)
		 :screen-function #'rpc-window-paint-rect-points
		 :argument-type :two-point
		 :point-arguments (left top right bottom)
		 :bounding-box (values left top right bottom)))
	      (t
	       (mac-rpc-screen-specific-graphics
		 :stream sheet :drawing-state drawing-state
		 :default-function (flavor:generic graphics::default-draw-rectangle)
		 :default-arguments (:filled nil)
		 :screen-function #'rpc-window-frame-rect-points
		 :argument-type :two-point
		 :point-arguments (left top right bottom)
		 :bounding-box (values left top
				       (+ right (pen-state-pen-width pen-state))
				       (+ bottom (pen-state-pen-height pen-state)))))))))

(defmethod (graphics::%screen-draw-triangle mac-rpc-screen)
	   (sheet x1 y1 x2 y2 x3 y3 &rest args &key (filled t) &allow-other-keys)
  (let ((drawing-state (graphics::get-drawing-state sheet)))
    (if (not (drawing-state-mac-rpc-scan-conversion-allowed drawing-state))
	(apply #'graphics::default-draw-triangle sheet x1 y1 x2 y2 x3 y3 args)
	(stack-let ((points (list x1 y1 x2 y2 x3 y3)))
	  (if filled
	      (mac-rpc-screen-specific-graphics
		:stream sheet :drawing-state drawing-state
		:default-function (flavor:generic graphics::default-draw-polygon)
		:screen-function #'rpc-window-paint-poly-points
		:argument-type :n-point-closed
		:point-arguments (points)
		:bounding-box (dw::point-sequence-box points))
	      (mac-rpc-screen-specific-graphics
		:stream sheet :drawing-state drawing-state
		:default-function (flavor:generic graphics::default-draw-polygon)
		:default-arguments (:filled nil)
		:screen-function #'rpc-window-frame-poly-points
		:argument-type :n-point-closed
		:point-arguments (points)
		:bounding-box (multiple-value-bind (left top right bottom)
				  (dw::point-sequence-box points)
				(values left top
					(+ right (pen-state-pen-width pen-state))
					(+ bottom (pen-state-pen-height pen-state))))))))))

(defmethod (graphics::%screen-draw-polygon mac-rpc-screen)
	   (sheet points &rest args &key (points-are-convex-p nil) (filled t))
  (ignore points-are-convex-p)
  (let ((drawing-state (graphics::get-drawing-state sheet)))
    (if (not (drawing-state-mac-rpc-scan-conversion-allowed drawing-state))
	(apply #'graphics::default-draw-polygon sheet points args)
	(if filled
	    (mac-rpc-screen-specific-graphics
	      :stream sheet :drawing-state drawing-state
	      :default-function (flavor:generic graphics::default-draw-polygon)
	      :screen-function #'rpc-window-paint-poly-points
	      :argument-type :n-point-closed
	      :point-arguments (points)
	      :bounding-box (dw::point-sequence-box points))
	    (mac-rpc-screen-specific-graphics
	      :stream sheet :drawing-state drawing-state
	      :default-function (flavor:generic graphics::default-draw-polygon)
	      :default-arguments (:filled nil)
	      :screen-function #'rpc-window-frame-poly-points
	      :argument-type :n-point-closed
	      :point-arguments (points)
	      :bounding-box (multiple-value-bind (left top right bottom)
				(dw::point-sequence-box points)
			      (values left top
				      (+ right (pen-state-pen-width pen-state))
				      (+ bottom (pen-state-pen-height pen-state)))))))))

(defun default-draw-oval (stream left top right bottom
			  &optional (start-mac-angle 0) (arc-mac-angle 360)
			  &rest args)
  (multiple-value-bind (start-angle end-angle clockwise)
      (convert-from-mac-arc start-mac-angle arc-mac-angle)
    (apply (flavor:generic graphics::default-draw-ellipse) stream
	   (floor (+ left right) 2) (floor (+ bottom top) 2)
	   (floor (- right left) 2) (floor (- bottom top) 2)
	   :start-angle start-angle :end-angle end-angle :clockwise clockwise
	   args)))

(defmethod (graphics::%screen-draw-ellipse mac-rpc-screen)
	   (sheet center-x center-y x-radius y-radius
	    &rest args
	    &key (inner-x-radius 0) (inner-y-radius 0)
		 (start-angle 0)
		 (end-angle graphics:2pi)
		 (clockwise nil)
		 (join-to-path nil)
		 (filled t))
  (let ((drawing-state (graphics::get-drawing-state sheet)))
    (if (or (not (drawing-state-mac-rpc-scan-conversion-allowed drawing-state))
	    join-to-path (not (zerop inner-x-radius)) (not (zerop inner-y-radius))
	    (and (or ( x-radius y-radius)
		     (not (graphics::full-circle-p start-angle end-angle)))
		 ;; An ellipse or arc is distorted y rotation and an arc by stretching.
		 (multiple-value-bind (rotation scale-x scale-y)
		     (graphics:decompose-transform
		       (graphics::drawing-state-transform drawing-state))
		   (or (not (zerop rotation))
		       (when (not (graphics::full-circle-p start-angle end-angle))
			 (if ( (abs scale-x) (abs scale-y)) t
			     (when (minusp scale-x)
			       (setq start-angle (- pi start-angle)
				     end-angle (- pi end-angle)
				     clockwise (not clockwise)))
			     (when (minusp scale-y)
			       (setq start-angle (- start-angle)
				     end-angle (- end-angle)
				     clockwise (not clockwise)))
			     nil))))))
	(apply #'graphics::default-draw-ellipse sheet center-x center-y x-radius y-radius args)
	(let ((left (- center-x x-radius))
	      (top (- center-y y-radius))
	      (right (+ center-x x-radius))
	      (bottom (+ center-y y-radius)))
	  (if (graphics::full-circle-p start-angle end-angle)
	      (if filled
		  (mac-rpc-screen-specific-graphics
		    :stream sheet :drawing-state drawing-state
		    :default-function #'default-draw-oval
		    :default-arguments (0 360)
		    :screen-function #'rpc-window-paint-oval-points
		    :argument-type :two-point
		    :point-arguments (left top right bottom)
		    :bounding-box (values left top right bottom)
		    :refined-position-test ((x y)
					    (let ((center-x (floor (+ left right) 2))
						  (center-y (floor (+ top bottom) 2))
						  (x-radius (floor (- right left) 2))
						  (y-radius (floor (- bottom top) 2)))
					      ( (+ (expt (* (- x center-x) y-radius) 2)
						    (expt (* (- y center-y) x-radius) 2))
						 (expt (* x-radius y-radius) 2))))
		    :refined-box (dw:computing-outline-from-path (stream)
				   (let ((center-x (floor (+ left right) 2))
					 (center-y (floor (+ top bottom) 2))
					 (x-radius (abs (floor (- right left) 2)))
					 (y-radius (abs (floor (- bottom top) 2))))
				     (graphics::draw-scaled-simple-ellipse
				       stream center-x center-y
				       (+ x-radius 2) (+ y-radius 2)))))
		  (mac-rpc-screen-specific-graphics
		    :stream sheet :drawing-state drawing-state
		    :default-function #'default-draw-oval
		    :default-arguments (0 360 :filled nil)
		    :screen-function #'rpc-window-frame-oval-points
		    :argument-type :two-point
		    :point-arguments (left top right bottom)
		    :bounding-box (values left top
					  (+ right (pen-state-pen-width pen-state))
					  (+ bottom (pen-state-pen-height pen-state)))
		    :refined-position-test ((x y)
					    (let ((center-x (floor (+ left right) 2))
						  (center-y (floor (+ top bottom) 2))
						  (x-radius (floor (- right left) 2))
						  (y-radius (floor (- bottom top) 2)))
					      (and (dw::point-inside-ellipse-p
						     x y center-x center-y
						     (+ x-radius 2) (+ y-radius 2))
						   (or ( x-radius 2) ( y-radius 2)
						       (not (dw::point-inside-ellipse-p
							      x y center-x center-y
							      (- x-radius 2) (- y-radius 2))))
						   )))
		    :refined-box (dw:computing-outline-from-path (stream)
				   (let ((center-x (floor (+ left right) 2))
					 (center-y (floor (+ top bottom) 2))
					 (x-radius (abs (floor (- right left) 2)))
					 (y-radius (abs (floor (- bottom top) 2))))
				     (graphics::draw-scaled-simple-ellipse
				       stream center-x center-y
				       (+ x-radius 2) (+ y-radius 2))
				     (when (and (> x-radius 2) (> y-radius 2))
				       (graphics::draw-scaled-simple-ellipse
					 stream center-x center-y
					 (- x-radius 2) (- y-radius 2)))))))
	      (multiple-value-bind (start-mac-angle arc-mac-angle)	;we're drawing an arc
		  (convert-to-mac-arc start-angle end-angle clockwise)
		;; Normalize drawing direction for bounding box, position, etc.
		(when clockwise (rotatef start-angle end-angle))
		(if filled
		    (mac-rpc-screen-specific-graphics
		      :stream sheet :drawing-state drawing-state
		      :default-function #'default-draw-oval
		      :screen-function #'rpc-window-paint-arc-points
		      :argument-type :two-point
		      :point-arguments (left top right bottom)
		      :other-arguments (start-mac-angle arc-mac-angle)
		      :bounding-box (dw::elliptical-arc-box
				      (floor (+ left right) 2)
				      (floor (+ top bottom) 2)
				      (abs (floor (- right left) 2))
				      (abs (floor (- bottom top) 2))
				      start-angle end-angle t)
		      :refined-position-test ((x y)
					      (let ((center-x (floor (+ left right) 2))
						    (center-y (floor (+ top bottom) 2))
						    (x-radius (abs (floor (- right left) 2)))
						    (y-radius (abs (floor (- bottom top) 2))))
						(and ( (+ (expt (* (- x center-x) y-radius) 2)
							   (expt (* (- y center-y) x-radius) 2)
							   )
							(expt (* x-radius y-radius) 2))
						     (dw::point-between-angles-p
						       x y center-x center-y
						       start-angle end-angle))))
		      :refined-box (dw:computing-outline-from-path (stream)
				     (let ((center-x (floor (+ left right) 2))
					   (center-y (floor (+ top bottom) 2))
					   (x-radius (abs (floor (- right left) 2)))
					   (y-radius (abs (floor (- bottom top) 2))))
				       (graphics:draw-ellipse center-x center-y
							      x-radius y-radius
					 :start-angle start-angle :end-angle end-angle
					 :filled nil :stream stream)
				       (graphics:with-graphics-translation
					 (stream center-x center-y)
					 (graphics:draw-line 0 0 y-radius 0
							     :rotation start-angle
							     :scale-x (/ x-radius y-radius)
							     :stream stream)
					 (graphics:draw-line 0 0 y-radius 0
							     :rotation end-angle
							     :scale-x (/ x-radius y-radius)
							     :stream stream)))))
		    (mac-rpc-screen-specific-graphics
		      :stream sheet :drawing-state drawing-state
		      :default-function #'default-draw-oval
		      :default-arguments (:filled nil)
		      :screen-function #'rpc-window-frame-arc-points
		      :argument-type :two-point
		      :point-arguments (left top right bottom)
		      :other-arguments (start-mac-angle arc-mac-angle)
		      :bounding-box (multiple-value-bind (left top right bottom)
					(dw::elliptical-arc-box
					  (floor (+ left right) 2)
					  (floor (+ top bottom) 2)
					  (abs (floor (- right left) 2))
					  (abs (floor (- bottom top) 2))
					  start-angle end-angle nil) 
				      (values left top
					      (+ right (pen-state-pen-width pen-state))
					      (+ bottom (pen-state-pen-height pen-state))))
		      :refined-position-test ((x y)
					      (let ((center-x (floor (+ left right) 2))
						    (center-y (floor (+ top bottom) 2))
						    (x-radius (abs (floor (- right left) 2)))
						    (y-radius (abs (floor (- bottom top) 2))))
						(and (dw::point-inside-ellipse-p
						       x y center-x center-y
						       (+ x-radius 2) (+ y-radius 2))
						     (or ( x-radius 2) ( y-radius 2)
							 (not (dw::point-inside-ellipse-p
								x y center-x center-y
								(- x-radius 2)
								(- y-radius 2))))
						     (dw::point-between-angles-p
						       x y center-x center-y
						       start-angle end-angle))))
		      :refined-box (dw:computing-outline-from-path (stream)
				     (let ((center-x (floor (+ left right) 2))
					   (center-y (floor (+ top bottom) 2))
					   (x-radius (abs (floor (- right left) 2)))
					   (y-radius (abs (floor (- bottom top) 2))))
				       (graphics:draw-ellipse center-x center-y
							      x-radius y-radius
							      :start-angle start-angle
							      :end-angle end-angle
							      :filled nil :stream stream)))
		      ))))))))

;;; A testing function...
#||
(defun test-ellipse (&optional (do-host t) (single-box t) (up t))
  (let ((stream *standard-output*)
	(r 100))
    (fresh-line)
    (graphics:with-room-for-graphics (stream)
      (dw:with-redisplayable-output (:stream stream)
	(graphics:with-graphics-translation (stream (* 2 r) (* 2 r))
	  (loop repeat (if do-host 2 1) for host = nil then t do
	    (loop repeat 2 for clockwise = nil then t do
	      (graphics:with-graphics-scale (stream 1 (if up 1 -1))
		(graphics:with-graphics-translation
		  (stream (if clockwise 0 (* 2.5 r)) 0)
		  (graphics:draw-string
		    (if clockwise "Clockwise" "Counterclockwise")
		    0 (- r) :attachment-y (if up :top :bottom) :attachment-x :center)
		  (loop for start from -1 to 1 by 1/4
			for end = (+ start (if clockwise -1/8 1/8)) do
		    (dw:with-output-as-presentation
			(:stream stream
			 :object `(,(if host :host :genera) ,start ,end)
			 :single-box single-box)
		      (graphics:with-scan-conversion-mode (stream :host-allowed host)
			(graphics:draw-ellipse
			  0 0 r r :stream stream
			  :start-angle (* start pi)
			  :end-angle (* end pi)
			  :clockwise clockwise
			  :gray-level (* (if host .5 1) (if clockwise .5 1))
			  :scale (if host .7 1))))))))))))))
||#

(defun rpc-window-draw-glyphs (application-id window-id x&y string font-number)
  (rpc-window-text-mode-from-pen-mode application-id window-id)
  (rpc-window-text-font application-id window-id (ldb (byte 16 16) font-number))
  (rpc-window-text-face application-id window-id (ldb (byte 8 8) font-number))
  (rpc-window-text-size application-id window-id (ldb (byte 8 0) font-number))
  (rpc-window-move-to application-id window-id (elt x&y 0) (elt x&y 1))
  (rpc-window-draw-string application-id window-id string))

(defun default-draw-glyphs (stream x&y string font-number font &rest args)
  (ignore font-number)
  (loop with y = (- (elt x&y 1) (zl:font-baseline font))
	for index being the array-elements of string
	for x = (elt x&y 0) then (+ x (let ((cwt (zl:font-char-width-table font)))
					(if cwt (aref cwt index) (zl:font-char-width font))))
	do
    (apply #'graphics::default-draw-glyph stream index font x y args)))

(defmethod (graphics::%screen-draw-glyph mac-rpc-screen)
	   (sheet index font x y)
  ;; Y coordinate is top of glyph.
  ;; Text is never opaque, and trying to draw opaque text on the Mac clips portions
  ;; of italic characters that extend past the character's width.  So use :opaque nil.
  (graphics:with-drawing-state (sheet :opaque nil)
    (let ((drawing-state (graphics::get-drawing-state sheet)))
      (if (not (drawing-state-mac-rpc-scan-conversion-allowed drawing-state))
	  ;; default-draw-glyph expects Y coordinate corresponding to top of glyph.
	  (graphics::default-draw-glyph sheet index font x y)
	  (let ((font-number (send tv:display-device-type :rpc-font-number self font)))
	    (graphics::transform-and-fix-points-internal (graphics:stream-transform sheet)
							 x y)
	    (graphics:with-graphics-identity-transform (sheet)
	    (if (null font-number)
		(graphics::default-draw-glyph sheet index font x y)
		(stack-let ((points (list x (+ y (zl:font-baseline font))))
			    (string (make-array 1 :element-type '(unsigned-byte 8)
						:initial-element index)))
		  (mac-rpc-screen-specific-graphics
		    :stream sheet :drawing-state drawing-state
		    :screen-function #'rpc-window-draw-glyphs
		    ;; rpc-window-draw-glyphs expects Y coordinate
		    ;; corresponding to baseline of glyph. 
		    :argument-type :n-point
		    :point-arguments (points)
		    :other-arguments (string font-number)
		    :default-function #'default-draw-glyphs
		    ;; default-draw-glyphs expects Y coordinate
		    ;; corresponding to baseline of glyph.
		    :default-arguments (font)
 		    :bounding-box (values x y
					  (+ x (let ((cwt (zl:font-char-width-table font)))
						 (if cwt (aref cwt index)
						     (zl:font-char-width font))))
					  (+ y (zl:font-char-height font)))
		    ;; bounding box calculation should use the "top"
		    ;; value for Y, not the "baseline" value
		    )))))))))

(defmethod (graphics::%screen-draw-string mac-rpc-screen)
	   (sheet string x y
	    &rest args
	    &key (toward-x (1+ x)) (toward-y y) (stretch-p nil) (character-style nil)
		 (record-as-text nil)
	    &allow-other-keys)
  (block done
   ;; Text is never opaque, and trying to draw opaque text on the Mac clips portions
   ;; of italic characters that extend past the character's width.  So use :opaque nil.
   (graphics:with-drawing-state (sheet :opaque nil)
    (let ((drawing-state (graphics::get-drawing-state sheet)))
      (unless (drawing-state-mac-rpc-scan-conversion-allowed drawing-state)
	(apply #'graphics::default-draw-string sheet string x y args)
	(return-from done))
      (graphics::transform-and-fix-points-internal (graphics:stream-transform sheet)
						   x y toward-x toward-y)
      (multiple-value-bind (left top right bottom baseline-y toward-x toward-y string-width)
	  (apply #'graphics::draw-string-bounding-box-internal sheet string x y
		 :toward-x toward-x :toward-y toward-y args)
	(ignore top right bottom)
	(when (and record-as-text (send-if-handles sheet :output-recording-enabled)
		   (= toward-y baseline-y) ( toward-x left) (not stretch-p))
	  (multiple-value-bind (ox oy)
	      (send sheet :read-cursorpos)
	    (with-character-style (character-style sheet :bind-line-height t)
	      (send sheet :set-cursorpos left (- baseline-y (send sheet :baseline)))
	      (send sheet :string-out string))
	    (send sheet :set-cursorpos ox oy))
	  (return-from done))
	(graphics:with-graphics-identity-transform (sheet)
	  (stack-let* ((pen-x left)
		       (pen-y baseline-y)
		       (indices (make-array (min 128 (sys:vector-length string))
					    :element-type '(unsigned-byte 8)
					    :fill-pointer 0))
		       (last-font nil)
		       start-x start-y)
	    (labels ((add-glyph (index font x y width)
		       (unless (and (eql font last-font) (= x pen-x) (= y pen-y))
			 (force-string)
			 (setq last-font font
			       pen-x x
			       pen-y y)
			 (setq start-x pen-x
			       start-y pen-y))
		       (loop until (vector-push index indices)
			     do (force-string))
		       (incf pen-x width))
		     (force-string ()
		       (when (plusp (fill-pointer indices))
			 (let ((font-number (send tv:display-device-type :rpc-font-number self
						  last-font)))
			   (stack-let ((points (list start-x start-y)))
			     (if font-number
				 (let* ((top (- start-y (tv:font-baseline last-font)))
					(bottom (+ top (tv:font-char-height last-font))))
				   (mac-rpc-screen-specific-graphics
				     :stream sheet :drawing-state drawing-state
				     :screen-function #'rpc-window-draw-glyphs
				     :argument-type :n-point
				     :point-arguments (points)
				     :other-arguments (indices font-number)
				     :default-function #'default-draw-glyphs
				     :default-arguments (last-font)
				     :bounding-box (values start-x top pen-x bottom)))
				 (default-draw-glyphs sheet points indices font-number
						      last-font))))
			 (setf (fill-pointer indices) 0))))
	      (setq character-style (si:merge-character-styles
				      character-style
				      (tv:sheet-merged-current-style sheet)))
	      (let ((x pen-x)
		    (y pen-y)
		    (x-adjust nil) (y-adjust nil) (adjust-denominator 1)
		    left-of-pen up-p)
		(let ((dx (- toward-x x))
		      (dy (- toward-y y))
		      (string-length (sys:vector-length string)))
		  (setq up-p (minusp dy)
			left-of-pen (or (minusp dx) (and (zerop dx) up-p)))
		  (cond (stretch-p
			 (setq x-adjust dx
			       y-adjust dy
			       adjust-denominator string-length))
			((= dy 0)			;Horizontal
			 (setq y-adjust 0))
			((= dx 0)			;Vertical
			 (setq x-adjust 0))
			((> (abs dx) (abs dy))	;X major
			 (setq y-adjust (* dy string-width)
			       adjust-denominator (* (abs dx) string-length)))
			(t			;Y major
			 (multiple-value-bind (nil nil total-height)
			     (send sheet :draw-string-size string character-style)
			   (setq x-adjust (* dx total-height)
				 adjust-denominator (* (abs dy) string-length))))))
		(flet ((do-char (char count)
			 (multiple-value-bind (index font)
			     (unless ( #o200 (char-code char) #o277)	;Not format effectors
			       (si:lookup-index-and-font char tv:display-device-type
							 character-style nil))
			   (when (and index
				      (< index (tv:font-fill-pointer font))
				      (let ((cit (tv:font-chars-exist-table font)))
					(or (null cit) (aref cit index))))
			     (let ((cw (let ((font-cwt (tv:font-char-width-table font))
					     (font-cw (tv:font-char-width font)))
					 (tv:compute-char-width index font-cwt font-cw))))
			       (add-glyph index font (if left-of-pen (- x cw) x) y cw)
			       (if x-adjust
				   (incf x (- (floor (* (1+ count) x-adjust)
						     adjust-denominator)
					      ;; Spread out roundoff error
					      (floor (* count x-adjust)
						     adjust-denominator)))
				   (if left-of-pen
				       (decf x cw)
				       (incf x cw)))
			       (if y-adjust
				   (incf y (- (floor (* (1+ count) y-adjust)
						     adjust-denominator)
					      (floor (* count y-adjust)
						     adjust-denominator)))
				   (if up-p
				       (decf y (tv:font-char-height font))
				       (incf y (tv:font-char-height font)))))))))
		  (if left-of-pen
		      (loop for char being the array-elements of string
			    downfrom (1- (sys:vector-length string)) to 0
				     using (index index)
			    do (do-char char index))
		      (loop for char being the array-elements of string
				     using (index index)
			    do (do-char char index)))))
	      (force-string)))))))))

(defflavor mac-rpc-pixmap-correspondence () (mac-rpc-drawable rpc::rpc-pixmap-correspondence))

(defmethod (color:%screen-inferior-color-p mac-rpc-screen) (sheet)
  (cond ((and (> rpc::true-remote-depth 1)
	      (if (operation-handled-p sheet 'graphics::get-drawing-state)
		  (drawing-state-mac-rpc-scan-conversion-allowed
		    (graphics::get-drawing-state sheet))
		  (ldb-test graphics::%%scan-conversion-host-allowed
			    graphics::*default-scan-conversion-flags*)))
	 :remote)
	((send-if-handles self :color-map)
	 :local)))

;;;

(defflavor mac-rpc-bitmap-screen () (tv:basic-remote-bitmap-screen mac-rpc-screen))

(defresource mac-rpc-bitmap-screen ()
  :constructor (make-instance 'mac-rpc-bitmap-screen))

(defmethod (:screen-allocate-bitmap-stream mac-rpc-screen) (&rest ignore)
  (allocate-resource 'mac-rpc-bitmap-screen))

(defmethod (tv:deallocate-bitmap-stream mac-rpc-bitmap-screen) ()
  (deallocate-resource 'mac-rpc-bitmap-screen self))

;;;

(compile-flavor-methods mac-rpc-console mac-rpc-main-console
			mac-rpc-screen mac-rpc-pixmap-correspondence mac-rpc-bitmap-screen)

;;;; The Genera screen compatibilty application

(si:define-character-style-families *mac-display-device* si:*mouse-character-set*
  '(:family :fix (:size :normal (:face :roman fonts:mouse))))

(defmethod (:rpc-font-number basic-mac-display-device) (screen font)
  (rpc::rpc-screen-font-number screen font))

(dw:define-remote-program-framework genera
  :selectable (:mac)
  :menu-level-order `(("File" "Close" nil "Quit")
		      ,*standard-edit-menu*
		      "Options")
  :inherit-from (remote-quit-commands)
  :command-table (:kbd-accelerator-p t :inherit-from '("remote-quit-commands"))
  :state-variables ((console nil)
		    (n-remote-screens 0) (n-deep-screens 0)
		    (enable-movable-screen rpc:*RPC-Screen-Use-Host-Screen-Style*)
		    (enable-backup-screen (or rpc:*RPC-Screen-Always-Use-Backup-Screen*
					      rpc:*RPC-Screen-Use-Backup-Screen*)))
  )

(dw:define-subcommand-menu-handler "Keyboard" genera ((:mac :options)) (:mac :keyboard))

(defwhopper (dw::lookup-menu-handler genera) (menu-level menu-item &key (gesture ':left))
  (cond ((member menu-item '("Fixed Screen" "Movable Screen") :test #'equal)
	 (continue-whopper menu-level "Window Fixed/Movable" :gesture gesture))
	((member menu-item '("Disable Backup Screen" "Enable Backup Screen") :test #'equal)
	 (continue-whopper menu-level "Backup Screen Enable/Disable" :gesture gesture))
	(t
	 (continue-whopper menu-level menu-item :gesture gesture))))

(defwhopper (dw::remote-program-menu-items genera) ()
  (let ((menus (continue-whopper)))
    (dolist (menu menus)
      (when (equal (first (first menu)) "Options")
	(dolist (menu-item (rest menu))
	  (cond ((equal (first menu-item) "Backup Screen Enable/Disable")
		 (setf (first menu-item) (if enable-backup-screen
					     "Disable Backup Screen"
					     "Enable Backup Screen")))
		((equal (first menu-item) "Window Fixed/Movable")
		 (setf (first menu-item) (if enable-movable-screen
					     "Fixed Screen"
					     "Movable Screen")))))))
    menus))

;;; Make remote console screen Movable (gives it a title bar, grow box, and zoom box)
(define-genera-command (com-Window-Fixed/Movable :menu-accelerator "Window Fixed/Movable"
						 :menu-level ((:mac :options)))
		       ()
  (setf enable-movable-screen (not enable-movable-screen))
  (rpc::change-screen-style (sys:console-screen console)
			    (rpc::rpc-console-screen-drawable console)
			    (rpc::rpc-screen-screen-number (sys:console-screen console))
			    enable-movable-screen)
  (rpc-program-install-menus self))

;;; Make remote console screen have a backup screen/ disable backup screen
(define-genera-command (com-Backup-Screen-Enable/Disable :menu-accelerator
							 "Backup Screen Enable/Disable"
							 :menu-level ((:mac :options)))
		       ()
  (if RPC:*RPC-Screen-Always-Use-Backup-Screen*
      (remove-remote-menu-item self "Backup Screen Enable/Disable" '((:mac :options)))
      (setf enable-backup-screen (not enable-backup-screen))
      (rpc::Set-Backup-Screen (sys:console-screen console)
			      (rpc::rpc-console-screen-drawable console)
			      enable-backup-screen)
      )
  (rpc-program-install-menus self))

(defmethod (rpc-program-note-start genera :before) (ignore)
  (setq n-remote-screens (rpc-program-call self #'rpc::rpc-console-query-peripherals)
	n-deep-screens (loop for i from 1 to n-remote-screens
			     count
			       (multiple-value-bind (nil nil depth)
				   (rpc-program-call self #'rpc::rpc-console-query-screen-size
						     i t)
				 (> depth 1)))))

(define-genera-command (com-start-screen)
    (&key
      (initial-activity '((token-or-type (("None") "Initial Lisp") sys:activity-name))
			:name "Initial Activity"
			:documentation "An Initial Activity"
			:default "Initial Lisp")  
      (screen-number `((token-or-type (("Default" . 0)) ((integer 1 ,n-remote-screens))))
		     :name "Screen Number" :default 0
		     :documentation "A Macintosh Screen Number"
		     :when (> n-remote-screens 1))
      (movable-screen-p 'boolean :default enable-movable-screen :name "Movable Screen")
      (backup-screen-p 'boolean :default enable-backup-screen :name "Backup Screen"
		       :when (null rpc:*rpc-screen-always-use-backup-screen*))
      (multi-bit-screen 'boolean :default nil
			:name "Color"
			:documentation "Color"
			:when (plusp n-deep-screens))
      (who-line-p 'boolean :default t :name "Who Line" :documentation "Who Line")
      (main-p 'boolean :default (and (embedded-agent-p (rpc-program-transport-agent self))
				     (null sys:*main-console*))
	      :name "Main Screen"
	      :documentation "Main Screen")
      (display-device-type
	`((scl:alist-member :alist (("Genera fonts as images"
				     :value ,si:*b&w-screen*)
				    ("Genera fonts installed on Mac"
				     :value ,*genera-fonts-mac-display-device*)
				    ("Just Mac fonts"
				     :value ,*mac-display-device*))))
	:default *genera-fonts-mac-display-device*
	:name "Display Device Type"
	:documentation "Display Device Type")
      )
   ;; Compensate for CP reader not setting defaults or arguments not being read.
   (unless (> n-remote-screens 1)
     (setq screen-number 0))
   (unless (plusp n-deep-screens)
     (setq multi-bit-screen nil))
   (setf enable-backup-screen (or rpc:*rpc-screen-always-use-backup-screen*
				  backup-screen-p))
   (setf enable-movable-screen movable-screen-p)
   ;; hack up the defaulting that you can't do in the args because of the
   ;; ambiguity in screen number
   (multiple-value-bind (width height)
       (rpc-program-call self #'rpc::rpc-console-query-screen-size
			 screen-number nil)
     (when enable-movable-screen
       ;; Take into account the title bar which the Macintosh doesn't yet know will be there.
       (decf height 20))
     ;; guess about fonts 
     (when (and (eq display-device-type *genera-fonts-mac-display-device*)	;
		(or (< width 900) (< height 700)))
       (setq display-device-type *small-screen-genera-fonts-mac-display-device*))
     (setq console (create-rpc-console
		     :flavor (if main-p 'mac-rpc-main-console 'mac-rpc-console)
		     :console-id (rpc-program-application-id self)
		     :transport-agent (rpc-program-transport-agent self)
		     :display-device-type display-device-type
		     :default-screen-number screen-number
		     :multi-bit-screen multi-bit-screen
		     :who-line-p who-line-p
		     :main-p main-p
		     :activity initial-activity
		     :screen-width width
		     :screen-height height
		     :x-offset 0
		     :y-offset 0
		     :host-style enable-movable-screen
		     :backup-screen enable-backup-screen)))
   (rpc-program-install-menus self))

(defmethod (rpc-program-note-start genera :after) (ignore)
  (unless console
    (let ((dw:*program* self))
      (destructuring-bind (command . arguments)
	  (dw::standard-remote-menu-handler 'com-start-screen)
	(rpc-program-call-1 self #'rpc-toolkit-set-standard-cursor 4)
	(apply command arguments)))
    (if rpc:*rpc-screen-always-use-backup-screen*
	(remove-remote-menu-item self "Backup Screen Enable/Disable" '((:mac :options))))
    )
  (unless console				;Command aborted
    (dw:remote-program-quit self)))

;;; Do some of what TV:SHUTDOWN-WINDOW-SYSTEM does, but just to one screen
;;; Also do some of what the :KILL message to the screen would do
(defun shutdown-screen (screen console who-line)
  (let ((who-line-screen (tv:screen-who-line-screen screen)))
    (when who-line-screen
      (shutdown-screen who-line-screen console t)))
  ;; Try not to nail processes that might be drawing on the screen, but only wait 5 seconds
  (process-wait-with-timeout "Sheet Lock" 300. #'tv:sheet-can-get-lock screen)
  (tv:screen-clear-locks screen)
  (setf tv:prepared-sheet nil)
  (tv:shutdown-this-mouse (sys:console-mouse console))
  (tv:without-screen-management
    (dolist (inferior (copy-list (tv:sheet-exposed-inferiors screen)))
      (send inferior :deexpose nil))
    (unless who-line
      (setf (sys:console-selected-window console) nil)))
  (send screen :deexpose)
  (send screen :deactivate)
  (send screen :set-console nil)
  (incf (tv:screen-resource-tick screen))
  (send screen :update-current-timestamp)
  ;; tv:reset-tree-dynamic-state but without resetting any processes
  (tv:map-over-all-inferiors screen #'tv:reset-dynamic-state)
  (when (eq screen tv:default-screen)
    (setq tv:default-screen nil))
  (when (eq screen tv:main-screen)
    (setq tv:main-screen nil))
  (when (eq screen tv:who-line-screen)
    (setq tv:who-line-screen nil
	  tv:nwatch-who-line-sheet nil
	  tv:who-line-run-state-sheet nil
	  tv:who-line-file-state-sheet nil
	  tv:who-line-documentation-window nil))
  (if who-line
      (tv:remove-active-who-line-screen screen)
      (pushnew screen tv:*old-console-screens*)))

(defmethod (rpc-program-note-quit genera :before) ()
  (when console
    (shutdown-screen (sys:console-screen console) console nil)
    (sys:console-disable console)
    (setq console nil)))

(define-genera-command (com-edit-cut/copy )
    ((cut-p 'boolean :default t))
  (let* ((interval
	   (let ((strings (loop for window in (cp::windows-for-marking-and-yanking
						:window (sys:console-selected-window console))
				as text = (send window :marked-text :return-as-string t
						:unmark t
						:delete cut-p)
				when text collect text)))
	     (if (null strings)
		 (send zwei:*kill-history* :yank)
		 (apply #'zwei:kill-ring-push strings))))
	 (string (typecase interval
		   (string interval)
		   (zwei:interval (zwei:string-interval interval))
		   (otherwise nil))))
    (if string
	(rpc-program-call-1 self #'rpc-toolkit-set-scrap
			    (string-length string) (string-to-ascii string))
	(sys:beep))))

(dw:define-command-menu-handler ("Cut" genera ((:mac :edit))) ()
  (declare (dw::corresponding-keyboard-accelerator #\s-X))
  `(com-edit-cut/copy t))

(dw:define-command-menu-handler ("Copy" genera ((:mac :edit))) ()
  (declare (dw::corresponding-keyboard-accelerator #\s-C))
  `(com-edit-cut/copy nil))

(define-genera-command (com-edit-paste :menu-accelerator "Paste"
				       :menu-level ((:mac :edit))
				       :keyboard-accelerator #\s-V)
		       ()
  (let ((string (ascii-to-string (rpc-program-call-1 self #'rpc-toolkit-get-scrap))))
    (zwei:kill-ring-push string)
    (let ((window (sys:console-selected-window console)))
      (when window
	(send window :force-kbd-input
	      (dw::make-presentation-blip :presentation-type 'si:input-editor
					  :object string))))))

(define-genera-command (com-keyboard-control :menu-accelerator t
					     :menu-level ((:mac :keyboard)))
		       ()
   (sys:select-activity "Keyboard control" :console console))

(define-genera-command (com-common-keyboard-settings :menu-accelerator "Common settings"
						     :menu-level ((:mac :keyboard)))
		       ()
   (let* ((keyboard (sys:console-keyboard console))
	  (layout (system-applications::find-keyboard-layout
		    (sys:keyboard-layout-type keyboard)))
	  (table (sys:keyboard-keyboard-table keyboard)))
     (case (system-applications::keyboard-layout-symbolic-name layout)
       (:apple-extended
	 (multiple-value-bind (shift-choice mouse-choice)
	     (dw:with-remote-accepting-values (t :program self
						 :prompt "Command keyboard settings")
	       (values
		 (let ((type '((alist-member :alist (("Control Meta Super"
						      :value (:control :meta :super))
						     ("Super Meta Control"
						      :value (:super :meta :control))
						     ("Meta Control Super"
						      :value (:meta :control :super)))))))
		   (accept type
		     :prompt "Shift key order"
		     :default (tv:menu-execute-no-side-effects
				(find (loop for code in '(#x3B #x3A #x37) collect
				        (let ((mapping (aref table 0 code)))
					  (and (ldb-test sys:%%kbd-mapping-special mapping)
					       (= (ldb sys:%%kbd-mapping-special-class mapping)
						  sys:%kbd-mapping-special-shift)
					       (aref sys:*kbd-mapping-bit-names*
						     (ldb sys:%%kbd-mapping-bit-number
							  mapping)))))
					    (getf (cdar type) :alist)
					    :test #'equal
					    :key #'tv:menu-execute-no-side-effects))))
		 (accept 'boolean :prompt "Mouse keys are buttons (rather than shifts)"
				  :default (null (cli::keyboard-mouse-button-shift-keys
						   keyboard)))))
	   (flet ((set-for-all (hardware-code mapping &optional side-extra)
		    (setq mapping (sys:standardize-keyboard-mapping mapping t))
		    (when side-extra
		      (setf (%logldb side-extra mapping) 1))
		    (dotimes (i (sys:keyboard-table-shift-index-limit table))
		      (setf (aref table i hardware-code) mapping))))
	     (loop for apple-codes in '((#x3B #x3E) (#x3A #x3D) #x37)
		   for shift in shift-choice do
	       (if (atom apple-codes)
		   (set-for-all apple-codes shift)
		 (set-for-all (first apple-codes) shift cli::%%kbd-mapping-left-p)
		 (set-for-all (second apple-codes) shift sys:%%kbd-mapping-right-p)))
	     (let* ((default
		      (system-applications::keyboard-layout-default-mouse-button-shift-keys
			layout))
		    (mouse-m (second (assoc 1 default)))
		    (mouse-r (second (assoc 2 default))))
	       (cond (mouse-choice
		      (set-for-all mouse-m :mouse-m)
		      (set-for-all mouse-r :mouse-r)
		      (setf (cli::keyboard-mouse-button-shift-keys keyboard) nil))
		     (t
		      (set-for-all mouse-m :noop)
		      (set-for-all mouse-r :noop)
		      (setf (cli::keyboard-mouse-button-shift-keys keyboard) default)))))))
       (otherwise
	 ;; Should probably be a simple alert call
	 (display-simple-alert self
			       (format () "There are no possible settings for the ~A keyboard"
				       (system-applications::keyboard-layout-pretty-name
					 layout)))))))


(defun display-simple-alert (program message)
  (multiple-value-bind (width-limit height-limit)
      (rpc-program-call program #'rpc::rpc-console-query-screen-size 0 nil)
    (display-dialog-help program message
			 (make-rect :right (floor width-limit 2)
				    :bottom (floor height-limit 2))
			 width-limit height-limit)))

(compile-flavor-methods genera)
(dw::compile-remote-program-combination genera :mac)
