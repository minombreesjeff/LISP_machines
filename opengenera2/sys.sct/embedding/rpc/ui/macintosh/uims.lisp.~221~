;;; -*- Mode: LISP; Syntax: LISP+C; Package: MACINTOSH-INTERNALS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; RPC program frameworks

(eval-when (eval load compile)

(define-remote-type application-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Application_ID name })))

(define-remote-type window-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Window_ID name })))

(define-remote-type window-characters ()
  (:abbreviation-for '(vector (structure (code cardinal-8) (modifiers cardinal-8))))
  (:c (:declare (name) #{ Window_Characters *name })))

(define-remote-type picture-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Picture_ID name })))

(define-remote-type presentation-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Presentation_ID name })))

(define-remote-type dialog-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Dialog_ID name })))

(define-mac-structure (rpc-menu-list :c-name #{RPCMenuList} :alignment nil)
  (nmenus integer-16)
  (menus (vector rpc-menu-info *)))

(define-mac-structure (rpc-menu-info :c-name #{RPCMenuInfo} :alignment nil)
  (length integer-16)
  (type integer-16)
  (info menu-info))

(define-mac-structure (menu-info :c-name #{MenuInfo} :alignment nil)
  id width height
  (+ ((menu-proc cardinal-32))
     ((proc-id cardinal-16)
      (padding cardinal-16)))
  (enable-flags cardinal-32)
  (data (vector unsigned-byte *)))

(define-remote-type rpc-menu-list ()
  (:abbreviation-for `(opaque-bytes (:c #{RPCMenuList *}))))

(define-remote-type rpc-menu-info ()
  (:abbreviation-for
    `(opaque-bytes (:c #{RPCMenuInfo *} (:length (name) #{name ->length})))))

(define-remote-type quickdraw-picture ()
  (:abbreviation-for
    `(opaque-bytes (:c #{Picture *} (:length (name) #{name ->picSize})))))

(define-mac-structure (presentation-set :c-name #{PresentationSet} :alignment nil)
  (total-length integer-32)
  (release-timeout integer-32)
  (npresentations integer-16)
  (presentations (vector presentation npresentations)))

(define-octet-structure-field-type presentation-id () (&rest args)
  :expander 'cardinal-32
  :c #{Presentation_ID})

(define-mac-structure (presentation :c-name #{Presentation})
  (id presentation-id)
  (rect rect)
  (chords cardinal-32))

(define-remote-type presentation-set ()
  (:abbreviation-for
    `(opaque-bytes (:c #{PresentationSet *} (:length (name) #{name ->total_length})))))

(define-mac-structure (dialog-items :c-name #{RPCDialogItems} :alignment nil)
  (total-length integer-32)
  (nitems integer-16)
  (items (vector dialog-item (1+ nitems))))

(define-mac-structure (dialog-item :c-name #{RPCDialogItem} :alignment nil)
  (handle cardinal-32)
  (display-rect rect)
  (type cardinal-8)
  (length cardinal-8)
  (data (vector cardinal-8 length)))

;;; Dialog-values and dialog-value are moved to event-comm.lisp so we can try to compile 
;;; this *&^%$^%$ system.
;
;(define-mac-structure (dialog-values :c-name #{RPCDialogValues})
;  (total-length integer-32)
;  (nvalues integer-16)
;  (values (vector dialog-value nvalues)))
;
;(define-mac-structure (dialog-value :c-name #{RPCDialogValue})
;  (item-number integer-16)
;  (type (member cardinal-16 '(boolean string)))
;  (+ ((on-p (boolean integer-16)))
;     ((string padded-pascal-string))))

;(define-remote-type dialog-items ()
;  (:abbreviation-for
;    `(opaque-bytes (:c #{RPCDialogItems *} (:length (name) #{name ->total_length})))))
;
;(define-remote-type dialog-values ()
;  (:abbreviation-for
;    `(opaque-bytes (:c #{RPCDialogValues *} (:length (name) #{name ->total_length})))))
)

(defconstant %window-type-document 0)		;documentProc
(defconstant %window-type-dbox 1)		;dBoxProc
(defconstant %window-type-plain-dbox 2)		;plainDBox
(defconstant %window-type-alt-dbox 3)		;altDBoxProc
(defconstant %window-type-no-grow-doc 4)	;noGrowDocProc
(defconstant %window-type-rounded-corner 16)	;rDocProc (radius 16,4,6,8,10,12,20,24)
(defconstant %window-type-zoom 8)		;added to others (no symbolic name?)

(defflavor rpc-program
	((transport-agent *default-transport-agent*)
	 (application-id (new-unique-id)))
	(dw::remote-program)
  (:readable-instance-variables transport-agent application-id)
  (:initable-instance-variables transport-agent))

(si:defvar-resettable *rpc-programs* nil)

(defun find-program-from-application-id (application-id)
  (find application-id *rpc-programs* :key #'rpc-program-application-id))

(eval-when (eval load compile)
(pushnew '(:mac mac-rpc-program) dw::*remote-program-mixins* :replace t :key #'first)
)

(defflavor mac-rpc-program
	((menu-id-levels nil)
	 (windows nil)
	 (saved-menu-items nil))
	(mtb::event-uims rpc-program)
  :writable-instance-variables)

;;; Next free entry is 80, with a hole between 49 and 50.
(define-remote-module rpc-uims-to-mac
  (:number #x7f000125)
  (:version 1)
  (:server :c)
  (:client :lisp))

(rpc::define-standard-rpc-output-definer define-rpc-uims-to-mac-entry rpc-uims-to-mac
					 ((application-id application-id)))

(defprop define-mac-rpc-window-output-entry define-remote-entry
	 zwei:definition-function-spec-type)

;;; Next free entry is 13
(define-remote-module rpc-uims-from-mac
  (:number #x7f000126)
  (:version 1)
  (:server :lisp)
  (:client :c))

(rpc::define-standard-rpc-input-definer define-rpc-uims-from-mac-entry
					rpc-uims-from-mac mac-rpc-program
					find-program-from-application-id
					((application-id application-id)))

(define-remote-error rpc-uims-application-not-available rpc-uims-from-mac
  (:number 1)
  (:arguments (world-load-type-phrase c-string)
	      (available-programs-sentence c-string)))

(define-remote-error rpc-uims-application-startup-error rpc-uims-from-mac
  (:number 2)
  (:arguments (description c-string)
	      (load-file-name c-string)))

(define-remote-entry rpc-uims-start-application rpc-uims-from-mac
  (:number 1)
  (:arguments (name pascal-string))
  (:values (application-id application-id))
  (:lisp
    (:server
      (process-wait "OK to run applications"
	#'(lambda () (null si:*system-initialization-in-progress*)))
      (condition-case (error)
	   (let ((program-name (dw::find-remote-program name :remote-system-type :mac)))
	     (if program-name
		 (let ((program (dw:make-program program-name :remote-system-type :mac
						 :transport-agent rpc::xdr-agent)))
		   ;; Make the default agent be one that we believe is connected to something
		   (sys:setq-globally rpc:*default-transport-agent* rpc::xdr-agent)
		   (without-interrupts (push program *rpc-programs*))
		   (rpc-values (rpc-program-application-id program))
		   (rpc-program-note-start program name))
		 (let ((mac-programs (remove-if-not #'(lambda (item)
							(or (eq (dw::remote-program-name-entry-allowed-remote-system-types item) t)
							    (member :mac (dw::remote-program-name-entry-allowed-remote-system-types item))))
						    dw::*remote-program-names*)))
		   (rpc-error rpc-uims-application-not-available
			      (format nil "~A world file (.~A file)"
				      #+3600 "a 3600"
				      #+(and IMach (not VLM)) "an Ivory"
				      #+(and IMach VLM) "a VLM"
				      #-(or 3600 IMach) "a"
				      (second (assoc si:*world-load-file-type*
						     fs:*default-canonical-types*)))
			      (format nil "The program~P available in this world ~A ~Q."
				      (length mac-programs)
				      (if (cdr mac-programs) "are" "is")
				      #'(lambda ()
					  (format-textual-list mac-programs
					    #'(lambda (item stream)
						(prin1
						  (dw::remote-program-name-entry-pretty-name
						    item)
						  stream))
					    :conjunction "and" :if-two " and " :filled nil)))))
		 ))
	 (error
	   (rpc-error rpc-uims-application-startup-error (dbg:report-string error)
							 si:loaded-band-name))))))

(define-remote-entry rpc-uims-quit-from-mac rpc-uims-from-mac (:number 2)
		     (:arguments (application-id application-id))
		     (:values )					;No values, but synchronous
  (:lisp
    (:server
      (let ((instance (find-program-from-application-id application-id)))
	(when instance
	  (rpc-program-note-quit instance))
	(rpc-values)))))

(defmethod (rpc-program-note-quit mac-rpc-program) ()
  (let ((cons (assoc transport-agent *scratch-resfiles*)))
    (when cons
      ;; Get rid of the scratch resource file
      (stack-let ((fcb (make-fcbpbrec))
		  (name (make-str255))
		  (refnum (cdr cons)))
	(rpc-program-call-1 self #'_PBGetFCBInfo fcb name 0 refnum 0)
	(rpc-program-call-1 self #'_CloseResFile refnum)
	(rpc-program-call-1 self #'_PBHDelete name (fcbpbrec-ioFCBvrefnum fcb 0)
					           (fcbpbrec-ioFCBParID fcb 0)))
      (setq *scratch-resfiles* (delete cons *scratch-resfiles*))))
  (without-interrupts
    (when (setq *rpc-programs* (delete self *rpc-programs*))
      (when (eq rpc:*default-transport-agent* transport-agent)
	;; Keep the default transport agent actually attached to something
	(sys:setq-globally rpc:*default-transport-agent*
			   (rpc-program-transport-agent (first *rpc-programs*)))))))

(defmethod (rpc-program-call mac-rpc-program) (function &rest args)
  (let ((*default-transport-agent* transport-agent))
    (apply function application-id args)))

(defmethod (rpc-program-call-1 mac-rpc-program) (function &rest args)
  (let ((*default-transport-agent* transport-agent))
    (apply function args)))

(define-rpc-uims-to-mac-entry rpc-uims-quit-to-mac 2 () ())

(defmethod (dw:remote-program-quit mac-rpc-program) ()
  (rpc-program-note-quit self)
  (rpc-program-call self #'rpc-uims-quit-to-mac))

(define-rpc-uims-to-mac-entry rpc-uims-install-menus 3
  ((menus rpc-menu-list))
  ())

(define-mac-structure program-init
  (agent (member integer-8 '(nil :tcp :serial :reliable-serial :emb)))
  (host pascal-string)
  (application pascal-string))

(defun write-program-init (to-file agent host application commands)
  (stack-let ((ivri0 (make-array 10 :element-type '(unsigned-byte 8) :fill-pointer 1))
	      (ivri1 (string-to-ascii
		       (with-output-to-string (stream)
			 (let ((dw:*program* (dw:make-program
					       (symbol-value-in-instance
						 (cli::lookup-activity application)
						 'cli::program-name))))
			   (loop for command in commands
				 as first-p = t then nil
				 do
			     (unless first-p
			       (terpri stream))
			     (if (stringp command)
				 (write-string command stream)
				 (present command `((cp:command :command-table ,application))
					  :acceptably t :stream stream))))))))
    (setf (program-init-agent ivri0 0) agent)
    (flet ((append-pascal-string (string to-array)
	     (vector-push-extend (length string) to-array)
	     (when (plusp (length string))
	       (vector-push-portion-extend to-array (string-to-ascii string)))))
      (append-pascal-string host ivri0)
      (append-pascal-string application ivri0))
    (write-mac-file to-file () (make-resource-fork
				 (list (list ivri0 "ivrI" 0)
				       (list ivri1 "ivrI" 1 application)))
		    :name (format nil "~A init" application))))

(defmethod (rpc-program-note-start mac-rpc-program) (program-name)
  (rpc-program-install-menus self)
  (let ((init (rpc-program-call-1 self #'rpc-toolkit-get-named-resource "ivrI" program-name)))
    (when (plusp (length init))
      (setq init (ascii-to-string init))
      (let ((dw:*program* self)
	    (cp:*command-table* dw::command-table))
	(dw::do-delimited-substrings ((init) (ignore start end))
	    (destructuring-bind (command . arguments)
		(accept-from-string 'cp:command init :start start :end end)
	      (apply command arguments))
	  (#\return)))))
  (rpc-program-call-1 self #'rpc-toolkit-set-standard-cursor 0))

;;; Translate from an item list as returned by dw::remote-program-menu-items into a MENU
;;; resource.
(defun menu-items-menu-info (menu-items &optional menu-id)
  (stack-let ((result (make-array 100 :element-type '(unsigned-byte 8) :fill-pointer 0)))
    (setf (fill-pointer result) (octet-structure-field-index (menu-info-data result 0)))
    (when menu-id
      (setf (menu-info-id result 0) menu-id))
    (let ((enabled 0))
      (loop for item in menu-items
	    for index from 0 below 32
	    do (unless (getf (rest item) :disabled)
		 (setf (sys:%logldb (byte 1 index) enabled) 1)))
      (setf (menu-info-enable-flags result 0) enabled))
    (flet ((add-pascal-string (string)
	     (vector-push-extend (string-length string) result)
	     (vector-push-portion-extend result (string-to-ascii string))))
      (add-pascal-string (first (pop menu-items)))
      (dolist (item menu-items)
	(destructuring-bind (name &key argument-menu keyboard-accelerator character-style
				       subcommand-menu
				       disabled)
	    item
	  (ignore disabled)
	  (cond ((null name)
		 (setq name "-"))
		(argument-menu
		 (setq name (string-append name " ..."))))
	  (add-pascal-string name)
	  (let ((icon 0)
		(key 0)
		(mark 0)
		(style 0))
	    (when keyboard-accelerator
	      (setq key (char-to-ascii keyboard-accelerator)))
	    (when character-style
	      (setq style (mac-font-style-for-character-style-face
			    (si:cs-face (si:parse-character-style character-style)))))
	    (when subcommand-menu
	      (setq key #x1B mark subcommand-menu))
	    (vector-push-extend icon result)
	    (vector-push-extend key result)
	    (vector-push-extend mark result)	;mark
	    (vector-push-extend style result)))))
    (vector-push-extend 0 result)
    (copy-seq result)))

(eval-when (eval load compile)
(defvar *menu-id-offset* 100)
)

(defmethod (rpc-program-install-menus mac-rpc-program)
	   (&optional (menu-items (dw::remote-program-menu-items self)))
  (setq menu-id-levels (make-array (1+ (length menu-items))))
  (loop for (name) in menu-items
	for menu-id from (1+ *menu-id-offset*)
	do (setf (aref menu-id-levels (- menu-id *menu-id-offset*))
		 (getf (rest name) :menu-level))
	   (let ((subcommand (getf (rest name) :subcommand-menu)))
	     (when subcommand
	       (let ((item (assoc (second subcommand)
				  (find (first subcommand) menu-items
					:key #'(lambda (entry)
						 (getf (rest (first entry)) :menu-level))
					:test #'equal)
				  :test #'string-equal)))
		 (assert (equal (getf (rest name) :menu-level)
				(getf (rest item) :subcommand-menu)))
		 (setf (getf (rest item) :subcommand-menu) menu-id)))))
  ;; fix sub-command menus that have no items
  (loop for entry in menu-items
	as (nil . items) = entry
	do
    (loop for item in items
	  do
      (let ((sm (getf (rest item) :subcommand-menu)))
	(when (and sm (not (numberp sm)))
	  (setf (getf (rest item) :subcommand-menu) nil)
	  (setf (getf (rest item) :disabled) t)))))
  (setq saved-menu-items menu-items)
  (let ((menu-infos (map 'list #'menu-items-menu-info menu-items)))
    (loop for menu-info in menu-infos
	  for menu-id from (1+ *menu-id-offset*)
	  do
      (setf (menu-info-id menu-info 0) menu-id))
    (stack-let* ((length (+ (loop for menu-info in menu-infos
				  sum (+ (octet-structure-field-index
					   (rpc-menu-info-info menu-list 0))
					 (* 4 (ceiling (length menu-info) 4))))
			    (octet-structure-field-index
			      (rpc-menu-list-menus menu-list 0))))
		 (menu-list (make-array length :element-type '(unsigned-byte 8)))
		 (index 0))
      (setf (rpc-menu-list-nmenus menu-list index) (length menu-infos))
      (setq index (octet-structure-field-index (rpc-menu-list-menus menu-list index)))
      (loop for (name) in menu-items
	    for menu-info in menu-infos
	    do
	(let* ((length (length menu-info))
	       (rounded-length (* 4 (ceiling length 4))))
	  (setf (rpc-menu-info-length menu-list index) (+ rounded-length
							  (octet-structure-field-index
							    (rpc-menu-info-info menu-list 0)))
		(rpc-menu-info-type menu-list index) (if (getf (rest name) :subcommand-menu)
							 1 0))
	  (setq index (octet-structure-field-index (rpc-menu-info-info menu-list index)))
	  (copy-array-portion menu-info 0 length menu-list index (+ index length))
	  (incf index rounded-length)))
      (rpc-program-call self #'rpc-uims-install-menus menu-list))))

(defun merge-menu-bar-items (&rest items)	;allow for future expansion
  (setq items (reduce #'append items))
  ;; Lists are arranged in priority order with higher priority towards the CDR
  ;; NIL items represent dividing lines in the menus
  (let ((result (remove-duplicates (remove nil items :key #'car)
				   :key #'car
				   :test #'string-equal)))
    ;; Put the dividing lines back in, in front of the same things as before
    (loop for (item next) on items
	  as pos = (and (null (car item))
			(position (car next) result :key #'car :test #'string-equal)) do
      (when pos
	(unless (or (zerop pos) (null (car (elt result (1- pos)))))
	  (setq result (nconc (subseq result 0 pos) (ncons item) (nthcdr pos result))))))
    result))

(defun merge-menu-bar-names (&rest names)
  (first (last names)))

(defun merge-menu-bar-lists (&rest lists)	;allow for future calling with multiple lists
  ;; lists are arranged in priority order
  ;; with higher priority towards the CDR
  (let ((merged-list (reduce #'append lists))
	(new-list nil))
    (dolist (menu-entry merged-list)
      (destructuring-bind (name . items) menu-entry
	(let ((existing-entry
		(first (member (first name) new-list :key #'caar :test #'string-equal))))
	  (cond (existing-entry
		 (cond ((getf (rest name) :override)
			(setq new-list
			      (substitute menu-entry existing-entry new-list)))
		       (t
			(let ((new-items (merge-menu-bar-items (rest existing-entry)
							       items)))
			  (when new-items
			    (let ((existing-name (first existing-entry)))
			      (when (getf (rest existing-name) :disabled)
				(setf (getf (rest existing-name) :disabled) nil))))
			  (setf (rest existing-entry) new-items))))
		 (setf (first existing-entry)
		       (merge-menu-bar-names (first existing-entry) name)))
		(t (push menu-entry new-list))))))
    (nreverse new-list)))

(defmethod (change-menu-bars mac-rpc-program)
	   (&optional activity-specific-menu)
  (let ((menu-items (merge-menu-bar-lists
		      (dw::remote-program-menu-items self)
		      activity-specific-menu)))
    (rpc-program-install-menus self menu-items)))

(defmethod (upgrade-macintosh-menu-bar-ordering dw::program) (menu-level-order)
  (dw::upgrade-program-menu-items-1 self menu-level-order ':mac))

(defmethod (macintosh-menu-bar-ordering dw::program :default) ()
  nil)

;;; Remove menu item from Mac menu
(defmethod (remove-remote-menu-item mac-rpc-program) (command-name remote-menu-level)
  (let ((*package* (si:pkg-find-package 'mtb)))
    (dw::remove-command-menu-item self command-name remote-menu-level)
    (rpc-program-install-menus self (dw::remote-program-menu-items self)))
  )

;;; Add menu item to Mac menu
(defmethod (add-remote-menu-item mac-rpc-program) (command-name remote-menu-level)
  (let ((*package* (si:pkg-find-package 'mtb)))
    (dw::add-command-menu-item self command-name remote-menu-level)
    (rpc-program-install-menus self (dw::remote-program-menu-items self)))
  )

(define-rpc-uims-from-mac-entry rpc-uims-menu-choice 4
				((menu-id integer-16)
				 (item-name pascal-string))
				()
  (let ((length (string-length item-name)))
    (when (and (> length 4)
	       (string-equal item-name " ..." :start1 (- length 4)))
      (setq item-name (substring item-name 0 (- length 4)))))
  (let ((menu-level (elt menu-id-levels (- menu-id *menu-id-offset*))))
    (dw::remote-program-call-menu-handler self menu-level item-name)))

(define-rpc-uims-to-mac-entry rpc-uims-open-dialog 4
  ((dialog-id dialog-id)
   (bounds rect)
   (title pascal-string)
   (proc-id integer-16)
   (go-away boolean)
   (items dialog-items))
  ())

(define-rpc-uims-to-mac-entry rpc-uims-set-dialog-values 5
  ((dialog-id dialog-id)
   (values dialog-values))
  ())

(define-rpc-uims-to-mac-entry rpc-uims-modal-dialog 6
  ((dialog-id dialog-id))
  ((terminal-condition integer-16)
   (values dialog-values)))

(define-rpc-uims-to-mac-entry rpc-uims-select-dialog-item-text 7
  ((dialog-id dialog-id)
   (item-number integer-16)
   (start integer-16)
   (end integer-16))
  ())

(defmethod (dw::remote-program-read-template-arguments mac-rpc-program)
	   (argument-templates title)
  (let ((dialog-id (new-unique-id))
	(dialog-list (dw::argument-templates-into-dialog-list argument-templates)))
    (multiple-value-bind (first-item-no bounds width-limit height-limit)
	(multiple-value-bind (width-limit height-limit)
	    (rpc-program-call self #'rpc::rpc-console-query-screen-size 0 nil)
	  (multiple-value-bind (items bounds first-item-no)
	      (lay-out-dialog dialog-list 0 0 width-limit height-limit
			      '("OK" "Cancel"))
	    (rpc-program-call self #'rpc-uims-open-dialog dialog-id bounds title
							  %window-type-dbox nil items)
	    (values first-item-no bounds width-limit height-limit)))
      (multiple-value-prog1
	(loop
	  (rpc-program-call self #'rpc-uims-set-dialog-values dialog-id
			    (dialog-list-into-dialog-values dialog-list first-item-no))
	  (multiple-value-bind (termination-condition dialog-values)
	      (rpc-program-call self #'rpc-uims-modal-dialog dialog-id)
	    (when (= termination-condition 2)	;Cancel
	      (return nil))
	    (dialog-list-update-from-dialog-values dialog-list dialog-values first-item-no)
	    (if (= termination-condition 1)	;OK
		(let* ((errors (dw::argument-templates-update-from-dialog-list
				 argument-templates dialog-list))
		       (error-index (position nil errors :test #'neq)))
		  (when (null error-index)
		    (return t))
		  (display-dialog-help self (princ-to-string (nth error-index errors))
				       bounds width-limit height-limit)
		  (rpc-program-call self #'rpc-uims-select-dialog-item-text dialog-id
				    (dialog-list-item-index-to-item-number dialog-list
									   error-index
									   first-item-no)
				    0 32767))
		(let* ((item (dialog-list-item-number-to-item dialog-list
							      (mod termination-condition 1000)
							      first-item-no))
		       (item-no (position item dialog-list))
		       (template (nth item-no argument-templates)))
		  (if (> termination-condition 2000)	;Complete
		      (multiple-value-bind (string beeped index)
			  (dw::argument-template-complete template (second item))
			(setf (second item) (string-thin string))
			(when beeped
			  (rpc-program-call self #'rpc::rpc-console-beep 10))
			(rpc-program-call self #'rpc-uims-select-dialog-item-text dialog-id
					  (dialog-list-item-index-to-item-number
					    dialog-list item-no first-item-no)
					  index index))
		      (display-dialog-help self (with-output-to-string (stream)
						  (dw::argument-template-help template
									      (second item)
									      stream))
					   bounds width-limit height-limit))))))
	(rpc-program-call self #'rpc-uims-close-window dialog-id)))))

(defconstant %dialog-item-control 4)
(defconstant %dialog-item-button 0)
(defconstant %dialog-item-check 1)
(defconstant %dialog-item-radio 2)
(defconstant %dialog-item-resource 3)
(defconstant %dialog-item-static-text 8)
(defconstant %dialog-item-edit-text 16)
(defconstant %dialog-item-icon 32)
(defconstant %dialog-item-picture 64)
(defconstant %dialog-item-disabled 128)

(defun lay-out-dialog (dialog-list left top right bottom buttons &aux (margin 5))
  (declare (values dialog-items bounds first-item-no))
  (let ((dialog-items (make-array 200 :element-type '(unsigned-byte 8) :fill-pointer 0))
	(nitems 0)
	(width margin)
	(height margin)
	(line-height 20))
    (setf (fill-pointer dialog-items)
	  (octet-structure-field-index (dialog-items-items dialog-items 0)))
    (let ((x-pos margin)
	  (y-pos margin)
	  (font (mac-font-for-character-style '(:geneva :roman :normal)
					      si:*standard-character-set*))
	  (current-line-height line-height))
      (labels ((string-width (string)
		 (let ((maxl 0))
		   (dw::do-delimited-substrings ((string) (ignore start end))
		       (maxf maxl (loop for char being the array-elements of string
					    from start below end
					sum (qd-font-char-width font
								(sys:char-subindex char))))
		     (#\return ))
		   maxl))
	       (item-width (type string)
		 (let ((string-width (string-width string)))
		   (+ string-width
		      (case type
			(:text 25)
			(:edit (max (- 200 string-width) 30))
			(otherwise 40)))))
	       (add-item (type string)
		 (incf nitems)
		 (let* ((item-index (fill-pointer dialog-items))
			(length (string-length string))
			(data (octet-structure-field-index
				(dialog-item-data dialog-items item-index))))
		   (let ((next (+ data (* 2 (ceiling length 2)))))
		     (when (> next (array-total-size dialog-items))
		       (setq dialog-items (sys:adjust-array-size dialog-items (+ next 100))))
		     (setf (fill-pointer dialog-items) next))
		   (setf (dialog-item-type dialog-items item-index)
			 (ecase type
			   (:text %dialog-item-static-text)
			   (:edit %dialog-item-edit-text)
			   (:button (+ %dialog-item-control %dialog-item-button))
			   (:check (+ %dialog-item-control %dialog-item-check))
			   (:radio (+ %dialog-item-control %dialog-item-radio))))
		   (when (eql type :edit)
		     (maxf current-line-height 30))
		   (when (eql type :button)
		     (maxf current-line-height 25))
		   (when (eql type :radio)
		     (decf y-pos 2))		;kludge for Mac's misalignment of :radio button
		   (let* ((rect (octet-structure-field-index
				  (dialog-item-display-rect dialog-items item-index)))
			  (rleft x-pos)
			  (rtop y-pos)
			  (rright (incf x-pos (item-width type string)))
			  (rbottom (+ y-pos (+ current-line-height
					       (* line-height (count #\return string
								     :test #'char-equal))))))
		     (set-rect dialog-items rect rleft rtop rright rbottom)
		     (maxf width rright) (maxf height rbottom))
		   (when (eql type :radio)
		     (incf y-pos 2))
		   (setf (dialog-item-length dialog-items item-index) length)
		   (copy-array-portion (string-to-ascii string) 0 length
				       dialog-items data (+ data length))
		   item-index))
	       (add-line-item (type string)
		 (add-item type string)
		 (next-line))
	       (next-line ()
		 (setq y-pos (+ y-pos current-line-height)
		       x-pos margin
		       current-line-height line-height)))
	(setq buttons (loop for string in buttons
			    collect (add-item :button string)))
	(setq x-pos margin y-pos margin current-line-height line-height)
	(dolist (item dialog-list)
	  (if (stringp item)
	      (if (string-search-char #\return item)
		  (dw::do-delimited-substrings ((item) (ignore start end))
					       (add-line-item :text (substring item start end))
		    (#\return ))
		  (add-line-item :text item))
	      (destructuring-bind (prompt value &optional enum) item
		(typecase value
		  (boolean
		    (add-line-item :check prompt))
		  (string
		    (let ((item-prompt (string-append prompt ":")))
		      (unless (> (+ x-pos (item-width :text item-prompt)
				    (item-width :edit value))
				 right)
			(incf y-pos 5))
		      (add-item :text item-prompt)
		      (when (> (+ x-pos (item-width :edit value)) right)
			(next-line)
			(incf y-pos 5))
		      (add-line-item :edit value)
		      (incf y-pos 5)))
		  (otherwise
		    (add-item :text (string-append prompt ":"))
		    (let* ((inter-col 10)
			   (maxl (+ (loop for choice in enum
				      maximize (item-width :radio choice))
				    inter-col)))
		      (when (> (+ x-pos maxl) right)
			(next-line))
		      (let* ((menu-x x-pos)
			     (ncols (max 1 (floor (- right menu-x) maxl)))
			     (single-row ( ncols (length enum))))
			(loop for i from 0
			      for choice in enum
			      do
			  (when (and (plusp i) (zerop (mod i ncols)))
			    (next-line)
			    (setq x-pos menu-x))
			  (unless single-row
			    (setq x-pos (+ menu-x (* (mod i ncols) maxl))))
			  (add-item :radio choice)
			  (incf x-pos inter-col)))
		      (next-line)))))))

	(incf width margin)

	(when buttons
	  (let ((width (floor width (length buttons))))
	    (loop for button in buttons
		  for middle from (floor width 2) by width
		  do
	      (let* ((rect (octet-structure-field-index
			     (dialog-item-display-rect dialog-items button)))
		     (bwidth (- (rect-right dialog-items rect) (rect-left dialog-items rect)))
		     (bleft (- middle (floor bwidth 2))))
		(set-rect dialog-items rect bleft y-pos
					    (+ bleft bwidth) (+ y-pos line-height)))))
	  (next-line)
	  (maxf height y-pos))

	(incf height margin)))

    (setf (dialog-items-total-length dialog-items 0) (fill-pointer dialog-items)
	  (dialog-items-nitems dialog-items 0) (1- nitems))

    (values dialog-items
	    (let ((rleft left)
		  (rright (+ left width))
		  (rtop top)
		  (rbottom (+ top height)))
	      (when (zerop left)
		(setq rleft (- (floor (+ left right) 2) (floor width 2))
		      rright (+ rleft width)))
	      (when (> rright right)
		(setq rleft (max left (- right width))
		      rright (+ rleft width)))
	      (when (zerop top)
		(setq rtop (- (floor (+ top bottom) 2) (floor height 2))
		      rbottom (+ rtop height)))
	      (when (> rbottom bottom)
		(setq rtop (max top (- bottom height))
		      rright (+ rtop height)))
	      (make-rect :left rleft :top rtop :right rright :bottom rbottom))
	    (1+ (length buttons)))))

#||
(defun show-dialog-layout (dialog-items bounds)
  (let ((dleft (rect-left bounds 0))
	(dtop (rect-top bounds 0))
	(dright (rect-right bounds 0))
	(dbottom (rect-bottom bounds 0)))
    (let ((item-index (octet-structure-field-index
			(dialog-items-items dialog-items 0))))
      (dw:with-own-coordinates ()
	(send *standard-output* :set-cursorpos dleft dtop)
	(surrounding-output-with-border (t :thickness 2
					   :width (- dright dleft)
					   :height (- dbottom dtop))
	  (dotimes (i (dialog-items-nitems dialog-items 0))
	    (let ((item-rect (octet-structure-field-index
			       (dialog-item-display-rect dialog-items item-index))))
	      (send *standard-output* :set-cursorpos (rect-left dialog-items item-rect)
						     (rect-top dialog-items item-rect))
	      (surrounding-output-with-border (t :width (- (rect-right dialog-items item-rect)
							   (rect-left dialog-items item-rect))
						 :height (- (rect-bottom dialog-items
									 item-rect)
							    (rect-top dialog-items item-rect)))
		(dw:with-output-as-presentation (:object (list (1+ i)
							       (dialog-item-type dialog-items
										 item-index))
						 :type 'sys:expression)
		  (write-string (ascii-to-string
				  (dialog-item-data dialog-items item-index))))))
	    (setf item-index (+ (octet-structure-field-index
				  (dialog-item-data dialog-items item-index))
				(* 2 (ceiling (dialog-item-length dialog-items item-index)
					      2))))))
	(send *standard-output* :set-cursorpos dright dbottom))
      (assert (= item-index (dialog-items-total-length dialog-items 0))))))
||#

;;;--- It would be nice for the choice items to be mouse sensitive.  That means using
;;;modeless dialogs, getting the values back asynchronously when OK is hit, and using
;;;viewer windows for the help messages.  Probably still want dialogs for the errors, though.
(defun display-dialog-help (rpc-program help next-to-bounds width-limit height-limit)
  (multiple-value-bind (items bounds)
      (lay-out-dialog (list help) 0 (rect-bottom next-to-bounds 0) width-limit height-limit
		      '("OK"))
  (let ((dialog-id (new-unique-id)))
    (rpc-program-call rpc-program #'rpc-uims-open-dialog dialog-id bounds ""
							 %window-type-plain-dbox nil items)
    ;; "Type a space to flush."
    (rpc-program-call rpc-program #'rpc-uims-modal-dialog dialog-id)
    (rpc-program-call rpc-program #'rpc-uims-close-window dialog-id))))

;;; Convert enumerations into a set of radio booleans, and data convert for transmission.
(defun dialog-list-into-dialog-values (dialog-list first-item-no)
  (let ((item-no first-item-no)
	(dialog-values (make-array 100 :element-type '(unsigned-byte 8)))
	(index (octet-structure-field-index (dialog-values-values dialog-values 0)))
	(nvalues 0))
    (dolist (item dialog-list)
      (if (stringp item)
	  (incf item-no)			;Fixed string
	(destructuring-bind (prompt value &optional enumeration) item
	  (ignore prompt)
	  (flet ((add-item (type value)
		   (let ((nindex (+ (octet-structure-field-index
				      (dialog-value-on-p dialog-values index))
				    (ecase type
				      (boolean 2)
				      (string (1+ (logior (string-length value) 1)))))))
		     (when (> nindex (array-total-size dialog-values))
		       (setq dialog-values (sys:adjust-array-size dialog-values
								  (+ nindex 20))))
		     (setf (dialog-value-item-number dialog-values index) item-no
			   (dialog-value-type dialog-values index) type)
		     (ecase type
		       (boolean (setf (dialog-value-on-p dialog-values index) value))
		       (string (stack-let* ((length (string-length value))
					    (start (octet-structure-field-index
						     (dialog-value-string dialog-values
									  index)))
					    (as-bytes (make-array length
							:element-type '(unsigned-byte 8)
							:displaced-to value)))
				 (setf (aref dialog-values start) length)
				 (incf start)
				 (copy-array-portion as-bytes 0 length
						     dialog-values start (+ start length)))))
		     (setq index nindex)
		     (incf item-no)
		     (incf nvalues))))
	    (cond (enumeration
		   (incf item-no)			;The name
		   (loop for i from 1 to (length enumeration) do
		     (add-item 'boolean (= i value))))
		  ((stringp value)
		   (incf item-no)
		   (add-item 'string value))
		  (t
		   (add-item 'boolean value)))))))
    (setf (dialog-values-nvalues dialog-values 0) nvalues
	  (dialog-values-total-length dialog-values 0) index)
    (setq dialog-values (sys:adjust-array-size dialog-values index))
    dialog-values))

;;; Inverse of above.
(defun dialog-list-update-from-dialog-values (dialog-list dialog-values first-item-no)
  (let ((value-index (octet-structure-field-index (dialog-values-values dialog-values 0))))
    (stack-let ((as-string (make-array (dialog-values-total-length dialog-values 0)
				       :element-type 'string-char
				       :displaced-to dialog-values)))
      (dotimes (ignore (dialog-values-nvalues dialog-values 0))
	(let ((item-no (dialog-value-item-number dialog-values value-index)))
	  (multiple-value-bind (item base-item-no)
	      (dialog-list-item-number-to-item dialog-list item-no first-item-no)
	    (ecase (dialog-value-type dialog-values value-index)
	      (string
		(assert (= (1+ base-item-no) item-no))
		(let* ((start (octet-structure-field-index
				(dialog-value-string dialog-values value-index)))
		       (length (aref dialog-values start)))
		  (setf (second item) (substring as-string (1+ start) (+ start length 1)))
		  (setq value-index (+ start (1+ (logior length 1))))))
	      (boolean
		(if (= base-item-no item-no)
		    (setf (second item) (dialog-value-on-p dialog-values value-index))
		    (when (dialog-value-on-p dialog-values value-index)
		      (setf (second item) (- item-no base-item-no))))
		(setq value-index (+ (octet-structure-field-index
				       (dialog-value-on-p dialog-values value-index))
				     2)))))))))
  dialog-list)

(defun dialog-list-item-number-to-item (dialog-list item-no first-item-no)
  (declare (values item base-item-no))
  (loop for item in dialog-list
	for j = first-item-no then next-j
	as next-j = (if (stringp item)
			(1+ j)
			(destructuring-bind (prompt value &optional enumeration)
			    item
			  (ignore prompt)
			  (cond (enumeration (+ j (length enumeration) 1))
				((stringp value) (+ j 2))
				(t (1+ j)))))
	when (> next-j item-no)
	  return (values item j)))

(defun dialog-list-item-index-to-item-number (dialog-list item-index first-item-no)
  (let ((item-no first-item-no))
    (loop for item in dialog-list
	  for j from 0
	  do (multiple-value-bind (before after)
		 (if (stringp item)
		     (values 0 1)
		     (destructuring-bind (prompt value &optional enumeration) item
		       (ignore prompt)
		       (cond (enumeration (values 1 (length enumeration)))
			     ((stringp value) (values 1 1))
			     (t (values 1 0)))))
	       (incf item-no before)
	       (when (= j item-index)
		 (return item-no))
	       (incf item-no after)))))

(defflavor mac-rpc-window
	(program
	 (id (new-unique-id))
	 (state nil)
	 (title nil)
	 (pictures nil)
	 (original-bounds nil)
	 outside-bounds
	 viewport-bounds
	 (output-process nil)
	 (presentation-release-timeout 0))
	(mtb::event-uims-window)
  (:required-flavors to-quickdraw-output-stream)
  (:initable-instance-variables program title presentation-release-timeout id)
  (:init-keywords :left :top :right :bottom :width :height :progress-note)
  (:readable-instance-variables program id))

(defun find-window-from-application-and-window-ids (application-id window-id)
  (let ((program (find-program-from-application-id application-id)))
    (when program
      (find window-id (mac-rpc-program-windows program) :key #'mac-rpc-window-id))))

(defmethod (make-instance mac-rpc-window) (&key left top right bottom width height
					   &allow-other-keys)
  (when (and left right (null width))
    (setq width (- right left)))
  (when (and top bottom (null height))
    (setq height (- bottom top)))
  (when (or left top width height)
    (setq original-bounds (list left top width height)))
  (unless (and width height)
    (multiple-value-bind (swidth sheight)
	(rpc-program-call program #'rpc::rpc-console-query-screen-size 0 nil)
      (unless width (setq width swidth))
      (unless height (setq height sheight))))
  (unless left (setq left 0))
  (unless top (setq top 0))
  (setq outside-bounds (dw:make-temporary-box left top (+ left width) (+ top height)))
  (when title					;Account for scroll bars.
    (decf width 15)
    (decf height 15))
  (setq viewport-bounds (dw:make-temporary-box 0 0 width height)))

(defmethod (mac-rpc-window-mac-window mac-rpc-window)
	   ()
  (rpc-program-call program #'id-mywindow-window id -1))

(defmethod (rpc-window-for-mac-window mac-rpc-program) (mac-window)
  (let ((window-id (window-mywindow-id application-id mac-window)))
    (let ((rpc-window (find window-id windows :key #'mac-rpc-window-id)))
      rpc-window)))

(defgeneric mac-rpc-window-scroll-bars
	    (mac-rpc-window)
  (declare (values scroll-bar-handle-h scroll-bar-handle-v))
  (:method (mac-rpc-window)
   (condition-case (ignore)
	(rpc-program-call program #'id-mywindow-scroll-bars id)
      (mac-os-error ()))))

(defmethod (:inside-size mac-rpc-window) () (dw:box-size viewport-bounds))

(defmethod (:inside-width mac-rpc-window) () (dw::box-width viewport-bounds))

(defmethod (:inside-height mac-rpc-window) () (dw::box-height viewport-bounds))

(defun-in-flavor (set-random-position mac-rpc-window) ()
  (destructuring-bind (&optional left top &rest ignore) original-bounds
    (unless (and left top)
      (let ((random (logand id 3)))
	(unless left (setq left (- 100 (* random 10))))
	(unless top (setq top (+ 40 (* random 4)))))
      (multiple-value-bind (width height)	;adjust position if ncessary so left and top
	  (dw::box-size outside-bounds)		;are always on screen and right and bottom are
	(multiple-value-bind (swidth sheight)	;too, whenever possible.
	    (rpc-program-call program #'rpc::rpc-console-query-screen-size 0 nil)
	  (setq left (max 0 (min left (- swidth width))))
	  (setq top (max 0 (min top (- sheight height))))))
      (dw::set-box-position outside-bounds left top))))

(defflavor mac-rpc-picture-window
	((buffer-screens nil)
	 (buffer-ahead-screens nil)
	 (progress-note nil))
	(mac-rpc-window quickdraw-picture-stream)
  :initable-instance-variables
  )

(defflavor mac-rpc-drawing-window
	()
	(mac-rpc-window to-quickdraw-output-stream)
  )

(defmethod (dw::remote-program-open-viewer mac-rpc-program) (&rest args
							     &key (picture-p t)
							     &allow-other-keys)
  (si:with-rem-keywords (some-args args '(:picture-p))
    (apply #'make-instance (if picture-p 'mac-rpc-picture-window 'mac-rpc-drawing-window)
	   :program self some-args)))

(defmethod (dw::remote-noting-progress-internal mac-rpc-program) (ignore
								   continuation &rest args)
  (unwind-protect
      (progn
	(rpc-program-call-1 self #'rpc-toolkit-set-standard-cursor 4)
	(apply continuation args))
    (rpc-program-call-1 self #'rpc-toolkit-set-standard-cursor 0)))

(defmacro define-mac-rpc-window-output-entry (name opcode arglist values)
  `(define-rpc-uims-to-mac-entry ,name ,opcode
				 ((window-id window-id) . ,arglist)
				 ,values))

(rpc::define-standard-rpc-input-definer define-mac-rpc-window-input-entry 
					rpc-uims-from-mac mac-rpc-window
					find-window-from-application-and-window-ids
					((application-id application-id)
					 (window-id window-id)))

(define-mac-rpc-window-output-entry rpc-uims-add-window 8
  ((bounds rect)
   (title pascal-string)
   (proc-id integer-16)
   (go-away boolean)
   (color boolean))
  ())

(define-mac-rpc-window-output-entry rpc-uims-close-window 9 () ())

(define-remote-entry rpc-uims-add-picture rpc-uims-to-mac
  (:number 10)
  (:arguments (application-id application-id) (window-id window-id)
	      (picture-id picture-id)
	      (picture quickdraw-picture)
	      (presentations presentation-set))
  (:asynchronous t)
  (:c (:server
	#{ extern OSErr RPC_uims_add_long_picture();
           system_error_code = RPC_uims_add_long_picture(application_id,
                                                    window_id,
                                                    picture_id,
                                                    picture,
						    picture->picSize,
						    presentations);
	}
	)))

;;; Preferred entry; above only works when picSize valid.
(define-mac-rpc-window-output-entry rpc-uims-add-long-picture 47
  ((picture-id picture-id)
   (picture quickdraw-picture)
   (picture-length integer-32)
   (presentations presentation-set))
  ())

(define-mac-rpc-window-output-entry rpc-uims-delete-picture 45
  ((picture-id picture-id))
  ())

(define-mac-rpc-window-output-entry rpc-uims-show-window 11 () ())

(defmethod (mac-rpc-window-add-window mac-rpc-window) ()
  (push self (mac-rpc-program-windows program))
  (stack-let ((bounds (make-rect))
	      (proc-id (+ %window-type-document %window-type-zoom))
	      (go-away t))
    (multiple-value-call #'set-rect bounds 0 (dw:box-edges outside-bounds))
    (when (null title)
      (setq proc-id %window-type-plain-dbox
	    go-away nil
	    title ""))
    (rpc-program-call program #'rpc-uims-add-window id bounds title proc-id go-away color-p)))

;;; Bad name is for compatibility.
(defmethod (:expose mac-rpc-window) ()
  (unless state
    (set-random-position)
    (mac-rpc-window-add-window self)
    (setq state :active))
  (rpc-program-call program #'rpc-uims-show-window id))

(defmethod (:kill mac-rpc-window) ()
  (when (eq state :active)
    (rpc-program-call program #'rpc-uims-close-window id))
  (setq state :killed))

(defmethod (mac-rpc-window-add-picture mac-rpc-window) (picture)
  (let ((picture-id (new-unique-id)))
    (push (list picture-id picture) pictures)
    (loop for presentation being the array-elements
	      of (qd-picture-unique-id-presentation-table picture)
	  do
      (when presentation
	(setf (qd-presentation-chords presentation)
	      (presentation-mouse-chords program presentation))))
    (let ((presentations nil))
      (labels ((add-presentation (presentation)
		 (when (not (zerop (qd-presentation-chords presentation)))
		   (push presentation presentations))
		 (map () #'add-presentation (dw:presentation-inferiors presentation))))
	(map () #'add-presentation (qd-picture-presentations picture)))
      (stack-let ((presentation-set (make-presentation-set
				      :npresentations (length presentations)
				      :release-timeout presentation-release-timeout)))
	(loop for remote-presentation being the octet-structure-field-elements
		  of (presentation-set-presentations presentation-set 0)
	      for presentation in presentations
	      do (setf (presentation-id presentation-set remote-presentation)
		       (qd-presentation-unique-id presentation)
		       (presentation-chords presentation-set remote-presentation)
		       (qd-presentation-chords presentation))
		 (multiple-value-bind (left top right bottom)
		     (dw:box-edges (qd-presentation-bounding-box presentation))
		   (set-rect presentation-set (octet-structure-field-index
						(presentation-rect presentation-set
								   remote-presentation))
			     left top right bottom)))
	(setf (presentation-set-total-length presentation-set 0) (length presentation-set))
	(rpc-program-call program #'rpc-uims-add-long-picture id picture-id
						              picture (length picture)
							      presentation-set)))))

(defun-in-flavor (set-size-from-picture mac-rpc-picture-window) (picture)
  (let ((x-margin (- (dw::box-width outside-bounds) (dw::box-width viewport-bounds)))
	(y-margin (- (dw::box-height outside-bounds) (dw::box-height viewport-bounds))))
    (multiple-value-bind (width height)
	(dw::box-bottom-right (qd-picture-bounding-box picture))
      (incf height 20)
      (incf width 40)				;put in some right and bottom whitespace
      (multiple-value-bind (swidth sheight)	;but limit to size of screen
	  (rpc-program-call program #'rpc::rpc-console-query-screen-size 0 nil)
	(setq width (min width (- swidth x-margin)))
	(setq height (min height (- sheight y-margin 20))))	;compensate for #$%^ title!
      (when (third original-bounds)
	(setq width (dw::box-width viewport-bounds)))
      (when (fourth original-bounds)
	(setq height (dw::box-height viewport-bounds)))
      (dw::set-box-size viewport-bounds width height)
      (dw::set-box-size outside-bounds (+ width x-margin) (+ height y-margin)))))

(defun-in-flavor (close-picture-internal mac-rpc-picture-window) (keep-height)
  (qd-picture-stream-close-picture self)
  (unless state
    (when keep-height
      (setf (fourth original-bounds) t))	;Keep maximum height
    (set-size-from-picture picture)
    (set-random-position)
    (mac-rpc-window-add-window self)
    (setq state :active))
  (mac-rpc-window-add-picture self picture)
  (rpc-program-call program #'rpc-uims-show-window id))

(defmethod (:close mac-rpc-picture-window) (&optional abort-p)
  (unless abort-p
    (close-picture-internal nil)))

(defmethod (move-to mac-rpc-picture-window :before) (ignore y)
  (when (and buffer-screens
	     bounding-box (null current-presentation)
	     (> (- y (send self :baseline))
		(+ (dw:box-top bounding-box) (dw::box-height viewport-bounds))))
    ;; Time for the next screenful picture.  Close the current picture and send it.
    (close-picture-internal t)
    (when buffer-ahead-screens
      (flet ((go-ahead ()
	       (or (neq state :active)
		   (< (- (dw:box-bottom bounding-box) (dw:box-bottom viewport-bounds))
		      (* (dw::box-height viewport-bounds) buffer-ahead-screens)))))
	(unless (go-ahead)
	  (setq output-process *current-process*)
	  (when progress-note
	    (rpc-program-call-1 program #'rpc-toolkit-set-standard-cursor 0))
	  (process:process-block "Scroll wait" #'go-ahead)
	  (when progress-note
	    (rpc-program-call-1 program #'rpc-toolkit-set-standard-cursor 4)))))
    (unless (eq state :active)
      (signal 'sys:abort))
    (quickdraw-drawing-state-initialize graphics::drawing-state)
    (qd-picture-stream-open-picture self)))

;;; Index is MAC bit number, output mouse bit number.
;;; cloverleaf=control, shift=shift, caps-lock=hyper(?), option=meta, control=super.
(defparameter *mouse-bit-bits* '#(0 4 3 1 2))

(defun mac-chord-to-mouse-char (chord)
  (let ((bits 0))
    (dotimes (bit 5)
      (when (ldb-test (byte 1 bit) chord)
	(setf (ldb (byte 1 (aref *mouse-bit-bits* bit)) bits) 1)))
    (si:make-mouse-char 0 bits)))

(defvar *mac-mouse-chars* (loop for i below 32
				collect (mac-chord-to-mouse-char i)))

(defun mouse-char-to-mac-chord (mouse-char)
  (let ((bits (si:mouse-char-bits mouse-char))
	(chord 0))
    (dotimes (bit 5)
      (when (ldb-test (byte 1 (aref *mouse-bit-bits* bit)) bits)
	(setf (ldb-test (byte 1 bit) chord) 1)))
    chord))

(defun presentation-mouse-chords (program presentation)
  (let ((mask 0)
	(dw:*program* program)
	(cp:*command-table* (dw:program-command-table program)))
    (stack-let ((type `((cp:command :command-table ,cp:*command-table*))))
      (dw:with-presentation-input-context (type :inherit nil) (blip)
	   (dw::map-over-presentation-mouse-handlers
	     presentation #'ignore *mac-mouse-chars*
	     (lambda (ignore context gesture mouse-char)
	       (when (and gesture context mouse-char)
		 (setf (ldb (byte 1 (mouse-char-to-mac-chord mouse-char)) mask) 1))))))
    mask))

(defun presentation-mouse-command (program window presentation chord &rest arguments)
  (let ((dw:*program* program)
	(cp:*command-table* (dw:program-command-table program)))
    (stack-let ((type `((cp:command :command-table ,cp:*command-table*))))
      (dw:with-presentation-input-context (type :inherit nil) (blip)
	   (block value
	     (dw::map-over-presentation-mouse-handlers
	       presentation #'ignore (list (mac-chord-to-mouse-char chord))
	       (lambda (handler context gesture ignore)
		 (when (and gesture context)
		   (apply #'dw::call-presentation-mouse-handler-handler
		     :handler handler :input-context context
		     :window window :presentation presentation
		     :gesture gesture
		     arguments))))
	     nil)
	 (t (dw:presentation-blip-object blip))))))

(define-mac-rpc-window-input-entry rpc-uims-presentation-click 7
				   ((picture-id picture-id)
				    (presentation-id presentation-id)
				    (chord integer-16))
				   ()
  (let ((presentation (mac-rpc-window-presentation-from-id self picture-id presentation-id)))
    (when presentation
      (rpc-program-call-presentation-handler program self presentation chord))))

(defmethod (mac-rpc-window-presentation-from-id mac-rpc-window) (picture-id presentation-id)
  (let ((picture (second (assoc picture-id pictures))))
    (when picture
      (aref (qd-picture-unique-id-presentation-table picture) presentation-id))))

(defun rpc-program-call-presentation-handler (program window presentation chord &rest arguments)
  (let ((command (apply #'presentation-mouse-command program window presentation chord arguments)))
    (when command
      (let ((dw:*program* program))
	(apply (first command) (rest command))))))

(define-mac-rpc-window-input-entry rpc-uims-window-character 8
				   ((the-char character-8)
				    (modifiers integer-16))
				   ()
  (ignore the-char modifiers)
  )

(define-mac-rpc-window-input-entry rpc-uims-multiple-window-characters 12
				   ((window-chars window-characters))
  (ignore window-chars)
  )

(defsubst-in-flavor (maybe-wakeup-output mac-rpc-window) ()
  (let ((process output-process))
    (when process
      (process:process-wakeup process))))

(define-mac-rpc-window-input-entry rpc-uims-note-window-resize-or-scroll 9
				   ((outside rect)
				    (inside rect))
  (let ((x-margin 15); (- (dw::box-width outside-bounds) (dw::box-width viewport-bounds)))
	(y-margin 15));(- (dw::box-height outside-bounds) (dw::box-height viewport-bounds))))
    (dw::set-box-edges outside-bounds (rect-left outside 0) (rect-top outside 0)
				      (rect-right outside 0) (rect-bottom outside 0))
    (dw::set-box-edges viewport-bounds (rect-left inside 0) (rect-top inside 0)
				       (- (rect-right inside 0) x-margin)
				       (- (rect-bottom inside 0) y-margin)))
  (maybe-wakeup-output))

(define-mac-rpc-window-input-entry rpc-uims-note-window-close 10 ()
  (setf (mac-rpc-program-windows program) (delete self (mac-rpc-program-windows program)))
  (setq state :dead)
  (maybe-wakeup-output))

(define-mac-rpc-window-input-entry rpc-uims-note-window-clobbered 11 ()
  (maybe-wakeup-output))

(defmethod (:finish mac-rpc-window) ()
  (rpc-program-call program #'rpc::rpc-console-synch (sys:time)))

(defmethod (get-font-number mac-rpc-window) (family-name)
  ;; Could perhaps use a cache for these.
  (rpc-program-call-1 program #'rpc-toolkit-get-font-number family-name))

(compile-flavor-methods mac-rpc-picture-window)

(defmacro define-rpc-drawing-window-operation (generic arglist values
					       (number
						 &key (name
							(sys:fintern "RPC-WINDOW-~A" generic))
						      (lisp-arglist
							(map 'list #'first arglist)))
					       c-body &body lisp-body)
  (setq c-body (eval c-body))
  (when (= (length c-body) 1)
    (setq c-body #{ c-body ( (loop for (var) in arglist
				     for first-p = t then nil
				     unless first-p
				       append #{,}
				     collect (lisp-name-to-c-name var))
			     );
		  }))
  (setq c-body #{ Graphics_Compatibility gmode;
		  long forePixel;
		  if ( system_error_code = DrawSetPort(application_id, window_id, 
						       &gmode, &forePixel) )
	            goto _end_;
		  { c-body }
		  if (SetupBackupScreen(current_myWindow)) {
		    { c-body }
		    RestoreBackupScreen();
		  }
		  DrawRestorePort();
		})
  (when (null lisp-body)
    (setq lisp-body `((rpc-program-call program #',name id . ,(map 'list #'first arglist)))))
  `(progn
     (define-remote-entry ,name rpc-uims-to-mac
       (:number ,number)
       (:arguments (application-id application-id) (window-id window-id)
		   . ,arglist)
       ,(if values
	    `(:values . ,values)
	    `(:asynchronous t))
       (:c (:server ',c-body)))
     (defmethod (,generic mac-rpc-drawing-window) ,lisp-arglist . ,lisp-body)))

(define-rpc-drawing-window-operation set-origin ((x integer-16) (y integer-16)) () (20)
				     #{SetOrigin})

(define-rpc-drawing-window-operation set-clip ((region region)) () (21)
				     #{ RgnHandle handle;
				        OSErr err;

				        err = PtrToHand((Ptr)region, &handle, region->rgnSize);
					if (err) return(err);
					SetClip(handle);
					DisposHandle(handle);
				      })

(define-rpc-drawing-window-operation get-pen-state () ((state pen-state)) (22)
				     #{ PenState state;

				        GetPenState(&state);
					RPCValues(&state);
				      })

(define-rpc-drawing-window-operation set-pen-state ((state pen-state)) () (36) #{SetPenState})

(define-rpc-drawing-window-operation pen-size ((w integer-16) (h integer-16))
				     () (23) #{PenSize})

(define-rpc-drawing-window-operation pen-mode ((mode integer-16)) () (24) #{PenMode})

(define-rpc-drawing-window-operation pen-pattern ((pattern pattern)) () (25) #{PenPat})

(define-rpc-drawing-window-operation move-to ((x integer-16) (y integer-16)) () (26) #{MoveTo})

(define-rpc-drawing-window-operation line-to ((x integer-16) (y integer-16)) () (27) #{LineTo})

(define-rpc-drawing-window-operation text-font ((font integer-16)) () (28) #{TextFont})

(define-rpc-drawing-window-operation text-face ((face integer-16)) () (29) #{TextFace})

(define-rpc-drawing-window-operation text-mode ((mode integer-16)) () (30) #{TextMode})

(define-rpc-drawing-window-operation text-size ((size integer-16)) () (31) #{TextSize})

;--- should be fixed-point
(define-rpc-drawing-window-operation space-extra ((extra integer-16)) () (32) #{SpaceExtra})

(define-rpc-drawing-window-operation draw-string ((string pascal-string)) ()
				     (33 :lisp-arglist (string &optional (start 0) end))
				     #{DrawString}
  (if (and (zerop start) (null end))
      (rpc-program-call program #'rpc-window-draw-string id string)
      (stack-let ((pstring (make-array (- end start) :element-type '(unsigned-byte 8))))
	(replace pstring string :start2 start :end2 end)
	(rpc-program-call program #'rpc-window-draw-string id pstring))))

(define-rpc-drawing-window-operation string-width ((string pascal-string)) ()
				     (34 :lisp-arglist (string &optional (start 0) end))
				     #{StringWidth}
  (if (and (zerop start) (null end))
      (rpc-program-call program #'rpc-window-string-width id string)
      (stack-let ((pstring (make-array (- end start) :element-type '(unsigned-byte 8))))
	(replace pstring string :start2 start :end2 end)
	(rpc-program-call program #'rpc-window-string-width id pstring))))

(define-rpc-drawing-window-operation get-font-info () ((ascent integer-16)
						       (descent integer-16)
						       (width-max integer-16)
						       (leading integer-16))
				     (35)
				     #{ FontInfo info;

				        GetFontInfo(&info);
					RPCValues(info.ascent, info.descent,
						  info.widMax,info.leading);
				      })

(define-rpc-drawing-window-operation draw-line-from-to ((start-x integer-16)
							(start-y integer-16)
							(end-x integer-16)
							(end-y integer-16))
				     () (40)
				     #{ MoveTo(start_x, start_y);
				        LineTo(end_x, end_y);
				      })

(defun rect-points-call (operation program-id window-id left top right bottom &rest args)
  (stack-let ((rect (make-rect)))
    (when (< right left) (rotatef left right))
    (when (< bottom top) (rotatef top bottom))
    (set-rect rect 0 left top right bottom)
    (apply operation program-id window-id rect args)))

(defmacro define-rpc-drawing-window-rect-operation (name other-args number trap)
  (let* ((entry-name (sys:fintern "RPC-WINDOW-~A" name))
	 (points-name (sys:fintern "~A-POINTS" entry-name)))
    `(progn
       (defun ,points-name (&rest args)
	 (apply #'rect-points-call #',entry-name args))
       (define-rpc-drawing-window-operation ,name ((rect rect) . ,other-args) ()
					    (,number
					     :name ,entry-name
					     :lisp-arglist (left top right bottom
							    . ,(map 'list #'first other-args)))
					    ,trap
	 (rpc-program-call program #',points-name id
			   left top right bottom . ,(map 'list #'first other-args))))))

(define-rpc-drawing-window-rect-operation frame-rect () 50 #{FrameRect})

(define-rpc-drawing-window-rect-operation paint-rect () 51 #{PaintRect})

(define-rpc-drawing-window-rect-operation erase-rect () 52 #{EraseRect})

(define-rpc-drawing-window-rect-operation invert-rect () 53 #{InvertRect})

(define-rpc-drawing-window-rect-operation fill-rect ((pattern pattern)) 54 #{FillRect})

(define-rpc-drawing-window-rect-operation frame-oval () 55 #{FrameOval})

(define-rpc-drawing-window-rect-operation paint-oval () 56 #{PaintOval})

(define-rpc-drawing-window-rect-operation erase-oval () 57 #{EraseOval})

(define-rpc-drawing-window-rect-operation invert-oval () 58 #{InvertOval})

(define-rpc-drawing-window-rect-operation fill-oval ((pattern pattern)) 59 #{FillOval})

(define-rpc-drawing-window-rect-operation frame-round-rect ((oval-width integer-16)
							    (oval-height integer-16))
					  60 #{FrameRoundRect})

(define-rpc-drawing-window-rect-operation paint-round-rect ((oval-width integer-16)
							    (oval-height integer-16))
					  61 #{PaintRoundRect})

(define-rpc-drawing-window-rect-operation erase-round-rect ((oval-width integer-16)
							    (oval-height integer-16))
					  62 #{EraseRoundRect})

(define-rpc-drawing-window-rect-operation invert-round-rect ((oval-width integer-16)
							    (oval-height integer-16))
					  63 #{InvertRoundRect})

(define-rpc-drawing-window-rect-operation fill-round-rect ((oval-width integer-16)
							   (oval-height integer-16)
							   (pattern pattern))
					  64 #{FillRoundRect})

(define-rpc-drawing-window-rect-operation frame-arc ((start-angle integer-16)
						     (end-angle integer-16))
					  65 #{FrameArc})

(define-rpc-drawing-window-rect-operation paint-arc ((start-angle integer-16)
						     (end-angle integer-16))
					  66 #{PaintArc})

(define-rpc-drawing-window-rect-operation erase-arc ((start-angle integer-16)
						     (end-angle integer-16))
					  67 #{EraseArc})

(define-rpc-drawing-window-rect-operation invert-arc ((start-angle integer-16)
						     (end-angle integer-16))
					  68 #{InvertArc})

(define-rpc-drawing-window-rect-operation fill-arc ((start-angle integer-16)
						    (end-angle integer-16)
						    (pattern pattern))
					  69 #{FillArc})

(defun poly-points-call (operation program-id window-id points &rest args)
  (stack-let ((poly (make-polygon :length (+ (* (length points) 2)
					     (octet-structure-field-index
					       (polygon-points poly 0))))))
    (let ((index (octet-structure-field-index (polygon-points poly 0)))
	  (min-x nil) (max-x nil) (min-y nil) (max-y nil))
      (graphics:map-points #'(lambda (x y &optional ignore)
			       (minf-or min-x x) (maxf-or max-x x)
			       (minf-or min-y y) (maxf-or max-y y)
			       (setf (byte-swapped-8-aref-16 poly index) y)
			       (setf (byte-swapped-8-aref-16 poly (+ index 2)) x)
			       (incf index 4))
			   points)
      (set-rect poly (octet-structure-field-index (polygon-bounds poly 0))
		min-x min-y max-x max-y))
    (apply operation program-id window-id poly args)))

(defmacro define-rpc-drawing-window-poly-operation (name other-args number trap)
  (let* ((entry-name (sys:fintern "RPC-WINDOW-~A" name))
	 (points-name (sys:fintern "~A-POINTS" entry-name)))
    `(progn
       (defun ,points-name (&rest args)
	 (apply #'poly-points-call #',entry-name args))
       (define-rpc-drawing-window-operation ,name ((poly polygon) . ,other-args) ()
					    (,number
					     :name ,entry-name
					     :lisp-arglist (points
							     . ,(map 'list #'first other-args))
					     )
					    ',#{ PolyHandle polyh;
  
					         PtrToHand((Ptr)poly, &polyh, poly->polySize);
						 (eval trap)
						 (polyh (loop for (var) in other-args
							       append #{,}
							       collect (lisp-name-to-c-name
									 var))
							);
						 DisposHandle(polyh);
						 }
	 (rpc-program-call program #',points-name id points
			   . ,(map 'list #'first other-args))))))

(define-rpc-drawing-window-poly-operation frame-poly () 70 #{FramePoly})

(define-rpc-drawing-window-poly-operation paint-poly () 71 #{PaintPoly})

(define-rpc-drawing-window-poly-operation erase-poly () 72 #{ErasePoly})

(define-rpc-drawing-window-poly-operation invert-poly () 73 #{InvertPoly})

(define-rpc-drawing-window-poly-operation fill-poly ((pattern pattern)) 74 #{FillPoly})

(defmacro define-rpc-drawing-window-region-operation (name other-args number trap)
  `(define-rpc-drawing-window-operation ,name ((region region) . ,other-args) () (,number)
					',#{ RgnHandle handle;
				             OSErr err;

					     err = PtrToHand((Ptr)region, &handle,
							     region->rgnSize);
					     if (err) return(err);
					     (eval trap)
					     (handle (loop for (var) in other-args
							    append #{,}
							    collect (lisp-name-to-c-name
								      var))
						     );
					     DisposHandle(handle);
					     }))

(define-rpc-drawing-window-region-operation frame-region () 75 #{FrameRgn})

(define-rpc-drawing-window-region-operation paint-region () 76 #{PaintRgn})

(define-rpc-drawing-window-region-operation erase-region () 77 #{EraseRgn})

(define-rpc-drawing-window-region-operation invert-region () 78 #{InvertRgn})

(define-rpc-drawing-window-region-operation fill-region ((pattern pattern)) 79 #{FillRgn})

(defmethod (graphics:draw-image mac-rpc-drawing-window)
	   (image left top
		  &key (image-left 0) (image-top 0)
		       (image-right nil) (image-bottom nil)
		       (copy-image nil))
  (ignore copy-image)
  (multiple-value-bind (width height)
      (decode-raster-array image)
    (unless image-right
      (setq image-right width))
    (unless image-bottom
      (setq image-bottom height)))
  (qd-state-update-pen-state-and-color graphics::drawing-state self color-p)
  (rpc-program-call program #'rpc::rpc-screen-put-image id
		    (convert-mode-to-alu
		      (pen-state-pen-mode (qd-state-pen-state graphics::drawing-state)))
		    (- image-right image-left) (- image-bottom image-top)
		    image image-left image-top
		    left top))

(defmethod (text-ratio mac-rpc-drawing-window) (&rest ignore)
  (niy self 'text-ratio))

(define-rpc-drawing-window-operation background-pattern ((pattern pattern)) () (37) #{BackPat})

(define-rpc-drawing-window-operation rgb-foreground-color ((color rgb-color)) () (38)
				     #{RGBForeColor})

(define-rpc-drawing-window-operation rgb-background-color ((color rgb-color)) () (39)
				     #{RGBBackColor})

(define-rpc-drawing-window-rect-operation clip-rect () 41 #{ClipRect})

(define-rpc-drawing-window-operation text-mode-from-pen-mode () () (48)
				     #{PenState state;

				       GetPenState(&state);
				       TextMode(state.pnMode);
				      })

(compile-flavor-methods mac-rpc-drawing-window)

;;;; Special remote mouse tracking

(define-mac-rpc-window-output-entry rpc-uims-clear-mouse-handler 42 () ())

(define-remote-entry rpc-uims-set-standard-mouse-handler rpc-uims-to-mac
  (:number 43)
  (:arguments (application-id application-id)
	      (window-id window-id)
	      (bounds rect)
	      (drawing-state pen-state)
	      (drawing-function integer-16)
	      (points (vector integer-16))
	      (relative-ps cardinal-32)
	      (args (vector cardinal-8)))
  (:asynchronous t)
  (:c
    (:server
      #{ system_error_code = RPC_uims_set_standard_mouse_handler (application_id,
								  window_id,
								  bounds,
								  drawing_state,
								  drawing_function,
								  (IncomingMouseHandlerPoints*)points,
								  relative_ps,
								  (IncomingMouseHandlerArgs*)args);
         if (system_error_code) return (system_error_code);
       } )))

(defun tv:window-clear-remote-mouse-handler (sheet)
  (%screen-clear-remote-mouse-handler (tv:sheet-screen sheet) sheet))

(defmethod (tv:window-set-remote-mouse-handler tv:sheet) (&rest args)
  (declare (arglist function points relative-ps additional-args drawing-args))
  (apply #'%screen-set-remote-mouse-handler tv:screen self args))

(defwhopper (tv:window-set-remote-mouse-handler dw:dynamic-window)
	    (function points relative-ps &rest args)
  (let ((dx 0) (dy 0))
    (dw::coordinate-convert-points self :relative :inside dx dy)
    (dotimes (i (length points))
      (unless (aref relative-ps i)
	(incf (elt points i) (if (evenp i) dx dy))))
    (lexpr-continue-whopper function points relative-ps args)))

(defmethod (%screen-set-remote-mouse-handler tv:basic-screen) (&rest ignore) nil)

(defmethod (%screen-set-remote-mouse-handler rpc::rpc-screen)
	   (sheet function points relative-ps additional-args drawing-args)
  (multiple-value-bind (drawing-function args closed)
      (find-remote-mouse-handler function additional-args)
    (when drawing-function
      (let* ((dx 0) (dy 0) (array nil)
	     (drawable (tv:update-offsets sheet array dx dy)))
	(when drawable
	  (stack-let* ((bounds (make-rect))
		       (npoints (length points))
		       (points16 (make-array (+ npoints (if closed 2 0))
					     :element-type '(unsigned-byte 16)))
		       (relative-ps-mask 0))
	    (destructuring-bind (lc tc rc bc) (tv:sheet-clipping-region sheet)
	      (set-rect bounds 0 (+ lc dx) (+ tc dy) (+ rc dx) (+ bc dy)))
	    (multiple-value-bind (drawing-state)	;--- Should do color also
		(let ((gs (graphics::get-drawing-state sheet)))
		  (apply #'graphics::with-drawing-state-internal
			 gs #'qd-state-pen-state-and-color gs '(nil nil) drawing-args))
	      (dotimes (i npoints)
		(setf (aref points16 i) (elt points (logxor i 1)))
		(if (aref relative-ps i)
		    (setf (ldb (byte 1 i) relative-ps-mask) 1)
		    (incf (aref points16 i)
			  (if (evenp i)
			      (+ dy (tv:sheet-top-margin-size sheet))
			      (+ dx (tv:sheet-left-margin-size sheet))))))
	      (when closed
		(setf (aref points16 npoints) (aref points16 0)
		      (aref points16 (1+ npoints)) (aref points16 1))
		(setf (ldb (byte 1 npoints) relative-ps-mask) (ldb (byte 1 0) relative-ps-mask)
		      (ldb (byte 1 (1+ npoints)) relative-ps-mask)
		      (ldb (byte 1 1) relative-ps-mask)))
	      (rpc::rpc-screen-call drawable #'rpc-uims-set-standard-mouse-handler
				    bounds drawing-state drawing-function
				    points16 relative-ps-mask args)))
	  t)))))

(defmethod (%screen-clear-remote-mouse-handler rpc::rpc-screen) (sheet)
  (let* ((dx 0) (dy 0) (array nil)
	 (drawable (tv:update-offsets sheet array dx dy)))
    (when drawable
      (rpc::rpc-screen-call drawable #'rpc-uims-clear-mouse-handler))))

(defmacro define-remote-mouse-handler-functions (&body cases)
  (let* ((structures nil)
	 (form `(defun find-remote-mouse-handler (function function-args)
		  (case function
		    . ,(loop for (function arglist type . more) in cases
			     collect `((,function)
				       (destructuring-bind ,arglist function-args
					 ,(ecase type
					    (:equals
					      `(stack-let ((new-args (list . ,(second more))))
						 (find-remote-mouse-handler ',(first more)
									    new-args)))
					    (:remote
					      (let ((struct-name
						      (sys:fintern "~A-MOUSE-HANDLER-ARGS"
								   function)))
						(push `(define-mac-structure ,struct-name
							 . ,(second more))
						      structures)
						`(values ,(first more)
							 (,(sys:fintern "MAKE-~A" struct-name)
							  . ,(third more))
							 . ,(nthcdr 3 more))))))))))))
    `(progn
       ,@structures
       ,form)))

(define-remote-mouse-handler-functions
  (graphics:draw-line () :remote 0 () ())
  (graphics:draw-arrow (&key (arrow-head-length graphics:*default-arrow-length*)
			     (arrow-base-width graphics:*default-arrow-width*)
			     (from-arrow-head nil)
			     (to-arrow-head t))
		       :remote 1
		       ((arrow-head-length integer-16)
			(arrow-base-width integer-16)
			(arrow-heads cardinal-8))
		       (:arrow-head-length arrow-head-length
			:arrow-base-width arrow-base-width
			:arrow-heads (+ (ecase to-arrow-head
					  ((nil) 0)
					  ((t) 1)
					  ((:reverse) 2))
					(ecase from-arrow-head
					  ((nil) 0)
					  ((t) 4)
					  ((:reverse) 8)))))
  (graphics:draw-rectangle (&key (filled t))
			   :remote 2 ((filled (boolean cardinal-8))) (:filled filled))
  (graphics:draw-lines (&key (closed nil) (filled nil))
		       :remote 3 ((filled (boolean cardinal-8))) (:filled filled) closed)
  (graphics:draw-triangle (&key (filled t))
			  :equals graphics:draw-polygon (:filled filled))
  (graphics:draw-polygon (&key (filled t))
			 :equals graphics:draw-lines (:filled filled :closed t)))

(defun tv:window-set-remote-rubber-band-line-mouse-handler (sheet center-x center-y)
  (tv:window-set-remote-mouse-handler (si:follow-syn-stream sheet) 'graphics:draw-line
				      (list center-x center-y 0 0) (vector nil nil t t)
				      nil '(:alu :flip)))

(defun tv:window-set-remote-rubber-band-arrow-mouse-handler
       (sheet center-x center-y &rest args)
  (tv:window-set-remote-mouse-handler (si:follow-syn-stream sheet) 'graphics:draw-arrow
				      (list center-x center-y 0 0) (vector nil nil t t)
				      args '(:alu :flip)))

(define-mac-rpc-window-output-entry rpc-uims-drag-presentation 46
				    ((picture-id picture-id)
				     (presentation-id presentation-id)
				     (chord-mask cardinal-32))
				    ((result-window-id window-id)
				     (result-picture-id picture-id)
				     (result-presentation-id presentation-id)))

(defmethod (rpc-window-drag-presentation mac-rpc-window) (presentation mouse-chars)
  (multiple-value-bind (result-window-id result-picture-id result-presentation-id)
      (rpc-program-call program #'rpc-uims-drag-presentation id
			(loop for (picture-id picture) in pictures
			      when (position presentation
					     (qd-picture-unique-id-presentation-table picture))
				return picture-id)
			(qd-presentation-unique-id presentation)
			(let ((mask 0))
			  (dolist (mouse-char mouse-chars)
			    (setf (ldb (byte 1 (mouse-char-to-mac-chord mouse-char)) mask) 1))
			  mask))
    (when (not (zerop result-window-id))
      (let ((result-window (find result-window-id (mac-rpc-program-windows program)
				 :key #'mac-rpc-window-id)))
	(when result-window
	  (values result-window
		  (mac-rpc-window-presentation-from-id result-window
						       result-picture-id
						       result-presentation-id)))))))

;;;; Standard commands

(dw:define-remote-program-framework remote-quit-commands
  :selectable nil)

(define-remote-quit-commands-command (com-quit :menu-accelerator "Quit"
					       :menu-level (:top-level (:mac :file))
					       :keyboard-accelerator #\s-Q)
				     ()
  (dw:remote-program-quit))

(define-rpc-uims-to-mac-entry rpc-uims-close-front-window 12 () ())

(define-rpc-uims-to-mac-entry rpc-uims-close-all-windows 13 () ())

(defmethod (dw::remote-program-close-front-viewer mac-rpc-program) ()
  (rpc-program-call self #'rpc-uims-close-front-window))

(defmethod (dw::remote-program-close-all-viewers mac-rpc-program) ()
  (rpc-program-call self #'rpc-uims-close-all-windows))

(dw:define-remote-program-framework remote-viewer-commands
  :selectable nil
  :inherit-from (remote-quit-commands)
  :command-table (:kbd-accelerator-p t :inherit-from '("remote-quit-commands"))
  )

(define-remote-viewer-commands-command (com-close-front-viewer :menu-accelerator "Close"
							       :menu-level ((:mac :file))
							       :keyboard-accelerator #\s-W)
				       ()
  (dw::remote-program-close-front-viewer))

(define-remote-viewer-commands-command (com-all-viewers :menu-accelerator "Close All"
							:menu-level ((:mac :file)))
				       ()
  (dw::remote-program-close-all-viewers))

(defvar *standard-remote-viewer-file-menu* '("File" "Close" "Close All" nil "Quit"))
(defvar *standard-edit-menu* '("Edit" ("Undo" :keyboard-accelerator #\s-Z)
			      nil
			      ("Cut" :keyboard-accelerator #\s-X)
			      ("Copy" :keyboard-accelerator #\s-C)
			      ("Paste" :keyboard-accelerator #\s-V)
			      "Clear"))


(defun Allow-Backup-Screens (&optional (update-programs nil))
  ;;; For new programs, yet to be created
  (setf rpc:*rpc-screen-always-use-backup-screen* nil)
  ;;; for existing programs
  (when update-programs
    (loop for program in *rpc-programs*
	  when (and program
		    (typep program 'mac-genera))		;right kind
	    do (setf (genera-enable-backup-screen program) nil)
	       (add-remote-menu-item program "Backup Screen Enable/Disable" '((:mac :options)))
	       )
    )
  )

(defun Always-Use-Backup-Screens (&optional (update-programs nil))
  ;;; For new programs, yet to be created
  (setf rpc:*rpc-screen-always-use-backup-screen* t)
  ;;; for existing programs
  (when update-programs
    (loop for program in *rpc-programs*
	  when (and program
		    (typep program 'mac-genera))		;right kind
	    do (setf (genera-enable-backup-screen program) t)
	       (remove-remote-menu-item program "Backup Screen Enable/Disable" '((:mac :options)))
	       (when (genera-console program)
		 (rpc::Set-Backup-Screen (sys:console-screen (genera-console program))
					 (rpc::rpc-console-screen-drawable (genera-console program))
					 t)
		 )
	       )
    )
  )



#+ignore	;Don't compile this form in the normal course of events.
(eval-when (eval compile)
(write-octet-structure-definitions-to-c-file
  '(rpc-menu-info rpc-menu-list presentation presentation-set
    dialog-item dialog-items dialog-value dialog-values)
  "uims-types.h"
  :prologue #{ #ifndef _uims_types_
	       #define _uims_types_
	       #include '|<Menus.h>| #\Return

	       typedef unsigned long Application_ID;
               typedef unsigned long Window_ID;
               typedef unsigned long Picture_ID;
               typedef unsigned long Presentation_ID;
               typedef unsigned long Dialog_ID;
	       #define MenuIDOffset *menu-id-offset* #\Return

	       typedef struct {
	         long length;
		 struct {
		   unsigned char codeD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");
0		   unsigned char modifiers1;
0		   } element [MAX_KEYBOARD_EVENTS];
		 } Window_Characters;

             }
  :postscript #{ #endif _uims_types_
		 #\Return
		 }
	     )
)

#+ignore	;Don't compile this form in the normal course of events.
(define-remote-c-program rpc-uims-to-mac
  (:server (:prefix #{ extern MyWindowPtr current_myWindow; #\Return }
		    )
	   (:file "uims-to-mac")))
  
#+ignore	;Don't compile this form in the normal course of events.
(define-remote-c-program rpc-uims-from-mac
  (:client-extern
    (:errors rpc-uims-application-not-available rpc-uims-application-startup-error)
    (:file "uims-from-mac"))
  (:client
    (:errors rpc-uims-application-not-available rpc-uims-application-startup-error)
    (:file "uims-from-mac")))

