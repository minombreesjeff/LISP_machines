;;; -*- Mode: LISP; Syntax: Lisp+C; Package: RPC; Lowercase: Yes; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defprop define-standard-rpc-input-definer defun zwei:definition-function-spec-type)
(defmacro define-standard-rpc-input-definer (name module-name flavor-name finder
					     &optional identification-args)
  `(progn
     (defprop ,name define-remote-entry zwei:definition-function-spec-type)
     (defmacro ,name (name opcode arglist &body instance-method)
       (let ((instance-handler (sys:fintern "~A-INTERNAL" name))
	     (args (map 'list #'first arglist)))
	 `(compiler:local-declare ((sys:function-parent ,name define-remote-entry))
	    (define-remote-entry ,name ,',module-name
	      (:number ,opcode)
	      (:arguments ,@',identification-args . ,arglist)
	      (:asynchronous t)
	      (:lisp (:server (let ((instance ,'(,finder
						 . ,(map 'list #'first identification-args))))
				(when instance
				  (,instance-handler instance . ,args))))))
	    (defmethod (,instance-handler ,',flavor-name) ,args
	      . ,instance-method))))))

(defprop define-standard-rpc-output-definer defun zwei:definition-function-spec-type)
(defmacro define-standard-rpc-output-definer (name module-name &optional initial-args)
  `(progn
     (defprop ,name define-remote-entry zwei:definition-function-spec-type)
     (defmacro ,name (name opcode arglist values &key (asynchronous (null values)))
       (let ((c-name (lisp-name-to-c-name name)))
	 (when (string-equal c-name "RPC" :end1 3)
	   (setq c-name (intern (string-upcase (symbol-name c-name) :end 3)
				(symbol-package c-name))))
	 ,(when initial-args
	    `(setq arglist (append ',initial-args arglist)))
	 `(define-remote-entry ,name ,',module-name
	    (:number ,opcode)
	    (:arguments . ,arglist)
	    ,(if values
		 `(:values . ,values)
		 `(:asynchronous ,asynchronous))
	    (:c (:server ',(generate-c-server-callout c-name arglist values
						      :rpc-values (not asynchronous)))
		(:server-cleanup
		  ',(loop for ((name type)) on values
			  append (let ((function (get (if (consp type) (first type) type)
						      'callout-cleanup)))
				   (when function
				     (funcall function #{ (lisp-name-to-c-name name) })))))
		))))))

(eval-when (eval compile load)
(defun generate-c-server-callout (c-name arglist values &key (rpc-values (not (null values))))
  (dolist (value values)
    (let ((arg (getf (cddr value) :overwrite)))
      (when arg
	(setq arglist (remove arg arglist :key #'first)))))
  (let* ((*c-typedefs* nil)
	 (*c-declarations* nil)
	 (code
	  #{
	    (loop for (name type) in values
		   as cname = #{ (lisp-name-to-c-name name) }
		   append (remote-type-declaration type ':c cname)
		   append #{;}
		     )
	    (loop for ((name type)) on values
		   append (let ((function (get (if (consp type) (first type) type)
					       'callout-initialize)))
			    (when function
			      (funcall function #{ (lisp-name-to-c-name name) }))))
	    system_error_code = c-name ( (loop for ((name type) . more) on arglist
						  when (get (if (consp type) (first type) type)
							    'callout-with-pointer)
						    append #{&}
						  collect (lisp-name-to-c-name name)
						  when more append #{,})
					   (and arglist values #{,})
					   (loop for ((name) . more) on values
						  append #{&}
						  collect (lisp-name-to-c-name name)
						  when more append #{,})
					   );
	    if (system_error_code) return(system_error_code);
	    (when rpc-values
	       #{RPCValues( (loop for ((name) . more) on values
				   collect (lisp-name-to-c-name name)
				   when more append #{,})
			   );}
	       )
	    }))
    (append (collect-c-declarations) code)))
)

;;; A remote screen driven by the RPC.  This file is shared by all embeddings that
;;; don't use the X Window System or some alternative protocol for the same purpose.

(eval-when (eval load compile)

(define-remote-type console-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Console_ID name })))

(define-remote-type screen-id ()
  (:abbreviation-for 'cardinal-32)
  (:c (:declare (name) #{ Screen_ID name })))

(define-remote-type hardware-characters ()
  (:abbreviation-for '(vector cardinal-32))
  (:c (:declare (name) #{ Hardware_Characters *name })))

(defun image-word-size (raster)
  (multiple-value-bind (width height)
      (decode-raster-array raster)
    (+ (* height (ceiling width (sys:array-elements-per-q (sys:array-type-field raster)))) 4)))

(defmacro send-image (raster)
  `(update-xdr-pointer
     (send-image-internal ,raster xdr-agent xdr-pointer xdr-limit)))

;;; If we assume that the remote end can be better used shuffling bits around,
;;; it might make sense to offset the image down to a word boundary, after chasing
;;; indirections, and sending the even word sized subarray.
;;; Doesn't make much sense, though, until bit vector transmission is more optimized
;;; to just copy words (with optional sys:bit-reverse-32).
(defun send-image-internal (raster xdr-agent xdr-pointer xdr-limit)
  (multiple-value-bind (width height span)
      (decode-raster-array raster)
    (let* ((depth (sys:array-element-byte-size raster))
	   (elements-per-word (floor 32 depth)))
      (multiple-value-bind (word-width padding)
	  (ceiling width elements-per-word)
	;; Aligned raster rows are not actually required here, but this error
	;; check keeps the local and remote window systems consistent
	(compiler:%error-when (plusp (%fixnum-mod (lsh span depth) 32))
	  (error 'bitblt-array-fractional-word-width :array raster))
	(send-words width height depth word-width)
	(stack-let ((bits (make-array (+ (* height span)
					   ;; Omit padding at the end of the last raster row,
					   ;; which may not all exist as valid array elements
					   ;; if the array has an index offset.  Note that
					   ;; the value of padding is zero or negative.
					   padding)
				      :type (array-type raster)
				      :displaced-to raster)))
	  (if (= (ceiling span elements-per-word) word-width)
	      ;; Sending the whole array.
	      (ecase depth
		(1 (send-bit-vector bits))
		(4 (send-nibble-vector bits))
		(8 (send-byte-vector bits))
		(32 (send-word-vector bits)))
	      (dotimes (y height)
		(let* ((start (* y span))
		       (end (+ start width)))
		  (ecase depth
		    (1 (send-bit-vector bits start end))
		    (4 (send-nibble-vector bits start end))
		    (8 (send-byte-vector bits start end))
		    (32 (send-word-vector bits start end))))))))))
  xdr-pointer)

(defmacro receive-image (&optional variable storage-mode)
  `(multiple-value-setq (nil xdr-pointer)
     (receive-image-internal xdr-agent xdr-pointer xdr-limit
			     ,@(when (eq storage-mode :overwrite) `(,variable)))))

(defun receive-image-internal (xdr-agent xdr-pointer xdr-limit &optional into)
  (let* ((width (receive-word))
	 (height (receive-word))
	 (depth (receive-word))
	 (word-width (receive-word))
	 (elements-per-word (floor 32 depth)))
    (stack-let ((element-type `(unsigned-byte ,depth)))
      (multiple-value-bind (value actual-width span fast)
	  (if into
	      (multiple-value-bind (into-width height span) (decode-raster-array into)
		(ignore height)
		;; Aligned raster rows are not actually required here, but this error
		;; check keeps the local and remote window systems consistent
		(compiler:%error-when (plusp (%fixnum-mod (lsh span depth) 32))
		  (error 'bitblt-array-fractional-word-width :array into))
		(values into into-width span
			;; Make sure any extra bits at the end of each raster row are
			;; not valid bits at any level of indirect array, and therefore
			;; are okay to scribble upon.  Stop if we get to a 1-dimensional
			;; array or a displaced non-indirect array, which is just storage.
			(and (= into-width width)
			     (loop with array = into
				   with type = (array-type-field array)
				   while (array-indirect-p array)
				   do (setq array (array-indirect-pointer array))
				   while (= (array-rank array) 2)
				   always (and (= (array-type-field array) type)
					       (= (decode-raster-array array) width))))))
	      (let ((span (* word-width elements-per-word)))
		(values (make-raster-array span height :element-type element-type)
			span span t)))
	(stack-let ((bits (make-array ;; Omit padding at the end of the last raster row,
				      ;; which may not all exist as valid array elements
				      ;; if the array has an index offset
				      (+ (* (1- height) span) width)
				      :type (array-type value)
				      :displaced-to value)))
	  (if (and (= (floor span elements-per-word) word-width) fast)
	      ;; Fast case: bits doesn't skip any words in value, and furthermore
	      ;; any extra bits at the end of each raster row are okay to scribble upon
	      (ecase depth
		(1 (receive-bit-vector bits))
		(4 (receive-nibble-vector bits))
		(8 (receive-byte-vector bits))
		(32 (receive-word-vector bits)))
	      (dotimes (y height)
		(let* ((start (* y span))
		       (end (+ start width)))
		  (ecase depth
		    (1 (receive-bit-vector bits start end))
		    (4 (receive-nibble-vector bits start end))
		    (8 (receive-byte-vector bits start end))
		    (32 (receive-word-vector bits start end)))))))
	(unless (= actual-width width)
	  (setq value (make-raster-array width height :element-type (array-element-type value)
						      :displaced-to value
						      :displaced-conformally t)))
	(values value xdr-pointer)))))

(define-remote-type image ()
  (:lisp
    (:size (value) `(image-word-size ,value))
    (:send (value) `(send-image ,value))
    (:receive (variable storage-mode) `(receive-image ,variable ,storage-mode)))
  (:c
    (:declare (name) #{ RPC_image name })
    (:size (value) #{ value .height * value .word_width + 4})
    (:send (value)
     #{ send_word(value .width);
        send_word(value .height);
	send_word(value .depth);
	send_word(value .word_width);
	send_word_vector(value .data, value .height * value .word_width);
	})
    (:receive (value into-stack)
     #{ value .width = receive_word();
        value .height = receive_word();
	value .depth = receive_word();
	value .word_width = receive_word();
	(if into-stack
	     #{ value .data = get_receive_pointer();
	        advance_receive_pointer(value .height * value .word_width);
	      }
	      (let ((place (declare-c-variable 'bits #{long*})))
		#{ system_error_code = NewPtrChk(value .height * value .word_width * 4,
						 &place );
		   if (system_error_code) return(system_error_code);
		   receive_word_vector(place , value .height * value .word_width);
		   value .data = place ;
		 }))
	}))
  )

(defprop image t callout-with-pointer)

(defun (image callout-initialize) (name)
  #{ name .allocated = false;
   })

(defun (image callout-cleanup) (name)
  #{ if (name .allocated)
       FreeMemory((void **)&name . data);
   })

(zl:defstruct (colormap-entries :grouped-array :conc-name
				(:make-array (:type sys:art-16b)))
  index
  red
  green
  blue)

(define-remote-type colormap-entries ()
  (:abbreviation-for `(vector integer-16))
  (:c
    (:declare (name) #{ RPC_colormap_entries name })
    (:size (value) #{ (value .size << 1) + 1})
    (:send (value)
     #{ send_word(value .size << 2);
	send_halfword_vector(value .entries, (value .size << 2));
	})
    (:receive (value mode)
     #{ value .size = (receive_word()) >> 2;
	(ecase mode
	   ((:stack)
	    #{ value .entries = (RPC_colormap_entry *)get_receive_pointer();
	       advance_receive_pointer(value .size << 1);
	     })
	   ((:overwrite)
	    #{ receive_halfword_vector(value . entries , (value .size << 2));
	     })
	   ((nil)
	    (let ((place (declare-c-variable 'colors #{RPC_colormap_entry *})))
	      #{ system_error_code = NewPtrChk(value .size << 3, &place );
		 if (system_error_code) return(system_error_code);
		 receive_halfword_vector(place , (value .size << 2));
		 value .entries = place ;
	       })))
	}))
  )

(defprop colormap-entries t callout-with-pointer)

)

;;; Next free entry number is 3D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")7
0(define-remote-module rpc-console-output
			  (:number #x7f000123)
			  (:version 2)
			  (:server :c)
			  (:client :lisp))

(define-standard-rpc-output-definer define-rpc-console-output-entry rpc-console-output
				    ((console-id console-id)))

(defprop define-rpc-screen-output-entry define-remote-entry
	 zwei:definition-function-spec-type)

(defmacro define-rpc-screen-output-entry (name opcode arglist values)
  `(define-rpc-console-output-entry ,name ,opcode
				    ((screen-id screen-id) . ,arglist)
				    ,values))

;;; Next free entry number is 10
(define-remote-module rpc-console-input
			  (:number #x7f000124)
			  (:version 2)
			  (:server :lisp)
			  (:process nil)	;Ensure serial processing
			  (:client :c :lisp))

(define-standard-rpc-input-definer define-rpc-console-input-entry rpc-console-input
				    rpc-console find-console-from-id
				    ((console-id console-id)))

(defmethod (rpc-console-console-id cli::console :default) () nil)

(defun find-console-from-id (console-id)
  (dolist (console sys:*consoles*)
    (when (eql (rpc-console-console-id console) console-id)
      (return console))))

(defvar *rpc-unique-id* 0)

(defun new-unique-id ()
  (without-interrupts (incf *rpc-unique-id*)))

;;; Screen numbers are 1-based, as in the Monitors Control Panel menu.
;;; 0 means the default, the one with the menu bar on it.

(defflavor rpc-console
	((transport-agent *default-transport-agent*)
	 (display-device-type si:*b&w-screen*)
	 (default-screen-number 0)
	 (screen-drawable nil) screen-width screen-height screen-depth x-offset y-offset
	 (multi-bit-screen nil)
	 (who-line-p nil)
	 (console-id (new-unique-id)))
	(tv:basic-remote-console)
  (:readable-instance-variables transport-agent 
   default-screen-number console-id
   screen-height screen-width x-offset y-offset screen-drawable )
  (:initable-instance-variables transport-agent display-device-type
				default-screen-number multi-bit-screen
				who-line-p console-id screen-height
				screen-width x-offset y-offset))



(defflavor rpc-drawable
	(screen-id
	 (device-alu boole-ior)
	 (device-fill-data -1)
	 (device-plane-mask -1))
	()
  (:initable-instance-variables screen-id)
  (:readable-instance-variables screen-id)
  )


(defflavor rpc-screen
	((buffered-output-drawable nil)
	 buffered-output-alu buffered-output-fill-data buffered-output-plane-mask
	 
	 (buffered-graphics-enabled nil)
	 (buffered-graphics-mode nil)
	 (buffered-graphics (make-array 128 :element-type '(unsigned-byte 16) :fill-pointer 0))

	 (buffered-string-enabled t)
	 (buffered-string (make-array 128 :element-type '(unsigned-byte 8) :fill-pointer 0))
	 (buffered-string-font-number nil)
	 buffered-string-start-x buffered-string-end-x buffered-string-y
	 (buffered-string-limits (make-list 4))

	 (cached-font-number-font nil)
	 cached-font-number

	 (automatically-generate-pixmap-correspondences nil)
	 (genera-graphics-compatibility nil)

	 (refresh-pending nil)		;see rpc-console-screen-clobbered
	 
	 (screen-number 0)
	 (true-remote-depth 1)
	 (in-focus t))
	(tv:basic-remote-screen)
  (:initable-instance-variables
   screen-number buffered-string-enabled buffered-graphics-enabled
   automatically-generate-pixmap-correspondences)
  (:writable-instance-variables
   screen-number buffered-string-enabled buffered-graphics-enabled refresh-pending
   (tv:screen-permits-bit-save-arrays automatically-generate-pixmap-correspondences)
   (tv:screen-has-focus-p in-focus))
  (:readable-instance-variables
   (tv:screen-genera-graphics-compatibility genera-graphics-compatibility))
  (:functions send-buffered-string send-buffered-graphics)
  )

;;; The default for Host Style for RPC Screens
(defvar *RPC-Screen-Use-Host-Screen-Style* nil)

;;; The default for Backup Screen for RPC Screens
(defvar *RPC-Screen-Use-Backup-Screen* nil)

;;; When true, backup screens will always be created and the user won't
;;; be able to disable them.
(defvar *RPC-Screen-Always-Use-Backup-Screen* nil)

(defmethod (rpc-console-call rpc-console) (function &rest args)
  (when console-id				;Do nothing if shut down in another process.
    (let ((*default-transport-agent* transport-agent))	;--- Is this right?
      (apply function console-id args))))

;;; Shadow the basic-remote-screen method, so we do only the desired screen
;;; This avoids lock conflicts between the wholine screen and the main screen
(defmethod (:force-output rpc-screen) ()
  (when tv:console
    (rpc-screen-force-output self)))

(defmethod (tv:reset-dynamic-state rpc-screen) ()
  (setq buffered-string-font-number nil cached-font-number-font nil
	refresh-pending nil buffered-graphics-mode nil))

(defmethod (tv:remote-console-force-output rpc-console) () 
  ;--- There should just be a separate list of screens per console
  (dolist (screen tv:all-the-screens)
    (when (eq self (send screen :console))
      (rpc-screen-force-output screen)))
  )

(define-rpc-console-output-entry rpc-console-synch 1
				 ((id cardinal-32)) ((value cardinal-32)))

(defmethod (tv:remote-console-finish rpc-console) ()
  (tv:remote-console-force-output self)
  (rpc-console-call self #'rpc-console-synch (sys:%microsecond-clock)))

(defmethod (tv:remote-console-finish-blinkers rpc-console) ()
  (if (high-latency-p transport-agent)
      (tv:remote-console-finish self)
      (tv:remote-console-force-output self)))

(define-rpc-console-output-entry rpc-console-query-peripherals 2
				 () ((nscreens integer-16)
				     (mouse-max-n-buttons integer-16)
				     (mouse-max-size integer-16)
				     (keyboard-type cardinal-32)))

;;; Start up this RPC console.
(defmethod (start-rpc-console rpc-console) (&optional
					     (host-style *rpc-screen-use-host-screen-style*)
					     (backup-screen
					       (or *rpc-screen-always-use-backup-screen*
						   *rpc-screen-use-backup-screen*)))
  (multiple-value-bind (nscreens mouse-max-n-buttons mouse-max-size keyboard-type)
      (rpc-console-call self #'rpc-console-query-peripherals)
    (ignore nscreens)				;Only handle one for now.
    (minf mouse-max-size 32)			;All we keep track of.
    (setq cli::mouse (if (cli::console-master-p self)
			 (make-instance 'rpc-main-mouse
					:console self
					:max-n-buttons mouse-max-n-buttons
					:max-size mouse-max-size)
			 (make-instance 'rpc-secondary-mouse
					:console self
					:wired-mouse (si:make-wired-mouse)
					:max-n-buttons mouse-max-n-buttons
					:max-size mouse-max-size)))
    (setq cli::keyboard (let ((options (sys:keyboard-layout-keyboard-options keyboard-type)))
			  (when (= keyboard-type #x00010004)
			    (setf (getf options :all-keys-up-shift-keys)
				  system-applications::*symbolics-keyboard-shift-keys*))
			  (apply #'make-instance 'rpc-keyboard :console self options))))
  (sys:console-ensure-mouse-and-keyboard self)
  (sys:console-initialize self)
  (let ((master-p (cli::console-master-p self))
	(screen nil))
    (when master-p
      ;; Recycle an old main screen.
      (setq screen (dolist (old-screen tv:*old-console-screens*)
		     (when (sys:console-screen-acceptable-p self old-screen)
		       (setq tv:*old-console-screens*
			     (delete old-screen tv:*old-console-screens*))
		       (setf (rpc-screen-screen-number old-screen) default-screen-number)
		       (let ((who-screen (tv:screen-who-line-screen old-screen)))
			 (when who-screen
			   (setf (rpc-screen-screen-number who-screen) default-screen-number)))
		       (return old-screen)))))
    (multiple-value-bind (nil nil depth)
	(rpc-console-call self #'rpc-console-query-screen-size default-screen-number nil)
      (setf screen-depth depth))
    (unless multi-bit-screen
      (setq screen-depth 1))
    (setf screen-drawable (make-instance (rpc-console-pixmap-flavor self)))
    (rpc-console-call self #'rpc-screen-create-screen
		      (rpc-drawable-screen-id screen-drawable) default-screen-number
		      screen-width
		      screen-height x-offset y-offset host-style)
    (tv:without-screen-management
      (setq screen (tv:initialize-one-screen screen self master-p)))
    (set-backup-screen screen screen-drawable backup-screen)
    (push self sys:*consoles*)
    (when master-p
      (setq sys:*main-console* self
	    sys:*console* sys:*main-console*
	    tv:main-screen screen
	    tv:default-screen tv:main-screen)
      (push tv:main-screen tv:*console-screens*))
    (tv:mouse-initialize-internal cli::mouse screen)
    (let ((local-key 
	    (let ((local (dpbs 1 %%kbd-mapping-special
			       %kbd-mapping-special-shift %%kbd-mapping-special-class
			       cli::%kbd-shifts-local))
		  (table (keyboard-keyboard-table cli::keyboard)))
	      (dotimes (i 128)
		(when (= (aref table 0 i) local)
		  (return i))))))
      (when local-key
	(rpc-console-call self #'rpc-screen-set-kbd-parameters local-key t)))
    ;; If this is the first time since boot that the main screen has been
    ;; put into operation, run initializations.  Later times, this is a no-op.
    (tv:maybe-run-window-initializations)
    screen))

(define-rpc-console-output-entry rpc-console-enable-event-merging 34
				 () ()
				 :asynchronous nil)

(defmethod (sys:console-initialize rpc-console :after) ()
  (condition-case ()
       (rpc-console-call self #'rpc-console-enable-event-merging)
     (rpc-error)))

;;; Called when the remote console's top-left corner changed.
(defmethod (rpc-console-note-location-changed rpc-console)
	   (new-x new-y)
  (setf x-offset new-x
	y-offset new-y))

(defmethod (sys:console-screen-acceptable-p rpc-console) (screen)
  (and (typep screen 'rpc-screen)
       (eq (send screen :display-device-type) display-device-type)))

(defmethod (cli::console-create-keyboard rpc-console) ()
  (error "The keyboard should have already been created."))

(defmethod (sys:console-create-mouse rpc-console) ()
  (error "The mouse should have already been created."))

(define-rpc-console-output-entry rpc-console-query-screen-size 3
				 ((screen-number integer-16) (whole-p boolean))
				 ((width integer-16) (height integer-16) (depth integer-16)))

(defmethod (rpc-console-pixmap-flavor rpc-console :default) ()
  'rpc-pixmap-correspondence)

(defmethod (sys:console-video-address rpc-console) ()
  (values screen-drawable screen-width screen-height screen-depth 0 0 0 0))

(defmethod (sys:console-who-line-template rpc-console) ()
  (when who-line-p
    ;; This could actually by the default definition for all consoles with a little work.
    (multiple-value-bind (nil width nil nil nil nil left-margin right-margin)
	(sys:console-video-address self)
      (tv:default-construct-who-line-template display-device-type
					      (- width left-margin right-margin)))))

(defmethod (rpc-screen-flavor rpc-console) (who-line-p)
  (if who-line-p 'rpc-who-line-screen 'rpc-screen))

(defmethod (sys:console-screen-create rpc-console)
	   (who-line-p &rest make-window-args
		       &key (screen-number default-screen-number)
		       &allow-other-keys)
  (apply #'tv:make-window (rpc-screen-flavor self who-line-p)
	 :console self :superior nil
	 :screen-number screen-number
	 :display-device-type display-device-type
	 make-window-args))

(define-rpc-console-output-entry rpc-console-shutdown 4 () ())

(defmethod (sys:console-disable rpc-console) (&key abort)
  (declare (ignore abort))
  (cli::console-remove self)
  (when screen-drawable
    (unless si:*system-initialization-in-progress*
      (ignore-errors
	(rpc-console-call self #'rpc-screen-close-screen
			  (rpc-drawable-screen-id screen-drawable))))
    (setf screen-drawable nil))
  (when console-id
    (unless si:*system-initialization-in-progress*
      (ignore-errors
	(rpc-console-call self #'rpc-console-shutdown)))
    (setq console-id nil)))

(define-remote-entry rpc-console-start-up rpc-console-input
  (:number 1)
  (:arguments (who-line-p boolean)
	      (movable-window-p boolean)
	      (activity c-string))
  (:asynchronous t)
  (:lisp (:server (process-run-function "Console start up"	;:process nil above
		    #'(lambda ()
			(create-rpc-console :transport-agent xdr-agent
					    :who-line-p who-line-p
					    :host-style movable-window-p
					    :backup-screen (or *RPC-Screen-Always-Use-Backup-Screen*
							       *RPC-Screen-Use-Backup-Screen*)
					    :activity (unless (zerop (string-length activity))
							activity)))))))


(defvar-resettable *do-do-initial-dialogue* t)

;;; Create a new RPC Console
(defun create-rpc-console (&rest args
			   &key activity transport-agent
				(main-p (and (null sys:*main-console*)	;Make sure there isn't one already
					     (embedded-agent-p transport-agent)))
				(flavor (if main-p 'rpc-main-console 'rpc-console))
				(host-style *RPC-Screen-Use-Host-Screen-Style*)
				(backup-screen (or *RPC-Screen-Always-Use-Backup-Screen*
						   *RPC-Screen-Use-Backup-Screen*))
				&allow-other-keys)
  (let ((console (si:with-rem-keywords
		   (some-args args '(:activity :main-p :flavor :host-style :backup-screen))
		   (apply #'make-instance flavor some-args))))
    (start-rpc-console console host-style backup-screen)
    (when activity
      (if (string-equal activity "Initial Lisp")
	  (tv:delaying-screen-management	;don't autoexpose the Lisp Listener
						;before we arrest its process
	    (let* ((too-small (multiple-value-bind (width height)
				  (send (sys:console-screen console) :inside-size)
				(or (< width 750) (< height 500))))
		   (window (si:find-or-create-initial-lisp-listener
			     (sys:console-screen console) (not too-small)))
		   (process (send window :process))
		   (turn-servers-on
		     (and (not (equalp (send net:*local-host* :server-machine) "YES"))
			  (not (eq net:*local-site* neti:*distribution-site*)))))
	      (send process :arrest-reason :herald)
	      (send window :select)
	      (unwind-protect
		  (when *do-do-initial-dialogue*
		    (send window :clear-window)
		    (si:do-initial-dialogue window turn-servers-on))
		(setf *do-do-initial-dialogue* nil)
		(when main-p
		  (setq tv:initial-lisp-listener window))
		(process-wait "Finish disk save"
		  #'(lambda () (null si:*disk-saving*)))
		(send process :revoke-arrest-reason :herald))))
	  (sys:select-activity activity :console console)))
    console))

(defmethod (:appropriate-hardware-p rpc-screen) ()
  (and (not (member self tv:*old-console-screens*))		;not out-of-use
       (not (null tv:console))))				;connected

(define-rpc-console-input-entry rpc-console-mouse-position 2
				((in-screen-id screen-id) (x integer-16) (y integer-16))
  (when (eql (rpc-drawable-screen-id screen-drawable) in-screen-id)
    (tv:remote-console-new-mouse-position x y)))

(define-rpc-console-input-entry rpc-console-mouse-transition 4
				((in-screen-id screen-id) (buttons cardinal-8)
				 (x integer-16) (y integer-16))
  (when (eql (rpc-drawable-screen-id screen-drawable) in-screen-id)
    (tv:remote-console-new-mouse-buttons buttons x y)))

(define-rpc-console-input-entry rpc-console-keyboard-character 3
				((hard-char cardinal-32))
  (tv:io-buffer-put tv:keystroke-buffer hard-char t nil nil)	;save char but don't wakeup
  (tv:console-process-input self)				;send char where it belongs
  (when cli::esc-function					;wakeup kbd process if needed
    (process:process-wakeup cli::keyboard-process)))

(define-rpc-console-input-entry rpc-console-multiple-keyboard-characters 8
				((hard-chars hardware-characters))
  (let ((hard-chars hard-chars))
    (declare (sys:array-register hard-chars))
    (dotimes (i (length hard-chars))
      (tv:io-buffer-put tv:keystroke-buffer (aref hard-chars i) t nil nil)))
  (tv:console-process-input self)		;send char where it belongs
  (when cli::esc-function			;wakeup kbd process if needed
    (process:process-wakeup cli::keyboard-process)))

(defun-in-flavor (clobber-rectangle rpc-console) (in-screen-id width height x y)
  (dolist (screen tv:all-the-screens)
    (when (and (eq self (send screen :console))
	       (eql (rpc-drawable-screen-id (tv:screen-buffer screen)) in-screen-id))
      (tv:remote-console-asynchronous-refresh self screen x y (+ x width) (+ y height)))))

(define-rpc-console-input-entry rpc-console-screen-clobbered 5
				((in-screen-id screen-id))
  (clobber-rectangle in-screen-id screen-width screen-height 0 0))
  
(define-rpc-console-input-entry rpc-console-screen-rectangle-clobbered 6
				((in-screen-id screen-id)
				 (width integer-16) (height integer-16)
				 (x integer-16) (y integer-16))
  (clobber-rectangle in-screen-id width height x y))

(defun-in-flavor (note-focus-changed rpc-console) (in-screen-id new-focus)
  (dolist (screen tv:all-the-screens)
    (when (and (eq self (send screen :console))
	       (eql (rpc-drawable-screen-id (tv:screen-buffer screen)) in-screen-id))
      (setf (tv:screen-has-focus-p screen) (not (zerop new-focus))))))

(define-rpc-console-input-entry rpc-console-screen-focus-changed 7
				((in-screen-id screen-id)
				 (new-focus integer-16))
  (note-focus-changed in-screen-id new-focus))

;;; Entry for Remote Console that has changed it's size and/or has moved
;;; it's top-left corner.
(define-rpc-console-input-entry rpc-console-size-changed 9
				((new-x-offset integer-16)
				 (new-y-offset integer-16)
				 (new-width integer-16)
				 (new-height integer-16))
  (rpc-console-note-location-changed self new-x-offset new-y-offset)
  (unless (and (= new-width screen-width)
	       (= new-height screen-height))
    (setf screen-width new-width)
    (setf screen-height new-height)
    (tv:remote-console-note-size-changed self))) 

;;;

(define-rpc-console-output-entry rpc-console-beep 9 ((duration integer-16)) ())

(defmethod (cli::console-beep rpc-console) ()
  (rpc-console-call self #'rpc-console-beep 10))

;;;

(defflavor rpc-mouse () (tv:basic-remote-mouse))

(define-rpc-console-output-entry rpc-console-set-mouse-cursor 5
				 ((hotspot-x integer-16) (hotspot-y integer-16) (bitmap image))
				 ())

(define-rpc-console-output-entry rpc-console-clear-mouse-cursor 6 () ())
(define-rpc-console-output-entry rpc-console-show-mouse-cursor 23 () ())
(define-rpc-console-output-entry rpc-console-hide-mouse-cursor 24 () ())

(defmethod (tv:remote-mouse-install-cursor rpc-mouse) ()
  (when tv:console				;if not shut down yet
    (rpc-console-call tv:console #'rpc-console-set-mouse-cursor
		      (tv:mouse-cursor-x-offset self) (tv:mouse-cursor-y-offset self)
		      (tv:mouse-cursor-pattern self))))

(defmethod (tv:remote-mouse-clear-cursor rpc-mouse) ()
  (when tv:console				;if not shut down yet
    (rpc-console-call tv:console #'rpc-console-clear-mouse-cursor)))

(defmethod (tv:remote-mouse-show-cursor rpc-mouse) ()
  (when (and tv:console (not (rpc-console-drawing-opens-mouse-cursor tv:console)))
    (rpc-console-call tv:console #'rpc-console-show-mouse-cursor)))

(defmethod (tv:remote-mouse-hide-cursor rpc-mouse) ()
  (when (and tv:console (not (rpc-console-drawing-opens-mouse-cursor tv:console)))
    (rpc-console-call tv:console #'rpc-console-hide-mouse-cursor)))

(defmethod (tv:mouse-potentially-conflicting-blinker rpc-mouse) ()
  (and tv:console (not (rpc-console-drawing-opens-mouse-cursor tv:console))
       (tv:mouse-blinker self)))

;;;--- When another embedding is defined, make this default to nil and shadow in Mac flavor.
(defmethod (rpc-console-drawing-opens-mouse-cursor rpc-console) () t)

;;; No method should be defined on this flavor, since specific hosts may mix main-console
;;; and rpc-console themselves.
(defflavor rpc-main-console () (cli::main-console rpc-console))

(defflavor rpc-main-mouse () (rpc-mouse tv:primary-local-mouse))

(defflavor rpc-secondary-mouse () (rpc-mouse tv:secondary-local-mouse))

(defflavor rpc-keyboard
	((led-shift-bits nil)
	 (last-led-mask nil))
	(cli::keyboard)
  :initable-instance-variables)

(defmethod (cli::keyboard-note-change-of-shift-keys rpc-keyboard :after) ()
  (when led-shift-bits
    (let ((on 0))
      (let ((shifts (logior cli::left-shifts cli::right-shifts)))
	(loop for mask in led-shift-bits
	      for bit from 0
	      do
	  (when (logtest mask shifts)
	    (setf (ldb (byte 1 bit) on) 1))))
      (unless (eql on last-led-mask)
	(rpc-console-call cli::console #'rpc-console-set-kbd-leds on)
	(setq last-led-mask on)))))

(compile-flavor-methods rpc-console rpc-main-mouse rpc-secondary-mouse rpc-keyboard)

(defmethod (:expose rpc-screen :after) (&rest ignore)
  ;; This is so that business graphics can work even if local screen is only one-deep.
  (multiple-value-setq (nil nil true-remote-depth)
    (rpc-console-call tv:console #'rpc-console-query-screen-size screen-number t))
  (setf (tv:screen-genera-graphics-compatibility self)
	graphics::
	(not (ldb-test %%scan-conversion-host-allowed *default-scan-conversion-flags*))))

(defmacro-in-flavor (saving-normal-graphics-state rpc-screen) ((drawable console) &body body)
  `(multiple-value-bind (original-alu original-fill-data original-plane-mask)
       (normal-graphics-state ,drawable)
     (unwind-protect
	 (progn ,@body)
       (set-normal-graphics-state ,drawable ,console
				  original-alu original-fill-data original-plane-mask))))

(defun-in-flavor (rpc-screen-call rpc-screen) (drawable function &rest args)
  (when tv:console				;if not shut down yet
    (when buffered-string-font-number
      (saving-normal-graphics-state (drawable tv:console)
	(send-buffered-string)))
    (when buffered-graphics-mode
      (saving-normal-graphics-state (drawable tv:console)
        (send-buffered-graphics)))
    (apply #'rpc-console-call tv:console function (rpc-drawable-screen-id drawable) args)))

(defmethod (normal-graphics-state rpc-drawable :default) ()
  (values device-alu device-fill-data device-plane-mask)) 

(defmethod (set-normal-graphics-state rpc-drawable :default) (console alu fill-data plane-mask)
  (unless (and (= alu device-alu)
	       (= fill-data device-fill-data)
	       (= plane-mask device-plane-mask))
    (rpc-console-call console #'rpc-screen-set-fill-parameters (rpc-drawable-screen-id self)
		      fill-data plane-mask)
    (setq device-alu alu
	  device-fill-data fill-data
	  device-plane-mask plane-mask)))

;;; Entry to pass the info to the remote host when the screen is to change styles.
(define-rpc-screen-output-entry rpc-screen-change-screen-style 35
				((screen-number integer-16) (host-style boolean))
				()) 

;;; Call to set the window type of the remote screen.
;;;   T => Use Host style window (GrowBox and Title Bar)
;;; NIL => Use Fixed window ('Genera style')
(defmethod (change-screen-style rpc-screen) (drawable screen-number host-style)
  (rpc-screen-call drawable #'rpc-screen-change-screen-style screen-number host-style))

;;; Entry to pass the info to the remote host when the screen is to have a backup screen
(define-rpc-screen-output-entry rpc-screen-set-backup-screen 36
				((enable-backup-screen boolean))
				()) 

;;; Call to enable or disable the use of a backup screen for windows that don't have
;;; (or can't easily be written) :refresh methods.
;;;   T => Enable the use of backup screen for this screen
;;; NIL => Disable ...
(defmethod (Set-Backup-Screen rpc-screen) (drawable backup-screen)
  (rpc-screen-call drawable #'rpc-screen-set-backup-screen
		   (or *RPC-Screen-Always-Use-Backup-Screen* backup-screen)))

;;; Entry to create a screen on the remote host.
(define-rpc-screen-output-entry rpc-screen-create-screen 7
				((screen-number integer-16)
				 (width integer-16) (height integer-16)
				 (x-offset integer-16) (y-offset integer-16)
				 (host-style boolean))
				())

(define-rpc-screen-output-entry rpc-screen-close-screen 8 () ())

(define-rpc-console-output-entry rpc-screen-copy-area 25
    ((alu cardinal-8) (width integer-16) (height integer-16)
     (from-screen-id screen-id) (from-x integer-16) (from-y integer-16)
     (to-screen-id screen-id) (to-x integer-16) (to-y integer-16))
    ())

(defmethod (tv:remote-copy-area rpc-screen) (alu width height
					     from-drawable from-x from-y
					     to-drawable to-x to-y
					     &optional (fill-data -1) (plane-mask -1))
  (when buffered-string-font-number
    (send-buffered-string))
  (when buffered-graphics-mode
    (send-buffered-graphics))
  (set-normal-graphics-state to-drawable tv:console alu fill-data plane-mask)
  (rpc-console-call tv:console #'rpc-screen-copy-area alu (abs width) (abs height)
		    (rpc-drawable-screen-id from-drawable) from-x from-y
		    (rpc-drawable-screen-id to-drawable) to-x to-y))

(define-rpc-screen-output-entry rpc-screen-get-image 10
				((width integer-16) (height integer-16)
				 (from-x integer-16) (from-y integer-16)
				 (full-depth-p boolean) (image-storage image))
				((image image :overwrite image-storage)
				 (image-x integer-16) (image-y integer-16)))

;--- Compatibility for a little while, then can recycyle index
(define-remote-entry rpc-screen-old-get-image rpc-console-output
  (:number 11)
  (:arguments (console-id console-id) (screen-id screen-id)
	      (width integer-16) (height integer-16) (from-x integer-16)
	      (from-y integer-16) (image-storage image))
  (:values (image image :overwrite image-storage) (image-x integer-16)
	   (image-y integer-16))
  (:c
    (:server #{ RPC_image image;
	        short image_x;
		short image_y;
		image.allocated = false;
		system_error_code = RPC_screen_get_image(console_id, screen_id, width, height,
							 from_x, from_y, false,
							 &image, &image_x, &image_y);
		if (system_error_code) return(system_error_code);
		RPCValues(image, image_x, image_y);
		})
    (:server-cleanup #{ if(image.allocated)FreeMemory((void * *)&image.data);
		      })))

;;; This value is chosen to be the largest value that does not cause
;;; RPC to use the less efficient bulk-transfer mechanism in either direction
(defparameter *max-rpc-image-nwords* 350)

(defparameter *max-rpc-image-processes* 5)

;; Each process runs this function or get-image-internal-2
(defun-in-flavor (get-image-internal-1 rpc-screen) (width height slice-height flag
						    from-drawable from-x from-y
						    to-array to-x to-y)
  (with-data-stack
    (unwind-protect
	(multiple-value-bind (rwidth rheight rspan)
	    (decode-raster-array to-array)
	  (ignore rwidth rheight)
	  (loop with image = (si:%make-indirect-raster-stack-array width slice-height
					rspan (array-type-field to-array)
					to-array (+ (* to-y rspan) to-x))
		for y = 0 then next-y
		as next-y = (min (+ y slice-height) height)
		as this-height = (- next-y y) do
	    (si:%change-indirect-raster-array image width this-height rspan to-array
					      (+ (* to-y rspan) to-x))
	    (multiple-value-bind (image image-x image-y)
		(rpc-screen-call from-drawable #'rpc-screen-get-image width this-height
				 from-x from-y ( (array-type-field to-array) art-1b)
				 image)
	      (unless (null image)		;console might have shut down
		(unless (and (zerop image-x) (zerop image-y))
		  (error "Host returned image with offset, which is no longer supported"))))
	    (when (= next-y height)
	      (return))
	    (incf from-y this-height)
	    (incf to-y this-height)))
      (setf (location-contents flag) nil))))

(defun-in-flavor (get-image-internal-2 rpc-screen) (alu width height
						    slice-width slice-height flag
						    from-drawable from-x from-y
						    to-array to-x to-y)
  (unwind-protect
      (stack-let* ((dims (list slice-height slice-width))
		   (buffer (make-array dims :type (array-type-field to-array))))
	(loop for y = 0 then next-y
	      as next-y = (min (+ y slice-height) height)
	      as this-height = (- next-y y) do
	    (multiple-value-bind (image image-x image-y)
		(rpc-screen-call from-drawable #'rpc-screen-get-image width this-height
				 from-x from-y ( (array-type-field to-array) art-1b)
				 buffer)
	      (unless (null image)		;console might have shut down
		(bitblt alu width this-height image image-x image-y to-array to-x to-y)))
	  (when (= next-y height)
	    (return))
	  (incf from-y this-height)
	  (incf to-y this-height)))
    (setf (location-contents flag) nil)))

(defmethod (tv:remote-get-image rpc-screen) (alu width height
					     from-drawable from-x from-y
					     to-array to-x to-y)
  (when tv:console			;if not shut down yet
    (when buffered-string-font-number
      (send-buffered-string))		;do in the process that holds the lock
    (when buffered-graphics-mode
      (send-buffered-graphics)))
  (let* ((array-type (array-type-field to-array))
	 (elements-per-word (array-elements-per-q array-type))
	 (word-width (ceiling width elements-per-word))
	 (slice-width (* word-width elements-per-word))
	 (slice-height (max 1 (min height (floor *max-rpc-image-nwords* word-width))))
	 (n-slices (ceiling height slice-height))
	 (n-processes (min *max-rpc-image-processes* n-slices))
	 (process-height (ceiling height n-processes)))
    ;; Check for error now before going without-aborts and multi-process
    ;; Aligned raster rows are not actually required here, but this error
    ;; check keeps the local and remote window systems consistent
    (multiple-value-bind (nil nil span) (decode-raster-array to-array)
      (compiler:%error-when (plusp (%fixnum-mod (lsh span (array-element-byte-size to-array))
						32))
	(error 'bitblt-array-fractional-word-width :array to-array)))
    ;; Make it more difficult to abort this function while the created processes
    ;; are running, since that would cause the array argument to be written
    ;; into after this function is exited, which is undesirable.
    ;; Unfortunately this also creates an unnecessary without-aborts when there
    ;; is only one process, or when the other processes have already terminated,
    ;; but I guess we can live with that if we have to.
    (without-aborts ("An image is being received into ~S.~@
		      Aborting now would not prevent asynchronous modification of~@
		      that array by the multiple processes implementing the operation."
		     to-array)
      (let ((busy (and (> n-processes 1)
		       (make-array n-processes :initial-element t))))
	(loop for y = 0 then next-y while (< y height)
	      as next-y = (min (+ y process-height) height)
	      as this-height = (- next-y y)
	      for process from 1 with dummy do
	  ;; This receives all of the lexical state as arguments so that we do not have
	  ;; to cons a closure, nor use a stack-closure which would be unsafe if this
	  ;; process terminates early
	  (flet ((do-it (process y this-height width slice-height slice-width busy
			 alu from-drawable from-x from-y to-array to-x to-y
			 self self-mapping-table)
		   (if (= alu boole-1)
		       (get-image-internal-1 width this-height slice-height
					     (if busy (locf (aref busy process)) (locf dummy))
					     from-drawable from-x (+ from-y y)
					     to-array to-x (+ to-y y))
		       (get-image-internal-2 alu width this-height slice-width slice-height
					     (if busy (locf (aref busy process)) (locf dummy))
					     from-drawable from-x (+ from-y y)
					     to-array to-x (+ to-y y)))))
	    (if (= process n-processes)
		(do-it 0 y this-height width slice-height slice-width busy
		       alu from-drawable from-x from-y to-array to-x to-y
		       self self-mapping-table)
		(process-run-function "Remote Get Image" #'do-it process y this-height
				      width slice-height slice-width busy
				      alu from-drawable from-x from-y to-array to-x to-y
				      self self-mapping-table))))
	(unless (null busy)
	  ;; If we created some processes, wait for them to finish before returning.
	  (process-wait "Remote Get Image" #'every #'null busy))))))

(define-rpc-screen-output-entry rpc-screen-put-image 12
				((alu cardinal-8) (width integer-16) (height integer-16)
				 (image image) (from-x integer-16) (from-y integer-16)
				 (to-x integer-16) (to-y integer-16))
				())

(defmethod (tv:remote-put-image rpc-screen) (alu width height
					     from-array from-x from-y
					     to-drawable to-x to-y
					     &optional (fill-data -1) (plane-mask -1))
  (set-normal-graphics-state to-drawable tv:console alu fill-data plane-mask)
  (unless (and (plusp width) (plusp height))
    (return-from tv:remote-put-image nil))
  (multiple-value-bind (rwidth rheight rspan)
      (decode-raster-array from-array)
    (setq from-x (mod from-x rwidth)		;Wrap starting point into real array.
	  from-y (mod from-y rheight))
    (let* ((array-type (array-type-field from-array))
	   (elements-per-word (array-elements-per-q array-type))
	   (send-width rwidth)
	   (send-height rheight)
	   (o-from-x from-x)
	   (o-from-y from-y)
	   (send-x 0)
	   (send-y 0))
      (unless (> (+ from-x width) rwidth)	;If not wrapping
	(setq send-x from-x from-x 0 send-width width))	;just take subarray.
      (unless (> (+ from-y height) rheight)
	(setq send-y from-y from-y 0 send-height height))
      (let ((slice-height (max 1 (min send-height
				      (floor *max-rpc-image-nwords*
					     (ceiling send-width elements-per-word))))))
	(cond ((and (= slice-height send-height)
		    (> (* (ceiling width send-width) (ceiling height send-height)) 10)
		    (< (* send-width send-height 4)
		       (* *max-rpc-image-nwords* elements-per-word)))
	       ;; This image is going to be replicated more than ten times, and it is
	       ;; small enough that we can do at least four replications locally.  Do
	       ;; as much local replication as possible, since that is much faster.
	       (let* ((x-replication (min (ceiling width send-width)
					  (floor (* (floor *max-rpc-image-nwords* send-height)
						    elements-per-word)
						 send-width)))
		      (y-replication (min (ceiling height send-height)
					  (floor (floor *max-rpc-image-nwords* send-height)
						 (ceiling (* send-width x-replication)
							  elements-per-word))))
		      (buf-width (* x-replication send-width))
		      (buf-height (* y-replication send-height)))
		 (stack-let* ((buf1 (sys:make-raster-array
				      (* (ceiling buf-width elements-per-word)
					 elements-per-word)
				      buf-height
				      :type array-type))
			      (buf (sys:make-raster-array buf-width buf-height
							  :type array-type
							  :displaced-to buf1
							  :displaced-conformally t)))
		   (bitblt boole-1 buf-width buf-height from-array o-from-x o-from-y buf 0 0)
		   (rpc-screen-call to-drawable #'rpc-screen-put-image alu width height
				    buf 0 0 to-x to-y))))
	      ((and (= send-x 0) (= send-y 0)
		    (= (ceiling send-width elements-per-word) (floor rwidth elements-per-word))
		    (= slice-height rheight))
	       ;; Taking whole array and it fits.
	       (rpc-screen-call to-drawable #'rpc-screen-put-image alu width height
				from-array from-x from-y to-x to-y))
	      ((= slice-height send-height)
	       ;; Part of the array we want fits.
	       (with-data-stack
		 (let ((image (si:%make-indirect-raster-stack-array send-width send-height
					rspan array-type
					from-array (+ send-x (* send-y rspan)))))
		   (rpc-screen-call to-drawable #'rpc-screen-put-image alu width height
				    image from-x from-y to-x to-y))))
	      (t
	       ;; Need to manually step through slices from this end.
	       (with-data-stack
		 (loop with image = (si:%make-indirect-raster-stack-array
					  send-width slice-height rspan array-type
					  from-array (+ send-x (* (+ send-y from-y) rspan)))
		       for y = 0 then next-y
		       as next-y = (min height (+ y (min (- rheight from-y) slice-height)))
		       as this-height = (- next-y y)
		       do
		   (si:%change-indirect-raster-array image send-width this-height
						     rspan from-array
						     (+ send-x (* (+ send-y from-y) rspan)))
		   (rpc-screen-call to-drawable #'rpc-screen-put-image alu width this-height
				    image from-x 0 to-x to-y)
		   (setq from-y (mod (+ from-y this-height) rheight)
			 to-y (+ to-y this-height))
		   (when (= next-y height)
		     (return))))))))))

(defmethod (tv:remote-draw-1-bit-raster rpc-screen)
	   (width height pattern from-x from-y drawable to-x to-y
	    ones-alu ones-fill-data ones-plane-mask
	    zeros-alu zeros-fill-data zeros-plane-mask)
  (declare (ignore zeros-fill-data zeros-plane-mask))
  (tv:remote-put-image self (tv:combine-1-bit-alus ones-alu zeros-alu)
		       width height pattern from-x from-y drawable to-x to-y
		       ones-fill-data ones-plane-mask))

(define-rpc-console-output-entry rpc-console-get-whole-screen-image 27
  ((screen-number integer-16) (width integer-16) (height integer-16)
   (from-x integer-16) (from-y integer-16) (full-depth-p boolean))
  ((image image) (image-x integer-16) (image-y integer-16)))

;;;--- Temporary for compatibility
(define-remote-entry rpc-console-old-get-whole-screen-image rpc-console-output
  (:number 18)
  (:arguments (console-id console-id) (screen-number integer-16)
	      (width integer-16) (height integer-16) (from-x integer-16)
	      (from-y integer-16))
  (:values (image image) (image-x integer-16) (image-y integer-16))
  (:c
    (:server #{ RPC_image image;
	        short image_x;
		short image_y;
		image.allocated = false;
		system_error_code = RPC_console_get_whole_screen_image(console_id,
								       screen_number,
								       width, height,
								       from_x, from_y,
								       false, &image,
								       &image_x, &image_y);
		if (system_error_code) return(system_error_code);
		RPCValues(image, image_x, image_y);
		})
    (:server-cleanup #{ if(image.allocated)FreeMemory((void * *)&image.data);
		      })))

(defmethod (tv:remote-console-get-whole-screen-image rpc-console)
	   (&optional (screen-number default-screen-number)
		      (full-depth-p nil))
  (multiple-value-bind (width height depth)
      (rpc-console-call self #'rpc-console-query-screen-size screen-number t)
    (unless full-depth-p
      (setq depth 1))
    (let ((result (graphics:make-raster-array-with-correct-width width height
		    :element-type `(unsigned-byte ,depth))))
      (let ((slice-height (max 1 (min height
				      (floor *max-rpc-image-nwords*
					     (ceiling width (floor 32 depth)))))))
	(loop for y = 0 then next-y
	      as next-y = (min height (+ y slice-height))
	      as this-height = (- next-y y)
	      do
	  (multiple-value-bind (image image-x image-y)
	      (rpc-console-call self #'rpc-console-get-whole-screen-image screen-number
				width this-height 0 y full-depth-p)
	    (bitblt boole-1 width this-height image image-x image-y result 0 y))
	  (when (= next-y height)
	    (return))))
      (values result width height))))

(defun-in-flavor (allocate-buffered-graphics-room rpc-screen) (mode count drawable alu
							       fill-data plane-mask)
  (when buffered-string-font-number
    (send-buffered-string))
  (unless (and (eql mode buffered-graphics-mode)
	       (eql drawable buffered-output-drawable)
	       (eql alu buffered-output-alu)
	       (eql fill-data buffered-output-fill-data)
	       (eql plane-mask buffered-output-plane-mask))
    (when buffered-graphics-mode
      (send-buffered-graphics))
    (setq buffered-graphics-mode mode
	  buffered-output-drawable drawable
	  buffered-output-alu alu
	  buffered-output-fill-data fill-data
	  buffered-output-plane-mask plane-mask))
  (tv:remote-screen-note-pending-output self)
  #+ignore (assert ( count (array-total-size buffered-graphics)))
  (loop
    (let* ((index (fill-pointer buffered-graphics))
	   (new-fill-pointer (+ index count)))
      (when (< new-fill-pointer (array-total-size buffered-graphics))
	(setf (fill-pointer buffered-graphics) new-fill-pointer)
	(return index)))
    (send-buffered-graphics)))

(defun-in-flavor (send-buffered-graphics rpc-screen) ()
  (set-normal-graphics-state buffered-output-drawable tv:console buffered-output-alu
			     buffered-output-fill-data buffered-output-plane-mask)
  (when tv:console
    (rpc-console-call tv:console buffered-graphics-mode
		      (rpc-drawable-screen-id buffered-output-drawable) buffered-output-alu
		      buffered-graphics)
    (setf (fill-pointer buffered-graphics) 0)
    (setq buffered-graphics-mode nil)))

(define-rpc-screen-output-entry rpc-screen-draw-line 13
				((alu cardinal-8) (from-x integer-16) (from-y integer-16)
				 (to-x integer-16) (to-y integer-16) (draw-end-point boolean))
				())

(defmethod (tv:remote-draw-line rpc-screen) (drawable x1 y1 x2 y2
					     alu fill-data plane-mask
					     draw-end-point)
  (if buffered-graphics-enabled
      (let ((index (allocate-buffered-graphics-room
		     (if draw-end-point
			 (lambda (console screen alu lines)
			   (rpc-screen-draw-multiple-lines console screen alu t lines))
			 (lambda (console screen alu lines)
			   (rpc-screen-draw-multiple-lines console screen alu nil lines)))
		     4 drawable alu fill-data plane-mask)))
	(setf (aref buffered-graphics index) x1
	      (aref buffered-graphics (1+ index)) y1
	      (aref buffered-graphics (+ index 2)) x2
	      (aref buffered-graphics (+ index 3)) y2))
    (set-normal-graphics-state drawable tv:console alu fill-data plane-mask)
    (rpc-screen-call drawable #'rpc-screen-draw-line alu x1 y1 x2 y2 draw-end-point)))

(define-rpc-screen-output-entry rpc-screen-draw-rectangle 14
				((alu cardinal-8) (width integer-16) (height integer-16)
				 (x integer-16) (y integer-16))
				())

(defmethod (tv:remote-draw-rectangle rpc-screen) (width height drawable x y
						  alu fill-data plane-mask)
  (if buffered-graphics-enabled
      (let ((index (allocate-buffered-graphics-room #'rpc-screen-draw-multiple-rectangles 4
						    drawable alu fill-data plane-mask)))
	(setf (aref buffered-graphics index) x
	      (aref buffered-graphics (1+ index)) y
	      (aref buffered-graphics (+ index 2)) (+ x width)
	      (aref buffered-graphics (+ index 3)) (+ y height)))
    (set-normal-graphics-state drawable tv:console alu fill-data plane-mask)
    (rpc-screen-call drawable #'rpc-screen-draw-rectangle alu width height x y)))

(define-rpc-screen-output-entry rpc-screen-draw-triangle 15
				((alu cardinal-8)
				 (x1 integer-16) (y1 integer-16)
				 (x2 integer-16) (y2 integer-16)
				 (x3 integer-16) (y3 integer-16)
				 (bound-left integer-16) (bound-top integer-16)
				 (bound-right integer-16) (bound-bottom integer-16))
				())

(defmethod (tv:remote-draw-triangle rpc-screen) (drawable x1 y1 x2 y2 x3 y3
							  alu fill-data plane-mask limits)
  (set-normal-graphics-state drawable tv:console alu fill-data plane-mask)
  (apply #'rpc-screen-call drawable #'rpc-screen-draw-triangle alu x1 y1 x2 y2 x3 y3 limits))

(defmethod (tv:remote-draw-point rpc-screen) (drawable x y alu fill-data plane-mask)
  (tv:remote-draw-rectangle self 1 1 drawable x y alu fill-data plane-mask))


(defmethod (tv:remote-read-point rpc-screen) (drawable x y)
  (stack-let ((image (make-array '(1 32) :type (tv:sheet-array-type self))))
    (tv:remote-get-image self boole-1 1 1 drawable x y image 0 0)
    (raster-aref image 0 0)))

(define-remote-entry rpc-screen-old-draw-glyphs rpc-console-output
  (:number 16)
  (:arguments (console-id console-id) (screen-id screen-id)
	      (alu cardinal-8) (x integer-16) (y integer-16)
	      (font cardinal-32) (bytes pascal-string))
  (:asynchronous t)
  (:c (:server #{ system_error_code = RPC_screen_draw_glyphs(console_id, screen_id,
							     alu, x, y, font, bytes, 
							     0, 0, 16384, 16384);
							     
	       if (system_error_code)return(system_error_code);
	       })))

(define-rpc-screen-output-entry rpc-screen-draw-glyphs 28
				((alu cardinal-8) (x integer-16) (y integer-16)
				 (font cardinal-32) (bytes pascal-string)
				 (bound-left integer-16) (bound-top integer-16)
				 (bound-right integer-16) (bound-bottom integer-16))
				())

;;; It's pretty important that these next manage to buffer, as it takes
;;; about five times as long to draw a line of text one glyph at a time
;;; as in a single DrawString call on the Mac for instance.
(defmethod (tv:remote-draw-glyph rpc-screen) (index font drawable x y
						    alu fill-data plane-mask limits)
  (stack-let ((string (make-array 1 :element-type 'character)))
    (setf (aref string 0) (code-char index))
    (tv:remote-draw-glyphs self string 0 1 font drawable x y alu fill-data plane-mask limits)))

;;; The default is to use Genera fonts and BITBLT.
(defmethod (:rpc-font-number si:display-device :default) (screen font)
  (ignore screen font)
  nil)

(defgeneric rpc-console-font-number (rpc-console font display-device-type)
  )

;;; For display-devices that call back to the screen, try the one-entry cache
;;; and if that fails ask the console
(defmethod (rpc-screen-font-number rpc-screen) (font)
  (if (eq cached-font-number-font font)
      cached-font-number
      (prog1 (setq cached-font-number (rpc-console-font-number tv:console font
							       tv:display-device-type))
	     (setq cached-font-number-font font))))

(defun-in-flavor (send-buffered-string rpc-screen) ()
  (set-normal-graphics-state buffered-output-drawable tv:console buffered-output-alu
			     buffered-output-fill-data buffered-output-plane-mask)
  ;; Don't use rpc-screen-call, it will try to force buffer
  (when tv:console
    (apply #'rpc-console-call tv:console #'rpc-screen-draw-glyphs
	   (rpc-drawable-screen-id buffered-output-drawable)
	   buffered-output-alu buffered-string-start-x buffered-string-y
	   buffered-string-font-number buffered-string buffered-string-limits))
  (setq buffered-string-font-number nil))

(defmethod (tv:remote-draw-glyphs rpc-screen) (string index limit font drawable x y
					       alu fill-data plane-mask limits)
  (when buffered-graphics-mode
    (send-buffered-graphics))
  (let* ((font-number (send tv:display-device-type :rpc-font-number self font))
	 (string string))
    (declare (sys:array-register string))

    (when buffered-string-font-number
      (unless (and (eql font-number buffered-string-font-number)
		   (= x buffered-string-end-x) (= y buffered-string-y)
		   (equal limits buffered-string-limits)
		   (eql drawable buffered-output-drawable)
		   (eql alu buffered-output-alu) (eql fill-data buffered-output-fill-data)
		   (eql plane-mask buffered-output-plane-mask))
	(send-buffered-string)))

    (let* ((char-width-table (sys:font-char-width-table font))
	   (char-width (sys:font-char-width font))
	   (initial-char (aref string index))
	   (subindex-is-index-p (si:%char-subindex-is-index-p initial-char))
	   )

    (when (null font-number)
      ;; Draw as images
      (let ((indexing-table (sys:font-indexing-table font))
	    (raster-width (sys:font-raster-width font))
	    (raster-height (sys:font-raster-height font))
	    )
	(destructuring-bind (cleft ctop cright cbottom) limits
	  (loop for c being the array-elements of string from index below limit
		do
	    (let* ((index (if subindex-is-index-p
			      (char-subindex c)
			      (si:%chars-share-device-font-p c initial-char nil)))
		   (rx (* index raster-width))
		   (rw raster-width))
	      (when indexing-table
		(setq rx (aref indexing-table index)
		      rw (- (aref indexing-table (1+ index)) rx)))
	      (let ((rh raster-height) (x x) (y y) (ry 0))
		(let ((lkt (sys:font-left-kern-table font)))
		  (if lkt (decf x (aref lkt index))))
		(tv:clip-for-bitblt rw rh rx ry x y cleft ctop cright cbottom)
		(when (and (plusp rh) (plusp rw))
		  (tv:remote-put-image self alu rw rh font rx ry drawable x y
				       fill-data plane-mask)))
	      (incf x (tv:compute-char-width index char-width-table char-width))))))
      (return-from tv:remote-draw-glyphs))

    (when (null buffered-string-font-number)
      (setf buffered-string-font-number font-number
	    buffered-string-start-x x
	    buffered-string-end-x x
	    buffered-string-y y
	    buffered-output-drawable drawable
	    buffered-output-alu alu
	    buffered-output-fill-data fill-data
	    buffered-output-plane-mask plane-mask
	    (fill-pointer buffered-string) 0)
      (let ((l buffered-string-limits))
	(setf (car l) (pop limits)) (pop l)
	(setf (car l) (pop limits)) (pop l)
	(setf (car l) (pop limits)) (pop l)
	(setf (car l) (pop limits))))

    ;;--- I think perhaps the caller should pass in an array of unsigned-byte 8;
    ;; wait until font translation straightened out.
      (let ((buffered-string buffered-string)
	    (buffer-index (fill-pointer buffered-string))
	    (enabled buffered-string-enabled)
	    (end-x buffered-string-end-x))
	(declare (sys:array-register buffered-string))
	(loop ;; Push as many characters as we can into the buffer
	      do (loop repeat (min (- limit index)
				   (- (array-total-size buffered-string) buffer-index))
		       as c = (aref string index)
		       as char = (if subindex-is-index-p
				     (char-subindex c)
				     (si:%chars-share-device-font-p c initial-char nil))
		       do (setf (aref buffered-string buffer-index) char)
			  (when enabled
			    (incf end-x (tv:compute-char-width char char-width-table char-width)))
			  (incf index)
			  (incf buffer-index))
	         (setf buffered-string-end-x end-x
		       (fill-pointer buffered-string) buffer-index)
	      while (< index limit)
	      ;; If not done yet, the buffer must be full, so empty it out and try again
	      do (send-buffered-string)
	         (setf buffered-string-font-number font-number
		       buffered-string-start-x end-x
		       buffer-index 0)))
    (if (not buffered-string-enabled)
	(send-buffered-string)
	(tv:remote-screen-note-pending-output self)))))

(defmethod (rpc-screen-force-output rpc-screen) ()
  (tv:with-screen-controller-lock (self)
    (when buffered-string-font-number
      (send-buffered-string))
    (when buffered-graphics-mode
      (send-buffered-graphics))))

(define-rpc-screen-output-entry rpc-screen-set-mouse-position 17
				((x integer-16) (y integer-16)) ())

(defmethod (tv:remote-warp-mouse rpc-screen) (x y)
  (tv:with-screen-controller-lock (self)
    (rpc-screen-call tv:root-drawable #'rpc-screen-set-mouse-position
		     (+ x tv:x-offset) (+ y tv:y-offset))))

;;; This isn't rpc-screen- because a special case of screen = 0 is allowed for position
;;; relative to entire host screen.
(define-rpc-screen-output-entry rpc-console-position-run-lights 19
  ((nlights integer-16)
   (width integer-16)
   (height integer-16)
   (x integer-16)
   (y integer-16)
   (dx integer-16)
   (dy integer-16))
  ())

(define-rpc-console-output-entry rpc-console-set-kbd-leds 20 ((mask integer-16)) ())

(define-rpc-screen-output-entry rpc-screen-set-graphics-compatibility-mode 21
				((genera-p boolean)) ())

(defmethod ((setf tv:screen-genera-graphics-compatibility) rpc-screen) (new-mode)
  (unless (eq genera-graphics-compatibility new-mode)
    (tv:with-screen-controller-lock (self)
      (rpc-screen-call tv:root-drawable #'rpc-screen-set-graphics-compatibility-mode new-mode))
    (setq genera-graphics-compatibility new-mode)))

(define-rpc-console-output-entry rpc-screen-set-kbd-parameters 22
				 ((local-key-code integer-16)
				  (need-key-ups boolean))
				 ())

(define-rpc-screen-output-entry rpc-screen-set-fill-parameters 29
				((fill-data integer-32)
				 (plane-mask integer-32))
				())

(define-rpc-screen-output-entry rpc-screen-query-colormap 30
				((colors-storage colormap-entries))
				((colors colormap-entries :overwrite colors-storage)))

(define-rpc-screen-output-entry rpc-screen-alter-colormap 31
				((colors colormap-entries))
				())

(define-remote-entry rpc-screen-draw-multiple-lines rpc-console-output
  (:number 32)
  (:arguments (console-id console-id)
	      (screen-id screen-id)
	      (alu cardinal-8)
	      (draw-end-point boolean)
	      (lines (vector integer-16)))
  (:asynchronous t)
  (:c
    (:server
      #{ system_error_code = RPC_screen_draw_multiple_lines (console_id,
							     screen_id,
							     alu,
							     draw_end_point,
							     (ScreenDrawMultipleArgs*)lines);
         if (system_error_code) return (system_error_code);
       } )))

(defmethod (tv:remote-draw-multiple-lines rpc-screen) (drawable lines draw-end-point
						       alu fill-data plane-mask)
  (set-normal-graphics-state drawable tv:console alu fill-data plane-mask)
  (rpc-screen-call drawable #'rpc-screen-draw-multiple-lines alu draw-end-point lines))

(define-remote-entry rpc-screen-draw-multiple-rectangles rpc-console-output
  (:number 33)
  (:arguments (console-id console-id)
	      (screen-id screen-id)
	      (alu cardinal-8)
	      (rects (vector integer-16)))
  (:asynchronous t)
  (:c
    (:server
      #{ system_error_code = RPC_screen_draw_multiple_rectangles (console_id,
								  screen_id,
								  alu,
								  (ScreenDrawMultipleArgs*)rects);
         if (system_error_code) return (system_error_code);
       } )))

(defmethod (tv:remote-draw-multiple-rectangles rpc-screen) (drawable rects
							    alu fill-data plane-mask)
  (set-normal-graphics-state drawable tv:console alu fill-data plane-mask)
  (rpc-screen-call drawable #'rpc-screen-draw-multiple-rectangles alu rects))

(defflavor rpc-who-line-screen
	()
	(tv:generic-who-line-screen-mixin
	 tv:no-change-of-default-font-mixin
	 tv:slave-screen-mixin
	 rpc-screen)
  (:default-init-plist
   :gray-array-for-unused-areas :white
   :property-list (list :video :black-and-white
			:controller :remote
			:who-line t)))

(defmethod (rpc-who-line-screen-position-run-lights rpc-who-line-screen) (on-p)
  (if on-p
      (let ((run-line-field (tv:get-who-line-field :run-line self))
	    (run-state-field (tv:get-who-line-field :run-state self)))
	(when run-line-field
	  (let ((y (send run-line-field :y-offset))
		(x (if run-state-field (send run-state-field :x-offset) 0)))
	    (rpc-screen-call tv:root-drawable #'rpc-console-position-run-lights
			     6 32 1 (- (+ x tv:x-offset) (* 6 32)) (+ y tv:y-offset 1) 64 0))))
      (rpc-screen-call tv:root-drawable #'rpc-console-position-run-lights 0 0 0 0 0 0 0)))

(defmethod (:expose rpc-who-line-screen :before) (&rest ignore)
  (setq tv:console (send tv:parent-screen :console)))

(defmethod (:expose rpc-who-line-screen :after) (&rest ignore)
  (rpc-who-line-screen-position-run-lights self t))

(defmethod (:deexpose rpc-who-line-screen :before) (&rest ignore)
  (rpc-who-line-screen-position-run-lights self nil))

;;; who-line-screen doesn't need to note pending output, because it always calls :force-output
(defmethod (tv:remote-screen-note-pending-output rpc-who-line-screen) ()
  nil)

(define-rpc-console-output-entry rpc-screen-create-off-screen-screen 26
  ((screen-id screen-id)
   (width integer-16)
   (height integer-16)
   (depth integer-16))
  ()
  :asynchronous nil)

(defflavor rpc-pixmap-correspondence
	((screen-id (new-unique-id))
	 (valid t))
	(rpc-drawable)
  (:initable-instance-variables screen-id)
  (:writable-instance-variables (rpc-pixmap-valid valid)))

(defmethod (tv:%screen-allocate-sheet-temporary-bit-array rpc-screen) (sheet width height)
  sheet
  (and tv:console
       (let ((screen-id (new-unique-id)))
	 (condition-case ()
	      (rpc-console-call tv:console #'rpc-screen-create-off-screen-screen
				screen-id width height tv:depth)
	    (rpc-error-reply nil)
	    (:no-error
	      (make-instance (rpc-console-pixmap-flavor tv:console) :screen-id screen-id))))))

(defmethod (tv:%screen-deallocate-sheet-temporary-bit-array rpc-screen) (sheet pixmap)
  sheet
  (when tv:console
    (rpc-console-call tv:console #'rpc-screen-close-screen (rpc-drawable-screen-id pixmap)))
  t)

;; Return true if this drawable seems to be okay, false if it seems to be broken.
;; The true value is :local or :remote depending on where the data reside
;; direction is :read if we care what's in it, :write if we don't.
(defmethod (tv:verify-drawable rpc-screen) (pixmap sheet direction)
  direction sheet
  (and tv:console
       (rpc-pixmap-valid pixmap)
       (condition-case ()
	    (rpc-console-call tv:console #'rpc-screen-get-image
			      (rpc-drawable-screen-id pixmap) 0 0 0 0 nil
			      #.(make-raster-array 0 0 :element-type 'bit))
	  (rpc-error-reply
	    (setf (rpc-pixmap-valid pixmap) nil)
	    nil)
	  (:no-error
	    :remote))))



(defflavor roving-rpc-bitmap () (tv:basic-remote-bitmap-screen rpc-screen))

(defmethod (:screen-allocate-bitmap-stream rpc-screen) (&rest ignore)
  (make-instance 'roving-rpc-bitmap))

(defmethod (tv:deallocate-bitmap-stream roving-rpc-bitmap) () nil)



(compile-flavor-methods rpc-screen rpc-who-line-screen rpc-pixmap-correspondence
			roving-rpc-bitmap)

#+ignore	;Don't compile this form in the normal course of events.
(define-remote-c-program rpc-console-output
  (:server (:include "<Events.h>" "<Windows.h>" "console.h")
	   (:file "cnslout")))
  
#+ignore	;Don't compile this form in the normal course of events.
(define-remote-c-program rpc-console-input
  (:client-extern (:file "cnslin")
		  (:include "<Events.h>" "<Windows.h>" "<string.h>" "console.h"))
  (:client (:include "<Events.h>" "<Windows.h>" "<string.h>" "console.h")
	   (:file "cnslin")))
