;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: RPC; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The transport layer of RPC -- code common to all transport agents


;;; Protocol for transport agents
;--- I wonder if these comments have been kept up to date

;(XDR-INITIATE-CALL agent module-number module-version entry-number argument-size)
;  agent xdr-block pointer limit
;(SEND-CALL-AND-WAIT agent xdr-block)  reply-xdr-block
;(SEND-ASYNCHRONOUS-CALL agent xdr-block)
;(XDR-INITIATE-RECEIVE agent xdr-block module)  pointer limit
;(RELEASE-XDR-BLOCK agent xdr-block)	;works for both call & reply blocks
;(XDR-INITIATE-REPLY agent transaction-id size)  xdr-block xdr-pointer xdr-limit
;(XDR-SEND-REPLY agent xdr-block)
;(XDR-INITIATE-ERROR agent call-block actual-module-version size)
;  xdr-block xdr-pointer xdr-limit
;(XDR-SEND-ERROR agent xdr-block)
;(WAIT-FOR-CALL agent)
;  block pointer limit module-number module-version entry-number transaction-id
;The arguments and values of the following are slightly different on Imach,
;because the pointer is passed implicitly in the BAR-2 register.
;(XDR-SEND-WORD-VECTOR agent vector pointer limit &optional start end)  pointer
;  .. BYTE .. CHAR .. BIT
;(XDR-RECEIVE-WORD-VECTOR agent vector pointer limit &optional start end)  pointer
;  .. BYTE .. CHAR .. BIT
;XDR-SEND-WORD, XDR-SEND-WORDS, XDR-RECEIVE-WORD

;C routines
;RPCInitiateCall(module_number, entry_number, size  agent, block, pointer, limit)
;RPCSendCallAndWait(agent  block)
;RPCSendAsynchronousCall(agent  block)
;XDRInitiateReceive(agent, block  pointer, limit)
;XDRReleaseBlock(agent, block)
;XDRInitiateReply(agent, TransactionID, size  block, pointer, limit)
;XDRSendReply(agent, block)
;XDRInitiateError(agent, call_block, actual_module_version, size  block, pointer, limit)
;XDRSendError(agent, block)
;XDRVerifyPointer(pointer, limit)
;RPCWaitForCall(agent  block, pointer, limit, 
;                       module-number, module-version, entry-number, transaction-id)
;RPCPollForCall

;;; All transport agents are built on this flavor
(DEFFLAVOR TRANSPORT-AGENT () ()
  (:REQUIRED-METHODS XDR-INITIATE-CALL SEND-CALL-AND-WAIT SEND-ASYNCHRONOUS-CALL 
		     SEND-CALL-STARTING-FUTURE WAIT-FOR-FUTURE ABORT-FUTURE
		     XDR-INITIATE-RECEIVE RELEASE-XDR-BLOCK 
		     XDR-INITIATE-REPLY XDR-SEND-REPLY
		     XDR-INITIATE-ERROR XDR-SEND-ERROR REPORT-ERROR-WHILE-EXECUTING-SERVER
		     XDR-SEND-WORD-VECTOR XDR-SEND-BYTE-VECTOR XDR-SEND-BIT-VECTOR
		     XDR-RECEIVE-WORD-VECTOR XDR-RECEIVE-BYTE-VECTOR XDR-RECEIVE-BIT-VECTOR
		     XDR-SEND-HALFWORD-VECTOR XDR-RECEIVE-HALFWORD-VECTOR
		     XDR-SEND-SIGNED-HALFWORD-VECTOR XDR-SEND-SIGNED-BYTE-VECTOR
		     XDR-RECEIVE-SIGNED-HALFWORD-VECTOR XDR-RECEIVE-SIGNED-BYTE-VECTOR
		     XDR-SEND-NIBBLE-VECTOR XDR-SEND-SINGLE-FLOAT-VECTOR
		     XDR-RECEIVE-NIBBLE-VECTOR XDR-RECEIVE-SINGLE-FLOAT-VECTOR
		     XDR-BLOCK-MESSAGE-TYPE
		     CALL-BLOCK-TRANSACTION-ID DECODE-CALL-BLOCK
		     REPLY-BLOCK-TRANSACTION-ID DECODE-REPLY-BLOCK
		     :CLOSE AGENT-RUN-REMOTE-CALL-HANDLER))

(DEFMETHOD (SYS:PRINT-SELF TRANSPORT-AGENT) (STREAM PRINT-DEPTH SLASHIFY-P)
  (IF SLASHIFY-P
      (SYS:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
	(SYS:PRINT-SELF SELF STREAM PRINT-DEPTH NIL))
    (LET ((REMOTE-HOST (REMOTE-HOST SELF)))
      (WHEN REMOTE-HOST
	(PRINC (SEND REMOTE-HOST :SHORT-NAME) STREAM)
	(WRITE-CHAR #\SPACE STREAM))
      (PRIN1 (REMOTE-SYSTEM-TYPE SELF) STREAM))))

(DEFMETHOD (EMBEDDED-AGENT-P TRANSPORT-AGENT :DEFAULT) () NIL)

(DEFMETHOD (NETWORK-AGENT-P TRANSPORT-AGENT :DEFAULT) () NIL)

(DEFMETHOD (AGENT-CONNECTED-P TRANSPORT-AGENT :DEFAULT) () T)

(DEFMETHOD (REMOTE-HOST TRANSPORT-AGENT :DEFAULT) () NIL)

(DEFMETHOD (REMOTE-SYSTEM-TYPE TRANSPORT-AGENT :DEFAULT) ()
  (LET ((HOST (REMOTE-HOST SELF)))
    (OR (AND HOST (SEND HOST :SYSTEM-TYPE))
	:UNKNOWN)))

(DEFMETHOD (MAKE-INSTANCE TRANSPORT-AGENT :AFTER) (&REST IGNORE)
  (WITHOUT-INTERRUPTS
    (PUSHNEW SELF *ALL-TRANSPORT-AGENTS*)))

(DEFMETHOD (:CLOSE TRANSPORT-AGENT :AFTER) (&OPTIONAL IGNORE)
  (WITHOUT-INTERRUPTS
    (SETQ *ALL-TRANSPORT-AGENTS* (DELETE SELF *ALL-TRANSPORT-AGENTS*))))

(DEFUN CLOSE-AGENT ()
  (CLOSE *DEFAULT-TRANSPORT-AGENT* :ABORT T)
  (VARIABLE-MAKUNBOUND *DEFAULT-TRANSPORT-AGENT*))

(DEFMETHOD (COMMENCE-SHUTDOWN TRANSPORT-AGENT) ()
  NIL)

(DEFMACRO-IN-FLAVOR (DECODE-REPLY-BLOCK-BODY TRANSPORT-AGENT) (WORD-MACRO-BODY)
  `(LET (REPLY-STATUS ACCEPT-STATUS VERIFIER-FLAVOR VERIFIER-END LOW HIGH
	 REJECT-STATUS AUTH-STATUS)
     (MACROLET ((WORD (OFFSET) ,WORD-MACRO-BODY)
		(WORD-FOLLOWING-VERIFIER (OFFSET) `(WORD (+ VERIFIER-END ,OFFSET))))
       (CASE (SETQ REPLY-STATUS (WORD 2))
	 (0 (SETQ VERIFIER-FLAVOR (WORD 3))
	    (SETQ VERIFIER-END (+ 5 (CEILING (WORD 4) 4)))
	    (CASE (SETQ ACCEPT-STATUS (WORD-FOLLOWING-VERIFIER 0))
	      (2 (SETQ LOW (WORD-FOLLOWING-VERIFIER 1))
		 (SETQ HIGH (WORD-FOLLOWING-VERIFIER 2)))))
	 (1 (CASE (SETQ REJECT-STATUS (WORD 3))
	      (0 (SETQ LOW (WORD 4))
		 (SETQ HIGH (WORD 5)))
	      (1 (SETQ AUTH-STATUS (WORD 4)))))))
     (VALUES REPLY-STATUS ACCEPT-STATUS VERIFIER-FLAVOR LOW HIGH REJECT-STATUS AUTH-STATUS)))

(DEFMETHOD (COPY-XDR-BLOCK TRANSPORT-AGENT) (BLOCK)
  (LET* ((SIZE (XDR-BLOCK-DATA-SIZE SELF BLOCK))
	 (COPY (ALLOCATE-XDR-BLOCK SELF SIZE)))
    (#+3600 %BLOCK-GC-COPY #+IMACH %BLOCK-COPY-3232
     (XDR-BLOCK-DATA-POINTER SELF BLOCK)
     (XDR-BLOCK-DATA-POINTER SELF COPY)
     SIZE)
    COPY))

(DEFUN CLOSE-ALL-NETWORK-TRANSPORT-AGENTS ()
  (DOLIST (AGENT *ALL-TRANSPORT-AGENTS*)
    (WHEN (NETWORK-AGENT-P AGENT)
      (CLOSE AGENT :ABORT T))))

(ADD-INITIALIZATION "Close All Network Transport Agents" '(CLOSE-ALL-NETWORK-TRANSPORT-AGENTS)
		    () 'NETI:AFTER-NETWORK-INITIALIZATION-LIST)

(DEFUN SHUTDOWN-RPC (&OPTIONAL DELAY)
  (SETQ *OLD-TRANSPORT-AGENTS* NIL)
  (DOLIST (AGENT *ALL-TRANSPORT-AGENTS*)
    (COMMENCE-SHUTDOWN AGENT)
    (IF DELAY
	(PUSHNEW AGENT *OLD-TRANSPORT-AGENTS*)
	(CLOSE AGENT :ABORT T)))
  (SETQ *ALL-TRANSPORT-AGENTS* NIL)
  (VARIABLE-MAKUNBOUND *DEFAULT-TRANSPORT-AGENT*))

(DEFUN SHUTDOWN-RPC-2 ()
  (DOLIST (AGENT *OLD-TRANSPORT-AGENTS*)
    (CLOSE AGENT :ABORT T))
  (SETQ *OLD-TRANSPORT-AGENTS* NIL))

(ADD-INITIALIZATION "Shutdown RPC" '(SHUTDOWN-RPC) NIL 'SI:SYSTEM-SHUTDOWN-INITIALIZATION-LIST)

;For warm boot, do the first part right after turning on processes
;and finally close down the old agents after the window system is done with them
(ADD-INITIALIZATION "Shutdown RPC" '(SHUTDOWN-RPC T) '(:SYSTEM :NORMAL))
(ADD-INITIALIZATION "Shutdown RPC, part 2" '(SHUTDOWN-RPC-2) '(:SYSTEM :NORMAL))
(LET ((ELEM (ASSOC "Shutdown RPC" SI:SYSTEM-INITIALIZATION-LIST :TEST #'EQUAL)))
  (SETF SI:SYSTEM-INITIALIZATION-LIST (CONS ELEM (DELETE ELEM SI:SYSTEM-INITIALIZATION-LIST))))
(LET ((ELEM (ASSOC "Shutdown RPC, part 2" SI:SYSTEM-INITIALIZATION-LIST :TEST #'EQUAL))
      (WHERE (MEMBER "Window Initialize" SI:SYSTEM-INITIALIZATION-LIST :TEST #'EQUAL :KEY #'CAR)))
  (SETF (CDR WHERE) (CONS ELEM (DELETE ELEM (CDR WHERE)))))

;;; This mixin supplies a process to dispatch input received from the other end
(DEFFLAVOR SERVER-PROCESS-MIXIN ((PROCESS NIL)) ()
  (:REQUIRED-FLAVORS TRANSPORT-AGENT)
  (:INIT-KEYWORDS :PROCESS)
  (:DEFAULT-INIT-PLIST :PROCESS T))		;default is to create a dispatch process

(DEFVAR *INSIDE-RPC-DISPATCH-PROCESS* NIL)

(DEFMETHOD (MAKE-INSTANCE SERVER-PROCESS-MIXIN :AFTER) (&KEY ((:PROCESS A-PROCESS))
							&ALLOW-OTHER-KEYS)
  ;; Start a process to dispatch replies
  (SETQ PROCESS (AND A-PROCESS
		     (PROCESS:PROCESS-RUN-FUNCTION
		       `(:NAME ,(RPC-DISPATCH-PROCESS-NAME SELF)
			 :PRIORITY ,(RPC-DISPATCH-PROCESS-PRIORITY SELF)
			 :SYSTEM-PROCESS T
			 :FLAGS ,(RPC-DISPATCH-PROCESS-FLAGS SELF))
		       #'(LAMBDA (AGENT)
			   (UNWIND-PROTECT
			       (LET ((*INSIDE-RPC-DISPATCH-PROCESS* T))
				 (SERVER-TOP-LEVEL AGENT))
			     (PROCESS-GONE AGENT)))
		       SELF)))
  PROCESS)

(DEFMETHOD (RPC-DISPATCH-PROCESS-NAME SERVER-PROCESS-MIXIN :DEFAULT) ()
  (FORMAT NIL "RPC dispatch~@[ (~A)~]" (REMOTE-HOST SELF)))

(DEFMETHOD (RPC-DISPATCH-PROCESS-PRIORITY SERVER-PROCESS-MIXIN :DEFAULT) ()
  (PROCESS:MAKE-PROCESS-PRIORITY :FG 6 :PREEMPTIVE T))

(DEFMETHOD (RPC-DISPATCH-PROCESS-FLAGS SERVER-PROCESS-MIXIN :DEFAULT) ()
  NIL)

(DEFMETHOD (PROCESS-GONE SERVER-PROCESS-MIXIN) ()
  (SETQ PROCESS NIL))

(DEFMETHOD (:CLOSE SERVER-PROCESS-MIXIN :BEFORE) (&OPTIONAL ABORT-P)
  (IGNORE ABORT-P)
  (WHEN PROCESS
    (PROCESS-RESET PROCESS)
    ;; Process keeps running for a while, at least in new scheduler
    ;; and if we close the agent while it's still running, our ass is grass
    (PROCESS-WAIT "Process Wake"
      (LAMBDA () (WITHOUT-INTERRUPTS
		   (OR (NULL PROCESS)
		       (NULL (PROCESS:PROCESS-RUN-REASONS PROCESS))))))))

;;; Methods for agents that use Lisp arrays to implement XDR blocks
;;; Incldues a resource of XDR blocks and related support for futures and call-retrying

(DEFVAR ARRAY-XDR-BLOCK-AREA (MAKE-AREA :NAME 'ARRAY-XDR-BLOCK-AREA :GC :STATIC))

(DEFSTRUCT (ARRAY-XDR-BLOCK
	     (:TYPE :NAMED-ARRAY-LEADER)
	     :SIZE-SYMBOL
	     (:PRINT-FUNCTION PRINT-ARRAY-XDR-BLOCK)
	     (:CONSTRUCTOR-MAKE-ARRAY-KEYWORDS LENGTH)
	     (:COPIER NIL)
	     (:MAKE-ARRAY (:TYPE 'SYS:ART-FIXNUM :AREA ARRAY-XDR-BLOCK-AREA)))
  DATA-SIZE					;Also FILL-POINTER
  AGENT
  MODULE-NUMBER
  MODULE-VERSION
  ENTRY-NUMBER
  RESOURCE-DESCRIPTOR)

(DEFUN PRINT-ARRAY-XDR-BLOCK (ARRAY-XDR-BLOCK STREAM I-PRINDEPTH)
  (DECLARE (IGNORE I-PRINDEPTH))
  (PRINTING-RANDOM-OBJECT (ARRAY-XDR-BLOCK STREAM :TYPEP)
    (CONDITION-CASE (ERROR)
	 (LET ((AGENT (ARRAY-XDR-BLOCK-AGENT ARRAY-XDR-BLOCK)))
	   (PRIN1 (ARRAY-TOTAL-SIZE ARRAY-XDR-BLOCK) STREAM)
	   (WHEN (AND AGENT
		      (NOT (ZEROP (ARRAY-XDR-BLOCK-DATA-SIZE ARRAY-XDR-BLOCK)))
		      (VARIABLE-BOUNDP #'PRINT-XDR-BLOCK))
	     (WRITE-CHAR #\SPACE STREAM)
	     (PRINT-XDR-BLOCK
	       ARRAY-XDR-BLOCK AGENT STREAM
	       (ARRAY-XDR-BLOCK-MODULE-NUMBER ARRAY-XDR-BLOCK)
	       (ARRAY-XDR-BLOCK-MODULE-VERSION ARRAY-XDR-BLOCK)
	       (ARRAY-XDR-BLOCK-ENTRY-NUMBER ARRAY-XDR-BLOCK))))
       (ERROR
	 (WRITE-CHAR #\! STREAM)
	 (PRIN1 (TYPE-OF ERROR) STREAM)))))

(DEFRESOURCE ARRAY-XDR-BLOCK (DATA-SIZE AGENT)
  :CONSTRUCTOR (MAKE-ARRAY-XDR-BLOCK :LENGTH (ASH 1 (INTEGER-LENGTH DATA-SIZE)))
  :INITIALIZER (PROGN (SETF (ARRAY-XDR-BLOCK-DATA-SIZE OBJECT) DATA-SIZE)
		      (SETF (ARRAY-XDR-BLOCK-AGENT OBJECT) AGENT))
  :DEINITIALIZER (PROGN (SETF (ARRAY-XDR-BLOCK-DATA-SIZE OBJECT) 0)
			(SETF (ARRAY-XDR-BLOCK-AGENT OBJECT) NIL)
			(SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER OBJECT) NIL)
			(SETF (ARRAY-XDR-BLOCK-MODULE-VERSION OBJECT) NIL)
			(SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER OBJECT) NIL)
			(SETF (ARRAY-XDR-BLOCK-RESOURCE-DESCRIPTOR OBJECT) NIL))
  :MATCHER (LET ((ARRAY-SIZE (ARRAY-TOTAL-SIZE OBJECT)))
	     (AND (< DATA-SIZE ARRAY-SIZE)
		  ( (+ DATA-SIZE DATA-SIZE) ARRAY-SIZE)))
  :FREE-LIST-SIZE 128)

(DEFFLAVOR ARRAYS-FOR-XDR-BLOCKS ((ARRAY-SERVER-INFO NIL)) ()
  (:REQUIRED-FLAVORS TRANSPORT-AGENT))

;; This is a debugging kludge, so we detect garbage lengths sent by the other end by
;; going into the debugger with a failed assertion instead of running out of address space
(DEFPARAMETER MAXIMUM-VALID-XDR-BLOCK-SIZE 1_19)

(DEFMETHOD (ALLOCATE-XDR-BLOCK ARRAYS-FOR-XDR-BLOCKS) (SIZE)
  (ASSERT (< SIZE MAXIMUM-VALID-XDR-BLOCK-SIZE))	;Other end might send a garbage length
  (MULTIPLE-VALUE-BIND (ARRAY RESOURCE-DESCRIPTOR)
      (ALLOCATE-RESOURCE 'ARRAY-XDR-BLOCK SIZE SELF)
    (SETF (ARRAY-XDR-BLOCK-RESOURCE-DESCRIPTOR ARRAY) RESOURCE-DESCRIPTOR)
    ARRAY))

(DEFMETHOD (STACK-ALLOCATE-XDR-BLOCK ARRAYS-FOR-XDR-BLOCKS) (SIZE)
  (ASSERT (< SIZE MAXIMUM-VALID-XDR-BLOCK-SIZE))	;Other end might send a garbage length
  (LET ((ARRAY (MAKE-STACK-ARRAY (1+ SIZE)
				 :ELEMENT-TYPE 'FIXNUM
				 :LEADER-LENGTH ARRAY-XDR-BLOCK-SIZE
				 :FILL-POINTER SIZE	;Also ARRAY-XDR-BLOCK-DATA-SIZE
				 :NAMED-STRUCTURE-SYMBOL 'ARRAY-XDR-BLOCK)))
    (SETF (ARRAY-XDR-BLOCK-AGENT ARRAY) SELF)
    ARRAY))

(DEFMETHOD (RELEASE-XDR-BLOCK ARRAYS-FOR-XDR-BLOCKS) (BLOCK)
  (LET ((RESOURCE-DESCRIPTOR (ARRAY-XDR-BLOCK-RESOURCE-DESCRIPTOR BLOCK)))
    (WHEN RESOURCE-DESCRIPTOR
      (DEALLOCATE-RESOURCE 'ARRAY-XDR-BLOCK BLOCK RESOURCE-DESCRIPTOR)))
  NIL)

(DEFMETHOD (XDR-BLOCK-DATA-POINTER ARRAYS-FOR-XDR-BLOCKS) (BLOCK)
  ;; (LOCF (AREF BLOCK 0)) doesn't work for FIXNUM arrays
  (%MAKE-POINTER-OFFSET DTP-LOCATIVE BLOCK (SI:ARRAY-DATA-OFFSET BLOCK)))

(DEFWHOPPER (COPY-XDR-BLOCK ARRAYS-FOR-XDR-BLOCKS) (BLOCK)
  (LET ((COPY (CONTINUE-WHOPPER BLOCK)))
    (SETF (ARRAY-XDR-BLOCK-AGENT COPY) (ARRAY-XDR-BLOCK-AGENT BLOCK))
    (SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER COPY) (ARRAY-XDR-BLOCK-MODULE-NUMBER BLOCK))
    (SETF (ARRAY-XDR-BLOCK-MODULE-VERSION COPY) (ARRAY-XDR-BLOCK-MODULE-VERSION BLOCK))
    (SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER COPY) (ARRAY-XDR-BLOCK-ENTRY-NUMBER BLOCK))
    COPY))

(DEFMETHOD (XDR-BLOCK-DATA-SIZE ARRAYS-FOR-XDR-BLOCKS) (BLOCK)
  (ARRAY-XDR-BLOCK-DATA-SIZE BLOCK))

;;; CALL-BLOCK-TRANSACTION-ID is supplied by a more specific flavor,
;;; since it depends on the RPC protocol and on the byte swapping fashion

(DEFSTRUCT ARRAYS-FOR-XDR-BLOCKS-FUTURE
  FUTURE
  MODULE-NUMBER
  MODULE-VERSION
  ENTRY-NUMBER)

;;; Save the module number, version and entry number for later.
(DEFWHOPPER (SEND-CALL-STARTING-FUTURE ARRAYS-FOR-XDR-BLOCKS) (BLOCK &OPTIONAL DONT-RELEASE)
  (MULTIPLE-VALUE-BIND (IGNORE MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER)
      (DECODE-CALL-BLOCK SELF BLOCK)
    (MAKE-ARRAYS-FOR-XDR-BLOCKS-FUTURE
      :FUTURE (CONTINUE-WHOPPER BLOCK DONT-RELEASE)
      :MODULE-NUMBER MODULE-NUMBER
      :MODULE-VERSION MODULE-VERSION
      :ENTRY-NUMBER ENTRY-NUMBER)))

;;; Stash the saved module number, version and entry number onto the reply so
;;; it can be self-identifying (for printing, tracing, etc.)
(DEFWHOPPER (WAIT-FOR-FUTURE ARRAYS-FOR-XDR-BLOCKS) (FUTURE &OPTIONAL WHOSTATE)
  (LET ((REPLY (CONTINUE-WHOPPER (ARRAYS-FOR-XDR-BLOCKS-FUTURE-FUTURE FUTURE) WHOSTATE)))
    (WHEN REPLY 
      (SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER REPLY)
	    (ARRAYS-FOR-XDR-BLOCKS-FUTURE-MODULE-NUMBER FUTURE))
      (SETF (ARRAY-XDR-BLOCK-MODULE-VERSION REPLY)
	    (ARRAYS-FOR-XDR-BLOCKS-FUTURE-MODULE-VERSION FUTURE))
      (SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER REPLY)
	    (ARRAYS-FOR-XDR-BLOCKS-FUTURE-ENTRY-NUMBER FUTURE)))
    REPLY))

;;; Don't forget that we've hacked the future.
(DEFWHOPPER (ABORT-FUTURE ARRAYS-FOR-XDR-BLOCKS) (FUTURE)
  (CONTINUE-WHOPPER (ARRAYS-FOR-XDR-BLOCKS-FUTURE-FUTURE FUTURE)))

;;; Stash the module number, version and entry number into the reply so it can
;;; be self-identifying (for printing, tracing, etc.)
(DEFWHOPPER (SEND-CALL-AND-WAIT ARRAYS-FOR-XDR-BLOCKS)
	    (BLOCK &OPTIONAL WHOSTATE DONT-RELEASE)
  (MULTIPLE-VALUE-BIND (IGNORE MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER)
      (DECODE-CALL-BLOCK SELF BLOCK)
    (LET ((REPLY (CONTINUE-WHOPPER BLOCK WHOSTATE DONT-RELEASE)))
      (WHEN REPLY 
	(SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER REPLY) MODULE-NUMBER)
	(SETF (ARRAY-XDR-BLOCK-MODULE-VERSION REPLY) MODULE-VERSION)
	(SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER REPLY) ENTRY-NUMBER))
      REPLY)))

;;; Save the module number, version and entry number so that it can be stashed into the reply
(DEFWHOPPER (AGENT-RUN-REMOTE-CALL-HANDLER ARRAYS-FOR-XDR-BLOCKS)
	    (HANDLER TRANSACTION-ID XDR-BLOCK XDR-POINTER XDR-LIMIT
		     MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
		     CREDENTIAL VERIFIER CREDENTIAL-APPROVED)
  (WITH-STACK-LIST (INFO TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER)
    (LETF ((ARRAY-SERVER-INFO INFO))
      (CONTINUE-WHOPPER HANDLER TRANSACTION-ID XDR-BLOCK XDR-POINTER XDR-LIMIT
			MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
			CREDENTIAL VERIFIER CREDENTIAL-APPROVED))))

;;; Stash the saved module number, version and entry number into the reply
(DEFWHOPPER (XDR-INITIATE-REPLY ARRAYS-FOR-XDR-BLOCKS)
	    (TRANSACTION-ID VALUES-SIZE &OPTIONAL VERIFIER DONT-STACK-ALLOCATE)
  (MULTIPLE-VALUE-BIND (XDR-BLOCK XDR-POINTER XDR-LIMIT)
      (CONTINUE-WHOPPER TRANSACTION-ID VALUES-SIZE VERIFIER DONT-STACK-ALLOCATE)
    (WHEN ARRAY-SERVER-INFO
      (DESTRUCTURING-BIND
	(CALL-TRANSACTION-ID CALL-MODULE-NUMBER CALL-MODULE-VERSION CALL-ENTRY-NUMBER)
	  ARRAY-SERVER-INFO
	(WHEN (EQL TRANSACTION-ID CALL-TRANSACTION-ID)
	  (SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER XDR-BLOCK) CALL-MODULE-NUMBER)
	  (SETF (ARRAY-XDR-BLOCK-MODULE-VERSION XDR-BLOCK) CALL-MODULE-VERSION)
	  (SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER XDR-BLOCK) CALL-ENTRY-NUMBER))))
    (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT)))

;;; Stash the saved module number, version and entry number into the reply
(DEFWHOPPER (XDR-INITIATE-ERROR-INTERNAL ARRAYS-FOR-XDR-BLOCKS)
	    (TRANSACTION-ID ACCEPT-STATUS LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION
			    MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
			    ACTUAL-MODULE-VERSION ERROR-NUMBER ARGUMENTS-SIZE
			    VERIFIER DONT-STACK-ALLOCATE)
  (MULTIPLE-VALUE-BIND (XDR-BLOCK XDR-POINTER XDR-LIMIT)
      (CONTINUE-WHOPPER 
	TRANSACTION-ID ACCEPT-STATUS LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION
	MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
	ACTUAL-MODULE-VERSION ERROR-NUMBER ARGUMENTS-SIZE
	VERIFIER DONT-STACK-ALLOCATE)
    (WHEN ARRAY-SERVER-INFO
      (DESTRUCTURING-BIND
	(CALL-TRANSACTION-ID CALL-MODULE-NUMBER CALL-MODULE-VERSION CALL-ENTRY-NUMBER)
	  ARRAY-SERVER-INFO
	(WHEN (EQL TRANSACTION-ID CALL-TRANSACTION-ID)
	  (SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER XDR-BLOCK) CALL-MODULE-NUMBER)
	  (SETF (ARRAY-XDR-BLOCK-MODULE-VERSION XDR-BLOCK) CALL-MODULE-VERSION)
	  (SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER XDR-BLOCK) CALL-ENTRY-NUMBER))))
    (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT)))

;;; Stash the saved module number, version and entry number into the reply
(DEFWHOPPER (XDR-INITIATE-AUTH-ERROR ARRAYS-FOR-XDR-BLOCKS)
	    (TRANSACTION-ID AUTH-STAT ARGUMENTS-SIZE &OPTIONAL DONT-STACK-ALLOCATE)
  (MULTIPLE-VALUE-BIND (XDR-BLOCK XDR-POINTER XDR-LIMIT)
      (CONTINUE-WHOPPER TRANSACTION-ID AUTH-STAT ARGUMENTS-SIZE DONT-STACK-ALLOCATE)
    (DECLARE (SPECIAL ARRAYS-FOR-XDR-BLOCKS-SERVER-INFO))
    (WHEN ARRAY-SERVER-INFO
      (DESTRUCTURING-BIND
	(CALL-TRANSACTION-ID CALL-MODULE-NUMBER CALL-MODULE-VERSION CALL-ENTRY-NUMBER)
	  ARRAY-SERVER-INFO
	(WHEN (EQL TRANSACTION-ID CALL-TRANSACTION-ID)
	  (SETF (ARRAY-XDR-BLOCK-MODULE-NUMBER XDR-BLOCK) CALL-MODULE-NUMBER)
	  (SETF (ARRAY-XDR-BLOCK-MODULE-VERSION XDR-BLOCK) CALL-MODULE-VERSION)
	  (SETF (ARRAY-XDR-BLOCK-ENTRY-NUMBER XDR-BLOCK) CALL-ENTRY-NUMBER))))
    (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT)))

(DEFFLAVOR CALL-RETRYING-MIXIN () ()
  (:REQUIRED-FLAVORS TRANSPORT-AGENT))

(DEFFLAVOR RETRY-CALL (AGENT TRANSACTION-ID) (CONDITION)
  (:INITABLE-INSTANCE-VARIABLES AGENT TRANSACTION-ID)
  (:READABLE-INSTANCE-VARIABLES AGENT TRANSACTION-ID))

(DEFMETHOD (DBG:REPORT RETRY-CALL) (STREAM)
  (FORMAT STREAM "Retry RPC Call ~D" TRANSACTION-ID))

(COMPILE-FLAVOR-METHODS RETRY-CALL)

(DEFSTRUCT CALL-RETRYING-FUTURE
  FUTURE
  CALL-BLOCK)

;;; Don't stack-allocate xdr blocks when starting future calls since we're
;;; gonna put the block in the future object for possible later retrying.
(DEFWHOPPER (XDR-INITIATE-CALL CALL-RETRYING-MIXIN) 
	    (MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER ARGUMENT-SIZE
			   &OPTIONAL CREDENTIAL VERIFIER FOR-FUTURE DONT-STACK-ALLOCATE)
  (CONTINUE-WHOPPER MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER ARGUMENT-SIZE
		    CREDENTIAL VERIFIER FOR-FUTURE (OR FOR-FUTURE DONT-STACK-ALLOCATE)))

(DEFWHOPPER (SEND-CALL-STARTING-FUTURE CALL-RETRYING-MIXIN) (BLOCK &OPTIONAL DONT-RELEASE)
  (UNWIND-PROTECT 
      (MAKE-CALL-RETRYING-FUTURE
	:FUTURE (BLOCK MAKE-FUTURE
		  (TAGBODY
		    RETRY
		       (CONDITION-BIND
			 ((RETRY-CALL
			    #'(LAMBDA (COND)
				(WHEN (AND (EQ SELF (RETRY-CALL-AGENT COND))
					   (OR (NULL (RETRY-CALL-TRANSACTION-ID COND))
					       (EQL (CALL-BLOCK-TRANSACTION-ID SELF BLOCK)
						    (RETRY-CALL-TRANSACTION-ID COND))))
				  (GO RETRY)))))
			 (RETURN-FROM MAKE-FUTURE
			   (CONTINUE-WHOPPER BLOCK T)))))
	:CALL-BLOCK (IF DONT-RELEASE
			(COPY-XDR-BLOCK SELF BLOCK)
		      (PROG1 BLOCK (SETQ BLOCK NIL))))
    (UNLESS DONT-RELEASE
      (WHEN BLOCK (RELEASE-XDR-BLOCK SELF BLOCK)))))

(DEFWHOPPER (WAIT-FOR-FUTURE CALL-RETRYING-MIXIN) (FUTURE &OPTIONAL WHOSTATE)
  (UNWIND-PROTECT 
      (TAGBODY
	START
	   (CONDITION-BIND
	     ((RETRY-CALL
		#'(LAMBDA (COND)
		    (WHEN (AND (EQ SELF (RETRY-CALL-AGENT COND))
			       (OR (NULL (RETRY-CALL-TRANSACTION-ID COND))
				   (EQL (CALL-BLOCK-TRANSACTION-ID
					  SELF (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE))
					(RETRY-CALL-TRANSACTION-ID COND))))
		      (GO RETRY)))))
	     (LET ((RESTARTING NIL))
	       (ERROR-RESTART (RPC-ERROR "Retry ~A" (OR WHOSTATE "Remote Call"))
		 (IF RESTARTING (GO RETRY) (SETQ RESTARTING T))
		 (RETURN-FROM WAIT-FOR-FUTURE
		   (CONTINUE-WHOPPER (CALL-RETRYING-FUTURE-FUTURE FUTURE) WHOSTATE)))))
	RETRY
	   (RETURN-FROM WAIT-FOR-FUTURE
	     (SEND-CALL-AND-WAIT SELF (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE) WHOSTATE T)))
    (RELEASE-XDR-BLOCK
      SELF (PROG1 (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE)
		  (SETF (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE) NIL)))))

(DEFWHOPPER (ABORT-FUTURE CALL-RETRYING-MIXIN) (FUTURE)
  (UNWIND-PROTECT
      (CONTINUE-WHOPPER (CALL-RETRYING-FUTURE-FUTURE FUTURE))
    (WHEN (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE)
      (RELEASE-XDR-BLOCK
	SELF (PROG1 (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE)
		    (SETF (CALL-RETRYING-FUTURE-CALL-BLOCK FUTURE) NIL))))))

(DEFWHOPPER (SEND-CALL-AND-WAIT CALL-RETRYING-MIXIN)
	    (BLOCK &OPTIONAL WHOSTATE DONT-RELEASE)
  (LET ((TRANSACTION-ID (CALL-BLOCK-TRANSACTION-ID SELF BLOCK)))
    (UNWIND-PROTECT 
	(TAGBODY
	  RETRY
	     (CONDITION-BIND
	       ((RETRY-CALL
		  #'(LAMBDA (COND)
		      (WHEN (AND (EQ SELF (RETRY-CALL-AGENT COND))
				 (OR (NULL (RETRY-CALL-TRANSACTION-ID COND))
				     (EQL TRANSACTION-ID
					  (RETRY-CALL-TRANSACTION-ID COND))))
			(GO RETRY)))))
	       (ERROR-RESTART (RPC-ERROR "Retry ~A" (OR WHOSTATE "Remote Call"))
		 (RETURN-FROM SEND-CALL-AND-WAIT
		   (CONTINUE-WHOPPER BLOCK WHOSTATE T)))))
      (UNLESS DONT-RELEASE (RELEASE-XDR-BLOCK SELF BLOCK)))))

(DEFWHOPPER (SEND-ASYNCHRONOUS-CALL CALL-RETRYING-MIXIN)
	    (BLOCK &OPTIONAL DONT-RELEASE)
  (LET ((TRANSACTION-ID (CALL-BLOCK-TRANSACTION-ID SELF BLOCK)))
    (UNWIND-PROTECT 
	(TAGBODY
	  RETRY
	     (CONDITION-BIND
	       ((RETRY-CALL
		  #'(LAMBDA (COND)
		      (WHEN (AND (EQ SELF (RETRY-CALL-AGENT COND))
				 (OR (NULL (RETRY-CALL-TRANSACTION-ID COND))
				     (EQL TRANSACTION-ID
					  (RETRY-CALL-TRANSACTION-ID COND))))
			(GO RETRY)))))
	       (ERROR-RESTART (RPC-ERROR "Retry Remote Call")
		 (RETURN-FROM SEND-ASYNCHRONOUS-CALL
		   (CONTINUE-WHOPPER BLOCK T)))))
      (UNLESS DONT-RELEASE (RELEASE-XDR-BLOCK SELF BLOCK)))))


;;;; Substrate for sending and receiving vectors in XDR format (big and little ender)

;;; Copy the indicated portion of a vector to the current XDR block.  SHUFFLE can be one of
;;; :BIT, :NIBBLE, :BYTE, or :HALFWORD, and specifies that the data be shuffled accordingly
;;; (see notes below).  COERCION can be an arbitrary function, but is usually %FIXNUM or
;;; %FLONUM.  SHUFFLE and COERCION are applied to every word, after it is aligned with the
;;; XDR block; this is done in software in macroexpanded code.  Those cases are reasonably
;;; fast, but when no transformations are specified the copying is done by a very fast direct
;;; copy of the Lisp machine representation.
(DEFMACRO XDR-SEND-VECTOR
	  (VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END &OPTIONAL SHUFFLE COERCION)
  (IF (AND (NULL SHUFFLE) (NULL COERCION))
      `(%XDR-SIMPLE-SEND-VECTOR ,VECTOR #-IMACH ,XDR-POINTER ,XDR-LIMIT ,START ,END)
    `(%XDR-GENERAL-SEND-VECTOR ,VECTOR #-IMACH XDR-POINTER XDR-LIMIT ,START ,END
			       ,SHUFFLE ,COERCION)))

;;; Copy some of the current XDR block to the indicated portion of a vector.  SHUFFLE can be
;;; one of :BIT, :NIBBLE, :BYTE, or :HALFWORD, and specifies that the data be shuffled
;;; accordingly (see notes below).  COERCION can be an arbitrary function, but is usually
;;; %FIXNUM or %FLONUM.  SHUFFLE is applied to every word read from the XDR block, before
;;; aligning it with the vector.  COERCION is applied after alignment.  Those cases are
;;; reasonably fast, but when no transformations are specified the copying is done by a very
;;; fast direct copy of the Lisp machine representation.
(DEFMACRO XDR-RECEIVE-VECTOR
	  (VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END &OPTIONAL SHUFFLE COERCION)
  (IF (AND (NULL SHUFFLE) (NULL COERCION))
      `(%XDR-SIMPLE-RECEIVE-VECTOR ,VECTOR #-IMACH ,XDR-POINTER ,XDR-LIMIT ,START ,END)
    `(%XDR-GENERAL-RECEIVE-VECTOR ,VECTOR #-IMACH XDR-POINTER XDR-LIMIT ,START ,END
				  ,SHUFFLE ,COERCION)))

;;; These swapping primitives are designed to swap the elements of vectors appropriately for
;;; transmission to big-ender hosts.  Note that LispMs store array elements with increasing
;;; elements stored in more significant bits within a (little-ender) 32-bit word.  Note also
;;; that the LispM network system transmits the low-order bytes of a word first.  Therefore,
;;; the internal representation of an 8-bit array will be transmitted in order of increasing
;;; indices without any swapping.  Other size arrays work fine for little-ender targets, but
;;; need some swapping for big-ender targets.  You have to take the implicit byte-swap into
;;; account, though: in a 16-bit array, transmitting the internal representation would cause
;;; the elements to arrive in increasing order, but with the least-significant bytes first.
;;; So we have to swap bytes within elements.  For arrays with <8 bits per element, the bytes
;;; arrive in the right order, but the array portions within them are in the wrong order, so
;;; we have to swap elements within each byte.  Got it?

;;; Swap the bytes within each halfword.
(DEFSUBST %XDR-HALFWORD-SWAP (WORD)
  (%LOGDPBS (LDB (BYTE 8 0) WORD) (BYTE 8 8)
	    (LDB (BYTE 8 8) WORD) (BYTE 8 0)
	    (LDB (BYTE 8 16) WORD) (BYTE 8 24)
	    (LDB (BYTE 8 24) WORD) (BYTE 8 16)
	    0))

(DEFSUBST BYTE-SWAP (WORD)
  (%LOGDPB (LDB (BYTE 8 0) WORD) (BYTE 8 24)
	   (%LOGDPB (LDB (BYTE 8 8) WORD) (BYTE 8 16)
		    (%LOGDPB (LDB (BYTE 8 16) WORD) (BYTE 8 8)
			     (LDB (BYTE 8 24) WORD)))))

;;; This is a pure byte swap, used to swap 32-bit data.
(DEFSUBST %XDR-BYTE-SWAP (WORD) (BYTE-SWAP WORD))

;;; Swap the nibbles within each byte.
(DEFSUBST %XDR-NIBBLE-SWAP (WORD)
  (%LOGDPBS (LDB (BYTE 4 0) WORD) (BYTE 4 4)
	    (LDB (BYTE 4 4) WORD) (BYTE 4 0)
	    (LDB (BYTE 4 8) WORD) (BYTE 4 12)
	    (LDB (BYTE 4 12) WORD) (BYTE 4 8)
	    (LDB (BYTE 4 16) WORD) (BYTE 4 20)
	    (LDB (BYTE 4 20) WORD) (BYTE 4 16)
	    (LDB (BYTE 4 24) WORD) (BYTE 4 28)
	    (LDB (BYTE 4 28) WORD) (BYTE 4 24)
	    0))

;;; Swap the bits within each byte.
(DEFSUBST %XDR-BIT-SWAP (WORD)
  (LET ((TABLE #.(COERCE
		   (LOOP FOR I BELOW 256
			 COLLECT (%LOGDPB (LDB (BYTE 1 0) I) (BYTE 1 7)
				   (%LOGDPB (LDB (BYTE 1 1) I) (BYTE 1 6)
				     (%LOGDPB (LDB (BYTE 1 2) I) (BYTE 1 5)
				       (%LOGDPB (LDB (BYTE 1 3) I) (BYTE 1 4)
					 (%LOGDPB (LDB (BYTE 1 4) I) (BYTE 1 3)
					   (%LOGDPB (LDB (BYTE 1 5) I) (BYTE 1 2)
					     (%LOGDPB (LDB (BYTE 1 6) I) (BYTE 1 1)
						      (LDB (BYTE 1 7) I)))))))))
		   '(VECTOR (UNSIGNED-BYTE 8)))))
    (DECLARE (SYS:ARRAY-REGISTER TABLE))
    ;; AREFs clobber ALUF; preserve it
    (LET (#+IMach (ALUF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL)))
      (PROG1
	(%LOGDPBS (AREF TABLE (LDB (BYTE 8 24) WORD)) (BYTE 8 24)
		  (AREF TABLE (LDB (BYTE 8 16) WORD)) (BYTE 8 16)
		  (AREF TABLE (LDB (BYTE 8 8) WORD)) (BYTE 8 8)
		  (AREF TABLE (LDB (BYTE 8 0) WORD)))
	#+IMach (%WRITE-INTERNAL-REGISTER ALUF %REGISTER-ALU-AND-ROTATE-CONTROL)))))

#+IMACH
;;; Copy the specified portion of a given vector to the XDR block at XDR-POINTER.
(DEFUN %XDR-SIMPLE-SEND-VECTOR (VECTOR XDR-LIMIT START END)
  (WHEN ( START END)
    (MULTIPLE-VALUE-BIND (S-ARRAY S-CONTROL S-ADDRESS S-BOUND)
	(SETUP-1D-ARRAY VECTOR)
      (DECLARE (IGNORE S-ARRAY S-BOUND))
      (LET* ((ELEMENTS (- END START))
	     (SHIFT (- 5 (LDB ARRAY-REGISTER-BYTE-PACKING S-CONTROL)))
	     (BITS (ROT ELEMENTS SHIFT))
	     (OFFSET (ROT (+ (LDB ARRAY-REGISTER-BYTE-OFFSET S-CONTROL) START) SHIFT)))
	(VERIFY-XDR-POINTER-BELOW-LIMIT (%FIXNUM-CEILING BITS 32) T)
	;; BAR 1 points to source array, BAR 2 already points to XDR block
	(SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS S-ADDRESS (%FIXNUM-FLOOR OFFSET 32)))
	(LET ((OFFSET (%FIXNUM-MOD OFFSET 32.)))
	  ;; Set up the rotate control.
	  (SET-ALU-AND-ROTATE-CONTROL :BYTE-R (- OFFSET) :BYTE-S (1- OFFSET))
	  ;; Might need an extra word of source for the first destination word
	  (WHEN ( OFFSET 0)
	    (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
	  ;; Copy all the complete words, in 8-word chunks at first
	  (LET ((WORDS (%FIXNUM-FLOOR BITS 32.)))
	    (DOTIMES (IGNORE (%FIXNUM-FLOOR WORDS 8))
	      (LET ((W0 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W1 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W2 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W3 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W4 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W5 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W6 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))
		    (W7 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T :PREFETCH NIL)))
		(%BLOCK-WRITE 2 W0)
		(%BLOCK-WRITE 2 W1)
		(%BLOCK-WRITE 2 W2)
		(%BLOCK-WRITE 2 W3)
		(%BLOCK-WRITE 2 W4)
		(%BLOCK-WRITE 2 W5)
		(%BLOCK-WRITE 2 W6)
		(%BLOCK-WRITE 2 W7)))
	    ;; Copy remaining words one at a time
	    (DOTIMES (IGNORE (%FIXNUM-MOD WORDS 8))
	      (%BLOCK-WRITE 2 (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T))))
	  ;; Do partial word at the end of the destination, if any
	  (WHEN ( (SETQ BITS (%FIXNUM-MOD BITS 32.)) 0)
	    (%BLOCK-WRITE 2
	      (LOGAND
		(IF ( (%FIXNUM-MOD (- OFFSET) 32) BITS)
		    ;; Rotate latch contains enough bits to make the destination
		    (SI:%ROTATE-LATCH)		;clobbers BYTE-R and BYTE-S
		  ;; Rotate latch doesn't contain enough bits, read more
		  (%BLOCK-READ-SHIFT 1 :FIXNUM-ONLY T :NO-INCREMENT T))
		(%32-BIT-DIFFERENCE (ROT 1 BITS) 1))))))))
  NIL)

#+3600
;;; Copy the specified portion of a given vector to the XDR block at XDR-POINTER
(DEFUN %XDR-SIMPLE-SEND-VECTOR (VECTOR XDR-POINTER XDR-LIMIT START END)
  (MULTIPLE-VALUE-BIND (S-ARRAY S-CONTROL S-ADDRESS S-BOUND S-OFFSET)
      (SYS:SETUP-FORCE-1D-ARRAY-SEQUENTIAL VECTOR)
    (DECLARE (IGNORE S-ARRAY S-CONTROL S-BOUND))
    ;; Compute shift needed to convert vector elements to bits.
    (LET* ((SHIFT
	     ;; The 3600 array dispatch types are laid out so the hardware can convert
	     ;; elements to bits by shifting (min (ldb (byte 3 0) <type>) 5) bits left.  We
	     ;; can use almost the same rules for array types.
	     (LET ((TYPE (ARRAY-TYPE-FIELD VECTOR)))
	       (COND ((> (LDB (BYTE 3 0) TYPE) 5) 5)
		     ((< TYPE 6) TYPE)
		     ((= TYPE ART-BOOLEAN) 5)
		     ((= TYPE ART-STRING) 3))))
	   (BITS (ROT (- END START) SHIFT)))
      (VERIFY-XDR-POINTER-BELOW-LIMIT (%FIXNUM-CEILING BITS 32) T)
      (SI:%COPY-BITS
	BITS
	S-ADDRESS
	(ROT (+ S-OFFSET START) SHIFT)
	(READ-XDR-POINTER)
	0)
      (ADVANCE-XDR-POINTER (%FIXNUM-CEILING BITS 32)))))

#+IMACH
;;; Copy the specified portion of a given vector to the XDR block at BAR 2, applying
;;; the specified SHUFFLE and COERCION to every (aligned) word.
(DEFMACRO %XDR-GENERAL-SEND-VECTOR (VECTOR XDR-LIMIT START END SHUFFLE COERCION)
  `(MACROLET ((TRANSFORM-1 (WORD)
		`(,',(CASE SHUFFLE
		       (:BIT '%XDR-BIT-SWAP)
		       (:BYTE '%XDR-BYTE-SWAP)
		       (:NIBBLE '%XDR-NIBBLE-SWAP)
		       (:HALFWORD '%XDR-HALFWORD-SWAP)
		       (OTHERWISE 'PROGN))
		  ,WORD))
	      (TRANSFORM-2 (WORD)
		,(IF COERCION ``(FUNCALL ,',COERCION ,WORD) ``(PROGN ,WORD)))
	      (TRANSFORM (WORD)
		`(TRANSFORM-1 (TRANSFORM-2 ,WORD))))
     (WHEN ( START END)
       (MULTIPLE-VALUE-BIND (BITS OFFSET)
	   (%XDR-GENERAL-SEND-VECTOR-SETUP ,VECTOR ,XDR-LIMIT ,START ,END)
	 ;; Might need an extra word of source for the first destination word
	 (WHEN ( OFFSET 0)
	   (%BLOCK-READ-SHIFT 1))
	 ;; Copy all the complete words
	 (DOTIMES (IGNORE (%FIXNUM-FLOOR BITS 32))
	   (%BLOCK-WRITE 2 (TRANSFORM (%BLOCK-READ-SHIFT 1))))
	 ;; Do partial word at the end of the destination, if any
	 (WHEN ( (SETQ BITS (%FIXNUM-MOD BITS 32.)) 0)
	   (%BLOCK-WRITE 2
	     (TRANSFORM
	       (LOGAND
		 (IF ( (%FIXNUM-MOD (- OFFSET) 32) BITS)
		     ;; Rotate latch contains enough bits to make the destination
		     (SI:%ROTATE-LATCH)		;clobbers BYTE-R and BYTE-S
		   ;; Rotate latch doesn't contain enough bits, read more
		   (%BLOCK-READ-SHIFT 1 :NO-INCREMENT T))
		 (%32-BIT-DIFFERENCE (ROT 1 BITS) 1)))))
	 NIL))))

#+IMACH
;;; Common portion of the %XDR-GENERAL-SEND-VECTOR macro is shared to save code space.
(DEFUN %XDR-GENERAL-SEND-VECTOR-SETUP (VECTOR XDR-LIMIT START END)
  (MULTIPLE-VALUE-BIND (S-ARRAY S-CONTROL S-ADDRESS S-BOUND)
      (SETUP-1D-ARRAY VECTOR)
    (DECLARE (IGNORE S-ARRAY S-BOUND))
    (LET* ((ELEMENTS (- END START))
	   (SHIFT (- 5 (LDB ARRAY-REGISTER-BYTE-PACKING S-CONTROL)))
	   (BITS (ROT ELEMENTS SHIFT))
	   (OFFSET (ROT (+ (LDB ARRAY-REGISTER-BYTE-OFFSET S-CONTROL) START) SHIFT)))
      (VERIFY-XDR-POINTER-BELOW-LIMIT (%FIXNUM-CEILING BITS 32) T)
      ;; BAR 1 points to source array, BAR 2 already points to XDR block
      (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS S-ADDRESS (%FIXNUM-FLOOR OFFSET 32)))
      (LET ((OFFSET (%FIXNUM-MOD OFFSET 32.)))
	;; Set up the rotate control.
	(SET-ALU-AND-ROTATE-CONTROL :BYTE-R (- OFFSET) :BYTE-S (1- OFFSET))
	(VALUES BITS OFFSET)))))

#+3600
;;; Copy the specified portion of a given vector to the XDR block
(DEFMACRO %XDR-GENERAL-SEND-VECTOR
	  (VECTOR XDR-POINTER XDR-LIMIT START END SHUFFLE COERCION)
  `(MACROLET ((TRANSFORM-1 (WORD)
		`(,',(CASE SHUFFLE
		       (:BIT '%XDR-BIT-SWAP)
		       (:BYTE '%XDR-BYTE-SWAP)
		       (:NIBBLE '%XDR-NIBBLE-SWAP)
		       (:HALFWORD '%XDR-HALFWORD-SWAP)
		       (OTHERWISE 'PROGN))
		  ,WORD))
	      (TRANSFORM-2 (WORD)
		,(IF COERCION ``(FUNCALL ,',COERCION ,WORD) ``(PROGN ,WORD)))
	      (TRANSFORM (WORD)
		`(TRANSFORM-1 (TRANSFORM-2 ,WORD))))
     (MULTIPLE-VALUE-BIND (WORDS ELEMENTS/WORD BITS/ELEMENT)
	 (%XDR-GENERAL-SEND-VECTOR-SETUP ,VECTOR ,XDR-POINTER ,XDR-LIMIT ,START ,END)
       (LET ((I ,START)
	     (A ,VECTOR))
	 (DECLARE (SYS:ARRAY-REGISTER A))
	 (IF (= ELEMENTS/WORD 1)
	     ;; Optimize this case and make it work for nonfixnum values
	     (DOTIMES (IGNORE WORDS)
	       (XDR-BLOCK-WRITE (TRANSFORM (AREF A I)))
	       (INCF I))
	   (DOTIMES (IGNORE WORDS)
	     (LET ((WORD 0))
	       (DOTIMES (IGNORE ELEMENTS/WORD)
		 (SETQ WORD (ROT (LOGIOR (IF ( I END) 0 (AREF A I)) WORD) (- BITS/ELEMENT)))
		 #+IGNORE (SETQ WORD (LOGIOR (AREF A I) (ROT WORD BITS/ELEMENT)))
		 (INCF I)
		 #+IGNORE (IF ( I END) (RETURN)))
	       (XDR-BLOCK-WRITE (TRANSFORM WORD)))))))
     ,XDR-POINTER))

#+3600
;;; Common portion of the %XDR-GENERAL-SEND-VECTOR macro is shared to save code space.
(DEFUN %XDR-GENERAL-SEND-VECTOR-SETUP (VECTOR XDR-POINTER XDR-LIMIT START END)
  (LET* ((ELEMENTS (- END START))
	 (ELEMENTS/WORD (AREF SI:*ARRAY-ELEMENTS-PER-Q* (ARRAY-TYPE-FIELD VECTOR)))
	 (WORDS (CEILING ELEMENTS ELEMENTS/WORD)))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (VALUES WORDS ELEMENTS/WORD (SELECT ELEMENTS/WORD (1 32) (2 16) (4 8) (8 4) (16 2) (32 1)))))

#+IMACH
;;; Copy from the XDR block at BAR 2 to the specified portion of the specified vector
(DEFUN %XDR-SIMPLE-RECEIVE-VECTOR (VECTOR XDR-LIMIT START END)
  (MACROLET ((COMBINE (MASK SOURCE DESTINATION)
	       `(LET ((ALUF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL))
		      (MASK ,MASK))
		  (%WRITE-INTERNAL-REGISTER ALUF %REGISTER-ALU-AND-ROTATE-CONTROL)
		  (LOGIOR (LOGAND ,SOURCE MASK) (LOGAND ,DESTINATION (LOGNOT MASK))))))
    (WHEN ( START END)
      (MULTIPLE-VALUE-BIND (D-ARRAY D-CONTROL D-ADDRESS D-BOUND)
	  (SETUP-1D-ARRAY VECTOR)
	(DECLARE (IGNORE D-ARRAY D-BOUND))
	(LET* ((ELEMENTS (- END START))
	       (SHIFT (- 5 (LDB ARRAY-REGISTER-BYTE-PACKING D-CONTROL)))
	       (BITS (ROT ELEMENTS SHIFT))
	       (OFFSET (ROT (+ (LDB ARRAY-REGISTER-BYTE-OFFSET D-CONTROL) START) SHIFT))
	       (NEXT-BAR-2 (%POINTER-PLUS (%BLOCK-REGISTER 2) (%FIXNUM-CEILING BITS 32))))
	  (VERIFY-XDR-POINTER-BELOW-LIMIT (%FIXNUM-CEILING BITS 32) T)
	  ;; BAR 1 points to destination array, BAR 2 already points to XDR block
	  (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS D-ADDRESS (%FIXNUM-FLOOR OFFSET 32)))
	  (LET ((OFFSET (%FIXNUM-MOD OFFSET 32)))
	    ;; Set up the rotate control
	    (SET-ALU-AND-ROTATE-CONTROL :BYTE-R OFFSET :BYTE-S (LOGNOT OFFSET))
	    ;; Do partial word at the front of the destination, if any
	    (WHEN ( OFFSET 0)
	      (%BLOCK-WRITE 1
	        (COMBINE (LSH -1 OFFSET)
			 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T)
			 (%BLOCK-READ 1 :NO-INCREMENT T :FIXNUM-ONLY T)))
	      (SETQ BITS (MAX (- BITS (- 32 OFFSET)) 0)))
	    ;; Copy all the complete words, in 8-word chunks at first
	    (LET ((WORDS (%FIXNUM-FLOOR BITS 32)))
	      (DOTIMES (IGNORE (%FIXNUM-FLOOR WORDS 8))
		(LET ((W0 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W1 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W2 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W3 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W4 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W5 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W6 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))
		      (W7 (%BLOCK-READ-SHIFT 2 :PREFETCH NIL :FIXNUM-ONLY T)))
		  (%BLOCK-WRITE 1 W0)
		  (%BLOCK-WRITE 1 W1)
		  (%BLOCK-WRITE 1 W2)
		  (%BLOCK-WRITE 1 W3)
		  (%BLOCK-WRITE 1 W4)
		  (%BLOCK-WRITE 1 W5)
		  (%BLOCK-WRITE 1 W6)
		  (%BLOCK-WRITE 1 W7)))
	      ;; Copy remaining words one at a time
	      (DOTIMES (IGNORE (%FIXNUM-MOD WORDS 8))
		(%BLOCK-WRITE 1 (%BLOCK-READ-SHIFT 2 :FIXNUM-ONLY T))))
	    ;; Do partial word at the end of the destination, if any
	    (WHEN ( (SETQ BITS (%FIXNUM-MOD BITS 32)) 0)
	      (%BLOCK-WRITE 1
	        (COMBINE (%32-BIT-DIFFERENCE (ROT 1 BITS) 1)
			 (IF ( OFFSET BITS)
			     ;; Rotate latch contains enough bits to make the destination
			     (SI:%ROTATE-LATCH)	;clobbers BYTE-R and BYTE-S
			   ;; Rotate latch doesn't contain enough bits, read more
			   (%BLOCK-READ-SHIFT 2 :NO-INCREMENT T :FIXNUM-ONLY T))
			 (%BLOCK-READ 1 :NO-INCREMENT T :FIXNUM-ONLY T)))))
	  (SETF (%BLOCK-REGISTER 2) NEXT-BAR-2)))))
  NIL)

#+3600
;;; Copy from the XDR block to the specified portion of the specified vector
(DEFUN %XDR-SIMPLE-RECEIVE-VECTOR (VECTOR XDR-POINTER XDR-LIMIT START END)
  (MULTIPLE-VALUE-BIND (D-ARRAY D-CONTROL D-ADDRESS D-BOUND D-OFFSET)
      (SYS:SETUP-FORCE-1D-ARRAY-SEQUENTIAL VECTOR)
    (DECLARE (IGNORE D-ARRAY D-CONTROL D-BOUND))
    ;; Compute shift needed to convert vector elements to bits.
    (LET* ((SHIFT
	     ;; The 3600 array dispatch types are laid out so the hardware can convert
	     ;; elements to bits by shifting (min (ldb (byte 3 0) <type>) 5) bits left.  We
	     ;; can use almost the same rules for array types.
	     (LET ((TYPE (ARRAY-TYPE-FIELD VECTOR)))
	       (COND ((> (LDB (BYTE 3 0) TYPE) 5) 5)
		     ((< TYPE 6) TYPE)
		     ((= TYPE ART-BOOLEAN) 5)
		     ((= TYPE ART-STRING) 3))))
	   (BITS (ROT (- END START) SHIFT)))
      (VERIFY-XDR-POINTER-BELOW-LIMIT (%FIXNUM-CEILING BITS 32) T)
      (SI:%COPY-BITS
	BITS
	(READ-XDR-POINTER) 0
	D-ADDRESS (ROT (+ D-OFFSET START) SHIFT))
      (ADVANCE-XDR-POINTER (%FIXNUM-CEILING BITS 32)))))

#+IMACH
;;; Copy from the XDR block at BAR 2 to the specified portion of the specified vector,
;;; applying the specified SHUFFLE and COERCION to every (aligned) word.  Note that
;;; %BLOCK-READ-SHIFT isn't directly usable here, because we need to apply SHUFFLE on
;;; the original word-aligned data.  So we read the words with %BLOCK-READ, apply the
;;; shuffle, then use %ALU to perform exactly the same shift and rotate-latch hair
;;; that a %BLOCK-READ-SHIFT would.
(DEFMACRO %XDR-GENERAL-RECEIVE-VECTOR (VECTOR XDR-LIMIT START END SHUFFLE COERCION)
  `(MACROLET ((COMBINE (MASK SOURCE DESTINATION)
	       `(LET ((ALUF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL))
		      (MASK ,MASK))
		  (%WRITE-INTERNAL-REGISTER ALUF %REGISTER-ALU-AND-ROTATE-CONTROL)
		  (LOGIOR (LOGAND ,SOURCE MASK) (LOGAND ,DESTINATION (LOGNOT MASK)))))
	     (TRANSFORM-1 (WORD)
	       `(,',(CASE SHUFFLE
		      (:BIT '%XDR-BIT-SWAP)
		      (:BYTE '%XDR-BYTE-SWAP)
		      (:NIBBLE '%XDR-NIBBLE-SWAP)
		      (:HALFWORD '%XDR-HALFWORD-SWAP)
		      (OTHERWISE 'PROGN))
		 ,WORD))
	     (TRANSFORM-2 (WORD)
	       ,(IF COERCION ``(FUNCALL ,',COERCION ,WORD) ``(PROGN ,WORD))))
     (WHEN ( START END)
       (MULTIPLE-VALUE-BIND (BITS OFFSET)
	   (%XDR-GENERAL-RECEIVE-VECTOR-SETUP ,VECTOR ,XDR-LIMIT ,START ,END)
	 (LET ((NEXT-BAR-2 (%POINTER-PLUS (%BLOCK-REGISTER 2) (%FIXNUM-CEILING BITS 32))))
	   ;; Do partial word at the front of the destination, if any
	   (WHEN ( OFFSET 0)
	     (%BLOCK-WRITE 1
	       (COMBINE (LSH (IF ( BITS 32) -1 (%32-BIT-DIFFERENCE (ROT 1 BITS) 1)) OFFSET)
			(TRANSFORM-2 (%ALU 0 (TRANSFORM-1 (%BLOCK-READ 2 :FIXNUM-ONLY T))))
			(%BLOCK-READ 1 :NO-INCREMENT T :FIXNUM-ONLY T)))
	     (SETQ BITS (MAX (- BITS (- 32 OFFSET)) 0)))
	   ;; Copy all the complete words
	   (DOTIMES (IGNORE (%FIXNUM-FLOOR BITS 32))
	     (%BLOCK-WRITE 1
	       (TRANSFORM-2 (%ALU 0 (TRANSFORM-1 (%BLOCK-READ 2 :FIXNUM-ONLY T))))))
	   ;; Do partial word at the end of the destination, if any
	   (WHEN ( (SETQ BITS (%FIXNUM-MOD BITS 32)) 0)
	     (%BLOCK-WRITE 1
	       (COMBINE (%32-BIT-DIFFERENCE (ROT 1 BITS) 1)
			(IF ( OFFSET BITS)
			    ;; Rotate latch contains enough bits to make the destination
			    ;; Note that TRANSFORM-1 was applied to this word before it
			    ;; was loaded into the rotate latch.
			    (TRANSFORM-2 (SI:%ROTATE-LATCH))	;clobbers BYTE-R and BYTE-S
			  ;; Rotate latch doesn't contain enough bits, read more
			  (TRANSFORM-2 (%ALU 0 (TRANSFORM-1 (%BLOCK-READ 2 :FIXNUM-ONLY T)))))
			(%BLOCK-READ 1 :NO-INCREMENT T :FIXNUM-ONLY T))))
	   (SETF (%BLOCK-REGISTER 2) NEXT-BAR-2))
	   NIL))))

#+IMACH
;;; Common portion of the %XDR-GENERAL-RECEIVE-VECTOR macro is shared to save code space.
(DEFUN %XDR-GENERAL-RECEIVE-VECTOR-SETUP (VECTOR XDR-LIMIT START END)
  (MULTIPLE-VALUE-BIND (D-ARRAY D-CONTROL D-ADDRESS D-BOUND)
      (SETUP-1D-ARRAY VECTOR)
    (DECLARE (IGNORE D-ARRAY D-BOUND))
    (LET* ((ELEMENTS (- END START))
	   (SHIFT (- 5 (LDB ARRAY-REGISTER-BYTE-PACKING D-CONTROL)))
	   (BITS (ROT ELEMENTS SHIFT))
	   (OFFSET (ROT (+ (LDB ARRAY-REGISTER-BYTE-OFFSET D-CONTROL) START) SHIFT)))
      (VERIFY-XDR-POINTER-BELOW-LIMIT (%FIXNUM-CEILING BITS 32) T)
      ;; BAR 1 points to destination array, BAR 2 already points to XDR block
      (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS D-ADDRESS (%FIXNUM-FLOOR OFFSET 32)))
      (LET ((OFFSET (%FIXNUM-MOD OFFSET 32)))
	;; Set up the rotate control to emulate a %block-read-shift.
	(SET-ALU-AND-ROTATE-CONTROL
	  :BYTE-R OFFSET
	  :BYTE-S (LOGNOT OFFSET)
	  :FUNCTION (SYS:%ALU-FUNCTION-DPB SYS:%ALU-BYTE-BACKGROUND-ROTATE-LATCH SYS:%ALU-BYTE-SET-ROTATE-LATCH))
	(VALUES BITS OFFSET)))))

#+3600
;;; Copy from the XDR block to the specified portion of the specified vector
(DEFMACRO %XDR-GENERAL-RECEIVE-VECTOR
	  (VECTOR XDR-POINTER XDR-LIMIT START END SHUFFLE COERCION)
  `(MACROLET ((TRANSFORM-1 (WORD)
		`(,',(CASE SHUFFLE
		       (:BIT '%XDR-BIT-SWAP)
		       (:BYTE '%XDR-BYTE-SWAP)
		       (:NIBBLE '%XDR-NIBBLE-SWAP)
		       (:HALFWORD '%XDR-HALFWORD-SWAP)
		       (OTHERWISE 'PROGN))
		  ,WORD))
	      (TRANSFORM-2 (WORD)
		,(IF COERCION ``(FUNCALL ,',COERCION ,WORD) ``(PROGN ,WORD)))
	      (TRANSFORM (WORD)
		`(TRANSFORM-2 (TRANSFORM-1 ,WORD))))
     (MULTIPLE-VALUE-BIND (WORDS ELEMENTS/WORD BITS/ELEMENT)
	 (%XDR-GENERAL-RECEIVE-VECTOR-SETUP ,VECTOR ,XDR-POINTER ,XDR-LIMIT ,START ,END)
       (LET ((I ,START)
	     (A ,VECTOR))
	 (DECLARE (SYS:ARRAY-REGISTER A))
	 (IF (= ELEMENTS/WORD 1)
	     ;; Optimize this case and make it work for nonfixnum values
	     (DOTIMES (IGNORE WORDS)
	       (SETF (AREF A I) (TRANSFORM (XDR-BLOCK-READ)))
	       (INCF I))
	   (DOTIMES (IGNORE WORDS)
	     (LET ((WORD (TRANSFORM (XDR-BLOCK-READ))))
	       (DOTIMES (IGNORE ELEMENTS/WORD)
		 (SETF (AREF A I) (SHIFTF WORD (ROT WORD (- BITS/ELEMENT))))
		 (INCF I)
		 (IF ( I END) (RETURN)))))))
       XDR-POINTER)))

#+3600
;;; Common portion of the %XDR-GENERAL-RECEIVE-VECTOR macro is shared to save code space.
(DEFUN %XDR-GENERAL-RECEIVE-VECTOR-SETUP (VECTOR XDR-POINTER XDR-LIMIT START END)
  (LET* ((ELEMENTS (- END START))
	 (ELEMENTS/WORD (AREF SI:*ARRAY-ELEMENTS-PER-Q* (ARRAY-TYPE-FIELD VECTOR)))
	 (WORDS (CEILING ELEMENTS ELEMENTS/WORD)))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (VALUES WORDS ELEMENTS/WORD (SELECT ELEMENTS/WORD (1 32) (2 16) (4 8) (8 4) (16 2) (32 1)))))

#||
(DEFUN TEST-XDR-SEND-VECTOR (&OPTIONAL GENERAL-CASE-P)
  (LABELS ((TEST-CASE (TYPE START END)
	     (STACK-LET ((SOURCE (ZL:MAKE-ARRAY END :TYPE TYPE))
			 (TEST-BLOCK (ZL:MAKE-ARRAY 64 :TYPE ART-FIXNUM))
			 (REFERENCE-BLOCK (ZL:MAKE-ARRAY 64 :TYPE ART-FIXNUM)))
	       ;; Initialize source array
	       (LOOP FOR I BELOW END DO (SETF (AREF SOURCE I) I))
	       ;; Copy to reference block using copy-array-portion
	       (STACK-LET ((HACK (ZL:MAKE-ARRAY END :TYPE TYPE :DISPLACED-TO REFERENCE-BLOCK)))
		 (COPY-ARRAY-PORTION SOURCE START END HACK 0 (- END START)))
	       ;; Copy to test block using %xdr-send-vector
	       (#+3600 PROGN #+Imach WITH-BLOCK-REGISTERS #+Imach (2)
		 (LET (#+3600 (XDR-POINTER (%MAKE-POINTER DTP-LOCATIVE TEST-BLOCK)))
		   #+Imach (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS TEST-BLOCK 1))
		   (IF (NOT GENERAL-CASE-P)
		       (%XDR-SIMPLE-SEND-VECTOR SOURCE 
			 #+3600 XDR-POINTER (%POINTER-PLUS TEST-BLOCK 64) START END)
		     (%XDR-GENERAL-SEND-VECTOR SOURCE
		       #+3600 XDR-POINTER (%POINTER-PLUS TEST-BLOCK 64) START END
		       :BYTE #'BYTE-SWAP))))
	       ;; Compare the result
	       (LOOP FOR J BELOW (ARRAY-TOTAL-SIZE TEST-BLOCK) DO
		 (COMPILER:%ERROR-WHEN (NOT (EQL (AREF TEST-BLOCK J) (AREF REFERENCE-BLOCK J)))
		   (FORMAT T "~&Mismatch at index ~O, expected ~O, got ~O"
			   J (AREF REFERENCE-BLOCK J) (AREF TEST-BLOCK J))
		   (FORMAT T "~&  Arguments: ~A ~O ~O" (ARRAY-TYPES TYPE) START END))))))
    (TEST-CASE ART-FIXNUM 0 4)
    (LOOP FOR START FROM 0 TO 4 DO
      (LOOP FOR END FROM 18 DOWNTO 14 DO
	(TEST-CASE ART-8B START END)))
    (LOOP FOR START FROM 28 TO 36 DO
      (LOOP FOR END FROM 132 DOWNTO 124 DO
	(TEST-CASE ART-1B START END)))))

(DEFUN TEST-XDR-RECEIVE-VECTOR (&OPTIONAL GENERAL-CASE-P)
  (LABELS ((TEST-CASE (TYPE START END)
	     (STACK-LET ((SOURCE (ZL:MAKE-ARRAY 64 :TYPE ART-FIXNUM))
			 (TEST-ARRAY (ZL:MAKE-ARRAY END :TYPE TYPE))
			 (REFERENCE-ARRAY (ZL:MAKE-ARRAY END :TYPE TYPE)))
	       ;; Initialize source array
	       (LOOP FOR I BELOW (LENGTH SOURCE) DO
		 (SETF (AREF SOURCE I) (RANDOM 1_30)))
	       ;; Copy to reference array using copy-array-portion
	       (STACK-LET ((HACK (ZL:MAKE-ARRAY END :TYPE TYPE :DISPLACED-TO SOURCE)))
		 (COPY-ARRAY-PORTION HACK 0 (- END START) REFERENCE-ARRAY START END))
	       ;; Copy to test array using %xdr-receive-vector
	       (#+3600 PROGN #+Imach WITH-BLOCK-REGISTERS #+Imach (2)
		 (LET (#+3600 (XDR-POINTER (%MAKE-POINTER DTP-LOCATIVE SOURCE)))
		   #+Imach (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS SOURCE 1))
		   (IF (NOT GENERAL-CASE-P)
		       (%XDR-SIMPLE-RECEIVE-VECTOR TEST-ARRAY
			 #+3600 XDR-POINTER (%POINTER-PLUS SOURCE 64) START END)
		     ;; Can't actually test the shuffle because there's a shift between the
		     ;; two transformations.
		     (%XDR-GENERAL-RECEIVE-VECTOR TEST-ARRAY
		       #+3600 XDR-POINTER (%POINTER-PLUS SOURCE 64) START END NIL NIL))))
	       ;; Compare the result
	       (LOOP FOR J BELOW (ARRAY-TOTAL-SIZE TEST-ARRAY) DO
		 (COMPILER:%ERROR-WHEN (NOT (EQL (AREF TEST-ARRAY J) (AREF REFERENCE-ARRAY J)))
		   (FORMAT T "~&Mismatch at index ~O, expected ~O, got ~O"
			   J (AREF REFERENCE-ARRAY J) (AREF TEST-ARRAY J))
		   (FORMAT T "~&  Arguments: ~A ~O ~O" (ARRAY-TYPES TYPE) START END))))))
    (TEST-CASE ART-FIXNUM 0 4)
    (LOOP FOR START FROM 0 TO 4 DO
      (LOOP FOR END FROM 18 DOWNTO 14 DO
	(TEST-CASE ART-8B START END)))
    (LOOP FOR START FROM 28 TO 36 DO
      (LOOP FOR END FROM 132 DOWNTO 124 DO
	(TEST-CASE ART-1B START END)))))
||#

;;;; Little Ender data transmission and reception

(DEFFLAVOR LITTLE-ENDER-DATA () ()
  (:REQUIRED-FLAVORS TRANSPORT-AGENT))

(DEFMETHOD (XDR-SEND-WORD LITTLE-ENDER-DATA) (WORD #-IMACH XDR-POINTER XDR-LIMIT)
  (DECLARE (VALUES XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT 1 T)
  (XDR-BLOCK-WRITE WORD)
  NIL #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-SEND-WORDS LITTLE-ENDER-DATA) (#-IMACH XDR-POINTER XDR-LIMIT &REST WORDS)
  (DECLARE (VALUES XDR-POINTER))
  (BLOCK SEND
    ;; Cheat so we don't have to compute the length of the list: as long as we're not close
    ;; to the end of the block, keep popping words off the list
    (DOTIMES (IGNORE (%POINTER-DIFFERENCE XDR-LIMIT (READ-XDR-POINTER)))
      (IF (ENDP WORDS)
	  (RETURN-FROM SEND NIL)
	(XDR-BLOCK-WRITE (POP WORDS))))
    (VERIFY-XDR-POINTER-BELOW-LIMIT (LENGTH WORDS) T))
  #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-SEND-WORD-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-SINGLE-FLOAT-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END NIL #'%FIXNUM))

(DEFMETHOD (XDR-SEND-HALFWORD-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-BYTE-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-CHAR-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-NIBBLE-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-BIT-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-SIGNED-HALFWORD-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 2))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (DOTIMES (IGNORE WORDS)
      (LET ((B0 (AREF VECTOR (SHIFTF INDEX (1+ INDEX))))
	    (B1 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0)))
	(XDR-BLOCK-WRITE (%LOGDPB B1 (BYTE 16 16) B0)))))
  #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-SEND-SIGNED-BYTE-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 4))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (DOTIMES (IGNORE WORDS)
      (LET ((B0 (AREF VECTOR (SHIFTF INDEX (1+ INDEX))))
	    (B1 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0))
	    (B2 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0))
	    (B3 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0)))
	(XDR-BLOCK-WRITE (%LOGDPBS B3 (BYTE 8 24) B2 (BYTE 8 16) B1 (BYTE 8 8) B0)))))
  NIL #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-RECEIVE-WORD LITTLE-ENDER-DATA) (#-IMACH XDR-POINTER XDR-LIMIT)
  (DECLARE (VALUES WORD XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT 1 NIL)
  (VALUES (XDR-BLOCK-READ) #-IMACH XDR-POINTER))

(DEFMETHOD (XDR-RECEIVE-WORD-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-SINGLE-FLOAT-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END NIL #'%FLONUM))

(DEFMETHOD (XDR-RECEIVE-HALFWORD-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-BYTE-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-CHAR-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-NIBBLE-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-BIT-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-SIGNED-HALFWORD-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 2))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (MACROLET ((SIGN-EXTEND (X)
		 `(LET ((X ,X)) (%LOGDPB (- (LDB (BYTE 1 15) X)) (BYTE 16 16) X))))
      (DOTIMES (IGNORE WORDS)
	(LET ((WORD (XDR-BLOCK-READ)))
	  (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 16 0) WORD)))
	  (WHEN (< INDEX END)
	    (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 16 16) WORD))))))))
  #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-RECEIVE-SIGNED-BYTE-VECTOR LITTLE-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 4))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (MACROLET ((SIGN-EXTEND (X)
		 `(LET ((X ,X)) (%LOGDPB (- (LDB (BYTE 1 7) X)) (BYTE 24 8) X))))
      (DOTIMES (IGNORE WORDS)
	(LET ((WORD (XDR-BLOCK-READ)))
	  (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 0) WORD)))
	  (WHEN (< INDEX END)
	    (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 8) WORD)))
	    (WHEN (< INDEX END)
	      (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 16) WORD)))
	      (WHEN (< INDEX END)
		(SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 24) WORD))))))))))
  #-IMACH XDR-POINTER)

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")
0;;;; Big Ender data transmission and reception

(DEFFLAVOR BIG-ENDER-DATA () ()
  (:REQUIRED-FLAVORS TRANSPORT-AGENT))

(DEFMETHOD (XDR-SEND-WORD BIG-ENDER-DATA) (WORD #-IMACH XDR-POINTER XDR-LIMIT)
  (DECLARE (VALUES XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT 1 T)
  (XDR-BLOCK-WRITE (BYTE-SWAP WORD))
  NIL #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-SEND-WORDS BIG-ENDER-DATA) (#-IMACH XDR-POINTER XDR-LIMIT &REST WORDS)
  (DECLARE (VALUES XDR-POINTER))
  (BLOCK SEND
    ;; Cheat so we don't have to compute the length of the list: as long as we're not close
    ;; to the end of the block, keep popping words off the list
    (DOTIMES (IGNORE (%POINTER-DIFFERENCE XDR-LIMIT (READ-XDR-POINTER)))
      (IF (ENDP WORDS)
	  (RETURN-FROM SEND NIL)
	(XDR-BLOCK-WRITE (BYTE-SWAP (POP WORDS)))))
    (VERIFY-XDR-POINTER-BELOW-LIMIT (LENGTH WORDS) T))
  #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-SEND-WORD-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :BYTE))

(DEFMETHOD (XDR-SEND-SINGLE-FLOAT-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :BYTE #'%FIXNUM))

(DEFMETHOD (XDR-SEND-HALFWORD-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :HALFWORD))

(DEFMETHOD (XDR-SEND-BYTE-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-CHAR-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-SEND-NIBBLE-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :NIBBLE))

(DEFMETHOD (XDR-SEND-BIT-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-SEND-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :BIT))

(DEFMETHOD (XDR-SEND-SIGNED-HALFWORD-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 2))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (DOTIMES (IGNORE WORDS)
      (LET ((B0 (AREF VECTOR (SHIFTF INDEX (1+ INDEX))))
	    (B1 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0)))
	(XDR-BLOCK-WRITE (BYTE-SWAP (%LOGDPB B0 (BYTE 16 16) B1))))))
  #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-SEND-SIGNED-BYTE-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 4))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (DOTIMES (IGNORE WORDS)
      (LET ((B0 (AREF VECTOR (SHIFTF INDEX (1+ INDEX))))
	    (B1 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0))
	    (B2 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0))
	    (B3 (IF (< INDEX END) (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) 0)))
	(XDR-BLOCK-WRITE (%LOGDPBS B3 (BYTE 8 24) B2 (BYTE 8 16) B1 (BYTE 8 8) B0)))))
  NIL #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-RECEIVE-WORD BIG-ENDER-DATA) (#-IMACH XDR-POINTER XDR-LIMIT)
  (DECLARE (VALUES WORD XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT 1 NIL)
  (VALUES (BYTE-SWAP (XDR-BLOCK-READ)) #-IMACH XDR-POINTER))

(DEFMETHOD (XDR-RECEIVE-WORD-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :BYTE))

(DEFMETHOD (XDR-RECEIVE-SINGLE-FLOAT-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :BYTE #'%FLONUM))

(DEFMETHOD (XDR-RECEIVE-HALFWORD-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :HALFWORD))

(DEFMETHOD (XDR-RECEIVE-BYTE-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-CHAR-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END))

(DEFMETHOD (XDR-RECEIVE-NIBBLE-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :NIBBLE))

(DEFMETHOD (XDR-RECEIVE-BIT-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (XDR-RECEIVE-VECTOR VECTOR #-IMACH XDR-POINTER XDR-LIMIT START END :BIT))

(DEFMETHOD (XDR-RECEIVE-SIGNED-HALFWORD-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 2))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (MACROLET ((SIGN-EXTEND (X)
		 `(LET ((X ,X)) (%LOGDPB (- (LDB (BYTE 1 15) X)) (BYTE 16 16) X))))
      (DOTIMES (IGNORE WORDS)
	(LET ((WORD (BYTE-SWAP (XDR-BLOCK-READ))))
	  (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 16 16) WORD)))
	  (WHEN (< INDEX END)
	    (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 16 0) WORD))))))))
  #-IMACH XDR-POINTER)

(DEFMETHOD (XDR-RECEIVE-SIGNED-BYTE-VECTOR BIG-ENDER-DATA)
    (VECTOR #-IMACH XDR-POINTER XDR-LIMIT &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (LET ((WORDS (%FIXNUM-CEILING (- END START) 4))
	(INDEX START)
	(VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (VERIFY-XDR-POINTER-BELOW-LIMIT WORDS T)
    (MACROLET ((SIGN-EXTEND (X)
		 `(LET ((X ,X)) (%LOGDPB (- (LDB (BYTE 1 7) X)) (BYTE 24 8) X))))
      (DOTIMES (IGNORE WORDS)
	(LET ((WORD (XDR-BLOCK-READ)))
	  (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 0) WORD)))
	  (WHEN (< INDEX END)
	    (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 8) WORD)))
	    (WHEN (< INDEX END)
	      (SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 16) WORD)))
	      (WHEN (< INDEX END)
		(SETF (AREF VECTOR (SHIFTF INDEX (1+ INDEX))) (SIGN-EXTEND (LDB (BYTE 8 24) WORD))))))))))
  #-IMACH XDR-POINTER)


(DEFFLAVOR BIG-IN-LITTLE-BYTES-DATA () (LITTLE-ENDER-DATA))

(DEFMETHOD (XDR-SEND-BIT-VECTOR BIG-IN-LITTLE-BYTES-DATA)
	   (VECTOR #-IMACH XDR-POINTER XDR-LIMIT
	    &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT (CEILING (- END START) 32) T)
  (LET ((VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (LOOP FOR I FROM START BELOW END BY 32
	  AS WORD = (LOOP FOR I FROM I BELOW END FOR BIT FROM 0 BELOW 32
			  WITH RESULT = 0
			  DO (SETQ RESULT (LOGIOR RESULT (ROT (AREF VECTOR I) BIT)))
			  FINALLY (RETURN RESULT))
	  DO (LOOP FOR BIT FROM 0 BELOW 32 BY 8 DO
	       (SETF (%LOGLDB (BYTE 8 BIT) WORD) (BIT-REVERSE-8 (%LOGLDB (BYTE 8 BIT) WORD))))
	     (XDR-BLOCK-WRITE WORD))
    #-IMACH XDR-POINTER))

(DEFMETHOD (XDR-RECEIVE-BIT-VECTOR BIG-IN-LITTLE-BYTES-DATA)
	   (VECTOR #-IMACH XDR-POINTER XDR-LIMIT
	    &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT (CEILING (- END START) 32) NIL)
  (LET ((VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (LOOP FOR I FROM START BELOW END BY 32
	  AS WORD = (XDR-BLOCK-READ)
	  DO (LOOP FOR BIT FROM 0 BELOW 32 BY 8 DO
	       (SETF (%LOGLDB (BYTE 8 BIT) WORD) (BIT-REVERSE-8 (%LOGLDB (BYTE 8 BIT) WORD))))
	     (LOOP FOR I FROM I BELOW END FOR BIT DOWNFROM 0 ABOVE -32
		   DO (SETF (AREF VECTOR I) (ROT WORD BIT))))
    #-IMACH XDR-POINTER))

(DEFMETHOD (XDR-SEND-NIBBLE-VECTOR BIG-IN-LITTLE-BYTES-DATA)
	   (VECTOR #-IMACH XDR-POINTER XDR-LIMIT
	    &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT (CEILING (- END START) 8) T)
  (LET ((VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (LOOP FOR I FROM START BELOW END BY 8
	  AS WORD = (LOOP FOR I FROM I BELOW END FOR BIT FROM 0 BELOW 32 BY 4
			  WITH RESULT = 0
			  DO (SETQ RESULT (LOGIOR RESULT (ROT (AREF VECTOR I) (LOGXOR BIT 4))))
			  FINALLY (RETURN RESULT))
	  DO (XDR-BLOCK-WRITE WORD))
    #-IMACH XDR-POINTER))

(DEFMETHOD (XDR-RECEIVE-NIBBLE-VECTOR BIG-IN-LITTLE-BYTES-DATA)
	   (VECTOR #-IMACH XDR-POINTER XDR-LIMIT
	    &OPTIONAL (START 0) (END (VECTOR-LENGTH VECTOR)))
  (DECLARE (VALUES XDR-POINTER))
  (VERIFY-XDR-POINTER-BELOW-LIMIT (CEILING (- END START) 8) NIL)
  (LET ((VECTOR VECTOR))
    (DECLARE (SYS:ARRAY-REGISTER VECTOR))
    (LOOP FOR I FROM START BELOW END BY 8
	  AS WORD = (XDR-BLOCK-READ)
	  DO (LOOP FOR I FROM I BELOW END FOR BIT FROM 0 BELOW 32 BY 4
		   DO (SETF (AREF VECTOR I) (ROT WORD (- (LOGXOR BIT 4))))))
    #-IMACH XDR-POINTER))
