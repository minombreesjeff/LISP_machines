;;; -*- Mode: LISP; Syntax: Lisp+C; Package: RPC; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Basic Atomic Types

(define-remote-type integer-32 ()
  (:size 1)
  (:packed :word)
  (:lisp (:encode (value) value)		;represented as itself
	 (:decode (value) value)
	 (:typep (value)  `(fixnump ,value)))	;range happens to be the same as fixnum
  (:c    (:declare (name) #{LongInt name })
	 (:encode (value) value)		;represented as itself
	 (:decode (value) value)))

(define-remote-type cardinal-32 ()
  (:size 1)
  ;;can't be :packed :word because the Lisp values can be bignums
  (:lisp (:encode (value) `(sys:%logldb (byte 32 0) ,value))
	 (:decode (value) `(if (minusp ,value) (+ ,value ,(expt 2 32)) ,value))
	 (:typep (value)  `(typep ,value '(integer 0 (,(expt 2 32))))))
  (:c    (:declare (name) #{unsigned LongInt name })
	 (:encode (value) #{(LongInt)value })	;represented as itself
	 (:decode (value) #{(unsigned LongInt)value })))

;;; An alternative would be to have this type just be integer,
;;; defaulting to the other end's int type, which is the default
;;; argument size.
(define-remote-type integer-16 ()
  (:size 1)
  (:packed :halfword)
  (:signed t)
  (:lisp (:encode (value) value)
	 (:decode (value) value)
	 (:typep (value) `(typep ,value '(signed-byte 16))))
  (:c    (:declare (name) #{short name })
	 (:encode (value) #{(short)value })
	 (:decode (value) #{(short)value })))

(define-remote-type cardinal-16 ()
  (:size 1)
  (:packed :halfword)
  (:lisp (:encode (value) value)
	 (:decode (value) value)
	 (:typep (value) `(typep ,value '(unsigned-byte 16))))
  (:c    (:declare (name) #{unsigned short name })
	 (:encode (value) #{(unsigned short)value })
	 (:decode (value) #{(unsigned short)value })))

(define-remote-type cardinal-8 ()
  (:size 1)
  (:packed :byte)
  (:lisp (:encode (value) value)		;don't bother with range check
	 (:decode (value) value)
	 (:typep (value)  `(typep ,value '(unsigned-byte 8))))
  (:c    (:declare (name) #{unsigned char name })	;both packed and unpacked
	 (:encode (value) #{(LongInt)value })
	 (:decode (value) #{(unsigned char)value })))

(define-remote-type integer-8 ()
  (:size 1)
  (:packed :byte)
  (:signed t)
  (:lisp (:encode (value) value)		;don't bother with range check
	 (:decode (value) value)
	 (:typep (value)  `(typep ,value '(signed-byte 8))))
  (:c    (:declare (name) #{char name })	;both packed and unpacked
	 (:encode (value) #{(LongInt)value })
	 (:decode (value) #{(char)value })))

(define-remote-type cardinal-4 ()
  (:size 1)
  (:packed :nibble)
  (:lisp (:encode (value) value)		;don't bother with range check
	 (:decode (value) value)
	 (:typep (value)  `(typep ,value '(unsigned-byte 4))))
  (:c    (:declare (name) #{unsigned char name })	;a little white lie in the packed case
	 (:encode (value) #{(LongInt)value })
	 (:decode (value) #{(unsigned char)value })))

(define-remote-type bit ()
  (:size 1)
  (:packed :bit)
  (:lisp (:encode (value) value)		;don't bother with range check
	 (:decode (value) value)
	 (:typep (value)  `(typep ,value 'bit)))
  (:c    (:declare (name) #{unsigned char name })	;a little white lie in the packed case
	 (:encode (value) #{(LongInt)value })
	 (:decode (value) #{(unsigned char)value })))

(define-remote-type character-8 ()
  (:size 1)
  (:packed :byte)
  (:lisp (:encode (value) `(char-code ,value))	;don't bother with printing-ascii-p check
	 (:decode (value) `(code-char ,value))
	 (:typep (value)  `(typep ,value 'standard-char)))
  (:c    (:declare (name) #{unsigned char name })	;both packed and unpacked
	 (:encode (value) #{(LongInt)value })
	 (:decode (value) #{(unsigned char)value })))

(define-remote-type single-float ()
  (:size 1)
  (:packed :single-float)
  (:lisp (:encode (value) `(%fixnum ,value))
	 (:decode (value) `(%flonum ,value))
	 (:typep (value)  `(typep ,value 'single-float)))
  (:c    (:declare (name) #{float name })
	 (:encode (value) #{EncodeFloat(value)})
	 (:decode (value) #{DecodeFloat(value)})))


;;;; Derived Atomic Types

; (:abbreviation-for `(member nil t)) would disallow non-t truth values
; however in :typep test accept only t, so this doesn't have to go last in a union
(define-remote-type boolean ()
  (:size 1)
  (:lisp (:encode (value) `(if ,value 1 0))
	 (:decode (value) `(not (zerop ,value)))
	 (:typep (value)  `(typep ,value 'boolean)))
  (:c    (:declare (name) #{int name })
	 (:encode (value) value)		;represented as itself
	 (:decode (value) value)))

(define-remote-type boolean8 ()
  (:size 1)
  (:lisp (:encode (value) `(if ,value 1 0))
	 (:decode (value) `(not (zerop ,value)))
	 (:typep (value)  `(typep ,value 'boolean)))
  (:c    (:declare (name) #{char name })
	 (:encode (value) value)		;represented as itself
	 (:decode (value) value)))

(define-remote-type boolean16 ()
  (:size 1)
  (:lisp (:encode (value) `(if ,value 1 0))
	 (:decode (value) `(not (zerop ,value)))
	 (:typep (value)  `(typep ,value 'boolean)))
  (:c    (:declare (name) #{short name })
	 (:encode (value) value)		;represented as itself
	 (:decode (value) value)))

(define-remote-type boolean32 ()
  (:size 1)
  (:lisp (:encode (value) `(if ,value 1 0))
	 (:decode (value) `(not (zerop ,value)))
	 (:typep (value)  `(typep ,value 'boolean)))
  (:c    (:declare (name) #{LongInt name })
	 (:encode (value) value)		;represented as itself
	 (:decode (value) value)))

(define-remote-type member (&rest symbols)
  (:size 1)
  (:prologue ((vector (apply #'vector symbols)))
    (unless (every #'symbolp symbols)
      (type-error "The elements of ~S are required to be symbols." type)))
  (:lisp (:encode (value) `(position ,value ',vector))
	 (:decode (value) `(aref ',vector ,value))
	 (:typep (value)  (case (length symbols)
			    (0 `'nil)
			    (1 `(eql ,value ',(first symbols)))
			    (2 `(or (eql ,value ',(first symbols)) (eql ,value ',(second symbols))))
			    (otherwise `(not (null (position ,value ',vector)))))))
  (:c    (:declare (name) #{ enum { (loop for (symbol . more) on symbols
					   collect (lisp-name-to-c-name symbol)
					   when more append #{,})
				  } name })
	 (:encode (value) #{(LongInt)value })
	 (:decode (value) #{(int)value })))

;;;; Compound Types 1: Structures

(define-remote-type structure (&rest fields)
  (:prologue ((lisp-structure-name nil)
	      (c-structure-name nil)
	      (fields fields))
    ;; Parse (:lisp structure-name) and (:c structure-name) options out of the fields
    (loop for field in fields
	  do (unless (listp field)
	       (type-error "~S is not (field-name remote-type) nor (option structure-name)"
			   field)
	       (setq field '(:lisp)))
	  as (option structure-name . options) = field do
      (when (member option *known-languages*)
	(ecase option
	  (:lisp
	    (unless (symbolp structure-name)
	      (type-error "The ~A structure name ~S is supposed to be a symbol"
			  option structure-name))
	    (setq lisp-structure-name structure-name))
	  (:c
	    (setq c-structure-name (eval structure-name))))
	(when options
	  (type-error "The structure remote-type doesn't (yet) accept sub-options ~S in ~S"
		      options field))
	(setq fields (remove field fields))))
    (dolist (field fields)
      (unless (and (listp field)
		   (= (length field) 2)
		   (symbolp (first field))
		   (remote-type-specifier-p (second field)))
	(type-error "The structure field ~S is supposed to be (field-name remote-type)."
		    field))))
  ;; Check for fixed size, return NIL if any field is variable size
  (:size (loop for (nil type) in fields
	       as size = (remote-type-fixed-size type)
	       do (unless size (return nil))
	       sum size))
  ;; The XDR representation of a structure is simply a sequence of representations of fields
  (:lisp
    ;; Assume the Lisp compiler will do constant-folding for +
    (:size (value)
      (once-only (value &environment nil)
	`(+ ,@(loop for (name type) in fields
		    for position from 0
		    collect (remote-type-size-expression type language
			      (if lisp-structure-name
				  (remote-type-lisp-structure-field value
								    lisp-structure-name
								    name)
				  `(aref ,value ,position)))))))
    (:optimizable-common-subexpressions (value)
      (loop for (name type) in fields
	    for position from 0
	    append (remote-type-optimizable-common-subexpressions type language
		     (if lisp-structure-name
			 (remote-type-lisp-structure-field value
							   lisp-structure-name
							   name)
			 `(aref ,value ,position)))))
    (:send (value)
      (once-only (value &environment nil)
	`(progn
	   ,@(loop for (name type) in fields    
		   for position from 0
		   collect (remote-type-send type language
			     (if lisp-structure-name
				 (remote-type-lisp-structure-field value
								   lisp-structure-name
								   name)
				 `(aref ,value ,position)))))))
    (:receive (into storage-mode)
     (case storage-mode
       (:overwrite
	 (once-only (into &environment nil)
	   `(progn
	      ,@(loop for (name type) in fields    
		      for position from 0
		      for place = (if lisp-structure-name
				      (remote-type-lisp-structure-field
					into lisp-structure-name name)
				    `(aref ,into ,position))
		      collect
			`(setf ,place ,(remote-type-receive
					 type language place storage-mode)))
	      ,into)))
       (otherwise
	 (let ((really-into into))
	   (once-only (into &environment nil)
	     `(,(if lisp-structure-name
		    (remote-type-lisp-structure-constructor
		      lisp-structure-name (mapcar #'first fields))
		    (if (eq storage-mode :stack)
			'cli::stack-vector
			'vector))
	       ,@(loop for (name type) in fields    
		       for position from 0
		       collect
			 (remote-type-receive
			   type language
			   (and really-into
				(if lisp-structure-name
				    (remote-type-lisp-structure-field
				      into lisp-structure-name name)
				    `(aref ,into ,position)))
			   storage-mode))))))))
    (:typep (value)
     (if lisp-structure-name `(typep ,value ',lisp-structure-name) `(vectorp ,value))))
  (:c
    (:declare (name) 
     #{ (or c-structure-name
	     #{ struct { (loop for (name type) in fields
				append (remote-type-declaration type language
					 (list (lisp-name-to-c-name name)))
				collect '|;|)
	               } } )
        name })
    ;; Assume the C compiler will do constant-folding for +
    (:size (value)
      (loop for ((name type) . more) on fields
	    with (expression statement)
	    do (multiple-value-setq (expression statement)
		 (remote-type-size-expression type language
		   (remote-type-c-structure-field value name)))
	    append expression into expressions
	    when more append #{+} into expressions
	    append statement into statements
	    finally (return (values expressions statements))))
    (:send (value)
      (loop for (name type) in fields
	    append (remote-type-send type language
				     (remote-type-c-structure-field value name))))
    (:receive (into storage-mode)
      (loop for (name type) in fields
	    append (remote-type-receive type language
		     (remote-type-c-structure-field into name)
		     (and (eq storage-mode ':stack) storage-mode))))
    ;; Structures aren't pointers and don't need freeing, but some fields might be pointers
    (:free (value)
      (loop for (name type) in fields
	    append (remote-type-free type language
				     (remote-type-c-structure-field value name))))))

;; This does things like convert #{*p} and FOO into #{p->foo}.
(defun remote-type-c-structure-field (structure-value field-name)
  (append (cond ((eq (first structure-value) '*)
		 (if (cddr structure-value)
		     #{ ((cdr structure-value))-> }
		     #{ (cdr structure-value)-> }))
		((and (symbolp (first structure-value))	;not a parenthesized star
		      (alpha-char-p (aref (symbol-name (first structure-value)) 0)))
		 #{ structure-value . })
		((eq (car (last structure-value)) '|]|)	;array of structures
		 #{ structure-value . })
		;;--- Maybe this should be a T clause instead?
		((eq (first structure-value) '|(|)
		 #{ structure-value . })		
		(t
		 (error "~S unexpected form of C expression for structure" structure-value)))
	  (list (lisp-name-to-c-name field-name))))

(defun remote-type-lisp-structure-field (structure-value structure-name field-name &aux tem)
  (let ((flavor (flavor:find-flavor structure-name nil 'compile)))
    (when flavor
      (unless (flavor::flavor-components-composed flavor)
	(flavor::compose-flavor-combination structure-name :env 'compile))
      (unless (member field-name (flavor:flavor-all-instance-variables flavor))
	(warn "~S is not an instance variable of flavor ~S" field-name structure-name))
      (dolist (component (flavor:flavor-all-components flavor))
	(when (setq flavor (flavor:find-flavor component nil 'compile))
	  (when (setq tem (find field-name
				(flavor::flavor-local-readable-instance-variables flavor)
				:key #'second))
	    (return-from remote-type-lisp-structure-field
	      `(,(first tem) ,structure-value)))
	  ;;--- Kludge around deficiency in flavor system...accessor substs aren't recorded
	  (when (member field-name (flavor::flavor-local-ordered-instance-variables flavor))
	    (return-from remote-type-lisp-structure-field
	      `(,(intern (string-append component "-" field-name) (symbol-package field-name))
		,structure-value)))))
      (warn "Cannot find an accessor function to read ~S instance variable of flavor ~S"
	    field-name structure-name)
      (return-from remote-type-lisp-structure-field nil)))
  (let ((structure (get structure-name 'si:defstruct-description)))
    (when structure
      (unless (setq tem (assoc field-name (si:defstruct-description-slot-alist structure)))
	(warn "~S is not a slot of defstruct ~S" field-name structure-name))
      (return-from remote-type-lisp-structure-field
	`(,(si:defstruct-slot-description-ref-macro-name (cdr tem)) ,structure-value))))
  (warn "Cannot read ~S field of ~S because it is not defined as a flavor nor as a structure."
	field-name structure-name))

(defun remote-type-lisp-structure-constructor (structure-name field-names)
  (let ((flavor (flavor:find-flavor structure-name nil 'compile)))
    (when flavor
      ;; Try to use a positional-arguments constructor with matching arguments
      (loop for (name . arglist) in (flavor::flavor-constructors flavor) do
	(when (and ( (length arglist) (length field-names))
		   (not (mismatch arglist field-names :end1 (length field-names)))
		   (member (nth (length field-names) arglist)
			   '(nil &optional &rest &key &aux)))
	  (return-from remote-type-lisp-structure-constructor name)))
      ;; No good, use make-instance
      (unless (flavor::flavor-initializations-composed flavor)
	(flavor::compose-initializations structure-name :env 'compile))
      (return-from remote-type-lisp-structure-constructor
	`(lambda ,field-names
	   (make-instance ',structure-name
			  ,@(loop for field in field-names
				  with vars = (flavor:flavor-all-instance-variables flavor)
				  with kwds = (flavor::flavor-all-variable-init-keywords
						flavor)
				  as pos = (1+ (or (position field vars)
						   (progn (warn "~S is not an instance ~
								 variable of flavor ~S"
								field structure-name)
							  0)))
				  collect `',(or (first (find pos kwds :key #'second))
						 (warn "~S is not an initable instance ~
							variable of flavor ~S"
						       field structure-name))
				  collect field))))))
  (let ((structure (get structure-name 'si:defstruct-description)))
    (when structure
      ;; Try to use a positional-arguments constructor with matching arguments
      (loop for (name . stuff) in (si:defstruct-description-constructors structure) do
	(when (and stuff (equal (car stuff) field-names))
	  (return-from remote-type-lisp-structure-constructor name)))
      ;; Use a keyword constructor
      (loop for (name . stuff) in (si:defstruct-description-constructors structure) do
	(when (null stuff)
	  (return-from remote-type-lisp-structure-constructor
	    `(lambda ,field-names
	       (,name ,@(loop for field in field-names
			      collect (intern (string field) pkg-keyword-package)
			      collect field))))))
      (warn "Cannot make a ~S structure because no suitable constructor has been defined."
	    structure-name)
      (return-from remote-type-lisp-structure-constructor nil)))
  (warn "Cannot make a ~S because it is not defined as a flavor nor as a structure."
	structure-name))

;;;; Compound Types 2: Vectors

;;; Expand into one of several different implementation types depending on the packing
;;; This is just to make the code easier to understand by avoiding huge functions
;;; :nibble values for packing could be implemented, I guess, if needed
(define-remote-type vector (element-type &optional length)
  (:prologue ()
    (unless (remote-type-specifier-p element-type)
      (type-error "The vector element type ~S has not been defined as a remote type."
		  element-type))
    (unless (typep length '(or null (integer 0 *)))
      (type-error "~S is not valid for a vector length." length)))
  (:abbreviation-for
    (let ((lengthl (and length (list length))))
      (ecase (remote-type-packed element-type)
	((nil) `(general-vector ,element-type ,@lengthl))
	((:word) `(word-vector ,@lengthl))
	((:single-float) `(single-float-vector ,@lengthl))
	((:halfword) (if (remote-type-signed element-type)
			 `(signed-halfword-vector ,@lengthl)
			 `(halfword-vector ,@lengthl)))
	((:byte) (cond ((eq element-type 'character-8) `(char-vector ,@lengthl))
		       ((remote-type-signed element-type) `(signed-byte-vector ,@lengthl))
		       (t `(byte-vector ,@lengthl))))
	((:nibble) `(nibble-vector ,@lengthl))
	((:bit) `(bit-vector ,@lengthl)))))
  ;; Shareable portions of the language support
  (:lisp
    (:typep (value) `(vectorp ,value)))		;don't try to do anything with element type
  (:c
    (:declare (name)
      ;; A vector is always represented in C as a pointer.  If the length is fixed,
      ;; or the vector is a C-string or Pascal-string, this pointer just points to
      ;; the first element.  Otherwise it points to a structure whose first field
      ;; is named length, the number of elements, and whose second field is named
      ;; element, the array of elements.  C-string and Pascal-string are not handled
      ;; here, those remote types shadow this quasi method.
      ;; We never use the [ ] syntax for declaring these, since we want the representation
      ;; to be a pointer, even if fixed-length, and call-by-value never to be used.
      (if length
	  ;; Fixed length case
	  (remote-type-declaration element-type language #{ *name })
	  ;; Variable length case -- will be a structure of length and element
	  #{ (declare-c-type (intern (if (atom element-type)
					  (string-append element-type "-VECTOR")
					  (with-output-to-string (s)
					    (loop for item in element-type
						  with first = t do
					      (when (or (symbolp item) (integerp item))
						(if first (setq first nil)
						    (princ "-" s))
						(princ item s)))
					    (princ "-VECTOR" s)))
				      *rpc-package*)
			      #{ struct { LongInt length;
					  (remote-type-declaration element-type language
					     (list (lisp-name-to-c-name 'element)))
					   [STRUCT_POINTER_SIZE];
					}* } )
	     name }))))

;;; Like vector but in C the pointer and length are passed separately, instead
;;; of using a structure that is like an array with a fill-pointer.  A fixed
;;; length version of this would not make sense so we don't accept that argument.
(define-remote-type spread-vector (element-type)
  (:prologue ()
    (unless (remote-type-specifier-p element-type)
      (type-error "The vector element type ~S has not been defined as a remote type."
		  element-type)))
  (:abbreviation-for
    (ecase (remote-type-packed element-type)
      ((nil) `(general-vector ,element-type nil t))
      ((:word) `(word-vector nil t))
      ((:single-float) `(single-float-vector nil t))
      ((:halfword) (if (remote-type-signed element-type)
		       `(signed-halfword-vector nil t)
		       `(halfword-vector nil t)))
      ((:byte) (cond ((eq element-type 'character-8) `(char-vector nil t))
		     ((remote-type-signed element-type) `(signed-byte-vector nil t))
		     (t `(byte-vector nil t))))
      ((:nibble) `(nibble-vector nil t))
      ((:bit) `(bit-vector nil t))))
  ;; Shareable portions of the language support
  (:lisp
    (:typep (value) `(vectorp ,value)))		;don't try to do anything with element type
  (:c
    (:declare (name)
      (error "INTERNAL ERROR: The variable ~\\c-token-list\\ wasn't ~
		supposed to appear as a C variable" name))
    (:translate-argument (name)
      ;; First the pointer, then the length
      `((,(spread-vector-pointer name) (vector ,element-type 0))
	(,(spread-vector-length name) integer-32)))))

;;; Access to the variables containing the separate parts of a spread vector
(defun spread-vector-pointer (name)
  (intern (string-append name "-PTR")))

(defun spread-vector-length (name)
  (intern (string-append name "-LEN")))

;;; Similar for C.  name must be foo or *foo or (*foo), or if the thing came from the
;;; user already spread, name is (SPREAD foo_ptr foo_len).
(defun c-spread-vector-pointer (name)
  (when (and (= (length name) 3) (eq (first name) 'spread))
    (return-from c-spread-vector-pointer (second name)))
  (when (and (= (length name) 4) (eq (first name) '|(|) (eq (fourth name) '|)|)
	     (eq (second name) '*) (symbolp (third name)))
    (return-from c-spread-vector-pointer
      #{ (* (intern (string-append (third name) "_ptr") *rpc-package*) ) } ))
  (unless (and (or (= (length name) 1)
		   (and (= (length name) 2) (eq (first name) '*)))
	       (symbolp (car (last name))))
    (error "INTERNAL ERROR: The spread vector named ~\\c-token-list\\ is not ~
		in an expected form" name))
  (append (butlast name)
	  (list (intern (string-append (car (last name)) "_ptr") *rpc-package*))))

(defun c-spread-vector-length (name)
  (when (and (= (length name) 3) (eq (first name) 'spread))
    (return-from c-spread-vector-length (third name)))
  (when (and (= (length name) 4) (eq (first name) '|(|) (eq (fourth name) '|)|)
	     (eq (second name) '*) (symbolp (third name)))
    (return-from c-spread-vector-length
      #{ (* (intern (string-append (third name) "_len") *rpc-package*) ) } ))
  (unless (and (or (= (length name) 1)
		   (and (= (length name) 2) (eq (first name) '*)))
	       (symbolp (car (last name))))
    (error "INTERNAL ERROR: The spread vector named ~\\c-token-list\\ is not ~
		in an expected form" name))
  (append (butlast name)
	  (list (intern (string-append (car (last name)) "_len") *rpc-package*))))


;;; The following eleven types are internal and not documented for users, who should
;;; always get to these indirectly through vector

(define-remote-type byte-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 4 ,length ,spread
				     send-byte-vector receive-byte-vector (unsigned-byte 8))))

(define-remote-type signed-byte-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 4 ,length ,spread
				     send-signed-byte-vector receive-signed-byte-vector
				     (signed-byte 8))))

(define-remote-type char-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 4 ,length ,spread
				     send-char-vector receive-char-vector string-char)))

(define-remote-type nibble-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 8 ,length ,spread
				     send-nibble-vector receive-nibble-vector (unsigned-byte 4))))

(define-remote-type bit-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 32 ,length ,spread
				     send-bit-vector receive-bit-vector bit)))

(define-remote-type halfword-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 2 ,length ,spread
				     send-halfword-vector receive-halfword-vector
				     (unsigned-byte 16))))

(define-remote-type signed-halfword-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 2 ,length ,spread
				     send-signed-halfword-vector receive-signed-halfword-vector
				     (signed-byte 16))))

(define-remote-type word-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 1 ,length ,spread
				     send-word-vector receive-word-vector fixnum)))

(define-remote-type single-float-vector (&optional length spread)
  (:abbreviation-for `(packed-vector 1 ,length ,spread
				     send-single-float-vector receive-single-float-vector
				     single-float)))

;;; Common support for all packed vectors
(define-remote-type packed-vector (elements-per-word length spread
				   send-function receive-function lisp-element-type)
  (:size
    (and length (ceiling length elements-per-word)))
  (:lisp
    (:size (value)
      ;; Size is the number of words for the elements plus 1 for a length word in front
      (cond (length
	     (ceiling length elements-per-word))
	    ((= elements-per-word 1)
	     `(1+ (vector-length ,value)))
	    (t
	     `(1+ (%fixnum-ceiling (vector-length ,value) ,elements-per-word)))))
    (:optimizable-common-subexpressions (value)
     (and (not length) `((vector-length ,value))))
    (:send (value)
      (if length
	  `(,send-function ,value 0 ,length)
	  `(progn
	     (send-word (vector-length ,value))
	     (,send-function ,value 0 (vector-length ,value)))))
    (:receive (into storage-mode)
      (if (eq storage-mode ':overwrite)
	  `(progn ,@(unless length
		      `((setf (fill-pointer ,into) (receive-word))))
		  (,receive-function ,into)
		  ,into)
	  `(let ((vector (,(if (eq storage-mode :stack) 'make-stack-array 'make-array)
			  ,(or length `(receive-word))
			  :element-type ',lisp-element-type)))
	     (,receive-function vector)
	     vector))))
  (:c
    (:size (value)
      ;; Size is the number of words for the elements plus 1 for a length word in front
      (cond (length #{ (ceiling length elements-per-word) } )	;size is constant
	    (spread #{ ( (c-spread-vector-length value) + (1- elements-per-word) )
		       / elements-per-word
		       + 1 } )			;+1 for length word at front
	    (t #{ ( value -> length + (1- elements-per-word) )
		  / elements-per-word
		  + 1 } )))			;+1 for length word at front
    (:send (value)
      (let ((send-function (lisp-name-to-c-name send-function)))
	(cond (length #{ send-function(value , length); }
		      )
	      (spread #{ send_word((c-spread-vector-length value));
			 send-function((c-spread-vector-pointer value),
					 (c-spread-vector-length value)); }
		      )
	      (t #{ send_word(value ->length);
		    send-function(value ->element, value ->length);
		  } ))))
    (:receive (into storage-mode)
      (let ((receive-function (lisp-name-to-c-name receive-function))
	    (into-ptr (cond (length into)
			    (spread (c-spread-vector-pointer into))
			    (t #{ into ->element } )))
	    (into-len (cond (length nil)
			    (spread (c-spread-vector-length into))
			    (t #{ into ->length } ))))
	(cond ((eq storage-mode ':stack)
	       (if spread
		   #{ into-len = receive_word();
		      into-ptr = (void*)get_receive_pointer();
		      advance_receive_pointer((remote-type-size-expression original-type
									    language into)
					      - 1); }
		   #{ into = (void*)get_receive_pointer();
		      advance_receive_pointer((if length
						   (list (ceiling length elements-per-word))
						   (remote-type-size-expression original-type
										language into)
					      )); }
		   ))
	      ((eq storage-mode ':overwrite)
	       (if length
		   ;; See RPC.C for a comment on ANSI standard memory allocation.
		   #{ receive-function(into-ptr , length );
		    }
		   #{ into-len = receive_word();
		      receive-function(into-ptr , into-len );
		    } ))
	      (length
	       ;; See RPC.C for a comment on ANSI standard memory allocation.
	       #{ system_error_code = AllocateMemory((* (ceiling length elements-per-word)
							  4) ,
						     (void **)&into-ptr);
	          if ( system_error_code ) return ( system_error_code );
	          receive-function(into-ptr , length );
		} )
	      (t
	       (let ((length (declare-c-variable 'length #{LongInt})))
		 #{ length = receive_word();
		    system_error_code = AllocateMemory((( length + (1- elements-per-word) )
							/ elements-per-word
							(unless spread #{ + 1 })
						       ) << 2,
						       (void **)&(if spread into-ptr into));
		    if ( system_error_code ) return ( system_error_code );
		    into-len = length ;
		    receive-function(into-ptr , into-len );
		  } )))))))

;;; Unpacked vectors.  These have to be processed element by element with do loops.
;;; The XDR size of an element can be fixed or variable.
;;; This is where variable length data come home to roost.
(define-remote-type general-vector (element-type &optional length spread)
  (:prologue ((element-size (remote-type-fixed-size element-type))))	;NIL if variable
  (:size (and length element-size (* length element-size)))
  (:lisp
    (:size (value)
      ;; Size is the number of words for the elements plus 1 for a length word in front
      (if element-size
	  (if length
	      (* length element-size)
	      `(1+ (* (vector-length ,value) ,element-size)))
	  ;; Variable size elements, actually have to look at their values
	  (let ((elt (gensym)))
	    (if length
		`(loop for ,elt being the array-elements of ,value below ,length
		       sum ,(remote-type-size-expression element-type language elt))
		`(1+ (loop for ,elt being the array-elements of ,value
			   sum ,(remote-type-size-expression element-type language elt)))))))
    (:optimizable-common-subexpressions (value)
     (and (not length) `((vector-length ,value))))
    (:send (value)
     (let ((elt (gensym)))
       `(loop ,@(unless length `(initially (send-word (vector-length ,value))))
	      for ,elt being the array-elements of ,value
		       below ,(or length `(vector-length ,value))
	      do ,(remote-type-send element-type language elt))))
    (:receive (into storage-mode)
      (if (eq storage-mode ':overwrite)
	  `(progn ,@(unless length
		      `((setf (fill-pointer ,into) (receive-word))))
		  (dotimes (.index. (or length (fill-pointer ,into)))
		    (setf (aref ,into .index.) ,(remote-type-receive element-type language)))
		  ,into)
	  `(let* ((.length. ,(or length `(receive-word)))
		  (.vector. (,(if (eq storage-mode :stack) 'make-stack-array 'make-array)
			     .length.)))
	     (declare (sys:array-register .vector.))
	     (dotimes (.index. .length.)
	       (setf (aref .vector. .index.) ,(remote-type-receive element-type language)))
	     .vector.))))
  (:c
    (:size (value)
      ;; Size is the number of words for the elements plus 1 for a length word in front
      (if element-size
	  (cond (length #{ (* length element-size) } )
		(spread #{ (c-spread-vector-length value) * element-size + 1 } )
		(t #{ value -> length * element-size + 1 } ))
	  ;; Variable size elements, actually have to look at their values
	  (let* ((sum (declare-c-variable 'sum #{LongInt}))
		 (idx (declare-c-variable 'idx #{LongInt}))
		 (elt (cond (length (c-subscript value idx))
			    (spread #{ (c-spread-vector-pointer value) [ idx ] } )
			    (t #{ value -> element [ idx ] } )))
		 (len (cond (length #{ length } )
			    (spread (c-spread-vector-length value))
			    (t #{ value -> length } ))))
	    (multiple-value-bind (element-size element-statement)
		(remote-type-size-expression element-type language elt)
	      (values sum
		      #{ sum = (if length 0 1);
			 for ( idx = 0; idx < len; idx ++
			      )
			  { element-statement
			    sum += element-size; };
		       })))))
    (:send (value)
      (let* ((idx (declare-c-variable 'idx #{LongInt}))
	     (elt (cond (length (c-subscript value idx))
			(spread #{ (c-spread-vector-pointer value) [ idx ] } )
			(t #{ value -> element [ idx ] } )))
	     (len (cond (length #{ length } )
			(spread (c-spread-vector-length value))
			(t #{ value -> length } ))))
	#{ (unless length
	      #{ send_word(len); }
	      )
	   for ( idx = 0; idx < len; idx ++
		)
	    { (remote-type-send element-type language elt) };
	 }))
    (:receive (into storage-mode)
      (let* ((idx (declare-c-variable 'idx #{LongInt}))
	     (elt (cond (length (c-subscript into idx))
			(spread #{ (c-spread-vector-pointer into) [ idx ] } )
			(t #{ into -> element [ idx ] } )))
	     (elt-size #{ sizeof(elt) })
	     (len (if length #{ length } (declare-c-variable 'length #{LongInt})))
	     (into-ptr (if spread (c-spread-vector-pointer into) into)))
	#{ (unless length
	      #{ len = receive_word(); }
	      )
	   (unless (eq storage-mode ':overwrite)
	      #{ system_error_code = AllocateMemory((LongInt)(len * elt-size * 4),
						    (void **)&into-ptr );
		 if ( system_error_code ) return ( system_error_code );
	       } )
	   (unless length
	      (if spread
		  #{ (c-spread-vector-length into) = len; }
		  #{ into -> length = len; }
		  ))
	   for( idx = 0; idx < len; idx ++
	       )
	     { (remote-type-receive element-type language elt
				     (and (eq storage-mode ':stack) storage-mode)) };
	 }))
    (:free (value)
      (append
	;; First see if any code needs to be generated to free the elements, to avoid
	;; declaring idx if it's not used
	(when (remote-type-free element-type language #{elt})
	  (let* ((idx (declare-c-variable 'idx #{LongInt}))
		 (elt (cond (length (c-subscript value idx))
			    (spread #{ (c-spread-vector-pointer value) [ idx ] } )
			    (t #{ value -> element [ idx ] } )))
		 (len (cond (length #{ length } )
			    (spread (c-spread-vector-length value))
			    (t #{ value -> length } ))))
	    #{ for ( idx = 0; idx < len; idx ++
		    )
		{ (remote-type-free element-type language elt) };
	     }))
	;; Now free the vector itself
	#{ system_error_code = FreeMemory((void **)&value );
	   if ( system_error_code ) return ( system_error_code );
	 } ))))

(defun c-subscript (array index)
  (if (cdr array)
      #{ (array)[ index ] }
      #{ array [ index ] }))

;;;; Compound Types 3: Unions

(define-remote-type or (&rest possible-types)
  (:prologue ()
    (dolist (possible-type possible-types)
      (unless (remote-type-specifier-p possible-type)
	(type-error "The remote type ~S is not defined, in an OR." possible-type)))
    (let ((type-names (loop for type in possible-types
			    collect (if (atom type) type (car type)))))
      (loop for (this . that) on type-names do
	(when (member this that)
	  (type-error "The type name ~S occurs twice in ~S" this type))))
    (let ((typeps (loop for type in possible-types
			    collect (remote-typep type ':lisp 'value))))
      (loop for (this . that) on typeps for pos from 0 do
	(when (member this that :test #'equal)
	  (type-error "The types ~S and ~S in ~S~%do not have distinguishable Lisp values."
		      (nth pos possible-types)
		      (nth (+ pos 1 (position this that :test #'equal)) possible-types)
		      type)))))
  ;; Check for fixed size, return NIL if any field is variable size or if the
  ;; fields differ in size
  (:size (loop for type in possible-types
	       as size = (remote-type-fixed-size type)
	       do (unless size (return nil))
	       maximize size into max
	       minimize size into min
	       finally (when (= min max) (return (1+ max)))))
  (:lisp
    (:typep (value)
      `(or ,@(loop for type in possible-types
		   collect (remote-typep type language value))))
    (:size (value)
      `(1+ (cond ,@(loop for type in possible-types
			 collect `(,(remote-typep type language value)
				   ,(remote-type-size-expression type language value)))
		 (t (dbg:check-type-1 'value ,value ',original-type nil t)))))
    ;; :optimizable-common-subexpressions would seem nice here, but unfortunately
    ;; we can't conditionalize them by the discriminant, so just punt
    (:send (value)
      `(cond ,@(loop for type in possible-types
		     for discriminant from 0
		     collect `(,(remote-typep type language value)
			       (send-word ,discriminant)
			       ,(remote-type-send type language value)))
	     (t (dbg:check-type-1 'value ,value ',original-type nil t))))
    (:receive ()
      `(case (receive-word)
	 ,@(loop for type in possible-types
		 for discriminant from 0
		 collect `(,discriminant
			   ,(remote-type-receive type language)))
	 (otherwise (error "Invalid discriminant received for ~S" ',original-type))))
    (:preprocess (value)
     `(cond ,@(loop for type in possible-types
		    for preprocess = (remote-type-preprocess type language value)
		    when preprocess
		      collect (list (remote-typep type language value) preprocess)))))
  (:c
    (:declare (name)
      (let ((type-names (loop for type in possible-types
			      collect (if (atom type) type (car type)))))
	#{ (declare-c-type (intern (format nil "union~{_~A~}" type-names) *rpc-package*)
			    #{ struct { enum { (loop for (type . more) on type-names
						      collect (lisp-name-to-c-name
								(string-append type "_type"))
						      when more append #{,})
					     } type;
					union { (loop for type in possible-types
						       and name in type-names
						       as cname = #{ (lisp-name-to-c-name
									     name) }
						       append (remote-type-declaration
								type language cname)
						       collect '|;|)
					      } value;
				      } })
	   name }))
    (:size (value)
      (let ((size (declare-c-variable 'size #{LongInt})))
	(values #{ size + 1 }		;+1 for the discriminant
		#{ switch ( value .type )
		    { (loop for type in possible-types
			     for discriminant from 0
			     as field = (lisp-name-to-c-name (if (atom type) type (car type)))
			     append
			       (multiple-value-bind (expr stmt)
				   (remote-type-size-expression type language
								#{ value .value. field })
				 #{ case discriminant : stmt
						          size = expr ;
						          break; }
				    )) };
		 })))
    (:send (value)
      #{ send_word( value .type);
         switch ( value .type )
          { (loop for type in possible-types
		   for discriminant from 0
		   as field = (lisp-name-to-c-name (if (atom type) type (car type)))
		   as send = (remote-type-send type language #{ value .value. field })
		   append #{ case discriminant : send
					           break; }
		   ) };
       })
    (:receive (into storage-mode)
      (let ((discriminant (declare-c-variable 'discriminant #{int})))
	#{ discriminant = receive_word();
	   into . type = discriminant;
	   switch ( discriminant )
	    { (loop for type in possible-types
		     for discriminant from 0
		     as field = (lisp-name-to-c-name (if (atom type) type (car type)))
		     as rcv = (remote-type-receive type language #{ into .value. field }
						   (and (eq storage-mode ':stack)
							storage-mode))
		     append #{ case discriminant : rcv
						     break; }
		     ) };
	 }))
    (:free (value)
      ;; First check whether we need to generate any code
      (when (loop for type in possible-types
		  thereis (remote-type-free type language #{value}))
	#{ switch ( value .type )
	    { (loop for type in possible-types
		     for discriminant from 0
		     as field = (lisp-name-to-c-name (if (atom type) type (car type)))
		     as free = (remote-type-free type language #{ value .value. field })
		     when free
		       append #{ case discriminant : free
						       break; }
		     ) };
	 }))))

;;;; Compound Types 4: Opaque Data

(define-remote-type opaque-bytes (&rest options)
  (:prologue ((length nil)	;nil if variable length, number of bytes if fixed length
	      (structure nil)	;structure type for current language
	      (pointer-p t)	;receive as a pointer
	      (length-function nil))		;for current language
    (let ((pointer-p-p nil))
      (loop for option in options do
	(cond ((atom option)
	       (type-error
		 "The option ~S is supposed to be a list of an option name and arguments."
		 option))
	      ((eq (first option) ':length)
	       (if (and (rest option)
			(typep (second option) '(integer 0 *))
			(null (rest (rest option))))
		   (setq length (second option))
		   (type-error
		     "The option ~S is supposed to have one argument, the number of bytes."
		     option)))
	      ((eq (first option) ':pointer-p)
	       (setq pointer-p (second option)))
	      ((member (first option) *known-languages*)
	       (when (eq (first option) ':lisp)
		 (type-error "Structure names are not supported for the Lisp language."))
	       (if (rest option)
		   (when (eq (first option) language)
		     (destructuring-bind (structure-option &optional length-option)
			 (rest option)
		       (setq structure (if (symbolp structure-option)
					   structure-option
					   (eval structure-option)))
		       (when length-option
			 (if (eq (first length-option) ':length)
			     (setq length-function `(lambda . ,(rest length-option)))
			     (type-error
  "The option ~S is supposed to have the declaration followed by :LENGTH and a length function."
			       option)))))
		   (type-error
		     "The option ~S is supposed to have one argument, the ~A structure name."
		     option (first option))))
	      (t
	       (type-error "~S is neither :LENGTH nor the name of a known language."
			   (first option)))))
      (unless pointer-p-p
	(setq pointer-p (if structure (search #{*} structure) (null length))))))
  (:size (and length (ceiling length 4)))
  ;; The Lisp representation is simply the foreign representation as a vector of bytes
  (:lisp
    (:size (value)
      (if length (ceiling length 4)
	  `(1+ (%fixnum-ceiling (vector-length ,value) 4))))
    (:optimizable-common-subexpressions (value)
     (and (not length) `((vector-length ,value))))
    (:send (value)
      (if length
	  `(send-byte-vector ,value 0 ,length)
	  (once-only (value &environment nil)
	    `(progn (send-word (vector-length ,value))
		    (send-byte-vector ,value 0 (vector-length ,value))))))
    (:receive (into storage-mode)
      (if (eq storage-mode ':overwrite)
	  `(progn ,@(unless length
		      `((setf (fill-pointer ,into) (receive-word))))
		  (receive-byte-vector ,into)
		  ,into)
	  `(let ((array (,(if (eq storage-mode :stack) 'make-stack-array 'make-array)
			 ,(or length `(receive-word))
			 :element-type '(unsigned-byte 8))))
	     (receive-byte-vector array)
	     array)))
    (:typep (value)
      `(vectorp ,value)))
  (:c
    (:declare (name) 
      (cond (structure #{ structure name })
	    ((and length (not pointer-p)) #{ unsigned char name [ length ] })
	    (t #{ unsigned char* name })))
    (:size (value)
      (cond (length #{ (LongInt)(ceiling length 4) })
	    (length-function #{ ((((funcall length-function value) ) + 7) >> 2) })
	    (structure #{ ((sizeof(structure) + 7) >> 2) })
	    (t
	     (ignore value)
	     (type-error "Cannot compute size of opaque-bytes in C")
	     0)))
    (:send (value)
      (let ((length-place (cond (length #{length })
				(length-function (funcall length-function value))
				(structure #{sizeof(structure )})
				(t (type-error "Cannot compute size of opaque-bytes in C")))))
	#{ (unless length			;Parallel to :lisp :receive above.
	      #{ send_word(length-place ); }
	      )
	   send_byte_vector((unless pointer-p #{&}) value , (LongInt)length-place ); }
	))
    (:receive (into storage-mode)
      (let ((length-place (cond (length #{length })
				(length-function (funcall length-function into))
				(structure #{sizeof(structure )})))
	    (length-form nil))
	(unless length				;Parallel to :lisp :send above.
	  (setq length-place (declare-c-variable 'length #{LongInt})
		length-form #{ length-place = receive_word(); }
		))
	(cond ((not pointer-p)
	       #{ length-form
	          receive_byte_vector(into , length-place );
		  })
	      ((eq storage-mode ':stack)
	       ;; we assume that the C compiler is able to optimize this when length.
	       #{ length-form
		  into = (void*)get_receive_pointer();
		  advance_receive_pointer((length-place + 3) >> 2);
		  })
	      ((eq storage-mode ':overwrite)
	       #{ length-form
		  receive_byte_vector(into , length-place );
		  })
	      (t
	       #{ length-form
		  system_error_code = AllocateMemory(length-place , (void **)&into);
		  if ( system_error_code ) return ( system_error_code );
		  receive_byte_vector(into , length-place );
		  }))))))

;;;; Derived Compound Types

(define-remote-type string (&optional length)
  (:abbreviation-for `(vector character-8 ,@(and length `(,length)))))

(define-remote-type pascal-string ()
  (:abbreviation-for `(vector character-8))	;This abbreviation is only used for Lisp
  (:c
    (:declare (name) #{ unsigned char* name })
    (:size (value) #{ ((LongInt)((c-subscript value #{0}) + 7) >> 2) })
    (:send (value) #{ send_word((c-subscript value #{0}));
		      send_char_vector(& (c-subscript value #{1}),
				       (c-subscript value #{0}));
		    })
    (:receive (into storage-mode)
     (cond ((eq storage-mode ':stack)
	    ;; This only works on big-ender machines, otherwise we could have to move
	    ;; the count field into the high byte of the length word    
	    #{ into = (unsigned char*)get_receive_pointer() + 3;
	       advance_receive_pointer((remote-type-size-expression original-type language
								     into));
	     } )
	   ((eq storage-mode ':overwrite)
	    #{ (c-subscript into #{0}) = receive_word();
	       receive_char_vector(& (c-subscript into #{1}), (c-subscript into #{0}));
	     } )
	   (t
	    (let ((length (declare-c-variable 'length #{LongInt})))
	      #{ length = receive_word();
		 system_error_code = AllocateMemory(length + 1, (void **)&into);
		 if ( system_error_code ) return ( system_error_code );
		 (c-subscript into #{0}) = length;
		 receive_char_vector(& (c-subscript into #{1}), length);
	       } )))))
  (:lisp
    (:send (value)
      `(progn (compiler:%error-unless (< (vector-length ,value) 256)
		(error "~S is too long to be a Pascal string" ,value))
	      ,(remote-type-send `(vector character-8) language value)))))

;; This assumes the C strings library is linked in
;; and that the user doesn't mind having a stupid 16-bit limit on maximum string length
(define-remote-type c-string ()
  (:abbreviation-for `(vector character-8))	;This abbreviation is only used for Lisp
  (:c
    (:declare (name) #{ char* name })
    (:size (value) #{ ((LongInt)(strlen(value) + 7) >> 2) })
    (:send (value) 
      (let ((length (declare-c-variable 'length #{LongInt})))
	#{ length = strlen(value);
	   send_word(length);
	   send_char_vector(value, length);
	 }))
    (:receive (into storage-mode)
      (let ((length (declare-c-variable 'length #{LongInt})))
	(cond ((eq storage-mode ':stack)
	       #{ length = receive_word();
		  into = (char*)get_receive_pointer() - 1;
		  CopyMemory((void *)(into + 1), (void *)into, length);
		  (c-subscript into length) = 0;
		  advance_receive_pointer((length + 3) >> 2);
		} )
	      ((eq storage-mode ':overwrite)
	       #{ length = receive_word();
		  receive_char_vector(into, length);
		  (c-subscript into length) = 0;
		} )
	      (t
	       #{ length = receive_word();
		  system_error_code = AllocateMemory(length + 1, (void **)&into);
		  if ( system_error_code ) return ( system_error_code );
		  receive_char_vector(into, length);
		  (c-subscript into length) = 0;
		}))))))

(define-remote-type enumeration (&rest symbols-and-values)
  (:size 1)
  (:prologue ()
	     (unless (every #'(lambda (element)
				(and (symbolp (first element))
				     (fixnump (second element))))
			    symbols-and-values)
	       (type-error
		 "The elements of ~S are required to be lists of symbols and integer values."
		 type)))
  (:lisp
    (:encode (value) `(second (assoc ,value ',symbols-and-values)))
    (:decode (value) `(first (rassoc ,value ',symbols-and-values :key #'car)))
    (:typep (value)
     (case (length symbols-and-values)
       (0 `'nil)
       (1 `(eql ,value ',(first (first symbols-and-values))))
       (2 `(or (eql ,value ',(first (first symbols-and-values)))
	       (eql ,value ',(first (second symbols-and-values)))))
       (otherwise `(not (null (assoc ,value ',symbols-and-values)))))))
  (:c
    (:declare (name) 
     #{ enum { (loop for ((symbol value) . more) on symbols-and-values
		      append #{(lisp-name-to-c-name symbol) = value }
		      when more append #{,})
     } name })
    (:encode (value) #{(LongInt)value })
    (:decode (value) #{(int)value })))

(define-remote-type list (element-type)
  (:prologue ((element-size (remote-type-fixed-size element-type))
	      (list-type-name
		(intern (string-append
			  "list_"
			  (if (atom element-type) element-type (car element-type)))
			*rpc-package*))))
  (:lisp
    (:size (value)
     (if element-size
	 ;; Size is the element size plus one for a TRUE for each element,
	 ;; and a final word for a FALSE at the end.
	 `(1+ (* (list-length ,value) ,(1+ element-size)))
       ;; Variable size elements, actually have to look at their values
       `(loop for element in ,value
	      summing (1+ ,(remote-type-size-expression element-type language `element))
		into size
	      finally (return (1+ size)))))
    (:send (value)
     `(loop for element in ,value
	    do (send-word 1)			;send a TRUE to indicate another element
	       ,(remote-type-send element-type language `element)
	    finally (send-word 0)))		;indicate end-of-list with a FALSE
    (:receive (ignore ignore)
     `(loop while (not (zerop (receive-word)))	;any more?
	    collecting ,(remote-type-receive element-type language))))
    (:c
      (:declare (name)
       (let ((struct-name (lisp-name-to-c-name (string-append list-type-name "-STRUCT"))))
	 #{ (declare-c-type list-type-name
			     #{ struct  struct-name
			       { (remote-type-declaration element-type language nil) element;
			         struct struct-name *rest;
				 } *})
	     name }))
      (:size (value)
       (let ((size (declare-c-variable 'size #{LongInt}))
	     (pointer
	       (declare-c-variable 'pointer #{ (lisp-name-to-c-name list-type-name)})))
	 (values #{ size }
		 (multiple-value-bind (expression statement)
		     (remote-type-size-expression
		       element-type language #{pointer -> element })
		   #{ for (pointer = value , size = 1;
			   pointer != NULL;
			   pointer = pointer -> rest)
		       { statement ;
		         size += 1 + expression ;
		       } }))))
      (:send (value)
       (let ((pointer
	       (declare-c-variable 'pointer #{ (lisp-name-to-c-name list-type-name)})))
	 #{ for (pointer = value;
		 pointer != NULL; 
	         pointer = pointer -> rest)
	      { (remote-type-send 'integer-32 language #{1})
                (remote-type-send element-type language #{pointer -> element})
		}
	    (remote-type-send 'integer-32 language #{0})
	    }))
      (:receive (into storage-mode)
       (let ((pointer
	       (declare-c-variable 'pointer #{ (lisp-name-to-c-name list-type-name)}))
	     (previous (declare-c-variable 'prev #{ (lisp-name-to-c-name list-type-name)}))
	     (tmp (declare-c-variable 'tmp #{ LongInt })))
	 (ignore storage-mode)			;; --- Sigh
	 #{ into = NULL;
	    previous = NULL;
	    while (true) {
	      (remote-type-receive 'integer-32 language #{ tmp })
	      if ( tmp == 0 )
	        break;
              system_error_code =
	        AllocateMemory(sizeof(*pointer),(void **)&pointer);
	      if (system_error_code) return (system_error_code);
	      pointer -> rest = NULL;
	      (remote-type-receive element-type :c #{ pointer ->element } )
	      if (into == NULL) into = pointer;
	      if (previous != NULL) previous ->rest = pointer;
	      previous = pointer;
	      }
          }))
      (:free (value)
       (let ((pointer
	       (declare-c-variable 'pointer #{ (lisp-name-to-c-name list-type-name)}))
	     (next (declare-c-variable 'next #{ (lisp-name-to-c-name list-type-name)})))
	 #{ for (pointer = value;
	         pointer != NULL; 
	         pointer = next)
              { (remote-type-free element-type language #{pointer -> element})
                next = pointer -> rest;
	        system_error_code = FreeMemory((void **)&pointer);
	        if (system_error_code) return (system_error_code);
          }}))))
