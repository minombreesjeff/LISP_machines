;;; -*- Mode: LISP; Syntax: Lisp+C; Package: RPC; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Macros for defining remote modules, entries, and errors

(DEFPROP DEFINE-REMOTE-MODULE "Remote Module" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-REMOTE-MODULE (MODULE-NAME &REST OPTIONS)
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION MODULE-NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-MODULE))
    (PARSE-MACRO-OPTIONS DEFINE-REMOTE-MODULE OPTIONS
			 (VERSION
			  NUMBER
			  ALLOW-UNTRUSTED-ACCESS)
			 (SERVER
			  CLIENT
			  (PROCESS `(:NAME ,(STRING MODULE-NAME)))
			  AUTHENTICATION)
      (UNLESS NUMBER
	(SETQ NUMBER 0)
	(WARN "The :NUMBER option to DEFINE-REMOTE-MODULE is mandatory."))
      (UNLESS (FIXNUMP NUMBER)
	(WARN "The :NUMBER option to DEFINE-REMOTE-MODULE must be a 32-bit integer."))
      (UNLESS VERSION
	(SETQ VERSION 0)
	(WARN "The :VERSION option to DEFINE-REMOTE-MODULE is mandatory."))
      (UNLESS (FIXNUMP VERSION)
	(WARN "The :VERSION option to DEFINE-REMOTE-MODULE must be a 32-bit integer."))
      (UNLESS (OR SERVER CLIENT)
	(WARN "At least one of :SERVER or :CLIENT must be specified."))
      (UNLESS (SUBSETP SERVER *KNOWN-LANGUAGES*)
	(WARN "~S contains an unknown language name.  Use one of ~S."
	      (CONS ':SERVER SERVER) *KNOWN-LANGUAGES*))
      (UNLESS (SUBSETP CLIENT *KNOWN-LANGUAGES*)
	(WARN "~S contains an unknown language name.  Use one of ~S."
	      (CONS ':CLIENT CLIENT) *KNOWN-LANGUAGES*))
      (WHEN (EQUAL PROCESS '(NIL))
	(SETQ PROCESS NIL))
      (UNLESS (AND (LISTP PROCESS)
		   (EVENP (LENGTH PROCESS))
		   (LOOP FOR (KWD) ON PROCESS BY #'CDDR
			 ALWAYS (KEYWORDP KWD)))
	(WARN "~S is an invalid :PROCESS option.  It must be either NIL or an~@
	       alternating sequence of process creation keyword options and values."
	      PROCESS)
	(SETQ PROCESS `(:NAME ,(STRING MODULE-NAME))))
      (LOOP FOR AUTHENTICATION-TYPE IN AUTHENTICATION
	    UNLESS (MEMBER AUTHENTICATION-TYPE *AUTHENTICATION-TYPES*)
	      DO (WARN "~S is not a valid authentication type (one of ~{~#[~1;or ~]~S~^, ~})."
		   AUTHENTICATION-TYPE *AUTHENTICATION-TYPES*)
		 (SETQ AUTHENTICATION (DELETE AUTHENTICATION-TYPE AUTHENTICATION)))
      (LET* ((VARIABLE (AND (MEMBER ':LISP CLIENT)
			    (INTERN (FORMAT NIL "*~A-REMOTE-MODULE*" MODULE-NAME))))
	     (INITARGS `(:NAME ,MODULE-NAME
			:VARIABLE ,VARIABLE
			:NUMBER ,NUMBER
			:VERSION ,VERSION
			:SERVER-LANGUAGES ,SERVER
			:CLIENT-LANGUAGES ,CLIENT
			:PROCESS ,PROCESS
			:AUTHENTICATION ,AUTHENTICATION
			:ALLOW-UNTRUSTED-ACCESS ,ALLOW-UNTRUSTED-ACCESS)))
	(WHEN SYS:UNDO-DECLARATIONS-FLAG
	  (APPLY #'ADD-REMOTE-MODULE MODULE-NAME 'COMPILE INITARGS))
	`(PROGN
	   (ADD-REMOTE-MODULE ',MODULE-NAME NIL
			      ,@(MAPCAR (LAMBDA (X) (LIST 'QUOTE X)) INITARGS))
	   ,(WHEN VARIABLE
	      `(DEFVAR ,VARIABLE (FIND-REMOTE-MODULE ',MODULE-NAME)))
	   ',MODULE-NAME)))))

(DEFMACRO DEFINE-REMOTE-ENTRY (ENTRY-NAME MODULE-NAME &REST OPTIONS)
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION ENTRY-NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-ENTRY)
	(LISP-OPTIONS NIL)
	(C-OPTIONS NIL)
	(SERVERS NIL)
	(BODY NIL))
    (PARSE-MACRO-OPTIONS DEFINE-REMOTE-ENTRY OPTIONS
			 (NUMBER ASYNCHRONOUS WHOSTATE)
			 (ARGUMENTS VALUES LISP C AUTHENTICATION)
      (UNLESS NUMBER
	(SETQ NUMBER 0)
	(WARN "The :NUMBER option to DEFINE-REMOTE-ENTRY is mandatory."))
      (UNLESS (FIXNUMP NUMBER)
	(WARN "The :NUMBER option to DEFINE-REMOTE-ENTRY must be a 32-bit integer."))
      (LOOP FOR (NAME TYPE) IN (APPEND ARGUMENTS VALUES) DO
	(UNLESS (AND (SYMBOLP NAME) (NOT (CONSTANTP NAME)))
	  (WARN "~S is not valid as an argument/value name." NAME))
	(UNLESS (REMOTE-TYPE-SPECIFIER-P TYPE)	;--- 'COMPILE !!
	  (WARN "The type of ~S, ~S, is not defined as a remote type." NAME TYPE)))
      (DOLIST (LOSER (INTERSECTION ARGUMENTS VALUES :KEY #'FIRST))
	(WARN "~S is used as both the name of an argument and the name of a value,~@
		 which is not allowed." (FIRST LOSER)))
      (FLET ((CHECK-OPTIONS (THIS-KIND THESE ALLOWED-OPTIONS)
	       (LOOP FOR (NAME NIL . OPTIONS) IN THESE 
		     DO (UNLESS (OR (NULL OPTIONS)
				    (AND (= (LENGTH OPTIONS) 2)
					 (MEMBER (FIRST OPTIONS) ALLOWED-OPTIONS)))
			  (WARN "The ~S ~a was specified with invalid options ~S.~@
			  The only allowed options are ~{~#[~1; or ~]~A~^, ~}."
				NAME THIS-KIND OPTIONS ALLOWED-OPTIONS)))))
	(CHECK-OPTIONS "argument" ARGUMENTS '(:OUTPUT :EXTENT))
	(CHECK-OPTIONS "value" VALUES '(:OVERWRITE)))
      (FLET ((CHECK-OPTIONS (THIS-KIND THESE THAT-KIND THOSE ALLOWED-OPTION)
	       (LOOP FOR (NAME TYPE . OPTIONS) IN THESE DO
		 (WHEN (EQ (FIRST OPTIONS) ALLOWED-OPTION)
		   (LET ((ELEM (ASSOC (SECOND OPTIONS) THOSE)))
		     (COND ((NOT ELEM)
			    (WARN "The ~S ~a was specified with ~S ~S, but ~:*~s is not~@
			           the name of a ~a from this remote-entry."
				  NAME THIS-KIND (FIRST OPTIONS) (SECOND OPTIONS) THAT-KIND))
			   ((NOT (EQUAL TYPE (SECOND ELEM)))
			    (WARN "The ~S ~a was specified with ~S ~S, but~@
			           their respective types ~S and ~S are not equal.~@
			           Incorrect operation at run time is likely to result."
				  NAME THIS-KIND (FIRST OPTIONS) (SECOND OPTIONS)
				  TYPE (SECOND ELEM)))))))))
	(CHECK-OPTIONS "argument" ARGUMENTS "value" VALUES ':OUTPUT)
	(CHECK-OPTIONS "value" VALUES "argument" ARGUMENTS ':OVERWRITE))
      (WHEN (AND ASYNCHRONOUS VALUES)
	(WARN "Asynchronous remote entries cannot return any values"))
      (LOOP FOR AUTHENTICATION-TYPE IN AUTHENTICATION
	    UNLESS (MEMBER AUTHENTICATION-TYPE *AUTHENTICATION-TYPES*)
	      DO (WARN "~S is not a valid authentication type (one of ~{~#[~1;or ~]~S~^, ~})"
		   AUTHENTICATION-TYPE *AUTHENTICATION-TYPES*)
		 (SETQ AUTHENTICATION (DELETE AUTHENTICATION-TYPE AUTHENTICATION)))
      (WHEN WHOSTATE
	(WHEN ASYNCHRONOUS
	  (WARN "Asynchronous remote entries cannot have a whostate")
	  (SETQ WHOSTATE NIL)))
      (PARSE-MACRO-OPTIONS ":LISP option to DEFINE-REMOTE-ENTRY" LISP (FUTURE) (SERVER)
	(WHEN FUTURE
	  (IF ASYNCHRONOUS
	      (WARN "Asynchronous remote entries cannot have \"future\" stubs")
	    (SETF (GETF LISP-OPTIONS :FUTURE) FUTURE)))
	(WHEN SERVER
	  (SETQ BODY SERVER)
	  (PUSH `(:LISP ,SERVER) SERVERS)))
      (PARSE-MACRO-OPTIONS ":C option to DEFINE-REMOTE-ENTRY" C (SERVER SERVER-CLEANUP) ()
	(WHEN SERVER
	  (PUSH `(:C ,(EVAL SERVER) ,@(AND SERVER-CLEANUP `(,(EVAL SERVER-CLEANUP))))
		SERVERS)))
      (LET* ((INITARGS `(:NAME ,ENTRY-NAME
			 :NUMBER ,NUMBER
			 :ARGUMENTS ,ARGUMENTS
			 :VALUES ,VALUES
			 :SERVERS ,SERVERS
			 :ASYNCHRONOUS ,ASYNCHRONOUS
			 :LISP-OPTIONS ,LISP-OPTIONS
			 :C-OPTIONS ,C-OPTIONS
			 :AUTHENTICATION ,AUTHENTICATION
			 :WHOSTATE ,WHOSTATE))
	     (MODULE (FIND-REMOTE-MODULE MODULE-NAME T 'COMPILE)))
	(WHEN SYS:UNDO-DECLARATIONS-FLAG
	  (APPLY #'ADD-REMOTE-ENTRY ENTRY-NAME MODULE-NAME 'COMPILE INITARGS))
	`(PROGN
	   (ADD-REMOTE-ENTRY ',ENTRY-NAME ',MODULE-NAME NIL
			     ,@(MAPCAR (LAMBDA (X) (LIST 'QUOTE X))
				       INITARGS))
	   ,@(WHEN (MEMBER :LISP (REMOTE-MODULE-CLIENT-LANGUAGES MODULE))
	       (APPEND 
		 (LIST (GENERATE-LISP-STUB ENTRY-NAME ARGUMENTS VALUES NUMBER ASYNCHRONOUS
					   (REMOTE-MODULE-VARIABLE MODULE) WHOSTATE))
		 (WHEN (GETF LISP-OPTIONS :FUTURE)
		   (LIST (GENERATE-LISP-FUTURE-DEFSTRUCT ENTRY-NAME)
			 (GENERATE-LISP-START-FUTURE-STUB
			   ENTRY-NAME ARGUMENTS VALUES NUMBER (REMOTE-MODULE-VARIABLE MODULE))
			 (GENERATE-LISP-FINISH-FUTURE-STUB
			   ENTRY-NAME ARGUMENTS VALUES (REMOTE-MODULE-VARIABLE MODULE)
			   WHOSTATE)
			 (GENERATE-LISP-ABORT-FUTURE-STUB ENTRY-NAME)))))
	   ,@(WHEN (MEMBER :LISP (REMOTE-MODULE-SERVER-LANGUAGES MODULE))
	       (LIST (GENERATE-LISP-HANDLER ENTRY-NAME MODULE ARGUMENTS VALUES
					    ASYNCHRONOUS BODY)
		     `(ADD-HANDLER (FIND-REMOTE-MODULE ',MODULE-NAME)
				   ,NUMBER
				   ',(ENTRY-NAME-TO-HANDLER-NAME ENTRY-NAME)))))))))

(DEFUN ENTRY-NAME-TO-FUTURE-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND ENTRY-NAME "-FUTURE")))

(DEFUN ENTRY-NAME-TO-FUTURE-CONSTRUCTOR-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND "MAKE-" ENTRY-NAME "-FUTURE")))

(DEFUN ENTRY-NAME-TO-START-FUTURE-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND "START-" ENTRY-NAME "-FUTURE")))

(DEFUN ENTRY-NAME-TO-FINISH-FUTURE-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND "FINISH-" ENTRY-NAME "-FUTURE")))

(DEFUN ENTRY-NAME-TO-ABORT-FUTURE-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND "ABORT-" ENTRY-NAME "-FUTURE")))

(DEFUN ENTRY-NAME-TO-FUTURE-ACCESSOR-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND ENTRY-NAME "-FUTURE-FUTURE")))

(DEFUN ENTRY-NAME-TO-AGENT-ACCESSOR-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND ENTRY-NAME "-FUTURE-AGENT")))

(DEFUN ENTRY-NAME-TO-HANDLER-NAME (ENTRY-NAME)
  (INTERN (STRING-APPEND ENTRY-NAME "-HANDLER")))

(DEFPROP DEFINE-REMOTE-ERROR "Remote Error" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-REMOTE-ERROR (ERROR-NAME MODULE-NAME &REST OPTIONS)
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION ERROR-NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-ERROR))
    (PARSE-MACRO-OPTIONS DEFINE-REMOTE-ERROR OPTIONS (NUMBER CONDITION) (ARGUMENTS HANDLER)
      (UNLESS NUMBER
	(SETQ NUMBER 0)
	(WARN "The :NUMBER option to DEFINE-REMOTE-ERROR is mandatory."))
      (UNLESS (FIXNUMP NUMBER)
	(WARN "The :NUMBER option to DEFINE-REMOTE-ERROR must be a 32-bit integer."))
      (LOOP FOR (NAME TYPE) IN ARGUMENTS DO
	(UNLESS (AND (SYMBOLP NAME) (NOT (CONSTANTP NAME)))
	  (WARN "~S is not valid as an argument name." NAME))
	(UNLESS (REMOTE-TYPE-SPECIFIER-P TYPE)	;--- 'COMPILE !!
	  (WARN "The type of ~S, ~S is not defined as a remote type." NAME TYPE)))
      (LET* ((MODULE (AND MODULE-NAME (FIND-REMOTE-MODULE MODULE-NAME T 'COMPILE)))
	     (REPORT-FUNCTION-NAME
	       (AND (OR (NULL MODULE-NAME)
			(MEMBER :LISP (REMOTE-MODULE-CLIENT-LANGUAGES MODULE)))
		    (INTERN (STRING-APPEND ERROR-NAME "-REMOTE-ERROR-REPORTER"))))
	     (INITARGS `(:NAME ,ERROR-NAME
			 :NUMBER ,NUMBER
			 :ARGUMENTS ,ARGUMENTS
			 :CONDITION ,CONDITION
			 :REPORT-FUNCTION ,REPORT-FUNCTION-NAME)))
	(WHEN SYS:UNDO-DECLARATIONS-FLAG
	  (APPLY #'ADD-REMOTE-ERROR ERROR-NAME MODULE-NAME 'COMPILE INITARGS))
	`(PROGN
	   (ADD-REMOTE-ERROR ',ERROR-NAME ',MODULE-NAME NIL
			     ,@(MAPCAR (LAMBDA (X) (LIST 'QUOTE X))
				       INITARGS))
	   ,@(WHEN REPORT-FUNCTION-NAME
	       (LIST (GENERATE-LISP-REPORT-FUNCTION REPORT-FUNCTION-NAME ARGUMENTS
						    CONDITION ERROR-NAME HANDLER)))
	   )))))

;;;; Lisp code generators

(DEFUN GENERATE-LISP-STUB
       (ENTRY-NAME ARGUMENTS VALUES NUMBER ASYNCHRONOUS MODULE-VARIABLE WHOSTATE)
  (LET ((LT:*SIMPLE-VARIABLES* (MAPCAR #'FIRST ARGUMENTS))	;no possible aliasing of these
	(SENT-ARGUMENTS (LOOP FOR (NAME TYPE) IN ARGUMENTS
			      UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
				COLLECT (LIST NAME TYPE))))
    `(DEFUN ,ENTRY-NAME (,@(MAPCAR #'FIRST ARGUMENTS) &KEY TRANSPORT-AGENT)
       (DECLARE (VALUES ,@(MAPCAR #'FIRST VALUES))
		(FUNCTION-PARENT ,ENTRY-NAME DEFINE-REMOTE-ENTRY))
       (LET ((XDR-AGENT NIL)		;transport medium
	     (XDR-BLOCK NIL)		;current send or receive block, for unwind-protect
	     (XDR-POINTER NIL)		;current position in XDR block
	     (XDR-LIMIT NIL))		;exclusive upper bound on XDR block
	 (WITH-DATA-STACK		;some agents cons XDR-BLOCK on the data stack
	   (UNWIND-PROTECT		;free XDR-BLOCK if aborted
	       (XDR-REGISTER-SAVE
		 ,(REMOTE-TYPE-SEND-MULTIPLE
		    :LISP
		    (MAPCAR #'SECOND SENT-ARGUMENTS)	;types
		    (MAPCAR #'FIRST SENT-ARGUMENTS)	;values
		    `(MULTIPLE-VALUE-SETQ (XDR-AGENT XDR-BLOCK XDR-POINTER XDR-LIMIT)
		       (INITIATE-CALL ,MODULE-VARIABLE
				      ,NUMBER	;entry identifier
				      SIZE	;size substituted here
				      TRANSPORT-AGENT))
		    `(SETQ XDR-BLOCK
			   (,(IF ASYNCHRONOUS `SEND-ASYNCHRONOUS-CALL `SEND-CALL-AND-WAIT)
			    XDR-AGENT
			    (PROG1 XDR-BLOCK (SETQ XDR-BLOCK NIL))
			    ,@(AND WHOSTATE (LIST WHOSTATE)))))
		 ,@(UNLESS ASYNCHRONOUS
		     `((MULTIPLE-VALUE-SETQ (XDR-POINTER XDR-LIMIT)
			 (XDR-INITIATE-RECEIVE XDR-AGENT XDR-BLOCK ,MODULE-VARIABLE))
		       ,(LET ((TYPES (MAPCAR #'SECOND VALUES))
			      INTOS MODES)
			  (LOOP FOR (NAME NIL NIL OVERWRITE) IN VALUES WITH IO-ARG DO
			    (COND (OVERWRITE
				   (PUSH OVERWRITE INTOS)
				   (PUSH :OVERWRITE MODES))
				  ((SETQ IO-ARG (FIND NAME ARGUMENTS :KEY #'FOURTH))
				   (PUSH (FIRST IO-ARG) INTOS)
				   (PUSH :OVERWRITE MODES))
				  (T (PUSH NIL INTOS)
				     (PUSH NIL MODES))))
			  (SETQ INTOS (NREVERSE INTOS)
				MODES (NREVERSE MODES))
			  (REMOTE-TYPE-RECEIVE-MULTIPLE :LISP TYPES INTOS MODES)))))
	     (WHEN XDR-BLOCK
	       (RELEASE-XDR-BLOCK XDR-AGENT XDR-BLOCK))))))))

(DEFUN GENERATE-LISP-FUTURE-DEFSTRUCT (ENTRY-NAME)
  `(ZL:LOCAL-DECLARE ((FUNCTION-PARENT ,ENTRY-NAME DEFINE-REMOTE-ENTRY))
     (DEFSTRUCT ,(ENTRY-NAME-TO-FUTURE-NAME ENTRY-NAME)
       FUTURE
       AGENT)))

(DEFUN GENERATE-LISP-START-FUTURE-STUB
       (ENTRY-NAME ARGUMENTS VALUES NUMBER MODULE-VARIABLE)
  (LET* ((LT:*SIMPLE-VARIABLES* (MAPCAR #'FIRST ARGUMENTS))	;no possible aliasing of these
	 (SENT-ARGUMENTS
	   (LOOP FOR (NAME TYPE) IN ARGUMENTS
		 UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
		   COLLECT (LIST NAME TYPE))))
    `(DEFUN ,(ENTRY-NAME-TO-START-FUTURE-NAME ENTRY-NAME)
	    (,@(MAPCAR #'FIRST SENT-ARGUMENTS) &KEY TRANSPORT-AGENT)
       (DECLARE (VALUES FUTURE)
		(FUNCTION-PARENT ,ENTRY-NAME DEFINE-REMOTE-ENTRY))
       (LET ((XDR-AGENT NIL)		;transport medium
	     (XDR-BLOCK NIL)		;current send or receive block, for unwind-protect
	     (XDR-POINTER NIL)		;current position in XDR block
	     (XDR-LIMIT NIL))		;exclusive upper bound on XDR block
	 (WITH-DATA-STACK		;some agents cons XDR-BLOCK on the data stack
	   (UNWIND-PROTECT		;free XDR-BLOCK if aborted
	       (XDR-REGISTER-SAVE
		 ,(REMOTE-TYPE-SEND-MULTIPLE
		    :LISP
		    (MAPCAR #'SECOND SENT-ARGUMENTS)	;types
		    (MAPCAR #'FIRST SENT-ARGUMENTS)	;values
		    `(MULTIPLE-VALUE-SETQ (XDR-AGENT XDR-BLOCK XDR-POINTER XDR-LIMIT)
		       (INITIATE-CALL ,MODULE-VARIABLE
				      ,NUMBER	;entry identifier
				      SIZE	;size substituted here
				      TRANSPORT-AGENT
				      T))
		    `(,(ENTRY-NAME-TO-FUTURE-CONSTRUCTOR-NAME ENTRY-NAME)
		      :FUTURE (SEND-CALL-STARTING-FUTURE
				XDR-AGENT
				(PROG1 XDR-BLOCK (SETQ XDR-BLOCK NIL)))
		      :AGENT XDR-AGENT)))
	     (WHEN XDR-BLOCK
	       (RELEASE-XDR-BLOCK XDR-AGENT XDR-BLOCK))))))))

(DEFUN GENERATE-LISP-FINISH-FUTURE-STUB
       (ENTRY-NAME ARGUMENTS VALUES MODULE-VARIABLE WHOSTATE)
  (LET* ((LT:*SIMPLE-VARIABLES* (MAPCAR #'FIRST ARGUMENTS))	;no possible aliasing of these
	 (OVERWRITTEN-ARGUMENTS
	   (LOOP FOR (NAME TYPE) IN ARGUMENTS
		 WHEN (FIND NAME VALUES :KEY #'FOURTH)	;when overwritten
		   COLLECT (LIST NAME TYPE))))
    `(DEFUN ,(ENTRY-NAME-TO-FINISH-FUTURE-NAME ENTRY-NAME)
	    (FUTURE ,@(MAPCAR #'FIRST OVERWRITTEN-ARGUMENTS))
       (DECLARE (VALUES ,@(MAPCAR #'FIRST VALUES))
		(FUNCTION-PARENT ,ENTRY-NAME DEFINE-REMOTE-ENTRY))
       (LET ((XDR-AGENT (,(ENTRY-NAME-TO-AGENT-ACCESSOR-NAME ENTRY-NAME) FUTURE))
	     (FUTURE (,(ENTRY-NAME-TO-FUTURE-ACCESSOR-NAME ENTRY-NAME) FUTURE))
	     (XDR-BLOCK NIL)			;current receive block, for unwind-protect
	     (XDR-POINTER NIL)			;current position in XDR block
	     (XDR-LIMIT NIL))			;exclusive upper bound on XDR block
	 (WITH-DATA-STACK			;some agents cons XDR-BLOCK on the data stack
	   (UNWIND-PROTECT			;free XDR-BLOCK if aborted
	       (XDR-REGISTER-SAVE
		 (SETQ XDR-BLOCK
		       (WAIT-FOR-FUTURE XDR-AGENT FUTURE ,@(AND WHOSTATE (LIST WHOSTATE))))
		 (MULTIPLE-VALUE-SETQ (XDR-POINTER XDR-LIMIT)
		   (XDR-INITIATE-RECEIVE XDR-AGENT XDR-BLOCK ,MODULE-VARIABLE))
		 ,(LET ((TYPES (MAPCAR #'SECOND VALUES))
			INTOS MODES)
		    (LOOP FOR (NAME NIL NIL OVERWRITE) IN VALUES WITH IO-ARG DO
		      (COND (OVERWRITE
			     (PUSH OVERWRITE INTOS)
			     (PUSH :OVERWRITE MODES))
			    ((SETQ IO-ARG (FIND NAME ARGUMENTS :KEY #'FOURTH))
			     (PUSH (FIRST IO-ARG) INTOS)
			     (PUSH :OVERWRITE MODES))
			    (T (PUSH NIL INTOS)
			       (PUSH NIL MODES))))
		    (SETQ INTOS (NREVERSE INTOS)
			  MODES (NREVERSE MODES))
		    (REMOTE-TYPE-RECEIVE-MULTIPLE :LISP TYPES INTOS MODES)))
	     (WHEN XDR-BLOCK
	       (RELEASE-XDR-BLOCK XDR-AGENT XDR-BLOCK))))))))

(DEFUN GENERATE-LISP-ABORT-FUTURE-STUB
       (ENTRY-NAME)
  `(DEFUN ,(ENTRY-NAME-TO-ABORT-FUTURE-NAME ENTRY-NAME) (FUTURE)
     (DECLARE (FUNCTION-PARENT ,ENTRY-NAME DEFINE-REMOTE-ENTRY))
     (LET ((XDR-AGENT (,(ENTRY-NAME-TO-AGENT-ACCESSOR-NAME ENTRY-NAME) FUTURE))
	   (FUTURE (,(ENTRY-NAME-TO-FUTURE-ACCESSOR-NAME ENTRY-NAME) FUTURE)))
       (ABORT-FUTURE XDR-AGENT FUTURE))))

(DEFUN GENERATE-LISP-HANDLER (ENTRY-NAME MODULE ARGUMENTS VALUES ASYNCHRONOUS BODY)
  (UNLESS BODY
    (WARN "No Lisp server defined for remote entry ~S" ENTRY-NAME))
  (LET* ((SENT-ARGUMENTS (LOOP FOR (NAME TYPE) IN ARGUMENTS
			       UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
				 COLLECT (LIST NAME TYPE)))
	 (STORAGE-MODES (LOOP FOR (NAME NIL OPTION VALUE) IN ARGUMENTS
			      UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
				COLLECT (AND (EQ OPTION :EXTENT)
					     (EQ VALUE :DYNAMIC)
					     :STACK))))
    `(DEFUN ,(ENTRY-NAME-TO-HANDLER-NAME ENTRY-NAME)
	    (XDR-AGENT TRANSACTION-ID CALL-XDR-BLOCK XDR-POINTER XDR-LIMIT
	     &AUX (REPLY-XDR-BLOCK NIL))
       (DECLARE (FUNCTION-PARENT ,ENTRY-NAME DEFINE-REMOTE-ENTRY))
       ,@(WHEN ASYNCHRONOUS
	   `((DECLARE (IGNORE TRANSACTION-ID))))
       (UNWIND-PROTECT
	   (XDR-REGISTER-SAVE
	     (MULTIPLE-VALUE-BIND ,(MAPCAR #'FIRST SENT-ARGUMENTS)
		 ,(REMOTE-TYPE-RECEIVE-MULTIPLE :LISP (MAPCAR #'SECOND SENT-ARGUMENTS)
						NIL STORAGE-MODES)
	       ,(LISP-MACROLET
		  `((RPC-VALUES
		     ,#'(LAMBDA (FORM)
			  (WHEN ASYNCHRONOUS
			    (WARN "RPC-VALUES should not be used in asynchronously ~
				   called remote entries."))
			  (UNLESS (= (LENGTH (CDR FORM)) (LENGTH VALUES))
			    (WARN "Wrong number of values returned by Lisp body:~@
				   ~:S does not match ~:S"
				  (CDR FORM) (MAPCAR #'FIRST VALUES)))
			  (REMOTE-TYPE-SEND-MULTIPLE :LISP
			    (MAPCAR #'SECOND VALUES)		;types
			    (CDR FORM)			;values
			    `(MULTIPLE-VALUE-SETQ (REPLY-XDR-BLOCK XDR-POINTER XDR-LIMIT)
			       (XDR-INITIATE-REPLY XDR-AGENT TRANSACTION-ID SIZE))
			    `(XDR-SEND-REPLY XDR-AGENT (PROG1 REPLY-XDR-BLOCK
							      (SETQ REPLY-XDR-BLOCK NIL)))))
		     ,(NOT ASYNCHRONOUS))
		    (RPC-ERROR
		     ,#'(LAMBDA (FORM)
			  (LET ((ERROR (FIND-REMOTE-ERROR MODULE (SECOND FORM) T 'COMPILE)))
			    (UNLESS (= (LENGTH (CDDR FORM))
				       (LENGTH (REMOTE-ERROR-ARGUMENTS ERROR)))
			    (WARN "Wrong number of arguments to remote error ~S ~
				      in Lisp body:~@
				   ~:S does not match ~:S"
				  (SECOND FORM)
				  (CDDR FORM)
				  (MAPCAR #'FIRST (REMOTE-ERROR-ARGUMENTS ERROR))))
			    (REMOTE-TYPE-SEND-MULTIPLE :LISP
			      (MAPCAR #'SECOND (REMOTE-ERROR-ARGUMENTS ERROR))      ;types
			      (CDDR FORM)					      ;values
			      `(MULTIPLE-VALUE-SETQ (REPLY-XDR-BLOCK XDR-POINTER XDR-LIMIT)
				 (XDR-INITIATE-ERROR XDR-AGENT CALL-XDR-BLOCK
						     ,(REMOTE-MODULE-VERSION MODULE)
						     ,(REMOTE-ERROR-NUMBER ERROR) SIZE))
			      `(XDR-SEND-ERROR XDR-AGENT
					       (PROG1 REPLY-XDR-BLOCK
						      (SETQ REPLY-XDR-BLOCK NIL))))))))
		  (IF (CDR BODY) `(PROGN ,@BODY) (CAR BODY)))))
	 ;; Cleanup handler
	 (RELEASE-XDR-BLOCK XDR-AGENT CALL-XDR-BLOCK)
	 (WHEN REPLY-XDR-BLOCK
	   (RELEASE-XDR-BLOCK XDR-AGENT REPLY-XDR-BLOCK))))))

(DEFUN GENERATE-LISP-REPORT-FUNCTION
       (REPORT-FUNCTION-NAME ARGUMENTS CONDITION ERROR-NAME HANDLER)
  (LET ((LT:*SIMPLE-VARIABLES* (MAPCAR #'FIRST ARGUMENTS)))	;no possible aliasing of these
    `(DEFUN ,REPORT-FUNCTION-NAME (XDR-AGENT XDR-BLOCK XDR-POINTER XDR-LIMIT)
       (DECLARE (FUNCTION-PARENT ,ERROR-NAME DEFINE-REMOTE-ERROR)
		(DBG:ERROR-REPORTER))
       XDR-AGENT XDR-BLOCK
       (XDR-REGISTER-SAVE
	 (MULTIPLE-VALUE-BIND ,(MAPCAR #'FIRST ARGUMENTS)
	     ,(REMOTE-TYPE-RECEIVE-MULTIPLE :LISP (MAPCAR #'SECOND ARGUMENTS))
	   ,(COND (HANDLER
		   `(PROGN ,@HANDLER))
		  (CONDITION
		   `(ERROR ',CONDITION
			   ,@(LOOP FOR (VARIABLE) IN ARGUMENTS
				   COLLECT (INTERN (STRING VARIABLE) PKG-KEYWORD-PACKAGE)
				   COLLECT VARIABLE)))
		  (ARGUMENTS
		   `(ERROR ,(WITH-OUTPUT-TO-STRING (S)
			      (PRINC ERROR-NAME S)
			      (PRINC ": " S)
			      (LOOP FOR ((VARIABLE) . MORE) ON ARGUMENTS DO
				(PRINC (STRING-DOWNCASE VARIABLE) S)
				(PRINC " = ~S" S)
				(WHEN MORE (PRINC ", " S))))
			   ,@(MAPCAR #'FIRST ARGUMENTS)))
		  (T
		   `(ERROR ,(STRING ERROR-NAME)))))))))

;;;; C code generators

;; No storage leaks here, because if the system routines that we call return an error,
;; they also release XDRBlock 
(DEFUN GENERATE-C-STUB (ENTRY-NAME MODULE-NAME &OPTIONAL COMPILE-TIME)
  (LET* ((COMPILER:DEFAULT-WARNING-FUNCTION ENTRY-NAME)
	 (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-ENTRY)
	 (MODULE (FIND-REMOTE-MODULE MODULE-NAME T COMPILE-TIME))
	 (ENTRY (FIND-REMOTE-ENTRY MODULE ENTRY-NAME))
	 (ARGUMENTS (REMOTE-ENTRY-ARGUMENTS ENTRY))
	 (VALUES (REMOTE-ENTRY-VALUES ENTRY))
	 (ENTRY-NUMBER (REMOTE-ENTRY-NUMBER ENTRY))
	 (MODULE-NUMBER (INTERN (FORMAT NIL "0x~X" (REMOTE-MODULE-NUMBER MODULE))
				*RPC-PACKAGE*))
	 (MODULE-VERSION (INTERN (FORMAT NIL "~D" (REMOTE-MODULE-VERSION MODULE))
				 *RPC-PACKAGE*))
	 (C-ARGUMENTS (LOOP FOR (NAME TYPE nil output) IN ARGUMENTS
			    WHEN OUTPUT
			      DO (WARN "The argument ~s is to be overwritten by value ~s,~@
					but input/output argument overwriting hasn't been implemented for C clients yet."
				       NAME OUTPUT)
			    APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C NAME)))
	 (C-VALUES (LOOP FOR (NAME TYPE) IN VALUES
			 APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C
								(STRING-APPEND "RET-" NAME))))
	 (SENT-ARGUMENTS (LOOP FOR (NAME TYPE) IN ARGUMENTS
			       UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
				 COLLECT (LIST NAME TYPE)))
	 (HEADER
	   (LET ((*C-TYPEDEFS* NIL)
		 (*C-DECLARATIONS* NIL))
	     (LET ((PROTOTYPE
		     #{ OSErr (LISP-NAME-TO-C-NAME ENTRY-NAME)
				   ( (LOOP FOR ((NAME TYPE) . MORE) ON C-ARGUMENTS
					    DO (IGNORE TYPE)
					    COLLECT (LISP-NAME-TO-C-NAME NAME)
					    WHEN MORE APPEND #{,})
				     (WHEN (AND C-ARGUMENTS C-VALUES) #{,})
				     (LOOP FOR ((NAME TYPE) . MORE) ON C-VALUES
					    DO (IGNORE TYPE)
					    COLLECT (LISP-NAME-TO-C-NAME NAME)
					    WHEN MORE APPEND #{,})
				     ) #\RETURN
			(LOOP FOR (NAME TYPE) IN C-ARGUMENTS
			       AS CNAME = #{ (LISP-NAME-TO-C-NAME NAME) }
			       APPEND (REMOTE-TYPE-DECLARATION TYPE ':C CNAME)
			       COLLECT '|;|)
			(LOOP FOR (NAME TYPE) IN C-VALUES
			       AS CNAME = #{ * (LISP-NAME-TO-C-NAME NAME) }
			       APPEND (REMOTE-TYPE-DECLARATION TYPE ':C CNAME)
			       COLLECT '|;|)
		      }))
	       PROTOTYPE)))
	 (*C-TYPEDEFS* NIL)
	 (*C-DECLARATIONS* NIL)
	 (SEND (REMOTE-TYPE-SEND-MULTIPLE :C
					  (MAPCAR #'SECOND SENT-ARGUMENTS)	;types
					  (LOOP FOR (NAME TYPE) IN SENT-ARGUMENTS ;values
						DO (IGNORE TYPE)
						COLLECT (LIST (LISP-NAME-TO-C-NAME NAME)))
					  #{ system_error_code =
					       RPCInitiateCall((LongInt)MODULE-NUMBER,
							       (LongInt)MODULE-VERSION,
							       (LongInt)ENTRY-NUMBER,
							       (LongInt)size,
							       &XDR_Agent, &XDR_Block,
							       &TheXDRPointer, &XDRLimit);
					     if ( system_error_code )
					       return ( system_error_code );
					     XDRPointer = TheXDRPointer; }
					  (IF (REMOTE-ENTRY-ASYNCHRONOUS ENTRY)
					      #{ system_error_code =
						  RPCSendAsynchronousCall(XDR_Agent, &XDR_Block);
						 if ( system_error_code )
					           return ( system_error_code ); }
					      #{ system_error_code =
						  RPCSendCallAndWait(XDR_Agent, &XDR_Block);
						 if ( system_error_code )
					           return ( system_error_code ); }
					      )))
	 (RCV (UNLESS (REMOTE-ENTRY-ASYNCHRONOUS ENTRY)
		(LET* ((INITS NIL)
		       (VARS (LOOP FOR (NAME TYPE) IN VALUES
				   DO (IGNORE TYPE)
				   COLLECT #{ (*(LISP-NAME-TO-C-NAME
						    (STRING-APPEND "RET-" NAME))) }))
		       (TYPES (MAPCAR #'SECOND VALUES))
		       (MODES
			 (LOOP FOR (NAME TYPE NIL OVERWRITE) IN VALUES
			       COLLECT (WHEN OVERWRITE
					 (MULTIPLE-VALUE-BIND (IN-PTR OUT-PTR)
					     ;;--- This is unmodular and not quite right
					     ;;--- but it works for SPREAD-VECTOR
					     (VALUES (LISP-NAME-TO-C-NAME
						       (CAAR (REMOTE-TYPE-TRANSLATE-ARGUMENT
							       TYPE ':C OVERWRITE)))
						     (LISP-NAME-TO-C-NAME
						       (CAAR (REMOTE-TYPE-TRANSLATE-ARGUMENT
							       TYPE ':C 
							       (STRING-APPEND "RET-" NAME)))))
					   (SETQ INITS (APPEND INITS
							       #{ *OUT-PTR = IN-PTR; }
							       )))
					 ':OVERWRITE))))
		  (APPEND INITS (REMOTE-TYPE-RECEIVE-MULTIPLE ':C TYPES VARS MODES))))))
    #{ HEADER
       { (collect-c-declarations)
         XDRAgent XDR_Agent;
	 XDRBlock XDR_Block;
	 LongInt* TheXDRPointer;
	 register LongInt* XDRPointer;
	 LongInt* XDRLimit;
	 OSErr system_error_code;
         #\RETURN
	 
	 send
	 (UNLESS (REMOTE-ENTRY-ASYNCHRONOUS ENTRY)
	    #{ system_error_code =
		 XDRInitiateReceive(XDR_Agent, XDR_Block, &TheXDRPointer, &XDRLimit);
	       if ( system_error_code ) return ( system_error_code );
	       XDRPointer = TheXDRPointer;
	       rcv
	       XDRReleaseBlock(XDR_Agent, XDR_Block);
	     })
	 return(noErr);
       }
     }))

(DEFUN GENERATE-C-HANDLER (ENTRY-NAME MODULE-NAME &OPTIONAL STATIC-P COMPILE-TIME)
  (LET* ((COMPILER:DEFAULT-WARNING-FUNCTION ENTRY-NAME)
	 (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-ENTRY)
	 (MODULE (FIND-REMOTE-MODULE MODULE-NAME T COMPILE-TIME))
	 (MODULE-VERSION (REMOTE-MODULE-VERSION MODULE))
	 (ENTRY (FIND-REMOTE-ENTRY MODULE ENTRY-NAME))
	 (ARGUMENTS (REMOTE-ENTRY-ARGUMENTS ENTRY))
	 (VALUES (REMOTE-ENTRY-VALUES ENTRY))
	 (C-ARGUMENTS (LOOP FOR (NAME TYPE) IN ARGUMENTS
			    UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
			      APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C NAME)))
	 (C-VALUES (LOOP FOR (NAME TYPE) IN VALUES
			 APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C
								(STRING-APPEND "RET-" NAME))))
	 (SENT-ARGUMENTS (LOOP FOR (NAME TYPE) IN ARGUMENTS
			       UNLESS (FIND NAME VALUES :KEY #'FOURTH)	;unless overwritten
				 COLLECT (LIST NAME TYPE)))
	 (BODY (SECOND (OR (ASSOC :C (REMOTE-ENTRY-SERVERS ENTRY))
			   (PROGN
			     (WARN "No C server defined for remote entry ~S" ENTRY-NAME)
			     (RETURN-FROM GENERATE-C-HANDLER NIL)))))
	 (CLEANUP (THIRD (ASSOC :C (REMOTE-ENTRY-SERVERS ENTRY))))
	 (HEADER
	   #{ (AND STATIC-P #{ static })
	      OSErr (LISP-NAME-TO-C-NAME (STRING-APPEND ENTRY-NAME "-HANDLER"))
	           (the_XDRAgent, TransactionID, CallXDRBlock, the_XDRPointer, XDRLimit)
		   #\return
	      XDRAgent the_XDRAgent;
	      LongInt TransactionID;
	      XDRBlock CallXDRBlock;
	      LongInt* the_XDRPointer;
	      LongInt* XDRLimit;
	    })
	 (*C-TYPEDEFS* NIL)
	 (*C-DECLARATIONS* NIL)
	 (BODY #{ (LOOP FOR (NAME TYPE) IN C-ARGUMENTS
			 AS CNAME = #{ (LISP-NAME-TO-C-NAME NAME) }
			 APPEND (REMOTE-TYPE-DECLARATION TYPE ':C CNAME)
			 COLLECT '|;|)
	          (REMOTE-TYPE-RECEIVE-MULTIPLE :C
		     (MAPCAR #'SECOND SENT-ARGUMENTS)			;types
		     (LOOP FOR (NAME TYPE) IN SENT-ARGUMENTS		;variables
			   DO (IGNORE TYPE)
			   AS CNAME = #{ (LISP-NAME-TO-C-NAME NAME) }
			   COLLECT CNAME)
		     :STACK)
		  { XDRBlock ReplyXDRBlock;
		    (C-MACROLET `((|RPCValues|
				   ,#'(SYS:NAMED-LAMBDA |RPCValues| (&REST ARGS)
					(WHEN (REMOTE-ENTRY-ASYNCHRONOUS ENTRY)
					  (WARN "Asynchronous remote entries should not ~
						 return values."))
					(UNLESS (= (LENGTH ARGS) (LENGTH C-VALUES))
					  (WARN "Wrong number of values ~
						 returned by C body:~v,vQ"
						C-VALUES ARGS
						#'C-ARG-MISMATCH-COMPLAINT))
					(IF (NULL ARGS)
					    #{ system_error_code = 
					        RPCNoValues(XDR_Agent, TransactionID);
					       if ( system_error_code ) goto _end_ }
					    (REMOTE-TYPE-SEND-MULTIPLE-TRANSLATED :C
					      VALUES
					      (MAPCAR #'PARENTHESIZE-C-EXPRESSION ARGS)
					      #{ system_error_code =
						  XDRInitiateReply(XDR_Agent, TransactionID,
								   (LongInt)size, &ReplyXDRBlock,
								   &the_XDRPointer, &XDRLimit);
						 if ( system_error_code ) goto _end_;
						 XDRPointer = the_XDRPointer; }
					      #{ system_error_code =
						  XDRSendReply(XDR_Agent, ReplyXDRBlock);
						 if ( system_error_code ) goto _end_ ; }
					      T)))
				   ,(NOT (REMOTE-ENTRY-ASYNCHRONOUS ENTRY)))
				  (|RPCError|
				   ,#'(SYS:NAMED-LAMBDA |RPCError| (&REST ARGS)
					(LET* ((ERROR (FIND-REMOTE-ERROR MODULE
							(C-NAME-TO-LISP-NAME (FIRST ARGS))
							T 'COMPILE))
					       (EARGS (REMOTE-ERROR-ARGUMENTS ERROR))
					       (NUMBER (REMOTE-ERROR-NUMBER ERROR)))
					  (UNLESS (= (LENGTH (REST ARGS)) (LENGTH EARGS))
					    (WARN "Wrong number of arguments to ~
						   remote error ~S in C body:~v,vQ"
						  (FIRST ARGS) EARGS (REST ARGS)
						  #'C-ARG-MISMATCH-COMPLAINT))
					  (REMOTE-TYPE-SEND-MULTIPLE-TRANSLATED :C
					    EARGS				;types
					    (MAPCAR #'PARENTHESIZE-C-EXPRESSION
						    (CDR ARGS))		;values
					    #{ system_error_code =
						XDRInitiateError(XDR_Agent, CallXDRBlock,
								 (LongInt)MODULE-VERSION,
								 (LongInt)NUMBER ,
								 (LongInt)size,
								 &ReplyXDRBlock,
								 &the_XDRPointer, &XDRLimit);
					       if ( system_error_code ) goto _end_;
					       XDRPointer = the_XDRPointer; }
					    #{ system_error_code =
						XDRSendError(XDR_Agent, ReplyXDRBlock);
					       if ( system_error_code ) goto _end_ ; }
					    T))))
				  ;; Don't allow the user to put in a return statement
				  ;; that could cause failure to release storage
				  (|return|
				   ,#'(SYS:NAMED-LAMBDA |return| (VALUE)
					(IF (EQUAL VALUE #{ system_error_code } )
					    #{ goto _end_ }
					    #{ { system_error_code = VALUE ;
						 goto _end_; }
					      } ))))
				 BODY)
		    _end_: ;
		    CLEANUP
		    (REMOTE-TYPE-FREE-MULTIPLE :C
		       (MAPCAR #'SECOND SENT-ARGUMENTS)			;types
		       (LOOP FOR (NAME TYPE) IN SENT-ARGUMENTS		;variables
			     DO (IGNORE TYPE)
			     AS CNAME = #{ (LISP-NAME-TO-C-NAME NAME) }
			     COLLECT CNAME))
		  } }))
    ;; Optimize useless goto's out of body
    (LET ((POS (SEARCH #{ if (system_error_code) goto _end_; _end_: }
		       BODY)))
      (WHEN POS
	(SETQ BODY (APPEND (SUBSEQ BODY 0 POS) (SUBSEQ BODY (+ POS 7))))))
    ;; Cleanup incorrect syntax generated by #{ if (...) RPCValues (...); else RPCError (...);
    (LOOP
      (LET ((POS (SEARCH '(|goto| |_end_| |;| |}| |;| |else|) BODY)))
	(IF POS
	    (SETQ BODY (APPEND (SUBSEQ BODY 0 (+ POS 4)) (SUBSEQ BODY (+ POS 5))))
	    (RETURN))))
    #{ HEADER
       { XDRAgent XDR_Agent = the_XDRAgent;
	 register LongInt* XDRPointer = the_XDRPointer;
	 (COLLECT-C-DECLARATIONS)
	 OSErr system_error_code = noErr;
         #\RETURN
	 
	 BODY
	 return(system_error_code);
       }
     }))

(DEFUN C-ARG-MISMATCH-COMPLAINT (EXPECTED ACTUAL)
  (FORMAT T "~%Expected ")
  (FORMAT-TEXTUAL-LIST EXPECTED
		       (LAMBDA (ITEM STREAM)
			 (PRINC (LISP-NAME-TO-C-NAME (FIRST ITEM)) STREAM))
		       :FILLED T)
  (FORMAT T "~%but got ")
  (FORMAT-TEXTUAL-LIST ACTUAL
		       (LAMBDA (ITEM STREAM)
			 (WRITE-C-TOKEN-LIST-1 ITEM STREAM
					       (SEND STREAM :READ-CURSORPOS :CHARACTER)))
		       :FILLED T))

(DEFUN GENERATE-C-ERROR-ACCESSOR (ERROR-NAME MODULE-NAME &OPTIONAL COMPILE-TIME)
    (LET* ((COMPILER:DEFAULT-WARNING-FUNCTION ERROR-NAME)
	   (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-ERROR)
	   (MODULE (FIND-REMOTE-MODULE MODULE-NAME T COMPILE-TIME))
	   (ERROR (FIND-REMOTE-ERROR MODULE ERROR-NAME T COMPILE-TIME))
	   (ARGUMENTS (REMOTE-ERROR-ARGUMENTS ERROR))
	   (ERROR-NUMBER (INTERN (FORMAT NIL "~D" (REMOTE-ERROR-NUMBER ERROR))
				*RPC-PACKAGE*))
	   ;; Error arguments will be values of C accessor
	   (C-VALUES (LOOP FOR (NAME TYPE) IN ARGUMENTS
			 APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C
								(STRING-APPEND "RET-" NAME))))
	   (HEADER
	     (LET ((*C-TYPEDEFS* NIL)
		   (*C-DECLARATIONS* NIL))
	       (LET ((PROTOTYPE
		       #{ OSErr (LISP-NAME-TO-C-NAME ERROR-NAME)
		       ( (LOOP FOR ((NAME TYPE) . MORE) ON C-VALUES
			       DO (IGNORE TYPE)
			       COLLECT (LISP-NAME-TO-C-NAME NAME)
			       WHEN MORE APPEND #{,})
			) #\RETURN
		       (LOOP FOR (NAME TYPE) IN C-VALUES
			      AS CNAME = #{ * (LISP-NAME-TO-C-NAME NAME) }
			      APPEND (REMOTE-TYPE-DECLARATION TYPE ':C CNAME)
			      COLLECT '|;|)
		       }))
		 PROTOTYPE)))
	   (*C-TYPEDEFS* NIL)
	   (*C-DECLARATIONS* NIL)
	   (RCV (LET* ((VARS (LOOP FOR (NAME TYPE) IN ARGUMENTS
				   DO (IGNORE TYPE)
				   COLLECT #{ (*(LISP-NAME-TO-C-NAME
						    (STRING-APPEND "RET-" NAME))) })))
		  (REMOTE-TYPE-RECEIVE-MULTIPLE ':C (MAPCAR #'SECOND ARGUMENTS) VARS NIL))))
      #{ HEADER
       { (collect-c-declarations)
         XDRAgent XDR_Agent;
	 XDRBlock XDR_Block;
	 LongInt* TheXDRPointer;
	 register LongInt* XDRPointer;
	 LongInt* XDRLimit;
	 OSErr system_error_code;
         #\RETURN

	 system_error_code = RPCInitiateErrorHandler((LongInt) ERROR-NUMBER,
						     &XDR_Agent, &XDR_Block,
						     &TheXDRPointer, &XDRLimit);
	 if (system_error_code) return(system_error_code);
	 XDRPointer = TheXDRPointer;
	 rcv

	 return(noErr);
       } }
       ))


;;;; C source file generator

(DEFPROP DEFINE-REMOTE-C-PROGRAM "Remote C Program" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-REMOTE-C-PROGRAM (MODULE-NAME &REST OPTIONS)
  (LET* ((COMPILER:DEFAULT-WARNING-FUNCTION MODULE-NAME)
	 (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-REMOTE-C-PROGRAM)
	 (MODULE (FIND-REMOTE-MODULE MODULE-NAME T 'COMPILE))
	 (ENTRIES (SORT (COPY-LIST (REMOTE-MODULE-ENTRIES MODULE)) #'<
			:KEY #'REMOTE-ENTRY-NUMBER))
	 (CLIENT-EXTERN-FILENAME NIL)
	 (SERVER-EXTERN-FILENAME NIL))
   (MULTIPLE-VALUE-BIND (DEFAULT-PATHNAME SOURCE-TRUENAME)
       (CURRENT-COMPILER-SOURCE-FILE)
    (FLET ((GENERATE (TITLE FILE FILE-TYPE INCLUDE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET
		      FUNARG)
	     (UNLESS FILE
	       (WARN "The :FILE sub-option is mandatory")
	       (RETURN-FROM GENERATE NIL))
	     (WITH-OPEN-FILE (OUTPUT
			       (FS:MERGE-PATHNAME-DEFAULTS FILE DEFAULT-PATHNAME FILE-TYPE)
			       :DIRECTION :OUTPUT)
	       ;; Report on the extra files we're writing, at least for now
	       (FORMAT *ERROR-OUTPUT*
		       "~&[Writing ~A portion of ~A to ~A.]~%"
		       TITLE MODULE-NAME (PATHNAME OUTPUT))
	       ;; Generate the boilerplate at the front of the file
	       (WRITE-LINE "/* -*- Mode: C; Package: C-USER; Search-list: RPC -*- */" OUTPUT)
	       (WHEN SYMBOLICS-TRADE-SECRET
		 (WARN "----Don't know how to write Symbolics trade secret notice yet"))
	       (FORMAT OUTPUT "~2%/* ~A portion of ~A remote module version ~D~@
				~3@TGenerated from ~A~@
				~3@Tby ~A on ~\\date\\ */~2%"
		       TITLE MODULE-NAME (REMOTE-MODULE-VERSION MODULE)
		       SOURCE-TRUENAME ZL:USER-ID (TIME:GET-UNIVERSAL-TIME))
	       (WHEN (EQ FILE-TYPE :C-INCLUDE)
		 (LET ((INCLUDE-NAME (STRING-APPEND "--"
						    (SEND (TRUENAME OUTPUT) :RAW-NAME)
						    "--")))
		   (WRITE-C-TOKEN-LIST #{ #ifndef (LISP-NAME-TO-C-NAME INCLUDE-NAME)
					  #define (LISP-NAME-TO-C-NAME INCLUDE-NAME)
					}
				       OUTPUT)
		   (TERPRI OUTPUT)
		   (TERPRI OUTPUT)))
	       (DOLIST (FILE INCLUDE)
		 (WRITE-STRING "#include " OUTPUT)
		 (IF (CHAR-EQUAL (CHAR FILE 0) #\<) (PRINC FILE OUTPUT) (PRIN1 FILE OUTPUT))
		 (TERPRI OUTPUT))
	       (WHEN INCLUDE
		 (TERPRI OUTPUT))
	       (WHEN PREFIX
		 (WRITE-C-TOKEN-LIST (EVAL PREFIX) OUTPUT)
		 (TERPRI OUTPUT)
		 (TERPRI OUTPUT))
	       ;; Generate the body of the file
	       (FUNCALL FUNARG OUTPUT)
	       (TERPRI OUTPUT)
	       ;; Generate the boilerplate at the end of the file
	       (WHEN SUFFIX
		 (TERPRI OUTPUT)
		 (WRITE-C-TOKEN-LIST (EVAL SUFFIX) OUTPUT)
		 (TERPRI OUTPUT))
	       (WHEN (EQ FILE-TYPE :C-INCLUDE)
		 (TERPRI OUTPUT)
		 (WRITE-C-TOKEN-LIST #{ #endif } OUTPUT)
		 (TERPRI OUTPUT))))
	   (FILENAME-PREDICATE (THE-NAME INCLUDE-FILE)
	     (LET* ((INCLUDE-FILE-LAST (1- (LENGTH INCLUDE-FILE)))
		    (FILENAME (SUBSEQ INCLUDE-FILE
				      (IF (CHAR= (AREF INCLUDE-FILE 0) #\<)
					  1 0)
				      (WHEN (CHAR= (AREF INCLUDE-FILE INCLUDE-FILE-LAST) #\>)
					INCLUDE-FILE-LAST)))
		    (PATHNAME (FS:PARSE-PATHNAME FILENAME (PATHNAME-HOST DEFAULT-PATHNAME)))
		    (NAME (SEND PATHNAME :RAW-NAME))
		    (TYPE (SEND PATHNAME :RAW-TYPE))
		    (DOT (POSITION #\. THE-NAME :TEST #'CHAR=)))
	       (AND (STRING-EQUAL THE-NAME NAME :END1 DOT)
		    (STRING-EQUAL THE-NAME TYPE :START1 (1+ DOT)))))
	   (GENERATE-PROTOTYPE (NAME ARGUMENTS VALUES EXTERN-P)
	     (LET ((ARGUMENTS
		     (LOOP FOR (NAME TYPE) IN ARGUMENTS
			   APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C NAME)))
		   (VALUES
		     (LOOP FOR (NAME TYPE) IN VALUES
			   APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT TYPE ':C NAME))))
	       #{ (IF EXTERN-P #{ extern } #{ static } )
		  OSErr
		  (LISP-NAME-TO-C-NAME NAME)
		  (IF (AND (NULL ARGUMENTS) (NULL VALUES))
		       #{ PROTO_ARGS((void)); }
		       #{ PROTO_ARGS(( (LOOP FOR ((NAME TYPE) . MORE) ON ARGUMENTS
					      AS CNAME = #{ (LISP-NAME-TO-C-NAME NAME) }
					      APPEND (REMOTE-TYPE-DECLARATION TYPE ':C CNAME)
					      WHEN MORE APPEND #{,})
				       (WHEN (AND ARGUMENTS VALUES) #{,})
				       (LOOP FOR ((NAME TYPE) . MORE) ON VALUES
					      AS CNAME = #{ * (LISP-NAME-TO-C-NAME NAME) }
					      APPEND (REMOTE-TYPE-DECLARATION TYPE ':C CNAME)
					      WHEN MORE APPEND #{,})
				       )); }
			) }
		  )))
      (PARSE-MACRO-OPTIONS DEFINE-REMOTE-C-PROGRAM OPTIONS () (CLIENT CLIENT-EXTERN
							       SERVER SERVER-EXTERN)
	(WHEN (OR CLIENT CLIENT-EXTERN)
	  (UNLESS (MEMBER ':C (REMOTE-MODULE-CLIENT-LANGUAGES MODULE))
	    (WARN "C is not declared as a client language for the ~A remote module."
		  MODULE-NAME)))
	(WHEN (OR SERVER SERVER-EXTERN)
	  (UNLESS (MEMBER ':C (REMOTE-MODULE-SERVER-LANGUAGES MODULE))
	    (WARN "C is not declared as a server language for the ~A remote module."
		  MODULE-NAME)))
	(LET ((*C-TYPEDEFS* NIL)
	      (*C-DECLARATIONS* NIL))
	  (FLET ((GENERATE-PROTOTYPES (ENTRIES ERRORS OUTPUT)
		   (LET ((CODE NIL))
		     (DOLIST (ENTRY ENTRIES)
		       (PUSH (GENERATE-PROTOTYPE (REMOTE-ENTRY-NAME ENTRY)
						 (REMOTE-ENTRY-ARGUMENTS ENTRY)
						 (REMOTE-ENTRY-VALUES ENTRY)
						 T)
			     CODE))
		     (DOLIST (ERROR-NAME ERRORS)
		       (LET* ((ERROR (FIND-REMOTE-ERROR MODULE ERROR-NAME T 'COMPILE))
			      (VALUES (LOOP FOR (NAME TYPE) IN (REMOTE-ERROR-ARGUMENTS ERROR)
					    APPEND (REMOTE-TYPE-TRANSLATE-ARGUMENT
						     TYPE ':C (STRING-APPEND "RET-" NAME))))
			      (SYMBOLIC-CONSTANT (STRING-APPEND "REMOTE_ERROR_"
								(STRING-UPCASE
								  (LISP-NAME-TO-C-NAME
								    (REMOTE-ERROR-NAME ERROR)))
								)))
			 (PUSH #{ #define (INTERN SYMBOLIC-CONSTANT *RPC-PACKAGE*)
			       (REMOTE-ERROR-NUMBER ERROR) }
			       CODE)
			 (PUSH (GENERATE-PROTOTYPE (REMOTE-ERROR-NAME ERROR)
						   NIL
						   VALUES
						   T)
			       CODE)))
		     (WRITE-C-TOKEN-LIST (COLLECT-C-DECLARATIONS) OUTPUT)
		     (DOLIST (DCL (NREVERSE CODE))
		       (WRITE-C-TOKEN-LIST DCL OUTPUT)))))
	    (WHEN CLIENT-EXTERN
	      (PARSE-MACRO-OPTIONS "DEFINE-REMOTE-C-PROGRAM :CLIENT-EXTERN sub-options"
				   CLIENT-EXTERN
				   (FILE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET)
				   (ERRORS INCLUDE)
		(PUSHNEW "RPC.h" INCLUDE :TEST #'FILENAME-PREDICATE)	;Always include RPC.h
		(GENERATE "Client function prototypes" FILE :C-INCLUDE
			  INCLUDE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET
		  (LAMBDA (OUTPUT)
		    (SETF CLIENT-EXTERN-FILENAME (FORMAT NIL "~A~@[.~A~]"
							 (SEND (TRUENAME OUTPUT) :RAW-NAME)
							 (SEND (TRUENAME OUTPUT) :RAW-TYPE)))
		    (GENERATE-PROTOTYPES ENTRIES ERRORS OUTPUT)))))
	    (WHEN CLIENT
	      (PARSE-MACRO-OPTIONS "DEFINE-REMOTE-C-PROGRAM :CLIENT sub-options" CLIENT
				   (FILE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET)
				   (ERRORS INCLUDE)
		(PUSHNEW "RPC.h" INCLUDE :TEST #'FILENAME-PREDICATE)	;Always include RPC.h
		(WHEN CLIENT-EXTERN-FILENAME
		  (UNLESS (MEMBER CLIENT-EXTERN-FILENAME INCLUDE :TEST #'FILENAME-PREDICATE)
		    (SETF INCLUDE (APPEND INCLUDE (LIST CLIENT-EXTERN-FILENAME)))))
		(GENERATE "Client stubs" FILE :C INCLUDE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET
		  (LAMBDA (OUTPUT)
		    (UNLESS CLIENT-EXTERN
		      (GENERATE-PROTOTYPES ENTRIES ERRORS OUTPUT))
		    (DOLIST (ENTRY ENTRIES)
		      (WRITE-C-TOKEN-LIST (GENERATE-C-STUB (REMOTE-ENTRY-NAME ENTRY)
							   MODULE-NAME 'COMPILE)
					  OUTPUT)
		      (TERPRI OUTPUT)
		      (TERPRI OUTPUT))
		    (DOLIST (ERROR-NAME ERRORS)
		      (WRITE-C-TOKEN-LIST
			(GENERATE-C-ERROR-ACCESSOR ERROR-NAME MODULE-NAME 'COMPILE) OUTPUT)
		      (TERPRI OUTPUT)
		      (TERPRI OUTPUT))))))))
	(WHEN SERVER-EXTERN
	  (PARSE-MACRO-OPTIONS "DEFINE-REMOTE-C-PROGRAM :SERVER-EXTERN sub-options"
			       SERVER-EXTERN
			       (FILE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET) (INCLUDE)
	    (PUSHNEW "RPC.h" INCLUDE :TEST #'FILENAME-PREDICATE)	;Always include RPC.h
	    (GENERATE "Server function prototypes" FILE :C-INCLUDE
		      INCLUDE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET
	      (LAMBDA (OUTPUT)
		(LET ((*C-TYPEDEFS* NIL)
		      (*C-DECLARATIONS* NIL))
		  (SETF SERVER-EXTERN-FILENAME (FORMAT NIL "~A~@[.~A~]"
						       (SEND (TRUENAME OUTPUT) :RAW-NAME)
						       (SEND (TRUENAME OUTPUT) :RAW-TYPE)))
		  (DOLIST (ENTRY ENTRIES)
		    (WRITE-C-TOKEN-LIST
		      #{ extern OSErr
		         (LISP-NAME-TO-C-NAME (STRING-APPEND (REMOTE-ENTRY-NAME ENTRY)
							       "-HANDLER"))
			 PROTO_ARGS((XDRAgent the_XDRAgent, LongInt TransactionID,
				     XDRBlock CallXDRBlock, LongInt* the_XDRPointer,
				     LongInt* XDRLimit)) ; }
			 OUTPUT)
		    (TERPRI OUTPUT)
		    (TERPRI OUTPUT)))))))
	(WHEN SERVER
	  (PARSE-MACRO-OPTIONS "DEFINE-REMOTE-C-PROGRAM :SERVER sub-options" SERVER
			       (FILE INIT TYPE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET
				SUBMODULE-NAME GLUE-ONLY)
			       (INCLUDE ENTRIES-ONLY)
	    (PUSHNEW "RPC.h" INCLUDE :TEST #'FILENAME-PREDICATE)     ;Always include RPC.h
	    (WHEN SERVER-EXTERN-FILENAME
	      (UNLESS (MEMBER SERVER-EXTERN-FILENAME INCLUDE :TEST #'FILENAME-PREDICATE)
		(SETF INCLUDE (APPEND INCLUDE (LIST SERVER-EXTERN-FILENAME)))))
	    (WHEN TYPE
	      (UNLESS (MEMBER TYPE '(:LINKED :AUTO-LOAD :AUTO-LOAD-WITH-STATIC-DATA))
		(WARN "The :TYPE suboption of :SERVER must be one of~@
		       :LINKED, :AUTO-LOAD, or :AUTO-LOAD-WITH-STATIC-DATA")))
	    (GENERATE (IF SUBMODULE-NAME (FORMAT NIL "Server ~a" SUBMODULE-NAME) "Server")
		      FILE :C INCLUDE PREFIX SUFFIX SYMBOLICS-TRADE-SECRET
	      (LAMBDA (OUTPUT)
		(UNLESS GLUE-ONLY
		  ;; Generate all the handler functions
		  (DOLIST (ENTRY (IF ENTRIES-ONLY
				     (REMOVE-IF-NOT (LAMBDA (E) (MEMBER (REMOTE-ENTRY-NAME E)
									ENTRIES-ONLY))
						    ENTRIES)
				     ENTRIES))
		    (LET ((HANDLER (GENERATE-C-HANDLER (REMOTE-ENTRY-NAME ENTRY) MODULE-NAME
						       (NOT (OR SERVER-EXTERN ENTRIES-ONLY))
						       'COMPILE)))
		      (COND ((NULL HANDLER)
			     ;; No body defined for this guy
			     (SETQ ENTRIES (REMOVE ENTRY ENTRIES)))
			    (T
			     (UNLESS (OR SERVER-EXTERN ENTRIES-ONLY)
			       (WRITE-C-TOKEN-LIST
				 #{ static OSErr
				    (LISP-NAME-TO-C-NAME (STRING-APPEND (REMOTE-ENTRY-NAME
									    ENTRY)
									  "-HANDLER"))
				    PROTO_ARGS((XDRAgent the_XDRAgent, LongInt TransactionID,
						XDRBlock CallXDRBlock, LongInt* the_XDRPointer,
						LongInt* XDRLimit)) ; }
				 OUTPUT)
			       (TERPRI OUTPUT)
			       (TERPRI OUTPUT))
			     (WRITE-C-TOKEN-LIST HANDLER OUTPUT)
			     (TERPRI OUTPUT)
			     (TERPRI OUTPUT))))))
		(UNLESS ENTRIES-ONLY
		  ;; Generate the glue code.  Cast to int required by older C definition.
		  (LET ((SWITCH
			  #{ register FunctionPtr handler;
			     switch ( (int)entry_number ) {
			      (LOOP FOR ENTRY IN ENTRIES
				     AS NAME = (LISP-NAME-TO-C-NAME
						 (STRING-APPEND (REMOTE-ENTRY-NAME ENTRY)
								"-HANDLER"))
				     AS NUMBER = (REMOTE-ENTRY-NUMBER ENTRY)
				     APPEND #{ case NUMBER : handler = NAME; break;
					     } )
			      default: return(RPC_PROC_UNAVAIL); };
			     return((*handler)(agent, TransactionID, block, pointer, limit));
			    })
			(SERVER (INTERN (STRING-APPEND MODULE-NAME "-SERVER") *RPC-PACKAGE*)))
		  (WRITE-C-TOKEN-LIST
		    #{ (AND (NOT (EQ TYPE :AUTO-LOAD))
			     #{ static OSErr
			        (LISP-NAME-TO-C-NAME SERVER)
				PROTO_ARGS((XDRAgent agent, LongInt TransactionID,
					    LongInt entry_number, XDRBlock block,
					    LongInt* pointer, LongInt* limit)) ;
				#\RETURN #\RETURN
			      })

		       (AND (NOT (EQ TYPE :AUTO-LOAD))
			     #{ static
			     })

		       OSErr (LISP-NAME-TO-C-NAME
				 (IF (EQ TYPE :AUTO-LOAD) 'MAIN SERVER))
			     (agent, TransactionID, entry_number, block, pointer, limit)
			     #\RETURN
		       XDRAgent agent;
		       LongInt TransactionID, entry_number;
		       XDRBlock block;
		       LongInt* pointer;
		       LongInt* limit;
		       { SWITCH }
  
		       (AND (EQ TYPE :AUTO-LOAD-WITH-STATIC-DATA)
			     #{ #\RETURN #\RETURN
				OSErr main()
				{ RPCAutoLoadWithStaticData1();
				  (eval INIT)
				  RPCAutoLoadWithStaticData2((LISP-NAME-TO-C-NAME SERVER));
				}
			      })
  
		       (AND (MEMBER TYPE '(:LINKED NIL))
			     #{ #\RETURN #\RETURN
			        extern OSErr (LISP-NAME-TO-C-NAME
						 (STRING-APPEND "INITIALIZE-" SERVER))
				PROTO_ARGS((void)) ;
			        #\RETURN
				OSErr (LISP-NAME-TO-C-NAME
					  (STRING-APPEND "INITIALIZE-" SERVER))
				      ()
				{ (eval INIT)
				  return(
				    RegisterModule((LongInt)(INTERN
							     (FORMAT NIL "0x~X"
							       (REMOTE-MODULE-NUMBER MODULE))
							     *RPC-PACKAGE*),
						   (LongInt)(REMOTE-MODULE-VERSION MODULE),
						   (LISP-NAME-TO-C-NAME SERVER)));
				}
			      })
		       }
		    OUTPUT)))))))))
    `',MODULE-NAME)))

;;; Might be compiling from buffer or from file.  Try to get the right information
;;; either way.
(DEFUN CURRENT-COMPILER-SOURCE-FILE ()
  (DECLARE (VALUES PATHNAME TRUENAME))
  (LET ((PATHNAME NIL) (TRUENAME NIL))
    (COND ((AND (TYPEP *STANDARD-INPUT* 'ZWEI:EDITOR-TYPEOUT-WINDOW)
		(SETQ PATHNAME (SEND-IF-HANDLES ZWEI:*INTERVAL* :PATHNAME)))
	   (LET ((INFO (SEND ZWEI:*INTERVAL* :FILE-INFO)))
	     (WHEN (CONSP INFO)
	       (SETQ TRUENAME (FIRST INFO)))))
	  ((SETQ PATHNAME (SEND-IF-HANDLES *STANDARD-INPUT* :PATHNAME))
	   (SETQ TRUENAME (SEND-IF-HANDLES *STANDARD-INPUT* :TRUENAME)))
	  (SYS:FDEFINE-FILE-PATHNAME
	   (SETQ PATHNAME (SEND SYS:FDEFINE-FILE-PATHNAME :NEW-PATHNAME
				:TYPE :LISP :VERSION :NEWEST))))
    (WHEN (AND PATHNAME (NULL TRUENAME))
      (CONDITION-CASE (ERROR)
	   (SETQ TRUENAME (PROBE-FILE PATHNAME))
	 (FS:FILE-ERROR ))
      (WHEN (NULL TRUENAME)
	(SETQ TRUENAME PATHNAME)))
    (WHEN (NULL PATHNAME)
      (SETQ PATHNAME (FS:DEFAULT-PATHNAME)
	    TRUENAME PATHNAME))
    (VALUES PATHNAME TRUENAME)))
