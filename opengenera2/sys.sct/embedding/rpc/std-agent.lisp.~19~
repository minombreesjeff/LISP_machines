;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: RPC; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; T         errors in RPC servers go into the debugger
;;; NIL       errors in RPC servers are handled silently
;;; :NOTIFY   errors in RPC servers send a notification
;;; In all cases, the error also sends an error reply to the caller
(DEFVAR *SERVER-DEBUG-FLAG* :NOTIFY)

;;; The transport layer of RPC -- code common to all agents that follow the SUN standard
;;; This is the layer that defines the contents of XDR blocks
;;; The next layer up defines the allocation and transmission of XDR blocks

(DEFFLAVOR STD-TRANSPORT-AGENT ((REPLY-QUEUE NIL)) (TRANSPORT-AGENT)
  (:REQUIRED-METHODS ALLOCATE-XDR-BLOCK STACK-ALLOCATE-XDR-BLOCK RELEASE-XDR-BLOCK
		     XDR-BLOCK-DATA-POINTER XDR-BLOCK-DATA-SIZE
		     CALL-BLOCK-TRANSACTION-ID)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (XDR-INITIATE-CALL STD-TRANSPORT-AGENT)
	   (MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER ARGUMENT-SIZE
			  &OPTIONAL CREDENTIAL VERIFIER FOR-FUTURE DONT-STACK-ALLOCATE)
  (DECLARE (IGNORE FOR-FUTURE)
	   (VALUES AGENT XDR-BLOCK XDR-POINTER XDR-LIMIT))
  ;; Allocate a call block and a unique transaction ID
  (LET* ((SIZE (+ (RPC-CALL-HEADER-LENGTH CREDENTIAL VERIFIER) ARGUMENT-SIZE))
	 (BLOCK (IF DONT-STACK-ALLOCATE
		    (ALLOCATE-XDR-BLOCK SELF SIZE)
		  (STACK-ALLOCATE-XDR-BLOCK SELF SIZE)))
	 (TRANSACTION-ID (LOOP AS ID = *NEXT-TRANSACTION-ID*
			       UNTIL (STORE-CONDITIONAL (LOCF *NEXT-TRANSACTION-ID*)
							ID (%32-BIT-PLUS ID 1))
			       FINALLY (RETURN ID))))
    ;; Fill in the header of the call block
    (LET* ((XDR-AGENT SELF)
	   (XDR-POINTER (XDR-BLOCK-DATA-POINTER SELF BLOCK))
	   (XDR-LIMIT (%POINTER-PLUS XDR-POINTER SIZE)))
      (INITIALIZE-XDR-POINTER)
      (SEND-RPC-CALL-HEADER TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
			    CREDENTIAL VERIFIER)
      ;; Return the information the caller needs to complete the call
      (VALUES SELF BLOCK (READ-XDR-POINTER) XDR-LIMIT))))

(DEFMETHOD (SEND-CALL-STARTING-FUTURE STD-TRANSPORT-AGENT) (BLOCK &OPTIONAL DONT-RELEASE)
  (DECLARE (VALUES FUTURE))
  (LET* ((TRANSACTION-ID (CALL-BLOCK-TRANSACTION-ID SELF BLOCK))
	 (QUEUE-ELEMENT (LIST TRANSACTION-ID NIL *CURRENT-PROCESS*)))
    (PROCESS:ATOMIC-PUSH QUEUE-ELEMENT REPLY-QUEUE)
    (SEND-XDR-BLOCK SELF BLOCK DONT-RELEASE)
    QUEUE-ELEMENT))

(DEFMETHOD (WAIT-FOR-FUTURE STD-TRANSPORT-AGENT) (FUTURE &OPTIONAL WHOSTATE)
  (LET ((REPLY
	  (UNWIND-PROTECT
	      (PROGN 
		(PROCESS:PROCESS-BLOCK
		  (OR WHOSTATE "Remote Call")
		  (LAMBDA (QUEUE-ELEMENT) (NOT (NULL (SECOND QUEUE-ELEMENT))))
		  FUTURE)
		(PROG1 (SECOND FUTURE) (SETF (SECOND FUTURE) NIL)))
	    (PROCESS:ATOMIC-REPLACEF REPLY-QUEUE (REMOVE FUTURE REPLY-QUEUE))
	    (WHEN (AND (SECOND FUTURE) (NOT (ERRORP (SECOND FUTURE))))
	      (RELEASE-XDR-BLOCK SELF (PROG1 (SECOND FUTURE) (SETF (SECOND FUTURE) NIL)))))))
    (IF (ERRORP REPLY) (SIGNAL REPLY) REPLY)))

(DEFMETHOD (ABORT-FUTURE STD-TRANSPORT-AGENT) (FUTURE)
  (PROCESS:ATOMIC-REPLACEF REPLY-QUEUE (REMOVE FUTURE REPLY-QUEUE))
  (WHEN (AND (SECOND FUTURE) (NOT (ERRORP (SECOND FUTURE))))
    (RELEASE-XDR-BLOCK SELF (PROG1 (SECOND FUTURE) (SETF (SECOND FUTURE) NIL)))))

(DEFMETHOD (SEND-CALL-AND-WAIT STD-TRANSPORT-AGENT)
	   (BLOCK &OPTIONAL WHOSTATE DONT-RELEASE)
  (LET* ((TRANSACTION-ID (CALL-BLOCK-TRANSACTION-ID SELF BLOCK))
	 (QUEUE-ELEMENT (LIST TRANSACTION-ID NIL *CURRENT-PROCESS*))
	 (REPLY
	   (UNWIND-PROTECT
	       (PROGN
		 (PROCESS:ATOMIC-PUSH QUEUE-ELEMENT REPLY-QUEUE)
		 (SEND-XDR-BLOCK SELF BLOCK DONT-RELEASE)
		 (PROCESS:PROCESS-BLOCK
		   (OR WHOSTATE "Remote Call")
		   (LAMBDA (QUEUE-ELEMENT) (NOT (NULL (SECOND QUEUE-ELEMENT))))
		   QUEUE-ELEMENT)
		 (PROG1 (SECOND QUEUE-ELEMENT) (SETF (SECOND QUEUE-ELEMENT) NIL)))
	     (PROCESS:ATOMIC-REPLACEF REPLY-QUEUE (REMOVE QUEUE-ELEMENT REPLY-QUEUE))
	     (WHEN (AND (SECOND QUEUE-ELEMENT) (NOT (ERRORP (SECOND QUEUE-ELEMENT))))
	       (RELEASE-XDR-BLOCK
		 SELF (PROG1 (SECOND QUEUE-ELEMENT) (SETF (SECOND QUEUE-ELEMENT) NIL)))))))
    (IF (ERRORP REPLY) (SIGNAL REPLY) REPLY)))

(DEFMETHOD (SEND-ASYNCHRONOUS-CALL STD-TRANSPORT-AGENT) (BLOCK &OPTIONAL DONT-RELEASE)
  (SEND-XDR-BLOCK SELF BLOCK DONT-RELEASE)
  NIL)

;;; :DEBUGGER, :NOTIFY, or :IGNORE
(DEFVAR *UNEXPECTED-REPLY-DISPOSITION* :NOTIFY)

(DEFMETHOD (UNEXPECTED-REPLY-DISPOSITION STD-TRANSPORT-AGENT :DEFAULT) ()
  *UNEXPECTED-REPLY-DISPOSITION*)

(DEFMETHOD (WAIT-FOR-CALL STD-TRANSPORT-AGENT) (&OPTIONAL CREDENTIAL VERIFIER)
  (DECLARE (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT
		   MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER TRANSACTION-ID
		   CREDENTIAL VERIFIER))
  (LOOP AS BLOCK = (RECEIVE-XDR-BLOCK SELF) DO
    ;; Decode the header of the call block
    (LET* ((XDR-AGENT SELF)
	   (XDR-POINTER (XDR-BLOCK-DATA-POINTER SELF BLOCK))
	   (XDR-LIMIT (%POINTER-PLUS XDR-POINTER (XDR-BLOCK-DATA-SIZE SELF BLOCK))))
      (INITIALIZE-XDR-POINTER)
      (LET ((TRANSACTION-ID (RECEIVE-WORD))
	    (MESSAGE-TYPE (RECEIVE-WORD)))
	(CASE MESSAGE-TYPE
	  (0	;call
	    ;;--- Really ought to confirm RPC-VERSION = 2
	    (MULTIPLE-VALUE-BIND (MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
				  CREDENTIAL VERIFIER)
		(RECEIVE-REST-OF-RPC-CALL-HEADER CREDENTIAL VERIFIER)
	      (RETURN (VALUES BLOCK (READ-XDR-POINTER) XDR-LIMIT
			      MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER TRANSACTION-ID
			      CREDENTIAL VERIFIER))))
	  (1	;reply
	    (LET ((QUEUE-ELEMENT (ASSOC TRANSACTION-ID REPLY-QUEUE)))
	      (COND (QUEUE-ELEMENT 
		     (SETF (SECOND QUEUE-ELEMENT) BLOCK)
		     (PROCESS:ATOMIC-REPLACEF REPLY-QUEUE (REMOVE QUEUE-ELEMENT REPLY-QUEUE))
		     (PROCESS:WAKEUP (THIRD QUEUE-ELEMENT)))
		    (T
		     (UNWIND-PROTECT
			 (HANDLE-ERROR-REPLY
			   XDR-AGENT BLOCK NIL (UNEXPECTED-REPLY-DISPOSITION SELF))
		       (RELEASE-XDR-BLOCK XDR-AGENT BLOCK))))))
	  (OTHERWISE
	    (UNWIND-PROTECT
		(CERROR "Ignore it"
			"Malformed RPC message received: transaction ~D message ~D"
			TRANSACTION-ID MESSAGE-TYPE)
	      (RELEASE-XDR-BLOCK XDR-AGENT BLOCK))))))))

(DEFMETHOD (XDR-INITIATE-RECEIVE STD-TRANSPORT-AGENT) (BLOCK MODULE)
  (DECLARE (VALUES XDR-POINTER XDR-LIMIT)
	   (DBG:ERROR-REPORTER))
  ;; Decode the header of the reply block
  (LET* ((XDR-AGENT SELF)
	 (XDR-POINTER (XDR-BLOCK-DATA-POINTER SELF BLOCK))
	 (XDR-LIMIT (%POINTER-PLUS XDR-POINTER (XDR-BLOCK-DATA-SIZE SELF BLOCK))))
    (INITIALIZE-XDR-POINTER)
    (MULTIPLE-VALUE-BIND (TRANSACTION-ID REPLY-STATUS ACCEPT-STATUS VERIFIER)
	(RECEIVE-RPC-REPLY-HEADER :STACK)
      (AGENT-NOTE-REPLY-VERIFIER XDR-AGENT TRANSACTION-ID VERIFIER)
      (IF (AND (= REPLY-STATUS 0)		;ACCEPTED
	       (= ACCEPT-STATUS 0))		;SUCCESS
	  (VALUES (READ-XDR-POINTER) XDR-LIMIT)
	  (HANDLE-ERROR-REPLY XDR-AGENT BLOCK MODULE :DEBUGGER)))))

(DEFMETHOD (AGENT-NOTE-REPLY-VERIFIER STD-TRANSPORT-AGENT :DEFAULT)
	   (TRANSACTION-ID VERIFIER)
  (DECLARE (IGNORE TRANSACTION-ID VERIFIER)))

(DEFMETHOD (XDR-INITIATE-REPLY STD-TRANSPORT-AGENT)
	   (TRANSACTION-ID VALUES-SIZE &OPTIONAL VERIFIER DONT-STACK-ALLOCATE)
  (DECLARE (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT))
  ;; Allocate a block of the right size and fill in the reply header
  (LET* ((XDR-AGENT SELF)
	 (SIZE (+ (RPC-REPLY-HEADER-LENGTH VERIFIER) VALUES-SIZE))
	 (BLOCK (IF DONT-STACK-ALLOCATE
		    (ALLOCATE-XDR-BLOCK SELF SIZE)
		  (STACK-ALLOCATE-XDR-BLOCK SELF SIZE)))
	 (XDR-POINTER (XDR-BLOCK-DATA-POINTER SELF BLOCK))
	 (XDR-LIMIT (%POINTER-PLUS XDR-POINTER SIZE)))
    (INITIALIZE-XDR-POINTER)
    (SEND-RPC-REPLY-HEADER TRANSACTION-ID VERIFIER)
    (VALUES BLOCK (READ-XDR-POINTER) XDR-LIMIT)))

(DEFMETHOD (XDR-SEND-REPLY STD-TRANSPORT-AGENT) (BLOCK &OPTIONAL DONT-RELEASE)
  (SEND-XDR-BLOCK SELF BLOCK DONT-RELEASE))

(DEFMETHOD (XDR-INITIATE-ERROR-INTERNAL STD-TRANSPORT-AGENT)
	   (TRANSACTION-ID ACCEPT-STATUS LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION
			   MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
			   ACTUAL-MODULE-VERSION ERROR-NUMBER ARGUMENTS-SIZE
			   VERIFIER DONT-STACK-ALLOCATE)
  (DECLARE (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT))
  ;; Allocate a block of the right size and fill in the reply header
  ;; The caller will then fill in the error arguments
  (LET* ((XDR-AGENT SELF)
	 (SIZE (+ (RPC-ERROR-REPLY-HEADER-LENGTH VERIFIER) ARGUMENTS-SIZE))
	 (XDR-BLOCK (IF DONT-STACK-ALLOCATE
			(ALLOCATE-XDR-BLOCK SELF SIZE)
		      (STACK-ALLOCATE-XDR-BLOCK SELF SIZE)))
	 (XDR-POINTER (XDR-BLOCK-DATA-POINTER SELF XDR-BLOCK))
	 (XDR-LIMIT (%POINTER-PLUS XDR-POINTER SIZE)))
    (INITIALIZE-XDR-POINTER)
    (SEND-RPC-ERROR-REPLY-HEADER TRANSACTION-ID ACCEPT-STATUS
				 LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION
				 MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
				 ACTUAL-MODULE-VERSION ERROR-NUMBER
				 VERIFIER)
    (VALUES XDR-BLOCK (READ-XDR-POINTER) XDR-LIMIT)))

(DEFMETHOD (XDR-INITIATE-ERROR STD-TRANSPORT-AGENT)
	   (CALL-XDR-BLOCK ACTUAL-MODULE-VERSION ERROR-NUMBER ARGUMENTS-SIZE
	    &OPTIONAL (ACCEPT-STATUS 5)		;REMOTE-ERROR
		      (LOWEST-MODULE-VERSION ACTUAL-MODULE-VERSION)	;real value not known
		      (HIGHEST-MODULE-VERSION ACTUAL-MODULE-VERSION)	;real value not known
		      VERIFIER DONT-STACK-ALLOCATE)
  (DECLARE (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT))
  (MULTIPLE-VALUE-BIND (TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER)
      (DECODE-CALL-BLOCK SELF CALL-XDR-BLOCK)
    (XDR-INITIATE-ERROR-INTERNAL
      SELF TRANSACTION-ID ACCEPT-STATUS LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION
      MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER ACTUAL-MODULE-VERSION ERROR-NUMBER
      ARGUMENTS-SIZE VERIFIER DONT-STACK-ALLOCATE)))

(DEFMETHOD (XDR-SEND-ERROR STD-TRANSPORT-AGENT) (BLOCK &OPTIONAL DONT-RELEASE)
  (SEND-XDR-BLOCK SELF BLOCK DONT-RELEASE))

;; This is done in a somewhat unmodular way so the code does not have to be
;; replicated inside the body of every single handler
(DEFMETHOD (REPORT-ERROR-WHILE-EXECUTING-SERVER STD-TRANSPORT-AGENT)
	   (TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER DESCRIPTION
			   &OPTIONAL VERIFIER DONT-STACK-ALLOCATE)
  (UNLESS (AGENT-CONNECTED-P SELF)
    (RETURN-FROM REPORT-ERROR-WHILE-EXECUTING-SERVER NIL))
  (SETQ DESCRIPTION (STRING-THIN DESCRIPTION :ERROR-IF :FAT))
  (LET* ((ERROR (FIND 'ERROR-WHILE-EXECUTING-SERVER *ALL-GLOBAL-REMOTE-ERRORS*
		      :KEY #'REMOTE-ERROR-NAME))
	 (ACCEPT-STATUS 5)			;REMOTE-ERROR
	 (XDR-AGENT SELF)
	 (LENGTH (LENGTH DESCRIPTION))
	 (ARGUMENTS-SIZE (FLOOR (+ LENGTH 7) 4))
	 (XDR-BLOCK NIL)
	 (XDR-POINTER NIL)
	 (XDR-LIMIT NIL))
    (XDR-REGISTER-SAVE
      (UNWIND-PROTECT
	  (PROGN
	    (MULTIPLE-VALUE-SETQ (XDR-BLOCK XDR-POINTER XDR-LIMIT)
	      (XDR-INITIATE-ERROR-INTERNAL
		SELF TRANSACTION-ID ACCEPT-STATUS
		MODULE-VERSION MODULE-VERSION
		MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
		MODULE-VERSION (REMOTE-ERROR-NUMBER ERROR)
		ARGUMENTS-SIZE VERIFIER DONT-STACK-ALLOCATE))
	      (INITIALIZE-XDR-POINTER)
	      (SEND-WORD LENGTH)
	      (SEND-CHAR-VECTOR DESCRIPTION)
	      (VERIFY-XDR-POINTER T)
	      (XDR-SEND-ERROR SELF (PROG1 XDR-BLOCK (SETQ XDR-BLOCK NIL))))
	(WHEN XDR-BLOCK (RELEASE-XDR-BLOCK SELF XDR-BLOCK))))))

(DEFMETHOD (XDR-INITIATE-AUTH-ERROR STD-TRANSPORT-AGENT)
	   (TRANSACTION-ID AUTH-STAT ARGUMENTS-SIZE &OPTIONAL DONT-STACK-ALLOCATE)
  (DECLARE (VALUES XDR-BLOCK XDR-POINTER XDR-LIMIT))
  (LET* ((SIZE (+ (RPC-AUTH-ERROR-HEADER-LENGTH) ARGUMENTS-SIZE))
	 (XDR-BLOCK (IF DONT-STACK-ALLOCATE
			(ALLOCATE-XDR-BLOCK SELF SIZE)
		      (STACK-ALLOCATE-XDR-BLOCK SELF SIZE)))
	 (XDR-AGENT SELF)
	 (XDR-POINTER (XDR-BLOCK-DATA-POINTER SELF XDR-BLOCK))
	 (XDR-LIMIT (%POINTER-PLUS XDR-POINTER SIZE)))
    (INITIALIZE-XDR-POINTER)
    (SEND-RPC-AUTH-ERROR-HEADER TRANSACTION-ID AUTH-STAT)
    (VALUES XDR-BLOCK (READ-XDR-POINTER) XDR-LIMIT)))

(DEFMETHOD (REPORT-AUTH-ERROR STD-TRANSPORT-AGENT) (TRANSACTION-ID AUTH-STAT)
  (LET* ((XDR-AGENT SELF)
	 (XDR-BLOCK NIL)
	 (XDR-POINTER NIL)
	 (XDR-LIMIT NIL))
    (XDR-REGISTER-SAVE
      (UNWIND-PROTECT
	  (PROGN
	    (MULTIPLE-VALUE-SETQ (XDR-BLOCK XDR-POINTER XDR-LIMIT)
	      (XDR-INITIATE-AUTH-ERROR XDR-AGENT TRANSACTION-ID AUTH-STAT 0))
	    (INITIALIZE-XDR-POINTER)
	    (VERIFY-XDR-POINTER T)
	    (XDR-SEND-ERROR SELF (PROG1 XDR-BLOCK (SETQ XDR-BLOCK NIL))))
	(WHEN XDR-BLOCK (RELEASE-XDR-BLOCK SELF XDR-BLOCK))))))

;;; Top function of process that calls the handler
(DEFMETHOD (AGENT-RUN-REMOTE-CALL-HANDLER STD-TRANSPORT-AGENT)
	   (HANDLER TRANSACTION-ID XDR-BLOCK XDR-POINTER XDR-LIMIT
		    MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
		    CREDENTIAL VERIFIER CREDENTIAL-APPROVED)
  (DECLARE (IGNORE CREDENTIAL VERIFIER CREDENTIAL-APPROVED))
  (WITH-DATA-STACK		;some agents cons XDR-BLOCK on the data stack
    (UNWIND-PROTECT-CASE (ABORTED-P)
	;; Since we don't know anything about this error, we should
	;; handle the error before unwinding the stack, just in case error
	;; arguments are consed on the stack.
	(CONDITION-BIND-IF
	  (NEQ *SERVER-DEBUG-FLAG* T)
	  ((ERROR
	     #'(LAMBDA (ERROR)
		 (WHEN (EQ *SERVER-DEBUG-FLAG* :NOTIFY)
		   (TV:NOTIFY NIL "Error in RPC server ~S for transaction ~D:~%  ~~A~"
			      (FUNCTION-NAME HANDLER) TRANSACTION-ID ERROR))
		 (REPORT-ERROR-WHILE-EXECUTING-SERVER
		   SELF TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
		   (FORMAT NIL "Error in RPC server ~S for transaction ~D:~%  ~~A~"
			   (FUNCTION-NAME HANDLER) TRANSACTION-ID ERROR))
		 (SETQ ABORTED-P NIL)	;don't reply twice
		 (RETURN-FROM AGENT-RUN-REMOTE-CALL-HANDLER NIL))))
	  (RETURN-FROM AGENT-RUN-REMOTE-CALL-HANDLER
	    (LET ((*DEFAULT-TRANSPORT-AGENT* SELF))	;let server talk back easily
	      (MULTIPLE-VALUE-PROG1
		(FUNCALL HANDLER SELF TRANSACTION-ID XDR-BLOCK XDR-POINTER XDR-LIMIT)
		(SETQ ABORTED-P NIL)))))
      (:ABORT
	(REPORT-ERROR-WHILE-EXECUTING-SERVER
	  SELF TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
	  (FORMAT NIL "Execution of RPC server ~S for transaction ~D was aborted."
		  (FUNCTION-NAME HANDLER) TRANSACTION-ID))))))

;;;; Handling of unexpected and error replies

(DEFFLAVOR RPC-ERROR (AGENT TRANSACTION-ID) (ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(DEFFLAVOR RPC-INVALID-REPLY () (RPC-ERROR))

(DEFFLAVOR RPC-UNEXPECTED-REPLY () (RPC-ERROR))

;;--- This should have reject_stat and mismatch_info or auth_stat, but we don't use it
;;--- so worry about it some other time.
(DEFFLAVOR RPC-ACCESS-DENIED () (RPC-ERROR))

(DEFFLAVOR RPC-ERROR-REPLY (ACCEPT-STATUS
			    (LOWEST-MODULE-VERSION NIL) (HIGHEST-MODULE-VERSION NIL)
			    (MODULE-NUMBER NIL) (MODULE-VERSION NIL) (ENTRY-NUMBER NIL)
			    (ACTUAL-MODULE-VERSION NIL) (ERROR-CODE NIL))
			   (RPC-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(DEFFLAVOR RPC-REMOTE-OPERATING-SYSTEM-ERROR () (RPC-ERROR-REPLY))

(DEFFLAVOR RPC-UNKNOWN-REMOTE-ERROR () (RPC-ERROR-REPLY))

(DEFFLAVOR RPC-MISMATCH-ERROR () (RPC-ERROR-REPLY))

;; Set the current frame to the stub if we can find it
(DEFWHOPPER (DBG:CURRENT-AND-INNERMOST-FRAMES-FOR-DEBUGGER RPC-ERROR) (START-FRAME)
  (MULTIPLE-VALUE-BIND (CURRENT-FRAME INNERMOST-INTERESTING-FRAME)
      (CONTINUE-WHOPPER START-FRAME)
    (LOOP FOR FRAME = CURRENT-FRAME THEN (DBG:FRAME-OUT-TO-INTERESTING-ACTIVE-FRAME
					   (DBG:FRAME-PREVIOUS-ACTIVE-FRAME FRAME) NIL)
	  UNTIL (NULL FRAME)
	  AS FUNCTION = (FUNCTION-NAME (DBG:FRAME-FUNCTION FRAME))
	  DO (UNLESS (OR (EQ FUNCTION 'HANDLE-ERROR-REPLY)
			 (AND (LISTP FUNCTION)
			      (EQ (FIRST FUNCTION) 'FLAVOR:METHOD)
			      (EQ (FLAVOR:METHOD-GENERIC FUNCTION) 'XDR-INITIATE-RECEIVE)))
	       (RETURN (VALUES FRAME INNERMOST-INTERESTING-FRAME)))
	  FINALLY (RETURN (VALUES CURRENT-FRAME INNERMOST-INTERESTING-FRAME)))))

(DEFMETHOD (DBG:REPORT RPC-INVALID-REPLY) (STREAM)
  (FORMAT STREAM "Unparseable RPC reply received for transaction ~D." TRANSACTION-ID))

(DEFMETHOD (DBG:REPORT RPC-UNEXPECTED-REPLY) (STREAM)
  (FORMAT STREAM "RPC success reply received for transaction ~D, but no caller was waiting."
	  TRANSACTION-ID))

(DEFMETHOD (DBG:REPORT RPC-ACCESS-DENIED) (STREAM)
  (FORMAT STREAM "RPC access denied by server for transaction ~D." TRANSACTION-ID))

(DEFUN-IN-FLAVOR (DESCRIBE-REMOTE-ENTRY RPC-ERROR-REPLY) (STREAM)
  (IF (AND MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER)
      (FILLING-OUTPUT (STREAM)
	(LET* ((MODULE (GETHASH MODULE-NUMBER *REMOTE-MODULE-TABLE*))
	       (ENTRIES (REMOTE-MODULE-ENTRIES MODULE))
	       (ENTRY (AND MODULE
			   (LISTP ENTRIES)	;Delivery world
			   (FIND ENTRY-NUMBER ENTRIES :KEY #'REMOTE-ENTRY-NUMBER))))
	  (FORMAT STREAM "Call to remote entry ")
	  (IF ENTRY
	      (FORMAT STREAM "~S (~D)" (REMOTE-ENTRY-NAME ENTRY) ENTRY-NUMBER)
	      (FORMAT STREAM "~X" ENTRY-NUMBER))
	  (FORMAT STREAM " of module ")
	  (IF MODULE
	      (FORMAT STREAM "~S (#x~X)" (REMOTE-MODULE-NAME MODULE) MODULE-NUMBER)
	      (FORMAT STREAM "~X" MODULE-NUMBER))
	  (FORMAT STREAM " version ~D" MODULE-VERSION)
	  (WHEN (AND ACTUAL-MODULE-VERSION
		     ( ACTUAL-MODULE-VERSION MODULE-VERSION)
		     ( ACTUAL-MODULE-VERSION 0))
	    (FORMAT STREAM " requested, ~D actual" ACTUAL-MODULE-VERSION))
	  (FORMAT STREAM " failed for transaction ~D" TRANSACTION-ID)))
      (FORMAT STREAM "Remote call failed for transaction ~D" TRANSACTION-ID)))

(DEFMETHOD (DBG:REPORT RPC-REMOTE-OPERATING-SYSTEM-ERROR) (STREAM)
  (FORMAT STREAM "~:[Remote operating system~;~:*~:~] error code ~D~@[: ~A~].~%"
	  (LET ((SYSTEM-TYPE (REMOTE-SYSTEM-TYPE AGENT)))
	    (AND (NEQ SYSTEM-TYPE :UNKNOWN) SYSTEM-TYPE))
	  ERROR-CODE (RPC-REMOTE-OPERATING-SYSTEM-ERROR-STRING AGENT ERROR-CODE))
  (DESCRIBE-REMOTE-ENTRY STREAM)
  (PRINC "." STREAM))

(DEFMETHOD (DBG:REPORT RPC-UNKNOWN-REMOTE-ERROR) (STREAM)
  (DESCRIBE-REMOTE-ENTRY STREAM)
  (LET* ((MODULE (GETHASH MODULE-NUMBER *REMOTE-MODULE-TABLE*))
	 (ERROR (AND MODULE (FIND-REMOTE-ERROR-BY-NUMBER MODULE ERROR-CODE NIL))))
    (IF ERROR
	(FORMAT STREAM ":~%Remote error ~S reported." (REMOTE-ERROR-NAME ERROR))
	(FORMAT STREAM ":~%Undefined remote error number ~D reported." ERROR-CODE))))

(DEFMETHOD (DBG:REPORT RPC-MISMATCH-ERROR) (STREAM)
  (DESCRIBE-REMOTE-ENTRY STREAM) (FORMAT STREAM ":~%")
  (CASE ACCEPT-STATUS
    (1 (FORMAT STREAM "Server cannot find this remote module."))
    (2 (FORMAT STREAM "Remote module version mismatch")
       (COND ((NOT (AND LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION))
	      (FORMAT STREAM "."))
	     (( HIGHEST-MODULE-VERSION LOWEST-MODULE-VERSION)
	      (FORMAT STREAM ": versions ~D through ~D are available."
		      LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION))
	     (T (FORMAT STREAM ": version ~D is available." LOWEST-MODULE-VERSION))))
    (3 (FORMAT STREAM "Server cannot find the handler for this remote entry."))
    (4 (FORMAT STREAM "Server reports that the arguments are \"garbage\"."))
    (OTHERWISE (FORMAT STREAM "Unrecognized accept-status code ~D" ACCEPT-STATUS))))

(COMPILE-FLAVOR-METHODS RPC-INVALID-REPLY RPC-UNEXPECTED-REPLY RPC-ACCESS-DENIED
			RPC-REMOTE-OPERATING-SYSTEM-ERROR
			RPC-UNKNOWN-REMOTE-ERROR RPC-MISMATCH-ERROR)

;;; MODULE is the remote module we're serving or NIL if not known yet
;;; DISPOSITION is :DEBUGGER, :NOTIFY, or :IGNORE
(DEFUN HANDLE-ERROR-REPLY (XDR-AGENT XDR-BLOCK MODULE DISPOSITION)
  (DECLARE (DBG:ERROR-REPORTER))
  (WHEN (EQ DISPOSITION :IGNORE)
    (RETURN-FROM HANDLE-ERROR-REPLY NIL))
  ;; Decode the header of the reply block
  (LET* ((XDR-POINTER (XDR-BLOCK-DATA-POINTER XDR-AGENT XDR-BLOCK))
	 (XDR-LIMIT (%POINTER-PLUS XDR-POINTER (XDR-BLOCK-DATA-SIZE XDR-AGENT XDR-BLOCK))))
    (INITIALIZE-XDR-POINTER)
    (MULTIPLE-VALUE-BIND (TRANSACTION-ID REPLY-STATUS ACCEPT-STATUS VERIFIER)
	(RECEIVE-RPC-REPLY-HEADER :STACK)
      (LET ((CONDITION
	      (COND ((= REPLY-STATUS 1)		;REJECTED
		     (MAKE-CONDITION 'RPC-ACCESS-DENIED :AGENT XDR-AGENT
							:TRANSACTION-ID TRANSACTION-ID))
		    (( REPLY-STATUS 0)		;invalid
		     (MAKE-CONDITION 'RPC-INVALID-REPLY :AGENT XDR-AGENT
							:TRANSACTION-ID TRANSACTION-ID))
		    ((= ACCEPT-STATUS 0)	;SUCCESS
		     (MAKE-CONDITION 'RPC-UNEXPECTED-REPLY :AGENT XDR-AGENT
							   :TRANSACTION-ID TRANSACTION-ID))
		    ((< (%POINTER-DIFFERENCE XDR-LIMIT (READ-XDR-POINTER))
			(- (RPC-ERROR-REPLY-HEADER-LENGTH VERIFIER)
			   (RPC-REPLY-HEADER-LENGTH VERIFIER)))
		     ;; Extra information about the error is not present
		     (MAKE-CONDITION 'RPC-MISMATCH-ERROR :AGENT XDR-AGENT
							 :TRANSACTION-ID TRANSACTION-ID
							 :ACCEPT-STATUS ACCEPT-STATUS))
		    (T
		     (MULTIPLE-VALUE-BIND (LOWEST-MODULE-VERSION HIGHEST-MODULE-VERSION
					   MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER
					   ACTUAL-MODULE-VERSION ERROR-CODE)
			 (RECEIVE-RPC-ERROR-REPLY-HEADER)
		       (WHEN (AND (= ACCEPT-STATUS 5)	;REMOTE-ERROR
				  (EQ DISPOSITION :DEBUGGER))
			 (UNLESS MODULE
			   (SETQ MODULE (GETHASH MODULE-NUMBER *REMOTE-MODULE-TABLE*)))
			 (WHEN MODULE
			   (LET ((ERROR (FIND-REMOTE-ERROR-BY-NUMBER MODULE ERROR-CODE NIL)))
			     (WHEN ERROR
			       (RETURN-FROM HANDLE-ERROR-REPLY
				 (FUNCALL (REMOTE-ERROR-REPORT-FUNCTION ERROR)
					  XDR-AGENT XDR-BLOCK
					  (READ-XDR-POINTER) XDR-LIMIT))))))
		       (MAKE-CONDITION (CASE ACCEPT-STATUS
					 ((1 2 3) 'RPC-MISMATCH-ERROR)
					 ((4) 'RPC-REMOTE-OPERATING-SYSTEM-ERROR)
					 ((5) 'RPC-UNKNOWN-REMOTE-ERROR)
					 (OTHERWISE 'RPC-MISMATCH-ERROR))
				       :AGENT XDR-AGENT
				       :TRANSACTION-ID TRANSACTION-ID
				       :ACCEPT-STATUS ACCEPT-STATUS
				       :LOWEST-MODULE-VERSION LOWEST-MODULE-VERSION
				       :HIGHEST-MODULE-VERSION HIGHEST-MODULE-VERSION
				       :MODULE-NUMBER MODULE-NUMBER
				       :MODULE-VERSION MODULE-VERSION
				       :ENTRY-NUMBER ENTRY-NUMBER
				       :ACTUAL-MODULE-VERSION ACTUAL-MODULE-VERSION
				       :ERROR-CODE ERROR-CODE))))))
	(IF (EQ DISPOSITION :DEBUGGER)
	    (ERROR CONDITION)
	    (TV:NOTIFY NIL "RPC: ~A" CONDITION))))))

;;;; Facility for decoding error codes of remote operating systems

;;; ((system-type first-code last-code)...)
;;; See the file SYS:EMBEDDING;RPC;GENERIC;ERROR.H
(DEFPARAMETER *SYMBOLICS-ERROR-CODE-RANGE-ALIST*
	      '((:MACINTOSH 3600 3999)
		;; Add other system types here as they get defined
		(:UNKNOWN 3600 3999)))	;the default

;;; ((system-type (error-code string) (error-code string)...)...)
(DEFVAR *REMOTE-ERROR-NUMBER-ALIST* NIL)

(DEFUN RPC-REMOTE-OPERATING-SYSTEM-ERROR-STRING (AGENT ERROR-CODE)
  (LET* ((SYSTEM-TYPE (REMOTE-SYSTEM-TYPE AGENT))
	 (RANGE (OR (ASSOC SYSTEM-TYPE *SYMBOLICS-ERROR-CODE-RANGE-ALIST*)
		    (ASSOC :UNKNOWN *SYMBOLICS-ERROR-CODE-RANGE-ALIST*))))
    (COND ((AND RANGE ( ERROR-CODE (SECOND RANGE)) ( ERROR-CODE (THIRD RANGE)))
	   (SECOND (ASSOC (- ERROR-CODE (SECOND RANGE))
			  (CDR (ASSOC :SYMBOLICS *REMOTE-ERROR-NUMBER-ALIST*)))))
	  ((AND (GET SYSTEM-TYPE 'REMOTE-OPERATING-SYSTEM-ERROR-STRING-FUNCTION)
		(FUNCALL (GET SYSTEM-TYPE 'REMOTE-OPERATING-SYSTEM-ERROR-STRING-FUNCTION)
			 AGENT ERROR-CODE)))
	  (T
	   (SECOND (ASSOC ERROR-CODE
			  (CDR (ASSOC SYSTEM-TYPE *REMOTE-ERROR-NUMBER-ALIST*))))))))

(DEFMACRO DEFINE-REMOTE-ERROR-NUMBER (SYSTEM-TYPE NUMBER STRING)
  `(ADD-REMOTE-ERROR-NUMBER ',SYSTEM-TYPE ',NUMBER ',STRING))

(DEFUN ADD-REMOTE-ERROR-NUMBER (SYSTEM-TYPE NUMBER STRING)
  (LET ((ALIST (ASSOC SYSTEM-TYPE *REMOTE-ERROR-NUMBER-ALIST*)))
    (UNLESS ALIST
      (PUSH (SETQ ALIST (NCONS SYSTEM-TYPE)) *REMOTE-ERROR-NUMBER-ALIST* :LOCALIZE T))
    (LET ((ELEM (ASSOC NUMBER (CDR ALIST))))
      (IF ELEM
	  (SETF (SECOND ELEM) STRING)
	  (PUSH (LIST NUMBER STRING) (CDR ALIST) :LOCALIZE T)))))

;;;; Some combination flavors

(DEFFLAVOR STD-LITTLE-ENDER-ARRAY-TRANSPORT-AGENT ()
	   (LITTLE-ENDER-DATA ARRAYS-FOR-XDR-BLOCKS STD-TRANSPORT-AGENT)
  (:ABSTRACT-FLAVOR))

(DEFMETHOD (XDR-BLOCK-MESSAGE-TYPE STD-LITTLE-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (AREF BLOCK 1))

(DEFMETHOD (CALL-BLOCK-TRANSACTION-ID STD-LITTLE-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (AREF BLOCK 0))

(DEFMETHOD (REPLY-BLOCK-TRANSACTION-ID STD-LITTLE-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (AREF BLOCK 0))

(DEFMETHOD (DECODE-CALL-BLOCK STD-LITTLE-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (DECLARE (VALUES TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER))
  (VALUES (AREF BLOCK 0)
	  (AREF BLOCK 3)
	  (AREF BLOCK 4)
	  (AREF BLOCK 5)))

(DEFMETHOD (DECODE-REPLY-BLOCK STD-LITTLE-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (DECLARE (VALUES REPLY-STATUS ACCEPT-STATUS VERIFIER-FLAVOR LOW HIGH
		   REJECT-STATUS AUTH-STATUS))
  (DECODE-REPLY-BLOCK-BODY `(AREF BLOCK ,OFFSET)))

(DEFFLAVOR STD-BIG-ENDER-ARRAY-TRANSPORT-AGENT ()
	   (BIG-ENDER-DATA ARRAYS-FOR-XDR-BLOCKS STD-TRANSPORT-AGENT)
  (:ABSTRACT-FLAVOR))

(DEFMETHOD (XDR-BLOCK-MESSAGE-TYPE STD-BIG-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (BYTE-SWAP (AREF BLOCK 1)))

(DEFMETHOD (CALL-BLOCK-TRANSACTION-ID STD-BIG-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (BYTE-SWAP (AREF BLOCK 0)))

(DEFMETHOD (REPLY-BLOCK-TRANSACTION-ID STD-BIG-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (BYTE-SWAP (AREF BLOCK 0)))

(DEFMETHOD (DECODE-CALL-BLOCK STD-BIG-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (DECLARE (VALUES TRANSACTION-ID MODULE-NUMBER MODULE-VERSION ENTRY-NUMBER))
  (VALUES (BYTE-SWAP (AREF BLOCK 0))
	  (BYTE-SWAP (AREF BLOCK 3))
	  (BYTE-SWAP (AREF BLOCK 4))
	  (BYTE-SWAP (AREF BLOCK 5))))

(DEFMETHOD (DECODE-REPLY-BLOCK STD-BIG-ENDER-ARRAY-TRANSPORT-AGENT) (BLOCK)
  (DECLARE (VALUES REPLY-STATUS ACCEPT-STATUS VERIFIER-FLAVOR LOW HIGH
		   REJECT-STATUS AUTH-STATUS))
  (DECODE-REPLY-BLOCK-BODY `(BYTE-SWAP (AREF BLOCK ,OFFSET))))
