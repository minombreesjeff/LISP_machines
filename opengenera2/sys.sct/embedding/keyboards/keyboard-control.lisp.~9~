;;; -*- Mode: LISP; Syntax: Common-lisp; Package: SYSTEM-APPLICATIONS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Presentation Types

(define-presentation-type mapping-index-description ((&key keyboard-layout mapping-table))
   :printer ((mapping stream)
	     (formatting-textual-list (stream :separator " + ")
	       (let ((shifts (ldb %%kbd-mapping-index-description-shifts mapping)))
		 (flet ((print-some-shifts (mask)
			  (loop for bit downfrom (integer-length mask) to 0 do
			    (when (ldb-test (byte 1 bit) mask)
			      (let ((bit-name (string-capitalize-words
						(aref sys:*kbd-mapping-bit-names* bit))))
				(formatting-textual-list-element (stream)
				  (write-string bit-name stream)
				  (when mapping-table
				    (let ((key-code (key-code-for-shift mapping-table bit)))
				      (if (null key-code)
					  (format stream "(~'iUntypeable~)")
					  (let ((key-name
						  (let ((key (keyboard-layout-key-for-code
							       keyboard-layout key-code)))
						    (and key
							 (keyboard-layout-key-legend key)))))
					    (when key-name
					      (when (consp key-name)
						(setq key-name (if (characterp
								     (first key-name))
								   (first (last key-name))
								   (format nil "~{~A~^ ~}"
									   key-name))))
					      (setq key-name (string key-name))
					      (unless (string-equal bit-name key-name)
						(format stream "(~A)" key-name)))))))))))))
		   ;; Do the bits first, then the others.
		   (print-some-shifts (mask-field sys:%%kbd-shifts-bits shifts))
		   (print-some-shifts (dpb 0 sys:%%kbd-shifts-bits shifts))))
	       (let ((key (keyboard-layout-key-for-code
			    keyboard-layout
			    (ldb %%kbd-mapping-index-description-key-code mapping))))
		 (formatting-textual-list-element (stream)
		   (format stream "~A" key)))))
   )

(define-presentation-type mapping-table-entry ()
   :printer ((object stream)
	     (typecase object
	       (character (format stream "~:C" object))
	       (integer (if (ldb-test sys:%%kbd-mapping-special object)
			    (selector (ldb sys:%%kbd-mapping-special-class object) =
			      ((sys:%kbd-mapping-special-shift
				sys:%kbd-mapping-special-locking-shift
				sys:%kbd-mapping-special-locking-once-shift)	;---
				(write-string
				  (string-capitalize-words
				    (aref sys:*kbd-mapping-bit-names*
					  (ldb sys:%%kbd-mapping-shift-index object)))
				  stream))
			      (sys:%kbd-mapping-special-unassigned
				(format stream "~'iUnassigned~"))
			      (sys:%kbd-mapping-special-noop
				(format stream "~'iNoop~"))
			      (sys:%kbd-mapping-special-mouse-button
				(write-string
				  (string-capitalize-words
				    (nth (ldb sys:%%kbd-mapping-bit-number object)
					 sys:*kbd-mapping-mouse-button-names*))
				  stream)))
			    (format stream "~:C" (code-char object))))
	       (null (format stream "~'iUnassigned~"))
	       (cons (dolist (char object) (write-char char stream)))
	       (otherwise (format stream "~A" object))))
   :parser ((stream &key default type)
	    (let ((chars (accept '((type-or-string ((sequence extended-character))))
				 :stream stream
				 :default (typecase default
					    ((or null sequence) default)
					    (character (list default))
					    (integer
					      (if (ldb-test sys:%%kbd-mapping-special
							    default)
						  (present-to-string default
								     'mapping-table-entry)
						  (list (code-char default)))))
				 :prompt nil)))
	      (if (stringp chars)
		  (let ((class sys:%kbd-mapping-special-unassigned)
			(extra 0))
		    (block parsed
		      (when (string-equal chars "Unassigned")
			(return-from parsed))
		      (when (string-equal chars "Noop")
			(setq class sys:%kbd-mapping-special-noop)
			(return-from parsed))
		      (let ((shift-index (position chars sys:*kbd-mapping-bit-names*
						   :test #'string-equal
						   :key #'string-capitalize-words)))
			(when shift-index
			  (setq class sys:%kbd-mapping-special-shift
				extra shift-index)
			  (return-from parsed)))
		      (let ((mouse-index (position chars sys:*kbd-mapping-mouse-button-names*
						   :test #'string-equal
						   :key #'string-capitalize-words)))
			(when mouse-index
			  (setq class sys:%kbd-mapping-special-mouse-button
				extra mouse-index)
			  (return-from parsed)))
		      (error 'dw:input-not-of-required-type :string chars :type type))
		    (sys:dpbs 1 sys:%%kbd-mapping-special
			      class sys:%%kbd-mapping-special-class
			      extra))
		  (if (cdr chars)
		      (coerce chars 'string)
		      (let ((char (first chars)))
			(if (char-fat-p char)
			    char
			    (char-code char)))))))
   )

(define-presentation-type extended-character ()
   :abbreviation-for 'character
   :parser ((stream)
	    (let ((name (dw:read-standard-token stream)))
	      (or (si:xr-parse-keyboard-char name)	;Like #\...
		  (sys:parse-ferror "~S is not a character name" name))))
   :printer ((character stream)
	     (format stream "~:C" character))	;Good enough for now
   :description "a character"
   )


;;;; Drawing

(defun break-label-if-necessary (key label)
  (or (and (stringp label)
	   (> (length label) 1)
	   (multiple-value-bind (left top right bottom) (keyboard-layout-key-edges key)
	     (declare (ignore top bottom))
	     ( (- right left) 1))
	   (let ((colonpos (string-search-char #\: label)))
	     (setq label (if colonpos (substring label (1+ colonpos)) label)))
	   (string-search-set "- " label)
	   (loop for start first 0 then (string-search-not-set "- " label :start end)
		 while start
		 for end = (string-search-set "- " label :start start)
		 collect (substring label start end)
		 while end))
      label))

(defun keyboard-key-label (key mapping-table &optional (type :legend) extra-arg)
  (multiple-value-bind (label filled)
      (ecase type
	(:legend
	  (keyboard-layout-key-legend key))
	(:name
	  (keyboard-layout-key-name key))
	((:mapping :mapping-including-shifts :mapping-excluding-shifts)
	 (let* ((shift-index (or extra-arg 0))
		(mapping (sys:map-key-to-software-char
			   shift-index (keyboard-layout-key-code key) mapping-table))
		(filled nil))
	   (values (cond ((and (integerp mapping)
			       (ldb-test sys:%%kbd-mapping-special mapping))
			  (selector (ldb sys:%%kbd-mapping-special-class mapping) =
			    ((sys:%kbd-mapping-special-shift
			       sys:%kbd-mapping-special-locking-shift
			       sys:%kbd-mapping-special-locking-once-shift)
			     (let ((bit-number (ldb sys:%%kbd-mapping-bit-number mapping)))
			       (when (ldb-test (selector bit-number =
						 (sys:%kbd-shifts-shift
						   sys:%%kbd-mapping-table-index-shift)
						 (sys:%kbd-shifts-symbol
						   sys:%%kbd-mapping-table-index-symbol)
						 (otherwise 0))
					       shift-index)
				 (setq filled t))
			       (when (eq type :mapping-including-shifts)
				 (string-capitalize-words
				   (aref sys:*kbd-mapping-bit-names* bit-number)))))
			    (sys:%kbd-mapping-special-mouse-button
			      (string-capitalize-words
				(nth (ldb sys:%%kbd-mapping-bit-number mapping)
				     sys:*kbd-mapping-mouse-button-names*)))))
			 ((integerp mapping)
			  (let ((char (code-char mapping)))
			    (if (graphic-char-p char) char (char-name char))))
			 (t mapping))
		   filled)))
	(:code
	  (let ((code (keyboard-layout-key-code key))
		(radix (or extra-arg 10)))
	    (case radix
	      (10 (format nil "~D" code))
	      (8 (format nil "#o~3,'0O" code))
	      (16 (format nil "#x~2,'0X" code))
	      (otherwise (write code :radix t :base radix)))))
	(:keysym
	  (labels ((keysym-label (keysym)
		     (cond ((null keysym) nil)
			   ((and (listp keysym)
				 (numberp (first keysym))
				 (numberp (second keysym)))
			    (format nil "~3,'0D,~3,'0D" (first keysym) (second keysym)))
			   ((listp keysym) (mapcar #'keysym-label keysym))
			   ((< keysym 256) (format nil "000,~3,'0D" keysym))
			   (t (keysym-label
				(list (ldb (byte 8 8) keysym) (ldb (byte 8 0) keysym)))))))
	    (keysym-label (keyboard-layout-key-keysym key))))
	)
    (values (break-label-if-necessary key label) filled)))

;;; For use with D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")draw-string-image0, compute how much can scale up the label strings so
;;; that the widest fits.  Then we use this scale uniformly for all strings (so they are
;;; printed the same size, rather than the shorter ones in a bigger font).
(defun keys-draw-string-image-scale (keys mapping-table stream
				     &optional (label-type :legend) label-arg)
  (let ((string-width-scale 1))
    (dolist (key keys)
      (let ((width (multiple-value-bind (left nil right nil)
		       (keyboard-layout-key-edges key)
		     (* (- right left) .9))))	;Can use 90% of the keytop
	(labels ((check-one-label (label)
		   (when (and (stringp label) (plusp (string-length label)))
		     (minf string-width-scale
			   (/ width (send stream :draw-string-size label))))))
	  (let ((label (keyboard-key-label key mapping-table label-type label-arg)))
	    (if (consp label)
		(map () #'check-one-label label)
		(check-one-label label))))))
    string-width-scale))

;;; This version obeys the generic graphics protocol, and is therefore suitable for static
;;; displays, such as to hardcopy streams, etc.
(defun draw-keyboard-layout (keyboard-layout
			     &key (mapping-table nil)	;Might not need it if no mappings.
				  (stream *standard-output*)
				  (horizontal-fraction .9)	;Max (output always centered)
				  (vertical-fraction nil)	;Always allocated
				  (label-type :legend) label-arg
				  (keys (keyboard-layout-keys keyboard-layout))	;or subset
				  layout-label layout-label-character-style
				  )
  (multiple-value-bind (lleft ltop lright lbottom) (keyboard-layout-edges keyboard-layout)
    (multiple-value-bind (width height) (send stream :inside-size)
      (setq horizontal-fraction (* width horizontal-fraction)
	    vertical-fraction (and vertical-fraction (* height vertical-fraction)))
      (let ((string-width-scale (keys-draw-string-image-scale keys mapping-table stream
							      label-type label-arg))
	    (layout-label-height (with-character-style (layout-label-character-style stream
							 :bind-line-height t)
				   (* (send stream :line-height) 2)))
	    (scale (/ horizontal-fraction (- lright lleft))))
	(when vertical-fraction
	  (minf scale (/ (- vertical-fraction layout-label-height) (- lbottom ltop))))
	(let* ((lwidth (* scale (- lright lleft)))
	       (lheight (* scale (- lbottom ltop)))
	       (lheight-total (+ lheight layout-label-height)))
	  (graphics:with-room-for-graphics (stream (or vertical-fraction lheight-total))
	    (graphics:with-graphics-translation (stream
						  (/ (- width lwidth) 2)
						  (+ lheight-total
						     (if (null vertical-fraction) 0
							 (/ (- vertical-fraction lheight-total)
							    2))))
	      (graphics:with-graphics-scale (stream scale (- scale))
		(dolist (key keys)
		  (multiple-value-bind (label filled)
		      (keyboard-key-label key mapping-table label-type label-arg)
		    (keyboard-layout-key-draw key :filled filled :scale-thickness nil
						  :stream stream)
		    (graphics:with-drawing-state (stream :gray-level (if filled 0 1))
		      (draw-keyboard-layout-draw-label-internal key label
								stream string-width-scale)))))
	      (when layout-label
		(graphics:draw-string layout-label
				      (/ lwidth 2) (- lheight-total)
				      :attachment-y :bottom :attachment-x :center
				      :character-style layout-label-character-style
				      :stream stream)))))))))

(defun draw-keyboard-layout-draw-label-internal (key label stream string-width-scale)
  (labels ((draw-1 (label left top right bottom)
	     (flet ((draw-2 (string &rest drawing-args)
		      (unless (zerop (string-length string))
			(graphics:with-graphics-translation (stream
							      (/ (+ left right) 2)
							      (/ (+ top bottom) 2))
			  (graphics:with-graphics-scale (stream 1 -1)
			    (apply #'graphics:draw-string-image string 0 0
				   :attachment-x :center :attachment-y :center
				   :stream stream drawing-args))))))
	       (etypecase label
		 (character
		   (if (graphic-char-p label)
		       (stack-let ((string (make-array 1 :element-type 'character
						       :initial-element label)))
			 (draw-2 string :character-size (* (- bottom top) 3/4)))
		       (draw-1 (char-name label) left top right bottom)))
		 (string
		   (multiple-value-bind (nominal-width nil nil nominal-height)
		       (send stream :draw-string-size label)
		     ;; Draw with normal proportions, but scaled same for all.
		     (draw-2 label :character-size nominal-height
				   :string-width nominal-width
				   :scale string-width-scale)))
		 (cons
		   (let ((height (/ (- bottom top) (length label))))
		     (loop for y from top by height
			   for sublabel in label
			   do (draw-1 sublabel left y right (+ y height)))))
		 (null )
		 (symbol
		   (funcall label stream left top right bottom))))))
    (multiple-value-bind (left top right bottom)
	(keyboard-layout-key-edges key)
      (draw-1 label left top right bottom))))

;;; What character style size can be used to draw the labels of this type?
;;; A cache is maintained for drawing speed in fast update modes.
(defvar *keyboard-layout-character-size-cache* (make-hash-table :test 'equal))

(defun keyboard-layout-character-size (keyboard-layout mapping-table window
				       &optional (transform graphics:*identity-transform*)
						 (label-type :legend) label-type-arg)
  (let ((scale (first transform))
	(device-type (send window :display-device-type))
	(current-style (send window :merged-current-style)))
    ;; Should include a tick of mapping table modification also.
    (stack-let ((key (list keyboard-layout label-type label-type-arg
			   scale device-type current-style)))
      (multiple-value-bind (value found-p)
	  (gethash key *keyboard-layout-character-size-cache*)
	(when found-p
	  (return-from keyboard-layout-character-size
	    (values-list value))))
      (let ((single-label-size nil)
	    (other-label-size nil))
	(block get-style-sizes
	  (let ((keys (keyboard-layout-keys keyboard-layout))
		(single-too-large nil)
		(other-too-large nil))
	    (dw::map-over-valid-character-style-sizes-for-family-face
	      (lambda (size)
		(unless (eq size '*)
		  (with-character-size (size window)
		    (dolist (key keys)
		      (let ((label (keyboard-key-label key mapping-table
						       label-type label-type-arg))
			    (width (multiple-value-bind (left nil right nil)
				       (keyboard-layout-key-edges key)
				     (- (* (- right left) scale) 4))))	;A little margin
			(if (characterp label)
			    (unless single-too-large
			      (when (> (send window :character-width label) width)
				(setq single-too-large t)))
			    (unless other-too-large
			      (flet ((do-one (label)
				       (when (> (if (characterp label)
						    (send window :character-width label)
						    (send window :string-length label))
						width)
					 (setq other-too-large t))))
				(typecase label
				  (string (do-one label))
				  (cons (map () #'do-one label)))))))
		      (when (and single-too-large other-too-large)
			(return-from get-style-sizes))))
		  (when (or (null single-label-size) (not single-too-large))
		    (setq single-label-size size))
		  (when (or (null other-label-size) (not other-too-large))
		    (setq other-label-size size))))
	      (si:cs-family current-style) (si:cs-face current-style) current-style
	      :device device-type
	      :allow-relative nil)))
	(setf (gethash (copy-list key) *keyboard-layout-character-size-cache*)
	      (list single-label-size other-label-size))
	(values single-label-size other-label-size)))))

;;; For use to (dynamic) windows only.  Draw the initial outline and standard characters.
(defun present-keyboard-layout (keyboard-layout mapping-table window
				&optional presentation-table)
  (let ((transform
	  (multiple-value-bind (lleft ltop lright lbottom)
	      (keyboard-layout-edges keyboard-layout)
	    (multiple-value-bind (wleft wtop wright wbottom)
		(send window :visible-cursorpos-limits)
	      (let* ((scale-y (min (/ (* (- wright wleft) .9) (- lright lleft))
				   (/ (* (- wbottom wtop) .9) (- lbottom ltop))))
		     (scale-x (* scale-y (send (send window :screen) :pixel-aspect-ratio)))
		     (offset-x (+ wleft (/ (- (- wright wleft) (* scale-x (- lright lleft)))
					   2)))
		     (offset-y (+ wtop (/ (- (- wbottom wtop) (* scale-y (- lbottom ltop)))
					  2))))
		(list scale-x 0 0 scale-y offset-x offset-y)))))
	(inaccessible (compute-inaccessible-keys keyboard-layout (tv:sheet-console window))))
    (multiple-value-bind (single-label-size other-label-size)
	(keyboard-layout-character-size keyboard-layout mapping-table window transform)
      (let ((keys (keyboard-layout-keys keyboard-layout))
	    (presentation-type `((keyboard-layout-key-presentation
				   :keyboard-layout keyboard-layout))))
	(dolist (key keys)
	  (let ((presentation
		  (dw:with-output-as-presentation (:type presentation-type :object key
						   :stream window :single-box t)
		    (graphics:with-graphics-transform (window transform)
		      (when (member key inaccessible)
			(keyboard-layout-key-draw key :gray-level .1 :stream window))
		      (keyboard-layout-key-draw key :filled nil :stream window))
		    (present-keyboard-layout-draw-label-internal
		      key (keyboard-key-label key mapping-table) window transform
		      single-label-size other-label-size))))
	    (when presentation-table
	      (setf (aref presentation-table (keyboard-layout-key-code key))
		    presentation))))))
    transform))

(defun present-keyboard-layout-draw-label-internal (key label window transform
						    single-label-size other-label-size)
  (cond ((characterp label)
	 ;; Single character treated specially.
	 (with-character-size (single-label-size window)
	   (multiple-value-bind (width nil nil nil height)
	       (stack-let ((string (make-array 1 :element-type 'character
					         :initial-element label)))
		 (send window :string-length string))
	     (multiple-value-bind (left top right bottom)
		 (keyboard-layout-key-transformed-edges key transform)
	       (send window :draw-char label
		     (floor (- (+ left right) width) 2)
		     (floor (- (+ top bottom) height) 2))))))
	((and (symbolp label) label)
	 ;; Instead of using offset edges, use scales so that aspect
	 ;; ratio is adjusted for icon, too.
	 (graphics:with-graphics-transform (window transform)
	   (multiple-value-bind (left top right bottom)
	       (keyboard-layout-key-edges key)
	     (funcall label window left top right bottom))))
	(t
	 (labels ((draw-label-1 (label left top right bottom)
		    (etypecase label
		      (character
			(stack-let ((string (make-array 1 :element-type 'character
							:initial-element label)))
			  (draw-label-1 string left top right bottom)))
		      (string
			(with-character-size (other-label-size window)
			  (graphics:draw-string label
						(floor (+ left right) 2)
						(floor (+ top bottom) 2)
						:attachment-x :center
						:attachment-y :center
						:stream window)))
		      (cons
			(let ((height (/ (- bottom top) (length label))))
			  (loop for y from top by height
				for sublabel in label
				do
			    (draw-label-1 sublabel left y right (+ y height)))))
		      (null )
		      (symbol
			(funcall label window left top right bottom)))))
	   (multiple-value-bind (left top right bottom)
	       (keyboard-layout-key-transformed-edges key transform)
	     (draw-label-1 label left top right bottom))))))

(defun redraw-key-presentation (presentation window transform &optional (alu :flip))
  (keyboard-layout-key-redraw (dw:presentation-object presentation)
			      window presentation transform alu))

;;; Update the black XOR on keys that are down.
(defun update-keyboard-layout-key-states (keyboard window transform
					  presentation-table displayed-state-table)
  (dw:with-output-recording-disabled (window)
    (let ((state-table-now (sys:keyboard-key-states keyboard)))
      (loop for presentation being the array-elements of presentation-table
			     using (index code)
	    do
	(when presentation
	  (let ((state-now (aref state-table-now code)))
	    (unless (eq (aref displayed-state-table code) state-now)
	      (redraw-key-presentation presentation window transform)
	      (setf (aref displayed-state-table code) state-now))))))))

(defun clear-keyboard-layout-key-states (window transform
					 presentation-table displayed-state-table)
  (dw:with-output-recording-disabled (window)
    (loop for presentation being the array-elements of presentation-table
			   using (index code)
	  do
      (when (and presentation (aref displayed-state-table code))
	(redraw-key-presentation presentation window transform)
	(setf (aref displayed-state-table code) nil)))))

;;; Redraw the labels according to a new state.
(defun redraw-keyboard-layout-key-labels (keyboard-layout mapping-table window
					  transform presentation-table displayed-state-table
					  old-label-type old-label-type-arg
					  label-type label-type-arg)
  (multiple-value-bind (single-label-size other-label-size)
      (keyboard-layout-character-size keyboard-layout mapping-table window transform)
    (dw:with-output-recording-disabled (window)
      (loop for presentation being the array-elements of presentation-table
			     using (index code)
	    do
	(when presentation
	  (let* ((key (dw:presentation-object presentation))
		 (old-label (keyboard-key-label key mapping-table
						old-label-type old-label-type-arg))
		 (new-label (keyboard-key-label key mapping-table
						label-type label-type-arg)))
	    (unless (equal old-label new-label)
	      (when (or old-label (aref displayed-state-table code))
		(redraw-key-presentation presentation window transform :erase)
		(setf (aref displayed-state-table code) nil))
	      (when new-label
		(present-keyboard-layout-draw-label-internal key new-label window transform
							     single-label-size
							     other-label-size)))))))))

(defun show-mapping-key-chord (mapping mapping-table window transform
			       presentation-table state-table)
  (let ((shifts (ldb %%kbd-mapping-index-description-shifts mapping))
	(code (ldb %%kbd-mapping-index-description-key-code mapping)))
    (loop for presentation being the array-elements of presentation-table
			   using (index pcode)
	  do
      (when (and presentation
		 (or (= code pcode)
		     (let ((mapping (sys:map-key-to-software-char 0 pcode mapping-table)))
		       (and (integerp mapping)
			    (ldb-test sys:%%kbd-mapping-special mapping)
			    (let ((class (ldb sys:%%kbd-mapping-special-class mapping)))
			      (or (= class sys:%kbd-mapping-special-shift)
				  (= class sys:%kbd-mapping-special-locking-shift)
				  (= class sys:%kbd-mapping-special-locking-once-shift)))
			    (ldb-test (byte 1 (ldb sys:%%kbd-mapping-bit-number mapping))
				      shifts)))))
	(redraw-key-presentation presentation window transform)
	(setf (aref state-table pcode) t)))))


;;;; Control program

(dw:define-program-framework keyboard-control
  :command-definer t
  :inherit-from (dw:help-program)
  :command-table (:inherit-from '("help-program" "accept-values-pane-with-keyboard-commands"))
  :help keyboard-control-help
  :top-level (keyboard-control-top-level)
  :panes
  ((title :title :redisplay-function 'keyboard-control-title
		 :redisplay-after-commands nil)
   (keyboard :display :redisplay-function 'draw-keyboard :redisplay-after-commands nil)
   (command-menu :command-menu :menu-level :top-level)
   (interactor :interactor)
   (mappings :accept-values
	     :typeout-window t
	     :accept-values-function 'edit-mappings
	     :redisplay-after-commands t
	     :margin-components `dw:((margin-ragged-borders )
				     (margin-scroll-bar )
				     (margin-white-borders :thickness 2))
	     ))
  :configurations
  '((initial
      (:layout (initial :column title keyboard command-menu mappings interactor))
      (:sizes (initial (title 1 :lines)
		       (command-menu :ask-window self :size-for-pane command-menu)
		       (interactor 4 :lines)
		 :then (keyboard :even)
		       (mappings :even)))))
  :state-variables ((keyboard)
		    (keyboard-layout)
		    (mapping-table)
		    (editing-mappings nil)
		    (displayed-presentation-table)
		    (displayed-state-table)
		    (displayed-transform)
		    (raw-io-buffer))
  )

(cli::define-activity 'cli::program-choice-activity
		      :program-name 'keyboard-control
		      :name "Keyboard Control"
		      :description "Keyboard Control"
		      :clobber-p t
		      :choice-predicate 'choose-keyboard-control-if-reasonable)

(defun choose-keyboard-control-if-reasonable (superior)
  (let* ((keyboard (sys:console-keyboard (tv:sheet-console superior)))
	 (keyboard-layout (find-keyboard-layout (sys:keyboard-layout-type keyboard)
						:if-does-not-exist nil)))
    (if (null keyboard-layout)
	"Keyboard Control cannot be used on a console with an unrecognized keyboard."
	'keyboard-control)))

(defun-in-flavor (set-default-keyboard keyboard-control) ()
  (setq keyboard (sys:console-keyboard (tv:sheet-console dw:*program-frame*))
	keyboard-layout (find-keyboard-layout (sys:keyboard-layout-type keyboard))
	mapping-table (sys:keyboard-keyboard-table keyboard)))

(defun-in-flavor (initialize-keyboard-layout-tables keyboard-control) ()
  (setq displayed-presentation-table (make-array (keyboard-layout-key-code-limit
						   keyboard-layout))
	displayed-state-table (make-array (keyboard-layout-key-code-limit keyboard-layout)
					  :element-type 'boolean)))

(defmethod (keyboard-control-help keyboard-control) (stream string-so-far)
  (dw:help-program-help self stream string-so-far "
Click on a command from the menus in the middle,
or select a key for which to edit the mappings.
"))

(defmethod (keyboard-control-top-level keyboard-control) (&rest args)
  ;; Make this in our process for the sake of selection.
  (setq raw-io-buffer (tv:make-io-buffer 512 nil nil '(:raw t)))
  (set-default-keyboard)
  (initialize-keyboard-layout-tables)
  (apply #'dw:default-command-top-level self args))

(defmethod (keyboard-control-title keyboard-control) (window)
  (si:x-centering-in-window (window)
    (present (dw:program-pretty-name self) 'dw:program-name :stream window)
    (format window " (~A)" (keyboard-layout-pretty-name keyboard-layout))))

(defmethod (draw-keyboard keyboard-control) (window)
  (setq displayed-transform
    (with-character-style ((keyboard-layout-legend-character-style keyboard-layout) window)
      (present-keyboard-layout keyboard-layout mapping-table window
			       displayed-presentation-table)))
  (fill displayed-state-table nil))

(defmethod (edit-mappings keyboard-control) (stream)
  (when editing-mappings
    (if (eq editing-mappings 't)
	;;+++ Could use better formatting, and separation of classes of entry, like
	;;graphic characters, shifts, etc,
	(dotimes (code (sys:keyboard-table-key-code-limit mapping-table))
	  (edit-mappings-internal mapping-table keyboard-layout code stream))
	(edit-mappings-internal mapping-table keyboard-layout
				(keyboard-layout-key-code editing-mappings) stream))))

(defun edit-mappings-internal (mapping-table keyboard-layout code stream)
  (flet ((encode (shift)
	   (sys:%logdpbs
	     (sys:%logdpbs
	       (ldb sys:%%kbd-mapping-table-index-symbol shift)
	       sys:%%kbd-shifts-symbol
	       (ldb sys:%%kbd-mapping-table-index-shift shift)
	       sys:%%kbd-shifts-shift
	       0)
	     %%kbd-mapping-index-description-shifts
	     code %%kbd-mapping-index-description-key-code
	     0)))
    (let* ((type `((mapping-index-description :keyboard-layout ,keyboard-layout)))
	   (limit (sys:keyboard-table-shift-index-limit mapping-table))
	   (max (string-length (present-to-string (encode (1- limit)) type))))
      (dotimes (shift limit)
	(let ((old-mapping (aref mapping-table shift code))
	      (new-mapping (let ((index (encode shift)))
			     (accept 'mapping-table-entry
			       :default (aref mapping-table shift code) :provide-default t
			       :query-identifier index
			       :prompt (let ((description (present-to-string index type)))
					 (format () "~@vT~A  "
						 (- max (string-length description))
						 description))
			       :prompt-mode :raw
			       :stream stream))))
	  (unless (eql old-mapping new-mapping)
	    ;; Do this for effect.  It makes a copy of the original for later comparison.
	    (keyboard-layout-settable-mapping-table keyboard-layout)
	    (setf (aref mapping-table shift code) new-mapping)))))))

(defun-in-flavor (with-raw-keyboard-window-internal keyboard-control) (function)
  (declare (sys:downward-funarg function))
  (unless keyboard
    (dw:command-error "You cannot give this command unless the real keyboard is showing"))
  (fs:force-user-to-login)
  (let ((*debug-io* "Normal keyboard usurped")
	(window (dw:get-program-pane 'keyboard)))
    (unwind-protect
	(progn
	  (send window :set-io-buffer raw-io-buffer)
	  (tv:window-call-relative (window)
	    (funcall function window)))
      (send window :set-io-buffer (send dw:*program-frame* :io-buffer))
      (clear-keyboard-layout-key-states
	window displayed-transform displayed-presentation-table displayed-state-table))))

(defmacro-in-flavor (with-raw-keyboard-window keyboard-control) ((window) &body body)
  `(with-raw-keyboard-window-internal #'(lambda (,window) ,@body)))

(zwei:defindentation (with-raw-keyboard-window 1 1))

;;;--- Temporary
(defmethod (mouse-max-n-buttons tv:basic-mouse :default) () 3)

(defvar *key-test-uses-rat* nil)		;Cute, but unprofessional.

(defun mouse-blinker-character-for-buttons (buttons-down max-n-buttons)
  (setq max-n-buttons (min 3 (max 1 max-n-buttons)))	;All that's in the font.
  (when (and *key-test-uses-rat* (= max-n-buttons 3))
    (setq max-n-buttons 4))			;Special set
  (make-character (code-char (dpb (1- max-n-buttons) (byte 2 3) buttons-down))
		  :style '(:device-font fonts:key-test-mouse :normal)))

(define-keyboard-control-command
  (com-key-test :menu-accelerator t
		:menu-documentation "Display all raw keyboard and mouse transitions")
    ()
   (with-raw-keyboard-window (window)
     (format *query-io* "~&Hit END to finish.~%")
     (let* ((mouse-window (dw:get-program-pane 'mappings))
	    (console (tv:sheet-console mouse-window))
	    (mouse (sys:console-mouse console))
	    (n-buttons (mouse-max-n-buttons mouse))
	    (last-mouse-buttons nil))
       (multiple-value-bind (left top right bottom)
	   (send mouse-window :visible-cursorpos-limits)
	 (send mouse-window :set-mouse-position (floor (+ left right) 2)
						(floor (+ top bottom) 2)))
       (send mouse-window :set-mouse-blinker-type :character)
       (unwind-protect
	   (loop named top do
	     (send window :input-wait "Key Test"
		   #'(lambda (last-mouse-buttons mouse)
		       (neq last-mouse-buttons (tv:mouse-last-buttons mouse)))
		   last-mouse-buttons mouse)
	     (loop while (send mouse-window :any-tyi-no-hang))	;Just discard click blips here.
	     (let ((mouse-buttons (tv:mouse-last-buttons mouse)))
	       (unless (eql last-mouse-buttons mouse-buttons)
		 (let ((char (mouse-blinker-character-for-buttons mouse-buttons n-buttons)))
		   (send mouse-window :set-mouse-blinker-character char)
		   (when (eq mouse-window (tv:mouse-window mouse))
		     (tv:mouse-set-blinker-definition-internal mouse :character 0 0 :on
		       :set-character char)))
		 (setq last-mouse-buttons mouse-buttons)))
	     (loop
	       (update-keyboard-layout-key-states keyboard window displayed-transform
						  displayed-presentation-table
						  displayed-state-table)
	       (let ((hard-char (send window :any-tyi-no-hang)))
		 (when (null hard-char)
		   (return))
		 (when (integerp hard-char)
		   (let ((soft-char (sys:console-convert-to-software-char console hard-char)))
		     (when (eql soft-char #\End)
		       (return-from top)))))))
	 (send mouse-window :set-mouse-blinker-character #\mouse:nw-arrow)
	 (send mouse-window :set-mouse-blinker-type :default)
	 (when (eq mouse-window (tv:mouse-window mouse))
	   (send mouse-window :mouse-standard-blinker))))))

(define-keyboard-control-command
  (com-typing-test
    :menu-accelerator t
    :menu-documentation "Display key transitions and mapping changes while typing")
    ()
   (let ((label-type :legend)
	 (label-arg nil))
     (unwind-protect
	 (with-raw-keyboard-window (window)
	   (let ((console (tv:sheet-console window))
		 (read-stream *terminal-io*)
		 (process nil))
	     (fresh-line read-stream)
	     ;; Pretend that typeout window is selected.
	     (tv:blinker-set-visibility (send read-stream :following-blinker) :blink)
	     (flet ((raw-process ()
		      (unwind-protect
			  (loop
			    (redraw-keyboard-layout-key-labels
			      keyboard-layout mapping-table window displayed-transform
			      displayed-presentation-table displayed-state-table
			      label-type label-arg
			      (setq label-type :mapping-including-shifts)
			      (setq label-arg
				    (let ((shifts (sys:keyboard-shifts keyboard)))
				      (sys:dpbs (ldb sys:%%kbd-shifts-shift shifts)
						sys:%%kbd-mapping-table-index-shift
						(ldb sys:%%kbd-shifts-symbol shifts)
						sys:%%kbd-mapping-table-index-symbol 0))))
			    (update-keyboard-layout-key-states
			      keyboard window displayed-transform
			      displayed-presentation-table
			      displayed-state-table)
			    (let ((hard-char (tv:io-buffer-get raw-io-buffer)))
			      (when (integerp hard-char)
				(let ((soft-char (sys:console-convert-to-software-char
						   console hard-char)))
				  (when soft-char
				    (send read-stream :force-kbd-input soft-char))
				  (when (eql soft-char #\End)
				    (return))))))
			(setq process nil))))
	       (unwind-protect
		   (progn
		     (setq process
			   (process-run-function "Monitor raw keystrokes" #'raw-process))
		     (accept '((string) :delimiters (#\End))
			     :default nil :stream read-stream))
		 (when process
		   (process-kill process))))))
       (let ((window (dw:get-program-pane 'keyboard)))
	 (with-character-style ((keyboard-layout-legend-character-style keyboard-layout)
				window)
	   (redraw-keyboard-layout-key-labels
	     keyboard-layout mapping-table window displayed-transform
	     displayed-presentation-table displayed-state-table
	     label-type label-arg :legend nil))))))

(define-keyboard-control-command (com-show-codes
				   :provide-output-destination-keyword t)
    (&key (radix 'integer :default 8))
   (fresh-line)
   (formatting-table (t :multiple-columns t)
     (dolist (key (keyboard-layout-keys keyboard-layout))
       (formatting-row ()
	 (format-cell (keyboard-key-label key mapping-table :name) #'write-string)
	 (format-cell (keyboard-key-label key mapping-table :code radix) #'write-string)))))

(define-keyboard-control-command (com-where-is :menu-accelerator t
				   :menu-documentation "Show how to type a character")
    ((character '((extended-character)) :default nil :confirm t))
   (let ((mappings (find-character-mapping-indices character mapping-table)))
     (if (null mappings)
	 (format t "~&There is no way to type ~@\\presentation\\."
		 character 'extended-character)
	 (let ((window (dw:get-program-pane 'keyboard)))
	   (unwind-protect
	       (progn
		 (show-mapping-key-chord (first mappings) mapping-table
					 window displayed-transform
					 displayed-presentation-table displayed-state-table)
		 (format t "~&~@\\presentation\\ can be typed as "
			 character 'extended-character)
		 (let ((type `((mapping-index-description :keyboard-layout ,keyboard-layout
							  :mapping-table ,mapping-table))))
		   (formatting-textual-list (t :conjunction "or" :filled t)
		     (let ((mappings mappings))
		       (loop while mappings do
			 (let* ((next (first mappings))
				(shifts (ldb %%kbd-mapping-index-description-shifts next))
				(key (ldb %%kbd-mapping-index-description-key-code next))
				(any-p nil))
			   (flet ((reshift (shift symbol)
				    (dpb (sys:dpbs shift sys:%%kbd-shifts-shift
						   symbol sys:%%kbd-shifts-symbol
						   shifts)
					 %%kbd-mapping-index-description-shifts
					 next)))
			     (when (loop for shift below 2
					 always (loop for symbol below 2
						      always (member (reshift shift symbol)
								     mappings)))
			       (setq mappings (cons (reshift 0 0)
						    (remove key mappings
							    :key #'(lambda (x)
								     (ldb %%kbd-mapping-index-description-key-code x))))
				     any-p t))
			     (let ((mapping (pop mappings)))
			       (formatting-textual-list-element ()
				 (present mapping type)
				 (when any-p
				   (format t " (with any combination of shift and symbol)"))))
			     ))))))
		 (dw:remove-window-typeout-window (send *terminal-io* :superior)))
	     (clear-keyboard-layout-key-states window displayed-transform
					       displayed-presentation-table
					       displayed-state-table))))))

(define-keyboard-control-command (com-edit-mappings :menu-accelerator t)
    ((mappings `((dw:token-or-type (("None" . nil) ("All" . t))
				   ((keyboard-layout-key-presentation
				      :keyboard-layout ,keyboard-layout))))
	       :prompt "for (a key, All, or None)"
	       :confirm t))
   (setq editing-mappings mappings))

(define-presentation-to-command-translator edit-this-keys-mappings
   (keyboard-layout-key-presentation
     :documentation "Edit this key's mappings")
   (key)
  `(com-edit-mappings ,key))

(define-keyboard-control-command
  (com-show-differences :menu-accelerator t
    :menu-documentation "Show differences between this mapping and standard one")
    ()
   (let ((differences (mapping-table-differences mapping-table
						 (keyboard-layout-original-mapping-table
						   keyboard-layout))))
     (if (null differences)
	 (format t "~&There are no differences.~%")
	 (let ((index-type `((mapping-index-description :keyboard-layout ,keyboard-layout))))
	   (fresh-line)
	   (formatting-table ()
	     (formatting-column-headings (t :underline-p t)
	       "Keys" "Present mapping" "Standard mapping")
	     (loop for (index mapping-1 mapping-2) in differences do
	       (formatting-row ()
		 (formatting-cell ()
		   (present index index-type))
		 (formatting-cell ()
		   (present mapping-1 'mapping-table-entry))
		 (formatting-cell ()
		   (present mapping-2 'mapping-table-entry)))))))))

(define-keyboard-control-command
  (com-revert :menu-accelerator t
    :menu-documentation "Reset mapping to standard one")
    ()
   (copy-array-contents (keyboard-layout-original-mapping-table keyboard-layout)
			mapping-table))

(define-keyboard-control-command
  (com-save-differences :menu-accelerator t
    :menu-documentation "Save differences on the kill ring")
    ()
   (let ((differences (mapping-table-differences mapping-table
						 (keyboard-layout-original-mapping-table
						   keyboard-layout))))
     (when (null differences)
       (dw:command-error "There are no differences."))
     (let ((forms (mapping-table-difference-forms mapping-table keyboard-layout differences))
	   (interval (zwei:create-interval nil nil (make-instance 'zwei:kill-ring-interval))))
       (let ((stream (zwei:interval-stream interval)))
	 (dolist (form forms)
	   (write form :stream stream :pretty t :base 16 :radix t :case :downcase)
	   (terpri stream)))
       (send zwei:*kill-history* :push interval)))
   (format *query-io* "The appropriate forms have been saved on the kill ring."))

(defun unstandardize-keyboard-mapping (mapping)
  (when (integerp mapping)
    (setq mapping (if (ldb-test sys:%%kbd-mapping-special mapping)
		      (selector (ldb sys:%%kbd-mapping-special-class mapping) =
			((sys:%kbd-mapping-special-shift
			  sys:%kbd-mapping-special-locking-shift
			  sys:%kbd-mapping-special-locking-once-shift)
			 (let ((basic (aref sys:*kbd-mapping-bit-names*
					    (ldb sys:%%kbd-mapping-shift-index mapping))))
			   (selector (ldb sys:%%kbd-mapping-special-class mapping) =
			     (sys:%kbd-mapping-special-locking-shift
			       `(,basic :locking t))
			     (sys:%kbd-mapping-special-locking-once-shift
			       `(,basic :locking :once))
			     (otherwise basic))))
			(sys:%kbd-mapping-special-unassigned nil)
			(sys:%kbd-mapping-special-noop :noop)
			(sys:%kbd-mapping-special-mouse-button
			  (nth (ldb sys:%%kbd-mapping-bit-number mapping)
			       sys:*kbd-mapping-mouse-button-names*)))
		      (code-char mapping))))
  mapping)

(defun mapping-table-difference-forms (mapping-table keyboard-layout differences)
  (loop while differences collect
    (destructuring-bind (index mapping nil) (pop differences)
      `(sys:set-keyboard-table-mapping
	 ,(unstandardize-keyboard-mapping mapping)
	 ,(keyboard-layout-symbolic-name keyboard-layout)
	 ,(ldb %%kbd-mapping-index-description-key-code index)
	 ,@(let ((shifts (ldb %%kbd-mapping-index-description-shifts index)))
	     (if (and (zerop shifts)
		      (let ((more differences))
			(when (loop for other-shift from 1
						    below (sys:keyboard-table-shift-index-limit
							    mapping-table)
				    while more
				    always (destructuring-bind (other-index other-mapping nil)
					       (pop more)
					     (and (eql other-mapping mapping)
						  (= other-index
						     (dpb (sys:%logdpbs
							    (ldb sys:%%kbd-mapping-table-index-symbol
								 other-shift)
							    sys:%%kbd-shifts-symbol
							    (ldb sys:%%kbd-mapping-table-index-shift
								 other-shift)
							    sys:%%kbd-shifts-shift
							    0)
							  %%kbd-mapping-index-description-shifts
							  index)))))
			  (setq differences more)
			  t)))
		 '(:all-shifts t)
		 (append (and (ldb-test sys:%%kbd-shifts-shift shifts)
			      '(:shift t))
			 (and (ldb-test sys:%%kbd-shifts-symbol shifts)
			      '(:symbol t)))))))))

(define-keyboard-control-command
  (com-hardcopy-layout :menu-accelerator "Hardcopy"
		       :menu-documentation (:left "Hardcopy the current layout and mappings"))
    (&key
      (printer 'sys:printer :default hardcopy:*default-text-printer*
	       :documentation "Printer to use")
      (orientation '((member :portrait :landscape))
		   :default :portrait :documentation "Orientation on printed page")
      (include-legends 'boolean :default t
		       :documentation "Include a page of the actual keytop legends")
      (include-mappings 'boolean :default t
			:documentation "Include pictures of the variously shifted mappings")
      (include-codes '((alist-member :alist (("No" . nil)
					     ("Octal" . 8)
					     ("Decimal" . 10)
					     ("Hex" . 16))))
		     :default nil :provide-default t
		     :documentation "Include hardware mapping codes")
      #+ignore ;; Don't confuse the user with these keysyms, since they're probably wrong.
      (include-keysyms 'boolean :default nil
		       :documentation "Include X keysym codes")
      )
   (hardcopy-keyboard-layout keyboard-layout mapping-table
			     :printer printer
			     :landscape-p (eq orientation :landscape)
			     :include-legends include-legends
			     :include-mappings include-mappings
			     :include-codes include-codes
			     :include-keysyms #+ignore include-keysyms #-ignore nil))

(defun hardcopy-keyboard-layout (keyboard-layout mapping-table
				 &key (printer hardcopy:*default-text-printer*)
				      (landscape-p nil)
				      (include-legends t)
				      (include-mappings t)
				      (include-codes nil)
				      (include-keysyms nil))
  (with-open-stream (stream (hardcopy:make-hardcopy-stream printer
			      :title (format nil "~A keyboard layout"
					     (keyboard-layout-pretty-name keyboard-layout))
			      :landscape-p landscape-p))
    (flet ((one-table (&rest args)
	     (apply #'draw-keyboard-layout keyboard-layout
		    :mapping-table mapping-table :stream stream args)))
      (when include-legends
	(with-character-style ((keyboard-layout-legend-character-style keyboard-layout)
			       stream)
	  (ignore stream)			;Known to side effect same stream
	  (one-table :vertical-fraction (unless landscape-p .75)
		     :layout-label (keyboard-layout-pretty-name keyboard-layout)
		     :layout-label-character-style '(:swiss :roman :large))))
      (when include-codes
	(one-table :label-type :code :label-arg include-codes))
      (when include-keysyms
	(one-table :label-type :keysym))
      (when include-mappings
	(dotimes (index (sys:keyboard-table-shift-index-limit mapping-table))
	  (one-table :vertical-fraction (unless landscape-p .45)
		     :label-type :mapping-including-shifts :label-arg index))))))

(define-keyboard-control-command
  (com-hardcopy-all-layouts )
    (&key
      (printer 'sys:printer :default hardcopy:*default-text-printer*
	       :documentation "Printer to use")
      (orientation '((member :portrait :landscape))
		   :default :portrait :documentation "Orientation on printed page")
      (matching '((sequence string)) :default nil
		:documentation "Select layouts matching the given names"))
   (with-open-stream (stream (hardcopy:make-hardcopy-stream printer
			       :title (format nil "Keyboard layouts~@[ matching ~{~A~^, ~}~]"
					      matching)
			      :landscape-p (eq orientation :landscape)))
     (dolist (keyboard-layout
	       (sort
		 (loop for keyboard-layout in *keyboard-layouts*
		       when (or (null matching)
				(loop for string in matching
				      thereis (string-search string
							     (keyboard-layout-pretty-name
							       keyboard-layout))))
			 collect keyboard-layout)
		 #'string-lessp :key #'keyboard-layout-pretty-name))
       (draw-keyboard-layout keyboard-layout :stream stream
			     :layout-label (keyboard-layout-pretty-name keyboard-layout)
			     :layout-label-character-style '(:swiss :roman :large)))))

(define-keyboard-control-command
  (com-set-keyboard :menu-accelerator t
		    :menu-documentation "Show another keyboard layout's mappings")
    ((layout '((token-or-type (:default) keyboard-layout))
	       :default :default :prompt "layout"))
   (if (eq layout :default)
       (set-default-keyboard)
       (setq keyboard nil
	     keyboard-layout layout
	     mapping-table (keyboard-layout-default-mapping-table layout)))
  (initialize-keyboard-layout-tables)
  (send dw:*program-frame* :redisplay-pane 'title t)
  (send dw:*program-frame* :redisplay-pane 'keyboard t))

(compile-flavor-methods keyboard-control)

(cp:define-command (com-show-keyboard-layout :command-table "Documentation")
    ((keyboard-layout
       'keyboard-layout
       :default (find-keyboard-layout
		  (sys:keyboard-layout-type
		    (sys:console-keyboard
		      (send (tv:console-default-superior) :console)))
		  :if-does-not-exist nil)
       :provide-default (find-keyboard-layout
			  (sys:keyboard-layout-type
			    (sys:console-keyboard
			      (send (tv:console-default-superior) :console)))
			  :if-does-not-exist nil))
     &key
     (include-legends 'boolean :default t
		      :documentation "Include a page of the actual keytop legends")
     (include-mappings
       `((alist-member
	   :alist ,(let ((default (keyboard-layout-default-mapping-table keyboard-layout))
			 (current 
			   (let ((keyboard
				   (sys:console-keyboard
				     (send (tv:console-default-superior) :console))))
			     (and (eq (sys:keyboard-layout-type keyboard)
				      (keyboard-layout-symbolic-name keyboard-layout))
				  (sys:keyboard-keyboard-table keyboard)))))
		     (append (and current
				  (or (null default)
				      (equalp default current))
				  `(("Yes" ,current)))
			     (and default
				  (null current)
				  `(("Yes" ,default)))
			     (and default
				  current
				  (not (equalp default current))
				  `(("Current" ,current) ("Default" ,default)))
			     `(("No" nil))))))
       :default (or (let ((keyboard
			    (sys:console-keyboard
			      (send (tv:console-default-superior) :console))))
		      (and (eq (sys:keyboard-layout-type keyboard)
			       (keyboard-layout-symbolic-name keyboard-layout))
			   (sys:keyboard-keyboard-table keyboard)))
		    (keyboard-layout-default-mapping-table keyboard-layout))
       :provide-default t
       :documentation "Include pictures of the variously shifted mappings")
     (include-codes '((alist-member :alist (("No" . nil)
					    ("Octal" . 8)
					    ("Decimal" . 10)
					    ("Hex" . 16))))
		    :default nil :provide-default t
		    :documentation "Include hardware mapping codes")
     )
   (terpri)
   (when include-legends
     (with-character-style ((keyboard-layout-legend-character-style keyboard-layout))
       (draw-keyboard-layout
	 keyboard-layout
	 :layout-label (keyboard-layout-pretty-name keyboard-layout)
	 :layout-label-character-style '(:swiss :roman :large))))
   (when include-codes
     (draw-keyboard-layout
       keyboard-layout
       :label-type :code
       :label-arg include-codes))
   (when include-mappings
     (dotimes (index (sys:keyboard-table-shift-index-limit include-mappings))
       (draw-keyboard-layout
	 keyboard-layout
	 :mapping-table include-mappings
	 :label-type :mapping-including-shifts :label-arg index))))

;;;+++ Could have a pop-up window to enter a "extended" character.  Might be useful
;;;with primitive keyboards and funny character sets.
