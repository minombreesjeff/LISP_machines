;;; -*- Mode: Lisp; Package: COMPILER; Lowercase: T; Base: 8 -*-
;;; This file is >compiler>defs.
;;; This file contains definitions of global variables and data structurea
;;; that are part of the Lisp Compiler.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defmacro defvariant (name base-structure selector suffix)
  (let ((definer (intern (string-append name "-METHOD"))))
    `(progn
       (defmacro ,name (variant print-format &body fields)
	 (let* ((new-name (intern (string-append variant ,suffix)))
		(constructor-name (intern (string-append "MAKE-" new-name))))
	   `(progn
	      (defflavor ,new-name
		      ;; Default instance variables to NIL, rather than unbound
		      ,(loop for field in fields
			     collect (if (atom field)
					 `(,field nil)
					 field))
		      (,',base-structure)
		:readable-instance-variables
		:writable-instance-variables
		:initable-instance-variables
		:locatable-instance-variables
		(:conc-name "")
		(:constructor ,constructor-name))
	      (defmethod (,',selector ,new-name) ()
		',variant)
	      (defmethod (sys:print-self ,new-name) (stream ignore slashify)
		(if slashify
		    (si:printing-random-object (self stream)
		      (format stream ,@print-format))
		    (format stream ,@print-format))))))
       (defmacro ,definer ((fun name) arglist &body body)
	 (let ((new-name (intern (string-append name ,suffix) ',(pkg-name package))))
	   `(defmethod (,fun ,new-name) ,arglist
	      (declare (sys:function-parent ,',definer (,fun ,name)))
	      ,@body))))))

(defmacro defstructvariant (name base-structure selector suffix)
  `(defmacro ,name (variant &body fields)
     (let ((new-name (intern (string-append variant ,suffix))))
       `(progn 
	  (cl:defstruct (,new-name
			 (:include ,',base-structure
			  (,',selector ',variant))
			 (:conc-name nil) (:copier nil) (:predicate nil) (:inline nil))
	    . ,fields)
	  (putprop ',new-name
		   (get ',',base-structure 'named-structure-invoke)
		   'named-structure-invoke)))))

;;;; Global variables.

(defvar *starting-warning-tick*)      ; Warning count at the start of the
				      ; stream compilation of a form.


;;; Phase 1 variables.

(defvar *pframe*)		       ; The current pframe.
(defvar *function*)		       ; "function" structure for current function.
(defvar *function-list*)	       ; List of "function"s defined in this function family.
;;(defvar *lexical-list*)		       ; List of lexical variables defined i. t. f. f.
(defvar *last-inst*)		       ; Last instruction to be emitted.
(defvar *multiple-count*)	       ; Number of multiple groups on the control stack.
(defvar *nested-unwind-protects*)      ; Number of unwind-protect handlers on the control stack
(defvar *function-name*)	       ; When compiling a function call, this symbol gets
				       ;  bound to the name of the function being called.
(defvar *function-call-subforms*)      ; When compiling a function call, this symbol gets
				       ;  bound to the subforms of the function call list.
(defvar *argno*)		       ; The current argument number when compiling a form
				       ;  that is a function call.

;;; This symbol holds the source location token, and is bound when the macro
;;; si:source-locator is expanded during phase-1
(defvar *source-locator* nil)	       ; we hope this nil doesn't ever show up in inst's
(defvar-resettable *use-source-locators* nil)	; :lisp-list or :lisp-bp if you
						; want source location info

(defvar *source-locator-word-maker*)   ; bind to a function of three arguments, being the
				       ; start pc, the pc interval, and the source locator
				       ; called to build a word of source locator information
				       ; for the source locator array
(defvar *correspondences* nil)
(defvar *read-correspondences* nil)    ; si:xr-correpondence for lisp source locator

;;;
;;; When using source locators, this ensures that duplicate instruction
;;; sequences are not collapsed into each other.  This generates code which
;;; is larger but not slower, modulo short/long branch effects.  Most of the time,
;;; people who set *use-source-locators* also set *inhibit-phase-3-crossjumping*.
;;;
(defvar-resettable *inhibit-phase-3-crossjumping* nil)

;;;
;;; The foreign languages understand how their variables are allocated and
;;; may not need the local map.  Provide a hook to omit generation of the local map
;;;
(defvar-resettable *inhibit-local-map* nil)

;;; These variables define the lexical environment.  They are alists associating
;;; symbolic names to internal data structures.
(defvar *lexical-variables* nil)       ; Variable name => "variable" structure.
(defvar *special-variables* nil)       ; Variable name => "variable" structure.
(defvar *instance-variables* nil)      ; Variable name => "variable" structure.
(defvar *functions* nil)	       ; Function name => "function" structure.
(defvar *progs* nil)		       ; Prog name => "prog-pframe" structure.
				       ; Elements are (name invisiblep structure).
(defvar *tags* nil)		       ; Tag name => "tag" structure.
(defvar-resettable *interpreter-lexical-environment* nil)

;;; These variables are used by lexical scoping
(defvar *function-declared-downward* nil) ; Lambda contains (DECLARE (SYS:DOWNWARD-FUNCTION))
;;(defvar *non-local-go-tags* nil)     ; List of tags that are GOne to by internal functions.
(defvar *compiler-generated-lexical-list* nil)

(defvar *unknown-variable-names*)      ; List of symbols that were automatically SPECIALed.

(defvar *phase-1-form* nil)	       ; Form being phase-1ed now.
(defvar *phase-1-optimize-p* t)        ; Run optimizers and style-checkers if non-nil.
(defvar *transform-destination*)       ; Lets transformers know the pending destination.
(defvar *transform-environment*)       ; Lets transformers know the environment.
(defvar *functions-transformed*)       ; Records all macroexpansions.
(defvar *constants-open-coded*)	       ; Records all open-codings of DEFCONSTANT constants.
(defvar *transformations-before-phase-1* nil)	;Records transformations if using source loc.
(defvar *function-extra-intervals*)    ; Additional intervals that are part of the function
				       ; being compiled

(defvar *phase-1-variable-size*)		; kludge for passing around info
						; on how many stack slots lexical
						; vars take up in the face of 
						; dynamic-extent
(defvar *phase-1-variable-offset*)		; similar kludge for offset, ie for
						; a >1 sized thing, what stack slot 
						; to address

(defvar *dbs-pframe*)
(defvar *looping*)

(defconst *enable-frame-splitting* #+3600 nil #+imach t)

(defvar *local-block-size-adjustment* 0)	;Fudge factor for local block size in
						;frame splitting.

(defvar *optimize-slot-value*)

;;; Phase 2 variables and constants.
(defvar *dead*)			       ; The code we are looking at is unreachable.
(defvar *level*)		       ; The current control stack level.
(defvar *l-level*)		       ; The local block level.
(defvar *b-level*)		       ; The current binding stack level.
(defvar *local-block-offset*)	       ; The base of the local block
(defvar *max-level*)		       ; Maximum value of *level*.
(defvar *max-l-level*)		       ; Maximum value of *l-level*.
(defvar *dead-tags*)		       ; Collects all tags which become dead in phase 2.
(defvar *initial-n-retries* 3)
(defvar *n-retries* ) 		       ;number of times we retry to split

(defvar *all-vars-stack-resident* nil) ; Forces Phase-2 to treat all lexical variable
				       ;  as stack resident.
;;; Phase 3 variables
(defvar *run-phase-3* t)	       ; Only run phase 3 if this is true.
(defvar *phase-3-instruction*)	       ; The instruction currently being considered.
(defvar *phase-3-last-instruction*)    ; The last instruction in the current interval.
(defvar *phase-3-intervals-optimized*) ; List of intervals optimized so far.

;;; >>> Is any of this machine independent??? <<<
;;; Phase 4 variables.
(defvar *object-array*)		       ; Objects in the object section of the cc object.
(defvar *instruction-array*)	       ; Instructions in the instruction section.
(defvar *source-locator-array*)	       ; Parallel to the instruction array, we maintain an
				       ; array giving the source location tokens
(defvar *all-dispatches*)	       ; Dispatches, which have to be assembled in.
(defvar *all-branches*)		       ; Branches, which might have to be lengthened.
(defvar *all-tags*)		       ; Tags, which might have to be displaced.
(defvar *stack-smashed*)	       ; The top of the stack is not valid.
(defvar *all-error-jumps*)	       ; All error jumps
(defvar *frame-function*)	       ; The closest non-quick ancestor.
(defvar *lexical-variable-instructions*)	; Instructions that access lexical variables
(defvar *instance-variable-instructions*)	; Instructions that access instance variables
(defvar *mapping-table-instructions*)  ; Instructions that reference into the mapping table
(defvar *fdefinition-location-hints*)  ; Alist of object offset and fspec
(defvar *local-map*)		       ; Used in debugging info to name local variables
(defvar *phase-4-to-core*)	       ; T if compiling to core, NIL if compiling to file
(defvar *push-tag-address-inst-list*)  ; Alist of index in instruction array and tag structure
				       ; being referred to.  Phase 4 fixes these up.
(defvar *dispatch-interval-p* nil)     ; Used to control access to captive arguments

(defvar *internal-functions* nil)		;Alist of parent functions and all their
						; internal functions.
(defvar *pc-tags*)				;List of PC tags - scope is whole definition

(defvar-resettable *allow-wired-compile-to-core* nil)

(defconst *funcalling-functions* '(funcall cl:apply %funcall-n %lexpr-funcall-n))

;; Tells begin-processing-function to reset the function def error info.
(defconst *reset-function-definition-warnings* t)

(defvar *function-mapping-table-families*)

;;; For debugging ONLY.

(defvar *lexical-uid* 0)	       ; lexical-uid counter.
(defvar *pframe-uid* 0)		       ; frame uid counter.
(defvar *tag-uid* 0)		       ; Incremented to produce new names for tags.
(defvar *internal-function-uid* 0)     ; Internal function uid counter.
(defvar *parent-function-offset-list* nil) ; used to collect the function structures
                                           ; for all internal functions
(defvar *phase-2-debug-p* nil)	       ; Print out junk during phase 2.
(defvar *debug-phase-3* nil)	       ; Print out optimizations as they are made.
(defvar *lc-print-1* nil)	       ; Tools should print the Byte Lap result of
(defvar *lc-print-2* nil)	       ;   phases 1, 2, and 3
(defvar *lc-print-3* nil)
(defvar *lc-2* t)		       ; Tools should run phase 2 at all.
(defvar *p4-trace* nil)


;;; Control stack states keep track of the number of groups of unknown size on the
;;; stack.  
(defvar *control-stack-state*)         ; Information about the control stack

(defflavor control-stack-state
	((unknown-group-count 0)
	 (unknown-group-incremented nil)
	 (parent nil)
	 (children nil)
	 (n-catch-blocks 0)
	 (n-bindings 0))
	()
  :readable-instance-variables
  :writable-instance-variables
  :initable-instance-variables
  (:constructor make-control-stack-state
   (&optional (unknown-group-count 0) (parent nil) (n-catch-blocks 0) (n-bindings 0))))

(defmethod (note-unknown-group control-stack-state)
	   ()
  (unless unknown-group-incremented
    (increment-group-count self 1)
    (setq unknown-group-incremented t)))

(defmethod (note-catch-block control-stack-state)
	   ()
  (incf n-catch-blocks)
  (mapc #'(lambda (child) (note-catch-block child)) children))

(defmethod (note-binding control-stack-state)
	   ()
  (incf n-bindings)
  (mapc #'(lambda (child) (note-binding child)) children))

(defmethod (increment-group-count control-stack-state)
	   (amount)
  (incf unknown-group-count amount)
  (mapc #'(lambda (child)
	    (increment-group-count child amount))
	children))

(defmethod (split-off-from-parent control-stack-state)
	   (&optional new-parent)
  (setf (control-stack-state-children parent)
	(cl:delete self (control-stack-state-children parent)))
  (setq parent new-parent)
  (when new-parent
    (push self (control-stack-state-children new-parent)))
  (increment-group-count
    self
    (+ (if new-parent (control-stack-state-unknown-group-count new-parent) 0)
       (- unknown-group-count)
       (if unknown-group-incremented 1 0))))

(defmethod (new-control-stack-state control-stack-state)
	   ()
  (let ((new-state (make-control-stack-state unknown-group-count self n-catch-blocks n-bindings)))
    (push new-state children)
    new-state))

(compile-flavor-methods control-stack-state)

(defun push-control-stack-state ()
  (setq *control-stack-state* (new-control-stack-state *control-stack-state*)))

(defun pop-control-stack-state ()
  (setq *control-stack-state* (control-stack-state-parent *control-stack-state*)))

(defmacro with-new-control-stack-state (&body body)
  `(let* ((.old-state. *control-stack-state*))
     (unwind-protect
	 (progn (push-control-stack-state)
		,@body)
       (unless (eq *control-stack-state* .old-state.)
	 (loop until (eq (pop-control-stack-state) .old-state.))))))

;;; >>> This one might be needed earlier. <<<
;;; If a Lisp function is implemented in microcode, then it should have
;;; a "built-in" property whose value is a list.  Each element is a
;;; "built-in" structure.  This structure represents an opcode that
;;; implements a certain Lisp function when that function is called on a
;;; certain number of arguments.  If it is in no-operand format, the
;;; instruction expects to find all arguments on the stack; otherwise,
;;; the last argument comes from the operand and the others are on the
;;; stack.
;;;  built-in-opcode: The universal opcode for this instruction.
;;;  built-in-format: The name of the format of this instruction.
;;;  built-in-n-arguments: The number of arguments taken by this instruction.
;;;  built-in-n-values: The number of values left on the stack by this instruction.
;;;  built-in-operand: An immediate operand associated with the instruction for the
;;;    function that is built-in.
(defflavor built-in
	(built-in-opcode
	 built-in-format
	 built-in-n-arguments
	 built-in-n-values
	 built-in-operand)
	()
  (:constructor make-built-in)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables)

(compile-flavor-methods built-in)

;;;

(cl:defstruct (error-info :list (:conc-name nil) (:copier nil) (:predicate nil) (:inline nil))
  error-variable
  error-branch
  error-function
  error-info)

;;;

;;; These are for the save-level and restore-level instructions.
(defflavor level-saver
	(level-saver-level
	 level-saver-l-level)
	()
  (:constructor make-level-saver)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(compile-flavor-methods level-saver)



;;;; Pframes

;;; Pframes are for figuring out how to do unwinding when compiling
;;; non-local GOs and RETURNs.  There is one pframe for everything
;;; that might be the destination level of a GO or RETURN (namely,
;;; PROGs and things that turn into them), and there is one for every
;;; form that does run-time establishment of the binding stack level
;;; (such as PROGV) or that sets up a catch block (such as *CATCH
;;; and UNWIND-PROTECT).

;;;  pframe-parent is another pframe, being the parent, or NIL for
;;;     a top level function's frame.
;;;  pframe-type says what kind of pframe this is.  It is a symbol
;;;     such as PROG, LET, FUNCTION, etc.
;;;  pframe-uid is a unique fixnum FOR DEBUGGING ONLY.
;;;  pframe-unwind-p is T is there is an UNWIND instruction that unwinds this frame.
;;;  pframe-control-stack-state is the control-stack-state when the pframe is
;;;     created, so that unwinding can set it properly.
(defflavor pframe
	((pframe-parent *pframe*)
	 (pframe-uid (setq *pframe-uid* (1+ *pframe-uid*)))
	 (pframe-unwind-p nil)
	 (pframe-control-stack-state)
	 )
	()
  :abstract-flavor
  (:conc-name "")
  :initable-instance-variables
  :locatable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

;;; This macro defines types of pframes.
(defvariant defpframe pframe pframe-type "-PFRAME")

;;; These frames are created for forms that make Dynamic use of the Binding
;;; Stack.  They mainly just store the stack level at the time of the
;;; start-dbs so that the end-dbs can find it, in phase 2.
;;;  dbs-b-level: The binding stack level when the variable is pushed.
;;;  dbs-destination: The destination of %with-binding-stack-level.
;;;  dbs-var-level: The control stack level of the "variable" created by the
;;;       start-dbs instruction, so that unwind instructions can find it.  This
;;;       is the value of *level* just BEFORE the "variable" is pushed.
;;;  dbs-bind-p: T if a bind instruction was done within this frame.
;;;  dbs-specials-bound: list of special variable bound between here and the innermost
;;;			 %WITH-BINDING-STACK-LEVEL.
;;;  dbs-l-level: The local-block size.
(defpframe dbs ("(DBS PFrame)")
  dbs-b-level
  dbs-destination
  dbs-var-level
  dbs-bind-p
  dbs-specials-bound
  dbs-save-binding-stack
  dbs-l-level
  )

;;; These pframes are created for catch and unwind-protect.
;;;  catch-level: The control stack level before the catch block is pushed.
;;;  catch-l-level: The local-block level before the catch block is pushed
;;;  catch-b-level: The binding stack level before the catch block is pushed.
;;;  catch-internal-tag: This is not the catch tag!  It is a tag (see below) emitted
;;;       at the end of the catch form; this is where a throw will go to.  It is NIL
;;;       if the destination of the catch is return.
;;;  catch-prog-pframe: PROG pframe associated with this CATCH - used in case of
;;;       non-local GO or RETURN to PROG by Phase-2 to find TAG associated with PROG
;;; >>> Maybe this next one should be a DEFVARIANT??? <<<
;;;  catch-or-unwind: differentiates between CATCH and UNWIND-PROTECT
(defpframe catch ("(Catch PFrame)")
  catch-level
  catch-b-level
  catch-internal-tag
  catch-prog-pframe
  catch-or-unwind
  catch-l-level
  )

;;; These pframes are created when multiple groups are left on the stack.
;;; They exist mainly when we are compiling the rest of the forms of a prog1.
;;;  multiple-level: The control stack level just after the multiple value group is pushed.
;;;  multiple-l-level: The local-block level before the multiple value group is pushed.
;;;  multiple-b-level: The binding-stack level before the multiple value group is pushed.
(defpframe multiple ("(Multiple PFrame)")
  multiple-level
  multiple-l-level
  multiple-b-level)

(defpframe saved-multiple ("(Saved Multiple PFrame)")
  saved-multiple-variable
  saved-multiple-offset
  saved-multiple-level
  saved-multiple-l-level
  saved-multiple-b-level)

;;; These pframes are created for PROG, PROG*, DO, DO-NAMED, LOOP, BLOCK, etc.

;;;  nlg-function: The function containing this prog.
;;;  nlg-nested-unwind-protects: For detecting non-local transfers of control.
;;;  nlg-level: Stack level of this prog.  If there is a catch, this is the level 
;;;      inside the catch.
;;;  nlg-b-level: binding-stack level of this prog.
;;;  nlg-non-local-reference-p:  T if a non-local GO or RETURN has been seen.
;;;  nlg-looping: Is the form within a loop?
;;;  nlg-catch-var: The lexical variable itself.
;;;  nlg-level: local-block level of this prog
(defflavor nlg-pframe
	((nlg-function *function*)
	 (nlg-nested-unwind-protects *nested-unwind-protects*)
	 nlg-level
	 nlg-b-level
	 (nlg-non-local-reference-p nil)
	 (nlg-looping *looping*)
	 (nlg-catch-var nil)
	 nlg-l-level
	 )
	(catch-pframe)
  :abstract-flavor
  (:conc-name "")
  :initable-instance-variables
  :locatable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defvariant defnlgpframe nlg-pframe pframe-type "-PFRAME")

;;;  block-destination: The destination to which the BLOCK is being compiled.
;;;  block-name: The name of the block, used as an argument for %return-from-lambda,
;;;      which is what non-local RETURN turns into.
(defnlgpframe block ("(BLOCK PFrame)")
  block-destination
  block-name
  block-dest-type				;unused
  block-local-return-tag
  )

(defnlgpframe tagbody ("(TAGBODY PFrame)")
  )

;;; This pframe is used to determine what we must do to unwind the stack when aborting
;;; out of a non-local transfer of control.
;;;  nlg-transfer-non-local: True if this transfer turned out to be non-local.
;;;  nlg-transfer-target: the pframe which is the target of the transfer.
;;;  nlg-transfer-start-call: The start-call instruction used for this (non-local) transfer.
(defpframe nlg-transfer ("(NLG Transfer)")
  nlg-transfer-non-local
  nlg-transfer-target
  nlg-transfer-start-call)

;;; These pframes are created for calls which need special unwinding procedures
;;; open-call-start-call: the start-call byte-lap instruction for this call
(defpframe open-call ("(Open Call PFrame)")
  open-call-start-call)

(defun pframe-pr (pframe)
  (format nil "Pframe-~D" (pframe-uid pframe)))

(compile-flavor-methods dbs-pframe catch-pframe multiple-pframe saved-multiple-pframe
			block-pframe tagbody-pframe nlg-transfer-pframe open-call-pframe)



;;;; Variables and functions.

;;; This structure is created for each distinct Lisp variable.  Note that
;;; a lambda-bind (as in a LET clause) may be either a NAME or a BIND; a
;;; NAME operation creates a new variable but a BIND does not.
;;;  variable-name: The name of the variable; a symbol.
;;;  variable-type: One of the symbols lexical, special, or instance.
;;;  variable-usage-count: The number of references (symevals or sets) to this variable.
;;;       This is used to figure out whether an unused variable warning should be given.
;;;  variable-ignored-p: T => this variable is named "ignore" or otherwise declared
;;;       to be ignored.  Give an error message if it is used.
(defflavor variable
	(variable-name
	 (variable-usage-count 0)
	 (variable-ignored-p nil)
	 )
	()
  :abstract-flavor
  (:conc-name "")
  :initable-instance-variables
  :locatable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defvariant defvartype variable variable-type "-VARIABLE")


;;; Lexical variables.
;;; Several of these slots are mainly used to figure out whether the variable
;;; will be stack-resident or not.  See variable-stack-resident-p in phase-2.
;;;  lexical-lframe: The lframe that binds this variable; an lframe.
;;;  lexical-uid: For debugging ONLY.  Just to generate printouts.
;;;  lexical-stack-resident-p: T for stack-resident variables.  Filled in by phase 2.
;;;  lexical-location: The location of this variable, expressed as the offset between
;;;       the FP of the non-quick function that owns this variable, and its location.
;;;       Note that lexical-location is expressed this way for both local- and stack-
;;;       resident variables!  Also note that the FP points to just before argument 0.
;;;       For stack-resident variables pushed inside quick internal functions, we don't
;;;       actually know the FP offset because we don't know how much junk is pushed between
;;;       the frame header and us; this number is as if there were zero junk.
;;;  lexical-variable-location-p: T means that variable-location gets done on this var.
;;;  lexical-function: The function that contains that frame; a function.
;;;  lexical-referencing-functions: A list of functions that refer
;;;       to this variable.  If any of these turn out to be non-quick then
;;;       this variable might have to be treated differently.
;;;  lexical-bound-in-loop-p: The variable is bound inside a loop and may have to be
;;;	  a nested captive.  The magic here is that the lexical-location will be used
;;;	  as a pointer to a cons whose cdr will be
;;;       the value cell and whose car points to the previous captive structure (another cons
;;;       or the frame's captive block) is the previous captive block.
;;;  lexical-multiple-count: The value of *multiple-count* when this var is created; this
;;;       is used to figure out the multiple-mismatch-p, and if it is positive it means
;;;       that there are multiple groups between the base of the stack and the variable,
;;;       so it cannot be referenced relative to the base of the stack frame.
;;;  lexical-multiple-mismatch-p: T => this variable was referenced while *multiple-count*
;;;       had a different value than lexical-multiple-count; there are multiple groups
;;;       between the variable and some reference to it, so the variable cannot be
;;;       referenced relative to the top of the stack.
;;;  lexical-argument-p: T => this is an argument to a function, as opposed to being
;;;       a PROG, LET, internal-LAMBDA, etc variable.  This is true of lexical supplied-p
;;;       variables as well!
;;;  lexical-gensym-p: T => this variable wasn't really named by the user's code but rather
;;;	  by some macro.
;;;  lexical-size: Number of slots used by this variable on the stack
;;;  lexical-class: NORMAL, ARRAY-REGISTER
;;;  lexical-captive-p: T means that the variable is referenced by internal functions
;;;       of lexical-function.
;;;  lexical-captive-location: offset in the captive block for this variable's value cell.
;;;  lexical-source-locator: where the definition of this variable occurs.
;;;  lexical-function-cell-p: for FLETted and LABELled functions, Phase-1 generates a
;;;       local variable to contain the function cell; when it does this, this slot
;;;	  contains the name of the internal function, otherwise it contains a NIL
;;;  lexical-rest-arg-p: T ==> variable is an &REST arg.
;;;  lexical-original-variable: If this variable gets moved because a closure refers
;;;       to LP and FP variables, this is the original variable
;;;  lexical-local-block-offset: The offset of the lexical block when this variable
;;;       comes into existence.
;;;  lexical-control-stack-state: The control stack state where the variable was
;;;       created/located.
;;;  lexical-referencing-control-stack-states: The control stack state in references
;;;       to this variable.
;;;  lexical-modified-p: The variable is located or set.
;;;  lexical-superseding-variable: The variable has been superseded by another.
;;;  lexical-mapping-table-info: Mapping table information for this variable.
;;;  lexical-free-p: If T, this variable was a special argument initialization and is
;;;       available for reuse at allocate-local-block time.
;;;  lexical-kludge-p: If T, this is a kludge variable generated by the compiler.
;;;  lexical-variable-inlinable-p: If T, this variable can be inlined
;;;  lexical-mapped-access-p:  If T, this variable uses a mapping table
;;;  lexical-dynamic-extent:  If T, variable has dynamic extent.
(defvartype lexical ("(Lexical Variable)")
  lexical-uid
  lexical-stack-resident-p
  lexical-location
  (lexical-variable-location-p nil)
  (lexical-function *function*)
  (lexical-referencing-functions nil)
  (lexical-bound-in-loop-p nil)
  (lexical-multiple-count *multiple-count*)
  (lexical-multiple-mismatch-p nil)
  lexical-argument-p
  lexical-gensym-p
  (lexical-size 1)
  (lexical-offset 0)
  lexical-class
  lexical-captive-p
  lexical-captive-location
  lexical-source-locator
  lexical-function-cell-p
  (lexical-rest-arg-p nil)
  (lexical-original-variable)
  (lexical-supplied-p nil)
  (lexical-local-block-offset nil)
  (lexical-control-stack-state *control-stack-state*)
  (lexical-referencing-control-stack-states nil)
  (lexical-modified-p nil)
  (lexical-superseding-variable nil)
  (lexical-mapping-table-info nil)
  (lexical-free-p nil)
  (lexical-kludge-p nil)
  (lexical-variable-inlinable nil)
  (lexical-mapped-access-p nil)
  (lexical-dynamic-extent nil)
  )

(defflavor mapped-access-information
	(self-variable
	 self-mapping-table-variable
	 family
	 variables
	 class-index)
	()
  (:readable-instance-variables)
  (:initable-instance-variables))

(defvartype-method (lexical-nested-captive-p lexical) ()
  (and lexical-captive-p lexical-bound-in-loop-p))

(defvariant deflexclass lexical-variable lexical-class "-LEXICAL-VARIABLE")

(deflexclass normal ("(Normal Lexical Variable ~A)" (variable-pr self))
  )

;;;  array-register-type: Normal => use normal setup, ie barf if two dimensional etc.
;;;       FORCE-1D => Force array to be 1 dimensional
;;;  array-register-offset:  NIL => Entire array, number => offset into array
;;;  array-register-length:  NIL => End of array, number => maximum offset into array
;;;  array-register-warn:  Print warning if we can't use an array register.
(deflexclass array-register ("(Array Register Lexical Variable)")
  (array-register-type 'normal)
  (array-register-offset nil)
  (array-register-length nil)
  (array-register-warn t))

;;; function-cell-function: The compiler's function structure that corresponds to
;;;       this variable.
(deflexclass function-cell ("(Function Cell Lexical Variable)")
  (function-cell-function nil))

;;; Logic variable support.
(deflexclass logic ("(Logic Lexical Variable)")
  )

;;; Special variables.
(defvartype special ("(Special Variable)")
  )

;;; Instance variables.
(defvartype instance ("(Instance Variable)")
  )

(defun variable-pr (variable)
  (selectq (variable-type variable)
    (lexical
     (let ((name (selectq (lexical-class variable)
		   ((array-register array-register-1d)
		    (format nil "~A(Ar)" (variable-name variable)))
		   (logic (format nil "~A(Logic)" (variable-name variable)))
		   (otherwise (variable-name variable))))
	   (loc (lexical-location variable)))
       (if (null loc)
	   (format nil "~A-~D"
		   name
		   (lexical-uid variable))
	   (format nil "~A ~C.~D"
		   name
		   (if (lexical-stack-resident-p variable) #/s #/l)
		   loc))))
    (otherwise
     (format nil "~S" (variable-name variable)))))

(compile-flavor-methods normal-lexical-variable array-register-lexical-variable
			function-cell-lexical-variable logic-lexical-variable
			special-variable instance-variable
			)



;;; A variant of this structure is created for each function either referenced or defined
;;; by the code being compiled.
;;; function-type is one of:
;;;	external -- a function callable from the outside world, being defined
;;;	internal -- a function nested inside another function, being defined
;;;	internal-macro -- a local macro, being defined
;;;	reference -- a reference to a function not defined here
;;; function-spec: Where to find the function (not meaningful for internal variant,
;;;		but present in the base structure so it's in the same place in all
;;;		variants)

(defflavor function-reference
	((function-spec nil))
	()
  (:conc-name "")
  (:constructor make-function-reference)
  :locatable-instance-variables
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defmethod (function-type function-reference) () 'reference)

;;; For each Lisp function called by the compiled code, we just generate an
;;; instance of the basic structure.

;;; This structure is created for each Lisp function defined by the
;;; compiled code.
;;;  function-args-info: The args-info fixnum for this function.
;;;  function-lambda-list: The lambda-list, for &QUOTE (!).
;;;  function-interval: An interval containing the code of the body of the function.
;;;  function-documentation: String found in documentation position in function
;;;       body.

;;;  function-user-declares: Elements of the local declarations that should be sent over
;;;	  into the debug info.
;;;  function-lexical-variables: All lexical variables created while this function
;;;       was the function being compiled.
;;;  function-frame-owner: The function that owns the stack frame of this function.
;;;       For everything other than quick internals, this will be the function itself.
;;;  function-frame-sharers: A list of all functions other than this one that
;;;       share the frame of this one; that is, this function's quick internal functions.
;;;  function-argument-block-size: The number of slots holding argument variables
;;;       or ivars in the stack frame.  Only meaningful for non-quick functions.
;;;  function-local-block-size: The number of slots in the local block.  Filled in
;;;       by phase 2.  Only meaningful for non-quick-internal functions.
;;;  function-cca: The cca for this function, if this is a function being defined.
;;;  function-references: This is used during phase 4.  See (fun assemble) and
;;;       fixup-function-references.  Each element is a two list of a function
;;;       object and the offset in the object area of the compiled code object
;;;       for that function.  Therein lies an unresolved reference to this function's
;;;       compiled code object.
;;;  function-has-captive-lexicals-p: Flag used in phase 2 to indicate that some of
;;;       the functions lexicals need to reside in a captive block.
;;;  function-captive-block-size: The number of slots in the captive block.  Filled in
;;;       by phase 2.  Only meaningful for functions which have internal functions.
;;;  function-has-lp-lexicals: The function has lexical variables which must be
;;;       referenced relative to LP.
;;;  function-control-stack-state: The control stack state when the function is
;;;       entered.
;;;  function-has-mapped-slot-access: The function has a WITH-MAPPED-SLOT-ACCESS form
;;;       in it.
(defflavor function-definition
	(function-args-info
	 function-lambda-list
	 function-interval
	 (function-documentation-string nil)
	 (function-user-declares nil)		;really this is debugging-info
	 (function-lexical-variables nil)
	 function-frame-owner
	 (function-frame-sharers nil)
	 function-argument-block-size
	 function-local-block-size
	 function-cca
	 (function-references nil)
	 (function-pc-references nil)
	 (function-ordered-local-variables nil)
	 (function-has-captive-lexicals-p nil)
	 function-captive-block-size
	 function-has-lp-lexicals
	 function-control-stack-state
	 (function-has-mapped-slot-access *optimize-slot-value*)
	 )
	(function-reference)
  (:conc-name "")
  :initable-instance-variables
  :locatable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defvariant deffuntype function-definition function-type "-FUNCTION")

;;; An external function (turns into its own compiled-function object)
(deffuntype external ("(External Function)")
  function-internal-function-offsets
  )

;;; Internal functions can be created with LAMBDA, FLET, or LABELS;
;;; there is one of these for each function in a single FLET/LABELS form.
;;;  function-label: The name, a symbol.  NIL if anonymous.
;;;  function-uid: To make printed representation prettier; for debugging ONLY.
;;;  function-parent-function: The containing function.
;;;  function-refers-lexically-p: T means that this function uses some
;;;       variable that is named in a containing function.  This is stored
;;;       so that if it is NIL, later phases know that no lexical closure needs
;;;       to be consed.
;;;  function-funarg-p: T means that the function gets passed as a funarg
;;;       at some point.  Phase 2 uses this to decide that it cannot be quick.
;;;  function-quick-p: T means that the function should be quick; NIL that it should
;;;       not; :undecided that we don't know yet.  During *phase-1-again*, this will
;;;       be T or NIL.  It might be T during the first phase 1, though; this happens
;;;       for the functions generated by unwind-protect, which must be quick.
;;;  function-quick-destination: Only meaningful if quick-p is T.  The destination
;;;       to which the body of the function is compiled.  This is computed by
;;;       build-quick-destination and used by reconcile-destinations.
;;;  function-quick-tag: A tag emitted at the first instruction of this quick
;;;       internal function, to resolve call instructions.
;;;  function-mapping-table-p: T means this function accesses instance variables, so
;;;	  it must fetch self and self-mapping-table from its lexical environment.
;;;  function-free-lexical-variables: A list of all the free lexical variables referenced
;;;       by this function.
;;;  function-use-stack-closure-p: T if the function should be implemented as a lexical
;;;       closure that should be consed on the stack.
;;;  function-lexical-functions-called: a list of the lexical functions called by this
;;;       function.
;;;  function-lexical-contour: The lexical contour for this function.
;;;  function-used: T if the function has been used other than through its cell.
;;;  function-cell-var: Variable used for the function cell, if any.
;;;  function-inline-form-method: 
(deffuntype internal ("(Internal Function)")
  function-label
  (function-uid (prog1 *internal-function-uid* (incf *internal-function-uid*)))
  (function-parent-function *function*)
  (function-refers-lexically-p nil)
  (function-funarg-p nil)
  (function-quick-p ':undecided)
  function-quick-destination
  function-quick-tag
  (function-mapping-table-p nil)
  function-free-lexical-variables
  (function-use-stack-closure-p nil)
  (function-n-nested-frees nil)
  (function-lexical-functions-called nil)
  (function-lexical-contour nil)
  (function-used nil)
  function-cell-var
  (function-inline-form-method nil))

(defmethod (external-ancestor-function-spec function-reference) ()
  function-spec)

(defmethod (external-ancestor-function-spec internal-function) ()
  (external-ancestor-function-spec function-parent-function))

(defflavor interpreter-function
	((interpreter-function-location))
	(function-reference)
  (:conc-name "")
  (:constructor make-interpreter-function)
  :locatable-instance-variables
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defmethod (function-type interpreter-function) () 'interpreter)

(defmethod (function-args-info interpreter-function) ()
  (args-info (location-contents interpreter-function-location)))

(defmethod (function-lambda-list interpreter-function) ()
  (arglist (location-contents interpreter-function-location)))

(compile-flavor-methods function-reference
			external-function internal-function interpreter-function)

(defun function-pr (function)
  (selectq (function-type function)
    (internal
     (let ((parent (function-pr (function-parent-function function)))
	   (name (function-label function)))
       (if parent
	   `(:internal ,parent ,(function-uid function) ,@(and name `(,name)))
	   name)))
    (otherwise
     (function-spec function))))



;;;; Arguments

;;; This structure is only used in a limited area of phase-1.  It is the
;;; result of the first pass made over the argument list of any defined
;;; function, and it is given to the second pass to generate the argument
;;; aceeptance code.
;;;  argument-var: The variable naming this argument.
;;;  argument-usage-count: Usage count of argument-var before any init forms compiled.
;;;  argument-ivar: Internal lexical variable if argument-var is special, else nil.
;;;  argument-supplied-p-var: The variable saying whether the argument was passed.
;;;       NIL if there isn't any.
;;;  argument-supplied-p-var-usage-count: supplied-p-var's usage count before init forms.
;;;  argument-requiredness: required, optional, or rest.
;;;  argument-init-interval: If argument is optional, this is an interval containing
;;;       code that will push the right value onto the stack.
(defflavor argument
	(argument-var
	 argument-usage-count
	 (argument-ivar nil)
	 (argument-supplied-p-var nil)
	 argument-supplied-p-var-usage-count
	 argument-requiredness
	 argument-init-interval)
	()
  (:constructor make-argument)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

;;; This structure works like the argument structure, except that it is a list of aux
;;; variable bindings to be done after argument acceptance is finished.
;;;  aux-name: Name of the &aux variable.
;;;  aux-form: The form, to the value of which the &aux variable should be initialized.
;;;  aux-declaration: The declaration of the &aux variable in its lexical context.
;;;  aux-class: The class of the &aux variable (similar to its declaration)
;;;  aux-lisp-locator: The source of the variable itself
;;;  aux-value-lisp-locator: The source of the initialization value form.
(defflavor aux
	(aux-name
	 aux-form
	 aux-declaration
	 (aux-class 'normal)
	 aux-lisp-locator
	 aux-init-lisp-locator
	 )
	()
  (:constructor make-aux)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

;;; Similar structure for &KEY arguments.
(defflavor keyed
	(keyed-name
	 keyed-form
	 keyed-declaration
	 keyed-keyword
	 keyed-supplied-p-variable
	 keyed-supplied-p-declaration
	 keyed-lisp-locator
	 keyed-init-lisp-locator
	 keyed-supplied-p-loc
	 )
	()
  (:constructor make-keyed)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(compile-flavor-methods argument aux keyed)



(defvar *optimize-form-cache*)
(defvar *use-optimize-form-cache* nil)

(defun make-optimize-form-cache ()
  (cl:make-hash-table :test #'eq :locking nil :number-of-values 0))

(defun with-optimize-form-cache-internal (continuation)
  (declare (downward-funarg continuation))
  (let ((*optimize-form-cache* (cl:make-hash-table :test #'eq :locking nil :number-of-values 0)))
    (let ((*use-optimize-form-cache* t))
      (funcall continuation))))

(defmacro with-optimize-form-cache (&body body)
  `(with-optimize-form-cache-internal
     (named-lambda with-optimize-form-cache ()
       ,@body)))



(defgeneric destination-for-return (destination))
;;;    T - after evaluating this, return
;;;    NIL - don't return

(defgeneric destination-n-values (destination))
;;; number of values wanted by the destination (or NIL for "all values")
;;; (actually the maximum value wanted, since some may be ignored)
;;;    0 - "ignore"
;;;    1 - "stack" or "stack-predicate"
;;;    <integer> - known number (old list form)
;;;    NIL - unknown (multiple group); "multiple"

(defgeneric destination-usage (destination n))
;;; the way each value is used
;;;    NIL - not used
;;;    T - value is used
;;;    BOOLEAN - if value is NIL, NIL must be returned; otherwise any non-NIL value will do

(defgeneric destination-type (destination n))
;;;    <CL type> type of object required by destination

;;;

(defflavor general-destination
	((for-return nil)
	 n-values
	 (usage '())
	 (default-usage t)
	 (type '())
	 (default-type t)
	 (extent '())
	 (default-extent nil)
	 )
	()
  (:conc-name "DESTINATION-")
  (:constructor values-destination (n-values))
  (:constructor make-destination
   (&key n-values for-return (usage nil) (default-usage t) (type nil) (default-type t)
	 (extent nil) (default-extent t)))
  (:readable-instance-variables for-return n-values))

(defmethod (sys:print-self general-destination) (stream depth slashify-p)
  depth
  (if slashify-p
      (si:printing-random-object (self stream :no-pointer :typep)
	(princ self stream))
      (format stream "~D values~@[ ~A~]"
	      (or n-values "multiple") (and for-return "and return"))))

(defmethod (destination-usage general-destination) (n)
  (and (or (null n-values) (< n n-values))
       (values (if (< n (length usage))
		   (cl:elt usage n)
		   default-usage)
	       (if (< n (length extent))
		   (cl:elt extent n)
		   default-extent))))

;;;
;;; Similar to DESTINATION-USAGE, but returns T if anything in the usage
;;; for this destination *after* N is used.  This is so that when
;;; comiling things that are returning values into a m-v-b, we don't get
;;; confused and decide not to return something into an unused var, thus
;;; screwing up the stack.  Currently, the only user of this is the
;;; %error-unless expander.
;;;
(defmethod (destination-needed general-destination) (n)
  (or (destination-usage self n)		; takes care of n > length case
      (and (loop for i from (1+ n) below (length usage)
		 thereis (cl:elt usage i))
	   t)))

(defmethod (destination-type general-destination) (n)
  (if (< n (length type))
      (cl:elt type n)
      default-type))

(defmethod (remake-destination general-destination) (&rest keys)
  (apply #'make-destination
	 (append keys `(:n-values ,n-values :for-return ,for-return
				  :usage ,usage :default-usage ,default-usage
				  :type ,type :default-type ,default-type
				  :extent ,extent :default-extent ,default-extent))))

(compile-flavor-methods general-destination)

;;;

(defvar *destination-ignore* (values-destination 0))
(defvar *destination-stack* (values-destination 1))
(defvar *destination-stack-double* (values-destination 2))
(defvar *destination-multiple* (values-destination nil))
(defvar *destination-stack-predicate* (make-destination :n-values 1 :usage '(boolean)))
(defvar *destination-stack-fixnum* (make-destination :n-values 1 :type '(cl:fixnum)))
(defvar *destination-return* (make-destination :n-values nil :for-return t))
(defvar *destination-return-dont-care* (make-destination :n-values 0 :for-return t))

;;; Some back end stuff that's needed for both architectures

;;; The list *all-branches* is a list of branch structures, one for each instruction
;;; that references a tag.  Usually such instructions are branch instructions,
;;; but any instruction that may grow because a tag is out of reach will have
;;; one of these to represent it.  The corresponding list *all-tags* contains
;;; all of the tags, so that they can be displaced too.  It is assumed that
;;; all branches have one short form and one long form, and that zeroness of the
;;; branch-extra field tells you whether this branch has been converted to long
;;; form or not.  Currently, you can't have a "medium" form.
;;;  branch-type:  A symbol that names a Byte Lap opcode.  It may be any of the
;;;       jump opcodes, or quick-internal-call, catch, or unwind-protect; these
;;;       are defined by defbranch.
;;;  branch-tag: The tag structure for the destination of the jump.
;;;  branch-pre-address: The address of the jump instruction, as returned by assemble,
;;;       before any extra instructions are added.
;;;  branch-post-address: The address of the jump instruction, modified to take
;;;       into account extra instructions.  Initialized to the pre-address, and
;;;       modified by the addition of branch-extra's of preceeding branches.
;;;  branch-extra: The number of extra instructions inserted at this jump.  Starts at
;;;       zero and grows as branches are lengthened.
;;;  branch-instruction-array: The instruction array in which this branch was emitted, so
;;;       that the pre-address can be relocated after the arrays are merged into one.
;;;  branch-must-be-single-instruction: A long branch cannot be converted into two
;;;       instructions.  Used for entry instructions.
;;;  branch-assembled-long:  This is set to T by the back end of the I compiler
;;;	  if it had to be converted to a long branch.
;;;  branch-tos-state:  The state of TOS when the branch was assembled.
(defflavor branch
	(branch-type
	 branch-tag 
	 branch-pre-address
	 branch-post-address
	 branch-extra
	 branch-instruction-array
	 branch-must-be-single-instruction
	 (branch-assembled-long nil)
	 (branch-tos-state))
	()
  (:constructor make-branch)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(compile-flavor-methods branch)

;;; This structure remembers that a dispatch table has to be created.  See the
;;; comment of note-dispatch for more information.
;;;   dispatch-instruction-array: The instruction array containing the dispatch table.
;;;   dispatch-location: The location in the above array of the dispatch table.
;;;   dispatch-fall-through-p: Whether the entries drop through into following entries.
;;;   dispatch-entry-size: The number of instructions per entry in the table itself.
;;;   dispatch-interval-list: A list of intervals, one for each entry.
(defflavor dispatch
	(dispatch-location
	 dispatch-instruction-array
	 dispatch-fall-through-p 
	 dispatch-entry-size 
	 dispatch-interval-list
	 dispatch-source-locator-array)
	()
  (:constructor make-dispatch)
  (:conc-name "")
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(compile-flavor-methods dispatch)

(defnlgpframe new-block-read-test ("(BLOCK-READ-TEST PFrame)")
  block-read-test-pframe-level
  block-read-test-pframe-tag
  )

(compile-flavor-methods new-block-read-test-pframe)
