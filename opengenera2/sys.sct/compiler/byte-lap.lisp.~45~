;;; -*- Mode: Lisp; Package: COMPILER; Lowercase: T; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Byte-lap instructions and intervals.

;;; Operations on instructions.

(defgeneric tagp (inst)
  "T if this instruction is a tag.")

(defgeneric executablep (inst)
  "T is this instruction is executable")

;;; this is used by phase-3 to copy code
;;; the only methods which need to be defined are those for which code-may-be-copied is true
(defgeneric copy-inst (inst))


;;; This is the base structure included by all of the various
;;; structures for the various byte-lap opcodes.
;;;  inst-opcode is a symbol saying which kind of instruction this is.
;;;  inst-source-locator is the source location token which tells what piece of
;;;     source this instruction came from.
;;;  inst-next is the next byte-lap-instruction in the code, or nil if
;;;     this is the last one.
;;;  inst-prev is the previous byte-lap-instruction in the code, or nil
;;;     if this is the first one.
;;;  inst-level is the level in phase-2 for this instruction
;;;  inst-pre-control-stack-state is the value of *control-stack-state* before the
;;;     instruction is executed.
;;;  inst-post-control-stack-state is the value of *control-stack-state* after the
;;;     instruction is executed.
(defflavor byte-lap-instruction
	((inst-source-locator *source-locator*)
	 (inst-next nil)
	 (inst-prev nil)
	 (inst-level nil)
	 (inst-pre-control-stack-state nil)
	 (inst-post-control-stack-state nil))
	()
  :abstract-flavor
  (:conc-name "")
  :readable-instance-variables
  :writable-instance-variables
  :initable-instance-variables)

;;; Default methods.

(defmethod (tagp byte-lap-instruction :default) () nil)
(defmethod (executablep byte-lap-instruction :default) () t)

(defmethod (change-variable byte-lap-instruction :default) (substitutions)
  (declare (ignore substitutions)))

;;; This macro defines Byte-Lap instructions.
(defvariant definst byte-lap-instruction inst-opcode "-INSTRUCTION")



;;; The no-op instruction is mainly used for boundary conditions
;;; for the doubly-linked list.  It should never appear in the
;;; code except at the ends of lists, and it is a no-op.
(definst no-op ("(No op)")
  )

;;; The var instruction pushes the value of a variable.
;;;  var-variable: the "variable" structure for this variable.
;;;  var-level: The level of the stack before this instruction; set by phase 2 and
;;;       used by phase 4 to figure out how to address lexical variables.
;;;  var-nested-captive-environment: T to access the environment instead of the value.
(definst var ("(Var ~A)" (variable-pr var-variable))
  var-variable
  var-level
  (var-nested-captive-environment nil))

(definst-method (change-variable var) (substitutions)
  (let ((new (cl:getf substitutions var-variable)))
    (when new (setf var-variable new))))

;;; The fun instruction pushes a function on the stack.  If it is an external
;;; function, this will turn into an instruction that refers to the function
;;; cell of some function spec, analogously to what var does when the variable
;;; is a special variable.  Note that it can be any function spec, not just a symbol.
;;; If it is an internal function, the function must not
;;; be quick, and it turns into an instruction that loads a constant from the
;;; compiled code object just as the general-case const instruction does.
;;;  fun-function: the "function" structure for this function.
;;;  fun-level: The level of the stack before this instruction.
(definst fun ("(Fun ~A)" (function-pr fun-function))
  fun-function
  fun-level)

;;; The const instruction pushes a constant value.
;;;  const-value: The constant value itself.
;;;  const-sharable: A key which controls when constants can be collapsed.
;;;  const-read-only: T is constant can safely be made read-only.
(definst const ("(Const ~S)" const-value)
  const-value
  (const-sharable t)
  (const-read-only t))

;;; The pop instruction pops several objects off the stack, saving some objects
;;; on top of them.  In other words, when it is done, the top pop-save-n objects
;;; are still on top of the stack but the pop-n beneath them are gone.
;;;  pop-n: A fixnum, the number of pops to do, or the symbol "multiple",
;;;    meaning tht there is a multiple value group to be popped.
;;;  pop-save-n: A fixnum, the number of objects to save above the popped objects,
;;;    or the symbol "multiple", meaning that there is a multiple value group on
;;;    top of the objects to be popped, and it should be saved.
(definst pop  ("(Pop~:[~*~; ~D~]~:[~*~; saving ~D~])"
	       (not (eql pop-n 1)) pop-n
	       (not (eql pop-save-n 0)) pop-save-n)
  pop-n
  pop-save-n)

;;; The computed-pop instruction is like pop, but adds the values of some variables
;;; to the amount to pop.
;;; ---- Currently, this is a kludge just to support unwinding "saved-multiple" groups
;;; ---- so it knows that all variables will be lexicals in the local block.
;;; ---- This could be extended, if necessary.  Then this could be combined with POP.
(definst computed-pop ("(Pop ~A~{+~A~}~:[~*~;+~D~]~:[~*~; saving ~D~])"
		       (variable-pr (first computed-pop-variables))
		       (mapcar #'variable-pr (cdr computed-pop-variables))
		       (not (eql computed-pop-n 0)) computed-pop-n
		       (not (eql computed-pop-save-n 0)) computed-pop-save-n)
  computed-pop-variables
  computed-pop-n
  computed-pop-save-n)

;;; The setq instruction sets a variable to the value in the top of the
;;; stack.  It doesn't pop that value.
;;;  setq-variable: the "variable" structure for this variable.
;;;  setq-level: The level of the stack before this instruction; set by phase 2 and
;;;       used by phase 4 to figure out how to address lexical variables.
;;;  setq-nested-captive-environment: T to access the environment instead of the value.
(definst setq ("(Setq ~A)" (variable-pr setq-variable))
  setq-variable
  setq-level
  (setq-nested-captive-environment nil))

(definst-method (change-variable setq) (substitutions)
  (let ((new (cl:getf substitutions setq-variable)))
    (when new (setf setq-variable new))))

;;; Ensures that SELF and SELF-MAPPING-TABLE are set up appropriately.
(definst ensure-mapping-information ("(Ensure mapping information)")
  ensure-mapping-information-mapping-table
  ensure-mapping-information-segment
  ensure-mapping-information-self
  ensure-mapping-information-previous-mapping-tables
  ensure-mapping-information-previous-selfs)

(definst-method (change-variable ensure-mapping-information) (substitutions)
  (flet ((change-one (place)
	   (let ((new (cl:getf substitutions (location-contents place))))
	     (when new (setf (location-contents place) new)))))
    (change-one (locf ensure-mapping-information-mapping-table))
    (change-one (locf ensure-mapping-information-self))
    (cl:mapl #'(lambda (place) (change-one (locf (car place))))
	     ensure-mapping-information-previous-mapping-tables)
    (cl:mapl #'(lambda (place) (change-one (locf (car place))))
	     ensure-mapping-information-previous-selfs)))

;;; The capture-argument instruction is used to move an argument which is lexically
;;; captive from the argument block to the captive block.  Phase 2 generates these, and
;;; Phase 4 assembles them into the right thing.
;;;  capture-argument-variable: the "variable" structure for this argument.
(definst capture-argument ("(Capture Argument)")
  capture-argument-variable)

;;; The copy instruction pushes, onto the stack, the element at a certain
;;; numeric offset below the stack pointer.
;;;  copy-n: The depth below the top of the stack.  Zero would mean the top
;;;       of the stack.
;;;  copy-past-multiple: On top of the stack is a multiple group.  Skip over
;;;       first, then move copy-n words.  T or NIL.
(definst copy ("(Copy~@[ ~D~]~:[~; Past Multiple~])" (and (plusp copy-n) copy-n)
	       copy-past-multiple)
  copy-n
  copy-past-multiple)

;;; The start-call instruction indicates the start of a function call
;;;  start-call-function: A "function" structure for this function.
;;;  start-call-call: The call instruction which finishes this (any one if more than one)
;;;  start-call-level: The level -before- this start call, this also means the level
;;;    before the continuation was pushed in the funcall case.
;;;  start-call-l-level: The local-block level before this start call.
;;;  start-call-b-level: The binding-stack level before this start call.
(definst start-call ("(Start Call ~A)" (function-pr start-call-function))
  start-call-function
  start-call-call
  start-call-level
  start-call-l-level
  start-call-b-level)

;;; The call instruction calls a function with a given number of arguments.
;;; This is used for quick internal, quick external, and normal function calls
;;; alike; the assembler gets to figure out which real instruction to use.
;;;  call-function: A "function" structure for this function.
;;;  call-n-args: A fixnum, the number of arguments.
;;;  call-destination: A phase-1 destination code, the destination of the call.
;;;  call-inline-p: NIL normally, 'CL:INLINE if the call must be inline,
;;;    'CL:NOTINLINE if it must not be.
;;;  call-start-call: The list of start-call instructions that began this call - used
;;;    only for the i-machine.
;;;  call-builtin: Gets used by the back end.
(definst call ("(Call ~A ~S to ~A)" (function-pr call-function) call-n-args call-destination)
  call-function
  call-n-args
  call-destination
  call-inline-p
  (call-start-call nil)
  (call-builtin nil))

(definst-method (copy-inst call) ()
  (make-call-instruction
    :call-function call-function
    :call-n-args call-n-args
    :call-destination call-destination
    :call-inline-p call-inline-p
    :call-start-call call-start-call
    :call-builtin call-builtin
    :inst-source-locator inst-source-locator
    :inst-level inst-level
    :inst-pre-control-stack-state inst-pre-control-stack-state
    :inst-post-control-stack-state inst-post-control-stack-state))

;;; The jump instruction jumps to a tag, possibly depending on some condition,
;;; and possibly popping something from the top-of-stack.
;;;   jump-tag: the "tag" structure for the destination of this jump.
;;;   jump-condition: ALWAYS, TRUE, FALSE, ERROR-IF-TRUE, ERROR-IF-FALSE
;;;   jump-pops-if-successful: # of pops
;;;   jump-pops-if-not-successful: # of pops
;;;   jump-error-info: Either nil, or the error info for this jump
;;;   jump-always-pop: T or nil - For I architecture double-pop branches
(definst jump ("(~A~A Tag-~A)"
	       (selectq jump-condition
		 (always "Jump")
		 (false "Jump-if-false")
		 (true "Jump-if-true")
		 (error-if-true "Error-if-true")
		 (error-if-false "Error-if-false"))
	       (if (eq jump-condition 'always)
		   (selector jump-pops-if-successful =
		     (0 "")
		     (1 "-and-pop")
		     (2 "-and-pop-twice"))
		   (selector jump-pops-if-successful =
		     (0 (selector jump-pops-if-not-successful =
			  (0 "-no-pop")
			  (1 "-and-no-pop")))
		     (1 (selector jump-pops-if-not-successful =
			  (0 "-else-no-pop")
			  (1 "")
			  (2 "-else-extra-pop")))
		     (2 (selector jump-pops-if-not-successful =
			  (1 "-and-extra-pop")
			  (2 "-extra-pop")))))
	       (tag-name jump-tag))
  jump-tag
  jump-condition
  jump-pops-if-successful
  jump-pops-if-not-successful
  jump-error-info)

;;; The return instruction returns the top N values on the stack.
;;;  return-n: A fixnum, the number of values to return,
;;;    or the symbol MULTIPLE, meaning that this should be a return-multiple
;;;    instruction.  The return-multiple instruction finds a multiple value
;;;    group on the stack (N values with a fixnum N on top) and returns all
;;;;   of them.
(definst return ("(Return~:[ ~S~])" (eql return-n 1) return-n)
  return-n)

(definst-method (copy-inst return) ()
  (make-return-instruction
    :return-n return-n
    :inst-source-locator inst-source-locator
    :inst-level inst-level
    :inst-pre-control-stack-state inst-pre-control-stack-state
    :inst-post-control-stack-state inst-post-control-stack-state))

;;; The var-location instruction pushes the address of a local variable
;;; onto the stack.  (It is like PUSH-E in the A-machine.)
;;; As of System 313 it handles special variables as well.
;;;  var-location-variable: The lexical variable whose address is pushed.
;;;  var-location-level: The level of the stack before this instruction; set by phase
;;;       2 and used by phase 4 to figure out how to address lexical variables.
(definst var-location ("(Var Location ~A)" (variable-pr var-location-variable))
  var-location-variable
  var-location-level)

(definst-method (change-variable var-location) (substitutions)
  (let ((new (cl:getf substitutions var-location-variable)))
    (when new (setf var-location-variable new))))

;;; The bind instruction pops a value off the stack and binds the given
;;; special variable to it.
;;;  bind-variable: The variable that gets bound.
(definst bind ("(Bind ~A)" (if bind-variable (variable-pr bind-variable) "From STACK"))
  bind-variable)

(definst-method (change-variable bind) (substitutions)
  (let ((new (cl:getf substitutions bind-variable)))
    (when new (setf bind-variable new))))

;;; The unbind instruction pops the n most recent bindings off the binding
;;; stack.  (This instruction is never actually generated by phase 1; instead,
;;; phase 2 turns pop-vars instructions into this.)
;;;  unbind-n: The number of bindings to unbind.
(definst unbind ("(Unbind ~D)" unbind-n)
  unbind-n)

;;; The start-catch instruction always turns into exactly one
;;; catch-open L-machine instruction.  However, only the assembler
;;; can figure out the argument (the relative PC) and it can only
;;; do that after the end-catch instruction is reached.  The pframe
;;; structure for the catch links these together.
;;;  start-catch-pframe: The pframe for this catch form.
;;;  start-catch-destination: The destination of the catch.  This is used
;;;    to figure out which of the catch-open- opcodes to generate.  It cannot
;;;    be the list form destination, since this has to turn into a catch-open
;;;    instruction and the list form is only internal.
(definst start-catch ("(Start-Catch ~S (to ~A))"
		      (pframe-pr start-catch-pframe) start-catch-destination)
  start-catch-pframe
  start-catch-destination)

;;; The start-unwind-protect instruction always turns into exactly one
;;; unwind-protect-open L-machine instruction.  However, only the assember
;;; can figure out the argument (the address of the handler)
;;; and it can only do that after the main body has been compiled so that it
;;; knows where to find room in the compiled code object.  This is different
;;; from start-catch in that the destination is implicitly "ignore", and that
;;; it has a quick internal function to do cleaning up.  It uses the same kind
;;; of pframe that a start-catch does, though.
;;;  start-unwind-protect-pframe: The pframe for this form.
;;;  start-unwind-protect-handler: A tag at the beginning of the handler.
(definst start-unwind-protect ("(Start-Unwind-Protect ~S)"
			       (pframe-pr start-unwind-protect-pframe))
  start-unwind-protect-pframe
  start-unwind-protect-handler)

;;; The end-catch instruction always turns into a catch-close.  The assembler
;;; uses this to figure out the argument to the start-catch instruction.
;;; The end-catch instruction is also used to delimit the range of a start-unwind-protect.
;;; Unwind abstract instructions can be converted into this instruction by phase 2 
;;; in cases where GOs and RETURNs need to unwind catches.
;;;  end-catch-pframe: The pframe for this catch form.
;;;  end-catch-destination: The destination of the catch.  This is used
;;;    to figure out the argument of the catch-close instruction.  If this
;;;    instruction comes from an unwind, then this is the number of values
;;;    being preserved on the stack during the unwinding.  This is never
;;;    "return", since no end-catch is generated in that case (and it isn't
;;;    the list form; see start-catch above).  For an unwind-protect, this
;;;    is the destination of the unwind-protect and hence the destination
;;;    of the protected form, not the destination of the handler (which is always
;;;    ignore).
;;;  end-catch-extra-pops: On the I machine, catch-close does not restore the stack
;;;    for use, so we have to keep track of the number of extra pops which are needed
;;;    during an unwind.
(definst end-catch ("(End-Catch ~S (to ~A))"
		    (pframe-pr end-catch-pframe) end-catch-destination)
  end-catch-pframe
  end-catch-destination
  end-catch-extra-pops)

;;; The take-args instruction may turn into one of the real take-args
;;; instructions, or it may be "optimized out" if the fast calling
;;; option gets used (if there are four or fewer arguments and no
;;; rest argument).  Note that if there is a rest argument and NO
;;; optionals, this instruction always pushes something to be the
;;; rest argument, but if there is a rest argument and SOME optionals,
;;; you have to put a PUSH NIL instruction in the last element of the
;;; dispatch.  There is, in fact, an extra element in the dispatch for
;;; the rest argument when there are optionals; when there are no optionals,
;;; there is no dispatch.
;;;  take-args-n-required: The number of required arguments.
;;;  take-args-n-optional: The number of optional arguments.
;;;  take-args-rest-p: T iff there is a rest argument as well.
;;;  take-args-init-intervals: A list of n-optional intervals
;;;    containing the code to initialize those variables.
(definst take-args ("(Take-Args: ~D required, ~D optional, ~:[no~;a~] rest)"
		    take-args-n-required take-args-n-optional take-args-rest-p)
;;; >>> Need to arrange to do this somehow. <<<
;  (dolist (interval (take-args-init-intervals i))
;       (print-interval interval stream)
;       (format stream "~2%"))
  take-args-n-required
  take-args-n-optional
  take-args-rest-p
  take-args-init-intervals)

(definst-method (change-variable take-args) (substitutions)
  (dolist (interval take-args-init-intervals)
    (map-over-interval interval #'(lambda (inst)
				    (change-variable inst substitutions)))))

;;; The take-arg instruction pushes the enumerated argument from the
;;; containing external function onto the stack.  It is used instead of
;;; the take-args instruction in order to accept the argument from the caller
;;; under certain hairy conditions (see the take-args function); normally
;;; it is not used.
(definst take-arg ("(Take-Arg ~D)" take-arg-number)
  take-arg-number
  take-arg-rest-p)

;;; The require-args instruction is used before the take-arg instructions.
;;; It either does nothing or signals a wrong-number-of-arguments error.
(definst require-args ("(Require-Args: ~D required, ~D optional, ~:[no~;a~] rest)"
		       require-args-n-required require-args-n-optional require-args-rest-p)
  require-args-n-required
  require-args-n-optional
  require-args-rest-p)

;;; Stands for the take-keyword-argument instruction
(definst take-keyword-argument ("(Take Keyword Argument)")
  take-keyword-argument-rest-arg		;variable structure for the rest arg
  take-keyword-argument-interval		;code to be skipped over
  take-keyword-argument-level)			;stack level, needed in phase-4

;;; The arg-supplied-p instruction is used on I machines to tell whether a variable
;;; has been supplied.
;;;  arg-supplied-p-arg:  The arg refered to
(definst arg-supplied-p ("(Arg-Supplied-P ~s)" arg-supplied-p-arg)
  arg-supplied-p-arg)

;;; This is used on Ivory when we need more FP-addressable registers than our caller provided.
;;;  pad-argument-block-n:  The number of additional registers needed.
(definst pad-argument-block ("(Pad-Argument-Block ~D)" pad-argument-block-n)
  pad-argument-block-n)

;;; The take-values instruction is used after function calls targeted at destinations
;;; in which a specific number of values is being asked for.
;;; It expects to find on the stack N values with a fixnum N on top.
;;; It reformats these values, leaving on the stack exactly the number of
;;; values specified by the take-values-destination.
;;;  take-values-destination: The number of values desired.
(definst take-values ("(Take-Values ~D)" take-values-destination)
  take-values-destination)

;;; The relative-push-address instruction pushes, onto the stack, a locative to a
;;; numeric offset below the stack pointer.
;;;  relative-push-address-n: The depth below the top of the stack.  Zero would mean the top
;;;       of the stack.
(definst relative-push-address ("(Relative-Push-Address ~S)" relative-push-address-n)
  relative-push-address-n)

;;; The throw instruction is used for compilations of throw, in all cases.  It
;;; is almost like a function call, except that it takes a variable amount
;;; of input information on the stack and therfore cannot be expressed in Byte Lap
;;; as a function call.  "throw" is a special form, not a function, because it
;;; propagates multiple values; this is why it needs its own Byte Lap instruction.
(definst throw ("(Throw)")
  )

;;; The allocate-local-block instruction pushes a bunch of NILs onto the
;;; stack.  By the end of phase 1, we will know how many; phase 2 needs
;;; to know this in order to follow the stack level.  In a quick
;;; internal function, this instruction should not be generated;
;;; otherwise, it occurs once, after the arguments are taken.
(definst allocate-local-block ("(Allocate Local Block)")
  )

;;; The push-stack-closure instruction pushes a pointer to the current
;;; stack frame and a pointer to the internal function; it then makes a lexical
;;; closure from these two words on the stack.
(definst push-stack-closure ("(Push Stack Closure)")
  push-stack-closure-function
  push-stack-closure-level)

;;; this is a gross kludge
;;; it exists so that the logic variable initialization can see its own location,
;;; which isn't visible when the initialization form is executed
;;; it is only valid when folled by a SETQ, NAME or BIND with the same variable name
;;; (from which it finds the variable)
(definst push-logic-variable ("(Push Logic Variable ~S)" push-logic-variable-name)
  push-logic-variable-name
  push-logic-variable-variable
  push-logic-variable-level)

;;; The popj instruction is only emitted for quick internal functions.  It
;;; returns from a quick internal call, by popping a PC value off the control
;;; stack and jumping to that location.
;;;   popj-save-n: The number of things on the stack between us and the PC,
;;;        that need to be saved.  This is a fixnum, or the symbol MULTIPLE.
(definst popj ("(Popj~:[~*~; saving ~D~])" (not (eql popj-save-n 0)) popj-save-n)
  popj-save-n)

(definst-method (copy-inst popj) ()
  (make-popj-instruction
    :popj-save-n popj-save-n
    :inst-source-locator inst-source-locator
    :inst-level inst-level
    :inst-pre-control-stack-state inst-pre-control-stack-state
    :inst-post-control-stack-state inst-post-control-stack-state))

;;; The fast aref-instruction is only emitted for array-register variables.
;;;   fast-aref-variable: The array register variable
;;;   fast-aref-level: The level of the binding stack when executed
(definst fast-aref ("(Fast-aref ~S)" (variable-pr fast-aref-variable))
  fast-aref-variable
  fast-aref-level)

;;; The fast-aref-begin-instruction is emitted at the beginning of a fast-aset, to
;;; allow it to be turned back into an aref.
;;;   fast-aref-begin-function: The original function being called
;;;   fast-aref-begin-inst: The instruction which begins var part of the aref
(definst fast-aref-begin ("(Fast-aref-begin)")
  fast-aref-begin-function
  fast-aref-begin-inst)

;;; The fast aset-instruction is only emitted for array-register variables.
;;;   fast-aset-variable: The array register variable
;;;   fast-aset-level: The level of the binding stack when executed
(definst fast-aset ("(Fast-aset ~S)" (variable-pr fast-aset-variable))
  fast-aset-variable
  fast-aset-level)

;;; The fast-aset-begin instruction is emitted at the beginning of a fast-aset, to
;;; allow it to be turned back into an aset.
;;;   fast-aset-begin-function: The original function being called
;;;   fast-aset-last-value-inst: The last inst in the value computation
;;;   fast-aset-begin-inst: The beginning inst var part of the aset
(definst fast-aset-begin ("(Fast-aset-begin)")
  fast-aset-begin-function
  fast-aset-last-value-inst
  fast-aset-begin-inst)

;;; The setup-array instruction is only emitted to create array-register variables
;;; It pops off an array pointer, and replaces it with an array-register. Eventually,
;;; this will create different kinds of registers.
;;;   array-register-variable: The variable being created
(definst setup-array ("(Setup-array)")
  setup-array-register-variable
  )

(definst push-pc ("(Push PC)")
  push-pc-tag)

(definst push-pc-array ("(Push PC Array)")
  push-pc-array-tags
  push-pc-array-default-tag)


;;; Abstract instructions.

;;; The pop-vars abstract instruction is emitted at the end of
;;; the body of any special form that binds variables
;;; the duration of the special form.  This includes LET and PROG and
;;; their families.
;;; pop-vars-list: A list of "var" structures.  For each special one,
;;;   a pop has to be done off the binding stack, and for each stack-resident
;;;   lexical one, a pop has to be done off the control stack.
;;; pop-vars-destination: The destination to which the special form was
;;;   compiled.  This tells us how much good stuff is sitting on top of the
;;;   things we want to flush.  It may not be "return"; if the form before
;;;   returned then the vars got popped by the function return already.
(definst pop-vars ("(Pop-Vars ~{ ~A~} (to ~A))"
		   (loop for v in pop-vars-list collect (variable-pr v))
		   pop-vars-destination)
  pop-vars-list
  pop-vars-destination)

;;; In its usual form, the name abstract instruction is emitted right after
;;; the initial value of a new variable is computed onto the top of the
;;; stack, and it contains a list of one variable.  If the variable is
;;; stack-resident, phase 2 turns the name instruction into a no-op, and
;;; records the stack level of the variable so that phase 4 will be able to
;;; resolve references to it.  If the variable is local-block-resident,
;;; phase 2 turns the name instruction into a pop, which initializes the
;;; variable to its value.  In its more complicated form, the name
;;; instruction has a list of variables, all of whose values have appeared
;;; on the stack at the same time for some reason (like argument passing or
;;; value returning), and so many variables need to be handled together;
;;; this may preclude the use of the pop instruction if a local-resident
;;; variable value gets trapped under a stack-resident variable.
;;;  name-variables: A list of variables being created.  The first element
;;;       in the list is the first one being named (the deepest in the stack).
;;;  name-lexical-contour: The lexical contour before the NAME is executed.
(definst name ("(Name ~{ ~A~} )" (loop for v in name-variables collect (variable-pr v)))
  name-variables
  name-lexical-contour)

(definst-method (executablep name) () nil)

(definst-method (change-variable name) (substitutions)
  (scl:map-into name-variables #'(lambda (var) (cl:getf substitutions var var))
		name-variables))

;;; The start-dbs abstract instruction is generated at the start of a PROGV or
;;; PROGW, because they expand into an internal compiler special form
;;; called %with-binding-stack-level.  dbs stands for Dynamic use of Binding
;;; Stack; these special forms use the binding stack in a way that is only
;;; known at run-time.  This instruction notes the level of the binding stack
;;; at the beginning of the %with-binding-stack-level; when the end-dbs instruction
;;; is seen the level will be restored from the saved value.  It also turns into
;;; code to push the level of the binding stack onto the control stack, and
;;; end-dbs turns into code to restore the level of the binding stack to this.
;;;  start-dbs-pframe: The dbs-pframe structure for this with-binding-stack-level.
(definst start-dbs ("(Start-DBS ~S)" (pframe-pr start-dbs-pframe))
  start-dbs-pframe)

;;; The end-dbs abstract instruction restores the known level of the binding
;;; stack; see the comment for start-dbs, above.  If the surrounded code
;;; is compiled to destination return, this instruction is not generated.
;;;  end-dbs-pframe: The dbs-pframe structure for this with-binding-stack-level.
(definst end-dbs ("(End-DBS ~S)" (pframe-pr end-dbs-pframe))
  end-dbs-pframe)

;;; The start-prog abstract instruction is emitted at the beginning of
;;; the body of a PROG.  Phase 2 may turn it into a no-op, or into
;;; code to save the level of the binding stack if it turns out that
;;; there is a GO or RETURN to this PROG from inside a non-quick
;;; internal function.  This instruction is also needed so that the
;;; phase-2 pass over the Byte-Lap can note the stack levels for
;;; the prog's pframe structure (prog-level), so that unwind instructions
;;; can be cemented.  Note that this instruction is emitted after the variables
;;; of the PROG have been LETted, so that the level at that time is the inside
;;; level of the PROG; that is, the level at which tags are seen.
;;;  start-prog-pframe: The pframe structure for the PROG.
(definst start-prog ("(Start-Prog ~S)" (pframe-pr start-prog-pframe))
  start-prog-pframe)

;;; The end-prog abstract instruction is emitted at the end of the
;;; body of a PROG.  If the PROG saved the binding stack level at
;;; the beginning, this pops it off.  If the PROG is to destination
;;; return, this is not generated.
;;;  end-prog-pframe: The pframe structure for the PROG.
(definst end-prog ("(End-Prog ~S)" (pframe-pr end-prog-pframe))
  end-prog-pframe)

;;; The unwind abstract instruction is emitted before GOs and RETURNs.
;;; Its meaning is that all of the stuff on all of the stacks should
;;; be flushed to the level that occurs at the inside level of the BLOCK or TAGBODY
;;; described by unwind-frame, plus the size of the destination.  That is,
;;; everything on the stack, other than the destination stuff, should be
;;; flushed to the level that was the current level when the start-prog
;;; for this BLOCK or TAGBODY was emitted.  That means that catch blocks built by the
;;; BLOCK or TAGBODY itself are not affected, but anything inside of it is affected.
;;;  unwind-destination: This describes how much stuff is on the control
;;;    stack that should be preserved; stuff under it on the control stack
;;;    may get flushed.  It may not be "return", but it may be "multiple".
;;;  unwind-pframe: The pframe for the BLOCK or TAGBODY to whose level we are unwinding.
;;;  unwind-outside-p: Flush the catch block for the target pframe as well.
;;;  unwind-current-pframe: *pframe* when the unwind is emitted.  Phase 2 traces
;;;    from this to unwind-pframe to figure out what to do.
(definst unwind ("(Unwind ~S (to ~A))" (pframe-pr unwind-pframe) unwind-destination)
  unwind-destination
  unwind-pframe
  unwind-outside-p
  (unwind-current-pframe *pframe*)
  )

;;; The start-multiple abstract instruction is emitted when a multiple value
;;; group (N values with a fixnum N on top) is set up on the stack.  Its only
;;; purpose is so that the cementer can record the level in the multiple-pframe.
(definst start-multiple ("(Start-Multiple ~S)" (pframe-pr start-multiple-pframe))
  start-multiple-pframe)

;;; The end-multiple abstract instruction is emitted at the end of a multiple value
;;; group, so that the cementer can unwind it, should it need to.
(definst end-multiple ("(End-Multiple ~S)" (pframe-pr end-multiple-pframe))
  end-multiple-pframe)

(definst start-saved-multiple ("(Start-Saved-Multiple ~S)"
			       (mapcar #'pframe-pr start-saved-multiple-pframes))
  start-saved-multiple-pframes)

;;; The save-level abstract instruction records the control stack level
;;; into a level-saver object.  See (values phase-1).
(definst save-level ("(Save Level)")
  save-level-saver)

;;; The restore-level abstract instruction resets the level from a level-saver
;;; object.
(definst restore-level ("(Restore Level)")
  restore-level-saver)

;;; The kludge-stack abstract instruction tells phase 2 to modify
;;; its idea of the control-stack level by adding kludge-stack-amount
;;; to it.  This is used with %push and %pop so that the manipulations
;;; that those two functions do to the stack will not be visible to
;;; phase 2.  This is important because sometimes there are conditional
;;; branches that have one side that does a %push and another that does not,
;;; and this sets off the error check in phase-2 that notices internal tags
;;; having a different level than the code that drops into them.  *EVAL
;;; has one of these.
(definst kludge-stack ("(Kludge Stack ~S)" kludge-stack-amount)
  kludge-stack-amount
  kludge-stack-binding-p)

(definst unwind-quick-internal ("(Unwind Quick Internal~:[~*~; saving ~D~])"
				(not (eql unwind-quick-internal-save-n 0))
				unwind-quick-internal-save-n)
  unwind-quick-internal-save-n)

;;; This is a pseudo-instruction used by phase 2 to fixup mutually recursive LABELS
;;; inside backward jumps.
;;;  fixup-labels-fcell-vars: List of function cell variables that have to be considered.
(definst fixup-labels ("(Fixup Labels ~{ ~A~} )"
		       (loop for v in fixup-labels-fcell-vars collect v))
  fixup-labels-fcell-vars)

;;; This is for a reference to a constant flavor's mapping table from inside a method
(definst flavor-mapping-table ("(Flavor Mapping Table)")
  flavor-mapping-table-flavor)

;;; Pseudo assembler support
;;;  macro-instruction-bits: the raw machine instruction bits
;;;  macro-instruction-opcode: the symbolic opcode of the instruction
;;;  macro-instruction-operand: some kind of operand descriptor
(definst macro-instruction ("(Macro Instruction)")
  macro-instruction-bits
  macro-instruction-opcode
  macro-instruction-operand)



(defgeneric tag-function (tag)
  "The function in which the tag appears.  Not defined for internal tags.")

(defgeneric delete-tag-jump (tag inst)
  "Remove an instruction fram a tag's list of jump instructions.")

;;; A tag, the target of a jump.
;;;  tag-name: A symbol if this is a PROG tag, else a number, from *tag-uid*.
;;;     It is used for debugging and by Phase-4 when fixing up non-local GO's.
;;;  tag-type: "go" if this is a named PROG tag, "return" if this is the
;;;     return tag of a PROG, "internal" for conditionals etc.
;;;  tag-address: Numeric address of this tag.  Only used in phase 4.  This value is
;;;     after any branch lengthening that has been done; i.e., it is like a
;;;     branch-post-address.  NIL if tag not assembled yet.
;;;  tag-instruction-array: Instruction array in which tag-address was originally set.
;;;     Only used in phase 4, to relocate tag-address after the instruction arrays
;;;     are all merged together.
;;;  tag-jumps:  A list of all jump-instructions which branch to this tag.
;;;  tag-tos-status:  Used to keep track of when TOS needs to be fixed up on a jump.
;;;  tag-states:  List of possible mapping table and self values at this tag
(defflavor tag-instruction
	((tag-name)
	 (tag-address nil)
	 (tag-instruction-array)
	 (tag-jumps)
	 (tag-tos-status nil)
	 (tag-states nil))
	(byte-lap-instruction)
  :abstract-flavor
  (:conc-name "")
  :readable-instance-variables
  :writable-instance-variables
  :initable-instance-variables)

(defmethod (tagp tag-instruction) () t)

(defmethod (executablep tag-instruction) () nil)

(defmethod (delete-tag-jump tag-instruction) (inst)
  (setf tag-jumps (delq inst tag-jumps)))

;;; Tags are variants of tag-instructions.
(defvariant deftag tag-instruction tag-type "-TAG")

(defmethod (inst-opcode tag-instruction) () 'tag)



;;;

;;; Internal tags.
;;;  tag-level: The control stack level at this point.
;;;  tag-b-level: The binding stack level at this point.
;;;  tag-l-level: The locals block level at this point
(deftag internal ("(Tag-~A (internal))" tag-name)
  tag-level
  tag-b-level
  tag-l-level
  )

;;; Go and return tags.  These structures share tag-pframe.
;;;  tag-pframe: The pframe for the containing PROG.
;;;  tag-non-local-target-p: When non-NIL, indicates that some internal function GO's
;;;     to this tag - Phase-3 should not get rid of it if tag-jumps is NIL.
(deftag go ("(Tag-~A (go): ~S)" tag-name (pframe-pr tag-pframe))
  tag-pframe
  (tag-non-local-target-p nil))

(deftag-method (tag-function go) ()
  (nlg-function tag-pframe))

;;;

(deftag pc ("(Tag-~A (pc))" tag-name)
  (tag-function *function*)
  )

(definst block-read-test ("(Block-Read-Test ~O ~O ~A)"
			  block-read-test-bar
			  block-read-test-code
			  (tag-name block-read-test-tag))
  block-read-test-bar
  block-read-test-code
  block-read-test-tag
  block-read-test-level
  (block-read-test-pframe *pframe*)
  block-read-test-require-tos-valid)

;;;

;;; This instruction (and its variants below) are used to impose a tree structure on byte-lap
;;; generated by phase 1.  This structure is needed by the new phase (1a) that detects
;;; stack frame overflow.  The structure is removed by phase 1b.
(definst interval ("(Interval (to ~A))" interval-destination)
  ;; The destination to which the primary interval was compiled.
  ;; This describes the effect on the stack level of the interval.
  interval-destination
  ;; A list of intervals.  The first is the primary interval.  The rest are extra intervals.
  interval-intervals
  (interval-lexical-contour (si:env-variables *interpreter-lexical-environment*)))

(defvariant definterval interval-instruction interval-type "-INTERVAL-INSTRUCTION")

;;; This instruction is inserted by phase 1 at points where it is possible to break off an 
;;; internal function.  They are removed by phase 1b.
(definterval split ("(Split)")
  ;; These slots are used only by the frame-splitting stuff.
  interval-parent
  interval-offset
  (interval-children nil)
  (interval-max-words 0)
  (interval-tag-table nil)
  (interval-current-words 0)
  (interval-closure-words 0))

(defwhopper (interval-tag-table split-interval-instruction) ()
  (or (continue-whopper)
      (setf interval-tag-table (cl:make-hash-table :size 10))))

;;; These instructions are generated by phase 1 for non-local transfers.
;;; They are replaced by phase 1b with expanded code depending on whether the transfer
;;; was really non-local.

(definterval tagbody ("(Tagbody)")
  tagbody-pframe
  tagbody-tags)

(definst go ("(Go Tag-~A)" go-tag)
  go-pframe
  go-tag)

(definterval computed-go ("(Computed-Go)")
  computed-go-pframe
  computed-go-tags)

;;;

(definterval block ("(Block)")
  block-pframe)

(definterval return-from ("(Return-From)")
  return-from-pframe)
