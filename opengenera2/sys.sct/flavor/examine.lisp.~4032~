;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; All of the Flavor Examiner except for the program framework and the Zwei m-X interface

;---There should be a "lisp hacking" command table that this stuff goes in,
;---with the global command-table being reserved for language-independent stuff?

;;; Little support facilities that probably should be defined elsewhere

;The equivalent of ~ in FORMAT
(DEFMACRO WITH-CURRENT-INDENTATION ((&OPTIONAL (STREAM `*STANDARD-OUTPUT*)) &BODY BODY)
  (CHECK-TYPE STREAM SYMBOL)
  `(WITH-INDENTATION (,STREAM (ROUND-CURSOR-POSITION-TO-CHARACTERS ,STREAM))
     ,@BODY))

(DEFPARAMETER *MAXIMUM-INDENTATION-RATIO* 0.40)

;This makes things line up better, because WITH-INDENTATION can't indent by pixels.
;Also, if we are indented too far into the window, use a lesser indentation for the
;next line.  This would work better if FORMATTING-TEXTUAL-LIST were willing to start
;with a carriage return when the first item didn't fit on the line.
;Since this rounds down, you sometimes need to output an extra space first.
(DEFUN ROUND-CURSOR-POSITION-TO-CHARACTERS (&OPTIONAL (STREAM *STANDARD-OUTPUT*))
  (LET ((POSITION (SEND-IF-HANDLES STREAM :READ-CURSORPOS :CHARACTER))
	(SIZE (SEND-IF-HANDLES STREAM :SIZE-IN-CHARACTERS)))
    (UNLESS POSITION
      (RETURN-FROM ROUND-CURSOR-POSITION-TO-CHARACTERS 0))
    (LET ((INDENTATION (IF SIZE (MIN (FLOOR (* SIZE *MAXIMUM-INDENTATION-RATIO*)) POSITION)
			   POSITION)))
      (UNLESS (> POSITION INDENTATION)
	(SEND STREAM :SET-CURSORPOS INDENTATION NIL :CHARACTER))
      INDENTATION)))

(DEFUN QUOTE-UNLESS-CONSTANT (OBJECT)
  (IF (OR (NOT (ATOM OBJECT))
	  (AND (SYMBOLP OBJECT)
	       (NEQ OBJECT NIL)
	       (NEQ OBJECT T)
	       (NOT (KEYWORDP OBJECT))))
      (LIST 'QUOTE OBJECT)
      OBJECT))

(DEFUN PRINT-ARGLIST-AND-VALUES (ARGLIST VALUES)
  (WRITE-STRING ": ")
  (ZWEI:PRINT-ARGLIST-INTERNAL ARGLIST *STANDARD-OUTPUT*)
  (WHEN VALUES
    (FORMAT T "  ~:A" VALUES)))

;;; Abstract out the matching mechanism
;--- This should be general substrate defined elsewhere

;;; Wildcard matching version

;(DEFCONSTANT MATCH-ANYTHING-STRING "*")
;
;(DEFCONSTANT MATCH-STRING-TYPE 'STRING)	;Presentation type for command args
;
;(DEFUN MATCH-STRING (PATTERN ITEM)
;  (LOOP WHILE (CONSP ITEM) DO			;Deal with function-specs
;    (SETQ ITEM (SECOND ITEM)))
;  (FS:WILDCARD-MATCH PATTERN (STRING ITEM)))
;
;(DEFUN MATCH-DOCUMENTATION (SENTENCE-BEGINNING)
;  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
;  (STRING-APPEND SENTENCE-BEGINNING " that match this wildcard string"))
;
;--- If reinstated, needs to be updated like the version below
;(DEFUN NO-MATCH-FOUND (ITEM-DESCRIPTION &REST PATTERNS)
;  (FORMAT T "~&No ~:[matches found to~;~:*~A match the~] wildcard pattern~P "
;	  ITEM-DESCRIPTION (LIST-LENGTH PATTERNS))
;  (FORMAT-TEXTUAL-LIST PATTERNS #'PRIN1 :CONJUNCTION "or")
;  (WRITE-CHAR #\.))
;
;(DEFUN NON-MATCHING-ITEMS-FOUND (ITEMS ITEM-DESCRIPTION &REST PATTERNS)
;  (FORMAT T "~&~:D ~A~2:*~[~1; was~:;s were~] found ~*~
;			that did not match the wildcard pattern~P "
;	  (LIST-LENGTH ITEMS) ITEM-DESCRIPTION (LIST-LENGTH PATTERNS))
;  (FORMAT-TEXTUAL-LIST PATTERNS #'PRIN1 :CONJUNCTION "or")
;  (WRITE-CHAR #\.))


;;; Substring matching version
;--- Could be a sequence of substrings anded together, like :find symbol
;--- Could be by-word matching
;--- Could use vertical bar to indicate left or right end must match up

(DEFCONSTANT MATCH-ANYTHING-STRING "")

(DEFCONSTANT MATCH-STRING-TYPE 'STRING)		;Presentation type for command args

(DEFUN MATCH-STRING (PATTERN ITEM)
  (LOOP WHILE (CONSP ITEM) DO			;Deal with function-specs
    (SETQ ITEM (SECOND ITEM)))
  (STRING-SEARCH PATTERN (STRING ITEM)))

(DEFUN MATCH-DOCUMENTATION (SENTENCE-BEGINNING)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (STRING-APPEND SENTENCE-BEGINNING " that contain this substring"))

(DEFUN NO-MATCH-FOUND (ITEM-DESCRIPTION &REST PATTERNS)
  (COND ((MEMBER MATCH-ANYTHING-STRING PATTERNS :TEST #'EQUAL)
	 (FORMAT T "~&No ~A found."
		 (COND ((NULL ITEM-DESCRIPTION) "matches")
		       ((LISTP ITEM-DESCRIPTION) (SECOND ITEM-DESCRIPTION))
		       (T ITEM-DESCRIPTION))))
	(T
	 (WHEN (LISTP ITEM-DESCRIPTION)
	   (SETQ ITEM-DESCRIPTION (FIRST ITEM-DESCRIPTION)))
	 (FORMAT T "~&No ~:[matches found that~;~:*~A~] contain the substring~P "
		 ITEM-DESCRIPTION (LIST-LENGTH PATTERNS))
	 (FORMAT-TEXTUAL-LIST PATTERNS #'PRIN1 :CONJUNCTION "or")
	 (WRITE-CHAR #\.))))

(DEFUN NON-MATCHING-ITEMS-FOUND (ITEMS ITEM-DESCRIPTION &REST PATTERNS)
  (FORMAT T "~&~:D ~A~2:*~[~1; was~:;s were~] found ~*~
			that did not contain the substring~P "
	  (LIST-LENGTH ITEMS) ITEM-DESCRIPTION (LIST-LENGTH PATTERNS))
  (FORMAT-TEXTUAL-LIST PATTERNS #'PRIN1 :CONJUNCTION "or")
  (WRITE-CHAR #\.))

;;; Dynamic / Presentation / CP commands to show various aspects of a flavor

;;; Brackets mean this component does not appear here
;;; Downarrow means this component appears later
;;; Uparrow after brackets means this component appeared earlier
;;; Uparrow without brackets means this component appeared in the
;;;  depth-first traversal earlier, but appears here.
;;; If you just read the unbracketed items and ignore the punctuation
;;;  you get the actual component list, topologically sorted.
;;;  Without the :detailed option, that's all you see.
;;; If you just read all the flavor names and ignore the punctuation
;;;  you get an abbreviated form of the depth-first tree.
(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-COMPONENTS :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose component flavors are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "component flavors" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show component flavors"))
       (DUPLICATES 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Show duplicate occurrences of flavors, too.")
       (BRIEF 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Don't show the structure, just the names.")
       (INSTANCE-VARIABLES MATCH-STRING-TYPE
	:DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show instance variables"))
       (METHODS MATCH-STRING-TYPE :DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show methods for generics"))
       (INITIALIZATIONS MATCH-STRING-TYPE
	:DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show initializations"))
       (FUNCTIONS MATCH-STRING-TYPE :DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show in-flavor functions"))
       (DETAILED 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION
	  "Show additional detail if showing instance variables or initializations"))

  (SHOW-FLAVOR-COMPONENTS-AND FLAVOR-NAME :SHOW-STRUCTURE (NOT BRIEF)
					  :SHOW-DUPLICATES DUPLICATES
					  :PRUNE (OR (NOT (EQUAL MATCH MATCH-ANYTHING-STRING))
						     (AND (NOT DUPLICATES)
							  (OR INSTANCE-VARIABLES METHODS
							      INITIALIZATIONS FUNCTIONS)))
					  :SHOW-FLAVORS MATCH
					  :SHOW-INSTANCE-VARIABLES INSTANCE-VARIABLES
					  :SHOW-METHODS METHODS
					  :SHOW-INITIALIZATIONS INITIALIZATIONS
					  :SHOW-FUNCTIONS FUNCTIONS
					  :DETAILED DETAILED))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-INSTANCE-VARIABLES :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose instance variables are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "instance variables matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show instance variables"))
       (SORT
	'((ALIST-MEMBER
	   :ALIST (("Alphabetical" :VALUE ALPHABETICAL
		    :DOCUMENTATION "Sort the display alphabetically by instance variable name")
		   ("Flavor" :VALUE FLAVOR
		    :DOCUMENTATION "Sort the display according to flavor inheritance"))))
	:DEFAULT 'ALPHABETICAL
	:PROMPT "by" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Sort the display alphabetically by instance variable name,
or display the flavor inheritance tree with instance variables attached")
       (LOCALLY 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Do not show inherited instance variables")
       (DETAILED 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Show attributes such as readability and initability"))
   (IF (EQ SORT 'FLAVOR)
       (SHOW-FLAVOR-COMPONENTS-AND FLAVOR-NAME :SHOW-INSTANCE-VARIABLES MATCH
					       :DETAILED DETAILED
					       :PRUNE T :LOCALLY LOCALLY)
     (SHOW-FLAVOR-INSTANCE-VARIABLES-ALPHABETICALLY
       FLAVOR-NAME MATCH DETAILED LOCALLY)))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-METHODS :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose methods are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "generics matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show methods for generics"))
       (SORT
	'((ALIST-MEMBER
	   :ALIST (("Alphabetical" :VALUE ALPHABETICAL
		    :DOCUMENTATION "Sort the display alphabetically by generic function name")
		   ("Flavor" :VALUE FLAVOR
		    :DOCUMENTATION "Sort the display according to flavor inheritance"))))
	:DEFAULT 'ALPHABETICAL
	:PROMPT "by" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Sort the display alphabetically by generic function name,
or display the flavor inheritance tree with methods attached")
       (USING-INSTANCE-VARIABLE 'SYMBOL :DEFAULT NIL
	:PROMPT "an instance variable name"
	:DOCUMENTATION "Only show methods which use this instance variable")
       (LOCALLY 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Do not show inherited methods"))
   (COND ((NOT (NULL USING-INSTANCE-VARIABLE))
	  (SHOW-FLAVOR-METHODS-WHICH-USE-INSTANCE-VARIABLE
	    USING-INSTANCE-VARIABLE FLAVOR-NAME
	    :INCLUDE-COMPONENTS (NOT LOCALLY) :MATCHING MATCH))
	 ((EQ SORT 'FLAVOR)
	  (SHOW-FLAVOR-COMPONENTS-AND FLAVOR-NAME :SHOW-METHODS MATCH
						  :PRUNE T :LOCALLY LOCALLY))
	 (T
	  (SHOW-FLAVOR-METHODS-ALPHABETICALLY FLAVOR-NAME MATCH LOCALLY))))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-INITIALIZATIONS :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose initializations are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "initializations matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show initializations"))
       (SORT
	'((ALIST-MEMBER
	   :ALIST (("Alphabetical" :VALUE ALPHABETICAL
		    :DOCUMENTATION "Sort the display alphabetically by initialization keyword")
		   ("Flavor" :VALUE FLAVOR
		    :DOCUMENTATION "Sort the display according to flavor inheritance"))))
	:DEFAULT 'ALPHABETICAL
	:PROMPT "by" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Sort the display alphabetically by initialization keyword,
or display the flavor inheritance tree with initializations attached")
       (LOCALLY 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Do not show inherited initializations")
       (DETAILED 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Show all initializations, not just MAKE-INSTANCE keywords"))
  (IF (EQ SORT 'FLAVOR)
      (SHOW-FLAVOR-COMPONENTS-AND FLAVOR-NAME :SHOW-INITIALIZATIONS MATCH
					      :PRUNE T :DETAILED DETAILED :LOCALLY LOCALLY)
      (SHOW-FLAVOR-INITIALIZATIONS-ALPHABETICALLY FLAVOR-NAME MATCH DETAILED LOCALLY)))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-FUNCTIONS :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose in-flavor functions are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "functions matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show in-flavor functions"))
       (SORT
	'((ALIST-MEMBER
	   :ALIST (("Alphabetical" :VALUE ALPHABETICAL
		    :DOCUMENTATION "Sort the display alphabetically by function name")
		   ("Flavor" :VALUE FLAVOR
		    :DOCUMENTATION "Sort the display according to flavor inheritance"))))
	:DEFAULT 'ALPHABETICAL
	:PROMPT "by" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Sort the display alphabetically by function name,
or display the flavor inheritance tree with in-flavor functions attached")
       (LOCALLY 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Do not show inherited functions"))
  (IF (EQ SORT 'FLAVOR)
      (SHOW-FLAVOR-COMPONENTS-AND FLAVOR-NAME :SHOW-FUNCTIONS MATCH :PRUNE T :LOCALLY LOCALLY)
      (SHOW-FLAVOR-FUNCTIONS-ALPHABETICALLY FLAVOR-NAME MATCH LOCALLY)))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-OPERATIONS :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose generic operations are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "operations matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show operations on an instance of this flavor"))
       (DETAILED 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T
	:DOCUMENTATION "Show the arguments of each operation in addition to the name"))
  (LET* ((FL (FIND-FLAVOR FLAVOR-NAME))
	 ;; Collect the list of matching generic operations, copied so it can be sorted
	 (OPERATIONS
	   (FLET ((MATCH (OPERATION)
		    (OR (MATCH-STRING MATCH OPERATION)
			(LET ((MESSAGE (GENERIC-FUNCTION-COMPATIBLE-MESSAGE 
					 (FIND-GENERIC-FUNCTION OPERATION))))
			  (AND MESSAGE (MATCH-STRING MATCH MESSAGE))))))
	     (IF (FLAVOR-ALL-GENERICS FL)
		 (LOOP FOR OPERATION IN (FLAVOR-ALL-GENERICS FL)
		       UNLESS (AND (SYMBOLP OPERATION) (GET OPERATION 'COMPATIBLE-GENERIC))
			 WHEN (MATCH OPERATION)
			   COLLECT OPERATION)
		 (LOOP FOR (GENERIC . METHODS) IN (COLLECT-METHODS FLAVOR-NAME :ERROR-P NIL)
		       AS OPERATION = (GENERIC-FUNCTION-NAME GENERIC)
		       WHEN (MATCH OPERATION)
			 COLLECT OPERATION)))))
    (WHEN (NULL OPERATIONS)
      (NO-MATCH-FOUND "operations" MATCH)
      (RETURN-FROM COM-SHOW-FLAVOR-OPERATIONS (VALUES)))
    (SETQ OPERATIONS (SORT OPERATIONS #'STRING-LESSP
			   :KEY #'(LAMBDA (GENERIC)
				    (IF (LISTP GENERIC) (SECOND GENERIC) GENERIC))))
    (IF (NOT DETAILED)
	(FORMAT-ITEM-LIST OPERATIONS :PRESENTATION-TYPE '((GENERIC-FUNCTION-NAME)
							  :SHOW-COMPATIBLE-MESSAGE T))
	(DOLIST (OPERATION OPERATIONS)
	  (LET ((GF (FIND-GENERIC-FUNCTION OPERATION)))
	    (MULTIPLE-VALUE-BIND (ARGLIST VALUES)
		(ARGLIST (IF (GENERIC-FUNCTION-MESSAGE-P GF) GF OPERATION))
	      (WRITE-STRING "  ")
	      (PRESENT OPERATION 'GENERIC-FUNCTION-NAME)
	      (COND ((GENERIC-FUNCTION-MESSAGE-P GF)
		     (WRITE-STRING " (message)"))
		    ((GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF)
		     (FORMAT T " (message ~S)" (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF))))
	      ;--- For unexplicit generics, especially messages, this just uses the
	      ;--- general heuristicated arguments.
	      ;--- Really it ought to look at the methods of this particular flavor.
	      ;--- I don't have time for that now.
	      (PRINT-ARGLIST-AND-VALUES ARGLIST VALUES)
	      (TERPRI)))))))

;;; Common subroutine of various commands
;;; SHOW-INSTANCE-VARIABLES etc. can be NIL or a pattern causing matching ones to be shown
(DEFUN SHOW-FLAVOR-COMPONENTS-AND (FLAVOR-NAME &KEY (SHOW-STRUCTURE T)
						    SHOW-DUPLICATES
						    (SHOW-FLAVORS MATCH-ANYTHING-STRING)
						    SHOW-INSTANCE-VARIABLES
						    SHOW-METHODS
						    SHOW-INITIALIZATIONS
						    SHOW-FUNCTIONS
						    PRUNE
						    LOCALLY
						    DETAILED)
  ;; Have to show the structure if we're going to show anything else
  (WHEN (OR SHOW-DUPLICATES SHOW-INSTANCE-VARIABLES SHOW-METHODS
	    SHOW-INITIALIZATIONS SHOW-FUNCTIONS)
    (SETQ SHOW-STRUCTURE T))
  (WHEN LOCALLY (SETQ PRUNE NIL))

  ;; Get the list of component flavors
  (LET* ((FL (FIND-FLAVOR FLAVOR-NAME))
	 (COMPONENTS (COND (LOCALLY (LIST FLAVOR-NAME))
			   ((FLAVOR-COMPONENTS-COMPOSED FL)
			    (FLAVOR-ALL-COMPONENTS FL))
			   (T
			    (COMPOSE-FLAVOR-COMPONENTS FLAVOR-NAME))))
	 (ALL-COMPONENTS COMPONENTS)
	 (REQUIRED-FLAVORS NIL)
	 (INTERESTING-COMPONENTS NIL)
	 (FIRST T)
	 (SECOND NIL))

    ;; Add components reached by :REQUIRED-FLAVORS
    (DOLIST (FLAVOR COMPONENTS)
      (LABELS ((ADD-REQUIRED (FLAVOR)
		 (LET ((FL (FIND-FLAVOR FLAVOR NIL)))
		   (DOLIST (REQ (AND FL (FLAVOR-REQUIRED-FLAVORS FL)))
		     (UNLESS (MEMBER REQ COMPONENTS)
		       (LET ((ELEM (ASSOC REQ REQUIRED-FLAVORS)))
			 (COND (ELEM (PUSH FLAVOR (CDR ELEM)))
			       (T (PUSH (LIST REQ FLAVOR) REQUIRED-FLAVORS)
				  (ADD-REQUIRED REQ)))))))))
	(ADD-REQUIRED FLAVOR)))
    (SETQ REQUIRED-FLAVORS (REMOVE SHOW-FLAVORS (NREVERSE REQUIRED-FLAVORS)
				   :KEY #'CAR :TEST-NOT #'MATCH-STRING))

    ;; If not showing structure, just list the names in tabular format
    (IF (NOT SHOW-STRUCTURE)
	(LET ((FLAVORS (REMOVE SHOW-FLAVORS COMPONENTS :TEST-NOT #'MATCH-STRING)))
	  (UNLESS (NULL FLAVORS)
	    (FORMAT-ITEM-LIST FLAVORS :PRESENTATION-TYPE 'FLAVOR-NAME)))

      ;; Showing structure: prune the tree to just the interesting flavors, if desired
      (LABELS ((INTERESTING-P (FLAVOR-NAME)
		 (WHEN (OR (MATCH-STRING SHOW-FLAVORS FLAVOR-NAME)
			   (AND (OR SHOW-INSTANCE-VARIABLES SHOW-METHODS
				    SHOW-INITIALIZATIONS SHOW-FUNCTIONS)
				(FLAVOR-HAS-MATCHING-ATTRIBUTES FLAVOR-NAME
				  SHOW-INSTANCE-VARIABLES SHOW-METHODS
				  SHOW-INITIALIZATIONS SHOW-FUNCTIONS DETAILED))
			   (LOOP FOR (REQUIRED . BY) IN REQUIRED-FLAVORS
				 THEREIS (AND (MEMBER FLAVOR-NAME BY)
					      (INTERESTING-P REQUIRED))))
		   (PUSHNEW FLAVOR-NAME INTERESTING-COMPONENTS)
		   T))
	       (INDENT (DEPTH FIRST)
		 (DOTIMES (I (+ (* DEPTH 2) (IF FIRST 0 2))) (WRITE-CHAR #\SPACE))))
	(WHEN PRUNE
	  (LET ((FLAVOR-NAME FLAVOR-NAME)
		(COMPONENTS COMPONENTS)
		(INITIAL-DEPTH 0))
	    (WITH-STACK-ARRAY (TRAIL (LENGTH COMPONENTS))
	      (LOOP WHILE COMPONENTS DO
		(MAP-COMPONENTS-DEPTH-FIRST
		  #'(LAMBDA (FLAVOR-NAME DEPTH IGNORE REAL)
		      (SETF (AREF TRAIL DEPTH) FLAVOR-NAME)
		      (COND ((NOT REAL) 'DONT-RECURSE)
			    ((EQ FLAVOR-NAME (FIRST COMPONENTS))
			     ;; Decide whether this flavor is interesting
			     (WHEN (INTERESTING-P FLAVOR-NAME)
			       (DOTIMES (I DEPTH)
				 (PUSHNEW (AREF TRAIL I) INTERESTING-COMPONENTS)))
			     (POP COMPONENTS)
			     T)
			    (T 'DONT-RECURSE)))
		  FLAVOR-NAME NIL INITIAL-DEPTH)
		;; In general, there will be some components left over because of complex
		;; ordering constraints.  So run another pass to pick up the next bunch.
		(SETQ FLAVOR-NAME (FIRST COMPONENTS)
		      INITIAL-DEPTH 1))))
	  (UNLESS INTERESTING-COMPONENTS
	    (APPLY #'NO-MATCH-FOUND NIL
		   (DELETE NIL (LIST (AND (NOT (EQUAL SHOW-FLAVORS MATCH-ANYTHING-STRING))
					  SHOW-FLAVORS)
				     SHOW-INSTANCE-VARIABLES SHOW-METHODS
				     SHOW-INITIALIZATIONS SHOW-FUNCTIONS)))
	    (RETURN-FROM SHOW-FLAVOR-COMPONENTS-AND (VALUES))))
    
	;; Iterate, printing it out, until all of them have been printed
	(LOOP WHILE COMPONENTS DO
	  (MAP-COMPONENTS-DEPTH-FIRST
	    #'(LAMBDA (FLAVOR-NAME DEPTH IGNORE REAL)
		(COND ((NOT REAL) 'DONT-RECURSE)
		      ((AND INTERESTING-COMPONENTS
			    (NOT (MEMBER FLAVOR-NAME INTERESTING-COMPONENTS)))
		       (COND ((EQ FLAVOR-NAME (FIRST COMPONENTS))
			      (POP COMPONENTS)
			      T)
			     (T 'DONT-RECURSE)))
		      ((OR SHOW-DUPLICATES (EQ FLAVOR-NAME (FIRST COMPONENTS)))
		       ;; We're going to print this flavor
		       (WHEN (> DEPTH 0) (SETQ SECOND T))
		       (COND ((EQ FLAVOR-NAME (FIRST COMPONENTS))
			      ;; This flavor really goes here
			      (POP COMPONENTS)
			      (INDENT DEPTH FIRST)
			      (PRESENT FLAVOR-NAME 'FLAVOR-NAME)
			      (WHEN (AND (NOT FIRST)
					 SECOND
					 (ZEROP DEPTH))	;Top level of second pass
				;; Put in this arrow even when SHOW-DUPLICATES is not
				;; on, so that we know that the indentation of this
				;; line does not necessarily reflect the real
				;; structure.
				(WRITE-STRING " "))
			      (SHOW-MATCHING-FLAVOR-ATTRIBUTES FLAVOR-NAME
					SHOW-INSTANCE-VARIABLES SHOW-METHODS
					SHOW-INITIALIZATIONS SHOW-FUNCTIONS ALL-COMPONENTS
					DETAILED)
			      (TERPRI)
			      T)
			     (T
			      ;; This flavor goes someplace else, note an eliminated duplicate
			      (INDENT DEPTH FIRST)
			      (WRITE-CHAR #\[)
			      (PRESENT FLAVOR-NAME 'FLAVOR-NAME)
			      (WRITE-STRING (IF (MEMBER FLAVOR-NAME COMPONENTS) "] " "] "))
			      (TERPRI)
			      'DONT-RECURSE)))
		      (T 'DONT-RECURSE)))
	    FLAVOR-NAME)
	  ;; In general, there will be some components left over because of complex
	  ;; ordering constraints.  So run another pass to pick up the next bunch.
	  ;; Run this pass only over the remaining components, to get the depths right.
	  ;; The order of printing is controlled by the original, correct components
	  ;; list, so switching FLAVOR-NAME won't hurt anything.
	  (SETQ FLAVOR-NAME (FIRST COMPONENTS))
	  (SETQ FIRST NIL))))

    ;; After the table or tree of components, show any left-over required flavors
    (WHEN REQUIRED-FLAVORS
      (FORMAT T "~&Required flavors that are not components:~%")
      (FLET ((SHOW (REQ STREAM)
	       (PRESENT (FIRST REQ) 'FLAVOR-NAME :STREAM STREAM)
	       (WRITE-STRING " [required by " STREAM)
	       (FORMAT-TEXTUAL-LIST (REST REQ)
				    (LAMBDA (FLAVOR STREAM)
				      (PRESENT FLAVOR 'FLAVOR-NAME :STREAM STREAM))
				    :STREAM STREAM)
	       (WRITE-STRING "]" STREAM)))
	(IF (OR SHOW-INSTANCE-VARIABLES SHOW-METHODS SHOW-INITIALIZATIONS SHOW-FUNCTIONS)
	    (LOOP FOR REQ IN REQUIRED-FLAVORS DO
	      (WRITE-STRING "  ")
	      (SHOW REQ *STANDARD-OUTPUT*)
	      (SHOW-MATCHING-FLAVOR-ATTRIBUTES (CAR REQ) SHOW-INSTANCE-VARIABLES SHOW-METHODS
					       SHOW-INITIALIZATIONS SHOW-FUNCTIONS
					       ALL-COMPONENTS DETAILED)
	      (TERPRI))
	    (FORMAT-ITEM-LIST REQUIRED-FLAVORS :PRINTER #'SHOW))))))

;Another subroutine: show local attributes of this flavor, if any, selected by options
;DETAILED is only implemented for instance-variables & initializations currently.
;This shows all attributes, even ones that aren't inherited by the original
;flavor of interest, due to shadowing.  That's a feature.
(DEFUN SHOW-MATCHING-FLAVOR-ATTRIBUTES (FLAVOR-NAME SHOW-INSTANCE-VARIABLES
					SHOW-METHODS SHOW-INITIALIZATIONS SHOW-FUNCTIONS
					COMPONENTS DETAILED)
  (WHEN (OR SHOW-INSTANCE-VARIABLES SHOW-METHODS		;Speed bum
	    SHOW-INITIALIZATIONS SHOW-FUNCTIONS)
    (LET ((FL (FIND-FLAVOR FLAVOR-NAME))
	  (PRINTED-SOMETHING NIL)
	  MATCHING-ITEMS)
      (MACROLET ((SHOW-MATCHES (MATCH TITLE SORT &BODY ITERATION)
		   `(WHEN ,MATCH
		      (SETQ MATCHING-ITEMS NIL)
		      (MACROLET ((SHOW-IF-MATCH (ITEM &BODY PRINT)
				   `(WHEN (MATCH-STRING ,',MATCH ,ITEM)
				      (ENQUEUE (,ITEM) ,@PRINT))))
			,@ITERATION)
		      (SHOW-MATCHING-ITEMS MATCHING-ITEMS ,TITLE ,SORT)))
		 (ENQUEUE ((&REST ARGUMENTS) &BODY BODY)
		   (ASSERT (OR (NOT (NULL BODY)) (= (LIST-LENGTH ARGUMENTS) 1)))
		   `(ENQUEUE-FUNCTION ,(IF BODY
					   `(DW:NAMED-VALUE-SNAPSHOT-CONTINUATION PRINTER
					      ,(LOOP FOR ARG IN ARGUMENTS
						     COLLECT (IF (SYMBOLP ARG) ARG 'IGNORE))
					      ,@BODY)
					   `#'PRIN1)
				      ,@ARGUMENTS))
		 (ENQUEUE-FUNCTION (FUNCTION &REST ARGUMENTS)
		   `(PUSH (LIST ,FUNCTION ,@ARGUMENTS) MATCHING-ITEMS)))
	(LABELS ((SHOW-TITLE (TITLE PLURAL)
		   ;; Indent each titled block of output the same
		   (COND (PRINTED-SOMETHING
			  (TERPRI)
			  (SEND *STANDARD-OUTPUT* :SET-CURSORPOS PRINTED-SOMETHING NIL))
			 (T
			  (SETQ PRINTED-SOMETHING (SEND *STANDARD-OUTPUT* :READ-CURSORPOS))
			  ;; Maybe there isn't enough space left on the line?  Do a
			  ;; stupid heuristic to "make sure" there is enough (3/5 the width).
			  (LET ((ENOUGH
				  (FLOOR (OR (SEND-IF-HANDLES *STANDARD-OUTPUT* :INSIDE-SIZE)
					     95)	;Assume cursorpos in character units
					 5/2)))
			    (UNLESS ( PRINTED-SOMETHING ENOUGH)
			      (SETQ PRINTED-SOMETHING ENOUGH)
			      (TERPRI)
			      (SEND *STANDARD-OUTPUT* :SET-CURSORPOS PRINTED-SOMETHING NIL))
			    )))
		   (WRITE-CHAR #\SPACE)
		   (WITH-CHARACTER-STYLE ('(:DUTCH :ITALIC :SMALLER))
		     (WRITE-STRING TITLE)
		     (WHEN PLURAL (WRITE-CHAR #\s)))
		   (WRITE-CHAR #\SPACE)
		   (WRITE-CHAR #\SPACE))		;This space may get rounded down
		 (SHOW-MATCHING-ITEMS (MATCHING-ITEMS TITLE SORT)
		   (WHEN MATCHING-ITEMS
		     (SHOW-TITLE TITLE (CDR MATCHING-ITEMS))
		     ;;--- When the items involve GPRINT some smarter formatting
		     ;;--- that gave an item more horizontal space so it didn't need so
		     ;;--- much vertical space would be nice.  For now, I'm tired of
		     ;;--- hacking this; what it does now is good enough for the moment.
		     (WITH-CURRENT-INDENTATION ()
		       (FORMAT-TEXTUAL-LIST
			 (IF SORT (SORT MATCHING-ITEMS #'STRING-LESSP :KEY #'SECOND)
			     MATCHING-ITEMS)
			 #'(LAMBDA (ELEMENT *STANDARD-OUTPUT*)
			     (APPLY (FIRST ELEMENT) (REST ELEMENT)))
			 :FILLED T :SEPARATOR ", "))))
		 (SHOW-METHODS (GENERIC
				&OPTIONAL (METHOD-HOLDERS
					    (CDR (ASSOC GENERIC (FLAVOR-METHOD-TABLE FL)))))
		   (SETQ METHOD-HOLDERS
			 (REMOVE 'COMBINED METHOD-HOLDERS
				 :KEY #'(LAMBDA (MH)
					  (METHOD-TYPE (METHOD-HOLDER-FUNCTION-SPEC MH)))))
		   (WHEN METHOD-HOLDERS
		     (LET ((METHOD-COMBINATION		;Speed bum: compute only if needed
			     (WHEN (LOOP FOR MH IN METHOD-HOLDERS
					 AS METHOD = (METHOD-HOLDER-FUNCTION-SPEC MH)
					 WITH PRIMARY = NIL WITH OTHER = NIL
					 DO (COND ((NEQ (METHOD-TYPE METHOD) 'METHOD)
						   (SETQ OTHER T))
						  ((NULL (METHOD-OPTIONS METHOD))
						   (SETQ PRIMARY T))
						  (T (RETURN T)))
					 FINALLY (RETURN (AND PRIMARY OTHER)))
			       (DECIDE-METHOD-COMBINATION (FIND-GENERIC-FUNCTION GENERIC)
							  COMPONENTS NIL))))
		       (LOOP FOR (MH . REST) ON METHOD-HOLDERS
			     AS METHOD = (METHOD-HOLDER-FUNCTION-SPEC MH)
			     AND PREVIOUS-METHOD = NIL THEN METHOD
			     AND ONLY-METHOD = (NULL REST) DO
			 (ENQUEUE (METHOD PREVIOUS-METHOD METHOD-COMBINATION ONLY-METHOD)
			   (DW:WITH-OUTPUT-AS-PRESENTATION (:OBJECT METHOD
							    :TYPE (METHOD-PRESENTATION-TYPE
								    METHOD)
							    :ALLOW-SENSITIVE-INFERIORS NIL)
			     (LET ((PRINTED-SOMETHING NIL))
			       ;; Print generic function name if changed
			       (UNLESS (EQ (METHOD-GENERIC PREVIOUS-METHOD)
					   (METHOD-GENERIC METHOD))
				 (PRIN1 (METHOD-GENERIC METHOD))
				 (SETQ PRINTED-SOMETHING T))
			       ;; Elide the word "primary" when possible
			       (UNLESS (AND PRINTED-SOMETHING
					    ONLY-METHOD
					    (EQ (METHOD-TYPE METHOD) 'FLAVOR:METHOD)
					    (NULL (METHOD-OPTIONS METHOD)))
				 (WHEN PRINTED-SOMETHING
				   (WRITE-CHAR #\SPACE))
				 (PRINT-METHOD-SPEC METHOD METHOD-COMBINATION))))))))))

	  ;; End of substrate, start of real code
	  
	  (WHEN SHOW-INSTANCE-VARIABLES
	    (IF (NOT DETAILED)
		(SHOW-MATCHES SHOW-INSTANCE-VARIABLES "inst var" T
		  (DOLIST (VAR (FLAVOR-LOCAL-INSTANCE-VARIABLES FL))
		    (SHOW-IF-MATCH VAR)))
		(LET ((LIST (LOOP FOR VAR IN (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
				  WHEN (MATCH-STRING SHOW-INSTANCE-VARIABLES VAR)
				    COLLECT VAR)))
		  (WHEN LIST
		    (SHOW-TITLE "inst var" (CDR LIST))
		    (WITH-CURRENT-INDENTATION ()
		      (LOOP FOR (VAR . MORE) ON (SORT LIST #'STRING-LESSP) DO
			(PRIN1 VAR)
			(WRITE-CHAR #\SPACE)
			(LET ((DETAILS NIL))
			  (SHOW-INSTANCE-VARIABLE-DETAILS VAR (LIST FL)
			    #'(LAMBDA (FORMAT-STRING FORMAT-ARG)
				(PUSH (LIST FORMAT-STRING FORMAT-ARG) DETAILS)))
			  (WITH-CURRENT-INDENTATION ()
			    ;;--- Seems to be some problem here with the filling putting
			    ;;--- in more newlines than it really needs to.  Don't worry.
			    (FORMAT-TEXTUAL-LIST (NREVERSE DETAILS)
			      #'(LAMBDA (ITEM STREAM)
				  (FORMAT STREAM (FIRST ITEM) (SECOND ITEM)))
			      :FILLED T :SEPARATOR ", "))
			  (WHEN MORE (TERPRI)))))))))

	  (SHOW-MATCHES SHOW-METHODS "method" NIL
	    ;; Collect normal methods
	    (LOOP FOR (GENERIC . METHOD-HOLDERS) IN (FLAVOR-METHOD-TABLE FL) DO
	      (WHEN (MATCH-STRING SHOW-METHODS GENERIC)
		(SHOW-METHODS GENERIC METHOD-HOLDERS)))
	    ;; Collect instance-variable accessors
	    (FLET ((DO-ACCESSORS (TYPE LIST)
		     (LOOP FOR (GENERIC VAR) IN LIST DO
		       (WHEN (MATCH-STRING SHOW-METHODS GENERIC)
			 (LET ((METHOD `(,TYPE ,GENERIC ,FLAVOR-NAME ,VAR)))
			   (ENQUEUE (METHOD)
			     (DW:WITH-OUTPUT-AS-PRESENTATION
				      (:ALLOW-SENSITIVE-INFERIORS NIL
				       :OBJECT METHOD
				       :TYPE (METHOD-PRESENTATION-TYPE METHOD))
			       (PRIN1 (METHOD-GENERIC METHOD))
			       (WRITE-CHAR #\SPACE)
			       (PRINT-METHOD-SPEC METHOD NIL))))))))
	      (DO-ACCESSORS 'READ-INSTANCE-VARIABLE
			    (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL))
	      (DO-ACCESSORS 'WRITE-INSTANCE-VARIABLE
			    (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL))
	      (DO-ACCESSORS 'LOCATE-INSTANCE-VARIABLE
			    (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)))

	    ;; Sort alphabetically by generic, keeping entries for a single generic in
	    ;; order so the PREVIOUS-METHOD field in each element is right.
	    (SETQ MATCHING-ITEMS
		  (STABLE-SORT (NREVERSE MATCHING-ITEMS)
			       #'STRING-LESSP
			       :KEY #'(LAMBDA (ELEMENT)
					(LET ((GENERIC (METHOD-GENERIC (SECOND ELEMENT))))
					  (IF (LISTP GENERIC) (SECOND GENERIC) GENERIC))))))

	  ;; The format here is slightly ugly, but adequate, so I'm going to leave it alone
	  (COND (DETAILED
		 (SHOW-MATCHES SHOW-INITIALIZATIONS "inst var" T
		   (LOOP FOR (VAR VAL)
			     IN (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL) DO
		     (SHOW-IF-MATCH VAR
		       (PRIN1 VAR)
		       (WRITE-STRING "  ")
		       (WRITE VAL :PRETTY ':CODE))))
		 (SHOW-MATCHES SHOW-INITIALIZATIONS "initable inst var" T
		   (LOOP FOR (KWD VAR) IN (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL) DO
		     (IF (STRING-EQUAL KWD VAR)	;Usual case
			 (SHOW-IF-MATCH VAR)
			 (SHOW-IF-MATCH KWD	;Would like to match on both KWD and VAR
			   (FORMAT T "~S  ~S" VAR KWD))))))
		(T
		 ;;--- Really ought to be showing inst vars that are initable by any
		 ;;--- component flavor and are either initable or initialized at this
		 ;;--- flavor.  Humbug.  What to do?
		 (SHOW-MATCHES SHOW-INITIALIZATIONS "initable inst var" T
		   (LOOP FOR (KWD VAR) IN (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
			 WITH INIT = (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
			 AS DEFAULT = (ASSOC VAR INIT) DO
		     (SHOW-IF-MATCH KWD
		       (IF (STRING-EQUAL KWD VAR)	;Usual case
			   (PRIN1 VAR)
			   (FORMAT T "~S  ~S" VAR KWD))
		       (WHEN DEFAULT
			 (WRITE-STRING " (default ")
			 (WRITE (SECOND DEFAULT) :PRETTY ':CODE)
			 (WRITE-STRING ")")))))))
	  (SHOW-MATCHES SHOW-INITIALIZATIONS "allowed init keyword" T
	    (LOOP FOR KWD IN (FLAVOR-INIT-KEYWORDS FL) DO
	      (SHOW-IF-MATCH KWD)))
	  (SHOW-MATCHES SHOW-INITIALIZATIONS "default init" T
	    (LOOP FOR (KWD VAL) ON (FLAVOR-DEFAULT-INIT-PLIST FL) BY 'CDDR DO
	      (SHOW-IF-MATCH KWD
		(PRIN1 KWD)
		(WRITE-CHAR #\SPACE)
		(WRITE VAL :PRETTY ':CODE))))
	  (SHOW-MATCHES SHOW-INITIALIZATIONS "make-instance area keyword" NIL
	    (WHEN (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
	      (SHOW-IF-MATCH (FLAVOR-AREA-KEYWORD FL))))
	  (WHEN DETAILED
	    (SHOW-MATCHES SHOW-INITIALIZATIONS "initialization method" NIL
	      (WHEN (MATCH-STRING SHOW-INITIALIZATIONS 'MAKE-INSTANCE)
		(SHOW-METHODS 'MAKE-INSTANCE))
	      (WHEN (MATCH-STRING SHOW-INITIALIZATIONS ':INIT)
		(SHOW-METHODS ':INIT))
	      (SETQ MATCHING-ITEMS (NREVERSE MATCHING-ITEMS))))

	  (SHOW-MATCHES SHOW-FUNCTIONS "in-flavor function" T
	    (DOLIST (MH (FLAVOR-LOCAL-FUNCTIONS FL))
	      (SHOW-IF-MATCH (METHOD-GENERIC (METHOD-HOLDER-FUNCTION-SPEC MH))
		(DW:WITH-OUTPUT-AS-PRESENTATION (:OBJECT (METHOD-HOLDER-FUNCTION-SPEC MH)
						 :TYPE (METHOD-PRESENTATION-TYPE
							 (METHOD-HOLDER-FUNCTION-SPEC MH))
						 :ALLOW-SENSITIVE-INFERIORS NIL)
		  (PRIN1 (METHOD-GENERIC (METHOD-HOLDER-FUNCTION-SPEC MH))))))))))))

;This function must make the same tests as SHOW-MATCHING-FLAVOR-ATTRIBUTES
(DEFUN FLAVOR-HAS-MATCHING-ATTRIBUTES (FLAVOR-NAME SHOW-INSTANCE-VARIABLES
				       SHOW-METHODS SHOW-INITIALIZATIONS SHOW-FUNCTIONS
				       DETAILED)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (OR (AND SHOW-INSTANCE-VARIABLES
	     (FIND SHOW-INSTANCE-VARIABLES (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
		   :TEST #'MATCH-STRING))
	(AND SHOW-METHODS
	     (OR (FIND SHOW-METHODS (FLAVOR-METHOD-TABLE FL)
		       :TEST #'MATCH-STRING :KEY #'CAR)
		 (FIND SHOW-METHODS (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)
		       :TEST #'MATCH-STRING :KEY #'CAR)
		 (FIND SHOW-METHODS (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)
		       :TEST #'MATCH-STRING :KEY #'CAR)
		 (FIND SHOW-METHODS (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)
		       :TEST #'MATCH-STRING :KEY #'CAR)))

	(AND SHOW-INITIALIZATIONS
	     (OR (AND DETAILED (FIND SHOW-INITIALIZATIONS
				     (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
				     :TEST #'MATCH-STRING :KEY #'FIRST))
		 (FIND SHOW-INITIALIZATIONS (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
		       :TEST #'MATCH-STRING :KEY #'FIRST)
		 (FIND SHOW-INITIALIZATIONS (FLAVOR-INIT-KEYWORDS FL)
		       :TEST #'MATCH-STRING)
		 (LOOP FOR (KWD VAL) ON (FLAVOR-DEFAULT-INIT-PLIST FL) BY 'CDDR
		       THEREIS (MATCH-STRING SHOW-INITIALIZATIONS KWD))
		 (AND (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
		      (MATCH-STRING SHOW-INITIALIZATIONS (FLAVOR-AREA-KEYWORD FL)))
		 (AND DETAILED
		      (MATCH-STRING SHOW-INITIALIZATIONS 'MAKE-INSTANCE)
		      (LOOP FOR MH IN (CDR (ASSOC 'MAKE-INSTANCE (FLAVOR-METHOD-TABLE FL)))
			    THEREIS (NEQ (METHOD-TYPE (METHOD-HOLDER-FUNCTION-SPEC MH))
					 'COMBINED)))
		 (AND DETAILED
		      (MATCH-STRING SHOW-INITIALIZATIONS ':INIT)
		      (LOOP FOR MH IN (CDR (ASSOC ':INIT (FLAVOR-METHOD-TABLE FL)))
			    THEREIS (NEQ (METHOD-TYPE (METHOD-HOLDER-FUNCTION-SPEC MH))
					 'COMBINED)))))
	(AND SHOW-FUNCTIONS
	     (FIND SHOW-FUNCTIONS (FLAVOR-LOCAL-FUNCTIONS FL)
		   :TEST #'MATCH-STRING
		   :KEY #'(LAMBDA (MH) (METHOD-GENERIC (METHOD-HOLDER-FUNCTION-SPEC MH)))))
	)))

(DEFUN MAP-OVER-INSTANCE-VARIABLES (FUNCTION FLAVOR-NAME)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (FLET ((GET-FLAVOR (FL) (IF (SYMBOLP FL) (FIND-FLAVOR FL) FL)))
    (DOLIST (FLAVOR-NAME (IF (CL:LISTP FLAVOR-NAME)
			     FLAVOR-NAME
			     (FLAVOR-ALL-COMPONENTS (GET-FLAVOR FLAVOR-NAME))))
      (LET ((FL (GET-FLAVOR FLAVOR-NAME)))
	(LOOP FOR (KWD VAR) IN (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL) DO
	  (FUNCALL FUNCTION VAR :INITABLE KWD (FLAVOR-NAME FL)))
	(LOOP FOR (GEN VAR) IN (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL) DO
	  (FUNCALL FUNCTION VAR :READABLE GEN (FLAVOR-NAME FL)))
	(LOOP FOR (GEN VAR) IN (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL) DO
	  (FUNCALL FUNCTION VAR :WRITABLE GEN (FLAVOR-NAME FL)))
	(LOOP FOR (GEN VAR) IN (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL) DO
	  (FUNCALL FUNCTION VAR :LOCATABLE GEN (FLAVOR-NAME FL)))))
  NIL))


(DEFUN SHOW-INSTANCE-VARIABLE-DETAILS (VARIABLE FLS PRINT-FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG PRINT-FUNCTION))
  (MAP-OVER-INSTANCE-VARIABLES
    #'(LAMBDA (VAR KIND DATUM IGNORE)
	(WHEN (EQ VAR VARIABLE)
	  (FUNCALL PRINT-FUNCTION
		   (CL:ECASE KIND
		     ((:INITABLE)  "initable with ~S")
		     ((:READABLE)  "readable with ~S")
		     ((:WRITABLE)  "writable with ~S")
		     ((:LOCATABLE) "locatable with ~S"))
		   DATUM)))
    FLS))


;;; More subroutines for showing various flavor attributes

(DEFUN SHOW-FLAVOR-INSTANCE-VARIABLES-ALPHABETICALLY
       (FLAVOR-NAME &OPTIONAL (MATCH MATCH-ANYTHING-STRING) (DETAILED NIL) (LOCALLY NIL))
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (UNLESS (OR LOCALLY (FLAVOR-COMPONENTS-COMPOSED FL))
      (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL))
    (LET ((VARS (SORT (DELETE MATCH (COPY-LIST (IF LOCALLY
						   (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
						   (FLAVOR-ALL-INSTANCE-VARIABLES FL)))
			      :TEST-NOT #'MATCH-STRING)
		      #'STRING-LESSP)))
      (COND ((NULL VARS)
	     (NO-MATCH-FOUND (IF LOCALLY "local instance variables" "instance variables")
			     MATCH))
	    (DETAILED
	     ;; Tabular format won't work here because there are too many columns
	     ;; and the matrix is usually too sparse
	     (LOOP FOR VARIABLE IN VARS
		   WITH FLS = (MAPCAR #'FIND-FLAVOR (FLAVOR-ALL-COMPONENTS FL)) DO
	       (WRITE-STRING "  ")
	       (PRIN1 VARIABLE)
	       (WRITE-CHAR #\SPACE)
	       (WITH-CURRENT-INDENTATION ()
		 (FORMATTING-TEXTUAL-LIST (*STANDARD-OUTPUT* :FILLED T)
		   (SHOW-INSTANCE-VARIABLE-DETAILS VARIABLE FLS
						   #'(LAMBDA (FORMAT-STRING FORMAT-ARG)
						       (FORMATTING-TEXTUAL-LIST-ELEMENT ()
							 (FORMAT T FORMAT-STRING
								 FORMAT-ARG))))))
	       (TERPRI)))
	    (T (FORMAT-ITEM-LIST VARS))))))

(DEFUN SHOW-FLAVOR-METHODS-ALPHABETICALLY
       (FLAVOR-NAME &OPTIONAL (MATCH MATCH-ANYTHING-STRING) (LOCALLY NIL))
  (LET ((ALIST (FLET ((KEY (ASSOC)
			(LET ((GENERIC (GENERIC-FUNCTION-NAME (CAR ASSOC))))
			  (IF (LISTP GENERIC) (SECOND GENERIC) GENERIC))))
		 (SORT (DELETE-IF #'(LAMBDA (ASSOC)
				      (LOOP FOR METHOD IN (CDDR ASSOC)
					    ALWAYS (EQ (METHOD-TYPE METHOD) 'COMBINED)))
				  (DELETE MATCH (IF LOCALLY
						    (COLLECT-METHODS FLAVOR-NAME
						      :COMPONENTS (LIST FLAVOR-NAME)
						      :ERROR-P NIL)
						    (COLLECT-METHODS FLAVOR-NAME
						      :ERROR-P NIL))
					  :TEST-NOT #'MATCH-STRING :KEY #'KEY))
		       #'STRING-LESSP :KEY #'KEY))))
    (IF (NULL ALIST)
	(NO-MATCH-FOUND (IF LOCALLY
			    '("local methods for generic functions that" "local methods")
			    '("methods for generic functions that" "methods"))
			MATCH)
	(LOOP FOR (GENERIC METHOD-COMBINATION . METHODS) IN ALIST DO
	  (WRITE-STRING "  ")
	  (PRESENT (GENERIC-FUNCTION-NAME GENERIC) 'GENERIC-FUNCTION-NAME)
	  (MULTIPLE-VALUE-SETQ (NIL NIL METHODS)
	    (COMBINE-METHODS (GENERIC-FUNCTION-NAME GENERIC) FLAVOR-NAME
			     METHOD-COMBINATION METHODS :ERROR-P NIL))
	  (FORMAT T " method~P: " (LENGTH METHODS))
	  (WITH-CURRENT-INDENTATION ()
	    (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "" METHOD-COMBINATION METHODS))
	  (TERPRI)))))

(DEFUN SHOW-FLAVOR-METHODS-WHICH-USE-INSTANCE-VARIABLE
       (IV-NAME FLAVOR-NAME &KEY INCLUDE-COMPONENTS (MATCHING MATCH-ANYTHING-STRING))
  (LET* ((FLAVOR (FIND-FLAVOR FLAVOR-NAME))
	 (COMPONENTS
	   (COND ((EQ FLAVOR-NAME :ALL) :ALL)
		 ((NULL INCLUDE-COMPONENTS) (LIST FLAVOR-NAME))
		 ((FLAVOR-COMPONENTS-COMPOSED FLAVOR) (FLAVOR-ALL-COMPONENTS FLAVOR))
		 (T (COMPOSE-FLAVOR-COMPONENTS FLAVOR-NAME))))
	 (FOUND-ONE NIL))
    (SI:MAP-OVER-CALLERS
      IV-NAME
      (LAMBDA (CALLER-NAME HOW)
	(IGNORE HOW)
	(WHEN (AND (LISTP CALLER-NAME)
		   (MEMBER (FIRST CALLER-NAME) FLAVOR:*FDEFINABLE-METHOD-TYPES*)
		   (OR (EQ COMPONENTS :ALL)
		       (MEMBER (THIRD CALLER-NAME) COMPONENTS))
		   (MATCH-STRING MATCHING (SECOND CALLER-NAME)))
	  (SETQ FOUND-ONE T)
	  (FRESH-LINE)
	  (DW:WITH-OUTPUT-AS-PRESENTATION (:OBJECT CALLER-NAME
					   :TYPE (METHOD-PRESENTATION-TYPE CALLER-NAME)
					   :ALLOW-SENSITIVE-INFERIORS NIL)
	    (PRIN1 CALLER-NAME))))
	:CALLED-HOW ':INSTANCE-VARIABLE)
    (WHEN (NULL FOUND-ONE)
      (FORMAT T "~&There are no methods for ~S which use ~S" FLAVOR-NAME IV-NAME))))

(DEFUN SHOW-FLAVOR-INITIALIZATIONS-ALPHABETICALLY
       (FLAVOR-NAME &OPTIONAL (MATCH MATCH-ANYTHING-STRING) (DETAILED NIL) (LOCALLY NIL))
  (LET* ((FL (FIND-FLAVOR FLAVOR-NAME))
	 (GLOBALLY (NOT LOCALLY))
	 (MATCHED NIL)
	 (REQUIRED (IF LOCALLY (FLAVOR-REQUIRED-INIT-KEYWORDS FL)
		       (FLAVOR-ALL-REQUIRED-KEYWORDS FL)))
	 (*PRINT-PRETTY* ':CODE))	;for printing initialization forms
    (MULTIPLE-VALUE-BIND (INIT-VARIABLES INIT-KEYWORDS OTHER-INIT-KEYWORDS)
	(COLLECT-FLAVOR-INITIALIZATIONS FLAVOR-NAME MATCH LOCALLY)

      ;; Check whether something will be printed
      (WHEN (OR (AND DETAILED INIT-VARIABLES) INIT-KEYWORDS OTHER-INIT-KEYWORDS)
	(SETQ MATCHED T))

      ;; Show area initialization stuff
      (WHEN GLOBALLY				;too difficult to find KEYWORD locally
	(LET ((KEYWORD (FLAVOR-AREA-KEYWORD FL))
	      (AREA (FLAVOR-INSTANCE-AREA FL)))
	  (WHEN (NUMBERP AREA)
	    (SETQ AREA (AREA-NAME AREA)))
	  (WHEN (MATCH-STRING MATCH KEYWORD)
	    (SETQ MATCHED T)
	    (FORMAT T "~2@TInstances of ~S are created in ~:[the default area~;area ~:*~S~]~@
		     ~2@TAnother area can be specified with the keyword ~S~%"
		    FLAVOR-NAME AREA KEYWORD))))

      ;; Sort the lists and print them out
      (PRINT-FLAVOR-INITIALIZATIONS
	(IF DETAILED
	    "Initialization keyword~P that initialize~:*~[~1;s an~:;~] instance variable~:P"
	    "Initialization keyword~P")
	(IF DETAILED
	    INIT-KEYWORDS
	    (APPEND INIT-KEYWORDS OTHER-INIT-KEYWORDS))
	REQUIRED DETAILED)
      (WHEN DETAILED
	;; Show variables that are initialized unconditionally
	(PRINT-FLAVOR-INITIALIZATIONS "Instance variable initialization~P" INIT-VARIABLES
				      REQUIRED DETAILED)
	;; Show other init keywords in a separate alphabetized list
	(PRINT-FLAVOR-INITIALIZATIONS
	  "Initialization keyword~P provided by ~:*~[~1;a ~]method~:P"
	  OTHER-INIT-KEYWORDS REQUIRED DETAILED)))

   (WHEN (IF LOCALLY (GETF (FLAVOR-DEFAULT-INIT-PLIST FL) ':ALLOW-OTHER-KEYS)
	     (FLAVOR-ALL-ALLOW-OTHER-KEYS FL))
     (WHEN (MATCH-STRING MATCH ':ALLOW-OTHER-KEYS)
       (SETQ MATCHED T)
       (FORMAT T "~2@T:ALLOW-OTHER-KEYS T specified, so any init keyword is allowed.~%")))

   ;; Show MAKE-INSTANCE and :INIT methods
   (WHEN DETAILED
     (LET ((ALIST (NCONC (AND (MATCH-STRING MATCH 'MAKE-INSTANCE)
			      (COLLECT-METHODS FLAVOR-NAME :GENERIC 'MAKE-INSTANCE
					       :COMPONENTS (AND LOCALLY (LIST FLAVOR-NAME))
					       :ERROR-P NIL))
			 (AND (MATCH-STRING MATCH ':INIT)
			      (COLLECT-METHODS FLAVOR-NAME :GENERIC ':INIT
					       :COMPONENTS (AND LOCALLY (LIST FLAVOR-NAME))
					       :ERROR-P NIL)))))
       ;; Strip combined methods put in by COLLECT-METHODS
       (DOLIST (ELEM ALIST)
	 (SETF (CDDR ELEM) (DELETE 'COMBINED (CDDR ELEM) :KEY #'METHOD-TYPE)))
       (SETQ ALIST (DELETE NIL ALIST :KEY #'CDDR))
       ;; If anything is left, print it
       (WHEN ALIST
	 (SETQ MATCHED T)
	 (FORMAT T "~2@TInitialization method~P:~%"
		 (LOOP FOR ELEM IN ALIST
		       AS (GENERIC METHOD-COMBINATION . METHODS) = ELEM
		       DO (MULTIPLE-VALUE-SETQ (NIL NIL METHODS)
			    (COMBINE-METHODS (GENERIC-FUNCTION-NAME GENERIC) FLAVOR-NAME
					     METHOD-COMBINATION METHODS :ERROR-P NIL))
			  (SETF (CDDR ELEM) METHODS)
		       SUM (LIST-LENGTH METHODS)))
	 (LOOP FOR (GENERIC METHOD-COMBINATION . METHODS) IN ALIST DO
	   (WRITE-STRING "    ")
	   (PRESENT (GENERIC-FUNCTION-NAME GENERIC) 'GENERIC-FUNCTION-NAME)
	   (FORMAT T " method~P: " (LIST-LENGTH METHODS))
	   (WITH-CURRENT-INDENTATION ()
	     (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "" METHOD-COMBINATION METHODS))
	   (TERPRI)))))
   (UNLESS MATCHED
     (NO-MATCH-FOUND (IF LOCALLY "local initializations" "initializations") MATCH))))
;; Returns three lists: initialized-variables, variable-init-keywords, and other-init-keywords
;; All three lists' items have the form (keyword-or-nil variable-or-nil {default-value})
(DEFUN COLLECT-FLAVOR-INITIALIZATIONS (FLAVOR-NAME &OPTIONAL (MATCH MATCH-ANYTHING-STRING)
							     (LOCALLY NIL))
  (DECLARE (VALUES INIT-VARIABLES INIT-KEYWORDS OTHER-INIT-KEYWORDS))
  (LET* ((FL (FIND-FLAVOR FLAVOR-NAME))
	 (GLOBALLY (NOT LOCALLY))
	 (INIT-KEYWORDS NIL)	;List of (init-keyword variable-name [default-init-form])
	 (INIT-VARIABLES NIL)	;List of (nil variable-name [default-init-form])
	 (OTHER-INIT-KEYWORDS NIL))	;List of (init-keyword nil [default-init-form])
    (UNLESS (OR LOCALLY (FLAVOR-INITIALIZATIONS-COMPOSED FL))
      (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ERROR-P NIL))

    ;; Collect non-instance-variable initializations into OTHER-INIT-KEYWORDS
    (DOLIST (KEYWORD (IF LOCALLY (FLAVOR-INIT-KEYWORDS FL)
			 (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL)))
      (WHEN (MATCH-STRING MATCH KEYWORD)
	(STACK-LET ((KEYWORDS (LIST KEYWORD)))
	  (MULTIPLE-VALUE-BIND (FORM-P FORM)
	      (GET-PROPERTIES (IF LOCALLY (FLAVOR-DEFAULT-INIT-PLIST FL)
				  (FLAVOR-ALL-OTHER-DEFAULT-INIT-FORMS FL)) KEYWORDS)
	    (MULTIPLE-VALUE-BIND (VALUE-P VALUE)
		(GET-PROPERTIES (AND GLOBALLY (FLAVOR-ALL-OTHER-DEFAULT-INIT-CONSTANTS FL))
				KEYWORDS)
	      (PUSH `(,KEYWORD NIL 
		      ,@(COND (FORM-P (LIST FORM))
			      (VALUE-P (LIST (QUOTE-UNLESS-CONSTANT VALUE)))))
		    OTHER-INIT-KEYWORDS))))))

    ;; Collect instance variable initializations into INIT-KEYWORDS and INIT-VARIABLES
    (IF LOCALLY
	(LOOP FOR VAR IN (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
	      AS KEYWORD = (FIRST (FIND VAR (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
					:KEY #'SECOND))
	      AS INIT = (OR (ASSOC VAR (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL))
			    (LOOP FOR L ON (FLAVOR-DEFAULT-INIT-PLIST FL) BY 'CDDR DO
			      (WHEN (EQ (CAR L) KEYWORD) (RETURN L)))) DO
	  (IF KEYWORD
	      (WHEN (OR (MATCH-STRING MATCH KEYWORD) (MATCH-STRING MATCH VAR))
		(PUSH `(,KEYWORD ,VAR ,@(AND INIT (LIST (SECOND INIT))))
		       INIT-KEYWORDS))
	      (WHEN (AND INIT (MATCH-STRING MATCH VAR))
		(PUSH `(NIL ,VAR ,(SECOND INIT))
		      INIT-VARIABLES))))
	;; GLOBALLY
	(LOOP FOR VAR IN (FLAVOR-ALL-INSTANCE-VARIABLES FL)
	      FOR POS FROM 1
	      AS CELL = (%MAKE-POINTER-OFFSET DTP-LOCATIVE (FLAVOR-TEMPLATE-INSTANCE FL) POS)
	      AS KEYWORD = (FIRST (FIND POS (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL)
					:KEY #'SECOND))
	      AS INIT = (OR (FIND POS (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS FL)
				  :KEY #'SECOND)
			    (LOCATION-BOUNDP CELL)) DO
	  (IF KEYWORD
	      (WHEN (OR (MATCH-STRING MATCH KEYWORD) (MATCH-STRING MATCH VAR))
		(PUSH `(,KEYWORD ,VAR ,@(IF (LISTP INIT) INIT
					    (LIST (QUOTE-UNLESS-CONSTANT
						    (LOCATION-CONTENTS CELL)))))
		       INIT-KEYWORDS))
	      (WHEN (AND INIT (MATCH-STRING MATCH VAR))
		(PUSH `(NIL ,VAR ,@(IF (LISTP INIT) INIT
				       (LIST (QUOTE-UNLESS-CONSTANT
					       (LOCATION-CONTENTS CELL)))))
		      INIT-VARIABLES)))))
    (VALUES INIT-VARIABLES INIT-KEYWORDS OTHER-INIT-KEYWORDS)))
;; Print a list of the form (keyword-or-nil variable-or-nil {default-value})
;; Heading is (format t description (length list))
(DEFUN PRINT-FLAVOR-INITIALIZATIONS (DESCRIPTION LIST REQUIRED-INIT-KEYWORDS DETAILED)
  (UNLESS (NULL LIST)
    (FORMAT T "~2@T~@?:~%" DESCRIPTION (LENGTH LIST))
    (SETQ LIST (SORT LIST #'STRING-LESSP :KEY #'(LAMBDA (A) (OR (FIRST A) (SECOND A)))))
    (COND (DETAILED
	   (LOOP FOR (KEYWORD VAR . INIT) IN LIST DO
	     (FORMAT T "~4@T")
	     (WHEN KEYWORD (FORMAT T "~S" KEYWORD))
	     (WHEN (AND KEYWORD VAR) (FORMAT T "  "))
	     (WHEN VAR (FORMAT T "~S" VAR))
	     (COND (INIT
		    (WHEN KEYWORD (WRITE-CHAR #\,))
		    ;; Maybe there isn't enough space left on the line?  Do a
		    ;; stupid heuristic to "make sure" there is enough (3/5 the width).
		    ;;--- Really should be letting GPRINT decide.
		    (UNLESS (ATOM (CAR INIT))
		      (UNLESS ( (SEND *STANDARD-OUTPUT* :READ-CURSORPOS)
				 (FLOOR (OR (SEND-IF-HANDLES *STANDARD-OUTPUT* :INSIDE-SIZE)
					    95)
					5/2))
			(FORMAT T "~%~5@T")))
		    (FORMAT T (IF KEYWORD " default is ~S~%" "  ~S~%") (CAR INIT)))
		   (T
		    (WHEN (MEMBER KEYWORD REQUIRED-INIT-KEYWORDS)
		      (WRITE-STRING " [required]"))
		    (TERPRI)))))
	    (T
	     (WRITE-STRING "    ")
	     ;;--- GPRINT / FORMAT-TEXTUAL-LIST interaction issue again here
	     (FORMAT-TEXTUAL-LIST LIST
	       #'(LAMBDA (ITEM STREAM)
		   (LET ((WORD (OR (FIRST ITEM) (SECOND ITEM)))
			 (INIT (CDDR ITEM)))
		     ;; Not detailed, so print either keyword or variable, but not both
		     (PRIN1 WORD STREAM)
		     (WHEN INIT
		       (FORMAT STREAM " default is ~S" (CAR INIT)))
		     (WHEN (MEMBER (FIRST ITEM) REQUIRED-INIT-KEYWORDS)
		       (WRITE-STRING " [required]" STREAM))))
	       :FILLED T :AFTER-LINE-BREAK "    ")
	     (TERPRI)))))

(DEFUN SHOW-FLAVOR-FUNCTIONS-ALPHABETICALLY
       (FLAVOR-NAME &OPTIONAL (MATCH MATCH-ANYTHING-STRING) (LOCALLY NIL))
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (UNLESS (OR LOCALLY (FLAVOR-COMPONENTS-COMPOSED FL))
      (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL))
    (LET ((LIST (IF LOCALLY
		    ;; Fake FLAVOR-ALL-LOCAL-FUNCTIONS-without-inheritance
		    (LOOP FOR MH IN (FLAVOR-LOCAL-FUNCTIONS FL)
			  AS FSPEC = (METHOD-HOLDER-FUNCTION-SPEC MH)
			  WHEN (AND (METHOD-DEFINED-P MH)
				    (MATCH-STRING MATCH (METHOD-GENERIC FSPEC)))
			    COLLECT (LIST (METHOD-GENERIC FSPEC) FSPEC))
		    (LOOP FOR (NAME DEF FSPEC) IN (FLAVOR-ALL-LOCAL-FUNCTIONS FL)
			  WHEN (MATCH-STRING MATCH NAME)
			    COLLECT (LIST NAME FSPEC)))))
      (IF LIST
	  (FORMAT-ITEM-LIST (SORT LIST #'STRING-LESSP :KEY #'FIRST)
			    :PRINTER #'(LAMBDA (ITEM STREAM)
					 (DW:WITH-OUTPUT-AS-PRESENTATION
					       (:STREAM STREAM
						:TYPE (METHOD-PRESENTATION-TYPE
							(SECOND ITEM))
						:OBJECT (SECOND ITEM)
						:ALLOW-SENSITIVE-INFERIORS NIL)
					   (PRIN1 (FIRST ITEM) STREAM))))
	  (NO-MATCH-FOUND (IF LOCALLY "local in-flavor functions" "in-flavor functions")
			  MATCH)))))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-DEPENDENTS :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "flavor name"	;default prompt is "a flavor name", which looks stupid
				;this is really a bug in cp/presentation-type interface
	:CONFIRM T		;makes the flavor examiner program framework work right
	:DOCUMENTATION "The name of a flavor whose dependent flavors are of interest.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T
	:PROMPT "dependent flavors" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show dependent flavors"))
       (DUPLICATES 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Show duplicate occurrences and non-matching flavors, too.")
       (BRIEF 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Don't show the structure, just the names.")
       (LEVELS '((TOKEN-OR-TYPE (:ALL) ((INTEGER 1 *)))) :DEFAULT ':ALL :CONFIRM T
	:PROMPT "number" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION "Number of levels of recursive dependency to show")
       (INSTANCE-VARIABLES MATCH-STRING-TYPE
	:DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show flavors with instance variables"))
       (METHODS MATCH-STRING-TYPE
	:DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show flavors with methods for generics"))
       (INITIALIZATIONS MATCH-STRING-TYPE
	:DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show flavors with initializations"))
       (FUNCTIONS MATCH-STRING-TYPE
	:DEFAULT NIL :MENTIONED-DEFAULT MATCH-ANYTHING-STRING
	:PROMPT "matching" :DISPLAY-DEFAULT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show flavors with in-flavor functions"))
       (DETAILED 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
	:DOCUMENTATION
	  "Show additional detail if showing instance variables or initializations"))

    ;; Have to show the structure if we're going to show anything else
    (WHEN (OR INSTANCE-VARIABLES METHODS INITIALIZATIONS FUNCTIONS)
      (SETQ BRIEF NIL))
  
    ;; If not showing structure, just list the names in tabular form, alphabetized
    ;; No attempt here to distinguish :required-flavor dependents from the regular kind
    (WHEN BRIEF
      (LET ((FLAVORS (DELETE MATCH (FLAVOR-ALL-DEPENDENTS (FIND-FLAVOR FLAVOR-NAME))
			     :TEST-NOT #'MATCH-STRING)))
	(UNLESS (NULL FLAVORS)
	  (FORMAT-ITEM-LIST (SORT FLAVORS #'STRING-LESSP) :PRESENTATION-TYPE 'FLAVOR-NAME)
	  (RETURN-FROM COM-SHOW-FLAVOR-DEPENDENTS (VALUES)))))

    ;; Prune the tree to just the interesting flavors, if desired
    (LET ((INTERESTING NIL))
      (WHEN (OR (NOT (EQUAL MATCH MATCH-ANYTHING-STRING))
		(AND (NOT DUPLICATES)
		     (OR INSTANCE-VARIABLES METHODS INITIALIZATIONS FUNCTIONS)))
	;; Keep track of duplicates so no infinite recursion
	(LET ((TRAIL NIL))
	  ;; Subroutine to pass down one branch of the tree
	  (LABELS ((DO-FLAVOR (FLAVOR-NAME COMPONENTS DEPTH)
		     (WHEN (AND (MATCH-STRING MATCH FLAVOR-NAME)
				(OR DUPLICATES
				    (AND (NOT (MEMBER FLAVOR-NAME TRAIL))
					 (OR (NOT (OR INSTANCE-VARIABLES METHODS
						      INITIALIZATIONS INITIALIZATIONS))
					     (FLAVOR-HAS-MATCHING-ATTRIBUTES
					       FLAVOR-NAME INSTANCE-VARIABLES METHODS
					       INITIALIZATIONS FUNCTIONS DETAILED)))))
		       ;; This flavor is going to be printed out
		       (PUSHNEW FLAVOR-NAME INTERESTING)
		       (DOLIST (COMPONENT COMPONENTS)
			 (PUSHNEW COMPONENT INTERESTING)))
		     ;; Recurse if this is not a duplicate
		     (UNLESS (MEMBER FLAVOR-NAME TRAIL)
		       (PUSH FLAVOR-NAME TRAIL)
		       (INCF DEPTH)
		       (STACK-LET ((COMPONENTS (CONS FLAVOR-NAME COMPONENTS)))
			 (LET ((FL (FIND-FLAVOR FLAVOR-NAME NIL)))
			   (WHEN (AND FL (OR (EQ LEVELS ':ALL) ( DEPTH LEVELS)))
			     (DOLIST (DEPENDENT
				       (SORT (COPY-LIST (FLAVOR-LOCAL-DEPENDENTS FL))
					     #'STRING-LESSP))
			       (DO-FLAVOR DEPENDENT COMPONENTS DEPTH))))))))
	(DO-FLAVOR FLAVOR-NAME NIL 0)))
      (UNLESS INTERESTING
	(APPLY #'NO-MATCH-FOUND NIL
	       (DELETE NIL (LIST MATCH INSTANCE-VARIABLES METHODS INITIALIZATIONS FUNCTIONS)))
	(RETURN-FROM COM-SHOW-FLAVOR-DEPENDENTS (VALUES))))
  
      ;; Keep track of duplicates so no infinite recursion
      (LET ((TRAIL NIL))
	;; Subroutine to pass down one branch of the tree
	(LABELS ((DO-FLAVOR (FLAVOR-NAME DEPTH TAG)
		   (WHEN (AND (OR (NOT INTERESTING) (MEMBER FLAVOR-NAME INTERESTING))
			      (OR DUPLICATES (NOT (MEMBER FLAVOR-NAME TRAIL))))
		     ;; We're going to print this flavor
		     (DOTIMES (I (* DEPTH 2)) (WRITE-CHAR #\SPACE))
		     (COND ((MEMBER FLAVOR-NAME TRAIL)
			    ;; This is a duplicate
			    (WRITE-CHAR #\[)
			    (PRESENT FLAVOR-NAME 'FLAVOR-NAME)
			    (WRITE-STRING "] ")
			    (WHEN TAG (WRITE-STRING TAG))
			    (TERPRI))
			   (T
			    ;; This is for real, so recurse
			    (PRESENT FLAVOR-NAME 'FLAVOR-NAME)
			    (WHEN TAG (WRITE-STRING TAG))
			    (PUSH FLAVOR-NAME TRAIL)
			    (INCF DEPTH)
			    (LET ((FL (FIND-FLAVOR FLAVOR-NAME NIL)))
			      (COND ((NULL FL)
				     (WRITE-STRING "  (undefined flavor)")
				     (TERPRI))
				    (T
				     (SHOW-MATCHING-FLAVOR-ATTRIBUTES FLAVOR-NAME
				       INSTANCE-VARIABLES METHODS INITIALIZATIONS FUNCTIONS
				       (FLAVOR-ALL-COMPONENTS FL) DETAILED)
				     (COND ((OR (EQ LEVELS ':ALL) ( DEPTH LEVELS))
					    (TERPRI)
					    (DOLIST (DEPENDENT
						      (SORT (COPY-LIST
							      (FLAVOR-LOCAL-DEPENDENTS FL))
							    #'STRING-LESSP))
					      (DO-FLAVOR DEPENDENT DEPTH
						(LET ((FL (FIND-FLAVOR DEPENDENT NIL)))
						  (AND FL
						       (MEMBER FLAVOR-NAME
							       (FLAVOR-REQUIRED-FLAVORS FL))
						       "  [due to :REQUIRED-FLAVORS]")))))
					   ((SET-DIFFERENCE (FLAVOR-LOCAL-DEPENDENTS FL)
							    TRAIL)
					    (WRITE-STRING " ...")
					    (TERPRI))
					   (T (TERPRI)))))))))))
	  (DO-FLAVOR FLAVOR-NAME 0 NIL)))))

;;;; Show the differences between two flavors

;;; I found an earlier version of this helpful in debugging.  Whether this
;;; will be useful to users is an open question.  It's here so it can be tried.
(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-DIFFERENCES :COMMAND-TABLE "Flavors")
      ((FLAVOR-NAME-1 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "one flavor name"
	:CONFIRM T
	:DOCUMENTATION "The name of a flavor to be compared with another flavor.")
       (FLAVOR-NAME-2 'FLAVOR-NAME
	:DISPLAY-DEFAULT NIL
	:PROMPT "another flavor name"
	:CONFIRM T
	:DOCUMENTATION "The name of a flavor to be compared with the previous flavor.")
       &KEY
       (MATCH MATCH-STRING-TYPE :DEFAULT MATCH-ANYTHING-STRING :CONFIRM T :PROMPT NIL
	:DOCUMENTATION (MATCH-DOCUMENTATION "Show differences for generic functions")))

  ;; Silliness check
  (WHEN (EQ FLAVOR-NAME-1 FLAVOR-NAME-2)
    (FORMAT T "You must specify two different flavors.")
    (RETURN-FROM COM-SHOW-FLAVOR-DIFFERENCES (VALUES)))

  ;; Find the flavors' components and their intersection
  (LET* ((FLAVOR-1 (FIND-FLAVOR FLAVOR-NAME-1))
	 (FLAVOR-2 (FIND-FLAVOR FLAVOR-NAME-2))
	 (COMPONENTS-1 (IF (FLAVOR-COMPONENTS-COMPOSED FLAVOR-1)
			   (FLAVOR-ALL-COMPONENTS FLAVOR-1)
			   (COMPOSE-FLAVOR-COMPONENTS FLAVOR-NAME-1)))
	 (COMPONENTS-2 (IF (FLAVOR-COMPONENTS-COMPOSED FLAVOR-2)
			   (FLAVOR-ALL-COMPONENTS FLAVOR-2)
			   (COMPOSE-FLAVOR-COMPONENTS FLAVOR-NAME-2)))
	 (INTERSECTION (INTERSECTION COMPONENTS-1 COMPONENTS-2))
	 (DIFFERENT-1 (SET-DIFFERENCE COMPONENTS-1 INTERSECTION))
	 (DIFFERENT-2 (SET-DIFFERENCE COMPONENTS-2 INTERSECTION)))

    ;; Show differences in components.
    ;; I don't think SHOW-LIST-DIFFERENCES is the best way to present this.
    ;; It's intentional that these are in flavor combination order rather than alphabetical.
    ;; Using ~{~<~%~4@T~2:;~S~>~^, ~} disables mouse-sensitivity, so use something better.
    (WHEN INTERSECTION
      (FORMAT T "~&~S and ~S have common component~P:"
	      FLAVOR-NAME-1 FLAVOR-NAME-2 (LENGTH INTERSECTION))
      (FORMAT-ITEM-LIST INTERSECTION :PRESENTATION-TYPE 'FLAVOR-NAME))
    (WHEN (CDR DIFFERENT-1)			;Always starts with FLAVOR-NAME-1
      (FORMAT T "~&~S has~:[ other~] component~P:"
	      FLAVOR-NAME-1 (NULL INTERSECTION) (LENGTH (CDR DIFFERENT-1)))
      (FORMAT-ITEM-LIST (CDR DIFFERENT-1) :PRESENTATION-TYPE 'FLAVOR-NAME))
    (WHEN (CDR DIFFERENT-2)			;Always starts with FLAVOR-NAME-2
      (FORMAT T "~&~S has~:[ other~] component~P:"
	      FLAVOR-NAME-2 (NULL INTERSECTION) (LENGTH (CDR DIFFERENT-2)))
      (FORMAT-ITEM-LIST (CDR DIFFERENT-2) :PRESENTATION-TYPE 'FLAVOR-NAME))

    ;; Note flavors that are common components but not in the same order
    (SETQ INTERSECTION (SORT (COPY-LIST INTERSECTION) #'<
			     :KEY #'(LAMBDA (FLAVOR) (POSITION FLAVOR COMPONENTS-1))))
    (LET ((LOSERS NIL))
      (LOOP FOR (FLAVOR1 FLAVOR2) ON INTERSECTION UNTIL (NULL FLAVOR2) DO
	(UNLESS (MEMBER FLAVOR2 (MEMBER FLAVOR1 COMPONENTS-2))
	  (PUSHNEW FLAVOR1 LOSERS)
	  (PUSH FLAVOR2 LOSERS)))
      (WHEN LOSERS
	(LET* ((ALIST (LOOP FOR FLAVOR IN INTERSECTION
			    COLLECT (REMOVE-DUPLICATES
				      (APPEND (MEMBER FLAVOR COMPONENTS-1)
					      (CDR (MEMBER FLAVOR COMPONENTS-2)))
				      :FROM-END T)))
	       (GRAPH (LOOP FOR (FLAVOR . SUCCESSORS) IN ALIST
			    WHEN (MEMBER FLAVOR LOSERS)
			      COLLECT (CONS FLAVOR SUCCESSORS)))
	       (CYCLES (FIND-ALL-CYCLES GRAPH (FIRST LOSERS) ALIST NIL NIL))
	       (CULL (REDUCE #'INTERSECTION CYCLES)))
	  (IF CULL
	      (SETQ CULL (LIST (FIRST CULL)))
	      (DOLIST (CYCLE CYCLES)
		(UNLESS (INTERSECTION CYCLE CULL)
		  (PUSH (FIRST CYCLE) CULL))))
	  (LABELS ((SHOW-CYCLE (CYCLE FLAVOR-NAME COMPONENTS)
		     (FORMAT T "~&~S has components in order " FLAVOR-NAME)
		     (FORMAT-TEXTUAL-LIST (SORT (COPY-LIST CYCLE) #'<
						:KEY #'(LAMBDA (FLAVOR)
							 (POSITION FLAVOR COMPONENTS)))
					  #'PRESENT-FLAVOR-NAME
					  :FILLED T :AFTER-LINE-BREAK "    "))
		   (PRESENT-FLAVOR-NAME (FLAVOR-NAME STREAM)
		     (PRESENT FLAVOR-NAME 'FLAVOR-NAME :STREAM STREAM)))
	    (DOLIST (CYCLE CYCLES)
	      (SHOW-CYCLE CYCLE FLAVOR-NAME-1 COMPONENTS-1)
	      (SHOW-CYCLE CYCLE FLAVOR-NAME-2 COMPONENTS-2)))
	  (SETQ INTERSECTION (SET-DIFFERENCE INTERSECTION CULL)
		DIFFERENT-1 (SET-DIFFERENCE COMPONENTS-1 INTERSECTION)
		DIFFERENT-2 (SET-DIFFERENCE COMPONENTS-2 INTERSECTION)))))

    ;; If one flavor includes the other, results are less confusing if we don't
    ;; optimize out that shared flavor (see SAME below)
    (PUSHNEW FLAVOR-NAME-1 DIFFERENT-1)
    (PUSHNEW FLAVOR-NAME-2 DIFFERENT-2)

    ;; Do FIND-FLAVOR lookups once to save time and make code below more readable
    (LOOP FOR L ON DIFFERENT-1 DO
      (SETF (CAR L) (FIND-FLAVOR (CAR L))))
    (LOOP FOR L ON DIFFERENT-2 DO
      (SETF (CAR L) (FIND-FLAVOR (CAR L))))

    ;; Show differences in methods for operations in common.
    (FLET ((NONTRIVIAL (METHOD-HOLDERS)
	     (NOT (LOOP FOR METHOD-HOLDER IN METHOD-HOLDERS
			ALWAYS (EQ (METHOD-TYPE (METHOD-HOLDER-FUNCTION-SPEC METHOD-HOLDER))
				   'COMBINED)))))

      ;; Now find all generic functions handled by the nonshared components of either flavor
      (LET ((GENERICS
	      (SORT (DELETE-DUPLICATES
		      (NCONC (LOOP FOR F IN DIFFERENT-1
				   NCONC (LOOP FOR (GEN . MHS) IN (FLAVOR-METHOD-TABLE F)
					       WHEN (NONTRIVIAL MHS)
						 COLLECT GEN))
			     (LOOP FOR F IN DIFFERENT-2
				   NCONC (LOOP FOR (GEN . MHS) IN (FLAVOR-METHOD-TABLE F)
					       WHEN (NONTRIVIAL MHS)
						 COLLECT GEN))))
		    #'STRING-LESSP
		    :KEY #'(LAMBDA (GEN) (IF (LISTP GEN) (SECOND GEN) GEN))))
	    (FOUND NIL)
	    (SAME NIL))
	;; Explain each generic where the different methods don't end up shadowed
	(DOLIST (GEN GENERICS)
	  (WHEN (MATCH-STRING MATCH GEN)
	    (MULTIPLE-VALUE-BIND (NIL METHODS-1 MC-1 ERROR-1)
		(COMPOSE-HANDLER GEN FLAVOR-NAME-1)
	      (MULTIPLE-VALUE-BIND (NIL METHODS-2 MC-2 ERROR-2)
		  (COMPOSE-HANDLER GEN FLAVOR-NAME-2)
		(COND ((OR ERROR-1 ERROR-2 (LOOP FOR M IN METHODS-1
						 NEVER (MEMBER M METHODS-2 :TEST #'EQUAL)))
		       (SETQ FOUND T)
		       (FORMAT T "~%Difference in handling of ~S" GEN)
		       (UNLESS (OR ERROR-1 ERROR-2 (EQUAL MC-1 MC-2))
			 (FORMAT T "~%  Method-combination changed from ~S to ~S" MC-1 MC-2))
		       (COND (ERROR-1 (FORMAT T "~%  ~A" ERROR-1))
			     (T
			      (FORMAT T "~%  Method~P of ~S: "
				      (LENGTH METHODS-1) FLAVOR-NAME-1)
			      (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "    "
						      MC-1 METHODS-1)))
		       (COND (ERROR-2 (FORMAT T "~%  ~A" ERROR-2))
			     (T
			      (FORMAT T "~%  Method~P of ~S: "
				      (LENGTH METHODS-2) FLAVOR-NAME-2)
			      (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "    "
						      MC-2 METHODS-2))))
		      ((NOT (AND (EQUAL MC-1 MC-2) (EQUAL METHODS-1 METHODS-2)))
		       (SETQ FOUND T)
		       (FORMAT T "~%Differences in ~S methods from ~S to ~S~%  "
			       GEN FLAVOR-NAME-1 FLAVOR-NAME-2)
		       (UNLESS (EQUAL MC-1 MC-2)
			 (FORMAT T "Method-combination changed from ~S to ~S~%  " MC-1 MC-2))
		       (SHOW-METHOD-LIST-DIFFERENCES METHODS-1 METHODS-2 MC-1))
		      (T (PUSH GEN SAME)))))))
	(WHEN (AND GENERICS (NOT FOUND))
	  (WHEN SAME
	    (LET ((N (LIST-LENGTH SAME)))
	      (FORMAT T "~&~D generic~:P found with no method differences:" N)
	      (WHEN (> N 20) (SETQ SAME (SUBSEQ SAME 0 20)))
	      (FORMAT-ITEM-LIST SAME :PRESENTATION-TYPE '((GENERIC-FUNCTION-NAME)
							  :SHOW-COMPATIBLE-MESSAGE T))
	      (WHEN (> N 20) (FORMAT T "  and ~D others.~%" (- N 20)))))
	  (NON-MATCHING-ITEMS-FOUND GENERICS "differing generic" MATCH))))

    ;; Show conflicting local function names
    (LET ((FUNCTIONS
	    (SORT (DELETE-DUPLICATES
		    (NCONC (LOOP FOR F IN DIFFERENT-1
				 NCONC (LOOP FOR MH IN (FLAVOR-LOCAL-FUNCTIONS F)
					     COLLECT (METHOD-GENERIC
						       (METHOD-HOLDER-FUNCTION-SPEC MH))))
			   (LOOP FOR F IN DIFFERENT-2
				 NCONC (LOOP FOR MH IN (FLAVOR-LOCAL-FUNCTIONS F)
					     COLLECT (METHOD-GENERIC
						       (METHOD-HOLDER-FUNCTION-SPEC MH))))))
		  #'STRING-LESSP))
	  (FOUND NIL)
	  (SAME NIL))
	(LOOP FOR FUNCTION IN FUNCTIONS
	      AS F1 = (THIRD (ASSOC FUNCTION (FLAVOR-ALL-LOCAL-FUNCTIONS FLAVOR-1)))
	      AS F2 = (THIRD (ASSOC FUNCTION (FLAVOR-ALL-LOCAL-FUNCTIONS FLAVOR-2)))
	      DO
	  (COND ((NOT (MATCH-STRING MATCH FUNCTION)))
		((EQUAL F1 F2) (PUSH FUNCTION SAME))
		(T
		 (SETQ FOUND T)
		 (COND ((AND F1 F2)
			(FORMAT T "~&~S and ~S both have local functions named ~S"
				FLAVOR-NAME-1 FLAVOR-NAME-2 FUNCTION))
		       (F1
			(FORMAT T "~&~S has a local function named ~S, ~S does not"
				FLAVOR-NAME-1 FUNCTION FLAVOR-NAME-2))
		       (T
			(FORMAT T "~&~S has a local function named ~S, ~S does not"
				FLAVOR-NAME-2 FUNCTION FLAVOR-NAME-1)))
		 (COND ((NULL F1))
		       ((NEQ (METHOD-FLAVOR F1) FLAVOR-NAME-1)
			(FORMAT T "~% ~S inherits it from ~S"
				FLAVOR-NAME-1 (METHOD-FLAVOR F1)))
		       (F2
			(FORMAT T "~% ~S defines it itself" FLAVOR-NAME-1)))
		 (COND ((NULL F2))
		       ((NEQ (METHOD-FLAVOR F2) FLAVOR-NAME-2)
			(FORMAT T "~% ~S inherits it from ~S"
				FLAVOR-NAME-2 (METHOD-FLAVOR F2)))
		       (F1
			(FORMAT T "~% ~S defines it itself" FLAVOR-NAME-2))))))
	(WHEN (AND FUNCTIONS (NOT FOUND))
	  (WHEN SAME
	    (LET ((N (LIST-LENGTH SAME)))
	      (FORMAT T "~&~D local function~:P found with no differences:" N)
	      (WHEN (> N 20) (SETQ SAME (SUBSEQ SAME 0 20)))
	      (FORMAT-ITEM-LIST SAME)
	      (WHEN (> N 20) (FORMAT T "  and ~D others.~%" (- N 20)))
	      (SETQ FUNCTIONS (SET-DIFFERENCE FUNCTIONS SAME))))
	  (WHEN FUNCTIONS
	    (NON-MATCHING-ITEMS-FOUND FUNCTIONS "differing local function" MATCH))))))

;Show two lists, interleaved with each other, highlighting the differences between them
;ITEM-PRINTER takes two args, this item and previous item, to allow it to abbreviate
(DEFUN SHOW-LIST-DIFFERENCES (LIST1 LIST2
			      &KEY (ITEM-PRINTER #'(LAMBDA (THIS-ITEM LAST-ITEM)
						     (IGNORE LAST-ITEM)
						     (PRIN1 THIS-ITEM)))
				   (FILLED T)
				   (AFTER-LINE-BREAK "  ")
			      &AUX (GROUPS NIL))
  (FLET ((STASH-GROUP (GROUP)			;Defeat named-value-snapshot-continuation
	   (PUSH GROUP GROUPS))
	 (GET-GROUPS () GROUPS))
  (FORMATTING-TEXTUAL-LIST (*STANDARD-OUTPUT* :FILLED FILLED
					      :AFTER-LINE-BREAK AFTER-LINE-BREAK)
    (LOOP WITH L1 = LIST1 AND L2 = LIST2
	  WITH LAST-ITEM = NIL
	  WITH GROUPN = 0
	  WHILE (OR L1 L2) DO
      (MACROLET ((PRINT-ITEM (ITEM &OPTIONAL STRING)
		   (ONCE-ONLY (ITEM)
		     `(PROGN
			(FORMATTING-TEXTUAL-LIST-ELEMENT ()
			  (FUNCALL ITEM-PRINTER ,ITEM LAST-ITEM)
			  ,@(WHEN STRING
			      `((WRITE-STRING ,STRING))))
			(SETQ LAST-ITEM ,ITEM)))))
	(COND ((AND L1 L2 (EQUAL (CAR L1) (CAR L2)))
	       (PRINT-ITEM (CAR L1))
	       (SETQ L1 (CDR L1) L2 (CDR L2)))
	      ((AND (CDR L1) (CDR L2) (EQUAL (CAR L1) (CADR L2)) (EQUAL (CADR L1) (CAR L2)))
	       (PRINT-ITEM (CAR L2))		;Show the new order
	       (PRINT-ITEM (CAR L1) " D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")[swapped]0")
	       (SETQ L1 (CDDR L1) L2 (CDDR L2)))
	      ((AND L1 (OR (NULL L2)
			   (NOT (AND (CDR L2) (EQUAL (CAR L1) (CADR L2)))))
		    ;; See if a whole group was moved
		    ;; Note that we do not have to handle both the "moved later" and
		    ;; "moved earlier" directions (draw a picture if you don't believe me)
		    ;; ((no pictures in comments yet))
		    (LET ((TO (MEMBER (CAR L1) L2 :TEST #'EQUAL)))
		      (UNLESS (EQUAL TO L1)	;Exclude group that reaches end of both lists
			(IF (AND (CDR TO)	;Must have at least two elements
				 (EQUAL (CADR L1) (CADR TO)))
			    ;; Whole group was moved, give it a name for legible reference
			    (LOOP FOR X IN TO WHILE L1
				  WHILE (EQUAL X (CAR L1))
				  COLLECT X INTO GROUP
				  DO (SETQ L1 (CDR L1))
				  FINALLY
				    (STASH-GROUP GROUP)
				    (INCF GROUPN)
				    (FORMATTING-TEXTUAL-LIST-ELEMENT ()
				      (FORMAT T "~'Igroup-~D~ 1[moved0 1later]0" GROUPN))
				    (SETQ LAST-ITEM NIL))
			    ;; Not a group, just report a one-element difference
			    (PRINT-ITEM (CAR L1)
					(COND ((NOT (NULL TO)) " 1[moved0 1later]0")
					      ((NOT (MEMBER (CAR L1) LIST2 :TEST #'EQUAL))
					       " 1[deleted]0")
					      (T " 1[moved0 1earlier]0")))
			    (SETQ L1 (CDR L1)))
			T))))
	      ((LET ((FROM (ASSOC (CAR L2) (GET-GROUPS) :TEST #'EQUAL)))
		 (WHEN FROM
		   (FORMATTING-TEXTUAL-LIST-ELEMENT ()
		     (FORMAT T "~'Igroup-~D~ 1[put0 1here]0"
			     (LIST-LENGTH (MEMBER FROM (GET-GROUPS)))))
		   (SETQ L2 (NTHCDR (LIST-LENGTH FROM) L2))
		   T)))
	      (T
	       ;(AND L2 (OR (NULL L1)
	       ;	    (NOT (AND (CDR L1) (EQUAL (CADR L1) (CAR L2)))))
	       ;is necessarily true
	       (PRINT-ITEM (CAR L2)
			   (IF (MEMBER (CAR L2) LIST1 :TEST #'EQUAL)
			       " 1[put here]0" " 1[added]0"))
	       (SETQ L2 (CDR L2))))))) )
  (LOOP FOR GROUP IN (NREVERSE GROUPS) FOR GROUP-N FROM 1 AS LAST-ITEM = NIL DO
    (FORMAT T "~&~'Igroup-~D~ = " GROUP-N)
    (FORMATTING-TEXTUAL-LIST (*STANDARD-OUTPUT* :FILLED T
						:AFTER-LINE-BREAK "          ")	;Ten spaces
      (DOLIST (ITEM GROUP)
	(FORMATTING-TEXTUAL-LIST-ELEMENT ()
	  (FUNCALL ITEM-PRINTER ITEM LAST-ITEM))
	(SETQ LAST-ITEM ITEM)))))

;Version of SHOW-LIST-DIFFERENCES with an item-printer specialized for methods
(DEFUN SHOW-METHOD-LIST-DIFFERENCES (LIST1 LIST2 METHOD-COMBINATION &REST OPTIONS)
  (DECLARE (ARGLIST LIST1 LIST2 METHOD-COMBINATION &KEY (FILLED T) (AFTER-LINE-BREAK "  ")))
  (APPLY #'SHOW-LIST-DIFFERENCES LIST1 LIST2
	 :ITEM-PRINTER #'(LAMBDA (METHOD LAST-METHOD)
			   (PRINT-METHOD-SPEC-LIST-ELEMENT METHOD LAST-METHOD
							   METHOD-COMBINATION
							   *STANDARD-OUTPUT*))
	 OPTIONS))

;;; Commands to show things about generic functions

(CP:DEFINE-COMMAND (COM-SHOW-GENERIC-FUNCTION :COMMAND-TABLE "Flavors")
		   ((GENERIC '((GENERIC-FUNCTION-NAME :DEFINED T)) :DISPLAY-DEFAULT NIL
		     :PROMPT "generic function name"
		     :CONFIRM T)  ;makes the flavor examiner program framework work right
		    &KEY
		    (FLAVORS 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
		     :DOCUMENTATION
		       "List flavors that have methods for this generic function")
		    (METHODS 'BOOLEAN :DEFAULT NIL :MENTIONED-DEFAULT T :DISPLAY-DEFAULT NIL
		     :DOCUMENTATION "List all methods for this generic function"))
  (LET ((GF (FIND-GENERIC-FUNCTION GENERIC)))
    (MULTIPLE-VALUE-BIND (ARGLIST VALUES)
	(ARGLIST GF)
      (IF (GENERIC-FUNCTION-MESSAGE-P GF)
	  (FORMAT T "~&Message ~S (to ~S) takes arguments"
		  GENERIC (FIRST (GENERIC-FUNCTION-ARGLIST GF)))
	  (FORMAT T "~&Generic function ~S takes arguments" GENERIC))
      (PRINT-ARGLIST-AND-VALUES ARGLIST VALUES)
      (TERPRI)
      (COND ((GENERIC-FUNCTION-ACCESSOR GF)
	     (FORMAT T "This is an instance-variable accessor.~%"))
	    ((GENERIC-FUNCTION-EXPLICIT GF)
	     (FORMAT T "This is an explicit DEFGENERIC~@[ in file ~A~].~%"
		     (SI:GET-SOURCE-FILE-NAME GENERIC 'DEFUN))))
      (FORMAT T "~@[Method-combination type is~{ ~S~}.~%~]"
	      (GENERIC-FUNCTION-METHOD-COMBINATION GF))
      (FORMAT T "~@[The only method for this generic is declared to be a solitary method,
so a space-saving, slower technique for method dispatching is employed.~%~]"
	      (GENERIC-FUNCTION-SOLITARY GF))
      (FORMAT T "~@[This generic function is compatible with the ~S message.~%~]"
	      (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF))
      (WHEN (OR FLAVORS METHODS)
	(LET ((FLAVOR-LIST (SORT (COPY-LIST (GENERIC-FUNCTION-FLAVORS GF)) #'STRING-LESSP)))
	  (WHEN FLAVORS
	    (FORMAT T "There ~[~0;are no~1;is one~:;are ~:*~:D~] flavor~:P with methods ~
			    for this generic function~:*~[~0;.~:;:~]"
		    (LIST-LENGTH FLAVOR-LIST))
	    (WHEN FLAVOR-LIST
	      (FORMAT-ITEM-LIST FLAVOR-LIST :PRESENTATION-TYPE 'FLAVOR-NAME)))
	  (WHEN METHODS
    	    (SETQ METHODS (SORT (GENERIC-FUNCTION-METHODS GENERIC) #'STRING-LESSP
				:KEY #'METHOD-FLAVOR))
	    (FORMAT T "There ~[~0;are no~1;is one~:;are ~:*~:D~] method~:P ~
			    for this generic function~:*~[~0;.~:;:~]~%  "
		    (LIST-LENGTH METHODS))
	    (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "  "
				    (DECIDE-METHOD-COMBINATION
				      GF (LAST (GENERIC-FUNCTION-FLAVORS GF)) NIL)
				    METHODS)
	    (TERPRI)))))))
;;; A flavor that has a handler for a specific generic function.  This is
;;; (AND FLAVOR-NAME (SATISFIES <a closure that knows generic-function-name>))
;;; except that we can't put a closure there, and furthermore doing it that way
;;; loses the opportunity for special handling of completion of the null string.
(DEFINE-PRESENTATION-TYPE FLAVOR-HANDLING-GENERIC-FUNCTION ((GENERIC-FUNCTION-NAME))
   :EXPANDER 'FLAVOR-NAME
   :DESCRIBER ((STREAM &KEY PLURAL-COUNT)
	       (DW::PRESENTATION-STRING-PLURALIZE "a flavor" STREAM PLURAL-COUNT)
	       (FORMAT STREAM " that handle~A ~S"
		       (IF PLURAL-COUNT "" "s") GENERIC-FUNCTION-NAME))
   :PARSER ((STREAM &KEY INITIALLY-DISPLAY-POSSIBILITIES ORIGINAL-TYPE)
	    (DW::COMPLETE-INPUT-FROM-SYMBOL-SET STREAM *ALL-FLAVOR-NAMES-AARRAY*
						ORIGINAL-TYPE INITIALLY-DISPLAY-POSSIBILITIES
	      (LAMBDA (STRING &OPTIONAL (ACTION :COMPLETE))
		(DW::COMPLETE-FROM-SYMBOL-SET
		  (IF (OR (MEMBER ACTION DW::*COMPLETION-NEEDS-FULL-SET*)
			  (EQUAL STRING ""))
		      ;; It's faster to generate the set than to test every flavor
		      ;; GENERIC-FUNCTION-ALL-FLAVORS can still be very slow if there
		      ;; are a great many flavors involved.
		      (GENERIC-FUNCTION-ALL-FLAVORS
			(FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME))
		      *ALL-FLAVOR-NAMES-AARRAY*)
		  STRING ACTION
		  (LAMBDA (FLAVOR-NAME)
		    (FLAVOR-HANDLES-GENERIC-FUNCTION FLAVOR-NAME GENERIC-FUNCTION-NAME))))))
   :DEFAULT-PREPROCESSOR
	((FLAVOR-NAME)		;Just forget about defaulting if the default doesn't handle
	 (AND FLAVOR-NAME	;argument can be nil
	      (FLAVOR-HANDLES-GENERIC-FUNCTION FLAVOR-NAME GENERIC-FUNCTION-NAME)
	      FLAVOR-NAME))
   :TYPEP ((FLAVOR-NAME)
	   (AND (TYPEP FLAVOR-NAME '(AND SYMBOL (NOT NULL)))
		(FIND-FLAVOR FLAVOR-NAME NIL)
		(FLAVOR-HANDLES-GENERIC-FUNCTION FLAVOR-NAME GENERIC-FUNCTION-NAME))))
(DEFUN FLAVOR-HANDLES-GENERIC-FUNCTION (FLAVOR-NAME GENERIC-FUNCTION-NAME)
  (SETQ GENERIC-FUNCTION-NAME (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC-FUNCTION-NAME))
  (LABELS ((CHECK (FLAVOR-NAME)
	     (LET ((FL (FIND-FLAVOR FLAVOR-NAME NIL)))
	       (AND FL
		    (IF (FLAVOR-METHODS-COMPOSED FL)
			(ZL:GET-FLAVOR-HANDLER-FOR FLAVOR-NAME GENERIC-FUNCTION-NAME)
			(OR (ASSOC GENERIC-FUNCTION-NAME (FLAVOR-METHOD-TABLE FL))
			    (SOME #'CHECK (FLAVOR-LOCAL-COMPONENTS FL))))))))
    (CHECK FLAVOR-NAME)))

(CP:DEFINE-COMMAND (COM-SHOW-FLAVOR-HANDLER :COMMAND-TABLE "Flavors")
	((GENERIC '((GENERIC-FUNCTION-NAME :DEFINED T))
	  :PROMPT "for generic function" :DISPLAY-DEFAULT NIL :CONFIRM T)
	 (FLAVOR `((FLAVOR-HANDLING-GENERIC-FUNCTION ,GENERIC))
	  :PROMPT "of flavor" :DISPLAY-DEFAULT NIL :CONFIRM T
	  ;;--- Next line should not be needed, but :DEFAULT-PREPROCESSOR seems to be ignored
	  :DEFAULT (LET ((FLAVOR (DW::YANK-FOR-PRESENTATION-TYPE
				   (DW::FIND-ACCEPT-HISTORY 'FLAVOR-NAME) 'FLAVOR-NAME)))
		     (AND GENERIC FLAVOR	;argument can be nil
			  (FLAVOR-HANDLES-GENERIC-FUNCTION FLAVOR GENERIC)
			  FLAVOR)))
	 &KEY
	 (CODE '((MEMBER NO YES DETAILED)) :DEFAULT 'NO :MENTIONED-DEFAULT 'YES
	  :PROMPT "of combined method" :DISPLAY-DEFAULT NIL
	  :DOCUMENTATION "Show Lisp code of the combined method.
  YES shows a schematic outline for easier readability.
  DETAILED includes the details of method calling sequences."))
  (LET ((FORM NIL) HANDLER-FUNCTION-SPEC COMBINED-METHOD-LIST WRAPPER-SOURCES
	LAMBDA-LIST METHOD-COMBINATION ERROR)
    ;; Get information about the handler from the flavor system
    (IF (EQ CODE 'NO)
	(MULTIPLE-VALUE-SETQ (HANDLER-FUNCTION-SPEC COMBINED-METHOD-LIST
			      METHOD-COMBINATION ERROR)
	  (COMPOSE-HANDLER GENERIC FLAVOR))
	(MULTIPLE-VALUE-SETQ (FORM HANDLER-FUNCTION-SPEC COMBINED-METHOD-LIST WRAPPER-SOURCES
			      LAMBDA-LIST METHOD-COMBINATION ERROR)
	  (COMPOSE-HANDLER-SOURCE GENERIC FLAVOR)))
    (COND (ERROR (PRINC ERROR))
	  ((OR (ATOM HANDLER-FUNCTION-SPEC)	;I'm not sure if this is redundant
	       (NOT (MEMBER (METHOD-TYPE HANDLER-FUNCTION-SPEC)
			    '(COMBINED SHARED-COMBINED PSEUDO-COMBINED))))
	   (FORMAT T "The handler for ~S of an instance of ~S is~%the ~A "
		   GENERIC FLAVOR
		   (COND ((ATOM HANDLER-FUNCTION-SPEC) "function")	;Can this happen?
			 ((MEMBER (METHOD-TYPE HANDLER-FUNCTION-SPEC) *ACCESSOR-METHOD-TYPES*)
			  "accessor")
			 (T "method")))
	   (PRESENT HANDLER-FUNCTION-SPEC (METHOD-PRESENTATION-TYPE HANDLER-FUNCTION-SPEC)
		    :ALLOW-SENSITIVE-INFERIORS NIL)	;avoid user confusion
	   (FORMAT T "~%The method-combination type is~{ ~S~}.~%"
		   METHOD-COMBINATION))
	  (T
	   ;;--- Buglet, if we call COMPOSE-HANDLER-SOURCE then inherited combined
	   ;;--- methods never get returned.
	   (FORMAT T "The handler for ~S of an instance of ~S is a~%" GENERIC FLAVOR)
	   (CASE (METHOD-TYPE HANDLER-FUNCTION-SPEC)
	     (COMBINED
	       (FORMAT T "combined method, with method-combination type~{ ~S~}~
			  ~:[,~%inherited from ~S~].~%"
		   METHOD-COMBINATION (EQ (METHOD-FLAVOR HANDLER-FUNCTION-SPEC) FLAVOR)
		   (METHOD-FLAVOR HANDLER-FUNCTION-SPEC)))
	     (SHARED-COMBINED
	       (FORMAT T "shared-combined method, with method-combination type~{ ~S~}.~%"
		       METHOD-COMBINATION))
	     (PSEUDO-COMBINED
	       (FORMAT T "whopper, with method-combination type~{ ~S~}.~%"
		       METHOD-COMBINATION)))
	   (COND ((EQ CODE 'NO)
		  (FORMAT T (COND ((NULL COMBINED-METHOD-LIST)
				   ;; This can happen if there is a method-combination-error
				   ;; and the user presses Resume.
				   "There are no applicable methods.~%")
				  ((CDR COMBINED-METHOD-LIST)
				   "The methods, in order of execution, are:~%  ")
				  (T
				   "The only method is: ")))
		  (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "  "
					  METHOD-COMBINATION COMBINED-METHOD-LIST))
		 (T
		  ;; It's intentional that this shows a combined method even if
		  ;; we really used a SHARED-COMBINED or PSEUDO-COMBINED.  Have
		  ;; to show the Lisp code somehow.
		  (SETQ FORM `(DEFUN (COMBINED ,GENERIC ,FLAVOR)
				     (SELF SELF-MAPPING-TABLE .GENERIC. ,@LAMBDA-LIST)
				,FORM))
		  (MULTIPLE-VALUE-BIND (METHOD-ARGUMENTS METHOD-APPLY)
		      (LT:LAMBDA-LIST-ARGUMENTS LAMBDA-LIST)
		    (SETQ METHOD-APPLY (IF METHOD-APPLY 'APPLY 'FUNCALL))
		    (LABELS ((FORMATTER (X)
			       (CASE (CAR X)
				 ((APPLY FUNCALL)
				  (WHEN (AND (NEQ CODE 'DETAILED)
					     (LISTP (SECOND X))
					     (EQ (FIRST (SECOND X)) 'FUNCTION)
					     (EQ (THIRD X) 'SELF)
					     (LISTP (FOURTH X))
					     (EQ (FIRST (FOURTH X))
						 'GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE)
					     (EQ (FIFTH X) '.GENERIC.))
				    ;; Calling a method, either with standard arguments
				    ;; or with some other arguments
				    (IF (AND (EQ (FIRST X) METHOD-APPLY)
					     (EQUAL (NTHCDR 5 X) METHOD-ARGUMENTS))
					(GPRINT:GFORMAT "{0'(2 0 (NIL 0) (:DUTCH :ITALIC :SMALLER) "TR8I")call 0'P}" (SECOND (SECOND X)))
					(GPRINT:GFORMAT "{0'2call 0'P+4N'2 args0{'{0[<*_B>]'}'}}"
							(SECOND (SECOND X)) (NTHCDR 5 X)))
				    ;---It sure would be nice if I could push
				    ;---DW:WITH-SENSITIVE-OUTPUT through gprint queue
				    ;---MMcM says there is a way, but it's gross
				    T))
				 ;; There used to be other cases here, but they turn out
				 ;; no longer to be necessary.  Too bad, it was fun writing
				 ;; all those grotesque GPRINT:GFORMAT's.
				 (LAMBDA
				   ;; Purge top-level symbols, put in to prevent
				   ;; compiler warnings
				   (FUNCALL #'(:PROPERTY LAMBDA GPRINT::FORMATTER)
					    (APPEND (SUBSEQ X 0 2)
						    (REMOVE-IF #'ATOM
							       (SUBSEQ X 2 (1- (LENGTH X))))
						    (LAST X)))
				   T))))
		      (STACK-LET ((GPRINT:*LIST-FORMATTERS* (CONS #'FORMATTER
								  GPRINT:*LIST-FORMATTERS*)))
			(WRITE FORM :PRETTY ':CODE :ESCAPE T :LEVEL NIL :LENGTH NIL))))))))))

;;; Some useless commands that perhaps belong in the wastebasket

;--- 342.256 attempted to make this unnecessary, but it didn't work
;--- Leave this dummy translator here until the substrate bug is really fixed
;Define click middle on generic-function-name because otherwise it only has
;menu commands (when no shifting keys are pressed) and due to a bug (misfeature?)
;is not sensitive at all, so that you cannot get to the menu commands.
(DEFINE-PRESENTATION-TO-COMMAND-TRANSLATOR GENERIC-FUNCTION-NAME-DUMMY-COMMAND
	(((GENERIC-FUNCTION-NAME :DEFINED T)) :GESTURE :DESCRIBE :MENU NIL
	 :DOCUMENTATION "Describe this generic function")
	(GENERIC-FUNCTION-NAME)
  `(COM-SHOW-GENERIC-FUNCTION ,GENERIC-FUNCTION-NAME))

;;; This is just to get mouse sensitivity of any sort in the flavor
;;; examiner, where nested expression sensitivity isn't available.
(DEFINE-PRESENTATION-TO-COMMAND-TRANSLATOR FLAVOR-NAME-DUMMY-COMMAND
	(FLAVOR-NAME :GESTURE :DESCRIBE :MENU NIL :PRIORITY -1
	 :DOCUMENTATION "Show components of this flavor")
	(FLAVOR-NAME)
  `(COM-SHOW-FLAVOR-COMPONENTS ,FLAVOR-NAME))

;;; Some useful things to do from the mouse

;;; The first level of this list associates object presentation types to
;;; applicable commands.  Other presentation types with translators to those object
;;; presentation types, set up through the macrology below, also get the commands.
;;;
;;; The second level of this list contains elements
;;;	(action-name menu-documentation clauses...)
;;;   action-name - seed for construction of presentation translator names
;;;   menu-documentation - string displayed in menu
;;; Each clause looks like
;;;	(gesture documentation (command arguments...) options...)
;;;   gesture -- one of :LEFT, :MIDDLE, :RIGHT
;;;   documentation -- appears in the mouse documentation line
;;;   command -- name of the CP command to be invoked
;;;   arguments... -- arguments to that command, which get evaluated, with the object
;;;		      presentation type's name bound to the object (after translation)
;;;   options... -- PRESENTATION-BLIP-OPTIONS
;;;			:ACTIVATE NIL allows user to edit the command
;;;			:SUFFIX string appends those characters to this command
;;;					suffixing a space is how we evoke a noise string
;;;
;;; The last clause actually serves as an "otherwise" clause, to avoid looking stupid.
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFPARAMETER *PRESENTATION-COMMANDS*		;Drives the macro below
	      '((FLAVOR-NAME			;Flavor commands
		  (SHOW-FLAVOR-COMPONENTS "Show components of"
		    (:LEFT "Show flavor components as a tree"
			   (COM-SHOW-FLAVOR-COMPONENTS FLAVOR-NAME))
		    (:MIDDLE "briefly" (COM-SHOW-FLAVOR-COMPONENTS FLAVOR-NAME :BRIEF T))
		    (:RIGHT "as a tree including duplicates"
			    (COM-SHOW-FLAVOR-COMPONENTS FLAVOR-NAME :DUPLICATES T)))
		  (SHOW-FLAVOR-DEPENDENTS "Show flavors that depend on"
		    (:LEFT "Show flavor dependents as a tree"
			   (COM-SHOW-FLAVOR-DEPENDENTS FLAVOR-NAME))
		    (:MIDDLE "briefly" (COM-SHOW-FLAVOR-DEPENDENTS FLAVOR-NAME :BRIEF T))
		    (:RIGHT "as a tree including duplicates"
			    (COM-SHOW-FLAVOR-DEPENDENTS FLAVOR-NAME :DUPLICATES T)))
		  (SHOW-FLAVOR-OPERATIONS "Show operations on"
		    (:LEFT "Show generic functions and messages handled by this flavor"
			   (COM-SHOW-FLAVOR-OPERATIONS FLAVOR-NAME))
		    (:MIDDLE "matching a substring"
			     (COM-SHOW-FLAVOR-OPERATIONS FLAVOR-NAME :MATCH)
			     :ACTIVATE NIL :SUFFIX " ")
		    (:RIGHT "show arguments, too"
			    (COM-SHOW-FLAVOR-OPERATIONS FLAVOR-NAME :DETAILED T)))
		  (SHOW-FLAVOR-INSTANCE-VARIABLES "Show instance variables of"
		    (:LEFT "Show instance variables of this flavor"
			   (COM-SHOW-FLAVOR-INSTANCE-VARIABLES FLAVOR-NAME))
		    (:MIDDLE "matching a substring"
			     (COM-SHOW-FLAVOR-INSTANCE-VARIABLES FLAVOR-NAME :MATCH)
			     :ACTIVATE NIL :SUFFIX " ")
		    (:RIGHT "with initializations and accessors"
			    (COM-SHOW-FLAVOR-INSTANCE-VARIABLES FLAVOR-NAME :DETAILED T)))
		  (SHOW-FLAVOR-METHODS "Show methods of"
		    (:LEFT "Show methods of this flavor"
			   (COM-SHOW-FLAVOR-METHODS FLAVOR-NAME))
		    (:MIDDLE "matching a substring"
			     (COM-SHOW-FLAVOR-METHODS FLAVOR-NAME :MATCH)
			     :ACTIVATE NIL :SUFFIX " ")
		    (:RIGHT "in order by the flavors that define them"
			     (COM-SHOW-FLAVOR-METHODS FLAVOR-NAME :SORT 'FLAVOR)))
		  (SHOW-FLAVOR-INITIALIZATIONS "Show initializations of"
		    (:LEFT "Show initialization keywords"
			   (COM-SHOW-FLAVOR-INITIALIZATIONS FLAVOR-NAME))
		    (:MIDDLE "matching a substring"
			     (COM-SHOW-FLAVOR-INITIALIZATIONS FLAVOR-NAME :MATCH)
			     :ACTIVATE NIL :SUFFIX " ")
		    (:RIGHT "include internal details"
			    (COM-SHOW-FLAVOR-INITIALIZATIONS FLAVOR-NAME :DETAILED T))))
		(GENERIC-FUNCTION-NAME		;Generic function commands
		  (SHOW-GENERIC-FUNCTION "Describe"
		    (:LEFT "General attributes of generic function"
			   (COM-SHOW-GENERIC-FUNCTION GENERIC-FUNCTION-NAME))
		    (:MIDDLE "List flavors that support it"
			     (COM-SHOW-GENERIC-FUNCTION GENERIC-FUNCTION-NAME :FLAVORS T))
		    (:RIGHT "List methods for it"
			    (COM-SHOW-GENERIC-FUNCTION GENERIC-FUNCTION-NAME :METHODS T)))
;--- This doesn't work because the CP::UNREAD-CP-ARGUMENT created by CP:BUILD-COMMAND
;--- is not recognized, but just fed through as an argument, which explodes.
;--- Even :ACTIVATE NIL doesn't fix it.
;--- I'd like to have this on FLAVOR-NAME with the first argument unread also.
;		  (SHOW-HANDLER-FOR-GENERIC-FUNCTION "Show some flavor's handler for"
;		    (:LEFT "Show methods composing the handler"
;			   (COM-SHOW-FLAVOR-HANDLER GENERIC-FUNCTION-NAME)
;			   :ACTIVATE NIL)
;		    (:MIDDLE "Show Lisp code in schematic form"
;			     (COM-SHOW-FLAVOR-HANDLER GENERIC-FUNCTION-NAME NIL :CODE 'YES)
;			     :ACTIVATE NIL)
;		    (:RIGHT "detailed code"
;			    (COM-SHOW-FLAVOR-HANDLER GENERIC-FUNCTION-NAME NIL :CODE 'DETAILED)
;			    :ACTIVATE NIL))
		  ))))

;This macro makes object-presentation-type have all the appropriate mouse commands
;for operations on command-presentation-type in its click-right menu, for both CP and ZWEI
(DEFMACRO DEFINE-PRESENTATION-COMMANDS (OBJECT-PRESENTATION-TYPE
					COMMAND-PRESENTATION-TYPE
					PRETTY-NAME
					&KEY VARIABLE-NAME TRANSLATOR-NAME
					     TESTER TRANSLATOR SUFFIX
					&AUX COMMANDS)
  (CHECK-TYPE TRANSLATOR-NAME SYMBOL)
  (CHECK-TYPE OBJECT-PRESENTATION-TYPE (OR SYMBOL LIST))
  (dw:with-type-decoded (object-type-name) object-presentation-type
    (dw:with-type-decoded (command-type-name) command-presentation-type
      (UNLESS (SETQ COMMANDS (CDR (ASSOC command-type-name *PRESENTATION-COMMANDS*)))
	(ERROR "~S is not a presentation type in *PRESENTATION-COMMANDS*"
	       COMMAND-PRESENTATION-TYPE))
      (CHECK-TYPE PRETTY-NAME STRING)
      (CHECK-TYPE VARIABLE-NAME SYMBOL)
      (UNLESS VARIABLE-NAME
	(SETQ VARIABLE-NAME object-type-name))
      (UNLESS TRANSLATOR-NAME
	(UNLESS (eq object-type-name command-type-name)
	  (SETQ TRANSLATOR-NAME (INTERN (STRING-APPEND object-type-name
						       "-TO-"
						       command-type-name
						       (OR SUFFIX ""))))))
      (SETQ TESTER (IF TESTER
		       `((,VARIABLE-NAME &KEY PRESENTATION GESTURE &ALLOW-OTHER-KEYS)
			 (IGNORE ,VARIABLE-NAME PRESENTATION GESTURE)
			 ,TESTER)
		       'TRUE))
      (UNLESS TRANSLATOR
	(SETQ TRANSLATOR VARIABLE-NAME))
      `(PROGN 
	 ,@(UNLESS (eq OBJECT-TYPE-name COMMAND-TYPE-name)
	     `((DEFINE-PRESENTATION-TRANSLATOR ,TRANSLATOR-NAME
		  (,OBJECT-PRESENTATION-TYPE
		   ,COMMAND-PRESENTATION-TYPE
		   :TESTER ,TESTER
		   ;; Guess not, as user supplies translator
		   ;:DO-NOT-COMPOSE T
		   )
		  (,VARIABLE-NAME)
		 ,TRANSLATOR)))
	 ,@(LOOP FOR (COMMAND DOCUMENTATION . CLAUSES) IN COMMANDS
		 AS EXPANSION = `(CASE MOUSE-CHAR
				   ,@(LOOP FOR ((GESTURE DOCUMENTATION
							 (COMMAND . ARGUMENTS)
							 . OPTIONS)
						. MORE) ON CLAUSES
					   AS KEY = (OR (DW:MOUSE-CHAR-FOR-GESTURE GESTURE)
							(WARN "~S is an undefined mouse ~
								gesture name in ~S"
							      GESTURE COMMAND))
					   AS ARGS = (SUBST TRANSLATOR
							    COMMAND-PRESENTATION-TYPE
							    ARGUMENTS)
					   DO (SETQ COMMAND
						    `(CP:BUILD-COMMAND ',COMMAND ,@ARGS))
					      (WHEN OPTIONS
						(SETQ COMMAND `(VALUES ,COMMAND 'CP:COMMAND
								       ,@OPTIONS)))
					   COLLECT `(,(OR (AND MORE KEY) `OTHERWISE)
						     ,COMMAND)))
		 AS DOC-FUNCTION = `((OBJECT &KEY FOR-MENU-P MOUSE-CHAR)
				     (IGNORE OBJECT)
				     (IF FOR-MENU-P
					 ,(STRING-APPEND DOCUMENTATION " this " PRETTY-NAME)
					 (CASE MOUSE-CHAR
					   ,@(LOOP FOR (GESTURE DOCUMENTATION . MORE)
						       IN CLAUSES
						   AS KEY = (DW:MOUSE-CHAR-FOR-GESTURE GESTURE)
						   COLLECT `(,KEY ,DOCUMENTATION)))))
		 DO (WHEN TRANSLATOR-NAME
		      (SETQ COMMAND (INTERN (STRING-APPEND COMMAND
							   "-OF-"
							   object-type-name))))
		    (WHEN SUFFIX
		      (SETQ COMMAND (INTERN (STRING-APPEND COMMAND SUFFIX))))
		 COLLECT `(DEFINE-PRESENTATION-TO-COMMAND-TRANSLATOR ,COMMAND
			     (,OBJECT-PRESENTATION-TYPE
			      :TESTER ,TESTER :DO-NOT-COMPOSE T
			      :GESTURE NIL		;Menu only
			      :DOCUMENTATION ,DOC-FUNCTION)
			     (,VARIABLE-NAME &KEY MOUSE-CHAR)
			    (IGNORE MOUSE-CHAR)	;defeat compiler warning
			    ,EXPANSION)
		 COLLECT `(ZWEI:DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR
			    ,(INTERN (STRING-APPEND COMMAND "-FOR-ZWEI"))
			    (,OBJECT-PRESENTATION-TYPE
			     ,(SI:MAKE-COMMAND-NAME COMMAND)
			     ;; These commands don't depend on Zmacs
			     ZWEI:*STANDARD-COMTAB*
			     :GESTURE NIL	;Menu only
			     :TESTER ,TESTER :DO-NOT-COMPOSE T
			     :DOCUMENTATION ,DOC-FUNCTION)
			    (,VARIABLE-NAME &KEY MOUSE-CHAR)
			    (IGNORE MOUSE-CHAR)	;defeat compiler warning
			    (ZWEI:EXECUTE-CP-COMMAND-1 ,EXPANSION)))))))

;;; Define all the mouse commands

(DEFINE-PRESENTATION-COMMANDS FLAVOR-NAME FLAVOR-NAME "flavor")

;The internal FLAVOR structure is equivalent to a flavor name
(DEFINE-PRESENTATION-COMMANDS FLAVOR FLAVOR-NAME "flavor"
  :VARIABLE-NAME FL
  :TRANSLATOR (FLAVOR-NAME FL))

;A method name as a function spec can act as a flavor name
(DEFINE-PRESENTATION-COMMANDS FUNCTION-SPEC FLAVOR-NAME "method's flavor"
  :TESTER (AND (LISTP FUNCTION-SPEC)
	       (MEMBER (CAR FUNCTION-SPEC) *ALL-METHOD-TYPES*))
  :TRANSLATOR (METHOD-FLAVOR FUNCTION-SPEC))

;An instance variable accessor can name its flavor
(DEFINE-PRESENTATION-COMMANDS INSTANCE-VARIABLE-ACCESSOR FLAVOR-NAME "accessor's flavor"
  :TRANSLATOR (METHOD-FLAVOR INSTANCE-VARIABLE-ACCESSOR))

;An instance can act as the name of its flavor, but only when it is presented
;as an expression.  Don't pick up instances lying around inside other presentations.
(DEFINE-PRESENTATION-COMMANDS INSTANCE FLAVOR-NAME "instance's flavor"
  :TESTER (AND (INSTANCEP INSTANCE)	;Sometimes gets called with a named-structure
	       (DW::WITH-TYPE-DECODED (NAME)
				      (DW:PRESENTATION-TYPE PRESENTATION)
		 ;; Apply only to the exact presentation type specified.  For example,
		 ;; don't apply to pathname presentations (PATHNAME is a presentation subtype
		 ;; of EXPRESSION and a pathname is of CL type INSTANCE).
		 (EQL NAME 'EXPRESSION)))
  :TRANSLATOR (FLAVOR-NAME (%INSTANCE-FLAVOR INSTANCE)))

(DEFINE-PRESENTATION-COMMANDS ((GENERIC-FUNCTION-NAME :DEFINED T)) GENERIC-FUNCTION-NAME
  "generic function")

;The internal generic function structure is equivalent to its name
(DEFINE-PRESENTATION-COMMANDS GENERIC-FUNCTION GENERIC-FUNCTION-NAME "generic function"
  :TRANSLATOR (GENERIC-FUNCTION-NAME GENERIC-FUNCTION))

;A method name as a function-spec can act as the name of its generic function
(DEFINE-PRESENTATION-COMMANDS FUNCTION-SPEC GENERIC-FUNCTION-NAME "method's generic function"
  :SUFFIX "-1"
  :TESTER (AND (LISTP FUNCTION-SPEC)
	       (NEQ (CAR FUNCTION-SPEC) 'DEFUN-IN-FLAVOR)
	       (MEMBER (CAR FUNCTION-SPEC) *ALL-METHOD-TYPES*))
  :TRANSLATOR (METHOD-GENERIC FUNCTION-SPEC))

;An accessor can act as the name of its generic function
(DEFINE-PRESENTATION-COMMANDS INSTANCE-VARIABLE-ACCESSOR GENERIC-FUNCTION-NAME
							 "accessor's generic function"
  :TRANSLATOR (METHOD-GENERIC INSTANCE-VARIABLE-ACCESSOR))

;;;; Support for Show Effect of Definition applied to flavorish definitions

(DEFPROP DEFMETHOD SHOW-EFFECT-OF-METHOD-DEFINITION ZWEI:SHOW-EFFECT-HANDLER)
(DEFPROP DEFWRAPPER SHOW-EFFECT-OF-METHOD-DEFINITION ZWEI:SHOW-EFFECT-HANDLER)
(DEFPROP DEFWHOPPER SHOW-EFFECT-OF-METHOD-DEFINITION ZWEI:SHOW-EFFECT-HANDLER)
(DEFPROP DEFWHOPPER-SUBST SHOW-EFFECT-OF-METHOD-DEFINITION ZWEI:SHOW-EFFECT-HANDLER)
(DEFUN SHOW-EFFECT-OF-METHOD-DEFINITION (FORM)
  (FRESH-LINE)					;Output to typeout-window
  ;; Macroexpand the form so that we get the correct function-spec and also
  ;; so we can call the body if it's a wrapper
  (LET ((EXPANDED-FORM (MACROEXPAND FORM NIL T)))
    (WHEN (EQ (FIRST EXPANDED-FORM) 'PROGN)
      (SETQ EXPANDED-FORM (CAR (LAST EXPANDED-FORM 2))))
    (UNLESS (AND (EQ (FIRST EXPANDED-FORM) 'FDEFINE)
		 (CONSP (SECOND EXPANDED-FORM))
		 (EQ (FIRST (SECOND EXPANDED-FORM)) 'QUOTE)
		 (CONSP (THIRD EXPANDED-FORM))
		 (EQ (FIRST (THIRD EXPANDED-FORM)) 'FUNCTION))
      (ERROR "INTERNAL ERROR: ~S did not macroexpand as expected" (FIRST FORM)))
    (LET ((FUNCTION-SPEC (SECOND (SECOND EXPANDED-FORM))))
      (WHEN (FDEFINEDP FUNCTION-SPEC)
	(FORMAT T "~S is already defined~%" FUNCTION-SPEC))
      ;; Construct flavor environment with this method's FDEFINEDP status inverted
      (LET ((ENV `((,(METHOD-FLAVOR FUNCTION-SPEC) NIL NIL
		    (,FUNCTION-SPEC ,(COND ((FDEFINEDP FUNCTION-SPEC) NIL)	;undefines it
					   ((EQ (METHOD-TYPE FUNCTION-SPEC) 'WRAPPER)
					    ;; Get the correct definition for a wrapper
					    (SI:ENCLOSE (SECOND (THIRD EXPANDED-FORM))
							NIL FUNCTION-SPEC))
					   (T T))))))	;defines it, no particular definition
	    (OPERATION (IF (FDEFINEDP FUNCTION-SPEC) "Undefining this" "Defining this"))
	    (GENERIC (METHOD-GENERIC FUNCTION-SPEC))
	    (FLAVOR (METHOD-FLAVOR FUNCTION-SPEC))
	    (LAST-OLD-METHODS T)
	    (LAST-NEW-METHODS T))
	(FLET ((DO-FLAVOR (FLAVOR)
		 ;; Assume the ERROR return values can be ignored, they just mean "no methods"
		 (MULTIPLE-VALUE-BIND (NIL OLD-METHODS NIL)
		     (COMPOSE-HANDLER GENERIC FLAVOR)
		   (MULTIPLE-VALUE-BIND (NIL NEW-METHODS METHOD-COMBINATION)
		       (COMPOSE-HANDLER GENERIC FLAVOR :ENV ENV)
		     (COND ((EQUAL OLD-METHODS NEW-METHODS))	;Nothing changed
			   ((AND (EQUAL OLD-METHODS LAST-OLD-METHODS)
				 (EQUAL NEW-METHODS LAST-NEW-METHODS))
			    (FORMAT T "~&~A would have the same effect on ~S~%"
				    OPERATION FLAVOR))
			   ((NULL NEW-METHODS)
			    (FORMAT T "~&~A would make ~S cease to handle ~S~%"
				    OPERATION FLAVOR GENERIC)
			    (SETQ LAST-OLD-METHODS OLD-METHODS
				  LAST-NEW-METHODS NEW-METHODS))
			   ((NULL OLD-METHODS)
			    (FORMAT T "~&~A would give ~S method~P for ~S~%  "
				    OPERATION FLAVOR (LIST-LENGTH NEW-METHODS) GENERIC)
			    (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "  "
						    METHOD-COMBINATION NEW-METHODS)
			    (SETQ LAST-OLD-METHODS OLD-METHODS
				  LAST-NEW-METHODS NEW-METHODS))
			   (T
			    (FORMAT T "~&~A would change ~S's method~P for ~S~%  "
				    OPERATION FLAVOR
				    (MAX (LIST-LENGTH OLD-METHODS) (LIST-LENGTH NEW-METHODS))
				    GENERIC)
			    (SHOW-METHOD-LIST-DIFFERENCES OLD-METHODS NEW-METHODS
							  METHOD-COMBINATION)
			    (SETQ LAST-OLD-METHODS OLD-METHODS
				  LAST-NEW-METHODS NEW-METHODS)))))))
	  (LET ((FL (FIND-FLAVOR FLAVOR NIL)) (FIRST T))
	    (COND ((NULL FL)
		   (FORMAT T "~&~A cannot be analyzed because ~S is an undefined flavor."
			   OPERATION FLAVOR))
		  (T
		   (DO-FLAVOR FLAVOR)		;Do this one even if it's not composed
		   (DO-ALL-COMPOSED-DEPENDENTS (DEPENDENT FL FL)
		     (UNLESS (EQ DEPENDENT FLAVOR)
		       (UNLESS (FLAVOR-IS-ABSTRACT FL)	;Composed doesn't matter if abstract
			 (WHEN FIRST		;Print message because it's slow
			   (FORMAT T "~&[Searching dependent flavors]~%")
			   (SETQ FIRST NIL))
			 (DO-FLAVOR DEPENDENT))))))
	    T))))))

(DEFUN (DEFGENERIC ZWEI:SHOW-EFFECT-HANDLER) (FORM)
  (FRESH-LINE)					;Output to typeout-window
  ;; Parse this form into a list of functions and the generic-function options
  (DESTRUCTURING-BIND (NIL NAME ARGLIST &BODY OPTIONS) FORM
    (MULTIPLE-VALUE-BIND (FUNCTIONS PARSED-OPTIONS)
	(PARSE-DEFGENERIC NAME ARGLIST OPTIONS)
      ;; Show the effect of DEFGENERIC-INTERNAL
      (LET ((GF (FIND-GENERIC-FUNCTION NAME NIL)))
	(COND ((NULL GF)
	       (FORMAT T "Evaluating this would define the generic function ~S ~
			for the first time~%."
		       NAME))
	      (T
	       (SI:EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO GF)
	       (FORMAT T "Evaluating this would redefine the generic function ~S~@
			with ~:[different~;the same~] arguments.~%"
		       NAME (EQUAL ARGLIST (GENERIC-FUNCTION-ARGLIST GF)))
	       (UNLESS (EQUAL (GETF PARSED-OPTIONS ':METHOD-COMBINATION)
			      (GENERIC-FUNCTION-METHOD-COMBINATION GF))
		 (FORMAT T "The method-combination would be changed from ~
				~:[unspecified~;~:*~{~S~^ ~}~] to ~
				~:[unspecified~;~:*~{~S~^ ~}~]~%"
			 (GENERIC-FUNCTION-METHOD-COMBINATION GF)
			 (GETF PARSED-OPTIONS ':METHOD-COMBINATION))
		 ;;--- Show effect of changing method combination on flavors' methods?
		 )
	       (LET ((OLD (GENERIC-FUNCTION-METHOD-ARGLIST GF))
		     (NEW (ASSOC ':METHOD-ARGLIST (GETF PARSED-OPTIONS ':DEBUGGING-INFO))))
		 (SETQ NEW (IF NEW (CDR NEW)
			       (LT:REMOVE-ARGUMENTS-FROM-LAMBDA-LIST 1 ARGLIST)))
		 (UNLESS (EQUAL NEW OLD)
		   (FORMAT T "The arguments for methods would be changed from ~:S to ~:S~%"
			   OLD NEW)))
	       (UNLESS (EQ (GETF PARSED-OPTIONS ':MESSAGE-P) (GENERIC-FUNCTION-MESSAGE-P GF))
		 (IF (GENERIC-FUNCTION-MESSAGE-P GF)
		     (FORMAT T "It would be changed from a message to a generic function.~%")
		     (FORMAT T "It would be changed from a generic function to a message.~%")
		     ))
	       (UNLESS (EQ (GETF PARSED-OPTIONS ':COMPATIBLE-MESSAGE)
			   (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF))
		 (IF (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF)
		     (FORMAT T "It would no longer be equivalent to the ~S message.~%"
			     (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF))
		     (FORMAT T "It would become equivalent to the ~S message.~%"
			     (GETF PARSED-OPTIONS ':COMPATIBLE-MESSAGE))))
	       ;; I didn't bother with EXPLICIT, DEFINE-P, INLINE-METHODS
	       ;; and possible fine points of DEBUGGING-INFO
	       ;;--- Watch for changing the dispatch?  Important, but not recorded now.
	       )))
      ;; Show the effect of any function/method definitions
      ;;--- This isn't completely right, should pass down a hypothetical
      ;;--- environment containing the new generic function
      ;;--- in case FUNCTIONS includes any DEFMETHODs
      (LET ((ZWEI:*TYPEIN-WINDOW* ZWEI:*TYPEOUT-WINDOW*))	;always output upstairs
	(DOLIST (FUNCTION FUNCTIONS)
	  (ZWEI:SHOW-EFFECT-OF-LISP-FORM FUNCTION NIL))
	T))))

;Subroutine for various hypothetical-exploration commands
;--- Maybe this should share some code with COM-SHOW-FLAVOR-DIFFERENCES
;---This ignores a few of the more obscure attributes such as :REQUIRED-FLAVORS
(DEFUN SHOW-FLAVOR-DIFFERENCES (FLAVOR-NAME ENV1 ENV2 CHANGE-HEADING NO-CHANGE-HEADING
				IDENTICAL-METHODS IDENTICAL-INITIALIZATIONS)
  (DECLARE (SYS:DOWNWARD-FUNARG CHANGE-HEADING NO-CHANGE-HEADING))
  (LET* ((FL1 (FIND-FLAVOR FLAVOR-NAME 'CREATE-IN-ENV ENV1))
	 (FL2 (FIND-FLAVOR FLAVOR-NAME 'CREATE-IN-ENV ENV2))
	 (HEADING-PRINTED NIL))
    (LABELS ((SHOW-DIFFERENCES (LIST1 LIST2 DESCRIPTION &REST OPTIONS)
	       (UNLESS (EQUAL LIST1 LIST2)
		 (PRINT-HEADING DESCRIPTION)
		 (FORMAT T "~%  ")
		 (APPLY #'SHOW-LIST-DIFFERENCES LIST1 LIST2 OPTIONS)))
	     (SHOW-DIFFERENCE (ITEM1 ITEM2 DESCRIPTION)
	       (UNLESS (EQUAL ITEM1 ITEM2)
		 (PRINT-HEADING DESCRIPTION)
		 (FORMAT T "~S changed to ~S" ITEM1 ITEM2)))
	     (PRINT-HEADING (DESCRIPTION)
	       (FRESH-LINE)
	       (UNLESS HEADING-PRINTED
		 (FUNCALL CHANGE-HEADING *STANDARD-OUTPUT*)
		 (SETQ HEADING-PRINTED T))
	       (FORMAT T "~A:" DESCRIPTION)))
      ;; Get up to date information
      (UNLESS (FLAVOR-ALL-COMPONENTS FL1)
	(COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ENV ENV1 :ERROR-P NIL))
      (UNLESS (FLAVOR-ALL-COMPONENTS FL2)
	(COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ENV ENV2 :ERROR-P NIL))

      ;; Show differences in instance variables (ignoring their order)
      (UNLESS (EQUAL (FLAVOR-ALL-INSTANCE-VARIABLES FL1) (FLAVOR-ALL-INSTANCE-VARIABLES FL2))
	(PRINT-HEADING "Differences in instance variables")
	(COND ((AND (= (LIST-LENGTH (FLAVOR-ALL-INSTANCE-VARIABLES FL1))
		       (LIST-LENGTH (FLAVOR-ALL-INSTANCE-VARIABLES FL2)))
		    (SUBSETP (FLAVOR-ALL-INSTANCE-VARIABLES FL1)
			     (FLAVOR-ALL-INSTANCE-VARIABLES FL2)))
	       (FORMAT T "~%  Same instance variables but in a different order."))
	      (T
	       (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL1)
		 (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ENV ENV1 :ERROR-P NIL))
	       (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL2)
		 (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ENV ENV2 :ERROR-P NIL))
	       (DESCRIBE-TRANSFORM-INSTANCE FL1 FL2))))

      ;; Show differences in components
      (SHOW-DIFFERENCES (FLAVOR-ALL-COMPONENTS FL1) (FLAVOR-ALL-COMPONENTS FL2)
			"Differences in component flavors")

      ;; Show differences in methods
      ;; Sort with ALPHALESSP rather than STRING-LESSP because generic names can be lists
      (UNLESS IDENTICAL-METHODS
	(LET ((H1 (SORT (COMPOSE-HANDLERS FLAVOR-NAME :ENV ENV1 :ERROR-P NIL)
			#'ALPHALESSP :KEY #'CAR))
	      (H2 (SORT (COMPOSE-HANDLERS FLAVOR-NAME :ENV ENV2 :ERROR-P NIL)
			#'ALPHALESSP :KEY #'CAR)))
	  (UNLESS (EQUAL H1 H2)
	    (LOOP WHILE (OR H1 H2) WITH SUBHEADING-PRINTED = NIL
		  AS (OP1 MC1 METHODS1) = (CAR H1)
		  AS (OP2 MC2 METHODS2) = (CAR H2)
		  DO ;; Ignore uninteresting special-instance-variables pseudo-methods
		     (SETQ METHODS1 (REMOVE 'SPECIAL-INSTANCE-VARIABLES METHODS1
					    :KEY #'METHOD-TYPE)
			   METHODS2 (REMOVE 'SPECIAL-INSTANCE-VARIABLES METHODS2
					    :KEY #'METHOD-TYPE))
		     (COND ((EQUAL METHODS1 METHODS2)
			    (POP H1)
			    (POP H2))
			   (T
			    (UNLESS SUBHEADING-PRINTED
			      (PRINT-HEADING "Differences in methods")
			      (SETQ SUBHEADING-PRINTED T))
			    (COND ((EQ OP1 OP2)
				   (POP H1)
				   (POP H2)
				   (FORMAT T "~%Methods for ~S ~
					  (meth comb ~:[changed from ~S to ~S~;= ~S~*~]) ~
					  changed:~%  "
					   OP1 (EQUAL MC1 MC2) MC1 MC2)
				   (SHOW-METHOD-LIST-DIFFERENCES METHODS1 METHODS2 MC1))
				  ((AND OP1 (OR (NULL OP2) (ALPHALESSP OP1 OP2)))
				   (FORMAT T "~%~S is no longer handled: " OP1)
				   (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "  " MC1
							   METHODS1)
				   (POP H1))
				  (T
				   (FORMAT T "~%Method~P for ~S added: "
					   (LENGTH METHODS2) OP2)
				   (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "  " MC2
							   METHODS2)
				   (POP H2)))))))))

      ;; Show differences in initialization
      (UNLESS IDENTICAL-INITIALIZATIONS
	(UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL1)
	  (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ENV ENV1 :ERROR-P NIL))
	(UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL2)
	  (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ENV ENV2 :ERROR-P NIL))
	(SHOW-DIFFERENCE (FLAVOR-AREA-KEYWORD FL1) (FLAVOR-AREA-KEYWORD FL2)
			 "Area keyword for make-instance")
	(SHOW-DIFFERENCE (IF (NUMBERP (FLAVOR-INSTANCE-AREA FL1))
			     (AREA-NAME (FLAVOR-INSTANCE-AREA FL1))
			     (FLAVOR-INSTANCE-AREA FL1))
			 (IF (NUMBERP (FLAVOR-INSTANCE-AREA FL2))
			     (AREA-NAME (FLAVOR-INSTANCE-AREA FL2))
			     (FLAVOR-INSTANCE-AREA FL2))
			 "Default area for instances")
	;; Collect list of elements (variable-name init-keyword required [default-init-form])
	(FLET ((INITIALIZATIONS (FL)
		 (LET ((REQUIRED (FLAVOR-ALL-REQUIRED-KEYWORDS FL)))
		   (SORT (NCONC (LOOP FOR VAR IN (FLAVOR-ALL-INSTANCE-VARIABLES FL)
				      FOR POS FROM 1
				      WITH TEMPLATE = (FLAVOR-TEMPLATE-INSTANCE FL)
				      AS CELL = (%MAKE-POINTER-OFFSET DTP-LOCATIVE
								      TEMPLATE POS)
				      WITH KEYWORDS = (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL)
				      AS KEYWORD = (FIRST (FIND POS KEYWORDS :KEY #'SECOND))
				      WITH FORMS = (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS FL)
				      AS INIT = (FIND POS FORMS :KEY #'SECOND)
				      WHEN (OR KEYWORD INIT (LOCATION-BOUNDP CELL))
					COLLECT `(,VAR ,KEYWORD
						  ,(NOT (NOT (MEMBER KEYWORD REQUIRED)))
						  ,@(COND (INIT
							   (LIST (CAR INIT)))
							  ((LOCATION-BOUNDP CELL)
							   (LIST (QUOTE-UNLESS-CONSTANT
								   (LOCATION-CONTENTS CELL))))
							  (T NIL))))
				(LOOP FOR KEYWORD IN (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL)
				   WITH FORMS = (FLAVOR-ALL-OTHER-DEFAULT-INIT-FORMS FL)
				   WITH INITS = (FLAVOR-ALL-OTHER-DEFAULT-INIT-CONSTANTS FL)
				   WITH TEM
				   COLLECT (STACK-LET ((KEYWORDS (LIST KEYWORD)))
					     `(NIL ,KEYWORD
					       ,(NOT (NOT (MEMBER KEYWORD REQUIRED)))
					       ,@(COND ((MULTIPLE-VALUE-SETQ (NIL TEM)
							  (GET-PROPERTIES FORMS KEYWORDS))
							(LIST TEM))
						       ((MULTIPLE-VALUE-SETQ (NIL TEM)
							  (GET-PROPERTIES INITS KEYWORDS))
							(LIST (QUOTE-UNLESS-CONSTANT TEM)))
						       (T NIL))))))
		       #'STRING-LESSP
		       :KEY #'(LAMBDA (X) (OR (FIRST X) (SECOND X)))))))
	  (LET ((INIT1 (INITIALIZATIONS FL1))
		(INIT2 (INITIALIZATIONS FL2)))
	    (UNLESS (EQUAL INIT1 INIT2)
	      (PRINT-HEADING "Differences in initializations")
	      ;; Compare lists of (variable-name init-keyword required [default-init-form])
	      (FLET ((SAME (I1 I2)
		       (OR (AND (FIRST I1) (EQ (FIRST I1) (FIRST I2)))
			   (AND (SECOND I1) (EQ (SECOND I1) (SECOND I2))))))
		(LOOP WHILE (OR INIT1 INIT2)
		      AS I1 = (CAR INIT1) AS I2 = (CAR INIT2) DO
		  (COND ((EQUAL I1 I2) (POP INIT1) (POP INIT2))
			((SAME I1 I2)
			 ;; Show what changed from I1 to I2
			 (UNLESS (AND (EQ (FIRST I1) (FIRST I2)) (EQ (SECOND I1) (SECOND I2)))
			   ;; Either the variable or the keyword changed, but not both
			   (WHEN (AND (FIRST I1) (SECOND I1))
			     (FORMAT T
				     "~%  Instance variable ~S no longer initialized with ~S"
				     (FIRST I1) (SECOND I1)))
			   (WHEN (AND (FIRST I2) (SECOND I2))
			     (FORMAT T "~%  Instance variable ~S is now initialized with ~S"
				     (FIRST I2) (SECOND I2))))
			 (WHEN (AND (SECOND I1) (EQ (SECOND I1) (SECOND I2))
				    (NOT (EQ (THIRD I1) (THIRD I2))))
			   (FORMAT T "~%  Keyword ~S is ~:[now~;no longer~] required"
				   (SECOND I1) (THIRD I1)))
			 (UNLESS (EQUAL (CDDDR I1) (CDDDR I2))
			   (WHEN (CDDDR I1)
			     (FORMAT T "~%  Default for ~S is no longer ~S"
				     (OR (SECOND I1) (FIRST I1)) (FOURTH I1)))
			   (WHEN (CDDDR I2)
			     (FORMAT T "~%  Default for ~S is now ~S"
				     (OR (SECOND I2) (FIRST I2)) (FOURTH I2))))
			 (POP INIT1)
			 (POP INIT2))
			((AND I1 (OR (NULL I2)
				     (STRING-LESSP (OR (FIRST I1) (SECOND I1))
						   (OR (FIRST I2) (SECOND I2)))))
			 ;; I1 was deleted
			 (IF (FIRST I1)
			     (FORMAT T "~%  Instance variable ~S is no longer initialized~
					  ~@[ with ~S~]~:[~;~2:*~:[ to~;, default~]~* ~S~]"
				     (FIRST I1) (SECOND I1) (CDDDR I1) (FOURTH I1))
			     (FORMAT T "~%  ~S is no longer ~:[an allowed~;a required~] ~
					  init keyword"
				     (SECOND I1) (THIRD I1)))
			 (POP INIT1))
			(T
			 ;; I2 was inserted
			 (IF (FIRST I2)
			     (FORMAT T "~%  Instance variable ~S is now initialized~
					  ~@[ with ~S~]~:[~;~2:*~:[ to~;, default~]~* ~S~]"
				     (FIRST I2) (SECOND I2) (CDDDR I2) (FOURTH I2))
			     (FORMAT T
				     "~%  ~S is now ~:[an allowed~;a required~] init keyword"
				     (SECOND I2) (THIRD I2)))
			 (POP INIT2))))))))
	(SHOW-DIFFERENCE (FLAVOR-ALL-ALLOW-OTHER-KEYS FL1) (FLAVOR-ALL-ALLOW-OTHER-KEYS FL2)
			 "Make-instance allows any keyword"))

      (UNLESS HEADING-PRINTED
	(FUNCALL NO-CHANGE-HEADING *STANDARD-OUTPUT*))
      )))

(DEFUN (DEFFLAVOR ZWEI:SHOW-EFFECT-HANDLER) (FORM)
  (FRESH-LINE)					;Output to typeout-window
  ;; Parse this form into a list of FL structures
  (DESTRUCTURING-BIND (NIL FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS &REST OPTIONS)
		      FORM
    (LET ((FLS (PARSE-DEFFLAVOR FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS
				OPTIONS NIL)))
      (FRESH-LINE)				;PARSE-DEFFLAVOR prints sometimes
      ;; If already defined, pick up data from the existing definition.  Also report
      ;; the immediate effects of this form and construct the hypothetical environment.
      (LET ((ENV (LOOP FOR FL IN FLS
		       AS FLAVOR-NAME = (FLAVOR-NAME FL)
		       AS ALREADY-EXISTS = (FIND-FLAVOR FLAVOR-NAME NIL)
		       DO (WHEN ALREADY-EXISTS
			    (MERGE-FLAVOR-STRUCTURES ALREADY-EXISTS FL))
			  (FORMAT T "Evaluating this would ~:[~;re~]define the flavor ~S~%"
				  ALREADY-EXISTS FLAVOR-NAME)
		       COLLECT (LIST FLAVOR-NAME FL))))
	;; Now show the effects on all flavors that are already defined
	;; User can hit c-Abort if he doesn't want to see so much information
	(LET* ((FIRST T)
	       (FL (FIRST FLS))
	       (FLAVOR-NAME (FLAVOR-NAME FL))
	       (ALREADY-EXISTS (FIND-FLAVOR FLAVOR-NAME NIL)))
	  (WHEN ALREADY-EXISTS
	    (LET* ((IDENTICAL-COMPONENTS
		     (AND (EQUAL (FLAVOR-LOCAL-COMPONENT-PRECEDENCE FL)
				 (FLAVOR-LOCAL-COMPONENT-PRECEDENCE ALREADY-EXISTS))
			  (EQUAL (FLAVOR-REQUIRED-FLAVORS FL)
				 (FLAVOR-REQUIRED-FLAVORS ALREADY-EXISTS))))
		   (IDENTICAL-METHOD-COMBINATION
		     (AND (EQUAL (FLAVOR-LOCAL-METHOD-COMBINATION FL)
				 (FLAVOR-LOCAL-METHOD-COMBINATION ALREADY-EXISTS))
			  (EQUAL (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL)
				 (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES ALREADY-EXISTS))
			  (EQUAL (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS FL)
				 (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS
				   ALREADY-EXISTS))))
		   (IDENTICAL-ACCESSORS
		     (AND (EQUAL (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)
				 (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
			  (EQUAL (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)
				 (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
			  (EQUAL (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)
				 (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
			  (EQUAL (FLAVOR-LOCAL-DEFAULT-HANDLER FL)
				 (FLAVOR-LOCAL-DEFAULT-HANDLER ALREADY-EXISTS))))
		   (IDENTICAL-METHODS (AND IDENTICAL-COMPONENTS IDENTICAL-ACCESSORS
					   IDENTICAL-METHOD-COMBINATION))
		   (IDENTICAL-INITIALIZATIONS
		     (AND IDENTICAL-COMPONENTS
			  (EQUAL (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
				 (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS
				   ALREADY-EXISTS))
			  (EQUAL (FLAVOR-DEFAULT-INIT-PLIST FL)
				 (FLAVOR-DEFAULT-INIT-PLIST ALREADY-EXISTS))
			  (EQUAL (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
				 (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
			  (EQUAL (FLAVOR-INIT-KEYWORDS FL)
				 (FLAVOR-INIT-KEYWORDS ALREADY-EXISTS))
			  (EQUAL (FLAVOR-REQUIRED-INIT-KEYWORDS FL)
				 (FLAVOR-REQUIRED-INIT-KEYWORDS ALREADY-EXISTS))
			  (EQUAL (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
				 (FLAVOR-AREA-KEYWORD-SPECIFIED ALREADY-EXISTS))
			  (OR (NOT (FLAVOR-AREA-KEYWORD-SPECIFIED FL))
			      (EQ (FLAVOR-AREA-KEYWORD FL)
				  (FLAVOR-AREA-KEYWORD ALREADY-EXISTS))))))
	      (SHOW-FLAVOR-DIFFERENCES FLAVOR-NAME NIL ENV
				       #'(LAMBDA (STREAM)
					   (FORMAT STREAM
						   "Changes to ~S after redefining it:~%"
						   FLAVOR-NAME))
				       #'(LAMBDA (STREAM)
					   (FORMAT STREAM
						   "No notable changes to ~S would occur~%"
						   FLAVOR-NAME))
				       IDENTICAL-METHODS IDENTICAL-INITIALIZATIONS)
	      (DO-ALL-COMPOSED-DEPENDENTS (DEPENDENT FL FL)
		(UNLESS (EQ DEPENDENT FLAVOR-NAME)
		  (WHEN FIRST		;Print message because it's slow
		    (FORMAT T "~&[Searching dependent flavors]~%")
		    (SETQ FIRST NIL))
		  (SHOW-FLAVOR-DIFFERENCES DEPENDENT NIL ENV
					   #'(LAMBDA (STREAM)
					       (FORMAT STREAM
						       "Changes to ~S after redefining ~S:~%"
						       DEPENDENT FLAVOR-NAME))
					   #'NULL
					   IDENTICAL-METHODS IDENTICAL-INITIALIZATIONS)))))
	  T)))))
