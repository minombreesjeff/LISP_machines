;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains the defining form for flavors, its supporting
;;; data structures, and its immediate subroutines.  Some global
;;; declarations for the whole flavor system are here, too.

;;; Data structure for a flavor
;;; Stored on the FLAVOR property of a flavor-name, returned by FIND-FLAVOR
(DEFSTRUCT (FLAVOR :NAMED-ARRAY :CONC-NAME
				(:CONSTRUCTOR MAKE-FLAVOR)
				(:ALTERANT NIL) (:COPIER NIL) (:PREDICATE NIL))
  ;; Fields that must correspond to the "instance-descriptor" structure
  ;; understood by the microcode and defined in SYSDEF.  
  INSTANCE-SIZE			;1+ the number of instance variables
  HASH-MASK			;Loganded with the selector.
  (HASH-ADDRESS NIL)		;Address of first entry in handler table.
  NAME				;Symbol which is the name of the flavor (returned by TYPEP)
  ;; End of magic locations
  ;; Fields that record the direct results of DEFFLAVOR
  LOCAL-INSTANCE-VARIABLES	;List of names of instance variables
  LOCAL-COMPONENTS		;List of names of component flavors
  LOCAL-COMPONENT-PRECEDENCE	;Ordering of local component flavors
  LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS	;Alist of (name initial-value-form)
  (LOCAL-INITABLE-INSTANCE-VARIABLES NIL)	;((keyword variable-name)...)
  (LOCAL-READABLE-INSTANCE-VARIABLES NIL)	;((generic variable-name)...)
  (LOCAL-WRITABLE-INSTANCE-VARIABLES NIL)	;((generic variable-name)...)
  ;; Stored on the property list, because they are less commonly specified and
  ;; because they aren't needed after the flavor has been composed:
  ;;  :REQUIRED-FLAVORS :REQUIRED-INSTANCE-VARIABLES :REQUIRED-METHODS :REQUIRED-INIT-KEYWORDS
  ;;  :INIT-KEYWORDS :ORDERED-INSTANCE-VARIABLES :DEFAULT-INIT-PLIST :DOCUMENTATION :MIXTURE
  ;;  :METHOD-COMBINATION :METHOD-ORDER :DEFAULT-HANDLER :LOCATABLE-INSTANCE-VARIABLES
  ;;  :SPECIAL-INSTANCE-VARIABLES :SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS

  ;; Fields that record the direct results of DEFMETHOD
  (METHOD-TABLE NIL)		;((generic method-holder method-holder...)...)
				;<generic> is the name of a generic function or a message

  ;; Functions lexically, but not textually, inside the flavor
  (LOCAL-FUNCTIONS NIL)		;List of method-holders for defun-in-flavors
				;defmacro-in-flavors are in there, too

  ;; Back-pointers
  (LOCAL-DEPENDENTS NIL)	;Names of flavors whose LOCAL-COMPONENTS or REQUIRED-FLAVORS
				;include this flavor.  This information is maintained for
				;use by flavor-examining tools.
  (ALL-COMPOSED-DEPENDENTS NIL)	;Names of flavors that depend directly or indirectly on
				; this flavor, including this flavor itself and including
				; REQUIRED-FLAVORS dependencies, and have been
				; composed sufficiently that they need to be updated if this
				; flavor changes.  All the composing routines maintain this
				; list.  These flavors are listed in approximate dependency
				; order, base-flavor-first.  This flavor itself will be at
				; the front if it's present at all.
				;NOTE: This list can contain names of flavors that aren't
				; defined but have leaked through from other environments.
				; Use the DO-ALL-COMPOSED-DEPENDENTS macro to filter them out.

  ;; Fields resulting from flavor composition
  ALL-INSTANCE-VARIABLES	;List of names in storage order
  ALL-ORDERED-INSTANCE-VARIABLES	;List of names in storage order
  ALL-COMPONENTS		;List of names in inheritance order
			        ;only valid if FLAVOR-COMPONENTS-COMPOSED
  ALL-GENERICS			;List of names of all generics supported by this flavor.
				;For messages, the message keyword appears here.
				;For :COMPATIBLE-MESSAGE generics, both names appear here.
  ALL-LOCAL-FUNCTIONS		;Inherited list of elements, either:
				; (name (DEFUN-IN-FLAVOR flavor cell) function-spec)
				;    for a defun-in-flavor, or
				; (name (SPECIAL expander) function-spec)
				;    for a defmacro-in-flavor
				;name is the local name of the function
				;function-spec is its full name
				;Elements of this list are shared with the flavor
				;from which the local-function is inherited.
				;This list can be directly used as an si:env-functions.
  (HANDLER-TABLE NIL)		;Hash table of handlers, NIL if not composed yet

  ;; Initialization stuff resulting from flavor composition
  TEMPLATE-INSTANCE		;An instance containing the constant defaults
  INSTANCE-AREA			;Form to eval to get area in which to cons instances
  AREA-KEYWORD			;NIL or init-plist keyword that can specify the area 
				;Local if FLAVOR-AREA-KEYWORD-SPECIFIED, otherwise inherited
  ALL-VARIABLE-INIT-KEYWORDS	;((keyword slot-index [bit-mask])...)
  ALL-VARIABLE-DEFAULT-INIT-FORMS	;((default-value-form slot-index bit-mask)...)
  ALL-OTHER-INIT-KEYWORDS	;Combined list of init-keywords that don't init variables
  ALL-OTHER-DEFAULT-INIT-CONSTANTS	;(keyword default-value keyword default-value...)
  ALL-OTHER-DEFAULT-INIT-FORMS  ;(keyword default-value-form keyword default-value-form...)
  ALL-REQUIRED-KEYWORDS		;List of all undefaulted required-init-keywords
  ALL-UNHANDLED-KEYWORDS	;List of init-keywords on default-init-plist but not handled
				;See also INSTANCE-AREA and AREA-KEYWORD, above

  ;; Mapping tables
  MAPPING-TABLE-NAMES		;List of names of instance variables and component flavors
				;in the order they appear in all mapping tables from other
				;flavors to this one
  MAPPING-TABLE-VARIABLE-P	;Vector with T for variables and NIL for components that
				;tells how to interpret MAPPING-TABLE-NAMES
  MAPPING-TABLES		;List of mapping tables from this flavor to others
				;Look at MAPPING-TABLE-NAMES / MAPPING-TABLE-VARIABLE-P
				; of the other flavors to interpret contents of these maps

  ;; Flags, Property list
  (FLAGS 0)			;Fixnum full of useful bits
  (PLIST NIL))			;Property list

;;; `Accessor' for FLAVOR-ALL-COMPONENTS when it might not be composed yet
;;; If the components haven't been composed the result given here may not be
;;; in exactly the correct order.  However, this function will not signal an error.
(DEFUN GET-ALL-FLAVOR-COMPONENTS (FLAVOR-NAME &OPTIONAL ENV)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME T ENV)))
    (OR (FLAVOR-ALL-COMPONENTS FL)
	(LET ((COMPONENTS NIL))
	  (MAP-COMPONENTS-DEPTH-FIRST (LAMBDA (COMPONENT DEPTH TRAIL REAL)
					(IGNORE DEPTH TRAIL)
					(WHEN REAL (PUSHNEW COMPONENT COMPONENTS))
					T)
				      FLAVOR-NAME ENV)
	  (NREVERSE COMPONENTS)))))

;;; Non-consing version of the above:
;;; This can visit the same component multiple times.
(DEFUN MAP-ALL-FLAVOR-COMPONENTS (FLAVOR-NAME FUNCTION &OPTIONAL ENV)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (LET* ((FL (FIND-FLAVOR FLAVOR-NAME T ENV))
	 (ALL-COMPONENTS (FLAVOR-ALL-COMPONENTS FL)))
    (IF ALL-COMPONENTS
	(DOLIST (COMPONENT ALL-COMPONENTS)
	  (FUNCALL FUNCTION COMPONENT))
      (MAP-COMPONENTS-DEPTH-FIRST (LAMBDA (COMPONENT DEPTH TRAIL REAL)
				    (IGNORE DEPTH TRAIL)
				    (WHEN REAL
				      (FUNCALL FUNCTION COMPONENT))
				    T)
				  FLAVOR-NAME ENV))))

(DEFUN FLAVOR-HAS-COMPONENT-P (FLAVOR-NAME COMPONENT-NAME &OPTIONAL ENV)
  (MAP-ALL-FLAVOR-COMPONENTS FLAVOR-NAME (LAMBDA (COMPONENT)
					   (WHEN (EQ COMPONENT COMPONENT-NAME)
					     (RETURN-FROM FLAVOR-HAS-COMPONENT-P T)))
			     ENV)
  ;; Nope, didn't find one.
  NIL)

;;; Accessors for fields of flavor structure stored in the flags and the property list
;;; These are SETF'able of course, but can't be specified in the constructor

(DEFVAR *FLAGS-THAT-SURVIVE-REDEFINITION* 0)	;A bit mask
(DEFVAR *FLAGS-THAT-SURVIVE-COPYING* 0)		;Another bit mask
(DEFVAR *PROPERTIES-LOST-BY-REDEFINITION* NIL)	;A list of indicators
(DEFVAR *PROPERTIES-LOST-BY-COPYING* NIL)	;Another list of indicators

(DEFVAR *FLAVOR-FLAGS* (MAKE-LIST 15))

;SURVIVES-REDEFINITION is NIL if it survives nothing, T if it survives
;both redefinition and copying, or DEFFLAVOR if it survives only copying
(DEFMACRO DEFINE-FLAVOR-FLAG (NAME BIT-NUMBER SURVIVES-REDEFINITION DESCRIPTION)
  (CHECK-TYPE BIT-NUMBER (INTEGER 0 (#.(INTEGER-LENGTH MOST-POSITIVE-FIXNUM)))
	     "a bit number that fits in a positive fixnum")
  (CHECK-TYPE SURVIVES-REDEFINITION (MEMBER T NIL DEFFLAVOR))
  `(PROGN
     (SETF (LDB (BYTE 1 ,BIT-NUMBER) *FLAGS-THAT-SURVIVE-REDEFINITION*)
	   ,(IF (EQ SURVIVES-REDEFINITION T) 1 0))
     (SETF (LDB (BYTE 1 ,BIT-NUMBER) *FLAGS-THAT-SURVIVE-COPYING*)
	   ,(IF SURVIVES-REDEFINITION 1 0))
     (UNLESS (> (LENGTH *FLAVOR-FLAGS*) ,BIT-NUMBER)
       (SETQ *FLAVOR-FLAGS*
	     (APPEND *FLAVOR-FLAGS*
		     (MAKE-LIST (1+ (- ,BIT-NUMBER (LENGTH *FLAVOR-FLAGS*)))))))
     (SETF (NTH ,BIT-NUMBER *FLAVOR-FLAGS*) ',DESCRIPTION)
     (DEFSUBST ,NAME (FL)
       (LDB-TEST (BYTE 1 ,BIT-NUMBER) (FLAVOR-FLAGS FL)))))

(DEFPROP DEFINE-FLAVOR-FLAG DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;SURVIVES-REDEFINITION is NIL if it survives nothing, T if it survives
;both redefinition and copying, or DEFFLAVOR if it survives only copying
(DEFMACRO DEFINE-FLAVOR-PROPERTY (NAME INDICATOR SURVIVES-REDEFINITION)
  (CHECK-TYPE SURVIVES-REDEFINITION (MEMBER T NIL DEFFLAVOR))
  `(PROGN
     (SETQ *PROPERTIES-LOST-BY-REDEFINITION*
	   (,(IF (EQ SURVIVES-REDEFINITION T) `DELETE `ADJOIN)
	    ',INDICATOR *PROPERTIES-LOST-BY-REDEFINITION*))
     (SETQ *PROPERTIES-LOST-BY-COPYING*
	   (,(IF SURVIVES-REDEFINITION `DELETE `ADJOIN)
	    ',INDICATOR *PROPERTIES-LOST-BY-COPYING*))
     (DEFSUBST ,NAME (FL)
       (GETF* (FLAVOR-PLIST FL) ',INDICATOR))))

(DEFPROP DEFINE-FLAVOR-PROPERTY DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;This has to be a subst rather than a macro.  If it's a macro, its DEFINE-SETF-METHOD is
;never seen because the macro gets expanded as part of expanding the subst that calls it.
;That macro-expansion is inherently necessary, it seems, to get the subst arguments
;properly open-coded.
(DEFSUBST GETF* (PLIST INDICATOR)
  (GETF PLIST INDICATOR))

;; The purpose of this hair is to avoid taking up space for null properties
;; It's a little more complicated than it ought to be because disembodied property
;; lists were suddenly removed from SCL with no warning.
(DEFINE-SETF-METHOD GETF* (PLIST INDICATOR)
  (LET ((PLIST-VAR (GENSYM))
	(INDICATOR-VAR (GENSYM))
	(VALUE-VAR (GENSYM)))
    (VALUES (LIST PLIST-VAR INDICATOR-VAR)
	    (LIST `(LOCF ,PLIST) INDICATOR)
	    (LIST VALUE-VAR)
	    `(PUT-OR-REMPROP ,PLIST-VAR ,INDICATOR-VAR ,VALUE-VAR)
	    `(GETF (LOCATION-CONTENTS ,PLIST-VAR) ,INDICATOR-VAR))))

(DEFUN PUT-OR-REMPROP (PLACE INDICATOR VALUE)
  (IF VALUE
      (SETF (GETF (LOCATION-CONTENTS PLACE) INDICATOR) VALUE)
      (REMF (LOCATION-CONTENTS PLACE) INDICATOR)))

;;;; Define the flavor flags and properties

;All set for MAKE-INSTANCE
(DEFINE-FLAVOR-FLAG FLAVOR-INSTANTIABLE 0 NIL "Instantiable")
;Instances have actually been created
(DEFINE-FLAVOR-FLAG FLAVOR-INSTANTIATED 1 T "Instantiated")
;ALL-COMPONENTS has been composed
(DEFINE-FLAVOR-FLAG FLAVOR-COMPONENTS-COMPOSED 2 NIL "Components composed")
;HANDLER-TABLE has been composed
(DEFINE-FLAVOR-FLAG FLAVOR-METHODS-COMPOSED 3 NIL "Methods composed")
;Initialization has been composed
(DEFINE-FLAVOR-FLAG FLAVOR-INITIALIZATIONS-COMPOSED 4 NIL "Initializations composed")
;:ABSTRACT-FLAVOR option specified
(DEFINE-FLAVOR-FLAG FLAVOR-IS-ABSTRACT 5 DEFFLAVOR "Abstract")
;:NO-VANILLA-FLAVOR option specified
(DEFINE-FLAVOR-FLAG FLAVOR-WITHOUT-VANILLA 6 DEFFLAVOR "No Vanilla")
;AREA-KEYWORD locally specified
(DEFINE-FLAVOR-FLAG FLAVOR-AREA-KEYWORD-SPECIFIED 7 DEFFLAVOR ":AREA-KEYWORD specified")
;bit 8 spare
;:ALLOW-OTHER-KEYS inherited
(DEFINE-FLAVOR-FLAG FLAVOR-ALL-ALLOW-OTHER-KEYS 9 NIL ":ALLOW-OTHER-KEYS")
;Compatibility with old :INIT message
(DEFINE-FLAVOR-FLAG FLAVOR-HAS-INIT-METHOD 10 NIL "Has :INIT method")
(DEFINE-FLAVOR-FLAG FLAVOR-ORDERED-INSTANCE-VARIABLES-COMPOSED 11 NIL
		    "Ordered instance variables composed")
;FLAVOR-MIXTURE is non-NIL
(DEFINE-FLAVOR-FLAG FLAVOR-HAS-MIXTURE 12 DEFFLAVOR ":MIXTURE")
;True if any combined methods exist
(DEFINE-FLAVOR-FLAG FLAVOR-HAS-COMBINED-METHODS 13 T "Has combined methods")
;True if COMPILE-FLAVOR-METHODS has been done (only for human interest)
(DEFINE-FLAVOR-FLAG FLAVOR-HAS-COMPILE-FLAVOR-METHODS 14 T "COMPILE-FLAVOR-METHODS executed")

(DEFINE-FLAVOR-PROPERTY FLAVOR-REQUIRED-FLAVORS :REQUIRED-FLAVORS DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-REQUIRED-INSTANCE-VARIABLES :REQUIRED-INSTANCE-VARIABLES
			DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-REQUIRED-METHODS :REQUIRED-METHODS DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-REQUIRED-INIT-KEYWORDS :REQUIRED-INIT-KEYWORDS DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-INIT-KEYWORDS :INIT-KEYWORDS DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-DEFAULT-INIT-PLIST :DEFAULT-INIT-PLIST DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-DOCUMENTATION :DOCUMENTATION DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-ADDITIONAL-INSTANCE-VARIABLES
			ADDITIONAL-INSTANCE-VARIABLES NIL)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES
			:ORDERED-INSTANCE-VARIABLES DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES
			:LOCATABLE-INSTANCE-VARIABLES DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES
			:SPECIAL-INSTANCE-VARIABLES DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS
			:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-MIXTURE :MIXTURE DEFFLAVOR)  ;encoded form of :MIXTURE option
(DEFINE-FLAVOR-PROPERTY FLAVOR-MIXTURE-DEFAULTS FLAVOR-MIXTURE-DEFAULTS NIL)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-METHOD-ORDER :METHOD-ORDER DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-DEFAULT-HANDLER :DEFAULT-HANDLER DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-METHOD-COMBINATION :METHOD-COMBINATION DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-CONSTRUCTORS :CONSTRUCTOR DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED :FUNCTIONS DEFFLAVOR)
(DEFINE-FLAVOR-PROPERTY FLAVOR-OBSOLETE-MAPPING-TABLES OBSOLETE-MAPPING-TABLES T)

(SETQ *PROPERTIES-LOST-BY-REDEFINITION*		;Localize this list
      (COPY-LIST *PROPERTIES-LOST-BY-REDEFINITION* PERMANENT-STORAGE-AREA))

(SETQ *PROPERTIES-LOST-BY-COPYING*		;Localize this list too
      (COPY-LIST *PROPERTIES-LOST-BY-COPYING* PERMANENT-STORAGE-AREA))

;Named-structure handler for FLAVOR structure, to make it print and describe nicer
(DEFSELECT ((FLAVOR NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (FLAVOR STREAM IGNORE IGNORE)
   (SI:PRINTING-RANDOM-OBJECT (FLAVOR STREAM)
     (FORMAT STREAM "FLAVOR ~S" (FLAVOR-NAME FLAVOR))))
  (:DESCRIBE (FLAVOR)
   (LET ((*PRINT-LENGTH* 8))			;Disaster otherwise
     (DESCRIBE-DEFSTRUCT-WITH-FLAGS FLAVOR 'FLAVOR *FLAVOR-FLAGS*))))

(DEFVAR-RESETTABLE *INSIDE-WITH-PENDING-DW-UPDATES* NIL)

;;; The processing of any pending updates on warm boot is handled
;;; by DW's *pending-type-changes*.
(DEFVAR-RESETTABLE *PENDING-DW-UPDATES* NIL)

;;; Have the outermost guy do the actual updates.  Each level that
;;; either does a batch of updates, or which does an actual installation
;;; of a flavor change, should use this macro.
(DEFMACRO WITH-PENDING-DW-UPDATES (&BODY BODY)
  (LET ((OLD-VALUE (GENSYMBOL "OLD-UPDATE-FLAG-")))
    `(LET ((,OLD-VALUE *INSIDE-WITH-PENDING-DW-UPDATES*)
	   (*INSIDE-WITH-PENDING-DW-UPDATES* T))
       ;; Only bind the list if we're the outermost.
       (LET-IF (NOT ,OLD-VALUE)
	       ((*PENDING-DW-UPDATES* NIL))
	 (UNWIND-PROTECT
	     (PROGN ,@BODY)
	   (WITHOUT-ABORTS ("The mouse sensitivity tables are being update to reflect the~@
			     changes in the flavor type hierarchy.~@
~@
			     If you abort now, the tables may be left in an inconsistent~@
			     state, with only some of the changes in effect.")
	     (UNLESS ,OLD-VALUE
	       (DO-PENDING-DW-UPDATES))
	     ))))))

(DEFUN DO-PENDING-DW-UPDATES ()
  (DOLIST (UPDATE *PENDING-DW-UPDATES*)
    (DW:FINISH-TYPE-REDEFINITION UPDATE))
  (SETQ *PENDING-DW-UPDATES* NIL))

;; Interface with *pending-dw-updates*.

(DEFUN NOTE-CHANGE-FOR-DW (FLAVOR-NAME)
  (UNLESS *INSIDE-WITH-PENDING-DW-UPDATES*
    (CERROR "Continue updating ~S."
	    "Internal flavors/DW error: Attempt to redefine a flavor~@
	     without arranging to tell the presentation substrate when we're done.~@
	     The immediately affected type is ~S."
	    FLAVOR-NAME))
  (UNLESS (MEMBER FLAVOR-NAME *PENDING-DW-UPDATES*)
    (PROG1 (DW:PREPARE-FOR-TYPE-CHANGE FLAVOR-NAME)
	   (PUSH FLAVOR-NAME *PENDING-DW-UPDATES*))))

(DEFVAR *TRANSFORM-FLAVOR-WARNINGS*)

(DEFMACRO WITH-TRANSFORM-FLAVOR-WARNINGS (&BODY BODY)
  `(LET ((*TRANSFORM-FLAVOR-WARNINGS* NIL))
     (UNWIND-PROTECT
	 (PROGN . ,BODY)
       (PRINT-FLAVOR-TRANSFORMATION-WARNINGS))))

;;; Iterate over all composed dependents of a flavor, skipping undefined ones
(DEFMACRO DO-ALL-COMPOSED-DEPENDENTS ((DEPENDENT-FLAVOR-NAME-VARIABLE
				       DEPENDENT-FLAVOR-STRUCTURE-VARIABLE
				       COMPONENT-FLAVOR-STRUCTURE
				       &OPTIONAL ENV)
				      &BODY BODY)
  `(DOLIST (,DEPENDENT-FLAVOR-NAME-VARIABLE
	    (FLAVOR-ALL-COMPOSED-DEPENDENTS ,COMPONENT-FLAVOR-STRUCTURE))
     (LET ((,DEPENDENT-FLAVOR-STRUCTURE-VARIABLE
	    (FIND-FLAVOR ,DEPENDENT-FLAVOR-NAME-VARIABLE NIL
			 ,@(AND ENV `(,ENV)))))
       (WHEN ,DEPENDENT-FLAVOR-STRUCTURE-VARIABLE
	 ,@BODY))))

;;; Take care of the case where the compile-time environment is the run-time environment 
(DEFMACRO STANDARDIZE-ENV (ENV)
  `(AND (EQ ,ENV 'COMPILE)
	(NOT UNDO-DECLARATIONS-FLAG)
	(SETQ ,ENV NIL)))

;;; Perhaps this should be a standard SCL extension?  Anyway, I need it here.
(DEFINE-MODIFY-MACRO APPENDF (&REST LISTS) APPEND)

;;; Area in which to create semipermanent data for this environment
;;; ENV must be standardized already
(DEFSUBST FLAVOR-AREA (ENV)
  (IF ENV DEFAULT-CONS-AREA *FLAVOR-AREA*))

;;; General interface for mapping FLAVOR-NAME to flavor structure
;;; ERROR-P can be one of the following:
;;;  NIL  if flavor not found, return NIL.
;;;  T  if flavor not found, signal an error.
;;;  CREATE-IN-ENV  if flavor not found in ENV, but exists in current world,
;;;      then copy it into ENV.  If not found anywhere, signal an error.
;;; ENV (an argument that many of the flavor-system functions take) is the environment
;;; in which to look up flavors, generics, and methods.  It can be one of the following:
;;;  NIL  the run-time environment
;;;  COMPILE  the compile-time environment
;;;  an alist ((name flavor-structure generic-structure (method definition)...)...)
;;;   which allows replacement flavors or generics, and for a flavor allows
;;;   methods to be added or deleted (definition of NIL)
;;;   Note that if you put an entry in this alist for a generic whose name is a list,
;;;   you had better standardize the name first by calling STANDARDIZE-GENERIC-FUNCTION-NAME.
(DEFUN FIND-FLAVOR (FLAVOR-NAME &OPTIONAL (ERROR-P T) (ENV NIL))
  (CHECK-TYPE FLAVOR-NAME (AND SYMBOL (NOT NULL)))
  (CHECK-TYPE ERROR-P (MEMBER T NIL CREATE-IN-ENV))
  (STANDARDIZE-ENV ENV)
  (OR (COND ((EQ ENV 'COMPILE) (COMPILER:FILE-DECLARATION FLAVOR-NAME 'FLAVOR))
	    (ENV (SECOND (ASSOC FLAVOR-NAME ENV))))
      (AND ENV (EQ ERROR-P 'CREATE-IN-ENV)
	   (LET ((FL (GET FLAVOR-NAME 'FLAVOR)) ASSOC)
	     (WHEN FL
	       (SETQ FL (COPY-FLAVOR FL NIL))
	       (COND ((EQ ENV 'COMPILE)
		      (COMPILER:FILE-DECLARE FLAVOR-NAME 'FLAVOR FL))
		     ((SETQ ASSOC (ASSOC FLAVOR-NAME ENV))
		      (SETF (SECOND ASSOC) FL))
		     (T
		      (NCONC ENV (LIST (LIST FLAVOR-NAME FL)))))
	       FL)))
      (GET FLAVOR-NAME 'FLAVOR)
      (AND ERROR-P (ERROR 'FLAVOR-NOT-FOUND :NAME FLAVOR-NAME))))

;;;; DEFFLAVOR and his friends

(DEFPROP DEFFLAVOR "Flavor" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFFLAVOR (FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS &REST OPTIONS
		     &ENVIRONMENT ENV)
  (DECLARE (ZWEI:INDENTATION 1 7 3 1))
  ;; Optimize all forms that appear in the DEFFLAVOR, so they will interpret with
  ;; fewer page faults, and so more constants will be recognized.
  ;; Don't expand inline forms, because that tends to make them interpret slower.
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR))
    (WHEN (LISTP INSTANCE-VARIABLES)
      (SETQ INSTANCE-VARIABLES
	    (LOOP FOR IV IN INSTANCE-VARIABLES
		  COLLECT (IF (AND (LISTP IV) (LISTP (CDR IV)) (NULL (CDDR IV)))
			      (LIST (FIRST IV)
				    (COMPILER:OPTIMIZE-TOP-LEVEL-FORM (SECOND IV)
				      :ENVIRONMENT ENV :DO-OPTIMIZERS T :DO-MACRO-EXPANSION T
				      :DO-NAMED-CONSTANTS T :DO-CONSTANT-FOLDING T
				      :DO-STYLE-CHECKING T :DO-FUNCTION-ARGS T :REPEAT T))
			      IV))))
    (DOLIST (OPTION OPTIONS)
      (WHEN (AND (LISTP OPTION) (EQ (CAR OPTION) ':DEFAULT-INIT-PLIST))
	(SETQ OPTIONS (SUBSTITUTE (CONS ':DEFAULT-INIT-PLIST
					(LOOP FOR (KEY VAL) ON (CDR OPTION) BY 'CDDR
					      COLLECT KEY
					      COLLECT (COMPILER:OPTIMIZE-TOP-LEVEL-FORM VAL
							:ENVIRONMENT ENV :DO-OPTIMIZERS T
							:DO-MACRO-EXPANSION T
							:DO-NAMED-CONSTANTS T
							:DO-CONSTANT-FOLDING T
							:DO-STYLE-CHECKING T
							:DO-FUNCTION-ARGS T :REPEAT T)))
				  OPTION OPTIONS)))))
  (WHEN UNDO-DECLARATIONS-FLAG
    ;; Add this flavor to the compile-time environment
    ;; Note that we cannot save the result of PARSE-DEFFLAVOR in the BIN file,
    ;; but must redo the parse at load time, for too many reasons to list here
    (DEFFLAVOR-INTERNAL FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS OPTIONS T))
  ;; At load time, add this flavor to the run-time environment
  ;; and define any accessors that are substs rather than generic functions
  (PROGNIFY
    `((DEFFLAVOR-INTERNAL ',FLAVOR-NAME ',INSTANCE-VARIABLES
			  ',COMPONENT-FLAVORS ',OPTIONS NIL)
      ,@(ACCESSOR-SUBSTS FLAVOR-NAME INSTANCE-VARIABLES OPTIONS))))

(DEFUN DEFFLAVOR-INTERNAL (FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS OPTIONS
			   COMPILE-TIME)
  (LET ((FLS (PARSE-DEFFLAVOR FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS OPTIONS
			      COMPILE-TIME)))
    (PROG1 (DEFFLAVOR-INTERNAL-1 (FIRST FLS) COMPILE-TIME)
	   (DOLIST (FL (REST FLS))
	     (DEFFLAVOR-INTERNAL-1 FL COMPILE-TIME)))))

;;; COMPILE-TIME means that the results of this will be discarded when the compilation is over
;;;   UNDO-DECLARATIONS-FLAG must be set and COMPILER:FILE-LOCAL-DECLARATIONS must be bound.
;;; Local attributes of the flavor are generally not copied into *FLAVOR-AREA* since
;;; they aren't usually referenced at run time.
;;; The value is a list of FLs, with the specified flavor first on the list
;;; Additional FLs come from the :MIXTURE option
(DEFUN PARSE-DEFFLAVOR (FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS OPTIONS
			COMPILE-TIME
			&AUX (ENV (AND COMPILE-TIME 'COMPILE))
			     (AREA (FLAVOR-AREA ENV))
			     (FL (LET ((DEFAULT-CONS-AREA AREA))
				   (MAKE-FLAVOR :NAME FLAVOR-NAME)))
			     LOCAL-INSTANCE-VARIABLES (COMPONENT-ORDER COMPONENT-FLAVORS)
			     FLAVOR-OPTION ARGS
			     (READABLE-INSTANCE-VARIABLES NIL)
			     (WRITABLE-INSTANCE-VARIABLES NIL)
			     (LOCATABLE-INSTANCE-VARIABLES NIL)
			     (CONC-NAME T)
			     (GETTABLE-INSTANCE-VARIABLES NIL)
			     (SETTABLE-INSTANCE-VARIABLES NIL)
			     (INITABLE-INSTANCE-VARIABLES NIL)
			     (ADDITIONAL-FLAVORS NIL)
			     (COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
			     (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR))

  (CHECK-TYPE FLAVOR-NAME (AND SYMBOL (NOT NULL)))
  (CHECK-TYPE INSTANCE-VARIABLES LIST)
  (CHECK-TYPE COMPONENT-FLAVORS LIST)

  ;; Process the positional arguments.  Check that flavor names are symbols and
  ;; instance variables are valid variable names.  Collect instance variable names
  ;; and instance variable initial value forms separately.
  (LET ((VARS NIL) (INITS NIL))
    (DOLIST (ITEM INSTANCE-VARIABLES)
      (LET ((VAR (IF (ATOM ITEM) ITEM (CAR ITEM))))
	(SI:CHECK-SYMBOL-SETABILITY VAR "declare an instance variable")
	(COND ((MEMBER VAR VARS)
	       (WARN "The instance variable ~S is specified twice.~@
		      Only one instance variable with that name will be created."
		     VAR))
	      (T
	       (PUSH VAR VARS)
	       (UNLESS (ATOM ITEM)
		 (PUSH ITEM INITS))))))
    (SETQ LOCAL-INSTANCE-VARIABLES (NREVERSE VARS))
    (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLES FL) LOCAL-INSTANCE-VARIABLES)
    (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL) (NREVERSE INITS)))
  (LOOP FOR F IN COMPONENT-FLAVORS DO
    (UNLESS (AND (SYMBOLP F) (NEQ F NIL))
      (ERROR "Attempt to declare ~S as a component flavor
of ~S.  Flavor names must be symbols and not NIL." F FLAVOR-NAME)))

  ;; Option parsing
  (FLET ((NO-ARGS ()
	   (WHEN ARGS
	     (WARN "The flavor option ~S does not accept arguments." FLAVOR-OPTION)))
	 (SINGLE-ARG ()
	   (UNLESS (= (LENGTH ARGS) 1)
	     (WARN "The flavor option ~S requires exactly one argument." FLAVOR-OPTION))
	   (FIRST ARGS))
	 (SOME-ARGS (&OPTIONAL (MIN 1) MAX)
	   (WHEN (< (LENGTH ARGS) MIN)
	     (WARN "The flavor option ~S requires at least ~R argument~:P."
		   FLAVOR-OPTION MIN))
	   (AND MAX (> (LENGTH ARGS) MAX)
		(WARN "The flavor option ~S accepts at most ~D arguments."
		      FLAVOR-OPTION MAX))
	   ARGS)
	 (INSTANCE-VARIABLES-ARG (&OPTIONAL PAIR-ALLOWED)
	   (IF (NULL ARGS)
	       LOCAL-INSTANCE-VARIABLES
	       (LET ((ERROR (LOOP FOR ARG IN ARGS
				  AS VAR = (COND ((AND PAIR-ALLOWED (CONSP ARG))
						  (UNLESS (AND (= (LENGTH ARG) 2)
							       (SYMBOLP (FIRST ARG)))
						    (WARN "The flavor option ~S requires ~
						      that either a symbol or a list of~@
						      two symbols be specified, but ~S was ~
						      specified."
							  FLAVOR-OPTION ARG))
						  (SECOND ARG))
						 (T ARG))
				  UNLESS (OR (MEMBER VAR LOCAL-INSTANCE-VARIABLES)
					     (LOOP FOR OPTION IN OPTIONS
					       THEREIS (AND (LISTP OPTION)
							    (EQ (CAR OPTION)
								':REQUIRED-INSTANCE-VARIABLES)
							    (MEMBER VAR (CDR OPTION)))))
				    COLLECT ARG)))
		 (WHEN ERROR
		   (WARN "The flavor option ~S was specified with ~{~S~^, ~},~@
			      which may ~:[be~;contain~] ~
			      ~[~1;a ~]misspelled instance variable name~:P.  ~
			      ~:*~[~1;It~:;They~] will be ignored."
			 FLAVOR-OPTION ERROR (SOME #'CONSP ERROR) (LENGTH ERROR)))
		 ;; Only return legitimate instance variable names, since other parts
		 ;; of the code assume these really appear in flavor-all-instance-variables.
		 (SET-DIFFERENCE ARGS ERROR))))
	 (STANDARDIZE-GENERIC-FUNCTION-NAMES (LIST)
	   (LOOP FOR GENERIC IN LIST
		 COLLECT (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV))))
    (LOOP FOR (OPTION . REST) ON OPTIONS DO
      (IF (ATOM OPTION)
	  (SETQ FLAVOR-OPTION OPTION ARGS NIL)
	  (SETQ FLAVOR-OPTION (CAR OPTION) ARGS (CDR OPTION)))
      ;; Check for flavor options specified twice.  Some are allowed, some are not.
      (UNLESS (MEMBER FLAVOR-OPTION
		      '(:GETTABLE-INSTANCE-VARIABLES :INITABLE-INSTANCE-VARIABLES
			:LOCATABLE-INSTANCE-VARIABLES :ORDERED-INSTANCE-VARIABLES
			:READABLE-INSTANCE-VARIABLES :REQUIRED-INSTANCE-VARIABLES
			:SETTABLE-INSTANCE-VARIABLES :SPECIAL-INSTANCE-VARIABLES
			:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS
			:WRITABLE-INSTANCE-VARIABLES
			:REQUIRED-FLAVORS :CONSTRUCTOR :DEFAULT-INIT-PLIST
			:INIT-KEYWORDS :REQUIRED-INIT-KEYWORDS
			:FUNCTIONS :METHOD-COMBINATION :METHOD-ORDER :REQUIRED-METHODS))
	(DOLIST (OTHER REST)
	  (WHEN (EQ (IF (ATOM OTHER) OTHER (CAR OTHER)) FLAVOR-OPTION)
	    (WARN "The flavor option ~S is specified twice." FLAVOR-OPTION))))
      ;; Check for obsolete defflavor options that get specific messages.
      ;; This allows them to turn into options implemented by the case statement below.
      (CASE FLAVOR-OPTION
	(:INCLUDED-FLAVORS
	  (WARN "The :INCLUDED-FLAVORS flavor option is no longer supported.
Use :REQUIRED-FLAVORS or make these flavors into ordinary components.
~{~S~^, ~} ~:[have~;has~] been appended to ~S's components."
		ARGS (= (LENGTH ARGS) 1) FLAVOR-NAME)
	  (SETQ COMPONENT-FLAVORS (APPEND COMPONENT-FLAVORS ARGS)
		COMPONENT-ORDER COMPONENT-FLAVORS)
	  (GO SI:NEXT-LOOP))
	(:OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES
	  (WARN "The :OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES flavor option is obsolete.
It has been superseded by :WRITABLE-INSTANCE-VARIABLES.
You might want to specify :LOCATABLE-INSTANCE-VARIABLES as well, if you use LOCF.")
	  (SETQ FLAVOR-OPTION ':WRITABLE-INSTANCE-VARIABLES))
	(:ACCESSOR-PREFIX
	  (WARN "The :ACCESSOR-PREFIX flavor option is obsolete.
It has been superseded by :CONC-NAME.")
	  (SETQ FLAVOR-OPTION ':CONC-NAME))
	(:SELECT-METHOD-ORDER
	  (WARN "The :SELECT-METHOD-ORDER flavor option is obsolete.
It has been renamed to :METHOD-ORDER.")
	  (SETQ FLAVOR-OPTION ':METHOD-ORDER)))

      ;; Now parse the non-obsolete options
      ;; Clauses are sorted by categories and alphabetical within categories
      ;; Keys of all clauses are repeated in the error message at the end
      (CASE FLAVOR-OPTION
	;; Instance-variable options
	(:CONC-NAME
	  (SOME-ARGS 0 1)
	  (SETQ CONC-NAME (IF ARGS (FIRST ARGS) T)))
	(:GETTABLE-INSTANCE-VARIABLES
	  ;; Compatibility with old message-passing system
	  (APPENDF GETTABLE-INSTANCE-VARIABLES (INSTANCE-VARIABLES-ARG T)))
	(:INITABLE-INSTANCE-VARIABLES
	  (APPENDF INITABLE-INSTANCE-VARIABLES (INSTANCE-VARIABLES-ARG T)))
	(:LOCATABLE-INSTANCE-VARIABLES
	  (APPENDF LOCATABLE-INSTANCE-VARIABLES (INSTANCE-VARIABLES-ARG T)))
	(:ORDERED-INSTANCE-VARIABLES
	  (APPENDF (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL) (INSTANCE-VARIABLES-ARG)))
	(:READABLE-INSTANCE-VARIABLES
	  (APPENDF READABLE-INSTANCE-VARIABLES (INSTANCE-VARIABLES-ARG T)))
	(:REQUIRED-INSTANCE-VARIABLES
	  (APPENDF (FLAVOR-REQUIRED-INSTANCE-VARIABLES FL) (SOME-ARGS)))
	(:SETTABLE-INSTANCE-VARIABLES
	  ;; Compatibility with old message-passing system
	  (APPENDF SETTABLE-INSTANCE-VARIABLES (INSTANCE-VARIABLES-ARG T)))
	(:SPECIAL-INSTANCE-VARIABLES
	  (APPENDF (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL) (INSTANCE-VARIABLES-ARG)))
	(:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS
	  (APPENDF (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS FL)
		   (STANDARDIZE-GENERIC-FUNCTION-NAMES (SOME-ARGS))))
	(:WRITABLE-INSTANCE-VARIABLES
	  (APPENDF WRITABLE-INSTANCE-VARIABLES (INSTANCE-VARIABLES-ARG T)))

	;; Component-flavors options
	(:COMPONENT-ORDER
	  (SETQ COMPONENT-ORDER (SOME-ARGS)))
	(:MIXTURE
	  (SETF (VALUES (FLAVOR-MIXTURE FL) ADDITIONAL-FLAVORS)
		(ENCODE-FLAVOR-MIXTURE FLAVOR-NAME ARGS))
	  (SETF (FLAVOR-HAS-MIXTURE FL) T))
	(:NO-VANILLA-FLAVOR
	  (NO-ARGS)
	  (SETF (FLAVOR-WITHOUT-VANILLA FL) T))
	(:REQUIRED-FLAVORS
	  (APPENDF (FLAVOR-REQUIRED-FLAVORS FL) (SOME-ARGS)))

	;; Instance-creation options
	(:AREA-KEYWORD
	  (SETF (FLAVOR-AREA-KEYWORD FL) (SINGLE-ARG))
	  (SETF (FLAVOR-AREA-KEYWORD-SPECIFIED FL) T))
	(:CONSTRUCTOR
	  (COND ((OR (NULL ARGS) (CDDR ARGS))
		 (WARN "The flavor option :CONSTRUCTOR requires one or two arguments."))
		((NOT (SYMBOLP (FIRST ARGS)))
		 (WARN "~S is not a valid name for a constructor; a symbol is required"
		       (FIRST ARGS)))
		((NOT (LISTP (SECOND ARGS)))
		 (WARN "~S is not a valid argument list for the constructor ~S"
		       (SECOND ARGS) (FIRST ARGS)))
		(T
		 (PUSH (CONS (FIRST ARGS) (IF (CDR ARGS) (SECOND ARGS) 'ALL-VARS))
		       (FLAVOR-CONSTRUCTORS FL)))))
	(:DEFAULT-INIT-PLIST
	  (UNLESS (EVENP (LENGTH ARGS))
	    (WARN "The :DEFAULT-INIT-PLIST flavor option requires an even number of
arguments.  You didn't specify a value after ~S, so NIL will be assumed."
		  (CAR (LAST ARGS)))
	    (SETQ ARGS (APPEND ARGS '(NIL))))
	  (APPENDF (FLAVOR-DEFAULT-INIT-PLIST FL) (SOME-ARGS)))
	(:INIT-KEYWORDS
	  (APPENDF (FLAVOR-INIT-KEYWORDS FL) (SOME-ARGS)))
	(:REQUIRED-INIT-KEYWORDS
	  (APPENDF (FLAVOR-REQUIRED-INIT-KEYWORDS FL) (SOME-ARGS)))

	;; Miscellaneous options
	(:ABSTRACT-FLAVOR
	  (NO-ARGS)
	  (SETF (FLAVOR-IS-ABSTRACT FL) T))
	(:DEFAULT-HANDLER
	  ;; There are no uses of this in the system, and the documentation says
	  ;; that it is preferable to use a :unclaimed-message method.  However,
	  ;; it's so easy to implement this that we might as well be compatible.
	  (SETF (FLAVOR-LOCAL-DEFAULT-HANDLER FL) (SINGLE-ARG)))
	(:DOCUMENTATION
	  (SETF (FLAVOR-DOCUMENTATION FL) (SOME-ARGS)))
	(:FUNCTIONS
	  (DOLIST (NAME (SOME-ARGS))
	    (UNLESS (SYMBOLP NAME)
	      (WARN "(:FUNCTIONS ~S) ignored because the name is not a symbol." NAME)
	      (SETQ ARGS (REMOVE NAME ARGS))))
	  (APPENDF (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED FL) ARGS))

	(:METHOD-COMBINATION
	  ;; Identify old syntax and translate to new syntax with a warning
	  (WHEN (AND (LISTP (FIRST ARGS))
		     ( (LENGTH (FIRST ARGS)) 3)
		     (SYMBOLP (FIRST (FIRST ARGS)))
		     (GETDECL (FIRST (FIRST ARGS)) 'METHOD-COMBINATION))
	    (SETQ ARGS (LOOP FOR (TYPE ORDER . MESSAGES) IN ARGS
			     NCONC (LOOP FOR MESSAGE IN MESSAGES
					 COLLECT MESSAGE
					 COLLECT (LIST TYPE ORDER))))
	    (WARN "The obsolete syntax ~S~%has been replaced by ~S."
		  OPTION (CONS ':METHOD-COMBINATION ARGS)))
	  ;; Store the option in the form of an alist
	  (APPENDF (FLAVOR-LOCAL-METHOD-COMBINATION FL)
		   (LOOP FOR (GENERIC METHOD-COMBINATION) ON (SOME-ARGS) BY 'CDDR
			 DO (UNLESS (TYPEP GENERIC 'GENERIC-FUNCTION-NAME)
			      (WARN "The ~S flavor option takes its arguments in pairs,
each a generic-function name followed by a method-combination type.  You
specified ~S where a generic-function name was expected."
				    FLAVOR-OPTION GENERIC))
			    (WHEN (NULL METHOD-COMBINATION)
			      (WARN "The ~S flavor option takes its arguments in pairs,
each a generic-function name followed by a method-combination type.  You
specified an odd number of arguments.  :DAEMON method combination will be
assumed for the ~S generic function."
				    FLAVOR-OPTION GENERIC)
			      (SETQ METHOD-COMBINATION ':DAEMON))
			    (UNLESS (LISTP METHOD-COMBINATION)
			      (SETQ METHOD-COMBINATION (LIST METHOD-COMBINATION)))
			    (UNLESS (AND (SYMBOLP (FIRST METHOD-COMBINATION))
					 (GETDECL (FIRST METHOD-COMBINATION)
						  'METHOD-COMBINATION))
			      (WARN "The method combination type ~S declared for the~@
					~S generic function is not currently defined."
				    (FIRST METHOD-COMBINATION) GENERIC))
			 COLLECT (CONS (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV)
				       METHOD-COMBINATION))))
	(:METHOD-ORDER
	  (APPENDF (FLAVOR-LOCAL-METHOD-ORDER FL)
		   (STANDARDIZE-GENERIC-FUNCTION-NAMES (SOME-ARGS))))
	(:REQUIRED-METHODS
	  (APPENDF (FLAVOR-REQUIRED-METHODS FL)
		   (STANDARDIZE-GENERIC-FUNCTION-NAMES (SOME-ARGS))))
	(OTHERWISE
	  ;; An explicit error message because the one automatically generated by ECASE
	  ;; is not formatted nicely enough.  It's intentional that the list of valid
	  ;; options does not include the ones for old-flavor-system compatibility.
	  (WARN "~S is an unrecognized flavor option and will be ignored.
Valid options include instance-variable options:
~{~<~%  ~2:;~S~>~^, ~}
Component-flavor options:
~{~<~%  ~2:;~S~>~^, ~}
Instance-creation options:
~{~<~%  ~2:;~S~>~^, ~}
Miscellaneous options:
~{~<~%  ~2:;~S~>~^, ~}"
		FLAVOR-OPTION
		'(:CONC-NAME :GETTABLE-INSTANCE-VARIABLES :INITABLE-INSTANCE-VARIABLES
		  :LOCATABLE-INSTANCE-VARIABLES :ORDERED-INSTANCE-VARIABLES
		  :READABLE-INSTANCE-VARIABLES :REQUIRED-INSTANCE-VARIABLES
		  :SETTABLE-INSTANCE-VARIABLES :SPECIAL-INSTANCE-VARIABLES
		  :SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS :WRITABLE-INSTANCE-VARIABLES)
		'(:COMPONENT-ORDER :MIXTURE :NO-VANILLA-FLAVOR :REQUIRED-FLAVORS)
		'(:AREA-KEYWORD :CONSTRUCTOR :DEFAULT-INIT-PLIST :INIT-KEYWORDS
		  :REQUIRED-INIT-KEYWORDS)
		'(:ABSTRACT-FLAVOR :DEFAULT-HANDLER :DOCUMENTATION :FUNCTIONS
		  :METHOD-COMBINATION :METHOD-ORDER :REQUIRED-METHODS))))))

  ;; Store the compact precedence graph for later ordering of components
  (SETF (FLAVOR-LOCAL-COMPONENTS FL) COMPONENT-FLAVORS)
  (SETF (FLAVOR-LOCAL-COMPONENT-PRECEDENCE FL)
	(CONVERT-FLAVOR-COMPONENT-ORDER FLAVOR-NAME COMPONENT-ORDER COMPONENT-FLAVORS))

  ;; Deal with the various options for manipulating instance variables
  ;; Note that even though we are only parsing, this will create generic functions
  ;; It has to be that way, because you can't do anything with the FL structure
  ;; if the generic functions aren't already defined in the environment
  (FLET ((ADD-READABLE-INSTANCE-VARIABLE (VARIABLE ACCESSOR)
	   ;; Returns non-NIL if it was added, NIL if it was already there
	   (LOOP FOR (ACC VAR) IN (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL) DO
	     (WHEN (EQ ACC ACCESSOR)
	       (WHEN (EQ VAR VARIABLE)
		 (RETURN-FROM ADD-READABLE-INSTANCE-VARIABLE NIL))
	       (WARN "Instance variables ~S and ~S are both trying to be readable with ~S"
		     VAR VARIABLE ACCESSOR)))
	   (PUSH (LIST ACCESSOR VARIABLE) (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)))
	 (ADD-WRITABLE-INSTANCE-VARIABLE (VARIABLE ACCESSOR)
	   (LOOP FOR (ACC VAR) IN (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL) DO
	     (WHEN (EQ ACC ACCESSOR)
	       (WARN "Instance variables ~S and ~S are both trying to be writable with ~S"
		     VAR VARIABLE ACCESSOR)))
	   (PUSH (LIST ACCESSOR VARIABLE) (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)))
	 (ADD-LOCATABLE-INSTANCE-VARIABLE (VARIABLE ACCESSOR)
	   (LOOP FOR (ACC VAR) IN (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL) DO
	     (WHEN (EQ ACC ACCESSOR)
	       (WARN "Instance variables ~S and ~S are both trying to be locatable with ~S"
		     VAR VARIABLE ACCESSOR)))
	   (PUSH (LIST ACCESSOR VARIABLE) (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)))
	 (KEYWORD (STRING)
	   (INTERN (STRING STRING) PKG-KEYWORD-PACKAGE)))

    ;; Deal with initable, gettable, and settable instance variables
    ;; If the user has not specified the keywords for these, default appropriately.
    ;; "All settable instance variables should also be gettable and initable."
    (LOOP FOR VAR IN SETTABLE-INSTANCE-VARIABLES
	  DO (UNLESS (ATOM VAR) (SETQ VAR (SECOND VAR)))
	     (UNLESS (LOOP FOR ITEM IN GETTABLE-INSTANCE-VARIABLES
			   THEREIS (EQ (IF (ATOM ITEM) ITEM (SECOND ITEM)) VAR))
	       (PUSH VAR GETTABLE-INSTANCE-VARIABLES))
	     (UNLESS (LOOP FOR ITEM IN INITABLE-INSTANCE-VARIABLES
			   THEREIS (EQ (IF (ATOM ITEM) ITEM (SECOND ITEM)) VAR))
	       (PUSH VAR INITABLE-INSTANCE-VARIABLES)))
    (SETF (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
	  (LOOP FOR VAR IN INITABLE-INSTANCE-VARIABLES
		COLLECT (IF (ATOM VAR)
			    (LIST (KEYWORD VAR) VAR)
			    VAR)))
    (LET ((READER-ARGLIST `(,FLAVOR-NAME))
	  (WRITER-ARGLIST `(,FLAVOR-NAME NEW-VALUE))
	  (DEBUGGING-INFO `((FUNCTION-PARENT ,FLAVOR-NAME DEFFLAVOR))))
      (DOLIST (VAR GETTABLE-INSTANCE-VARIABLES)
	(MULTIPLE-VALUE-BIND (GENERIC VAR)
	    (IF (ATOM VAR) (VALUES (KEYWORD VAR) VAR)
		(VALUES (FIRST VAR) (SECOND VAR)))
	  (SETQ GENERIC (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV))
	  (WHEN (ADD-READABLE-INSTANCE-VARIABLE VAR GENERIC)
	    (MAKE-GENERIC-ACCESSOR GENERIC FLAVOR-NAME READER-ARGLIST
				   DEBUGGING-INFO COMPILE-TIME T))))
      (DOLIST (VAR SETTABLE-INSTANCE-VARIABLES)
	(MULTIPLE-VALUE-BIND (GENERIC VAR)
	    (IF (ATOM VAR) (VALUES (KEYWORD (STRING-APPEND "SET-" VAR)) VAR)
		(VALUES (FIRST VAR) (SECOND VAR)))
	  (SETQ GENERIC (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV))
	  (MAKE-GENERIC-ACCESSOR GENERIC FLAVOR-NAME WRITER-ARGLIST
				 DEBUGGING-INFO COMPILE-TIME T)
	  (ADD-WRITABLE-INSTANCE-VARIABLE VAR GENERIC)))
  
      ;; Deal with the instance-variable accessors
      (COND ((EQ CONC-NAME T) (SETQ CONC-NAME (STRING-APPEND FLAVOR-NAME #\-)))
	    ((NULL CONC-NAME) (SETQ CONC-NAME "")))
      (FLET ((MAKE-READABLE (VAR)
	       (MULTIPLE-VALUE-BIND (READER VAR)
		   (IF (ATOM VAR) (VALUES (INTERN (STRING-APPEND CONC-NAME VAR)) VAR)
		       (VALUES (FIRST VAR) (SECOND VAR)))
		 ;; Ordered instance vars use substs, rather than generics, for accessors
		 (UNLESS (MEMBER VAR (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL))
		   (LET ((GENERIC (STANDARDIZE-GENERIC-FUNCTION-NAME READER ENV)))
		     ;; Don't define any one variable more than once (avoid warnings)
		     (WHEN (ADD-READABLE-INSTANCE-VARIABLE VAR GENERIC)
		       (MAKE-GENERIC-ACCESSOR GENERIC FLAVOR-NAME READER-ARGLIST
					      DEBUGGING-INFO COMPILE-TIME NIL))
		     (VALUES READER VAR))))))
	(DOLIST (VAR READABLE-INSTANCE-VARIABLES)
	  (MAKE-READABLE VAR))
	(DOLIST (VAR WRITABLE-INSTANCE-VARIABLES)
	  (MULTIPLE-VALUE-BIND (READER VAR)
	      (MAKE-READABLE VAR)
	    (WHEN READER
	      (LET ((WRITER (STANDARDIZE-GENERIC-FUNCTION-NAME `(SETF ,READER) ENV)))
		(MAKE-GENERIC-ACCESSOR WRITER FLAVOR-NAME WRITER-ARGLIST
				       DEBUGGING-INFO COMPILE-TIME NIL)
		(ADD-WRITABLE-INSTANCE-VARIABLE VAR WRITER)))))
	(DOLIST (VAR LOCATABLE-INSTANCE-VARIABLES)
	  (MULTIPLE-VALUE-BIND (READER VAR)
	      (MAKE-READABLE VAR)
	    (WHEN READER
	      (LET ((LOCATOR (STANDARDIZE-GENERIC-FUNCTION-NAME `(LOCF ,READER) ENV)))
		(MAKE-GENERIC-ACCESSOR LOCATOR FLAVOR-NAME READER-ARGLIST
				       DEBUGGING-INFO COMPILE-TIME NIL)
		(ADD-LOCATABLE-INSTANCE-VARIABLE VAR LOCATOR))))))))

  ;; Error checking
  (WHEN (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL)
    (UNLESS (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS FL)
      (WARN "It is invalid to specify :SPECIAL-INSTANCE-VARIABLES without ~
	      :SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS")))
  (WHEN (AND (FLAVOR-CONSTRUCTORS FL) (FLAVOR-IS-ABSTRACT FL))
    (WARN "An abstract flavor cannot be instantiated, so the
constructor~P~{ ~S~} will not be defined."
	  (LENGTH (FLAVOR-CONSTRUCTORS FL))
	  (MAPCAR #'FIRST (FLAVOR-CONSTRUCTORS FL)))
    (SETF (FLAVOR-CONSTRUCTORS FL) NIL))
  (LOOP FOR (KEYWORD FORM) ON (FLAVOR-DEFAULT-INIT-PLIST FL) BY 'CDDR
	AS VAR = (SECOND (ASSOC KEYWORD (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)))
	AS INIT = (AND VAR (ASSOC VAR (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL))) DO
    (WHEN INIT
      (UNLESS (EQUAL (SECOND INIT) FORM)
	(WARN "The instance variable ~S is being initialized
to ~S in the list of instance variables but is being
initialized to ~S by the keyword ~S in the :DEFAULT-INIT-PLIST."
	      VAR (SECOND INIT) FORM KEYWORD))))
;--- Code below is commented out, because constants are already taken care of by
;--- calling SI:CHECK-SYMBOL-SETABILITY earlier and specials don't matter so much.
;--- The SI:CHECK-SYMBOL-SETABILITY error message is inferior, maybe I should improve it.
;--- Also SI:CHECK-SYMBOL-SETABILITY uses GET rather than GETDECL, FERROR rather than WARN.
;    ;; Using a globally declared special name for an instance variable can
;    ;; lead to problems, especially when the global name is a constant.
;    ;; Optimizers may not see the lexical binding of the instance variable
;    ;; and may incorrectly substitute the value of the constant.
;    ;; Complaint when it's not a constant is mainly for cleanliness.
;    (DOLIST (VAR LOCAL-INSTANCE-VARIABLES)
;      (WHEN (SI:SPECIAL-VARIABLE-P VAR)
;	(UNLESS (MEMBER VAR (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL))
;	  (WARN "The instance variable ~S has been declared ~:[special~;to be a constant~].
;It is possible that some references to this variable may be compiled incorrectly,
;accessing the ~:*~:[special variable~;constant~] when the instance variable was intended
;or vice versa."
;		VAR (GETDECL VAR 'DEFCONSTANT)))))

  ;; Now if some other flavors were automatically created (via :MIXTURE), do them.
  (CONS FL
	(LOOP FOR (NAME . COMPONENT-FLAVORS) IN ADDITIONAL-FLAVORS
	      NCONC (PARSE-DEFFLAVOR NAME NIL COMPONENT-FLAVORS NIL COMPILE-TIME))))

;;; Process a FL resulting from PARSE-DEFFLAVOR
;;; COMPILE-TIME means that the results of this will be discarded when the compilation is over
;;;   UNDO-DECLARATIONS-FLAG must be set and COMPILER:FILE-LOCAL-DECLARATIONS must be bound.
(DEFUN DEFFLAVOR-INTERNAL-1 (FL COMPILE-TIME
			     &AUX (FLAVOR-NAME (FLAVOR-NAME FL))
				  (COMPONENT-FLAVORS (FLAVOR-LOCAL-COMPONENTS FL))
				  (ALREADY-EXISTS NIL)
				  (IDENTICAL-COMPONENTS NIL)
				  IDENTICAL-VARS IDENTICAL-ACCESSORS
				  IDENTICAL-METHOD-COMBINATION
				  IDENTICAL-INITIALIZATIONS IDENTICAL-LOCAL-FUNCTIONS
				  COMPOSE-FLAVORS COMPOSE-METHODS COMPOSE-INITIALIZATION
				  (COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
				  (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR))

  ;;; We're about to do a batch of updates.  Take charge from our callees,
  ;;; since then we can eliminate duplicate updates.
  (WITH-PENDING-DW-UPDATES
    ;; Only do anything if RECORD-SOURCE-FILE-NAME says it's okay
    (WHEN (OR COMPILE-TIME
	      ;; :START-TYPE-DEFINITION is a temporary kludge
	      (AND (RECORD-DEFINITION-SOURCE-FILE FLAVOR-NAME 'DEFFLAVOR
						  :START-TYPE-DEFINITION NIL)
		   (RECORD-DEFINITION-SOURCE-FILE FLAVOR-NAME 'CLI::DEFTYPE
						  :START-TYPE-DEFINITION NIL)))
       (UNLESS COMPILE-TIME
	(NOTE-CHANGE-FOR-DW FLAVOR-NAME)	;To start with.
	(DW:MAYBE-CHECK-TYPE-REDEFINITION FLAVOR-NAME 'DEFFLAVOR :7.2-TYPE T))
      (WITHOUT-ABORTS ("Flavor data structures are being updated to define the flavor ~S.~@
		     Aborting now could damage this flavor, its relationships with its~@
		     component flavors, and its relationships with its dependent flavors,~@
		     might prevent instances of this flavor from ever working properly,~@
		     and might damage the table of names of all flavors."
		       FLAVOR-NAME)

	;; Link into flavor database
	;; Note whether the flavor is being defined or redefined
	(SETQ ALREADY-EXISTS (AND (NOT COMPILE-TIME) (FIND-FLAVOR FLAVOR-NAME NIL)))
	(WHEN ALREADY-EXISTS
	  ;; Ordered instance variables can never go away within a bootload, because their
	  ;; offsets may have been encoded into methods by fixup-method.
	  (SETF (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL)
		(FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES ALREADY-EXISTS))
	  ;; Redefined, note whether components or instance variables are changing
	  (SETQ IDENTICAL-COMPONENTS
		(AND (EQUAL (FLAVOR-LOCAL-COMPONENT-PRECEDENCE FL)
			    (FLAVOR-LOCAL-COMPONENT-PRECEDENCE ALREADY-EXISTS))
		     (EQUAL (FLAVOR-REQUIRED-FLAVORS FL)
			    (FLAVOR-REQUIRED-FLAVORS ALREADY-EXISTS))))
	  (SETQ IDENTICAL-METHOD-COMBINATION
		(AND (EQUAL (FLAVOR-LOCAL-METHOD-COMBINATION FL)
			    (FLAVOR-LOCAL-METHOD-COMBINATION ALREADY-EXISTS))
		     (EQUAL (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL)
			    (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES ALREADY-EXISTS))
		     (EQUAL (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS FL)
			    (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS
			      ALREADY-EXISTS))))
	  (SETQ IDENTICAL-LOCAL-FUNCTIONS
		(EQUAL (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED FL)
		       (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED ALREADY-EXISTS)))
	  (SETQ IDENTICAL-VARS
		(COND (IDENTICAL-COMPONENTS
		       ;; Check whether the instance variables are patently unchanged
		       (AND (EQUAL (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
				   (FLAVOR-LOCAL-INSTANCE-VARIABLES ALREADY-EXISTS))
			    (EQUAL (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL)
				   (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES ALREADY-EXISTS))))
		      ((FLAVOR-COMPONENTS-COMPOSED ALREADY-EXISTS)
		       ;; Check more carefully whether the instance variables have changed
		       (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME
						   :ENV (LIST (LIST FLAVOR-NAME FL))
						   :ERROR-P NIL)
		       (EQUAL (FLAVOR-ALL-INSTANCE-VARIABLES FL)
			      (FLAVOR-ALL-INSTANCE-VARIABLES ALREADY-EXISTS)))
		      (T NIL)))
	  (SETQ IDENTICAL-ACCESSORS		;Local accessors, not inherited
		(AND (EQUAL (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)
			    (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
		     (EQUAL (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)
			    (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
		     (EQUAL (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)
			    (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
		     (EQUAL (FLAVOR-LOCAL-DEFAULT-HANDLER FL)
			    (FLAVOR-LOCAL-DEFAULT-HANDLER ALREADY-EXISTS))))
	  (SETQ IDENTICAL-INITIALIZATIONS
		(AND IDENTICAL-COMPONENTS
		     IDENTICAL-VARS
		     (EQUAL (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
			    (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS ALREADY-EXISTS))
		     (EQUAL (FLAVOR-DEFAULT-INIT-PLIST FL)
			    (FLAVOR-DEFAULT-INIT-PLIST ALREADY-EXISTS))
		     (EQUAL (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
			    (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES ALREADY-EXISTS))
		     (EQUAL (FLAVOR-INIT-KEYWORDS FL)
			    (FLAVOR-INIT-KEYWORDS ALREADY-EXISTS))
		     (EQUAL (FLAVOR-REQUIRED-INIT-KEYWORDS FL)
			    (FLAVOR-REQUIRED-INIT-KEYWORDS ALREADY-EXISTS))
		     (EQUAL (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
			    (FLAVOR-AREA-KEYWORD-SPECIFIED ALREADY-EXISTS))
		     (OR (NOT (FLAVOR-AREA-KEYWORD-SPECIFIED FL))
			 (EQ (FLAVOR-AREA-KEYWORD FL) (FLAVOR-AREA-KEYWORD ALREADY-EXISTS))))))

	;; Add to flavor name tables if this is not just a compile-time defflavor
	(UNLESS COMPILE-TIME
	  (WITHOUT-INTERRUPTS
	    (UNLESS (MEMBER FLAVOR-NAME *ALL-FLAVOR-NAMES*)
	      (PUSH FLAVOR-NAME *ALL-FLAVOR-NAMES* :LOCALIZE T :AREA *FLAVOR-AREA*)
	      (FLAVOR-COMPLETION FLAVOR-NAME)))
	  ;; Back-pointers from this flavor's normal and required components
	  (ADD-FLAVOR-BACK-POINTERS COMPONENT-FLAVORS FLAVOR-NAME "component")
	  (ADD-FLAVOR-BACK-POINTERS (FLAVOR-REQUIRED-FLAVORS FL) FLAVOR-NAME "required")
	  ;; If a back-pointer from this flavor was waiting for this flavor to exist, create it
	  (UNLESS ALREADY-EXISTS
	    (RESOLVE-FLAVOR-PENDING-DEPENDS FLAVOR-NAME FL))
	  (WHEN (AND ALREADY-EXISTS (NOT IDENTICAL-COMPONENTS))
	    ;; Remove backward links from flavors we used to depend on
	    (LET ((NEW-COMPONENTS (APPEND (FLAVOR-REQUIRED-FLAVORS FL) COMPONENT-FLAVORS)))
	      (REMOVE-FLAVOR-BACK-POINTERS (FLAVOR-LOCAL-COMPONENTS ALREADY-EXISTS)
					   NEW-COMPONENTS FLAVOR-NAME)
	      (REMOVE-FLAVOR-BACK-POINTERS (FLAVOR-REQUIRED-FLAVORS ALREADY-EXISTS)
					   NEW-COMPONENTS FLAVOR-NAME)))
	  (WHEN (FBOUNDP 'CLOS-INTERNALS::ENSURE-FLAVOR-CLASS)
	    (CLOS-INTERNALS::ENSURE-FLAVOR-CLASS FLAVOR-NAME)))

	;; Record forward-declarations of local functions
	(WHEN COMPILE-TIME
	  (DOLIST (NAME (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED FL))
	    (NOTICE-DEFUN-IN-FLAVOR `(DEFUN-IN-FLAVOR ,NAME ,FLAVOR-NAME) NIL
				    (OR ALREADY-EXISTS FL)))
	  ;; Note any implicit methods that were generated.
	  (DOLIST (ENTRY (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL))
	    (LET ((NAME (FIRST ENTRY)))
	      (UNLESS (KEYWORDP NAME)
		(COMPILER:NOTICE-COMPILED-FUNCTION NAME)))))

	;; Merge with existing flavor definition, if any
	(COND (COMPILE-TIME (SETF (GETDECL FLAVOR-NAME 'FLAVOR) FL))
	      ((NOT ALREADY-EXISTS)
	       (SETF (GET FLAVOR-NAME 'FLAVOR) FL)
	       ;; Normally there won't be any dependent flavors, but if this flavor
	       ;; used to exist but then was REMOVE-FLAVORed, there could be.
	       (WITH-TRANSFORM-FLAVOR-WARNINGS
		 (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FL FL)
		   (UNLESS (EQ FLAVOR FLAVOR-NAME)
		     (REDEFINE-FLAVOR FLAVOR NIL NIL NIL NIL NIL)))))
	      ((OR IDENTICAL-VARS (NOT (FLAVOR-INSTANTIATED ALREADY-EXISTS)))
	       ;; There is no problem with existing instances continuing to work either
	       ;; because there aren't any existing instances or because nothing has changed.
	       (UNLESS IDENTICAL-ACCESSORS
		 (NOTE-ACCESSORS-REMOVED FL ALREADY-EXISTS))
	       ;; Update the new attributes into the old flavor structure.
	       (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLES ALREADY-EXISTS)
		     (FLAVOR-LOCAL-INSTANCE-VARIABLES FL))
	       (SETF (FLAVOR-LOCAL-COMPONENTS ALREADY-EXISTS) (FLAVOR-LOCAL-COMPONENTS FL))
	       (SETF (FLAVOR-LOCAL-COMPONENT-PRECEDENCE ALREADY-EXISTS)
		     (FLAVOR-LOCAL-COMPONENT-PRECEDENCE FL))
	       (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS ALREADY-EXISTS)
		     (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL))
	       (SETF (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES ALREADY-EXISTS)
		     (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL))
	       (SETF (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES ALREADY-EXISTS)
		     (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL))
	       (SETF (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES ALREADY-EXISTS)
		     (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL))
	       (SETF (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED ALREADY-EXISTS)
		     (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED FL))
	       (WHEN (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
		 (SETF (FLAVOR-AREA-KEYWORD ALREADY-EXISTS) (FLAVOR-AREA-KEYWORD FL)))
	       (SETQ COMPOSE-FLAVORS (FLAVOR-COMPONENTS-COMPOSED ALREADY-EXISTS)
		     COMPOSE-METHODS (FLAVOR-METHODS-COMPOSED ALREADY-EXISTS)
		     COMPOSE-INITIALIZATION (FLAVOR-INITIALIZATIONS-COMPOSED ALREADY-EXISTS))
	       (SETF (FLAVOR-FLAGS ALREADY-EXISTS)
		     (LOGIOR (LOGAND (FLAVOR-FLAGS ALREADY-EXISTS)
				     *FLAGS-THAT-SURVIVE-REDEFINITION*)
			     (FLAVOR-FLAGS FL)))
	       (SETF (FLAVOR-PLIST ALREADY-EXISTS)
		     (NCONC (LOOP FOR (PROP VAL) ON (FLAVOR-PLIST ALREADY-EXISTS) BY 'CDDR
				  UNLESS (MEMBER PROP *PROPERTIES-LOST-BY-REDEFINITION*)
				    APPEND (LIST PROP VAL))
			    (FLAVOR-PLIST FL)))
	       ;; If the instance variables have moved, forget old mapping tables.
	       ;; COMPOSE-METHOD-COMBINATION will make new ones.
	       (UNLESS IDENTICAL-VARS
		 (SETF (FLAVOR-MAPPING-TABLES ALREADY-EXISTS) NIL))
	       ;; Recompose whatever was composed before, based on the new information
	       ;; Don't try to optimize out COMPOSE-FLAVOR-COMBINATION, it's needed to
	       ;; update the flavor-all-composed-dependents links, if nothing else.
	       (IF COMPOSE-FLAVORS
		   (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL)
		   ;; Clear a cache, FLAVOR-ALL-COMPONENTS isn't necessarily NIL
		   (REMOVE-FROM-ALL-COMPOSED-DEPENDENTS ALREADY-EXISTS))
	       (WHEN COMPOSE-METHODS
		 (COMPOSE-METHOD-COMBINATION FLAVOR-NAME :ERROR-P NIL))
	       (WHEN COMPOSE-INITIALIZATION
		 (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ERROR-P NIL)
		 (VALIDATE-CONSTRUCTOR-FUNCTIONS ALREADY-EXISTS))
	       ;; Propagate the new attributes to the dependent flavors
	       (UNLESS (AND IDENTICAL-COMPONENTS IDENTICAL-VARS IDENTICAL-ACCESSORS
			    IDENTICAL-LOCAL-FUNCTIONS IDENTICAL-METHOD-COMBINATION
			    IDENTICAL-INITIALIZATIONS)
		 (WITH-TRANSFORM-FLAVOR-WARNINGS
		   (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FL ALREADY-EXISTS)
		     (UNLESS (EQ FLAVOR FLAVOR-NAME)
		       (REDEFINE-FLAVOR FLAVOR IDENTICAL-COMPONENTS IDENTICAL-VARS
					IDENTICAL-ACCESSORS IDENTICAL-LOCAL-FUNCTIONS
					IDENTICAL-METHOD-COMBINATION))))))
	      (T
	       ;; Old instances will stop working unless they are transformed to conform to
	       ;; the new flavor definition, with different instance variables.
	       ;; Copy relevant aspects of the old flavor structure then replace it.
	       ;; All new mapping tables will be made by COMPOSE-METHOD-COMBINATION when
	       ;; TRANSFORM-FLAVOR calls it.
	       (UNLESS IDENTICAL-ACCESSORS
		 (NOTE-ACCESSORS-REMOVED FL ALREADY-EXISTS))
	       (MERGE-FLAVOR-STRUCTURES ALREADY-EXISTS FL)
	       ;; Don't try to optimize out COMPOSE-FLAVOR-COMBINATION, it's needed to
	       ;; update the flavor-all-composed-dependents links, if nothing else.
	       (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL
					   :ENV (LIST (LIST FLAVOR-NAME FL)))
	       (WITH-TRANSFORM-FLAVOR-WARNINGS
		 (TRANSFORM-FLAVOR ALREADY-EXISTS FL)
		 ;; Propagate changes to the dependent flavors
		 (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FL ALREADY-EXISTS)
		   (UNLESS (EQ FLAVOR FLAVOR-NAME)
		     (REDEFINE-FLAVOR FLAVOR IDENTICAL-COMPONENTS IDENTICAL-VARS
				      IDENTICAL-ACCESSORS IDENTICAL-LOCAL-FUNCTIONS
				      IDENTICAL-METHOD-COMBINATION))))))
	;; Note that this flavor exists in case we compile a combined method for it,
	;; during this same compilation.
	(NOTICE-FLAVOR FLAVOR-NAME)
	;; Let who-calls know
	(SI:WHEN-IN-INCREMENTAL-WHO-CALLS-MODE
	  (SI:WHO-CALLS-DEFFLAVOR-HOOK FL))
	;; Value returned is flavor name, unless RECORD-SOURCE-FILE-NAME said not to do it
	FLAVOR-NAME))))

(DEFUN MERGE-FLAVOR-STRUCTURES (FROM TO)
  (SETF (FLAVOR-METHOD-TABLE TO) (FLAVOR-METHOD-TABLE FROM))
  (SETF (FLAVOR-LOCAL-FUNCTIONS TO) (FLAVOR-LOCAL-FUNCTIONS FROM))
  (SETF (FLAVOR-MAPPING-TABLE-NAMES TO) (FLAVOR-MAPPING-TABLE-NAMES FROM))
  (SETF (FLAVOR-MAPPING-TABLE-VARIABLE-P TO) (FLAVOR-MAPPING-TABLE-VARIABLE-P FROM))
  (SETF (FLAVOR-LOCAL-DEPENDENTS TO) (FLAVOR-LOCAL-DEPENDENTS FROM))
  (SETF (FLAVOR-ALL-COMPOSED-DEPENDENTS TO) (FLAVOR-ALL-COMPOSED-DEPENDENTS FROM))
  (SETF (FLAVOR-ALL-COMPONENTS TO) (FLAVOR-ALL-COMPONENTS FROM))
  ;; Ordered instance variables can never go away within a bootload, because
  ;; their offsets may have been encoded into methods by fixup-method.
  (SETF (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES TO)
	(FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FROM))
  ;; Retain local-function interpreter definition cells for functions
  ;; defined here, but not inherited ones.
  (SETF (FLAVOR-ALL-LOCAL-FUNCTIONS TO)
	(LOOP FOR ELEM IN (FLAVOR-ALL-LOCAL-FUNCTIONS FROM)
	      WHEN (EQ (METHOD-FLAVOR (THIRD ELEM)) (FLAVOR-NAME FROM))
		COLLECT ELEM))
  (LOOP FOR (PROP VAL) ON (FLAVOR-PLIST FROM) BY 'CDDR DO
    (UNLESS (MEMBER PROP *PROPERTIES-LOST-BY-REDEFINITION*)
      (SETF (GETF (FLAVOR-PLIST TO) PROP) VAL)))
  (SETF (FLAVOR-FLAGS TO) (LOGIOR (LOGAND (FLAVOR-FLAGS FROM)
					  *FLAGS-THAT-SURVIVE-REDEFINITION*)
				  (FLAVOR-FLAGS TO)))
  (SETF (FLAVOR-OBSOLETE-MAPPING-TABLES TO)
	(APPEND (FLAVOR-MAPPING-TABLES FROM) (FLAVOR-OBSOLETE-MAPPING-TABLES FROM)))
  TO)

;;; Develop a list of definitions for accessors for ordered-instance-variables, which
;;; want to be substs rather than generic functions that invoke pseudo-methods.
(DEFUN ACCESSOR-SUBSTS (FLAVOR-NAME INSTANCE-VARIABLES OPTIONS &AUX FL)
  (SETQ INSTANCE-VARIABLES (AND (LISTP INSTANCE-VARIABLES)
				(LOOP FOR VAR IN INSTANCE-VARIABLES
				      COLLECT (IF (ATOM VAR) VAR (CAR VAR)))))
  (LET ((ORDERED-INSTANCE-VARIABLES
	  (LOOP FOR OPTION IN OPTIONS
		AS ARGS = (AND (LISTP OPTION)
			       (PROG1 (CDR OPTION) (SETQ OPTION (CAR OPTION))))
		WHEN (EQ OPTION ':ORDERED-INSTANCE-VARIABLES)
		  APPEND (OR ARGS INSTANCE-VARIABLES))))
    (WHEN ORDERED-INSTANCE-VARIABLES
      (LET ((COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
	    (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR)
	    (CONC-NAME T)
	    (READABLE-INSTANCE-VARIABLES NIL)
	    (ACCESSOR-SUBSTS NIL)
	    (ACTUAL-ORDERED-INSTANCE-VARIABLES
	      ;; Ordered instance variables can never go away within a bootload, because their
	      ;; offsets may have been encoded into methods by fixup-method.  Therefore we
	      ;; look at the actual ordering, not the :ORDERED-INSTANCE-VARIABLES option,
	      ;; if an actual ordering has been committed to.
	      (OR (AND (NOT UNDO-DECLARATIONS-FLAG)
		       (SETQ FL (FIND-FLAVOR FLAVOR-NAME NIL))
		       (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL))
		  ORDERED-INSTANCE-VARIABLES)))
	(WHEN (AND (> (LIST-LENGTH ORDERED-INSTANCE-VARIABLES)
		      (LIST-LENGTH ACTUAL-ORDERED-INSTANCE-VARIABLES))
		   (NOT (MISMATCH ORDERED-INSTANCE-VARIABLES ACTUAL-ORDERED-INSTANCE-VARIABLES
				  :END1 (LIST-LENGTH ACTUAL-ORDERED-INSTANCE-VARIABLES)))
		   (NOT (FLAVOR-INSTANTIATED FL)))
	  ;; List is going to get longer (same rules as COMPOSE-FLAVOR-COMBINATION)
	  (SETQ ACTUAL-ORDERED-INSTANCE-VARIABLES ORDERED-INSTANCE-VARIABLES))
	(LOOP FOR OPTION IN OPTIONS
	      AS ARGS = (AND (LISTP OPTION)
			     (PROG1 (CDR OPTION) (SETQ OPTION (CAR OPTION)))) DO
	  (CASE OPTION
	    (:CONC-NAME
	     (SETQ CONC-NAME (IF ARGS (FIRST ARGS) T)))
	    ((:LOCATABLE-INSTANCE-VARIABLES :OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES
	      :READABLE-INSTANCE-VARIABLES :WRITABLE-INSTANCE-VARIABLES)
	     (APPENDF READABLE-INSTANCE-VARIABLES (OR ARGS INSTANCE-VARIABLES)))))
	(COND ((EQ CONC-NAME T) (SETQ CONC-NAME (STRING-APPEND FLAVOR-NAME #\-)))
	      ((NULL CONC-NAME) (SETQ CONC-NAME "")))
	;; Build up list of accessor names and variable names, with duplicates removed
	(LOOP FOR SPEC IN READABLE-INSTANCE-VARIABLES
	      AS VARIABLE = (IF (ATOM SPEC) SPEC (SECOND SPEC)) DO
	  (WHEN (MEMBER VARIABLE ORDERED-INSTANCE-VARIABLES)
	    (LET ((ACCESSOR (IF (ATOM SPEC) (INTERN (STRING-APPEND CONC-NAME SPEC))
				(FIRST SPEC))))
	      (UNLESS (LOOP FOR (ACC VAR) IN ACCESSOR-SUBSTS DO
			(WHEN (EQ ACC ACCESSOR)
			  (WHEN (EQ VAR VARIABLE)
			    (RETURN T))
			  (WARN "Instance variables ~S and ~S are both trying to ~
				be readable with ~S"
				VAR VARIABLE ACCESSOR)))
		(PUSH (LIST ACCESSOR VARIABLE) ACCESSOR-SUBSTS)))))
	(LOOP FOR (ACCESSOR VARIABLE) IN ACCESSOR-SUBSTS
	      AS POS = (POSITION VARIABLE ACTUAL-ORDERED-INSTANCE-VARIABLES)
	      DO (UNLESS POS
		   (WARN "Position of instance variable ~S in an instance of flavor ~S~@
			is not known, so the inline accessor ~S will be inefficient."
			 VARIABLE FLAVOR-NAME ACCESSOR))
	      COLLECT `(CHECK-FOR-ACCESSOR-REDEFINITION ',ACCESSOR ',FLAVOR-NAME
							',VARIABLE ,POS)
	      COLLECT `(DEFSUBST ,ACCESSOR (,FLAVOR-NAME)
			 (DECLARE (FUNCTION-PARENT ,FLAVOR-NAME DEFFLAVOR))
			 ,(IF POS
			      `(%INSTANCE-REF ,FLAVOR-NAME ,(1+ POS))
			      ;; Not ordered in this bootload, fall back on something slow
			      `(SYMBOL-VALUE-IN-INSTANCE ,FLAVOR-NAME ',VARIABLE))))))))

(DEFUN CHECK-FOR-ACCESSOR-REDEFINITION (GENERIC-FUNCTION-NAME FLAVOR-NAME VARIABLE
					&OPTIONAL (KNOWN-POSITION NIL KNOWN-POSITION-GIVEN))
  (SETQ GENERIC-FUNCTION-NAME (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC-FUNCTION-NAME))
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR)
	(GF (FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME NIL)))
    (IF GF
	(UNLESS (GENERIC-FUNCTION-MESSAGE-P GF)
	  (LET ((NO-OTHER-FLAVORS T)
		(NO-OTHER-METHODS T)
		(NO-OTHER-VARIABLES T))
	    ;; We are bashing, or have already bashed, this generic function
	    ;; See if there are any methods besides the accessor we might be replacing
	    (UNLESS (LOOP FOR FLAVOR IN (GENERIC-FUNCTION-FLAVORS GF) WITH TEM
			  ALWAYS (OR (EQ FLAVOR FLAVOR-NAME)
				     (SETQ NO-OTHER-FLAVORS NIL))
			  AS FL = (FIND-FLAVOR FLAVOR)
			  ALWAYS (LOOP FOR MH IN (CDR (ASSOC GENERIC-FUNCTION-NAME
							     (FLAVOR-METHOD-TABLE FL)))
				       AS METHOD = (METHOD-HOLDER-FUNCTION-SPEC MH)
				       ALWAYS (OR (EQ (METHOD-TYPE METHOD) 'COMBINED)
						  (SETQ NO-OTHER-METHODS NIL)))
			  WHEN (SETQ TEM (ASSOC GENERIC-FUNCTION-NAME
						(FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)))
			    ALWAYS (OR (EQ (SECOND TEM) VARIABLE)
				       (SETQ NO-OTHER-VARIABLES NIL))
			  ALWAYS (OR (NOT (ASSOC GENERIC-FUNCTION-NAME
						 (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES
						   FL)))
				     (SETQ NO-OTHER-VARIABLES NIL))
			  ALWAYS (OR (NOT (ASSOC GENERIC-FUNCTION-NAME
						 (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES
						   FL)))
				     (SETQ NO-OTHER-VARIABLES NIL)))
	      ;; Can't query whether to allow the redefinition, but warn at least
	      (WARN "The generic function ~S, handled by flavor~P~{ ~S,~}~@
		     is being superseded by an ~S accessor for flavor ~S.~@
		     Calls to the function ~S will no longer ~
		       ~:[work for objects of other flavors~;~
		         ~:[invoke methods~;~
			   ~:[access the variable they used to access~]~]~]."
		    GENERIC-FUNCTION-NAME (LIST-LENGTH (GENERIC-FUNCTION-FLAVORS GF))
		    (GENERIC-FUNCTION-FLAVORS GF)
		    :ORDERED-INSTANCE-VARIABLES FLAVOR-NAME GENERIC-FUNCTION-NAME
		    NO-OTHER-FLAVORS NO-OTHER-METHODS NO-OTHER-VARIABLES))))
	D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Check to see if we're redefining an existing ordered instance variable accessor
	;; but are going to be referencing a different slot than before.
0	(MULTIPLE-VALUE-BIND (OTHER-FLAVOR-NAME PARENT-TYPE)
	    (SYS:FUNCTION-PARENT GENERIC-FUNCTION-NAME 'DEFUN)
	  (WHEN (EQ PARENT-TYPE 'DEFFLAVOR)
	    (LET* ((FL (FIND-FLAVOR FLAVOR-NAME))
		   (POSITION (IF KNOWN-POSITION-GIVEN
				 KNOWN-POSITION
				 (POSITION VARIABLE
					   (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL))))
		   (IFS (SI:DEBUGGING-INFO-USER-ENTRY GENERIC-FUNCTION-NAME 'LT:INLINE-FORM))
		   (FORM (AND IFS (LT::INLINE-FORM-FORM (SECOND IFS)))))
	      (WHEN (AND (LISTP FORM)
			 (OR (EQ (FIRST FORM) 'SYS:%INSTANCE-REF)
			     (EQ (FIRST FORM) 'SYMBOL-VALUE-IN-INSTANCE)))
		(LET* ((OTHER-FL (FIND-FLAVOR OTHER-FLAVOR-NAME NIL))
		       (OTHER-VARIABLES (AND OTHER-FL
					     (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES OTHER-FL)))
		       (OTHER-POSITION-OR-VARIABLE (THIRD FORM))
		       (OTHER-POSITION (IF (NUMBERP OTHER-POSITION-OR-VARIABLE)
					   (1- OTHER-POSITION-OR-VARIABLE)
					   NIL))
		       (OTHER-VARIABLE (IF OTHER-POSITION
					   (AND (< OTHER-POSITION (LENGTH OTHER-VARIABLES))
						(NTH OTHER-POSITION OTHER-VARIABLES))
					   OTHER-POSITION-OR-VARIABLE)))
		  (UNLESS (OR (AND POSITION OTHER-POSITION (= POSITION OTHER-POSITION))
			      (AND (NULL POSITION) (NULL OTHER-POSITION)
				   (NEQ (FIRST FORM) 'SYS:%INSTANCE-REF)
				   (EQ VARIABLE OTHER-VARIABLE)))
		    (WARN "The generic function ~S, defined as an ~S accessor for the~
			   ~@[ instance variable ~S in~] flavor ~S,~@
			   is being superseded by an ~S accessor for the ~
			   instance variable ~S in flavor ~S.~@
			   These instance variables do not occupy the same position ~
			   within their respective flavors.~@
			   Therefore, any use of ~S will probably be compiled incorrectly."
			  GENERIC-FUNCTION-NAME
			  :ORDERED-INSTANCE-VARIABLES OTHER-VARIABLE OTHER-FLAVOR-NAME
			  :ORDERED-INSTANCE-VARIABLES VARIABLE FLAVOR-NAME
			  GENERIC-FUNCTION-NAME))))))))))

(DEFUN ADD-FLAVOR-BACK-POINTERS (COMPONENTS TO USAGE)
  (DOLIST (FROM COMPONENTS)
    (LET ((REASON (CAR (GET FROM 'OBSOLETE-FLAVOR))))
      (WHEN REASON
	(WARN "The ~A flavor ~S is obsolete~:[; ~A.~;.~%~A~]"
	      USAGE FROM (STRING-SEARCH-SET '(#\NEWLINE #\.) REASON) REASON)))
    (WITHOUT-INTERRUPTS
      (LET ((FL (GET FROM 'FLAVOR)))		;faster FIND-FLAVOR
	(IF FL
	    (PUSHNEW TO (FLAVOR-LOCAL-DEPENDENTS FL))
	    (PUSH (LIST FROM TO) *FLAVOR-PENDING-DEPENDS*))))))

(DEFUN REMOVE-FLAVOR-BACK-POINTERS (OLD-COMPONENTS NEW-COMPONENTS TO &AUX FL)
  (WITHOUT-INTERRUPTS
    (DOLIST (OLD OLD-COMPONENTS)
      (COND ((MEMBER OLD NEW-COMPONENTS))
	    ((SETQ FL (GET OLD 'FLAVOR))
	     (SETF (FLAVOR-LOCAL-DEPENDENTS FL) (DELETE TO (FLAVOR-LOCAL-DEPENDENTS FL))))
	    (T
	     (LOOP FOR X IN *FLAVOR-PENDING-DEPENDS*
		   AS (FROM TOO) = X DO
	       (WHEN (AND (EQ FROM OLD) (EQ TOO TO))
		 (SETQ *FLAVOR-PENDING-DEPENDS* (DELETE X *FLAVOR-PENDING-DEPENDS*)))))))))

(DEFUN RESOLVE-FLAVOR-PENDING-DEPENDS (FLAVOR-NAME FL)
  (WITHOUT-INTERRUPTS
    (LOOP FOR X IN *FLAVOR-PENDING-DEPENDS*
	  AS (FROM TO) = X DO
      (WHEN (EQ FROM FLAVOR-NAME)
	(PUSHNEW TO (FLAVOR-LOCAL-DEPENDENTS FL))
	(LET ((TFL (GET TO 'FLAVOR)))		;faster FIND-FLAVOR
	  (WHEN TFL
	    (WHEN (FLAVOR-ALL-COMPONENTS TFL)
	      ;; No update of DW type handlers necessary even if ADD-COMPOSED-DEPENDENT
	      ;; returns true, because DEFFLAVOR-INTERNAL-1 will take care of it
	      (ADD-COMPOSED-DEPENDENT TFL FL))
	    (SETF (FLAVOR-COMPONENTS-COMPOSED TFL) NIL)))
	(SETQ *FLAVOR-PENDING-DEPENDS* (DELETE X *FLAVOR-PENDING-DEPENDS*))))))

;Not stored explicitly because it's too painful to maintain
(DEFUN FLAVOR-ALL-DEPENDENTS (FL &OPTIONAL LIST-SO-FAR)
  (DOLIST (DEPENDENT (FLAVOR-LOCAL-DEPENDENTS FL))
    (UNLESS (MEMBER DEPENDENT LIST-SO-FAR)
      (WHEN (SETQ FL (FIND-FLAVOR DEPENDENT NIL))
	(SETQ LIST-SO-FAR (FLAVOR-ALL-DEPENDENTS FL (CONS DEPENDENT LIST-SO-FAR))))))
  LIST-SO-FAR)

(DEFUN FLAVOR-COMPLETION (FLAVOR-NAME)
  (BOOTSTRAP-FLAVOR-NAMES-AARRAY)
  (SI:AARRAY-INSERT *ALL-FLAVOR-NAMES-AARRAY*
		    (SYMBOL-NAME FLAVOR-NAME)
		    FLAVOR-NAME 'ATOM))

(DEFVAR *FLAVOR-NAMES-AARRAY-BOOTSTRAPPED* NIL)

(DEFUN BOOTSTRAP-FLAVOR-NAMES-AARRAY ()
  (UNLESS *FLAVOR-NAMES-AARRAY-BOOTSTRAPPED*
    (UNWIND-PROTECT-CASE ()
	(LET ((INHIBIT-SCHEDULING-FLAG NIL))	;keep world-build network connection alive
	  (SETQ *FLAVOR-NAMES-AARRAY-BOOTSTRAPPED* T)
	  (SETF (FILL-POINTER *ALL-FLAVOR-NAMES-AARRAY*) 0)
	  (MAPC #'FLAVOR-COMPLETION *ALL-FLAVOR-NAMES*)
	  (SETF (FILL-POINTER *ALL-GENERIC-FUNCTION-NAMES-AARRAY*) 0)
	  (MAPC #'GENERIC-FUNCTION-COMPLETION *ALL-GENERIC-FUNCTION-NAMES*))
      (:ABORT (SETQ *FLAVOR-NAMES-AARRAY-BOOTSTRAPPED* NIL)))))

;;; Convert a flavor component specification into a precedence graph in compact
;;; form, which consists of a list of lists of right-to-left ordered components.
;;; This is designed to be convenient to use without consing later.
;;; The lists themselves have no ordering dependencies among them.
;;; Every component must appear in the precedence graph, even if it participates
;;; in no precedence relations, in order to drive later depth-first component iteration.
;;; The component spec can be a list of lists, to allow despecification of some of
;;; the ordering constraints.
(DEFUN CONVERT-FLAVOR-COMPONENT-ORDER (FLAVOR-NAME COMPONENT-ORDER COMPONENT-FLAVORS
				       &AUX (ERROR NIL))
  (MACROLET ((ERROR (FORMAT-STRING &REST ARGS)
	       `(PROGN (WARN ,FORMAT-STRING ,@ARGS)
		       (SETQ ERROR T))))
    (COND ((ATOM (CAR COMPONENT-ORDER))
	   ;; Simple format, just one list of flavor names
	   (DOLIST (COMPONENT COMPONENT-ORDER)
	     (UNLESS (SYMBOLP COMPONENT)
	       (ERROR "~S where a symbol was expected in the component list of flavor ~S"
		       COMPONENT FLAVOR-NAME))
	     (WHEN (EQ COMPONENT FLAVOR-NAME)
	       (ERROR "~S is specified as a component of itself, which is illegal."
		       FLAVOR-NAME)))
	   (UNLESS ERROR
	     (LIST (REVERSE (CONS FLAVOR-NAME COMPONENT-ORDER)))))
	  (T
	   ;; Complex format, multiple constraint lists and the parent flavor
	   ;; is not automatically added.
	   (NCONC (LOOP FOR SPEC IN COMPONENT-ORDER
			COLLECT (COND ((CONSP SPEC)
				       (LOOP FOR COMPONENT IN SPEC AS FIRST = T THEN NIL DO
					 (UNLESS (SYMBOLP COMPONENT)
					   (ERROR "~S where a symbol was expected in a~@
						sublist of the component list of flavor ~S"
						  COMPONENT FLAVOR-NAME))
					 (UNLESS FIRST
					   (WHEN (EQ COMPONENT FLAVOR-NAME)
					     (ERROR "~S is specified as a component of ~
						itself, which is illegal."
						    FLAVOR-NAME))))
				       (REVERSE SPEC))
				      (T
				       (ERROR "~S where a list of components was expected~@
						in the component list of flavor ~S"
					      SPEC FLAVOR-NAME)))
			FINALLY (WHEN ERROR
				  (RETURN-FROM CONVERT-FLAVOR-COMPONENT-ORDER NIL)))
		  (LOOP FOR COMPONENT IN COMPONENT-FLAVORS
			UNLESS (LOOP FOR SPEC IN COMPONENT-ORDER
				     THEREIS (MEMBER COMPONENT (CDR SPEC)))
			  COLLECT (LIST COMPONENT)))))))

;;;; Propagation of changes in a flavor to its dependents

;; Caller must use WITH-TRANSFORM-FLAVOR-WARNINGS
(DEFUN REDEFINE-FLAVOR (FLAVOR-NAME IDENTICAL-COMPONENTS IDENTICAL-VARS
			IDENTICAL-ACCESSORS IDENTICAL-LOCAL-FUNCTIONS
			IDENTICAL-METHOD-COMBINATION)
  ;; Since we do an actual installation of the flavor if it changes representation,
  ;; we are responsible for taking charge of the DW updating after we do the actual
  ;; installation.  (We deliberately ignore the fact that all current callers will
  ;; take charge from us.  Future callers might not.)
  (WITH-PENDING-DW-UPDATES
    (LET ((FL (FIND-FLAVOR FLAVOR-NAME NIL)))
      (UNLESS FL
	(RETURN-FROM REDEFINE-FLAVOR NIL))
      ;; De-cache MAKE-INSTANCE's stuff    
      (SETF (FLAVOR-INSTANTIABLE FL) NIL)
      (COND ((AND IDENTICAL-COMPONENTS IDENTICAL-VARS)
	     ;; Format of instances has not changed, this is the easy case
	     ;; Local functions may have changed
	     (UNLESS IDENTICAL-LOCAL-FUNCTIONS
	       (WHEN (FLAVOR-COMPONENTS-COMPOSED FL)
		 (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL)))
	     ;; Methods or mapping tables may have changed
	     (UNLESS (AND IDENTICAL-ACCESSORS IDENTICAL-METHOD-COMBINATION)
	       (WHEN (FLAVOR-METHODS-COMPOSED FL)
		 (COMPOSE-METHOD-COMBINATION FLAVOR-NAME :ERROR-P NIL)))
	     ;; Recompute initialization information in case anything changed
	     (WHEN (FLAVOR-INITIALIZATIONS-COMPOSED FL)
	       (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ERROR-P NIL)
	       (VALIDATE-CONSTRUCTOR-FUNCTIONS FL)))
	    (T
	     ;; Format of instances may have changed, update the flavor carefully
	     (LET ((OLD-IVS (FLAVOR-ALL-INSTANCE-VARIABLES FL))
		   (OLD-COMPONENTS (FLAVOR-ALL-COMPONENTS FL))
		   (NEW-FL (IF (FLAVOR-INSTANTIATED FL) (COPY-FLAVOR FL T) FL)))
	       ;; Keep track of all the mapping tables that have ever been created,
	       ;; so that we can update them if the flavor changes a second time.
	       (UNLESS (EQ NEW-FL FL)
		 (SETF (FLAVOR-OBSOLETE-MAPPING-TABLES NEW-FL)
		       (APPEND (FLAVOR-MAPPING-TABLES FL) (FLAVOR-OBSOLETE-MAPPING-TABLES FL))))
	       ;; Recompute FLAVOR-ALL-INSTANCE-VARIABLES and FLAVOR-ALL-COMPONENTS
	       (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL
					   :ENV (LIST (LIST FLAVOR-NAME NEW-FL)))
	       (SETQ IDENTICAL-VARS (EQUAL (FLAVOR-ALL-INSTANCE-VARIABLES NEW-FL) OLD-IVS))
	       (COND ((AND (FLAVOR-INSTANTIATED FL) (NOT IDENTICAL-VARS))
		      ;; Old instances will stop working unless they are transformed to conform
		      ;; to the new flavor definition, with different instance variables.
		      ;; Copy relevant aspects of the old flavor structure then replace it.
		      ;; All new mapping tables will be made by COMPOSE-METHOD-COMBINATION when
		      ;; TRANSFORM-FLAVOR calls it.
		      (TRANSFORM-FLAVOR FL NEW-FL))
		     (T
		      ;; Didn't need to make a replacement flavor structure after all.
		      (UNLESS (EQ NEW-FL FL)
			(RETURN-ARRAY NEW-FL)
			(COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL))
		      ;; There is no problem with existing instances but mapping tables may
		      ;; need to change if instance variables have been moved.
		      (UNLESS IDENTICAL-VARS
			(LET ((FLAVOR-MAPPING-TABLES (FLAVOR-MAPPING-TABLES FL)))
			  (SETF (FLAVOR-MAPPING-TABLES FL) NIL)
			  (DOLIST (MT FLAVOR-MAPPING-TABLES)
			    ;; Invalidate old mapping tables even though they should be
			    ;; inaccessible because no instances exist yet
			    (TRANSFORM-MAPPING-TABLE MT (FLAVOR-ALL-INSTANCE-VARIABLES FL)))))
		      ;; Change meaning of IDENTICAL-COMPONENTS from "the original flavor had
		      ;; identical components" to "this flavor, a dependent of it, had
		      ;; identical components".
		      (SETQ IDENTICAL-COMPONENTS (EQUAL (FLAVOR-ALL-COMPONENTS FL)
							OLD-COMPONENTS))
		      ;; There is no problem with existing instances but methods may have been
		      ;; changed or mapping tables for the methods may need to change.
		      (UNLESS (AND IDENTICAL-COMPONENTS
				   IDENTICAL-VARS IDENTICAL-ACCESSORS
				   IDENTICAL-METHOD-COMBINATION)
			(WHEN (FLAVOR-METHODS-COMPOSED FL)
			  (COMPOSE-METHOD-COMBINATION FLAVOR-NAME :ERROR-P NIL)))
		      ;; A mapping-table update might have been punted earlier because the
		      ;; mapped-to flavor was not yet in this flavor's all-components list.
		      ;; A mapping table from this flavor used by an inherited combined method
		      ;; thus might not contain a needed mapping to a third flavor.
		      (UNLESS IDENTICAL-COMPONENTS
			(UPDATE-INDIRECT-MAPPING-TABLES FL))
		      ;; Recompute initialization information in case anything changed
		      (WHEN (FLAVOR-INITIALIZATIONS-COMPOSED FL)
			(COMPOSE-INITIALIZATIONS FLAVOR-NAME :ERROR-P NIL)
			(VALIDATE-CONSTRUCTOR-FUNCTIONS FL))))))))))

;; Caller must use WITH-TRANSFORM-FLAVOR-WARNINGS
(DEFUN TRANSFORM-FLAVOR (OLD-FL NEW-FL)
  (LET ((FLAVOR-NAME (FLAVOR-NAME OLD-FL)))
    ;; Install replacement flavor defstruct and arrange for existing instances
    ;; to update themselves.  Most operations in other processes will work while
    ;; we're doing this, but some will not.  ---Perhaps later deal with this or document---
    (SETF (GET FLAVOR-NAME 'FLAVOR) NEW-FL)
    ;; Blow away old mapping tables
    (DOLIST (MT (FLAVOR-OBSOLETE-MAPPING-TABLES NEW-FL))
      (TRANSFORM-MAPPING-TABLE
	MT (FLAVOR-ALL-INSTANCE-VARIABLES NEW-FL)
	`((,FLAVOR-NAME ,OLD-FL))))
    ;; :ERROR-P NIL on these because blowing out into the debugger at this point can
    ;; only be worse than having a missing required method, or an extraneous method
    ;; for the method combination, or something of that sort.  The flavor has already
    ;; been instantiated (in its prior incarnation).
    (COMPOSE-METHOD-COMBINATION FLAVOR-NAME :ERROR-P NIL)
    (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ERROR-P NIL)
    (VALIDATE-CONSTRUCTOR-FUNCTIONS NEW-FL)
    (INSTALL-INSTANCE-TRANSFORMING-HANDLER-TABLE OLD-FL)
    (LET ((CLASS (CLOS:FIND-CLASS FLAVOR-NAME NIL)))
      (WHEN CLASS
	(CLOS-INTERNALS::RECOMBINE-METHODS CLASS T OLD-FL)))
    (PUSH (LIST OLD-FL NEW-FL) *TRANSFORM-FLAVOR-WARNINGS*)))

(DEFUN COPY-FLAVOR (FL SAME-ENV)
  (LET ((DEFAULT-CONS-AREA (IF SAME-ENV *FLAVOR-AREA* DEFAULT-CONS-AREA)))
    (MAKE-FLAVOR :NAME (FLAVOR-NAME FL)
		 :LOCAL-INSTANCE-VARIABLES (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
		 :LOCAL-COMPONENTS (FLAVOR-LOCAL-COMPONENTS FL)
		 :LOCAL-COMPONENT-PRECEDENCE (FLAVOR-LOCAL-COMPONENT-PRECEDENCE FL)
		 :LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS
		   (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
		 :LOCAL-INITABLE-INSTANCE-VARIABLES
		   (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
		 :LOCAL-READABLE-INSTANCE-VARIABLES
		   (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)
		 :LOCAL-WRITABLE-INSTANCE-VARIABLES
		   (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)
		 :LOCAL-DEPENDENTS (FLAVOR-LOCAL-DEPENDENTS FL)
		 :ALL-COMPOSED-DEPENDENTS (FLAVOR-ALL-COMPOSED-DEPENDENTS FL)
		 :METHOD-TABLE (FLAVOR-METHOD-TABLE FL)
		 :LOCAL-FUNCTIONS (FLAVOR-LOCAL-FUNCTIONS FL)
		 :AREA-KEYWORD (FLAVOR-AREA-KEYWORD FL)
		 :MAPPING-TABLE-NAMES (FLAVOR-MAPPING-TABLE-NAMES FL)
		 :MAPPING-TABLE-VARIABLE-P (FLAVOR-MAPPING-TABLE-VARIABLE-P FL)
		 ;; Ordered instance variables can never go away within a bootload, because
		 ;; their offsets may have been encoded into methods by fixup-method.
		 :ALL-ORDERED-INSTANCE-VARIABLES
		   (AND SAME-ENV (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL))
		 ;; Retain local-function interpreter definition cells for functions
		 ;; defined here, but not inherited ones.
		 :ALL-LOCAL-FUNCTIONS
		   (LOOP FOR ELEM IN (FLAVOR-ALL-LOCAL-FUNCTIONS FL)
			 WHEN (EQ (METHOD-FLAVOR (THIRD ELEM)) (FLAVOR-NAME FL))
			   COLLECT ELEM)
		 :FLAGS (LOGAND (FLAVOR-FLAGS FL)
				*FLAGS-THAT-SURVIVE-COPYING*)
		 :PLIST (LOOP FOR (PROP VAL) ON (FLAVOR-PLIST FL) BY 'CDDR
			      UNLESS (MEMBER PROP *PROPERTIES-LOST-BY-COPYING*)
				NCONC (LIST PROP VAL)))))

;;; Obsoleting defflavors
;;;    Obsolete the flavor so that including it in other defflavors will generate
;;;    a warning.
;;;    Obsolete any accessors (:readable/writable/locatable-instance-variables).
;;; [  Could call COMPILER:MAKE-MESSAGE-OBSOLETE but I guess I'll skip that.]
(DEFUN (:PROPERTY DEFFLAVOR COMPILER:MAKE-OBSOLETE) (FLAVOR-NAME REASON &OPTIONAL IGNORE)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (SETF (GET FLAVOR-NAME 'OBSOLETE-FLAVOR) (CONS REASON FDEFINE-FILE-PATHNAME))
    (LOOP WITH REASON = (FORMAT NIL "it is an accessor for the obsolete ~S flavor.~%~:"
				FLAVOR-NAME REASON)
	  FOR (ACCESSOR) IN (APPEND (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)
				    (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)
				    (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL))
	  DO (WHEN (GENERIC-FUNCTION-EXPLICIT (FIND-GENERIC-FUNCTION ACCESSOR))
	       (COMPILER:MAKE-OBSOLETE-1 ACCESSOR REASON)))))

;;; Undo a DEFFLAVOR
(DEFUN REMOVE-FLAVOR (FLAVOR-NAME)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    ;; We're about to make several changes, ending in the final elimination of
    ;; the flavor.  Take charge from our callees, and tell DW it's over when it's over.
    (WITH-PENDING-DW-UPDATES
      (WITHOUT-ABORTS ("Flavor data structures are being updated to remove the flavor ~S.~@
		       Aborting now could damage this flavor, its relationships with its~@
		       component flavors, and the table of names of all flavors."
		       FLAVOR-NAME)
	(NOTE-CHANGE-FOR-DW FLAVOR-NAME)
	(WITHOUT-INTERRUPTS
	  (SETQ *ALL-FLAVOR-NAMES* (DELETE FLAVOR-NAME *ALL-FLAVOR-NAMES*))
	  (SI:AARRAY-DELETE *ALL-FLAVOR-NAMES-AARRAY*
			    (SYMBOL-NAME FLAVOR-NAME)
			    FLAVOR-NAME 'ATOM))
	(REMOVE-FLAVOR-BACK-POINTERS (FLAVOR-LOCAL-COMPONENTS FL) NIL FLAVOR-NAME)
	(REMOVE-FLAVOR-BACK-POINTERS (FLAVOR-REQUIRED-FLAVORS FL) NIL FLAVOR-NAME)
	(REMOVE-FROM-ALL-COMPOSED-DEPENDENTS FL)
	(WITHOUT-INTERRUPTS
	  (DOLIST (F (FLAVOR-LOCAL-DEPENDENTS FL))
	    (PUSH (LIST FLAVOR-NAME F) *FLAVOR-PENDING-DEPENDS*)))
	;; Remove genericflavor links
	(FLET ((CLEAN (LIST)
		 (LOOP FOR (GENERIC-FUNCTION-NAME) IN LIST DO
		   (LET ((GF (FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME)))
		     (SETF (GENERIC-FUNCTION-FLAVORS GF)
			   (DELETE FLAVOR-NAME (GENERIC-FUNCTION-FLAVORS GF)))))))
	  (CLEAN (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL))
	  (CLEAN (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL))
	  (CLEAN (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL))
	  (CLEAN (FLAVOR-METHOD-TABLE FL)))
	(REMPROP FLAVOR-NAME 'FLAVOR)
	(WHEN (FBOUNDP 'CLOS-INTERNALS::REMOVE-FLAVOR-CLASS)
	  (CLOS-INTERNALS::REMOVE-FLAVOR-CLASS FLAVOR-NAME))
	(WITH-TRANSFORM-FLAVOR-WARNINGS
	  (DOLIST (F (FLAVOR-LOCAL-DEPENDENTS FL))
	    (REDEFINE-FLAVOR F NIL T T T T)))
	;; Remove additional flavors due to :MIXTURE
	(MAPC #'REMOVE-FLAVOR
	      (DELETE FLAVOR-NAME (FLAVOR-MIXTURE-NAMES (FLAVOR-MIXTURE FL))))))))

;You typically do this and then do a DEFFLAVOR to add options such as readable or initable
;or to change the default initial value.
(DEFUN RENAME-INSTANCE-VARIABLE (FLAVOR-NAME OLD NEW)
  (SI:CHECK-SYMBOL-SETABILITY NEW "declare an instance variable")
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (UNLESS (MEMBER OLD (FLAVOR-LOCAL-INSTANCE-VARIABLES FL))
      (ERROR "~S is not an instance variable of ~S" OLD FLAVOR-NAME))
    (WHEN (MEMBER NEW (FLAVOR-LOCAL-INSTANCE-VARIABLES FL))
      (ERROR "~S already has an instance variable named ~S" FLAVOR-NAME NEW))
    (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)
	  (SUBSTITUTE NEW OLD (FLAVOR-LOCAL-INSTANCE-VARIABLES FL)))
    (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
	  (LOOP FOR ITEM IN (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL)
		COLLECT (IF (EQ (CAR ITEM) OLD) (CONS NEW (CDR ITEM)) ITEM)))
    (SETF (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
	  (REMOVE OLD (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL) :KEY #'SECOND))
    (SETF (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)
	  (REMOVE OLD (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL) :KEY #'SECOND))
    (SETF (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)
	  (REMOVE OLD (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL) :KEY #'SECOND))
    (SETF (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)
	  (REMOVE OLD (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL) :KEY #'SECOND))
    (SETF (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL)
	  (SUBSTITUTE NEW OLD (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL)))
    (SETF (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL)
	  (SUBSTITUTE NEW OLD (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL)))
    ;; Let who-calls know of any changed accessors
    (SI:WHEN-IN-INCREMENTAL-WHO-CALLS-MODE
      (SI:WHO-CALLS-DEFFLAVOR-HOOK FL))
    (FLET ((FIX-FLAVOR (FL)
	     (LET ((POS (POSITION OLD (FLAVOR-ALL-INSTANCE-VARIABLES FL))))
	       (WHEN POS
		 (SETF (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL)
		       (REMOVE (1+ POS) (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL)
			       :KEY #'SECOND))))
	     (SETF (FLAVOR-ALL-INSTANCE-VARIABLES FL)
		   (SUBSTITUTE NEW OLD (FLAVOR-ALL-INSTANCE-VARIABLES FL)))
	     (SETF (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL)
		   (SUBSTITUTE NEW OLD (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL)))
	     (SETF (FLAVOR-MAPPING-TABLE-NAMES FL)
		   (LOOP FOR VAR IN (FLAVOR-MAPPING-TABLE-NAMES FL) FOR J FROM 0
			 COLLECT (IF (AND (EQ VAR OLD)
					  (AREF (FLAVOR-MAPPING-TABLE-VARIABLE-P FL) J))
				     NEW
				     VAR)))))
      (IF (FLAVOR-ALL-COMPOSED-DEPENDENTS FL)
	  (DO-ALL-COMPOSED-DEPENDENTS (DEPENDENT FL FL)
	    (FIX-FLAVOR FL))
	  (FIX-FLAVOR FL)))))
