;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains handler tables and mapping tables

;;;; Define the layout of handler tables, a specialized type of hash table

;; Explanation of the values for GC-DEPENDENCE and GC-GENERATION:
;;
;; GC Dependence	GC Generation
;; -------------	---------------------------------------------------------
;; none			NIL (actually, the value is ignored)
;; static		%GC-STATIC-GENERATION-NUMBER when last rehashed,
;;			or :DEFAULT, which means that
;;			*LAST-REHASH-GC-STATIC-GENERATION-NUMBER* is the
;;			value of %GC-STATIC-GENERATION-NUMBER when last rehashed.
;; dynamic		%GC-DYNAMIC-GENERATION-NUMBER when last rehashed
;; ephemeral		%GC-GENERATION-NUMBER when last rehashed

(DEFSUBST HANDLER-TABLE-GC-DEPENDENCE (HT) (AREF HT 0))
	;The GC dependence of this table.

(DEFSUBST HANDLER-TABLE-METHOD-ORDER (HT) (AREF HT 1))
	;List of generics that want to be found with fewer hash probes

(DEFSUBST HANDLER-TABLE-DEFAULT-HANDLER (HT) (AREF HT 2))
	;Function called when method lookup fails and rehashing doesn't help

(DEFSUBST HANDLER-TABLE-NUMBER-OF-ENTRIES (HT) (AREF HT 3))
	;Number of valid entries in the table

(DEFSUBST HANDLER-TABLE-MASK (HT) (AREF HT 4))
	;Mask anded with %pointer of message symbol to get hash probe index
	;This is copied into the flavor, from whence the microcode gets it

(DEFSUBST HANDLER-TABLE-ESCAPE-HANDLER (HT) (AREF HT 5))
	;Function called if microcoded message lookup fails

(DEFSUBST HANDLER-TABLE-GC-GENERATION (HT) (AREF HT 6))
	;Value of %GC-GENERATION-NUMBER when rehashed

(DEFSUBST HANDLER-TABLE-ADDRESS (HT) (LOCF (AREF HT 7)))
  	;Address of the first entry

(DEFUN HANDLER-TABLE-LAST-ADDRESS (HT) (LOCF (AREF HT (- (ARRAY-TOTAL-SIZE HT) 3))))
	;Address of last slot, always empty

;Three-word entries for messages handled:
;The contents of these slots are known to microcode
;The order of these slots is wired into some of the code below
;Unused table entries have NIL in the selector and mapping table, and escape-handler in the function

#+IMACH (PROGN

(DEFSUBST HANDLER-TABLE-SELECTOR (P)
  (LOCATION-CONTENTS P))

(DEFSUBST HANDLER-TABLE-FUNCTION (P)
  (LOCATION-CONTENTS (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)))

(DEFSUBST HANDLER-TABLE-MAPPING-TABLE (P)
  (LOCATION-CONTENTS (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 2)))

(DEFUN HANDLE-INTERPRETED-DEFMETHOD (FUNCTION-PARAMETER SELF &REST ARGS)
  (APPLY (FIRST FUNCTION-PARAMETER) (SECOND FUNCTION-PARAMETER) SELF ARGS))

)

#+3600 (PROGN

(DEFSUBST HANDLER-TABLE-SELECTOR (P)
  (LOCATION-CONTENTS P))

(DEFSUBST HANDLER-TABLE-MAPPING-TABLE (P)
  (LOCATION-CONTENTS (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)))

(DEFSUBST HANDLER-TABLE-FUNCTION (P)
  (LOCATION-CONTENTS (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 2)))

(DEFUN HANDLE-INTERPRETED-DEFMETHOD (SELF FUNCTION-PARAMETER SELECTOR &REST ARGS)
  (APPLY (FIRST FUNCTION-PARAMETER) SELF (SECOND FUNCTION-PARAMETER) SELECTOR ARGS))

)

(DEFUN SET-HANDLER-TABLE-ELEMENT (CELL SELECTOR FUNCTION PARAMETER)
  ;; Don't write if nothing has changed, to keep IDS size down
  (UNLESS (EQ (HANDLER-TABLE-SELECTOR CELL) SELECTOR)
    (SETF (HANDLER-TABLE-SELECTOR CELL) SELECTOR))
  (LET ((OLD-PARAMETER (HANDLER-TABLE-MAPPING-TABLE CELL)))
    (MULTIPLE-VALUE-BIND (F P)
	(TYPECASE FUNCTION
	  (COMPILED-FUNCTION
	    ;; The function cell gets the PC to the method, and the mapping table cell gets
	    ;; the mapping table
	    (VALUES #+3600 FUNCTION #+IMACH (%MAKE-POINTER DTP-EVEN-PC FUNCTION)
		    PARAMETER))
	  (OTHERWISE
	    ;; The function cell gets the PC for the interpreter, and the mapping table is
	    ;; the function to apply
	    (VALUES #+3600 #'HANDLE-INTERPRETED-DEFMETHOD
		    #+IMACH (%MAKE-POINTER DTP-EVEN-PC #'HANDLE-INTERPRETED-DEFMETHOD)
		    (IF (AND (LISTP OLD-PARAMETER)
			     (EQ (FIRST OLD-PARAMETER) FUNCTION)
			     (EQ (SECOND OLD-PARAMETER) PARAMETER))
			OLD-PARAMETER
			(LIST-IN-AREA *FLAVOR-AREA* FUNCTION PARAMETER)))))
      (UNLESS (EQ (HANDLER-TABLE-FUNCTION CELL) F)
	(SETF (HANDLER-TABLE-FUNCTION CELL) F))
      (UNLESS (EQ OLD-PARAMETER P)
	(SETF (HANDLER-TABLE-MAPPING-TABLE CELL) P)))))

(DEFUN SET-HANDLER-VECTOR-ELEMENT (HANDLER-CELL PARAMETER-CELL FUNCTION PARAMETER)
  (LET ((OLD-PARAMETER (LOCATION-CONTENTS PARAMETER-CELL)))
    (MULTIPLE-VALUE-BIND (F P)
	(TYPECASE FUNCTION
	  (COMPILED-FUNCTION
	    (VALUES FUNCTION PARAMETER))
	  (OTHERWISE
	    ;; The function cell gets the PC for the interpreter, and the mapping table is
	    ;; the function to apply
	    (VALUES #'HANDLE-INTERPRETED-DEFMETHOD
		    (IF (AND (LISTP OLD-PARAMETER)
			     (EQ (FIRST OLD-PARAMETER) FUNCTION)
			     (EQ (SECOND OLD-PARAMETER) PARAMETER))
			OLD-PARAMETER
			(LIST-IN-AREA *FLAVOR-AREA* FUNCTION PARAMETER)))))
      (UNLESS (EQ (LOCATION-CONTENTS HANDLER-CELL) F)
	(SETF (LOCATION-CONTENTS HANDLER-CELL) F))
      (UNLESS (EQ OLD-PARAMETER P)
	(SETF (LOCATION-CONTENTS PARAMETER-CELL) P)))))

(DEFUN SET-HANDLER-TABLE-PARAMETER (CELL PARAMETER)
  (LET ((EXTRA-ARG (HANDLER-TABLE-MAPPING-TABLE CELL)))
    (IF (EQ (HANDLER-TABLE-FUNCTION CELL)
	    #+3600 #'HANDLE-INTERPRETED-DEFMETHOD
	    #+IMACH (%MAKE-POINTER DTP-EVEN-PC #'HANDLE-INTERPRETED-DEFMETHOD))
	(UNLESS (EQ (SECOND EXTRA-ARG) PARAMETER)
	  (SETF (SECOND EXTRA-ARG) PARAMETER))
	(UNLESS (EQ EXTRA-ARG PARAMETER)
	  (SETF (HANDLER-TABLE-MAPPING-TABLE CELL) PARAMETER)))))

(DEFUN SET-HANDLER-VECTOR-PARAMETER (HANDLER-CELL PARAMETER-CELL PARAMETER)
  (LET ((EXTRA-ARG (LOCATION-CONTENTS PARAMETER-CELL)))
    (IF (EQ (LOCATION-CONTENTS HANDLER-CELL) #'HANDLE-INTERPRETED-DEFMETHOD)
	(UNLESS (EQ (SECOND EXTRA-ARG) PARAMETER)
	  (SETF (SECOND EXTRA-ARG) PARAMETER))
	(UNLESS (EQ EXTRA-ARG PARAMETER)
	  (SETF (LOCATION-CONTENTS PARAMETER-CELL) PARAMETER)))))

;;; This variable controls how full the hash tables are allowed to get.
;;; In general they will be less full than this since their size has to
;;; be a power of two because the microcode does the hashing with LOGAND.
;;; In some system 243, message handlers generated with .8 fullness, the
;;; expected search distance was increased from 1.2 to 1.5, but the tables
;;; went from 2.7M words to 1.5M words.
;;; For some system 329:
;;; Average of 1,066 flavors with 85,958 handlers (81 avg/flavor), 54% avg density:
;;; 2.05 average probes, 82 maximum, 71%  1 probe, 91%  3, 99%  17
;;; Total of 490,244 words of handler tables.
;;; In system 362, increasing this from 0.8 to 0.85 saved 377 pages while costing
;;; only 1/2 microsecond on average and only 2 microseconds at the 95th percentile
;;; (but 30 microseconds worst case) in increased collisions during method lookup.
(DEFPARAMETER HANDLER-TABLE-FULLNESS-THRESHOLD 0.85)

;;; This variable controls how many extra entries after the last probe address
;;; are initially allowed.  The last entry in the table always has to be unused
;;; so the search will terminate (it doesn't wrap around).
;;; This needs to be big enough to eliminate handler table growing in the
;;; rehash that happens during the disk-save after a reorder-memory, because
;;; growing a handler table there screws up the careful placement of handler
;;; tables in virtual address space by reorder-memory.
(DEFPARAMETER HANDLER-TABLE-EXTRA-SPACE 5)

;; This variables control when OPTIMIZE-HANDLER-TABLES is run.  If a table's GC-DEPENDENCE
;; is static, and its generation is :DEFAULT, then this is the generation number which is
;; really used.  This keeps down on modified pages when incrementally reordering memory.
(DEFVAR *LAST-REHASH-GC-STATIC-GENERATION-NUMBER* %GC-STATIC-GENERATION-NUMBER)

;; When changing the value of the above variable, this variable is used to half mask
;; its value.  The decision of whether to rehash is based only upon the above variable,
;; but the decision on what to store into the table is based on this.
(DEFVAR *THIS-REHASH-GC-STATIC-GENERATION-NUMBER* NIL)

;;;; Routines for handler tables

(DEFUN MAKE-HANDLER-TABLE (NUMBER-OF-METHODS METHOD-ORDER DEFAULT-HANDLER)
  (MULTIPLE-VALUE-BIND (SLOTS EXTENSION)
      (HANDLER-TABLE-OPTIMAL-N-SLOTS NUMBER-OF-METHODS)
    (MAKE-HANDLER-TABLE-INTERNAL (1- SLOTS)
				 (HANDLER-TABLE-SIZE-FOR-N-SLOTS (+ SLOTS EXTENSION))
				 METHOD-ORDER DEFAULT-HANDLER
				 (PROGN
				   #+3600 'HANDLE-UNCLAIMED-MESSAGE
				   #+IMACH
				   (%MAKE-POINTER-OFFSET
				     DTP-EVEN-PC #'HANDLE-UNCLAIMED-MESSAGE 2)))))

(DEFUN MAKE-HANDLER-TABLE-INTERNAL (MASK SIZE METHOD-ORDER DEFAULT-HANDLER ESCAPE-HANDLER)
  (LET ((HT (MAKE-ARRAY SIZE :AREA *FLAVOR-AREA*)))
    (SETF (HANDLER-TABLE-MASK HT) MASK)
    (SETF (HANDLER-TABLE-NUMBER-OF-ENTRIES HT) 0)
    (SETF (HANDLER-TABLE-ESCAPE-HANDLER HT) ESCAPE-HANDLER)
    (SETF (HANDLER-TABLE-DEFAULT-HANDLER HT) (OR DEFAULT-HANDLER
						 'HANDLE-REAL-UNCLAIMED-MESSAGE))
    (SETF (HANDLER-TABLE-GC-DEPENDENCE HT) %GC-DEPENDENCE-NONE)
    (SETF (HANDLER-TABLE-GC-GENERATION HT) NIL)
    (SETF (HANDLER-TABLE-METHOD-ORDER HT) METHOD-ORDER)
    (LOOP FOR P = (HANDLER-TABLE-ADDRESS HT) THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 3)
	  DO (SETF (HANDLER-TABLE-FUNCTION P) ESCAPE-HANDLER)
	  UNTIL (EQ P LIMIT) WITH LIMIT = (HANDLER-TABLE-LAST-ADDRESS HT))
    HT))

(DEFUN INSTALL-HANDLER-TABLE (FL HT)
  (SETF (FLAVOR-HASH-MASK FL) (HANDLER-TABLE-MASK HT))
  (SETF (FLAVOR-HASH-ADDRESS FL) (HANDLER-TABLE-ADDRESS HT))
  (SETF (FLAVOR-HANDLER-TABLE FL) HT))

(DEFUN HANDLER-TABLE-OPTIMAL-N-SLOTS (NUMBER-OF-METHODS)
  (DECLARE (VALUES SLOTS EXTENSION))
  ;; Minimum possible size of table.  Don't make tables smaller than 8 slots;
  ;; it's pointless given that we have to provide extra space (see HANDLER-TABLE-EXTRA-SPACE).
  (LET ((SIZE (MAX 8 (ASH 1 (INTEGER-LENGTH NUMBER-OF-METHODS)))))
    (LOOP UNTIL ( (* SIZE HANDLER-TABLE-FULLNESS-THRESHOLD) NUMBER-OF-METHODS)
	  DO (SETQ SIZE (ASH SIZE 1)))
    (VALUES SIZE HANDLER-TABLE-EXTRA-SPACE)))

(DEFUN HANDLER-TABLE-SIZE-FOR-N-SLOTS (N-SLOTS)
  (+ 7 (* 3 N-SLOTS)))

(DEFUN HANDLER-TABLE-N-SLOTS-FOR-SIZE (SIZE)
  (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)
      (FLOOR (- SIZE 7) 3)
    (UNLESS (AND (ZEROP REMAINDER) (NOT (MINUSP QUOTIENT)))
      (ERROR "Illegal size for handler table:  ~D" SIZE))
    QUOTIENT))

(DEFUN HANDLER-TABLE-ACTUAL-N-SLOTS (HANDLER-TABLE)
  (DECLARE (VALUES SLOTS EXTENSION))
  (LET* ((RAW-N-SLOTS (HANDLER-TABLE-N-SLOTS-FOR-SIZE (ARRAY-TOTAL-SIZE HANDLER-TABLE)))
	 (BASE-N-SLOTS (- RAW-N-SLOTS HANDLER-TABLE-EXTRA-SPACE))
	 ;; Round this down to the next lower power of 2.
	 (N-SLOTS (ASH 1 (1- (INTEGER-LENGTH BASE-N-SLOTS)))))
    ;; Check DLA's sanity.  Remove this eventually.
    (UNLESS (AND ( N-SLOTS BASE-N-SLOTS) (< BASE-N-SLOTS (* 2 N-SLOTS)))
      (ERROR "Error in handler table size calculation -- shouldn't happen."))
    (VALUES N-SLOTS (- RAW-N-SLOTS N-SLOTS))))

;; This must be called with GC flips inhibited, and with the handler table current.
;; Failure to do so may cause the handler table to be marked as not needing a rehash
;; when it really does.
(DEFUN HANDLER-TABLE-CHECK-GC-DEPENDENCE (HT SELECTOR)
  (LET ((DEPENDENCE (GC-DEPENDENCE SELECTOR)))
    (WHEN (> DEPENDENCE (HANDLER-TABLE-GC-DEPENDENCE HT))
      (SETF (HANDLER-TABLE-GC-DEPENDENCE HT) DEPENDENCE)
      (SETF (HANDLER-TABLE-GC-GENERATION HT)
	    (SELECTOR DEPENDENCE =
	      (%GC-DEPENDENCE-STATIC
		(IF (= %GC-STATIC-GENERATION-NUMBER
		       (OR *THIS-REHASH-GC-STATIC-GENERATION-NUMBER*
			   *LAST-REHASH-GC-STATIC-GENERATION-NUMBER*))
		    :DEFAULT
		    %GC-STATIC-GENERATION-NUMBER))
	      (%GC-DEPENDENCE-DYNAMIC %GC-DYNAMIC-GENERATION-NUMBER)
	      (%GC-DEPENDENCE-EPHEMERAL %GC-GENERATION-NUMBER))))))

(DEFUN INSERT-IN-HANDLER-TABLE (FL SELECTOR HANDLER MAPPING-TABLE)
  ;; Disable interrupts so GC won't flip and so other processes won't molest the table
  (WITHOUT-INTERRUPTS
    (LET ((HT (FLAVOR-HANDLER-TABLE FL)))
      (MULTIPLE-VALUE-BIND (FOUND-P IGNORE CELL)
	  (HANDLER-TABLE-SEARCH FL SELECTOR)
	(IF FOUND-P
	    (COND ((NULL HANDLER)
		   ;; Remove the entry, and shuffle back any entries we have to
		   ;; shuffle due to collisions.
		   (DECF (HANDLER-TABLE-NUMBER-OF-ENTRIES HT))
		   (SET-HANDLER-TABLE-ELEMENT CELL NIL (HANDLER-TABLE-ESCAPE-HANDLER HT) NIL)
		   (SETF (HANDLER-TABLE-METHOD-ORDER HT)
			 (REMOVE SELECTOR (HANDLER-TABLE-METHOD-ORDER HT)))
		   ;; Next slot occupied?  May have been occupied due to a hash collision.
		   (WHEN (HANDLER-TABLE-SELECTOR (%MAKE-POINTER-OFFSET DTP-LOCATIVE CELL 3))
		     (REHASH-HANDLER-TABLE FL HT T)))
		  (T
		   ;; Update the entry
		   (SET-HANDLER-TABLE-ELEMENT CELL SELECTOR HANDLER MAPPING-TABLE)))
	    (WHEN HANDLER
	      (LET ((N-ENTRIES (1+ (HANDLER-TABLE-NUMBER-OF-ENTRIES HT))))
		(WHEN ( N-ENTRIES
			 (* (1+ (HANDLER-TABLE-MASK HT)) HANDLER-TABLE-FULLNESS-THRESHOLD))
		  (REHASH-HANDLER-TABLE FL HT T N-ENTRIES)
		  (SETQ HT (FLAVOR-HANDLER-TABLE FL))
		  (MULTIPLE-VALUE-SETQ (NIL NIL CELL) (HANDLER-TABLE-SEARCH FL SELECTOR)))
		;; Add a new entry
		(SETF (HANDLER-TABLE-NUMBER-OF-ENTRIES HT) N-ENTRIES)
		;; When adding an ephemeral key to the table, need to rehash more often
		(HANDLER-TABLE-CHECK-GC-DEPENDENCE HT SELECTOR)
		;; Expand table if necessary to accomodate the new entry
		(WHEN (NULL CELL)		;Fell off end of table
		  (SETQ CELL (ENLARGE-HANDLER-TABLE FL HT SELECTOR)))
		(SET-HANDLER-TABLE-ELEMENT CELL SELECTOR HANDLER MAPPING-TABLE))))
	NIL))))

;;; Fast version used when building a new handler table from scratch.
;;; We can assume that SELECTOR will not be already present in the table and
;;; that the table will be big enough almost all the time.
;;; Returns the table, in case it grows.
;;; Note that the table is not yet pointed-to by its flavor.
;;; Don't have to worry about other processes molesting the table for that reason.
;;; Note:  We don't worry about GC flipping here.  All callers must ensure
;;; that GC flipping is inhibited for HANDLER-TABLE-CHECK-GC-DEPENDENCE to work.
(DEFUN INSERT-DIRECTLY-IN-HANDLER-TABLE (HT SELECTOR HANDLER MAPPING-TABLE)
  ;; Do the equivalent of HANDLER-TABLE-SEARCH
  (LET ((CELL
	  (LOOP WITH P = (%MAKE-POINTER-OFFSET DTP-LOCATIVE	;Initial probe address -1
					       (HANDLER-TABLE-ADDRESS HT)
					       (1- (* (LOGAND (HANDLER-TABLE-MASK HT)
							      (%POINTER SELECTOR))
						      3)))
		AS PROBE = (%P-CONTENTS-INCREMENT-POINTER P)
		UNTIL (NULL PROBE)
		DO (SETQ P (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 2))
		FINALLY
		  (WHEN (EQ (HANDLER-TABLE-LAST-ADDRESS HT) P)
		    (SETQ HT (SI:ADJUST-ARRAY-SIZE HT (+ (ARRAY-TOTAL-SIZE HT) 3)))
		    (SETF (HANDLER-TABLE-FUNCTION (HANDLER-TABLE-LAST-ADDRESS HT))
			  (HANDLER-TABLE-ESCAPE-HANDLER HT))
		    (SETQ P (FOLLOW-CELL-FORWARDING P NIL)))
		  (RETURN P))))
    (INCF (HANDLER-TABLE-NUMBER-OF-ENTRIES HT))
    ;; When adding an ephemeral key to the table, need to rehash more often
    (HANDLER-TABLE-CHECK-GC-DEPENDENCE HT SELECTOR)
    (SET-HANDLER-TABLE-ELEMENT CELL SELECTOR HANDLER MAPPING-TABLE)
    HT))

;; Grow the handler table only; the caller will take care of installing the new one.
(DEFUN ENLARGE-HANDLER-TABLE-INTERNAL (HT SELECTOR)
  (DECLARE (VALUES NHT CELL))
  (LET ((NHT (SI:ADJUST-ARRAY-SIZE HT (+ (ARRAY-TOTAL-SIZE HT) 3))))
    (SETF (HANDLER-TABLE-FUNCTION (HANDLER-TABLE-LAST-ADDRESS NHT))
	  (HANDLER-TABLE-ESCAPE-HANDLER NHT))
    (MULTIPLE-VALUE-BIND (IGNORE IGNORE CELL)
	(HANDLER-TABLE-SEARCH-INTERNAL
	  NHT (HANDLER-TABLE-ADDRESS NHT) (HANDLER-TABLE-MASK NHT) SELECTOR)
      (UNLESS CELL
	(ERROR "Internal error: expanding handler table didn't make any room"))
      (VALUES NHT CELL))))

;; Need more extra space at the end of a handler table.
;; Grow the table and install it in the flavor.
(DEFUN ENLARGE-HANDLER-TABLE (FL HT SELECTOR)
  (MULTIPLE-VALUE-BIND (NHT CELL)
      (ENLARGE-HANDLER-TABLE-INTERNAL HT SELECTOR)
    (UNLESS (EQ HT NHT)				;Snap out forwarding
      (INSTALL-HANDLER-TABLE FL NHT))
    CELL))

;; This does exactly what the microcode does, but returns extra information.
(DEFUN HANDLER-TABLE-SEARCH-INTERNAL (HT ADDRESS MASK SELECTOR)
  (WHEN (NULL ADDRESS)
    (RETURN-FROM HANDLER-TABLE-SEARCH-INTERNAL NIL))
  (SETQ ADDRESS (%MAKE-POINTER-OFFSET DTP-LOCATIVE ADDRESS	;Initial probe address -1
				      (1- (* (LOGAND MASK (%POINTER SELECTOR)) 3))))
  (LOOP AS PROBE = (%P-CONTENTS-INCREMENT-POINTER ADDRESS) DO
    (COND ((EQ PROBE SELECTOR)
	   (RETURN (VALUES (HANDLER-TABLE-FUNCTION ADDRESS)
			   (HANDLER-TABLE-MAPPING-TABLE ADDRESS)
			   ADDRESS)))		;Slot
	  ((NULL PROBE)
	   (WHEN (EQ (HANDLER-TABLE-LAST-ADDRESS HT) ADDRESS)
	     (RETURN NIL))			;Dropped off end of table
	   (RETURN (VALUES NIL NIL ADDRESS)))	;Free slot
	  (T (SETQ ADDRESS (%MAKE-POINTER-OFFSET DTP-LOCATIVE ADDRESS 2))))))

;;; Should be called with interrupts inhibited
;;; This imitates what the microcode does, except that it knows how to rehash.
;;; Returns NIL for the METHOD and MAPPING-TABLE if no entry matching the selector
;;; is found, and in that case SLOT is the address of the free slot where it could go.
;;; Can return a SLOT of NIL if it drops off the end of the table or if
;;; the flavor does not have a handler table.
(DEFUN HANDLER-TABLE-SEARCH (FL SELECTOR)
  (DECLARE (VALUES METHOD MAPPING-TABLE SLOT))
  (REHASH-HANDLER-TABLE FL)
  (HANDLER-TABLE-SEARCH-INTERNAL (FLAVOR-HANDLER-TABLE FL) (FLAVOR-HASH-ADDRESS FL)
				 (FLAVOR-HASH-MASK FL) SELECTOR))

;;; On the I machine, the table contains an internal form of the
;;; function and parameter the "user" thinks is in there, so we have to
;;; do a little more work to get to the function and its parameter.
(DEFUN HANDLER-TABLE-FUNCTION-AND-PARAMETER (FL SELECTOR)
  (DECLARE (VALUES FUNCTION PARAMETER SLOT))
  (REHASH-HANDLER-TABLE FL)
  (MULTIPLE-VALUE-BIND (HANDLER-PC EXTRA-ARG CELL)
      (HANDLER-TABLE-SEARCH-INTERNAL (FLAVOR-HANDLER-TABLE FL) (FLAVOR-HASH-ADDRESS FL)
				     (FLAVOR-HASH-MASK FL) SELECTOR)
    (WHEN HANDLER-PC
      (LET ((HANDLER #+3600 HANDLER-PC
		     #+IMACH (%MAKE-POINTER DTP-COMPILED-FUNCTION HANDLER-PC)))
	(IF (EQ HANDLER #'HANDLE-INTERPRETED-DEFMETHOD)
	    (VALUES (FIRST EXTRA-ARG)
		    (SECOND EXTRA-ARG)
		    CELL)
	    (VALUES HANDLER
		    EXTRA-ARG
		    CELL))))))

;;; Must be called with interrupts inhibited, to prevent GC from flipping, also to
;;; prevent other processes from trying to rehash at same time.
;;; Returns T if it actually rehashed it.
;;; Note that this must not store into the handler table if no rehashing is required,
;;; in order to cut down the number of modified pages seen by incremental disk save.
;;; This can grow the table.
(DEFUN REHASH-HANDLER-TABLE (FL &OPTIONAL (HT (FLAVOR-HANDLER-TABLE FL))
					  (FORCE NIL)
					  (GROW-TO-N-ENTRIES NIL))
  (UNLESS HT
    (RETURN-FROM REHASH-HANDLER-TABLE NIL))
  (WHEN (OR FORCE
	    ;; Rehash if GC has changed the hash values.
	    (LET ((GENERATION (HANDLER-TABLE-GC-GENERATION HT)))
	      (SELECTOR (HANDLER-TABLE-GC-DEPENDENCE HT) =
		(%GC-DEPENDENCE-STATIC ( (IF (EQ GENERATION :DEFAULT)
					      *LAST-REHASH-GC-STATIC-GENERATION-NUMBER*
					      GENERATION)
					  %GC-STATIC-GENERATION-NUMBER))
		(%GC-DEPENDENCE-NONE NIL)
		(%GC-DEPENDENCE-DYNAMIC ( %GC-DYNAMIC-GENERATION-NUMBER GENERATION))
		(%GC-DEPENDENCE-EPHEMERAL ( %GC-GENERATION-NUMBER GENERATION)))))
    (LET ((HANDLER-TABLE-SIZE (ARRAY-TOTAL-SIZE HT))
	  (MASK (HANDLER-TABLE-MASK HT))
	  (GREW NIL))
      ;; If we were requested to grow, then do so if it will make us bigger.
      (WHEN GROW-TO-N-ENTRIES
	(MULTIPLE-VALUE-BIND (N-SLOTS EXTENSION)
	    (HANDLER-TABLE-OPTIMAL-N-SLOTS GROW-TO-N-ENTRIES)
	  (LET ((SIZE (HANDLER-TABLE-SIZE-FOR-N-SLOTS (+ N-SLOTS EXTENSION))))
	    (WHEN (> SIZE HANDLER-TABLE-SIZE)
	      (SETQ HANDLER-TABLE-SIZE SIZE
		    MASK (1- N-SLOTS)
		    GREW T)))))
      ;; NHT is a temporary buffer, unless we have to grow the handler table
      (LET* ((NHT (MAKE-HANDLER-TABLE-INTERNAL MASK HANDLER-TABLE-SIZE
					       (HANDLER-TABLE-METHOD-ORDER HT)
					       (HANDLER-TABLE-DEFAULT-HANDLER HT)
					       (HANDLER-TABLE-ESCAPE-HANDLER HT)))
	     (NHT-ADDRESS (HANDLER-TABLE-ADDRESS NHT)))
	(SETF (HANDLER-TABLE-NUMBER-OF-ENTRIES NHT) (HANDLER-TABLE-NUMBER-OF-ENTRIES HT))
	;; Stick in the ordered methods first, so that they will almost
	;; always be hit on the first probe.
	(DOLIST (SELECTOR (HANDLER-TABLE-METHOD-ORDER HT))
	  (MULTIPLE-VALUE-BIND (IGNORE IGNORE CELL)
	      (HANDLER-TABLE-SEARCH-INTERNAL NHT NHT-ADDRESS MASK SELECTOR)
	    (WHEN (NULL CELL)
	      (MULTIPLE-VALUE-SETQ (NHT CELL)
		(ENLARGE-HANDLER-TABLE-INTERNAL NHT SELECTOR))
	      (SETQ NHT-ADDRESS (HANDLER-TABLE-ADDRESS NHT)
		    GREW T))
	    (SETF (HANDLER-TABLE-SELECTOR CELL) SELECTOR)))
	;; Copy the contents of HT into NHT
	(LOOP FOR P = (HANDLER-TABLE-ADDRESS HT) THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 3)
	      UNTIL (EQ P LIMIT) WITH LIMIT = (HANDLER-TABLE-LAST-ADDRESS HT)
	      AS SELECTOR = (HANDLER-TABLE-SELECTOR P) DO
	  (WHEN SELECTOR
	    (HANDLER-TABLE-CHECK-GC-DEPENDENCE NHT SELECTOR)
	    (MULTIPLE-VALUE-BIND (IGNORE IGNORE CELL)
		(HANDLER-TABLE-SEARCH-INTERNAL NHT NHT-ADDRESS MASK SELECTOR)
	      (WHEN (NULL CELL)
		(MULTIPLE-VALUE-SETQ (NHT CELL)
		  (ENLARGE-HANDLER-TABLE-INTERNAL NHT SELECTOR))
		(SETQ NHT-ADDRESS (HANDLER-TABLE-ADDRESS NHT)
		      GREW T))
	      (SETF (HANDLER-TABLE-SELECTOR CELL) SELECTOR)
	      (SETF (HANDLER-TABLE-FUNCTION CELL) (HANDLER-TABLE-FUNCTION P))
	      (SETF (HANDLER-TABLE-MAPPING-TABLE CELL) (HANDLER-TABLE-MAPPING-TABLE P)))))
	;; Copy back into HT if it fits there or else replace HT with NHT
	(IF GREW
	    (INSTALL-HANDLER-TABLE FL NHT)
	  (NONMODIFYING-COPY-ARRAY-CONTENTS NHT HT)
	  (RETURN-ARRAY NHT))
	T))))

;; Don't modify pages if we can help it, so IDS file size will be kept down.
(DEFUN NONMODIFYING-COPY-ARRAY-CONTENTS (FROM TO)
  (LET ((FROM FROM) (TO TO))
    (DECLARE (SYS:ARRAY-REGISTER FROM TO))
    (LOOP FOR I BELOW (MIN (ARRAY-TOTAL-SIZE FROM) (ARRAY-TOTAL-SIZE TO))
	  AS ELEM = (AREF FROM I)
	  WHEN (NEQ (AREF TO I) ELEM)
	    DO (SETF (AREF TO I) ELEM))))

;; Rehash all handler tables if the GC generation number has incremented, and
;; update *LAST-REHASH-GC-STATIC-GENERATION-NUMBER*.  Also, since after a static
;; GC dynamic regions can become static, force a table to rehash if it appears
;; its GC dependence could be changed back to static.  The optional FORCE
;; argument is mainly for debugging.
(DEFUN OPTIMIZE-HANDLER-TABLES (&OPTIONAL FORCE)
  (LET ((SUGGEST ( %GC-STATIC-GENERATION-NUMBER *LAST-REHASH-GC-STATIC-GENERATION-NUMBER*)))
    (WHEN (OR FORCE SUGGEST)
      (LET ((REHASH-COUNT 0)
	    (NUMERATOR 0)
	    (DENOMINATOR (LENGTH *ALL-FLAVOR-NAMES*))
	    (*THIS-REHASH-GC-STATIC-GENERATION-NUMBER* %GC-STATIC-GENERATION-NUMBER))
	(WHEN SUGGEST
	  (SETQ DENOMINATOR (* DENOMINATOR 2)))
	(FLET ((REHASH (FLAVOR-NAME FORCE)
		 (WITHOUT-INTERRUPTS
		   (LET ((FLAVOR (FIND-FLAVOR FLAVOR-NAME NIL)))
		     (WHEN FLAVOR
		       (LET ((HT (FLAVOR-HANDLER-TABLE FLAVOR)))
			 (WHEN HT
			   (WHEN (REHASH-HANDLER-TABLE FLAVOR HT
				   (OR FORCE
				       (> (HANDLER-TABLE-GC-DEPENDENCE HT)
					  %GC-DEPENDENCE-STATIC)
				       (NEQ (HANDLER-TABLE-GC-GENERATION HT) :DEFAULT)))
			     (INCF REHASH-COUNT)))))))
		 (TV:NOTE-PROGRESS (INCF NUMERATOR) DENOMINATOR)))
	  (TV:NOTING-PROGRESS ("Optimizing flavor handler tables")
	    (DOLIST (FLAVOR-NAME *ALL-FLAVOR-NAMES*)
	      (REHASH FLAVOR-NAME FORCE))
	    (SETQ *LAST-REHASH-GC-STATIC-GENERATION-NUMBER*
		  *THIS-REHASH-GC-STATIC-GENERATION-NUMBER*)
	    (WHEN SUGGEST
	      ;; "Once more with D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")feeling0, this time!"
	      ;; Do it with *LAST-REHASH-GC-STATIC-GENERATION-NUMBER* set so that tables
	      ;; rehashed by other processes above get the GC generation set to :DEFAULT.
	      ;; Probably not going to touch lots of handler tables this time around.
	      (STORAGE:WITH-PREFETCHING-DISABLED *FLAVOR-AREA*
		(DOLIST (FLAVOR-NAME *ALL-FLAVOR-NAMES*)
		  (REHASH FLAVOR-NAME NIL))))
	    REHASH-COUNT))))))

(ADD-INITIALIZATION "OPTIMIZE-HANDLER-TABLES" '(OPTIMIZE-HANDLER-TABLES) '(BEFORE-COLD))

;Alist from names of inlinable methods to combined methods for different generic
;functions that depend on them.
(DEFVAR *INLINE-METHOD-DEPENDENCIES* NIL)

;;; Get a new definition of a method into all the places that know about it.
;;;--- This will get more complicated when the linkage from combined methods
;;;--- to component methods is fixed to avoid going through a function cell.
(DEFUN UPDATE-METHOD-DEFINITION (FLAVOR-NAME FUNCTION-SPEC DEFINITION)
  ;; Update the generic function's argument list, if it has not been declared
  ;; explicitly.  This is somewhat heuristic.
  ;; Also try to get it from the most basic flavor.
  (FLET ((ARGLIST-SIGNIFICANCE (ARGLIST)
	   (IF (NULL ARGLIST)			;() is more significant than (IGNORE) !   
	       1
	       (LOOP FOR SYMBOL IN ARGLIST
		     DO (IF (LISTP SYMBOL) (SETQ SYMBOL (CAR SYMBOL)))
		     COUNT (NOT (OR (MEMBER SYMBOL LAMBDA-LIST-KEYWORDS)
				    (EQ SYMBOL 'IGNORE)))))))
    (WHEN (EQ (METHOD-TYPE FUNCTION-SPEC) 'FLAVOR:METHOD)
      (LET ((GF (FIND-GENERIC-FUNCTION (METHOD-GENERIC FUNCTION-SPEC))))
	(SI:EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO GF)
	(UNLESS (OR (GENERIC-FUNCTION-EXPLICIT GF)
		    (SYMBOLP DEFINITION)
		    (AND (GENERIC-FUNCTION-ARGLIST GF)
			 (ZEROP (ARGLIST-SIGNIFICANCE (CDDDR (ARGLIST DEFINITION))))))
	  (LET ((EXISTING-FLAVOR (FIRST (GENERIC-FUNCTION-ARGLIST GF))) FL)
	    (WHEN (OR (NULL EXISTING-FLAVOR)
		      (EQ EXISTING-FLAVOR (METHOD-FLAVOR FUNCTION-SPEC))
		      (> (ARGLIST-SIGNIFICANCE
			   (PROGN
			     #+3600 (CDDDR (ARGLIST DEFINITION))
			     #+IMACH (CDDR (ARGLIST DEFINITION))))
			 (ARGLIST-SIGNIFICANCE (LT:REMOVE-ARGUMENTS-FROM-LAMBDA-LIST 1
						 (GENERIC-FUNCTION-ARGLIST GF))))
		      (NOT (SETQ FL (FIND-FLAVOR EXISTING-FLAVOR NIL)))
		      (MEMBER (METHOD-FLAVOR FUNCTION-SPEC) (FLAVOR-ALL-COMPONENTS FL)))
	      (SETF (GENERIC-FUNCTION-ARGLIST GF)
		    (CONS (METHOD-FLAVOR FUNCTION-SPEC)
			  (PROGN #+3600 (CDDDR (ARGLIST DEFINITION))
				 #+IMACH (CDDR (ARGLIST DEFINITION)))))
	      (LET ((GENERIC-INFO (GENERIC-FUNCTION-DEBUGGING-INFO GF))
		    (METHOD-INFO (DEBUGGING-INFO DEFINITION)))
		(DOLIST (TYPE *GENERIC-FUNCTION-DEBUGGING-INFO-TAKEN-FROM-METHOD*)
		  (SETQ GENERIC-INFO (REMOVE TYPE GENERIC-INFO :KEY #'CAR))
		  (WHEN (SETQ TYPE (ASSOC TYPE METHOD-INFO))
		    (WHEN (EQ (FIRST TYPE) 'SYS:DOWNWARD-FUNARG)
		      ;; Compensate for methods having more arguments than generics
		      (UNLESS (EQUAL (SECOND TYPE) '(-1))
			(SETQ TYPE (LIST 'SYS:DOWNWARD-FUNARG
					 (LOOP FOR INDEX IN (SECOND TYPE)
					       COLLECT (- INDEX #+3600 2 #+IMACH 1))))))
		    (PUSH TYPE GENERIC-INFO)))
		(SETF (GENERIC-FUNCTION-DEBUGGING-INFO GF) GENERIC-INFO))))))))

  (IF (EQ (METHOD-TYPE FUNCTION-SPEC) 'COMBINED)
      ;; If this is a combined method that depends on methods for other generics, due to
      ;; inlining, record the dependency
      (DOLIST (METHOD (THIRD (ASSOC 'COMBINED-METHOD-DERIVATION (DEBUGGING-INFO DEFINITION))))
	(UNLESS (EQUAL (METHOD-GENERIC METHOD) (METHOD-GENERIC FUNCTION-SPEC))
	  (LET ((ASSOC (ASSOC METHOD *INLINE-METHOD-DEPENDENCIES* :TEST #'EQUAL)))
	    (IF ASSOC
		(PUSHNEW FUNCTION-SPEC (CDR ASSOC) :TEST #'EQUAL :LOCALIZE T)
		(PUSH (LIST METHOD FUNCTION-SPEC) *INLINE-METHOD-DEPENDENCIES*
		      :LOCALIZE T)))))
      ;; If this method affects combined methods for other generics, propagate
      (DOLIST (METHOD (CDR (ASSOC FUNCTION-SPEC *INLINE-METHOD-DEPENDENCIES* :TEST #'EQUAL)))
	(LET ((FL (FIND-FLAVOR (METHOD-FLAVOR METHOD) NIL)))
	  (WHEN (AND FL (FLAVOR-METHODS-COMPOSED FL))
	    (RECOMPILE-FLAVOR (METHOD-FLAVOR METHOD)
			      :GENERIC (METHOD-GENERIC METHOD)
			      :DO-DEPENDENTS NIL)))))

  ;; Update references to the method from combined methods and handler tables
  (DO-ALL-COMPOSED-DEPENDENTS (DEPENDENT FL (FIND-FLAVOR FLAVOR-NAME))
;This is commented out until combined methods are made not to go through function cells
;   ;; See if there is a combined method to be updated
;   (WHEN (FLAVOR-HAS-COMBINED-METHODS FL)
;     (DOLIST (MH (CDR (ASSOC (METHOD-GENERIC FUNCTION-SPEC) (FLAVOR-METHOD-TABLE FL))))
;       (WHEN (EQ (METHOD-TYPE (METHOD-HOLDER-FUNCTION-SPEC MH)) 'COMBINED)
;	  ;;--- Here update this method's constant's table
;	  ;;--- Do internal functions of combined methods also
;	  )))
    (WHEN (FLAVOR-METHODS-COMPOSED FL)
      ;; Update any occurrences of this method in the handler table
      (WITHOUT-INTERRUPTS
	(LABELS ((UPDATE (METHOD PARAMETER METHOD-CELL PARAMETER-CELL)
		   (WHEN (EQ METHOD #'HANDLE-INTERPRETED-DEFMETHOD)
		     (SETQ METHOD (FIRST PARAMETER)
			   PARAMETER (SECOND PARAMETER)))
		   (LET ((NAME (FUNCTION-NAME METHOD)))
		     (WHEN (EQUAL NAME FUNCTION-SPEC)
		       ;; Substitute the new definition in place of this method
		       (SET-HANDLER-VECTOR-ELEMENT
			 METHOD-CELL PARAMETER-CELL DEFINITION PARAMETER))
		     (WHEN (AND (LISTP NAME)
				(MEMBER (CAR NAME) *ALL-METHOD-TYPES*))
		       (CASE (METHOD-TYPE NAME)
			 ((NCWHOPPER SHARED-COMBINED)
			  ;; Update references to methods from the extra-arg vector
			  (LOOP FOR I FROM 0 BY 2 BELOW (1- (VECTOR-LENGTH PARAMETER)) DO
			    (UPDATE (AREF PARAMETER I) (AREF PARAMETER (1+ I))
				    (LOCF (AREF PARAMETER I)) (LOCF (AREF PARAMETER (1+ I)))))
			  (WHEN (EQ (METHOD-TYPE NAME) 'NCWHOPPER)
			    ;; If this used to be an interpreted whopper, but is now compiled,
			    ;; the mapping table might not exist yet, so be sure it's there.
			    (SETF (AREF PARAMETER (1- (VECTOR-LENGTH PARAMETER)))
				  (GET-MAPPING-TABLE FL (METHOD-FLAVOR NAME)))))
			 (OTHERWISE
			   ;; If this used to be an interpreted method, but is now compiled,
			   ;; the mapping table might not exist yet, so be sure it's there.
			   (SET-HANDLER-VECTOR-PARAMETER
			     METHOD-CELL PARAMETER-CELL
			     (GET-MAPPING-TABLE FL (METHOD-FLAVOR NAME))))))))
		 (UPDATE-HANDLER-TABLE (CELL SELECTOR FUNCTION PARAMETER)
		   (LET ((NAME (FUNCTION-NAME FUNCTION)))
		     (WHEN (EQUAL NAME FUNCTION-SPEC)
		       ;; Substitute the new definition in place of this method
		       (SET-HANDLER-TABLE-ELEMENT CELL SELECTOR DEFINITION PARAMETER))
		     (WHEN (AND (LISTP NAME)
				(MEMBER (CAR NAME) *ALL-METHOD-TYPES*))
		       (CASE (METHOD-TYPE NAME)
			 ((NCWHOPPER SHARED-COMBINED)
			  ;; Update references to methods from the extra-arg vector
			  (LOOP FOR I FROM 0 BY 2 BELOW (1- (VECTOR-LENGTH PARAMETER)) DO
			    (UPDATE (AREF PARAMETER I) (AREF PARAMETER (1+ I))
				    (LOCF (AREF PARAMETER I)) (LOCF (AREF PARAMETER (1+ I)))))
			  (WHEN (EQ (METHOD-TYPE NAME) 'NCWHOPPER)
			    ;; If this used to be an interpreted whopper, but is now compiled,
			    ;; the mapping table might not exist yet, so be sure it's there.
			    (SETF (AREF PARAMETER (1- (VECTOR-LENGTH PARAMETER)))
				  (GET-MAPPING-TABLE FL (METHOD-FLAVOR NAME)))))
			 (OTHERWISE
			   ;; If this used to be an interpreted method, but is now compiled,
			   ;; the mapping table might not exist yet, so be sure it's there.
			   (SET-HANDLER-TABLE-PARAMETER
			     CELL
			     (GET-MAPPING-TABLE FL (METHOD-FLAVOR NAME)))))))))
	  (LET ((SELECTOR (GENERIC-FUNCTION-SELECTOR
			    (FIND-GENERIC-FUNCTION (METHOD-GENERIC FUNCTION-SPEC)))))
	    (MULTIPLE-VALUE-BIND (FUNCTION PARAMETER CELL)
		(HANDLER-TABLE-FUNCTION-AND-PARAMETER FL SELECTOR)
	      (WHEN FUNCTION
		;; Some method exists for this generic, could be a combined-method
		(UPDATE-HANDLER-TABLE CELL SELECTOR FUNCTION PARAMETER)))))))))

;;;; Support for instance-variable accessors

(DEFUN HANDLER-DEFINITION (FUNCTION-SPEC FLAVOR)
  (DECLARE (VALUES FUNCTION MAPPING-TABLE))
  (ECASE (METHOD-TYPE FUNCTION-SPEC)
    (READ-INSTANCE-VARIABLE
      (VALUES #'READ-INSTANCE-VARIABLE
	      (1+ (POSITION (ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)
			    (FLAVOR-ALL-INSTANCE-VARIABLES FLAVOR)))))
    (WRITE-INSTANCE-VARIABLE
      (VALUES #'WRITE-INSTANCE-VARIABLE
	      (1+ (POSITION (ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)
			    (FLAVOR-ALL-INSTANCE-VARIABLES FLAVOR)))))
    (LOCATE-INSTANCE-VARIABLE
      (VALUES #'LOCATE-INSTANCE-VARIABLE
	      (1+ (POSITION (ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)
			    (FLAVOR-ALL-INSTANCE-VARIABLES FLAVOR)))))
    ((METHOD COMBINED)
      (VALUES (FDEFINITION FUNCTION-SPEC)
	      (GET-MAPPING-TABLE FLAVOR (METHOD-FLAVOR FUNCTION-SPEC))))
    (PSEUDO-COMBINED
      (VALUES (FDEFINITION (THIRD FUNCTION-SPEC))
	      (LET ((PARAMETER (MAKE-ARRAY (+ (* (LENGTH (CDDDR FUNCTION-SPEC)) 2)
					      (IF (EQ (METHOD-TYPE (THIRD FUNCTION-SPEC))
						      'NCWHOPPER)
						  1 0))
					   :AREA *FLAVOR-AREA*)))
		(LOOP FOR I FROM 0 BY 2
		      FOR SPEC IN (CDDDR FUNCTION-SPEC) DO
		  (MULTIPLE-VALUE-BIND (FUNCTION MAPPING-TABLE)
		      (IF (SYMBOLP SPEC)
			  (VALUES (FDEFINITION SPEC) NIL)
			  (HANDLER-DEFINITION SPEC FLAVOR))
		    (SET-HANDLER-VECTOR-ELEMENT
		      (LOCF (AREF PARAMETER I)) (LOCF (AREF PARAMETER (1+ I)))
		      FUNCTION MAPPING-TABLE))
		  FINALLY
		    (WHEN (EQ (METHOD-TYPE (THIRD FUNCTION-SPEC)) 'NCWHOPPER)
		      (SETF (AREF PARAMETER I)
			    (GET-MAPPING-TABLE FLAVOR
					       (METHOD-FLAVOR (THIRD FUNCTION-SPEC))))))
		PARAMETER)))))

#+3600
(DEFUN READ-INSTANCE-VARIABLE (SELF SLOT .GENERIC.)
  (IGNORE .GENERIC.)
  (LOCATION-CONTENTS (%P-STRUCTURE-OFFSET SELF SLOT)))	;faster (%INSTANCE-REF SELF SLOT)

#+3600
(DEFUN WRITE-INSTANCE-VARIABLE (SELF SLOT .GENERIC. VALUE)
  (IGNORE .GENERIC.)
  (SETF (LOCATION-CONTENTS (%P-STRUCTURE-OFFSET SELF SLOT)) VALUE))	;faster (%INSTANCE-SET VALUE SELF SLOT)

#+3600
(DEFUN LOCATE-INSTANCE-VARIABLE (SELF SLOT .GENERIC.)
  (IGNORE .GENERIC.)
  (%P-STRUCTURE-OFFSET SELF SLOT))		;faster (%INSTANCE-LOC SELF SLOT)

;; The IMach versions of the above three functions are in SYS:SYS;IPRIM

;;; Called if the microcode can't find the handler
(DEFUN HANDLE-UNCLAIMED-MESSAGE (#+3600 SELF #+3600 SELF-MAPPING-TABLE #+3600 SELECTOR
				 #+IMACH SELECTOR #+IMACH SELF
				 &REST ARGS)
  (DECLARE (DBG:ERROR-REPORTER))
  #+IMACH ARGS
  ;; The following gets optimized out, but will cause locals to be SP-relative.
  #+IMACH (%PUSH (%POP))
  (WHEN (AND SELECTOR (WITHOUT-INTERRUPTS
			(HANDLER-TABLE-SEARCH (%INSTANCE-FLAVOR SELF) SELECTOR)))
    ;; Maybe we needed to rehash, retry
    #+3600 (RETURN-FROM HANDLE-UNCLAIMED-MESSAGE (APPLY SELF SELECTOR ARGS))
    #+IMACH (SYS:%GENERIC-DISPATCH))
  ;; There can't be any fake instances, since they are all CLOS instances, so don't
  ;; need to worry about them.
  (COND ((AND (CONSP SELECTOR)
	      (SYS:FUNCALLABLE-INSTANCE-P (FIRST SELECTOR)))
	 #+IMACH (SETQ SELF (SYS:%POP))
	 (SETQ SELECTOR (FIRST SELECTOR)))
	((AND (TYPEP SELECTOR 'SYS:GENERIC-FUNCTION)
	      (NOT (CLOS-INTERNALS::GENERIC-FUNCTION-CLOS SELECTOR)))
	 ;; We are dealing with a Flavors generic function.
	 )
	(T
	 ;; Too bad the stack is so messed up that we can't get away with a local
	 ;; variable.
	 (TYPECASE SELECTOR
	   (SYMBOL (SETQ SELECTOR (OR (AND (NULL (GET SELECTOR 'GENERIC))
					   (GET SELECTOR
						'CLOS-INTERNALS::SELECTOR-GENERIC-FUNCTION))
				      SELECTOR)))
	   (GENERIC-FUNCTION
	     (SETQ SELECTOR (CLOS-INTERNALS::FUNCALLABLE-INSTANCE-FROM-GENERIC-SELECTOR
			      SELECTOR))))
	 #+IMACH
	 (UNLESS
	   (OR (NOT (CLOS-INTERNALS::GENERIC-FUNCTION-P SELECTOR))
	       (= (SYS:%P-LDB SYS:%%PACKED-INSTRUCTION-OPCODE
			      (CLOS-INTERNALS::%FUNCALLABLE-INSTANCE-FUNCTION SELECTOR))
		  I-LISP-COMPILER:*%GENERIC-DISPATCH-OPCODE*)
	       ;; CLOS-INTERNALS::DISPATCH-HANDLER-SPEC is defined by CLOS, but we
	       ;; can't get here unless CLOS is loaded, so it should be safe.
	       (NULL (CLOS-INTERNALS::DISPATCH-HANDLER-SPEC
		       (CLOS-INTERNALS::%FUNCALLABLE-INSTANCE-FUNCTION SELECTOR))))
	   (SETQ SELF (SYS:%POP)))))
  #+IMACH
  (UNLESS (LDB-TEST SYS:%%CR.APPLY
		    (SYS:%READ-INTERNAL-REGISTER SYS:%REGISTER-CONTROL-REGISTER))
    (SYS:%PUSH NIL))
  #+IMACH
  (COMPILER:%INSTRUCTION SYS:%SET-CDR-CODE-2 (SYS:SP -1))
  (COND ((CLOS-INTERNALS::GENERIC-FUNCTION-P SELECTOR)
	 ;; This was a CLOS generic function, pass control to CLOS
	 #+3600
	 (STACK-LET ((ARGUMENTS (CONS SELF ARGS)))
	   (CLOS-INTERNALS::HANDLE-MISSED-DISPATCH SELECTOR ARGUMENTS))
	 #+IMACH
	 (CLOS-INTERNALS::HANDLE-MISSED-DISPATCH
	   SELECTOR
	   (SYS:%SET-TAG (SYS:LOCF SELF) SYS:DTP-LIST))
	 )
	(T
	 ;; Really not handled, escape to default handler
	 #+3600
	 (APPLY (HANDLER-TABLE-DEFAULT-HANDLER (FLAVOR-HANDLER-TABLE
						 (%INSTANCE-FLAVOR SELF)))
		SELF SELF-MAPPING-TABLE SELECTOR ARGS)
	 #+IMACH
	 (APPLY (HANDLER-TABLE-DEFAULT-HANDLER (FLAVOR-HANDLER-TABLE (%INSTANCE-FLAVOR SELF)))
		SELF NIL SELECTOR (CDR (SYS:%SET-TAG (SYS:LOCF SELF) SYS:DTP-LIST))))))

#||
;;; Convenient function for when the above needs to be chamnged
#+IMACH
(DEFUN REDEFINE-HANDLE-UNCLAIMED-MESSAGE ()
  (LET* ((HUM 'HANDLE-UNCLAIMED-MESSAGE)
	 (HUMFUN #'HANDLE-UNCLAIMED-MESSAGE)
	 (HUMPC (%MAKE-POINTER-OFFSET DTP-EVEN-PC HUMFUN 2)))
    (TV:DOLIST-NOTING-PROGRESS (FLAVOR-NAME FLAVOR:*ALL-FLAVOR-NAMES*
					    "Updating flavor handler tables")
      (LET ((FLAVOR (GET FLAVOR-NAME 'FLAVOR)))
	(WHEN FLAVOR
	  (WITHOUT-INTERRUPTS
	    (LET ((HT (FLAVOR-HANDLER-TABLE FLAVOR)))
	      (WHEN HT
		(LET ((HANDLER (HANDLER-TABLE-ESCAPE-HANDLER HT)))
		  (WHEN HANDLER
		    (LET* ((FUNCTION (%FIND-STRUCTURE-HEADER HANDLER))
			   (FUNCTION-NAME (FUNCTION-NAME FUNCTION)))
		      (WHEN (AND (EQ FUNCTION-NAME HUM)
				 (NEQ FUNCTION HUMFUN))
			(SETF (HANDLER-TABLE-ESCAPE-HANDLER HT) HUMPC)))))
		(LET ((HT-ADDRESS (HANDLER-TABLE-ADDRESS HT))
		      (HT-LIMIT (HANDLER-TABLE-LAST-ADDRESS HT)))
		  (LOOP FOR POINTER FIRST (LOCF (HANDLER-TABLE-SELECTOR HT-ADDRESS))
				    THEN (%POINTER-PLUS POINTER 3)
			WHILE (%POINTER-LESSP POINTER HT-LIMIT)
			DOING
		    (WHEN (NULL (HANDLER-TABLE-SELECTOR POINTER))
		      (SETF (HANDLER-TABLE-FUNCTION POINTER) HUMPC))))))))))))
||#

;;; Called if there really is not a handler
;--- Needs to be converted from ':UNCLAIMED-MESSAGE to some generic function
(DEFUN HANDLE-REAL-UNCLAIMED-MESSAGE
       (SELF SELF-MAPPING-TABLE SELECTOR &REST ARGS)
  (DECLARE (DBG:ERROR-REPORTER)
	   (IGNORE SELF-MAPPING-TABLE))
  (IF (WITHOUT-INTERRUPTS (HANDLER-TABLE-SEARCH (%INSTANCE-FLAVOR SELF) ':UNCLAIMED-MESSAGE))
      (APPLY SELF ':UNCLAIMED-MESSAGE SELECTOR ARGS)
      (SIGNAL-PROCEED-CASE ((VALUE) 'UNCLAIMED-MESSAGE
				    :OBJECT SELF
				    :MESSAGE SELECTOR
				    :ARGUMENTS (COPY-LIST ARGS))
	((:NEW-MESSAGE :NEW-FUNCTION)
	  (APPLY SELF VALUE ARGS))
	(:ARGUMENT-VALUE
	  (COND ((TYPEP SELECTOR 'GENERIC-FUNCTION)
		 (APPLY SELECTOR VALUE ARGS))
		((TYPEP VALUE 'INSTANCE)
		 (APPLY VALUE SELECTOR ARGS))
		(T
		 (APPLY #'HANDLE-REAL-UNCLAIMED-MESSAGE VALUE NIL SELECTOR ARGS)
		 ))))))

;;; Called when a generic function's first argument is not an instance
;;;--- eventually find an appropriate flavor to use and dispatch to there
(DEFUN GENERIC-APPLIED-TO-NON-INSTANCE (GENERIC OBJECT &REST ARGUMENTS)
  (DECLARE (DBG:ERROR-REPORTER)
	   (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (SIGNAL-PROCEED-CASE ((VALUE) 'UNCLAIMED-MESSAGE
				:OBJECT OBJECT
				:MESSAGE GENERIC
				:ARGUMENTS (COPY-LIST ARGUMENTS))
    (:NEW-FUNCTION
      (APPLY VALUE OBJECT ARGUMENTS))
    (:ARGUMENT-VALUE
      (APPLY GENERIC VALUE ARGUMENTS))))

(DEFUN HANDLE-TRANSFORM-INSTANCE
       #+3600(SELF SELF-MAPPING-TABLE SELECTOR &REST ARGS)
       #+IMACH(SELECTOR SELF &REST ARGS)
  #+3600(IGNORE SELF-MAPPING-TABLE)
  (TRANSFORM-INSTANCE SELF (FIND-FLAVOR (FLAVOR-NAME (%INSTANCE-FLAVOR SELF))))
  ;; Try sending the message again
  (APPLY SELF SELECTOR ARGS))

;;; This has to be after HANDLE-TRANSFORM-INSTANCE on the I machine
(DEFVAR *INSTANCE-TRANSFORMING-HANDLER-TABLE*
	(MAKE-HANDLER-TABLE-INTERNAL
	  0 (HANDLER-TABLE-SIZE-FOR-N-SLOTS 2)
	  NIL NIL
	  (PROGN
	    #+3600 'HANDLE-TRANSFORM-INSTANCE
	    #+IMACH (%MAKE-POINTER DTP-EVEN-PC #'HANDLE-TRANSFORM-INSTANCE))))

(DEFUN INSTALL-INSTANCE-TRANSFORMING-HANDLER-TABLE (FL)
  (INSTALL-HANDLER-TABLE FL *INSTANCE-TRANSFORMING-HANDLER-TABLE*))  

;; (:HANDLER generic-function-name flavor-name) refers to the function that is called when
;; the generic function named generic-function-name is performed on an object of that flavor.
;; Storing into this changes the handler for that specific flavor
;;  which should make it possible to trace and so forth.
(DEFINE-FUNCTION-SPEC-HANDLER :HANDLER (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (BLOCK HANDLER-FUNCTION-SPEC-HANDLER
    (LET* ((GENERIC-FUNCTION-NAME (SECOND FUNCTION-SPEC))
	   (GF (AND (TYPEP GENERIC-FUNCTION-NAME 'GENERIC-FUNCTION-NAME)
		    (FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME NIL)))
	   (FLAVOR-NAME (THIRD FUNCTION-SPEC))
	   (FL (AND FLAVOR-NAME (SYMBOLP FLAVOR-NAME) (FIND-FLAVOR FLAVOR-NAME NIL))))
      (UNLESS (AND FL GF)
	(IF (MEMBER FUNCTION '(VALIDATE-FUNCTION-SPEC FDEFINEDP SI:COMPILER-FDEFINEDP
			       SI:GET FUNCTION-PARENT))
	    (RETURN-FROM HANDLER-FUNCTION-SPEC-HANDLER NIL)
	    (ERROR (COND (FL 
			  "In the function spec ~S, ~S is not the name of a generic function")
			 (GF "In the function spec ~S, ~*~S is not the name of a flavor")
			 (T "In the function spec ~S, ~S is not the name of a generic function
and ~S is not the name of a flavor"))
		   FUNCTION-SPEC GENERIC-FUNCTION-NAME FLAVOR-NAME)))
      ;; If the handlers have not already been constructed, construct them.  Debatable!!
      (UNLESS (FLAVOR-METHODS-COMPOSED FL)
	(COMPOSE-METHOD-COMBINATION FLAVOR-NAME))
      ;; Get a pointer to the cell in the handler tabler, and don't let it move
      (WITHOUT-INTERRUPTS
	(MULTIPLE-VALUE-BIND (HANDLER-FUNCTION PARAMETER CELL)
	    (HANDLER-TABLE-FUNCTION-AND-PARAMETER FL (GENERIC-FUNCTION-SELECTOR GF))
	  (UNLESS HANDLER-FUNCTION
	    (IF (MEMBER FUNCTION '(VALIDATE-FUNCTION-SPEC FDEFINEDP SI:COMPILER-FDEFINEDP
				   SI:GET FUNCTION-PARENT))
		(RETURN-FROM HANDLER-FUNCTION-SPEC-HANDLER NIL)
		(ERROR "The function spec ~S is invalid because~@
			the flavor ~S does not handle the ~S generic function."
		       FUNCTION-SPEC FLAVOR-NAME GENERIC-FUNCTION-NAME)))
	  (CASE FUNCTION
	    (VALIDATE-FUNCTION-SPEC (= (LENGTH FUNCTION-SPEC) 3))
	    (FDEFINE
	      (SET-HANDLER-TABLE-ELEMENT
		CELL (GENERIC-FUNCTION-SELECTOR GF) ARG1 PARAMETER))
	    (FDEFINITION HANDLER-FUNCTION)
	    (FDEFINEDP (NOT (NULL CELL)))
	    (OTHERWISE (SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2))
	    ))))))

;;;; Mapping tables

;;; The array contains offsets of instance variables (NIL means a deleted instance variable)
;;; and mapping tables (or symbols standing in for them) for component flavors.
;;; Element 0 of the array is a named-structure symbol and element 1 is the flavor.
(DEFSTRUCT (MAPPING-TABLE :NAMED-ARRAY :CONC-NAME
			  (:SIZE-SYMBOL *MAPPING-TABLE-OVERHEAD*)
			  (:CONSTRUCTOR NIL) (:ALTERANT NIL) (:COPIER NIL) (:PREDICATE NIL))
  FLAVOR)

(DEFSELECT ((MAPPING-TABLE NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (MAPPING-TABLE STREAM IGNORE IGNORE)
   (SI:PRINTING-RANDOM-OBJECT (MAPPING-TABLE STREAM)
     (FORMAT STREAM "Map to flavor ~S" (MAPPING-TABLE-FLAVOR MAPPING-TABLE)))))

;;; Given from and to flavors, return the mapping table to be used when a method associated
;;; with the to-flavor is called for an instance of the from-flavor.  For the caller's
;;; convenience, FROM-FLAVOR is a structure while TO-FLAVOR-NAME is a name.
;;; FROM-FLAVOR always has FLAVOR-COMPONENTS-COMPOSED by design.
;;; It's okay for TO-FLAVOR-NAME to be currently not a defined flavor.
;;; If UPDATE is specified, force creation of a new mapping table if one exists
;;;  already, but don't actually create a new one.
;;; RECURSION: List of flavors whose mapping tables we are in the middle of making,
;;;  to break up circular references among mapping tables.
;;; Note: we must always make a new mapping table and never update an existing one
;;; to map new instance variables.  The reason is to avoid having a method already
;;; running on the stack acquire the ability to reference off the end of its instance
;;; when the flavor acquires new instance variables and the instance gets
;;; structure-forwarded.
;;--- WITHOUT-INTERRUPTS?  Status of this whole function unclear
(DEFUN GET-MAPPING-TABLE (FROM-FLAVOR TO-FLAVOR-NAME &OPTIONAL UPDATE RECURSION)
  (LET* ((TFL (FIND-FLAVOR TO-FLAVOR-NAME NIL))
	 (NAMES (AND TFL (FLAVOR-MAPPING-TABLE-NAMES TFL)))
	 (VARIABLE-P (AND TFL (FLAVOR-MAPPING-TABLE-VARIABLE-P TFL))))
    ;; See if we need a mapping table
    (UNLESS NAMES
      ;; Don't need one, substitute a symbol (the name of the flavor) as a placeholder
      (RETURN-FROM GET-MAPPING-TABLE TO-FLAVOR-NAME))
    ;; See if we already have the mapping table
    (LOOP FOR MT IN (FLAVOR-MAPPING-TABLES FROM-FLAVOR)
	  DO (WHEN (EQ (MAPPING-TABLE-FLAVOR MT) TO-FLAVOR-NAME)
	       (IF (NOT UPDATE)
		   ;; Assume it is up to date, return it
		   (RETURN-FROM GET-MAPPING-TABLE MT)
		   ;; We know we have something to update, exit the loop
		   (RETURN)))
	  FINALLY
	    (WHEN UPDATE
	      ;; No mapping table exists already, but perhaps another mapping table
	      ;; that does exist contains a slot where this mapping table should be.
	      ;; If not, don't create a new mapping table; the reason for this is to
	      ;; avoid creating mapping tables while a program is being loaded; otherwise
	      ;; a lot of mapping tables would be created and then superseded while
	      ;; methods are being loaded.  Instead we defer creation of mapping tables
	      ;; until the handler tables are created if possible.
	      (WHEN (LOOP FOR MT IN (FLAVOR-MAPPING-TABLES FROM-FLAVOR)
			  NEVER (LOOP FOR ELEM BEING THE ARRAY-ELEMENTS OF MT
					  FROM *MAPPING-TABLE-OVERHEAD*
				      THEREIS (EQ ELEM TO-FLAVOR-NAME)))
		;; Nothing found to update, exit
		(RETURN-FROM GET-MAPPING-TABLE NIL))))
    (WHEN (MEMBER TO-FLAVOR-NAME RECURSION)
      ;; Oops, infinite recursion.  Can't make a mapping table now, 
      ;; just return the symbol and assume the caller will fix it later.
      (RETURN-FROM GET-MAPPING-TABLE TO-FLAVOR-NAME))

    ;; If TO-FLAVOR is not a component of FROM-FLAVOR, refuse to make a mapping table
    ;; because it could not be updated if TO-FLAVOR later changed so that it needed
    ;; a longer mapping table.  Don't signal an error, because the error can happen at
    ;; all sorts of embarrassing times.  Instead, return a symbol, which will only signal
    ;; an error if someone actually tries to use it.
    (UNLESS (MEMBER (FLAVOR-NAME FROM-FLAVOR) (FLAVOR-ALL-COMPOSED-DEPENDENTS TFL))
      (RETURN-FROM GET-MAPPING-TABLE TO-FLAVOR-NAME))

    ;; The first time we make a mapping table is a good time to copy the NAMES list and the
    ;; VARIABLE-P vector into *FLAVOR-AREA* to localize them, on the assumption that they
    ;; aren't likely to change after this.
    (WHEN (AND NAMES ( (%AREA-NUMBER NAMES) *FLAVOR-AREA*))
      (SETF (FLAVOR-MAPPING-TABLE-NAMES TFL) (SETQ NAMES (COPY-LIST NAMES *FLAVOR-AREA*))))
    (WHEN (AND VARIABLE-P ( (%AREA-NUMBER VARIABLE-P) *FLAVOR-AREA*))
      (SETF (FLAVOR-MAPPING-TABLE-VARIABLE-P TFL)
	    (SETQ VARIABLE-P (COPY-SEQ VARIABLE-P *FLAVOR-AREA*))))

    ;; Make a new mapping table
    (LET ((ALL-VARS (FLAVOR-ALL-INSTANCE-VARIABLES FROM-FLAVOR))
	  (MT (MAKE-ARRAY (+ (LENGTH NAMES) *MAPPING-TABLE-OVERHEAD*)
			  :NAMED-STRUCTURE-SYMBOL 'MAPPING-TABLE
			  :AREA *FLAVOR-AREA*)))
      (SETF (MAPPING-TABLE-FLAVOR MT) TO-FLAVOR-NAME)
      (STACK-LET ((RECURSION (CONS TO-FLAVOR-NAME RECURSION)))
	(LOOP FOR NAME IN NAMES AND J FROM 0
	      AND I FROM *MAPPING-TABLE-OVERHEAD* WITH POS DO
	  (SETF (AREF MT I) (COND ((NOT (AREF VARIABLE-P J))
				   (GET-MAPPING-TABLE FROM-FLAVOR NAME NIL RECURSION))
				  ((SETQ POS (POSITION NAME ALL-VARS))
				   (1+ POS))
				  ;; NIL if the instance variable is not present, which
				  ;; will signal a run-time error if used
				  (T NIL)))))
      ;; Install this mapping table into all the places where it belongs, which could
      ;; include other mapping tables that we made inside the recursive call to
      ;; GET-MAPPING-TABLE just above, which couldn't get this mapping table
      ;; on their own recursive call to GET-MAPPING-TABLE because of RECURSION.
      (LOOP FOR L ON (FLAVOR-MAPPING-TABLES FROM-FLAVOR)
	    AS OTHER-MT = (CAR L) WITH FOUND = NIL
	    DO (WHEN (EQ (MAPPING-TABLE-FLAVOR OTHER-MT) TO-FLAVOR-NAME)
		 (SETF (CAR L) MT)
		 (TRANSFORM-MAPPING-TABLE OTHER-MT ALL-VARS)	;Invalidate old mapping table
		 (SETQ OTHER-MT MT)
		 (SETQ FOUND T))
	       (LOOP FOR I FROM *MAPPING-TABLE-OVERHEAD* BELOW (LENGTH OTHER-MT)
		     AS OLD-MT = (AREF OTHER-MT I)
		     DO (WHEN (EQ (IF (ARRAYP OLD-MT) (MAPPING-TABLE-FLAVOR OLD-MT) OLD-MT)
				  TO-FLAVOR-NAME)
			  (SETF (AREF OTHER-MT I) MT)
			  (RETURN)))
	    FINALLY (UNLESS FOUND
		      (PUSH MT (FLAVOR-MAPPING-TABLES FROM-FLAVOR)
			    :AREA *FLAVOR-AREA* :LOCALIZE T)))
      (WITHOUT-INTERRUPTS
	(LET ((HT (FLAVOR-HANDLER-TABLE FROM-FLAVOR)))
	  (WHEN HT
	    (LOOP FOR P = (FLAVOR-HASH-ADDRESS FROM-FLAVOR)
			THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 3)
		  UNTIL (EQ P LIMIT) WITH LIMIT = (HANDLER-TABLE-LAST-ADDRESS HT)
		  AS OLD-MT = (HANDLER-TABLE-MAPPING-TABLE P)
		  DO (COND ((EQ (IF (AND (ARRAYP OLD-MT)
					 (EQ (NAMED-STRUCTURE-P OLD-MT) 'MAPPING-TABLE))
				    (MAPPING-TABLE-FLAVOR OLD-MT)
				    OLD-MT)	;Symbol or instance-variable index
				TO-FLAVOR-NAME)
			    (SETF (HANDLER-TABLE-MAPPING-TABLE P) MT))
			   ((AND (ARRAYP OLD-MT)
				 (NOT (NAMED-STRUCTURE-P OLD-MT))
				 (= (ARRAY-TYPE-FIELD OLD-MT) SYS:ART-Q)
				 (= (%AREA-NUMBER OLD-MT) *FLAVOR-AREA*))
			    ;; See PSEUDO-COMBINED in HANDLER-DEFINITION
			    (DOTIMES (I (LENGTH OLD-MT))
			      (LET ((ELEMENT (AREF OLD-MT I)))
				(WHEN (EQ (IF (AND (ARRAYP ELEMENT)
						   (EQ (NAMED-STRUCTURE-P ELEMENT)
						       'MAPPING-TABLE))
					      (MAPPING-TABLE-FLAVOR ELEMENT)
					      ELEMENT)
					  TO-FLAVOR-NAME)
				  (SETF (AREF OLD-MT I) MT)))))))))
	(RETURN-FROM GET-MAPPING-TABLE MT)))))

;; Make sure that the mapping tables of this flavor contain, in their slots that
;; are mapping tables rather than instance variable indices, all the mapping tables
;; that should be there.
;; A mapping-table update might have been punted during flavor redefinition
;; because the mapped-to flavor was not yet in this flavor's all-components list.
;; A mapping table from this flavor used by an inherited combined method
;; thus might not contain a needed mapping to a third flavor.
(DEFUN UPDATE-INDIRECT-MAPPING-TABLES (FL)
  (DOLIST (MT (FLAVOR-MAPPING-TABLES FL))
    (LET ((TFL (FIND-FLAVOR (MAPPING-TABLE-FLAVOR MT))))
      (LOOP FOR THIRD-FLAVOR IN (FLAVOR-MAPPING-TABLE-NAMES TFL)
	    FOR VARIABLE-P BEING THE ARRAY-ELEMENTS OF (FLAVOR-MAPPING-TABLE-VARIABLE-P TFL)
	    DO (UNLESS VARIABLE-P
		 (GET-MAPPING-TABLE FL THIRD-FLAVOR))))))

;; Blow away old mapping tables by storing :MOVED into slots that map instance variables
;; that don't appear at the same position in the new and old incarnations of the instance.
(DEFUN TRANSFORM-MAPPING-TABLE (MT VARS &OPTIONAL ENV)
  (LET* ((TFL (FIND-FLAVOR (MAPPING-TABLE-FLAVOR MT) NIL ENV))
	 (NAMES (AND TFL (FLAVOR-MAPPING-TABLE-NAMES TFL)))
	 (VARIABLE-P (AND TFL (FLAVOR-MAPPING-TABLE-VARIABLE-P TFL))))
    (WHEN VARIABLE-P
      (LOOP FOR I FROM *MAPPING-TABLE-OVERHEAD* BELOW (LENGTH MT) DO
	(WHEN (AREF VARIABLE-P (- I *MAPPING-TABLE-OVERHEAD*))
	  (LET ((POS (POSITION (CAR NAMES) VARS)))
	    (COND ((NULL POS) (SETF (AREF MT I) NIL))
		  ((NOT (EQL (AREF MT I) (1+ POS))) (SETF (AREF MT I) ':MOVED)))))
	(POP NAMES)))))

;;;; Utilization of mapping tables by methods

;;; Calls to this function with SELF as the instance (e.g. in a combined method) are
;;; compiled specially, using SELF-MAPPING-TABLE.
(DEFUN GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE (INSTANCE FLAVOR-NAME)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (GET-MAPPING-TABLE (%INSTANCE-FLAVOR INSTANCE) FLAVOR-NAME))

;;; Similar, but error if (TYPEP INSTANCE TO-FLAVOR-NAME) is not true.
;;; This is only called from solitary-method trampoline functions,
;;; hence we can assume that the instance is the first argument to
;;; our caller and is named nothing more imaginative than SELF.
(DEFUN GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE-CHECK-TYPE (INSTANCE TO-FLAVOR-NAME)
  (DECLARE (DBG:ERROR-REPORTER))
  (WHEN (INSTANCEP INSTANCE)			;Since %INSTANCE-FLAVOR doesn't check
    (LET ((FROM-FLAVOR (%INSTANCE-FLAVOR INSTANCE)))
      ;; Check whether the instance needs to be transformed
      (WHEN (EQ (FLAVOR-HANDLER-TABLE FROM-FLAVOR) *INSTANCE-TRANSFORMING-HANDLER-TABLE*)
	(TRANSFORM-INSTANCE INSTANCE
			    (SETQ FROM-FLAVOR (FIND-FLAVOR (FLAVOR-NAME FROM-FLAVOR)))))
      ;; For speed, if we already have the mapping table bypass the error check
      ;; since 99% of the time mapping tables only exist for component flavors
      ;; The goal here is to avoid paging-in FLAVOR-ALL-COMPONENTS
      (DOLIST (MT (FLAVOR-MAPPING-TABLES FROM-FLAVOR))
	(WHEN (EQ (MAPPING-TABLE-FLAVOR MT) TO-FLAVOR-NAME)
	  (RETURN-FROM GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE-CHECK-TYPE MT)))
      ;; No mapping table, so do the type check
      (WHEN (MEMBER TO-FLAVOR-NAME (FLAVOR-ALL-COMPONENTS FROM-FLAVOR))
	(RETURN-FROM GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE-CHECK-TYPE
	  (GET-MAPPING-TABLE FROM-FLAVOR TO-FLAVOR-NAME)))))
  ;; Signal an error
  (LET ((FRAME (DBG:FRAME-OUT-TO-INTERESTING-ACTIVE-FRAME
		 (DBG:FRAME-PREVIOUS-ACTIVE-FRAME (%STACK-FRAME-POINTER)))))
    (ERROR 'DBG:WRONG-TYPE-DATUM :FUNCTION (FRAME-FUNCTION FRAME)
				 :NAME 'SELF
				 :BAD-VALUE INSTANCE
				 :EXPECTED-TYPE `(INSTANCE ,TO-FLAVOR-NAME)
				 :ARG-NUMBER 1)))

;;; FIXUP-METHOD is called by anything that creates a compiled-function when the
;;; debugging-info has :INSTANCE-VARIABLE-INSTRUCTIONS or :MAPPING-TABLE-INSTRUCTIONS.
;;; Called from the binary loader when just loaded a CCA.
;;; Responsible for storing proper offsets into instance variable accessing instructions,
;;; and if a combined method, storing indices in the mapping table array leader for the
;;; mapping tables of methods this combined method calls.
;--- Why aren't fields in macroinstructions defined symbolically?
(DEFUN FIXUP-METHOD (CCA)
  (LET* ((EXTRA-INFO (CCA-EXTRA-INFO CCA))
	 (FUNCTION-SPEC (CAR EXTRA-INFO))
	 (DEBUGGING-INFO (CDR EXTRA-INFO))
	 (FLAVOR (LOOP FOR PARENT-FUNCTION-SPEC = FUNCTION-SPEC
						THEN (SECOND PARENT-FUNCTION-SPEC)
		       WHILE (AND (LISTP PARENT-FUNCTION-SPEC)
				  (EQ (FIRST PARENT-FUNCTION-SPEC) ':INTERNAL))
		       FINALLY
			 (RETURN (AND (LISTP PARENT-FUNCTION-SPEC)
				      (MEMBER (METHOD-TYPE PARENT-FUNCTION-SPEC)
					      *FDEFINABLE-METHOD-TYPES*)
				      (METHOD-FLAVOR PARENT-FUNCTION-SPEC)))))
	 (FL (AND FLAVOR (GET FLAVOR 'FLAVOR)))		;faster FIND-FLAVOR
	 (SOMETHING-CHANGED NIL))
    (UNLESS FL
      (ERROR (COND (FLAVOR
		    "Attempt to define method ~S on undefined flavor ~S")
		   ;;--- Remove in Release 8
		   ((EQ (CAR FUNCTION-SPEC) ':METHOD)
		    "Attempt to define ~S, which was compiled in Release 6 Flavors.~@
		     Please consult the release notes for information on~@
		     updating your program to Release 7 Flavors.")
		   (T
		    "Attempt to define method ~S but its flavor cannot be determined.~@
		     This is an internal error that should never occur."))
	     FUNCTION-SPEC FLAVOR))
    
    ;; Batch up all the DW updates, for duplicate elimination.
    (WITH-PENDING-DW-UPDATES
      ;; If this is a combined method, make sure it gets updated if anything it depends
      ;; on is later changed, before a run-time compose-method-combination is done.
      (WHEN (EQ (METHOD-TYPE FUNCTION-SPEC) 'COMBINED)
	(UNLESS (FLAVOR-METHODS-COMPOSED FL)
	  ;; Don't check FLAVOR-COMPONENTS-COMPOSED here, because if there is a warning
	  ;; we don't want to repeat the warning for each method we fixup.
	  ;; Calling COMPOSE-FLAVOR-COMBINATION is sufficient to establish dependents links.
	  (UNLESS (FLAVOR-ALL-COMPONENTS FL)
	    (COMPOSE-FLAVOR-COMBINATION FLAVOR :ERROR-P NIL))))

      ;; Make sure we know what this flavor's ordered-instance-variables are.
      (UNLESS (FLAVOR-ORDERED-INSTANCE-VARIABLES-COMPOSED FL)
	(COMPOSE-ORDERED-INSTANCE-VARIABLES FLAVOR)))

    ;;--- Should go WITHOUT-ABORTS here so that if a new mapping table slot gets allocated
    ;;--- we're guaranteed that all mapping tables get updated.  I'm also assuming only
    ;;--- one process at a time gets into FIXUP-METHOD.  Unfortunately this whole thing
    ;;--- is too slow for WITHOUT-INTERRUPTS to be reasonable (do it anyway?!).

    ;; Update argument fields of instructions that access instance variables
    (LOOP FOR (VAR . PCS) IN (CDR (ASSOC ':INSTANCE-VARIABLE-INSTRUCTIONS DEBUGGING-INFO)) DO
      (MULTIPLE-VALUE-BIND (OFFSET ORDERED-BIT NEW-ONE-P)
	  (INSTANCE-VARIABLE-INSTRUCTION-ARGUMENT FL VAR)
      (UNLESS ( 0 OFFSET 255)
	(ERROR "The instance variable ~S cannot be addressed by ~S because
the offset, ~S, is out of range.  Your flavor probably has too many instance variables."
	       VAR FUNCTION-SPEC OFFSET))
      (DOLIST (PC PCS)
	#+3600
	(SETF (CCA-INSTRUCTION CCA PC)
	      (DPB ORDERED-BIT (BYTE 1 2)	;See note in OPDEF!
		   (DPB OFFSET (BYTE 8 8) (CCA-INSTRUCTION CCA PC NIL))))
	#+IMACH
	(SETF (CCA-INSTRUCTION CCA PC)
	      (DPB ORDERED-BIT (BYTE 1. 11.)
		   (DPB OFFSET (BYTE 8. 0.) (CCA-INSTRUCTION CCA PC NIL))))
	)
      (WHEN NEW-ONE-P (SETQ SOMETHING-CHANGED T))))
    ;; Update argument fields of instructions that access component mapping tables
    (LOOP FOR (FLA . PCS) IN (CDR (ASSOC ':MAPPING-TABLE-INSTRUCTIONS DEBUGGING-INFO)) DO
      (MULTIPLE-VALUE-BIND (OFFSET NEW-ONE-P)
	  (COMPONENT-MAPPING-TABLE-INSTRUCTION-ARGUMENT FL FLA)
	(UNLESS ( 0 OFFSET 255)
	  (ERROR "The mapping table for flavor ~S cannot be addressed by ~S because
the offset, ~S, is out of range.  Your flavor probably has too many component flavors."
		 FLA FUNCTION-SPEC OFFSET))
	(DOLIST (PC PCS)
	  #+3600
	  (SETF (CCA-INSTRUCTION CCA PC)
		(DPB OFFSET (BYTE 8 8) (CCA-INSTRUCTION CCA PC NIL)))
	  #+IMACH
	  (SETF (CCA-INSTRUCTION CCA PC)
		(DPB OFFSET (BYTE 8 0) (CCA-INSTRUCTION CCA PC NIL)))
	  )
	(WHEN NEW-ONE-P (SETQ SOMETHING-CHANGED T))))
    ;; If we had to allocate a new mapping table entry, update all mapping tables
    ;; to this flavor from other flavors that depend on it.
    (WHEN SOMETHING-CHANGED
      (DO-ALL-COMPOSED-DEPENDENTS (DEPENDENT F FL)
	(GET-MAPPING-TABLE F FLAVOR T)))))

(DEFUN INSTANCE-VARIABLE-INSTRUCTION-ARGUMENT (FROM-FLAVOR INSTANCE-VAR)
  (DECLARE (VALUES OFFSET ORDERED-BIT NEW-ONE-P))
  (LET ((POS (POSITION INSTANCE-VAR (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FROM-FLAVOR))))
    (IF POS
	(VALUES (1+ POS) 1 NIL)
	(LOOP WITH VAR-P = (FLAVOR-MAPPING-TABLE-VARIABLE-P FROM-FLAVOR)
	      FOR I FROM 0
	      FOR VAR IN (FLAVOR-MAPPING-TABLE-NAMES FROM-FLAVOR) 
	      DO (WHEN (AND (EQ VAR INSTANCE-VAR) (AREF VAR-P I))
		   (RETURN (VALUES (+ I *MAPPING-TABLE-OVERHEAD*) 0 NIL)))
	      FINALLY
		(SETF (FLAVOR-MAPPING-TABLE-NAMES FROM-FLAVOR)
		      (APPEND (FLAVOR-MAPPING-TABLE-NAMES FROM-FLAVOR) (LIST INSTANCE-VAR)))
		(SETF (FLAVOR-MAPPING-TABLE-VARIABLE-P FROM-FLAVOR)
		      (SETQ VAR-P
			    (IF VAR-P
				(SI:ADJUST-ARRAY-SIZE VAR-P (1+ I))
				(MAKE-ARRAY (1+ I) :ELEMENT-TYPE '(MEMBER T NIL)))))
		(SETF (AREF VAR-P I) T)
		(RETURN (VALUES (+ I *MAPPING-TABLE-OVERHEAD*)
				0
				T))))))

(DEFUN COMPONENT-MAPPING-TABLE-INSTRUCTION-ARGUMENT (FROM-FLAVOR TO-FLAVOR-NAME)
  (DECLARE (VALUES MAPPING-TABLE-ARRAY-LEADER-INDEX NEW-ONE-P))
  (LOOP WITH VAR-P = (FLAVOR-MAPPING-TABLE-VARIABLE-P FROM-FLAVOR)
	FOR I FROM 0
	FOR COMP IN (FLAVOR-MAPPING-TABLE-NAMES FROM-FLAVOR)
	DO (WHEN (AND (EQ COMP TO-FLAVOR-NAME) (NOT (AREF VAR-P I)))
	     (RETURN (VALUES (+ I *MAPPING-TABLE-OVERHEAD*) NIL)))
	FINALLY
	  (SETF (FLAVOR-MAPPING-TABLE-NAMES FROM-FLAVOR)
		(APPEND (FLAVOR-MAPPING-TABLE-NAMES FROM-FLAVOR) (LIST TO-FLAVOR-NAME)))
	  (SETF (FLAVOR-MAPPING-TABLE-VARIABLE-P FROM-FLAVOR)
		(SETQ VAR-P
		      (IF VAR-P
			  (SI:ADJUST-ARRAY-SIZE VAR-P (1+ I))
			  (MAKE-ARRAY (1+ I) :ELEMENT-TYPE '(MEMBER T NIL)))))
	  (SETF (AREF VAR-P I) NIL)
	  (RETURN (VALUES (+ I *MAPPING-TABLE-OVERHEAD*) T))))

;;; Generic Dispatch
(DEFUN HANDLE-GENERIC-UNCLAIMED-MESSAGE (#+IMACH SELECTOR #+IMACH SELF
					 #+3600 SELF #+3600 IGNORE #+3600 SELECTOR
					 &REST ARGS)
  (DECLARE (DBG:ERROR-REPORTER))
  (LOOP DOING
    (SIGNAL-PROCEED-CASE ((VALUE) 'UNCLAIMED-MESSAGE
			  :OBJECT SELF
			  :MESSAGE SELECTOR
			  :ARGUMENTS (COPY-LIST ARGS))
      ((:NEW-MESSAGE :NEW-FUNCTION)
       (RETURN-FROM HANDLE-GENERIC-UNCLAIMED-MESSAGE
	 (APPLY SELF VALUE ARGS)))
      (:ARGUMENT-VALUE
	(COND ((TYPEP SELECTOR 'GENERIC-FUNCTION)
	       (RETURN-FROM HANDLE-GENERIC-UNCLAIMED-MESSAGE
		 (APPLY SELECTOR VALUE ARGS)))
	      (T
	       (SETQ SELF VALUE)))))))

(DEFUN INITIALIZE-GENERIC-DISPATCH-HANDLERS ()
  #+3600 (UNLESS (VARIABLE-BOUNDP %GENERIC-DISPATCH-VECTOR)
	   ;; This array has to be safeguarded, since the GC doesn't scavenge A-memory.
	   (SETQ %GENERIC-DISPATCH-VECTOR
		 (LOCF (AREF (MAKE-ARRAY (ROT 1 (BYTE-SIZE SYS:%%Q-DATA-TYPE))
					 :AREA SAFEGUARDED-OBJECTS-AREA)
			     0))))
  (LET* ((FAKE-HANDLER-TABLE (MAKE-ARRAY 3))
	 (FAKE-FLAVOR (MAKE-FLAVOR :HASH-MASK 0
				   :HASH-ADDRESS (LOCF (AREF FAKE-HANDLER-TABLE 0))))
	 (LOC #+IMACH (LOCF (FLAVOR-HASH-MASK FAKE-FLAVOR))
	      #+3600 FAKE-FLAVOR))
    (SETF (AREF FAKE-HANDLER-TABLE #+IMACH 1 #+3600 2)
	  #+IMACH (%MAKE-POINTER DTP-EVEN-PC #'HANDLE-GENERIC-UNCLAIMED-MESSAGE)
	  #+3600 #'HANDLE-GENERIC-UNCLAIMED-MESSAGE)
    (LOOP REPEAT (ROT 1 (BYTE-SIZE SYS:%%Q-DATA-TYPE))
	  FOR POINTER FIRST #+IMACH (%POINTER-PLUS %TRAP-VECTOR-BASE %GENERIC-DISPATCH-VECTOR)
			    #+3600 %GENERIC-DISPATCH-VECTOR
		      THEN (%POINTER-PLUS POINTER 1)
	  DOING
      (#+IMACH %MEMORY-WRITE #+3600 %P-STORE-CONTENTS POINTER LOC))))

(ADD-INITIALIZATION "Initialize Generic Dispatch Handlers"
		    '(INITIALIZE-GENERIC-DISPATCH-HANDLERS)
		    '(:ONCE))
