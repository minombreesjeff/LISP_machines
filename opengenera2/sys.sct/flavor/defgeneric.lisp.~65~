;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains the defining form for generic functions, its supporting
;;; data structures, and its immediate subroutines.

;;; Generic-function object.  These are "interned", i.e. once one is created
;;; with a given name, the same object is used forever, being modified rather
;;; than replaced if another DEFGENERIC is evaluated.  This is because the
;;; object itself will be used as the selector in flavors' handler tables.
;;; For now, at least, "interning" uses the GENERIC property of the name.
;;; If you REMPROP a GENERIC property, you will get into very serious trouble
;;; because the flavor system won't keep things consistent.  For example, you
;;; may get handlers placed into handler tables under the wrong selector key.

;;; The name of a generic may or may not be FDEFINE'd to that generic.

;;; An object reference to a generic function has type DTP-GENERIC-FUNCTION and
;;; the address of a list-representation structure containing the fields
;;; defined by a DEFSTORAGE in SYSDEF.  The comments on those fields are
;;; repeated here for mutual edification and enjoyment.

;GENERIC-FUNCTION-NAME			;A symbol, or a list that names a derived function
;GENERIC-FUNCTION-ARGLIST		;A lambda-list (first argument is dispatched upon)
;GENERIC-FUNCTION-DEBUGGING-INFO	;Alist similar to debugging-info of compiled-function
;GENERIC-FUNCTION-METHOD-COMBINATION	;Type of method-combination to be used
;					;List of method-combination type symbol and parameters
;					;NIL if not specified by the generic function, in
;					;which case the flavor can specify it or the
;					;default can be taken
;GENERIC-FUNCTION-FLAGS			;Fixnum full of useful bits (defined below)
;GENERIC-FUNCTION-FLAVORS		;List of names of all flavors with methods for this
;  This could be removed if we ever get rid of message-passing (ha ha)
;GENERIC-FUNCTION-SELECTOR		;Selector in flavors' handler tables: this object
;					;or a message symbol

(DEFVAR *GENERIC-FUNCTION-FLAGS* (MAKE-LIST 11))

(DEFMACRO DEFINE-GENERIC-FUNCTION-FLAG (NAME BIT-NUMBER DESCRIPTION)
  (CHECK-TYPE BIT-NUMBER (INTEGER 0 (#.(INTEGER-LENGTH MOST-POSITIVE-FIXNUM)))
	     "a bit number that fits in a positive fixnum")
  `(PROGN
     (UNLESS (> (LENGTH *GENERIC-FUNCTION-FLAGS*) ,BIT-NUMBER)
       (SETQ *GENERIC-FUNCTION-FLAGS*
	     (APPEND *GENERIC-FUNCTION-FLAGS*
		     (MAKE-LIST (1+ (- ,BIT-NUMBER (LENGTH *GENERIC-FUNCTION-FLAGS*)))))))
     (SETF (NTH ,BIT-NUMBER *GENERIC-FUNCTION-FLAGS*) ',DESCRIPTION)
     (DEFSUBST ,NAME (GF)
       (LDB-TEST (BYTE 1 ,BIT-NUMBER) (GENERIC-FUNCTION-FLAGS GF)))))

(DEFPROP DEFINE-GENERIC-FUNCTION-FLAG DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-EXPLICIT 0 "Explicit")
	;T if declared explicitly by DEFGENERIC (or as an accessor)

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-METHODS-MADE 1 "Methods Exist")
	;T if DEFMETHOD has been macroexpanded for a method for this
	;generic.  This controls warnings for forward references to
	;generics with funny method-combinations that transform the arguments.

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-ACCESSOR 2 "Accessor")
	;T if this is an accessor (controls error message for wrong type argument)

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-MESSAGE-P 3 "Message")
	;T if this is really a message, which is sent rather than called.
	;This affects the selector and is necessary as long as we continue to
	;support message-passing.

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-SOLITARY 4 "Solitary")
	;T if the only method for this generic was declared to be a solitary method.
	;This causes a different method-indexing technique to be used.

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-INLINE-METHODS 5 "Inline-methods")
	;T if methods are to be coded inline in combined-methods

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-INLINE-RECURSIVE-METHODS 6
			      "Inline-recursive-methods")
	;T if (generic SELF ...) in an inlined method gets inlined also

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-HAS-DISPATCH-FUNCTION 7
			      "Has-dispatch-function")
	;T if FDEFINITION of its name is not the generic-function object, but
	;instead is a piece of compiled code to do the dispatching.

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-HAS-COMPATIBLE-MESSAGE 8
			      "Has-compatible-message")

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-COMPRESSED-DEBUGGING-INFO 9
			      "Compressed-debugging-info")

(DEFINE-GENERIC-FUNCTION-FLAG GENERIC-FUNCTION-LINKED 10 "Linked")
	;T if there may be any direct links to this generic function.

(DEFINE-GENERIC-FUNCTION-FLAG CLOS-INTERNALS::GENERIC-FUNCTION-CLOS 11.
  "This generic function is a CLOS generic function")

(DEFSUBST GENERIC-FUNCTION-COMPATIBLE-MESSAGE (GF)
  (AND (GENERIC-FUNCTION-HAS-COMPATIBLE-MESSAGE GF)
       (GENERIC-FUNCTION-SELECTOR GF)))

;;; List of names of debugging-info items that should be picked up from
;;; methods when the generic function has not been defined explicitly
(DEFPARAMETER *GENERIC-FUNCTION-DEBUGGING-INFO-TAKEN-FROM-METHOD*
	      '(VALUES SYS:DOWNWARD-FUNARG))

(DEFUN DESCRIBE-GENERIC-FUNCTION (GENERIC)
  (DESCRIBE-DEFSTRUCT-WITH-FLAGS-INTERNAL
	GENERIC 'GENERIC-FUNCTION
	'((NAME . GENERIC-FUNCTION-NAME)
	  (ARGLIST . GENERIC-FUNCTION-ARGLIST)
	  (DEBUGGING-INFO . GENERIC-FUNCTION-DEBUGGING-INFO)
	  (METHOD-COMBINATION . GENERIC-FUNCTION-METHOD-COMBINATION)
	  (FLAGS . GENERIC-FUNCTION-FLAGS)
	  (FLAVORS . GENERIC-FUNCTION-FLAVORS)
	  (SELECTOR . GENERIC-FUNCTION-SELECTOR))
	*GENERIC-FUNCTION-FLAGS*))

;--- An expedient hack, maybe replaced later by something more general
(DEFUN DESCRIBE-DEFSTRUCT-WITH-FLAGS (STRUCTURE DEFSTRUCT-TYPE FLAGS)
  (LET ((DESCRIPTION (GET DEFSTRUCT-TYPE 'SI:DEFSTRUCT-DESCRIPTION)))
    (UNLESS DESCRIPTION
      (ERROR "~S is not a known type of structure." STRUCTURE))
    (DESCRIBE-DEFSTRUCT-WITH-FLAGS-INTERNAL
	STRUCTURE (SI:DEFSTRUCT-DESCRIPTION-NAME DESCRIPTION)
	(LOOP FOR (NAME . SLOT-DESCRIPTION)
		  IN (SI:DEFSTRUCT-DESCRIPTION-SLOT-ALIST DESCRIPTION)
	      COLLECT (CONS NAME
			    (SI:DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME SLOT-DESCRIPTION)))
	FLAGS)))

;This began life as DESCRIBE-DEFSTRUCT
(DEFUN DESCRIBE-DEFSTRUCT-WITH-FLAGS-INTERNAL (STRUCTURE TYPE SLOTS FLAGS)
  (FORMAT T "~%~S is a ~S~%" STRUCTURE TYPE)
  (LOOP FOR (NAME . ACCESSOR) IN SLOTS DOING
    (FORMAT T "   ~30A" (STRING-APPEND NAME ":"))
    (LET* ((FORM `(,ACCESSOR ',STRUCTURE))
	   (VALUE (EVAL FORM)))
      (PRESENT VALUE 'EXPRESSION :FORM FORM)
      (WHEN (AND (STRING-EQUAL NAME 'FLAGS) (INTEGERP VALUE))
	(WITH-INDENTATION (*STANDARD-OUTPUT*
			    (SEND *STANDARD-OUTPUT* :READ-CURSORPOS :CHARACTER))
	  (LOOP FOR DESCRIPTION IN FLAGS AS BIT FROM 0 WITH FIRST = T DO
	    (WHEN (LOGBITP BIT VALUE)
	      (WRITE-STRING (IF FIRST "   (" ","))
	      (WHEN (> (STRING-LENGTH DESCRIPTION)
		       (- (OR (SEND-IF-HANDLES *STANDARD-OUTPUT* :SIZE-IN-CHARACTERS) 90.)
			  (SEND *STANDARD-OUTPUT* :READ-CURSORPOS :CHARACTER)
			  1))
		(TERPRI))
	      (WRITE-STRING DESCRIPTION)
	      (SETQ FIRST NIL))
	    FINALLY (UNLESS FIRST (WRITE-STRING ")")))))
      (TERPRI)))
  STRUCTURE)

(DEFSUBST MAKE-GENERIC-FUNCTION (&KEY NAME ARGLIST DEBUGGING-INFO METHOD-COMBINATION (FLAGS 0)
				      (FLAVORS NIL) SELECTOR AREA)
  (%MAKE-POINTER DTP-GENERIC-FUNCTION
		 (LIST-IN-AREA AREA NAME ARGLIST DEBUGGING-INFO METHOD-COMBINATION
				    FLAGS FLAVORS SELECTOR)))

;;; The GENERIC special form
;;; as in (APPLY (GENERIC MAKE-INSTANCE) NEW-INSTANCE INIT-OPTIONS)
;;; The dumper knows how to dump generic functions now.
;;; Some day this should pass its environment to FIND-GENERIC-FUNCTION.
(DEFMACRO GENERIC (GENERIC-FUNCTION-NAME)
  ;; For MAPFORMS purposes, this is just a constant.  Actually expanding the macro
  ;; would signal an error if the generic function is undefined and we aren't compiling
  ;; to a file.
  (DECLARE LT:(ARG-TEMPLATE FLAVOR:GENERIC)
	   (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CHECK-TYPE GENERIC-FUNCTION-NAME GENERIC-FUNCTION-NAME)
  `',(FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME T 'COMPILE))

(DEFUN COPY-GENERIC-FUNCTION (GF)
  (MAKE-GENERIC-FUNCTION :NAME (GENERIC-FUNCTION-NAME GF)
			 :ARGLIST (GENERIC-FUNCTION-ARGLIST GF)
			 :DEBUGGING-INFO (COPY-TREE (GENERIC-FUNCTION-DEBUGGING-INFO GF))
			 :METHOD-COMBINATION (GENERIC-FUNCTION-METHOD-COMBINATION GF)
			 :FLAGS (GENERIC-FUNCTION-FLAGS GF)
			 :FLAVORS (COPY-LIST (GENERIC-FUNCTION-FLAVORS GF))
			 :SELECTOR (GENERIC-FUNCTION-SELECTOR GF)))

;;; Arguments seen by a method, after SELF (and other internal args such as mapping-table)
(DEFUN GENERIC-FUNCTION-METHOD-ARGLIST (GF)
  (LET ((ASSOC (ASSOC ':METHOD-ARGLIST (SI:EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO GF))))
    (IF ASSOC (CDR ASSOC)
	(LT:REMOVE-ARGUMENTS-FROM-LAMBDA-LIST 1 (GENERIC-FUNCTION-ARGLIST GF))))) ;strip SELF

(DEFVAR *STANDARDIZED-GENERIC-FUNCTION-NAMES* NIL)

;;; So lists can be compared with EQ and so compatible-generics can be referred to
;;; by their message names.
(DEFUN STANDARDIZE-GENERIC-FUNCTION-NAME (NAME &OPTIONAL ENV)
  (ETYPECASE NAME
    (SYMBOL
      (OR (AND (EQ ENV 'COMPILE)
	       (COMPILER:FILE-DECLARATION NAME 'COMPATIBLE-GENERIC))
	  (GET NAME 'COMPATIBLE-GENERIC NAME)))
    (LIST
      (LET ((GF (FIND-GENERIC-FUNCTION NAME NIL)))
	(COND (GF (GENERIC-FUNCTION-NAME GF))
	      ((NOT (LISTP *STANDARDIZED-GENERIC-FUNCTION-NAMES*))
	       ;; Hash table
	       (MULTIPLE-VALUE-BIND (NIL NIL STANDARD-NAME)
		   (GETHASH NAME *STANDARDIZED-GENERIC-FUNCTION-NAMES*)
		 (OR STANDARD-NAME
		     (SETF (GETHASH (IF ( (%AREA-NUMBER NAME) *FLAVOR-STATIC-AREA*)
					(SETQ NAME (COPY-LIST NAME *FLAVOR-STATIC-AREA*))
					NAME)
				    *STANDARDIZED-GENERIC-FUNCTION-NAMES*)
			   NAME))))
	      ((FIND NAME *STANDARDIZED-GENERIC-FUNCTION-NAMES* :TEST #'EQUAL))
	      (T
	       ;; Maintain list until hash tables are bootstrapped during world build
	       (PUSH (IF ( (%AREA-NUMBER NAME) *FLAVOR-STATIC-AREA*)
			 (SETQ NAME (COPY-LIST NAME *FLAVOR-STATIC-AREA*))
			 NAME)
		     *STANDARDIZED-GENERIC-FUNCTION-NAMES*)
	       NAME))))))


;;;; Support for defining generic functions

(DEFPROP DEFGENERIC DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;--- Maybe add DEFMESSAGE which is similar to DEFGENERIC but explicitly makes it a message?
(DEFMACRO DEFGENERIC (NAME ARGLIST &BODY OPTIONS)
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFUN))
    (MULTIPLE-VALUE-BIND (FUNCTIONS PARSED-OPTIONS)
	(PARSE-DEFGENERIC NAME ARGLIST OPTIONS)
      (WHEN UNDO-DECLARATIONS-FLAG
	;; Add this generic to the compile-time environment
	(APPLY #'DEFGENERIC-INTERNAL NAME ARGLIST :COMPILE-TIME T PARSED-OPTIONS))
      ;; Arrange to build the GENERIC-FUNCTION structure at load time
      ;; and also to load any interface function or methods defined here
      ;;--- If the long-discussed "definition group" facility is ever implemented,
      ;;--- use it here and remove the RECORD-SOURCE-FILE-NAME from DEFGENERIC-INTERNAL.
      ;;--- Would need to move the validation of the name as well, I expect.
      (PROGNIFY
	`((DEFGENERIC-INTERNAL ',NAME ',ARGLIST
			       ,@(LOOP FOR (KEY VAL) ON PARSED-OPTIONS BY 'CDDR
				       NCONC `(,KEY ',VAL)))
	  ,@FUNCTIONS)))))

;;; NAME will be standardized, a la STANDARDIZE-GENERIC-FUNCTION-NAME, so if
;;;  you haven't standardized it already, look in generic-function-name of the result.
;;; ERROR-P says what happens if no generic by this name is found:
;;;  T (the default)  signal an error
;;;  NIL  return NIL
;;;  MESSAGE  assume it to be a message and create a generic accordingly
;;;  CREATE  create a generic, deciding heuristically whether or not it's a message
;;;  CREATE-IN-ENV  if not found in ENV, but exists in current world, then copy into ENV.
;;;	If not found anywhere, same as CREATE
;;;
;;;  NOTE: The generic function name must be well-formed. that is, a 
;;;  valid-derived-function spec. ERROR-P of NIL will not protect you
;;;  from that.
;;;
(DEFUN FIND-GENERIC-FUNCTION (NAME &OPTIONAL (ERROR-P T) ENV &AUX TEM)
  (CHECK-TYPE ERROR-P (MEMBER T NIL MESSAGE CREATE CREATE-IN-ENV))
  (CHECK-TYPE NAME GENERIC-FUNCTION-NAME)
  (STANDARDIZE-ENV ENV)
  (OR (COND ((EQ ENV 'COMPILE)
	     (OR (COMPILER:FILE-DECLARATION NAME 'GENERIC)
		 (AND (SYMBOLP NAME)
		      (SETQ TEM (GETDECL NAME 'COMPATIBLE-GENERIC))
		      (COMPILER:FILE-DECLARATION TEM 'GENERIC))))
	    (ENV
	     (OR (THIRD (ASSOC NAME ENV :TEST #'EQUAL))
		 (AND (SYMBOLP NAME)
		      (SETQ TEM (GET NAME 'COMPATIBLE-GENERIC))
		      (ASSOC TEM ENV :TEST #'EQUAL)))))
      (AND ENV (EQ ERROR-P 'CREATE-IN-ENV)
	   (LET ((GF (FIND-GENERIC-FUNCTION NAME NIL NIL)))
	     (WHEN GF
	       (SETQ GF (COPY-GENERIC-FUNCTION GF))
	       (COND ((EQ ENV 'COMPILE)
		      (COMPILER:FILE-DECLARE NAME 'GENERIC GF))
		     ((SETQ TEM (ASSOC NAME ENV :TEST #'EQUAL))
		      (IF (CDDR TEM)
			  (SETF (THIRD TEM) GF)
			  (SETF (CDDR TEM) (LIST GF))))
		     (T
		      (NCONC ENV (LIST (LIST NAME NIL GF)))))
	       GF)))
      (IF (SYMBOLP NAME)
	  (OR (GET NAME 'GENERIC)
	      (AND (SETQ TEM (GET NAME 'COMPATIBLE-GENERIC))
		   (GET TEM 'GENERIC)))
	  (SI:FUNCTION-SPEC-GET NAME 'GENERIC))
      (CASE ERROR-P
	((MESSAGE CREATE CREATE-IN-ENV)
	 (DEFGENERIC-INTERNAL NAME NIL
	   :COMPILE-TIME (EQ ENV 'COMPILE)
	   :EXPLICIT NIL
	   :MESSAGE-P (OR (EQ ERROR-P 'MESSAGE)
			  (GENERIC-FUNCTION-HEURISTICALLY-MESSAGE NAME))))
	((NIL) NIL)
	(OTHERWISE (ERROR 'GENERIC-FUNCTION-NOT-FOUND :NAME NAME)))))

;;; Predicate to determine if a given symbol is the name of a message.
;;; Used in error-signalling, to distinguish messages from generic
;;; functions.  -- ACW 10/07/92 14:58:17
(DEFUN MESSAGE-P (NAME)
  (GENERIC-FUNCTION-MESSAGE-P (FIND-GENERIC-FUNCTION NAME)))

;;; Make a generic function to access a readable/writable/gettable/settable instance variable.
;;; It is permissible for the generic function to exist already; in other words,
;;; it is legal for two flavors to use the same accessor name in a consistent way.
(DEFUN MAKE-GENERIC-ACCESSOR (GENERIC FLAVOR ARGLIST DEBUGGING-INFO COMPILE-TIME MESSAGE-P)
  (LET ((GF (FIND-GENERIC-FUNCTION GENERIC NIL (AND COMPILE-TIME 'COMPILE))))
    (COND ((NULL GF)
	   (SETQ GF (DEFGENERIC-INTERNAL GENERIC ARGLIST :DEBUGGING-INFO DEBUGGING-INFO
							 :COMPILE-TIME COMPILE-TIME
							 :EXPLICIT (NOT MESSAGE-P)
							 :MESSAGE-P MESSAGE-P))
	   (SETF (GENERIC-FUNCTION-ACCESSOR GF) T))
	  (T
	   (SI:EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO GF)
	   (WHEN (OR (GENERIC-FUNCTION-EXPLICIT GF)				;defined
		     (AND (NOT MESSAGE-P) (GENERIC-FUNCTION-ARGLIST GF)))	;inferred
	     (UNLESS (COMPATIBLE-ARGLISTS ARGLIST (GENERIC-FUNCTION-ARGLIST GF))
	       (WARN "The arguments expected by the ~:[generic function~;message~] ~S~@
		  when used as an instance-variable accessor, ~:S,~@
		  are not consistent with the arguments, ~:S, already ~:[inferred~;defined~]."
		     MESSAGE-P GENERIC ARGLIST (GENERIC-FUNCTION-ARGLIST GF)
		     (GENERIC-FUNCTION-EXPLICIT GF))))
	   (UNLESS (GENERIC-FUNCTION-EXPLICIT GF)
	     (UNLESS MESSAGE-P			;This counts as an explicit definition
	       (SETF (GENERIC-FUNCTION-ARGLIST GF) ARGLIST)
	       (SETF (GENERIC-FUNCTION-EXPLICIT GF) T))
	     (SETF (GENERIC-FUNCTION-ACCESSOR GF) T))
	   ;; Set the function definition, as DEFGENERIC-INTERNAL would.
	   ;; EXPLICIT argument is NIL because RECORD-SOURCE-FILE-NAME has not been called.
	   (UNLESS (OR COMPILE-TIME MESSAGE-P
		       (GENERIC-FUNCTION-HAS-DISPATCH-FUNCTION GF))
	     (INSTALL-GENERIC-FUNCTION GENERIC GF NIL T))))
    (PUSHNEW FLAVOR (GENERIC-FUNCTION-FLAVORS GF))
    GF))

;;; If some generic accessors have been removed, unlink genericflavor links
(DEFUN NOTE-ACCESSORS-REMOVED (NEW-FL OLD-FL)
  (LET ((READABLE (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES NEW-FL))
	(WRITABLE (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES NEW-FL))
	(LOCATABLE (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES NEW-FL))
	(METHODS (FLAVOR-METHOD-TABLE OLD-FL)))
    (FLET ((NOTE-REMOVALS (LIST)
	     (LOOP FOR (GENERIC) IN LIST DO
	       (UNLESS (OR (ASSOC GENERIC READABLE)
			   (ASSOC GENERIC WRITABLE)
			   (ASSOC GENERIC LOCATABLE)
			   (LOOP FOR MH IN (CDR (ASSOC GENERIC METHODS))
				 AS METHOD = (METHOD-HOLDER-FUNCTION-SPEC MH)
				 THEREIS (NOT (EQ (METHOD-TYPE METHOD) 'COMBINED))))
		 (LET ((GF (FIND-GENERIC-FUNCTION GENERIC)))
		   (SETF (GENERIC-FUNCTION-FLAVORS GF)
			 (DELETE (FLAVOR-NAME OLD-FL) (GENERIC-FUNCTION-FLAVORS GF))))))))
      (NOTE-REMOVALS (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES OLD-FL))
      (NOTE-REMOVALS (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES OLD-FL))
      (NOTE-REMOVALS (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES OLD-FL)))))

;;; True if the name of a generic function looks like a message
;--- Give user more control over this?
(DEFUN GENERIC-FUNCTION-HEURISTICALLY-MESSAGE (NAME)
  (KEYWORDP NAME))

;;; Called by the dumper.
(DEFUN GENERIC-FUNCTION-FASD-FORM (GENERIC-FUNCTION)
  `(FIND-GENERIC-FUNCTION-AS-CONSTANT ',(GENERIC-FUNCTION-NAME GENERIC-FUNCTION)))

;;; Parse a DEFGENERIC, also look for possible embedded function definitions
(DEFUN PARSE-DEFGENERIC (NAME ARGLIST OPTIONS)
  (DECLARE (VALUES FUNCTIONS PARSED-OPTIONS))
  (LET ((DEBUGGING-INFO NIL)
	(DOWNWARD-FUNARGS NIL)
	(METHOD-COMBINATION NIL)
	(COMPATIBLE-MESSAGE NIL)
	(DECLARATIONS NIL)
	(BODY NIL)
	(METHODS NIL)
	(FUNCTIONS NIL)
	(INLINE-METHODS NIL)
	(DISPATCH NIL)
	(OPTIMIZE NIL)
	(OPTIMIZE-SPEED NIL)
	(METHOD-ARGLIST (LT:REMOVE-ARGUMENTS-FROM-LAMBDA-LIST 1 ARGLIST))
	DEFGENERIC-OPTION ARGS)
    ;; Parse options into local variables
    (FLET ((SINGLE-ARG ()
	     (UNLESS (= (LENGTH ARGS) 1)
	       (WARN "The DEFGENERIC option ~S requires exactly one argument."
		     DEFGENERIC-OPTION))
	     (FIRST ARGS))
	   (SOME-ARGS (&OPTIONAL (MIN 1) MAX)
	     (WHEN (< (LENGTH ARGS) MIN)
	       (WARN "The DEFGENERIC option ~S requires at least ~R argument~:P."
		     DEFGENERIC-OPTION MIN))
	     (AND MAX (> (LENGTH ARGS) MAX)
		  (WARN "The DEFGENERIC option ~S accepts at most ~D arguments."
			DEFGENERIC-OPTION MAX))
	     ARGS))
      (LOOP FOR (OPTION . REST) ON OPTIONS DO
	(COND ((LISTP OPTION)
	       (SETQ DEFGENERIC-OPTION (CAR OPTION)
		     ARGS (CDR OPTION)))
	      ((STRINGP OPTION)
	       (SETQ DEFGENERIC-OPTION ':DOCUMENTATION
		     OPTION `(:DOCUMENTATION ,OPTION)
		     ARGS (CDR OPTION)))
	      (T
	       (SETQ DEFGENERIC-OPTION OPTION
		     ARGS NIL)))
	(UNLESS (MEMBER DEFGENERIC-OPTION '(:METHOD DECLARE))
	  (DOLIST (OTHER REST)
	    (WHEN (EQ (IF (ATOM OTHER) OTHER (CAR OTHER)) DEFGENERIC-OPTION)
	      (WARN "The DEFGENERIC option ~S is specified twice."
		    DEFGENERIC-OPTION))))
	(ECASE DEFGENERIC-OPTION
	  (:METHOD-COMBINATION (SETQ METHOD-COMBINATION (SOME-ARGS)))
	  (:COMPATIBLE-MESSAGE (SETQ COMPATIBLE-MESSAGE (SINGLE-ARG)))
	  (:DOCUMENTATION (SINGLE-ARG) (PUSH OPTION DEBUGGING-INFO))
	  (:METHOD-ARGLIST (SETQ METHOD-ARGLIST ARGS) (PUSH OPTION DEBUGGING-INFO))
	  (:INLINE-METHODS
	    (SETQ INLINE-METHODS (IF (LISTP OPTION) (SINGLE-ARG) T))
	    (UNLESS (MEMBER INLINE-METHODS '(NIL T :RECURSIVE))
	      (WARN "The DEFGENERIC option :INLINE-METHODS ~S is invalid.~@
		     Valid values are NIL, T, and :RECURSIVE."
		    INLINE-METHODS)
	      (SETQ INLINE-METHODS NIL)))
	  (:OPTIMIZE (SETQ OPTIMIZE (SOME-ARGS)))
	  (:DISPATCH (SETQ DISPATCH (SINGLE-ARG)))
	  (:FUNCTION (SETQ BODY (SOME-ARGS)))
	  (:METHOD (PUSH (SOME-ARGS 2) METHODS))
	  (DECLARE
	    (SETQ DECLARATIONS (APPEND DECLARATIONS (SOME-ARGS)))
	    (DOLIST (DCL ARGS)
	      (COND ((NOT (AND (LISTP DCL) (SYMBOLP (FIRST DCL))))
		     (WARN "~S is not a valid declaration in DEFGENERIC" DCL))
		    ((EQ (FIRST DCL) 'OPTIMIZE)
		     (SETQ OPTIMIZE (REST DCL)))
		    ((GET (FIRST DCL) 'SI:DEBUG-INFO)
		     (PUSH DCL DEBUGGING-INFO))
		    ((OR (EQ (FIRST DCL) 'SYS:DOWNWARD-FUNARG)
			 (EQ (FIRST DCL) 'FUTURE-COMMON-LISP:DYNAMIC-EXTENT))
		     (SETQ DOWNWARD-FUNARGS
			   (APPEND (SI:DOWNWARD-FUNARG-DEBUGGING-INFO DCL ARGLIST NIL)
				   DOWNWARD-FUNARGS)))
		    (T
		     (WARN "~S is not a valid declaration in DEFGENERIC" DCL)))
	      )))))
    (WHEN DOWNWARD-FUNARGS
      (PUSH `(SYS:DOWNWARD-FUNARG ,DOWNWARD-FUNARGS) DEBUGGING-INFO))
    ;; Accept the Common Lisp OPTIMIZE declaration, ignore most of it
    (DOLIST (OPTION OPTIMIZE)
      (MULTIPLE-VALUE-BIND (QUALITY ENABLE)
	  (IF (LISTP OPTION)
	      (VALUES (FIRST OPTION) (NOT (EQL (SECOND OPTION) 0)))
	      (VALUES OPTION T))
	(COND ((NOT (MEMBER QUALITY '(SPEED SPACE SAFETY COMPILATION-SPEED)
			    :TEST #'STRING-EQUAL))
	       (WARN "The DEFGENERIC optimization quality ~S is invalid.~@
		     Valid values are SPEED, SPACE, SAFETY, and COMPILATION-SPEED." QUALITY))
	      ((NOT ENABLE))
	      ((STRING-EQUAL QUALITY 'SPEED) (SETQ OPTIMIZE-SPEED T)))))
    (WHEN (AND DISPATCH
	       (NOT (EQ DISPATCH (FIRST ARGLIST))))
      ;;--- As with DEFSUBST, there is the issue that if you do a DEFGENERIC
      ;;--- with the :DISPATCH option, then later do it again with the :DISPATCH
      ;;--- removed, the INLINE proclamation or compiler optimizer stays around.
      ;; Dispatching off a different argument than normal, generate trampoline
      ;; Compute list of required arguments and rest argument if there are any others
      (MULTIPLE-VALUE-BIND (ARGS APPLY)
	  (LOOP FOR ARG IN ARGLIST
		IF (LT:VARIABLEP ARG)
		  COLLECT ARG INTO ARGS
		ELSE RETURN (VALUES ARGS (GENSYM))
		FINALLY (RETURN (VALUES ARGLIST NIL)))
	(UNLESS (MEMBER DISPATCH ARGS)
	  (WARN "The DEFGENERIC option :DISPATCH ~S is invalid because~@
			~:*~S is not the name of a required argument of this generic."
		DISPATCH))
	(DOLIST (OTHER OPTIONS)
	  (UNLESS (ATOM OTHER) (SETQ OTHER (CAR OTHER)))
	  (WHEN (MEMBER OTHER '(:FUNCTION :METHOD-ARGLIST))
	    (WARN "The DEFGENERIC option :DISPATCH cannot be used together with ~S."
		  OTHER)))
	(SETQ METHOD-ARGLIST (LT:REMOVE-FROM-LAMBDA-LIST DISPATCH ARGLIST))
	(PUSH `(:METHOD-ARGLIST ,@METHOD-ARGLIST) DEBUGGING-INFO)
	(UNLESS (ASSOC 'ARGLIST DECLARATIONS)
	  (PUSH `(ARGLIST ,@ARGLIST) DECLARATIONS))
	;; Transform the arglist and body.
	(SETF ARGLIST (IF APPLY
			  `(,@ARGS &REST ,APPLY)
			  ARGS))
	(SETQ BODY (IF APPLY
		       `((APPLY (GENERIC ,NAME) ,DISPATCH ,@(REMOVE DISPATCH ARGS) ,APPLY))
		       `((FUNCALL (GENERIC ,NAME) ,DISPATCH ,@(REMOVE DISPATCH ARGS)))))
	(WHEN OPTIMIZE-SPEED
	  (PUSH `(PROCLAIM '(INLINE ,NAME)) FUNCTIONS))))
    (DOLIST (METHOD METHODS)
      (PUSH `(DEFMETHOD (,NAME ,@(FIRST METHOD)) ,METHOD-ARGLIST
	       (DECLARE (FUNCTION-PARENT ,NAME DEFUN))
	       ,@(REST METHOD))
	    FUNCTIONS))
    (WHEN (AND COMPATIBLE-MESSAGE (NOT BODY))
      ;; Create COMPATIBLE-MESSAGE trampoline
      ;; Note that we still send even if SELF is not an instance, since it might be some
      ;; other object that obeys message-passing protocol, such as a closure of a defselect.
      (UNLESS (ASSOC 'ARGLIST DECLARATIONS)
	(PUSH `(ARGLIST ,@ARGLIST) DECLARATIONS))
      (SETQ ARGLIST '(SELF &REST ARGS))
      (SETQ BODY `((APPLY #'SEND SELF ',COMPATIBLE-MESSAGE ARGS))))
    (WHEN BODY
      (PUSH `(DEFUN ,NAME ,ARGLIST
	       ,@(AND DECLARATIONS
		      `((DECLARE ,@DECLARATIONS)))
	       ,@(AND (STRINGP (CADR (ASSOC ':DOCUMENTATION DEBUGGING-INFO)))
		      `(,(CADR (ASSOC ':DOCUMENTATION DEBUGGING-INFO))))
	       ,@BODY)
	    FUNCTIONS))
    (VALUES (NREVERSE FUNCTIONS)		;PROCLAIM before DEFUN
	    (APPEND
	      (AND DEBUGGING-INFO `(:DEBUGGING-INFO ,DEBUGGING-INFO))
	      (AND METHOD-COMBINATION `(:METHOD-COMBINATION ,METHOD-COMBINATION))
	      (AND COMPATIBLE-MESSAGE `(:COMPATIBLE-MESSAGE ,COMPATIBLE-MESSAGE))
	      (AND BODY `(:DEFINE-P NIL))
	      (AND INLINE-METHODS `(:INLINE-METHODS ,INLINE-METHODS))))))

;;; Guts of DEFGENERIC and FIND-GENERIC-FUNCTION
;;; Value is the GENERIC-FUNCTION structure, not the symbol that names it.
;;; EXPLICIT means that DEFGENERIC was written explicitly (perhaps inside of a DEFFLAVOR).
;;; COMPILE-TIME means that the results of this will be discarded when the compilation is over
;;;   UNDO-DECLARATIONS-FLAG must be set and COMPILER:FILE-LOCAL-DECLARATIONS must be bound.
;;; DEBUGGING-INFO is the debugging-info alist derived from the defgeneric options.
;;; METHOD-COMBINATION is the method-combination specified by defgeneric options.
;;; COMPATIBLE-MESSAGE is NIL or a message whose sending invokes this generic.
;;; MESSAGE-P is T if this generic is only invoked as a message.
;;; DEFINE-P is T if this generic is to be made the function definition of its name.
(DEFUN DEFGENERIC-INTERNAL (NAME ARGLIST
			    &KEY (EXPLICIT T) COMPILE-TIME DEBUGGING-INFO METHOD-COMBINATION
				 COMPATIBLE-MESSAGE MESSAGE-P (DEFINE-P T) INLINE-METHODS)

  ;; Validate the arguments
  (UNLESS (TYPEP NAME 'GENERIC-FUNCTION-NAME)
    (WARN "Invalid name ~S specified for a generic function.
The name of a generic function~:[ (or a message)~] must be a non-NIL symbol
or a list of two elements: one of ~{~S~^,~} followed by a non-NIL symbol."
	  NAME EXPLICIT SI:*DERIVED-FUNCTION-TYPES*)
    (RETURN-FROM DEFGENERIC-INTERNAL NIL))
  (UNLESS (LISTP ARGLIST)
    (WARN "Invalid argument list ~S specified for a generic function.
A list, possibly empty, is required."
	  ARGLIST)
    (SETQ ARGLIST NIL))
  (WHEN METHOD-COMBINATION
    (UNLESS (AND (SYMBOLP (FIRST METHOD-COMBINATION))
		 (GETDECL (FIRST METHOD-COMBINATION) 'METHOD-COMBINATION))
      (WARN "~S is not currently defined as a method-combination type"
	    (FIRST METHOD-COMBINATION))))

  ;; Record the definition, if truly a generic function, and check for name conflict
  ;; Don't record the definition if :FUNCTION was used, because that would cause a
  ;; spurious warning about duplicate definitions in the file.
  (AND EXPLICIT
       DEFINE-P
       (NOT MESSAGE-P)
       (NOT COMPILE-TIME)
       (NOT (RECORD-SOURCE-FILE-NAME NAME 'DEFUN))
       (RETURN-FROM DEFGENERIC-INTERNAL NIL))

  ;; If there is an existing generic-function by this name, redefine it
  ;; Otherwise, make a new one
  ;; At compile-time, never use the run-time one
  (LET ((GENERIC
	  (OR (IF COMPILE-TIME
		  (COMPILER:FILE-DECLARATION NAME 'GENERIC)
		  (FIND-GENERIC-FUNCTION NAME NIL))
	      (MAKE-GENERIC-FUNCTION
		;; Generics at run-time are not ephemeral.  Put them in a static
		;; area so we don't need to rehash handler tables after dynamic GC's.
		:AREA (IF COMPILE-TIME DEFAULT-CONS-AREA *FLAVOR-STATIC-AREA*)
		:METHOD-COMBINATION METHOD-COMBINATION
		:NAME
		  ;; Make sure the name in the generic-function is consistent with the
		  ;; name that standardize-generic-function-name would return.
		  (COND (COMPILE-TIME NAME)
			((ATOM NAME) NAME)
			((NOT (LISTP *STANDARDIZED-GENERIC-FUNCTION-NAMES*))
			 ;; Hash table
			 (MULTIPLE-VALUE-BIND (NIL NIL STANDARD-NAME)
			     (GETHASH NAME *STANDARDIZED-GENERIC-FUNCTION-NAMES*)
			   (OR STANDARD-NAME
			       (SETF (GETHASH
				       (IF ( (%AREA-NUMBER NAME) *FLAVOR-STATIC-AREA*)
					   (SETQ NAME (COPY-LIST NAME *FLAVOR-STATIC-AREA*))
					   NAME)
				       *STANDARDIZED-GENERIC-FUNCTION-NAMES*)
				     NAME))))
			((FIND NAME *STANDARDIZED-GENERIC-FUNCTION-NAMES* :TEST #'EQUAL))
			(T
			 ;; Maintain list until hash tables are bootstrapped
			 ;; during world build
			 (PUSH (IF ( (%AREA-NUMBER NAME) *FLAVOR-STATIC-AREA*)
				   (SETQ NAME (COPY-LIST NAME *FLAVOR-STATIC-AREA*))
				   NAME)
			       *STANDARDIZED-GENERIC-FUNCTION-NAMES*)
			 NAME)))))
	(SOMETHING-CHANGED NIL))

    ;; Check for colliding with a compatible-message
    (UNLESS (EQUAL (GENERIC-FUNCTION-NAME GENERIC) NAME)
      ;;--- I don't want to think about whether there is a way to recover from this
      (ERROR "Cannot define a generic function named ~S because~@
	      that name is already a message synonymous with the generic function ~S"
	     NAME (GENERIC-FUNCTION-NAME GENERIC)))

    ;; Make sure the local variable NAME is the standardized version
    ;; so we can use EQ testing elsewhere
    (SETQ NAME (GENERIC-FUNCTION-NAME GENERIC))

    ;; The rest of this function is critical updating of data structures
    (WITHOUT-ABORTS
	("Flavor data structures are being updated to define the generic function ~S.~@
	  Aborting now could damage this generic function, the flavors that~@
	  have methods for it, and the table of names of all generic functions."
	 NAME)
      ;; Update uninteresting attributes of the generic just found or created
      (SETF (GENERIC-FUNCTION-ARGLIST GENERIC) ARGLIST)
      (SETF (GENERIC-FUNCTION-DEBUGGING-INFO GENERIC) DEBUGGING-INFO)
      (SETF (GENERIC-FUNCTION-EXPLICIT GENERIC) EXPLICIT)
      (SETF (GENERIC-FUNCTION-INLINE-METHODS GENERIC) INLINE-METHODS)
      (SETF (GENERIC-FUNCTION-INLINE-RECURSIVE-METHODS GENERIC)
	    (EQ INLINE-METHODS ':RECURSIVE))
      (SETF (GENERIC-FUNCTION-HAS-DISPATCH-FUNCTION GENERIC)
	    (AND (NOT MESSAGE-P) (NOT DEFINE-P)))
  
      ;; See whether this generic has been changed in a way that affects the flavors
      (UNLESS (EQ (GENERIC-FUNCTION-MESSAGE-P GENERIC) MESSAGE-P)
	(SETF (GENERIC-FUNCTION-MESSAGE-P GENERIC) MESSAGE-P)
	(SETQ SOMETHING-CHANGED T))
      (UNLESS (EQUAL (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC) METHOD-COMBINATION)
	(WHEN (GENERIC-FUNCTION-METHODS-MADE GENERIC)
	  (LET ((OLD-MC (CAR (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC)))
		(NEW-MC (CAR METHOD-COMBINATION)))
	    (UNLESS (EQ NEW-MC OLD-MC)
	      (MULTIPLE-VALUE-BIND (OLD-TRANSFORMER NEW-TRANSFORMER)
		  (IF COMPILE-TIME
		      (VALUES (GETDECL OLD-MC 'METHOD-COMBINATION-METHOD-TRANSFORMER)
			      (GETDECL NEW-MC 'METHOD-COMBINATION-METHOD-TRANSFORMER))
		      (VALUES (GET OLD-MC 'METHOD-COMBINATION-METHOD-TRANSFORMER)
			      (GET NEW-MC 'METHOD-COMBINATION-METHOD-TRANSFORMER)))
		(UNLESS (EQ OLD-TRANSFORMER NEW-TRANSFORMER)
		  (LET* ((OLD-KEYWORDS (AND OLD-TRANSFORMER
					    (ASSOC 'METHOD-COMBINATION-TRANSFORMER-KEYWORDS
						   (DEBUGGING-INFO OLD-TRANSFORMER))))
			 (NEW-KEYWORDS (AND NEW-TRANSFORMER
					    (ASSOC 'METHOD-COMBINATION-TRANSFORMER-KEYWORDS
						   (DEBUGGING-INFO NEW-TRANSFORMER))))
			 (ARGLIST-DIFFERS (OR (MEMBER ':METHOD-ARGLIST OLD-KEYWORDS)
					      (MEMBER ':METHOD-ARGLIST NEW-KEYWORDS)))
			 (BODY-DIFFERS (OR (MEMBER ':METHOD-BODY OLD-KEYWORDS)
					   (MEMBER ':METHOD-BODY NEW-KEYWORDS))))
		    (WHEN (OR ARGLIST-DIFFERS BODY-DIFFERS)
		      (WARN "Changing the method-combination of ~S from ~S to ~S
  may have caused some previously-defined methods to be compiled incorrectly, because the
  ~:[~;bodies of the methods ~:[~;and the ~]~:*~]~
  ~:[~;ways the methods receive their arguments ~]may have been changed."
		    NAME OLD-MC NEW-MC BODY-DIFFERS ARGLIST-DIFFERS))))))))
	(SETF (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC) METHOD-COMBINATION)
	(SETQ SOMETHING-CHANGED T))
      (UNLESS (EQ (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GENERIC) COMPATIBLE-MESSAGE)
	(IF COMPATIBLE-MESSAGE
	    (LET ((SUPERSEDED-GENERIC (AND (NOT COMPILE-TIME)
					   (FIND-GENERIC-FUNCTION COMPATIBLE-MESSAGE NIL))))
	      (WHEN SUPERSEDED-GENERIC
		;; The standardized name of the message generic has been changed
		(SETF (GENERIC-FUNCTION-FLAVORS GENERIC)
		      (UNION (GENERIC-FUNCTION-FLAVORS GENERIC)
			     (GENERIC-FUNCTION-FLAVORS SUPERSEDED-GENERIC)))
		;; Carry over some attributes from the message generic
		(WHEN (GENERIC-FUNCTION-METHODS-MADE SUPERSEDED-GENERIC)
		  (SETF (GENERIC-FUNCTION-METHODS-MADE GENERIC) T))
		;; Update any flavors and methods that know it
		(FLET ((UPDATEA (ALIST)
			 (DOLIST (ITEM ALIST)
			   (WHEN (EQ (FIRST ITEM) COMPATIBLE-MESSAGE)
			     (SETF (FIRST ITEM) NAME))))
		       (UPDATE (LIST)
			 (LOOP FOR L ON LIST DO
			   (WHEN (EQ (FIRST L) COMPATIBLE-MESSAGE)
			     (SETF (FIRST L) NAME)))))
		  (LOOP FOR FLAVOR IN (GENERIC-FUNCTION-ALL-FLAVORS SUPERSEDED-GENERIC NIL)
			AS FL = (FIND-FLAVOR FLAVOR) DO
		    (WHEN FL
		      (UPDATEA (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL))
		      (UPDATEA (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL))
		      (UPDATEA (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL))
		      (UPDATEA (FLAVOR-METHOD-TABLE FL))
		      ;;--- Next line is a bug, since the flavors we are updating are probably
		      ;;--- not the ones that have :REQUIRED-METHODS of this generic.
		      ;;--- GENERIC-FUNCTION-FLAVORS is the ones with methods.
		      ;;--- Should I create an additional list of genericflavor links?
		      (UPDATE (FLAVOR-REQUIRED-METHODS FL))
		      (UPDATE (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS FL))
		      (UPDATE (FLAVOR-LOCAL-METHOD-ORDER FL))
		      (UPDATEA (FLAVOR-LOCAL-METHOD-COMBINATION FL))
		      (DOLIST (METHOD-HOLDER (CDR (ASSOC NAME (FLAVOR-METHOD-TABLE FL))))
			;; Update the name of the method holder
			(SETF (METHOD-GENERIC (METHOD-HOLDER-FUNCTION-SPEC METHOD-HOLDER))
			      NAME)
			;; Update the name of the method (doesn't always share with above)
			(WHEN (METHOD-DEFINED-P METHOD-HOLDER)
			  (LET ((METHOD (METHOD-HOLDER-DEFINITION METHOD-HOLDER)))
			    (WHEN (COMPILED-FUNCTION-P METHOD)
			      (SETQ METHOD (COMPILED-FUNCTION-CCA METHOD))
			      (SETF (CAR (COMPILED-FUNCTION-EXTRA-INFO METHOD))
				    (METHOD-HOLDER-FUNCTION-SPEC METHOD-HOLDER))))))))))
	      (UNLESS (OR SUPERSEDED-GENERIC COMPILE-TIME)
		(WITHOUT-INTERRUPTS
		  (GENERIC-FUNCTION-COMPLETION COMPATIBLE-MESSAGE T))))
	    ;; This generic no longer has a compatible-message, remove the back-link
	    ;; It's impossible to unlink methods and flavors that used the message name
	    ;; in the source, too bad.
	    (REMPROP (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GENERIC) 'COMPATIBLE-GENERIC))
	(SETF (GENERIC-FUNCTION-HAS-COMPATIBLE-MESSAGE GENERIC) COMPATIBLE-MESSAGE)
	(SETQ SOMETHING-CHANGED T))
  
      ;; Backward link from compatible-message to compatible-generic
      (WHEN COMPATIBLE-MESSAGE
	(IF COMPILE-TIME
	    (SETF (GETDECL COMPATIBLE-MESSAGE 'COMPATIBLE-GENERIC) NAME)
	    (SETF (GET COMPATIBLE-MESSAGE 'COMPATIBLE-GENERIC) NAME)))
  
      ;; Selector for true generics is the generic itself, unless there is
      ;; a compatible message.  Selector for messages is the message itself.
      (SETF (GENERIC-FUNCTION-SELECTOR GENERIC)
	    (COND ((NOT MESSAGE-P) (OR COMPATIBLE-MESSAGE GENERIC))
		  ((SYMBOLP NAME) NAME)
		  (T GENERIC)))			;Lists can't be messages
  
      ;; Unless this is really a message, or there is an interface function,
      ;; this generic function becomes the fdefinition of its name.
      ;; Cannot call FDEFINE because it doesn't provide an argument to get the
      ;; particular combination of its many features that is needed, so be unmodular.
      (UNLESS (OR MESSAGE-P (NOT DEFINE-P))
	(COND (COMPILE-TIME
	       (COMPILER:FUNCTION-DEFINED NAME)
	       (COMPILER:NOTICE-COMPILED-FUNCTION NAME))
	      (T
	       (INSTALL-GENERIC-FUNCTION NAME GENERIC EXPLICIT T)))
  
	;; If this is a derived function, make it known to the compiler at compile time
	(WHEN (AND COMPILE-TIME (LISTP NAME))
	  (FUNCALL (GET (FIRST NAME) 'FUNCTION-SPEC-HANDLER) 'SI:COMPILER-FDEFINE
		   NAME GENERIC)))
  
      ;; Intern it
      (IF COMPILE-TIME
	  (SETF (GETDECL NAME 'GENERIC) GENERIC)
	  (SETF (SI:FUNCTION-SPEC-GET NAME 'GENERIC) GENERIC))
  
      ;; Record its existence
      (UNLESS COMPILE-TIME
	(WITHOUT-INTERRUPTS
	  (UNLESS (MEMBER NAME *ALL-GENERIC-FUNCTION-NAMES*)
	    (PUSH NAME *ALL-GENERIC-FUNCTION-NAMES* :LOCALIZE T :AREA *FLAVOR-AREA*)
	    (GENERIC-FUNCTION-COMPLETION NAME))))
  
      ;; Propagate any possible change to all flavors built on this
      (WHEN SOMETHING-CHANGED
	(UNLESS COMPILE-TIME			;Redundant test, keep it for clarity
	  (DOLIST (FLAVOR (GENERIC-FUNCTION-ALL-FLAVORS GENERIC))
	    (WHEN (FIND-FLAVOR FLAVOR NIL)
	      (RECOMPILE-FLAVOR FLAVOR :GENERIC NAME :DO-DEPENDENTS NIL)))))
  
      ;; Return the generic-function structure
      GENERIC)))

;;; Our private version of FDEFINE
(DEFUN INSTALL-GENERIC-FUNCTION (NAME GENERIC EXPLICIT SAVE-PREVIOUS-DEFINITION)
  ;; If there is a previous definition,
  ;; and if it is encapsulated, set INNER-SPEC to the symbol
  ;; which holds the real definition before encapsulation, and
  ;; save that definition.
  (LET ((FUNCTION-SPEC (IF (FDEFINEDP NAME)
			   (LET* ((INNER-SPEC (SI:UNENCAPSULATE-FUNCTION-SPEC NAME))
				  (OLD-SOURCE (SI:GET-SOURCE-FILE-NAME INNER-SPEC 'DEFUN)))
			     (WHEN (FDEFINEDP INNER-SPEC)
			       (UNLESS (EQ (FDEFINITION INNER-SPEC) GENERIC)
				 ;; We have a name conflict between a generic and a non
				 ;; generic.  If EXPLICIT, RECORD-SOURCE-FILE-NAME was
				 ;; already called and the user was already consulted.
				 ;; If not, don't redefine anything without authorization.
				 (WHEN SAVE-PREVIOUS-DEFINITION
				   (UNLESS (OR EXPLICIT (EQ INHIBIT-FDEFINE-WARNINGS T)
					       FS:THIS-IS-A-PATCH-FILE)
				     (IF (EQ INHIBIT-FDEFINE-WARNINGS ':JUST-WARN)
					 (WARN "~:[~;The CLOS generic function ~]~S is being implicitly redefined ~
					        as a Flavors generic function.~@[~@
						It was previously defined by the file ~A.~]~@
						If ~S is a primitive function, your world ~
						will probably no longer be usable.~@
						The old definition of ~S is being saved on ~
						its ~S property."
					       (CLOS-INTERNALS::GENERIC-FUNCTION-P
						 (FDEFINITION INNER-SPEC))
					       NAME OLD-SOURCE  NAME NAME :PREVIOUS-DEFINITION)
					 (UNLESS (YES-OR-NO-P "~:[~;The CLOS generic function ~]~S is being implicitly ~
							       redefined as a Flavors generic ~
							       function.~@[~@
							       It was previously defined ~
							       by the file ~A.~]~@
							       If you answer \"Yes\", ~S ~
							       will only accept instances ~
							       as its first argument;~@
							       if ~S is a primitive ~
							       function, your world will ~
							       probably no longer be usable.~@
							       ~2@TOkay to redefine ~S?  "
							      (CLOS-INTERNALS::GENERIC-FUNCTION-P
								(FDEFINITION INNER-SPEC))
							      NAME OLD-SOURCE NAME NAME NAME)
					   (WARN "The old definition of ~S remains in effect.~@
					          To redefine it so that you can perform ~
						  generic operations, do an explicit ~S.~@
						  Otherwise, you must perform generic ~
						  operations by (FUNCALL ~S ...)"
						 NAME `DEFGENERIC `(GENERIC ,NAME))
					   (RETURN-FROM INSTALL-GENERIC-FUNCTION NIL))))
				   (SETF (SI:FUNCTION-SPEC-GET NAME ':PREVIOUS-DEFINITION)
					 (FDEFINITION INNER-SPEC)))))
			     INNER-SPEC)
			   NAME)))
    ;; Do the FDEFINE, hacking storage category declarations.
    (SI:FDEFINE-INTERNAL FUNCTION-SPEC GENERIC)
    FUNCTION-SPEC))

(DEFUN GENERIC-FUNCTION-COMPLETION (GENERIC-FUNCTION-NAME &OPTIONAL RECURSIVE)
    (BOOTSTRAP-FLAVOR-NAMES-AARRAY)
    (LET ((SYMBOL (IF (SYMBOLP GENERIC-FUNCTION-NAME)
		      GENERIC-FUNCTION-NAME
		      (SECOND GENERIC-FUNCTION-NAME))))
      (SI:AARRAY-INSERT *ALL-GENERIC-FUNCTION-NAMES-AARRAY*
			(SYMBOL-NAME SYMBOL) SYMBOL 'ATOM))
    (UNLESS RECURSIVE
      (LET ((MESSAGE (GENERIC-FUNCTION-COMPATIBLE-MESSAGE
		       (FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME))))
	(WHEN MESSAGE
	  (GENERIC-FUNCTION-COMPLETION MESSAGE T)))))

;A list of the names of all flavors that have or inherit methods for this generic function
;and have had their methods composed.  These are the flavors that need updating if
;the generic function changes.
;With a second argument of NIL, include uncomposed flavors that have methods
(DEFUN GENERIC-FUNCTION-ALL-FLAVORS (GF &OPTIONAL (COMPOSED-ONLY T))
  (LET ((RESULT NIL))
    (DOLIST (FLAVOR (GENERIC-FUNCTION-FLAVORS GF))
      (UNLESS COMPOSED-ONLY
	(PUSHNEW FLAVOR RESULT))
      (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FL (FIND-FLAVOR FLAVOR))
	(WHEN (FLAVOR-METHODS-COMPOSED FL)
	  (PUSHNEW FLAVOR RESULT))))
    (NREVERSE RESULT)))				;Most basic flavors first

(DEFUN GENERIC-FUNCTION-METHODS (GENERIC &OPTIONAL ENV)
  (LOOP FOR FLAVOR IN (GENERIC-FUNCTION-FLAVORS (FIND-GENERIC-FUNCTION GENERIC T ENV))
	AS FL = (FIND-FLAVOR FLAVOR NIL) WITH TEM
	UNLESS (NULL FL)
	  APPEND
	  ;; Collect accessors
	    `(,@(AND (SETQ TEM (ASSOC GENERIC (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL)))
		     `((READ-INSTANCE-VARIABLE ,GENERIC ,FLAVOR ,(SECOND TEM))))
	      ,@(AND (SETQ TEM (ASSOC GENERIC (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL)))
		     `((WRITE-INSTANCE-VARIABLE ,GENERIC ,FLAVOR ,(SECOND TEM))))
	      ,@(AND (SETQ TEM (ASSOC GENERIC (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL)))
		     `((LOCATE-INSTANCE-VARIABLE ,GENERIC ,FLAVOR ,(SECOND TEM))))
	      ;; Collect real methods
	      ,@(LOOP FOR MH IN (CDR (ASSOC GENERIC (FLAVOR-METHOD-TABLE FL)))
		      AS METHOD = (METHOD-HOLDER-FUNCTION-SPEC MH)
		      UNLESS (EQ (METHOD-TYPE METHOD) 'COMBINED)
			COLLECT METHOD))))

(DEFUN BOOTSTRAP-GENERIC-FUNCTIONS ()
  (DOLIST (ARGS SI:*DEFGENERIC-COLD-FORMS*)
    (APPLY #'DEFGENERIC-INTERNAL ARGS)))

(ADD-INITIALIZATION "Bootstrap generic functions" '(BOOTSTRAP-GENERIC-FUNCTIONS) '(:ONCE))
