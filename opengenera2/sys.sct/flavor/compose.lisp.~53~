;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains routines for composition of the parts of a flavor into a whole.


;;;; Composing the component flavors to determine their order, the set
;;;; of instance variables and their order, and the set of local functions.

;;; ERROR-P false means print a warning and don't set FLAVOR-COMPONENTS-COMPOSED
;;;  if an error; true means go into the debugger if an error.
;;; Returns T if succeeded, NIL if failed
(DEFUN COMPOSE-FLAVOR-COMBINATION (FLAVOR-NAME &KEY (ENV NIL) (ERROR-P T))
  (STANDARDIZE-ENV ENV)
  ;; If this is the run-time environment, copy the information into *FLAVOR-AREA*
  ;; because it probably won't change, and compactify it, to speed things up.
  (FLET ((COPY (LIST)
	   (IF ENV LIST (COPY-LIST LIST *FLAVOR-AREA*))))
    ;; In the minimal case, DW updates might complete here.
    ;; Or our caller may take charge from us, if he provided a temporary environment.
    (WITH-PENDING-DW-UPDATES
      ;; Find and sort the component flavors
      (LET* ((FL (FIND-FLAVOR FLAVOR-NAME 'CREATE-IN-ENV ENV))
	     (ERROR NIL)
	     (COMPONENTS (COPY (CONDITION-BIND-IF (NOT ERROR-P)
				 ((COMPONENT-ORDERING-ERROR
				    #'(LAMBDA (CONDITION)
					(WHEN (MEMBER ':NO-ACTION
						      (SEND CONDITION :PROCEED-TYPES))
					  (LET ((FLAVORS (COMPONENTS-TO-BE-INSERTED-ARBITRARILY
							   CONDITION)))
					    (WARN "~A
  This error is being ignored and ~{~<~%  ~2:;~S~>~^, ~}
  ~:[is~;are~] being arbitrarily inserted into the component list without
  regard for component-order constraints."
						  CONDITION FLAVORS (CDR FLAVORS))
					    (SETQ ERROR T)
					    (SEND CONDITION :PROCEED :NO-ACTION))))))
				 (COMPOSE-FLAVOR-COMPONENTS FLAVOR-NAME ENV))))
	     (ADDITIONAL-FLAVORS NIL)
	     ALL-FLAVORS
	     (VARS NIL)
	     ;; Ordered instance variables can never go away within a bootload, because
	     ;; their offsets may have been encoded into methods by fixup-method.
	     ;; Also new ordered instance variables cannot be added once the flavor has
	     ;; been instantiated, because the instructions for accessing ordered instance
	     ;; variables do not check for structure-forwarding.  This is all invisible
	     ;; to the user, it only affects what instructions get used to access instance vars.
	     (ORDERED-VARS (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL))
	     (ORDERED-SOURCE NIL)
	     (REQUIRED-VARS NIL)
	     (LOCAL-FUNCTIONS NIL)
	     (LOCAL-FUNCTIONS-SEEN NIL)
	     TEM)
	;; Collect names of local functions (defun-in-flavor's) and local macros
	(FLET ((COLLECT-LOCAL-FUNCTIONS (FLAVOR-NAME FLAVOR)
		 (FLET ((ADD-LOCAL-FUNCTION (FUNCTION-SPEC MACRO FROM-FLAVOR)
			  (LET ((NAME (METHOD-GENERIC FUNCTION-SPEC)))
			    (COND ((ASSOC NAME LOCAL-FUNCTIONS)
				   (LET ((SHADOW (FIND NAME LOCAL-FUNCTIONS-SEEN
						       :KEY #'METHOD-GENERIC)))
				     (UNLESS (EQUAL SHADOW FUNCTION-SPEC)
				       ;; Warn about local-function shadowing, because people
				       ;; found it confusing and not useful.
				       (FLAVOR-ERROR FLAVOR-NAME NIL
"The local function ~S defined by flavor ~S is being
overridden by a definition of the same local function in flavor ~S.
This is not recommended, because the scoping of these names can be confusing."
						     NAME (METHOD-FLAVOR FUNCTION-SPEC)
						     (METHOD-FLAVOR SHADOW)))))
				  (T
				   ;; Add to LOCAL-FUNCTIONS, sharing interpreter definition
				   ;; cell if one exists (i.e. this is runtime).
				   (PUSH (OR (AND FROM-FLAVOR
						  (ASSOC NAME (FLAVOR-ALL-LOCAL-FUNCTIONS
							        FROM-FLAVOR)))
					     ;; Create an interpreter definition cell
					     (LIST-IN-AREA (FLAVOR-AREA ENV)
					       NAME
					       (OR MACRO
						   (LIST-IN-AREA (FLAVOR-AREA ENV)
						     'DEFUN-IN-FLAVOR
						     (METHOD-FLAVOR FUNCTION-SPEC)
						     (FDEFINITION-LOCATION FUNCTION-SPEC)))
							   FUNCTION-SPEC))
					 LOCAL-FUNCTIONS)
				   (PUSH FUNCTION-SPEC LOCAL-FUNCTIONS-SEEN))))))
		   (LET ((COMPILE-TIME-FUNCTIONS (AND (EQ ENV 'COMPILE)
						      (COMPILER:FILE-DECLARATION-ALIST
							FLAVOR-NAME 'KNOWN-LOCAL-FUNCTIONS))))
		     (LOOP FOR (FILE FUNCTIONS) IN COMPILE-TIME-FUNCTIONS DO
		       (IGNORE FILE)
		       (LOOP FOR (FUNCTION-SPEC MACRO) IN FUNCTIONS DO
			 (ADD-LOCAL-FUNCTION FUNCTION-SPEC MACRO NIL)))
		     (LET ((RUN-TIME-FL (IF (EQ ENV 'COMPILE) (FIND-FLAVOR FLAVOR-NAME NIL NIL)
					    FLAVOR)))
		       (WHEN RUN-TIME-FL
			 (DOLIST (METHOD-HOLDER (FLAVOR-LOCAL-FUNCTIONS RUN-TIME-FL))
			   (WHEN (METHOD-DEFINED-P METHOD-HOLDER)
			     (UNLESS (AND COMPILE-TIME-FUNCTIONS	;Speed/paging bum
					  ;; If file has been compiled ignore old loaded version
					  (ASSOC (METHOD-HOLDER-SOURCE-FILE-NAME METHOD-HOLDER)
						 COMPILE-TIME-FUNCTIONS))
			       (LET ((DEF (METHOD-HOLDER-DEFINITION METHOD-HOLDER)))
				 (ADD-LOCAL-FUNCTION (METHOD-HOLDER-FUNCTION-SPEC METHOD-HOLDER)
						     (AND (LISTP DEF) (EQ (FIRST DEF) 'SPECIAL)
							  DEF)
						     RUN-TIME-FL)))))))
		     ;; Do forward declarations after actual definitions, so they get shadowed
		     ;; if the thing has now been defined.  These declarations are not
		     ;; shadowed by COMPILE-TIME-FUNCTIONS, FLAVOR is already in ENV.
		     (DOLIST (NAME (FLAVOR-LOCAL-FUNCTIONS-FORWARD-REFERENCED FLAVOR))
		       (ADD-LOCAL-FUNCTION `(DEFUN-IN-FLAVOR ,NAME ,FLAVOR-NAME) NIL NIL))))))
	  ;; Map over the components in order and collect the instance variables
	  ;; in storage order.  Also store the indirect back-pointers.
	  (LOOP FOR F IN COMPONENTS AS FFL = (FIND-FLAVOR F NIL ENV) DO
	    (COND (FFL
		   (ADD-COMPOSED-DEPENDENT FL FFL ENV)
		   ;; Collect instance variables
		   ;; Least-specific components' variables end up at the end
		   (SETQ VARS (APPEND (FLAVOR-LOCAL-INSTANCE-VARIABLES FFL) VARS))
		   (SETQ REQUIRED-VARS (STABLE-UNION REQUIRED-VARS
						     (FLAVOR-REQUIRED-INSTANCE-VARIABLES FFL)))
		   (WHEN (SETQ TEM (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FFL))
		     ;; Merge into existing order requirement.  Shorter of the two must be
		     ;; a prefix of the longer, and we take the longer.
		     (LOOP FOR V1 IN ORDERED-VARS FOR V2 IN TEM FOR SLOT FROM 1 WITH N
			   UNLESS (EQ V1 V2) COLLECT (LIST V1 V2 SLOT) INTO ERRORS
			   FINALLY
			     (COND (ERRORS
				    (FLAVOR-ERROR FLAVOR-NAME ERROR-P
"Component flavor ~S specifies ordered instance variables that
conflict with ~:[assumptions already made in the current world~;those specified by ~:*~S~].
The ordered instance variable specification of ~2:*~S~* is being ignored.~
~:{~%~2@T~S and ~S are both trying to go into slot ~D~}"
						  F ORDERED-SOURCE ERRORS))
				   ((> (SETQ N (LIST-LENGTH TEM)) (LIST-LENGTH ORDERED-VARS))
				    ;; See if it is still possible to add ordered instance vars
				    (BLOCK EXIT-IF-INSTANTIATED
				      (DO-ALL-COMPOSED-DEPENDENTS (F FL FL ENV)
					(LET ((ORD (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL)))
					  (WHEN (AND (FLAVOR-INSTANTIATED FL)
						     (OR (> N (LIST-LENGTH ORD))
							 (MISMATCH TEM ORD :END2 N)))
					    (RETURN-FROM EXIT-IF-INSTANTIATED))))
				      ;; It is, do so
				      (SETQ ORDERED-VARS TEM
					    ORDERED-SOURCE F))))))

		   ;; Collect local functions and macros
		   (COLLECT-LOCAL-FUNCTIONS F FFL)

		   ;; Collect required-flavors
		   (SETQ ADDITIONAL-FLAVORS (UNION ADDITIONAL-FLAVORS
						   (SET-DIFFERENCE (FLAVOR-REQUIRED-FLAVORS FFL)
								   COMPONENTS))))
		  (T
		   (SETQ ERROR T)
		   (FLAVOR-ERROR FLAVOR-NAME ERROR-P
				 "The component flavor ~S has not been DEFFLAVORed." F))))
    
	  ;; Collect additional instance variables and local functions from required-flavors,
	  ;; components of required-flavors, and required-flavors of required-flavors.
	  ;; Order of processing flavors in this loop does not matter.
	  (SETQ ALL-FLAVORS COMPONENTS)
	  (LOOP WHILE ADDITIONAL-FLAVORS DO
	    (SETQ ALL-FLAVORS (UNION ALL-FLAVORS ADDITIONAL-FLAVORS))
	    (LOOP FOR F IN (PROG1 ADDITIONAL-FLAVORS (SETQ ADDITIONAL-FLAVORS NIL))
		  AS FFL = (FIND-FLAVOR F NIL ENV) DO
	      (COND (FFL
		     (ADD-COMPOSED-DEPENDENT FL FFL ENV)
		     (SETQ REQUIRED-VARS
			   (UNION REQUIRED-VARS
				  (SET-DIFFERENCE
				    (UNION (FLAVOR-LOCAL-INSTANCE-VARIABLES FFL)
					   (FLAVOR-REQUIRED-INSTANCE-VARIABLES FFL))
				    VARS)))
		     (COLLECT-LOCAL-FUNCTIONS F FFL)
		     (SETQ ADDITIONAL-FLAVORS
			   (UNION ADDITIONAL-FLAVORS
				  (SET-DIFFERENCE (UNION (FLAVOR-LOCAL-COMPONENTS FFL)
							 (FLAVOR-REQUIRED-FLAVORS FFL))
						  ALL-FLAVORS))))
		    (T
		     (SETQ ERROR T)
		     (FLAVOR-ERROR FLAVOR-NAME ERROR-P
				   "The required flavor ~S has not been DEFFLAVORed." F))))))
  
	(WHEN (NULL ENV)
	  ;; Remove obsolete composed-dependent links, from both Flavors and DW handler tables
	  (DOLIST (F (SET-DIFFERENCE (FLAVOR-ALL-COMPONENTS FL) COMPONENTS))
	    (LET ((FFL (FIND-FLAVOR F NIL ENV)))
	      (WHEN FFL
		(REMOVE-COMPOSED-DEPENDENT FL FFL))))
  
	  ;; Tell the DW handler table that this flavor's supertypes are changing
	  (NOTE-CHANGE-FOR-DW FLAVOR-NAME))

	;; Stash results
	(SETF (FLAVOR-ALL-COMPONENTS FL) (COPY COMPONENTS))
	(SETQ VARS (DELETE-DUPLICATES VARS :FROM-END T))	;move duplicates to leftmost position
	(SETF (FLAVOR-ALL-INSTANCE-VARIABLES FL)
	      (COPY (APPEND ORDERED-VARS (SET-DIFFERENCE VARS ORDERED-VARS))))
						;Note reliance on order stability of SET-DIFFERENCE to get
						;VARS into the order we expect (least-specific flavors' vars first)
	(SETF (FLAVOR-ADDITIONAL-INSTANCE-VARIABLES FL)
	      (COPY (SET-DIFFERENCE REQUIRED-VARS VARS)))
	(SETF (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL) (COPY ORDERED-VARS))
	(SETF (FLAVOR-ORDERED-INSTANCE-VARIABLES-COMPOSED FL) T)
	(SETF (FLAVOR-ALL-LOCAL-FUNCTIONS FL) (COPY LOCAL-FUNCTIONS))
	;; If this flavor has been committed to a particular order of instance variables,
	;; that commitment applies to its components as well, since methods on the components
	;; can only assume the instance variable order common to all dependent flavors.
	;; In other words, a flavor's all-ordered-instance-variables must be a prefix
	;; of the all-ordered-instance-variables of each of its dependents.
	(WHEN ORDERED-VARS
	  (DOLIST (FL COMPONENTS)
	    (SETQ FL (FIND-FLAVOR FL T ENV))
	    (UNLESS (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL)
	      (LET* ((ORD (FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL))
		     (N (AND ORD (MISMATCH ORD ORDERED-VARS))))
		(WHEN N (SETQ ORD (SUBSEQ ORD 0 N)))	;ORD is now the common prefix
		(WHEN ORD
		  (SETF (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL) (COPY ORD)))))))
	(UNLESS ERROR
	  (SETF (FLAVOR-COMPONENTS-COMPOSED FL) T))
	(NOT ERROR)))))

;;; "In order to form a more perfect union...."
;;; Similar to normal UNION, but guaranteed to preserve the order of elements
(DEFUN STABLE-UNION (SET1 SET2)
  (LET ((LENGTH1 (LENGTH SET1))
	(LENGTH2 (LOOP FOR ITEM IN SET2 COUNT (NOT (MEMBER ITEM SET1)))))
    (IF (ZEROP LENGTH2)
	SET1
	(LET* ((RESULT (MAKE-LIST (+ LENGTH1 LENGTH2)))
	       (L RESULT))
	  (LOOP FOR ITEM IN SET1 DO
	    (SETF (CAR L) ITEM)
	    (SETQ L (CDR L)))
	  (LOOP FOR ITEM IN SET2 DO
	    (UNLESS (MEMBER ITEM SET1)
	      (SETF (CAR L) ITEM)
	      (SETQ L (CDR L))))
	  RESULT))))

;;;; Internal routines that compute the proper order of component flavors

;;; Iteration driver and vanilla flavor inserter
;;; This calls FUNCTION for each component of FLAVOR-NAME at least once.  The arguments
;;; to FUNCTION are the name of the component flavor, the depth of recursion, a list
;;; of the names of all flavors that must locally precede this one (-not- a transitive
;;; closure of the precedence relations!), and a flag that is true if this component flavor
;;; is known to be a real component (not one derived from a precedence relation that
;;; doesn't really apply to the current mixture).
;;; As a special kludge, the third argument is the symbol VANILLA if this is VANILLA and
;;; it is being made a component automatically rather than by explicit inclusion.
;;; If FUNCTION returns NIL, iteration terminates without looking at components to right.
;;; If FUNCTION returns DONT-RECURSE, do younger brothers but not sons.
;;; Undefined components do not cause an error unless FUNCTION does not like them.
;;; The values returned by MAP-COMPONENTS-DEPTH-FIRST are meaningless to the outside caller.
(DEFUN MAP-COMPONENTS-DEPTH-FIRST (FUNCTION FLAVOR-NAME
				   &OPTIONAL (ENV NIL) (DEPTH 0) (PRECEDENCE NIL) (REAL T)
					     (TRAIL NIL))
  (DECLARE (DOWNWARD-FUNARG FUNCTION))
  (DECLARE (VALUES NO-VANILLA CONTINUE))
  (LET ((CONTINUE (FUNCALL FUNCTION FLAVOR-NAME DEPTH PRECEDENCE REAL))
	(NO-VANILLA (EQ FLAVOR-NAME 'VANILLA))
	(FL (FIND-FLAVOR FLAVOR-NAME NIL ENV)))
    (WHEN FL
      (WHEN (FLAVOR-WITHOUT-VANILLA FL)
	(SETQ NO-VANILLA T))
      (UNLESS (OR (MEMBER CONTINUE '(NIL DONT-RECURSE))
		  (MEMBER FLAVOR-NAME TRAIL))	;Break infinite recursion
	(STACK-LET ((TRAIL (CONS FLAVOR-NAME TRAIL)))
	  (LOOP FOR COMPONENTS IN (FLAVOR-LOCAL-COMPONENT-PRECEDENCE FL) DO
	    ;; Use recursion to iterate backwards through list
	    (BLOCK RECURSE
	      (LABELS ((ITERATE (COMPONENTS)
			 (WHEN COMPONENTS
			   (LET ((COMPONENT (CAR COMPONENTS)))
			     (UNLESS (EQ COMPONENT FLAVOR-NAME)
			       (ITERATE (CDR COMPONENTS))
			       (MULTIPLE-VALUE-BIND (NO-VANILLA-1 CONTINUE-1)
				   (MAP-COMPONENTS-DEPTH-FIRST FUNCTION COMPONENT ENV
				     (1+ DEPTH) (CDR COMPONENTS)
				     (AND REAL
					  (MEMBER COMPONENT (FLAVOR-LOCAL-COMPONENTS FL)))
				     TRAIL)
				 (WHEN NO-VANILLA-1
				   (SETQ NO-VANILLA T))
				 (UNLESS CONTINUE-1
				   (RETURN-FROM RECURSE))))))))
		(ITERATE COMPONENTS)))))
	(WHEN (= DEPTH 0)
	  (UNLESS NO-VANILLA
	    ;; Vanilla is inserted as last component of top-level flavor
	    (FUNCALL FUNCTION 'VANILLA 1 'VANILLA T)))))
    (VALUES NO-VANILLA CONTINUE)))

;;; Make alist from component flavor to the components that must be to its left
;;; due to local constraints.  This is -not- the transitive closure of
;;; FLAVOR-LOCAL-COMPONENT-PRECEDENCE, but only the union of it; it's necessary
;;; not to compute the transitive closure here in order for the error reporting
;;; to be able to find cyclic constraints.
(DEFUN MAKE-PRECEDENCE-ALIST (FLAVOR-NAME ENV)
  (LET ((ALIST NIL)
	(REAL-COMPONENTS NIL))
    (MAP-COMPONENTS-DEPTH-FIRST #'(LAMBDA (FLAVOR-NAME DEPTH PRECEDENCE REAL)
				    (IGNORE DEPTH)
				    ;; Vanilla flavor should always be the last component
				    (WHEN (EQ PRECEDENCE 'VANILLA)
				      (SETQ PRECEDENCE (MAPCAR #'CAR ALIST)))
				    ;; Construct the union of everything preceding this flavor
				    (LET ((ELEM (ASSOC FLAVOR-NAME ALIST)))
				      (IF ELEM
					  (SETF (CDR ELEM) (UNION (CDR ELEM) PRECEDENCE))
					  (PUSH (CONS FLAVOR-NAME PRECEDENCE) ALIST)))
				    ;; Remember which components were real
				    (WHEN REAL
				      (PUSHNEW FLAVOR-NAME REAL-COMPONENTS))
				    T)
				FLAVOR-NAME ENV)
    (DOLIST (ELEM ALIST)			;Delete components that aren't real
      (IF (MEMBER (CAR ELEM) REAL-COMPONENTS)
	  (SETF (CDR ELEM) (REMOVE-IF-NOT #'(LAMBDA (COMPONENT)
					      (MEMBER COMPONENT REAL-COMPONENTS))
					  (CDR ELEM)))
	  (SETQ ALIST (DELETE ELEM ALIST))))
    (NREVERSE ALIST)))

;;; Compute the FLAVOR-ALL-COMPONENTS list, in the appropriate order.
;;; Check for and explain circular dependencies.
;;; Missing required-flavors and undefined component flavors are detected elsewhere.
(DEFUN COMPOSE-FLAVOR-COMPONENTS (FLAVOR-NAME &OPTIONAL ENV)
  ;; First combine all the local ordering constraints.
  (LET ((ALIST (MAKE-PRECEDENCE-ALIST FLAVOR-NAME ENV))
	(COMPONENTS NIL))
    ;; Start with a null components list; the given flavor will always be the first
    ;; component, because it will be the first one encountered by MAP-COMPONENTS-DEPTH-FIRST.
    ;; If there are circular constraints such that the given flavor has to have something
    ;; to its left, this will be detected, because no other flavor is unconstrained.
    ;; Using the local ordering constraints, build an ordered list of components by
    ;; repeated depth-first tree walk until all components have been incorporated that can be.
    ;; The tree walk is done in such an order as to minimize the number of iterations
    ;; through this loop required to come up with the answer.
    ;; SLOW = NIL is an optimization to cut off probably unreachable branches of the tree.
    (LOOP AS CHANGED = NIL WITH SLOW = NIL DO
      (MAP-COMPONENTS-DEPTH-FIRST
	#'(LAMBDA (FLAVOR-NAME IGNORE IGNORE IGNORE)
	    (COND ((MEMBER FLAVOR-NAME COMPONENTS) T)	;Already a component, continue
		  ((NOT (ASSOC FLAVOR-NAME ALIST)) 'DONT-RECURSE)  ;Not really a component
		  ((LOOP FOR PREDECESSOR IN (CDR (ASSOC FLAVOR-NAME ALIST))
			 ALWAYS (MEMBER PREDECESSOR COMPONENTS))
		   ;; This one can go in now, put it in and return T.
		   (PUSH FLAVOR-NAME COMPONENTS)
		   (SETQ CHANGED T))
		  ;; If above LOOP fails, return NIL since everything to right will fail too.
		  ;; But in SLOW mode, disable that optimization.
		  (T SLOW)))
	FLAVOR-NAME ENV)
      (WHEN (NOT CHANGED)
	;; We seem to be done; make sure all components really got incorporated.
	(WHEN (= (LENGTH COMPONENTS) (LENGTH ALIST))
	  (RETURN))
	;; Some components didn't get incorporated.  Either there is an ordering
	;; conflict, or the speedup didn't work.  The speedup fails after recovery
	;; from a conflict, because the constraints are no longer transitive.  It
	;; also fails in the face of partial ordering among the components of a flavor.
	(IF SLOW
	    ;; Already slow: there must be an ordering conflict.
	    ;; Explain it nicely and recover by making an arbitrary choice.
	    (SETQ COMPONENTS (NRECONC (EXPLAIN-COMPONENT-ORDERING-ERROR FLAVOR-NAME ALIST
									COMPONENTS ENV)
				      COMPONENTS))
	    ;; Try again without the speedup.
	    (SETQ SLOW T))))
    ;; Put list of components into normal order
    (NREVERSE COMPONENTS)))

;;;; Composing the ordered-instance-variables alone

;;; This is considered less expensive, and leaves less data structure consed up,
;;; than COMPOSE-FLAVOR-COMBINATION, in the common case where there are no ordered
;;; instance variables.
(DEFUN COMPOSE-ORDERED-INSTANCE-VARIABLES (FLAVOR-NAME)
  ;; Batch up the DW updates this may incur.  (This should only be an optimization).
  (WITH-PENDING-DW-UPDATES
    (MAP-COMPONENTS-DEPTH-FIRST
      #'(LAMBDA (COMPONENT IGNORE IGNORE REAL)
	  (LET ((FL (FIND-FLAVOR COMPONENT NIL)))
	    (COND ((NOT REAL))
		  ((NULL FL)
		   ;; Do not warn about undefined components, because that causes bootstrapping
		   ;; problems during world building, because methods are often loaded before
		   ;; all components of their flavor have been defined, and because the maximum
		   ;; bad effect is only to use a mapping table where a more optimum addressing
		   ;; mechanism could have been used.
		   )
		  ((FLAVOR-LOCAL-ORDERED-INSTANCE-VARIABLES FL)
		   (RETURN-FROM COMPOSE-ORDERED-INSTANCE-VARIABLES
		     (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ERROR-P NIL))))
	    T))
      FLAVOR-NAME)
    ;; No ORDERED-INSTANCE-VARIABLES found in any component
    (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
      (SETF (FLAVOR-ALL-ORDERED-INSTANCE-VARIABLES FL) NIL)
      (SETF (FLAVOR-ORDERED-INSTANCE-VARIABLES-COMPOSED FL) T))))

;;;; Composing the methods of the component flavors to produce the handlers

;;; Combine inherited methods and construct the handler table.
;;; This function gets called when a handler table is needed and again when a
;;; new method is added or an existing method is removed.
;;; Specify GENERIC to do this for just one generic operation, for incremental update.
;;; ERROR-P is T to signal errors, NIL to print warnings.
(DEFUN COMPOSE-METHOD-COMBINATION (FLAVOR-NAME &REST OPTIONS
				   &KEY GENERIC ENV &ALLOW-OTHER-KEYS)
  (DECLARE (ARGLIST FLAVOR-NAME &KEY GENERIC ENV IGNORE-EXISTING-METHODS (ERROR-P T)))
  ;; Get the list of function-specs of handlers, combined-method definitions, and incidentals
  (MULTIPLE-VALUE-BIND (HANDLERS DEFUNS METHOD-ORDER DEFAULT-HANDLER)
      (APPLY #'COLLECT-COMBINED-METHODS FLAVOR-NAME OPTIONS)
    ;; Compile the combined methods into the run-time environment
    (COMPILE-FUNCTION-LIST DEFUNS)
    ;; Store the handlers where they belong
    (LET ((FL (FIND-FLAVOR FLAVOR-NAME T ENV)))
      (COND ((FLAVOR-IS-ABSTRACT FL)
	     ;; Abstract flavors don't get instantiated, hence never have handler tables
	     NIL)
	    (GENERIC
	     ;; Add or remove a single handler in the hash table, if the table exists
	     (WHEN (FLAVOR-HANDLER-TABLE FL)
	       (LET* ((HANDLER (FIRST HANDLERS))
		      (GF (FIND-GENERIC-FUNCTION GENERIC))
		      (SELECTOR (GENERIC-FUNCTION-SELECTOR GF))
		      (MESSAGE (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF)))
		 (COND (HANDLER
			;; Add an entry to the handler table
			(MULTIPLE-VALUE-BIND (FUNCTION MAPPING-TABLE)
			    (HANDLER-DEFINITION HANDLER FL)
			  (INSERT-IN-HANDLER-TABLE FL SELECTOR FUNCTION MAPPING-TABLE))
			;; Add to the list of all supported operations
			(WHEN MESSAGE
			  (PUSHNEW MESSAGE (FLAVOR-ALL-GENERICS FL)
				   :AREA *FLAVOR-AREA* :LOCALIZE T))
			(PUSHNEW (GENERIC-FUNCTION-NAME GF) (FLAVOR-ALL-GENERICS FL)
				 :AREA *FLAVOR-AREA* :LOCALIZE T))
		       (T
			;; Remove an entry from the handler table
			(INSERT-IN-HANDLER-TABLE FL SELECTOR NIL NIL)
			(SETF (FLAVOR-ALL-GENERICS FL)
			      (REMOVE (GENERIC-FUNCTION-NAME GF)
				      (IF MESSAGE (REMOVE MESSAGE (FLAVOR-ALL-GENERICS FL))
					  (FLAVOR-ALL-GENERICS FL)))))))))
	    (T
	     ;; Create or massively update the hash table of handlers
	     ;; Put the handlers into the declared order
	     (WHEN METHOD-ORDER
	       (SETQ HANDLERS (SORT HANDLERS
				    #'(LAMBDA (X Y)
					(IF (MEMBER Y METHOD-ORDER)
					    (MEMBER Y (CDR (MEMBER X METHOD-ORDER)))
					    (MEMBER X METHOD-ORDER)))
				    :KEY #'METHOD-GENERIC)))
	     ;; Make a new handler table containing all the handlers
	     (LET ((HT (MAKE-HANDLER-TABLE (LENGTH HANDLERS) METHOD-ORDER DEFAULT-HANDLER)))
	       ;; Inhibit Flips -- See comment by INSERT-DIRECTLY-IN-HANDLER-TABLE.
	       (SI:INHIBIT-GC-FLIPS
		 (DOLIST (HANDLER HANDLERS)
		   (LET ((SELECTOR (GENERIC-FUNCTION-SELECTOR (FIND-GENERIC-FUNCTION
								(METHOD-GENERIC HANDLER)))))
		     (MULTIPLE-VALUE-BIND (FUNCTION MAPPING-TABLE)
			 (HANDLER-DEFINITION HANDLER FL)
		       (SETQ HT (INSERT-DIRECTLY-IN-HANDLER-TABLE HT SELECTOR
				FUNCTION MAPPING-TABLE)))))
		 ;; Now that the handler table is valid, install it
		 (INSTALL-HANDLER-TABLE FL HT)))
	     ;; Maintain the list of all supported operations
	     (SETF (FLAVOR-ALL-GENERICS FL)
		   (COPY-LIST (LOOP FOR HANDLER IN HANDLERS
				    AS GENERIC = (METHOD-GENERIC HANDLER)
				    COLLECT GENERIC
				    WHEN (GENERIC-FUNCTION-COMPATIBLE-MESSAGE
					   (FIND-GENERIC-FUNCTION GENERIC))
				      COLLECT IT)
			      *FLAVOR-AREA*))
	     ;; Flag that this has been done
	     (SETF (FLAVOR-METHODS-COMPOSED FL) T)))
      NIL)))

;;; What should be the value of FLAVOR-ALL-GENERICS (useful if methods have not been composed)
(DEFUN COMPOSE-FLAVOR-ALL-GENERICS (FLAVOR-NAME &KEY ENV (ERROR-P T))
  (LOOP FOR (GF METHOD-COMBINATION . METHODS)
	    IN (FLAVOR::COLLECT-METHODS FLAVOR-NAME :ENV ENV :ERROR-P ERROR-P)
	WITH RESULT = NIL
	FINALLY (RETURN RESULT) DO
    (IGNORE METHOD-COMBINATION)
    (WHEN (COND ((LOOP FOR METHOD IN METHODS
		       ALWAYS (EQ (FLAVOR:METHOD-TYPE METHOD) 'FLAVOR:COMBINED))
		 NIL)				;All real methods have been deleted
		((NOT (FLAVOR::GENERIC-FUNCTION-SOLITARY GF))
		 T)				;Normal case
		((AND (= (LENGTH METHODS) 1)
		      (EQUAL (FLAVOR::GENERIC-FUNCTION-SOLITARY-METHOD GF)
			     (FIRST METHODS)))
		 ;; The only method is a solitary method, so we don't need
		 ;; an entry in the handler table.  Instead, the dispatching
		 ;; will be done by the trampoline function.
		 NIL)
		(T
		 ;; Originally there was a solitary method, but now there are
		 ;; other methods, so we must switch to using the handler table.
		 T))
      (LET ((MESSAGE (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF)))
	(WHEN MESSAGE
	  (PUSH MESSAGE RESULT)))
      (PUSH (GENERIC-FUNCTION-NAME GF) RESULT))))

(DEFUN COMPILE-FUNCTION-LIST (FORMS)
  ;; Compile some functions into the current environment
  ;; Ignore any incidental compilation now in progress
  (LET ((FILE-LOCAL-DECLARATIONS NIL)
	(INHIBIT-FDEFINE-WARNINGS T)		;Don't care what file it's in
	(FDEFINE-FILE-PATHNAME NIL))		;Don't bother recording this
    (IF (NOT (VARIABLE-BOUNDP #'COMPILE))
	;; No compiler loaded yet, so limp along with the interpreter
	(MAPC #'EVAL FORMS)
	(COMPILER:COMPILE-FORMS FORMS))))

;;; Collect the handlers and the definitions of the combined methods
(DEFUN COLLECT-COMBINED-METHODS (FLAVOR-NAME &KEY GENERIC ENV IGNORE-EXISTING-METHODS
						  (ERROR-P T))
  (DECLARE (VALUES FUNCTION-SPECS DEFUNS METHOD-ORDER DEFAULT-HANDLER))
  (LET ((FUNCTION-SPECS NIL)
	(DEFUNS NIL)
	METHOD-ORDER DEFAULT-HANDLER)
    (LOOP FOR (GF METHOD-COMBINATION . METHODS) IN (COLLECT-METHODS FLAVOR-NAME
								    :GENERIC GENERIC
								    :ENV ENV
								    :ERROR-P ERROR-P) DO
      (WHEN (COND ((LOOP FOR METHOD IN METHODS
			 ALWAYS (EQ (METHOD-TYPE METHOD) 'COMBINED))
		   NIL)				;All real methods have been deleted
		  ((NOT (GENERIC-FUNCTION-SOLITARY GF))
		   T)				;Normal case
		  ((EQ ENV 'COMPILE)
		   NIL)				;At compile time, assume still solitary
		  ((AND (= (LENGTH METHODS) 1)
			(EQUAL (GENERIC-FUNCTION-SOLITARY-METHOD GF) (FIRST METHODS)))
		   ;; The only method is a solitary method, so we don't need
		   ;; an entry in the handler table.  Instead, the dispatching
		   ;; will be done by the trampoline function.
		   NIL)
		  (T
		   ;; Originally there was a solitary method, but now there are
		   ;; other methods, so we must switch to using the handler table.
		   (REMOVE-SOLITARY-METHOD GF)
		   T))
	;; A handler for this generic function really is required
	(CONDITION-BIND-IF (NOT ERROR-P)
			   ((METHOD-COMBINATION-ERROR 'WARN-ABOUT-METHOD-COMBINATION-ERROR))
	  (MULTIPLE-VALUE-BIND (FUNCTION-SPEC DEFUN)
	      (MAKE-COMBINED-METHOD (GENERIC-FUNCTION-NAME GF) FLAVOR-NAME
				    METHOD-COMBINATION METHODS
				    ENV IGNORE-EXISTING-METHODS)
	    (PUSH FUNCTION-SPEC FUNCTION-SPECS)
	    (WHEN DEFUN
	      ;; The handler is a combined method, queue its definition for compilation
	      (PUSH DEFUN DEFUNS))))))
    (UNLESS GENERIC				;If doing whole wazoo
      (MULTIPLE-VALUE-SETQ (METHOD-ORDER DEFAULT-HANDLER)
	(CHECK-FLAVOR-REQUIREMENTS FLAVOR-NAME FUNCTION-SPECS ENV ERROR-P)))
    (VALUES FUNCTION-SPECS DEFUNS METHOD-ORDER DEFAULT-HANDLER)))

;;; Check for missing required- this-and-that, collect the method-order & default-handler
(DEFUN CHECK-FLAVOR-REQUIREMENTS (FLAVOR-NAME HANDLERS ENV ERROR-P)
  (DECLARE (VALUES METHOD-ORDER DEFAULT-HANDLER))
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME T ENV))
	(METHOD-ORDER NIL)
	(DEFAULT-HANDLER NIL)
	(MISSING-METHODS NIL)
	(MISSING-INSTANCE-VARIABLES NIL)
	(MISSING-FLAVORS NIL)
	FFL ORD)
    (DOLIST (COMPONENT (FLAVOR-ALL-COMPONENTS FL))
      ;; If ERROR-P is NIL, ignore component flavors that are not defined
      ;; A warning about them should already have been issued by compose-flavor-combination
      (WHEN (SETQ FFL (FIND-FLAVOR COMPONENT ERROR-P ENV))
	(UNLESS (FLAVOR-IS-ABSTRACT FL)
	  (DOLIST (REQM (FLAVOR-REQUIRED-METHODS FFL))
	    (UNLESS (FIND REQM HANDLERS :KEY #'METHOD-GENERIC)
	      (LET ((ASSOC (ASSOC REQM MISSING-METHODS)))
		(IF ASSOC
		    (PUSH COMPONENT (CDR ASSOC))
		    (PUSH (LIST REQM COMPONENT) MISSING-METHODS)))))
	  (DOLIST (REQV (FLAVOR-REQUIRED-INSTANCE-VARIABLES FFL))
	    (UNLESS (MEMBER REQV (FLAVOR-ALL-INSTANCE-VARIABLES FL))
	      (LET ((ASSOC (ASSOC REQV MISSING-INSTANCE-VARIABLES)))
		(IF ASSOC
		    (PUSH COMPONENT (CDR ASSOC))
		    (PUSH (LIST REQV COMPONENT) MISSING-INSTANCE-VARIABLES)))))
	  (DOLIST (REQF (FLAVOR-REQUIRED-FLAVORS FFL))
	    (UNLESS (MEMBER REQF (FLAVOR-ALL-COMPONENTS FL))
	      (LET ((ASSOC (ASSOC REQF MISSING-FLAVORS)))
		(IF ASSOC
		    (PUSH COMPONENT (CDR ASSOC))
		    (PUSH (LIST REQF COMPONENT) MISSING-FLAVORS))))))
	(WHEN (SETQ ORD (FLAVOR-LOCAL-METHOD-ORDER FFL))
	  (SETQ METHOD-ORDER (NCONC METHOD-ORDER (COPY-LIST ORD))))
	(UNLESS DEFAULT-HANDLER
	  (SETQ DEFAULT-HANDLER (FLAVOR-LOCAL-DEFAULT-HANDLER FFL)))))
    (WHEN (OR MISSING-INSTANCE-VARIABLES MISSING-METHODS MISSING-FLAVORS)
      (SETQ MISSING-INSTANCE-VARIABLES (SORT MISSING-INSTANCE-VARIABLES #'STRING-LESSP
					     :KEY #'CAR)
	    MISSING-METHODS (SORT MISSING-METHODS #'ALPHALESSP :KEY #'CAR)
	    MISSING-FLAVORS (SORT MISSING-FLAVORS #'STRING-LESSP :KEY #'CAR))
      (FLAVOR-ERROR FLAVOR-NAME ERROR-P
		    "~Q" (LAMBDA ()		;Too difficult to write in FORMAT language
			   (FLET ((SHOW (TITLE LIST MORE)
				    (WHEN LIST
				      (FORMAT T "Missing ~A~P " TITLE (LENGTH LIST))
				      (FORMAT-TEXTUAL-LIST
					LIST
					(LAMBDA (ELEM STREAM)
					  (FORMAT STREAM "~S (required by " (CAR ELEM))
					  (FORMAT-TEXTUAL-LIST (CDR ELEM) #'PRIN1
							       :STREAM STREAM
							       :CONJUNCTION "and")
					  (WRITE-CHAR #\) STREAM))
					:FILLED T	;---bug? doesn't seem to fill anyway
					:AFTER-LINE-BREAK "    ")
				      (WHEN MORE (TERPRI)))))
			     (SHOW "component flavor" MISSING-FLAVORS
				   (OR MISSING-INSTANCE-VARIABLES MISSING-METHODS))
			     (SHOW "instance variable" MISSING-INSTANCE-VARIABLES
				   MISSING-METHODS)
			     (SHOW "method" MISSING-METHODS NIL)))))
    (VALUES METHOD-ORDER DEFAULT-HANDLER)))

;;; Compute an alist ((generic-function method-combination function-spec function-spec...)...)
;;; of methods defined on or inherited by a flavor.  Within each alist element,
;;; generic-function is an object (not a name), method-combination is a list of type
;;; and parameters, and function-specs are listed in base-flavor-first order.
;;; Each function-spec can be a method, wrapper, accessor, combined-method, etc.
;;;	:COMPONENTS -- If non-NIL, list of flavors to get methods from
;;;	:GENERIC -- if non-NIL, include only methods for that generic function
;;;	:ENV -- environment (see comment on FIND-FLAVOR)
;;;	:MUST-BE-DEFINED -- True  ignore undefined methods (ignored if ENV = COMPILE)
(DEFUN COLLECT-METHODS (FLAVOR-NAME &KEY COMPONENTS GENERIC
					 ENV (MUST-BE-DEFINED T) (ERROR-P T))
  (WHEN GENERIC
    (SETQ GENERIC (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV)))
  (STANDARDIZE-ENV ENV)
  (LET ((ALIST NIL)
	(SPECIAL-INSTANCE-VARIABLES NIL)
	(SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS NIL))
    (LABELS ((COLLECT-FROM (FLAVOR-NAME)
	       (LET* ((FL (FIND-FLAVOR FLAVOR-NAME NIL ENV))
		      (RUN-TIME-FL (IF (EQ ENV 'COMPILE) (FIND-FLAVOR FLAVOR-NAME NIL NIL)
				       FL))
		      (COMPILE-TIME-METHODS
			(AND (EQ ENV 'COMPILE)
			     (COMPILER:FILE-DECLARATION-ALIST FLAVOR-NAME 'KNOWN-METHODS)))
		      (RUN-TIME-METHODS
			(AND RUN-TIME-FL (FLAVOR-METHOD-TABLE RUN-TIME-FL)))
		      (HYPOTHETICAL-METHODS
			(AND (CONSP ENV) (CDDDR (ASSOC FLAVOR-NAME ENV)))))
		 (LOOP FOR (FILE METHODS) IN COMPILE-TIME-METHODS DO
		   (IGNORE FILE)
		   (LOOP FOR FUNCTION-SPEC IN METHODS DO
		     (ADD-METHOD FUNCTION-SPEC)))
		 (LOOP FOR (FUNCTION-SPEC DEFINITION) IN HYPOTHETICAL-METHODS DO
		   (WHEN DEFINITION
		     (ADD-METHOD FUNCTION-SPEC)))
		 (LOOP FOR (GEN . METHOD-HOLDERS) IN RUN-TIME-METHODS DO
		   (UNLESS (AND GENERIC (NEQ GEN GENERIC))	;speed bum
		     ;; Don't let generics superseded by :COMPATIBLE-MESSAGE leak through
		     ;; from the run-time environment into the compile-time environment.
		     (UNLESS (AND (SYMBOLP GEN)
				  (EQ ENV 'COMPILE)
				  (COMPILER:FILE-DECLARATION GEN 'COMPATIBLE-GENERIC))
		       (DOLIST (METHOD-HOLDER METHOD-HOLDERS)
			 (UNLESS (AND COMPILE-TIME-METHODS	;Speed/paging bum
				      ;; If file has been compiled, ignore loaded version
				      (ASSOC (METHOD-HOLDER-SOURCE-FILE-NAME METHOD-HOLDER)
					     COMPILE-TIME-METHODS))
			   (LET ((FUNCTION-SPEC (METHOD-HOLDER-FUNCTION-SPEC METHOD-HOLDER)))
			     (UNLESS (ASSOC FUNCTION-SPEC HYPOTHETICAL-METHODS :TEST #'EQUAL)
			       (UNLESS (AND MUST-BE-DEFINED
					    (NOT (METHOD-DEFINED-P METHOD-HOLDER)))
				 (ADD-METHOD FUNCTION-SPEC)))))))))
		 (WHEN FL
		   (DOLIST (X (FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FL))
		     (ADD-METHOD `(READ-INSTANCE-VARIABLE ,(FIRST X) ,FLAVOR-NAME
							  ,(SECOND X))))
		   (DOLIST (X (FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FL))
		     (ADD-METHOD `(WRITE-INSTANCE-VARIABLE ,(FIRST X) ,FLAVOR-NAME
							   ,(SECOND X))))
		   (DOLIST (X (FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FL))
		     (ADD-METHOD `(LOCATE-INSTANCE-VARIABLE ,(FIRST X) ,FLAVOR-NAME
							    ,(SECOND X))))
		   (SETQ SPECIAL-INSTANCE-VARIABLES
			   (UNION (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLES FL)
				  SPECIAL-INSTANCE-VARIABLES)
			 SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS
			   (UNION (FLAVOR-LOCAL-SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS FL)
				  SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS)))))
	     ;; Add this method to ALIST in the appropriate place
	     (ADD-METHOD (FUNCTION-SPEC)
	       (LET ((GEN (METHOD-GENERIC FUNCTION-SPEC)))
		 (UNLESS (AND GENERIC (NEQ GEN GENERIC))
		   (SETQ GEN (FIND-GENERIC-FUNCTION GEN T ENV))
		   (LET ((ELEM (ASSOC GEN ALIST)))
		     (IF ELEM
			 (PUSHNEW FUNCTION-SPEC (CDDR ELEM) :TEST #'EQUAL)
			 (PUSH (LIST* GEN
				      (DECIDE-METHOD-COMBINATION GEN COMPONENTS ENV)
				      (LIST FUNCTION-SPEC))
			       ALIST)))))))
      ;; Collect methods from the specified set of flavors
      (IF COMPONENTS
	  (DOLIST (FLAVOR COMPONENTS)
	    (COLLECT-FROM FLAVOR))
	  (LET ((FL (FIND-FLAVOR FLAVOR-NAME T ENV)))
	    (UNLESS (FLAVOR-COMPONENTS-COMPOSED FL)
	      (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ENV ENV :ERROR-P ERROR-P)
	      ;; Might have been copied into ENV
	      (SETQ FL (FIND-FLAVOR FLAVOR-NAME T ENV)))
	    (SETQ COMPONENTS (FLAVOR-ALL-COMPONENTS FL))
	    (DOLIST (COMPONENT COMPONENTS)
	      (COLLECT-FROM COMPONENT))))
      ;; If any SPECIAL-INSTANCE-VARIABLES were found, add appropriate pseudo-wrappers
      (WHEN SPECIAL-INSTANCE-VARIABLES
	(LET ((LOSERS NIL))
	  (DOLIST (GEN SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS)
	    (LET* ((GF (FIND-GENERIC-FUNCTION GEN NIL ENV))
		   (ELEM (AND GF (ASSOC GF ALIST))))
	      (IF ELEM
		  (PUSH `(SPECIAL-INSTANCE-VARIABLES ,GEN ,FLAVOR-NAME
						     ,@SPECIAL-INSTANCE-VARIABLES)
			(CDDR ELEM))
		  (PUSH GEN LOSERS))))
	  (WHEN LOSERS
	    (UNLESS GENERIC
	      (FLAVOR-ERROR FLAVOR-NAME ERROR-P
		":SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS ~{~S~^, ~} was~@
		specified, but no methods for these operations were defined or inherited."
		LOSERS)))))
      ALIST)))

;;;; Decide the method-combination type and parameters to be used by a particular
;;;; combination of generic function and flavor.  Report any conflicts.

(DEFUN DECIDE-METHOD-COMBINATION (GF COMPONENTS ENV)
  (LET ((GENERIC (GENERIC-FUNCTION-NAME GF))
	(MC (GENERIC-FUNCTION-METHOD-COMBINATION GF))
	(SOURCE NIL))
    (DOLIST (FLAVOR COMPONENTS)
      (LET* ((FL (FIND-FLAVOR FLAVOR NIL ENV))
	     (ELEM (AND FL (ASSOC GENERIC (FLAVOR-LOCAL-METHOD-COMBINATION FL)))))
	(WHEN ELEM
	  (IF (NULL MC)
	      (SETQ MC (CDR ELEM)
		    SOURCE FLAVOR)
	      (UNLESS (EQUAL MC (CDR ELEM))
		(FLAVOR-ERROR (FIRST COMPONENTS) NIL
			      "The ~:[generic function ~S~;flavor ~:*~S~*~] ~
				specifies ~{~S ~}method-combination,~@
				but the flavor ~S specifies ~{~S ~}method-combination.~@
				~2@*~{~S ~}method-combination will be used."
			      SOURCE GENERIC MC FLAVOR (CDR ELEM)))))))
    (OR MC '(:DAEMON :MOST-SPECIFIC-FIRST))))

;;; Call this when a flavor has been changed, it updates that flavor's compiled
;;;  information and that of any that depend on it.
;;; GENERIC is NIL to do all generics, or the name of a generic that needs compilation.
;;; IGNORE-EXISTING-METHODS can be T to force regeneration of all combined methods.
;;;  This is used if a wrapper has changed or there was a bug in the method-combining routine.
;;; DO-DEPENDENTS controls whether flavors that depend on this one are also compiled.
(DEFUN RECOMPILE-FLAVOR (FLAVOR-NAME
			 &KEY GENERIC ENV IGNORE-EXISTING-METHODS (DO-DEPENDENTS T))
  (DO-ALL-COMPOSED-DEPENDENTS (DEPENDENT FL (FIND-FLAVOR FLAVOR-NAME T ENV) ENV)
    ;; If the method-combination has been computed, compute it again.
    ;; If it hasn't yet been computed, nothing is out of date yet.
    (WHEN (FLAVOR-METHODS-COMPOSED FL)
      (COMPOSE-METHOD-COMBINATION DEPENDENT
				  :GENERIC GENERIC
				  :ENV ENV
				  :IGNORE-EXISTING-METHODS IGNORE-EXISTING-METHODS)
      (WHEN (OR (NULL GENERIC) (EQ GENERIC ':INIT))
	(SETF (FLAVOR-HAS-INIT-METHOD FL) (MEMBER ':INIT (FLAVOR-ALL-GENERICS FL)))))
    (UNLESS DO-DEPENDENTS
      ;;--- Temporary error check!  Remove after successfully building world
      (UNLESS (EQ DEPENDENT FLAVOR-NAME)
	(BREAK "INTERNAL ERROR: Flavor not at the front of ALL-COMPOSED-DEPENDENTS"))
      (RETURN NIL))))

;;; Maintain FLAVOR-ALL-COMPOSED-DEPENDENTS, in the correct order
(DEFUN ADD-COMPOSED-DEPENDENT (FLAVOR COMPONENT &OPTIONAL ENV)
  (LET ((FLAVOR-NAME (FLAVOR-NAME FLAVOR)))
    (LET ((COMPONENT-NAME (FLAVOR-NAME COMPONENT)))
      ;; Don't do this when we are hacking the compiler environment
      (WHEN (AND (NULL ENV)
		 (NEQ FLAVOR-NAME COMPONENT-NAME))
	;; Tell the DW handler table that this flavor acquired a new subtype
	(NOTE-CHANGE-FOR-DW COMPONENT-NAME))
      (UNLESS (MEMBER FLAVOR-NAME (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT))
	(WITHOUT-INTERRUPTS
	  ;; Put FLAVOR-NAME into the list right after the last occurrence of
	  ;; one of FLAVOR-NAME's components, so that flavor recompilation will occur 
	  ;; in base-flavor-first order, maximizing inheritance of combined methods.
	  ;; In any case, a flavor always goes at the front of its own list.
	  (LET ((WHERE (LOCF (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT))))
	    (UNLESS (EQ FLAVOR-NAME COMPONENT-NAME)
	      (LOOP WITH COMPONENTS = (FLAVOR-ALL-COMPONENTS FLAVOR)
		    FOR L ON (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT)
		    DO (WHEN (MEMBER (CAR L) COMPONENTS)
			 (SETQ WHERE L)))
	      ;; Avoid removing a flavor from the front of its own list.
	      (UNLESS (LISTP WHERE)
		(UNLESS (NULL (LOCATION-CONTENTS WHERE))
		  (SETQ WHERE (LOCATION-CONTENTS WHERE)))))
	    ;; Splice FLAVOR-NAME into the list after WHERE (which could be a locative)
	    (RPLACD WHERE (CONS-IN-AREA FLAVOR-NAME (CDR WHERE) *FLAVOR-AREA*))
	    ;; Keep the list from getting too scattered, without spending
	    ;; the whole day copying it over and over.
	    (SETF (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT)
		  (LOCALIZE-LIST (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT)
				 *FLAVOR-AREA*))))))))

(DEFUN REMOVE-COMPOSED-DEPENDENT (FLAVOR COMPONENT)
  (LET ((FLAVOR-NAME (FLAVOR-NAME FLAVOR))
	(COMPONENT-NAME (FLAVOR-NAME COMPONENT))
	(DEPENDENTS (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT)))
    ;; If only the flavor system did locking instead of D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")without-interrupts0...
    ;; There is a small timing window here.  Someone could come along and delete
    ;; or add to the list between the time we do the 1dw:prepare-for-type-change0,
    ;; and the time we do our thing.  But this doesn't matter, really, since
    ;; this is just accumulating possibilities.  So long as someone wins the race,
    ;; we will record the initial state, (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")and0 the intermediate state.  It's the
    ;; other end that counts.  The 1dw:finish-type-redefinition0 must happen after
    ;; the 2last0 change.  The 1without-interrupts0 here won't make any difference
    ;; to who wins 2that0 race.  Moving this outside the 1without-interrupts0 won't make
    ;; that bug any worse. --RWK
    (WHEN (MEMBER FLAVOR-NAME DEPENDENTS)
      (UNLESS (EQ FLAVOR-NAME COMPONENT-NAME)
	;; Tell the DW handler table that this flavor lost a subtype
	(NOTE-CHANGE-FOR-DW COMPONENT-NAME)))
    (WITHOUT-INTERRUPTS
      ;; We recompute 1dependents0 within the 1without-interrupts0.
      (LET ((DEPENDENTS (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT)))
	(WHEN (MEMBER FLAVOR-NAME DEPENDENTS)
	  (SETF (FLAVOR-ALL-COMPOSED-DEPENDENTS COMPONENT)
		(DELETE FLAVOR-NAME DEPENDENTS)))))))

(DEFUN REMOVE-FROM-ALL-COMPOSED-DEPENDENTS (FLAVOR)
  ;; Since we do a series of partial updates, we should take charge of completing
  ;; the DW updating from our callees.  (We deliberately ignore the fact that all
  ;; current callers will take charge from us.  Future callers might not.)
  (WITH-PENDING-DW-UPDATES
    (DOLIST (COMPONENT (FLAVOR-ALL-COMPONENTS FLAVOR))
      (WHEN (SETQ COMPONENT (FIND-FLAVOR COMPONENT NIL))
	(REMOVE-COMPOSED-DEPENDENT FLAVOR COMPONENT)))
    (SETF (FLAVOR-ALL-COMPONENTS FLAVOR) NIL)))

;;; Called when a new function or macro, local to a flavor, becomes known.
;;; Update composed lists of local functions in this flavor and its dependents.
(DEFUN DEFUN-IN-FLAVOR-ADDED (FL ENV FUNCTION-SPEC MACRO)
  (STANDARDIZE-ENV ENV)
  ;; Find the interpreter cell if it already exists, or else make a new one
  (LET ((AREA (FLAVOR-AREA ENV))
	(ELEM (FIND FUNCTION-SPEC (FLAVOR-ALL-LOCAL-FUNCTIONS FL)
		    :KEY #'THIRD :TEST #'EQUAL)))
    (UNLESS ELEM
      (SETQ ELEM (LIST-IN-AREA AREA (METHOD-GENERIC FUNCTION-SPEC) MACRO FUNCTION-SPEC)))
    ;; Get the interpreter cell into the FLAVOR-ALL-LOCAL-FUNCTIONS of dependent flavors.
    ;; This could be inside the UNLESS ELEM, as an optimization, except that there is a bug
    ;; in compile-time/run-time environment separation that can cause an entry to
    ;; get into FLAVOR-ALL-LOCAL-FUNCTIONS of one flavor without the dependents being
    ;; updated.  Better to have correctness than optimization.
    (MACROLET ((UPDATE-FLAVOR (FL)
		 ;; First check if this FL is in the environment we are updating
		 ;; This is a kludge, but an expedient one
		 `(UNLESS (AND (EQ ENV 'COMPILE)
			       (EQ ,FL (FIND-FLAVOR (FLAVOR-NAME ,FL) NIL NIL)))
		    ;; Now make sure this defun-in-flavor is in the list resulting from
		    ;; compose-flavor-combination on this flavor
		    ;;--- Really ought to be checking for warnings about local function
		    ;;--- shadowing, as in compose-flavor-combination, but it's difficult.
		    (UNLESS (ASSOC (METHOD-GENERIC FUNCTION-SPEC)
				   (FLAVOR-ALL-LOCAL-FUNCTIONS ,FL))
		      (PUSH ELEM (FLAVOR-ALL-LOCAL-FUNCTIONS ,FL)
			    :AREA AREA :LOCALIZE 2)))))
      (UPDATE-FLAVOR FL)			;even if not composed
      (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FL FL ENV)
	(UPDATE-FLAVOR FL)))
    ;; Update contents of interpreter cell
    (COND (MACRO (SETF (SECOND ELEM) MACRO))
	  ((NOT (AND (EQ (FIRST (SECOND ELEM)) 'DEFUN-IN-FLAVOR)
		     (EQ (SECOND (SECOND ELEM)) (METHOD-FLAVOR FUNCTION-SPEC))
		     (EQ (THIRD (SECOND ELEM)) (FDEFINITION-LOCATION FUNCTION-SPEC))))
	   (SETF (SECOND ELEM) (LIST-IN-AREA AREA
					     'DEFUN-IN-FLAVOR
					     (METHOD-FLAVOR FUNCTION-SPEC)
					     (FDEFINITION-LOCATION FUNCTION-SPEC)))))
    ELEM))

;;; Called when a defun-in-flavor, defsubst-in-flavor, or defmacro-in-flavor is fundefined.
;;; Update composed lists of local functions in this flavor and its dependents.
;;;--- Would need to be smarter if local-function shadowing were allowed.
(DEFUN DEFUN-IN-FLAVOR-REMOVED (FL FUNCTION-SPEC)
  (MACROLET ((UPDATE-FLAVOR (FL)
	       `(LET ((ITEM (ASSOC (METHOD-GENERIC FUNCTION-SPEC)
				   (FLAVOR-ALL-LOCAL-FUNCTIONS ,FL))))
		  (WHEN ITEM
		    (SETF (FLAVOR-ALL-LOCAL-FUNCTIONS ,FL)
			  (DELETE ITEM (FLAVOR-ALL-LOCAL-FUNCTIONS ,FL)
				  :TEST #'EQ :COUNT 1))))))
    (UPDATE-FLAVOR FL)
    (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FL FL)
      (UPDATE-FLAVOR FL))))

;;; A method used to be solitary, but now there are multiple methods for the generic function,
;;; so switch to the normal dispatching mechanism.
(DEFUN REMOVE-SOLITARY-METHOD (GF)
  ;; Remove the trampoline
  (SETF (GENERIC-FUNCTION-HAS-DISPATCH-FUNCTION GF) NIL)
  (INSTALL-GENERIC-FUNCTION (GENERIC-FUNCTION-NAME GF) GF NIL NIL)
  ;; Remove the declaration made by the original defmethod
  (SETF (GENERIC-FUNCTION-SOLITARY GF) NIL)
  ;; Add the original method to the handler table of all flavors that inherit it
  (DOLIST (FLAVOR (GENERIC-FUNCTION-FLAVORS GF))
    (RECOMPILE-FLAVOR FLAVOR :GENERIC (GENERIC-FUNCTION-NAME GF))))

;;;; COMPILE-FLAVOR-METHODS

;;; Compiling this puts the combined methods into the compiler output file and
;;; also arranges to confirm their correctness at load time and otherwise prepare
;;; the flavor to be instantiated.
;;; Don't interpret this, unless you want your combined methods to run interpreted!
(DEFMACRO COMPILE-FLAVOR-METHODS (&REST FLAVOR-NAMES)
  (UNLESS FLAVOR-NAMES
    (WARN "COMPILE-FLAVOR-METHODS requires at least one flavor name as an argument."))
  (LET ((ADDITIONAL-FLAVORS NIL)		;for mixtures
	(COMBINED-METHODS NIL)			;definitions to be compiled
	(CONSTRUCTORS NIL))
    (DOLIST (FLAVOR-NAME FLAVOR-NAMES)
      (LET ((FL (CONDITION-CASE () (FIND-FLAVOR FLAVOR-NAME 'CREATE-IN-ENV 'COMPILE)
		  (FLAVOR-NOT-FOUND NIL)))
	    ;; Can't associate warnings with the COMPILE-FLAVOR-METHODS form, since it isn't
	    ;; a definition, so associate them with the DEFFLAVOR.
	    (COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
	    (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR))
	(COND ((AND FL
		    (OR (FLAVOR-COMPONENTS-COMPOSED FL)
			(COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ENV 'COMPILE :ERROR-P NIL)))
	       ;; The flavor is fully defined in the compile-time environment
	       ;; Make the combined methods that need to be compiled
	       (MULTIPLE-VALUE-BIND (NIL DEFUNS)
		   (COLLECT-COMBINED-METHODS FLAVOR-NAME :ENV 'COMPILE
					     :IGNORE-EXISTING-METHODS UNDO-DECLARATIONS-FLAG
					     :ERROR-P NIL)
		 (SETQ COMBINED-METHODS (NCONC COMBINED-METHODS DEFUNS)))
	       ;; Collect additional flavors due to :MIXTURE
	       (SETQ ADDITIONAL-FLAVORS
		     (UNION (SET-DIFFERENCE (FLAVOR-MIXTURE-NAMES (FLAVOR-MIXTURE FL))
					    FLAVOR-NAMES)
			    ADDITIONAL-FLAVORS))
	       ;; Issue any necessary warnings about initializations
	       (COMPILE-FLAVOR-METHODS-INITIALIZATIONS FLAVOR-NAME FL 'COMPILE)
	       ;; Compile any by-position constructor functions
	       (WHEN (FLAVOR-CONSTRUCTORS FL)
		 (PUSH (CONS FLAVOR-NAME (COMPOSE-CONSTRUCTOR-FUNCTIONS FL 'COMPILE))
		       CONSTRUCTORS)))
	      (T
	       (WARN "COMPILE-FLAVOR-METHODS of ~S is ineffective because~@
		      ~:[the flavor is undefined~;~
		      the components of the flavor could not be fully determined~] ~
		      at compile time."
		     FLAVOR-NAME FL)))))
    (FLET ((COMPILE-DEFUNS (DEFUNS)
	     (COND (UNDO-DECLARATIONS-FLAG DEFUNS)
		   (DEFUNS `((COMPILE-FUNCTION-LIST ',DEFUNS))))))
      ;; Output code to do load-time stuff
      `(PROGN ,@(COMPILE-DEFUNS COMBINED-METHODS)
	      ,@(MAPCAN #'(LAMBDA (FLAVOR-NAME)
			    (LET ((CONSTRUCTORS (CDR (ASSOC FLAVOR-NAME CONSTRUCTORS))))
			      (IF (NULL CONSTRUCTORS)
				  `((COMPILE-FLAVOR-METHODS-LOAD-TIME
				      ',FLAVOR-NAME ',UNDO-DECLARATIONS-FLAG))
				  ;; First compose everything but the constructors, then load
				  ;; the previously compiled constructors, then call
				  ;; COMPILE-FLAVOR-METHODS-LOAD-TIME again to validate them
				  `((COMPILE-FLAVOR-METHODS-LOAD-TIME ',FLAVOR-NAME
								      ',UNDO-DECLARATIONS-FLAG
								      NIL)
				    ,@(COMPILE-DEFUNS CONSTRUCTORS)
				    (COMPILE-FLAVOR-METHODS-LOAD-TIME ',FLAVOR-NAME NIL T)))))
			FLAVOR-NAMES)
	      ;;Include all the flavors automatically created from this one
	      ,@(AND ADDITIONAL-FLAVORS
		     `((COMPILE-FLAVOR-METHODS ,@ADDITIONAL-FLAVORS)))))))

;;; FORCE is to avoid duplicate warnings when compiling directly into the current
;;; environment, and to defend against loading incorrect combined methods from a file.
(DEFUN COMPILE-FLAVOR-METHODS-LOAD-TIME (FLAVOR-NAME FORCE &OPTIONAL (CONSTRUCTORS T))
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME))
	;; Can't associate warnings with the COMPILE-FLAVOR-METHODS form, since it isn't
	;; a definition, so associate them with the DEFFLAVOR.
	(COMPILER:DEFAULT-WARNING-FUNCTION FLAVOR-NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFLAVOR))
    (SETF (FLAVOR-HAS-COMPILE-FLAVOR-METHODS FL) T)
    (UNLESS (FLAVOR-COMPONENTS-COMPOSED FL)
      (WHEN (OR (FLAVOR-ALL-COMPONENTS FL)	;Got an error earlier
		(NOT (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME	;Got an error this time
						 :ERROR-P NIL)))
	;; If we can't COMPOSE-FLAVOR-COMBINATION without getting an error yet,
	;; don't try to compose the other stuff: that would just go into the Debugger
	(RETURN-FROM COMPILE-FLAVOR-METHODS-LOAD-TIME NIL)))
    (WHEN (OR FORCE (NOT (FLAVOR-METHODS-COMPOSED FL)))
      (COMPOSE-METHOD-COMBINATION FLAVOR-NAME))
    (COMPILE-FLAVOR-METHODS-INITIALIZATIONS FLAVOR-NAME FL NIL)
    (WHEN CONSTRUCTORS
      (VALIDATE-CONSTRUCTOR-FUNCTIONS FL))))

(DEFUN COMPILE-FLAVOR-METHODS-INITIALIZATIONS (FLAVOR-NAME FL ENV)
  (UNLESS (FLAVOR-IS-ABSTRACT FL)
    (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL)
      (COMPOSE-INITIALIZATIONS FLAVOR-NAME :ERROR-P NIL :ENV ENV))
    (UNLESS (FLAVOR-ALL-ALLOW-OTHER-KEYS FL)
      (WHEN (FLAVOR-ALL-UNHANDLED-KEYWORDS FL)
	(FLAVOR-ERROR FLAVOR-NAME NIL
		      "Flavor ~S does not handle the init keyword~P ~{~S~^, ~} ~
found in a :DEFAULT-INIT-PLIST"
		      FLAVOR-NAME
		      (LENGTH (FLAVOR-ALL-UNHANDLED-KEYWORDS FL))
		      (REVERSE (FLAVOR-ALL-UNHANDLED-KEYWORDS FL))))))
  FLAVOR-NAME)

;;;; Flavor mixture support

;--- It would be nicer if :MIXTURE was inherited, but there are some issues.
;--- RWK says it's easy to figure out how the mixins ought to be ordered.
;--- Harder is arranging the code, since we don't always know at DEFFLAVOR
;--- time whether a component flavor has :MIXTURE and anyway it might change.

;Convert the :MIXTURE option to DEFFLAVOR into a decision tree.
; Each subtree's car is a keyword, and cdr is an alist from values to subtrees or leaves.  
; In this alist the key OTHERWISE is special.
;A leaf is a symbol (combined flavor name) or a string (error message).
;The second value is a list of elements (flavor-name component-flavors...)
;describing the subsidiary flavors automatically declared by the :MIXTURE option.
(DEFUN ENCODE-FLAVOR-MIXTURE (FLAVOR-NAME SPECS)
  (DECLARE (VALUES TREE ADDITIONAL-FLAVORS))
  (LET ((ADDITIONAL-FLAVORS NIL)		;Second value to be returned
	(WARNED-ABOUT NIL))			;To prevent duplicate warnings
    (LABELS ((ENCODE (LEFT PLIST L)
	       ;;LEFT is a list of the mixins already seen to our left, in reverse order.
	       ;; The last element of this list is always the base flavor.
	       ;;PLIST is a list of alternating keywords and values describing the
	       ;; path through the decision tree to get to where are we now.
	       ;;L is the list of specs we are working on.
	       (COND ((STRINGP (CAR LEFT))		;Issue an error message
		      (CAR LEFT))
		     ((NULL (CAR LEFT))			;No mixin needs to be added
		      (ENCODE (CDR LEFT) PLIST L))	
		     ((NULL L)				;Leaf, define a flavor
		      (COND ((NULL (CDR LEFT)) FLAVOR-NAME)	;No mixins
			    ((LOOP FOR (NAME . COMPONENTS) IN ADDITIONAL-FLAVORS
				   WHEN (EQUAL COMPONENTS LEFT) RETURN NAME))  ;Already exists
			    (T
			     (LET ((NAME (FLAVOR-MIXTURE-NAME LEFT)))
			       ;; Look for FLAVOR-MIXTURE-NAME-heuristics-induced blunders
			       ;; and retrench if the generated name wouldn't work.
			       ;; Better to use a silly looking name than to warn.
			       (WHEN (OR (MEMBER NAME LEFT)
					 (ASSOC NAME ADDITIONAL-FLAVORS))
				 (SETQ NAME (INTERN (WITH-OUTPUT-TO-STRING (S)
						      (LOOP FOR (COMPONENT . REST) ON LEFT DO
							(WRITE-STRING (STRING COMPONENT) S)
							(WHEN REST (WRITE-CHAR #\+ S)))))))
			       (PUSH (CONS NAME LEFT) ADDITIONAL-FLAVORS)
			       NAME))))
		     ((OR (NOT (LISTP (CAR L)))		;Error case
			  (NOT (SYMBOLP (CAAR L)))
			  (NOT (CDAR L))
			  (NOT (OR (SYMBOLP (CADAR L)) (STRINGP (CADAR L))
				   (LOOP FOR X IN (CDAR L)
					 ALWAYS (AND (LISTP X)
						     ( (LENGTH X) 2)
						     (ACCEPTABLE-VALUE-P (FIRST X))
						     (OR (SYMBOLP (SECOND X))
							 (STRINGP (SECOND X))))))))
		      (UNLESS (MEMBER (CAR L) WARNED-ABOUT)
			(WARN "~S is a malformed flavor mixture description." (CAR L))
			(PUSH (CAR L) WARNED-ABOUT))
		      NIL)
		     ((ATOM (CADAR L))			;Boolean case
		      (UNLESS (OR (CADAR L) (CDDAR L))
			(UNLESS (MEMBER (CAR L) WARNED-ABOUT)
			  (WARN "~S as a flavor mixture description is useless, because its~@
			       effect does not depend on whether the ~S argument is T or NIL."
				(CAR L) (CAAR L))
			  (PUSH (CAR L) WARNED-ABOUT)))
		      (CASE (GETF PLIST (CAAR L) 'OTHERWISE)	;Check if keyword already seen
			((T) (ENCODE (CONS (CADAR L) LEFT)
				     PLIST
				     (APPEND (CDDAR L) (CDR L))))
			((NIL) (ENCODE LEFT
				       PLIST
				       (CDR L)))
			(OTHERWISE `(,(CAAR L)
				     (T ,(ENCODE (CONS (CADAR L) LEFT)
						 (LIST* (CAAR L) T PLIST)
						 (APPEND (CDDAR L) (CDR L))))
				     (NIL ,(ENCODE LEFT
						   (LIST* (CAAR L) NIL PLIST)
						   (CDR L)))))))
		     (T					;General alist case
		      (WHEN (LOOP FOR (VALUE MIXIN . SUBSPECS) IN (CDAR L)
				  DO (IGNORE VALUE)
				  NEVER (OR MIXIN SUBSPECS))
			(UNLESS (MEMBER (CAR L) WARNED-ABOUT)
			  (WARN "~S as a flavor mixture description is useless, because its~@
			       effect does not depend on the value of the ~S argument."
				(CAR L) (CAAR L))
			  (PUSH (CAR L) WARNED-ABOUT)))
		      (IF (LOOP FOR (PROP VALUE) ON PLIST BY 'CDDR
				THEREIS (AND (EQ PROP (CAAR L))
					     (NEQ VALUE 'OTHERWISE)
					     (ASSOC VALUE (CDAR L))))
			  ;; Keyword already seen and we know which clause is selected
			  (DESTRUCTURING-BIND (IGNORE MIXIN . SUBSPECS)
					      (ASSOC (GETF PLIST (CAAR L)) (CDAR L))
			    (ENCODE (CONS MIXIN LEFT)
				    PLIST
				    (APPEND SUBSPECS (CDR L))))
			  `(,(CAAR L)
			    . ,(LOOP FOR (VALUE MIXIN . SUBSPECS) IN (CDAR L)
				     AS PLIST1 = (LIST* (CAAR L) VALUE PLIST)
				     COLLECT (LIST VALUE
						   (ENCODE (CONS MIXIN LEFT)
							   PLIST1
							   (APPEND SUBSPECS (CDR L))))))))))
	     ;; Something that can reasonably be compared with EQL (via ASSOC)
	     ;; This is the same test that CASE uses
	     ;; Unacceptable: strings, bit-vectors, vectors, lists, QUOTE forms
	     ;; which users might accidentally expect to work as keys.  Don't
	     ;; complain about instances and named-structures, since they might
	     ;; be interned through some type-specific mechanism.
	     (ACCEPTABLE-VALUE-P (VALUE)
	       (AND (ATOM VALUE)
		    (NOT (AND (ARRAYP VALUE)
			      (NOT (NAMED-STRUCTURE-P VALUE)))))))
      (VALUES (ENCODE (LIST FLAVOR-NAME) NIL SPECS)
	      ADDITIONAL-FLAVORS))))

;Get flavor name from decision tree
;ERROR-P can be T, NIL, or THROW
; THROW throws NIL to DECODE-FLAVOR-MIXTURE if the init-options are not legal
(DEFUN DECODE-FLAVOR-MIXTURE (BASE-FLAVOR INIT-OPTIONS &OPTIONAL ENV (ERROR-P T))
  (MACROLET ((BARF (&REST ARGS)
	       `(IF (EQ ERROR-P 'THROW)
		    (THROW 'DECODE-FLAVOR-MIXTURE NIL)
		    (FUNCALL (IF ERROR-P #'ERROR #'WARN) ,@ARGS))))
    (LET* ((FL (FIND-FLAVOR BASE-FLAVOR T ENV))
	   (TREE (FLAVOR-MIXTURE FL)))
      (UNLESS TREE
	(RETURN-FROM DECODE-FLAVOR-MIXTURE BASE-FLAVOR))
      (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL)
	(COMPOSE-INITIALIZATIONS BASE-FLAVOR :ENV ENV :ERROR-P ERROR-P))
      (LET ((DEFAULTS (FLAVOR-MIXTURE-DEFAULTS FL)))
	(UNLESS (LOOP FOR (KEY VAL) ON DEFAULTS BY 'CDDR	;If any defaults aren't
		      DO (IGNORE KEY)
		      ALWAYS (AND (ATOM VAL)			;self-evaluating constants
				  (OR (NOT (SYMBOLP VAL))
				      (EQ VAL NIL)
				      (EQ VAL T)
				      (KEYWORDP VAL))))
	  (SETQ DEFAULTS (LOOP FOR (KEY VAL) ON DEFAULTS BY 'CDDR
			       UNLESS (LOOP FOR K IN INIT-OPTIONS BY 'CDDR
					    THEREIS (EQ K KEY))
				 COLLECT KEY AND COLLECT (EVAL VAL))))
	(LOOP AS VAL = (GETF INIT-OPTIONS (CAR TREE) (GETF DEFAULTS (CAR TREE)))
	      AS NEXT = (CADR (OR (ASSOC VAL (CDR TREE))
				  (ASSOC 'OTHERWISE (CDR TREE))))
	      DO (COND ((NULL NEXT)
			(BARF "~S is illegal as the ~S option for ~S.~@
			      Legal values are ~{~1{~S~}~^, ~}."
			      VAL (CAR TREE) BASE-FLAVOR (CDR TREE)))
		       ((SYMBOLP NEXT) (RETURN NEXT))
		       ((LISTP NEXT) (SETQ TREE NEXT))
		       (T 
			;; Figure out how we got here, now that consing is okay
			(SETQ TREE (FLAVOR-MIXTURE FL))
			(LOOP AS VAL = (GETF INIT-OPTIONS (CAR TREE)
					     (GETF DEFAULTS (CAR TREE)))
			      AS NXT = (CADR (OR (ASSOC VAL (CDR TREE))
						 (ASSOC 'OTHERWISE (CDR TREE))))
			      APPEND `(,(CAR TREE) ,VAL) INTO TRAIL
			      WHILE (LISTP NXT)
			      DO (SETQ TREE NXT)
			      FINALLY
				(BARF "Illegal ~:[option~;combination of options~] ~
				       ~{~S ~}to ~S: ~A"
				      (CDDR TRAIL) TRAIL BASE-FLAVOR NEXT)))))))))

;Find all the init-keywords that are mentioned in the mixture decision tree
(DEFUN FLAVOR-MIXTURE-KEYWORDS (FL)
  (LET ((RESULT NIL))
    (LABELS ((TRAVERSE (TREE)
	       (WHEN (CONSP TREE)
		 (PUSHNEW (CAR TREE) RESULT)
		 (LOOP FOR (VALUE SUBTREE) IN (CDR TREE)
		       DO (IGNORE VALUE)
			  (TRAVERSE SUBTREE)))))
      (TRAVERSE (FLAVOR-MIXTURE FL))
      RESULT)))

;Find all the flavors automatically created from this one, given its tree
(DEFUN FLAVOR-MIXTURE-NAMES (TREE)
  (COND ((LISTP TREE)
	 (DELETE-DUPLICATES (LOOP FOR (VALUE SUBTREE) IN (CDR TREE)
				  DO (IGNORE VALUE)
				  NCONC (FLAVOR-MIXTURE-NAMES SUBTREE))))
	((NULL TREE) NIL)
	((SYMBOLP TREE) (NCONS TREE))))

;Concatenate the names of the various mixins, separated by hyphens, base flavor last.
;But elide "basic", "mixin", and redundant occurrences of words in the basic flavor name.
;This gives a good guess at reasonable names for the automatically defined flavors.
;I'm sure the algorithm could be greatly improved
(DEFUN FLAVOR-MIXTURE-NAME (L)
  (LET ((BASE-FLAVOR (STRING (FIRST (LAST L)))))
    (WHEN (%STRING-EQUAL BASE-FLAVOR 0 "BASIC-" 0 6)
      (SETQ BASE-FLAVOR (SUBSTRING BASE-FLAVOR 6)))
    (LET ((REDUNDANCIES (LOOP FOR I = 0 THEN (1+ J)
			      AS J = (STRING-SEARCH-CHAR #\- BASE-FLAVOR :START I)
			      COLLECT (SUBSTRING BASE-FLAVOR I J)
			      WHILE J)))
      (INTERN (WITH-OUTPUT-TO-STRING (S)
		(LOOP WHILE (CDR L)
		      AS NAME = (STRING (POP L)) AS ORIGINAL-NAME = NAME
		      DO (WHEN (%STRING-EQUAL NAME 0 "BASIC-" 0 6)
			   (SETQ NAME (SUBSTRING NAME 6)))
			 (LET ((LEN (- (STRING-LENGTH NAME) 6)))
			   (WHEN (AND (PLUSP LEN)
				      (%STRING-EQUAL NAME LEN "-MIXIN" 0 6))
			     (SETQ NAME (SUBSTRING NAME 0 LEN))))
			 (LOOP FOR I = 0 THEN (1+ J)
			       AS J = (STRING-SEARCH-CHAR #\- NAME :START I)
			       DO (LOOP FOR R IN REDUNDANCIES DO
				    (WHEN (STRING-EQUAL NAME R :START1 I :END1 J)
				      (SETQ NAME (COND ((NOT (NULL J))
							(PROG1 (STRING-APPEND
								 (SUBSTRING NAME 0 I)
								 (SUBSTRING NAME (1+ J)))
							       (SETQ J (1- I))))
						       ((PLUSP I)
							(SUBSTRING NAME 0 (1- I)))
						       (T	;Totally-redundant case
							(SETQ NAME ORIGINAL-NAME))))
				      (RETURN)))
			       WHILE J)
			 (WRITE-STRING NAME S)
			 (WRITE-CHAR #\- S))
		(WRITE-STRING BASE-FLAVOR S))))))
