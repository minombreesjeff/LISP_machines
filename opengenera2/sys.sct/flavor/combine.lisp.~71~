;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains the mechanism for defining method-combination types
;;; The actual definitions of the types are in another file (CTYPES)

;;; Possible extensions:
;;;  NO-METHODS-OK option
;;;  Can METHOD-COMBINATION-ERROR use conditional signalling to eliminate the ERROR-P arg?

;DOCUMENTATION (in case not all these details are in the Sage documentation)

;Defining a method-combination type defines two functions on the property list
;of the name of the type.  The method-combination type can then be invoked by
;specifying a method-combination (a list of the type and some type-dependent
;parameters, such as ordering) for a generic function.

;The function on the FLAVOR::METHOD-COMBINATION property takes five arguments:
; (1) The name of the generic function this is a method for.
;     This gets bound to the parameter name FLAVOR:GENERIC.
; (2) The name of the flavor that is going to receive the combined method.
;     This gets bound to the parameter name FLAVOR:FLAVOR.
;     Method-combinations for binary generic operators may need to know the flavor name.
; (3) the method-combination specification, car is name, cdr is list of parameters
; (4) the list of method function specs supplied by component flavors, most-specific-last
; (5) ERROR-P, NIL to suppress error messages for extraneous methods.
;
;It returns two values:
; (1) A form to use as the body of the combined-method.
; (2) A list of function specs in the (approximate) order that they are called.
;     "Approximate" because of nonlinear ordering when there are wrappers, etc.
;
;The body of DEFINE-METHOD-COMBINATION returns the form (value #1 above) as its
;value.  It can also have side-effects on the variables bound to methods or
;lists of methods if it likes, although usually the filters in the methods-specifications
;take care of this automatically.

;The function on the FLAVOR::METHOD-COMBINATION-PRINTER property takes two arguments:
;  The method-combination
;  A function spec
;It prints an abbreviated description of the function spec to STANDARD-OUTPUT.
;This is a "pretty" form of the method-options (cdddr of the function spec).
;It doesn't print the generic nor the flavor, since
;it could be called by something sorting by either of those.
;The caller should print whatever reference to the generic and the flavor it desires.

;Patterns
;We define a set of methods to be depended upon by the combined method using
;a methods-specification of the form
;	(variable printer filter order pattern pattern...)
;printer is a string, used as a format string with the method-options as its arguments,
; or else it's a function to be called with method-combination and function-spec as
; its arguments.  Printer is not evaluated.
; Printer strings get hacked automatically for default methods.
;variable is a variable bound to a function spec or list of function specs
; depending on the filter.  Note that the list can always be empty (NIL);
; if this matters to the individual method-combination function it must
; check explicitly.  Usually it doesn't matter, because the code it returns
; will be optimized anyway.
;filter is one of the following symbols (unevaluated):
;	:FIRST -- take the first method in the specified order
;	:LAST -- take the last method in the specified order
;	:EVERY -- take all the methods
;	:REMOVE-DUPLICATES -- take all the methods then divide them into
;		equivalence classes according to EQUAL of method-options of function specs
;		and take only the first of each equivalence class.
;You can also do your own filtering in the body by setq'ing the variable.
;
;order must evaluate to :MOST-SPECIFIC-FIRST or :MOST-SPECIFIC-LAST, it can be
; a form or one of those keywords (as a constant).
; :BASE-FLAVOR-LAST and :BASE-FLAVOR-FIRST are also accepted for compatibility, with a warning
;A method that matches any of the patterns is selected (in effect the patterns are ORed).
;Each pattern is a list or (), must match the method-options, and may be dotted.
;Match is by EQUAL except * matches anything.  Dotted * may be useful for variable length.
;No patterns is the same as a pattern of ().
;Intermixed with the patterns can be special kludge symbols, one of:
;	:DEFAULT -- if no other matches, insert the :DEFAULT methods, else ignore them.
;	  (no other possibilities currently)
;
;The methods-specifications are applied sequentially in the order they are written,
; so put more general patterns last.  The methods are expected to be called in the
; order the methods-specifications are written, so put in a :ORDER clause if it's not so.
;
;Thus for daemons:
;	((BEFORE "before" :EVERY :MOST-SPECIFIC-FIRST (:BEFORE))
;	 (PRIMARY "primary" :FIRST ORDER :DEFAULT)
;	 (AFTER "after" :EVERY :MOST-SPECIFIC-LAST (:AFTER)))

;;;; Implicit arguments to CALL-COMPONENT-METHOD macro

(DEFVAR *COMBINED-METHOD-LAMBDA-LIST*)
(DEFVAR *COMBINED-METHOD-ARGUMENTS*)
(DEFVAR *COMBINED-METHOD-APPLY*)

;;;; Defining forms for method-combination types

(DEFPROP DEFINE-SIMPLE-METHOD-COMBINATION DEFINE-METHOD-COMBINATION
	 ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFINE-SIMPLE-METHOD-COMBINATION (NAME OPERATOR
					    &OPTIONAL SINGLE-ARG-IS-VALUE
						      (PRETTY-NAME
							(LET ((*PACKAGE* NIL))
							  (FORMAT NIL "~((~S)~)" NAME))))
  (WHEN (SYMBOLP OPERATOR)			;Could be a LAMBDA
    (COMPILER:FUNCTION-REFERENCED OPERATOR `(:PROPERTY ,NAME METHOD-COMBINATION)))
  (MAKE-METHOD-COMBINATION-FUNCTION
	NAME
	`(&OPTIONAL (ORDER ':MOST-SPECIFIC-FIRST))
	`((METHODS ,PRETTY-NAME :EVERY ORDER () (,NAME) :DEFAULT))
	(LIST (IF SINGLE-ARG-IS-VALUE
		  `(IF (= (LENGTH METHODS) 1)
		       (CALL-COMPONENT-METHOD (FIRST METHODS))
		       (CALL-COMPONENT-METHODS METHODS :OPERATOR ',OPERATOR))
		  `(CALL-COMPONENT-METHODS METHODS :OPERATOR ',OPERATOR)))))

(DEFPROP DEFINE-METHOD-COMBINATION "Method-combination type" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-METHOD-COMBINATION (NAME PARAMETERS METHOD-PATTERNS &BODY BODY)
  (DECLARE (ZWEI:INDENTATION 2 1))
  (CHECK-TYPE PARAMETERS LIST)
  (CHECK-TYPE METHOD-PATTERNS (AND LIST (NOT NULL)))
  (MAKE-METHOD-COMBINATION-FUNCTION NAME PARAMETERS METHOD-PATTERNS BODY))

(DEFUN MAKE-METHOD-COMBINATION-FUNCTION (NAME PARAMETERS METHOD-PATTERNS BODY)
  ;; Validate our arguments
  (UNLESS (SYMBOLP NAME)
    (ERROR "The name of a method-combination type must be a symbol, not ~S." NAME))
  (DOLIST (X METHOD-PATTERNS)
    (UNLESS (AND (LISTP X) ( (LENGTH X) 4))
      (ERROR "~S is an invalid methods-specification." X))
    (SI:CHECK-SYMBOL-SETABILITY (FIRST X) "bind (in a methods-specification)")
    (UNLESS (OR (STRINGP (SECOND X)) (SYMBOLP (SECOND X)))
      (ERROR "~S is an invalid printer in the methods-specification for ~S.~@
		A string or a symbol is required." (SECOND X) (FIRST X)))
    (UNLESS (MEMBER (THIRD X) '(:FIRST :LAST :EVERY :REMOVE-DUPLICATES))
      (ERROR "~S is an invalid filter in the methods-specification for ~S.~@
		:FIRST, :LAST, :EVERY, or :REMOVE-DUPLICATES is required."
	     (THIRD X) (FIRST X)))
    (DOLIST (Y (CDDDDR X))
      (UNLESS (EQ Y ':DEFAULT)
	(UNLESS (LISTP Y)
	  (ERROR "~S is an invalid pattern in the methods-specification for ~S.~@
			A list is required." Y (FIRST X)))
	;; I guess we don't care if it's a list of symbols or of other types of elements
	)))
  ;; Add the null pattern to any patternless clauses, by default.
  (SETQ METHOD-PATTERNS (COPY-LIST METHOD-PATTERNS))
  (LOOP FOR L ON METHOD-PATTERNS DO
    (WHEN (MEMBER (CDDDDR (CAR L)) '(() (:DEFAULT)) :TEST #'EQUAL)
      (SETF (CAR L) (APPEND (CAR L) '(())))))
  ;; Build the two functions that implement the procedural interface from the
  ;; flavor system to this method-combination type
  (MULTIPLE-VALUE-BIND (DEFUN TRANSFORMER)
      (MAKE-METHOD-COMBINATION-FUNCTION-1 NAME PARAMETERS METHOD-PATTERNS BODY)
    (WHEN UNDO-DECLARATIONS-FLAG
      (SETF (GETDECL NAME 'METHOD-COMBINATION)
	    (SI:ENCLOSE `(LAMBDA . ,(CDDR DEFUN)) NIL (SECOND DEFUN)))
      (WHEN TRANSFORMER
	(SETF (GETDECL NAME 'METHOD-COMBINATION-METHOD-TRANSFORMER)
	      (SI:ENCLOSE `(LAMBDA . ,(CDDR TRANSFORMER)) NIL (SECOND TRANSFORMER)))))
    `(PROGN
       (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-METHOD-COMBINATION)
       ,(MAKE-METHOD-COMBINATION-PRINT-FUNCTION NAME METHOD-PATTERNS)
       ,(OR TRANSFORMER `(REMPROP ',NAME 'METHOD-COMBINATION-METHOD-TRANSFORMER))
       ,DEFUN)))

(DEFUN MAKE-METHOD-COMBINATION-FUNCTION-1 (NAME PARAMETERS METHOD-PATTERNS BODY)
  (DECLARE (VALUES DEFUN TRANSFORMER))
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFINE-METHOD-COMBINATION)
	(DEFAULT NIL)
	(DEFAULT-IS-A-LIST NIL)
	(DECLARATIONS NIL)
	(SPECIALS NIL)
	(ARGLIST NIL)
	(ORDERED-PATTERNS METHOD-PATTERNS)
	(TRANSFORMER NIL)
	(INDETERMINACY-BUFFERS NIL))
    ;; Notice if the :DEFAULT kludge is used
    ;; and note places where we will need to check for indeterminacy
    (LOOP FOR (VAR PRINTER FILTER ORDER . PATTERNS) IN METHOD-PATTERNS DO
      (IGNORE PRINTER ORDER)
      (WHEN (MEMBER ':DEFAULT PATTERNS)
	(WHEN DEFAULT
	  (WARN "~S and ~S can't both get :DEFAULT methods." DEFAULT VAR))
	(SETQ DEFAULT VAR
	      DEFAULT-IS-A-LIST (NOT (MEMBER FILTER '(:FIRST :LAST)))))
      (WHEN (OR (CDR PATTERNS) (NOT (WILD-PATTERN (CAR PATTERNS))))
	(PUSH (LIST VAR (GENSYM) (GENSYM)) INDETERMINACY-BUFFERS)))
    ;; Allow special option clauses before the body
    (LOOP WHILE (AND BODY (LISTP (FIRST BODY))) DO
      (CASE (CAR (FIRST BODY))
	((:ARGLIST)
	 (SETQ ARGLIST (LOOP FOR (VAR . VAL) IN (LT:MATCH-ARGS-TO-LAMBDA-LIST
						  (CDR (POP BODY))
						  '(SELF .DAEMON-CALLER-ARGS.)
						  :APPLY T
						  :RETURN-BINDINGS T)
			     UNLESS (EQ VAR 'IGNORE)
			       COLLECT `(,VAR ',VAL))))
	((:ORDER)
	 (SETQ ORDERED-PATTERNS (CDR (POP BODY)))
	 (SETQ ORDERED-PATTERNS (SORT (COPY-LIST METHOD-PATTERNS)
				      #'(LAMBDA (X Y)
					  (MEMBER (CAR Y)
						  (CDR (MEMBER (CAR X) ORDERED-PATTERNS)))))))
	(:METHOD-TRANSFORMER
	 (SETQ TRANSFORMER (CDR (POP BODY))))
	(OTHERWISE (RETURN))))
  ;; Build the function that implements the METHOD-PATTERNS specified
  ;;--- Cannot declare parameters, method-pattern vars with CL declaration scoping
  ;;--- because the declarations get put into the body at the wrong place.
  ;;--- Fix later, but the problem is that multiple lexical contours are created.
  (MULTIPLE-VALUE-SETQ (DECLARATIONS SPECIALS BODY)
    (SI:PARSE-BODY-DECLARATIONS BODY NIL))
  (WHEN SPECIALS
    (UNLESS SI:*SPECIAL-DECLARATIONS-ARE-PERVASIVE*
      (PUSH `(SPECIAL ,@SPECIALS) DECLARATIONS)))
  (VALUES
    `(DEFUN (:PROPERTY ,NAME METHOD-COMBINATION)
	    (GENERIC FLAVOR METHOD-COMBINATION COMPONENT-METHOD-LIST ERROR-P
	     &AUX (METHOD-COMBINATION-PARAMETERS (CDR METHOD-COMBINATION)))
       (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-METHOD-COMBINATION)
		,@DECLARATIONS)
       (IGNORE GENERIC FLAVOR)			;user code can look at them if it likes
       ;; The &AUX variable METHOD-COMBINATION-PARAMETERS exists solely to control the
       ;; error message produced by DESTRUCTURING-BIND if the pattern doesn't match.
       (DESTRUCTURING-BIND ,PARAMETERS METHOD-COMBINATION-PARAMETERS
	 ;; Bind variables to accumulate method function specs or lists thereof.
	 ;; Also bind variables specified in the ARGLIST to forms to access
	 ;; corresponding parts of the method arglist at run time.  We access
	 ;; just the DEFMETHOD-visible part of the method arglist.
	 (LET (,@(LOOP FOR (VAR) IN METHOD-PATTERNS
		       COLLECT `(,VAR NIL))
	       ,@(LOOP FOR (NIL V1 V2) IN INDETERMINACY-BUFFERS
		       COLLECT `(,V1 NIL)
		       COLLECT `(,V2 NIL))
	       ,@(COND ((NOT DEFAULT) `())
		       (DEFAULT-IS-A-LIST `((DEFAULT-METHODS NIL)))
		       (T `((DEFAULT-METHOD NIL))))
	       ,@ARGLIST
	       (EXTRANEOUS-METHODS NIL))
	   ;; Error-check and standardize the order parameters
	   ,@(LOOP FOR (VAR PRINTER FILTER ORDER . PATTERNS) IN METHOD-PATTERNS
		   DO (IGNORE VAR PRINTER FILTER PATTERNS)
		      (WHEN (KEYWORDP ORDER)
			(VERIFY-METHOD-COMBINATION-ORDER ORDER NAME))	;issue warning
		   UNLESS (MEMBER ORDER '(:MOST-SPECIFIC-FIRST :MOST-SPECIFIC-LAST
					  :BASE-FLAVOR-FIRST :BASE-FLAVOR-LAST))
		     UNLESS (MEMBER ORDER ALREADY-DONE :TEST #'EQUAL)
		       COLLECT (LET ((VERIFY `(VERIFY-METHOD-COMBINATION-ORDER
						 ,ORDER ',NAME GENERIC FLAVOR)))
				 (IF (SYMBOLP ORDER) `(SETQ ,ORDER ,VERIFY) VERIFY))
		       AND COLLECT ORDER INTO ALREADY-DONE)
	   ;; Iterate over the methods supplied, matching each against the patterns,
	   ;; and collecting them in the appropriate variables.
	   (LOOP FOR METHOD IN COMPONENT-METHOD-LIST
		 AS METHOD-PATTERN = (AND (EQ (METHOD-TYPE METHOD) 'FLAVOR:METHOD)
					  (METHOD-OPTIONS METHOD)) DO
	     (COND ((MEMBER (METHOD-TYPE METHOD) *INTERNAL-METHOD-TYPES*))	;skip these
		   ,@(LOOP FOR (VAR PRINTER FILTER ORDER . PATTERNS) IN METHOD-PATTERNS
			   AS INDETERMINACY = (ASSOC VAR INDETERMINACY-BUFFERS)
			   DO (IGNORE PRINTER)
			      (WHEN (EQ ORDER ':BASE-FLAVOR-LAST)
				(SETQ ORDER ':MOST-SPECIFIC-FIRST))
			      (WHEN (EQ ORDER ':BASE-FLAVOR-FIRST)
				(SETQ ORDER ':MOST-SPECIFIC-LAST))
			   COLLECT
			     `((OR ,@(LOOP FOR PATTERN IN PATTERNS
					   UNLESS (EQ PATTERN ':DEFAULT)
					     COLLECT (MATCH-METHOD-PATTERN PATTERN
									   INDETERMINACY)))
			       ,(CASE FILTER
				  ((:EVERY :REMOVE-DUPLICATES)
				   `(PUSH METHOD ,VAR))
				  ((:FIRST)
				   (CASE ORDER
				     ((:MOST-SPECIFIC-FIRST)
				      `(SETQ ,VAR METHOD))
				     ((:MOST-SPECIFIC-LAST)
				      `(WHEN (NULL ,VAR)
					 (SETQ ,VAR METHOD)))
				     (OTHERWISE
				      `(WHEN (OR (EQ ,ORDER ':MOST-SPECIFIC-FIRST)
						 (NULL ,VAR))
					 (SETQ ,VAR METHOD)))))
				  ((:LAST)
				   (CASE ORDER
				     ((:MOST-SPECIFIC-LAST)
				      `(SETQ ,VAR METHOD))
				     ((:MOST-SPECIFIC-FIRST)
				      `(WHEN (NULL ,VAR)
					 (SETQ ,VAR METHOD)))
				     (OTHERWISE
				      `(WHEN (OR (EQ ,ORDER ':MOST-SPECIFIC-LAST)
						 (NULL ,VAR))
					 (SETQ ,VAR METHOD)))))))
			   WHEN (MEMBER ':DEFAULT PATTERNS)
			     COLLECT
			       `(,(MATCH-METHOD-PATTERN '(:DEFAULT) INDETERMINACY)
				 ,(CASE FILTER
				    ((:EVERY :REMOVE-DUPLICATES)
				     `(PUSH METHOD DEFAULT-METHODS))
				    ((:FIRST)
				     (CASE ORDER
				       ((:MOST-SPECIFIC-FIRST)
					`(SETQ DEFAULT-METHOD METHOD))
				       ((:MOST-SPECIFIC-LAST)
					`(WHEN (NULL DEFAULT-METHOD)
					   (SETQ DEFAULT-METHOD METHOD)))
				       (OTHERWISE
					`(WHEN (OR (EQ ,ORDER ':MOST-SPECIFIC-FIRST)
						   (NULL DEFAULT-METHOD))
					   (SETQ DEFAULT-METHOD METHOD)))))
				    ((:LAST)
				     (CASE ORDER
				       ((:MOST-SPECIFIC-LAST)
					`(SETQ DEFAULT-METHOD METHOD))
				       ((:MOST-SPECIFIC-FIRST)
					`(WHEN (NULL DEFAULT-METHOD)
					   (SETQ DEFAULT-METHOD METHOD)))
				       (OTHERWISE
					`(WHEN (OR (EQ ,ORDER ':MOST-SPECIFIC-LAST)
						   (NULL DEFAULT-METHOD))
					   (SETQ DEFAULT-METHOD METHOD))))))))
		   (ERROR-P
		    (COMPLAIN-ABOUT-EXTRANEOUS-METHOD METHOD METHOD-COMBINATION
		      ',(LOOP FOR (VAR PRINTER FILTER ORDER . PATTERNS) IN METHOD-PATTERNS
			      DO (IGNORE VAR PRINTER FILTER ORDER)
			      NCONC (LOOP FOR PATTERN IN PATTERNS
					  COLLECT (IF (EQ PATTERN ':DEFAULT)
						      (LIST PATTERN)
						      PATTERN)))))
		   (T (PUSH METHOD EXTRANEOUS-METHODS))))
	   ;; Insert default methods as required
	   ,@(WHEN DEFAULT
	       `((WHEN (NULL ,DEFAULT)
		   (SETQ ,DEFAULT ,(IF DEFAULT-IS-A-LIST
				       `DEFAULT-METHODS
				       `DEFAULT-METHOD)))))
	   ;; Reverse any lists collected in the wrong order
	   ;; Also remove duplicates as directed
	   ,@(LOOP FOR (VAR PRINTER FILTER ORDER . PATTERNS) IN METHOD-PATTERNS
		   DO (IGNORE PRINTER PATTERNS)
		   WHEN (MEMBER FILTER '(:EVERY :REMOVE-DUPLICATES))
		     UNLESS (MEMBER ORDER '(:MOST-SPECIFIC-FIRST :BASE-FLAVOR-LAST))
		       COLLECT (IF (MEMBER ORDER '(:MOST-SPECIFIC-LAST :BASE-FLAVOR-FIRST))
				   `(SETQ ,VAR (NREVERSE ,VAR))
				   `(WHEN (EQ ,ORDER ':MOST-SPECIFIC-LAST)
				      (SETQ ,VAR (NREVERSE ,VAR))))
		   WHEN (EQ FILTER ':REMOVE-DUPLICATES)
		     COLLECT `(SETQ ,VAR (DELETE-DUPLICATES ,VAR :FROM-END T
								 :TEST #'EQUAL
								 :KEY #'METHOD-OPTIONS)))
	   ;; Finally, return the desired result
	   (VALUES ,(IF (= (LENGTH BODY) 1)
			(FIRST BODY)
			`(PROGN ,@BODY))
		   (APPEND ,@(LOOP FOR (VAR PRINTER FILTER ORDER) IN ORDERED-PATTERNS
				   DO (IGNORE PRINTER ORDER)
				   COLLECT (IF (MEMBER FILTER '(:FIRST :LAST))
					       `(AND ,VAR (LIST ,VAR))
					       VAR))
			   EXTRANEOUS-METHODS)))))
    (AND TRANSFORMER
	 (MAKE-METHOD-COMBINATION-TRANSFORMER NAME PARAMETERS TRANSFORMER)))))

(DEFUN MAKE-METHOD-COMBINATION-PRINT-FUNCTION (NAME METHOD-PATTERNS)
  ;; Build a function that matches a function-spec against each of the method-patterns
  ;; in order, and uses the appropriate print specification for the first match.
  ;; We assume that the print specifications don't care about the particular generic
  ;; and flavor, and that we don't need to bind the parameter variables.
  `(DEFUN (:PROPERTY ,NAME METHOD-COMBINATION-PRINTER) (METHOD-COMBINATION FUNCTION-SPEC)
     (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-METHOD-COMBINATION))
     (IGNORE METHOD-COMBINATION)
     (LET ((METHOD-PATTERN (AND (EQ (METHOD-TYPE FUNCTION-SPEC) 'FLAVOR:METHOD)
				(METHOD-OPTIONS FUNCTION-SPEC))))
       (COND ((MEMBER (METHOD-TYPE FUNCTION-SPEC) *INTERNAL-METHOD-TYPES*))	;skip these
	     ,@(LOOP FOR (VAR PRINTER FILTER ORDER . PATTERNS) IN METHOD-PATTERNS
		     DO (IGNORE VAR FILTER ORDER)
		     COLLECT `((OR ,@(LOOP FOR PATTERN IN PATTERNS
					   UNLESS (EQ PATTERN ':DEFAULT)
					     COLLECT (MATCH-METHOD-PATTERN PATTERN NIL)))
			       ,(IF (STRINGP PRINTER)
				    `(APPLY #'PRINT-METHOD-SPEC-1 ,PRINTER FUNCTION-SPEC
					    (METHOD-OPTIONS FUNCTION-SPEC))
				    `(,PRINTER METHOD-COMBINATION FUNCTION-SPEC)))
		     WHEN (MEMBER ':DEFAULT PATTERNS)
		       COLLECT `(,(MATCH-METHOD-PATTERN '(:DEFAULT) NIL)
				 (PRINT-METHOD-SPEC-1 "default" FUNCTION-SPEC)))
	     (T (FORMAT T "~S [extraneous for ~S method-combination]"
			FUNCTION-SPEC METHOD-COMBINATION))))))

(DEFPROP METHOD-COMBINATION-TRANSFORMER-KEYWORDS T SI:DEBUG-INFO)

(DEFUN MAKE-METHOD-COMBINATION-TRANSFORMER (NAME PARAMETERS CLAUSES)
  (LET ((METHOD-ARGLIST `METHOD-ARGLIST)
	(METHOD-BODY `METHOD-BODY)
	(GENERIC-METHOD-ARGLIST `GENERIC-METHOD-ARGLIST)
	(INHIBIT-CHECKING NIL))
    (DOLIST (CLAUSE CLAUSES)
      (UNLESS (= (LENGTH CLAUSE) 2)
	(WARN "~S is an illegal :METHOD-TRANSFORMER clause.
A clause must consist of a keyword and a form." CLAUSE))
      (CASE (FIRST CLAUSE)
	(:METHOD-ARGLIST (SETQ METHOD-ARGLIST (SECOND CLAUSE)))
	(:METHOD-BODY (SETQ METHOD-BODY (SECOND CLAUSE)))
	(:GENERIC-METHOD-ARGLIST (SETQ GENERIC-METHOD-ARGLIST (SECOND CLAUSE)))
	(:INHIBIT-CHECKING (SETQ INHIBIT-CHECKING (SECOND CLAUSE)))
	(OTHERWISE (WARN "~S is an illegal :METHOD-TRANSFORMER clause.
The keyword ~S is not one of :METHOD-ARGLIST, :METHOD-BODY,
:GENERIC-METHOD-ARGLIST, or :INHIBIT-CHECKING.  The clause will be ignored."
			 CLAUSE (FIRST CLAUSE)))))
    (MULTIPLE-VALUE-BIND (VARIABLES IGNORE PARAMETERS)
	(LT:LAMBDA-LIST-ARGUMENTS PARAMETERS)
      `(DEFUN (:PROPERTY ,NAME METHOD-COMBINATION-METHOD-TRANSFORMER)
	      (FUNCTION-SPEC METHOD-COMBINATION
	       METHOD-ARGLIST METHOD-BODY GENERIC-METHOD-ARGLIST
	       &AUX (METHOD-COMBINATION-PARAMETERS (CDR METHOD-COMBINATION)))
	 (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-METHOD-COMBINATION)
		  (VALUES METHOD-ARGLIST METHOD-BODY GENERIC-METHOD-ARGLIST INHIBIT-CHECKING)
		  (METHOD-COMBINATION-TRANSFORMER-KEYWORDS ,@(MAPCAR #'CAR CLAUSES)))
	 (LET ((GENERIC (METHOD-GENERIC FUNCTION-SPEC))
	       (FLAVOR (METHOD-FLAVOR FUNCTION-SPEC)))
	   (IGNORE FUNCTION-SPEC GENERIC FLAVOR	;user code can look at them if it likes
		   METHOD-ARGLIST METHOD-BODY GENERIC-METHOD-ARGLIST)
	   ;; The &AUX variable METHOD-COMBINATION-PARAMETERS exists solely to control the
	   ;; error message produced by DESTRUCTURING-BIND if the pattern doesn't match.
	   (DESTRUCTURING-BIND ,PARAMETERS METHOD-COMBINATION-PARAMETERS
	     (IGNORE ,@VARIABLES)
	     (VALUES ,METHOD-ARGLIST ,METHOD-BODY ,GENERIC-METHOD-ARGLIST ,INHIBIT-CHECKING)
	     ))))))

;;;; Compile-time support for above defining forms

;;; Build code to do pattern-matching
(DEFUN MATCH-METHOD-PATTERN (PATTERN INDETERMINACY)
  (LET* ((LEN (LENGTH PATTERN))
	 (TEST (IF (NULL (CDR (LAST PATTERN)))		;If not a dotted list
		   (IF (NOT (MEMBER '* PATTERN))
		       `(EQUAL METHOD-PATTERN ',PATTERN)
		       `(AND (= (LENGTH METHOD-PATTERN) ,LEN)
			     ,@(LOOP FOR ITEM IN PATTERN AND I FROM 0
				     UNLESS (EQ ITEM '*)
				       COLLECT `(EQUAL (NTH ,I METHOD-PATTERN)
						       ',ITEM))))
		   ;; Dotted
		   `(AND ( (LENGTH METHOD-PATTERN) ,LEN)
			 ,@(LOOP WHILE (LISTP PATTERN)
				 FOR I FROM 0
				 AS ITEM = (POP PATTERN)
				 UNLESS (EQ ITEM '*)
				   COLLECT `(EQUAL (NTH ,I METHOD-PATTERN)
						   ',ITEM))
			 ,@(UNLESS (EQ PATTERN '*)
			     `((EQUAL (NTHCDR ,LEN METHOD-PATTERN)
				      ',PATTERN)))))))
    (IF INDETERMINACY
	`(WHEN ,TEST
	   (WHEN ERROR-P
	     ;; Check for ambiguity, where the same flavor contributes more than one
	     ;; method to the same list via different patterns (i.e. no wildcard patterns).
	     ;; The ordering of these methods is indeterminate.
	     ;; Usually this indicates someone screwed up changing the name of a method
	     ;; e.g. from untyped to :LIST.
	     (CHECK-FOR-METHOD-ORDER-INDETERMINACY ,(SECOND INDETERMINACY)
						   ,(THIRD INDETERMINACY)
						   METHOD
						   ',PATTERN)
	     (SETQ ,(SECOND INDETERMINACY) METHOD
		   ,(THIRD INDETERMINACY) ',PATTERN))
	   ;; Return T as result of test since the pattern matched
	   T)
	TEST)))

(DEFUN WILD-PATTERN (PATTERN)
  (OR (LOOP UNTIL (ATOM PATTERN) THEREIS (EQ (POP PATTERN) '*))
      (EQ PATTERN '*)))


;;; Make code prettier so we can easily recognize the case where we don't
;;; really need a combined method after all.  This way the individual
;;; method-combination routines don't have to worry about this.  Add new
;;; special-cases to this function as they arise.
(DEFUN SIMPLIFY-COMBINED-METHOD-BODY (FORM)
  (COND ((ATOM FORM) FORM)
	((EQ (CAR FORM) 'MULTIPLE-VALUE-PROG1)
	 ;; Simplify the elements of the form in case some turn into NIL
	 ;; Then strip redundant NILs and remove MULTIPLE-VALUE-PROG1 if no values to be saved
	 (LET ((FIRST (SIMPLIFY-COMBINED-METHOD-BODY (CADR FORM)))
	       (FORMS (DELETE NIL (MAPCAR #'SIMPLIFY-COMBINED-METHOD-BODY (CDDR FORM)))))
	   (WHEN (AND (NULL (CDR FORMS))
		      (LISTP (CAR FORMS))
		      (EQ (CAAR FORMS) 'PROGN))
	     (SETQ FORMS (CDAR FORMS)))
	   (COND ((NULL FORMS) FIRST)
		 ((NULL FIRST) (SIMPLIFY-COMBINED-METHOD-BODY `(PROGN ,@FORMS NIL)))
		 (T `(MULTIPLE-VALUE-PROG1 ,FIRST ,@FORMS)))))
	((EQ (CAR FORM) 'PROGN)
	 ;; Simplify the elements of a PROGN, then remove redundant NILs and PROGNs
	 (PROGNIFY (LOOP FOR (FORM . FOR-EFFECT) ON (CDR FORM)
			 DO (SETQ FORM (SIMPLIFY-COMBINED-METHOD-BODY FORM))
			 UNLESS (AND (NULL FORM) FOR-EFFECT)
			   WHEN (AND (LISTP FORM) (EQ (CAR FORM) 'PROGN))
			     APPEND (CDR FORM)
			 ELSE COLLECT FORM)))
	((EQ (CAR FORM) 'OR)
	 ;; Simplify the elements of an OR, then remove redundant NILs from the front
	 (PROGNIFY (LOOP FOR (FORM . MORE) ON (CDR FORM)
			 DO (SETQ FORM (SIMPLIFY-COMBINED-METHOD-BODY FORM))
			 UNLESS (AND (NULL FORM) MORE)
			   COLLECT FORM)
		   'OR))
	((EQ (CAR FORM) 'AND)
	 ;; Simplify the elements of an AND.  NILs aren't redundant.
	 (PROGNIFY (MAPCAR #'SIMPLIFY-COMBINED-METHOD-BODY (CDR FORM))
		   'AND))
	((EQ (CAR FORM) 'MULTIPLE-VALUE-PROG2)
	 ;; Expand these since they may turn into a PROGN
	 (SIMPLIFY-COMBINED-METHOD-BODY (MACROEXPAND-1 FORM)))
	(T FORM)))

;;; If this form is a call to a method, the function spec of the method, else NIL
(DEFUN METHOD-CALL-P (FORM &AUX FUNCTION-SPEC-FORM GET-MAPPING-TABLE-FORM)
  ;; We are looking for a form like
  ;; (,(IF *COMBINED-METHOD-APPLY* 'APPLY 'FUNCALL)
  ;;  (FUNCTION . *)
  ;;  ,@(FEATURE-CASE
  ;;      (3600. '(SELF (GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE *) .GENERIC.))
  ;;      (:IMACH '((GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE *) SELF)))
  ;;  . ,*COMBINED-METHOD-ARGUMENTS*)
  (AND (LISTP FORM)
       (EQ (POP FORM) (IF *COMBINED-METHOD-APPLY* 'APPLY 'FUNCALL))
       (LISTP (SETQ FUNCTION-SPEC-FORM (POP FORM)))
       (EQ (FIRST FUNCTION-SPEC-FORM) 'FUNCTION)
       (FEATURE-CASE
	 (3600.
	   (AND (EQ (POP FORM) 'SELF)
		(LISTP (SETQ GET-MAPPING-TABLE-FORM (POP FORM)))
		(EQ (FIRST GET-MAPPING-TABLE-FORM) 'GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE)
		(EQ (POP FORM) '.GENERIC.)))
	 (:IMACH
	   (AND (LISTP (SETQ GET-MAPPING-TABLE-FORM (POP FORM)))
		(EQ (FIRST GET-MAPPING-TABLE-FORM) 'GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE)
		(EQ (POP FORM) 'SELF))))
       (EQUAL FORM *COMBINED-METHOD-ARGUMENTS*)
       ;; Return the method function spec
       (SECOND FUNCTION-SPEC-FORM)))

;;;; Runtimes for method-combination routines

;;; Look for two methods from same flavor matching different patterns for same method list
;;; or matching the same pattern when the pattern doesn't contain wildcards.
(DEFUN CHECK-FOR-METHOD-ORDER-INDETERMINACY (PREVIOUS-METHOD PREVIOUS-PATTERN METHOD PATTERN)
  (WHEN (EQ (METHOD-FLAVOR METHOD) (METHOD-FLAVOR PREVIOUS-METHOD))
    (WHEN (OR (NEQ PATTERN PREVIOUS-PATTERN) (NOT (WILD-PATTERN PATTERN)))
      ;; Reduce the COND below from four clauses to three.
      (AND (MEMBER (METHOD-TYPE METHOD) *ACCESSOR-METHOD-TYPES*)
	   (NOT (MEMBER (METHOD-TYPE PREVIOUS-METHOD) *ACCESSOR-METHOD-TYPES*))
	   (ROTATEF METHOD PREVIOUS-METHOD))
      (COND ((AND (MEMBER (METHOD-TYPE METHOD) *ACCESSOR-METHOD-TYPES*)
		  (MEMBER (METHOD-TYPE PREVIOUS-METHOD) *ACCESSOR-METHOD-TYPES*))
	     (METHOD-COMBINATION-ERROR 
"Flavor ~S specifies that the generic operation ~S
is used both for ~@ ~S
and for ~@ ~S.
The intended order of combination of these actions is unclear.
Put these instance-variable accessors on different flavors, so that the order
of component flavors determines the order of combination, or eliminate one of them."
	       (METHOD-FLAVOR METHOD) (METHOD-GENERIC METHOD)
	       (METHOD-TYPE METHOD) (ACCESSOR-INSTANCE-VARIABLE METHOD)
	       (METHOD-TYPE PREVIOUS-METHOD) (ACCESSOR-INSTANCE-VARIABLE PREVIOUS-METHOD)))
	    ((MEMBER (METHOD-TYPE PREVIOUS-METHOD) *ACCESSOR-METHOD-TYPES*)
	     (METHOD-COMBINATION-ERROR 
"Flavor ~S specifies that the generic operation ~S
is used both for ~@ ~S
and for the method ~S.
The intended order of combination of these actions is unclear.
Put the instance-variable accessor and the method on different flavors, so that the
order of component flavors determines the order of combination, or eliminate one of them."
	       (METHOD-FLAVOR METHOD) (METHOD-GENERIC METHOD)
	       (METHOD-TYPE PREVIOUS-METHOD) (ACCESSOR-INSTANCE-VARIABLE PREVIOUS-METHOD)
	       METHOD))
	    (T
	     (METHOD-COMBINATION-ERROR "The intended order of combination of ~S
and ~S is unclear.
Put these methods on different flavors, so that the order of component
flavors determines the order of combination, or undefine one of them."
				METHOD PREVIOUS-METHOD))))))

(DEFUN VERIFY-METHOD-COMBINATION-ORDER (ORDER
					&OPTIONAL METHOD-COMBINATION-TYPE GENERIC FLAVOR)
  (CASE ORDER
    ((:MOST-SPECIFIC-FIRST :MOST-SPECIFIC-LAST)
      ORDER)
    ((:BASE-FLAVOR-FIRST :BASE-FLAVOR-LAST)
      (LET ((NEW (IF (EQ ORDER ':BASE-FLAVOR-FIRST) ':MOST-SPECIFIC-LAST
		     ':MOST-SPECIFIC-FIRST)))
	(WARN "~:[~2*~;~:*In ~S method combination~@[, for generic function ~S~]~
		~@[, for flavor ~S~]~%~]~
		~S is obsolete; ~S is the preferred term."
	      METHOD-COMBINATION-TYPE GENERIC FLAVOR ORDER NEW)
	NEW))
    (OTHERWISE
      (METHOD-COMBINATION-ERROR "~S is an illegal method order.~@
				Use :MOST-SPECIFIC-FIRST or :MOST-SPECIFIC-LAST."
				ORDER))))

(DEFUN PRINT-METHOD-SPEC-1 (FORMAT FUNCTION-SPEC &REST FORMAT-ARGS)
  (DW:WITH-OUTPUT-AS-PRESENTATION (:OBJECT FUNCTION-SPEC :TYPE 'FUNCTION-SPEC)
    (APPLY #'FORMAT T FORMAT FORMAT-ARGS)))


;;; Convenience macro that method-combination routines can put in
;;; the body of the combined method
(DEFMACRO MULTIPLE-VALUE-PROG2 (BEFORE RESULT &REST AFTER)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(PROGN ,BEFORE
	  (MULTIPLE-VALUE-PROG1 ,RESULT
				,@AFTER)))

;;; Allows a combined method to check whether the instance was transformed
;;; after the method dispatch and before locking a lock.
;;; This pseudo-macro can only validly be called from a combined method; typically
;;; from the expansion of a wrapper or a whopper-subst.
(DEFUN COMBINED-METHOD-FLAVOR ()
  (ERROR "COMBINED-METHOD-FLAVOR can only validly be called from a combined method"))

;;; Generate calls to a list of methods
(DEFUN CALL-COMPONENT-METHODS (FUNCTION-SPEC-LIST &KEY (OPERATOR 'PROGN))
  `(,OPERATOR
    ,@(LOOP FOR FUNCTION-SPEC IN FUNCTION-SPEC-LIST
	    COLLECT (CALL-COMPONENT-METHOD FUNCTION-SPEC))))

;;; Generate a form that calls a single method
;;; With no keyword arguments, passes on the combined method's arguments
;;; With :ARGLIST, uses that instead
;;; With :ARGLIST and :APPLY T, uses APPLY instead of FUNCALL
;;; With just :APPLY, it is the single argument to apply to (even if value is NIL)
(DEFUN CALL-COMPONENT-METHOD (FUNCTION-SPEC
			      &KEY (APPLY NIL APPLY-P)
				   (ARGLIST (IF APPLY-P
						(PROG1 (LIST APPLY) (SETQ APPLY T))
						(PROG1 *COMBINED-METHOD-ARGUMENTS*
						       (SETQ APPLY *COMBINED-METHOD-APPLY*))))
			      &AUX (CALL (IF APPLY 'APPLY 'FUNCALL)))
  ;; You are allowed to have no primary method, so if the FUNCTION-SPEC is NIL
  ;; don't generate any code.  I never liked this HIC feature, but that's the way it is.
  (WHEN FUNCTION-SPEC
    ;; In case the METHOD-COMBINATION function went nuts
    (UNLESS (AND (LISTP FUNCTION-SPEC)
		 (MEMBER (METHOD-TYPE FUNCTION-SPEC) *CALLABLE-METHOD-TYPES*))
      (ERROR "~S is not a method or accessor function spec." FUNCTION-SPEC))
    ;; Dispatch on type of handler
    (ECASE (METHOD-TYPE FUNCTION-SPEC)
      (FLAVOR:METHOD
	;; Build the form to call it
	(FEATURE-CASE
	  (3600.
	    `(,CALL #',FUNCTION-SPEC
	      ;; First the "hidden" arguments not in the DEFMETHOD argument list
	      SELF 
	      (GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE SELF ',(METHOD-FLAVOR FUNCTION-SPEC))
	      .GENERIC.	;This b.d. should go away (fixed on the I-Machine)
	      ;; Now the "visible" arguments, controlled by our keyword arguments
	      ,@ARGLIST))
	  (:IMACH
	    `(,CALL #',FUNCTION-SPEC
	      ;; First the "hidden" arguments not in the DEFMETHOD argument list
	      (GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE SELF ',(METHOD-FLAVOR FUNCTION-SPEC))
	      SELF
	      ;; Now the "visible" arguments, controlled by our keyword arguments
	      ,@ARGLIST)))
	)
      (READ-INSTANCE-VARIABLE
	;; Build the form to read the instance variable
	(ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC))
      (LOCATE-INSTANCE-VARIABLE
	;; Build the form to locate the instance variable
	`(LOCF ,(ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)))
      (WRITE-INSTANCE-VARIABLE
	;; Build the form to write the instance variable
	`(SETQ ,(ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)
	       ,(IF (AND APPLY (NULL (CDR ARGLIST)))
		    `(FIRST ,(FIRST ARGLIST))
		    (FIRST ARGLIST)))))))

;;;; Routines for inline method combination

;--- This may change later, to use .DAEMON-CALLER-ARGS. less often
;--- to avoid APPLY overhead even when not using INLINE methods
(DEFUN DECIDE-COMBINED-METHOD-ARGLIST (GENERIC COMPONENT-METHOD-LIST ENV)
  (DECLARE (VALUES VARIABLES APPLY LAMBDA-LIST))
  (IGNORE COMPONENT-METHOD-LIST)		;not needed currently
  (LET ((GF (FIND-GENERIC-FUNCTION GENERIC T ENV)))
    (IF (GENERIC-FUNCTION-INLINE-METHODS GF)
	(LT:LAMBDA-LIST-ARGUMENTS (GENERIC-FUNCTION-METHOD-ARGLIST GF))
	(VALUES `(.DAEMON-CALLER-ARGS.) T `(&REST .DAEMON-CALLER-ARGS.)))))

(DEFUN SUBST-COMBINED-METHOD (FLAVOR-NAME BODY-FORM ENV)
  (DECLARE (VALUES BODY-FORM INLINED-METHODS INLINED-METHOD-SOURCES))
  ;; Translate each call-component-method in body-form by inlining the method.
  (LET ((INLINED-METHODS NIL)
	(INLINED-METHOD-SOURCES NIL))
    (VALUES (LT:COPYFORMS #'(LAMBDA (SUBFORM KIND USAGE)
			      (IGNORE USAGE)
			      (COND ((NLISTP KIND) SUBFORM)	;Not a function combination
				    ((AND (MEMBER (FIRST SUBFORM) '(APPLY FUNCALL))
					  (LISTP (SECOND SUBFORM))
					  (EQ (FIRST (SECOND SUBFORM)) 'FUNCTION)
					  (LISTP (SECOND (SECOND SUBFORM)))
					  (EQ (FIRST (SECOND (SECOND SUBFORM))) 'METHOD)
					  (FEATURE-CASE
					    (3600.
					      (AND (EQ (THIRD SUBFORM) 'SELF)
						   (LISTP (FOURTH SUBFORM))
						   (EQ (FIRST (FOURTH SUBFORM))
						       'GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE)
						   (EQ (FIFTH SUBFORM) '.GENERIC.)))
					    (:IMACH
					      (AND (LISTP (THIRD SUBFORM))
						   (EQ (FIRST (THIRD SUBFORM))
						       'GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE)
						   (EQ (FOURTH SUBFORM) 'SELF)))))
				     ;; Inline a method invocation
				     (MULTIPLE-VALUE-BIND (FORM I-M I-M-S)
					 (SUBST-COMPONENT-METHOD SUBFORM
								 (SECOND (SECOND SUBFORM))
								 (NTHCDR
								   (FEATURE-CASE
								     (3600. 5)
								     (:IMACH 4.))
								   SUBFORM)
								 (EQ (FIRST SUBFORM) 'APPLY)
								 FLAVOR-NAME ENV)
				       (SETQ INLINED-METHODS (NCONC INLINED-METHODS I-M)
					     INLINED-METHOD-SOURCES
					       (NCONC INLINED-METHOD-SOURCES I-M-S))
				       (VALUES FORM T)))
				    ((EQ (CAR SUBFORM) 'DESTRUCTURING-BIND)
				     (VALUES (MACROEXPAND SUBFORM
					       LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*)
					     NIL))
				    (T SUBFORM)))
			  BODY-FORM)
	      INLINED-METHODS
	      INLINED-METHOD-SOURCES)))

(DEFUN SUBST-COMPONENT-METHOD (SUBFORM METHOD ARGUMENTS APPLY FLAVOR-NAME ENV)
  (DECLARE (VALUES FORM INLINED-METHODS INLINED-METHOD-SOURCES))
  ;; Slight bug here in that if it's been deleted from the
  ;; compile-time environment, the runtime def won't be ignored
  (LET ((SUBST-DEFINITION (LT:FIND-INLINE-FORM-METHOD METHOD)))
    (WHEN (NULL SUBST-DEFINITION)
      ;; Don't optimize if don't know how
      (RETURN-FROM SUBST-COMPONENT-METHOD (VALUES SUBFORM NIL NIL)))
    ;; Subroutine called in two places below
    ;; Exist mainly to deal with the possibility that LT:EXPAND-INLINE-FORM can give
    ;; up and simply return its second argument
    (FLET ((EXPAND-INLINE (METHOD FUNCTION ARGUMENTS APPLY)
	     (LET* ((PSEUDO-FORM `(,FUNCTION ,@ARGUMENTS))
		    (NEW-FORM (LT:EXPAND-INLINE-FORM
				METHOD PSEUDO-FORM NIL
				:APPLY APPLY
				:SUPPRESS-WARNINGS-FOR-LEGAL-LISP T)))
	       (WHEN (EQ NEW-FORM PSEUDO-FORM)
		 (RETURN-FROM SUBST-COMPONENT-METHOD (VALUES SUBFORM NIL NIL)))
	       NEW-FORM)))      
      ;; Convert the form to call the method into a form that is the body of the method then
      ;; look for recursive calls to inlineable generics and expand them, too.
      (LET ((INLINED-METHODS (NCONS METHOD))
	    ;; Save only the form, not the LT:INLINE-FORM structure, because EQUAL
	    ;; doesn't know how to compare those structures and anyway we don't
	    ;; care about the rest of the information in them.
	    (INLINED-METHOD-SOURCES
	      (NCONS (LT::INLINE-FORM-FORM SUBST-DEFINITION)))
	    ;; These variables are never modified.
	    ;; This is necessary for :inline-methods :recursive to work.
	    (LT:*SIMPLE-VARIABLES*
	      (FEATURE-CASE
	        (3600. '(SELF SELF-MAPPING-TABLE .GENERIC.))
		(:IMACH '(SELF-MAPPING-TABLE SELF)))))
	(VALUES
	  (LT:COPYFORMS
	    #'(LAMBDA (SUBFORM KIND USAGE)
		(IGNORE USAGE)
		(COND ((NLISTP KIND) SUBFORM)	;Not a function combination
		      ((AND (SYMBOLP (CAR SUBFORM))
			    (EQ (CADR SUBFORM) 'SELF)
			    (LET ((GF (FIND-GENERIC-FUNCTION (CAR SUBFORM) NIL ENV)))
			      (AND GF
				   (NOT (GENERIC-FUNCTION-MESSAGE-P GF))
				   (GENERIC-FUNCTION-INLINE-RECURSIVE-METHODS GF))))
		       ;; Inline a recursive generic inside this method
		       (MULTIPLE-VALUE-BIND (FORM HANDLER I-M I-M-S LAMBDA-LIST IGNORE ERROR)
			   (COMPOSE-HANDLER-SOURCE (CAR SUBFORM) FLAVOR-NAME :ENV ENV)
			 (IF ERROR SUBFORM
			     (MULTIPLE-VALUE-BIND (*COMBINED-METHOD-ARGUMENTS*
						   *COMBINED-METHOD-APPLY*
						   *COMBINED-METHOD-LAMBDA-LIST*)
				 (LT:LAMBDA-LIST-ARGUMENTS LAMBDA-LIST)
			       (SETQ INLINED-METHODS (NCONC INLINED-METHODS I-M)
				     INLINED-METHOD-SOURCES
				     (NCONC INLINED-METHOD-SOURCES I-M-S))
			       (MULTIPLE-VALUE-BIND (FORM I-M I-M-S)
				   (SUBST-COMBINED-METHOD FLAVOR-NAME
							  (OR FORM
							      (CALL-COMPONENT-METHOD HANDLER))
							  ENV)
				 (SETQ INLINED-METHODS (NCONC INLINED-METHODS I-M)
				       INLINED-METHOD-SOURCES
				       (NCONC INLINED-METHOD-SOURCES I-M-S))
				 (MULTIPLE-VALUE-BIND (BLOCK-NAME FOUNDP)
				     (SI:DIVINE-SUITABLE-BLOCK-NAME HANDLER)
				   (EXPAND-INLINE
				     (IF FOUNDP
					 (LT:CONSTRUCT-INLINE-FORM
					   HANDLER *COMBINED-METHOD-LAMBDA-LIST*
					   (LIST FORM) NIL
					   :BLOCK-NAME BLOCK-NAME)
					 (LT:CONSTRUCT-INLINE-FORM
					   HANDLER *COMBINED-METHOD-LAMBDA-LIST*
					   (LIST FORM) NIL))				       
				     HANDLER
				     (CDDR SUBFORM)
				     *COMBINED-METHOD-APPLY*)))))))
		      (T SUBFORM)))
	    (EXPAND-INLINE SUBST-DEFINITION METHOD
			   ;; This is to deal with compatibility with older code which
			   ;; didn't put SELF and SELF-MAPPING-TABLE into the lambda list.
			   (FEATURE-CASE
			    (3600.
			      (IF (EQ (FIRST (LT::INLINE-FORM-LAMBDA-LIST SUBST-DEFINITION))
				      'SELF)
				  `(SELF
				     (GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE SELF ',FLAVOR-NAME)
				     .GENERIC.
				     ,@ARGUMENTS)
				  ARGUMENTS))
			    (:IMACH
			      (IF (EQ (FIRST (LT::INLINE-FORM-LAMBDA-LIST SUBST-DEFINITION))
				      'SELF-MAPPING-TABLE)
				  `((GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE SELF ',FLAVOR-NAME)
				    SELF
				    ,@ARGUMENTS)
				  ARGUMENTS)))
			   APPLY))
	  INLINED-METHODS
	  INLINED-METHOD-SOURCES)))))

;;;; Next level up of interface -- independent of the type of method-combination

;;; Each combined method has this on its debugging-info, so we know where it came from
;;; List of METHOD-COMBINATION, COMBINED-METHOD-LIST, and wrapper sources
;;; Wrapper sources includes anything that can be compared with EQUAL to verify the
;;; applicability of this combined method, including wrapper sources, inlined method
;;; sources, and combined-method-flavor notations
(DEFPROP COMBINED-METHOD-DERIVATION T SI:DEBUG-INFO)

(DEFVAR *MAKE-COMBINED-METHOD-BOOTSTRAP-GUESSES* NIL)

(DEFUN MAKE-COMBINED-METHOD (GENERIC FLAVOR-NAME METHOD-COMBINATION COMPONENT-METHOD-LIST
			     ENV IGNORE-EXISTING-METHOD)
  (DECLARE (VALUES FUNCTION-SPEC DEFUN))
  ;; Bootstrapping kludge: when inline-methods are involved, we can't even figure out
  ;; the derivation of the combined method until the entire compiler is loaded, including
  ;; all macros and special forms and the language tools.  In this case, we must assume
  ;; that whatever was compiled was correct.  This applies to whopper-substs too.
  (WHEN (AND (NULL ENV)
	     (NOT (VARIABLE-BOUNDP #'COMPILE))
	     (OR (GENERIC-FUNCTION-INLINE-METHODS (FIND-GENERIC-FUNCTION GENERIC))
		 (MEMBER 'WRAPPER COMPONENT-METHOD-LIST :KEY #'METHOD-TYPE)))
    ;; The handler will be a combined method because of the inline method or wrapper,
    ;; unless the inline method declaration is ignored because there is only one
    ;; method (after shadowing).  We have to assume that this decision was made correctly
    ;; at compile time.  Either way, there may be whoppers around the basic handler.
    ;; The FINDs are :FROM-END in order to find the most specific method.
    (LET ((COMBINED-METHOD
	    (OR (FIND 'COMBINED COMPONENT-METHOD-LIST :KEY #'METHOD-TYPE :FROM-END T)
		(FIND 'NCWHOPPER COMPONENT-METHOD-LIST :TEST-NOT #'EQ
						       :KEY #'METHOD-TYPE :FROM-END T)
		(ERROR "MAKE-COMBINED-METHOD bootstrapping kludge: can't find method in ~S"
		       COMPONENT-METHOD-LIST))))
      ;; Put in any whoppers that weren't absorbed into the combined method
      ;; Whoppers are absorbed if they are followed by a wrapper
      ;; The least specific whopper goes on the inside
      (DOLIST (METHOD (LOOP WITH LIST = COMPONENT-METHOD-LIST
			    FOR (METHOD . REST) ON COMPONENT-METHOD-LIST
			    DO (WHEN (EQ (METHOD-TYPE METHOD) 'WRAPPER)
				 (SETQ LIST REST))
			    FINALLY (RETURN LIST)))
	(WHEN (EQ (METHOD-TYPE METHOD) 'NCWHOPPER)
	  (SETQ COMBINED-METHOD `(PSEUDO-COMBINED ,GENERIC ,METHOD ,COMBINED-METHOD))))
      ;; Save for later analysis
      (PUSH (LIST GENERIC FLAVOR-NAME COMBINED-METHOD)
	    *MAKE-COMBINED-METHOD-BOOTSTRAP-GUESSES*)
      (RETURN-FROM MAKE-COMBINED-METHOD COMBINED-METHOD)))
  (MULTIPLE-VALUE-BIND (BODY-FORM FUNCTION-SPEC COMBINED-METHOD-LIST WRAPPER-SOURCES
			LAMBDA-LIST NIL NIL
			*COMBINED-METHOD-ARGUMENTS* *COMBINED-METHOD-APPLY*)
      (COMBINE-METHODS GENERIC FLAVOR-NAME METHOD-COMBINATION COMPONENT-METHOD-LIST :ENV ENV)
    (LET ((DEFUN NIL)				;Function to be compiled
	  (CONTINUATION NIL)			;Function-spec of whopper continuation
	  ARRAY (N-METHODS 0) (N-AFTERS 0))
      (WHEN BODY-FORM
	;; This little kludge makes shared-combined methods work better
	(WHEN (AND (LISTP BODY-FORM)
		   (EQ (CAR BODY-FORM) 'MULTIPLE-VALUE-PROG1))
	  (SETQ BODY-FORM `(PROGN ,BODY-FORM)))
	;; Need to build a combined method, inherit a combined method,
	;; build an extra-arg vector for a shared combined method, or
	;; supply a single method as the continuation for a whopper.
	(COND ((AND FUNCTION-SPEC		;Test for single method
		    (SETQ CONTINUATION (METHOD-CALL-P BODY-FORM))))
	      ((AND (LISTP BODY-FORM)		;Does a matching shared-combined method exist
		    (SYMBOLP (CAR BODY-FORM))
		    (SETQ ARRAY (GET (CAR BODY-FORM) 'SHARED-COMBINED))
		    (LOOP FOR (FORM . REST) ON (CDR BODY-FORM) FINALLY (RETURN T) DO
		      (COND ((NULL FORM) (INCF N-METHODS))	;Missing primary method
			    ((METHOD-CALL-P FORM) (INCF N-METHODS))
			    ((AND (NULL REST)
				  (LISTP FORM)
				  (EQ (FIRST FORM) 'MULTIPLE-VALUE-PROG1)
				  (OR (NULL (SECOND FORM))	;Missing primary method
				      (METHOD-CALL-P (SECOND FORM)))
				  (EVERY #'METHOD-CALL-P (CDDR FORM)))
			     (INCF N-METHODS)	;(CADR FORM)
			     (SETQ N-AFTERS (LENGTH (CDDR FORM))))
			    (T (RETURN NIL))))	;Fails to match
		    (< N-METHODS (ARRAY-DIMENSION ARRAY 1))
		    (< N-AFTERS (ARRAY-DIMENSION ARRAY 2))
		    (LOCATION-BOUNDP (LOCF (AREF ARRAY 0 N-METHODS N-AFTERS))))
	       (SETQ CONTINUATION
		     `(PSEUDO-COMBINED ,GENERIC
				       (SHARED-COMBINED ,(CAR BODY-FORM)
							0	;--- n-args NYI
							,N-METHODS ,N-AFTERS)
				       ,@(LOOP FOR FORM IN (CDR BODY-FORM)
					       WHEN (METHOD-CALL-P FORM)
						 COLLECT IT
					       ELSE WHEN (NULL FORM)
						      COLLECT 'IGNORE
					       ;; This is a MULTIPLE-VALUE-PROG1 form
					       ELSE COLLECT (IF (SECOND FORM)
								(METHOD-CALL-P (SECOND FORM))
								'IGNORE)
						    AND NCONC (MAPCAR #'METHOD-CALL-P
								      (CDDR FORM))))))
	      (T
	       (LET* ((DERIVATION (LIST METHOD-COMBINATION
					;; Derivation does not include whoppers whopped
					;; around the combined method
					(LOOP FOR METHODS ON COMBINED-METHOD-LIST
					      FOR FSPEC = FUNCTION-SPEC THEN (FOURTH FSPEC)
					      WHILE (EQ (METHOD-TYPE FSPEC) 'PSEUDO-COMBINED)
					      DO (ASSERT (EQ (THIRD FSPEC) (FIRST METHODS)))
					      FINALLY (RETURN METHODS))
					WRAPPER-SOURCES))
		      (COMBINED-METHOD `(COMBINED ,GENERIC ,FLAVOR-NAME))
		      (ALREADY-EXISTS (HAVE-COMBINED-METHOD COMBINED-METHOD DERIVATION
							    COMPONENT-METHOD-LIST ENV
							    IGNORE-EXISTING-METHOD)))
		 (IF ALREADY-EXISTS
		     ;; Inherit a combined method
		     (SETQ CONTINUATION ALREADY-EXISTS)
		     ;; Have to define a new combined method
		     (WHEN (EQ ENV 'COMPILE)
		       (NOTICE-METHOD COMBINED-METHOD)
		       (COMPILER:FILE-DECLARE COMBINED-METHOD 'COMBINED-METHOD-DERIVATION
					      DERIVATION))
		     (SETQ CONTINUATION COMBINED-METHOD
			   DEFUN `(DEFUN ,COMBINED-METHOD
					 ,(FEATURE-CASE
					    (3600. `(SELF SELF-MAPPING-TABLE .GENERIC.
							  ,@LAMBDA-LIST))
					    (:IMACH `(SELF-MAPPING-TABLE SELF ,@LAMBDA-LIST)))
				    (DECLARE (COMBINED-METHOD-DERIVATION ,@DERIVATION)
					     ,@(FLAVOR-LOCAL-DECLARATIONS FLAVOR-NAME ENV T))
				    ;; No compiler warning if arguments unused, this shields
				    ;; local macros in the body from parse-body-declarations
				    SELF SELF-MAPPING-TABLE
				    ,(FEATURE-CASE
				      (3600. '.GENERIC.)
				      (:IMACH 'NIL))
				    ;; I shouldn't need this, but I guess certain wrappers
				    ;; would otherwise cause a compiler warning.
				    ,@(WHEN (MEMBER '.DAEMON-CALLER-ARGS. LAMBDA-LIST)
					`(.DAEMON-CALLER-ARGS.))
				    ;; Here is the real body
				    ,BODY-FORM)))))))
      ;; If FUNCTION-SPEC is a whopper call, plug in its continuation.  If there are
      ;; nested whoppers, the innermost is the one that doesn't have a continuation yet.
      (WHEN (AND FUNCTION-SPEC
		 (EQ (METHOD-TYPE FUNCTION-SPEC) 'PSEUDO-COMBINED))
	;; This loop finds the innermost in a nest of PSEUDO-COMBINED function-specs.
	(LOOP FOR FSPEC = FUNCTION-SPEC THEN (FOURTH FSPEC)
	      DO (ASSERT (EQ (METHOD-TYPE FSPEC) 'PSEUDO-COMBINED))
	      WHILE (FOURTH FSPEC)
	      FINALLY (SETF (FOURTH FSPEC) (OR CONTINUATION 'MISSING-WHOPPER-CONTINUATION))))
      (VALUES (OR FUNCTION-SPEC CONTINUATION) DEFUN))))

;;; Called when there is a whopper with nothing inside it.
;;; For now, this returns NIL, since that's what Flavors has historically done.
;;; Common Lisp Object System says this should signal an error.
#+3600
(DEFUN MISSING-WHOPPER-CONTINUATION (SELF SELF-MAPPING-TABLE .GENERIC. &REST IGNORE)
  (IGNORE SELF SELF-MAPPING-TABLE .GENERIC.)
  NIL)

#+IMACH
(DEFUN MISSING-WHOPPER-CONTINUATION (SELF-MAPPING-TABLE SELF &REST IGNORE)
  (IGNORE SELF SELF-MAPPING-TABLE)
  NIL)

;;; Having extracted all methods for this generic from all components, combine them.
;;; If a combined method has to be made or inherited or shared, the first value is
;;; its body (a form), otherwise the first value is NIL.
;;; If that combined method is to be used as the handler, the second value is NIL,
;;; otherwise the second value is a function-spec that defines the handler.  This little
;;; rigmarole is to make it easier to inherit combined methods.
;;; Note that it is possible for both of the first two values to be non-NIL, when
;;; the second value is the function spec of a whopper and the whopper's extra-arg
;;; vector includes a combined method for the whopped-around methods.  When both values
;;; are non-nil, the second value is a PSEUDO-COMBINED function-spec for a whopper and
;;; it, or the innermost one if they are nested, has NIL as its continuation.
;;; Both of the first two values can be NIL in an error situation.
;;; Further values are a list of function-specs, for the methods invoked, in the order
;;; that they are invoked; the source-code of any wrappers involved; the argument list
;;; (after the usual method arguments) for the combined method;
;;; the method-combination type and arguments (useful for interface on next level up);
;;; an error description string if ERROR-P is NIL and an error occurs;
;;; combined-method-arguments; and combined-method-apply.
(DEFUN COMBINE-METHODS (GENERIC FLAVOR-NAME METHOD-COMBINATION COMPONENT-METHOD-LIST
			&KEY (ERROR-P T) (ENV NIL))
  (DECLARE (VALUES BODY-FORM SINGLE-METHOD COMBINED-METHOD-LIST WRAPPER-SOURCES
		   LAMBDA-LIST METHOD-COMBINATION ERROR
		   COMBINED-METHOD-ARGUMENTS COMBINED-METHOD-APPLY))
  ;; Determine the arglist for the combined method
  (MULTIPLE-VALUE-BIND (*COMBINED-METHOD-ARGUMENTS* *COMBINED-METHOD-APPLY*
			*COMBINED-METHOD-LAMBDA-LIST*)
      (DECIDE-COMBINED-METHOD-ARGLIST GENERIC COMPONENT-METHOD-LIST ENV)
    (LET ((FUNCTION (GETDECL (FIRST METHOD-COMBINATION) 'METHOD-COMBINATION)))
      (COND (FUNCTION
	     ;; Call the method-combination type to combine the methods
	     (MULTIPLE-VALUE-BIND (BODY-FORM METHODS)
		 (FUNCALL FUNCTION GENERIC FLAVOR-NAME METHOD-COMBINATION
			  COMPONENT-METHOD-LIST ERROR-P)
	       ;; Collect the wrappers and wrap them around the form.  The least specific
	       ;; wrapper is first in COMPONENT-METHOD-LIST and goes on the inside,
	       ;; therefore goes earlier in the sorted SPECIAL-METHODS list.
	       (LET ((SPECIAL-METHODS
		       (STABLE-SORT
			 (REMOVE-IF-NOT #'(LAMBDA (FUNCTION-SPEC)
					    (ASSOC (METHOD-TYPE FUNCTION-SPEC)
						   *SPECIALLY-COMBINED-METHOD-TYPES*))
					COMPONENT-METHOD-LIST)
			 #'(LAMBDA (X Y)
			     (LET ((XN (THIRD (ASSOC (METHOD-TYPE X)
						     *SPECIALLY-COMBINED-METHOD-TYPES*)))
				   (YN (THIRD (ASSOC (METHOD-TYPE Y)
						     *SPECIALLY-COMBINED-METHOD-TYPES*))))
			       (OR (> XN YN)
				   (AND (= XN YN)
					(EQ (METHOD-FLAVOR X) (METHOD-FLAVOR Y))
					;; X goes before Y if X's type is after Y in *SPEC...
					;; and therefore Y is to be wrapped around X.
					(ASSOC (METHOD-TYPE X)
					       (CDR (MEMBER (METHOD-TYPE Y)
							    *SPECIALLY-COMBINED-METHOD-TYPES*
							    :KEY #'CAR)))))))))
		     (WRAPPER-SOURCES NIL)
		     (PSEUDO-COMBINED-METHOD NIL)
		     WRAPPER-SOURCE WHOPPER)
		 (DOLIST (METHOD SPECIAL-METHODS)
		   (WHEN (AND PSEUDO-COMBINED-METHOD
			      (NEQ (METHOD-TYPE METHOD) 'NCWHOPPER))
		     ;; Wrapping something around a pseudo-combined method,
		     ;; have to embed it back into the combined method body
		     (SETQ BODY-FORM (WRAP-PSEUDO-COMBINED PSEUDO-COMBINED-METHOD
							   (SIMPLIFY-COMBINED-METHOD-BODY
							     BODY-FORM)
							   FLAVOR-NAME)
			   PSEUDO-COMBINED-METHOD NIL))
		   (MULTIPLE-VALUE-SETQ (BODY-FORM WRAPPER-SOURCE WHOPPER)
		     (FUNCALL (CADR (ASSOC (METHOD-TYPE METHOD)
					   *SPECIALLY-COMBINED-METHOD-TYPES*))
			      METHOD
			      (SIMPLIFY-COMBINED-METHOD-BODY BODY-FORM)
			      ENV))
		   (WHEN WRAPPER-SOURCE
		     (PUSH WRAPPER-SOURCE WRAPPER-SOURCES))
		   (WHEN WHOPPER
		     (SETQ PSEUDO-COMBINED-METHOD
			   `(PSEUDO-COMBINED ,GENERIC ,WHOPPER ,PSEUDO-COMBINED-METHOD))))
		 ;; HANDLER is non-NIL if BODY-FORM is a single method invocation.
		 ;; There might still be a whopper around it.
		 (SETQ BODY-FORM (SIMPLIFY-COMBINED-METHOD-BODY BODY-FORM))
		 (LET ((HANDLER (AND (= (LIST-LENGTH METHODS) 1)
				     (IF (EQ (METHOD-TYPE (FIRST METHODS)) 'METHOD)
					 (METHOD-CALL-P BODY-FORM)
					 ;; Instance-variable accessors aren't recognized
					 ;; by METHOD-CALL-P, so employ a kludge
					 (AND (EQUAL BODY-FORM
						     (CALL-COMPONENT-METHOD (FIRST METHODS)))
					      (FIRST METHODS))))))
		   ;; Put the wrappers onto the method-list in the order they are called.
		   (SETQ METHODS (NRECONC SPECIAL-METHODS METHODS))
		   ;; Check for inline case
		   (WHEN (GENERIC-FUNCTION-INLINE-METHODS
			   (FIND-GENERIC-FUNCTION GENERIC T ENV))
		     (MULTIPLE-VALUE-BIND (NEW-BODY INLINED-METHODS INLINED-METHOD-SOURCES)
			 (SUBST-COMBINED-METHOD FLAVOR-NAME BODY-FORM ENV)
		       ;; Exclude case where no combined method was needed after all
		       (UNLESS (AND HANDLER (EQUAL INLINED-METHODS METHODS))
			 (SETQ METHODS (DELETE-DUPLICATES (NCONC METHODS INLINED-METHODS))
			       WRAPPER-SOURCES (DELETE-DUPLICATES
						 (NCONC WRAPPER-SOURCES
							INLINED-METHOD-SOURCES))
			       BODY-FORM NEW-BODY
			       HANDLER NIL))))
		   ;; Expand possible COMBINED-METHOD-FLAVOR macro now
		   ;; WRAPPER-SOURCES check is for bootstrapping reasons
		   (WHEN WRAPPER-SOURCES
		     (SETQ BODY-FORM
			   (LT:COPYFORMS
			     #'(LAMBDA (SUBFORM KIND USAGE)
				 (IGNORE USAGE)
				 (COND ((AND (LISTP KIND)	;function combination
					     (EQUAL SUBFORM '(COMBINED-METHOD-FLAVOR)))
					(PUSH `(COMBINED-METHOD-FLAVOR ,FLAVOR-NAME)
					      WRAPPER-SOURCES)
					`(QUOTE ,(IF (AND (EQ ENV 'COMPILE)
							  UNDO-DECLARATIONS-FLAG)
						     ;; Compiling to a file
						     (CONS COMPILER:EVAL-AT-LOAD-TIME-MARKER
							   `(FIND-FLAVOR ',FLAVOR-NAME))
						     ;; Compiling to memory
						     (FIND-FLAVOR FLAVOR-NAME))))
				       (T SUBFORM)))
			     BODY-FORM)))
		   (VALUES (AND (OR (NOT HANDLER) PSEUDO-COMBINED-METHOD)
				BODY-FORM)	;NIL if all info is in the second value
			   (OR PSEUDO-COMBINED-METHOD HANDLER)
			   METHODS WRAPPER-SOURCES *COMBINED-METHOD-LAMBDA-LIST*
			   METHOD-COMBINATION NIL
			   *COMBINED-METHOD-ARGUMENTS* *COMBINED-METHOD-APPLY*)))))
	  (T
	   (WHEN ERROR-P
	     (METHOD-COMBINATION-ERROR "~S is not a defined type of method combination."
				       METHOD-COMBINATION))
	   (VALUES NIL NIL COMPONENT-METHOD-LIST NIL NIL METHOD-COMBINATION
		   "undefined method combination"))))))

;; Embed whopper pseudo-combined methods back into the combined method body.
(DEFUN WRAP-PSEUDO-COMBINED (FUNCTION-SPEC BODY-FORM FLAVOR-NAME)
  (LET* ((VAR (GENSYM))
	 (FIRST-VAR VAR)
	 (BINDINGS
	   ;; Make one stack vector for each nested PSEUDO-COMBINED function-spec
	   (LOOP FOR FSPEC = FUNCTION-SPEC THEN CONTINUATION UNTIL (NULL FSPEC)
		 AS WHOPPER = (THIRD FSPEC)
		 AS CONTINUATION = (FOURTH FSPEC)
		 COLLECT `(,VAR
			   (VECTOR
			     ,@(IF CONTINUATION
				   `((FUNCTION ,(THIRD CONTINUATION))
				     ,(SETQ VAR (GENSYM)))
				   `((LAMBDA
				       ,(FEATURE-CASE
					  (3600. `(SELF SELF-MAPPING-TABLE .GENERIC.
							,@*COMBINED-METHOD-LAMBDA-LIST*))
					  (:IMACH `(SELF-MAPPING-TABLE SELF
						      ,@*COMBINED-METHOD-LAMBDA-LIST*)))
				       ;; Burn up variables
				       SELF SELF-MAPPING-TABLE
				       ,(FEATURE-CASE
					 (3600. '.GENERIC.)
					 (:IMACH 'NIL))
				       ,@*COMBINED-METHOD-ARGUMENTS*
				       ,BODY-FORM)
				     (GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE
				       SELF ',FLAVOR-NAME)))
			     (GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE
			       SELF ',(METHOD-FLAVOR WHOPPER)))))))
    (FEATURE-CASE
      (3600.
	`(STACK-LET* ,(NREVERSE BINDINGS)
	   (,(IF *COMBINED-METHOD-APPLY* 'APPLY 'FUNCALL)
	    #',(THIRD FUNCTION-SPEC) SELF ,FIRST-VAR .GENERIC. ,@*COMBINED-METHOD-ARGUMENTS*)))
      (:IMACH
	`(STACK-LET* ,(NREVERSE BINDINGS)
	   (,(IF *COMBINED-METHOD-APPLY* 'APPLY 'FUNCALL)
	    #',(THIRD FUNCTION-SPEC) ,FIRST-VAR SELF ,@*COMBINED-METHOD-ARGUMENTS*))))
    ))

;;;; Still higher-level interfaces

;;; Given the name of a generic and the name of a flavor, find the methods that handle
;;; that generic operation on instances of that flavor.
;;; Hypothetical assumptions can be inserted by using ENV to substitute hypothetical
;;; flavor, generic, and method definitions for the ones in the real world.
(DEFUN COMPOSE-HANDLER (GENERIC FLAVOR-NAME &KEY ENV)
  (DECLARE (VALUES HANDLER-FUNCTION-SPEC COMBINED-METHOD-LIST METHOD-COMBINATION ERROR))
  ;; Standardize name for benefit of combined-method function spec
  (SETQ GENERIC (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV))
  (LET* ((GF (FIND-GENERIC-FUNCTION GENERIC T ENV))
	 (FL (FIND-FLAVOR FLAVOR-NAME T ENV)))
    (WHEN (AND (NULL ENV) (FLAVOR-METHODS-COMPOSED FL))
      ;; Get the information already computed in the run-time environment
      (MULTIPLE-VALUE-BIND (FUNCTION PARAMETER)
	  (WITHOUT-INTERRUPTS (HANDLER-TABLE-FUNCTION-AND-PARAMETER
				FL (GENERIC-FUNCTION-SELECTOR GF)))
	(WHEN FUNCTION
	  (LET ((FUNCTION-SPEC (FUNCTION-NAME FUNCTION)))
	    (WHEN (LISTP FUNCTION-SPEC)	;Not an instance variable accessor
	      (CASE (METHOD-TYPE FUNCTION-SPEC)
		(COMBINED
		  (LET ((COMBINED-METHOD-DERIVATION
			  (ASSOC 'COMBINED-METHOD-DERIVATION (DEBUGGING-INFO FUNCTION))))
		    (RETURN-FROM COMPOSE-HANDLER
		      (VALUES FUNCTION-SPEC
			      (THIRD COMBINED-METHOD-DERIVATION)
			      (SECOND COMBINED-METHOD-DERIVATION)))))
		(SHARED-COMBINED
		  (RETURN-FROM COMPOSE-HANDLER
		    (VALUES FUNCTION-SPEC
			    (LOOP FOR METHOD BEING THE ARRAY-ELEMENTS OF PARAMETER
				      FROM 0 BY 2
				  UNLESS (EQ METHOD #'IGNORE)
				    COLLECT (FUNCTION-NAME METHOD))
			    (DECIDE-METHOD-COMBINATION GF (FLAVOR-ALL-COMPONENTS FL) ENV))))
		(NCWHOPPER )	;Too difficult to write code to recover the information
		(OTHERWISE
		  (RETURN-FROM COMPOSE-HANDLER
		    (VALUES FUNCTION-SPEC
			    (LIST FUNCTION-SPEC)
			    (DECIDE-METHOD-COMBINATION GF (FLAVOR-ALL-COMPONENTS FL) ENV))
		    ))))))))
    ;; Information not available in run-time environment, compute it
    (LET* ((ALIST (COLLECT-METHODS FLAVOR-NAME :GENERIC GENERIC
					       :ENV ENV
					       :ERROR-P NIL))
	   (METHOD-COMBINATION (SECOND (FIRST ALIST)))
	   (METHODS (CDDR (FIRST ALIST))))
      (MULTIPLE-VALUE-BIND (NIL SINGLE-METHOD COMBINED-METHOD-LIST NIL NIL NIL ERROR)
	  (COMBINE-METHODS GENERIC FLAVOR-NAME METHOD-COMBINATION METHODS
			   :ERROR-P NIL :ENV ENV)
	(IF COMBINED-METHOD-LIST
	    (VALUES (OR SINGLE-METHOD `(COMBINED ,GENERIC ,FLAVOR-NAME))
		    COMBINED-METHOD-LIST
		    METHOD-COMBINATION
		    ERROR)
	    (VALUES NIL NIL METHOD-COMBINATION
		    (FORMAT NIL "Flavor ~S does not handle generic operation ~S"
			    FLAVOR-NAME GENERIC)))))))

;;; Given the name of a generic and the name of a flavor, find the source code for
;;; the combined method that handles that generic operation on instances of that flavor.
;;; First value is NIL if no combined method is required.
;;; Hypothetical assumptions can be inserted by using ENV to substitute hypothetical
;;; flavor, generic, and method definitions for the ones in the real world.
(DEFUN COMPOSE-HANDLER-SOURCE (GENERIC FLAVOR-NAME &KEY ENV)
  (DECLARE (VALUES FORM HANDLER-FUNCTION-SPEC COMBINED-METHOD-LIST WRAPPER-SOURCES
		   LAMBDA-LIST METHOD-COMBINATION ERROR))
  ;; Standardize name for benefit of combined-method function spec
  (SETQ GENERIC (STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC ENV))
  (LET* ((ALIST (COLLECT-METHODS FLAVOR-NAME :GENERIC GENERIC
					     :ENV ENV
					     :ERROR-P NIL))
	 (METHOD-COMBINATION (SECOND (FIRST ALIST)))
	 (METHODS (CDDR (FIRST ALIST))))
    (MULTIPLE-VALUE-BIND (FORM SINGLE-METHOD COMBINED-METHOD-LIST WRAPPER-SOURCES
			  LAMBDA-LIST NIL ERROR)
	(COMBINE-METHODS GENERIC FLAVOR-NAME METHOD-COMBINATION METHODS
			 :ERROR-P NIL :ENV ENV)
      (IF COMBINED-METHOD-LIST
	  (VALUES FORM
		  (OR SINGLE-METHOD `(COMBINED ,GENERIC ,FLAVOR-NAME))
		  COMBINED-METHOD-LIST
		  WRAPPER-SOURCES
		  LAMBDA-LIST
		  METHOD-COMBINATION
		  ERROR)
	  (VALUES NIL NIL NIL NIL NIL METHOD-COMBINATION
		  (FORMAT NIL "Flavor ~S does not handle generic operation ~S"
			  FLAVOR-NAME GENERIC))))))

;;; Return a list ((generic method-combination (function-spec function-spec...))...)
;;; that describes the methods making up all handlers for this flavor.
(DEFUN COMPOSE-HANDLERS (FLAVOR-NAME &KEY COMPONENTS ENV (ERROR-P T))
  (CONDITION-BIND-IF (NOT ERROR-P)
		     ((METHOD-COMBINATION-ERROR #'(LAMBDA (CONDITION)
						    (WARN "~A" CONDITION)
						    (SEND CONDITION :PROCEED :NO-ACTION))))
    (LOOP FOR (GF METHOD-COMBINATION . METHODS) IN (COLLECT-METHODS FLAVOR-NAME
								    :COMPONENTS COMPONENTS
								    :ENV ENV
								    :ERROR-P ERROR-P)
	  AS GENERIC = (GENERIC-FUNCTION-NAME GF)
	  UNLESS (LOOP FOR METHOD IN METHODS ALWAYS (EQ (METHOD-TYPE METHOD) 'COMBINED))
	    COLLECT (MULTIPLE-VALUE-BIND (NIL NIL COMBINED-METHOD-LIST)
			(COMBINE-METHODS GENERIC FLAVOR-NAME METHOD-COMBINATION METHODS
					 :ENV ENV)
		      (LIST GENERIC METHOD-COMBINATION COMBINED-METHOD-LIST)))))

;;; Print the part of a method function spec after the generic and the flavor nicely
(DEFUN PRINT-METHOD-SPEC (FUNCTION-SPEC METHOD-COMBINATION)
  (LET ((FUNCTION (GET (FIRST METHOD-COMBINATION) 'METHOD-COMBINATION-PRINTER))
	(TYPE (METHOD-TYPE FUNCTION-SPEC)))
    (COND ((EQ TYPE 'READ-INSTANCE-VARIABLE)
	   (FORMAT T "read inst var ~S" (ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)))
	  ((EQ TYPE 'WRITE-INSTANCE-VARIABLE)
	   (FORMAT T "write inst var ~S" (ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)))
	  ((EQ TYPE 'LOCATE-INSTANCE-VARIABLE)
	   (FORMAT T "locate inst var ~S" (ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC)))
	  ((EQ TYPE 'NCWHOPPER)		;The names have been changed to protect the innocent
	   (PRINT-METHOD-SPEC-1 "whopper" FUNCTION-SPEC))
	  ((EQ TYPE 'WHOPPER)		;Make obsolete name stand out
	   (PRINT-METHOD-SPEC-1 "whopper ~v[compiled in 7.0 or 7.1]~"
				FUNCTION-SPEC '(NIL NIL :SMALLER)))
	  ((MEMBER TYPE *INTERNAL-METHOD-TYPES*)
	   (PRINT-METHOD-SPEC-1 "~@" FUNCTION-SPEC TYPE))
	  ((NULL FUNCTION)
	   (FORMAT T "~S [with undefined method-combination ~S]"
		   FUNCTION-SPEC METHOD-COMBINATION))
	  (T (FUNCALL FUNCTION METHOD-COMBINATION FUNCTION-SPEC)))))

;;;; Internals in support of above interfaces

;;; Return function-spec for an already-existent combined method that we can use,
;;; or NIL if a new one needs to be made.  Also creates the *FLAVOR-COMPILE-TRACE*
;;; because this is where we discover the reasons why a method has to be recompiled.
(DEFUN HAVE-COMBINED-METHOD (FUNCTION-SPEC DERIVATION COMPONENT-METHOD-LIST
			     ENV IGNORE-EXISTING-METHOD)
  (FLET ((DERIVATION (METHOD)
	   (OR (AND (EQ ENV 'COMPILE)
		    (COMPILER:FILE-DECLARATION METHOD 'COMBINED-METHOD-DERIVATION))
	       (AND (FDEFINEDP METHOD)
		    (CDR (ASSOC 'COMBINED-METHOD-DERIVATION (DEBUGGING-INFO METHOD)))))))
    ;; See if this flavor already has a suitable combined method defined.
    (AND (NOT IGNORE-EXISTING-METHOD)
	 (MEMBER FUNCTION-SPEC COMPONENT-METHOD-LIST :TEST #'EQUAL)
	 (EQUAL (DERIVATION FUNCTION-SPEC) DERIVATION)
	 (RETURN-FROM HAVE-COMBINED-METHOD FUNCTION-SPEC))
    ;; Search the available methods, which are in most-specific-last order, to see if
    ;; there is a suitable combined method that can be inherited.  The most likely one
    ;; will be last in the list.
    (LET ((BEST NIL) (DERIV NIL))
      (DOLIST (METHOD COMPONENT-METHOD-LIST)
	(UNLESS (AND IGNORE-EXISTING-METHOD (EQUAL METHOD FUNCTION-SPEC))
	  (WHEN (EQ (METHOD-TYPE METHOD) 'COMBINED)
	    (SETQ BEST METHOD
		  DERIV (DERIVATION METHOD))
	    (WHEN (EQUAL DERIV DERIVATION)
	      (RETURN-FROM HAVE-COMBINED-METHOD METHOD)))))
      ;; No method found, you'll have to make one.  Trace if desired, but not at compile-time.
      (UNLESS (EQ ENV 'COMPILE)
	(PUSH (MAKE-FLAVOR-COMPILE-TRACE-ENTRY
		:FUNCTION-SPEC FUNCTION-SPEC
		:DERIVATION DERIVATION
		:PREVIOUS-FUNCTION-SPEC (IF IGNORE-EXISTING-METHOD 'IGNORE-EXISTING-METHOD
					    BEST)
		:PREVIOUS-DERIVATION DERIV
		:PATHNAME FDEFINE-FILE-PATHNAME)
	      *FLAVOR-COMPILE-TRACE-LIST*))
      ;; Return NIL since no method was found
      NIL)))

;;;; Specially-combined method types

(DEFUN PUT-WRAPPER-INTO-COMBINED-METHOD (FUNCTION-SPEC BODY-FORM ENV)
  (LET ((EXPANDER (IF (EQ ENV 'COMPILE)
		      (OR (COMPILER:FILE-DECLARATION FUNCTION-SPEC 'WRAPPER)
			  (DECLARED-DEFINITION FUNCTION-SPEC))
		      (OR (SECOND (ASSOC FUNCTION-SPEC
					 (CDDDR (ASSOC (METHOD-FLAVOR FUNCTION-SPEC) ENV))
					 :TEST #'EQUAL))
			  (FDEFINITION FUNCTION-SPEC)))))
    (VALUES (FUNCALL EXPANDER
		     (IF (AND *COMBINED-METHOD-APPLY*
			      (= (LIST-LENGTH *COMBINED-METHOD-ARGUMENTS*) 1))
			 (FIRST *COMBINED-METHOD-ARGUMENTS*)
			 (CONS (IF *COMBINED-METHOD-APPLY* 'LIST* 'LIST)
			       *COMBINED-METHOD-ARGUMENTS*))
		     BODY-FORM)
	    (CDR (ASSOC 'FLAVOR-SOURCE (DEBUGGING-INFO EXPANDER))))))

;;; Next three definitions are for old whoppers compiled before system 364
;;; This support could be removed in Release 8.0.  There is no support provided for
;;; the I machine, since no compiled whoppers from before 364 exist.

(DEFUN PUT-WHOPPER-INTO-COMBINED-METHOD (FUNCTION-SPEC BODY-FORM ENV)
  (IGNORE ENV)
  (FEATURE-CASE
    (3600.
      `(,(IF *COMBINED-METHOD-APPLY* 'APPLY 'FUNCALL)
	#',FUNCTION-SPEC
	SELF
	(GET-FLAVOR-MAPPING-TABLE-FOR-INSTANCE SELF ',(METHOD-FLAVOR FUNCTION-SPEC))
	#'(LAMBDA (SELF SELF-MAPPING-TABLE .GENERIC. ,@*COMBINED-METHOD-LAMBDA-LIST*)
	    ;;  Burn up variables so as not to get warnings for whoppers
	    ;;  on flavors not having methods for this message.
	    SELF SELF-MAPPING-TABLE .GENERIC. ,@*COMBINED-METHOD-ARGUMENTS*
	    ,BODY-FORM)
	SELF-MAPPING-TABLE .GENERIC.
	,@*COMBINED-METHOD-ARGUMENTS*))))

;;; Macros that can only be used inside the above internal-lambda
#+3600
(DEFMACRO CONTINUE-WHOPPER (&REST ARGS)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (FEATURE-CASE
    (3600. `(FUNCALL .WHOPPER-CONTINUATION. SELF .OLD-SELF-MAPPING-TABLE. .GENERIC. . ,ARGS))))

;--- Change name to APPLY-CONTINUE-WHOPPER for consistency with Common Lisp?
;--- Unfortunately (APPLY #'CONTINUE-WHOPPER ...) can't work.
#+3600
(DEFMACRO LEXPR-CONTINUE-WHOPPER (&REST ARGS)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (FEATURE-CASE
    (3600. `(APPLY .WHOPPER-CONTINUATION. SELF .OLD-SELF-MAPPING-TABLE. .GENERIC. . ,ARGS))))

#+IMACH
(DEFUN CONTINUE-WHOPPER (&REST ARGS)
  (DECLARE (IGNORE ARGS))
  (ERROR "CONTINUE-WHOPPER called outside of a whopper"))

#+IMACH
(DEFUN LEXPR-CONTINUE-WHOPPER (&REST ARGS)
  (DECLARE (IGNORE ARGS))
  (ERROR "LEXPR-CONTINUE-WHOPPER called outside of a whopper"))

;;; All the real work happens in COMBINE-METHODS
(DEFUN PUT-NCWHOPPER-INTO-COMBINED-METHOD (FUNCTION-SPEC BODY-FORM ENV)
  (IGNORE ENV)
  (VALUES BODY-FORM NIL FUNCTION-SPEC))

(DEFUN PUT-SPECIAL-INSTANCE-VARIABLES-INTO-COMBINED-METHOD (FUNCTION-SPEC BODY-FORM ENV)
  (IGNORE ENV)
  `(WITH-SPECIALS-BOUND-TO-INSTANCE-VARIABLES ,(METHOD-OPTIONS FUNCTION-SPEC)
     ,BODY-FORM))

(SI:DEFINE-SPECIAL-FORM WITH-SPECIALS-BOUND-TO-INSTANCE-VARIABLES
			(VARIABLES &BODY BODY &ENVIRONMENT ENV)
  (DECLARE LT:(ARG-TEMPLATE QUOTE ARBITRARY . BODY))  
  :MACRO-EXPANDER
  (IGNORE ENV)
  ;; Check at compile time for trying to bind A-memory, assuming these don't move around
  #+3600
  (LOOP FOR VAR IN VARIABLES
	AS SPECIAL-LOC = (LOCF (SYMBOL-VALUE VAR))
	DO
    (UNLESS (%POINTER-LESSP SPECIAL-LOC A-MEMORY-VIRTUAL-ADDRESS)
      (ERROR "Cannot bind special variable ~S to an instance variable
because its value cell is in hardware A-memory" VAR)))
  `(SYS:%WITH-BINDING-STACK-LEVEL
     ,@(LOOP FOR VAR IN VARIABLES
	     COLLECT `(LOCALLY (DECLARE (SPECIAL ,VAR))
		        (SYS:%BIND-LOCATION (SYS:VARIABLE-LOCATION ,VAR) NIL)))
						;need 1-arg bind!
     ,@(LOOP FOR VAR IN VARIABLES
	     COLLECT `(LINK-VARIABLES (LOCALLY (DECLARE (SPECIAL ,VAR))
					       (ZL:VARIABLE-LOCATION ,VAR))
				      (ZL:VARIABLE-LOCATION ,VAR)))
     ,@BODY)
  :INTERPRETER
  (PROGV VARIABLES NIL
	 (LOOP FOR VAR IN VARIABLES
	       AS SPECIAL-LOC = (LOCF (SYMBOL-VALUE VAR))
	       AS INSTANCE-LOC = (CDR (ASSOC VAR (SI:ENV-VARIABLES ENV))) DO
	   (UNLESS (AND (LOCATIVEP INSTANCE-LOC)
			(NOT (EQ SPECIAL-LOC (FOLLOW-CELL-FORWARDING INSTANCE-LOC T))))
	     (ERROR "~S is not lexically bound as an instance variable" VAR))
	   ;; Don't put invisible pointers into A-memory
	   #+3600
	   (UNLESS (%POINTER-LESSP SPECIAL-LOC A-MEMORY-VIRTUAL-ADDRESS)
	     (ERROR "Cannot bind special variable ~S to an instance variable
because its value cell is in hardware A-memory" VAR))
	   (%P-STORE-TAG-AND-POINTER SPECIAL-LOC
				     DTP-EXTERNAL-VALUE-CELL-POINTER
				     INSTANCE-LOC))
	 (SI:EVAL-BODY BODY ENV)))

(DEFUN LINK-VARIABLES (&REST PAIRS)
  (LOOP FOR (FROM TO) ON PAIRS BY 'CDDR DO
    (SETQ FROM (FOLLOW-CELL-FORWARDING FROM NIL))
    ;; Don't put invisible pointers into A-memory
    #+3600
    (UNLESS (%POINTER-LESSP FROM A-MEMORY-VIRTUAL-ADDRESS)
	(ERROR "Cannot bind special variable ~S to an instance variable
because its value cell is in hardware A-memory" (COMPILER:DISASSEMBLE-DECODE-LOCATIVE FROM)))
    (%P-STORE-TAG-AND-POINTER FROM DTP-EXTERNAL-VALUE-CELL-POINTER TO)))

;;;; Massaging and validation of method arglists

;;; Extracts defmethod-declarations from the body's declarations.
;;; Checks the method's arguments agree with the arguments declared for the generic function.
;;; Allows the generic function's method-combination to transform the method's arguments
;;; and/or body.  Note that method-combinations declared for flavors are not allowed to
;;; make transformations, only method-combinations declared for generic functions can do so.
(DEFUN MASSAGE-METHOD-ARGUMENTS (FUNCTION-SPEC ARGLIST BODY LEXICAL-ENVIRONMENT)
  (DECLARE (VALUES ARGLIST DECLARATIONS BODY ADDITIONAL-FORMS)
	   (DBG:ERROR-REPORTER))
  ;; Strip declarations out of the body
  (MULTIPLE-VALUE-BIND (DECLARATIONS BODY)
      (FIND-BODY-DECLARATIONS BODY LEXICAL-ENVIRONMENT ARGLIST)
    (LET* ((GF (FIND-GENERIC-FUNCTION (METHOD-GENERIC FUNCTION-SPEC) 'CREATE 'COMPILE))
	   (NORMAL-ARGLIST (GENERIC-FUNCTION-METHOD-ARGLIST GF))
	   (INHIBIT-CHECKING (NOT (GENERIC-FUNCTION-EXPLICIT GF)))
	   (ADDITIONAL-FORMS NIL)
	   (MC (GENERIC-FUNCTION-METHOD-COMBINATION GF))
	   (TRANSFORMER (AND MC (GETDECL (CAR MC) 'METHOD-COMBINATION-METHOD-TRANSFORMER))))
      (WHEN TRANSFORMER
	(MULTIPLE-VALUE-SETQ (ARGLIST BODY NORMAL-ARGLIST INHIBIT-CHECKING)
	  (FUNCALL TRANSFORMER FUNCTION-SPEC MC ARGLIST BODY NORMAL-ARGLIST))
	;; Strip declarations again, transformer might have added some to body
	(SETQ DECLARATIONS (APPEND DECLARATIONS
				   (MULTIPLE-VALUE-SETQ (NIL BODY)
				     (FIND-BODY-DECLARATIONS BODY NIL ARGLIST)))))
      ;; Look for defmethod-declarations, process them into additional-forms.
      ;; Massage ARGLIST declarations by sticking magic args on the front.
      ;; Recognize INHIBIT-ARGLIST-CHECKING declarations.
      (LOOP FOR FORM IN DECLARATIONS
	    WHEN (AND (LISTP FORM) (EQ (CAR FORM) 'DECLARE))
	      APPEND (CDR FORM) INTO DCLS
	    ELSE COLLECT FORM INTO OTHERS
	    FINALLY
	      (LOOP FOR L ON DCLS WITH ASSOC DO
		(COND ((EQ (CAAR L) 'ARGLIST)
		       (SETF (CAR L)
			     (FEATURE-CASE
			      (3600. `(ARGLIST SELF SELF-MAPPING-TABLE .GENERIC. ,@(CDAR L)))
			      (:IMACH `(ARGLIST SELF-MAPPING-TABLE SELF ,@(CDAR L))))
			     ))
		      ((EQ (CAAR L) 'INHIBIT-ARGLIST-CHECKING)
		       (SETQ INHIBIT-CHECKING T))
		      ((SETQ ASSOC (ASSOC (CAAR L) *DEFMETHOD-DECLARATIONS*))
		       (SETQ ADDITIONAL-FORMS
			     (APPEND ADDITIONAL-FORMS
				     (FUNCALL (SECOND ASSOC) FUNCTION-SPEC (CAR L) ARGLIST)))
		       (SETQ DCLS (DELETE (CAR L) DCLS)))))
	      (SETQ DECLARATIONS (APPEND (AND DCLS `((DECLARE ,@DCLS)))
					 (AND OTHERS OTHERS))))

	(WHEN (AND (EQ (METHOD-TYPE FUNCTION-SPEC) 'FLAVOR:METHOD)
		   (GENERIC-FUNCTION-INLINE-METHODS GF))
	  ;;--- Check that method's &optional argument initializations agree with generic's,
	  ;;--- since the latter will rule, in the inline case.
	  ;; Let the compiler do the work.
	  (PUSH `(PROCLAIM '(INLINE ,FUNCTION-SPEC)) ADDITIONAL-FORMS))

	(SETF (GENERIC-FUNCTION-METHODS-MADE GF) T)
	(UNLESS (OR INHIBIT-CHECKING
		    (EQ ARGLIST 'IGNORE))	;--- see comment at DEFWRAPPER
	  ;; Compare this method's arglist against the generic method arglist
	  (UNLESS (COMPATIBLE-ARGLISTS ARGLIST NORMAL-ARGLIST)
	    (WARN "The arguments, ~:S, are not consistent with
the generic arguments for ~S methods, ~:S."
		  ARGLIST (GENERIC-FUNCTION-NAME GF) NORMAL-ARGLIST)))
	(VALUES ARGLIST DECLARATIONS BODY ADDITIONAL-FORMS))))

(DEFUN COMPATIBLE-ARGLISTS (ARGLIST NORMAL-ARGLIST)
  (LET ((ARGS-INFO (ARGS-INFO-FROM-LAMBDA-LIST ARGLIST))
	(NORMAL-ARGS-INFO (ARGS-INFO-FROM-LAMBDA-LIST NORMAL-ARGLIST)))
    (IF (LDB-TEST %%ARG-DESC-REST-ARG ARGS-INFO)
	(AND ( (LDB %%ARG-DESC-MIN-ARGS ARGS-INFO)
		(LDB %%ARG-DESC-MIN-ARGS NORMAL-ARGS-INFO))
	     (OR (LDB-TEST %%ARG-DESC-REST-ARG NORMAL-ARGS-INFO)
		 ( (LDB %%ARG-DESC-MAX-ARGS ARGS-INFO)
		    (LDB %%ARG-DESC-MAX-ARGS NORMAL-ARGS-INFO))))
	(= ARGS-INFO NORMAL-ARGS-INFO))))

;;;; Printing of *FLAVOR-COMPILE-TRACE-LIST*

(DEFUN PRINT-FLAVOR-COMPILE-TRACE (&KEY FLAVOR GENERIC NEWEST OLDEST NEWEST-FIRST)
  (CHECK-TYPE FLAVOR SYMBOL)
  (CHECK-TYPE GENERIC (OR NULL GENERIC-FUNCTION-NAME))
  (CHECK-TYPE NEWEST (OR NULL (INTEGER 1 *)))
  (CHECK-TYPE OLDEST (OR NULL (INTEGER 1 *)))
  (FLET ((MATCH (FCT)
	   (AND (NOT (AND FLAVOR
			  (NOT (EQ FLAVOR (METHOD-FLAVOR (FCT-FUNCTION-SPEC FCT))))))
		(NOT (AND GENERIC
			  (NOT (EQUAL GENERIC (METHOD-GENERIC (FCT-FUNCTION-SPEC FCT)))))))))
    (MULTIPLE-VALUE-BIND (START END)
	(COND (NEWEST
	       (VALUES 0 (LOOP FOR FCT IN *FLAVOR-COMPILE-TRACE-LIST*
			       FOR POS FROM 0 WITH COUNT = NEWEST
			       DO (WHEN (AND (MATCH FCT) (ZEROP (DECF COUNT)))
				    (RETURN POS)))))
	      ((AND OLDEST (NULL FLAVOR) (NULL GENERIC))
	       (VALUES (MAX (- (LIST-LENGTH *FLAVOR-COMPILE-TRACE-LIST*) OLDEST) 0) NIL))
	      (OLDEST
	       (VALUES (LOOP FOR POS DOWNFROM (1- (LIST-LENGTH *FLAVOR-COMPILE-TRACE-LIST*))
			     AS FCT = (NTH POS *FLAVOR-COMPILE-TRACE-LIST*)
			     WITH COUNT = OLDEST
			     DO (WHEN (AND (MATCH FCT) (ZEROP (DECF COUNT)))
				  (RETURN POS)))
		       NIL))
	      (T (VALUES 0 NIL)))
      (LET ((LIST (NTHCDR START *FLAVOR-COMPILE-TRACE-LIST*)))
	(IF NEWEST-FIRST
	    (LOOP FOR FCT IN LIST DO
	      (WHEN (MATCH FCT)
		(PRINT-FLAVOR-COMPILE-TRACE-ENTRY FCT))
	      (WHEN END
		(WHEN (= END START) (RETURN))
		(DECF END)))
	    (LOOP FOR POS DOWNFROM (IF END (- END START) (1- (LIST-LENGTH LIST))) TO 0
		  AS FCT = (NTH POS LIST) DO
	      (WHEN (MATCH FCT)
		(PRINT-FLAVOR-COMPILE-TRACE-ENTRY FCT))))
	NIL))))

(DEFUN PRINT-FLAVOR-COMPILE-TRACE-ENTRY (FCT)
  (LET ((FUNCTION-SPEC (FCT-FUNCTION-SPEC FCT))
	(DERIVATION (FCT-DERIVATION FCT))
	(PREVIOUS-FUNCTION-SPEC (FCT-PREVIOUS-FUNCTION-SPEC FCT))
	(PREVIOUS-DERIVATION (FCT-PREVIOUS-DERIVATION FCT))
	(PATHNAME (FCT-PATHNAME FCT)))
    (FORMAT T "~%The combined method for ")
    (PRESENT (METHOD-GENERIC FUNCTION-SPEC) 'GENERIC-FUNCTION-NAME)
    (WRITE-STRING " of a ")
    (PRESENT (METHOD-FLAVOR FUNCTION-SPEC) 'FLAVOR-NAME)
    (WRITE-STRING (IF (ATOM PREVIOUS-FUNCTION-SPEC) " was compiled" " was recompiled"))
    (FORMAT T "~%to call method~P " (LENGTH (SECOND DERIVATION)))
    (PRINT-COMBINED-METHOD-DERIVATION DERIVATION)
    (TERPRI)
    (COND ((EQ PREVIOUS-FUNCTION-SPEC 'IGNORE-EXISTING-METHOD)
	   (FORMAT T "because of forced recompilation.~%"))
	  (PREVIOUS-FUNCTION-SPEC
	   (WRITE-STRING "rather than using ")
	   (PRESENT PREVIOUS-FUNCTION-SPEC 'FUNCTION-SPEC)
	   (FORMAT T ",~%")
	   (COND ((AND (EQUAL (FIRST DERIVATION) (FIRST PREVIOUS-DERIVATION))
		       (EQUAL (SECOND DERIVATION) (SECOND PREVIOUS-DERIVATION)))
		  (WRITE-STRING "because a wrapper has changed since it was compiled."))
		 (T
		  (FORMAT T "which calls method~P " (LENGTH (SECOND PREVIOUS-DERIVATION)))
		  (PRINT-COMBINED-METHOD-DERIVATION PREVIOUS-DERIVATION)))
	   (TERPRI)))
    (WHEN PATHNAME
      (WRITE-STRING "This occurred in file ")
      (PRESENT (PATHNAME PATHNAME))		;coerce PATHNAME, because it can be a string
      (TERPRI))))

(DEFUN PRINT-COMBINED-METHOD-DERIVATION (DERIVATION)
  (PRINT-METHOD-SPEC-LIST *STANDARD-OUTPUT* ", " "  " (FIRST DERIVATION) (SECOND DERIVATION))
  (FLET ((PRINT-METHOD-COMBINATION (STREAM)
	   (FORMAT STREAM "with method-combination ~{~S~^ ~}" (FIRST DERIVATION))))
    (IF (OPERATION-HANDLED-P *STANDARD-OUTPUT* :CHARACTER-WIDTH)
	(LET ((CURSORPOS (SEND *STANDARD-OUTPUT* :READ-CURSORPOS))
	      (WIDTH (DW:CONTINUATION-OUTPUT-SIZE #'(LAMBDA (STREAM)
						      (WRITE-STRING ", " STREAM)
						      (PRINT-METHOD-COMBINATION STREAM))
						  *STANDARD-OUTPUT*)))
	  (IF (< (+ CURSORPOS WIDTH) (SEND *STANDARD-OUTPUT* :INSIDE-SIZE))
	      (WRITE-STRING ", ")
	      (TERPRI)))
	(TERPRI))
    (PRINT-METHOD-COMBINATION *STANDARD-OUTPUT*)))

;;; SHARED-COMBINED methods.
;;; Function-spec is
;;;  (SHARED-COMBINED operator number-of-args number-of-methods number-of-after-methods)
;;;  number-of-args is 0 for &REST argument, else is number of args including SELF
;;;  and in that case no &optional/&rest/&key is allowed.
;;; The FLAVOR:SHARED-COMBINED property of the operator symbol is a 3-D array
;;;  and each element of the array is a function-cell.
;;; The function gets the methods and mapping tables from its extra-arg vector.
;;; This eliminates 3800 (almost half) of the combined methods in the system.

(DEFINE-FUNCTION-SPEC-HANDLER SHARED-COMBINED (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (CASE FUNCTION
    (VALIDATE-FUNCTION-SPEC
      (AND (= (LENGTH FUNCTION-SPEC) 5)
	   (SYMBOLP (SECOND FUNCTION-SPEC))	;even if it lacks a SHARED-COMBINED property
	   (EVERY #'INTEGERP (CDDR FUNCTION-SPEC))))
    (SI:DEFINITION-HAS-LOCATION-P NIL)		;Forwarding is never required
    ((FDEFINE FUNDEFINE FDEFINITION FDEFINEDP)
     (LET ((ARRAY (GET (SECOND FUNCTION-SPEC) 'SHARED-COMBINED))
	   (SUBSCRIPTS (CDDR FUNCTION-SPEC)))
       (IF (AND ARRAY
		(= (ARRAY-RANK ARRAY) (LENGTH SUBSCRIPTS))
		(APPLY #'ARRAY-IN-BOUNDS-P ARRAY SUBSCRIPTS))
	   (CASE FUNCTION
	     (FDEFINE (SETF (APPLY #'AREF ARRAY SUBSCRIPTS) ARG1))
	     (FUNDEFINE (LOCATION-MAKUNBOUND (LOCF (APPLY #'AREF ARRAY SUBSCRIPTS))))
	     (FDEFINITION (APPLY #'AREF ARRAY SUBSCRIPTS))
	     (FDEFINEDP (LOCATION-BOUNDP (LOCF (APPLY #'AREF ARRAY SUBSCRIPTS)))))
	   (UNLESS (EQ FUNCTION 'FDEFINEDP)
	     (ERROR "~S is not a valid function-spec because ~
			~:[shared-combined methods have not been defined for ~S~*~;~
			   ~*~{~S~^,~} are out-of-bounds subscripts.~]"
		    FUNCTION-SPEC ARRAY (SECOND FUNCTION-SPEC) SUBSCRIPTS)))))
    (OTHERWISE
      (SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2))))

(DEFMACRO DEFINE-SHARED-COMBINED-METHODS (OPERATOR MAX-ARGS MIN-METHODS MAX-METHODS
					  &OPTIONAL (MAX-AFTERS 0))
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',OPERATOR 'DEFINE-SHARED-COMBINED-METHODS)
     (SETF (GET ',OPERATOR 'SHARED-COMBINED)
	   (MAKE-ARRAY '(,(1+ MAX-ARGS)		;0 through MAX-ARGS
			 ,(1+ MAX-METHODS)	;0 through MAX-METHODS
			 ,(1+ MAX-AFTERS))))	;0 through MAX-AFTERS
     ,@(LOOP FOR N-ARGS FROM 0 TO MAX-ARGS NCONC
	 (LOOP FOR N-METHODS FROM 0 BELOW MIN-METHODS NCONC
	   (LOOP FOR N-AFTERS FROM 0 TO MAX-AFTERS COLLECT
	     `(LOCATION-MAKUNBOUND (LOCF (AREF (GET ',OPERATOR 'SHARED-COMBINED)
					       ,N-ARGS ,N-METHODS ,N-AFTERS))))))
     ,@(LOOP FOR N-ARGS FROM 0 TO MAX-ARGS
	     AS PARAMETERS = (IF (ZEROP N-ARGS) `(&REST ARGS)
				 (LOOP FOR I FROM 1 TO N-ARGS
				       COLLECT (INTERN (FORMAT NIL "ARG-~D" I))))
	     AS CALL = `APPLY THEN `FUNCALL
	     AS ARGS = `(ARGS) THEN PARAMETERS
	     NCONC
	 (LOOP FOR N-METHODS FROM MIN-METHODS TO MAX-METHODS NCONC
	   (LOOP FOR N-AFTERS FROM 0 TO MAX-AFTERS COLLECT
	     `(DEFUN (SHARED-COMBINED ,OPERATOR ,N-ARGS ,N-METHODS ,N-AFTERS)
		     ,(PROGN #+3600 `(SELF METHOD-VECTOR .GENERIC. ,@PARAMETERS)
			     #+IMACH `(METHOD-VECTOR SELF ,@PARAMETERS))
		(DECLARE (FUNCTION-PARENT ,OPERATOR DEFINE-SHARED-COMBINED-METHODS))
		(MULTIPLE-VALUE-PROG1
		  (,OPERATOR
		   ,@(LOOP REPEAT N-METHODS FOR I FROM 0 BY 2
			   COLLECT
			   (PROGN
			     #+3600 `(,CALL (AREF METHOD-VECTOR ,I) SELF
				      (AREF METHOD-VECTOR ,(1+ I)) .GENERIC. ,@ARGS)
			     #+IMACH `(,CALL (AREF METHOD-VECTOR ,I) 
				       (AREF METHOD-VECTOR ,(1+ I)) SELF ,@ARGS))
			     ))
		  ,@(LOOP REPEAT N-AFTERS FOR I FROM (* N-METHODS 2) BY 2
			  COLLECT
			  (PROGN
			    #+3600 `(,CALL (AREF METHOD-VECTOR ,I) SELF
				     (AREF METHOD-VECTOR ,(1+ I)) .GENERIC. ,@ARGS)
			    #+IMACH `(,CALL (AREF METHOD-VECTOR ,I) 
				      (AREF METHOD-VECTOR ,(1+ I)) SELF ,@ARGS))
			    )
		  )))))))

;;; Define the shared-combined methods that have been observed to be used in the system
;--- Later investigate turning on the N-ARGS > 0 feature, making MAKE-COMBINED-METHOD use it

(DEFINE-SHARED-COMBINED-METHODS AND 0 2 5)
(DEFINE-SHARED-COMBINED-METHODS APPEND 0 2 5)
(DEFINE-SHARED-COMBINED-METHODS LIST 0 1 5)
(DEFINE-SHARED-COMBINED-METHODS NCONC 0 2 5)
(DEFINE-SHARED-COMBINED-METHODS OR 0 2 5)
(DEFINE-SHARED-COMBINED-METHODS PROGN 0 1 7 4) ;PROGN handles :DAEMON and :TWO-PASS also
