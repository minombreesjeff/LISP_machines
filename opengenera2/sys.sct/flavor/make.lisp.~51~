;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: FLAVOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains MAKE-INSTANCE and friends

;Later this may be an instruction
;For now, write it this kludgey, gross way so it's reasonably fast
#+3600
(DEFUN %BLOCK-COPY-ALLOW-NULL (FROM TO COUNT)
  (UNLESS (ZEROP COUNT)
    (SI:INHIBIT-GC-FLIPS
      (LOOP FOR ADDRESS = FROM THEN NEW-ADDRESS WITH COUNT = COUNT
	    AS NEW-ADDRESS = (%BLOCK-TRANSPORT ADDRESS COUNT)
	    DO (DECF COUNT (%POINTER-DIFFERENCE NEW-ADDRESS ADDRESS))
	    WHILE (PLUSP COUNT))
      (%BLOCK-GC-COPY FROM TO COUNT)
      NIL)))

#+IMACH
(DEFSUBST %BLOCK-COPY-ALLOW-NULL (FROM TO COUNT)
  (SI:%BLOCK-SCAVENGE-COPY FROM TO COUNT))

;;;; Convert initialization information into a convenient form for quick MAKE-INSTANCE

(DEFUN COMPOSE-INITIALIZATIONS (FLAVOR-NAME &KEY ENV (ERROR-P T)
				&AUX (FL (FIND-FLAVOR FLAVOR-NAME 'CREATE-IN-ENV ENV))
				     (INSTANCE-VARIABLE-INITIALIZATIONS NIL)
				     (DEFAULT-INIT-ALIST NIL)
				     (INSTANCE-VARIABLE-INIT-KEYWORDS NIL)
				     (OTHER-INIT-KEYWORDS NIL) (REQUIRED-KEYWORDS NIL)
				     (UNHANDLED-KEYWORDS NIL) (ALLOW-OTHER-KEYS NIL)
				     (INSTANCE-AREA NIL) (AREA-KEYWORD NIL)
				     (VARIABLE-DEFAULT-INIT-FORMS NIL)
				     TEMPLATE VARS)
  (STANDARDIZE-ENV ENV)
  ;; Make sure we know the component flavors and the instance variables
  (UNLESS (IF ERROR-P (FLAVOR-COMPONENTS-COMPOSED FL) (FLAVOR-ALL-COMPONENTS FL))
    (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME :ENV ENV :ERROR-P ERROR-P))
  ;; Map over the components in order and collect the instance-variable initializations,
  ;; the default-init-plist, and a few other initialization-related items.
  ;; Initializations seen earlier shadow initializations from flavors seen later.
  (LOOP FOR F IN (FLAVOR-ALL-COMPONENTS FL) AS FL = (FIND-FLAVOR F NIL ENV) DO
    (COND ((NULL FL)
	   (FLAVOR-ERROR FLAVOR-NAME ERROR-P
			 "The component flavor ~S has not been DEFFLAVORed." F))
	  (T
	   (LOOP FOR ASSOC IN (FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FL) DO
	     (PUSHNEW ASSOC INSTANCE-VARIABLE-INITIALIZATIONS :KEY #'FIRST))
	   (LOOP FOR (IND VAL) ON (FLAVOR-DEFAULT-INIT-PLIST FL) BY 'CDDR DO
	     (UNLESS (ASSOC IND DEFAULT-INIT-ALIST)
	       (PUSH (LIST IND VAL) DEFAULT-INIT-ALIST)))
	   (LOOP FOR ASSOC IN (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL)
		 AS (KEYWORD VARIABLE) = ASSOC
		 AS (NIL CONFLICT) = (ASSOC KEYWORD INSTANCE-VARIABLE-INIT-KEYWORDS)
		 DO (COND ((NULL CONFLICT) (PUSH ASSOC INSTANCE-VARIABLE-INIT-KEYWORDS))
			  ((NEQ CONFLICT VARIABLE)
			   (FLAVOR-ERROR FLAVOR-NAME ERROR-P
					 "Instance variables ~S and ~S of ~S~@
					  are both initializable with the same keyword, ~S"
					 VARIABLE CONFLICT FLAVOR-NAME KEYWORD))))
	   (SETQ OTHER-INIT-KEYWORDS (STABLE-UNION OTHER-INIT-KEYWORDS
						   (FLAVOR-INIT-KEYWORDS FL)))
	   ;; STABLE-UNION rather than UNION so the error message looks nicer
	   (SETQ REQUIRED-KEYWORDS (STABLE-UNION REQUIRED-KEYWORDS
						 (FLAVOR-REQUIRED-INIT-KEYWORDS FL)))
	   (UNLESS AREA-KEYWORD			;Inherit from first component to specify it
	     (WHEN (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
	       (SETQ AREA-KEYWORD (FLAVOR-AREA-KEYWORD FL)))))))
  ;; Correlate the initialization information collected from the component flavors.
  ;; Required-keywords can be satisfied by default-init-plist
  (SETQ REQUIRED-KEYWORDS (REMOVE-IF #'(LAMBDA (KEYWORD)
					 (ASSOC KEYWORD DEFAULT-INIT-ALIST))
				     REQUIRED-KEYWORDS))
  ;; Default-init-plist can feed into :MIXTURE
  (WHEN (FLAVOR-HAS-MIXTURE FL)
    (SETF (FLAVOR-MIXTURE-DEFAULTS FL)
	  (LOOP WITH FLAVOR-MIXTURE-KEYWORDS = (FLAVOR-MIXTURE-KEYWORDS FL)
		FOR (KEY FORM) IN DEFAULT-INIT-ALIST
		WHEN (MEMBER KEY FLAVOR-MIXTURE-KEYWORDS)
		  APPEND (LIST KEY FORM))))

  ;; Initable-instance-variables can be initialized by default-init-plist entries,
  ;; which dominates initializations from the defflavor instance-variables list.
  ;; Also handle :ALLOW-OTHER-KEYS and area-keyword here.
  ;; Note that the same keyword can be used for multiple purposes.
  (LOOP FOR ASSOC IN DEFAULT-INIT-ALIST
	AS (KEYWORD FORM) = ASSOC
	AS (NIL VARIABLE) = (ASSOC KEYWORD INSTANCE-VARIABLE-INIT-KEYWORDS)
	AS HANDLED = NIL DO
    (WHEN VARIABLE
      (SETQ INSTANCE-VARIABLE-INITIALIZATIONS
	    (CONS (LIST VARIABLE FORM)
		  (DELETE (ASSOC VARIABLE INSTANCE-VARIABLE-INITIALIZATIONS)
			  INSTANCE-VARIABLE-INITIALIZATIONS)))
      (SETQ HANDLED T))
    (WHEN (EQ KEYWORD ':ALLOW-OTHER-KEYS)
      (IF (CONSTANTP FORM)
	  (SETQ ALLOW-OTHER-KEYS (LT:EVALUATE-CONSTANT FORM))
	  (FLAVOR-ERROR FLAVOR-NAME NIL
			":DEFAULT-INIT-PLIST ~S ~S ignored because the form is not constant."
			KEYWORD FORM))
      (SETQ HANDLED T))
    (WHEN (EQ KEYWORD AREA-KEYWORD)
      ;; Try to avoid run-time evaluation when we know the value will be constant
      ;; or will be the value of DEFAULT-CONS-AREA (SI:%MAKE-STRUCTURE handles that).
      (SETQ INSTANCE-AREA (COND ((POSITION FORM AREA-LIST))
				((EQ FORM 'DEFAULT-CONS-AREA) NIL)
				(T FORM)))
      (SETQ HANDLED T))
    (WHEN HANDLED
      (SETQ DEFAULT-INIT-ALIST (DELETE ASSOC DEFAULT-INIT-ALIST))))

  ;; Initable-instance-variables dominate init-keywords [I hope this is right!]
  (SETQ OTHER-INIT-KEYWORDS (REMOVE-IF #'(LAMBDA (KEYWORD)
					   (ASSOC KEYWORD INSTANCE-VARIABLE-INIT-KEYWORDS))
				       OTHER-INIT-KEYWORDS))
  ;; Check for unhandled default-init-plist entries & unhandled required-init-keywords
  (UNLESS ALLOW-OTHER-KEYS
    (SETQ UNHANDLED-KEYWORDS (LOOP FOR (KEYWORD) IN DEFAULT-INIT-ALIST
				   UNLESS (MEMBER KEYWORD OTHER-INIT-KEYWORDS)
				     COLLECT KEYWORD))
    (WHEN UNHANDLED-KEYWORDS
      (FLAVOR-ERROR FLAVOR-NAME NIL
		    "The initialization keyword~P ~{~S~^, ~}, ~
			specified in :DEFAULT-INIT-PLIST, ~0@*~[~1;is~:;are~] not handled."
		    (LENGTH UNHANDLED-KEYWORDS) UNHANDLED-KEYWORDS))
    (LOOP FOR KEYWORD IN REQUIRED-KEYWORDS
	  UNLESS (EQ KEYWORD AREA-KEYWORD)
	    UNLESS (MEMBER KEYWORD OTHER-INIT-KEYWORDS)
	      UNLESS (ASSOC KEYWORD INSTANCE-VARIABLE-INIT-KEYWORDS)
		COLLECT KEYWORD INTO LOSERS
	  FINALLY
	    (WHEN LOSERS
	      (FLAVOR-ERROR FLAVOR-NAME NIL
			    "The initialization keyword~P ~{~S~^, ~} ~0@*~[~1;is~:;are~] ~
				required by :REQUIRED-INIT-KEYWORDS, but~@
				no disposition for ~0@*~[~1;it~:;them~] as :INIT-KEYWORDS, ~
				:INITABLE-INSTANCE-VARIABLES,~@
				or :AREA-KEYWORD has been specified."
			    (LENGTH LOSERS) LOSERS))))
  ;; If this is the run-time environment, copy the information into *FLAVOR-AREA*
  ;; because it probably won't change, and compactify it, to speed up MAKE-INSTANCE.
  (FLET ((COPY (TREE)
	   (IF ENV TREE (COPY-TREE TREE *FLAVOR-AREA*))))
    ;; If there's already a template instance lying around, trash it because the place
    ;; where its length is stored is about to get overwritten.
    (WHEN (FLAVOR-TEMPLATE-INSTANCE FL)
      (%BLOCK-STORE-TAG-AND-POINTER (FLAVOR-TEMPLATE-INSTANCE FL)
				    (FLAVOR-INSTANCE-SIZE FL)
				    (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
					 DTP-HEADER-I)
				    (PROGN
				      #+3600
				      (DPB %ARRAY-DISPATCH-WORD
					   (DEFSTORAGE-FIELD-BYTE ARRAY-DISPATCH-FIELD)
					   (DPB ART-Q
						(DEFSTORAGE-FIELD-BYTE ARRAY-TYPE-FIELD)
						0))
				      #+IMACH
				      (%LOGDPB ART-Q ARRAY-TYPE-FIELD 0))
				    0))
    ;; Store the initialization information in the form needed by MAKE-INSTANCE
    (SETQ VARS (FLAVOR-ALL-INSTANCE-VARIABLES FL))
    (SETF (FLAVOR-INSTANCE-SIZE FL) (1+ (LENGTH VARS)))
    (SETQ TEMPLATE (SI:%MAKE-STRUCTURE DTP-INSTANCE DTP-HEADER-P %HEADER-TYPE-INSTANCE
				       (PROGN #+3600 FL
					      #+IMACH (LOCF (%FLAVOR-HASH-MASK FL)))
				       (FLAVOR-AREA ENV) (FLAVOR-INSTANCE-SIZE FL)))
    (SETF (FLAVOR-TEMPLATE-INSTANCE FL) TEMPLATE)
    (LOOP FOR VARIABLE IN VARS FOR SLOT FROM 1
	  WITH MASK = 1
	  AS P = (%MAKE-POINTER-OFFSET DTP-LOCATIVE TEMPLATE SLOT)
	  AS (BOUNDP FORM) = (ASSOC VARIABLE INSTANCE-VARIABLE-INITIALIZATIONS)
	  DO (COND ((NOT BOUNDP) (%P-STORE-TAG-AND-POINTER P DTP-NULL VARIABLE))
		   ((CONSTANTP FORM) (%P-STORE-CONTENTS P (LT:EVALUATE-CONSTANT FORM)))
		   (T (PUSH (LIST FORM SLOT MASK) VARIABLE-DEFAULT-INIT-FORMS)
		      (SETQ MASK (ASH MASK 1))
		      (%P-STORE-TAG-AND-POINTER P DTP-NULL VARIABLE))))
    (SETQ VARIABLE-DEFAULT-INIT-FORMS (NREVERSE VARIABLE-DEFAULT-INIT-FORMS))
    (SETF (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS FL) (COPY VARIABLE-DEFAULT-INIT-FORMS))
    (SETF (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL)
	  (COPY (NREVERSE (LOOP FOR (KEYWORD VARIABLE) IN INSTANCE-VARIABLE-INIT-KEYWORDS
				AS SLOT = (1+ (POSITION VARIABLE VARS))
				AS MASK = (THIRD (FIND SLOT VARIABLE-DEFAULT-INIT-FORMS
						       :KEY #'SECOND))
				COLLECT (IF MASK (LIST KEYWORD SLOT MASK)
					    (LIST KEYWORD SLOT))))))
    (SETF (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL) (COPY OTHER-INIT-KEYWORDS))
    (LOOP FOR (KEYWORD FORM) IN DEFAULT-INIT-ALIST
	  ;; Perhaps this should be using a special version of EVAL, if ENV = COMPILE,
	  ;; in case the value of a constant is being changed.  However, the compiler
	  ;; itself is completely broken in this respect, so "what me worry?"!
	  IF (CONSTANTP FORM)
	    NCONC (LIST KEYWORD (LT:EVALUATE-CONSTANT FORM)) INTO CONSTANTS
	    ELSE NCONC (LIST KEYWORD FORM) INTO FORMS
	  FINALLY
	    (SETF (FLAVOR-ALL-OTHER-DEFAULT-INIT-CONSTANTS FL) (COPY CONSTANTS))
	    (SETF (FLAVOR-ALL-OTHER-DEFAULT-INIT-FORMS FL) (COPY FORMS)))
    (SETF (FLAVOR-ALL-REQUIRED-KEYWORDS FL) (COPY REQUIRED-KEYWORDS))
    (SETF (FLAVOR-ALL-UNHANDLED-KEYWORDS FL) (COPY UNHANDLED-KEYWORDS))
    (SETF (FLAVOR-ALL-ALLOW-OTHER-KEYS FL) ALLOW-OTHER-KEYS)
    (SETF (FLAVOR-INSTANCE-AREA FL) INSTANCE-AREA)
    (SETF (FLAVOR-AREA-KEYWORD FL) AREA-KEYWORD)
    (SETF (FLAVOR-INITIALIZATIONS-COMPOSED FL) T)))

(DEFUN PREPARE-FOR-INSTANTIATION (FL &AUX (FLAVOR-NAME (FLAVOR-NAME FL)))
  (DECLARE (DBG:ERROR-REPORTER))
  (WHEN (FLAVOR-IS-ABSTRACT FL)
    (ERROR "The flavor ~S cannot be instantiated because it is abstract." FLAVOR-NAME))
  (UNLESS (FLAVOR-METHODS-COMPOSED FL)
    (COMPOSE-METHOD-COMBINATION FLAVOR-NAME))
  (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL)
    (COMPOSE-INITIALIZATIONS FLAVOR-NAME))
  (SETF (FLAVOR-HAS-INIT-METHOD FL) (MEMBER ':INIT (FLAVOR-ALL-GENERICS FL)))
  (SETF (FLAVOR-INSTANTIABLE FL) T))

;;;; By-position constructor functions

#+IMach
;; The version of the constructor "compiler" which generated a particular constructor
;; function.  This is Ivory-only for now, since I don't want to force recompilation of
;; every constructor on the 3600.
(DEFVAR *FLAVOR-CONSTRUCTOR-VERSION* 2)

;The CONSTRUCTOR-DERIVATION debug-info is a list:
;(all-vars easy-vars hard-vars 
; init-keywords easy-init hard-init
; area-keyword area-form generics)
;
;all-vars is a list of instance variable names, in storage order.
;easy-vars is an alist from instance variable names to initial value objects.
;hard-vars is an alist from instance variable names to initial value forms.
; If an instance variable is in neither easy-vars nor hard-vars, it's initially unbound.
;init-keywords is a list of non-iv, non-area initialization keywords, in no special order.
;easy-init is a plist from init keywords to default value objects.
;hard-init is a plist from init keywords to default value forms.
; If an init keyword is in neither easy-init nor hard-init, it has no default and
; if not supplied does not appear in the method argument list.
;area-keyword is the init-keyword that controls the area for instance creation.
;area-form is a form that evaluates to the default area.
;generics is a list of initialization generics that have methods
; (members are the symbols MAKE-INSTANCE, :INIT).
;
;This includes all initialization information for the flavor that any constructor
;could depend on, even items that this constructor does not actually depend on.
;I tried storing only the information that actually got compiled into the constructor,
;but it proved to be extremely complex and not worthwhile.  The only cost of storing
;it all is a few extra words of debugging-info per constructor, and occasional
;unnecessary recompilation of constructors when a flavor is changed.
(DEFPROP CONSTRUCTOR-DERIVATION T SI:DEBUG-INFO)
(DEFPROP CONSTRUCTOR-ARGLIST T SI:DEBUG-INFO)

;A list of defuns.  Flavor must already be prepared for instantiation.
;Don't call this if (FLAVOR-CONSTRUCTORS FL) is NIL.
;---I'm not worrying about name clashes between constructor arguments and
;free references in default-value forms; the easiest way to deal with
;that would be for the compiler to give me a special form that
;wraps a form in the null lexical environment.
(DEFUN COMPOSE-CONSTRUCTOR-FUNCTIONS (FL ENV)
  (FEATURE-CASE
    (:IMACH (I-COMPOSE-CONSTRUCTOR-FUNCTIONS FL ENV))
    (3600. (L-COMPOSE-CONSTRUCTOR-FUNCTIONS FL ENV))))

(DEFUN L-COMPOSE-CONSTRUCTOR-FUNCTIONS (FL ENV)
  (LOOP FOR (NAME . ARGS) IN (FLAVOR-CONSTRUCTORS FL)
	AS COMPILER:DEFAULT-WARNING-FUNCTION = NAME
	WITH COMPILER:DEFAULT-WARNING-DEFINITION-TYPE = 'DEFUN
	WITH FLAVOR-NAME = (FLAVOR-NAME FL)
	WITH DERIVATION = (FLAVOR-CONSTRUCTOR-DERIVATION FL ENV)
	AS (ALL-VARS EASY-VARS HARD-VARS INIT-KEYWORDS EASY-INIT HARD-INIT
	    AREA-KEYWORD AREA-FORM GENERICS) = DERIVATION
	WITH (TEM POS PAIR VPAIR KEY DEFAULT ARG1 FLV ORIGINAL-ARGS USE-TEMPLATE)
	AS KIND = NIL AS UNBOUND = NIL AS ARG0 = NIL AS REST = NIL AS VARS = NIL
	AS EXPLICIT-UNBOUND = NIL AS DUMMY-ARG0 = NIL
	AS INIT-OPTIONS = NIL			;list of forms, keywords are quoted
	AS OPTIONAL-INIT-OPTIONS = NIL		;list of (keyword value-var supplied-p-var)
	AS SUPPRESSED-INIT-OPTIONS = NIL	;list of (keyword value-var)
	AS AREA-VAR = NIL DO
        ;; Expand the one-argument :CONSTRUCTOR option
        (SETQ ORIGINAL-ARGS (SETQ ARGS (FLAVOR-CONSTRUCTOR-ARGLIST FL ARGS)))
	;; Classify arguments into instance-variables, init-options, and instance area.
	;; Insert supplied-p vars into arglist where needed.
	(DOLIST (VAR ARGS)
	  (COND ((MEMBER VAR LAMBDA-LIST-KEYWORDS)
		 (CASE VAR
		   ((&OPTIONAL &REST &KEY &AUX)
		    (SETQ KIND VAR))
		   ((&ALLOW-OTHER-KEYS))
		   (OTHERWISE
		     (WARN "Error in constructor function ~S for flavor ~S.~@
			   ~S is an invalid lambda-list keyword in a constructor."
			   NAME FLAVOR-NAME VAR))))
		(T
		 (SETQ PAIR VAR VPAIR VAR DEFAULT NIL KEY NIL)
		 (UNLESS (ATOM VAR)
		   (SETQ VAR (CAR PAIR) DEFAULT (CDR PAIR))
		   (SETQ VPAIR VAR)
		   (WHEN (EQ KIND '&KEY)
		     (UNLESS (ATOM VAR)
		       (SETQ KEY (CAR VAR)	;&KEY with explicit keyword
			     VAR (CADR VAR)))))
		 (UNLESS (AND (SYMBOLP VAR) (NOT (CONSTANTP VAR)))
		   (WARN "Error in constructor function ~S for flavor ~S.~@
			 ~S where a variable is required in the parameter list."
			 NAME FLAVOR-NAME VAR)
		   (SETQ VAR 'FOO))
		 (UNLESS (SETQ POS (POSITION VAR ALL-VARS))
		   (UNLESS KEY
		     (SETQ KEY (INTERN (SYMBOL-NAME VAR) PKG-KEYWORD-PACKAGE)))
		   (COND ((EQ KEY AREA-KEYWORD)
			  (WHEN AREA-VAR
			    (WARN "Error in constructor function ~S for flavor ~S.~@
				  Both ~S and ~S specify the area for instance creation."
				  NAME FLAVOR-NAME AREA-VAR VAR))
			  (SETQ AREA-VAR VAR))
			 ((MEMBER KEY INIT-KEYWORDS)
			  (LOOP FOR ((NIL K) V) ON INIT-OPTIONS BY 'CDDR DO
			    (WHEN (EQ K KEY)
			      (WARN "Error in constructor function ~S for flavor ~S.~@
				    Both ~S and ~S specify the ~S init-keyword."
				    NAME FLAVOR-NAME VAR V KEY)))
			  (SETQ INIT-OPTIONS (NCONC INIT-OPTIONS `(',KEY ,VAR))))
			 (T
			  (WARN "Error in parameter list of ~
				constructor function ~S for flavor ~S.~@
				~S is not the name of an instance variable~
				~:[~2*~;~%and ~S is not the area-keyword ~S~]~
				~[~0;~2*~1;~%and ~S is not the init-keyword ~{~S~}~
				  ~:;~%and ~S is not one of the init-keywords ~{~S~^, ~}~]."
				NAME FLAVOR-NAME
				VAR
				AREA-KEYWORD KEY AREA-KEYWORD
				(LENGTH INIT-KEYWORDS) KEY INIT-KEYWORDS))))
		 (UNLESS ARG0
		   (COND ((EQ KIND '&KEY)
			  (SETQ ARG0 (GENSYM) DUMMY-ARG0 T)
			  (SETQ ARGS `(&REST ,ARG0 ,@ARGS)))
			 (T (SETQ ARG0 VAR))))
		 (PUSH VAR VARS)
		 (WHEN (EQ KIND '&REST)
		   (SETQ REST VAR))		;Will need to be copied
		 ;; If this argument can be defaulted, but no default was specified,
		 ;; then unlike a normal defun, the default is nonlocal and comes from
		 ;; the defflavor, except for &aux variables, which behave as if no
		 ;; default had been specified in the defflavor (i.e. unbound).
		 ;; This is as specified by CLtL for defstruct.
		 (WHEN (AND KIND (NEQ KIND '&REST) (NOT DEFAULT))
		   (COND (POS			;This is an instance variable initialization
			  (CASE KIND
			    (&AUX
			     (PUSH (LIST NIL POS VAR) UNBOUND)
			     (PUSH VAR EXPLICIT-UNBOUND)
			     (SETQ ARGS (REMOVE PAIR ARGS)))
			    ((&OPTIONAL &KEY)
			     (COND ((SETQ TEM (ASSOC VAR EASY-VARS))
				    (SETQ ARGS (SUBSTITUTE `(,VPAIR ',(CADR TEM)) PAIR ARGS)))
				   ((SETQ TEM (ASSOC VAR HARD-VARS))
				    (SETQ ARGS (SUBSTITUTE `(,VPAIR ,(CADR TEM)) PAIR ARGS)))
				   (T (SETQ TEM (GENSYM))	;Supplied-p variable
				      (SETQ ARGS (SUBSTITUTE `(,VPAIR NIL ,TEM) PAIR ARGS))
				      (PUSH (LIST TEM POS VAR) UNBOUND))))))
			 ((EQ KEY AREA-KEYWORD)
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR ,AREA-FORM) PAIR ARGS)))
			 ((NOT (MEMBER KEY INIT-KEYWORDS)))
			 ((EQ KIND '&AUX)
			  (PUSH (LIST KEY VAR) SUPPRESSED-INIT-OPTIONS)
			  (SETQ INIT-OPTIONS (NBUTLAST INIT-OPTIONS 2)))
			 ((SETQ TEM (GETF HARD-INIT KEY))
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR ,TEM) PAIR ARGS)))
			 ((OR (SETQ TEM (GETF EASY-INIT KEY))
			      (LOOP FOR K IN EASY-INIT BY 'CDDR THEREIS (EQ K KEY)))
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR ',TEM) PAIR ARGS)))
			 (T
			  (SETQ TEM (GENSYM))	;Supplied-p variable
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR NIL ,TEM) PAIR ARGS))
			  (PUSH (LIST KEY VAR TEM) OPTIONAL-INIT-OPTIONS)
			  (SETQ INIT-OPTIONS (NBUTLAST INIT-OPTIONS 2))))))))
	;; Arrange to be able to recycle the FP|0 slot, named ARG0
	;; and to have the flavor structure on hand.  The flavor structure is a constant
	;; in the constructor function for speed and, more importantly, so we can be
	;; sure its flavor-instance-size agrees with the one we are compiling into
	;; various parts of the body of the constructor function.
	(SETQ FLV (GENSYM)
	      TEM `(,FLV ',(COND ((AND (EQ ENV 'COMPILE) UNDO-DECLARATIONS-FLAG)
				  (CONS COMPILER:EVAL-AT-LOAD-TIME-MARKER
					`(LOAD-TIME-FIND-FLAVOR ',(FLAVOR-NAME FL)
								,(FLAVOR-INSTANCE-SIZE FL))))
				 (T
				  ;; The FLAVOR-INSTANTIATED bit must be set, so that the
				  ;; instance-size can't be changed by redefining the flavor.
				  ;; Don't wait until the constructor is actually called
				  ;; before setting it, that would be too late!
				  (SETF (FLAVOR-INSTANTIATED FL) T)
				  FL))))
	(COND ((NULL ARG0)
	       (SETQ ARG0 (GENSYM)
		     ARGS `(&AUX ,ARG0 ,TEM)))
	      (DUMMY-ARG0
	       (UNLESS (EQ KIND '&AUX) (SETQ ARGS (APPEND ARGS '(&AUX))))
	       (SETQ ARGS (APPEND ARGS `(,TEM))))
	      (T
	       (SETQ ARG1 (GENSYM))
	       (UNLESS (EQ KIND '&AUX) (SETQ ARGS (APPEND ARGS '(&AUX))))
	       (SETQ ARGS (APPEND ARGS `((,ARG1 ,ARG0) ,TEM)))
	       (SETQ INIT-OPTIONS (SUBSTITUTE ARG1 ARG0 INIT-OPTIONS))))
	;; Default any init-options that don't come from arguments
	(LOOP FOR (KEY VAL) ON HARD-INIT BY 'CDDR DO
	  (UNLESS (OR (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
		      (ASSOC KEY OPTIONAL-INIT-OPTIONS)
		      (LOOP FOR (NIL K) IN INIT-OPTIONS BY 'CDDR THEREIS (EQ K KEY)))
	    (SETQ INIT-OPTIONS (NCONC INIT-OPTIONS `(',KEY ,VAL)))))
	(LOOP FOR (KEY VAL) ON EASY-INIT BY 'CDDR DO
	  (UNLESS (OR (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
		      (ASSOC KEY OPTIONAL-INIT-OPTIONS)
		      (LOOP FOR (NIL K) IN INIT-OPTIONS BY 'CDDR THEREIS (EQ K KEY)))
	    (SETQ INIT-OPTIONS (NCONC INIT-OPTIONS `(',KEY ',VAL)))))
	;; Make sure all required-init-options have been handled
	(LOOP FOR KEY IN (FLAVOR-ALL-REQUIRED-KEYWORDS FL)
	      UNLESS (OR (LOOP FOR (NIL K) IN INIT-OPTIONS BY 'CDDR THEREIS (EQ K KEY))
			 (LET ((VAR (ASSOC KEY (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL))))
			   (WHEN VAR
			     (SETQ VAR (NTH (1- (SECOND VAR)) ALL-VARS))
			     (OR (MEMBER VAR VARS)	;Initialized by argument
				 (ASSOC VAR HARD-VARS)	;Initialized by default-init-plist
				 (ASSOC VAR EASY-VARS)))))	;..
		COLLECT KEY INTO REQUIRED-KEYWORDS
	      FINALLY
		(WHEN REQUIRED-KEYWORDS
		  ;; These missing INIT-OPTIONS could be in one of three states:
		  ;; (1) Missing completely.
		  ;; (2) OPTIONAL-INIT-OPTIONS, supplied to init methods only when
		  ;;     supplied to the constructor.
		  ;; (3) SUPPRESSED-INIT-OPTIONS, disabled via &AUX.
		  (WARN "Error in constructor function ~S for flavor ~S.~v,v,vQ"
			NAME FLAVOR-NAME
			(LOOP FOR KEY IN REQUIRED-KEYWORDS
			      WHEN (ASSOC KEY OPTIONAL-INIT-OPTIONS)
				COLLECT KEY)
			(LOOP FOR KEY IN REQUIRED-KEYWORDS
			      WHEN (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
				COLLECT KEY)
			(LOOP FOR KEY IN REQUIRED-KEYWORDS
			      UNLESS (ASSOC KEY OPTIONAL-INIT-OPTIONS)
				UNLESS (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
				  COLLECT KEY)
			(LAMBDA (OPTIONAL SUPPRESSED MISSING)
			  (WHEN MISSING
			    (FORMAT T "~%The constructor does not supply a value for ~
					the required init-keyword~P ~{~S~^, ~}."
				    (LENGTH MISSING) MISSING))
			  (WHEN SUPPRESSED
			    (FORMAT T "~%The constructor does not supply a value for ~
					the required init-keyword~P ~{~S~^, ~}~@
					because &AUX has been used to suppress ~A."
				    (LENGTH SUPPRESSED) SUPPRESSED
				    (IF (CDR SUPPRESSED) "them" "it")))
			  (WHEN OPTIONAL
			    (FORMAT T "~%The constructor only supplies a value for ~
					the required init-keyword~P ~{~S~^, ~}~@
					when the corresponding argument~2:*~P~* to ~
					the constructor ~A supplied,~@
					since no default was specified for ~A."
				    (LENGTH OPTIONAL) OPTIONAL
				    (IF (CDR OPTIONAL) "are" "is")
				    (IF (CDR OPTIONAL) "these init-keywords"
					"this init-keyword")))))))
	;; Decide whether to use the template or initialize things explicitly
	(COND ((> (LOOP FOR VAR IN ALL-VARS
			COUNT (AND (NOT (MEMBER VAR VARS))
				   (NOT (ASSOC VAR HARD-VARS))
				   (NOT (FIND VAR UNBOUND :KEY #'THIRD))))
		  4)
	       (SETQ USE-TEMPLATE T))
	      (T
	       ;; Initialize them individually
	       (SETQ USE-TEMPLATE NIL)
	       (DOLIST (VAR ALL-VARS)
		 (WHEN (AND (NOT (MEMBER VAR VARS))
			    (NOT (ASSOC VAR HARD-VARS))
			    (NOT (FIND VAR UNBOUND :KEY #'THIRD)))
		   (IF (SETQ TEM (ASSOC VAR EASY-VARS))
		       (PUSH `(,VAR ',(SECOND TEM)) HARD-VARS)
		       (PUSH (LIST NIL (POSITION VAR ALL-VARS) VAR) UNBOUND))))))
	COLLECT
	  `(DEFUN ,NAME ,ARGS
	     (DECLARE (FUNCTION-PARENT ,FLAVOR-NAME DEFFLAVOR)
		      (CONSTRUCTOR-DERIVATION . ,DERIVATION)
		      (CONSTRUCTOR-ARGLIST . ,ORIGINAL-ARGS)
		      ,@(WHEN DUMMY-ARG0
			  `((ARGLIST . ,(LDIFF (CDDR ARGS) (MEMBER '&AUX ARGS))))))
	     ,@(WHEN REST `((SETQ ,REST (COPY-LIST ,REST))))
	     ,@(WHEN SUPPRESSED-INIT-OPTIONS
		 `((IGNORE ,@(MAPCAR #'SECOND SUPPRESSED-INIT-OPTIONS))))
	     ;; In case a version of this function with the EVAL-AT-LOAD-TIME-MARKER
	     ;; still in it ever gets called, blow up before creating an instance
	     ;; with a bad header.
	     (UNLESS (ARRAYP ,FLV)
	       (RETURN-FROM ,NAME
		 (COMPILE-TIME-CONSTRUCTOR-CALLED)))
	     ;; Create the instance and initialize the constant parts of it
	     (SETQ ,ARG0 (SI:%MAKE-STRUCTURE DTP-INSTANCE
					     DTP-HEADER-P %HEADER-TYPE-INSTANCE ,FLV
					     ,(OR AREA-VAR AREA-FORM)
					     ,(FLAVOR-INSTANCE-SIZE FL)))
	     ,@(WHEN USE-TEMPLATE
		 `((%BLOCK-COPY-ALLOW-NULL (FLAVOR-TEMPLATE-INSTANCE ,FLV)
					   ,ARG0
					   ,(FLAVOR-INSTANCE-SIZE FL))))
	     ;; Store values of variables mentioned in the arglist
	     ;; Reconsider which subprimitive to use on the I-Machine:
	     ;; %STORE-INSTANCE-VARIABLE-ORDERED does a read-alter-rewrite to follow
	     ;; forwarding pointers and preserve the cdr-code, but doesn't bounds-check
	     ;; the position.  Reading is safe because newly allocated storage is
	     ;; always initialized, even on the data-stack.
	     ;; %P-STORE-CDR-AND-CONTENTS doesn't read before writing,
	     ;; but it takes two more instructions so I think it's slower.
	     ,@(LOOP FOR VAR IN (REVERSE VARS)
		     UNLESS (MEMBER VAR EXPLICIT-UNBOUND)
		       WHEN (SETQ POS (POSITION VAR ALL-VARS))
			 COLLECT `(COMPILER:%STORE-INSTANCE-VARIABLE-ORDERED
				    ,(IF (EQ VAR ARG0) ARG1 VAR) ,(1+ POS)))
	     ;; Store values of slots with nonconstant initialization forms that
	     ;; were not mentioned in the arglist
	     ,@(LOOP FOR (VAR FORM) IN HARD-VARS
		     UNLESS (MEMBER VAR VARS)
		       COLLECT `(COMPILER:%STORE-INSTANCE-VARIABLE-ORDERED
				    ,FORM ,(1+ (POSITION VAR ALL-VARS))))
	     ;; Make slots unbound that need to be
	     ,@(LOOP FOR (COND POS VAR) IN UNBOUND
		     COLLECT `(UNLESS ,COND
				(%P-STORE-TAG-AND-POINTER
				  (%MAKE-POINTER-OFFSET DTP-LOCATIVE ,ARG0 ,(1+ POS))
				  DTP-NULL ',VAR)))
	     ;; Invoke methods if there are any
	     ,@(IF (OR (AND INIT-OPTIONS (MEMBER ':INIT GENERICS))
		       OPTIONAL-INIT-OPTIONS)
		   ;; Hard case, have to materialize the init options in a variable
		   `((STACK-LET ((INIT-OPTIONS (LIST ,@INIT-OPTIONS)))
		       ,@(WHEN OPTIONAL-INIT-OPTIONS
			   `((%ASSURE-PDL-ROOM ,(+ (* (LENGTH OPTIONAL-INIT-OPTIONS) 3) 10))))
		       ,@(LOOP FOR (KEY VAR SUPPLIED-P) IN OPTIONAL-INIT-OPTIONS
			       COLLECT `(WHEN ,SUPPLIED-P
					  (%PUSH ',KEY)
					  (%PUSH ,(IF (EQ VAR ARG0) ARG1 VAR))
					  (%PUSH INIT-OPTIONS)
					  ;;--- Knows too much about the guts of the compiler
					  (%CHANGE-LIST-TO-CONS
					    (COMPILER:%STACK-LOCATION-INTERNAL 2))
					  (SETQ INIT-OPTIONS
						(%MAKE-POINTER DTP-LIST
						  (COMPILER:%STACK-LOCATION-INTERNAL 2)))))
		       ,@(WHEN (MEMBER 'MAKE-INSTANCE GENERICS)
			   `((APPLY (GENERIC MAKE-INSTANCE) ,ARG0 INIT-OPTIONS)))
		       ,@(WHEN (MEMBER ':INIT GENERICS)
			   `((SEND ,ARG0 :INIT (LOCF INIT-OPTIONS))))
		       ;; Value is the instance
		       ;; inside the stack-let, so the compiler won't forget about the %PUSHes
		       ,ARG0))
		   ;; Normal case
		   `(,@(WHEN (MEMBER 'MAKE-INSTANCE GENERICS)
			 `((FUNCALL (GENERIC MAKE-INSTANCE) ,ARG0 ,@INIT-OPTIONS)))
		     ,@(WHEN (MEMBER ':INIT GENERICS)
			 `((SEND ,ARG0 :INIT NIL)))
		     ;; Value is the instance
		     ,ARG0)))))

(DEFUN I-COMPOSE-CONSTRUCTOR-FUNCTIONS (FL ENV)
  (LOOP FOR (NAME . ARGS) IN (FLAVOR-CONSTRUCTORS FL)
	AS COMPILER:DEFAULT-WARNING-FUNCTION = NAME
	WITH COMPILER:DEFAULT-WARNING-DEFINITION-TYPE = 'DEFUN
	WITH FLAVOR-NAME = (FLAVOR-NAME FL)
	WITH DERIVATION = (FLAVOR-CONSTRUCTOR-DERIVATION FL ENV)
	AS (ALL-VARS EASY-VARS HARD-VARS INIT-KEYWORDS EASY-INIT HARD-INIT
	    AREA-KEYWORD AREA-FORM GENERICS) = DERIVATION
	WITH (TEM POS PAIR VPAIR KEY DEFAULT FLV ORIGINAL-ARGS)
	AS KIND = NIL AS COND-UNBOUND = NIL AS REST = NIL AS VARS = NIL
	AS INSTANCE-VAR = (GENSYM)
	AS EXPLICIT-UNBOUND = NIL 
	AS INIT-OPTIONS = NIL			;list of forms, keywords are quoted
	AS OPTIONAL-INIT-OPTIONS = NIL		;list of (keyword value-var supplied-p-var)
	AS SUPPRESSED-INIT-OPTIONS = NIL	;list of (keyword value-var)
	AS AREA-VAR = NIL DO
        ;; Expand the one-argument :CONSTRUCTOR option
        (SETQ ORIGINAL-ARGS (SETQ ARGS (FLAVOR-CONSTRUCTOR-ARGLIST FL ARGS)))
	;; Classify arguments into instance-variables, init-options, and instance area.
	;; Insert supplied-p vars into arglist where needed.
	(DOLIST (VAR ARGS)
	  (COND ((MEMBER VAR LAMBDA-LIST-KEYWORDS)
		 (CASE VAR
		   ((&OPTIONAL &REST &KEY &AUX)
		    (SETQ KIND VAR))
		   ((&ALLOW-OTHER-KEYS))
		   (OTHERWISE
		     (WARN "Error in constructor function ~S for flavor ~S.~@
			   ~S is an invalid lambda-list keyword in a constructor."
			   NAME FLAVOR-NAME VAR))))
		(T
		 (SETQ PAIR VAR VPAIR VAR DEFAULT NIL KEY NIL)
		 (UNLESS (ATOM VAR)
		   (SETQ VAR (CAR PAIR) DEFAULT (CDR PAIR))
		   (SETQ VPAIR VAR)
		   (WHEN (EQ KIND '&KEY)
		     (UNLESS (ATOM VAR)
		       (SETQ KEY (CAR VAR)	;&KEY with explicit keyword
			     VAR (CADR VAR)))))
		 (UNLESS (AND (SYMBOLP VAR) (NOT (CONSTANTP VAR)))
		   (WARN "Error in constructor function ~S for flavor ~S.~@
			 ~S where a variable is required in the parameter list."
			 NAME FLAVOR-NAME VAR)
		   (SETQ VAR 'FOO))
		 (UNLESS (SETQ POS (POSITION VAR ALL-VARS))
		   (UNLESS KEY
		     (SETQ KEY (INTERN (SYMBOL-NAME VAR) PKG-KEYWORD-PACKAGE)))
		   (COND ((EQ KEY AREA-KEYWORD)
			  (WHEN AREA-VAR
			    (WARN "Error in constructor function ~S for flavor ~S.~@
				  Both ~S and ~S specify the area for instance creation."
				  NAME FLAVOR-NAME AREA-VAR VAR))
			  (SETQ AREA-VAR VAR))
			 ((MEMBER KEY INIT-KEYWORDS)
			  (LOOP FOR ((NIL K) V) ON INIT-OPTIONS BY 'CDDR DO
			    (WHEN (EQ K KEY)
			      (WARN "Error in constructor function ~S for flavor ~S.~@
				    Both ~S and ~S specify the ~S init-keyword."
				    NAME FLAVOR-NAME VAR V KEY)))
			  (SETQ INIT-OPTIONS (NCONC INIT-OPTIONS `(',KEY ,VAR))))
			 (T
			  (WARN "Error in parameter list of ~
				constructor function ~S for flavor ~S.~@
				~S is not the name of an instance variable~
				~:[~2*~;~%and ~S is not the area-keyword ~S~]~
				~[~0;~2*~1;~%and ~S is not the init-keyword ~{~S~}~
				  ~:;~%and ~S is not one of the init-keywords ~{~S~^, ~}~]."
				NAME FLAVOR-NAME
				VAR
				AREA-KEYWORD KEY AREA-KEYWORD
				(LENGTH INIT-KEYWORDS) KEY INIT-KEYWORDS))))
		 (PUSH VAR VARS)
		 (WHEN (EQ KIND '&REST)
		   (SETQ REST VAR))		;Will need to be copied
		 ;; If this argument can be defaulted, but no default was specified,
		 ;; then unlike a normal defun, the default is nonlocal and comes from
		 ;; the defflavor, except for &aux variables, which behave as if no
		 ;; default had been specified in the defflavor (i.e. unbound).
		 ;; This is as specified by CLtL for defstruct.
		 (WHEN (AND KIND (NEQ KIND '&REST) (NOT DEFAULT))
		   (COND (POS			;This is an instance variable initialization
			  (CASE KIND
			    (&AUX
			     (PUSH VAR EXPLICIT-UNBOUND)
			     (SETQ ARGS (REMOVE PAIR ARGS)))
			    ((&OPTIONAL &KEY)
			     (COND ((SETQ TEM (ASSOC VAR EASY-VARS))
				    (SETQ ARGS (SUBSTITUTE `(,VPAIR ',(CADR TEM)) PAIR ARGS)))
				   ((SETQ TEM (ASSOC VAR HARD-VARS))
				    (SETQ ARGS (SUBSTITUTE `(,VPAIR ,(CADR TEM)) PAIR ARGS)))
				   (T (SETQ TEM (GENSYM))	;Supplied-p variable
				      (SETQ ARGS (SUBSTITUTE `(,VPAIR NIL ,TEM) PAIR ARGS))
				      (PUSH (LIST VAR TEM) COND-UNBOUND))))))
			 ((EQ KEY AREA-KEYWORD)
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR ,AREA-FORM) PAIR ARGS)))
			 ((NOT (MEMBER KEY INIT-KEYWORDS)))
			 ((EQ KIND '&AUX)
			  (PUSH (LIST KEY VAR) SUPPRESSED-INIT-OPTIONS)
			  (SETQ INIT-OPTIONS (NBUTLAST INIT-OPTIONS 2)))
			 ((SETQ TEM (GETF HARD-INIT KEY))
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR ,TEM) PAIR ARGS)))
			 ((OR (SETQ TEM (GETF EASY-INIT KEY))
			      (LOOP FOR K IN EASY-INIT BY 'CDDR THEREIS (EQ K KEY)))
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR ',TEM) PAIR ARGS)))
			 (T
			  (SETQ TEM (GENSYM))	;Supplied-p variable
			  (SETQ ARGS (SUBSTITUTE `(,VPAIR NIL ,TEM) PAIR ARGS))
			  (PUSH (LIST KEY VAR TEM) OPTIONAL-INIT-OPTIONS)
			  (SETQ INIT-OPTIONS (NBUTLAST INIT-OPTIONS 2))))))))
	;; Arrange to have the flavor structure on hand.  The flavor structure is a constant
	;; in the constructor function for speed and, more importantly, so we can be
	;; sure its flavor-instance-size agrees with the one we are compiling into
	;; various parts of the body of the constructor function.
	(SETQ FLV (GENSYM)
	      TEM `(,FLV ',(COND ((AND (EQ ENV 'COMPILE) UNDO-DECLARATIONS-FLAG)
				  (CONS COMPILER:EVAL-AT-LOAD-TIME-MARKER
					`(LOAD-TIME-FIND-FLAVOR ',(FLAVOR-NAME FL)
								,(FLAVOR-INSTANCE-SIZE FL))))
				 (T
				  ;; The FLAVOR-INSTANTIATED bit must be set, so that the
				  ;; instance-size can't be changed by redefining the flavor.
				  ;; Don't wait until the constructor is actually called
				  ;; before setting it, that would be too late!
				  (SETF (FLAVOR-INSTANTIATED FL) T)
				  FL))))
	(SETQ ARGS `(,@ARGS ,@(IF (EQ KIND '&AUX) NIL '(&AUX)) ,INSTANCE-VAR ,TEM))
	;; Default any init-options that don't come from arguments
	(LOOP FOR (KEY VAL) ON HARD-INIT BY 'CDDR DO
	  (UNLESS (OR (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
		      (ASSOC KEY OPTIONAL-INIT-OPTIONS)
		      (LOOP FOR (NIL K) IN INIT-OPTIONS BY 'CDDR THEREIS (EQ K KEY)))
	    (SETQ INIT-OPTIONS (NCONC INIT-OPTIONS `(',KEY ,VAL)))))
	(LOOP FOR (KEY VAL) ON EASY-INIT BY 'CDDR DO
	  (UNLESS (OR (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
		      (ASSOC KEY OPTIONAL-INIT-OPTIONS)
		      (LOOP FOR (NIL K) IN INIT-OPTIONS BY 'CDDR THEREIS (EQ K KEY)))
	    (SETQ INIT-OPTIONS (NCONC INIT-OPTIONS `(',KEY ',VAL)))))
	;; Make sure all required-init-options have been handled
	(LOOP FOR KEY IN (FLAVOR-ALL-REQUIRED-KEYWORDS FL)
	      UNLESS (OR (LOOP FOR (NIL K) IN INIT-OPTIONS BY 'CDDR THEREIS (EQ K KEY))
			 (LET ((VAR (ASSOC KEY (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL))))
			   (WHEN VAR
			     (SETQ VAR (NTH (1- (SECOND VAR)) ALL-VARS))
			     (OR (MEMBER VAR VARS)	;Initialized by argument
				 (ASSOC VAR HARD-VARS)	;Initialized by default-init-plist
				 (ASSOC VAR EASY-VARS)))))	;..
		COLLECT KEY INTO REQUIRED-KEYWORDS
	      FINALLY
		(WHEN REQUIRED-KEYWORDS
		  ;; These missing INIT-OPTIONS could be in one of three states:
		  ;; (1) Missing completely.
		  ;; (2) OPTIONAL-INIT-OPTIONS, supplied to init methods only when
		  ;;     supplied to the constructor.
		  ;; (3) SUPPRESSED-INIT-OPTIONS, disabled via &AUX.
		  (WARN "Error in constructor function ~S for flavor ~S.~v,v,vQ"
			NAME FLAVOR-NAME
			(LOOP FOR KEY IN REQUIRED-KEYWORDS
			      WHEN (ASSOC KEY OPTIONAL-INIT-OPTIONS)
				COLLECT KEY)
			(LOOP FOR KEY IN REQUIRED-KEYWORDS
			      WHEN (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
				COLLECT KEY)
			(LOOP FOR KEY IN REQUIRED-KEYWORDS
			      UNLESS (ASSOC KEY OPTIONAL-INIT-OPTIONS)
				UNLESS (ASSOC KEY SUPPRESSED-INIT-OPTIONS)
				  COLLECT KEY)
			(LAMBDA (OPTIONAL SUPPRESSED MISSING)
			  (WHEN MISSING
			    (FORMAT T "~%The constructor does not supply a value for ~
					the required init-keyword~P ~{~S~^, ~}."
				    (LENGTH MISSING) MISSING))
			  (WHEN SUPPRESSED
			    (FORMAT T "~%The constructor does not supply a value for ~
					the required init-keyword~P ~{~S~^, ~}~@
					because &AUX has been used to suppress ~A."
				    (LENGTH SUPPRESSED) SUPPRESSED
				    (IF (CDR SUPPRESSED) "them" "it")))
			  (WHEN OPTIONAL
			    (FORMAT T "~%The constructor only supplies a value for ~
					the required init-keyword~P ~{~S~^, ~}~@
					when the corresponding argument~2:*~P~* to ~
					the constructor ~A supplied,~@
					since no default was specified for ~A."
				    (LENGTH OPTIONAL) OPTIONAL
				    (IF (CDR OPTIONAL) "are" "is")
				    (IF (CDR OPTIONAL) "these init-keywords"
					"this init-keyword")))))))
	(DOLIST (VAR ALL-VARS)
	  (WHEN (AND (NOT (MEMBER VAR VARS))
		     (NOT (ASSOC VAR HARD-VARS))
		     (NOT (ASSOC VAR COND-UNBOUND))
		     (SETQ TEM (ASSOC VAR EASY-VARS)))
	    (PUSH `(,VAR ',(SECOND TEM)) HARD-VARS)))
	COLLECT
	  `(DEFUN ,NAME ,ARGS
	     (DECLARE (FUNCTION-PARENT ,FLAVOR-NAME DEFFLAVOR)
		      (CONSTRUCTOR-DERIVATION . ,DERIVATION)
		      (CONSTRUCTOR-ARGLIST . ,ORIGINAL-ARGS))
	     ,@(WHEN REST `((SETQ ,REST (COPY-LIST ,REST))))
	     ,@(WHEN SUPPRESSED-INIT-OPTIONS
		 `((IGNORE ,@(MAPCAR #'SECOND SUPPRESSED-INIT-OPTIONS))))
	     ;; In case a version of this function with the EVAL-AT-LOAD-TIME-MARKER
	     ;; still in it ever gets called, blow up before creating an instance
	     ;; with a bad header.
	     (UNLESS (ARRAYP ,FLV)
	       (RETURN-FROM ,NAME
		 (COMPILE-TIME-CONSTRUCTOR-CALLED)))
	     ;; Create the instance and initialize the constant parts of it
	     (SETQ ,INSTANCE-VAR (SI:%MAKE-STRUCTURE DTP-INSTANCE
						     DTP-HEADER-P %HEADER-TYPE-INSTANCE
						     (LOCF (%FLAVOR-HASH-MASK ,FLV))
						     ,(OR AREA-VAR AREA-FORM)
						     ,(FLAVOR-INSTANCE-SIZE FL)))
	     ;; BAR-1 now points to the the location of the first instance variable
	     (SI:PREPARE-FOR-BLOCK-WRITE)
	     ,@(LOOP FOR INSTANCE-VAR IN ALL-VARS
		     FOR VALUE = (IF (MEMBER INSTANCE-VAR VARS)
				     (IF (MEMBER INSTANCE-VAR EXPLICIT-UNBOUND)
					 `(SI:%SET-TAG ',INSTANCE-VAR DTP-NULL)
					 INSTANCE-VAR)
				     (LET ((TEMP (ASSOC INSTANCE-VAR HARD-VARS)))
				       (IF TEMP
					   (LET ((FORM (SECOND TEMP)))
					     (IF (OR (AND (CONSP FORM)
							  (NEQ (FIRST FORM) 'QUOTE))
						     (AND (SYMBOLP FORM)
							  (LT:SYMBOL-MACRO-P FORM ENV)))
						 `(LET ((.BAR. (%BLOCK-REGISTER 1)))
						    (PROG1 ,FORM
							   (SETF (%BLOCK-REGISTER 1) .BAR.)
							   (SI:PREPARE-FOR-BLOCK-WRITE)))
						 FORM))
					   `(SI:%SET-TAG ',INSTANCE-VAR DTP-NULL))))
		     FOR COND = (ASSOC INSTANCE-VAR COND-UNBOUND)
		     COLLECTING
		       `(SI:%BLOCK-WRITE
			  1
			  ,(IF COND
			       `(IF ,(SECOND COND)
				    ,VALUE
				    (SI:%SET-TAG ',INSTANCE-VAR DTP-NULL))
			       VALUE)))
	     ;; Invoke methods if there are any
	     ,@(IF (OR (AND INIT-OPTIONS (MEMBER ':INIT GENERICS))
		       OPTIONAL-INIT-OPTIONS)
		   ;; Hard case, have to materialize the init options in a variable
		   `((STACK-LET ((INIT-OPTIONS (LIST ,@INIT-OPTIONS)))
		       ,@(WHEN OPTIONAL-INIT-OPTIONS
			   `((%ASSURE-PDL-ROOM ,(+ (* (LENGTH OPTIONAL-INIT-OPTIONS) 3) 10))))
		       ,@(LOOP FOR (KEY VAR SUPPLIED-P) IN OPTIONAL-INIT-OPTIONS
			       COLLECT `(WHEN ,SUPPLIED-P
					  (%PUSH ',KEY)
					  (%PUSH ,VAR)
					  (%PUSH INIT-OPTIONS)
					  ;;--- Knows too much about the guts of the compiler
					  (%CHANGE-LIST-TO-CONS
					    (COMPILER:%STACK-LOCATION-INTERNAL 2))
					  (SETQ INIT-OPTIONS
						(%MAKE-POINTER DTP-LIST
						  (COMPILER:%STACK-LOCATION-INTERNAL 2)))))
		       ,@(WHEN (MEMBER 'MAKE-INSTANCE GENERICS)
			   `((APPLY (GENERIC MAKE-INSTANCE) ,INSTANCE-VAR INIT-OPTIONS)))
		       ,@(WHEN (MEMBER ':INIT GENERICS)
			   `((SEND ,INSTANCE-VAR :INIT (LOCF INIT-OPTIONS))))
		       ;; Value is the instance
		       ;; inside the stack-let, so the compiler won't forget about the %PUSHes
		       ,INSTANCE-VAR))
		   ;; Normal case
		   `(,@(WHEN (MEMBER 'MAKE-INSTANCE GENERICS)
			 `((FUNCALL (GENERIC MAKE-INSTANCE) ,INSTANCE-VAR ,@INIT-OPTIONS)))
		     ,@(WHEN (MEMBER ':INIT GENERICS)
			 `((SEND ,INSTANCE-VAR :INIT NIL)))
		     ;; Value is the instance
		     ,INSTANCE-VAR)))))

(DEFUN COMPILE-TIME-CONSTRUCTOR-CALLED ()
  (DECLARE (DBG:ERROR-REPORTER))
  (ERROR "Compile-time version of constructor function called.  It cannot~@
	  operate correctly until it has been dumped to a BIN file and loaded again."))

(DEFUN FLAVOR-CONSTRUCTOR-DERIVATION (FL ENV)
  ;; Error check before using subprimitives
  (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL)
    (ERROR "Internal error: Can't make constructors for flavor ~S because it hasn't
had its initialization information composed.  Please report this bug in the flavor system."
	   (FLAVOR-NAME FL)))
  (LET* ((TEMPLATE (FLAVOR-TEMPLATE-INSTANCE FL))
	 (ALL-VARS (FLAVOR-ALL-INSTANCE-VARIABLES FL))
	 (EASY-VARS (LOOP FOR SLOT FROM 1 FOR VAR IN ALL-VARS
			  UNLESS (= (%P-LDB-OFFSET %%Q-DATA-TYPE TEMPLATE SLOT) DTP-NULL)
			    COLLECT (LIST VAR (%P-CONTENTS-OFFSET TEMPLATE SLOT))))
	 (HARD-VARS (LOOP FOR SLOT FROM 1 FOR VAR IN ALL-VARS
			  WITH INIT = (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS FL)
			  AS ELEM = (FIND SLOT INIT :KEY #'SECOND)
			  WHEN ELEM COLLECT (LIST VAR (FIRST ELEM))))
	 (INIT-KEYWORDS (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL))
	 (EASY-INIT (FLAVOR-ALL-OTHER-DEFAULT-INIT-CONSTANTS FL))
	 (HARD-INIT (FLAVOR-ALL-OTHER-DEFAULT-INIT-FORMS FL))
	 (AREA-KEYWORD (FLAVOR-AREA-KEYWORD FL))
	 ;; Form to evaluate to get the area in which to create instances
	 (AREA-FORM (IF (INTEGERP (FLAVOR-INSTANCE-AREA FL))
			(AREA-NAME (FLAVOR-INSTANCE-AREA FL))	;Un-evaluate
			(FLAVOR-INSTANCE-AREA FL)))
	 (GENERICS NIL))
    (WHEN (FLAVOR-HAS-INIT-METHOD FL)
      (PUSH ':INIT GENERICS))
    (WHEN (LOOP FOR METHOD IN (CDDAR (COLLECT-METHODS (FLAVOR-NAME FL) :ENV ENV
						      :GENERIC 'MAKE-INSTANCE))
		THEREIS (NEQ (METHOD-FLAVOR METHOD) 'VANILLA))
      (PUSH 'MAKE-INSTANCE GENERICS))
    (LIST ALL-VARS EASY-VARS HARD-VARS INIT-KEYWORDS EASY-INIT HARD-INIT
	  AREA-KEYWORD AREA-FORM GENERICS
	  #+IMach *FLAVOR-CONSTRUCTOR-VERSION*)))

;; Expand the one-argument :CONSTRUCTOR option now that the flavor is composed.
;; Depends on current value of *PACKAGE*, normally the package current
;; when a COMPILE-FLAVOR-METHODS form is compiled/loaded.  Cannot use gensyms
;; for these variables, because VALIDATE-CONSTRUCTOR-FUNCTIONS calls EQUAL.
(DEFUN FLAVOR-CONSTRUCTOR-ARGLIST (FL ARGS)
  (FLET ((KEY (KEY &OPTIONAL (VAR (INTERN (SYMBOL-NAME KEY))))
	   (IF (AND (STRING= VAR KEY)
		    (EQ (SYMBOL-PACKAGE KEY) PKG-KEYWORD-PACKAGE))
	       VAR
	       `((,KEY ,VAR)))))
    (IF (EQ ARGS 'ALL-VARS)
	`(&KEY ,@(LOOP FOR (KEY POS) IN (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL)
		       COLLECT (KEY KEY (NTH (1- POS) (FLAVOR-ALL-INSTANCE-VARIABLES FL))))
	       ,@(LOOP FOR KEY IN (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL)
		       COLLECT (KEY KEY))
	       ,(KEY (FLAVOR-AREA-KEYWORD FL)))
	ARGS)))

;--- Might be useful to FUNDEFINE constructors that were created by a former
;--- incarnation of this flavor, but no longer requested at all.  Right now
;--- they aren't recorded anywhere, though.
(DEFUN VALIDATE-CONSTRUCTOR-FUNCTIONS (FL)
  (WHEN (FLAVOR-CONSTRUCTORS FL)
    (UNLESS (FLAVOR-INSTANTIABLE FL)
      ;; Ensure that calling the constructor will produce an instance that works
      (PREPARE-FOR-INSTANTIATION FL))
    (LET ((DERIVATION (FLAVOR-CONSTRUCTOR-DERIVATION FL NIL)))
      (UNLESS (LOOP FOR (FUNCTION . ARGS) IN (FLAVOR-CONSTRUCTORS FL)
		    AS DEBUG-INFO = (DEBUGGING-INFO FUNCTION)
		    ALWAYS (AND (FBOUNDP FUNCTION)
				(EQUAL (CDR (ASSOC 'CONSTRUCTOR-ARGLIST DEBUG-INFO))
				       (FLAVOR-CONSTRUCTOR-ARGLIST FL ARGS))
				(EQUAL (CDR (ASSOC 'CONSTRUCTOR-DERIVATION DEBUG-INFO))
				       DERIVATION)))
	(COMPILE-FUNCTION-LIST (COMPOSE-CONSTRUCTOR-FUNCTIONS FL NIL))))))

;;; Find a FL that has the specified FLAVOR-INSTANCE-SIZE, because that number has
;;; been compiled into the constructor in various places.  Returning a FL with a
;;; different size would violate storage conventions and crash the transporter.
;;; So if the flavor's size is different from what it was at compile time, make
;;; a dummy flavor to be used if this constructor gets called, even though the constructor
;;; will be redefined soon, by COMPILE-FLAVOR-METHODS-LOAD-TIME.
;;; The FLAVOR-INSTANTIATED bit must be set in the returned flavor,
;;; so that the flavor-instance-size can't be changed by redefining the flavor.
(DEFUN LOAD-TIME-FIND-FLAVOR (FLAVOR-NAME FLAVOR-INSTANCE-SIZE)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME NIL)))
    (UNLESS (AND FL (EQL (FLAVOR-INSTANCE-SIZE FL) FLAVOR-INSTANCE-SIZE))
      ;; Make a flavor with just enough fields to keep the garbage collector happy
      ;; Any attempt to apply a generic function to an instance of this will signal an error
      (SETQ FL (MAKE-FLAVOR :NAME (MAKE-SYMBOL (STRING-APPEND "Extinct flavor " FLAVOR-NAME))
			    :INSTANCE-SIZE FLAVOR-INSTANCE-SIZE)))
    (SETF (FLAVOR-INSTANTIATED FL) T)
    FL))

;;;; Interfaces for init keywords that are documented (may be somewhat brain damaged)

;Returns non-NIL if the flavor allows the specified keyword in its init-plist,
;NIL if it doesn't.  The return value is the name of the component flavor
;that actually handles it.
;We won't concern ourselves with :allow-other-keys
(DEFUN FLAVOR-ALLOWS-INIT-KEYWORD-P (FLAVOR-NAME KEYWORD)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (UNLESS (FLAVOR-COMPONENTS-COMPOSED FL)
      (COMPOSE-FLAVOR-COMBINATION FLAVOR-NAME))
    (LOOP FOR FLAVOR-NAME IN (FLAVOR-ALL-COMPONENTS FL)
	  AS FL = (FIND-FLAVOR FLAVOR-NAME)
	  WITH AREA-SPECIFIED = NIL DO
      (WHEN (OR (ASSOC KEYWORD (FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FL))
		(MEMBER KEYWORD (FLAVOR-INIT-KEYWORDS FL)))
	(RETURN FLAVOR-NAME))
      (UNLESS AREA-SPECIFIED
	(WHEN (FLAVOR-AREA-KEYWORD-SPECIFIED FL)
	  (SETQ AREA-SPECIFIED T)
	  (WHEN (EQ KEYWORD (FLAVOR-AREA-KEYWORD FL))
	    (RETURN FLAVOR-NAME)))))))

;;; Given the name of a flavor, return a list of all of the symbols that
;;; are valid init-options for the flavor, sorted alphabetically.  This
;;; function is primarily for people to call in order to get information;
;;; specifically, so that people writing documentation can be sure to
;;; document all of the init-options that exist.
(DEFUN FLAVOR-ALLOWED-INIT-KEYWORDS (FLAVOR-NAME)
  (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
    (UNLESS (FLAVOR-INITIALIZATIONS-COMPOSED FL)
      (COMPOSE-INITIALIZATIONS FLAVOR-NAME))
    (SORT (APPEND (MAPCAR #'CAR (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL))
		  (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL)
		  (AND (FLAVOR-AREA-KEYWORD FL)
		       (LIST (FLAVOR-AREA-KEYWORD FL))))
	  #'ALPHALESSP)))

(DEFUN FLAVOR-DEFAULT-INIT-GET (FLAVOR INDICATOR &OPTIONAL DEFAULT)
  (LET ((FL (IF (TYPEP FLAVOR 'FLAVOR) FLAVOR (FIND-FLAVOR FLAVOR))))
    (GETF (FLAVOR-DEFAULT-INIT-PLIST FL) INDICATOR DEFAULT)))

(DEFSETF FLAVOR-DEFAULT-INIT-GET (FLAVOR INDICATOR) (VALUE)
  `(FLAVOR-DEFAULT-INIT-PUTPROP ,FLAVOR ,VALUE ,INDICATOR))

(DEFUN FLAVOR-DEFAULT-INIT-PUTPROP (FLAVOR VALUE INDICATOR)
  (LET ((FL (IF (TYPEP FLAVOR 'FLAVOR) FLAVOR (FIND-FLAVOR FLAVOR))))
    (SETF (GETF (FLAVOR-DEFAULT-INIT-PLIST FL) INDICATOR) VALUE)
    (REDEFINE-FLAVOR-INITIALIZATIONS FL)
    VALUE))

(DEFUN FLAVOR-DEFAULT-INIT-REMPROP (FLAVOR INDICATOR)
  (LET ((FL (IF (TYPEP FLAVOR 'FLAVOR) FLAVOR (FIND-FLAVOR FLAVOR))))
    (PROG1 (REMF (FLAVOR-DEFAULT-INIT-PLIST FL) INDICATOR)
	   (REDEFINE-FLAVOR-INITIALIZATIONS FL))))

(DEFUN REDEFINE-FLAVOR-INITIALIZATIONS (FL)
  ;; These two bindings should not be needed, as components and instance
  ;; variables are not being changed.  However, they can't hurt.
  (WITH-PENDING-DW-UPDATES
    (WITH-TRANSFORM-FLAVOR-WARNINGS
      (DO-ALL-COMPOSED-DEPENDENTS (FLAVOR FFL FL)
	(REDEFINE-FLAVOR FLAVOR T T T T T)))))

;;;; MAKE-INSTANCE itself

;; NB: First arg is FLAVOR-NAME when called, but INSTANCE when methods receive control
;; NB: This is not compatible with :INIT, args are in different format to enable
;;     use of &KEY in the methods.
;; :ALLOW-OTHER-KEYS :RETURN makes the unhandled keys be returned as a second value
;; I'm not sure if anybody will need this, but what the hell.
;; I didn't put in a VALUES declaration for it since it only returns a second value
;; at all if :ALLOW-OTHER-KEYS :RETURN is actually specified.
(DEFGENERIC MAKE-INSTANCE (FLAVOR-NAME &REST INIT-OPTIONS)
  (:METHOD-COMBINATION :TWO-PASS)
  (:METHOD-ARGLIST &REST INIT-OPTIONS)
  (:FUNCTION
    (LET ((FL (FIND-FLAVOR FLAVOR-NAME)))
      (WHEN (FLAVOR-HAS-MIXTURE FL)
	;; Maybe instantiate some other flavor, mixed out of this one
	(SETQ FLAVOR-NAME (DECODE-FLAVOR-MIXTURE FLAVOR-NAME INIT-OPTIONS)
	      FL (FIND-FLAVOR FLAVOR-NAME)))
      (UNLESS (FLAVOR-INSTANTIABLE FL)
	(PREPARE-FOR-INSTANTIATION FL))
      (LET ((VARIABLES-INITIALIZED-MASK 0)
	    (MAX-STACK-CONSING (FLOOR (- CONTROL-STACK-MAX-FRAME-SIZE 100) 3))
	    TEM TEM1 INSTANCE
	    (VARIABLE-INIT-KEYWORDS (FLAVOR-ALL-VARIABLE-INIT-KEYWORDS FL))
	    (OTHER-INIT-KEYWORDS (FLAVOR-ALL-OTHER-INIT-KEYWORDS FL))
	    (AREA-KEYWORD (FLAVOR-AREA-KEYWORD FL))
	    (UNHANDLED-KEYWORDS (FLAVOR-ALL-UNHANDLED-KEYWORDS FL))
	    (ALLOW-OTHER-KEYS (OR (FLAVOR-ALL-ALLOW-OTHER-KEYS FL)
				  (GETF INIT-OPTIONS ':ALLOW-OTHER-KEYS)))
	    (REQUIRED-KEYWORDS (FLAVOR-ALL-REQUIRED-KEYWORDS FL)))
	;; Check that all required keywords were supplied, before making the instance.
	;; Don't actually signal the error until we have checked for other errors, though,
	;; so that all errors get reported at the same time.
	(WHEN REQUIRED-KEYWORDS
	  (LOOP FOR KEYWORD IN INIT-OPTIONS BY 'CDDR
		WITH MASK = (1- (ASH 1 (LENGTH REQUIRED-KEYWORDS)))
		AS POS = (POSITION KEYWORD REQUIRED-KEYWORDS)
		DO (WHEN POS (SETQ MASK (LOGAND MASK (LOGNOT (ASH 1 POS)))))
		FINALLY
		  (SETQ REQUIRED-KEYWORDS (AND (NOT (ZEROP MASK))	;Speed bum
					       (LOOP FOR KEYWORD IN REQUIRED-KEYWORDS
						     FOR BIT FROM 0
						     WHEN (LOGBITP BIT MASK)
						       COLLECT KEYWORD)))))
	;; Only make the instance if we aren't going to signal an error later
	(UNLESS REQUIRED-KEYWORDS
	  (SETQ INSTANCE (SI:%MAKE-STRUCTURE DTP-INSTANCE
					     DTP-HEADER-P %HEADER-TYPE-INSTANCE
					     (PROGN
					       #+3600 FL
					       #+IMACH (LOCF (%FLAVOR-HASH-MASK FL)))
					     (OR (GETF INIT-OPTIONS AREA-KEYWORD)
						 (LET ((AREA (FLAVOR-INSTANCE-AREA FL)))
						   ;; TYPEP test is a speed bum
						   (IF (TYPEP AREA '(OR NULL INTEGER))
						       AREA
						       (EVAL AREA))))
					     (FLAVOR-INSTANCE-SIZE FL)))
	  (%BLOCK-COPY-ALLOW-NULL (FLAVOR-TEMPLATE-INSTANCE FL)
				  INSTANCE
				  (FLAVOR-INSTANCE-SIZE FL)))
	;; Iterate through INIT-OPTIONS initializing instance variables and collecting
	;; keywords that are not handled.  This is optimized assuming that the number of
	;; keywords actually supplied to MAKE-INSTANCE is usually much smaller than the
	;; number that actually could be supplied (most initables usually default).
	(LOOP FOR L ON INIT-OPTIONS BY 'CDDR AS KEYWORD = (CAR L) DO
	  (UNLESS (CDR L)
	    ;; No reason to defer reporting this particular error until the end
	    (CERROR "Use NIL as the value."
		    "The value after the keyword ~S is missing" KEYWORD))
	  (IF (SETQ TEM (ASSOC KEYWORD VARIABLE-INIT-KEYWORDS))
	      ;; An instance-variable-initializing keyword
	      ;; Ignore duplicate keywords from the right (I think this is the fastest way)
	      (UNLESS (LOOP FOR LL = INIT-OPTIONS THEN (CDDR LL) UNTIL (EQ LL L)
			    THEREIS (EQ (CAR LL) KEYWORD))
		(WHEN INSTANCE
		  (%P-STORE-CONTENTS-OFFSET (CADR L) INSTANCE (SECOND TEM)))
		(WHEN (SETQ TEM (THIRD TEM))
		  (SETQ VARIABLES-INITIALIZED-MASK
			(LOGIOR TEM VARIABLES-INITIALIZED-MASK))))
	      ;; Not an instance-variable-initializing keyword
	      (OR (AND ALLOW-OTHER-KEYS (NEQ ALLOW-OTHER-KEYS ':RETURN))
		  (MEMBER KEYWORD OTHER-INIT-KEYWORDS)
		  (AND (EQ KEYWORD AREA-KEYWORD) AREA-KEYWORD)
		  (EQ KEYWORD ':ALLOW-OTHER-KEYS)
		  (PUSHNEW KEYWORD UNHANDLED-KEYWORDS))))
	;; Complain if there are unhandled keywords or missing required keywords or both
	;; If there are no unhandled keywords then the error is proceedable, by just
	;; ignoring the keywords.  But missing required-keywords cannot reasonably
	;; be defaulted, so that error is fatal.
	(WHEN REQUIRED-KEYWORDS
	  (ERROR "~:[~3*~;Attempt to make a ~S without specifying the keyword~P ~{~S~^, ~}~
		  ~:[~;~%~]~:*~]~
		 ~:[~3*~;Flavor ~S does not handle the init keyword~P ~{~S~^, ~}~]"
		 REQUIRED-KEYWORDS FLAVOR-NAME (LENGTH REQUIRED-KEYWORDS) REQUIRED-KEYWORDS
		 (AND UNHANDLED-KEYWORDS (NOT ALLOW-OTHER-KEYS))
		 FLAVOR-NAME (LENGTH UNHANDLED-KEYWORDS) (REVERSE UNHANDLED-KEYWORDS)))
	(WHEN (AND UNHANDLED-KEYWORDS (NOT ALLOW-OTHER-KEYS))
	  (SIGNAL-PROCEED-CASE (() 'INVALID-INITIALIZATION-KEYWORD
				   :FLAVOR-NAME FLAVOR-NAME :KEYWORDS UNHANDLED-KEYWORDS)
	    (:NO-ACTION )))
	;; Default uninitialized instance variables from the default-init-plist
	(LOOP FOR (FORM SLOT MASK) IN (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS FL) DO
	  (UNLESS (LOGTEST MASK VARIABLES-INITIALIZED-MASK)
	    (%P-STORE-CONTENTS-OFFSET (EVAL FORM) INSTANCE SLOT)))
	;; Add defaulted non-instance-variable-initializing keywords to init-plist
	;; Use %PUSH to avoid consing, therefore cannot bind local variables
	;; after this point; hence the use of TEM and TEM1.
	(MACROLET ((ADD-PROPERTY (KEYWORD VALUE)
		     `(COND ((MINUSP (DECF MAX-STACK-CONSING))
			     (SETQ INIT-OPTIONS (LIST* ,KEYWORD ,VALUE INIT-OPTIONS)))
			    (T
			     (%PUSH ,KEYWORD)
			     (%PUSH ,VALUE)
			     (%PUSH INIT-OPTIONS)
			     ;;--- This knows too much about the guts of the compiler
			     ;;--- These should be an abstraction for this, sort of
			     ;;--- an "expr version" of WITH-STACK-LIST*.
			     ;;--- Or else the %FINISH-STACK-LIST* instruction should exist.
			     (%CHANGE-LIST-TO-CONS (COMPILER:%STACK-LOCATION-INTERNAL 2))
			     (SETQ INIT-OPTIONS
				   (%MAKE-POINTER DTP-LIST
						  (COMPILER:%STACK-LOCATION-INTERNAL 2)))
			     ))))
	  (SETQ TEM (FLAVOR-ALL-OTHER-DEFAULT-INIT-CONSTANTS FL))
	  (LOOP WHILE TEM DO
	    (SETQ TEM1 INIT-OPTIONS)
	    (UNLESS (LOOP WHILE TEM1 DO
		      (WHEN (EQ (CAR TEM1) (CAR TEM))
			(RETURN T))
		      (SETQ TEM1 (CDDR TEM1)))
	      (ADD-PROPERTY (CAR TEM) (CADR TEM)))
	    (SETQ TEM (CDDR TEM)))
	  (SETQ TEM (FLAVOR-ALL-OTHER-DEFAULT-INIT-FORMS FL))
	  (LOOP WHILE TEM DO
	    (SETQ TEM1 INIT-OPTIONS)
	    (UNLESS (LOOP WHILE TEM1 DO
		      (WHEN (EQ (CAR TEM1) (CAR TEM))
			(RETURN T))
		      (SETQ TEM1 (CDDR TEM1)))
	      (ADD-PROPERTY (CAR TEM) (EVAL (CADR TEM))))
	    (SETQ TEM (CDDR TEM)))
	  ;; Remember that instances of this flavor have been handed out to the world
	  ;; This SETF is conditional to avoid unnecessarily marking a page modified,
	  ;; which would move it from the load file to the paging file and interfere
	  ;; with page prefetching.
	  (UNLESS (FLAVOR-INSTANTIATED FL)
	    (SETF (FLAVOR-INSTANTIATED FL) T))
	  ;; Invoke any MAKE-INSTANCE methods
	  (APPLY (GENERIC MAKE-INSTANCE) INSTANCE INIT-OPTIONS)
	  ;; Invoke any :INIT methods (compatibility kludge)
	  (WHEN (FLAVOR-HAS-INIT-METHOD FL)
	    (SEND INSTANCE :INIT (LOCF INIT-OPTIONS)))
	  ;; Return the answer
	  (IF (EQ ALLOW-OTHER-KEYS ':RETURN)
	      (VALUES INSTANCE UNHANDLED-KEYWORDS)
	      INSTANCE))))))

;;;; Transform an instance whose flavor has been incompatibly redefined

(DEFGENERIC TRANSFORM-INSTANCE (INSTANCE NEW-FL)
  (:METHOD-ARGLIST . ())
  (:FUNCTION
    (CHECK-TYPE INSTANCE INSTANCE)
    ;; Make sure NEW-FL is ready to be instantiated
    (UNLESS (FLAVOR-INSTANTIABLE NEW-FL)
      (PREPARE-FOR-INSTANTIATION NEW-FL))
    ;; Remember that instances of this flavor have been handed out to the world
    (SETF (FLAVOR-INSTANTIATED NEW-FL) T)
    ;; Pick up characteristics of new and old flavors.  Note that these cannot change
    ;; once the FLAVOR-INSTANTIATED bit has been set.
    (LET* ((OLD-FL (%INSTANCE-FLAVOR INSTANCE))
	   (OLD-IVS (FLAVOR-ALL-INSTANCE-VARIABLES OLD-FL))
	   (OLD-SIZE (FLAVOR-INSTANCE-SIZE OLD-FL))
	   (NEW-IVS (FLAVOR-ALL-INSTANCE-VARIABLES NEW-FL))
	   (NEW-SIZE (FLAVOR-INSTANCE-SIZE NEW-FL)))
      (BLOCK INNER
	;; Optimize the case where the instance variables aren't changing.
	(WHEN (AND (= NEW-SIZE OLD-SIZE) (EQUAL NEW-IVS OLD-IVS))
	  ;; Disable interrupts so no one else can come in and transform the instance.
	  (SI:WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (100.)
	    (WHEN (EQ (%INSTANCE-FLAVOR INSTANCE) OLD-FL)
	      (%P-STORE-CDR-TYPE-AND-POINTER (FOLLOW-STRUCTURE-FORWARDING INSTANCE)
					     %HEADER-TYPE-INSTANCE DTP-HEADER-P
					     (PROGN #+3600 NEW-FL
						    #+IMACH (LOCF (%FLAVOR-HASH-MASK NEW-FL))))
	      (RETURN-FROM INNER))))
	;; The instance variables are changing, have to make a new instance
	(LET* ((STACK-INSTANCE (LDB-TEST %%REGION-STACK
					 (REGION-BITS (%REGION-NUMBER INSTANCE))))
	       (NEW-AREA (IF STACK-INSTANCE
			     WORKING-STORAGE-AREA
			     (%AREA-NUMBER INSTANCE)))
	       (NEW-INSTANCE (SI:%MAKE-STRUCTURE DTP-INSTANCE DTP-HEADER-P
						 %HEADER-TYPE-INSTANCE
						 (PROGN
						   #+3600 NEW-FL
						   #+IMACH (LOCF (%FLAVOR-HASH-MASK NEW-FL)))
						 NEW-AREA NEW-SIZE)))
	  ;; Default any instance variables that don't exist in the old instance.
	  ;; We can only use the same defaults that MAKE-INSTANCE would use.
	  (%BLOCK-COPY-ALLOW-NULL (FLAVOR-TEMPLATE-INSTANCE NEW-FL) NEW-INSTANCE NEW-SIZE)
	  (LOOP FOR (FORM SLOT) IN (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS NEW-FL) DO
	    (UNLESS (MEMBER (NTH (1- SLOT) NEW-IVS) OLD-IVS)
	      (%INSTANCE-SET (EVAL FORM) NEW-INSTANCE SLOT)))
	  ;; Now disable interrupts so no one else can come in and transform the instance
	  ;; and so no one sees it partly transformed.  Get OLD-IVS again so we don't lose
	  ;; any instance variable values if it has changed.
	  (SI:WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (200.)
	    (LET ((OLD-INSTANCE (FOLLOW-STRUCTURE-FORWARDING INSTANCE)))
	      (UNLESS (EQ OLD-FL (SETQ OLD-FL (%INSTANCE-FLAVOR OLD-INSTANCE)))
		(SETQ OLD-IVS (FLAVOR-ALL-INSTANCE-VARIABLES OLD-FL)
		      OLD-SIZE (FLAVOR-INSTANCE-SIZE OLD-FL)))
	      ;; Copy and reorder any instance variables present in both old and new
	      (LOOP FOR VAR IN OLD-IVS
		    FOR OLD-SLOT FROM 1
		    FOR NEW-SLOT = (POSITION VAR NEW-IVS) DO
		(WHEN NEW-SLOT
		  (SI:%P-COPY-Q
		    (%MAKE-POINTER-OFFSET DTP-LOCATIVE OLD-INSTANCE OLD-SLOT)
		    (%MAKE-POINTER-OFFSET DTP-LOCATIVE NEW-INSTANCE (1+ NEW-SLOT)))))
	      (COND ((OR ;; New instance is bigger, have to structure-forward
		         (> NEW-SIZE OLD-SIZE)
			 ;; Instance has already been forwarded once, cannot shorten in
			 ;; place because we might give up cells that are referenced by
			 ;; forwarding pointers in the original instance, leaving
			 ;; dangling references from the original instance past the end
			 ;; of the forwarded instance.  Instead, forward again.
			 (AND (> OLD-SIZE NEW-SIZE)
			      (NEQ OLD-INSTANCE INSTANCE)))
		     ;; Don't call the regular STRUCTURE-FORWARD function, because
		     ;; we need to scramble the dtp-element-forward pointers.
		     (%P-STORE-TAG-AND-POINTER OLD-INSTANCE DTP-HEADER-FORWARD NEW-INSTANCE)
		     (LOOP FOR VAR IN OLD-IVS
			   FOR OLD-SLOT FROM 1
			   FOR NEW-SLOT = (POSITION VAR NEW-IVS) DO
		       (%P-STORE-TAG-AND-POINTER
			 (%MAKE-POINTER-OFFSET DTP-LOCATIVE OLD-INSTANCE OLD-SLOT)
			 DTP-ELEMENT-FORWARD
			 (IF NEW-SLOT
			     (%MAKE-POINTER-OFFSET DTP-LOCATIVE NEW-INSTANCE (1+ NEW-SLOT))
			     ;; Instance variable has disappeared, we have to make a detached
			     ;; value cell for it in case anyone still has a locative to here.
			     ;; Can't just use the old cell in the old instance because the
			     ;; GC doesn't allow us to only store dtp-element-forward
			     ;; into some of the elements (where would the references to
			     ;; the other elements go when the new instance is evacuated
			     ;; and the indirection through the old instance is snapped out?)
			     (LET ((CELL (MAKE-LIST 1)))
			       (%P-STORE-CDR-TYPE-AND-POINTER CELL CDR-NIL DTP-NULL VAR)
			       CELL))))
		     ;; If the instance has been forwarded more than once, snap out
		     ;; the intermediate level of forwarding, to avoid map cache problems.
		     (UNLESS (EQ OLD-INSTANCE INSTANCE)
		       (%P-STORE-TAG-AND-POINTER INSTANCE DTP-HEADER-FORWARD NEW-INSTANCE)
		       (SI:UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
		       (LOOP FOR P = (%MAKE-POINTER-OFFSET DTP-LOCATIVE INSTANCE 1)
				   THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)
			     WITH REGION = (%REGION-NUMBER INSTANCE)
			     WITH LIMIT = (+ (REGION-ORIGIN REGION)
					     (REGION-FREE-POINTER REGION))
			     WHILE (%POINTER-LESSP P LIMIT)
			     WHILE (= (%P-DATA-TYPE P) DTP-ELEMENT-FORWARD)
			     DO (%P-STORE-TAG-AND-POINTER P DTP-ELEMENT-FORWARD
							  (FOLLOW-CELL-FORWARDING P NIL)))))
		    (T
		     ;; Can reuse old instance and reclaim storage of new instance
		     (%BLOCK-COPY-ALLOW-NULL NEW-INSTANCE OLD-INSTANCE NEW-SIZE)
		     (WHEN (> OLD-SIZE NEW-SIZE)	;Fill extra space
		       (%BLOCK-STORE-TAG-AND-POINTER
			 (%MAKE-POINTER-OFFSET DTP-LOCATIVE OLD-INSTANCE NEW-SIZE)
			 (- OLD-SIZE NEW-SIZE)
			 (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-I)
			 (PROGN
			   #+3600 (DPB %ARRAY-DISPATCH-WORD
				       (DEFSTORAGE-FIELD-BYTE ARRAY-DISPATCH-FIELD)
				       (DPB ART-Q (DEFSTORAGE-FIELD-BYTE ARRAY-TYPE-FIELD) 0))
			   #+IMACH (%LOGDPB ART-Q ARRAY-TYPE-FIELD 0))
			 0))
		     (LET ((REGION (%REGION-NUMBER NEW-INSTANCE)))	;Reclaim storage
		       (WHEN (= (+ (%POINTER NEW-INSTANCE) NEW-SIZE)
				(+ (SI:REGION-ORIGIN REGION) (SI:REGION-FREE-POINTER REGION)))
			 (SI:GC-RESET-FREE-POINTER REGION
						   (- (%POINTER NEW-INSTANCE)
						      (SI:REGION-ORIGIN REGION)))))))))))
      ;; INSTANCE has been transformed, now tell it what happened.
      ;;--- Can't use OPERATION-HANDLED-P here, think about what that means
      (WHEN (MEMBER 'TRANSFORM-INSTANCE (FLAVOR-ALL-GENERICS NEW-FL))
	;;--- What args would the method like to see?
	(FUNCALL (GENERIC TRANSFORM-INSTANCE) INSTANCE))
      ;; Return the transformed instance
      ;; Never return NEW-INSTANCE, we want to preserve EQ-ness of SELF
      INSTANCE)))

(DEFUN DESCRIBE-TRANSFORM-INSTANCE (OLD-FL NEW-FL)
  (LET* ((OLD-IVS (FLAVOR-ALL-INSTANCE-VARIABLES OLD-FL))
	 (OLD-SIZE (FLAVOR-INSTANCE-SIZE OLD-FL))
	 (NEW-IVS (FLAVOR-ALL-INSTANCE-VARIABLES NEW-FL))
	 (NEW-SIZE (FLAVOR-INSTANCE-SIZE NEW-FL))
	 (TEMPLATE (FLAVOR-TEMPLATE-INSTANCE NEW-FL))
	 (DELETED-VARIABLES (SET-DIFFERENCE OLD-IVS NEW-IVS))
	 (ADDED-VARIABLES (SET-DIFFERENCE NEW-IVS OLD-IVS)))
    (WHEN DELETED-VARIABLES
      (FORMAT T "~%  The instance variable~P ~{~S~^, ~} will be removed."
	      (LENGTH DELETED-VARIABLES) DELETED-VARIABLES))
    (LOOP FOR VAR IN ADDED-VARIABLES
	  AS SLOT = (1+ (POSITION VAR NEW-IVS))
	  DO (LOOP FOR (FORM FORM-SLOT) IN (FLAVOR-ALL-VARIABLE-DEFAULT-INIT-FORMS NEW-FL)
		   DO (WHEN (= FORM-SLOT SLOT)
			(FORMAT T "~%  The new instance variable ~S will be ~
					set to the value of ~S."
				VAR FORM)
			(RETURN))
		   FINALLY
		     (SETQ SLOT (%MAKE-POINTER-OFFSET DTP-LOCATIVE TEMPLATE SLOT))
		     (IF (LOCATION-BOUNDP SLOT)
			 (FORMAT T "~%  The new instance variable ~S will be set to ~S."
				 VAR (LOCATION-CONTENTS SLOT))
			 (FORMAT T "~%  The new instance variable ~S will be left unbound."
				 VAR))))
    (WHEN (> NEW-SIZE OLD-SIZE)
      (FORMAT T "
  The instance will be structure-forwarded, because its size will increase."))
    (FORMAT T "
  ~:[If any methods for the generic function ~S are defined for 
  this flavor, ~:*~S will be applied to the instance
  ~;The generic function ~S will be applied to the instance
  ~]to let it know that its instance variables have been shuffled around."
	    (MEMBER 'TRANSFORM-INSTANCE (FLAVOR-ALL-GENERICS NEW-FL))
	    'TRANSFORM-INSTANCE)))

(DEFUN PRINT-FLAVOR-TRANSFORMATION-WARNINGS ()
  (WHEN *TRANSFORM-FLAVOR-WARNINGS*
    (LET ((BATCHES NIL))	;((warning-string old-fl new-fl flavor-name flavor-name...)...)
      (LOOP FOR (OLD-FL NEW-FL) IN *TRANSFORM-FLAVOR-WARNINGS*
	    AS STRING = (WITH-OUTPUT-TO-STRING (*STANDARD-OUTPUT*)
			  (DESCRIBE-TRANSFORM-INSTANCE OLD-FL NEW-FL))
	    AS ELEM = (ASSOC STRING BATCHES :TEST #'EQUAL) DO
	(IF ELEM
	    (PUSH (FLAVOR-NAME NEW-FL) (CDDDR ELEM))
	    (PUSH (LIST STRING OLD-FL NEW-FL (FLAVOR-NAME NEW-FL)) BATCHES)))
      (WARN "~vQ" (NREVERSE BATCHES)
	    (LAMBDA (BATCHES)
	      (LOOP FOR ((STRING OLD-FL NEW-FL . FLAVOR-NAMES) . MORE) ON BATCHES DO
		(IGNORE STRING)
		(FILLING-OUTPUT ()
		  (IF (CDR FLAVOR-NAMES)
		      (FORMAT T "Flavors ~{~S~^, ~} have " FLAVOR-NAMES)
		      (FORMAT T "Flavor ~S has " (FIRST FLAVOR-NAMES)))
		  (FORMAT T "been changed in such a way that the stored representation of ~
			     an instance is different.  Existing instances will be updated ~
			     the next time they are used."))
		(DESCRIBE-TRANSFORM-INSTANCE OLD-FL NEW-FL)
		(WHEN MORE (TERPRI))))))))

;;; Change the flavor of an instance to another flavor, preferably one that has
;;; compatible instance variables.  This is fairly compatible with the one in the
;;; old flavor system, but doesn't take an ERROR-P argument since it always works.
;;; Also note that TRANSFORM-INSTANCE is generic, so the instance gets informed
;;; of what happens without the caller taking special action.
(DEFUN CHANGE-INSTANCE-FLAVOR (INSTANCE NEW-FLAVOR)
  (LET ((FL (FIND-FLAVOR NEW-FLAVOR)))
    (IF (EQ FL (%INSTANCE-FLAVOR INSTANCE))
	INSTANCE
	(TRANSFORM-INSTANCE INSTANCE FL))))

(SI:DEFINE-GC-OPTIMIZATION TRANSFORM-OBSOLETE-FLAVOR-INSTANCES SI:SYMBOLICS-SYSTEM-RELEASE
  (:DOCUMENTATION
    "Run FLAVOR:TRANSFORM-INSTANCE on all instances whose flavor definition has changed")
  (:BEFORE-FLIP (IGNORE)
    (SI:INHIBIT-GC-FLIPS			;interlock with GC
      (SI:GC-RECLAIM-OLDSPACE)			;needed if not called from full GC
      (SI:WITH-PROGRESS-REPORT ("finding and updating obsolete flavor instances")
	(TV:NOTING-PROGRESS ("Finding and updating obsolete flavor instances")
	  (LET ((TOTAL-WORDS 0)
		(SEEN-WORDS 0)
		(SEEN-INSTANCES 0)
		(TRANSFORMED-INSTANCES 0)
		(ERROR-INSTANCES 0))
	    (SI:MAP-OVER-REGIONS
	      #'SI:AREA-PREDICATE-AREAS-WITH-OBJECTS
	      #'SI:REGION-PREDICATE-STRUCTURE
	      #'(LAMBDA (AREA REGION)
		  (DECLARE (IGNORE AREA))
		  (INCF TOTAL-WORDS (SI:REGION-FREE-POINTER REGION))))
	    (SI:MAP-OVER-REGIONS
	      #'SI:AREA-PREDICATE-AREAS-WITH-OBJECTS
	      #'SI:REGION-PREDICATE-STRUCTURE
	      #'(LAMBDA (AREA REGION)
		  (DECLARE (IGNORE AREA))
		  (SI:MAP-OVER-OBJECTS-IN-REGION
		    REGION
		    #'(LAMBDA (ADDRESS HEADER LEADER SIZE)
			(DECLARE (IGNORE ADDRESS LEADER SIZE))
			(WHEN (AND (TYPEP HEADER 'INSTANCE) (SYS:FLAVOR-INSTANCE-P HEADER))
			  (INCF SEEN-INSTANCES)
			  (LET* ((OLD (SI:%INSTANCE-FLAVOR HEADER))
				 (NEW (FLAVOR:FIND-FLAVOR (FLAVOR:FLAVOR-NAME OLD) NIL)))
			    (UNLESS (EQ OLD NEW)
			      (COND ((EQ HEADER (FLAVOR-TEMPLATE-INSTANCE OLD)))
				    ((NOT (NULL NEW))
				     (FLAVOR:TRANSFORM-INSTANCE HEADER NEW)
				     (INCF TRANSFORMED-INSTANCES))
				    (T
				     (INCF ERROR-INSTANCES))))))))
		  (INCF SEEN-WORDS (SI:REGION-FREE-POINTER REGION))
		  (TV:NOTE-PROGRESS SEEN-WORDS TOTAL-WORDS)))
	    (SI:GC-OPTIMIZATION-REPORT "~&Transformed ~D obsolete instance~:P out of ~D."
				       TRANSFORMED-INSTANCES SEEN-INSTANCES)
	    (UNLESS (ZEROP ERROR-INSTANCES)
	      (SI:GC-OPTIMIZATION-REPORT "~%~D instance~:P of undefined flavors were found."
					 ERROR-INSTANCES))))))))
