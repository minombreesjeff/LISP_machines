;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SYSTEM-INTERNALS; Base: 10 -*-

;; Simple DDT.
;; You have to know what you're doing to use this.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
(DEFUN SDDT (&OPTIONAL (OBJECT NIL OBJECT-P))
  (FORMAT T "~%SDDT, † for help.  Caveat Emptor.")
  (IF (NOT OBJECT-P)
      (TERPRI)
    (SETQ OBJECT (%POINTER OBJECT))
    (SDDT-PRINT-ADDRESS OBJECT)
    (SDDT-PRINT-MEMORY-LOCATION OBJECT))
  (LOOP WITH ARGUMENT 
	WITH POINT = OBJECT
	WITH BASE = 8
	WITH IBASE = 8
	AS KEY = (SEND STANDARD-INPUT :TYI)
	DO (IF (DIGIT-CHAR-P KEY) ;Accept bogus base 10 format like the reader does.
	       (PROGN (SETQ ARGUMENT
			    (+ (- (CHAR-INT KEY) (CHAR-INT #\0))
			       (LSH (OR ARGUMENT 0) 3)))
		      (SEND STANDARD-OUTPUT :TYO KEY))
	     (CL:CASE KEY
	       ((#\End #\c-Z) (RETURN (VALUES)))
	       ((#\/ )
		(PRINC "// ")
		(WHEN ARGUMENT
		  (SETQ POINT ARGUMENT))
		(WHEN POINT
		  (SDDT-PRINT-MEMORY-LOCATION POINT)))
	       ((#\Tab)
		(WHEN POINT
		  (SETQ POINT (%P-POINTER (OR ARGUMENT POINT)))
		  (SDDT-PRINT-ADDRESS POINT)
		  (SDDT-PRINT-MEMORY-LOCATION POINT)))
	       ((#\c-Tab)
		(WHEN POINT
		  (CONDITION-CASE (HEADER LEADER)
		       (%FIND-STRUCTURE-EXTENT POINT)
		     (ERROR (FORMAT T "~&Error:  ~A" HEADER))
		     (:NO-ERROR
		       (WHEN HEADER
			 (SETQ POINT (%POINTER LEADER))
			 (SDDT-PRINT-ADDRESS POINT)
			 (SDDT-PRINT-MEMORY-LOCATION POINT))))))
	       ((#\<)
		(WHEN POINT
		  (CONDITION-CASE (ERROR)
		       (MULTIPLE-VALUE-BIND (HEADER LEADER)
			   (%FIND-STRUCTURE-EXTENT POINT)
			 (WHEN HEADER
			   (COND ((%POINTER-LESSP (REGION-ORIGIN (%REGION-NUMBER LEADER))
						  LEADER)
				  (MULTIPLE-VALUE (HEADER LEADER)
				    (%FIND-STRUCTURE-EXTENT (1- (%POINTER LEADER))))
				  (WHEN HEADER
				    (SETQ POINT (%POINTER LEADER))
				    (SDDT-PRINT-ADDRESS POINT)
				    (SDDT-PRINT-MEMORY-LOCATION POINT)))
				 (T (FORMAT T "~&Already at start of region.")))))
		     (ERROR (FORMAT T "~&Error:  ~A" ERROR)))))
	       ((#\>)
		(WHEN POINT
		  (CONDITION-CASE (ERROR)
		       (MULTIPLE-VALUE-BIND (HEADER LEADER SIZE)
			   (%FIND-STRUCTURE-EXTENT POINT)
			 (WHEN HEADER
			   (LET ((REGION (%REGION-NUMBER LEADER)))
			     (SETQ LEADER (%MAKE-POINTER-OFFSET DTP-LOCATIVE LEADER SIZE))
			     (COND ((< (%POINTER-DIFFERENCE LEADER (REGION-ORIGIN REGION))
				       (REGION-FREE-POINTER REGION))
				    (MULTIPLE-VALUE (HEADER LEADER)
				      (%FIND-STRUCTURE-EXTENT LEADER))
				    (WHEN HEADER
				      (SETQ POINT (%POINTER LEADER))
				      (SDDT-PRINT-ADDRESS POINT)
				      (SDDT-PRINT-MEMORY-LOCATION POINT)))
				   (T (FORMAT T "~&Already at end of region."))))))
		     (ERROR (FORMAT T "~&Error:  ~A" ERROR)))))
	       ((#\^ #\Backspace)
		(WHEN POINT
		  (DECF POINT (OR ARGUMENT 1))
		  (SDDT-PRINT-ADDRESS POINT)
		  (SDDT-PRINT-MEMORY-LOCATION POINT)))
	       ((#\Line)
		(WHEN POINT
		  (INCF POINT (OR ARGUMENT 1))
		  (SDDT-PRINT-ADDRESS POINT)
		  (SDDT-PRINT-MEMORY-LOCATION POINT)))
	       ((#\?)
		(WHEN POINT
		  (DESCRIBE-ADDRESS POINT)))
	       ((#\=)
		(CONDITION-CASE (ERROR)
		     (SETQ POINT (%POINTER (EVAL (ACCEPT 'DW::FORM :PROMPT "Form to eval"
								   :PROMPTS-IN-LINE T))))
		   (ERROR (FORMAT T "~&Error:  ~A" ERROR))
		   (ABORT (TERPRI))
		   (:NO-ERROR
		     (SDDT-PRINT-ADDRESS POINT)
		     (SDDT-PRINT-MEMORY-LOCATION POINT))))
	       ((#\S #\s)
		(WHEN POINT
		  (CONDITION-CASE (ERROR)
		       (LET ((TYPE (%P-DATA-TYPE POINT)))
			 (BLOCK PRINT
			   (CATCH-ERROR-RESTART ((ERROR ABORT) "Abort printing")
			     (RETURN-FROM PRINT
			       (IF (OR (= TYPE DTP-HEADER-P) (= TYPE DTP-HEADER-I))
				   (FORMAT T " Header for ~S" (%FIND-STRUCTURE-HEADER POINT))
				   (FORMAT T " ~S "
					   (LOCATION-CONTENTS
					     (%MAKE-POINTER DTP-LOCATIVE POINT))))))
			   (SDDT-PRINT-ADDRESS POINT)
			   (SDDT-PRINT-MEMORY-LOCATION POINT)))
		     (ERROR (FORMAT T "~&Error:  ~A" ERROR)))))
	       ((#\W #\w)
		(WHEN POINT
		  (CONDITION-CASE (ERROR)
		       (LET ((HEADER (%FIND-STRUCTURE-EXTENT POINT)))
			 (WHEN HEADER
			   (BLOCK PRINT
			     (CATCH-ERROR-RESTART ((ERROR ABORT) "Abort printing")
			       (RETURN-FROM PRINT
				 (FORMAT T " ~S " HEADER)))
			     (SDDT-PRINT-ADDRESS POINT)
			     (SDDT-PRINT-MEMORY-LOCATION POINT))))
		     (ERROR (FORMAT T "~&Error:  ~A" ERROR)))))
	       ((#\Return) (SEND STANDARD-OUTPUT :TYO #\Return))	;Hah, fooled you!
	       ((#\Help)
		(PRINC "
//		Examine Address
Tab		Follow Pointer
c-Tab		Find Structure Header
^ or Backspace	Previous Location
Linefeed	Next Location
<		Previous Object
>		Next Object
?		Describe Address
=		Accept Object as Point
S		Print Cell Contents
W		Print Containing Object
End or c-Z	Exit
"))
	       (OTHERWISE (PRINC " ??? ")))
	     (SETQ ARGUMENT NIL))))

(DEFUN SDDT-PRINT-ADDRESS (LOC)
  (FORMAT T "~%~\SI:ADDRESS\// " (%POINTER LOC)))

(DEFUN SDDT-PRINT-MEMORY-LOCATION (LOC)
  (LET ((REGION (%REGION-NUMBER LOC)))
    (COND ((AND (NULL REGION)
		(NOT (= (%LOGLDB %%VMA-EQUALS-PMA (%POINTER LOC)) %VMA-EQUALS-PMA)))
	   (PRINC " not in any region"))
	  (T (LET* ((TYPE (%P-DATA-TYPE LOC))
		    (NAME (DATA-TYPE-NAME TYPE)))
	       (FORMAT T " ~A ~A ~\SI:ADDRESS\ "
		       (OR (NTH (%P-CDR-CODE LOC)
				(SELECTOR TYPE =
				  (DTP-HEADER-I *HEADER-I-TYPES*)
				  (DTP-HEADER-P *HEADER-P-TYPES*)
				  (OTHERWISE *CDR-CODES*)))
			   (%P-CDR-CODE LOC))
		       NAME
		       (CL:CASE NAME
			 (#+3600 DTP-FIX #+IMACH DTP-FIXNUM
			  (%P-LDB %%Q-FIXNUM LOC))
			 (#+3600 DTP-FLOAT #+IMACH DTP-SINGLE-FLOAT
			  (%FLONUM (%P-LDB %%Q-FIXNUM LOC)))
			 #+IMACH (DTP-SMALL-RATIO (%SMALL-RATIO (%P-LDB %%Q-FIXNUM LOC)))
			 (OTHERWISE (%P-POINTER LOC)))))))))

(DEFUN DESCRIBE-ADDRESS (LOC)
  (LET* ((REGION (%REGION-NUMBER LOC))
	 (AREA (AND REGION (REGION-AREA REGION))))
    #+3600
    (IF (AND (NULL AREA)
	     (= (%LOGLDB %%VMA-EQUALS-AMEM (%POINTER LOC)) %VMA-EQUALS-AMEM))
	(FORMAT T "~&~\SI:ADDRESS\// A-memory location" LOC)
	(FORMAT T "~&~\SI:ADDRESS\// Area ~S, Region ~O" LOC (AND AREA (AREA-NAME AREA)) REGION))
    #+IMach
    (FORMAT T "~&~\SI:ADDRESS\// Area ~S, Region ~O" LOC (AND AREA (AREA-NAME AREA)) REGION)
    (WHEN REGION
      (DESCRIBE-REGION REGION))
    (WHEN AREA
      (CONDITION-CASE (ERROR)
	   (DESCRIBE (%MAKE-POINTER DTP-LOCATIVE LOC))
	 (ERROR (FORMAT T "~&Error: ~A" ERROR))))))


;; Random hacks for debugging GC crashes.

(DEFUN PRINT-OBJECTS-IN-REGION (REGION-NUMBER &OPTIONAL AFTER-ADDRESS)
  (LET ((AREA-NUMBER (REGION-AREA REGION-NUMBER)))
    (MAP-OVER-OBJECTS-IN-REGION REGION-NUMBER
      #'(LAMBDA (ADDRESS HEADER LEADER SIZE)
	  LEADER
	  (WHEN (OR (NULL AFTER-ADDRESS)
		    ( ADDRESS AFTER-ADDRESS))
	    ;; Kludge generic functions.
	    (WHEN (AND (LISTP HEADER)
		       (EQL SIZE (DEFSTORAGE-SIZE GENERIC-FUNCTION))
		       (EQL AREA-NUMBER FLAVOR::*FLAVOR-STATIC-AREA*))
	      (SETQ HEADER (%MAKE-POINTER DTP-GENERIC-FUNCTION HEADER)))
	    (FORMAT T "~%~\SI:ADDRESS\:  ~S" ADDRESS HEADER))))))

(DEFUN PRINT-OBJECTS-AROUND (OBJECT &OPTIONAL (N 5))
  (FLET ((FIND-STRUCTURE-EXTENT (POINTER)
	   (MULTIPLE-VALUE-BIND (HEADER LEADER SIZE)
	       (%FIND-STRUCTURE-EXTENT POINTER)
	     ;; Kludge generic functions.
	     (WHEN (AND (LISTP HEADER)
			(EQL SIZE (DEFSTORAGE-SIZE GENERIC-FUNCTION))
			(EQL (%AREA-NUMBER HEADER) FLAVOR::*FLAVOR-STATIC-AREA*))
	       (SETQ HEADER (%MAKE-POINTER DTP-GENERIC-FUNCTION HEADER)))
	     (VALUES HEADER LEADER SIZE))))
    (MULTIPLE-VALUE-BIND (HEADER LEADER SIZE)
	(FIND-STRUCTURE-EXTENT OBJECT)
      (LET* ((REGION (%REGION-NUMBER LEADER))
	     (REGION-ORIGIN (REGION-ORIGIN REGION))
	     (REGION-LIMIT (+ REGION-ORIGIN (REGION-FREE-POINTER REGION))))
	(LABELS ((RECURSE-BACK (HEADER LEADER N)
		   (WHEN (AND (PLUSP N) (%POINTER-LESSP REGION-ORIGIN LEADER))
		     (%MULTIPLE-VALUE-CALL-N RECURSE-BACK
		       (FIND-STRUCTURE-EXTENT (%MAKE-POINTER-OFFSET DTP-LOCATIVE LEADER -1)) 2
		       (1- N) 1))
		   (FORMAT T "~%~\SI:ADDRESS\:  ~S" (%POINTER LEADER) HEADER)))
	  (FORMAT T "~&~S, region ~O" (AREA-NAME (REGION-AREA REGION)) REGION)
	  (RECURSE-BACK HEADER LEADER N)
	  (LOOP REPEAT N 
		WHILE (> (%POINTER-DIFFERENCE REGION-LIMIT LEADER) SIZE)
		DO (MULTIPLE-VALUE (HEADER LEADER SIZE)
		     (FIND-STRUCTURE-EXTENT (%MAKE-POINTER-OFFSET DTP-LOCATIVE LEADER SIZE)))
		   (FORMAT T "~%~\SI:ADDRESS\:  ~S" (%POINTER LEADER) HEADER)))))))

(DEFUN REGION-PREDICATE-NOT-OLDSPACE (REGION)
  ( (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION)) %REGION-SPACE-OLD))

(DEFUN REGION-PREDICATE-NOT-OLDSPACE-OR-STACK (REGION)
  (LET ((TYPE (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))))
    (AND ( TYPE %REGION-SPACE-OLD)
	 (NOT (LDB-TEST %%SPACE-TYPE-STACK TYPE)))))

(DEFUN FIND-GC-FORWARDS (&OPTIONAL AREA)
  (FLET ((FIND-GC-FORWARDS-AREA-REGION (AREA REGION)
	   (LET* ((ORIGIN (REGION-ORIGIN REGION))
		  (LIMIT (+ ORIGIN (REGION-FREE-POINTER REGION))))
	     (SCANNING-THROUGH-MEMORY FIND-GC-FORWARDS (ORIGIN LIMIT)
	       (LOOP WITH GCFWDP
		     FOR ADDRESS FROM ORIGIN BELOW LIMIT
		     DO (CHECK-MEMORY-SCAN FIND-GC-FORWARDS ADDRESS)
			(IF (= (%P-DATA-TYPE ADDRESS) DTP-GC-FORWARD)
			    (UNLESS GCFWDP
			      (FORMAT T "~%Area ~S region ~O, GC-FORWARDS from ~\SI:ADDRESS\"
				      (AREA-NAME AREA) REGION ADDRESS)
			      (SETQ GCFWDP T))
			    (WHEN GCFWDP
			      (FORMAT T " to ~\SI:ADDRESS\" ADDRESS)
			      (SETQ GCFWDP NIL)))
		     FINALLY (WHEN GCFWDP
			       (FORMAT T " to ~\SI:ADDRESS\" LIMIT)))))))
    (WHEN (SYMBOLP AREA) (SETQ AREA (SYMEVAL AREA)))
    (IF AREA
	(DO-AREA-REGIONS (REGION AREA)
	  (WHEN (REGION-PREDICATE-NOT-OLDSPACE REGION)
	    (FIND-GC-FORWARDS-AREA-REGION AREA REGION)))
	(MAP-OVER-REGIONS #'AREA-PREDICATE-AREAS-WITH-OBJECTS
			  #'REGION-PREDICATE-NOT-OLDSPACE
			  #'FIND-GC-FORWARDS-AREA-REGION))))

(DEFUN FIND-BAD-POINTERS (&OPTIONAL AREA)
  (FLET ((FIND-BAD-POINTERS-AREA-REGION (AREA REGION)
	   (LET* ((ORIGIN (REGION-ORIGIN REGION))
		  (LIMIT (+ ORIGIN (REGION-FREE-POINTER REGION)))
		  #+3600 (ADDRESS-SPACE-MAP *ADDRESS-SPACE-MAP*))
	     #+3600 (DECLARE (ARRAY-REGISTER ADDRESS-SPACE-MAP))
	     (SCANNING-THROUGH-MEMORY FIND-BAD-POINTERS (ORIGIN LIMIT)
	       (LOOP WITH BAD-POINTER-P
		     FOR ADDRESS FROM ORIGIN BELOW LIMIT
		     DO (CHECK-MEMORY-SCAN FIND-BAD-POINTERS ADDRESS)
			(IF (AND (%POINTER-TYPE-P (%P-DATA-TYPE ADDRESS))
				 (NOT #+3600  (REGION-VALID-P
						(AREF ADDRESS-SPACE-MAP
						      (%P-LDB %%VMA-QUANTUM-NUM ADDRESS)))
				      #+IMach (%REGION-NUMBER ADDRESS))
				 (NOT (= (%P-LDB %%VMA-EQUALS-PMA ADDRESS) %VMA-EQUALS-PMA)))
			    (UNLESS BAD-POINTER-P
			      (FORMAT T "~%Area ~S region ~O, BAD-POINTERS from ~\SI:ADDRESS\"
				      (AREA-NAME AREA) REGION ADDRESS)
			      (SETQ BAD-POINTER-P T))
			    (WHEN BAD-POINTER-P
			      (FORMAT T " to ~\SI:ADDRESS\" ADDRESS)
			      (SETQ BAD-POINTER-P NIL)))
		     FINALLY (WHEN BAD-POINTER-P
			       (FORMAT T " to ~\SI:ADDRESS\" LIMIT)))))))
    (WHEN (SYMBOLP AREA) (SETQ AREA (SYMEVAL AREA)))
    (IF AREA
	(DO-AREA-REGIONS (REGION AREA)
	  (WHEN (REGION-PREDICATE-NOT-OLDSPACE-OR-STACK REGION)
	    (FIND-BAD-POINTERS-AREA-REGION AREA REGION)))
	(MAP-OVER-REGIONS #'AREA-PREDICATE-AREAS-WITH-OBJECTS
			  #'REGION-PREDICATE-NOT-OLDSPACE-OR-STACK
			  #'FIND-BAD-POINTERS-AREA-REGION))))

(DEFUN PRINT-MINIMAL-REGION-INFO (REGION &OPTIONAL (STREAM STANDARD-OUTPUT))
  (LET ((BITS (REGION-BITS REGION)))
    (FORMAT STREAM "~\SI:REGION-SPACE-TYPE\ ~\SI:REGION-REPRESENTATION-TYPE\"
	    (LDB %%REGION-SPACE-TYPE BITS)
	    (LDB %%REGION-REPRESENTATION-TYPE BITS))))

(DEFUN FIND-POINTERS-FROM-REGION-TO-AREA (FROM-REGION TO-AREA &OPTIONAL DDT-MODE)
  (LET* ((FROM-ORIGIN (REGION-ORIGIN FROM-REGION))
	 (FROM-FREE-POINTER (REGION-FREE-POINTER FROM-REGION))
	 (FROM-LIMIT (+ FROM-ORIGIN FROM-FREE-POINTER))
	 (REGION NIL)
	 #+3600 (ASM *ADDRESS-SPACE-MAP*)
	 (REGION-AREA *REGION-AREA*))
    (DECLARE (ARRAY-REGISTER #+3600 ASM REGION-AREA))
    (SCANNING-THROUGH-MEMORY FRED (FROM-ORIGIN FROM-LIMIT)
      (LOOP FOR ADDRESS FROM FROM-ORIGIN BELOW FROM-LIMIT DO
	(CHECK-MEMORY-SCAN FRED ADDRESS)
	(WHEN (AND (%POINTER-TYPE-P (%P-DATA-TYPE ADDRESS))
		   #+3600  (REGION-VALID-P (SETQ REGION (AREF ASM (%P-LDB %%VMA-QUANTUM-NUM
									  ADDRESS))))
		   #+IMach (%REGION-NUMBER ADDRESS)
		   (= (AREF REGION-AREA REGION) TO-AREA))
	  (IF (NOT DDT-MODE)
	      (LET ((PRINLEVEL 3) (PRINLENGTH 4))
		(FORMAT T "~%~S  ~S (region ~O, ~VQ)"
			(%FIND-STRUCTURE-HEADER ADDRESS)
			(%FIND-STRUCTURE-HEADER (%P-POINTER ADDRESS))
			REGION REGION #'PRINT-MINIMAL-REGION-INFO))
	    (SDDT-PRINT-ADDRESS ADDRESS)
	    (SDDT-PRINT-MEMORY-LOCATION ADDRESS)
	    (FORMAT T " (region ~O, ~VQ)"
		    REGION REGION #'PRINT-MINIMAL-REGION-INFO)))))))

(DEFUN FIND-POINTERS-FROM-AREA-TO-AREA (FROM-AREA TO-AREA &OPTIONAL DDT-MODE)
  (DO-AREA-REGIONS (REGION FROM-AREA)
    (FORMAT T "~% *** From region ~O (~VQ):" REGION REGION #'PRINT-MINIMAL-REGION-INFO)
    (FIND-POINTERS-FROM-REGION-TO-AREA REGION TO-AREA DDT-MODE)))

(DEFUN FIND-DYNAMIC-POINTERS-FROM-REGION (FROM-REGION &OPTIONAL DDT-MODE)
  (LET* ((FROM-ORIGIN (REGION-ORIGIN FROM-REGION))
	 (FROM-FREE-POINTER (REGION-FREE-POINTER FROM-REGION))
	 (FROM-LIMIT (+ FROM-ORIGIN FROM-FREE-POINTER))
	 (REGION NIL)
	 #+3600 (ASM *ADDRESS-SPACE-MAP*)
	 )
    (DECLARE (ARRAY-REGISTER #+3600 ASM))
    (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS LEVEL-TYPE)
      (SCANNING-THROUGH-MEMORY FRED (FROM-ORIGIN FROM-LIMIT)
	(LOOP FOR ADDRESS FROM FROM-ORIGIN BELOW FROM-LIMIT DO
	  (CHECK-MEMORY-SCAN FRED ADDRESS)
	  (WHEN (AND (%POINTER-TYPE-P (%P-DATA-TYPE ADDRESS))
		     #+3600  (REGION-VALID-P (SETQ REGION (AREF ASM (%P-LDB %%VMA-QUANTUM-NUM
									    ADDRESS))))
		     #+IMACH (SETQ REGION (%REGION-NUMBER ADDRESS))
		     (LET* ((BITS (REGION-BITS REGION))
			    (TYPE (LDB %%REGION-SPACE-TYPE BITS)))
		       (AND (OR (= TYPE %REGION-SPACE-NEW)
				(= TYPE %REGION-SPACE-COPY)
				(= TYPE %REGION-SPACE-OLD))
			    ( (LEVEL-TYPE (LDB %%REGION-LEVEL BITS))
			       %LEVEL-TYPE-DYNAMIC))))
	    (IF (NOT DDT-MODE)
		(LET ((PRINLEVEL 3) (PRINLENGTH 4))
		  (FORMAT T "~%~S  ~S"
			  (%FIND-STRUCTURE-HEADER ADDRESS)
			  (%FIND-STRUCTURE-HEADER (%P-POINTER ADDRESS))))
		(SDDT-PRINT-ADDRESS ADDRESS)
		(SDDT-PRINT-MEMORY-LOCATION ADDRESS)
		(FORMAT T " (REGION ~O, ~VQ)"
			REGION REGION #'PRINT-MINIMAL-REGION-INFO))))))))

(DEFUN FIND-DYNAMIC-POINTERS-FROM-AREA (FROM-AREA &OPTIONAL DDT-MODE)
  (DO-AREA-REGIONS (REGION FROM-AREA)
    (WHEN (< (LEVEL-TYPE (LDB %%REGION-LEVEL (REGION-BITS REGION))) %LEVEL-TYPE-DYNAMIC)
      (FORMAT T "~% *** From region ~O (~VQ):" REGION REGION #'PRINT-MINIMAL-REGION-INFO)
      (FIND-DYNAMIC-POINTERS-FROM-REGION REGION DDT-MODE))))

(DEFUN FIND-REFERENCES-IN-REGION (LOCATION REGION)
  (LET* ((ORIGIN (REGION-ORIGIN REGION))
	 (LIMIT (+ ORIGIN (REGION-FREE-POINTER REGION))))
    (SCANNING-THROUGH-MEMORY FIND-REFERENCES-IN-REGION (ORIGIN LIMIT)
      (LOOP FOR ADDRESS FROM ORIGIN BELOW LIMIT DO
	(WHEN (= (LDB (BYTE 12 0) ADDRESS) 0)
	  (CHECK-MEMORY-SCAN FIND-REFERENCES-IN-REGION ADDRESS))
	(WHEN (AND (EQ (%P-POINTER ADDRESS) LOCATION)
		   (%POINTER-TYPE-P (%P-DATA-TYPE ADDRESS)))
	  (FORMAT T "~&Found reference to ~\SI:ADDRESS\ at ~\SI:ADDRESS\ in region ~O of area ~O"
		  LOCATION ADDRESS REGION (REGION-AREA REGION)))))))

(DEFUN FIND-REFERENCES (POINTER &OPTIONAL AREA)
  (IF (NOT (NULL AREA))
      (MAP-OVER-REGIONS-OF-AREA AREA #'REGION-PREDICATE-NOT-OLDSPACE-OR-STACK
	(LAMBDA (REGION) (FIND-REFERENCES-IN-REGION POINTER REGION)))
    (MAP-OVER-REGIONS #'AREA-PREDICATE-AREAS-WITH-OBJECTS #'REGION-PREDICATE-NOT-OLDSPACE
      (LAMBDA (IGNORE REGION)
	(FIND-REFERENCES-IN-REGION POINTER REGION)))))
