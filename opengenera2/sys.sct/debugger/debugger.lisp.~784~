;;; -*- Mode: LISP; Package: Debugger; Base: 8; Lowercase: Yes -*-

;;; Debugger main loop and commands
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Actual debugger interface

(defvar D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*writing-cold-load-error* 0nil
  "Bound when writing an error in the cold-load-stream to prevent recursive errors")

(defvar 1*warm-booting-from-core-dump* 0nil
  "Set before warm booting from cold-load error written to a file to prevent recursive warm starting")

(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; It is OK for a platform that does not have a cold load (ie Brick) to write stuff to the
;;; cold-load since it is a null stream on these platforms.  The problem is, no one will ever
;;; see it.
0(defun use-cold-load-stream (string)
  (unless (eq terminal-io tv:cold-load-stream)
    (setq terminal-io tv:cold-load-stream)
    (setq inhibit-scheduling-flag t)		;only one process at a time in cold load
    (ignore-errors
      (when (and (null saved-screen-process)
		 (variable-boundp tv:main-screen)
		 (not (null tv:main-screen)))
	(unless (or (typep tv:main-screen 'tv:basic-remote-screen)
		    (not (process:lock-idle-p (tv:screen-lock tv:main-screen))))
	  (multiple-value-bind (width height) (send tv:main-screen :inside-size)
	    (let ((type (tv:sheet-array-type tv:main-screen)))
	      (when (or (null cold-load-stream-saved-screen)
			(multiple-value-bind (cold-width cold-height)
			    (decode-raster-array cold-load-stream-saved-screen)
			  (or ( width cold-width)
			      ( height cold-height)
			      (neq type (array-type cold-load-stream-saved-screen)))))
		(when cold-load-stream-saved-screen
		  (tv:deallocate-temporary-sheet-bit-raster cold-load-stream-saved-screen)
		  (setf cold-load-stream-saved-screen nil))
		(setq cold-load-stream-saved-screen
		      (tv:make-temporary-sheet-bit-raster tv:main-screen width height))))
	    (let ((lock (tv:sheet-lock tv:main-screen))
		  (inferior-lock-count (tv:sheet-inferior-lock-count tv:main-screen)))
	      (setf (tv:sheet-lock tv:main-screen) current-process)
	      (setf (tv:sheet-inferior-lock-count tv:main-screen) 0)
	      (tv:sheet-force-access (tv:main-screen)
		(send tv:main-screen :bitblt-from-sheet tv:alu-seta
		      width height 0 0 cold-load-stream-saved-screen 0 0))
	      (setf (tv:sheet-lock tv:main-screen) lock)
	      (setf (tv:sheet-inferior-lock-count tv:main-screen) inferior-lock-count))))
	;; We've successfully saved the screen, make it be restored later.
	(setq saved-screen-process (or current-process t)
	      saved-screen-level *debugger-level*)))
    (send terminal-io :select)
    (send terminal-io :home-cursor))
  (format terminal-io "~&--> ~A, using the cold load stream <--~2%" string))

(defun recover-from-cold-load-stream (&optional (wholine-too t))
  (setq tv:cold-load-stream-selected nil)
  (when saved-screen-process
    (send terminal-io :deselect)
    (send terminal-io :finish)
    (without-interrupts
      (setq saved-screen-process nil)
      (unless (or (typep tv:main-screen 'tv:basic-remote-screen)
		  (not (process:lock-idle-p (tv:screen-lock tv:main-screen))))
	(let ((lock (tv:sheet-lock tv:main-screen))
	      (inferior-lock-count (tv:sheet-inferior-lock-count tv:main-screen)))
	  (setf (tv:sheet-lock tv:main-screen) current-process)
	  (setf (tv:sheet-inferior-lock-count tv:main-screen) 0)
	  (multiple-value-bind (width height) (send tv:main-screen :inside-size)
	    (tv:sheet-force-access (tv:main-screen)
	      (send tv:main-screen :bitblt tv:alu-seta
		    width height cold-load-stream-saved-screen 0 0 0 0)))
	  (tv:deallocate-temporary-sheet-bit-raster cold-load-stream-saved-screen)
	  (setf cold-load-stream-saved-screen nil)
	  (setf (tv:sheet-lock tv:main-screen) lock)
	  (setf (tv:sheet-inferior-lock-count tv:main-screen) inferior-lock-count))
	(when wholine-too
	  (tv:who-line-clobbered))))))

(defun 1cleanup-after-core-dump 0()
  (when *warm-booting-from-core-dump*
    (tv:notify nil
	       "Warm Booted from Cold-Load Stream:  ~:[~A~;Error description in ~A~]"
	       2;; We should have the pathname stored in *warm-booting-from-core-dump*
0	       (cl:pathnamep *warm-booting-from-core-dump*)
	       *warm-booting-from-core-dump*)
    (setq *warm-booting-from-core-dump* nil)))

(add-initialization "Core-Dump and Reboot Debugger Cleanup"
		    '(cleanup-after-core-dump)
		    nil 'si:warm-initialization-list)


;;; Menu-driven proceed handlers

(defconst other-proceed-options
	  '((#\Suspend "Enter the debugger"
	     :value :enter-debugger
	     :documentation "Enter the debugger")
	    (#\c-M "Send a bug report"
	     :value :bug-report
	     :documentation "Send a bug report")))

(defvar debugger-using-menus nil)

;; For visual distinctiveness
(defvar *proceed-menu-margin-choices*
	`((dw::margin-drop-shadow-borders :non-shadow-thickness 5)
	  (dw::margin-label :box :inside :margin :top)
	  (dw::margin-white-borders :thickness 8)
	  (dw::margin-scroll-bar :visibility :if-needed)))

(defvar *menu-proceed-style* :expert)

(defun proceed-via-menu ()
  (let* ((my-window (symeval-in-error-environment 'terminal-io))
	 (my-activity (and (instancep my-window)
			   (send-if-handles my-window :alias-for-selected-windows)))
	 (my-screen (or (and (instancep my-window)
			     (send-if-handles my-window :screen))
			tv:main-screen))
	 (help-window nil)
	 (other-options-type `((alist-member :alist ,other-proceed-options)))
	 ;;--- Kludge, should be a way to pass this in
	 (dw::*menu-choose-margin-choices* *proceed-menu-margin-choices*)
	 (dw::*default-end-of-page-mode* :scroll) ;In wrap mode, etc. this looks bizarre!
	 line-ypos)
    ;; Don't expose the Debugger menu over somebody else's window if the
    ;; error occurred in an exposed, unselected window.  So wait for the
    ;; activity that got the error to be the selected activity.
    ;;--- Also, :NOTICE :ERROR won't correctly notify you in this case.
    (flet ((wait-until-my-activity-selected ()
	     (when my-activity
	       (process-wait "Debugger selected"
		 #'(lambda ()
		     (let ((selected-window (tv:sheet-selected-window my-screen)))
		       (and selected-window
			    (eq (send selected-window :alias-for-selected-windows)
				my-activity))))))))
      (wait-until-my-activity-selected)
      (using-resource (menu dw::dynamic-menu my-screen :temporary-p t)
	(send menu :set-alias-for-selected-windows my-activity)
	(setq line-ypos
	      (dw::menu-choose-call-drawer
		menu
		(lambda (menu &key max-width max-height)
		  (ignore max-width max-height)
		  (cl:apply #'draw-proceed-via-menu-items menu other-options-type
			    (options-for-proceed-via-menu-style
			      *menu-proceed-style*)))))
	(loop doing
	  (let ((proceed-option
		  (zl:with-notification-mode (:pop-up menu)
		    (dw::position-window-near-carefully menu '(:mouse))
		    (tv:window-call (menu :deactivate)
		      ;; Put mouse at the left-hand end of the Resume proceed option
		      (send menu :set-mouse-position
				 (round (* dw::*default-menu-choose-x-offset*
					   (send menu :char-width)))
				 (+ line-ypos (send menu :line-height))
				 nil)
		      (unwind-protect
			  (dw:with-presentation-input-context
			     (`((or proceed-option ,other-options-type)) :stream menu)
			     (blip)
			       (loop named got-option
				     doing
				 (let ((char (read-character menu
							     :fresh-line nil
							     :notification nil
							     :refresh nil :suspend nil
							     :abort nil :status :exposed
							     :presentation-context t)))
				   (when (eql char :status)
				     (return-from got-option char))
				   (selector char char-equal
				     (#\Suspend (return :enter-debugger))
				     (#\Control-M (return :bug-report))
				     (#\Help (setq help-window (dw::display-own-window-help
								 help-window menu "Debugger"
								 #'debugger-menu-help nil)))
				     (otherwise
				       (when (char-bit char :super)
					 (let ((n (- (char-code char) (char-code #\A))))
					   (unless (minusp n)
					     (let ((entry (nth n *proceed-dispatch-table*)))
					       (when entry
						 (return (cdr entry)))))))
				       (dolist (entry *proceed-dispatch-table*)
					 (when (mem #'char-equal char (car entry))
					   (return-from got-option (cdr entry))))
				       (beep)))))
			     (proceed-option (car (dw:presentation-blip-object blip)))
			     (otherwise (dw:presentation-blip-object blip)))
			(dw::deallocate-help-window help-window))))))
	    (selectq proceed-option
	      ;; The menu is deexposed, probably the user is selecting another window
	      (:status
	       ;; After the menu is deexposed and before the other window gets selected,
	       ;; the window under the menu gets selected temporarily.  Wait for the
	       ;; selection of the other window to get started so we don't reexpose
	       ;; the menu prematurely.  This is a kludge, but we can't lock the nonexistent
	       ;; lock of the nonexistent activity system.
	       (process-wait-with-timeout "Debugger deselected" 60. 
		 #'(lambda ()
		     (let ((selected-window (tv:sheet-selected-window my-screen)))
		       (and selected-window
			    (neq (send selected-window :alias-for-selected-windows)
				 my-activity))))))
	      ;; Return back to the debugger command loop
	      (:enter-debugger (return :enter-debugger))
	      ;; Send a bug report and loop back to menu
	      (:bug-report (com-mail-bug-report))
	      ;; Execute a proceed command, which may throw out of here
	      (otherwise
	       (let ((value (let ((standard-output my-window)
				  ;; Silent unless there is a reasonable place to print
				  (silent (not (and (typep my-window 'tv:sheet)
						    (tv:sheet-exposed-p my-window)
						    (send my-window :interactive)))))
			      (unless silent
				(cl:fresh-line standard-output))
			      (execute-proceed-command proceed-option silent))))
		 ;; If we executed a special command or everybody declined to proceed,
		 ;; we need to pop up the proceed menu again
		 (when value (return value)))))
	    ;; Come here when menu gets deexposed because another window got exposed,
	    ;; or because the user sent a bug report.  Wait for the same sibling to get
	    ;; selected again, then loop back, exposing and choosing again.  This is
	    ;; preferable to making the menu an inferior of that window, because it
	    ;; doesn't get messed up by things like scrolling it.
	    (wait-until-my-activity-selected)))))))

(defun debugger-menu-help (stream)
  (format stream "The program has encountered an exceptional condition.
Select one of the proceed options listed by clicking on it with the mouse
or by pressing the key mentioned in parentheses next to the option.~%")
  (when (cl:find #\Resume *proceed-dispatch-table* :key #'caar)
    (format stream "Press the Resume key to select the simplest method of recovering.~%"))
  (when (cl:find #\Abort *proceed-dispatch-table* :key #'caar)
    (format stream "Press the Abort key to abort the failing program action.~%"))
  (format stream "Press Suspend to enter the Debugger.
Press control-M to send a bug report."))

(defun banner-message-default-for-draw-proceed-via-menu (&optional (punctuation "."))
  (let ((error (if (variable-boundp *error*) *error*)))
    (let ((classification (if error (error-classification error))))
      (format nil "~A~@[ ~A~] error occurred~A"
	      (scl:string-a-or-an (or classification "error") nil :capitalize)
	      classification
	      punctuation))))

(defmacro heading-off-dw-conditional-newline-barfage ((stream-var) &body forms)
  (cl:check-type stream-var symbol "a stream variable")
  ;; Apologies in advance about all the consing... -kmp 18-Dec-90
  `(cl:write-string (with-output-to-string (,stream-var) ,@forms) ,stream-var))

(defun draw-proceed-via-menu-items
       (menu other-options-type
	&key (banner-style '(nil :bold nil))		; Style for banner message
	     (banner-message
	       (banner-message-default-for-draw-proceed-via-menu ":"))
	     						; Banner message (nil, fn, or string)
	     (error-indent 8)				; Indentation of error message 
	     (error-style '(nil nil nil))		; Style of error message
	     (error-y-offset-1 nil)			; Y offset before message
	     (error-y-offset-2 nil)			; Y offset after message
	     (inter-column-spacing 16)			; Spacing between key and action
	     (full-key-name t)				; `super-A' vs `s-A'
	     (suppress '())				; :RESTART, :PROCEED, :SPECIAL-COMMAND
	     (show-headers nil)				; Show headers on each column?
	     (show-keys :before)			; :BEFORE, :AFTER, or NIL
	     (key-style '(nil nil :smaller))		; Style to show keys in
	     (key-alignment :right)			; Justification style for keys
	     (key-preference :prefer-special-only)	; Which keys to show:
	     (prompt-format-string
	       "~&~'iSpecify how to proceed, using the~:[~; keyboard or~] mouse.~~%")
	     ;;    :PREFER-SPECIAL-ONLY  Show `Resume' rather than `Super-A' if possible.
	     ;;    :SUPER-ONLY           Always show just `Super-A' and never `Resume'.
	     ;;    :PREFER-SPECIAL       Show `Resume 2or0 Super-A'.
	     ;;    :PREFER-SUPER         Show `Super-A or Resume'.
	     (key-colon ":")				; Trailing colon for keys
	     (option-style '(nil nil nil)))		; Style for proceed options
  (declare (values final-y))
  (flet ((key-displayer (char1 &optional char2)
	   #'(lambda ()
	       (with-character-style (key-style)
		 (format t "~:[~C~;~@:C~]~@[ ~'ior~ ~0@*~:[~2@*~C~;~2@*~@:C~]~]"
			 full-key-name char1 char2)))))
    (with-character-family (:swiss menu :bind-line-height t)
      (cl:fresh-line menu)
      (with-character-style (banner-style menu :bind-line-height t)
	(cl:typecase banner-message
	  (null)
	  (string (cl:write-string banner-message menu))
	  (symbol (funcall banner-message menu))))
      (flet ((show-error-message (menu style)
	       (with-character-style (style menu :bind-line-height t)
		 (when banner-message (terpri menu))
		 (send *error* :report menu))))
	(if error-y-offset-1 (send menu :increment-cursorpos nil error-y-offset-1))
	(if banner-message
	    (scl:indenting-output (menu error-indent)
	      (show-error-message menu error-style))
	    (show-error-message menu banner-style))
	(if error-y-offset-2 (send menu :increment-cursorpos nil error-y-offset-2)))
      (format menu prompt-format-string show-keys))
    (let ((y (multiple-value-bind (nil y)
		 (send menu :read-cursorpos)
	       (+ y (floor (send menu :baseline) 2)))))
      (terpri menu)
      (formatting-table (menu :inter-column-spacing inter-column-spacing)
	(when (and show-headers (eq show-keys :before))
	  (formatting-row (menu)
	    (formatting-cell (menu :align-x key-alignment) (format menu "~'iKeystroke~"))
	    (formatting-cell (menu) (format menu "~'iAction~"))))
	(loop for proc in *proceed-dispatch-table*
	      for super-char-code from (char-code #\A)
	      for super-char = (make-character (code-char super-char-code)
					       :bits char-super-bit)
	      unless (and (not (caar proc)) (memq (cadr proc) suppress))
		do (formatting-row (menu)
		     (dw:with-output-as-presentation
			 (:stream menu
			  :object (cons (cdr proc) *error*)
			  :type 'proceed-option
			  :single-box t
			  :allow-sensitive-inferiors nil
			  :allow-sensitive-raw-text nil)
		       (let ((special-char (caar proc)) char1 char2)
			 (cl:case key-preference
			   (:prefer-special-only
			     (setq char1 (or special-char super-char)))
			   ((:super-only :prefer-super-only)
			    (setq char1 super-char))
			   (otherwise ;; :prefer-super or :prefer-special
			     (setq char1 (if special-char special-char super-char)
				   char2 (if special-char super-char))
			     (when (and (eq key-preference :prefer-super) char2)
			       (cl:rotatef char1 char2))))
			 (when (eq show-keys :before)
			   (formatting-cell (menu :align-x key-alignment)
			     (with-character-family (:fix menu :bind-line-height t)
			       (format menu "~Q~A" (key-displayer char1 char2) key-colon))))
			 (formatting-cell (menu)
			   (with-character-style (option-style menu :bind-line-height t)
			     1(heading-off-dw-conditional-newline-barfage (menu)
0			       (describe-proceed-option (cdr proc) *error* menu)1)
0			     (when (eq show-keys :after)
			       (format menu " (~Q)" (key-displayer char1 char2)))))))))
	(dolist (stuff other-proceed-options)
	  (destructuring-bind (char text . ignore) stuff
	    (destructuring-bind (ignore . item) stuff
	      (formatting-row (menu)
		(dw:with-output-as-presentation
		    (:stream menu
		     :object (tv:menu-execute-no-side-effects item)
		     :type other-options-type
		     :single-box t
		     :allow-sensitive-inferiors nil
		     :allow-sensitive-raw-text nil)
		  (when (eq show-keys :before)
		    (formatting-cell (menu :align-x key-alignment)
		      (with-character-family (:fix menu :bind-line-height t)
			(format menu "~Q~A" (key-displayer char) key-colon))))
		  (formatting-cell (menu)
		    (with-character-style (option-style menu :bind-line-height t)
		      (scl:write-string text menu)
		      (when (eq show-keys :after)
			(format menu " (~Q)" (key-displayer char)))))))))))
      (graphics:draw-line 0 y (send menu :maximum-x-position) y :thickness 1
			  :stream menu)
      y)))

(defvar *proceed-via-menu-icon*
	(graphics:with-output-to-bitmap (stream :width 40 :height 55)
	  (graphics:draw-rectangle 20. 53. 21. 20. :stream stream)
	  (graphics:draw-circle 20. 48. 3. :stream stream)
	  (graphics:draw-rectangle 19. 46. 21. 20. :stream stream)
	  (graphics:draw-rectangle 16. 43. 24. 20. :stream stream)
	  (graphics:draw-circle 20. 20. 20. :stream stream)))

(defun draw-proceed-via-menu-icon (&optional (stream standard-output))
  (graphics:with-room-for-graphics (stream 55.)
    (graphics:draw-image *proceed-via-menu-icon* 0 0 :stream stream)
    (graphics:draw-string 
      (banner-message-default-for-draw-proceed-via-menu)
      50. 20.
      :attachment-x :left
      :attachment-y :center
      :stream stream)))

(defun options-for-proceed-via-menu-style (style)
  (flet ((basic-options (style)
	   (cl:ecase style
	     (:simple					;Shows Resume, Abort, Suspend, c-M
	       '(:suppress (:restart :proceed :special-command)
		 :error-y-offset-1 5
		 :error-y-offset-2 5
		 :key-preference :prefer-special-only))
	     (:novice					;Also shows special commands
	       '(:suppress (:restart :proceed)
		 :error-y-offset-1 5
		 :error-y-offset-2 5
		 :key-preference :prefer-special))
	     (:expert					;Shows everything
	       '(:error-y-offset-1 5
		 :error-y-offset-2 5
		 :key-preference :prefer-special)))))
    (cl:case style
      ((:simple :novice :expert)
       (basic-options style))
      ((:simple-icon :novice-icon :expert-icon)
       (append '(:banner-message draw-proceed-via-menu-icon
		 :error-indent 50.
		 :error-y-offset-1 -30.
		 :error-y-offset-2 10.)
	       (basic-options (cdr (assoc style '((:simple-icon . :simple)
						  (:novice-icon . :novice)
						  (:expert-icon . :expert)))))))
      (:classic
	'(:banner-message nil
	  :full-key-name nil
	  :key-style (nil nil nil)
	  :show-keys :after
	  :prompt-format-string "~&~'iSelect a proceed option~~%"))
      (otherwise
	(if (cl:listp style)
	    style
	    ;; If there's a bug in this stuff, it's better to just go with
	    ;; the wrong thing than to send the user into the debugger...
	    '())))))


;;; Top level of command loop

;; The debugger command tables
(defvar *debugger-comtab* (cp:make-command-table "Debugger"
						 :command-table-size 100.))
(cp:add-command-accelerator "Debugger" 'cp:read-full-command '(#/: #\m-X))

(defvar *lisp-debugger-comtab* (cp:make-command-table "Lisp-Debugger"
						      :command-table-size 40.
						      :inherit-from '("Debugger")))

;; These are compiled into DEBUGGER-TOP-LEVEL, to increase speed / reduce working-set
(eval-when (compile load eval)
(defvar *debugger-open-coded-bindings*
	'((standard-input syn-terminal-io)
	  (standard-output syn-terminal-io)
	  (error-output syn-terminal-io)
	  (debug-io syn-terminal-io)
	  (query-io syn-terminal-io)
	  (*input-editor-options* nil)
	  (*input-editor-typein* nil)
	  (rubout-handler nil)
	  (dw:*presentation-input-context* nil)
	  (read-preserve-delimiters nil)
	  (*read-suppress* nil)
	  (si:xr-maintain-correspondence nil)
	  (si:xr-correspondences nil)
	  (kbd-intercepted-characters kbd-standard-intercepted-characters)
	  (local-declarations nil)
	  (default-cons-area working-storage-area)
	  (trace-conditions nil)
          (conditions:*break-on-signals* nil)
	  (*menu-proceed-conditions* *standard-menu-proceed-conditions*))))

;Users can insert additional bindings here if they wish to slow down the debugger
(defvar *debugger-bindings* nil)

(defmacro with-debugger-bindings (&body body)
  `(let ,*debugger-open-coded-bindings*
     (si:with-interactive-values-bound (*debugger-bindings* nil)
       ,@body)))

(defvar-standard *debugger-saving-stream-state* nil)

(defun debugger-control-stack-grown-handler (ignore)
  ;; Relocate all interesting Debugger stuff
  (relocate-debugger-frame-pointers)
  ;; Applications above the Debugger may still need to handle this condition
  nil)

(defun debugger-timer-expired-handler (e)
  ;; Need to save input editor state and establish new context in case the timer
  ;; expired while reading a Debugger command.
  (flet ((query ()
	   1;;--- This is still not right
0	   (with-input-editing ()
	     (dw:with-accept-activation-chars ('(#\End #\Return) :override t)
	       (cl:yes-or-no-p "Timer ~S expired.~%Would you like to remain in the debugger? "
			       (send e :timer))))))
    (if (if (ignore-errors
	      (operation-handled-p terminal-io :with-saved-state-for-break))
	    (send terminal-io :with-saved-state-for-break #'query)
	  (query))
	1(throw 'quit nil)
0      1(throw 'return-values-from-debugger nil)0)))

(defmacro with-debugger-handlers (&body body)
  `(condition-bind ((control-stack-grown #'debugger-control-stack-grown-handler)
		    (process::form-timeout #'debugger-timer-expired-handler))
     ,@body))

;; The value returned from here is a list of values to be returned as the
;; values of ENTER-DEBUGGER
(defun debugger-top-level (*error* *innermost-visible-frame*
			   *reason-debugger-entered* special-commands
			   &optional elide-bottom-frame)
  ;; What was this trying to do?
  ;;(setq tv:prepared-sheet nil)
  ;; Resort to increasingly stringent emergency measures to cope with recursive errors
  (flet ((debug ()
	   (declare (downward-function))
	   (let ((*debugger-saving-stream-state* nil))
	     (with-debugger-handlers
	       (tv:unprepare-sheet
		 (debugger-top-level-1 special-commands elide-bottom-frame))))))
    (if (and (not (or *debug-io-override* *debugger-saving-stream-state*))
	     (ignore-errors
	       (operation-handled-p terminal-io :with-saved-state-for-break)))
	(let ((*debugger-saving-stream-state* t))
	  (send terminal-io :with-saved-state-for-break #'debug))
	(debug))))

(defvar-resettable conditions:*debugger-hook* nil)

(defun debugger-top-level-1 (special-commands elide-bottom-frame)
  (when conditions:*debugger-hook*
    (let ((old-*debugger-hook* conditions:*debugger-hook*)
	  (conditions:*debugger-hook* nil))
      (funcall old-*debugger-hook* *error* old-*debugger-hook*)))
  (let* ((original-terminal-io (or *debug-io-override*
				   (let ((stream (symeval-in-error-environment 'debug-io)))
				     (if (stringp stream)
					 stream (si:follow-syn-stream stream)))))
	 (old-standard-input (and (variable-boundp standard-input)
				  (si:follow-syn-stream standard-input)))
	 (terminal-io original-terminal-io)
	 (debugger-using-menus nil)				;"user typed Abort" flag
	 (inhibit-scheduling-flag inhibit-scheduling-flag))	;SETQ'ed below
    (unwind-protect
	;; Decide if stream is okay and whether to notify the user
	(let (w-o)
	  (cond ((stringp terminal-io)
		 (use-cold-load-stream terminal-io))
		((null (setq w-o (ignore-errors
				   (let ((trace-conditions nil))
				     (send terminal-io :which-operations)))))
		 (use-cold-load-stream "Using TERMINAL-IO gets an error"))
		((eq terminal-io tv:cold-load-stream)
		 (setq terminal-io nil)		;so use-cold-load-stream will work as we desire
		 (use-cold-load-stream "DEBUG-IO is the cold-load stream"))
		((and (instancep terminal-io)
		      (not (send-if-handles terminal-io :interactive)))
		 ;; This is a lot easier now that we have encapsulating streams.
		 ;; Be forgiving, even though most such streams warn the user
		 ;; that he is about to lose.
		 (use-cold-load-stream "TERMINAL-IO is not an interactive stream"))
		(( *debugger-level* *debugger-level-cold-load-stream-threshold*)
		 (use-cold-load-stream "Many recursive errors"))
		(*debugger-might-have-system-problems* 
		 (use-cold-load-stream "Recursive errors in the debugger"))
		;; This experiment was considered by many to be more a source
		;; of trouble than a benefit, so comment it out.  Maybe when use
		;; of WITHOUT-INTERRUPTS is more disciplined it could come back.
		#+++ignore
		(inhibit-scheduling-flag
		 (use-cold-load-stream "INHIBIT-SCHEDULING-FLAG set to T"))
		((memq :notice w-o)
		 (ignore-errors
		   (let ((window-bad (send terminal-io :notice :error)))
		     (when (stringp window-bad)
		       (use-cold-load-stream window-bad))))))
	  (when (eq terminal-io cold-load-stream)	;If we switched streams
	    (setq tv:cold-load-stream-selected t)	; for any reason
	    ;; If we are reading from the cold load stream, disable interrupts
	    ;; for the duration of our time in the debugger.  This prevents other
	    ;; processes from preempting us and seizing the cold-load stream, which
	    ;; is something that can really drive a user up the wall.
	    (setq inhibit-scheduling-flag t))
	  (when (and (null *disable-menu-proceeding*)
		     ;; No menus in the cold-load stream or on remote consoles
		     (not tv:cold-load-stream-selected)
		     (not (neti:remote-terminal-p))
		     ;; The mouse has to be on the current screen, too
		     (let* ((window (symeval-in-error-environment 'terminal-io))
			    (screen (or (and (instancep window)
					     (send-if-handles window :screen))
					tv:main-screen))
			    (mouse (tv:sheet-mouse screen)))
		       (and mouse (tv:sheet-me-or-my-kid-p (tv:mouse-sheet mouse) screen)))
		     ;; No menus if entering because TRACE-CONDITIONS is set
		     (not (and (symeval-in-error-environment
				 'trace-conditions *innermost-visible-frame*)
			       *reason-debugger-entered*))
		     ;; Finally check for an interesting condition
		     (not (or (typep *error* 'zl:break)
			      (typep *error* 'cl:break)))
		     (or (eq *menu-proceed-conditions* t)
			 (loop for condition in *menu-proceed-conditions*
			       thereis (and (get condition 'flavor)
					    (si:typep-flavor *error* condition)))))
	    (setq debugger-using-menus t))
	  (let ((si:*remembered-binding-warnings* nil)
		(*stack-frame-pdl* (make-array 20 :fill-pointer 0))
		(*current-frame* *innermost-visible-frame*)
		(*previous-current-frame* nil)
		(*innermost-interesting-frame* *innermost-visible-frame*)
		(*proceed-dispatch-table* nil)	;SETQ'ed later
		;; These need to be bound even when we're not in
		;; the Display Debugger, because many places tick them
		(*backtrace-pane-tick* 0)
		(*args-and-locals-pane-tick* 0)
		(*source-code-pane-tick* 0)
		(*inspect-history-pane-tick* 0)
		(*always-use-lisp-debugger* *always-use-lisp-debugger*)
		(already-printed nil)
		(bpt nil)
		(*debugger-might-have-system-problems*
		  (or *debugger-might-have-system-problems*
		      (si:cold-load-stream-p terminal-io)
		      (not process::*preemption-enabled*)))
		#+imach (*frame-array-index-cached-frame* nil)
		#+imach (*frame-array-index-cached-index* nil))
	    (setf (fill-pointer *stack-frame-pdl*) -1)
	    (with-debugger-bindings
	      (relocate-frame-pointers *error*)
	      ;; Print the error message now, to give the user something
	      ;; to read while we take the rest of our page faults
	      (unless (or debugger-using-menus (typep *error* 'stepper-break))
		(catch-error-restart
		  ((abort)
		   "Skip printing the error message and continue entering debugger")
		  (setq already-printed t)
		  (print-error-message *error* nil nil nil)))
	      (when (instancep terminal-io)
		;; If there is a screen associated with the IO stream
		;; make sure it is visible.  This is for color console.
		(let ((screen (send-if-handles terminal-io :screen)))
		  (when screen
		    (send-if-handles screen :set-video-on t))))
	      (setq *current-frame* (innermost-interesting-frame
				      ;; Maybe bury the Debugger entry frame
				      (if elide-bottom-frame
					  (frame-previous-frame *current-frame*)
					*current-frame*)))
	      (using-resource (*stack-frame-array* stack-frame-array)
		;; Now that we're safely in the debugger...
		(multiple-value (*current-frame* *innermost-interesting-frame*)
		  (current-and-innermost-frames-for-debugger *error* *current-frame*))
		;; Do a hasty exit if this is a breakpoint and the
		;; break condition is not satisfied
		(cond ((typep *error* 'stepper-break)
		       (let ((function (frame-function *current-frame*))
			     (pc #+3600 (frame-relative-exit-pc *current-frame*)
				 #+IMach (if *current-breakpoint-info*
					     (bpt-pc *current-breakpoint-info*)
					     (frame-relative-exit-pc *current-frame*))))
			 (setq bpt #+3600 (llc:any-breakpoint-in-function function pc)
			       #+imach (ilc:any-breakpoint-in-function function pc))
			 (when bpt
			   (let ((conditional (bpt-conditional bpt)))
			     (when conditional
			       (unless (car (if (listp conditional)
						(eval-in-error-environment t t conditional)
						(funcall-in-error-environment t t conditional)
						))
				 (return-from debugger-top-level-1
				   (catch 'quit
				     (catch 'return-values-from-debugger
				       (execute-proceed-command
					 '(:proceed :no-action) t))))))))))
		      ;; Make sure the *current-frame* is interesting to its language
		      ;; Note that a call to SI:*EVAL at the very top of the stack is
		      ;; interesting, since that is probably an entry to the Debugger
		      ;; from an interpreted form.
		      ;; Also a function with a breakpoint in it is always interesting
		      ((and (neq (frame-function *current-frame*) #'si:*eval)
			    (not (frame-interesting-p *current-frame*)))
		       (setf *current-frame*
			     (frame-previous-interesting-frame *current-frame* t
							       #+IMach nil t))))
		2;; Everything within this 0when2 clause applies to platforms that do not have a
		;; cold-load-stream so we have to take special actions.
0		#+imach
		(system-case
		  (nxp1000
		    (when (and tv:cold-load-stream-selected
			       (not (cli::domino-debug-switch-p)))
		      (cond
			(*warm-booting-from-core-dump*	2; We were booting and lost
0			 (halt (format nil "Boot~%")))	2;Cold Boot
0			(*writing-cold-load-error*	2;Recursive Error
0			 (setq *warm-booting-from-core-dump*
			       "(Filename unavailable, recursive error)")
			 (halt (format nil "Start~%")))	2;Warm Start
0			(t			2;Write the error to the FEP and warm start
0			 (let ((*writing-cold-load-error* t))
			   (multiple-value-bind (sec min hours date month year nil nil)
			       (time:get-time)
			     (condition-case (error)
				  (progn
				    (fs:with-automatic-login-to-sys-host
				      (with-open-file
					(stream
					  (format 
					    nil
					    "fep:>~2,'0D-~2,'0D-~2,'0D-~2,'0D:~2,'0D:~2,'0D-error.text"
					    year month date hours min sec)
					  :direction :output)
					(bug-report-description *error* stream nil)
					2;; Warm start to get us out of here
0					(setq *warm-booting-from-core-dump*
					      (send stream :truename))))
				    (halt (format nil "Start~%")))
				(error		2;We lost trying to write the file
0				  (setq *warm-booting-from-core-dump*
					(format nil
						"Error encountered writing error report: ~A"
						error))
				  2;; Warm boot
0				  (halt (format nil "Start~%")))
				)))))))
		  (otherwise nil))
		;; Prepare to handle c-Aborts (see below).
		(catch 'quit
		  (flet ((rebinding-message ()
			   (when (variable-boundp #'com-show-standard-value-warnings)
			     (format t "~&The following specials have been rebound; use ")
			     (with-character-style (*deemphasis-character-style*)
			       (present '(com-show-standard-value-warnings) 'cp:command
					:acceptably :very
					:for-context-type
					'((cp:command-or-form
					    :dispatch-mode :form-preferred))))
			     (format t " for details:")
			     (si:print-any-binding-warnings nil nil)
			     (terpri))))
		    (catch-error-restart
		      ((abort)
		       "Abort debugger initialization and enter dbg command loop")
		      ;; Decide whether to enter a command loop (punt if trivial
		      ;; recursive error)
		      (let ((trivial-error (error-is-trivial *current-frame* *error*)))
			(unless debugger-using-menus
			  (if trivial-error
			      (unless already-printed
				(print-error-message *error* nil nil nil))
			    ;; At this point, cannot yet list options since
			    ;; PROCEED-DISPATCH-TABLE is NIL
			    (when si:*remembered-binding-warnings*
			      (when already-printed (terpri))
			      (rebinding-message))
			    (show nil already-printed)
			    ;; Perhaps there is a breakpoint action?
			    (when bpt
			      (with-language-for-frame (*current-frame*)
				(let ((action (bpt-action bpt)))
				  (when (not (null action))
				    (selectq action
				      (:show-locals
				       (print-frame-locals *current-frame* 0 0))
				      (:show-args
				       (print-frame-args *current-frame* 0 nil))
				      (:show-all (show-all))
				      (otherwise
				       (ignore-errors
					 (if (listp action)
					     (eval-in-error-environment t t action)
					   (funcall-in-error-environment t t action)))))))))))
			;; Now that an error message has been printed, flush typeahead
			;; unless it was flushed already by somebody else.
			(when (clear-input-p *error*)
			  (ignore-errors (send terminal-io :clear-input)))
			;; Setup for special commands
			(send *error* :initialize-special-commands)
			(send-if-handles *error* :debugger-entry-hook)
			;; If this is a trivial error, check for any
			;; debugger commands to automatically do.
			(when trivial-error
			  (loop with values
				with special-commands = (send *error* :special-commands)
				for command in *trivial-error-special-commands*
				doing
			    (and (memq command special-commands)
				 (car (setq values
					    (let ((*inherit-lexical-environment* nil))
					      (funcall-in-error-environment
						t t *error* :special-command command))))
				 (return-from debugger-top-level-1 (values-list values))))
			  (return-from debugger-top-level-1 nil))
			(when (and (variable-boundp
				     dw::*mouse-handling-recursion-level*)
				   ( dw::*mouse-handling-recursion-level* 2))
			  (with-character-style (*emphasis-character-style*)
			    (format t
				"~&Recursive error occurred during mouse ~
				   input handling.~@
				   Mouse input has been disabled while in ~
				   the debugger.~%")))))
		    ;; Not a trivial error.  Make the proceed dispatch table while
		    ;; not inside an extraneous catch-error-restart.
		    (setq *proceed-dispatch-table*
			  (make-proceed-dispatch-table *error* special-commands))
		    ;; Can now display the menu
		    (when debugger-using-menus
		      (let ((result (catch 'return-values-from-debugger
				      (proceed-via-menu))))
			(if (neq result :enter-debugger)
			    (return-from debugger-top-level-1 result)
			    (setq debugger-using-menus nil)
			    (when si:*remembered-binding-warnings*
			      (rebinding-message))
			    (show nil))))
		    (catch-error-restart
		      ((abort)
		       "Abort debugger initialization and enter dbg command loop")
		      (unless (typep *error* 'stepper-break)
			(show-proceed-options)))
		    (return-from debugger-top-level-1
		      (debugger-command-loop))))
		;; There was a throw to QUIT that was not caught by the command
		;; loop.  This probably means that the catch-error-restart in
		;; fh-applier went off, and it told run-sg to throw to QUIT.
		;; One way this happens is if the user does a c-Abort while
		;; special commands are being set up.
		(ignore-errors
		  (send terminal-io :string-out "[Abort while entering debugger]"))
		'(nil)))))
      ;; UNWIND-PROTECT cleanup
      ;; If we were on a typeout window, it can go away now
      (when (instancep terminal-io)
	(send-if-handles terminal-io :make-complete))
      ;; If :NOTICE changed to a different window, get rid of it
      (when (not (eq terminal-io original-terminal-io))
	(si:process-flush-background-stream :wait-until-seen nil))
      ;; If we brought up the cold-load stream, get rid of it
      (when (eq terminal-io tv:cold-load-stream)
	(if (and (eq (or current-process t) saved-screen-process)
		 (eq *debugger-level* saved-screen-level))
	    (recover-from-cold-load-stream)
	    (setq tv:cold-load-stream-selected nil))))))



(defun debugger-command-loop (&optional program-frame)
  (let ((initial-redisplay t)
	(evalhook nil)
	(unread-command nil)
	(unread-command-type nil)
	command type
	(backtrace-pane
	  (and program-frame (send program-frame :get-pane 'backtrace)))
	(args-and-locals-pane
	  (and program-frame (send program-frame :get-pane 'args-and-locals)))
	(source-code-pane
	  (and program-frame (send program-frame :get-pane 'source-code)))
	(history-pane
	  (and program-frame (send program-frame :get-pane 'history))))
    (labels ((read-command-internal ()
	       (if unread-command
		   (values (prog1 unread-command (setq unread-command nil))
			   unread-command-type)
		 (cp:read-accelerated-command
		   :command-table (language-command-table *current-language*)
		   :form-p t
		   :prompt (lambda (stream ignore)
			     (language-debugger-prompt *current-language* stream))
		   :full-command-full-rubout t
		   :handle-clear-input t
		   :catch-accelerator-errors :abort
		   :unknown-accelerator-is-command t
		   :unknown-accelerator-tester #'proceed-command-lookup
		   :unknown-accelerator-reader #'read-form-internal
		   :unknown-accelerator-reader-prompt #'eval-prompt
		   :special-blip-handler #'reject-spurious-blips
		   :abort-chars '(#\m-Abort)
		   :suspend-chars '(#\Suspend #\m-Suspend)
		   :intercept-function #'intercept-special-chars
		   :window-wakeup (when program-frame #'wakeup))))
	     (reject-spurious-blips (blip-char)
	       (let ((blip (and (listp blip-char) (car blip-char))))
		 (if (memq blip '(dw::window-wakeup-select zwei:select-window))
		     nil
		   blip-char)))
	     (intercept-special-chars (char)
	       (declare (dbg:error-reporter))
	       (kbd-intercept-character char)
	       (throw 'quit nil))
	     (proceed-command-lookup (char)
	       (or (and (char-bit char :super)
			(let ((n (- (char-code char) (char-code #\A))))
			  (and (not (minusp n))
			       (nth n *proceed-dispatch-table*))))
		   (loop for elem in *proceed-dispatch-table*
			 when (mem #'char-equal char (car elem))
			   return elem)))
	     (eval-prompt (stream ignore)
	       (language-eval-prompt *current-language* stream))
	     (read-form-internal ()
	       (scl:destructuring-bind (form type)
		  (funcall-in-error-environment t t
		    #'(lambda () (read-command-or-form
				   nil
				   :dispatch-mode :form-preferred
				   :command-table
				     (language-command-table *current-language*)
				   :expression-reader
				     (language-expression-reader *current-language*)
				   :expression-printer
				     (language-expression-printer *current-language*)
				   :blank-line-mode :reprompt
				   :prompt nil)))
		 (if (eq type :full-rubout)
		     (values nil nil :full-rubout)
		   (values form type :form))))
	     (wakeup (blip)
	       (dw:presentation-blip-case blip
		 (dw::window-wakeup-viewport-position-changed
		  (let ((pane (dw:presentation-blip-object blip)))
		    (destructuring-bind (nil y) (dw:presentation-blip-options blip)
		      ;; Only bother when we scrolled in Y
		      (when (and (not (null y))
				 (or (and (eq pane backtrace-pane)
					  (redisplay-tick *backtrace-pane-tick*))
				     (and (eq pane args-and-locals-pane)
					  (redisplay-tick *args-and-locals-pane-tick*))
				     (and (eq pane source-code-pane)
					  (redisplay-tick *source-code-pane-tick*))
				     (and (eq pane history-pane)
					  (redisplay-tick *inspect-history-pane-tick*))))
			;; Redisplay the single pane that needs to be scrolled
			(send program-frame :redisplay-pane
					    (dw:presentation-blip-object blip))))))
		 (otherwise
		   (dw::default-window-wakeup-handler blip)))))
      (catch (if *inside-display-debugger* '|Never thrown to| 'return-values-from-debugger)
	(loop with -   = nil
	      ;; It's OK that we bind these, even in the face of the Ivory Rev 1
	      ;; logic-variable bug, because EVCPs don't "bind through".
	      with +   = (symeval-in-error-environment '-)
	      with ++  = (symeval-in-error-environment '+)
	      with +++ = (symeval-in-error-environment '++)
	      with *   = (symeval-in-error-environment '*)
	      with **  = (symeval-in-error-environment '**)
	      with *** = (symeval-in-error-environment '***)
	      with //  = (symeval-in-error-environment '//)
	      with inhibit-scheduling-flag = inhibit-scheduling-flag	;SETQ'ed below
	      with throw-flag = nil
	      doing
	  (catch 'dw::abort-command-read
	    ;; Since *STACK-FRAME-ARRAY* and friends are maintained as specials,
	    ;; the CONDITION-BIND in DEBUGGER-TOP-LEVEL which calls this is not
	    ;; sufficient in the face of recursive entries to the Debugger.
	    ;; Relocating things by hand is a hedge against disaster.
	    (relocate-debugger-frame-pointers)
	    (with-language-for-frame (*current-frame*)
	      (when program-frame
		(send program-frame :redisplay initial-redisplay)
		(when initial-redisplay
		  (dw::flush-pending-wakeups query-io)
		  (setq initial-redisplay nil)))
	      (catch-error-restart ((error abort)
				    "~:[~;Display ~]Debugger command level ~D"
				    *inside-display-debugger* *debugger-level*)
		(catch 'quit
		  (when throw-flag
		    (print-error-message *error* t *show-backtrace* t))
		  (setq throw-flag t)
		  ;; Read the next command or expression, with combined rubout processing
		  (condition-case (e)
		       (multiple-value (command type)
			 (read-command-internal))
		     (error #+++ignore (setq tv:cold-load-stream-selected t)
			    #+++ignore (use-cold-load-stream "Error reading command")
			    #---ignore (format t "Error reading command: ~~A~" e)
			    (multiple-value (command type)
			      (read-command-internal))))
		
		  ;; Once we get past here, the I/O stream is basically working and
		  ;; we can dispense with the PRINT-CAREFULLY's and IGNORE-ERROR's,
		  ;; since if we get a recursive error we will be able to handle it
		  ;; without going into an infinite loop of errors.
		  ;; If we are reading from the cold load stream, disable interrupts
		  ;; for the duration of our time in the debugger.  This prevents other
		  ;; processes from preempting us and seizing the cold-load stream, which
		  ;; is something that can really drive a user up the wall.
		  (when (eq terminal-io tv:cold-load-stream)
		    (setq inhibit-scheduling-flag t))

		  (si:allow-recursive-wired-ferror
		    (stack-let
		      ((input-type `((cp:command-or-form
				       :command-table
				         ,(language-command-table *current-language*)
				       :dispatch-mode :form-preferred))))
		      (dw:with-presentation-more-break-input-context
			 (input-type)
			 (blip)
			   (selectq type
			     ;; All the proceed commands get handled as unknown accelerators 
			     (:unknown
			      (tyo #\Space)
			      (execute-proceed-command (cdr command))
			      (redisplay-tick *backtrace-pane-tick*
					      *args-and-locals-pane-tick*
					      *source-code-pane-tick*)
			      (setq throw-flag nil))
			     ;; Commands get run in the Debugger environment, and don't
			     ;; return any value (they must set *, **, etc, by hand)
			     ((:command :accelerator)
			      (when (car command)
				(if (cp:command-in-command-table-p (car command)
								   cp:*global-command-table*)
				    (si:with-process-non-interactive-priority ()
				      (eval command))
				  ;; We assume things only in the debugger comtab are
				  ;; short and purely interactive.
				  (eval command)))
			      (setq throw-flag nil))
			     ;; Forms get run in the program environment
			     (:form
			      (catch 'quit		;If quit while evaling, still set +
				(eval-and-print-for-values command)
				(redisplay-tick *args-and-locals-pane-tick*)
				(setq throw-flag nil))
			      (cl:shiftf +++ ++ + -))
			     (t nil))
			 (t
			   (multiple-value-bind (form type)
			       (cp::echo-and-return-command-or-form-blip blip nil input-type)
			     (setq unread-command form
				   unread-command-type type)))))))))))))))

;; FORM must be a Lisp form.  Foreign languages must ensure that anything
;; that gets this far had better be a Lisp form.
(defun eval-and-print-for-values (form)
  (si:with-process-non-interactive-priority ()
    (let ((new-//
	    (let ((si:inside-trace nil))
	      (condition-bind
		  ((debugger-condition #'maybe-pass-condition-to-user))
		(warn-about-specially-handled-variables form)
		;; There are two ways to make this work in the face of multiple
		;; languages.  The first is to make the LANGUAGE-EXPRESSION-EVALUATOR
		;; generic take both a form and a frame, and set up the evaluation 
		;; environment and then do the evaluation.  The second is to have each
		;; language translate its expression to Lisp, and then just do this!
		;; Naturally, we take door number 2, because number 1 is HARD.
		(eval-in-error-environment t nil (setq - form))))))
      (cond ((neq new-// *error-flag*)
	     (si:set-value-for-* (car new-//))
	     ;; Even though we evaluate Lisp, we print in the correct language.
	     ;; It's the wrong thing, but it gets the right behavior.
	     ;;--- Someday, the printer should take both an object and a type
	     (loop with printer = (language-expression-printer *current-language*)
		   for value in new-//
		   do (send terminal-io :fresh-line)
		      (let ((*print-pretty* (or *debugger-print-pretty* *print-pretty*))
			    (*print-circle* (or *debugger-print-circle* *print-circle*)))
			(print-carefully "expression"
			  (funcall printer value))))
	     (setq // new-//)))
      (when *inside-display-debugger*
	(maintain-inspect-history-pane dw:*program* (car new-//))))))

(defunp maybe-pass-condition-to-user (condition)
  (let ((handled-p (condition-handled-p condition)))
    (selectq handled-p
      (:maybe (format t "~&This condition may or may not be handled by the program:~%  ~~A~"
		condition))
      (nil)
      (t (format t "~&This condition will be handled by the program:~%  ~~A~"
	   condition)))
    (when handled-p
      ;;--- Should be three options: Pass on, Enter debugger, or Abort
      (when (yes-or-no-p "Pass it on to the program? ")
	(return nil)))
    ;; If the user typed Abort while evaluating an expression, then the debugger
    ;; should handle it gracefully unless the user program has a handler for it,
    ;; in which case the debugger should be entered recursively
    (if (and (or (typep condition 'sys:abort)
		 (typep condition 'stepper-break))
	     (not handled-p))
	nil
      (let ((*debugger-level* (1+ *debugger-level*))
	    ;; Search up the stack 'til we find the frame that signalled the error.
	    ;; This way, the user doesn't have to see internal frames.  (Note that
	    ;; :ERROR-REPORTER properties aren't the way to do this!)
	    (frame (loop for frame = (%stack-frame-pointer)
				   then (frame-previous-frame frame)
			 until (or (null frame)
				   (eq (frame-function frame)
				       #'(flavor:method dbg:signal-condition condition)))
			 finally (return (if (null frame)
					     (frame-previous-frame (%stack-frame-pointer))
					   (frame-previous-frame frame))))))
	(values-list
	  (debugger-top-level
	    condition frame
	    "an error occurred while evaluating a form in the debugger" nil))))))


;; Print out the error message of the error.
;; ERROR nil means don't print the error message, it's already been printed.
;; RETURN-P means to print "Back to".
;; BACKTRACE-P means to print the one-line backtrace.
;; HOOK-P means to check for an ERROR-MESSAGE-HOOK and print it.
(defun print-error-message (error return-p backtrace-p hook-p)
  (let ((*printing-monitor-message* t)
	(cl:*print-level* *error-message-prinlevel*)
	(cl:*print-length* *error-message-prinlength*)
	(scl:*print-string-length* *error-message-string-length*))
    (flet ((one-line-backtrace (n)
	     (print-backtrace n 0 t
			      (lambda (frame count ignore)
				(or (zerop count) (princ "  "))
				(present-stack-frame frame)))))
      (dw:with-output-as-presentation (:object error
				       :type 'sys:form)
	(print-carefully "error message"
	  (when error
	    (with-character-style (*emphasis-character-style*)
	      (format t "~&~:[~;Back to ~]~A: " return-p (condition-type error))
	      (print-carefully "report"
		(with-indentation
		  (standard-output
		    (or (send-if-handles standard-output :read-cursorpos :character) 2))
		  (send error :report standard-output))))
	    (send standard-output :fresh-line))))
      (when backtrace-p				;If not suppressed give backtrace
	(princ "While in the function ")
	(microcode-backtrace *innermost-interesting-frame*)
	(let ((*current-frame* *innermost-interesting-frame*)
	      (*error* error))
	  (one-line-backtrace *error-message-backtrace-length*))
	(terpri))
      (when hook-p				;Check for user message hook
	(let ((hook (symeval-in-error-environment 'error-message-hook)))
	  (when hook
	    (funcall hook)			;Call user function to explain
	    (send standard-output :fresh-line)))))))


;;; Functions to extract the argument and local variable values from a frame.

(defun arg (name-or-number)
  (values (lframe-argument-value *current-language* *frame* name-or-number)))

(defun loc (name-or-number)
  (values (lframe-local-value *current-language* *frame* name-or-number :force)))

(defun val (&optional (val-no 0))
  (if (operation-handled-p *error* :values-being-returned)
      (let ((values (send *error* :values-being-returned)))
	(if (< val-no (length values))
	    (nth val-no values)
	  (ferror "Value number ~D out of range; ~D values are being returned"
	    val-no (length values))))
    (ferror "No values are being returned now")))

(defun fun ()
  (frame-function *frame*))

(cl:defsetf  arg set-arg)
(scl:deflocf arg arg-location)

(cl:defsetf  loc set-loc)
(scl:deflocf loc loc-location)

(cl:defsetf  val set-val)
(scl:deflocf val val-location)

#+3600 (cl:defsetf  fun set-fun)
#+3600 (scl:deflocf fun fun-location)

(defun set-arg (name-or-number value)
  (let ((*printing-monitor-message* t))
    (multiple-value-bind (nil loc)
	(lframe-argument-value *current-language* *frame* name-or-number)
      (redisplay-tick *args-and-locals-pane-tick*)
      (setf (location-contents loc) value)
      value)))

(defun set-loc (name-or-number value)
  (let ((*printing-monitor-message* t))
    (multiple-value-bind (nil loc)
	(lframe-local-value *current-language* *frame* name-or-number :force)
      (redisplay-tick *args-and-locals-pane-tick*)
      (setf (location-contents loc) value)
      value)))

#+3600
(defun set-val (val-no value)
  (if (operation-handled-p *error* :values-being-returned)
      (let ((values (send *error* :values-being-returned)))
	(if (< val-no (length values))
	    (setf (nth val-no values) value)
	  (ferror "Value number ~D out of range; ~D values are being returned"
	    val-no (length values))))
    (ferror "No values are being returned now")))

#+imach
(defun set-val (val-no value)
  (if (operation-handled-p *error* :values-being-returned)
      (multiple-value-bind (values locations)
	  (send *error* :values-being-returned)
	(if ( val-no (length values))
	    (ferror "Value number ~D out of range; ~D values are being returned"
	      val-no (length values))
	  (setf (nth val-no values) value)
	  (%p-store-contents (nth val-no locations) value)))
    (ferror "No values are being returned now")))

#+3600
(defun set-fun (value)
  (let ((*printing-monitor-message* t)
	(function (si:valid-function-definition value t)))
    (if (null function)
	(ferror "~S does not have a valid function definition" value)
      (when (neq (frame-function *frame*) function)
	(redisplay-tick *backtrace-pane-tick*
			*args-and-locals-pane-tick*
			*source-code-pane-tick*)
	(show-frame-after-motion :silently))
      (setf (frame-function *frame*) function))))

(defun arg-location (name-or-number)
  (multiple-value-bind (nil loc)
      (lframe-argument-value *current-language* *frame* name-or-number)
    loc))

(defun loc-location (name-or-number)
  (multiple-value-bind (nil loc)
      (lframe-local-value *current-language* *frame* name-or-number :force)
    loc))

#+3600
(defun val-location (val-no)
  (if (operation-handled-p *error* :values-being-returned)
      (let ((values (send *error* :values-being-returned)))
	(if (< val-no (length values))
	    (locf (nth val-no values))
	  (ferror "Value number ~D out of range; ~D values are being returned"
		  val-no (length values))))
    (ferror "No values are being returned now")))

#+imach
(defun val-location (val-no)
  (if (operation-handled-p *error* :values-being-returned)
      (multiple-value-bind (nil locations)
	  (send *error* :values-being-returned)
	(if (< val-no (length locations))
	    (nth val-no locations)
	  (ferror "Value number ~D out of range; ~D values are being returned"
		  val-no (length locations))))
    (ferror "No values are being returned now")))

#+3600
(defun fun-location ()
  (let ((*printing-monitor-message* t))
    (locf (frame-function *frame*))))


(defun present-stack-frame (frame &optional (stream standard-output))
  ;; FRAME might be different than *CURRENT-FRAME*
  (with-language-for-frame (frame)
    (let ((frame-object (cons frame *error*)))
      (multiple-value-bind (name fspec-type)
	  (lframe-frame-function-name *current-language* frame nil)
	(let ((pretty-name (lframe-frame-function-name *current-language* frame)))
	  (print-carefully "stack frame"
	    ;; Using a single box gives an easier target to hit
	    (dw:with-output-as-presentation (:stream stream
					     :object frame-object
					     :type 'stack-frame
					     :allow-sensitive-inferiors nil)
	      ;; This will give useful behavior even when we're not in the Debugger any more
	      (dw:with-output-as-presentation (:stream stream
					       :object name
					       :type fspec-type)
		(let ((cl:*print-level* nil)
		      (cl:*print-length* nil))
		  (if (stringp pretty-name)
		      (princ pretty-name stream)
		    (prin1 pretty-name stream)))))))))))

;;; Frame printing
(defun print-function-and-args (frame &optional show-pc-p show-source-file-p
						show-local-if-different)
  (with-language-for-frame (frame)
    (let ((*printing-monitor-message* t)
	  (cl:*print-level* *function-prinlevel*)
	  (cl:*print-length* *function-prinlength*)
	  (function (frame-function frame)))
      (print-carefully "function name"
	(terpri)
	(and (closurep function)
	     (princ "Closure of "))
	(with-character-style (*emphasis-character-style*)
	  (present-stack-frame frame))
	(when (and show-pc-p
		   (typep function :compiled-function))
	  (let ((pc-now (frame-relative-exit-pc frame)))
	    (if pc-now (format t "  (P.C. = ~O)" pc-now))))
	(with-character-style (*deemphasis-character-style*)
	  (loop for func = function then (fsymeval (cadr encaps))
		for delimiter = "  (encapsulated for " then ", "
		as encaps = (and (legitimate-function-p func)
				 (si:debugging-info-user-entry
				   func 'si:encapsulated-definition))
		while encaps
		do (princ delimiter)
		   (princ (caddr encaps))
		finally (or (eq func function)
			    (princ ")")))
	  (unless (frame-active-p frame)
	    (format t "  (not yet active)")))
	(when show-source-file-p
	  (print-function-source-file function)))
      (terpri)
      (print-frame-args frame 3 show-local-if-different))))

(defun print-function-source-file (function)
  (ignore-errors
    (let ((function-name (lframe-function-name *current-language* function nil)))
      (unless (language-validate-function-spec *current-language* function-name)
	(return-from print-function-source-file nil))
      (let ((source (si:function-spec-get function-name :source-file-name t))
	    (original nil))
	(when (listp source)
	  ;; Even the foreign languages use DEFUN for function definitions
	  (let ((paths (assq 'defun source)))
	    (setq original (first (last (rest2 paths))))
	    (setq source (second paths))))
	;; Don't show source file if it's not known
	(when (null source)
	  (return-from print-function-source-file nil))
	;; Don't show source file if it's a standard system function
	(unless (stringp source)		;work while still loading the inner system
	  (setq source (send source :generic-pathname))
	  (if (null original)
	      (let ((system (sct:patchable-system-from-pathname source)))
		;; :SCRC is special, that's where we develop all this stuff
		(when (and system (memq1 0:scrc (sct:system-maintaining-sites system)))
		  (return-from print-function-source-file nil)))
	    (let ((pfvi (send source :get 'si:patch-file-version-info))
		  (system (sct:patchable-system-from-pathname original)))
	      (when (and pfvi system
			 (memq :scrc (sct:system-maintaining-sites system))
			 (eq system (sct:find-system-named (first pfvi) t t)))
		(return-from print-function-source-file nil)))))
	;; We know it's a user-dependent or site-dependent pathname, so print it
	(format t "  ~V(from ~A)~" *deemphasis-character-style* source))
      (unless (si:function-same-as-function-from-name function)
	(format t "  ~V(not the current definition)~" *deemphasis-character-style*)))))

;; Returns 1+ the number of the last local variable that it displayed.  Normally 0.
;; On the A machine, 1 if a rest arg was printed.  On the L machine, the highest
;; local slot in the argument block.
;; SHOW-LOCAL-IF-DIFFERENT causes arguments to be displayed that have been SETQ'ed.
(defun print-frame-args (frame indent &optional show-local-if-different n-args-and-locals)
  (declare (values local-start))
  (let ((*printing-monitor-message* t)
	(cl:*print-level* *error-message-prinlevel*)
	(cl:*print-length* *error-message-prinlength*)
	(scl:*print-string-length* *error-message-string-length*))
    (print-carefully "frame args"
      (lframe-print-arguments (find-language-for-frame frame)
			      frame indent show-local-if-different
			      n-args-and-locals))))

(defun print-frame-locals (frame local-start &optional (indent 0) n-args-and-locals)
  (let ((*printing-monitor-message* t))
    (print-carefully "frame locals"
      (lframe-print-locals (find-language-for-frame frame)
			   frame local-start indent
			   n-args-and-locals))))

#+imach
(defun describe-open-subframes (frame &optional (indent 0))
  (let ((*printing-monitor-message* t))
    (print-carefully "open subframes"
      (lframe-describe-open-subframes (find-language-for-frame frame) frame indent))))


;; Return the name of the argno'th arg of function, or NIL if
;; not known or function doesn't want that many args.
;; Rest args don't count.
#+3600
(defun arg-name (function argno)
  (language-argument-name (find-language-for-function function) function argno))

#+imach
(defun arg-name (frame argno)
  (language-argument-name (find-language-for-frame frame) frame argno))

#+3600
(defun rest-arg-name (function)
  (language-rest-argument-name (find-language-for-function function) function))

#+imach
(defun rest-arg-name (frame)
  (language-rest-argument-name (find-language-for-frame frame) frame))

#+3600
(defun local-name (function localno &optional pc)
  (language-local-name (find-language-for-function function) function localno pc))

#+imach
(defun local-name (frame localno &optional pc)
  (language-local-name (find-language-for-frame frame) frame localno pc))


;;; Show commands

;; This is how the error message is printed when the error handler starts up.
;; Give error message, context, and warnings about screwed-up environment
(defun show (&optional (show-proceed-options t) already-printed)
  (unless already-printed (terpri))
  (print-error-message (and (not already-printed) *error*) nil *show-backtrace* t)
  (unless (typep *error* 'stepper-break)
    (show-function-and-args)
    (when show-proceed-options
      (show-proceed-options)))
  (and *reason-debugger-entered*
       (format t "~& Debugger was entered because ~A" *reason-debugger-entered*))
  (show-process-owning-lock)
  ;; Print any useful warnings
  (or (eq base ibase)
      (format t "~& Warning: BASE is ~D. but IBASE is ~D.~%" base ibase))
  (let ((dca (symeval-in-error-environment 'default-cons-area)))
    (or (eq dca working-storage-area)
	(format t "~& Warning: The default cons area is ~A, not working-storage-area.~%"
	  (area-name dca))))
  (when (symeval-in-error-environment 'inhibit-scheduling-flag *innermost-visible-frame*)
    (format t "~& Warning: ~INHIBIT-SCHEDULING-FLAG is set.  You are probably in the ~
	       middle of a program~@
	       that did not expect to be interrupted.  Things may be inconsistent.~~%"))
  nil)

;; If we interrupted a process waiting on some kind of lock, then show the
;; user what process currently owns the lock.
(defprop locking-function t si:debug-info)
(defun show-process-owning-lock ()
  (loop repeat 10.				;don't search too far
	for frame = *current-frame* then (frame-previous-frame frame)
	until (null frame)
	as function = (frame-function frame)
	as locking-function = (si:debugging-info-user-entry function 'locking-function)
	doing
    (when locking-function
      (destructuring-bind (nil describer &rest arg-names) locking-function
	(let ((arguments (loop for arg-name in arg-names
			       collect (frame-arg-value frame arg-name))))
	  (cl:apply describer arguments))))))

(defun show-function-and-args (&optional show-source-file-p)
  (print-function-and-args *current-frame* nil show-source-file-p nil))

(defun show-all (&optional show-source-file-p clear-window)
  (when clear-window
    (send-if-handles standard-output :clear-window))
  ;; Print the header, including the function name
  (show-additional-frame-info *current-frame*)
  (typecase (frame-function *current-frame*)
    (:compiled-function (show-all-compiled show-source-file-p))
    (otherwise (show-function-and-args show-source-file-p))))

(defun show-all-compiled (&optional show-source-file-p)
  (let* ((*printing-monitor-message* t)
	 (frame *current-frame*)
	 (function (frame-function frame))
	 (active-p (frame-active-p frame)))
    (format t "~V~S~" *emphasis-character-style*
			(lframe-function-name *current-language* function nil))
    (unless active-p
      (format t "  (not yet active)"))
    (when show-source-file-p
      (print-function-source-file function))
    (format t "~2%")
    ;; Print the arguments, including the rest-arg which is a local
    (let ((local-start (print-frame-args *current-frame* 1 t)))
      (when active-p
	;; Print the rest of the locals, if the frame is active
	(print-frame-locals frame local-start 1)
	#+imach (when (ldb-test %%cr.call-started (frame-own-control-register frame))
		  (describe-open-subframes frame 1))
	(lframe-show-code-for-function *current-language* frame function
				       (lframe-show-source-code-p *current-language*)
				       :brief nil)
	;; This kludge is to prevent the prompt from triggering a **MORE**
	;; when it comes out on the bottom line of the window
	(when (memq :notice (send standard-output :which-operations))
	  (send standard-output :notice :input-wait))))))

(defun show-proceed-options ()
  (flet ((show-proceed-option (proceed stream)
	  (present (cons proceed *error*) 'proceed-option :stream stream)))
    (loop for a in *proceed-dispatch-table*
	  ;; Could use a proper CHAR-SUCCESSOR function here
	  with char = #\s-A
	  do (format t "~&~C~{, ~C~}:~15T" char (car a))
	     (print-carefully "proceed option"
	       (with-indentation
		   (standard-output
		     (or (send standard-output :read-cursorpos :character) 2))
		 (show-proceed-option (cdr a) standard-output)))
	     (incf (char-code char)))))

(defun describe-proceed-option (proceed error stream)
  (selectq (first proceed)
    (:proceed
     (send error :document-proceed-type (second proceed) stream))
    (:special-command
     (send error :document-special-command (second proceed) stream))
    (:restart
     (funcall (car (second proceed)) :describe-restart stream))
    (:exit-debugger
     (send stream :string-out (or (second proceed) "Exit debugger")))
    (:eval
     (if (third proceed) 
	 (send stream :string-out (third proceed))
       (send stream :string-out "Evaluate ")
       (prin1 (second proceed) stream)))))

(cp:define-command (com-execute-proceed :command-table "Debugger"
					:provide-output-destination-keyword nil)
    ((proceed 'proceed-option))
  (execute-proceed-command (car proceed)))

(define-presentation-to-command-translator execute-proceed
   (proceed-option
    :gesture :select
    :documentation "Take this proceed option"
    :tester ((proceed &rest ignore)
	     ;; Don't accept "old" proceed options
	     (let ((error (cdr proceed)))
	       (and (variable-boundp *error*)
		    (eq error *error*)
		    (neq (condition-status error)
			 :signalled)))))
   (proceed)
  `(com-execute-proceed ,proceed))

(defvar *aborting-disabled* nil)

(cp:define-command (com-abort :command-table "Debugger"
			      :provide-output-destination-keyword nil)
    ((clear-trap-on-exit 'scl:boolean
			  :default t
			  :prompt "Clear all trap-on-exits"
			  :documentation "Clear all trap-on-exits before aborting"))
  (cond (*aborting-disabled*
	 (format t
	     "~&You have disabled ABORT, use ~V:Enable Aborts~ enable it again"
	   *deemphasis-character-style*))
	(t
	 ;; Kludgy way to do the Abort
	 (loop for entry in *proceed-dispatch-table*
	       do (when (mem #'char-equal #\Abort (car entry))
		    (format t "~&")
		    (execute-restart (cdr entry) nil clear-trap-on-exit)))
	 (beep)
	 (format t "~&There are no restart handlers for ABORT"))))

(cp:define-command-accelerator abort "Debugger" (#\Abort #\c-Z) () (arg-p ignore)
  (if arg-p
      `(com-abort nil)
    `(com-abort)))

(cp:define-command (com-proceed :command-table "Debugger"
				:provide-output-destination-keyword nil)
    (&key
      (trap-on-call 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Trap on the next function call"))
  ;; Kludgy way to do the Resume
  (loop for entry in *proceed-dispatch-table*
	do (when (mem #'char-equal #\Resume (car entry))
	     (format t "~&")
	     (execute-proceed-command (cdr entry) nil trap-on-call)))
  (beep)
  (format t "~&There is no way to proceed from this error"))

(cp:define-command-accelerator proceed "Debugger" (#\Resume) () ()
  `(com-proceed))

;; This is a table of special key bindings which some proceed types get.
;; Earlier entries on this list shadow later entries, and they all shadow
;; global commands except for Abort and Resume.
(defvar *proceed-type-special-keys*
	'((:store-new-value #\s-sh-C)		;As in BASH-AND-PROCEED in OES
	  ))

;; Similarly for special commands.
(defvar *special-command-special-keys*
	'((:package-dwim #\c-sh-P)
	  ))

;; This makes up the error-dependent dispatch-table
;; It is a list whose elements are:
;; (<keys> <command> . <args>)
;; Keys is a list of special keys which can invoke this command.
;; Abort and Resume are inserted in this table here
;; Command-type is one of:
;;  :EXIT-DEBUGGER -- Arg, if present, is the description printed.
;;  :PROCEED -- args are arguments to proceed message, not evaluated.
;;  :SPECIAL-COMMAND -- ditto, to special-command message.
;;  :RESTART -- arg is the sublist of *RESTART-HANDLERS*.
;;	If the handler doesn't handle *ERROR*, and it handles the :FAKE-RESTART message,
;;	then that is sent instead of :HANDLE-CONDITION *ERROR*.
;;  :EVAL -- evaluate arg1.  arg2 is optional documentation.
(defun make-proceed-dispatch-table (error &optional other-keys)
  (if *inside-make-proceed-dispatch-table*
      (progn
	(format t "~&Warning -- recursive entry to MAKE-PROCEED-DISPATCH-TABLE,~@
		     will quit trying compute proceed options")
	nil)
    (let* ((*inside-make-proceed-dispatch-table* t)
	   (proceed-types (send error :proceed-types))
	   (special-commands (send error :special-commands))
	   (restarts (symeval-in-error-environment '*restart-handlers*))
	   (proceed-keys
	     (loop for type in proceed-types
		   collect (list (cdr (assq type *proceed-type-special-keys*))
				 :proceed type)))
	   (special-command-keys
	     (loop for elem in special-commands
		   collect (list (cdr (assq elem *special-command-special-keys*))
				 :special-command elem)))
	   (restart-keys
	     (loop for l on restarts with abort-used = nil
		   for ll first (cdr restarts) then (cddr ll)
		   when (eq l ll)
		     do (format error-output "~&[Warning: restart handler list circular.  ~
					         Please report this bug.]~%")
			(loop-finish)
		   as restart = (car l)
		   when (and (or (show-restart-handler-p *error* restart)
				 ;; Always handle the innermost abort.
				 (and (not abort-used)
				      (send restart :handle-condition-flavors-p '(abort))))
			     (si:valid-throw-tag-p
			       (follow-cell-forwarding (%make-pointer dtp-locative l) nil)))
		     collect (list (and (not abort-used)
					(send restart :handle-condition-flavors-p '(abort))
					(setq abort-used '(#\Abort)))
				   :restart l))))
      ;; Resume gets the first proceed type
      ;; Abort was already set up to get the first abort handler
      (and proceed-keys
	   (not (ass #'si:mem-char #\Resume other-keys))
	   (push #\Resume (caar proceed-keys)))
      ;; If Resume is not otherwise used, put it on the first restart handler if
      ;; it is designed for restarting from this error (as opposed to catching
      ;; arbitrary errors and aborts).
      (and (not proceed-keys)
	   (not (ass #'si:mem-char #\Resume other-keys))
	   (not (ass #'si:mem-char #\Resume special-command-keys))
	   restart-keys
	   (not (send (car (third (first restart-keys)))
		      :handle-condition-flavors-p '(abort)))
	   (push #\Resume (caar restart-keys)))
      ;; If there are more choices than letters in the alphabet, assume that this is
      ;; because there are a lot of restart keys (the number of the others is normally
      ;; bounded by the condition), so eliminate some from the middle of the restarts.
      (let* ((n-restarts (length restart-keys))
	     (n-excess-restarts
	       (min (- (+ (length other-keys) (length proceed-keys)
			  (length special-command-keys) n-restarts) 26.)
		    (- n-restarts 4))))
	(when (plusp n-excess-restarts)
	  (setq restart-keys
		(nconc (firstn (// (- n-restarts n-excess-restarts) 2) restart-keys)
		       (nthcdr (// (+ n-restarts n-excess-restarts) 2) restart-keys)))))
      (append other-keys
	      (nconc proceed-keys special-command-keys restart-keys)))))

(defun execute-proceed-command (entry &optional silent trap-on-call)
  (when (variable-boundp #'maybe-hack-breakpoints)
    (maybe-hack-breakpoints))
  (let (tem)
    (cond ((cond ((eq (car entry) :proceed)
		  (setq tem :document-proceed-type)
		  t)
		 ((eq (car entry) :special-command)
		  (setq tem :document-special-command)
		  t))
	   (with-character-style (*deemphasis-character-style*)
	     (unless silent
	       (send *error* tem (cadr entry) standard-output)
	       (send standard-output :tyo #\Return)))
	   (when trap-on-call
	     (set-trap-on-call *current-frame* t))
	   (let* ((*inherit-lexical-environment* nil)
		  (values (eval-in-error-environment t nil `(apply ',*error* ',entry))))
	     (cond ((not (null (car values)))
		    (throw 'return-values-from-debugger values))
		   ((eq (car entry) :proceed)
		    (format t "~&The :PROCEED method declined to proceed")))))
	  ((eq (car entry) :restart)
	   (execute-restart entry silent t trap-on-call))
	  ((eq (car entry) :exit-debugger)
	   (unless silent
	     (with-character-style (*deemphasis-character-style*)
	       (send standard-output :string-out (or (cadr entry) "Exit debugger"))))
	   (when trap-on-call
	     (set-trap-on-call *current-frame* t))
	   (throw 'return-values-from-debugger '(nil)))
	  ((eq (car entry) :eval)
	   (when trap-on-call
	     (set-trap-on-call *current-frame* t))
	   (eval (cadr entry)))
	  (t (ferror "Invalid entry in proceed dispatch table:  ~S" entry)))))

(defun execute-restart (entry &optional silent (clear-trap-on-exit t) trap-on-call)
  (unless silent
    (let ((*inherit-lexical-environment* nil))
      (with-character-style (*deemphasis-character-style*)
	(funcall-in-error-environment t nil
	  (caadr entry) :describe-restart standard-output)))
    (tyo #\Return standard-output))
  (catch 'private-special-command
    (let* ((tag (follow-cell-forwarding (%make-pointer dtp-locative (cadr entry)) nil))
	   (reasons (si:throw-inhibit-reasons tag)))
      (when reasons
	(let ((travesty				;It's a travesty if the user has no choice
		(loop for (nil . choice) in *proceed-dispatch-table* do
		  (cond ((eq choice entry) (return t))
			((memq (car choice) '(:proceed :special-command :exit-debugger))
			 (return nil))
			((eq (car choice) ':restart)
			 (unless (si:throw-inhibit-reasons
				   (follow-cell-forwarding
				     (%make-pointer dtp-locative (cadr choice))
				     nil))
			   (return nil)))))))
	  (selectq (process::process-abort-query
		    nil "abort" reasons t 2 nil nil travesty nil nil)
	    (process::abort (si:note-forcible-abort current-process reasons))
	    (otherwise (format t "~&The attempt to abort the program has been abandoned.~%")
		       (throw 'quit nil)))))
      (when clear-trap-on-exit
	(clear-trap-on-exits tag))
      (cond ((funcall (caadr entry) :handle-condition-p *error*)
	     (when trap-on-call
	       (set-trap-on-call *current-frame* t))
	     (funcall-in-error-environment nil nil
	       (caadr entry) :handle-condition *error* tag))
	    ((funcall (caadr entry) :operation-handled-p :fake-restart)
	     (when trap-on-call
	       (set-trap-on-call *current-frame* t))
	     (funcall-in-error-environment nil nil
	       (caadr entry) :fake-restart tag))
	    (t (format t "~&Restart handler won't allow restarting")
	       (throw 'quit nil)))
      ;; Normally, the restart-handler will throw, which will cause
      ;; the debugger to be thrown through, and any debugger stack
      ;; group to go away.
      (error "Restart handler didn't throw?"))))

;; Find the tag that execute-restart would throw to, NIL if none
(defun condition-throw-tag (&rest condition-flavors)
  (loop for l on *restart-handlers*
	when (send (car l) :handle-condition-flavors-p condition-flavors)
	  return (follow-cell-forwarding (%make-pointer dtp-locative l) nil)))

;; The theory for trap on exits is that they are cleared by explicit commands
;; to dispose of a context containing them.  Thus invoking a restart handler
;; clears trap-on-exits in frames that will be thrown through, and returning
;; or throwing when the debugger was entered by a trap-on-call clears the
;; trap-on-exit that was left behind by that trap-on-call.
(defun clear-trap-on-exits (list-in-stack-frame)
  (when *innermost-visible-frame*
    ;; Prevent any trap-on-exits from the throw out to the restart level
    #+3600
    (loop for frame = *innermost-visible-frame* then (frame-previous-open-frame frame)
	  until (or (null frame)
		    (%pointer-lessp frame list-in-stack-frame))
	  do (setf (debugger-trace-flag frame) nil))
    #+imach
    (map-over-frames-in-stack
      ;; Find stack-group of frame
      (let ((low (sg-control-stack-low %current-stack-group))
	    (current-fp (%stack-frame-pointer)))
	;; optimize the common case.
	(if (and (%pointer-lessp low *innermost-visible-frame*)
		 (si:%pointer- *innermost-visible-frame* current-fp))
	    si:%current-stack-group
	    (multiple-value-bind (origin active-size size number sg type)
		(si:decode-stack-address *innermost-visible-frame*)
	      (ignore origin active-size size number type)
	      sg)))
      #'(lambda (frame lcr function)
	  (declare (ignore lcr function))
	  (when (or (null frame)
		    (%pointer-lessp frame list-in-stack-frame))
	    (return-from clear-trap-on-exits))
	  (unless (not (%pointer-lessp frame *innermost-visible-frame*))
	    (setf (debugger-trace-flag frame) nil)))
      :none)))

;;; Backtrace commands.

;; Print only the names of the functions, as many per line as will fit.
(defun short-backtrace (&optional (n 10000.) internal-flag continuations #+imach active-only)
  (send standard-output :fresh-line)
  (if (null continuations)
      (scl:filling-output (t :fill-on-spaces nil)
	(let ((printed-something nil)
	      (pending-parents nil))
	  (print-backtrace n 0 internal-flag
	    (lambda (frame ignore index)
	      ;; PRINT-BACKTRACE binds *CURRENT-LANGUGAGE*
	      (let* ((function (lframe-frame-function-name *current-language* frame nil))
		     (continued (memq function pending-parents))
		     ;; The parent can either be the nominal function-parent
		     ;; for this function, or whatever function owns this
		     ;; :INTERNAL function
		     (parent (if (and (listp function)
				      (eq (first function) ':internal))
				 (second function)
			       (and (validate-function-spec function)
				    (multiple-value-bind (fspec type)
					(function-parent function)
				      (and (eq type 'defun) fspec))))))
		(when continued
		  ;; If we have just printed a pending parent, remove it
		  ;; from the list
		  (setq pending-parents (delq function pending-parents)))
		(if (and parent
			 (loop repeat (- n index)
			       for fr = frame then (frame-previous-frame fr) while fr
			       as fr-name = (function-name (frame-function fr)) 
			       when (equal fr-name parent)
				 do (setq parent fr-name)
				    (return t)))
		    ;; If this function has a parent which will eventually get
		    ;; printed, save it away for later
		    (push parent pending-parents)
		  ;; Here is where we can print something, finally
		  (when printed-something
		    (send standard-output :conditional-string-out " ")
		    (cl:write-char (if continued #\ #\))
		    (cl:write-char #\space))
		  (present-stack-frame frame)
		  (setq printed-something t))))
	    #+imach active-only)))
    ;;--- When DW filling-streams are faster, always use them
    ;;--- Perhaps a "flatsize" stream would be a useful addition to DW?
    (let ((current-font (send-if-handles debug-io :current-font)))
      (if (or (null current-font)		;watch out for cold-load stream
	      (null (tv:font-char-width-table current-font)))
	  ;; I know that this is not in the new idiom, but it's up to 50% faster than
	  ;; the version below for fixed-width fonts
	  (let* ((line-length (or (send-if-handles standard-output :size-in-characters) 95.))
		 (chars-left line-length))
	    (print-backtrace n 0 internal-flag
	      (lambda (frame count ignore)
		(let* ((name (function-name (frame-function frame)))
		       (name-length (+ (if (plusp count) 3 0) (flatsize name))))
		  (when (and (> name-length chars-left)
			     ( name-length line-length))
		    (terpri)
		    (setq chars-left line-length))
		  (when (plusp count) (princ "  "))
		  (present-stack-frame frame)
		  (decf chars-left name-length)))
	      #+imach active-only))
	;; For variable-width fonts, use the slow (but more elegant) implementation
	(formatting-textual-list (t :separator "  "
				    :filled :before
				    :after-line-break " ")
	  (print-backtrace n 0 internal-flag
	    (lambda (frame ignore ignore)
	      (formatting-textual-list-element ()
		(present-stack-frame frame)))
	    #+imach active-only))))))

(defun print-backtrace (n skip internal-flag frame-printer-function
			#+imach &optional #+imach active-only)
  (macrolet ((move-frame (frame)
	       `(if internal-flag
		    (if #+3600 t #+imach active-only
			(frame-previous-active-frame ,frame)
		      (frame-previous-open-frame ,frame))
		  (frame-previous-interesting-frame ,frame nil #+imach active-only))))
    (loop with *print-pretty* = nil		;two things filling is too many
	  with count = 0
	  for frame = *current-frame* then (move-frame frame)
	  for index upfrom (- skip) below n
	  until (null frame)
	  do (unless (minusp index)
	       ;; Be sure that *current-language* reflects this frame
	       (with-language-for-frame (frame)
		 ;; In backtraces, always censor uninteresting frames, no
		 ;; matter what c-N or c-P will do
		 (when (or internal-flag (frame-interesting-p frame))
		   (print-carefully "function name"
		     (funcall frame-printer-function frame count index)
		     (incf count))))))))

(define-presentation-type invisible-frame-type ()
   :abbreviation-for `((or (scl:sequence (scl:member ,@*all-invisible-frame-types*))
			   scl:boolean))
   :description "an invisible frame type")

(cp:define-command (com-show-backtrace :command-table "Debugger")
    (&key (nframes 'cl:integer
		   :default 10000.
		   :documentation "Show this many frames")
	  (internal 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation #+3600 "Don't skip interpreter frames"
				   #+imach "Don't skip interpreter or open frames")
	  (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show arguments")
	  (invisible 'invisible-frame-type
		     :default (not *censor-invisible-frames*)
		     :default-type 'scl:boolean
		     :mentioned-default t
		     :documentation "Don't skip invisible frames")
	  #+imach
	  (active-only 'scl:boolean
		       :default nil
		       :mentioned-default t
		       :documentation "Skip frames which are open but not active")
	  (continuations 'scl:boolean
			 :when (null detailed)
			 :default t
			 :documentation "Show continuation functions"))
  (let ((*invisible-frame-types-to-show*
	  (if (symbolp invisible) *invisible-frame-types-to-show* invisible))
	(*censor-invisible-frames* (neq invisible t)))
    (let-if (and (not continuations) (not invisible))
	    ((*combined-methods-are-invisible* t))
      (if detailed
	  (print-backtrace nframes 0 internal
			   (lambda (frame ignore ignore)
			     (print-function-and-args frame nil t nil))
			   #+imach active-only)
	(short-backtrace nframes internal continuations #+imach active-only)))))

(cp:define-command-accelerator continuation-backtrace "Debugger" (#\c-B) () (arg-p arg)
  `(com-show-backtrace ,@(if arg-p `(:nframes ,arg))))

;;; Bug report

;;; Set this to something else if you prefer, like (si:parse-character-style '(nil nil :large))
;;; or (si:character-style-for-device-font 'fonts:quantum si:*b&w-screen*)
(defvar *character-style-for-bug-mail-prologue*
	(si:parse-character-style '(:fix :roman :tiny)))

(defun bug-mail-prologue (st &key system-name)
  (let ((fill-column				;this heuristic could be improved...
	  (let ((default-char-width (send cl:*terminal-io* :string-length "s"))
		(this-char-width (send cl:*terminal-io* :string-length
				       (make-array
					 1 :type 'art-fat-string :initial-value
					 (si:make-merged-char
					   #\s *character-style-for-bug-mail-prologue*)))))
	    (// (* 75. default-char-width) this-char-width))))
    (scl:with-character-style (*character-style-for-bug-mail-prologue* st)
      (cl:fresh-line st)
      (multiple-value-bind (model serial-number)
	  (si:machine-model)
	;; FORMATTED-SYSTEM-VERSION-INFO does its own filling.
	(cl:write-string (sct:formatted-system-version-info
			   "" "" (format nil "In Symbolics ~D~:[ ~A in~;~*~] "
					 model
					 (or (null system-name)
					     (string-equal
					       system-name
					       dbg:*default-bug-recipient-root-name*))
					 system-name)
			   fill-column)
			 st)
	(cl:write-string "," st)
	(scl:fresh-line st)
	(scl:filling-output (st :fill-column fill-column)
	  (format st "world ~:[booted from ~;disk-saved into ~]~A~@[ (~A)~] "
		  si:*disk-saved* si:loaded-band-name
		  (when (and (variable-boundp sct:system-additional-info)
			     (plusp (array-active-length sct:system-additional-info)))
		    sct:system-additional-info))
	  (format st "on Symbolics ~D~@[ #~D~] (~A):~%"
		  model serial-number si:local-pretty-host-name)
	  ;; Full GC count.
	  (let ((system-release (- si:*system-release-gc-count*
				   si:*released-system-release-gc-count*)))
	    (when (> system-release 0)
	      (format st "(SI:FULL-GC :SYSTEM-RELEASE T)'s since release of system: ~D~%"
		      system-release)))
	  ;; Warm booted processes.
	  (when si:warm-booted-processes
	    (cl:write-string "Warm booted from: " st)
	    (scl:format-textual-list si:warm-booted-processes #'princ :stream st)
	    (format st ".~%"))
	  ;; Aborted processes.
	  (when si:*processes-forcibly-aborted*
	    (format st "Processes forcibly aborted:")
	    (dolist (item (cl:remove-duplicates si:*processes-forcibly-aborted*
						:from-end t :test #'equal))
	      (let ((process (car item))
		    (reasons (cdr item))
		    (count (cl:count item si:*processes-forcibly-aborted*
				     :test #'equal)))
		(format st "~%~2@T~A aborted~:[ ~D time~:P~;~*~] ~
				with the following warning:~{~%~4@T~~A~~^~%~4@T. . .~}"
			process (= count 1) count reasons)))
	    (terpri st))
	  ;; Processes forcibly reset at warm-boot.
	  (when si:*processes-forcibly-reset-at-warm-boot*
	    (format st "Processes forcibly reset by warm-booting:")
	    (dolist (item (cl:remove-duplicates si:*processes-forcibly-reset-at-warm-boot*
						:from-end t :test #'equal))
	      (let ((process (car item))
		    (reasons (cdr item))
		    (count (cl:count item si:*processes-forcibly-reset-at-warm-boot*
				     :test #'equal)))
		(format st "~%~2@T~A reset~:[ ~D time~:P~;~*~] ~
				with the following warning:~{~%~4@T~~A~~^~%~4@T. . .~}"
			process (= count 1) count reasons)))
	    (terpri st))
	  ;; and a blank line.
	  (terpri st))))))

;; Bug reporting command
;; Starts up a new window and a new process to report the bug, so that
;; the user may switch back to this window to perform further investigation,
;; or to attempt to recover, before mailing off a complete bug report.
(cp:define-command (com-mail-bug-report :command-table "Debugger"
					:provide-output-destination-keyword nil)
    (&key
      (nframes '((dw:token-or-type
		   (("All" . t)
		    ("Default" . nil))
		   stack-frame-or-integer))
	       :default nil
	       :documentation "Number of frames in backtrace"))
  (fs:force-user-to-login)			;before switching processes, windows
  (if (not (and (variable-boundp #'zwei:bug) (variable-boundp #'mail-bug-report-1)))
      ;; both Zwei and Development Debugger must be present to generate bug messages
      (with-open-file (stream (accept '((fs:pathname ) :direction :write)
				      :prompt "Save bug report in file"
				      :default (fs:make-pathname :host "FEP" :directory :root
								 :name "BUG" :type "TEXT"
								 :version :newest))
			      :direction :output :error :reprompt)
	(bug-mail-prologue stream)
	(format stream "~2&")
	(cl:write-line "Please explain the circumstances that led to this bug, and how it can be reproduced" stream)
	(let ((*printing-monitor-message* t))
	  (bug-report-description *error* stream nframes)))
    (let ((*printing-monitor-message* t))
      (mail-bug-report-1 :process-name "Mail from debugger"
			 :system (or *default-bug-report-recipient-system*
				     (bug-report-recipient-system *error*))
			 :additional-body (with-output-to-string (stream)
					    (bug-report-description *error* stream nframes))
			 :prompt "Please explain the circumstances that led to this bug, and how it can be reproduced"
			 :point-before-additional-body t))))

(cp:define-command-accelerator bug "Debugger" (#\c-M) () (arg-p arg)
  `(com-mail-bug-report ,@(when arg-p `(:nframes ,arg))))

(defvar *default-backtrace-depth* 8.
  "Default depth of the backtrace in bug-reports sent via debugger command")

(defmethod (:bug-report-description condition) (standard-output n-frames)
  (let ((*error* self)				;need this to print backtraces
	(current-frame *current-frame*))
    ;; Encourage users to include complete information in their bug reports
    (when (%pointer-lessp current-frame *innermost-interesting-frame*)
      (when (fquery () "The current frame, for ~S, is in the middle of the stack.~@
			Do you want the stack trace in your bug report to start at ~
			the top of the stack,~%at the frame for ~S, instead? "
		    (function-name (frame-function current-frame))
		    (function-name (frame-function *innermost-interesting-frame*)))
	(setq current-frame *innermost-interesting-frame*)))
    ;; N-FRAMES could be an actual frame!
    (when (presentation-frame-p n-frames)
      (setq n-frames (1+ (loop for frame = current-frame then (frame-previous-frame frame)
			       until (or (null frame) (eq frame (car n-frames)))
			       count 1))))
    (let* ((total-frames (loop for frame = current-frame
					 then (frame-previous-active-frame frame)
			       until (null frame)
			       count t)))
      ;; NFRAMES = NIL  all frames, NFRAMES = T  ask
      (cond ((null n-frames)
	     (setq n-frames total-frames))
	    ((not (numberp n-frames))
	     (setq n-frames *default-backtrace-depth*)
	     (when
	       (and (> total-frames n-frames)
		    (fquery ()
			"There are a total of ~D frames in the stack.  By default only~@
			 information for the top ~D frames is included.  Would you prefer~@
			 to include detailed information for every frame instead? "
		      total-frames n-frames))
	       (setq n-frames total-frames)))))
    (let ((*error-message-prinlevel* *bug-report-prinlevel*)
	  (*error-message-prinlength* *bug-report-prinlength*)
	  (*error-message-string-length* *bug-report-string-length*)
	  (*current-frame* current-frame)
	  (*censor-invisible-frames* nil)
	  ;; Canonicalize the printing of symbols
	  (package (pkg-find-package 'scl)))
      (terpri)
      (print-error-message self nil t t)
      (describe-condition-for-bug-report self)
      (print-carefully "TRACE-CONDITIONS"
	(let ((tc (symeval-in-error-environment 'trace-conditions
						*innermost-interesting-frame*)))
	  (when tc
	    (format t "TRACE-CONDITIONS was set to ~S~%" tc))))
      (print-carefully "*BREAK-ON-SIGNALS*"
	(let ((bos (symeval-in-error-environment 'conditions:*break-on-signals*
						 *innermost-interesting-frame*)))
	  (when bos
	    (format t "*BREAK-ON-SIGNALS* was set to ~S~%" bos))))
      (let ((interesting-specials (ignore-errors
				    (find-all-special-usages
				      (frame-function current-frame))))
	    (cl:*print-level* *error-message-prinlevel*)
	    (cl:*print-length* *error-message-prinlength*)
	    (scl:*print-string-length* *error-message-string-length*))
	;; Print the backtrace, including "interesting" specials at the point
	;; where they were last bound
	(print-backtrace n-frames 0 nil
	  (lambda (frame i ignore)
	    (let ((local-start (print-function-and-args frame t t t)))
	      (when (and (zerop i)
			 (frame-active-p frame))
		(print-frame-locals frame local-start 3))
	      #+imach (when (ldb-test %%cr.call-started
				      (frame-own-control-register frame))
			(describe-open-subframes frame 1))
	      (print-carefully "frame's specials"
		(let ((frame-bindings (collect-frame-bindings frame)))
		  (loop for (sym val unbound-p) in frame-bindings
			do (when (memq sym interesting-specials)
			     (format t "   Special ~S: ~S~%"
			       sym (if unbound-p "unbound" val))
			     (setq interesting-specials
				   (delq sym interesting-specials)))))))))
	;; If there are any more "interesting" specials (which have global
	;; values but are not otherwise bound), display them
	(when interesting-specials
	  (terpri)
	  (loop for spec in interesting-specials
		do (format t "   Special ~S: ~S~%"
		     spec (if (boundp spec) (symeval spec) "unbound")))))
      (multiple-value-bind (*current-frame* more-stack)
	  (frame-next-nth-interesting-frame current-frame (- n-frames))
	(when more-stack
	  (format t "~2&~VRest of stack:~" *deemphasis-character-style*)
	  (let ((cl:*print-level* *function-prinlevel*)
		(cl:*print-length* *function-prinlength*))
	    (print-backtrace 10000. 0 nil
	      (lambda (frame ignore ignore)
		(let ((function (frame-function frame)))
		  (print-carefully "function name"
		    (terpri)
		    (and (closurep function)
			 (princ "Closure of "))
		    (format t "~V~S~"
		      *emphasis-character-style* (function-name function))
		    (when (typep function :compiled-function)
		      (let ((pc-now (frame-relative-exit-pc frame)))
			(if pc-now (format t "  (P.C. = ~O)" pc-now))))
		    (with-character-style (*deemphasis-character-style*)
		      (print-function-source-file function))))))))))))

(defmethod (describe-condition-for-bug-report condition) ()
  (format t "~%The condition signalled was ~S~%" (typep self)))

(cp:define-command (com-simple-help :command-table "Debugger"
				    :provide-output-destination-keyword nil)
    ()
  (format t 
      "~&You are in the debugger.  Here are some options:~@
       ~2T~14TLeave the debugger.~@
       ~2Tc-~14TDisplay information about the other debugger commands.~:[~@
       ~2Tc-m-W~14TEnter the Display Debugger.~;~]"
    (or (not (fboundp 'com-enter-display-debugger)) (neti:remote-terminal-p))))

(cp:define-command-accelerator simple-help "Debugger" (#\Help) () ()
  `(com-simple-help))

;; Languages get to shadow this if they want
;;--- Terrible way to do help anyway
(cp:define-command (com-help :command-table "Debugger")
                   ()
  (cond ((not (variable-boundp #'show-display-debugger-help))
	 (format debug-io "This is a stripped down debugger.
You can proceed or abort, get a short backtrace (c-B), and write a full trace to a file (c-M).
"))
	((net:remote-terminal-p debug-io)
	 ;; Not likely to be in the Display Debugger here!
	 (show-debugger-help debug-io))
	(*inside-display-debugger*
	 (tv:show-help #'show-display-debugger-help
		       :wait t :title "Display Debugger Help"
		       :console (dw::stream-console debug-io)))	; assure it's on the right one
	(t
	 (tv:show-help #'show-debugger-help
		       :wait t :title "Debugger Help"
		       :console (dw::stream-console debug-io)))))

(cp:define-command-accelerator help "Debugger" (#\c-Help) () ()
  `(com-help))

;;; Now that everything is there, we can start using the real debugger.

(defun enter-debugger (condition &optional reason special-commands elide-bottom-frame)
  (let ((*debugger-level* (1+ *debugger-level*))
	(*inside-display-debugger* nil)
	(previous-frame (frame-previous-frame (%stack-frame-pointer))))
    (cli::with-floating-point-status-saved
      (progn
	(when ( *debugger-level* *debugger-level-break-threshold*)
	  (let ((*debugger-might-have-system-problems* t))
	    ;; if we go through the first clause, then the debugger isn't in
	    ;; the cold load stream, but we want to tread carefully, anyway.
	    (cond ((< *debugger-level* *debugger-level-emergency-break-threshold*)
		   (break "because of too many errors; use (DBG:EMERGENCY-DEBUGGER) to debug"))
		  ((< *debugger-level* *debugger-level-halt-threshold*)
		   (let ((terminal-io tv:cold-load-stream)
			 (standard-input syn-terminal-io)
			 (standard-output syn-terminal-io)
			 (query-io syn-terminal-io)
			 (debug-io syn-terminal-io)
			 (inhibit-scheduling-flag t))
		     (si:emergency-break "because of too many recursive errors")))
		  (t
		   ;; Last resort is the FEP debugger
		   ;; Would be nice to set WIRED-FERROR-ARGS, if I had a wired list and string
		   (si:%funcall-in-aux-stack #'si:aux-halt)))))
	(values-list
	  (si:with-process-interactive-priority ()
	    (debugger-top-level condition previous-frame
				reason special-commands
				elide-bottom-frame)))))))

