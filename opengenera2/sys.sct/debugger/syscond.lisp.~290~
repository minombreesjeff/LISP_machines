;;; -*- Mode: Lisp; Package: Debugger; Base: 8 -*-

;;; New Condition Signalling System.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; "Use what pathname instead?"
;;;		-- F. P. Error

;;; Some standard condition flavors

;; This is signalled by the Abort key.
(DEFFLAVOR ABORT () (NULL-REPORT CONDITION))

;; User option.
;; If this is non-NIL, package dwim will always be a special command.
;; and MAP-OVER-LOOKALIKE-SYMBOLS will only be done the first time you
;; invoke the special command.
(DEFVAR *DEFER-PACKAGE-DWIM* NIL)

(DEFFLAVOR BASIC-PACKAGE-DWIM-MIXIN (LOOKALIKE-SYMBOLS) (SPECIAL-COMMANDS-MIXIN)
  (:REQUIRED-FLAVORS ERROR)
  (:REQUIRED-METHODS :SYMBOL-FOR-PACKAGE-DWIM :USEFUL-SYMBOL-PREDICATE))

(DEFMETHOD (:INITIALIZE-PACKAGE-DWIM BASIC-PACKAGE-DWIM-MIXIN) ()
  (SETQ LOOKALIKE-SYMBOLS NIL)
  (LET ((SYM (SEND SELF ':SYMBOL-FOR-PACKAGE-DWIM)))
    (AND SYM
	 (MAP-OVER-LOOKALIKE-SYMBOLS
	   (GET-PNAME SYM)
	   PKG-GLOBAL-PACKAGE
	   #'(LAMBDA (SYM PREDICATE LIST)
	       (AND (FUNCALL PREDICATE SYM)
		    (NOT (MEMQ SYM (CDR LIST)))
		    (PUSH SYM (CDR LIST))))
	   (SEND SELF ':USEFUL-SYMBOL-PREDICATE)
	   (LOCF LOOKALIKE-SYMBOLS)))))

(DEFMETHOD (INITIALIZE-SPECIAL-COMMANDS BASIC-PACKAGE-DWIM-MIXIN) ()
  (UNLESS *DEFER-PACKAGE-DWIM*
    (FUNCALL-IN-PROPER-ENVIRONMENT SELF SELF ':INITIALIZE-PACKAGE-DWIM)
    (OR LOOKALIKE-SYMBOLS
	(SETQ SPECIAL-COMMANDS (REMQ ':PACKAGE-DWIM SPECIAL-COMMANDS)))))

;; The :PACKAGE-DWIM-INFO list has (boundp symeval description offset).
(DEFFLAVOR PACKAGE-DWIM-MIXIN () (BASIC-PACKAGE-DWIM-MIXIN)
  (:REQUIRED-METHODS :PACKAGE-DWIM-INFO))

(DEFMETHOD (:USEFUL-SYMBOL-PREDICATE PACKAGE-DWIM-MIXIN) ()
  (CAR (SEND SELF ':PACKAGE-DWIM-INFO)))

(DEFMETHOD (SPECIAL-COMMAND PACKAGE-DWIM-MIXIN :PACKAGE-DWIM) ()
  ;; Maybe this should always generate LOOKALIKE-SYMBOLs again here?
  (UNLESS (VARIABLE-BOUNDP LOOKALIKE-SYMBOLS)
    (SEND SELF ':INITIALIZE-PACKAGE-DWIM))
  (IF LOOKALIKE-SYMBOLS
      (DESTRUCTURING-BIND (NIL EVAL PRETTY OFFSET)
			  (SEND SELF ':PACKAGE-DWIM-INFO)
	(DO ((SYMBOL (SEND SELF ':SYMBOL-FOR-PACKAGE-DWIM))
	     (L LOOKALIKE-SYMBOLS (CDR L))
	     SYM)
	    ((NULL L))
	  (SETQ SYM (CAR L))
	  (WHEN (PACKAGE-DWIM-QUERY PRETTY SYM SYMBOL OFFSET EVAL)
	    (RETURN (VALUES ':NEW-VALUE (FUNCALL EVAL SYM))))))
      (FORMAT T "~&There are no lookalike symbols in other packages.")
      NIL))

(DEFUN PACKAGE-DWIM-QUERY (NOUN SYMBOL ORIGINAL OFFSET EVAL)
  (LOOP AS ANS = (FQUERY '(:CHOICES (((T "Yes.") #/Y #/T #\SP)
				     ((NIL "No.") #/N #\RUBOUT #/c-Z)
				     ((V "View the ") #/V)
				     ((P "Permanently link ") #/P)
				     ((G "Go to package ") #/G))
			   :HELP-FUNCTION PACKAGE-DWIM-HELP)
			 "Use the ~A of ~S? " NOUN SYMBOL) DO
    (SELECTQ ANS
      ((NIL) (RETURN NIL))
      (V (FORMAT QUERY-IO "~A of ~S" NOUN SYMBOL)
	 (LET ((PRINLEVEL *ERROR-MESSAGE-PRINLEVEL*)
	       (PRINLENGTH *ERROR-MESSAGE-PRINLENGTH*)
	       (SCL:*PRINT-STRING-LENGTH* *ERROR-MESSAGE-STRING-LENGTH*))
	   (SEND STANDARD-OUTPUT ':TYO #\CR)
	   (PRIN1 (FUNCALL EVAL SYMBOL))))
      (P (FORMAT QUERY-IO "~S to ~S" ORIGINAL SYMBOL)
	 (LET ((CELL1 (%MAKE-POINTER-OFFSET DTP-LOCATIVE ORIGINAL OFFSET))
	       (CELL2 (%MAKE-POINTER-OFFSET DTP-LOCATIVE SYMBOL OFFSET)))
	   (UNLESS (EQ (FOLLOW-CELL-FORWARDING CELL1 NIL) (FOLLOW-CELL-FORWARDING CELL2 NIL))
	     (%P-STORE-CDR-TYPE-AND-POINTER (FOLLOW-CELL-FORWARDING CELL1 NIL)
					    CDR-NEXT DTP-ONE-Q-FORWARD CELL2)))
	 (RETURN SYMBOL))
      (G (FORMAT QUERY-IO "~A." (SYMBOL-PACKAGE SYMBOL))
	 (PKG-GOTO (SYMBOL-PACKAGE SYMBOL))
	 (RETURN SYMBOL))
      (T (RETURN SYMBOL)))))

(DEFMETHOD (DOCUMENT-SPECIAL-COMMAND PACKAGE-DWIM-MIXIN :PACKAGE-DWIM) (STREAM)
  (COND ((AND (VARIABLE-BOUNDP LOOKALIKE-SYMBOLS) LOOKALIKE-SYMBOLS)
	 (FORMAT STREAM "Use the ~A of " (THIRD (SEND SELF ':PACKAGE-DWIM-INFO)))
	 (DO ((L LOOKALIKE-SYMBOLS (CDR L)))
	     ((NULL L))
	   (PRIN1 (CAR L) STREAM)
	   (COND ((NULL (CDR L)))
		 ((NULL (CDDR L))
		  (SEND STREAM ':STRING-OUT ", or "))
		 (T (SEND STREAM ':STRING-OUT ", "))))
	 (FORMAT STREAM " instead."))
	(T (FORMAT STREAM "Offer to use the ~A of lookalike symbols in other packages."
		   (THIRD (SEND SELF ':PACKAGE-DWIM-INFO))))))

;; This version tries to prefetch the packages so that the above can go fast.

(DEFUN MAP-OVER-LOOKALIKE-SYMBOLS (PNAME PKG FUNCTION &REST ADDITIONAL-ARGS)
  (LET* ((PACKAGES SI:*ALL-PACKAGES*)
	 (SHOW-PROGRESS TV:*SHOW-SYSTEM-INTERNAL-PROGRESS-NOTES*)
	 (HASH (AND (VARIABLE-BOUNDP SI:*INSTANT-PACKAGE-DWIM-TABLE*)
		    (MOD (SXHASH-STRING (STRING PNAME)) SI:*INSTANT-PACKAGE-DWIM-MODULUS*)))
	 (LENGTH (AND HASH
		      (SI:PKG-DWIM-AREF-LENGTH SI:*INSTANT-PACKAGE-DWIM-TABLE* HASH))))
    (TV:NOTING-PROGRESS-IF SHOW-PROGRESS ("Searching for lookalike symbols")
      (SI:PREFETCH-FOR-MAPPING-OVER-LOOKALIKE-SYMBOLS PNAME PKG SHOW-PROGRESS T)
      (IF HASH
	  (LOOP FOR PKG# FROM 0 BELOW (FILL-POINTER SI:*INSTANT-PACKAGE-DWIM-PACKAGE*) DO
	    (WHEN (SI:INSTANT-PACKAGE-DWIM-SYMBOL-IN-PACKAGE HASH PKG# LENGTH)
	      (LET ((PKG (AREF SI:*INSTANT-PACKAGE-DWIM-PACKAGE* PKG#)))
		(WHEN PKG	;package might have been killed
		  (MULTIPLE-VALUE-BIND (SYM FLAG) (INTERN-LOCAL-SOFT PNAME PKG)
		    (WHEN FLAG
		      (LEXPR-FUNCALL FUNCTION SYM ADDITIONAL-ARGS)))))))
	  (LOOP FOR PKG IN PACKAGES DO
	    (MULTIPLE-VALUE-BIND (SYM FLAG) (INTERN-LOCAL-SOFT PNAME PKG)
	      (WHEN FLAG
		(LEXPR-FUNCALL FUNCTION SYM ADDITIONAL-ARGS))))))))

(DEFUN PACKAGE-DWIM-HELP (S)
  (FORMAT S "~&Y to use it this time.
P to use it every time (permanently link the two symbols).
G to use it this time and do a pkg-goto.
V to look at the value of this symbol, then ask again.
N to do nothing with this symbol and ask about the next one."))

(DEFGENERIC CONDITIONS:CELL-ERROR-NAME (CONDITIONS:CELL-ERROR))

(DEFFLAVOR CONDITIONS:CELL-ERROR () (ERROR))

(DEFMETHOD (CONDITIONS:CELL-ERROR-NAME CONDITIONS:CELL-ERROR) ()
  NIL)

;; This is what TRANS-TRAPs are built out of.
(DEFFLAVOR CELL-CONTENTS-ERROR () (NO-ACTION-MIXIN CONDITIONS:CELL-ERROR)
  :ABSTRACT-FLAVOR
  (:REQUIRED-METHODS :DESCRIBE-CELL-CONTENTS
		     :CELL-CONTENTS-VALID
		     :DESCRIBE-VALID-CONTENTS
		     ;; This is used by :TRAP-PROCEED to do bash and proceed.
		     ;; It should not be used by programs!
		     :STORE-NEW-VALUE))

(DEFMETHOD (PROCEED CELL-CONTENTS-ERROR :NEW-VALUE) (&OPTIONAL (VALUE NIL VALUEP))
  (BLOCK NIL
    (OR (AND (NOT VALUEP)
	     (SEND SELF ':CELL-CONTENTS-VALID)
	     (FQUERY NIL "~VQ
  Do you want to go ahead and use the newly-defined value? "
			  ':DESCRIBE-VALID-CONTENTS SELF)
	     (RETURN ':NO-ACTION))
	(AND (NOT VALUEP)
	     (SETQ VALUE (PROMPT-AND-READ ':EVAL-FORM
					  "Form to evaluate and use this time as ~VQ:~%"
					  ':DESCRIBE-CELL-CONTENTS SELF))))
    (VALUES ':NEW-VALUE VALUE)))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE CELL-CONTENTS-ERROR :NEW-VALUE) (STREAM)
  (SEND STREAM :STRING-OUT "Supply a value to use this time as ")
  (SEND SELF :DESCRIBE-CELL-CONTENTS STREAM))

(DEFMETHOD (PROCEED CELL-CONTENTS-ERROR :STORE-NEW-VALUE)
	   (&OPTIONAL (VALUE (PROMPT-AND-READ ':EVAL-FORM
			       "Form to evaluate and store permanently as ~VQ:~%"
			       ':DESCRIBE-CELL-CONTENTS SELF)))
  (VALUES ':STORE-NEW-VALUE VALUE))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE CELL-CONTENTS-ERROR :STORE-NEW-VALUE) (STREAM)
  (SEND STREAM :STRING-OUT "Supply a value to store permanently as ")
  (SEND SELF :DESCRIBE-CELL-CONTENTS STREAM))

(DEFFLAVOR CONDITIONS:UNBOUND-VARIABLE (VARIABLE-NAME) (CELL-CONTENTS-ERROR)
  (:INITABLE-INSTANCE-VARIABLES (:NAME VARIABLE-NAME))
  (:READABLE-INSTANCE-VARIABLES
    (CONDITIONS:CELL-ERROR-NAME VARIABLE-NAME)))

 ;Portable code might really signal this.
(DEFMETHOD (DBG:REPORT CONDITIONS:UNBOUND-VARIABLE) (STREAM)
  (FORMAT STREAM "The variable ~S is unbound." VARIABLE-NAME))

;This flavor is abstract--specializations according to the type of variable exist below
(DEFFLAVOR UNBOUND-VARIABLE
	(VARIABLE-NAME)
	(CONDITIONS:UNBOUND-VARIABLE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :VARIABLE-NAME)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (:DESCRIBE-CELL-CONTENTS UNBOUND-VARIABLE) (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "the value of ~S" VARIABLE-NAME))

(DEFMETHOD (:DESCRIBE-VALID-CONTENTS UNBOUND-VARIABLE) (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "~S is now bound." VARIABLE-NAME))

(DEFMETHOD (REPORT UNBOUND-VARIABLE) (STREAM)
  (SEND STREAM ':STRING-OUT "The")
  (SEND SELF ':DESCRIBE-VARIABLE-TYPE STREAM)
  (SEND STREAM ':STRING-OUT " variable ")
  (PRIN1 VARIABLE-NAME STREAM)
  (SEND STREAM ':STRING-OUT " is unbound")
  (SEND SELF ':DESCRIBE-CONTEXT STREAM)
  (SEND STREAM ':TYO #/.))

(DEFMETHOD (:DESCRIBE-VARIABLE-TYPE UNBOUND-VARIABLE :DEFAULT) (IGNORE) ())
(DEFMETHOD (:DESCRIBE-CONTEXT UNBOUND-VARIABLE :DEFAULT) (IGNORE) ())

;Special variable
(DEFFLAVOR UNBOUND-SYMBOL () (PACKAGE-DWIM-MIXIN UNBOUND-VARIABLE))

(DEFMETHOD (:CELL-CONTENTS-VALID UNBOUND-SYMBOL) ()
  (BOUNDP VARIABLE-NAME))

(DEFMETHOD (:STORE-NEW-VALUE UNBOUND-SYMBOL) (VALUE)
  (SET VARIABLE-NAME VALUE))

(DEFMETHOD (:SYMBOL-FOR-PACKAGE-DWIM UNBOUND-SYMBOL) ()
  VARIABLE-NAME)

(DEFMETHOD (:PACKAGE-DWIM-INFO UNBOUND-SYMBOL) ()
  '(BOUNDP-AND-NOT-KEYWORD SYMEVAL "value" 1))

;Keywords are not candidates for package dwim, because their values are trivial
(DEFUN BOUNDP-AND-NOT-KEYWORD (SYMBOL)
  (AND (BOUNDP SYMBOL) (NOT (KEYWORDP SYMBOL))))

;Special variable, closed over.  Or a DTP-NULL pointing to a symbol, found inside
;an arbitrary memory location.
(DEFFLAVOR UNBOUND-CLOSURE-VARIABLE (ADDRESS) (UNBOUND-VARIABLE)
  (:INITABLE-INSTANCE-VARIABLES ADDRESS)
  (:REQUIRED-INIT-KEYWORDS :ADDRESS))

(DEFMETHOD (:DESCRIBE-CONTEXT UNBOUND-CLOSURE-VARIABLE) (STREAM)
  (SEND STREAM ':STRING-OUT " in a closure value cell"))

(DEFMETHOD (:CELL-CONTENTS-VALID UNBOUND-CLOSURE-VARIABLE) ()
  (LOCATION-BOUNDP ADDRESS))

(DEFMETHOD (:STORE-NEW-VALUE UNBOUND-CLOSURE-VARIABLE) (VALUE)
  (RPLACD ADDRESS VALUE))

;Instance variable
(DEFFLAVOR UNBOUND-INSTANCE-VARIABLE
	(INSTANCE)
	(UNBOUND-VARIABLE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :INSTANCE))

(DEFMETHOD (:DESCRIBE-VARIABLE-TYPE UNBOUND-INSTANCE-VARIABLE) (STREAM)
  (SEND STREAM ':STRING-OUT " instance"))

(DEFMETHOD (:DESCRIBE-CONTEXT UNBOUND-INSTANCE-VARIABLE) (STREAM)
  (SEND STREAM ':STRING-OUT " in ")
  (PRIN1 INSTANCE STREAM))

(DEFMETHOD (:CELL-CONTENTS-VALID UNBOUND-INSTANCE-VARIABLE) ()
  (BOUNDP-IN-INSTANCE INSTANCE VARIABLE-NAME))

(DEFMETHOD (:STORE-NEW-VALUE UNBOUND-INSTANCE-VARIABLE) (VALUE)
  (SET-IN-INSTANCE INSTANCE VARIABLE-NAME VALUE))

;(DEFFLAVOR UNBOUND-LOCAL-VARIABLE
;	(FUNCTION)
;	(UNBOUND-VARIABLE)
;  :INITABLE-INSTANCE-VARIABLES)
;
;(DEFMETHOD (UNBOUND-LOCAL-VARIABLE :DESCRIBE-VARIABLE-TYPE) (STREAM)
;  (SEND STREAM ':STRING-OUT " local"))
;
;(DEFMETHOD (UNBOUND-LOCAL-VARIABLE :DESCRIBE-CONTEXT) (STREAM)
;  (SEND STREAM ':STRING-OUT " in ")
;  (PRIN1 FUNCTION STREAM))
;
;(DEFMETHOD (UNBOUND-LOCAL-VARIABLE :CELL-CONTENTS-VALID) () ...)
;(DEFMETHOD (UNBOUND-LOCAL-VARIABLE :STORE-NEW-VALUE) (VALUE) ...)

(DEFFLAVOR CONDITIONS:UNDEFINED-FUNCTION (FUNCTION-NAME) (CELL-CONTENTS-ERROR)
  (:INITABLE-INSTANCE-VARIABLES (:NAME FUNCTION-NAME)))

(DEFMETHOD (CONDITIONS:CELL-ERROR-NAME CONDITIONS:UNDEFINED-FUNCTION) ()
  FUNCTION-NAME)

 ;Portable code might really signal this.
(DEFMETHOD (DBG:REPORT CONDITIONS:UNDEFINED-FUNCTION) (STREAM)
  (FORMAT STREAM "The function ~S is undefined." FUNCTION-NAME))

(DEFFLAVOR UNDEFINED-FUNCTION
	(FUNCTION-NAME)
	(PACKAGE-DWIM-MIXIN CONDITIONS:UNDEFINED-FUNCTION)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :FUNCTION-NAME))

(DEFMETHOD (:SYMBOL-FOR-PACKAGE-DWIM UNDEFINED-FUNCTION) ()
  (AND (SYMBOLP FUNCTION-NAME)
       FUNCTION-NAME))

(DEFMETHOD (:PACKAGE-DWIM-INFO UNDEFINED-FUNCTION) ()
  '(FBOUNDP FSYMEVAL "definition" 2))

(DEFMETHOD (:DESCRIBE-CELL-CONTENTS UNDEFINED-FUNCTION) (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "the definition of ~S" FUNCTION-NAME))

(DEFMETHOD (:DESCRIBE-VALID-CONTENTS UNDEFINED-FUNCTION) (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "~S is now defined." FUNCTION-NAME))

(DEFMETHOD (:CELL-CONTENTS-VALID UNDEFINED-FUNCTION) ()
  (FDEFINEDP FUNCTION-NAME))

(DEFMETHOD (:STORE-NEW-VALUE UNDEFINED-FUNCTION) (VALUE)
  (FDEFINE FUNCTION-NAME VALUE NIL T))

(DEFMETHOD (REPORT UNDEFINED-FUNCTION) (STREAM)
  (FORMAT STREAM "The function ~S is undefined." FUNCTION-NAME))

(DEFFLAVOR UNDEFINED-PROLOG-PREDICATE
	()
	(UNDEFINED-FUNCTION)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT UNDEFINED-PROLOG-PREDICATE) (STREAM)
  (FORMAT STREAM "The predicate ~S is undefined." FUNCTION-NAME))

(DEFMETHOD (PROCEED UNDEFINED-PROLOG-PREDICATE :FAIL) ()
  "Act as if it were defined with no clauses this time"
  (VALUES :NEW-VALUE NIL))

(DEFMETHOD (PROCEED UNDEFINED-PROLOG-PREDICATE :FAIL-PERMANENTLY) ()
  "Define it to have no clauses"
  (VALUES :STORE-NEW-VALUE NIL))

(DEFMETHOD (PROCEED UNDEFINED-PROLOG-PREDICATE :NO-ACTION) ()
  "Retry, now that the predicate has been defined"
  (VALUES :NO-ACTION))

(DEFMETHOD (MAKE-INSTANCE UNDEFINED-PROLOG-PREDICATE :AFTER) (&REST IGNORE)
  (SETQ PROCEED-TYPES (LIST* :FAIL :FAIL-PERMANENTLY PROCEED-TYPES)))

;; This is signaled by GET-DEFINED-FUNCTION-SPEC
(DEFFLAVOR UNDEFINED-FUNCTION-SPEC () (UNDEFINED-FUNCTION))

(DEFMETHOD (REPORT UNDEFINED-FUNCTION-SPEC) (STREAM)
  (FORMAT STREAM "The function spec ~S is undefined." FUNCTION-NAME))

(DEFMETHOD (MAKE-INSTANCE UNDEFINED-FUNCTION-SPEC :AFTER) (&REST IGNORE)
  (SETQ PROCEED-TYPES (REMQ ':NEW-VALUE PROCEED-TYPES)))

(DEFMETHOD (PROCEED UNDEFINED-FUNCTION-SPEC :NEW-FUNCTION-SPEC)
	   (&OPTIONAL (NEW-FUNCTION-SPEC (PROMPT-AND-READ ':EXPRESSION
					   "Type a function spec to use instead: ")))
  (VALUES ':NEW-FUNCTION-SPEC NEW-FUNCTION-SPEC))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE UNDEFINED-FUNCTION-SPEC :NEW-FUNCTION-SPEC) (STREAM)
  (FORMAT STREAM "Supply a new function spec to use instead of ~S" FUNCTION-NAME))

(DEFMETHOD (SPECIAL-COMMAND UNDEFINED-FUNCTION-SPEC :PACKAGE-DWIM) (&REST IGNORE)
  ;; Maybe this should generate LOOKALIKE-SYMBOLs again here?
  (UNLESS (VARIABLE-BOUNDP LOOKALIKE-SYMBOLS)
    (SEND SELF ':INITIALIZE-PACKAGE-DWIM))
  (IF LOOKALIKE-SYMBOLS
      (DO ((L LOOKALIKE-SYMBOLS (CDR L))
	   SYM ANS)
	  ((NULL L))
	(SETQ SYM (CAR L))
  RETRY	(SETQ ANS (FQUERY '(:CHOICES
			    (((T "Yes.") #/Y #/T #\SP)
			     ((NIL "No.") #/N #\RUBOUT #/c-Z)
			     ((V "View the definition of ") #/V)
			     ((P "Permanently link the definition of ") #/P)
			     ((G "Go to package ") #/G))
			    :HELP-FUNCTION PACKAGE-DWIM-HELP)
			  "Use ~S instead? " SYM))
	(COND ((NOT (NULL ANS))
	       (SELECTQ ANS
		 (V (FORMAT QUERY-IO "~S." SYM)
		    (LET ((PRINLEVEL *ERROR-MESSAGE-PRINLEVEL*)
			  (PRINLENGTH *ERROR-MESSAGE-PRINLENGTH*)
			  (SCL:*PRINT-STRING-LENGTH* *ERROR-MESSAGE-STRING-LENGTH*))
		      (SEND STANDARD-OUTPUT ':TYO #\CR)
		      (PRIN1 (FDEFINITION SYM)))
		    (GO RETRY))
		 (P (FORMAT QUERY-IO "~S to ~S" FUNCTION-NAME SYM)
		    (%P-STORE-CDR-TYPE-AND-POINTER
		      (FOLLOW-CELL-FORWARDING (FDEFINITION-LOCATION FUNCTION-NAME) NIL)
		      #.CDR-NEXT
		      #.DTP-ONE-Q-FORWARD
		      (FDEFINITION-LOCATION SYM)))
		 (G (FORMAT QUERY-IO "~A." (SYMBOL-PACKAGE SYM))
		    (PKG-GOTO (SYMBOL-PACKAGE SYM))))
	       (RETURN (VALUES ':NEW-FUNCTION-SPEC SYM)))))
      (FORMAT T "~&There are no lookalike symbols in other packages.")
      NIL))

(DEFFLAVOR BAD-DATA-TYPE-IN-MEMORY
	(ADDRESS DATA-TYPE POINTER)
	(CELL-CONTENTS-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  (:INITABLE-INSTANCE-VARIABLES ADDRESS)
  (:REQUIRED-INIT-KEYWORDS :ADDRESS))

(DEFWRAPPER (MAKE-INSTANCE BAD-DATA-TYPE-IN-MEMORY) (IGNORE BODY)
  `(PROGN ,BODY
	  (SETQ DATA-TYPE (%P-DATA-TYPE ADDRESS)
		POINTER (%P-POINTER ADDRESS))))

(DEFMETHOD (:DESCRIBE-CELL-CONTENTS BAD-DATA-TYPE-IN-MEMORY)
	   (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "the contents of #<DTP-LOCATIVE ~\SI:ADDRESS\>" (%POINTER ADDRESS)))

(DEFMETHOD (:DESCRIBE-VALID-CONTENTS BAD-DATA-TYPE-IN-MEMORY)
	   (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "#<DTP-LOCATIVE ~\SI:ADDRESS\> now contains a valid data type." (%POINTER ADDRESS)))

(DEFMETHOD (:CELL-CONTENTS-VALID BAD-DATA-TYPE-IN-MEMORY) ()
  (MEMQ (SI:DATA-TYPE-NAME (%P-DATA-TYPE ADDRESS)) *GOOD-DATA-TYPES*))

(DEFMETHOD (:STORE-NEW-VALUE BAD-DATA-TYPE-IN-MEMORY) (VALUE)
  (%P-STORE-CONTENTS ADDRESS VALUE))

(DEFMETHOD (REPORT BAD-DATA-TYPE-IN-MEMORY) (STREAM)
  (FORMAT STREAM "The word #<~A ~\SI:ADDRESS\> was read from location ~\SI:ADDRESS\~@[ (in ~A)~]."
	         ;;--- Something should be done about this gratuitous incompatibility
		 (SI:DATA-TYPE-NAME DATA-TYPE)
		 POINTER (%POINTER ADDRESS)
		 (LET ((AREA (%AREA-NUMBER ADDRESS)))
		   (AND AREA (AREA-NAME AREA)))))

(DEFFLAVOR UNKNOWN-SETF-LOCF-REFERENCE
	(FORM)
	(BASIC-PACKAGE-DWIM-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :FORM))

(DEFMETHOD (:SYMBOL-FOR-PACKAGE-DWIM UNKNOWN-SETF-LOCF-REFERENCE) ()
  (AND (LISTP FORM)
       (SYMBOLP (CAR FORM))
       (CAR FORM)))

(DEFMETHOD (PROCEED UNKNOWN-SETF-LOCF-REFERENCE :NEW-SYMBOL)
	   (&OPTIONAL (SYMBOL (PROMPT-AND-READ ':EVAL-FORM
				"Form to evaluate and use as the car of ~S:~%" FORM)))
  (VALUES ':NEW-SYMBOL SYMBOL))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE UNKNOWN-SETF-LOCF-REFERENCE :NEW-SYMBOL) (STREAM)
  (FORMAT STREAM "Supply a different function than ~S to be expanded." (CAR FORM)))

(DEFMETHOD (SPECIAL-COMMAND UNKNOWN-SETF-LOCF-REFERENCE :PACKAGE-DWIM) (&REST IGNORE)
  ;; Maybe this should generate LOOKALIKE-SYMBOLs again here?
  (UNLESS (VARIABLE-BOUNDP LOOKALIKE-SYMBOLS)
    (SEND SELF ':INITIALIZE-PACKAGE-DWIM))
  (IF LOOKALIKE-SYMBOLS
      (DO ((L LOOKALIKE-SYMBOLS (CDR L))
	   SYM ANS)
	  ((NULL L))
	(SETQ SYM (CAR L))
	(SETQ ANS (FQUERY '(:CHOICES
			    (((T "Yes.") #/Y #/T #\SP)
			     ((NIL "No.") #/N #\RUBOUT #/c-Z)
			     ((G "Go to package ") #/G))
			    :HELP-FUNCTION SETF-LOCF-PACKAGE-DWIM-HELP)
			  "Use ~S instead? " SYM))
	(COND ((NOT (NULL ANS))
	       (SELECTQ ANS
		 (G (FORMAT QUERY-IO "~A." (SYMBOL-PACKAGE SYM))
		    (PKG-GOTO (SYMBOL-PACKAGE SYM))))
	       (RETURN (VALUES ':NEW-SYMBOL SYM)))))
      (FORMAT T "~&There are no lookalike symbols in other packages.")
      NIL))

(DEFUN SETF-LOCF-PACKAGE-DWIM-HELP (S)
  (FORMAT S "~&Y to use it this time.
G to use it this time and do a pkg-goto.
N to do nothing with this symbol and ask about the next one."))

(DEFMETHOD (DOCUMENT-SPECIAL-COMMAND UNKNOWN-SETF-LOCF-REFERENCE :PACKAGE-DWIM) (STREAM)
  (COND ((AND (VARIABLE-BOUNDP LOOKALIKE-SYMBOLS) LOOKALIKE-SYMBOLS)
	 (SEND STREAM ':STRING-OUT "Use ")
	 (DO ((L LOOKALIKE-SYMBOLS (CDR L)))
	     ((NULL L))
	   (PRIN1 (CAR L) STREAM)
	   (COND ((NULL (CDR L)))
		 ((NULL (CDDR L))
		  (SEND STREAM ':STRING-OUT ", or "))
		 (T (SEND STREAM ':STRING-OUT ", "))))
	 (SEND STREAM ':STRING-OUT " instead."))
	(T (FORMAT STREAM "Offer to use lookalike symbols in other packages."))))

(DEFFLAVOR UNKNOWN-SETF-REFERENCE () (UNKNOWN-SETF-LOCF-REFERENCE))

(DEFMETHOD (REPORT UNKNOWN-SETF-REFERENCE) (TO)
  (FORMAT TO "~S has no SETF property.  Can't invert this reference:  ~S"
	  (CAR FORM) FORM))

(DEFMETHOD (:USEFUL-SYMBOL-PREDICATE UNKNOWN-SETF-REFERENCE) ()
  #'(LAMBDA (X)
      (NOT (NULL (OR (GETL X '(SETF SI:SETF-EXPANDER))
		     (AND (FBOUNDP X)
			  (OR (ARRAYP (FSYMEVAL X))
			      (SI:MACRO-FUNCTION X)
			      (LT:FIND-INLINE-FORM-METHOD X))))))))

#||
(DEFFLAVOR UNKNOWN-LOCF-REFERENCE () (UNKNOWN-SETF-LOCF-REFERENCE))

(DEFMETHOD (REPORT UNKNOWN-LOCF-REFERENCE) (TO)
  (FORMAT TO "~S has no LOCF property.  Can't get locative from this reference:  ~S"
	  (CAR FORM) FORM))

(DEFMETHOD (:USEFUL-SYMBOL-PREDICATE UNKNOWN-LOCF-REFERENCE) ()
  #'(LAMBDA (X)
      (OR (GETL X '(LOCF SI:SETF-EXPANDER))
	  (AND (FBOUNDP X)
	       (LET ((VAL (FSYMEVAL X)))
		 (OR (SI:MACRO-FUNCTION VAL)
		     (ASSQ 'SI:SUBST-DEFINITION (DEBUGGING-INFO VAL))))))))
||#

(DEFFLAVOR PAGE-FAULT-ON-UNALLOCATED-VMA
	(FORMAT-STRING VMA #+3600 PC #+3600 FP #+3600 SP)
	(ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT PAGE-FAULT-ON-UNALLOCATED-VMA) (STREAM)
  (FORMAT STREAM FORMAT-STRING VMA #+3600 PC #+3600 FP #+3600 SP))


(DEFGENERIC CONDITIONS:ARITHMETIC-ERROR-OPERATION (CONDITIONS:ARITHMETIC-ERROR))

(DEFGENERIC CONDITIONS:ARITHMETIC-ERROR-OPERANDS (CONDITIONS:ARITHMETIC-ERROR))

;; This is dictated by ANSI CL
(DEFFLAVOR CONDITIONS:ARITHMETIC-ERROR ((OPERATION NIL) (OPERANDS NIL)) (ERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:READABLE-INSTANCE-VARIABLES
    (CONDITIONS:ARITHMETIC-ERROR-OPERATION OPERATION)
    (CONDITIONS:ARITHMETIC-ERROR-OPERANDS  OPERANDS)))

;; This exists mainly for TYPEP.
(DEFFLAVOR ARITHMETIC-ERROR
	(OPERATION OPERANDS)
	(CONDITIONS:ARITHMETIC-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  :ABSTRACT-FLAVOR
  )

(DEFMETHOD (ERROR-CLASSIFICATION ARITHMETIC-ERROR) () "arithmetic")

(DEFFLAVOR CONDITIONS:DIVISION-BY-ZERO () (ARITHMETIC-ERROR))

(DEFFLAVOR DIVIDE-BY-ZERO
	((OPERATION '//)
	 (FUNCTION NIL))
	(CONDITIONS:DIVISION-BY-ZERO)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT DIVIDE-BY-ZERO) (STREAM)
  (FORMAT STREAM "There was an attempt to divide by zero~@[ in ~S~]."
	  (FUNCTION-NAME FUNCTION)))

(DEFFLAVOR FLOATING-POINT-EXCEPTION
	(NON-TRAP-RESULT
	 (SAVED-FLOAT-OPERATION-STATUS FLOAT-OPERATION-STATUS))
	(ARITHMETIC-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :NON-TRAP-RESULT)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (PROCEED FLOATING-POINT-EXCEPTION :USE-NON-TRAP-RESULT) ()
  (VALUES ':NEW-VALUE NON-TRAP-RESULT))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE FLOATING-POINT-EXCEPTION :USE-NON-TRAP-RESULT) (STREAM)
  (FORMAT STREAM "Use the ~A (non-trap) result: ~A"
	  (SELECTQ (SI:FLOAT-EXCEPTION-TYPE NON-TRAP-RESULT)
	    (:DENORMALIZED "denormalized")
	    (:INFINITY "infinite")
	    (:NAN "not-a-number")
	    (:NORMAL "normalized")
	    (:ZERO "zero"))
	  NON-TRAP-RESULT))

(DEFMETHOD (PROCEED FLOATING-POINT-EXCEPTION :USE-ZERO) ()
  (VALUES ':NEW-VALUE
	  (TYPECASE NON-TRAP-RESULT
	    (:DOUBLE-FLOAT 0.0D0)
	    (OTHERWISE 0.0))))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE FLOATING-POINT-EXCEPTION :USE-ZERO) (STREAM)
  (FORMAT STREAM "Use 0.0~:[~;d0~] as the result instead"
	  (TYPEP NON-TRAP-RESULT :DOUBLE-FLOAT)))

(DEFMETHOD (PROCEED FLOATING-POINT-EXCEPTION :NEW-VALUE)
	   (&OPTIONAL (VALUE (PROMPT-AND-READ ':NUMBER "Number to use instead: ")))
  "Ask for a number to use in place of the result"
  (TYPECASE NON-TRAP-RESULT
    ;; most of the guys who get this result are going to try to unbox the result
    (:DOUBLE-FLOAT
     (SETQ VALUE (DFLOAT VALUE))))
  (VALUES ':NEW-VALUE VALUE))

(DEFFLAVOR FLOAT-EXCEPTION-NON-NUMERIC-RESULT-MIXIN
	()
        ())

(DEFMETHOD (PROCEED FLOAT-EXCEPTION-NON-NUMERIC-RESULT-MIXIN :NEW-VALUE)
	   (&OPTIONAL (VALUE (PROMPT-AND-READ
			       :EVAL-FORM
			       "Form to be evaluated and used as the result: ")))
  "Ask for a form to be evaluated and used as the result"
  (VALUES ':NEW-VALUE VALUE))

(DEFFLAVOR FLOAT-DIVIDE-BY-ZERO
	()
	(DIVIDE-BY-ZERO FLOATING-POINT-EXCEPTION)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  )

; This option confuses programs which believe that they are getting a particular
; precision result back.  It also confuses users who don't understand precision.
;(DEFFLAVOR USE-DOUBLE-MIXIN () ()
;  :GETTABLE-INSTANCE-VARIABLES
;  :INITABLE-INSTANCE-VARIABLES
;  )
;

(DEFFLAVOR CONDITIONS:FLOATING-POINT-UNDERFLOW () (FLOATING-POINT-EXCEPTION))

(DEFMETHOD (DBG:REPORT CONDITIONS:FLOATING-POINT-UNDERFLOW) (STREAM)
  (FORMAT STREAM "There was a floating point underflow.~% For: ~S"
	  `(,OPERATION ,@OPERANDS)))

(DEFFLAVOR FLOATING-EXPONENT-UNDERFLOW
	((FUNCTION NIL))
	(CONDITIONS:FLOATING-POINT-UNDERFLOW)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  )


(DEFMETHOD (REPORT FLOATING-EXPONENT-UNDERFLOW) (STREAM)
  (FORMAT STREAM "~S produced a result too small in magnitude to be
representable as a normalized ~:[single~;double~]-precision floating-point number."
	  FUNCTION
	  (TYPEP NON-TRAP-RESULT :DOUBLE-FLOAT))
  )

(DEFFLAVOR CONDITIONS:FLOATING-POINT-OVERFLOW () (FLOATING-POINT-EXCEPTION))

(DEFMETHOD (DBG:REPORT CONDITIONS:FLOATING-POINT-OVERFLOW) (STREAM)
  (FORMAT STREAM "There was a floating point overflow.~% For: ~S"
	  `(,OPERATION ,@OPERANDS)))

(DEFFLAVOR FLOATING-EXPONENT-OVERFLOW
	((FUNCTION NIL))
	(CONDITIONS:FLOATING-POINT-OVERFLOW)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  )

(DEFMETHOD (REPORT FLOATING-EXPONENT-OVERFLOW) (STREAM)
  (FORMAT STREAM "~S produced a result too large in magnitude to be
representable as a ~:[single~;double~]-precision floating-point number"
	  FUNCTION
	  (TYPEP NON-TRAP-RESULT :DOUBLE-FLOAT))
  )

(DEFFLAVOR CONDITIONS:FLOATING-POINT-INVALID-OPERATION () (FLOATING-POINT-EXCEPTION)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR FLOAT-INVALID-OPERATION
	()
	(CONDITIONS:FLOATING-POINT-INVALID-OPERATION)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  )

(DEFMETHOD (REPORT FLOAT-INVALID-OPERATION) (STREAM)
  (FORMAT STREAM "An invalid floating-point operation was attempted:
~A with arguments ~A" OPERATION OPERANDS))

(DEFFLAVOR FLOAT-INVALID-COMPARE-OPERATION
	()
        (FLOAT-EXCEPTION-NON-NUMERIC-RESULT-MIXIN
	 FLOAT-INVALID-OPERATION)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  )

(DEFFLAVOR FLOAT-DIVIDE-ZERO-BY-ZERO
	()
	(FLOAT-INVALID-OPERATION DIVIDE-BY-ZERO)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFFLAVOR CONDITIONS:FLOATING-POINT-INEXACT () (FLOATING-POINT-EXCEPTION)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR FLOAT-INEXACT-RESULT
	()
	(CONDITIONS:FLOATING-POINT-INEXACT)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT FLOAT-INEXACT-RESULT) (STREAM)
  (FORMAT STREAM "A floating-point operation produced an inexact result:
~A with arguments ~A" OPERATION OPERANDS))

(DEFFLAVOR NEGATIVE-SQRT
	((OPERATION 'SQRT))
	(FLOAT-INVALID-OPERATION)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT NEGATIVE-SQRT) (STREAM)
  (FORMAT STREAM "Attempt to take the square root of ~S, which is negative."
	  (FIRST OPERANDS)))

(DEFFLAVOR NON-POSITIVE-LOG
	(NUMBER)
	(ARITHMETIC-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :NUMBER))

(DEFMETHOD (REPORT NON-POSITIVE-LOG) (STREAM)
  (FORMAT STREAM "Attempt to take the logarithm of ~S, which is not a positive number."
	  NUMBER))

;--- Inconsistent arguments?  This only occurs if base is 0 and exponent is negative.
(DEFFLAVOR ZERO-TO-NEGATIVE-POWER
	(EXPONENT
	 (OPERATION '^)
	 (FUNCTION NIL))
	(ARITHMETIC-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :EXPONENT))

(DEFMETHOD (REPORT ZERO-TO-NEGATIVE-POWER) (STREAM)
  (FORMAT STREAM "Attempt to execute (^ 0 ~S), which is not defined~@[in ~S~]." EXPONENT))

(DEFFLAVOR BAD-ARRAY-MIXIN
	(ARRAY
	 (STORING-NAME NIL))
	()
  (:REQUIRED-FLAVORS ERROR)
  (:INITABLE-INSTANCE-VARIABLES ARRAY)
  (:GETTABLE-INSTANCE-VARIABLES ARRAY))

(DEFWRAPPER (MAKE-INSTANCE BAD-ARRAY-MIXIN) (IGNORE BODY)
  `(PROGN ,BODY
	  (AND (NULL STORING-NAME)
	       (SETQ PROCEED-TYPES (REMQ ':STORE-NEW-ARRAY PROCEED-TYPES)))))

(DEFMETHOD (PROCEED BAD-ARRAY-MIXIN :NEW-ARRAY)
	   (&OPTIONAL (NEW-ARRAY (PROMPT-AND-READ ':EVAL-FORM
						  "Form to evaluate and use instead: ")))
  "Ask for a new array"
  (VALUES ':NEW-ARRAY NEW-ARRAY))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE BAD-ARRAY-MIXIN :STORE-NEW-ARRAY) (STREAM)
  (FORMAT STREAM "Ask for a new array to store back into ~A" STORING-NAME))

(DEFMETHOD (PROCEED BAD-ARRAY-MIXIN :STORE-NEW-ARRAY)
	   (&OPTIONAL (NEW-ARRAY (PROMPT-AND-READ ':EVAL-FORM
						  "Form to evaluate and store back into ~A: "
						  STORING-NAME)))
  (VALUES ':STORE-NEW-ARRAY NEW-ARRAY))

(DEFFLAVOR ARRAY-HAS-NO-LEADER
	((FUNCTION NIL))
	(BAD-ARRAY-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT ARRAY-HAS-NO-LEADER) (STREAM)
  (FORMAT STREAM "The array ~:[~*~S~;given to ~S, ~S,~] does not have a leader."
	  FUNCTION FUNCTION ARRAY))

(DEFFLAVOR FILL-POINTER-NOT-FIXNUM
	((FUNCTION NIL))
	(BAD-ARRAY-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT FILL-POINTER-NOT-FIXNUM) (STREAM)
  (FORMAT STREAM "The fill-pointer of the array ~:[~*~S~;given to ~S, ~S,~] is not a fixnum."
	  FUNCTION FUNCTION ARRAY))

(DEFFLAVOR ARRAY-WRONG-NUMBER-OF-DIMENSIONS
	(DIMENSIONS-GIVEN
	 DIMENSIONS-EXPECTED
	 (APPLIED NIL)
	 (FUNCTION NIL))
	(BAD-ARRAY-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT ARRAY-WRONG-NUMBER-OF-DIMENSIONS) (STREAM)
  (FORMAT STREAM
    (IF APPLIED
	"The ~2@*~D-dimensional array ~1@*~S was erroneously applied to ~3@*~D argument~:P."
	"~S was given ~S, a ~S-dimensional array; it expected a ~S-dimensional one.")
    FUNCTION ARRAY DIMENSIONS-GIVEN DIMENSIONS-EXPECTED))

(DEFFLAVOR ARRAY-WRONG-NUMBER-OF-SUBSCRIPTS
	(SUBSCRIPTS-GIVEN
	 (FUNCTION NIL)
	 (NUMBER-OF-SUBSCRIPTS-GIVEN NIL)
	 (NUMBER-OF-SUBSCRIPTS-EXPECTED NIL))
	(BAD-ARRAY-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (MAKE-INSTANCE ARRAY-WRONG-NUMBER-OF-SUBSCRIPTS) (&REST IGNORE)
  (UNLESS NUMBER-OF-SUBSCRIPTS-GIVEN
    (SETQ NUMBER-OF-SUBSCRIPTS-GIVEN (LENGTH SUBSCRIPTS-GIVEN)))
  (UNLESS NUMBER-OF-SUBSCRIPTS-EXPECTED
    (SETQ NUMBER-OF-SUBSCRIPTS-EXPECTED (ARRAY-#-DIMS ARRAY))))

(DEFMETHOD (REPORT ARRAY-WRONG-NUMBER-OF-SUBSCRIPTS) (STREAM)
  (FORMAT STREAM
	  "~S was given ~S subscripts, ~S, for ~S, a ~S-dimensional array."
    FUNCTION NUMBER-OF-SUBSCRIPTS-GIVEN SUBSCRIPTS-GIVEN ARRAY NUMBER-OF-SUBSCRIPTS-EXPECTED))

(DEFFLAVOR NUMBER-ARRAY-NOT-ALLOWED
	((FUNCTION NIL))
	(BAD-ARRAY-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT NUMBER-ARRAY-NOT-ALLOWED) (STREAM)
  (FORMAT STREAM
	  "The array ~S~@[, which was given to ~S,~] is not allowed to be a ~A array.~%"
	  ARRAY
	  FUNCTION
	  (SELECTQ (SI:ARRAY-TYPE ARRAY)
	    ((ART-STRING ART-FAT-STRING) "character")
	    (ART-BOOLEAN "boolean")
	    (OTHERWISE "numeric"))))

(DEFFLAVOR SUBSCRIPT-OUT-OF-BOUNDS
	((FUNCTION NIL)
	 (OBJECT NIL)
	 SUBSCRIPT-USED
	 (SUBSCRIPT-LIMIT NIL)
	 (STORING-NAMES NIL))
	(ERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES FUNCTION OBJECT)
  (:INIT-KEYWORDS :SUBSCRIPTS-USED :SUBSCRIPTS-LIMIT))

(DEFMETHOD (MAKE-INSTANCE SUBSCRIPT-OUT-OF-BOUNDS) (&KEY SUBSCRIPTS-USED SUBSCRIPTS-LIMIT
						    &ALLOW-OTHER-KEYS)
  (AND SUBSCRIPTS-USED
       (SETQ SUBSCRIPT-USED SUBSCRIPTS-USED))
  (AND SUBSCRIPTS-LIMIT
       (SETQ SUBSCRIPT-LIMIT SUBSCRIPTS-LIMIT)))

(DEFMETHOD (:SUBSCRIPT-USED SUBSCRIPT-OUT-OF-BOUNDS) ()
  (IF (ATOM SUBSCRIPT-USED) SUBSCRIPT-USED
      (LOOP AS RESULT = 1 THEN (* RESULT TEM)
	    FOR TEM IN SUBSCRIPT-USED
	    FINALLY (RETURN RESULT))))

(DEFMETHOD (:SUBSCRIPTS-USED SUBSCRIPT-OUT-OF-BOUNDS) ()
  (IF (LISTP SUBSCRIPT-USED) SUBSCRIPT-USED (LIST SUBSCRIPT-USED)))

(DEFMETHOD (:SUBSCRIPT-LIMIT SUBSCRIPT-OUT-OF-BOUNDS) ()
  (IF (ATOM SUBSCRIPT-LIMIT) SUBSCRIPT-LIMIT
      (LOOP AS RESULT = 1 THEN (* RESULT TEM)
	    FOR TEM IN SUBSCRIPT-LIMIT
	    FINALLY (RETURN RESULT))))

(DEFMETHOD (:SUBSCRIPTS-LIMIT SUBSCRIPT-OUT-OF-BOUNDS) ()
  (IF (LISTP SUBSCRIPT-LIMIT) SUBSCRIPT-LIMIT (LIST SUBSCRIPT-LIMIT)))

(DEFMETHOD (REPORT SUBSCRIPT-OUT-OF-BOUNDS) (STREAM)
  (FORMAT STREAM
	  (IF (MINUSP (SEND SELF ':SUBSCRIPT-USED))
	      "The subscript~@[ into ~S~], ~{~S~^, ~}, was negative~*~@[ in ~S~]~%"
    "The subscript~@[ into ~S~], ~{~S~^, ~}, was beyond the length, ~{~S~^, ~}~@[, in ~S~]~%")
	  OBJECT (SEND SELF ':SUBSCRIPTS-USED)
	  (SEND SELF ':SUBSCRIPTS-LIMIT) (FUNCTION-NAME FUNCTION)))

;; Doesn't make sense to give a new subscript if the array is zero-length.
(DEFWRAPPER (MAKE-INSTANCE SUBSCRIPT-OUT-OF-BOUNDS) (IGNORE BODY)
  `(PROGN ,BODY
	  (COND ((EQL (SEND SELF ':SUBSCRIPT-LIMIT) 0)
		 (SETQ PROCEED-TYPES (REMQ ':NEW-SUBSCRIPT
					   (REMQ ':STORE-NEW-SUBSCRIPT PROCEED-TYPES))))
		((NOT (LOOP FOR X IN STORING-NAMES THEREIS X))
		 (SETQ PROCEED-TYPES (REMQ ':STORE-NEW-SUBSCRIPT PROCEED-TYPES))))))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE SUBSCRIPT-OUT-OF-BOUNDS :NEW-SUBSCRIPT) (STREAM)
  (LET ((NSUBS (IF (ATOM SUBSCRIPT-LIMIT) 1 (LENGTH SUBSCRIPT-LIMIT))))
    (IF (= NSUBS 1)
	(FORMAT STREAM "Ask for a different subscript")
	(FORMAT STREAM "Ask for new subscripts"))))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE SUBSCRIPT-OUT-OF-BOUNDS :STORE-NEW-SUBSCRIPT) (STREAM)
  (LET ((NSUBS (IF (ATOM SUBSCRIPT-LIMIT) 1 (LENGTH SUBSCRIPT-LIMIT))))
    (IF (= NSUBS 1)
	(FORMAT STREAM "Ask for a different subscript storing back")
	(FORMAT STREAM "Ask for new subscripts storing back")))
  (LOOP FOR L ON STORING-NAMES
	WITH COMMA-P = NIL
	WHEN (CAR L)
	DO (IF COMMA-P
	       (PRINC (IF (LOOP FOR LL ON (CDR L) THEREIS (CAR LL))
			  ", " ", and ")
		      STREAM)
	       (PRINC " into " STREAM)
	       (SETQ COMMA-P T))
	   (PRINC (CAR L) STREAM)))

(DEFMETHOD (PROCEED SUBSCRIPT-OUT-OF-BOUNDS :NEW-SUBSCRIPT) (&REST SUBS)
  (AND (NULL SUBS)
       (LET ((NSUBS (IF (ATOM SUBSCRIPT-LIMIT) 1 (LENGTH SUBSCRIPT-LIMIT))))
	 (SETQ SUBS (LOOP FOR I FROM 1 TO NSUBS
			  COLLECT (PROMPT-AND-READ ':NUMBER
						   "~:[~:R s~;S~]ubscript to use instead: "
						   (= NSUBS 1) I)))))
  (VALUES-LIST (CONS ':NEW-SUBSCRIPT SUBS)))

(DEFMETHOD (PROCEED SUBSCRIPT-OUT-OF-BOUNDS :STORE-NEW-SUBSCRIPT) (&REST SUBS)
  (AND (NULL SUBS)
       (LET ((NSUBS (IF (ATOM SUBSCRIPT-LIMIT) 1 (LENGTH SUBSCRIPT-LIMIT))))
	 (SETQ SUBS (LOOP FOR I FROM 1 TO NSUBS
			  FOR NAME IN STORING-NAMES
			  COLLECT (PROMPT-AND-READ ':NUMBER
  "~:[~:R s~;~*S~]ubscript to ~:[use instead~;store back into ~:*~A~]: "
						   (= NSUBS 1) I NAME)))))
  (VALUES-LIST (CONS ':STORE-NEW-SUBSCRIPT SUBS)))

(DEFFLAVOR BAD-ARRAY-TYPE
	((FUNCTION NIL)
	 TYPE)
	(ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT BAD-ARRAY-TYPE) (STREAM)
  (FORMAT STREAM "The array type, ~S, was invalid~@[ in ~S~]."
	  TYPE FUNCTION))

(DEFFLAVOR WRONG-STACK-GROUP-STATE
	((FUNCTION NIL)
	 STACK-GROUP)
	(ERROR)
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT WRONG-STACK-GROUP-STATE) (STREAM)
  (FORMAT STREAM "The state of the stack group, ~S~@[, given to ~S,~] was invalid.~%"
	  STACK-GROUP FUNCTION))

(DEFFLAVOR DRAW-OFF-END-OF-SCREEN
	(FUNCTION)
	(ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT DRAW-OFF-END-OF-SCREEN) (STREAM)
  (FORMAT STREAM "The function ~S attempted to erase past the end of the screen.~%"
	  FUNCTION))

(DEFFLAVOR DRAW-ON-UNPREPARED-SHEET
	(SHEET)
	(ERROR NO-ACTION-MIXIN)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT DRAW-ON-UNPREPARED-SHEET) (STREAM)
  (FORMAT STREAM "There was an attempt to draw on the sheet ~S without preparing it first.~%"
	  SHEET))

(DEFFLAVOR BITBLT-DESTINATION-TOO-SMALL () (ERROR))

(DEFMETHOD (REPORT BITBLT-DESTINATION-TOO-SMALL) (STREAM)
  (FORMAT STREAM "The destination of a BITBLT was too small."))

(DEFFLAVOR BITBLT-ARRAY-FRACTIONAL-WORD-WIDTH (ARRAY)
	   (ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT BITBLT-ARRAY-FRACTIONAL-WORD-WIDTH) (STREAM)
  (MULTIPLE-VALUE-BIND (WIDTH IGNORE SPANNING-WIDTH)
      (DECODE-RASTER-ARRAY ARRAY)
    (FORMAT STREAM "The array passed to BITBLT, ~S, 
does not have a ~:[width (second dimension)~;spanning width~] which is a multiple of ~D.
BITBLT requires that the rows of an array be word-aligned."
	    ARRAY
	    ( WIDTH SPANNING-WIDTH)
	    (PROGN
	      #+3600 (CDR (ASSQ (ARRAY-TYPE ARRAY) ARRAY-ELEMENTS-PER-Q))
	      #+IMACH (ROT 1 (ARRAY-BYTE-PACKING ARRAY))))))

(DEFFLAVOR WRITE-IN-READ-ONLY
	(ADDRESS FORMAT-STRING PLACE TYPE)
	(ERROR)
  (:GETTABLE-INSTANCE-VARIABLES ADDRESS FORMAT-STRING)
  (:INITABLE-INSTANCE-VARIABLES ADDRESS FORMAT-STRING))

(DEFMETHOD (MAKE-INSTANCE WRITE-IN-READ-ONLY) (&REST IGNORE)
  (LET ((SAFE-ADDRESS (WITHOUT-INTERRUPTS
			(LET ((REGION (%REGION-NUMBER ADDRESS)))
			  (WHEN REGION
			    (SELECTOR (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION)) =
			      ((%REGION-SPACE-NEW
				%REGION-SPACE-COPY
				%REGION-SPACE-WEAK)
			       (%MAKE-POINTER DTP-LOCATIVE ADDRESS))))))))
    (WHEN SAFE-ADDRESS
      (MULTIPLE-VALUE-BIND (TENTATIVE-PLACE TENTATIVE-TYPE)
	  (COMPILER:DISASSEMBLE-DECODE-LOCATIVE SAFE-ADDRESS)
	(CL:CASE TENTATIVE-TYPE
	  ((:FUNCTION :VARIABLE)
	   (SETQ PLACE TENTATIVE-PLACE
		 TYPE TENTATIVE-TYPE)))))))

(DEFMETHOD (REPORT WRITE-IN-READ-ONLY) (STREAM)
  (IF (VARIABLE-BOUNDP PLACE)
      (FORMAT STREAM "There was an attempt to set the write-protected ~A ~S"
	      (STRING-DOWNCASE TYPE) PLACE)
      (FORMAT STREAM FORMAT-STRING ADDRESS)))

(DEFFLAVOR CONDITIONS:STORAGE-CONDITION () (DEBUGGER-CONDITION)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR PDL-OVERFLOW (PDL-NAME) (CONDITIONS:STORAGE-CONDITION)	;Not ERRORP
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT PDL-OVERFLOW) (STREAM)
  (FORMAT STREAM "The ~A stack overflowed." PDL-NAME))

(DEFMETHOD (PROCEED PDL-OVERFLOW :GROW-PDL) ()
  "Continue with a larger stack."
  ':GROW-PDL)

(DEFFLAVOR CONTROL-STACK-GROWN () (CONDITION))

(DEFMETHOD (REPORT CONTROL-STACK-GROWN) (STREAM)
  (FORMAT STREAM "The control stack was grown."))

(DEFFLAVOR AREA-OVERFLOW (AREA) (DEBUGGER-CONDITION)
  (:GETTABLE-INSTANCE-VARIABLES AREA)
  (:INITABLE-INSTANCE-VARIABLES (:AREA-NUMBER AREA)))

(DEFMETHOD (REPORT AREA-OVERFLOW) (STREAM)
  (LET ((NAME (AREA-NAME AREA))
	(MAX-SIZE (AREA-MAXIMUM-SIZE AREA)))
    (IF (MINUSP MAX-SIZE)
	;; Slight kludge here to give (make-list -1) a better error message on the LM-2.
	(FORMAT STREAM "Attempt to allocate a negative amount of space in ~A." NAME)
	(FORMAT STREAM "Allocation in ~A exceeded the maximum of ~D. words.~%"
		NAME MAX-SIZE))))

;Maybe this method belongs in some other file
(DEFMETHOD (PROCEED AREA-OVERFLOW :NO-ACTION) ()
  "Give the area one more region and proceed with allocation"
  ':NO-ACTION)

(DEFFLAVOR REGION-TABLE-OVERFLOW () (DEBUGGER-CONDITION))	;Not ERRORP

(DEFMETHOD (REPORT REGION-TABLE-OVERFLOW) (STREAM)
  (FORMAT STREAM "Unable to create a new region because the region tables are full.~%"))

(DEFFLAVOR SI:RESOURCE-ERROR () (ERROR)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR SI:RESOURCE-EXTRA-DEALLOCATION
	(OBJECT RESOURCE)
	(NO-ACTION-MIXIN SI:RESOURCE-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT SI:RESOURCE-EXTRA-DEALLOCATION) (STREAM)
  (FORMAT STREAM "~A was already deallocated from resource ~S." OBJECT RESOURCE))

(DEFFLAVOR SI:RESOURCE-OBJECT-NOT-FOUND
	(OBJECT RESOURCE)
	(NO-ACTION-MIXIN SI:RESOURCE-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT SI:RESOURCE-OBJECT-NOT-FOUND) (STREAM)
  (FORMAT STREAM "~A not found in resource ~S." OBJECT RESOURCE))


(DEFFLAVOR CONDITIONS:CONTROL-ERROR () (ERROR))

(DEFFLAVOR THROW-TAG-NOT-SEEN
	(TAG VALUES)
	(CONDITIONS:CONTROL-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT THROW-TAG-NOT-SEEN) (STREAM)
  (FORMAT STREAM "There was no pending CATCH for the tag ~S.~%" TAG)
  (COND ((NULL VALUES)
	 (FORMAT STREAM "No values were being throw~%"))
	((NULL (CDR VALUES))
	 (FORMAT STREAM "The value being thrown was ~S~%"
		 (CAR VALUES)))
	(T
	 (FORMAT STREAM "The values being thrown were ~{~S~^, ~}" VALUES))))

(DEFMETHOD (PROCEED THROW-TAG-NOT-SEEN :NEW-TAG)
	   (&OPTIONAL (NEW-TAG (PROMPT-AND-READ ':EVAL-FORM
					"Form to evaluate and use as the tag to throw to: ")))
  "Use a different tag instead"
  (VALUES ':NEW-TAG NEW-TAG))

(DEFFLAVOR INSTANCE-VARIABLE-ZERO-REFERENCED () (ERROR))

(DEFMETHOD (REPORT INSTANCE-VARIABLE-ZERO-REFERENCED) (STREAM)
  (FORMAT STREAM "Referenced instance variable 0.
You are probably using a deleted instance variable.~%"))

(DEFFLAVOR ZERO-ARGS-TO-SELECT-METHOD (SELECT-METHOD) (ERROR)
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT ZERO-ARGS-TO-SELECT-METHOD) (STREAM)
  (FORMAT STREAM "~S was applied to no arguments.~%" SELECT-METHOD))

(DEFFLAVOR TOO-FEW-ARGUMENTS (FUNCTION NARGS ARGUMENT-LIST) (REPLACEMENT-VALUES-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT TOO-FEW-ARGUMENTS) (STREAM)
  (FORMAT STREAM "The function ~S was called with too few arguments."
	  (FUNCTION-NAME FUNCTION)))

#+3600
(DEFMETHOD (PROCEED TOO-FEW-ARGUMENTS :ADDITIONAL-ARGUMENTS) (&OPTIONAL ADDITIONAL-ARGS)
  "Supply the missing arguments."
  (AND (NULL ADDITIONAL-ARGS)
       (SETQ ADDITIONAL-ARGS (LET* ((REAL-FUNCTION (OR (SI:VALID-FUNCTION-DEFINITION FUNCTION)
						       FUNCTION))
				    (ARGS-INFO (ARGS-INFO REAL-FUNCTION))
				    (MIN-ARGS (LDB %%ARG-DESC-MIN-ARGS ARGS-INFO))
				    (MAX-ARGS (LDB %%ARG-DESC-MAX-ARGS ARGS-INFO))
				    (REST-P (LDB-TEST %%ARG-DESC-REST-ARG ARGS-INFO))
				    (REST-NAME (AND REST-P (REST-ARG-NAME REAL-FUNCTION))))
			       (LOOP FOR ARG-NO FROM NARGS BELOW (IF REST-P 177777 MAX-ARGS)
				     COLLECT (MULTIPLE-VALUE-BIND (VALUE END-FLAG)
						 (PROMPT-AND-READ
						   (IF ( ARG-NO MIN-ARGS)
						       ':EVAL-FORM-OR-END
						       ':EVAL-FORM)
  "Value for arg #~D~:[~@[ (~A)~]~; (in rest arg~@[ ~A~])~]~
   ~:[~; (Or ” to end arguments)~]: "
  ARG-NO ( ARG-NO MAX-ARGS)
  (IF ( ARG-NO MAX-ARGS) REST-NAME (ARG-NAME REAL-FUNCTION ARG-NO))
  ( ARG-NO MIN-ARGS))
					       (AND END-FLAG (LOOP-FINISH))
					       VALUE)))))
  (VALUES ':ADDITIONAL-ARGUMENTS ADDITIONAL-ARGS))

(DEFFLAVOR TOO-MANY-ARGUMENTS (FUNCTION NARGS ARGUMENT-LIST) (REPLACEMENT-VALUES-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT TOO-MANY-ARGUMENTS) (STREAM)
  (FORMAT STREAM "The function ~S was called with too many arguments."
	  (FUNCTION-NAME FUNCTION)))

(DEFVAR TOO-MANY-ARGS-Y-N-OR-P-FQUERY-CHOICES
  '(:CHOICES (((T "Yes.") #/Y #/T #\SP)
	      ((NIL "No.") #/N #\RUBOUT)
	      ((:PROCEED "Proceed with call.") #/P #\END))
    :HELP-FUNCTION TOO-MANY-ARGS-FQUERY-HELP))

(DEFVAR TOO-MANY-ARGS-Y-OR-N-FQUERY-CHOICES
  '(:CHOICES (((T "Yes.") #/Y #/T #\SP)
	      ((NIL "No.") #/N #\RUBOUT))
    :HELP-FUNCTION TOO-MANY-ARGS-FQUERY-HELP))

(DEFUN TOO-MANY-ARGS-FQUERY-HELP (S)
  (DECLARE (SPECIAL *MUST-DROP-P* *P-ALLOWED-P*))
  (FORMAT S "~&Y to drop this and be asked about optional arguments.
~:[N to skip dropping this and resume the call.
~;N to abort proceeding this way.~]
~:[~;P to drop this and resume the call.
~]"
	  *MUST-DROP-P* *P-ALLOWED-P*))

#+3600
(DEFMETHOD (PROCEED TOO-MANY-ARGUMENTS :FEWER-ARGUMENTS) (&OPTIONAL NEW-NARGS)
  "Drop some extraneous arguments."
  (WHEN (NULL NEW-NARGS)
    (SETQ NEW-NARGS (LET* ((REAL-FUNCTION (OR (SI:VALID-FUNCTION-DEFINITION FUNCTION)
					      FUNCTION))
			   (ARGS-INFO (ARGS-INFO REAL-FUNCTION))
			   (MIN-ARGS (LDB %%ARG-DESC-MIN-ARGS ARGS-INFO))
			   (MAX-ARGS (LDB %%ARG-DESC-MAX-ARGS ARGS-INFO)))
		      (LOOP FOR N DOWNFROM MAX-ARGS TO MIN-ARGS
			    DO (LET ((*MUST-DROP-P* (= N MAX-ARGS))	;Dropping all extra
				     (*P-ALLOWED-P* ( N MIN-ARGS)))	;P too
				 (DECLARE (SPECIAL *MUST-DROP-P* *P-ALLOWED-P*))
				 (SELECTQ (LET ((CHOICES
						  (IF *P-ALLOWED-P*
						      TOO-MANY-ARGS-Y-N-OR-P-FQUERY-CHOICES
						      TOO-MANY-ARGS-Y-OR-N-FQUERY-CHOICES)))
					    (IF *MUST-DROP-P*
						(FQUERY CHOICES 
							"Drop extra ~D argument~:P? "
							(- NARGS N))
						(FQUERY CHOICES
							"Also drop optional arg #~D~@[ (~A) ~]"
							N (ARG-NAME REAL-FUNCTION N))))
				   ((T) )	;Ok, go on
				   ((NIL) (RETURN (IF *MUST-DROP-P* NIL (1+ N))))
				   ((:PROCEED) (DECF N) (LOOP-FINISH))))
			       ;; It's probably a bug that N has the wrong value here
			    FINALLY (RETURN (1+ N))))))
  (AND NEW-NARGS (VALUES ':FEWER-ARGUMENTS NEW-NARGS)))

(DEFFLAVOR WRONG-TYPE-ARGUMENT
	((ARG-NAMES '("argument"))
	 (STORING-NAMES NIL))
	(ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (ERROR-CLASSIFICATION WRONG-TYPE-ARGUMENT) () "argument")

(DEFWRAPPER (MAKE-INSTANCE WRONG-TYPE-ARGUMENT) (IGNORE BODY)
  `(PROGN ,BODY
	  (UNLESS (LOOP FOR X IN STORING-NAMES THEREIS X)
	    (SETQ PROCEED-TYPES (REMQ ':STORE-ARGUMENT-VALUE PROCEED-TYPES)))))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE WRONG-TYPE-ARGUMENT :ARGUMENT-VALUE) (STREAM)
  (FORMAT STREAM "Supply replacement argument~P" (LENGTH ARG-NAMES)))

(DEFMETHOD (PROCEED WRONG-TYPE-ARGUMENT :ARGUMENT-VALUE) (&REST NEW-ARGS)
  (IF NEW-ARGS
      (OR (= (LENGTH NEW-ARGS) (LENGTH ARG-NAMES))
	  (FERROR "Wrong number of new arguments given"))
      (SETQ NEW-ARGS (LOOP FOR NAME IN ARG-NAMES
			   COLLECT (PROMPT-AND-READ ':EVAL-FORM
				     "Form to evaluate and use as replacement ~A:~%" NAME))))
  (VALUES-LIST (CONS ':ARGUMENT-VALUE NEW-ARGS)))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE WRONG-TYPE-ARGUMENT :STORE-ARGUMENT-VALUE) (STREAM)
  (FORMAT STREAM "Supply replacement argument~P, storing back" (LENGTH ARG-NAMES))
  (LOOP FOR L ON STORING-NAMES
	WITH COMMA-P = NIL
	WHEN (CAR L)
	DO (IF COMMA-P
	       (PRINC (IF (LOOP FOR LL ON (CDR L) THEREIS (CAR LL))
			  ", " ", and ")
		      STREAM)
	       (PRINC " into " STREAM)
	       (SETQ COMMA-P T))
	   (PRINC (CAR L) STREAM)))

(DEFMETHOD (PROCEED WRONG-TYPE-ARGUMENT :STORE-ARGUMENT-VALUE) (&REST NEW-ARGS)
  (IF NEW-ARGS
      (OR (= (LENGTH NEW-ARGS) (LENGTH ARG-NAMES))
	  (FERROR "Wrong number of new arguments given"))
      (SETQ NEW-ARGS (LOOP FOR NAME IN ARG-NAMES
			   AND STORE-NAME IN STORING-NAMES
			   COLLECT (PROMPT-AND-READ ':EVAL-FORM
  "Form to evaluate and use as replacement ~A~@[ and store back into ~A~]:~%"
				     NAME STORE-NAME))))
  (VALUES-LIST (CONS ':STORE-ARGUMENT-VALUE NEW-ARGS)))

(DEFFLAVOR BASIC-CHECK-ARG
	(FUNCTION
	 OLD-VALUE
	 ARG-NAME
	 ARG-NUMBER)
	(WRONG-TYPE-ARGUMENT)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (MAKE-INSTANCE BASIC-CHECK-ARG) (&REST IGNORE)
  (SETQ ARG-NAMES (LIST (FORMAT NIL "value for ~A" ARG-NAME))))

(DEFMETHOD (REPORT BASIC-CHECK-ARG) (STREAM)
  (SEND STREAM ':STRING-OUT "The ")
  (COND (ARG-NUMBER (FORMAT:ENGLISH-ORDINAL-PRINT ARG-NUMBER STREAM)
		    (SEND STREAM ':TYO #\SP)))
  (SEND STREAM ':STRING-OUT "argument ")
  (COND (ARG-NUMBER (SEND STREAM ':TYO #/()))
  (PRINC ARG-NAME STREAM)
  (COND (ARG-NUMBER (SEND STREAM ':TYO #/))))
  (FORMAT STREAM " to ~S, ~S, was of the wrong type.~%The function expected "
	  (FUNCTION-NAME FUNCTION) OLD-VALUE)
  (SEND SELF ':PRINT-DESCRIPTION STREAM)
  (PRINC "." STREAM))

;;; This is the WRONG-TYPE-ARGUMENT signalled by CHECK-ARG-1
(DEFFLAVOR CHECK-ARG (DESCRIPTION) (BASIC-CHECK-ARG)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:PRINT-DESCRIPTION CHECK-ARG) (STREAM)
  (PRINC DESCRIPTION STREAM))

(DEFFLAVOR ARGUMENT-TYPECASE (TYPES) (BASIC-CHECK-ARG)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:PRINT-DESCRIPTION ARGUMENT-TYPECASE) (STREAM)
  (PRINT-TYPE-TEST-DESCRIPTION TYPES STREAM))

(DEFUN PRINT-TYPE-TEST-DESCRIPTION (LIST STREAM)
  ;; Replace low-level data type names with high-level, conceptual data type names.
  ;; When a conceptual data type is implemented by more than one low-level data type,
  ;; only use the conceptual data type name if all the low-level types appear in the list.
  ;; For example, symbols in the 3600 are implemented by dtp-symbol and dtp-nil.
  (LOOP FOR REST ON LIST
	AS TYPE = (CAR REST) DO
    (WHEN (MEMQ TYPE *DATA-TYPES*)
      (LET ((CTYPE (CDR (ASSQ (SYMEVAL TYPE) TYPEP-ALIST))))
	(WHEN (AND CTYPE
		   (LOOP FOR (TYP . CTYP) IN TYPEP-ALIST
			 DO (SETQ TYP (NTH TYP *DATA-TYPES*))
			 WHEN (EQ CTYP CTYPE)
			   ALWAYS (MEMQ TYP REST)))
	  ;; I know this conses, too bad.
	  ;; It also changes the order of the types, if that matters.
	  (SETQ LIST (CONS CTYPE
			   (REM-IF #'(LAMBDA (TYPE)
				       (AND (MEMQ TYPE *DATA-TYPES*)
					    (EQ (CDR (ASSQ (SYMEVAL TYPE) TYPEP-ALIST))
						CTYPE)))
				   LIST)))))))
  ;; Print a description of each type being checked for
  (LOOP FOR (TYPE . REST) ON LIST WITH COMMA-P = NIL DO
    ;; If there is more than one phrase, connect them with "or".
    ;; If there are three or more phrases, put commas between them.
    (IF COMMA-P
	(SEND STREAM :STRING-OUT (COND (REST ", ")
				       ((CDR LIST) ", or ")
				       (T " or ")))
	(SETQ COMMA-P T))
    (LET ((NAME (GET TYPE 'SI:TYPE-NAME)))
      (IF NAME (SEND STREAM :STRING-OUT NAME)
	  (SEND STREAM :STRING-OUT "a ")
	  (PRIN1 TYPE STREAM)))))

(DEFFLAVOR REPLACEMENT-VALUES-MIXIN () ()
  (:REQUIRED-FLAVORS CONDITION)
  (:DOCUMENTATION :MIXIN "Provides a :VALUES proceed type.
   Proceeding substitutes some values instead of evaluating the erring form."))

(DEFMETHOD (PROCEED REPLACEMENT-VALUES-MIXIN :VALUES)
	   (&OPTIONAL (VALUES-LIST NIL VALUES-SUPPLIED-P))
  "Supply value(s) to use as the result of the erroneous form"
  (OR VALUES-SUPPLIED-P
      (SETQ VALUES-LIST (LOOP WITH (VALUE END-FLAG)
			      FOR N FROM 1
			      DO (MULTIPLE-VALUE (VALUE END-FLAG)
				   (PROMPT-AND-READ ':EVAL-FORM-OR-END
						    "The ~:R value, or ”: ~28T" N))
			      UNTIL END-FLAG
			      COLLECT VALUE)))
  (VALUES ':VALUES VALUES-LIST))

(DEFFLAVOR CONDITIONS:PROGRAM-ERROR () (ERROR)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR INVALID-FORM (FORM) (REPLACEMENT-VALUES-MIXIN CONDITIONS:PROGRAM-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT INVALID-FORM) (STREAM)
  (FORMAT STREAM "~S is not a valid form to be evaluated" FORM))

(DEFFLAVOR INVALID-FUNCTION (FUNCTION) (CONDITIONS:CONTROL-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT INVALID-FUNCTION) (STREAM)
  (COND ((AND (LISTP FUNCTION) (MEMQ (FIRST FUNCTION) '(SPECIAL MACRO)))
	 (FORMAT STREAM  "You cannot use a ~:[special form~;macro~] as a function: ~S"
		 (OR (EQ (FIRST FUNCTION) 'MACRO) (NULL (THIRD FUNCTION)))
		 FUNCTION))
	(T (FORMAT STREAM
		   (TYPECASE FUNCTION
		     (:SYMBOL "The symbol ~S has an invalid function definition")
		     (:NUMBER "The number, ~S, was called as a function")
		     (:ARRAY (IF (= (ARRAY-#-DIMS FUNCTION) 1)
				 "The array, ~S, is not a valid function except when
given a valid subscript as its argument."
				 "The array, ~S, is not a valid function except when
given valid subscripts as its arguments."))	     
		     (OTHERWISE "The object ~S is not a valid function"))
		   FUNCTION))))

(DEFMETHOD (PROCEED INVALID-FUNCTION :NEW-FUNCTION)
	   (&OPTIONAL (NEW-FUNCTION (PROMPT-AND-READ ':EVAL-FORM
				      "Form to evaluate and use as the function instead:~%")))
  "Supply a function to use instead."
  (VALUES ':NEW-FUNCTION NEW-FUNCTION))

;;This is also CONDITIONS:CONTROL-ERROR due to INVALID-FUNCTION,
;;but that's permitted by ANSI CL. -kmp 12-Oct-89
(DEFFLAVOR INVALID-LAMBDA-LIST () (INVALID-FUNCTION CONDITIONS:PROGRAM-ERROR))

(DEFMETHOD (REPORT INVALID-LAMBDA-LIST) (STREAM)
  (FORMAT STREAM "The function ~S has an invalid lambda list" FUNCTION))

(DEFFLAVOR UNDEFINED-KEYWORD-ARGUMENT (KEYWORD VALUE)
	   (NO-ACTION-MIXIN CONDITIONS:CONTROL-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT UNDEFINED-KEYWORD-ARGUMENT) (STREAM)
  (FORMAT STREAM "The keyword argument ~S is unrecognized." KEYWORD))

(DEFMETHOD (PROCEED UNDEFINED-KEYWORD-ARGUMENT :NEW-KEYWORD)
	   (&OPTIONAL (NEW-KEYWORD (PROMPT-AND-READ ':EVAL-FORM
				     "Form to evaluate and use instead of ~D ? "
				     KEYWORD)))
  "Supply a keyword to use instead"
  (VALUES ':NEW-KEYWORD NEW-KEYWORD))

(DEFFLAVOR UNCLAIMED-MESSAGE (OBJECT MESSAGE ARGUMENTS)
	   (WRONG-TYPE-ARGUMENT CONDITIONS:CONTROL-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:DEFAULT-INIT-PLIST :ARG-NAMES '("instance")))

(DEFFLAVOR UNCLAIMED-SUB-MESSAGE () ()
  (:REQUIRED-FLAVORS UNCLAIMED-MESSAGE)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (REPORT UNCLAIMED-MESSAGE) (STREAM)
  (LET ((GF MESSAGE))
    ;; Distinguish generic-function call from message send, generate suitable report.
    ;; If it was a message send, rather than a generic function call, set GF to the
    ;; generic-function object corresponding to the message, and make sure it's right.
    (COND ((AND (TYPEP MESSAGE ':GENERIC-FUNCTION)
		(EQ MESSAGE (GENERIC-FUNCTION-SELECTOR MESSAGE)))
	   (FORMAT STREAM "The generic function ~S was applied to the argument~P ~{~S~^, ~}.
The ~:[argument~;first argument~] was not of the correct type.
The function is implemented by "
		   (FUNCTION-NAME MESSAGE) (1+ (LENGTH ARGUMENTS))
		   (CONS OBJECT ARGUMENTS) ARGUMENTS))
	  (T
	   (FORMAT STREAM "The object ~S received a ~S message, which went unclaimed.
The rest of the message was ~:S.~%"
		   OBJECT MESSAGE ARGUMENTS)
	   (COND ((TYPEP MESSAGE ':GENERIC-FUNCTION)
		  (IF (GENERIC-FUNCTION-COMPATIBLE-MESSAGE MESSAGE)
		      (FORMAT STREAM
			"The generic function ~S has the (:COMPATIBLE-MESSAGE ~S) option,
thus, unlike typical generic functions, it performs its generic dispatch
to the methods by SENDing the ~:*~S message.
The object ~S has no meaning as a message."
			(FUNCTION-NAME MESSAGE) (GENERIC-FUNCTION-SELECTOR MESSAGE)
			MESSAGE)
		      (FORMAT STREAM
			"The object ~S is part of the implementation of the ~S message.
It has no meaning as a message."
			MESSAGE (GENERIC-FUNCTION-SELECTOR MESSAGE) MESSAGE))
		  (RETURN-FROM REPORT NIL))
		 ((NOT (AND (SYMBOLP MESSAGE) (CL:TYPEP MESSAGE 'GENERIC-FUNCTION-NAME)))
		  (FORMAT STREAM "~S is not a valid message symbol." MESSAGE)
		  (RETURN-FROM REPORT NIL))
		 ((NULL (SETQ GF (FLAVOR:FIND-GENERIC-FUNCTION MESSAGE NIL)))
		  (PRINC "The message is handled by no flavors." STREAM)
		  (RETURN-FROM REPORT NIL))
		 ((NOT (OR (EQ MESSAGE (GENERIC-FUNCTION-SELECTOR GF))
			   (EQ MESSAGE (GENERIC-FUNCTION-COMPATIBLE-MESSAGE GF))))
		  (FORMAT STREAM "~S is the name of a generic function, not a message."
			  MESSAGE)
		  (RETURN-FROM REPORT NIL))
		 (T (PRINC "The message is handled by " STREAM)))))
    (LET ((N (LENGTH (GENERIC-FUNCTION-FLAVORS GF))))
      (COND ((= N 0) (PRINC "no flavors." STREAM))
	    ((= N 1) (FORMAT STREAM "the flavor ~S." (FIRST (GENERIC-FUNCTION-FLAVORS GF))))
	    (T
	     (PRINC "the flavors " stream)
	     (LET ((L (SORT (COPYLIST (GENERIC-FUNCTION-FLAVORS GF)) #'ALPHALESSP)))
	       (IF (< N 7)			;Show at most six flavors
		   (FORMAT-TEXTUAL-LIST L #'PRIN1 :STREAM STREAM :FILLED T
						  :CONJUNCTION "and")
		   (FORMAT-TEXTUAL-LIST (NCONC (FIRSTN 4 L) '(NIL))
					#'(LAMBDA (FLAVOR STREAM)
					    (IF FLAVOR (PRIN1 FLAVOR STREAM)
						(FORMAT STREAM "and ~:D others" (- N 4))))
					:STREAM STREAM :FILLED T))
	       (PRINC "." stream))))))) 

(DEFMETHOD (MAKE-INSTANCE UNCLAIMED-MESSAGE :AFTER) (&REST IGNORE)
  (UNLESS (TYPEP SELF 'UNCLAIMED-SUB-MESSAGE)
    (SETQ PROCEED-TYPES (REMQ (IF (AND (TYPEP MESSAGE ':GENERIC-FUNCTION)
				       (EQ MESSAGE (GENERIC-FUNCTION-SELECTOR MESSAGE)))
				  ':NEW-MESSAGE ':NEW-FUNCTION)
			      PROCEED-TYPES))))

(DEFMETHOD (PROCEED UNCLAIMED-MESSAGE :NEW-MESSAGE)
	   (&OPTIONAL (NEW-MESSAGE NIL NEW-MESSAGE-P))
  "Supply a different message name"
  (UNLESS NEW-MESSAGE-P
    (LET ((TEM (AND MESSAGE (SYMBOLP MESSAGE) (GET-HANDLER-FOR OBJECT MESSAGE))))
      (IF (AND TEM
	       (NOT (TYPEP SELF 'UNCLAIMED-SUB-MESSAGE))
	       (FQUERY NIL "~S is now handled by ~S.
Do you want to invoke the newly-defined handler? " MESSAGE (FUNCTION-NAME TEM)))
	  (SETQ NEW-MESSAGE MESSAGE)
	  (SETQ NEW-MESSAGE (PROMPT-AND-READ ':EXPRESSION
					     "Message name to use instead of ~S:~%"
					     MESSAGE)))))
  (VALUES ':NEW-MESSAGE NEW-MESSAGE))

(DEFMETHOD (PROCEED UNCLAIMED-MESSAGE :NEW-FUNCTION)
	   (&OPTIONAL (NEW-FUNCTION NIL NEW-FUNCTION-P))
  "Supply a different generic function"
  (UNLESS NEW-FUNCTION-P
    (LET ((TEM (AND MESSAGE (TYPEP MESSAGE ':GENERIC-FUNCTION)
		    (GET-HANDLER-FOR OBJECT (FUNCTION-NAME MESSAGE)))))
      (SETQ NEW-FUNCTION
	    (IF (AND TEM
		     (NOT (TYPEP SELF 'UNCLAIMED-SUB-MESSAGE))
		     (FQUERY NIL "~S is now handled by ~S.~@
				Do you want to invoke the newly-defined handler? "
			     (FUNCTION-NAME MESSAGE) (FUNCTION-NAME TEM)))
		MESSAGE
		(FLAVOR:FIND-GENERIC-FUNCTION
		  (ACCEPT '((GENERIC-FUNCTION-NAME :DEFINED T))
			  :PROMPT (LAMBDA (STREAM IGNORE)
				    (FORMAT STREAM "Generic function to use instead of ~S"
					    (FUNCTION-NAME MESSAGE)))
			  :DEFAULT (FUNCTION-NAME MESSAGE)))))))
  (VALUES ':NEW-FUNCTION NEW-FUNCTION))

(DEFFLAVOR CONDITIONS:PRINT-NOT-READABLE (OBJECT) (NO-ACTION-MIXIN ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:READABLE-INSTANCE-VARIABLES (CONDITIONS:PRINT-NOT-READABLE-OBJECT OBJECT)))

(DEFMETHOD (REPORT CONDITIONS:PRINT-NOT-READABLE) (STREAM)
  (FORMAT STREAM "Can't print ~S readably." OBJECT))

(DEFFLAVOR PRINT-NOT-READABLE () (CONDITIONS:PRINT-NOT-READABLE))

(DEFGENERIC CONDITIONS:STREAM-ERROR-STREAM (CONDITIONS:STREAM-ERROR))

(DEFFLAVOR CONDITIONS:STREAM-ERROR ((STREAM NIL)) (ERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:READABLE-INSTANCE-VARIABLES
    (CONDITIONS:STREAM-ERROR-STREAM STREAM)))

(DEFMETHOD (ERROR-CLASSIFICATION CONDITIONS:STREAM-ERROR) () "I//O")

(DEFMETHOD (DBG:REPORT CONDITIONS:STREAM-ERROR) (STREAM)
  (FORMAT STREAM "An error occurred in I//O to ~A." STREAM))

(DEFFLAVOR CONDITIONS:END-OF-FILE () (CONDITIONS:STREAM-ERROR))

(DEFMETHOD (DBG:REPORT CONDITIONS:END-OF-FILE) (STREAM)
  (FORMAT STREAM "End of file~@[ on ~A~]." STREAM))

(DEFFLAVOR END-OF-FILE
	((STREAM NIL)
	 (FORMAT-STRING NIL))
	(CONDITIONS:END-OF-FILE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

;; Allow format-string to be initialized to T or something, for compatibility.
(DEFMETHOD (MAKE-INSTANCE END-OF-FILE) (&REST IGNORE)
  (OR (STRINGP FORMAT-STRING)
      (SETQ FORMAT-STRING "End of file~@[ for ~S~].")))

(DEFMETHOD (REPORT END-OF-FILE) (S)
  (FORMAT S FORMAT-STRING STREAM))

(DEFFLAVOR END-OF-RECORD-FILE
	((STREAM NIL))
	(ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT END-OF-RECORD-FILE) (S)
  (FORMAT S "End of record file for ~S." STREAM))

(DEFFLAVOR STREAM-CLOSED
	(ATTEMPT STREAM)
	(ERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :ATTEMPT :STREAM))

(DEFMETHOD (REPORT STREAM-CLOSED) (REPORT-STREAM)
  (FORMAT REPORT-STREAM "Attempt to ~A ~A, which has already been closed."
	  ATTEMPT STREAM))

(DEFFLAVOR CONDITIONS:PARSE-ERROR () (ERROR))

(DEFFLAVOR PARSE-ERROR ((CORRECT-INPUT T)) (CONDITIONS:PARSE-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFFLAVOR PARSE-FERROR () (FERROR PARSE-ERROR))

(DEFFLAVOR CONDITIONS:READER-ERROR () (CONDITIONS:PARSE-ERROR CONDITIONS:STREAM-ERROR))

(DEFFLAVOR READ-ERROR
	((LOCATION NIL)
	 (STREAM NIL))
	(PARSE-ERROR CONDITIONS:READER-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (MAKE-INSTANCE READ-ERROR) (&REST IGNORE)
  (WHEN (AND (NULL LOCATION) STREAM)
    (SETQ LOCATION (SEND-IF-HANDLES STREAM :READ-LOCATION))))

(DEFMETHOD (PROCEED READ-ERROR :REPLACEMENT-SYMBOL)
	   (&OPTIONAL (NEW-SYMBOL
			(PROMPT-AND-READ :SYMBOL
					 "Symbol to use instead [note package is ~A]: "
					 PACKAGE)))
   "Supply a different symbol"
   (VALUES ':REPLACEMENT-SYMBOL NEW-SYMBOL))

(DEFFLAVOR READ-FERROR () (FERROR READ-ERROR))

(DEFFLAVOR READ-END-OF-FILE () (END-OF-FILE READ-ERROR)
  (:DEFAULT-INIT-PLIST :CORRECT-INPUT NIL))

(DEFFLAVOR READ-LIST-END-OF-FILE (LIST) (READ-END-OF-FILE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

;The END-OF-FILE report has already printed the stream name, since the reader
;does not supply a format string (neither to :TYI nor to ERROR).
(DEFMETHOD (REPORT READ-LIST-END-OF-FILE :AFTER) (S)
  (FORMAT S "~&End of file occurred while reading ~:S" LIST))

(DEFFLAVOR READ-STRING-END-OF-FILE (STRING) (READ-END-OF-FILE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT READ-STRING-END-OF-FILE :AFTER) (S)
  (FORMAT S "~&End of file occurred while reading ~:S" STRING))

(DEFFLAVOR READ-MULTIPLE-ESCAPE-END-OF-FILE (STRING) (READ-END-OF-FILE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT READ-MULTIPLE-ESCAPE-END-OF-FILE :AFTER) (S)
  (FORMAT S "~&End of file occurred while reading symbol |~A|" STRING))

(DEFFLAVOR READ-LISP-SYNTAX-ERROR (STREAM) (READ-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:INIT-KEYWORDS :ORIGINAL-CONDITION)
  (:REQUIRED-INIT-KEYWORDS :ORIGINAL-CONDITION))

(DEFMETHOD (REPORT READ-LISP-SYNTAX-ERROR :AFTER) (S)
  (FORMAT S "~%While reading from ~S" STREAM))

(DEFFLAVOR READ-LISP-SYNTAX-NOT-FOUND () (LISP-SYNTAX-NOT-FOUND READ-LISP-SYNTAX-ERROR))

(DEFMETHOD (MAKE-INSTANCE READ-LISP-SYNTAX-NOT-FOUND) (&KEY ORIGINAL-CONDITION
						       &ALLOW-OTHER-KEYS)
  (SETQ SI:NAME (SEND ORIGINAL-CONDITION :NAME)))

(DEFFLAVOR READ-PACKAGE-ERROR (STREAM) (READ-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:INIT-KEYWORDS :ORIGINAL-CONDITION)
  (:REQUIRED-INIT-KEYWORDS :ORIGINAL-CONDITION))

(DEFMETHOD (REPORT READ-PACKAGE-ERROR :AFTER) (S)
  (FORMAT S "~&While reading from ~S" STREAM))

(DEFFLAVOR READ-PACKAGE-NOT-FOUND () (PACKAGE-NOT-FOUND READ-PACKAGE-ERROR))

(DEFMETHOD (MAKE-INSTANCE READ-PACKAGE-NOT-FOUND) (&KEY ORIGINAL-CONDITION &ALLOW-OTHER-KEYS)
  (SETQ SI:NAME (SEND ORIGINAL-CONDITION :NAME)
	SI:RELATIVE-TO (SEND ORIGINAL-CONDITION :RELATIVE-TO)
	SI:RELATIVE-TO-SYNTAX (SEND ORIGINAL-CONDITION :RELATIVE-TO-SYNTAX)))

(DEFFLAVOR READ-EXTERNAL-SYMBOL-NOT-FOUND () (EXTERNAL-SYMBOL-NOT-FOUND READ-PACKAGE-ERROR))
  
(DEFMETHOD (MAKE-INSTANCE READ-EXTERNAL-SYMBOL-NOT-FOUND) (&KEY ORIGINAL-CONDITION
							   &ALLOW-OTHER-KEYS)
  (SETQ SI:STRING (SEND ORIGINAL-CONDITION ':STRING)
	CL:PACKAGE (SEND ORIGINAL-CONDITION ':PACKAGE)))

(DEFFLAVOR READ-PACKAGE-LOCKED () (PACKAGE-LOCKED READ-PACKAGE-ERROR))

(DEFMETHOD (MAKE-INSTANCE READ-PACKAGE-LOCKED) (&KEY ORIGINAL-CONDITION &ALLOW-OTHER-KEYS)
  (SETQ SI:SYMBOL (SEND ORIGINAL-CONDITION ':SYMBOL)
	CL:PACKAGE (SEND ORIGINAL-CONDITION ':PACKAGE)))

(DEFFLAVOR READ-NAME-CONFLICT-IN-EXPORT-FROM-LOCKED-PACKAGE ()
	(NAME-CONFLICT-IN-EXPORT-FROM-LOCKED-PACKAGE READ-PACKAGE-ERROR))

(DEFMETHOD (MAKE-INSTANCE READ-NAME-CONFLICT-IN-EXPORT-FROM-LOCKED-PACKAGE)
	   (&KEY ORIGINAL-CONDITION &ALLOW-OTHER-KEYS)
  (SETQ SI:SYMBOL (SEND ORIGINAL-CONDITION ':SYMBOL)
	CL:PACKAGE (SEND ORIGINAL-CONDITION ':PACKAGE)
	SI:CONFLICTS (SEND ORIGINAL-CONDITION ':CONFLICTS)))

(DEFFLAVOR READ-PREMATURE-END-OF-SYMBOL
	(SHORT-SYMBOL
	  ORIGINAL-STRING)
	(READ-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT READ-PREMATURE-END-OF-SYMBOL) (S)
  (FORMAT S "Stopped reading before the end of the string,~
                  ~%in reading symbol ~S from string ~S"
	  SHORT-SYMBOL ORIGINAL-STRING))

(DEFFLAVOR ENCAPSULATED-READ-ERROR
	(ORIGINAL-CONDITION STREAM)
	(READ-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT ENCAPSULATED-READ-ERROR) (S)
  (SEND ORIGINAL-CONDITION ':REPORT S)
  (FORMAT S "~&While reading from ~S" STREAM))

;; Disk Errors only have one proceed type -- :RETRY-DISK-OPERATION
;; which is a funny name for :NO-ACTION
(DEFFLAVOR DISK-ERROR
	(COMMAND-NAME
	 UNIT
	 CYLINDER
	 SURFACE
	 SECTION
	 (DISK-STATUS NIL))
	(ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT DISK-ERROR) (STREAM)
  (FORMAT STREAM "Disk ~A error unit ~D, cyl ~D., surf ~D., sec ~D.~@[,~%  status ~A~]"
	  COMMAND-NAME UNIT CYLINDER SURFACE SECTION DISK-STATUS))

#||
;;; This can't possible work.
(DEFMETHOD (PROCEED DISK-ERROR :RETRY-DISK-OPERATION) ()
  "Retry the disk operation"
  ':RETRY-DISK-OPERATION)
||#

(DEFFLAVOR DISK-COMPLETION-ERROR
	(FINAL-CYLINDER
	 FINAL-SURFACE
	 FINAL-SECTION)
	(DISK-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT DISK-COMPLETION-ERROR :AFTER) (STREAM)
  (FORMAT STREAM "~%Failed to complete operation, final disk address should be ~D, ~D, ~D."
	  FINAL-CYLINDER FINAL-SURFACE FINAL-SECTION))

(DEFFLAVOR DISK-READ-COMPARE-ERROR () (DISK-ERROR))

(DEFMETHOD (REPORT DISK-READ-COMPARE-ERROR) (STREAM)
  (FORMAT STREAM 
	  "Disk error during read//compare after ~A unit ~D, cyl ~D., surf ~D., sec ~D.~@[,
  status ~A~]"
	  COMMAND-NAME UNIT CYLINDER SURFACE SECTION DISK-STATUS))

(DEFFLAVOR DISK-NOT-MOUNTED-ERROR
	   ()
           (DISK-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT DISK-NOT-MOUNTED-ERROR) (STREAM)
  (FORMAT STREAM "Disk unit ~D is not mounted" UNIT))

(DEFMETHOD (PROCEED DISK-NOT-MOUNTED-ERROR :MOUNT-DISK-UNIT) ()
  "Mount the disk unit"
  ':MOUNT-DISK-UNIT)


(DEFFLAVOR CONDITIONS:WARNING () (CONDITION)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR WARNING () (NO-ACTION-MIXIN CONDITIONS:WARNING))

(DEFMETHOD (CONDITION-TYPE WARNING) () "Warning")

(DEFFLAVOR CONDITIONS:SIMPLE-WARNING () (CONDITIONS:SIMPLE-CONDITION WARNING))

(DEFFLAVOR DEFAULT-WARNING
	(FORMAT-STRING FORMAT-ARGS)
	(WARNING)
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-INIT-KEYWORDS :FORMAT-STRING :FORMAT-ARGS)
  (:DOCUMENTATION :CONDITION "Signalled by the WARN function"))

(DEFMETHOD (REPORT DEFAULT-WARNING) (STREAM)
  (LEXPR-FUNCALL #'FORMAT STREAM FORMAT-STRING FORMAT-ARGS))

(DEFFLAVOR CONDITIONS:STYLE-WARNING () (WARNING)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR DEFAULT-STYLE-WARNING () (CONDITIONS:STYLE-WARNING DEFAULT-WARNING))

(COMPILE-FLAVOR-METHODS DEFAULT-STYLE-WARNING)

(DEFFLAVOR REDEFINITION
	(DEFINITION-TYPE
	 NAME
	 NEW-PATHNAME
	 OLD-PATHNAME
	 (MUNGING-PRIVATE-PATCH NIL))
	(WARNING)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT REDEFINITION) (STREAM)
  (FORMAT STREAM "~A ~S, being redefined~@[ by file ~A~],
was previously defined by file ~A~:[~; (a private patch file)~]."
	  (SI:DEFINITION-TYPE-NAME DEFINITION-TYPE)
	  NAME
	  NEW-PATHNAME
	  OLD-PATHNAME
	  MUNGING-PRIVATE-PATCH))

(DEFMETHOD (PROCEED REDEFINITION :PROCEED) ()
  "Don't warn in the future for this pair of files"
  ':PROCEED)

(DEFMETHOD (PROCEED REDEFINITION :INHIBIT-DEFINITION) ()
  "Inhibit this definition from taking place"
  ':INHIBIT-DEFINITION)

(DEFFLAVOR FQUERY
	(OPTIONS FORMAT-STRING FORMAT-ARGS)
	(CONDITION)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT FQUERY) (STREAM)
  (SEND STREAM ':STRING-OUT "FQUERY:  ")
  (LEXPR-FUNCALL #'FORMAT STREAM FORMAT-STRING FORMAT-ARGS))

(DEFMETHOD (PROCEED FQUERY :CHOICE)
	   (&OPTIONAL (CHOICE (PROMPT-AND-READ ':EVAL-FORM
				"Form to evaluate and use as the choice in FQUERY: ")))
  "Supply a choice to return from FQUERY"
  (VALUES ':CHOICE CHOICE))



;;; Breaks are not errors (they are invisible to errset, etc.)  but they accept some of the
;;; same messages.
(DEFFLAVOR BREAK () (NO-ACTION-MIXIN DEBUGGER-CONDITION)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (CONDITION-TYPE BREAK) () "Break")
(DEFMETHOD (CLEAR-INPUT-P BREAK) () NIL)
(DEFMETHOD (SHOW-RESTART-HANDLER-P BREAK) (IGNORE) T)

;;;

(DEFFLAVOR SYNCHRONOUS-BREAK () (NULL-REPORT BREAK))

(DEFMETHOD (CURRENT-AND-INNERMOST-FRAMES-FOR-DEBUGGER SYNCHRONOUS-BREAK) (FRAME)
  (VALUES FRAME FRAME))

(COMPILE-FLAVOR-METHODS SYNCHRONOUS-BREAK)

;;;

(DEFFLAVOR ASYNCHRONOUS-BREAK () (NULL-REPORT BREAK))

(COMPILE-FLAVOR-METHODS ASYNCHRONOUS-BREAK)



(DEFFLAVOR BINARY-FILE-OBSOLETE-VERSION
	((PATHNAME NIL))
	(ERROR NO-ACTION-MIXIN)
  (:INITABLE-INSTANCE-VARIABLES))

(DEFFLAVOR BINARY-FILE-OBSOLETE-VERSION-3 ()
	   (BINARY-FILE-OBSOLETE-VERSION))

(DEFMETHOD (REPORT BINARY-FILE-OBSOLETE-VERSION-3) (STREAM)
  (FORMAT STREAM
	  "Bin file~@[ ~A~] format version is 3, which indicates a Release 6 file.~@
	   It is unlikely that this file will work after Release 6.~@
	   Among other things, characters are now first class objects and ~@
	   multidimensional arrays are now stored in row major order.~%~@
	   [Resume] to continue loading anyway."
	  PATHNAME))

(DEFFLAVOR INLINE-CONSTANT-VALUE-CHANGED
	(FUNCTION
	 CONSTANT
	 OLD-VALUE)
	(NO-ACTION-MIXIN ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT INLINE-CONSTANT-VALUE-CHANGED) (STREAM)
  (FORMAT STREAM
	  "The function ~S contains an inline reference to the~@
	   constant ~S, but ~:[that symbol is no longer defined as a constant~;~
			       the value was different in the compilation environment~].~@
	   ~4@TThe inlined constant value was ~S.~@
	   ~4@T~:[It is currently unbound.~;Its current value is ~S.~]"
	  FUNCTION CONSTANT (GET CONSTANT 'DEFCONSTANT) OLD-VALUE
	  (BOUNDP CONSTANT)
	  (AND (BOUNDP CONSTANT) (SYMEVAL CONSTANT))))

(DEFMETHOD (PROCEED INLINE-CONSTANT-VALUE-CHANGED :INHIBIT-FUTURE-WARNINGS) ()
  :INHIBIT-FUTURE-WARNINGS)

(DEFMETHOD (DOCUMENT-PROCEED-TYPE INLINE-CONSTANT-VALUE-CHANGED :INHIBIT-FUTURE-WARNINGS)
	   (STREAM)
  (FORMAT STREAM
	  "Proceed and don't complain about future miscompiled references to ~S"
	  CONSTANT))

(DEFFLAVOR LINKED-FUNCTION-REDEFINITION
	(FUNCTION-SPEC OLD-FUNCTION NEW-FUNCTION)
	(ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT LINKED-FUNCTION-REDEFINITION) (STREAM)
  (IF (VARIABLE-BOUNDP NEW-FUNCTION)
      (FORMAT STREAM
	      "Redefining the function ~S to be ~S,~@
	       but there are direct calls to its current definition, ~S."
	      FUNCTION-SPEC NEW-FUNCTION OLD-FUNCTION)
      (FORMAT STREAM
	      "Undefining the function ~S,~@
	       but there are direct calls to its current definition, ~S."
	      FUNCTION-SPEC OLD-FUNCTION)))

(DEFMETHOD (PROCEED LINKED-FUNCTION-REDEFINITION :UNLINK-OLD-FUNCTION) ()
  :UNLINK-OLD-FUNCTION)

(DEFMETHOD (DOCUMENT-PROCEED-TYPE LINKED-FUNCTION-REDEFINITION :UNLINK-OLD-FUNCTION) (STREAM)
  (FORMAT STREAM "Unlink references to ~S, then allow redefinition to proceed."
	  FUNCTION-SPEC))

(DEFMETHOD (PROCEED LINKED-FUNCTION-REDEFINITION :UNLINK-OLD-FUNCTION-USING-WHO-CALLS) ()
  :UNLINK-OLD-FUNCTION-USING-WHO-CALLS)

(DEFMETHOD (DOCUMENT-PROCEED-TYPE LINKED-FUNCTION-REDEFINITION
				  :UNLINK-OLD-FUNCTION-USING-WHO-CALLS) (STREAM)
  (FORMAT STREAM
	  "Use Who-Calls to unlink references to ~S, then allow redefinition to proceed."
	  FUNCTION-SPEC))

(DEFMETHOD (PROCEED LINKED-FUNCTION-REDEFINITION :UNLINK-ALL) ()
  "Unlink references to all functions, then allow this redefinition to proceed."
  :UNLINK-ALL)

(DEFMETHOD (PROCEED LINKED-FUNCTION-REDEFINITION :NO-ACTION) ()
  "Allow the redefinition to proceed.
The redefinition will not take effect for direct calls until they are unlinked."
  :NO-ACTION)

(COMPILE-FLAVOR-METHODS LINKED-FUNCTION-REDEFINITION)


;; From SYSCOND
(COMPILE-FLAVOR-METHODS UNDEFINED-FUNCTION UNDEFINED-FUNCTION-SPEC UNKNOWN-SETF-REFERENCE
			#|UNKNOWN-LOCF-REFERENCE|#
			PAGE-FAULT-ON-UNALLOCATED-VMA
			;; L-machine-specific floating-point exceptions.
			;; These are needed here because some of the
			;; below are based on them.  They can't go in
			;; LCOMETH since it gets loaded later.
			FLOAT-DIVIDE-BY-ZERO
			FLOAT-DIVIDE-ZERO-BY-ZERO
			FLOAT-INVALID-OPERATION
			FLOAT-INVALID-COMPARE-OPERATION
			FLOAT-INEXACT-RESULT
			;; Common conditions
			NEGATIVE-SQRT NON-POSITIVE-LOG ZERO-TO-NEGATIVE-POWER
			CHECK-ARG ARGUMENT-TYPECASE
			INVALID-FORM INVALID-FUNCTION INVALID-LAMBDA-LIST
			TOO-FEW-ARGUMENTS TOO-MANY-ARGUMENTS
			PDL-OVERFLOW CONTROL-STACK-GROWN
			UNDEFINED-KEYWORD-ARGUMENT UNCLAIMED-MESSAGE
			PRINT-NOT-READABLE END-OF-FILE STREAM-CLOSED PARSE-FERROR READ-FERROR
			READ-END-OF-FILE READ-LIST-END-OF-FILE READ-STRING-END-OF-FILE
			READ-MULTIPLE-ESCAPE-END-OF-FILE
			READ-PREMATURE-END-OF-SYMBOL ENCAPSULATED-READ-ERROR
			DISK-ERROR DISK-COMPLETION-ERROR DISK-READ-COMPARE-ERROR
			DISK-NOT-MOUNTED-ERROR
			ABORT DEFAULT-WARNING REDEFINITION FQUERY
			;; Lesser common conditions
			ARRAY-WRONG-NUMBER-OF-DIMENSIONS SUBSCRIPT-OUT-OF-BOUNDS
			)

;; These can be signalled by the scheduler during initialization
(COMPILE-FLAVOR-METHODS SI:RESOURCE-EXTRA-DEALLOCATION SI:RESOURCE-OBJECT-NOT-FOUND)

;; From SYSCOND again
(COMPILE-FLAVOR-METHODS BINARY-FILE-OBSOLETE-VERSION-3 INLINE-CONSTANT-VALUE-CHANGED)

;On the A machine only the traps are instantiated
(COMPILE-FLAVOR-METHODS AREA-OVERFLOW REGION-TABLE-OVERFLOW
			FLOATING-EXPONENT-UNDERFLOW FLOATING-EXPONENT-OVERFLOW)

;On the A machine these were signalled by microcode
(COMPILE-FLAVOR-METHODS THROW-TAG-NOT-SEEN)

;; For ANSI Common Lisp
(COMPILE-FLAVOR-METHODS CONDITIONS:SIMPLE-WARNING CONDITIONS:PRINT-NOT-READABLE)
