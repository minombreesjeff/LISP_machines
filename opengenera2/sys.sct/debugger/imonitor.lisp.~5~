;;; -*- Mode: LISP; Package: Debugger; Base: 8; Lowercase: T -*- 

;;; Debugger variable monitor
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (:FIX :BOLD :VERY-LARGE) "BIGFNTB")               Variable Monitor

0This provides a facility to monitor when a location is referenced or modified.
Currently, it only places you into the debugger; in the future you will be
able to do a wide variety of things.  When you are placed in the debugger,
you are given a variety of proceed options, to let you do things like
proceed, use a different value, skip a modification, etc.  In addition, you
are given special commands to turn on or off monitoring, either for all references
to this location or to specific types of references.

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")monitor-symbol-value (3 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Variable 0&key3 (read nil) (write t) locate makunbound boundp
0Takes a symbol naming a variable, and traps references to the variable.

3Read0      3  0-- If T, trap all instructions reading the value of this variable.
3Write0     3  0-- If T, trap all instructions modifying the value of this variable.
	    -- If :CHANGE, trap all instructions which actually change the value.
3Locate0    3  0-- If T, trap all LOCF's of this variable.  Actually only works on those
            3  0 that do FOLLOW-CELL-FORWARDING.  This isn't too important, because any
            3  0 attempt to actually read or modify the cell via these means will hit one
            3  0 of the other traps.
3Makunbound0  -- If T, trap all instructions making this location unbound.
3Boundp0      -- If T, trap all instructions checking for this location being bound.

Currently, the only meaningful values are T and NIL, meaning enter the debugger
and don't trap this condition, respectively.  Other things are possible, including
running arbitrary functions, but the interface to that has not yet been built.

2monitor-variable3 access-form 0&key3 (read nil) (write t) locate makunbound boundp
0This takes a LOCFable form and monitors references to the location so named.
3Read0, 3write0, etc are like for 2monitor-variable0.

2monitor-instance-variable3 instance variable-name 
0                          &key3 (read nil) (write t) locate makunbound boundp
0Monitor references to a specific instance variable of a specific instance.

2unmonitor-location 3locative
0Stop monitoring the location indicated by 3locative0.

2unmonitor 0&optional 3name
0This isn't well defined yet.  It takes the name of a location.
For variables, this is just the symbol.  Probably there should
be an 2unmonitorf0 and 2unmonitor-instance-variable0.  If given
no arguments, it will turn off all monitors.

Probably it can't take a name, just a location, and a menu-based
interface is needed for doing this.

(4 0 (NIL 0) (:FIX :BOLD :LARGE) "MEDFNTB")         ***       LIMITATIONS        ***

0This is implemented by storing a special invisible pointer into the
memory location being monitored.  Therefore, it cannot be used to
monitor any location which is understood at a low enough level.
This includes, for example, header-words of things like symbols,
flavors, arrays, etc (2dtp-header-i0 and 2dtp-header-p0).

Calls are not implemented yet.  (Monitoring a function cell and
calling the function from compiled code will trap, but you'll just
get an error, not any nice proceed options).

I don't know what happens with AREF of packed arrays.  (Moon left a
"to do" note that I haven't investigated).
|#

;;--- AREF of a packed array doesn't work
;;--- Also, looking at the microcode, locative trapping looks like a hoax.
;;---  (Moon says probably only things which do FOLLOW-CELL-FORWARDING actually
;;---  trigger the trap)
;;--- Things that look at the CDR-code (like GETF-INTERNAL) don't completely win -
;;---  looking at the CDR-code shouldn't really count as a monitor trap
;;--- :CONDITION and :ACTION would be nice


2;;--- Remove these when the real one works

0(defun monitor-nyi ()
  (format t "~&The variable monitor has not been implemented yet on the I-machine"))  

(cp:define-command (com-monitor-variable :command-table "Tracing"
					 :provide-output-destination-keyword nil)
    ((locations '((cl:sequence symbol))
		:prompt "variables to monitor"
		:default nil)
     &key
     (cell '((cl:member :value-cell :function-cell))
	   :default :value-cell
	   :documentation "Function cell or value cell")
     (read 'scl:boolean
	   :default nil
	   :mentioned-default t
	   :documentation "Trap on reads")
     (write '((token-or-type (:change) scl:boolean))
	    :default-type 'scl:boolean
	    :default t
	    :documentation "Trap on writes")
     (locf 'scl:boolean
	   :default nil
	   :mentioned-default t
	   :documentation "Trap on locf's")
     (makunbound 'scl:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "Trap on makunbound's")
     (boundp 'scl:boolean
	     :default nil
	     :mentioned-default t
	     :documentation "Trap on boundp's"))
  (loop for location in locations doing
    (setq location (selectq cell
		     (:value-cell (value-cell-location location))
		     (:function-cell (function-cell-location location))))
    (monitor-location location :read read :write write :locate locf
		      :makunbound makunbound :boundp boundp)))

(cp:define-command (com-unmonitor-variable :command-table "Tracing"
					   :provide-output-destination-keyword nil)
    ((locations '((or null ((cl:sequence symbol))))
		:prompt "variables to unmonitor or <return> for all"
		:default nil
		:default-type 'null)
     &key
     (cell '((cl:member :value-cell :function-cell))
	   :default :value-cell
	   :documentation "Function cell or value cell"))
  (cond ((null locations)
	 (unmonitor nil t))
	(t
	 (loop for location in locations doing
	   (setq location (selectq cell
			    (:value-cell (value-cell-location location))
			    (:function-cell (function-cell-location location))))
	   (unmonitor-location location)))))

(cp:define-command (com-show-monitored-locations :command-table "Tracing"
						 :provide-output-destination-keyword nil)
    ()
  (monitor-nyi))

(defun monitor-symbol-value (variable &rest keywords)
  (declare (arglist variable &key (read nil) (write t) locate makunbound boundp))
  (lexpr-funcall #'monitor-location (value-cell-location variable)
		 :name `("~S" ,variable)
		 keywords))

(defun monitor-location (location &key (read nil) (write t) name
			 locate
			 (makunbound (or (not (null write)) (eq write 'dbg)))
			 (boundp (or (eq read t) (eq read 'dbg))))
  (ignore location read write name locate makunbound boundp)
  (monitor-nyi))

(defun monitor-instance-variable (instance variable-name &rest keywords)
  (declare (arglist instance variable-name
	    &key (read nil) (write t) locate makunbound boundp))
  (lexpr-funcall #'monitor-location (locate-in-instance instance variable-name)
		 :name `("the ~S instance variable of ~S" ,variable-name ,instance)
		 keywords))

(defmacro monitor-variable (access-form &rest keywords)
  (declare (arglist access-form
	    &key (read nil) (write t) locate makunbound boundp))
  `(monitor-location (locf ,access-form) :name ',`("~S" ,access-form) ,@keywords))

(defun unmonitor-location (location)
  (ignore location)
  (monitor-nyi))

(defun unmonitor (&optional name log)
  (ignore name log)
  (monitor-nyi))


#||

;;; Basic data structures

(defvar *monitored-locations* nil)

;; Sometimes read handlers should not signal "unbound" errors (for instance,
;; the BIND handlers).  This tells them not to.
(defvar *inhibit-signalling-unbounds* nil)

(defconst *unbound-marker* "Unbound marker")

(defflavor monitor-descriptor
	(name
	 value-cell
	 instruction-handler)
	()
  :writable-instance-variables
  :initable-instance-variables
  (:locatable-instance-variables value-cell))

(defmethod (sys:print-self monitor-descriptor) (stream &rest ignore)
  (format stream "#<MONITOR-DESCRIPTOR ~O for ~?>"
	  (%pointer self)
	  (car name) (cdr name)))

(defun location-monitored-p (location)
  (let ((*printing-monitor-message* t))
    (= (%p-data-type (follow-cell-forwarding location t)) dtp-monitor-forward)))

(defmethod (monitor-descriptor-value-cell-or-unbound monitor-descriptor) ()
  (if (variable-boundp value-cell)
      value-cell
    *unbound-marker*))

(defmethod (emulate-instruction monitor-descriptor) (uop vma mon-trap-frame)
  (funcall (aref instruction-handler uop) vma self mon-trap-frame))

(defmethod (read-function monitor-descriptor) (value vma frame)
  (null-read-function value vma frame))

(defmethod (write-function monitor-descriptor) (old-value new-value vma frame)
  (null-write-function old-value new-value vma frame))

(defmethod (locate-function monitor-descriptor) (vma frame)
  (null-locate-function vma frame))

(defmethod (location-boundp-function monitor-descriptor) (vma frame)
  (null-location-boundp-function vma frame))

(defmethod (location-makunbound-function monitor-descriptor) (vma frame name)
  (null-location-makunbound-function vma frame name))

(defflavor debugger-monitor-descriptor
	((state '(:write)))
	(monitor-descriptor)
  (:constructor make-debugger-monitor-descriptor (name instruction-handler state))
  :readable-instance-variables)

(defmethod (:toggle-state debugger-monitor-descriptor) (state-keyword)
  (setq state
	(if (memq state-keyword state)
	    (delq state-keyword state)
	  (cons state-keyword state))))

(defmethod (read-function debugger-monitor-descriptor) (value vma frame)
  (if (memq :read state)
      (debugger-read-function value vma frame)
    (null-read-function value vma frame))) 

(defmethod (write-function debugger-monitor-descriptor) (old-value new-value vma frame)
  (cond ((memq :write state)
	 (debugger-write-function old-value new-value vma frame))
	((and (memq :change state) (neq old-value new-value))
	 (debugger-write-function old-value new-value vma frame))
	(t
	 (null-write-function old-value new-value vma frame))))

(defmethod (locate-function debugger-monitor-descriptor) (vma frame)
  (if (memq :locate state)
      (debugger-locate-function vma frame)
    (null-locate-function vma frame)))

(defmethod (location-boundp-function debugger-monitor-descriptor) (vma frame)
  (if (memq :boundp state)
      (debugger-boundp-function vma frame)
    (null-location-boundp-function vma frame)))

(defmethod (location-makunbound-function debugger-monitor-descriptor) (vma frame name)
  (if (memq :location-makunbound state)
      (debugger-makunbound-function vma frame name)
    (null-location-makunbound-function vma frame name)))

(defmethod (show-monitor-state debugger-monitor-descriptor) (vma)
  (format t "~&The ~\vma\ is being monitored for " vma)
  (formatting-textual-list (t :filled t :finally " and ")
    (when (memq :read state)
      (formatting-textual-list-element () (princ "reads")))
    (when (memq :write state)
      (formatting-textual-list-element () (princ "writes")))
    (when (memq :change state)
      (formatting-textual-list-element () (princ "changes")))
    (when (memq :locate state)
      (formatting-textual-list-element () (princ "locf's")))
    (when (memq :boundp state)
      (formatting-textual-list-element () (princ "makunbound's")))
    (when (memq :makunbound state)
      (formatting-textual-list-element () (princ "boundp's")))))


;; Don't use LOCATION-MONITORED-P here, it can cause a recursive trap (the
;; location will have already had any forwarding pointers chased anyway).
(defun location-monitor-descriptor (location &optional (error-p t))
  (if (= (%p-data-type location) dtp-monitor-forward)
      (%find-structure-header (%p-contents-as-locative location))
    (when error-p
      (ferror "~S contains a ~S; a DTP-MONITOR-FORWARD was expected"
	location (nth (%p-data-type location) *data-types*)))
    nil))

;; Don't use LOCATION-MONITORED-P here, it can cause a recursive trap
(defun store-monitor-descriptor (location monitor-descriptor)
  (without-interrupts
    (si:%p-copy-q (if (= (%p-data-type location) dtp-monitor-forward)
		      (%p-contents-as-locative location)
		    location)
		  (locf (monitor-descriptor-value-cell monitor-descriptor)))
    (%p-store-cdr-type-and-pointer
      location
      (%p-cdr-code location) dtp-monitor-forward
      (locf (monitor-descriptor-value-cell monitor-descriptor))))
  monitor-descriptor)

(eval-when (compile load eval)
  (cl:defsetf location-monitor-descriptor store-monitor-descriptor))


;;; Instruction Simulators
;;; These only have to complete the execution of an instruction that has
;;; trapped for a monitor-forward.  For the instructions that only reference
;;; memory once, and then return immediately, this is easy.

(defvar *instruction-handler* (make-array 2000 :initial-value nil)) 

;; Dispatch to handler for the operation trying to be performed on the monitored cell
;;--- In the handlers, PREV-FRAME should be called FAULT-FRAME, PREV-TOP should be
;;--- FAULT-SP, PREV-PC should be FAULT-PC
(defun monitor-trap (vma)
  (declare (safeguarded-function disable-reference-validation))
  (let* ((mon-trap-frame (%stack-frame-pointer))
	 (inst (pc-instruction (decrement-pc (frame-return-pc mon-trap-frame))))
	 (uop (ilc:get-universal-opcode inst)))
    (emulate-instruction (location-monitor-descriptor vma)
			 uop vma mon-trap-frame)))

;; Make the microcode know about monitor traps
(defun enable-monitor-trap (mt)
  (destructuring-bind (nil start nil &rest names)
		      (assq 'sys:microcode-constants si:*magic-locations*)
    (loop for index from 0
	  for (type name) in names
	  when (and (eq type :function)
		    (eq name 'monitor-trap))
	    do (%p-store-contents (%pointer-plus start index) mt))))

(add-initialization "Enable monitor traps"
   '(enable-monitor-trap #'monitor-trap)
   '(:now))

;; For diagnosing handlers which have been forgotten entirely
(defun truly-undefined-instruction-handler (vma monitor mon-trap-frame)
  (undefined-instruction-handler vma monitor mon-trap-frame))

;; For diagnosing handlers which have not yet been implemented
(defun unimplemented-instruction-handler (vma monitor mon-trap-frame)
  (undefined-instruction-handler vma monitor mon-trap-frame))

;; Instructions which shouldn't take monitor traps, but somehow have
(defun undefined-instruction-handler (vma monitor mon-trap-frame)
  (ignore monitor)
  (signal 'unimplemented-monitor-trap :vma vma :frame mon-trap-frame
				      :proceed-types '(:no-action)))

;; An instruction that reads from memory and doesn't take any stack arguments
(defun read-instruction-handler (vma monitor mon-trap-frame)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (read-function monitor (monitor-descriptor-value-cell-or-unbound monitor)
		 vma mon-trap-frame))

;; An instruction that reads from memory with one stack argument
(defun read1-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 1)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (read-function monitor (monitor-descriptor-value-cell-or-unbound monitor)
		 vma mon-trap-frame))

;; An instruction that reads from memory with two stack arguments
(defun read2-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 2)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (read-function monitor (monitor-descriptor-value-cell-or-unbound monitor)
		 vma mon-trap-frame))

;; An instruction that reads from memory with three stack arguments
(defun read3-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 3)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (read-function monitor (monitor-descriptor-value-cell-or-unbound monitor)
		 vma mon-trap-frame))

(defun boundp-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 1)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (location-boundp-function monitor vma mon-trap-frame))

(defun pop-instruction-handler (vma monitor mon-trap-frame)
  (write-instruction-handler vma (location-contents (frame-previous-top mon-trap-frame))
			     monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 1))

(defun movem-instruction-handler (vma monitor mon-trap-frame)
  (write-instruction-handler vma (location-contents (frame-previous-top mon-trap-frame))
			     monitor mon-trap-frame))

(defun store2-instruction-handler (vma monitor mon-trap-frame)
  (write-instruction-handler vma (location-contents (frame-previous-top mon-trap-frame))
			     monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 2))

(defun xstore2-instruction-handler (vma monitor mon-trap-frame)
  (write-instruction-handler vma (%p-contents-offset (frame-previous-top mon-trap-frame) -1)
			     monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 2))

(defun xstore3-instruction-handler (vma monitor mon-trap-frame)
  (write-instruction-handler vma (%p-contents-offset (frame-previous-top mon-trap-frame) -2)
			     monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 3))

(defun xstore4-instruction-handler (vma monitor mon-trap-frame)
  (write-instruction-handler vma (%p-contents-offset (frame-previous-top mon-trap-frame) -3)
			     monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 4))

(defun length-internal-instruction-handler (vma monitor mon-trap-frame)
  (length-handler-internal vma monitor mon-trap-frame nil))

(defun cl-length-internal-instruction-handler (vma monitor mon-trap-frame)
  (length-handler-internal vma monitor mon-trap-frame t))

(defun length-handler-internal (vma monitor mon-trap-frame cl-length-p)
  (when (and cl-length-p
	     (let ((header (%find-structure-header vma)))
	       (and (cl:vectorp header)
		    (array-has-leader-p header)
		    (eq (follow-cell-forwarding (locf (fill-pointer header)) t) vma))))
    ;; Looking for the length of a vector
    (return-from length-handler-internal
      (array-length-handler-internal vma monitor mon-trap-frame :vector 2)))
  (let* ((prev-top (frame-previous-top mon-trap-frame))
	 (current-length (1+ (%p-contents-offset prev-top 0)))
	 (current-thing (read-function monitor
				       (monitor-descriptor-value-cell-or-unbound monitor)
				       vma mon-trap-frame)))
    (cond ((endp current-thing)
	   ;;--- This should do proper error-checking in the CL case
	   (adjust-frame-top mon-trap-frame 2)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-value)
	   current-length)
	  (t
	   (setf (frame-return-pc mon-trap-frame)
		 (decrement-pc (frame-return-pc mon-trap-frame)))
	   (%p-store-contents-offset current-length prev-top 0)
	   (%p-store-contents-offset current-thing prev-top -1)))))

(defun vector-length-instruction-handler (vma monitor mon-trap-frame)
  (array-length-handler-internal vma monitor mon-trap-frame :vector))

(defun array-length-instruction-handler (vma monitor mon-trap-frame)
  (array-length-handler-internal vma monitor mon-trap-frame :array))

(defun array-active-length-instruction-handler (vma monitor mon-trap-frame)
  (array-length-handler-internal vma monitor mon-trap-frame :array-active))

(defun array-length-handler-internal (vma monitor mon-trap-frame type
				      &optional (n-words 1))
  (let* ((cause-trap (read-function monitor
				    (monitor-descriptor-value-cell-or-unbound monitor)
				    vma mon-trap-frame))
	 ;; VMA could point to either the array leader, or to the array
	 (array (%find-structure-header vma))
	 (dispatch (array-dispatch-field array))
	 (*printing-monitor-message* t))	;no recursive traps...
    cause-trap
    ;;--- In fact, this is too hairy, since we can really only take a trap
    ;;--- on the fill-pointer and never on the array header.
    (flet ((array-active-length-leader (array)
	     (%p-contents-offset (locf (fill-pointer array)) 0))
	   (array-active-length-long (array)
	     (%p-contents-offset (locf (fill-pointer array)) 0))
	   (array-length-short-2d (array)
	     (* (array-rows-field array) (array-columns-field array))))
      (let ((length
	      (selector dispatch =
		((%array-dispatch-1-bit %array-dispatch-2-bit %array-dispatch-4-bit
		  %array-dispatch-8-bit %array-dispatch-16-bit
		  %array-dispatch-fixnum %array-dispatch-word %array-dispatch-boolean
		  %array-dispatch-character %array-dispatch-fat-character)
		 (array-normal-length-field array))
		((%array-dispatch-leader)
		 (if (eq type :array)
		     (array-short-length-field array)
		   (array-active-length-leader array)))
		((%array-dispatch-short-indirect)
		 (array-short-indirect-length-field array))
		((%array-dispatch-long)
		 (if (eq type :array)
		     (array-long-length-field array)
		   (array-active-length-long array)))
		((%array-dispatch-long-multidimensional)
		 (cond ((eq type :array)
			(array-long-length-field array))
		       ((eq type :array-active)
			(array-active-length-long array))))
		((%array-dispatch-short-2d)
		 (when (memq type '(:array :array-active))
		   (array-length-short-2d array))))))
	(adjust-frame-top mon-trap-frame n-words)
	(setf (frame-value-disposition mon-trap-frame) %call-for-value)
	length))))

(defun last-instruction-handler (vma monitor mon-trap-frame)
  (let* ((prev-top (frame-previous-top mon-trap-frame))
	 (current-thing (read-function monitor
				       (monitor-descriptor-value-cell-or-unbound monitor)
				       vma mon-trap-frame)))
    (cond ((endp (cdr current-thing))
	   (adjust-frame-top mon-trap-frame 1)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-value)
	   (%p-contents-offset prev-top 0))
	  (t
	   (setf (frame-return-pc mon-trap-frame)
		 (decrement-pc (frame-return-pc mon-trap-frame)))
	   (%p-store-contents-offset current-thing prev-top 0)))))	   

(defun bind-specvar-instruction-handler (vma monitor mon-trap-frame)
  (bind-location-internal vma monitor mon-trap-frame 0 1))

(defun bind-locative-instruction-handler (vma monitor mon-trap-frame)
  (bind-location-internal vma monitor mon-trap-frame 0 2))
			  
(defun bind-location-internal (vma monitor mon-trap-frame offset n-pops)
  (let* ((binding-stack-pointer %binding-stack-pointer)
	 (old-value
	   ;; Inhibit recursive traps.  You might think that you can just
	   ;; put this in the top-level LET*, but you can't because we're
	   ;; going to hack %BSP below...
	   (let ((*printing-monitor-message* t)
		 (*inhibit-signalling-unbounds* t))
	     (read-function monitor
			    (monitor-descriptor-value-cell-or-unbound monitor)
			    vma mon-trap-frame)))
	 (new-value (%p-contents-offset (frame-previous-top mon-trap-frame) offset))
	 (mon-value (write-function monitor
				    (monitor-descriptor-value-cell-or-unbound monitor)
				    new-value vma mon-trap-frame))
	 (fault-frame (frame-previous-frame mon-trap-frame)))
    ;; Perform the actual binding operation
    (%p-store-contents-increment-pointer old-value binding-stack-pointer)
    (%p-store-contents-increment-pointer vma binding-stack-pointer)
    (%p-store-cdr-code binding-stack-pointer (frame-bindings-bit fault-frame))
    (adjust-frame-top mon-trap-frame n-pops)
    (setf (monitor-descriptor-value-cell monitor) mon-value)
    ;; If we turned off monitoring, we have to update the real value-cell
    (when (not (memq vma *monitored-locations*))
      (si:%p-copy-q (locf (monitor-descriptor-value-cell monitor)) vma))
    (setf (frame-bindings-bit fault-frame) 1)
    (setf %binding-stack-pointer binding-stack-pointer)))

(defun unbind-instruction-handler (vma monitor mon-trap-frame)
  (let ((binding-stack-pointer %binding-stack-pointer)
	(trap-pc (decrement-pc (frame-return-pc mon-trap-frame))))
    (multiple-value-bind (n-left new-bsp)
	(unbind-handler-internal vma monitor mon-trap-frame binding-stack-pointer)
      ;; If we finished the instruction, then clear first-part-done (this
      ;; means that a subsequent UNBIND won't lose, e.g.), otherwise, back
      ;; up the PC and pclsr
      (cond ((zerop n-left)
	     (adjust-frame-top mon-trap-frame 1)
	     (setf (frame-first-part-done (frame-previous-frame mon-trap-frame)) 0))
	    (t (setf (frame-return-pc mon-trap-frame) trap-pc)))
      (setf %binding-stack-pointer new-bsp))))
    
;; The only way a return instruction can trap is during its unbind phase
;;--- If you have a function (DEFUN FOO () (LET ((*A* 1)) 2)), where *A* is
;;--- monitored, calling FOO will return no values!  Bad bug!
;;--- The way to fix this is to kludge the TOS for PREV-FRAME to be the number
;;--- of values to return, but I don't see how to do this since the return-PC
;;--- doesn't even point to the right place.  I think specially checking for
;;--- being in the RETURN-MULTIPLE escape function is the place to start.
;;--- The various call-then-return instructions must come through here, too.
(defun return-instruction-handler (vma monitor mon-trap-frame)
  (let ((binding-stack-pointer %binding-stack-pointer))
    (multiple-value-bind (n-left new-bsp)
	(unbind-handler-internal vma monitor mon-trap-frame binding-stack-pointer)
      (when (zerop n-left)
	(setf (frame-first-part-done mon-trap-frame) 0))
      (setf %binding-stack-pointer new-bsp))))

;; The only way a catch-close instruction can trap is during its unbind phase
(defun catch-close-instruction-handler (vma monitor mon-trap-frame)
  (let ((binding-stack-pointer %binding-stack-pointer))
    (multiple-value-bind (n-left new-bsp)
	(unbind-handler-internal vma monitor mon-trap-frame binding-stack-pointer)
      (when (zerop n-left)
	(setf (frame-first-part-done mon-trap-frame) 0))
      (setf %binding-stack-pointer new-bsp))))

(defun unbind-handler-internal (vma monitor mon-trap-frame binding-stack-pointer)
  (declare (values n-left binding-stack-pointer))
  (let* ((old-bindings-bit (binding-stack-chain-bit binding-stack-pointer))
	 (old-loc (%p-contents-pointer-decrement binding-stack-pointer))
	 (saved-value (%p-contents-pointer-decrement binding-stack-pointer))
	 (n-left (max (1- (location-contents (frame-previous-top mon-trap-frame))) 0)))
    (when (neq old-loc vma)
      (fsignal "The VMA ~O and the binding-stack ~O do not agree while unbinding!"
	vma old-loc))
    (if (eq saved-value *unbound-marker*)
	;; Special case where we need to restore something to its unbound state
	(multiple-value-bind (thing nil)
	    (decode-locative-for-printing vma)
	  (debugger-makunbound-function vma mon-trap-frame thing))
      (let ((mon-value (write-function monitor
				       (monitor-descriptor-value-cell-or-unbound monitor)
				       saved-value vma mon-trap-frame)))
	(setf (monitor-descriptor-value-cell monitor) mon-value)
	;; If we turned off monitoring, we have to update the real value-cell
	(when (not (memq vma *monitored-locations*))
	  (si:%p-copy-q (locf (monitor-descriptor-value-cell monitor)) vma))))
    (setf (location-contents (frame-previous-top mon-trap-frame)) n-left)
    (setf (frame-bindings-bit (frame-previous-frame mon-trap-frame)) old-bindings-bit)
    (values n-left binding-stack-pointer)))

(defun member-instruction-handler (vma monitor mon-trap-frame)
  ;; If the contents of the current vma are EQL to the key, then we're done
  (let* ((inst (pc-instruction (decrement-pc (frame-return-pc mon-trap-frame))))
	 (uop (ilc:get-universal-opcode inst))
	 (prev-top (frame-previous-top mon-trap-frame))
	 (key (%p-contents-offset prev-top -1))
	 current-sublist current-thing next-sublist)
    ;; Read the item that we are comparing
    (setq current-sublist (read-function monitor
					 (monitor-descriptor-value-cell-or-unbound monitor)
					 vma mon-trap-frame))
    ;; Set up all of the pointers
    (cond ((cl:listp current-sublist)
	   (setq next-sublist (cdr current-sublist)
		 current-thing (car current-sublist)))
	  (t
	   ;;--- I don't know why I need this kludge
	   (setq current-thing current-sublist
		 current-sublist (%make-pointer dtp-list vma)
		 next-sublist (cdr current-sublist))))
    (cond ((if (= uop ilc:*memq-opcode*)
	       (eq key current-thing)
	     (eql key current-thing))
	   ;; We have a match, so adjust the stack and return the result 
	   (adjust-frame-top mon-trap-frame 2)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-value)
	   current-sublist)
	  (t
	   ;; Otherwise, adjust the arguments and restart the instruction
	   (setf (frame-return-pc mon-trap-frame)
		 (decrement-pc (frame-return-pc mon-trap-frame)))
	   (%p-store-contents-offset next-sublist prev-top 0)))))

(defun assoc-instruction-handler (vma monitor mon-trap-frame)
  (let* ((inst (pc-instruction (decrement-pc (frame-return-pc mon-trap-frame))))
	 (uop (ilc:get-universal-opcode inst))
	 (prev-top (frame-previous-top mon-trap-frame))
	 (key (%p-contents-offset prev-top -1))
	 current-thing)
    (setq current-thing (read-function monitor
				       (monitor-descriptor-value-cell-or-unbound monitor)
				       vma mon-trap-frame))
    (cond ((if (= uop ilc:*assq-opcode*)
	       (eq key current-thing)
	     (eql key current-thing))
	   ;; We have a match, so return the current cons
	   (adjust-frame-top mon-trap-frame 2)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-value)
	   (%find-structure-header vma))
	  (t
	   (let* ((this-sublist (%p-contents-offset prev-top 0))
		  (next-sublist (cdr this-sublist)))
	     ;; Adjust the arguments and restart the instruction
	     (setf (frame-return-pc mon-trap-frame)
		   (decrement-pc (frame-return-pc mon-trap-frame)))
	     (%p-store-contents-offset next-sublist prev-top 0))))))

(defun get-instruction-handler (vma monitor mon-trap-frame)
  (let* ((inst (pc-instruction (decrement-pc (frame-return-pc mon-trap-frame))))
	 (uop (ilc:get-universal-opcode inst))
	 (prev-top (frame-previous-top mon-trap-frame))
	 (zl-get (= uop ilc:*get-opcode*))
	 (key (%p-contents-offset prev-top (if zl-get 0 -1)))
	 current-sublist current-thing next-sublist)
    (setq current-sublist (read-function monitor
					 (monitor-descriptor-value-cell-or-unbound monitor)
					 vma mon-trap-frame))
    ;; Set up all of the pointers
    (cond ((cl:listp current-sublist)
	   (setq next-sublist (cdr current-sublist)
		 current-thing (car current-sublist)))
	  (t
	   ;;--- I don't know why I need this kludge
	   (setq current-thing current-sublist
		 current-sublist (%make-pointer dtp-list vma)
		 next-sublist (cdr current-sublist))))
    (cond ((if zl-get
	       (eq key current-thing)
	     (eql key current-thing))
	   ;; Key matched, so return the associated value
	   (adjust-frame-top mon-trap-frame (if zl-get 2 3))
	   (setf (frame-value-disposition mon-trap-frame) %call-for-value)
	   (car next-sublist))
	  (t
	   ;; GETF-INTERNAL takes one more argument than GET
	   (let ((next-plist (cdr next-sublist)))
	     (setf (frame-return-pc mon-trap-frame)
		   (decrement-pc (frame-return-pc mon-trap-frame)))
	     (%p-store-contents-offset (if zl-get (locf next-plist) next-plist)
				       prev-top (if zl-get -1 -2)))))))

;; A FOLLOW-CELL-FORWARDING instruction, which may really be part of a function
;; that is not compiled as an instruction, so check for those functions.
(defun follow-cell-forwarding-handler (vma monitor mon-trap-frame)
  (let* ((error-frame (frame-previous-frame mon-trap-frame))
	 (function (frame-function error-frame)))
    (cond ((eq function #'location-boundp)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-return)
	   (location-boundp-function monitor vma mon-trap-frame))
	  ((eq function #'location-makunbound)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-return)
	   (location-makunbound-function monitor vma mon-trap-frame
					 (frame-arg-value error-frame 1)))
	  ((eq function #'makunbound)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-return)
	   (location-makunbound-function monitor vma mon-trap-frame
					 (frame-arg-value error-frame 0)))
	  ((eq function #'fmakunbound)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-return)
	   (location-makunbound-function monitor vma mon-trap-frame
					 (frame-arg-value error-frame 0)))
	  (t
	   (adjust-frame-top mon-trap-frame 2)
	   (setf (frame-value-disposition mon-trap-frame) %call-for-value)
	   (locate-function monitor vma mon-trap-frame)))))

(defun store-conditional-instruction-handler (vma monitor mon-trap-frame)
  (let ((old (%p-contents-offset (frame-previous-top mon-trap-frame) -1))
	(new (location-contents (frame-previous-top mon-trap-frame))))
    (adjust-frame-top mon-trap-frame 3)
    (setf (frame-value-disposition mon-trap-frame) %call-for-value)
    (when (eq (monitor-descriptor-value-cell monitor) old)
      (setq new (write-function monitor old new vma mon-trap-frame))
      (if (memq vma *monitored-locations*)
	  (store-conditional (locf (monitor-descriptor-value-cell monitor)) old new)
	;; Store in the real value-cell if monitoring was turned off
	(store-conditional vma old new)))))


;; Common subroutine for all instructions that store into the location
(defun write-instruction-handler (vma new-value monitor mon-trap-frame)
  (setf (monitor-descriptor-value-cell monitor)
	(write-function monitor (monitor-descriptor-value-cell-or-unbound monitor)
			new-value vma mon-trap-frame))
  ;; If we turned off monitoring, we have to update the real value-cell
  ;;--- There still doesn't work if the user explicitly unmonitors the
  ;;--- location, then monitors it again.  The write gets lost.
  (when (not (memq vma *monitored-locations*))
    (si:%p-copy-q (locf (monitor-descriptor-value-cell monitor)) vma))
  (monitor-descriptor-value-cell monitor))

(defun locate-instruction-handler (vma monitor mon-trap-frame)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (locate-function monitor vma mon-trap-frame))

(defun locate1-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 1)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (locate-function monitor vma mon-trap-frame))

(defun locate2-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 2)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (locate-function monitor vma mon-trap-frame))

(defun locate3-instruction-handler (vma monitor mon-trap-frame)
  (adjust-frame-top mon-trap-frame 3)
  (setf (frame-value-disposition mon-trap-frame) %call-for-value)
  (locate-function monitor vma mon-trap-frame))

(defun adjust-frame-top (mon-trap-frame n-words)
  (setf (frame-previous-top mon-trap-frame)
	(%pointer-plus (frame-previous-top mon-trap-frame) (- n-words)))
  (loop for frame = (%stack-frame-pointer) then (frame-previous-frame frame)
	and next = nil then frame
	until (eq frame mon-trap-frame)
	finally (setf (frame-buffer-underflow-bit next) 1)))


;;; Dummy functions for unmonitored operations

(defun null-read-function (value vma frame)
  (declare (dbg:error-reporter))
  (ignore frame)
  (if (and (eq value *unbound-marker*) (not *inhibit-signalling-unbounds*))
      ;; If this cell is unbound, signal that fact
      (multiple-value-bind (nil value)
	  (signal 'unbound-symbol :variable-name (decode-locative-for-printing vma))
	value)
    value))

(defun null-write-function (old-value new-value vma frame)
  (ignore old-value vma frame)
  new-value)

(defun null-locate-function (vma frame)
  (ignore frame)
  vma)

(defun null-location-boundp-function (vma frame)
  (ignore frame)
  (location-boundp (%p-contents-as-locative vma)))

(defun null-location-makunbound-function (vma frame name)
  (ignore frame)
  (location-makunbound (%p-contents-as-locative vma) name))


;;; Tables of instructions

(defmacro set-instruction-handler (handler table &body instructions)
  (when compiler:qc-file-in-progress
    (compiler:function-referenced handler))
  `(set-instruction-handler-1 ',handler ,table ',instructions))

(defun set-instruction-handler-1 (handler table instructions)
  (loop for op in instructions
	as uop = (symeval (intern (string-append "*" op "-OPCODE*")
				  ilc:*ilc-package*))
	do (setf (aref table uop) handler)
	   ;; 10-bit immediate operands take up the next three opcode slots
	   ;; as well as the one we just set up
	   (when (eq (aref ilc:*instruction-format* uop)
		     '10-bit-immediate-operand)
	     (loop repeat 3 for i upfrom (1+ uop)
		   do (setf (aref table i) handler)))))

(defun check-instruction-handlers (table &optional (warn t) (all-unimplemented nil))
  (loop with unimplemented = (if all-unimplemented
				 '(truly-undefined-instruction-handler
				   unimplemented-instruction-handler)
			       '(truly-undefined-instruction-handler))
	for handler being the array-elements of table using (index uop)
	as name = (aref ilc:*instruction-name* uop)
	do (when (null handler)
	     (setf (aref table uop) 'truly-undefined-instruction-handler))
	when (and name (memq (aref table uop) unimplemented))
	  collect name into undefined-ops
	finally
	  (when (and warn undefined-ops)
	    (loop for name in undefined-ops do
	      (if (eq warn :message-only)
		  (format t "~&No monitor handler has been defined for the ~A instruction"
		    name)
		(warn () "No handler has been defined for the ~A instruction" name))))
 	  (return undefined-ops)))

(set-instruction-handler read-instruction-handler *instruction-handler*
  push-indirect push-instance-variable push-instance-variable-ordered
  %fetch-freevar-0 %fetch-freevar-1 %fetch-freevar-2 %fetch-freevar-3
  %fetch-freevar-4 %fetch-freevar-5 %fetch-freevar-6 %fetch-freevar-7
  push-car-local push-cdr-local)

(set-instruction-handler read1-instruction-handler *instruction-handler*
  car cdr symeval fsymeval get-pname
  ar-1-immed ar-1-local fast-aref ftn-ar-1 array-leader-immed
  %fetch-freevar-n %instance-ref)

(set-instruction-handler read2-instruction-handler *instruction-handler*
  ar-1 array-leader %1d-aref)

(set-instruction-handler read3-instruction-handler *instruction-handler*
  ar-2)

(set-instruction-handler pop-instruction-handler *instruction-handler*
  pop-indirect pop-instance-variable pop-instance-variable-ordered
  %pop-freevar-0 %pop-freevar-1 %pop-freevar-2 %pop-freevar-3
  %pop-freevar-4 %pop-freevar-5 %pop-freevar-6 %pop-freevar-7)

(set-instruction-handler movem-instruction-handler *instruction-handler*
  movem-indirect movem-instance-variable movem-instance-variable-ordered
  %movem-freevar-0 %movem-freevar-1 %movem-freevar-2 %movem-freevar-3
  %movem-freevar-4 %movem-freevar-5 %movem-freevar-6 %movem-freevar-7)

(set-instruction-handler locate-instruction-handler *instruction-handler*
  push-address-instance-variable push-address-instance-variable-ordered)

(set-instruction-handler locate1-instruction-handler *instruction-handler*
  value-cell-location function-cell-location property-cell-location package-cell-location
  ;;--- This never goes off, because it never reads memory!
  %instance-loc)

(set-instruction-handler locate2-instruction-handler *instruction-handler*
  %1d-aloc ap-1 ftn-ap-1 ap-leader)

(set-instruction-handler locate3-instruction-handler *instruction-handler*
  ap-2)

(set-instruction-handler store2-instruction-handler *instruction-handler*
  rplaca rplacd set)

(set-instruction-handler xstore2-instruction-handler *instruction-handler*
  as-1-immed as-1-local fast-aset ftn-as-1 store-array-leader-immed
  %pop-freevar-n %instance-set)

(set-instruction-handler xstore3-instruction-handler *instruction-handler*
  as-1 store-array-leader %1d-aset)

(set-instruction-handler xstore4-instruction-handler *instruction-handler*
  as-2)

(set-instruction-handler boundp-instruction-handler *instruction-handler*
  boundp fboundp location-boundp)

(set-instruction-handler length-internal-instruction-handler *instruction-handler*
  length-internal)

(set-instruction-handler cl-length-internal-instruction-handler *instruction-handler*
  cl-length-internal)

(set-instruction-handler vector-length-instruction-handler *instruction-handler*
  vector-length)

(set-instruction-handler array-length-instruction-handler *instruction-handler*
  array-length)

(set-instruction-handler array-active-length-instruction-handler *instruction-handler*
  array-active-length)

(set-instruction-handler last-instruction-handler *instruction-handler*
  last)

(set-instruction-handler bind-specvar-instruction-handler *instruction-handler*
  bind-specvar)

(set-instruction-handler bind-locative-instruction-handler *instruction-handler*
  bind-locative)

(set-instruction-handler unbind-instruction-handler *instruction-handler*
  unbind-n)

(set-instruction-handler return-instruction-handler *instruction-handler*
  return-nil return-n return-stack return-multiple)

(set-instruction-handler catch-close-instruction-handler *instruction-handler*
   catch-close catch-close-multiple)

(set-instruction-handler member-instruction-handler *instruction-handler*
  memq member-fast)

(set-instruction-handler assoc-instruction-handler *instruction-handler*
  assq assoc-fast)

(set-instruction-handler get-instruction-handler *instruction-handler*
  get getf-internal)

(set-instruction-handler follow-cell-forwarding-handler *instruction-handler*
  follow-cell-forwarding)

(set-instruction-handler store-conditional-instruction-handler *instruction-handler*
  store-conditional)

;; Instructions whose handlers haven't yet been written
(set-instruction-handler unimplemented-instruction-handler *instruction-handler*
  ;;--- This can trap by referencing the array header, but it's probably
  ;;--- a bad idea to be monitoring that anyway (SWM)
  stringp
  ;;--- Call instructions are quite hard, ignore them for now (SWM)
  ;;--- These can trap when reading the function cell during the call, or
  ;;--- during the return phase while unbinding things.
  call-0-ignore call-0-stack call-0-return call-0-multiple
  call-1-ignore call-1-stack call-1-return call-1-multiple
  call-2-ignore call-2-stack call-2-return call-2-multiple
  call-3-ignore call-3-stack call-3-return call-3-multiple
  call-4-ignore call-4-stack call-4-return call-4-multiple
  call-n-ignore call-n-stack call-n-return call-n-multiple
  funcall-0-ignore funcall-0-stack funcall-0-return funcall-0-multiple
  funcall-1-ignore funcall-1-stack funcall-1-return funcall-1-multiple
  funcall-2-ignore funcall-2-stack funcall-2-return funcall-2-multiple
  funcall-3-ignore funcall-3-stack funcall-3-return funcall-3-multiple
  funcall-4-ignore funcall-4-stack funcall-4-return funcall-4-multiple
  funcall-n-ignore funcall-n-stack funcall-n-return funcall-n-multiple
  funcall-ni-ignore funcall-ni-stack funcall-ni-return funcall-ni-multiple
  lexpr-funcall-ignore lexpr-funcall-stack lexpr-funcall-return lexpr-funcall-multiple
  lexpr-funcall-n-ignore lexpr-funcall-n-stack lexpr-funcall-n-return lexpr-funcall-n-multiple
  ;;--- Prolog instructions (Cassels)
  push-goal proceed execute-stack execute-goal dereference-stack dereference-local 
  unify-constant unify-immediate unify-local unify-list unify-list* unify-nil unify-list*-1
  ;;--- Fortran instructions (Cassels or Stryker)
  ftn-double-ar-1 ftn-double-as-1
  ;;--- C instructions (Cassels or Hornig)
  octet-aref-8 octet-aref-16 octet-aref octet-aset-8 octet-aset-16 octet-aset
  sign-extend-8 sign-extend-16
  ;;--- It's probably a bad idea to monitor slots in hash tables, etc.
  %block-search-eq-internal soft-matte-decode-arrays soft-matte-internal
  %block-checksum-copy %block-32-36-checksum-copy %block-36-32-checksum-copy
  %dispatch-elt
  ;;--- Miscellaneous (SWM)
  %trap-on-instance %io-read-until-bit-test %io-read-while-bit-test %io-read %io-write
  set-cdr-local %set-cdr-code-1 %set-cdr-code-2 %movem-freevar-n
  restart-trapped-call un-lexpr-funcall stack-dump stack-load)

;; Instructions that should never see DTP-MONITOR-FORWARD
(set-instruction-handler undefined-instruction-handler *instruction-handler*
  push-constant push-local push-immed push-address-local push-from-beyond-multiple
  push-n-nils push-nil push-2-nils push-t push-character
  movem-local pop-local pop-n pop-n-save-1 pop-n-save-m
  pop-n-save-multiple pop-multiple-save-n fixup-tos pop-multiple-save-multiple
  %save-binding-stack-level %restore-binding-stack-level optional-arg-supplied-p
  append-multiple-groups take-arg require-args take-values take-keyword-argument
  take-n-args take-n-args-rest take-rest-arg take-n-optional-args take-n-optional-args-rest
  take-m-required-n-optional-args take-m-required-n-optional-args-rest
  branch branch-true branch-false branch-true-else-pop branch-false-else-pop
  branch-true-and-pop branch-false-and-pop long-branch long-branch-immed
  branch-eq branch-not-eq branch-atom branch-not-atom branch-endp branch-not-endp
  error-if-true error-if-false catch-open-ignore catch-open-stack catch-open-return
  catch-open-multiple unwind-protect-open
  call-quick-external call-quick-internal call-quick-internal-long
  popj popj-n popj-multiple %leave-unwind-protect
  eq eql char= char-equal not zerop plusp minusp lessp greaterp equal-number atom fixp
  single-float-p numberp symbolp arrayp cl-listp endp double-float-p floatp
  add-stack add-local add-immed sub-stack sub-local sub-immed unary-minus
  logand-stack logior-stack logxor-stack multiply-stack multiply-immed
  quotient-stack remainder-stack rational-quotient-stack mod-stack
  increment-local decrement-local cons ncons
  ldb-immed dpb-immed lsh-stack rot-stack ash-stack
  floor-stack truncate-stack ceiling-stack round-stack
  %add-bignum-step %sub-bignum-step %multiply-bignum-step %divide-bignum-step
  %numeric-dispatch-index %32-bit-plus %32-bit-difference %lshc-bignum-step
  %convert-single-to-double %convert-double-to-single %convert-double-to-fixnum
  %convert-fixnum-to-double %convert-single-to-fixnum float
  %double-floating-compare %double-floating-add %double-floating-sub
  %double-floating-multiply %double-floating-divide %double-floating-abs
  %double-floating-minus %double-floating-scale
  float-operating-mode set-float-operating-mode
  float-operation-status set-float-operation-status
  array-register-event setup-1d-array setup-force-1d-array
  ftn-load-array-register setup-1d-array-sequential setup-force-1d-array-sequential
  %halt %multiply-double %data-type %pointer %fixnum %flonum
  %make-pointer %make-pointer-immed %make-pointer-immed-offset %pointer-difference
  ;; Yes, the %P- instructions really won't generate a monitor trap
  %p-store-contents %p-store-tag-and-pointer %p-store-cdr-and-contents
  %p-store-contents-increment-pointer %p-store-contents-pointer-decrement
  %p-contents-as-locative %p-structure-offset
  %p-contents-increment-pointer %p-contents-pointer-decrement
  %p-ldb-immed %p-tag-ldb-immed %p-dpb-immed %p-tag-dpb-immed char-ldb-immed
  %microsecond-clock %stack-group-switch 
  follow-structure-forwarding %unsynchronized-device-read
  %block-store-cdr-and-contents %block-store-tag-and-pointer
  %bitblt-short-row %bitblt-long-row %bitblt-long-row-backwards %bitblt-decode-arrays
  push-microcode-escape-constant funcall-microcode-escape-constant
  %assure-pdl-room assure-prolog-frame-room
  %resume-main-stack-buffer %funcall-in-auxiliary-stack-buffer
  %audio-start %fep-doorbell %disk-start %net-wakeup %tape-wakeup
  %map-cache-write %phtc-read %phtc-write %phtc-setup
  %reference-tag-read %reference-tag-write %scan-reference-tags
  %gc-tag-read %gc-tag-write %scan-gc-tags %gc-map-write
  %meter-on %meter-off %block-gc-copy %block-transport %scan-for-oldspace
  %clear-caches %physical-address-cache %set-preempt-pending %check-preempt-pending
  %scan-for-ephemeral-space %ephemeralp %clear-instruction-cache %scan-for-ecc-error
  %frame-consing-done %allocate-list-block %allocate-structure-block
  %allocate-list-transport-block %allocate-structure-transport-block
  %draw-line-loop %draw-string-step %draw-triangle-segment
  %bitblt-short %bitblt-long
  %start %set-ethernet-address
  push-var push-choice-pointer push-void push-list push-list*
  globalize-var globalize-var-for-neck-cut
  fail fail-if-false fail-if-true cut neck-cut
  %restart-trapped-fail %prolog-meter-on %prolog-meter-off
  %read-scc-register %write-scc-register)

;; Fill in the rest of the table.  Don't bother to barf, it happens at a useless time.
(check-instruction-handlers *instruction-handler* nil t)


;;; Calling the debugger for monitored operations

(defflavor access-monitored-location (vma frame inst function desc)
	   (special-commands-mixin debugger-condition)
  (:initable-instance-variables vma frame desc)
  (:required-methods :operation-name)
  :abstract-flavor)

(defmethod (:init access-monitored-location :after) (ignore)
  (setq inst (pc-instruction (decrement-pc (frame-return-pc frame)))
	function (frame-function (frame-previous-frame frame))
	desc (location-monitor-descriptor vma))
  ;; :NO-ACTION should always be on RESUME
  (and (memq ':no-action proceed-types)
       (neq (first proceed-types) ':no-action)
       (setq proceed-types (cons ':no-action (remq ':no-action proceed-types)))))
	
(defmethod (:report access-monitored-location) (stream)
  (let ((*printing-monitor-message* t))
    #---ignore (format stream "Monitor trap~%")
    #+++ignore (when (monitor-descriptor-name desc)
		 (format stream "Monitoring ~1{~@?~:}~%" (monitor-descriptor-name desc)))
    (let ((uop (ilc:get-universal-opcode inst)))
      (format stream "The function ~S used the instruction ~S~:[ ~O~;~*~] to ~A~@
		      the ~\vma\"
	(function-name function)
	(aref ilc:*instruction-name* uop)
	(eq (aref ilc:*instruction-format* uop) 'no-operand)
	(ldb (byte 8 8) inst)
	(send self :operation-name)
	vma))))

(defmethod (current-and-innermost-frames-for-debugger access-monitored-location) (ignore)
  (declare (values current-frame innermost-interesting-frame))
  (let ((innermost-interesting-frame (frame-previous-frame frame)))
    (values (frame-out-to-interesting-active-frame innermost-interesting-frame)
	    innermost-interesting-frame)))

(defmethod (relocate-frame-pointers access-monitored-location) ()
  (setq frame (follow-cell-forwarding frame nil)))

(defmacro define-toggle-trap (name trap-keyword)
  (let ((command-name (intern (string-append "TOGGLE-" (string-upcase name) "-TRAP")
			      pkg-keyword-package)))
    `(progn
       (defmethod (:special-command access-monitored-location ,command-name)
		  (&rest ignore)
	 (send self :toggle-trap-internal ',trap-keyword)
	 nil)
       (defmethod (:document-special-command access-monitored-location ,command-name)
		  (stream)
	 (send self :document-special-command-internal stream ',name ',trap-keyword)))))

;; Don't use LOCATION-MONITORED-P here, it can cause a recursive trap
(defmethod (:toggle-trap-internal access-monitored-location) (trap-keyword)
  (unless (= (%p-data-type vma) dtp-monitor-forward)
    (format t "~&Re-enabling monitoring~%")
    (setf (location-monitor-descriptor vma) desc))
  (send desc :toggle-state trap-keyword))

(defmethod (:document-special-command-internal access-monitored-location)
	   (stream name trap-keyword)
  (if (memq trap-keyword (debugger-monitor-descriptor-state desc))
      (format stream "Turn ~A trapping off for this location" name)
    (format stream "Turn ~A trapping on for this location" name)))

(define-toggle-trap "read" :read)

(define-toggle-trap "write" :write)

(define-toggle-trap "locate" :locate)

(define-toggle-trap "boundp" :boundp)

(define-toggle-trap "makunbound" :makunbound)

(defmethod (:special-command access-monitored-location :unmonitor-location) (&rest ignore)
  (block access-monitored-location
    (unless (memq vma *monitored-locations*)
      (fsignal "~S is not a location known to be monitored" vma)
      (return-from access-monitored-location nil))
    (unless (eq (location-monitor-descriptor vma) desc)
      (ferror "Location ~S is no longer being monitored by this error"))
    (unmonitor-location vma)
    nil))

(defmethod (:document-special-command access-monitored-location :unmonitor-location) (stream)
  (format stream "Unmonitor the location"))


(defflavor read-monitored-location (value) (access-monitored-location)
  :initable-instance-variables)

(defmethod (:operation-name read-monitored-location) () "read")

(defmethod (:report read-monitored-location :after) (stream)
  (format stream "~%~:[The contents of the location is ~S~;The location is unbound~]"
    (eq value *unbound-marker*) value))

(defmethod (:proceed read-monitored-location :no-action) ()
  (declare (dbg:error-reporter))
  (if (eq value *unbound-marker*)
      ;; I admit it, this is not so hot
      (signal 'unbound-symbol-trap :variable-name (decode-locative-for-printing vma)
				   :macro-pc (decrement-pc (frame-return-pc frame))
				   :error-handler-base-frame frame)
    (values :no-action value)))

(defmethod (:document-proceed-type read-monitored-location :no-action) (stream)
  (format stream "~:[Return ~S, the contents of the location~;~
		     Signal an unbound symbol trap~]"
    (eq value *unbound-marker*) value))

(defmethod (:proceed read-monitored-location :new-value)
	   (&optional (new-value (read-and-verify-expression
				   t nil value "New value to return")))
  (values :new-value new-value))

(defmethod (:document-proceed-type read-monitored-location :new-value) (stream)
  (format stream "Return a specified value~:[ instead of ~S~]"
    (eq value *unbound-marker*) value))

(defun debugger-read-function (value vma frame)
  (declare (dbg:error-reporter))
  (if *printing-monitor-message*
      value
    (multiple-value-bind (nil value)
	(signal 'read-monitored-location :vma vma :frame frame :value value
					 :proceed-types '(:no-action :new-value))
      value)))


(defflavor write-monitored-location (old-value new-value) (access-monitored-location)
  :initable-instance-variables)

(defmethod (:operation-name write-monitored-location) () "write")

(defmethod (:report write-monitored-location :after) (stream)
  (if (eq old-value new-value)
      (format stream
	  "~%The contents of the location is being rewritten as ~:[~*unbound~;~S~]"
	(location-boundp (%p-contents-as-locative vma)) new-value)
    (format stream
	"~%The contents of the location is being changed from ~:[~*unbound~;~S~] to ~S"
      (location-boundp (%p-contents-as-locative vma)) old-value new-value)))

(defmethod (:proceed write-monitored-location :no-action) ()
  (values :new-value new-value))

(defmethod (:document-proceed-type write-monitored-location :no-action) (stream)
  (format stream "Store ~S into the location" new-value))

(defmethod (:proceed write-monitored-location :new-value)
	   (&optional (new-val (read-and-verify-expression
				 t nil new-value "New value to store")))
  (values :new-value new-val))

(defmethod (:document-proceed-type write-monitored-location :new-value) (stream)
  (format stream "Store a specified value instead of ~S" new-value))

(defmethod (:proceed write-monitored-location :old-value) ()
  (values :old-value old-value))

(defmethod (:document-proceed-type write-monitored-location :old-value) (stream)
  (format stream "Leave the location ~:[set to its old value~;unbound~]"
    (eq old-value *unbound-marker*)))

(defun debugger-write-function (old-value new-value vma frame)
  (declare (dbg:error-reporter))
  (multiple-value-bind (nil value)
      (signal 'write-monitored-location :vma vma :frame frame
					:old-value old-value :new-value new-value)
    value))


(defflavor boundp-monitored-location (boundp (value)) (access-monitored-location)
  :initable-instance-variables)

(defmethod (:operation-name boundp-monitored-location) ()
  "test whether the location is bound")

(defmethod (:report boundp-monitored-location :after) (stream)
  (format stream "~%The location is ~:[unbound~;bound to ~S~]" boundp value))

(defmethod (:proceed boundp-monitored-location :no-action) ()
  (values :no-action boundp))

(defmethod (:document-proceed-type boundp-monitored-location :no-action) (stream)
  (format stream "Return ~S, indicating the location is ~:[unbound~;bound~]" boundp boundp))

(defmethod (:proceed boundp-monitored-location :new-value)
	   (&optional (new-value (read-and-verify-expression
				   t nil boundp "New value to return")))
  (values :new-value new-value))

(defmethod (:document-proceed-type boundp-monitored-location :new-value) (stream)
  (format stream "Return a specified value instead of ~S" boundp))

(defun debugger-boundp-function (vma frame)
  (declare (dbg:error-reporter))
  (let* ((desc (location-monitor-descriptor vma))
	 (boundp (location-boundp (locf (monitor-descriptor-value-cell desc)))))
    (if *printing-monitor-message*
	boundp
      (multiple-value-bind (nil value)
	  (signal 'boundp-monitored-location
		  :vma vma :frame frame :boundp boundp
		  :value (monitor-descriptor-value-cell-or-unbound desc))
	value))))


(defflavor locate-monitored-location () (access-monitored-location)
  :initable-instance-variables)

(defmethod (:operation-name locate-monitored-location) ()
  "return a locative to")

(defmethod (:proceed locate-monitored-location :no-action) ()
  (values :no-action vma))

(defmethod (:document-proceed-type locate-monitored-location :no-action) (stream)
  (format stream "Return ~A, a locative to the monitored cell" vma))

(defmethod (:proceed locate-monitored-location :new-value)
	   (&optional (new-value (read-and-verify-expression
				   t nil vma "New value to return")))
  (values :new-value new-value))

(defmethod (:document-proceed-type locate-monitored-location :new-value) (stream)
  (format stream "Return a specified value instead of ~S" vma))

(defun debugger-locate-function (vma frame)
  (declare (dbg:error-reporter))
  (if *printing-monitor-message*
      vma
    (multiple-value-bind (nil value)
	(signal 'locate-monitored-location :vma vma :frame frame)
      value)))
 

(defflavor makunbound-monitored-location (name) (access-monitored-location)
  :initable-instance-variables)

(defmethod (:operation-name makunbound-monitored-location) () "makunbound")

(defmethod (:report makunbound-monitored-location :after) (stream)
  (format stream
    "~%The contents of the location is being changed from ~:[~*unbound~;~S~] to ~
     unbound~@[ with name ~S~]"
    (location-boundp (%p-contents-as-locative vma))
    (and (location-boundp (%p-contents-as-locative vma))
	 (location-contents (%p-contents-as-locative vma)))
    name))

(defmethod (:proceed makunbound-monitored-location :no-action) ()
  :no-action)

(defmethod (:document-proceed-type makunbound-monitored-location :no-action) (stream)
  (format stream "Make the location unbound"))

(defmethod (:proceed makunbound-monitored-location :old-value) ()
  :old-value)

(defmethod (:document-proceed-type makunbound-monitored-location :old-value) (stream)
  (let ((boundp ( dtp-null (%p-data-type (%p-contents-as-locative vma)))))
    (format stream "Leave the location ~:[unbound~;unchanged, containing ~S~]"
      boundp (when boundp
	       (location-contents (%p-contents-as-locative vma))))))

(defun debugger-makunbound-function (vma frame name)
  (declare (dbg:error-reporter))
  (signal-proceed-case (() 'makunbound-monitored-location :vma vma :frame frame :name name)
    (:no-action
      (location-makunbound (%p-contents-as-locative vma) name))
    (:old-value
      nil)))


(defflavor unimplemented-monitor-trap () (access-monitored-location)
  :initable-instance-variables)

(defmethod (:operation-name unimplemented-monitor-trap) ()
  "miscellaneous")

(defmethod (:report unimplemented-monitor-trap) (stream)
  (format stream "Monitor trap~%")
  (let* ((error-frame (frame-previous-frame frame))
	 (inst (pc-instruction (decrement-pc (frame-return-pc frame))))
	 (uop (ilc:get-universal-opcode inst)))
    (format stream "The function ~S used the instruction ~S~:[ ~O~;~*~] to access~%~
		    the ~\vma\,~%~
		    but the simulator for this instruction has not been implemented."
      (function-name (frame-function error-frame))
      (aref ilc:*instruction-name* uop)
      (eq (aref ilc:*instruction-format* uop) 'no-operand)
      (ldb (byte 8 8) inst)
      vma)))

(defmethod (:proceed unimplemented-monitor-trap :no-action) ()
  (unmonitor-location vma)
  ;; The easiest way to restart a single instruction
  (back-up-return-pc frame)
  :no-action)

(defmethod (:document-proceed-type unimplemented-monitor-trap :no-action) (stream)
  (format stream "Unmonitor the location and retry the instruction"))

(compile-flavor-methods access-monitored-location read-monitored-location
			write-monitored-location makunbound-monitored-location
			boundp-monitored-location locate-monitored-location
			unimplemented-monitor-trap)


;;; A wee bit of user interface

(defun monitor-symbol-value (variable &rest keywords)
  (declare (arglist variable &key (read nil) (write t) locate makunbound boundp))
  (lexpr-funcall #'monitor-location (value-cell-location variable)
		 :name `("~S" ,variable)
		 keywords))

(defun monitor-location (location &key (read nil) (write t) name
			 locate
			 (makunbound (or (not (null write)) (eq write 'dbg)))
			 (boundp (or (eq read t) (eq read 'dbg))))
  (when (fixp location)
    (setq location (%make-pointer dtp-locative location)))
  ;; It's OK to trap here, since this isn't supposed to be monitored
  (setq location (follow-cell-forwarding location t))
  ;;--- Don't monitor locations in the stack for the time being
  (when (or (dw::consed-in-control-stack location)
	    (dw::consed-in-data-stack location)
	    (let* ((region (sys:%region-number location))
		   (bits (and region (sys:region-bits region))))
	      (or (null region)
		  (ldb-test sys:%%region-stack bits))))
    (ferror "You can't monitor locations in stacks or in A-memory"))
  (when (memq location *monitored-locations*)
    (unmonitor-location location))
  (let ((type (nth (%p-data-type location) *data-types*)))
    (when (member type
		  '(dtp-header-i dtp-header-p dtp-monitor-forward dtp-gc-forward))
      (error "Cannot monitor location ~D; it is a ~S"
	     location (nth (symeval type) sys:*data-types*))))
  (let ((state `(,@(if read '(:read))
		 ,@(if (eq write t) '(:write))
		 ,@(if (eq write :change) '(:change))
		 ,@(if locate '(:locate))
		 ,@(if makunbound '(:makunbound))
		 ,@(if boundp '(:boundp)))))
    (cl:pushnew location *monitored-locations* :test #'eq)
    (setf (location-monitor-descriptor location)
	  (make-debugger-monitor-descriptor (or name
						`("location ~S in ~S" ,location
						  ,(%find-structure-header location)))
					    *instruction-handler*
					    state))))

(defun monitor-instance-variable (instance variable-name &rest keywords)
  (declare (arglist instance variable-name
	    &key (read nil) (write t) locate makunbound boundp))
  (lexpr-funcall #'monitor-location (locate-in-instance instance variable-name)
		 :name `("the ~S instance variable of ~S" ,variable-name ,instance)
		 keywords))

(defmacro monitor-variable (access-form &rest keywords)
  (declare (arglist access-form
	    &key (read nil) (write t) locate makunbound boundp))
  `(monitor-location (locf ,access-form) :name ',`("~S" ,access-form) ,@keywords))

(defun unmonitor-location (location)
  (when (fixp location)
    (setq location (%make-pointer dtp-locative location)))
  ;; Inhibit recursive monitor traps
  (let ((*printing-monitor-message* t))
    (setq location (follow-cell-forwarding location t)))
  (unless (memq location *monitored-locations*)
    (fsignal "~S is not a location known to be monitored" location)
    (return-from unmonitor-location nil))
  (let ((desc (location-monitor-descriptor location nil)))
    (without-interrupts
      ;;--- If someone modified the CDR code in the meantime, we trust they
      ;;--- really did it to the one in the monitor-descriptor.  This probably
      ;;--- isn't right, but I'm being lazy.
      (when desc
	(si:%p-copy-q (locf (monitor-descriptor-value-cell desc)) location))
      (setq *monitored-locations* (delq location *monitored-locations*)))
    desc))

(defun unmonitor (&optional name log)
  (loop for location in *monitored-locations*
	;; It's OK if this isn't monitored any more
	as desc = (location-monitor-descriptor location nil)
	when (or (not name)
		 (and desc
		      (equal name (cdr (monitor-descriptor-name desc)))))
	  do (when (and desc log)
	       (format t "~&The ~\vma\ is now unmonitored" location))
	     (without-interrupts
	       ;;--- If someone modified the CDR code in the meantime, we trust they
	       ;;--- really did it to the one in the monitor-descriptor.  This probably
	       ;;--- isn't right, but I'm being lazy.
	       (when desc
		 (si:%p-copy-q (locf (monitor-descriptor-value-cell desc)) location))
	       (setq *monitored-locations* (delq location *monitored-locations*)))))


(cp:define-command (com-monitor-variable :command-table "Tracing"
					 :provide-output-destination-keyword nil)
    ((locations '((cl:sequence symbol))
		:prompt "variables to monitor"
		:default nil)
     &key
     (cell '((cl:member :value-cell :function-cell))
	   :default :value-cell
	   :documentation "Function cell or value cell")
     (read 'scl:boolean
	   :default nil
	   :mentioned-default t
	   :documentation "Trap on reads")
     (write '((token-or-type (:change) scl:boolean))
	    :default-type 'scl:boolean
	    :default t
	    :documentation "Trap on writes")
     (locf 'scl:boolean
	   :default nil
	   :mentioned-default t
	   :documentation "Trap on locf's")
     (makunbound 'scl:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "Trap on makunbound's")
     (boundp 'scl:boolean
	     :default nil
	     :mentioned-default t
	     :documentation "Trap on boundp's"))
  (loop for location in locations doing
    (setq location (selectq cell
		     (:value-cell (value-cell-location location))
		     (:function-cell (function-cell-location location))))
    (monitor-location location :read read :write write :locate locf
		      :makunbound makunbound :boundp boundp)
    (format t "~&The ~(~A~) of ~S is now being monitored for "
      cell (decode-locative-for-printing location))
    (formatting-textual-list (t :finally " and ")
      (when read (formatting-textual-list-element () (princ "reads")))
      (when (eq write t) (formatting-textual-list-element () (princ "writes")))
      (when (eq write :change) (formatting-textual-list-element () (princ "changes")))
      (when locf (formatting-textual-list-element () (princ "locf's")))
      (when makunbound (formatting-textual-list-element () (princ "makunbound's")))
      (when boundp (formatting-textual-list-element () (princ "boundp's"))))))

(cp:define-command (com-unmonitor-variable :command-table "Tracing"
					   :provide-output-destination-keyword nil)
    ((locations '((or null ((cl:sequence symbol))))
		:prompt "variables to unmonitor or <return> for all"
		:default nil
		:default-type 'null)
     &key
     (cell '((cl:member :value-cell :function-cell))
	   :default :value-cell
	   :documentation "Function cell or value cell"))
  (cond ((null locations)
	 (if *monitored-locations*
	     (unmonitor nil t)
	   (format t "~&No locations are currently being monitored")))
	(t
	 (loop for location in locations doing
	   (setq location (selectq cell
			    (:value-cell (value-cell-location location))
			    (:function-cell (function-cell-location location))))
	   (if (not (memq (let ((*printing-monitor-message* t))
			    (follow-cell-forwarding location t)) *monitored-locations*))
	       (format t "~&~S was not monitored"
		 (decode-locative-for-printing location))
	     (unmonitor-location location)
	     (format t "~&The ~(~A~) of ~S is now unmonitored"
	       cell (decode-locative-for-printing location)))))))

(cp:define-command (com-show-monitored-locations :command-table "Tracing"
						 :provide-output-destination-keyword nil)
    ()
  (if (null *monitored-locations*)
      (format t "~&No locations are currently being monitored")
    (loop for vma in *monitored-locations*
	  as descr = (location-monitor-descriptor vma)
	  do (show-monitor-state descr vma))))

(defvar *monitor-for-reads-on-click* nil)
(define-presentation-action monitor-location
   (location-or-unbound dw:top-level-command-context
    :tester ((object &key presentation)
	     (let ((location (or (dw::presentation-location presentation)
				 (if (locativep object) object))))
	       (and location
		    (not (location-monitored-p (%make-pointer dtp-locative location))))))
    :documentation "Monitor this location"
    :gesture :monitor-location)
   (object &key presentation window)
  (let* ((superior (find-named-slot-superior presentation))
	 (location (or (and superior (dw::presentation-object superior))
		       (dw::presentation-location presentation)
		       (and (locativep object) object))))
    (when location
      (setq location (%make-pointer dtp-locative location))
      (if presentation
	  (monitor-location location
			    :read *monitor-for-reads-on-click*
			    :write t
			    :name `("location ~S ~vQ" ,location
				    ,presentation ,#'format-present-superior))
	(monitor-location location :read *monitor-for-reads-on-click*))
      (si:with-ie-typeout-if-appropriate (terminal-io)
	(format t "~&The ~\vma\ is now monitored for ~:[reads and ~]writes"
	  location (not *monitor-for-reads-on-click*)))
      (incf dw::*presentation-input-context-tick*)
      (represent-named-slot presentation window))
    (values)))

(define-presentation-action unmonitor-location
   (location-or-unbound dw:top-level-command-context
    :tester ((object &key presentation)
	     (let ((location (or (dw::presentation-location presentation)
				 (if (locativep object) object))))
	       (and location
		    (location-monitored-p (%make-pointer dtp-locative location)))))
    :documentation "Unmonitor this location"
    :gesture :unmonitor-location)
   (object &key presentation window)
  (let* ((superior (find-named-slot-superior presentation))
	 (location (or (and superior (dw::presentation-object superior))
		       (dw::presentation-location presentation)
		       (and (locativep object) object))))
    (when location
      (setq location (%make-pointer dtp-locative location))
      (unmonitor-location location)
      (si:with-ie-typeout-if-appropriate (terminal-io)
	(format t "~&The ~\vma\ is no longer being monitored" location))
      (incf dw::*presentation-input-context-tick*)
      (represent-named-slot presentation window))
    (values)))

(define-presentation-action monitor-special-variable
   (symbol dw:top-level-command-context
    :tester ((symbol)
	     (and (get symbol 'special)
		  (not (location-monitored-p (value-cell-location symbol)))))
    :documentation "Monitor this variable"
    :gesture :monitor-location)
   (symbol)
  (let ((location (value-cell-location symbol)))
    (monitor-location location :read *monitor-for-reads-on-click*)
    (si:with-ie-typeout-if-appropriate (terminal-io)
      (format t "~&The ~\vma\ is now monitored for ~:[reads and ~]writes"
	location (not *monitor-for-reads-on-click*)))
    (values)))

(define-presentation-action unmonitor-special-variable
   (symbol dw:top-level-command-context
    :tester ((symbol)
	     (and (get symbol 'special)
		  (location-monitored-p (value-cell-location symbol))))
    :documentation "Unmonitor this variable"
    :gesture :unmonitor-location)
   (symbol)
  (let ((location (value-cell-location symbol)))
    (unmonitor-location location)
    (si:with-ie-typeout-if-appropriate (terminal-io)
      (format t "~&The ~\vma\ is no longer being monitored" location))
    (values)))

(defun format-present-superior (presentation)
  (multiple-value-bind (superior type)
      (find-named-slot-superior presentation)
    (if (not superior)
	(present (dw::presentation-object presentation) (dw::presentation-type presentation)
		 :stream format:*format-output*)
      (setq type (copylist type))
      (setf (cl:getf (cdr type) :show-structure) t)
      (setf (cl:getf (cdr type) :show-monitored) nil)
      (if superior
	  (present (dw::presentation-object superior) type :stream format:*format-output*)
	(prin1 (%find-structure-header (dw::presentation-location presentation))
	       format:*format-output*)))))

(defun represent-named-slot (presentation window)
  (multiple-value-bind (pr type)
      (find-named-slot-superior presentation)
    (when pr
      (send window :represent-presentation pr type))))

(defun find-named-slot-superior (presentation &optional (depth 1))
  ;; Normally, DEPTH is just 1, so that, for example, clicking on an item
  ;; in a list contained in an IV monitors that item rather than the IV.
  ;; However, clicking on the top-level list monitors the IV.
  (when (null depth) (setq depth 100000.))
  (loop repeat depth
	for pr = (dw::presentation-superior presentation)
	       then (dw::presentation-superior pr)
	while pr
	as type = (dw::presentation-type pr)
	when (dw:presentation-subtypep type 'named-slot)
	  return (values pr type)
	until (not (dw:presentation-subtypep 'location-or-unbound type))))

(compile-flavor-methods debugger-monitor-descriptor)

||#
