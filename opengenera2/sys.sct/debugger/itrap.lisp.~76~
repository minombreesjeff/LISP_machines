;;; -*- Mode: Lisp; Package: Debugger; Base: 8; -*-

;;; I machine microcode error debugger interface
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFVAR *TRAP-MISC-CONDITION-TABLE*)	;Initialized by cold load
(DEFVAR *TRAP-DISPATCH-TABLE-VERSIONS*)	;The file versions of the dispatch tables.

(DEFVAR *CURRENT-BREAKPOINT-INFO* NIL)
(DEFVAR *STEP-FROM-BREAKPOINT* NIL)

;; This maps wrong-type-argument OP2 into SCL types.
(DEFCONST *TRAP-SCL-TYPES*
  #.SCL:(VECTOR 'FIXNUM
		'INSTANCE
		'LOCATIVE
		'ARRAY
		'NUMBER
		'(OR LOCATIVE SYS:(DATA-TYPE DTP-LIST))	;Not DTP-LIST-INSTANCE
		'(OR LIST LOCATIVE)
		'CHARACTER
		'LIST
		'SYS:COMPILED-FUNCTION-PC
		'(OR CONS LOCATIVE)))

;; This is pointed to by unfull entries of *TRAP-MISC-CONDITION-TABLE*, set up by
;; the cold load generator.
(DEFUN UNHANDLED-MISC-CONDITION (CONDITION FAULT-PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE FAULT-PC VMA TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR :FORMAT-STRING "Unhandled microcondition ~S"
		:FORMAT-ARGS (,(OR (NTH CONDITION *TRAP-MISC-CONDITIONS*) CONDITION))
		:SHOW-INTERNAL-STATE T))

(DEFUN INITIALIZE-MISC-CONDITION-TABLE ()
  (SETQ *TRAP-MISC-CONDITION-TABLE*
	(ALOC (MAKE-ARRAY (^ 2 (BYTE-SIZE %%TRAP-DESC-CONDITION-1-OP2))
			  :INITIAL-VALUE #'UNHANDLED-MISC-CONDITION) 0)))

(ADD-INITIALIZATION 'INITIALIZE-MISC-CONDITION-TABLE
		    '(INITIALIZE-MISC-CONDITION-TABLE)
		    '(:ONCE))

(DEFUN SIGNAL-TRAP (COND)
  (DECLARE (DBG:ERROR-REPORTER))
  (UNWIND-PROTECT
      (STACK-LET ((VALUES (MULTIPLE-VALUE-LIST (SIGNAL COND))))
	(LEXPR-SEND COND :TRAP-PROCEED VALUES))
    (WHEN (TYPEP COND 'TRAP)
      (LOCATION-MAKUNBOUND (LOCATE-IN-INSTANCE COND 'TRAPPING-FRAME)
			   'TRAPPING-FRAME)
      (LOCATION-MAKUNBOUND (LOCATE-IN-INSTANCE COND 'TRAP-FRAME)
			   'TRAP-FRAME))))

;;; "QA"

(DEFUN LIST-PROBLEMS ()
  (FILLING-OUTPUT ()

    ;; Check for any unhandled misc conditions
    (LOOP FOR CONDITION IN *TRAP-MISC-CONDITIONS*
	  WHEN (EQ (%MEMORY-READ (%POINTER-PLUS *TRAP-MISC-CONDITION-TABLE*
						(SYMEVAL CONDITION)))
		   #'UNHANDLED-MISC-CONDITION)
	    COLLECT (SUBSTRING CONDITION 6) INTO UNHANDLED
	  FINALLY
	    (WHEN UNHANDLED
	      (FORMAT T "~%Warning:  No trap handlers for these conditions: ")
	      (FORMAT-TEXTUAL-LIST UNHANDLED #'PRINC)))

    ;; Check for any nonexistent trap merges.
    ;; This prints bogus warnings sometimes, but it's the best it can do
    ;; without knowledge of the microcode.
    (FLET ((HEURISTICATE-HANDLER-FLAVORS (FUNCTION &AUX FLAVOR FLAVORS)
	     (UNLESS (EQ FUNCTION #'UNHANDLED-MISC-CONDITION)
	       (SI:DO-FUNCTION-CONSTANTS (CONSTANT) FUNCTION
		 (WHEN (AND (OR (SYMBOLP CONSTANT)
				(AND (CL:CONSP CONSTANT)
				     (SYMBOLP (SETQ CONSTANT (CAR CONSTANT)))))
			    (SETQ FLAVOR (FLAVOR:FIND-FLAVOR CONSTANT NIL))
			    (CL:MEMBER 'TRAP (FLAVOR:FLAVOR-ALL-COMPONENTS FLAVOR)))
		   (CL:PUSHNEW CONSTANT FLAVORS))))
	     FLAVORS))
      (LET ((TRAP-FLAVORS (CL:MAP 'CL:VECTOR #'HEURISTICATE-HANDLER-FLAVORS
				  (SI:%FIND-STRUCTURE-HEADER *TRAP-MISC-CONDITION-TABLE*)))
	    (WTA-FLAVORS (HEURISTICATE-HANDLER-FLAVORS #'HANDLE-WRONG-TYPE-ARGUMENT))
	    (REPORTED-ENTRIES NIL)
	    (REPORTED-MERGES NIL))
	(FLET ((ENTRY-FLAVORS (ENTRY)
		 (SELECTOR (LDB %%TRAP-DESC-CONDITION-1-CLASS ENTRY) =
		   (%TRAP-CLASS-MISC-CONDITION
		     (AREF TRAP-FLAVORS (LDB %%TRAP-DESC-CONDITION-1-OP2 ENTRY)))
		   (%TRAP-CLASS-WRONG-TYPE-ARGUMENT WTA-FLAVORS))))
	  (LOOP FOR TABLE BEING THE ARRAY-ELEMENTS OF *TRAP-DISPATCH-TABLES*
		WHEN TABLE DO
	    (LET ((TABLE TABLE))
	      (DECLARE (ARRAY-REGISTER TABLE))
	      (LOOP FOR I BELOW 1_11.
		    AS ENTRY = (AREF TABLE I)
		    WHEN (AND (LDB-TEST %%TRAP-DESC-CONDITION-2-CLASS ENTRY)
			      (NOT (CL:MEMBER ENTRY REPORTED-ENTRIES)))
		      DO (LET ((FLAVORS-1 (ENTRY-FLAVORS (LDB (BYTE 10.  0.) ENTRY)))
			       (FLAVORS-2 (ENTRY-FLAVORS (LDB (BYTE 10. 10.) ENTRY)))
			       (FLAVORS-3 (ENTRY-FLAVORS (LDB (BYTE 10. 20.) ENTRY)))
			       FLAVORS-1-2 NO-MERGE)
			   (FLET ((VERIFY-MERGES (FLAVORS-1 FLAVORS-2 &OPTIONAL MERGE-FLAVORS)
				    (LOOP FOR FLAVOR-1 IN FLAVORS-1 DO
				      (LOOP FOR FLAVOR-2 IN FLAVORS-2 DO
					(LET ((MERGER (CL:ASSOC FLAVOR-2
							(GET FLAVOR-1
							     'TRAP-MERGE-HANDLER-ALIST))))
					  (COND ((NULL MERGER)
						 (PUSH (LIST FLAVOR-1 FLAVOR-2) NO-MERGE))
						(MERGE-FLAVORS
						 (SETQ FLAVORS-1-2
						       (APPEND FLAVORS-1-2
							       (HEURISTICATE-HANDLER-FLAVORS
								 (CADR MERGER)))))))))))
			     (VERIFY-MERGES FLAVORS-1 FLAVORS-2 FLAVORS-3)
			     (WHEN FLAVORS-3
			       (VERIFY-MERGES FLAVORS-1 FLAVORS-3)
			       (VERIFY-MERGES FLAVORS-2 FLAVORS-3)
			       (VERIFY-MERGES FLAVORS-1-2 FLAVORS-3))
			     (WHEN NO-MERGE
			       (WHEN (NULL REPORTED-MERGES)
				 (FORMAT T "~%No merges defined for"))
			       (LOOP FOR PAIR IN NO-MERGE
				     UNLESS (MEMBER PAIR REPORTED-MERGES)
				       DO (CL:APPLY #'FORMAT T "~%  ~A with ~A" PAIR)
					  (PUSH PAIR REPORTED-MERGES)))
			     (PUSH ENTRY REPORTED-ENTRIES)))))))))

    ;; ZL and SYS packages are allowed to be random
    ;; CL and SCL packages are not, for reasons of documentation formatting
    (DOLIST (PKG '("CL" "SCL"))
      (SETQ PKG (PKG-FIND-PACKAGE PKG))
      (DO-EXTERNAL-SYMBOLS (SYM PKG)
	(UNLESS (EQ (SYMBOL-PACKAGE SYM) PKG)
	  (UNLESS (AND (EQ PKG SI:*SCL-PACKAGE*)
		       (EQ (SYMBOL-PACKAGE SYM) SI:*LISP-PACKAGE*))
	    (FORMAT T "~&~S is in the ~S package but its home package is ~S"
		    SYM PKG (SYMBOL-PACKAGE SYM))))))
    ;; Make sure every symbol in CL is also in SCL
    (DO-EXTERNAL-SYMBOLS (SYM SI:*LISP-PACKAGE*)
      (MULTIPLE-VALUE-BIND (OTHER FLAG)
	  (INTERN-SOFT SYM SI:*SCL-PACKAGE*)
	(UNLESS (AND (EQ FLAG :EXTERNAL) (EQ OTHER SYM))
	  (FORMAT T "~&~S is in the CL package but not in the SCL package" SYM))))

    (LOOP FOR FLAVOR IN (FLAVOR:FLAVOR-ALL-DEPENDENTS (FLAVOR:FIND-FLAVOR 'TRAP))
	  AS FL = (FLAVOR:FIND-FLAVOR FLAVOR)
	  UNLESS (OR (FLAVOR::FLAVOR-HAS-COMPILE-FLAVOR-METHODS FL)
		     (FLAVOR::FLAVOR-IS-ABSTRACT FL))
	    COLLECT FLAVOR INTO NO-COMPILE
	  FINALLY (WHEN NO-COMPILE
		    (FORMAT T "~&No COMPILE-FLAVOR-METHODS for these flavors: ")
		    (FORMAT-TEXTUAL-LIST NO-COMPILE #'PRINC)))
    ;;---
    (I-LISP-COMPILER:LIST-PROBLEMS))
  (IF (MEMQ SI:*WHO-CALLS-MODE* '(:DISABLED :UNINITIALIZED))
      (FORMAT T "~&Can't check for globally uncompiled errors; Who-Calls isn't enabled.")
      (SI:CHECK-WHO-CALLS-MODE-FOR-LOOKUP-MAYBE-WARN)
      (SI:UPDATE-WHO-CALLS-DATABASE)
      (LET ((CALLERS NIL))			;of ERROR or SIGNAL
	(FLET ((COLLECT (CALLER IGNORE)
		 (CL:PUSHNEW CALLER CALLERS)))
	  (SI:MAP-OVER-CALLERS 'ERROR #'COLLECT :CALLED-HOW :FUNCTION)
	  (SI:MAP-OVER-CALLERS 'SIGNAL #'COLLECT :CALLED-HOW :FUNCTION))
	;; Use BAR 2 so that callees save it.
	(WITH-BLOCK-REGISTERS (2)
	  (LOOP WITH MOBY[tm] = (FLAVOR:FLAVOR-ALL-DEPENDENTS (FLAVOR:FIND-FLAVOR 'CONDITION))
		WITH FL
		WITH TABLE = (CL:MAKE-HASH-TABLE :SIZE (LENGTH CALLERS))
		FOR CALLER IN CALLERS
		WHEN (TYPEP CALLER :COMPILED-FUNCTION)
		  DO ;; Skip the entry instruction word; it can't contain a constant.
		     ;; Loop until we see the sequencing fence.
		     (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS CALLER 1))
		     (LOOP AS OBJECT = (%BLOCK-READ 2 :CYCLE-TYPE %MEMORY-SCAVENGE
						    :SET-CDR-NEXT NIL :PREFETCH NIL)
			   UNTIL (= (LDB %%Q-CDR-CODE-WITHIN-TAG (%TAG OBJECT))
				    SEQUENCING-FENCE)
			   WHEN (AND (SYMBOLP OBJECT)
				     (MEMQ OBJECT MOBY[tm])
				     (SETQ FL (FLAVOR:FIND-FLAVOR OBJECT NIL))
				     (NOT (FLAVOR::FLAVOR-HAS-COMPILE-FLAVOR-METHODS FL))
				     (NOT (FLAVOR::FLAVOR-IS-ABSTRACT FL)))
			     DO (PUSH (SI:COMPILED-FUNCTION-NAME CALLER)
				      (GETHASH OBJECT TABLE)))
		FINALLY
		  (UNLESS (ZEROP (CL:HASH-TABLE-COUNT TABLE))
		    (FORMAT T "~%The following errors may require COMPILE-FLAVOR-METHODs:~%")
		    (FORMATTING-TABLE ()
		      (FORMATTING-COLUMN-HEADINGS ()
			(FORMATTING-CELL () (CL:WRITE-STRING "Error flavor:"))
			(FORMATTING-CELL () (CL:WRITE-STRING "Used by:")))
		      (LOOP FOR FUNCTIONS BEING THE HASH-ELEMENTS OF TABLE WITH-KEY OBJECT
			    DO (FORMATTING-ROW ()
				 (FORMAT-CELL OBJECT #'PRIN1)
				 (FORMATTING-CELL ()
				   (FILLING-OUTPUT ()
				     (FORMAT-TEXTUAL-LIST FUNCTIONS #'PRIN1))))))))))))


(DEFMACRO OPCODE-SELECT (INSTRUCTION &BODY CLAUSES)
  (FLET ((CONVERT (SYMBOL)
	   (OR (INTERN-LOCAL-SOFT (STRING-APPEND "*" SYMBOL "-OPCODE*")
				  "I-LISP-COMPILER")
	       (ERROR "Unknown opcode ~S" SYMBOL))))
    `(SELECTOR (LDB %%PACKED-INSTRUCTION-OPCODE ,INSTRUCTION) =
       . ,(LOOP FOR CLAUSE IN CLAUSES
		COLLECT (COND ((AND (SYMBOLP (CAR CLAUSE))
				    (CL:MEMBER (CAR CLAUSE) '(T OTHERWISE) :TEST #'STRING=))
			       CLAUSE)
			      ((ATOM (CAR CLAUSE))
			       `(,(CONVERT (CAR CLAUSE)) . ,(CDR CLAUSE)))
			      (T `(,(MAPCAR #'CONVERT (CAR CLAUSE)) . ,(CDR CLAUSE))))))))

(DEFMACRO CALL-DATA-TYPE-P (DTP)
  `(= (LDB (BYTE 3 3) ,DTP)
      (LDB (BYTE 3 3) DTP-CALL-COMPILED-EVEN)))

;;---- This n-values stuff needs to be canonicalized here so that, for example,
;;---- EQ-NO-POP returns 1 value.
(DEFUN PC-INFO (PC)
  (DECLARE (VALUES NAME N-ARGS N-VALUES FORMAT))
  (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC)))
    (IF INSTRUCTION
	(LET ((FORMAT (I-LISP-COMPILER:GET-OPCODE-FORMAT
			(LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))))
	  (VALUES (I-LISP-COMPILER:GET-OPCODE-PRETTY-NAME
		    (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))
		  (POP FORMAT)
		  (POP FORMAT)
		  (CAR FORMAT)))
	(LET ((DTP (%P-DATA-TYPE PC)))
	  (MULTIPLE-VALUE-BIND (N-ARGS N-VALUES)
	      (IF (CALL-DATA-TYPE-P DTP)
		  (VALUES NIL NIL)
		  (VALUES 0 1))
	    (VALUES (DATA-TYPE-INSTRUCTION-NAME DTP) N-ARGS N-VALUES
		    '(FULL-WORD-INSTRUCTION)))))))

(CL:PROCLAIM '(CL:INLINE PC-NEXT-PC))
(DEFUN PC-NEXT-PC (PC)
  (SELECTOR (%P-LDB %%Q-INSTRUCTION-SEQUENCING PC) =
    (SEQUENCING-PC-EVEN+2-ODD+3
      (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	  (%POINTER-PLUS PC 1)
	  (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC 2)))
    (SEQUENCING-PC+1
      (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	  (%MAKE-POINTER DTP-ODD-PC PC)
	  (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC 1)))
    (SEQUENCING-PC-1
      (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	  (%MAKE-POINTER-OFFSET DTP-ODD-PC PC -1)
	  (%MAKE-POINTER DTP-EVEN-PC PC)))
    (OTHERWISE
      (ERROR "Can't determine next PC for ~S" PC))))
(CL:PROCLAIM '(CL:NOTINLINE PC-NEXT-PC))

;; This doesn't work for the first PC in a function.
(DEFUN PC-PREVIOUS-PC (PC)
  (PROG ()
	(WHEN (TYPE-MEMBER PC DTP-EVEN-PC)
	  (SELECTOR (%P-LDB %%Q-INSTRUCTION-SEQUENCING (%POINTER-PLUS PC -1)) =
	    (SEQUENCING-PC+1
	      (RETURN (%MAKE-POINTER-OFFSET DTP-ODD-PC PC -1)))
	    (SEQUENCING-PC-EVEN+2-ODD+3
	      (RETURN (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC -1)))
	    (OTHERWISE (GO ERROR))))
	(SELECTOR (%P-LDB %%Q-INSTRUCTION-SEQUENCING PC) =
	  (SEQUENCING-PC+1
	    (RETURN (%MAKE-POINTER DTP-EVEN-PC PC)))
	  (SEQUENCING-PC-EVEN+2-ODD+3
	    (SELECTOR (%P-LDB %%Q-INSTRUCTION-SEQUENCING (%POINTER-PLUS PC 1)) =
	      (SEQUENCING-PC-1
		(RETURN (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC 1)))))
	  (SEQUENCING-PC-1
	    (SELECTOR (%P-LDB %%Q-INSTRUCTION-SEQUENCING (%POINTER-PLUS PC 1)) =
	      (SEQUENCING-PC-1
		(RETURN (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC 1))))))
     ERROR
	(RETURN (ERROR "Can't determine previous PC for ~S" PC))))

;;---- integrate with disassembler...
(DEFUN DATA-TYPE-INSTRUCTION-NAME (DTP)
  (OR (CDR (CL:ASSOC DTP '((#.DTP-EXTERNAL-VALUE-CELL-POINTER . PUSH-INDIRECT)
			   (#.DTP-CALL-COMPILED-EVEN          . CALL-COMPILED-EVEN)
			   (#.DTP-CALL-COMPILED-ODD           . CALL-COMPILED-ODD)
			   (#.DTP-CALL-INDIRECT               . CALL-INDIRECT)
			   (#.DTP-CALL-GENERIC                . CALL-GENERIC)
			   (#.DTP-CALL-COMPILED-EVEN-PREFETCH . CALL-COMPILED-EVEN-PREFETCH)
			   (#.DTP-CALL-COMPILED-ODD-PREFETCH  . CALL-COMPILED-ODD-PREFETCH)
			   (#.DTP-CALL-INDIRECT-PREFETCH      . CALL-INDIRECT-PREFETCH)
			   (#.DTP-CALL-GENERIC-PREFETCH       . CALL-GENERIC-PREFETCH))))
      'PUSH-CONSTANT))

(DEFMACRO DEFINE-TRAP-DISPATCH (NAME ARGLIST &BODY BODY &ENVIRONMENT ENV)
  "Arglist is (condition pc vma trapping-frame trap-frame)"
  (MULTIPLE-VALUE-BIND (DECLS REAL-BODY)
      (FIND-BODY-DECLARATIONS BODY ENV)
    `(MULTIPLE-DEFINITION ,NAME DEFINE-TRAP-DISPATCH
       (DEFUN (:PROPERTY ,NAME TRAP-DISPATCH) ,ARGLIST
	 ,@DECLS
	 (DECLARE (FUNCTION-PARENT ,NAME DEFINE-TRAP-DISPATCH))
	 (BLOCK ,NAME . ,REAL-BODY))
       (SET-MISC-TRAP #'(:PROPERTY ,NAME TRAP-DISPATCH)
		      ,(SYMEVAL (INTERN (STRING-APPEND "%TRAP-" NAME) "DEBUGGER"))))))

(DEFUN SET-MISC-TRAP (FUNCTION INDEX)
  (SETF (AREF (%FIND-STRUCTURE-HEADER *TRAP-MISC-CONDITION-TABLE*) INDEX) FUNCTION))

(DEFMACRO DEFINE-TRAP-MERGE (NAME
			     (TRAP1 &REST TRAP1-FLAVORS)
			     (TRAP2 &REST TRAP2-FLAVORS)
			     &BODY BODY)
  `(MULTIPLE-DEFINITION ,NAME DEFINE-TRAP-MERGE
     (DEFUN ,NAME (,TRAP1 ,TRAP2)
       (DECLARE (FUNCTION-PARENT ,NAME DEFINE-TRAP-MERGE))
       . ,BODY)
     (INSTALL-TRAP-MERGE #',NAME ',TRAP1-FLAVORS ',TRAP2-FLAVORS)))

(DEFUN INSTALL-TRAP-MERGE (FUNCTION TRAP1-FLAVORS TRAP2-FLAVORS)
  (LOOP FOR FLAVOR1 IN TRAP1-FLAVORS DO
    (LOOP FOR FLAVOR2 IN TRAP2-FLAVORS DO
      (LET* ((ALIST (GET FLAVOR1 'TRAP-MERGE-HANDLER-ALIST))
	     (ELEM (CL:ASSOC FLAVOR2 ALIST)))
	(IF ELEM
	    (SETF (CADR ELEM) FUNCTION)
	  (SETQ ELEM (LIST FLAVOR2 FUNCTION))
	  (SETF (GET FLAVOR1 'TRAP-MERGE-HANDLER-ALIST)
		(CONS ELEM ALIST)))))))
	


;;;; Base flavor

(DEFFLAVOR TRAP
	(MICROSTATE
	 MACRO-PC
	 VMA
	 TRAPPING-FRAME				;Frame in which the trap occurred.
	 TRAP-FRAME				;Frame for ERROR-TRAP-HANDLER.
	 (ADDITIONAL-FORMAT-STRING NIL)		;For use by trap merging
	 (ADDITIONAL-FORMAT-ARGS NIL)		;Ditto
	 (SHOW-INTERNAL-STATE NIL))
	()
  (:REQUIRED-FLAVORS DEBUGGER-CONDITION)
  :INITABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES MACRO-PC)
  (:METHOD-COMBINATION :TRAP-PROCEED :CASE
                       :PROCEED :CASE
                       :DOCUMENT-PROCEED-TYPE :CASE)
  :ABSTRACT-FLAVOR
  (:FUNCTIONS FRAME-AT-ENTRY-INSTRUCTION-P))	;forward reference

(DEFMETHOD (MAKE-INSTANCE TRAP) (&REST init-options)
  (SETQ PROCEED-TYPES (getf init-options :proceed-types)
		      #+ignore  ;;this is what it was that made trap on exit
		      ;;;not have a proceed type sometimes -- Kalman
		      '()))

(DEFCONST *DONT-RETURN-FROM-THESE-INSTRUCTIONS*
	  'COMPILER:(START-CALL
		     FINISH-CALL-N
		     FINISH-CALL-N-APPLY
		     FINISH-CALL-TOS
		     FINISH-CALL-TOS-APPLY
		     ENTRY-REST-ACCEPTED
		     ENTRY-REST-NOT-ACCEPTED
		     EXTENDED-ENTRY-REST-ACCEPTED
		     EXTENDED-ENTRY-REST-NOT-ACCEPTED
		     RETURN-SINGLE
		     RETURN-MULTIPLE
		     RETURN-KLUDGE
		     %JUMP))

(DEFMETHOD (MAKE-INSTANCE TRAP :AFTER) (&REST IGNORE)
  ;; If the instruction is an entry instruction, retrying it is just like C-M-R.
  ;; If it is not a built-in type instruction, you cannot return from it like a function.
  (SETQ PROCEED-TYPES (APPEND PROCEED-TYPES
			      (MULTIPLE-VALUE-BIND (NAME NIL RETURN-P)
				  (PC-INFO MACRO-PC)
				(COND ((EQL RETURN-P 0)
				       (WHEN (CL:MEMBER NAME
							*DONT-RETURN-FROM-THESE-INSTRUCTIONS*)
					 (SETQ RETURN-P NIL)))
				      ((NOT (FIXNUMP RETURN-P))
				       (SETQ RETURN-P NIL)))
				(LET ((RETRY-P (NOT (FRAME-AT-ENTRY-INSTRUCTION-P
						      TRAPPING-FRAME TRAP-FRAME))))
				  ;;if these were already passed into trap's proceed-types
				  ;;list, don't add them a second time. -- Kalman
				  (when (and return-p (memq :return-values proceed-types))
				    (setq return-p nil))
				  (when (and retry-p (memq :no-action proceed-types))
				    (setq retry-p nil))
				  (COND ((AND RETURN-P RETRY-P) '(:RETURN-VALUES :NO-ACTION))
					(RETURN-P '(:RETURN-VALUES))
					(RETRY-P '(:NO-ACTION))))))))

(DEFMETHOD (REPORT TRAP :AFTER) (STREAM)
  (WHEN ADDITIONAL-FORMAT-STRING
    (FORMAT STREAM ", and~%")
    (CL:APPLY #'FORMAT STREAM ADDITIONAL-FORMAT-STRING ADDITIONAL-FORMAT-ARGS))
  (WHEN SHOW-INTERNAL-STATE
    (FORMAT STREAM "~%~A, " MACRO-PC)
    (IF (NUMBERP MICROSTATE)
	(FORMAT STREAM "VMA ~\SI:ADDRESS\, Microstate ~O" VMA MICROSTATE)
	(FORMAT STREAM "Trap in exception handler ~a" MICROSTATE))))

;;; Retry the instruction that got the error, maybe something has been fixed.
(DEFMETHOD (PROCEED TRAP :NO-ACTION) () :NO-ACTION)

(DEFMETHOD (DOCUMENT-PROCEED-TYPE TRAP :NO-ACTION) (STREAM)
  (FORMAT STREAM "Retry the ~A instruction" (PC-INFO MACRO-PC)))

(DEFUN-IN-FLAVOR (FRAME-AT-ENTRY-INSTRUCTION-P TRAP) (FRAME NEXT)
  (LET* ((OPEN (SPARTAN-FRAME-NEXT-OPEN-FRAME FRAME NEXT))
	 (PC (FRAME-CALLER-CONTINUATION OPEN)))
    (AND (TYPE-MEMBER PC DTP-EVEN-PC)
	 (ZEROP (%POINTER-DIFFERENCE (%FIND-STRUCTURE-HEADER PC) PC)))))

;;; If the instruction is the entry instruction, we actually restart the frame.
;;; The microcode could be responsible for setting pc=restart-trapped-call-escape-pc,
;;; but we already know so much it probably isn't worth it.
(DEFMETHOD (:TRAP-PROCEED TRAP :NO-ACTION) ()
  (IF (FRAME-AT-ENTRY-INSTRUCTION-P TRAPPING-FRAME TRAP-FRAME)
      (%RESTART-FRAME TRAPPING-FRAME (FRAME-FUNCTION TRAPPING-FRAME))
      ;; Just return from the trap frame
      NIL))

(DEFMETHOD (PROCEED TRAP :RETURN-VALUES) (&OPTIONAL (VALUES NIL VALUES-P))
  (AND (NOT VALUES-P)
       (MULTIPLE-VALUE-BIND (NIL NIL NVALS)
	   (PC-INFO MACRO-PC)
	 (COND ((NULL NVALS))
	       ((ZEROP NVALS))
	       ((= NVALS 1)
		(SETQ VALUES (LIST (PROMPT-AND-READ :EVAL-FORM
						    "Form to evaluate and return: "))))
	       (T
		(SETQ VALUES (LOOP FOR I FROM 0 BELOW NVALS
				   COLLECT (PROMPT-AND-READ
					     :EVAL-FORM
					     "Form to evaluate and use as the ~:R value: "
					     (1+ I))))
		))))
  (VALUES :RETURN-VALUES VALUES))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE TRAP :RETURN-VALUES) (STREAM)
  (MULTIPLE-VALUE-BIND (NAME NIL NVALS)
      (PC-INFO MACRO-PC)
    (FORMAT STREAM "Return ~[~;a value ~:;~:*~D values ~]from the ~A instruction"
	    NVALS NAME)))

(DEFMETHOD (EXECUTE-HELPER-FUNCTION TRAP) (CODE)
  (LET* ((CONTINUATION (ASSEMBLE-HELPER-FUNCTION CODE))
	 ;; Find the frame which holds the error handler continuation.
	 (FRAME (SEARCH-FOR-NEXT-OPEN-FRAME TRAP-FRAME %CURRENT-STACK-GROUP)))
    ;; Force the error handler to return to the new continuation
    (SETF (FRAME-CALLER-CONTINUATION FRAME) CONTINUATION)
    ;; Return from the trap frame
    NIL))

;;; Return from an instruction, given things to put on the stack.
;;; Replace the arguments with the values, via an escape routine that spreads the list.
;;; This requires that the hole made by signal-error be two long in the case of an
;;; instruction of no stack arguments.
(DEFMETHOD (:TRAP-PROCEED TRAP :RETURN-VALUES) (VALUES)
  (MULTIPLE-VALUE-BIND (NIL NIL NVALS FORMAT)
      (PC-INFO MACRO-PC)
    ;; Check if known.  Was not offered to user if unknown.
    (UNLESS NVALS (SETQ NVALS 0))
    (AND ( (LENGTH VALUES) NVALS)
	 (FERROR NIL "The values ~S were not correct to return with." VALUES))
    ;; Find out how many arguments really have to be popped.
    ;; (That is, exclude any immediate arguments.)
    (MULTIPLE-VALUE-BIND (NIL NIL NIL ARGUMENTS-ON-STACK)
	(IF (EQ (CAR FORMAT) 'FULL-WORD-INSTRUCTION)
	    (VALUES NIL NIL NIL 0)
	    (DECODE-PACKED-INSTRUCTION-ARGUMENT
	      (PACKED-INSTRUCTION-FROM-PC MACRO-PC)
	      TRAPPING-FRAME TRAP-FRAME 0))
      (EXECUTE-HELPER-FUNCTION SELF
	`((SET-SP-TO-ADDRESS (SP ,ARGUMENTS-ON-STACK))
	  ,@(LOOP FOR VALUE IN VALUES COLLECT `(PUSH-CONSTANT ,VALUE))
	  ;; ,(%MAKE-POINTER DTP-CALL-INDIRECT (LOCF #'CL:BREAK))
	  ;; (FINISH-CALL-N (FP 1)) ;FINISH-CALL-0-EFFECT
	  ,(PC-NEXT-PC MACRO-PC)
	  (%JUMP (SP POP)))))))

(DEFMETHOD (RELOCATE-FRAME-POINTERS TRAP) ()
  (SETQ TRAPPING-FRAME (FOLLOW-CELL-FORWARDING TRAPPING-FRAME NIL))
  (SETQ TRAP-FRAME (FOLLOW-CELL-FORWARDING TRAP-FRAME NIL)))

(DEFMETHOD (FRAME-PC-INCREMENTED-P TRAP) (FRAME)
  ;; The PC is incremented in all frames except for the one in which
  ;; the trap actually occurred.
  (NEQ FRAME TRAPPING-FRAME))

(DEFMETHOD (DESCRIBE-CONDITION-FOR-BUG-REPORT TRAP :AFTER) ()
  (LET ((PACKAGE (PKG-FIND-PACKAGE "Debugger")))
    (COND ((NUMBERP MICROSTATE)
	   (FORMAT T "Trap microstate = #o~O (Rev~D)"
		   MICROSTATE (%READ-INTERNAL-REGISTER %REGISTER-CHIP-REVISION))
	   (FORMAT T "~%From Rev~D error table version ~D:"
		   (%READ-INTERNAL-REGISTER %REGISTER-CHIP-REVISION)
		   (AREF *TRAP-DISPATCH-TABLE-VERSIONS*
			 (%READ-INTERNAL-REGISTER %REGISTER-CHIP-REVISION)))
	   (LET ((ENTRY (%MEMORY-READ (%POINTER-PLUS *TRAP-DISPATCH-TABLE*
						     (LDB (BYTE 11. 0) MICROSTATE)))))
	     (PRINT-TRAP-DISPATCH-TABLE-ENTRY
	       (LDB (BYTE 11. 0) MICROSTATE)
	       ENTRY)
	     (WHEN (LDB-TEST %%TRAP-DESC-VMA-VALID ENTRY)
	       (LET* ((INHIBIT-SCHEDULING-FLAG T)	;TO PREVENT FLIPPING
		      (POINTER (%POINTER VMA))
		      (REGION (%REGION-NUMBER POINTER)))
		 (WHEN REGION
		   (LET* ((REGION-ORIGIN (REGION-ORIGIN REGION))
			  (REGION-FREE (%POINTER-PLUS REGION-ORIGIN
						      (SI:REAL-REGION-FREE-POINTER REGION)))
			  (FROM (%POINTER-PLUS
				  POINTER
				  (- (MIN (%POINTER-DIFFERENCE POINTER REGION-ORIGIN) 20))))
			  (TO (%POINTER-PLUS
				POINTER
				(MIN (%POINTER-DIFFERENCE REGION-FREE POINTER) 20))))
		     (SCL:INDENTING-OUTPUT (STANDARD-OUTPUT "  ")
		       (WITH-CHARACTER-STYLE (*CHARACTER-STYLE-FOR-BUG-MAIL-PROLOGUE*)
			 (SI:TRANSPORT-ERROR-ADDITIONAL-INFO NIL FROM TO)))))))))
	  (T
	   (FORMAT T "Trap in exception handler ~a" MICROSTATE)))
    #-VLM
    (SCL:INDENTING-OUTPUT (STANDARD-OUTPUT "  ")
      (WITH-CHARACTER-STYLE (*CHARACTER-STYLE-FOR-BUG-MAIL-PROLOGUE*)
	(CP::PRINT-MEMORY-ECC :VERBOSE T :SPECIFIED-NO-OF-ELEMENTS STORAGE::*ECC-LOG-SIZE*)))
    (SEND STANDARD-OUTPUT :FRESH-LINE)))

(DEFUN INSTRUCTION-CAN-STORE-NEW-ARGUMENT (INSTRUCTION)
  (SELECTOR (LDB %%PACKED-INSTRUCTION-ADDRESSING-MODE INSTRUCTION) =
    (STACK-ADDRESSING-MODE-STACK-POINTER
      (LDB-TEST %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION))
    (STACK-ADDRESSING-MODE-IMMEDIATE NIL)
    (OTHERWISE T)))

(DEFUN INSTRUCTION-SUBSCRIPT-ARGUMENT (INSTRUCTION)
  (OPCODE-SELECT INSTRUCTION
    ((FAST-AREF-1 PUSH-INSTANCE-VARIABLE PUSH-ADDRESS-INSTANCE-VARIABLE) 1)
    ((FAST-ASET-1 AREF-1 ALOC-1 ARRAY-LEADER ALOC-LEADER %INSTANCE-REF %INSTANCE-LOC
      POP-INSTANCE-VARIABLE MOVEM-INSTANCE-VARIABLE) 2)
    ((ASET-1 STORE-ARRAY-LEADER %INSTANCE-SET) 3)
    (OTHERWISE (ERROR "The ~A instruction doesn't take a subscript argument"
		      (ILC:GET-OPCODE-PRETTY-NAME
			(LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))))))    

(DEFUN INSTRUCTION-ARGUMENT-NAME (PC)
  (MULTIPLE-VALUE-BIND (FUNCTION OFFSET)
      (SI:DECODE-PC PC)
    (MULTIPLE-VALUE-BIND (MODE OFFSET ENTRY)
	(ILC:DECODE-ADDRESS-OPERAND
	  (PACKED-INSTRUCTION-FROM-PC PC)
	  (AREF (ILC:COMPUTE-STACK-DESCRIPTION FUNCTION) OFFSET))
      (WHEN ENTRY (SETQ ENTRY (ILC:STACK-ENTRY-NAME ENTRY)))
      (VALUES ENTRY MODE OFFSET))))

(DEFUN-IN-FLAVOR (CALL-WITH-NEW-ARGUMENTS TRAP) (BASH-P &REST ARGUMENT-NUMBERS-AND-VALUES)
  (LOOP WITH INSTRUCTION = (PACKED-INSTRUCTION-FROM-PC MACRO-PC)
	WITH FORMAT
	FOR (NUMBER VALUE) ON ARGUMENT-NUMBERS-AND-VALUES BY 'CDDR DO
    (MULTIPLE-VALUE-BIND (NIL LOCATION N-ARGUMENTS)
	(DECODE-PACKED-INSTRUCTION-ARGUMENT INSTRUCTION TRAPPING-FRAME TRAP-FRAME NUMBER)
      (COND ((AND LOCATION
		  (OR (NOT (EQL NUMBER N-ARGUMENTS))
		      BASH-P
		      (= (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION)
			 (DPB STACK-ADDRESSING-MODE-STACK-POINTER
			      %%PACKED-INSTRUCTION-ADDRESSING-MODE 0))))
	     ;; Case 1:  Store argument onto stack and retry instruction
	     (SETF (LOCATION-CONTENTS LOCATION) VALUE))
	    ((MEMQ 'COMPILER:POP
		   (SETQ FORMAT (THIRD (ILC:GET-OPCODE-FORMAT
					 (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION)))))
	     ;; Case 2:  Execute a helper function using SP|POP addressing.
	     (EXECUTE-HELPER-FUNCTION SELF
	       `((PUSH-CONSTANT ,VALUE)
		 (,(ILC:GET-OPCODE-PRETTY-NAME
		     (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))
		  (SP POP))
		 ,(PC-NEXT-PC MACRO-PC)
		 (%JUMP (SP POP)))))
	    (T (LET ((TYPE (CL:SET-DIFFERENCE FORMAT 'COMPILER:(LP FP SP POP))))
		 (IF (AND (CL:CONSP TYPE)
			  (NULL (CDR TYPE))
			  (ILC:POSSIBLE-IMMEDIATE-OPERAND? VALUE (CAR TYPE)))
		     ;; Case 3:  Execute a helper function using immediate addressing.
		     (EXECUTE-HELPER-FUNCTION SELF
		       `((,(ILC:GET-OPCODE-PRETTY-NAME
			     (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))
			  ,VALUE)
			 ,(PC-NEXT-PC MACRO-PC)
			 (%JUMP (SP POP))))
		      ;; Case 4:  Punt.
		      (ERROR "Can't fit new argument into immediate operand"))))))))

;;;; Individual routines

(DEFFLAVOR TRAP-FERROR
	()
	(TRAP FERROR))

(DEFUN FORMAT-MERGE (STRING ARGS)
  (CL:APPLY #'FORMAT FORMAT:*FORMAT-OUTPUT* STRING ARGS))

(DEFUN REMOVE-KEYWORDS-FROM-PLIST (PLIST KEYWORDS)
  (LOOP FOR (KEY VAL) ON PLIST BY 'CDDR
	WHEN (NOT (MEMQ KEY KEYWORDS))
	  APPEND `(,KEY ,VAL)))

;; TRAP1 can be the result of a merge, but TRAP2 can't.
(DEFINE-TRAP-MERGE MERGE-TRAP-FERROR-1
		   (TRAP1 TRAP-FERROR)
		   (TRAP2 WRONG-TYPE-ARGUMENT-TRAP
			  SUBSCRIPT-OUT-OF-BOUNDS-TRAP)
  (IF (NOT (GETF (CDR TRAP1) :ADDITIONAL-FORMAT-STRING))
      `(,(CAR TRAP2)
	,@(REMOVE-KEYWORDS-FROM-PLIST (CDR TRAP2) '(:SHOW-INTERNAL-STATE))
	:ADDITIONAL-FORMAT-STRING ,(GETF (CDR TRAP1) :FORMAT-STRING)
	:ADDITIONAL-FORMAT-ARGS ,(GETF (CDR TRAP1) :FORMAT-ARGS)
	,@(WHEN (OR (GETF (CDR TRAP1) :SHOW-INTERNAL-STATE)
		    (GETF (CDR TRAP2) :SHOW-INTERNAL-STATE))
	    '(:SHOW-INTERNAL-STATE T)))
      `(,(CAR TRAP2)
	,@(REMOVE-KEYWORDS-FROM-PLIST (CDR TRAP2) '(:SHOW-INTERNAL-STATE
						    :ADDITIONAL-FORMAT-STRING
						    :ADDITIONAL-FORMAT-ARGS))
	:ADDITIONAL-FORMAT-STRING "~V,VQ, and~%~V,VQ"
	:ADDITIONAL-FORMAT-ARGS (,(GETF (CDR TRAP1) :FORMAT-STRING)
				 ,(GETF (CDR TRAP1) :FORMAT-ARGS)
				 ,#'FORMAT-MERGE
				 ,(GETF (CDR TRAP1) :ADDITIONAL-FORMAT-STRING)
				 ,(GETF (CDR TRAP1) :ADDITIONAL-FORMAT-ARGS)
				 ,#'FORMAT-MERGE)
	,@(WHEN (OR (GETF (CDR TRAP1) :SHOW-INTERNAL-STATE)
		    (GETF (CDR TRAP2) :SHOW-INTERNAL-STATE))
	    '(:SHOW-INTERNAL-STATE T)))))

;; TRAP1 can be the result of a merge, but TRAP2 can't.
(DEFINE-TRAP-MERGE MERGE-TRAP-FERROR-2
		   (TRAP1 TRAP-FERROR
			  WRONG-TYPE-ARGUMENT-TRAP
			  WRONG-TYPE-ARGUMENTS-TRAP
			  DIVIDE-BY-ZERO-TRAP
			  SUBSCRIPT-OUT-OF-BOUNDS-TRAP)
		   (TRAP2 TRAP-FERROR)
  (IF (NOT (GETF (CDR TRAP1) :ADDITIONAL-FORMAT-STRING))
      `(,(CAR TRAP1)
	,@(REMOVE-KEYWORDS-FROM-PLIST (CDR TRAP1) '(:SHOW-INTERNAL-STATE))
	:ADDITIONAL-FORMAT-STRING ,(GETF (CDR TRAP2) :FORMAT-STRING)
	:ADDITIONAL-FORMAT-ARGS ,(GETF (CDR TRAP2) :FORMAT-ARGS)
	,@(WHEN (OR (GETF (CDR TRAP1) :SHOW-INTERNAL-STATE)
		    (GETF (CDR TRAP2) :SHOW-INTERNAL-STATE))
	    '(:SHOW-INTERNAL-STATE T)))
      `(,(CAR TRAP1)
	,@(REMOVE-KEYWORDS-FROM-PLIST (CDR TRAP1) '(:SHOW-INTERNAL-STATE
						    :ADDITIONAL-FORMAT-STRING
						    :ADDITIONAL-FORMAT-ARGS))
	:ADDITIONAL-FORMAT-STRING "~V,VQ, and~%~V,VQ"
	:ADDITIONAL-FORMAT-ARGS (,(GETF (CDR TRAP1) :ADDITIONAL-FORMAT-STRING)
				 ,(GETF (CDR TRAP1) :ADDITIONAL-FORMAT-ARGS)
				 ,#'FORMAT-MERGE
				 ,(GETF (CDR TRAP2) :FORMAT-STRING)
				 ,(GETF (CDR TRAP2) :FORMAT-ARGS)
				 ,#'FORMAT-MERGE)
	,@(WHEN (OR (GETF (CDR TRAP1) :SHOW-INTERNAL-STATE)
		    (GETF (CDR TRAP2) :SHOW-INTERNAL-STATE))
	    '(:SHOW-INTERNAL-STATE T)))))

(DEFFLAVOR UNKNOWN-TRAP-COMBINATION
	(TRAP1 TRAP2 TRAP3)
	(TRAP ERROR)
  (:INITABLE-INSTANCE-VARIABLES TRAP1 TRAP2))

(DEFMETHOD (MAKE-INSTANCE UNKNOWN-TRAP-COMBINATION) (&REST IGNORE)
  (SETQ SHOW-INTERNAL-STATE T)
  (COND ((EQ (CAR TRAP1) 'UNKNOWN-TRAP-COMBINATION)
	 (PSETQ TRAP1 (GET TRAP1 :TRAP1)
		TRAP2 (GET TRAP1 :TRAP2)
		TRAP3 TRAP2))
	((EQ (CAR TRAP2) 'UNKNOWN-TRAP-COMBINATION)
	 (PSETQ TRAP2 (GET TRAP2 :TRAP1)
		TRAP3 (GET TRAP2 :TRAP2)))
	(T (SETQ TRAP3 NIL))))

(DEFMETHOD (DBG:REPORT UNKNOWN-TRAP-COMBINATION) (STREAM)
  (FORMAT STREAM "Unable to combine the following microcode error conditions:")
  (FLET ((PRINT-CONDITION (CONDITION N STREAM)
	   (FORMAT STREAM "~%  Condition ~D:  ~S" N CONDITION)))
    (PRINT-CONDITION TRAP1 1 STREAM)
    (PRINT-CONDITION TRAP2 2 STREAM)
    (WHEN TRAP3
      (PRINT-CONDITION TRAP3 3 STREAM))))

;;; Transporter traps
(DEFFLAVOR TRANS-TRAP () (TRAP)
  :ABSTRACT-FLAVOR)

;;--- Either this has to prune out instructions it can't emulate, or we have to
;;--- ensure that :NEW-VALUE can emulate all instructions (eg BIND-LOCATIVE, ASSOC).
(DEFMETHOD (MAKE-INSTANCE TRANS-TRAP :AFTER) (&REST IGNORE)
  (SETQ PROCEED-TYPES (APPEND '(:NEW-VALUE :STORE-NEW-VALUE)
			      (REMQ :RETURN-VALUES PROCEED-TYPES))))

;;--- :PROCEED has to validate the value in the case of DTP-CALL-GENERIC
(DEFMETHOD (:TRAP-PROCEED TRANS-TRAP :NEW-VALUE)
	   (VALUE &AUX INSTRUCTION NAME)
  (SETQ INSTRUCTION (PACKED-INSTRUCTION-FROM-PC MACRO-PC))
  (COND ((NULL INSTRUCTION)
	 ;; This is a full word instruction.
	 ;; If it's a call, we have to emulate the call.  Otherwise, just push
	 ;; the value.
	 (IF (NOT (TYPE-MEMBER (%MEMORY-READ MACRO-PC :CYCLE-TYPE %MEMORY-SCAVENGE)
			       DTP-CALL-COMPILED-EVEN
			       DTP-CALL-COMPILED-ODD
			       DTP-CALL-INDIRECT
			       DTP-CALL-GENERIC
			       DTP-CALL-COMPILED-EVEN-PREFETCH
			       DTP-CALL-COMPILED-ODD-PREFETCH
			       DTP-CALL-INDIRECT-PREFETCH
			       DTP-CALL-GENERIC-PREFETCH))
	     (SEND SELF :TRAP-PROCEED :RETURN-VALUES (LIST VALUE))
	     (EXECUTE-HELPER-FUNCTION SELF
				      `((PUSH-CONSTANT ,VALUE)
					(START-CALL (SP POP))
					,(PC-NEXT-PC MACRO-PC)
					(%JUMP (SP POP))))))
	((CL:MEMBER (SETQ NAME (I-LISP-COMPILER:GET-OPCODE-PRETTY-NAME
				 (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION)))
		    '(CAR CDR AREF-1 FAST-AREF-1 ARRAY-LEADER PUSH-LEXICAL-VAR
		      PUSH-INSTANCE-VARIABLE PUSH-INSTANCE-VARIABLE-ORDERED %INSTANCE-REF
		      %MEMORY-READ))
	 (SEND SELF :TRAP-PROCEED :RETURN-VALUES (LIST VALUE)))
	((EQ NAME 'START-CALL)
	 (MULTIPLE-VALUE-BIND (NIL NIL NIL ARGUMENTS-ON-STACK)
	     (DECODE-PACKED-INSTRUCTION-ARGUMENT
	       (PACKED-INSTRUCTION-FROM-PC MACRO-PC)
	       TRAPPING-FRAME TRAP-FRAME 0)
	   (EXECUTE-HELPER-FUNCTION SELF
	     `((SET-SP-TO-ADDRESS (SP ,ARGUMENTS-ON-STACK))
	       (PUSH-CONSTANT ,VALUE)
	       (START-CALL (SP POP))
	       ,(PC-NEXT-PC MACRO-PC)
	       (%JUMP (SP POP))))))
	;;--- There are still lots of instructions unhandled...
	(T
	 (BAD-HACKER "Cannot simulate this instruction: " NAME))))

(DEFMETHOD (:TRAP-PROCEED TRANS-TRAP :STORE-NEW-VALUE) (VALUE)
  (SEND SELF :STORE-NEW-VALUE VALUE)
  (SEND SELF :TRAP-PROCEED :NO-ACTION))

(DEFUN DECODE-MEMORY-DATA-ERROR (VMA PC TRAPPING-FRAME TRAP-FRAME)
  (MULTIPLE-VALUE-BIND (FLAVOR INIT-ARGS UNBOUND-SLOT-TYPE)
      (DECODE-BAD-DATA-TYPE-TRAP VMA)
    ;; Note:  If UNBOUND-SLOT-TYPE is not NIL, then INIT-ARGS is the slot name and if
    ;; UNBOUND-SLOT-TYPE is :CLASS, FLAVOR is the vector of class slots and if
    ;; UNBOUND-SLOT-TYPE is :INSTANCE, FLAVOR is the instance with the unbound slot.
    (CL:CASE UNBOUND-SLOT-TYPE
      (:INSTANCE
	(LET ((VALUE (CLOS:SLOT-UNBOUND
		       (CLOS:CLASS-OF FLAVOR)
		       FLAVOR
		       INIT-ARGS)))
	  (SETF (FRAME-CALLER-CONTINUATION
		  (SEARCH-FOR-NEXT-OPEN-FRAME TRAP-FRAME %CURRENT-STACK-GROUP))
		(ASSEMBLE-HELPER-FUNCTION
		  `((PUSH-CONSTANT ,VALUE)
		    ,(PC-NEXT-PC PC)
		    (%JUMP (SP POP)))))
	  (THROW '%RETURN-FROM-TRAP NIL)))
      (:CLASS
	;; Have to figure out what the instance is
	(LET* ((FUNCTION (FUNCTION-NAME (%FIND-STRUCTURE-HEADER PC)))
	       (INSTANCE
		 (COND ((OR (EQ FUNCTION 'CLOS-INTERNALS::STANDARD-CLASS-SHARED-SLOT-READER)
			    (EQ
			      FUNCTION
			      'CLOS-INTERNALS::FUNCALLABLE-STANDARD-CLASS-SHARED-SLOT-READER))
			(%P-CONTENTS-OFFSET TRAPPING-FRAME 3))
		       ((AND (CL:CONSP FUNCTION)
			     (EQ (FIRST FUNCTION) 'CLOS:METHOD)
			     (EQ (SECOND FUNCTION) 'CLOS-INTERNALS::SLOT-VALUE-USING-CLASS))
			(%P-CONTENTS-OFFSET TRAPPING-FRAME 4))
		       (T
			;; Use the class prototype of the class as an approximation
			;; to the instance.
			(CLOS:CLASS-PROTOTYPE
			  (CLOS-INTERNALS::CLASS-SLOTS-VECTOR-CLASS FLAVOR)))))
	       (VALUE (CLOS:SLOT-UNBOUND
			(CLOS:CLASS-OF INSTANCE)
			INSTANCE
			INIT-ARGS)))
	  (SETF (FRAME-CALLER-CONTINUATION
		  (SEARCH-FOR-NEXT-OPEN-FRAME TRAP-FRAME %CURRENT-STACK-GROUP))
		(ASSEMBLE-HELPER-FUNCTION
		  `((PUSH-CONSTANT ,VALUE)
		    ,(PC-NEXT-PC PC)
		    (%JUMP (SP POP))))))
	(THROW '%RETURN-FROM-TRAP NIL))
      (OTHERWISE
	`(,FLAVOR . ,INIT-ARGS)))))

;;--- MEMORY-DATA-ERROR can also mean that a block-read-alu/test instruction 
;;--- trapped for some reason (such as fixnum data-type check).
;;--- However, BAD-DATA-TYPE is still pretty descriptive, so maybe that's okay for now.
(DEFINE-TRAP-DISPATCH MEMORY-DATA-ERROR (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION))
  (DECODE-MEMORY-DATA-ERROR VMA PC TRAPPING-FRAME TRAP-FRAME))

(DEFFLAVOR DIVIDE-BY-ZERO-TRAP () (TRAP DIVIDE-BY-ZERO))

(DEFINE-TRAP-DISPATCH DIVIDE-BY-ZERO (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (DIVISOR (DECODE-PACKED-INSTRUCTION-ARGUMENT
		    INSTRUCTION TRAPPING-FRAME TRAP-FRAME 0)))
    (WHEN (AND (NUMBERP DIVISOR) (ZEROP DIVISOR))
      (MULTIPLE-VALUE-BIND (ARG1 NIL N-ARGUMENTS)
	  (DECODE-PACKED-INSTRUCTION-ARGUMENT INSTRUCTION TRAPPING-FRAME TRAP-FRAME 1)
	`(DIVIDE-BY-ZERO-TRAP
	   :FUNCTION ,(I-LISP-COMPILER:GET-OPCODE-PRETTY-NAME
			(LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))
	   :OPERANDS (,ARG1 . ,(LOOP FOR I FROM 2 BELOW N-ARGUMENTS
				     COLLECT (DECODE-PACKED-INSTRUCTION-ARGUMENT
					       INSTRUCTION TRAPPING-FRAME TRAP-FRAME I))))))))

(DEFINE-TRAP-MERGE WRONG-TYPE-ARGUMENT-SUPERSEDES-DIVIDE-BY-ZERO
		   (TRAP1 DIVIDE-BY-ZERO-TRAP)
		   (TRAP2 WRONG-TYPE-ARGUMENT-TRAP)
  (DECLARE (IGNORE TRAP1))
  TRAP2)

(DEFFLAVOR TOO-FEW-ARGUMENTS-TRAP () (TRAP TOO-FEW-ARGUMENTS))

(DEFMETHOD (PROCEED TOO-FEW-ARGUMENTS-TRAP :ADDITIONAL-ARGUMENTS) (&OPTIONAL ADDITIONAL-ARGS)
  "Supply the missing arguments."
  (AND (NULL ADDITIONAL-ARGS)
       (SETQ ADDITIONAL-ARGS (LET* ((INSTRUCTION (%POINTER (%MEMORY-READ MACRO-PC)))
				    (MIN-ARGS (- (LDB %%ENTRY-INSTRUCTION-MIN INSTRUCTION) 2))
				    (MAX-ARGS (- (LDB %%ENTRY-INSTRUCTION-MAX INSTRUCTION) 2))
				    (NOT-REST-P
				      (LDB-TEST
					%%ENTRY-INSTRUCTION-REST-NOT-ACCEPTED
					INSTRUCTION))
				    (REST-NAME (AND (NOT NOT-REST-P)
						    (REST-ARG-NAME TRAPPING-FRAME))))
			       (LOOP FOR ARG-NO FROM NARGS BELOW (IF NOT-REST-P
								     MAX-ARGS 177777)
				     COLLECT (MULTIPLE-VALUE-BIND (VALUE END-FLAG)
						 (PROMPT-AND-READ
						   (IF ( ARG-NO MIN-ARGS)
						       ':EVAL-FORM-OR-END
						       ':EVAL-FORM)
  "Value for arg #~D~:[~@[ (~A)~]~; (in rest arg~@[ ~A~])~]~
   ~:[~; (Or ” to end arguments)~]: "
  ARG-NO ( ARG-NO MAX-ARGS)
  (IF ( ARG-NO MAX-ARGS) REST-NAME (ARG-NAME TRAPPING-FRAME ARG-NO))
  ( ARG-NO MIN-ARGS))
					       (AND END-FLAG (LOOP-FINISH))
					       VALUE)))))
  (VALUES ':ADDITIONAL-ARGUMENTS ADDITIONAL-ARGS))

(DEFINE-TRAP-DISPATCH TOO-FEW-ARGUMENTS (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAP-FRAME))
  `(TOO-FEW-ARGUMENTS-TRAP
     :FUNCTION ,(FRAME-FUNCTION TRAPPING-FRAME)
     :NARGS ,(FRAME-NUMBER-OF-ARGS TRAPPING-FRAME)
     :ARGUMENT-LIST ,(CDR (GET-FRAME-FUNCTION-AND-ARGS TRAPPING-FRAME))))

(DEFMETHOD (MAKE-INSTANCE TOO-FEW-ARGUMENTS-TRAP :AFTER) (&REST IGNORE)
  (PUSH :ADDITIONAL-ARGUMENTS PROCEED-TYPES))

;;; Supply some more arguments to use.
(DEFMETHOD (:TRAP-PROCEED TOO-FEW-ARGUMENTS-TRAP :ADDITIONAL-ARGUMENTS) (ARGS)
  (LET ((NARGS (LENGTH ARGS))
	(CR (LOCF (FRAME-CALLER-CONTROL-REGISTER TRAP-FRAME))))
    (INCF (%P-LDB %%CR.ARGUMENT-SIZE CR) NARGS)
    (EXECUTE-HELPER-FUNCTION SELF
      `(,@(LOOP FOR ARG IN ARGS COLLECT `(PUSH-CONSTANT ,ARG))
	,MACRO-PC
	(%JUMP (SP POP))))))

(DEFFLAVOR TOO-MANY-ARGUMENTS-TRAP () (TRAP TOO-MANY-ARGUMENTS))

(DEFMETHOD (PROCEED TOO-MANY-ARGUMENTS-TRAP :FEWER-ARGUMENTS) (&OPTIONAL NEW-NARGS)
  "Drop some extraneous arguments."
  (WHEN (NULL NEW-NARGS)
    (SETQ NEW-NARGS (LET* ((INSTRUCTION (%POINTER (%MEMORY-READ MACRO-PC)))
			   (MIN-ARGS (- (LDB %%ENTRY-INSTRUCTION-MIN INSTRUCTION) 2))
			   (MAX-ARGS (- (LDB %%ENTRY-INSTRUCTION-MAX INSTRUCTION) 2)))
		      (LOOP FOR N DOWNFROM MAX-ARGS TO MIN-ARGS
			    DO (LET ((*MUST-DROP-P* (= N MAX-ARGS))	;Dropping all extra
				     (*P-ALLOWED-P* ( N MIN-ARGS)))	;P too
				 (DECLARE (SPECIAL *MUST-DROP-P* *P-ALLOWED-P*))
				 (SELECTQ (LET ((CHOICES
						  (IF *P-ALLOWED-P*
						      TOO-MANY-ARGS-Y-N-OR-P-FQUERY-CHOICES
						      TOO-MANY-ARGS-Y-OR-N-FQUERY-CHOICES)))
					    (IF *MUST-DROP-P*
						(FQUERY CHOICES 
							"Drop extra ~D argument~:P? "
							(- NARGS N))
						(FQUERY CHOICES
							"Also drop optional arg #~D~@[ (~A) ~]"
							N (ARG-NAME TRAPPING-FRAME N))))
				   ((T) )	;Ok, go on
				   ((NIL) (RETURN (IF *MUST-DROP-P* NIL (1+ N))))
				   ((:PROCEED) (DECF N) (LOOP-FINISH))))
			       ;; It's probably a bug that N has the wrong value here
			    FINALLY (RETURN (1+ N))))))
  (AND NEW-NARGS (VALUES ':FEWER-ARGUMENTS NEW-NARGS)))

(DEFINE-TRAP-DISPATCH TOO-MANY-ARGUMENTS (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAP-FRAME))
  `(TOO-MANY-ARGUMENTS-TRAP
     :FUNCTION ,(FRAME-FUNCTION TRAPPING-FRAME)
     :NARGS ,(FRAME-NUMBER-OF-ARGS TRAPPING-FRAME)
     :ARGUMENT-LIST ,(CDR (GET-FRAME-FUNCTION-AND-ARGS TRAPPING-FRAME))))

(DEFMETHOD (MAKE-INSTANCE TOO-MANY-ARGUMENTS-TRAP :AFTER) (&REST IGNORE)
  (PUSH :FEWER-ARGUMENTS PROCEED-TYPES))

;;; Supply a different number of arguments to use.
(DEFMETHOD (:TRAP-PROCEED TOO-MANY-ARGUMENTS-TRAP :FEWER-ARGUMENTS) (NEW-NARGS)
  (LET* ((ARGS (FRAME-NUMBER-OF-VISIBLE-ARGS TRAPPING-FRAME))
	 (DELTA (- ARGS NEW-NARGS))
	 (CR (LOCF (FRAME-CALLER-CONTROL-REGISTER TRAP-FRAME)))
	 (APPLY (%P-LDB %%CR.APPLY CR)))
    (COND ((ZEROP APPLY)
	   (DECF (%P-LDB %%CR.ARGUMENT-SIZE CR) DELTA)
	   (EXECUTE-HELPER-FUNCTION SELF
				    `((SET-SP-TO-ADDRESS (SP ,DELTA))
				      ,MACRO-PC
				      (%JUMP (SP POP)))))
	  ((< ARGS NEW-NARGS)
	   ;; Pop from the rest arg
	   (LET ((LOC (%POINTER-PLUS
			TRAPPING-FRAME
			(+ ARGS (DEFSTORAGE-SIZE STACK-FRAME)))))
	     (SETF (LOCATION-CONTENTS LOC)
		   (BUTLAST (LOCATION-CONTENTS LOC) (+ (- DELTA) 1)))))
	   
	  (T
	   (SETF (%P-LDB %%CR.APPLY CR) 0)
	   (DECF (%P-LDB %%CR.ARGUMENT-SIZE CR) DELTA)
	   (EXECUTE-HELPER-FUNCTION SELF
				    `((SET-SP-TO-ADDRESS (SP ,(+ DELTA 1)))
				      ,MACRO-PC
				      (%JUMP (SP POP))))))))

;; Simple and stupid for now.
(DEFFLAVOR SUBSCRIPT-OUT-OF-BOUNDS-TRAP () (TRAP SUBSCRIPT-OUT-OF-BOUNDS))

(DEFMETHOD (REPORT SUBSCRIPT-OUT-OF-BOUNDS-TRAP) (STREAM)
  (LET ((INSTRUCTION (PC-INFO MACRO-PC)))
    (IF (AND (ZEROP SUBSCRIPT-LIMIT)
	     (CL:MEMBER INSTRUCTION '(ARRAY-LEADER STORE-ARRAY-LEADER ALOC-LEADER)))
	(FORMAT STREAM "The array given to the ~A instruction, ~S,~@
			does not have a leader."
		INSTRUCTION OBJECT)
	(FORMAT STREAM "The subscript, ~S, used with the ~A instruction~@
			on ~S was ~:[beyond the length, ~S~;negative~]."
		SUBSCRIPT-USED INSTRUCTION OBJECT (MINUSP SUBSCRIPT-USED) SUBSCRIPT-LIMIT))))

(DEFMETHOD (MAKE-INSTANCE SUBSCRIPT-OUT-OF-BOUNDS-TRAP :AFTER) (&REST IGNORE)
  (OPCODE-SELECT (PACKED-INSTRUCTION-FROM-PC MACRO-PC)
    ((FAST-AREF-1 FAST-ASET-1))
    (OTHERWISE
      (LET ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC MACRO-PC)))
	(WHEN (INSTRUCTION-CAN-STORE-NEW-ARGUMENT INSTRUCTION)
	  (SETQ STORING-NAMES (LIST (INSTRUCTION-ARGUMENT-NAME MACRO-PC)))
	  (CL:PUSHNEW :STORE-NEW-SUBSCRIPT PROCEED-TYPES)))))
  (CL:PUSHNEW :NEW-SUBSCRIPT PROCEED-TYPES))

(DEFMETHOD (:TRAP-PROCEED SUBSCRIPT-OUT-OF-BOUNDS-TRAP :NEW-SUBSCRIPT) (NEW-SUBSCRIPT)
  (CALL-WITH-NEW-ARGUMENTS 
    NIL
    (INSTRUCTION-SUBSCRIPT-ARGUMENT (PACKED-INSTRUCTION-FROM-PC MACRO-PC))
    NEW-SUBSCRIPT))

(DEFMETHOD (:TRAP-PROCEED SUBSCRIPT-OUT-OF-BOUNDS-TRAP :STORE-NEW-SUBSCRIPT) (NEW-SUBSCRIPT)
  (CALL-WITH-NEW-ARGUMENTS 
    T
    (INSTRUCTION-SUBSCRIPT-ARGUMENT (PACKED-INSTRUCTION-FROM-PC MACRO-PC))
    NEW-SUBSCRIPT))

(DEFINE-TRAP-DISPATCH SUBSCRIPT-BOUNDS-ERROR (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC)))
    (MACROLET ((ARGUMENT (N)
		 `(DECODE-PACKED-INSTRUCTION-ARGUMENT
		    INSTRUCTION TRAPPING-FRAME TRAP-FRAME ,N))
	       (VALIDATE-ARRAY (ARRAY &OPTIONAL (CHECK-RANK T))
		 `(UNLESS (AND (ARRAYP ,ARRAY)
			       ,@(WHEN CHECK-RANK
				   `((EQL (CL:ARRAY-RANK ,ARRAY) 1))))
		    (RETURN-FROM SUBSCRIPT-BOUNDS-ERROR NIL)))
	       (VALIDATE-INDEX (INDEX)
		 `(UNLESS (CL:INTEGERP ,INDEX)
		    (RETURN-FROM SUBSCRIPT-BOUNDS-ERROR NIL)))
	       (VALIDATE-LIMIT (INDEX)
		 `(UNLESS (FIXNUMP ,INDEX)
		    (RETURN-FROM SUBSCRIPT-BOUNDS-ERROR NIL))))
      (MULTIPLE-VALUE-BIND (OBJECT SUBSCRIPT LIMIT)
	  (OPCODE-SELECT INSTRUCTION
	    ((AREF-1 ALOC-1 ASET-1)
	     (MULTIPLE-VALUE-BIND (ARRAY-ARG INDEX-ARG)
		 (OPCODE-SELECT INSTRUCTION
		   (ASET-1 (VALUES 2 3))
		   (T      (VALUES 1 2)))
	       (LET ((ARRAY (ARGUMENT ARRAY-ARG))
		     (INDEX (ARGUMENT INDEX-ARG)))
		 (VALIDATE-ARRAY ARRAY)
		 (VALIDATE-INDEX INDEX)
		 (VALUES ARRAY INDEX (ARRAY-LENGTH ARRAY)))))
	    ((FAST-AREF-1 FAST-ASET-1)
	     (MULTIPLE-VALUE-BIND (ARRAY-ARG INDEX-ARG)
		 (OPCODE-SELECT INSTRUCTION
		   (FAST-AREF-1 (VALUES 2 1))
		   (T           (VALUES 3 2)))
	       (MULTIPLE-VALUE-BIND (NIL LOC)
		   (DECODE-PACKED-INSTRUCTION-ARGUMENT
		     INSTRUCTION TRAPPING-FRAME TRAP-FRAME ARRAY-ARG)
		 (SETQ LOC (%POINTER-PLUS LOC -1))
		 (LET ((ARRAY (ARRAY-REGISTER-ARRAY LOC))
		       (INDEX (ARGUMENT INDEX-ARG))
		       (CONTROL (ARRAY-REGISTER-CONTROL-WORD LOC))
		       (LIMIT (ARRAY-REGISTER-ARRAY-LENGTH LOC)))
		   ;; Don't validate the rank, because this could be a force-1d operation.
		   (VALIDATE-ARRAY ARRAY NIL)
		   (VALIDATE-INDEX INDEX)
		   (VALIDATE-LIMIT LIMIT)
		   (WHEN ( (LDB ARRAY-REGISTER-EVENT-COUNT CONTROL)
			    (%READ-INTERNAL-REGISTER %REGISTER-EVENT-COUNT))
		     (LET ((LENGTH (ARRAY-LENGTH ARRAY)))
		       (WHEN ( LENGTH LIMIT)
			 ;; The microcode checks the event count after the subscripts, so
			 ;; sometimes we have to fix the length and retry the instruction
			 ;; for it to properly take the instruction exception.
			 (SETF (ARRAY-REGISTER-ARRAY-LENGTH LOC) LENGTH)
			 (THROW '%RETURN-FROM-TRAP NIL))))
		   (VALUES ARRAY INDEX LIMIT)))))
	    ((ARRAY-LEADER STORE-ARRAY-LEADER ALOC-LEADER)
	     (MULTIPLE-VALUE-BIND (ARRAY-ARG INDEX-ARG)
		 (OPCODE-SELECT INSTRUCTION
		   (STORE-ARRAY-LEADER (VALUES 2 3))
		   (T                  (VALUES 1 2)))
	       (LET ((ARRAY (ARGUMENT ARRAY-ARG))
		     (INDEX (ARGUMENT INDEX-ARG)))
		 (VALIDATE-ARRAY ARRAY NIL)
		 (VALIDATE-INDEX INDEX)
		 (VALUES ARRAY INDEX (OR (ARRAY-LEADER-LENGTH ARRAY) 0)))))
	    ((%INSTANCE-REF %INSTANCE-SET %INSTANCE-LOC)
	     ;; The microcode never signals this in conjunction with other conditions.
	     (MULTIPLE-VALUE-BIND (INSTANCE-ARG INDEX-ARG)
		 (OPCODE-SELECT INSTRUCTION
		   (%INSTANCE-SET (VALUES 2 3))
		   (T             (VALUES 1 2)))
	       (LET ((INSTANCE (ARGUMENT INSTANCE-ARG)))
		 (VALUES INSTANCE (ARGUMENT INDEX-ARG)
			 (FLAVOR::FLAVOR-INSTANCE-SIZE (%INSTANCE-FLAVOR INSTANCE))))))
	    ((PUSH-INSTANCE-VARIABLE POP-INSTANCE-VARIABLE
	      MOVEM-INSTANCE-VARIABLE PUSH-ADDRESS-INSTANCE-VARIABLE)
	     (HANDLE-INVALID-MAPPING-TABLE-ENTRY
	       TRAPPING-FRAME TRAP-FRAME PC
	       (%P-CONTENTS-OFFSET TRAPPING-FRAME 2)
	       (ARGUMENT 0) NIL)
	     (THROW '%RETURN-FROM-TRAP NIL))
	    (OTHERWISE
	      (RETURN-FROM SUBSCRIPT-BOUNDS-ERROR
		`(TRAP-FERROR
		   :FORMAT-STRING "Unable to decode subscript-bounds-error signalled ~
				   by the ~S instruction"
		   :FORMAT-ARGS (,(PC-INFO PC))
		   :SHOW-INTERNAL-STATE T))))
	(WHEN (OR (MINUSP SUBSCRIPT)
		  ( SUBSCRIPT LIMIT))
	  `(SUBSCRIPT-OUT-OF-BOUNDS-TRAP
	     :OBJECT ,OBJECT
	     :SUBSCRIPT-USED ,SUBSCRIPT
	     :SUBSCRIPT-LIMIT ,LIMIT))))))

(DEFFLAVOR WRONG-TYPE-SUBSCRIPT-AND-SUBSCRIPT-OUT-OF-BOUNDS-TRAP
	()
	(SUBSCRIPT-OUT-OF-BOUNDS-TRAP
	 WRONG-TYPE-ARGUMENT-TRAP))

(DEFINE-TRAP-MERGE SUBSCRIPT-IS-A-BIGNUM
		   (TRAP1 SUBSCRIPT-OUT-OF-BOUNDS-TRAP)
		   (TRAP2 WRONG-TYPE-ARGUMENT-TRAP)
  `(WRONG-TYPE-SUBSCRIPT-AND-SUBSCRIPT-OUT-OF-BOUNDS-TRAP
    ,@(CDR TRAP1)
    ,@(CDR TRAP2)))

(DEFUN DECODE-FLAVORS-MAPPING-TABLE-TRAP (IDX FRAME MT)
  (DECLARE (VALUES FIXED-P INSTANCE VARIABLE))
  (LET* ((VARNO (- IDX FLAVOR::*MAPPING-TABLE-OVERHEAD*))
	 (INSTANCE (%P-CONTENTS-OFFSET FRAME 3))
	 (FLAVOR (FLAVOR:FIND-FLAVOR (FLAVOR::MAPPING-TABLE-FLAVOR MT) NIL))
	 (IFLAVOR (AND (INSTANCEP INSTANCE)
		       (FLAVOR:FIND-FLAVOR (FLAVOR-NAME (%INSTANCE-FLAVOR INSTANCE)) NIL))))
    (WHEN (AND FLAVOR					;Delusions of persecution
	       IFLAVOR
	       (< -1 VARNO (ARRAY-LENGTH (FLAVOR::FLAVOR-MAPPING-TABLE-VARIABLE-P FLAVOR)))
	       (AREF (FLAVOR::FLAVOR-MAPPING-TABLE-VARIABLE-P FLAVOR) VARNO))
      ;; Instruction is legal for the flavor
      (WHEN (OR ( IDX (ARRAY-LENGTH MT))
		(EQ (AREF MT IDX) :MOVED))
	;; Mapping table is out of date, fix it and retry the instruction.
	;; This happens if the flavor was redefined after the mapping table
	;; was fetched from the handler table.
	(UNLESS (EQ (%INSTANCE-FLAVOR INSTANCE) IFLAVOR)
	  (FLAVOR:TRANSFORM-INSTANCE INSTANCE IFLAVOR))	;Update the instance
	(LET ((NEW (FLAVOR::GET-MAPPING-TABLE IFLAVOR (FLAVOR::MAPPING-TABLE-FLAVOR MT))))
	  (UNLESS (EQ NEW MT)
	    ;; The out of date mapping table may have been captured in a closure,
	    ;; which means it will keep coming back and causing further traps.
	    ;; Since the mapping table may also be captured in other closures
	    ;; in conjunction with other instances that have not yet been updated
	    ;; to the new flavor definition, we cannot modify the old mapping table
	    ;; in any way.  However, if we can find the closure, we can replace
	    ;; the old mapping table in the closure's environment with the new one.
	    ;; The call that invoked the closure could be any number of frames up
	    ;; the stack from the frame that took the trap.
	    (MAP-OVER-FRAMES-IN-STACK %CURRENT-STACK-GROUP
	      (LAMBDA (FRAME IGNORE FUNCTION)
		(WHEN (AND (TYPEP FUNCTION ':COMPILED-FUNCTION)
			   (LET ((FUNCTION-NAME (FUNCTION-NAME FUNCTION)))
			     (AND (CL:CONSP FUNCTION-NAME)
				  (EQ (CAR FUNCTION-NAME) ':INTERNAL)))
			   (EQ (SECOND (ASSQ 0 (CDR (ASSQ ':VARIABLE-CREATION-ALIST
							  (DEBUGGING-INFO FUNCTION)))))
			       'COMPILER:.LEXICAL-ENVIRONMENT-POINTER.))
		  (LET ((ENV (%MEMORY-READ (%POINTER-PLUS FRAME 2))))
		    (WHEN (AND (CL:CONSP ENV)
			       (CL:CONSP (CDR ENV))
			       (EQ (FIRST ENV) MT)
			       (EQ (SECOND ENV) INSTANCE))
		      (SETF (FIRST ENV) NEW))))))
	    (SETQ MT NEW)))
	(SETF (%P-CONTENTS-OFFSET FRAME 2) MT)		;Update mapping table
	(SETF (%P-CDR-CODE (%POINTER-PLUS FRAME 3)) CDR-NEXT)	;Clear optimize flag
	(UNLESS (OR ( IDX (ARRAY-LENGTH MT))		;Infinite-loop paranoia
		    (EQ (AREF MT IDX) :MOVED))
	  (RETURN-FROM DECODE-FLAVORS-MAPPING-TABLE-TRAP T)))	;Retry instruction
      (WHEN (AND (< IDX (ARRAY-LENGTH MT))
		 (EQ (AREF MT IDX) NIL))
	(VALUES NIL INSTANCE (NTH VARNO (FLAVOR::FLAVOR-MAPPING-TABLE-NAMES FLAVOR)))))))

(DEFUN DECODE-CLOS-MAPPING-TABLE-TRAP (TRAPPING-FRAME TRAP-FRAME PC MT IDX)
  (DECLARE (VALUES FIXED-P INSTANCE SLOT)
	   (IGNORE PC))
  (LET ((ENTRY (AREF MT IDX)))
    (COND ((EQ ENTRY ':UPDATE)
	   ;; Have to update some instances.  This case is tricky,
	   ;; because the mapping table might apply to several
	   ;; instances.  Get the mapping table first, so that if
	   ;; something gets changed the mapping table will be
	   ;; invalidated before we go to use it.
	   ;;
	   ;; First, see if the class of the referenced instance seems correct
	   (LET* ((CLASSES (CLOS-INTERNALS:MAPPING-TABLE-CLASSES MT))
		  (INSTANCE (%MEMORY-READ (%POINTER-PLUS TRAPPING-FRAME 3)
					  :CYCLE-TYPE %MEMORY-SCAVENGE))
		  (INSTANCE-CLASS (CLOS:CLASS-OF INSTANCE))
		  (MTF-INDEX
		    (CLOS-INTERNALS:SEGMENT-NUMBER-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX
		      0 IDX))
		  (CLASS-INDEX (LDB CLOS-INTERNALS:%%MAP-BITS-CLASS
				    (AREF (CLOS-INTERNALS:MAPPING-TABLE-FAMILY-MAP-BITS
					    (CLOS-INTERNALS::MAPPING-TABLE-FAMILY MT))
					  MTF-INDEX)))
		  (SUPPOSED-CLASS (NTH CLASS-INDEX CLASSES)))
	     (UNLESS (EQ SUPPOSED-CLASS INSTANCE-CLASS)
	       (SETQ CLASSES (CL:COPY-LIST CLASSES))
	       (SETF (NTH CLASS-INDEX CLASSES) INSTANCE-CLASS))
	     (SETF (%P-CDR-CODE (%POINTER-PLUS TRAPPING-FRAME 3)) CDR-NEXT)
	     (SETF (%P-CONTENTS-OFFSET TRAPPING-FRAME 2)
		   (CL:APPLY
		     #'CLOS-INTERNALS:GET-MAPPING-TABLE-FOR-CLASSES
		     (CLOS-INTERNALS:MAPPING-TABLE-FAMILY MT)
		     CLASSES)))
	   ;; Update everything in the frame that looks like an instance.  Have to
	   ;; watch out for lexical environments too, but we don't do them yet.
	   (LOOP FOR PLACE FIRST (%POINTER-PLUS TRAPPING-FRAME 3)
		 THEN (%POINTER-PLUS PLACE 1)
		 UNTIL (EQ PLACE TRAP-FRAME)
		 FOR THING = (%MEMORY-READ PLACE :CYCLE-TYPE %MEMORY-SCAVENGE)
		 DOING
	     (WHEN (OR (SYS:INSTANCEP THING)
		       (FUNCALLABLE-INSTANCE-P THING))
	       (CLOS-INTERNALS:UPDATE-INSTANCE-USING-CLASS (CLOS:CLASS-OF THING) THING)))
	   T)
	  (T NIL))))

(DEFUN HANDLE-INVALID-MAPPING-TABLE-ENTRY (TRAPPING-FRAME TRAP-FRAME PC MT IDX BACKUP-PC)
  (DECLARE (ERROR-REPORTER))
  (TYPECASE MT
    (FLAVOR::MAPPING-TABLE
      (MULTIPLE-VALUE-BIND (FIXED-P INSTANCE VARIABLE)
	  (DECODE-FLAVORS-MAPPING-TABLE-TRAP IDX TRAPPING-FRAME MT)
	(WHEN BACKUP-PC
	  ;; Back the PC up
	  (SETF (%SAVED-CONTINUATION-REGISTER) PC))
	(COMPILER:%ERROR-UNLESS FIXED-P
	  (LET* ((NAME (PC-INFO PC))
		 (RETRY (FORMAT NIL "Retry the ~A instruction" NAME)))
	    (IF INSTANCE
		(CL:CERROR RETRY "There was an attempt to access the instance variable ~S~@
				  of ~S, but it has no instance variable by that name."
			   VARIABLE INSTANCE)
		(CL:CERROR RETRY "The ~A microcode ran into an invalid mapping table entry."
			   NAME))))
	(RETURN-FROM HANDLE-INVALID-MAPPING-TABLE-ENTRY NIL)))
    (CLOS-INTERNALS:MAPPING-TABLE
      (WHEN (DECODE-CLOS-MAPPING-TABLE-TRAP TRAPPING-FRAME TRAP-FRAME PC MT IDX)
	;; Back the PC up
	(WHEN BACKUP-PC
	  (SETF (%SAVED-CONTINUATION-REGISTER) PC))
	(RETURN-FROM HANDLE-INVALID-MAPPING-TABLE-ENTRY NIL))))
  ;; Back the PC up
  (WHEN BACKUP-PC
    (SETF (%SAVED-CONTINUATION-REGISTER) PC))
  (LET* ((NAME (PC-INFO PC))
	 (RETRY (FORMAT NIL "Retry the ~A instruction" NAME)))
    (CL:CERROR RETRY
	       "The ~A microcode ran into an invalid mapping table."
	       NAME)))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER PUSH-INSTANCE-VARIABLE TRAP-MODE-EMULATOR
				      (IDX SI:&PC PC)
  (DECLARE (UNSAFEGUARDED-REFERENCE HANDLE-INVALID-MAPPING-TABLE-ENTRY
				    CLOS:SLOT-VALUE)
	   (DBG:ERROR-REPORTER))
  (LET* ((TRAP-FRAME (%STACK-FRAME-POINTER))
	 (TRAPPING-FRAME (%POINTER-PLUS
			   TRAP-FRAME
			   (- (LDB %%CR.CALLER-FRAME-SIZE
				   (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (ENTRY (AREF MT IDX)))
    (TYPECASE ENTRY
      (:LOCATIVE
	(LOCATION-CONTENTS ENTRY))
      (:COMPILED-FUNCTION
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-VALUE
	  (VALUES
	    (FUNCALL ENTRY 'CLOS:SLOT-VALUE IDX MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 3)))))
      (OTHERWISE
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
	  (HANDLE-INVALID-MAPPING-TABLE-ENTRY TRAPPING-FRAME TRAP-FRAME PC MT IDX T))
	(VALUES)))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER POP-INSTANCE-VARIABLE TRAP-MODE-EMULATOR
				      (VAL IDX SI:&PC PC)
  (DECLARE (UNSAFEGUARDED-REFERENCE HANDLE-INVALID-MAPPING-TABLE-ENTRY
				    FUTURE-COMMON-LISP:SETF CLOS:SLOT-VALUE)
	   (DBG:ERROR-REPORTER))
  (LET* ((TRAP-FRAME (%STACK-FRAME-POINTER))
	 (TRAPPING-FRAME (%POINTER-PLUS
			   TRAP-FRAME
			   (- (LDB %%CR.CALLER-FRAME-SIZE
				   (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (ENTRY (AREF MT IDX)))
    (TYPECASE ENTRY
      (:LOCATIVE
	(CL:SETF (LOCATION-CONTENTS ENTRY) VAL)
	(VALUES))
      (:COMPILED-FUNCTION
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
	  (FUNCALL ENTRY '(FUTURE-COMMON-LISP:SETF CLOS:SLOT-VALUE) IDX
		   MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 3)
		   VAL))
	(VALUES))
      (OTHERWISE
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
	  (HANDLE-INVALID-MAPPING-TABLE-ENTRY TRAPPING-FRAME TRAP-FRAME PC MT IDX T))
	(VALUES VAL)))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER MOVEM-INSTANCE-VARIABLE TRAP-MODE-EMULATOR
				      (VAL IDX SI:&PC PC)
  (DECLARE (UNSAFEGUARDED-REFERENCE HANDLE-INVALID-MAPPING-TABLE-ENTRY
				    FUTURE-COMMON-LISP:SETF CLOS:SLOT-VALUE)
	   (DBG:ERROR-REPORTER))
  (LET* ((TRAP-FRAME (%STACK-FRAME-POINTER))
	 (TRAPPING-FRAME (%POINTER-PLUS
			   TRAP-FRAME
			   (- (LDB %%CR.CALLER-FRAME-SIZE
				   (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (ENTRY (AREF MT IDX)))
    (TYPECASE ENTRY
      (:LOCATIVE
	(CL:SETF (LOCATION-CONTENTS ENTRY) VAL))
      (:COMPILED-FUNCTION
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
	  (FUNCALL ENTRY '(FUTURE-COMMON-LISP:SETF CLOS:SLOT-VALUE) IDX
		   MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 3)
		   VAL)))
      (OTHERWISE
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
	  (HANDLE-INVALID-MAPPING-TABLE-ENTRY TRAPPING-FRAME TRAP-FRAME PC MT IDX T)))))
  ;;; When this exception is taken, VAL will have been popped off the
  ;;; stack, so we have to return it.
  (VALUES VAL))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER PUSH-ADDRESS-INSTANCE-VARIABLE TRAP-MODE-EMULATOR
				      (IDX SI:&PC PC)
  (DECLARE (UNSAFEGUARDED-REFERENCE HANDLE-INVALID-MAPPING-TABLE-ENTRY
				    LOCF CLOS:SLOT-VALUE)
	   (DBG:ERROR-REPORTER))
  (LET* ((TRAP-FRAME (%STACK-FRAME-POINTER))
	 (TRAPPING-FRAME (%POINTER-PLUS
			   TRAP-FRAME
			   (- (LDB %%CR.CALLER-FRAME-SIZE
				   (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (ENTRY (AREF MT IDX)))
    (TYPECASE ENTRY
      (:LOCATIVE
	ENTRY)
      (:COMPILED-FUNCTION
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-VALUE
	  (FUNCALL ENTRY '(LOCF CLOS:SLOT-VALUE) IDX MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 3))))
      (OTHERWISE
	(SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
	  (HANDLE-INVALID-MAPPING-TABLE-ENTRY TRAPPING-FRAME TRAP-FRAME PC MT IDX T))
	(VALUES)))))

;;; Random traps.

;; This has to be improved somewhat
#+IGNORE
(DEFINE-TRAP-DISPATCH BRANCH-DOT-ERROR (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (MACROLET ((UNKNOWN ()
	       `(RETURN-FROM BRANCH-DOT-ERROR
		  '(UNKNOWN-TRAP))))
    (LET ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	  (VALUE (%MEMORY-READ (%POINTER-PLUS TRAP-FRAME -1))))
      (MULTIPLE-VALUE-BIND (FUNCTION RELATIVE-PC)
	  (SI:DECODE-PC PC)
	;;--- This uses the wrong relative-pc
	(LET* ((STACK-DESCRIPTION (AREF (ILC:COMPUTE-STACK-DESCRIPTION FUNCTION) RELATIVE-PC))
	       (N-ARGS (FRAME-NUMBER-OF-ARGS TRAPPING-FRAME))
	       (OFFSET (- (ILC:STACK-DESCRIPTION-SP STACK-DESCRIPTION)
			  (DEFSTORAGE-SIZE STACK-FRAME)))
	       (ARGUMENT-NUMBER (AND (< OFFSET N-ARGS) OFFSET))
	       (NAME (ILC:STACK-ENTRY-NAME (ILC:STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	       (SENSE (LDB (BYTE 1 14) INSTRUCTION)))
	  (OPCODE-SELECT INSTRUCTION
	    ((BRANCH-TRUE-AND-EXTRA-POP		;These are simple wrong-type traps
	      BRANCH-TRUE-EXTRA-POP
	      BRANCH-TRUE-ELSE-NO-POP
	      BRANCH-FALSE-AND-EXTRA-POP
	      BRANCH-FALSE-EXTRA-POP
	      BRANCH-FALSE-ELSE-NO-POP)
	     (LET* ((PREVIOUS (PC-PREVIOUS-PC PC))
		    (PREVIOUS-INSTRUCTION (OR (PACKED-INSTRUCTION-FROM-PC PREVIOUS)
					      (UNKNOWN))))
	       (OPCODE-SELECT PREVIOUS-INSTRUCTION
		 ((TYPE-MEMBER TYPE-MEMBER-NO-POP)
		  `(WRONG-TYPE-DATUM-TRAP
		     :DATUM-NAME ,NAME
		     :DATUM-ARGUMENT-NUMBER ,ARGUMENT-NUMBER
		     :EXPECTED-TYPE ,(DECODE-TYPE-MEMBER-TYPE PREVIOUS-INSTRUCTION SENSE)
		     :VALUE ,VALUE
		     :FUNCTION ,FUNCTION))
		 (OTHERWISE (UNKNOWN)))))
	    (OTHERWISE				;Complicated traps
	      ;;--- Maybe this should inhibit debug-info expansion somehow?
	      (LET ((HANDLER (CDR (CL:ASSOC RELATIVE-PC
					    (CDR (CL:ASSOC :TRAP-HANDLERS
							   (DEBUGGING-INFO FUNCTION)))))))
		(IF HANDLER
		    ;;--- Are these the right arguments??  Remember to write DEFGENERIC.
		    (HANDLE-USER-TRAP HANDLER FUNCTION RELATIVE-PC NAME ARGUMENT-NUMBER VALUE)
		    (UNKNOWN))))))))))

(DEFINE-TRAP-DISPATCH ALOC-NON-OBJECT-ARRAY (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE VMA CONDITION))
  `(TRAP-FERROR :FORMAT-STRING "The array given to the ~S instruction, ~S, ~
				is not allowed to be a specialized array."
		:FORMAT-ARGS (,(PC-INFO PC)
			      ,(DECODE-PACKED-INSTRUCTION-ARGUMENT
				 (PACKED-INSTRUCTION-FROM-PC PC)
				 TRAPPING-FRAME TRAP-FRAME 1))))


(DEFINE-TRAP-DISPATCH BAD-CDR-CODE-IN-MEMORY (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR :FORMAT-STRING "The ~A instruction found a bad cdr-code at ~S."
		:FORMAT-ARGS (,(PC-INFO PC) ,VMA)))

(DEFINE-TRAP-DISPATCH BYTE-ARRAY-WORD-TYPE-CHECK (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR :FORMAT-STRING "The ~S instruction expected to find a fixnum in location ~S, ~@
				but instead found #<~A ~\SI:ADDRESS\>."
		:FORMAT-ARGS (,(PC-INFO PC) ,VMA
			      ,(SI:DATA-TYPE-NAME (%P-DATA-TYPE VMA))
			      ,(%P-POINTER VMA))))

(DEFFLAVOR WRONG-TYPE-ARRAY-ELEMENT-TRAP
	(ARRAY)
	(WRONG-TYPE-ARGUMENT-TRAP)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT WRONG-TYPE-ARRAY-ELEMENT-TRAP :AFTER) (STREAM)
  (FORMAT STREAM ",~%and therefore will not fit in the ~A array ~S."
	  (AREF *ARRAY-TYPES* (ARRAY-TYPE-FIELD ARRAY)) ARRAY))

(DEFUN ASET-TYPE-ERROR (PC TRAPPING-FRAME TRAP-FRAME TYPE)
  (LET ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC)))
    `(WRONG-TYPE-ARRAY-ELEMENT-TRAP
       :ARGUMENT-NUMBER 1
       :ARGUMENT-TYPE ,TYPE
       :ARRAY ,(OPCODE-SELECT INSTRUCTION
		 (ASET-1
		   (DECODE-PACKED-INSTRUCTION-ARGUMENT
		     INSTRUCTION TRAPPING-FRAME TRAP-FRAME 2))
		 (FAST-ASET-1
		   (MULTIPLE-VALUE-BIND (NIL LOC)
		       (DECODE-PACKED-INSTRUCTION-ARGUMENT
			 INSTRUCTION TRAPPING-FRAME TRAP-FRAME 3)
		     (%P-CONTENTS-OFFSET LOC -1)))))))

(DEFINE-TRAP-DISPATCH CHARACTER-ARRAY-ASET-TYPE-ERROR
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (ASET-TYPE-ERROR PC TRAPPING-FRAME TRAP-FRAME 'CHARACTER))

(DEFINE-TRAP-DISPATCH NON-8-BIT-CHARACTER (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (ASET-TYPE-ERROR PC TRAPPING-FRAME TRAP-FRAME 'CL:STRING-CHAR))

(DEFINE-TRAP-DISPATCH FIXNUM-ARRAY-ASET-TYPE-ERROR (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (ASET-TYPE-ERROR PC TRAPPING-FRAME TRAP-FRAME 'CL:FIXNUM))

(DEFFLAVOR PDL-OVERFLOW-TRAP () (TRAP PDL-OVERFLOW))

(DEFMETHOD (MAKE-INSTANCE PDL-OVERFLOW-TRAP :AFTER) (&REST IGNORE)
  (SETQ PROCEED-TYPES (CONS :GROW-PDL (CL:REMOVE :NO-ACTION PROCEED-TYPES))))

(DEFMETHOD (:TRAP-PROCEED PDL-OVERFLOW-TRAP :GROW-PDL) ()
  NIL)

(DEFINE-TRAP-DISPATCH BINDING-STACK-OVERFLOW (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME))
  (SI:STACK-GROUP-CALL STACK-GROWER :BIND PDL-GROW-RATIO)
  (LET* ((SG %CURRENT-STACK-GROUP)
	 (ABSOLUTE-LIMIT (SG-ABSOLUTE-BINDING-STACK-LIMIT SG))
	 (NEW-SIZE (%POINTER-DIFFERENCE (SG-BINDING-STACK-LIMIT SG)
					(SG-BINDING-STACK-LOW SG))))
    ;; Don't enter the Debugger if we haven't exceeded the absolute limit.
    (IF (OR (NULL ABSOLUTE-LIMIT)
	    (> NEW-SIZE ABSOLUTE-LIMIT))
	`(PDL-OVERFLOW-TRAP :PDL-NAME "binding")
	(THROW '%RETURN-FROM-TRAP NIL))))

(DEFFLAVOR WRONG-TYPE-MICROARG-TRAP
	(MICROROUTINE ARGUMENT-VALUE BAD-VALUE)
	(WRONG-TYPE-ARGUMENT-TRAP)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT WRONG-TYPE-MICROARG-TRAP) (STREAM)
  (FORMAT STREAM "The ~a microcode encountered ~s, which was not " MICROROUTINE BAD-VALUE)
  (CLI::PRINT-TYPE-DESCRIPTION ARGUMENT-TYPE STREAM)
  (FORMAT STREAM ",~%from the ~:r argument, ~s, of the ~a instruction"
	  ARGUMENT-NUMBER ARGUMENT-VALUE (PC-INFO MACRO-PC)))

(DEFINE-TRAP-DISPATCH ASSOC-LIST-ELEMENT-NOT-LIST (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET ((ARGUMENT-VALUE (DECODE-PACKED-INSTRUCTION-ARGUMENT
			  (PACKED-INSTRUCTION-FROM-PC PC) TRAPPING-FRAME TRAP-FRAME 2)))
    `(WRONG-TYPE-MICROARG-TRAP
       :MICROROUTINE CAR
       :ARGUMENT-NUMBER 2
       :ARGUMENT-TYPE LIST
       :ARGUMENT-VALUE ,ARGUMENT-VALUE
       ;; Sigh, VMA is random.
       :BAD-VALUE ,(DO ((L ARGUMENT-VALUE (CDR L)))
		       ((NOT (CL:CONSP L)))
		     (UNLESS (CL:LISTP (CAR L))
		       (RETURN (CAR L)))))))

(DEFINE-TRAP-DISPATCH LIST-OPERATION-TAIL-NOT-LIST (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET* ((ARGUMENT-NUMBER
	   (CL:CASE (PC-INFO PC)
	     (ASSOC 2)
	     (MEMBER 2)
	     (RGETF 2)
	     (ENDP 1)
	     (T 1)))
	 (ARGUMENT-VALUE (DECODE-PACKED-INSTRUCTION-ARGUMENT
			   (PACKED-INSTRUCTION-FROM-PC PC)
			   TRAPPING-FRAME TRAP-FRAME ARGUMENT-NUMBER)))
    `(WRONG-TYPE-MICROARG-TRAP
       :MICROROUTINE ENDP
       :ARGUMENT-NUMBER ,ARGUMENT-NUMBER
       :ARGUMENT-TYPE LIST
       :ARGUMENT-VALUE ,ARGUMENT-VALUE
       :BAD-VALUE ,(DO ((L ARGUMENT-VALUE (CDR L)))
		       ((NULL L))
		     (WHEN (NOT (CL:CONSP L))
		       (RETURN L))))))

(DEFINE-TRAP-DISPATCH DIVIDE-OVERFLOW (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR
     :FORMAT-STRING "The result of the ~A instruction cannot be represented as a fixnum"
     :FORMAT-ARGS (,(PC-INFO PC))))

(DEFINE-TRAP-DISPATCH BINDING-STACK-UNDERFLOW (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR :FORMAT-STRING "Binding stack underflow"
		:SHOW-INTERNAL-STATE T))

(DEFINE-TRAP-DISPATCH FRAME-OVERFLOW (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR :FORMAT-STRING "Attempt to create a frame larger than ~S words"
		:FORMAT-ARGS (,CONTROL-STACK-MAX-FRAME-SIZE)
		:SHOW-INTERNAL-STATE T))

(DEFINE-TRAP-DISPATCH I-STAGE-ERROR (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA TRAPPING-FRAME TRAP-FRAME))
  ;; Try to detect common cases
  (COND ((AND (TYPE-MEMBER PC DTP-ODD-PC)
	      (< (%TAG (%MEMORY-READ PC :CYCLE-TYPE %MEMORY-BIND-READ))
		 DTP-PACKED-INSTRUCTION-60))
	 `(TRAP-FERROR
	    :FORMAT-STRING "Attempt to execute the second half of a full-word instruction"
	    :SHOW-INTERNAL-STATE T))
	((= (%P-CDR-CODE PC) SEQUENCING-FENCE)
	 `(TRAP-FERROR
	    :FORMAT-STRING "Execution ran off the end of function ~S"
	    :FORMAT-ARGS (,(%FIND-STRUCTURE-HEADER PC))))
	(T `(TRAP-FERROR :FORMAT-STRING "Internal error decoding instruction stream"
			 :SHOW-INTERNAL-STATE T))))

(DEFINE-TRAP-DISPATCH ILLEGAL-FULL-WORD-INSTRUCTION
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA TRAPPING-FRAME TRAP-FRAME))
  `(TRAP-FERROR :FORMAT-STRING "~A is not legal as a data-type in a full-word instruction"
		:FORMAT-ARGS (,(SI:DATA-TYPE-NAME (%P-DATA-TYPE PC)))
		:SHOW-INTERNAL-STATE T))

(DEFINE-TRAP-DISPATCH ARRAY-REGISTER-FORMAT-ERROR
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (ARG (OPCODE-SELECT INSTRUCTION
		(FAST-AREF-1 2)
		(T 3))))
    (MULTIPLE-VALUE-BIND (NIL LOC)
	(DECODE-PACKED-INSTRUCTION-ARGUMENT
	  INSTRUCTION TRAPPING-FRAME TRAP-FRAME ARG)
      (SETQ LOC (%POINTER-PLUS LOC -1))		;Back up to first word of array register.
      (MULTIPLE-VALUE-BIND (WORD TYPE)
	  (COND ((NOT (ARRAYP  (ARRAY-REGISTER-ARRAY LOC)))
		 (VALUES "array" "an array"))
		((NOT (FIXNUMP (ARRAY-REGISTER-CONTROL-WORD LOC)))
		 (VALUES "control" "a fixnum"))
		((NOT (FIXNUMP (ARRAY-REGISTER-ARRAY-LENGTH LOC)))
		 (VALUES "array-length" "a fixnum"))
		(T (RETURN-FROM ARRAY-REGISTER-FORMAT-ERROR NIL)))
	`(TRAP-FERROR
	   :FORMAT-STRING "Invalid array-register format:  the ~A word is not ~A."
	   :FORMAT-ARGS (,WORD ,TYPE))))))

(DEFINE-TRAP-DISPATCH FLAVOR-SEARCH-MASK-NOT-FIXNUM
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION))
  (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (INSTANCE (%P-CONTENTS-OFFSET TRAPPING-FRAME
		     (OPCODE-SELECT INSTRUCTION
		       (%GENERIC-DISPATCH 3)
		       (OTHERWISE 2))))
	 (FLAVOR (%INSTANCE-FLAVOR INSTANCE))
	 (MASK-LOC (LOCF (FLAVOR::FLAVOR-HASH-MASK FLAVOR))))
    (IF (MEMQ (DATA-TYPE-NAME (%P-DATA-TYPE MASK-LOC)) *GOOD-DATA-TYPES*)
	`(TRAP-FERROR :FORMAT-STRING "The hash mask for ~S, ~S, was not a fixnum"
		      :FORMAT-ARGS (,FLAVOR ,(LOCATION-CONTENTS MASK-LOC)))
	(DECODE-MEMORY-DATA-ERROR VMA PC TRAPPING-FRAME TRAP-FRAME))))

(DEFINE-TRAP-DISPATCH FLAVOR-SEARCH-TABLE-POINTER-NOT-LOCATIVE
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION))
  (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (INSTANCE (%P-CONTENTS-OFFSET TRAPPING-FRAME
		     (OPCODE-SELECT INSTRUCTION
		       (%GENERIC-DISPATCH 3)
		       (OTHERWISE 2))))
	 (FLAVOR (%INSTANCE-FLAVOR INSTANCE))
	 (ADDRESS-LOC (LOCF (FLAVOR::FLAVOR-HASH-ADDRESS FLAVOR))))
    (IF (MEMQ (DATA-TYPE-NAME (%P-DATA-TYPE ADDRESS-LOC)) *GOOD-DATA-TYPES*)
	`(TRAP-FERROR :FORMAT-STRING "The hash address for ~S, ~S, was not a locative"
		      :FORMAT-ARGS (,FLAVOR ,(LOCATION-CONTENTS ADDRESS-LOC)))
	(DECODE-MEMORY-DATA-ERROR VMA PC TRAPPING-FRAME TRAP-FRAME))))

(DEFINE-TRAP-DISPATCH GENERIC-SEARCH-TABLE-ENTRY-NOT-PC
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION))
  (IF (NOT (MEMQ (DATA-TYPE-NAME (%P-DATA-TYPE VMA)) *GOOD-DATA-TYPES*))
      (DECODE-MEMORY-DATA-ERROR VMA PC TRAPPING-FRAME TRAP-FRAME)
    (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	   (INSTANCE (%P-CONTENTS-OFFSET TRAPPING-FRAME
		       (OPCODE-SELECT INSTRUCTION
			 (%GENERIC-DISPATCH 3)
			 (OTHERWISE 2))))
	   (FLAVOR (%INSTANCE-FLAVOR INSTANCE)))
      (MULTIPLE-VALUE-BIND (HASH-ARRAY LEADER SIZE)
	  (SI:%FIND-STRUCTURE-EXTENT (FLAVOR::FLAVOR-HASH-ADDRESS FLAVOR))
	(DECLARE (IGNORE HASH-ARRAY))
	(IF (AND (NOT (%POINTER-LESSP VMA LEADER))
		 (%UNSIGNED-LESSP (%POINTER-DIFFERENCE VMA LEADER) SIZE)
		 (NOT (TYPE-MEMBER (%MEMORY-READ VMA) DTP-EVEN-PC DTP-ODD-PC)))
	    `(TRAP-FERROR :FORMAT-STRING "The entry for method ~S in flavor ~S,~@
					  ~S, was not a compiled function pc."
			  :FORMAT-ARGS (,(%P-CONTENTS-OFFSET TRAPPING-FRAME
					   (OPCODE-SELECT INSTRUCTION
					     (%GENERIC-DISPATCH 2)
					     (OTHERWISE 3)))
					,(FLAVOR:FLAVOR-NAME FLAVOR)
					,(%MEMORY-READ VMA)))
	    (DECODE-MEMORY-DATA-ERROR VMA PC TRAPPING-FRAME TRAP-FRAME))))))

(DEFINE-TRAP-DISPATCH INSTANCE-FLAVOR-TABLE-CONTENTS-NOT-LOCATIVE
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA TRAP-FRAME))
  (LET* ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (INSTANCE (%P-CONTENTS-OFFSET TRAPPING-FRAME
		     (OPCODE-SELECT INSTRUCTION
		       (%GENERIC-DISPATCH 3)
		       (OTHERWISE 2)))))
    `(TRAP-FERROR
       :FORMAT-STRING "The generic dispatch entry for ~S does not contain a locative."
       :FORMAT-ARGS (,(DATA-TYPE-NAME (%DATA-TYPE INSTANCE))))))

(DEFINE-TRAP-DISPATCH INTERPRETER-TABLE-CONTENTS-NOT-PC
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAP-FRAME))
  `(TRAP-FERROR
     :FORMAT-STRING "The interpreter vector entry for ~S ~
		     does not contain a compiled function pc."
     :FORMAT-ARGS (,(DATA-TYPE-NAME (%P-DATA-TYPE (%POINTER-PLUS TRAPPING-FRAME 2))))))

(DEFFLAVOR WRONG-IMPLICIT-TYPE-TRAP (NAME VALUE TYPE) (TRAP ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT WRONG-IMPLICIT-TYPE-TRAP) (STREAM)
  (FORMAT STREAM "The value of ~S, ~S, was not " NAME VALUE)
  (PRINT-TYPE-DESCRIPTION TYPE STREAM))

(DEFINE-TRAP-DISPATCH SELF-MAPPING-TABLE-TYPE-ERROR
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION PC VMA TRAP-FRAME))
  `(WRONG-IMPLICIT-TYPE-TRAP :NAME SELF-MAPPING-TABLE
			     :VALUE ,(%P-CONTENTS-OFFSET TRAPPING-FRAME 2)
			     :TYPE (DATA-TYPE DTP-ARRAY)))

(DEFINE-TRAP-DISPATCH SELF-TYPE-ERROR
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET ((MAPPING-TABLE (%P-CONTENTS-OFFSET TRAPPING-FRAME 2)))
    (WHEN (TYPEP MAPPING-TABLE 'CLOS-INTERNALS:MAPPING-TABLE)
      (LET ((HANDLER
	      (OPCODE-SELECT (PACKED-INSTRUCTION-FROM-PC PC)
		(PUSH-INSTANCE-VARIABLE #'PUSH-INSTANCE-VARIABLE-HELPER)
		(POP-INSTANCE-VARIABLE #'POP-INSTANCE-VARIABLE-HELPER)
		(MOVEM-INSTANCE-VARIABLE #'MOVEM-INSTANCE-VARIABLE-HELPER)
		(PUSH-ADDRESS-INSTANCE-VARIABLE #'PUSH-ADDRESS-INSTANCE-VARIABLE-HELPER))))
	(WHEN HANDLER
	  (STACK-LET ((CODE `((DTP-CALL-COMPILED-EVEN
				,(%MAKE-POINTER-OFFSET DTP-EVEN-PC HANDLER 1))
			      ,PC
			      (FINISH-CALL-N
				(:10-BIT-IMMEDIATE
				  #.(DPB VALUE-DISPOSITION-EFFECT
					 %%PACKED-INSTRUCTION-VALUE-DISPOSITION 2))))))
	    (SETF (FRAME-CALLER-CONTINUATION
		    (SEARCH-FOR-NEXT-OPEN-FRAME TRAP-FRAME %CURRENT-STACK-GROUP))
		  (ASSEMBLE-HELPER-FUNCTION CODE))
	    (THROW '%RETURN-FROM-TRAP NIL)))))
    `(WRONG-IMPLICIT-TYPE-TRAP :NAME SELF
			       :VALUE ,(%P-CONTENTS-OFFSET TRAPPING-FRAME 3)
			       :TYPE SCL:INSTANCE)))

(DEFUN PUSH-INSTANCE-VARIABLE-HELPER (PC)
  (DECLARE (DBG:ERROR-REPORTER) (CL:INLINE PC-NEXT-PC))
  (SETF (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION) (PC-NEXT-PC PC))
  (COMPILER:NO-OP)
  (COMPILER:NO-OP)
  (LET* ((TRAPPING-FRAME
	   (%POINTER-PLUS
	     (%STACK-FRAME-POINTER)
	     (- (LDB %%CR.CALLER-FRAME-SIZE
		     (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (SELF (%P-CONTENTS-OFFSET TRAPPING-FRAME 3))
	 (INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (IDX (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION))
	 (ENTRY (AREF MT IDX)))
    (TYPECASE ENTRY
      (:FIXNUM
	(RETURN-KLUDGE (CLOS-INTERNALS:%FUNCALLABLE-INSTANCE-REF SELF ENTRY)))
      (:LOCATIVE
	(RETURN-KLUDGE (LOCATION-CONTENTS ENTRY)))
      (:COMPILED-FUNCTION
	(RETURN-KLUDGE (FUNCALL ENTRY 'CLOS:SLOT-VALUE IDX MT SELF)))
      (OTHERWISE
	(HANDLE-INVALID-MAPPING-TABLE-ENTRY TRAPPING-FRAME (%STACK-FRAME-POINTER) PC MT IDX T)
	(RETURN-KLUDGE (VALUES))))))

(DEFUN PUSH-ADDRESS-INSTANCE-VARIABLE-HELPER (PC)
  (DECLARE (DBG:ERROR-REPORTER) (CL:INLINE PC-NEXT-PC))
  (SETF (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION) (PC-NEXT-PC PC))
  (COMPILER:NO-OP)
  (COMPILER:NO-OP)
  (LET* ((TRAPPING-FRAME
	   (%POINTER-PLUS
	     (%STACK-FRAME-POINTER)
	     (- (LDB %%CR.CALLER-FRAME-SIZE
		     (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (SELF (%P-CONTENTS-OFFSET TRAPPING-FRAME 3))
	 (INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (IDX (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION))
	 (ENTRY (AREF MT IDX)))
    (TYPECASE ENTRY
      (:FIXNUM
	(RETURN-KLUDGE
	  (LOCF (CLOS-INTERNALS:%FUNCALLABLE-INSTANCE-REF SELF ENTRY))))
      (:LOCATIVE
	(RETURN-KLUDGE ENTRY))
      (:COMPILED-FUNCTION
	(RETURN-KLUDGE (FUNCALL ENTRY '(LOCF CLOS:SLOT-VALUE) IDX MT SELF)))
      (OTHERWISE
	(HANDLE-INVALID-MAPPING-TABLE-ENTRY TRAPPING-FRAME (%STACK-FRAME-POINTER) PC MT IDX T)
	(RETURN-KLUDGE (VALUES))))))

(DEFUN MOVEM-INSTANCE-VARIABLE-HELPER (PC)
  (DECLARE (DBG:ERROR-REPORTER) (CL:INLINE PC-NEXT-PC))
  (SETF (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION) (PC-NEXT-PC PC))
  (COMPILER:NO-OP)
  (COMPILER:NO-OP)
  (LET* ((TRAPPING-FRAME
	   (%POINTER-PLUS
	     (%STACK-FRAME-POINTER)
	     (- (LDB %%CR.CALLER-FRAME-SIZE
		     (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (SELF (%P-CONTENTS-OFFSET TRAPPING-FRAME 3))
	 (INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (IDX (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION))
	 (ENTRY (AREF MT IDX))
	 (VALUE (%P-CONTENTS-OFFSET (%STACK-FRAME-POINTER) -1)))
    (TYPECASE ENTRY
      (:FIXNUM
	(SETF (CLOS-INTERNALS:%FUNCALLABLE-INSTANCE-REF SELF ENTRY) VALUE))
      (:LOCATIVE
	(SETF (LOCATION-CONTENTS ENTRY) VALUE))
      (:COMPILED-FUNCTION
	(FUNCALL ENTRY '(CLOS:SETF CLOS:SLOT-VALUE) IDX MT SELF VALUE))
      (OTHERWISE
	(HANDLE-INVALID-MAPPING-TABLE-ENTRY
	  TRAPPING-FRAME (%STACK-FRAME-POINTER) PC MT IDX T)))
    (RETURN-KLUDGE (VALUES))))

(DEFUN POP-INSTANCE-VARIABLE-HELPER (PC)
  (DECLARE (DBG:ERROR-REPORTER) (CL:INLINE PC-NEXT-PC))
  (SETF (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION) (PC-NEXT-PC PC))
  (COMPILER:NO-OP)
  (COMPILER:NO-OP)
  (LET* ((TRAPPING-FRAME
	   (%POINTER-PLUS
	     (%STACK-FRAME-POINTER)
	     (- (LDB %%CR.CALLER-FRAME-SIZE
		     (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (MT (%P-CONTENTS-OFFSET TRAPPING-FRAME 2))
	 (SELF (%P-CONTENTS-OFFSET TRAPPING-FRAME 3))
	 (INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC))
	 (IDX (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION))
	 (ENTRY (AREF MT IDX))
	 (VALUE (%P-CONTENTS-OFFSET (%STACK-FRAME-POINTER) -1)))
    (TYPECASE ENTRY
      (:FIXNUM
	(SETF (CLOS-INTERNALS:%FUNCALLABLE-INSTANCE-REF SELF ENTRY) VALUE)
	(SI:POP-GRANDFATHERS-STACK 1))
      (:LOCATIVE
	(SETF (LOCATION-CONTENTS ENTRY) VALUE)
	(SI:POP-GRANDFATHERS-STACK 1))
      (:COMPILED-FUNCTION
	(FUNCALL ENTRY '(CLOS:SETF CLOS:SLOT-VALUE) IDX MT SELF VALUE)
	(SI:POP-GRANDFATHERS-STACK 1))
      (OTHERWISE
	(HANDLE-INVALID-MAPPING-TABLE-ENTRY
	  TRAPPING-FRAME (%STACK-FRAME-POINTER) PC MT IDX T)))
    (RETURN-KLUDGE (VALUES))))

;; This should be a wrong-type-argument trap, except that the multiple-value-group size
;; isn't considered to be an argument by OPDEF.
;; Uses :ADDITIONAL-FORMAT-STRING, which strictly speaking should only be generated
;; by trap merges.  That's okay as long as this condition isn't signalled in conjunction
;; with any others.
(DEFINE-TRAP-DISPATCH TAKE-VALUES-TYPE-ERROR
		      (CONDITION PC VMA TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (IGNORE CONDITION VMA))
  (LET ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC PC)))
    (MULTIPLE-VALUE-BIND (TAKE-N-ARGS LOCATION)
	(DECODE-PACKED-INSTRUCTION-ARGUMENT INSTRUCTION TRAPPING-FRAME TRAP-FRAME 1)
      (LET ((MV-GROUP-SIZE (%MEMORY-READ (%POINTER-PLUS (OR LOCATION TRAP-FRAME) -1)
					 :CYCLE-TYPE %MEMORY-SCAVENGE)))
	(IF (NOT (TYPE-MEMBER TAKE-N-ARGS DTP-FIXNUM))
	    `(WRONG-TYPE-ARGUMENT-TRAP
	       :ARGUMENT-NUMBER 1
	       :ARGUMENT-TYPE CL:FIXNUM
	       ,@(WHEN (NOT (TYPE-MEMBER MV-GROUP-SIZE DTP-FIXNUM))
		   `(:ADDITIONAL-FORMAT-STRING
		     "The TAKE-VALUES instruction expected a multiple-value-group
on the stack, but the top of stack, ~S, was not a fixnum"
		     :ADDITIONAL-FORMAT-ARGS (,MV-GROUP-SIZE))))
		(WHEN (NOT (TYPE-MEMBER MV-GROUP-SIZE DTP-FIXNUM))
		  `(TRAP-FERROR
		     :FORMAT-STRING
		       "The TAKE-VALUES instruction expected a multiple-value-group
on the stack, but the top of stack, ~S, was not a fixnum"
		     :FORMAT-ARGS (,MV-GROUP-SIZE))))))))

;;;; Argument mismatch traps

(DEFFLAVOR WRONG-TYPE-ARGUMENT-TRAP
	(ARGUMENT-NUMBER
	 ARGUMENT-TYPE
	 ARGUMENT-VALUE
	 (ARGUMENT-DATA-TYPE NIL))		;If non-null, unsafe data type for value
	(TRAP WRONG-TYPE-ARGUMENT)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (MAKE-INSTANCE WRONG-TYPE-ARGUMENT-TRAP :AFTER) (&REST IGNORE)
  (LET ((INSTRUCTION (PACKED-INSTRUCTION-FROM-PC MACRO-PC)))
    (MULTIPLE-VALUE-BIND (VALUE NIL N-ARGUMENTS)
	(DECODE-PACKED-INSTRUCTION-ARGUMENT
	  INSTRUCTION TRAPPING-FRAME TRAP-FRAME ARGUMENT-NUMBER)
      (IF (CL:MEMBER (DATA-TYPE-NAME (%DATA-TYPE VALUE)) *GOOD-DATA-TYPES*)
	  (SETQ ARGUMENT-VALUE VALUE)
	  (SETQ ARGUMENT-VALUE (%SET-TAG VALUE DTP-FIXNUM)
		ARGUMENT-DATA-TYPE (DATA-TYPE-NAME (%DATA-TYPE VALUE))))
      (WHEN (AND (EQL ARGUMENT-NUMBER N-ARGUMENTS)
		 (INSTRUCTION-CAN-STORE-NEW-ARGUMENT INSTRUCTION))
	(SETQ STORING-NAMES (LIST (INSTRUCTION-ARGUMENT-NAME MACRO-PC)))
	(CL:PUSHNEW :STORE-ARGUMENT-VALUE PROCEED-TYPES))
      (CL:PUSHNEW :ARGUMENT-VALUE PROCEED-TYPES))))

(DEFMETHOD (REPORT WRONG-TYPE-ARGUMENT-TRAP) (STREAM)
  (FORMAT STREAM
	  "The ~:R argument to the ~A instruction, ~:[~S~;#<~:*~A ~\SI:ADDRESS\>~], was not "
	  ARGUMENT-NUMBER
	  (PC-INFO MACRO-PC)
	  ARGUMENT-DATA-TYPE
	  ARGUMENT-VALUE)
  (CLI::PRINT-TYPE-DESCRIPTION ARGUMENT-TYPE STREAM))

(DEFMETHOD (:TRAP-PROCEED WRONG-TYPE-ARGUMENT-TRAP :ARGUMENT-VALUE) (NEW-VALUE)
  (CALL-WITH-NEW-ARGUMENTS NIL ARGUMENT-NUMBER NEW-VALUE))

(DEFMETHOD (:TRAP-PROCEED WRONG-TYPE-ARGUMENT-TRAP :STORE-ARGUMENT-VALUE) (NEW-VALUE)
  (CALL-WITH-NEW-ARGUMENTS T ARGUMENT-NUMBER NEW-VALUE))

;; Required by the documentation
(DEFMETHOD (:OLD-VALUE WRONG-TYPE-ARGUMENT-TRAP) ()
  ARGUMENT-VALUE)

;; Required by the documentation
(DEFMETHOD (:FUNCTION WRONG-TYPE-ARGUMENT-TRAP) ()
  (VALUES (PC-INFO MACRO-PC)))

(DEFINE-TRAP-MERGE MERGE-WRONG-TYPE-ARGUMENTS
		   (TRAP1 WRONG-TYPE-ARGUMENT-TRAP WRONG-TYPE-ARGUMENTS-TRAP)
		   (TRAP2 WRONG-TYPE-ARGUMENT-TRAP)
  (MULTIPLE-VALUE-BIND (NUMBERS TYPES)
      (IF (EQ (CAR TRAP1) 'WRONG-TYPE-ARGUMENT-TRAP)
	  (VALUES (LIST (GET TRAP1 :ARGUMENT-NUMBER))
		  (LIST (GET TRAP1 :ARGUMENT-TYPE)))
	  (VALUES (GET TRAP1 :ARGUMENT-NUMBERS)
		  (GET TRAP1 :ARGUMENT-TYPES)))
    `(WRONG-TYPE-ARGUMENTS-TRAP
       :ARGUMENT-NUMBERS ,(APPEND NUMBERS (LIST (GET TRAP2 :ARGUMENT-NUMBER)))
       :ARGUMENT-TYPES   ,(APPEND TYPES   (LIST (GET TRAP2 :ARGUMENT-TYPE))))))

(DEFFLAVOR WRONG-TYPE-ARGUMENTS-TRAP
	(ARGUMENT-NUMBERS
	 ARGUMENT-TYPES
	 ARGUMENT-VALUES
	 ARGUMENT-DATA-TYPES)
	(TRAP WRONG-TYPE-ARGUMENT)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (MAKE-INSTANCE WRONG-TYPE-ARGUMENTS-TRAP :AFTER) (&REST IGNORE)
  (LOOP WITH INSTRUCTION = (PACKED-INSTRUCTION-FROM-PC MACRO-PC)
	WITH (BAD-VALUE-P VALUE N-ARGUMENTS)
	FOR NUMBER IN ARGUMENT-NUMBERS
	DO (MULTIPLE-VALUE (VALUE NIL N-ARGUMENTS)
	     (DECODE-PACKED-INSTRUCTION-ARGUMENT INSTRUCTION TRAPPING-FRAME TRAP-FRAME NUMBER))
	WHEN (CL:MEMBER (DATA-TYPE-NAME (%DATA-TYPE VALUE)) *GOOD-DATA-TYPES*)
	  COLLECT VALUE INTO VALUES AND COLLECT NIL INTO TYPES
	ELSE
	  COLLECT (%SET-TAG VALUE DTP-FIXNUM) INTO VALUES
	  AND COLLECT (DATA-TYPE-NAME (%DATA-TYPE VALUE)) INTO TYPES
	  AND DO (SETQ BAD-VALUE-P T)
	COLLECT (AND (EQL NUMBER N-ARGUMENTS)
		     (INSTRUCTION-CAN-STORE-NEW-ARGUMENT INSTRUCTION)
		     (INSTRUCTION-ARGUMENT-NAME MACRO-PC))
	  INTO STORES
	COLLECT (FORMAT NIL "~:R argument" NUMBER) INTO NAMES
	FINALLY
	  (SETQ ARGUMENT-VALUES VALUES
		ARGUMENT-DATA-TYPES (AND BAD-VALUE-P TYPES)
		STORING-NAMES STORES
		ARG-NAMES NAMES)
	  (WHEN (LOOP FOR STORE IN STORES THEREIS STORE)
	    (CL:PUSHNEW :STORE-ARGUMENT-VALUE PROCEED-TYPES))
	  (CL:PUSHNEW :ARGUMENT-VALUE PROCEED-TYPES)))

(DEFMETHOD (REPORT WRONG-TYPE-ARGUMENTS-TRAP) (STREAM)
  (FORMAT STREAM "In the ~A instruction," (PC-INFO MACRO-PC))
  (LOOP FOR CLAUSE = (LENGTH ARGUMENT-NUMBERS) THEN (1- CLAUSE)
	FOR ARGUMENT-NUMBER IN ARGUMENT-NUMBERS
	FOR ARGUMENT-TYPE IN ARGUMENT-TYPES
	FOR ARGUMENT-VALUE = ARGUMENT-VALUES THEN (CDR ARGUMENT-VALUE)
	FOR ARGUMENT-DATA-TYPE = ARGUMENT-DATA-TYPES THEN (CDR ARGUMENT-DATA-TYPE)
	DO (FORMAT STREAM "~%  the ~:R argument, ~:[~S~;#<~:*~A ~\SI:ADDRESS\>~], was not "
		   ARGUMENT-NUMBER
		   (CAR ARGUMENT-DATA-TYPE)
		   (CAR ARGUMENT-VALUE))
	   (CLI::PRINT-TYPE-DESCRIPTION ARGUMENT-TYPE STREAM)
	   (SELECT CLAUSE
	     (3 (FORMAT STREAM ", "))
	     (2 (FORMAT STREAM ", and ")))))

(DEFMETHOD (:TRAP-PROCEED WRONG-TYPE-ARGUMENTS-TRAP :ARGUMENT-VALUE) (&REST NEW-VALUES)
  (CL:APPLY #'CALL-WITH-NEW-ARGUMENTS NIL
	    (LOOP FOR ARGUMENT-NUMBER IN ARGUMENT-NUMBERS
		  FOR VALUE IN NEW-VALUES
		  COLLECT ARGUMENT-NUMBER
		  COLLECT VALUE)))

(DEFMETHOD (:TRAP-PROCEED WRONG-TYPE-ARGUMENTS-TRAP :STORE-ARGUMENT-VALUE) (&REST NEW-VALUES)
  (CL:APPLY #'CALL-WITH-NEW-ARGUMENTS T
	    (LOOP FOR ARGUMENT-NUMBER IN ARGUMENT-NUMBERS
		  FOR VALUE IN NEW-VALUES
		  COLLECT ARGUMENT-NUMBER
		  COLLECT VALUE)))

;; Required by the documentation
(DEFMETHOD (:FUNCTION WRONG-TYPE-ARGUMENTS-TRAP) ()
  (VALUES (PC-INFO MACRO-PC)))

;; Required by the documentation
(DEFMETHOD (:OLD-VALUE WRONG-TYPE-ARGUMENTS-TRAP) ()
  (VALUES-LIST ARGUMENT-VALUES))


;;; Trap-on-Call

(DEFFLAVOR BREAKON-TRAP (FUNCTION REAL-FRAME) (NO-ACTION-MIXIN DEBUGGER-CONDITION)
  (:INITABLE-INSTANCE-VARIABLES FUNCTION)
  (:INIT-KEYWORDS :BREAKON-THIS-TIME-FRAME))

(DEFUN BREAKON-THIS-TIME (BREAK-CONDITION FUNCTION ARGS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF BREAK-CONDITION
      (SIGNAL 'BREAKON-TRAP :FUNCTION FUNCTION
			    :PROCEED-TYPES :NO-ACTION
			    :BREAKON-THIS-TIME-FRAME (%STACK-FRAME-POINTER)))
  (LEXPR-FUNCALL FUNCTION ARGS))

(DEFMETHOD (CLEAR-INPUT-P BREAKON-TRAP) () NIL)

(DEFMETHOD (MAKE-INSTANCE BREAKON-TRAP) (&KEY BREAKON-THIS-TIME-FRAME &ALLOW-OTHER-KEYS)
  ;; Find the frame containing the encapsulated version of the function
  (SETQ REAL-FRAME
	(BLOCK FIND-REAL-FRAME
	  (LET ((FOUND-BREAKON NIL)
		(FUNCTION-NAME (FUNCTION-NAME FUNCTION)))
	    (MAP-OVER-FRAMES-IN-STACK %CURRENT-STACK-GROUP
	      #'(LAMBDA (FRAME IGNORE FRAME-FUNCTION)
		  (WHEN (EQ FRAME BREAKON-THIS-TIME-FRAME)
		    (SETQ FOUND-BREAKON T))
		  (WHEN (AND FOUND-BREAKON
			     (OR (EQ FUNCTION FRAME-FUNCTION)
				 ;; Encapsulations might be interpreted, in which
				 ;; case we need to do a little but of decoding
				 (AND (EQ FRAME-FUNCTION #'(:PROPERTY DTP-LIST SI:INTERPRETER-FUNCTION))
				      (LET* ((LOCATION (%POINTER-PLUS FRAME
								      (DEFSTORAGE-SIZE STACK-FRAME)))
					     (FORM (SYS:%MEMORY-READ LOCATION :CYCLE-TYPE %MEMORY-SCAVENGE))
					     (UNDIGESTED-FORM (SI:UNDIGEST FORM))
					     (FSPEC (FUNCTION-NAME UNDIGESTED-FORM)))
					(EQ FSPEC FUNCTION-NAME)))))
		    (RETURN-FROM FIND-REAL-FRAME FRAME)))))
	  BREAKON-THIS-TIME-FRAME)))

(DEFMETHOD (:DEBUGGER-ENTRY-HOOK BREAKON-TRAP) ()
  (SETF (DEBUGGER-TRACE-FLAG REAL-FRAME) T))

(DEFMETHOD (CURRENT-AND-INNERMOST-FRAMES-FOR-DEBUGGER BREAKON-TRAP) (IGNORE)
  (VALUES REAL-FRAME REAL-FRAME))

(DEFMETHOD (CONDITION-TYPE BREAKON-TRAP) () "Break")

(DEFMETHOD (REPORT BREAKON-TRAP) (STREAM)
  (FORMAT STREAM "Break on entry to function ~S~%" (FUNCTION-NAME FUNCTION)))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE BREAKON-TRAP :NO-ACTION) (STREAM)
  (SEND STREAM :STRING-OUT "Proceed with the call"))


;;; Trap-on-Exit

(DEFFLAVOR RETURN-FROM-TRACED-FRAME-TRAP
	(TRAPPING-FUNCTION
	 RETURNED-VALUES
	 RETURNED-VALUES-LOCATIONS)
	(TRAP DEBUGGER-CONDITION)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (CLEAR-INPUT-P RETURN-FROM-TRACED-FRAME-TRAP) () NIL)

(DEFMETHOD (:VALUES-BEING-RETURNED RETURN-FROM-TRACED-FRAME-TRAP) ()
  (VALUES RETURNED-VALUES RETURNED-VALUES-LOCATIONS))

(DEFMETHOD (:DECODE-FRAME-EXIT RETURN-FROM-TRACED-FRAME-TRAP) ()
  (DECLARE (VALUES EXIT-NAME RETURN-NAME FUNCTION-NAME FRAME CATCH-TAG CATCH-TARGET))
  (LET* ((EXIT-NAME "exit from")
	 (RETURN-NAME "returned")
	 (TRUE-TRAPPING-FUNCTION (%FIND-STRUCTURE-HEADER MACRO-PC))
	 CATCH-TAG CATCH-TARGET)
    (BLOCK ANALYZE-THROW
      (WHEN (EQ TRUE-TRAPPING-FUNCTION #'(:INTERNAL SYS:%THROW 0 SI:%THROW-INTERNAL))
	;;--- Boy, does this ever know too much about how SYS:%THROW is implemented!
	(LET* ((NEXT-FP (FRAME-NEXT-ACTIVE-FRAME TRAPPING-FRAME))
	       (CB (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST))
	       (SP (%POINTER-PLUS NEXT-FP -1)))
	  (IF ( (%POINTER-DIFFERENCE MACRO-PC TRUE-TRAPPING-FUNCTION)
		 (- (%FIXNUM-FLOOR (CCA-N-INSTRUCTIONS (COMPILED-FUNCTION-CCA
							 TRUE-TRAPPING-FUNCTION)) 2) 2))
	      ;; It's the second %RETURN-MULTIPLE in SI:%THROW-INTERNAL, so the top of the
	      ;; stack contains:
	      ;;   the values being thrown, in appropriate format for the catch block
	      ;;   the PC to throw to
	      ;;   the address of the target catch block's tag word
	      ;;   the address of the next frame
	      ;;   the number of catch blocks to close
	      ;;   the number of words here
	      (SETQ CB (%POINTER-PLUS (LOCATION-CONTENTS (%POINTER-PLUS NEXT-FP -4)) 1)
		    SP (%POINTER-PLUS NEXT-FP -6))
	      ;; It's the first %RETURN-MULTIPLE in SI:%THROW-INTERNAL, so the top of the
	      ;; stack contains only a multiple group of the values being thrown.
	      ;; The catch's value-disposition is return, finding it can be tricky.
	      ;; But it's the innermost catch that hasn't been thrown-through, except
	      ;; when we have already returned from the frame where the catch was.
	      (LOOP WHILE (AND CB (OR (NOT (ZEROP (CATCH-BLOCK-UNWIND-PROTECT CB)))
				      (NOT (ZEROP (CATCH-BLOCK-INVALID CB)))
				      (NOT (%POINTER-LESSP CB TRAPPING-FRAME))))
		    DO (SETQ CB (CATCH-BLOCK-PREVIOUS CB))
		    FINALLY
		      (UNLESS (AND CB
				   (= (CATCH-BLOCK-VALUE-DISPOSITION CB)
				      VALUE-DISPOSITION-RETURN)
				   (LOOP FOR FRAME = TRAPPING-FRAME
						   THEN (FRAME-PREVIOUS-FRAME TRAPPING-FRAME)
					 UNTIL (%POINTER-LESSP FRAME CB)
					 AS CR = (FRAME-OWN-CONTROL-REGISTER FRAME)
					 ALWAYS (= (LDB %%CR.VALUE-DISPOSITION CR)
						   VALUE-DISPOSITION-RETURN)))
			;; Must have already popped the catch
			(RETURN-FROM ANALYZE-THROW))))
	  ;; Get the information out of the target catch block
	  (SETQ CATCH-TAG (CATCH-BLOCK-TAG CB)
		CATCH-TARGET (CATCH-BLOCK-PC CB)
		RETURNED-VALUES-LOCATIONS 
		  (SELECT (CATCH-BLOCK-VALUE-DISPOSITION CB)
		    (VALUE-DISPOSITION-VALUE (LIST SP))
		    ((VALUE-DISPOSITION-MULTIPLE VALUE-DISPOSITION-RETURN)
		     (LET ((N-VALUES (LOCATION-CONTENTS SP)))
		       (LOOP FOR P = (%POINTER-PLUS SP (- N-VALUES)) THEN (%POINTER-PLUS P 1)
			     REPEAT N-VALUES
			     COLLECT P)))
		    (OTHERWISE NIL))
		RETURNED-VALUES (MAPCAR #'LOCATION-CONTENTS RETURNED-VALUES-LOCATIONS)
		EXIT-NAME "throw through"
		RETURN-NAME "thrown"))))
    (VALUES EXIT-NAME RETURN-NAME
	    (FUNCTION-NAME TRAPPING-FUNCTION) TRAPPING-FRAME
	    CATCH-TAG CATCH-TARGET)))

(DEFMETHOD (DOCUMENT-PROCEED-TYPE RETURN-FROM-TRACED-FRAME-TRAP :NO-ACTION) (STREAM)
  (MULTIPLE-VALUE-BIND (EXIT-NAME NIL FUNCTION-NAME)
      (SEND SELF :DECODE-FRAME-EXIT)
    (FORMAT STREAM "Continue to ~A ~S" EXIT-NAME FUNCTION-NAME)))

(DEFMETHOD (REPORT RETURN-FROM-TRACED-FRAME-TRAP) (STREAM)
  (MULTIPLE-VALUE-BIND (EXIT-NAME RETURN-NAME FUNCTION-NAME FRAME CATCH-TAG CATCH-TARGET)
      (SEND SELF :DECODE-FRAME-EXIT)
    (SETF (DEBUGGER-TRACE-FLAG FRAME) NIL)		;Don't get error again
    (FORMAT STREAM "Break on ~A ~S;" EXIT-NAME FUNCTION-NAME)
    (WHEN CATCH-TAG
      (FORMAT STREAM " throwing to tag ~S" CATCH-TAG)
      (WHEN CATCH-TARGET
	(MULTIPLE-VALUE-BIND (FUNCTION PC) (SI:DECODE-PC CATCH-TARGET)
	  (FORMAT STREAM " at PC ~O in ~S" PC (FUNCTION-NAME FUNCTION))))
      (FORMAT STREAM ";"))
    (COND ((NULL RETURNED-VALUES)
	   (FORMAT STREAM "~%no values are being ~A." RETURN-NAME))
	  (T
	   (FORMAT STREAM "~%value~P being ~A: " (LENGTH RETURNED-VALUES) RETURN-NAME)
	   (FORMAT-TEXTUAL-LIST RETURNED-VALUES #'PRIN1 :FILLED T)))))

(DEFMETHOD (PROCEED RETURN-FROM-TRACED-FRAME-TRAP :NO-ACTION) ()
  "Go ahead and return."
  :NO-ACTION)

;; Return as expected.
(DEFMETHOD (:TRAP-PROCEED RETURN-FROM-TRACED-FRAME-TRAP :NO-ACTION) ()
  ;; If SIGNAL-TRAP-ON-EXIT changed the PC, change it back
  (WITH-STACK-FRAME-ARRAY ((%STACK-FRAME-POINTER))
    (SETF (FRAME-CALLER-CONTINUATION (FRAME-NEXT-OPEN-FRAME
				       (FRAME-NEXT-ACTIVE-FRAME TRAPPING-FRAME)))
	  MACRO-PC))
  (CL:APPLY #'%THROW 'RETURN-VALUES-FROM-EXIT-TRAP RETURNED-VALUES))

(DEFUN SIGNAL-TRAP-ON-EXIT (FRAME FUNCTION)
  (DECLARE (ERROR-REPORTER))
  (LET ((*INNERMOST-VISIBLE-FRAME* (%STACK-FRAME-POINTER)))
    (SETQ FRAME (FOLLOW-CELL-FORWARDING FRAME NIL))
    (WITH-STACK-FRAME-ARRAY (FRAME)
      (LET* ((TRAPPING-PC (BLOCK TRAPPING-PC
			    (MAP-OVER-FRAMES-IN-STACK %CURRENT-STACK-GROUP
			      #'(LAMBDA (FP IGNORE PC)
				  (WHEN (EQ FP FRAME)
				    (RETURN-FROM TRAPPING-PC PC)))
			      T)))
	     (TOP-OF-STACK (%POINTER-PLUS FRAME (+ (FRAME-SIZE FRAME) -1)))
	     (INSTRUCTION (PACKED-INSTRUCTION-FROM-PC TRAPPING-PC))
	     VALUES VALUES-LOCATIONS)
	(OPCODE-SELECT INSTRUCTION
	  ((RETURN-SINGLE)
	   (SELECT (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION)
	     (%REGISTER-TOS
	      (SETQ VALUES (LIST (LOCATION-CONTENTS TOP-OF-STACK))
		    VALUES-LOCATIONS (LIST TOP-OF-STACK)))
	     (%REGISTER-CONSTANT-T
	      (SETQ VALUES (LIST T)))
	     (%REGISTER-CONSTANT-NIL
	      (SETQ VALUES (LIST NIL)))))
	  ((RETURN-MULTIPLE)
	   (SELECT (LDB %%PACKED-INSTRUCTION-ADDRESSING-MODE INSTRUCTION)
	     (STACK-ADDRESSING-MODE-STACK-POINTER
	      (LET ((N-VALUES (LOCATION-CONTENTS TOP-OF-STACK)))
		(SETQ VALUES (LOOP FOR I FROM (- N-VALUES) BELOW 0
				   COLLECT (%P-CONTENTS-OFFSET TOP-OF-STACK I)))
		(SETQ VALUES-LOCATIONS (LOOP FOR I FROM (- N-VALUES) BELOW 0
					     COLLECT (%POINTER-PLUS TOP-OF-STACK I)))))
	     (STACK-ADDRESSING-MODE-IMMEDIATE
	      (LET ((N-VALUES (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION)))
		(SETQ VALUES (LOOP FOR I FROM (- 1 N-VALUES) UPTO 0
				   COLLECT (%P-CONTENTS-OFFSET TOP-OF-STACK I)))
		(SETQ VALUES-LOCATIONS (LOOP FOR I FROM (- 1 N-VALUES) UPTO 0
					     COLLECT (%POINTER-PLUS TOP-OF-STACK I)))))))
	  ((RETURN-KLUDGE)
	   ;;--- Value disposition is funny.
	   ;;--- In fact, this whole instruction is funny.
	   (FERROR "Why are you doing a trap-on-exit from a trap-handler?"))
	  #+++IGNORE
	  ((FINISH-CALL-N FINISH-CALL-N-APPLY FINISH-CALL-TOS FINISH-CALL-TOS)
	   ;; This should never happen, because the PC will be pointing to the return
	   ;; instruction of the function which this finish-call called.
	   (FERROR "Call up Symbolics and ask for BEE or Efland")))
	;; TRAPPING-PC can be in the wrong function due to destination return
	;; or due to throw.  If so, adjust the stack so (FRAME-FUNCTION FRAME)
	;; will return FUNCTION.  Must bind *INNERMOST-VISIBLE-FRAME* back
	;; or FRAME-NEXT-OPEN-FRAME will not return the right answer.
	(LET ((*INNERMOST-VISIBLE-FRAME* (%STACK-FRAME-POINTER)))
	  (WHEN (AND FUNCTION
		     (NOT (EQ (%FIND-STRUCTURE-HEADER TRAPPING-PC) FUNCTION)))
	    (SETF (FRAME-CALLER-CONTINUATION (FRAME-NEXT-OPEN-FRAME
					       (FRAME-NEXT-ACTIVE-FRAME FRAME)))
		  (%MAKE-PC FUNCTION (CCA-N-INSTRUCTIONS (COMPILED-FUNCTION-CCA FUNCTION))))))
	(SIGNAL 'RETURN-FROM-TRACED-FRAME-TRAP
		:TRAPPING-FRAME FRAME		;the frame in which we did c-x E
		:TRAPPING-FUNCTION FUNCTION	;the frame-function of that frame
		:TRAP-FRAME FRAME		;--- not really right...
		:MACRO-PC TRAPPING-PC		;the PC where we actually took the trap
		:RETURNED-VALUES VALUES
		:RETURNED-VALUES-LOCATIONS VALUES-LOCATIONS
		:PROCEED-TYPES '(:NO-ACTION))
	;; If we changed the PC, change it back
	(LET ((*INNERMOST-VISIBLE-FRAME* (%STACK-FRAME-POINTER)))
	  (WHEN (AND FUNCTION
		     (NOT (EQ (%FIND-STRUCTURE-HEADER TRAPPING-PC) FUNCTION)))
	    (SETF (FRAME-CALLER-CONTINUATION (FRAME-NEXT-OPEN-FRAME
					       (FRAME-NEXT-ACTIVE-FRAME FRAME)))
		  TRAPPING-PC)))))))



(DEFUN MERGE-TRAPS (TRAP1 TRAP2 TRAP3)
  (FLET ((GET-TRAP-MERGE-HANDLER (TRAP1 TRAP2)
	   (OR (CADR (CL:ASSOC (CAR TRAP2) (GET (CAR TRAP1) 'TRAP-MERGE-HANDLER-ALIST)))
	       #'(LAMBDA (TRAP1 TRAP2)
		   `(UNKNOWN-TRAP-COMBINATION :TRAP1 ,TRAP1 :TRAP2 ,TRAP2)))))
    (MACROLET ((MERGE-TWO-TRAPS (TRAP1 TRAP2)
		 `(IF ,TRAP1
		      (FUNCALL (GET-TRAP-MERGE-HANDLER ,TRAP1 ,TRAP2) ,TRAP1 ,TRAP2)
		      ,TRAP2)))
      (LET ((SINGLE-TRAP TRAP1))
	(WHEN TRAP2
	  (SETQ SINGLE-TRAP (MERGE-TWO-TRAPS SINGLE-TRAP TRAP2)))
	(WHEN TRAP3
	  (SETQ SINGLE-TRAP (MERGE-TWO-TRAPS SINGLE-TRAP TRAP3)))
	(OR SINGLE-TRAP
	    '(TRAP-FERROR :FORMAT-STRING "Unable to determine cause of microcode error trap"
			  :SHOW-INTERNAL-STATE T))))))

(DEFUN HANDLE-WRONG-TYPE-ARGUMENT (FAULT-PC TRAPPING-FRAME TRAP-FRAME ARG TYPE)
  (LET ((INSTRUCTION
	  (OR (PACKED-INSTRUCTION-FROM-PC FAULT-PC)
	      (RETURN-FROM HANDLE-WRONG-TYPE-ARGUMENT
		'(TRAP-FERROR :FORMAT-STRING
		   "A full word instruction signalled a wrong-type-argument error"
		   :SHOW-INTERNAL-STATE T)))))
    (WHEN (ZEROP ARG)				;This means "INDEX"
      (OPCODE-SELECT INSTRUCTION
	(FAST-AREF-1 (SETQ ARG 1))
	(FAST-ASET-1 (SETQ ARG 2))
	(OTHERWISE (RETURN-FROM HANDLE-WRONG-TYPE-ARGUMENT
		     `(TRAP-FERROR :FORMAT-STRING
			"I don't know what the index argument is for the ~A instruction."
			:FORMAT-ARGS (,(PC-INFO FAULT-PC))
			:SHOW-INTERNAL-STATE T)))))
    (MULTIPLE-VALUE-BIND (VALUE NIL N-ARGS)
	(DECODE-PACKED-INSTRUCTION-ARGUMENT INSTRUCTION TRAPPING-FRAME TRAP-FRAME ARG)
      ;; Now we have the actual argument.  See if it is actually the correct type.
      (UNLESS (SELECTOR TYPE =
		(0 (TYPE-MEMBER VALUE DTP-FIXNUM))
		(1 (TYPE-MEMBER VALUE DTP-INSTANCE DTP-LIST-INSTANCE
				      DTP-STRING-INSTANCE DTP-ARRAY-INSTANCE))
		(2 (TYPE-MEMBER VALUE DTP-LOCATIVE))
		(3 (TYPE-MEMBER VALUE DTP-ARRAY DTP-ARRAY-INSTANCE
				      DTP-STRING DTP-STRING-INSTANCE))
		(4 (TYPE-MEMBER VALUE DTP-FIXNUM DTP-SMALL-RATIO DTP-SINGLE-FLOAT
				      DTP-DOUBLE-FLOAT DTP-BIGNUM DTP-BIG-RATIO
				      DTP-COMPLEX DTP-SPARE-NUMBER))
		(5 (TYPE-MEMBER VALUE DTP-LIST DTP-LOCATIVE))
		(6 (TYPE-MEMBER VALUE DTP-NIL DTP-LOCATIVE DTP-LIST DTP-LIST-INSTANCE))
		(7 (TYPE-MEMBER VALUE DTP-CHARACTER))
		(8. (TYPE-MEMBER VALUE DTP-NIL DTP-LIST DTP-LIST-INSTANCE))
		(9. (TYPE-MEMBER VALUE DTP-EVEN-PC DTP-ODD-PC))
		(10. (TYPE-MEMBER VALUE DTP-LOCATIVE DTP-LIST DTP-LIST-INSTANCE))
		(OTHERWISE
		  (RETURN-FROM HANDLE-WRONG-TYPE-ARGUMENT
		    `(TRAP-FERROR
		       :FORMAT-STRING "Invalid data-type code ~S in trap dispatch table"
		       :FORMAT-ARGS (,TYPE)
		       :SHOW-INTERNAL-STATE T))))
	;; We don't want to store the value in the condition object since it might
	;; be something funny like #<DTP-NULL 37>.  We can't store the locative to
	;; the argument either, due to funny types like EVCP's and immediate arguments.
	`(WRONG-TYPE-ARGUMENT-TRAP
	   :ARGUMENT-NUMBER ,(IF (ZEROP ARG) N-ARGS ARG)
	   :ARGUMENT-TYPE   ,(AREF *TRAP-SCL-TYPES* TYPE))))))

;; Returns NIL if the PC points to a full-word instruction.
(DEFUN PACKED-INSTRUCTION-FROM-PC (PC)
  (LET ((INSTRUCTION (%MEMORY-READ PC :CYCLE-TYPE %MEMORY-SCAVENGE)))
    (WHEN ( (DPB -1 %%Q-ODD-INSTRUCTION-WITHIN-TAG (%TAG INSTRUCTION))
	     DTP-PACKED-INSTRUCTION-77)
      (RETURN-FROM PACKED-INSTRUCTION-FROM-PC NIL))
    (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	(LDB %%Q-EVEN-INSTRUCTION (%POINTER INSTRUCTION))
	(DPB (LDB %%Q-ODD-INSTRUCTION-WITHIN-TAG (%TAG INSTRUCTION))
	     %%ODD-INSTRUCTION-TAG-COMPONENT
	     (LDB %%Q-ODD-INSTRUCTION-WITHIN-POINTER (%POINTER INSTRUCTION))))))

;; Argument of zero means last argument.
;; Otherwise argument number, 1-based.
(DEFUN DECODE-PACKED-INSTRUCTION-ARGUMENT (INSTRUCTION FRAME NEXT-FRAME ARGUMENT)
  (DECLARE (VALUES ARGUMENT-VALUE ARGUMENT-LOCATION
		   INSTRUCTION-N-ARGUMENTS ARGUMENTS-ON-STACK))
  (LET ((OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION)))
    (DESTRUCTURING-BIND (N-ARGS N-RETURNED FORMAT)
	(I-LISP-COMPILER:GET-OPCODE-FORMAT OPCODE)
      (DECLARE (IGNORE N-RETURNED))
      (LET ((ARG-OFFSET (IF (ZEROP ARGUMENT) 0 (- N-ARGS ARGUMENT)))
	    (OPERAND (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION))
	    (ADDRESSING-MODE (LDB %%PACKED-INSTRUCTION-ADDRESSING-MODE INSTRUCTION))
	    (ARGUMENT-VALUE NIL)
	    (ARGUMENT-LOCATION NIL)
	    (ARGUMENTS-ON-STACK (1- N-ARGS)))
	(IF (ZEROP ARG-OFFSET)
	    (IF (= ADDRESSING-MODE STACK-ADDRESSING-MODE-IMMEDIATE)
		(SETQ ARGUMENT-VALUE (IF (CL:MEMBER 'UNSIGNED FORMAT)
					 OPERAND
					 (SIGN-EXTEND-8 OPERAND)))
	      (SETQ ARGUMENT-LOCATION
		    (SELECTOR ADDRESSING-MODE =
		      (STACK-ADDRESSING-MODE-FRAME-POINTER
			(%POINTER-PLUS FRAME OPERAND))
		      (STACK-ADDRESSING-MODE-LOCAL-POINTER
			(%POINTER-PLUS FRAME
			  (+ (%P-LDB %%CR.ARGUMENT-SIZE (%POINTER-PLUS NEXT-FRAME 1))
			     OPERAND)))
		      (OTHERWISE ;STACK-ADDRESSING-MODE-STACK-POINTER
			(%POINTER-PLUS NEXT-FRAME
				       (IF (NOT (ZEROP OPERAND))
					   (- OPERAND 256.)
					 (INCF ARGUMENTS-ON-STACK)	;SP|POP
					 -1)))))
	      (SETQ ARGUMENT-VALUE (%MEMORY-READ ARGUMENT-LOCATION
						 :CYCLE-TYPE %MEMORY-SCAVENGE)))
	  (LET ((ACTUAL-ARG-OFFSET (- ARG-OFFSET)))
	    (WHEN (AND (ZEROP OPERAND)
		       (= (LDB %%PACKED-INSTRUCTION-ADDRESSING-MODE INSTRUCTION)
			  STACK-ADDRESSING-MODE-STACK-POINTER))
	      (DECF ACTUAL-ARG-OFFSET)
	      (INCF ARGUMENTS-ON-STACK))
	    (SETQ ARGUMENT-LOCATION (%POINTER-PLUS NEXT-FRAME ACTUAL-ARG-OFFSET)
		  ARGUMENT-VALUE (%MEMORY-READ ARGUMENT-LOCATION
					       :CYCLE-TYPE %MEMORY-SCAVENGE))))
	(VALUES ARGUMENT-VALUE ARGUMENT-LOCATION N-ARGS ARGUMENTS-ON-STACK)))))



(DEFUN ERROR-TRAP-HANDLER-1 (FAULT-PC MICROSTATE VMA TRAP-DESCRIPTOR TRAPPING-FRAME TRAP-FRAME)
  (DECLARE (DBG:ERROR-REPORTER))
  (LET* ((OLD-INHIBIT-CONSING-FLAG SI:*INHIBIT-CONSING-FLAG*)
	 (SG %CURRENT-STACK-GROUP)
	 (LEVEL (SG-ERROR-TRAP-LEVEL SG)))
    (COMPILER:%ERROR-WHEN (> LEVEL 20.)
      (WIRED-FERROR :PROCEEDABLE-HALT "Too many recursive errors"))
    (UNWIND-PROTECT
	(PROGN
	    ;; The recursion level cannot be kept using dynamic binding
	    ;; due to BINDING-STACK-OVERFLOW.
	    (SETF (SG-ERROR-TRAP-LEVEL SG) (1+ LEVEL))
	    (SI:%REVERT-TO-EMULATOR-MODE)
	    (MACROLET ((HANDLE (N)
			 (LET ((CLASS-BYTE (FINTERN "%%TRAP-DESC-CONDITION-~D-CLASS" N))
			       (OP1-BYTE   (FINTERN "%%TRAP-DESC-CONDITION-~D-OP1" N))
			       (OP2-BYTE   (FINTERN "%%TRAP-DESC-CONDITION-~D-OP2" N)))
			   `(SELECTOR (LDB ,CLASS-BYTE TRAP-DESCRIPTOR) =
			      (%TRAP-CLASS-WRONG-TYPE-ARGUMENT
				(HANDLE-WRONG-TYPE-ARGUMENT
				  FAULT-PC TRAPPING-FRAME TRAP-FRAME
				  (LDB ,OP1-BYTE TRAP-DESCRIPTOR)
				  (LDB ,OP2-BYTE TRAP-DESCRIPTOR)))
			      (%TRAP-CLASS-MISC-CONDITION
				(FUNCALL (%MEMORY-READ
					   (%POINTER-PLUS *TRAP-MISC-CONDITION-TABLE*
							  (LDB ,OP2-BYTE TRAP-DESCRIPTOR)))
					 (LDB ,OP2-BYTE TRAP-DESCRIPTOR) FAULT-PC VMA
					 TRAPPING-FRAME TRAP-FRAME))
			      (OTHERWISE NIL)))))
	      (CATCH '%RETURN-FROM-TRAP
		;; Unconditionally allow consing here since otherwise we'll just
		;; blow out recursively in one of the allocate escapes.
		(SETQ SI:*INHIBIT-CONSING-FLAG* NIL)
		(LET* ((TRAP1 (HANDLE 1))
		       (TRAP2 (HANDLE 2))
		       (TRAP3 (HANDLE 3))
		       (MAKE-INSTANCE-ARGS (MERGE-TRAPS TRAP1 TRAP2 TRAP3)))
		  (SIGNAL-TRAP (CL:APPLY #'MAKE-INSTANCE (CAR MAKE-INSTANCE-ARGS)
					 :VMA VMA
					 :MACRO-PC FAULT-PC
					 :MICROSTATE MICROSTATE
					 :TRAPPING-FRAME TRAPPING-FRAME
					 :TRAP-FRAME TRAP-FRAME
					 (CDR MAKE-INSTANCE-ARGS)))))))
	(COMPILER:%ERROR-WHEN OLD-INHIBIT-CONSING-FLAG
	  (SETQ SI:*INHIBIT-CONSING-FLAG* OLD-INHIBIT-CONSING-FLAG)
	  (SI:CLEAR-CONS-CACHES))
	(SETF (SG-ERROR-TRAP-LEVEL SG) LEVEL))))



(DEFUN PRINT-TRAP-DISPATCH-TABLE (&OPTIONAL TABLE-OR-VERSION (STREAM STANDARD-OUTPUT))
  (LOOP WITH TABLE = (CL:TYPECASE TABLE-OR-VERSION
		       (CL:FIXNUM (AREF *TRAP-DISPATCH-TABLES* TABLE-OR-VERSION))
		       (CL:NULL (%FIND-STRUCTURE-HEADER *TRAP-DISPATCH-TABLE*))
		       (OTHERWISE TABLE-OR-VERSION))
	FOR I BELOW 1_11.
	AS ENTRY = (AREF TABLE I) DO
    (WHEN (NOT (ZEROP ENTRY))
      (PRINT-TRAP-DISPATCH-TABLE-ENTRY I ENTRY STREAM)))
  (FORMAT T "~2&     * indicates vma-valid"))

(DEFUN PRINT-TRAP-DISPATCH-TABLE-ENTRY (INDEX ENTRY &OPTIONAL (STREAM STANDARD-OUTPUT))
  (FLET ((PRINT-CONDITION (CONDITION NEWLINE)
	   (WHEN (NOT (ZEROP CONDITION))
	     (WHEN NEWLINE (FORMAT STREAM "~%      "))
	     (LET ((OP1 (LDB %%TRAP-DESC-CONDITION-1-OP1 CONDITION))
		   (OP2 (LDB %%TRAP-DESC-CONDITION-1-OP2 CONDITION)))
	       (SELECTOR (LDB %%TRAP-DESC-CONDITION-1-CLASS CONDITION) =
		 (%TRAP-CLASS-NO-ERROR
		   (FORMAT STREAM "NO-ERROR ~O ~O" OP1 OP2))
		 (%TRAP-CLASS-MISC-CONDITION
		   (FORMAT STREAM "MISC ~O ~A" OP1
			   (SUBSTRING (NTH OP2 *TRAP-MISC-CONDITIONS*) 6)))
		 (%TRAP-CLASS-WRONG-TYPE-ARGUMENT
		   (FORMAT STREAM "WRONG-TYPE-ARGUMENT ~A " (IF (ZEROP OP1) "INDEX" OP1))
		   (CLI::PRINT-TYPE-DESCRIPTION (AREF *TRAP-SCL-TYPES* OP2)
						STANDARD-OUTPUT))
		 (%TRAP-CLASS-TRAP-ON-EXIT
		   (FORMAT STREAM "TRAP-ON-EXIT ~O ~O" OP1 OP2)))))))
    (FORMAT STREAM "~%~4O ~:[ ~;*~]" INDEX (LDB-TEST %%TRAP-DESC-VMA-VALID ENTRY))
    (IF (ZEROP ENTRY)
	(FORMAT STREAM "No error table entry")
      (PRINT-CONDITION (LDB (BYTE 10.  0.) ENTRY) NIL)
      (PRINT-CONDITION (LDB (BYTE 10. 10.) ENTRY) T)
      (PRINT-CONDITION (LDB (BYTE 10. 20.) ENTRY) T))))
    
(DEFUN PRINT-MISC-CONDITION-TABLE ()
  (LOOP FOR LOC = *TRAP-MISC-CONDITION-TABLE* THEN (%POINTER-PLUS LOC 1)
	FOR L = *TRAP-MISC-CONDITIONS* THEN (CDR L)
	FOR I BELOW (^ 2 (BYTE-SIZE %%TRAP-DESC-CONDITION-1-OP2))
	DO (FORMAT T "~%~52A ~S"
		   (OR (CAR L) I)
		   (SI:COMPILED-FUNCTION-NAME (LOCATION-CONTENTS LOC)))))

(FORMAT:DEFFORMAT I-WORD (:ONE-ARG) (WORD IGNORE)
  (PRINT-I-WORD-COMPONENTS (%TAG WORD) (%POINTER WORD) FORMAT:*FORMAT-OUTPUT*))

(FORMAT:DEFFORMAT INDIRECT-I-WORD (:ONE-ARG) (POINTER IGNORE)
  (PRINT-I-WORD-COMPONENTS (%P-LDB %%Q-TAG POINTER)
			   (%P-LDB %%Q-POINTER POINTER)
			   FORMAT:*FORMAT-OUTPUT*))

(DEFUN PRINT-I-WORD (WORD STREAM)
  (LET ((TAG (%TAG WORD))
	(POINTER (%POINTER WORD)))
    (PRINT-I-WORD-COMPONENTS TAG POINTER STREAM)))

(DEFUN PRINT-I-WORD-COMPONENTS (TAG POINTER STREAM)
    (LOOP REPEAT 4
	  WITH TOP-FOUR = (DPB TAG (BYTE 8. 2) (%LOGLDB (BYTE 2 30.) POINTER))
	  FOR SHIFT FROM -9. BY 3
	  DO (SEND STREAM :TYO
		   (CODE-CHAR (+ (CHAR-CODE #/0) (LOGAND (LSH TOP-FOUR SHIFT) 7)))))
    (LOOP REPEAT 10.
	  WITH PTR = (%LOGDPB 0 (BYTE 2 30.) POINTER)
	  FOR SHIFT FROM -27. BY 3
	  DO (SEND STREAM :TYO
		   (CODE-CHAR (+ (CHAR-CODE #/0) (LOGAND (LSH PTR SHIFT) 7)))))
    (SEND STREAM :STRING-OUT " (")
    (SEND STREAM :TYO (CODE-CHAR (+ (CHAR-CODE #/0) (LDB %%Q-CDR-CODE-WITHIN-TAG TAG))))
    (SEND STREAM :TYO #/.)
    (LOOP REPEAT 3
	  WITH PTR = (LDB %%Q-TYPE-WITHIN-TAG TAG)
	  FOR SHIFT FROM -6. BY 3
	  DO (SEND STREAM :TYO
		   (CODE-CHAR (+ (CHAR-CODE #/0) (LOGAND (LSH PTR SHIFT) 7)))))
    (SEND STREAM :TYO #/.)
    (LOOP REPEAT 11.
	  FOR SHIFT FROM -30. BY 3
	  DO (SEND STREAM :TYO
		   (CODE-CHAR (+ (CHAR-CODE #/0) (LOGAND (LSH POINTER SHIFT) 7)))))
    (SEND STREAM :TYO #/) ))

(DEFUN EXECUTE-AND-CONTINUE (TRAP-PC BPT TRACE-P)
  (LET* ((INSTRUCTION-TYPE (BPT-DATA-TYPE BPT))
	 (INSTRUCTION-POINTER (BPT-INSTRUCTION BPT))
	 (TRACER
	   (IF TRACE-P
	       #'(LAMBDA (PC)
		   (SETF (%P-LDB %%CR.INSTRUCTION-TRACE (LOCF (%SAVED-CONTROL-REGISTER))) 1)
		   PC)
	       #'(LAMBDA (PC)
		   PC)))
	 (JUMP-POP (DPBS I-LISP-COMPILER:*%JUMP-OPCODE* %%PACKED-INSTRUCTION-OPCODE
			 STACK-ADDRESSING-MODE-STACK-POINTER
			 %%PACKED-INSTRUCTION-ADDRESSING-MODE
			 0)))
    (MACROLET ((CALL-TRACER (PC-TYPE PC-POINTER)
		 `(PROGN
		    (%BLOCK-WRITE
		      1
		      (%SET-TAG TRACER (DPB SEQUENCING-PC-EVEN+2-ODD+3
					    %%Q-CDR-CODE-WITHIN-TAG
					    DTP-CALL-COMPILED-EVEN)))
		    (%BLOCK-WRITE
		      1
		      (%SET-TAG ,PC-POINTER
				(DPB SEQUENCING-PC-EVEN+2-ODD+3
				     %%Q-CDR-CODE-WITHIN-TAG
				     ,PC-TYPE)))
		    (%BLOCK-WRITE
		      1
		      (%SET-TAG
			(SI:%LOGDPBS (LDB %%ODD-INSTRUCTION-DATA-COMPONENT JUMP-POP)
				     %%Q-ODD-INSTRUCTION-WITHIN-POINTER
				     I-LISP-COMPILER:*FINISH-CALL-N-OPCODE*
				     %%PACKED-INSTRUCTION-OPCODE
				     VALUE-DISPOSITION-VALUE
				     %%PACKED-INSTRUCTION-VALUE-DISPOSITION
				     2)
			(DPBS SEQUENCING-PC+1
			      %%Q-CDR-CODE-WITHIN-TAG
			      (LDB %%ODD-INSTRUCTION-TAG-COMPONENT JUMP-POP)
			      %%Q-ODD-INSTRUCTION-WITHIN-TAG
			      DTP-PACKED-INSTRUCTION-60)))))
	       (SUFFIX ()
		 `(%BLOCK-WRITE
		    1
		    (%SET-TAG '(NIL) (DPB SEQUENCING-FENCE %%Q-CDR-CODE-WITHIN-TAG DTP-NIL)))))
    (WHEN (>= INSTRUCTION-TYPE DTP-PACKED-INSTRUCTION-60)
      (LET* ((INSTRUCTION-BITS
	       (IF (EVENP (BPT-PC BPT))
		   (LDB %%Q-EVEN-INSTRUCTION (%POINTER INSTRUCTION-POINTER))
		   (DPB (LDB %%Q-ODD-INSTRUCTION-WITHIN-TAG INSTRUCTION-TYPE)
			%%ODD-INSTRUCTION-TAG-COMPONENT
			(LDB %%Q-ODD-INSTRUCTION-WITHIN-POINTER
			     (%POINTER INSTRUCTION-POINTER)))))
	     (OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)))
	(WHEN (= OPCODE I-LISP-COMPILER:*BRANCH-OPCODE*)
	  ;; 0 START-CALL-DIRECT tracer
	  ;; 2 PUSH-CONSTANT #<DTP-PC Branch-dest>
	  ;; 4 FINISH-CALL-1-VALUE
	  ;; 5 %JUMP SP|POP
	  (MULTIPLE-VALUE-BIND (CCA FUNCTION)
	      (MAKE-COMPILED-CODE (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
				     3
				     1)
				  1
				  *DEFAULT-CONS-AREA*)
	    (DECLARE (IGNORE CCA))
	    (SI:WITH-BLOCK-REGISTERS (1)
	      (SI:SAVING-REGISTERS (%REGISTER-BAR-1)
	        (SETF (%BLOCK-REGISTER 1) FUNCTION)
		(LET ((OFFSET
			(+ (I-LISP-COMPILER:SIGN-EXTEND
			     (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS) 10.)
			   (LDB (BYTE 1 0) (%TAG TRAP-PC)))))
		  (CALL-TRACER (+ DTP-EVEN-PC (LDB (BYTE 1 0) OFFSET))
			       (%POINTER-PLUS TRAP-PC (ASH OFFSET -1))))
		(SUFFIX)))
	    (SETF (%SAVED-CONTINUATION-REGISTER) (%SET-TAG FUNCTION DTP-EVEN-PC))
	    (RETURN-FROM EXECUTE-AND-CONTINUE NIL)))
	(WHEN (OR (<= I-LISP-COMPILER:*BRANCH-TRUE-OPCODE*
		      OPCODE
		      I-LISP-COMPILER:*BRANCH-FALSE-AND-NO-POP-ELSE-NO-POP-EXTRA-POP-OPCODE*)
		  (= OPCODE I-LISP-COMPILER:*LOOP-INCREMENT-TOS-LESS-THAN-OPCODE*)
		  (= OPCODE I-LISP-COMPILER:*LOOP-DECREMENT-TOS-OPCODE*))
	  ;;  0 Cond-branch 10
	  ;;  2 START-CALL-DIRECT traces
	  ;;  4 PUSH-CONSTANT #<DTP-PC Continuation>
	  ;;  6 FINISH-CALL-1-VALUE
	  ;;  7 %JUMP SP|POP
	  ;; 10 START-CALL-DIRECT tracer
	  ;; 12 PUSH-CONSTANCT #<DTP-PC Branch>
	  ;; 14 FINISH-CALL-1-VALUE
	  ;; 15 %JUMP SP|POP
	  (MULTIPLE-VALUE-BIND (CCA FUNCTION)
	      (MAKE-COMPILED-CODE (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
				     7
				     1)
				  1
				  *DEFAULT-CONS-AREA*)
	    (DECLARE (IGNORE CCA))
	    (SI:WITH-BLOCK-REGISTERS (1)
	      (SI:SAVING-REGISTERS (%REGISTER-BAR-1)
		(SETF (%BLOCK-REGISTER 1) FUNCTION)
		(LET ((OFFSET
			(+ (I-LISP-COMPILER:SIGN-EXTEND
			     (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS) 10.)
			   (LDB (BYTE 1 0) (%TAG TRAP-PC)))))
		  (%BLOCK-WRITE
		    1
		    (%SET-TAG
		      (DPB OPCODE
			   %%PACKED-INSTRUCTION-OPCODE
			   #o10)
		      (DPBS SEQUENCING-PC-EVEN+2-ODD+3
			    %%Q-CDR-CODE-WITHIN-TAG
			    DTP-PACKED-INSTRUCTION-60)))
		  (CALL-TRACER
		    (%DATA-TYPE (%SAVED-CONTINUATION-REGISTER))
		    (%SAVED-CONTINUATION-REGISTER))
		  (CALL-TRACER
		    (+ DTP-EVEN-PC (LDB (BYTE 1 0) OFFSET))
		    (%POINTER-PLUS TRAP-PC (ASH OFFSET -1)))
		  (SUFFIX))))
	    (SETF (%SAVED-CONTINUATION-REGISTER) (%SET-TAG FUNCTION DTP-EVEN-PC))
	    (RETURN-FROM EXECUTE-AND-CONTINUE NIL)))))
    ;; 0 or 1 instruction
    ;; 2 START-CALL-DIRECT tracer
    ;; 4 PUSH-CONSTANT #<DTP-PC Continuation>
    ;; 6 FINISH-CALL-1-VALUE
    ;; 7 %JUMP SP|POP
    (MULTIPLE-VALUE-BIND (CCA FUNCTION)
	(MAKE-COMPILED-CODE (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
			       4
			       1)
			    1
			    *DEFAULT-CONS-AREA*)
      (DECLARE (IGNORE CCA))
      (SI:WITH-BLOCK-REGISTERS (1)
	(SI:SAVING-REGISTERS (%REGISTER-BAR-1)
	  (SETF (%BLOCK-REGISTER 1) FUNCTION)
	  (%BLOCK-WRITE 1 (%SET-TAG INSTRUCTION-POINTER
				    (DPB (IF (EVENP (BPT-PC BPT))
					     SEQUENCING-PC-EVEN+2-ODD+3
					     SEQUENCING-PC+1)
					 %%Q-CDR-CODE-WITHIN-TAG
					 INSTRUCTION-TYPE)))
	  (CALL-TRACER
	    (%DATA-TYPE (%SAVED-CONTINUATION-REGISTER))
	    (%SAVED-CONTINUATION-REGISTER))
	  (SUFFIX)))
      (SETF (%SAVED-CONTINUATION-REGISTER)
	    (%SET-TAG FUNCTION (IF (EVENP (BPT-PC BPT)) DTP-EVEN-PC DTP-ODD-PC)))))))

(DEFUN GENERIC-BREAKPOINT-HANDLER (OBJECT)
  (IGNORE OBJECT)
  ;; Return NIL to force debugger entry
  NIL)


(DEFINE-INSTRUCTION-EXCEPTION-HANDLER %PROC-BREAKPOINT TRAP-MODE-EMULATOR (&PC PC)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
    (MULTIPLE-VALUE-BIND (FUNCTION REL-PC)
	(SI:DECODE-PC PC)
      (LET ((*CURRENT-BREAKPOINT-INFO* (ILC:ANY-BREAKPOINT-IN-FUNCTION FUNCTION REL-PC))
	    (*STEP-FROM-BREAKPOINT* NIL))
	(CONDITION-BIND ((BREAKPOINT 'GENERIC-BREAKPOINT-HANDLER))
	  (SIGNAL 'BREAKPOINT :FRAME (%STACK-FRAME-POINTER)))
	(EXECUTE-AND-CONTINUE PC *CURRENT-BREAKPOINT-INFO* *STEP-FROM-BREAKPOINT*))))
  (COMPILER:%PUSH-N 1)
  (RETURN-KLUDGE (VALUES)))

;; Not exactly traps, but really pretty close
(DEFFLAVOR UNDEFINED-ARITHMETIC-FUNCTION-ERROR (BASE-FRAME MACRO-PC-LOC MACRO-PC) (ERROR)
  (:INITABLE-INSTANCE-VARIABLES BASE-FRAME MACRO-PC)
  (:REQUIRED-INIT-KEYWORDS :BASE-FRAME)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (DOCUMENT-PROCEED-TYPE UNDEFINED-ARITHMETIC-FUNCTION-ERROR :RETURN-VALUE) (STREAM)
  (LET ((NAME (PC-INFO MACRO-PC)))
    (FORMAT STREAM "Return a value from the ~A instruction" NAME)))

(DEFMETHOD (PROCEED UNDEFINED-ARITHMETIC-FUNCTION-ERROR :RETURN-VALUE) ()
  (LET ((VALUE (PROMPT-AND-READ :EVAL-FORM
				"Form to evaluate and return: ")))
    (VALUES :RETURN-VALUE VALUE)))

(DEFFLAVOR UNDEFINED-BINARY-ARITHMETIC-FUNCTION-ERROR
	(ARG-1 ARG-2)
	(UNDEFINED-ARITHMETIC-FUNCTION-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT UNDEFINED-BINARY-ARITHMETIC-FUNCTION-ERROR) (STREAM)
  (FORMAT STREAM "The operation ~S is not defined for the arguments ~S and ~S"
	  (PC-INFO MACRO-PC)
	  ARG-1 ARG-2))
  
(DEFFLAVOR UNDEFINED-UNARY-ARITHMETIC-FUNCTION-ERROR
	(ARG)
	(UNDEFINED-ARITHMETIC-FUNCTION-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (REPORT UNDEFINED-UNARY-ARITHMETIC-FUNCTION-ERROR) (STREAM)
  (FORMAT STREAM "The operation ~S is not defined for the argument ~S"
	  (PC-INFO MACRO-PC)
	  ARG))
