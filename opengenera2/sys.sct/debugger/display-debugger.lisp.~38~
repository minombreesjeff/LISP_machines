;;; -*- Mode: LISP; Package: Debugger; Base: 10; Lowercase: Yes -*-

;;; Display Debugger main loop and commands
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


;; The Display Debugger program frame definition
(dw:define-program-framework display-debugger
  :command-definer nil
  :command-table				;only needed to satisfy the canned
    (:inherit-from '("Debugger")		; stuff in define-program-framework
     :kbd-accelerator-p t)
  :selectable nil				;this is not a real activity
  :select-key nil
  :top-level
    (display-debugger-top-level)
  :state-variables
    ((error-object)
     (error-window)
     (error-activity)
     (error-screen)
     (error-process)
     (n-visible-frames)
     (n-invisible-frames)
     (n-uninteresting-frames)
     (inspect-history)
     (displayed-code-for-frame))
  :panes
    ((title :title
	    :height-in-lines 1
	    :redisplay-after-commands nil
	    :redisplay-function 'display-title-pane)
     (buttons :command-menu
	      :menu-level :top-level
	      :default-character-style '(:jess :roman :normal)
	      :columns
	        `(("Abort"         "Proceed"        "Return"     "Reinvoke"   )
		  ("Exit"          "Switch windows" "Help"       "Bug Report" )
		  ("Edit function" "Find Frame"     "Backtrace"  "Source code")
		  ("Breakpoints"   "Monitor"        "Exit traps" "Call traps" )))
     ;; These are in the order in which they should be redisplayed!
     (backtrace :display
		:incremental-redisplay :limit-to-viewport
		:redisplay-function 'display-backtrace-pane
		:end-of-page-mode :truncate
		:margin-components
		  `((dw:margin-ragged-borders :thickness 1)
		    (dw:margin-whitespace :margin :left
					  :thickness 2)
		    (dw:margin-scroll-bar :visibility :if-needed)
		    (dw:margin-scroll-bar :margin :bottom
					  :visibility :if-needed
					  :elevator-thickness 6
					  :shaft-whitespace-thickness 4)
		    (dw:margin-white-borders :thickness 2)
		    (dw:margin-label :string "Backtrace"
				     :style (:swiss :bold-italic :normal)
				     :margin :top)))
     (interactor :listener
		 :margin-components
		   `((dw:margin-ragged-borders :thickness 1)
		     (dw:margin-whitespace :margin :left
					   :thickness 2)
		     (dw:margin-scroll-bar :visibility :normal)
		     (dw:margin-white-borders :thickness 2)))
     (proceed-options :display
		      :incremental-redisplay t
		      :redisplay-function 'display-proceed-options-pane
		      :end-of-page-mode :truncate
		      :margin-components
		        `((dw:margin-ragged-borders :thickness 1)
			  (dw:margin-whitespace :margin :left
						:thickness 2)
			  (dw:margin-scroll-bar :visibility :if-needed)
			  (dw:margin-white-borders :thickness 2)))
     (args-and-locals :display
		      :incremental-redisplay :limit-to-viewport
		      :redisplay-function 'display-arguments-and-locals-pane
		      :end-of-page-mode :truncate
		      :margin-components
		        `((dw:margin-ragged-borders :thickness 1)
			  (dw:margin-whitespace :margin :left
						:thickness 2)
			  (dw:margin-scroll-bar :visibility :if-needed)
			  (dw:margin-scroll-bar :margin :bottom
						:visibility :if-needed
						:elevator-thickness 6
						:shaft-whitespace-thickness 4)
			  (dw:margin-white-borders :thickness 2)
			  (dw:margin-label :string "Arguments, locals, and specials"
					   :style (:swiss :bold-italic :normal)
					   :margin :top)))
     (source-code :display
		  :incremental-redisplay t
		  :redisplay-function 'display-source-or-compiled-code-pane
		  :end-of-page-mode :truncate
		  :margin-components
		    `((dw:margin-ragged-borders :thickness 1)
		      (dw:margin-whitespace :margin :left
					    :thickness 2)
		      (dw:margin-scroll-bar :visibility :if-needed)
		      (dw:margin-scroll-bar :margin :bottom
					    :visibility :if-needed
					    :elevator-thickness 6
					    :shaft-whitespace-thickness 4)
		      (dw:margin-white-borders :thickness 2)))
     (history :display
	      :incremental-redisplay t
	      :redisplay-function 'display-inspect-history-pane
	      :end-of-page-mode :scroll
	      :margin-components
	        `((dw:margin-ragged-borders :thickness 1)
		  (dw:margin-whitespace :margin :left
					:thickness 2)
		  (dw:margin-scroll-bar :visibility :if-needed)
		  (dw:margin-scroll-bar :margin :bottom
					:visibility :if-needed
					:elevator-thickness 6
					:shaft-whitespace-thickness 4)
		  (dw:margin-white-borders :thickness 2))))
  :configurations
    #+++ignore
    ;; This configuration uses only half the top line for the title, so that
    ;; the proceed options get the extra space that it took up.  Also, the
    ;; horizontal dividers line up, giving a more balanced appearance.  Too
    ;; bad we have to hard-wire pixels into the configuration spec :-(.
    '((main
	(:layout
	  (main :column the-works)
	  (the-works :row interactor&c code&c)
          (interactor&c :column title buttons backtrace history interactor)
	  (code&c :column proceed-options source-code args-and-locals))
	(:sizes
	  (main
	    (the-works :even))
	  (the-works
	    (interactor&c 0.50) :then (code&c :even))
	  (interactor&c
	    (title 1 :lines) (buttons 4 :lines) (history 5 :lines) (interactor 315)
	    :then (backtrace :even))
	  (code&c
	    (proceed-options 97) (args-and-locals 315)
	    :then (source-code :even)))))
    #---ignore
    ;; Let's try to do the same as the above without wiring in pixels,
    ;; so it has a chance of flying on the small screen.
    '((main
	(:layout
	  (main :column the-works)
	  (the-works :row interactor&c code&c)
          (interactor&c :column title buttons backtrace history interactor)
	  (code&c :column proceed-options source-code args-and-locals))
	(:sizes
	  (main
	    (the-works :even))
	  (the-works
	    (interactor&c 0.50) :then (code&c :even))
	  (interactor&c
	    (title 1 :lines) (buttons 4 :lines) (history 5 :lines) (interactor .42)
	    :then (backtrace :even))
	  (code&c
	    (proceed-options .130) (args-and-locals .42)
	    :then (source-code :even))))))

(tv:defwindow-resource display-debugger ()
  :make-window
    (dw:program-frame :program 'display-debugger
                      :activate-p t
		      ;; Display debuggers will never stand by themselves
		      :process nil)
  :deinitializer
    (let* ((window object)
	   (program (send window :program)))
      (dw:reset-program-state-variables program
					`((error-object)
					  (error-window)
					  (error-activity)
					  (error-screen)
					  (error-process)
					  (n-visible-frames)
					  (n-invisible-frames)
					  (n-uninteresting-frames)
					  (inspect-history)
					  (displayed-code-for-frame))))
  :initial-copies 0)

;; Allocate a Display Debugger and set up it initial state
(defun enter-display-debugger ()
  (catch 'return-from-display-debugger
    (using-resource (display-debugger display-debugger)
      (let* ((program (send display-debugger :program))
	     (error-window
	       (symeval-in-error-environment 'terminal-io))
	     (error-activity
	       (and (instancep error-window)
		    (send-if-handles error-window :alias-for-selected-windows)))
	     (error-screen
	       (or (and (instancep error-window)
			(send-if-handles error-window :screen))
		   tv:main-screen)))
	;; Tell the program what object it's editing, etc.
	(multiple-value-bind (n-visible n-invisible n-uninteresting)
	    (loop with n-visible = 0
		  with n-invisible = 0
		  with n-uninteresting = 0
		  for frame = *innermost-interesting-frame*
			    then (frame-previous-active-frame frame)
		  for i below 10000.
		  until (null frame)
		  do (with-language-for-frame (frame)
		       (if (not (frame-interesting-p frame nil))
			   (incf n-uninteresting)
			 (incf n-invisible)
			 (unless (frame-invisible-p frame)
			   (incf n-visible))))
		  finally (return (values n-visible n-invisible n-uninteresting)))
	  (dw:reset-program-state-variables program
					    `((error-object ,*error*)
					      (error-window ,error-window)
					      (error-activity ,error-activity)
					      (error-screen ,error-screen)
					      (error-process ,sys:current-process)
					      (n-visible-frames ,n-visible)
					      (n-invisible-frames ,n-invisible)
					      (n-uninteresting-frames ,n-uninteresting)
					      (inspect-history ())
					      (displayed-code-for-frame nil))))
	;; Clear all of the per-entry frames.  What this means is that we don't
	;; need for all of the redisplayers to use the error-object (*ERROR*) in 
	;; their caches, because all old stuff disappears every time.
	(loop for pane-name in '(title proceed-options history 
				 source-code args-and-locals backtrace interactor)
	      as pane = (send display-debugger :get-pane pane-name)
	      do (send pane :clear-history))
	;; Shadow the activity being debugged with the Display Debugger frame,
	;; so that the Select key will find it, etc.
	(tv:with-window-shadowed-for-selection (error-window display-debugger :reselect t)
	  (tv:window-call (display-debugger :deactivate)
	    (send display-debugger :activate)
	    (send display-debugger :select)
	    ;; Run the display-debugger's top-level form
	    (dw:program-frame-top-level display-debugger)))))))


(defvar *display-debugger-disable-aborts* t)

;; *CURRENT-FRAME* and *CURRENT-LANGUAGE* are still around from the original
;; invocation to the normal Debugger
(defmethod (display-debugger-top-level display-debugger) (&rest options)
  (ignore options)
  (let ((*inside-display-debugger* t)
	(*backtrace-type* *backtrace-type*)
	(*display-debugger-show-source-code* *display-debugger-show-source-code*)
	(*aborting-disabled* *display-debugger-disable-aborts*))
    ;; Sometimes we need to access DW:*PROGRAM-FRAME* and DW:*PROGRAM*
    ;; during the execution of user forms in order to redisplay nicely.
    (with-stack-list* (*variables-not-to-inherit*
		       'dw:*program-frame* 'dw:*program* 'tv:*default-inspector-frame*
		       *variables-not-to-inherit*)
      ;; Remind the user of the error
      (print-error-message error-object nil nil t)
      ;; Just show the name of the function, but not the arguments, since
      ;; they can be found elsewhere on the screen
      (let ((function (frame-function *current-frame*)))
	(format t "~&The current frame is ")
	(print-carefully "function name"
	  (when (closurep function)
	    (princ "a closure of "))
	  (with-character-style (*emphasis-character-style*)
	    (present (lframe-frame-function-name *current-language* *current-frame*)
		     (language-function-spec-type *current-language*)))))
      ;; Remind the user of the proceed options (particularly the Super keys)
      (show-proceed-options)
      (using-resource (tv:*default-inspector-frame* tv:inspect-frame-resource)
	(tv:reset-inspector-frame tv:*default-inspector-frame* nil t)
	(debugger-command-loop dw:*program-frame*)))))

(defmethod (display-debugger-activity-state display-debugger) ()
  (values error-window error-activity error-screen error-object error-process))

(defmethod (dw:program-frame-asynchronous-refresh-handler display-debugger) (frame)
  (ignore frame)
  ;;--- This needs to do some magic to get some panes to redisplay correctly
  )

(define-presentation-type highlighting-arrow ()
   :printer ((arrow stream)
	     (if arrow
		 (format stream "~C " #\arrow:right-open-arrow)
	       (format stream "  "))))

(defun ensure-presentation-visible (stream presentation &optional (additional-lines 5))
  (when presentation
    (multiple-value-bind (left top right bottom)
	(send stream :visible-cursorpos-limits)
      (let* ((box (dw:presentation-displayed-box presentation))
	     (box-left (dw::box-left box))
	     (box-right (dw::box-right box))
	     (box-top (dw::box-top box))
	     (box-bottom (dw::box-bottom box)))
	;; If desired item is not visible, move it into the viewport.
	(unless (and ( box-left left)
		     ( box-right right)
		     ( box-top top)
		     ( box-bottom bottom))
	  (send stream :scroll-to-visible-cursor
		(if (< box-left left) box-left box-right)
		(+ (if (< box-top top) box-top box-bottom)
		   (* additional-lines (send stream :line-height)))))))))

(defmethod (dw:program-frame-override-name-for-select-handler display-debugger) (frame)
  (ignore frame)
  (format nil "Display Debugger~:[~; on ~:*~A~]" error-activity))

(defmethod (display-title-pane display-debugger) (stream)
  (dw::centering-line (stream)
    (format stream "Display Debugger~:[~; on ~:*~A~]" error-activity)))

(defmethod (display-proceed-options-pane display-debugger) (stream)
  (let ((standard-output stream))
    (dw:with-redisplayable-output (:unique-id *error*
				   :cache-value *error*)
      (loop for p in *proceed-dispatch-table*
	    as pp = (cons (cdr p) error-object)
	    do (dw:with-redisplayable-output (:unique-id pp
					      :id-test #'equal
					      :cache-value pp
					      :cache-test #'equal)
		 (print-carefully "proceed option"
		   (present pp 'proceed-option))
		 (terpri))))))

(defmethod (display-inspect-history-pane display-debugger) (stream)
  (let ((standard-output stream)
	(cl:*print-pretty* nil))
    (dw:with-redisplayable-output (:unique-id *error*
				   :cache-value *inspect-history-pane-tick*)
      (dw:with-redisplayable-output (:unique-id 'title
				     :cache-value 'constant)
	(format t "~VInspect history~" '(:swiss :bold-italic :normal)))
      (let ((last-object nil))
	(declare (special last-object))
	(loop for (object . rest) on inspect-history
	      do (dw:with-redisplayable-output (:unique-id object
						:cache-value object)
		   (terpri)
		   (dw:with-output-truncation (t :horizontal t)
		     (if (null rest)
			 (setq last-object (present object 'sys:form))
		       (present object 'sys:form))))
	      finally (ensure-presentation-visible stream last-object 0))))))

(defmethod (maintain-inspect-history-pane display-debugger) (object)
  ;; Don't remember things which are utterly trivial
  (unless (or (symbolp object)			;includes NIL
	      (numberp object)
	      (characterp object)
	      (stringp object))
    ;; Only one copy of the object in the inspect history
    (setq inspect-history (delq object inspect-history))
    ;; Put the new object at the very top of the history
    (setq inspect-history (append inspect-history (ncons object)))
    ;; Redisplay the inspect history pane
    (redisplay-tick *inspect-history-pane-tick*)))

(defmethod (display-backtrace-pane display-debugger) (stream)
  (when (send standard-input :listen)
    (return-from display-backtrace-pane))
  (let* ((standard-output stream)
	 (old-current-frame *current-frame*)
	 ;; If the current frame is "uninteresting", then include uninteresting
	 ;; frames in the backtrace
	 (include-uninteresting (not (frame-interesting-p old-current-frame)))
	 (include-invisible (or (eq *backtrace-type* :invisible)
				(frame-invisible-p old-current-frame)))
	 (*current-frame* *innermost-interesting-frame*)
	 (highlighting-arrow nil)
	 (*censor-invisible-frames* (not include-invisible))
	 (n-frames (+ (if include-invisible n-invisible-frames n-visible-frames)
		      (if include-uninteresting n-uninteresting-frames 0)))
	 (cl:*print-pretty* nil))
    (declare (special highlighting-arrow))
    (dw:with-redisplayable-output (:unique-id *error*
				   :cache-value *backtrace-pane-tick*)
      (print-backtrace 10000. 0 include-uninteresting
	(lambda (frame count ignore)
	  (let ((inhibit-y-limit (null highlighting-arrow)))
	    (dw:with-redisplayable-output
	        (:unique-id frame
		 :vertical-fraction (rational-quotient count n-frames)
		 :inhibit-viewport-y-limit inhibit-y-limit)
	      (let ((at-current-frame (eq frame old-current-frame)))
		(dw:with-redisplayable-output (:cache-value at-current-frame
					       :inhibit-viewport-y-limit inhibit-y-limit)
		  (let ((arrow (present at-current-frame 'highlighting-arrow)))
		    (when at-current-frame
		      (setq highlighting-arrow arrow)))))
	      (dw:with-redisplayable-output (:cache-value (cons (frame-function frame)
								(debugger-trace-flag frame))
					     :cache-test #'equal
					     :inhibit-viewport-y-limit inhibit-y-limit)
		(present-stack-frame frame)
		(when (debugger-trace-flag frame)
		  (format t " ~V(trap on exit)~" '(nil nil :smaller))))
	      (terpri))))))
    (ensure-presentation-visible stream highlighting-arrow)))

(defmethod (display-arguments-and-locals-pane display-debugger) (stream)
  (when (send standard-input :listen)
    (return-from display-arguments-and-locals-pane))
  (let* ((standard-output stream)
	 (frame *current-frame*)
	 ;; Abbreviate arguments and locals heavily
	 (cl:*print-pretty* nil)
	 (cl:*print-level* *error-message-prinlevel*)
	 (cl:*print-length* *error-message-prinlength*)
	 (scl:*print-string-length* *error-message-string-length*)
	 (cl:*print-array* nil)
	 (cl:*print-circle* nil)
	 (scl:*print-structure-contents* nil))
    (dw:with-redisplayable-output (:unique-id frame
				   :cache-value *args-and-locals-pane-tick*)
      ;; Set up the scroll-bar size for this pane.  The number will be a bit
      ;; small, because the printers might show both an arg and a local (if 
      ;; they're different), plus an occasional line of descriptive text.
      (multiple-value-bind (special-start special-end)
	  (lframe-special-pdl-range *current-language* *current-frame*)
	(let* ((n-specials (if special-start
			       (let ((n-specials 1))
				 (map-over-bindings
				   (lambda (&rest ignore) (incf n-specials))
				   special-start special-end)
				 n-specials)
			     0))
	       (n-args-and-locals
		 (+ (frame-number-of-locals frame)
		    (if (zerop (frame-lexical-called frame))
			0
		      (length (car (frame-lexical-environment frame))))
		    (multiple-value-bind (captive-block captive-map)
			(lframe-captive-info frame)
		      (if (and captive-map captive-block)
			  (length captive-map)
			  0))
		    n-specials))
	       (local-start (print-frame-args frame 0 t n-args-and-locals)))
	  ;; Show the locals, if there are any
	  (when (frame-active-p frame)
	    (print-frame-locals frame local-start 0 n-args-and-locals))
	  ;; Show the specials bound in this frame, too
	  (when special-start
	    (lframe-print-specials *current-language* frame
				   special-start special-end
				   n-specials n-args-and-locals))
	  #+imach (when (ldb-test %%cr.call-started (frame-own-control-register frame))
		    (describe-open-subframes frame 1)))))))

(defun possibly-clipped-cache-value (object-top object-bottom
				     viewport-top viewport-bottom
				     cache-value)
  (if (and viewport-top
	   (or (> object-top viewport-bottom)
	       (< object-bottom viewport-top)))
      :clipped
    (if (or (null viewport-top)
	    (and ( object-top viewport-top)
		 ( object-bottom viewport-bottom)))
	cache-value
      :partially-clipped)))

(defun possibly-clipped-cache-test (old new &optional (test #'eq))
  (or (eq new :clipped)
      (and (neq new :partially-clipped)
	   (funcall test new old))))

(defmethod (display-source-or-compiled-code-pane display-debugger) (stream)
  (when (send standard-input :listen)
    (return-from display-source-or-compiled-code-pane))
  (let* ((standard-output stream)
	 (frame *current-frame*)
	 (function (frame-function frame))
	 (highlighting-arrow nil))
    (declare (special highlighting-arrow))
    (dw:with-redisplayable-output (:unique-id frame
				   :cache-value *source-code-pane-tick*)
      (if (typep function :compiled-function)
	  (multiple-value-bind (ignore viewport-top ignore viewport-bottom)
	      (send-if-handles stream :visible-cursorpos-limits :character)
	    #+3600
	    (let* ((start-pc (compiled-function-initial-pc function))
		   (end-pc (llc:disassemble-lim-pc function))
		   (pc-now (if frame (or (frame-relative-exit-pc frame) end-pc) nil)))
	      (when (null displayed-code-for-frame)
		;; Offset the viewport in order to center PC-NOW on the pane
		(let* ((height (- viewport-bottom viewport-top))
		       (offset (+ (- pc-now (floor height 2)) -4)))
		  (incf viewport-top offset)
		  (incf viewport-bottom offset))
		(setq displayed-code-for-frame t))
	      ;; Print the name of the function
	      (dw:with-redisplayable-output (:unique-id 'function-name
					     :cache-value (function-name function)
					     :cache-test #'equal)
		(print-carefully "function name"
		  (with-character-style (*emphasis-character-style*)
		    ;; We don't need the pretty-name here, because the
		    ;; code is right in front of our very eyes
		    (present (lframe-function-name *current-language* function nil)
			     (language-function-spec-type *current-language*)))
		  (terpri)))
	      (if (and (lframe-show-source-code-p *current-language*)
		       (si:function-correspondence-info function))
		  ;; Show function source code if that's what's wanted
		  (dw:with-redisplayable-output (:unique-id frame
						 :cache-value 'constant)
		    (lframe-show-code-for-function *current-language* frame function
						   t nil nil))
		  ;; The user wants to see disassembled code, or we can't oblige
		  ;; him with source-code
		  (print-carefully "disassembled code"
		    (loop with cl:*print-pretty* = nil
			  with cca = (cca-compiled-code-object
				       (compiled-function-cca function))
			  for pc = start-pc
				 then (+ pc (llc:disassemble-instruction-length function pc))
			  for line-number from 1
			  until ( pc end-pc)
			  as clipped = (possibly-clipped-cache-value
					 line-number line-number
					 viewport-top viewport-bottom
					 :not-clipped)
			  doing
		      (if (eq clipped :clipped)
			  (dw:with-redisplayable-output (:unique-id pc
							 :cache-value clipped)
			    (tyo #\space)
			    (terpri))
			  (let ((at-pc-now (eq pc pc-now))
				(breakpoint (llc:any-breakpoint-in-function cca pc)))
			    (dw:with-redisplayable-output (:unique-id pc)
			      (dw:with-redisplayable-output (:cache-value at-pc-now)
				(let ((arrow (present at-pc-now 'highlighting-arrow)))
				  (when at-pc-now
				    (setq highlighting-arrow arrow))))
			      (dw:with-redisplayable-output (:cache-value breakpoint)
				(with-character-style ((and at-pc-now *emphasis-character-style*))
				  (llc:disassemble-instruction function pc)))
			      (terpri))))
			  finally
			    (let ((at-pc-now (eq pc pc-now)))
			      (when at-pc-now
				(dw:with-redisplayable-output (:unique-id pc
							       :cache-value at-pc-now)
				  (let ((arrow (present at-pc-now 'highlighting-arrow)))
				    (when at-pc-now
				      (setq highlighting-arrow arrow)))
				  (terpri))))))))
	    #+imach
	    (multiple-value-bind (cca extra-info vca pc-now pc-0 pc-1 count)
		(lframe-setup-for-disassembly *current-language* frame function)
	      (declare (ignore pc-0 pc-1 count))
	      (when (null displayed-code-for-frame)
		;; Offset the viewport in order to center PC-NOW on the pane
		(let* ((height (- viewport-bottom viewport-top))
		       (offset (+ (- pc-now (floor height 2)) -4)))
		  (incf viewport-top offset)
		  (incf viewport-bottom offset))
		(setq displayed-code-for-frame t))
	      ;; Print the name of the function
	      (dw:with-redisplayable-output (:unique-id 'function-name
					     :cache-value (function-name function)
					     :cache-test #'equal)
		(print-carefully "function name"
		  (with-character-style (*emphasis-character-style*)
		    ;; We don't need the pretty-name here, because the
		    ;; code is right in front of our very eyes
		    (present (lframe-function-name *current-language* function nil)
			     (language-function-spec-type *current-language*)))
		  (terpri)))
	      (if (and (lframe-show-source-code-p *current-language*)
		       (si:function-correspondence-info function))
		  ;; Show function source code if that's what's wanted
		  (dw:with-redisplayable-output (:unique-id frame
						 :cache-value 'constant)
		    (lframe-show-code-for-function *current-language* frame function
						   t nil nil))
		  ;; The user wants to see disassembled code, or we can't oblige
		  ;; him with source-code
		  (print-carefully "disassembled code"
		    (let* ((cl:*print-pretty* nil)
			   (stack-array (i-lisp-compiler:compute-stack-description function))
			   (relative-pc 0))
		      (loop named disassemble
			    for displayed-line-number from 1
			    doing
			(let ((clipped NIL #|| (possibly-clipped-cache-value
					 displayed-line-number displayed-line-number
					 viewport-top viewport-bottom
					 :not-clipped)||#))
			  (if (eq clipped :clipped)
			      (dw:with-redisplayable-output (:unique-id relative-pc
							     :cache-value clipped)
				(tyo #\space)
				(terpri))
			      (let ((at-pc-now (eq relative-pc pc-now))
				    (breakpoint (ilc:any-breakpoint-in-function
						  cca relative-pc)))
				(dw:with-redisplayable-output
				    (:unique-id RELATIVE-PC)
				  (dw:with-redisplayable-output (:cache-value at-pc-now)
				    (let ((arrow
					    (present at-pc-now 'highlighting-arrow)))
				      (when at-pc-now
					(setq highlighting-arrow arrow))))
				  (dw:with-redisplayable-output
				      (:cache-value breakpoint)
				    (with-character-style
				      ((and (eq relative-pc pc-now)
					    *emphasis-character-style*))
				      (ilc:disassemble-instruction
					cca
					relative-pc
					(cdr (cl:assoc relative-pc vca))
					stack-array
					(cdr extra-info))
				      (terpri)))))))
			(incf relative-pc
			      (select (ldb %%q-cdr-code-within-tag
					   (%TAG
					     (%memory-read
					       (%pointer-plus
						 cca (+ (ldb (byte 31. 1.) relative-pc)
							(defstorage-size compiled-function)))
					       :cycle-type %memory-scavenge
					       :set-cdr-next nil)))
				(sequencing-pc+1 1)
				(sequencing-fence (return-from disassemble nil))
				(sequencing-pc-1 -1)
				(sequencing-pc-even+2-odd+3
				 (+ 2 (ldb (byte 1 0) relative-pc)))))))
		    (unless highlighting-arrow
		      (dw:with-redisplayable-output (:unique-id 'last-pc :cache-value t)
			(setq highlighting-arrow (present t 'highlighting-arrow))
			(terpri))))))
		  )
	  ;; Interpreted function, grind it into the pane
	  (dw:with-redisplayable-output (:unique-id 'function-name
					 :cache-value (function-name function)
					 :cache-test #'equal)
	    (with-character-style (*emphasis-character-style*)
	      (present (lframe-function-name *current-language* function nil)
		       (language-function-spec-type *current-language*)))
	    (terpri))
	  (dw:with-redisplayable-output (:unique-id frame
					 :cache-value 'constant)
	    (gprint:print-object (si:undigest function) :form))))
    (ensure-presentation-visible stream highlighting-arrow)))


(defmacro define-menu-button (command name &key (gesture :left) (documentation t))
  (dw::define-command-menu-handler-internal name 'display-debugger
    '(:top-level) (if (listp gesture) gesture (list gesture))
    documentation nil
    '(&rest args)
    `((declare (dw::accelerator-for ,command))
      (cl:apply #'dw:standard-command-menu-handler
		',command
		:command-table 'display-debugger
		args))))

;; Here are all of the mouse-clicks for all of the menu-buttons
(define-menu-button com-abort-display-debugger "Abort"
  :gesture :left
  :documentation "Abort from the error")

(define-menu-button com-proceed "Proceed"
  :gesture :left
  :documentation "Proceed from the error")

(define-menu-button com-edit-function "Edit function"
  :gesture :left
  :documentation "Edit the function for this frame")

(define-menu-button com-display-source-code "Source code"
  :gesture :left
  :documentation "Show source code in the source pane")
(define-menu-button com-display-compiled-code "Source code"
  :gesture :middle
  :documentation "Show compiled code")
(define-menu-button com-choose-source-or-compiled-code "Source code"
  :gesture :right
  :documentation "Menu for choosing source or compiled code")

(define-menu-button com-return "Return"
  :gesture :left
  :documentation "Return from the current frame")
(define-menu-button com-display-debugger-return "Return"
  :gesture :middle
  :documentation "Return from an arbitrary frame")

(define-menu-button com-reinvoke "Reinvoke"
  :gesture :left
  :documentation "Reinvoke the current frame")
(define-menu-button com-display-debugger-reinvoke "Reinvoke"
  :gesture :middle
  :documentation "Reinvoke an arbitrary frame")

(define-menu-button com-display-debugger-find-frame "Find Frame"
  :gesture :left
  :documentation "Search for a frame on the stack")

(define-menu-button com-display-debugger-find-frame-again "Find Frame"
  :gesture :middle
  :documentation "Re-execute previous search")

(define-menu-button com-mail-bug-report "Bug Report"
  :gesture :left
  :documentation "Send a bug report")

(define-menu-button com-exit-from-display-debugger "Exit"
  :gesture :left
  :documentation "Exit the Display Debugger, staying in the error context")

(define-menu-button com-switch-windows "Switch windows"
  :gesture :left
  :documentation "Switch to original window (Function S to return to Display Debugger)")

(define-menu-button com-help "Help"
  :gesture :left
  :documentation "Show the Help text for the Display Debugger")

(define-menu-button com-show-breakpoints "Breakpoints"
  :gesture :left
  :documentation "Show all breakpoints")
(define-menu-button com-clear-all-breakpoints "Breakpoints"
  :gesture :middle
  :documentation "Clear all breakpoints")
(define-menu-button com-choose-breakpoint-command "Breakpoints"
  :gesture :right
  :documentation "Menu of breakpoint commands")

(define-menu-button com-show-monitored-locations "Monitor"
  :gesture :left
  :documentation "Show all monitored locations")
(define-menu-button com-choose-monitor-command "Monitor"
  :gesture :right
  :documentation "Menu of monitor commands")

(define-menu-button com-set-trap-on-exit "Exit traps"
  :gesture :left
  :documentation "Set trap-on-exit for this frame")
(define-menu-button com-clear-trap-on-exit "Exit traps"
  :gesture :middle
  :documentation "Clear trap-on-exit for this frame")
(define-menu-button com-choose-exit-trap-command "Exit traps"
  :gesture :right
  :documentation "Menu of trap-on-exit commands")

(define-menu-button com-set-trap-on-call "Call traps"
  :gesture :left
  :documentation "Set trap-on-call")
(define-menu-button com-clear-trap-on-call "Call traps"
  :gesture :middle
  :documentation "Clear trap-on-call")
(define-menu-button com-choose-call-trap-command "Call traps"
  :gesture :right
  :documentation "Menu of trap-on-call commands")

(define-menu-button com-display-ordinary-backtrace "Backtrace"
  :gesture :left
  :documentation "Show ordinary backtrace in backtrace pane")
(define-menu-button com-display-invisible-backtrace "Backtrace"
  :gesture :middle
  :documentation "Include invisible frames")
(define-menu-button com-choose-backtrace-type "Backtrace"
  :gesture :right
  :documentation "Menu of backtrace commands")


(cp:define-command (com-abort-display-debugger :command-table "Debugger"
					       :provide-output-destination-keyword nil)
    ()
  ;; Kludgy way to do the Abort
  (loop for entry in *proceed-dispatch-table*
	do (when (mem #'char-equal #\Abort (car entry))
	     (format t "~&")
	     (execute-restart (cdr entry) nil t)))
  (beep)
  (format t "~&There are no restart handlers for ABORT"))

(cp:define-command (com-exit-from-display-debugger :command-table "Debugger"
						   :provide-output-destination-keyword nil)
    ()
  (if *inside-display-debugger*
      (throw 'return-from-display-debugger nil)
    (format t "~&You are not inside the Display Debugger.")))

(cp:define-command (com-switch-windows :command-table "Debugger"
				       :provide-output-destination-keyword nil)
    ()
  (if *inside-display-debugger*
      (send (display-debugger-error-activity dw:*program*)
	     :select-shadowed-activity (send tv:selected-window :alias-for-selected-windows))
    (format t "~&You are not inside the Display Debugger.")))

(cp:define-command-accelerator exit-from-display-debugger "Debugger" (#\End) () ()
  `(com-exit-from-display-debugger))

(defvar *breakpoint-command-menu*
	`(("Set breakpoint" (com-set-breakpoint t))
	  ("Clear breakpoint" (com-clear-breakpoint t))
	  ("Clear all breakpoints" (com-clear-all-breakpoints nil))
	  ("Show breakpoints" (com-show-breakpoints nil))))

(cp:define-command (com-choose-breakpoint-command :command-table "Debugger"
						  :provide-output-destination-keyword nil)
    ()
  (choose-debugger-menu-command *breakpoint-command-menu* "Breakpoint commands"))

(defvar *monitor-command-menu*
	`(("Monitor variable" (com-monitor-variable t))
	  ("Unmonitor variable" (com-unmonitor-variable t))
	  ("Unmonitor all variables" (com-unmonitor-variable nil))
	  ("Show monitored locations" (com-show-monitored-locations nil))))

(cp:define-command (com-choose-monitor-command :command-table "Debugger"
					       :provide-output-destination-keyword nil)
    ()
  (choose-debugger-menu-command *monitor-command-menu* "Monitor commands"))

(defvar *exit-trap-command-menu*
	`(("Set trap on exit" (com-set-trap-on-exit))
	  ("Set trap on exit (all frames)" (com-set-trap-on-exit t))
	  ("Clear trap on exit" (com-clear-trap-on-exit))
	  ("Clear trap on exit (all frames)" (com-clear-trap-on-exit t))))

(cp:define-command (com-choose-exit-trap-command :command-table "Debugger"
						 :provide-output-destination-keyword nil)
    ()
  (choose-debugger-menu-command *exit-trap-command-menu* "Exit trap commands"))

(defvar *call-trap-command-menu*
	`(("Set trap on call" (com-set-trap-on-call))
	  ("Clear trap on call" (com-clear-trap-on-call))
	  ("Proceed trap on call" (com-proceed-trap-on-call))
	  ("Restart trap on call" (com-restart-trap-on-call))))

(cp:define-command (com-choose-call-trap-command :command-table "Debugger"
						 :provide-output-destination-keyword nil)
    ()
  (choose-debugger-menu-command *call-trap-command-menu* "Call trap commands"))

(defun choose-debugger-menu-command (menu prompt)
  (let ((command (dw:menu-choose menu :prompt (format nil "~V~A~"
						'(:jess :roman :normal) prompt))))
    (when command
      (destructuring-bind (command arg-p) command
	(multiple-value-bind (command args)
	    (cp::command-accelerator-internal
	      #'(lambda (&rest ignore) (list command))
	      nil nil
	      :argument-allowed arg-p
	      :activate (not arg-p))
	  (lexpr-funcall command args))))))

(cp:define-command (com-display-source-code :command-table "Debugger"
					    :provide-output-destination-keyword nil)
    ()
  (when (and *inside-display-debugger*
	     (neq *display-debugger-show-source-code* t))
    (redisplay-tick *source-code-pane-tick*)
    (send (send dw:*program-frame* :get-pane 'source-code) :clear-history)
    (setq *display-debugger-show-source-code* t)))

(cp:define-command (com-display-compiled-code :command-table "Debugger"
					      :provide-output-destination-keyword nil)
    ()
  (when (and *inside-display-debugger*
	     (neq *display-debugger-show-source-code* nil))
    (redisplay-tick *source-code-pane-tick*)
    (send (send dw:*program-frame* :get-pane 'source-code) :clear-history)
    (setq *display-debugger-show-source-code* nil)))

(defvar *source-or-compiled-code-menu*
	`(("Display source code" (com-display-source-code nil))
	  ("Display compiled code" (com-display-compiled-code nil))))

(cp:define-command (com-choose-source-or-compiled-code :command-table "Debugger"
						       :provide-output-destination-keyword nil)
    ()
  (choose-debugger-menu-command *source-or-compiled-code-menu* "Source or compiled code"))

(cp:define-command (com-display-ordinary-backtrace :command-table "Debugger"
						   :provide-output-destination-keyword nil)
    ()
  (when (neq *backtrace-type* :ordinary)
    (redisplay-tick *backtrace-pane-tick*)
    (setq *backtrace-type* :ordinary)))

(cp:define-command (com-display-invisible-backtrace :command-table "Debugger"
						    :provide-output-destination-keyword nil)
    ()
  (when (neq *backtrace-type* :invisible)
    (redisplay-tick *backtrace-pane-tick*)
    (setq *backtrace-type* :invisible)))

(defvar *backtrace-type-menu*
	`(("Display ordinary backtrace" (com-display-ordinary-backtrace nil))
	  ("Display invisible backtrace" (com-display-invisible-backtrace nil))))

(cp:define-command (com-choose-backtrace-type :command-table "Debugger"
					      :provide-output-destination-keyword nil)
    ()
  (choose-debugger-menu-command *backtrace-type-menu* "Backtrace type"))

(cp:define-command (com-display-debugger-find-frame :command-table "Debugger"
						    :provide-output-destination-keyword nil)
    ()
  (let ((frame (accept 'string
		       :prompt "String to search for")))
    (push-stack-frame-pdl)
    (when (find-frame-internal frame nil)
      (show-frame-after-motion :quietly))))

(cp:define-command (com-display-debugger-find-frame-again :command-table "Debugger"
							  :provide-output-destination-keyword nil)
    ()
  (let ((frame (send (dw::find-accept-history 'string) :yank)))
    (push-stack-frame-pdl)
    (when (find-frame-internal frame nil)
      (show-frame-after-motion :quietly))))

;;--- If DW didn't pop up a stupid menu, I could just use COM-ARBITRARY-FRAME-RETURN
(cp:define-command (com-display-debugger-return :command-table "Debugger"
						:provide-output-destination-keyword nil)
    ()
  (let ((frame (accept 'stack-frame
		       :default nil
		       :prompt "Click on a stack-frame to return from")))
    (if (presentation-frame-p frame)
	(com-return-from-frame-internal (car frame))
      (format t "~&~S is not a stack-frame" frame))))

;;--- If DW didn't pop up a stupid menu, I could just use COM-ARBITRARY-FRAME-REINVOKED,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");
0(cp:define-command (com-display-debugger-reinvoke :command-table "Debugger"
						  :provide-output-destination-keyword nil)
    ()
  (let ((frame (accept 'stack-frame
		       :default nil
		       :prompt "Click on a stack-frame to reinvoke")))
    (if (not (presentation-frame-p frame))
	(format t "~&~S is not a stack-frame" frame)
	(query-and-restart-frame (car frame)))))

(compile-flavor-methods display-debugger)


;; Here's how we get into the Display Debugger

(cp:define-command (com-enter-display-debugger :command-table "Debugger"
					       :provide-output-destination-keyword nil)
    ()
  (cond ((neti:remote-terminal-p)
	 (format t
	     "~&The Display Debugger can currently only be used from the main console.~%"))
	(*inside-display-debugger*
	 (format t
	     "~&You cannot recursively enter the Display Debugger."))
	(t (enter-display-debugger))))

(cp:define-command-accelerator enter-display-debugger "Debugger" (#\c-m-W) () ()
  `(com-enter-display-debugger))


;; The help text for the Display Debugger

(defun show-display-debugger-help (&optional (standard-output standard-output))
  (send standard-output :string-out
        "
    You are in the Display Debugger.  The layout of the frame is:

")
  ;; Draw a picture of it, in the kludgiest possible way
  (let ((x-translate   50.)
	(total-height 310.)
	(total-width  500.)
	(left-offset   50.)
	(baseline       5.))
    (flet ((draw-string (string left y1 y2)
	     (graphics:draw-string string
				   (+ left left-offset x-translate)
				   (- (// (+ y1 y2) 2) baseline)))
	   (draw-line (x1 y1 x2 y2)
	     (graphics:draw-line (+ x1 x-translate) y1
				 (+ x2 x-translate) y2)))
      (graphics:with-room-for-graphics (standard-output)
	(with-character-style ('(:swiss :roman :normal))
	  (graphics:draw-rectangle (+ 0 x-translate) 0
				   (+ 0 total-width x-translate) total-height
				   :filled nil :thickness 2)
	  (let ((vertical-divider (* total-width 0.50)))
	    (draw-line vertical-divider 0 vertical-divider total-height)
	    (let ((history-divider (* total-height 0.40))
		  (backtrace-divider (* total-height 0.50))
		  (button-divider (* total-height 0.80))
		  (title-divider (* total-height 0.95)))
	      (draw-line 0 title-divider vertical-divider title-divider)
	      (draw-string "Title" 0 title-divider total-height)
	      (draw-line 0 button-divider vertical-divider button-divider)
	      (draw-string "Menu buttons" 0 button-divider title-divider)
	      (draw-line 0 backtrace-divider vertical-divider backtrace-divider)
	      (draw-string "Backtrace" 0 backtrace-divider button-divider)
	      (draw-line 0 history-divider vertical-divider history-divider)
	      (draw-string "Inspect history" 0 history-divider backtrace-divider)
	      (draw-string "Interactor" 0 0 history-divider))
	    (let ((source-divider (* total-height 0.40))
		  (proceed-divider (* total-height 0.80)))
	      (draw-line vertical-divider proceed-divider total-width proceed-divider)
	      (draw-string "Proceed options" vertical-divider proceed-divider total-height)
	      (draw-line vertical-divider source-divider total-width source-divider)
	      (draw-string "Source code" vertical-divider proceed-divider source-divider)
	      (draw-string "Arguments and locals" vertical-divider source-divider 0)))))))
  (send standard-output :string-out
	"

    The Title pane shows you the name of the /"activity/" which you are debugging.

    The items in the Menu Buttons pane may be clicked on to execute particular commands.
    The mouse documentation line shows what these buttons do in more detail.  Additionally,
    all of the usual Debugger commands may be used by typing them on the keyboard.

    Clicking Mouse-Left on a frame in the Backtrace pane sets the current frame to be
    that frame.  Click Mouse-Right on a frame to get a complete list of gestures on
    stack-frames.

    The Inspect History pane keeps track of all of the /"complex/" Lisp objects which
    you have examined, either via the mouse or via DESCRIBE.  You can click on items
    in the pane to re-examine them.

    Items in the Proceed Options pane may be clicked on to take that proceed option.

    When possible, the code shown in the Source Code pane is sensitive as Lisp forms.
    If no source code is available, you are shown compiled code.

    The Arguments and Locals pane shows you all of the args and locals for the current
    frame.  In particular, you may modify args or locals by click c-m-Mouse-Right on
    an argument or local value.

    Here are a few commands which can be typed at the keyboard:

     (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"):Help
0      c-†        Display the text you are now reading.
    
     Lisp form      Evaluate the form and prints the result.  The form is
                    evaluated in the lexical environment of the current frame iff
                    *INHERIT-LEXICAL-ENVIRONMENT* is non-NIL.")
  (send standard-output :string-out
	"

    Here is the text for the normal Debugger commands.")
  (show-debugger-help standard-output t))
