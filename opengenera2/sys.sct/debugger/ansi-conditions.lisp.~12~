;;; -*- Mode: LISP; Syntax: Common-lisp; Package: CLI; Base: 10 -*-
;;; Common Lisp Condition System compatibility
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains an approximation to what we believe will be in
;;; ANSI Common Lisp in the way of conditions support.  Note that ANSI CL is
;;; a moving target, so don't be surprised if stuff here has to change.
;;; What's here at the time this comment was written corresponds to 
;;; Common Lisp Condition System, version 18 as amended by X3J13 cleanup
;;; issues BREAK-ON-WARNINGS-OBSOLETE (v2), CLOS-CONDITIONS (v4), 
;;; and CONDITION-RESTARTS (v2). (But this kind of comment is the sort that
;;; can quickly become out-of-date, so check what's changed in the file before
;;; you really believe that last sentence.)  -kmp 22-Mar-90


(DEFUN ACCUMULATE-CASE-KEYS (MACRO-NAME CASES LIST-IS-ATOM-P)
  (LET ((KEYS '()))
    (DOLIST (CASE CASES)
      (LET ((KEY (CAR CASE)))
	(COND ((ATOM KEY)
	       (COND ((NULL KEY))
		     ((MEMBER KEY '(OTHERWISE T))
		      (ERROR "OTHERWISE is not allowed in ~S expressions." MACRO-NAME))
		     (T (PUSH KEY KEYS))))
	      (LIST-IS-ATOM-P
	       (PUSH KEY KEYS))
	      (T
	       (DOLIST (K KEY) (PUSH K KEYS))))))
    (NREVERSE KEYS)))

(DEFUN DESCRIBE-ABORT-TO-TOPLEVEL (STREAM)
  (LET ((HANDLER (FIND-ABORT-TO-TOPLEVEL)))
    (SEND (CAR HANDLER) :DESCRIBE-RESTART STREAM)))

(DEFUN ABORT-TO-TOPLEVEL ()
  (RESTART-FROM (FIND-ABORT-TO-TOPLEVEL)))

(DEFUN FIND-ABORT-TO-TOPLEVEL ()
  (DO ((L DBG:*ACTIVE-CONDITIONS-AND-RESTARTS* (DBG:NEXT-ACTIVE-CONDITIONS-AND-RESTARTS L))
       (TOPLEVEL-RESTARTS DBG:*RESTART-HANDLERS* (CADDDR L)))
      ((NULL L) TOPLEVEL-RESTARTS)))

(DEFUN RESTART-FROM (RESTART-HANDLERS)
  (LET ((ABORT-CONDITION (MAKE-CONDITION 'SYS:ABORT)))
    (DO ((L RESTART-HANDLERS (CDR L)))
	((NULL L))
      (LET ((RESTART-HANDLER (CAR L)))
	(WHEN (SEND RESTART-HANDLER :HANDLE-CONDITION-FLAVORS-P '(SYS:ABORT))
	  (SEND RESTART-HANDLER :HANDLE-CONDITION ABORT-CONDITION
		(FOLLOW-CELL-FORWARDING (SYS:%MAKE-POINTER SYS:DTP-LOCATIVE L) NIL))
	  (ERROR "The restart handler ~S is proceeding??" RESTART-HANDLER))))))

(DEFUN GET-IMPLICIT-RESTARTS (CONDITION TAG)
  (OR (CADR TAG)
      (SETF (CADR TAG)
	    (MAPCAR #'(LAMBDA (PROCEED-TYPE)
			(MAKE-RESTART
			  :NAME (CL:CASE PROCEED-TYPE
				  ((:NO-ACTION :CONTINUE-CERROR) 'CONDITIONS:CONTINUE)
				  (OTHERWISE NIL))
			  :FUNCTION
			    #'(LAMBDA (&REST ARGUMENTS)
				(SETQ ARGUMENTS (COPY-LIST ARGUMENTS))	;!!! Genera
				(THROW TAG (CL:APPLY #'VALUES
						     PROCEED-TYPE
						     ARGUMENTS)))
			  :REPORT-FUNCTION
			    #'(LAMBDA (STREAM)
				(DBG:DOCUMENT-PROCEED-TYPE
				  CONDITION PROCEED-TYPE STREAM))
			  :INTERACTIVE-FUNCTION
			    #'(LAMBDA ()
				(CDR (MULTIPLE-VALUE-LIST
				       (DBG:PROCEED CONDITION PROCEED-TYPE))))))
		    (DBG:PROCEED-TYPES CONDITION)))))

(DEFVAR *TOPLEVEL-RESTARTS* (MAKE-HASH-TABLE))

(DEFUN MAKE-TOPLEVEL-RESTART ()
  (OR (GETHASH SYS:CURRENT-PROCESS *TOPLEVEL-RESTARTS*)
      (SETF (GETHASH SYS:CURRENT-PROCESS *TOPLEVEL-RESTARTS*)
	    (MAKE-RESTART :NAME 'CONDITIONS:ABORT
			  :FUNCTION #'(LAMBDA () (ABORT-TO-TOPLEVEL))
			  :REPORT-FUNCTION #'(LAMBDA (STREAM)
					       (DESCRIBE-ABORT-TO-TOPLEVEL STREAM))
			  :INTERACTIVE-FUNCTION #'(LAMBDA () NIL)))))



(DEFVAR *CONDITION-RESTARTS* '())

(DEFMACRO FUTURE-COMMON-LISP:WITH-CONDITION-RESTARTS (CONDITION RESTARTS &BODY FORMS)
  `(STACK-LET ((*CONDITION-RESTARTS* (LIST* ,CONDITION ,RESTARTS *CONDITION-RESTARTS*)))
     ,@FORMS))

(DEFSUBST COMPUTE-EXCLUDED-RESTARTS (CONDITION)
  (WHEN CONDITION
    (DO ((L *CONDITION-RESTARTS* (CDDR L))
	 (E '() (IF (NEQ (CAR L) CONDITION)
		    (APPEND (CADR L) E)	  ;; Really UNION, but that would probably be
		    ;; slower and duplicates don't matter anyway. -kmp
		    E)))
	((NULL L) E))))

(DEFUN CONDITIONS:COMPUTE-RESTARTS (&OPTIONAL CONDITION)
  "Computes a list of all active restarts."
  (LET ((EXCLUDED (COMPUTE-EXCLUDED-RESTARTS CONDITION))
	(EXPLICIT-RESTARTS   DBG:*RESTARTS*)
	(CONDITIONS/RESTARTS DBG:*ACTIVE-CONDITIONS-AND-RESTARTS*)
	(RESULT-LIST '()))
    (LET ((RESULT
	    (DO () (NIL)
	      (COND ((AND (NOT EXPLICIT-RESTARTS) (NOT CONDITIONS/RESTARTS))
		     (RETURN (NRECONC RESULT-LIST (NCONS (MAKE-TOPLEVEL-RESTART)))))
		    ((NOT CONDITIONS/RESTARTS)
		     (DO () ((NOT EXPLICIT-RESTARTS))
		       (DOLIST (R (POP EXPLICIT-RESTARTS))
			 (PUSH R RESULT-LIST))))
		    ((NOT EXPLICIT-RESTARTS)
		     (DO () ((NULL CONDITIONS/RESTARTS))
		       (DOLIST (R (GET-IMPLICIT-RESTARTS (CAR CONDITIONS/RESTARTS)
							 CONDITIONS/RESTARTS))
			 (PUSH R RESULT-LIST))
		       (SETQ CONDITIONS/RESTARTS
			     (DBG:NEXT-ACTIVE-CONDITIONS-AND-RESTARTS CONDITIONS/RESTARTS))))
		    ((EQ (CADDR CONDITIONS/RESTARTS) EXPLICIT-RESTARTS)
		     (DOLIST (R (GET-IMPLICIT-RESTARTS (CAR CONDITIONS/RESTARTS)
						       CONDITIONS/RESTARTS))
		       (PUSH R RESULT-LIST))
		     (SETQ CONDITIONS/RESTARTS
			   (DBG:NEXT-ACTIVE-CONDITIONS-AND-RESTARTS CONDITIONS/RESTARTS)))
		    (T
		     (DOLIST (R (POP EXPLICIT-RESTARTS))
		       (PUSH R RESULT-LIST)))))))
      (IF EXCLUDED (SET-DIFFERENCE RESULT EXCLUDED) RESULT))))

(DEFFLAVOR CONDITIONS:RESTART
	   ((NAME NIL)
	    ;; These functions are properties of each instance, not of each class.
	    ;; Hence, they are not methods. -kmp 21-Feb-90
	    (FUNCTION NIL)
	    (REPORT-FUNCTION NIL)
	    (INTERACTIVE-FUNCTION NIL)
	    (TEST-FUNCTION NIL))
  ()
  :INITABLE-INSTANCE-VARIABLES
  (:CONSTRUCTOR MAKE-RESTART)
  (:READABLE-INSTANCE-VARIABLES
    (CONDITIONS:RESTART-NAME NAME)
    (RESTART-FUNCTION FUNCTION)
    (RESTART-REPORT-FUNCTION REPORT-FUNCTION)
    (RESTART-TEST-FUNCTION TEST-FUNCTION)
    (RESTART-INTERACTIVE-FUNCTION INTERACTIVE-FUNCTION)))

(DEFMETHOD (SYS:PRINT-SELF CONDITIONS:RESTART) (STREAM DEPTH SLASHIFY-P)
  (DECLARE (IGNORE DEPTH))
  (FLET ((UGLY ()
	   (FUTURE-COMMON-LISP:PRINT-UNREADABLE-OBJECT (SELF STREAM :TYPE T :IDENTITY T))))
    (COND (SLASHIFY-P      (UGLY))
	  (REPORT-FUNCTION (FUNCALL REPORT-FUNCTION STREAM))
	  (NAME	           (FORMAT STREAM "~S" NAME))
	  (T 		   (UGLY)))))

(COMPILE-FLAVOR-METHODS CONDITIONS:RESTART)

(DEFMACRO CONDITIONS:RESTART-BIND (BINDINGS &BODY FORMS)
  "Executes a body of code with given restarts handlers active."
  `(RESTART-BIND-TRAMPOLINE
     #'(FUTURE-COMMON-LISP:LAMBDA ()
	 (DECLARE (SYS:DOWNWARD-FUNCTION))
	 ,@FORMS)
     ,@(MAPCAR #'(LAMBDA (BINDING)
		   `(MAKE-RESTART :NAME     ',(CAR BINDING)
				  :FUNCTION ,(CADR BINDING)
				  ,@(CDDR BINDING)))
	       BINDINGS)))

(DEFUN RESTART-BIND-TRAMPOLINE (FUNCTION &REST RESTARTS)
  (DECLARE (DBG:ERROR-REPORTER))
  (LET ((DBG:*RESTARTS* (CONS (CL:COPY-LIST RESTARTS) DBG:*RESTARTS*)))
    (FUNCALL FUNCTION)))

(DEFUN CONDITIONS:FIND-RESTART (NAME &OPTIONAL CONDITION)
  "Finds a restart with the given name."
  (DOLIST (RESTART (CONDITIONS:COMPUTE-RESTARTS CONDITION))
    (WHEN (AND (OR (EQ RESTART NAME) (EQ (CONDITIONS:RESTART-NAME RESTART) NAME))
	       (LET ((FN (RESTART-TEST-FUNCTION RESTART)))
		 (OR (NOT FN) (FUNCALL FN CONDITION))))
      (RETURN RESTART))))
  
(DEFUN CONDITIONS:INVOKE-RESTART (RESTART &REST VALUES)
  "Invokes the given restart."
  (APPLY #'INVOKE-RESTART-INTERNAL NIL NIL RESTART VALUES)) 

(DEFUN INVOKE-RESTART-INTERNAL (CONDITION MUST-TRANSFER RESTART &REST VALUES)
  (LET ((REAL-RESTART (OR (CONDITIONS:FIND-RESTART RESTART CONDITION)
			  (ERROR "Restart ~S is not active~@[ for condition ~S~]."
				 RESTART CONDITION))))
    (MULTIPLE-VALUE-PROG1 (APPLY (RESTART-FUNCTION REAL-RESTART) VALUES)
      (IF MUST-TRANSFER (CONDITIONS:ERROR "Restart ~S failed unexpectedly."
					  REAL-RESTART)))))

(DEFUN CONDITIONS:INVOKE-RESTART-INTERACTIVELY (RESTART)
  "Prompts for any relevant arguments, then invokes the given restart."
  (LET ((REAL-RESTART (OR (CONDITIONS:FIND-RESTART RESTART)
			  (ERROR "Restart ~S is not active." RESTART))))
    (APPLY (RESTART-FUNCTION REAL-RESTART)
	   (LET ((INTERACTIVE-FUNCTION
		   (RESTART-INTERACTIVE-FUNCTION REAL-RESTART)))
	     (IF INTERACTIVE-FUNCTION
		 (FUNCALL INTERACTIVE-FUNCTION)
		 '())))))


(EVAL-WHEN (EVAL COMPILE LOAD)
(DEFUN PARSE-KEYWORD-PAIRS (LIST KEYS)
  (DO ((L LIST (CDDR L))
       (K '() (LIST* (CADR L) (CAR L) K)))
      ((OR (NULL L) (NOT (CL:MEMBER (CAR L) KEYS)))
       (VALUES (NREVERSE K) L))))
)

(DEFMACRO WITH-KEYWORD-PAIRS ((NAMES EXPRESSION &OPTIONAL KEYWORDS-VAR) &BODY FORMS)
  (LET ((TEMP (CL:MEMBER '&REST NAMES)))
    (UNLESS (= (LENGTH TEMP) 2) (ERROR "&REST keyword is ~:[missing~;misplaced~]." TEMP))
    (LET ((KEY-VARS (CL:LDIFF NAMES TEMP))
	  (KEY-VAR (OR KEYWORDS-VAR (GENSYM)))
	  (REST-VAR (CADR TEMP)))
      (LET ((KEYWORDS (MAPCAR #'(LAMBDA (X) (INTERN (STRING X) (CL:FIND-PACKAGE "KEYWORD")))
			      KEY-VARS)))
	`(MULTIPLE-VALUE-BIND (,KEY-VAR ,REST-VAR)
	     (PARSE-KEYWORD-PAIRS ,EXPRESSION ',KEYWORDS)
	   (LET ,(MAPCAR #'(LAMBDA (VAR KEYWORD) `(,VAR (GETF ,KEY-VAR ,KEYWORD)))
			 KEY-VARS KEYWORDS)
	     ,@FORMS))))))

(DEFUN HANDLER-BIND-TRAMPOLINE (FUNCTION &REST TYPES-AND-HANDLERS)
  (CONDITION-BIND ((SYS:CONDITION #'(LAMBDA (CONDITION)
				      (DO ((L TYPES-AND-HANDLERS (CDDR L)))
					  ((NULL L))
					(WHEN (TYPEP CONDITION (CAR L))
					  (FUNCALL (CADR L) CONDITION))))))
    (FUNCALL FUNCTION)))

(DEFMACRO CONDITIONS:HANDLER-BIND (BINDINGS &BODY FORMS &ENVIRONMENT ENV)
  "Executes body in a context where given handler bindings are active."
  ;; Try to expand into a native CONDITION-BIND if at all possible.
  (IF (EVERY #'NATIVE-CONDITION-TYPE-FOR-HANDLER-TEST-P
	     (MAPCAR #'CAR BINDINGS))
      `(CONDITION-BIND ,(MAPCAR #'(LAMBDA (BINDING)
				    (LIST (NATIVE-CONDITION-TYPE-FOR-HANDLER-TEST
					    (CAR BINDING))
					  ;; Note that in ANSI CL, a condition handler
					  ;; must explicitly transfer control to handle
					  ;; the condition.  Returning *any* value means
					  ;; decline (like returning NIL in Zetalisp).
					  `#'(LAMBDA (.CONDITION.)
					       (FUNCALL ,(CADR BINDING) .CONDITION.)
					       NIL)))
				BINDINGS)
	 ,@FORMS)
      `(HANDLER-BIND-TRAMPOLINE #'(FUTURE-COMMON-LISP:LAMBDA ()
				    (DECLARE (SYS:DOWNWARD-FUNCTION))
				    ,@FORMS)
				,@(MAPCAN #'(LAMBDA (BINDING)
					      (LIST* `',(CAR BINDING)
						     (LET ((FN (CADR BINDING)))
						       ;; Force a SYS:DOWNWARD-FUNCTION
						       ;; declaration if this is an anonymous
						       ;; lambda expression.
						       (SETQ FN (MACROEXPAND FN ENV))
						       (IF (AND (NOT (ATOM FN))
								(EQ (CAR FN) 'FUNCTION)
								(NOT (ATOM (CADR FN)))
								(EQ (CAR (CADR FN)) 'LAMBDA))
							   `#'(LAMBDA ,(CADR (CADR FN))
								(DECLARE
								  (SYS:DOWNWARD-FUNCTION))
								,@(CDDR (CADR FN)))
							   FN))
						     NIL))
					  BINDINGS))))

(DEFMACRO CONDITIONS:HANDLER-CASE (FORM &REST CASES)
  "Executes form, passing control to a case clause if a matching condition occurs."
  (DECLARE (ZWEI:INDENTATION 1 1))
  ;; :NO-ERROR was added between Revision 15 and Revision 18 of the Condition System
  (LET ((NO-ERROR-CASE (ASSOC :NO-ERROR CASES)))
    (WHEN NO-ERROR-CASE
      (LET ((ERROR-RETURN (MAKE-SYMBOL "ERROR-RETURN"))
	    (NORMAL-RETURN (MAKE-SYMBOL "NORMAL-RETURN")))
	(RETURN-FROM CONDITIONS:HANDLER-CASE
	  `(BLOCK ,ERROR-RETURN
	     (MULTIPLE-VALUE-CALL #'(FUTURE-COMMON-LISP:LAMBDA ,@(CDR NO-ERROR-CASE))
				  (BLOCK ,NORMAL-RETURN
				    (RETURN-FROM ,ERROR-RETURN
				      (CONDITIONS:HANDLER-CASE
					  (RETURN-FROM ,NORMAL-RETURN ,FORM)
					,@(REMOVE NO-ERROR-CASE CASES))))))))))
  (LET ((TAG (GENSYM))
	(VAR (GENSYM))
	(ANNOTATED-CASES (MAPCAR #'(LAMBDA (CASE) (CONS (GENSYM) CASE))
				 CASES)))
    `(BLOCK ,TAG
       (LET ((,VAR NIL))
	 ,VAR ;ignorable
	 (TAGBODY
	   (CONDITIONS:HANDLER-BIND ,(MAPCAR #'(LAMBDA (ANNOTATED-CASE)
						      (LIST (CADR ANNOTATED-CASE)
							    `#'(FUTURE-COMMON-LISP:LAMBDA (TEMP)
								 (DECLARE
								   (:SYS:DOWNWARD-FUNCTION))
								 ,(IF (CADDR ANNOTATED-CASE)
								      `(SETQ ,VAR TEMP)
								      `TEMP	;ignored
								      )
								 (GO ,(CAR ANNOTATED-CASE)))))
					     ANNOTATED-CASES)
	     (RETURN-FROM ,TAG ,FORM))
	   ,@(MAPCAN #'(LAMBDA (ANNOTATED-CASE)
			 (LIST (CAR ANNOTATED-CASE)
			       (LET ((BODY (CDDDR ANNOTATED-CASE)))
				 `(RETURN-FROM ,TAG
				    ,(COND ((CADDR ANNOTATED-CASE)
					    `(LET ((,(CAADDR ANNOTATED-CASE)
						    ,VAR))
					       ,@BODY))
					   ((NOT (CDR BODY))
					    (CAR BODY))
					   (T
					    `(PROGN ,@BODY)))))))
		     ANNOTATED-CASES))))))



(DEFUN COMPATIBLE-RESTART-TRAMPOLINE (FUNCTION RESTART)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (EQ (CONDITIONS:RESTART-NAME RESTART) 'CONDITIONS:ABORT)
      (CATCH-ERROR-RESTART ((SYS:ABORT DBG:DEBUGGER-CONDITION) "~A" RESTART)
	(FUNCALL FUNCTION))
      (CATCH-ERROR-RESTART (DBG:DEBUGGER-CONDITION "~A" RESTART)
	(FUNCALL FUNCTION)))
  ;; Normally the function that is passed in here does a non-local transfer
  ;; of control and we never reach here.  We only reach here if the user
  ;; interactively selects this error restart. -kmp 7-Mar-90
  (CONDITIONS:INVOKE-RESTART-INTERACTIVELY RESTART))

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFVAR *RESTART-CASE-IMPLICIT-CONDITION-ASSOCIATORS*
	'((CONDITIONS:SIGNAL CONDITIONS:SIMPLE-CONDITION 1)
	  (SCL:SIGNAL 	     "There is no default."      1)
	  (CONDITIONS:ERROR  CONDITIONS:SIMPLE-ERROR     1)
	  (SCL:ERROR         CONDITIONS:SIMPLE-ERROR     1)
	  (CONDITIONS:CERROR CONDITIONS:SIMPLE-ERROR     2)
	  (SCL:CERROR	     CONDITIONS:SIMPLE-ERROR     2)
	  (CONDITIONS:WARN   CONDITIONS:SIMPLE-WARNING   1)
	  (SCL:WARN	     CONDITIONS:SIMPLE-WARNING	 1)))

(DEFUN PREPARE-SIGNAL-ARGUMENTS (VAR SIGNALLER-FORM)
  (DECLARE (VALUES MAKER-FORM NEW-SIGNALLER-FORM))
  (UNLESS (ATOM SIGNALLER-FORM)
    (LET ((ENTRY (ASSOC (CAR SIGNALLER-FORM) *RESTART-CASE-IMPLICIT-CONDITION-ASSOCIATORS*)))
      (WHEN ENTRY
	(LET* ((DEFAULT-CONDITION (CADR ENTRY))
	       (N (CADDR ENTRY))
	       (CONDITION-ARGUMENTS (NTHCDR N SIGNALLER-FORM)))
	  (VALUES `(COERCE-TO-CONDITION ,(CAR CONDITION-ARGUMENTS)
					(LIST ,@(CDR CONDITION-ARGUMENTS))
					',DEFAULT-CONDITION
					',(CAR SIGNALLER-FORM))
		  `(,@(ZL:FIRSTN N SIGNALLER-FORM) ,VAR)))))))
);NEHW-LAVE

(DEFMACRO CONDITIONS:RESTART-CASE (EXPRESSION &REST CLAUSES)
  "Executes form, passing control to a case clause if a matching restart is invoked."
  (DECLARE (ZWEI:INDENTATION 1 1))
  (LABELS ((TRANSFORM-KEYWORDS (&KEY REPORT INTERACTIVE TEST)
	     (LET ((RESULT '()))
	       (WHEN REPORT
		 (SETQ RESULT (LIST* (IF (STRINGP REPORT)
					 `#'(FUTURE-COMMON-LISP:LAMBDA (STREAM)
					      (DECLARE (SYS:DOWNWARD-FUNCTION))
					      (CL:WRITE-STRING ,REPORT STREAM))
					 `#',REPORT)
				     :REPORT-FUNCTION
				     RESULT)))
	       (WHEN INTERACTIVE
		 (SETQ RESULT (LIST* `#',INTERACTIVE
				     :INTERACTIVE-FUNCTION
				     RESULT)))
	       (WHEN TEST
		 (SETQ RESULT (LIST* `#',TEST
				     :TEST-FUNCTION
				     RESULT)))
	       (NREVERSE RESULT)))
	   (MAKE-COMPATIBLE-RESTART-CASE (BLOCK-TAG DATA EXP)
	     (LET ((CVAR (GENSYM)))
	       (MULTIPLE-VALUE-BIND (MAKER-FORM NEW-EXP)
		   (PREPARE-SIGNAL-ARGUMENTS CVAR EXP)
		 (WHEN MAKER-FORM
		   (SETQ EXP `(LET ((,CVAR ,MAKER-FORM))
				(FUTURE-COMMON-LISP:WITH-CONDITION-RESTARTS
				  ,CVAR (ZL:FIRSTN ,(LENGTH DATA) (CONDITIONS:COMPUTE-RESTARTS))
				  ,NEW-EXP))))))
	     (MAKE-COMPATIBLE-RESTART-CASE-1 BLOCK-TAG DATA EXP 0))
	   (MAKE-COMPATIBLE-RESTART-CASE-1 (BLOCK-TAG DATA EXPRESSION N)
	     (COND ((NULL DATA) EXPRESSION)
		   (T (MAKE-COMPATIBLE-RESTART-CASE-1
			BLOCK-TAG
			(CDR DATA)
			`(COMPATIBLE-RESTART-TRAMPOLINE
			   #'(FUTURE-COMMON-LISP:LAMBDA ()
			       (DECLARE (SYS:DOWNWARD-FUNCTION))
			       (RETURN-FROM ,BLOCK-TAG ,EXPRESSION))
			   (NTH ,N (CAR DBG:*RESTARTS*)))
			(+ N 1))))))
    (LET ((BLOCK-TAG (GENSYM))
	  (TEMP-VAR  (GENSYM))
	  (DATA
	    (MAPCAR #'(LAMBDA (CLAUSE)
			(WITH-KEYWORD-PAIRS ((REPORT INTERACTIVE TEST &REST FORMS)
					     (CDDR CLAUSE))
			  (LIST (CAR CLAUSE)			   ;Name=0
				(GENSYM)			   ;Tag=1
				(TRANSFORM-KEYWORDS :REPORT REPORT ;Keywords=2
						    :INTERACTIVE INTERACTIVE
						    :TEST TEST)
				(CADR CLAUSE)			   ;BVL=3
				FORMS)))			   ;Body=4
		    CLAUSES)))
      `(BLOCK ,BLOCK-TAG
	 (LET ((,TEMP-VAR NIL))
	   (TAGBODY
	     (CONDITIONS:RESTART-BIND
	       ,(MAPCAR #'(LAMBDA (DATUM)
			    (LET ((NAME (NTH 0 DATUM))
				  (TAG  (NTH 1 DATUM))
				  (KEYS (NTH 2 DATUM)))
			      `(,NAME #'(FUTURE-COMMON-LISP:LAMBDA (&REST TEMP)
					  (DECLARE (SYS:DOWNWARD-FUNCTION))
					  (SETQ ,TEMP-VAR TEMP)
					  (GO ,TAG))
				,@KEYS)))
			DATA)
	       (RETURN-FROM ,BLOCK-TAG
		 ,(MAKE-COMPATIBLE-RESTART-CASE BLOCK-TAG DATA EXPRESSION)))
	     ,@(MAPCAN #'(LAMBDA (DATUM)
			   (LET ((TAG  (NTH 1 DATUM))
				 (BVL  (NTH 3 DATUM))
				 (BODY (NTH 4 DATUM)))
			     (LIST TAG
				   `(RETURN-FROM ,BLOCK-TAG
				      (CL:APPLY #'(FUTURE-COMMON-LISP:LAMBDA ,BVL ,@BODY)
						  ,TEMP-VAR)))))
		       DATA)))))))

(DEFMACRO CONDITIONS:WITH-SIMPLE-RESTART ((RESTART-NAME FORMAT-STRING
							&REST FORMAT-ARGUMENTS)
					  &BODY FORMS)
  "Executes body, returning control if the indicated restart is invoked."
  (LET ((STREAM-VAR (FUTURE-COMMON-LISP:GENSYM "STREAM")))
    `(CONDITIONS:RESTART-CASE ,(IF (CDR FORMS) `(PROGN ,@FORMS) (CAR FORMS))
       (,RESTART-NAME ()
	  :REPORT (FUTURE-COMMON-LISP:LAMBDA (,STREAM-VAR)
		    (DECLARE (SYS:DOWNWARD-FUNCTION))
		    (FORMAT ,STREAM-VAR ,FORMAT-STRING ,@FORMAT-ARGUMENTS))
	(VALUES NIL T)))))



(DEFUN CONDITIONS:ABORT (&OPTIONAL CONDITION)
  "Invokes the ABORT restart (to abort program execution)."
  (INVOKE-RESTART-INTERNAL CONDITION T 'CONDITIONS:ABORT))

(DEFUN CONDITIONS:CONTINUE (&OPTIONAL CONDITION)
  "Invokes the CONTINUE restart (to continue CERROR)."
  (INVOKE-RESTART-INTERNAL CONDITION NIL 'CONDITIONS:CONTINUE))

(DEFUN CONDITIONS:MUFFLE-WARNING (&OPTIONAL CONDITION)
  "Invokes the MUFFLE-WARNING restart (to bypass WARN)."
  (INVOKE-RESTART-INTERNAL CONDITION NIL 'CONDITIONS:MUFFLE-WARNING))

(DEFUN CONDITIONS:STORE-VALUE (VALUE &OPTIONAL CONDITION)
  "Invokes the STORE-VALUE restart (to permanently store a value)."
  (INVOKE-RESTART-INTERNAL CONDITION NIL 'CONDITIONS:STORE-VALUE VALUE))

(DEFUN CONDITIONS:USE-VALUE   (VALUE &OPTIONAL CONDITION)
  "Invokes the USE-VALUE restart (to use a value once)."
  (INVOKE-RESTART-INTERNAL CONDITION NIL 'CONDITIONS:USE-VALUE VALUE))

(DEFSUBST NATIVE-CONDITION-TYPE-FOR-INSTANTIATION (NAME)
  ;; Cloe used to do something more complicated here.
  ;; For our purposes, it should suffice for this to be a no-op, but
  ;; I've retained this indirection for a while just to 
  NAME) ;For now.-kmp 12-Oct-89

(DEFUN CONDITIONS:MAKE-CONDITION (NAME &REST INIT-KEYWORDS)
  "Makes a condition of the indicated type."
  (APPLY #'MAKE-CONDITION (NATIVE-CONDITION-TYPE-FOR-INSTANTIATION NAME) INIT-KEYWORDS))

(DEFUN NATIVE-CONDITION-TYPE-FOR-HANDLER-TEST (CL-COMPATIBLE-TYPE)
  (LET ((EXPANDED-TYPE (NATIVE-CONDITION-TYPE-FOR-TEST CL-COMPATIBLE-TYPE)))
    (COND ((SYMBOLP EXPANDED-TYPE) (NCONS EXPANDED-TYPE))
	  ((EQ (CAR EXPANDED-TYPE) 'OR)
	   (MAPCAN #'NATIVE-CONDITION-TYPE-FOR-HANDLER-TEST (CDR EXPANDED-TYPE)))
	  (T (ERROR "Cannot handle this type: ~S" CL-COMPATIBLE-TYPE)))))

(DEFUN NATIVE-CONDITION-TYPE-FOR-HANDLER-TEST-P (X)
  (IF (ATOM X)
      (AND (SYMBOLP X) (SUBTYPEP X 'CONDITIONS:CONDITION))
      (AND (EQ (CAR X) 'OR) (EVERY #'NATIVE-CONDITION-TYPE-FOR-HANDLER-TEST-P (CDR X)))))

(DEFUN NATIVE-CONDITION-TYPE-FOR-TEST (CL-COMPATIBLE-TYPE)
  (LET ((EXPANDED-TYPE (CLI::TYPE-EXPAND CL-COMPATIBLE-TYPE)))
    (COND ((ATOM EXPANDED-TYPE) EXPANDED-TYPE)
	  (T
	   (CASE (CAR EXPANDED-TYPE)
	     ((INSTANCE) (CADR EXPANDED-TYPE))
	     ((OR AND NOT) `(,(CAR EXPANDED-TYPE)
			     ,@(MAPCAR #'NATIVE-CONDITION-TYPE-FOR-TEST (CDR EXPANDED-TYPE))))
	     (T EXPANDED-TYPE))))))



(DEFUN CONDITIONS:BREAK (&OPTIONAL (FORMAT-STRING "(BREAK) executed") &REST FORMAT-ARGUMENTS)
  "Prints a message and directly enters the debugger continuably. See CLtL, p432."
  (DECLARE (DBG:ERROR-REPORTER))
  (CHECK-TYPE FORMAT-STRING STRING "a format string")
  (DBG:ENTER-DEBUGGER
    (MAKE-CONDITION 'BREAK
		    :FORMAT-STRING FORMAT-STRING
		    :FORMAT-ARGS (COPY-LIST FORMAT-ARGUMENTS))
    NIL '(((#\RESUME) :EXIT-DEBUGGER "Return from BREAK"))
    T)
  NIL)

(DEFUN CONDITIONS:ERROR (DATUM &REST ARGUMENTS)
  "Signals an error, given format-string/args or error-type/initargs."
  (DECLARE (DBG:ERROR-REPORTER))
  (ERROR (COERCE-TO-CONDITION DATUM ARGUMENTS 'CONDITIONS:SIMPLE-ERROR
			      'CONDITIONS:ERROR)))

(DEFUN CONDITIONS:SIGNAL (CONDITION &REST ARGUMENTS)
  (LET ((CONDITION-OBJECT (COERCE-TO-CONDITION CONDITION ARGUMENTS
					       'CONDITIONS:SIMPLE-CONDITION
					       'CONDITIONS:SIGNAL)))
    ;; This default handler implements the fact that in the CL condition system,
    ;; (SIGNAL 'error-condition) does not enter the debugger if unhandled.
    ;; It just returns NIL.
    (CONDITION-BIND-DEFAULT ((SYS:CONDITION #'(LAMBDA (CONDITION)
						(WHEN (EQ CONDITION CONDITION-OBJECT)
						  (RETURN-FROM CONDITIONS:SIGNAL NIL)))))
      (SIGNAL CONDITION-OBJECT))))

(DEFUN COERCE-TO-CONDITION (DATUM ARGUMENTS DEFAULT-TYPE FUNCTION-NAME)
  (SETQ ARGUMENTS (COPY-LIST ARGUMENTS))
  (COND ((TYPEP DATUM 'CONDITIONS:CONDITION)
	 (IF ARGUMENTS
	     (CONDITIONS:CERROR "Ignore the additional arguments."
				'CONDITIONS:SIMPLE-TYPE-ERROR
				:DATUM ARGUMENTS
				:EXPECTED-TYPE 'NULL
				:FORMAT-CONTROL "You may not supply additional arguments ~
				     	        when giving ~S to ~S."
				:FORMAT-ARGUMENTS (LIST DATUM FUNCTION-NAME)))
	 DATUM)
        ((SYMBOLP DATUM)                  ;roughly, (SUBTYPEP DATUM 'CONDITION)
         (APPLY #'CONDITIONS:MAKE-CONDITION DATUM ARGUMENTS))
        ((STRINGP DATUM)
	 (CONDITIONS:MAKE-CONDITION DEFAULT-TYPE
				    :FORMAT-CONTROL DATUM
				    :FORMAT-ARGUMENTS ARGUMENTS))
        (T
         (CONDITIONS:ERROR 'CONDITIONS:SIMPLE-TYPE-ERROR
			   :DATUM DATUM
			   :EXPECTED-TYPE '(OR SYMBOL STRING)
			   :FORMAT-CONTROL "Bad argument to ~S: ~S"
			   :FORMAT-ARGUMENTS (LIST FUNCTION-NAME DATUM)))))

(DEFUN CONDITIONS:CERROR (CONTINUE-STRING DATUM &REST ARGUMENTS)
  "Signals a continuable error, given format-string/args or error-type/initargs."
  (DECLARE (DBG:ERROR-REPORTER))
  (LET ((CONDITION (COERCE-TO-CONDITION DATUM ARGUMENTS 'CONDITIONS:SIMPLE-ERROR
					'CONDITIONS:CERROR)))
    (CONDITIONS:WITH-SIMPLE-RESTART (CONDITIONS:CONTINUE "~A"
							 (APPLY #'FORMAT NIL CONTINUE-STRING
								ARGUMENTS))
      (CONDITIONS:ERROR CONDITION)))
  NIL)

(DEFUN CONDITIONS:WARN (DATUM &REST ARGUMENTS)
  "Types a warning, given format-string/args or error-type/initargs."
  (LET ((CONDITION
	  (COERCE-TO-CONDITION DATUM ARGUMENTS 'CONDITIONS:SIMPLE-WARNING 'CONDITIONS:WARN)))
    (CHECK-TYPE CONDITION CONDITIONS:WARNING "a warning condition")
    #||						;Removed by issue BREAK-ON-WARNINGS-OBSOLETE -kmp
    (WHEN *BREAK-ON-WARNINGS*
      (CONDITIONS:BREAK "Warn entered while *BREAK-ON-WARNINGS* was true.~%Data: ~S"
			CONDITION))
    ||#
    (LET ((SAVE-WARNING (OR COMPILER:DEFAULT-WARNING-FUNCTION
			    COMPILER:COMPILER-WARNINGS-CONTEXT
			    COMPILER:SUPPRESS-COMPILER-WARNINGS))
	  (HANDLED NIL))
      (CONDITIONS:RESTART-CASE (SIGNAL CONDITION)
	(CONDITIONS:MUFFLE-WARNING ()
	  :REPORT "Skip warning."
	  (SETQ HANDLED T)))
      (UNLESS HANDLED
	(COND (SAVE-WARNING
	       (IF (STRINGP DATUM)
		   (SETQ ARGUMENTS (SYS:COPY-IF-NECESSARY ARGUMENTS))
		   (SETQ DATUM "~A" ARGUMENTS (LIST CONDITION)))
	       (COMPILER:WARN-1 'COMPILER:FORMAT-COMPILER-WARNING
				:FORMAT-STRING DATUM
				:FORMAT-ARGS ARGUMENTS))
	      (T
	       (UNLESS COMPILER:SUPPRESS-COMPILER-WARNINGS
		 (FORMAT *ERROR-OUTPUT* "~&Warning: ~~A~~%" CONDITION)))))
      NIL)))



(DEFFLAVOR DUMMY-DEBUGGER-CONDITION (DESCRIPTION) (DBG:DEBUGGER-CONDITION)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (DBG:REPORT DUMMY-DEBUGGER-CONDITION) (STREAM)
  (FORMAT STREAM "~A" DESCRIPTION))

(DEFMETHOD (DBG:CONDITION-TYPE DUMMY-DEBUGGER-CONDITION) () "Debug")

(DEFUN CONDITIONS:INVOKE-DEBUGGER (CONDITION)
  (DECLARE (DBG:ERROR-REPORTER))
  (DBG:WITH-CONDITIONS-AND-RESTARTS (CONDITION DBG:*RESTARTS*)
    (DBG:ENTER-DEBUGGER (MAKE-CONDITION 'DUMMY-DEBUGGER-CONDITION :DESCRIPTION CONDITION))))



(DEFMACRO CONDITIONS:IGNORE-ERRORS (&REST FORMS)
  "Executes body returning its values, or just two values (NIL, true) if it errs."
  `(CONDITIONS:HANDLER-CASE (PROGN ,@FORMS)
     (CONDITIONS:ERROR (CONDITION) (VALUES NIL CONDITION))))

;; !!! Note: Now that CONDITIONS:DEFINE-CONDITION does not take a :REPORT option
;;           (this was changed from v18 by issue CLOS-CONDITIONS), it is critical
;;	     that we be able to support writing FUTURE-COMMON-LISP:PRINT-OBJECT
;;	     methods on type CONDITION (a flavor, not a class).  I think this
;;	     will be enabled by an upcoming patch by Moon.  If it's not, we need
;;	     to figure out how people are supposed to write report methods. -kmp 7-Mar-90

(DEFMACRO CONDITIONS:DEFINE-CONDITION (NAME PARENT-TYPES SLOTS &REST OPTIONS)
  (LET ((SLOT-NAMES-AND-INITIAL-VALUES NIL)
	(SLOT-READERS   '())
	(SLOT-INITTERS  '())
	(REPORT-METHOD  NIL)
	(DOCUMENTATION  NIL))
    (DOLIST (SLOT SLOTS)
      (MULTIPLE-VALUE-BIND (SLOT-NAME SLOT-OPTIONS)
	  (IF (CONSP SLOT)
	      (VALUES (CAR SLOT) (CDR SLOT))
	      (VALUES SLOT NIL))
	(LET ((SLOT-NAME-AND-INITIAL-VALUE NIL))
	  (DO ((L SLOT-OPTIONS (CDDR L)))
	      ((NULL L))
	    (LET ((OPTION-NAME  (CAR  L))
		  (OPTION-VALUE (CADR L)))
	      (CASE OPTION-NAME
		((:INITFORM) (SETQ SLOT-NAME-AND-INITIAL-VALUE (LIST SLOT-NAME OPTION-VALUE)))
		((:READER)   (PUSH (LIST OPTION-VALUE SLOT-NAME) SLOT-READERS))
		((:WRITER
		   :ACCESSOR) (ERROR "Condition slots are read-only.~% ~S" SLOT))
		((:INITARG)  (PUSH (LIST OPTION-VALUE SLOT-NAME) SLOT-INITTERS))
		((:TYPE :DOCUMENTATION) (IGNORE OPTION-VALUE))	;Might as well accept these.
		(OTHERWISE (ERROR "Slot option ~S is not supported." OPTION-NAME)))))
	  (PUSH (OR SLOT-NAME-AND-INITIAL-VALUE SLOT-NAME) SLOT-NAMES-AND-INITIAL-VALUES))))
    (SETQ SLOT-NAMES-AND-INITIAL-VALUES (NREVERSE SLOT-NAMES-AND-INITIAL-VALUES))
    (SETQ SLOT-READERS   (NREVERSE SLOT-READERS))
    (SETQ SLOT-INITTERS  (NREVERSE SLOT-INITTERS))
    (DOLIST (OPTION OPTIONS)
      (CHECK-TYPE OPTION CONS)
      (ECASE (FIRST OPTION)
	(:DOCUMENTATION
	  (SETF DOCUMENTATION (SECOND OPTION))
	  (CHECK-TYPE DOCUMENTATION STRING))
	(:REPORT
	  (SETF REPORT-METHOD 
		(LET ((REPORTER (SECOND OPTION)))
		  (TYPECASE REPORTER
		    (STRING
		      `(WRITE-STRING ,REPORTER STREAM))
		    (OTHERWISE
		      `(FUNCALL #',REPORTER SELF STREAM))))))))
    `(PROGN
       (DEFFLAVOR ,NAME ,SLOT-NAMES-AND-INITIAL-VALUES
		  ,(MAPCAR #'NATIVE-CONDITION-TYPE-FOR-INSTANTIATION
			   (OR PARENT-TYPES '(CONDITIONS:CONDITION)))
	 ,@(IF DOCUMENTATION  `((:DOCUMENTATION ,DOCUMENTATION)))
	 ,@(IF SLOT-READERS   `((:READABLE-INSTANCE-VARIABLES ,@SLOT-READERS)))
	 ,@(IF SLOT-INITTERS  `((:INITABLE-INSTANCE-VARIABLES ,@SLOT-INITTERS))))
       ,@(IF REPORT-METHOD `((DEFMETHOD (DBG:REPORT ,NAME) (STREAM)
			       ,REPORT-METHOD)))
       ',NAME)))



(DEFFLAVOR CASE-FAILURE (NAME POSSIBILITIES) (CONDITIONS:TYPE-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(DEFMETHOD (DBG:REPORT CASE-FAILURE) (STREAM)
  (FORMAT STREAM "~S fell through ~S expression.~%Wanted one of ~:S."
	  (CONDITIONS:TYPE-ERROR-DATUM SELF) NAME POSSIBILITIES))




(DEFMACRO CONDITIONS:ECASE (KEYFORM &REST CASES)
  (DECLARE (ZWEI:INDENTATION 1 1))
  (LET ((KEYS (ACCUMULATE-CASE-KEYS 'CONDITIONS:ECASE CASES NIL))
	(VAR (GENSYM)))
    `(LET ((,VAR ,KEYFORM))
       (CASE ,VAR
	 ,@CASES
	 (OTHERWISE
	   (ECASE-FAILURE ',KEYFORM ,VAR ',KEYS))))))

(DEFUN ECASE-FAILURE (FORM VALUE KEYS)
  (DECLARE (DBG:ERROR-REPORTER) (IGNORE FORM))
  (CONDITIONS:ERROR 'CASE-FAILURE
		    :NAME 'CONDITIONS:ECASE
		    :DATUM VALUE
		    :EXPECTED-TYPE `(MEMBER ,@KEYS)
		    :POSSIBILITIES KEYS))

(DEFMACRO CONDITIONS:CCASE (KEYPLACE &REST CASES)
  (DECLARE (ZWEI:INDENTATION 1 1))
  (LET ((KEYS (ACCUMULATE-CASE-KEYS 'CONDITIONS:CCASE CASES NIL))
	(TAG1 (GENSYM))
	(TAG2 (GENSYM)))
    `(BLOCK ,TAG1
       (TAGBODY ,TAG2
	 (RETURN-FROM ,TAG1
	   (CASE ,KEYPLACE
	     ,@CASES
	     (OTHERWISE
	       (SETF ,KEYPLACE (CCASE-FAILURE ',KEYPLACE ,KEYPLACE ',KEYS))
	       (GO ,TAG2))))))))

(DEFUN CCASE-FAILURE (KEYPLACE VALUE KEYS)
  (DECLARE (DBG:ERROR-REPORTER))
  (CONDITIONS:RESTART-CASE (CONDITIONS:ERROR 'CASE-FAILURE
					     :NAME 'CONDITIONS:CCASE
					     :DATUM VALUE
					     :EXPECTED-TYPE `(MEMBER ,@KEYS)
					     :POSSIBILITIES KEYS)
    (CONDITIONS:STORE-VALUE (VALUE)
	:REPORT (FUTURE-COMMON-LISP:LAMBDA (STREAM)
		  (DECLARE (SYS:DOWNWARD-FUNCTION))
		  (FORMAT STREAM "Supply a new value of ~S." KEYPLACE))
	:INTERACTIVE READ-EVALUATED-FORM
      VALUE)))

(DEFUN READ-EVALUATED-FORM (&OPTIONAL FORMAT-STRING &REST FORMAT-ARGUMENTS)
  (LIST (PROMPT-AND-READ :EVAL-FORM "Form to evaluate and use~@[ ~A~]:~%"
			 (WHEN FORMAT-STRING
			   (APPLY #'FORMAT NIL FORMAT-STRING FORMAT-ARGUMENTS)))))


(DEFMACRO CONDITIONS:ETYPECASE (KEYFORM &REST CASES)
  (DECLARE (ZWEI:INDENTATION 1 1))
  (LET ((TYPES (ACCUMULATE-CASE-KEYS 'CONDITIONS:ETYPECASE CASES T))
	(VAR (GENSYM)))
    `(LET ((,VAR ,KEYFORM))
       (TYPECASE ,VAR
	 ,@CASES
	 (OTHERWISE
	   (ETYPECASE-FAILURE ',KEYFORM ,VAR ',TYPES))))))

(DEFUN ETYPECASE-FAILURE (FORM VALUE TYPES)
  (DECLARE (DBG:ERROR-REPORTER) (IGNORE FORM))
  (CONDITIONS:ERROR 'CASE-FAILURE
		    :NAME 'CONDITIONS:ETYPECASE
		    :DATUM VALUE
		    :EXPECTED-TYPE `(OR ,@TYPES)
		    :POSSIBILITIES TYPES))

(DEFMACRO CONDITIONS:CTYPECASE (KEYPLACE &REST CASES)
  (DECLARE (ZWEI:INDENTATION 1 1))
  (LET ((TYPES (ACCUMULATE-CASE-KEYS 'CONDITIONS:CTYPECASE CASES T))
	(TAG1 (GENSYM))
	(TAG2 (GENSYM)))
    `(BLOCK ,TAG1
       (TAGBODY ,TAG2
	 (RETURN-FROM ,TAG1
	   (TYPECASE ,KEYPLACE
	     ,@CASES
	     (OTHERWISE
	       (SETF ,KEYPLACE (CTYPECASE-FAILURE ',KEYPLACE ,KEYPLACE ',TYPES))
	       (GO ,TAG2))))))))

(DEFUN CTYPECASE-FAILURE (KEYPLACE VALUE TYPES)
  (DECLARE (DBG:ERROR-REPORTER))
  ;; Note that this internal routine only returns when the STORE-VALUE restart
  ;; is invoked, and then returns the value (without storing it).  The caller
  ;; (the expansion of CTYPECASE) is expected to be ready to receive the value
  ;; and do the right thing with it.
  (CONDITIONS:RESTART-CASE (CONDITIONS:ERROR 'CASE-FAILURE
					     :NAME 'CONDITIONS:CTYPECASE
					     :DATUM VALUE
					     :EXPECTED-TYPE `(OR ,@TYPES)
					     :POSSIBILITIES TYPES)
    (STORE-VALUE (VALUE)
        :REPORT (FUTURE-COMMON-LISP:LAMBDA (STREAM)
		  (DECLARE (SYS:DOWNWARD-FUNCTION))
		  (FORMAT STREAM "Supply a new value of ~S." KEYPLACE))
        :INTERACTIVE READ-EVALUATED-FORM
      VALUE)))



(DEFMACRO CONDITIONS:CHECK-TYPE (PLACE TYPE &OPTIONAL TYPE-STRING)
  (LET ((TAG1 (GENSYM))
	(TAG2 (GENSYM)))
    `(BLOCK ,TAG1
       (TAGBODY ,TAG2
	 (FUTURE-COMMON-LISP:WHEN (TYPEP ,PLACE ',TYPE) (RETURN-FROM ,TAG1 NIL))
	 (SETF ,PLACE (CHECK-TYPE-FAILURE ',PLACE ,PLACE ',TYPE ',TYPE-STRING))
	 (GO ,TAG2)))))

(DEFUN CHECK-TYPE-FAILURE (PLACE VALUE TYPE TYPE-STRING)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF TYPE-STRING
      (CONDITIONS:RESTART-CASE (CONDITIONS:ERROR "The value of ~S is ~S, which is not ~A."
						 PLACE VALUE TYPE-STRING)
	(CONDITIONS:STORE-VALUE (VALUE)
	    :REPORT (FUTURE-COMMON-LISP:LAMBDA (STREAM)
		      (DECLARE (SYS:DOWNWARD-FUNCTION))
		      (FORMAT STREAM "Supply a new value of ~S." PLACE))
	    :INTERACTIVE READ-EVALUATED-FORM
	  VALUE))
      (CONDITIONS:RESTART-CASE (CONDITIONS:ERROR
				 "The value of ~S is ~S, which is not ~
				  ~:[of type ~S~;~\\A-OR-AN\\~]."
				 PLACE VALUE (SYMBOLP TYPE) TYPE)
	(CONDITIONS:STORE-VALUE (VALUE)
	    :REPORT (FUTURE-COMMON-LISP:LAMBDA (STREAM)
		      (DECLARE (SYS:DOWNWARD-FUNCTION))
		      (FORMAT STREAM "Supply a new value of ~S." PLACE))
	    :INTERACTIVE READ-EVALUATED-FORM
	  VALUE))))

(DEFMACRO CONDITIONS:ASSERT (TEST-FORM &OPTIONAL PLACES DATUM &REST ARGUMENTS)
  "Signals a continuable error if test-form yields NIL."
  (LET ((TAG (GENSYM)))
    `(TAGBODY ,TAG
       (FUTURE-COMMON-LISP:UNLESS ,TEST-FORM
	 (ASSERT-FAILURE ',TEST-FORM ',PLACES ,DATUM ,@ARGUMENTS)
	 (SETF (VALUES ,@PLACES) (ASSERT-GET-CORRECTED-VALUES ',PLACES ,@PLACES))
	 (GO ,TAG)))))

(DEFUN ASSERT-FAILURE (ASSERTION PLACES DATUM &REST ARGUMENTS)
  (DECLARE (DBG:ERROR-REPORTER))
  ;; This only returns if the CONDITIONS:CONTINUE restart is invoked.
  ;; The caller should be prepared to prompt for new values of the places,
  ;; since that's part of the contract of invoking CONDITIONS:CONTINUE.
  (CONDITIONS:RESTART-CASE (CONDITIONS:ERROR
			     (IF DATUM 
				 (COERCE-TO-CONDITION DATUM ARGUMENTS
						      'CONDITIONS:SIMPLE-ERROR
						      'CONDITIONS:ASSERT)
				 (CONDITIONS:MAKE-CONDITION
				   'CONDITIONS:SIMPLE-ERROR
				   :FORMAT-CONTROL "The assertion ~S failed."
				   :FORMAT-ARGUMENTS (LIST ASSERTION))))
    (CONDITIONS:CONTINUE ()
        :REPORT (FUTURE-COMMON-LISP:LAMBDA (STREAM)
		  (DECLARE (SYS:DOWNWARD-FUNCTION))
		  (ASSERT-REPORT PLACES STREAM))
      NIL)))

(DEFUN ASSERT-REPORT (NAMES STREAM)
  (FORMAT STREAM "Retry assertion~:[~2*~; with new value~P for ~{~S~^, ~}~]."
	  NAMES (LENGTH NAMES) NAMES))

(DEFUN ASSERT-GET-CORRECTED-VALUES (PLACES &REST VALUES)
  (VALUES-LIST (MAPCAR #'ASSERT-PROMPT PLACES VALUES)))

(DEFUN ASSERT-PROMPT (NAME VALUE)
  (COND ((Y-OR-N-P "The old value of ~S is ~S.~
		  ~%Do you want to supply a new value? "
		   NAME VALUE)
	 (FLET ((READ-IT () (CAR (READ-EVALUATED-FORM "for ~S" NAME))))
	   (IF (SYMBOLP NAME)			;Help user debug lexical variables
	       (PROGV (LIST NAME) (LIST VALUE) (READ-IT))
	       (READ-IT))))
	(T VALUE)))
