;;; -*- Mode: LISP; Package: Debugger; Base: 8; Lowercase: Yes -*-

;;; Debugger commands
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(cp:define-command (com-show-frame :command-table "Debugger")
    (&key (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
	  (clear-window 'scl:boolean
			:default nil
			:mentioned-default t
			:documentation "Clear the window first"))
  (let ((*printing-monitor-message* t))
    (if detailed
	(show-all t clear-window)
      (when clear-window
	(send-if-handles standard-output :clear-window))
      (print-error-message *error* nil t t)
      (si:print-any-binding-warnings nil)
      (show-function-and-args t)
      (show-proceed-options))))

(cp:define-command-accelerator show "Debugger" (#\c-L #\Refresh) () ()
  `(com-show-frame :detailed nil :clear-window t))
(cp:define-command-accelerator show-all "Debugger" (#\m-L) () ()
  `(com-show-frame :detailed t :clear-window t))

(cp:define-command (com-show-proceed-options :command-table "Debugger")
    ()
  (show-proceed-options))

;;; Movement commands

(defun show-frame-after-motion (how)
  (unless (eq *current-frame* *previous-current-frame*)
    (setq *previous-current-frame* *current-frame*)
    (redisplay-tick *backtrace-pane-tick*
		    *args-and-locals-pane-tick*
		    *source-code-pane-tick*)
    (when *inside-display-debugger*
      (setf (display-debugger-displayed-code-for-frame dw:*program*) nil))
    (flet ((prepare-panes ()
	     (when *inside-display-debugger*
	       (loop for pane-name in '(source-code args-and-locals)
		     as pane = (send dw:*program-frame* :get-pane pane-name)
		     do (send pane :clear-history)))))
      (cond ((or (eq how :quietly)
		 (eq how :silently))
	     (prepare-panes)
	     #+++ignore				;too verbose, so flush it
	     (when (eq how :quietly)		;louder than :silently
	       (let* ((frame *current-frame*)
		      (*printing-monitor-message* t)
		      (cl:*print-level* *function-prinlevel*)
		      (cl:*print-length* *function-prinlength*)
		      (function (frame-function frame)))
		 (print-carefully "function name"
		   (princ "The current frame is now ")
		   (when (closurep function)
		     (princ "a closure of "))
		   (with-character-style (*emphasis-character-style*)
		     (present (lframe-frame-function-name *current-language* frame)
			      (language-function-spec-type *current-language*)))))))
	    ((eq how :detailed)
	     (show-all))
	    (t
	     (show-function-and-args))))))

(cp:define-command (com-next-frame :command-table "Debugger"
				   :provide-output-destination-keyword nil)
    (&key (nframes 'cl:integer
		   :default 1
		   :documentation "Move this many frames")
	  (internal 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation #+3600 "Don't skip interpreter frames"
				   #+imach "Don't skip interpreter or open frames")
	  (invisible 'scl:boolean
		     :default (not *censor-invisible-frames*)
		     :mentioned-default t
		     :documentation "Don't skip invisible frames")
	  #+imach
	  (active-only 'scl:boolean
		       :default nil
		       :mentioned-default t
		       :documentation "Skip frames which are open but not active")
	  (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (labels ((move-frame (n)
	     (if internal
		 (frame-next-nth-open-frame *current-frame* n (not invisible))
	       (frame-next-nth-interesting-frame *current-frame* n
						 (not invisible) #+imach active-only)))
	   (up-stack ()
	     (let ((frame (move-frame (- nframes))))
	       (if (eq frame *current-frame*)
		   (format t "You are already at the bottom of the stack.~%")
		 (setq *current-frame* frame
		       *current-language* (find-language-for-frame *current-frame*))
		 (show-frame-after-motion
		   (if quietly :quietly (if detailed :detailed nil)))))))
    (up-stack)))

(cp:define-command-accelerator next-frame "Debugger" (#\c-N #\Line) () (arg-p arg)
  `(com-next-frame ,@(if arg-p `(:nframes ,arg))))
(cp:define-command-accelerator next-invisible "Debugger" (#\m-sh-N) () (arg-p arg)
  `(com-next-frame ,@(if arg-p `(:nframes ,arg)) :invisible t))
(cp:define-command-accelerator next-detailed "Debugger" (#\m-N) () (arg-p arg)
  `(com-next-frame ,@(if arg-p `(:nframes ,arg)) :detailed t))
(cp:define-command-accelerator next-noskip "Debugger" (#\c-m-N) () (arg-p arg)
  `(com-next-frame ,@(if arg-p `(:nframes ,arg)) :internal t :invisible t :detailed nil))

(cp:define-command (com-previous-frame :command-table "Debugger"
				       :provide-output-destination-keyword nil)
    (&key (nframes 'cl:integer
		   :default 1
		   :documentation "Move this many frames")
	  (to-interesting 'scl:boolean
			  :default nil
			  :mentioned-default t
			  :documentation "Move out to an interesting frame")
	  (internal 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation #+3600 "Don't skip interpreter frames"
				   #+imach "Don't skip interpreter or open frames")
	  (invisible 'scl:boolean
		     :default (not *censor-invisible-frames*)
		     :mentioned-default t
		     :documentation "Don't skip invisible frames")
	  #+imach
	  (active-only 'scl:boolean
		       :default nil
		       :mentioned-default t
		       :documentation "Skip frames which are open but not active")
	  (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (labels ((move-frame (n)
	     (if internal
		 (frame-next-nth-open-frame *current-frame* n (not invisible))
	       (frame-next-nth-interesting-frame *current-frame* n
						 (not invisible) #+imach active-only)))
	   (down-stack ()
	     (let ((frame (move-frame nframes)))
	       (if (eq frame *current-frame*)
		   (format t "You are already at the top of the stack.~%")
		 (setq *current-frame* frame
		       *current-language* (find-language-for-frame *current-frame*))))))
    (if (not to-interesting)
	(down-stack)
      (setq *current-frame* (or (frame-out-to-interesting-frame
				  (frame-previous-active-frame *current-frame*)
				  #+imach active-only)
				(frame-next-active-frame nil))
	    *current-language* (find-language-for-frame *current-frame*)))
    (show-frame-after-motion
      (if quietly :quietly (if detailed :detailed nil)))))

(cp:define-command-accelerator previous-frame "Debugger" (#\c-P #\Return) () (arg-p arg)
  `(com-previous-frame ,@(if arg-p `(:nframes ,arg))))
(cp:define-command-accelerator previous-invisible "Debugger" (#\m-sh-P) () (arg-p arg)
  `(com-previous-frame ,@(if arg-p `(:nframes ,arg)) :invisible t))
(cp:define-command-accelerator previous-detailed "Debugger" (#\m-P) () (arg-p arg)
  `(com-previous-frame ,@(if arg-p `(:nframes ,arg)) :detailed t))
(cp:define-command-accelerator previous-noskip "Debugger" (#\c-m-P) () (arg-p arg)
  `(com-previous-frame ,@(if arg-p `(:nframes ,arg)) :internal t :invisible t :detailed nil))
(cp:define-command-accelerator out-noskip "Debugger" (#\c-m-U) () (arg-p arg)
  `(com-previous-frame
     ,@(if arg-p `(:nframes ,arg)) :to-interesting t :internal t :detailed nil))

(cp:define-command (com-top-of-stack :command-table "Debugger"
				     :name "Top of Stack"
				     :provide-output-destination-keyword nil)
    (&key (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
   ;; Make sure the innermost frame is interesting to the language
   (push-stack-frame-pdl)
   (setq *current-frame* (if (or (eq (frame-function *innermost-interesting-frame*) #'si:*eval)
				 (frame-interesting-p *innermost-interesting-frame*))
			     *innermost-interesting-frame*
			   (frame-previous-interesting-frame
			     *innermost-interesting-frame* t #+IMach nil t))
	 *current-language* (find-language-for-frame *current-frame*))
  (show-frame-after-motion
    (if quietly :quietly (if detailed :detailed nil))))

(cp:define-command-accelerator top-of-stack "Debugger" (#\m-<) () ()
  `(com-top-of-stack))

(cp:define-command (com-bottom-of-stack :command-table "Debugger"
					:name "Bottom of Stack"
					:provide-output-destination-keyword nil)
    (&key (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (push-stack-frame-pdl)
  (setq *current-frame* (frame-next-active-frame nil)
	*current-language* (find-language-for-frame *current-frame*))
  (show-frame-after-motion
    (if quietly :quietly (if detailed :detailed nil))))

(cp:define-command-accelerator bottom-of-stack "Debugger" (#\m->) () ()
  `(com-bottom-of-stack))

(cp:define-command (com-find-frame :command-table "Debugger"
				   :provide-output-destination-keyword nil)
    ((frame 'string)
     &key (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
          (invisible 'scl:boolean
		     :default (not *censor-invisible-frames*)
		     :mentioned-default t
		     :documentation "Don't skip invisible frames")
	  (reverse 'scl:boolean
		   :default nil
		   :mentioned-default t
		   :documentation "Search backwards")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (push-stack-frame-pdl)
  (when (find-frame-internal frame nil reverse (not invisible))
    (show-frame-after-motion
      (if quietly :quietly (if detailed :detailed nil)))))

;;--- Because accelerators don't interact well with positional CP arguments
(cp:define-command (com-reverse-find-frame :command-table "Debugger"
					   :provide-output-destination-keyword nil)
    ((frame 'string)
     &key (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
          (invisible 'scl:boolean
		     :default (not *censor-invisible-frames*)
		     :mentioned-default t
		     :documentation "Don't skip invisible frames")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (push-stack-frame-pdl)
  (when (find-frame-internal frame nil t (not invisible))
    (show-frame-after-motion
      (if quietly :quietly (if detailed :detailed nil)))))

(cp:define-command-accelerator find-frame "Debugger" (#\c-S) (:activate nil) (ignore arg)
  (if (minusp arg)
      `(com-reverse-find-frame)			;--- s/b `(com-find-frame :reverse t)
    `(com-find-frame)))

(cp:define-command (com-set-current-frame :command-table "Debugger"
					  :provide-output-destination-keyword nil)
    ((frame 'stack-frame
	    :default (lframe-frame-function-name *current-language* *current-frame*))
     &key (detailed 'scl:boolean
		    :default nil
		    :mentioned-default t
		    :documentation "Show locals and disassembled code")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (push-stack-frame-pdl)
  (if (presentation-frame-p frame)
      (setq *current-frame* (car frame)
	    *current-language* (find-language-for-frame *current-frame*))
    (find-frame-internal frame t nil))
  (show-frame-after-motion
    (if quietly :quietly (if detailed :detailed nil))))

(defun stack-frame-not-stale (stack-frame-presentation)
  ;; Shouldn't need to check that STACK-FRAME-PRESENTATION is a cons, nor should
  ;; we need to check that ERROR is a condition object, since (1) that would mask
  ;; a bug in the Debugger, and (2) it can make this page hard, which can really
  ;; kill performance since this gets run so often
  (destructuring-bind (frame . error) stack-frame-presentation
    (and (locativep frame)
	 (not (or (%pointer-lessp frame %control-stack-low)
		  #+3600
		  (%pointer-lessp %control-stack-limit frame)
		  #+imach
		  (%pointer-lessp (%read-internal-register %register-control-stack-limit) frame)))
	 (variable-boundp *error*)
	 (eq error *error*)
	 (neq (condition-status error) :signalled))))

(define-presentation-to-command-translator set-frame
   (stack-frame
    :gesture :select
    :documentation "Set the current frame"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame))
    ;; Make this higher than any handlers on SYS:FUNCTION-SPEC
    :priority 0.5)
   (frame)
  `(com-set-current-frame ,frame))

(define-presentation-to-command-translator set-frame-detailed
   (stack-frame
    :gesture :alternate-select
    :documentation "Set the current frame (detailed)"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame))
    ;; Make this higher than any handlers on SYS:FUNCTION-SPEC
    :priority 0.5)
   (frame)
  `(com-set-current-frame ,frame :detailed t))

(defun find-frame-internal (string &optional exact reverse-p skip-invisible)
  (flet ((move-frame (frame)
	   (loop for f = (if reverse-p
			     (frame-next-open-frame frame)
			   (frame-previous-open-frame frame))
		       then (if reverse-p
				(frame-next-open-frame f)
			      (frame-previous-open-frame f))
		 until (or (not skip-invisible)
			   (not (frame-invisible-p f)))
		 finally (return f))))
    ;; STRING can really be a function or a function-spec, too
    (loop with function-to-search-for = (si:valid-function-definition string t)
	  for frame = (move-frame *current-frame*) then (move-frame frame)
	  until (null frame)
	  as frame-function = (frame-function frame)
	  when (or (and function-to-search-for
			(eq function-to-search-for frame-function))
		   (and (not exact)
			(let ((name (function-name frame-function)))
			  (string-search string (cond ((stringp name) name)
						      ((symbolp name) (string name))
						      (t (format nil "~S" name)))))))
	    do (setq *current-frame* frame
		     *current-language* (find-language-for-frame *current-frame*))
	       (return frame)
	  finally 
	    (format t "~&Search failed.~%")
	    (return nil))))

;;; Frame PDL commands

(cp:define-command (com-pop-frame-pdl :command-table "Debugger"
				      :name "Pop Frame PDL"
				      :provide-output-destination-keyword nil)
    (&key (discard 'scl:boolean
		   :default nil
		   :mentioned-default t
		   :documentation "Discard the top item on the frame PDL")
	  (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (let ((popped-frame (pop-stack-frame-pdl)))
    (when (and popped-frame (not discard))
      (setq *current-frame* popped-frame
	    *current-language* (find-language-for-frame *current-frame*))
      (show-frame-after-motion (if quietly :quietly nil)))))

(cp:define-command (com-push-frame-pdl :command-table "Debugger"
				       :name "Push Frame PDL"
				       :provide-output-destination-keyword nil)
    ()
  (push-stack-frame-pdl))

(cp:define-command (com-exchange-frame-pdl :command-table "Debugger"
					   :name "Exchange Frame PDL"
					   :provide-output-destination-keyword nil)
    (&key (quietly 'scl:boolean
		   :default *inside-display-debugger*
		   :mentioned-default t))
  (let ((index (fill-pointer *stack-frame-pdl*)))
    (if (minusp index)
	(format t "~&The stack-frame PDL is empty.")
      (swapf *current-frame* (aref *stack-frame-pdl* index))
      (setq *current-language* (find-language-for-frame *current-frame*))
      (show-frame-after-motion (if quietly :quietly nil)))))

(cp:define-command (com-show-frame-pdl :command-table "Debugger"
				       :name "Show Frame PDL"
				       :provide-output-destination-keyword nil)
    ()
  (if (minusp (fill-pointer *stack-frame-pdl*))
      (format t "~&The stack-frame PDL is empty.")
    (loop for i below (1+ (fill-pointer *stack-frame-pdl*))
	  do (cl:fresh-line)
	     (present-stack-frame (aref *stack-frame-pdl* i)))))

(defun push-stack-frame-pdl ()
  (let ((index (fill-pointer *stack-frame-pdl*))
	(highest-index (1- (array-length *stack-frame-pdl*))))
    (when ( index highest-index)
      ;; We've used up the PDL, push the whole thing back
      (let ((pdl *stack-frame-pdl*))
	(declare (sys:array-register pdl))
	(loop for i below (1- index)
	      doing (setf (aref pdl i) (aref pdl (1+ i)))))
      (setq index (1- highest-index)))
    (incf index)
    (setf (aref *stack-frame-pdl* index) *current-frame*)
    (setf (fill-pointer *stack-frame-pdl*) index)))

(defun pop-stack-frame-pdl ()
  (let ((index (fill-pointer *stack-frame-pdl*)))
    (if (minusp index)
	;; FORMAT returns NIL, which is the flag used to indicate an error
	(format t "~&The stack-frame PDL is empty.")
      (prog1 (aref *stack-frame-pdl* index)
	     (setf (fill-pointer *stack-frame-pdl*) (1- index))))))

(cp:define-command-accelerator push-or-pop-frame-pdl "Debugger" (#\c-Space) () (arg-p arg)
  (cond ((not arg-p)
	 `(com-push-frame-pdl))
	((= arg 0)
	 `(com-show-frame-pdl))
	((and (eq arg-p :control-u) (= arg 4.))
	 `(com-pop-frame-pdl))
	((and (eq arg-p :control-u) (= arg 16.))
	 `(com-pop-frame-pdl :discard t))
	(t (beep))))

(cp:define-command-accelerator exchange-frame-pdl "Debugger" (#\c-m-Space) () ()
  `(com-exchange-frame-pdl))

;;; Rest of backtrace commands.

(cp:define-command-accelerator brief-backtrace "Debugger" (#\c-sh-B) () (arg-p arg)
  `(com-show-backtrace ,@(if arg-p `(:nframes ,arg)) :continuations nil))
(cp:define-command-accelerator detailed-backtrace "Debugger" (#\m-B) () (arg-p arg)
  `(com-show-backtrace ,@(if arg-p `(:nframes ,arg)) :detailed t))
(cp:define-command-accelerator invisible-backtrace "Debugger" (#\m-sh-B) () (arg-p arg)
  `(com-show-backtrace ,@(if arg-p `(:nframes ,arg)) :invisible t))
(cp:define-command-accelerator full-backtrace "Debugger" (#\c-m-B) () (arg-p arg)
  `(com-show-backtrace ,@(if arg-p `(:nframes ,arg)) :internal t :detailed t))

;; Show the passed arguments to a frame which we are not yet in
(cp:define-command (com-show-frame-arguments :command-table "Debugger")
    ((frame 'stack-frame
	    :default *current-frame*))
  (let* ((*current-frame* (if (presentation-frame-p frame)
			      (car frame)
			    frame))
	 (*current-language* (find-language-for-frame *current-frame*)))
    (if (zerop (frame-number-of-args *current-frame*))
	(format t "~S was not called with any arguments"
	  (lframe-frame-function-name *current-language* *current-frame*))
      (format t "~S was called with the following arguments:~%"
	(lframe-frame-function-name *current-language* *current-frame*))
      (lframe-print-arguments *current-language* *current-frame* 2 nil))))

(define-presentation-to-command-translator show-frame-arguments
   (stack-frame
    :gesture :describe
    :documentation "Show arguments with which frame was called"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-show-frame-arguments ,(car frame)))

;;; Control commands

(cp:define-command (com-enable-aborts :command-table "Debugger"
				      :provide-output-destination-keyword nil)
    ()
  (setq *aborting-disabled* nil)
  (format t "~&The ABORT command is now enabled"))

(cp:define-command (com-disable-aborts :command-table "Debugger"
				       :provide-output-destination-keyword nil)
    ()
  (setq *aborting-disabled* t)
  (format t "~&The ABORT command is now disabled"))

(cp:define-command (com-enable-condition-tracing :command-table "Tracing"
						 :provide-output-destination-keyword nil)
    ((conditions 'enable-condition-list
		 :default '(t))
     &key
     (conditional 'break-condition
		  :default #'true
		  :mentioned-default 'always
		  :documentation "When to break"))
  (cond ((or (null conditions) (memq 't conditions))
	 (setq conditions t))
	((memq 'nil conditions)
	 (setq conditions nil)))
  (setq trace-conditions conditions)
  (setq-globally trace-conditions conditions)
  (setq-globally trace-conditions-conditional conditional))

(cp:define-command (com-disable-condition-tracing :command-table "Tracing"
						  :provide-output-destination-keyword nil)
    ()
  (setq trace-conditions nil)
  (setq-globally trace-conditions nil)
  (setq-globally trace-conditions-conditional nil))

(cp:define-command-accelerator trace-cond "Debugger" ((#\c-X #\T)) () (arg-p arg)
  (if arg-p
      (if (zerop arg)
	  `(com-disable-condition-tracing)
	`(com-enable-condition-tracing))
    (if (null trace-conditions)
	`(com-enable-condition-tracing)
      `(com-disable-condition-tracing))))

(cp:define-command (com-return :command-table "Debugger"
			       :provide-output-destination-keyword nil)
    ()
  (com-return-from-frame-internal *current-frame*))

(cp:define-command-accelerator return "Debugger" (#\c-R) () ()
  `(com-return))

(defun com-return-from-frame-internal (frame)
  (let ((*current-frame* frame)
	(*current-language* (find-language-for-frame frame)))
    (cond ((not (frame-active-p *current-frame*))
	   (princ "This frame has not yet been activated; you cannot return from it"))
	  ((null (frame-previous-active-frame *current-frame*))
	   (princ "This is the bottom frame; you cannot return from it"))
	  (t
	   (let* ((name (function-name (frame-function *current-frame*)))
		  (values (multiple-value-bind (type maxvals)
			      (frame-real-value-disposition *current-frame*)
			    (selectq type
			      (:ignore
			       (format t "~&The caller is not interested in any values")
			       (or (fquery nil "Return from ~S? " name)
				   (throw 'quit t))
			       nil)
			      (:single
			       (format t "~&Return a value from the function ~S.~%" name)
			       (list (read-and-verify-expression t nil nil
								 "New value to return")))
			      (:multiple
			       ;; If multiple-value-list, allow specification of as many as
			       ;; wanted.
			       (format t (if maxvals
					     "~&The caller expects ~R values"
					   "~&The caller expects any number of values")
				 maxvals)
			       (if (eql maxvals 0)
				   (fquery nil "Return from ~S? " name)
				 (multiple-value-bind (nil values-names)
				     (let ((function (frame-function *current-frame*)))
				       (and (legitimate-function-p function)
					    (arglist function)))
				   (accumulate-multiple-return-values
				     "~&Enter values, ending with ”"
				     "Value #~S~@[ (~A)~]" maxvals values-names))))))))
	     (return-from-frame *current-frame* values))))))

;; Return VALUES from FRAME.
(defun return-from-frame (frame values)
  (setf (debugger-trace-flag frame) nil)
  (%return-from-frame frame values))

;;--- Other multi-language issues?  Also, EVALUATED-EXPRESSION p-t is completely bogus
(defun read-and-verify-expression (verify-p p-t-args default prompt &rest prompt-args)
  (declare (values form flag))
    (loop named read-thing
	  doing
      (destructuring-bind (thing)
	  (funcall #'funcall-in-error-environment t t
		   #'accept `((evaluated-expression) ,@p-t-args)
			    :prompt (lexpr-funcall #'format nil prompt prompt-args)
			    :default default)
	(cond ((or (eq thing :return)
		   (eq thing :end))
	       (return-from read-thing (values nil thing)))
	      ((not (listp thing))
	       (return-from read-thing (values thing :value)))
	      ((= (length thing) 1)
	       (return-from read-thing (values nil (car thing))))
	      (t
	       (destructuring-bind (form value) thing
		 (if (or (null verify-p)
			 (cl:constantp form)
			 (let ((query-io query-io)
			       (cl:*print-level* *error-message-prinlevel*)
			       (cl:*print-length* *error-message-prinlength*)
			       (scl:*print-string-length* *error-message-string-length*))
			   (fquery () "Value is ~S, OK? " value)))
		     (return-from read-thing (values value :value)))))))))

(defun accumulate-multiple-return-values
       (initial-prompt intermediate-prompt &optional max names)
  (format query-io initial-prompt)
  ;;--- I would use (with-stack-array (vector 100. :fill-pointer 0) ...), except
  ;;--- that there is a terrible interaction with PROMPT-AND-ACCEPT-IN-ERROR-ENVIRONMENT
  ;;--- which causes stuff on the data stack to get trashed.  Just try c-R'ing from
  ;;--- a frame and typing ” immediately after a value, then it explodes.
  (let ((vector (make-array 10 :fill-pointer 0)))
    (loop with values = nil
	  with nvalues = 0
	  as name = (nth nvalues names)
	  until (and max ( nvalues max))
	  with (form flag)
	  do (multiple-value (form flag)
	       ;; Let a higher level take care of defaulting
	       (read-and-verify-expression nil '(:or-end t :evaluate nil) nil
					   intermediate-prompt nvalues name))
	  until (neq flag :value)
	  as n = (multiple-value-vector (vector)
		   (values-list (eval-in-error-environment t t form)))
	  do (when ( n 1) (format t "~&That form returned ~D values" n))
	     (loop repeat n
		   for i upfrom 0
		   do (when (or (cl:constantp form)
				(let ((query-io query-io)
				      (cl:*print-level* *error-message-prinlevel*)
				      (cl:*print-length* *error-message-prinlength*)
				      (scl:*print-string-length* *error-message-string-length*))
				  (fquery () "The ~:R value~@[ (~A)~] is ~S, OK? "
				    (1+ nvalues) (nth nvalues names) (aref vector i))))
			(push (aref vector i) values)
			(incf nvalues)))
	  finally (return (nreverse values)))))

;;--- Multi-language issues?
(cp:define-command (com-reinvoke :command-table "Debugger"
				 :provide-output-destination-keyword nil)
    (&key
      (new-args 'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "Supply new arguments"))
  (if new-args
      (let* ((form (get-frame-function-and-args *current-frame*))
	     (function (real-function-definition (first form)))
	     (arguments (read-new-arguments-for-frame *current-frame* function (cdr form)))
	     (cl:*print-level* *error-message-prinlevel*)
	     (cl:*print-length* *error-message-prinlength*)
	     (scl:*print-string-length* *error-message-string-length*))
	(when (fquery () "Restart call to ~S~@[ on arguments ~S~]? "
		(function-name function) arguments)
	  #---ignore				;kludge implementation
	  (loop with *frame* = *current-frame*
		for i upfrom 0
		for arg in arguments
		do (setf (dbg:arg i) arg)
		finally (%restart-frame *current-frame* (real-function-definition function)))
	  #+++ignore	;correct (but buggy) implementation
	  ;;--- This leaves a bad arg to %jump on the stack!  How come?
	  ;;--- (In Zmacs, try m-Suspend, c-U c-m-R, Resume)
	  (lexpr-funcall #'si:%unwind-to-frame-and-funcall
			 (frame-previous-frame *current-frame*) function arguments)))
      (query-and-restart-frame *current-frame*)))

(defun query-and-restart-frame (frame &optional additional-query set-trap-on-call)
  (let* ((function-and-args (get-frame-function-and-args frame))
	 (function (real-function-definition (car function-and-args)))
	 (arguments (cdr function-and-args))
	 (cl:*print-level* *error-message-prinlevel*)
	 (cl:*print-length* *error-message-prinlength*)
	 (scl:*print-string-length* *error-message-string-length*))
    (when (fquery () "Restart call to ~S~@[ on arguments ~S~]~@[~A~]? "
		  function arguments additional-query)
      (restore-implied-arguments frame)
      (when set-trap-on-call
	(set-trap-on-call frame t))
      (%restart-frame frame function))))

(cp:define-command-accelerator reinvoke "Debugger" (#\c-m-R) () (arg-p ignore)
  `(com-reinvoke ,@(if arg-p '(:new-args t))))

(defun real-function-definition (function)
  (when (instancep function)
    (setq function
	  (clos-internals::function-name-current-definition function)))
  (let ((real-function (si:valid-function-definition function)))
    (when real-function
      ;; If recalling a special form, probably really retrying interpreting it.
      ;; If recalling a macro, probably really retrying the macro expansion.
      (if (listp real-function)
	  (setq function (or (special-form-p real-function)
			     (macro-function real-function)
			     real-function))
	  (setq function real-function))))
  function)

;;--- Multi-language issues?
(defun read-new-arguments-for-frame (frame function old-arguments)
  #+3600 (ignore frame)
  (let* ((args-info (args-info function))
	 (min-args (ldb %%arg-desc-min-args args-info))
	 (max-args (ldb %%arg-desc-max-args args-info))
	 (rest-p (ldb-test %%arg-desc-rest-arg args-info))
	 (rest-name (and rest-p (rest-arg-name #+3600 function #+imach frame))))
    (loop for arg-no below (if rest-p 10000. max-args)
	  for old-args first old-arguments then (cdr old-args)
	  when (and rest-p (= arg-no max-args) old-args
		    (fquery () "Use old arguments ~S for rest arg~@[ ~A~]? "
			    old-args rest-name))
	    append old-args
	    and do (incf arg-no (length old-args))
		   (setq old-args nil)
	  with (form flag)
	  do (multiple-value (form flag)
	       (read-and-verify-expression t `(:or-end ,( arg-no min-args)
					       :or-return ,(not (null old-args)))
					   (first old-args)
		  "Value for arg #~D~:[~@[ (~A)~]~; (in rest arg~@[ ~A~])~]~
		   ~:[~; (Or ” to end arguments)~]"
		 arg-no ( arg-no max-args)
		 (if ( arg-no max-args) rest-name
		     (arg-name #+3600 function #+imach frame arg-no))
		 ( arg-no min-args)))
	  collect (cond ((eq flag :end)
			 (when old-args
			   (princ "[End]"))
			 (loop-finish))
			((eq flag :return)
			 (let ((value (first old-args)))
			   (prin1 value)))
			(t form)))))

(cp:define-command (com-throw :command-table "Debugger"
			      :provide-output-destination-keyword nil)
    ((symbol 'symbol)
     (value 'form-or-code-fragment
	    :prompt "a form or code fragment"
	    :default nil))
  (let ((tag symbol)
	(vals (eval-in-error-environment t t value)))
    (setf (debugger-trace-flag *innermost-interesting-frame*) nil)
    (throw-from-error-environment tag vals)
    nil))

(cp:define-command-accelerator throw "Debugger" (#\c-T) (:activate nil) ()
  `(com-throw))

(cp:define-command (com-arbitrary-frame-return :command-table "Debugger"
					       :provide-output-destination-keyword nil)
    ((frame 'stack-frame :default nil))
  (if (presentation-frame-p frame)
      (com-return-from-frame-internal (car frame))
    (format t "~&~S is not a stack-frame" frame)))

(define-presentation-to-command-translator return-from-arbitrary-frame
   (stack-frame
    :gesture nil
    :documentation "Return from this frame"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-arbitrary-frame-return ,frame))

(cp:define-command (com-arbitrary-frame-reinvoke :command-table "Debugger"
						 :provide-output-destination-keyword nil)
    ((frame 'stack-frame :default nil))
  (if (not (presentation-frame-p frame))
      (format t "~&~S is not a stack-frame" frame)
      (query-and-restart-frame (car frame))))

(define-presentation-to-command-translator reinvoke-arbitrary-frame
   (stack-frame
    :gesture nil
    :documentation "Reinvoke this frame"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-arbitrary-frame-reinvoke ,frame))

;;; Trap on frame exit and call

(cp:define-command (com-set-trap-on-exit :command-table "Debugger"
					 :name "Set Trap on Exit"
					 :provide-output-destination-keyword nil)
    ((frame 'stack-frame :default *current-frame*)
     &key (all 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :documentation "Set trap-on-exit for entire stack"))
  (if all
      (loop for frame = frame then (frame-previous-active-frame frame)
	    until (null frame)
	    do (setf (debugger-trace-flag frame) t))
    (let ((frame (if (presentation-frame-p frame) (car frame) frame)))
      (setf (debugger-trace-flag frame) t)))
  (redisplay-tick *backtrace-pane-tick*))

(cp:define-command-accelerator set-trap-exit "Debugger" ((#\c-X #\E)) () (arg-p ignore)
  `(com-set-trap-on-exit ,*current-frame* ,@(if arg-p '(:all t))))

(define-presentation-to-command-translator set-trap-exit
   (stack-frame
    :gesture nil
    :documentation "Set trap-on-exit for this frame"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-set-trap-on-exit ,frame :all nil))

(cp:define-command (com-clear-trap-on-exit :command-table "Debugger"
					   :name "Clear Trap on Exit"
					   :provide-output-destination-keyword nil)
    ((frame 'stack-frame :default *current-frame*)
     &key (all 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :documentation "Clear trap-on-exit for entire stack"))
   (if all
       (loop for frame = frame then (frame-previous-active-frame frame)
	     until (null frame)
	     do (setf (debugger-trace-flag frame) nil))
     (let ((frame (if (presentation-frame-p frame) (car frame) frame)))
       (setf (debugger-trace-flag frame) nil)))
  (redisplay-tick *backtrace-pane-tick*))

(cp:define-command-accelerator clear-trap-exit "Debugger" ((#\c-X #\c-E)) () (arg-p ignore)
  `(com-clear-trap-on-exit ,*current-frame* ,@(if arg-p '(:all t))))

(define-presentation-to-command-translator clear-trap-exit
   (stack-frame
    :gesture nil
    :documentation "Clear trap-on-exit for this frame"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-clear-trap-on-exit ,frame :all nil))

(cp:define-command (com-set-trap-on-call :command-table "Debugger"
					 :name "Set Trap on Call"
					 :provide-output-destination-keyword nil)
    ()
  (set-trap-on-call *current-frame* t))

(cp:define-command-accelerator set-trap-call "Debugger" ((#\c-X #\C)) () ()
  `(com-set-trap-on-call))

(cp:define-command (com-clear-trap-on-call :command-table "Debugger"
					   :name "Clear Trap on Call"
					   :provide-output-destination-keyword nil)
    ()
  (set-trap-on-call *current-frame* nil))

(cp:define-command-accelerator clear-trap-call "Debugger" ((#\c-X #\c-C)) () ()
  `(com-clear-trap-on-call))

(cp:define-command (com-proceed-trap-on-call :command-table "Debugger"
					     :name "Proceed Trap on Call"
					     :provide-output-destination-keyword nil)
    ()
  (format t "~&Proceeding, will trap on next function call.~%")
  (com-proceed :trap-on-call t))

(cp:define-command-accelerator proceed-trap-call "Debugger" ((#\c-X #\m-C)) () ()
  `(com-proceed-trap-on-call))

(cp:define-command (com-restart-trap-on-call :command-table "Debugger"
					     :name "Restart Trap on Call"
					     :provide-output-destination-keyword nil)
    ()
   (query-and-restart-frame *current-frame* ", and trap on first call" t))

(cp:define-command-accelerator restart-trap-call "Debugger" ((#\c-X #\c-m-C)) () ()
  `(com-restart-trap-on-call))

;;; Commands for looking at special bindings.
 
(cp:define-command (com-show-bindings :command-table "Lisp-Debugger")
    (&key (all 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :documentation "Show bindings for entire stack")
	  (invisible 'scl:boolean
		     :default t
		     :documentation "Don't skip invisible frames")
	  (matching 'string
		    :documentation "Show only specials matching string"))
  (show-frame-bindings (not all) matching (not invisible)))

(cp:define-command-accelerator bindings "Lisp-Debugger" ((#\c-X #\B)) () (arg-p ignore)
  `(com-show-bindings ,@(if arg-p '(:all t))))

(defun show-frame-bindings (&optional just-current matching skip-invisible)
  (let ((*printing-monitor-message* t))
    ;; Find range of special pdl for this frame together with
    ;; all uninteresting frames called by it.
    (flet ((move-frame (frame)
	     (loop for f = (frame-previous-frame frame)
			 then (frame-previous-frame f)
		   until (or (not skip-invisible)
			     (not (frame-invisible-p f)))
		   finally (return f))))
      (loop with printed-one = nil
	    with cl:*print-level* = *error-message-prinlevel*
	    with cl:*print-length* = *error-message-prinlength*
	    with scl:*print-string-length* = *error-message-string-length*
	    for frame = *current-frame* then (move-frame frame)
	    until (null frame)
	    as print-heading = t
	    do ;--- Code changed to get around stupid compiler bug
	       ;(multiple-value-bind (start end n-subframes)
	       (let (start end n-subframes)
		 (cl:multiple-value-setq (start end n-subframes)
		   (frame-and-subframes-special-pdl-range frame))
		 (when start
		   (with-language-for-frame (frame)
		     (map-over-bindings
		       (lambda (loc val unbound-p ignore ignore)
			 (let ((sym (symbol-from-value-cell-location loc)))
			   (when (or (null matching)
				     ;; In case of random locatives on the binding stack
				     (and (not (locativep sym))
					  (string-search matching sym)))
			     (when print-heading
			       (setq print-heading nil)
			       (unless just-current
				 (format t "~&For frame ")
				 (with-character-style (*emphasis-character-style*)
				   (present-stack-frame frame))
				 (princ ":"))
			       (format t "~&~V~:[  ~]Names and values of specials bound ~
					in this frame~:[ and its subframes~]:~~%"
				 *deemphasis-character-style*
				 just-current (= n-subframes 1)))
			     (print-carefully "special variable binding"
			       (format t "~&~:[  ~]~S: " just-current sym)
			       (if unbound-p
				   (princ "unbound")
				 (present val (language-expression-type *current-language*)
					  :location loc)))
			     (setq printed-one t))))
		       start end))))
	    until just-current
	    finally (unless printed-one
		      (format t "~&No ~:[such ~]specials bound in ~:[the stack~;this frame~]"
			(null matching) just-current))))))

(cp:define-command (com-use-lisp-mode :command-table "Debugger"
				      :provide-output-destination-keyword nil)
    ((lisp-mode 'scl:boolean
		:default t
		:documentation "Always use Lisp as the debugging langugage"))
  (setq *always-use-lisp-debugger* lisp-mode)
  (setq *current-language*
	(if *always-use-lisp-debugger*
	    *lisp-language-debugging-instance*
	  (find-language-for-frame *current-frame*))))

(cp:define-command (com-use-lexical-environment :command-table "Lisp-Debugger"
						:provide-output-destination-keyword nil)
    ()
  (setq *inherit-lexical-environment* t)
  (format t "~&Now inheriting frame's lexical environment"))

(cp:define-command (com-use-dynamic-environment :command-table "Lisp-Debugger"
						:provide-output-destination-keyword nil)
    ()
  (setq *inherit-lexical-environment* nil)
  (format t "~&No longer inheriting frame's lexical environment"))

(cp:define-command-accelerator toggle-inheriting "Lisp-Debugger" ((#\c-X #\I)) () (arg-p arg)
  (when (null arg-p) (setq arg (if *inherit-lexical-environment* 0 1)))
  (if (zerop arg)
      `(com-use-dynamic-environment)
    `(com-use-lexical-environment)))

(cp:define-command (com-show-special :command-table "Lisp-Debugger"
				     :provide-output-destination-keyword nil)
    ((symbol 'symbol)
     &key
     (environment 'environment-type
		  :default :program
		  :documentation "environment in which to evaluate"))
  (let ((*printing-monitor-message* t)
	val loc)
    (selectq environment
      (:program
       (multiple-value (val loc)
	 (symeval-in-error-environment
	   symbol (frame-innermost-subframe *current-frame*))))
      (:debugger
       (setq val (car (eval-in-error-environment nil t symbol))))
      (:streams
       (let ((*inherit-lexical-environment* nil))
	 (setq val (car (eval-in-error-environment t t symbol))))))
    (si:set-value-for-* val)
    (cl:shiftf +++ ++ + (or loc symbol))
    (format t "~&")
    (if (or (null loc) (location-boundp loc))
	(present val (language-expression-type *current-language*)
		 :location loc)
      (format t "Unbound"))))

(cp:define-command (com-show-standard-value-warnings :command-table "Debugging")
    ()
  (if (null si:*remembered-binding-warnings*)
      (format t "~&There were no standard values which required binding")
    (format t "~&The following standard values were bound:")
    (si:print-any-binding-warnings t nil 2)))

(cp:define-command (com-show-condition-handlers :command-table "Debugger")
    (&key (all 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :documentation "Show handlers for entire stack"))
  (flet ((show-frame-handlers (show-current)
	   (loop for frame = *current-frame* then (frame-previous-active-frame frame)
		 until (null frame)
		 as inner-frame = (frame-innermost-subframe frame)
		 as outer-frame = (frame-previous-active-frame frame)
		 as handlers-found = nil
		 doing
	     (loop for symbol in *condition-handler-lists*
		   as handlers =
		      (ldiff (symeval-in-error-environment symbol inner-frame)
			     (symeval-in-error-environment symbol outer-frame))
		   when handlers
		     do (with-language-for-frame (frame)
			  (unless (or handlers-found show-current)
			    (format t "~&For frame ")
			    (with-character-style (*emphasis-character-style*)
			      (present-stack-frame frame))
			    (princ ":"))
			  (format t "~&~V~:[  ~]~A established in this frame~
					  ~:[ and its subframes~]:~~%"
			    *deemphasis-character-style* show-current
			    (string-capitalize-words (string-trim "*" symbol))
			    (eq inner-frame frame))
			  (setq handlers-found t)
			  (loop for h in (nreverse handlers)
				do (format t "  ~:[  ~]" show-current)
				   (send h :describe-self-briefly)
				   (send standard-output :fresh-line))))
	     (when (and (not handlers-found) show-current)
	       (format t "~&No condition handlers established in this frame~:[ and its subframes~].~%"
		 (eq inner-frame *current-frame*)))
		 until show-current)))
    (show-frame-handlers (not all))))

(cp:define-command (com-show-catch-blocks :command-table "Debugger")
    (&key (all 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :documentation "Show catch blocks for entire stack"))
  (flet ((show-catch-blocks (show-current)
	   (if (and show-current
		    #+3600 (zerop (frame-catch-bit *current-frame*))
		    #+imach (ldb-test %%cr.cleanup-catch
				      (frame-own-control-register *current-frame*)))
	       (format t "~&This frame has no open catch blocks or unwind-protects.~%")
	     (loop initially
		     (format t "~&~V~A~~%"
		       *deemphasis-character-style*
		       (if show-current
			   "Open catch blocks and unwind-protects in this frame:"
			 "All open catch blocks and unwind-protects:"))
		     ;; One below the current frame so %pointer-lessp works...
		   with base-frame = (loop for prev = nil then fp
					   for fp = (%stack-frame-pointer)
						  then (frame-previous-frame fp)
					   when (eq fp *current-frame*)
					     return prev)
		   with current-function = (frame-function *current-frame*)
		   for cb = (progn #+3600 %catch-block-list
				   #+imach (%read-internal-register %register-catch-block-list))
			  then (catch-block-previous cb)
		   until (null cb)
		   #+Imach #+Imach #+Imach #+Imach
		   with cb-frame = (%stack-frame-pointer)
		   doing
	       #+3600
	       (let* ((tag (catch-block-tag cb))
		      (thrown-thru (catch-block-thrown-through cb))
		      (pc (catch-block-pc cb))
		      (disposition (catch-block-value-disposition cb))
		      (function (%find-structure-header pc))
		      (rel-pc (function-relative-pc pc function)))
		 ;; Don't use catch blocks higher than the current frame
		 (when (%pointer-lessp cb base-frame)
		   (when (and show-current (neq function current-function))
		     (return nil))
		   (if (not (zerop thrown-thru))
		       (format t
			   (if (eq tag 'sys:unwind-protect-tag)
			       " UNWIND-PROTECT cleanup in ~*~S at PC ~O ~A~%"
			     " Tag ~S in ~S at PC ~O ~A~%")
			 tag (function-name function) rel-pc
			 "has been thrown through")
		     (format t
			 (if (eq tag 'sys:unwind-protect-tag)
			     " UNWIND-PROTECT cleanup in ~*~S at PC ~O~*~%"
			   " Throwing to tag ~S returns to ~S at PC ~O ~
			     ~[for effect~;with one value~; ~
			       with value(s)~;with multiple values~]~%")
		       tag (function-name function) rel-pc disposition))))
	       #+imach
	       (let ((tag (catch-block-tag cb))
		     (pc (catch-block-pc cb))
		     (unwind-protect (not (zerop (catch-block-unwind-protect cb)))))
		 ;; Don't use catch blocks higher than the current frame
		 (when (%pointer-lessp cb base-frame)
		   ;; Find the frame containing this catch block
		   (loop until (%pointer-lessp cb-frame cb)
			 do (setq cb-frame (frame-previous-frame cb-frame)))
		   ;; The PC is NIL in a catch for value-disposition Return
		   (unless unwind-protect
		     (when (= (catch-block-value-disposition cb) value-disposition-return)
		       (setq pc (frame-return-pc cb-frame))))
		   (let* ((frame-function (frame-function cb-frame))
			  (function (%find-structure-header pc))
			  (rel-pc (function-relative-pc pc function)))
		     (when (and show-current (neq frame-function current-function))
		       (return nil))
		     (if unwind-protect
			 (format t " UNWIND-PROTECT cleanup in ~S at PC ~O~*~%"
				 (function-name function) rel-pc)
			 (format t " Throwing to tag ~S returns ~:[~*~;from ~S ~]~
				    to ~S at PC ~O ~
				    ~[for effect~;with one value~;~
				    with value(s)~;with multiple values~]~
				    ~[~; (already thrown through)~]~%"
				 tag (= (catch-block-value-disposition cb)
					value-disposition-return)
				 (function-name frame-function)
				 (function-name function) rel-pc
				 (catch-block-value-disposition cb)
				 (catch-block-invalid cb))))))))))
    (show-catch-blocks (not all))))

(cp:define-command (com-show-lexical-environment :command-table "Lisp-Debugger")
    ()
  (if (zerop (frame-lexical-called *current-frame*))
      (format t "~&This frame was not lexically called.~%")
    (loop with got-one = nil
	  with cl:*print-level* = *error-message-prinlevel*
	  with cl:*print-length* = *error-message-prinlength*
	  with scl:*print-string-length* = *error-message-string-length*
	  for env-item in (frame-lexical-environment *current-frame*)
	  for env-name in '("variables" "functions" "blocks" "tagbodies" "declarations")
	  when (not (null env-item))
	    do (setq got-one t)
	       (format t "~& ~VLexically inherited ~A:~~%"
		 *deemphasis-character-style* env-name)
	       (loop for (name . value) in env-item
		     do (print-carefully "lexical variable"
			  (format t "~&  ~S: ~S"
			    name (if (locativep value)
				     (location-contents value) (car value)))))
	  finally (unless got-one
		    (format t "~&There is no lexical environment for this frame")))))

(cp:define-command (com-show-lexical-closure :command-table "Lisp-Debugger")
    ((closure 'lexical-closure))
  (let* ((function (lexical-closure-function closure))
	 (lexical-map (cdr (assoc :lexical-map (debugging-info function))))
	 (cl:*print-level* *error-message-prinlevel*)
	 (cl:*print-length* *error-message-prinlength*)
	 (scl:*print-string-length* *error-message-string-length*))
    (format t "~&~VLexical variables in environment for closure of ~~S"
      *deemphasis-character-style* (function-name function))
    (print lexical-map)
    (mapc #'(lambda (x y)
	      (format t "~& ~S: ~S" (first x) y))
	  (cl:sort lexical-map (lambda (x y) (< (lexical-map-variable-generation x)
						(lexical-map-variable-generation y)))
		   :key #'second)
	  (lexical-closure-environment closure))))

;;--- This explodes because the closure isn't printable, so I assume that a
;;--- real printer for this type needs to be added somewhere.
#+++ignore
(define-presentation-to-command-translator describe-closure
   (lexical-closure
    :gesture :describe
    :documentation "Describe this lexical closure")
   (closure)
  `(com-show-lexical-closure ,closure))

;;; Other informational commands.

(cp:define-command (com-show-function-arguments :command-table "Debugging")
    ((function-spec 'function-spec
		    :prompt "function spec" :display-default nil :confirm t))
  (if (fdefinedp function-spec)
      (multiple-value-bind (arglist values type)
	  (arglist function-spec)
	;; Special kludges for things not invoked directly
	(when (listp function-spec)
	  (selectq (first function-spec)
	    (flavor:defun-in-flavor
	     (setq arglist (cddr arglist)))
	    ((flavor:method flavor:ncwhopper)
	     (setq arglist (#+3600 cdddr #+IMach cddr arglist)))
	    ((clos-internals::method)
	     (setq arglist
		   #+IMach (cdr arglist)
		   #+3600 (if (eq (first arglist) 'clos-internals::.extra-argument.)
			      ;; No required arguments
			      (cdr arglist)
			      ;; Arg0 .extra-argument. .generic. . other-args
			      `(,(car arglist)
				. ,(cdddr arglist)))))))
	(format t "~S~@[ (~A)~]: " function-spec type)
	(zwei:print-arglist-internal arglist standard-output)
	(when values
	  (format t "  ~:A" values)))
    (format t "The function ~S is not currently defined." function-spec)))

(define-presentation-to-command-translator show-function-arguments
   (((function-spec :defined-p t))
    :documentation "Show this function's argument list"
    :gesture :describe)
   (function-spec)
  `(com-show-function-arguments ,function-spec))

(define-presentation-to-command-translator show-function-object-arguments
   (function
     :documentation "Show this function's argument list"
     :gesture nil)
   (function)
  `(com-show-function-arguments ,(function-name function)))

(define-presentation-to-command-translator show-frame-function-arguments
   (stack-frame
    :gesture nil
    :documentation "Show this function's argument list"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-show-function-arguments ,(function-name (frame-function (car frame)))))

(cp:define-command (com-show-arglist :command-table "Debugger"
				     :provide-output-destination-keyword nil)
    ()
  (let* ((function-name (lframe-frame-function-name *current-language* *current-frame*))
	 (arglist (lframe-arglist *current-language* *current-frame*)))
    (print-carefully "arglist"
      (format t "~&The argument list for ~S is ~S" function-name arglist))))

(cp:define-command-accelerator arglist "Debugger" (#\c-sh-A) () ()
  `(com-show-arglist))

(cp:define-command (com-show-argument :command-table "Debugger"
				      :provide-output-destination-keyword nil)
    ((argument 'integer-or-all
	       :default :all))
  (let ((*printing-monitor-message* t))
    (format t "~&")
    (if (numberp argument)
	(multiple-value-bind (val loc)
	    (lframe-argument-value *current-language* *current-frame* argument nil t)
	  (print-carefully "argument"
	    (if (null loc)
		(format t "Argument number ~D out of range" argument)
	      (si:set-value-for-* val)
	      (cl:shiftf +++ ++ + loc)
	      (let ((*print-pretty* (or *debugger-print-pretty* *print-pretty*))
		    (*print-circle* (or *debugger-print-circle* *print-circle*)))
		(present val (language-expression-type *current-language*)
			 :location loc)))))
      (print-frame-args *current-frame* 0 nil))))

(cp:define-command-accelerator argument "Debugger" (#\c-m-A) () (arg-p arg)
  `(com-show-argument ,(if arg-p arg 0)))

(cp:define-command-accelerator all-arguments "Debugger" ((#\c-X #\c-A)) () ()
  `(com-show-argument :all))

(cp:define-command (com-show-rest-argument :command-table "Lisp-Debugger"
					   :provide-output-destination-keyword nil)
    ()
  (let ((*printing-monitor-message* t))
    (format t "~&")
    (multiple-value-bind (nil val loc)
	#+3600 (decode-frame-rest-arg *current-frame*)
	#+imach (let* ((frame *current-frame*)
		       (function (frame-function frame))
		       (control-register (frame-own-control-register frame))
		       (args-info (%args-info function))
		       (uses-lp (ldb-test %%arg-desc-rest-arg args-info))
		       (first-local-offset (ldb %%cr.argument-size control-register))
		       (rest-arg-slot (and uses-lp first-local-offset)))
		  (when rest-arg-slot
		    (let* ((loc (%pointer-plus frame rest-arg-slot))
			   (val (location-contents loc)))
		      (values nil val loc))))
      (if (null loc)
	  (format t "There is no &REST argument")
	(si:set-value-for-* val)
	(let ((*print-pretty* (if (memq '&key (arglist (frame-function *current-frame*)))
				  :plist t))
	      (*print-circle* (or *debugger-print-circle* *print-circle*)))
	  (print-carefully "&REST argument"
	    (present val (language-expression-type *current-language*)
		     :location loc)))))))

(cp:define-command-accelerator rest-arg "Lisp-Debugger" ((#\c-X #\c-R)) () ()
  `(com-show-rest-argument))

(cp:define-command (com-show-local :command-table "Debugger"
				   :provide-output-destination-keyword nil)
    ((local 'integer-or-all
	    :default :all))
  (let ((*printing-monitor-message* t))
    (format t "~&")
    (if (numberp local)
	(multiple-value-bind (val loc)
	    (lframe-local-value *current-language* *current-frame* local :force)
	  (print-carefully "Local"
	    (if (null loc)
		(format t "Local number ~D out of range" local)
	      (si:set-value-for-* val)
	      (cl:shiftf +++ ++ + loc)
	      (let ((*print-pretty* (or *debugger-print-pretty* *print-pretty*))
		    (*print-circle* (or *debugger-print-circle* *print-circle*)))
		(present val (language-expression-type *current-language*)
			 :location loc)))))
      (print-frame-locals *current-frame* 0 0))))

(cp:define-command-accelerator local "Debugger" (#\c-m-L) () (arg-p arg)
  `(com-show-local ,(if arg-p arg 0)))

(cp:define-command-accelerator all-locals "Debugger" ((#\c-X #\c-L)) () ()
  `(com-show-local :all))

(cp:define-command (com-show-stack :command-table "Lisp-Debugger")
    ()
  (labels ((display-local-name (#+3600 function #+imach frame localno &optional pc)
	     (let ((name (local-name #+3600 function #+imach frame localno pc)))
	       (when name
		 (princ " (")
		 (present name 'sys:form)
		 (princ ")"))))
	   (display-value (val loc)
	     (print-carefully "value"
	       (let ((cl:*print-level* *error-message-prinlevel*)
		     (cl:*print-length* *error-message-prinlength*)
		     (scl:*print-string-length* *error-message-string-length*))
		 (princ ": ")
		 (present val (language-expression-type *current-language*)
			  :location loc))))
	   (show-stack (frame local-start indent)
	     (let (#+3600 (function (frame-function frame)))
	       (loop with n-locals = (frame-number-of-stack-slots frame)
		     for i upfrom local-start below (1+ n-locals)
		     do	(print-carefully "local"
			  (format t "~&~VTLocal ~D" indent i)
			  (display-local-name #+3600 function #+imach frame i
					      (frame-relative-exit-pc frame))
			  (multiple-value-bind (val loc)
			      (frame-local-value frame i :force)
			    (display-value val loc)))))))
    (let ((*printing-monitor-message* t))
      (show-stack *current-frame* 0 0))))

(cp:define-command (com-show-function :command-table "Lisp-Debugger"
				      :provide-output-destination-keyword nil)
    ()
  (let ((*printing-monitor-message* t))
    #+3600 (cl:shiftf +++ ++ + (locf (frame-function *current-frame*)))
    #+3600 (si:set-value-for-* (location-contents +))
    #+imach (si:set-value-for-* (frame-function *current-frame*))
    (format t "~&")
    ;; This will print correctly even for interpreted functions,
    ;; but we will get reasonable mouse-sensitivity for our efforts
    (print-carefully "frame function"
      (present * '((compiled-function-spec) :name-only nil)))))

(cp:define-command-accelerator function "Lisp-Debugger" (#\c-m-F) () ()
  `(com-show-function))

(cp:define-command (com-show-value :command-table "Lisp-Debugger"
				   :provide-output-destination-keyword nil)
    ((value 'integer-or-all
	    :default :all))
  (let ((*printing-monitor-message* t))
    (format t "~&")
    (if (operation-handled-p *error* :values-being-returned)
	(multiple-value-bind (values #+imach locations) 
	    (send *error* :values-being-returned)
	  (if (numberp value)
	      (print-carefully "Value"
		(cond ((< value (length values))
		       (si:set-value-for-* (nth value values))
		       (cl:shiftf +++ ++ + #+3600 (locf (nth value values))
					   #+imach (nth value locations))
		       (let ((*print-pretty* (or *debugger-print-pretty* *print-pretty*))
			     (*print-circle* (or *debugger-print-circle* *print-circle*)))
			 (present * (language-expression-type *current-language*)
				  :location +)))
		      (t (format t "Value number ~D out of range; ~
				    ~D values are being returned"
			   value (length values)))))
	    (loop with value-names = (multiple-value-bind (nil values-names)
					 (let ((function (frame-function *current-frame*)))
					   (and (legitimate-function-p function)
						(arglist function)))
				       values-names)
		  for i below (length values)
		  as name = (nth i value-names)
		  as val = (nth i values)
		  as loc = #+3600 (locf (nth i values))
			   #+imach (nth i locations)
		  do (print-carefully "value"
		       (format t "~& Value ~D~@[ (~A)~]: " i name)
		       (present val (language-expression-type *current-language*)
				:location loc)))))
      (princ "No values are being returned now"))))

(cp:define-command-accelerator value "Lisp-Debugger" (#\c-m-V) () (arg-p arg)
  `(com-show-value ,(if arg-p arg 0)))

(cp:define-command (com-show-instruction :command-table "Debugger"
					 :provide-output-destination-keyword nil)
    ()
  (lframe-describe-instruction *current-language* *current-frame*))

(cp:define-command-accelerator instruction "Debugger" (#\c-m-I) () ()
  `(com-show-instruction))

(cp:define-command (com-describe-last :command-table "Debugger"
				      :provide-output-destination-keyword nil)
    ()
  (funcall (language-expression-describer *current-language*) *))

(cp:define-command (com-describe-local :command-table "Debugger"
				       :provide-output-destination-keyword nil)
    ((local 'integer-or-all
	    :default :all))
  (multiple-value-bind (val loc)
      (lframe-local-value *current-language* *current-frame* local :force)
    (print-carefully "Local"
      (if (null loc)
	  (format t "Local number ~D out of range" local)
	(si:set-value-for-* val)
	(cl:shiftf +++ ++ + loc)
	(funcall (language-expression-describer *current-language*) val)))))

(cp:define-command-accelerator describe "Debugger" (#\c-m-D) () (arg-p arg)
  (if arg-p
      `(com-describe-local ,arg)
    `(com-describe-last)))

(cp:define-command (com-evaluate-form :command-table "Debugger"
				      :provide-output-destination-keyword nil)
    ((form 'form-or-code-fragment
	   :prompt "a form or code fragment"))
  (catch 'quit
    (eval-and-print-for-values form))
  (cl:shiftf +++ ++ + -))

;;--- Someday, ACCEPT needs to have less Lisp wired into it, so that just typing
;;--- a form at top level works correctly.
(cp:define-command-accelerator evaluate-form "Debugger" (#\c-sh-E) (:echo nil) ()
  (format t "~&~A to evaluate: " (language-expression-name *current-language*))
  (let ((form (first (funcall-in-error-environment t t
		       (language-expression-reader *current-language*)))))
    `(com-evaluate-form ,form)))

(define-presentation-to-command-translator evaluate-form
   (sys:code-fragment
     :gesture :evaluate-form
     :documentation "Evaluate this code fragment")
   (code-fragment)
  `(com-evaluate-form ,code-fragment))

(defvar *last-self-value* nil)
(cp:define-command (com-symeval-in-last-instance :command-table "Lisp-Debugger"
						 :name "Symeval in Last Instance"
						 :provide-output-destination-keyword nil)
    ((symbol 'symbol))
  (let ((self-value (if (instancep *) * *last-self-value*)))
    (format t "~&")
    (cond ((not (instancep self-value))
	   (princ "The last value is not an instance"))
	  (t (setq *last-self-value* self-value)
	     (let ((loc (locate-in-instance self-value symbol)))
 	       (cond ((not (location-boundp loc))
		      (format t "~@\PRESENTATION\ currently unbound in ~S.~%"
			symbol 'sys:form self-value))
		     (t (let ((val (location-contents loc)))
			  (si:set-value-for-* val)
			  (cl:shiftf +++ ++ + loc)
			  (present val 'sys:expression :location loc)))))))))

(cp:define-command-accelerator instance-eval "Lisp-Debugger" ((#\c-X #\c-I)) (:activate nil) ()
  `(com-symeval-in-last-instance))

(cp:define-command (com-edit-function :command-table "Debugger"
				      :provide-output-destination-keyword nil
				      :explicit-arglist
				        (&optional (function nil function-supplied-p)))
    ((function 'stack-frame-or-function-spec
	       :default (when (variable-boundp *current-frame*)
			  (function-name (frame-function *current-frame*)))))
  (let* ((function (if function-supplied-p
		       function
		     (and (variable-boundp *current-frame*)
			  (function-name (frame-function *current-frame*))))))
    (cond ((presentation-frame-p function)
	   (setq function (function-name (frame-function (car function)))))
	  ((and (listp function) (memq (car function) flavor::*accessor-method-types*))
	   (format t "~&The accessor for ~S is defined by the flavor ~S"
	     (flavor::accessor-instance-variable function)
	     (flavor:method-flavor function))
	   (return-from com-edit-function
	     (ed `(zwei:edit-definition ,(flavor:method-flavor function) (defflavor))))))
    (let* ((real-function (si:valid-function-definition function t))
	   (function (and real-function (function-name function))))
      (if (typep real-function :compiled-function)
	  (multiple-value-bind (language foundp)
	      (if *always-use-lisp-debugger*
		  ;; Even if the user thinks he wants to always use Lisp,
		  ;; we still have to get the BP for the proper language.
		  (let ((*always-use-lisp-debugger* nil))
		    (find-language-for-function real-function))
		(values *current-language* t))
	    (multiple-value-bind (bp definition-type)
		(and foundp
		     (not function-supplied-p)
		     (variable-boundp *current-frame*)
		     (lframe-current-source-locator-bp language *current-frame*))
	      (if bp
		  (ed `(zwei:function-at-bp
			 ,(function-name-for-editor language function)
			 ,bp ,definition-type))
		;; Compiled functions are always DEFUNs
		(ed `(zwei:edit-definition ,function (defun))))))
	(if (null function)
	    (format t "~&There is no function for this frame")
	  (ed `(zwei:edit-definition ,function (defun))))))))    

(cp:define-command-accelerator edit-function "Debugger" (#\c-E) () ()
  `(com-edit-function))

(define-presentation-to-command-translator edit-frame-function
   (stack-frame
    :gesture :edit-function
    :documentation "Edit this frame's function"
    :tester ((frame &rest ignore)
	     (stack-frame-not-stale frame)))
   (frame)
  `(com-edit-function ,(function-name (frame-function (car frame)))))

(cp:define-command (com-show-compiled-code :command-table "Debugging")
    ((function 'compiled-function-spec
	       :default (if (variable-boundp *current-frame*)
			    (function-name (frame-function *current-frame*))
			  nil))
     (from-pc '((cl:integer) :base 8)
	      :default 0
	      :prompt "from PC")
     (to-pc '((or ((cl:integer) :base 8) null))
	    :default nil
	    :prompt "to pc"))
  (let ((function-name (if (cl:compiled-function-p function)
			   (function-name function)
			 function)))
    (format t "~&~VDisassembled code for ~~S:~%"
      *deemphasis-character-style* function-name))
  (disassemble function from-pc to-pc))

;; Show the disassembled code for the function we are running, being
;; careful to not show the code for any redefined version.
(cp:define-command-accelerator disassemble "Debugger" ((#\c-X #\D)) () ()
  `(com-show-compiled-code ,(frame-function *current-frame*)))

;; This is careful to disassemble the compiled-code object pointed to, not the
;; compiled-code object named by the function-name of the object.  That means
;; the right thing gets disassembled if the function is redefined.
(define-presentation-to-command-translator show-compiled-code-for-function-object
   (function
    :tester ((function)
	     (cl:compiled-function-p (or (special-form-p function)
					 (macro-function function)
					 function)))
    :gesture :disassemble
    :documentation "Disassemble this function")
   (function)
  `(com-show-compiled-code ,function))

;; Show the disassembled code for the most recent version of the function.
(define-presentation-to-command-translator show-compiled-code
   (((sys:function-spec :defined-p t))
    :gesture :disassemble
    :documentation "Disassemble this function"
    :tester ((function-spec)
	     (let ((function (si:valid-function-definition
			       (si:unencapsulate-function-spec function-spec))))
	       (cl:compiled-function-p (or (special-form-p function)
					   (macro-function function)
					   function)))))
   (function-spec)
  `(com-show-compiled-code ,function-spec))

(define-presentation-to-command-translator show-compiled-code-for-frame
   (stack-frame
    :gesture :disassemble
    :documentation "Disassemble the function for this frame"
    :tester ((frame)
	     (and (stack-frame-not-stale frame)
		  (cl:compiled-function-p (frame-function (car frame))))))
   (frame)
  `(com-show-compiled-code ,(frame-function (car frame))))

;; A useful function
(defun print-definition-from-correspondences (function)
  (terpri)
  (multiple-value-bind (section correspondences)
      (si:function-correspondence-info function)
    (if (and section correspondences)
	(zwei:output-interval-with-presentation-nodes-sensitivity
	  section nil t nil)
      (format t "~&~S was not compiled from the editor.~%" (function-name function))))
  (values))

(defun show-lisp-frame-source (frame &optional function (header-p t) (warn-p t))
  (when (and (null function) (not (null frame)))
    (setq function (frame-function frame)))
  (setq function (si:unencapsulate-function-spec function))
  (multiple-value-bind (section correspondences)
      (si:function-correspondence-info function)
    (cond ((and section correspondences)
	   (when header-p
	     (if (eq header-p :brief)
		 (format t "~%~VSource code:~"
		   *deemphasis-character-style* )
	       (format t "~&~VSource code for ~~S:~%"
		 *deemphasis-character-style* (function-name function))))
	   (zwei:output-interval-with-presentation-nodes-sensitivity
	     section nil t nil
	     :highlighted-presentations
	     (when frame
	       (let ((locator (frame-exit-source-locator frame)))
		 (and locator
		      (list (make-instance 'dw:presentation
					   :type 'sys:code-fragment
					   :location (locf (first locator)))))))))
	  ((and (listp (si:valid-function-definition function))
		(not (macro-function function))
		(not (special-form-p function)))
	   ;; Might be interpreted code
	   (gprint:print-object (si:undigest (si:valid-function-definition function))))
	  (t (when warn-p
	       (format t "~&Function ~S ~A~%"
		 (function-name function)
		 (if (null section)
		     "is not in an editor buffer"
		   "has no source locators; the code will not be sensitive")))
	     (when header-p
	       (if (eq header-p :brief)
		   (format t "~%~V~:[Source~;Disassembled~] code:~"
		     *deemphasis-character-style* (null section))
		 (format t "~&~V~:[Source~;Disassembled~] code for ~~S:~%"
		   *deemphasis-character-style* (null section) (function-name function))))
	     (if (null section)
		 (lframe-disassemble-function (find-language-for-frame frame) frame
					      (or (special-form-p function)
						  (macro-function function)
						  (si:valid-function-definition function t)))
	       (let* ((first-bp (send section :first-bp))
		      (last-bp (send section :last-bp))
		      (interval-stream (zwei:open-interval-stream first-bp last-bp t)))
		 (stream-copy-until-eof interval-stream standard-output)))))))

(cp:define-command (com-show-source-code :command-table "Editing")
    ((function '((sys:function-spec :defined-p t) :partial-completers nil)
	       :default (if (variable-boundp *current-frame*)
			    (function-name (frame-function *current-frame*))
			    nil)
	       :confirm (not (variable-boundp *current-frame*))))
  (let ((frame (when (and (variable-boundp *current-frame*)
			  (equal function (function-name (frame-function *current-frame*))))
		 *current-frame*)))
    (let ((language (if frame
			(find-language-for-frame frame)
		      (find-language-for-function function))))
      (lframe-show-code-for-function language frame (fdefinition function) t t t))))

(cp:define-command-accelerator source-code "Debugger" ((#\c-X #\c-D)) () ()
  `(com-show-source-code))

;; Command to set the stack size
(cp:define-command (com-set-stack-size :command-table "Debugging"
				       :provide-output-destination-keyword nil)
    ((stack 'stack-type
	    :default :control)
     (size `((stack-size) :stack-type ,stack)))
   ;; Now set the stack size.  It's OK if there is no data stack
   (if (and (eq stack ':data)
	    (null (sg-data-stack-low %current-stack-group)))
       (si:grow-data-stack size)
     (without-interrupts
       (call-stack-grower
	 stack
	 (- size
	    (selectq stack
	      ;; The +32 in the next line is to allow for the size of this frame
	      ;; and the other frames required to perform the stack-group call.
	      (:control (+ (%pointer-difference (%stack-frame-pointer) %control-stack-low)
			   32.))
	      ;; The +3 in the next line is because of the WITHOUT-INTERRUPTS later
	      (:bind (+ (%pointer-difference
			  %binding-stack-pointer
			  #+3600 %binding-stack-low
			  #+imach (%pointer-plus
				    (sg-binding-stack-low %current-stack-group)
				    (defstorage-size binding-stack-entry)))
			3))
	      (:data (if (sg-data-stack-low %current-stack-group)
			 (1+ (%pointer-difference
			       (sg-data-stack-pointer %current-stack-group)
			       (sg-data-stack-low %current-stack-group)))
			 0))))))))

;;; Bug report generation.

(defprop bug-report-recipient-system t si:debug-info)

;;; This variable is the one place in the system where the root name of the
;;; default bug-report recipient is defined.  Its standard value in the
;;; distributed world is "Lispm", so the default recipient is the traditional
;;; "Bug-Lispm".  At SCRC, we change the value to "Genera".  Change the value
;;; of this string to make a global change to the "Bug-D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")<whatever>0" default.
(defvar *default-bug-recipient-root-name* "Lispm")

;; This alist normally includes only top-level functions
(defconst *function-bug-report-alist*
	  (let ((foo
		  `((zwei:eval-print
		      ,*default-bug-recipient-root-name*)	;catches evals inside of Zwei
		    (dw:menu-choose "DW")
		    (dw::layout-designer-top-level "DW")
		    (compiler:compile "Lisp-Compiler")
		    (compiler:compile-file "Lisp-Compiler")
		    (zwei:compile-interval "Lisp-Compiler")
		    (zwei:zmacs-window-top-level "Zwei")
		    (zwei:zmail-process-top-level "Zmail"))))
	    (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;--- This does not work on the I-machine
0	    (sys:%p-store-cdr-type-and-pointer	;link the structure to the root name
	      (locf (cadar foo)) (sys:%p-cdr-code (locf (cadar foo)))
	      sys:dtp-external-value-cell-pointer
	      (locf *default-bug-recipient-root-name*))
	    foo))

;;;--- Too bad about the top-level code needed to make external-value-cell pointer linkery
;;;--- work for a variable.  It should be replaced later by an appropriate new defining
;;;--- macro, so it can be done in a single definition. -- Dodds 2/15/88
(defvar-resettable *default-default-bug-report-recipient-system*
   *default-bug-recipient-root-name* *default-bug-recipient-root-name*)

2;;--- This does not work on the I-machine
0(progn
  (sys:%p-store-cdr-type-and-pointer
    (locf *default-default-bug-report-recipient-system*)
    (sys:%p-cdr-code (locf *default-default-bug-report-recipient-system*))
    sys:dtp-external-value-cell-pointer (locf *default-bug-recipient-root-name*))
  (sys:%p-store-cdr-type-and-pointer
    (locf (second (assq 'dbg:*default-default-bug-report-recipient-system*
			si:*warm-boot-bindings*)))
    (sys:%p-cdr-code (locf (second (assq 'dbg:*default-default-bug-report-recipient-system*
				   si:*warm-boot-bindings*))))
    sys:dtp-external-value-cell-pointer (locf *default-bug-recipient-root-name*)))

(defvar-resettable *default-bug-report-recipient-system* nil nil)
	    
(defmacro with-default-bug-report-recipient-system ((system) &body body)
  `(let ((dbg:*default-bug-report-recipient-system* ,system))
     ,@body))

(defun mail-bug-report-1 (&key (system (or *default-bug-report-recipient-system*
					   *default-default-bug-report-recipient-system*))
			  (process-name "Bug report") (window-name "Bug-report Window")
			  additional-body prompt point-before-additional-body)
  (declare (special zwei:*require-subjects*))
  (when (net:remote-terminal-p)
    (when (cl:yes-or-no-p 
 "Would you like to send the report from this remote terminal,
without the ability to edit the automatic text,
rather than having ~: exposed on the real console?  " window-name)
      (multiple-value-bind (address prologue)
	  (zwei:parse-bug-arg system)
	(let ((to (accept '((cl:sequence zwei:address)) :prompt "To"
			  :default (zwei:parse-addresses address)))
	      (cc (accept '((cl:sequence zwei:address)) :prompt "CC"
			  :default `((:user ,si:*user*))))
	      (subject (when (member zwei:*require-subjects* '(t :bug))
			 (accept 'string :prompt "Subject")))
	      (text (accept 'zwei:message-string
			    :prompt (format nil "~@[~A~%~]Text (end with ”):~%" prompt)
			    :prompt-mode :raw
			    :activation-chars '(#\End #\c-End)
			    :default nil)))
	  (setq text (string-append prologue #\return text))
	  (when additional-body
	    (setq text (string-append text #\return additional-body)))
	  (zwei:send-message-string to text :cc cc :subject subject)
	  (return-from mail-bug-report-1)))))
  (mail-bug-report window-name process-name
		   #'bug system additional-body prompt point-before-additional-body
		   (memq zwei:*require-subjects* '(t :init :bug)) nil nil
		   (tv:console-default-superior)))

(defvar *bug-report-chars-per-second* #+3600 2500.
				      #+imach (sys:system-case
						(macivory 1500.)
						(otherwise 2500.)))

(defun mail-bug-report (window-name process-name function &rest args)
  (let ((additional-body (and (eq function #'bug)
			      (second args)))
	(process (cl:apply #'process-run-function process-name function args)))
    ;; Before calling PROCESS-WAIT-WITH-TIMEOUT, make sure the scheduler is operative
    ;; and not inhibited.  We test TERMINAL-IO rather than INHIBIT-SCHEDULING-FLAG
    ;; for a reason; INHIBIT-SCHEDULING-FLAG can be T yet scheduling will still happen
    ;; when we :TYI to read the next debugger command, if TERMINAL-IO is a window.
    (cond ((eq terminal-io tv:cold-load-stream)
	   ;; Scheduler is inoperative
	   (format t "~&~: will start up when the scheduler is running again"
	     window-name))
	  ((not (typep terminal-io 'tv:sheet))
	   ;; We aren't using the window system
	   (format t "~&~: is starting up on ~A"
	     window-name (if tv:default-screen (send tv:default-screen :name)
			     "the window system")))
	  (t
	   ;; Normal case
	   ;; Wait until the process has started up and covered over our window
	   (unless (process-wait-with-timeout
		       "Bug window startup"
		       (* 60. (if (stringp additional-body)
				  (max 15. (// (string-length additional-body)
					       *bug-report-chars-per-second*))
				15.))
		     #'(lambda (process)
			 (equal (process-whostate process) si:*whostate-awaiting-user-input*))
		     process)
	     ;; Deal with the possibility of the bug window starting up while
	     ;; this message is being printed
	     (let ((window terminal-io))
	       ;; This kludge is because there is no activity system.  Programs that use
	       ;; frames generally use a typeout window as TERMINAL-IO, and it normally
	       ;; doesn't ever get exposed.  So use its superior instead.
	       (when (typep window 'tv:basic-typeout-window)
		 (setq window (send window :superior)))
	       (when (memq (send window :status) '(:selected :exposed))
		 ;; Time out -- explain ourselves
		 (format t "~&Timed out while waiting for ~A to start up.~%" window-name)
		 (let ((state (process-whostate process)))
		   (if (equal state "Run")
		       (princ "The process controlling it is still running; please wait")
		     (format t "The process controlling it is in state ~S.
You can select it using [Select] in the system menu, but you may have to clear
whatever condition is preventing it from starting up first.  In order to allow
the ~A to come up so you can finish transmitting the report,
it may prove necessary to abort the process that got the error or even to
type ~:C ~:C." state window-name #\Function #\c-Clear-Input))))))
	   ;; Now wait until our window comes back to the top before prompting
	   (tv:await-window-exposure)))))

;; If FOR-FUNCTION is defined in a file which is part of a system, and that
;; system defines a bug list recipient, return that recipient.  (If necessary
;; we could have a list of systems which aren't really interesting, but
;; fortunately most internal systems DON'T define bug recipients, so we
;; don't get errors sent to Bug-Genera just because RPLACD was called on 3.)
(defun get-interesting-system-bug-report-list-name (for-function)
  (declare (values bug-recipient system))
  (labels ((find-system-bug-report-list-or-superior/'s (system)
	     (or (sct:system-bug-reports system)
		 ;; "Subsystems may have only a single parent", so this is safe
		 (when (sct:system-component-of-systems system)
		   (find-system-bug-report-list-or-superior/'s
		     (car (sct:system-component-of-systems system)))))))
    (destructuring-bind (bug-recipient system)	;ignore-errors doesn't return multiple values
	(ignore-errors				;paper over potential bugs
	  (let* ((file (si:get-source-file-name for-function 'defun))
		 (system (when file (send (send file :generic-pathname) :get 'sct:system))))
	    ;; Someday perhaps check to see if this system should be ignored and hence
	    ;; make this function live up to the "interesting-system" part of its name.
	    (when system
	      (list (find-system-bug-report-list-or-superior/'s system) system))))
      (when bug-recipient
	(values bug-recipient system)))))

(defun extract-bug-recipient (recipient-spec system)
  (cond ;; oldest new-DEFSYSTEM syntax: if there is a system, return "Bug-<system>", else NIL
	((eq recipient-spec t)
	 (when (typep system 'sct:system)
	   (format nil "Bug-~:(~A~)" (sct:system-name system))))
	;; old-DEFSYSTEM syntax: just return the (presumed) symbol
	((atom recipient-spec)
	 recipient-spec)
	;; present (plist-style) syntax: default missing :name and :mailing-list and return
	((symbolp (first recipient-spec))
	 (unless (cl:getf recipient-spec :mailing-list)
	   (setq recipient-spec
		 (append recipient-spec (list :mailing-list (format nil "Bug-~:(~A~)"
					       (sct:system-name system))))))
	 (unless (cl:getf recipient-spec :name)
	   (setq recipient-spec
		 (append recipient-spec (list :name (sct:system-pretty-name system)))))
	 recipient-spec)
	;; second-oldest new-DEFSYSTEM syntax, a list of (<mailing-list> <mouse-doc>):
	;; transform into new format and return that
	(t
	 (if (typep system 'sct:system)
	     (list :name (sct:system-pretty-name system) :mailing-list (first recipient-spec))
	   (list :mailing-list (first recipient-spec))))))

(defmethod (:bug-report-recipient-system condition) ()
  (loop for frame = *innermost-interesting-frame*
		  then (frame-previous-frame frame)
	until (null frame)
	as function = (function-name (frame-function frame))
	do (multiple-value-bind (bug-report system)
	       (or (second (assq 'bug-report-recipient-system (debugging-info function)))
		   (second (assq function *function-bug-report-alist*))
		   (get-interesting-system-bug-report-list-name function))
	     (when bug-report
	       (return (extract-bug-recipient bug-report system))))
	finally (return *default-default-bug-report-recipient-system*)))


;;; Some useful debugging tools, stolen from various places

;; All of these debugging tools generate compiler warnings, so that they
;; don't accidently creep into sources undetected
(defun debugging-style-warning (form)
  (compiler:warn () "Debugging statement: ~S" form))

;; This produces a distinctive whistle when executed
(defprop whistle debugging-style-warning compiler:style-checker) 
(defun whistle (&key (direction ':down))
  (if (eq direction ':down)
      (%slide 0 50. 20000. 320000.)
      (%slide 800. -50. 20000. 320000.)))

;; Executes BODY only when the Mode-Lock key is held down
(defprop when-mode-lock debugging-style-warning compiler:style-checker)
(defmacro when-mode-lock (&body body)
  `(when (when-mode-lock-internal)
     ,@body))

;; Executes BODY only when the Mode-Lock key is NOT held down
(defprop unless-mode-lock debugging-style-warning compiler:style-checker)
(defmacro unless-mode-lock (&body body)
  `(unless (when-mode-lock-internal)
     ,@body))

(tv:define-mode-lock-state :debugger "Enable forms within DBG:WHEN-MODE-LOCK")

(defun when-mode-lock-internal ()
  (tv:mode-lock-state :debugger))

(defvar *user-debugging-flags* (make-array 100. :type 'art-boolean :fill-pointer 0))

(defprop when-flag debugging-style-warning compiler:style-checker)
(defmacro when-flag (number &body body)
  `(when (when-flag-internal ,number)
     ,@body))

(defprop unless-flag debugging-style-warning compiler:style-checker)
(defmacro unless-flag (number &body body)
  `(unless (when-flag-internal ,number)
     ,@body))

(defun when-flag-internal (number)
  (values
    (ignore-errors				;if you can't aref it, it ain't set
      (aref *user-debugging-flags* number))))

(defun kbd-toggle-dbg-flag (&optional arg)
  (cond ((zerop (or arg 0))
	 (tv:show-help #'dbg-flag-help
		       :title "DBG Flag Help"
		       :force-redisplay t))
	(t (let ((state (not (minusp arg))))
	     (setq arg (abs arg))
	     (if (> arg (array-length *user-debugging-flags*))
		 (beep)
	       (setf (aref *user-debugging-flags* arg) state)
	       (if state
		   (dw::maxf (fill-pointer *user-debugging-flags*) (1+ arg))
		 (loop for i downfrom (1- (fill-pointer *user-debugging-flags*))
		       do (cond (( i 0)
				 (setf (fill-pointer *user-debugging-flags*) 0)
				 (return))
				((aref *user-debugging-flags* i)
				 (setf (fill-pointer *user-debugging-flags*) (1+ i))
				 (return))))))))))

(defun kbd-toggle-all-dbg-flags (&optional arg)
  (loop with state = (not (minusp (or arg 0)))
	for i below (array-length *user-debugging-flags*)
	do (setf (aref *user-debugging-flags* i) state)
	finally (setf (fill-pointer *user-debugging-flags*)
		      (if state (array-length *user-debugging-flags*) 0))))

(defun dbg-flag-help (stream)
  (with-character-family (:swiss stream :bind-line-height t)
    (format stream  "~%Use Function 1number0 D to set flag 1number0.~@
		       Use Function <minus> 1number0 D to clear flag 1number0.~@
		       Use Function D to inspect the flag settings.~@
		     ~%Code may use (dbg:when-flag 1number0 ...)~%~%"))
  (formatting-table (stream :inter-column-spacing (* (send stream :char-width) 2))
    (formatting-column-headings (stream :underline-p T)
      (formatting-cell (stream) "Number")
      (formatting-cell (stream) "State"))
    (if (> (fill-pointer *user-debugging-flags*) 1)
	(loop for i from 1 below (fill-pointer *user-debugging-flags*)
	      doing
	  (formatting-row (stream)
	    (formatting-cell (stream :align :right)
	      (scl:write i :stream stream))
	    (formatting-cell (stream)
	      (let ((s (aref *user-debugging-flags* i)))
		;;--- Someday use a real AVV here, so that you can click on these
		;;--- flags to change their state
		(if s
		    (scl:write-string "On" stream)
		  (scl:write-string "   Off" stream))))))
      (formatting-row (stream :single-column T)
	(formatting-cell (stream)
	  (with-character-face (:italic stream)
	    (scl:write-string "(none set)" stream))))))
  (terpri stream)
  ;;--- A little disassembly of the caller would allow us to show them with
  ;;--- the list of flags above.
  (let ((callee 'when-flag-internal)
	(callers ()))
    (si:map-over-callers callee
			 (lambda (caller how)
			   (ignore how)
			   (push caller callers))
			 :called-how :function)
    (cond (callers
	   (format stream "These functions call ~S:~%" callee)
	   (format-textual-list callers
				(lambda (item stream)
				  (scl:present item '((sys:function-spec) :abbreviate-p T)
					       :stream stream))
				:stream stream))
	  (t (format stream "(no callers of ~s)" callee))))
  (scl:fresh-line stream))

(tv:add-function-key #/D   'kbd-toggle-dbg-flag "Toggle DBG flag state")
(tv:add-function-key #/c-D 'kbd-toggle-all-dbg-flags "Toggle all DBG flags")

;; Presents the values of a set of named variables, the presentation type
;; being the DW:PRESENTATION-TYPE declaration for a name
(defprop show-values debugging-style-warning compiler:style-checker)
(defmacro show-values (dbg-p &rest vars)
  `(progn
     ,@(loop for var in vars
	     collect `(format trace-output "~&~S: " ',var)
	     ;; :LOCATION is not strictly safe, since the variable in question
	     ;; might be "gone" by the time the user tries to modify it
	     collect `(present ,var ',(presentation-type-for-name var 'sys:form)
			       :location (locf ,var)
			       :stream trace-output))
     ,@(when dbg-p '((dbg)))))

;;--- This works at compile-time, how about making it work at run-time
;;--- so that just typing the name of a local variable gets the output
;;--- presented correctly, and c-m-R asks for the right thing, etc.
;;--- Of course, that means branch-spreading, etc...
(defun presentation-type-for-name (name &optional (default 't))
  (or (loop named found-type
	    with seen-contour = nil
	    for declare in compiler:local-declarations
	    doing
	(when (listp declare)
	  (selectq (car declare)
	    ((compiler:lexical compiler:special)
	     (when (memq name (cdr declare))
	       ;; If there has been a new binding of NAME, return the
	       ;; default rather than the declared type
	       (when seen-contour
		 (return default))
	       (setq seen-contour t)))
	    ((dw:presentation-type)
	     (loop for (type . names) in (cdr declare)
		   when (memq name names)
		     do (return-from found-type type))))))
      default))

#||
(defun foo (x &optional (z x))
  (declare (dw:presentation-type (cl:integer x z)))
  (let ((y (fs:merge-pathnames (format nil "foo.lisp.~D" z)))
	(z nil))
    (declare (dw:presentation-type (fs:pathname y) (sys:form x)))
    ;; Note that the Z here isn't the one we know about
    (show-values nil x y z))
  (show-values t x z)
  (values x z))
||#

;; Invoke the error handler to look at a particular stack group.
;; A window or process may also be supplied, and a stack group found from it.
;; Supplying NIL means find a process which is waiting to be looked at.
;; Forces a call to the debugger inside that stack group, but with our
;; TERMINAL-IO
(defun dbg (&optional process)
  ;; This has no effect
  (declare (error-reporter))
  (cond ((null process)
	 (return-from dbg
	   (enter-debugger (make-condition 'synchronous-break) nil nil t)))
	((eq process t)
	 (setq process (tv:find-process-in-error))))
  (if (null process)
      "cannot find a process"
    ;; If arg is a window or stream, extract process from it.
    (or (typep process :stack-group)
	(process:process-p process)
	(setq process (funcall process :process)))
    ;; Extract PROCESS and stack-group (SG) so that we have both.
    (let ((sg (if (process:process-p process)
		  (process::process-stack-group process)
		(prog1 process (setq process nil)))))
      (unless (typep sg :stack-group)
	(if (and (null sg)
		 (process:process-simple-p process))
	    (ferror "~S is a simple process that currently has no state, or stack.  There is nothing to debug."
	      process)
	  (ferror "~S not a stack group" sg)))
      ;; If called on a random stack group, warn the user.
      (and (or process
	       (yes-or-no-p
		 "If that stack group is in use by any other process, you will lose.
Are you sure this is what you want to do? "))
	   ;; LOCK is a cell for inter-process communication.  The debuggee stores a T when
	   ;; the user is finished debugging, and that makes us return.
	   (let ((lock nil))
	     (cond ((not process)
		    #---ignore (ferror "Can't debug stack groups yet")
		    #+++ignore (force-sg-into-debugger sg terminal-io lock))
		   (t (cond ((process:process-arrest-reasons process)
			     (format t "~&Note: waiting until ~S is un-arrested~%" process))
			    ((null (process:process-run-reasons process))
			     (format t "~&Note: waiting until ~S is given a run-reason~%"
			       process)))
		      (process:process-interrupt process
		        #'(lambda (debug-io calling-process)
			    ;; This has no effect
			    (declare (error-reporter))
			    (unwind-protect
				;; For this message, it might be a stack group but usually it's a process.
				(catch-error-restart (abort "Allow process to continue")
				  (enter-debugger (make-condition 'asynchronous-break) nil nil t))
			      (setf lock t)
			      (process:process-wakeup calling-process)))
			terminal-io *current-process*)))
	     (process:process-block "DBG" #'(lambda () lock)))))))


