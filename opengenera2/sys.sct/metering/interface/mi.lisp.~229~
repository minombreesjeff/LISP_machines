;;; -*- Mode: LISP; Syntax: Common-lisp; Package: mi; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; 5) running metering outside of the interface
;;; 6) the semantics of filters have to be thought out


0;;; flavor to allow instance variables that aren't publicly advertised "state-variables"
(defflavor mi-base-program
	((real-page-fault-collector
	   (make-data-collector 'metering:event-trace
					 :circular nil
					 :size 10000
					 :area metering:metering-area))
	 (default-output-fields-alist nil)
	 (current-run nil)	 
	 (tick 0)
	 (history-tick 0)
	 )
	(dw::program)
  (:conc-name mi-)
  :readable-instance-variables
  (:writable-instance-variables history-tick)
  )


(defvar *run-list* nil "List of all the metering runs.")
(defvar *last-run* nil "A tail pointer for *run-list*")

(defun last-run () (car *last-run*))

(defun register-run (run &optional mi)
  (unless mi
    (let ((window (dw:find-program-window 'metering-interface :create-p nil)))
      (when window
	(setf mi (send window :program)))))
  (when mi (incf (mi-history-tick mi)))
  (if *last-run*
      (setf (cdr *last-run*) (cons run nil)
	    *last-run* (cdr *last-run*))
      (if *run-list*
	  (error "*last-run* is nil but *run-list* is not (~S)"
		 *run-list*)
	  (setf *run-list* (cons run nil)
		*last-run* *run-list*))))

(defun delete-run (run &optional mi temporarily)
  (unless mi
    (let ((window (dw:find-program-window 'metering-interface :create-p nil)))
      (when window
	(setf mi (send window :program)))))
  (when mi (incf (mi-history-tick mi))) 
  (unless temporarily (clean-up-run-is-dead run))
  (setf *run-list* (remove run *run-list*)
	*last-run* (last *run-list*)))


	 
(define-program-framework metering-interface
  :inherit-from (dw:help-program mi-base-program)
  :select-key #\%
  :command-definer define-mi-command
  :pretty-name "Metering Interface"
  :top-level (top-level)
  :command-table
  (:inherit-from '("help-program" "Standard arguments")
   :kbd-accelerator-p t)
   :help dw:help-program-help
  :state-variables nil
  :panes
  ((title :title :size-from-output t
	  :default-character-style '(:EUREX :ITALIC :HUGE)
	  :redisplay-function
	  #'(lambda (ignore stream)
	      (dw:with-output-as-presentation (:stream stream :object
						       "Metering Interface"
						       :single-box t	       
						       :type 'dw:program-name)		
		(write-string "Metering" stream)
		(terpri stream)
		(write-string "Interface" stream)))
	  :height-in-lines 2 :redisplay-after-commands nil)
   (interactor :listener
     :margin-components '((margin-borders)
			  (margin-white-borders)
			  (margin-scroll-bar)
			  (margin-white-borders))
     :more-p nil)
   (command-menu :command-menu :menu-level :top-level
		 :rows '(("Meter Form" "Meter in Process"
			  "Re-Meter" "Set Display Options"
			  "Show Metering Run" "Help"))
		 :equalize-column-widths nil)
   (meter-history :display
     :blinker-deselected-visibility t
     :blinker-flavor 'tv:hollow-rectangular-blinker
     :margin-components '((margin-borders)
			  (margin-white-borders)
			  (margin-label :margin :bottom
					:style (:dutch :italic :normal)
					:string "History of Metering Runs")
			  (margin-scroll-bar)
			  (margin-white-borders))
     :incremental-redisplay t
     :redisplay-function #'redisplay-run-history)
   ;;; this pane must be before results pane
   ;;; for header width to get recalculated correctly
   (results-headers
     :display
     :redisplay-function #'redisplay-headers
     :default-character-style '(:fix :roman :normal)
     :incremental-redisplay t)
   (results
     :display
     :blinker-deselected-visibility t
     :blinker-flavor 'tv:hollow-rectangular-blinker
     :margin-components '((margin-borders)
			  (margin-white-borders)
			  (margin-label :margin :bottom
					:style (:dutch :italic :normal)
					:string "Metering Results")
			  (margin-scroll-bar)
			  (margin-scroll-bar :margin :bottom)
			  (margin-white-borders))
     :default-character-style '(:fix :extra-condensed :normal)
     :typeout-window t
     :automatically-remove-typeout-window t
     :end-of-page-mode :truncate
     :incremental-redisplay t			;:limit-to-viewport
     :redisplay-function #'redisplay-results
     )
   )
  :configurations
  '((main
      (:layout
	(main :column row-1 command-menu interactor results-headers results)
	(row-1 :row title meter-history))
      (:sizes
	(main (row-1 4 :lines meter-history)
	      (command-menu :ask-window self :size-for-pane command-menu)
	      (interactor 8 :lines)
	      (results-headers 2 :lines)
	      :then
	      (results :even))
	(row-1 (title :ask-window self :size-for-pane title)
	       :then
	       (meter-history :even))))))



;;; Help interface

(dw:define-command-menu-handler ("Help" metering-interface :top-level
				 :gesture (:left :right)) ()
   `(dw:com-help))
		 
(defmethod (dw::map-command-menu-item-to-help-topic metering-interface) (string)
  (if (string-equal string "help")
      `("metering interface help command")
      `(,string "command")))


(defmethod (dw::map-command-name-to-help-topic metering-interface) (symbol)
  (format () "~@\\presentation\\ command"
	  symbol `((cp:command-name :command-table ,(dw:program-command-table self)))))

(defmethod (dw::map-program-name-to-help-topic metering-interface) (name)
  `(,name))

(cp:install-commands 'metering-interface
		     '(si:com-edit-definition si:com-report-bug tv:com-set-window-options
					      si:com-show-callers
					      dbg:com-show-compiled-code
					      dbg:com-show-function-arguments))

;;; snarfed from more-commands - only changed the default
(define-mi-command (com-clear-output-history)
    ((window 'dw:dynamic-window
	     ;; *terminal-io* is per-process, much better than tv:selected-window
	     ;; in the face of activity system activity.
	     :default (and (typep *query-io* 'dw:dynamic-window)
			   *query-io*))
     &key
     (keep-marked-text 'boolean :default t
		       :documentation "Don't remove anything that's underlined.")
     (keep-screenfuls 'integer :default 0 :mentioned-default 5
		      :prompt "number of screenfuls"
		      :documentation "Don't remove anything within the last few screenfuls.")
     (keep-all-text 'boolean :default nil :mentioned-default t
		    :documentation "Remove presentations and graphics, but not characters."))
   (send window :compress-output-history :marked-text (and keep-marked-text :keep)
	                                 :keep-screenfuls keep-screenfuls
					 :keep-all-text keep-all-text))

(define-mi-command (com-copy-output-history)
    ((destinations 'cp::destination :default nil)
     (source 'dw:dynamic-window :default (when (typep (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*query-io*0 'dw:dynamic-window)
					   2*query-io*0)
				:prompt "from window"))
   (cp::with-standard-output-bound destinations
     (dw::output-output-history-as-text source)))


(defmethod (make-instance metering-interface :after) (&rest ignore)
  ;; grossness to get the left margin on the headers
  ;; to be the same size as the left margin on the results
  (reset-default-output-fields-alist self))

;; is this the wrong place to do this disgusting kludge!  where is the right?
(defmethod (dw::after-program-frame-activation-handler metering-interface) (frame)
  (send (send frame :get-pane 'results-headers)
	:set-margin-components
	`((dw::margin-asymmetrical-borders
	    :left-thickness 0
	    :top-thickness 2
	    :right-thickness 0
	    :bottom-thickness 0)
	  (margin-whitespace :margin :top :thickness 4)
	  (margin-whitespace :margin :left
			     :thickness ,(send (send frame :get-pane 'results)
					       :left-margin-size)))))
					   
(defmethod (headers-window metering-interface) ()
  (get-program-pane 'results-headers))

(defmethod (results-window metering-interface) ()
  (get-program-pane 'results))

(defmethod (results-typeout-window metering-interface) ()
  (send (get-program-pane 'results) :typeout-window))

(define-presentation-type redisplay-history-p-blip ()
   :expander 'dw::window-wakeup)

(defmethod (top-level metering-interface) (&rest args)
  (declare (dbg:bug-report-recipient-system "Metering"))
  (unless metering:*metering-enabled*
    (metering:enable-metering-utility))
  (flavor:with-instance-environment (self env)	
    (apply #'default-command-top-level self 
	   :dispatch-mode :command-preferred
	   :keyboard-accelerators t
	   :unknown-accelerator-is-command t
	   :prompt #'si:arrow-prompt
	   :window-wakeup (lambda (blip)
			    (dw:presentation-blip-case blip
			      (dw::window-wakeup-viewport-position-changed
				(let ((window (presentation-blip-object blip)))
				  (when (eq window (get-program-pane 'results))
				    ;; Only bother when we scrolled in Y
				    (destructuring-bind (nil y)
					(dw:presentation-blip-options blip)
				      (when (and (not (null y)) current-run)
					(force-redisplay current-run t)
					(send dw:*program-frame* :redisplay-pane window)))
				    (let ((x-offset (send window :viewport-position)))
				      (send (get-program-pane 'results-headers)
					    :set-viewport-position x-offset 0)))))
			      (redisplay-history-p-blip
				(send dw:*program-frame* :redisplay-pane
				      (get-program-pane 'meter-history))))
			     (dw:help-program-check-for-help-wakeup blip))
	   :environment env
	   args)))


    

(define-presentation-type basic-metering-run ()
   :no-deftype t
   :history t
   :description "a metering run"
   :parser ((stream &key original-type initially-display-possibilities)
	    (values 
	      (dw:completing-from-suggestions (stream
						:partial-completers `(#\space)
						:type original-type
						:initially-display-possibilities
						initially-display-possibilities)
		(loop for run in *run-list*
		      do (dw:suggest (format nil "~:[~A~;~:*~A (~A)~]"
					     (metering-run-name run)
					     (metering-run-time run))
				     run)))))
   :printer ((run stream &key acceptably)
	     (when run
	       (presentation-printer run stream acceptably))))


(defmethod (redisplay-run-history metering-interface) (stream)
  (multiple-value-bind (ignore ignore right ignore)
      (send stream :visible-cursorpos-limits :character)
    (with-redisplayable-output (:stream stream :cache-value history-tick
					:unique-id 'runs)
      (let (current-run-y)
	(declare (special current-run-y))
	(loop for run in *run-list*
	      do (with-redisplayable-output (:stream stream :unique-id run
						     :cache-value (eq run current-run))
		   (when (eq run current-run)
		     (multiple-value-setq (nil current-run-y)
		       (send stream :read-cursorpos)))
		   (format stream "~C " (if (eq run current-run)
					    #\arrow:right-open-arrow
					    #\space))
		   (let ((*print-pretty* nil)
			 (*print-abbreviate-quote* 't))
		     (abbreviating-output (stream :width (- right 2) :height 1
						  :show-abbreviation t)
		       (if (eql run current-run)
			   (with-character-face (:bold stream)
			     (present run 'basic-metering-run :stream stream))
			   (present run 'basic-metering-run :stream stream)))))
		 (terpri stream)
	      finally (when current-run-y
			(ensure-y-visible stream current-run-y .5)))))))

(defun ensure-y-visible (stream y fraction)
  (multiple-value-bind (left top right bottom)
      (send stream :visible-cursorpos-limits)
    (ignore left right)
    (unless (and ( top y) (< y bottom))
      (let ((height (send stream :line-height)))
	(send stream :y-scroll-to
	      (max (- y (* (floor (* fraction (- bottom top)) height) height))
		   0)
	      :absolute)))))

(defmethod (redisplay-results metering-interface) (stream)
  (with-redisplayable-output (:stream stream :unique-id self)
    (if current-run
	(si:with-process-non-interactive-priority ()
	  (display-metering-results current-run stream
				    (send (headers-window self) :char-width)))
	(with-redisplayable-output (:stream stream :unique-id 'no-data :cache-value t)
	  (with-character-style ('(nil :italic :large) stream)
	    (if *run-list*
		(format stream
			"No run current.~%Use ~'b~@\\presentation\\~ to select a run to display."
			'show-metering-run 'cp:command-name)
		(format stream
			"There are no metering runs.~
                     ~%Use ~'b~@\\presentation\\~ or ~'b~@\\presentation\\~ to create one."
			'com-meter-form 'cp:command-name
			'com-meter-in-process 'cp:command-name)))))))

(defmethod (redisplay-headers metering-interface) (stream)
  (when current-run
    (display-headers current-run stream (send (results-window self) :char-width))))

(defmethod (make-run-current metering-interface) (run)
  (unless (eql run current-run)
    (delete-run run self t)
    (register-run run self)
    (setq current-run run)
    (initialize-display current-run self)
    ;; make sure the header pane isn't y scrolled
    ;; while we're at clean out the old gunk
    (send (dw:program-frame self) :clear-pane 'results-headers)
    (send (dw:program-frame self) :clear-pane 'results)))


(define-mi-command (com-scroll-window)
		((type '((member :screen :line :beginning :end :point-at-top))
		       :prompt "by" :default :screen)
		 (count 'integer :default +1 :prompt "repeat count")
		 (coordinate '((member :y :x)) :default :y))
  (let ((tv:*asynchronous-window-operation* t))
    (cp::scroll-window-command-internal type count coordinate (results-window self))))

(cp:define-command-accelerator scroll-window-forward-y "Metering-Interface" (#\Scroll)
			       (:echo nil) (numeric-arg-p numeric-arg)
  `(com-scroll-window
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :end)
	(otherwise :line))
     ,numeric-arg))

(cp:define-command-accelerator scroll-window-backward-y "Metering-Interface" (#\m-scroll)
			       (:echo nil) (numeric-arg-p numeric-arg)
  `(com-scroll-window
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(otherwise :line))
     ,(- numeric-arg)))

(cp:define-command-accelerator scroll-window-forward-x "Metering-Interface" (#\s-scroll)
			       (:echo nil) (numeric-arg-p numeric-arg)
  `(com-scroll-window
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :end)
	(otherwise :line))
     ,numeric-arg
     :x))

(cp:define-command-accelerator scroll-window-backward-x "Metering-Interface" (#\m-s-scroll)
			       (:echo nil) (numeric-arg-p numeric-arg)
  `(com-scroll-window
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(otherwise :line))
     ,(- numeric-arg)
     :x))


;;;; The metering-type function generics

(defvar *default-metering-type* :function-call)

(defvar *metering-environment* nil
  "When metering is in progress this is bound to the current run")

(defvar *metering-run-in-progress* nil
  "When metering is in progress this contains the current run")


(defmethod (warm-boot-reset metering-interface) ()
  (setq current-run nil))

(defun reset-metering-interface-state ()
  (when *metering-environment*
    (finalize-run *metering-environment* t))
  (setq *metering-environment* nil
	*metering-run-in-progress* nil)
  (let ((window (dw:find-program-window 'metering-interface :create-p nil)))
    (when window
      (warm-boot-reset (send window :program)))))

(add-initialization 'reset-metering-interface
		     `(reset-metering-interface-state)
		     '(:warm))


;;;; Define the metering types, and the methods on them
;;; metering runs contain both the information for the running of the metering
;;; and the "presentation" of the results
(defflavor basic-metering-run
	((form nil)
	 (compiled-form nil)			;if called from mi compiles form save for rerun
	 (metered-functions nil)
	 (start-and-stop nil)
	 (mode-lock-p nil)	 
	 time
	 (name nil)
	 (all-output-fields nil)
	 (output-fields nil)
	 (header-tick 0)
	 (display-locked nil)
	 collector
	 (count 1)
	 (region nil)
	 (control-with-switch nil)
	 control
	 (process *current-process*)
	 (without-interrupts nil)
	 (what-to-meter :everything)
	 (display-initialized nil)
	 (finalized nil))			; if this run is finalized don't re-finalize
	()
  (:initable-instance-variables form name compiled-form name count region process
				control-with-switch
				without-interrupts what-to-meter
				metered-functions start-and-stop mode-lock-p)
  :abstract-flavor
  (:conc-name metering-run-)
  (:readable-instance-variables form collector count name time control
				process metered-functions without-interrupts
				all-output-fields output-fields
				compiled-form finalized)
  (:writable-instance-variables display-locked)
  (:required-methods define-collector set-trigger set-generators
		     set-scope clear-scope finalize-run
		     display-metering-results metering-run-type metering-run-trigger))

(defmethod (make-instance basic-metering-run :after) (&rest ignore)
  (setq time (format nil "~\\datime\\"))
  (unless region
    (setq region (ecase what-to-meter
		   (:enabled 'with-metering-enabled-trigger)
		   (:functions
		     (if (= (length metered-functions) 1)
			 (first metered-functions)
			 `(or . ,metered-functions)))
		   (:everything (if (meter-process-style-metering self)
				    t
				    'with-metering-enabled-trigger))))))

(defmethod (presentation-printer basic-metering-run) (stream acceptably)
  (if acceptably
      (format stream "~:[~A~;~:*~A (~A)~]" name time)
      (format stream "Metering (~A) ~A ~@[~A ~]" time (metering-run-type self) name)
      (if (meter-process-style-metering self)
	  (multiple-value-call #'format stream
			       "in ~@\\presentation\\~@[~'i (~@\\presentation\\)~~]"
			       process 'si:process
			       (ecase what-to-meter
				 (:everything nil)
				 (:enabled (values what-to-meter 'what-to-meter))
				 (:functions (values metered-functions
						     '(sequence ((si:function-spec)))))))
	  (multiple-value-call
	    #'format stream
	    "~'i~:[No form recorded~;~:*~A~]~~
             ~@[ (~@\\presentation\\~@[ ~@\\presentation\\~])~]"
	    form
	    (ecase what-to-meter
	      (:everything nil)
	      (:enabled (values what-to-meter 'what-to-meter))
	      (:functions (values what-to-meter 'what-to-meter metered-functions
				  '(sequence ((si:function-spec))))))))))


(defmethod (print-short-form basic-metering-run) (stream)
  (format stream "~A Metering (~A)" (metering-run-type self) (or name time)))

(defmethod (meter-process-style-metering basic-metering-run) ()
  (not (null start-and-stop)))

(defmethod (metering-run-parameters basic-metering-run) ()
  (if (meter-process-style-metering self)
      `(,process ,(metering-run-type self) ,what-to-meter
	:metered-functions ,metered-functions 
	:start-and-stop ,start-and-stop
	:mode-lock-p ,mode-lock-p
	:name ,name)
      `(,form ,(metering-run-type self) ,what-to-meter
	:metered-functions ,metered-functions 
	:name ,name
	:count ,count :without-interrupts ,without-interrupts)))

(defmethod (clean-up-run-is-dead basic-metering-run) ()
  (setf collector nil
	output-fields nil
	all-output-fields nil
	compiled-form nil
	process nil
	control nil))

;;; this is the meaty one - each run gets called with initialize-run and finalize-run
(defmethod (initialize-run basic-metering-run) ()
  (initialize-collector self)
  (set-generators self)
  (set-trigger self)
  (do-pre-metering-stuff self)
  (set-scope self)
  (unless control-with-switch
    (set-control-switch-on control)))

(defmethod (set-scope basic-metering-run :after) ()
  (setf control
	(metering:trigger-control
	  (parse-trigger (metering-run-trigger self)))))
  
;;; *** this method is unnessary - eventually everyone should just define
;;;     an initialize-collector and eliminate define-collector ? ***
(defmethod (initialize-collector basic-metering-run) ()
  (setq collector (define-collector self)))

(defmethod (metering-run-type basic-metering-run) () nil)

(defmethod (reset-run basic-metering-run) ()
  (metering:reset-collector collector))
						    
(defmethod (do-pre-metering-stuff basic-metering-run) () nil)

(defmacro with-metering-enabled (&body body)
  `(process:without-preemption-if (and *metering-environment*
				       (metering-run-without-interrupts
					 *metering-environment*))
				  (meter-form (with-metering-enabled-trigger) ()
					      (progn ,@body))))

(defmethod (apply-function basic-metering-run) (function really-metering
							 explicitly-enable args)
  (if (and explicitly-enable really-metering)
      (with-metering-enabled
	(apply function args))
      (apply function args)))

(defmethod (finalize-run basic-metering-run :before) (abort-p)
  (ignore abort-p)
  (clear-scope self))

(defmethod (finalize-run basic-metering-run :after) (abort-p)
  (output-finish-message self abort-p)
  (let* ((mi-current (and (variable-boundp dw:*program*)
			  (typep dw:*program* 'metering-interface)
			  dw:*program*))
	 (mi-frame (dw:find-program-window 'metering-interface :create-p nil))
	 (mi (or mi-current
		 (and mi-frame (send mi-frame :program)))))
    (if abort-p
	(clean-up-run-is-dead self)
	(register-run self mi)
	(if mi-current
	    (make-run-current mi self)
	    (when mi-frame
	      (send (send mi-frame :get-pane 'interactor)
		    :force-kbd-input
		    (dw::make-presentation-blip :presentation-type 'redisplay-history-p-blip
						:object nil)))))))

(defwhopper (finalize-run basic-metering-run) (abort-p)
  (unless finalized
    (setq finalized t)
    (continue-whopper abort-p)))

(defmethod (output-finish-message basic-metering-run) (abort-p)
  (when (and (variable-boundp dw:*program*) (typep dw:*program* 'metering-interface))
    ;; don't want to present aborted run
    ;; otherwise it will never get gc'ed
    (let ((run-string (with-output-to-string (s)
			(format s "~@\\presentation\\" self 'basic-metering-run))))
      (if abort-p
	  (format t "~%Aborted ~A" run-string)
	  (when (send (results-typeout-window dw:*program*) :exposed-p)
	    (format t "~%Finished for ~A" run-string))))))

(defmethod (display-no-data-message basic-metering-run) (stream)
  (with-character-style ('(nil :italic :large) stream)
    (format stream
	    "No data for this run.~
             ~%Try Re-Metering changing some of the metering parameters.")))

(defwhopper (initialize-display basic-metering-run) (mi)
  (continue-whopper mi)
  (setq display-initialized t))

(defmethod (cleanup-for-temporary-disable basic-metering-run :default) ())
			       

(defgeneric describe-run (run stream)
  "Prints a description of the run to the stream"
  (:method-combination :progn :most-specific-last))

(defgeneric metering-run-parameters (run)
  "returns a list of keyword arguments to use as options for meter-form"
  (:method-combination :append :most-specific-last))

(defgeneric clean-up-run-is-dead (run)
  "Run is dead clear out useless slots to make sure they objects get garbage collected"
  (:method-combination :progn :most-specific-last))

(defgeneric define-collector (metering-run)
  "Defines a new collector on the metering type")

(defgeneric set-trigger (metering-run)
  "Initialize the trigger and collector for metering")

(defgeneric set-generators (metering-run)
  "Clear the triggers and attach the generators")

(defun parse-region (region)
  (and region (cond ((parse-trigger region :if-not-exists nil) region)
		    ((si:valid-function-definition region) `#',region)
		    ((and (listp region) (member (first region) '(or and not)))
		     `(,(first region) . ,(map 'list 'parse-region (rest region))))
		    (t nil))))

(defgeneric set-scope (metering-run)
  "Set the scope of the trigger")

(defgeneric clear-scope (metering-run)
  "Clear the scope of the trigger")

(defgeneric metering-run-trigger (metering-run)
  "Returns the trigger")

(defgeneric finalize-run (metering-run abort-p)
  "clear the scope of the trigger and other clean up")

(defgeneric cleanup-for-temporary-disable (run)
  "Cleanup data structures when we temporarily disable metering due to mode-lock, or function keys")


(defvar *all-output-fields-alist* nil "an alist of all the outfields for each run type")
(defvar *default-output-field-alist* nil
  "an alist of metering types and an ordered list of field names")

(defmacro do-program-windows (type (window-var) &body body)
  (let ((windows-so-far (gensym)))
    `(loop with ,windows-so-far = nil
	   for ,window-var = (dw:find-program-window ,type :create-p nil
						     :reuse-test
						     #'(lambda (window ignore)
							 (not (member window
								      ,windows-so-far))))
	   while ,window-var
	   do (push ,window-var ,windows-so-far)
	      (progn ,@body))))
					 
(defun delete-output-field-for-type (metering-type header)
  (let ((type-alist (assoc metering-type *all-output-fields-alist*))
	(type-default-alist (assoc metering-type *default-output-field-alist*)))
    (when type-default-alist
      (delete header (cdr type-default-alist) :test #'string-equal
	      :key #'(lambda (object) (if (listp object) (first object) object))))
    (when type-alist
      (setf (cdr type-alist)
	    (delete header (cdr type-alist)
		    :test #'string-equal :key #'field-header)))
    (do-program-windows 'metering-interface (window)
	(reset-default-output-fields-alist (send window :program)))))

(defun register-output-field-for-type (field metering-type)
  (let ((type-alist (assoc metering-type *all-output-fields-alist*)))
    (unless type-alist
      (setq type-alist (cons metering-type nil))
      (push type-alist *all-output-fields-alist*))
    (setf (cdr type-alist) (delete (field-header field) (cdr type-alist)
				   :test #'string-equal :key #'field-header))
    (push field (cdr type-alist)))
  (do-program-windows 'metering-interface (window)
    (reset-default-output-fields-alist (send window :program))))

(defun output-fields-for-metering-type (type)
  (cdr (assoc type *all-output-fields-alist*)))

;;; just the field names
(defmethod (metering-type-default-output-fields metering-interface) (metering-type)
  (cdr (assoc metering-type default-output-fields-alist)))

(defmethod (metering-type-all-output-fields metering-interface) (metering-type)
  (loop for field in (cdr (assoc metering-type *all-output-fields-alist*))
	collect (copy-self field)))


(3 0 (NIL 0) (NIL :BOLD :BIGGER) "BIGFNTB");;; some commands for metering runs

0;;; Various commands on runs
;;; select => show
;;;           change parameters - change display parameters
;;;           re-run 
;;;           delete
;;;           describe - fully print form and parameters

(define-presentation-type what-to-meter ()
   :abbreviation-for
   '(alist-member
      :alist
      (("Everything" :value :everything
	:documentation "Meter the whole form/process")
       ("Only when Enabled" :value :enabled
	:documentation
	"Only meter when dynamically within a mi:with-metering-enabled")
       ("Within Functions" :value :functions
	:documentation
	"Only meter when within any of the specified functions (see :metered functions)")))
   :describer ((stream &key plural-count)
	       (dw::presentation-string-pluralize "a condition" stream plural-count)
	       (write-string " under which metering happens" stream))
   :history t)

(defmethod (describe-run basic-metering-run) (stream)
  (if (meter-process-style-metering self)
      (format stream "~&~A Metering Run ~@[~S~] ~&~'iCreated:~ ~A ~&~'iProcess:~ ~A~
                      ~&~'iWhat was metered:~ ~@\\presentation\\~
                      ~:[~2*~;: ~'i~@\\presentation\\~~]~
                      ~&~'iOnly Meter when Mode Lock:~ ~:[No~;Yes~]"
	      (metering-run-type self)
	      name time process
	      what-to-meter
	      'what-to-meter
	      (eq what-to-meter :functions)
	      metered-functions '(sequence ((si:function-spec)))
	      mode-lock-p)  
      (format stream "~&~A Metering Run ~@[~S~] ~&~'iCreated:~ ~A ~&~'iForm:~ ~S~
                  ~&~'iWhat was metered:~ ~@\\presentation\\~
                  ~:[~2*~;: ~'i~@\\presentation\\~~]~
		  ~&~'iCount:~ ~D~&~'iProcess:~ ~A~
                  ~&~'iWithout Interrupts:~ ~:[No~;Yes~]"
	      (metering-run-type self)
	      name time form
	      what-to-meter 'what-to-meter (eq what-to-meter :functions) 
	      metered-functions '(sequence ((si:function-spec)))
	      count process without-interrupts)))

(define-mi-command (com-describe-metering-run :keyboard-accelerator (#\c-sh-d))
    ((run 'basic-metering-run :default current-run))
   (describe-run run *standard-output*))

(define-presentation-to-command-translator describe-metering-run
   (basic-metering-run
    :gesture :describe
    :documentation "Describe this run")
   (run)
  `(com-describe-metering-run1 0,run1)0)

(defvar *hardcopy* nil)

(defvar *graphics-stream-p* t)

(defvar *standard-output-style* '(:fix :extra-condensed :normal)
  "The style used when writing to a buffer.")

(define-mi-command (show-metering-run :provide-output-destination-keyword t
				      :menu-accelerator t)
		   ((display-run `basic-metering-run :default current-run))
  (setf (metering-run-display-locked display-run) nil)
  (if (eq (si:follow-syn-stream *standard-output*) (results-typeout-window self))
      (make-run-current self display-run)
      (if (not (operation-handled-p *standard-output* ':set-cursorpos))
	  (progn 
	    (format (results-typeout-window self)
		    "~%The output destination specified ~S does not support cursor motion"
		    ;; pretty gross
		    cp::.output-destination.)
	    (si:close-open-stream *standard-output* 't))
	  (let ((*graphics-stream-p* (graphics:graphics-stream-p *standard-output*))
		(continuation
		  (lambda (stream)
		    (with-character-style (*standard-output-style* stream)
		      (let ((char-width (send stream :char-width)))
			(with-character-style ('(nil :bold :large) stream)
			  (present display-run (type-of display-run) :stream stream)
			  (terpri stream)
			  (terpri stream))
			(display-headers display-run stream char-width)
			(terpri stream)
			(if (= char-width 1)
			    (format stream "~v@{-~}~%"
				    (total-headers-width display-run char-width char-width)
				    t)
			    (when *graphics-stream-p*
			      (graphics:with-room-for-graphics (stream nil
								       :fresh-line nil
								       :move-cursor t)
				(graphics:draw-line
				  0 0
				  (total-headers-width display-run char-width char-width) 0
				  :stream stream))))
			(send-if-handles stream :clear-rest-of-line)
			(display-metering-results display-run stream char-width))))))
	    (if (eql (send-if-handles *standard-output* :real-set-cursorpos)
		     :hardcopy)
		(multiple-value-bind (right bottom)
		    (dw:continuation-output-size continuation *standard-output*)
		  (multiple-value-bind (width height)
		      (send *standard-output* :inside-size)
		     ;;; this doesn't work
		    (send *standard-output* :set-title
			  (format nil "Metering (~A) ~A ~@[~A ~]"
				  (metering-run-time display-run)
				  (metering-run-type display-run)
				  (metering-run-name display-run)))
		    (setq width (ceiling right width)
			  height (ceiling bottom height))
		    (send *standard-output* :with-multiple-pages continuation
			  *standard-output*
			  width height)))
		(fresh-line *standard-output*)
		(funcall continuation *standard-output*))))))

(define-presentation-to-command-translator show-metering-results
   (basic-metering-run
    :gesture :select
    :documentation "Show the data for this run")
   (run)
  `(show-metering-run1 0,run1)0)

(define-mi-command (com-lock-results-display) ()
  (and current-run
       (setf (metering-run-display-locked current-run) t)))

(define-mi-command (com-unlock-results-display) ()
  (and current-run
       (setf (metering-run-display-locked current-run) nil)))

(define-mi-command (com-wipe-text :keyboard-accelerator (#\s-W #\m-W))
    ()
   (dw::kill-ring-push-marked-text (dw:get-program-pane 'results)))

(define-mi-command (com-re-meter :name "Re-Meter"
				 :menu-accelerator t
				 :keyboard-accelerator (#\c-m-R))
    ((run 'basic-metering-run :default current-run))
   (if (metering-run-form run)
       (let ((new-arguments
	       (cp:choose-command-arguments
		 (if (meter-process-style-metering run)
		     'com-meter-in-process
		     'com-meter-form)
		 :prompt
		 (format nil
			 "~'iRe run~ ~@\\presentation\\ ~'imodifying its parameters~"
			 run 'basic-metering-run)
		 :typeout-stream (results-typeout-window self)
		 :initial-arguments (metering-run-parameters run)
		 :start 0)))
	 (when new-arguments
	   (if (meter-process-style-metering run)
	       (let ((start-and-stop (getf (cdddr new-arguments) :start-and-stop))
		     (mode-lock-p (getf (cdddr new-arguments) :mode-lock-p)))
		 (apply #'meter-form-internal
			self
			:process (first new-arguments)
			:metering-type (second new-arguments)
			:what-to-meter (third new-arguments)
			:form `(funcall ,(function-for-start-and-stop-and-mode-lock
					   start-and-stop mode-lock-p)
					*metering-environment*)
			:count 1
			:control-with-switch t
			(cdddr new-arguments)))
	       (apply #'meter-form-internal
		      self
		      :form (first new-arguments)
		      :metering-type (second new-arguments)
		      :what-to-meter (third new-arguments)
		      (if (equal (first new-arguments)
				 (metering-run-form run))
			  `(:compiled-form ,(metering-run-compiled-form run)
			    ,@(cdddr new-arguments))
			  (cdddr new-arguments))))))
       (format t "~%This run ~A cannot be re-run it has no form." run)))

(define-presentation-to-command-translator re-meter
   (basic-metering-run
    :gesture :super-middle
    :tester ((run) (not (null (metering-run-form run))))
    :documentation "Re-meter modifying this run's parameters")
   (run)
  `(com-re-meter ,run))

(define-mi-command (com-set-display-options :menu-accelerator t) ((run 'basic-metering-run
								       :default current-run))
   (condition-bind ((si:abort (lambda (&rest ignore)
				(dw:remove-window-typeout-window
				  (results-window self) :prompt-p nil)
				nil)))
     (change-parameters run (results-typeout-window self)))
   (dw:remove-window-typeout-window (results-window self) :prompt-p nil))

(define-presentation-to-command-translator set-display-options
   (basic-metering-run
    :gesture :meta-left
    :documentation "Set Display Options")
   (run)
  (values `(com-set-display-options ,run) nil
	  :echo nil))

(defparameter *confirm-delete-of-runs* t
  "Whether or not deletes of runs are confirmed.")

(define-mi-command (com-delete-metering-run) ((runs '(sequence basic-metering-run)))
   (when (or (not *confirm-delete-of-runs*)
	     (accept 'boolean :stream *Standard-output*
		     :default t
		     :prompt
		     (let ((*print-pretty* nil)
			   (*print-abbreviate-quote* 't))
		       (if (null (cdr runs))
			   (format nil "Do you really want to delete~% ~@\\presentation\\?~%(Yes or No)"
				   (first runs)  'basic-metering-run)
			   (format nil "Do you really want to delete~% ~@\\presentation\\?~%(Yes or No)"
				   runs  '(sequence basic-metering-run))))))
     (loop for run in runs
	   do (when (eq run current-run) (setq current-run nil))
	      (delete-run run self))
     (when (null current-run)
       (make-run-current self (last-run)))))

(define-presentation-to-command-translator delete-metering-run
   (basic-metering-run
    :gesture :delete
    :documentation "Delete this metering run from the history")
   (run)
  `(com-delete-metering-run (,run)))


;;; sorting

(defstruct (sorting-option (:type list) (:conc-name sorting-option-) (:constructor nil))
  (name "")
  (field nil)
  (extractor nil)
  (predicate nil)
  (total nil))

(defvar *all-sorting-options-alist* nil "Sorting options for each of the types")

(defmacro define-sorting-options (metering-type options)
  `(define-sorting-options-function ',metering-type ,options))
  
(defun define-sorting-options-function (metering-type options)
  (flet ((register-options (type)
	   (setf *all-sorting-options-alist*
		 (remove type *all-sorting-options-alist* :key #'car))
	   (push (cons type options)
		 *all-sorting-options-alist*)))		 
    (if (listp metering-type)
	(loop for type in metering-type
	      do (register-options type))
	(register-options metering-type))))

(defun sorting-options-for-metering-type (metering-type)
  (cdr (assoc metering-type *all-sorting-options-alist*)))
							  
(define-presentation-type sorting-option ((metering-type))
   :no-deftype t
   :parser ((stream &key initially-display-possibilities original-type)
	    (values
	      (dw:complete-from-sequence (sorting-options-for-metering-type metering-type)
					 stream
					 :name-key #'sorting-option-name
					 :partial-completers `(#\space)
					 :type original-type
					 :initially-display-possibilities
					 initially-display-possibilities)))
   :choose-displayer
   ((stream object query-identifier &key original-type)
    (dw::accept-values-choose-from-sequence stream
					    (sorting-options-for-metering-type metering-type)
					    object
					    query-identifier
					    :type original-type))
   :printer ((option stream &key acceptably)
	     (if acceptably
		 (format stream "~S" (sorting-option-name option))
		 (format stream "~A" (sorting-option-name option))))
   :description "A sorting option")


;;; field stuff

;;; to do on fields
;;;  mouse commands for adding fields/sub-fields ; moving fields ?
;;;  add field can only add before
;;;   should no function must come last

;;; All the data can be represented as fields
   
(defflavor basic-output-field
	(header
	 header-pixel-width
	 documentation)
	()
  :abstract-flavor
  (:readable-instance-variables (field-header header) (field-documentation documentation)
				(field-header-pixel-width header-pixel-width))
  :initable-instance-variables)

(defmethod (sys:print-self basic-output-field) (stream depth slashify-p)
  (si:printing-random-object (self stream :typep)
    (princ header stream)))

(defflavor output-field-descriptor
	((run nil)
	 (sub-fields)
	 (current-sub-fields)
	 metering-component
	 (field-extractor-function nil)		;derived from metering-component
	 (cached-header-char-width)
	 (cached-data-char-width)
	 (excess-width)
	 (total-width)
	 sub-headers-left			;left most extent of sub-fields' header
	 sub-headers-right)
	(basic-output-field)
  (:readable-instance-variables (field-current-sub-fields current-sub-fields)
   (field-sub-fields sub-fields) (field-run run))
  (:writable-instance-variables (field-run run))
  (:initable-instance-variables sub-fields current-sub-fields metering-component)
  (:init-keywords :sub-field-descriptions :current-sub-field-names))


(defflavor output-sub-field-descriptor
	(write-function
	 width					;write function better obey width
	 main-field)
	(basic-output-field)
  :initable-instance-variables
  (:readable-instance-variables (sub-field-main-field main-field))
  (:writable-instance-variables (sub-field-main-field main-field)))

(defmethod (make-instance output-field-descriptor :after) (&key sub-field-descriptions
								current-sub-field-names
								&allow-other-keys)
  (unless sub-fields
    (setf sub-fields
	  (loop for sub-field-description in sub-field-descriptions
		collect (apply #'make-instance 'output-sub-field-descriptor
			       sub-field-description))))
  (unless current-sub-fields
    (setf current-sub-fields
	  (loop for name in current-sub-field-names
		for sub-field = (find name sub-fields :test #'string-equal :key #'field-header)
		if sub-field
		collect sub-field
		  else do (format t "~%The sub-field ~A is not defined on ~A" name self))))
  (loop for sub-field in sub-fields
	do (setf (sub-field-main-field sub-field) self)))

(defmethod (make-instance output-sub-field-descriptor :after) (&rest ignore)
  (setf write-function (eval write-function))
  (unless (compiled-function-p write-function)
    (setq write-function
	  (symbol-function (compile (gentemp (if header
						 (string-append "output-field-" header)
						 "output-field")
					     'mi)
				    write-function)))))

(defmethod (copy-self output-sub-field-descriptor) ()
  (make-instance 'output-sub-field-descriptor
		 :header header
		 :documentation documentation
		 :write-function write-function
		 :width width))

(defmethod (copy-self output-field-descriptor) ()
  (let ((new-sub-fields-alist (loop for sub-field in sub-fields
				    collect (cons sub-field (copy-self sub-field)))))
    (make-instance 'output-field-descriptor
		   :header header
		   :documentation documentation
		   :sub-fields (loop for (nil . new-sub-field) in new-sub-fields-alist
				     collect new-sub-field)
		   :current-sub-fields (loop for current-sub-field in current-sub-fields
					     collect (cdr (assoc current-sub-field
								 new-sub-fields-alist)))
		   :metering-component metering-component)))

;;; draws a horizontal bar of bar-width =  value/total * width
;;; width is in pixels;  the cursor is moved in :character's beyond the bar
;;; char-width is in pixels
(defun bar-graph (stream value total width)
  (let ((height (send stream :baseline))
	(x-value (* (min value total) (if (plusp total) (/ (float width) total) 1))))
    (graphics:with-room-for-graphics (stream height :fresh-line nil :move-cursor nil)
      (graphics:draw-rectangle 0 height
			       width 1
			       :stream stream
			       :filled t
			       :gray-level .05)
      (when (plusp value)
	(graphics:draw-rectangle 0 height
				 (if (> value total) width x-value) 1
				 :stream stream
				 :filled t
				 :gray-level (if (> value total) .3 .2))
	(graphics:draw-rectangle 0 height
				 x-value 1
				 :stream stream
				 :filled nil
				 :thickness 0)))))

(defvar *overflow-seperation* 4)

(defun distribution-graph (stream array width overflow)
  (let* ((height (send stream :baseline))
	 (max-value (max overflow
			 (loop for i being the array-elements of array maximize i)))
	 (scale (if (zerop max-value)
		    0
		    (/ (1- height) max-value))))
    (graphics:with-room-for-graphics (stream height :fresh-line nil :move-cursor nil)
      (let ((number-of-buckets (- width 2 (* 2 *overflow-seperation*))))
	(graphics:draw-line 0 1 number-of-buckets 1
			    :opaque nil :thickness 0 :stream stream)
	(graphics:draw-point (floor (float number-of-buckets) 2) 0 :stream stream)
	(loop for x from 0
	      for value being the array-elements of array
	      for y = (floor (* value scale))
	      do
	  (when (plusp y)
	    (graphics:draw-line x 1 x (1+ y) :stream stream :opaque nil :thickness 1)))
	(let ((scaled-overflow (floor (* scale overflow))))
	  (when (plusp (* scale overflow))	;don't test the floored value
	    (graphics:draw-line (+ number-of-buckets *overflow-seperation*) 1
				width 1
				:opaque nil :thickness 0 :stream stream)
	    (let ((overflow-position  (- width (1+ (floor *overflow-seperation* 2)))))
	      (graphics:draw-line overflow-position 1
				  overflow-position  (1+ scaled-overflow)
				  :stream stream :opaque nil :thickness 1))))))))

(defun graph-histogram-distribution (stream collector width)
  (let ((number-of-buckets (- width 2 (* 2 *overflow-seperation*))))
    (stack-let ((array (make-array number-of-buckets :initial-element 0)))
      (let* ((average (average collector))
	     (max-value (* 2 average))
	     (interval (/ (float max-value) number-of-buckets))
	     (overflow 0))
	(metering:map-over-histogram-buckets
	  collector
	  #'(lambda (bottom top count)
	      (let ((intensity (/ (float count) (1+ (- top bottom)))))
		(cond ((zerop interval) (incf (aref array (floor number-of-buckets 2))
					      count))
		      ((< top 0))
		      ((> bottom max-value) (incf overflow count))
		      (t
		       (when (< bottom 0) (setf bottom 0))
		       (when ( top max-value)
			 (incf overflow (* (- top max-value) intensity))
			 (setf top max-value))
		       (if (= top bottom)
			   (if (= top average)
			       ;; kludge to exactly center average value
			       (incf (aref array (floor number-of-buckets 2))
				     count)
			       (incf (aref array (min (floor bottom interval)
						      (1- number-of-buckets)))
				     count))
			   (let ((bottom-bucket (min (floor bottom interval)
						     (1- number-of-buckets)))
				 (top-bucket (min (floor top interval)
						  (1- number-of-buckets))))
			     (if (= bottom-bucket top-bucket)
				 (incf (aref array bottom-bucket)
				       count)
				 (incf (aref array bottom-bucket)
				       (* intensity (- interval (mod bottom interval))))
				 (loop with portion = (* interval intensity)
				       for bucket from (1+ bottom-bucket) below top-bucket
				       do (incf (aref array bucket) portion))
				 (incf (aref array top-bucket)
				       (* intensity (mod top interval)))))))))))
	(distribution-graph stream array width overflow)))))

(defun graph-histogram-weighted-distribution (stream collector width)
  (let ((number-of-buckets (- width 2 (* 2 *overflow-seperation*))))
    (stack-let ((array (make-array number-of-buckets :initial-element 0)))
      (let* ((average (average collector))
	     (max-value (* 2 average))
	     (interval (/ (float max-value) number-of-buckets))
	     (overflow 0))
	(macrolet ((avg (x y) `(/ (+ ,x ,y) 2))
		   (get-bucket-number (value)
		     `(min (floor ,value interval) (1- number-of-buckets))))
	  (unless (zerop interval)
	    (metering:map-over-histogram-buckets
	      collector
	      #'(lambda (bottom top count)
		  (let ((intensity (/ (float count) (1+ (- top bottom)))))
		    (cond ((< top 0))
			  ((> bottom max-value) (incf overflow (* count (avg bottom top))))
			  (t
			   (when (< bottom 0) (setf bottom 0))
			   (when ( top max-value)
			     (incf overflow (* (- top max-value) (avg top max-value)
					       intensity))
			     (setf top max-value))
			   (if (= top bottom)
			       (if (= top average)
				   (incf (aref array (floor number-of-buckets 2))
					 (* count bottom))
				   (incf (aref array (get-bucket-number bottom))
					 (* count bottom)))
			       (let ((bottom-bucket (get-bucket-number bottom))
				     (top-bucket (get-bucket-number top)))
				 (if (= bottom-bucket top-bucket)
				     (incf (aref array bottom-bucket)
					   (* count (avg bottom top)))
				     (let ((bucket-boundary (* (1+ bottom-bucket) interval)))
				       (incf (aref array bottom-bucket)
					     (* intensity (avg bucket-boundary bottom)
						(- interval (mod bottom interval))))
				       (loop with portion = (* interval intensity)
					     for bucket from (1+ bottom-bucket)
							below top-bucket
					     for average from (+ bucket-boundary
								 (/ interval 2))
							 by interval
					     do (incf (aref array bucket) (* portion average)))
				       (incf (aref array top-bucket)
					     (multiple-value-bind (floor rem)
						 (floor top interval)
					       (* intensity (avg top (* floor interval))
						  rem)))))))))))))
	  (distribution-graph stream array width overflow))))))


;; a helper macro so we don't blow out on 0 denominators.
(defmacro float0 (num den)
  `(let ((.den. ,den))
     (if (zerop .den.)
	 0.0
	 (float (/ ,num .den.)))))

(defmacro define-output-field (metering-component metering-run-type &body descriptions)
  (let* ((new-descriptions (copy-tree descriptions))
	 (sub-fields (getf new-descriptions :sub-field-descriptions)))
    `(progn ,@(loop for sub-field in sub-fields
		    for header = (getf sub-field :header)
		    for symbol = (gentemp (if header
					      (string-append "output-field-" header)
					      "output-field")
					  'mi)
		    for function-location = (member :write-function sub-field)
		    for function = (second function-location)
		    when (and (listp function) (eql (car function) 'lambda))
		      collect `(defun ,symbol ,@(cdr function))
		      and do (setf (second function-location) `(symbol-function ',symbol)))
	    ,(if (atom metering-run-type)
		 `(register-output-field-for-type
		    (apply #'make-instance
			   'output-field-descriptor
			   :metering-component ',metering-component
			   ',new-descriptions)
		    ',metering-run-type)
		 `(let ((new-field (apply #'make-instance 'output-field-descriptor
					  :metering-component ',metering-component
					  ',new-descriptions)))
		    ,@(loop for type in metering-run-type
			    collect `(register-output-field-for-type new-field ',type)))))))

(defmacro undefine-output-field (metering-component metering-run-type header)
  (ignore metering-component)
  (if (atom metering-run-type)
      `(delete-output-field-for-type ',metering-run-type ,header)
      `(progn
	 ,@(loop for type in metering-run-type
		 collect `(delete-output-field-for-type ',type ,header)))))

(defmacro define-default-output-fields (run-type &rest fields)
  `(register-default-output-fields ',run-type '(,@fields)))

(defun register-default-output-fields (run-type fields)
  (setq fields
	(loop with all-fields = (cdr (assoc run-type *all-output-fields-alist*))
	      for field in fields
	      for field-name = (if (listp field) (first field) field)
	      if (not (member field-name all-fields
			      :key #'field-header :test #'string-equal))
		do (cerror "Ignore this field"
			   "Field ~a of metering type ~a was not found"
			   field-name run-type)
	      else do (when (listp field)
			(setf (cdr field)
			      (loop with subfields = (field-sub-fields
						       (find field-name all-fields
							     :key #'field-header
							     :test #'string-equal))
				    for subfield-name in (cdr field)
				    if  (not (member subfield-name subfields
						     :key #'field-header
						     :test #'string-equal))
				      do (cerror "Ignore this subfield"
						 "Subfield ~a of field ~a of metering type ~a was not found"
						 subfield-name field-name run-type)
				    else collect subfield-name)))
		   and collect field))
  (setq *default-output-field-alist*
	(delete run-type *default-output-field-alist* :key #'first))
  (push (cons run-type fields) *default-output-field-alist*)
  (do-program-windows 'metering-interface 
		      (window)
    (reset-default-output-fields-alist (send window :program))))

(define-mi-command (com-set-default-output-fields-for-type)
    ((from-run 'basic-metering-run :prompt "Run to use for defaults" :default current-run))
   (register-default-output-fields
     (metering-run-type from-run)
     (loop for field in (metering-run-output-fields from-run)
	   collect (cons (field-header field)
			 (loop for current-sub-field in (field-current-sub-fields field)
			       collect (field-header current-sub-field))))))

(define-mi-command (com-set-output-fields-of-run-from-defaults)
    ((run 'basic-metering-run :prompt "Run to set" :default current-run))
   (set-output-fields-from-defaults run self)
   (force-redisplay run))

(define-presentation-to-command-translator set-output-fields-from-defaults
   (basic-metering-run
    :gesture nil
    :documentation "Set the output fields from the defaults for this type.")
   (run)
  (values `(com-set-output-fields-of-run-from-defaults ,run) nil
	  :echo nil))


;;; output fields stuff for basic-metering-run's

(defmethod (metering-run-field-descriptions basic-metering-run) ()
  (metering:collector-component-description collector))

(defmethod (initialize-display basic-metering-run :before) (mi)
  (unless output-fields
    (set-output-fields-from-defaults self mi)))

;;; force the headers to redisplay
(defmethod (force-redisplay basic-metering-run :after) (&optional (only-to-leaves nil))
  (unless only-to-leaves (incf header-tick)))

(defmethod (set-output-fields-from-defaults basic-metering-run) (mi)
  (setf all-output-fields (metering-type-all-output-fields mi (metering-run-type self)))
  (loop for output-field in all-output-fields
	do (setf (field-run output-field) self))
  (setf output-fields
	(loop for field-name in (metering-type-default-output-fields mi
								     (metering-run-type self))
	      for field = (find (if (listp field-name)
				    (first field-name)
				    field-name)
				all-output-fields
				:key #'field-header
				:test #'string-equal)
	      if field
		collect field
		and
		when (listp field-name)
		  do (set-current-sub-fields field (rest field-name))
	      else do nil
	      else do (cerror "Ignore this field"
			      "Field ~a of metering type ~a was not found"
			      field-name (metering-run-type self)))))



						       
(defparameter *number-of-inter-sub-field-spaces* 2)
(defparameter *number-of-inter-field-spaces* 4)

(defmethod (get-field output-field-descriptor) (run entry)
  (if field-extractor-function
      (funcall field-extractor-function entry)
      (when metering-component
	(setf field-extractor-function
	      (metering:get-component-extractor-from-components
		metering-component entry (metering-run-field-descriptions run)))
	(funcall field-extractor-function entry))))

(defmethod (sub-fields-changed output-field-descriptor) ()
  (setf excess-width nil
	total-width nil))

(defun output-field-descriptor-choices (run exists-p function)
  (declare (sys:downward-funarg function))
  (if (eql run '*)
      ;; this is probably never useful since the fields really must be copied
      (loop for (metering-type . fields) in *all-output-fields-alist*
	    do (loop for field in fields
		     do (funcall function (field-header field) field)))
      (cond ((eq exists-p '*)
	     (loop for field in (metering-run-all-output-fields run)
		   do (funcall function (field-header field) field)))
	    (exists-p
	     (loop for field in (metering-run-output-fields run)
		   do (funcall function (field-header field) field)))
	    (t (loop with existing = (metering-run-output-fields run)
		     for field in (metering-run-all-output-fields run)
		     unless (member field existing)
		       do (funcall function (field-header field) field))))))

(define-presentation-type output-field-descriptor ((&optional (run '*) (exists-p '*)))
   :no-deftype t
   :history t
   :data-arguments-are-disjoint nil
   :parser ((stream &key initially-display-possibilities original-type)
	    (values
	      (dw:completing-from-suggestions
		(stream :type original-type
			:initially-display-possibilities initially-display-possibilities)
		(output-field-descriptor-choices run exists-p #'dw:suggest))))
   :choose-displayer ((stream object query-identifier &key original-type)
		      (let ((choices nil))
			(output-field-descriptor-choices run exists-p
							 (lambda (key value)
							   (ignore key)
							   (push value choices)))
			(dw::accept-values-choose-from-sequence stream (nreverse choices)
								object
								query-identifier
								:type original-type)))
   :typep ((field)
	   (let ((type-run run)
		 (type-exists-p exists-p))
	     (let ((object-run (field-run field))
		   (object-exists-p (and type-run
					 (neq type-run '*)
					 (not (null (member field
							    (metering-run-output-fields
							      type-run)))))))
	       (and (or (eq type-run '*) (eq type-run object-run))
		    (or (eq type-exists-p '*)
			(eq type-exists-p object-exists-p))))))
   :presentation-subtypep
   ((subtype supertype)
    (dw:with-presentation-type-arguments (output-field-descriptor subtype)
      (let ((sub-run run)
	    (sub-exists-p exists-p))
	(dw:with-presentation-type-arguments (output-field-descriptor supertype)
	  (let ((super-run run)
		(super-exists-p exists-p))
	    (values (and (or (eql super-run '*) (eql sub-run super-run))
			 (or (eql super-exists-p '*)
			     (eql sub-exists-p super-exists-p)))
		    (and super-run sub-run)))))))
   :describer ((stream &key plural-count)
	       (cond ((and run (not (symbolp run)))
		      (cond ((eq exists-p '*)
			     (dw::presentation-string-pluralize "an output field"
								stream plural-count))
			    (exists-p
			     (dw::presentation-string-pluralize "a current output field"
								stream plural-count))
			    (t
			     (dw::presentation-string-pluralize "a non-current output field"
								stream plural-count)))
		      (write-string " of " stream)
		      (print-short-form run stream))
		     (t (dw::presentation-string-pluralize "an output field"
							   stream plural-count))))
   :printer ((field stream) (format stream "~A" (and field (field-header field)))))

(defun output-sub-field-descriptor-choices (field run exists-p function)
  (declare (sys:downward-funarg function))
  (ignore run)
  (when field
    (if (null exists-p)
	(loop with existing = (field-current-sub-fields field)
	      for sub-field in (field-sub-fields field)
	      unless (member sub-field existing)
		do (funcall function (field-header sub-field) sub-field))
	(if (eql exists-p '*)
	    (loop for sub-field in (field-sub-fields field)
		  do (funcall function (field-header sub-field) sub-field))
	    (loop for sub-field in (field-current-sub-fields field)
		  do (funcall function (field-header sub-field) sub-field))))))

(define-presentation-type output-sub-field-descriptor ((&optional field run (exists-p '*)))
   :no-deftype t
   :history t
   :data-arguments-are-disjoint nil
   :parser ((stream &key initially-display-possibilities original-type)
	    (values
	      (dw:completing-from-suggestions
		(stream :type original-type
			:initially-display-possibilities initially-display-possibilities)
		(output-sub-field-descriptor-choices field run exists-p #'dw:suggest))))
   :choose-displayer ((stream object query-identifier &key original-type)
		      (let ((choices nil))
			(output-sub-field-descriptor-choices field run exists-p
							     (lambda (key value)
							       (ignore key)
							       (push value choices)))
			(dw::accept-values-choose-from-sequence stream (nreverse choices)
								object
								query-identifier
								:type original-type)))   
   :typep
   ((sub-field)
    (let ((type-field field)
	  (type-run run)
	  (type-exists-p exists-p))
      (let* ((object-field (sub-field-main-field sub-field))
	     (object-run (and object-field (field-run object-field)))
	     (object-exists-p (and type-field
				   (not (null
					  (member sub-field
						  (field-current-sub-fields type-field)))))))
	(and (or (null type-run) (eq type-run object-run))
	     (or (null type-field)
		 (eq type-field object-field)
		 (string-equal (field-header type-field) (field-header object-field)))
	     (or (eq type-exists-p '*) (eq type-exists-p object-exists-p))))))
   :presentation-subtypep
   ((subtype supertype)
    (dw:with-presentation-type-arguments (output-sub-field-descriptor subtype)
      (let ((sub-field field)
	    (sub-run run)
	    (sub-exists-p exists-p))
	(dw:with-presentation-type-arguments (output-sub-field-descriptor supertype)
	  (let ((super-field field)
		(super-run run)
		(super-exists-p exists-p))
	    (values (and (eql sub-run super-run)
			 (eql sub-field super-field)
			 (or (eq super-exists-p '*) (eql sub-exists-p super-exists-p)))
		    (and super-field super-run sub-run sub-field)))))))
   :describer ((stream &key plural-count)
	       (cond (field
		      (cond ((eq exists-p '*)
			     (dw::presentation-string-pluralize "an sub field"
								stream plural-count))
			    (exists-p
			     (dw::presentation-string-pluralize "a current output sub field"
								stream plural-count))
			    (t
			     (dw::presentation-string-pluralize
			       "a non-current output sub field"
			       stream plural-count)))
		      (write-string " of " stream)
		      (present field 'output-field-descriptor :stream stream))
		     (t (dw::presentation-string-pluralize "an output sub field"
							   stream plural-count))))
   :printer ((sub-field stream) (format stream "~A" (and sub-field (field-header sub-field)))))

(define-presentation-type basic-output-field ()
   :no-deftype t
   :history nil
   :description "An output field"
   :printer ((sub-field stream) (format stream "~A" (field-header sub-field))))

(defwhopper (display-metering-results basic-metering-run) (stream header-char-width)
  (if display-locked
      (dw:with-redisplayable-output (:stream stream :unique-id 'display-locked
					     :cache-value display-locked)
	(with-character-style ('(nil :italic :large) stream)
	  (format stream
		  "Display locked.~%Use ")
	  (with-character-face (:bold stream)
	    (dw:with-output-as-presentation (:stream stream
					     :object `(com-unlock-results-display)
					     :type 'cp:command
					     :allow-sensitive-inferiors nil)
	      (present 'com-unlock-results-display 'cp:command-name :stream stream)))
	  (format stream " to update display.")))
      (continue-whopper stream header-char-width)))

(defmethod (display-metering-results basic-metering-run :before) (stream header-char-width)
  (loop with char-width = (send stream :char-width)
	for output-field in output-fields
	do (validate-cached-widths output-field header-char-width char-width)))



(defmethod (variable-width-p output-field-descriptor) ()
  (loop for sub-field in sub-fields thereis (variable-width-p sub-field)))
									  
(defmethod (variable-width-p output-sub-field-descriptor) ()
  (null width))

(defmethod (add-output-field basic-metering-run) (new-field before-field)
  (unless (eq (field-run new-field) self)
    (error "Adding field ~s to ~S which does not have the correct run."))
  (if (eq before-field (first output-fields))
      (push new-field output-fields)
      (if (null before-field)
	  (setf (cdr (last output-fields)) (cons new-field nil))
	  (loop for fields on output-fields
		when (eq (second fields) before-field)
		  do (setf (rest fields) (cons new-field (rest fields)))
		     (return)
		finally (cerror "make it the first field"
				"The field ~a was specified to come before ~a which is not an existing field"
				new-field before-field)
			(push new-field output-fields))))
  (force-redisplay self))

(define-mi-command (com-add-output-field)
    ((run 'basic-metering-run :default current-run)
     (new-field `(token-or-type (("Choose" . nil)) (output-field-descriptor ,run nil))
		:default nil
		:prompt "New field")
     (before-field (if (and new-field (variable-width-p new-field))
		       `(alist-member :alist (("Make this Last" . :last)
					      ("Choose" . nil)))
		       `(token-or-type (("Choose" . nil)) (output-field-descriptor ,run t)))
		   :default nil
		   :prompt "Before field"))
   (when (null new-field)
     (let ((choices nil))
       (output-field-descriptor-choices run nil
					(lambda (key field)
					  (push `(,key :value ,field
						  :documentation ,(field-documentation field))
						choices)))
       (setq new-field
	     (dw:menu-choose (nreverse choices) :prompt "Choose a new field"))))
   (when new-field
     (when (null before-field)
       (setq before-field
	     (if (variable-width-p new-field)
		 :last
		 (choose-output-field-location
		   (field-header-locations run
					   (send (headers-window self) :char-width)
					   (send (results-window self) :char-width))
		   (headers-window self)
		   new-field
		   "Add"))))
     (when before-field
       (add-output-field run new-field (if (eq before-field :last) nil before-field)))))

(defmethod (non-current-output-fields-p basic-metering-run) ()
  (> (length all-output-fields) (length output-fields)))

(define-presentation-to-command-translator add-output-field
   (basic-metering-run
    :gesture :control-meta-left
    :tester ((run)
	     (non-current-output-fields-p run))
    :documentation "Add an output field to this run")
   (run)
  (values `(com-add-output-field ,run nil nil) nil
	  :echo nil))

(defmethod (add-output-sub-field basic-metering-run) (field new-sub-field before-sub-field)
  (add-output-sub-field field new-sub-field before-sub-field)
  (force-redisplay self))

(defmethod (add-output-sub-field output-field-descriptor) (new-sub-field before-sub-field)
  ;;; *** is this necessary - how can you type an invalid one
  ;;;      how about point at other runs of same types fields?
  ;;;      same question applies below ***
  (unless (member new-sub-field sub-fields)
    (setf new-sub-field (find (field-header new-sub-field) sub-fields
			      :test #'string-equal :key #'field-header)))
  (if (eq before-sub-field (first current-sub-fields))
      (push new-sub-field current-sub-fields)
      (loop for some-sub-fields on current-sub-fields
	    when (eq (second some-sub-fields) before-sub-field)
	      do (setf (rest some-sub-fields) (cons new-sub-field (rest some-sub-fields)))
		 (return)
	    finally
	      (cerror "make it the first sub-field"
		      "The sub-field ~a was specified to come before ~a which is not an existing sub-field"
			    new-sub-field before-sub-field)
		    (push new-sub-field current-sub-fields)))
  (sub-fields-changed self))

;;; code for object-to-ignore assumes locations are ordered
;;; should we enforce this?
(defun choose-output-field-location (locations window new-output-field operation-description
				     &optional (object-to-ignore nil))
  (let (old-x old-object
	old-doc-string)
    (multiple-value-bind (ignore top ignore bottom)
	(send window :visible-cursorpos-limits)
      (unwind-protect 
	  (dw:tracking-mouse (window :whostate "Choose Location")
	    (:mouse-motion (x ignore)
	     (loop with best-distance = (when old-x (abs (- x old-x)))
		   with best-object = old-object
		   with best-location = old-x
		   for previous-object = nil then object
		   for (location-x . object) in locations
		   for distance = (abs (- x location-x))
		   when (and (not (and object-to-ignore
				       (or (eq object object-to-ignore)
					   (eq previous-object object-to-ignore))))
			     (or (null best-distance) (< distance best-distance)))
		     do (setq best-location location-x
			      best-distance distance
			      best-object object)
		   finally 
		     (unless (and old-x (= old-x best-location))
		       (when old-x
			 (graphics:draw-rectangle (- old-x 2) top (+ old-x 2) bottom
						  :gray-level .3
						  :stream window
						  :opaque nil
						  :alu :flip))
		       (setq old-x best-location
			     old-object best-object
			     old-doc-string (and best-location
						 (format nil "~A ~A   L: Before ~A   M: Abort"
							 operation-description
							 (field-header new-output-field)
							 (if (symbolp best-object)
							     "None"
							     (field-header best-object)))))
		       (graphics:draw-rectangle (- old-x 2) top (+ old-x 2) bottom
						:gray-level .3
						:stream window
						:opaque nil
						:alu :flip))))
	    (:who-line-documentation-string ()
					    old-doc-string)
	    (:mouse-click (button x y)
	     (ignore button x y)
	     (selector button char-mouse-equal
	       (#\mouse-l (return-from choose-output-field-location
			    (values old-object)))
	       (#\mouse-m (signal 'si:abort))
	       (otherwise (tv:beep)))))
	(when old-x
	  (graphics:draw-rectangle (- old-x 2) top (+ old-x 2) bottom
				   :gray-level .3
				   :stream window
				   :opaque nil
				   :alu :flip))))))

(define-mi-command (com-add-output-subfield)
    ((field `(output-field-descriptor ,current-run t)
	    :prompt "Main field")
     (new-sub-field
       `(token-or-type (("Choose" . nil))
		       (output-sub-field-descriptor ,field ,current-run nil))
       :prompt "New sub-field" :provide-default nil
       :default nil)
     (before-sub-field
       (if (and new-sub-field (variable-width-p new-sub-field))
	   `(alist-member :alist (("Make this Last" . :last)
				  ("Choose" . nil)))
	   `(token-or-type (("Make this Last" . :last) ("Choose" . nil))
			   (output-sub-field-descriptor ,field ,current-run t)))
       :prompt "Before sub-field"
       :provide-default nil))
   (when (null new-sub-field)
     (let ((choices nil))
       (output-sub-field-descriptor-choices field current-run nil
					    (lambda (key subfield)
					      (push `(,key :value ,subfield
						      :documentation
						      ,(field-documentation subfield))
						    choices)))
       (setq new-sub-field
	     (dw:menu-choose (nreverse choices)
			     :prompt "Choose a new sub field"))))
   (when new-sub-field
     (when (null before-sub-field)
       (setq before-sub-field
	     (if (variable-width-p new-sub-field)
		 :last
		 (choose-output-field-location
		   (sub-field-header-locations current-run field
					       (send (headers-window self) :char-width)
					       (send (results-window self) :char-width))
		   (headers-window self)
		   new-sub-field "Add"))))
     (when before-sub-field
       (add-output-sub-field current-run field new-sub-field
			     (if (eql before-sub-field :last)
				 nil
				 before-sub-field)))))

(defmethod (non-current-sub-fields-p output-field-descriptor) ()
  (> (length sub-fields) (length current-sub-fields)))

(define-presentation-to-command-translator add-output-subfield
   (output-field-descriptor
    :gesture :control-meta-left
    :tester ((field)
	     (non-current-sub-fields-p field))
    :documentation "Add a subfield to this field")
   (field &key presentation)
  (dw::with-inherited-presentation-type-arguments
      (output-field-descriptor (dw:presentation-type presentation) :error-p nil)
    (values `(com-add-output-subfield ,field nil nil1)0 nil
	    :echo nil)))


;;; moving fields
		 
(defmethod (number-of-movable-fields basic-metering-run) ()
  (loop for output-field in output-fields
	count (not (variable-width-p output-field))))

(defmethod (number-of-movable-subfields output-field-descriptor) ()
  (loop for subfield in current-sub-fields
	count (not (variable-width-p subfield))))

(define-mi-command (com-move-output-field) ((run 'basic-metering-run :default current-run)
					    (field
					     `(output-field-descriptor ,run t)
					     :default nil
					     :prompt "Field to move")
					   (before-field
					     `(null-or-type (output-field-descriptor ,run t))
					     :default nil
					     :prompt "Before field"))
   (when field
     (when (null before-field)
       (setq before-field
	     (choose-output-field-location
	       (field-header-locations run
				       (send (headers-window self) :char-width)
				       (send (results-window self) :char-width))
	       (headers-window self) field "Move" field)))
     (when before-field
       (delete-an-output-field run field)
       (add-output-field run field before-field))))

(define-presentation-to-command-translator move-output-field
   (output-field-descriptor
     :gesture :control-meta-middle
     :tester ((field) (and (not (variable-width-p field))
			   (field-run field)
			   (> (number-of-movable-fields (field-run field))
			      1)))
     :documentation "Move this output field")
   (field &key presentation)
  (dw::with-inherited-presentation-type-arguments
      (output-field-descriptor (dw:presentation-type presentation) :error-p nil)
    (values `(com-move-output-field ,run ,field nil) nil
	    :echo nil)))

(define-mi-command (com-move-output-subfield)
    ((field `(output-field-descriptor ,current-run t)
	    :prompt "Main field")
     (sub-field `(output-sub-field-descriptor ,field ,current-run t)
		:prompt "Subfield to move" :provide-default nil
		:default nil)
     (before-sub-field
       `(token-or-type (("Make this Last" . :last) ("Choose" . nil))
		       (output-sub-field-descriptor ,field ,current-run t))
       :prompt "Before subfield"
       :documentation "Move chosen subfield to before this subfield"
       :provide-default nil))
   (when sub-field
     (if (variable-width-p sub-field)
	 (format t "The ~A subfield cannot be moved." (field-header sub-field))
	 (when (null before-sub-field)
	   (setq before-sub-field
		 (choose-output-field-location
		   (sub-field-header-locations current-run field
					       (send (headers-window self) :char-width)
					       (send (results-window self) :char-width))
		   (headers-window self) sub-field "Move" sub-field)))
	 (when before-sub-field
	   (delete-sub-field field sub-field current-run t)       
	   (add-output-sub-field current-run field sub-field
				 (if (eql before-sub-field :last)
				     nil
				     before-sub-field))))))
						      
(define-presentation-to-command-translator move-output-subfield
   (output-sub-field-descriptor
    :gesture :control-meta-middle
    :tester ((subfield) (and (not (variable-width-p subfield))
			   (> (number-of-movable-subfields (sub-field-main-field subfield))
			      1)))
    :documentation "Move this subfield")
   (sub-field &key presentation)
  (dw::with-inherited-presentation-type-arguments
      (output-sub-field-descriptor (dw:presentation-type presentation) :error-p nil)
    (values `(com-move-output-subfield ,field ,sub-field nil) nil
	    :echo nil)))


;;; deleting fields
		   
(defmethod (delete-an-output-field basic-metering-run) (field)
  (setf output-fields (delete field output-fields))
  ;;; *** force recalculation isn't defined on basic-metering-run ***
  (force-redisplay self))

(defmethod (delete-sub-field output-field-descriptor) (sub-field run
								 &optional dont-delete-field)
  (setf current-sub-fields (delete sub-field current-sub-fields))
  (sub-fields-changed self)
  (when (and (null current-sub-fields) (not dont-delete-field))
    (delete-an-output-field run self))
  (force-redisplay run))

(define-mi-command (com-delete-output-field) ((field
						`(output-field-descriptor ,current-run t)))
   (when (or (not (variable-width-p field))
	     (accept 'boolean
		     :stream *standard-output*
		     :prompt (format nil
				     "Do you really want to delete the ~a field (Yes or No)"
				     (field-header field))
		     :default nil))
     (delete-an-output-field current-run field)))

(define-presentation-to-command-translator delete-output-field
   (output-field-descriptor
    :gesture :delete
    :documentation "Delete this field")
   (field &key presentation)
  (dw::with-inherited-presentation-type-arguments
      (output-field-descriptor (dw:presentation-type presentation) :error-p nil)
    `(com-delete-output-field ,field1)0))

(define-mi-command (com-delete-output-subfield) ((field
						   `(output-field-descriptor ,current-run t))
						  (sub-field
						    `(output-sub-field-descriptor
						       ,field ,current-run t)))
   (delete-sub-field field sub-field current-run))

(define-presentation-to-command-translator delete-output-subfield
   (output-sub-field-descriptor
    :gesture :delete
    :documentation "Delete this field")
   (sub-field &key presentation)
  (dw::with-inherited-presentation-type-arguments
      (output-sub-field-descriptor (dw:presentation-type presentation) :error-p nil)
    (values `(com-delete-output-subfield ,field ,sub-field1)0 nil
	    :echo nil)))



(defmethod (describe-self basic-output-field) (stream)
  (format stream "~A" (field-documentation self)))

(define-mi-command (com-describe-output-field) ((field
						  `(output-field-descriptor ,current-run *)))
   (describe-self field *standard-output*))

(define-presentation-to-command-translator describe-output-field
   (output-field-descriptor
     :gesture :describe
     :documentation "Describe this field")
   (field)
  (values `(com-describe-output-field ,field) nil
	  :echo nil))

(define-mi-command (com-describe-output-subfield) ((field
						     `(output-field-descriptor ,current-run *))
						   (sub-field
						     `(output-sub-field-descriptor ,field
										   ,current-run
										   *)))
   (ignore field)				;make the compiler happy its used in args
   (describe-self sub-field *standard-output*))

(define-presentation-to-command-translator describe-output-sub-field
   (output-sub-field-descriptor
     :gesture :describe
     :documentation "Describe this subfield")
   (sub-field &key presentation)
  (dw::with-inherited-presentation-type-arguments
      (output-sub-field-descriptor (dw:presentation-type presentation) :error-p nil)
    (values `(com-describe-output-subfield ,field ,sub-field) nil
	    :echo nil)))


(defun clipped-cache-value (our-top out-bottom viewport-top viewport-bottom cache-value)
  (if (and viewport-top
	   (or (> our-top viewport-bottom)
	       (< out-bottom viewport-top)))
      :clipped
      (if (or (null viewport-top)
	      (and ( our-top viewport-top)
		   ( out-bottom viewport-bottom)))
	  cache-value
	  :partially-clipped)))

(defun clipped-cache-test (old new)
  (or (eq new :clipped)
      (and (neq new :partially-clipped)
	   (eq new old))))


;;; output field width calculation

(defmethod (calculate-header-pixel-width basic-output-field) (header-char-width)
  (setf header-pixel-width
	(* header-char-width (string-length header))))

(defmethod (field-width output-field-descriptor) (char-width)
  (ignore char-width)
  total-width)

(defun-in-flavor (calculate-field-total-width output-field-descriptor) (header-char-width
									 data-char-width)
  (calculate-header-pixel-width self header-char-width)
  ;; recache sub fields
  (loop for sub-field in current-sub-fields
	do (calculate-header-pixel-width sub-field header-char-width))
  (let ((sub-field-widths 
	  (loop for sub-field in current-sub-fields
		for first first t then nil
		sum (+ (field-total-width sub-field data-char-width)
		       (if first 0 (* *number-of-inter-sub-field-spaces* data-char-width))))))
    (setf total-width (max header-pixel-width sub-field-widths)
	  excess-width (if (and (not (zerop sub-field-widths))
				(> header-pixel-width sub-field-widths))
			   (floor (- header-pixel-width sub-field-widths)
				  (loop for sub-field in current-sub-fields
					count ( (field-total-width sub-field data-char-width)
						 0)))
			   0)
	  cached-header-char-width header-char-width
	  cached-data-char-width data-char-width
	  sub-headers-left nil
	  sub-headers-right nil)
    (loop with (sub-left sub-right)
	  with position = 0
	  for first first t then nil
	  for sub-field in current-sub-fields
	  unless first
	    do (incf position (* *number-of-inter-sub-field-spaces* data-char-width))
	  do (multiple-value-setq (sub-left sub-right position)
	       (header-extent-and-field-end sub-field position excess-width
					    data-char-width))
	     (when sub-left
	       (if sub-headers-left
		   (setf sub-headers-left (min sub-headers-left sub-left))
		   (setf sub-headers-left  sub-left))
	       (if sub-headers-right
		   (setf sub-headers-right (max sub-headers-right sub-right))
		   (setf sub-headers-right  sub-right))))))

(defmethod (validate-cached-widths output-field-descriptor) (header-char-width data-char-width)
  (unless (and excess-width
	       (= cached-header-char-width header-char-width)
	       (= cached-data-char-width data-char-width))
    (calculate-field-total-width header-char-width data-char-width)))

(defmethod (header-extent-and-field-end output-sub-field-descriptor) (left excess-width
									   data-char-width)
  (let* ((field-total-width (field-total-width self data-char-width))
	 (total-width (+ field-total-width excess-width))
	 (header-left (+ left (- (+ field-total-width (floor excess-width 2))
				 header-pixel-width))))	;right justify - to field (not excess)
    (if (and (not *graphics-stream-p*) (eql (second width) :pixel))
	(values nil nil left)					;punt this field
	(values header-left (+ header-left header-pixel-width) (+ left total-width)))))

(defmethod (field-total-width output-sub-field-descriptor) (char-width)
  (if *graphics-stream-p*
      (max header-pixel-width
	   (if width
	       (ecase (second width)
		 (:character (* char-width (first width)))
		 (:pixel (first width)))
	       0))
      (if width
	  (ecase (second width)
	    (:character (max header-pixel-width (* char-width (first width))))
	    (:pixel 0))
	  ;; if there is null width then it isn't graphics and the width is the same as header
	  header-pixel-width)))

;;; output field locations - used when adding output fields

(defmethod (field-header-locations basic-metering-run) (header-char-width data-char-width)
  (loop with inter-field-distance = (* *number-of-inter-field-spaces* data-char-width)
	with location = data-char-width		;initial bogus space
	for first first t then nil
	for field in output-fields
	collect (cons location field)
	unless first do (incf location (floor inter-field-distance 2))
	do (validate-cached-widths field header-char-width data-char-width)
	   (incf location (+ (field-width field data-char-width)
			     (ceiling inter-field-distance 2)))))

(defmethod (sub-field-header-locations basic-metering-run) (field header-char-width
								  data-char-width)
  (loop with inter-field-distance = (* *number-of-inter-field-spaces* data-char-width)
	with location = data-char-width		;initial bogus space
	for first first t then nil
	for output-field in output-fields
	unless first do (incf location inter-field-distance)
	do (validate-cached-widths field header-char-width data-char-width)
	if (eql output-field field)
	  return (sub-field-header-locations field location header-char-width data-char-width)
	else do (incf location (field-width output-field data-char-width))))

(defmethod (sub-field-header-locations output-field-descriptor) (location header-char-width
									  data-char-width)
  (ignore header-char-width)
  (loop with inter-field-distance = (* *number-of-inter-sub-field-spaces* data-char-width)
	for first first t then nil
	for sub-field in current-sub-fields
	collect (cons location sub-field) into locations
	unless first do (incf location (floor inter-field-distance 2))
	do (multiple-value-setq (nil nil location)
	     (header-extent-and-field-end sub-field location excess-width data-char-width))
	   (incf location
		 (ceiling inter-field-distance 2))
	finally (return (values (cons (cons location :last) locations)))))

;;; this is used by show-metering-run
;;; this better be used with the caches correct
(defmethod (total-headers-width basic-metering-run) (header-char-width data-char-width)
  (ignore header-char-width)
  (+ (loop for first first t then nil
	   for field in output-fields
	   sum (field-width field data-char-width))
     (* (1- (length output-fields))
	(* *number-of-inter-field-spaces* data-char-width))
     data-char-width))


;;; actually display headers of output fields

(defmethod (display-headers basic-metering-run) (stream data-char-width)
  (let* ((header-char-width (send stream :char-width))
	 (inter-field-spacing (* *number-of-inter-field-spaces* data-char-width)))
    (flet ((kludge-write-space (stream)
	     ;; this junk is necessary to get around a rude bug
	     ;; in redisplayable output - the first thing in a with-redisplayable-output
	     ;; can't be a set-cursorpos
	     (cond ((= data-char-width header-char-width)
		    (write-char #\space stream))
		   ;; this must be to the screen !!! (see show-metering-run)
		   ((< header-char-width data-char-width)
		    (write-char #\space stream)
		    (send stream :set-cursorpos (- data-char-width header-char-width) 0))
		   ;; time for the real kludge
		   (t (write-char
			(make-character 
			  #\space
			  :style (send (send dw:*program-frame* :get-pane 'results)
				       :merged-current-style))
			stream)))))
      (with-redisplayable-output (:stream stream :cache-value header-tick
					  :unique-id self)
	(kludge-write-space stream)
	(with-output-as-presentation (:stream stream :object self :type 'basic-metering-run
					      :single-box t)
	  (loop for first first t then nil
		for field in output-fields
		unless first
		  do (multiple-value-bind (x y) (send stream :read-cursorpos)
		       (send stream :set-cursorpos (+ x inter-field-spacing) y))
		do (with-output-as-presentation (:stream stream
						 :object field
						 :type `(output-field-descriptor ,self t))
		     (write-field-header field stream header-char-width data-char-width)))
	  (terpri stream)
	  (kludge-write-space stream)
	  (loop 
	      for first first t then nil
	      for field in output-fields
	      unless first
		do (multiple-value-bind (x y) (send stream :read-cursorpos)
		     (send stream :set-cursorpos (+ x inter-field-spacing) y))
	      do (write-sub-field-headers field stream
					  header-char-width data-char-width)))))))

(defmethod (write-field-header output-field-descriptor) (stream header-char-width
								data-char-width)
  (validate-cached-widths self header-char-width data-char-width)
  (let* ((sub-headers-center (floor (+ sub-headers-left sub-headers-right) 2))
	 (header-width (* (string-length header) header-char-width))
	 (header-width-over-2 (floor header-width 2)))
    (if (< (- sub-headers-center header-width-over-2) 0)
	(incf sub-headers-center (- (- sub-headers-center header-width-over-2)))
	;; if it overhangs right push it left
	(when (> (+ sub-headers-center (- header-width header-width-over-2))
		 total-width)
	  (decf sub-headers-center
		(- (+ sub-headers-center (- header-width header-width-over-2))
		   total-width))))
    (multiple-value-bind (left top) (send stream :read-cursorpos)
      ;; if it overhangs left push it right
      (send stream :set-cursorpos
	    (+ left (- sub-headers-center header-width-over-2)) top)
      (write-string header stream)
      (send stream :set-cursorpos (+ left total-width) top))))

(defmethod (write-sub-field-headers output-field-descriptor) (stream header-char-width
								     data-char-width)
  (validate-cached-widths self header-char-width data-char-width)
  (loop with inter-sub-field-spacing = (* *number-of-inter-sub-field-spaces* data-char-width)
	for first first t then nil
	for sub-field in current-sub-fields
	unless first
	  do (multiple-value-bind (x y) (send stream :read-cursorpos)
	       (send stream :set-cursorpos (+ x inter-sub-field-spacing) y))
	do (with-output-as-presentation (:stream stream
					 :object sub-field
					 :type `(output-sub-field-descriptor ,self ,run t))
	     (write-field-header sub-field stream excess-width
				 header-char-width
				 data-char-width))))

(defmethod (write-field-header output-sub-field-descriptor) (stream excess-width
								    header-char-width
								    data-char-width)
  (ignore header-char-width)
  (unless (and (not *graphics-stream-p*) (eql (second width) :pixel))
    (multiple-value-bind (left top) (send stream :read-cursorpos)
      (multiple-value-bind (header-left nil field-right)
	  (header-extent-and-field-end self left excess-width data-char-width)
	(send stream :set-cursorpos header-left top)
	(write-string header stream)
	(send stream :set-cursorpos field-right top)))))


;;; display the fields themselves - this is called by various display-metering-results

;;; entry is all fields
(defmethod (write-sub-fields output-field-descriptor) (stream run entry key char-width)
  (when (null excess-width)
    (error "the header should have be redisplay first which would update the cache"))
  (let ((field-value (get-field self run entry)))
      ;;; if only we had dw:with-output-as-presentation-if
    (if field-value
	(dw:with-output-as-presentation (:single-box 't
					 :allow-sensitive-inferiors nil
					 :stream stream
					 :object field-value
					 :type `(field ,self ,key))
	  (loop for first first t then nil
		for sub-field in current-sub-fields
		unless first do (format stream "~v@t" *number-of-inter-sub-field-spaces*)
		do (write-field sub-field stream field-value run entry key
				excess-width char-width)))
	(loop for first first t then nil
	      for sub-field in current-sub-fields
	      unless first do (format stream "~v@t" *number-of-inter-sub-field-spaces*)
	      do (write-field sub-field stream field-value run entry key
			      excess-width char-width)))))

(defmethod (write-field output-sub-field-descriptor) (stream field-value run entry key
							     excess-width
							     char-width)
  (unless (and (not *graphics-stream-p*) (eql (second width) :pixel))
    (multiple-value-bind (left top) (send stream :read-cursorpos)
      (let ((pixel-width (+ (field-total-width self char-width) excess-width)))
	(send stream :set-cursorpos
	      (+ left (floor (- pixel-width
				(if width
				    (ecase (second width)
				      (:character (* char-width (first width)))
				      (:pixel (first width)))
				    0))
			     2))
	      top)
;      (dw:with-redisplayable-output  (:stream stream :unique-id self :cache-value t)
	(let ((si:*print-error-suppress* t))
	  (funcall write-function stream field-value run entry key))
;	)
	(when width
	  (send stream :set-cursorpos (+ left pixel-width) top))))))



;;; real field stuff - this is not output fields 
		
;;; *** a hack to work around a define-presentation-type bug***
;;; *** allows me to use :no-deftype t below
(defstruct (field (:copier nil)))		
		
(define-presentation-type field ((&optional output-field key))
   :no-deftype t
   :history nil
   :description "a metering result"
   :parser nil
   :printer ((field stream)
	     (ignore field)
	     (format stream "~A of ~A in ~A"
		     (field-header output-field) key (field-run output-field))))

(defmethod (get-entries-for-key basic-metering-run) (key)
  (collect-data-for-value collector key))

(defmethod (key-description basic-metering-run) (key) key)

(define-mi-command (com-expand-metering-data) ((run 'basic-metering-run :default current-run)
					       (output-field `(output-field-descriptor ,run *))
					       (key (metering-run-key-type run)
						    :provide-default nil))
   (format t "~%Description of ~A of ~@\\presentation\\ in Run ~A"
	   (field-header output-field)
	   (key-description run key) (metering-run-key-type run)
	   (metering-run-time run))
   (display-collector (get-field output-field run
				 (get-entries-for-key run key))))

(define-presentation-to-command-translator expand-metering-data
   (field
     :gesture :describe
     :documentation "Expand the data for this field")
   (field &key presentation)
  (ignore field)
  (dw::with-inherited-presentation-type-arguments
      (field (dw:presentation-type presentation) :error-p nil)
    (values `(com-expand-metering-data1 0,(field-run output-field) ,output-field ,key) nil
	    :echo nil)))




;;; *** what should this really do about non existing sub-fields ***
(defmethod (set-current-sub-fields output-field-descriptor) (sub-field-names)
  (setf current-sub-fields
	(loop for sub-field-name in sub-field-names
	      for sub-field = (find sub-field-name sub-fields
				    :key #'field-header :test #'string-equal)
	      when sub-field
		collect sub-field)))

(defmethod (reset-default-output-fields-alist metering-interface) ()
  (setf default-output-fields-alist (copy-tree *default-output-field-alist*)))



(defparameter *metering-run-flavors*
	      `((:function-call function-call-metering-run)
		(:statistical-function-call statistical-function-call-metering-run)
		(:call-tree call-tree-metering-run)
		(:statistical-call-tree statistical-call-tree-metering-run)
		(:page-fault page-trace-metering-run)
		(:statistical-program-counter pc-metering-run)))

(defun look-up-metering-run-flavor (type)
  (second (assoc type *metering-run-flavors*)))
    
(defparameter
  *basic-metering-types*
  `(("Function Call" :value :function-call
     :documentation
     "Collects data for every function call.  The data is indexed by the function.")
    ("Statistical Function Call" :value :statistical-function-call
     :documentation
     "Periodically samples data for the current function call of the metered process.")
    ("Call Tree" :value :call-tree
     :documentation
     "Collects data for every function call.  The data is indexed by the stack trace.")
    ("Statistical Call Tree" :value :statistical-call-tree
     :documentation
     "Periodically samples data for the current stack trace of the metered process.")
    ("Page Fault" :value :page-fault
     :documentation "Collects data relating to the paging system.")))

(defparameter *meter-form-metering-types* '())

;; since this depends on the type of system we are running, we can't do
;; this at compile time.
(add-initialization
  "initialize meter-form metering types"
  `(setf *meter-form-metering-types*
	 `(,@(when (meter:pc-metering-supported-p)
	       `(("Statistical Program Counter" :value :statistical-program-counter
		  :documentation
		  "Collects the percentage of time spent in functions.  It executes the form several times.")))))
  '(:cold :now))

(defparameter *meter-in-process-metering-types* `())

(define-presentation-type meter-form-metering-type ()
   :parser ((stream &key original-type initially-display-possibilities default-supplied
		    default default-type)
	    (let ((type `((alist-member :alist ,(append *basic-metering-types*
							*meter-form-metering-types*)))))
	      (values
		(if default-supplied
		    (accept type
			    :stream stream
			    :original-type (or original-type type)
			    :default default
			    :default-type (or default-type type)
			    :initially-display-possibilities initially-display-possibilities)
		    (accept type :stream stream :original-type (or original-type type)
			    :initially-display-possibilities initially-display-possibilities)))))
   :printer ((metering-type stream)
	     (princ (first (or (dw::item-from-menu-value metering-type
							 *basic-metering-types*)
			       (dw::item-from-menu-value metering-type
							 *meter-form-metering-types*)))
  		    stream))
   :description "a metering type"
   :history t)

(define-presentation-type meter-in-process-metering-type ()
   :abbreviation-for
   `((alist-member :alist ,(append *basic-metering-types*
				   *meter-in-process-metering-types*)))
   :description "a metering type"
   :history t)


;;; errors for metering run creation

(defflavor nested-metering-run
	(run)
	(error)
  :initable-instance-variables)

(defmethod (dbg:report nested-metering-run) (stream)
  (format stream "An attempt was made to create a new run while in the dynamic scope ~
                  of an existing run ~S" run))

(defflavor another-metering-run-is-in-progress
	(run)
	(error)
  :initable-instance-variables)

(defmethod (dbg:report another-metering-run-is-in-progress) (stream)
  (format stream
	  "An attempt was made to create a new metering run while another run (~S) ~
           was in progess." run))

(defmethod (sys:proceed another-metering-run-is-in-progress :abort-other-run) ()
  "Abort the other run discarding its data."
  (finalize-run run t)
  (setq *metering-run-in-progress* nil)
  (values :aborted run))


(defmacro with-new-metering-run-internal (options &body body)
  `(progn
     (when (not (null *metering-environment*))
       (error 'nested-metering-run :run *metering-environment*))
     (when (not (null *metering-run-in-progress*))
       (signal 'another-metering-run-is-in-progress :run *metering-run-in-progress*))
     (let ((*metering-environment*
	     (let ((.metering-run-options. ,options))
	       (apply #'make-instance
		      (look-up-metering-run-flavor
			(or (getf .metering-run-options. :metering-type)
			    *default-metering-type*))
		      (si:rem-keywords .metering-run-options. '(:metering-type))))))
       (dbg:catch-error-restart-command ((error) "Abort this run discarding its data")
	   (finalize-run *metering-environment* t)
	 (dbg:with-debugger-special-command ((error) "Disable metering for this run")
	     (clear-scope *metering-environment*)
	   (condition-bind ((sys:abort (lambda (error)
					 (ignore error)
					 (clear-scope *metering-environment*)
					 (finalize-run *metering-environment* t)
					 nil)))
	     (unwind-protect	 
		 (progn (setq *metering-run-in-progress* *metering-environment*)
			(initialize-run *metering-environment*)
			,@body)
	       (finalize-run *metering-environment*
			     (not (eq *metering-run-in-progress*
				      *metering-environment*)))
	       (setq *metering-run-in-progress* nil))))))))

(defmacro with-new-metering-run (options &body body)
  (declare (arglist ((&key metering-type
			   name
			   process
			   without-interrupts)
		     &body body)))
  `(with-new-metering-run-internal (list ,@options)
     . ,body))

(define-presentation-type repeat-count ()
   :abbreviation-for '((integer 1 *))
   :description "A number of trials"
   :history t)

(define-mi-command (com-meter-form :menu-accelerator t)
    ((form 'sys:expression
	   :prompt "form to meter"
	   :confirm t)
     (metering-type 'meter-form-metering-type)
     (what-to-meter
       'what-to-meter
       :prompt "What to meter"
       :documentation
       "Under what conditions metering should happen.")
     &key
     (metered-functions '(sequence ((si:function-spec :defined-p t)))
			:documentation "Meter while within any of these functions"
			:when (eq what-to-meter :functions))
     (name '(null-or-type string) :default nil
	   :prompt "A name for this run"
	   :documentation "A name to be used when printing and describing this run")
     (without-interrupts
       'boolean :default nil :mentioned-default t
       :prompt "Meter inside a without-interrupts (this can be dangerous)"
       :when (not (or (eq metering-type :statistical-call-tree)
		      (eq metering-type :statistical-function-call)))
       :documentation
       "Execute the form inside a without-interrupts (this can be dangerous)")
     (count 'repeat-count :prompt "N trials"
	    :default (or (dw:presentation-type-default 'repeat-count) 1)
	    :documentation
	    "Execute the form count-1 times before collecting data")
     (initially-flush-all-pages 'boolean :default nil :mentioned-default t
				:when (eq metering-type :page-fault))
     (sampling-interval (if (eq metering-type :statistical-program-counter)
			    `(number (2e-5) 1)
			    '(number #,(/ 1 60)))
			:default (if (and (eq metering-type :statistical-program-counter)
					  (meter:pc-metering-sampling-rate-control-p))
				     (/ 1s0 (meter:pc-metering-sampling-rate))
				     (/ 1 30))
			:prompt "Seconds between samples"
			:documentation
			"The approximate time interval between samples (in seconds)"
			:when (or (eq metering-type :statistical-call-tree)
				  (eq metering-type :statistical-function-call)
				  (and (eq metering-type :statistical-program-counter)
				       (meter:pc-metering-sampling-rate-control-p))))
     (resolution-percentage '((number (0) 100))
			    :prompt "Expand peaks above percentage"
			    :default .5
			    :when (eql metering-type :statistical-program-counter))
     )
   (apply #'meter-form-internal
	  self
	  :form form
	  :metering-type metering-type
	  :what-to-meter what-to-meter
	  :metered-functions metered-functions
	  :name name
	  :without-interrupts without-interrupts
	  :count count
	  `(,@(when (eq metering-type :page-fault)
		`(:initially-flush-all-pages ,initially-flush-all-pages))
	    ,@(when (eq metering-type :statistical-program-counter)
		`(:resolution-percentage ,resolution-percentage))
	    ,@(when (or (eq metering-type :statistical-call-tree)
			(eq metering-type :statistical-function-call)
			(and (eq metering-type :statistical-program-counter)
			     (meter:pc-metering-sampling-rate-control-p)))
		`(:sampling-interval ,sampling-interval)))))
   
(defun form-needs-compiling? (form)
  (and (listp form)
       (let ((function (car form))
	     (args (cdr form)))
	 ;; is the "function" something we can't just call?
	 (or (not (symbolp function))
	     (not (fdefinedp function))
	     (special-form-p function)
	     (macro-function function)
	     ;; function is OK, but maybe the args need EVALing:
	     (some #'(lambda (arg)
		       ;; if args are symbols the evaluation must happen when the function
		       ;; is apply'ed -> the form must be compiled
		       ;;  (or else we would meter the evals)
		       (not (or #||(symbolp arg)||# (constantp arg))))
		   args)))))

(defun function-and-args-to-apply (form options)
  (declare (values function args new-options))
  (let ((compiled-function (getf options :compiled-form)))
    (cond (compiled-function (values compiled-function nil options))
	  ((atom form) (values #'eval (list form) options))
	  ((form-needs-compiling? form)
	   (let* ((tick compiler:new-compiler-warnings-tick)
		  (compiled-function (symbol-function (compile (gentemp "Metered-form" 'mi)
							      `(lambda () ,form)))))
	     (when (and ( tick compiler:new-compiler-warnings-tick)
			(not (accept 'boolean
				     :prompt
				     "There are compiler warnings for the form.  Do you still want to meter the form? (Yes or No)"
				     :stream *standard-output*
				     :default nil)))
	       (signal 'sys:abort))
	     (setf options (si:rem-keywords options '(:compiled-form)))
	     (push compiled-function options)
	     (push :compiled-form options)
	     (values compiled-function nil options)))
	  (t (values (car form) (mapcar #'eval (cdr form)) options)))))

(defun meter-form-internal (metering-interface &rest options)   
  (ignore metering-interface)
  (let ((count (getf options :count))
	(only-when-enabled (eq (getf options :what-to-meter) :enabled)))
    (multiple-value-bind (function args new-options)
	(function-and-args-to-apply (getf options :form) options)
      (when (null function)
	(cerror "Meter nil" "The form was not recorded (or was nil)")) 
      (with-new-metering-run-internal new-options
	(loop for iter below count
	      for first first t then nil
	      if only-when-enabled
		do ;; if we can't control metering we must reset between each run
		   ;; we could disable metering in other ways
		   ;; thereby avoiding reseting... but for now
		  (unless first (reset-run *metering-environment*))
		  (apply-function *metering-environment* function (= iter (1- count))
				  nil args)
	      else do ;; if we can control metering - only meter the final time
		     (apply-function *metering-environment* function
				     (= iter (1- count)) t args))))))



(defparameter *mode-lock-polling-sleep-interval* .5)

(defun function-for-start-and-stop-and-mode-lock (start-and-stop mode-lock-p)
  (flet ((until-avv-end-or-abort (run)
	   (if mode-lock-p
	       (process-run-function "Enabling metering on mode lock"
		 #'(lambda (run)
		     (tv:noting-progress-alterable-note ("Metering Disabled")
		       (loop with control = (metering-run-control run)
			     with switch = nil
			     until (or (neq  *metering-run-in-progress* run)
				       (metering-run-finalized run))
			     do (when (neq (tv:key-state :mode-lock) switch)
				  (if switch
				      (progn (set-control-switch-off control :all t)
					     (cleanup-for-temporary-disable run)
					     (tv:format-progress-note nil "Metering Disabled"))
				      (progn
					(set-control-switch-on control)
					(tv:format-progress-note
					  nil
					  "Metering Enabled in Process ~A"
					  (metering-run-process run))))
				  (setf switch (not switch)))
				(sleep *mode-lock-polling-sleep-interval*))))
		 run)
	       (set-control-switch-on (metering-run-control *metering-environment*)))
	   (with-character-size (:normal)
	     (format t "~%~@\\presentation\\ in progress.~%~
                        ~@[~%Depress Mode Lock to enable metering~%~]"
		     *metering-environment* 'basic-metering-run mode-lock-p)
	     (tv:noting-progress-if (not mode-lock-p)
		 ((format nil "Metering in Process ~A" (metering-run-process run)))
	       (with-character-face (:bold)
		 (when (eql
			 (accept '(alist-member
				    :alist
				    (("Yes" :value t
				      :documentation 1"Complete the metering normally."0)
				     ("Abort" :value :abort
				      :documentation 1"Abort the metering discarding data."0)))
				 :stream *standard-output*
				 :prompt "Complete the metering now?"
				 :default t
				 :initially-display-possibilities t)
			 :abort)
		   (signal 'si:abort))))))
	 (function-keys (run)
	   (let ((start-metering nil)
		 (finish-metering nil)
		 (enabled nil))
	     (tv:add-function-key
	       #\(
	       #'(lambda (ignore)
		   (setf tv:*function-keys*
			 (delete (assoc #\( tv:*function-keys*) tv:*function-keys*)
			 start-metering t)
		   (tv:add-function-key
		     #\)
		     #'(lambda (ignore)
			 (unless (neq run *metering-run-in-progress*)
			   (set-control-switch-off (metering-run-control run) :all t)
			   (delete (assoc #\) tv:*function-keys*) tv:*function-keys*)
			   (setf finish-metering t)))
		     "Finish metering"
		     :process '(:priority 4))
		   (if mode-lock-p
		       (process-run-function "Enabling metering on mode lock"
			 #'(lambda (run)
			     (loop with control = (metering-run-control run)
				   until (or finish-metering
					     (neq run *metering-run-in-progress*)
					     (metering-run-finalized run))
				   do (when (neq (tv:key-state :mode-lock) enabled)
					(if enabled
					    (set-control-switch-off control :all t)
					    (set-control-switch-on control))
					(setf enabled (not enabled)))
				      (sleep *mode-lock-polling-sleep-interval*)))
			 run)
		       (set-control-switch-on (metering-run-control run))
		       (setf enabled t)))
	       "Start Metering"
	       :process '(:priority 4))
	     (with-character-size (:large)
	       (format t "~%~@\\presentation\\ in progress.~%~
                          ~@[~%Depress Mode Lock to enable metering~%~]
                          ~%2Function-( starts metering and Function-) ends.0"
		       *metering-environment* 'basic-metering-run mode-lock-p))
	     (tv:noting-progress-alterable-note ("Metering Waiting to Start")
	       (loop with metering-state = nil
		     until (or finish-metering
			       ;; be careful of warm boots
			       (neq *metering-environment* run)
			       (metering-run-finalized run))
		     when (and (null metering-state)
			       start-metering)
		       do (if mode-lock-p
			      (progn (setf metering-state :disabled)
				     (tv:format-progress-note nil "Metering Disabled"))
			      (progn (setf metering-state :started)
				     (tv:format-progress-note
				       nil "Metering Started in Process ~A"
				       (metering-run-process run))))
		     when (and (not (eql metering-state :finished))
			       finish-metering)
		       do (setf metering-state :finished)
			  (tv:format-progress-note nil "Metering Finished")
		     when (and mode-lock-p
			       enabled
			       (eql metering-state :disabled))
		       do (setf metering-state :enabled)
			  (tv:format-progress-note nil
						   "Metering Enabled in Process ~A"
						   (metering-run-process run))
		     when (and mode-lock-p
			       (not enabled)
			       (eql metering-state :enabled))
		       do (setf metering-state :disabled)
			  (tv:format-progress-note nil "Metering Disabled")
		     do (sleep 1))))))
    (ecase start-and-stop
      (:avv #'until-avv-end-or-abort)
      (:function-keys #'function-keys))))

(define-mi-command (com-meter-in-process :menu-accelerator t)
    ((process 'si:process
	      :prompt "Meter only in process"
	      :confirm t
	      :documentation "Only meter in this process")
     (metering-type 'meter-in-process-metering-type
		    :documentation "The style of metering to use")
     (what-to-meter
       'what-to-meter
       :prompt "What to meter"
       :documentation
       "Under what conditions metering should happen.")
     &key
     (metered-functions '(sequence ((si:function-spec :defined-p t)))
			:documentation "Meter while within any of these functions"
			:when (eq what-to-meter :functions))
     (start-and-stop `(alist-member
			:alist
			(("Until End chosen" :value :avv
			  :documentation
			  "Start metering immediately Stop or Abort using menu")
			 ("Function keys" :value :function-keys
			  :documentation
			  "Function-( starts metering and Function-) ends metering")))
		     :default :avv
		     :prompt "Method of Starting and Stopping"
		     :documentation "A method of starting and ending metering")
     (mode-lock-p 'boolean :default nil :mentioned-default t
		  :prompt "Only meter while Mode Locked"
		  :documentation "Only meter while mode lock key is depressed")
     (name '(null-or-type string) :default nil
	   :prompt "A name for this run"
	   :documentation "A name to be used when printing and describing this run")
     (initially-flush-all-pages 'boolean :default nil :mentioned-default t
				:when (eq metering-type :page-fault))
     (sampling-interval '(number #,(/ 1 60))
			:default (/ 1 30)
			:prompt "Seconds between samples"
			:documentation
			"The approximate time interval between samples (in seconds)"
			:when (or (eq metering-type :statistical-call-tree)
				  (eq metering-type :statistical-function-call))))
   (apply #'meter-form-internal
	  self
	  :form `(funcall ,(function-for-start-and-stop-and-mode-lock start-and-stop
								      mode-lock-p)
			  *metering-environment*)
	  :what-to-meter what-to-meter
	  ;; save these for printing/describing and for rerunning
	  :metered-functions metered-functions
	  :start-and-stop start-and-stop
	  :mode-lock-p mode-lock-p
	  :control-with-switch t
	  :metering-type metering-type
	  :name name
	  :without-interrupts nil
	  :count 1
	  :process process
	  `(,@(when (eq metering-type :page-fault)
		`(:initially-flush-all-pages ,initially-flush-all-pages))
	    ,@(when (or (eq metering-type :statistical-call-tree)
			(eq metering-type :statistical-function-call))
		`(:sampling-interval ,sampling-interval)))))
