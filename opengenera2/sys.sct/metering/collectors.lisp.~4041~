;;; -*- Mode: LISP; Syntax: Common-lisp; Package: METERING; Base: 10 Patch-file: T; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; some simple, basic collectors

;;; display data to a stream.  This can be used for a trace-like facility.

(defcollector display ((&rest args) ((args sys:expression)))
  ((stream t))
  ()
  (:init-options-and-types (&key ((stream t) metering-stream "stream to display on")))
  :initable-instance-variables)

(defmethod (collect-data display) (name &rest data)
  (format stream "~&~S: ~S" name data))

(defmethod (get-form-to-collect-data display) (instance &key args for-value)
  (declare (values form instance bindings))
  (if for-value
      (error "cannot build a hierarchical collector out of DISPLAY.")
      (if (eq instance ':constant)
	  (let ((instance-name (gensym "INSTANCE"))
		(stream (gensym "STREAM"))
		(format-cmds (with-output-to-string (s)
			       (format s "~~&")
			       (loop for arg in args
				     do (if (constantp arg)
					    (format s "~A " arg)
					    (format s "~~S "))))))
	    (values `(format ,stream ,format-cmds ,@(remove-if #'constantp args))
		    instance-name
		    `((,stream (si:eval-in-instance ,instance-name 'stream)))))
	  (values `(collect-data ,instance ,@args) nil nil))))

;; unnecesary, except to generate better error message.
(defmethod (wire-for-aux-stack display) ()
  (error "You cannot wire a display collector."))

(defmethod (unwire display) ()
  ;; This we know for sure.
  (error "Display was never wired for the aux stack."))

(defresource displaying-collectors (&rest init-options)
  :constructor (apply #'make-instance 'display init-options)
  :checker (progn (ignore object in-use-p) 't))

(defun make-display (&rest init-options)
  (values (apply #'allocate-resource 'displaying-collectors init-options)))

(setf (get 'display 'make-collector) #'make-display)
(defmethod (combine display) (combinee)
  (ignore combinee)
  (values))

(defmethod (optimize-combine display) (combinee)
  (ignore combinee)
  't)



;;;; ignore the value.  Treated specially by the code that displays metering status.

(defcollector ignore ((&rest args) ((args sys:expression "Ignore value" :value))) () ())

(defmethod (get-form-to-collect-data ignore) (instance &key args for-value)
  (declare (values form instance bindings))
  (if for-value
      (error "cannot build a hierarchical collector out of IGNORE.")
      (if (eq instance ':constant)
	  (let ((instance-name (gensym "INSTANCE")))
	    (values `(ignore ,@args) instance-name nil))
	  (values `(ignore ,instance ,@args) nil nil))))

(defmethod (collect-data ignore) (&rest data)
  (ignore data))

(defmethod (wire-for-aux-stack ignore) ()
  ;; trivially done.
  )

(defmethod (unwire ignore) ())

;; and just as trivially
(defmethod (get-form-to-collect-wired-data ignore) (instance &key args for-value)
  (declare (values form instance bindings))
  (get-form-to-collect-data self instance :args args :for-value for-value))

(let ((ignorer (make-data-collector 'ignore)))
  (setf (get 'ignore 'make-collector)
	#'(lambda (&rest ignore) ignorer)))


(defmethod (optimize-combine ignore) (combinee)
  (ignore combinee)
  't)





;;;; :compression, :circular-buffer, :size

(zl:defconst event-trace-delimiter-normal 0)
(zl:defconst event-trace-delimiter-seperator 1)
(zl:defconst event-trace-delimiter-repeat 2)
(zl:defconst event-trace-delimiter-repeat-count 3)

(defcollector event-trace
	      ((&rest args) ((args sys:expression "Record value" :either)))
  ;; the first two i.v.s are initialized in the make-instance method.
  (data 
    delimiters
    (circular nil)
    (wrapped nil)
    (last-name nil)
    (first-name nil))
  ()
  :wirable
  (:init-options-and-types (&key ((circular nil) boolean "circular buffer")
				 ((size 2000.) integer "size of buffer")))
  (:writable-instance-variables last-name)
  (:initable-instance-variables circular)
  (:init-keywords :compress :size)
  :readable-instance-variables
  :ordered-instance-variables
  (:default-init-plist :area metering-area))

(defmethod (make-instance event-trace :after)
	   (&rest init-options &key (size 2000.) area &allow-other-keys)
  (setf data (make-array size :fill-pointer 0 :area (or area metering-area)))
  (setf delimiters (make-array size :element-type '(unsigned-byte 2)
			       :initial-element 0
			       :area (or area metering-area))))

(defmethod (reset event-trace) ()
  (setf last-name nil)
  (setf (fill-pointer data) 0)
  (setf wrapped nil)
  (fill delimiters 0))
(defsubst copy-list-if-necessary (object)
  (declare (notinline copy-list-if-necessary))
  (if (and (listp object) (= (si:%area-number (si:%pointer object)) si:stack-area))
      (mapcar #'copy-list-if-necessary object)
      object))

;; (si:%area-number b)
(defmacro truncate-list-if-necessary (object &environment env)
  (once-only (object &environment env)
    `(if (and (listp ,object) (= (si:%area-number (si:%pointer ,object)) si:stack-area))
	 (si:%pointer ,object)
	 ,object)))

(defun safe-copy-of-list ()
  (if *construct-wired-code*
      #||'truncate-list-if-necessary||#
      'identity
      'copy-list-if-necessary))

(defmethod (collect-data event-trace) (name &rest args)
  (let ((limit (array-total-size data))
	(index (fill-pointer data))
	(arg-length (+ (length args) (if (AND (eql name last-name) (PLUSP (LENGTH ARGS)))
					 0 1))))
    (macrolet ((store (item)
		 `(progn (setf (aref data index) ,item)
			 (incf index))))
      (flet ((fixup-old-delimiters (from to)
	       (loop for i from from below to
		     do (let ((delimiter (aref delimiters i)))
			  (cond
			    ((eql delimiter event-trace-delimiter-normal))
			    ((eql delimiter event-trace-delimiter-seperator)
			     (setf first-name (aref data i))
			     (setf (aref delimiters i) event-trace-delimiter-normal))
			    (t
			     (setf (aref delimiters i) event-trace-delimiter-normal)))))))
	(if ( (+ index arg-length) limit)
	    (progn
	      (when (and wrapped circular)
		(fixup-old-delimiters index (+ index arg-length)))
	      (if (AND (eql name last-name) (PLUSP (LENGTH ARGS)))
		  (setf (aref delimiters index) event-trace-delimiter-repeat)
		  (setf (aref delimiters index) event-trace-delimiter-seperator)
		  (store name)
		  (setq last-name name))
	      (loop for arg in args do
		(store (copy-list-if-necessary arg)))
	      (setf (fill-pointer data) index))
	    (if circular
		(macrolet ((check-index ()
			     `(progn
				(when ( index limit)
				  (setf wrapped 't)
				  (setf index 0)))))
		  (fixup-old-delimiters index limit)
		  (fixup-old-delimiters 0 (- arg-length (- limit index)))
		  (check-index)
		  (if (eql name last-name)
		      (setf (aref delimiters index) event-trace-delimiter-repeat)
		      (setf (aref delimiters index) event-trace-delimiter-seperator)
		      (store name)
		      (setq last-name name))
		  (loop for arg in args do
		    (check-index)
		    (store (copy-list-if-necessary arg)))
		  (setf (fill-pointer data) index))
		(setf wrapped 't)))))))


(defmethod (get-form-to-collect-data event-trace) (instance &key args for-value)
  (declare (values form instance bindings))
  (if for-value
      (error "cannot build a hierarchical collector out of EVENT-TRACE.")
      (if (eq instance ':constant)
	  (let ((instance-name (gensym "INSTANCE"))
		(data-name (gensym "DATA"))
		(delimiters-name (gensym "DELIMITERS"))
		(limit-name (gensym "LIMIT"))
		(circular-name (gensym "CIRCULAR"))
		(name (car args))
		(arg-length (loop with rest-arg = nil
				  with count = 0
				  for arg in (cdr args)
				  do (if (arg-is-rest-arg? arg)
					 (setf rest-arg `((length ,arg)))
					 (incf count))
				  finally (return `(+ ,@(unless (zerop count) (ncons count))
						      ,@rest-arg)))))
	    (values `(let ((index (fill-pointer ,data-name))
			   (args-length (+ ,arg-length
					   (if (AND
						 (eql ,name
						    ,(safe-instance-reference 'event-trace
									      'last-name
									      instance-name))
						 (PLUSP ,ARG-LENGTH))
					       0 1))))
		       (macrolet ((store (arg)
				    `(progn
				       (setf (aref ,',data-name index) ,arg)
				       (incf index))))
			 (flet ((fixup-old-delimiters (from to)
				  (loop for i from from below to
					do (let ((delimiter (aref ,delimiters-name i)))
					     (cond
					       ((eql delimiter
						     ,(safe-constant-reference
							'event-trace-delimiter-normal)))
					       ((eql delimiter
						     ,(safe-constant-reference
							'event-trace-delimiter-seperator))
						(setf ,(safe-instance-reference
							 'event-trace 'first-name instance-name)
						      (aref ,data-name i))
						(setf (aref ,delimiters-name i)
						      ,(safe-constant-reference
							 'event-trace-delimiter-normal)))
					       (t
						(setf (aref ,delimiters-name i)
						      ,(safe-constant-reference
							 'event-trace-delimiter-normal))))))))


			 (if ( (+ index args-length) ,limit-name)
			     (progn
			       (when (and ,circular-name
					  ,(safe-instance-reference
					     'event-trace 'wrapped instance-name))
				 (fixup-old-delimiters index (+ index args-length)))
			       (if (AND (eql ,name
					     ,(safe-instance-reference 'event-trace
								       'last-name
								       instance-name))
					(PLUSP ,ARG-LENGTH))
				   (setf (aref ,delimiters-name index)
					 ,(safe-constant-reference
					    `event-trace-delimiter-repeat))
				   (setf (aref ,delimiters-name index)
					 ,(safe-constant-reference
					   `event-trace-delimiter-seperator))
				   (store ,name)
				   (setf ,(safe-instance-reference
					    'event-trace 'last-name instance-name)
					 ,name))
			       ,@(loop for arg in (cdr args)
				       collect
					 (if (arg-is-rest-arg? arg)
					     `(loop for arg in ,(second arg) do
						(store (copy-list-if-necessary arg)))
					     `(store (,(safe-copy-of-list) ,arg))))
			       (setf (fill-pointer ,data-name) index))
			     (if ,circular-name
				 (macrolet ((check-index ()
					      `(progn
						 (when ( index ,',limit-name)
						   (setf ,(safe-instance-reference
							    'event-trace
							    'wrapped
							    ',instance-name)
							 't)
						   (setf index 0)))))
				   (fixup-old-delimiters index ,limit-name)
				   (fixup-old-delimiters
				     0 (- args-length (- ,limit-name index)))
				   (check-index)
				   (if (eql ,name (event-trace-last-name ,instance-name))
				       (setf (aref ,delimiters-name index)
					     ,(safe-constant-reference
						'event-trace-delimiter-repeat))
				       (setf (aref ,delimiters-name index)
					     ,(safe-constant-reference
						'event-trace-delimiter-seperator))
				       (store ,name)
				       (setf ,(safe-instance-reference
						'event-trace 'last-name instance-name)
					     ,name))
				   ,@(loop for arg in (cdr args)
					   collect
					     (if (arg-is-rest-arg? arg)
						 `(loop for arg in ,(second arg) do
						    (check-index)
						    (store (,(safe-copy-of-list) arg)))
						 `(progn
						    (check-index)
						    (store (,(safe-copy-of-list) ,arg)))))
				   (setf (fill-pointer ,data-name) index))
				 (setf ,(safe-instance-reference
					  'event-trace
					  'wrapped
					  instance-name)
				       't))))))
		       instance-name
		       `((,data-name (event-trace-data ,instance-name))
			 (,delimiters-name (event-trace-delimiters ,instance-name))
			 (,limit-name (array-total-size ,data-name))
			 (,circular-name (event-trace-circular ,instance-name)))))
	  (values `(collect-data ,instance ,@args) nil nil))))



(defmethod (get-form-to-collect-wired-data event-trace) (instance &key args for-value)
  (declare (values form instance bindings))
  (let ((*construct-wired-code* 't))
    (get-form-to-collect-data self instance :args args :for-value for-value)))

(defmethod (display event-trace) (&optional (s 't) &key label)
  (format s "~%")
  (when label
    (format s "~A" (if (listp label) (car label) label)))
  (let ((index 0))
    (when (and circular wrapped)
      (format s "~&(Circular buffer has wrapped (~D))" (fill-pointer data)))
    (get-entries self
		 #'(lambda (name &rest args)
		     (format s "~& ~4D: ~S" index name)
		     (incf index)
		     (loop for arg in args do (format s " ~S" arg))))))

(defmethod (get-entries event-trace) (f)
  (loop with arglist = nil
	with name = (or first-name 'name-not-known-yet)
	with data-border = (fill-pointer data)
	with size = (array-total-size data)
	with top-limit = (if (zerop data-border)
			     (if (and circular wrapped) size 0)
			     (1- data-border))
	with synched = (not (and circular wrapped))
	for index = (if (and circular wrapped (not (= data-border size))) data-border 0)
		  then (let ((next (1+ index)))
			 (if ( next size) 0 next))
	as entry = (aref data index)
	as delimiter = (aref delimiters index)
	while (or (and wrapped circular) (< index data-border))
	do (cond ((eql delimiter event-trace-delimiter-seperator)
		  (when (and arglist synched)
		    (apply f (nreverse arglist)))
		  (setq synched 't)
		  (setq arglist (ncons entry))
		  (setq name entry))
		 ((eql delimiter event-trace-delimiter-repeat)
		  (when (and arglist synched)
		    (apply f (nreverse arglist)))
		  (setq synched 't)
		  (setq arglist (list entry name)))
		 (t (push entry arglist)))
	until (= index top-limit)
	finally (when arglist
		  (apply f (nreverse arglist)))))

(defmethod (collector-empty-p event-trace) ()
  (and (not wrapped) (zerop (fill-pointer data))))

(defmethod (complete-data-p event-trace) ()
  (not wrapped))

(defmethod (wire-for-aux-stack event-trace) ()
  (si:wire-structure data)
  (si:wire-structure delimiters)
  (si:wire-structure self))

(defmethod (unwire event-trace) ()
  (si:unwire-structure data)
  (si:unwire-structure delimiters)
  (si:unwire-structure self))



;; representation is still not consistent....
(defflavor total-mixin () ()
  (:required-instance-variables total1 total2)
  :abstract-flavor)

(defmethod (collector-total1 total-mixin) () total1)

(defmethod (collector-total2 total-mixin) () total2)

(defsubst get-total-components (data &optional dont-cons)
  (if (zl:fixnump data)
      (if (minusp data)
	  (values data -1)
	  (values data 0))
      ;; the data is guaranteed to be an integer, but this is too dangerous to take a chance
      ;; on
      (if (zl:bigp data)
	  (values (si:bignum-ref data 0)
		  (if (and dont-cons
			   (> (integer-length data) 63))
		      ;; this is bogus, but it's better than FEPping the machine.
		      0
		      (ash data -32)))
	  ;; let someone else crash
	  (values data 0))))

(defmethod (add-data total-mixin) (data)
  (multiple-value-bind (val1 val2)
      (get-total-components data)
    (multiple-value-bind (sum carry)
	(si:%add-bignum-step total1 val1 0)
      (setf total1 sum)
      (incf total2 (+ carry val2)))))

(defmethod (get-form-to-add-data total-mixin) (instance-name data flavor-name)
  `(let ((inst ,instance-name))
     (multiple-value-bind (val1 val2)
	 (get-total-components ,data ,*construct-wired-code*)
       (multiple-value-bind (sum carry)
	   (si:%add-bignum-step ,(safe-instance-reference flavor-name 'total1 'inst) val1 0)
	 (setf ,(safe-instance-reference flavor-name 'total1 'inst) sum)
	 ;; It's better to get incorrect data than crash into the FEP.
	 ,(if *construct-wired-code*
	     `(when (zl:fixnump val2)
		(setf ,(safe-instance-reference flavor-name 'total2 'inst)
		      (sys:%32-bit-plus ,(safe-instance-reference flavor-name 'total2 'inst)
					(sys:%32-bit-plus carry val2))))
	     `(incf ,(safe-instance-reference flavor-name 'total2 'inst)
		    (+ carry val2)))))))

(defmethod (combine-total total-mixin) (combinee)
  (let ((val1 (collector-total1 combinee))
	(val2 (collector-total2 combinee)))
    (multiple-value-bind (sum carry)
	(si:%add-bignum-step total1 val1 0)
      (setf total1 sum)
      (incf total2 (+ carry val2)))))

(defmethod (optimize-combine-total total-mixin) (combinee)
  (when (operation-handled-p combinee 'total)
    (let ((other-total (floor (total combinee))))
      (multiple-value-bind (val1 val2)
	  (get-total-components other-total)
	(multiple-value-bind (sum carry)
	    (si:%add-bignum-step total1 val1 0)
	  (setf total1 sum)
	  (incf total2 (+ carry val2)))))
    't))

(defmethod (reset-total total-mixin) ()
  (setf total1 0)
  (setf total2 0))

;;; an odd name.  But it fits in the convention of xxx-total,
;;; (operation - collector-mixin-type) used above.
(defmethod (total-total total-mixin) ()
  (if (and (eql total2 -1) (minusp total1))
      total1
      (let ((high-bits (ash total2 32)))
	;; Don't you *dare* do a bignum-ref of something that isn't a bignum.
	(if (zl:bigp high-bits)
	    (progn (setf (si:bignum-ref high-bits 0) total1)
		   high-bits)
	    ;; really should be 0, but just in case we'll add it in.
	    (+ high-bits (if (minusp total1)
			     (si:%make-bignum-from-fixnum-components 0 1 total1)
			     total1))))))




#||

(defflavor total-tester
	((total1 0) (total2 0))
	(total-mixin)
  :writable-instance-variables)

(defun test-total-stuff (range &optional (count 10000.))
  (let* ((total-instance (make-instance 'total-tester))
	 (start (total-total total-instance))
	 (range (abs range))
	 (range-seed (+ range range)))
    (loop for i below count do
      (let ((data (- (random range-seed) (1- range))))
	(incf start data)
	(add-data total-instance data)
	(when (zerop (mod i 250.))
	  (format t "~&~7D: ~D (last data: ~D)" i (total-total total-instance) data))
	(unless (eql start (total-total total-instance))
	  (format t "~&~D: Unequal TOTAL: ~S validate: ~S"
		  i (total-total total-instance) start))))))
||#



;;;;;;;;;;;;;;;;
;;;; simple averaging and total....

(defflavor collect-names-mixin ((names nil)) ()
  :writable-instance-variables
  (:conc-name names-))

(defwhopper-subst (collect-data collect-names-mixin) (name &rest args)
  (pushnew name names)
  (lexpr-continue-whopper name args))

(defwhopper (get-form-to-collect-data collect-names-mixin) (instance &key args for-value)
  (if for-value
      (error "You can't build a hierarchical collector using the COLLECT-NAMES-MIXIN")
      (multiple-value-bind (form instance-name bindings)
	  (continue-whopper instance :args args :for-value for-value)
	(when (and (or (eq instance-name ':constant) (null instance-name))
		   (or (eq instance :constant) (null instance)))
	  (setf instance-name (gensym "INSTANCE")))
	(values `(progn (pushnew ,(car args) (names-names ,(or instance-name instance)))
			,form)
		instance-name bindings))))

(defmethod (reset collect-names-mixin :after) ()
  (setf names nil))

(defmethod (display collect-names-mixin :before) (&optional (s 't) &key label)
  (ignore label)
  (format s "Names seen: ~s " names))

(defwhopper (get-form-to-collect-wired-data collect-names-mixin)
	    (instance &key args for-value)
  (cl:warn "You can't wire a collector that uses COLLECT-NAMES-MIXIN")
  (if for-value
      (error "You can't build a hierarchical collector using the COLLECT-NAMES-MIXIN")
      (multiple-value-bind (form instance-name bindings)
	  (continue-whopper instance :args (cdr args) :for-value for-value)
	(when (and (or (eq instance-name ':constant) (null instance-name))
		   (or (eq instance :constant) (null instance)))
	  (setf instance-name (gensym "INSTANCE")))
	(values `(progn (pushnew ,(car args) (names-names ,(or instance-name instance)))
			,form)
		instance-name bindings))))

(defwhopper (wire-for-aux-stack collect-names-mixin) ()
  (cl:warn "You can't wire a collector that uses COLLECT-NAMES-MIXIN")
  (continue-whopper))
(defmethod (get-entries collect-names-mixin) (mapping-function)
  (loop for name in names 
	do (funcall mapping-function name)))
(defcollector collect-names
	      ((name) ((name t "Name to remember" :value)))
	      ()
  (collect-names-mixin))


(defcollector collect-simple-averages
	      ((&rest args) ((args integer "Value to average" :value)))
	      ((count 0)
	       (total1 0)
	       (total2 0))
  (trivially-wirable-collector-mixin total-mixin)
  :wirable
  :ordered-instance-variables
  (:conc-name avg-)
  :writable-instance-variables
  (:default-init-plist :area metering-area))




(defmethod (collect-data collect-simple-averages) (&rest args)
  (incf count (length args))
  (add-data self (apply #'+ args)))


(defmethod (get-form-to-collect-data collect-simple-averages)
	   (instance &key args for-value)
  (if for-value
      (error "You can't build a hierarchical collector using the COLLECT-SIMPLE-AVERAGES")
      (let ((instance-name (if (eq instance ':constant)
			       (gensym "INSTANCE")
			       instance)))
	(values `(let ((avg ,instance-name)
		       (new-value ,(if (= 1 (length args))
				       (car args)
				       `(+ ,@args))))
		   (incf ,(safe-instance-reference 'avg 'count 'avg) ,(length args))
		   ,(get-form-to-add-data
		      self instance-name 'new-value 'avg))
		(if (eq instance ':constant) instance-name nil)
		nil))))



(defmethod (avg-total collect-simple-averages) ()
  (total self))
(defmethod (total collect-simple-averages) () (total-total self))

(defmethod (average collect-simple-averages) ()
  (if (zerop count)
      0
      (/ (float (total self)) count)))

(defmethod (compact-results collect-simple-averages) () (average self))
(defmethod (compact-results-description collect-simple-averages) () 'average)

(defmethod (complete-data-p collect-simple-averages) ()
  ( count 1))
(defmethod (collector-empty-p collect-simple-averages) () (zerop count))

(defmethod (reset collect-simple-averages) ()
  (setf count 0)
  (reset-total self))

(defmethod (display collect-simple-averages) (&optional (s 't) &key label)
  (let ((total (total self))
	(avg (average self)))
    (format s "~&")
    (when label
      (format s "~A: " (if (listp label) (car label) label)))
    (format s "Averages: count: ~D Total: ~D Average: ~F"
	    count total avg)))

;;Yield a list of numbers such that average, total, and count are all the same as this 
;; collector has so far.
(defmethod (get-entries collect-simple-averages) (mapping-function)
  (multiple-value-bind (base-number threshold)
      (floor (average self))
    (loop repeat count
	  do (funcall mapping-function
		      (+ base-number (if (> (random 1.0) threshold) 1 0))))))



;; if everything works correctly, this will only be called when COMBINEE is also
;; of type collect-simple-averages.
(defmethod (combine collect-simple-averages) (combinee)
  (incf count (avg-count combinee))
  (combine-total self combinee))

(defmethod (optimize-combine collect-simple-averages) (combinee)
  (when (and (operation-handled-p combinee 'entry-count)
	     (optimize-combine-total self combinee))
    (incf count (entry-count combinee))
    't))

(defmethod (entry-count collect-simple-averages) () count)



(defcollector standard-deviation
	      ((&rest args) ((args integer "Value to average" :value)))
	      ((count 0)
	       (total1 0)
	       (total2 0)
	       (sum-of-squares-1 0)
	       (sum-of-squares-2 0)
	       (sum-of-squares-3 0))
  (trivially-wirable-collector-mixin total-mixin)
  :wirable
  :ordered-instance-variables
  (:conc-name stdev-)
  :writable-instance-variables
  (:default-init-plist :area metering-area))

(defmethod (collect-data standard-deviation) (&rest args)
  (incf count (length args))
  (let* ((new-val (apply #'+ args))
	 (new-val-squared (floor (* new-val new-val))))
    (add-data self new-val)
    (multiple-value-bind (low-square high-square)
	(if (zl:fixnump new-val-squared)
	    (values new-val-squared 0)
	    (values (si:bignum-ref new-val-squared 0)
		    (if (> (si:bignum-length new-val-squared) 1)
			(si:bignum-ref new-val-squared 1)
			0)))
      (multiple-value-bind (sum carry)
	  (si:%add-bignum-step sum-of-squares-1 low-square 0)
	(setf sum-of-squares-1 sum)
	(multiple-value-bind (sum carry)
	    (si:%add-bignum-step sum-of-squares-2 high-square carry)
	  (setf sum-of-squares-2 sum)
	  (unless (zerop carry)
	    (setf sum-of-squares-3 
		  (si:%add-bignum-step sum-of-squares-3 carry 0))))))))

(defmethod (get-form-to-collect-data standard-deviation)
	   (instance &key args for-value)
  (if for-value
      (error "You can't build a hierarchical collector using the STANDARD-DEVIATION")
      (let ((instance-name (if (eq instance ':constant)
			       (gensym "INSTANCE")
			       instance)))
	(values `(let* ((stdev ,instance-name)
			(new-val ,(if (= 1 (length args))
				      (car args)
				      `(+ ,@args)))
			(new-val-squared (floor (* new-val new-val))))
		   (incf ,(safe-instance-reference 'stdev 'count 'stdev) ,(length args))
		   ,(get-form-to-add-data self instance-name 'new-val 'stdev)
		   (multiple-value-bind (low-square high-square)
		       (if (zl:fixnump new-val-squared)
			   (values new-val-squared 0)
			   (values (si:bignum-ref new-val-squared 0)
				   (if (> (si:bignum-length new-val-squared) 1)
				       (si:bignum-ref new-val-squared 1)
				       0)))
		     (multiple-value-bind (sum carry)
			 (si:%add-bignum-step
			   ,(safe-instance-reference 'stdev 'sum-of-squares-1 'stdev)
			   low-square 0)
		       (setf ,(safe-instance-reference 'stdev 'sum-of-squares-1 'stdev) sum)
		       (multiple-value-bind (sum carry)
			   (si:%add-bignum-step
			     ,(safe-instance-reference 'stdev 'sum-of-squares-2 'stdev)
			     high-square carry)
			 (setf ,(safe-instance-reference 'stdev 'sum-of-squares-2 'stdev)
			       sum)
			 (unless (zerop carry)
			   (setf ,(safe-instance-reference 'stdev 'sum-of-squares-3 'stdev) 
				 (si:%add-bignum-step
				   ,(safe-instance-reference
				      'stdev 'sum-of-squares-3 'stdev)
				   carry 0)))))))
		(if (eq instance ':constant) instance-name nil)
		nil))))
(defmethod (total standard-deviation) () (total-total self))

(defmethod (average standard-deviation) ()
  (if (zerop count)
      0
      (/ (float (total self)) count)))

(defmethod (sum-of-squares standard-deviation) ()
  (if (zerop sum-of-squares-3)
      (if (and (zerop sum-of-squares-2)
	       (not (minusp sum-of-squares-1)))
	  sum-of-squares-1
	  (si:%make-bignum-from-fixnum-components 0 2 sum-of-squares-1 sum-of-squares-2))
      (si:%make-bignum-from-fixnum-components
	0 3 sum-of-squares-1 sum-of-squares-2 sum-of-squares-3)))

(defmethod (standard-deviation standard-deviation) (&optional mean)
  (unless mean (setq mean (average self)))
  (let ((count (stdev-count self)))
    (if (zerop count)
	0.0
	(sqrt (/ (- (sum-of-squares self) (* mean (total self)))
		 count)))))

(defmethod (compact-results standard-deviation) () (average self))
(defmethod (compact-results-description standard-deviation) () 'average)

(defmethod (complete-data-p standard-deviation) ()
  (= (sum-of-squares self)
     (* (total self) (average self))))
(defmethod (collector-empty-p standard-deviation) () (zerop count))

(defmethod (reset standard-deviation) ()
  (setf count 0)
  (reset-total self)
  (setf sum-of-squares-1 0)
  (setf sum-of-squares-2 0)
  (setf sum-of-squares-3 0))

(defmethod (display standard-deviation) (&optional (s 't) &key label)
  (let* ((total (total self))
	 (avg (average self))
	 (stdev (standard-deviation self avg)))
    (format s "~&")
    (when label
      (format s "~A: " (if (listp label) (car label) label)))
    (format s "Averages: count: ~D Total: ~D Average: ~FŒ~F"
	    count total avg stdev)))
;;Yield a list of numbers such that average, total, and count, and standard-deviation are
;;all the same as this collector has so far.
;; We can do this in many ways.  For the sake of convenience we arbitrarily choose to
;; send out most at the average, and two side bars at 3 standard-deviations out.
;; If this would cause the values to be both positive and negative, we shrink the outlying
;; bars until we fit on one side of zero.  If the average is within a standard-deviation of
;; zero, we obviously can't produce a series of values fitting this specification.  Instead
;; we try to have a large spike at 1, with a smaller clump as far out as possible.
(defmethod (get-entries standard-deviation) (mapping-function)
  (declare (sys:downward-funarg mapping-function))
  (when (plusp count)
    (multiple-value-bind (base skewed)
	(floor (abs (total self)) count)
      (let* ((total (total self))
	     (average (/ (abs total) count))
	     (square-sum (sum-of-squares self))
	     (variance (- (/ square-sum count) (* average average)))
	     (standard-deviation (sqrt variance))
	     (sign (if (minusp total) -1 1)))
	(if (or (not (< 1 base standard-deviation))
		(not (< (- square-sum count 1) (expt (- total count 1) 2))))
	    (let* ((deviation (if (< standard-deviation base (* 3 standard-deviation))
				  average
				  (* 3 standard-deviation)))
		   (deviants (if (zerop deviation)
				 0
				 (max (floor (* count variance) (* 2 deviation deviation)) 1))))
	      (multiple-value-bind (mode-skew deviants-skew)
		  (let ((base-mode (- count (+ deviants deviants))))
		    (if (> base-mode skewed)
			(values skewed 0)
			(values (if (evenp (- skewed base-mode)) base-mode (1- base-mode))
				(ceiling (- skewed base-mode) 2))))
		(let ((mode (- (- count (+ deviants deviants)) mode-skew))
		      (deviants (- deviants deviants-skew))
		      (deviation (round deviation))
		      (base (* base sign)))
		  (loop repeat mode do (funcall mapping-function base))
		  (loop repeat mode-skew
			with value = (+ base sign)
			do (funcall mapping-function value))
		  (loop repeat deviants
			with value1 = (+ base deviation)
			with value2 = (- base deviation) do
		    (funcall mapping-function value1)
		    (funcall mapping-function value2))
		  (loop repeat deviants-skew
			with value1 = (+ base deviation 1)
			with value2 = (- (1+ base) deviation) do
		    (funcall mapping-function value1)
		    (funcall mapping-function value2)))))
	    ;; OK simple scheme won't work in this case.
	    ;; Try shifting the MEAN, and only having one deviation, *away* from zero.
	    (let* ((base sign)
		   (base-mode (round (/ (- (* count square-sum) (* total total))
					(- (+ square-sum count) (abs (+ total total))))))
		   (base-deviants (- count base-mode))
		   (deviation (* sign (1- (floor (- (abs total) base-mode) base-deviants))))
		   (skewed (- (abs total)
			      (abs (+ (* base-mode base)
				      (* base-deviants (+ deviation sign))))))
		   (mode (max (- base-mode skewed) 0))
		   (mode-skew (min base-mode skewed))
		   (deviants-skew (- skewed mode-skew))
		   (deviants (- base-deviants deviants-skew)))
	      (loop repeat mode do (funcall mapping-function base))
	      (loop repeat mode-skew
		    with value = (+ base sign)
		    do (funcall mapping-function value))
	      (loop repeat deviants
		    with value = (+ base deviation) do
		(funcall mapping-function value))
	      (loop repeat deviants-skew
		    with value = (+ base deviation sign) do
		(funcall mapping-function value))))))))



#||
(defun drive-test (&optional (repeats 1000))
  (flet ((tolerably-equal (num1 num2)
	   (and (eq (minusp num1) (minusp num2))
		(< (/ (abs (- num1 num2))
		      (abs (+ num1 num2)))
		   1/20))))
    (loop repeat repeats do
      (let* ((count (random 1000))
	     (total (- (random 10000) 5000))
	     (squares (+ (abs total) (* (random 5000) (random 5000)))))
	(multiple-value-bind (new-count new-total new-squares low high)
	    (test-get-entries count total squares)
	  (unless (and (= count new-count)
		       (= total new-total)
		       (tolerably-equal squares new-squares))
	    (format t "~&***===> New count: ~D New total: ~D New squares: ~D"
		    new-count new-total new-squares))
	  (unless (eq (minusp low) (minusp high))
	    (format t "~&* Zero crossing")))))))
||#

;; if everything works correctly, this will only be called when COMBINEE is also
;; of type standard-deviation.
(defmethod (combine standard-deviation) (combinee)
  (incf count (stdev-count combinee))
  (combine-total self combinee)
  (multiple-value-bind (sum carry)
      (si:%add-bignum-step sum-of-squares-1 (stdev-sum-of-squares-1 combinee) 0)
    (setf sum-of-squares-1 sum)
    (multiple-value-bind (sum carry)
	(si:%add-bignum-step sum-of-squares-2 (stdev-sum-of-squares-2 combinee) carry)
      (setf sum-of-squares-2 sum)
      (setf sum-of-squares-3
	    (si:%add-bignum-step
	      sum-of-squares-3 (stdev-sum-of-squares-3 combinee) carry)))))

(defmethod (optimize-combine standard-deviation) (combinee)
  (when (and (operation-handled-p combinee 'sum-of-squares)
	     (operation-handled-p combinee 'entry-count)
	     (optimize-combine-total self combinee))
    (let ((other-count (entry-count combinee))
	  (other-sum-of-squares (sum-of-squares combinee)))
      (incf count other-count)
      (setf other-sum-of-squares (floor other-sum-of-squares))
      (multiple-value-bind (sum1 sum2 sum3)
	  (if (zl:fixnump other-sum-of-squares)
	      (values other-sum-of-squares 0 0)
	      (values (si:bignum-ref other-sum-of-squares 0)
		      (if (> (si:bignum-length other-sum-of-squares) 1)
			  (si:bignum-ref other-sum-of-squares 1)
			  0)
		      (if (> (si:bignum-length other-sum-of-squares) 2)
			  (si:bignum-ref other-sum-of-squares 2)
			  0)))
	(multiple-value-bind (sum carry)
	    (si:%add-bignum-step sum-of-squares-1 sum1 0)
	  (setf sum-of-squares-1 sum)
	  (multiple-value-bind (sum carry)
	      (si:%add-bignum-step sum-of-squares-2 sum2 carry)
	    (setf sum-of-squares-2 sum)
	    (setf sum-of-squares-3
		  (si:%add-bignum-step sum-of-squares-3 sum3 carry)))))
      't)))

(defmethod (entry-count standard-deviation) () count)



;;;;;;;;;;;;;;;;

(defcollector counter (() (()))
  ((count 0))
  (trivially-wirable-collector-mixin)
  :wirable
  :ordered-instance-variables
  :writable-instance-variables
  (:conc-name collector-))

(defmethod (reset counter) ()
  (setf count 0))

(defmethod (collector-empty-p counter) () (zerop count))
(defmethod (complete-data-p counter) () t)

(defmethod (collect-data counter) (&rest args)
  (ignore args)
  (incf count))

(defmethod (display counter) (&optional (s t) &key label)
  (if label
      (format s "~&~A h" (if (listp label) (car label) label))
      (format s "~&H"))
  (format s "as been incremented ~D times" count))

(defmethod (get-form-to-collect-data counter) (instance &key args for-value)
  (declare (values form instance bindings))
  (if for-value
      (error "It is illegal to build hierarchical collectors on top of COUNTERs")
      (if args
	  (error "COUNTERs take no arguments. Extra: ~S" args)
	  (if (eq instance ':constant)
	      (let ((instance-name (gensym "INSTANCE")))
		(values `(incf (collector-count ,instance-name))
			instance-name
			nil))
	      (values `(incf (collector-count ,instance)) nil nil)))))

(defmethod (total counter) () count)
(defmethod (entry-count counter) () count)

(defmethod (compact-results counter) () count)
(defmethod (compact-results-description counter) () 'TOTAL)

(defmethod (get-entries counter) (mapping-function)
  (loop repeat count
	do (funcall mapping-function)))

(defmethod (combine counter) (combinee)
  (incf count (total combinee)))

(defmethod (optimize-combine counter) (combinee)
  (when (operation-handled-p combinee 'entry-count)
    (let ((other-count (entry-count combinee)))
      (incf count other-count))))




;;;;;;;;;;;;;;;;

(defcollector sum ((&rest args) ((args integer "Value(s) to sum" :value)))
  ((total1 0)
   (total2 0))
  (trivially-wirable-collector-mixin total-mixin)
  :wirable
  :ordered-instance-variables
  :writable-instance-variables)
(defmethod (reset sum) () (reset-total self))
(defmethod (collector-empty-p sum) () (and (zerop total1) (zerop total2)))

(defmethod (collect-data sum) (&rest args)
  (add-data self (apply #'+ args)))
(defmethod (get-form-to-collect-data sum)
	   (instance &key args for-value)
  (if for-value
      (error "You can't build a hierarchical collector using the SUM collector")
      (let ((instance-name (if (eq instance ':constant)
			       (gensym "SUM")
			       instance)))
	(values (get-form-to-add-data self instance-name
				      (if (= 1 (length args)) (car args) (cons '+ args))
				      'sum)
		(if (eq instance ':constant) instance-name nil)
		nil))))
(defmethod (total sum) () (total-total self))

(defmethod (display sum) (&optional (s t) &key label)
  (if label
      (format s "~&~A h" (if (listp label) (car label) label))
      (format s "~&H"))
  (format s "as a total of ~D" (total self)))

(defmethod (compact-results sum) () (total self))
(defmethod (compact-results-description sum) () 'TOTAL)

(defmethod (get-entries sum) (mapping-function)
  (funcall mapping-function (total self)))

(defmethod (combine sum) (combinee)
  (combine-total self combinee))

(defmethod (optimize-combine sum) (combinee)
  (optimize-combine-total self combinee))
(defcollector integer-sum ((&rest args) ((args integer "Value(s) to sum" :value)))
  ()
  (sum)
  :wirable
  :ordered-instance-variables
  :writable-instance-variables)


;;;;;
(defcollector bounds ((&rest args) ((args integer "Value(s) to check range" :value)))
  ((min nil)
   (max nil))
  (trivially-wirable-collector-mixin)
  :wirable
  :ordered-instance-variables
  :writable-instance-variables)

(defmethod (reset bounds) ()
  (setf min nil)
  (setf max nil))

(defmethod (collector-empty-p bounds) () (null min))

(defmethod (collect-data bounds) (&rest args)
  (map nil #'(lambda (value)
	       (when (or (null min) (< value min))
		 (setf min value))
	       (when (or (null max) (> value max))
		 (setf max value)))
       args))

(defmethod (get-form-to-collect-data bounds)
	   (instance &key args for-value)
  (if for-value
      (error "You can't build a hierarchical collector using the BOUNDS collector")
      (let ((instance-name (if (eq instance ':constant)
			       (gensym "BOUNDS")
			       instance)))
	(values `(let ((bounds-instance ,instance-name))
		   ,(flet ((get-bounds (value)
			     `(progn
				(let ((min (bounds-min bounds-instance)))
				  (when (or (null min) (< ,value min))
				    (setf (bounds-min bounds-instance) ,value)))
				(let ((min (bounds-max bounds-instance)))
				  (when (or (null max) (> ,value max))
				    (setf (bounds-max bounds-instance) ,value))))))
		      (if (= 1 (length args))
			  (get-bounds (car args))
			  `(progn
			     ,@(map 'list #'(lambda (value) (get-bounds value)) args)))))
		(if (eq instance ':constant) instance-name nil)
		nil))))

(defmethod (bounds bounds) () (when min (list min max)))

(defmethod (display bounds) (&optional (s t) &key label)
  (if label
      (format s "~&~A w" (if (listp label) (car label) label))
      (format s "~&W"))
  (format s "as between ~D and ~D" min max))

(defmethod (compact-results bounds) () (bounds self))
(defmethod (compact-results-description bounds) () 'BOUNDS)

(defmethod (get-entries bounds) (mapping-function)
  (funcall mapping-function min)
  (funcall mapping-function max))

(defmethod (combine bounds) (combinee)
  (multiple-value-bind (omin omax)
      (si:eval-in-instance combinee '(values min max))
    (if (and omin min)
	(when (< omin min) (setf min omin))
	(setf min (or min omin)))
    (if (and omax max)
	(when (> omax max) (setf max omax))
	(setf max (or max omax)))))

(defmethod (upper-bound bounds) () max)
(defmethod (lower-bound bounds) () min)


;;;;;;;
(defcollector record  (() (()))
  (data)
  ()
  ;; allow hierarchical collectors to be built out of this.
  (:hierarchical t)
  :writable-instance-variables)

(defmethod (make-instance record :after) (&rest init-options)
  (ignore init-options)
  (setf data (funcall make-component)))

(defmethod (collect-data record) (&rest args)
  (decompose-components (or data (setf data (funcall make-component)))
			#'(lambda (component ignore)
			    (apply 'collect-data component args))))

(defmethod (collect-data-for-value record) (&rest args)
  (ignore args)
  (or data (setf data (funcall make-component))))

(defmethod (get-form-to-collect-data record) (instance &key args for-value)
  (declare (values form instance bindings))
  (if (eq instance ':constant)
      (let ((instance-name (gensym "RECORD"))
	    (data (gensym "COMPONENTS")))
	(values (if for-value
		    data
		    `(decompose-components
		       ,data
		       #'(lambda (component ignore)
			   (collect-data component ,@args))))
		instance-name
		`((,data (si:eval-in-instance ,instance-name 'data)))))
      (values `(,(if for-value 'collect-data-for-value 'collect-data) ,instance ,@args)
	      nil
	      nil)))

(defmethod (reset record) ()
  (decompose-components data #'(lambda (c ignore) (reset c))))

(defmethod (complete-data-p record) () t)

(defmethod (map-over-component-collectors record) (function &rest args)
  (declare (sys:downward-funarg function))
  (apply function nil data args))

(defmethod (ncomponents record) () 1)

(setf (collector-type-sample-instance
	(find-collector-type 'record))
      (make-data-collector 'record :component-description '()))


;;;;;;;;;;;;;;;;



(defcollector collect-hash
	      ((&rest args) ((args sys:expression "Hash key" :either)))
	      ((table nil))
  () 
  ;; allow hierarchical collectors to be built out of this.
  (:hierarchical t)
  (:init-options-and-types (&key (make-hash-table-args
				   sys:expression
				   "arguments to make-hash-table")))
  :initable-instance-variables
  (:init-keywords :make-hash-table-args))
(defmethod (make-instance collect-hash :after)
	   (&rest init-options &key make-hash-table-args area &allow-other-keys)
  (let ((make-hash-table-args (if area
				  (append make-hash-table-args (list :area area))
				  make-hash-table-args)))
    (setf table (or table (apply #'make-hash-table make-hash-table-args)))))
(defmethod (collect-data collect-hash) (key &rest args)
  (let ((inner-collector (or (gethash key table)
			     (setf (gethash (copy-list-if-necessary key) table)
				   (funcall make-component)))))
    (decompose-components inner-collector
			  #'(lambda (component ignore)
			      (declare (sys:downward-function))
			      (apply 'collect-data component args)))))
(defmethod (collect-data-for-value collect-hash) (key &rest args)
  (ignore args)
  (stack-let ((temp-key (cons key args)))
    (let ((table-key (if args temp-key key)))
      (or (gethash table-key table)
	  (setf (gethash (copy-list-if-necessary table-key) table)
		(funcall make-component))))))
(defmethod (get-data-components collect-hash) (key &rest args)
  (stack-let ((temp-key (cons key args)))
    (let ((table-key (if args temp-key key)))
      (gethash table-key table))))
(defmethod (get-form-to-collect-data collect-hash) (instance &key args for-value)
  (declare (values form instance bindings))
  (if (eq instance ':constant)
      (let ((instance-name (gensym "HASH-COLLECTOR"))
	    (table (gensym "HASH-TABLE"))
	    (temp-name (gensym (if for-value "KEY" "COMPONENTS")))
	    (constructor (gensym "CONSTRUCTOR")))
	(values (if for-value
		    (let ((key (if (listp args)
				   (if (= (length args) 1)
				       (car args)
				       `(list ,@args))
				   args)))
		      `(stack-let ((,temp-name ,key))
			 (or (gethash ,temp-name ,table)
			     (setf (gethash (copy-list-if-necessary ,temp-name) ,table)
				   (funcall ,constructor)))))
		    `(let ((,temp-name
			    (or (gethash ,(car args) ,table)
				(setf (gethash (copy-list-if-necessary ,(car args)) ,table)
				      (funcall ,constructor)))))
		       (decompose-components ,temp-name
					     #'(lambda (component ignore)
						 (collect-data component ,@(cdr args))))))
		instance-name
		`((,table (si:eval-in-instance ,instance-name 'table))
		  (,constructor (si:eval-in-instance ,instance-name 'make-component)))))
      (values `(,(if for-value 'collect-data-for-value 'collect-data) ,instance ,@args)
	      nil
	      nil)))
(defmethod (reset collect-hash) ()
  (clrhash table))
(defmethod (complete-data-p collect-hash) () t)
(defmethod (map-over-component-collectors collect-hash) (function &rest args)
  (maphash #'(lambda (key value)
	       (declare (sys:downward-function))
	       (apply function key value args))
	   table))
(defmethod (get-entries collect-hash) (function)
  (declare (sys:downward-funarg function))
  (maphash #'(lambda (key value)
	       (declare (sys:downward-function))
	       (get-entries-from-components
		 value
		 #'(lambda (&rest args)
		     (apply function key args))))
	   table))
(defmethod (ncomponents collect-hash) ()
  (send table :filled-elements))
(defmethod (member-of-collection collect-hash) (key)
  (multiple-value-bind (value found)
      (gethash key table)
    (ignore value)
    found))

(setf (collector-type-sample-instance
	(find-collector-type 'collect-hash))
      (make-data-collector 'collect-hash :component-description '()))


;;;;;;;;;;;;;;;;

#||
(defflavor hack-circular-buffer-with-compression
	((a (make-array 4000. :fill-pointer 0 :area metering-area))
	 (wrapped nil)
	 (region-seperator-duplicate (ncons nil))
	 (last-entry nil)
	 (duplicate-count))
	(event-trace))


;; no get-form-to-collect-data yet.

(defmethod (collect-data hack-circular-buffer-with-compression) (name &rest args)
  (let ((limit (zl:array-length a))
	(index (fill-pointer a)))
    (macrolet ((store (arg)
		 `(progn
		    (when ( index limit)
		      (setf wrapped 't)
		      (setf index 0))
		    (setf (aref a index) ,arg)
		    (incf index))))
      (if (and last-entry
	       (eql name last-name)
	       (loop for i = (if (eq (aref a last-entry)
				     region-seperator-same-name)
				 (mod (1+ last-entry) limit)
				 (mod (+ last-entry 2) limit))
			   then (mod (1+ i) limit)
		     as old-arg = (aref a i)
		     for arg in args
		     always (equal arg old-arg)))
	  (setf duplicate-count (if duplicate-count (1+ duplicate-count) 1))
	  (when duplicate-count
	    (store region-seperator-duplicate)
	    (store duplicate-count)
	    (setf duplicate-count nil))
	  (setf last-entry (mod index limit))
	  (if (eql name last-name)
	      (store region-seperator-same-name)
	      (store region-seperator)
	      (store name)
	      (setq last-name name))
	  (loop for arg in args do
	    (store (copy-list-if-necessary arg)))
	  (setf (fill-pointer a) index)))))

(defmethod (reset hack-circular-buffer-with-compression) ()
  (setf last-name nil)
  (setf wrapped nil)
  (setf last-entry nil)
  (setf duplicate-count nil)
  (setf (fill-pointer a) 0))

(defmethod (display hack-circular-buffer-with-compression) (&optional (s 't))
  (format s "~%")
  (loop with name = 'name-not-known-yet
	with maybe-name = (cons 'name-not-known-yet-but-maybe last-name)
	with next-entry-is-name = nil
	with data-border = (fill-pointer a)
	with size = (array-total-size a)
	with limit = (if (zerop data-border)
			 (if wrapped size 0)
			 (1- data-border))
	for index = (if wrapped data-border 0)
		  then (let ((next (1+ index)))
			 (if ( next size) 0 next))
	as entry = (aref a index)
	initially (unless (member entry
				  (list region-seperator region-seperator-same-name))
		    (format s " ~D: " index))
	while (or wrapped (< index data-border))
	do (cond ((eq entry region-seperator)
		  (format s "~& ~D: " index)
		  (setq next-entry-is-name 't))
		 ((eq entry region-seperator-same-name)
		   (format s "~& ~D: ~S " index (if (eq name 'name-not-known-yet)
						    maybe-name
						    name))
		   (setq next-entry-is-name nil))
		 ((eq entry region-seperator-duplicate)
		  (format s "~&    repeated additional times: "))
		 (t
		  (when next-entry-is-name
		    (setq name entry))
		  (setq next-entry-is-name nil)
		  (format s "~S " entry)))
	until (= index limit)
	finally (when (and (numberp duplicate-count) (plusp duplicate-count))
		  (format s "~&    repeated ~D additional times." duplicate-count))))

(defmethod (get-entries hack-circular-buffer-with-compression) (f)
  (let ((size (array-total-size a)))
    (macrolet ((next-index (index) `(mod (1+ ,index) size)))
      (loop with arglist = nil
	    with duplicate-count = nil
	    with name = 'name-not-known-yet
	    with maybe-name = (cons 'name-not-known-yet-but-maybe last-name)
	    with data-border = (fill-pointer a)
	    with limit = (if (zerop data-border)
			     (if wrapped size 0)
			     (1- data-border))
	    for index = (if wrapped data-border 0) then (next-index index)
	    as entry = (aref a index)
	    while (or wrapped (< index data-border))
	    do (cond ((eq entry region-seperator)
		      (apply f duplicate-count (nreverse arglist))
		      (setq duplicate-count nil)
		      (setf index (next-index index))
		      (setq name (aref a index))
		      (setq arglist (ncons name)))
		     ((eq entry region-seperator-same-name)
		      (apply f duplicate-count (nreverse arglist))
		      (setq duplicate-count nil)
		      (setq arglist (ncons (if (eq name 'name-not-known-yet)
					       maybe-name
					       name))))
		     ((eq entry region-seperator-duplicate)
		      (setf index (mod (1+ index) size))
		      (setf duplicate-count (aref a index)))
		     (t (push entry arglist)))
	    until (= index limit)
	    finally (when arglist
		      (apply f duplicate-count (nreverse arglist)))))))

||#
;;;
#| example |
(let ((interesting 0)
      (count 0))
  (metering:get-entries
    metering:*general-cb*
    #'(lambda (duplicates &rest args)
	(INCF count (if duplicates (1+ duplicates) 1))
	(let ((type (car args)))
	  (if (member type '(si:process-switch metering:bad))
	      (setf interesting 3)
	      (decf interesting))
	  (when (plusp interesting)
	    (format t "~&~D: ~S" count type)
	    (loop for arg in (cdr args) do
	      (format t " ~S" arg)))))))
||#

(defflavor event-trace-with-interlocking
	()
	(event-trace multiple-process-collector-mixin))

#||
(defflavor event-trace-with-compression-and-multiple-processes
	()
	(hack-circular-buffer-with-compression multiple-process-collector-mixin))
||#

;;;;

#| (defflavor pc-metering-collector () (basic-collector)) |#






