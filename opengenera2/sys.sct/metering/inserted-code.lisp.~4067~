;;; -*- Mode: LISP; Syntax: Common-lisp; Package: METERING; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
#||

;; now these 6 functions are in sys:metering;metering-macros.

;; Actual meat of creating a metering point.
(defmacro define-metering-point
	  ((name &optional description warn-about-duplicates?
		 &key (env '(:process :scheduler))
		 conditions)
	   arglist &body forms)
  (ignore warn-about-duplicates?)
  (let ((number-of-args (length arglist)))
    (unless (= (length forms) number-of-args)
      (cl:warn '(:error 't)
	       "There are only ~D forms, but ~D arguments that need values"
	       (length forms)
	       number-of-args))
    (let* ((trigger-type (if conditions 'restricted-trigger 'trigger))
	   (trigger-variable-name
	     (find-trigger-variable-name name trigger-type arglist description))
	   (controlling-switch (gensym))
	   (start-time (gensym))
	   (test-trigger-variable-name (gensym))
	   (update-overhead
	     `(unless ancestor-collecting-overhead?
		,(cond
		   ((and (member :process env) (member :scheduler env))
		    `(if si:*current-process*
			 (si:incf* (metering:process-metering-overhead si:*current-process*)
				   (sys:%32-bit-difference (sys:%microsecond-clock)
							   ,start-time))
			 (si:incf* si:*scheduler-metering-overhead*
				   (sys:%32-bit-difference (sys:%microsecond-clock)
							   ,start-time))))
		   ((member :process env)
		    `(si:incf* (metering:process-metering-overhead si:*current-process*)
			       (sys:%32-bit-difference (sys:%microsecond-clock) ,start-time)))
		   ((member :scheduler env)
		    `(si:incf* si:*scheduler-metering-overhead*
			       (sys:%32-bit-difference (sys:%microsecond-clock)
						       ,start-time)))))))
      (when conditions
	(append-cautions-from-conditions (eval trigger-variable-name) conditions))
      `(progn
	 ;; A wart on the side of the compiler:  Why isn't there a better way to determine
	 ;; whether a form is being compiled into a file or not?
	 ,@(when (AND (VARIABLE-BOUNDP COMPILER:*BINARY-OUTPUT-STREAM*)
		      COMPILER:*BINARY-OUTPUT-STREAM*)
	     `((let ((dummy
		',(cons
		 COMPILER:EVAL-AT-LOAD-TIME-MARKER
		 `(let ((,test-trigger-variable-name
			 (find-trigger-variable-name ',name ',trigger-type ',arglist ',description)))
		    (when (not (eql ,test-trigger-variable-name ',trigger-variable-name))
		      (if (variable-boundp ,trigger-variable-name)
			  (warn (:bad-style 't)
				"This function contains a metering point that is incompatible with the current world.~\
It probably won't work to meter this.   Recompiling will fix this.")
			  (setq ,trigger-variable-name ,test-trigger-variable-name)))))))
		 (ignore dummy))))
	 (locally
	   (declare (special ,trigger-variable-name))

	   (let ((,start-time (sys:%microsecond-clock)))
	     (when (and *metering-enabled*
			(not *metering-overhead-accounted*)
			,trigger-variable-name)
	       (let* ((ancestor-collecting-overhead? *metering-overhead-accounted*)
		      (*metering-overhead-accounted* 't)
		      (,controlling-switch (trigger-control ,trigger-variable-name))
		      ;; avoid recursive metering.
		      (*metering-enabled* nil))
		 (when (and ,controlling-switch
			    (let ((state (control-state ,controlling-switch)))
			      (or (eq state 't)
				  (and state (metering-enabled? ,controlling-switch)))))
		   ;; maybe we should evaluate the forms in a let, so we can meter them also?
		   (when (and (trigger-collector-function ,trigger-variable-name)
			      (or (null (trigger-filter1 ,trigger-variable-name))
				  (funcall (trigger-filter1 ,trigger-variable-name)
					   ,@forms)))
		     (funcall (trigger-generator-function ,trigger-variable-name)
			      (trigger-collector-function ,trigger-variable-name)
			      ,start-time
			      ,@forms)))
		 ,update-overhead))))))))

(defsubst funcall-in-region (region closure)
  (declare (dbg:error-reporter))
  (unwind-protect
      (progn
	(enter-region region)
	(funcall closure))
    (exit-region region)))

(defsubst apply-in-region (region closure args
				  &optional
				  (accounted metering::*metering-overhead-accounted*))
  (declare (dbg:error-reporter))
  (unwind-protect
      (progn
	(enter-region region)
	(let ((metering::*metering-overhead-accounted* accounted))
	  (apply closure args)))
    (exit-region region)))

(defmacro apply-in-region-1 (region closure args
			     &optional
			     (accounted metering::*metering-overhead-accounted*)
			     (wired nil))
  `(let ((.region. ,region))
     (unwind-protect
	 (progn
	   (enter-region .region.)
	   (,(if wired 'metering:aux-stack-bind 'let)
	    ((metering::*metering-overhead-accounted* ,accounted))
	    (apply ,closure ,args)))
       (exit-region .region.))))

(defmacro meter-form
	  ((name &optional description warn-about-duplicates?
		 &key (env '(:process :scheduler))
		 conditions)
	   arglist
	   form
	   &body values-to-pass-on)
  (ignore warn-about-duplicates?)
  (let ((number-of-args (length arglist))
	(start-time (gensym))
	(continuation (gensym))
	(trigger-type (if conditions 'restricted-metering-region 'metering-region))
	(ancestor-collecting-overhead? (gensym)))
    (unless (= (length values-to-pass-on) number-of-args)
      (cl:warn '(:error 't)
	       "There are only ~D forms, but ~D arguments that need values"
	       (length values-to-pass-on)
	       number-of-args))
    (let ((trigger-variable-name
	    (find-trigger-variable-name
	      name trigger-type arglist description))
	  (test-trigger-variable-name (gensym))
	  (update-overhead
	    `(unless ,ancestor-collecting-overhead?
	       ,(cond
		  ((and (member :process env) (member :scheduler env))
		   `(if si:*current-process*
			(si:incf* (metering:process-metering-overhead si:*current-process*)
				  (sys:%32-bit-difference (sys:%microsecond-clock)
							  ,start-time))
			(si:incf* si:*scheduler-metering-overhead*
				  (sys:%32-bit-difference (sys:%microsecond-clock)
							  ,start-time))))
		  ((member :process env)
		   `(si:incf* (metering:process-metering-overhead si:*current-process*)
			      (sys:%32-bit-difference (sys:%microsecond-clock) ,start-time)))
		  ((member :scheduler env)
		   `(si:incf* si:*scheduler-metering-overhead*
			      (sys:%32-bit-difference (sys:%microsecond-clock)
						      ,start-time)))))))
      (when conditions
	(append-cautions-from-conditions (eval trigger-variable-name) conditions))
      `(progn
	 ;; A wart on the side of the compiler:  Why isn't there a better way to determine
	 ;; whether a form is being compiled into a file or not?
	 ,@(when (AND (VARIABLE-BOUNDP COMPILER:*BINARY-OUTPUT-STREAM*)
		      COMPILER:*BINARY-OUTPUT-STREAM*)
	     `((let ((dummy
		',(cons
		 COMPILER:EVAL-AT-LOAD-TIME-MARKER  
		 `(let ((,test-trigger-variable-name
		       (find-trigger-variable-name
			 ',name ',trigger-type ',arglist ',description)))
		  (when (not (eql ,test-trigger-variable-name ',trigger-variable-name))
		    (if (variable-boundp ,trigger-variable-name)
			(warn (:bad-style 't)
			      "This function contains a metering point that is incompatible with the current world.~\
It probably won't work to meter this.   Recompiling will fix this.")
			(setq ,trigger-variable-name ,test-trigger-variable-name)))
		  ,test-trigger-variable-name))))
		 (ignore dummy))))
	 ;; To do: figure out when we can avoid the closure - i.e. volume of code isn't too
	 ;; high.  walk the code, macroexpand all, check size?
	 (locally
	   (declare (special ,trigger-variable-name))
	   (let ((,start-time (sys:%microsecond-clock)))
	     (if (and *metering-enabled*
		      ,trigger-variable-name)
		 (let* ((,ancestor-collecting-overhead? *metering-overhead-accounted*)
			(*metering-overhead-accounted* 't)
			(controlling-switch (trigger-control ,trigger-variable-name))
			(region (trigger-active-region ,trigger-variable-name))
			#||(*metering-enabled* nil)||#)
		   ;; we use nested FLET's rather than a single LABELS so that we don't
		   ;; shadow the symbol CLOSURE-OF-FORM inside ,form.
		   (multiple-value-prog1
		     (flet ((closure-of-form ()
			      (declare (sys:downward-function))
			      ,update-overhead
			      (let ((*metering-overhead-accounted*
				      ,ancestor-collecting-overhead?))
				(multiple-value-prog1
				  #||
				  (let ((*metering-enabled* 't))
				    ,form)
				  ||#
				  ,form
				  (setf ,start-time (sys:%microsecond-clock))))))
		       (if (and controlling-switch
				(not ,ancestor-collecting-overhead?)
				(let ((state (control-state controlling-switch)))
				  (or (eq state 't)
				      (and state (metering-enabled? controlling-switch)))))
			   (flet ((metered-closure-of-form (,continuation)
				    (declare (sys:downward-function))
				    (multiple-value-prog1
				      (if region
					  (funcall-in-region region #'closure-of-form)
					  (progn
					    ,update-overhead
					    (let ((*metering-overhead-accounted*
						    ,ancestor-collecting-overhead?))
					      (multiple-value-prog1
						#||
						(let ((*metering-enabled* t))
						  ,form)
						||#
						,form
						(setf ,start-time
						      (sys:%microsecond-clock))))))
				      (when (or (null (trigger-filter1 ,trigger-variable-name))
						(funcall (trigger-filter1 ,trigger-variable-name)
							 ,@values-to-pass-on))
					(funcall ,continuation
						 ,start-time ,@values-to-pass-on)))))
			     (funcall (trigger-generator-function ,trigger-variable-name)
				      #'metered-closure-of-form
				      (trigger-initial-collector-function
					,trigger-variable-name)
				      (trigger-collector-function ,trigger-variable-name)
				      (trigger-compute-differences ,trigger-variable-name)
				      ,start-time))
			   (if region 
			       (funcall-in-region region #'closure-of-form)
			       (closure-of-form))))
		     ,update-overhead))
		   ,form)))))))

(zwei:defindentation (meter-form 2 3 3 1))


(defmacro start-metering-interval
	  ((name &optional description warn-about-duplicates?
		 &key (env '(:process :scheduler))
		 conditions)
	   arglist
	   &body forms)
  (ignore warn-about-duplicates?)
  (let ((number-of-args (length arglist))
	(start-time (gensym))
	(trigger-type (if conditions
			  '(restricted-metering-interval :initial)
			  '(metering-interval :initial)))
	(ancestor-collecting-overhead? (gensym)))
    (unless (= (length forms) number-of-args)
      (cl:warn '(:error 't)
	       "There are only ~D forms, but ~D arguments that need values"
	       (length forms)
	       number-of-args))
    (let ((trigger-variable-name
	    (find-trigger-variable-name
	      name trigger-type arglist description))
	  (trigger (gensym))
	  (test-trigger-variable-name (gensym))
	  (update-overhead
	    `(unless ,ancestor-collecting-overhead?
	       ,(cond
		  ((and (member :process env) (member :scheduler env))
		   `(if si:*current-process*
			(si:incf* (metering:process-metering-overhead si:*current-process*)
				  (sys:%32-bit-difference (sys:%microsecond-clock)
							  ,start-time))
			(si:incf* si:*scheduler-metering-overhead*
				  (sys:%32-bit-difference (sys:%microsecond-clock)
							  ,start-time))))
		  ((member :process env)
		   `(si:incf* (metering:process-metering-overhead si:*current-process*)
			      (sys:%32-bit-difference (sys:%microsecond-clock) ,start-time)))
		  ((member :scheduler env)
		   `(si:incf* si:*scheduler-metering-overhead*
			      (sys:%32-bit-difference (sys:%microsecond-clock)
						      ,start-time)))))))
      (when conditions
	(append-cautions-from-conditions (eval trigger-variable-name) conditions))
      `(progn
	 ;; A wart on the side of the compiler:  Why isn't there a better way to determine
	 ;; whether a form is being compiled into a file or not?
	 ,@(when (AND (VARIABLE-BOUNDP COMPILER:*BINARY-OUTPUT-STREAM*)
		      COMPILER:*BINARY-OUTPUT-STREAM*)
	     `((let ((dummy
		       ',(cons
			   COMPILER:EVAL-AT-LOAD-TIME-MARKER  
			   `(let ((,test-trigger-variable-name
				   (find-trigger-variable-name
				     ',name ',trigger-type ',arglist ',description)))
			      (when (not (eql ,test-trigger-variable-name ',trigger-variable-name))
				(if (variable-boundp ,trigger-variable-name)
				    (warn (:bad-style 't)
					  "This function contains a metering point that is incompatible with the current world.~\
It probably won't work to meter this.   Recompiling will fix this.")
				    (setq ,trigger-variable-name ,test-trigger-variable-name)))
			      ,test-trigger-variable-name))))
		 (ignore dummy))))
	 (locally
	   (declare (special ,trigger-variable-name))
	   (let* ((,start-time (sys:%microsecond-clock))
		   (,ancestor-collecting-overhead? *metering-overhead-accounted*)
		   (*metering-overhead-accounted* 't)
		   (,trigger ,trigger-variable-name))
	      (when (and *metering-enabled* (not ,ancestor-collecting-overhead?) ,trigger)
		(let ((*metering-enabled* nil))
		  (when (and (or *metering-stack*
				 (process-meter-stack scl:*current-process*))
			     (let ((control (trigger-control ,trigger)))
			       (and control
				    (let ((state (control-state control)))
				      (or (eq state 't)
					  (and state
					       (metering-enabled? control)))))))
		    (when (or (null (trigger-filter3 ,trigger))
			      (funcall (trigger-filter3 ,trigger) ,@forms))
		      (incf (trigger-interval-depth ,trigger))
		      (if (trigger-initial-generator-function ,trigger)
			  (let ((*metering-stack* (or *metering-stack*
						      (process-meter-stack scl:*current-process*))))
			    (funcall (trigger-initial-generator-function ,trigger)
				     (trigger-initial-collector-function ,trigger)
				     ,start-time ,@forms))
			  (when (trigger-initial-collector-function ,trigger)
			    (funcall (trigger-initial-collector-function ,trigger)
				     ,@forms)))))))
	      ,update-overhead)
	   (values))))))

(defmacro end-metering-interval 
	  ((name &optional description warn-about-duplicates?
		 &key (env '(:process :scheduler))
		 conditions)
	   arglist
	   &body forms)
  (ignore warn-about-duplicates?)
  (let ((number-of-args (length arglist))
	(start-time (gensym))
	(trigger-type (if conditions
			  '(restricted-metering-interval :final)
			  '(metering-interval :final)))
	(ancestor-collecting-overhead? (gensym)))
    (unless (= (length forms) number-of-args)
      (cl:warn '(:error 't)
	       "There are only ~D forms, but ~D arguments that need values"
	       (length forms)
	       number-of-args))
    (let ((trigger-variable-name
	    (find-trigger-variable-name
	      name trigger-type arglist description))
	  (trigger (gensym))
	  (test-trigger-variable-name (gensym))
	  (update-overhead
	    `(unless ,ancestor-collecting-overhead?
	       ,(cond
		  ((and (member :process env) (member :scheduler env))
		   `(if si:*current-process*
			(si:incf* (metering:process-metering-overhead si:*current-process*)
				  (sys:%32-bit-difference (sys:%microsecond-clock)
							  ,start-time))
			(si:incf* si:*scheduler-metering-overhead*
				  (sys:%32-bit-difference (sys:%microsecond-clock)
							  ,start-time))))
		  ((member :process env)
		   `(si:incf* (metering:process-metering-overhead si:*current-process*)
			      (sys:%32-bit-difference (sys:%microsecond-clock) ,start-time)))
		  ((member :scheduler env)
		   `(si:incf* si:*scheduler-metering-overhead*
			      (sys:%32-bit-difference (sys:%microsecond-clock)
						      ,start-time)))))))
      (when conditions
	(append-cautions-from-conditions (eval trigger-variable-name) conditions))
      `(progn
	 ;; A wart on the side of the compiler:  Why isn't there a better way to determine
	 ;; whether a form is being compiled into a file or not?
	 ,@(when (AND (VARIABLE-BOUNDP COMPILER:*BINARY-OUTPUT-STREAM*)
		      COMPILER:*BINARY-OUTPUT-STREAM*)
	     `((let ((dummy
		       ',(cons
			   COMPILER:EVAL-AT-LOAD-TIME-MARKER  
			   `(let ((,test-trigger-variable-name
				   (find-trigger-variable-name
				     ',name ',trigger-type ',arglist ',description)))
			      (when (not (eql ,test-trigger-variable-name ',trigger-variable-name))
				(if (variable-boundp ,trigger-variable-name)
				    (warn (:bad-style 't)
					  "This function contains a metering point that is incompatible with the current world.~\
It probably won't work to meter this.   Recompiling will fix this.")
				    (setq ,trigger-variable-name ,test-trigger-variable-name)))
			      ,test-trigger-variable-name))))
		 (ignore dummy))))
	 (locally
	   (declare (special ,trigger-variable-name))
	   (let* ((,start-time (sys:%microsecond-clock))
		   (,ancestor-collecting-overhead? *metering-overhead-accounted*)
		   (*metering-overhead-accounted* 't)
		   (,trigger ,trigger-variable-name))
	      (let ((stack (or *metering-stack* (process-meter-stack scl:*current-process*))))
		(when stack
		  ;; avoid recursive metering.
		  (if (and *metering-enabled*
			   (not ,ancestor-collecting-overhead?)
			   ,trigger
			   (let ((control (trigger-control ,trigger)))
			     (and control
				  #+ignore
				  (let ((state (control-state control)))
				    (or (eq state 't)
					(and state
					     (metering-enabled? control))))
				  #-ignore
				  (control-state control))))
		      (let ((*metering-enabled* nil))
			(if (or (null (trigger-filter1 ,trigger))
				(funcall (trigger-filter1 ,trigger) ,@forms))
			    (let ((*metering-stack* stack))
			      (funcall (trigger-generator-function ,trigger)
				       (trigger-compute-differences ,trigger)
				       (trigger-collector-function ,trigger)
				       ,start-time ,@forms))
			    (pop-frame stack)))
		      ;; cleanup is necessary, regardless of state of metering.
		      (pop-frame stack))
		  (when ,trigger
		    (decf (trigger-interval-depth ,trigger)))))
	      ,update-overhead)
	   (values))))))

(zwei:defindentation (start-metering-interval 2 3 3 1))
(zwei:defindentation (end-metering-interval 2 3 3 1))

||#




(defun encapsulate-function (function trigger types)
  (unencapsulate-function-from-metering function)
  (let ((e-types (get-encapsulation-types-from-types types))
	(conditions  (get-conditions-from-types types)))
    (cond ((and (member 'meter e-types) (member 'region e-types))
	   (encapsulate-function-for-metering-or-region function trigger conditions))
	  ((null e-types))
	  ((member 'meter e-types)
	   (encapsulate-function-for-metering function trigger conditions))
	  ((member 'region e-types)
	   (encapsulate-function-for-region function trigger conditions))
	  (t ;;;(unencapsulate-function-from-metering function))))
	   ))))

(defmacro aux-stack-bind (bindings &body body)
  (loop for var-val in bindings
	as temp = (gensym)
	as var = (car var-val)
	as val = (second var-val)
	collect (list temp var) into temps
	append var-val into initial-setfs
	append (list var temp) into final-setfs
	finally (return
		  `(let ,temps
		     (unwind-protect
			 (progn
			   (setf ,@initial-setfs)
			   ,@body)
		       (setf ,@final-setfs))))))

(defun trigger-iv-reference (iv-name wired)
  (if wired
      `(inline-instance-ref basic-trigger ,iv-name trigger-variable-name)
      `(,(intern (string-append "TRIGGER-" (string-upcase (string iv-name)))
		 (pkg-find-package 'metering))
	trigger-variable-name)))
(defvar *region-encapsulation-table* (make-hash-table :test #'equal :size 3))
;; For those functions in direct path of microcode-error-handler, check to make sure stack 
;; isn't in halt-on-error state, before you begin metering.
;;    (ZEROP (LDB SI:%%SG-HALT-ON-ERROR SI:%CURRENT-STACK-GROUP-STATUS-BITS))
;; For those functions in the direct path of transport-trap check to make sure that 
;; (NOT SYS:%TRANSPORT-IN-PROGRESS)
(COMPILER-LET (#+imach(COMPILER:*ENABLE-FRAME-SPLITTING* T))
(defun encapsulate-function-for-metering (function trigger &optional conditions)
  (let* ((current-definition (si:valid-function-definition function))
	 (key (list function :metering conditions current-definition))
	 (encapsulated-p (si:function-encapsulated-p function))
	 (saved-data (gethash key *region-encapsulation-table*)))
    (when (and saved-data (not encapsulated-p))
      (destructuring-bind (saved-definition saved-symbol saved-trigger) saved-data
	(when (eq (si:valid-function-definition saved-symbol) current-definition)
	  (fdefine function saved-definition nil t)
	  (setf (symbol-value saved-trigger) trigger)
	  (return-from encapsulate-function-for-metering saved-symbol))))
    (let* ((si:inhibit-fdefine-warnings 't)
	   (wired (member 'si:wired conditions))
	   (safeguarded (or (member 'si:safeguarded conditions)
			    (member 'si:gc-safe conditions)))
	   ;; for the time being constant.  Eventually check if this function is ever
	   ;; called in the scheduler.
	   (update-overhead
	     `(unless .ancestor-collecting-overhead?.
		(,@(if #+3600 wired #+IMACH nil
		       '(if (si:%auxiliary-stack-p)
			    (si:incf* %aux-stack-metering-overhead
				      (sys:%32-bit-difference (sys:%microsecond-clock)
							      .start-time.)))
		       '(progn))
		 (if process::*in-process-dispatcher*
		     (si:incf* si:*scheduler-metering-overhead*
			       (sys:%32-bit-difference (sys:%microsecond-clock)
						       .start-time.))
		     (si:incf* (process-metering-overhead process::%real-current-process)
			       (sys:%32-bit-difference (sys:%microsecond-clock)
						       .start-time.))))))
	   (filter1 (trigger-iv-reference 'filter1 wired))
	   (controller (trigger-iv-reference 'control wired))
	   (compute-differences (trigger-iv-reference 'compute-differences wired))
	   (generator-function (trigger-iv-reference 'generator-function wired))
	   (collector-function (trigger-iv-reference 'collector-function wired))
	   (initial-collector-function
	     (trigger-iv-reference 'initial-collector-function wired))
	   (state (if wired
		      `(inline-instance-ref basic-control state controller)
		      '(control-state controller)))
	   (new-trigger-symbol (or (ignore-errors (gentemp "TRIGGER" *package*))
				   (gentemp "TRIGGER")))
	   (new-symbol
           (progn
	     (setf (symbol-value new-trigger-symbol) trigger)
	     (si:encapsulate-and-compile
	       (si:unencapsulate-function-spec function 'si:meter)
	       function
	       'si:meter
	       `(cl:locally
		  (let* ((.start-time. (sys:%microsecond-clock))
			 (.ancestor-collecting-overhead?. *metering-overhead-accounted*)
			 (.old-function. ,si:encapsulated-function)
			 (.real-arglist. arglist))
		    (declare (special ,new-trigger-symbol))
		    (declare (inline metering:process-metering-overhead))
		    (if (and *metering-enabled*
			     (not .ancestor-collecting-overhead?.)
			     #+3600 (not sys:%transport-in-progress)
			     #+IMACH (zerop sI:%transport-trap-level))
			(,(if #+3600 wired #+IMACH nil 'aux-stack-bind 'let)
			 ((*metering-overhead-accounted* 't)
			  #||(*metering-enabled* nil)||#)
			 (let* ((trigger-variable-name ,new-trigger-symbol)
				(.frame-pointer. (global:%stack-frame-pointer))
				(controller ,controller)
				(funarg #'(lambda (continuation)
					    (declare (sys:downward-function))
					    ,@(when (or safeguarded wired)
						`((declare
						    (sys:unsafeguarded-reference
						      si:*scheduler-metering-overhead*
						      ,@(when safeguarded
							  '(metering-enabled?))))))
					    (multiple-value-call
					      (lambda (&rest values)
						(declare (sys:downward-function))
						(when (or (null ,filter1)
							  (funcall ,filter1
								   .frame-pointer.
								   ',function
								   .real-arglist.
								   values nil))
						  (funcall continuation
							   .start-time.
							   .frame-pointer.
							   ',function
							   .real-arglist. values nil))
						(,(if (or wired safeguarded)
						      'si:%values-list
						      'values-list) values))
					      (unwind-protect-case ()
						  (multiple-value-prog1
						    (,(if #+3600 wired #+IMACH nil
							  'aux-stack-bind
							  'let)
						     ((*metering-overhead-accounted*
							.ancestor-collecting-overhead?.)
						      #||(*metering-enabled* 't)||#)
						     ,update-overhead
						     (apply .old-function. .real-arglist.))
						    (setf .start-time.
							  (sys:%microsecond-clock)))
						(:abort
						  (setf .start-time. (sys:%microsecond-clock))
						  (when (or (null ,filter1)
							    (funcall ,filter1
								     .frame-pointer.
								     ',function
								     .real-arglist. nil t))
						    (funcall continuation
							     .start-time.
							     .frame-pointer.
							     ',function
							     .real-arglist.
							     nil
							     t))))))))
			   (if (and controller
				    ,(if wired
					 `(aref *wired-metering-control*
						,(trigger-control-variable trigger))
					 `(let ((state ,state))
					    (or (eq state 't)
						(and state
						     (metering-enabled? controller))))))
			       (multiple-value-prog1
				 (funcall ,generator-function
					  funarg
					  ,initial-collector-function
					  ,collector-function
					  ,compute-differences
					  .start-time.
					  .frame-pointer.
					  ',function
					  .real-arglist.)
				 ,update-overhead)
			       (progn
				 ,update-overhead
				 (setf *metering-overhead-accounted*
				       .ancestor-collecting-overhead?.)
				 #||(setf *metering-enabled* t)||#
				 (apply .old-function. .real-arglist.)))))
			(apply .old-function. .real-arglist.))))
	       (when (or wired conditions)
		 (cons
		   (cons 'si:encapsulation-conditions
			 (loop for condition in conditions
			       collect (list condition 't)))
		   (when (or wired safeguarded)
		     (ncons
		       `(sys:unsafeguarded-reference
			  si:*scheduler-metering-overhead*)))))))))
      (unless encapsulated-p
	(setf (gethash (list function :metering conditions current-definition)
		       *region-encapsulation-table*)
	      (list (si:valid-function-definition function) new-symbol new-trigger-symbol)))
      new-symbol
      )))
)
(COMPILER-LET (#+imach(COMPILER:*ENABLE-FRAME-SPLITTING* T))
(defun encapsulate-function-for-region (function trigger &optional conditions)
  (let* ((current-definition (si:valid-function-definition function))
	 (key (list function :region conditions current-definition))
	 (encapsulated-p (si:function-encapsulated-p function))
	 (saved-data (gethash key *region-encapsulation-table*)))
    (when (and saved-data (not encapsulated-p))
      (destructuring-bind (saved-definition saved-symbol saved-trigger) saved-data
	  (when (eq (si:valid-function-definition saved-symbol) current-definition)
	    (fdefine function saved-definition nil t)
	    (setf (symbol-value saved-trigger) trigger)
	    (return-from encapsulate-function-for-region saved-symbol))))
    (let* ((si:inhibit-fdefine-warnings 't)
	   (wired (member 'si:wired conditions))
	   (new-trigger-symbol (or (ignore-errors (gentemp "TRIGGER" *package*))
				   (gentemp "TRIGGER")))
	   (new-symbol
	     (progn
	       (setf (symbol-value new-trigger-symbol) trigger)
	     (si:encapsulate-and-compile
	       (si:unencapsulate-function-spec function 'si:meter)
	       function
	       'si:meter
	       `(cl:locally
		  (let ((.old-function. ,si:encapsulated-function)
			(.real-arglist. arglist))
		    (declare (special ,new-trigger-symbol))
		    (if (and *metering-enabled*
			     #+3600 (not sys:%transport-in-progress)
			     #+IMACH (zerop si:%transport-trap-level)
			     #+3600
			     ,@(when (member 'si:wired conditions)
				 '((not (si:%auxiliary-stack-p)))))
			(let* ((trigger-variable-name ,new-trigger-symbol)
			       (region (trigger-active-region trigger-variable-name))
			       (.accounted?. metering::*metering-overhead-accounted*)
			       (metering::*metering-overhead-accounted* t))
			  (if region
			      (apply-in-region-1 region .old-function. .real-arglist. .accounted?. ,wired)
			      (apply .old-function. .real-arglist.)))
			(apply .old-function. .real-arglist.))))
	       (when conditions
		 (ncons
		   (cons 'si:encapsulation-conditions
			 (loop for condition in conditions
			       collect (list condition 't)))))))))
      (unless encapsulated-p
	(setf (gethash (list function :region conditions current-definition)
		       *region-encapsulation-table*)
	      (list (si:valid-function-definition function) new-symbol new-trigger-symbol)))
      new-symbol)))
)
(COMPILER-LET (#+imach(COMPILER:*ENABLE-FRAME-SPLITTING* T))
(defun encapsulate-function-for-metering-or-region (function trigger &optional conditions)
  (let* ((current-definition (si:valid-function-definition function))
	 (key (list function :metering-or-region conditions current-definition))
	 (encapsulated-p (si:function-encapsulated-p function))
	 (saved-data (gethash key *region-encapsulation-table*)))
    (when (and saved-data (not encapsulated-p))
      (destructuring-bind (saved-definition saved-symbol saved-trigger) saved-data
	  (when (eq (si:valid-function-definition saved-symbol) current-definition)
	    (fdefine function saved-definition nil t)
	    (setf (symbol-value saved-trigger) trigger)
	    (return-from encapsulate-function-for-metering-or-region saved-symbol))))
  (let* ((si:inhibit-fdefine-warnings 't)
	 (wired (member 'si:wired conditions))
	 (safeguarded (or (member 'si:gc-safe conditions)
			  (member 'si:safeguarded conditions)))
	 (update-overhead
	   `(unless .ancestor-collecting-overhead?.
	      (,@(if #+3600 wired #+IMACH nil
		     '(if (si:%auxiliary-stack-p)
			  (si:incf* %aux-stack-metering-overhead
				    (sys:%32-bit-difference (sys:%microsecond-clock)
							    .start-time.)))
		     '(progn))
	       (if process::*in-process-dispatcher*
		   (si:incf* si:*scheduler-metering-overhead*
			     (sys:%32-bit-difference (sys:%microsecond-clock)
						     .start-time.))
		   (si:incf* (process-metering-overhead process::%real-current-process)
			     (sys:%32-bit-difference (sys:%microsecond-clock)
						     .start-time.))))))
	 (filter1 (trigger-iv-reference 'filter1 wired))
	 (controller (trigger-iv-reference 'control wired))
	 (compute-differences (trigger-iv-reference 'compute-differences wired))
	 (generator-function (trigger-iv-reference 'generator-function wired))
	 (collector-function (trigger-iv-reference 'collector-function wired))
	 (initial-collector-function
	   (trigger-iv-reference 'initial-collector-function wired))
	 (active-region (trigger-iv-reference 'active-region wired))
	 (state (if wired
		    `(inline-instance-ref basic-control state controller)
		    '(control-state controller)))
	 (new-trigger-symbol (or (ignore-errors (gentemp "TRIGGER" *package*))
				 (gentemp "TRIGGER")))
	 (new-symbol
  (progn
    (setf (symbol-value new-trigger-symbol) trigger)
    (si:encapsulate-and-compile
      (si:unencapsulate-function-spec function 'si:meter)
      function
      'si:meter
      `(cl:locally
	 (let* ((.start-time. (sys:%microsecond-clock))
		(.ancestor-collecting-overhead?. *metering-overhead-accounted*)
		(.old-function. ,si:encapsulated-function)
		(.real-arglist. arglist))
	   (declare (special ,new-trigger-symbol))
	   (declare (inline metering:process-metering-overhead))
            (if (and *metering-enabled*
		     #+3600 (NOT (SYS:%TRANSPORT-IN-PROGRESS))
		     #+IMACH (ZEROP si:%transport-TRAP-LEVEL))
		(,(if #+3600 wired #+imach nil 'aux-stack-bind 'let)
		 ((*metering-overhead-accounted* 't)
		  #||(*metering-enabled* nil)||#)
		 (let* ((trigger-variable-name ,new-trigger-symbol)
		       (controller ,controller)
		       (region ,active-region)
		       (.frame-pointer. (global:%stack-frame-pointer))
		       (funarg #'(lambda (continuation)
				   (declare (sys:downward-function))
				   (declare
				     (sys:unsafeguarded-reference
				       si:*scheduler-metering-overhead*
				       ,@(when safeguarded
					   '(metering-enabled?))))
				   (multiple-value-call
				     (lambda (&rest values)
				       (declare (sys:downward-function))
				       (when (or (null ,filter1)
						 (funcall ,filter1
							  .start-time.
							  .frame-pointer.
							  ',function .real-arglist. values
							  nil))
					 (funcall continuation
						  .start-time.
						  .frame-pointer.
						  ',function .real-arglist. values nil))
				       (,(if (or wired safeguarded)
					     'si:%values-list 'values-list) values))
				     (unwind-protect-case ()
					 (multiple-value-prog1
					   (if region
					       (apply-in-region-1
						 region (progn ,update-overhead
							       .old-function.)
						 .real-arglist.
						 .ancestor-collecting-overhead?. ,wired)
					       (,(if wired 'aux-stack-bind 'let)
						((*metering-overhead-accounted*
						   .ancestor-collecting-overhead?.)
						 #||(*metering-enabled* 't)||#)
						,update-overhead
						(apply .old-function. .real-arglist.)))
					   (setf .start-time. (sys:%microsecond-clock)))
				       (:abort
					 (setf .start-time. (sys:%microsecond-clock))
					 (when (or (null ,filter1)
						   (funcall ,filter1
							    .start-time.
							    .frame-pointer.
							    ',function .real-arglist. nil t))
					   (funcall continuation
						    .start-time.
						    .frame-pointer.
						    ',function .real-arglist. nil t))))))))
		  (if (and controller
			   (not .ancestor-collecting-overhead?.)
			 ,(if wired
			      `(aref *wired-metering-control*
				     ,(trigger-control-variable trigger))
			      `(let ((state ,state))
				 '(or (eq state 't)
				      (and state (metering-enabled? controller))))))
		    (multiple-value-prog1
		      (funcall ,generator-function
			       funarg
			       ,initial-collector-function
			       ,collector-function
			       ,compute-differences
			       .start-time.
			       .frame-pointer.
			       ',function
			       .real-arglist.)
		      ,update-overhead)
		    (if region
			(apply-in-region-1 region (progn ,update-overhead .old-function.)
					   .real-arglist.
					   .ancestor-collecting-overhead?. ,wired)
			(progn
			  (setf *metering-overhead-accounted*
				.ancestor-collecting-overhead?.)
			  #||(setf *metering-enabled* 't)||#
			  ,update-overhead
			  (apply .old-function. .real-arglist.))))))
	    (apply .old-function. .real-arglist.))))
      (when (or wired conditions)
	(cons
	  (cons 'si:encapsulation-conditions
		(loop for condition in conditions
		      collect (list condition 't)))
	  (when (or wired safeguarded)
	     (ncons
	       `(sys:unsafeguarded-reference
		  si:*scheduler-metering-overhead*)))))))))
      (unless encapsulated-p
	(setf (gethash (list function :metering-or-region conditions current-definition)
		       *region-encapsulation-table*)
	      (list (si:valid-function-definition function) new-symbol new-trigger-symbol)))
      new-symbol)))
)
(defun unencapsulate-function-from-metering (function-desc)
  (let* ((spec1 (si:unencapsulate-function-spec function-desc 'si:meter))
	 (spec2 (si:unencapsulate-function-spec spec1 '(si:meter))))
    (and (neq spec1 spec2)
	 ;; make sure it is unencapsulated
	 (fdefine spec1 (fdefinition spec2)))))

(defun (si:meter si:encapsulation-grind-function) (function def width real-io untyo-p)
  (ignore def width untyo-p)
  (when (function-metered-p function)
    (multiple-value-bind (trigger function-name)
	(find-metered-function-trigger function)
      (cl:pprint
	`(meter ,function-name
		(let ((trigger ,trigger))
		  (if (and *metering-enabled*
			   (metering-enabled? (trigger-control trigger)))
		      (meter trigger
			     #'(lambda (continuation)
				 (multiple-value-call
				   (lambda (&rest values)
				     (funcall continuation
					      frame-pointer
					      ,function-name
					      arglist
					      returned-values)
				     (values-list values))
				   (apply real-function arglist))))
		      (apply real-function arglist))))
	real-io))))

(defvar *meter-function-entry-counter* 0)
(defvar *meter-function-exit-counter* 0)

#||
;; now in metering-definitions, so 
(defvar *bad-meter-bit-traps* nil)
||#
(add-initialization "setup *bad-meter-bit-traps* collector"
		    '(setf *bad-meter-bit-traps*
			   (make-data-collector
			     'event-trace :circular 't))
		    ()
		    '*metering-cold-initializations*)
;; The function trap code is now in SYS:DEBUGGER;FUNCTION-TRAP.LISP

;;;

;;; This code is for custom written generator functions.  It is out of date, but will
;;; probably be fixed for a future release.

(defmacro define-metering-generator (name lambda-list values-list &body body)
  (let* ((pass-through (eq (car (last values-list)) :pass-through))
	 (passed-args (loop for rest-of-args on lambda-list by #'cdr
			    do (when (eq (car rest-of-args) '&rest)
				 (return (cadr rest-of-args)))))
	 (number-of-values-to-yield (if pass-through
					(1- (length values-list))
					(length values-list))))
    (when (and pass-through (not passed-args))
      (error ":PASS-THROUGH requires an &REST argument to pass through."))
    `(defun ,name (.continuation. .first-realtime. ,@lambda-list)
       (declare (values ,@values-list))
       (ignore .first-realtime.)
       (macrolet ((yield (&rest generated-values)
		    (unless (= (length generated-values)
			       ,number-of-values-to-yield)
		      (error "Yielded ~D values.  ~D expected."
			     (length generated-values)
			     ,number-of-values-to-yield))
		    ,(if pass-through
			 ``(apply .continuation. ,@generated-values ,',passed-args)
			 '`(funcall .continuation. ,@generated-values))))
	 ,@body))))

(defmacro define-metering-region-generator (name lambda-list initial-values values-list
					    &body body)
  (let* ((pass-through (eq (car (last values-list)) :pass-through))
	 (passed-args (loop for rest-of-args on lambda-list by #'cdr
			    do (when (eq (car rest-of-args) '&rest)
				 (return (cadr rest-of-args)))))
	 (number-of-values-to-yield (if pass-through
					(1- (length values-list))
					(length values-list)))
	 (number-of-initial-values-to-yield (length initial-values))
	 (continuation (gensym)))
    (when (and pass-through (not passed-args))
      (error ":PASS-THROUGH requires an &REST argument to pass through."))
    `(defun ,name (.continuation. .collect-initial-values. .collect-final-values.
		   .compute-changes. .first-realtime.)
       (declare (arglist ,@lambda-list))
       (declare (values ,@values-list))
       (declare (initial-values ,@initial-values))
       (ignore .first-realtime. .compute-changes.)
       (macrolet ((yield (&rest generated-values)
		    ,(if initial-values
			 `(if (= (length generated-values)
				 ,number-of-initial-values-to-yield)
			      `(when .collect-initial-values.
				 ;; avoid recursive metering
				 (let ((*metering-enabled* nil))
				   (funcall .collect-initial-values. ,@generated-values)))
			      (error "YIELDed ~D values in initial form.  ~D expected."
				     (length generated-values)
				     ,number-of-initial-values-to-yield))
			 `(error "Can't YIELD in initial form if no initial values are declared.")))
		  (eval-after-form (&body after)
		    `(macrolet ((yield (&rest generated-values)
				  (unless (= (length generated-values)
					     ,,number-of-values-to-yield)
				    (error "Yielded ~D values.  ~D expected."
					   (length generated-values)
					   ,,number-of-values-to-yield))
				  ,(if ,pass-through
				       '`(apply .collect-final-values.
						,@generated-values ,',passed-args)
				       '`(funcall .collect-final-values.
						  ,@generated-values))))
		       (flet ((,',continuation (.first-realtime. ,',@lambda-list)
			       (declare (sys:downward-function))
			       (ignore .first-realtime.)
			       ;; avoid recursive metering
			       (let ((*metering-enabled* nil))
				 ,@after)))
			 (funcall .continuation. #',',continuation)))))
	 ,@body))))

;; this macro will define a function that returns the two 
(defmacro define-metering-interval-generator (name lambda-list initial-values values-list
					    &body body)
  (let* ((pass-through (eq (car (last values-list)) :pass-through))
	 (passed-args (loop for rest-of-args on lambda-list by #'cdr
			    do (when (eq (car rest-of-args) '&rest)
				 (return (cadr rest-of-args)))))
	 (number-of-values-to-yield (if pass-through
					(1- (length values-list))
					(length values-list)))
	 (number-of-initial-values-to-yield (length initial-values))
	 (references (make-hash-table))
	 (continuation (gensym)))
    (when (and pass-through (not passed-args))
      (error ":PASS-THROUGH requires an &REST argument to pass through."))
    `(defun ,name (.continuation. .collect-initial-values. .collect-final-values.
		   .compute-changes. .first-realtime.)
       (declare (arglist ,@lambda-list))
       (declare (values ,@values-list))
       (declare (initial-values ,@initial-values))
       (ignore .first-realtime. .compute-changes.)
       (macrolet ((yield (&rest generated-values)
		    ,(if initial-values
			 `(if (= (length generated-values)
				 ,number-of-initial-values-to-yield)
			      `(when .collect-initial-values.
				 ;; avoid recursive metering
				 (let ((*metering-enabled* nil))
				   (funcall .collect-initial-values. ,@generated-values)))
			      (error "YIELDed ~D values in initial form.  ~D expected."
				     (length generated-values)
				     ,number-of-initial-values-to-yield))
			 `(error "Can't YIELD in initial form if no initial values are declared.")))
		  (eval-after-form (&body after)
		    `(let ((collapse-values (null .collect-initial-values.)))
		       (macrolet ((yield (&rest generated-values)
				    (unless (= (length generated-values)
					       ,,number-of-values-to-yield)
				      (error "Yielded ~D values.  ~D expected."
					     (length generated-values)
					     ,,number-of-values-to-yield))
				    ,(if ,pass-through
					 '`(apply .collect-final-values.
						  ,@generated-values ,',passed-args)
					 '`(funcall .collect-final-values.
						    ,@generated-values))))
			 (flet ((,',continuation (.first-realtime. ,',@lambda-list)
				 (declare (sys:downward-function))
				 (ignore .first-realtime.)
				 ;; avoid recursive metering
				 (let ((*metering-enabled* nil))
				   ,@after)))
			   (funcall .continuation. #',',continuation))))))
	 ,@body))))


;;; custom collector functions.
(defvar *component-description* nil)
(defvar *collector-descriptions* nil)

(defun find-collector-and-type (instance)
  (if *component-description*
      (let ((slot (find-slot-in-component-description instance *component-description*)))
	(values (if (= (length *component-description*) 1)
		    '.components.
		    `(aref .components. ,(position slot *component-description*)))
		(second slot)))
      (if (assoc instance *collector-descriptions*)
	  (values instance
		  (get-collector-type (second (assoc instance *collector-descriptions*))))
	  (values instance (get-collector-type (parse-collector instance))))))

(defun find-component-description (instance)
  (if *component-description*
      (third (find-slot-in-component-description instance *component-description*))
      (if (third (assoc instance *collector-descriptions*))
	  (third (assoc instance *collector-descriptions*))
	  (collector-component-description (parse-collector instance)))))



(defmacro define-collector-function (name arglist &body body)
  `(defun ,name ,arglist
     (compiler-let ((*collector-descriptions* nil))
       (macrolet ((define-collector-type ((name type &rest init-args))
		    (unless (assoc name *collector-descriptions*)
		      (let ((components
			      (second (member :component-description init-args))))
			(push (list name
				    type
				    (when components
				      (valid-component-description components 't)
				      (order-component-description components)))
			      *collector-descriptions*)))
		    nil)
		  (collect (instance &rest args)
		    (multiple-value-bind (collector type)
			(find-collector-and-type instance)
		      (get-form-to-collect-data type collector :args args)))
		  (collect-component (instance)
		    (find-collector-and-type instance))
		  (collect-for-value (instance &rest args)
		    (multiple-value-bind (collector type)
			(find-collector-and-type instance)
		      (get-form-to-collect-data type collector :args args :for-value 't))))
	 (macrolet ((with-collector ((collector &rest args) &body body)
		      `(let ((.components. (collect-for-value ,collector ,@args)))
			 (compiler-let
			   ((*component-description*
			      (find-component-description ',collector)))
			   ,@body))))
	   ,@body)))))

(zwei:defindentation (with-collector 1 2 1 1))

#||

(define-collector-function foo (a1 a2 a3 a4)
  (with-collector (*c1* a1)
    (if (oddp a2)
	(with-collector (a a2)
	  (collect a a3)
	  (collect b))
	(with-collector (x a2)
	  (collect a a4)
	  (collect c)))))

||#
