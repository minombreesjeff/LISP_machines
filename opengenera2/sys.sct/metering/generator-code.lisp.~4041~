;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: METERING -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; this is the code that is used to automatically create generator-functions.  Not only
;;; is the code that is in this file ugly, it also create ugly code.

;;; As with so much of the rest of the metering utility, this desperately needs to be
;;; rewritten.

;; some syntax: (there must be a better way to do this).  For :OVERHEAD
;; we expect a list of 3 elements, a LOCATION, an ARG-LIST, and a COMPUTATION.
;; If the LOCATION and the COMPUTATION are both provided, then LOCATION must be SETF'able.
;; If ARG-LIST is non-nil, COMPUTATION is turned into a macro, with an uninterned name.
;; If the second and third elements aren't included, they default to nil.
;;
;; Right now, only null values for ARG-LIST and COMPUTATION are accepted.
;;
(defmacro defgenerator ((name class type lambda-list &key description alters precedence results argument-types presentation-type force constantp special-type wirable overhead temporary-data argument-list-matcher)
			&body body)
  (let* ((real-macro nil)
	 (expand-overhead-macro nil)
	 (macro-or-form (if (null lambda-list)
			    ;; avoid using macro if possible.
			    ;; might need PROGN
			    `(progn ,@body)
			    (let ((macro-name (make-symbol (string name))))
			      (setf real-macro 't)
			      ;; we need to remember that it is a macro so we 
			      ;; can expand it properly
			      (list :macro macro-name))))
	 (overhead-macro-or-form
	   (when overhead
	     (if (listp overhead)
		 (if (null (second overhead))
		     (if (or (first overhead) (third overhead) (cdddr overhead))
			 (list (first overhead)	; location
			       nil		; MACRO-P
						; computation
			       (and (cddr overhead) `(progn ,@(cddr overhead))))
			 (progn
			   (setf overhead nil)
			   nil))
		     (let ((macro-name (make-symbol
					 (string-append (string name) "-GENERATE-OVERHEAD"))))
		       (setf expand-overhead-macro 't)
		       (list (first overhead) :macro macro-name)))
		 (cl:warn `(:bad-style 't)
			  ":OVERHEAD ~S did not match Overhead pattern: `(GET-OVERHEAD ARGLIST &REST FORMS-TO-COMPUTE-OVERHEAD)~%Ignoring :OVERHEAD" overhead))))
	 (init-plist (list :name `',name
			   :class `',class
			   :type `',type
			   :description description
			   :precedence `',precedence
			   :results `',(or results name)
			   :alters `',(if (listp alters)
					  (append 
					    (list (if (listp (car alters))
						      (cons 'time (car alters))
						      (cons 'time
							    (ncons (car alters))))
						  (if (listp (cadr alters))
						      (cons 'paging (cadr alters))
						      (cons 'paging
							    (ncons (cadr alters)))))
					    (cddr alters))
					  (list (list 'time alters) (ncons 'paging)))
			   :lambda-list `',lambda-list
			   :argument-types `',(or argument-types
						     (loop for arg in lambda-list
							   when
							     (not
							       (member
								 arg
								 si:lambda-list-keywords))
							     collect
							   `(,arg sys:expression nil :either)))
			   :arg-matcher `',(or argument-list-matcher #'identity)
			   :presentation-type `',(or presentation-type
						     (generator-type-presentation-type
						       (get-generator-type type)))
			   :form-to-calculate `',macro-or-form
			   :constantp `',constantp
			   :wirable `',wirable
			   :overhead-computation `',overhead-macro-or-form
			   :computation-type
			   `',(or special-type
				  (if constantp
				      (if (change-computable? (get-generator-type type))
					  (error "~A is computable, so ~A can't be :CONSTANTP"
						 type name)
					  'constant-generator-value)
				      (if (change-computable? (get-generator-type type))
					  'computable-generator-value
					  'non-computable-generator-value)))
			   :needs-temporary-stack `',temporary-data)))
				      
    (when (or force (and (boundp 'fs:this-is-a-patch-file) fs:this-is-a-patch-file))
      (setq init-plist (append init-plist '(:force 't))))
    (when argument-types
      (let ((number-of-args
	      (loop for arg in lambda-list
		    count (not (member arg si:lambda-list-keywords)))))
	(unless (= (length argument-types) number-of-args)
	  (error "The number of presentation types (~D) did not match the arguments in the lambda list: ~S" (length argument-types) lambda-list))))

    `(progn
       ,(when (and real-macro (eq (car macro-or-form) ':macro))
	  `(eval-when (load)
	     (defmacro ,(second macro-or-form) ,lambda-list ,@body)))
       ,(when (and expand-overhead-macro (eq (second overhead-macro-or-form) ':macro))
	  `(eval-when (load)
	     (defmacro ,(third overhead-macro-or-form) ,(second overhead)
	       ,@(cddr overhead))))
       (make-instance 'generator ,@init-plist))))

;;; this is bound to one of the generator-function-types when we try to build a generator
;;; function.  It is used inside the macroexpansion, usually to generate default values for
;;; arguments.  An example is FP.  When we are in a TRIGGER, then FP (the frame-pointer) is
;;; (sys:frame-previous-frame
;;;   (sys:frame-previous-frame
;;;     (sys:frame-previous-frame (%stack-frame-pointer)))).  When type is METERING-REGION, 
;;; this is much more complicated.
(defvar *generator-function-type*)

(defmethod (get-form-to-generate-data generator) (generator-function-type &rest args)
  (if (and (listp form-to-calculate) (eq (car form-to-calculate) ':macro))
      (let ((*generator-function-type* generator-function-type))
	;; we do it ourselves, so that *generator-function-type* can be referenced
	;; by the macro.
	(macroexpand (cons (second form-to-calculate) (copy-list args))))
      (if (not (null args))
	  (error "Generator ~A expects no arguments, ~S supplied." name args)
	  form-to-calculate)))

(defmethod (compute-change-of-generated-data generator)
	   (generator-function-type value2 &rest args)
  (get-form-to-compute-change (get-generator-type type)
			      (if (and (listp form-to-calculate)
				       (eq (car form-to-calculate) ':macro))
				  (let ((*generator-function-type* generator-function-type))
				    (macroexpand (cons (second form-to-calculate)
						       (copy-list args))))
				  (if (not (null args))
				      (error "Generator ~A expects no arguments.  ~S supplied" name args)
				      form-to-calculate))
			      value2))

(defmethod (get-form-to-generate-overhead generator) (generator-function-type &rest args)
  (if (null overhead-computation)
      (apply #'get-form-to-generate-data self generator-function-type args)
      (if (and (second overhead-computation) (eq (second overhead-computation) :macro))
	  (let ((*generator-function-type* generator-function-type))
	    ;; we do it ourselves, so that *generator-function-type* can be referenced
	    ;; by the macro.
	    (macroexpand (cons (third overhead-computation) (copy-list args))))
	  (if (not (null args))
	      (error
		"Generator overhead computation for ~A expects no arguments, ~S supplied."
		name
		args)
	      (third overhead-computation)))))

(defmethod (special-location-for-overhead? generator) ()
  (and overhead-computation (first overhead-computation)))

(defmethod (special-computation-for-overhead? generator) ()
  (and overhead-computation (null (third overhead-computation))))

;;

(defun get-names-from-slot (slot &optional (type 'metering-interval))
  (declare (values basic-name overhead-counter total-overhead))
  (ignore type)
  (let ((overhead (generator-code-description-overhead-name slot))
	(total-overhead (special-location-for-overhead?
			  (generator-value-generator
			    (generator-code-description-generator-value slot)))))
    (values
      (generator-code-description-basic-name slot)
      overhead
      (cond (total-overhead total-overhead)
	    (overhead
	     (intern (string-append "TOTAL-" (string overhead))
		     (symbol-package overhead)))
	    (t nil)))))

(defun sort-generators-by-precedence (generator-list)
  (labels ((precedes (g1 g2)
	     ; if a definitely alters b, and b doesn't alter a, or only possibly alters a,
	     ; then a comes before b.
	     ; if a possibly alters b, and b doesn't alter a, then a still comes before b.
	     ; if we can't make a decision, g1 will precede g2, so answer 't
	     (let* ((g1 (generator-value-generator g1))
		    (g2 (generator-value-generator g2))
		    (class-g1 (generator-class g1))
		    (class-g2 (generator-class g2))
		    (g1-definitely-altered-by-g2
		      (member class-g1 (generator-definitely-alters g2))))
	       (not (or (and (member class-g2 (generator-definitely-alters g1))
			     (not g1-definitely-altered-by-g2))
			(and (member class-g2 (generator-possibly-alters g1))
			     (not (or g1-definitely-altered-by-g2
				      (member class-g1 (generator-possibly-alters g2))))))))))
    (stable-sort generator-list #'precedes)))
(defvar *metering-generator-region-recursive-values*
	(make-hash-table :test #'equal :size 3))

(defun get-generator-recursive-values (generator-value)
  (let* ((generator (generator-value-generator generator-value))
	 (uid (if (generator-value-uid-exists generator-value)
		  (generator-value-uid generator-value)
		  (funcall (generator-arg-matcher generator)
			   (get-arglist-from-slot generator-value)))))
    (if (null uid)
	(values (generator-recursive-value generator)
		(generator-recursive-overhead-value generator))
	(stack-let ((key (cons generator uid)))
	  (multiple-value-bind (values found-p)
	      (gethash key *metering-generator-region-recursive-values*)
	    (if found-p
		(values-list values)
		(let ((val1 (gentemp "T" (pkg-find-package "METERING")))
		      (val2 (gentemp "T" (pkg-find-package "METERING"))))
		  (proclaim `(special ,val1))
		  (proclaim `(special ,val2))
		  (set val1 (get-null-value generator))
		  (set val2 (get-null-value generator))
		  (setf (gethash (copy-list key)
				 *metering-generator-region-recursive-values*)
			(list val1 val2))
		  (values val1 val2))))))))
;;
(defun make-generator-function (lambda-list generator-list
				&key (type 'trigger) name wire
				initial-collector-arglist
				final-collector-arglist
				initial-trigger-values)
  (declare (values function description))
  (multiple-value-bind (full-generators name-of-rest-arg-to-pass-through)
      (interpret-generator-list generator-list lambda-list wire)
    (let ((initial-collector-arglist
	    (or initial-collector-arglist
		(loop for g in full-generators
		      append
			(loop for value in (generator-value-values g)
			      when (report-initial? value)
				collect (generator-value-name value)))))
	  (final-collector-arglist
	    (or final-collector-arglist
		(loop for g in full-generators
		      append
			(loop for value in (generator-value-values g)
			      when (report-final? value)
				collect (generator-value-name value))))))
      (values
	(funcall ;; need to funcall result, to get the closure.
	  ;; this is memoized.
	  (create-generator-function
	    name type lambda-list full-generators name-of-rest-arg-to-pass-through wire
	    :initial-collector-arglist initial-collector-arglist
	    :final-collector-arglist final-collector-arglist
	    :initial-trigger-values initial-trigger-values))
	full-generators))))

;; This should probably dispatch off of a list of (type function) pairs rather than 
;; having the dispatching hardwired in the code.
(defun-with-cache create-generator-function
		  (name type lambda-list generator-list name-of-rest-arg-to-pass-through
			&optional wire
			&key initial-collector-arglist final-collector-arglist
			initial-trigger-values)
      (nil (multiple-value-bind (canonicalized-lambda-list
				 canonicalized-generator-list
				 canonicalized-initial-arglist
				 canonicalized-final-arglist
				 canonicalized-initial-lambda-list)
		(canonicalize-generator-description lambda-list generator-list
						    initial-collector-arglist
						    final-collector-arglist
						    initial-trigger-values)
	      (list canonicalized-lambda-list canonicalized-generator-list type wire
		    canonicalized-initial-arglist canonicalized-final-arglist
		    canonicalized-initial-lambda-list)))
  (multiple-value-prog1
    (case type
      (trigger
	(create-trigger-generator-function
	  name lambda-list generator-list name-of-rest-arg-to-pass-through wire
	  final-collector-arglist))
      (metering-region
	(create-metering-region-generator-function
	  name lambda-list generator-list name-of-rest-arg-to-pass-through wire
	  initial-collector-arglist final-collector-arglist initial-trigger-values))
      (metering-interval
	(create-metering-interval-generator-functions
	  name lambda-list generator-list name-of-rest-arg-to-pass-through wire
	  initial-collector-arglist final-collector-arglist))
      (t (error "invalid type of trigger: ~S" type)))
    ;; reset the stupid prefix.
    (gensym "G")))

;;



(defun get-trigger-generator-function-pieces (generator-list)
  (declare (values overhead-bindings value-bindings args measure-overhead temp-space))
  (loop with temp-space = nil
	for g in generator-list
	as gen = (generator-value-generator g)
	as descript = (generator-value-description g)
	as (start-variable overhead-variable total-overhead-variable)
	   = (multiple-value-list (get-names-from-slot descript))
	as compute-value = (get-form-from-slot g 'trigger)
	when (generator-needs-temporary-stack gen)
	  do (setq temp-space 't)
	when (generator-code-description-overhead descript)
	  collect `(,total-overhead-variable ,(get-null-value gen)) into overhead-bindings
	when (generator-code-description-overhead descript)
	  collect `(,start-variable ,(get-overhead-from-slot g 'trigger))
	    into value-bindings
	append (loop for value in (generator-value-values g)
		     collect
		       (list (generator-value-name value)
			     (if (computable? value)
				 (if (eq (generator-value-report value) :report-value)
				     (if (eq (generator-value-overhead value) :overhead)
					 (compute-difference-of-data
					   gen compute-value total-overhead-variable)
					 compute-value)
				     total-overhead-variable)
				 compute-value)))
	  into args
	when (generator-code-description-overhead descript)
	  collect `(setf ,total-overhead-variable
			 ,(accumulate-overhead
			    gen total-overhead-variable
			    (apply #'compute-change-of-generated-data
				   gen 'trigger start-variable (generator-value-args g))))
	    into measure-overhead
	finally
	  (return
	    (values
	      overhead-bindings value-bindings args (nreverse measure-overhead)
	      temp-space))))

(defun layout-trigger-generator-function
       (name lambda-list collector-arglist
	overhead-bindings value-bindings args measure-overhead rest-args-name
	&optional wire temp)
  (let ((source-code
	  `(lambda ()
	     (let ,overhead-bindings
	       (flet
		 ((generator-function (.continuation. .first-realtime. ,@lambda-list)
		    (declare (arglist ,@lambda-list))
		    (declare
		      (values ,@collector-arglist
			      ,@(when rest-args-name (ncons :pass-through))))
		    (ignore .first-realtime.)
		    (,(if temp 'sys:with-data-stack 'progn)
		     (let ,value-bindings
		       (let* ,args
			 (,(if rest-args-name 'apply 'funcall)
			  .continuation.
			  ,@collector-arglist
			  ,@(when rest-args-name (ncons rest-args-name)))
			 (setf .first-realtime. nil)
			 ,@measure-overhead)))))
		 ,(make-closure-wirable-if-needed wire '#'generator-function))))))
    (values
      (compile
	(or name (gensym "GENERATOR-FUNCTION"))
	source-code)
      source-code)))

(defun create-trigger-generator-function (name lambda-list generator-list rest-args-name
					  &optional wire final-collector-arglist)
  (multiple-value-bind (overhead-bindings value-bindings args measure-overhead temp)
      (get-trigger-generator-function-pieces generator-list)
    (layout-trigger-generator-function
      name lambda-list final-collector-arglist
      overhead-bindings value-bindings args measure-overhead rest-args-name wire temp)))



;; The registry holds expressions and information about whether the expression has already 
;; been computed.

;; There are two passes over an expression: FIND-expression and
;; COMPRESS-expression.  compress-expression walks over an expression
;; and replaces any already-seen computations with the name of the
;; location where the result is stored.  If it sees a computation that
;; has already been seen more than once, but no temporary location has
;; been allocated, it allocates a temporary, and stores the value into
;; that.

;; The REGISTRY (a hash table keyed on expression) has entries of the form
;;     EXPR ==> (TYPE VALUE)
;; The meanings of TYPE are:
;;    :LOCATION			the results of EXPR are stored in location VALUE
;;    :TEMP-VALUE		EXPR has been seen once, so no TEMP, and never compressed,
;;    				so we can't side-effect the code.
;;    :TEMP-LOCATION-AND-VALUE	EXPR has been seen more than once, but never compressed, so
;;    				still no TEMP, yet.
;;    :VALUE			EXPR has been seen once, so no temporary has been allocated,
;;				but it HAS been compressed (therefore we can side-effect the
;;				compressed code from EXPR to (SETF TEMP EXPR))
;;    :TEMP-LOCATION		EXPR has been COMPRESSed when only seen once, so no TEMP, but
;;     				it has been seen again since then, but not COMPRESSed again.
;;     				If it gets compressed it will be converted to :LOCATION.

;;; large no-op for now.  Fixed after rel 7.0.
(defun computable-expression (binding-list)
  (let ((registry (make-hash-table :test #'equal :locking nil)))
    (labels ((find-expression (expr &optional location)
	       (when (or location
			 (and (listp expr)
			      (not (constantp expr))))
		 (modify-hash
		   registry expr
		   #'(lambda (key value key-exists-p)
		       (ignore key)
		       (if key-exists-p
			   (let ((type (car value)))
			     (case type
			       (:value
				 (list :temp-location (second value)))
			       (:temp-value
				 (list :temp-location-and-value (second value)))
			       (otherwise
				 value)))
			   (if location
			       (list :location location)
			       ;; until we get our hands on the final piece of code, we
			       ;; can't store anything real here, because it won't be
			       ;; modifiable.
			       (list :temp-value expr))))))
	       expr)
	     (cleanup-expression (expr)
	       (when (listp expr)
		 (let ((entry (gethash expr registry)))
		   (when entry
		     (case (car entry)
		       (:temp-location
			(setf (car entry) :value))
		       (:temp-location-and-value
			 (setf (car entry) :temp-value)))))
		 (loop for sub-expr in expr do (cleanup-expression sub-expr))))
	     (compress-expression (expr &optional (find 't))
	       (when find
		 (find-expression expr))
	       (if (listp expr)
		   (let* ((entry (gethash expr registry))
			  (type (car entry))
			  (new-expr (second entry)))
		     (case type
		       (:location
			 (cleanup-expression (cdr expr))
			 new-expr)
		       (:temp-value
			 (setf (second entry) (cons
						(compress-expression (car expr) nil)
						(compress-expression (cdr expr) nil)))
			 (setf (first entry) :value)
			 (second entry))
		       (:temp-location
			 (let ((placeholder (gensym "EXPR"))
			       (o-car (car new-expr))
			       (o-cdr (cdr new-expr)))
			   ;; we use this more than once.  We need a temporary.
			   (setf (cdr binding-list)
				 (cons placeholder (cdr binding-list)))
			   ;; from now on, just return the temporary.
			   (setf (first entry) :location)
			   (setf (second entry) placeholder)
			   ;; modify old code to store value into temporary
			   ;; location.
			   (setf (car new-expr) 'setf)
			   (setf (cdr new-expr) (list placeholder (cons o-car o-cdr)))
			   (cleanup-expression (cdr expr))
			   placeholder))
		       (:temp-location-and-value
			 (let ((placeholder (gensym "EXPR")))
			   ;; we use this more than once.  We need a temporary.
			   (setf (cdr binding-list)
				 (cons placeholder (cdr binding-list)))
			   ;; from now on, just return the temporary.
			   (setf (first entry) :location)
			   (setf (second entry) placeholder)
			   `(setf ,placeholder ,(cons
						  (compress-expression (car expr) nil)
						  (compress-expression (cdr expr) nil)))))
		       (otherwise
			 (loop for sub-expr on expr
			       do (setf (car sub-expr)
					(compress-expression (car sub-expr) nil))
			       finally (return expr)))))
		   expr)))
      (values #'find-expression #'compress-expression))))

(defun common-expression-optimizer ()
;; this will be the fixed version of above.
)
			     
;;

(COMPILER-LET (#+IMACH(COMPILER:*ENABLE-FRAME-SPLITTING* T))
(defun get-metering-region-generator-function-pieces (generator-list)
  (declare (values value-bindings final-value-bindings overhead-bindings
		   initial-args args changes calculate-overhead-1 calculate-overhead-2
		   flip-generations restore-generations
		   temp-space))
  (macrolet ((expr-i (&rest args)
	       `(funcall expr-i-fun ,@args))
	     (expr-ci (&rest args)
	       `(funcall expr-ci-fun ,@args))
	     (expr-ri (arg)
	       `(funcall expr-ci-fun ,arg nil))
	     (expr-f (&rest args)
	       `(funcall expr-f-fun ,@args))
	     (expr-cf (&rest args)
	       `(funcall expr-cf-fun ,@args))
	     (expr-rf (arg)
	       `(funcall expr-cf-fun ,arg nil)))
    (loop with initial-value-bindings = (ncons nil)
	  with final-value-bindings = (ncons nil)
	  with (expr-i-fun expr-ci-fun) =
	    (multiple-value-list (computable-expression initial-value-bindings))
	  with (expr-f-fun expr-cf-fun) =
	    (multiple-value-list (computable-expression final-value-bindings))
	  with temp-space = nil
	  for g in generator-list
	  as gen = (generator-value-generator g)
	  as descript = (generator-value-description g)
	  as (start-variable overhead-variable total-overhead-variable)
	     = (multiple-value-list (get-names-from-slot descript))
	  as compute-value = `(identity ,(get-form-from-slot g 'metering-region))
	  as compute-overhead = `(identity ,(get-overhead-from-slot g 'metering-region))
	  as initial-overhead = `(identity ,total-overhead-variable)
	  as null-value = (get-null-value gen)
	  when (generator-needs-temporary-stack gen)
	    do (setq temp-space 't)
	  when (generator-code-description-overhead descript)
	    collect `(,total-overhead-variable ,null-value) into overhead-totals
	  as value-arg = (when (and (generator-code-description-initial descript)
				    (generator-code-description-final descript))
			   start-variable)
	  as overhead-arg = (when (generator-code-description-overhead-name descript)
			      overhead-variable)
	  with recursive-value-1 and recursive-value-2
	  do (if (or (generator-code-description-exclusive descript)
		     (generator-code-description-exclusive-overhead-name descript))
		 (multiple-value-setq (recursive-value-1 recursive-value-2)
		   (get-generator-recursive-values g))
		 (setq recursive-value-1 nil)
		 (setq recursive-value-2 nil))
	  as exclusive-arg = (when (generator-code-description-exclusive descript)
			       recursive-value-1)
	  as exclusive-overhead-arg
	     = (when (generator-code-description-exclusive-overhead-name descript)
		 recursive-value-2)
	  as exclusive-copy-1 = (when exclusive-arg (gensym "EXCLUSIVE-"))
	  as exclusive-copy-2 = (when exclusive-overhead-arg (gensym "EXCLUSIVE-OVERHEAD-"))
	  as duplicate-exclusive-1 = (find recursive-value-1 late-value-bindings :key #'car)
	  as duplicate-exclusive-2 = (find recursive-value-2 late-value-bindings :key #'car)
	  append `(,@(when (and exclusive-copy-1 (not duplicate-exclusive-1))
		       `((,exclusive-copy-1 ,null-value)))
		   ,@(when (and exclusive-copy-2 (not duplicate-exclusive-2))
		       `((,exclusive-copy-2 ,null-value))))
	    into flip-generations
	  append `(,@(when (and exclusive-copy-1 (not duplicate-exclusive-1))
		       `((si:incf* ,exclusive-arg ,exclusive-copy-1)))
		   ,@(when (and exclusive-copy-2 (not duplicate-exclusive-2))
		       `((si:incf* ,exclusive-overhead-arg ,exclusive-copy-2))))
	    into restore-generations
	  when (and (generator-code-description-initial descript)
		    (generator-code-description-final descript))
	    collect (progn
		      (expr-i compute-value value-arg)
		      `(,value-arg ,compute-value))
	      into value-bindings
	  append `(,@(when (generator-code-description-overhead-delta descript)
		       (expr-i initial-overhead overhead-arg)
		       `((,overhead-arg ,initial-overhead)))
		   ,@(when (and exclusive-arg (not duplicate-exclusive-1))
		       `((,exclusive-arg ,null-value)))
		   ,@(when (and exclusive-overhead-arg (not duplicate-exclusive-2))
		       `((,exclusive-overhead-arg ,null-value))))
	    into late-value-bindings
	  append (loop for value in (generator-value-values g)
		       when (report-initial? value)
			 collect
		       (list (generator-value-name value)
			     (expr-ri
			       (if (computable? value)
				   (if (eq (generator-value-report value) :report-overhead)
				       initial-overhead
				       (if (eq (generator-value-overhead value) :overhead)
					   (compute-difference-of-data
					     gen
					     compute-value
					     initial-overhead)
					   compute-value))
				   compute-value))))
	    into initial-args
	  when (generator-code-description-overhead descript)
	    collect `(setf ,total-overhead-variable
			   ,(expr-ci
			      (accumulate-overhead
				gen
				total-overhead-variable
				(expr-i
				  (apply #'compute-change-of-generated-data
					 gen 'metering-region
					 (expr-i compute-overhead)
					 (generator-value-args g))))))
	      into calculate-overhead-1
	  when (generator-code-description-overhead descript)
	    collect (let ((name (gensym "OVERHEAD-COMPUTATION")))
		      (expr-f compute-overhead name)
		      `(,name ,compute-overhead))
	      into overhead-bindings
	  when (and ;; if it's not already a variable,
		 (listp (second compute-value))
		 ;; and it hasn't already been stashed because of overhead,
		 (not (and (generator-code-description-overhead descript)
			   (equal compute-value compute-overhead)))
		 ;; and it gets computed more than once.
		 (or (> (length (generator-value-values g)) 1)
		     (generator-code-description-exclusive descript)))
	    collect (let ((name (gensym "VALUE-COMPUTATION")))
		      (expr-f compute-value name)
		      `(,name ,compute-value))
	      into overhead-bindings
	  append (loop for value in (generator-value-values g)
		       when (report-final? value)
			 collect
		       (list (generator-value-name value)
			     (if (computable? value)
				 (expr-rf
				   (if (eq (generator-value-report value)
					   :report-overhead)
				       initial-overhead
				       (if (eq (generator-value-overhead value) :overhead)
					   (compute-difference-of-data
					     gen compute-value
					     initial-overhead)
					   compute-value)))
				 (if (report-initial? value)
				     (expr-ri compute-value) ;; expr-ci and expr-cf
				     (expr-rf compute-value)))))
	    into args
	  append
	    (macrolet ((expr-incf (location amount)
			 ``(setf ,,location
				 ,(expr-rf
				    (compute-sum-of-data
				      gen (expr-rf ,amount) ,location))))
		       (expr-diff (val1 val2)
			 `(compute-difference-of-data
			    gen (expr-rf ,val1) (expr-rf ,val2)))
		       (expr-change (val)
			 `(compute-change-of-data
			    gen
			    (expr-rf ,val)
			    (expr-ri ,val))))
	      (loop for value in (generator-value-values g)
		    with updated-superior-overhead = duplicate-exclusive-2
		    with updated-superior-value = duplicate-exclusive-1
		    when (report-final? value)
		      collect
		    (list (generator-value-name value)
			(if (computable? value)
			    (expr-rf
			      (if (eq (generator-value-report value)
				      :report-overhead)
				  (if (eq (generator-value-inclusive value) :inclusive)
				      (expr-change initial-overhead)
				      (expr-rf
					`(progn
					   ,@(unless updated-superior-overhead
					       (setf updated-superior-overhead 't)
					       `(,(expr-incf
						    exclusive-copy-2
						    (expr-change initial-overhead))))
					   ,(expr-rf
					      (expr-diff
						(expr-change initial-overhead)
						exclusive-overhead-arg)))))
				  (if (eq (generator-value-inclusive value) :inclusive)
				      (if (eq (generator-value-overhead value) :overhead)
					  (expr-diff
					    (expr-change compute-value)
					    (expr-change initial-overhead))
					  (expr-change compute-value))
				      `(progn
					 ,(unless updated-superior-value
					    (setf updated-superior-value 't)
					    (expr-incf
					      exclusive-copy-1
					      (expr-change compute-value)))
					 ,(unless (or updated-superior-overhead
						      (neq (generator-value-overhead value)
							   :overhead))
					    (setf updated-superior-overhead 't)
					    (expr-incf
					      exclusive-copy-2
					      (expr-change initial-overhead)))
					 ,(if (eq (generator-value-overhead value)
						  :overhead)
					      (expr-diff
						(expr-diff
						  (expr-change compute-value)
						  (expr-change initial-overhead))
						(expr-diff
						  exclusive-arg
						  exclusive-overhead-arg))
					      (expr-diff
						(expr-change compute-value)
						exclusive-arg))))))
			    (if (report-initial? value)
				(expr-ri compute-value) ;;expr-ci and expr-cf
				(expr-rf compute-value))))))
	    into changes
	  when (generator-code-description-overhead descript)
	    collect `(setf ,total-overhead-variable
			   ,(expr-cf
			      (accumulate-overhead
				gen
				total-overhead-variable
				(expr-f
				  (apply #'compute-change-of-generated-data
					 gen 'metering-region (expr-f compute-overhead)
					 (generator-value-args g))))))
	      into calculate-overhead-2
	  finally
	    (return
	      (values (append value-bindings flip-generations
			      (reverse (cdr initial-value-bindings)))
		      (append (reverse (cdr final-value-bindings)) overhead-bindings)
		      overhead-totals
		      initial-args args changes
		      calculate-overhead-1
		      calculate-overhead-2
		      late-value-bindings restore-generations)))))
)

(COMPILER-LET (#+IMACH(COMPILER:*ENABLE-FRAME-SPLITTING* T))
(defun layout-metering-region-generator-function
       (name lambda-list final-collector-arglist initial-collector-arglist
	value-bindings final-bindings overhead-bindings
	initial-args args changes calculate-overhead-1 calculate-overhead-2
	flip-generations restore-generations rest-args-name
	&optional wire temp initial-lambda-list)
  (let ((source
	  `(lambda ()
  	     (let ,overhead-bindings
	       (flet
		 ((generator-function
		     (.continuation. .collect-initial-values. .collect-final-values. .compute-changes.
				     .first-realtime. ,@initial-lambda-list)
		    (declare (arglist ,@lambda-list))
		    (declare (values ,@final-collector-arglist
				     ,@(when rest-args-name (ncons :pass-through))))
		    (declare (initial-values ,@initial-collector-arglist))
		    ,@(when overhead-bindings
			`((declare (compiler:evacuable-downward-closures))))
		    ;; hack for code on aux stack.  Ugly, Ugly, Ugly.
		    ,@(when wire
			`((declare (sys:unsafeguarded-reference
						 si:*scheduler-metering-overhead*))))
		    (ignore .first-realtime.
			    ,@(loop for arg in initial-lambda-list
				    when (not (or (member arg si:lambda-list-keywords)
						  (constantp arg)))
				      collect arg))
		    (,(if temp 'sys:with-data-stack 'progn)
		    (let ,value-bindings
		      (multiple-value-prog1
			(let ,flip-generations
			  (when .collect-initial-values.
			    ;; avoid recursive metering
			    (,(if wire 'aux-stack-bind 'let)
			     ((*metering-enabled* nil))
			     (let* ,initial-args
			       (ignore
				 ,@(loop for binding in initial-args collect (car binding)))
			       (funcall .collect-initial-values.
					,@initial-collector-arglist)))
			    (setf .first-realtime. nil)
			    ,@(last calculate-overhead-1))	;
			  (setf .first-realtime. nil)
			  ,@(cdr (reverse calculate-overhead-1))
			  (flet ((gen-function-conclusion (.first-realtime. ,@lambda-list)
				   ,@(unless overhead-bindings
				       `((declare (sys:downward-function))))
				   ,@(when wire
				       `((declare (sys:unsafeguarded-reference si:*scheduler-metering-overhead*))))
				   (,(if temp 'sys:with-data-stack 'progn)
				    (,(if wire 'aux-stack-bind 'let)
				     ((*metering-enabled* nil))
				     (let ,final-bindings
				       (if .compute-changes.
					   (let ,changes
					     (ignore
					       .first-realtime.
					       ,@(loop for binding in changes
						       collect (car binding)))
					   (,(if rest-args-name 'apply 'funcall)
					    .collect-final-values.
					    ,@final-collector-arglist
					    ,@(when rest-args-name (ncons rest-args-name))))
					   (let ,args
					   (,(if rest-args-name 'apply 'funcall)
					    .collect-final-values.
					    ,@final-collector-arglist
					    ,@(when rest-args-name (ncons rest-args-name)))))
				       (setf .first-realtime. nil)
				       ,@(reverse calculate-overhead-2))))))
			    (funcall .continuation. #'gen-function-conclusion)))
			(progn ,@restore-generations))))))
		 ,(make-closure-wirable-if-needed wire '#'generator-function))))))
    (values 
      (compile (or name (gensym "GENERATOR-FUNCTION")) source)
      source)))
)

(defun create-metering-region-generator-function
       (name lambda-list generator-list rest-args-name wire
	initial-collector-arglist final-collector-arglist initial-lambda-list)
  (multiple-value-bind
    (value-bindings final-value-bindings overhead-bindings
     initial-args args changes calculate-overhead-1 calculate-overhead-2
     flip-generations restore-generations temp)
      (get-metering-region-generator-function-pieces generator-list)
    (layout-metering-region-generator-function
      name lambda-list final-collector-arglist initial-collector-arglist
      value-bindings final-value-bindings overhead-bindings
      initial-args args changes calculate-overhead-1 calculate-overhead-2
      flip-generations restore-generations
      rest-args-name wire temp initial-lambda-list)))


;;
(COMPILER-LET (#+IMACH(COMPILER:*ENABLE-FRAME-SPLITTING* T))
(defun create-metering-interval-generator-functions
       (name lambda-list generator-list rest-args-name wire
	initial-collector-arglist final-collector-arglist)
  (declare (values (meter-begin meter-end)))
  (multiple-value-bind (overhead-totals overhead-bindings overhead-stack-bindings
			initial-value-bindings final-value-bindings
			calculate-overhead-from-bindings
			calculate-overhead-from-stack-bindings
			initial-args initial-bindings #||final-bindings||# args changes
			stack-frame-size need-totals temp-space)
      (macrolet ((expr-i (&rest args)
		   `(funcall expr-i-fun ,@args))
		 (expr-ci (&rest args)
		   `(funcall expr-ci-fun ,@args))
		 (expr-ri (arg)
		   `(funcall expr-ci-fun ,arg nil))
		 (expr-f (&rest args)
		   `(funcall expr-f-fun ,@args))
		 (expr-cf (&rest args)
		   `(funcall expr-cf-fun ,@args))
		 (expr-rf (arg)
		   `(funcall expr-cf-fun ,arg nil)))
      (loop with stack-depth = 0
	    with need-totals = nil
	    with needs-temp = nil
	    with initial-value-bindings = (ncons nil)
	    with final-value-bindings = (ncons nil)
	    with  (expr-i-fun expr-ci-fun) =
	      (multiple-value-list (computable-expression initial-value-bindings))
	    with (expr-f-fun expr-cf-fun) =
	      (multiple-value-list (computable-expression final-value-bindings))
	    for g in generator-list
	    as gen = (generator-value-generator g)
	    as descript = (generator-value-description g)
	    as (nil overhead-variable total-overhead-variable)
	       = (multiple-value-list
		   (get-names-from-slot descript))
	    as compute-value = `(identity ,(get-form-from-slot g 'metering-interval))
	    as compute-overhead = `(identity ,(get-overhead-from-slot g 'metering-interval))
	    as initial-overhead = `(identity ,total-overhead-variable)
	    as null-value = (get-null-value gen)
	    when (generator-needs-temporary-stack gen)
	      do (setq needs-temp 't)
	    when (generator-code-description-overhead descript)
	      collect `(,total-overhead-variable ,null-value) into overhead-totals
	    as value-index = (when (and (generator-code-description-initial descript)
					(generator-code-description-final descript))
			       (incf stack-depth))
	    as overhead-index = (when
				  (and value-index 
				       (generator-code-description-overhead-delta descript))
				  (incf stack-depth))
	    as exclusive-index = (when (generator-code-description-exclusive descript)
				   (incf stack-depth))
	    as exclusive-overhead-index
	       = (when (generator-code-description-exclusive-overhead descript)
		   (incf stack-depth))
	    when (or exclusive-index exclusive-overhead-index)
	      do (setq need-totals 't)
	    when (and (generator-code-description-initial descript)
		      (generator-code-description-final descript))
	      collect (progn
			(expr-i compute-value `(aref stack (- stack-ptr ,value-index)))
			`(setf (aref stack (- stack-ptr ,value-index)) ,compute-value))
		into initial-stack-bindings
	    append `(,@(when (generator-code-description-overhead-delta descript)
			 (expr-i initial-overhead `(aref stack (- stack-ptr ,overhead-index)))
			 `((setf (aref stack (- stack-ptr ,overhead-index))
				 ,total-overhead-variable)))
		     ,@(when (generator-code-description-exclusive descript)
			 `((setf (aref stack (- stack-ptr ,exclusive-index)) ,null-value)))
		     ,@(when (generator-code-description-exclusive-overhead descript)
			 `((setf (aref stack (- stack-ptr ,exclusive-overhead-index))
				 ,null-value))))
	      into initial-bindings
	    append (loop for value in (generator-value-values g)
			 when (report-initial? value)
			   collect
			 (list (generator-value-name value)
			       (expr-ri
				 (if (computable? value)
				     (if (eq (generator-value-report value) :report-overhead)
					 initial-overhead
					 (if (eq (generator-value-overhead value) :overhead)
					     (compute-difference-of-data
					       gen
					       compute-value
					       initial-overhead)
					     compute-value))
				     compute-value))))
	      into initial-args
	    when (generator-code-description-overhead descript)
	      collect `(setf ,total-overhead-variable
			     ,(expr-ci
				(accumulate-overhead
				  gen
				  total-overhead-variable
				  (expr-i
				    (apply #'compute-change-of-generated-data
					   gen 'metering-interval
					   (expr-i compute-overhead)
					   (generator-value-args g))))))
		into calculate-overhead-from-stack-bindings
	    when (generator-code-description-overhead descript)
	      collect (progn
			(expr-f compute-overhead overhead-variable)
			`(,overhead-variable ,compute-overhead))
		into overhead-bindings
	      ;;;
	      ;;;
	    when (and
		   ;; if it's not already a variable,
		   (listp (second compute-value))
		   ;; and it hasn't already been stashed because of overhead,
		   (not (and (generator-code-description-overhead descript)
			     (equal compute-value compute-overhead)))
		   ;; and it gets computed more than once.
		   (or (> (length (generator-value-values g)) 1)
		       (generator-code-description-exclusive descript)))
	      collect (let ((name (gensym "VALUE-COMPUTATION")))
			(expr-f compute-value name)
			`(,name ,compute-value))
		into overhead-bindings
	    append (loop for value in (generator-value-values g)
			 when (report-final? value)
			   collect
			 (list (generator-value-name value)
			     (if (computable? value)
				 (expr-rf
				   (if (eq (generator-value-report value)
					   :report-overhead)
				       initial-overhead
				       (if (eq (generator-value-overhead value) :overhead)
					   (compute-difference-of-data
					     gen (expr-f compute-value)
					     initial-overhead)
					   compute-value)))
				 (if (report-initial? value)
				     (expr-ri compute-value) ;; expr-ci and expr-cf
				     (expr-rf compute-value)))))
	      into args
	    append
	      (macrolet ((expr-incf (location amount)
			   ``(setf ,,location
				   ,(expr-rf
				      (compute-sum-of-data
					gen (expr-rf ,amount) ,location))))
			 (expr-diff (val1 val2)
			   `(compute-difference-of-data
			      gen (expr-rf ,val1) (expr-rf ,val2)))
			 (expr-change (val)
			   `(compute-change-of-data
			      gen
			      (expr-rf ,val)
			      (expr-ri ,val))))
		(loop for value in (generator-value-values g)
		      with updated-superior-overhead = nil
		      with updated-superior-value = nil
		      when (report-final? value)
			collect
		      (list (generator-value-name value)
			    (if (computable? value)
				(expr-rf
				  (if (eq (generator-value-report value)
					  :report-overhead)
				      (if (eq (generator-value-inclusive value) :inclusive)
					  (expr-change initial-overhead)
					  (expr-rf
					    `(progn
					       ,@(unless updated-superior-overhead
						   (setf updated-superior-overhead 't)
						   `((unless top-of-stack
						       ,(expr-incf
							  `(aref stack
								 ,(expr-rf
								    `(- prev-stack-ptr
									,exclusive-overhead-index)))
							  (expr-change initial-overhead)))))
					       ,(expr-rf
						  (expr-diff
						    (expr-change initial-overhead)
						    `(aref stack
							   (- stack-ptr
							      ,exclusive-overhead-index)))))))
				      (if (eq (generator-value-inclusive value) :inclusive)
					  (if (eq (generator-value-overhead value) :overhead)
					      (expr-diff
						(expr-change compute-value)
						(expr-change initial-overhead))
					      (expr-change compute-value))
					  `(progn
					     (unless top-of-stack
					       ,(unless updated-superior-value
						  (setf updated-superior-value 't)
						  (expr-incf
						    `(aref stack
							   ,(expr-rf
							      `(- prev-stack-ptr
								  ,exclusive-index)))
						    (expr-change compute-value)))
					       ,(unless (or updated-superior-overhead
							    (eq (generator-value-overhead value)
								:no-overhead))
						  (setf updated-superior-overhead 't)
						  (expr-incf
						    `(aref stack
							   ,(expr-rf
							      `(- prev-stack-ptr
								  ,exclusive-overhead-index)))
						    (expr-change initial-overhead))))
					     ,(if (eq (generator-value-overhead value)
						      :overhead)
						  (expr-diff
						    (expr-diff
						      (expr-change compute-value)
						      (expr-change initial-overhead))
						    (expr-diff
						      `(aref stack
							     (- stack-ptr ,exclusive-index))
						      `(aref stack
							     (- stack-ptr
								,exclusive-overhead-index))))
						  (expr-diff
						    (expr-change compute-value)
						    `(aref stack
							   (- stack-ptr ,exclusive-index))))))))
				(if (report-initial? value)
				    (expr-ri compute-value) ;;expr-ci and expr-cf
				    (expr-rf compute-value))))))
	      into changes
	    when (generator-code-description-overhead descript)
	      collect `(setf ,total-overhead-variable
			     ,(expr-cf
				(accumulate-overhead
				  gen
				  total-overhead-variable
				  (expr-f
				    (apply #'compute-change-of-generated-data
					   gen 'metering-interval (expr-f compute-overhead)
					   (generator-value-args g))))))
		into calculate-overhead-from-bindings
	    finally
	      (return
		(values overhead-totals overhead-bindings initial-stack-bindings
			(reverse (cdr initial-value-bindings))
			(reverse (cdr final-value-bindings))
			calculate-overhead-from-bindings
			calculate-overhead-from-stack-bindings
			initial-args initial-bindings #||final-bindings||# args changes
			stack-depth need-totals needs-temp))))
    (let ((source-code
	    `(lambda ()
	       (let ,overhead-totals
		 (flet ((generator-function-preamble (.collect-initial-values. .first-realtime. ,@lambda-list)
			  (declare (arglist ,@lambda-list))
			  (declare (values ,@final-collector-arglist
					   ,@(when rest-args-name (ncons :pass-through))))
			  (declare (initial-values ,@initial-collector-arglist))
			  (ignore .first-realtime.
				  ,@(loop for arg in lambda-list
					  when (not (member arg si:lambda-list-keywords))
					    collect arg))
			  (let* ((*metering-enabled* nil)
				 ,@(when (plusp stack-frame-size)
				     `((stack
					 (or *metering-stack*
					     (process::pmi-stack
					       (si:process-metering-info
						 si:*current-process*))))
				       (stack-ptr
					 (ensure-stack-frame stack ,stack-frame-size))))
				 ,@initial-value-bindings)
			    ,@(when (plusp stack-frame-size)
				'((declare (sys:array-register stack))))
			    (,(if temp-space 'sys:with-data-stack 'progn)
			     ,@overhead-stack-bindings
			     ,@initial-bindings
			     (when .collect-initial-values.
			       (let* ,initial-args
				 (ignore
				   ,@(loop for binding in initial-args collect (car binding)))
				 (funcall .collect-initial-values. ,@initial-collector-arglist)
				 (setf .first-realtime. nil)
				 ,@(last calculate-overhead-from-stack-bindings)))
			     (setf .first-realtime. nil)
			     ,@(cdr (reverse calculate-overhead-from-stack-bindings)))))
			(generator-function-conclusion
			   (.compute-change. .collect-final-values. .first-realtime. ,@lambda-list)
			  (ignore .first-realtime.
				  ,@(loop for arg in lambda-list
					  when (not (member arg si:lambda-list-keywords))
					    collect arg))
			  (,(if temp-space 'sys:with-data-stack 'progn)
			   (let* ((*metering-enabled* nil)
				  ,@final-value-bindings
				  ,@overhead-bindings
				  ,@(when (plusp stack-frame-size)
				      `((stack
					  (or *metering-stack*
					      (process::pmi-stack
						(si:process-metering-info
						  si:*current-process*))))
					(stack-ptr (metering-stack-pointer stack))
					,@(when need-totals
					    `((prev-stack-ptr
						(metering-stack-frame-pointer stack))
					      (top-of-stack (or (null prev-stack-ptr)
								(zerop prev-stack-ptr)))))
					#||,@final-bindings||#)))
			     ,@(when (plusp stack-frame-size)
				 '((declare (sys:array-register stack))))
			     (,(if (plusp stack-frame-size)
				   'when
				   'progn)
			      ,@(when (plusp stack-frame-size)
				  `((and stack
					 ,@(when need-totals '(prev-stack-ptr))
					 (>= stack-ptr ,stack-frame-size))))
			      (if .compute-change.
				  (let* ,changes
				    (ignore
				      ,@(loop for binding in changes collect (car binding)))
				    (,(if rest-args-name 'apply 'funcall)
				     .collect-final-values.
				     ,@final-collector-arglist
				     ,@(when rest-args-name (ncons rest-args-name))))
				  (let* ,args
				    (ignore
				      ,@(loop for binding in args collect (car binding)))
				    (,(if rest-args-name 'apply 'funcall)
				     .collect-final-values.
				     ,@final-collector-arglist
				     ,@(when rest-args-name (ncons rest-args-name))))))
			     (setf .first-realtime. nil)
			     ,@(reverse calculate-overhead-from-bindings)))))
		   (list ,(make-closure-wirable-if-needed wire '#'generator-function-preamble)
			 ,(make-closure-wirable-if-needed wire '#'generator-function-conclusion)))))))
      (values
	(compile
	  (or name (gensym "GENERATOR-FUNCTION"))
	  source-code)
	source-code))))
)

;; have a total-collector, that also yields current-value.

;; ::=> per-region (send region get-totals 'foo) which yields a summing collector,
;; which you can then ask :total?
