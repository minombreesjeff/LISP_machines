;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: METERING; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;allocate stacks out of resource, and put into process slot.


;; allocate it when set-scope?  (what about (not (:process "lisp listener 1"))?)
;; or when turn-on-metering? (more reliable, but more expensive)

(setq *enable-metering-on-function-calls* 't)
(add-initialization
  're-enable-all-function-call-metering
  `(setq *enable-metering-on-function-calls* 't)
  ()
  '*metering-warm-initializations*)

(setq *enable-function-metering-during-scavenge* nil)

#+3600
(defun turn-on-meter-bit (process)		;
  (if (eq (si:process-stack-group process) si:%current-stack-group)
      (sys:%meter-on)
      (let ((sg (si:process-stack-group process)))
	(when (and sg (zl:typep sg ':stack-group))
	  (setf (si:sg-meter-enable sg) 1))))
  (values))

#+imach
(defun turn-on-meter-bit (process)
  (let ((sg (si:process-stack-group process)))
    (if (eq sg si:%current-stack-group)
	(progn
	  (dbg:meter-on-exit
	    (sys:%pointer-plus (sys:%stack-frame-pointer)
			   (- (ldb si:%%cr.caller-frame-size
				   (si:%read-internal-register si:%register-control-register))))
	    (sys:%stack-frame-pointer) si:%current-stack-group 1)
	  (si:%p-dpb 1 si:%%cr.call-trace (cli::%saved-control-register-address)))
	(when (zl:typep sg :stack-group)
	  (block find-it
	    (dbg:map-over-frames-in-stack 
	      sg
	      #'(lambda (fp lcr function)
		  (when (eql function #'process::run-process-dispatcher)
		    (si:%p-dpb 1 sys:%%cr.call-trace lcr)
		    (dbg:meter-on-exit fp (sys:%pointer-plus lcr -1) sg 1)
		    (return-from find-it (values nil)))))))))
  (values))



#+3600
(defun turn-on-meter-bit-check (process state)
  (ignore state)
  (if (eq (si:process-stack-group process) si:%current-stack-group)
      (sys:%meter-on)
      (let ((sg (si:process-stack-group process)))
	(when (and sg (zl:typep sg ':stack-group))
	  (setf (si:sg-meter-enable (si:process-stack-group process)) 1))))
  (values))

#+imach
(defun turn-on-meter-bit-check (process state)
  (declare (ignore state))
  (let ((sg (si:process-stack-group process)))
    (if (eq sg si:%current-stack-group)
	(progn
	  (si:%p-dpb 1 si:%%cr.call-trace (cli::%saved-control-register-address))
	  (dbg:meter-on-exit
	    (sys:%pointer-plus (sys:%stack-frame-pointer)
	      (- (ldb sys:%%cr.caller-frame-size
		      (sys:%read-internal-register sys:%register-control-register))))
	    (sys:%stack-frame-pointer) sg 1))
	(when (zl:typep sg :stack-group)
	  (block find-it
	    (dbg:map-over-frames-in-stack 
	      sg
	      #'(lambda (fp lcr function)
		  (when (eql function #'process::run-process-dispatcher)
		    (si:%p-dpb 1 sys:%%cr.call-trace lcr)
		    ;;--- We know that the next-active-frame is one word before
		    ;;--- the saved control register.  Someone should fix this
		    ;;--- modularity.
		    (dbg:meter-on-exit fp (sys:%pointer-plus lcr -1) sg 1)
		    (return-from find-it (values nil)))))))))
  (values))

#+3600
(defun turn-off-meter-bit (process)
  (if (eq (si:process-stack-group process) si:%current-stack-group)
      (sys:%meter-off)
      (let ((sg (si:process-stack-group process)))
	(when (and sg (zl:typep sg ':stack-group))
	  (setf (si:sg-meter-enable (si:process-stack-group process)) 0))))
  (values))

#+imach
(defun turn-off-meter-bit (process)
  (let ((sg (si:process-stack-group process)))
    (if (eq sg si:%current-stack-group)
	(si:without-interrupts			;can't take a function call
	  (si:%p-dpb 0 si:%%cr.call-trace (cli::%saved-control-register-address))
	  (setf (sys:%logldb si:%%cr.call-trace
			     (sys:%read-internal-register sys:%register-control-register))
		0)
	  (dbg:meter-on-exit
	    (sys:%pointer-plus (sys:%stack-frame-pointer)
			       (- (ldb sys:%%cr.caller-frame-size
				       (sys:%read-internal-register sys:%register-control-register))))
	    (sys:%stack-frame-pointer) sg 0)
	  (dbg:%meter-on-exit-this-frame 0))
	(when (zl:typep sg :stack-group)
	  (block find-it
	    (dbg:map-over-frames-in-stack 
	      sg
	      #'(lambda (fp lcr function)
		  (when (eql function #'process::run-process-dispatcher)
		    (si:%p-dpb 0 si:%%cr.call-trace lcr)
		    ;;--- We know that the next-active-frame is one word before
		    ;;--- the saved control register.  Someone should fix this
		    ;;--- modularity.
		    (dbg:meter-on-exit fp (sys:%pointer-plus lcr -1) sg 0)
		    (return-from find-it (values nil)))))))))
  (values))
(defvar *computing-fudge-factor* nil)

;;; update trigger fields
(defun copy-trigger-variables (source-trigger dest-trigger)
  (setf (trigger-generated-values dest-trigger)
	(trigger-generated-values source-trigger))
  (setf (trigger-initial-generated-values dest-trigger)
	(trigger-initial-generated-values source-trigger))
  (setf (trigger-generator-function dest-trigger)
	(trigger-generator-function source-trigger))
  (setf (trigger-collector-function dest-trigger)
	(trigger-collector-function source-trigger))
  (setf (trigger-initial-generator-function dest-trigger)
	(trigger-initial-generator-function source-trigger))
  (setf (trigger-initial-collector-function dest-trigger)
	(trigger-initial-collector-function source-trigger))
  (setf (trigger-generator-description dest-trigger)
	(trigger-generator-description source-trigger))
  (setf (trigger-collector-description dest-trigger)
	(trigger-collector-description source-trigger))
  (setf (trigger-initial-collector-description dest-trigger)
	(trigger-initial-collector-description source-trigger)))

;;; update control fields
(defun copy-control-variables (source-control dest-control)
      (setf (control-testing-function dest-control)
	    (control-testing-function source-control))
      (setf (control-special-actions dest-control)
	    (control-special-actions source-control))
      (setf (control-per-process-actions dest-control)
	    (control-per-process-actions source-control)))


(defun activate-all-function-metering ()
  (when (and (or (null *function-entry-fudge-factor-1*)
		 (zerop *function-entry-fudge-factor-1*))
	     (not *computing-fudge-factor*))
    (let ((consistent nil)
	  (*computing-fudge-factor* t)
	  (all-function-calls-trigger (parse-trigger 'all-function-calls))
	  (all-function-calls-control (parse-control 'all-function-calls))
	  (fudge-factor-trigger
	      (make-instance 'restricted-control-interval
			     :name "All Function Calls"
			     ;;; triggers a metering event whenever 
			     :description "every function entry and exit"
			     :type 'function
			     :variable-name '*trigger-for-all-function-calls*
			     :control-extent :per-process
			     :turn-control-on 'turn-on-meter-bit
			     :turn-control-off 'turn-off-meter-bit
			     :check-for-control-state 'turn-on-meter-bit-check
			     :control-setup 'allocate-meter-stack
			     :control-cleanup 'deallocate-meter-stack
			     :activate-control 'activate-all-function-metering
			     :deactivate-control 'deactivate-all-function-metering
			     :values '(frame-pointer #+IMach function)
			     :initial-values `(frame-pointer #+IMach function)
			     :value-types `(metering-stack-frame-pointer #+IMach function)))
	  (fudge-factor-control
	    (make-instance 'per-process-control :name "All Function Calls" :keep t)))

;;; Save trigger fields
      (copy-trigger-variables all-function-calls-trigger fudge-factor-trigger)
;;; Save control fields
      (copy-control-variables all-function-calls-control fudge-factor-control)
;;; Establish new control
      (control-trigger fudge-factor-control all-function-calls-trigger)
      (add-trigger-to-control fudge-factor-control all-function-calls-trigger)
;;; Can only have one "all function calls" routine at a time
      (if (remove-registered-control "all function calls")
	  (register-control "all function calls" fudge-factor-control))

      (loop repeat *number-of-times-to-try-computing-fudge-factors*
	    until consistent do
	(multiple-value-setq (nil nil consistent)
	  (compute-fudge-factor 2500 :silent))
	    finally
	      (unless (or consistent
			  (and (> *compute-fudge-factor-warning-threshold*
				  *number-of-times-to-try-computing-fudge-factors*)
			       (< *function-fudge-factor-error*
				  (+ *function-entry-fudge-factor-1*
				     *function-entry-fudge-factor-2*
				     *function-exit-fudge-factor-1*
				     *function-exit-fudge-factor-2*))))
		(format *query-IO* *inconsistent-fudge-factors-description*)
		(display-function-call-fudge-factors *query-io*)
		(case *inconsistent-fudge-factors-action*
		  (:prompt
		    (loop with resolved = nil
			  until resolved do
		      (case (accept 'inconsistent-fudge-factors-action
				    :default :retry-once
				    :prompt "Enter one of Retry Once, Retry, or Ignore")
			(:ignore (setq resolved t))
			(:retry-once
			  (multiple-value-setq (nil nil resolved)
			    (compute-fudge-factor 2500 :silent))
			  (unless resolved
			    (display-function-call-fudge-factors *query-io*)
			    (format *query-io* "~%Results still inconsistent")))
			(:retry
			  (loop until (multiple-value-bind (ignore ignore consistent)
					  (compute-fudge-factor 2500 :silent)
					consistent))
			  (setq resolved t)))))
		  (:ignore)
		  (:retry
		    (loop until (multiple-value-bind (ignore ignore consistent)
				    (compute-fudge-factor 2500 :silent)	;
				  consistent))))))
;;; Reestablish trigger fields
      (copy-trigger-variables fudge-factor-trigger all-function-calls-trigger)
;;; Reestablish control fields
      (copy-control-variables fudge-factor-control all-function-calls-control)
;;; Reestablish "real environment"
      (control-trigger all-function-calls-control all-function-calls-trigger)
      (add-trigger-to-control all-function-calls-control all-function-calls-trigger)
      (if (remove-registered-control "all function calls")
	  (register-control "all function calls" all-function-calls-control))))
  #+imach
  (progn
    (si:init-saved-trap-vector)
    (si:install-exception-trace-handlers)))

(defun deactivate-all-function-metering ()
  #+imach (si:remove-exception-trace-handlers))
(defun deallocate-meter-stack (process)
  (when (process-meter-stack process)
    (si:deallocate-resource 'metering-stacks (process-meter-stack process)))
  (setf (process-meter-stack process) nil))
(defun allocate-meter-stack (process)
  (unless (process-meter-stack process)
    (setf (process-meter-stack process)
	  (si:allocate-resource 'metering-stacks))))

(add-initialization
  'create-all-function-calls-trigger
  `(progn
     (register-triggering-event
       'all-function-calls
       '*trigger-for-all-function-calls*
       (make-instance 'restricted-control-interval
		      :name "All Function Calls"
		 ;;; triggers a metering event whenever 
		      :description "every function entry and exit"
		      :type 'function
		      :variable-name '*trigger-for-all-function-calls*
		      :control-extent :per-process
		      :turn-control-on 'turn-on-meter-bit
		      :turn-control-off 'turn-off-meter-bit
		      :check-for-control-state 'turn-on-meter-bit-check
		      :control-setup 'allocate-meter-stack
		      :control-cleanup 'deallocate-meter-stack
		      :activate-control 'activate-all-function-metering
		      :deactivate-control 'deactivate-all-function-metering
		      :values '(frame-pointer #+IMach function)
		      :initial-values `(frame-pointer #+IMach function)
		      :value-types `(metering-stack-frame-pointer #+IMach function)))
     (control-trigger (make-instance 'per-process-control :name "All Function Calls" :keep t)
		      'all-function-calls))
  ()
  '*metering-load-initializations*)

(defun meter-functions-during-scavenge (&optional (enable nil))
  (setf *enable-function-metering-during-scavenge* enable))


;; compute fudge factors so that we can take the unmeasurable overhead into account.


(defvar function-entry-fudge-factor 0)
(defvar function-exit-fudge-factor 0)
(defvar *control-test-traps* nil)


(defvar *trap-total-internal-time* 0)
(defvar *trap-entry-start* 0)
(defvar *trap-entry-ovhd-start* 0)


;;;;;

(defun empty-proc ())
(defmacro wrap-time-x (hold-time &body form)
  `(let ((,hold-time (sys:%microsecond-clock)))	;
     ,@form
     (sys:%32-bit-difference
       (sys:%microsecond-clock)
       ,hold-time)))
(defmacro hog-machine (&body body)
  `(process:with-no-other-processes
     (let ((old-schedule si:inhibit-scheduling-flag)
	   #+imach old-clock-signal)
       (unwind-protect
	   (progn
	     (setf si:inhibit-scheduling-flag 't)
	     #+imach
	     (SYS:SYSTEM-CASE
	       (EMBEDDED
		 (SETQ old-clock-signal (SYS:EMB-CLOCK-SIGNAL))
		 (SETF (SYS:EMB-CLOCK-SIGNAL) -1))
	       (OTHERWISE NIL))			;better to get slightly wrong answer than to blow out
	     ;;used to be part of the #+imach crap that we would execute at higher trap mode.
	     ;; but we can't do that.  Too bad.
	     #-ignore
	     ,@body
	     #+ignore 
	     (sys:%funcall-in-trap-mode 
	       (sys:%set-trap-mode sys:trap-mode-io)
	       #'(lambda () ,@body))
	     )
	 #+imach
	 (SYS:SYSTEM-CASE
	   (EMBEDDED
	     (SETF (SYS:EMB-CLOCK-SIGNAL) old-clock-signal))
	   (OTHERWISE NIL))
	 (setf si:inhibit-scheduling-flag old-schedule)))))
(defmacro really-turn-meter-off ()
  `(progn
     (sys:%meter-off)
     #+imach
     (turn-off-meter-bit *current-process*)
     #+ignore
     (dbg:%meter-on-exit-this-frame 0)))
(defmacro really-turn-meter-on ()
  `(progn
     #+imach
     (turn-on-meter-bit *current-process*)
     #+ignore
     (si:with-metering-disabled
       (dbg:%meter-on-exit-this-frame 1))
     #+3600
     (sys:%meter-on)))
;; if the PROC wants to cancel out some time (if it knows that a particular section has
;; high variablility), then it should INCF* this variable by the amount it wants to cancel
(DEFVAR *internal-trap-time* 0)

(defun compute-histograms-for-fcm
       (proc preamble cleanup trigger count display-results expected-traps-per-call)
  (declare (values elapsed-difference measured-difference n-traps adjusted-time))
  (declare (inline metering:process-metering-overhead))
  ;; don't page later.
  (setf *control-test-traps* t)
  (funcall preamble)
  (funcall proc)
  (setf *control-test-traps* nil)
  (funcall cleanup)
  (really-turn-meter-off)
  (let* ((stack-dumped? 0)
	 (normal-time (make-data-collector 'modal-histogram :entries 100))
	 (overhead-difference (make-data-collector 'modal-histogram :entries 100))
	 (trapping-time (make-data-collector 'modal-histogram :entries 100))
	 (adjusted-time (make-data-collector 'modal-histogram :entries 100))
	 (normal-map-misses (when (eq display-results :computations)
			      (make-data-collector 'modal-histogram :entries 100)))
	 (metered-map-misses (when (eq display-results :computations)
			       (make-data-collector 'modal-histogram :entries 100)))
	 (normal-interrupt-time  (when (eq display-results :computations)
				   (make-data-collector 'modal-histogram :entries 100)))
	 (metered-interrupt-time  (when (eq display-results :computations)
				    (make-data-collector 'modal-histogram :entries 100)))
	 (stack-dump-record #+3600 nil #+imach (make-array (min count 1000) :fill-pointer 0))
	 (ntraps 0)
	 (difference 0)
	 (dumped-physical-stack-address
	   (storage:%vma-to-pma (si:%pointer (locf stack-dumped?)))))
    (macrolet ((total-interrupt-time ()
		 #+3600 'si:*ms-time-sequence-break*
		 #+imach
		 `(sys:with-block-registers (1)
					    (setf (sys:%block-register 1) cli::*interrupt-mode-meters*)
					    (+ (sys:%block-read 1 :fixnum-only t)
					       (sys:%block-read 1 :fixnum-only t)
					       (sys:%block-read 1 :fixnum-only t)
					       (sys:%block-read 1 :fixnum-only t)
					       (sys:%block-read 1 :fixnum-only t)
					       (sys:%block-read 1 :fixnum-only t :prefetch nil)
					       (sys:%block-read 1 :fixnum-only t :prefetch nil))))
	       (map-misses ()
		 #+3600 'si:*count-map-misses*
		 #+imach '(sys:%read-internal-register sys:%register-count-map-reloads)))
      (hog-machine
	(setf *internal-trap-time* 0)
	(let ((ntraps *control-test-trap-count*)
	      (stack-lower-bound
		#+3600 nil
		#+imach (cli::%read-internal-register cli::%register-stack-cache-lower-bound)))
	  (if (eq display-results :computations)
	      (progn
		(loop repeat count do
		  (collect-data normal-time
				(let ((start-cancel-time *internal-trap-time*)
				      (itime (total-interrupt-time))
				      (map-misses (map-misses))
				      (new-value (incf stack-dumped?)))
				  (prog1 (- (wrap-time-x fudge-time (funcall proc))
					    (sys:%32-bit-difference *internal-trap-time* start-cancel-time))
					 (setf map-misses
					       (si:%32-bit-difference (map-misses) map-misses))
					 (setf itime (- (total-interrupt-time) itime))
					 #+imach
					 (vector-push
					   (eql (sys:%memory-read dumped-physical-stack-address
								  :cycle-type sys:%memory-raw)
						new-value)
					   stack-dump-record)
					 (collect-data normal-interrupt-time itime)
					 (collect-data normal-map-misses map-misses)))))
		#+imach
		(when (eq display-results :computations)
		  (let ((new-stack-lower-bound (cli::%read-internal-register
						 cli::%register-stack-cache-lower-bound)))
		    (when (or (not (eql stack-lower-bound new-stack-lower-bound))
			      (eql (sys:%stack-frame-pointer) stack-lower-bound))
		      (format t "~&Stack cache appeared to be dumped FP: ~\\si:address\\ original low: ~\\si:address\\ new low: ~\\si:address\\"
			      (sys:%stack-frame-pointer) stack-lower-bound new-stack-lower-bound)))))
	      (loop repeat count do
		  (collect-data normal-time
				(let ((start-cancel-time *internal-trap-time*))
				  (- (wrap-time-x fudge-time (funcall proc))
				     (sys:%32-bit-difference *internal-trap-time* start-cancel-time))))))
	  (unless (or (eq display-results :silent) (= ntraps *control-test-trap-count*))
	    (format t "~&Took ~D traps while measuring normal form."
		    (- *control-test-trap-count* ntraps))))
		  
	(setf *control-test-traps* t)
	(setf *internal-trap-time* 0)
	(funcall preamble)
	(if (eq display-results :computations)
	    (loop with temp-overhead-difference
		  repeat count do
	      (when trigger
		(funcall trigger))
	      (let* ((initial-trap-count *control-test-trap-count*)
		     (start-overhead (metering:process-metering-overhead process::%real-current-process))
		     (start-cancel-time *internal-trap-time*)
		     (itime (total-interrupt-time))
		     (elapsed-misses (map-misses))
		     (elapsed (prog1 (- (wrap-time-x fudge-time (funcall proc))
					(sys:%32-bit-difference *internal-trap-time* start-cancel-time))
				     (setf elapsed-misses
					   (sys:%32-bit-difference (map-misses) elapsed-misses)))))
		(setq itime (- (total-interrupt-time) itime))
		(incf ntraps (- *control-test-trap-count* initial-trap-count))
		(setf temp-overhead-difference
		      (sys:%32-bit-difference (metering:process-metering-overhead process::%real-current-process)
					      start-overhead))
		(really-turn-meter-off)
		(collect-data metered-map-misses elapsed-misses)
		(collect-data metered-interrupt-time itime)
		(collect-data trapping-time elapsed)
		(collect-data overhead-difference temp-overhead-difference)
		(collect-data adjusted-time (- elapsed temp-overhead-difference))))
	    (loop with temp-overhead-difference
		  repeat count do
	      (when trigger
		(funcall trigger))
	      (let* ((initial-trap-count *control-test-trap-count*)
		     (start-overhead (metering:process-metering-overhead process::%real-current-process))
		     (start-cancel-time *internal-trap-time*)
		     (elapsed (- (wrap-time-x fudge-time (funcall proc))
				 (sys:%32-bit-difference *internal-trap-time* start-cancel-time))))
		(incf ntraps (- *control-test-trap-count* initial-trap-count))
		(setf temp-overhead-difference
		      (sys:%32-bit-difference (metering:process-metering-overhead process::%real-current-process)
					      start-overhead))
		(really-turn-meter-off)
		(collect-data trapping-time elapsed)
		(collect-data overhead-difference temp-overhead-difference)
		(collect-data adjusted-time (- elapsed temp-overhead-difference)))))))
    (really-turn-meter-off)
    (funcall cleanup)
    (setq difference (- (total trapping-time) (total normal-time)))

    (multiple-value-bind (low high)
	(get-reasonable-histogram-bounds adjusted-time)
      (ignore high)
      (when (eq display-results :computations)
	(flet ((show-histogram (h)
		 (dw:with-output-as-presentation (:object h :type 'metering-results)
		   (format t " ~D " (total h)))))
	  (format t "~&Normal time: ")
	  (show-histogram normal-time)
	  (format t " Trapping time: ")
	  (show-histogram trapping-time)
	  (format t " Measured Overhead : ")
	  (show-histogram overhead-difference)
	  (format t " Differences: ")
	  (show-histogram adjusted-time)
	  (format t "~&Normal map misses: ")
	  (show-histogram normal-map-misses)
	  (format t " metered map misses: ")
	  (show-histogram metered-map-misses)
	  (format t " Normal interrupt time: ")
	  (show-histogram normal-interrupt-time)
	  (format t " metered interrupt time: ")
	  (show-histogram metered-interrupt-time)
	  (dw:with-output-as-presentation (:object stack-dump-record :type 'array)
	    (format t " total stack-dumps: ~D" (count t stack-dump-record))))
	(format t "~&The difference between trapping case (~D) and normal case (~D) for ~D repetitions is ~D (or ~F per call)"
		(total trapping-time) (total normal-time) count difference (float (/ difference count)))
	(format t "~&The measured overhead was ~D, or ~F per call, using ~D traps"
		(total overhead-difference) (float (/ (total overhead-difference) count)) ntraps)
	(format t "~&So the unaccounted overhead was ~D, or ~F per call, ~F per set of traps"
		(- difference (total overhead-difference))
		(float (/ (- difference (total overhead-difference)) count))
		(if (plusp ntraps)
		    (float (/ (- difference (total overhead-difference))
			      (/ ntraps expected-traps-per-call)))
		    0))
	(format t "~&Using only the main mode, unaccounted time is ~F"
		(- low #+ignore (reasonable-average normal-time) #-ignore 0)))
      (values difference (total overhead-difference) ntraps
	      (- low #+ignore (/ (reasonable-total normal-time) (reasonable-entry-count normal-time ))
		 #-ignore 0)))))

#+imach
(defun force-stack-dump ()
  (let* ((stack-dumped? 0)
	 (dumped-physical-stack-address
	   (storage:%vma-to-pma (si:%pointer (locf stack-dumped?)))))
    (let ((old-value (sys:%memory-read dumped-physical-stack-address
				       :cycle-type sys:%memory-raw))
	  (new-value (incf stack-dumped?)))
      (sleep 1)
      (format t "~&Current: ~S original: ~S local: ~S"
	      (sys:%memory-read dumped-physical-stack-address :cycle-type sys:%memory-raw)
	      old-value new-value))))
(defvar *calibrate-collector*
	(make-data-collector 'collect-hash
			     :component-description
			     '((time modal-histogram :entries 100))))
(defun call-empty () (empty-proc))

(defun mempty-proc (&key count-limit time-limit)
  (metering:with-form-measured (:values t :verbose nil
					:count-limit count-limit :time-limit time-limit)
    (empty-proc)))
(defun calibrate-fudge-factor (count display-results message)
  (declare (values callee-histogram caller-histogram))
  (clear-trigger 'all-function-calls)
  (reset-collector *calibrate-collector*)
  (generate-data-at-trigger 'all-function-calls
			    `((real-time :keywords
					 (:overhead :exclusive (:name excl-real-time)))
			      #+3600 (function frame-pointer)))
  (collect-data-from-trigger 'all-function-calls
			     `(((,*calibrate-collector* function)
				(time excl-real-time))))
  (hog-machine
    (unwind-protect
	(progn
	  (set-scope-of-control 'all-function-calls 
				`(and (:process ,*current-process*) (:region calibrate)))
	  (meter-form (calibrate) () (loop repeat count do (call-empty))))
      (set-scope-of-control 'all-function-calls nil)
      (clear-trigger 'all-function-calls)))
  (let ((internal-results
	  (metering:get-component-from-components
	    'time
	    (collect-data-for-value *calibrate-collector* #'empty-proc)
	    *calibrate-collector*))
	(incl-results
	  (get-component-from-components
	    'time
	    (collect-data-for-value *calibrate-collector* #'call-empty)
	    *calibrate-collector*)))
    (when (eq display-results :computations)
      (fresh-line)
      (terpri)
      (flet ((copy-histogram (h)
	       (let ((h2 (make-data-collector 'modal-histogram :entries 100)))
		 (combine h2 h)
		 h2)))
	(setq internal-results (copy-histogram internal-results ))
	(setq incl-results (copy-histogram incl-results )))
      (dw:with-output-as-presentation
		  (:object internal-results :type 'metering-results)
		(format t "~&~A the total-internal time was ~D for ~D repetitions, with a minimum time of ~D"
			message (total internal-results) (entry-count internal-results)
			(get-histogram-bounds internal-results)))
	      (dw:with-output-as-presentation
		  (:object incl-results :type 'metering-results)
		(format t "~&~A the total inclusive time was ~D for ~D repetitions, with a minimum time of ~D"
			message (total incl-results) (entry-count incl-results)
			(get-histogram-bounds incl-results))))
    (values internal-results incl-results)))
(defun set-factors-and-fixup-fractions (entry-ff1 entry-ff2 exit-ff1 exit-ff2)
  (let* ((entry-fraction
	   (multiple-value-bind (integer fraction-n1)
	       (floor entry-ff1)
	     (setf *function-entry-fudge-factor-1* integer)
	     (multiple-value-bind (integer fraction-n2)
		 (floor entry-ff2)
	       (setf *function-entry-fudge-factor-2* integer)
	       (+ fraction-n1 fraction-n2))))
	 (exit-fraction
	   (multiple-value-bind (integer fraction-x1)
	       (floor exit-ff1)
	     (setf *function-exit-fudge-factor-1* integer)
	     (multiple-value-bind (integer fraction-x2)
		 (floor exit-ff2)
	       (setf *function-exit-fudge-factor-2* integer)
	       (+ fraction-x1 fraction-x2)))) 
	 (count (lcm (denominator entry-fraction) (denominator exit-fraction))))
    (setf *function-trap-fudge-denominator* count)
    (multiple-value-bind (integer fraction)
	(floor entry-fraction)
      (incf *function-entry-fudge-factor-2* integer)
      (setf *function-entry-fudge-fraction* (* fraction count)))
    (multiple-value-bind (integer fraction)
	(floor exit-fraction)
      (incf *function-exit-fudge-factor-2* integer)
      (setf *function-exit-fudge-fraction* (* fraction count)))))
;;; replace sys:meter-function-entry with metering:metering-function-entry-handler
	   
;; display-results: NIL 	       	only show warnings
;;		    :SILENT		print nothing whatsoever
;;		    :COMPUTATIONS	print every gory detail.
;;		    <anything else>	same as nil, but also show summaries.

(defun compute-fudge-factor (&optional (count 2500.) (display-results nil))
  (declare (values exact-fudge-factors integer-values consistent-p))
  #+(or 3600 (and imach (not vlm)))
  (let* ((flag-value 0)
	 (silent (eq display-results :SILENT))
	 (display-results (and (not silent) display-results))
	 (inconsistencies nil))
    (tv:noting-progress ("Computing metering fudge factors.")
    (clear-trigger 'all-function-calls)
    (when display-results
      (format t "~&Clearing old fudge-factors.  Setting to 0."))
    (setf *function-entry-fudge-factor-1* 0)
    (setf *function-entry-fudge-factor-2* 0)
    (setf *function-exit-fudge-factor-1* 0)
    (setf *function-exit-fudge-factor-2* 0)
    (setf *function-trap-fudge-denominator* 0)
    (setf *function-entry-fudge-fraction* 0)
    (setf *function-exit-fudge-fraction* 0)
    (setf *function-fudge-factor-error* 0)
    (setf *function-caller-fudge-factor-error* 0)
    (setf *function-callee-fudge-factor-error* 0)
    (flet
      ((equal-within (a b tolerance)
	 (< (abs (- a b)) (if (integerp tolerance) tolerance (min 2 (* tolerance (max a b))))))
       (trap-on-exit ()
	 #+3600
	 (setf (sys:frame-meter-bit (si:%stack-frame-pointer)) flag-value)
	 #+imach
	 (let ((start-time (sys:%microsecond-clock)))
	   (flet ((do-it (value)
		    (let* ((our-fp (sys:%stack-frame-pointer))
			   (fp (sys:%pointer-plus
				 our-fp
				 (- (ldb sys:%%cr.caller-frame-size
					 (sys:%read-internal-register
					   sys:%register-control-register))))))
		      (unless (zerop value)
			(si:%funcall-in-aux-stack #'storage::set-trap-on-exit-flag
						  fp our-fp si:%current-stack-group 1)
			(setf (sys:%logldb si:%%cr.call-trace (cli::%saved-control-register))
			      1)))))
	     (do-it flag-value))
	   (si:incf* *internal-trap-time*
		     (sys:%32-bit-difference (sys:%microsecond-clock) start-time))))
       (compute-in-env (descript function preamble cleanup trigger traps-per-call)
	 (when (eq display-results :computations)
	   (format t "~&~%~S" descript))
	 (multiple-value-bind (elapsed measured ntraps adjusted)
	     (compute-histograms-for-fcm
	       function preamble cleanup trigger count display-results traps-per-call)
	   (ignore elapsed measured ntraps)
	   adjusted))
       (turn-on-both ()
	 (set-scope-of-control 'all-function-calls `(:process ,si:*current-process*)))
       (turn-off-both () (set-scope-of-control 'all-function-calls nil))
       #+imach
       (trigger-metering ()
	 (setf (sys:%logldb si:%%cr.call-trace (cli::%saved-control-register))
	       1))
       (turn-on-first ()
	 (set-scope-of-control 'all-function-calls
			       `(and (:process ,si:*current-process*)
				     *force-control-to-evaluate-scope*)))
       (turn-on-flag () (setf flag-value 1))
       (turn-off-second ()
	 #+imach
	 (let* ((fp (sys:%stack-frame-pointer))
		(caller-fp (sys:%pointer-plus fp
					      (- (ldb sys:%%cr.caller-frame-size
						      (sys:%read-internal-register
							sys:%register-control-register))))))
	   (si:%funcall-in-aux-stack
	     #'storage::set-trap-on-exit-flag caller-fp fp si:%current-stack-group 0))
	 (setf flag-value 0)))

      ;; first, figure out the total fudge needed, and balance between entry and exit.
      (let* ((unaccounted-total
	       (compute-in-env
		 "Using both" #'empty-proc #'turn-on-both #'turn-off-both
		 #+3600 #'sys:%meter-on #+imach #'trigger-metering 2))
	     (unaccounted-entry
	       (compute-in-env "Just first" #'empty-proc #'turn-on-first #'turn-off-both
		 #+3600 #'sys:%meter-on #+imach #'trigger-metering 1))
	     (unaccounted-exit
	       (compute-in-env
		 "Just second" #'trap-on-exit #'turn-on-flag #'turn-off-second 
		 #'turn-on-flag 1))
	     (discrepancy (- (+ unaccounted-exit unaccounted-entry) unaccounted-total)))

	;; are the results self-consistent?
	(unless (equal-within unaccounted-total (+ unaccounted-exit unaccounted-entry) 1)
	  (setq inconsistencies 't)
	  (unless silent
	    (format *error-output*
		    "~&The total fudge-factor (~D usecs) is not within a microsecond of ~
the sum of entry fudge-factor (~D usecs) and the exit fudge-factor (~D usecs). ~
Try running (COMPUTE-FUDGE-FACTOR COUNT) with a higher value of COUNT than ~D."
		    unaccounted-total unaccounted-entry unaccounted-exit count))
	  ;; make sure that the numbers we eventually use don't add up to more than
	  ;; unaccounted total.  We're guessing here, but unaccounted-total is more
	  ;; important than the breakdown between entry and exit.
	  (when (plusp discrepancy)
	    (if (and (< (floor discrepancy 2) unaccounted-entry)
		     (< (floor discrepancy 2) unaccounted-exit))
		(progn
		  (decf unaccounted-entry (floor discrepancy 2))
		  (decf unaccounted-exit (ceiling discrepancy 2)))
		(if (< unaccounted-entry unaccounted-exit)
		    (progn
		      (setf unaccounted-entry 0)
		      (setf unaccounted-exit unaccounted-total))
		    (progn
		      (setf unaccounted-exit 0)
		      (setf unaccounted-entry unaccounted-total))))))

	(let ((entry-ff1 0)
	      (entry-ff2 unaccounted-entry)
	      (exit-ff1 unaccounted-exit)
	      (exit-ff2 0))
	  (set-factors-and-fixup-fractions entry-ff1 entry-ff2 exit-ff1 exit-ff2)

	  ;; calibrate between caller and callee, and see if we can get a handle on the
	  ;; expected error.
	  (multiple-value-bind (internal-results incl-results)
	      (calibrate-fudge-factor count display-results "Using the fudge factors")
	    (let ((callee-error (get-histogram-bounds internal-results))
		  (callee-adjust 0))
	      ;; adjust between caller and callee
	      (if (minusp callee-error)
		  (let* ((adjust (abs callee-error))
			 (adjust-entry (min (/ adjust 2) entry-ff2))
			 (adjust-exit (min exit-ff1 (- adjust adjust-entry))))
		    (when (eq display-results :computations)
		      (format t "~&Adjusting entry by ~D, and exit by ~D"
			      adjust-entry adjust-exit))
		    (setf callee-adjust (+ adjust-entry adjust-exit))
		    (incf callee-error callee-adjust)
		    (decf entry-ff2 adjust-entry)
		    (incf entry-ff1 adjust-entry)
		    (decf exit-ff1 adjust-exit)
		    (incf exit-ff2 adjust-exit)
		    (set-factors-and-fixup-fractions entry-ff1 entry-ff2 exit-ff1 exit-ff2))
		(progn
		  (setq inconsistencies 't)
		  (unless silent
		    (format *error-output*
			    "~&Charging all of the fudge factors to the callee, and none to the caller, resulted in an ~@
exclusive time of ~F useconds for an empty function call.      This is possible, but hard
to believe."
			    (reasonable-average internal-results)))))

	      ;; compute potential errors

	      ;; assume the internal time of the empty-proc should be around 0.
	      (setq *function-callee-fudge-factor-error*
		    (max (float (abs callee-error))
			 ;; the 1- is to allow for the low being 1 off of the average,
			 ;; even though the average is close to 1 (say .99), probabilistically
			 ;; we'd still probably get at least a single 0 entry.  So we can't
			 ;; include that as part of the error.
			 (1- (abs (+ (reasonable-average internal-results) callee-adjust)))))

	      ;; assume that most of the cost of calling the empty-proc is function-call
	      ;; overhead
	      (multiple-value-bind (avg h)
		  (mempty-proc :count-limit count)
		(ignore avg)
		(let ((too-short? (- (get-histogram-bounds h)
				     (1- (+ (get-histogram-bounds incl-results)
					    callee-adjust)))))
		  ;; only *think* it's an error, if the time with fudge is *shorter* than
		  ;; the define-metering-function case.
		  (setq *function-caller-fudge-factor-error*
			(max too-short?
			     (- (reasonable-average incl-results) (reasonable-average h))
			     0))))
	      (setf *function-fudge-factor-error*
		    (max (abs discrepancy)
			 (+ *function-callee-fudge-factor-error*
			    *function-caller-fudge-factor-error*)))))
	  
	  (when display-results
	    (format t "~&~%Error ranges: For callee: ~S for caller: ~S total: ~S"
		    *function-callee-fudge-factor-error* *function-caller-fudge-factor-error*
		    *function-fudge-factor-error*))
	    
	  (when (or (minusp entry-ff2) (minusp entry-ff1)
		    (minusp exit-ff2) (minusp exit-ff1))
	    (if silent
		(progn
		  ;; don't bother printing wimpy retry suggestion.
		  (setq inconsistencies t)
		  (format *error-output*
			  "~&The computed fudge factors, ~D, ~D, ~D, and ~D are not valid.~
~%It's a very good idea to try to run COMPUTE-FUDGE-FACTOR again.~%"
			  entry-ff2 entry-ff1 exit-ff2 exit-ff1))
		(setq inconsistencies 't)))
	    
	  (when (and inconsistencies (not silent))
	    (format *error-output*
		    "~&~%There were some internal inconsistencies in the computations.
You might try running (COMPUTE-FUDGE-FACTOR) again, to get slightly better numbers."))

	  (set-factors-and-fixup-fractions entry-ff1 entry-ff2 exit-ff1 exit-ff2)
						   
	  (when (eq display-results :computations)
	    (format t "~&~%~%Check for overhead values of system traps with fudge factors.")
	    (format t "~&~%Both")
	    (flet ((test-it ()
	    (compute-histograms-for-fcm
	      #'empty-proc #'turn-on-both #'turn-off-both #+3600 #'sys:%meter-on #+imach #'trigger-metering count display-results 2)))
	      (funcall #'test-it))
	    (format t "~&~%First")
	    (compute-histograms-for-fcm
	      #'empty-proc #'turn-on-first #'turn-off-both #+3600 #'sys:%meter-on #+imach #'trigger-metering count display-results 1)
	    (format t "~&~%Second")
	    (compute-histograms-for-fcm
	      #'trap-on-exit #'turn-on-flag #'turn-off-second #'turn-on-flag count display-results 1)
	    (format t "~%~%"))
	  (values (list entry-ff1 entry-ff2 exit-ff1 exit-ff2)
		  (list *function-entry-fudge-factor-1* *function-entry-fudge-factor-2*
			*function-entry-fudge-fraction*
			*function-exit-fudge-factor-1* *function-exit-fudge-factor-2*
			*function-exit-fudge-fraction*
			*function-callee-fudge-factor-error*
			*function-caller-fudge-factor-error* *function-fudge-factor-error*)
		  (not inconsistencies))))))))




#||
(defvar *last-timestamp* 0)

(defvar *seperate-entry-total* 0)

(defvar *seperate-exit-total* 0)

(defvar *entry-total* 0)

(defvar *exit-total* 0)

(defvar *trap-entry-total* 0)

(defvar *trap-exit-total* 0)

(defun test-meter-function-entry-timestamp (old-inhibit-scheduling-flag)
  (declare (si:safeguarded-function si:disable-reference-validation))
  (let* ((start-time (sys:%32-bit-difference (sys:%microsecond-clock)
					     *function-entry-fudge-factor-1*))
	 (fp (sys:frame-previous-frame (sys:%stack-frame-pointer)))
	 (ancestor-collecting-overhead? *metering-overhead-accounted*)
	 (*metering-overhead-accounted* 't)
	(meter-on 't)
	(b nil))
    (ignore meter-on b)
    (setf si:inhibit-scheduling-flag old-inhibit-scheduling-flag)
    (incf *trap-entry-total* (sys:%32-bit-difference start-time *last-timestamp*))
    (setf (sys:frame-meter-bit fp) 1)
    (let ((si:inhibit-scheduling-flag 't))
      (unless ancestor-collecting-overhead? 
	(let ((adjusted-start-time start-time))
	  (si:incf* (process-metering-overhead si:*current-process*)
		    (sys:%32-bit-difference (sys:%microsecond-clock) adjusted-start-time))))
      ;; It is critical that SETF *LAST-TIMESTAMP* be outside of the SI:INCF*, because
      ;; otherwise the LET-SUBST-DECIDE sees a side-effect in the VALUE, and binds
      ;; process-metering-overhead *before* reading the clock, so the perceived cost
      ;; of adding the timestamp is *negative*!!! Would really screw up calibration.
      (setf *last-timestamp* (sys:%microsecond-clock))
      (setf *metering-overhead-accounted* ancestor-collecting-overhead?)
      ;; this meter-on is necessary, otherwise not only do we miss the fraction of
      ;; a microsecond that it takes to perform this operation, but, the previous form
      ;; compiles differently, and costs us about 2 microseconds!!!
      (when meter-on (sys:%meter-on))))
  nil)

(defun test-meter-function-exit-timestamp (old-inhibit-scheduling-flag)
  (declare (si:safeguarded-function si:disable-reference-validation))
  (let* ((start-time (sys:%32-bit-difference (sys:%microsecond-clock)
					     *function-exit-fudge-factor-1*))
	 (fp (sys:frame-previous-frame (sys:%stack-frame-pointer)))
	 (ancestor-collecting-overhead? *metering-overhead-accounted*)
	 (*metering-overhead-accounted* 't)
	(meter-on 't))
    (ignore meter-on)
    (setf si:inhibit-scheduling-flag old-inhibit-scheduling-flag)
    (incf *trap-exit-total* (sys:%32-bit-difference start-time *last-timestamp*))
    (setf (sys:frame-meter-bit fp) 0)
    (let ((si:inhibit-scheduling-flag 't))
      (unless ancestor-collecting-overhead? 
	(let ((adjusted-start-time start-time))
	  (si:incf* (process-metering-overhead si:*current-process*)
		    (sys:%32-bit-difference (sys:%microsecond-clock) adjusted-start-time))))
      ;; It is critical that SETF *LAST-TIMESTAMP* be outside of the SI:INCF*, because
      ;; otherwise the LET-SUBST-DECIDE sees a side-effect in the VALUE, and binds
      ;; process-metering-overhead *before* reading the clock, so the perceived cost
      ;; of adding the timestamp is *negative*!!! Would really screw up calibration.
      (setf *last-timestamp* (sys:%microsecond-clock))
      (setf *metering-overhead-accounted* ancestor-collecting-overhead?)
      ;; this meter-on is necessary, otherwise not only do we miss the fraction of
      ;; a microsecond that it takes to perform this operation, but, the previous form
      ;; compiles differently, and costs us about 2 microseconds!!!
      (when meter-on (sys:%meter-on))))
  nil)

(defun test-meter-function-entry-timestamp-1 (old-inhibit-scheduling-flag)
  (declare (si:safeguarded-function si:disable-reference-validation))
  (let* ((start-time (sys:%32-bit-difference (sys:%microsecond-clock)
					     *function-entry-fudge-factor-1*))
	 (fp (sys:frame-previous-frame (sys:%stack-frame-pointer)))
	 (ancestor-collecting-overhead? *metering-overhead-accounted*)
	 (*metering-overhead-accounted* 't)
	(meter-on 't)
	(b nil))
    (ignore meter-on b)
    (setf si:inhibit-scheduling-flag old-inhibit-scheduling-flag)
    (setf (sys:frame-meter-bit fp) 0)
    (incf *trap-entry-total* (sys:%32-bit-difference start-time *last-timestamp*))
    (let ((si:inhibit-scheduling-flag 't))
      (unless ancestor-collecting-overhead? 
	(let ((adjusted-start-time start-time))
	  (si:incf* (process-metering-overhead si:*current-process*)
		    (sys:%32-bit-difference (sys:%microsecond-clock) adjusted-start-time))))
      ;; It is critical that SETF *LAST-TIMESTAMP* be outside of the SI:INCF*, because
      ;; otherwise the LET-SUBST-DECIDE sees a side-effect in the VALUE, and binds
      ;; process-metering-overhead *before* reading the clock, so the perceived cost
      ;; of adding the timestamp is *negative*!!! Would really screw up calibration.
      (setf *last-timestamp* (sys:%microsecond-clock))
      (setf *metering-overhead-accounted* ancestor-collecting-overhead?)
      ;; this meter-on is necessary, otherwise not only do we miss the fraction of
      ;; a microsecond that it takes to perform this operation, but, the previous form
      ;; compiles differently, and costs us about 2 microseconds!!!
      (when meter-on (sys:%meter-on))))
  nil)

(defun test-meter-function-exit-timestamp-1 (old-inhibit-scheduling-flag)
  (declare (si:safeguarded-function si:disable-reference-validation))
  (let* ((start-time (sys:%32-bit-difference (sys:%microsecond-clock)
					     *function-exit-fudge-factor-1*))
	 (fp (sys:frame-previous-frame (sys:%stack-frame-pointer)))
	 (ancestor-collecting-overhead? *metering-overhead-accounted*)
	 (*metering-overhead-accounted* 't)
	 (meter-on nil))
    (setf si:inhibit-scheduling-flag old-inhibit-scheduling-flag)
    (setf (sys:frame-meter-bit fp) 0)
    (incf *trap-exit-total* (sys:%32-bit-difference start-time *last-timestamp*))
    (let ((si:inhibit-scheduling-flag 't))
      (unless ancestor-collecting-overhead? 
	(let ((adjusted-start-time start-time))
	  (si:incf* (process-metering-overhead si:*current-process*)
		    (sys:%32-bit-difference (sys:%microsecond-clock) adjusted-start-time))))
      ;; It is critical that SETF *LAST-TIMESTAMP* be outside of the SI:INCF*, because
      ;; otherwise the LET-SUBST-DECIDE sees a side-effect in the VALUE, and binds
      ;; process-metering-overhead *before* reading the clock, so the perceived cost
      ;; of adding the timestamp is *negative*!!! Would really screw up calibration.
      (setf *last-timestamp* (sys:%microsecond-clock))
      (setf *metering-overhead-accounted* ancestor-collecting-overhead?)
      ;; this meter-off is necessary, otherwise not only do we miss the fraction of
      ;; a microsecond that it takes to perform this operation, but, the previous form
      ;; compiles differently, and costs us about 2 microseconds!!!
      (when meter-on (sys:%meter-off))))
  nil)
	  	  
(defun compute-timestamped-fudge-factors (display-results silent)
  (flet
    ((compute-with-timestamp (proc preamble cleanup)
       (declare (values elapsed-difference measured-difference))
       ;; don't page later.
       (funcall preamble)
       (funcall proc)
       (funcall cleanup)
       (funcall preamble)
       (funcall cleanup)
       (sys:%meter-off)
       (let* ((normal-time
		(hog-machine
		  (wrap-time fudge-time (loop repeat count do
					  (setf *last-timestamp* (sys:%microsecond-clock))
					  (funcall proc)
					  (let ((exit-time (sys:%microsecond-clock)))
					    (incf *exit-total*
						  (sys:%32-bit-difference
						    exit-time *last-timestamp*)))))))
	      (overhead-difference nil) 
	      (trapping-time
		(prog1
		  (hog-machine
		    (funcall preamble)
		    (let ((start-overhead (process-metering-overhead *current-process*)))
		      (prog1
			(wrap-time fudge-time (loop repeat count do
						(setf *last-timestamp* (sys:%microsecond-clock))
						(funcall proc)
						(let ((exit-time (sys:%microsecond-clock)))
						  (incf *exit-total*
							(sys:%32-bit-difference
							  exit-time *last-timestamp*)))))
			(setf overhead-difference
			      (sys:%32-bit-difference
				(process-metering-overhead *current-process*)
				start-overhead)))))
		  (sys:%meter-off)
		  (funcall cleanup)))
	      (difference (- trapping-time normal-time)))
	 (when (eq display-results :computations)
	   (format t "~&The difference between trapping case (~D) and normal case (~D) for ~D repetitions is ~D (or ~F per call)"
		   trapping-time normal-time count difference (float (/ difference count)))
	   (format t "~&The measured overhead was ~D, or ~F per call"
		   overhead-difference (float (/ overhead-difference count)))
	   (format t "~&So the unaccounted overhead was ~D, or ~F per call"
		   (- difference overhead-difference)
		   (float (/ (- difference overhead-difference) count))))
	 (values difference overhead-difference))))
    (unless (equal-within (- unaccounted-total-with-timestamp
			     (+ unaccounted-exit-with-timestamp
				unaccounted-entry-with-timestamp))
			  (- unaccounted-total (+ unaccounted-exit unaccounted-entry))
			  1)
      (setq inconsistencies 't)
      (unless silent
	(format t "~& ( (- ~D (+ ~D ~D)) (- ~D (+ ~D ~D)))"
		unaccounted-total-with-timestamp
		unaccounted-exit-with-timestamp
		unaccounted-entry-with-timestamp
		unaccounted-total unaccounted-exit unaccounted-entry)
	(format *error-output*
		"~&The timestamp computations and the normal computations don't correlate.")))
    (unless (and (equal-within (- unaccounted-total-with-timestamp unaccounted-total)
			       (+ (- unaccounted-entry-with-timestamp unaccounted-entry)
				  (- unaccounted-exit-with-timestamp unaccounted-exit))
			       1)
		 (equal-within (- unaccounted-entry-with-timestamp unaccounted-entry)
			       (- unaccounted-exit-with-timestamp unaccounted-exit)
			       .5))
      (setq inconsistencies 't)
      (unless silent
	(format *error-output*
		"~&The timestamp computations (~D useconds) for total, should take roughly twice as long ~
as each of entry (~D usecs) and exit (~D usecs), both of which should be roughly equal."
		(- unaccounted-total-with-timestamp unaccounted-total)
		(- unaccounted-entry-with-timestamp unaccounted-entry)
		(- unaccounted-exit-with-timestamp unaccounted-exit))))	  
    (letf ((#'sys:meter-function-entry #'test-meter-function-entry-timestamp)
	   (#'sys:meter-function-exit #'test-meter-function-exit-timestamp))
      (when (eq display-results :computations)
	(format t "~&~%Seperate out call and return times."))
      (compute-with-timestamp 
	#'timestamp-proc
	#'(lambda ()
	    (setq *seperate-entry-total* *entry-total*)
	    (setq *seperate-exit-total* *exit-total*)
	    (setq *entry-total* 0)
	    (setq *exit-total* 0)
	    (setq *trap-entry-total* 0)
	    (setq *trap-exit-total* 0)
	    (sys:%meter-on)
	    (values))
	#'sys:%meter-off))))
||#
