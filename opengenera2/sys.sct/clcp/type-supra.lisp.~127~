;;; -*- Mode: LISP; Package: Common-lisp-internals; Syntax:Common-Lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Superstructure of Common Lisp type system -- actual type definitions (first file)

;;; Basic type expressions

(DEFINE-SUBTYPEP-FUNCTION (DEFAULT DEFAULT) (IGNORE TYPE-1 ARGS-1 IGNORE TYPE-2 ARGS-2)
  (IF (AND (EQ TYPE-1 TYPE-2)
	   (LOOP FOR ARG1 IN ARGS-1
		 FOR ARG2 IN ARGS-2
		 ALWAYS (OR (EQ ARG2 '*)
			    (EQUAL ARG1 ARG2))))
      (VALUES T T)
      (VALUES NIL T)))


(DEFINE-DEFTYPE-PLACEHOLDER SATISFIES)

(DEFINE-TYPEP-FUNCTION-AND-SUBST-EXPANDER SATISFIES (OBJECT PREDICATE &REST PREDICATE-ARGS)
  (APPLY PREDICATE OBJECT PREDICATE-ARGS))

(DEFINE-TYPE-PRINTER SATISFIES (STREAM PREDICATE &REST PREDICATE-ARGS)
  (FORMAT STREAM "an object satisfies the predicate ~S~@[ with additional arguments ~A~]"
	  PREDICATE PREDICATE-ARGS))

(DEFINE-SUBTYPEP-FUNCTION (SATISFIES SATISFIES)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (EQUAL ARGS-1 ARGS-2)
      (VALUES T T)
      (VALUES NIL NIL)))

(DEFINE-SUBTYPEP-FUNCTION (SATISFIES DEFAULT
			   DEFAULT SATISFIES)
			  (IGNORE IGNORE IGNORE IGNORE IGNORE IGNORE)
  (VALUES NIL NIL))


(DEFINE-DEFTYPE-PLACEHOLDER MEMBER)

(DEFINE-TYPEP-FUNCTION-AND-SUBST-EXPANDER MEMBER (OBJECT &REST LIST)
  (NOT (NOT (MEMBER OBJECT LIST))))

(DEFINE-TYPE-PRINTER MEMBER (STREAM &REST LIST)
  (CASE (LIST-LENGTH LIST)
    (0 (WRITE-STRING "a member of the empty set" STREAM))
    (1 (PRIN1 (FIRST LIST) STREAM))
    (OTHERWISE (WRITE-STRING "one of " STREAM)
	       (FORMAT-TEXTUAL-LIST LIST #'PRIN1
				    :STREAM STREAM :CONJUNCTION "or"
				    :FILLED T :AFTER-LINE-BREAK "       "))))

(DEFINE-SUBTYPEP-FUNCTION (MEMBER *) (IGNORE IGNORE (&REST OBJECTS)
				      TYPE IGNORE IGNORE)
  (CONDITION-CASE ()
       (IF (LOOP FOR OBJECT IN OBJECTS
		 ALWAYS (TYPEP OBJECT TYPE))
	   (VALUES T T)
	   (VALUES NIL T))
     (ERROR (VALUES NIL NIL))))	;Can happen while compiling, if TYPE not yet really defined

(DEFUN (MEMBER EQUAL-TYPEP) (LIST1 LIST2)
  (AND (= (LIST-LENGTH LIST1) (LIST-LENGTH LIST2))
       (LOOP FOR OBJECT IN LIST1
	     ALWAYS (MEMBER OBJECT LIST2))))


(DEFINE-DEFTYPE-PLACEHOLDER NOT)

(DEFINE-TYPEP-FUNCTION-AND-SUBST-EXPANDER NOT (OBJECT TYPE)
  (NOT (TYPEP OBJECT TYPE)))

(DEFUN (NOT TYPE-EXPAND) (TYPE ARGS TERMINAL-TYPES OPTIMIZE SUB-TERMINAL-TYPES)
  (IF OPTIMIZE
      (MULTIPLE-VALUE-BIND (TYPE TYPE-NAME ARGS)
	  (TYPE-EXPAND (FIRST ARGS) TERMINAL-TYPES OPTIMIZE SUB-TERMINAL-TYPES)
	(IF (EQ TYPE-NAME 'NOT)
	    (FIRST ARGS)
	    `(NOT ,TYPE)))
      TYPE))

(DEFINE-TYPE-PRINTER NOT (STREAM TYPE)
  (PRINC "not " STREAM)
  (PRINT-TYPE-DESCRIPTION TYPE STREAM))

;;; Generally, the complement of a set will only be a subset of the universe.
;;; We could have TYPE-EXPAND have a database to fixup (SUBTYPEP '(NOT (NOT x)) 'x),
;;; but I doubt that is worth it.
(DEFINE-SUBTYPEP-FUNCTION (NOT DEFAULT) (IGNORE IGNORE IGNORE
					 IGNORE IGNORE IGNORE)
  (VALUES NIL NIL))


(DEFINE-DEFTYPE-PLACEHOLDER OR)

(DEFINE-TYPEP-FUNCTION OR (OBJECT &REST TYPES)
  (LOOP FOR TYPE IN TYPES
	THEREIS (TYPEP OBJECT TYPE)))

(DEFINE-TYPEP-EXPANDER OR (OBJECT &REST TYPES)
  (ZL:ONCE-ONLY (OBJECT)
    `(OR . ,(LOOP FOR TYPE IN TYPES
		  COLLECT `(TYPEP ,OBJECT ',TYPE)))))

;;; Optimize OR type expressions by removing types that are covered by other types.
;;; But preserve the order of type tests (see Mary Poppins page 37).
;;; Type expansion happens -after- duplicate removal because type expansion can
;;; produce type expressions, e.g. involving satisfies, that SUBTYPEP can't grok.
(DEFUN (OR TYPE-EXPAND) (TYPE ARGS TERMINAL-TYPES OPTIMIZE SUB-TERMINAL-TYPES)
  TERMINAL-TYPES  ;not used
  (LABELS ((TRY-SUPERTYPES (LIST)
	     ;; turn (OR NULL CONS) into LIST, etc.
	     (IF (AND (CONSP LIST) (REST LIST))	;at least two things
		 (LET* ((TYPE (FIRST LIST))
			(CLASS (CLOS:FIND-CLASS (IF (CONSP TYPE) (FIRST TYPE) TYPE) NIL)))
		   (WHEN CLASS
		     (STACK-LET ((OR-TYPE `(OR ,@LIST)))
		       (DOLIST (SUPERCLASS (CLOS:CLASS-DIRECT-SUPERCLASSES CLASS))
			 (LET ((SUPERTYPE (CLOS:CLASS-NAME SUPERCLASS)))
			   (WHEN (SUBTYPEP SUPERTYPE OR-TYPE)
			     ;; if we find one, remove now-extraneous subtypes
			     ;; and look for a further supertype
			     (RETURN-FROM TRY-SUPERTYPES
			       (TRY-SUPERTYPES
				 `(,SUPERTYPE
				   ,@(DELETE TYPE (REST LIST) :TEST #'SUPERTYPEP)))))))))
		   ;; no interesting supertypes for the first type,
		   ;; so look at the next
		   ;; no need to consider this type further, since anything which
		   ;; would include it should have already been found
		   `(,TYPE
		     ,@(TRY-SUPERTYPES (REST LIST))))
		 LIST)))
    (COND (OPTIMIZE
	   ;; Copy arguments and flatten embedded ORs
	   (SETQ ARGS (MAPCAN #'(LAMBDA (TYPE)
				  (MULTIPLE-VALUE-BIND (TYPE TYPE-NAME TYPE-ARGS)
				      (TYPE-EXPAND TYPE (CONS 'OR *STANDARD-TERMINAL-TYPES*))
				    (IF (EQ TYPE-NAME 'OR) (COPY-LIST TYPE-ARGS) (LIST TYPE))))
			      ARGS))
	   ;; Remove covered terms
	   (SETQ ARGS (DELETE-DUPLICATES (DELETE-DUPLICATES ARGS :TEST #'SUBTYPEP :REPLACE T)
					 :TEST #'SUPERTYPEP :FROM-END T))
	   (SETQ ARGS (TRY-SUPERTYPES ARGS))
	   ;; Optimize what remains
	   (DO ((L ARGS (CDR L))) ((NULL L))
	     (SETF (CAR L) (TYPE-EXPAND (CAR L) SUB-TERMINAL-TYPES OPTIMIZE)))
	   ;; Remove OR if only one term remains
	   (IF (REST ARGS) (CONS 'OR ARGS) (FIRST ARGS)))
	  ((REST ARGS) TYPE)
	  (T (FIRST ARGS)))))

(DEFINE-TYPE-PRINTER OR (STREAM &REST TYPES)
  (LOOP FOR LIST ON TYPES
	FOR COUNT FROM 0
	DO (UNLESS (ZEROP COUNT)
	     (PRINC (COND ((CDR LIST) ", ")
			  ((= COUNT 1) " or ")
			  (T ", or "))
		    STREAM))
	   (PRINT-TYPE-DESCRIPTION (CAR LIST) STREAM)))

;;; OR: union, a subtype iff each part is a subtype
;;;	       a supertype if any piece is a supertype, else say don't know.
;;;	         there could be more hair ***
(DEFINE-SUBTYPEP-FUNCTION (OR DEFAULT
			   OR OR)
			  (IGNORE IGNORE (&REST TYPES)
			   TYPE IGNORE IGNORE)
  (LOOP FOR TYPE1 IN TYPES
	WITH SUB-SO-FAR-P = T
	AND DEF-SO-FAR-P = T
	WITH (SUB-P DEF-P)
	DOING (MULTIPLE-VALUE-SETQ (SUB-P DEF-P)
		(SUBTYPEP TYPE1 TYPE))
	WHEN (NOT SUB-P)
	  DO (SETQ SUB-SO-FAR-P NIL)
	     (AND (NOT DEF-P) (SETQ DEF-SO-FAR-P NIL))
	FINALLY (RETURN (VALUES SUB-SO-FAR-P DEF-SO-FAR-P))))

(DEFINE-SUBTYPEP-FUNCTION (* OR)
			  (TYPE IGNORE IGNORE
			   IGNORE IGNORE (&REST TYPES))
  (IF (LOOP FOR TYPE2 IN TYPES
	    THEREIS (SUBTYPEP TYPE TYPE2))
      (VALUES T T)
      (VALUES NIL NIL)))

;;;--- Does not reduce to canonical form first, so won't detect such things
;;; as (equal-typep '(or fixnum integer float) '(or integer float))
;;; nor (equal-typep '(or fixnum integer) 'integer)
(DEFUN (OR EQUAL-TYPEP) (LIST1 LIST2)
  (AND (= (LIST-LENGTH LIST1) (LIST-LENGTH LIST2))
       (LOOP FOR OBJECT IN LIST1
	     ALWAYS (MEMBER OBJECT LIST2 :TEST #'EQUAL-TYPEP))))


(DEFINE-DEFTYPE-PLACEHOLDER AND)

(DEFINE-TYPEP-FUNCTION AND (OBJECT &REST TYPES)
  (LOOP FOR TYPE IN TYPES
	ALWAYS (TYPEP OBJECT TYPE)))

(DEFINE-TYPEP-EXPANDER AND (OBJECT &REST TYPES)
  (ZL:ONCE-ONLY (OBJECT)
    `(AND . ,(LOOP FOR TYPE IN TYPES
		   COLLECT `(TYPEP ,OBJECT ',TYPE)))))

;;; Optimize AND type expressions by removing types that cover other types.
;;; But preserve the order of type tests (see Mary Poppins page 37).
;;; Type expansion happens -after- duplicate removal because type expansion can
;;; produce type expressions, e.g. involving satisfies, that SUBTYPEP can't grok.
(DEFUN (AND TYPE-EXPAND) (TYPE ARGS TERMINAL-TYPES OPTIMIZE SUB-TERMINAL-TYPES)
  TERMINAL-TYPES  ;not used
  (COND (OPTIMIZE
	 ;; Copy arguments and flatten embedded ANDs
	 (SETQ ARGS (MAPCAN #'(LAMBDA (TYPE)
				(MULTIPLE-VALUE-BIND (TYPE TYPE-NAME TYPE-ARGS)
				    (TYPE-EXPAND TYPE (CONS 'AND *STANDARD-TERMINAL-TYPES*))
				  (IF (EQ TYPE-NAME 'AND) (COPY-LIST TYPE-ARGS) (LIST TYPE))))
			    ARGS))
	 ;; Remove covering terms
	 (SETQ ARGS (DELETE-DUPLICATES (DELETE-DUPLICATES ARGS :TEST #'SUPERTYPEP :REPLACE T)
				       :TEST #'SUBTYPEP :FROM-END T))
	 ;; Optimize what remains
	 (DO ((L ARGS (CDR L))) ((NULL L))
	   (SETF (CAR L) (TYPE-EXPAND (CAR L) SUB-TERMINAL-TYPES OPTIMIZE)))
	 ;; Remove AND if only one term remains
	 (COND ((NULL ARGS) 'T)
	       ((REST ARGS) (CONS 'AND ARGS))
	       (T (FIRST ARGS))))
	((NULL ARGS) 'T)
	((REST ARGS) TYPE)
	(T (FIRST ARGS))))

(DEFINE-TYPE-PRINTER AND (STREAM &REST TYPES)
  (LOOP FOR COUNT FROM 0
	UNTIL (NULL TYPES)
	WITH SATISFIES = NIL
	AS TYPE = (POP TYPES)
	DO (UNLESS (ZEROP COUNT)
	     (PRINC (COND (TYPES ", ")
			  ((AND (LISTP TYPE)
				(EQ (CAR TYPE) 'SATISFIES))
			   (SETQ SATISFIES T)
			   (IF (= COUNT 1) " that " ", and that "))
			  ((= COUNT 1) " and ")
			  (T ", and "))
		    STREAM))
	   (COND (SATISFIES
		  (FORMAT STREAM "satisfies the predicate ~S" (CADR TYPE)))
		 ((EQUAL (CAR TYPES) '(NOT NULL))
		  (POP TYPES)
		  (SETQ TYPE (WITH-OUTPUT-TO-STRING (S) (PRINT-TYPE-DESCRIPTION TYPE S)))
		  (COND ((< (LENGTH TYPE) 3))
			((NOT (MISMATCH TYPE "a " :END1 2))
			 (SETQ TYPE (SUBSTRING TYPE 2)))
			((NOT (MISMATCH TYPE "an " :END1 3))
			 (SETQ TYPE (SUBSTRING TYPE 3))))
		  (PRINC "a non-null " STREAM)
		  (PRINC TYPE STREAM))
		 (T
		  (PRINT-TYPE-DESCRIPTION TYPE STREAM)))))

;;; AND: intersection, a supertype iff in each piece
;;;		       a subtype if some piece is a subtype, else say don't know
;;; *** we don't know for example that [-10,5][-5,10][-6,6].  That could be done
;;; by TYPE-EXPAND locally knowing how to merge and what is disjoint, etc.
(DEFINE-SUBTYPEP-FUNCTION (DEFAULT AND
			   AND AND)
			  (TYPE IGNORE IGNORE
			   IGNORE IGNORE (&REST TYPES))
  (LOOP FOR TYPE2 IN TYPES
	WITH SUB-SO-FAR-P = T
	AND DEF-SO-FAR-P = T
	WITH (SUB-P DEF-P)
	DOING (MULTIPLE-VALUE-SETQ (SUB-P DEF-P)
		(SUBTYPEP TYPE TYPE2))
	WHEN (NOT SUB-P)
	  DO (SETQ SUB-SO-FAR-P NIL)
	     (AND (NOT DEF-P) (SETQ DEF-SO-FAR-P NIL))
	FINALLY (RETURN (VALUES SUB-SO-FAR-P DEF-SO-FAR-P))))

(DEFINE-SUBTYPEP-FUNCTION (AND DEFAULT)
			  (IGNORE IGNORE (&REST TYPES)
			   TYPE IGNORE IGNORE)
  (IF (LOOP FOR TYPE1 IN TYPES
	    THEREIS (SUBTYPEP TYPE1 TYPE))
      (VALUES T T)
      (VALUES NIL NIL)))

(DEFUN (AND EQUAL-TYPEP) (LIST1 LIST2)
  (AND (= (LIST-LENGTH LIST1) (LIST-LENGTH LIST2))
       (LOOP FOR OBJECT IN LIST1
	     ALWAYS (MEMBER OBJECT LIST2 :TEST #'EQUAL-TYPEP))))


;;; An extension to standard Common Lisp
;;; Translate from declaration mode to discrimination mode
(DEFTYPE DECLARE (TYPE)
  (SETQ TYPE (TYPE-EXPAND TYPE '(ARRAY COMPLEX)))
  (COND ((ATOM TYPE) TYPE)
	((NULL (CDR TYPE)) TYPE)
	((AND (EQ (FIRST TYPE) 'ARRAY) (NOT (EQ (SECOND TYPE) '*)))
	 `(ARRAY ,(CDR (ASSOC (TYPE-ARRAY-ELEMENT-TYPE (SECOND TYPE)) *ARRAY-ELEMENT-TYPES*))
		 . ,(CDDR TYPE)))
	((AND (EQ (FIRST TYPE) 'COMPLEX) (NOT (EQ (SECOND TYPE) '*)))
	 (MULTIPLE-VALUE-BIND (ELEMENT-TYPE ELEMENT-TYPE-NAME ELEMENT-TYPE-ARGS)
	     (TYPE-EXPAND (SECOND TYPE) '(INTEGER RATIONAL OR))
	   (COND ((MEMBER ELEMENT-TYPE-NAME '(INTEGER RATIONAL))
		  `(OR ,ELEMENT-TYPE ,TYPE))	;The rule of complex canonicalization
		 ((MEMBER ELEMENT-TYPE-NAME '(AND OR))
		  `(,ELEMENT-TYPE-NAME ,@(MAPCAR #'(LAMBDA (TYPE) `(COMPLEX (DECLARE ,TYPE)))
						 ELEMENT-TYPE-ARGS)))
		 (T TYPE))))			;Assumed to be floating
	((MEMBER (FIRST TYPE) '(AND OR NOT))
	 (CONS (FIRST TYPE)
	       (MAPCAR #'(LAMBDA (TYPE) `(DECLARE ,TYPE)) (REST TYPE))))
	(T TYPE)))


(DEFINE-DEFTYPE-PLACEHOLDER T)

(DEFPROP T "anything" TYPENAME)

(DEFINE-TYPEP-FUNCTION T (IGNORE) T)

(DEFINE-TYPEP-EXPANDER T (OBJECT)
  `(PROGN ,OBJECT 'T))

(DEFINE-SUBTYPEP-FUNCTION (* T) (IGNORE IGNORE IGNORE IGNORE IGNORE IGNORE)
  (VALUES T T))

(DEFINE-COERCION T IDENTITY)


(DEFINE-DEFTYPE-PLACEHOLDER NIL)

(DEFPROP NIL "nothing" TYPENAME)

(DEFINE-TYPEP-FUNCTION NIL (IGNORE) NIL)

(DEFINE-TYPEP-EXPANDER NIL (OBJECT)
  `(PROGN ,OBJECT 'NIL))

(DEFINE-SUBTYPEP-FUNCTION (NIL *) (IGNORE IGNORE IGNORE IGNORE IGNORE IGNORE)
  (VALUES T T))


;;; Arrays
;   Some portions of this are in type-infra for bootstrapping reasons

(DEFINE-DEFTYPE-PLACEHOLDER ARRAY)

(DEFINE-TYPEP-FUNCTION ARRAY (OBJECT &OPTIONAL ELEMENT-TYPE DIMENSIONS)
  ;; Error-check a common screwup of, e.g., '(3) instead of (3).  Do this first,
  ;; so a blatently incorrect call isn't papered over if OBJECT wasn't an array anyway.
  (WHEN (LISTP DIMENSIONS)
    (LOOP FOR DIM IN DIMENSIONS
	  UNLESS (OR (EQL DIM '*)
		     (AND (INTEGERP DIM)
			  ( DIM 0)))
	    DO (ERROR "~S isn't a nonnegative integer in the type specifier array dimension ~S"
		      DIM DIMENSIONS)))
  (AND (ARRAYP OBJECT)
       (OR (EQ ELEMENT-TYPE '*)
	   (EQUAL-TYPEP (ARRAY-ELEMENT-TYPE OBJECT) ELEMENT-TYPE))
       (COND ((EQ DIMENSIONS '*))
	     ((INTEGERP DIMENSIONS)
	      (= DIMENSIONS (ARRAY-RANK OBJECT)))
	     ((LISTP DIMENSIONS)
	      (AND (= (LENGTH DIMENSIONS) (ARRAY-RANK OBJECT))
		   (LOOP FOR DIM IN DIMENSIONS
			 FOR I FROM 0
			 ALWAYS (OR (EQ DIM '*)
				    (= DIM (ARRAY-DIMENSION OBJECT I)))))))))

;;; Inline enough to get the trivial case and VECTORP and SIMPLE-VECTOR-P faster.
;;; Actually it's not so difficult to inline everything reasonable.
(DEFINE-TYPEP-EXPANDER ARRAY (OBJECT &OPTIONAL ELEMENT-TYPE DIMENSIONS)
  (BLOCK FAIL					;Return NIL if cannot expand inline
    (LET ((TESTS `((ARRAYP ,OBJECT))))
      (UNLESS (EQ ELEMENT-TYPE '*)
	(LOOP FOR (ART . TYPE) IN *ARRAY-ELEMENT-TYPES*
	      WHEN (EQUAL-TYPEP TYPE ELEMENT-TYPE)
	        COLLECT ART INTO ARTS
	      FINALLY
		(COND ((NULL ARTS)
		       (COMPILER:WARN '(:BAD-STYLE T)
			 "~S is not a recognized array element type in ~S"
			 ELEMENT-TYPE
			 (IF (EQ DIMENSIONS '*)
			     (LIST 'ARRAY ELEMENT-TYPE)
			     (LIST 'ARRAY ELEMENT-TYPE DIMENSIONS)))
		       (RETURN-FROM FAIL NIL))
		      ((NULL (CDR ARTS))
		       (PUSH `(EQ (ARRAY-TYPE ,OBJECT) ',(FIRST ARTS)) TESTS))
		      (T
		       (PUSH `(MEMBER (ARRAY-TYPE ,OBJECT) ',ARTS) TESTS)))))
      (COND ((EQ DIMENSIONS '*))
	    ((NUMBERP DIMENSIONS)
	     (PUSH `(= (ARRAY-RANK ,OBJECT) ,DIMENSIONS) TESTS))
	    ((LISTP DIMENSIONS)
	     (PUSH `(= (ARRAY-RANK ,OBJECT) ,(LENGTH DIMENSIONS)) TESTS)
	     (COND ((LOOP FOR X IN DIMENSIONS ALWAYS (EQ X '*)))
		   ((AND (= (LENGTH DIMENSIONS) 1) (INTEGERP (FIRST DIMENSIONS)))
		    (PUSH `(= (ZL:ARRAY-LENGTH ,OBJECT) ,(FIRST DIMENSIONS)) TESTS))
		   ((LOOP FOR X IN DIMENSIONS ALWAYS (OR (EQ X '*) (INTEGERP X)))
		    (LOOP FOR X IN DIMENSIONS FOR I FROM 0
			  UNLESS (EQ X '*)
			    DO (PUSH `(= (ARRAY-DIMENSION ,OBJECT ,I) ,X) TESTS)))
		   (T (COMPILER:WARN '(:BAD-STYLE T)
			"~S is illegal as a specification of a dimension of an array in ~S.~@
		         An integer or * is required."
			(LOOP FOR X IN DIMENSIONS
			      UNLESS (OR (EQ X '*) (INTEGERP X))
			        RETURN X)
			(LIST 'ARRAY ELEMENT-TYPE DIMENSIONS))
		      (RETURN-FROM FAIL NIL))))
	    (T (COMPILER:WARN '(:BAD-STYLE T)
		 "~S is illegal as a specification of the dimensions of an array in ~S.~@
		  An integer, *, or a list of integers and *'s is required."
		 DIMENSIONS (LIST 'ARRAY ELEMENT-TYPE DIMENSIONS))
	       (RETURN-FROM FAIL NIL)))
      (IF (CDR TESTS) (CONS 'AND (NREVERSE TESTS)) (FIRST TESTS)))))

(DEFINE-TYPE-PRINTER ARRAY (STREAM &OPTIONAL ELEMENT-TYPE DIMENSIONS)
  (PRINT-ARRAY-DIMENSION-SPEC DIMENSIONS "array" STREAM)
  (PRINT-ELEMENT-TYPE-SPEC ELEMENT-TYPE STREAM))

(DEFUN PRINT-ARRAY-DIMENSION-SPEC (DIMENSIONS NAME STREAM)
  (COND ((EQ DIMENSIONS '*)
	 (PRINC (IF (FIND (CHAR NAME 0) "aeiouAEIOU") "an " "a ") STREAM))
	((ATOM DIMENSIONS)
	 (FORMAT STREAM "a ~D-dimensional " (OR DIMENSIONS 0)))
	(T
	 (LOOP FOR DIM IN DIMENSIONS
	       FOR AXIS FROM 0
	       DO (PRINC (COND ((PLUSP AXIS) " x ")
			       ((EQ DIM '*) "an ")
			       (T "a "))
			 STREAM)
		  (IF (EQ DIM '*) (PRINC "N" STREAM) (PRIN1 DIM STREAM))
	       FINALLY (PRINC (IF (ZEROP AXIS) "-long " " ") STREAM))))
  (PRINC NAME STREAM))

(DEFUN PRINT-VECTOR-LENGTH-SPEC (LENGTH ELEMENT NAME STREAM)
  (COND ((EQ LENGTH '*)
	 (PRINC (IF (FIND (CHAR NAME 0) "aeiouAEIOU") "an " "a ") STREAM))
	(T
	 (FORMAT STREAM "a ~D-~A " LENGTH ELEMENT)))
  (PRINC NAME STREAM))

(DEFUN PRINT-ELEMENT-TYPE-SPEC (ELEMENT-TYPE STREAM)
  (UNLESS (EQ ELEMENT-TYPE '*)
    (PRINC " whose typical element is " STREAM)
    (PRINT-TYPE-DESCRIPTION ELEMENT-TYPE STREAM)))

(DEFINE-SUBTYPEP-FUNCTION (ARRAY ARRAY) (IGNORE IGNORE (&OPTIONAL ELEM1 DIM1)
					 IGNORE IGNORE (&OPTIONAL ELEM2 DIM2))
  (LET ((SUB-SO-FAR-P T) (DEF-SO-FAR-P T))
    (COND ((EQ ELEM2 '*))
	  ((EQ ELEM1 '*)
	   (SETQ SUB-SO-FAR-P NIL
		 DEF-SO-FAR-P NIL))
	  (T
	   (MULTIPLE-VALUE-BIND (SUB-P DEF-P)
	       (EQUAL-TYPEP ELEM1 ELEM2)
	     (UNLESS SUB-P
	       (SETQ SUB-SO-FAR-P NIL)
	       (UNLESS DEF-P
		 (SETQ DEF-SO-FAR-P NIL))))))
    (COND ((EQ DIM2 '*))
	  ((EQ DIM1 '*)
	   (SETQ SUB-SO-FAR-P NIL
		 DEF-SO-FAR-P NIL))
	  ((NUMBERP DIM1)
	   (IF (NUMBERP DIM2)
	       (UNLESS (= DIM1 DIM2)
		 (SETQ SUB-SO-FAR-P NIL))
	       (UNLESS (= DIM1 (LENGTH DIM2))
		 (SETQ SUB-SO-FAR-P NIL))))
	  ((NUMBERP DIM2)
	   (UNLESS (= (LENGTH DIM1) DIM2)
	     (SETQ SUB-SO-FAR-P NIL)))
	  (T
	   (IF ( (LENGTH DIM1) (LENGTH DIM2))
	       (SETQ SUB-SO-FAR-P NIL)
	       (LOOP FOR D1 IN DIM1
		     FOR D2 IN DIM2
		     WHEN (COND ((EQ D2 '*) NIL)
				((EQ D1 '*) T)
				(( D1 D2) T)
				(T NIL))
		       DO (SETQ SUB-SO-FAR-P NIL)
			  (LOOP-FINISH)))))
    (VALUES SUB-SO-FAR-P DEF-SO-FAR-P)))


(PROCLAIM '(INLINE SEQUENCEP))
(DEFUN SEQUENCEP (OBJECT)
   (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE) (COMPILER:RETURN-TYPE SCL:BOOLEAN))
   (DECLARE (INLINE VECTORP))
   (OR (LISTP OBJECT)
       (VECTORP OBJECT)))
(PROCLAIM '(NOTINLINE SEQUENCEP))

;;; SEQUENCE:
;;; This &optional type here is fairly bogus; it's different than DW's, and
;;; pretty random as a CL definition anyway.  "Specialize if vector, ignore if
;;; list"?  What good is that?
(DEFINE-TYPE-WITH-FUNCTION SEQUENCE SEQUENCEP (&OPTIONAL TYPE)
  `(OR (VECTOR ,TYPE *) LIST))

(DEFINE-SUBTYPEP-FUNCTION (STRING SEQUENCE)
			  (IGNORE IGNORE IGNORE
			   IGNORE IGNORE IGNORE)
  (VALUES T T))


;;; Numbers

;;; NUMBERP in microcode
(DEFINE-TYPE-WITH-FUNCTION NUMBER NUMBERP (&OPTIONAL LOW-LIMIT HIGH-LIMIT)
  (IF (AND (EQ LOW-LIMIT '*) (EQ HIGH-LIMIT '*))
      '(OR INTEGER RATIO FLOAT COMPLEX)
      `(OR (INTEGER ,LOW-LIMIT ,HIGH-LIMIT)
	   (RATIO ,LOW-LIMIT ,HIGH-LIMIT)
	   (FLOAT ,LOW-LIMIT ,HIGH-LIMIT))))

;;; INTEGER subtypep if integer compare ranges, else default
(DEFMACRO DEFINE-NUMBER-TYPEP-AND-EXPANDER (TYPE PREDICATE &OPTIONAL TYPENAME)
  (SETQ TYPENAME (CANONICALIZE-TYPENAME TYPENAME TYPE))
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',TYPE 'DEFINE-NUMBER-TYPEP-AND-EXPANDER)
     (RECORD-SOURCE-FILE-NAME ',TYPE 'DEFTYPE)
     (ZL:LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,TYPE DEFINE-NUMBER-TYPEP-AND-EXPANDER))
       (DEFINE-TYPEP-FUNCTION ,TYPE (OBJECT &OPTIONAL LOW HIGH)
	 (AND (,PREDICATE OBJECT)
	      (OR (EQ LOW '*)
		  (IF (LISTP LOW) (< (CAR LOW) OBJECT) ( LOW OBJECT)))
	      (OR (EQ HIGH '*)
		  (IF (LISTP HIGH) (> (CAR HIGH) OBJECT) ( HIGH OBJECT)))))
       (DEFINE-TYPEP-EXPANDER ,TYPE (OBJECT &OPTIONAL LOW HIGH)
	 ;; *** could use some compiler help here to save once-only and special casing.
	 ;; Actually, a whole lot of compiler help could make this use the subst expander.
	 (IF (AND (EQ LOW '*) (EQ HIGH '*))
	     `(,',PREDICATE ,OBJECT)
	     (ZL:ONCE-ONLY (OBJECT)
	       `(AND (,',PREDICATE ,OBJECT)
		     ,(OR (EQ LOW '*)
			  (IF (LISTP LOW) `(< ,(CAR LOW) ,OBJECT) `( ,LOW ,OBJECT)))
		     ,(OR (EQ HIGH '*)
			  (IF (LISTP HIGH) `(> ,(CAR HIGH) ,OBJECT) `( ,HIGH ,OBJECT)))))))
       (DEFINE-TYPE-PRINTER ,TYPE (STREAM &OPTIONAL LOW HIGH)
	 (PRINT-NUMBER-TYPE-DESCRIPTION ,TYPENAME STREAM LOW HIGH)))))

(DEFUN PRINT-NUMBER-TYPE-DESCRIPTION (TYPENAME STREAM LOW HIGH &OPTIONAL MODULUS)
  (PRINC TYPENAME STREAM)
  ;; Don't use the word "between" in here because it's too confusing with
  ;; inclusive and exclusive.
  (IF MODULUS
      (FORMAT STREAM " modulo ~S" MODULUS)
    (UNLESS (EQ LOW '*)
      (FORMAT STREAM " greater than ~:[or equal to ~]~S"
	(LISTP LOW) (IF (LISTP LOW) (CAR LOW) LOW)))
    (UNLESS (EQ HIGH '*)
      (FORMAT STREAM "~:[ and~] less than ~:[or equal to ~]~S"
	(EQ LOW '*) (LISTP HIGH) (IF (LISTP HIGH) (CAR HIGH) HIGH)))))

;;;This an is just because of the n.  Fixed in system 94.
(DEFINE-NUMBER-TYPEP-AND-EXPANDER INTEGER INTEGERP "an integer")

(DEFINE-SUBTYPEP-FUNCTION (INTEGER INTEGER
			   RATIO RATIO
			   FLOAT FLOAT)
			  (IGNORE TYPENAME1 (&OPTIONAL LOW1 HIGH1)
			   IGNORE TYPENAME2 (&OPTIONAL LOW2 HIGH2))
  
  ;; An inclusive interval can be equal to an exclusive interval
  ;; because the integers are not a continuum.

  (LABELS ((CANONICALIZE-INTEGER (TYPENAME LOW HIGH)
	     (CASE TYPENAME
	       (INTEGER
		 (TYPECASE LOW
		   (CONS (SETQ LOW
			       (1+ (FIRST LOW)))))
		 (TYPECASE HIGH
		   (CONS (SETQ HIGH 
			       (1- (FIRST HIGH)))))))
	     (VALUES LOW HIGH)))
    (MULTIPLE-VALUE-SETQ (LOW1 HIGH1)
      (CANONICALIZE-INTEGER TYPENAME1 LOW1 HIGH1))
    (MULTIPLE-VALUE-SETQ (LOW2 HIGH2)
      (CANONICALIZE-INTEGER TYPENAME2 LOW2 HIGH2)))
    
  (IF (AND (OR (EQ LOW2 '*)
	       (AND (NEQ LOW1 '*)
		    (FUNCALL (IF (AND (LISTP LOW2) (ATOM LOW1)) #'< #')
			     (IF (LISTP LOW2) (CAR LOW2) LOW2)
			     (IF (LISTP LOW1) (CAR LOW1) LOW1))))
	   (OR (EQ HIGH2 '*)
	       (AND (NEQ HIGH1 '*)
		    (FUNCALL (IF (AND (LISTP HIGH2) (ATOM HIGH1)) #'> #')
			     (IF (LISTP HIGH2) (CAR HIGH2) HIGH2)
			     (IF (LISTP HIGH1) (CAR HIGH1) HIGH1)))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-SUBTYPEP-FUNCTION (INTEGER OR)
			  (INTEGER-TYPE IGNORE (&OPTIONAL LOW HIGH)
			   IGNORE IGNORE (&REST ORS))
  ;; a sleazy hack just to make some error messages look nice
  ;; someday do it right by merging ranges, expanding FIXNUM and BIGNUM
  ;; by (type-expand type '(or integer))
  (IF (OR (MEMBER INTEGER-TYPE ORS :TEST #'SUBTYPEP)
	  (AND (EQ LOW '*)
	       (EQ HIGH '*)
	       (MEMBER 'BIGNUM ORS :TEST #'SUBTYPEP)
	       (MEMBER 'FIXNUM ORS :TEST #'SUBTYPEP)))
      (VALUES T T)
      (VALUES NIL NIL)))

;;; An inclusive interval can be equal to an exclusive interval
;;; because the integers are not a continuum.
(DEFUN (INTEGER EQUAL-TYPEP) (LIST1 LIST2)
  (LET ((LOW1 (FIRST LIST1))
	(HIGH1 (OR (SECOND LIST1) '*))
	(LOW2 (FIRST LIST2))
	(HIGH2 (OR (SECOND LIST2) '*)))
    (AND (OR (EQUAL LOW1 LOW2)
	     (AND (INTEGERP LOW1) (LISTP LOW2) (EQL (1+ (CAR LOW2)) LOW1))
	     (AND (INTEGERP LOW2) (LISTP LOW1) (EQL (1+ (CAR LOW1)) LOW2)))
	 (OR (EQUAL HIGH1 HIGH2)
	     (AND (INTEGERP HIGH1) (LISTP HIGH2) (EQL (1- (CAR HIGH2)) HIGH1))
	     (AND (INTEGERP HIGH2) (LISTP HIGH1) (EQL (1- (CAR HIGH1)) HIGH2))))))

(DEFINE-NUMBER-TYPEP-AND-EXPANDER RATIO SI:RATIONALP)

#+IMACH
(DEFINE-TYPE-WITH-FUNCTION RATIO SI:RATIONALP (&OPTIONAL LOW-LIMIT HIGH-LIMIT)
  `(OR (SMALL-RATIO ,LOW-LIMIT ,HIGH-LIMIT)
       (BIG-RATIO ,LOW-LIMIT ,HIGH-LIMIT)))

#+IMACH
(DEFSUBST SMALL-RATIO-P (RATIO)
  (TYPE-MEMBER RATIO DTP-SMALL-RATIO))

#+IMACH
(DEFINE-NUMBER-TYPEP-AND-EXPANDER SMALL-RATIO SMALL-RATIO-P)

#+IMACH
(DEFSUBST BIG-RATIO-P (RATIO)
  (TYPE-MEMBER RATIO DTP-BIG-RATIO))

#+IMACH
(DEFINE-NUMBER-TYPEP-AND-EXPANDER BIG-RATIO BIG-RATIO-P)

(DEFPROP COMPLEX "a complex number" TYPENAME)

(DEFINE-TYPEP-FUNCTION COMPLEX (OBJECT &OPTIONAL TYPE)
  (CASE TYPE
    ((* T NUMBER REAL)
     (COMPLEXP OBJECT))
    (OTHERWISE
      (AND (COMPLEXP OBJECT)
	   (TYPEP (REALPART OBJECT) TYPE)
	   (TYPEP (IMAGPART OBJECT) TYPE)))))

(DEFINE-TYPEP-EXPANDER COMPLEX (OBJECT &OPTIONAL TYPE)
  (CASE TYPE
    ((* T NUMBER REAL)
     `(COMPLEXP ,OBJECT))
    (OTHERWISE
      (UNLESS (SUBTYPEP TYPE '(OR FLOAT RATIONAL))
	(WARN "~S isn't a subtype of ~S; you can't use it with ~S."
	       TYPE 'REAL 'COMPLEX))
      (LET ((OBJECT-VAR (GENSYMBOL "OBJECT")))
	(LET ((BODY `(AND (COMPLEXP ,OBJECT-VAR)
			  (TYPEP (REALPART ,OBJECT-VAR) ',TYPE)
			  (TYPEP (IMAGPART ,OBJECT-VAR) ',TYPE))))
	  (SETQ BODY
		`(LET ((,OBJECT-VAR ,OBJECT))
		   ,BODY)))))))

(DEFINE-COERCION COMPLEX (OBJECT &OPTIONAL COMPONENT-TYPE)
  (LET ((CANDIDATE (CTYPECASE OBJECT
		     (COMPLEX OBJECT)
		     (NUMBER (COMPLEX OBJECT)))))
    (IF (EQL COMPONENT-TYPE '*)
	CANDIDATE
      (COMPLEX (COERCE (REALPART CANDIDATE) COMPONENT-TYPE)
	       (COERCE (IMAGPART CANDIDATE) COMPONENT-TYPE)))))

(DEFINE-TYPEP-FUNCTION NUMBER (OBJECT &OPTIONAL LOW HIGH)
   (IF (AND (EQ LOW '*) (EQ HIGH '*))
       (NUMBERP OBJECT)
       (AND (SI:REALP OBJECT)
	    (OR (EQ LOW '*)
		(IF (LISTP LOW) (< (CAR LOW) OBJECT) ( LOW OBJECT)))
	    (OR (EQ HIGH '*)
		(IF (LISTP HIGH) (> (CAR HIGH) OBJECT) ( HIGH OBJECT))))))

(DEFINE-TYPEP-EXPANDER NUMBER (OBJECT &OPTIONAL LOW HIGH)
   (IF (AND (EQ LOW '*) (EQ HIGH '*))
       `(NUMBERP ,OBJECT)
       (ONCE-ONLY (OBJECT)
	  `(AND (SI:REALP ,OBJECT)
		,(OR (EQ LOW '*)
		     (IF (LISTP LOW) `(< ,(CAR LOW) ,OBJECT) `( ,LOW ,OBJECT)))
		,(OR (EQ HIGH '*)
		     (IF (LISTP HIGH) `(> ,(CAR HIGH) ,OBJECT) `( ,HIGH ,OBJECT)))))))

;;; Miscellaneous types

(DEFTYPE EXPRESSION () `(DW::PRESENTATION-ONLY-TYPE SYS:EXPRESSION))

(DEFTYPE EQL (OBJECT) `(MEMBER ,OBJECT))

;;; NULL is microcode
(DEFINE-TYPE-WITH-FUNCTION NULL NULL ()
  (DECLARE (TYPENAME "NIL"))
  '(MEMBER NIL))

;;; CONSP in microcode
(DEFTYPE-AS-FUNCTION CONS CONSP)

(DEFTYPE-AS-FUNCTION ATOM ATOM "an atom")

(DEFTYPE-AS-FUNCTION STREAM STREAMP)

(DEFINE-TYPE-WITH-FUNCTION LIST LISTP ()
  '(OR NULL CONS))

(DEFTYPE-AS-FUNCTION SYMBOL SYMBOLP)

(DEFTYPE-AS-FUNCTION KEYWORD KEYWORDP)

(DEFTYPE-AS-FUNCTION FUNCTION FUNCTIONP)

(DEFTYPE-AS-FUNCTION FUTURE-COMMON-LISP:FUNCTION FUTURE-COMMON-LISP:FUNCTIONP)

(DEFINE-COERCION FUTURE-COMMON-LISP:FUNCTION (OBJECT)
  (BLOCK COERCE-TO-FUNCTION
    (TYPECASE OBJECT
      (FUTURE-COMMON-LISP:FUNCTION
	(RETURN-FROM COERCE-TO-FUNCTION
	  OBJECT))
      (SYMBOL
	(LET ((FCN (FUTURE-COMMON-LISP:SYMBOL-FUNCTION OBJECT)))
	  (WHEN (FUTURE-COMMON-LISP:FUNCTIONP FCN)
	    (RETURN-FROM COERCE-TO-FUNCTION
	      FCN))))
      (CONS
	(RETURN-FROM COERCE-TO-FUNCTION
	  (SI:ENCLOSE OBJECT NIL))))
    (ERROR "Only lambda expressions and symbols defined as functions can be coerced to functions.")))

(DEFUN FUTURE-COMMON-LISP:COMPILED-FUNCTION-P (X)
  (AND (FUTURE-COMMON-LISP:FUNCTIONP X)
       (CL:TYPECASE X
	 (SYS:LEXICAL-CLOSURE
	   (NOT (SI:INTERPRETED-FUNCTION-P X)))
	 (SYS:DYNAMIC-CLOSURE
	   (COMPILED-FUNCTION-P (SYS:CLOSURE-FUNCTION X)))
	 (OTHERWISE T))))

(DEFTYPE-AS-FUNCTION FUTURE-COMMON-LISP:COMPILED-FUNCTION
		     FUTURE-COMMON-LISP:COMPILED-FUNCTION-P)

(DEFTYPE-AS-FUNCTION CHARACTER CHARACTERP)

(DEFINE-COERCION CHARACTER CHARACTER)

(DEFTYPE-AS-FUNCTION COMPILED-FUNCTION ZL:SUBRP)

(DEFTYPE-AS-FUNCTION LOCATIVE LOCATIVEP)

#+IMACH
(DEFTYPE-AS-FUNCTION PHYSICAL-ADDRESS SI:PHYSICAL-ADDRESS-P)

(DEFTYPE-AS-FUNCTION UNBOUND-LOGIC-VARIABLE UNBOUND-LOGIC-VARIABLE-P)

(DEFTYPE-AS-FUNCTION DYNAMIC-CLOSURE ZL:CLOSUREP)

(DEFTYPE-AS-FUNCTION LEXICAL-CLOSURE LEXICAL-CLOSURE-P)

(DEFTYPE-AS-FUNCTION GENERIC-FUNCTION GENERIC-FUNCTION-P)

;;; This circular definition is just to drive subtypep.

(DEFUN STRING-CHAR-TYPE-P (CHAR)
  (AND (CHARACTERP CHAR) (STRING-CHAR-P CHAR)))

(DEFINE-TYPE-WITH-FUNCTION STRING-CHAR STRING-CHAR-TYPE-P ()
  (DECLARE (TYPENAME "a string character"))
  '(SATISFIES STRING-CHAR-TYPE-P))

(DEFUN STANDARD-CHAR-TYPE-P (CHAR)
  (AND (CHARACTERP CHAR) (STANDARD-CHAR-P CHAR)))

;;; Doesn't need to test for CHARACTER or STRING-CHAR first because
;;; STANDARD-CHAR-P returns NIL if given a non-character
(DEFINE-TYPE-WITH-FUNCTION STANDARD-CHAR STANDARD-CHAR-TYPE-P ()
  (DECLARE (TYPENAME "a standard character"))
  '(SATISFIES STANDARD-CHAR-TYPE-P))

(DEFINE-SUBTYPEP-FUNCTION (STRING-CHAR CHARACTER
			   STANDARD-CHAR CHARACTER
			   STANDARD-CHAR STRING-CHAR)
			  (IGNORE IGNORE IGNORE
			   IGNORE IGNORE IGNORE)
  (VALUES T T))

(DEFTYPE FUTURE-COMMON-LISP:BASE-CHAR () 'STRING-CHAR)

(DEFTYPE FUTURE-COMMON-LISP:EXTENDED-CHAR ()
  '(AND CHARACTER (NOT FUTURE-COMMON-LISP:BASE-CHAR)))

(COMPILER:DEFINE-SYNONYM-FUNCTION STRUCTUREP SI:NAMED-STRUCTURE-P)


(DEFINE-DEFTYPE-PLACEHOLDER STRUCTURE)

(DEFINE-TYPEP-FUNCTION STRUCTURE (OBJECT &OPTIONAL NAME)
  (AND (STRUCTUREP OBJECT)
       (OR (EQ NAME '*)
	   (TYPEP-STRUCTURE OBJECT NAME))))

(DEFINE-TYPEP-EXPANDER STRUCTURE (OBJECT &OPTIONAL NAME)
  (IF (EQ NAME '*)
      `(STRUCTUREP ,OBJECT)
      `(TYPEP-STRUCTURE ,OBJECT ',NAME)))

(DEFINE-TYPE-PRINTER STRUCTURE (STREAM &OPTIONAL NAME)
  (IF (EQ NAME '*)
      (PRINC "a structure" STREAM)
      (FORMAT STREAM "a structure of type ~S" NAME)))

(DEFINE-SUBTYPEP-FUNCTION (STRUCTURE STRUCTURE)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (OR (NULL ARGS-2)
	  (EQ (FIRST ARGS-2) '*)
	  (AND (LISTP ARGS-1)
	       (NEQ (FIRST ARGS-1) '*)
	       (DO ((SUP (FIRST ARGS-2))
		    (INF (FIRST ARGS-1))
		    D)
		   ((EQ INF SUP) T)
		 (UNLESS (AND (SETQ D (GET INF 'SI:DEFSTRUCT-DESCRIPTION))
			      (SI:DEFSTRUCT-DESCRIPTION-NAMED-P D)
			      (SETQ INF (CAR (SI:DEFSTRUCT-DESCRIPTION-INCLUDE D))))
		   (RETURN NIL)))))
      (VALUES T T)
      (VALUES NIL T)))


(DEFINE-DEFTYPE-PLACEHOLDER INSTANCE)

(DEFINE-TYPEP-FUNCTION INSTANCE (OBJECT &OPTIONAL FLAVOR)
  (AND (SI:INSTANCEP OBJECT)
       (OR (EQ FLAVOR '*)
	   (TYPEP-FLAVOR OBJECT FLAVOR))))

(DEFINE-TYPEP-EXPANDER INSTANCE (OBJECT &OPTIONAL FLAVOR)
  (IF (EQ FLAVOR '*)
      `(SI:INSTANCEP ,OBJECT)
      `(TYPEP-FLAVOR ,OBJECT ',FLAVOR)))

(DEFINE-TYPE-PRINTER INSTANCE (STREAM &OPTIONAL NAME)
  (IF (EQ NAME '*)
      (PRINC "an instance" STREAM)
      (FORMAT STREAM "an instance of type ~S" NAME)))

(DEFINE-SUBTYPEP-FUNCTION (INSTANCE INSTANCE)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (OR (NULL ARGS-2)
	  (EQ (FIRST ARGS-2) '*)
	  (EQUAL ARGS-1 ARGS-2)
	  (AND (CONSP ARGS-1)
	       (NEQ (FIRST ARGS-1) '*)
	       (MEMBER (FIRST ARGS-2) (FLAVOR:GET-ALL-FLAVOR-COMPONENTS (FIRST ARGS-1)))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-DEFTYPE-PLACEHOLDER CLOS-INTERNALS:MEMBER-OF-CLASS)
(DEFINE-DEFTYPE-PLACEHOLDER CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED)

(DEFINE-TYPEP-FUNCTION CLOS-INTERNALS:MEMBER-OF-CLASS
		       (OBJECT &OPTIONAL CLASS)
  (OR (EQ CLASS '*)
      (CLOS-INTERNALS:TYPEP-CLASS OBJECT CLASS)))

(DEFINE-TYPEP-FUNCTION CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED
		       (OBJECT &OPTIONAL CLASS-NAME)
  (OR (EQ CLASS-NAME '*)
      (CLOS-INTERNALS:TYPEP-CLASS OBJECT (CLOS:FIND-CLASS CLASS-NAME))))

(DEFINE-TYPEP-EXPANDER CLOS-INTERNALS:MEMBER-OF-CLASS (OBJECT &OPTIONAL CLASS)
  (IF (EQ CLASS '*)
      T
      `(CLOS-INTERNALS:TYPEP-CLASS ,OBJECT ',CLASS)))

(DEFINE-TYPEP-EXPANDER CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED (OBJECT &OPTIONAL CLASS-NAME)
  (IF (EQ CLASS-NAME '*)
      T
      `(CLOS-INTERNALS:TYPEP-CLASS ,OBJECT (CLOS:FIND-CLASS ',CLASS-NAME))))

(DEFINE-TYPE-PRINTER CLOS-INTERNALS:MEMBER-OF-CLASS (STREAM &OPTIONAL CLASS)
  (IF (EQ CLASS '*)
      (PRINC "any object" STREAM)
      (FORMAT STREAM "a member of class ~S" (CLOS-INTERNALS:CLASS-NAME-FOR-TYPE-OF CLASS))))

(DEFINE-TYPE-PRINTER CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED (STREAM &OPTIONAL CLASS-NAME)
  (IF (EQ CLASS-NAME '*)
      (PRINC "any object" STREAM)
      (FORMAT STREAM "a member of the class named ~A" CLASS-NAME)))

(DEFINE-SUBTYPEP-FUNCTION CLOS-INTERNALS:(MEMBER-OF-CLASS MEMBER-OF-CLASS
					  MEMBER-OF-CLASS FUNCALLABLE-INSTANCE
					  FUNCALLABLE-INSTANCE MEMBER-OF-CLASS
					  FUNCALLABLE-INSTANCE FUNCALLABLE-INSTANCE)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (OR (NULL ARGS-2)
	  (EQ (FIRST ARGS-2) '*)
	  (EQUAL ARGS-1 ARGS-2)
	  (AND (CONSP ARGS-1)
	       (NEQ (FIRST ARGS-1) '*)
	       (MEMBER (FIRST ARGS-2)
		       (CLOS:CLASS-PRECEDENCE-LIST (FIRST ARGS-1)))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-SUBTYPEP-FUNCTION (CLOS-INTERNALS:MEMBER-OF-CLASS FUNCTION)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE IGNORE)
  (IF (AND (CONSP ARGS-1)
	   (NEQ (FIRST ARGS-1) '*)
	   (MEMBER (CLOS:FIND-CLASS 'FUNCTION NIL)
		   (CLOS:CLASS-PRECEDENCE-LIST (FIRST ARGS-1))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-SUBTYPEP-FUNCTION CLOS-INTERNALS::(MEMBER-OF-CLASS-NAMED MEMBER-OF-CLASS-NAMED
					   MEMBER-OF-CLASS-NAMED FUNCALLABLE-INSTANCE
					   FUNCALLABLE-INSTANCE MEMBER-OF-CLASS-NAMED
					   FUNCALLABLE-INSTANCE FUNCALLABLE-INSTANCE)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (OR (NULL ARGS-2)
	  (EQ (FIRST ARGS-2) '*)
	  (EQUAL ARGS-1 ARGS-2)
	  (AND (CONSP ARGS-1)
	       (NEQ (FIRST ARGS-1) '*)
	       (MEMBER (CLOS:FIND-CLASS (FIRST ARGS-2))
		       (CLOS:CLASS-PRECEDENCE-LIST (CLOS:FIND-CLASS (FIRST ARGS-1))))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-SUBTYPEP-FUNCTION CLOS-INTERNALS::(MEMBER-OF-CLASS-NAMED MEMBER-OF-CLASS)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (OR (NULL ARGS-2)
	  (EQ (FIRST ARGS-2) '*)
	  (EQUAL ARGS-1 ARGS-2)
	  (AND (CONSP ARGS-1)
	       (NEQ (FIRST ARGS-1) '*)
	       (MEMBER (FIRST ARGS-2)
		       (CLOS:CLASS-PRECEDENCE-LIST (CLOS:FIND-CLASS (FIRST ARGS-1))))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-SUBTYPEP-FUNCTION CLOS-INTERNALS::(MEMBER-OF-CLASS MEMBER-OF-CLASS-NAMED)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE ARGS-2)
  (IF (OR (NULL ARGS-2)
	  (EQ (FIRST ARGS-2) '*)
	  (EQUAL ARGS-1 ARGS-2)
	  (AND (CONSP ARGS-1)
	       (NEQ (FIRST ARGS-1) '*)
	       (MEMBER (CLOS:FIND-CLASS (FIRST ARGS-2))
		       (CLOS:CLASS-PRECEDENCE-LIST (FIRST ARGS-1)))))
      (VALUES T T)
      (VALUES NIL T)))

(DEFINE-SUBTYPEP-FUNCTION (CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED FUNCTION)
			  (IGNORE IGNORE ARGS-1 IGNORE IGNORE IGNORE)
  (IF (AND (CONSP ARGS-1)
	   (NEQ (FIRST ARGS-1) '*)
	   (MEMBER (CLOS:FIND-CLASS 'FUNCTION NIL)
		   (CLOS:CLASS-PRECEDENCE-LIST (CLOS:FIND-CLASS (FIRST ARGS-1)))))
      (VALUES T T)
      (VALUES NIL T)))


;;; Don't do this -- it's officially defined by CLOS.
;(DEFINE-DEFTYPE-PLACEHOLDER CLOS-INTERNALS:FUNCALLABLE-INSTANCE)

(DEFINE-TYPEP-FUNCTION CLOS-INTERNALS:FUNCALLABLE-INSTANCE (OBJECT &OPTIONAL CLASS)
  (AND (FUNCALLABLE-INSTANCE-P OBJECT)
       (OR (EQ CLASS '*)
	   (CLOS-INTERNALS:TYPEP-CLASS OBJECT CLASS))))

(DEFINE-TYPEP-EXPANDER CLOS-INTERNALS:FUNCALLABLE-INSTANCE (OBJECT &OPTIONAL CLASS)
  (IF (EQ CLASS '*)
      `(FUNCALLABLE-INSTANCE-P ,OBJECT)
      `(CLOS-INTERNALS:TYPEP-CLASS ,OBJECT ',CLASS)))

(DEFINE-TYPE-PRINTER CLOS-INTERNALS:FUNCALLABLE-INSTANCE (STREAM &OPTIONAL CLASS)
  (IF (EQ CLASS '*)
      (PRINC "a funcallable instance")
      (FORMAT STREAM "a funcallable instance member of class ~s"
	      (CLOS-INTERNALS:CLASS-NAME-FOR-TYPE-OF CLASS))))

(DEFUN CLOS-INTERNALS:DEFINED-GENERIC-FUNCTION-NAME-P (NAME)
  (AND (SYS:VALIDATE-FUNCTION-SPEC NAME)
       (FDEFINEDP NAME)
       (CLOS-INTERNALS::GENERIC-FUNCTION-P
	 (FDEFINITION (SI:UNENCAPSULATE-FUNCTION-SPEC NAME)))))

(DEFTYPE CLOS-INTERNALS:GENERIC-FUNCTION-NAME (&KEY DEFINED)
  `(AND (OR (AND SYMBOL (NOT NULL)) LIST)
        (SATISFIES ,(IF (AND DEFINED (NEQ DEFINED '*))
                        `CLOS-INTERNALS:DEFINED-GENERIC-FUNCTION-NAME-P
                        `CLOS-INTERNALS:GENERIC-FUNCTION-NAME-VALID-P))))

(DEFINE-TYPE-PRINTER CLOS-INTERNALS:GENERIC-FUNCTION-NAME (STREAM &key defined)
  (PRINT-TYPE-DESCRIPTION
    (IF DEFINED
	`(AND (OR (AND SYMBOL (NOT NULL))
		  (AND LIST (SATISFIES
			      CLOS-INTERNALS:GENERIC-FUNCTION-NAME-VALID-P)))
	      (SATISFIES DEFINED-GENERIC-FUNCTION-P))
	`(OR (AND SYMBOL (NOT NULL))
	     (AND LIST (SATISFIES CLOS-INTERNALS:GENERIC-FUNCTION-NAME))))
    STREAM))

(DEFINE-SUBTYPEP-FUNCTION (FUTURE-COMMON-LISP:FUNCTION FUNCTION
			   FUTURE-COMMON-LISP:COMPILED-FUNCTION FUTURE-COMMON-LISP:FUNCTION
			   LEXICAL-CLOSURE FUTURE-COMMON-LISP:FUNCTION
			   DYNAMIC-CLOSURE FUTURE-COMMON-LISP:FUNCTION
			   COMPILED-FUNCTION FUTURE-COMMON-LISP:COMPILED-FUNCTION
			   CLOS-INTERNALS:FUNCALLABLE-INSTANCE FUTURE-COMMON-LISP:COMPILED-FUNCTION)
			  (IGNORE IGNORE IGNORE IGNORE IGNORE IGNORE)
  (VALUES T T))

(DEFSUBST COMPILED-FUNCTION-PC-P (PC)
  (OR (= (%DATA-TYPE PC) DTP-ODD-PC)
      (= (%DATA-TYPE PC) DTP-EVEN-PC)))

(DEFTYPE-AS-FUNCTION COMPILED-FUNCTION-PC COMPILED-FUNCTION-PC-P)

(DEFINE-SUBTYPEP-FUNCTION
  (
   FUTURE-COMMON-LISP:BROADCAST-STREAM FUTURE-COMMON-LISP:STREAM
   FUTURE-COMMON-LISP:CONCATENATED-STREAM FUTURE-COMMON-LISP:STREAM
   FUTURE-COMMON-LISP:ECHO-STREAM FUTURE-COMMON-LISP:STREAM
   FUTURE-COMMON-LISP:FILE-STREAM FUTURE-COMMON-LISP:STREAM
   FUTURE-COMMON-LISP:STRING-STREAM FUTURE-COMMON-LISP:STREAM
   FUTURE-COMMON-LISP:SYNONYM-STREAM FUTURE-COMMON-LISP:STREAM
   FUTURE-COMMON-LISP:TWO-WAY-STREAM FUTURE-COMMON-LISP:STREAM
   )
  (IGNORE IGNORE IGNORE IGNORE IGNORE IGNORE)
  (VALUES T T))

(ZL:COMMENT
()
;;;; Random test cases
(TYPEP "foo" 'STRING)
(TYPEP 1 'RATIONAL)
(TYPEP 1 '(INTEGER 3 5))
(TYPEP 1 '(INTEGER 0 5))
(TYPEP "foo" 'ARRAY)
(TYPEP "foo" '(ARRAY INTEGER))
(TYPEP "foo" '(ARRAY * (* *)))

(SUBTYPEP 'INTEGER 'NUMBER)
(SUBTYPEP 'BIT '(INTEGER -10 10))

;; *** Here's one where we say don't know.  This could be fixed by having SUBTYPEP able to
;; say entirely disjoint rather than just not a subset.
;; [Or, "Fixed in DW types".  This is one of the ways that type-walking is better than
;;  type expansion.  --RWK]
(SUBTYPEP 'BIT '(RATIONAL -4 -3))

(SUBTYPEP 'FIXNUM 'INTEGER)
(SUBTYPEP 'BIGNUM '(INTEGER 0 100))
(SUBTYPEP 'CONS 'LIST)

(SUBTYPEP 'VECTOR 'ARRAY)
(SUBTYPEP 'STRING 'VECTOR)
(SUBTYPEP 'BIT-VECTOR '(ARRAY RATIONAL))

(SUBTYPEP 'RATIO 'RATIONAL)

(SUBTYPEP 'NULL 'SYMBOL)
(SUBTYPEP 'BIT-VECTOR '(ARRAY RATIO))	;*** doesn't know
(SUBTYPEP 'NULL 'SEQUENCE)
(SUBTYPEP 'LIST 'SEQUENCE)
(SUBTYPEP 'ARRAY 'SEQUENCE)

(SUBTYPEP 'INTEGER 'COMMON)
(SUBTYPEP 'PATHNAME 'COMMON)
;; Could be NIL T??
(SUBTYPEP 'INSTANCE 'COMMON)

)
