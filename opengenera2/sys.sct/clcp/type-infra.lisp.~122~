;;; -*- Mode: LISP; Package: Common-lisp-internals; Syntax:Common-Lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFPROP TYPENAME T SI:DEBUG-INFO)

;;; Infrastructure of Common Lisp type system

;;; These are the primitive types in common lisp.  A compatible program can use
;;; TYPE-EXPAND to reduce a type expression to these.
;;; Non primitive types are given a DEFTYPE property for expanding.
;;; This list should include everything in Table 4-1 of the Common Lisp Manual,
;;; plus the five primitive type-expression symbols in the last line.
(DEFPARAMETER *STANDARD-TERMINAL-TYPES*
  '(T NIL NULL ATOM CONS LIST ARRAY SIMPLE-ARRAY SEQUENCE VECTOR SIMPLE-VECTOR
    BIT-VECTOR SIMPLE-BIT-VECTOR STRING SIMPLE-STRING CHARACTER STRING-CHAR STANDARD-CHAR
    NUMBER INTEGER FIXNUM BIGNUM BIT RATIONAL RATIO COMPLEX
    FLOAT SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT FUTURE-COMMON-LISP:REAL
    SYMBOL KEYWORD FUNCTION COMPILED-FUNCTION LEXICAL-CLOSURE DYNAMIC-CLOSURE
    PATHNAME PACKAGE STREAM HASH-TABLE RANDOM-STATE READTABLE COMMON
    FUTURE-COMMON-LISP:FUNCTION FUTURE-COMMON-LISP:COMPILED-FUNCTION
    NOT OR AND MEMBER SATISFIES))

;;; These are the primitive types for the TYPEP function and the compiler TYPEP expander.
;;; Each symbol must have a TYPEP property for run-time testing and a TYPEP-EXPANDER property
;;; for compile-time expansion.
(DEFPARAMETER *TYPEP-TERMINAL-TYPES*
  '(SATISFIES
    MEMBER DATA-TYPE ARRAY
    NUMBER RATIONAL RATIO INTEGER FLOAT FUTURE-COMMON-LISP:REAL
    STRUCTURE INSTANCE NOT OR AND
    T NIL))

;;; Same as the above, but for the maximally inline case.  I.e. SATISFIES is at the end.
(DEFPARAMETER *MAXIMALLY-INLINE-TYPEP-TERMINAL-TYPES*
  '(MEMBER DATA-TYPE ARRAY
    NUMBER RATIONAL RATIO INTEGER FLOAT FUTURE-COMMON-LISP:REAL
    STRUCTURE INSTANCE NOT OR AND
    SATISFIES
    T NIL))

;;; These are the primitive types for SUBTYPEP.  Each symbol can have a SUBTYPEP function
;;; for complicated subtype checking.
;;; The specialized subtypes of FLOAT are here so we'll know they're subtypes of FLOAT
(DEFPARAMETER *SUBTYPEP-TERMINAL-TYPES*
	      '(
		LEXICAL-CLOSURE DYNAMIC-CLOSURE FUNCTION
		MEMBER ARRAY INTEGER SINGLE-FLOAT DOUBLE-FLOAT
		SYMBOL CONS RATIO STANDARD-CHAR STRING-CHAR CHARACTER STRUCTURE INSTANCE
		FUTURE-COMMON-LISP:BROADCAST-STREAM
		FUTURE-COMMON-LISP:CONCATENATED-STREAM
		FUTURE-COMMON-LISP:ECHO-STREAM
		FUTURE-COMMON-LISP:FILE-STREAM
		FUTURE-COMMON-LISP:STREAM
		FUTURE-COMMON-LISP:STRING-STREAM
		FUTURE-COMMON-LISP:SYNONYM-STREAM
		FUTURE-COMMON-LISP:TWO-WAY-STREAM
		NIL T NOT OR AND SATISFIES))

;;; These are the primitive types for EQUAL-TYPEP.  Each symbol can have
;;; an EQUAL-TYPEP property that is used to compare two lists whose first
;;; elements are both that symbol and whose remaining elements are not equal.
(DEFPARAMETER *EQUAL-TYPEP-TERMINAL-TYPES*
  '(MEMBER ARRAY INTEGER FLOAT SINGLE-FLOAT DOUBLE-FLOAT
    SYMBOL CONS RATIO CHARACTER STRING-CHAR STRUCTURE INSTANCE
    NIL T NOT OR AND SATISFIES))

;;; The primitive types for COERCE are defined dynamically; see DEFINE-COERCION

;;; Special form for defining types
(DEFMACRO DEFTYPE (NAME LAMBDA-LIST &BODY BODY)
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
      (SI:FIND-BODY-DECLARATIONS BODY NIL LAMBDA-LIST)
    (LET ((PRETTY-NAME (CANONICALIZE-TYPENAME
			 (BLOCK PRETTY-NAME
			   (LOOP FOR DECL IN DECLARATIONS
				 WHEN (AND (LISTP DECL)
					   (EQ (FIRST DECL) 'DECLARE))
				   DO (LOOP FOR ENTRY IN (REST DECL)
					    WHEN (AND (LISTP ENTRY)
						      (EQ (FIRST ENTRY) 'TYPENAME))
					      DO (RETURN-FROM PRETTY-NAME (SECOND ENTRY)))))
			 NAME))
	  (DOCUMENTATION (FIND-IF #'STRINGP DECLARATIONS))
	  (TYPE-LAMBDA-LIST (FIXUP-DEFTYPE-LAMBDA-LIST LAMBDA-LIST))
	  (PRESENTATION-ONLY-KLUDGE (AND (CONSP (FIRST (LAST BODY)))
						 (EQ (CAR (FIRST (LAST BODY))) 'QUOTE)
						 (CONSP (SECOND (FIRST (LAST BODY))))
						 (EQ (CAR (SECOND (FIRST (LAST BODY))))
						     'DW::PRESENTATION-ONLY-TYPE))))
      `(MULTIPLE-DEFINITION ,NAME DEFTYPE
	 (START-DEFTYPE-DEFINITION ',NAME
				   ,@(WHEN DOCUMENTATION
				       `(:DOCUMENTATION ,DOCUMENTATION))
				   :ARGLIST ',TYPE-LAMBDA-LIST
				   :PRETTY-NAME ',PRETTY-NAME
				   :RECORD-SOURCE-FILE-NAME NIL	;done by MULTIPLE-DEFINITION
				   ,@(WHEN PRESENTATION-ONLY-KLUDGE
				       `(:PRESENTATION-ONLY-KLUDGE T)))
	 (DEFUN (:PROPERTY ,NAME DEFTYPE) ,TYPE-LAMBDA-LIST
	   ,@DECLARATIONS
	   ,@REAL-BODY)
	 (EVAL-WHEN (COMPILE)
	   (COMPILER:FILE-DECLARE ',NAME 'DEFTYPE
				  #'(LAMBDA ,TYPE-LAMBDA-LIST ,@DECLARATIONS ,@REAL-BODY)))
	 (FINISH-DEFTYPE-DEFINITION ',NAME
				    ,@(WHEN PRESENTATION-ONLY-KLUDGE
					`(:PRESENTATION-ONLY-KLUDGE T)))))))

(DEFPROP DEFTYPE "Type" SI:DEFINITION-TYPE-NAME)

;; Use this when you define a type by hand, and want other people to get
;; redefinition warnings if they try to redefine the type
(DEFMACRO DEFINE-DEFTYPE-PLACEHOLDER (NAME)
  `(RECORD-SOURCE-FILE-NAME ',NAME 'DEFTYPE))

;;; Retrieve the type lambda list.  This also might serve to test if a type is defined,
;;; once all of the type definitions in the world are recompiled to pick up lambda list
;;; properties.  

(DEFUN SYS:TYPE-ARGLIST (TYPE)
  (DECLARE (VALUES ARGLIST NIL-IF-NOT-A-TYPE))
  (CHECK-TYPE TYPE SYMBOL "a primitive type symbol")
  (LET ((ARGLIST (GET TYPE 'TYPE-LAMBDA-LIST '.NOT-A-LIKELY-LAMBDA-LIST)))
    (IF (EQ ARGLIST '.NOT-A-LIKELY-LAMBDA-LIST)
	NIL
	(VALUES ARGLIST T))))

(DEFUN CANONICALIZE-TYPENAME (PRETTY-NAME NAME)
  (WHEN (NULL PRETTY-NAME)
    (SETQ PRETTY-NAME (LET ((STRING (STRING-DOWNCASE (SUBSTITUTE #\SP #\- (STRING NAME)))))
			(STRING-APPEND (IF (AND (PLUSP (STRING-LENGTH STRING))
						(STRING-SEARCH-CHAR (AREF STRING 0)
								    "aeiou"))
					   "an " "a ")
				       STRING))))
  PRETTY-NAME)

(DEFUN FIXUP-DEFTYPE-LAMBDA-LIST (LAMBDA-LIST)
  (LOOP FOR X IN LAMBDA-LIST
	WITH OPT-P = NIL
	WHEN (MEMBER X LAMBDA-LIST-KEYWORDS)
	  DO (CASE X
	       ((&OPTIONAL &KEY) (SETQ OPT-P T))
	       ((&REST &AUX) (SETQ OPT-P NIL))
	       (OTHERWISE (ERROR "~S not permitted in DEFTYPE lambda-list" X)))
	ELSE WHEN (AND OPT-P (SYMBOLP X))
	DO (SETQ X `(,X '*))
	COLLECT X))

;;; Special cases of DEFTYPE

;;; Define a type in terms of a predicate already defined (in microcode or whatever).
(DEFMACRO DEFTYPE-AS-FUNCTION (TYPE FUNCTION &OPTIONAL TYPENAME)
  `(DEFTYPE ,TYPE ()
     (DECLARE (TYPENAME ,TYPENAME))
     ;; Make these part of the presentation hierarchy.
     '(SATISFIES ,FUNCTION)))

;;; Define a type in terms of subtypes and associate a predicate with it, 
;;; Define a type in terms of subtypes and associate a predicate with it, 
(DEFMACRO DEFINE-TYPE-WITH-FUNCTION (TYPE FUNCTION LAMBDA-LIST &BODY TYPE-DEFINITION)
  (UNLESS (OR (NULL LAMBDA-LIST)
	      (MEMBER (CAR LAMBDA-LIST) '(&OPTIONAL &REST)))
    (ERROR "~S is not a suitable lambda-list since there are required arguments"
	    LAMBDA-LIST))
  (UNLESS (AND (MEMBER (LENGTH (MEMBER '&REST LAMBDA-LIST)) '(0 2))
	       (LOOP FOR X IN LAMBDA-LIST
		     ALWAYS (OR (MEMBER X '(&OPTIONAL &REST))
				(NOT (MEMBER X LAMBDA-LIST-KEYWORDS)))))
    (ERROR "~S is not a lambda-list I can understand" LAMBDA-LIST))
  (LET ((TYPENAME NIL)
	(NO-ARGS-TEST (LOOP FOR X IN LAMBDA-LIST
			    UNLESS (SYMBOLP X)
			      DO (ERROR "~S is too complicated in the lambda-list" X)
			    WHEN (EQ X '&REST)
			      COLLECT `(NULL ,(CAR (LAST LAMBDA-LIST)))
			      AND DO (LOOP-FINISH)
			    UNLESS (EQ X '&OPTIONAL)
			      COLLECT `(EQ ,X '*))))
    (WHEN (AND (LISTP (CAR TYPE-DEFINITION))
	       (EQ (CAR (CAR TYPE-DEFINITION)) 'DECLARE)
	       (EQ (CAR (CADR (CAR TYPE-DEFINITION))) 'TYPENAME))
      (SETQ TYPENAME (CADR (CADR (CAR TYPE-DEFINITION)))
	    TYPE-DEFINITION (CDR TYPE-DEFINITION)))
    (UNLESS (= (LENGTH TYPE-DEFINITION) 1)
      (ERROR "Too many subforms in ~S" TYPE-DEFINITION))
    (SETQ TYPE-DEFINITION (CAR TYPE-DEFINITION))
    (LET ((SATISFIES (IF NO-ARGS-TEST
			 `(AND ,@NO-ARGS-TEST
			       `((SATISFIES ,',FUNCTION)))
			 ``((SATISFIES ,',FUNCTION)))))
      `(DEFTYPE ,TYPE ,LAMBDA-LIST
	 (DECLARE (TYPENAME ,TYPENAME))
	 ,(IF (EQ (CAR TYPE-DEFINITION) 'QUOTE)
	      (IF (EQ (CAR SATISFIES) 'QUOTE)	      
		  ;; Make sure constant structure is not built at run time
		  `'(EQUIVALENT
		      ,@(CADR SATISFIES)
		      ,@(IF (AND (LISTP (CADR TYPE-DEFINITION))
				 (EQ (CAR (CADR TYPE-DEFINITION)) 'EQUIVALENT))
			    (CDR (CADR TYPE-DEFINITION))
			    (CDR TYPE-DEFINITION)))
		  ;; Merge nested use of EQUIVALENT
		  ``(EQUIVALENT
		      ,@,SATISFIES
		      ,@',(IF (AND (LISTP (CADR TYPE-DEFINITION))
				   (EQ (CAR (CADR TYPE-DEFINITION)) 'EQUIVALENT))
			      (CDR (CADR TYPE-DEFINITION))
			      (CDR TYPE-DEFINITION))))
	      ;; General case -- but maybe we can still optimize the common
	      ;; case of no parameters to avoid consing the constant result
	      (LET ((VARS (SET-DIFFERENCE LAMBDA-LIST LAMBDA-LIST-KEYWORDS))
		    (VALS (LOOP FOR X IN LAMBDA-LIST WITH REST = NIL
				WHEN (EQ X '&REST) DO (SETQ REST T)
				ELSE UNLESS (EQ X '&OPTIONAL)
				       COLLECT (IF REST ''NIL ''*))))
		(MULTIPLE-VALUE-BIND (NO-ARGS-CODE ARGS-CODE)
		    ;; Kludge for NUMBER type, pull out the clauses of its IF
		    (IF (AND NO-ARGS-TEST
			     (LISTP TYPE-DEFINITION)
			     (EQ (FIRST TYPE-DEFINITION) 'IF)
			     (LISTP (SECOND TYPE-DEFINITION))
			     (EQ (FIRST (SECOND TYPE-DEFINITION)) 'AND)
			     (LOOP FOR COND IN (CDR (SECOND TYPE-DEFINITION))
				   ALWAYS (EQUAL (COMPILER:OPTIMIZE-TOP-LEVEL-FORM
						   (LET-SUBST VARS VALS COND)
						   :DO-CONSTANT-FOLDING T
						   :DO-INLINE-FORMS T
						   :DO-MACRO-EXPANSION T
						   :DO-FUNCTION-ARGS T)
						 ''T)))
			(VALUES (THIRD TYPE-DEFINITION) (FOURTH TYPE-DEFINITION))
			(VALUES TYPE-DEFINITION TYPE-DEFINITION))
		  ;; Now build a specialized version of NO-ARGS-CODE with the constant
		  ;; defaults for the arguments plugged in
		  (SETQ NO-ARGS-CODE
			(COMPILER:OPTIMIZE-CONSTANT-LISTS
			  ``(EQUIVALENT (SATISFIES ,',FUNCTION)
					,,(LET-SUBST VARS VALS NO-ARGS-CODE))))
		  (IF (AND NO-ARGS-TEST (LISTP NO-ARGS-CODE) (EQ (CAR NO-ARGS-CODE) 'QUOTE))
		      `(IF ,(IF (CDR NO-ARGS-TEST) `(AND ,@NO-ARGS-TEST) (CAR NO-ARGS-TEST))
			   ,NO-ARGS-CODE
			   ,ARGS-CODE)
		      ;; Truly general case
		      ``(EQUIVALENT
			  ,@,SATISFIES
			  ,,TYPE-DEFINITION)))))))))

(DEFPROP DEFINE-TYPE-WITH-FUNCTION DEFTYPE ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;;; Like above, but function also compiled as the maximally inline version of the subtypes.
(DEFMACRO DEFINE-TYPE-PREDICATE (FUNCTION TYPE LAMBDA-LIST &BODY TYPE-DEFINITION)
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',FUNCTION 'DEFINE-TYPE-PREDICATE)
     (DEFINE-TYPE-WITH-FUNCTION ,TYPE ,FUNCTION ,LAMBDA-LIST ,@TYPE-DEFINITION)
     (PROCLAIM '(INLINE ,FUNCTION))
     (DEFUN ,FUNCTION (OBJECT)
       (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
       (DECLARE (SYS:FUNCTION-PARENT ,FUNCTION DEFINE-TYPE-PREDICATE))
       ,(INLINE-TYPE-PREDICATE-INTERNAL FUNCTION 'OBJECT TYPE))
     (PROCLAIM '(NOTINLINE ,FUNCTION))
     ))

;It's a DEFUN, not a DEFTYPE, because the name of the type isn't the second subform
(DEFPROP DEFINE-TYPE-PREDICATE DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;;; Supporting functions for TYPEP and SUBTYPEP

;;; For defining TYPEP and SUBTYPEP functions: just changes the lambda-list.
(DEFMACRO DEFINE-TYPEP-FUNCTION (NAME LAMBDA-LIST &BODY BODY)
  (LET ((.TYPE-LAMBDA-LIST. (FIXUP-DEFTYPE-LAMBDA-LIST LAMBDA-LIST)))
    `(PROGN
       (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-TYPEP-FUNCTION)
       (DEFUN (:PROPERTY ,NAME TYPEP) , .TYPE-LAMBDA-LIST.
	 (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-TYPEP-FUNCTION))
	 ,@BODY)
       (DEFPROP ,NAME ,(CDR .TYPE-LAMBDA-LIST.) TYPE-LAMBDA-LIST) ; remove OBJECT
       )))

(DEFMACRO DEFINE-TYPEP-EXPANDER (NAME LAMBDA-LIST &BODY BODY)
  (LET ((LAMBDA-LIST (FIXUP-DEFTYPE-LAMBDA-LIST LAMBDA-LIST)))
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-TYPEP-EXPANDER)
     (DEFUN (:PROPERTY ,NAME TYPEP-EXPANDER) ,LAMBDA-LIST
       (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-TYPEP-EXPANDER))
       ,@BODY)
     (EVAL-WHEN (COMPILE)
       (COMPILER:FILE-DECLARE ',NAME 'TYPEP-EXPANDER
			      #'(LAMBDA ,LAMBDA-LIST ,@BODY)))
     )))

(DEFMACRO DEFINE-TYPE-PRINTER (NAME LAMBDA-LIST &BODY BODY)
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-TYPE-PRINTER)
     (DEFUN (:PROPERTY ,NAME TYPE-PRINTER) ,(FIXUP-DEFTYPE-LAMBDA-LIST LAMBDA-LIST)
       (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-TYPE-PRINTER))
       . ,BODY)))

(DEFMACRO DEFINE-TYPEP-FUNCTION-AND-SUBST-EXPANDER (NAME LAMBDA-LIST DEFINITION)
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-TYPEP-FUNCTION-AND-SUBST-EXPANDER)
     (ZL:LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,NAME DEFINE-TYPEP-FUNCTION-AND-SUBST-EXPANDER))
       (DEFINE-TYPEP-FUNCTION ,NAME ,LAMBDA-LIST ,DEFINITION)
       (DEFINE-TYPEP-EXPANDER ,NAME (&REST ARGS)
	 (SUBST-TYPEP-EXPANDER ARGS ',LAMBDA-LIST ',DEFINITION)))))

(DEFUN SUBST-TYPEP-EXPANDER (ARGS LAMBDA-LIST DEFINITION)
  (LOOP FOR LARG IN LAMBDA-LIST
	FOR FIRST-P FIRST T THEN NIL
	WITH SUBSTS = NIL
	WITH REMAINING-ARGS = ARGS
	WITH REST-P
	WHEN (EQ LARG '&REST)
	  DO (SETQ REST-P T)
	ELSE WHEN (NEQ LARG '&OPTIONAL)
	  DO (PUSH (CONS LARG
			 (LET ((TEM (COND (REST-P (COPY-LIST REMAINING-ARGS))
					  (REMAINING-ARGS (POP REMAINING-ARGS) )
					  (T '*))))
			   (IF FIRST-P TEM `',TEM)))
		   SUBSTS)
	FINALLY (WHEN (EQ (CAR DEFINITION) 'SI:DISPLACED)	;***!
		  (SETQ DEFINITION (CADR DEFINITION)))
		(SETQ DEFINITION (SUBLIS SUBSTS DEFINITION))
		;; Optimize IF that always branches the same way
		(WHEN (AND (EQ (CAR DEFINITION) 'IF)
			   (EQ (CAADR DEFINITION) 'EQ)
			   (LISTP (SECOND (SECOND DEFINITION)))
			   (EQ (CAR (SECOND (SECOND DEFINITION))) 'QUOTE)
			   (LISTP (THIRD (SECOND DEFINITION)))
			   (EQ (CAR (THIRD (SECOND DEFINITION))) 'QUOTE))
		  (SETQ DEFINITION (IF (EQ (SECOND (SECOND (SECOND DEFINITION)))
					   (SECOND (THIRD (SECOND DEFINITION))))
				       (THIRD DEFINITION)
				       (FOURTH DEFINITION))))
		;; Optimize FUNCALL of a quoted symbol (the compiler says isn't supposed to)
		;; so that built-in type predicates will be recognized.  For SATISFIES.
		(WHEN (AND (MEMBER (CAR DEFINITION) '(FUNCALL APPLY))
			   (LISTP (CADR DEFINITION))
			   (EQ (CAADR DEFINITION) 'QUOTE)
			   (SYMBOLP (CADADR DEFINITION)))
		      (SETQ DEFINITION (SUBST `#',(SECOND (SECOND DEFINITION)) (SECOND DEFINITION) DEFINITION)))
		(RETURN DEFINITION)))

(DEFVAR *SUBTYPEP-FUNCTION-HASH-TABLE*)

(DEFUN ADD-SUBTYPEP-FUNCTION (FUNCTION TYPE-PAIRS)
  (UNLESS (VARIABLE-BOUNDP *SUBTYPEP-FUNCTION-HASH-TABLE*)
    (SETQ *SUBTYPEP-FUNCTION-HASH-TABLE* (MAKE-HASH-TABLE :TEST #'EQUAL
							  :AREA PERMANENT-STORAGE-AREA)))
  (LOOP FOR (TYPE1 TYPE2) ON TYPE-PAIRS BY 'CDDR
	DO (SEND *SUBTYPEP-FUNCTION-HASH-TABLE*
		 :PUT-HASH (LIST-IN-AREA PERMANENT-STORAGE-AREA
					 (COPY-TREE TYPE1 PERMANENT-STORAGE-AREA)
					 (COPY-TREE TYPE2 PERMANENT-STORAGE-AREA))
			   FUNCTION)))

(DEFPROP DEFINE-SUBTYPEP-FUNCTION "SUBTYPEP Function" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-SUBTYPEP-FUNCTION (TYPE-PAIRS (TYPE1 TYPE-NAME-1 TYPE-ARGS-1
						TYPE2 TYPE-NAME-2 TYPE-ARGS-2)
				    &BODY BODY)
  (SETQ BODY (IF (SYMBOLP TYPE-ARGS-1)
		 `((LET ((,TYPE-ARGS-1 .TYPE-ARGS-1.))
		     . ,BODY))
		 `((DESTRUCTURING-BIND
		     ,(FIXUP-DEFTYPE-LAMBDA-LIST TYPE-ARGS-1) .TYPE-ARGS-1.
		     . ,BODY))))
  (SETQ BODY (IF (SYMBOLP TYPE-ARGS-2)
		 `((LET ((,TYPE-ARGS-2 .TYPE-ARGS-2.))
		     . ,BODY))
		 `((DESTRUCTURING-BIND
		     ,(FIXUP-DEFTYPE-LAMBDA-LIST TYPE-ARGS-2) .TYPE-ARGS-2.
		     . ,BODY))))
  (LET ((NAME (INTERN (FORMAT NIL "~A-~A-SUBTYPEP-FUNCTION"
			      (FIRST TYPE-PAIRS) (SECOND TYPE-PAIRS)))))
    `(PROGN
       (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-SUBTYPEP-FUNCTION)
       (DEFUN ,NAME (,TYPE1 ,TYPE-NAME-1 .TYPE-ARGS-1.
		     ,TYPE2 ,TYPE-NAME-2 .TYPE-ARGS-2.)
	 (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-SUBTYPEP-FUNCTION))
	 . ,BODY)
       (ADD-SUBTYPEP-FUNCTION ',NAME ',(COPY-LIST TYPE-PAIRS)))))

(DEFUN (:PROPERTY DEFINE-SUBTYPEP-FUNCTION ZWEI:DEFINITION-FUNCTION-SPEC-PARSER) (BP)
  (LET ((AFTER-LIST-BP (ZWEI:FORWARD-SEXP BP)))
    (WHEN AFTER-LIST-BP
      (LET ((FSPEC-STRING (ZWEI:STRING-INTERVAL BP AFTER-LIST-BP)))
	(MULTIPLE-VALUE-BIND (LIST ERROR-P)
	    (ZWEI:READ-FSPEC-ITEM-FROM-STRING FSPEC-STRING)
	  (IF (OR ERROR-P (SYMBOLP LIST))
	      (VALUES NIL NIL NIL T)
	      (VALUES (INTERN (FORMAT NIL "~A-~A-SUBTYPEP-FUNCTION"
				      (FIRST LIST) (SECOND LIST)))
		      'DEFINE-SUBTYPEP-FUNCTION
		      FSPEC-STRING
		      NIL)))))))


;;; Functions: TYPEP, SUBTYPEP, SUPERTYPEP, EQUAL-TYPEP

(DEFUN TYPE-NAME-P (TYPE-NAME &OPTIONAL ENV)
  (OR (GET-PROPERTIES (SYMBOL-PLIST TYPE-NAME)
		      '(TYPEP DEFTYPE TYPE-EXPAND FLAVOR:FLAVOR
			      SI:DEFSTRUCT-DESCRIPTION SI:NAMED-STRUCTURE-INVOKE))
      (AND (CLOS-INTERNALS:COMPILE-FILE-ENVIRONMENT-P ENV)
	   (OR (COMPILER:FILE-DECLARATION TYPE-NAME 'DEFTYPE)
	       (COMPILER:FILE-DECLARATION TYPE-NAME 'FLAVOR:FLAVOR)))
      (CLOS:FIND-CLASS TYPE-NAME NIL ENV)))

(DEFUN TYPEP (OBJECT TYPE)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (TYPEP-INTERNAL OBJECT TYPE 'TYPEP))

(DEFUN TYPEP-INTERNAL (OBJECT TYPE PROPERTY-NAME
		       &OPTIONAL (TERMINAL-TYPES *TYPEP-TERMINAL-TYPES*) OPTIMIZE
		       (SUB-TERMINAL-TYPES TERMINAL-TYPES))
  (MULTIPLE-VALUE-BIND (NIL TYPE-NAME ARGS)
      (TYPE-EXPAND TYPE TERMINAL-TYPES OPTIMIZE SUB-TERMINAL-TYPES)
    (APPLY (OR (AND (EQ PROPERTY-NAME 'TYPEP-EXPANDER)
		    (COMPILER:FILE-DECLARATION TYPE-NAME PROPERTY-NAME))
	       (GET TYPE-NAME PROPERTY-NAME)
	       (ERROR "~S is not a known type." TYPE))
	   OBJECT ARGS)))

(DEFUN INSTANCE-CLASS-P (INSTANCE)
  (WHEN (INSTANCEP INSTANCE)
    (LET ((CLASS-CLASS (CLOS:FIND-CLASS 'CLOS-INTERNALS:CLASS NIL)))
      (WHEN CLASS-CLASS
	(CLOS-INTERNALS:TYPEP-CLASS INSTANCE CLASS-CLASS)))))

;;; Expand type expression into more primitive types
(DEFUN TYPE-EXPAND (TYPE &OPTIONAL (TERMINAL-TYPES *STANDARD-TERMINAL-TYPES*) OPTIMIZE
				   (SUB-TERMINAL-TYPES TERMINAL-TYPES))
  (DECLARE (VALUES TYPE TYPE-NAME ARGS))
  (DECLARE (NOTINLINE CLOS:FIND-CLASS))
  (LOOP
    (MULTIPLE-VALUE-BIND (TYPE-NAME ARGS)
	(TYPECASE TYPE
	  (LIST (VALUES (FIRST TYPE) (REST TYPE)))
	  (SYMBOL (VALUES TYPE NIL))
	  ((SATISFIES INSTANCE-CLASS-P)
	   (IF (OR (CLOS-INTERNALS::TYPEP-CLASS TYPE (CLOS:FIND-CLASS 'CLOS-INTERNALS::FLAVOR-CLASS))
		   (CLOS-INTERNALS::TYPEP-CLASS TYPE (CLOS:FIND-CLASS 'CLOS:BUILT-IN-CLASS)))
	       (VALUES (CLOS:CLASS-NAME TYPE) NIL)
	       (VALUES 'CLOS-INTERNALS:MEMBER-OF-CLASS (LIST TYPE))))
	  (OTHERWISE
	    (ERROR "~S is illegal as a type expression; type names must be symbols or classes"
		   TYPE)))
      (LET ((FUNCTION (GET TYPE-NAME 'TYPE-EXPAND)))
	(WHEN (OR (NULL FUNCTION)
		  (EQUAL TYPE (SETQ TYPE (FUNCALL FUNCTION TYPE ARGS TERMINAL-TYPES
						  OPTIMIZE SUB-TERMINAL-TYPES))))
	  (COND ((MEMBER TYPE-NAME TERMINAL-TYPES)
		 (RETURN (VALUES TYPE TYPE-NAME ARGS)))
		;;
		((SETQ FUNCTION (COMPILER:FILE-DECLARATION TYPE-NAME 'DEFTYPE))
		 (SETQ TYPE (APPLY FUNCTION ARGS)))
		((COMPILER:FILE-DECLARATION TYPE-NAME 'FLAVOR:FLAVOR)
		 (SETQ TYPE `(INSTANCE ,TYPE-NAME)))
		((CLOS:FIND-CLASS TYPE-NAME NIL 'FUTURE-COMMON-LISP:COMPILE-FILE)
		 (SETQ TYPE `(CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED ,TYPE-NAME)))
		;;
		((SETQ FUNCTION (GET TYPE-NAME 'DEFTYPE))
		 (SETQ TYPE (APPLY FUNCTION ARGS)))
		((GET TYPE-NAME 'TYPEP)
		 (RETURN (VALUES TYPE TYPE-NAME ARGS)))
		((GET TYPE-NAME 'FLAVOR:FLAVOR)
		 (SETQ TYPE `(INSTANCE ,TYPE-NAME)))
		((CLOS:FIND-CLASS TYPE-NAME NIL)
		 (SETQ TYPE `(CLOS-INTERNALS::MEMBER-OF-CLASS-NAMED ,TYPE-NAME)))
		((OR (GET TYPE-NAME 'ZL:SI:DEFSTRUCT-DESCRIPTION)
		     (GET TYPE-NAME 'ZL:NAMED-STRUCTURE-INVOKE))
		 (SETQ TYPE `(STRUCTURE ,TYPE-NAME)))		
		(T (ERROR "~S is not a known type." TYPE-NAME))))))))

(DEFINE-DEFTYPE-PLACEHOLDER EQUIVALENT)

(DEFUN (EQUIVALENT TYPE-EXPAND) (TYPE ARGS TERMINAL-TYPES OPTIMIZE SUB-TERMINAL-TYPES)
  TYPE OPTIMIZE SUB-TERMINAL-TYPES  ;ignored
  (BLOCK TOP
    (DOLIST (PREFER TERMINAL-TYPES (FIRST ARGS))
      (DOLIST (TYPE ARGS)
	(WHEN (EQ (IF (LISTP TYPE) (FIRST TYPE) TYPE) PREFER)
	  (RETURN-FROM TOP TYPE))))))

(COMPILER:ADD-OPTIMIZER TYPEP TYPEP-OPTIMIZER)

(DEFUN TYPEP-OPTIMIZER (FORM)
  (COMPILER:MATCHP FORM
    (('TYPEP VALUE TYPE)
     (WHEN (COMPILER:CONSTANT-FORM-P TYPE)
       (LET ((TYPE (COMPILER:CONSTANT-EVALUATOR TYPE)))
	 (RETURN-FROM TYPEP-OPTIMIZER
	   (TYPEP-INTERNAL VALUE TYPE 'TYPEP-EXPANDER *TYPEP-TERMINAL-TYPES* T))))))
  FORM)

(DEFUN INLINE-TYPE-PREDICATE-INTERNAL (FUNCTION OBJECT TYPE)
  (LET ((NEW (TYPEP-INTERNAL OBJECT TYPE 'TYPEP-EXPANDER
			      *MAXIMALLY-INLINE-TYPEP-TERMINAL-TYPES*
			      T *STANDARD-TERMINAL-TYPES*)))
    (WHEN (AND NEW (LISTP NEW) (EQ (FIRST NEW) FUNCTION))
      (ERROR "The type ~S expanded into ~S." TYPE NEW))
    (OR NEW
	`(TYPEP ,OBJECT
		',(TYPE-EXPAND TYPE *MAXIMALLY-INLINE-TYPEP-TERMINAL-TYPES*
			       T *STANDARD-TERMINAL-TYPES*)))))

;;; SUBTYPEP is moved to TYPE-SUPRA3 so that it doesn't get loaded before it can be used.

(DEFUN LOOKUP-SUBTYPEP-FUNCTION (&REST KEY)
  (DECLARE (ARGLIST TYPE1 TYPE2))
  (SEND *SUBTYPEP-FUNCTION-HASH-TABLE* :GET-HASH KEY))

(DEFUN SUPERTYPEP (TYPE1 TYPE2)
  (SUBTYPEP TYPE2 TYPE1))

(DEFUN EQUAL-TYPEP (TYPE1 TYPE2)
  (WHEN (EQUAL TYPE1 TYPE2)
    (RETURN-FROM EQUAL-TYPEP T))
  (SETQ TYPE1 (TYPE-EXPAND TYPE1 *EQUAL-TYPEP-TERMINAL-TYPES*))
  (SETQ TYPE2 (TYPE-EXPAND TYPE2 *EQUAL-TYPEP-TERMINAL-TYPES*))
  (OR (EQUAL TYPE1 TYPE2)
      (AND (LISTP TYPE1) (LISTP TYPE2)
	   (EQ (CAR TYPE1) (CAR TYPE2))
	   (LET ((HANDLER (GET (CAR TYPE1) 'EQUAL-TYPEP)))
	     (AND HANDLER
		  (FUNCALL HANDLER (CDR TYPE1) (CDR TYPE2)))))))

;;; This is used by the debugger to print a english description of type descriptor
(DEFUN PRINT-TYPE-DESCRIPTION (TYPE STREAM)
  (LET ((TYPE-SYMBOL TYPE)
	(TYPE-ARGS NIL))
    (WHEN (LISTP TYPE)
      (SETF `(,TYPE-SYMBOL . ,TYPE-ARGS) TYPE))
    (LET ((FUNCTION (GET TYPE-SYMBOL 'TYPE-PRINTER)))
      (WHEN FUNCTION
	(RETURN-FROM PRINT-TYPE-DESCRIPTION
	  (APPLY FUNCTION STREAM TYPE-ARGS))))
    (WHEN (NULL TYPE-ARGS)
      (LET ((TYPENAME (GET TYPE-SYMBOL 'TYPENAME)))
	(WHEN TYPENAME
	  (RETURN-FROM PRINT-TYPE-DESCRIPTION
	    (PRINC TYPENAME STREAM)))))
    (PRIN1 TYPE STREAM)))

;;; Support for COERCE

;;; In one form you specify the name of a function, in the other you
;;; specify the arguments and body of the function
(DEFMACRO DEFINE-COERCION (TO-TYPE . REST)
  (DECLARE (ARGLIST TO-TYPE (OBJECT . TYPE-ARGS) &BODY BODY))
  (IF (CDR REST)
      (DESTRUCTURING-BIND ((OBJECT . TYPE-ARGS) &BODY BODY) REST
	(LET ((NAME (INTERN (FORMAT NIL "COERCE-TO-~A" TO-TYPE))))
	  `(PROGN 'COMPILE
		  (RECORD-SOURCE-FILE-NAME ',TO-TYPE 'DEFINE-COERCION)
		  (DEFUN ,NAME (,OBJECT . ,(FIXUP-DEFTYPE-LAMBDA-LIST TYPE-ARGS))
		    (DECLARE (FUNCTION-PARENT ,TO-TYPE DEFINE-COERCION))
		    . ,BODY)
		  (ADD-COERCION ',NAME ',TO-TYPE))))
      `(ADD-COERCION ',(CAR REST) ',TO-TYPE)))

(DEFVAR *COERCION-FUNCTION-HASH-TABLE*)

(DEFVAR *COERCION-TERMINAL-TYPES* NIL)

(DEFUN ADD-COERCION (FUNCTION TO-TYPE)
  (UNLESS (VARIABLE-BOUNDP *COERCION-FUNCTION-HASH-TABLE*)
    (SETQ *COERCION-FUNCTION-HASH-TABLE* (MAKE-HASH-TABLE :TEST #'EQUAL
							  :AREA PERMANENT-STORAGE-AREA)))
  (PUSHNEW (IF (LISTP TO-TYPE) (CAR TO-TYPE) TO-TYPE) *COERCION-TERMINAL-TYPES*)  
  (SEND *COERCION-FUNCTION-HASH-TABLE* :PUT-HASH (COPY-TREE TO-TYPE PERMANENT-STORAGE-AREA)
						 FUNCTION))

(DEFUN LOOKUP-COERCION (TO-TYPE)
  (MULTIPLE-VALUE-BIND (IGNORE TYPE-NAME TYPE-ARGS)
      (TYPE-EXPAND TO-TYPE *COERCION-TERMINAL-TYPES*)
    (LET ((FUNCTION (SEND *COERCION-FUNCTION-HASH-TABLE* :GET-HASH TYPE-NAME)))
      (AND FUNCTION
	   (LET ((ARGS (ARGS-INFO FUNCTION)))
	     ( (LDB SYS:%%ARG-DESC-MIN-ARGS ARGS)
		(1+ (LIST-LENGTH TYPE-ARGS))
		(LDB SYS:%%ARG-DESC-MAX-ARGS ARGS)))
	   (VALUES FUNCTION TYPE-ARGS)))))

(DEFUN COERCE (OBJECT RESULT-TYPE)
  (DECLARE (SIDE-EFFECTS SIMPLE REDUCIBLE))
  (MULTIPLE-VALUE-BIND (FUNCTION ARGS)
      (LOOKUP-COERCION RESULT-TYPE)  
    (COND (FUNCTION
	   (APPLY FUNCTION OBJECT ARGS))
	  ((TYPEP OBJECT RESULT-TYPE)
	   OBJECT)
	  (T (SIGNAL-PROCEED-CASE ((RESULT) 'COERCE-UNKNOWN-TYPE
				   :OBJECT OBJECT :TO-TYPE RESULT-TYPE)
	       (:NEW-VALUE RESULT))))))

(COMPILER:ADD-OPTIMIZER COERCE COERCE-OPTIMIZER)

(DEFUN COERCE-OPTIMIZER (FORM)
  (COMPILER:MATCHP FORM
    (('COERCE VALUE TYPE)
     (WHEN (COMPILER:CONSTANT-FORM-P TYPE)
       (LET ((TO-TYPE (COMPILER:CONSTANT-EVALUATOR TYPE)))
	 (MULTIPLE-VALUE-BIND (FUNCTION ARGS)
	     (LOOKUP-COERCION TO-TYPE)
	   (WHEN FUNCTION
	     (RETURN-FROM COERCE-OPTIMIZER
	       `(,FUNCTION ,VALUE ,@(MAPCAR #'(LAMBDA (X) `(QUOTE ,X)) ARGS)))))))))
  FORM)
