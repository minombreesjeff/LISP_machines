;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Package: FCLI; Lowercase: Yes; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun ansi-function-nyi (form)
  (compiler:warn '(:bad-style t) "~S is not yet implemented." (first form)))

(setf (get 'ignore 'si:declaration-alias) 'lisp:ignore)

;;;

;;; ANSI says that these must be macros.

(defmacro prog1 (value &rest forms)
  `(lisp:prog1 ,value ,@forms))

(defmacro prog2 (form value &rest forms)
  `(lisp:prog2 ,form ,value ,@forms))

(defmacro step (form)
  `(si:step-apply #'(lambda () ,form) nil))

(defmacro with-compilation-unit ((&key override) &body forms)
  `(compiler:compiler-context-bind (:inherit-existing-environment (not ,override))
     ,@forms))

(defmacro define-setf-expander (access-function lambda-list &body body)
  `(lisp:define-setf-method ,access-function ,lambda-list ,@body))

(defmacro declaim (&rest decl-specs)
  `(progn
     ,@(mapcar #'(lambda (spec)
		   `(progn
		      (eval-when (compile)
			(lt::process-proclaim ',spec t))
		      (proclaim ',spec)))
	       decl-specs)))

(defmacro function (fspec)
  (declare (compiler:do-not-record-macroexpansions))
  (etypecase fspec
    (symbol)
    (cons
      (ecase (car fspec)
	((setf lambda)))))
  `(lisp:function ,fspec))

(defmacro if (test if-true &optional if-false)
  `(lisp:if ,test ,if-true ,if-false))

(defmacro push (item place &environment env)
  (lt::expand-push-2 item place 'cons nil env))

(defmacro pushnew (item place &rest keys &key test test-not key &environment env)
  (declare (ignore test test-not key))
  (lt::expand-push-2 item place 'adjoin keys env))

(defmacro time (form)
  `(lisp:time ,form))

(defmacro with-output-to-string ((stream &optional string &key (element-type ''character))
				 &body body
				 &environment env)
  (cli::with-output-to-string-expander stream string body env :element-type element-type))

(defmacro with-open-file ((stream filename &rest options) &body body)
  `(with-open-stream (,stream (open ,filename ,@options)) ,@body))

;;;

(compiler:add-style-checker 'ansi-function-nyi 'pprint-logical-block 'ansi-function-nyi)
(defmacro pprint-logical-block
	  ((stream-symbol list &rest keys
			  &key (prefix "" prefix-p) (per-line-prefix "" plp-p) (suffix ""))
	   &body body)
  (declare (ignore prefix per-line-prefix suffix))
  (check-type stream-symbol symbol)
  (when (and prefix-p plp-p)
    (warn "Only one of ~S and ~S may be used in a ~S form." :prefix :per-line-prefix
	  'pprint-logical-block))
  (case stream-symbol
    ((nil)
     (setf stream-symbol '*standard-output*))
    ((t)
     (setf stream-symbol '*terminal-io*)))
  `(pprint-logical-block-1
     (macrolet ((pprint-exit-if-list-exhausted ()
		  `(funcall #1=#:exit-if-list-exhausted))
		(pprint-pop ()
		  `(funcall #2=#:pop)))
       #'(lambda (,stream-symbol #1# #2#)
	   (declare (ignorable #1# #2#))
	   ,@body))
     ,stream-symbol ,list ,@keys))

(defmacro pprint-exit-if-list-exhausted ()
  (error "~S must be used within ~S." 'pprint-exit-if-list-exhausted 'pprint-logical-block))

(defmacro pprint-pop ()
  (error "~S must be used within ~S." 'pprint-pop 'pprint-logical-block))

(defmacro formatter (control-string)
  (check-type control-string string)
  `(formatter-1 ,control-string))

(defun formatter-1 (control-string)
  #'(lambda (stream &rest args)
      (declare (dynamic-extent args))
      (let ((format:*common-lisp-format* t))
	(apply #'format:format-internal stream control-string args))))



;; Not all streams are STREAMP, so specially check for them.
(defun pathname-stream-p (x)
  (or (streamp x)
      (and (scl:instancep x) (scl:operation-handled-p x :pathname))))

(defun pathname (x)
  (declare (inline pathnamep))
  (ctypecase x
    (pathname x)
    (string
     (values (fs:parse-pathname x nil *default-pathname-defaults*)))
    ((satisfies pathname-stream-p)
     (funcall x :pathname))))

(defun truename (x)
  (ctypecase x
    ((or pathname string)
     (scl:send (open (pathname x) :direction :probe :if-does-not-exist :error) :truename))
    ((satisfies pathname-stream-p)
     (funcall x :truename))))

(defun parse-namestring (thing &optional host (defaults *default-pathname-defaults*)
			 &key (start 0) end junk-allowed)
  (declare (inline pathnamep))
  (ctypecase host
    (null)
    (string
     (setq host (fs:get-pathname-host host)))
    ((scl:instance net:host)))  
  (ctypecase thing
    (string
      (unless end
	(setq end (length thing)))
      (unless (and (zerop start) (= end (length thing)))
	(setq thing (subseq thing start end)))
      (when junk-allowed
	(cerror "Proceed assuming no junk is present"
		"Sorry, :junk-allowed argument to parse-namestring is not implemented"))
      (values (fs:parse-pathname thing host (pathname defaults)) end))
    (pathname
      (values thing start))
    ((satisfies pathname-stream-p)
      (values (funcall thing :pathname) start))))

;; Same as ZL version except that a stream is acceptable as the pathname argument
(defun merge-pathnames (pathname &optional (defaults *default-pathname-defaults*)
			(default-version :newest))
  (setq defaults (pathname defaults))
  (fs:merge-pathnames (parse-namestring pathname nil defaults) defaults default-version))

(defun convert-from-ansi-directory (value)
  (etypecase value
    ((member nil :wild :unspecific) value)
    (cons
      (when (member :up value)
	(error ":UP is not supported."))
      (setf value (substitute :up :back value))
      (ecase (car value)
	(:absolute (or (cdr value) :root))
	(:relative value)))
    (string (list value))))

(defun convert-to-ansi-directory (value)
  (etypecase value
    ((member nil :unspecific) value)
    ((member :root) '(:absolute))
    (cons
      (if (eq (car value) :relative)
	  (substitute :back :up value)
	  (cons :absolute value)))))

(defun make-pathname (&rest keywords &key host device directory name type version defaults (case :local))
  (declare (ignore host device directory name type version))
  (declare (dynamic-extent keywords))
  (apply #'scl:send
	 (if defaults
	     (pathname defaults)
	     (scl:send (fs:default-pathname *default-pathname-defaults* nil nil nil t)
		       :new-pathname :device nil :directory nil :name nil :type nil :version nil))
	 :new-pathname
	 (loop for (key value) on keywords by #'cddr
	       if (or (eq key :host) (eq key :version))
		 collect key and collect value
	       else
		 if (eq key :device)
		   collect (if (eq case :local) :raw-device :device) and collect value
	       else
		 if (eq key :directory)
		   collect (if (eq case :local) :raw-directory :directory)
		   and collect (convert-from-ansi-directory value)
	       else
		 if (eq key :name)
		   collect (if (eq case :local) :raw-name :name) and collect value
	       else
		 if (eq key :type)
		   collect (if (eq case :local) :raw-type :type) and collect value
								       )))

(defun pathname-host (pathname &key (case :local))
  (declare (ignore case))
  (scl:send (pathname pathname) :host))

(defun pathname-device (pathname &key (case :local))
  (scl:send (pathname pathname) (ecase case (:local :raw-device) (:common :device))))

(defun pathname-directory (pathname &key (case :local))
  (convert-to-ansi-directory
    (scl:send (pathname pathname) (ecase case (:local :raw-directory) (:common :directory)))))

(defun pathname-name (pathname &key (case :local))
  (scl:send (pathname pathname) (ecase case (:local :raw-name) (:common :name))))

(defun pathname-type (pathname &key (case :local))
  (scl:send (pathname pathname) (ecase case (:local :raw-type) (:common :type))))

(defun pathname-version (pathname)
  (scl:send (pathname pathname) :version))

(defun namestring (pathname)
  (string (scl:send (pathname pathname) :string-for-printing)))

(defun file-namestring (pathname)
  (string (scl:send (pathname pathname) :string-for-dired)))
  
(defun directory-namestring (pathname)
  (string (scl:send (pathname pathname) :string-for-directory)))

(defun host-namestring (pathname)
  (string (scl:send (scl:send (pathname pathname) :host) :name-as-file-computer)))

(defun enough-namestring (pathname &optional (defaults *default-pathname-defaults*))
  (setq pathname (pathname pathname)
	defaults (pathname defaults))
  (let ((host (scl:send pathname :host))
	(device (scl:send pathname :device))
	(directory (scl:send pathname :directory))
	(name (scl:send pathname :name))
	(type (scl:send pathname :type))
	(version (scl:send pathname :version))
	(same-host t))
    (unless (eq host (scl:send defaults :host))
      (setq defaults (fs:default-pathname defaults host)
	    same-host nil))
    (let ((same-device (equal (scl:send defaults :device) device))
	  (same-directory (equal (scl:send defaults :directory) directory))
	  (same-name (equal (scl:send defaults :name) name))
	  (same-type (equal (scl:send defaults :type) type))
	  (same-version (equal (scl:send defaults :version) version)))
      (let ((string (string (scl:send (scl:send pathname :new-pathname
						:device (if same-device nil device)
						:directory (if same-directory nil directory)
						:name (if same-name nil name)
						:type (if (and same-version same-type) nil type)
						:version (if same-version nil version))
				      :string-for-printing))))
	(if same-host
	    (subseq string (1+ (position #\: string)))
	    string)))))

(defun wild-pathname-p (pathname &optional field-key)
  (scl:send (pathname pathname) (ecase field-key
				  ((nil) :wild-p)
				  ((:host) :host-wild-p)
				  ((:device) :device-wild-p)
				  ((:directory) :directory-wild-p)
				  ((:name) :name-wild-p)
				  ((:type) :type-wild-p)
				  ((:version) :version-wild-p))))

(defun wild-pathname (x)
  (setf x (pathname x))
  (when (null (pathname-device x))
    (setf x (make-pathname :device :wild :defaults x)))
  (when (null (pathname-directory x))
    (setf x (make-pathname :directory :wild :defaults x)))
  (when (null (pathname-name x))
    (setf x (make-pathname :name :wild :defaults x)))
  (when (null (pathname-type x))
    (setf x (make-pathname :type :wild :defaults x)))
  (when (null (pathname-version x))
    (setf x (make-pathname :version :wild :defaults x)))
  x)

(defun pathname-match-p (pathname wildname)
  (not (null (scl:send (wild-pathname wildname) :pathname-match (pathname pathname)))))

(defun translate-pathname (source from-wildname to-wildname)
  (scl:send (wild-pathname from-wildname) :translate-wild-pathname (wild-pathname to-wildname)
								   (pathname source)))

(defun logical-pathname (x)
  (let ((pathname (pathname x)))
    (check-type pathname logical-pathname)
    pathname))

(defun translate-logical-pathname (logical-pathname &key)
  (scl:send (pathname logical-pathname) :translated-pathname))

(defun logical-pathname-translations (host)
  (scl:send (fs:get-logical-pathname-host host) :translations))

(defun (setf logical-pathname-translations) (translations host)
  (fs:set-logical-pathname-host host :translations translations)
  translations)

(defun load-logical-pathname-translations (host)
  (declare (values just-loaded))
  (cond ((fs:get-logical-pathname-host host t) nil)
	(t (fs:make-logical-pathname-host host) t)))



(declaim (inline symbol-function))
(defun symbol-function (symbol)
  (lisp:symbol-function symbol))

(defun (setf symbol-function) (value symbol)
  (check-type value function)
  (setf (lisp:symbol-function symbol) value))

(defun function-lambda-expression (fcn)
  (check-type fcn function)
  (if (si:interpreted-function-p fcn)
      (si:interpreted-function-lambda-expression fcn)
      (let ((name (sys:function-name fcn))
	    (lambda-exp (second (assoc :interpreted-definition (sys:debugging-info fcn)))))
	(if lambda-exp
	    (values lambda-exp (sys:lexical-closure-p fcn) name)
	    (values nil t name)))))

(defun gensym (&optional arg)
  (multiple-value-bind (prefix suffix)
      (ctypecase arg
	(null    (values "G" (shiftf *gensym-counter* (1+ *gensym-counter*))))
	(integer (values "G" arg))
	(string  (values arg (shiftf *gensym-counter* (1+ *gensym-counter*)))))
    (make-symbol (cli::generate-symbol-name prefix suffix))))

(defun array-displacement (array)
  (if (si:array-displaced-p array)
      (values (si:array-indirect-to array) (si:array-index-offset array))
      (values nil 0)))

(defun compile-file (input-file &key output-file (verbose *compile-verbose*)
		     (print *compile-print*) (external-format :default))
  (ecase external-format
    ((:default)))
  (lisp:compile-file input-file :output-file output-file :verbose verbose :print print))

(defun compile-file-pathname (input-file &key output-file &allow-other-keys)
  (let ((pathname (scl:send (fs:merge-pathnames input-file fs:load-pathname-defaults)
			    :new-pathname
			    :canonical-type si:*default-binary-file-type*
			    :version :newest)))
    (if output-file
	(fs:merge-pathnames output-file pathname)
	pathname)))

(defun load (filename &key (verbose *load-verbose*) (print *load-print*)
	     (if-does-not-exist :error) (external-format :default))
  (ecase external-format
    ((:default)))
  (lisp:load filename :verbose verbose :print print :if-does-not-exist if-does-not-exist))

(declaim (inline adjoin))
(defun adjoin (item list &rest keys &key (test #'eql) test-not (key #'identity))
  (declare (ignore test test-not key))
  (declare (dynamic-extent keys))
  (apply #'lisp:adjoin item list keys))

(defun adjust-array (array new-dimensions &rest keys &key element-type initial-element
							  initial-contents fill-pointer
							  displaced-to displaced-index-offset)
  (declare (ignore element-type initial-element initial-contents fill-pointer displaced-to
		   displaced-index-offset))
  (declare (dynamic-extent keys))
  (apply #'lisp:adjust-array array new-dimensions keys))

(defun apropos (string &optional package)
  (lisp:apropos string package))

(defun apropos-list (string &optional package)
  (lisp:apropos-list string package))

(declaim (inline boole))
(defun boole (op integer1 integer2)
  (lisp:boole op integer1 integer2))

(declaim (inline code-char))
(defun code-char (code)
  (lisp:code-char code))

(defun copy-alist (list)
  (lisp:copy-alist list))

(defun copy-list (list)
  (lisp:copy-list list))

(defun copy-seq (sequence)
  (lisp:copy-seq sequence))

(defun copy-tree (object)
  (lisp:copy-tree object))

(defmacro dotimes ((var countform &optional resultform) &body forms &environment env)
  (declare (compiler:do-not-record-macroexpansions))
  (cli::expand-dotimes var countform resultform forms env :syntax :ansi-common-lisp))

(defun (compiler:style-checker ignored-iterator dotimes) (form)
  (let ((var (car (second form)))
	(declarations (si:find-body-declarations (cddr form)
						 compiler:*optimizer-environment*)))
    (when (cli::variable-ignored var declarations)
      ;; Not enough support to do (WARN 'STYLE-WARNING ...), so do it the old way.
      (cli::warn '(:bad-style t)
		 "The iteration variable ~S is implicitly used, so it may not be ignored."
		 var))))

(declaim (inline delete-duplicates))
(defun delete-duplicates (sequence &rest keys &key from-end (test #'eql) test-not (start 0) end
						   (key #'identity))
  (declare (ignore from-end test test-not start end key))
  (declare (dynamic-extent keys))
  (apply #'lisp:delete-duplicates sequence keys))

(defun delete-file (file)
  (ctypecase file
    ((or pathname string)
     (lisp:delete-file file))
    ((satisfies pathname-stream-p)
     (lisp:delete-file file))))

(declaim (inline digit-char))
(defun digit-char (weight &optional (radix 10))
  (lisp:digit-char weight radix))

(defun directory (pathname)
  (lisp:directory (pathname pathname)))

(defun disassemble (function)
  (lisp:disassemble function))

(defun dribble (&optional pathname)
  (lisp:dribble pathname))

(defun inspect (object)
  (lisp:inspect object))

(defun gethash (key table &optional default)
  (multiple-value-bind (value found-p)
      (lisp:gethash key table default)
    (values value found-p)))

;;; Need these so 8.1 binaries will load.
(progn
  (eval-when (:compile-toplevel)
    (flavor::defgeneric-internal 'gethash '(key table &optional default) :define-p nil
				 :debugging-info '((:method-arglist key &optional table))
				 :compile-time t))
  (flavor::defgeneric-internal 'gethash '(key table &optional default) :define-p nil
			       :debugging-info '((:method-arglist key &optional table)))

  (scl:defmethod (gethash hash-table) (key &optional default)
    (lisp:gethash key scl:self default))
  )

(defun (setf gethash) (value key table &optional default)
  (setf (lisp:gethash key table default) value))

(defun macroexpand (form &optional env)
  (lisp:macroexpand form env))

(defun macroexpand-1 (form &optional env)
  (lisp:macroexpand-1 form env))

(declaim (inline make-array))
(defun make-array (dimensions &rest keys &key (element-type t) initial-element initial-contents
					      adjustable fill-pointer displaced-to
					      displaced-index-offset)
  (declare (ignore element-type initial-element initial-contents adjustable fill-pointer
		   displaced-to displaced-index-offset))
  (declare (dynamic-extent keys))
  (apply #'lisp:make-array dimensions keys))

(defun make-hash-table (&rest keys &key (test #'eql) size rehash-size rehash-threshold)
  (declare (ignore test size rehash-size rehash-threshold))
  (declare (dynamic-extent keys))
  (apply #'lisp:make-hash-table keys))

(declaim (inline make-list))
(defun make-list (size &key initial-element)
  (lisp:make-list size :initial-element initial-element))

(defun make-sequence (type size &rest keys &key initial-element)
  (declare (ignore initial-element))
  (declare (dynamic-extent keys))
  (apply #'lisp:make-sequence type size keys))

(defun make-string (size &rest keys &key initial-element (element-type 'character))
  (declare (ignore initial-element))
  (declare (dynamic-extent keys))
  (apply #'lisp:make-string size :element-type element-type keys))

(defun make-symbol (print-name)
  (lisp:make-symbol print-name))

(defun parse-integer (string &key (start 0) end (radix 10) junk-allowed)
  (lisp:parse-integer string :start start :end end :radix radix :junk-allowed junk-allowed))

(defun rename-file (file new-name)
  (ctypecase file
    ((or pathname string)
     (lisp:rename-file file new-name))
    ((satisfies pathname-stream-p)
     (lisp:rename-file file new-name))))

(defun room (&optional (x :default))
  (check-type x (member t nil :default))
  (if (eq x :default)
      (lisp:room)
      (lisp:room x)))

(defun sleep (seconds)
  (lisp:sleep seconds))

(defun vector-pop (vector)
  (lisp:vector-pop vector))

(defun make-string-output-stream (&key (element-type 'character))
  (sys:make-lexical-closure
    (cli::make-string-output-environment :string (make-string 100 :element-type element-type)
					 :index 0 :end 100)
    #'cli::string-output-stream))

(defun open (filename &rest keys &key (direction :input) (element-type 'character)
	     if-exists if-does-not-exist (external-format :default))
  (declare (ignore direction element-type if-exists if-does-not-exist))
  (declare (dynamic-extent keys))
  (ecase external-format
    ((:default)))
  (apply #'lisp:open filename keys))

(defun write (object &rest keys &key stream escape radix base circle pretty level length
				     case gensym array readably pprint-dispatch right-margin
				     lines miser-width)
  (declare (ignore stream escape radix base circle pretty level length
		   case gensym array readably pprint-dispatch right-margin
		   lines miser-width))
  (declare (dynamic-extent keys))
  (apply #'lisp:write object keys))

(defun write-to-string (object &rest keys &key escape radix base circle pretty level length
					       case gensym array)
  (declare (ignore escape radix base circle pretty level length case gensym array))
  (declare (dynamic-extent keys))
  (apply #'lisp:write-to-string object keys))

;;;

(defun stream-external-format (stream)
  (declare (ignore stream))
  :default)

(defun interactive-stream-p (stream)
  (scl:send stream :interactive))

(defun open-stream-p (stream)
  (typecase stream
    (file-stream
      (let ((stream-to-find (if (typep stream 'si:basic-indirect-stream-mixin)
				(scl:send stream :stream)
				stream)))
	;; Don't let the *PATHNAME-HOST-LIST* change out from under us.  We'll try to be quick.
	(process:without-preemption
	  (dolist (host fs:*pathname-host-list*)
	    (dolist (open-stream (scl:send host :open-streams))
	      (when (eq stream-to-find open-stream)
		(return-from open-stream-p t)))))))
    (otherwise 
      (conditions:restart-case
	  (error "~S was called on ~S.~
	        ~%This operation is currently only implemented for file streams."
		 'open-stream-p stream)
	(treat-as-open   () :report "Treat the stream as open."   t)
	(treat-as-closed () :report "Treat the stream as closed." nil)))))

(compiler:add-style-checker 'ansi-function-nyi 'file-string-length 'ansi-function-nyi)
(defun file-string-length (file-stream object)
  (error "~S is not implemented" 'file-string-length))

(defun upgraded-complex-part-type (type &optional env)
  (declare (ignore env))
  (dolist (upgraded-type '(single-float double-float rational))
    (when (subtypep type upgraded-type)
      (return-from upgraded-complex-part-type upgraded-type)))
  (error "~S is not a type of real number." type))

(defun upgraded-array-element-type (type &optional env)
  (declare (ignore env))
  (or (cdr (assoc (cli::type-array-element-type type) cli::*array-element-types*)) t))

(defun pprint-newline (kind &optional stream)
  (declare (ignore stream))
  (check-type kind (member :linear :fill :miser :mandatory))
  nil)

(defun pprint-logical-block-1 (continuation stream list &key prefix per-line-prefix (suffix ""))
  (declare (dynamic-extent continuation))
  (error "~S is not implemented" 'pprint-logical-block))

(defun pprint-indent (relative-to n &optional stream)
  (declare (ignore stream))
  (check-type relative-to (member :block :current))
  (check-type n real)
  nil)

(defun pprint-tab (kind colnum colinc &optional stream)
  (declare (ignore stream))
  (check-type kind (member :line :section :line-relative :section-relative))
  (check-type colnum (integer 0 *))
  (check-type colinc (integer 0 *))
  nil)

(compiler:add-style-checker 'ansi-function-nyi 'pprint-fill 'ansi-function-nyi)
(defun pprint-fill (stream list &optional colon? atsign?)
  (error "~S is not implemented" 'pprint-fill))

(compiler:add-style-checker 'ansi-function-nyi 'pprint-linear 'ansi-function-nyi)
(defun pprint-linear (stream list &optional colon? atsign?)
  (error "~S is not implemented" 'pprint-linear))

(compiler:add-style-checker 'ansi-function-nyi 'pprint-tabular 'ansi-function-nyi)
(defun pprint-tabular (stream list &optional colon? atsign? tabsize)
  (error "~S is not implemented" 'pprint-tabular))

(compiler:add-style-checker 'ansi-function-nyi 'copy-pprint-dispatch 'ansi-function-nyi)
(defun copy-pprint-dispatch (&optional table)
  (error "~S is not implemented" 'copy-pprint-dispatch))

(compiler:add-style-checker 'ansi-function-nyi 'pprint-dispatch 'ansi-function-nyi)
(defun pprint-dispatch (object &optional table)
  (error "~S is not implemented" 'pprint-dispatch))

(compiler:add-style-checker 'ansi-function-nyi 'set-pprint-dispatch 'ansi-function-nyi)
(defun set-pprint-dispatch (type function &optional priority table)
  (error "~S is not implemented" 'set-pprint-dispatch))



(defun canonicalize-package (package)
  (etypecase package
    ((or string symbol sys:package) (sys:find-package-for-syntax package :ansi-common-lisp))))

(defun make-package (name &key nicknames (use "COMMON-LISP"))
  (si:make-package-for-syntax name :nicknames nicknames :use use :syntax :ansi-common-lisp))

(defmacro in-package (name)
  (etypecase name
    (string)
    (symbol (setf name (symbol-name name))))
  `(eval-when (compile load eval)
     (in-package-1 ',name)))

(defun in-package-1 (name)
  (setf *package* (sys:find-package-for-syntax name :ansi-common-lisp)))

(defun find-package (name)
  (declare lt:(side-effects reader))
  (sys:find-package-for-syntax name :ansi-common-lisp :find))

(defun package-name (package)
  (declare lt:(side-effects reader))
  (setf package (canonicalize-package package))
  (sys:package-name-for-syntax package :ansi-common-lisp nil))

(defun package-nicknames (package)
  (declare lt:(side-effects reader))
  (setf package (canonicalize-package package))
  (si:package-nicknames-for-syntax package :ansi-common-lisp nil))

(defun rename-package (package new-name &optional new-nicknames)
  (setf package (canonicalize-package package))
  (si:rename-package-for-syntax package new-name new-nicknames :ansi-common-lisp)
  package)

(defun package-use-list (package)
  (setf package (canonicalize-package package))
  (lisp:package-use-list package))

(defun package-used-by-list (package)
  (setf package (canonicalize-package package))
  (lisp:package-used-by-list package))

(defun package-shadowing-symbols (package)
  (setf package (canonicalize-package package))
  (lisp:package-shadowing-symbols package))

;; list-all-packages

(defun delete-package (package)
  (unless (packagep package)
    (let ((pkg (find-package package)))
      (when (null pkg)
	(cerror "Proceed without deleting anything." "No package named ~A can be found."
		package)
	(return-from delete-package nil))
      (setf package pkg)))
  (when (null (package-name package))
    (return-from delete-package nil))
  (when (not (null (package-used-by-list package)))
    (cerror "Unuse the package." "Package ~A is used by packages ~A."
	    package (package-used-by-list package)))
  (si:pkg-kill package)
  (setf (si:pkg-name-list package) nil)
  (setf (si:pkg-prefix-name package) nil)
  t)

(defun intern (string &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:intern string package))

(defun find-symbol (string &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:find-symbol string package))

(defun unintern (symbol &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:unintern symbol package))

(defun export (symbols &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:export symbols package))

(defun unexport (symbols &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:unexport symbols package))

(defun import (symbols &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:import symbols package))

(defun shadowing-import (symbols &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:shadowing-import symbols package))

(defun shadow (symbols &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:shadow symbols package))

(defun resolve-package-names (package-names)
  (mapcar #'(lambda (name) (sys:find-package-for-syntax name :ansi-common-lisp))
	  (if (listp package-names) package-names (list package-names))))

(defun use-package (packages-to-use &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:use-package (resolve-package-names packages-to-use) package))

(defun unuse-package (packages-to-unuse &optional (package *package*))
  (setf package (canonicalize-package package))
  (lisp:unuse-package (resolve-package-names packages-to-unuse) package))

;;; find-all-symbols

(defmacro do-symbols ((var &optional package result-form) &body body)
  `(do-symbols-expander ,var (list ,package) ,result-form ,body
			:internal :external :inherited))

(defmacro do-external-symbols ((var &optional package result-form) &body body)
  `(do-symbols-expander ,var (list ,package) ,result-form ,body :external))

(defmacro do-all-symbols ((var &optional result-form) &body body)
  `(do-symbols-expander ,var (list-all-packages) ,result-form ,body :internal :external))

(defmacro do-symbols-expander (var packages result-form body &rest symbol-types)
  (let ((mname (gensym)))
    `(with-package-iterator (,mname ,packages ,@symbol-types)
       (loop
	 (multiple-value-bind (,mname ,var) (,mname)
	   (if ,mname
	       (progn ,@body)
	       (return ,result-form)))))))

;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")WITH-PACKAGE-ITERATOR

0;;; Uses 7 different iterating functions depending on :internal, :external and :inherited;
;;; State of iterator is stored in a stack list;

;;; Sets up the state variables for with-package-iterator
(defmacro with-package-iterator-state (state-variable packages &body body)
  (let ((package-list-variable (gensym)))
    `(let ((,package-list-variable ,packages))
       (unless (listp ,package-list-variable)
	 (setq ,package-list-variable (list ,package-list-variable)))

       ;;; list must correspond with state-variable-list of functions defined
       ;;; by define-package-iterator.
       (scl:with-stack-list
	 (,state-variable
	  ;; iterator state elements:
	  -1				;INDEX into PACKAGE
	  nil				;PACKAGE, one of USED-PACKAGES
	  nil				;SPECIFIED-PACKAGE, one of SPECIFIED-PACKAGES
	  nil				;USED-PACKAGES, self-and-use-list of SPECIFIED-PACKAGE
	  ,package-list-variable	;SPECIFIED-PACKAGES, PACKAGES argument from user
	  )				;stack list state variable crock because people
					;say closures arn't efficient.
	 ,@body))))

;;; This macro constructs the 7 different iterator functions, one for each combination of
;;; :internal :external and :inherited
(defmacro define-package-iterator (internal-p external-p inherited-p name)
  `(defun ,name (state-variable-list)
     (macrolet ((index ()              `(first   state-variable-list))
		(package ()            `(second  state-variable-list))
		(specified-package ()  `(third   state-variable-list))
		(used-packages ()      `(fourth  state-variable-list))
		(specified-packages () `(fifth   state-variable-list))
		)				;structure of state-variable-list must
						;correspond with with-package-iterator-state
       ;;; SPECIFIED-PACKAGES is the list of packages provided in the invocation of
       ;;; with-package-iterator.  We pop things off of it into SPECIFIED-PACKAGE.
       ;;; USED-PACKAGES is the pkg-self-and-use-list of SPECIFIED-PACKAGE.
       ;;; we pop things off of it into PACKAGE.  INDEX is the current index into PACKAGE.
       ;;; It starts at the end and moved backwards to the beginning.

       ;;; Here we cache those values which are referenced in the most frequent passes through
       ;;; the loop.
       (let* ((fast-index (index))
	      (fast-package (package))
	      (fast-specified-package (specified-package))
	      ,@(and inherited-p
		     `((shadow (and fast-specified-package (si:pkg-shadowing-symbols fast-specified-package)))
		       hash-code)))
	 (macrolet (;; "writethrough" cache for infrequently modified variables
		    (alter-fast-package (new)
		      `(progn (setq fast-package ,new)
			      (setf (package) fast-package)))
		    (alter-fast-specified-package (new)
		      `(progn (setq fast-specified-package ,new)
			      (setf (specified-package) fast-specified-package)
			      ,@',(and inherited-p `((setq shadow (si:pkg-shadowing-symbols fast-specified-package)))))))
	   (multiple-value-prog1
	     (block found-a-symbol
	       (loop
		 (when (<= fast-index 0)
		   (loop				;get another package to look through
		     (if (used-packages)
			 (alter-fast-package (pop (used-packages)))
			 (progn
			   (unless (specified-packages) (return-from found-a-symbol nil))
			   (let ((p (pop (specified-packages))))
			     (alter-fast-specified-package (si:find-package-for-syntax p :ansi-common-lisp :error)))
			   ,(if inherited-p
				`(macrolet ((consider (x)
					      ,(if (or internal-p external-p)
						   `x ``(cdr ,x))))
				   (setf (used-packages)
					 (consider (si:pkg-self-and-use-list
						     fast-specified-package)))
				   (alter-fast-package (pop (used-packages))))
				`(alter-fast-package fast-specified-package)) ))
		     (when fast-package (return)))
		   (setq fast-index (array-dimension fast-package 0)))

		 (decf fast-index 2)
		 (when (numberp ,(if inherited-p
				     `(setq hash-code (si:pkg-entry-hash fast-package fast-index))
				     `(si:pkg-entry-hash fast-package fast-index)))
		   (let ((symbol (si:pkg-entry-symbol fast-package fast-index)))
		     (macrolet
		       ((symbol-type-dispatch ()
			  ,(if (or internal-p external-p)
			       ``(scl:select (si:pkg-entry-code fast-package fast-index)
				   ,',@(when internal-p
					 `((si:pkg-internal-code
					     (return-from found-a-symbol
					       (values t symbol :internal
						       fast-specified-package)))))
				   ,',@(when external-p
					 `((si:pkg-external-code
					     (return-from found-a-symbol
					       (values t symbol :external
						       fast-specified-package))))) )
			       nil))
			(inherited-symbols-check ()
			  `(when (eql si:pkg-external-code
				      (si:pkg-entry-code fast-package fast-index))
			     (unless (and shadow
					  (multiple-value-bind (ignore idx)
					      (scl:without-interrupts
						(si:pkg-intern-internal
						  (symbol-name symbol) hash-code
						  fast-specified-package))
					    (declare (ignore ignore))
					    idx))
			       (return-from found-a-symbol
				 (values t symbol :inherited fast-specified-package)))
			     )) )
		       ,(if inherited-p
			    (if (or internal-p external-p)
				`(if (eq fast-package fast-specified-package)
				     (symbol-type-dispatch)
				     (inherited-symbols-check))
				`(inherited-symbols-check))
			    `(symbol-type-dispatch)))
		     ))))

	     ;;; save the cached values
	     ;;; FAST-PACKAGE and FAST-SPECIFIED-PACKAGE are "write-through" variables
	     ;;; only FAST-INDEX need be saved.
	     (setf (index) fast-index))))
       )))

;;; Make the iterator functions
;(define-package-iterator nil nil nil package-iterator-illegal)  won't ever be needed!
(define-package-iterator nil nil   t package-iterator-inherited)
(define-package-iterator nil   t nil package-iterator-external)
(define-package-iterator nil   t   t package-iterator-external-inherited)
(define-package-iterator   t nil nil package-iterator-internal)
(define-package-iterator   t nil   t package-iterator-internal-inherited)
(define-package-iterator   t   t nil package-iterator-internal-external)
(define-package-iterator   t   t   t package-iterator-internal-external-inherited)

(defmacro with-package-iterator ((next-function package-list &rest symbol-types) &body body)
  (flet ((select-package-iterator (internal-p external-p inherited-p)
	   ;; Pick the right iterator function, based on which keywords were provided to
	   ;; WITH-PACKAGE-ITERATOR
	   (if internal-p
	       (if external-p
		   (if inherited-p
		       'package-iterator-internal-external-inherited
		       'package-iterator-internal-external)
		   (if inherited-p
		       'package-iterator-internal-inherited
		       'package-iterator-internal))
	       (if external-p
		   (if inherited-p
		       'package-iterator-external-inherited
		       'package-iterator-external)
		   (if inherited-p
		       'package-iterator-inherited
		       (error "No package iterator")	; should never happen
		       )))))
    (let ((state-variable-name (gensym))
	  internal-p external-p inherited-p
	  iterator-function)

    ;;; argument parsing:
      (dolist (type symbol-types)
	(ecase type
	       (:internal (setq internal-p t))
	       (:external (setq external-p t))
	       (:inherited (setq inherited-p t))
	       ))
      (unless (or internal-p external-p inherited-p)
	(error "No symbol types were specified.~&~
You must specifiy at least one of :internal, :external, or :inherited."))

    ;;; pick the right package iterator function:
    (setq iterator-function
	  (select-package-iterator internal-p external-p inherited-p))
    
    `(with-package-iterator-state ,state-variable-name ,package-list
       (macrolet ((,next-function ()
		   `(,',iterator-function ,',state-variable-name)))
	 ,@body)))))

;;;

(defmacro defpackage (name &body options)
  (let ((nicknames nil)
	(use-list nil)
	(use-seen nil)
	(shadow nil)
	(shadowing-import-from (make-hash-table :test #'string=))
	(import-from (make-hash-table :test #'string=))
	(export nil)
	(intern nil)
	(size nil)
	(documentation nil))
    ;; Parse the options.
    (labels ((safe-string (name)
	       (etypecase name
		 (string name)
		 (symbol (symbol-name name))))
	     (append-symbol-names (strings names)
	       (append strings (mapcar #'safe-string names))))
      (macrolet ((appendf-symbol-names (strings names)
		   `(setf ,strings (append-symbol-names ,strings ,names))))
	(setf name (safe-string name))
	(dolist (option options)
	  (check-type option list)
	  (let ((ll (list-length option)))
	    (unless (and ll (plusp ll))
	      (error "Malformed DEFPACKAGE option ~S." option))
	    (ecase (first option)
	      (:nicknames
		(appendf-symbol-names nicknames (rest option)))
	      (:use
		(setf use-seen t)
		(appendf-symbol-names use-list (rest option)))
	      (:shadow
		(appendf-symbol-names shadow (rest option)))
	      (:shadowing-import-from
		(unless (< 1 ll)
		  (error "Malformed DEFPACKAGE option ~S." option))
		(appendf-symbol-names (gethash (safe-string (second option)) shadowing-import-from)
				      (nthcdr 2 option)))
	      (:import-from
		(unless (< 1 ll)
		  (error "Malformed DEFPACKAGE option ~S." option))
		(appendf-symbol-names (gethash (safe-string (second option)) import-from)
				      (nthcdr 2 option)))
	      (:export
		(appendf-symbol-names export (rest option)))
	      (:intern
		(appendf-symbol-names intern (rest option)))
	      (:size
		(unless (= ll 2)
		  (error "Malformed DEFPACKAGE option ~S." option))
		(when (not (null size))
		  (error "Size specified more than once."))
		(setf size (second option))
		(check-type size (integer 0 *)))
	      (:documentation
		(unless (= ll 2)
		  (error "Malformed DEFPACKAGE option ~S." option))
		(when (not (null documentation))
		  (error "Documentation specified more than once."))
		(setf documentation (second option))
		(check-type documentation string)))))))
    ;; Remove duplicate entries.
    ;; KMP 15-Dec-89: !!! Might be nice sometime to do a style warning here
    ;;                about duplicate entries while removing them.
    (setf nicknames (remove-duplicates nicknames :test #'string=))
    (setf use-list (remove-duplicates use-list :test #'string=))
    (setf shadow (remove-duplicates shadow :test #'string=))
    (flet ((fixtable (table)
	     (maphash #'(lambda (key value)
			  (setf (gethash key table)
				(remove-duplicates value :test #'string=)))
		      table)))
      (fixtable shadowing-import-from)
      (fixtable import-from))
    (setf export (remove-duplicates export :test #'string=))
    (setf intern (remove-duplicates intern :test #'string=))
    ;; Make sure all symbols are mentioned once.
    (flet ((test-disjoint (&rest lists)
	     (declare (dynamic-extent lists))
	     (let ((table (make-hash-table :test #'string=)))
	       (flet ((test (name)
			(unless (= 1 (incf (gethash name table 0)))
			  ;; KMP 15-Dec-89: !!! Would be a good idea to make this
			  ;;  error proceedable. e.g., accumulate a list of the problem
			  ;;  symbols and then prompt the user for options to correct.
			  (error "The name ~A appears more than once." name))))
		 (dolist (list lists)
		   (if (listp list)
		       (map nil #'test list)
		       (maphash #'(lambda (key value)
				    (declare (ignore key))
				    (map nil #'test value))
				list)))))))
      (test-disjoint shadow intern shadowing-import-from import-from)
      (test-disjoint export intern))
    ;; Genereate the function call.
    (flet ((table-list (table)
	     (let ((list nil))
	       (maphash #'(lambda (key value)
			    (push (cons key value) list))
			table)
	       list)))
      `(eval-when (:compile-toplevel :load-toplevel :execute)
	 (defpackage-internal
	   ,name
	   ,@(and nicknames `(:nicknames ',nicknames))
	   ,@(and use-seen `(:use ',use-list))
	   ,@(and shadow `(:shadow ',shadow))
	   ,@(let ((list (table-list shadowing-import-from)))
	       (and list `(:shadowing-import-from ',list)))
	   ,@(let ((list (table-list import-from)))
	       (and list `(:import-from ',list)))
	   ,@(and export `(:export ',export))
	   ,@(and intern `(:intern ',intern))
	   ,@(and size `(:size ,size))
	   ,@(and documentation `(:documentation ,documentation))
	   )))))

(defvar *package-documentation* (make-hash-table :test #'string-equal :size 0))

(defun defpackage-internal (name &key nicknames (use '("COMMON-LISP")) shadow
			    shadowing-import-from import-from export intern size documentation)
  (declare (ignore size))
  (let ((package (find-package name)))
    (cond ((null package)
	   (setf package (make-package name :nicknames nicknames :use nil)))
	  (t
	   ;; Unexport all exported symbols.
	   (unexport (loop for sym being each external-symbol of package
			   collect sym)
		     package)
	   (unuse-package (package-use-list package) package)
	   ;; Unintern all imported symbols which we can find again.
	   (loop for sym being each present-symbol of package
		 for sympkg = (symbol-package sym)
		 when (and sympkg
			   (not (eq package sympkg))
			   (eq sym (find-symbol (symbol-name sym) sympkg)))
		   do (unintern sym package))
	   (setf (si:pkg-shadowing-symbols package) nil)
	   (rename-package package name nicknames)))
    (shadow shadow package)
    (dolist (entry shadowing-import-from)
      (let ((pkg (canonicalize-package (first entry))))
	(shadowing-import (mapcar #'(lambda (name) (intern name pkg)) (rest entry))
			  package)))	     
    (use-package use package)
    (dolist (entry import-from)
      (let ((pkg (canonicalize-package (first entry))))
	(import (mapcar #'(lambda (name) (intern name pkg)) (rest entry)) package)))
    (map nil #'(lambda (name) (intern name package)) intern)
    (export (mapcar #'(lambda (name) (intern name package)) export) package)
    (if documentation
	(setf (gethash name *package-documentation*) documentation)
	(remhash name *package-documentation*))
    package))
