;;; -*- Mode: LISP; Package: Common-lisp-internals; Lowercase: T; Syntax: Common-Lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Initial Common Lisp compatibility functions and variables.

;;;Chapter 4.
;;;See types.lisp

;;;Chapter 5, minus the above

(defconstant lambda-parameters-limit #+3600 128 #+IMACH 50)

;;;Chapter 6.

(defun equal (x y)
  (declare lt:(side-effects reader reducible))
  (declare (compiler:return-type boolean))
  (loop
    (cond ((eql x y) (return t))
	  ((not (= (sys:%data-type x) (sys:%data-type y))) (return nil))
	  ((consp x)
	   (loop
	     (unless (or (eql (car x) (car y))
			 (equal (car x) (car y)))
	       (return-from equal nil))
	     (setq x (cdr x) y (cdr y))
	     (unless (and (consp x) (consp y))
	       (return))))
	  ((arrayp x) ;optimize out the common case
	   (cond ((stringp x) (return (and (stringp y) (sys:%string= x 0 y 0 nil))))
		 ((bit-vector-p x) (return (and (bit-vector-p y)
						(bit-vector-equal x y))))
		 (t (return nil))))
	  (t (return nil)))))

(defun equalp (x y)
  (declare lt:(side-effects reader reducible))
  (declare (compiler:return-type boolean))
  (loop
    (cond ((eql x y) (return t))
	  ((numberp x) (return (and (numberp y) (= x y))))
	  ((arrayp x) (return (and (arrayp y) (array-equalp x y))))
	  ((not (= (sys:%data-type x) (sys:%data-type y))) (return nil))
	  ((consp x)
	   (loop
	     (unless (or (eql (car x) (car y))
			 (equalp (car x) (car y)))
	       (return-from equalp nil))
	     (setq x (cdr x) y (cdr y))
	     (unless (and (consp x) (consp y))
	       (return))))
	  ((characterp x) (return (and (characterp y) (char-equal x y))))
	  ((hash-table-p x)
	   (return (and (hash-table-p y) (hash-table-equalp x y))))
	  ((instancep x)
	   (return (and (instancep y) (clos-internals::clos-instance-equalp x y))))
	  (t (return nil)))))

(defun array-equalp (a b)
  (let ((nd1 (array-rank a))
	(nd2 (array-rank b)))
    (compiler:%error-unless (= nd1 nd2)
      (return-from array-equalp nil))
    (cond ((= nd1 1)
	   (let ((length (length a)))		;hack fill pointers
	     (and (= (length b) length)
		  (let ((a a) (b b))
		    (declare (sys:array-register a b))
		    (dotimes (i length t)
		      (compiler:%error-unless (equalp (%1d-aref a i) (%1d-aref b i))
			(return nil)))))))
	  ((= nd1 0) (equalp (aref a) (aref b)))
	  ((not (loop for axis below nd1
		      always (= (array-dimension a axis) (array-dimension b axis))))
	   nil)
	  ((and (zerop (sys:array-discontiguous-bit a))
		(zerop (sys:array-discontiguous-bit b)))
	   (let ((a a) (b b))
	     (declare (sys:array-register-1d a b))
	     (dotimes (i (array-total-size a) t)
	       (compiler:%error-unless (equalp (%1d-aref a i) (%1d-aref b i))
		 (return nil)))))
	  (t
	   (with-stack-list (indices 0 0 0 0 0 0 0 0 0 0)	;up to 10, only support ~7
	     (with-stack-list (limits 0 0 0 0 0 0 0 0 0 0)	;up to 10, only support ~7
	       (setq indices (nthcdr (- 10. nd1) indices)
		     limits  (nthcdr (- 10. nd1) limits))
	       (loop for axis below nd1
		     for limit on limits
		     do (setf (car limit) (array-dimension a axis)))
	       (recursive-array-equalp a b indices indices limits)))))))

;;; In days gone by (before 10/17/85), this used to traverse the array
;;; in column-major order.  Sink your teeth into that!  This one is
;;; row-major.  It is always called with at least one axis to go.
(defun recursive-array-equalp (a b indices indices-tail limits-tail)
  (dotimes (i (car limits-tail) t)
    (setf (car indices-tail) i)
    (unless (if (cdr indices-tail)
		(recursive-array-equalp a b indices (cdr indices-tail) (cdr limits-tail))
		(equalp (apply #'aref a indices) (apply #'aref b indices)))
      (return nil))))

;;;Chapter 7.

(defconstant call-arguments-limit #+IMACH 50
                                  #+3600 128) ;I think...really it depends on what else you do

(defconstant multiple-values-limit #+IMACH 50
				   #+3600 128) ;I think...really it depends on what else you do

;;; Modified version of the ZL PROGV.
;;; The VAR's are always SPECIAL, but don't get autodeclared. 
;;; Excess values are ignored.  Excess variables are unbound.
(si:define-special-form progv (&whole form vars vals &body body
				    &environment env)
  (declare lt:(arg-template eval eval arbitrary . body))
  (%with-binding-stack-level
    (let* ((vars (eval vars env))
	   (vals (eval vals env)))
      (loop (when (null vars) (return))
	    (let ((var (pop vars)))
	      (si:check-symbol-setability var "bind")
	      (let ((loc (follow-cell-forwarding (si:value-cell-location var) nil)))
		(if (not (null vals))
		    (%bind-location loc (pop vals))
		    (%bind-location loc nil)
		    (location-makunbound loc))))))
    (si:eval-body body env)))

;;; Full mapping functions


(defun mapcar (fcn list &rest more-lists)
  "Maps over successive elements, returns a list of the results."
  (declare (sys:downward-funarg fcn))
  ;;--- Eliminating the RPLACs would be better than the copylist
  (functionally-evaluate fcn)
  (let ((lists (list* list (copy-list more-lists))))
    (loop named top
	  with v
	  with n-lists = (length lists)
	  and p = (locf v)
	  for lp first lists then lists		;pick up next element of each list
	  do (let (#+imach (pushes 2))
	       (%start-function-call fcn t n-lists nil)
	       (loop until (null lp)
		     do (when (null (car lp))
			  #+imach (si:abort-call-0 pushes)
			  (return-from top v))
			#+imach (incf pushes)
			(%push (caar lp))
			(rplaca lp (cdar lp))
			(setq lp (cdr lp)))
	       (setq lp (%finish-function-call fcn t n-lists nil))
	       (rplacd p (setq p (ncons lp)))))))	;cons it onto list

(defun mapc (fcn list &rest more-lists)
  "Maps over successive elements, returns second argument."
  (declare (sys:downward-funarg fcn))
  ;;--- Eliminating the RPLACs would be better than the copylist
  (functionally-evaluate fcn)
  (let ((lists (list* list (copy-list more-lists))))
    (loop named top
	  with res = (car lists)
	  and n-lists = (length lists)
	  for lp first lists then lists
	  do (let (#+imach (pushes 2))
	       (%start-function-call fcn nil n-lists nil)
	       (loop until (null lp)
		     do (when (null (car lp))
			  #+imach (si:abort-call-0 pushes)
			  (return-from top res))
			#+imach (incf pushes)
			(%push (caar lp))
			(rplaca lp (cdar lp))
			(setq lp (cdr lp)))
	       (%finish-function-call fcn nil n-lists nil)))))

(defun maplist (fcn list &rest more-lists)
  "Maps over successive sublists, returns a list of the results."
  (declare (sys:downward-funarg fcn))
  ;;--- Eliminating the RPLACs would be better than the copylist
  (functionally-evaluate fcn)
  (let ((lists (list* list (copy-list more-lists))))
    (loop named top
	  with v
	  with n-lists = (length lists)
	  and p = (locf v)
	  for lp first lists then lists
	  do (let (#+imach (pushes 2))
	       (%start-function-call fcn t n-lists nil)
	       (loop until (null lp)
		     do (when (null (car lp))
			  #+imach (si:abort-call-0 pushes)
			  (return-from top v))
			#+imach (incf pushes)
			(%push (car lp))
			(rplaca lp (cdar lp))
			(setq lp (cdr lp)))
	       (setq lp (%finish-function-call fcn t n-lists nil))
	       (rplacd p (setq p (ncons lp)))))))

(defun mapl (fcn list &rest more-lists)
  "Maps over successive sublists, returns second argument."
  (declare (sys:downward-funarg fcn))
  ;;--- Eliminating the RPLACs would be better than the copylist
  (functionally-evaluate fcn)
  (let ((lists (list* list (copy-list more-lists))))
    (loop named top
	  with res = (car lists)
	  and n-lists = (length lists)
	  for lp first lists then lists
	  do (let (#+imach (pushes 2))
	       (%start-function-call fcn nil n-lists nil)
	       (loop until (null lp)
		     do (when (null (car lp))
			  #+imach (si:abort-call-0 pushes)
			  (return-from top res))
			#+imach (incf pushes)
			(%push (car lp))
			(rplaca lp (cdar lp))
			(setq lp (cdr lp)))
	       (%finish-function-call fcn nil n-lists nil)))))

(defun mapcan (fcn list &rest more-lists)
  "Maps over successive elements, returns NCONC of the results."
  (declare (sys:downward-funarg fcn))
  ;;--- Eliminating the RPLACs would be better than the copylist
  (functionally-evaluate fcn)
  (let ((lists (list* list (copy-list more-lists))))
    (loop named top
	  with v
	  with n-lists = (length lists)
	  and p = (locf v)
	  for lp first lists then lists
	  do (let (#+imach (pushes 2))
	       (%start-function-call fcn t n-lists nil)
	       (loop until (null lp)
		     do (when (null (car lp))
			  #+imach (si:abort-call-0 pushes)
			  (return-from top v))
			#+imach (incf pushes)
			(%push (caar lp))
			(rplaca lp (cdar lp))
			(setq lp (cdr lp)))
	       (setq lp (%finish-function-call fcn t n-lists nil)))
	  unless (atom lp)
	    do (rplacd p lp)
	       (setq p (last lp)))))

(defun mapcon (fcn list &rest more-lists)
  "Maps over successive sublists, returns NCONC of the results."
  (declare (sys:downward-funarg fcn))
  ;;--- Eliminating the RPLACs would be better than the copylist
  (functionally-evaluate fcn)
  (let ((lists (list* list (copy-list more-lists))))
    (loop named top
	  with v
	  with n-lists = (length lists)
	  and p = (locf v)
	  for lp first lists then lists
	  do (let (#+imach (pushes 2))
	       (%start-function-call fcn t n-lists nil)
	       (loop until (null lp)
		     do (when (null (car lp))
			  #+imach (si:abort-call-0 pushes)
			  (return-from top v))
			#+imach (incf pushes)
			(%push (car lp))
			(rplaca lp (cdar lp))
			(setq lp (cdr lp)))
	       (setq lp (%finish-function-call fcn t n-lists nil)))
	  unless (atom lp)
	    do (rplacd p lp)
	       (setq p (last lp)))))

;;; Chapter 8

;;;Chapter 9

;;;Moby work needed in the compiler *****
;;; We are mostly not implementing chapter 9 yet

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")(0defun the-checker (type form &rest values)
  (declare (dbg:error-reporter))
  (cond ((and (listp type)
	      (eq (first type) 'values))
	 (let ((state :required)
	       (next-values values)
	       (value-number 0))
	   (dolist (this-type (rest type))
	     (incf value-number)
	     (cond ((null state)
		    (cerror "Ignore this error."
			    "Extraneous types follow &REST in ~S." type))
		   ((eq state :rest)
		    (unless (typep next-values this-type)
		      (cerror "Use the values anyway."
			      "The list of the remaining values ~S is not of type ~S."
			      next-values this-type))
		    (setf next-values nil)
		    (setf state nil))
		   ((eq this-type '&optional)
		    (setf state :optional))
		   ((eq this-type '&rest)
		    (setf state :rest))
		   ((eq this-type '&key)
		    (error "~S is not supported in the type specifier for ~S."
			   '&key 'the))
		   ((null next-values)
		    (unless (eq state :optional)
		      (cerror "Ignore this error."
			      "No value was returned by ~S to match the ~:R type, ~S."
			      form value-number this-type)))
		   (t
		    (let ((this-value (pop next-values)))
		      (unless (typep this-value this-type)
			(cerror "Use the value anyway."
				"The ~:R value, ~S, returned by ~S is not of type ~S."
				value-number this-value form this-type))))))
	   (when next-values
	     (cerror "Use the values anyway."
		     "The form ~S returned ~S which is longer than the type list ~S."
		     form `(values ,@values) type))))
	(t
	 ;; (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")(the integer (floor 1 3))0 should not get an error, so don't bother
	 ;; checking that the number of returned values is exactly one.
	 ;; Note that 2(the (values integer) (floor 1 3))0 correctly signals an error.
	 (cond ((zerop (length values))
		(unless (typep nil type)
		  ;; 2(the symbol (values))0 is OK, but not 2(the integer (values))
0		  (cerror "Return no values."
			  "The form ~S returned no values rather than one or more values."
			  form)))
	       ((not (typep (first values) type))
		(cerror "Use the value anyway."
			"The form ~S returned the value ~S which is not of type ~S."
			form (first values) type)))))
  (values-list values))

(si:define-special-form the (type form &environment env)
  (declare lt:(arg-template quote return))
  (multiple-value-call #'the-checker type form (eval form env)))

;;;Chapter 10

#+IMACH
(defun getf (plist indicator &optional default)
  (declare lt:(side-effects reader reducible))
  (multiple-value-bind (value found-p)
      (sys:rgetf indicator plist)
    (if found-p
	value
	default)))

#+imach
(define-instruction-exception-handler rgetf trap-mode-emulator (indicator plist)
  (do ()
      ((null plist) (values nil nil))
    (when (eql (pop plist) indicator)
      (return (values (car plist) plist)))
    (setf plist (cdr plist))))

#-IMach
;; Make this accessible to architectures which don't have it as an instruction.
(defun rgetf (indicator plist)
  (declare lt:(side-effects reader reducible))
  (do ()
      ((null plist) (values nil nil))
    (when (eql (pop plist) indicator)
      (return (values (car plist) plist)))
    (setf plist (cdr plist))))

#+3600
(defun getf (plist indicator &optional default)
  (declare lt:(side-effects reader reducible))
  (do ()
      ((null plist) default)
    (when (eq (pop plist) indicator)
      (return (car plist)))
    (setf plist (cdr plist))))

;;; For compatibility only...
#+3600
(defun getf-internal (plist indicator default)
  (getf plist indicator default))

(defun set-getf (plist indicator value)
  ;; If the indicator is already present, just change it to the new property value.
  ;; Otherwise cons a new one onto the front of the property list.
  #+3600
  (do ((pl plist))
      ((null pl)
       (if plist
	   (list* indicator value plist)
	   (list indicator value)))
    (when (and (eq (pop pl) indicator) pl)
      (setf (car pl) value)
      (return plist))
    (setf pl (cdr pl)))
  #+IMach
  (multiple-value-bind (ignore place)
      (rgetf indicator plist)
    (cond (place
	   (setf (car place) value)
	   plist)
	  (plist
	   (list* indicator value plist))
	  (t
	   (list indicator value)))))

(define-setf-method getf (plist indicator &optional default &environment env)
  (multiple-value-bind (plist-temps plist-vals plist-stores
			plist-store-form plist-access-form)
      (get-setf-method plist env)
    (let ((itemp (gensym))
	  (store (gensym))
	  (vtemp (gensym)))
      (values (append plist-temps (list itemp))
	      (append plist-vals (list indicator))
	      (list store)
	      `(let-value ,vtemp ,store
		 ,(sys:stack-let ((*simple-variables*
				    `(,itemp ,vtemp ,@plist-temps ,@*simple-variables*)))
		    (let-subst plist-stores `((set-getf ,plist-access-form ,itemp ,vtemp))
			       plist-store-form
			       env)))
	      (if default
		  `(getf ,plist-access-form ,itemp ,default)
		  `(getf ,plist-access-form ,itemp))))))

(defun getf-location-1 (plloc indicator default)
  (let ((plist (location-contents plloc)))
    #+3600
    (do ((pl plist))
	((null pl)
	 (let ((new-plist (if plist
			       (list* indicator default plist)
			       (list indicator default))))
	   (setf (location-contents plloc) new-plist)
	   (locf (second new-plist))))
      (when (and (eq (pop pl) indicator) pl)
	(return (locf (car pl))))
      (pop pl))
    #+IMach
    (multiple-value-bind (ignore place)
	(rgetf indicator plist)
      (if place
	  (locf (car place))
	  (let ((new-plist (if plist
			       (list* indicator default plist)
			       (list indicator default))))
	    (setf (location-contents plloc) new-plist)
	    (locf (second new-plist)))))))

(deflocf getf (plist indicator &optional default)
  `(getf-location-1 (locf ,plist) ,indicator ,default))

;;;

(proclaim '(inline symbol-plist))
(defun symbol-plist (symbol)
  (declare lt:(side-effects reader))
  (location-contents (sys:property-cell-location symbol)))

#+3600
(defsubst get (symbol indicator &optional default)
  (declare lt:(side-effects reader))
  (getf (symbol-plist symbol) indicator default))

#+imach
(defun get (symbol indicator &optional default)
  (declare lt:(side-effects reader))
  ;; Inline the above code here for Ivory
  (check-type symbol symbol)
  (multiple-value-bind (value found-p)
      (sys:rgetf indicator (symbol-property-cell symbol))
    (if found-p value default)))

(defun putprop (symbol value indicator)
  (check-type symbol symbol)
  (without-interrupts
    (let ((plist (symbol-property-cell symbol)))
      #+3600
      (do ((pl plist))
	  ((null pl)
	   (let ((area (and (symbol-package-cell symbol) si:area-for-property-lists)))
	     (setf (symbol-property-cell symbol)
		   (if (null plist)
		       (list-in-area area indicator value)
		       (list*-in-area area indicator value plist)))))
	(when (and (eq (pop pl) indicator) pl)
	  (setf (car pl) value)
	  (return))
	(setq pl (cdr pl)))
      #+IMach
      (multiple-value-bind (ignore place)
	  (rgetf indicator plist)
	(if place
	    (setf (car place) value)
	    (let ((area (and (symbol-package-cell symbol) si:area-for-property-lists)))
	      (setf (symbol-property-cell symbol)
		    (if (null plist)
			(list-in-area area indicator value)
			(list*-in-area area indicator value plist)))))))
    value))

(defsetf get (symbol indicator &optional default) (value)
  default
  `(putprop ,symbol ,value ,indicator))

(defun get-location-1 (symbol indicator default)
  (check-type symbol symbol)
  (without-interrupts
    (let ((plist (symbol-property-cell symbol)))
      #+3600
      (do ((pl plist))
	  ((null pl)
	   (let* ((area (and (symbol-package-cell symbol) si:area-for-property-lists))
		  (new-plist (if plist
				 (list*-in-area area indicator default plist)
				 (list-in-area area indicator default))))
	     (setf (symbol-property-cell symbol) new-plist)
	     (locf (second new-plist))))
	(when (and (eq (pop pl) indicator) pl)
	  (return (locf (car pl))))
	(pop pl))
      #+IMach
      (multiple-value-bind (ignore place)
	  (rgetf indicator plist)
	(if place
	    (locf (car place))
	    (let* ((area (and (symbol-package-cell symbol) si:area-for-property-lists))
		   (new-plist (if plist
				 (list*-in-area area indicator default plist)
				 (list-in-area area indicator default))))
	      (setf (symbol-property-cell symbol) new-plist)
	      (locf (second new-plist))))))))

(deflocf get (symbol indicator &optional default)
  `(get-location-1 ,symbol ,indicator ,default))

;;;

(defun remf-1 (plist indicator)
  "Remove a property.  Returns non-NIL if present, NIL if not present.
   Second value is the new property list."
  (without-interrupts
    (let ((ppl (locf plist))
	  (pl plist))
      (loop
	(compiler:%error-when (endp pl)
	  (return (values nil plist)))
	(compiler:%error-when (#+3600 eq #+IMach eql (car pl) indicator)
	  ;; Found an indicator to remove.  Avoid RPLACD.
          (let ((npl1 (cdr pl)))
	    (unless (consp npl1)
	      (error "Malformed property list ~S" plist))
	    (let ((npl2 (cdr npl1)))
	      (cond ((and (not (endp npl2))		  ; RPLACD to NIL is okay.
			  (consp ppl)			  ; RPLACD of a LOCATIVE is okay.
			  (= (%p-cdr-code ppl) cdr-next)) ; RPLACD of a normal CONS is okay.
		     (%p-store-cdr-and-contents pl npl2 cdr-nil)
		     (%p-store-cdr-code ppl cdr-normal))
		    (t
		     (setf (location-contents ppl) npl2)
		     (setf (car pl) nil)))
	      (setf (car npl1) nil)
	      (setf (cdr npl1) nil)
	      (return (values t plist)))))
	(setf ppl (cdr pl))
	(compiler:%error-unless (consp ppl)
	  (error "Malformed property list ~S" plist))
	(setf pl (cdr ppl))))))

;; Older version for compatibility.
(defun remf-internal (plloc indicator)
  "Remove a property.  Returns NIL if not present, or a list whose CAR is the property."
  (remf (location-contents plloc) indicator))

(defun remprop (symbol indicator)
  (remf (symbol-plist symbol) indicator))

(defun get-properties (plist indicator-list)
  (declare lt:(side-effects reader reducible))
  (declare (values indicator value plist))
  (do ((pl plist plist))
      ((null plist) (values nil nil nil))
    (let ((indicator (pop plist)))
      (when (member indicator indicator-list)
	(return (values indicator (car plist) pl)))
      (pop plist))))

(defun copy-symbol (symbol &optional copyprops)
  (declare lt:(side-effects reader reducible))
  (let ((newsym (make-symbol (symbol-name symbol))))
    (when copyprops
      (when (boundp symbol)
	(setf (symbol-value newsym) (symbol-value symbol)))
      (when (fboundp symbol)
	(setf (symbol-function newsym) (symbol-function symbol)))
      (setf (symbol-plist newsym)
	    (copy-list (symbol-plist symbol) si:area-for-property-lists)))
    newsym))

;Common subroutine of GENSYM and GENTEMP  
(defun generate-symbol-name (prefix n)
  (if (and (= (string-length prefix) 1)
	   (< n 10000)
	   (not (string-fat-p prefix)))
      (let ((s (make-string 5)))
	(setf (aref s 0) (aref prefix 0))
	(loop for i from 4 downto 1
	      do (multiple-value-bind (tens ones)
		     (floor n 10)
		   (setf (aref s i) (digit-char ones))
		   (setf n tens)))
	s)
      (with-output-to-string (s)
	(write-string prefix s)
	(si:print-integer n 10 s))))

(defvar *gentemp-counter* 0)

(defun gentemp (&optional (prefix "T") package)
  (setq package (if package
		    (pkg-find-package package :error *package*)
		    *package*))
  (loop as string = (generate-symbol-name prefix (incf *gentemp-counter*))
	do (multiple-value-bind (sym found)
	       (intern string package)
	     (return-array string)
	     (unless found (return-from gentemp sym)))))

(defvar *gensym-prefix* "G")
(defvar *gensym-counter* 0)

(defun gensym (&optional arg)
  (ctypecase arg
    (null)
    (integer (setq *gensym-counter* arg))
    (string (setq *gensym-prefix* arg)))
  (make-symbol (generate-symbol-name *gensym-prefix*
				     (shiftf *gensym-counter* (1+ *gensym-counter*)))))

;;; this is in SYS, not CL or SCL
(defun gensymbol (&optional prefix count)
  (declare (arglist &optional (prefix "G") count))
  (when count (setq *gensym-counter* count))
  (make-symbol (generate-symbol-name (or prefix "G")
				     (shiftf *gensym-counter* (1+ *gensym-counter*)))))

(proclaim '(inline symbol-package))
(defun symbol-package (symbol)
  (declare lt:(side-effects reader))
  (location-contents (package-cell-location symbol)))

;;;Chapter 11 

;;;Moon has pointed out that Chapter 11, oddly enough, is largely bankrupt.

;;Chapter 12

(defsubst 1+ (number)
  (declare (compiler:do-not-record-macroexpansions))
  (+ number 1))

(defsubst 1- (number)
  (declare (compiler:do-not-record-macroexpansions))
  (- number 1))

(defsubst oddp (integer)
  (declare lt:(side-effects simple reducible))
  (not (zerop (ldb (byte 1 0) integer))))

(defsubst evenp (integer)
  (declare lt:(side-effects simple reducible))
  (zerop (ldb (byte 1 0) integer)))

(defun max (number &rest numbers)
  (declare lt:(side-effects simple reducible))
  (if (null numbers)
      (check-type number number)
      (dolist (n numbers)
	#+3600 (when (> n number) (setf number n))
	#+IMach (setf number (max number n))))		;Exercise instruction.
  number)

(defun min (number &rest numbers)
  (declare lt:(side-effects simple reducible))
  (if (null numbers)
      (check-type number number)
      (dolist (n numbers)
	#+3600 (when (< n number) (setf number n))
	#+IMach (setf number (min number n))))		;Exercise instruction.
  number)

(defun + (&rest numbers)
  (declare lt:(side-effects simple reducible))
  (if (null numbers)
      0
    (let ((number (pop numbers)))
      (if (null numbers)
	  (check-type number number)
	(loop do (setf number (+-internal number (pop numbers)))
	      while numbers))
      number)))

(defun - (number &rest more-numbers)
  (declare lt:(side-effects simple reducible))
  (if (null more-numbers)
      (zl:minus number)
    (loop do (setf number (--internal number (pop more-numbers)))
	  while more-numbers)
    number))

(defun * (&rest numbers)
  (declare lt:(side-effects simple reducible))
  (if (null numbers)
      1
    (let ((number (pop numbers)))
      (if (null numbers)
	  (check-type number cl:number)
	(loop do (setf number (* number (pop numbers)))
	      while numbers))
      number)))

(defun / (number &rest more-numbers)
  (declare lt:(side-effects simple reducible))
  (if (null more-numbers)
      (*rational-quotient 1 number)
    (loop do (setf number (*rational-quotient number (pop more-numbers)))
	  while more-numbers)
    number))

(defun lcm (&rest integers)
  (declare lt:(side-effects simple reducible))
  (let ((lcm 1))
    (loop while integers
	  for number = (pop integers)
	  when (zerop number) return 0
	  do (setq lcm (/ (* lcm (abs number)) (gcd lcm number)))
	  finally (return lcm))))

;; Fast two-argument case for the compiler.
(defun lcm-internal (a b)
  (declare lt:(side-effects simple reducible))
  (let ((gcd (gcd a b)))
    (if (zerop gcd)
	0
      (abs (/ (* a b) gcd)))))

(compiler:add-optimizer lcm lcm-optimizer lcm-internal)
(defun lcm-optimizer (form)
  (case (length form)
    (1 1)
    (2 `(abs ,@(rest form)))
    (3 `(lcm-internal ,@(rest form)))
    (otherwise form)))

(defun gcd (&rest integers)
  (declare lt:(side-effects simple reducible))
  (let ((gcd 0))
    (dolist (number integers gcd)
      (setf gcd (si:\\\\-internal gcd number)))))

(compiler:add-optimizer gcd gcd-optimizer si:\\\\-internal)
(defun gcd-optimizer (form)
  (cond ((null (cdr form)) 0)
	((null (cddr form)) `(abs ,(second form)))
	(t (loop for x in (reverse (cdr form))
		 as result first x then `(si:\\\\-internal ,x ,result)
		 finally (return result)))))

;;;rational/rationalize floors and ceilings, etc. in numerics.lisp

(defconstant boole-clr #2R0000)
(defconstant boole-set #2R1111)
(defconstant boole-1 #2R0101)
(defconstant boole-2 #2R0011)
(defconstant boole-c1 #2R1010)
(defconstant boole-c2 #2R1100)
(defconstant boole-and #2R0001)
(defconstant boole-ior #2R0111)
(defconstant boole-xor #2R0110)
(defconstant boole-eqv #2R1001)
(defconstant boole-nand #2R1110)
(defconstant boole-nor #2R1000)
(defconstant boole-andc1 #2R0010)
(defconstant boole-andc2 #2R0100)
(defconstant boole-orc1 #2R1011)
(defconstant boole-orc2 #2R1101)

(defun logand (&rest integers)
  (declare lt:(side-effects simple reducible))
  (let ((logand -1))
    (dolist (number integers logand)
      (setq logand (boole boole-and logand number)))))

(defun logior (&rest integers)
  (declare lt:(side-effects simple reducible))
  (let ((logior 0))
    (dolist (number integers logior)
      (setq logior (boole boole-ior logior number)))))

(defun logxor (&rest integers)
  (declare lt:(side-effects simple reducible))
  (let ((logxor 0))
    (dolist (number integers logxor)
      (setq logxor (boole boole-xor logxor number)))))

(defun logeqv (&rest integers)
  (declare lt:(side-effects simple reducible))
  (let ((logeqv -1))
    (dolist (number integers logeqv)
      (setq logeqv (boole boole-eqv logeqv number)))))

(defsubst lognand (integer1 integer2)
  (declare lt:(side-effects simple reducible))
  (boole boole-nand integer1 integer2))

(defsubst lognor (integer1 integer2)
  (declare lt:(side-effects simple reducible))
  (boole boole-nor integer1 integer2))

(defsubst logandc1 (integer1 integer2)
  (declare lt:(side-effects simple reducible))
  (boole boole-andc1 integer1 integer2))

(defsubst logandc2 (integer1 integer2)
  (declare lt:(side-effects simple reducible))
  (boole boole-andc2 integer1 integer2))

(defsubst logorc1 (integer1 integer2)
  (declare lt:(side-effects simple reducible))
  (boole boole-orc1 integer1 integer2))

(defsubst logorc2 (integer1 integer2)
  (declare lt:(side-effects simple reducible))
  (boole boole-orc2 integer1 integer2))

(defsubst logbitp (index integer)
  (declare lt:(side-effects simple reducible))
  (ldb-test (byte 1 index) integer))

(defun bits-on-per-fixnum (fixnum)
  (declare lt:(side-effects simple reducible))
  ;; modified from Gosper's HAKMEM algorithm
  ;; [division is expensive, bytes are cheap]
  ;; the sign is just another bit to count
  (let* ((threes (sys:%32-bit-difference
		   (sys:%32-bit-difference fixnum
					   (logand #o13333333333 (ldb (byte 31 1) fixnum)))
		   (logand #o11111111111 (ldb (byte 30 2) fixnum))))
	 (threes-mask (%logldb (byte 32 0) #o30707070707))
	 (sixes (+ (logand threes threes-mask)
		   (logand (ldb (byte 29 3) threes) threes-mask)))
	 (twelves (+ (ldb (byte 12 0) sixes)
		     (ldb (byte 12 12) sixes)
		     (ldb (byte 8 24) sixes))))
    (+ (ldb (byte 6 0) twelves)
       (ldb (byte 6 6) twelves))))

(defun logcount (integer)
  (declare lt:(side-effects simple reducible))
  (etypecase integer
    (fixnum (bits-on-per-fixnum (logxor integer (- (ldb (byte 1 31) integer)))))
    (bignum (loop with ref = (si:get-bignum-advancing-pointer integer 0)
		  with sign = (si:bignum-sign integer)
		  repeat (si:bignum-length integer)
		  sum (bits-on-per-fixnum (si:bignum-advance-ref ref sign))))))

;;; The functions which deal with bytes.
;;; First, the ones that don't care about byte specifiers.
;;; These are the primitive operations the later ones expand into.
;;; These functions are optimized to within an inch of their lives.

(defun load-byte-internal (size position from-value)
  (declare lt:(side-effects simple reducible)
	   (compiler:return-type integer))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (etypecase from-value
    (fixnum (if (or (< size (byte-size %%q-fixnum)) ( from-value 0))	;just in case
		(logand (lognot (lsh -1 size)) (ash from-value (- position)))
		(si:fixnum-load-byte-returning-bignum from-value position size)))
    (bignum (si:bignum-load-byte from-value position size))))

(defun deposit-byte-internal (byte-value size position into-value)
  (declare lt:(side-effects simple reducible)
	   (compiler:return-type integer))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (etypecase into-value
    (fixnum
      (etypecase byte-value
	(fixnum (if ( (+ position size) (byte-size %%q-fixnum))
		    (let* ((mask (lsh -1 (- size (byte-size %%q-fixnum))))
			   (answer (logior (lsh (logand byte-value mask) position)
					   (logand into-value (lognot (lsh mask position))))))
		      (if (minusp (logxor answer into-value))
			  (si:additive-fixnum-overflow answer)	;sign changed
			  answer))
		    (si:fixnum-fixnum-deposit-byte into-value position size byte-value)))
	(bignum (si:fixnum-bignum-deposit-byte into-value position size byte-value))))
    (bignum
      (etypecase byte-value
	(fixnum (si:bignum-fixnum-deposit-byte into-value position size byte-value))
	(bignum (si:bignum-bignum-deposit-byte into-value position size byte-value))))))

(defun fixnum-load-byte-internal (size position from-value)
  (declare lt:(side-effects simple reducible)
	   (compiler:return-type fixnum))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (unless (<= (+ size position) (byte-size %%q-fixnum))
    (error "Specified byte is outside the range of a fixnum."))
  (check-type from-value integer)
  (when (not (fixnump from-value))
    (setf from-value (si:integer-low-bits-as-fixnum from-value)))
  (logand (lsh -1 (- size (byte-size %%q-fixnum))) (lsh from-value (- position))))

(defun fixnum-deposit-byte-internal (byte-value size position into-value)
  (declare lt:(side-effects simple reducible)
	   (compiler:return-type fixnum))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (unless (<= (+ size position) (byte-size %%q-fixnum))
    (error "Specified byte is outside the range of a fixnum."))
  (check-type into-value fixnum)
  (check-type byte-value integer)
  (when (not (fixnump byte-value))
    (setf byte-value (si:integer-low-bits-as-fixnum byte-value)))
  (let ((mask (lsh (lsh -1 (- size (byte-size %%q-fixnum))) position)))
    (logior (logand into-value (lognot mask))
	    (logand (lsh byte-value position) mask))))

(defun %p-load-byte-internal (size position pointer)
  (declare lt:(side-effects reader)
	   (compiler:return-type integer))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (unless (<= (+ size position) (+ (byte-size %%q-pointer) (byte-size %%q-all-but-pointer)))
    (error "Specified byte is outside the range of a Q."))
  (multiple-value-bind (low high)
      (without-interrupts
	(values (%p-ldb %%q-pointer pointer)
		(%p-ldb %%q-all-but-pointer pointer)))
    (cond (( (+ position size) (byte-size %%q-pointer))	;All in the low
	   (ldb (byte size position) low))
	  (( position (byte-size %%q-pointer))	;All in the high
	   (ldb (byte size (- position (byte-size %%q-pointer))) high))
	  (t
	   (let ((diff (- (byte-size %%q-pointer) position)))
	     (if (<= size 32)
		 (%logdpb high
			  (byte (- size diff) diff)
			  (ldb (byte diff position) low))
		 (dpb high
		      (byte (- size diff) diff)
		      (ldb (byte diff position) low))))))))

(defun %p-deposit-byte-internal (byte-value size position pointer)
  (declare (compiler:return-type))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (unless (<= (+ size position) (+ (byte-size %%q-pointer) (byte-size %%q-all-but-pointer)))
    (error "Specified byte is outside the range of a Q."))
  (multiple-value-bind (low high)
      (without-interrupts
	(values (%p-ldb %%q-pointer pointer)
		(%p-ldb %%q-all-but-pointer pointer)))
    (cond (( (+ position size) (byte-size %%q-pointer))	;All in the low
	   (%p-dpb (%logdpb byte-value (byte size position) low) %%q-pointer pointer))
	  (( position (byte-size %%q-pointer))	;All in the high
	   (%p-dpb (%logdpb byte-value (byte size (- position (byte-size %%q-pointer))) high)
		   %%q-all-but-pointer pointer))
	  (t
	   (let ((diff (- (byte-size %%q-pointer) position)))
	     (%p-dpb (%logdpb byte-value (byte diff position) low) %%q-pointer pointer)
	     (%p-dpb (%logdpb (ldb (byte (- size diff) diff) byte-value)
			      (byte (- size diff) 0)
			      high)
		     %%q-all-but-pointer pointer)))))
  nil)

(defun char-load-byte-internal (size position from-char)
  (declare (compiler:return-type fixnum))
  (declare lt:(side-effects simple))		;not REDUCIBLE!
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (unless (<= (+ size position) (byte-size %%q-pointer))
    (error "Specified byte is outside the range of a character."))
  (check-type from-char character)
  (ldb (byte size position) (%pointer from-char)))

#+3600
(proclaim '(inline char-deposit-byte-internal))

(defun char-deposit-byte-internal (byte-value size position into-char)
  (declare (compiler:return-type character))
  (declare lt:(side-effects simple))		;not REDUCIBLE!
  (%make-pointer dtp-character (%logdpb byte-value (byte size position)
				    (char-ldb-internal %%q-pointer into-char))))

;;; Now learn about byte specifiers.
;;; This is the only code in the system which knows their format.

(defstruct long-byte-specifier size position)

(defun byte-size-and-position (byte-specifier)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type (values integer integer)))
  (etypecase byte-specifier
    (fixnum
      (values (ldb %%byte-spec-size byte-specifier)
	      (ldb %%byte-spec-position byte-specifier)))
    (long-byte-specifier
      (values (long-byte-specifier-size byte-specifier)
	      (long-byte-specifier-position byte-specifier)))))

(defun byte-position (bytespec)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type integer))
  (multiple-value-bind (ignore position) (byte-size-and-position bytespec)
    position))

(defun byte-size (bytespec)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type integer))
  (multiple-value-bind (size ignore) (byte-size-and-position bytespec)
    size))

(defun byte (size position)
  (declare lt:(side-effects simple reducible))
  (check-type size (integer 0 *))
  (check-type position (integer 0 *))
  (if (and (< size (ash 1 (byte-size %%byte-spec-size)))
	   (< position (ash 1 (byte-size %%byte-spec-position))))
      (dpb position %%byte-spec-position size)
      (make-long-byte-specifier :size size :position position)))

;;; Now the functions that take byte specifiers.  These are defined in term of the ones above.

(defun ldb (bytespec integer)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type integer))
  (multiple-value-bind (size position) (byte-size-and-position bytespec)
    (load-byte-internal size position integer)))

;;; The only tricky (and fast) case is fixnum-fixnum.  Other things call
;;; out to bignum code.  In the fixnum-fixnum case, if the final
;;; resulting width [position+size] is potentially longer than a word
;;; (32 bits) then callout to the bignum code to handle it.  Else, do a
;;; "DPB" using boolean arithmetic ignoring the sign of the result.  Ths
;;; sign of the result must be the same as the sign of INTEGER.  If the
;;; intermediate answer isn't, cons a bignum, which can be done quickly
;;; using ADDITIVE-FIXNUM-OVERFLOW.
(defun dpb (newbyte bytespec integer)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type integer))
  (multiple-value-bind (size position) (byte-size-and-position bytespec)
    (deposit-byte-internal newbyte size position integer)))

#||  ;; test routine for DPB
(defun test-dpb (test-function)
  "E.g., (test-dpb #'ndpb)"
  (let ((generic-function #'(lambda (value ppss word)
			      (let* ((width (ldb %%byte-spec-size ppss))
				     (position (ldb %%byte-spec-position ppss))
				     (mask (1- (ash 1 width))))
				(logior (boole 4 word (ash mask position))
					(ash (logand value mask) position)))))
	(integers '(0 1 7 -1 #o200 #o377 #o111111 -2 -7 -8
		      #,si:*setz* #,(lsh -1 -1)
		      1_60. 1_61. 1_62. 1_63.
		      -1_60. -1_61. -1_62. -1_63.
		      #,(1- 1_60.) #,(1- 1_61.) #,(1- 1_62.) #,(1- 1_63.) 
		      #,(1- -1_60.) #,(1- -1_61.) #,(1- -1_62.) #,(1- -1_63.)))
	(byte-components '(0 1 8 16. 24. 31. 32. 60. 61. 62. 63.
			     ;64.
			     )))
		      
    (format t "~&Running ~D. tests...~%"
	    (* (length integers)
	       (length byte-components)
	       (length byte-components)
	       (length integers)))

    (loop for value in integers do
      (loop for size in byte-components do
        (loop for position in byte-components do
	  (loop for word in integers
		as generic-answer = (funcall generic-function value (byte size position) word)
		as test-answer    = (funcall test-function    value (byte size position) word)
		when ( generic-answer test-answer)
		do (format t "~%Differing answers for 'dpb'ing ~O into (BYTE ~O ~O) of ~O;~@
			        generic answer is ~O, test answer is ~O~%"
			   value size position word
			   generic-answer test-answer)))))))
||#

(defun %logldb (bytespec integer)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type fixnum))
  (multiple-value-bind (size position) (byte-size-and-position bytespec)
    (fixnum-load-byte-internal size position integer)))

(defun %logdpb (newbyte bytespec integer)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type fixnum))
  (multiple-value-bind (size position) (byte-size-and-position bytespec)
    (fixnum-deposit-byte-internal newbyte size position integer)))

;;; All recursive calls in the next two functions should have immediate byte pointer operands
(defun %p-ldb (bytespec pointer)
  (multiple-value-bind (size position) (byte-size-and-position bytespec)
    (%p-load-byte-internal size position pointer)))

(defun %p-dpb (newbyte bytespec pointer)
  (declare (compiler:return-type))
  (multiple-value-bind (size position) (byte-size-and-position bytespec)
    (%p-deposit-byte-internal newbyte size position pointer))
  nil)

;;; This is actually done by microcode for the case where the PPSS is a constant.
;;; This version has to be kept around for the other cases, however.
(defun char-ldb-internal (ppss char)
  (declare (compiler:return-type fixnum))
  (declare lt:(side-effects simple))		;not REDUCIBLE!
  (multiple-value-bind (size position) (byte-size-and-position ppss)
    (char-load-byte-internal size position char)))

(defun char-dpb-internal (value ppss char)
  (declare (compiler:return-type character))
  (declare lt:(side-effects simple))		;not REDUCIBLE!
  (multiple-value-bind (size position) (byte-size-and-position ppss)
    (check-type size (integer 0 *))
    (check-type position (integer 0 *))
    (unless (<= (+ size position) (byte-size %%q-pointer))
      (error "Specified byte is outside the range of a character."))
    (check-type char character)
    (char-deposit-byte-internal value size position char)))

;; Miscellaneous CL stuff.

(defsubst load-byte (from-value position size)
  (declare lt:(side-effects simple reducible))
  (ldb (byte size position) from-value))

(defsubst deposit-byte (into-value position size byte-value)
  (declare lt:(side-effects simple reducible))
  (dpb byte-value (byte size position) into-value))

(defsubst mask-field (bytespec integer)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type integer))
  (logand (dpb -1 bytespec 0) integer))

(defun deposit-field (newbyte bytespec integer)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:return-type integer))
  (let ((mask (dpb -1 bytespec 0)))
    (logior (boole boole-andc2 integer mask)
	    (logand newbyte mask))))

;;;

#+Imach (proclaim '(inline sign-extend-16 sign-extend-8))

(defun sign-extend-16 (n)
  (dpb n (byte 15 0) (- (ldb (byte 1 15) n))))

(defun sign-extend-8 (n)
  (dpb n (byte 7 0) (- (ldb (byte 1 7) n))))

;;; We assume that storing the long form will truncate, not error.
(define-setf-method sign-extend-8 (ref)
  (let ((store (gensym)))
    (values nil nil (list store) `(setf ,ref ,store) ref)))

(define-setf-method sign-extend-16 (ref)
  (let ((store (gensym)))
    (values nil nil (list store) `(setf ,ref ,store) ref)))

;;; Supply array-register nil if only one call (really only useful for
;;; building callable versions below).
(defmacro with-bit-reversing-1 ((&key (array-register t)) &body body)
  (let* ((8-reverse '#.(let ((value (make-array 256 :element-type '(unsigned-byte 8))))
			 #+ignore	;bootstrapping version
			 (let ((4-reverse (make-array 16 :element-type '(unsigned-byte 4)
					    :initial-contents #b'(0000 1000 0100 1100
								  0010 1010 0110 1110
								  0001 1001 0101 1101
								  0011 1011 0111 1111))))
			   (dotimes (i 256)
			     (dpb (aref 4-reverse (ldb (byte 4 0) i)) (byte 4 4)
				  (aref 4-reverse (ldb (byte 4 4) i)))))
			 #-ignore
			 (dotimes (i 256)
			   (setf (aref value i) (bit-reverse-8 i)))
			 value))
	 ;; I'd prefer to use FLET with INLINE, but that doesn't work in our compiler.
	 (macros `((bit-reverse-2 (int2)
		     `(bit-reverse-8 (dpb ,int2 (byte 2 6) 0)))
		   (bit-reverse-4 (int4)
		     `(bit-reverse-8 (dpb ,int4 (byte 4 4) 0)))
		   (bit-reverse-8 (int8)
		     `(aref ,',(if array-register '.8-reverse. `',8-reverse) ,int8))
		   (bit-reverse-16 (int16 &environment env)
		     (once-only (int16 &environment env)
		       `(dpb (bit-reverse-8 (ldb (byte 8 0) ,int16)) (byte 8 8)
			     (bit-reverse-8 (ldb (byte 8 8) ,int16)))))
		   (bit-reverse-32 (int32 &environment env)
		     (once-only (int32 &environment env)
		       `(%logdpbs (bit-reverse-8 (ldb (byte 8 0) ,int32)) (byte 8 24)
				  (bit-reverse-8 (ldb (byte 8 8) ,int32)) (byte 8 16)
				  (bit-reverse-8 (ldb (byte 8 16) ,int32)) (byte 8 8)
				  (bit-reverse-8 (ldb (byte 8 24) ,int32))))))))
    (if (not array-register)
	`(macrolet ,macros . ,body)
	`(let ((.8-reverse. ',8-reverse))
	   (declare (array-register .8-reverse.))
	   (macrolet ,macros
	     . ,body)))))

(defmacro with-bit-reversing (&body body)
  `(with-bit-reversing-1 () . ,body))

(defsubst bit-reverse-2 (int2)
  (with-bit-reversing-1 (:array-register nil)
    (bit-reverse-2 int2)))
(proclaim '(notinline bit-reverse-2))		;Allow inline, but not by default

(defsubst bit-reverse-4 (int4)
  (with-bit-reversing-1 (:array-register nil)
    (bit-reverse-4 int4)))
(proclaim '(notinline bit-reverse-4))

(defsubst bit-reverse-8 (int8)
  (with-bit-reversing-1 (:array-register nil)
    (bit-reverse-8 int8)))
(proclaim '(notinline bit-reverse-8))

(defsubst bit-reverse-16 (int16)
  (with-bit-reversing
    (bit-reverse-16 int16)))
(proclaim '(notinline bit-reverse-16))

(defsubst bit-reverse-32 (int32)
  (with-bit-reversing
    (bit-reverse-32 int32)))
(proclaim '(notinline bit-reverse-32))

;;;

;;; Common Lisp arithmetic comparisons are not quite the same as the Zetalisp ones

(compiler:define-comparison-operation =
  (lambda (x y) `(internal-= ,x ,y)))
(compiler:define-not-equal-operation /=
  (lambda (x y) `(not (internal-= ,x ,y))))

(compiler:define-comparison-operation <
  (lambda (x y) `(internal-< ,x ,y)))
(compiler:define-comparison-operation >
  (lambda (x y) `(internal-> ,x ,y)))
(compiler:define-comparison-operation <=
  (lambda (x y) `(not (internal-> ,x ,y))))
(compiler:define-comparison-operation >=
  (lambda (x y) `(not (internal-< ,x ,y))))

;;;Do list chapter before sequence chapter, because lists are more fundamental
;;;than sequences, and also, I want new stack hacking for sequences.

;;; Chapter 14

#+IMACH
;;; Clobbers block register 1.
(defwiredfun length (sequence)
  (declare lt:(side-effects reader reducible))
  (declare (sys:unsafeguarded-reference dbg:check-type-1 sequence))
  (declare (compiler:return-type (cl:integer 0 #.cl:most-positive-fixnum)))
  (loop
    ;; If this typecase falls through, the argument isn't a sequence.
    (typecase sequence
      ;; the ordering of these cases was chosen by looking at the Gabriel benchmarks
      (cons
	(let ((list sequence) (n 1))
	  (loop
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length n))		;Loop unrolled eight times
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 1)))
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 2)))
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 3)))
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 4)))
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 5)))
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 6)))
	    (compiler:%error-when (endp (setq list (cdr list)))
	      (return-from length (+ n 7)))
	    (setq n (+ n 8)))))
      (null (return-from length 0))
      (array
	(with-block-registers (1)
	  ;; Use block register 1 to read the header using the appropriate cycle type.
	  ;; Afterward, we can address other words of the array header relative to it,
	  ;; since it follows any forwarding pointers.
	  (setf (%block-register 1) sequence)
	  (let ((header (%set-tag (%block-read 1 :cycle-type %memory-header) dtp-fixnum)))
	    ;; First do a quick check for a short prefix array with leader-length 0,
	    ;; returning the short array length field in the header in this common case.
	    (cond ((not (ldb-test (byte 9 15.) header))
		   (return-from length (ldb array-short-length-field header)))
		  ((not (ldb-test array-long-prefix-bit header))
		   ;; It's a short-prefix array with a leader.  If the first leader element
		   ;; is a fixnum, it's a fill-pointer, otherwise return the length.
		   (let ((fill-pointer
			   (%memory-read
			     ;; Block register has advanced to one past the header.
			     (%pointer-plus (%block-register 1) -2))))
		     (return-from length
		       (if (typep fill-pointer 'fixnum)
			   fill-pointer
			 (ldb array-short-length-field header)))))
		  ;; Now we know it's a long-prefix array, possibly with a leader.  However,
		  ;; it must be one-dimensional, so check that here.
		  ((= (ldb array-long-dimensions-field header) 1)
		   ;; If it has a leader and the first element is a fill-pointer, return that.
		   (when (ldb-test array-leader-length-field header)
		     (let ((fill-pointer
			     ;; Block register has advanced to one past the header.
			     (%memory-read
			       (%pointer-plus (%block-register 1) -2))))
		       (when (typep fill-pointer 'fixnum)
			 (return-from length fill-pointer))))
		   ;; Otherwise return the long length, conveniently located in the next word.
		   (return-from length
		     (%block-read 1 :fixnum-only t :prefetch nil))))))))
    ;; Nothing claimed it, so it wasn't a sequence.
    (setq sequence (dbg:check-type-1 'sequence sequence 'sequence))))

;;; Chapter 15

;;; Chapter 16

;;; Chapter 17

(defun array-dimension (array axis-number)
  (declare lt:(side-effects simple reducible))
  (zl:array-dimension-n (1+ axis-number) array))

;;; Chapter 18

;; - element-type must be NIL (unspecified) or a subtype of CHARACTER.
;; - initial-element must NIL (unspecified) or of type element-type (which
;;   implies it is at most of type CHARACTER). 
;; - If element-type is unspecified, then the array type is based on the
;;   initial-element.  If the initial-element is unspecified or a
;;   STRING-CHAR, a thin string is made.  Else (which means
;;   initial-element is larger than STRING-CHAR but at most CHARACTER) a
;;   fat string is made.
;; - If element-type is a subtype of STRING-CHAR, then a thin string is
;;   made, else a fat string is made.
(defun make-string (size &key initial-element element-type area)
  (declare lt:(side-effects reader))
  (let ((zl-make-array-type
	  (case element-type
	    ((nil)
	     ;; element type based on character
	     (ctypecase initial-element
	       ((or null string-char) sys:art-string)
	       (character sys:art-fat-string)))
	    ;; special case string-char and character to avoid diving into the entire type system.
	    (character
	      (check-type initial-element (or null character))
	      sys:art-fat-string)
	    (string-char
	      (check-type initial-element (or null string-char))
	      sys:art-string)
	    (otherwise
	      (assert (subtypep element-type 'character)
		      (element-type)
		      "The element-type, ~S, is not a subtype of CHARACTER."
		      element-type)
	      (assert (or (null initial-element) (typep initial-element element-type))
		      (initial-element)
		      "The initial-element, ~S, is neither NIL nor of type ~S"
		      initial-element element-type)
	      (if (subtypep element-type 'string-char)
		  sys:art-string
		  sys:art-fat-string)))))
    (values (zl:make-array size :type zl-make-array-type
			   :initial-value initial-element :area area))))

;;; Chapter 20

;;Not necessarily self-evaluating.  Just guaranteed always to evaluate to the same thing.
(defun constantp (form &optional env)
  (declare lt:(side-effects simple reducible))
  (setf form
	(if (fboundp 'compiler:optimize-form)
	    (compiler:optimize-form
	      form env
	      :repeat t :do-macro-expansion t :do-named-constants t :do-constant-folding t
	      :do-function-args t :do-optimizers t :do-inline-forms t)
	    (macroexpand form env)))
  (if (atom form)
      (or (not (symbolp form))
	  (compiler:self-evaluating-symbol-p form)
	  (lt:named-constant-p form env))
      (case (car form)
	((quote) t)
	((values)
	 (every #'(lambda (x) (constantp x env)) (cdr form))))))

;; This must agree with constantp
(defun lt:evaluate-constant (form &optional env)
  (setf form
	(if (fboundp 'compiler:optimize-form)
	    (compiler:optimize-form
	      form env
	      :repeat t :do-macro-expansion t :do-named-constants t :do-constant-folding t
	      :do-function-args t :do-optimizers t :do-inline-forms t)
	    (macroexpand form env)))
  (if (atom form)
      (cond ((not (symbolp form))
	     form)
	    ((compiler:self-evaluating-symbol-p form)
	     form)
	    (t
	     (multiple-value-bind (constant-p value)
		 (lt:named-constant-p form env)
	       (if constant-p
		   value
		   (error "Symbol ~S does not have a value." form)))))
      (case (first form)
	(quote
	  (second form))
	(values
	  (apply #'values		 
		 (loop for value in (cdr form)
		       collect (lt:evaluate-constant value env))))
	(otherwise
	  (error "Constant evaluator called on ~S" form)))))

;;; Chapter 25

(proclaim '(inline identity))
(defun identity (object)
  (declare (side-effects simple reducible))
  object)

;;; SCL function things

(defvar *proclaim-fspec-properties* '(INLINE FTYPE FUNCTION) "Function spec properties
that represent CL PROCLAIM's")

(defun remove-proclaims (fspec)
  (loop for prop in *proclaim-fspec-properties*
	    do (si:function-spec-remprop fspec prop)))

(defun print-function-proclaims (function &key (stream *standard-output*))
  (let ((plist (si:function-spec-plist function)))
    (when (or (getf plist 'inline) (getf plist 'ftype) (getf plist 'function))
      (format stream "~&Proclaimed properties:")
      (when (eq (getf plist 'inline) 'inline)
	(format stream "~&  INLINE"))
      (when (eq (getf plist 'inline) 'notinline)
	(format stream "~&  NOTINLINE"))
      (when (getf plist 'ftype)
	(format stream "~&  FTYPE        ~S" (getf plist 'ftype)))
      (when (getf plist 'function)
	(format stream "~&  FUNCTION     ~S" (getf plist 'function))))))


(defun print-debugging-info (function &key (stream *standard-output*) (internal nil))
  (format stream "~&Debugging info:")
  (let ((*print-pretty* t)
	(*print-array* t))
    (loop for (indicator . info) in (debugging-info function)
	  do
      (case indicator
	(si:encapsulated-definition
	  (when internal
	    (format stream "~&  ~S ~S" 'si:encapsulated-definition info)))
	(si:renamings
	  (when internal
	    (format stream "~&  ~S" 'si:renamings)
	    (loop for (renamed renamed-to) in info
		  do (format stream "~&    ~A~40Tto ~A" renamed renamed-to))))
	(arglist
	  (format stream "~&  ~S ~A" 'arglist info))
	(values
	  (format stream "~&  ~S ~A" 'values info))
	#+IMach
	(:variable-creation-alist
	  (when internal
	    (format stream "~&  ~S ~S" ':variable-creation-alist info)))
	#+3600
	(:local-map
	  (when internal
	    (format stream "~&  ~S ~S" ':local-map info)))
	(sys:function-parent
	  (format stream "~&  ~S ~A" 'sys:function-parent info))
	#+IMach
	(:internal-functions
	  (when internal
	    (format stream "~&  ~S~{~%     ~S~}" ':internal-functions info)))
	#+3600
	(:internal-function-offsets
	  (when internal
	    (format stream "~&  ~S ~{~O ~}" ':internal-function-offsets info)))))))

(defun describe-function (fspec &key (stream *standard-output*))
  (assert (fdefinedp fspec) (fspec)
	  "Function spec ~S does not describe a defined function.")
  (print-debugging-info fspec :stream stream)
  (print-function-proclaims fspec :stream stream))
