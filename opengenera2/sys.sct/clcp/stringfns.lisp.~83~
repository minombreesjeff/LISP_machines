;;; -*- Mode: Lisp; Package: Common-lisp-internals; Lowercase: T; Syntax: Common-Lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; String functions, Chapter 17.

;;; char is linked to aref.

;;; This macro defines a Lisp function that has some required arguments followed
;;; by some keyword arguments.  It also defines a version of the function, whose
;;; name has -internal appended to it, which has the same required arguments but
;;; takes the rest of the arguments as optional arguments.  It defines a compiler
;;; optimizer that converts a call to the former into a call to the latter, if it
;;; is easy to do so, namely, if the keywords are given only strictly in order.
;;; "requireds" is a list of the required arguments.  "keywords" is a list of two-
;;; element lists: the keyword and the default form.  All default forms must be
;;; evaluable from Lisp top level (they can't depend on other arguments).  This
;;; macro must only be used in CL files!

(eval-when (compile load eval)
(defparameter *string-macro-package* *package*)
)

(defmacro define-optimized-keyword-function (name requireds keywords &body body)
  (let ((keyword-symbols (loop for (k) in keywords collect k))
	(name-internal (intern (string-append name "-INTERNAL") *string-macro-package*)))
    (multiple-value-bind (declarations real-body)
	(si:find-body-declarations body nil requireds)
      `(progn
	 (record-source-file-name ',name  'define-optimized-keyword-function)
	 (defun ,name (,@requireds &key . ,keywords)
	   ,@declarations
	   (declare (sys:function-parent ,name define-optimized-keyword-function))
	   (,name-internal ,@requireds . ,keyword-symbols))
	 (defun ,name-internal (,@requireds . ,keyword-symbols)
	   ,@declarations
	   (declare (sys:function-parent ,name define-optimized-keyword-function))
	   ,@real-body)
	 (compiler:add-optimizer ,name keyword-function-optimizer)
	 (setf (get ',name 'keyword-function-optimizer-arg)
	       '(,name-internal
		 ,requireds
		 ,(loop for (k init) in keywords
			collect
			  (list
			    (intern (string k) si:pkg-keyword-package)	;intern only
						;takes strings
			    init))))))))

(eval-when (compile load eval)
(defun keyword-function-optimizer (form)
  (destructuring-bind (name-internal requireds keywords)
		      (get (car form) 'keyword-function-optimizer-arg)
    (let* ((n-req (list-length requireds))
	   (nk (- (list-length form) n-req 1))
	   (kvlist (nthcdr (+ 1 n-req) form)))
      (cond ((or (minusp nk) (oddp nk))
	     ;; If some required args missing, or not an even number of k/v pairs, no luck.
	     form)
	    ((loop named outer
		   with p = keywords
		   for k in kvlist by 'cddr do
		   (when (and (listp k) (eq (car k) 'quote))
		     (setq k (cadr k)))
		   (loop when (null p) do (return-from outer nil)
			 until (eq k (caar p))
			 do (pop p))
		   finally (return t))
	     ;; Keywords are all in right order.
	     `(,name-internal
	       ,@(loop for r in (cdr form) repeat n-req collect r)
	       .,(loop for (keyword init) in keywords collect
		       (loop for (k value) on kvlist by 'cddr do
			     (when (and (listp k) (eq (car k) 'quote))
			       (setq k (cadr k)))
			     (when (eq k keyword)
			       (return value))
			     finally (return init)))))
	    (t form)))))
);end of eval-when

;;; (Copied from the SI version.)
(defmacro coerce-string-arg (arg-name &optional destructive)
  `(si:coerce-string-arg ,arg-name ,destructive))

(define-optimized-keyword-function string=
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (cond ((or end1 end2)
	 (unless end1 (setq end1 (zl:array-active-length string1)))
	 (unless end2 (setq end2 (zl:array-active-length string2)))
	 (and (= (setq end1 (- end1 start1)) (- end2 start2))
	      (sys:%string= string1 start1 string2 start2 end1)))
	(t (sys:%string= string1 start1 string2 start2 nil))))

(define-optimized-keyword-function string-equal
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (cond ((or end1 end2)
	 (unless end1 (setq end1 (zl:array-active-length string1)))
	 (unless end2 (setq end2 (zl:array-active-length string2)))
	 (and (= (setq end1 (- end1 start1)) (- end2 start2))
	      (sys:%string-equal string1 start1 string2 start2 end1)))
	(t (sys:%string-equal string1 start1 string2 start2 nil))))

;;; %string-compare returns 0 if strings are the same, positive if
;;; the first is greater, and negative if the first is less.  Abs value
;;; is one greater than the place where they differ.  Macrocode must
;;; compensate by subtracting 1; it must also compensate because the number
;;; is relative to the start position, whereas CL is absolute in terms of
;;; string1.

(defmacro define-optimized-string-function (case-name no-case-name requireds keywords
					    &body body)
  (multiple-value-bind (declarations real-body)
      (si:find-body-declarations body nil requireds)
    `(progn
       (define-optimized-keyword-function ,case-name ,requireds ,keywords
	 ,@declarations
	 (declare (sys:function-parent ,case-name define-optimized-string-function))
	 (macrolet ((%string-compare-1 (&rest args)
                      `(sys:%string-exact-compare ,@args)))
	   ,@real-body))
       (define-optimized-keyword-function ,no-case-name ,requireds ,keywords
	 ,@declarations
	 (declare (sys:function-parent ,case-name define-optimized-string-function))
	 (macrolet ((%string-compare-1 (&rest args)
                      `(sys:%string-compare ,@args)))
	   ,@real-body)))))

(define-optimized-string-function string< string-lessp
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (cond ((or end1 end2)
	 (unless end1 (setq end1 (zl:array-active-length string1)))
	 (unless end2 (setq end2 (zl:array-active-length string2)))
	 (let* ((len2 (- end2 start2))
		(len1 (- end1 start1))
		(result (%string-compare-1 string1 start1 string2 start2 (min len1 len2))))
	   (if (zerop result)
	       (when (< len1 len2) end1)
	       (when (minusp result) (1- (- start1 result))))))
	(t (let ((result (%string-compare-1 string1 start1 string2 start2 nil)))
	     (when (minusp result) (1- (- start1 result)))))))

(define-optimized-string-function string> string-greaterp
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (cond ((or end1 end2)
	 (unless end1 (setq end1 (zl:array-active-length string1)))
	 (unless end2 (setq end2 (zl:array-active-length string2)))
	 (let* ((len2 (- end2 start2))
		(len1 (- end1 start1))
		(result (%string-compare-1 string1 start1 string2 start2 (min len1 len2))))
	   (if (zerop result)
	       (when (> len1 len2) (+ start1 len2))
	       (when (plusp result) (1- (+ start1 result))))))
	(t (let ((result (%string-compare-1 string1 start1 string2 start2 nil)))
	     (when (plusp result) (1- (+ start1 result)))))))

(define-optimized-string-function string<= string-not-greaterp
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (cond ((or end1 end2)
	 (unless end1 (setq end1 (zl:array-active-length string1)))
	 (unless end2 (setq end2 (zl:array-active-length string2)))
	 (let* ((len2 (- end2 start2))
		(len1 (- end1 start1))
		(result (%string-compare-1 string1 start1 string2 start2 (min len1 len2))))
	   (if (zerop result)
	       (when (<= len1 len2) end1)
	       (when (minusp result) (1- (- start1 result))))))
	(t (let ((result (%string-compare-1 string1 start1 string2 start2 nil)))
	     (cond ((zerop result)
		    (zl:array-active-length string1))
		   ((minusp result)
		    (1- (- start1 result))))))))

(define-optimized-string-function string>= string-not-lessp
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (cond ((or end1 end2)
	 (unless end1 (setq end1 (zl:array-active-length string1)))
	 (unless end2 (setq end2 (zl:array-active-length string2)))
	 (let* ((len2 (- end2 start2))
		(len1 (- end1 start1))
		(result (%string-compare-1 string1 start1 string2 start2 (min len1 len2))))
	   (if (zerop result)
	       (when (>= len1 len2) (+ start1 len2))
	       (when (plusp result) (1- (+ start1 result))))))
	(t (let ((result (%string-compare-1 string1 start1 string2 start2 nil)))
	     (cond ((zerop result)
		    (zl:array-active-length string1))
		   ((plusp result)
		    (1- (+ start1 result))))))))

(define-optimized-string-function string/= string-not-equal
	(string1 string2) ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (unless end1 (setq end1 (zl:array-active-length string1)))	;we always need the end values
  (unless end2 (setq end2 (zl:array-active-length string2)))
  (let* ((len2 (- end2 start2))
	 (len1 (- end1 start1))
	 (result (%string-compare-1 string1 start1 string2 start2 (min len1 len2))))
    (cond ((zerop result)
	   (when ( len1 len2) (min len1 len2)))
	  ((minusp result)
	   ;; result is biased by 1 and relative, make it absolute in string1
	   (+ start1 (1- (- result))))
	  (t
	   ;; result is biased by 1 and relative, make it absolute in string1
	   (+ start1 (1- result))))))

(compiler:define-synonym-function string string/=)
(compiler:define-synonym-function string string<=)
(compiler:define-synonym-function string string>=)

(define-optimized-keyword-function string-upcase (string) ((start 0) (end nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (nstring-upcase (string-append string) :start start :end end))

(define-optimized-keyword-function string-downcase (string) ((start 0) (end nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (nstring-downcase (string-append string) :start start :end end))

(define-optimized-keyword-function string-flipcase (string) ((start 0) (end nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (nstring-flipcase (string-append string) :start start :end end))

(define-optimized-keyword-function string-capitalize (string) ((start 0) (end nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (let ((copied-string (string-append string))
	(state nil))
    (loop for i from start below (or end (zl:array-active-length string)) do
	  (let* ((char (aref copied-string i)))
	    (cond ((null state)			;Between words
		   (cond ((alpha-char-p char)
			  (setf (aref copied-string i) (char-upcase char))
			  (setq state t))
			 ((digit-char-p char)
			  (setq state t))))
		  (t				;Inside a word
		   (cond ((alpha-char-p char)
			  (setf (aref copied-string i) (char-downcase char)))
			 ((not (digit-char-p char))
			  (setq state nil)))))))
    copied-string))

(define-optimized-keyword-function nstring-upcase (string) ((start 0) (end nil))
  (coerce-string-arg string t)
  (zl:string-upcase string start end nil)
  string)

(define-optimized-keyword-function nstring-downcase (string) ((start 0) (end nil))
  (coerce-string-arg string t)
  (zl:string-downcase string start end nil)
  string)

(define-optimized-keyword-function nstring-flipcase (string) ((start 0) (end nil))
  (coerce-string-arg string t)
  (zl:string-flipcase string start end nil)
  string)

(define-optimized-keyword-function nstring-capitalize (string) ((start 0) (end nil))
  (coerce-string-arg string t)
  (let ((state nil))
    (loop for i from start below (or end (zl:array-active-length string)) do
	  (let* ((char (aref string i)))
	    (cond ((null state)			;Between words
		   (cond ((alpha-char-p char)
			  (setf (aref string i) (char-upcase char))
			  (setq state t))
			 ((digit-char-p char)
			  (setq state t))))
		  (t				;Inside a word
		   (cond ((alpha-char-p char)
			  (setf (aref string i) (char-downcase char)))
			 ((not (digit-char-p char))
			  (setq state nil)))))))
    string))

;;; The capitalize-words functions are like the old ZL versions, but with keyword
;;; arguments to be consistent with CL.  They differ from the CL capitalize functions
;;; in that only space and hyphen are delimiters (not apostrophe, for example),
;;; and they convert hyphens into spaces.

(define-optimized-keyword-function string-capitalize-words (string) ((start 0) (end nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (let ((copied-string (string-append string)))
    (nstring-capitalize-words copied-string :start start :end end)
    copied-string))

(define-optimized-keyword-function nstring-capitalize-words (string) ((start 0) (end nil))
  (coerce-string-arg string t)
  (let ((state t))
    (loop for i from start below (or end (zl:array-active-length string)) do
	  (let* ((char (aref string i)))
	    (cond ((char-equal char #\-)
		   (setf (aref string i) #\space)
		   (setq state t))
		  ((char-equal char #\space)
		   (setq state t))
		  (state
		   (when (alpha-char-p char)
		     (setf (aref string i) (char-upcase char)))
		   (setq state nil))
		  ((alpha-char-p char)
		   (setf (aref string i) (char-downcase char))))))
    string))

;;; This differs from the ZL version because it takes keyword arguments, and
;;; because it returns its answer in "absolute" form (if start1 is non-zero).
(define-optimized-keyword-function string-compare
	(string1 string2) ((start1 0) (start2 0) (end1 nil) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (unless end1 (setq end1 (zl:array-active-length string1)))
  (unless end2 (setq end2 (zl:array-active-length string2)))
  (let* ((len2 (- end2 start2))
	 (len1 (- end1 start1))
	 (result (sys:%string-compare string1 start1 string2 start2 (min len1 len2))))
    (cond ((zerop result)
	   ;; common portion is the same, answer based on who is longer
	   ;; but in either case the answer is relative to the start of string1
	   (cond ((= len1 len2) 0)
		 ((> len1 len2) (+ (+ end2 1) (- start1 start2)))
		 (t          (- (+ end1 1)))))
	  ;; not the same, but sys:%string-compare is relative to start1
	  ((plusp result) (+ start1 result))
	  (t		  (- result start1)))))

(define-optimized-keyword-function string-exact-compare
	(string1 string2) ((start1 0) (start2 0) (end1 nil) (end2 nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string1)
  (coerce-string-arg string2)
  (unless end1 (setq end1 (zl:array-active-length string1)))
  (unless end2 (setq end2 (zl:array-active-length string2)))
  (let* ((len2 (- end2 start2))
	 (len1 (- end1 start1))
	 (result (sys:%string-exact-compare string1 start1 string2 start2 (min len1 len2))))
    (cond ((zerop result)
	   ;; common portion is the same, answer based on who is longer
	   ;; but in either case the answer is relative to the start of string1
	   (cond ((= len1 len2) 0)
		 ((> len1 len2) (+ (+ end2 1) (- start1 start2)))
		 (t	     (- (+ end1 1)))))
	  ;; not the same, but sys:%string-exact-compare is relative to start1
	  ((plusp result) (+ start1 result))
	  (t		  (- result start1)))))

(define-optimized-keyword-function string-reverse (string) ((start 0) (end nil))
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (string-nreverse (string-append string) :start start :end end))

(define-optimized-keyword-function string-nreverse (string) ((start 0) (end nil))
  (coerce-string-arg string t)
  (loop for i from start
	for j downfrom (1- (or end (zl:array-active-length string)))
	until ( j i)
	  do (rotatef (aref string j) (aref string i)))
  string)

;;; New string search functions that take keyword arguments.  NOTE that the
;;; reverse searches expect end>start, unlike the old ZL functions which
;;; expected to<from!!

;;; Highly-specialized macro for defining search functions.  Each search
;;; function has an extra keyword argument: from-end.  This
;;; macro generates three functions.  One only searches forward, and
;;; takes the other keywords as optional arguments.  One is similar but
;;; only searches backwards.  One is the user-visible function, which
;;; takes all keyword arguments as keywords, and calls one of the other
;;; two functions to do the actual work.

(defmacro define-string-search-function (name requireds keywords forward-body backward-body)
  (let ((keyword-symbols (loop for (k) in keywords collect k))
	(forward-name (intern (string-append name "-FORWARD") *string-macro-package*))
	(backward-name (intern (string-append name "-BACKWARD") *string-macro-package*)))
    `(progn
       (defun ,name (,@requireds &key from-end . ,keywords)
	 (declare lt:(side-effects reader reducible)
		  (sys:function-parent ,name define-string-search-function))
	 (if from-end
	     (,backward-name ,@requireds . ,keyword-symbols)
	     (,forward-name ,@requireds . ,keyword-symbols)))
       (defun ,forward-name (,@requireds &optional . ,keyword-symbols)
	 (declare lt:(side-effects reader reducible)
		  (sys:function-parent ,name define-string-search-function))
	 ,forward-body)
       (defun ,backward-name (,@requireds &optional . ,keyword-symbols)
	 (declare lt:(side-effects reader reducible)
		  (sys:function-parent ,name define-string-search-function))
	 ,backward-body)
       (compiler:add-optimizer ,name string-search-function-optimizer)
       (setf (get ',name 'string-search-function-optimizer-arg)
	     '(,forward-name
	       ,backward-name
	       ,requireds
	       ,(loop for (k init) in keywords
		      collect
			(list
			  (intern (string k) si:pkg-keyword-package)
			  init))))
       )))

(defun string-search-function-optimizer (form)
  (destructuring-bind (forward-name backward-name requireds keywords)
		      (get (car form) 'string-search-function-optimizer-arg)
    (let* ((n-req (list-length requireds))
	   (nk (- (list-length form) n-req 1))
	   (kvlist (nthcdr (+ 1 n-req) form))
	   (from-end (string-search-check-from-end kvlist)))
      (cond ((or (minusp nk) (oddp nk) (eq from-end :computed))
	     ;; If some required args missing, or not an even number of k/v pairs,
	     ;; or a computed from-end form was given, no luck.
	     form)
	    ((loop named outer
		   with p = keywords
		   for k in kvlist by 'cddr do
		   (when (and (listp k) (eq (car k) 'quote))
		     (setq k (cadr k)))
		   (unless (eq k :from-end)
		     (loop when (null p) do (return-from outer nil)
			   until (eq k (caar p))
			   do (pop p)))
		   finally (return t))
	     ;; Keywords are all in right order.
	     `(,(if from-end backward-name forward-name)
	       ,@(loop for r in (cdr form) repeat n-req collect r)
	       .,(loop for (keyword init) in keywords collect
		       (loop for (k value) on kvlist by 'cddr do
			     (when (and (listp k) (eq (car k) 'quote))
			       (setq k (cadr k)))
			     (when (eq k keyword)
			       (return value))
			     finally (return init)))))
	    (t form)))))

;;; Look in an alternating list of keyword forms and value forms, trying
;;; to figure out what the value of the :from-end keyword will be.  Return
;;; t or nil if known, and :computed if unknown.
(defun string-search-check-from-end (kvlist)
  (loop for (keyword value) on kvlist by 'cddr do
	(unless (symbolp keyword) (return :computed))
	(when (eq keyword :from-end)
	  (return (if (constantp value)
		      (not (null (lt:evaluate-constant value)))
		      :computed)))))

(define-string-search-function string-search-char (char string)
						  ((start 0) (end nil))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (sys:%string-search-char char string start end))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (let ((string string))
      (declare (sys:array-register string))
      (do ((i (1- end) (1- i)))
	  ((< i start) nil)
	(when (char-equal char (aref string i))
	  (return i))))))

(define-string-search-function string-search-exact-char (char string)
							((start 0) (end nil))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (sys:%string-search-exact-char char string start end))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (let ((string string))
      (declare (sys:array-register string))
      (do ((i (1- end) (1- i)))
	  ((< i start) nil)
	(when (char= char (aref string i))
	  (return i))))))

(define-string-search-function string-search-not-char (char string)
  ((start 0) (end nil))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (let ((string string))
      (declare (sys:array-register string))
      (do ((i start (1+ i)))
	  (( i end) nil)
	(unless (char-equal char (aref string i))
	  (return i)))))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (let ((string string))
      (declare (sys:array-register string))
      (do ((i (1- end) (1- i)))
	  ((< i start) nil)
	(unless (char-equal char (aref string i))
	  (return i))))))

(define-string-search-function string-search-not-exact-char (char string)
  ((start 0) (end nil))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (let ((string string))
      (declare (sys:array-register string))
      (do ((i start (1+ i)))
	  (( i end) nil)
	(unless (char= char (aref string i))
	  (return i)))))
  (progn
    (check-type char character)
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (let ((string string))
      (declare (sys:array-register string))
      (do ((i (1- end) (1- i)))
	  ((< i start) nil)
	(unless (char= char (aref string i))
	  (return i))))))

;;; These two are separate so that they can be called directly with sufficient knowledge.
(defun %string-search-array-set (string start end set)
  (let ((string string)
	(set set)
	(set-length (string-length set)))
    (declare (sys:array-register string set))
    (do ((i start (1+ i)))
	(( i end) nil)
      (let ((char (aref string i)))
	(do ((j 0 (1+ j)))
	    (( j set-length) nil)
	  (when (char-equal char (aref set j))
	    (return-from %string-search-array-set i)))))))

(defun %string-search-array-set-reverse (string start end set)
  (let ((string string)
	(set set)
	(set-length (string-length set)))
    (declare (sys:array-register string set))
    (do ((i (1- end) (1- i)))
	((< i start) nil)
      (let ((char (aref string i)))
	(do ((j 0 (1+ j)))
	    (( j set-length) nil)
	  (when (char-equal char (aref set j))
	    (return-from %string-search-array-set-reverse i)))))))

;;; --- needs optimizations for constant char-set
(define-string-search-function string-search-set (char-set string)
  ((start 0) (end nil))
  (progn
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (if (arrayp char-set) (%string-search-array-set string start end char-set)
	(let ((string string))
	  (declare (sys:array-register string))
	  (do ((i start (1+ i)))
	      (( i end) nil)
	    (when (find (aref string i) char-set :test #'char-equal) 
	      (return i))))))
  (progn
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (if (arrayp char-set) (%string-search-array-set-reverse string start end char-set)
	(let ((string string))
	  (declare (sys:array-register string))
	  (do ((i (1- end) (1- i)))
	      ((< i start) nil)
	    (when (find (aref string i) char-set :test #'char-equal)
	      (return i)))))))

(defun %string-search-not-array-set (string start end set)
  (let ((string string)
	(set set)
	(set-length (string-length set)))
    (declare (sys:array-register string set))
    (do ((i start (1+ i)))
	(( i end) nil)
      (let ((char (aref string i)))
	(do ((j 0 (1+ j)))
	    (( j set-length)
	     (return-from %string-search-not-array-set i))
	  (when (char-equal char (aref set j))
	    (return)))))))

(defun %string-search-not-array-set-reverse (string start end set)
  (let ((string string)
	(set set)
	(set-length (string-length set)))
    (declare (sys:array-register string set))
    (do ((i (1- end) (1- i)))
	((< i start) nil)
      (let ((char (aref string i)))
	(do ((j 0 (1+ j)))
	    (( j set-length)
	     (return-from %string-search-not-array-set-reverse i))
	  (when (char-equal char (aref set j))
	    (return)))))))

(define-string-search-function string-search-not-set (char-set string)
  ((start 0) (end nil))
  (progn
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (if (arrayp char-set) (%string-search-not-array-set string start end char-set)
	(do ((i start (1+ i)))
	    (( i end) nil)
	  (unless (find (aref string i) char-set :test #'char-equal)
	    (return i)))))
  (progn
    (coerce-string-arg string)
    (unless end (setq end (zl:array-active-length string)))
    (if (arrayp char-set) (%string-search-not-array-set-reverse string start end char-set)
	(do ((i (1- end) (1- i)))
	    ((< i start) nil)
	  (unless (find (aref string i) char-set :test #'char-equal)
	    (return i))))))

(define-string-search-function string-search (key string)
					     ((start1 0) (end1 nil) (start2 0) (end2 nil))
  (progn
    (coerce-string-arg string)
    (coerce-string-arg key)
    (unless end1 (setq end1 (zl:array-active-length key)))
    (unless end2 (setq end2 (zl:array-active-length string)))
    (let ((key-len (- end1 start1)))
      (cond ((zerop key-len)
	     (and ( start2 end2) start2))
	    (t
	     (decf end2 (1- key-len))		;Last position at which key may start +1
	     (when ( end2 0)
	       (loop with ch1 = (aref key start1) do
		     (unless (setq start2 (sys:%string-search-char ch1 string start2 end2))
		       (return nil))
		     (and (sys:%string-equal key start1 string start2 key-len)
			  (return start2))
		     (incf start2)))))))
  
  (progn
    (coerce-string-arg string)
    (coerce-string-arg key)
    (unless end1 (setq end1 (zl:array-active-length key)))
    (unless end2 (setq end2 (zl:array-active-length string)))
    (let ((key-len (- end1 start1)))
      (incf start2 (- key-len 1))		;First pos at which last char of key may be
      (cond ((zerop key-len)
	     (and ( start2 end2) end2))
	    (t
	     (loop with ch1 = (aref key (1- end1))
		   for i from (1- end2) downto start2 do
	       (when (and (char-equal (aref string i) ch1)
			  (sys:%string-equal key start1 string (1+ (- i key-len)) key-len))
		 (return (1+ (- i key-len))))))))))

(define-string-search-function string-search-exact (key string)
						   ((start1 0) (end1 nil)
						    (start2 0) (end2 nil))
  (progn
    (coerce-string-arg string)
    (coerce-string-arg key)
    (unless end1 (setq end1 (zl:array-active-length key)))
    (unless end2 (setq end2 (zl:array-active-length string)))
    (let ((key-len (- end1 start1)))
      (cond ((zerop key-len)
	     (and ( start2 end2) start2))
	    (t
	     (decf end2 (1- key-len))		;Last position at which key may start +1
	     (when ( end2 0)
	       (loop with ch1 = (aref key start1) do
		 (unless (setq start2 (sys:%string-search-exact-char ch1 string start2 end2))
		   (return nil))
		 (and (sys:%string= key start1 string start2 key-len)
		      (return start2))
		 (incf start2)))))))
  
  (progn
    (coerce-string-arg string)
    (coerce-string-arg key)
    (unless end1 (setq end1 (zl:array-active-length key)))
    (unless end2 (setq end2 (zl:array-active-length string)))
    (let ((key-len (- end1 start1)))
      (incf start2 (- key-len 1))		;First pos at which last char of key may be
      (cond ((zerop key-len)
	     (and ( start2 end2) end2))
	    (t
	     (loop with ch1 = (aref key (1- end1))
		   for i from (1- end2) downto start2 do
	       (when (and (char= (aref string i) ch1)
			  (sys:%string= key start1 string (1+ (- i key-len)) key-len))
		 (return (1+ (- i key-len))))))))))

(defun string-trim (char-set string &aux i j)
  (declare lt:(side-effects reader reducible))
  (setq i (string-search-not-set char-set string))
  (cond ((null i) "")
	(t (setq j (string-search-not-set char-set string :from-end t))
	   (substring string i (1+ j)))))

(defun string-left-trim (char-set string &aux i)
  (declare lt:(side-effects reader reducible))
  (setq i (string-search-not-set char-set string))
  (cond (i (substring string i (string-length string)))
	(t "")))
(defun string-right-trim (char-set string &aux i)
  (declare lt:(side-effects reader reducible))
  (setq i (string-search-not-set char-set string :from-end t))
  (cond (i (substring string 0 (1+ i)))
	(t "")))

(defun string-nconc (modified-string &rest strings)
  (coerce-string-arg modified-string t)
  (let* ((length (fill-pointer modified-string))
	 (total-length (+ length (loop for string in strings sum (string-length string)))))
    (when (> total-length (zl:array-length modified-string))
      (setq modified-string (zl:adjust-array-size modified-string total-length)))
    (loop for string in strings
	  do (typecase string
	       (character
		 (setf (aref modified-string length) string)
		 (incf length))
	       (otherwise
		 (unless (stringp string)
		   (setq string (string string)))
		 (let ((string-length (zl:array-active-length string)))
		   (copy-array-portion string 0 string-length modified-string length
				       (incf length string-length))))))
    (setf (fill-pointer modified-string) total-length))
  modified-string)



(defvar *compound-separators*
	'(;; prepositions
	  "about" "above" "after" "amidst" "around" "at"
	  "before" "behind" "below" "beneath" "beside" "between" "by"
	  "for" "from"
	  "in" "inside" "into"
	  "like"
	  "of" "on" "onto" "outside" "over"
	  "through" "to"
	  "under"
	  "via"
	  "with"
	  ;; conjunctions
	  "and" "or"
	  ;; actually, nor won't work terribly well without handling for neither,
	  ;; but someday maybe we will add handling for "either" and "neither"
	  ;; so might as well. -kmp 17-Nov-90
	  "nor"))

(defun string-pluralize-1 (string continuation)
  (let* ((pos0 (or (string-search-set si:*whitespace* string) (string-length string)))
	 (pos1 0)
	 (pos2 0))
    (loop
      (unless pos1 (return (string-pluralize-2 string continuation)))
      (setq pos1 (or (string-search-not-set si:*whitespace* string :start pos0) pos0))
      (setq pos2 (or (string-search-set si:*whitespace* string :start pos1)
		     (string-length string)))
      (dolist (word *compound-separators*)
	(when (string-equal string word :start1 pos1 :end1 pos2)
	  (let* ((string1 (substring string 0 pos0))
		 (string2 (string-pluralize-1a (substring string pos0) (- pos2 pos0)))
		 (length2 (string-length string2)))
	    (return-from string-pluralize-1
	      (string-pluralize-2 string1
				  #'(lambda (flush add length last-char-lc-flag style-index)
				      (funcall continuation
					       (if flush (+ flush length2) length2)
					       (if add (string-append add string2) string2)
					       (+ length length2)
					       last-char-lc-flag
					       style-index)))))))
      (setq pos0 pos2)
      (setq pos1 (string-search-not-set si:*whitespace* string :start pos2)))))

(defun string-pluralize-1a (string pos)
  (let* ((pos1 (or (string-search-not-set si:*whitespace* string :start pos) pos))
	 (pos2 (or (string-search-set si:*whitespace* string :start pos1)
		   (string-length string))))
    (cond ((or (string-equal string "a" :start1 pos1 :end1 pos2)
	       (string-equal string "an" :start1 pos1 :end1 pos2))
	   (string-append (substring string 0 pos1)
			  (string-pluralize
			    (substring string
				       (or (string-search-not-set si:*whitespace* string
								  :start pos2)
					   (string-length string))))))
	  (t string))))

(defun string-pluralize-2 (string continuation)
  (declare (sys:downward-funarg continuation))
  (let ((length (string-length string))
	(pos0   (1+ (or (string-search-set si:*whitespace* string :from-end t)
			-1))))
    (if (zerop length)
	""
      (let* ((flush nil)
	     (add nil)
	     (last-char-raw (aref string (1- length)))
	     (last-char-style-index (si:char-style-index last-char-raw))
	     (last-char (char-upcase last-char-raw))
	     (last-char-lc-flag (char last-char last-char-raw))
	     (penult-char (if (> length 1)
			      (char-upcase (aref string (- length 2)))
			    #\*))
	     (last-3 (substring string (max 0 (- length 3)))))
	(cond ((and (char-equal last-char #\Y)
		    (not (member penult-char '(#\A #\E #\I #\O #\U))))
	       (setq flush 1 add "ies"))
	      ((or (string-equal string "ox"  :start1 pos0)
		   (string-equal string "vax" :start1 pos0))
	       (setq add "en"))
	      ((or (and (char= last-char #\H)
			(member penult-char '(#\C #\S)))
		   (member last-char '(#\S #\Z #\X)))
	       (setq add "es"))
	      ((and (string-equal last-3 "man")
		    (not (string-equal string "human" :start1 pos0)))
	       (setq flush 2 add "en"))
	      ((string-equal last-3 "ife")
	       (setq flush 2 add "ves"))
              ((and ( length 5) (string-equal string "child" :start1 (- length 5)))
               (setq add "ren"))
	      (t (setq add "s")))
	(funcall continuation flush add length last-char-lc-flag last-char-style-index)))))

(defun string-pluralize (string)
  (declare lt:(side-effects reader reducible))
  (coerce-string-arg string)
  (string-pluralize-1
    string
    #'(lambda (flush add length last-char-lc-flag style-index)
	(if flush (setq string (substring string 0 (- length flush))))
	(cond (add
	       (let ((text-to-add (cond (last-char-lc-flag add)
					(t (string-upcase add)))))
		 (if (zerop style-index)
		     (string-append string text-to-add)
		     (format nil "~A~V~A~"
			     string (si:index-character-style style-index) text-to-add))))
	      (t string)))))

(defun string-pluralize-to-stream (string stream)
  (coerce-string-arg string)
  (string-pluralize-1
    string
    #'(lambda (flush add length last-char-lc-flag style-index)
	(cl:write-string string stream :end (if flush (- length flush)))
	(map nil #'(lambda (c)
		     (let ((char (if last-char-lc-flag c (char-upcase c))))
		       (unless (zerop style-index)
			 (setq char (make-character char
						    :style (si:index-character-style
							     style-index))))
		       (write-char char stream)))
	     add))))


#||

(defun test-string-pluralize (&optional (fn 'string-pluralize))
  (let ((result (mapcan #'(lambda (singular-plural)
			    (let* ((singular (car singular-plural))
				   (plural (funcall fn singular))
				   (correct (cadr singular-plural)))
			      (unless (equal plural correct)
				(ncons (list singular :result plural :expected correct)))))
			'(("" 	"")			 ;Special case
			  ("dog"        "dogs")	         ;Standard plural
			  ("turkey"     "turkeys")	 ;<vowel>y => <vowel>ys
			  ("pay"        "pays")	         ;ditto
			  ("proxy"      "proxies")	 ;y => ies
			  ("witch"      "witches")	 ;ch => ches
			  ("wish"       "wishes")	 ;sh => shes
			  ("pith"       "piths")	 ;other h
			  ("ox"         "oxen")          ;special case "ox"
			  ("vax"        "vaxen")         ;special case "vax"
			  ("box"        "boxes")	 ;x => xes
			  ("fuzz"       "fuzzes")	 ;z => zes
			  ("fuss"       "fusses")        ;s => ses
			  ("man"        "men")	         ;special case "...man"
			  ("human"      "humans")	 ;special case "human"
			  ("fireman"    "firemen")	 ;generalized "...man" special case
			  ("wife"       "wives")	 ;special case "...ife"
			  ("child"      "children")      ;special case "...child"
			  ("grandchild" "grandchildren") ;generalized "...child" special case
			  ("D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")bold0"       "1bolds0")	 ;preserve bold
			  ("(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")italic0"     "2italics0")	 ;preserve italic
			  ("big box"    "big boxes")	 ;double words
			  ("tall man"   "tall men")	 ;double word with special case
			  ("tall human" "tall humans")	 ;double word with special case
			  ("man of war" "men of war")	 ;xxx of yyy   => xxxs of yyy
			  ("MAN OF WAR" "MEN OF WAR")	 ;test case preservation
			  ("1man of war0" "1men of war0")	 ;test style preservation
			  ("son of a bitch"
			   "sons of bitches")		 ;xxx of a yyy => xxxs of yyys
			  ("big  box  of  toys"
			   "big  boxes  of  toys")	 ;xxx  of  yyy => xxxs  of  yyys
			  ("window with a border"
			   "windows with borders")	 ;xxx with a yyy => xxxs with yyys
			  ("picture in a window with a border"
			   "pictures in windows with borders")
			  ;; These next few may seem a little weird but consider that they
			  ;; work well in the case where they are obtained by removing
			  ;; "a" or "an" from the front of a phrase, and then pluralizing
			  ;; the rest. Certainly none of these responses are any worse than
			  ;; what used to come out before under these circumstances.
			  ;; -kmp 11-Nov-90
			  ("painting or a picture of a house"
			   ;;    a painting or a picture of a house
			   ;; => paintings or pictures of houses
			   "paintings or pictures of houses")
			  ("man and a dog"
			   ;; a man and a dog => men and dogs
			   "men and dogs")
			  ("man and dog"
			   ;; a man and dog => men and dog
			   ;; This is clearly marginal, but harmless.
			   ;; certainly no worse than "man and dogs" -kmp 11-Nov-90
			   "men and dog")
			  ))))
    (if (not result) :win `(:lose ,@result))))

||#


;;; Selecting "a" or "an"
;;; See also the ~\A-OR-AN\ format directive.

(defvar *pronounce-aitch* t)

(defvar *string-a-or-an-exceptions-alist* '(("one" . :A))
  "List with form ((EXCEPTION1 . VAL1) ...) where VALi may be :A or :AN.")

(defun string-a-or-an (string &optional (both-words t) (case :downcase))
  (cli::coerce-string-arg string)
  (let* ((length (string-length string))
	 (pos (string-search #\Space string))
	 (original-string string))
    (when pos
      (setq string (nsubstring string 0 pos))	;Don't side-effect it!
      (setq length pos))
    (if (= length 0)
	string					;"a " will look dumb. Just punt. GIGO.
	(let ((char (char string 0)))
	  (let* ((article
		   (cond ((cdr (assoc string *string-a-or-an-exceptions-alist*
				      :test #'string-equal)))
			 ((digit-char-p char)
			  ;; pronounce leading digits number!
			  (string-a-or-an (format nil "~:R"
						  (parse-integer string :junk-allowed t))
					  nil nil))
			 ((or
			    ;; "an x" but "a xylophone"
			    (= length 1)
			    ;; "an fff" but "a frog"
			    (not (string-search-set "AEIOU" string))
			    ;; "an xl400" but "a xylophone"
			    (string-search-set "0123456789" string))
			  (if (string-search-char char "AEFHILMNORSX")
			      :an :a))
			 (t
			  (if (or
				;; "an apple", "an indian", ...
				(string-search-char char "AIO")
				;; "a history" (American) but "an history" (British)
				(if (or (char= char #\H) (char= char #\h))
				    (ccase *pronounce-aitch*
				      ((t)   nil)
				      ((:an) nil);Some people just say "an" always for "h...".
				      ((nil) (not (string-equal string "HEU" :end1 3)))))
				;; "an egg" but "a eunich"
				(and (or (char= char #\E) (char= char #\e))
				     (not (string-equal string "EU" :end1 2)))
				;; "an umbrella", but "a unicorn", "uniform", ...,
				;; but "an uninformed ...", ... and of course "a unix"
				;; Admittedly, we have to be heuristic.
				(and (or (char= char #\U) (char= char #\u))
				     (not (and (string-equal string "UNI" :end1 3)
					       (or (< length 5)
						   (not (string-search-char
							  (char string 4)
							  ;; Treat "y" as a vowel here.
							  ;; e.g., "unicycle"
							  "BCDFGHJKLMNPQRSTVWXZ")))))))
			      :an :a))))
		 (article-string
		   (cond ((not (eq case 't))
			  (ecase case
			    ((nil) article)
			    ((:downcase) (string-downcase article))
			    ((:upcase)   (string-upcase article))
			    ((:capitalize) (string-capitalize article))))
			 ((upper-case-p (char string (- length 1)))
			  ;; Assume word is all-uppercase. Make the result be, too.
			  (string-upcase article))
			 (t
			  ;; Mixed case is ok. Use lower case.
			  (string-downcase article)))))
	    (if both-words
		(string-append article-string #\Space original-string)
		article-string))))))

#|| ;; OK, QA folks. Go to town...

(DEFUN TEST-STRING-A-OR-AN ()
  (LET ((FAILURES '()))
    (DOLIST (ITEM '(("an" "XL400")         ("a" "3600")            ("an" "8086")
		    ("a"  "100")           ("a"  "-3")             ("an" "ant")
		    ("a"  "box")           ("a"  "cat")            ("a"  "dog")
		    ("an" "egg")           ("a"  "eunich")
		    ("a"  "fox")           ("a"  "god")
		    ("a"  "hat" T)	   ("an" "hat" NIL)
		    ("a"  "heuristic" T)   ("a"  "heuristic" NIL)
		    ("an" "ice")           ("a"  "jot")
		    ("a"  "kid")           ("a"  "lip")            ("a"  "mop")
		    ("a"  "nap")           ("an" "ore")            ("a"  "pig")
		    ("a"  "quip")          ("a"  "rip")            ("a"  "sip")
		    ("a"  "tip")           ("an" "ump")            ("a"  "unix")
		    ("a"  "unique thing")  ("a"  "unicycle")       ("an" "umbrella")
		    ("a"  "uniformed man") ("an" "uninformed man") ("a"  "vax")
		    ("a"  "war")           ("a"  "xylophone")      ("a"  "yak")
		    ("a"  "zip")
		    ("an" "a") ("a"  "b") ("a"  "c") ("a"  "d") ("an" "e")
		    ("an" "f") ("a"  "g") ("an" "h") ("an" "i") ("a"  "j")
		    ("a"  "k") ("an" "l") ("an" "m") ("an" "o") ("a"  "p")
		    ("a"  "q") ("an" "r") ("an" "s") ("a"  "t") ("a"  "u")
		    ("a"  "v") ("a"  "w") ("an" "x") ("a"  "y") ("a"  "z")))
      (LET ((*PRONOUNCE-AITCH* (IF (> (LENGTH ITEM) 2) (THIRD ITEM)
				   *PRONOUNCE-AITCH*)))
	(LET ((RESULT1 (CLI::STRING-A-OR-AN (SECOND ITEM) NIL))
	      (RESULT2 (CLI::STRING-A-OR-AN (STRING-UPCASE (SECOND ITEM)) NIL)))
	  (UNLESS (AND (EQUAL RESULT1 (FIRST ITEM))
		       (EQUAL RESULT2 (FIRST ITEM)))
	    (PUSH (LIST (SECOND ITEM) *PRONOUNCE-AITCH* RESULT1 RESULT2) FAILURES)))))
    (DOLIST (CASE '(NIL T :UPCASE :DOWNCASE :CAPITALIZE))
      (UNLESS (EQUAL (CLI::STRING-A-OR-AN "apple" NIL CASE)
		     (FUNCALL (CADR (ASSOC CASE '((NIL       IDENTITY)
						  (T         STRING-DOWNCASE)
						  (:DOWNCASE STRING-DOWNCASE)
						  (:UPCASE   STRING-UPCASE)
						  (:CAPITALIZE STRING-CAPITALIZE))))
			      :AN))
	(PUSH CASE FAILURES)))
    (IF (NOT FAILURES) :WIN `(:LOSE ,FAILURES))))

||#
