;;; -*- Mode: LISP; Syntax: common-lisp; Package: Common-lisp-internals; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; A veritable -Bos Gruniens- of hair....

#|
    The ktpa (keyword to positional argument) stuff below is motivated by

    1)  a desire to speed up keyword parameter processing.  For a given function, when
	practical, we would like to speed this up by defining a "helper" function that takes
	positional rather than keyword arguments and call the "helper" function instead.  It
	is desirable that this "helper" function to be "automatically" generated and the
	means by which a call to the function is optimized to a call to the "helper" function
	be automatically generated.

    2)  a desire to be able to define our own "helper" functions for certain keyword(s)
	versus value(s) (including no keyword) combination(s) and have calls to the
	particular function changed into calls to the "helper" functions.  It is reasonable
	to supply hand coded versions of the "helper" but it is desirable that the means by
	which a call to a function is optimized to a call to such a hand coded helper
	function be automatically generated.

    As an example of goal 1), we might like

	(member-if #'numberp some-list :key #'car)

to be optimized into

	(member-if-positional #'numberp some-list #'car)

    As a couple of examples of goal 2), we might like

	(member some-item some-list :test #'equal)

to be optimized into

	(member-equal some-item some-list)

and

	(member-test some-item some-list :test #'some-test)

to be optimized into

	(member-test some-item some-list some-test)

    To achieve goal 1), a function with keyword arguments may be defined using the
DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-FUNCTION.  For example,

	(define-keyword-to-positional-arguments-function (foo foo-positional)
	  (arg1 arg2 &key key1 key2)
	  ...)

defines a FOO-POSITIONAL function whose argument list consists of the four required arguments
arg1, arg2, key1, and key2.  In addition, the function FOO is defined and proclaimed to be
INLINE using the DEFSUBST mechanism.  FOO's argument list is (arg1 arg2 &key key1 key2) and
FOO's body merely invokes FOO-POSITIONAL.  Invocation's of FOO are, when possible (as
determined by the DEFSUBST mechanism), automatically converted to calls to FOO-POSITIONAL.

    The lambda list for a DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-FUNCTION may contain
required, optional, keyword, and auxiliary arguments.  The lambda list may not contain an
&rest argument.  Supplied-p arguments in optional and keyword arguments are supported.

    WARNING: this implementation means that callers of FOO must be recompiled when FOO's
interface is changed.

    To achieve goal 2), the DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-OPTIMIZERS macro may be
used to link a function's invocation with a specific parameter pattern with a helper
function invocation.  The DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-OPTIMIZERS has the form

	(define-keyword-to-positional-arguments-optimizers function argument-list
	  &body patterns-and-transformations)

ARGUMENT-LIST should match the argument list for FUNCTION.

    Each PATTERNS-AND-TRANSFORMATIONS has the form

	(pattern transformation)

where PATTERN is a pseudo lambda list which may contain

	1)  the name of an argument in ARGUMENT-LIST
	2)  a keyword in ARGUMENT-LIST
	3)  a compile time constant expression
	4)  a #'foo form

TRANSFORMATION should be the forms which the invocation of FUNCTION should be transformed.

    Using the name of an argument in a pattern specifies that any actual argument in the
indicated position or keyword value in the invocation of FUNCTION matches the pattern.  Using
a keyword in a pattern specifies that the keyword must appear in the invocation of FUNCTION
for the pattern to match.  The keyword need not appear in the same position in the invocation
of the function as it does in the pattern.  Using a compile time constant expression or a #'
form in a pattern specifies that the actual argument in the indicated position or keyword
value in the invocation of FUNCTION must exactly match that constant or #' form for the
pattern to match.  Patterns are matched against an invocation of FUNCTION in the order
specified by the user of DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-OPTIMIZERS.

    For example, the MEMBER-EQUAL helper example can be defined by

	(define-keyword-to-positional-arguments-optimizers member
	  (item list &key (test #'eql) test-not (key #'identity))
	  ((item list :test #'equal) (member-equal item list)))

The effect of the existing FILL to FILL-FAST optimizer can be mimiced by

	(define-keyword-to-positional-arguments-optimizers fill
	  (sequence item &key (start 0) end)
	  ((sequence item) (fill-fast sequence item))
	  ((sequence item :start start) (fill-fast sequence item start))
	  ((sequence item :start start :end end) (fill-fast sequence item start end))
	  ((sequence item :end end) (fill-fast sequence item start end)))

Note that it is not necessary to supply a (sequence item :end end :start start) pattern.

WARNING: it is not possible in the current implementation to specify additional patterns and
transformations in additional invocations of DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-OPTIMIZERS.
A single invocation of DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-OPTIMIZERS should be used for
each FUNCTION.

WARNING: the current implementation does not sit on top of a general purpose pattern
recognition facility.  Ordering of patterns is therefore important.  In the case of the
MEMBER-EQUAL and MEMBER-TEST examples above, specifying the patterns as

	(define-keyword-to-positional-arguments-optimizers member
	  (item list &key (test #'eql) test-not (key #'identity))
	  ((item list :test test) (member-test item list test))
	  ((item list :test #'equal) (member-equal item list)))

would mean that the transformation for (item list :test #'equal) would never occur since the
invocation

	(member some-item some-list :test #'equal)

is matched by the pattern (item list :test test).
|#

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;;
;;;0	1The keyword to positional argument optimization structure to hold the database used
;;; in defining keyword-to-positional-arguments-pattern-matching.
;;;
;;;0	1Each 0pattern1 in 0patterns1 is a three element list.  0(first list)1 is one
;;; 0'compiler:ordered1 or 0'compiler:unordered1, indicating the kind of pattern.  0(second list)
1;;; is the call argument pattern to be matched.  0(third list)1 is the optimized call pattern.
;;;
0(zl:defstruct
   (ktpa-optimizer-data (:copier nil) (:predicate nil) (:alterant nil)
			(:conc-name "KTPA-OPTIMIZER-"))
   ((number-of-required-parameters (byte 8 0) 0)
    (number-of-optional-parameters (byte 8 8) 0)
    (number-of-keyword-parameters (byte 8 16) 0))
   (original-lambda-list nil)
   (optional-info nil)		1; alist of 0(default-value . supplied-p)1 pairs
0   (keywords-info nil)		1; alist of 0(keyword default-value1 . 0supplied-p)1 triplets
0   (patterns nil)
   (positional-parameter-list nil))

(defsubst setup-ktpa-argument-pattern (pattern parameter-name)
   (declare (values pattern-or-*))
   (if (eq pattern parameter-name)
       'cl:*
       pattern))

(defparameter *ktpa-keyword-pattern-mismatch-error*
	      "The keyword ~A specified in the optimization argument template ~A~@
	       did not appear in the original lambda-list for the function ~A.")

1;;;
;;;0 ASSUMES: 1The caller has already verified0 (AND (EVENP (LENGTH KEYWORD-ARGUMENT-PATTERNS))
1;;;0						  ( (LENGTH KEYWORD-ARGUMENT-PATTERNS) 6).
1;;;
0(defun make-canonicalized-ktpa-keyword-argument-patterns
       (kw-arg-pats kws-and-dfvs kw-parm-names func-name)
   (declare (arglist keyword-argument-patterns keywords-and-default-values
		     keyword-parameter-names function-name)
	    (values keyword-pattern-type keyword-pattern-list))
   (let ((kw-pat-list (make-list (* (length kws-and-dfvs) 2) :initial-element #\p))
	 (copied-pats (copy-tree kw-arg-pats)))		1; for error reporting purposes
0      (labels ((validate-kw (expected-kw)
		  (declare (sys:downward-function)
			   (arglist expected-keyword) (values keyword-position))
		  (let ((kw-pos (position expected-kw kws-and-dfvs :key #'first)))
		    (when (null kw-pos)
		      (compiler:warn *ktpa-keyword-pattern-mismatch-error*
				     expected-kw copied-pats func-name)
		      (return-from make-canonicalized-ktpa-keyword-argument-patterns
			(values nil nil)))
		    kw-pos)))
	 (loop while kw-arg-pats
	       as expected-kw  = (pop kw-arg-pats)
	       as kw-position  = (validate-kw expected-kw)
	       as expected-pat = (pop kw-arg-pats)
	       as kw-parm-name = (nth kw-position kw-parm-names)
	       doing
		 (let ((kw-position-in-list (* kw-position 2)))
		   (setf (nth kw-position-in-list kw-pat-list) expected-kw)
		   (setf (nth (+ kw-position-in-list 1) kw-pat-list)
			 (setup-ktpa-argument-pattern expected-pat kw-parm-name)))
	       finally
		 (return (values 'compiler:ordered (ncons kw-pat-list)))))))

1;;;
;;;0 ASSUMES:1 The caller has already verified0 (AND (EVENP (LENGTH KEYWORD-ARGUMENT-PATTERNS))
1;;;0						  ( (LENGTH KEYWORD-ARGUMENT-PATTERNS) 4).
1;;;
0(defun make-ktpa-keyword-argument-patterns (kw-arg-pats kws-and-dfvs kw-parm-names func-name)
   (declare (arglist keyword-argument-patterns keywords-and-default-values
		     keyword-parameter-names function-name)
	    (values keyword-pattern-type keyword-pattern-list))
   (let (kw-pat-list
	 (copied-pats (copy-tree kw-arg-pats)))		1; for error reporting purposes
0      1;;
0      (labels ((validate-keyword (kw)
		  (declare (sys:downward-function)
			   (arglist expected-keyword) (values keyword-position))
		  (let ((kw-pos (position kw kws-and-dfvs :key #'first)))
		    (when (null kw-pos)
		       (compiler:warn
			 *ktpa-keyword-pattern-mismatch-error* kw copied-pats func-name)
		       (return-from make-ktpa-keyword-argument-patterns (values nil nil)))
		    kw-pos))
	       ;;
	       (assemble-kw-data (kw-1 pat-1 pos-1 kw-2 pat-2 pos-2)
		  (declare (sys:downward-function) (values))
		  (let ((arg-pat-1 (setup-ktpa-argument-pattern
				     pat-1 (nth pos-1 kw-parm-names)))
			(arg-pat-2 (setup-ktpa-argument-pattern
				     pat-2 (nth pos-2 kw-parm-names))))
		     (push (list kw-2 arg-pat-2 kw-1 arg-pat-1) kw-pat-list)
		     (push (list kw-1 arg-pat-1 kw-2 arg-pat-2) kw-pat-list))))
	 (when kw-arg-pats
	   (let* ((kw-1  (pop kw-arg-pats))
		  (pos-1 (validate-keyword kw-1))
		  (pat-1 (pop kw-arg-pats)))
	      (if kw-arg-pats
		  (let* ((kw-2  (pop kw-arg-pats))
			 (pos-2 (validate-keyword kw-2))
			 (pat-2 (pop kw-arg-pats)))
		     (if (> pos-2 pos-1)
			 (assemble-kw-data kw-1 pat-1 pos-1 kw-2 pat-2 pos-2)
			 (assemble-kw-data kw-2 pat-2 pos-2 kw-1 pat-1 pos-1)))
		  (push
		    (list kw-1
			  (setup-ktpa-argument-pattern pat-1 (nth pos-1 kw-parm-names)))
		    kw-pat-list))))
	 (values 'compiler:unordered kw-pat-list))))

(defun build-ktpa-optimizer-data
       (func-name func-ll reqd-parms optn-parms kw-parms opt-func-defs) 
  (declare (arglist function-name function-lambda-list
		    required-parameters optional-parameters keyword-parameters
		    optimized-function-definitions)
	   (values ktpa-optimizer-data-built-p ktpa-optimizer-data))
  (let (kw-parm-names kw-parm-kws-and-dfvs optn-parm-names optn-parm-dfvs
	pos-parms-sans-auxs pos-kws pos-optns)
    1;;
0    (labels ((setup-optn-data (optn-parm optn-parm-dfv supp-p-var)
	       (declare (sys:downward-function)
			(arglist optional-parameter-name keyword-parameter-default-value
				 supplied-p-variable)
			(values parameter-name))
	       (push optn-parm pos-optns)
	       (push optn-parm optn-parm-names)
	       (push (cons optn-parm-dfv supp-p-var) optn-parm-dfvs)
	       (when supp-p-var (push supp-p-var pos-optns)))
	     1;;
0	     (setup-kw-data (kw-parm kw-parm-dfv supp-p-var)
	       (declare (sys:downward-function)
			(arglist keyword-parameter-name-or-pair
				 keyword-parameter-default-value
				 supplied-p-variable)
			(values parameter-name))
	       (push (cond ((symbolp kw-parm)
			    (push kw-parm kw-parm-names)
			    (push (list* (intern (string kw-parm) pkg-keyword-package)
					 kw-parm-dfv
					 supp-p-var)
				  kw-parm-kws-and-dfvs)
			    kw-parm)
			   (t (push (second kw-parm) kw-parm-names)
			      (push (list* (first kw-parm) kw-parm-dfv supp-p-var)
				    kw-parm-kws-and-dfvs)
			      (second kw-parm)))
		     pos-kws)
	       (when supp-p-var (push supp-p-var pos-kws))))
       1;;
0       (setq pos-parms-sans-auxs
	     (append reqd-parms
		     (loop for optn-parm in optn-parms
			   do (cond ((symbolp optn-parm)
				     (setup-optn-data optn-parm nil nil))
				    ((= (length optn-parm) 3)
				     (setup-optn-data
				       (first optn-parm)
				       (second optn-parm)
				       (third optn-parm)))
				    (t (setup-optn-data
					 (first optn-parm) (second optn-parm) nil)))
			   finally (setq optn-parm-names (nreverse optn-parm-names))
				   (setq optn-parm-dfvs  (nreverse optn-parm-dfvs))
				   (return (nreverse pos-optns)))
		     (loop for kw-parm in kw-parms
			   do (cond ((symbolp kw-parm)
				     (setup-kw-data kw-parm nil nil))
				    ((= (length kw-parm) 3)
				     (setup-kw-data
				       (first kw-parm) (second kw-parm) (third kw-parm)))
				    (t (setup-kw-data (first kw-parm) (second kw-parm) nil)))
			   finally (setq kw-parm-names (nreverse kw-parm-names))
				   (setq kw-parm-kws-and-dfvs (nreverse kw-parm-kws-and-dfvs))
				   (return (nreverse pos-kws)))))
       ;;
       (let* ((all-opt-pats-valid-p t)
	      (num-reqd-parms (length reqd-parms))
	      (ktpa-optimizer-data
		(make-ktpa-optimizer-data
		  number-of-required-parameters num-reqd-parms
		  number-of-optional-parameters (length optn-parms)
		  number-of-keyword-parameters  (length kw-parms)
		  original-lambda-list          (copy-tree func-ll)
		  optional-info                 optn-parm-dfvs
		  keywords-info                 kw-parm-kws-and-dfvs
		  positional-parameter-list     pos-parms-sans-auxs)))
	  (setf (ktpa-optimizer-patterns ktpa-optimizer-data)
		(loop for (opt-func-arg-pat . opt-code) in opt-func-defs
		      nconcing
		   (block process-opt-func-def
		      (let (final-arg-pat)
			 (when (< (length opt-func-arg-pat) num-reqd-parms)
			    (compiler:warn "Too few arguments specified in the optimization ~
					    argument template for~%~A.~@
					    At least ~D required arguments must be ~
					    specified for function ~A."
					   (cons opt-func-arg-pat opt-code)
					   num-reqd-parms
					   func-name)
			    (setq all-opt-pats-valid-p nil)
			    (return-from process-opt-func-def))
			 1;;
0			 (loop for reqd-parm in reqd-parms
			       while opt-func-arg-pat
			       as  pattern = (pop opt-func-arg-pat)
			       do (push (setup-ktpa-argument-pattern pattern reqd-parm)
					final-arg-pat))
			 1;;
0			 (loop for optn-parm-name in optn-parm-names
			       while opt-func-arg-pat
			       as  pattern = (pop opt-func-arg-pat)
			       do (push (setup-ktpa-argument-pattern pattern optn-parm-name)
					final-arg-pat))
			 1;;
0			 (let ((kw-pat-len (length opt-func-arg-pat)))
			    (unless (evenp kw-pat-len)
			       (compiler:warn "The length of the keyword portion of the ~
					       optimization argument template for~@
					       ~A was not an even number."
					      opt-func-arg-pat)
			       (setq all-opt-pats-valid-p nil)
			       (return-from process-opt-func-def))
			    (multiple-value-bind (opt-pat-kind opt-pats)
				  (funcall
				     (if (> kw-pat-len 4)
					 #'make-canonicalized-ktpa-keyword-argument-patterns
					 #'make-ktpa-keyword-argument-patterns)
				     opt-func-arg-pat
				     kw-parm-kws-and-dfvs
				     kw-parm-names
				     func-name)
			       (when opt-pat-kind
				 (cons
				    (list opt-pat-kind
					  (nconc (reverse final-arg-pat) (pop opt-pats))
					  (copy-tree opt-code))
				    (when opt-pats
				       (ncons (list opt-pat-kind
						    (nconc (nreverse final-arg-pat)
							   (pop opt-pats))
						    opt-code)))))))))))
	  (values all-opt-pats-valid-p ktpa-optimizer-data)))))

(defsubst ktpa-args-value-equal (value argument)
  (equal (key-test-function-default-value-canonicalizer value)
	 (key-test-function-default-value-canonicalizer argument)))

(defun ktpa-arguments-match-p (pattern arguments)
   (declare (values scl:boolean))
   (when (= (length pattern) (length arguments))
      (loop for parameter in pattern
	    for argument in arguments
	    always ;;
		   ;;        Wild cards in patterns are denoted by the symbol *.
		   ;;
		   (or (eq parameter 'cl:*) (ktpa-args-value-equal parameter argument)))))

(defun ktpa-canonicalized-arguments-match-p (ktpa-opt-data num-pos-args pattern arguments)
   (declare (arglist ktpa-optimizer-data number-of-positional-arguments pattern arguments)
	    (values scl:boolean))
   (let* ((result-list
	    (make-list (+ num-pos-args (* (ktpa-optimizer-number-of-keyword-parameters
					   ktpa-opt-data)
					  2))
		       :initial-element #\p)))
      1;;
      ;;        First place all the positional arguments into the canonicalized argument
      ;;        list.
      ;;
0      (loop for i from 0 below num-pos-args
	    while arguments
	    do (setf (nth i result-list) (pop arguments)))
      1;;
      ;;	If there are an even number of elements left, the actual invocation is
      ;;        presumably busted.  Otherwise, if there are any left over, they are presumably
      ;;        keyword arguments so move them into canonicalized positions in the argument
      ;;        list.
      ;;
0      (unless (evenp (length arguments))
	 (return-from ktpa-canonicalized-arguments-match-p nil))
      1;;
0      (when arguments
	 (let ((keyword-argument-keywords (ktpa-optimizer-keywords-info ktpa-opt-data)))
	    (loop with arg-position
		  while arguments
		  do (setq arg-position
			   (position (first arguments)
				     keyword-argument-keywords
				     :key #'first))
		     (if arg-position
			 (let ((canonical-position (+ (* arg-position 2) num-pos-args)))
			    (setf (nth canonical-position result-list) (pop arguments)
				  (nth (+ canonical-position 1) result-list) (pop arguments)))
			 (return-from ktpa-canonicalized-arguments-match-p nil)))))
      (ktpa-arguments-match-p pattern result-list)))

1;;;
;;;        In case you need to turn this stuff off.
;;;
0(defvar *do-ktpa-optimizations* t)

(defun find-ktpa-optimization (form)
   (compiler:matchp form
      ((function-name . args)
       (or (and *do-ktpa-optimizations*
		(let ((ktpa-opt-data (get function-name 'compiler:ktpa-optimizer-data)))
		   (if (null ktpa-opt-data)
		       form
		       (let* ((args-length (length args))
			      (num-reqd-parms
				(ktpa-optimizer-number-of-required-parameters ktpa-opt-data))
			      (num-optn-parms
				(ktpa-optimizer-number-of-optional-parameters ktpa-opt-data))
			      (num-pos-parms (+ num-reqd-parms num-optn-parms))
			      (kw-names-and-vals (ktpa-optimizer-keywords-info ktpa-opt-data))
			      (optn-vals (ktpa-optimizer-optional-info ktpa-opt-data))
			      args-no-dups kw-args-no-dups)
			 (cond ((> args-length num-pos-parms)
				1;;        
0				(unless (evenp (- args-length num-pos-parms))
				  (return-from find-ktpa-optimization form))
				1;;
0				(loop for i from 0 below num-pos-parms
				      do (push (nth i args) args-no-dups))
				1;;
0				1;;        Create a list of the keyword args with no duplicates
0				1;;
0				(loop for kw-args on (nthcdr num-pos-parms args) by 'cddr
				      as  kw-arg = (first kw-args)
				      do (cond ((assoc kw-arg kw-names-and-vals)
						(unless (member kw-arg args-no-dups)
						  (push kw-arg kw-args-no-dups)
						  (push (second kw-args) kw-args-no-dups)))
					       (t
						1;;        A keyword that doesn't match the
0						1;;        known keywords.  Punt.
0						1;;
0						(return-from find-ktpa-optimization form))))
				1;;
0				1;;        Make another pass over the keyword args weeding out
0				1;;        those that are the same as the default value unless
0				1;;        there is a corresponding supplied-p parameter.
0				1;;
0				(loop for (kw-arg kw-val . nil)
					  on (nreverse kw-args-no-dups) by 'cddr
				      as kw-assoc = (assoc kw-arg kw-names-and-vals)
				      when (or (cddr kw-assoc)
					       (not (ktpa-args-value-equal
						      (second kw-assoc) kw-val)))
					do (push kw-arg args-no-dups)
					   (push kw-val args-no-dups))
				(setq args-no-dups (nreverse args-no-dups)))
			       ((> args-length num-reqd-parms)
				(setq args-no-dups (nreverse (copy-list args)))
1				;;
0				1;;        Make a pass over the optional arguments from the
0				1;;        rear weeding out any that are the same as the
				;;        default value unless there is a corresponding
0				1;;        supplied-p parameter.
0				1;;
0				(loop for arg in args-no-dups
				      for i from (- args-length num-reqd-parms 1) downto 0
				      as  optn-assoc = (nth i optn-vals)
				      if  (or (cdr optn-assoc)
					      (not (ktpa-args-value-equal
						     (first optn-assoc) arg)))
					return nil
				      else do (setq args-no-dups (cdr args-no-dups)))
				(setq args-no-dups (nreverse args-no-dups)))
			       (t (setq args-no-dups (copy-list args))))
			 1;;
0			 (loop for pat in (ktpa-optimizer-patterns ktpa-opt-data)
			       when (if (eq (first pat) 'compiler:ordered)
					    (ktpa-canonicalized-arguments-match-p
					       ktpa-opt-data
					       num-pos-parms
					       (second pat)
					       args-no-dups)
					    (ktpa-arguments-match-p (second pat) args-no-dups))
				  return
				     `(funcall
					 (function
					   (lambda ,(copy-tree
						      (ktpa-optimizer-original-lambda-list
							ktpa-opt-data))
					     ,@(copy-list
						 (ktpa-optimizer-positional-parameter-list
						   ktpa-opt-data))
					     ,@(copy-tree (third pat))))
					 ,@args))))))
	   form))
      (* form)))

(defflavor ktpa-ll-error
	(message definition-type)
	(lambda-list-error)
  (:initable-instance-variables)
  (:gettable-instance-variables))

(defmethod (:report ktpa-ll-error) (stream)
  (format stream "Keyword arguments to positional arguments lambda list error:~%~A" message))

(compile-flavor-methods ktpa-ll-error)

(defun validate-ktpa-ll (lambda-list &optional (function-or-optimizer 'function))
  (declare (values valid-lambda-list-p
		   required-arguments optional-arguments
		   keyword-arguments auxiliary-arguments))
  (let (reqd-args optnl-args kw-args aux-args)
    (condition-case (error)
	(labels ((signal-ll-error (msg)
		   (declare (sys:downward-function))
		   (error 'ktpa-ll-error :lambda-list lambda-list :message msg))
1		 ;;
0		 (check-constantp-dfv (arg)
		   (declare (sys:downward-function))
		   (unless (or (symbolp arg)
			       1;;
0			       1;;        Require that default values be 0constantp1 or a
			       ;;        special variable reference or a form of the form
			       ;;        0(function foo)1 when defining a keyword to positional
			       ;;        arguments function but not when defining a keyword to
0			       1;;        positional arguments optimizer.
0			       1;;
0			       (neq function-or-optimizer 'function)
			       (let ((init (second arg)))
				  (or (constantp init)
				      (and (consp init) (eq (first init) 'function))
				      (and (symbolp init) (get init 'special)))))
		      (signal-ll-error
			"Only constant or special variable default parameter values are ~
			 supported."))))
	   1;;
0	   (multiple-value-bind (ignore aok)
	       (map-over-lambda-list lambda-list
		  #'(lambda (item type)
		       (let ((item (first item)))
			 (case type
			    (:required
			      (push item reqd-args))
			    (:optional
			      (check-constantp-dfv item)
			      (push item optnl-args))
			    (:rest
			      (signal-ll-error "&REST is not supported."))
			    (:key
			      1;;
0			      1;;    a keyword of 0:ALLOW-OTHER-KEYS1 is not checked by
0			      1;;    0MAP-OVER-LAMBDA-LIST1 so do it0 1here.
0			      1;;
0			      (let ((kw-sym
				      (if (symbolp item)
					  (intern (string item) pkg-keyword-package)
					  (let ((possible-kw (first item)))
					    (if (symbolp possible-kw)
						(intern (string possible-kw)
							pkg-keyword-package)
						(first possible-kw))))))
				(when (and (string-equal kw-sym "ALLOW-OTHER-KEYS")
					   (symbol-package kw-sym))
				   (signal-ll-error ":ALLOW-OTHER-KEYS is not supported.")))
			      (check-constantp-dfv item)
			      (push item kw-args))
			    (:aux
			      1;;
0			      1;;        We don't care about non "0constantp1" defaults here.
0			      1;;
0			      (push item aux-args))
			    (otherwise
			      (signal-ll-error
				"Incorrect or unsupported lambda-list syntax."))))))
	     (when aok
	       (signal-ll-error
		 "&ALLOW-OTHER-KEYS is not supported."))))
      (lambda-list-error
	 (let ((error-string (make-array 200 :element-type 'character :fill-pointer 0)))
	    (with-output-to-string (*error-output* error-string)
	      (send error :report *error-output*))
	    (compiler:warn error-string))
	 (return-from validate-ktpa-ll (values nil nil nil nil nil))))
    (values
      t
      1;;
0      1;;        Get rid of the 0NREVERSE1s below and fix the lambda above when a CL
0      1;;        collection facility is available.
0      1;;
0      (nreverse reqd-args) (nreverse optnl-args) (nreverse kw-args) (nreverse aux-args))))

1;;;
;;;	For patching.
;;;
0(defmacro delete-ktpa-optimizer (target-function &rest optimized-into)
  `(progn
     (compiler:delete-optimizer-internal
       ',target-function 'find-ktpa-optimization ',optimized-into)
     (remprop ',target-function 'compiler:ktpa-optimizer-data)))

1;;;
;;;0	1The keyword to positional argument and 0test-key-macro1 code which follows0 1can't use
;;; 0si:find-body-declarations1, because macroexpanding the body before0 1the 0compiler-let
1;;; environment has been set up won't work.
;;;
0(defun find-ktpa-tkm-body-declarations (body)
  (declare (values downward-funargs other-declarations body-without-declarations))
  (let ((downward-funargs nil)
	(other-declarations nil))
    (loop until (null body)
	  while (or (and (stringp (car body)) (cdr body))
		    (and (consp (car body)) (eq (caar body) 'declare)))
	  do (loop for declaration in (rest (pop body))
		   do (if (and (consp declaration)
			       (eq (car declaration) 'downward-funarg))
			  (setq downward-funargs (append downward-funargs (rest declaration)))
			  (push declaration other-declarations)))
	  finally (return (values downward-funargs
				  (nreverse other-declarations)
				  body)))))

(defmacro define-keyword-to-positional-arguments-function
	  ((function-name positional-function-name) function-lambda-list &body body)
  1;;
0  1;;        0decls1 below is always bound to 0NIL1 since 0validate-ktpa-ll1 returns 5 values
0  1;;
  ;;        Gross kludge to deal with the fact that you can't
0  1;;        0(declare (sys:downward-funarg foo))1 when foo is a keyword arg.
0  1;;
0  (flet ((funarg-declaration (downward-funargs keywords)
	   (let ((nonkey-funargs (if keywords
				     (remove-if #'(lambda (arg)
						    (member arg keywords
							    :key #'(lambda (key)
								     (if (consp key)
									 (first key)
									 key))))
						downward-funargs)
				     downward-funargs)))
	     (and nonkey-funargs
		  `((declare (downward-funarg ,@nonkey-funargs)))))))
    (multiple-value-bind (valid-ll reqd-args optnl-args kw-args aux-args)
	(validate-ktpa-ll function-lambda-list)
      (multiple-value-bind (downward-funargs other-decls body)
	  (find-ktpa-tkm-body-declarations body)
	1;;
0	1;;        If the lambda-list fails initial checks or if there are no keyword
0	1;;        arguments just return a defun of the function.
0	1;;
0	(unless (and valid-ll kw-args)
	  (return-from define-keyword-to-positional-arguments-function
	    `(progn
	       (record-source-file-name
		 ',function-name 'define-keyword-to-positional-arguments-function)
	       (defun ,function-name ,function-lambda-list
		 ,@(funarg-declaration downward-funargs
				       (cdr (member '&key function-lambda-list)))
		 ,@(when other-decls
		     `((declare ,@other-decls)))
		 (declare (function-parent
			    ,function-name
			    define-keyword-to-positional-arguments-function))
		 ,@body)
	       ',function-name)))
	(let ((posnl-parm-list
		(append reqd-args
			(loop for optnl-arg in optnl-args
			      nconcing (if (symbolp optnl-arg)
					   (ncons optnl-arg)
					   (if (= (length optnl-arg) 3)
					       (list (first optnl-arg) (third optnl-arg))
					       (ncons (first optnl-arg)))))
			(flet ((get-kw-arg-name (kw-arg)
				 (declare (sys:downward-function))
				 (let ((possible-kw-arg (first kw-arg)))
				   (if (symbolp possible-kw-arg)
				       possible-kw-arg
				       (second possible-kw-arg)))))
			  (loop for kw-arg in kw-args
				nconcing (if (symbolp kw-arg)
					     (ncons kw-arg)
					     (if (= (length kw-arg) 3)
						 (list (get-kw-arg-name kw-arg) (third kw-arg))
						 (ncons (get-kw-arg-name kw-arg)))))))))
	  `(zl:local-declare ((function-parent
				,function-name
				define-keyword-to-positional-arguments-function))
	     (record-source-file-name
	       ',function-name 'define-keyword-to-positional-arguments-function)
	     (defun ,positional-function-name
		    ,(append posnl-parm-list
			     (when aux-args (cons '&aux aux-args)))
	       ,@(funarg-declaration downward-funargs nil)
	       ,@(when other-decls
		   `((declare ,@other-decls)))
	       (block ,function-name		; Support for RETURN-FROMs
		 ,@body))
	     (defsubst ,function-name
		       ,(append reqd-args
				(when optnl-args (cons '&optional optnl-args))
				(when kw-args    (cons '&key      kw-args)))
	       ,@(funarg-declaration downward-funargs kw-args)
	       (,positional-function-name ,@posnl-parm-list))))))))

(defmacro define-keyword-to-positional-arguments-optimizers (func-name func-ll &body opt-defs)
  (declare (arglist function-name function-lambda-list &body optimizer-definitions))
1  ;;
0  (let ((arglist (condition-case ()
		     (arglist func-name)
		   (dbg:undefined-function-trap nil))))
    (unless (null arglist)
      (unless (equal arglist func-ll)
	(compiler:warn "The arglist ~A does match the installed definition's arglist ~A."
		       func-ll arglist)
	(return-from define-keyword-to-positional-arguments-optimizers nil))))
  1;;
0  (multiple-value-bind (valid-ll reqd-args optnl-args kw-args)
      (validate-ktpa-ll func-ll)
    (unless valid-ll
      (return-from define-keyword-to-positional-arguments-optimizers nil))
    (multiple-value-bind (ktpa-opt-data-built-p ktpa-opt-data)
	(build-ktpa-optimizer-data func-name func-ll reqd-args optnl-args kw-args opt-defs)
      (unless ktpa-opt-data-built-p
	 (return-from define-keyword-to-positional-arguments-optimizers nil))
      `(progn
	 (putprop ',func-name ,ktpa-opt-data 'compiler:ktpa-optimizer-data)
	 (compiler:add-optimizer-internal
	   ',func-name
	   'find-ktpa-optimization
	   1;;
0	   1;;        Pay homage to the 0INTOS1 even though the 0INTOS1 mechanism seems to have
0	   1;;        been broken sometime in 1986.  -- DySak 6/06/89
0	   1;;
0	   ',(loop with optimized-intos
		   for opt-func-def in opt-defs
		   as  opt-func-name = (first opt-func-def)
		   unless (member opt-func-name optimized-intos)
		     do (push opt-func-name optimized-intos)))))))

(defvar *test-key-macro-mode* nil)
(defvar *test-key-macro-name*)

(defun key-test-function-optimizer (form)
  (let ((property (get (car form) 'optimizable-arglist-length)))
    (or (and property
	     (let ((nargs (list-length (cdr form)))
		   (nargs-good (car property)))
	       (if (or (= nargs nargs-good)
		       (and (> nargs nargs-good)
			    (key-test-function-hairy-optimizer
			      (car form)
			      (nthcdr nargs-good (cdr form)))))
		   `(,(cadr property)
		     . ,(loop for val in (cdr form)
			      repeat nargs-good
			      collect val)))))
	form)))

(defun key-test-function-hairy-optimizer (function argl)
  (loop with function-argl = (cdr (member '&key (arglist function)))
	with tail = argl
	until (null tail)
	unless (consp tail) return nil
	as arg = (pop tail)
	unless (consp tail) return nil
	as value = (pop tail)
	always (key-test-function-default-value function-argl arg value)))

(defun keyword-arguments-defaults-except (function argl exception-keyword)
  (loop with function-argl = (cdr (member '&key (arglist function)))
	with exception-value = nil
	with exception-value-found = nil
	with tail = argl
	until (null tail)
	unless (consp tail) return (values nil nil)
	as arg = (pop tail)
	unless (consp tail) return (values nil nil)
	as value = (pop tail)
	do (cond ((eql arg exception-keyword)
		  (unless exception-value-found
		    (setq exception-value value)
		    ;; only accept the first occurrence
		    (setq exception-value-found t)))
		 ((key-test-function-default-value function-argl arg value))
		 (t
		  (return (values nil nil))))
	finally (return (values t
				(key-test-function-default-value-canonicalizer
				  (if exception-value-found
				      exception-value
				      (key-test-get-function-default-value
					function-argl exception-keyword)))))))

(defmacro eq-to-keyword (keyword symbol &environment env)
  (once-only (keyword symbol &environment env)
    `(and (symbolp ,keyword)
	  (keywordp ,keyword)
	  (symbolp ,symbol)
	  (string= (string ,keyword) (string ,symbol)))))

(defun key-test-function-default-value (argl ksym value)
  (multiple-value-bind (default-value keyword-legal-p)
      (key-test-get-function-default-value argl ksym)
    (and keyword-legal-p
	 (equal (key-test-function-default-value-canonicalizer default-value)
		(key-test-function-default-value-canonicalizer value)))))

(defun key-test-get-function-default-value (argl ksym)
  (declare (values default-value keyword-legal-p))
  (loop for targ in argl
	if (eq-to-keyword ksym targ) return (values nil t)
	when (and (consp targ)
		  (eq-to-keyword ksym (car targ)))
	  return (values (cadr targ) t)
	finally (return (values nil nil))))

(defun key-test-function-default-value-canonicalizer (thing)
  (cond ((and (consp thing)
	      (eq (car thing) 'function)
	      (consp (cdr thing)))
	 (cons 'quote (cdr thing)))
	((and (consp thing)
	      (eq (car thing) 'quote)
	      (consp (cdr thing))
	      (let ((object (cadr thing)))
		(when (or (numberp object)
			  (member object '(nil t)))
		  (setq thing object)		;could be nil
		  t)))
	 thing)
	(t thing)))

;; Called by presentation type system!!
;(defun tkm-parse-arglist (arglist &optional positional-funarg-names key-funarg-names)
;  (declare (values required rest key aux funargs))
;  (let (required rest key aux funargs)
;    (let ((ptr (locf required)))
;      (dolist (arg arglist)
;	(case arg
;	  (&key (setq ptr (locf key)))
;	  (&rest (setq ptr (locf rest)))
;	  (&aux (setq ptr (locf aux)))
;	  (otherwise (rplaca ptr (cons arg (car ptr)))))))
;    (values (nreverse required) (nreverse rest) (nreverse key) (nreverse aux))))
	
(defun tkm-parse-arglist (arglist)
  (declare (values required rest key aux funargs))
  (let (required rest key aux)
    (lt:map-over-lambda-list
      arglist
      #'(lambda (arg type)
	  (ecase type
	    (:required (push (car arg) required))
	    (:optional (error "Optional arguments not supported by tkm-parse-arglist."))
	    (:rest (setq rest (list (car arg))))
	    (:aux (push (car arg) aux))
	    (:key
	      (push (car arg) key)))))
    (values (nreverse required) rest (nreverse key) (nreverse aux))))

(defun tkm-reconstitute-arglist (required rest key aux)
  (append
    required
    (and rest `(&rest . ,rest))
    (and key `(&key . ,key))
    (and aux `(&aux . ,aux))))

(defun tkm-merge-arglists (&rest arglists)
  (let (required rest key aux)
    (dolist (arglist arglists)
      (multiple-value-bind (this-required this-rest this-key this-aux)
	  (tkm-parse-arglist arglist)
	(if this-required (setq required (append required this-required)))
	(if this-rest (setq rest (append rest this-rest)))
	(if this-key (setq key (append key this-key)))
	(if this-aux (setq aux (append aux this-aux)))))
    (if (> (length rest) 1)
	(error "Multiple &rest's given."))
    (tkm-reconstitute-arglist required rest key aux)))

(defun test-key-macro-arglist (key)
  (case key
    (:2arg-fast nil)
    (:2arg  '(&key (test #'eql) test-not (key #'identity) &aux not-test))
    ((:if :if-not) '(&key key))
    1;;
0    1;;        This could have been done as part of the first case but keep the common ones at
0    1;;        the top of the case to make compilation just a wee bit faster.
0    1;;
0    ((:if-fast :if-not-fast
      :2arg-test :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg- :2arg-char=
      1;;
0      1;;        0CHAR-EQUAL 1is in the0 36xx 1ucode0.  1It's a function on0 Ivory.
      1;;
0      #+3600 :2arg-char-equal)
     nil)
    (t (error "Unknown test key macro key ~A." key))))

(defun test-key-macro-declarations (key)
  (case key
    ((:2arg-fast :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg- :2arg-char=
      ;;
      ;;        CHAR-EQUAL is in the 36xx ucode.  It's a function on Ivory.
      ;;
      #+3600 :2arg-char-equal) nil)
    (:2arg-test '((declare (sys:downward-funarg test))))
    (:2arg      '((declare (sys:downward-funarg test test-not key))))
    ((:if-fast :if-not-fast) '((declare (sys:downward-funarg predicate))))
    (t          '((declare (sys:downward-funarg predicate key))))))

(defun add-fast-optimizer-properties (fast-key slow-key names shared-args)
  (let ((fast-group (assoc fast-key names)))
    (when fast-group
      (let ((slow-group (assoc slow-key names))
	    (argl (or (third fast-group) shared-args)))
	(unless slow-group
	  (error "No corresponding ~A for ~A." slow-key fast-key))
	`((zl:putprop ',(second slow-group)
		      '(,(list-length (tkm-parse-arglist argl))
			,(second fast-group))
		      'optimizable-arglist-length)
	  (compiler:add-optimizer ,(second slow-group)
				  key-test-function-optimizer
				  ,(second fast-group)))))))

(defun tkm-build-fast-case-dequalifiers (arglist)
  (multiple-value-bind (nil nil keys nil)
      (tkm-parse-arglist arglist)
    (loop for key in keys
	  when (atom key) do (setq key (list key nil))
	  as (var default) = key
	  unless (member var '(key test test-not))
	  collect (if (null default)
		      `(null ,var)
		      `(eql ,var ,default)) into tests
	  finally (and tests (return `((and . ,tests)))))))

;;;Needs more work such that limit-checkers and other prologial code do
;;;not get expanded twice for inline-fast/seqfast case.
(defmacro deftest-key-macro (group-name names shared-args &body body
					&aux fast-clause global-arglist
					downward-funargs other-declarations)
  (setq global-arglist (third (assoc ':global-arglist names)))
  (setq fast-clause
	(or (assoc ':2arg-seqfast names)
	    (assoc ':2arg-fast names)))
  (multiple-value-setq (downward-funargs other-declarations body)
    (find-ktpa-tkm-body-declarations body))
  `(zl:local-declare ((function-parent ,group-name deftest-key-macro))
     (record-source-file-name ',group-name 'deftest-key-macro)
     ,@ (add-fast-optimizer-properties ':2arg-fast ':2arg names shared-args)
     ,@ (add-fast-optimizer-properties ':if-fast ':if names shared-args)
     ,@ (add-fast-optimizer-properties ':if-not-fast ':if-not names shared-args)
     . ,(loop for (type name iargl . extra-decls) in names
	      when name			;ignore seqfast for defun, ignore arglist dcl
	      collect
	      (let ((arg-list nil)
		    (subst-arg (and (member type '(:if :if-not))
				    (or iargl
					(error "No predicate position arg for ~S" name)))))
		(if subst-arg (setq iargl (third (or (assoc ':2arg names)
						     (error "No :2arg case for ~S" name)))))
		(setq arg-list
		      (tkm-merge-arglists
			(test-key-macro-arglist type)
			(or iargl shared-args)
			(and (member type '(:2arg :if :if-not))
			     global-arglist)))
		(if subst-arg
		    (setq arg-list (subst 'predicate subst-arg arg-list)))
		`(,@(if (member type '(:2arg-fast :if-fast :if-not-fast))
			`(defun ,name)
			`(define-keyword-to-positional-arguments-function
			    (,name ,(intern (string-append (string name) "-POSITIONAL")))))
		   ,arg-list
		   ,@(when extra-decls
		       `((declare ,@extra-decls)))
		   ,@(test-key-macro-declarations type)
		   ,@(when downward-funargs
		       `((declare (downward-funarg ,@downward-funargs))))
		   ,@(when other-declarations
		       `((declare ,@other-declarations)))
		   (compiler-let ((si:inhibit-displacing-flag t)
				  ;;Displace will screw multiple expansion of ,body.
				  (*test-key-macro-name* ',name)
				  (*test-key-macro-mode* ',type))
		     (test-key-macro-prologue)
		     (test-key-macro-test-prologue)
		     (test-key-macro-test-if-if-not-fast-prologue)
		     ,(cond ((and fast-clause (eq type ':2arg))
			     `(cond ((and (eq test #'eql)
					  (null key)
					  ,@(tkm-build-fast-case-dequalifiers arg-list)
					  (null test-not))
				     (compiler-let ((*test-key-macro-mode*
						      ',(car fast-clause)))
				       . ,body))
				    ;; FIND can use the ASSOC instruction in some cases
				    ,@(when (eq name 'find)
					`(((and (eq test #'eql)
						(or (eql key #'car) (eql key #'first))
						(listp sequence)
						item	;FIND  ASSOC when item is NIL
						,@(tkm-build-fast-case-dequalifiers arg-list)
						(null test-not))
					   (assoc item sequence))))
				    (t . ,body)))
			    (t `(progn . ,body)))))))))

(defmacro test-key-macro-case-f (fname &body body)
  (loop for (type code) in body
	when (or (eq type t) (eq type *test-key-macro-mode*)
		 (and (consp type)
		      (member *test-key-macro-mode* type)))
	return (progv (list fname) (list *test-key-macro-name*)
		 (eval code))))

(defmacro test-key-macro-case (&body body)
  (loop for (type code) in body
	when (or (eq type t) (eq type 'otherwise) (eq type *test-key-macro-mode*)
		 (and (consp type)
		      (member *test-key-macro-mode* type)))
	return code))

(defmacro test-key-macro-case-macro (&body body)
  `(zl:selectq *test-key-macro-mode*
     . ,body))

(defmacro when-test-key-macro-slow (&body body)
  (test-key-macro-case-macro
     ((:2arg-fast :2arg-test :if-fast :if-not-fast
       :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg- :2arg-char=
       ;;
       ;;        CHAR-EQUAL is in the 36xx ucode.  It's a function on Ivory.
       ;;
       #+3600 :2arg-char-equal) nil)
     (t `(progn . ,body))))

(defmacro when-test-key-macro-test (&body body)
  (test-key-macro-case-macro
     (:2arg-test `(progn . ,body))
     (t nil)))

(defmacro when-test-key-macro-if-if-not-fast (&body body)
  (test-key-macro-case-macro
     ((:if-fast :if-not-fast) `(progn . ,body))
     (t nil)))

(defmacro functionally-evaluate (x)
  `(tagbody loop
     (compiler:%error-when (progn #+3600 (and (symbolp ,x) (not (null ,x)))
				  #+imach (type-member ,x dtp-symbol))
       (setq ,x (symbol-function-cell ,x))
       (go loop))))

(defmacro test-key-macro-prologue ()
  `(when-test-key-macro-slow
     (test-key-macro-case
       (:2arg
	 (progn (if test-not
		    (setq test test-not)
		    (setq not-test t))
		(functionally-evaluate key)
		(functionally-evaluate test)))
       ((:if :if-not)
	(progn (functionally-evaluate predicate)
	       (functionally-evaluate key)))
       (t nil))
     (if (eq key #'identity) (setq key nil))))

(defmacro test-key-macro-test-prologue ()
  `(when-test-key-macro-test
     (functionally-evaluate test)))

(defmacro test-key-macro-test-if-if-not-fast-prologue ()
  `(when-test-key-macro-if-if-not-fast
     (functionally-evaluate predicate)))

(defmacro notnull (x)
  `(not (null ,x)))

;Note: when given two "arguments", this macro passes them to the comparison predicate
;in reverse order.  Thus the one that was extracted from the sequence should be first,
;so that it will be the second argument to the predicate (Mary Poppins page 202).
(defmacro test-key-macro-test (value &optional test-value)
  (test-key-macro-case-macro
    ((:2arg-fast :2arg-seqfast)
      `(eql ,test-value ,value))
    (:2arg
      (if test-value
	 `(eq not-test (notnull
			 (funcall test ,test-value
				,(let-subst '(.test-value.) (list value)
				   `(if key (funcall key .test-value.) .test-value.)))))
	 `(eq not-test
	      (notnull ,(let-subst '(.test-value.) (list value)
				   `(if key (funcall key .test-value.) .test-value.))))))
    (:if `(funcall predicate ,(let-subst '(.test-value.) (list value)
				`(if key (funcall key .test-value.) .test-value.))))
    (:if-not `(not (funcall predicate ,(let-subst '(.test-value.) (list value)
					 `(if key (funcall key .test-value.) .test-value.)))))
    (:if-fast `(funcall predicate ,value))
    (:if-not-fast `(not (funcall predicate ,value)))
    (:2arg-test
      `(funcall test ,test-value ,value))
    (:2arg-=
      `(= ,test-value ,value))
    (:2arg-eq
      `(eq ,test-value ,value))
    (:2arg-<
      `(< ,test-value ,value))
    (:2arg->
      `(> ,test-value ,value))
    (:2arg-
      `( ,test-value ,value))
    (:2arg-
      `( ,test-value ,value))
    (:2arg-char=
      `(char= ,test-value ,value))
    ;;
    ;;        CHAR-EQUAL is in the 36xx ucode.  It's a function on Ivory.
    ;;
    #+3600
    (:2arg-char-equal
      `(char-equal ,test-value ,value))
    (otherwise (error "Unhandled case of test-key-macro"))))

;Same as above but the key is applied to the second value, which came from the first seq
(defmacro test-key-macro-test-2 (value test-value)
  (test-key-macro-case-macro
    ((:2arg-fast :2arg-seqfast)
      `(eql ,test-value ,value))
    (:2arg-test
      `(funcall test ,test-value ,value))
    (:2arg
      `(eq not-test
	   (notnull
	     (funcall test ,(let-subst '(.test-value.) (list test-value)
				       `(if key (funcall key .test-value.) .test-value.))
		      ,value))))
    (:2arg-test
      `(funcall test ,test-value ,value))
    (:2arg-=
      `(= ,test-value ,value))
    (:2arg-eq
      `(eq ,test-value ,value))
    (:2arg-<
      `(< ,test-value ,value))
    (:2arg->
      `(> ,test-value ,value))
    (:2arg-
      `( ,test-value ,value))
    (:2arg-
      `( ,test-value ,value))
    (:2arg-char=
      `(char= ,test-value ,value))
    ;;
    ;;        CHAR-EQUAL is in the 36xx ucode.  It's a function on Ivory.
    ;;
    #+3600
    (:2arg-char-equal
      `(char-equal ,test-value ,value))
    (otherwise (error "Unhandled case of test-key-macro"))))

(defmacro test-key-macro-extract-key (value)
  (test-key-macro-case-macro
    ((:2arg-fast :2arg-seqfast)
      value)
    ((:2arg :if :if-not)
      (let-subst '(.test-value.) (list value)
	`(if key (funcall key .test-value.) .test-value.)))
    ;;
    ;;        This could have been done as part of the first case but keep the common ones at
    ;;        the top of the case to make compilation just a wee bit faster.
    ;;
    ((:2arg-test :if-fast :if-not-fast
      :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg- :2arg-char=
      ;;
      ;;        CHAR-EQUAL is in the 36xx ucode.  It's a function on Ivory.
      ;;
      #+3600 :2arg-char-equal)
     value)
    (otherwise (error "Unhandled case of test-key-macro"))))

(defvar *sequence-macro-vector-or-list* nil)
(defvar *sequence-macro-sequence* nil)

(defmacro with-sequence-macro-list (&body body)
  `(compiler-let ((*sequence-macro-vector-or-list* :list))
     . ,body))

(defmacro with-sequence-macro-vector (&body body)
  `(compiler-let ((*sequence-macro-vector-or-list* :vector))
     . ,body))

;;;The caller has to set "end" in the vector case.

(defmacro sequence-iterator (&rest args)
  (declare (arglist sequence &key forward-form
				  (start 'start sp) (end 'end ep) (rlseq 'rlseq)
				  (backward-form forward-form)
				  (reverse-list-code nil)
				  (reverse-array-code :default)
				  (else-list-form nil)
				  forward-list-only force-fast-with-index
				  list-only))
  (apply #'sequence-iterator-function args))

(eval-when (eval load compile)
(defun sequence-iterator-function		;needed for &key processing
       (sequence &key
		 forward-form
		 (start 'start sp) (end 'end ep)
		 (rlseq 'rlseq)
		 (backward-form nil bfp)
		 (reverse-list-code nil)
		 (reverse-array-code :default)
		 (else-list-form nil)
		 forward-list-only force-fast-with-index list-only)
  (unless bfp (setq backward-form forward-form))
  (if forward-list-only (setq backward-form nil))
  (when (member *test-key-macro-mode*
		'(:2arg-fast :2arg-test :if-fast :if-not-fast
		  :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg- :2arg-char=
		  ;;
		  ;;        CHAR-EQUAL is in the 36xx ucode.
		  ;;        It's a function on Ivory.
		  ;;
		  #+3600 :2arg-char-equal))
    (if (null sp)
	(setq start ''0 backward-form nil))
    (if (and (null ep)
	     (not list-only))
	(setq end `(vector-length ,sequence))))
  (let* ((forward-list-case
	   `(with-sequence-macro-list
	      ,(cond ((not (member *test-key-macro-mode*
				   '(:2arg-fast :2arg-seqfast :2arg-test :if-fast :if-not-fast
				     :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg-
				     :2arg-char=
				     ;;
				     ;;        CHAR-EQUAL is in the 36xx ucode.
				     ;;        It's a function on Ivory.
				     ;;
				     #+3600 :2arg-char-equal)))
		      `(loop for .index. upfrom 0
			     when (and ,end ( .index. ,end)) return nil	;skip finally
			     for .node. on ,sequence
			     when ( .index. ,start) do ,forward-form
			     else do ,else-list-form
			     finally
			       (progn
				 (if (< .index. ,start)
				     (sequence-index-error-f ,sequence ,start))
				 (if ,end
				     (sequence-index-error-f ,sequence ,end)))))
		     (force-fast-with-index
		      `(loop for .index. upfrom 0
			     for .node. on ,sequence
			     do ,forward-form))
		     (t
		      `(loop for .node. on ,sequence
			     do ,forward-form)))))
	 (forward-case
	   (if (or list-only forward-list-only)
	       forward-list-case
	       `(cond ((listp ,sequence)
		       ,forward-list-case)
		      (t
		       (with-sequence-macro-vector
			 (let ((,sequence ,sequence))
			   (declare (array-register ,sequence))
			   ,(if (member *test-key-macro-mode*
					'(:2arg-fast :2arg-test :if-fast :if-not-fast
					  :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg-
					  :2arg-char=
					  ;;
					  ;;        CHAR-EQUAL is in the 36xx ucode.
					  ;;        It's a function on Ivory.
					  ;;
					  #+3600 :2arg-char-equal))
				`(loop for .index. upfrom ,start below ,end
				       do ,forward-form)
				`(loop for .index. upfrom ,start until ( .index. ,end)
				       do ,forward-form)))))))))
    `(compiler-let ((*sequence-macro-sequence* ',sequence))
       ,(if (null backward-form)
	    forward-case
	    `(cond (from-end
		    ,(let ((list-code
			     (cond
			       ((null reverse-list-code)
				'(error "Illegal reverse list case."))
			       ((eq reverse-list-code :default)
				;; This forward-processes in the backwards list case
				;; on the assumption that rlseq and start have been
				;; fudged to skip over the right number of things.
				(if (member *test-key-macro-mode*
					    '(:2arg-fast :2arg-seqfast :2arg-test
					      :if-fast :if-not-fast
					      :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg-
					      :2arg-char=
					      ;;
					      ;;        CHAR-EQUAL is in the 36xx ucode.
					      ;;        It's a function on Ivory.
					      ;;
					      #+3600 :2arg-char-equal))
				    `(with-sequence-macro-list
				       (loop for .index. upfrom ,start
					     for .node. on ,rlseq
					     do ,backward-form))
				    `(with-sequence-macro-list
				       (loop for .index. upfrom ,start
					     when (and ,end ( .index. ,end))
					       return nil		;skip finally
					     for .node. on ,rlseq
					     do ,backward-form
					     finally
					     (if ,end
						 (sequence-index-error-f ,sequence ,end))))))
			       (t
				`(with-sequence-macro-list
				   ,reverse-list-code)))))
		       (if list-only
			   list-code
			   `(if (listp ,sequence) ,list-code
				(with-sequence-macro-vector
				  (let ((,sequence ,sequence))
				    (declare (array-register ,sequence))
				    ,(cond ((null reverse-array-code)
					    '(error "Illegal reverse array case."))
					   ((eq reverse-array-code :default)
					    `(loop for .index. downfrom (1- ,end) to ,start
						   do ,backward-form))
					   (t reverse-array-code))))))))
		   (t ,forward-case))))))
);eval-when

(defmacro sequence-node ()
  (case *sequence-macro-vector-or-list*
    (:list '.node.)
    (t (error "Reference to sequence node in invalid context."))))

(defmacro sequence-element ()
  (case *sequence-macro-vector-or-list*
    (:vector `(aref ,*sequence-macro-sequence* .index.))
    (:list `(car .node.))
    (t (error "Sequence function macros: gross confusion."))))

(defmacro store-sequence-element (val)
  (case *sequence-macro-vector-or-list*
    (:vector `(setf (aref ,*sequence-macro-sequence* .index.) ,val))
    (:list `(rplaca .node. ,val))
    (t (error "Sequence function macros: gross confusion."))))

(defmacro sequence-check-and-default-limits (sequence
					      &optional (start 'start) (end 'end)
					      &environment env)
  (test-key-macro-case-macro
     ((:2arg-fast :2arg-test :if-fast :if-not-fast
       :2arg-= :2arg-eq :2arg-< :2arg-> :2arg- :2arg- :2arg-char=
       ;;
       ;;        CHAR-EQUAL is in the 36xx ucode.  It's a function on Ivory.
       ;;
       #+3600 :2arg-char-equal) nil)
     (:2arg-seqfast
       (once-only-simple-variables (sequence &environment env)
	 `(unless (listp ,sequence)
	    (setq ,end (vector-length ,sequence)))))
     (t (once-only-simple-variables (sequence &environment env)
	  `(unless (listp ,sequence)
	     (let ((length (vector-length ,sequence)))
	       (if ,end
		   (if (> ,end length)
		       (sequence-index-error-f ,sequence ,end))
		   (setq ,end length))
	       (if (> ,start length)
		   (sequence-index-error-f ,sequence ,start))))))))

(defmacro reverse-list-check-macro (item-name)
  `(with-sequence-macro-list
     (when (listp sequence)
       (reverse-either-check-macro ,item-name))))

(defmacro reverse-either-check-macro (item-name)
  `(when from-end
     (when (or count (setq from-end nil))
       (test-key-macro-case-f fname
	 (:2arg
	  `(let ((test-not (if not-test nil test))
		 (test (if not-test test nil)))
	     (reverse-either-check-macro-inner ,fname ,',item-name)))
	 (t `(reverse-either-check-macro-inner ,fname ,',item-name))))))

(defmacro reverse-either-check-macro-inner (fname item-name)
  ;;
  ;;        We don't have to worry about the :2arg-fast, :2arg-test, :if-fast, :if-not-fast,
  ;;        :2arg-=, :2arg-eq, :2arg-<, :2arg->, :2arg-, :2arg-, :2arg-char=, or
  ;;        :2arg-char-equal (3600 only) since invocations of this macro are all wrapped by
  ;;         CLI::WHEN-TEST-KEY-MACRO-SLOW.
  ;;
  `(let ((howmany
	   (test-key-macro-case
	     (:2arg-seqfast
	      (count ,item-name sequence :start start :end end))
	     (:2arg
	      (count ,item-name sequence :test test :test-not test-not :key key
		     :start start :end end))
	     (:if (count-if predicate sequence :key key :start start :end end))
	     (:if-not
	      (count-if-not predicate sequence :key key :start start :end end)))))
     (cond ((zerop howmany) (return-from ,fname sequence))
	   (( howmany count) (setq from-end nil))
	   (t
	    ,(case *sequence-macro-vector-or-list*
	       (:list `(progn
			 (dotimes (ignore start) (setq rlseq (cdr rlseq)))
			 (when end (decf end start))		;rlseq got shorter
			 (decf howmany (if (plusp count) count 0))
			 (multiple-value-setq (rlseq start)
			   (test-key-macro-case
			     (:2arg-seqfast
			      (find-skip-match ,item-name rlseq howmany))
			     (:2arg
			      (find-skip-match ,item-name rlseq howmany :test test
					       :test-not test-not :key key))
			     (:if
			      (find-skip-match-if predicate rlseq howmany :key key))
			     (:if-not
			      (find-skip-match-if-not predicate rlseq howmany :key key))))))
	       (otherwise '(setq skip-count (- howmany (if (plusp count) count 0)))))))))

;;;Macro used in writing optimal list sharing functions.  This basically 
;;;prepares for a nondestructive rplacd, so to speak.
(defmacro unshare-list-macro (output-ptr unshared-output-ptr)
  `(unless (eq ,output-ptr ,unshared-output-ptr)
     (let ((haumany (loop for x first ,unshared-output-ptr then (cdr x)
			  until (eq x ,output-ptr)
			  count t)))
       (setq ,unshared-output-ptr
	     (setq ,output-ptr
		   (cond ((= haumany 1)
			  (cdr (rplacd ,unshared-output-ptr
				       (cons (cadr ,unshared-output-ptr) nil))))
			 (t (let ((chunk (make-list haumany)))
			      (prog1
				(loop for elt in (cdr ,unshared-output-ptr)
				      and node on chunk
				      do (rplaca node elt)
				      when (null (cdr node))
				      return node)
				(rplacd ,unshared-output-ptr chunk))))))))))

;;;Bos Gruniens is the genus/species of the Yak.

;;; This has been moved here from sage to avoid having to have sage loaded 
;;; before macivory support and reorder-sequence.

;;; Iterate over sequence(s), maybe returning a sequence of what the body evaluates to.
;;; (domap 'list ((x vector-of-foos) (y list-of-bars)) (mumble x y))
;;;==> (map 'list (named-lambda domap (x y) (mumble x y)) vector-of-foos list-of-bars)
;;; domap is to map as let is to ((lambda ---) ---).  That is, it gets the
;;; name of the iteration variable(s) next to the thing(s) being iterated over, instead
;;; of having them separated by the entire body of the iteration.

(defmacro domap (result-type bindings &body body)
  `(map ,result-type
	#'(zl:named-lambda domap ,(mapcar #'first bindings) ,@body)
	,@(mapcar #'second bindings)))
