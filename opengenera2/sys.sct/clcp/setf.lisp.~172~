;;; -*- Mode:LISP; Package:Language-Tools; Syntax:Common-Lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Generalized-variable facilities

;--- Common-Lisp conversion issues:
;--- Need a better way to report macroexpansion time errors, at least
;---  calling compiler:warn becomes a bit clumsy.  cf. defsubst-error.
;---  Actually, as far as I can see compiler:warn is brain-damaged, and
;---  what should happen is simply that signalling an error while
;---  expanding a macro should be handled specially, for certain flavors.
;---  All such errors should go in the warnings data base (except file
;---  errors perhaps?); certain errors should be just printed and not
;---  go into the debugger.  Also certain errors can be suppressed entirely.
;--- use Common Lisp error system to signal errors

;;; The entry functions to this module are:
;;;   SETF, PSETF, SHIFTF, ROTATEF, DEFSETF, DEFINE-SETF-METHOD, LOCF, DEFLOCF
;;;   DEFINE-SETF-EQUIVALENCE, DEFINE-MODIFY-MACRO, INCF, DECF, PUSH, PUSHNEW, POP
;;;   GET-SETF-METHOD, GET-SETF-METHOD-MULTIPLE-VALUE
;;; In addition the following, which aren't global, but need to be called
;;; by some user-written functions, probably:
;;;   DEFINE-MODIFY-METHOD, EXPAND-MODIFY-MACRO

(EXPORT '(SETF PSETF SHIFTF ROTATEF DEFSETF DEFINE-SETF-METHOD LOCF DEFLOCF
	  DEFINE-SETF-EQUIVALENCE DEFINE-MODIFY-MACRO INCF DECF PUSH PUSHNEW POP
	  GET-SETF-METHOD GET-SETF-METHOD-MULTIPLE-VALUE
	  DEFINE-MODIFY-METHOD EXPAND-MODIFY-MACRO))

;;; See SETF.DOC for some important information about internal conventions
;;; and for documentation of what the entry functions are supposed to do

;;; Assumptions about compiler optimizations:
;;; MULTIPLE-VALUE-BIND with one variable is no less efficient than LET
;;; CAR for effect merely compiles its argument for effect (for POP).

;;; It would certainly be nice if we knew what was being macroexpanded for
;;; value, in which case we could know that a variable that appears to be
;;; used twice is really only used once and optimize it out.  This could
;;; at least be done internally to complex forms generated entirely here.
;;; [LET-VALUE now takes care of some cases of this.]

;;; SETF of LET would be nice, e.g. for SETF'ing complex DEFSUBSTs that require
;;; temporary variables.  It can't really be made to work in this scheme, because
;;; some of the bindings generated need to be sequential and some need to be parallel.

;;; SETF macro and its variants

;The SETF macro itself is in SETF-INSTALL
(DEFUN EXPAND-SETF (PAIRS ENV &AUX REFERENCE TEM)
  (IF (ODDP (LIST-LENGTH PAIRS))
      (COMPILER:WARN () "Wrong number of arguments to SETF (must be even)"))
  (COND ((NULL PAIRS) NIL)
	((CDDR PAIRS)
	 (CONS 'PROGN (LOOP FOR (REFERENCE VALUE) ON PAIRS BY 'CDDR
			    COLLECT (EXPAND-SETF (LIST REFERENCE VALUE) ENV))))
	((VARIABLEP (SETQ REFERENCE (FIRST PAIRS)) ENV)
	 (CONS 'SETQ PAIRS))
	(T (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM)
	       (GET-SETF-METHOD-MULTIPLE-VALUE REFERENCE ENV)
	     (COND ;; Multiple-value case is less optimal
		   ((CDR STORES)
		    (LET*-SUBST VARS VALS
				`(MULTIPLE-VALUE-BIND ,STORES ,(SECOND PAIRS)
				   ,STORE-FORM)
				ENV))
		   ;; Try to optimize out an unnecessary variable just being used
		   ;; to return the right value.
		   ((AND (LISTP STORE-FORM)
			 (EQ (FIRST STORE-FORM) 'LET-VALUE)
			 (EQ (THIRD STORE-FORM) (FIRST STORES)))
		    (IF (EQ (CAR (LET-SUBST (LIST (SECOND STORE-FORM)) (CDR PAIRS)
					    (SETQ TEM `(PROGN ,(FOURTH STORE-FORM)
							      ,(SECOND STORE-FORM)))
					    ENV))
			    'PROGN)
			;; The store form may be evaluated twice, so flush the LET-VALUE
			(LET*-SUBST (APPEND VARS STORES) (APPEND VALS (CDR PAIRS))
				    (SUBST (THIRD STORE-FORM) (SECOND STORE-FORM) TEM)
				    ENV)
			;; Merge the LET-VALUE and the LET-SUBST, to generate only one temp
			(LET*-SUBST VARS VALS
				    `(LET-VALUE ,(FIRST STORES) ,(SECOND PAIRS)
				       ,(SUBST (FIRST STORES) (SECOND STORE-FORM)
					       (FOURTH STORE-FORM)))
				    ENV)))
		   ;; Normal case
		   (T
		    (LET*-SUBST (APPEND VARS STORES) (APPEND VALS (CDR PAIRS))
				STORE-FORM
				ENV)))))))

(DEFMACRO PSETF (&REST PAIRS &ENVIRONMENT ENV)
  (IF (ODDP (LIST-LENGTH PAIRS))
      (COMPILER:WARN () "Wrong number of arguments to PSETF (must be even)"))
  `(PROGN ,(EXPAND-PSETF PAIRS ENV) NIL))

(DEFUN EXPAND-PSETF (PAIRS ENV)
  ;; Accumulate the reference side-effects and the values from left to right into
  ;; temporary variables and the prog1 stack respectively.  Then do the assignments
  ;; from right to left.
  (COND ((NULL PAIRS) NIL)
	((NULL (CDDR PAIRS)) (EXPAND-SETF PAIRS ENV))
	(T (EXPAND-SETF (LIST (FIRST PAIRS)
			      `(PROG1 ,(SECOND PAIRS) ,(EXPAND-PSETF (CDDR PAIRS) ENV)))
			ENV))))

(DEFUN (:PROPERTY PSETF :UNDO-FUNCTION) (FORM)
  ;; The order of the side-effects in PSETF is not well-defined (CLtL, p97)
  ;; so no particular care is needed about order here.
  `(PSETF ,@(LOOP FOR PAIRS ON (CDR FORM) BY 'CDDR
		  NCONC (LIST (CAR PAIRS) `',(EVAL (CAR PAIRS))))))

(DEFMACRO SHIFTF (&REST REFERENCES-AND-VALUES &ENVIRONMENT ENV)
  ;; Move all the bindings to the outside.  Stack up the store values with PROG1.
  ;; Note that (SHIFTF a) = a, (SHIFTF) = NIL.  These are both extensions to CL!
  (LOOP WHILE (CDR REFERENCES-AND-VALUES)
	AS REFERENCE = (POP REFERENCES-AND-VALUES)
	WITH (VARS VALS STORES STORE-FORM ACCESS-FORM)
	DO (MULTIPLE-VALUE-SETQ (VARS VALS STORES STORE-FORM ACCESS-FORM)
	     (GET-SETF-METHOD REFERENCE ENV))
	APPEND VARS INTO ALL-VARS
	APPEND VALS INTO ALL-VALS
	APPEND STORES INTO ALL-STORES
	COLLECT STORE-FORM INTO ALL-STORE-FORMS
	COLLECT ACCESS-FORM INTO ALL-ACCESS-FORMS
	FINALLY (RETURN (LET*-SUBST ALL-VARS ALL-VALS
				    (LET ((*SIMPLE-VARIABLES* ALL-VARS))
				      (SHIFTF-NEST ALL-STORES ALL-STORE-FORMS
						   ALL-ACCESS-FORMS
						   (CAR REFERENCES-AND-VALUES)
						   ENV))
				    ENV))))

(DEFMACRO ROTATEF (&REST REFERENCES &ENVIRONMENT ENV)
  ;; Move all the bindings to the outside.  Stack up the store values with PROG1.
  (LOOP FOR REFERENCE IN REFERENCES
	WITH (VARS VALS STORES STORE-FORM ACCESS-FORM)
	DO (MULTIPLE-VALUE-SETQ (VARS VALS STORES STORE-FORM ACCESS-FORM)
	     (GET-SETF-METHOD REFERENCE ENV))
	APPEND VARS INTO ALL-VARS
	APPEND VALS INTO ALL-VALS
	APPEND STORES INTO ALL-STORES
	COLLECT STORE-FORM INTO ALL-STORE-FORMS
	COLLECT ACCESS-FORM INTO ALL-ACCESS-FORMS
	FINALLY (RETURN `(PROGN
			   ,(AND ALL-STORES
				 (LET*-SUBST ALL-VARS ALL-VALS
				   (LET ((*SIMPLE-VARIABLES* ALL-VARS))
				     (LET-SUBST (LIST (FIRST ALL-STORES))
						(LIST (SHIFTF-NEST (CDR ALL-STORES)
								   (CDR ALL-STORE-FORMS)
								   (CDR ALL-ACCESS-FORMS)
								   (CAR ALL-ACCESS-FORMS)
								   ENV))
						(FIRST ALL-STORE-FORMS)
						ENV))
				   ENV))
			   NIL))))

(DEFUN SHIFTF-NEST (STORES STORE-FORMS ACCESS-FORMS LAST-ACCESS-FORM ENV)
  (IF (NULL ACCESS-FORMS)
      LAST-ACCESS-FORM
      `(PROG1 ,(CAR ACCESS-FORMS)
	      ,(LET-SUBST (LIST (CAR STORES))
			  (WITH-STACK-LIST* (*SIMPLE-VARIABLES* (CAR STORES)
								*SIMPLE-VARIABLES*)
			    (LIST (SHIFTF-NEST (CDR STORES) (CDR STORE-FORMS)
					       (CDR ACCESS-FORMS) LAST-ACCESS-FORM
					       ENV)))
			  (CAR STORE-FORMS)
			  ENV))))

;;; DEFSETF and SETF-method handling

;; This is unfortunate, but the CLM doesn't let us pass this around normally.
(DEFVAR *GET-SETF-METHOD-INTERPRETER-ENVIRONMENT* NIL)

;Require that multiple values not be involved, because they don't fit
;into the temporary-variable-binding model everything is built on
(DEFUN GET-SETF-METHOD (REFERENCE &OPTIONAL ENVIRONMENT)
  (DECLARE (VALUES VARS VALS STORES STORE-FORM ACCESS-FORM))
  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)
      (GET-SETF-METHOD-MULTIPLE-VALUE REFERENCE ENVIRONMENT)
    (OR (= (LIST-LENGTH STORES) 1)
	(COMPILER:WARN '(:FATAL T)
		       "Unable to handle the reference ~S, which wants ~D values"
		       REFERENCE (LIST-LENGTH STORES)))
    (VALUES VARS VALS STORES STORE-FORM ACCESS-FORM)))

(DEFUN GET-SETF-METHOD-MULTIPLE-VALUE
       (REFERENCE &OPTIONAL ENVIRONMENT &AUX METHOD DEF)
  (DECLARE (VALUES VARS VALS STORE-VARS STORE-FORM ACCESS-FORM))
  (WHEN (OR (EQ ENVIRONMENT NIL)
	    (EQ ENVIRONMENT T))
    ;; Compatibility with earlier SCL extension where the optional argument meant
    ;; FOR-EFFECT.
    (SETQ ENVIRONMENT *GET-SETF-METHOD-INTERPRETER-ENVIRONMENT*))
  (LOOP WITH ORIGINAL-REFERENCE = REFERENCE DO	;Loop expanding macros
    (FLET ((INVALID ()
	     (COMPILER:WARN '(:FATAL T)
			    "~S is not valid as a generalized variable reference~
				~:[ (macroexpanded from ~S)~]"
			    REFERENCE (EQ REFERENCE ORIGINAL-REFERENCE) ORIGINAL-REFERENCE))
	   (GET-TRIVIAL-SETF-METHOD (REFERENCE METHOD)
	     (LET ((STORE (LIST (GENSYM)))
		   (VARS NIL) (VALS NIL) (ARGS NIL))
	       (DOLIST (ARG (CDR REFERENCE))
		 (IF (CONSTANTP ARG ENVIRONMENT)
		     (PUSH ARG ARGS)
		     (LET ((TEMP (GENSYM)))
		       (PUSH TEMP ARGS)
		       (PUSH TEMP VARS)
		       (PUSH ARG VALS))))
	       (SETF VARS (REVERSE VARS))
	       (SETF VALS (REVERSE VALS))
	       (SETF ARGS (REVERSE ARGS))
	       (VALUES VARS VALS STORE
		       (IF (SYMBOLP METHOD)
			   `(,METHOD ,@ARGS ,@STORE)
			   (ECASE (FIRST METHOD)
			     (SETF `(FUNCALL #',METHOD ,@ARGS ,@STORE))
			     (FUTURE-COMMON-LISP:SETF `(FUNCALL #',METHOD ,@STORE ,@ARGS))))
		       `(,(FIRST REFERENCE) ,@ARGS)))))
      (COND ((VARIABLEP REFERENCE ENVIRONMENT)
	     (RETURN (LET ((STORE (GENSYM)))
		       (VALUES () () (LIST STORE) `(SETQ ,REFERENCE ,STORE) REFERENCE))))
	    ((AND (SYMBOLP REFERENCE)
		  (NOT (EQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENVIRONMENT))))))
	    ((OR (ATOM REFERENCE) (NOT (SYMBOLP (CAR REFERENCE))))
	     (INVALID))
	    ((SETQ DEF (SI:LOCAL-FUNCTION-DEFINITION (CAR REFERENCE) ENVIRONMENT))
	     (OR (AND (CONSP DEF)
		      (EQ (FIRST DEF) 'DEFUN-IN-FLAVOR)
		      (LOCATION-BOUNDP (THIRD DEF))
		      (SETQ METHOD (SI:DEBUGGING-INFO-USER-ENTRY (LOCATION-CONTENTS (THIRD DEF))
								 'INLINE-FORM))
		      (SI:ENV-DECLARATIONS-INLINE-P (INLINE-FORM-NAME (SECOND METHOD))
						    ENVIRONMENT)
		      (NOT (EQ REFERENCE
			       (SETQ REFERENCE (EXPAND-INLINE-DEFUN-IN-FLAVOR
						 (SECOND METHOD) REFERENCE
						 ENVIRONMENT)))))
		 (NOT (EQ REFERENCE
			  (SETQ REFERENCE
				(MACROEXPAND-1
				  REFERENCE
				  ENVIRONMENT))))
		 (RETURN
		   (GET-TRIVIAL-SETF-METHOD
		     REFERENCE (LET ((SETF-LIST `(SETF ,(CAR REFERENCE))))
				 (IF (SI:LOCAL-FUNCTION-DEFINITION SETF-LIST ENVIRONMENT)
				     SETF-LIST
				     `(FUTURE-COMMON-LISP:SETF ,(CAR REFERENCE))))))))
	    ;; look for (FUNCALL #'FUNCTION ...) where FUNCTION is an inline
	    ;; this is generated by the compiler for DEFSUBST-IN-FLAVORs
	    ((AND (EQ (FIRST REFERENCE) 'FUNCALL)
		  (CONSP (REST REFERENCE))
		  (CONSP (SECOND REFERENCE))
		  (EQ (FIRST (SECOND REFERENCE)) 'FUNCTION)
		  (CONSP (REST (SECOND REFERENCE)))
		  (SI:ENV-DECLARATIONS-INLINE-P (SECOND (SECOND REFERENCE))
						ENVIRONMENT)
		  (SETQ METHOD (FIND-INLINE-FORM-METHOD
				 (SECOND (SECOND REFERENCE))
				 ENVIRONMENT))
		  (STACK-LET* ((FAKE-FORM `(,(SECOND (SECOND REFERENCE))
					    ,@(REST (REST REFERENCE))))
			       (EXPANDED-FORM (EXPAND-INLINE-FORM
						METHOD FAKE-FORM
						ENVIRONMENT
						:NEVER-BIND-LOCALS T)))
		    (UNLESS (EQ FAKE-FORM EXPANDED-FORM)
		      (SETQ REFERENCE EXPANDED-FORM)
		      T))))
	    ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'TRIVIAL-SETF-METHOD))
	     (RETURN (GET-TRIVIAL-SETF-METHOD REFERENCE METHOD)))
	    ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'SETF-EQUIVALENCE))
	     (SETQ REFERENCE (LIST (FIRST METHOD) (CONS (SECOND METHOD) (CDR REFERENCE)))))
	    ((SETQ METHOD
		   (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'SETF-METHOD-WITH-ENVIRONMENT))
	     (RETURN (FUNCALL METHOD REFERENCE ENVIRONMENT)))
	    ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'SETF-METHOD))
	     (LET ((*GET-SETF-METHOD-INTERPRETER-ENVIRONMENT* ENVIRONMENT))
	       (RETURN (FUNCALL METHOD REFERENCE))))
	    ((COMPILER:FILE-DECLARATION (CAR REFERENCE) 'DERIVED-SETF-FUNCTION)
	     (RETURN (GET-TRIVIAL-SETF-METHOD REFERENCE `(SETF ,(CAR REFERENCE)))))
	    ((COMPILER:FILE-DECLARATION (CAR REFERENCE)
					'DERIVED-FUTURE-COMMON-LISP-SETF-FUNCTION)
	     (RETURN (GET-TRIVIAL-SETF-METHOD REFERENCE
					      `(FUTURE-COMMON-LISP:SETF ,(CAR REFERENCE)))))
	    ((SETQ METHOD (GET (CAR REFERENCE) 'TRIVIAL-SETF-METHOD))
	     (RETURN (GET-TRIVIAL-SETF-METHOD REFERENCE METHOD)))
	    ((SETQ METHOD (GET (CAR REFERENCE) 'SETF-EQUIVALENCE))
	     (SETQ REFERENCE (LIST (FIRST METHOD) (CONS (SECOND METHOD) (CDR REFERENCE)))))
	    ((SETQ METHOD (GET (CAR REFERENCE) 'SETF-METHOD-WITH-ENVIRONMENT))
	     (RETURN (FUNCALL METHOD REFERENCE ENVIRONMENT)))
	    ((SETQ METHOD (GET (CAR REFERENCE) 'SETF-METHOD))
	     (LET ((*GET-SETF-METHOD-INTERPRETER-ENVIRONMENT* ENVIRONMENT))
	       (RETURN (FUNCALL METHOD REFERENCE))))
	    ((NEQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENVIRONMENT))))
	    ((AND (SETQ METHOD (GET (CAR REFERENCE) 'DERIVED-SETF-FUNCTION))
		  (LOCATION-BOUNDP METHOD))
	     (RETURN (GET-TRIVIAL-SETF-METHOD REFERENCE `(SETF ,(CAR REFERENCE)))))
	    ((AND (SETQ METHOD (GET (CAR REFERENCE) 'DERIVED-FUTURE-COMMON-LISP-SETF-FUNCTION))
		  (LOCATION-BOUNDP METHOD))
	     (RETURN
	       (GET-TRIVIAL-SETF-METHOD REFERENCE `(FUTURE-COMMON-LISP:SETF ,(CAR REFERENCE)))))
	    ((AND (SETQ METHOD (GET (CAR REFERENCE) 'SI:DEFSTRUCT-SLOT))
		  (SI:DEFSTRUCT-SLOT-READ-ONLY-P (CAR METHOD) (CDR METHOD)))
	     (COMPILER:WARN '(:FATAL T)
			    "~S cannot be SETF'ed because it is a read-only structure slot~
			   ~:[ (macroexpanded from ~S)~]"
			    (CAR REFERENCE)
			    (EQ REFERENCE ORIGINAL-REFERENCE) ORIGINAL-REFERENCE))
	    ((AND (SETQ METHOD (FIND-INLINE-FORM-METHOD (CAR REFERENCE)
							ENVIRONMENT))
		  (SI:ENV-DECLARATIONS-INLINE-P (FIRST REFERENCE)
						ENVIRONMENT)
		  (NOT (EQ REFERENCE
			   (SETQ REFERENCE (EXPAND-INLINE-FORM METHOD REFERENCE
							       ENVIRONMENT
							       :NEVER-BIND-LOCALS T))))))
	    ((NOT (SPECIAL-FORM-P (CAR REFERENCE)))
	     (RETURN (GET-TRIVIAL-SETF-METHOD
		       REFERENCE `(FUTURE-COMMON-LISP:SETF ,(CAR REFERENCE)))))
	    (T
	     (INVALID))))))

(DEFUN EXPAND-INLINE-DEFUN-IN-FLAVOR (METHOD FORM ENV)
  (STACK-LET ((FORM-WITH-FLAVOR-ARGS `(,(FIRST FORM)
				       #+3600 SELF #+3600 SELF-MAPPING-TABLE
				       #+IMACH SELF-MAPPING-TABLE #+IMACH SELF
				       ,@(REST FORM))))
    (LET ((EXPANDED-FORM (EXPAND-INLINE-FORM METHOD FORM-WITH-FLAVOR-ARGS ENV
					     :NEVER-BIND-LOCALS T)))
      (IF (EQ EXPANDED-FORM FORM-WITH-FLAVOR-ARGS)
	  FORM					;it wasn't really expanded
	  EXPANDED-FORM))))

(DEFPROP DEFSETF "SETF function" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFSETF (ACCESS-FUNCTION STORING-FUNCTION-OR-ARGS &OPTIONAL STORE-VARIABLES
		   &BODY BODY
		   &AUX
		   (NAME ACCESS-FUNCTION)
		   (SEND-CASE NIL)
		   (TRIVIAL-METHOD-PROPERTY 'TRIVIAL-SETF-METHOD)
		   (METHOD-PROPERTY 'SETF-METHOD-WITH-ENVIRONMENT))
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION ACCESS-FUNCTION)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFSETF))
    ;; Determine whether we are dealing in functions or messages
    (COND ((SYMBOLP ACCESS-FUNCTION)
	   (UNLESS (OR (FDEFINEDP ACCESS-FUNCTION)
		       (COMPILER:FUNCTION-DEFINED-P ACCESS-FUNCTION))
	     (COMPILER:WARN-1 'COMPILER:FUNCTION-REFERENCED-BUT-NOT-DEFINED :DELAYED T
			      :MESSAGE "DEFSETF of ~S may be a typographical error since ~
				~:*~S does not currently have a function definition."
			      :REFERENCED-FUNCTION ACCESS-FUNCTION)))
	  ((AND (LISTP ACCESS-FUNCTION)
		(EQ (FIRST ACCESS-FUNCTION) 'SEND)
		(SYMBOLP (SECOND ACCESS-FUNCTION))
		(NULL (CDDR ACCESS-FUNCTION)))
	   (SETQ NAME (SECOND ACCESS-FUNCTION)
		 SEND-CASE T
		 TRIVIAL-METHOD-PROPERTY 'TRIVIAL-SETF-SEND-METHOD
		 METHOD-PROPERTY 'SETF-SEND-METHOD-WITH-ENVIRONMENT))
	  (T (COMPILER:WARN '(:FATAL T)
			    "~S is unrecognizable: either a function name or (SEND message) is required"
			    ACCESS-FUNCTION)))
    (WHEN (NULL BODY)
      (WHEN (NOT SEND-CASE)
	;;--- Would like to be able to pass DEFSETF as a definition-type argument here
	(COMPILER:FUNCTION-REFERENCED STORING-FUNCTION-OR-ARGS ACCESS-FUNCTION))
      (RETURN-FROM DEFSETF
	`(PROGN
	   ,@(WHEN STORE-VARIABLES
	       `((SETF (DOCUMENTATION ',NAME 'DEFSETF) ',STORE-VARIABLES)))
	   (,@(IF SEND-CASE
		  '(PROGN)
		  `(SYS:MULTIPLE-DEFINITION ,NAME DEFSETF))
	    (SI:DEFINE-SETF-PROPERTY ',NAME ',TRIVIAL-METHOD-PROPERTY
	      ',STORING-FUNCTION-OR-ARGS))
	   (EVAL-WHEN (COMPILE)
	     (SI:DEFINE-COMPILE-TIME-SETF-PROPERTY ',NAME ',TRIVIAL-METHOD-PROPERTY
	       ',STORING-FUNCTION-OR-ARGS)))))
    ;; Functional case
    (LET ((LAMBDA-LIST STORING-FUNCTION-OR-ARGS)
	  (VARIABLES NIL)
	  (FORM-VAR (GENSYM))
	  (ACCESS-FORM-VAR NIL)
	  (ENV-VAR NIL)
	  (NEW-LAMBDA-LIST NIL)
	  (OPERATION-VAR (AND SEND-CASE (GENSYM)))
	  (TEMP-VARS (GENSYM))
	  (TEMP-VALS (GENSYM))
	  (TEMP-FORM (GENSYM)))
      ;; LMFS:DEFSTORAGE needs to get hold of the environment and the whole
      ;; form for some reason.
      (WHEN (EQ (CAR LAMBDA-LIST) '&WHOLE)
	(POP LAMBDA-LIST)
	(SETQ ACCESS-FORM-VAR (POP LAMBDA-LIST)))
      (LOOP WHILE LAMBDA-LIST
	    FOR ELT = (POP LAMBDA-LIST)
	    DOING
	(COND ((EQ ELT '&ENVIRONMENT)
	       (SETQ ENV-VAR (POP LAMBDA-LIST)))
	      (T (PUSH ELT NEW-LAMBDA-LIST))))
      (WHEN (NULL ENV-VAR)
	(SETQ ENV-VAR (GENSYM)))
      (WHEN (NULL ACCESS-FORM-VAR)
	(SETQ ACCESS-FORM-VAR (GENSYM)))
      (SETQ NEW-LAMBDA-LIST (NREVERSE NEW-LAMBDA-LIST))
      (WHEN SEND-CASE			;Insert extra arg, like defmethod
	(SETQ NEW-LAMBDA-LIST `(,(FIRST NEW-LAMBDA-LIST) ,OPERATION-VAR
				,@(REST NEW-LAMBDA-LIST))))
      (LT:MAP-OVER-LAMBDA-LIST
	NEW-LAMBDA-LIST
	#'(LAMBDA (LIST TYPE)
	    (LET ((ITEM (FIRST LIST)))
	      (ECASE TYPE
		((:REQUIRED :REST)
		 (PUSH ITEM VARIABLES))
		((:OPTIONAL :KEY :AUX)
		 (IF (ATOM ITEM)
		     (PUSH ITEM VARIABLES)
		     (LET ((VARIABLE (FIRST ITEM)))
		       (WHEN (CONSP VARIABLE)
			 ;; &key ((keyword variable) ..)
			 (SETQ VARIABLE (SECOND VARIABLE)))
		       (PUSH VARIABLE VARIABLES)
		       (UNLESS (NULL (REST ITEM))
			 (UNLESS (NULL (REST (REST ITEM)))
			   (PUSH (THIRD ITEM) VARIABLES))))))
		((:ALLOW-OTHER-KEYS))))))
      (LOOP FOR V IN STORE-VARIABLES DO
	(UNLESS (AND (SYMBOLP V) (NOT (MEMBER V LAMBDA-LIST-KEYWORDS)))
	  (COMPILER:WARN () "~S is not allowed in a DEFSETF store-variables list" V)))
      (MULTIPLE-VALUE-BIND (DECLARATIONS SPECIALS BODY DOCUMENTATION DEBUGGING-INFO
			    VAR-DCLS UNSPECIALS FUN-DCLS)
	  (SI:PARSE-BODY-DECLARATIONS BODY NIL `(,ENV-VAR ,ACCESS-FORM-VAR ,@NEW-LAMBDA-LIST))
	(DECLARE (IGNORE SPECIALS UNSPECIALS))
	(LET* ((STORES (MAPCAR #'(LAMBDA (SYM) (DECLARE (IGNORE SYM)) (GENSYM))
			       STORE-VARIABLES))
	       (BODY `(MULTIPLE-VALUE-BIND (,TEMP-VARS ,TEMP-VALS ,TEMP-FORM)
			  (SETF-DESTRUCTURE (CDR ,FORM-VAR) ,ENV-VAR)
			(DESTRUCTURING-BIND ,NEW-LAMBDA-LIST ,TEMP-FORM
			  (DECLARE ,@(SI:RECONSTITUTE-BODY-DECLARATIONS
				       VAR-DCLS FUN-DCLS `(,FORM-VAR ,ENV-VAR) NIL))
			  ,@(WHEN SEND-CASE
			      `(,OPERATION-VAR))
			  
			  (LET ((,ACCESS-FORM-VAR
				 `(,',(IF SEND-CASE 'SEND ACCESS-FUNCTION)
				   ,@,TEMP-FORM))
				,@(MAPCAR #'(LAMBDA (VAR GENSYM) `(,VAR ',GENSYM))
					  STORE-VARIABLES STORES))
			    (VALUES ,TEMP-VARS
				    ,TEMP-VALS
				    ',STORES
				    (PROGN ,@BODY)
				    ,ACCESS-FORM-VAR)))))
	       (HELPER `(:PROPERTY ,NAME ,(IF SEND-CASE
					      'SETF-SEND-METHOD-WITH-ENVIRONMENT-INTERNAL
					      'SETF-METHOD-WITH-ENVIRONMENT-INTERNAL))))
	  `(PROGN
	     ,@(AND DOCUMENTATION
		    `((SETF (DOCUMENTATION ',NAME 'DEFSETF) ,DOCUMENTATION)))
	     (,@(IF SEND-CASE
		    '(PROGN)
		    `(SYS:MULTIPLE-DEFINITION ,NAME DEFSETF))
	      (DEFUN ,HELPER (,FORM-VAR ,ENV-VAR)
		(DECLARE (FUNCTION-PARENT ,ACCESS-FUNCTION DEFSETF)
			 ,@(SI:RECONSTITUTE-BODY-DECLARATIONS
			     VAR-DCLS FUN-DCLS VARIABLES NIL)
			 ,@DECLARATIONS
			 ,@DEBUGGING-INFO)
		,BODY)
	      (SI:DEFINE-SETF-PROPERTY ',NAME ',METHOD-PROPERTY #',HELPER))
	     (EVAL-WHEN (COMPILE)
	       (SI:DEFINE-COMPILE-TIME-SETF-PROPERTY ',NAME ',METHOD-PROPERTY
		 #'(LAMBDA (,FORM-VAR ,ENV-VAR)
		     (DECLARE ,@(SI:RECONSTITUTE-BODY-DECLARATIONS
				  VAR-DCLS FUN-DCLS VARIABLES NIL)
			      ,@DECLARATIONS
			      ,@DEBUGGING-INFO)
		     ,BODY)))))))))

(DEFUN SETF-DESTRUCTURE (FORM ENVIRONMENT)
  (DECLARE (VALUES TEMPS TEMPTED-VALUES TEMPTED-FORM))
  (LET ((TEMPS NIL)
	(TEMPTED-VALUES NIL)
	(TEMPTED-FORM NIL))
    (LOOP FOR ELT IN FORM DOING
      (COND ((CONSTANTP ELT ENVIRONMENT)
	     (PUSH ELT TEMPTED-FORM))
	    (T (LET ((SYM (GENSYM)))
		 (PUSH SYM TEMPS)
		 (PUSH SYM TEMPTED-FORM)
		 (PUSH ELT TEMPTED-VALUES)))))
    (VALUES (NREVERSE TEMPS)
	    (NREVERSE TEMPTED-VALUES)
	    (NREVERSE TEMPTED-FORM))))

;;; This is needed by pre-8.1 compiled code -- Cyphers
(DEFUN HELP-DEFSETF (ARGS STORE-VARIABLES ACCESS-FUNCTION SEND-CASE BODY FORM
		     &AUX WHOLE-ARGUMENT)
  ;; This crock is for BSG, who needs it to convert DEFSTORAGE.
  (WHEN (EQ (FIRST ARGS) '&WHOLE)
    (POP ARGS)
    (SETF WHOLE-ARGUMENT (POP ARGS)))
  (MULTIPLE-VALUE-BIND (TEMP-VARS TEMP-VALS ARG-VARS ARG-VALS NEW-ARG-LIST)
      (MATCH-SOURCE-ARGS-TO-LAMBDA-LIST ARGS (REST FORM) :QUOTE-ARGUMENTS T)
    (LET ((ACCESS-FORM `(,(IF SEND-CASE 'SEND ACCESS-FUNCTION) ,@NEW-ARG-LIST)))
      (WHEN WHOLE-ARGUMENT
	(PUSH WHOLE-ARGUMENT ARG-VARS)
	(PUSH `',ACCESS-FORM ARG-VALS))
      (LET ((STORES (MAPCAR #'(LAMBDA (IGNORE) (GENSYM)) STORE-VARIABLES)))
	(VALUES TEMP-VARS
		TEMP-VALS
		STORES
		(LET ((PATTERN `(LET* (,@(MAPCAR #'LIST ARG-VARS ARG-VALS)
				       ,@(MAPCAR #'(LAMBDA (VAR GENSYM)
						     `(,VAR ',GENSYM))
						 STORE-VARIABLES STORES)
				       )
				  ,@BODY)))
		  (EVAL PATTERN))
		ACCESS-FORM)))))

(DEFPROP DEFINE-SETF-METHOD DEFSETF ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFINE-SETF-METHOD (ACCESS-FUNCTION LAMBDA-LIST &BODY BODY)
  (CHECK-TYPE ACCESS-FUNCTION SYMBOL)
  (LET ((FORM-VAR NIL)
	(ENV-VAR NIL)
	(ENV-VAR-P NIL)
	(NEW-LAMBDA-LIST NIL))
    (WHEN (EQ (CAR LAMBDA-LIST) '&WHOLE)
      (POP LAMBDA-LIST)
      (SETQ FORM-VAR (POP LAMBDA-LIST)))
    (LOOP WHILE LAMBDA-LIST
	  FOR ELT = (POP LAMBDA-LIST)
	  DOING
      (COND ((EQ ELT '&ENVIRONMENT)
	     (SETQ ENV-VAR (POP LAMBDA-LIST))
	     (SETQ ENV-VAR-P T))
	    (T (PUSH ELT NEW-LAMBDA-LIST))))
    (WHEN (NULL ENV-VAR)
      (SETQ ENV-VAR (GENSYM)))
    (WHEN (NULL FORM-VAR)
      (SETQ FORM-VAR (GENSYM)))
    (SETQ NEW-LAMBDA-LIST (NREVERSE NEW-LAMBDA-LIST))
    (LET ((FORM `(DESTRUCTURING-BIND ,NEW-LAMBDA-LIST (CDR ,FORM-VAR) ,@BODY)))
      `(PROGN
	 (SYS:MULTIPLE-DEFINITION ,ACCESS-FUNCTION DEFINE-SETF-METHOD
	   ,@(WHEN (STRINGP (CAR BODY))
	       `((SETF (DOCUMENTATION ',ACCESS-FUNCTION 'DEFSETF) ,(POP BODY))))
	   (DEFUN (:PROPERTY ,ACCESS-FUNCTION SETF-METHOD-INTERNAL-WITH-ENVIRONMENT)
		  (,FORM-VAR ,ENV-VAR)
	     (DECLARE (FUNCTION-PARENT ,ACCESS-FUNCTION DEFSETF))
	     ,@(UNLESS ENV-VAR-P `(,ENV-VAR))
	     ,FORM)
	   (SI:DEFINE-SETF-PROPERTY ',ACCESS-FUNCTION 'SETF-METHOD-WITH-ENVIRONMENT
	     #'(:PROPERTY ,ACCESS-FUNCTION SETF-METHOD-INTERNAL-WITH-ENVIRONMENT)))
	 (EVAL-WHEN (COMPILE)
	   (SI:DEFINE-COMPILE-TIME-SETF-PROPERTY ',ACCESS-FUNCTION
						 'SETF-METHOD-WITH-ENVIRONMENT
	     #'(LAMBDA (,FORM-VAR ,ENV-VAR)
		 ,@(UNLESS ENV-VAR-P `(,ENV-VAR))
		 ,FORM)))))))

(DEFPROP DEFINE-SETF-EQUIVALENCE DEFSETF ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFINE-SETF-EQUIVALENCE (ACCESS-FUNCTION OUTER-FUNCTION INNER-FUNCTION
				   &OPTIONAL DOCUMENTATION)
  (CHECK-TYPE ACCESS-FUNCTION SYMBOL)
  `(PROGN
     (RECORD-SOURCE-FILE-NAME ',ACCESS-FUNCTION 'DEFSETF)
     ,@(WHEN DOCUMENTATION
	 `((SETF (DOCUMENTATION ',ACCESS-FUNCTION 'DEFSETF) ,DOCUMENTATION)))
     (DEFPROP ,ACCESS-FUNCTION (,OUTER-FUNCTION ,INNER-FUNCTION) SETF-EQUIVALENCE)
     (EVAL-WHEN (COMPILE)
       (SI:DEFINE-COMPILE-TIME-SETF-PROPERTY ',ACCESS-FUNCTION 'SETF-EQUIVALENCE 
	 '(,OUTER-FUNCTION ,INNER-FUNCTION)))))

;;; Evaluates all the args-vars in order, except possibly for ones named IGNORE.
;;; This is overly-generous but should do the job adequately.
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFUN MACRO-BEHAVES-LIKE-FUNCTION (FORM)
  (LET ((ARGS-VARS (CDR FORM)))
    (CATCH 'FAIL
      (NULL (MAPFORMS #'(LAMBDA (FORM KIND IGNORE VARS)
			  (WHEN (EQ KIND 'SYMEVAL)
			    (LOOP (COND ((EQ FORM (FIRST VARS))
					 (RETURN (SETQ VARS (REST VARS))))
					((EQ (FIRST VARS) 'IGNORE)
					 (SETQ VARS (REST VARS)))
					((MEMBER FORM ARGS-VARS)
					 (THROW 'FAIL NIL))
					(T (RETURN)))))
			  VARS)
		      FORM
		      :INITIAL-STATE ARGS-VARS)))))
)


;;; LOCF and DEFLOCF

(DEFPROP DEFLOCF "LOCF function" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFLOCF (ACCESS-FUNCTION LOCATE-FUNCTION-OR-SUBFORMS &BODY BODY
		   &AUX (DOCUMENTATION NIL))
  (CHECK-TYPE ACCESS-FUNCTION SYMBOL)
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION ACCESS-FUNCTION)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFLOCF))
    (AND (STRINGP (CAR BODY))
	 (SETQ DOCUMENTATION (POP BODY)))
    (AND BODY (NOT (LISTP LOCATE-FUNCTION-OR-SUBFORMS))
	 (COMPILER:WARN '(:FATAL T) "Unrecognizable DEFLOCF form"))
    (UNLESS (OR (FDEFINEDP ACCESS-FUNCTION)
		(COMPILER:FUNCTION-DEFINED-P ACCESS-FUNCTION))
      (COMPILER:WARN () "DEFLOCF of ~S may be a typographical error since ~
			  ~:*~S does not currently have a function definition."
		     ACCESS-FUNCTION))
    (WHEN (SYMBOLP LOCATE-FUNCTION-OR-SUBFORMS)	;Error detection in trivial case
      ;;--- Would like to be able to pass DEFLOCF as a definition-type argument here
      (COMPILER:FUNCTION-REFERENCED LOCATE-FUNCTION-OR-SUBFORMS ACCESS-FUNCTION))
    `(PROGN
       ,@(WHEN DOCUMENTATION
	   `((SETF (DOCUMENTATION ',ACCESS-FUNCTION 'DEFLOCF) ,DOCUMENTATION)))
       ,@(IF (NOT (LISTP LOCATE-FUNCTION-OR-SUBFORMS))
	     ;;Trivial case
	     `((RECORD-SOURCE-FILE-NAME ',ACCESS-FUNCTION 'DEFLOCF)
	       (SI:DEFINE-LOCF-PROPERTY ',ACCESS-FUNCTION 'TRIVIAL-LOCF-METHOD
		 ',LOCATE-FUNCTION-OR-SUBFORMS)
	       (EVAL-WHEN (COMPILE)
		 (SI:DEFINE-COMPILE-TIME-LOCF-PROPERTY ',ACCESS-FUNCTION 'TRIVIAL-LOCF-METHOD
		   ',LOCATE-FUNCTION-OR-SUBFORMS)))
	     (LET ((LAMBDA-LIST LOCATE-FUNCTION-OR-SUBFORMS)
		   (FORM-VAR NIL)
		   (ENV-VAR NIL)
		   (ENV-VAR-P NIL)
		   (NEW-LAMBDA-LIST NIL))
	       (WHEN (EQ (CAR LAMBDA-LIST) '&WHOLE)
		 (POP LAMBDA-LIST)
		 (SETQ FORM-VAR (POP LAMBDA-LIST)))
	       (LOOP WHILE LAMBDA-LIST
		     FOR ELT = (POP LAMBDA-LIST)
		     DOING
		 (COND ((EQ ELT '&ENVIRONMENT)
			(SETQ ENV-VAR (POP LAMBDA-LIST))
			(SETQ ENV-VAR-P T))
		       (T (PUSH ELT NEW-LAMBDA-LIST))))
	       (WHEN (NULL ENV-VAR)
		 (SETQ ENV-VAR (GENSYM)))
	       (WHEN (NULL FORM-VAR)
		 (SETQ FORM-VAR (GENSYM)))
	       (SETQ NEW-LAMBDA-LIST (NREVERSE NEW-LAMBDA-LIST))
	       ;;General case
	       (LET ((FORM `(DESTRUCTURING-BIND ,NEW-LAMBDA-LIST (CDR ,FORM-VAR)
			      ,@BODY))
		     (HELPER `(:PROPERTY ,ACCESS-FUNCTION
			       LOCF-METHOD-WITH-ENVIRONMENT-INTERNAL)))
		 `(PROGN
		    (SYS::MULTIPLE-DEFINITION ,ACCESS-FUNCTION DEFLOCF
		      (DEFUN ,HELPER (,FORM-VAR ,ENV-VAR)
			(DECLARE (FUNCTION-PARENT ,ACCESS-FUNCTION DEFLOCF))
			,@(UNLESS ENV-VAR-P `(,ENV-VAR))
			,FORM)
		      (SI:DEFINE-LOCF-PROPERTY ',ACCESS-FUNCTION 'LOCF-METHOD-WITH-ENVIRONMENT
			#',HELPER))
		    (EVAL-WHEN (COMPILE)
		      (SI:DEFINE-COMPILE-TIME-LOCF-PROPERTY ',ACCESS-FUNCTION
							    'LOCF-METHOD-WITH-ENVIRONMENT
			#'(LAMBDA (,FORM-VAR ,ENV-VAR)
			    ,@(UNLESS ENV-VAR-P `(,ENV-VAR))
			    ,FORM))))))))))

(DEFUN EXPAND-LOCF (REFERENCE ENV &AUX METHOD DEF)
  (LOOP WITH ORIGINAL-REFERENCE = REFERENCE DO	;Loop expanding macros
    (COND ((VARIABLEP REFERENCE ENV)
	   (RETURN `(SYS:VARIABLE-LOCATION ,REFERENCE)))
	  ((AND (SYMBOLP REFERENCE)
		(NOT (EQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENV))))))
	  ((OR (ATOM REFERENCE) (NOT (SYMBOLP (CAR REFERENCE))))
	   (COMPILER:WARN '(:FATAL T)
			  "~S is not valid as a generalized variable reference~
			    ~:[ (macroexpanded from ~S)~]"
			  REFERENCE (EQ REFERENCE ORIGINAL-REFERENCE) ORIGINAL-REFERENCE))
	  ((SETQ DEF (SI:LOCAL-FUNCTION-DEFINITION (CAR REFERENCE) ENV))
	   (OR (AND (CONSP DEF)
		    (EQ (FIRST DEF) 'DEFUN-IN-FLAVOR)
		    (LOCATION-BOUNDP (THIRD DEF))
		    (SETQ METHOD (SI:DEBUGGING-INFO-USER-ENTRY (LOCATION-CONTENTS (THIRD DEF))
							       'INLINE-FORM))
		    (SI:ENV-DECLARATIONS-INLINE-P (INLINE-FORM-NAME (SECOND METHOD)) ENV)
		    (NOT (EQ REFERENCE
			     (SETQ REFERENCE (EXPAND-INLINE-DEFUN-IN-FLAVOR
					       (SECOND METHOD) REFERENCE ENV)))))
	       (NOT (EQ REFERENCE
			(SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENV))))
	       (COMPILER:WARN '(:FATAL T)
			      "No LOCF method known for ~S forms~
				~:[ (macroexpanded from ~S)~] in this lexical environment"
			      (CAR REFERENCE) (EQ REFERENCE ORIGINAL-REFERENCE)
			      ORIGINAL-REFERENCE)))
	  ;; look for (FUNCALL #'FUNCTION ...) where FUNCTION is an inline
	  ;; this is generated by the compiler for DEFSUBST-IN-FLAVORs
	  ((AND (EQ (FIRST REFERENCE) 'FUNCALL)
		(CONSP (REST REFERENCE))
		(CONSP (SECOND REFERENCE))
		(EQ (FIRST (SECOND REFERENCE)) 'FUNCTION)
		(CONSP (REST (SECOND REFERENCE)))
		(SI:ENV-DECLARATIONS-INLINE-P (SECOND (SECOND REFERENCE)) ENV)
		(SETQ METHOD (FIND-INLINE-FORM-METHOD (SECOND (SECOND REFERENCE)) ENV))
		(STACK-LET* ((FAKE-FORM `(,(SECOND (SECOND REFERENCE))
					  ,@(REST (REST REFERENCE))))
			     (EXPANDED-FORM (EXPAND-INLINE-FORM METHOD FAKE-FORM ENV
								:NEVER-BIND-LOCALS T)))
		  (UNLESS (EQ FAKE-FORM EXPANDED-FORM)
		    (SETQ REFERENCE EXPANDED-FORM)
		    T))))
	  ((COMPILER:FILE-DECLARATION (CAR REFERENCE) 'DERIVED-LOCF-FUNCTION)
	   (RETURN `(FUNCALL #'(LOCF ,(CAR REFERENCE)) ,@(CDR REFERENCE))))
	  ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'TRIVIAL-LOCF-METHOD))
	   (RETURN (CONS METHOD (CDR REFERENCE))))
	  ((SETQ METHOD
		 (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'LOCF-METHOD-WITH-ENVIRONMENT))
	   (RETURN (FUNCALL METHOD REFERENCE ENV)))
	  ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'LOCF-METHOD))
	   (RETURN (FUNCALL METHOD REFERENCE)))
	  ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'SETF-EQUIVALENCE))
	   (SETQ REFERENCE (LIST (FIRST METHOD) (CONS (SECOND METHOD) (CDR REFERENCE)))))
	  ((AND (SETQ METHOD (GET (CAR REFERENCE) 'DERIVED-LOCF-FUNCTION))
		(LOCATION-BOUNDP METHOD))
	   (RETURN `(FUNCALL #'(LOCF ,(CAR REFERENCE)) ,@(CDR REFERENCE))))
	  ((SETQ METHOD (GET (CAR REFERENCE) 'TRIVIAL-LOCF-METHOD))
	   (RETURN (CONS METHOD (CDR REFERENCE))))
	  ((SETQ METHOD (GET (CAR REFERENCE) 'LOCF-METHOD-WITH-ENVIRONMENT))
	   (RETURN (FUNCALL METHOD REFERENCE ENV)))
	  ((SETQ METHOD (GET (CAR REFERENCE) 'LOCF-METHOD))
	   (RETURN (FUNCALL METHOD REFERENCE)))
	  ((SETQ METHOD (GET (CAR REFERENCE) 'SETF-EQUIVALENCE))
	   (SETQ REFERENCE (LIST (FIRST METHOD) (CONS (SECOND METHOD) (CDR REFERENCE)))))
	  ((AND (SETQ METHOD (FIND-INLINE-FORM-METHOD (CAR REFERENCE) ENV))
		(SI:ENV-DECLARATIONS-INLINE-P (FIRST REFERENCE) ENV)
		(NOT (EQ REFERENCE (SETQ REFERENCE (EXPAND-INLINE-FORM METHOD REFERENCE
						     ENV :NEVER-BIND-LOCALS T))))))
	  ((NEQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENV))))
	  ((AND (EQ (FIRST REFERENCE) 'VALUES) (= (LENGTH REFERENCE) 2))
	   (SETQ REFERENCE (SECOND REFERENCE)))
	  (T
	   (RETURN `(FUNCALL #'(LOCF ,(CAR REFERENCE)) ,@(CDR REFERENCE)))))))


;;; MODIFY macros, MODIFY methods, and PUSH macros

(DEFUN EXPAND-MODIFY-MACRO (REFERENCE FUNCTION ARGS &OPTIONAL (USE-MODIFY-METHODS T) ENV
			    &AUX METHOD)
  (LOOP WITH ORIGINAL-REFERENCE = REFERENCE DO	;Loop expanding macros
    (COND ((VARIABLEP REFERENCE ENV)
	   (RETURN `(SETQ ,REFERENCE (,FUNCTION ,REFERENCE ,@ARGS))))
	  ((AND (SYMBOLP REFERENCE)
		(NOT (EQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENV))))))
	  ((OR (ATOM REFERENCE) (NOT (SYMBOLP (CAR REFERENCE))))
	   (COMPILER:WARN '(:FATAL T)
			  "~S is not valid as a generalized variable reference~
			    ~:[ (macroexpanded from ~S)~]"
			  REFERENCE (EQ REFERENCE ORIGINAL-REFERENCE) ORIGINAL-REFERENCE))
	  (T (IF (SI:LOCAL-FUNCTION-DEFINITION (CAR REFERENCE) ENV)
		 (OR (NOT (EQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE ENV))))
		     (COMPILER:WARN '(:FATAL T)
				    "No SETF method known for ~S forms~
				~:[ (macroexpanded from ~S)~] in this lexical environment"
				    (CAR REFERENCE) (EQ REFERENCE ORIGINAL-REFERENCE)
				    ORIGINAL-REFERENCE))
		 (FLET ((USE-SETF-METHOD ()
			  (MULTIPLE-VALUE-BIND (TEMPS TVALS STORES STORE-FORM ACCESS-FORM)
			      (GET-SETF-METHOD-MULTIPLE-VALUE REFERENCE ENV)
			    (RETURN (IF (= (LIST-LENGTH STORES) 1)
					(LET ((*SIMPLE-VARIABLES* TEMPS))
					  (LET*-SUBST (APPEND TEMPS STORES)
						      (APPEND TVALS
							      `((,FUNCTION ,ACCESS-FORM ,@ARGS)))
						      STORE-FORM
						      ENV))
					(LET*-SUBST TEMPS TVALS
						    `(MULTIPLE-VALUE-BIND ,STORES
							 (,FUNCTION ,ACCESS-FORM ,@ARGS)
						       ,STORE-FORM)
						    ENV))))))		    
		   (COND ((AND USE-MODIFY-METHODS
			       (SETQ METHOD (COMPILER:FILE-DECLARATION
					      (CAR REFERENCE)
					      'MODIFY-METHOD-WITH-ENVIRONMENT)))
			  (RETURN (FUNCALL METHOD REFERENCE ENV FUNCTION ARGS)))
			 ((AND USE-MODIFY-METHODS
			       (SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE)
								       'MODIFY-METHOD)))
			  (RETURN (FUNCALL METHOD REFERENCE FUNCTION ARGS)))
			 ((OR (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'DERIVED-SETF-FUNCTION)
			      (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'DERIVED-FUTURE-COMMON-LISP-SETF-FUNCTION)
			      (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'TRIVIAL-SETF-METHOD)
			      (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'SETF-METHOD-WITH-ENVIRONMENT)
			      (COMPILER:FILE-DECLARATION (CAR REFERENCE) 'SETF-METHOD))
			  (USE-SETF-METHOD))
			 ((SETQ METHOD (COMPILER:FILE-DECLARATION (CAR REFERENCE)
								  'SETF-EQUIVALENCE))
			  (SETQ REFERENCE `(,(FIRST METHOD) (,(SECOND METHOD)
							     . ,(REST REFERENCE)))))
			 ((AND USE-MODIFY-METHODS
			       (SETQ METHOD (GET (CAR REFERENCE)
						 'MODIFY-METHOD-WITH-ENVIRONMENT)))
			  (RETURN (FUNCALL METHOD REFERENCE ENV FUNCTION ARGS)))
			 ((AND USE-MODIFY-METHODS
			       (SETQ METHOD (GET (CAR REFERENCE) 'MODIFY-METHOD)))
			  (RETURN (FUNCALL METHOD REFERENCE FUNCTION ARGS)))
			 ((OR (AND (SETQ METHOD (GET (CAR REFERENCE) 'DERIVED-SETF-FUNCTION))
				   (LOCATION-BOUNDP METHOD))
			      (AND (SETQ METHOD (GET (CAR REFERENCE)
						     'DERIVED-FUTURE-COMMON-LISP-SETF-FUNCTION))
				   (LOCATION-BOUNDP METHOD))
			      (GET (CAR REFERENCE) 'TRIVIAL-SETF-METHOD)
			      (GET (CAR REFERENCE) 'SETF-METHOD-WITH-ENVIRONMENT)
			      (GET (CAR REFERENCE) 'SETF-METHOD))
			  (USE-SETF-METHOD))
			 ((SETQ METHOD (GET (CAR REFERENCE) 'SETF-EQUIVALENCE))
			  (SETQ REFERENCE `(,(FIRST METHOD) (,(SECOND METHOD)
							     . ,(REST REFERENCE)))))
			 ((AND (SETQ METHOD (FIND-INLINE-FORM-METHOD (CAR REFERENCE) ENV))
			       (SI:ENV-DECLARATIONS-INLINE-P (FIRST REFERENCE) ENV)
			       (NOT (EQ REFERENCE
					(SETQ REFERENCE (EXPAND-INLINE-FORM METHOD REFERENCE ENV
									    :NEVER-BIND-LOCALS T))))))
			 ((NEQ REFERENCE (SETQ REFERENCE (MACROEXPAND-1 REFERENCE))))
			 (T
			  (USE-SETF-METHOD)))))))))

(DEFMACRO DEFINE-MODIFY-METHOD (ACCESS-FUNCTION LAMBDA-LIST (FUNCTION-VARIABLE ARGS-VARIABLE)
				&BODY BODY)
  (CHECK-TYPE ACCESS-FUNCTION SYMBOL)
  (CHECK-TYPE FUNCTION-VARIABLE SYMBOL)
  (CHECK-TYPE ARGS-VARIABLE SYMBOL)
  (LET ((FORM-VAR NIL)
	(ENV-VAR NIL)
	(ENV-VAR-P NIL)
	(NEW-LAMBDA-LIST NIL))
    (WHEN (EQ (CAR LAMBDA-LIST) '&WHOLE)
      (POP LAMBDA-LIST)
      (SETQ FORM-VAR (POP LAMBDA-LIST)))
    (LOOP WHILE LAMBDA-LIST
	  FOR ELT = (POP LAMBDA-LIST)
	  DOING
      (COND ((EQ ELT '&ENVIRONMENT)
	     (SETQ ENV-VAR (POP LAMBDA-LIST))
	     (SETQ ENV-VAR-P T))
	    (T (PUSH ELT NEW-LAMBDA-LIST))))
    (WHEN (NULL ENV-VAR)
      (SETQ ENV-VAR (GENSYM)))
    (WHEN (NULL FORM-VAR)
      (SETQ FORM-VAR (GENSYM)))
    (SETQ NEW-LAMBDA-LIST (NREVERSE NEW-LAMBDA-LIST))
    (LET ((FORM `(DESTRUCTURING-BIND ,NEW-LAMBDA-LIST (CDR ,FORM-VAR) ,@BODY)))
      `(PROGN
	 (SYS:MULTIPLE-DEFINITION ,ACCESS-FUNCTION DEFINE-MODIFY-METHOD
	   (DEFUN (:PROPERTY ,ACCESS-FUNCTION MODIFY-METHOD-WITH-ENVIRONMENT)
		  (,FORM-VAR ,ENV-VAR ,FUNCTION-VARIABLE ,ARGS-VARIABLE)
	     (DECLARE (FUNCTION-PARENT ,ACCESS-FUNCTION DEFINE-MODIFY-METHOD))
	     ,@(UNLESS ENV-VAR-P `(,ENV-VAR))
	     ,FORM))
	 (EVAL-WHEN (COMPILE)
	   (COMPILER:FILE-DECLARE
	     ',ACCESS-FUNCTION 'MODIFY-METHOD-WITH-ENVIRONMENT
	     #'(LAMBDA (,FORM-VAR ,ENV-VAR ,FUNCTION-VARIABLE ,ARGS-VARIABLE)
		 ,@(UNLESS ENV-VAR-P `(,ENV-VAR))
		 ,FORM)))))))

(DEFMACRO DEFINE-MODIFY-MACRO (NAME ARGS FUNCTION &REST DOCUMENTATION-AND-DECLARATIONS)
  (LET ((ENV-VAR (GENSYM))
	(ARGLIST (LET ((ARGL NIL)
		       (REST NIL))
		   (MAP-OVER-LAMBDA-LIST
		     ARGS #'(LAMBDA (ITEM TYPE)
			      (ECASE TYPE
				((:REQUIRED :OPTIONAL :KEY)
				 (LET ((ITEM (FIRST ITEM)))
				   (PUSH (IF (ATOM ITEM) ITEM (FIRST ITEM)) ARGL)))
				(:REST
				  (SETF REST (IF (ATOM ITEM) ITEM (FIRST ITEM))))
				((:ALLOW-OTHER-KEYS :&-KEY))
				((:AUX)
				 (WARN "&AUX parameters are not permitted.")))))
		   (IF REST
		       `(LIST* ,.(NREVERSE ARGL) ,REST)
		       `(LIST ,.(NREVERSE ARGL))))))
    `(DEFMACRO ,NAME (REFERENCE ,@ARGS &ENVIRONMENT ,ENV-VAR)
       ,@DOCUMENTATION-AND-DECLARATIONS
       (EXPAND-MODIFY-MACRO REFERENCE ',FUNCTION ,ARGLIST T ,ENV-VAR))))

;No backwards-modify methods.  Since PUSH and PUSHNEW involve consing there
;probably isn't a lot to be gained by special-casing certain references.
(DEFUN EXPAND-PUSH (ITEM REFERENCE FUNCTION FUNCTION-IN-AREA FUNCTION-LOCALIZE KEYWORDS ENV)
  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)
      (GET-SETF-METHOD REFERENCE ENV)
    (LET* ((ITEM-VAR (GENSYM))
	   (AREA (GETF KEYWORDS :AREA))
	   (LOCALIZE (GETF KEYWORDS :LOCALIZE))
	   (OTHER-KEYWORDS (REMOVE-KEYWORDS '(:AREA :LOCALIZE) KEYWORDS))
	   (CONS-FORM (COND (LOCALIZE
			     ;; This doesn't worry about the unlikely possibility of
			     ;; the user specifying both :AREA and :LOCALIZE, specifying
			     ;; :LOCALIZE first, and having side-effects in the values.
			     ;; LET-SUBST could take care of that, but it's too much trouble.
			     `(,FUNCTION-LOCALIZE ,ITEM-VAR ,ACCESS-FORM ,AREA ,LOCALIZE
						  ,@OTHER-KEYWORDS))
			    ((NULL AREA)
			     `(,FUNCTION ,ITEM-VAR ,ACCESS-FORM ,@OTHER-KEYWORDS))
			    (T
			     `(,FUNCTION-IN-AREA ,ITEM-VAR ,ACCESS-FORM ,AREA
						 ,@OTHER-KEYWORDS)))))
      (LET ((*SIMPLE-VARIABLES* (CONS ITEM-VAR VARS)))
	(LET*-SUBST (APPEND *SIMPLE-VARIABLES* STORES)
		    `(,ITEM ,@VALS ,CONS-FORM)
		    STORE-FORM
		    ENV)))))

(DEFUN EXPAND-PUSH-2 (ITEM REFERENCE FUNCTION OTHER-ARGUMENTS ENV)
  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)
      (GET-SETF-METHOD REFERENCE ENV)
    (LET* ((ITEM-VAR (GENSYM))
	   (CONS-FORM `(,FUNCTION ,ITEM-VAR ,ACCESS-FORM ,@OTHER-ARGUMENTS)))
      (LET ((*SIMPLE-VARIABLES* (CONS ITEM-VAR VARS)))
	(LET*-SUBST (APPEND *SIMPLE-VARIABLES* STORES)
		    `(,ITEM ,@VALS ,CONS-FORM)
		    STORE-FORM
		    ENV)))))

;I'm not going to support the old Maclisp 2-argument POP, even though ZL has it.  Suck.
(DEFUN EXPAND-POP (LIST &OPTIONAL ENV)
  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)
      (GET-SETF-METHOD LIST ENV)
    (LET*-SUBST VARS VALS
		`(PROG1 (CAR ,ACCESS-FORM)
			,(LET ((*SIMPLE-VARIABLES* VARS))
			   (LET-SUBST STORES `((CDR ,ACCESS-FORM))
				      STORE-FORM
				      ENV)))
		ENV)))

;This might be globalized some day, people have asked for it
(DEFUN REMOVE-KEYWORDS (KEYWORDS-TO-REMOVE ARGLIST)
  (LOOP FOR (KEY VAL) ON ARGLIST BY 'CDDR
	UNLESS (MEMBER (IF (AND (LISTP KEY) (EQ (FIRST KEY) 'QUOTE)) (SECOND KEY) KEY)
		       KEYWORDS-TO-REMOVE)
	  COLLECT KEY AND COLLECT VAL))

;;; SETF and LOCF methods for basic Lisp functions

;Here I have included every function that had one for the old Zetalisp SETF
;and all the functions listed in the SETF writeup in the Common Lisp "laser" manual

;--- Skipping the ones in the LMFS and TAPE packages, TV:GEOMETRY-FILL-P, CHAOS:PUP-WORD
;--- and L-machine-specific ones: BIN-OP-DISPATCH, %DISK-DCW-INDEX, STRING-FROM-WORD-ARRAY,
;	UNSIGNED-AREF, BIGNUM-REF, CCA-INSTRUCTION, CCA-OBJECT, COMPILED-FUNCTION-INSTRUCTION,
;--- These will all need to be done eventually, but not needed until CL bootstrap
;--- since they are all specific to single modules, not general system things.

(DEFSETF AREF (&REST SUBSCRIPTS) (VALUE)
  `(ZL:ASET ,VALUE . ,SUBSCRIPTS))
(DEFLOCF AREF SI:ALOC)

(DEFSETF SYS:%1D-AREF (ARRAY INDEX) (VALUE)
  `(SYS:%1D-ASET ,VALUE ,ARRAY ,INDEX))
(DEFLOCF SYS:%1D-AREF SYS:%1D-ALOC)

(defsetf future-common-lisp:row-major-aref (array index) (value)
  `(sys:%1d-aset ,value ,array ,index))

(DEFSETF ZL:AR-1 (ARRAY I) (VALUE)
  `(ZL:AS-1 ,VALUE ,ARRAY ,I))
(DEFLOCF ZL:AR-1 ZL:AP-1)

(DEFSETF ZL:AR-2 (ARRAY I J) (VALUE)
  `(ZL:AS-2 ,VALUE ,ARRAY ,I ,J))
(DEFLOCF ZL:AR-2 ZL:AP-2)

(DEFSETF ARRAY-LEADER (ARRAY I) (VALUE)
  `(ZL:STORE-ARRAY-LEADER ,VALUE ,ARRAY ,I))
(DEFLOCF ARRAY-LEADER ZL:AP-LEADER)

(DEFSETF ZL:ARRAYCALL (IGNORE &REST X) (VALUE)
  `(ZL:ASET ,VALUE . ,X))
(DEFLOCF ZL:ARRAYCALL (IGNORE &REST X)
  `(ALOC . ,X))

;---No LOCF method for ELT I guess...
(DEFSETF ELT SYS:SETELT)

(DEFSETF SVREF (VECTOR INDEX) (VALUE)
  `(ZL:ASET ,VALUE ,VECTOR ,INDEX))

(DEFSETF CHAR (STRING INDEX) (VALUE)
  `(ZL:ASET ,VALUE ,STRING ,INDEX))

(DEFSETF BIT (BIT-ARRAY &REST SUBSCRIPTS) (VALUE)
  `(ZL:ASET ,VALUE ,BIT-ARRAY ,@SUBSCRIPTS))

(DEFSETF SCHAR (STRING INDEX) (VALUE)
  `(ZL:ASET ,VALUE ,STRING ,INDEX))

(DEFSETF SBIT (SIMPLE-BIT-ARRAY &REST SUBSCRIPTS) (VALUE)
  `(ZL:ASET ,VALUE ,SIMPLE-BIT-ARRAY ,@SUBSCRIPTS))

(DEFSETF SUBSEQ (SEQUENCE START &OPTIONAL END) (NEW-SEQUENCE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,NEW-SEQUENCE
       (REPLACE ,SEQUENCE ,VTEMP :START1 ,START :END1 ,END))))

(DEFSETF PLANE-AREF (&REST SUBSCRIPTS) (VALUE)
  `(ZL:PLANE-ASET ,VALUE . ,SUBSCRIPTS))

(DEFSETF CAR RPLACA2)
(DEFLOCF CAR ZL:CAR-LOCATION)

(DEFSETF CDR RPLACD2)
(DEFLOCF CDR IDENTITY)

(DEFSETF LOCATION-CONTENTS RPLACD2)
(DEFLOCF LOCATION-CONTENTS IDENTITY)

;Necessary because of common-lisp-function-link mechanism equating REST to CDR
(DEFSETF REST RPLACD2)
(DEFLOCF REST IDENTITY)

(DEFINE-SETF-EQUIVALENCE CAAR CAR CAR)
(DEFINE-SETF-EQUIVALENCE CADR CAR CDR)
(DEFINE-SETF-EQUIVALENCE CDAR CDR CAR)
(DEFINE-SETF-EQUIVALENCE CDDR CDR CDR)
(DEFINE-SETF-EQUIVALENCE CAAAR CAR CAAR)
(DEFINE-SETF-EQUIVALENCE CAADR CAR CADR)
(DEFINE-SETF-EQUIVALENCE CADAR CAR CDAR)
(DEFINE-SETF-EQUIVALENCE CADDR CAR CDDR)
(DEFINE-SETF-EQUIVALENCE CDAAR CDR CAAR)
(DEFINE-SETF-EQUIVALENCE CDADR CDR CADR)
(DEFINE-SETF-EQUIVALENCE CDDAR CDR CDAR)
(DEFINE-SETF-EQUIVALENCE CDDDR CDR CDDR)
(DEFINE-SETF-EQUIVALENCE CAAAAR CAR CAAAR)
(DEFINE-SETF-EQUIVALENCE CAAADR CAR CAADR)
(DEFINE-SETF-EQUIVALENCE CAADAR CAR CADAR)
(DEFINE-SETF-EQUIVALENCE CAADDR CAR CADDR)
(DEFINE-SETF-EQUIVALENCE CADAAR CAR CDAAR)
(DEFINE-SETF-EQUIVALENCE CADADR CAR CDADR)
(DEFINE-SETF-EQUIVALENCE CADDAR CAR CDDAR)
(DEFINE-SETF-EQUIVALENCE CADDDR CAR CDDDR)
(DEFINE-SETF-EQUIVALENCE CDAAAR CDR CAAAR)
(DEFINE-SETF-EQUIVALENCE CDAADR CDR CAADR)
(DEFINE-SETF-EQUIVALENCE CDADAR CDR CADAR)
(DEFINE-SETF-EQUIVALENCE CDADDR CDR CADDR)
(DEFINE-SETF-EQUIVALENCE CDDAAR CDR CDAAR)
(DEFINE-SETF-EQUIVALENCE CDDADR CDR CDADR)
(DEFINE-SETF-EQUIVALENCE CDDDAR CDR CDDAR)
(DEFINE-SETF-EQUIVALENCE CDDDDR CDR CDDDR)

(DEFINE-SETF-EQUIVALENCE NTH CAR NTHCDR)

(DEFINE-SETF-METHOD NTHCDR (N LIST &ENVIRONMENT ENV)
  (IF (CONSTANTP N ENV)
      (LET ((N-VALUE (EVALUATE-CONSTANT N ENV)))
	(IF (EQL N-VALUE 0)
	    (GET-SETF-METHOD-MULTIPLE-VALUE LIST ENV)
	    (LET ((STORE (GENSYM))
		  (REF (GENSYM)))
	      (VALUES (LIST REF)
		      (LIST `(NTHCDR ,(1- N-VALUE) ,LIST))
		      (LIST STORE)
		      `(RPLACD2 ,REF ,STORE)
		      `(CDR ,REF)))))
      (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)
	  (GET-SETF-METHOD LIST ENV)
	(LET ((NSYM (GENSYM)))
	  (VALUES (LIST* NSYM VARS)
		  (LIST* N VALS)
		  STORES
		  `(IF (ZEROP ,NSYM)
		       ,STORE-FORM
		       (RPLACD2 (NTHCDR (1- ,NSYM) ,ACCESS-FORM) ,@STORES))
		  `(NTHCDR ,NSYM ,ACCESS-FORM))))))

(DEFLOCF NTHCDR (N LIST)
  (LET ((NN (GENSYM)))
    `(LET ((,NN ,N))
       (IF (ZEROP ,NN)
	   (LOCF ,LIST)
	   (NTHCDR (1- ,NN) ,LIST)))))

;Let's be mathematically complete
(DEFINE-SETF-METHOD IDENTITY (REFERENCE &ENVIRONMENT ENV)
  (GET-SETF-METHOD-MULTIPLE-VALUE REFERENCE ENV))

(DEFSETF ZL:FSYMEVAL ZL:FSET)
(DEFLOCF ZL:FSYMEVAL ZL:FUNCTION-CELL-LOCATION)
(DEFSETF SYMBOL-FUNCTION ZL:FSET)
(DEFLOCF SYMBOL-FUNCTION ZL:FUNCTION-CELL-LOCATION)

(DEFSETF FDEFINITION (FUNCTION-SPEC) (DEFINITION)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,DEFINITION
       (FDEFINE ,FUNCTION-SPEC ,VTEMP T))))

(DEFLOCF FDEFINITION FDEFINITION-LOCATION)

;--- Uses FSET rather than FDEFINE since this seems like it's supposed to be
;primitive and not save the old definition and so forth.  On the other hand,
;there is no "carefully" way to do this, except at the level of MACRO and DEFMACRO.
(DEFSETF MACRO-FUNCTION (SYMBOL &OPTIONAL ENV) (EXPANDER)
  (DECLARE (IGNORE ENV))
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,EXPANDER
       (ZL:FSET ,SYMBOL (LIST 'SPECIAL ,VTEMP)))))

;This exists in Zetalisp, although I've never seen it used!
;I fixed various lossages in the old ZL definition (function specs, error reporting, careful)
(DEFINE-SETF-METHOD FUNCTION (FUNCTION-SPEC)
  (UNLESS (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
    (COMPILER:WARN '(:FATAL T)
		   "~S is not a function spec, (FUNCTION ~:*~S) can't be SETF'ed"
		   FUNCTION-SPEC))
  (LET ((DEFINITION (GENSYM)))
    (VALUES () () (LIST DEFINITION)
	    `(SETF (LOCATION-CONTENTS (SI:FUNCTION-LOCATION ,FUNCTION-SPEC)) ,DEFINITION)
	    `(FUNCTION ,FUNCTION-SPEC))))

(DEFLOCF FUNCTION (FUNCTION-SPEC)
  (UNLESS (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
    (COMPILER:WARN '(:FATAL T)
		   "~S is not a function spec, (FUNCTION ~:*~S) can't be LOCF'ed"
		   FUNCTION-SPEC))
  `(SI:FUNCTION-LOCATION ,FUNCTION-SPEC))

(DEFSETF ZL:SYMEVAL SET)
(DEFLOCF ZL:SYMEVAL (SYMBOL)
  `(FOLLOW-CELL-FORWARDING (SI:VALUE-CELL-LOCATION ,SYMBOL) NIL))
(DEFSETF SYMBOL-VALUE SET)
(DEFLOCF SYMBOL-VALUE (SYMBOL)
  `(FOLLOW-CELL-FORWARDING (SI:VALUE-CELL-LOCATION ,SYMBOL) NIL))

(DEFSETF ZL:SYMEVAL-IN-INSTANCE SI:SET-IN-INSTANCE)
(DEFLOCF ZL:SYMEVAL-IN-INSTANCE SI:LOCATE-IN-INSTANCE)
(DEFSETF SYMBOL-VALUE-IN-INSTANCE SI:SET-IN-INSTANCE)
(DEFLOCF SYMBOL-VALUE-IN-INSTANCE SI:LOCATE-IN-INSTANCE)

(DEFSETF ZL:PLIST ZL:SETPLIST)
(DEFLOCF ZL:PLIST ZL:PROPERTY-CELL-LOCATION)
(DEFSETF ZL:GET (SYM INDICATOR) (VALUE)
  `(ZL:PUTPROP ,SYM ,VALUE ,INDICATOR))
(DEFLOCF ZL:GET SI:GET-LOCATION)

;--- New table system takes care of these
;(DEFSETF GETHASH (KEY HASH-TABLE &OPTIONAL DEFAULT) (VALUE)
;  DEFAULT ;ignored by SETF, needed for INCF
;  `(ZL:PUTHASH ,KEY ,VALUE ,HASH-TABLE))
;
;(DEFSETF ZL:GETHASH (KEY HASH-TABLE) (VALUE)
;  `(ZL:PUTHASH ,KEY ,VALUE ,HASH-TABLE))
;
;;--- terd
;(DEFSETF ZL:GETHASH-EQUAL (KEY HASH-TABLE) (VALUE)
;  `(ZL:PUTHASH-EQUAL ,KEY ,VALUE ,HASH-TABLE))

(DEFSETF ZL:ARG ZL:SETARG)

(DEFSETF %P-CONTENTS-OFFSET (BASE OFFSET) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%P-STORE-CONTENTS-OFFSET ,VTEMP ,BASE ,OFFSET))))
(DEFLOCF %P-CONTENTS-OFFSET (BASE OFFSET)
  `(%MAKE-POINTER-OFFSET DTP-LOCATIVE ,BASE ,OFFSET))

(DEFSETF %P-LDB (PPSS POINTER) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%P-DPB ,VTEMP ,PPSS ,POINTER))))

(DEFSETF %P-LDB-OFFSET (PPSS POINTER OFFSET) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%P-DPB-OFFSET ,VTEMP ,PPSS ,POINTER ,OFFSET))))

(DEFSETF %P-POINTER (POINTER) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%P-STORE-POINTER ,POINTER ,VTEMP))))

(DEFSETF %P-DATA-TYPE (POINTER) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%P-STORE-DATA-TYPE ,POINTER ,VTEMP))))

(DEFSETF %P-CDR-CODE (POINTER) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%P-STORE-CDR-CODE ,POINTER ,VTEMP))))

(DEFINE-SETF-METHOD BYTE-SIZE (BYTE-SPECIFIER &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (BS-TEMPS BS-VALS BS-STORES BS-STORE-FORM BS-ACCESS-FORM)
      (GET-SETF-METHOD BYTE-SPECIFIER ENV)
    (LET ((STORE (GENSYM)))
      (VALUES BS-TEMPS
	      BS-VALS
	      (LIST STORE)
	      `(PROGN ,(LET-SUBST BS-STORES `((BYTE ,STORE (BYTE-POSITION ,BS-ACCESS-FORM)))
				  BS-STORE-FORM
				  ENV)
		      ,STORE)
	      `(BYTE-SIZE ,BS-ACCESS-FORM)))))

(DEFINE-SETF-METHOD BYTE-POSITION (BYTE-SPECIFIER &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (BS-TEMPS BS-VALS BS-STORES BS-STORE-FORM BS-ACCESS-FORM)
      (GET-SETF-METHOD BYTE-SPECIFIER ENV)
    (LET ((STORE (GENSYM)))
      (VALUES BS-TEMPS
	      BS-VALS
	      (LIST STORE)
	      `(PROGN ,(LET-SUBST BS-STORES `((BYTE (BYTE-SIZE ,BS-ACCESS-FORM) ,STORE))
				  BS-STORE-FORM
				  ENV)
		      ,STORE)
	      `(BYTE-POSITION ,BS-ACCESS-FORM)))))

;Why is a temporary variable not bound to WORD-ACCESS-FORM, eliminating
;common sub-expressions from INCF?  This seems plausible at first, but
;the problem is that a side-effect that changes the value of WORD-ACCESS-FORM
;might get inserted between two references, and eliminating the common
;sub-expression would be wrong.  Consider, for instance,
;	(ROTATEF (LDB BYTE1 (AREF A I)) (LDB BYTE2 (AREF A I)))
;which should exchange two bytes in an array element.  If the AREF
;is executed and a variable is bound to the array element, one of
;the two ASET's generated will be lost.

;Requires the full general case because it is SETF-recursive
(DEFINE-SETF-METHOD LDB (BYTE WORD &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (WORD-TEMPS WORD-VALS WORD-STORES WORD-STORE-FORM WORD-ACCESS-FORM)
      (GET-SETF-METHOD WORD ENV)
    (LET ((BTEMP (GENSYM))
	  (STORE (GENSYM))
	  (VTEMP (GENSYM)))
      (LET ((*SIMPLE-VARIABLES* (CONS BTEMP WORD-TEMPS)))
	(VALUES *SIMPLE-VARIABLES*
		(CONS BYTE WORD-VALS)
		(LIST STORE)
		`(LET-VALUE ,VTEMP ,STORE
		   ,(LET-SUBST WORD-STORES `((DPB ,VTEMP ,BTEMP ,WORD-ACCESS-FORM))
			       WORD-STORE-FORM
			       ENV))
		`(LDB ,BTEMP ,WORD-ACCESS-FORM))))))

(DEFINE-SETF-METHOD %LOGLDB (BYTE WORD &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (WORD-TEMPS WORD-VALS WORD-STORES WORD-STORE-FORM WORD-ACCESS-FORM)
      (GET-SETF-METHOD WORD ENV)
    (LET ((BTEMP (GENSYM))
	  (STORE (GENSYM))
	  (VTEMP (GENSYM)))
      (LET ((*SIMPLE-VARIABLES* (CONS BTEMP WORD-TEMPS)))
	(VALUES *SIMPLE-VARIABLES*
		(CONS BYTE WORD-VALS)
		(LIST STORE)
		`(LET-VALUE ,VTEMP ,STORE
		   ,(LET-SUBST WORD-STORES `((%LOGDPB ,VTEMP ,BTEMP ,WORD-ACCESS-FORM))
			       WORD-STORE-FORM
			       ENV))
		`(%LOGLDB ,BTEMP ,WORD-ACCESS-FORM))))))

(DEFINE-SETF-METHOD LDB-TEST (BYTE WORD &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (WORD-TEMPS WORD-VALS WORD-STORES WORD-STORE-FORM WORD-ACCESS-FORM)
      (GET-SETF-METHOD WORD ENV)
    (LET ((BTEMP (GENSYM))
	  (STORE (GENSYM))
	  (VTEMP (GENSYM)))
      (LET ((*SIMPLE-VARIABLES* (CONS BTEMP WORD-TEMPS)))
	(VALUES *SIMPLE-VARIABLES*
		(CONS BYTE WORD-VALS)
		(LIST STORE)
		`(LET-VALUE ,VTEMP (IF ,STORE -1 0)
		   ,(LET-SUBST WORD-STORES `((DPB ,VTEMP ,BTEMP ,WORD-ACCESS-FORM))
			       WORD-STORE-FORM
			       ENV))
		`(LDB-TEST ,BTEMP ,WORD-ACCESS-FORM))))))

(DEFINE-SETF-METHOD MASK-FIELD (BYTE WORD &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (WORD-TEMPS WORD-VALS WORD-STORES WORD-STORE-FORM WORD-ACCESS-FORM)
      (GET-SETF-METHOD WORD ENV)
    (LET ((BTEMP (GENSYM))
	  (STORE (GENSYM))
	  (VTEMP (GENSYM)))
      (LET ((*SIMPLE-VARIABLES* (CONS BTEMP WORD-TEMPS)))
	(VALUES *SIMPLE-VARIABLES*
		(CONS BYTE WORD-VALS)
		(LIST STORE)
		`(LET-VALUE ,VTEMP ,STORE
		   ,(LET-SUBST WORD-STORES `((DEPOSIT-FIELD ,VTEMP ,BTEMP ,WORD-ACCESS-FORM))
			       WORD-STORE-FORM
			       ENV))
		`(MASK-FIELD ,BTEMP ,WORD-ACCESS-FORM))))))


;;; SETF of internal and internalesque things

(DEFSETF SYS:FLOAT-OPERATING-MODE   SYS:SET-FLOAT-OPERATING-MODE)
(DEFSETF SYS:FLOAT-OPERATION-STATUS SYS:SET-FLOAT-OPERATION-STATUS)

;Pathnames
(DEFLOCF FS:PATHNAME-PROPERTY-LIST (PATHNAME)
  `(SEND ,PATHNAME :PROPERTY-LIST-LOCATION))

;Flavors
(DEFSETF %INSTANCE-REF (INSTANCE INDEX) (VALUE)
  (LET ((VTEMP (GENSYM)))
    `(LET-VALUE ,VTEMP ,VALUE
       (%INSTANCE-SET ,VTEMP ,INSTANCE ,INDEX))))

(DEFLOCF %INSTANCE-REF %INSTANCE-LOC)

;Function specs
(DEFSETF SI:FUNCTION-SPEC-GET (FUNCTION-SPEC INDICATOR) (VALUE)
  `(SI:FUNCTION-SPEC-PUTPROP ,FUNCTION-SPEC ,VALUE ,INDICATOR))

;;; SETF of messages

;--- We don't bother now about supporting LOCF of messages

(DEFINE-SETF-METHOD SEND (INSTANCE MESSAGE &REST ARGS &ENVIRONMENT ENV)
  (SETF-SEND INSTANCE MESSAGE ARGS ENV))

;Obsolete name (for this operation!) kept around
(DEFINE-SETF-METHOD FUNCALL (INSTANCE MESSAGE &REST ARGS)
  (SETF-SEND INSTANCE MESSAGE ARGS))

(DEFSETF (SEND :GET) (INSTANCE INDICATOR) (VALUE)
  `(SEND ,INSTANCE :PUTPROP ,VALUE ,INDICATOR))

(DEFSETF (SEND :GET-HASH) :PUT-HASH)

(DEFUN SETF-SEND (INSTANCE MESSAGE ARGS &OPTIONAL ENVIRONMENT &AUX METHOD)
  (COND ((KEYWORDP MESSAGE))
	((AND (LISTP MESSAGE) (EQ (FIRST MESSAGE) 'QUOTE) (SYMBOLP (SECOND MESSAGE)))
	 (SETQ MESSAGE (SECOND MESSAGE)))
	(T (COMPILER:WARN '(:FATAL T) "Can only SETF a SEND of a constant message, not ~S"
			  MESSAGE)))
  (COND ((SETQ METHOD (COMPILER:FILE-DECLARATION MESSAGE 'TRIVIAL-SETF-SEND-METHOD))
	 (LET ((TEMPS (LOOP REPEAT (1+ (LIST-LENGTH ARGS)) COLLECT (GENSYM)))
	       (STORE (GENSYM)))
	   (VALUES TEMPS
		   (CONS INSTANCE ARGS)
		   (LIST STORE)
		   `(SEND ,(FIRST TEMPS) ',METHOD ,@(CDR TEMPS) ,STORE)
		   `(SEND ,(FIRST TEMPS) ',MESSAGE ,@(CDR TEMPS)))))
	((SETQ METHOD (COMPILER:FILE-DECLARATION MESSAGE 'SETF-SEND-METHOD-WITH-ENVIRONMENT))
	 (FUNCALL METHOD `(SEND ,INSTANCE ',MESSAGE . ,ARGS) ENVIRONMENT))
	((SETQ METHOD (COMPILER:FILE-DECLARATION MESSAGE 'SETF-SEND-METHOD))
	 (FUNCALL METHOD `(SEND ,INSTANCE ',MESSAGE . ,ARGS)))
	((SETQ METHOD (GET MESSAGE 'TRIVIAL-SETF-SEND-METHOD))
	 (LET ((TEMPS (LOOP REPEAT (1+ (LIST-LENGTH ARGS)) COLLECT (GENSYM)))
	       (STORE (GENSYM)))
	   (VALUES TEMPS
		   (CONS INSTANCE ARGS)
		   (LIST STORE)
		   `(SEND ,(FIRST TEMPS) ',METHOD ,@(CDR TEMPS) ,STORE)
		   `(SEND ,(FIRST TEMPS) ',MESSAGE ,@(CDR TEMPS)))))
	((SETQ METHOD (GET MESSAGE 'SETF-SEND-METHOD-WITH-ENVIRONMENT))
	 (FUNCALL METHOD `(SEND ,INSTANCE ',MESSAGE . ,ARGS) ENVIRONMENT))
	((SETQ METHOD (GET MESSAGE 'SETF-SEND-METHOD))
	 (FUNCALL METHOD `(SEND ,INSTANCE ',MESSAGE . ,ARGS)))
	((NULL ARGS)
	 (LET ((TEMP (GENSYM))
	       (STORE (GENSYM))
	       (SET-MESSAGE (INTERN (STRING-APPEND "SET-" MESSAGE) SI:PKG-KEYWORD-PACKAGE)))
	   (VALUES (LIST TEMP)
		   (LIST INSTANCE)
		   (LIST STORE)
		   `(SEND ,TEMP ',SET-MESSAGE ,STORE)
		   `(SEND ,TEMP ',MESSAGE))))
	(T (COMPILER:WARN '(:FATAL T) "No SETF-SEND method known for ~S"
			  `(SEND ,INSTANCE ',MESSAGE . ,ARGS)))))

;;; Destructuring SETF methods

;;; We can destructure backquote patterns that don't involve APPEND or NCONC
;;; (i.e. that use ,@ and ,. only at the ends of lists).
;;; When destructuring into a backquote pattern, constants in the pattern are ignored,
;;; no attempt is made to verify matching with the tree being destructured.

(DEFINE-SETF-METHOD LIST (&REST REFERENCES &ENVIRONMENT ENV)
  (LOOP FOR REF IN REFERENCES
        WITH (VARS VALS STORES STORE-FORM)
	DO (MULTIPLE-VALUE-SETQ (VARS VALS STORES STORE-FORM)
	     (GET-DESTRUCTURING-BACKQUOTE-SETF-METHOD REF ENV))
	APPEND VARS INTO ALL-VARS
	APPEND VALS INTO ALL-VALS
	APPEND STORES INTO ALL-STORES
	COLLECT STORE-FORM INTO ALL-STORE-FORMS
	FINALLY
	  (LET ((LIST-VAR (GENSYM)))
	    (RETURN (VALUES ALL-VARS ALL-VALS (LIST LIST-VAR)
			    `(PROG1 ,LIST-VAR
				    ,@(LOOP FOR REF IN REFERENCES
					    FOR STORE-VAR IN ALL-STORES
					    FOR STORE-FORM IN ALL-STORE-FORMS
					    DO (IGNORE REF)
					    COLLECT (LET-SUBST (LIST STORE-VAR)
							       `((POP ,LIST-VAR))
							       STORE-FORM
							       ENV)))
			    `(COMPILE-TIME-ERROR "LIST-destructuring SETF is write-only"))))))

(DEFINE-SETF-METHOD LIST* (&REST REFERENCES &ENVIRONMENT ENV)
  (LOOP FOR REF IN REFERENCES
        WITH (VARS VALS STORES STORE-FORM)
	DO (MULTIPLE-VALUE-SETQ (VARS VALS STORES STORE-FORM)
	     (GET-DESTRUCTURING-BACKQUOTE-SETF-METHOD REF ENV))
	APPEND VARS INTO ALL-VARS
	APPEND VALS INTO ALL-VALS
	APPEND STORES INTO ALL-STORES
	COLLECT STORE-FORM INTO ALL-STORE-FORMS
	FINALLY
	  (LET ((LIST-VAR (GENSYM)))
	    (RETURN (VALUES ALL-VARS ALL-VALS (LIST LIST-VAR)
			    `(PROG1 ,LIST-VAR
				    ,@(LOOP FOR REF IN REFERENCES
					    FOR STORE-VAR IN ALL-STORES
					    FOR STORE-FORM IN ALL-STORE-FORMS
					    AS NOT-LAST = (CDR REFERENCES) THEN (CDR NOT-LAST)
					    DO (IGNORE REF)
					    COLLECT (LET-SUBST (LIST STORE-VAR)
							       (IF NOT-LAST
								   `((POP ,LIST-VAR))
								   `(,LIST-VAR))
							       STORE-FORM
							       ENV)))
			    `(COMPILE-TIME-ERROR "LIST-destructuring SETF is write-only"))))))

(DEFINE-SETF-METHOD CONS (CAR CDR &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (VARS1 VALS1 STORES1 STORE-FORM1)
      (GET-DESTRUCTURING-BACKQUOTE-SETF-METHOD CAR ENV)
    (MULTIPLE-VALUE-BIND (VARS2 VALS2 STORES2 STORE-FORM2)
	(GET-DESTRUCTURING-BACKQUOTE-SETF-METHOD CDR ENV)
      (LET ((CONS-VAR (GENSYM)))
	(VALUES (APPEND VARS1 VARS2)
		(APPEND VALS1 VALS2)
		(LIST CONS-VAR)
		`(PROGN ,(LET-SUBST STORES1 `((CAR ,CONS-VAR)) STORE-FORM1 ENV)
			,(LET-SUBST STORES2 `((CDR ,CONS-VAR)) STORE-FORM2 ENV)
			,CONS-VAR)
		`(COMPILE-TIME-ERROR "CONS-destructuring SETF is write-only"))))))

;This implements ignoring of constants
(DEFUN GET-DESTRUCTURING-BACKQUOTE-SETF-METHOD (REFERENCE ENV)
  (COND ((NOT (CONSTANTP REFERENCE ENV))
	 (GET-SETF-METHOD REFERENCE ENV))
	(T
	 (WHEN (SYMBOLP REFERENCE)		;--- Do we want this?
	   (COMPILER:WARN () "~S is being regarded as a constant, not a variable, ~
			         in this destructuring SETF"
			  REFERENCE))
	 (LET ((GENSYM (GENSYM)))
	   (VALUES () () (LIST GENSYM) GENSYM REFERENCE)))))

;A placeholder form that gives an error if it is ever compiled, and turns into NIL
(DEFMACRO COMPILE-TIME-ERROR (FORMAT-STRING &REST FORMAT-ARGS)
  (APPLY #'COMPILER:WARN () FORMAT-STRING FORMAT-ARGS)
  NIL)

(DEFINE-SETF-METHOD VECTOR (&REST REFERENCES &ENVIRONMENT ENV)
  (LOOP FOR REF IN REFERENCES
        WITH (VARS VALS STORES STORE-FORM)
	DO (MULTIPLE-VALUE-SETQ (VARS VALS STORES STORE-FORM)
	     (GET-DESTRUCTURING-BACKQUOTE-SETF-METHOD REF ENV))
	APPEND VARS INTO ALL-VARS
	APPEND VALS INTO ALL-VALS
	APPEND STORES INTO ALL-STORES
	COLLECT STORE-FORM INTO ALL-STORE-FORMS
	FINALLY
	  (LET ((LIST-VAR (GENSYM)))
	    (RETURN (VALUES ALL-VARS ALL-VALS (LIST LIST-VAR)
			    `(PROGN ,@(LOOP FOR REF IN REFERENCES
					    FOR INDEX FROM 0
					    FOR STORE-VAR IN ALL-STORES
					    FOR STORE-FORM IN ALL-STORE-FORMS
					    DO (IGNORE REF)
					    COLLECT (LET-SUBST (LIST STORE-VAR)
							       `((AREF ,LIST-VAR ,INDEX))
							       STORE-FORM
							       ENV))
				    ,LIST-VAR)
			    `(COMPILE-TIME-ERROR "VECTOR-destructuring SETF is write-only"))))))

;--- SETF of VALUES of plain variables isn't going to use MULTIPLE-VALUE-SETQ as it should,
;--- but it can only do that when executed for effect!  Unless we're allowed to return
;--- only the first of the correct values, instead of all of them!
;--- This generates substantially worse code, even on the L machine,
;--- because of the extra variables used in the MULTIPLE-VALUE-BIND.
(DEFINE-SETF-METHOD VALUES (&REST REFERENCES &ENVIRONMENT ENV)
  (LOOP FOR REF IN REFERENCES
        WITH (VARS VALS STORES STORE-FORM ACCESS-FORM)
	DO (MULTIPLE-VALUE-SETQ (VARS VALS STORES STORE-FORM ACCESS-FORM)
	     (GET-SETF-METHOD REF ENV))
	APPEND VARS INTO ALL-VARS
	APPEND VALS INTO ALL-VALS
	APPEND STORES INTO ALL-STORES
	COLLECT STORE-FORM INTO ALL-STORE-FORMS
	COLLECT ACCESS-FORM INTO ALL-ACCESS-FORMS
	FINALLY
	  (SETQ STORES (LOOP FOR L ON REFERENCES
			     DO (IGNORE L)
			     COLLECT (GENSYM)))
	  (RETURN (VALUES ALL-VARS ALL-VALS STORES
			  `(VALUES ,@(LOOP FOR REF IN REFERENCES
					   FOR VALUE-VAR IN STORES
					   FOR STORE-VAR IN ALL-STORES
					   FOR STORE-FORM IN ALL-STORE-FORMS
					   DO (IGNORE REF)
					   COLLECT (LET-SUBST (LIST STORE-VAR)
							      (LIST VALUE-VAR)
							      STORE-FORM
							      ENV)))
			  (IF (= (LENGTH ALL-ACCESS-FORMS) 1)
			      `(VALUES ,@ALL-ACCESS-FORMS)
			      `(COMPILE-TIME-ERROR "VALUES-destructuring SETF is write-only"))))))

;Pretend the last argument is only a single argument, get the setf method
;for that form, then stick APPLY back in.  Since this doesn't understand
;the code it is generating in any deep way, it can be fooled into generating
;wrong code when it should have generated an error at macroexpansion time
;saying that it doesn't understand what it's doing.
(DEFINE-SETF-METHOD APPLY (FUNCTION &REST ARGS &ENVIRONMENT ENV)
  (IF (AND (LISTP FUNCTION)
	   (= (LIST-LENGTH FUNCTION) 2)
	   (MEMBER (FIRST FUNCTION) '(QUOTE FUNCTION FUTURE-COMMON-LISP:FUNCTION))
	   (SYMBOLP (SECOND FUNCTION)))
      (SETQ FUNCTION (SECOND FUNCTION))
      (ERROR "~S is not a constant function; APPLY of it is~@
	      not understood as a generalized variable" FUNCTION))
  (MULTIPLE-VALUE-BIND (VARS VALS STORE-VARS STORE-FORM ACCESS-FORM)
      (GET-SETF-METHOD-MULTIPLE-VALUE (CONS FUNCTION ARGS) ENV)
    (LET* ((LAST-ARG (CAR (LAST ARGS)))
	   (LAST-ARG-CONSTANT (CONSTANTP LAST-ARG ENV))
	   (LIST-VAR (LOOP FOR VAR IN VARS AND VAL IN VALS
			   WHEN (EQL VAL LAST-ARG) RETURN VAR))
	   (LIST-ACCESS-FORM (CAR (LAST ACCESS-FORM)))
	   (LIST-STORE-FORM (CAR (LAST STORE-FORM))))
      (UNLESS (AND (OR (AND LIST-VAR (EQL LIST-ACCESS-FORM LIST-VAR))
		       (AND LAST-ARG-CONSTANT (EQL LIST-ACCESS-FORM LAST-ARG)))
		   (OR (AND LIST-VAR (EQL LIST-STORE-FORM LIST-VAR))
		       (AND LAST-ARG-CONSTANT (EQL LIST-STORE-FORM LAST-ARG))))
	(ERROR "APPLY of ~S not understood as a generalized variable" FUNCTION))
      (VALUES VARS VALS STORE-VARS
	      `(APPLY #',(FIRST STORE-FORM) . ,(REST STORE-FORM))
	      `(APPLY #',(FIRST ACCESS-FORM) . ,(REST ACCESS-FORM))))))


;Ditto for LOCF
;---Too bad the macroexpansion environment isn't passed down
(DEFLOCF APPLY (FUNCTION &REST ARGS &ENVIRONMENT ENV)
  (IF (AND (LISTP FUNCTION)
	   (= (LIST-LENGTH FUNCTION) 2)
	   (MEMBER (FIRST FUNCTION) '(QUOTE FUNCTION))
	   (SYMBOLP (SECOND FUNCTION)))
      (SETQ FUNCTION (SECOND FUNCTION))
      (ERROR "~S is not a constant function; APPLY of it is~@
	      not understood as a generalized variable" FUNCTION))
  (LET ((FORM (EXPAND-LOCF (CONS FUNCTION ARGS) ENV)))
    `(APPLY #',(FIRST FORM) . ,(REST FORM))))

(DEFINE-SETF-METHOD THE (TYPE VALUES-FORM &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)
      (GET-SETF-METHOD-MULTIPLE-VALUE VALUES-FORM ENV)
    (LET ((MY-STORES (MAPCAR #'(LAMBDA (IGNORE) (GENSYM)) STORES)))
      (VALUES VARS
	      VALS
	      MY-STORES
	      `(MULTIPLE-VALUE-BIND (,@STORES) (THE ,TYPE (VALUES ,@MY-STORES))
		 ,STORE-FORM)
	      `(THE ,TYPE ,ACCESS-FORM)))))

(DEFLOCF THE (TYPE VALUE-FORM)
  (DECLARE (IGNORE TYPE))
  `(LOCF ,VALUE-FORM))
