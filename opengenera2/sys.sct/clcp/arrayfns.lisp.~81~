;;; -*- Mode: Lisp; Package: Common-lisp-internals; Lowercase: T; Syntax: Common-Lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Array functions, Chapter 17

;;; When a real check-arg form becomes available, this file should be
;;; changed to take advantage of it.  But currently this file is loaded
;;; before the type system.

#+3600
(defun make-array (dimensions
		   &key (element-type t) (initial-element nil initial-element-p)
			(initial-contents nil initial-contents-p)
			adjustable fill-pointer displaced-to displaced-index-offset
			displaced-conformally
			area leader-list leader-length named-structure-symbol)
  (declare lt:(side-effects reader))
  (when (and fill-pointer (null leader-list) (null leader-length))
    (setq leader-length 1))
  (when initial-contents-p
    (compiler:%error-when initial-element-p
      (error "~S may not be specified when ~S is" :initial-contents :initial-element))
    (compiler:%error-when displaced-to
      (error "~S may not be specified when ~S is" :initial-contents :displaced-to)))
  (when initial-element-p
    (compiler:%error-when displaced-to
      (error "~S may not be specified when ~S is" :displaced-to :initial-element)))
  (let ((array (zl:make-array
		 dimensions
		 :type (type-array-element-type element-type)
		 :initial-value initial-element
		 :displaced-to displaced-to
		 :displaced-index-offset displaced-index-offset
		 :displaced-conformally displaced-conformally
		 :area area
		 :leader-list leader-list
		 :leader-length leader-length
		 :named-structure-symbol named-structure-symbol
		 :adjustable adjustable
		 )))
    (when fill-pointer
      (unless (= 1 (array-rank array))
	(error "The :fill-pointer option must only be used for one-d arrays"))
      (if (eq fill-pointer t)
	  (setq fill-pointer (array-dimension array 0)))
      (if (or (not (fixnump fill-pointer))
	      (minusp fill-pointer))
	  (error "~S is not a legal value for the :fill-pointer option" fill-pointer))
      (setf (fill-pointer array) fill-pointer))
    (when initial-contents-p
      (initialize-array-contents array dimensions initial-contents))
    array))

#+imach
(defun make-array (dimensions
		   &key (element-type t) (initial-element nil initial-element-p)
			(initial-contents nil initial-contents-p)
			adjustable fill-pointer displaced-to displaced-index-offset
			displaced-conformally
			area leader-list leader-length named-structure-symbol)
  (declare lt:(side-effects reader))
  (when initial-contents-p
    (compiler:%error-when initial-element-p
      (error "~S may not be specified when ~S is" :initial-contents :initial-element))
    (compiler:%error-when displaced-to
      (error "~S may not be specified when ~S is" :initial-contents :displaced-to)))
  (when initial-element-p
    (compiler:%error-when displaced-to
      (error "~S may not be specified when ~S is" :displaced-to :initial-element)))
  (let ((array 
	  (si:make-array-internal dimensions (type-array-element-type element-type) area
				  leader-list leader-length fill-pointer displaced-to
				  displaced-index-offset named-structure-symbol initial-element
				  displaced-conformally adjustable)))
    (when initial-contents-p
      (initialize-array-contents array dimensions initial-contents))
    array))

;;; This is the common subroutine.
(defun initialize-array-contents (array dimensions initial-contents)
  (cond ((null dimensions)
	 (setf (aref array) initial-contents))
	((or (numberp dimensions) (= (length dimensions) 1))
	 (when (listp dimensions) (setq dimensions (car dimensions)))
	 (cond ((and (listp initial-contents) (= (length initial-contents) dimensions))
		(loop for elt in initial-contents for i from 0 do
		  (setf (aref array i) elt)))
	       ((and (vectorp initial-contents)
		     (= (vector-length initial-contents) dimensions))
		(copy-array-contents initial-contents array))
	       (T
		(error "The initial-contents are ~S, but the array is ~S long"
		       initial-contents dimensions))))
	(T
	 (labels ((sub-part-initialize (offset size initial-contents dimensions wd)
		    (let ((dim0 (first dimensions)) (other-dims (rest dimensions)))
		      (cond ((arrayp initial-contents)
			     (let ((init-rank (array-rank initial-contents))
				   (init-dims (array-dimensions initial-contents)))
			       (cond ((and (= (length dimensions) init-rank) (every #'= dimensions init-dims))
				      (copy-array-portion initial-contents 0 size
							  array offset (+ offset size)))
				     ((and (= init-rank 1)
					   (= (vector-length initial-contents) dim0)
					   (> dim0 0))
				      (loop with subsize = (/ size dim0)
					    for suboffset from offset by subsize
					    for i from 0 below dim0 do
					(sub-part-initialize suboffset subsize (aref initial-contents i)
							     other-dims (1+ wd))))
				     (T
				      (error "The initial-contents contains ~S, which does not ~
						match the array's ~@[~:R and greater ~]dimensions ~
									       which are ~S"
					     initial-contents (when (plusp wd) (1+ wd)) dimensions)))))
			    ((and (listp initial-contents) (= (length initial-contents) dim0))
			     (if (null other-dims)
				 (let ((array array))
				   (declare (sys:array-register-1d array))
				   (loop for val in initial-contents for i from offset do
				     (setf (sys:%1d-aref array i) val)))
				 (when (> dim0 0)
				   (loop with subsize = (/ size dim0)
					 for suboffset from offset by subsize
					 for subseq in initial-contents do
				     (sub-part-initialize suboffset subsize subseq other-dims (1+ wd))))))
			    (T
			     (error "The initial-contents contains ~S, but the array's ~
							      ~:R dimension is ~D"
				    initial-contents (1+ wd) dim0))))))
	   (sub-part-initialize 0 (apply #'* dimensions) initial-contents dimensions 0))))
  array)

#||
;;; testing
()
;;; these should work
(loop for init in '((one four nine sixteen)
		    (#(one) (four) nine 16)
		    #(one four nine sixteen))
      do (print (make-array 4 :initial-contents init)))
;;; these should error
(make-array 4 :initial-contents '(one four nine sixteen twenty-five))
(make-array 4 :initial-contents #2A((one four) (nine sixteen)))
;;; these should work
(loop for init in '((#(1 2 3) #(2 3 4) (3 4 5))	  ;list of sequences (some lists, some arrays)
		    #((1 2 3) (2 3 4) #(3 4 5))	  ;array of sequences (some lists, some arrays)
		    #2A((1 2 3) (2 3 4) (3 4 5))) ;2d array
      do (print (make-array '(3 3) :initial-contents init)))
;;; these should error
(make-array '(3 3) :initial-contents #(1 2 3 2 3 4 3 4 5))
(make-array '(3 3) :initial-contents #2A((1 2 3) (2 3 4) (3 4 5) (4 5 6)))
;;; these should work
(loop for init in '((#2A((a b) (b a)) #(#(x y) #(y x)))
		    #3A(((t nil) (nil t)) ((foo bar) (baz bat)))
		    (((c d) (d c)) ((dd cc) (cc dd))))
      do (print (make-array '(2 2 2) :initial-contents init)))
;;; these should error
(make-array '(2 2 2) :initial-contents #2A(((t nil) (nil t)) (#(foo bar) #(baz bat))))
(make-array '(2 2 2) :initial-contents '(((c d e) (e d c)) ((dd cc) (cc dd))))
(make-array '(1 1 1 1) :initial-contents #(#2A(((x)))))	;should exercise the "nth and later dimensions"
||#


(defconstant array-rank-limit 8)

(defconstant array-dimension-limit (ash 1 27.))

(defconstant array-total-size-limit array-dimension-limit)

(defconstant array-leader-length-limit
	     #+3600
	     (sys:defsysbyte-limit-value sys:array-long-leader-length-field)
	     #+IMACH
	     (sys:defsysbyte-limit-value sys:array-leader-length-field)
	     )

;;; Type system support needed during system load.  Originally in TYPE-INFRA.

(defparameter *array-element-types*
  '((sys:art-1b . (integer 0 (2)))
    (sys:art-2b . (integer 0 (4)))
    (sys:art-4b . (integer 0 (16)))
    (sys:art-8b . (integer 0 (256)))
    (sys:art-16b . (integer 0 (65536)))
    (sys:art-fixnum . fixnum)
    (sys:art-string . string-char)
    (sys:art-fat-string . character)
    (sys:art-boolean . (member t nil))
    (sys:art-q . t)
    (sys:art-q-list . t)))

(defparameter *common-array-types*		;For COMMONP
  '(sys:art-1b sys:art-2b sys:art-4b sys:art-8b sys:art-16b 
	       sys:art-boolean
	       sys:art-fixnum
	       ;; Note that ZL strings are deliberately excluded; so are
	       ;; SYS:ART-Q-LIST arrays.
	       sys:art-q))

(defun array-element-type (array)
  (declare lt:(side-effects reducible reader))
  (let ((elem (assoc (sys:array-type array) *array-element-types*)))
    (if elem (cdr elem) 'nil)))			;If it's not in our table, say it can't hold
						;any objects at all!

(defparameter *atomic-array-element-types*
  '((t . sys:art-q)
    (string-char . sys:art-string)
    (character . sys:art-fat-string)
    (boolean . sys:art-boolean)
    (bit . sys:art-1b)))

(defparameter *integer-array-element-types*
  '((0 1 . sys:art-1b)
    (0 3 . sys:art-2b)
    (0 15 . sys:art-4b)
    (0 255 . sys:art-8b)
    (0 65535 . sys:art-16b)
    (#.most-negative-fixnum #.most-positive-fixnum . sys:art-fixnum)))

;;; I think this will be fast enough that if called by the compiler for the normal
;;; case and optimized we'll do ok.
;;; It wasn't, but maybe this is.
(defun type-array-element-type (desired-type)
  (compiler:%error-when (eq desired-type nil)			;Avoid making an ART-1B!
    (error "Attempt to make an array with :ELEMENT-TYPE NIL, probably an error"))
  (flet ((find-array-type (desired-type)
	   (typecase desired-type
	     (symbol (cdr (assoc desired-type *atomic-array-element-types*)))
	     (cons
	       (case (first desired-type)
		 (integer
		   (let ((args (rest desired-type)))
		     (unless (and (consp args)
				  (consp (rest args)))
		       (return-from find-array-type 'sys:art-q))
		     (let ((low (first args))
			   (high (second args)))
		       (unless (integerp low)
			 (if (and (consp low) (integerp (first low)))
			     (setq low (1+ (first low)))
			     (return-from find-array-type 'sys:art-q)))
		       (unless (integerp high)
			 (if (and (consp high) (integerp (first high)))
			     (setq high (1- (first high)))
			     (return-from find-array-type 'sys:art-q)))
		       (dolist (entry *integer-array-element-types* 'sys:art-q)
			 (when (and ( high (second entry))
				    ( (first entry) low))
			   (return (rest (rest entry))))))))
		 (member
		   (dolist (element (rest desired-type) 'sys:art-boolean)
		     (unless (member element '(t nil))
		       (return nil)))))))))
    (or (find-array-type desired-type)
	(let ((expanded-type (type-expand desired-type *subtypep-terminal-types*)))
	  (or (and (not (eql desired-type expanded-type))
		   (find-array-type expanded-type))
	      (car (rassoc expanded-type *array-element-types* :test #'subtypep))
	      (error "~S not a subtype of T?" desired-type))))))

(defun vector (&rest objects)
  (declare lt:(side-effects reader))
  (let ((vector (zl:make-array (list-length objects))))
    (loop for i from 0
	  for o in objects do
	  (setf (aref vector i) o))
    vector))

(defun stack-vector (&rest objects)
  (declare lt:(side-effects reader))
  (let ((vector (make-stack-array (list-length objects))))
    (loop for i from 0
	  for o in objects do
	  (setf (aref vector i) o))
    vector))

(defun adjustable-array-p (array)
  (declare lt:(side-effects simple reducible))
  (check-type array array)
  (or (not (array-displaced-p array))
      #+3600
      (let ((dispatch (array-dispatch-field array)))
	(or (= dispatch %array-dispatch-long)
	    (= dispatch %array-dispatch-long-multidimensional)))
      #+IMACH
      (= 1 (array-long-prefix-bit array))))

;;; aref is shared with ZL.
;;; array-element-type is defined in types.lisp.
;;; array-rank is linked to zl:array-#-dims.
;;; array-dimension is defined in functions.lisp.
;;; array-dimensions is shared with ZL.
;;; array-total-size is linked to zl:array-length
;;; array-in-bounds-p is shared with ZL.
;;; bit is linked to zl:aref.
;;; sbit is linked to zl:aref.

(defsubst svref (vector index)
  (aref vector index))


;;; Bit-array functions: fast version

;--- This doesn't work for conformal displaced indirect arrays (it fails
;--- to skip the gaps between the rows.)

;Execution times for BIT-AND:
; third arg of T,   44 microseconds setup + 31 nanoseconds per bit (1.0 microseconds/word)
; three arguments,  74 microseconds setup + 56 nanoseconds per bit (1.8 microseconds/word)
;The first case is 44 macroinstructions plus the function call (which I counted in the setup).
;Setup overhead will be a few microseconds worse when the non-aligned cases work.

;;; This is similar to TV:WITH-BITBLT-ENVIRONMENT-INTERNAL
;;; Note well: the next local variable bound in the body must be BB-ALU-OPERATION
#+3600
(defmacro bit-array-function-setup ((nargs) &body body)
  (let ((extra-locals (if ( nargs 9.) (make-list (- 9. nargs) :initial-element 'ignore)
			  (error "Too many arguments already: ~D." nargs))))
    `(let (,@extra-locals 
	   ;; This is the block that is known about by the microcode
	   bb-width
	   bb-s-data-addr (bb-s-row-offset 0) bb-s-offset bb-s-bitpos
	   (bb-s-row-length cl:most-positive-fixnum)	;no wraparound desired
	   bb-d-data-addr bb-d-offset bb-d-bitpos
	   bb-event-count)
       ;; These may not be used explicitly
       (progn bb-s-row-offset bb-s-offset bb-s-bitpos bb-s-row-length bb-event-count)
       . ,body)))

;Returns the upper bound in case you want to error-check it
#+3600
(defmacro bit-array-source (array)
  `(multiple-value-bind (ignore control address end start)
       (setup-force-1d-array-sequential ,array)
     (setq bb-event-count control)
     (unless (= (ldb (defstorage-field-byte array-register-dispatch-field) control)
		%array-dispatch-1-bit)
       (check-type ,array (array bit)))
     (setq bb-s-data-addr address
	   bb-s-offset (ldb (byte 27. 5) start)
	   bb-s-bitpos (ldb (byte 5 0) start)
	   bb-width (- end start))
     end))

;Stores the length where the microcode wants it, also returns the upper bound
#+3600
(defmacro bit-array-destination (array &optional no-source)
  `(multiple-value-bind (ignore control address end start)
       (setup-force-1d-array-sequential ,array)
     (unless (= (ldb (defstorage-field-byte array-register-dispatch-field) control)
		%array-dispatch-1-bit)
       (check-type ,array (array bit)))
     (setq bb-d-data-addr address
	   bb-d-offset (ldb (byte 27. 5) start)
	   bb-d-bitpos (ldb (byte 5 0) start))
     ,(if no-source
	  `(progn
	     (setq bb-event-count control)
	     (setq bb-width (- end start)))
	  `(unless (= bb-width (- end start))
	     (error "The arrays are not the same size.")))
     end))

;;; This must be called without any bindings between it and the BIT-ARRAY-FUNCTION-SETUP
;;; I don't think it's worth the check for the case where we can call %BITBLT-SHORT-ROW
;;; since the check takes almost as long as the time saved.
#+3600
(defmacro bit-array-microcode (alu)
  `(let ((bb-alu-operation ,alu))
     bb-alu-operation  ;the microcode will use it
     (sys:%bitblt-long-row)))

#+3600
(defun bit-not (source &optional destination)
;This declaration ought to be used, but doesn't work.  Generates the right code anyway.
; (declare (ordered-local-variables))
  (bit-array-function-setup (2)
    (ignore bb-d-bitpos bb-d-offset bb-d-data-addr bb-s-data-addr)
    (cond ((or (eq destination t) (eq destination source))
	   (bit-array-destination source t)
	   (bit-array-microcode #b1100)
	   source)
	  (t
	   (or destination
	       (setq destination (zl:make-array (array-dimensions source) :type 'art-1b)))
	   (bit-array-source source)
	   (bit-array-destination destination)
	   (bit-array-microcode #b1010)
	   destination))))

#+3600
(defmacro define-2arg-bit-array-function (name alu)
  `(defun ,name (first second &optional third)
     (declare (function-parent ,name define-2arg-bit-array-function))
;This declaration ought to be used, but doesn't work.  Generates the right code anyway.
;    (declare (ordered-local-variables))
     (bit-array-function-setup (3)
       (ignore bb-d-bitpos bb-d-offset bb-d-data-addr bb-s-data-addr)
       (cond ((or (eq third t) (eq third first))
	      (bit-array-source second)
	      (bit-array-destination first)
	      (bit-array-microcode ,(dpb (ldb (byte 1 2) alu) (byte 1 1)	;Commute
					 (dpb (ldb (byte 1 1) alu) (byte 1 2) alu)))
	      first)
	     ((eq third second)
	      (bit-array-source first)
	      (bit-array-destination second)
	      (bit-array-microcode ,alu)
	      second)
	     (t
	      (or third
		  (setq third (zl:make-array (array-dimensions first) :type 'art-1b)))
	      (bit-array-source second)
	      (bit-array-destination third)
	      (bit-array-microcode #b0101)	;copy
	      (bit-array-source first)
	      (bit-array-destination third)
	      (bit-array-microcode ,alu)
	      third)))))



#+imach
(defmacro decoding-bit-array ((bit-array prefix) &body body)
  (flet ((make-name (name) (fintern "~A-~A" prefix name)))
    (let ((array (make-name "ARRAY"))
	  (control (make-name "CONTROL"))
	  (beg-addr (make-name "BEG-ADDR"))
	  (actual-size (make-name "ACTUAL-SIZE"))
	  (total-size (make-name "TOTAL-SIZE"))
	  (event (gensym))
	  (header (gensym))
	  (length (gensym))
	  (offset (gensym))
	  (indirect (gensym)))
      `(progn
	 (si:check-arg ,bit-array (type-member ,bit-array dtp-array dtp-string) "an array")
	 (setf (%block-register 1) ,bit-array)
	 (let* ((,event (%read-internal-register %register-event-count))
		(,array ,bit-array)
		(,header (%pointer (%block-read 1 :cycle-type %memory-header))))
	   (compiler:%error-unless (= (%logldb array-type-field ,header) sys:art-1b)
	     (error "~S is not a bit array." ,array))
	   (compiler:%error-when (and (ldb-test array-long-prefix-bit ,header)
				      (ldb-test array-discontiguous-bit ,header))
	     (error "~S does not have contiguous storage." ,array))
	   (multiple-value-bind (,control ,beg-addr ,total-size)
	       (if (ldb-test array-long-prefix-bit ,header)
		   (let ((,length (%block-read 1))
			 (,offset (%block-read 1 :prefetch nil))
			 (,indirect (%block-read 1 :prefetch nil)))
		     (cond ((or (type-member ,indirect dtp-locative)
				(type-member ,indirect dtp-physical-address)
				(type-member ,indirect dtp-fixnum))
			    (values
			      (%logdpb ,event array-register-event-count-and-byte-offset
				       ,header)
			      ,indirect
			      ,length))
			   (t
			    (compiler:%error-unless
			      (type-member ,indirect dtp-array dtp-string)
			      (error "Invalid indirect pointer found in array"))
			    (multiple-value-bind (,control ,beg-addr ,actual-size)
				(si:displaced-array-register-values
				  ,event ,header ,length ,offset ,indirect)
			      (compiler:%error-when (< ,actual-size ,length)
				(error "~A does not have all its storage." ,array))
			      (values ,control ,beg-addr ,length)))))
		   (let ((,length (ldb array-short-length-field ,header)))
		     (values
		       (%logdpb ,event array-register-event-count-and-byte-offset ,header)
		       (%block-register 1)
		       ,length)))
	     ,array ,control ,beg-addr ,total-size
	     ,@body))))))

;;; NOTE: This is a customized version of BITBLT-LOOP-CALL in BITBLT and should be 
;;; adjusted if relevant changes are made there. It should be the equivalent of 
;;;   (BITBLT-LOOP-CALL :SINGLE T alu D-TOTAL-SIZE)
;;; It is hardcoded here since BITBLT occurs much later in the system declaration list.

#+imach
(defmacro bit-array-bitblt-single-row (alu &optional no-source)
  `(progn
     ,@(unless no-source
	 `((compiler:%error-unless (= s-total-size d-total-size)
	     (error "~S and ~S are not the same size." s-array d-array))))
     (let* ((d-bitpos (ldb array-register-byte-offset d-control))
	    (bit-offset ,(if no-source
			     'd-bitpos
			     `(- d-bitpos (ldb array-register-byte-offset s-control))))
	    (word-width (- (sys:%fixnum-floor (+ d-total-size d-bitpos) 32)
			   (if (zerop d-bitpos) 0 1)))
	    (first-column-mask (if (zerop d-bitpos) 0 (lsh -1 d-bitpos)))
	    (last-column-mask (lsh -1 (- (sys:%fixnum-mod (+ d-total-size d-bitpos) 32.) 32))))
       ;; First and last columns are one and the same
       (when (minusp word-width)
	 (setq word-width 0
	       last-column-mask (logand first-column-mask last-column-mask)
	       first-column-mask 0))
       ;; Dispatch to inner loop dependent on particular memory reference patterns
       (funcall (bitblt-inner-loop-fun :single ,alu)
		,alu
		,(if no-source nil 's-beg-addr)
		d-beg-addr
		bit-offset
		word-width
		first-column-mask
		last-column-mask
		,(if no-source
		     nil
		     `(> (sys:%fixnum-mod (+ d-total-size d-bitpos) 32)
			 (sys:%fixnum-mod bit-offset 32)))))))

;;;*********************************************************************
;;; IMach Bit-array functions: 

#+imach
(defun bit-not (source &optional destination)
  (cond ((or (eq destination t) (eq destination source))
	 (decoding-bit-array (source d)
	   (bit-array-bitblt-single-row boole-c2 t))
	 source)
	(t
	 (when (null destination)
	   (setf destination (make-array (array-dimensions source) :element-type 'bit)))
	 (decoding-bit-array (source s)
	   (decoding-bit-array (destination d)
	     (bit-array-bitblt-single-row boole-c1)))
	 destination)))

;;; This function is shared by all the BIT-xxx functions except BIT-NOT
;;; which only takes one (optionally two) arguments unlike the remaining
;;; functions. Originally each BIT-xxx function was an independent function
;;; based on this body, hardcoding in the alu references and the (dpb...)
;;; commuted alu. 
#+imach
(defun base-bit-array-function (alu first second &optional third)
  (cond ((or (eq third t) (eq third first))
	 (decoding-bit-array (second s)
	   (decoding-bit-array (first d)
	     (bit-array-bitblt-single-row (dpb (ldb (byte 1 2) alu) (byte 1 1)
					       (dpb (ldb (byte 1 1) alu) (byte 1 2) alu)))))
	 first)
	((eq third second)
	 (decoding-bit-array (first s)
	   (decoding-bit-array (second d)
	     (bit-array-bitblt-single-row alu)))
	 second)
	(t
	 (when (null third)
	   (setf third (make-array (array-dimensions first) :element-type 'bit)))
	 (decoding-bit-array (third d)
	   (decoding-bit-array (second s)
	     (bit-array-bitblt-single-row boole-1))	;copy
	   (decoding-bit-array (first s)
	     (decoding-bit-array (third d)
	       (bit-array-bitblt-single-row alu))))
	 third)))

#+IMACH
(defmacro define-2arg-bit-array-function (name alu)
  `(defun ,name (first second &optional third)
     (declare (function-parent ,name define-2arg-bit-array-function))
     (base-bit-array-function ,alu first second third)))

;;;*********************************************************************
;;; Shared definitions of actual functions for both 3600 and IMACH
;;; from their respective versions of the same macro.

(define-2arg-bit-array-function bit-and   #b0001)
(define-2arg-bit-array-function bit-ior   #b0111)
(define-2arg-bit-array-function bit-xor   #b0110)
(define-2arg-bit-array-function bit-eqv   #b1001)
(define-2arg-bit-array-function bit-nand  #b1110)
(define-2arg-bit-array-function bit-nor   #b1000)
(define-2arg-bit-array-function bit-andc1 #b0010)
(define-2arg-bit-array-function bit-andc2 #b0100)
(define-2arg-bit-array-function bit-orc1  #b1011)
(define-2arg-bit-array-function bit-orc2  #b1101)



;;; More bit-vector stuff from Cassels.  This is all heavily optimized.
;;; The optimizations done by the macros really should be done by the compiler
;;; under the control of declarations.

(defmacro %inline-logldb (bytespec integer)
  ;; do an inline optimized version since we know that the args are right
  (compiler:matchp bytespec
    (('byte size position)
     (if (and (numberp size) (numberp position))
	 `(sys:%logldb ,bytespec ,integer)
	 (let ((place (if (eql position 0)
			  integer
			  `(rot ,integer (- ,position))))
	       (shift (compiler:matchp size
			(('- '32 number)
			 `(- ,number))
			(* `(- ,size 32)))))
	   `(logand (lsh -1 ,shift) ,place))))
    (* `(sys:%logldb ,bytespec ,integer))))

(defmacro %inline-logdpb (newbyte bytespec integer)
  ;; do an inline optimized version since we know that the args are right
  (compiler:matchp bytespec
    (('byte size position)
     (if (and (numberp size) (numberp position))
	 `(sys:%logdpb ,newbyte ,bytespec ,integer)
	 (if (eql newbyte 0)
	     (let ((mask `(lsh -1 (- ,size 32))))
	       `(logand ,integer (lognot ,(if (eql position 0)
					      mask
					      `(rot ,mask ,position)))))
	     `(sys:%logdpb ,newbyte ,bytespec ,integer))))
    (* `(sys:%logdpb ,newbyte ,bytespec ,integer))))

(defmacro %integer-mod (integer divisor)
  (if (and (integerp divisor) (plusp divisor)
	   (zerop (logand divisor (1- divisor))))
      ;; positive integer power of two
      `(ldb (byte ,(1- (integer-length divisor)) 0) ,integer)
      `(mod ,integer ,divisor)))

(defmacro %nonnegative-fixnum-floor (integer divisor)
  (if (and (integerp divisor) (plusp divisor)
	   (zerop (logand divisor (1- divisor))))
      ;; positive integer power of two
      (let ((shifts (1- (integer-length divisor))))
	(if (< shifts 32)			;realy fits in a fixnum
	    `(sys:%logldb (byte ,(- 32 shifts) ,shifts) ,integer)
	    `(ash ,integer ,(- shifts))))
      `(floor ,integer ,divisor)))

#+3600
(defun decode-bit-vector (bit-vector start end)
  (declare (values ref bit-offset bits))
  ;; 0  bit-offset < 32
  (declare (dbg:error-reporter))
  (multiple-value-bind (array control base bound index-offset)
      ;; this will check the type of bit-vector to make sure it is a 1d array
      ;; admittedly the message could be more informative
      (sys:setup-1d-array-sequential bit-vector)
    (declare (ignore array))
    (unless (= (ldb (sys:defstorage-field-byte sys:array-register-dispatch-field) control)
	       sys:%array-register-dispatch-1-bit)	;check fast
      (check-type bit-vector bit-vector))	;signal an appropriate error
    (let ((start-bit-offset
	    (cond ((eql start 0)
		   index-offset)
		  (t
		   (check-type start (integer 0 *))
		   (+ index-offset start))))
	  (end-bit-offset
	    (cond ((null end)
		   (+ index-offset (sys:vector-length bit-vector)))
		  (t
		   (check-type end (or null (integer 0 *)))
		   (+ index-offset end)))))
      (if (<= 0 start-bit-offset end-bit-offset bound)
	  (values
	    (sys:%p-structure-offset base (1- (%nonnegative-fixnum-floor start-bit-offset 32)))
	    (%integer-mod start-bit-offset 32)
	    (- end-bit-offset start-bit-offset))
	  (error "The specified bounds (~D (~D)) are outside of the valid part of the bit vector (0 (~D))."
		 start (or end (sys:vector-length bit-vector)) (- bound index-offset))))))

#+IMACH
(defun decode-bit-vector (bit-vector start end)
  (declare (values ref bit-offset bits))
  ;; 0  bit-offset < 32
  (declare (dbg:error-reporter))
  (multiple-value-bind (array control base bound) (sys:setup-1d-array bit-vector)
    (declare (ignore array))
    (unless (= (%logldb array-register-byte-packing control) 0)	;Check fast
      (check-type bit-vector bit-vector))	;signal an appropriate error
    (let* ((byte-offset (%logldb array-register-byte-offset control))
	   (bit-offset
	     (cond ((eql start 0) byte-offset)
		   (t
		     (check-type start (integer 0 *))
		     (+ byte-offset (min start bound)))))
	   (length
	     (cond ((null end)
		    (- bound bit-offset))
		   (t
		     (check-type end (or null (integer 0 *)))
		     (cond ((< end start) 0)
			   ((> end bound)
			    (- (+ bound byte-offset) bit-offset))
			   (t (- end start)))))))
      (values (sys:%p-structure-offset base (1- (%nonnegative-fixnum-floor bit-offset 32)))
	      (%integer-mod bit-offset 32)
	      length))))

(defun bit-vector-zero-p (bit-vector &key (start 0) end)
  (multiple-value-bind (ref bit-offset bits)
      (decode-bit-vector bit-vector start end)
    (cond ((= bits 0))				;don't read if you don't have to
	  (( (+ bits bit-offset) 32)		;it all fits in one word
	   (zerop (%inline-logldb (byte bits bit-offset)
				  (sys:%p-contents-increment-pointer ref))))
	  (t
	   (and (or (zerop bit-offset)
		    (progn
		      (decf bits (- 32 bit-offset))
		      (zerop (%inline-logldb (byte (- 32 bit-offset) bit-offset)
					     (sys:%p-contents-increment-pointer ref)))))
		(and (loop repeat (%nonnegative-fixnum-floor bits 32)
			   always (zerop (sys:%p-contents-increment-pointer ref)))
		     (or (zerop (%integer-mod bits 32))
			 (zerop (%inline-logldb
				  (byte (%integer-mod bits 32) 0)
				  (sys:%p-contents-increment-pointer ref))))))))))

(defun bit-vector-cardinality (bit-vector &key (start 0) end)
  (multiple-value-bind (ref bit-offset bits)
      (decode-bit-vector bit-vector start end)
    (cond ((= bits 0) 0)			;don't read if you don't have to
	  (( (+ bits bit-offset) 32)		;it all fits in one word
	   (cli::bits-on-per-fixnum (%inline-logldb (byte bits bit-offset)
						    (sys:%p-contents-increment-pointer ref))))
	  (t
	   (+ (if (zerop bit-offset) 0
		  (progn
		    (decf bits (- 32 bit-offset))
		    (cli::bits-on-per-fixnum
		      (%inline-logldb (byte (- 32 bit-offset) bit-offset)
				      (sys:%p-contents-increment-pointer ref)))))
	      (+ (loop repeat (%nonnegative-fixnum-floor bits 32)
		       sum (cli::bits-on-per-fixnum
			     (sys:%p-contents-increment-pointer ref)))
		 (if (zerop (%integer-mod bits 32)) 0
		     (cli::bits-on-per-fixnum
		       (%inline-logldb (byte (%integer-mod bits 32) 0)
				       (sys:%p-contents-increment-pointer ref))))))))))

(defun bit-vector-position (bit bit-vector &key (start 0) end)
  (multiple-value-bind (ref bit-offset bits)
      (decode-bit-vector bit-vector start end)
    (check-type bit bit)
    (let ((mask (- bit 1)))			;mask is -1 to search for 0, 0 for 1
      (cond (( bits 0) nil)			;don't read if you don't have to
	    (( (+ bits bit-offset) 32)		;it all fits in one word
	     (let ((word (%inline-logldb (byte bits bit-offset)
					 (logxor (sys:%p-contents-increment-pointer ref)
						 mask))))
	       (and (not (zerop word))
		    (+ (1- (fixnum-rightmost-one word)) start))))
	    (t
	     (unless (zerop bit-offset)
	       ;; handle initial partial word
	       (let ((word (%inline-logldb
			     (byte (- 32 bit-offset) bit-offset)
			     (logxor (sys:%p-contents-increment-pointer ref)
				     mask))))
		 (unless (zerop word)
		   (return-from bit-vector-position
		     (+ (1- (fixnum-rightmost-one word)) start))))
	       (decf bits (- 32 bit-offset))
	       (incf start (- 32 bit-offset)))
	     ;; handle intermediate full words
	     (loop for i from 0 below (%nonnegative-fixnum-floor bits 32)
		   as word = (logxor (sys:%p-contents-increment-pointer ref)
				     mask)
		   do (unless (zerop word)
			(return-from bit-vector-position
			  (+ start
			     (* i 32)
			     (1- (fixnum-rightmost-one word))))))
	     (let ((1s (%integer-mod bits 32)))
	       (and (not (zerop 1s))
		    ;; handle last partial word
		    (let ((word (%inline-logldb
				  (byte 1s 0)
				  (logxor (sys:%p-contents-increment-pointer ref)
					  mask))))
		      (and (not (zerop word))
			   (+ (- bits 1s) start ;;fix by Jeff Barnett of Northrup
			      (1- (fixnum-rightmost-one word))))))))))))

(defun bit-vector-hash (bit-vector &key (start 0) end)
  (macrolet ((ones-complement-add (a b)
	       `(sys:%multiple-value-call-n
		  sys:%32-bit-plus
		  (sys:%add-bignum-step ,a ,b 0) 2)))
    (multiple-value-bind (ref bit-offset bits)
	(decode-bit-vector bit-vector start end)
      (sys:%32-bit-plus
	;; offset it a little so that 0 vectors don't map to 0
	;; and make sure that all 0 vectors don't map to the same place
	(sys:%32-bit-difference -7 (rot bits 7))
	(cond ((zerop bits) 0)
	      (( (+ bits bit-offset) 32)	;it all fits in one word
	       (%inline-logldb (byte bits bit-offset)
			       (sys:%p-contents-increment-pointer ref)))
	      (t
	       (let ((sum 0))
		 ;; sum the bits where they appear in the word
		 ;; at the end we'll rotate to put them where they should have been
		 (unless (zerop bit-offset)
		   (setq sum (%inline-logdpb 0 (byte bit-offset 0)
					     (sys:%p-contents-increment-pointer ref)))
		   (decf bits (- 32 bit-offset)))
		 (loop repeat (%nonnegative-fixnum-floor bits 32)
		       do (setq sum (ones-complement-add
				      (sys:%p-contents-increment-pointer ref)
				      sum)))
		 (unless (zerop (%integer-mod bits 32))
		   (setq sum (ones-complement-add
			       (%inline-logldb (byte (%integer-mod bits 32) 0)
					       (sys:%p-contents-increment-pointer ref))
			       sum)))
		 ;; make sure that it didn't matter what the offset was
		 (rot sum (- bit-offset)))))))))

(defmacro bit-vector-components-zerop-map (function bit-vector-1 start1 end1
					   bit-vector-2 start2 end2)
  `(block body
     (multiple-value-bind (ref bit-offset bits)
	 (decode-bit-vector ,bit-vector-1 ,start1 ,end1)
       (multiple-value-bind (ref-2 bit-offset-2 bits-2)
	   (decode-bit-vector ,bit-vector-2 ,start2 ,end2)
	 (unless (= bits bits-2)
	   (return-from body nil))
	 (when (zerop bits)			;don't read if you don't need to
	   (return-from body t))
	 ;; make sure that bit-vector-1 ends "later" than bit-vector-2
	 (unless ( bit-offset bit-offset-2)
	   (rotatef bit-offset bit-offset-2)
	   (rotatef ref ref-2))
	 (let ((offset-diff (- bit-offset bit-offset-2)))
	   (cond (( (+ bits bit-offset) 32)	;they both fit on one word
		  (zerop (%inline-logldb
			   (byte bits bit-offset)
			   (,function
			    (sys:%p-contents-increment-pointer ref)
			    (rot (sys:%p-contents-increment-pointer ref-2)
				 offset-diff)))))
		 ((zerop bit-offset)		;optimize common case
		  ;; 0  bit-offset-2  bit-offset = 0 => bit-offset-2 = bit-offset
		  (and (loop repeat (%nonnegative-fixnum-floor bits 32)
			     always
			       ,(case function
				  (logxor
				    `(= (sys:%p-contents-increment-pointer ref)
					(sys:%p-contents-increment-pointer ref-2)))
				  (otherwise
				    `(zerop
				       (,function
					(sys:%p-contents-increment-pointer ref)
					(sys:%p-contents-increment-pointer ref-2))))))
		       (or (zerop (%integer-mod bits 32))
			   (zerop (%inline-logldb
				    (byte (%integer-mod bits 32) 0)
				    (,function
				     (sys:%p-contents-increment-pointer ref)
				     (sys:%p-contents-increment-pointer ref-2)))))))
		 (t
		  (let* ((word (sys:%p-contents-increment-pointer ref))
			 (word-2 (rot (sys:%p-contents-increment-pointer ref-2)
				      offset-diff))
			 (diff-mask (lsh -1 (- offset-diff 32)))
			 (rest-mask (lognot diff-mask)))
		    ;; take care of the first chunk of bit-vector
		    (unless (zerop (%inline-logldb
				     (byte (- 32 bit-offset) bit-offset)
				     (,function word word-2)))
		      (return-from body nil))
		    (decf bits (- 32 bit-offset))
		    ;; now bit-vector is at offset 0, and there are offset-diff
		    ;; uncompared bits left in word-2
		    
		    ;; loop for all the complete words in bit-vector
		    (loop repeat (%nonnegative-fixnum-floor bits 32)
			  as prev-word-2 = word-2
			  do (setq word (sys:%p-contents-increment-pointer ref))
			     (setq word-2
				   (rot (sys:%p-contents-increment-pointer ref-2)
					offset-diff))
			     (unless (zerop
				       (logior
					 ;; compare the rest of previous word-2
					 ;; with first part of word
					 (logand (,function word prev-word-2)
						 diff-mask)
					 ;; compare the rest of word with the first
					 ;; part of word-2
					 (logand (,function word word-2)
						 rest-mask)))
			       (return-from body nil)))
		    (let ((bits-left (%integer-mod bits 32)))
		      (when (zerop bits-left)
			(return-from body t))
		      (setq word (sys:%p-contents-increment-pointer ref))
		      (if ( bits-left bit-offset)
			  (zerop
			    (%inline-logldb (byte bits-left 0)
					    (,function word word-2)))
			  (zerop
			    (logior
			      (logand (,function word word-2) diff-mask)
			      (%inline-logldb
				(byte (- bits-left bit-offset)
				      bit-offset)
				(,function
				 word
				 (rot (sys:%p-contents-increment-pointer ref-2)
				      offset-diff)))))))))))))))

(defun bit-vector-equal (bit-vector-1 bit-vector-2 &key (start1 0) end1 (start2 0) end2)
  (bit-vector-components-zerop-map logxor bit-vector-1 start1 end1
				   bit-vector-2 start2 end2))

(defun bit-vector-subset-p (bit-vector-1 bit-vector-2 &key (start1 0) end1 (start2 0) end2)
  ;; bit-vector-1 is a subset of bit-vector-2
  ;; in this system, logandc2 is a function
  (macrolet ((logandc2 (integer1 integer2) `(logand ,integer1 (lognot ,integer2))))
    (bit-vector-components-zerop-map logandc2 bit-vector-1 start1 end1
				     bit-vector-2 start2 end2)))

(defun bit-vector-disjoint-p (bit-vector-1 bit-vector-2 &key (start1 0) end1 (start2 0) end2)
  (bit-vector-components-zerop-map logand bit-vector-1 start1 end1
				   bit-vector-2 start2 end2))


;;; fill-pointer is shared with ZL.  (Omitted from Laser edition for some reason.)

(defun array-has-fill-pointer-p (array)
  (declare lt:(side-effects reducible simple))
  (and (array-has-leader-p array)
       (integerp (array-leader array 0))	;Same test as array-active-length
       (= (array-rank array) 1)))		;CL demands this

(defun vector-push (new-element vector)
  (zl:array-push vector new-element))

(defun vector-push-extend (new-element vector &optional extension)
  (zl:array-push-extend vector new-element extension))

;;; vector-pop is linked to zl:array-pop.

;;; ADJUST-ARRAY

;A subtlety is that official CL requires you to displace, not
;structure-forward, when you create a new array; it's different in
;various ways (the leader would not be shared if you displaced).  But
;there might not be enough room to store the displacement info, if one
;of the dimensions was originally zero (resulting in no allocation of
;data words).

;This won't change the leader; I suppose a keyword for that could be added.

(defun adjust-array (array new-dimensions
		     &key (element-type nil element-type-specified)
			  (initial-element nil initial-element-specified)
			  (initial-contents nil initial-contents-specified)
			  fill-pointer
			  displaced-to displaced-index-offset displaced-conformally)
  (check-type array array)
  (if (listp new-dimensions)
      (dolist (x new-dimensions)
	(unless (and (integerp x) ( x 0))
	  (error "The dimension, ~S, is not a non-negative integer" x)))
      (unless (and (integerp new-dimensions) ( new-dimensions 0))
	(error "The dimension, ~S, is not a non-negative integer" new-dimensions)))
  (let ((rank (array-rank array))
	(length (if (listp new-dimensions) (first new-dimensions) new-dimensions))
	(displaced (sys:array-displaced-p array)))
    (let ((new-rank (if (listp new-dimensions) (list-length new-dimensions) 1)))
      (unless (= new-rank rank)
	(error "The number of dimensions specified, ~S, did not equal the rank, ~S"
		new-rank rank)))
    (when element-type-specified
      (unless (eq (type-array-element-type element-type) (sys:array-type array))
	(error "The array does not hold elements of type ~S" element-type)))
    (when fill-pointer
      (unless (= rank 1)
	(error "The :fill-pointer option must only be used with vectors"))
      (setf (fill-pointer array) (cond ((eq fill-pointer t) length)
				       ((and (fixnump fill-pointer)
					     ( 0 fill-pointer length))
					fill-pointer)
				       (t (error "The fill-pointer, ~S, is not an ~
						  integer between 0 and ~S inclusive."
						 fill-pointer length)))))
    (if displaced
	(if displaced-to
	    (adjust-displaced-array array rank new-dimensions displaced-to
				    displaced-index-offset displaced-conformally)
	    (let ((new-array
		    (let ((area (sys:%area-number array)))
		      (make-array new-dimensions
				  :element-type (array-element-type array)
				  :area area
				  (if initial-element-specified :initial-element :area)
				   (if initial-element-specified initial-element area)
				  (if initial-contents-specified :initial-contents :area)
				   (if initial-contents-specified initial-contents area)
				  (if fill-pointer :fill-pointer :area)
				   (if fill-pointer fill-pointer area)))))
	      (adjust-displaced-array array rank new-dimensions new-array 0 t)
	      new-array))
	(if displaced-to
	    (let ((new-array
		    (let ((area (sys:%area-number array)))
		      (make-array new-dimensions
				  :element-type (array-element-type array)
				  :area area
				  :displaced-to displaced-to
				  :displaced-index-offset displaced-index-offset
				  :displaced-conformally displaced-conformally
				  (if fill-pointer :fill-pointer :area)
				   (if fill-pointer fill-pointer area)))))
	      (structure-forward array new-array)
	      new-array)
	    (let ((old-dimensions (and initial-element-specified
				       (if (= rank 1) (zl:array-length array)
					   (array-dimensions array))))
		  (new-array (if (= rank 1)
				 (si:adjust-array-size array length)
				 (apply #'si:array-grow array new-dimensions))))
	      (cond (initial-contents-specified
		     (initialize-array-contents new-array new-dimensions initial-contents))
		    (initial-element-specified
		     (if (= rank 1)
			 (when (> length old-dimensions)
			   (si:fill-array-portion new-array old-dimensions length
						  initial-element))
			 (initialize-array-expansion new-array initial-element
						     old-dimensions new-dimensions))))
	      new-array)))))

;;; array used to be of dimensions start-dimensions.  It is now of
;;; dimensions end-dimensions.  Fill the array with end-dimensions with
;;; item, except for the array within start-dimensions.
(defun initialize-array-expansion (array item start-dimensions end-dimensions)
  ;; Check for the array extent being empty, to save consing
  (unless (loop for s in start-dimensions for e in end-dimensions
		always ( s e))
    (let ((indices (make-list (list-length start-dimensions) :initial-element 0)))
      ;; Loop for each axis that has opened up some space
      (do ((axis 0 (1+ axis))
	   (s start-dimensions (cdr s))
	   (e end-dimensions (cdr e)))
	  ((null s))
	(when (< (car s) (car e))
	  ;; Initialize indices to first element to do
	  (do ((l indices (cdr l))
	       (i 0 (1+ i)))
	      ((null l))
	    (setf (car l) (if (= i axis) (car s) 0)))
	  ;; Back up so that after incrementing we will be at the first element
	  (decf (first indices))
	  ;; Iterate through all elements in this space
	  (loop named inner do
	    ;; Increment the list of subscripts.  Return if we are exhausted.
	    (do ((l indices (cdr l))
		 (s start-dimensions (cdr s))
		 (e end-dimensions (cdr e))
		 (i 0 (1+ i)))
		((null l) (return-from inner))
	      (when (< (incf (car l)) (car e))
		(return))
	      (setf (car l) (if (= i axis) (car s) 0)))	;"Carry" into the next dimension
	    (si:%lexpr-aset item array indices))))))
  array)

;;; Architecture-dependent function reminiscent of si:change-indirect-array
;;; Assumes the caller has already taken care of the error-checking
;;; so don't call this function directly if you are not ADJUST-ARRAY!!

#+3600
(defun adjust-displaced-array (array rank new-dimensions displaced-to
			       displaced-index-offset displaced-conformally)
  (check-type displaced-to (or array fixnum locative)
	     "an array to indirect to, or an address to displace to")
  #+row-major
  (unless displaced-index-offset
    (setq displaced-index-offset 0))
  #-row-major
  (if (arrayp displaced-to)
      (unless displaced-index-offset
	(setq displaced-index-offset 0))
      (when displaced-index-offset
	(error "Index offset is illegal when not indirecting to an array")))
  (and displaced-conformally
       ( (array-rank displaced-to) rank)
       (error "Conformal array displacement requires equal rank"))
  (let ((dispatch (array-dispatch-field array))
	(index-length (if (listp new-dimensions) (apply #'* new-dimensions) new-dimensions))
	(type (array-type-field array))
	(offset #+row-major 4 #-row-major 3))
    (select dispatch
      (sys:%array-dispatch-short-indirect
       (unless displaced-index-offset
	 (setq displaced-index-offset 0))
       (when (or ( index-length
		    (defsysbyte-limit-value array-short-indirect-length-field))
		 ( displaced-index-offset
		    (defsysbyte-limit-value array-short-indirect-offset-field)))
	 (error "Illegal attempt to change array's dispatch by making it too long")))
      ((sys:%array-dispatch-long %array-dispatch-long-multidimensional)
       #-row-major
       (cond ((arrayp (array-indirect-pointer array))
	      (unless displaced-index-offset
		(error "Illegal attempt to change array from indirect to displaced"))
	      (incf offset))
	     (displaced-index-offset
	      (error "Illegal attempt to change array from displaced to indirect"))))
      (otherwise
       (error "Unrecognized array format")))
    (when (> rank 1)
      ;; Store the dimensions
      (si:%store-multiple-array-dimensions array (= offset 4) new-dimensions)
      ;; (column-major order) Store the multipliers for all subscripts but the last, or
      ;; (row-major    order) Store the multipliers for all subscripts but the first.
      (if displaced-conformally
	  (setq index-length (si:%inherit-conformal-multipliers
			       array type rank new-dimensions displaced-to))
	  (si:%store-nonconformal-multipliers array rank new-dimensions)))
    (select dispatch
      (sys:%array-dispatch-short-indirect
       (setf (array-short-indirect-length-field array) index-length)
       (setf (array-short-indirect-offset-field array) displaced-index-offset))
      (sys:%array-dispatch-long
       (setf (array-long-length-field array) index-length)
       #+row-major (setf (array-index-offset-field array) displaced-index-offset)
       #-row-major (when displaced-index-offset
		     (setf (array-index-offset-field array) displaced-index-offset)))
      (sys:%array-dispatch-long-multidimensional
       #+row-major (setf (array-index-offset-field array) displaced-index-offset)
       #-row-major (when displaced-index-offset
		     ;; Make the overall length field include the elements of the array
		     ;; we indirect to that are between the rows of this array, since that's
		     ;; the way bounds checking wants to work.
		     (setq index-length (car (last new-dimensions)))
		     (loop repeat (1- rank) with off = (array-long-prefix-length-field array)
			   do (setq index-length (* index-length (sys:%p-contents-offset
								   array (decf off)))))
		     (setf (array-index-offset-field array) displaced-index-offset))
       (setf (array-long-length-field array) index-length)))
    (setf (array-indirect-pointer array) displaced-to)
    (array-register-event)
    array))

#+IMACH
(defun adjust-displaced-array (array rank new-dimensions displaced-to
			       displaced-index-offset displaced-conformally)
  (check-type displaced-to (or array fixnum locative physical-address)
	     "an array to indirect to, or an address to displace to")
  (unless displaced-index-offset
    (setq displaced-index-offset 0))
  (and displaced-conformally
       ( (array-rank displaced-to) rank)
       (error "Conformal array displacement requires equal rank"))
  (let ((index-length (if (listp new-dimensions) (apply #'* new-dimensions) new-dimensions)))
    (with-block-registers (1)
      (setf (%block-register 1) (locf (array-long-length-field array)))
      (si:prepare-for-block-write)
      (%block-write 1 index-length)
      (%block-write 1 displaced-index-offset)
      (%block-write 1 displaced-to)
      (cond ((listp new-dimensions)
	     (dolist (dim new-dimensions)
	       (%block-write 1 dim)
	       (%block-write 1 1)))
	    (t (%block-write 1 new-dimensions)
	       (%block-write 1 1))))
    (when (> rank 1)
      (if displaced-conformally
	  (si:%inherit-conformal-multipliers array displaced-to rank)
	  (si:%store-nonconformal-multipliers array rank)))
    (array-register-event)
    array))
