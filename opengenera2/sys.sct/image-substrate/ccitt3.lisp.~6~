;;; -*- Mode: LISP; Syntax: Common-lisp; Package: IMAGES; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defvar D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*white-termination-codes*
0	'(
	  0 "00110101"
	  1 "000111"
	  2 "0111"
	  3 "1000"
	  4 "1011"
	  5 "1100"
	  6 "1110"
	  7 "1111"
	  8 "10011"
	  9 "10100"
	  10 "00111"
	  11 "01000"
	  12 "001000"
	  13 "000011"
	  14 "110100"
	  15 "110101"
	  16 "101010"
	  17 "101011"
	  18 "0100111"
	  19 "000 1100"
	  20 "000 1000"
	  21 "001 0111"
	  22 "000 0011"
	  23 "000 0100"
	  24 "010 1000"
	  25 "010 1011"
	  26 "001 0011"
	  27 "010 0100"
	  28 "001 1000"
	  29 "0000 0010"
	  30 "0000 0011"
	  31 "0001 1010"
	  32 "0001 1011"
	  33 "0001 0010"
	  34 "0001 0011"
	  35 "0001 0100"
	  36 "0001 0101"
	  37 "0001 0110"
	  38 "0001 0111"
	  39 "0010 1000"
	  40 "0010 1001"
	  41 "0010 1010"
	  42 "0010 1011"
	  43 "0010 1100"
	  44 "0010 1101"
	  45 "0000 0100"
	  46 "0000 0101"
	  47 "0000 1010"
	  48 "0000 1011"
	  49 "0101 0010"
	  50 "0101 0011"
	  51 "0101 0100"
	  52 "0101 0101"
	  53 "0010 0100"
	  54 "0010 0101"
	  55 "0101 1000"
	  56 "0101 1001"
	  57 "0101 1010"
	  58 "0101 1011"
	  59 "0100 1010"
	  60 "0100 1011"
	  61 "0011 0010"
	  62 "0011 0011"
	  63 "0011 0100"
	  ))

(defvar 1*black-termination-codes*
0	'(
	  0 "0000110111"
	  1 "010"
	  2 "11"
	  3 "10"
	  4 "011"
	  5 "0011"
	  6 "0010"
	  7 "00011"
	  8 "000101"
	  9 "000100"
	  10 "000 0100"
	  11 "000 0101"
	  12 "000 0111"
	  13 "0000 0100"
	  14 "0000 0111"
	  15 "0 0001 1000"
	  16 "00 0001 0111"
	  17 "00 0001 1000"
	  18 "00 0000 1000"
	  19 "000 0110 0111"
	  20 "000 0110 1000"
	  21 "000 0110 1100"
	  22 "000 0011 0111"
	  23 "000 0010 1000"
	  24 "000 0001 0111"
	  25 "000 0001 1000"
	  26 "0000 1100 1010"
	  27 "0000 1100 1011"
	  28 "0000 1100 1100"
	  29 "0000 1100 1101"
	  30 "0000 0110 1000"
	  31 "0000 0110 1001"
	  32 "0000 0110 1010"
	  33 "0000 0110 1011"
	  34 "0000 1101 0010"
	  35 "0000 1101 0011"
	  36 "0000 1101 0100"
	  37 "0000 1101 0101"
	  38 "0000 1101 0110"
	  39 "0000 1101 0111"
	  40 "0000 0110 1100"
	  41 "0000 0110 1101"
	  42 "0000 1101 1010"
	  43 "0000 1101 1011"
	  44 "0000 0101 0100"
	  45 "0000 0101 0101"
	  46 "0000 0101 0110"
	  47 "0000 0101 0111"
	  48 "0000 0110 0100"
	  49 "0000 0110 0101"
	  50 "0000 0101 0010"
	  51 "0000 0101 0011"
	  52 "0000 0010 0100"
	  53 "0000 0011 0111"
	  54 "0000 0011 1000"
	  55 "0000 0010 0111"
	  56 "0000 0010 1000"
	  57 "0000 0101 1000"
	  58 "0000 0101 1001"
	  59 "0000 0010 1011"
	  60 "0000 0010 1100"
	  61 "0000 0101 1010"
	  62 "0000 0110 0110"
	  63 "0000 0110 0111"
	  ))

(defvar 1*white-make-up-codes*
0	'(
	  64 "11011"
	  128 "10010"
	  192 "010111"
	  256 "011 0111"
	  320 "0011 0110"
	  384 "0011 0111"
	  448 "0110 0100"
	  512 "0110 0101"
	  576 "0110 1000"
	  640 "0110 0111"
	  704 "0 1100 1100"
	  768 "0 1100 1101"
	  832 "0 1101 0010"
	  896 "0 1101 0011"
	  960 "0 1101 0100"
	  1024 "0 1101 0101"
	  1088 "0 1101 0110"
	  1152 "0 1101 0111"
	  1216 "0 1101 1000"
	  1280 "0 1101 1001"
	  1344 "0 1101 1010"
	  1408 "0 1101 1011"
	  1472 "0 1001 1000"
	  1536 "0 1001 1001"
	  1600 "0 1001 1010"
	  1664 "011000"
	  1728 "0 1001 1011"
	  EOL "0000 0000 0001"
	  ))

(defvar 1*black-make-up-codes*
0	'(
	  64 "00 0000 1111"
	  128 "0000 1100 1000"
	  192 "0000 1100 1001"
	  256 "0000 0101 1011"
	  320 "0000 0011 0011"
	  384 "0000 0011 0100"
	  448 "0000 0011 0101"
	  512 "0 0000 0110 1100"
	  576 "0 0000 0110 1101"
	  640 "0 0000 0100 1010"
	  704 "0 0000 0100 1011"
	  768 "0 0000 0100 1100"
	  832 "0 0000 0100 1101"
	  896 "0 0000 0111 0010"
	  960 "0 0000 0111 0011"
	  1024 "0 0000 0111 0100"
	  1088 "0 0000 0111 0101"
	  1152 "0 0000 0111 0110"
	  1216 "0 0000 0111 0111"
	  1280 "0 0000 0101 0010"
	  1344 "0 0000 0101 0011"
	  1408 "0 0000 0101 0100"
	  1472 "0 0000 0101 0101"
	  1536 "0 0000 0101 1010"
	  1600 "0 0000 0101 1011"
	  1664 "0 0000 0110 0100"
	  1728 "0 0000 0110 0101"
	  EOL "0000 0000 0001"
	  ))

(defvar 1*additional-make-up-codes*
0	'(
	  1792 "000 0000 1000"
	  1856 "000 0000 1100"
	  1920 "000 0000 1101"
	  1984 "0000 0001 0010"
	  2048 "0000 0001 0011"
	  2112 "0000 0001 0100"
	  2176 "0000 0001 0101"
	  2240 "0000 0001 0110"
	  2304 "0000 0001 0111"
	  2368 "0000 0001 1100"
	  2432 "0000 0001 1101"
	  2496 "0000 0001 1110"
	  2560 "0000 0001 1111"
	  ))

(defvar 1*white-table*0 (make-array 128 :fill-pointer 0 :initial-element 0))
(defvar 1*black-table*0 (make-array 128 :fill-pointer 0 :initial-element 0))

(defun 1init-ccitt3-tables0 ()
  (fill-ccitt3-table *white-table*
		     *white-termination-codes*
		     *white-make-up-codes*
		     *additional-make-up-codes*)
  (fill-ccitt3-table *black-table*
		     *black-termination-codes*
		     *black-make-up-codes*
		     *additional-make-up-codes*))

(defun 1fill-ccitt3-table0 (table termination-codes make-up-codes additional-make-up-codes)
  (setf (fill-pointer table) 1)
  (setf (aref table 0) 0)
  (fill-ccitt3-table-1 table T termination-codes)
  (fill-ccitt3-table-1 table nil make-up-codes)
  (fill-ccitt3-table-1 table nil additional-make-up-codes))

(defmacro 1do-bits-in-ccitt3-code0 ((this-bit last-bit? bits) &body body)
  `(do-bits-in-ccitt3-code-1
     ,bits
     (sys:named-lambda do-bits-in-ccitt3-code (,this-bit ,last-bit?) ,@body)))

(defun 1do-bits-in-ccitt3-code-10 (bits continuation)
  (declare (sys:downward-funarg continuation))
  (stack-let ((decoded-bits (make-array 20 :element-type 'bit :fill-pointer 0)))
    (domap () ((bit bits))
      (ecase bit
	((#\0) (vector-push-extend 0 decoded-bits))
	((#\1) (vector-push-extend 1 decoded-bits))
	((#\Space) )))
    (let ((last (1- (length decoded-bits))))
      (dotimes (i (1+ last))
      (funcall continuation (aref decoded-bits i) (= i last))))))
;; (do-bits-in-ccitt3-code (this last? "0000 0001 1101") (print (list this last?)))

(defsubst 1next-following-zero0 (n)        (sys:%logldb (byte 14 0) n))
(defsubst 1end-following-zero0 (n)         (sys:%logldb (byte 1 14) n))
(defsubst 1termination-following-zero0 (n) (sys:%logldb (byte 1 15) n))
(defsubst 1next-following-one0 (n)         (sys:%logldb (byte 14 16) n))
(defsubst 1end-following-one0 (n)          (sys:%logldb (byte 1 30) n))
(defsubst 1termination-following-one0 (n)  (sys:%logldb (byte 1 31) n))

(defparameter 1*ccitt3-eol-encoding*0 (let ((x 0))
				      (setf (next-following-zero x) -1)
				      x))

#+Franz
(defun describe-ccitt3-entry (n &optional leadin)
  (if leadin
      (write-string leadin)
      (fresh-line))
  (format T "following 1: ~3d[~a~a];  following 0: ~3d[~a~a]~%"
	  (next-following-one n)
	  (if (zerop (end-following-one n)) " " "E")
	  (if (zerop (termination-following-one n)) " " "T")
	  (next-following-zero n)
	  (if (zerop (end-following-zero n)) " " "E")
	  (if (zerop (termination-following-zero n)) " " "T")))
#+Franz
(defun describe-ccitt3-table (table)
  (dotimes (i (length table))
    (format T "~&~3d" i)
    (describe-ccitt3-entry (aref table i) "  ")))

(defun 1fill-ccitt3-table-10 (table termination? codes)
  (loop for (run-length bits) on codes by #'cddr do
    (let ((index 0))
      (macrolet ((when-debugging (&rest stuff)
		   (prog1 () stuff)
		   #+Franz
		   `(progn ,@stuff)))
	(when-debugging
	  (format T "~&Inserting ~d with termination ~s, bits ~s"
		  run-length termination? bits))
	(do-bits-in-ccitt3-code (this-bit last-bit? bits)
	  (assert (< index (length table)))
	  (let ((n (aref table index)))
	    (when-debugging
	      (format T "~&This bit ~d~a, index ~d, word:"
		      this-bit
		      (if last-bit? "[L]" "")
		      index)
	      (describe-ccitt3-entry n "  "))
	    (macrolet ((doit (next- end- termination-)
			 `(let ((next (,next- n)))
			    (assert (zerop (,end- n)))
			    (assert (zerop (,termination- n)))
			    (cond (last-bit?
				   (assert (zerop next))
				   (setf (,next- n)
					 (etypecase run-length
					   (integer run-length)
					   ((member EOL) *ccitt3-eol-encoding*)))
				   (setf (,end- n) 1)
				   (when termination? (setf (,termination- n) 1)))
				  (T
				   (when (zerop next)
				     (setq next (fill-pointer table))
				     (when-debugging
				       (format T "~&  Allocating ~d" next))
				     (setf (fill-pointer table) (1+ next))
				     (setf (aref table next) 0)
				     (setf (,next- n) next))
				   (assert (> next index))))
			    (setf (aref table index) n)
			    (setq index next))))
	      (if (zerop this-bit)
		  (doit next-following-zero end-following-zero termination-following-zero)
		  (doit next-following-one end-following-one termination-following-one))
	      (when-debugging
		(format T "~%  n now ~d:" n)
		(describe-ccitt3-entry n "  ")
		))))))))

(2 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB")(init-ccitt3-tables)
0
(defun 1lookup-ccitt3-string0 (array start-index table)
  (declare (values run-length termination? next-array-index))
  (let ((table-index 0)
	(array-index start-index))
    (flet ((error-next (next)
	     (let ((run (map 'string #'digit-char
			     (subseq array start-index array-index))))
	       (if (zerop next)
		   (error "Failed to find run ~s" run)
		   (error "Internal error: following link backwards, for run ~s" run)))))
      (let ((table table) (array array))
	(declare (sys:array-register table array))
	(loop
	  (let ((n (aref table table-index))
		(bit (aref array array-index)))
	    (incf array-index)
	    (if (zerop bit)
		(let ((next (next-following-zero n)))
		  (cond ((zerop (end-following-zero n))
			 (unless (> next table-index)
			   (error-next next))
			 (setq table-index next))
			(T
			 (return-from lookup-ccitt3-string
			   (values (if (eql next *ccitt3-eol-encoding*) 'EOL next)
				   (not (zerop (termination-following-zero n)))
				   array-index)))))
		(let ((next (next-following-one n)))
		  (cond ((zerop (end-following-one n))
			 (unless (> next table-index)
			   (error-next next))
			 (setq table-index next))
			(T
			 (return-from lookup-ccitt3-string
			   (values (if (eql next *ccitt3-eol-encoding*) 'EOL next)
				   (not (zerop (termination-following-one n)))
				   array-index))))))))))))

#+Franz
(defun test-lookup (&optional show-errors)
  (loop for string = (accept 'string) do
    (let ((bits (map '(vector bit)
		     (lambda (ch) (digit-char-p ch 2))
		     (remove #\space string))))
      (flet ((doit (color table)
	       (condition-case-if (not show-errors) (err)
		    (multiple-value-bind (run termination? next)
			(lookup-ccitt3-string bits 0 table)
		      (format T "~&~a run ~d ~s next ~d"
			      color
			      run termination? next))
		  (error 
		    (format T "~&~a: ~a" color err)))))
	(doit "White" *white-table*)
	(doit "Black" *black-table*)))))

(defun 1decode-ccitt3-runs0 (image-array image-width image-length
			   strip-buffer strip-top-row rows-per-strip)
  (macrolet ((when-debugging (&rest stuff)
	       (prog1 () stuff)
	       #+Franz
	       `(progn ,@stuff)))
    (multiple-value-bind (ignore ignore image-array-spanning-width)
	(decode-raster-array image-array)
      (stack-let ((image1 (make-array (* image-length image-array-spanning-width)
				      :element-type 'bit
				      :displaced-to image-array))
		  (strip-vector (make-array (* 8 (length strip-buffer))
					    :element-type 'bit
					    :displaced-to strip-buffer)))
	(declare (sys:array-register image1))
	;;--- Maybe this should depend on bit-fill-order
	(sys:with-bit-reversing
	  (let ((strip-buffer strip-buffer))
	    (declare (sys:array-register strip-buffer))
	    (dotimes (j (length strip-buffer))
	      (setf (aref strip-buffer j) (sys:bit-reverse-8 (aref strip-buffer j))))))
	(let ((strip-bit-number 0))
	  (dotimes (j rows-per-strip)
	    (let ((row (+ j strip-top-row)))
	      (when ( row image-length) (return))
	      (tv:note-progress row image-length)
	      (let* ((image-bit-number (* row image-array-spanning-width))
		     (last-image-bit-number (+ image-bit-number image-width)))
		(let ((color :white))
		  (when-debugging (format T "~&Row ~d" row))
		  (loop named runs do
		    (multiple-value-bind (color-table next-color)
			(ecase color
			  (:white (values *white-table* :black))
			  (:black (values *black-table* :white)))
		      (when-debugging
			(format T "~&  run of ~s" color))
		      (loop named codes-in-run do
			(multiple-value-bind (run-length termination? next-strip-index)
			    (lookup-ccitt3-string strip-vector strip-bit-number color-table)
			  (when (eql run-length 'eol)
			    (when-debugging (format T "~&  EOL"))
			    (return-from runs))
			  (let ((color-code (ecase color (:white 0) (:black 1))))
			    ;;---A bitblt-like hack (with byte/word operations) could
			    ;; speed this.  See cli::decode-bit-vector.
			    (loop for j from image-bit-number below (+ image-bit-number run-length)
				  do
			      (setf (aref image1 j) color-code)))
			  (setq strip-bit-number next-strip-index)
			  (incf image-bit-number run-length)
			  (when termination?
			    (when-debugging (format T "~&    Termination of codes in run"))
			    (return-from codes-in-run))))
		      (when ( image-bit-number last-image-bit-number)
			(when-debugging (format T "~&--End of row, at bit ~d of ~d"
						image-bit-number last-image-bit-number))
			(return-from runs))
		      (when-debugging (format T "~&Next run"))
		      (setq color next-color)))))
	      (setq strip-bit-number (ceiling-multiple-of strip-bit-number 8)))))))))
