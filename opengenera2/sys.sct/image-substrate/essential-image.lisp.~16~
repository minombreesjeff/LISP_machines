;;; -*- Mode: LISP; Syntax: Zetalisp; Package: COLOR; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; This is the minimal subset of the image storage format necessary to be compatible
;;; so that Image Substrate works by itself and when all of Images is loaded.


(defvar *non-garbage-images* (cl:make-hash-table :test #'eq))
(defvar *named-images* (cl:make-hash-table :test #'string-equal))
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")    ;those which are in the image database, or have bit arrays

0(defvar *interesting-properties*
	'(:artist :author :binary-map
	  :credits :comment :copyright :creation-parameters
	  :date :frame-properties :interesting-properties :owner
	  :pixel-aspect-ratio :title
	  :icon-source-frame
	  :x-resolution :y-resolution
	  :x-position :y-position
	  )
  "properties to be saved with the image")
(defvar *frame-properties* '(:description :field-description))
(defvar *derived-image-properties* '(:1b-image :2b-image :8b-image :rgb-image :32b-image
					       :packed-rgb-image :packed-yuv-image
					       :image-icon
					       :2b-peano-image :2b-palette-image
					       :4b-peano-image :4b-palette-image
					       :8b-peano-image :8b-palette-image))

;;internals in loader
(defvar *dont-load-image-binary* nil)
(defvar *make-image-load-image-icons* nil)

;;
;; returns an area number to cons image arrays into
;;
(defun image-bit-array-area ()
  (if (boundp 'tv:*default-bit-array-area*)
      (symeval 'tv:*default-bit-array-area*)
      default-cons-area))

(defgeneric image-width-multiplier (image-type)
  (:function
    (if (instancep image-type)
	(funcall (flavor:generic image-width-multiplier) image-type)
	(selectq image-type
	  (packed-rgb-image 3)
	  (packed-yuv-image 2)
	  (t 1)))))

;;
;; Create an image object
;;
(defun make-image (flavor &rest args)
  (lexpr-funcall 'make-instance flavor
    :dont-load-binary (cl:getf (cdr args) :dont-load-binary *dont-load-image-binary*)
    :load-image-icons (cl:getf (cdr args) :load-image-icon *make-image-load-image-icons*)
    args))

(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")tv:bit-array-list-as-bit-array0 (raster-list direction continuation
				    &rest args
				    &key width height
				    (dx 0)(dy 0)
				    &allow-other-keys)
			    
  (with-stack-list (dims height width)
  (tv:with-temp-sheet-raster
    (to-raster dims :type 'art-fixnum)
    (when (memq direction '(:input :both))
      (color:zoom-rectangle
	:from-array raster-list
	:to-array to-raster
	:from-left dx
	:from-top dy
	:from-right (+ dx width)
	:from-bottom (+ dy height)
	:to-left 0
	:to-top 0
	:to-right width
	:to-bottom height))
    (funcall continuation to-raster 0 width)
    (when (memq direction '(:output :both))
      (color:zoom-rectangle
	:to-array raster-list
	:from-array to-raster
	:to-left dx
	:to-top dy
	:to-right (+ dx width)
	:to-bottom (+ dy height)
	:from-left 0
	:from-top 0
	:from-right width
	:from-bottom height))    
    )))

;;
;; Returns three values; the image flavor, the "create" message, and the "anonymous create"
;;
(defun useful-bits-per-pixel (sheet-or-raster)
  (cond ((fixp sheet-or-raster)
	 sheet-or-raster)
	((or (typep sheet-or-raster 'tv:sheet)
	     (arrayp sheet-or-raster))
	 (tv:with-prepared-sheet-or-raster
	   (sheet-or-raster :bits-per-pixel bits-per-pixel :screen scr)
	   (if scr
	       (send scr :useful-bits-per-pixel)
	       bits-per-pixel)))
	((instancep sheet-or-raster)
	 (send sheet-or-raster :useful-bits-per-pixel))))

(defvar *image-types* '(b&w-image 2b-image 4b-image
			2b-palette-image 2b-random-image
			4b-palette-image 4b-random-image
			false-color-image 8b-palette-image 8b-random-image
			rgb-image packed-rgb-image packed-yuv-image 32b-image))

(define-presentation-type image-type ()
   :abbreviation-for '(alist-member :alist
				    (("1b" :value b&w-image
				      :documentation "a 1 bit per pixel (b&w) image")
				     ("2b" :value 2b-image
				      :documentation "a 2 bits per pixel image")
				     ("4b" :value 4b-image
				      :documentation "a 4 bits-per-pixel image")
				     ("8b" :value false-color-image
				      :documentation "an 8 bit per pixel image")
				     ("rgb" :value rgb-image
				      :documentation "a 24 bit per pixel image, in RGB format")
				     ("packed rgb" :value packed-rgb-image
				      :documentation "A 24 bit per pixel image, in Packed-RGB (Abekas) format")
				     ("rgba" :value 32b-image
				      :documentation "a 32 bits per pixel image"))
				    ))

(defvar *unpublished-image-types* `(32b-no-alpha-image ,*image-types*))

(defun default-image-type (sheet-or-raster &optional (for-save))
  (cond ((listp sheet-or-raster)
	 (values 'rgb-image :create-rgb-image :rgb-image))
	((or (arrayp sheet-or-raster)
	     (typep sheet-or-raster 'tv:sheet)
	     (fixp sheet-or-raster))
	 (selector (useful-bits-per-pixel sheet-or-raster)
		   =
	   (1 (values 'b&w-image :create-1b-image :1b-image))
	   (2 (values '2b-image :create-2b-image :2b-image))
	   (4 (values '4b-image :create-4b-image :4b-image))
	   (8 (values 'false-color-image :create-8b-image :8b-image))
	   (24 (if for-save
		   (values 'rgb-image :create-rgb-image :rgb-image)
		   (values '32b-image :create-32b-image :32b-image)))
	   (t (values '32b-image :create-32b-image :32b-image))))
	((instancep sheet-or-raster)
	 (multiple-value-bind (create anon)
	     (send sheet-or-raster :create-me-message)
	   (values (typep sheet-or-raster) create anon)))
	(t (ferror "~A doesn't seem to specify an image" sheet-or-raster))))


(defun transfer-image-type (sheet-or-raster &optional map)
  (let ((def (default-image-type sheet-or-raster)))
    (selectq def
      (2b-image
       (selectq (transfer-map-type map)
	 (:grayscale (values (if (eq (canonical-color-map
				       (or map *standard-2b-grayscale-map*))
				     *standard-2b-grayscale-map*)
				 '2b-image
				 '2b-palette-image)
			     map))
	 (:palette (values '2b-palette-image map))
	 (:random (values '2b-random-image map)))
       )
      (4b-image
       (selectq (transfer-map-type map)
	 (:grayscale (values (if (eq (canonical-color-map
				       (or map *standard-4b-grayscale-map*))
				     *standard-4b-grayscale-map*)
				 '4b-image
				 '4b-palette-image)
			     map))
	 (:palette (values '4b-palette-image map))
	 (:random (values '4b-random-image map)))
       )
      (false-color-image
       (selectq (transfer-map-type map)
	 (:grayscale  (values (if (eq (canonical-color-map
					(or map *standard-grayscale-map*))
				      *standard-grayscale-map* )
				  'false-color-image
				  '8b-palette-image)
			      map))
	 (:palette (values '8b-palette-image map))
	 (:random (values '8b-random-image map)))
       )
      (t (values def map)))))

(defun data-array-type (image-type)
  (selectq image-type
    (b&w-image 'art-1b)
    ((2b-image 2b-palette-image 2b-random-image) 'art-2b)
    ((4b-image 4b-palette-image 4b-random-image) 'art-4b)
    ((false-color-image 8b-random-image 8b-palette-image rgb-image
			packed-rgb-image
			packed-yuv-image)
     'art-8b)
    ((32b-image 32b-no-alpha-image) 'art-fixnum)
    (t (cond ((and (fixp image-type)
		   (car (rassoc image-type array-bits-per-element))))
	     (t (ferror "~S isn't a known image type" image-type))))))

(defflavor essential-image-methods
	((name) (source-file) (file-format) (modified) (current-frame))
	(si:property-list-mixin) 
  (:settable-instance-variables name source-file file-format modified)
  (:gettable-instance-variables current-frame)
  :initable-instance-variables
  (:init-keywords :binary-info :dont-load-binary :setup-color-map :invisible-to-database)
  (:default-init-plist :allow-other-keys t)
  (:method-combination :IMAGE-DUMP-FORM (:NCONC :MOST-SPECIFIC-LAST)
                       :BINARY-DUMP-FORM (:NCONC :MOST-SPECIFIC-LAST)
                       :IMAGE-ARRAYS (:NCONC :MOST-SPECIFIC-LAST)
                       :CREATE-BIT-ARRAYS (:NCONC :MOST-SPECIFIC-LAST)
                       :CREATE-DISPLACED-BIT-ARRAYS (:NCONC :MOST-SPECIFIC-LAST)
                       :CREATE-INIT-PLIST (:NCONC :MOST-SPECIFIC-LAST))
  )

(defun image-p (object) (typep object 'essential-image-methods))

(defmethod (:4b-color-map essential-image-methods) ()
  (let ((map (send self :setup-color-map)))
    (if (and map (eql (send map :size) 16))
	map
	(cl:case (transfer-map-type map)
	  (:grayscale *standard-4b-grayscale-map*)
	  (t (copy-color-map map :size 16))))))
  
(defmethod (:8b-color-map essential-image-methods) ()
  (let ((map (send self :setup-color-map)))
    (if (and map (eql (send map :size) 256))
	map
	(cl:case (transfer-map-type map)
	  (:grayscale *standard-grayscale-map*)
	  (t (copy-color-map map :size 256))))))

(defmethod (:useful-bits-per-pixel essential-image-methods) ()
  (or (cdr (assoc (send self :data-array-type) array-bits-per-element))
      32.))
    

(defmethod (:compatible-pixel-depth essential-image-methods) (with)
  (ignore with)
  (let ((my-depth (send self :useful-bits-per-pixel)))
    (or (eql my-depth 1)
	(eql my-depth with)
	(and (eql my-depth 24.)
	     (eql with 32.))
	)))

(defmethod (image-width-multiplier essential-image-methods) () 1)


(defmethod (:init essential-image-methods :after) (plist)
  
  (or source-file (setq source-file fdefine-file-pathname))

  (let ((typ (get plist :binary-file-type)))
    (when typ (send self :putprop typ :binary-file-type)))

  (when (stringp source-file)
    (setq source-file (fs:parse-pathname source-file)))

  (let ((sp (or (get plist :setup-color-map)
		(let ((st (get plist :standard-color-map)))
		  (when st
		    (or (standard-map-with-name st)
			(canonical-color-map (make-standard-color-map :initial-data st)))))
		)))
    (when sp (send self :set-setup-color-map sp)))
  
  (let ((local-interest (get plist :interesting-properties))
	(global-interest *interesting-properties*))
    
    (labels ((store-property-list (plist &optional all-local)
	       (loop for (prop val) on plist by #'cddr
		     do
		 (cond ((memq prop '(:properties :local-properties))
			(store-property-list val t))
		       ((or (memq prop global-interest)
			    (memq prop local-interest))
			(send self :putprop val prop))
		       (all-local
			(push prop local-interest)
			(send self :putprop val prop)))
		 )))
      (store-property-list (car plist))
      )
    (when local-interest
      (send self :putprop local-interest :interesting-properties)))
  
  (when (and (typep source-file 'fs:pathname)
	     (not (send source-file :name))
	     name)
    (setq source-file (send source-file :new-pathname
			    :name (string name))))
  
  (unless (send self :get :date)
    (send self :putprop
	  (with-output-to-string (i)
	    (prog ((standard-output i))
		  (time:print-current-time)))
	  :date))
  
  (unless (send self :get :author)
    (send self :putprop
	  user-id
	  :author))

  (let* ((bm (send self :get :binary-map))
	 (binary-info (get plist :binary-info))
	 (no-dump-file (or (null source-file)
			   (and (null binary-info)
				(null bm))))
	 (dont-load-binary  (or no-dump-file
				(get plist :dont-load-binary)))

	 (load-image-icons (and (get plist :load-image-icons)
				(neq (send self :get :binary-file-type) :image-icon)))
	 )

    (loop for (prop-name prop-val) on bm by #'cddr	
	do
    (send self :set-variable prop-name
	  (if  (nlistp prop-val) prop-val nil)))


    (when dont-load-binary
      (multiple-value-bind (wid hei) (send self :size)
	(unless (and wid hei)
1	  ;take our size from the size of the bit arrays
0	  (loop with min-w and min-h
		for arr in (when (send self :bit-arrays-valid-p)
			     (send self :binary-arrays))
		do
	    (multiple-value-bind (w h) (decode-raster-array arr)
	      (setq min-w (min w (or min-w w))
		    min-h (min h (or min-h h))))
		finally (when min-w
			  (unless wid
			    (send self :set-width
				  (// min-w
				      (image-width-multiplier
					(send self :transfer-image-type-spec))))))
			(when min-h (unless hei (send self :set-height min-h))))
	  )))

    (when (and (not no-dump-file)
	       (or (null dont-load-binary)))
      1;load the binary files and scan for icons if requested
0      (send self ':load-binary-file
	    :file source-file
	    :force-reload t
	    ))

    (when (and load-image-icons
	       (not (send self :menu-icon :create-p nil :load-file nil)))
      (send self :menu-icon :create-p t :load-file t
	    :rescale (or (send self :get :rescale-icon) :select)))

    (let ((inv (get plist :invisible-to-database)))
      (when inv (send self :putprop t :invisible-to-database)))
    (send self :set-name name)))

(defmethod (:full-color-p essential-image-methods) () nil)

(defmethod (:binary-arrays essential-image-methods)
	   (&key (frame current-frame))
  (loop for (nil dat) on (if frame
			     (cdr (send self :frame-plist frame))
			     ;--- Is this right?
			     (send self :image-arrays))
		 by #'cddr
	    when (and (arrayp dat)
		      (= (array-#-dims dat) 2))
	      collect dat))

(defmethod (:component-valid-for-frame essential-image-methods) (frame component)
  (unless (listp frame)(setq frame (send self :frame-plist frame)))
  (and frame
       (if (memq component (send self :rle-component-names))
	   (or (get frame :data-array)
	       (get frame component))
	   (get frame component))))

(defmethod (:bit-arrays-valid-for-frame essential-image-methods) (frame)
  (if (eq frame current-frame)
      (send self :bit-arrays-valid-p)
      (let ((pl (if (listp frame) frame (send self :frame-plist frame))))
	(loop for i in (send self :image-array-names)
	      always (arrayp (get pl i))))))

(defmethod (:set-variable essential-image-methods) (name to)
  (let ((method (intern (string-append "SET-" name) ':keyword)))
    (if (operation-handled-p self method)
	(send self method to)
	(send self :putprop to name))))

(defmethod (:current-frame-properties essential-image-methods) ()
  (let ((fp (send self :get :frame-properties)))
    (loop for (prop val) on flavor:property-list by #'cddr
	  when (or (memq prop *frame-properties*)
		   (memq prop fp))
	    collect prop
	    and collect val)))

(defmethod (:current-frame-spec essential-image-methods) ()
  (let* ((bd (send self :binary-dump-form))
	 (fprops (send self :current-frame-properties))
	 (w (send self :width))
	 (h (send self :height)))
    (when (or w h fprops)
      `(:width ,w
	:height ,h
	,@fprops
	,@bd))))

(defmethod (:save-current-frame essential-image-methods) ()
  (let* ((cf current-frame)
	 (frames (send self :get :frames))
	 (fr (assoc cf frames))
	 (spec (send self :current-frame-spec)))

    (when spec
      (unless fr
	(setq fr (list cf))
	(if frames
	    (nconc frames (list fr))
	    (send self :putprop (setq frames (list fr)) :frames)))
      (setf (cdr fr) spec)
      (loop for (prop nil) on spec by #'cddr
	    do (send self :set-variable prop nil)))
    ))

(defmethod (:restore-current-frame essential-image-methods) ()
  (let* ((cf current-frame)
	 (frames (send self :get :frames))
	 (fr (assoc cf frames))
	 )

    (unless fr
      (setq fr (list cf))
      (if frames
	  (nconc frames (list fr))
	  (send self :putprop (setq frames (list fr)) :frames)))

    (loop for (prop val) on (cdr fr) by #'cddr
	  do (send self :set-variable prop val)
	     )
    (setf (cdr fr) nil)))


(defmethod (:frame-plist essential-image-methods) (frame)
  (let ((cf current-frame))
    (if (eq frame cf)
	`(,cf ,@(send self :current-frame-spec))
	(assoc frame (send self :frame-plists)))))

(defmethod (:frame-property essential-image-methods) (property &optional (frame current-frame))
  (if (eq frame current-frame)
      (send self property)
      (getf (cdr (assoc frame (send self :frame-plists))) property)))

(defmethod (:frame-plists essential-image-methods) ()
  (let ((cf current-frame)
	(fr (send self :get :frames)))
    (unless fr
      (send self :putprop (setq fr (list (list cf))) :frames))
    (loop for frame in fr
	  collect
	  (if (eql (first frame) cf)
	      (cons cf (send self :current-frame-spec))
	      frame))))

(defmethod (:set-current-frame essential-image-methods) (id &optional error-p)
  (unless (eql id current-frame)
    (when error-p
      (unless (send self :frame-plist id)
	(ferror "Frame ~S is not defined" id)))
    (unless (or (fixp id)
		(and (symbolp id) (neq id t)))
      (ferror "Frames must be identified by an integer or a symbol~A."
	      (if (eq id t) " other than T"  ""))
      )
    (send self :save-current-frame)
    (setq current-frame id)
    (send self :restore-current-frame)))

(defmethod (:delete-frame essential-image-methods) (frame)
  (send self :discard-bit-arrays :frame frame)
  (let ((cf current-frame))
    (if (eq frame t)

	(progn
	  (send self :save-current-frame)
	  (send self :putprop (list nil) :frames)
	  (send self :set-current-frame nil)
	  )

	(when (eq frame cf)
	  (send self :set-current-frame (setq cf nil)))

	(when (eql cf frame) (send self :save-current-frame))
	(send self :putprop
	      (delete (assoc frame (send self :get :frames))
		      (send self :get :frames))
	      :frames)
	(when (eql cf frame) (send self :restore-current-frame))
	)))

(defmethod (:image-valid-p essential-image-methods) (&optional or-on-file)
  (and (send self :width)
       (send self :height)
       (or (send self :bit-arrays-valid-p)
	   (when or-on-file source-file)
	   )))

(defmethod (garbage-image-p essential-image-methods) ()
  (let ((names (gethash name *named-images*)))
    (cond ((eq self names) nil) ;named
	  ((and (listp names)(memq self names)) nil)
	  (t (image-has-no-bit-arrays self)))))

(defmethod (image-has-no-bit-arrays essential-image-methods) ()
  (cond ((send self :bit-arrays-valid-p) nil)         ;has bit arrays
	((loop with frames = (send self :get :frames)
	       and image-array-names = (send self :image-array-names)
	       for frame in frames do
	   (loop for n in image-array-names
		 as a = (get frame n)
		 thereis (arrayp a))) nil)           ;bit arrays somewhere
	(t (remhash self *non-garbage-images*)
	   t)))

(defmethod (:set-name essential-image-methods :after) (ignore)
  (unless (send self :get :invisible-to-database)
    (send self :remember-in-database))
  (garbage-image-p self))

(defmethod (named-image-p essential-image-methods) ()
  (let ((images (gethash name *named-images*)))
    (cond ((eq self images))
	  ((nlistp images) nil)
	  ((memq self images) t))))

(defmethod (:fasd-form essential-image-methods) ()
  (let* ((frames (cl:remove-if #'(lambda (a)(eql (car a) current-frame))
			       (send self :frame-plists)))
	 (plist (send self :create-init-plist :exclude-properties '(:binary-map)))
	 )

  `(make-image ',(typep self)
	       ,@plist
	       ,@(when frames
		   `(,:frames ',frames)))
  ))

(defmethod (:create-init-plist essential-image-methods)
	   (&rest keywords &key exclude-properties &allow-other-keys)
  (declare (arglist (&key exclude-properties include-properties)))
  `(,@(unless (memq :name exclude-properties)

	`(:name ',name))
    ,@(unless (memq :file-format exclude-properties)
	`(:file-format ',file-format))
    ,@(lexpr-send self ':*interesting-properties* keywords)))

(defmethod (:*interesting-properties* essential-image-methods)
	   (&key exclude-properties include-properties)
  (let ((props (loop with local-interest = (send self :get :interesting-properties)
		     and global-interest = *interesting-properties*
		     for pname in (send self ':plist)
		     as pval in (cdr (send self ':plist))
		     when (and (or (memq pname local-interest)
				   (memq pname global-interest)
				   (memq pname include-properties)
				   )
			       (not (member pname exclude-properties)))
		     nconc `(,pname ,pval))))
    (when props `(:properties ',props))))


(defflavor essential-image ((width nil)
			    (height nil)
			    )
	   (essential-image-methods)
  (:initable-instance-variables width height)
  #+ignore	;Not possible in this loading sequence.
  (:required-methods
   :transfer-scaled-image
   :data-array-type
   :create-me-message
   :compatible-pixel-depth
   :create-bit-arrays   :create-displaced-bit-arrays
   :discard-bit-arrays :bit-arrays-valid-p
   :copy-image-to-window
   :copy-image-from-window)
  (:default-init-plist :name "unnamed"))

(defmethod (:width essential-image) (&optional (frame current-frame))
  (if (eq frame current-frame)
      width
      (send self :frame-property :width frame)))

(defmethod (:height essential-image) (&optional (frame current-frame))
  (if (eq frame current-frame)
      height
      (send self :frame-property :height frame)))

(defmethod (:set-width essential-image) (new) (setq width new))

(defmethod (:set-height essential-image) (new) (setq height new))

(defmethod (:set-name essential-image :before) (newname)
  (when (and (neq name newname)
	     (or (and name (symbolp name))
		 (stringp name)))
    (let ((removed))
      (scl:modify-hash *named-images*
		       name
		       #'(lambda (ignore val present)
			   (cond ((null present)(setq removed t)(values))
				 ((eq val self)
				  (setq removed t)
				  (values))
				 ((nlistp val) val)
				 ((memq self val)
				  (let ((new (delete self val 1)))
				    (if new new (setq removed t)(values)))))))
      (when removed (remhash name *named-images*))
      ;(multiple-value-bind (n a) (gethash name *named-images*)
      ;(when (and (null n) a) (ferror "null name")))
    )))

(defmethod (:remember-in-database essential-image) ()
  (when (or (and name (symbolp name))
	    (stringp name))
    (unless (send self :get :invisible-to-database)
      (puthash self self *non-garbage-images*)
      (scl:modify-hash *named-images* name
		       #'(lambda (ignore val ignore)
			   (cond ((null val) self)
				 ((eq val self) self)
				 ((nlistp val)
				  (if (image-has-no-bit-arrays val)
				      self
				      (list self val)))
				 ((memq self val) val)
				 (t (cons self
					  (cl:remove-if
						 #'(lambda (a)(image-has-no-bit-arrays a))
						 val)))))))))

(defmethod (:set-size essential-image-methods) (width height)
  (send self :set-width width )
  (send self :set-height height))

(defmethod (:size essential-image) (&optional (frame current-frame))
  (values (send self :width frame)(send self :height frame)))

(defmethod (:edges essential-image) (&optional (frame current-frame))
  (values 0 0 (send self :width frame) (send self :height frame)))

(defmethod (:inside-width essential-image) (&optional (frame current-frame))
  (send self :width frame))
(defmethod (:inside-height essential-image) (&optional (frame current-frame))
  (send self :height frame))
(defmethod (:inside-size essential-image) (&optional (frame current-frame))
  (send self :size frame))
(defmethod (:inside-edges essential-image) (&optional (frame current-frame))
  (send self :edges frame))

(defmethod (:print-self essential-image)
	   (stream ignore slashify)
  
  (let* ((on-file (cond ((send self :get :killed)
			 " (killed)")
			((and (not (send self :bit-arrays-valid-p))
			      (send self :source-file))
			 " (on file)")
			((not (send self :image-valid-p))
			 " (invalid)")
			(t "")))
	 (images (gethash (send self :name) *named-images*))
	 (nth (cond ((eq self images) 1)
		    ((nlistp images) nil)
		    ((loop for idx from 1
			   as im in images
			   when (eq im self) return idx))
		    ))
	 (registration (cond ((null nth)
			      (if (gethash self *non-garbage-images*)
				  "temporary "
				  "unregistered "))
			     (t "")))
	 )
    (if slashify
	(printing-random-object (self stream :no-pointer)
	  (send self :print-name-to-stream stream :prefix registration
		:suffix on-file)
	  (let ((frames (send self :get :frames)))
	    (when (or (cdr frames)
		      (caar frames))
	      (format stream " Frame ~A among ~A"
		      current-frame
		      (length frames)))
	    ))
	(format stream "~A~A" name on-file))))

(defmethod (:print-name-to-stream essential-image)
	   (stream &key prefix suffix (print-type (typep self)))
  (let* ((images (gethash (send self :name) *named-images*))
	 (nth (cond ((eq self images) 1)
		    ((nlistp images) nil)
		    ((loop for idx from 1
			   as im in images
			   when (eq im self) return idx))
		    )))
    (format stream "~A~A~A~A~A~D~A"
	    (or prefix "")
	    (or print-type  "")
	    (if print-type " " "")
	    name				
	    (if (or (null nth)(eql nth 1)) "" " -")
	    (if (or (null nth)(eql nth 1)) "" nth)
	    (or suffix "")
	    )))

(defmethod (:defined-frames essential-image-methods) ()
  (loop for (i) in (send self :get :frames)
	collect i))

(defmethod (:map-over-frames essential-image-methods) (frames continuation)
  (let* ((cf current-frame))
    (with-stack-list (fl frames)
      (unwind-protect
	  (loop for ii in (cond ((eq frames t) (send self :get :frames))
				 ((listp frames) frames)
				 (t fl))
		as i = (if (eq frames t) (first ii) ii)
		do (send self :set-current-frame i)
		   (funcall continuation))
	(send self :set-current-frame cf)))
    ))

(defmethod (:create-init-plist essential-image :nconc)
	   (&key exclude-properties include-properties)
  (ignore include-properties)
  `(,@(unless (memq :width exclude-properties)
	`(:width ,width))
    ,@(unless (memq :height exclude-properties)
	`(:height ,height))))


(defmethod (:transfer-image-type-spec essential-image-methods) (&optional map)
  (ignore map)
  (zl:typep self))

(defmacro-in-flavor (with-bit-arrays essential-image-methods)
		    ((&key (disposition :unchanged)) &body body)
  `(let* ((cf current-frame)
	  (binary-not-loaded (not (send self :bit-arrays-valid-p))))
     (unwind-protect
	 (progn (when binary-not-loaded
		  (send self :load-binary-file :frame cf))
		(unless (send self :bit-arrays-valid-p)
		  (ferror "Image ~A bit arrays not available" self))
		,@body)
       (when (or (eq ,disposition :unloaded)
		 (and binary-not-loaded (eq ,disposition :loaded)))
	 (send self :discard-bit-arrays :frame cf)))))

(defmethod (:with-bit-array essential-image-methods)
	   (direction continuation 
		      &key (frame current-frame)
		      (x-offset 0)
		      (y-offset 0)
		      &allow-other-keys)
  (send self :with-single-bit-array
	#'(lambda (ar)
	    (multiple-value-bind (nil nil span)
		(decode-raster-array (if (listp ar) (first ar) ar))
	      (funcall continuation ar (+ x-offset (* y-offset span)) span)))
	:frame frame
	:disposition (if (eq direction :input) :no-change :loaded)
	))

(defmethod (2can-i-make-the-right-output-stream0 essential-image-methods) nil)
(defmethod (2can-i-make-the-right-bidirectional-stream0 essential-image-methods) nil)
(defmethod (2can-i-make-the-right-input-stream0 essential-image-methods)
	   (&key frame &allow-other-keys)
  ;default answer, yes if no bit arrays, no if bit arrays
  (not (send self :bit-arrays-valid-for-frame frame)))

(defmethod (2:with-bit-array-stream0 essential-image-methods)	
	   (direction continuation
		      &rest args
		      &key
		      (frame current-frame)
		      (x-offset 0)
		      (y-offset 0)
		      &allow-other-keys)	
  (if (cl:apply (cond ((eq direction :input) #'can-i-make-the-right-input-stream)
		      ((eq direction :output)#'can-i-make-the-right-output-stream)
		      (t #'can-i-make-the-right-bidirectional-stream))
		self
		args)

      (si:with-rem-keywords (args args '(:x-offset :y-offset :permit-rgb))
	(lexpr-send self :load-binary-file
		    :continuation continuation
		    :frame frame
		    :dx x-offset
		    :dy y-offset
		    args))

      (lexpr-send self :with-bit-array
		  direction
		  #'(lambda (raster index span)
		      (multiple-value-bind (dy dx) (floor index span)
			(cl:apply #'tv:bit-array-as-bit-array-stream
			  raster direction
			  continuation
			  :x-offset dx
			  :y-offset dy
			  :frame frame
			  args)))
		  args)
      ))


(defmethod (2:with-bit-array-or-stream0 essential-image-methods)
	   (direction continuation &rest args &key (frame current-frame) &allow-other-keys)
  (if (send self :bit-arrays-valid-for-frame frame)
      (lexpr-send self :with-bit-array direction continuation args)
      (lexpr-send self :with-bit-array-stream direction continuation args)))

;
; Methods to coerce RGB images into art-fixnum
;
(defmethod (2:with-32b-array0 essential-image-methods)
	   (direction continuation
		      &rest args
		      &key
		      (x-offset 0)
		      (y-offset 0)
		      (width (send self :width))
		      (height (send self :height))
		      &allow-other-keys)
  (if (or (and (eql x-offset 0)
	       (eql y-offset 0)
	       (eql width (send self :width))
	       (eql height (send self :height)))
	  (send self :get :32b-image))

      (let ((im (or (send self :get :32b-image)
		    (if (eq direction :output)
			(send self :32b-image
			      :continuation #'ignore)
			(send self :32b-image)))))
	(lexpr-send im :with-bit-array direction continuation args)
	(when (member direction '(:output :both))
	  (send self :remprop :32b-image)
	  (send self :take-image-from-window im
		:dx x-offset
		:dy y-offset
		:width width
		:height height
		:kill-derived-images t
		:new-bit-arrays nil
		)
	  (send self :putprop im :32b-image)
	  ))

      (lexpr-send self :with-bit-array
		  direction
		  #'(lambda (raster index span)
		      (destructuring-bind (dy dx)(floor index span)
			(cl:apply #'tv:bit-array-list-as-bit-array
				  raster direction continuation
				  :x-offset dx
				  :y-offset dy
				  args)
			  ))
		  :permit-rgb t
		  args)))

(defmethod (2:with-32b-array-stream0 essential-image-methods)
	   (direction continuation
		      &rest args
		      &key
		      (x-offset 0)
		      (y-offset 0)
		      (width (send self :width))
		      (height (send self :height))
		      &allow-other-keys)
  (if (or (and (eql x-offset 0)
	       (eql y-offset 0)
	       (eql width (send self :width))
	       (eql height (send self :height)))
	  (send self :get :32b-image))

      (let ((im (or (send self :get :32b-image)
		    (if (eq direction :output)
			(send self :32b-image
			      :continuation #'ignore)
			(send self :32b-image)))))
	
	(lexpr-send im :with-bit-array-stream
		    direction continuation args)
	(when (member direction '(:output :both))
	  (send self :remprop :32b-image)
	  (send self :take-image-from-window im
		:dx x-offset
		:dy y-offset
		:width width
		:height height
		:kill-derived-images t
		:new-bit-arrays nil
		)
	  (send self :putprop im :32b-image)
	  ))

      (lexpr-send self :with-bit-array
		  direction
		  #'(lambda (raster index span)
		      (multiple-value-bind (dy dx) (floor index span)
			(cl:apply #'tv:bit-array-as-bit-array-stream
				raster index
				continuation
				:x-offset dx
				:y-offset dy
				args)
			  ))
		  :permit-rgb t
		  args)
      ))

(defmethod (2:with-32b-array-or-stream0 essential-image-methods)
	   (direction continuation
		      &rest args
		      &key
		      (x-offset 0)
		      (y-offset 0)
		      (width (send self :width))
		      (height (send self :height))
		      &allow-other-keys)
  (if (or (and (eql x-offset 0)
	       (eql y-offset 0)
	       (eql width (send self :width))
	       (eql height (send self :height)))
	  (send self :get :32b-image))
      (lexpr-send self :with-32b-array direction continuation args)
      (lexpr-send self :with-32b-array-stream direction continuation args)
      ))


(defflavor full-color-image-mixin () ()
  (:required-flavors essential-image-methods)
  )

(defflavor rgb-image-mixin ((red) (green) (blue)) ()
  :initable-instance-variables
  :settable-instance-variables
  (:required-flavors essential-image)
  )

(defwhopper (2:with-bit-array-or-stream0 rgb-image-mixin)
	    (direction continuation &rest args &key permit-rgb &allow-other-keys)
  (if permit-rgb
      (lexpr-continue-whopper direction continuation args)
      (lexpr-send self :with-32b-array-or-stream direction continuation args)
      ))

(defwhopper (2:with-bit-array0 rgb-image-mixin)
	    (direction continuation &rest args &key permit-rgb &allow-other-keys)
  (if permit-rgb
      (lexpr-continue-whopper direction continuation args)
      (lexpr-send self :with-32b-array direction continuation args)
      ))

(defwhopper (2:with-bit-array-stream0 rgb-image-mixin)
	    (direction continuation &rest args &key permit-rgb &allow-other-keys)
  (if permit-rgb
      (lexpr-continue-whopper  direction continuation args)
      (lexpr-send self :with-32b-array-stream direction continuation args)
      ))

(defmethod (:useful-bits-per-pixel rgb-image-mixin) ()
  24.)

(defmethod (:full-color-p rgb-image-mixin) () t)

(defmethod (:data-array-type rgb-image-mixin) ()
  'art-8b)

(defmethod (:image-array-names rgb-image-mixin) ()
  '(:red :green :blue))

(defmethod (:image-arrays rgb-image-mixin :nconc) ()
  `(:red ,red :green ,green :blue ,blue))

(defmethod (:bit-arrays-valid-p rgb-image-mixin) ()
  (when (and red green blue) t))

(defmethod (:binary-dump-form rgb-image-mixin :nconc) ()
  `(:red ,red :green ,green :blue ,blue))

(defmethod (:create-init-plist rgb-image-mixin :nconc)
	   (&key exclude-properties include-properties)
  (ignore include-properties)
  `(,@(unless (memq :red exclude-properties)
	`(:red ,red))
    ,@(unless (memq :green exclude-properties)
	`(:green ,green))
    ,@(unless (memq :blue exclude-properties)
	`(:blue ,blue))))

(defmethod (:with-single-bit-array rgb-image-mixin)
	   (continuation &key (frame current-frame) (disposition :unchanged))
  (declare (sys:downward-funarg continuation))
  (send self :map-over-frames frame
	#'(lambda ()
	    (declare (sys:downward-function))
	    (with-bit-arrays (:disposition disposition)
	      (with-stack-list (rgb red green blue)
		(funcall continuation rgb))))
	))

(defflavor false-color-mixin ((setup-color-map)) ()
  :initable-instance-variables
  :settable-instance-variables
  (:init-keywords :standard-color-map)
  )

(defmethod (:transfer-image-type-spec false-color-mixin) (&optional (map setup-color-map))
  (transfer-image-type self map))

(defmethod (:create-init-plist false-color-mixin :nconc)
	   (&key exclude-properties include-properties)
  (ignore include-properties)
  (unless (memq :setup-color-map exclude-properties)
    (let ((name (when setup-color-map (send setup-color-map :name))))
      (if (and name (eq setup-color-map (standard-map-with-name name)))
	  `(:standard-color-map ',name)
	  `(:setup-color-map ',setup-color-map)))))

(defflavor single-plane-image-mixin ((data-array)) ()
  :initable-instance-variables
  :settable-instance-variables
  (:required-methods :data-array-type)
  (:required-flavors essential-image))

(defmethod (:create-init-plist single-plane-image-mixin :nconc)
	   (&key exclude-properties include-properties)
  (ignore include-properties)
  (unless (memq :data-array exclude-properties)
    `(:data-array ',data-array)))

(defmethod (:image-array-names single-plane-image-mixin) ()
  '(:data-array))

(defmethod (:image-arrays single-plane-image-mixin :nconc) ()
  `(:data-array ,data-array))

(defmethod (:bit-arrays-valid-p single-plane-image-mixin) ()
  (when data-array t))

(defmethod (:binary-dump-form single-plane-image-mixin :nconc) ()
  `(:data-array ,data-array))

(defflavor 1bit-image-mixin () (single-plane-image-mixin)
  (:required-flavors essential-image ))

(defmethod (:with-single-bit-array single-plane-image-mixin)
	   (continuation &key (frame current-frame) (disposition :unchanged))
  (declare (sys:downward-funarg continuation))
  (send self :map-over-frames frame
	#'(lambda ()
	    (declare (sys:downward-function))
	    (with-bit-arrays (:disposition disposition)
	      (funcall continuation data-array)))))

(defmethod (:data-array-type 1bit-image-mixin) ()
  'art-1b)

(defmethod (:1b-image 1bit-image-mixin) ()
  self)

(defflavor 2bit-image-mixin () (false-color-mixin single-plane-image-mixin)
  (:required-flavors essential-image))

(defmethod (:data-array-type 2bit-image-mixin) ()
  'art-2b)

(defmethod (:2b-image 2bit-image-mixin) ()
  self)

(defflavor 4bit-image-mixin () (false-color-mixin single-plane-image-mixin)
  (:required-flavors essential-image))

(defmethod (:data-array-type 4bit-image-mixin) ()
  'art-4b)

(defmethod (:4b-image 4bit-image-mixin) ()
  self)

(defflavor 8bit-image-mixin () (false-color-mixin single-plane-image-mixin)
  (:required-flavors essential-image))

(defmethod (:data-array-type 8bit-image-mixin) ()
  'art-8b)

(defwhopper (:8b-image 8bit-image-mixin) (&optional (palette t))
  (if (and palette (neq setup-color-map *standard-false-color-map*))
      (continue-whopper palette)
      self))

(defflavor 32bit-image-mixin () (single-plane-image-mixin)
  (:required-flavors essential-image))

(defmethod (:data-array-type 32bit-image-mixin) ()
  'art-fixnum)

(defmethod (:32b-image 32bit-image-mixin) ()
  self)

(defmethod (:full-color-p 32bit-image-mixin) () t)

(defflavor packed-rgb-image-mixin () (single-plane-image-mixin)
  (:required-flavors essential-image))

(defmethod (image-width-multiplier packed-rgb-image-mixin) () 3)

(defmethod (:data-array-type packed-rgb-image-mixin) ()
  'art-8b)

(defmethod (:packed-rgb-image packed-rgb-image-mixin) ()
  self)

(defmethod (:full-color-p packed-rgb-image-mixin) () t)

(defflavor packed-yuv-image-mixin () (single-plane-image-mixin)
  (:required-flavors essential-image))


(defmethod (image-width-multiplier packed-yuv-image-mixin) () 2)

(defmethod (:data-array-type packed-yuv-image-mixin) ()
  'art-8b)

(defmethod (:packed-yuv-image packed-yuv-image-mixin) ()
  self)

(defmethod (:full-color-p packed-yuv-image-mixin) () t)


(defflavor rle-mixin () ()
  (:required-flavors essential-image)
  (:init-keywords :rle)
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (3 0 (NIL 0) (NIL :BOLD-EXTENDED NIL) "CPTFONTB")The instantiable flavors
0;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defflavor packed-rgb-image
	()
	(packed-rgb-image-mixin   full-color-image-mixin essential-image rle-mixin))

(defflavor packed-yuv-image
	()
	(packed-yuv-image-mixin  full-color-image-mixin essential-image rle-mixin))

(defflavor 32b-image
	()
	(32bit-image-mixin full-color-image-mixin essential-image rle-mixin))

(defflavor rgb-image
	()
	(rgb-image-mixin  full-color-image-mixin essential-image rle-mixin))

(defflavor 2b-image () (2bit-image-mixin essential-image rle-mixin))

(defflavor false-color-image () (8bit-image-mixin essential-image rle-mixin))

(defflavor 4b-image () (4bit-image-mixin essential-image rle-mixin))

(defflavor b&w-image () (1bit-image-mixin essential-image rle-mixin))

(compile-flavor-methods b&w-image 2b-image 4b-image false-color-image rgb-image 32b-image)
