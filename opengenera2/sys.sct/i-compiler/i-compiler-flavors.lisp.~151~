;;; -*- Mode: Lisp; Package: I-Lisp-Compiler; Lowercase: T; Base: 10; Syntax: Zetalisp -*- 
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Support for the architecture protocol
(defflavor i-architecture-mixin
	()
	(basic-architecture)
  (:abstract-flavor))

(defmethod (get-phase-1-handler i-architecture-mixin) (sym)
  (or (get sym 'phase-1-handler)
      (get sym 'compiler:phase-1-handler)))

(defmethod (get-phase-1-hook i-architecture-mixin) (sym)
  (or (get sym 'phase-1-hook)
      (get sym 'compiler:phase-1-hook)))

(defmethod (get-transformers i-architecture-mixin) (function)
  (append (get function 'transformers)
	  (get function 'compiler:transformers)))

(defmethod (get-optimizers i-architecture-mixin) (function)
  (get function 'optimizers))

;;; The form is a function call.  "function-name" is the symbol that
;;; names the function, and "subforms" are the already-transformed
;;; argument forms.  Note that the function may be a "fexpr"; that is,
;;; it may have "quoted arguments".  If so, the arguments have not been
;;; transformed.  Number-of-arguments checking has already been done,
;;; and the user got warned if it was wrong; from here on, ignore the
;;; number-of-args information and assume that the user will fix it.
;;; Otherwise it will get caught at run-time anyway.
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;;
;;; The special cases for (foo (let ((x (bar))) (baz x))) here are not handled yet!
;;;
0(defconst *maximum-rest-arg-size* 16.)		;Anything bigger is special-cased
(defconst *largest-mvg-size* 8)			;Anything bigger is special-cased

(defconst compiler:*functions-without-extra-args*
	  '(append si:append-2
	     cons funcall
	     si:%make-double si:%make-complex
	     list si:%list-1 si:%list-2 si:%list-3 si:%list-4 si:%list-n
	     list* si:%list*-1 si:%list*-2 si:%list*-3 si:%list*-4 si:%list*-n
	     %1d-aref %1d-aset
	     ncons
	     si:%return-from-lambda))

(defmethod (phase-1-function-call i-architecture-mixin)
	   (arg-function-name arg-subforms destination class info lambda-list)
  info						;unused.
  lambda-list					;unused.  Part of defunct FEXPR system.
  (selectq class
    (function-call)
    (special
     ;; This is a call to a user-defined "FEXPR".  In the new lexical scoping
     ;; system we don't support those, since there is no way even the few cases
     ;; that used to work could still work.
     (phase-1-bad-form "~S is a special form but the compiler has not been told
how to compile calls to it.  Use a macro, a compiler transformer,
a COMPILER:PHASE-1 property, or a COMPILER:PHASE-1-HOOK property." arg-function-name))
    (otherwise
     (llc-error "~S is unrecognized as the classification of the form ~S;
something is broken in the compiler."
		class *phase-1-form*)))

  (when (eq arg-function-name 'start-call)
    (note-unknown-group *control-stack-state*))

  (let* ((function-name arg-function-name)
	 (subforms arg-subforms)
	 (generic-p nil)
	 (start-argno 0)
	 (n-args (length arg-subforms))
	 (local (si:local-function-definition
		  function-name *interpreter-lexical-environment*))
	 (function (or local (external-function function-name)))
	 (inline-p (and (not (si:env-declarations-inline-p
			       arg-function-name *interpreter-lexical-environment*))
			'cl:notinline)))

    ;; Undo inline FUNCALL where possible.
    (when (and (not local)
	       (eq function-name 'funcall)
	       (not (eq inline-p 'cl:notinline)))
      (let ((funarg (first subforms)))
	(when (and (listp funarg)
		   (= 2 (length funarg))
		   (eq (first funarg) 'function)
		   (sys:validate-function-spec (second funarg))
		   (si:definition-has-location-p (second funarg)))
	  (setf function-name (second funarg))
	  (setf subforms (rest1 subforms))
	  (decf n-args)
	  (incf start-argno)
	  (setf local (si:local-function-definition
			function-name *interpreter-lexical-environment*))
	  (setf function (or local (external-function function-name)))
	  (setf inline-p (and (not (si:env-declarations-inline-p
				     function-name *interpreter-lexical-environment*))
			      'cl:notinline)))))

    ;; Do type checking
    (unless local
      (multiple-value-bind (return-type for-effect)
	  (compiler:function-return-type function-name)
	(when (and for-effect
		   (not (eql 0 (destination-n-values destination))))
	  (phase-1-warning
	    "Compiling a call to ~A for value even though its value is not defined."
	    (function-pr function)))
	(compiler:check-types-compatible destination return-type)))

    ;; Insert trampoline if there are lots of arguments.
    (when (> n-args *maximum-rest-arg-size*)
      (unless (and (not local)
		   (member function-name *funcalling-functions*))
	(push `#',function-name subforms)
	(incf n-args)
	(decf start-argno)
	(setf function-name 'funcall)
	(setf local nil)
	(setf function (external-function 'funcall)))
      (setf inline-p 'cl:notinline))

    ;; First deal with lexical functions and I-machine FUNCALL.
    (selectq (function-type function)
      (internal
       (emit-var (lookup-variable (lexical-function-cell-name (function-label function))))
       ;; If this is a call to a lexical function which is
       ;; not defined by the current function, save it on
       ;; the list of lexical functions that have to be
       ;; fixed up if the current function's
       ;; lexical-closure cannot be consed on the stack.
       (when (and (eq (function-type *function*) 'internal)
		  (neq (function-parent-function function) *function*))
	 (push* function (function-lexical-functions-called *function*)))
       ;; Emit the call starter, and change to FUNCALL.
       (setf function-name 'funcall)
       (setf local nil)
       (setq function (external-function 'funcall))
       (setf inline-p nil))
      (compiler:interpreter)
      ((external reference)
       (when (and (memq function-name *funcalling-functions*)
		  (not (eq inline-p 'cl:notinline)))
	 (let ((*function-name* arg-function-name)
	       (*function-call-subforms* arg-subforms)
	       (*argno* start-argno))
	   (phase-1 (first subforms) *destination-stack* subforms nil t))
	 (when (cl:typep (first subforms) 'sys:generic-function)
	   (setq generic-p t))
	 (decf n-args)
	 (incf start-argno)
	 (pop subforms)))
      (otherwise
       (phase-1-bad-form
	 "You cannot call ~S as it is not a function." function-name)))

    (let* ((start-call-inst
	     (emit-start-call function destination))
	   (pframe-p (or (eq inline-p 'cl:notinline)
			 (not (or (get function-name 'built-in)
				  (get function-name 'assemble-function)
				  (get-kludged-built-in *compiler* function-name)))))
	   (possible-extra-arg-p
	     (and pframe-p
		  (not (if (eq function-name 'funcall)
			   (eq inline-p 'cl:notinline)
			   (memq function-name compiler:*functions-without-extra-args*)))
		  (not generic-p))))
      ;; Open a new pframe, so that we can abort this call (e.g, if there's a RETURN).
      (with-new-control-stack-state
	(when possible-extra-arg-p
	  (note-unknown-group *control-stack-state*))
	(let-if possible-extra-arg-p
		((*multiple-count* (1+ *multiple-count*)))
	  (let-if pframe-p
		  ((compiler:*pframe*
		     (make-open-call-pframe :open-call-start-call start-call-inst)))
	    ;; Handle the arguments.
	    ;; This is an ordinary function, without "quoted" arguments.
	    ;; The subforms have been transformed already, so don't do it again.
	    (loop with *function-name* = arg-function-name
		  with *function-call-subforms* = arg-subforms
		  for *argno* from start-argno
		  for subforms on subforms
		  as subform = (first subforms)
		  do
	      (phase-1 subform *destination-stack* subforms nil t))))
	(emit-call function n-args destination inline-p start-call-inst)))))

(defmethod (compiler:phase-1-lambda-combination i-architecture-mixin)
	   (name var-list val-list body destination)
  (function-of-lambda name var-list body nil)
  (let* ((n-args (length val-list))
	 (inline-p nil)
	 (start-call (emit-start-call (external-function 'funcall) destination)))
    (dolist (val val-list)
      (phase-1 val *destination-stack* val-list nil t))
    (when (> n-args *maximum-rest-arg-size*)
      (incf n-args)
      (setf inline-p 'cl:notinline))
    (emit-call (external-function 'funcall) n-args destination inline-p start-call)))

(defmethod (compiler:make-array-optimizer-length-limit i-architecture-mixin)
	   ()
  #-IMACH(i-support::defsysbyte-limit-value i:sys:array-short-length-field)
  #+IMACH(defsysbyte-limit-value sys:array-short-length-field))

;;; Analysis by DLA indicates that this is never worth it on the I machine
(defmethod (compiler:case-to-computed-go-p i-architecture-mixin)
	   (all-keys)
  (declare (ignore all-keys))
  nil)

(defmethod (compiler:emit-supplied-p i-architecture-mixin)
	   (argument argument-number)
  (declare (ignore argument-number))
  (let ((supplied-p-var (compiler:argument-supplied-p-var argument)))
    (when (and supplied-p-var (eq (variable-type supplied-p-var) 'lexical))
      (setf (compiler:lexical-supplied-p supplied-p-var) t)
      (setf (compiler:lexical-argument-p supplied-p-var) nil)))
  (emit (compiler::make-arg-supplied-p-instruction
	  :arg-supplied-p-arg argument)))

(defmethod (compiler:general-take-args i-architecture-mixin)
	   (argument-list)
  (declare (special n-required n-optional compiler:rest-arg))
  (loop for argument in argument-list
	collect (or (compiler:argument-ivar argument)
		    (compiler:argument-var argument))
	  into ivars
	when (eq (compiler:argument-requiredness argument) 'compiler:optional)
	  collect (compiler:collect-interval
		    (emit-const nil))
	    into init-intervals
	finally
	  (cond ((and (not (null init-intervals))
		      compiler:rest-arg)
		 ;; (See note in DEFS where the take-args instruction is defined.)
		 (nconc init-intervals
			(ncons (compiler:collect-interval
				 (emit-const 'nil))))))
	  (compiler:emit-take-args
	    n-required n-optional (not (null compiler:rest-arg)) init-intervals)
	  (compiler:emit-name ivars)
	  (mapc #'compiler:note-argument-lexical ivars))
  ;; Now take the arguments one at a time
  (loop with instance-called = (and (typep *function* 'external-function)
				    (assq 'instance-variables
					  (function-user-declares *function*))
				    (cdr argument-list)
				    (eq (compiler:argument-var (first argument-list)) 'self)
				    (eq (compiler:argument-var (second argument-list))
					'self-mapping-table))
	for argument in argument-list
	for argument-number from 0
	for instance-called-variable =
	    (and instance-called (< argument-number 2)) do
    (ignore instance-called-variable)
    (let ((var (compiler:argument-var argument)))
      ;; Get the value of the argument onto the stack.
      (selectq (compiler:argument-requiredness argument)
	(compiler:required)
	(compiler:rest)
	(compiler:optional
	 (let ((join-tag (make-tag)))
	   (compiler:emit-supplied-p *compiler* argument ARGUMENT-NUMBER)
	   ;; The value on the stack says whether the argument was provided.
	   (let ((supplied-p-var (compiler:argument-supplied-p-var argument)))
	     (if (null supplied-p-var)
		 ;; No supplied-p.  Just jump if false.
		 (compiler:emit-jump 'true join-tag)
		 (selectq (variable-type supplied-p-var)
		   (lexical
		    ;; Let the slot currently on the stack BE the supplied-p
		    ;; variable.  If NIL, leave it and jump.  Else push t.
		    (compiler:note-argument-lexical supplied-p-var)
		    (compiler:emit-name (list supplied-p-var))
		    (compiler:emit-jump 'true join-tag 0 0))
		   (special
		    ;; Bind the variable and jump if false.
		    (emit-copy)
		    (emit-bind supplied-p-var)
		    (compiler:emit-jump 'true join-tag))
		   (otherwise
		    (phase-1-bad-form "Can't handle this type.")))))
	   ;; If argument was not supplied:
	   (when (eq (compiler:argument-requiredness argument) 'compiler:optional)
	     ;; If argument is optional, insert the init code here.
	     (compiler:emit-interval (compiler:argument-init-interval argument))
	     (if (eq (variable-type var) 'special)
		 (compiler:emit-setq (compiler:argument-ivar argument))
		 (compiler:emit-setq var))
	     (compiler:emit-pop))
	   (emit-tag join-tag)))
	(otherwise
	 (llc-error "Illegal requiredness in ~S" argument)))
      ;; Now that it is initialized, do the right thing with it.
      (selectq (variable-type var)
	(lexical)
	(special
	 (let ((ivar (compiler:argument-ivar argument)))
	   ;; This will totally screw up if the backend tries to
	   ;; use stack-pointer addressing rather than frame-pointer.
	   (emit-var ivar))
	 (setf (function-lexical-variables *function*)
	       (delq (compiler:argument-ivar argument)
		     (function-lexical-variables *function*)))
	 (emit-bind var))
	(instance
	 (phase-1-bad-form "Instance variables can't be arguments: ~S"
			   var))
	(otherwise
	 (llc-error "Bad variable type: ~S" var))))))

(defmethod (compiler:call-defun-in-flavor i-architecture-mixin) (def form)
  (let ((flavor (second def)))
    `(funcall #'(defun-in-flavor ,(first form) ,flavor)
	      (flavor:get-flavor-mapping-table-for-instance self ',flavor)
	      self ,@(rest1 form))))

(defmethod (compiler:note-argument-lexical-internal i-architecture-mixin)
	   (lexical-variable)
  (declare (special compiler:location compiler:rest-arg))
  (unless (compiler:lexical-supplied-p lexical-variable)
    (setf (lexical-argument-p lexical-variable) t))
  (when (eq compiler:rest-arg lexical-variable)
    (setq compiler:location 0))
  (setf (lexical-location lexical-variable) compiler:location)
  (incf compiler:location))

(defmethod (function-plist-indicator i-architecture-mixin) () ':i-compiled-function)

(defmethod (generate-object-representation i-architecture-mixin) (function-list fixup-p)
  (let ((*phase-4-to-core* fixup-p)
	(*function-mapping-table-families* nil))
    (mapc #'assemble-function function-list)
    (fixup-compiled-functions)
    t))

(defmethod (get-assemble-function i-architecture-mixin) (spec)
  (get spec 'assemble-function))

(defmethod (get-built-in i-architecture-mixin) (spec n-args)
  (let ((b (get spec 'built-in)))
    (when b
      (if n-args
	  (if (> (length b) 1)
	      ;; There's more than one - check arg count
	      (loop for b-i in b
		    thereis (and (= (built-in-n-arguments b-i) n-args) b-i))
	      ;; There's only one - use it regarless of the arg count
	      (car b))
	  b))))

(defmethod (get-kludged-built-in i-architecture-mixin) (spec)
  (cdr (assoc spec *kludged-built-ins*)))

(defmethod (get-modification-function i-architecture-mixin) (&rest spec)
  (cond ((equal spec '(+-internal 1)) '1+local)
	((equal spec '(--internal 1)) '1-local)
	((equal spec '(cdr)) 'cdr-local)
	((equal spec '(car)) 'car-local)
	((equal spec '(%pointer-plus 1)) '%pointer-increment)))

;;; The 3600 uses #o40 here.  That's too big on the I machine just yet, because there
;;; are a lot of functions around for which even this limit is too small.  Until the
;;; compiler is fixed, we just have to take our chances with values being returned,
;;; etc.
(defmethod (compiler:max-frame-size  i-architecture-mixin) ()
  (- i:sys:control-stack-max-frame-size #o20))

#-imach
(defmethod (compiler:get-data-type-number i-architecture-mixin) (type-name)
  (cl:ecase type-name
    (dtp-list i:sys:dtp-list)))

#+imach
(defmethod (compiler:get-data-type-number i-architecture-mixin) (type-name)
  (cl:symbol-value type-name))

(defmethod (cement-args-and-destination i-architecture-mixin) (inst n-args destination)
  (let ((spec (function-spec (call-function inst)))
	(size (destination-size destination))
	(force-external (call-force-external inst)))
    (cond ((and (not force-external)
		(memq spec *funcalling-functions*))
	   ;; Handle these guys specially - basically, just set the stack level back
	   ;; to what it was before the start call + any returned values.  If no start-call,
	   ;; then use the number of arguments to figure out the starting level.
	   (when (destination-for-return destination)
	     (setq *dead* t))
	   (setq *level*
		 (let ((starter (car (call-start-call inst))))
		   (cond (starter
			  (setq compiler:*l-level* (compiler:start-call-l-level starter))
			  (+ (start-call-level starter)
			     (if (symbolp size) 0 size)))
			 (t
			  (+ (- *level*
				(selectq spec
				  ((compiler:%funcall-n compiler:%lexpr-funcall-n)
				   n-args)
				  (otherwise
				   (+ n-args 3))))
			     (typecase size
			       (:fixnum size)
			       (:symbol (selectq size
					  (multiple 0)
					  (return 1))))))))))
	  ;; Normal case
	  (t
	   (let ((n-to-pop
		   (+ n-args (if (and (not force-external)
				      (or (call-builtin inst)
					  (get spec 'assemble-function)
					  (assoc spec *kludged-built-ins*)))
				 0
				 ;; If call is not to a built-in, then it will
				 ;;  have a call-starter that pushes 2 or 3 words
				 ;;  onto the stack.
				 (if (member spec compiler:*functions-without-extra-args*)
				     2
				     3)))))
	     (selectq size
	       (return
		;; Return from function, it's all over.
		(setq *dead* t))
	       (multiple
		;; Multiple value group left on stack.  Note it, pop arguments.
		(decf-level n-to-pop))
	       (otherwise
		;; Pop off the arguments and the call starter and push the returned values.
		(incf-level (- size n-to-pop)))))))))

(defmethod (emit-binding-stack-level i-architecture-mixin) ()
  (setf (inst-level (emit-const i:sys:%register-binding-stack-pointer)) *level*)
  (incf-level)
  (let ((call (emit-call (external-function 'i:sys:%read-internal-register)
			 1 *destination-stack* 'cl:inline)))
    (setf (inst-level call) *level*)
    (decf-level)				;Arg popped
    call))

(defmethod (cement-macro-instruction i-architecture-mixin) (inst)
  ;; Assume at least one arg always comes from the operand field in the instruction.
  ;; This is a horrible kludge.  MBell 4/16/86 19:28:56
  (let* ((opcode (let ((temp (macro-instruction-opcode inst)))
		   (typecase temp
		     (:null (ldb i:sys:%%packed-instruction-opcode
				 (macro-instruction-bits inst)))
		     (:number temp)
		     (:symbol (symeval temp))
		     (otherwise (error "Bad opcode")))))
	 (operand (macro-instruction-operand inst))
	 (n-args (get-opcode-n-args opcode))
	 (n-vals (get-opcode-n-returned opcode))
	 (attributes (get-opcode-attributes opcode)))
    (cond ((memq ':loop attributes))		;They don't change level
	  ((and (eql opcode *set-sp-to-address-opcode*)
		(eql (ldb I:sys:%%packed-instruction-addressing-mode operand)
		     stack-addressing-mode-stack-pointer))
	   (incf-level (- (ldb %%packed-instruction-8-bit-operand operand) 255.)))
	  ((and (fixp n-args) (fixp n-vals))
	   (incf-level
	     (- n-vals				;pushes
		(if (eql n-args 0)
		    0				;no operands to pop
		  (if (and (memq 'pop (get-opcode-legal-operand-types opcode))
			   (eql (ldb I:sys:%%packed-instruction-addressing-mode operand)
				stack-addressing-mode-stack-pointer)
			   (eql (ldb I:sys:%%packed-instruction-8-bit-operand operand)
				stack-addressing-mode-frame-pointer))
		      n-args			;last operand popped
		    (1- n-args))))))		;last operand not popped
	  ((numberp n-vals)
	   (incf-level (- n-vals (1- n-args))))
	  ((and (eql opcode *push-n-nils-opcode*)
		(eql (ldb I:sys:%%packed-instruction-addressing-mode operand)
		     stack-addressing-mode-immediate))
	   (incf-level (ldb %%packed-instruction-8-bit-operand operand)))
	  (t
	   (cl:warn "%INSTRUCTION construct can't figure out stack effect of ~S" inst))))
  t)

(defmethod (compiler:catch-pframe-size-internal i-architecture-mixin)
	   (pframe)
  (selectq (catch-or-unwind pframe)
    (catch 5)
    (unwind 3)
    (otherwise (error "Illegal pframe ~a" pframe))))

(defmethod (cement-throw i-architecture-mixin) (ignore)
  (setq *dead* t)
  nil)						;No further need of instruction

(defmethod (cement-unwind i-architecture-mixin) (inst)
  (let* ((target (unwind-pframe inst))
	 (destination (unwind-destination inst))
	 (dest-size (destination-size destination))
	 (dest-size-n (if (eq dest-size 'multiple) 0 dest-size)))
    (multiple-value-bind (abort-call-fcn abort-call-dest abort-adjust)
	(cl:case dest-size
	  (0 (values 'si:abort-call-0 *destination-ignore* nil))
	  (1 (values 'si:abort-call-1 *destination-stack* nil))
	  (multiple (values 'si:abort-call-multiple *destination-multiple* nil))
	  (return (error "Not yet implemented."))
	  (otherwise (values 'si:abort-call-multiple *destination-multiple* t)))
      (flet ((flush-catch-frame (pframe)
	       ;; On the I machine, CATCH-CLOSE doesn't do anything about the stack
	       ;; level of things pushed inside the catch, so we have to clean these
	       ;; up.
	       (let ((n-pushed
		       (- *level*
			  (+ (catch-level pframe)
			     (catch-pframe-size pframe))
			  dest-size-n)))
		 (setf (inst-level (emit-end-catch pframe destination n-pushed)) *level*))
	       (setq *level* (+ (catch-level pframe) dest-size-n)
		     compiler:*l-level* (compiler:catch-l-level pframe)
		     *b-level* (catch-b-level pframe)))
	     (adjust-b-level (dest-b-level)
	       (when (plusp (compiler:bindings-in-control-stack *compiler*))
		 (let ((bindings (- *b-level* dest-b-level)))
		   (when (plusp bindings)
		     (setf (inst-level (emit-unbind bindings)) *level*)
		     (compiler:decf-b-level bindings))))))
	(loop for pframe = (unwind-current-pframe inst) then (pframe-parent pframe)
	      until (eq pframe target) do
	  (if (null pframe) (llc-error "Could not find the PROG for a GO or RETURN"))
	  (cl:ecase (pframe-type pframe)
	    (dbs
	      (when (dbs-bind-p pframe)
		;; Get at the binding stack pointer, which was pushed after the start of
		;; this dbs (i.e. is at 1+ it's level).
		;; >>> Don't emit the start-call here, since it's for a built-in. <<<
		(setf (inst-level (emit-copy (- *level* (1+ (dbs-var-level pframe)))
					     (eq dest-size 'multiple)))
		      *level*)
		(incf-level)
		(setf (inst-level
			(emit-call (external-function 'system:%restore-binding-stack-level)
				   1
				   *destination-ignore*))
		      *level*)
		(decf-level)
		(setq *b-level* (dbs-b-level pframe))))
	    (catch
	      (flush-catch-frame pframe))
	    ((block tagbody compiler:new-block-read-test)
	     (when (compiler:nlg-non-local-reference-p pframe)
	       (flush-catch-frame pframe)))
	    (multiple
	      ;; The idea here is to pop off the multiple group, and any other things that
	      ;; were pushed, then set the running control stack level what is was before
	      ;; the group was pushed.
	      (adjust-b-level (compiler:multiple-b-level pframe))
	      (let* ((ml (+ dest-size-n (multiple-level pframe)))
		     (n-pushed (- *level* ml)))
		;; First we have to pop off any extra values other than the multiple group
		;; which have been pushed in the
		(when (plusp n-pushed)
		  (setf (inst-level (emit-pop n-pushed dest-size)) *level*)
		  (decf-level n-pushed))
		;; Then pop the multiple group itself.
		(setf (inst-level (emit-pop 'multiple dest-size)) *level*)
		(setq compiler:*l-level* (compiler:multiple-l-level pframe))
		(setq *level* ml)))
	    (compiler:saved-multiple
	      ;; The idea here is to pop off the multiple group, and any other things that
	      ;; were pushed, then set the running control stack level what is was before
	      ;; the group was pushed.
	      (adjust-b-level (compiler:saved-multiple-b-level pframe))
	      (let ((ml (+ dest-size-n (compiler:saved-multiple-level pframe))))
		(setf (inst-level (compiler:emit-computed-pop
				    `(,(compiler:saved-multiple-variable pframe))
				    (compiler:saved-multiple-offset pframe)
				    dest-size))
		      *level*)
		(setq *level* ml)
		(setq compiler:*l-level* (compiler:saved-multiple-l-level pframe))))
	    ;; We have to emit ABORT-CALL's for all of the open-call pframes
	    (open-call
	      (let ((open-start-call (open-call-start-call pframe)))
		(adjust-b-level (compiler:start-call-b-level open-start-call))
		(when abort-adjust
		  ;; MVGs don't count against the level, so make the pushed values go
		  ;; away as we turn into one.
		  (decf-level dest-size)
		  (setf (inst-level (emit-const dest-size)) *level*))
		(let (;; This is the number of words, not including the values to be
		      ;; returned, which will be popped by the abort call
		      (words-to-pop (+ (sys:defstorage-size sys:stack-frame)
				       (- *level*
					  (inst-level (inst-next open-start-call)))))
		      (start-call (emit-start-call (external-function abort-call-fcn)
						   abort-call-dest)))
		  (setf (inst-level start-call) *level*)
		  (incf-level 2)
		  (setf (inst-level (emit-const words-to-pop)) *level*)
		  (incf-level)
		  (setf (inst-level
			  (emit-call (external-function abort-call-fcn) 1 abort-call-dest
				     'cl:inline start-call))
			*level*)
		  (when abort-adjust (reconcile-destinations abort-call-dest destination))
		  (setq *level* (+ (start-call-level open-start-call) dest-size-n))
		  (setq compiler:*l-level*
			(compiler:start-call-l-level open-start-call)))))
	    ;; We have to emit ABORT-CALL's for all of the open-call pframes
	    (compiler:nlg-transfer
	      (when (compiler:nlg-transfer-non-local pframe)
		(adjust-b-level (compiler:start-call-b-level (compiler:nlg-transfer-start-call pframe)))
		(let* ((level (start-call-level (compiler:nlg-transfer-start-call pframe)))
		       (to-pop (- *level* level (if abort-adjust dest-size 0))))
		  (when abort-adjust
		    (setf (inst-level (emit-const dest-size)) *level*)
		    (incf-level))
		  (let ((start-call (emit-start-call (external-function abort-call-fcn)
						     abort-call-dest)))
		    (setf (inst-level start-call) *level*)
		    (incf-level 2)
		    ;; This is the number of words, not including the values to be
		    ;; returned, which will be popped by the abort call
		    (setf (inst-level (emit-const to-pop)) *level*)
		    (incf-level)
		    (setf (inst-level
			    (emit-call (external-function abort-call-fcn)
				       1 abort-call-dest 'cl:inline start-call))
			  *level*)
		    (when abort-adjust
		      (reconcile-destinations abort-call-dest destination))
		    (setq *level* level)
		    (setq compiler:*l-level* (compiler:start-call-l-level start-call))))))))
	(if (and (compiler:unwind-outside-p inst)
		 (compiler:nlg-non-local-reference-p target))
	    (flush-catch-frame target)
	    (let* ((target-level (+ (compiler:nlg-level target)
				    dest-size-n))
		   (target-b-level (compiler:nlg-b-level target)))
	      (let ((delta-b-level (- *b-level* target-b-level)))
		(when (plusp delta-b-level)
		  (setf (inst-level (emit-unbind delta-b-level)) *level*)))
	      (let ((delta-level (- *level* target-level)))
		(when (plusp delta-level)
		  (setf (inst-level (emit-pop delta-level dest-size)) *level*)
		  (decf-level delta-level)))
	      (setq *level* target-level)
	      (setq compiler:*l-level* (compiler:nlg-l-level target))
	      (setq *b-level* target-b-level)))
	nil))))

(defmethod (emit-%make-lexical-environment i-architecture-mixin) (ncells)
  (let* ((fun (external-function 'si:%make-lexical-environment))
	 (start-inst (emit-start-call fun *destination-stack*)))
    (emit-const ncells)
    (emit-call fun 1 *destination-stack* nil start-inst)))

(defmethod (built-in-address-operand-p i-architecture-mixin) (built-in)
  (let ((format (built-in-format built-in)))
    (cl:subsetp '(lp fp sp) format)))

(defmethod (format-fits-arg i-architecture-mixin) (format arg)
  (and (numberp arg)
       (let ((type (cl:set-difference format '(lp fp sp pop))))
	 (if (and (listp type)
		  (null (cdr type)))
	     (possible-immediate-operand? arg (car type))
	     (cl:error "Internal I compiler error - bad format")))))

(defmethod (emit-call-sequence i-architecture-mixin)
	   (function arg-pushing-continuation n-args destination &optional inline-p)
  (let ((start-call (emit-start-call function destination)))
    (funcall arg-pushing-continuation)
    (emit-call function n-args destination inline-p start-call)))

(defwhopper (compiler:emit-setq-sequence i-architecture-mixin)
	    (variable value-form value-source-locator destination)
  (if (and (not (destination-usage destination 0))
	   (eq (compiler:variable-type variable) 'special))
      ;; When doing SETQ of a special variable ignoring the value, formulate
      ;; this as a call to RPLACD.  We have to do that here since the back end
      ;; can't shuffle the stack efficiently.
      (emit-call-sequence self
			  (external-function 'rplacd)
			  #'(lambda ()
			      (emit-var-location variable)
			      (phase-1 value-form *destination-stack* value-source-locator))
			  2 destination)
      (continue-whopper variable value-form value-source-locator destination)))

(defmethod (compiler:get-peep-hole-optimizers i-architecture-mixin) (function)
  (get function 'peep-hole-optimizers))

(defmethod (compiler:emit-start-call-if-needed i-architecture-mixin)
	   (function destination n-args)
  (let ((spec (function-spec function)))
    (unless (or (get-kludged-built-in *compiler* spec)
		(and (memq (function-type function) '(external reference))
		     (symbolp spec)
		     (or (get-assemble-function *compiler* spec)
			 (get-built-in *compiler* spec n-args))))
      (emit-start-call function destination))))

(defun environment-is-referenced (function)
  (when (eq (function-type function) 'internal)
    (loop for (name . var) in (function-lexical-contour function)
	  doing
      (ignore name)
      (when (and (typep var 'compiler:variable)
		 (eq 'compiler:lexical (variable-type var))
		 (null (compiler:lexical-superseding-variable var)))
	(loop for ref-function in (compiler:lexical-referencing-functions var)
	      doing
	  (when (and (neq ref-function function)
		     (loop for f first (function-parent-function ref-function)
				 then (function-parent-function f)
			   doing
		       (when (eq f function)
			 (return-from environment-is-referenced t))
		       (when (eq (function-type f) 'external)
			 (return))))))))))

;;; The cases we have to worry about:
;;; If there is no &rest arg, then we just do everything FP-based.
;;; If there is an &rest arg, but only non-&rest args are needed in the closure, then
;;; we do everything FP-based.
;;; If there is an &rest arg and either the &rest arg or one of the locals is needed
;;; in the downward closure, then we must be LP-based, and any arguments which are
;;; needed in the closure must be copied to an LP location.
(defmethod (compiler:determine-argument-residence i-architecture-mixin) (function)
  ;; Copy the arguments at FP|2 and FP|3 if we need them for slot access.
  (when (compiler:function-has-mapped-slot-access function)
    (let* ((args-to-relocate nil)
	   (args-info (function-args-info function))
	   (max-args (ldb %%arg-desc-max-args args-info)))
      ;; Pad argument block if necessary.
      (when (< max-args 2)
	(compiler:pad-argument-block (- 2 max-args)
				     :shuffle (ldb-test %%arg-desc-rest-arg args-info)))
      (loop for location from (if (and (eq (function-type function) 'internal)
				       (function-refers-lexically-p function))
				  -1 0)
	    repeat (min 2 max-args)
	    do
	(loop for var in (function-lexical-variables function)
	      do (when (and (lexical-argument-p var)
			    (not (lexical-rest-arg-p var))
			    (eql (lexical-location var) location))
		   (unless (compiler:lexical-free-p var)
		     (lisp:pushnew var args-to-relocate))
		   (return))
	      finally (error "Can't shuffle stack for internal function.")))
      (when args-to-relocate
	(compiler:relocate-arguments-elsewhere function args-to-relocate))))
  (let* ((args-to-relocate nil)
	 (env (compiler:get-environment-list-pointer function nil))
	 (function-has-captive-lexicals-p (function-has-captive-lexicals-p function))
	 (local-offset (function-argument-block-size function))
	 (lp-lexicals 
	   (loop with lexical-non-args = nil
		 with rest-argp = nil
		 for var in (function-lexical-variables function)
		 doing
	     (when (lexical-rest-arg-p var)
	       (setq local-offset 1)
	       (setq rest-argp t))
	     (unless (or (and function-has-captive-lexicals-p
			      (or (and (eq var env)
				       ;; In this case,
				       ;; EMIT-BYTE-LAP-FOR-CAPTIVE-VARIABLES
				       ;; will copy this as if it were
				       ;; lexical-captive-p, even though
				       ;; it isn't marked as such.
				       (compiler:function-refers-lexically-p function))
				  (lexical-captive-p var)))
			 (compiler:lexical-free-p var)
			 (if (eq var env)
			     (not (environment-is-referenced function))
			     (every (compiler:lexical-referencing-functions var)
				    #'function-quick-p)))
	       (if (and (lexical-argument-p var)
			(null (lexical-rest-arg-p var)))
		   (let ((mapping-info (lexical-mapping-table-info var)))
		     (when mapping-info
		       (let ((mapvar
			       (compiler:mapped-access-information-self-mapping-table-variable
				 mapping-info)))
			 (if (lexical-argument-p mapvar)
			     (cl:pushnew mapvar args-to-relocate)
			     (setf lexical-non-args t))))
		     (cl:pushnew var args-to-relocate))
		   (setq lexical-non-args t)))
		 finally
		   (return (and rest-argp lexical-non-args)))))
    (setf (compiler:function-has-lp-lexicals function) lp-lexicals)
    ;; If no variables need LP addressing, we don't need to copy the arguments.
    (when (null lp-lexicals)
      (setf args-to-relocate nil))
    ;; Actually copy things.
    (when args-to-relocate
      (compiler:relocate-arguments-elsewhere function args-to-relocate))
    local-offset))

(defmethod (compiler:jump-pops-valid-p i-architecture-mixin)
	   (pops-if-successful pops-if-not-successful)
  (and ( pops-if-successful 2)
       ( pops-if-not-successful 2)
       ( -1 (- pops-if-successful pops-if-not-successful) 1)))

;; Don't need these because of Cyphers' winning new variable-creation-alist feature.
;; So don't generate them.  That helps out phase-3.
(defmethod (compiler:back-end-requires-pop-vars i-architecture-mixin) () ())

(defmethod (compiler:cement-take-args i-architecture-mixin)
	   (instruction)
  (let ((take-args-n-required (take-args-n-required instruction)))
    (loop for init-interval in (take-args-init-intervals instruction)
	  for initial-level from (+ compiler:*level* take-args-n-required)
	  do
      (let ((compiler:*all-vars-stack-resident* t))
	(compiler:cement-interval init-interval initial-level)))
    (if (take-args-rest-p instruction)
	(if (zerop (take-args-n-optional instruction))
	    (setq compiler:*level* 1)
	    (setq compiler:*level* 2))			;locate-locals
	(incf-level (+ take-args-n-required (take-args-n-optional instruction))))
    t))

#-IMACH
(defconst *defined-fspecs* (cl:make-hash-table :test 'equal :number-of-values 0 :size 5000))

#-IMACH
(defun load-defined-fspecs (file &optional append)
  (unless append
    (cl:clrhash *defined-fspecs*))
  (with-open-file (stream file)
    (let ((*package* (cl:find-package "ICL")))
      (loop for fspec = (read stream nil)
	    while fspec doing
	(setf (cl:gethash fspec *defined-fspecs*) t)))))

#-IMACH
(defmethod (compiler:global-fdefinedp i-architecture-mixin)
	   (fspec)
  (let ((fspec (i-support::flip-to-parallel-world fspec)))
    (or (fdefinedp fspec)
	(cl:gethash fspec *defined-fspecs*)
	(condition-case ()
	     (get-i-compiled-function fspec)
	   (error nil)))))

#+IMACH
(defmethod (compiler:global-fdefinedp i-architecture-mixin)
	   (fspec)
  (fdefinedp fspec))

compiler:
(defmethod (compiler:take-args-stack-effects i-lisp-compiler:i-architecture-mixin) (inst)
  (let ((spread-args (+ (take-args-n-required inst) (take-args-n-optional inst))))
    (when (and (eq (function-type *function*) 'internal)
	       (function-refers-lexically-p *function*))
      (incf spread-args))
    (let ((words spread-args))
      (when (take-args-rest-p inst)
	(incf words)
	(incf words spread-args)
	(when (plusp (take-args-n-optional inst))
	  (incf words))
	(let ((pushed-apply-args (- i-lisp-compiler:*maximum-rest-arg-size* spread-args)))
	  (when (plusp pushed-apply-args)
	    (incf words pushed-apply-args))))
      words)))

(defmethod (compiler:emit-call-split-off-function i-architecture-mixin) (nfunction destination)
  (emit-fun nfunction)
  (emit-call-sequence *compiler* (external-function 'funcall) #'ignore 0 destination))

(defmethod (compiler:bindings-in-control-stack i-architecture-mixin) () 0)

(defmethod (compiler:cement-copy-&rest-argument i-architecture-mixin) (var)
  (let ((*control-stack-state* (inst-post-control-stack-state compiler:*last-inst*))
	(level *level*))
    (let ((fun (emit-fun (external-function 'list))))
      (setf (inst-level fun) *level*)
      (setf (fun-level fun) *level*))
    (let* ((cl-function (external-function 'cl:apply))
	   (start-call (emit-start-call cl-function *destination-stack*)))
      (setf (inst-level start-call) *level*)
      (setf (start-call-level start-call) *level*)
      (setf (start-call-l-level start-call) *l-level*)
      (setf (compiler:start-call-b-level start-call) *b-level*)
      (incf-level 2)
      (with-new-control-stack-state
	(let ((var (emit-var var)))
	  (setf (inst-level var) *level*)
	  (setf (var-level var) *level*))
	(incf-level)
	(setf (inst-level (emit-call cl-function 1 *destination-stack* 'cl:inline start-call))
	      *level*)
	(setf *level* (1+ level))))
    (let ((setq (emit-setq var)))
      (setf (inst-level setq) *level*)
      (setf (setq-level setq) *level*))
    (let ((pop (emit-pop 1)))
      (setf (inst-level pop) *level*)
      (setf (inst-post-control-stack-state pop) *control-stack-state*))
    (decf-level)))
