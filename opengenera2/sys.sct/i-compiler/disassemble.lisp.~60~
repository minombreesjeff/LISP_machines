;;; -*- Mode: LISP; Package: I-LISP-COMPILER; Base: 10; Syntax: Zetalisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;
;;; Format of information from the compiler:
;;;
;;; :VARIABLE-CREATION-ALIST
;;;
;;;    An AList whose entries have a relative PC as their key and a list
;;;    of the names of the top locations on the stack as their value.
;;;
;;; :LEXICAL-VARIABLE-INSTRUCTIONS
;;;
;;;    An AList whose entries have a lexical environment variable name
;;;    as their key, and a list of relative PCs as their value.
;;;
;;; :INSTANCE-VARIABLE-INSTRUCTIONS
;;;
;;;    An AList whose entries have an instance variable name as their
;;;    key, and a list of relative PCs as their value.
;;;
;;; :TRAP-HANDLERS
;;;
;;;    An AList whose entries have a relative PC as their key and a
;;;    trap handler as their value.
;;;

(DEFSUBST SIGN-EXTEND (VALUE SIGN-BIT)
  (SYS:%LOGDPB (- (%LOGLDB (BYTE 1 (1- SIGN-BIT)) VALUE))
	       (BYTE (- 32. SIGN-BIT) SIGN-BIT)
	       VALUE))

(DEFSUBST PACKED-INSTRUCTION-TYPE-P (TYPE)
  (AND ( I:SYS:DTP-PACKED-INSTRUCTION-60 TYPE)
       ( TYPE I:SYS:DTP-PACKED-INSTRUCTION-77)))

(DEFMACRO FULL-WORD-INSTRUCTION-TYPE-P (TYPE)
  `(ZEROP (LOGXOR 5 (LDB (BYTE 3 3) ,TYPE))))

(DEFUN BREAKPOINT-LIST-IN-FUNCTION (FUNCTION)
  (CDR (SI:DEBUGGING-INFO-USER-ENTRY FUNCTION :BREAKPOINTS)))

;; If there is a breakpoint at the given PC, return it
(DEFUN ANY-BREAKPOINT-IN-FUNCTION (FUNCTION &OPTIONAL (PC NIL))
  (IF (NULL PC)
      (NOT (NULL (BREAKPOINT-LIST-IN-FUNCTION FUNCTION)))
    (LOOP FOR BPT IN (BREAKPOINT-LIST-IN-FUNCTION FUNCTION)
	  WHEN (= PC (DBG:BPT-PC BPT))
	    DO (RETURN BPT)
	  FINALLY (RETURN NIL))))

(DEFSYSBYTE %%OPDESC-CLASS 4 0)

(DEFENUMERATED *OPDESC-CLASSES*
	       (OPDESC-CLASS-UNDEFINED
		OPDESC-CLASS-ENTRY
		OPDESC-CLASS-OPERAND-FROM-STACK
		OPDESC-CLASS-EMULATE)
  )

(DEFSYSBYTE %%OPDESC-OPERAND-FROM-STACK-N-POPPED 2. 4.)
(DEFSYSBYTE %%OPDESC-OPERAND-FROM-STACK-N-RETURNED 3. 6.)
(DEFSYSBYTE %%OPDESC-OPERAND-FROM-STACK-SIGNED 1 9.)

(DEFCONST *OPDESC-ARRAY*
	  (FUNCALL #'(LAMBDA ()
		       (LET ((ARRAY (MAKE-ARRAY (LSH 1 (BYTE-SIZE %%PACKED-INSTRUCTION-OPCODE))
						:TYPE ART-FIXNUM)))
			 (DOTIMES (OPCODE 256.)
			   (LET ((N-ARGS (GET-OPCODE-N-ARGS OPCODE))
				 (N-RETURNED (GET-OPCODE-N-RETURNED OPCODE)))
			     (WHEN (AND (NUMBERP N-ARGS) (NUMBERP N-RETURNED))
			       ;; OPDEF has a bias of 1 for these instructions, so subtract it off
			       (SELECTQ (GET-OPCODE-PRETTY-NAME OPCODE)
				 ((EQ-NO-POP EQL-NO-POP EQUAL-NUMBER-NO-POP GREATERP-NO-POP
					     LESSP-NO-POP LOGTEST-NO-POP
					     %UNSIGNED-LESSP-NO-POP)
				  (DECF N-ARGS)
				  (DECF N-RETURNED)))
			       (SETF (AREF ARRAY OPCODE)
				     (DPBS OPDESC-CLASS-OPERAND-FROM-STACK %%OPDESC-CLASS
					   N-ARGS %%OPDESC-OPERAND-FROM-STACK-N-POPPED
					   N-RETURNED %%OPDESC-OPERAND-FROM-STACK-N-RETURNED
					   (IF (MEMQ 'SIGNED
						     (GET-OPCODE-LEGAL-OPERAND-TYPES OPCODE))
					       1
					       0)
					   %%OPDESC-OPERAND-FROM-STACK-SIGNED
					   0)))))
			 ARRAY))))

(DEFUN PARSE-OPDESC-DESCRIPTION (FIELDS)
  `(%LOGDPB ,(FIRST FIELDS) %%OPDESC-CLASS
	    ,(SELECTQ (FIRST FIELDS)
	       (OPDESC-CLASS-ENTRY 0)
	       ((OPDESC-CLASS-OPERAND-FROM-STACK OPDESC-CLASS-EMULATE)
		`(%LOGDPBS ,(SECOND FIELDS) %%OPDESC-OPERAND-FROM-STACK-N-POPPED
			   ,(THIRD FIELDS) %%OPDESC-OPERAND-FROM-STACK-N-RETURNED
			   ,(IF (FOURTH FIELDS) 1 0) %%OPDESC-OPERAND-FROM-STACK-SIGNED
			   0))
	       (OTHERWISE (ERROR "Don't know how to parse this opdesc description")))))

(DEFMACRO DEF-OPDESC (INSTRUCTIONS &BODY VALUE)
  `(LET ((.VALUE. ,(PARSE-OPDESC-DESCRIPTION VALUE)))
     ,@(LOOP FOR INSTRUCTION IN INSTRUCTIONS
	     COLLECT
	       `(SETF (AREF *OPDESC-ARRAY* ,(OPCODE-FOR-INSTRUCTION INSTRUCTION)) .VALUE.))))

(DEFUN MAKE-STACK-ENTRY (TYPE NAME VALUE VALUE-P)
  (IF (AND (EQ TYPE NIL)(SYMBOLP NAME))
      NAME
      (IF VALUE-P
	  (LIST TYPE NAME VALUE)
	  (LIST TYPE NAME))))

(DEFUN STACK-ENTRY-TYPE (STACK-ENTRY)
  (IF (SYMBOLP STACK-ENTRY)
      NIL
      (FIRST STACK-ENTRY)))

(DEFUN STACK-ENTRY-NAME (STACK-ENTRY)
  (IF (SYMBOLP STACK-ENTRY)
      STACK-ENTRY
      (SECOND STACK-ENTRY)))

(DEFUN STACK-ENTRY-VALUE (STACK-ENTRY)
  (DECLARE (VALUES VALUE EXISTS-P))
  (IF (OR (SYMBOLP STACK-ENTRY)
	  (NULL (CDDR STACK-ENTRY)))
      (VALUES NIL NIL)
      (VALUES (THIRD STACK-ENTRY) T)))

(DEFUN STACK-ENTRY-COMPONENTS (STACK-ENTRY)
  (DECLARE (VALUES TYPE NAME VALUE VALUE-P))
  (IF (SYMBOLP STACK-ENTRY)
      (VALUES NIL STACK-ENTRY NIL NIL)
      (SYS:%MULTIPLE-VALUE-CALL-N VALUES
				  (FIRST STACK-ENTRY) 1
				  (SECOND STACK-ENTRY) 1
				  (IF (CDDR STACK-ENTRY)
				      (VALUES (THIRD STACK-ENTRY) T)
				      (VALUES NIL NIL)) 2)))

(DEFUN COPY-STACK-ENTRY (STACK-ENTRY &OPTIONAL NAME)
  (IF (SYMBOLP STACK-ENTRY)
      (IF (SYMBOLP NAME)
	  NAME
	  (MAKE-STACK-ENTRY NIL NAME NIL NIL))
      (MAKE-STACK-ENTRY (STACK-ENTRY-TYPE STACK-ENTRY)
			NAME
			(THIRD STACK-ENTRY)
			(CDDR STACK-ENTRY))))

(CL:DEFSTRUCT (STACK-DESCRIPTION (:TYPE :LIST))
  (SP -1)
  (LP 0)
  (STACK NIL))

(DEFUN PUSH-VALUE (STACK-DESCRIPTION TYPE NAME &OPTIONAL (VALUE NIL VALUE-P))
  (MAKE-STACK-DESCRIPTION
    :SP (1+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
    :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
    :STACK (CONS (MAKE-STACK-ENTRY TYPE NAME VALUE VALUE-P)
		 (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))

(DEFUN PUSH-START-CALL (STACK-DESCRIPTION LOCATIVE)
  (IF (LOCATION-BOUNDP LOCATIVE)
      (LET ((FUNCTION (LOCATION-CONTENTS LOCATIVE)))
	(IF (TYPEP FUNCTION :COMPILED-FUNCTION)
	    (MAKE-STACK-DESCRIPTION
	      :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 2)
	      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	      :STACK (LIST*
		       (MAKE-STACK-ENTRY :CONTROL '.SAVED-CONTROL-REGISTER. NIL NIL)
		       (MAKE-STACK-ENTRY :FRAME '.SAVED-CONTINUATION-REGISTER. FUNCTION T)
		       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	    (MAKE-STACK-DESCRIPTION
	      :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 3)
	      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	      :STACK (LIST*
		       (MAKE-STACK-ENTRY :EXTRA-ARG NIL FUNCTION T)
		       (MAKE-STACK-ENTRY :CONTROL '.SAVED-CONTROL-REGISTER. NIL NIL)
		       (MAKE-STACK-ENTRY :FRAME '.SAVED-CONTINUATION-REGISTER. NIL NIL)
		       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))))
      (MULTIPLE-VALUE-BIND (SYMBOL TYPE)
	  (DISASSEMBLE-DECODE-LOCATIVE LOCATIVE)
	(IF (AND (EQ TYPE :FUNCTION)
		 (MEMQ SYMBOL COMPILER:*FUNCTIONS-WITHOUT-EXTRA-ARGS*))
	    (MAKE-STACK-DESCRIPTION
	      :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 2)
	      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	      :STACK (LIST*
		       (MAKE-STACK-ENTRY :CONTROL '.SAVED-CONTROL-REGISTER. NIL NIL)
		       (MAKE-STACK-ENTRY :FRAME '.SAVED-CONTINUATION-REGISTER. SYMBOL T)
		       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	    (MAKE-STACK-DESCRIPTION
	      :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 3)
	      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	      :STACK (LIST*
		       (MAKE-STACK-ENTRY :EXTRA-ARG NIL NIL NIL)
		       (MAKE-STACK-ENTRY :CONTROL '.SAVED-CONTROL-REGISTER. NIL NIL)
		       (MAKE-STACK-ENTRY :FRAME '.SAVED-CONTINUATION-REGISTER. NIL NIL)
		       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))))))

(DEFUN DECODE-ADDRESS-OPERAND (INSTRUCTION-BITS STACK-DESCRIPTION)
  (DECLARE (VALUES MODE OFFSET-OR-VALUE ENTRY))
  (LET ((OPERAND (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION-BITS)))
    (SELECT (LDB %%PACKED-INSTRUCTION-ADDRESSING-MODE INSTRUCTION-BITS)
      (STACK-ADDRESSING-MODE-FRAME-POINTER
       (VALUES :FP OPERAND (STACK-DESCRIPTION-FP-N STACK-DESCRIPTION OPERAND)))
      (STACK-ADDRESSING-MODE-LOCAL-POINTER
       (VALUES :LP OPERAND (STACK-DESCRIPTION-LP-N STACK-DESCRIPTION OPERAND)))
      (STACK-ADDRESSING-MODE-STACK-POINTER
       (IF (ZEROP OPERAND)
	   (VALUES :SP :POP (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION 0))
	   (VALUES :SP
		   (- OPERAND 255.)
		   (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION (- 255. OPERAND)))))
      (STACK-ADDRESSING-MODE-IMMEDIATE
       (VALUES
	 :IMMEDIATE
	 (IF (LDB-TEST %%OPDESC-OPERAND-FROM-STACK-SIGNED
		       (AREF *OPDESC-ARRAY* (LDB %%PACKED-INSTRUCTION-OPCODE
						 INSTRUCTION-BITS)))
	     (SIGN-EXTEND OPERAND 8)
	     OPERAND))))))

(DEFUN SP-OFFSET (STACK-DESCRIPTION INSTRUCTION-BITS)
  (LET ((SP (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	(OPERAND (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION-BITS)))
    (SELECT (LDB %%PACKED-INSTRUCTION-ADDRESSING-MODE INSTRUCTION-BITS)
      (STACK-ADDRESSING-MODE-FRAME-POINTER (- SP OPERAND))
      (STACK-ADDRESSING-MODE-LOCAL-POINTER
       (- SP (STACK-DESCRIPTION-LP STACK-DESCRIPTION) OPERAND))
      (STACK-ADDRESSING-MODE-STACK-POINTER (- 255. OPERAND)))))

(DEFUN POP-N (STACK-DESCRIPTION N)
  (MAKE-STACK-DESCRIPTION
    :SP (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) N)
    :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
    :STACK (NTHCDR N (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))

(DEFUN PUSH-N (STACK-DESCRIPTION N)
  (IF (= N 0)
      STACK-DESCRIPTION
      (MAKE-STACK-DESCRIPTION
	:SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) N)
	:LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	:STACK (LET ((LIST (MAKE-LIST (1+ N))))
		 (%P-STORE-CDR-CODE (%POINTER-PLUS LIST (1- N)) CDR-NORMAL)
		 (%P-STORE-CONTENTS (%POINTER-PLUS LIST N)
				    (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
		 LIST))))

(DEFUN STACK-DESCRIPTION-FP-N (STACK-DESCRIPTION N)
  (IF STACK-DESCRIPTION
      (LET ((SP (STACK-DESCRIPTION-SP STACK-DESCRIPTION)))
	(IF (> N SP)
	    (MAKE-STACK-ENTRY 'ILLEGAL-OPERAND NIL NIL NIL)
	    (NTH (- SP N) (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))
      'UNKNOWN))

(DEFUN STACK-DESCRIPTION-FP-LOC (STACK-DESCRIPTION N)
  (DECLARE (IGNORE STACK-DESCRIPTION))
  N)

(DEFUN STACK-DESCRIPTION-SP-N (STACK-DESCRIPTION N)
  (IF STACK-DESCRIPTION
      (IF (> N (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	  (MAKE-STACK-ENTRY 'ILLEGAL-OPERAND NIL NIL NIL)
	  (NTH N (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
      'UNKNOWN))

(DEFUN STACK-DESCRIPTION-SP-LOC (STACK-DESCRIPTION N)
  (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) N))

(DEFUN STACK-DESCRIPTION-LP-N (STACK-DESCRIPTION N)
  (IF STACK-DESCRIPTION
      (LET ((SP (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	    (LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)))
	(IF (> N (- SP LP))
	    (MAKE-STACK-ENTRY 'ILLEGAL-OPERAND NIL NIL NIL)
	    (NTH (- SP LP N) (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))
      'UNKNOWN))

(DEFUN STACK-DESCRIPTION-LP-LOC (STACK-DESCRIPTION N)
  (+ (STACK-DESCRIPTION-LP STACK-DESCRIPTION) N)) 

(DEFUN STACK-DESCRIPTION-LOCATION-CONTENTS (STACK-DESCRIPTION LOC)
  (NTH (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) LOC)
       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))

(DEFUN STACK-DESCRIPTION-LOCATION (STACK-DESCRIPTION LOC)
  (NTHCDR (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) LOC)
	  (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))

(DEFUN STACK-DESCRIPTION-NAME-LOCATION (STACK-DESCRIPTION N NAME)
  (LET* ((LOC (NTHCDR (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) N)
		      (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	 (STACK-ENTRY (CAR LOC)))
    (IF (SYMBOLP STACK-ENTRY)
	(IF (SYMBOLP NAME)
	    (SETF (CAR LOC) NAME)
	    (SETF (CAR LOC)
		  (MAKE-STACK-ENTRY NIL NAME NIL NIL)))
	(SETF (SECOND STACK-ENTRY) NAME))))

(DEFUN STACK-DESCRIPTION-NAME-VARIABLES (STACK-DESCRIPTION NAMES)
  (LOOP FOR NAME IN (REVERSE NAMES)
	FOR PLACE ON (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)
	FOR STACK-ENTRY = (CAR PLACE)
	DOING
    (IF (SYMBOLP STACK-ENTRY)
	(IF (SYMBOLP NAME)
	    (SETF (CAR PLACE) NAME)
	    (SETF (CAR PLACE) (MAKE-STACK-ENTRY NIL NAME NIL NIL)))
	(SETF (SECOND STACK-ENTRY) NAME))))

(DEFUN NAME-LOCATION (INSTRUCTION-BITS STACK-DESCRIPTION NAMES-LOC)
  (LET ((NAME (POP (LOCATION-CONTENTS NAMES-LOC))))
    (WHEN NAME
      (LET* ((PLACE (NTHCDR (SP-OFFSET STACK-DESCRIPTION INSTRUCTION-BITS)
			    (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	     (ENTRY (CAR PLACE)))
	(IF (SYMBOLP ENTRY)
	    (IF (SYMBOLP NAME)
		(SETF (CAR PLACE) NAME)
		(SETF (CAR PLACE) (MAKE-STACK-ENTRY NIL NAME NIL NIL)))
	    (SETF (SECOND ENTRY) NAME))))))

(DEFUN NAME-ON-STACK (STACK-DESCRIPTION &OPTIONAL (N 0))
  (STACK-ENTRY-NAME (NTH N (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))

(DEFUN (FUTURE-COMMON-LISP:SETF NAME-ON-STACK)
       (NAME STACK-DESCRIPTION &OPTIONAL (N 0))
  (LET* ((LOC (NTHCDR N (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	 (STACK-ENTRY (CAR LOC)))
    (IF (SYMBOLP STACK-ENTRY)
	(IF (SYMBOLP NAME)
	    (SETF (CAR LOC) NAME)
	    (SETF (CAR LOC)
		  (MAKE-STACK-ENTRY NIL NAME NIL NIL)))
	(SETF (SECOND STACK-ENTRY) NAME))))

(DEF-OPDESC (ENTRY-REST-ACCEPTED ENTRY-REST-NOT-ACCEPTED)
  OPDESC-CLASS-ENTRY)

(DEFVAR *EMULATE-ARRAY* (MAKE-ARRAY 256.))

(DEFMACRO DEFINE-EMULATOR (INSTRUCTIONS
			   (INSTRUCTION-BITS STACK-DESCRIPTION
					     RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
			   &BODY BODY)
  `(PROGN
     (DEFUN (:PROPERTY ,(CAR INSTRUCTIONS) EMULATE)
	    (,INSTRUCTION-BITS ,STACK-DESCRIPTION ,RELATIVE-PC ,NAMES-LOC ,PENDING-PCS-LOC)
       ,INSTRUCTION-BITS ,STACK-DESCRIPTION ,RELATIVE-PC ,NAMES-LOC ,PENDING-PCS-LOC
       ,@BODY)
     ,@(LOOP FOR INSTRUCTION IN INSTRUCTIONS
	     APPENDING
	       (LOOP FOR I FROM 0 BELOW 256.
		     WHEN (EQ (GET-OPCODE-PRETTY-NAME I) INSTRUCTION)
		       APPEND
			 `((SETF (AREF *EMULATE-ARRAY* ,I)
				 #'(:PROPERTY ,(CAR INSTRUCTIONS) EMULATE))
			   (SETF (AREF *OPDESC-ARRAY* ,I)
				 (DPBS OPDESC-CLASS-EMULATE %%OPDESC-CLASS
				       ,(IF (MEMQ 'SIGNED
						  (GET-OPCODE-LEGAL-OPERAND-TYPES I))
					    1 0)
				          %%OPDESC-OPERAND-FROM-STACK-SIGNED
				       0)))))))

;;; 0
(DEFINE-EMULATOR (CAR)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (DECLARE (IGNORE MODE))
    (LET* ((NAME NIL)
	   (STACK-DESCRIPTION
	     (COND ((EQ OFFSET-OR-VALUE :POP)
		    (SETQ NAME (NAME-ON-STACK STACK-DESCRIPTION))
		    (POP-N STACK-DESCRIPTION 1))
		   (T STACK-DESCRIPTION)))
	   (NEW-STACK-DESCRIPTION 
	     (IF (EQ (STACK-ENTRY-TYPE ENTRY) ':STACK-ADDRESS)
		 (LET ((ENTRY (STACK-DESCRIPTION-LOCATION-CONTENTS
				STACK-DESCRIPTION
				(STACK-ENTRY-VALUE ENTRY))))
		   (LET ((VALUE
			   (SELECT (STACK-ENTRY-TYPE ENTRY)
			     ((:MVG :CONSTANT) (STACK-ENTRY-VALUE ENTRY))
			     (OTHERWISE NIL))))
		     (IF VALUE
			 (PUSH-VALUE STACK-DESCRIPTION :CONSTANT NIL VALUE)
			 (PUSH-N STACK-DESCRIPTION 1))))
		 (PUSH-N STACK-DESCRIPTION 1))))
      (WHEN NAME
	(SETF (NAME-ON-STACK NEW-STACK-DESCRIPTION) NAME))
      NEW-STACK-DESCRIPTION)))

;;; 13
(DEFINE-EMULATOR (LOCATE-LOCALS PUSH-GLOBAL-LOGIC-VARIABLE TYPE-MEMBER-NO-POP
				%BLOCK-0-READ %BLOCK-1-READ %BLOCK-2-READ %BLOCK-3-READ
				%BLOCK-0-READ-SHIFT %BLOCK-1-READ-SHIFT
				%BLOCK-2-READ-SHIFT %BLOCK-3-READ-SHIFT
				%READ-INTERNAL-REGISTER %COPROCESSOR-READ)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (PUSH-N STACK-DESCRIPTION 1))

;;; 33
(DEFINE-EMULATOR (ADD)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (DECLARE (IGNORE MODE))
    (LET* ((OFFSET (IF (EQ OFFSET-OR-VALUE :POP) 2 1))
	   (NAME (NAME-ON-STACK STACK-DESCRIPTION (1- OFFSET)))
	   (NEW-STACK-DESCRIPTION (POP-N STACK-DESCRIPTION OFFSET)))
      (BLOCK ADD
	(SELECTQ (STACK-ENTRY-TYPE ENTRY)
	  ((:MVG :CONSTANT)
	   (LET* ((ARG (STACK-DESCRIPTION-SP-N
			 STACK-DESCRIPTION
			 (IF (EQ OFFSET-OR-VALUE :POP) 1 0)))
		  (VAL1 (STACK-ENTRY-VALUE ENTRY))
		  (VAL2 (STACK-ENTRY-VALUE ARG)))
	     (SELECTQ (STACK-ENTRY-TYPE ARG)
	       ((:MVG :CONSTANT)
		(WHEN (AND (NUMBERP VAL1)
			   (NUMBERP VAL2))
		  (RETURN-FROM ADD
		    (PUSH-VALUE NEW-STACK-DESCRIPTION :CONSTANT NAME (+ VAL1 VAL2)))))))))
	(SETQ NEW-STACK-DESCRIPTION (PUSH-N NEW-STACK-DESCRIPTION 1))
	(SETF (NAME-ON-STACK NEW-STACK-DESCRIPTION) NAME)
	NEW-STACK-DESCRIPTION))))

;;; 61
(DEFINE-EMULATOR (PUSH)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (SELECTQ MODE
      (:IMMEDIATE (PUSH-VALUE STACK-DESCRIPTION :CONSTANT NIL OFFSET-OR-VALUE))
      (OTHERWISE
       (MULTIPLE-VALUE-BIND (VALUE VALUE-P) (STACK-ENTRY-VALUE ENTRY)
	 (IF VALUE-P
	     (PUSH-VALUE STACK-DESCRIPTION (STACK-ENTRY-TYPE ENTRY) NIL VALUE)
	     (PUSH-VALUE STACK-DESCRIPTION (STACK-ENTRY-TYPE ENTRY) NIL)))))))

;;; 62
(DEFINE-EMULATOR (POP)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET* ((TOP-OF-STACK (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION 0))
	 (TOS-TYPE (STACK-ENTRY-TYPE TOP-OF-STACK))
	 (NAME (POP (LOCATION-CONTENTS NAMES-LOC)))
	 (OFFSET (SP-OFFSET STACK-DESCRIPTION INSTRUCTION-BITS)))
    (UNLESS (MINUSP OFFSET)
      (LET* ((PLACE (NTHCDR OFFSET (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
	     (ENTRY (FIRST PLACE))
	     (ENTRY-TYPE (STACK-ENTRY-TYPE ENTRY)))
	(IF (OR (AND (EQ TOS-TYPE ':MVG)
		     (OR (EQ ENTRY-TYPE ':MVG)
			 (EQ ENTRY-TYPE ':CONSTANT)))
		(AND (EQ ENTRY-TYPE ':MVG)
		     (OR (EQ TOS-TYPE ':MVG)
			 (EQ TOS-TYPE ':CONSTANT))))
	    (SETF (CAR PLACE)
		  (MAKE-STACK-ENTRY :MVG (OR NAME (STACK-ENTRY-NAME ENTRY))
				    (STACK-ENTRY-VALUE TOP-OF-STACK) T))
	    (WHEN NAME
	      (SETF (CAR PLACE)
		    (IF (SYMBOLP ENTRY)
			(MAKE-STACK-ENTRY NIL NAME NIL NIL)
			(PROGN (SETF (SECOND ENTRY) NAME)
			       ENTRY)))))))
    (POP-N STACK-DESCRIPTION 1)))

;;; 63
(DEFINE-EMULATOR (MOVEM)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (NAME-LOCATION INSTRUCTION-BITS STACK-DESCRIPTION NAMES-LOC)
  STACK-DESCRIPTION)

;;; 64
(DEFINE-EMULATOR (PUSH-N-NILS)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (PUSH-N STACK-DESCRIPTION (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION-BITS)))

(DEFINE-EMULATOR (PUSH-LOCAL-LOGIC-VARIABLES)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (LET ((N (SELECT MODE
	       (:IMMEDIATE
		OFFSET)
	       ((:LP :SP :FP)
		(SELECT (STACK-ENTRY-TYPE ENTRY)
		  ((:MVG :CONSTANT) (STACK-ENTRY-VALUE ENTRY))
		  (OTHERWISE NIL))))))
      (AND N
	   (PUSH-N STACK-DESCRIPTION N)))))

;;; 65
(DEFINE-EMULATOR (PUSH-ADDRESS)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (DECLARE (IGNORE ENTRY))
    (PUSH-VALUE STACK-DESCRIPTION
		:STACK-ADDRESS
		NIL
		(SELECT MODE
		  (:SP (STACK-DESCRIPTION-SP-LOC STACK-DESCRIPTION OFFSET))
		  (:FP (STACK-DESCRIPTION-FP-LOC STACK-DESCRIPTION OFFSET))
		  (:LP (STACK-DESCRIPTION-LP-LOC STACK-DESCRIPTION OFFSET))
		  (OTHERWISE (RETURN-FROM PUSH-ADDRESS NIL))))))

;;; 66
(DEFINE-EMULATOR (SET-SP-TO-ADDRESS)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET ((OFFSET (SP-OFFSET STACK-DESCRIPTION INSTRUCTION-BITS)))
    (MAKE-STACK-DESCRIPTION
      :SP (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) OFFSET)
      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
      :STACK (AND (PLUSP OFFSET)
		  (NTHCDR OFFSET (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))))

;;; 67
(DEFINE-EMULATOR (SET-SP-TO-ADDRESS-SAVE-TOS)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET* ((OFFSET (SP-OFFSET STACK-DESCRIPTION INSTRUCTION-BITS))
	 (STACK-ENTRY (COPY-STACK-ENTRY
			(FIRST (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
			(NAME-ON-STACK STACK-DESCRIPTION OFFSET))))
    (MAKE-STACK-DESCRIPTION
      :SP (- (STACK-DESCRIPTION-SP STACK-DESCRIPTION) OFFSET)
      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
      :STACK (CONS STACK-ENTRY
		   (NTHCDR (1+ OFFSET) (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))))

;;; 68
(DEFINE-EMULATOR (PUSH-ADDRESS-SP-RELATIVE)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (LET ((ARG
	    (IF (EQ MODE :IMMEDIATE)
		OFFSET-OR-VALUE
		(SELECTQ (STACK-ENTRY-TYPE ENTRY)
		  ((:CONSTANT :MVG) (STACK-ENTRY-VALUE ENTRY))
		  (OTHERWISE NIL)))))
      (WHEN (NUMBERP ARG)
	(PUSH-VALUE (IF (EQ OFFSET-OR-VALUE :POP)
			(POP-N STACK-DESCRIPTION 1)
			STACK-DESCRIPTION)
		    :STACK-ADDRESS
		    NIL
		    (STACK-DESCRIPTION-SP-LOC STACK-DESCRIPTION (1+ ARG)))))))

;;; 69
(DEFINE-EMULATOR (STACK-BLT)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE FROM)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (DECLARE (IGNORE MODE))
    (LET* ((SP (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	   (STACK (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
      (WHEN (EQ OFFSET-OR-VALUE :POP)
	;; Get rid of the SP-POP argument
	(POP STACK)
	(DECF SP))
      ;; Get rid of arg 1
      (LET ((TO (POP STACK)))
	(DECF SP)
	(WHEN (AND (EQ (STACK-ENTRY-TYPE FROM) ':STACK-ADDRESS)
		   (EQ (STACK-ENTRY-TYPE TO) ':STACK-ADDRESS))
	  (LET* ((FROM-LOC (STACK-ENTRY-VALUE FROM))
		 (TO-LOC (STACK-ENTRY-VALUE TO))
		 (TO-SAVE (1+ (- SP FROM-LOC)))
		 (TO-POP (- FROM-LOC TO-LOC))
		 (LIST (MAKE-LIST (1+ TO-SAVE))))
	    (LOOP REPEAT TO-SAVE
		  FOR LOC ON LIST
		  DOING
	      (SETF (CAR LOC) (COPY-STACK-ENTRY (POP STACK)))
		  FINALLY
		    (SETF (SECOND LOC) (NTHCDR TO-POP STACK))
		    (%P-STORE-CDR-CODE LOC CDR-NORMAL))
	    (MAKE-STACK-DESCRIPTION
	      :SP (- SP TO-POP)
	      :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	      :STACK LIST)))))))

;;; 70
(DEFINE-EMULATOR (STACK-BLT-ADDRESS)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET* ((FROM-LOC (1- (SP-OFFSET STACK-DESCRIPTION INSTRUCTION-BITS)))
	 (SP (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	 (STACK (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
	 (TO (POP STACK)))
    (DECF SP)
    (WHEN (EQ (STACK-ENTRY-TYPE TO) ':STACK-ADDRESS)
      (LET* ((TO-LOC (STACK-ENTRY-VALUE TO))
	     (TO-SAVE (1+ FROM-LOC))
	     (TO-POP (- (- SP FROM-LOC) TO-LOC))
	     (LIST (MAKE-LIST (1+ TO-SAVE))))
	(LOOP REPEAT TO-SAVE
	      FOR LOC ON LIST
	      DOING
	  (SETF (CAR LOC) (COPY-STACK-ENTRY (POP STACK)))
	      FINALLY
		(SETF (SECOND LOC) (NTHCDR TO-POP STACK))
		(%P-STORE-CDR-CODE LOC CDR-NORMAL))
	(MAKE-STACK-DESCRIPTION
	  :SP (- SP TO-POP)
	  :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	  :STACK LIST)))))

;;; 82, 83
(DEFINE-EMULATOR (SETUP-1D-ARRAY SETUP-FORCE-1D-ARRAY)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (DECLARE (IGNORE MODE ENTRY))
    (LET ((STACK-DESCRIPTION
	    (IF (EQ OFFSET-OR-VALUE :POP)
		(POP-N STACK-DESCRIPTION 1)
		STACK-DESCRIPTION)))
      (WHEN (= (LENGTH (LOCATION-CONTENTS NAMES-LOC)) 1)
	;; This is the typical case, where the compile generates the instruction
	;; because of an array register declaration.  There is only one name, but 4
	;; slots.  For debugging purposes, it makes more sense to associate the name
	;; with the last word in the group rather than the top of the stack, so
	;; rearrange things.  The disassembler also knows about this when it
	;; disassembles FAST-AREF and FAST-ASET.
	(SETF (LOCATION-CONTENTS NAMES-LOC)
	      (LIST (FIRST (LOCATION-CONTENTS NAMES-LOC)) NIL NIL NIL)))
      (PUSH-N STACK-DESCRIPTION 4))))

;;; 89
(DEFINE-EMULATOR (BRANCH)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (PUSH (CONS (+ (SIGN-EXTEND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS) 10.)
		 RELATIVE-PC)
	      STACK-DESCRIPTION)
	(LOCATION-CONTENTS PENDING-PCS-LOC))
  NIL)

;;; 90
(DEFINE-EMULATOR (BRANCH-TRUE BRANCH-TRUE-ELSE-EXTRA-POP BRANCH-TRUE-AND-EXTRA-POP
		  BRANCH-TRUE-EXTRA-POP BRANCH-TRUE-NO-POP BRANCH-TRUE-AND-NO-POP
		  BRANCH-TRUE-ELSE-NO-POP BRANCH-TRUE-AND-NO-POP-ELSE-NO-POP-EXTRA-POP
		  BRANCH-FALSE BRANCH-FALSE-ELSE-EXTRA-POP BRANCH-FALSE-AND-EXTRA-POP
		  BRANCH-FALSE-EXTRA-POP BRANCH-FALSE-NO-POP BRANCH-FALSE-AND-NO-POP
		  BRANCH-FALSE-ELSE-NO-POP BRANCH-FALSE-AND-NO-POP-ELSE-NO-POP-EXTRA-POP)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET* ((OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	 (POPPED (1+ (- (LDB (BYTE 1 0) OPCODE) (LDB (BYTE 1 2) OPCODE))))
	 (BRANCH-POPPED (1+ (- (LDB (BYTE 1 1) OPCODE) (LDB (BYTE 1 2) OPCODE)))))
    (PUSH (CONS (+ (SIGN-EXTEND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS) 10.)
		   RELATIVE-PC)
		(POP-N STACK-DESCRIPTION BRANCH-POPPED))
	  (LOCATION-CONTENTS PENDING-PCS-LOC))
    (POP-N STACK-DESCRIPTION POPPED)))

;;; 106
(DEFINE-EMULATOR (LOOP-DECREMENT-TOS LOOP-INCREMENT-TOS-LESS-THAN)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (PUSH (CONS (+ (SIGN-EXTEND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS) 10.)
		 RELATIVE-PC)
	      STACK-DESCRIPTION)
	(LOCATION-CONTENTS PENDING-PCS-LOC))
  STACK-DESCRIPTION)

;;; 116
(DEFINE-EMULATOR (%MEMORY-READ %MEMORY-READ-ADDRESS
			LDB CHAR-LDB %P-LDB %P-TAG-LDB TYPE-MEMBER)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  STACK-DESCRIPTION)

;;; 120
(DEFINE-EMULATOR (%BLOCK-0-READ-TEST %BLOCK-1-READ-TEST %BLOCK-2-READ-TEST %BLOCK-3-READ-TEST)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  ;; SP|0 or SP|-1 should be a PC.
  (LET* ((STACK (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
	 (PC
	   (BLOCK PC
	     (LET ((ENTRY (FIRST STACK)))
	       (WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':PC)
		 (RETURN-FROM PC (STACK-ENTRY-VALUE ENTRY))))
	     (LET ((ENTRY (SECOND STACK)))
	       (WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':PC)
		 (RETURN-FROM PC (STACK-ENTRY-VALUE ENTRY)))))))
    (WHEN PC
      (PUSH (CONS PC STACK-DESCRIPTION)
	    (LOCATION-CONTENTS PENDING-PCS-LOC)))
    STACK-DESCRIPTION))

;;; 128
(DEFINE-EMULATOR (START-CALL)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET ((POP-P (= (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)
		  (DPB STACK-ADDRESSING-MODE-STACK-POINTER
		       %%PACKED-INSTRUCTION-ADDRESSING-MODE 0)))
	(STACK (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))
    (OR (WHEN POP-P
	  (LET ((ENTRY (FIRST STACK)))
	    (MULTIPLE-VALUE-BIND (VALUE EXISTS-P) (STACK-ENTRY-VALUE ENTRY)
	      (WHEN EXISTS-P
		(IF (EQ (STACK-ENTRY-TYPE ENTRY) ':EVCP)
		    (PUSH-START-CALL (POP-N STACK-DESCRIPTION 1) VALUE)
		    (AND (TYPEP VALUE :COMPILED-FUNCTION)
			 (MAKE-STACK-DESCRIPTION
			   :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) -1 2)
			   :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
			   :STACK
			   (LIST*
			     (MAKE-STACK-ENTRY :CONTROL '.SAVED-CONTROL-REGISTER. NIL NIL)
			     (MAKE-STACK-ENTRY :FRAME '.SAVED-CONTINUATION-REGISTER. NIL NIL)
			     (CDR (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))))))))
	(MAKE-STACK-DESCRIPTION
	  :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) (IF POP-P -1 0) 3)
	  :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	  :STACK (LIST*
		   (MAKE-STACK-ENTRY :EXTRA-ARG NIL NIL NIL)
		   (MAKE-STACK-ENTRY :CONTROL '.SAVED-CONTROL-REGISTER. NIL NIL)
		   (MAKE-STACK-ENTRY :FRAME '.SAVED-CONTINUATION-REGISTER. NIL NIL)
		   (IF POP-P
		       (CDR (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
		       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))))))

;;; 129
(DEFINE-EMULATOR (FINISH-CALL-N FINISH-CALL-N-APPLY FINISH-CALL-TOS FINISH-CALL-TOS-APPLY)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET* ((DISPOSITION (LDB (BYTE 2. 8.) INSTRUCTION-BITS))
	 (SP (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	 (LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION))
	 (STACK (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
	 (POPPED-STACK STACK)
	 (POPPED-SP SP))
    ;; Find the frame for this call
    (LOOP NAMED DO-CALL DOING
      (LET ((ENTRY (POP POPPED-STACK)))
	(WHEN (NULL POPPED-STACK)
	  ;; This can happen if phase-3 doesn't know it can delete the entire call
	  ;(FORMAT T "~&Finish call with no start call at ~o" RELATIVE-PC)
	  (RETURN-FROM DO-CALL NIL))
	(DECF POPPED-SP)
	(WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':FRAME)
	  ;; Found it
	  (MULTIPLE-VALUE-BIND (FUNCTION FUNCTION-P) (STACK-ENTRY-VALUE ENTRY)
	    (LET ((NAME (AND FUNCTION-P
			     (TYPECASE FUNCTION
			       (:COMPILED-FUNCTION (FUNCTION-NAME FUNCTION))
			       (:SYMBOL FUNCTION)
			       (OTHERWISE NIL)))))
	      (WHEN NAME
		(SELECTQ NAME
		  (SI:ABORT-CALL-0
		   ;; Pop back to the next frame
		   (LOOP DOING
		     (LET ((ENTRY (POP POPPED-STACK)))
		       (WHEN (NULL POPPED-STACK)
			 ;; This can happen if phase-3 doesn't know it can delete the
			 ;; entire call
			 ;(FORMAT T "~&ABORT-CALL-0 with no start call at ~o" RELATIVE-PC)
			 (RETURN-FROM DO-CALL NIL))
		       (DECF POPPED-SP)
		       (WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':FRAME)
			 (LET ((STACK-DESCRIPTION (MAKE-STACK-DESCRIPTION
						    :SP POPPED-SP
						    :STACK POPPED-STACK
						    :LP LP)))
			   (RETURN-FROM DO-CALL
			     (VALUES
			       (SELECT DISPOSITION
				 (VALUE-DISPOSITION-EFFECT STACK-DESCRIPTION)
				 (VALUE-DISPOSITION-RETURN NIL)
				 (OTHERWISE
				  (FERROR "Bad disposition")))
			       STACK-DESCRIPTION)))))))
		  (SI:ABORT-CALL-1
		   ;; TOS now contains the value to return
		   (LET ((RETURN (POP POPPED-STACK)))
		     (DECF POPPED-SP)
		     (LOOP DOING
		       (LET ((ENTRY (POP POPPED-STACK)))
			 (WHEN (NULL POPPED-STACK)
			   ;; This can happen if phase-3 doesn't know it can delete
			   ;; the call
			   ;(FORMAT T "~&ABORT-CALL-1 with no start call at ~o" RELATIVE-PC)
			   (RETURN-FROM DO-CALL NIL))
			 (DECF POPPED-SP)
			 (WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':FRAME)
			   (LET ((STACK-DESCRIPTION (MAKE-STACK-DESCRIPTION
						      :SP POPPED-SP
						      :STACK POPPED-STACK
						      :LP LP)))
			     (RETURN-FROM DO-CALL
			       (VALUES
				 (SELECT DISPOSITION
				   (VALUE-DISPOSITION-VALUE
				    (MAKE-STACK-DESCRIPTION
				      :SP (1+ POPPED-SP)
				      :STACK (CONS RETURN POPPED-STACK)
				      :LP LP))
				   (VALUE-DISPOSITION-RETURN NIL)
				   (OTHERWISE (FERROR "Bad disposition")))
				 STACK-DESCRIPTION))))))))
		  (SI:ABORT-CALL-MULTIPLE
		   ;; There is now a M-V-G on the top of the stack.  To keep things
		   ;; simple, we'll just pop back to our caller and leave an M-V-G on
		   ;; top of the stack.
		   (LOOP DOING
		     (LET ((ENTRY (POP POPPED-STACK)))
		       (DECF POPPED-SP)
		       (WHEN (NULL POPPED-STACK)
			 ;; This can happen if phase-3 doesn't know it can delete the
			 ;; entire call
			 ;(FORMAT T "~&ABORT-CALL-MULTIPLE with no start call at ~o"
			 ;        RELATIVE-PC)
			 (RETURN-FROM DO-CALL NIL))
		       (WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':FRAME)
			 (LET ((STACK-DESCRIPTION (MAKE-STACK-DESCRIPTION :SP POPPED-SP
									  :STACK POPPED-STACK
									  :LP LP)))
			   (RETURN-FROM DO-CALL
			     (VALUES
			       (SELECT DISPOSITION
				 (VALUE-DISPOSITION-MULTIPLE
				  (PUSH-VALUE STACK-DESCRIPTION :MVG NIL 0))
				 (VALUE-DISPOSITION-RETURN NIL)
				 (OTHERWISE (FERROR "Bad disposition")))
			       STACK-DESCRIPTION)))))))))
	      ;; Just an ordinary function call, so leave the appropriate thing on
	      ;; the stack
	      (LET ((STACK-DESCRIPTION (MAKE-STACK-DESCRIPTION
					 :SP POPPED-SP
					 :STACK POPPED-STACK
					 :LP LP)))
		(RETURN-FROM DO-CALL
		  (VALUES
		    (LET ((N-VALUES (FIRST (LOCATION-CONTENTS NAMES-LOC))))
		      (COND ((FIXNUMP N-VALUES)
			     (POP (LOCATION-CONTENTS NAMES-LOC))
			     (PUSH-N STACK-DESCRIPTION N-VALUES))
			    (T (SELECT DISPOSITION
				 (VALUE-DISPOSITION-RETURN NIL)
				 (VALUE-DISPOSITION-EFFECT STACK-DESCRIPTION)
				 (VALUE-DISPOSITION-VALUE
				  (PUSH-VALUE STACK-DESCRIPTION NIL NIL))
				 (VALUE-DISPOSITION-MULTIPLE
				  (PUSH-VALUE STACK-DESCRIPTION :MVG NIL 0))))))
		    STACK-DESCRIPTION))))))))))

;;; 137 LOCATE-LOCALS with PUSH-GLOBAL-LOGIC-VARIABLE

;;; 140
(DEFINE-EMULATOR (RETURN-KLUDGE RETURN-MULTIPLE RETURN-SINGLE
		  %GENERIC-DISPATCH %MESSAGE-DISPATCH)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  NIL)

;;; 141
(DEFINE-EMULATOR (TAKE-VALUES)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET* ((N (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION-BITS))
	 (TOP-OF-STACK (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION 0))
	 (POPPED
	   (SELECT (STACK-ENTRY-TYPE TOP-OF-STACK)
	     ((:CONSTANT :MVG)
	      (LET ((VALUE (STACK-ENTRY-VALUE TOP-OF-STACK)))
		(AND (NUMBERP VALUE)
		     (POP-N STACK-DESCRIPTION (1+ VALUE)))))
	     (OTHERWISE NIL))))
    (LET* ((NAMES (LOCATION-CONTENTS NAMES-LOC))
	   (LENGTH (LENGTH NAMES)))
      ;; If there aren't enough names, pad with NIL.  Too many is okay, since
      ;; NAMEs are permitted to be merged.
      (WHEN (< LENGTH N)
	(SETF (LOCATION-CONTENTS NAMES-LOC)
	      (APPEND NAMES (MAKE-LIST (- N LENGTH))))))
    (WHEN POPPED
      (PUSH-N POPPED N))))

;;; 146
(DEFINE-EMULATOR (CATCH-OPEN)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (LET ((TOP-OF-STACK (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION 0)))
    (IF (ZEROP (LDB (BYTE 1 0) INSTRUCTION-BITS))
	(LET ((DISPOSITION (LDB (BYTE 2. 6.) INSTRUCTION-BITS)))
	  (WHEN (EQ (STACK-ENTRY-TYPE TOP-OF-STACK) ':PC)
	    (LET* ((STACK-DESCRIPTION (POP-N STACK-DESCRIPTION 2))
		   (NEW-DESCRIPTION
		    (SELECT DISPOSITION
		      (VALUE-DISPOSITION-VALUE (PUSH-N STACK-DESCRIPTION 1))
		      (VALUE-DISPOSITION-MULTIPLE
		       (MAKE-STACK-DESCRIPTION
			 :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 1.)
			 :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
			 :STACK (LIST* (MAKE-STACK-ENTRY :MVG NIL 0 T)
				       (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))
		      (VALUE-DISPOSITION-EFFECT STACK-DESCRIPTION)
		      (VALUE-DISPOSITION-RETURN NIL))))
	      (WHEN NEW-DESCRIPTION
		(PUSH (CONS (STACK-ENTRY-VALUE TOP-OF-STACK) NEW-DESCRIPTION)
		      (LOCATION-CONTENTS PENDING-PCS-LOC)))))
	  (MAKE-STACK-DESCRIPTION
	    :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 3.)
	    :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
	    :STACK (LIST* (MAKE-STACK-ENTRY :CATCH 'CATCH-OPEN NIL NIL)
			  NIL
			  NIL
			  (STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))) 
	(LET ((NEW-STACK-DESCRIPTION
		(MAKE-STACK-DESCRIPTION
		  :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 2.)
		  :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
		  :STACK (LIST* (MAKE-STACK-ENTRY :CATCH 'UNWIND-PROTECT-OPEN NIL NIL)
				NIL
				(STACK-DESCRIPTION-STACK STACK-DESCRIPTION)))))
	  ;; Push the stack description appropriate for a normal exit
	  (WHEN (EQ (STACK-ENTRY-TYPE TOP-OF-STACK) ':PC)
	    (PUSH (CONS (STACK-ENTRY-VALUE TOP-OF-STACK) NEW-STACK-DESCRIPTION)
		  (LOCATION-CONTENTS PENDING-PCS-LOC)))
	  NEW-STACK-DESCRIPTION))))

;;; 147
(DEFINE-EMULATOR (CATCH-CLOSE)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  STACK-DESCRIPTION)

;;; 168
(DEFINE-EMULATOR (%POINTER-PLUS)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (LET* ((OFFSET (IF (EQ OFFSET-OR-VALUE :POP) 2 1))
	   (NAME (NAME-ON-STACK STACK-DESCRIPTION (1- OFFSET))))
      (BLOCK %POINTER-PLUS
	(WHEN (EQ MODE :IMMEDIATE)
	  (LET ((POINTER (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION 0)))
	    (WHEN (EQ (STACK-ENTRY-TYPE POINTER) ':STACK-ADDRESS)
	      (RETURN-FROM %POINTER-PLUS
		(PUSH-VALUE (POP-N STACK-DESCRIPTION 1)
			    :STACK-ADDRESS
			    NAME
			    (+ (STACK-ENTRY-VALUE POINTER) OFFSET-OR-VALUE))))))
	(LET ((STACK-DESCRIPTION (PUSH-N (POP-N STACK-DESCRIPTION OFFSET) 1)))
	  (WHEN NAME
	    (SETF (NAME-ON-STACK STACK-DESCRIPTION) NAME))
	  STACK-DESCRIPTION)))))

;;; 185 %GENERIC-DISPATCH with RETURN
;;; 186 %MESSAGE-DISPATCH with RETURN

;;; 187
(DEFINE-EMULATOR (%JUMP)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (DECLARE (IGNORE MODE))
    (WHEN (EQ (STACK-ENTRY-TYPE ENTRY) ':PC)
      (PUSH (CONS (STACK-ENTRY-VALUE ENTRY)
		  (IF (EQ OFFSET-OR-VALUE :POP)
		      (POP-N STACK-DESCRIPTION 1)
		      STACK-DESCRIPTION))
	    (LOCATION-CONTENTS PENDING-PCS-LOC)))
    NIL))

;;; 188
(DEFINE-EMULATOR (NO-OP %HALT %CHECK-PREEMPT-REQUEST)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  STACK-DESCRIPTION)

;;; 370
(DEFINE-EMULATOR (DPB CHAR-DPB %WRITE-INTERNAL-REGISTER %COPROCESSOR-WRITE)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (POP-N STACK-DESCRIPTION 1))

;;; 372
(DEFINE-EMULATOR (%P-DPB %P-TAG-DPB)
		 (INSTRUCTION-BITS STACK-DESCRIPTION RELATIVE-PC NAMES-LOC PENDING-PCS-LOC)
  (POP-N STACK-DESCRIPTION 2))


(DEFUN COMPUTE-STACK-DESCRIPTION (FUNCTION)
  (LET* ((CCA (COMPILED-FUNCTION-CCA FUNCTION))
	 (DEBUG-INFO (DEBUGGING-INFO FUNCTION))
	 (VCA (CDR (ASSOC ':VARIABLE-CREATION-ALIST DEBUG-INFO)))
	 (LAST-NAMES-VCA NIL)
	 (INSTRUCTION-WORDS (- (CCA-TOTAL-SIZE CCA)
			       (CCA-SUFFIX-SIZE CCA)
			       (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
	 (N-INSTRUCTIONS (* INSTRUCTION-WORDS 2))
	 (BASE-ADDRESS (%MAKE-POINTER DTP-LOCATIVE FUNCTION))
	 (DISASSEMBLE-ARRAY (MAKE-ARRAY N-INSTRUCTIONS))
	 (DEBUG-ALIST NIL)
	 (REMAINING-PCS (LIST (CONS 0 (MAKE-STACK-DESCRIPTION))))
	 (OPDESCS *OPDESC-ARRAY*))
    (DECLARE (ARRAY-REGISTER OPDESCS))
    (LOOP WHILE REMAINING-PCS DOING
      (LET* ((REMAINING-PC (POP REMAINING-PCS))
	     (RELATIVE-PC (CAR REMAINING-PC))
	     (STACK-DESCRIPTION (CDR REMAINING-PC))
	     (LAST-NAMES (CDR (ASSOC RELATIVE-PC LAST-NAMES-VCA))))
	(UNLESS (AREF DISASSEMBLE-ARRAY RELATIVE-PC)
	  (LOOP NAMED PROCESS-PATH DOING
	    (WHEN ( RELATIVE-PC N-INSTRUCTIONS)
	      (RETURN-FROM PROCESS-PATH))
	    (LET ((DESCRIPTION (AREF DISASSEMBLE-ARRAY RELATIVE-PC)))
	      (WHEN DESCRIPTION
		(STACK-DESCRIPTION-NAME-VARIABLES DESCRIPTION LAST-NAMES)
		(RETURN-FROM PROCESS-PATH)))
	    (STACK-DESCRIPTION-NAME-VARIABLES STACK-DESCRIPTION LAST-NAMES)
	    (WHEN (AREF DISASSEMBLE-ARRAY RELATIVE-PC)
	      (RETURN-FROM PROCESS-PATH))
	    (SETF (AREF DISASSEMBLE-ARRAY RELATIVE-PC) STACK-DESCRIPTION)
	    ;(FORMAT T "~%~o ~s" RELATIVE-PC (STACK-DESCRIPTION-SP STACK-DESCRIPTION))
	    (LET* ((INSTRUCTION
		     (%MEMORY-READ
		       (%POINTER-PLUS BASE-ADDRESS (LDB (BYTE 31. 1.) RELATIVE-PC))
		       :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))
		   (TYPE (%DATA-TYPE INSTRUCTION))
		   (SEQUENCING
		     (SELECT (LDB %%Q-CDR-CODE-WITHIN-TAG (%TAG INSTRUCTION))
		       (SEQUENCING-PC+1 1)
		       (SEQUENCING-FENCE
			(FORMAT T "~&Warning:  Sequencing fence encountered")
			(RETURN-FROM PROCESS-PATH))
		       (SEQUENCING-PC-1 -1)
		       (SEQUENCING-PC-EVEN+2-ODD+3
			(+ 2 (LDB (BYTE 1 0) RELATIVE-PC)))))
		   (NAMES (CDR (CL:ASSOC RELATIVE-PC VCA))))
	      (BLOCK PROCESS-INSTRUCTION
		(TAGBODY 
		  BREAKPOINT-RESTART
		     (WHEN ( TYPE DTP-PACKED-INSTRUCTION-60)
		       (LET* ((INSTRUCTION-BITS
				(IF (EVENP RELATIVE-PC)
				    (%SET-TAG INSTRUCTION DTP-FIXNUM)
				    (DPB TYPE %%ODD-INSTRUCTION-TAG-COMPONENT
					 (LDB %%Q-ODD-INSTRUCTION-WITHIN-POINTER
					      (%SET-TAG INSTRUCTION DTP-FIXNUM)))))
			      (OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
			      (OPDESC (AREF OPDESCS OPCODE)))
			 (WHEN (EQL #.(ILC:OPCODE-FOR-INSTRUCTION '%PROC-BREAKPOINT) OPCODE)
			   (LET ((BPT-INFO
				   (ANY-BREAKPOINT-IN-FUNCTION FUNCTION RELATIVE-PC)))
			     (SETF INSTRUCTION (DBG:BPT-INSTRUCTION BPT-INFO))
			     (SETF TYPE (DBG:BPT-DATA-TYPE BPT-INFO)))
			   (GO BREAKPOINT-RESTART))
			 (SELECT (LDB %%OPDESC-CLASS OPDESC)
			   (OPDESC-CLASS-ENTRY
			    (WHEN (ODDP RELATIVE-PC)
			      ;; Entry instructions aren't allowed in odd PCs, so something
			      ;; has gone wrong.  Stop computing stack information on this
			      ;; path.
			      (FORMAT T "~&Warning:  Entry instruction at odd PC ~o" RELATIVE-PC)
			      (RETURN-FROM PROCESS-PATH))
			    (LET ((MIN (LDB %%ENTRY-INSTRUCTION-MIN INSTRUCTION-BITS))
				  (MAX (LDB %%ENTRY-INSTRUCTION-MAX INSTRUCTION-BITS)))
			      (SETQ STACK-DESCRIPTION
				    (MAKE-STACK-DESCRIPTION
				      :SP (1- MIN)
				      :LP MAX
				      :STACK (LET* ((LIST (MAKE-LIST MIN))
						    (LAST-2 (NTHCDR (- MIN 2) LIST)))
					       (SETF (CAR LAST-2) '.SAVED-CONTROL-REGISTER.)
					       (SETF (CADR LAST-2) '.SAVED-CONTINUATION-REGISTER.)
					       LIST)))
			      (SETF (AREF DISASSEMBLE-ARRAY RELATIVE-PC) STACK-DESCRIPTION)))
			   (OPDESC-CLASS-OPERAND-FROM-STACK
			    (LET* ((OFFSET (+ (1- (LDB %%OPDESC-OPERAND-FROM-STACK-N-POPPED
						       OPDESC))
					      (IF (= (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND
							  INSTRUCTION-BITS)
						     (DPB STACK-ADDRESSING-MODE-STACK-POINTER
							  %%PACKED-INSTRUCTION-ADDRESSING-MODE
							  0))
						  1
						  0)))
				   (RETURNED
				     (LDB %%OPDESC-OPERAND-FROM-STACK-N-RETURNED OPDESC))
				   (NAME (WHEN (AND (> OFFSET 0)
						    (= RETURNED 1))
					   (NAME-ON-STACK STACK-DESCRIPTION (1- OFFSET)))))
			      (SETQ STACK-DESCRIPTION
				    (PUSH-N (POP-N STACK-DESCRIPTION OFFSET) RETURNED))
			      (WHEN NAME
				(SETF (NAME-ON-STACK STACK-DESCRIPTION) NAME))))
			   (OPDESC-CLASS-EMULATE
			    (MULTIPLE-VALUE-BIND (NEW-STACK-DESCRIPTION DEBUG-STACK-DESCRIPTION)
				(FUNCALL (AREF *EMULATE-ARRAY* OPCODE)
					 INSTRUCTION-BITS STACK-DESCRIPTION
					 RELATIVE-PC (LOCF NAMES) (LOCF REMAINING-PCS))
			      (WHEN DEBUG-STACK-DESCRIPTION
				(PUSH (CONS (+ RELATIVE-PC SEQUENCING) DEBUG-STACK-DESCRIPTION)
				      DEBUG-ALIST))
			      (COND ((SETQ STACK-DESCRIPTION NEW-STACK-DESCRIPTION)
				     (RETURN-FROM PROCESS-INSTRUCTION))
				    (T
				     (WHEN NAMES
				       ;; This can only happen on entry instructions.
				       ;; In this case, we have to resort to a kludge
				       ;; to relocate the names to the next PC.
				       (PUSH (CONS (+ RELATIVE-PC 2) NAMES)
					     LAST-NAMES-VCA))
				     (RETURN-FROM PROCESS-PATH)))))
			   (OTHERWISE
			    (FORMAT T "~&Warning:  Unknown opcode ~o at PC ~o"
				    OPCODE RELATIVE-PC)
			    (RETURN-FROM PROCESS-PATH))))
		       (RETURN-FROM PROCESS-INSTRUCTION)))
		(WHEN (TYPE-MEMBER INSTRUCTION DTP-EXTERNAL-VALUE-CELL-POINTER)
		  (SETQ STACK-DESCRIPTION
			(PUSH-VALUE STACK-DESCRIPTION
				    :EVCP NIL
				    (%MAKE-POINTER DTP-LOCATIVE INSTRUCTION)))
		  (RETURN-FROM PROCESS-INSTRUCTION))
		(WHEN (TYPE-MEMBER INSTRUCTION DTP-EVEN-PC DTP-ODD-PC)
		  (SETQ STACK-DESCRIPTION
			(IF (AND (%POINTER-LESSP BASE-ADDRESS INSTRUCTION)
				 (%UNSIGNED-LESSP
				   (%POINTER-DIFFERENCE INSTRUCTION BASE-ADDRESS)
				   INSTRUCTION-WORDS))
			    (PUSH-VALUE
			      STACK-DESCRIPTION
			      :PC
			      NIL
			      (+ (* (%POINTER-DIFFERENCE INSTRUCTION BASE-ADDRESS) 2)
				 (IF (TYPE-MEMBER INSTRUCTION DTP-EVEN-PC)
				     0
				     1)))
			    (PUSH-N STACK-DESCRIPTION 1)))
		  (RETURN-FROM PROCESS-INSTRUCTION))
		(WHEN (TYPE-MEMBER INSTRUCTION
				   DTP-CALL-COMPILED-EVEN DTP-CALL-COMPILED-EVEN-PREFETCH
				   DTP-CALL-COMPILED-ODD DTP-CALL-COMPILED-ODD-PREFETCH)
		  ;; If this is our own function, then we have to take a look at the
		  ;; relevant PCs.
		  (WHEN (AND (%POINTER-LESSP BASE-ADDRESS INSTRUCTION)
			     (%UNSIGNED-LESSP (%POINTER-DIFFERENCE INSTRUCTION BASE-ADDRESS)
					      INSTRUCTION-WORDS))
		    (LET ((PC (+ (* (%POINTER-DIFFERENCE INSTRUCTION BASE-ADDRESS) 2)
				 (IF (TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN
						  DTP-CALL-COMPILED-EVEN-PREFETCH)
				     0
				     1))))
		      (UNLESS (AREF DISASSEMBLE-ARRAY PC)
			(PUSH (CONS PC (MAKE-STACK-DESCRIPTION)) REMAINING-PCS))))
		  (SETQ STACK-DESCRIPTION
			(MAKE-STACK-DESCRIPTION
			  :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 2)
			  :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
			  :STACK (LIST*
				   (MAKE-STACK-ENTRY NIL '.SAVED-CONTROL-REGISTER. NIL NIL)
				   (MAKE-STACK-ENTRY :FRAME '.CONTINUATION-REGISTER.
						     (%FIND-STRUCTURE-HEADER INSTRUCTION)
						     T)
				   (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))
		  (RETURN-FROM PROCESS-INSTRUCTION))
		(WHEN (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH)
		  (SETQ STACK-DESCRIPTION
			(PUSH-START-CALL
			  STACK-DESCRIPTION (%MAKE-POINTER DTP-LOCATIVE INSTRUCTION)))
		  (RETURN-FROM PROCESS-INSTRUCTION))
		(WHEN (TYPE-MEMBER INSTRUCTION DTP-CALL-GENERIC DTP-CALL-GENERIC-PREFETCH)
		  (SETQ STACK-DESCRIPTION
			(MAKE-STACK-DESCRIPTION
			  :SP (+ (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 3)
			  :LP (STACK-DESCRIPTION-LP STACK-DESCRIPTION)
			  :STACK (LIST*
				   (MAKE-STACK-ENTRY :EXTRA-ARG NIL NIL NIL)
				   (MAKE-STACK-ENTRY NIL '.SAVED-CONTROL-REGISTER. NIL NIL)
				   (MAKE-STACK-ENTRY :FRAME '.CONTINUATION-REGISTER.
						     (%FIND-STRUCTURE-HEADER INSTRUCTION)
						     T)
				   (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))))
		  (RETURN-FROM PROCESS-INSTRUCTION))
		#+VLM
		(WHEN (TYPE-MEMBER INSTRUCTION AXPI::*NATIVE-INSTRUCTION-OPCODE*)
		  ;; A native-mode-instruction.  All we really care
		  ;; about is maintaining sp level.  --- Some day we may
		  ;; be smart enough to maintain the names?
		  (LET ((BRANCH-TARGET-DESCRIPTION (CDR (ASSOC RELATIVE-PC REMAINING-PCS))))
		    ;; We are the target of a branch.  The stack
		    ;; emulator will have foolishly emulated the
		    ;; fall-through path already, so we need to reset
		    ;; our stack description to emulate the branch-taken
		    ;; path
		    (WHEN BRANCH-TARGET-DESCRIPTION
		      (SETF STACK-DESCRIPTION BRANCH-TARGET-DESCRIPTION)))
		  (MULTIPLE-VALUE-BIND (STACK-ADJUSTMENT PC-ADJUSTMENT)
		      (AXPI::EMULATE-NATIVE-INSTRUCTION (%POINTER INSTRUCTION))
		    (COND
		      ((NULL STACK-ADJUSTMENT))
		      ((PLUSP STACK-ADJUSTMENT)
		       (SETQ STACK-DESCRIPTION
			     (PUSH-N STACK-DESCRIPTION STACK-ADJUSTMENT)))
		      ((MINUSP STACK-ADJUSTMENT)
		       (SETQ STACK-DESCRIPTION
			     (POP-N STACK-DESCRIPTION (- STACK-ADJUSTMENT)))))
		    (WHEN PC-ADJUSTMENT
		      (PUSH (CONS (+ RELATIVE-PC PC-ADJUSTMENT) STACK-DESCRIPTION)
			    REMAINING-PCS))
		    (RETURN-FROM PROCESS-INSTRUCTION)
		    ))
		(SETQ STACK-DESCRIPTION
		      (PUSH-VALUE STACK-DESCRIPTION :CONSTANT NIL INSTRUCTION)))
	      (SETQ LAST-NAMES NAMES)
	      (INCF RELATIVE-PC SEQUENCING))))))
    (VALUES DISASSEMBLE-ARRAY DEBUG-ALIST)))


(DEFVAR *FUNCTION-BEING-DISASSEMBLED*)

;;; New disassembler
(DEFUN PRINT-PC-AND-SEQUENCING (STREAM RELATIVE-PC SEQUENCING
				&OPTIONAL BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE SEQUENCING))
  ;; only print pc DUMMY is a place holder
  (PRESENT `(,*FUNCTION-BEING-DISASSEMBLED* ,RELATIVE-PC)
	   `((COMPILER:COMPILED-FUNCTION-AND-PC)
	     :PC-ONLY T :BPT ,BREAKPOINT-INSTRUCTION-P) :STREAM STREAM))

(DEFUN DISASSEMBLE-PRINT-FUNCTION-OBJECT (FSPEC &OPTIONAL (STREAM STANDARD-OUTPUT))
  (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
				   :OBJECT (OR (SI:VALID-FUNCTION-DEFINITION FSPEC T)
					       FSPEC)
				   :TYPE 'SYS:FUNCTION)
    (FORMAT STREAM "#'")
    (PRESENT FSPEC 'SYS:FUNCTION-SPEC :STREAM STREAM)))

(DEFUN DISASSEMBLE-PRINT-COMMENT (STREAM LEXICAL INSTANCE ADDRESS-OPERAND CREATES)
  (WHEN (OR LEXICAL INSTANCE ADDRESS-OPERAND CREATES)
    (FORMAT STREAM "~40,8T;~:[~2*~;~@\presentation\ ~]~
                           ~:[~2*~;~@\presentation\ ~]"
	    LEXICAL LEXICAL 'SYS:FORM
	    INSTANCE INSTANCE 'SYS:FORM)
    (WHEN ADDRESS-OPERAND
      (IF (LISTP ADDRESS-OPERAND)
	  (DISASSEMBLE-PRINT-FUNCTION-OBJECT (CAR ADDRESS-OPERAND) STREAM)
	  (FORMAT STREAM "~@\presentation\" ADDRESS-OPERAND 'SYS:FORM))
      (CL:WRITE-CHAR #\SPACE STREAM))
    (WHEN CREATES
      (WHEN (OR LEXICAL INSTANCE ADDRESS-OPERAND)
	(CL:WRITE-STRING "   " STREAM))
      (CL:WRITE-STRING "Creating " STREAM)
      (FORMAT-TEXTUAL-LIST
	CREATES
	#'(LAMBDA (X STREAM)
	    (IF (LISTP X)
		(DISASSEMBLE-PRINT-FUNCTION-OBJECT (CAR X) STREAM)
		(FORMAT STREAM "~@\presentation\" X 'SYS:FORM)))
	:CONJUNCTION "and"
	:STREAM STREAM))))

(DEFUN PACKED-PRINT-PC-AND-SEQUENCING (STREAM RELATIVE-PC INCREMENT
				&OPTIONAL BREAKPOINT-INSTRUCTION-P)
  (PRINT-PC-AND-SEQUENCING
    STREAM
    RELATIVE-PC
    (SELECTQ INCREMENT
      (-1 "-  ")
      (1 "   ")
      (2 "++ ")
      (3 "+++"))
    BREAKPOINT-INSTRUCTION-P))

(DEFUN DEFAULT-DISASSEMBLER (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (PRINC (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)) STREAM)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (IF (EQ MODE :IMMEDIATE)
	(FORMAT STREAM " ~s" OFFSET-OR-VALUE)
	(FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE))
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))

(DEFUN REGISTER-NAME-FROM-ADDRESS (ADDRESS &OPTIONAL (RWMODE :READ))
  (AREF (IF (EQ RWMODE :READ)
	    *INTERNAL-READABLE-REGISTER-MAP*
	    *INTERNAL-WRITABLE-REGISTER-MAP*)
	ADDRESS))

(DEFSUBST BLOCK-READ-COMPONENTS (INSTRUCTION-BITS)
  (DECLARE (VALUES CYCLE-NAME FIXNUM-ONLY INHIBIT-PREFETCH NO-INCREMENT))
  (VALUES (NTH (LDB %%MEMORY-CYCLE-TYPE INSTRUCTION-BITS) *MEMORY-CYCLE-TYPES*)
	  (PLUSP (LDB %%MEMORY-FIXNUM-ONLY INSTRUCTION-BITS))
	  (PLUSP (LDB %%MEMORY-LAST-WORD INSTRUCTION-BITS))
	  (PLUSP (LDB %%MEMORY-NO-INCREMENT INSTRUCTION-BITS))))

(DEFCONST *DISASSEMBLERS* (MAKE-ARRAY 256. :INITIAL-VALUE 'DEFAULT-DISASSEMBLER))

(DEFMACRO DEFINE-DISASSEMBLER (INSTRUCTIONS ARGUMENTS &BODY BODY)
  `(PROGN (DEFUN (:PROPERTY ,(FIRST INSTRUCTIONS) DISASSEMBLE)
		 ,ARGUMENTS
	    ,@BODY)
	  ,@(LOOP FOR INSTRUCTION IN INSTRUCTIONS
		  APPEND
		  (LOOP FOR I FROM 0 BELOW 256.
			WHEN (EQ INSTRUCTION (GET-OPCODE-PRETTY-NAME I))
			  COLLECT			
			    `(SETF (AREF *DISASSEMBLERS* ,I)
				   #'(:PROPERTY ,(FIRST INSTRUCTIONS) DISASSEMBLE))))))

;;; 13
(DEFINE-DISASSEMBLER (PUSH-GLOBAL-LOGIC-VARIABLE LOCATE-LOCALS NO-OP %HALT
		      %CHECK-PREEMPT-REQUEST %GENERIC-DISPATCH %MESSAGE-DISPATCH)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (PRINC (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)) STREAM)
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 27
(DEFINE-DISASSEMBLER (TYPE-MEMBER TYPE-MEMBER-NO-POP)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (LET* ((N (LDB %%PACKED-INSTRUCTION-TYPE-MEMBER-N INSTRUCTION-BITS))
	 (BACKGROUND (LDB %%PACKED-INSTRUCTION-TYPE-MEMBER-BACKGROUND INSTRUCTION-BITS))
	 (OPERAND (DPB N (BYTE (BYTE-SIZE %%PACKED-INSTRUCTION-TYPE-MEMBER-N)
			       (BYTE-SIZE %%PACKED-INSTRUCTION-TYPE-MEMBER-BACKGROUND))
		       BACKGROUND))
	 (PAIR (CL:ASSOC OPERAND *TYPE-MEMBER-NAME-ALIST*))
	 (OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	 (NO-POP-P (= (DPB 0 (BYTE 2 0) OPCODE) *TYPE-MEMBER-NO-POP-OPCODE*)))
    (COND (PAIR (CL:WRITE-STRING (CDR PAIR) STREAM)
		(WHEN NO-POP-P
		  (CL:WRITE-STRING "-NO-POP" STREAM)))
	  (T (FORMAT STREAM "TYPE-MEMBER~:[~;-NO-POP~] (" NO-POP-P)
	     (LET ((4N (* 4 N))
		   (MASK 1)
		   (FIRST T))
	       (DOTIMES (I 8)
		 (UNLESS (ZEROP (LOGAND MASK BACKGROUND))
		   (IF FIRST (SETQ FIRST NIL) (CL:WRITE-STRING " " STREAM))
		   (CL:WRITE-STRING (CL:SYMBOL-NAME (NTH (MOD (+ 4N I) 64.)
							 *DATA-TYPES*))
				    STREAM))
		 (SETQ MASK (LSH MASK 1)))
	       (CL:WRITE-STRING ")" STREAM)))))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))


;;; 32
(DEFINE-DISASSEMBLER (ZEROP)
		  (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			  NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (IF (EQ MODE :IMMEDIATE)
	(FORMAT STREAM "PUSH ~@\presentation\" (ZEROP OFFSET-OR-VALUE))
	(FORMAT STREAM "ZEROP ~a|~a" MODE OFFSET-OR-VALUE))
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))

;;; 63
(DEFINE-DISASSEMBLER (MOVEM)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (COND ((EQ MODE :IMMEDIATE)
	   (FORMAT STREAM "MOVEM (illegal) ~s" OFFSET-OR-VALUE))
	  ((AND (EQ MODE :SP)
		(EQL OFFSET-OR-VALUE 0))
	   (FORMAT STREAM "FIXUP-TOS"))
	  (T
	   (FORMAT STREAM "MOVEM ~a|~a" MODE OFFSET-OR-VALUE)))
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))

;; 66, 67
(DEFINE-DISASSEMBLER (SET-SP-TO-ADDRESS SET-SP-TO-ADDRESS-SAVE-TOS)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (PRINC (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)) STREAM)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (IF (EQ MODE :IMMEDIATE)
	(FORMAT STREAM " ~s" OFFSET-OR-VALUE)
	(FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE)))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 71
(DEFINE-DISASSEMBLER (LDB CHAR-LDB %P-LDB %P-TAG-LDB)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (LET ((SIZE (1+ (LDB %%PACKED-INSTRUCTION-BYTE-SIZE-1 INSTRUCTION-BITS)))
	(ROTATION (LDB %%PACKED-INSTRUCTION-BYTE-ROTATION INSTRUCTION-BITS))
	(OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)))
    (IF (AND (= OPCODE *LDB-OPCODE*) (= SIZE #O40) ( ROTATION 0))
	(FORMAT STREAM "ROT ~S~40,8T;Strange LDB"
		(%LOGDPB (- (LDB (BYTE 1 4) ROTATION)) (BYTE 27. 5) ROTATION))
	(FORMAT STREAM "~a (Byte ~a ~a)"
		(GET-OPCODE-PRETTY-NAME OPCODE)
		SIZE
		(LDB (BYTE 5. 0.) (- 32. ROTATION)))))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 72
(DEFINE-DISASSEMBLER (DPB CHAR-DPB %P-DPB %P-TAG-DPB)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (FORMAT STREAM "~a (Byte ~a ~a)"
	  (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	  (1+ (LDB I:SYS:%%PACKED-INSTRUCTION-BYTE-SIZE-1 INSTRUCTION-BITS))
	  (LDB I:SYS:%%PACKED-INSTRUCTION-BYTE-ROTATION INSTRUCTION-BITS))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 84, 85
(DEFINE-DISASSEMBLER (FAST-AREF-1 FAST-ASET-1)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (PRINC (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)) STREAM)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      ;; The operand for these instructions points one past the array,
      ;; so to get to the actual array we have to subtract 1 from the
      ;; operand.  Since operands of the form FP|0, LP|0 don't make
      ;; sense (since the array register would then go below FP|0 or
      ;; LP|0) and SP|POP and immediate operands are illegal for these
      ;; instructions, there is no chance of a borrow occurring if we
      ;; just subtract one from the instruction bits, so that's what we
      ;; do.
      (DECODE-ADDRESS-OPERAND (1- INSTRUCTION-BITS) STACK-DESCRIPTION)
    (FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE)
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))

;;; 89
(DEFINE-DISASSEMBLER (BRANCH
		      BRANCH-TRUE
		      BRANCH-TRUE-ELSE-EXTRA-POP
		      BRANCH-TRUE-AND-EXTRA-POP
		      BRANCH-TRUE-EXTRA-POP
		      BRANCH-TRUE-NO-POP
		      BRANCH-TRUE-AND-NO-POP
		      BRANCH-TRUE-ELSE-NO-POP
		      BRANCH-TRUE-AND-NO-POP-ELSE-NO-POP-EXTRA-POP
		      BRANCH-FALSE
		      BRANCH-FALSE-ELSE-EXTRA-POP
		      BRANCH-FALSE-AND-EXTRA-POP
		      BRANCH-FALSE-EXTRA-POP
		      BRANCH-FALSE-NO-POP
		      BRANCH-FALSE-AND-NO-POP
		      BRANCH-FALSE-ELSE-NO-POP
		      BRANCH-FALSE-AND-NO-POP-ELSE-NO-POP-EXTRA-POP
		      LOOP-DECREMENT-TOS
		      LOOP-INCREMENT-TOS-LESS-THAN)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (IF (AND (ZEROP (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS))
	   (= (LDB (BYTE 4 4) (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	      (LDB (BYTE 4 4) *BRANCH-TRUE-OPCODE*)))
      (LET* ((NAME (DBG:OPCODE-SELECT INSTRUCTION-BITS
		     (BRANCH-TRUE			"TRAP-IF-TRUE")
		     (BRANCH-TRUE-ELSE-EXTRA-POP	"TRAP-IF-TRUE-EXTRA-POP")
		     (BRANCH-TRUE-AND-EXTRA-POP		"TYPE-TRAP-IF-TRUE")
		     (BRANCH-TRUE-EXTRA-POP		"TYPE-TRAP-IF-TRUE-EXTRA-POP")
		     (BRANCH-TRUE-NO-POP		"TRAP-IF-TRUE-NO-POP")
		     (BRANCH-TRUE-ELSE-NO-POP		"TYPE-TRAP-IF-TRUE-NO-POP")
		     (BRANCH-FALSE			"TRAP-IF-FALSE")
		     (BRANCH-FALSE-ELSE-EXTRA-POP	"TRAP-IF-FALSE-EXTRA-POP")
		     (BRANCH-FALSE-AND-EXTRA-POP	"TYPE-TRAP-IF-FALSE")
		     (BRANCH-FALSE-EXTRA-POP		"TYPE-TRAP-IF-FALSE-EXTRA-POP")
		     (BRANCH-FALSE-NO-POP		"TRAP-IF-FALSE-NO-POP")
		     (BRANCH-FALSE-ELSE-NO-POP		"TYPE-TRAP-IF-FALSE-NO-POP")
		     ((BRANCH-TRUE-AND-NO-POP
		       BRANCH-TRUE-AND-NO-POP-ELSE-NO-POP-EXTRA-POP) "UNDEFINED-TRAP-IF-TRUE")
		     (OTHERWISE 			"UNDEFINED-TRAP-IF-FALSE"))))
	(CL:WRITE-STRING NAME STREAM)
	(LET ((HANDLER (AND (NOT (%STRING= NAME 0 "TYPE" 0 4))
			    (CDR (CL:ASSOC RELATIVE-PC
					   (CDR (CL:ASSOC :TRAP-HANDLERS DEBUGGING-INFO)))))))
	  (WHEN HANDLER
	    (FORMAT STREAM "~40,8T;to ~S" HANDLER))))
      (FORMAT STREAM "~A ~o"
	(GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	(+ RELATIVE-PC
	   (SIGN-EXTEND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS) 10.))))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 108
(DEFINE-DISASSEMBLER (%BLOCK-0-READ %BLOCK-1-READ %BLOCK-2-READ %BLOCK-3-READ
				    %BLOCK-0-READ-SHIFT %BLOCK-1-READ-SHIFT
				    %BLOCK-2-READ-SHIFT %BLOCK-3-READ-SHIFT
				    %BLOCK-1-READ-TEST %BLOCK-2-READ-TEST
				    %BLOCK-3-READ-TEST)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (MULTIPLE-VALUE-BIND (CYCLE-NAME FIXNUM-ONLY INHIBIT-PREFETCH NO-INCREMENT)
      (BLOCK-READ-COMPONENTS INSTRUCTION-BITS)
    (FORMAT
      STREAM
      "~a ~a~:[~; FIXNUM-ONLY~]~:[~; SET-CDR-NEXT~]~:[~; INHIBIT-PREFETCH~]~:[~; NO-INCREMENT~]"
      (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
      (SUBSTRING CYCLE-NAME (CL:LENGTH "%MEMORY-"))
      FIXNUM-ONLY
      (PLUSP (LDB %%MEMORY-SET-CDR-NEXT INSTRUCTION-BITS))
      INHIBIT-PREFETCH NO-INCREMENT))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 129
(DEFINE-DISASSEMBLER (FINISH-CALL-N-APPLY FINISH-CALL-N FINISH-CALL-TOS FINISH-CALL-TOS-APPLY)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (MULTIPLE-VALUE-BIND (N-VALUES NAMES)
      (IF (FIXNUMP (CAR NAMES))
	  (VALUES (CAR NAMES) (CDR NAMES))
	  (VALUES NIL NAMES))
    (LET ((OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)))
      (FORMAT STREAM "FINISH-CALL~:[~;-APPLY~]-~:[~*STACK~;~a~]"
	      (OR (EQL OPCODE *FINISH-CALL-N-APPLY-OPCODE*)
		  (EQL OPCODE *FINISH-CALL-TOS-APPLY-OPCODE*))
	      (OR (EQL OPCODE *FINISH-CALL-N-OPCODE*)
		  (EQL OPCODE *FINISH-CALL-N-APPLY-OPCODE*))
	      (1- (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND INSTRUCTION-BITS)))
      (IF N-VALUES
	  ;; When calling functions which the compiler knows will use RETURN-KLUDGE
	  ;; to return, the value-disposition will be ignored and the TAKE-VALUES is
	  ;; compiled by hand.  The debugging info contains a number which indicates
	  ;; the number of values which will be returned.
	  (FORMAT STREAM "-FOR-~d-VALUE~A" N-VALUES (IF (EQL N-VALUES 1) "" "S"))
	  (FORMAT STREAM "-~a"
		  (SELECT (LDB %%PACKED-INSTRUCTION-VALUE-DISPOSITION INSTRUCTION-BITS)
		    (I:SYS:VALUE-DISPOSITION-EFFECT "EFFECT")
		    (I:SYS:VALUE-DISPOSITION-VALUE "VALUE")
		    (I:SYS:VALUE-DISPOSITION-RETURN "RETURN")
		    (I:SYS:VALUE-DISPOSITION-MULTIPLE "MULTIPLE")))))
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES)))

;;; 133
(DEFINE-DISASSEMBLER (ENTRY-REST-ACCEPTED ENTRY-REST-NOT-ACCEPTED)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (LET ((MIN (LDB %%ENTRY-INSTRUCTION-MIN INSTRUCTION-BITS))
	(MAX (LDB %%ENTRY-INSTRUCTION-MAX INSTRUCTION-BITS)))
    (PRINT-PC-AND-SEQUENCING
      STREAM
      RELATIVE-PC
      (SELECT INCREMENT
	(-1 "-  ")
	(1  "+  ")
	(2  "   ")
	(3  "+++"))
       BREAKPOINT-INSTRUCTION-P)
    (FORMAT STREAM "ENTRY: ~s REQUIRED, ~s OPTIONAL" (- MIN 2) (- MAX MIN))
    (WHEN (NOT (LDB-TEST (BYTE 1 0) (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)))
      (PRINC ", REST ARG" STREAM))
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES)))

;;; 137 LOCATE-LOCALS with PUSH-GLOBAL-LOGIC-VARIABLE

;;; 138
(DEFINE-DISASSEMBLER (RETURN-SINGLE)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION NAMES DEBUGGING-INFO))
  (LET ((OPERAND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)))
    (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
    (FORMAT STREAM "RETURN-SINGLE-~a"
	    (SELECT OPERAND
	      (%REGISTER-TOS "STACK")
	      (%REGISTER-CONSTANT-T "T")
	      (%REGISTER-CONSTANT-NIL "NIL")
	      (OTHERWISE (REGISTER-NAME-FROM-ADDRESS OPERAND))))))

;;; 142
(DEFINE-DISASSEMBLER (LOGXOR)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (IF (EQ MODE :IMMEDIATE)
	(IF (EQ OFFSET-OR-VALUE -1)
	    (FORMAT STREAM "LOGNOT")
	    (FORMAT STREAM "LOGXOR ~s" OFFSET-OR-VALUE))
	(FORMAT STREAM "LOGXOR ~a|~a" MODE OFFSET-OR-VALUE)))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 144
(DEFINE-DISASSEMBLER (UNBIND-N)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE NAMES DEBUGGING-INFO))
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
    (COND ((AND (EQ MODE :IMMEDIATE)
		(EQL OFFSET-OR-VALUE 1))
	   (CL:WRITE-STRING "UNBIND" STREAM))
	  ((AND (EQ MODE :SP)
		(EQ OFFSET-OR-VALUE :POP))
	   (CL:WRITE-STRING "UNBIND-N-TOS" STREAM))
	  (T (CL:WRITE-STRING "UNBIND-N" STREAM)
	     (IF (EQ MODE :IMMEDIATE)
		 (FORMAT STREAM " ~a" OFFSET-OR-VALUE)
		 (FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE))))))

;;; 146
(DEFINE-DISASSEMBLER (CATCH-OPEN)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (LET ((OPERAND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)))
    (COND ((ZEROP (LDB (BYTE 1 0) OPERAND))
	   (FORMAT STREAM "CATCH-OPEN-~a"
		   (SELECT (LDB (BYTE 2 6) OPERAND)
		     (VALUE-DISPOSITION-EFFECT "EFFECT")
		     (VALUE-DISPOSITION-VALUE "VALUE")
		     (VALUE-DISPOSITION-RETURN "RETURN")
		     (VALUE-DISPOSITION-MULTIPLE "MULTIPLE"))))
	  (T (FORMAT STREAM "UNWIND-PROTECT-OPEN"))))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 147
(DEFINE-DISASSEMBLER (CATCH-CLOSE)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE INSTRUCTION-BITS STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (FORMAT STREAM "CATCH-CLOSE")
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 148
(DEFINE-DISASSEMBLER (PUSH-LEXICAL-VAR POP-LEXICAL-VAR MOVEM-LEXICAL-VAR)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (FORMAT STREAM "~A-~D"
	  (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	  (LDB %%PACKED-INSTRUCTION-LEXICAL-VAR-N INSTRUCTION-BITS))
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (IF (EQ MODE :IMMEDIATE)
	(FORMAT STREAM " ~s" OFFSET-OR-VALUE)
	(FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE))
    (DISASSEMBLE-PRINT-COMMENT
      STREAM
      (LOOP FOR (NAME . PCS) IN (CDR (CL:ASSOC :LEXICAL-VARIABLE-INSTRUCTIONS DEBUGGING-INFO))
	    DOING
	(WHEN (CL:MEMBER RELATIVE-PC PCS)
	  (RETURN NAME)))
      NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))

;;; 151
(DEFINE-DISASSEMBLER (PUSH-INSTANCE-VARIABLE POP-INSTANCE-VARIABLE MOVEM-INSTANCE-VARIABLE
		      PUSH-ADDRESS-INSTANCE-VARIABLE
		      PUSH-INSTANCE-VARIABLE-ORDERED POP-INSTANCE-VARIABLE-ORDERED
		      MOVEM-INSTANCE-VARIABLE-ORDERED
		      %INSTANCE-REF %INSTANCE-SET %INSTANCE-LOC)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (LET ((OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)))
      (BLOCK DISASSEMBLE
	(LET* ((CLOS-INFO
		 (SECOND (CL:ASSOC 'CLOS-INTERNALS:MAPPING-TABLE-FAMILY DEBUGGING-INFO)))
	       (FAMILY (FIRST CLOS-INFO))
	       (MAPPED-VARIABLES (CL:REST CLOS-INFO))
	       (PRETTY-NAME (SELECT OPCODE
			      (*PUSH-INSTANCE-VARIABLE-OPCODE* "PUSH")
			      (*POP-INSTANCE-VARIABLE-OPCODE* "POP")
			      (*MOVEM-INSTANCE-VARIABLE-OPCODE* "MOVEM")
			      (*PUSH-ADDRESS-INSTANCE-VARIABLE-OPCODE* "LOCATE"))))
	  (WHEN (AND FAMILY PRETTY-NAME)
	    (LET* ((INDEX
		     (CLOS-INTERNALS:SEGMENT-NUMBER-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX
		       0 OFFSET-OR-VALUE))
		   (DATA (AREF (CLOS-INTERNALS:MAPPING-TABLE-FAMILY-MAP-DATA FAMILY)
			       INDEX))
		   (BITS (AREF (CLOS-INTERNALS:MAPPING-TABLE-FAMILY-MAP-BITS FAMILY)
			       INDEX))
		   (CLASS-INDEX (LDB CLOS-INTERNALS:%%MAP-BITS-CLASS BITS))
		   (CLASS (NTH CLASS-INDEX MAPPED-VARIABLES))
		   (TYPE (LDB CLOS-INTERNALS:%%MAP-BITS-TYPE BITS)))
	      (COND ((EQL TYPE CLOS-INTERNALS:%MAP-TYPE-SLOT)
		     (FORMAT STREAM "~a-SLOT-VALUE-~d (~s '~s)"
			     PRETTY-NAME
			     OFFSET-OR-VALUE
			     CLASS
			     DATA)
		     (DISASSEMBLE-PRINT-COMMENT
		       STREAM NIL NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)
		     (RETURN-FROM DISASSEMBLE))
		    (T
		     (LET ((OPCODE-NAME
			     (COND ((AND (EQL TYPE CLOS-INTERNALS:%MAP-TYPE-READER)
					 (EQL OPCODE *PUSH-INSTANCE-VARIABLE-OPCODE*))
				    "PUSH-WITH-READER")
				   ((EQL TYPE CLOS-INTERNALS:%MAP-TYPE-WRITER)
				    (COND ((EQL OPCODE *POP-INSTANCE-VARIABLE-OPCODE*)
					   "POP-WITH-WRITER")
					  ((EQL OPCODE *MOVEM-INSTANCE-VARIABLE-OPCODE*)
					   "MOVEM-WITH-WRITER")))
				   ((AND (EQL TYPE CLOS-INTERNALS:%MAP-TYPE-LOCATOR)
					 (EQL OPCODE *PUSH-ADDRESS-INSTANCE-VARIABLE-OPCODE*))
				    "LOCATE-WITH-LOCATOR"))))
		       (WHEN OPCODE-NAME
			 (FORMAT STREAM "~a-~d (~s)" OPCODE-NAME INDEX CLASS)
			 (DISASSEMBLE-PRINT-COMMENT
			   STREAM
			   NIL
			   DATA
			   (WHEN ENTRY (STACK-ENTRY-NAME ENTRY))
			   NAMES)
			 (RETURN-FROM DISASSEMBLE))))))))
	(PRINC (GET-OPCODE-PRETTY-NAME OPCODE) STREAM)
	(IF (EQ MODE :IMMEDIATE)
	    (FORMAT STREAM " ~s" OFFSET-OR-VALUE)
	    (FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE))
	(DISASSEMBLE-PRINT-COMMENT
	  STREAM
	  NIL
	  (LOOP FOR (NAME . PCS)
		    IN (CDR (CL:ASSOC :INSTANCE-VARIABLE-INSTRUCTIONS DEBUGGING-INFO))
		DOING
	    (WHEN (CL:MEMBER RELATIVE-PC PCS)
	      (RETURN NAME)))
	  (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))))

(DEFUN GET-REGISTER-NAME-FROM-ADDRESS (ADDRESS &OPTIONAL (RWMODE :READ))
  (AREF (IF (EQ RWMODE :READ)
	    I:SYSTEM:*INTERNAL-READABLE-REGISTER-MAP*
	  I:SYSTEM:*INTERNAL-WRITABLE-REGISTER-MAP*)
	ADDRESS))

;;; 171
(DEFINE-DISASSEMBLER (%READ-INTERNAL-REGISTER)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (CL:WRITE-STRING "%READ " STREAM)
  (CL:WRITE-STRING
    (CL:SYMBOL-NAME
      (GET-REGISTER-NAME-FROM-ADDRESS
	(LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)
	:READ))
    STREAM
    :START 1)
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 172
(DEFINE-DISASSEMBLER (%WRITE-INTERNAL-REGISTER)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (CL:WRITE-STRING "%WRITE " STREAM)
  (CL:WRITE-STRING
    (CL:SYMBOL-NAME
      (GET-REGISTER-NAME-FROM-ADDRESS
	(LDB I:SYS:%%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)
	:WRITE))
    STREAM
    :START 1)
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 173
(DEFINE-DISASSEMBLER (%COPROCESSOR-READ)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (LET ((OPERAND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)))
    (SELECT OPERAND
      (SI:%COPROCESSOR-MICROSECOND-CLOCK-ADDRESS
       (CL:WRITE-STRING "%MICROSECOND-CLOCK" STREAM))
      (OTHERWISE
       (FORMAT STREAM "%COPROCESSOR-READ ~o" OPERAND))))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 174
(DEFINE-DISASSEMBLER (%COPROCESSOR-WRITE)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (LET ((OPERAND (LDB %%PACKED-INSTRUCTION-10-BIT-OPERAND INSTRUCTION-BITS)))
    (SELECT OPERAND
      (SI:%COPROCESSOR-MICROSECOND-CLOCK-ADDRESS
       (CL:WRITE-STRING "%SET-MICROSECOND-CLOCK" STREAM))
      (OTHERWISE
       (FORMAT STREAM "%COPROCESSOR-WRITE ~o" OPERAND))))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 175
(DEFINE-DISASSEMBLER (%MEMORY-READ %MEMORY-READ-ADDRESS)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE STACK-DESCRIPTION DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (FORMAT STREAM "~a ~a~:[~; FIXNUM-ONLY~]~:[~; SET-CDR-NEXT~]"
	  (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS))
	  (SUBSTRING (NTH (LDB %%MEMORY-CYCLE-TYPE INSTRUCTION-BITS)
			  *MEMORY-CYCLE-TYPES*)
		     (CL:LENGTH "%MEMORY-"))
	  (PLUSP (LDB %%MEMORY-FIXNUM-ONLY INSTRUCTION-BITS))
	  (PLUSP (LDB %%MEMORY-SET-CDR-NEXT INSTRUCTION-BITS)))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES))

;;; 178
(DEFINE-DISASSEMBLER (%SET-TAG)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (DECLARE (IGNORE DEBUGGING-INFO))
  (PACKED-PRINT-PC-AND-SEQUENCING STREAM RELATIVE-PC INCREMENT BREAKPOINT-INSTRUCTION-P)
  (PRINC (GET-OPCODE-PRETTY-NAME (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)) STREAM)
  (MULTIPLE-VALUE-BIND (MODE OFFSET-OR-VALUE ENTRY)
      (DECODE-ADDRESS-OPERAND INSTRUCTION-BITS STACK-DESCRIPTION)
    (IF (EQ MODE :IMMEDIATE)
	(LET ((CDR-CODE (LDB %%Q-CDR-CODE-WITHIN-TAG OFFSET-OR-VALUE))
	      (TYPE (NTH (LDB %%Q-TYPE-WITHIN-TAG OFFSET-OR-VALUE) *DATA-TYPES*)))
	  (SELECT CDR-CODE
	    (CDR-NORMAL (CL:WRITE-STRING " CDR-NORMAL" STREAM))
	    (CDR-NIL (CL:WRITE-STRING " CDR-NIL" STREAM))
	    (3 (CL:WRITE-STRING " CDR-3" STREAM)))
	  (CL:WRITE-CHAR #\SP STREAM)
	  (CL:WRITE-STRING (CL:SYMBOL-NAME TYPE) STREAM :START 4))
	(FORMAT STREAM " ~a|~a" MODE OFFSET-OR-VALUE))
    (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL (WHEN ENTRY (STACK-ENTRY-NAME ENTRY)) NAMES)))

;;; 189 NO-OP with PUSH-GLOBAL-LOGIC-VARIABLE
;;; 190 %HALT with PUSH-GLOBAL-LOGIC-VARIABLE

(DEFUN DISASSEMBLE-INSTRUCTION
       (CCA RELATIVE-PC NAMES STACK-ARRAY DEBUGGING-INFO
	&OPTIONAL (STREAM CL:*STANDARD-OUTPUT*) FOR-INSPECT-P)
  (LET* ((INSTRUCTION
	   (%MEMORY-READ
	     (%POINTER-PLUS CCA (+ (LDB (BYTE 31. 1.) RELATIVE-PC)
				   (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
	     :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))
	 (TYPE (%DATA-TYPE INSTRUCTION))
	 (INCREMENT
	   (SELECT (LDB %%Q-CDR-CODE-WITHIN-TAG (%TAG INSTRUCTION))
	     (SEQUENCING-PC+1 1)
	     (SEQUENCING-FENCE (RETURN-FROM DISASSEMBLE-INSTRUCTION NIL))
	     (SEQUENCING-PC-1 -1)
	     (SEQUENCING-PC-EVEN+2-ODD+3
	      (+ 2 (LDB (BYTE 1 0) RELATIVE-PC)))))
	 (STACK-DESCRIPTION (AREF STACK-ARRAY RELATIVE-PC))
	 (*FUNCTION-BEING-DISASSEMBLED*
	   (SYS:FUNCTION-NAME (%MAKE-POINTER-OFFSET DTP-COMPILED-FUNCTION CCA
				(DEFSTORAGE-SIZE COMPILED-FUNCTION)))))
    (IF ( TYPE DTP-PACKED-INSTRUCTION-60)
	(DISASSEMBLE-PACKED-INSTRUCTION
	  INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM)
	(FUNCALL
	  (IF FOR-INSPECT-P
	      #'DISASSEMBLE-FULL-WORD-INSTRUCTION-FOR-INSPECT
	      #'DISASSEMBLE-FULL-WORD-INSTRUCTION)
	  INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM))
    INCREMENT))


(DEFUN DISASSEMBLE-PACKED-INSTRUCTION
       (INSTRUCTION RELATIVE-PC INCREMENT NAMES	STACK-DESCRIPTION DEBUGGING-INFO STREAM
	&OPTIONAL BREAKPOINT-INSTRUCTION-P)
  (LET* ((TYPE (%DATA-TYPE INSTRUCTION))
	 (INSTRUCTION-BITS
	   (IF (EVENP RELATIVE-PC)
	       (%SET-TAG INSTRUCTION DTP-FIXNUM)
	       (DPB TYPE %%ODD-INSTRUCTION-TAG-COMPONENT
		    (LDB %%Q-ODD-INSTRUCTION-WITHIN-POINTER
			 (%SET-TAG INSTRUCTION DTP-FIXNUM)))))
	 (OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)))
    (FUNCALL (AREF *DISASSEMBLERS* OPCODE)
	     STREAM
	     INSTRUCTION-BITS
	     RELATIVE-PC
	     INCREMENT
	     STACK-DESCRIPTION
	     NAMES
	     DEBUGGING-INFO
	     BREAKPOINT-INSTRUCTION-P)))

(DEFUN DISASSEMBLE-FULL-WORD-INSTRUCTION
       (INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM
	&OPTIONAL BREAKPOINT-INSTRUCTION-P)
  (LET* ((CCA-LIST (ASSQ :FUNCTION-CCA (CDR DEBUGGING-INFO)))
	 (CCA (CDR CCA-LIST)))
    (FLET ((PRINT-DECODED-LOCATIVE (LOCATIVE)
	     (MULTIPLE-VALUE-BIND (SYMBOL TYPE)
		 (DISASSEMBLE-DECODE-LOCATIVE LOCATIVE CCA RELATIVE-PC)
	       (CL:CASE TYPE
		 (:VARIABLE
		   (FORMAT STREAM "~@\presentation\" SYMBOL 'SYS:FORM))
		 (:FUNCTION
		   (DISASSEMBLE-PRINT-FUNCTION-OBJECT SYMBOL STREAM))
		 (OTHERWISE
		   (FORMAT STREAM "@~@\presentation\" SYMBOL 'SYS:FORM)))))
	   (PRINT-DATUM (DATUM)
	     (FORMAT STREAM "'~@\presentation\" DATUM 'SYS:EXPRESSION)))
      (DISASSEMBLE-FULL-WORD-INSTRUCTION-INTERNAL
	INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM
	BREAKPOINT-INSTRUCTION-P #'PRINT-DECODED-LOCATIVE #'PRINT-DATUM))))


(DEFUN DISASSEMBLE-FULL-WORD-INSTRUCTION-FOR-INSPECT
       (INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM
	&OPTIONAL BREAKPOINT-INSTRUCTION-P)
  (LET* ((CCA-LIST (ASSQ :FUNCTION-CCA (CDR DEBUGGING-INFO)))
	 (CCA (CDR CCA-LIST)))
    (FLET ((PRINT-DECODED-LOCATIVE (LOCATIVE)
	     (MULTIPLE-VALUE-BIND (SYMBOL TYPE)
		 (DISASSEMBLE-DECODE-LOCATIVE LOCATIVE CCA RELATIVE-PC)
	       (CL:CASE TYPE
		 (:VARIABLE
		   (SEND STREAM :ITEM (LIST SYMBOL CCA RELATIVE-PC)
			 'TV:CCA-INDIRECT-OBJECT #'TV:PRINT-CCA-OBJECT ","))
		 (:FUNCTION
		   (SEND STREAM :ITEM (LIST SYMBOL CCA RELATIVE-PC)
			 'TV:CCA-INDIRECT-OBJECT #'TV:PRINT-CCA-OBJECT "#'"))
		 (OTHERWISE
		   (FORMAT STREAM "@~@\presentation\" SYMBOL 'SYS:FORM)))))
	   (PRINT-DATUM (DATUM)
	     (LET ((TYPE (IF (TYPE-MEMBER DATUM DTP-EVEN-PC DTP-ODD-PC DTP-GENERIC-FUNCTION)
			     'TV:CCA-RANDOM-OBJECT
			     'TV:CCA-OBJECT)))
	       (SEND STREAM :ITEM (LIST DATUM CCA RELATIVE-PC)
		     TYPE #'TV:PRINT-CCA-OBJECT ""))))
      (DISASSEMBLE-FULL-WORD-INSTRUCTION-INTERNAL
	INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM
	BREAKPOINT-INSTRUCTION-P #'PRINT-DECODED-LOCATIVE #'PRINT-DATUM))))

(DEFUN DISASSEMBLE-FULL-WORD-INSTRUCTION-INTERNAL
       (INSTRUCTION RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM
	BREAKPOINT-INSTRUCTION-P PRINT-DECODED-LOCATIVE PRINT-DATUM)
  (DECLARE (SYS:DOWNWARD-FUNARG PRINT-DECODED-LOCATIVE PRINT-DATUM)
	   (IGNORE DEBUGGING-INFO))
  (PRINT-PC-AND-SEQUENCING
    STREAM
    RELATIVE-PC
    (SELECTQ INCREMENT
      (-1 "-  ")
      (1  "+  ")
      (2  "   ")
      (3  "+++"))
    BREAKPOINT-INSTRUCTION-P)
  (COND
    ((TYPE-MEMBER INSTRUCTION DTP-EXTERNAL-VALUE-CELL-POINTER)
     (PRINC "PUSH-INDIRECT " STREAM)
     (FUNCALL PRINT-DECODED-LOCATIVE (%SET-TAG INSTRUCTION DTP-LOCATIVE)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN)
     (PRINC "START-CALL-DIRECT " STREAM)
     (FUNCALL PRINT-DATUM (%SET-TAG INSTRUCTION DTP-EVEN-PC)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-ODD)
     (PRINC "START-CALL-DIRECT " STREAM)
     (FUNCALL PRINT-DATUM (%SET-TAG INSTRUCTION DTP-ODD-PC)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN-PREFETCH)
     (PRINC "START-CALL-DIRECT-PREFETCH " STREAM)
     (FUNCALL PRINT-DATUM (%SET-TAG INSTRUCTION DTP-EVEN-PC)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-ODD-PREFETCH)
     (PRINC "START-CALL-DIRECT-PREFETCH " STREAM)
     (FUNCALL PRINT-DATUM (%SET-TAG INSTRUCTION DTP-ODD-PC)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT)
     (PRINC "START-CALL-INDIRECT " STREAM)
     (FUNCALL PRINT-DECODED-LOCATIVE (%SET-TAG INSTRUCTION DTP-LOCATIVE)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT-PREFETCH)
     (PRINC "START-CALL-INDIRECT-PREFETCH " STREAM)
     (FUNCALL PRINT-DECODED-LOCATIVE (%SET-TAG INSTRUCTION DTP-LOCATIVE)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-GENERIC)
     (PRINC "START-CALL-GENERIC " STREAM)
     (FUNCALL PRINT-DATUM (%SET-TAG INSTRUCTION DTP-GENERIC-FUNCTION)))
    ((TYPE-MEMBER INSTRUCTION DTP-CALL-GENERIC-PREFETCH)
     (PRINC "START-CALL-GENERIC-PREFETCH " STREAM)
     (FUNCALL PRINT-DATUM (%SET-TAG INSTRUCTION DTP-GENERIC-FUNCTION)))
    #+VLM
    ((TYPE-MEMBER INSTRUCTION AXPI::*NATIVE-INSTRUCTION-OPCODE*)
     (MULTIPLE-VALUE-BIND (MODE OFFSET COMPONENT)
	 (AXPI::PRINT-NATIVE-INSTRUCTION (%POINTER INSTRUCTION) STREAM RELATIVE-PC)
       (LET ((ENTRY
	       (CL:CASE MODE
		 (:FP (STACK-DESCRIPTION-FP-N STACK-DESCRIPTION OFFSET))
		 (:LP (STACK-DESCRIPTION-LP-N STACK-DESCRIPTION OFFSET))
		 (:SP (STACK-DESCRIPTION-SP-N STACK-DESCRIPTION OFFSET)))))
	 (DISASSEMBLE-PRINT-COMMENT
	   STREAM
	   COMPONENT NIL
	   (WHEN ENTRY (STACK-ENTRY-NAME ENTRY))
	   NAMES)
	 (RETURN-FROM DISASSEMBLE-FULL-WORD-INSTRUCTION-INTERNAL
	   INCREMENT))))
    (T
     (PRINC "PUSH-CONSTANT " STREAM)
     (FUNCALL PRINT-DATUM INSTRUCTION)))
  (DISASSEMBLE-PRINT-COMMENT STREAM NIL NIL NIL NAMES)
  INCREMENT)

(DEFUN DISASSEMBLE-INSTRUCTION-FOR-INSPECT
       (CCA RELATIVE-PC NAMES STACK-ARRAY DEBUGGING-INFO
	&OPTIONAL (STREAM CL:*STANDARD-OUTPUT*))
  (DISASSEMBLE-INSTRUCTION CCA RELATIVE-PC NAMES STACK-ARRAY DEBUGGING-INFO STREAM T))

(DEFUN DISASSEMBLE-BREAKPOINT-INSTRUCTION (BREAKPOINT PC INCREMENT NAMES STACK-DESCRIPTION
					   DEBUGGING-INFO STREAM)
  (IF ( (%DATA-TYPE (DBG::BPT-INSTRUCTION BREAKPOINT)) DTP-PACKED-INSTRUCTION-60)
      (DISASSEMBLE-PACKED-INSTRUCTION (DBG:BPT-INSTRUCTION BREAKPOINT) PC INCREMENT
				      NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM 'T)
      (LET ((INSTRUCTION
	      (%SET-TAG (DBG:BPT-INSTRUCTION BREAKPOINT) (DBG:BPT-DATA-TYPE BREAKPOINT))))
	(DISASSEMBLE-FULL-WORD-INSTRUCTION
	  INSTRUCTION PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM 'T))))

(DEFINE-DISASSEMBLER (%PROC-BREAKPOINT)
		     (STREAM INSTRUCTION-BITS RELATIVE-PC INCREMENT STACK-DESCRIPTION
			     NAMES DEBUGGING-INFO BREAKPOINT-INSTRUCTION-P)
  (IGNORE INSTRUCTION-BITS BREAKPOINT-INSTRUCTION-P)
  (LET* ((BREAKPOINTS (ASSQ :BREAKPOINTS (CDR DEBUGGING-INFO)))
	 (BREAKPOINT-LIST (CDR BREAKPOINTS)))
    (LOOP FOR BPT IN BREAKPOINT-LIST DO
      (IF (EQL (DBG:BPT-PC BPT) RELATIVE-PC)
	  (DISASSEMBLE-BREAKPOINT-INSTRUCTION
	    BPT RELATIVE-PC INCREMENT NAMES STACK-DESCRIPTION DEBUGGING-INFO STREAM)))))

(DEFUN DISASSEMBLE-CCA (CCA &OPTIONAL FROM-PC TO-PC (STREAM CL:*STANDARD-OUTPUT*))
  (SETQ FROM-PC (OR FROM-PC 0))
  (SETQ TO-PC (OR TO-PC 1000000.))
  (LET* ((FUNCTION (%MAKE-POINTER-OFFSET
		     DTP-COMPILED-FUNCTION CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
	 (DEBUGGING-INFO (DEBUGGING-INFO FUNCTION))
	 (VCA (CDR (CL:ASSOC :VARIABLE-CREATION-ALIST DEBUGGING-INFO)))
	 (STACK-ARRAY (COMPUTE-STACK-DESCRIPTION FUNCTION))
	 (RELATIVE-PC FROM-PC)
	 (PARENT-FUNCTION-NAME
	   (LET ((PARENT-FUNCTION-NAME (FUNCTION-NAME FUNCTION)))
	     (LOOP WHILE (AND (CL:CONSP PARENT-FUNCTION-NAME)
			      (EQ (FIRST PARENT-FUNCTION-NAME) ':INTERNAL))
		   DOING
	       (SETQ PARENT-FUNCTION-NAME (SECOND PARENT-FUNCTION-NAME)))
	     PARENT-FUNCTION-NAME)))
    (WHEN (CL:LOCALLY
	    (DECLARE (CL:NOTINLINE CL:TYPEP))
	    (CL:TYPEP PARENT-FUNCTION-NAME 'CLOS:METHOD))
      (LET ((MAPPING-TABLE-FAMILY
	      (CLOS-INTERNALS::METHOD-MAPPING-TABLE-FAMILY PARENT-FUNCTION-NAME)))
	(WHEN MAPPING-TABLE-FAMILY
	  (SETQ DEBUGGING-INFO `((CLOS-INTERNALS:MAPPING-TABLE-FAMILY
				   (,MAPPING-TABLE-FAMILY
				    ,@(CLOS-INTERNALS::METHOD-MAPPING-TABLE-ARGUMENTS
					PARENT-FUNCTION-NAME)))
				 ,@DEBUGGING-INFO)))))
    ;; Adjust the from PC so that it corresponds to a real instruction
    (SETQ RELATIVE-PC (MIN RELATIVE-PC (1- (CL:LENGTH STACK-ARRAY))))
    (LOOP UNTIL (OR (= RELATIVE-PC 0)
		    (AREF STACK-ARRAY RELATIVE-PC))
	  DOING (DECF RELATIVE-PC))
    (LOOP DOING
      (LET ((INCREMENT
	      (PROGN
		(TERPRI STREAM)
		(DISASSEMBLE-INSTRUCTION
		  CCA
		  RELATIVE-PC
		  (CDR (CL:ASSOC RELATIVE-PC VCA))
		  STACK-ARRAY
		  DEBUGGING-INFO
		  STREAM))))
	(IF INCREMENT
	    (INCF RELATIVE-PC INCREMENT)
	    (RETURN NIL)))
      (WHEN ( RELATIVE-PC TO-PC)
	(RETURN)))))

(DEFUN RETURN-INSTRUCTION (CCA RELATIVE-PC &OPTIONAL FUNCTION)
  (LET* ((INSTRUCTION
	   (%MEMORY-READ (%POINTER-PLUS CCA (+ (LDB (BYTE 31. 1.) RELATIVE-PC)
					       (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
			 :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))
	 (TYPE (%DATA-TYPE INSTRUCTION))
	 (INSTRUCTION-BITS
	   (IF (EVENP RELATIVE-PC)
	       (%SET-TAG INSTRUCTION DTP-FIXNUM)
	       (DPB TYPE %%ODD-INSTRUCTION-TAG-COMPONENT
		    (LDB %%Q-ODD-INSTRUCTION-WITHIN-POINTER
			 (%SET-TAG INSTRUCTION DTP-FIXNUM))))))
    (WHEN (EQL (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION-BITS)
	       (ILC:OPCODE-FOR-INSTRUCTION '%PROC-BREAKPOINT))
      (LET ((BPT-INFO (ANY-BREAKPOINT-IN-FUNCTION FUNCTION RELATIVE-PC)))
	(IF BPT-INFO
	    (SETF INSTRUCTION (DBG:BPT-PC BPT-INFO)))))
    INSTRUCTION))


(DEFUN COMPUTE-LOCAL-NAMES-FOR-DEBUGGER (FRAME &OPTIONAL PC)
  (LET* ((FUNCTION (DBG:FRAME-FUNCTION FRAME))
	 (STACK-DESCRIPTION-ARRAY)
	 (DEBUG-ALIST)
	 (TARGET-PC (OR PC (FRAME-RELATIVE-EXIT-PC FRAME))))
    (WHEN (NULL TARGET-PC)
      (RETURN-FROM COMPUTE-LOCAL-NAMES-FOR-DEBUGGER NIL))
    (MULTIPLE-VALUE (STACK-DESCRIPTION-ARRAY DEBUG-ALIST)
      (COMPUTE-STACK-DESCRIPTION FUNCTION))
    (LET* ((STACK-DESCRIPTION
	     (OR (CDR (CL:ASSOC TARGET-PC DEBUG-ALIST))
		 (AND (< TARGET-PC (VECTOR-LENGTH STACK-DESCRIPTION-ARRAY))
		      (AREF STACK-DESCRIPTION-ARRAY TARGET-PC))))
	   (STACK (STACK-DESCRIPTION-STACK STACK-DESCRIPTION))
	   (SP (OR (STACK-DESCRIPTION-SP STACK-DESCRIPTION) 0))
	   (LP (OR (STACK-DESCRIPTION-LP STACK-DESCRIPTION) 0))
	   (NAMES (CL:MAKE-ARRAY (MAX (1+ SP) LP)))
	   (NAMES-LOW LP)
	   (NAMES-HIGH SP)
	   (FRAME-SIZE (DBG:FRAME-SIZE FRAME))
	   (CR (DBG:FRAME-OWN-CONTROL-REGISTER FRAME))
	   (LOCALS (MAKE-ARRAY (MAX LP FRAME-SIZE)))
	   (LOCALS-LOW LP)
	   (LOCALS-HIGH (1- FRAME-SIZE)))
      (LOOP FOR I FROM 0
	    FOR ELT IN (REVERSE STACK) DOING
	(SETF (AREF NAMES I) ELT))
      (MACROLET ((STACK-SLOT (N)
		   `(%MEMORY-READ (%POINTER-PLUS FRAME ,N) :CYCLE-TYPE %MEMORY-SCAVENGE)))
	;; The goal is to match the names in STACK with the values on the stack.  We
	;; start with the arguments, since they're easy.
	(LOOP FOR I FROM 0 BELOW LP DOING
	  (SETF (AREF LOCALS I) (STACK-ENTRY-NAME (AREF NAMES I))))
	;; Now there may be a rest arg, in which case we have to skip over those
	;; components which are in this frame.
	(LET ((ARGS-SUPPLIED (LDB %%CR.ARGUMENT-SIZE CR)))
	  (WHEN (AND (> ARGS-SUPPLIED LP) ( LP NAMES-HIGH))
	    (SETF (AREF LOCALS ARGS-SUPPLIED) (STACK-ENTRY-NAME (AREF NAMES LP)))
	    (INCF NAMES-LOW)
	    (SETF LOCALS-LOW (1+ ARGS-SUPPLIED))))
	;; Now the easy stuff is done
	(LABELS ((MATCH-STACK (NAMES-LOW NAMES-HIGH LOCALS-LOW LOCALS-HIGH)
		   (LOOP NAMED FORWARD DOING
		     (WHEN (OR (> NAMES-LOW NAMES-HIGH)
			       (> LOCALS-LOW LOCALS-HIGH))
		       ;; This can happen either because the code was compiled
		       ;; incorrectly, the disassembler made a mistake, or the code
		       ;; contains %PUSH loops.
		       (RETURN-FROM MATCH-STACK))
		     (LET ((NAME (AREF NAMES NAMES-LOW)))
		       (SELECT (STACK-ENTRY-TYPE NAME)
			 (:MVG (RETURN-FROM FORWARD))
			 (OTHERWISE
			  (SETF (AREF LOCALS LOCALS-LOW)
				(STACK-ENTRY-NAME (AREF NAMES NAMES-LOW)))
			  (INCF NAMES-LOW)
			  (INCF LOCALS-LOW)))))
		   (LOOP NAMED BACKWARD DOING
		     (WHEN (OR (< NAMES-HIGH NAMES-LOW)
			       (< LOCALS-HIGH LOCALS-LOW))
		       (RETURN-FROM MATCH-STACK NIL))
		     (LET ((NAME (AREF NAMES NAMES-HIGH)))
		       (SELECTQ (STACK-ENTRY-TYPE NAME)
			 (:MVG
			  (LET ((SIZE (STACK-SLOT LOCALS-HIGH)))
			    (WHEN (AND (TYPEP SIZE :FIXNUM)
				       ( 0 SIZE 128.))
			      (SETF (AREF LOCALS LOCALS-HIGH)
				    (STACK-ENTRY-NAME (AREF NAMES NAMES-HIGH)))
			      (DECF LOCALS-HIGH (1+ SIZE)))))
			 (OTHERWISE
			  (SETF (AREF LOCALS LOCALS-HIGH)
				(STACK-ENTRY-NAME (AREF NAMES NAMES-HIGH)))
			  (DECF LOCALS-HIGH)))
		       (DECF NAMES-HIGH)))))
	  (MATCH-STACK NAMES-LOW NAMES-HIGH LOCALS-LOW LOCALS-HIGH)
	  LOCALS)))))

(DEFSELECT DEFAULT-DISASSEMBLE-FUNCTION
  (:NUMBER-OF-INSTRUCTIONS (CCA)
   (CCA-N-INSTRUCTIONS CCA))
  (:ENTRY-INSTRUCTION-P (ADDRESS)
   (= ADDRESS 0))
  (:GET-INSTRUCTION (CCA ADDRESS)
   (CCA-INSTRUCTION CCA ADDRESS))
  (:GET-DEBUG-INFO-ELEMENT (CCA KEYWORD)
   (ASSQ KEYWORD (CDR (SI:CCA-EXTRA-INFO-FOR-DEBUGGING CCA))))
  (:GET-CONSTANT-OBJECT (CCA INDEX &OPTIONAL IGNORE)
   (LET* ((OBJECT (CCA-OBJECT CCA INDEX))
	  (TYPE (TYPEP OBJECT)))
     (COND #+3600 ((EQ TYPE ':COMPILED-FUNCTION)
		   (VALUES (FUNCTION-NAME OBJECT) TYPE))
	   #-3600 ((EQ TYPE 'CCA)
		   (VALUES (CAR (CCA-EXTRA-INFO OBJECT)) ':COMPILED-FUNCTION))
	   (T (VALUES OBJECT TYPE)))))
  (:GET-INDIRECT-OBJECT (CCA INDEX)
   (LET ((OBJECT (CCA-OBJECT CCA INDEX)))
     (TYPECASE OBJECT
       (:LOCATIVE
	 (DISASSEMBLE-DECODE-LOCATIVE OBJECT CCA INDEX))
       ;; PROLOG SOMETIMES PUTS LISTS OR COMPILED FUNCTIONS HERE
       (OTHERWISE OBJECT))))
  (:PRINT-CONSTANT-OBJECT (OBJECT PREFIX CCA INDEX STREAM &OPTIONAL FUNCTION-P)

   CCA INDEX
   (IF FUNCTION-P
       (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
					:OBJECT (OR (SI:VALID-FUNCTION-DEFINITION OBJECT T)
						    OBJECT)
					:TYPE 'SYS:FUNCTION)
	 (FORMAT STREAM "~A" PREFIX)
	 (PRESENT OBJECT 'SYS:FUNCTION-SPEC :STREAM STREAM))
       (FORMAT STREAM "~A" PREFIX)
       (PRESENT OBJECT 'SYS:EXPRESSION :STREAM STREAM)))
  (:PRINT-INDIRECT-OBJECT (OBJECT PREFIX CCA INDEX STREAM &OPTIONAL FUNCTION-P)
   CCA INDEX
   (IF FUNCTION-P
       (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
					:OBJECT (OR (SI:VALID-FUNCTION-DEFINITION OBJECT T)
						    OBJECT)
					:TYPE 'SYS:FUNCTION)	;
	 (FORMAT STREAM "~A" PREFIX)
	 (PRESENT OBJECT 'SYS:FUNCTION-SPEC :STREAM STREAM))
       (FORMAT STREAM "~A" PREFIX)
       (PRESENT OBJECT 'SYS:FORM :STREAM STREAM)))
  (:PRINT-LOCAL-VARIABLE-NAME (NAME STREAM)
   (FORMAT STREAM "~32,8T;~@\PRESENTATION\" NAME 'SYS:FORM))
  (:PRINT-INSTANCE-VARIABLE-NAME (NAME STREAM)
   (FORMAT STREAM "~32,8T;~@\PRESENTATION\" NAME 'SYS:FORM))
  (:ANY-BREAKPOINT (CCA ADDRESS)
   (ILC:ANY-BREAKPOINT-IN-FUNCTION (CCA-COMPILED-CODE-OBJECT CCA) ADDRESS))
  )

(DEFUN DISASSEMBLE-LIM-PC (FUNCTION)
  (DEFAULT-DISASSEMBLE-FUNCTION ':NUMBER-OF-INSTRUCTIONS (COMPILED-FUNCTION-CCA FUNCTION)))

(DEFUN DISASSEMBLE-ARG-NAME (FRAME ARG-NUMBER &OPTIONAL (CACHE T))
  (DECLARE (VALUES ARG-NAME ARG-NAMES))
  (LET* ((INDEX (AND CACHE (DBG:FRAME-ARRAY-INDEX FRAME)))
	 (LOCAL-NAMES
	   (OR (WHEN CACHE
		 (DBG::SFA-LOCAL-NAMES (AREF DBG:*STACK-FRAME-ARRAY* INDEX)))
	       (COMPUTE-LOCAL-NAMES-FOR-DEBUGGER FRAME)))
	 (N (+ ARG-NUMBER (DEFSTORAGE-SIZE STACK-FRAME))))
    ;; Cache the result for speedier later use
    (WHEN CACHE
      (SETF (DBG:SFA-LOCAL-NAMES (AREF DBG:*STACK-FRAME-ARRAY* INDEX)) LOCAL-NAMES))
    (VALUES (AND (< N (CL:LENGTH LOCAL-NAMES))
		 (AREF LOCAL-NAMES N))
	    LOCAL-NAMES)))

(DEFUN DISASSEMBLE-LOCAL-NAME (FRAME LOCAL-NUMBER PC &OPTIONAL (CACHE T))
  (DECLARE (VALUES LOCAL-NAME LOCAL-NAMES))
  (LET* ((INDEX (AND CACHE (DBG:FRAME-ARRAY-INDEX FRAME)))
	 (LOCAL-NAMES
	   (OR (WHEN CACHE
		 (DBG:SFA-LOCAL-NAMES (AREF DBG:*STACK-FRAME-ARRAY* INDEX)))
	       (COMPUTE-LOCAL-NAMES-FOR-DEBUGGER FRAME PC)))
	 (N (+ LOCAL-NUMBER (DEFSTORAGE-SIZE STACK-FRAME))))
    (WHEN CACHE
      (SETF (DBG:SFA-LOCAL-NAMES (AREF DBG:*STACK-FRAME-ARRAY* INDEX)) LOCAL-NAMES))
    (VALUES (AND (< N (CL:LENGTH LOCAL-NAMES))
		 (AREF LOCAL-NAMES N))
	    LOCAL-NAMES)))

(DEFUN CACHE-LOCAL-NAMES-FOR-DEBUGGER (FRAME PC)
  (LET* ((INDEX (DBG:FRAME-ARRAY-INDEX FRAME))
	 (LOCAL-NAMES (OR (DBG:SFA-LOCAL-NAMES (AREF DBG:*STACK-FRAME-ARRAY* INDEX))
			  (COMPUTE-LOCAL-NAMES-FOR-DEBUGGER FRAME PC))))
    (SETF (DBG:SFA-LOCAL-NAMES (AREF DBG:*STACK-FRAME-ARRAY* INDEX)) LOCAL-NAMES)
    LOCAL-NAMES))
