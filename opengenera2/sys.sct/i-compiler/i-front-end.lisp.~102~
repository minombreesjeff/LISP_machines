;;; -*- Mode: Lisp; Package: I-LISP-COMPILER; Lowercase: T; Base: 10; Syntax: Zetalisp -*- 
;;; 
;;; This file contains the Lisp-Compiler front-end stuff for the I-machine.
;;; 
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun (cli::load-byte-internal phase-1-hook) (body destination)
  (load-byte-hook 'cli::load-byte-internal body destination 'inverted-ldb))

(defun (cli::fixnum-load-byte-internal phase-1-hook) (body destination)
  (load-byte-hook 'cli::fixnum-load-byte-internal body destination 'inverted-ldb))

(defun (cli::%p-load-byte-internal phase-1-hook) (body destination)
  (load-byte-hook 'cli::%p-load-byte-internal body destination 'inverted-%p-ldb))

(defun (cli::char-load-byte-internal phase-1-hook) (body destination)
  (load-byte-hook 'cli::char-load-byte-internal body destination 'inverted-char-ldb))

(defun load-byte-hook (function body destination inverted-function)
  (matchp body
    ((size position thing)
     (when (and (constant-form-p size) (constant-form-p position))
       (let ((size (constant-evaluator size))
	     (position (constant-evaluator position)))
	 (when (and (plusp size) (not (minusp position))
		    (selectq function
		      (cli::load-byte-internal (and ( (+ size position) 32.) (< size 32.)))
		      (cli::fixnum-load-byte-internal ( (+ size position) 32.))
		      (cli::%p-load-byte-internal
		       (or (and (>= position 32.) (<= (+ size position) 40.))	;TAG
			   (and (<= position 32.) (<= (+ size position) 32.))))	;POINTER
		      (cli::char-load-byte-internal
		       (and (<= (+ size position) 32.) (<= size 32.)))))
	   (phase-1 `(,inverted-function ,thing ,(byte size position))
		    destination nil nil)
	   t))))
    (* nil)))

(defun (cli::deposit-byte-internal phase-1-hook) (body destination)
  (deposit-byte-hook 'cli::deposit-byte-internal body destination 'inverted-dpb))

(defun (cli::fixnum-deposit-byte-internal phase-1-hook) (body destination)
  (deposit-byte-hook 'cli::fixnum-deposit-byte-internal body destination 'inverted-dpb))

(defun (cli::%p-deposit-byte-internal phase-1-hook) (body destination)
  (prog1 (deposit-byte-hook 'cli::%p-deposit-byte-internal body *destination-ignore*
			    'inverted-%p-dpb)
	 (phase-1-constant nil destination)))

(defun (cli::char-deposit-byte-internal phase-1-hook) (body destination)
  (deposit-byte-hook 'cli::char-deposit-byte-internal body destination 'inverted-char-dpb))

(defun deposit-byte-hook (function body destination inverted-function)
  (matchp body
    ((byte-value size position into-thing)
     (when (and (constant-form-p size) (constant-form-p position))
       (let ((size (constant-evaluator size))
	     (position (constant-evaluator position)))
	 (when (and (plusp size) (not (minusp position))
		    (selectq function
		      (cli::deposit-byte-internal ( (+ size position) 31.))
		      (cli::fixnum-deposit-byte-internal ( (+ size position) 32.))
		      (cli::char-deposit-byte-internal ( (+ size position) 32.))
		      (cli::%p-deposit-byte-internal
		       (or (and (>= position 32.) (<= (+ size position) 40.))	 ;TAG
			   (and (<= position 32.) (<= (+ size position) 32.))))));POINTER
	   (phase-1 `(,inverted-function ,byte-value ,into-thing ,(byte size position))
		    destination nil nil)
	   t))))
    (* nil)))

(defun (system-internals:%fast-aref-1 phase-1-hook) (body destination)
  (matchp body
    ((index var-name)
     (when (symbolp var-name)
       (when (self-evaluating-symbol-p var-name)
	 (phase-1-bad-form "~S cannot be an array." var-name))
       (let ((var (lookup-variable var-name)))
	 (when (eq (variable-type var) 'lexical)
	   (phase-1 index *destination-stack-fixnum* (car body) nil)
	   (emit-fast-aref var)
	   (pop-into-destination destination)
	   t))))
    (* (phase-1-wrong-num-args '%fast-aref-1 body)
       nil)))

(defun (as-1 phase-1-hook) (body destination)
  (or (phase-1-array-register-aset 'as-1 body destination)
      (phase-1-return-special-value body destination 'as-1 0)))

(defun (%1d-aset phase-1-hook) (body destination)
  (or (phase-1-array-register-aset '%1d-aset body destination)
      (phase-1-return-special-value body destination '%1d-aset 0)))

(defun (i:sys:%pointer-increment phase-1-handler) (body destination)
  (phase-1-variable-modifier 'i:sys:%pointer-increment body destination))

(defun (%set-cdr-code-1 phase-1-handler) (body destination)
  (phase-1-variable-modifier '%set-cdr-code-1 body destination))

(defun (%set-cdr-code-2 phase-1-handler) (body destination)
  (phase-1-variable-modifier '%set-cdr-code-2 body destination))

(defun phase-1-variable-modifier (function body destination)
  (matchp body
    ((arg)
     (typecase arg
       (:symbol
	 ;; Old incorrect format.  Continue to support for compatibility
	 (let ((var (lookup-variable arg)))
	   (selectq (variable-type var)
	     (lexical
	      (warn nil
		    "In ~s the argument should be a locative.  (LOCF ~s) is being substituted."
		     *phase-1-form* arg)
	      (emit-var-location var))
	     (otherwise
	      (phase-1-bad-form "The argument to ~S must be a locative to a local variable."
				function)))))
       (:list
	 (phase-1 arg *destination-stack* nil))
       (otherwise (phase-1-bad-form)))
     (emit-call (external-function function) 1 destination 'cl:inline))
    (* (phase-1-bad-form))))

(defun (i:sys:%merge-cdr-no-pop phase-1-handler) (body destination)
  (matchp body
    ((arg1 arg)
     (phase-1 arg1 *destination-stack* nil)
     (typecase arg
       (:symbol
	 ;; Old incorrect format.  Continue to support for compatibility
	 (let ((var (lookup-variable arg)))
	   (selectq (variable-type var)
	     (lexical
	      (warn nil
		    "In ~s the argument should be a locative.  (LOCF ~s) is being substituted."
		     *phase-1-form* arg)
	      (emit-var-location var))
	     (otherwise
	      (phase-1-bad-form
		"The argument to %MERGE-CDR-NO-POP must be a locative to a local variable.")))
	   ))
       (:list
	 (phase-1 arg *destination-stack* nil))
       (otherwise (phase-1-bad-form)))
     (emit-call (external-function 'i:sys:%merge-cdr-no-pop) 2 destination 'cl:inline))
    (* (phase-1-bad-form))))

(defun (si:location-boundp phase-1-handler) (body destination)
  (matchp body
    ((location)
     (phase-1 `(not (type-member (i:sys:%memory-read ,location :cycle-type
						     i:sys:%memory-data-write :set-cdr-next t)
				 i:sys:dtp-null))
	      destination body))
    (* (phase-1-bad-form))))

(defvar *no-pop-functions*
	i:i-lisp-compiler:
	'(((eq)			eq		     eq-no-pop)
	  ((eql)		eql		     eql-no-pop)
	  ((=)			internal-=	     =-no-pop)
	  ((> greaterp)		internal->	     >-no-pop)
	  ((< lessp)		internal-<	     <-no-pop)
	  ((cl:logtest)		logtest-internal     logtest-no-pop)
	  ((%unsigned-lessp)	%unsigned-lessp	     %unsigned-lessp-no-pop)
	  ((type-member)	type-member-internal type-member-no-pop)))

;; The ICASE compiler-special form should only be generated by transformers.
;; It is not very forgiving if found in user code.
;;    -- QUOTEP must be T or NIL
;;    -- The test must be recognized by the back end.
;;    -- All selectors must be in a list.
;;    -- The otherwise (T) clause is required.

;; This compiles the branches optimally for the case where all destinations
;; are equally likely.  It is slightly suboptimal for the case where the
;; first destination is by far the most common, but we're only wasting one cycle.
;; Maybe someday there can be a way to control this.
(defun (i:i-lisp-compiler:icase phase-1-handler) (body destination)
  (matchp body
    ((form quotep pop-test no-pop-test . clauses)
     (cond ((and (null (cdr clauses))
		 (eq (first (first clauses)) 'otherwise))
	    (phase-1 form *destination-ignore* body)
	    (phase-1-progn (cdr (first clauses)) destination))
	   (t
	    (phase-1 form *destination-stack* body)
	    (let ((tags (loop for clause in clauses do (ignore clause) collect (make-tag)))
		  (end-tag (make-tag))
		  (pop-test-function (external-function pop-test))
		  (no-pop-test-function (external-function no-pop-test)))
	      (loop for ((selectors . body) . rest-of-clauses) on clauses
		    for (tag . rest-of-tags) on tags
		    do (ignore body)
		    when rest-of-clauses
		      do (if selectors
			     (loop for (selector . rest-of-selectors) on selectors do
			       (phase-1 (if quotep `',selector selector)
					*destination-stack* selectors)
			       (cond ((and (null rest-of-selectors)
					   (null (cdr rest-of-clauses)))
				      (emit-call pop-test-function 2 *destination-stack*)
				      (compiler:emit-jump 'false (car rest-of-tags))
				      (compiler:emit-jump 'always tag))
				     (t (emit-call no-pop-test-function 2
						   *destination-stack-double*)
					(compiler:emit-jump 'true tag 2 1))))
			     (when (null (cdr rest-of-clauses))
			       (compiler:emit-jump 'always (car rest-of-tags) 1))))
	      (loop for (nil . body) in clauses
		    for tag in tags
		    do (compiler:emit-tag tag)
		       (phase-1-progn body destination)
		       (unless (destination-for-return destination)
			 (compiler:emit-jump 'always end-tag)))
	      (unless (destination-for-return destination)
		(emit-tag end-tag))))))
    (* (phase-1-bad-form))))

;;; Optimizers and transformers

;;; Transformers 

(deftransformer (cl:case case-icase) (form)
  (compiler:matchp form
    (('cl:case item . clauses)
     (let ((otherwise-seen nil))
       `(i:i-lisp-compiler:icase ,item t i:sys:eql i:sys:eql-no-pop
	  ,@(loop for (clause . rest) on clauses
		  collect `(,(cond ((and (null rest) (member (car clause) '(t otherwise)))
				    (setq otherwise-seen t)
				    'otherwise)
				   ((cl:listp (car clause))
				    (car clause))
				   (t (list (car clause))))
			    . ,(cdr clause)))
	  ,@(unless otherwise-seen
	      '((otherwise nil))))))
    (* (phase-1-bad-form))))

(deftransformer (zl:selector selector-icase) (form)
  (compiler:matchp form
    (('zl:selector item test . clauses)
     (let ((elem (cl:assoc #+3600 (i-support::parallel-name test)
			   #+imach test
			   *no-pop-functions*
			   :test #'cl:member)))
       (if (null elem)
	   (si:expand-selector item test clauses compiler:*interpreter-lexical-environment*)
	   (destructuring-bind (nil pop no-pop) elem
	     (let ((otherwise-seen nil))
	       `(i:i-lisp-compiler:icase ,item nil ,pop ,no-pop
	          ,@(loop for (clause . rest) on clauses
			  collect `(,(cond ((and (null rest)
						 (member (car clause) '(t otherwise)))
					    (setq otherwise-seen t)
					    'otherwise)
					   ((cl:consp (car clause))	;not LISTP
					    (car clause))
					   (t (list (car clause))))
				    . ,(cdr clause)))
		  ,@(unless otherwise-seen
		      '((otherwise nil)))))))))
    (* (phase-1-bad-form))))



#|| ;For QA only

() ;Magic

(DEFUN TEST-INTERPRETED-AND-COMPILED (ENTRIES &KEY (VERBOSE T))
  (FLET ((TRY-BOTH-WAYS (FORM)
	   (LET ((G (GENSYM)))
	     (VALUES (PROGN (EVAL `(DEFUN ,G () ,FORM))
			    (FUNCALL G))
		     (PROGN (COMPILE G)
			    (FUNCALL G))))))
    (LET ((OK T))
      (DOLIST (ENTRY ENTRIES)
	(DESTRUCTURING-BIND (FORM &KEY (EXPECTED NIL EXPECTED-P)
				       (TEST 'EQL)
				       (PROBLEMS-EXPECTED NIL))
	    ENTRY
	  (LET ((ERROR NIL) WARNING INTERPRETED-RESULT COMPILED-RESULT)
	    (CONDITION-CASE (CONDITION)
		 (SETQ WARNING
		       (CL:WITH-OUTPUT-TO-STRING (CL:*ERROR-OUTPUT*)
			 (CL:MULTIPLE-VALUE-SETQ (INTERPRETED-RESULT COMPILED-RESULT)
			   (TRY-BOTH-WAYS FORM))))
	       (SYS:ERROR
		 (SETQ ERROR CONDITION)))
	    (WHEN (EQUAL WARNING "") (SETQ WARNING NIL))
	    (UNLESS (AND (NOT ERROR)
			 (NOT WARNING)
			 (WHEN EXPECTED-P (FUNCALL TEST EXPECTED INTERPRETED-RESULT))
			 (WHEN EXPECTED-P (FUNCALL TEST EXPECTED COMPILED-RESULT))
			 (FUNCALL TEST INTERPRETED-RESULT COMPILED-RESULT))
	      (UNLESS PROBLEMS-EXPECTED (SETQ OK NIL))
	      (WHEN VERBOSE
		(IF ERROR
		    (FORMAT T "~&For ~S ...~:[~;~
		               ~% Expected: ~S~]~
			       ~% Error:    ~~A~~%"
			    FORM EXPECTED-P EXPECTED ERROR)
		    (FORMAT T "~&For ~S ...~@[
			       ~% Warning:     ~~A~~]~
		               ~% Interpreted: ~S~
		               ~% Compiled:    ~S~:[~
			       ~% No particular result expected.~;~
		               ~% Expected:    ~S~]~%"
			    FORM
			    WARNING
			    INTERPRETED-RESULT
			    COMPILED-RESULT
			    EXPECTED-P EXPECTED)))))))
      (WHEN VERBOSE
	(FORMAT T "~&Test ~:[failed~;succeeded~]." OK))
      OK)))

(DEFUN TEST-CASE-AND-SELECTOR (&KEY (VERBOSE T))
  (TEST-INTERPRETED-AND-COMPILED
    '(;; CASE tests
      ((LET ((X NIL)) (CL:CASE X (NIL 1)))
       :EXPECTED NIL)
      ((CL:CASE NIL (NIL 1) ((NIL) 2) ((T) 3) (T 4))
       :EXPECTED 2)
      ((LET ((X NIL) (Y T))
	 (CL:CASE X (NIL (PRINT Y))))
       :EXPECTED NIL)
      ((LET ((FOO NIL))
	 (CL:CASE FOO (1 :ONE) (2 :TWO) (NIL :THREE)))
       :EXPECTED NIL)
      ((CL:CASE 1 (1 :ONE) (2 :TWO) (3 :THREE) (OTHERWISE :FOUR))
       :EXPECTED :ONE)
      ((CL:CASE 2 (1 :ONE) (2 :TWO) (3 :THREE) (OTHERWISE :FOUR))
       :EXPECTED :TWO)
      ((CL:CASE 3 (1 :ONE) (2 :TWO) (3 :THREE) (OTHERWISE :FOUR))
       :EXPECTED :THREE)
      ((CL:CASE 4 (1 :ONE) (2 :TWO) (3 :THREE) (OTHERWISE :FOUR))
       :EXPECTED :FOUR)
      ((CL:CASE 4 (1 :ONE) (2 :TWO) (3 :THREE) (T :FOUR))
       :EXPECTED :FOUR)
      ((CL:CASE 1 () (NIL 1) ((NIL) 2) (OTHERWISE 3))
       :PROBLEMS-EXPECTED T)
      ((CL:CASE T ((T) 3) (T 4))
       :EXPECTED 3)
      ((CL:CASE T (T 3) ((T) 4))
       :EXPECTED 3
       :PROBLEMS-EXPECTED T)
      ;; SELECTOR tests
      ((ZL:SELECTOR NIL EQL (NIL :FOUND) ((3.0 4.0 5.0) :FOUND-TOO))
       :EXPECTED :FOUND)
      ((ZL:SELECTOR NIL EQL ((3.0 4.0 5.0) :FOUND) (NIL :FOUND-TOO) (OTHERWISE :MISSING))
       :EXPECTED :FOUND-TOO)
      ((ZL:SELECTOR NIL EQL ((3.0 4.0 5.0) :FOUND) (NIL :FOUND-TOO))
       :EXPECTED :FOUND-TOO)
      ((ZL:SELECTOR 3 = ((3 4 5) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECTOR 3 EQL ((3 4 5) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECTOR 3 = ((3.0 4.0 5.0) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECTOR 3 EQL ((3.0 4.0 5.0) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :MISSING)
      ((ZL:SELECTOR 3 EQL ((3.0 4.0 5.0) :FOUND) (T :MISSING))
       :EXPECTED :MISSING)
      ((ZL:SELECTOR 3 = ((#C(3.0 0.0) #C(4.0 0.0) #C(5.0 0.0)) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECTOR 3 EQL (('THREE 'FOUR 'FIVE) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :MISSING)
      ((ZL:SELECTOR 'THREE EQL (('THREE 'FOUR 'FIVE) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECTOR (CONS 'ONE 'TWO) EQUAL
	 (('(ONE . TWO)) '1-2)
	 (('(THREE . FOUR)) '3-4)
	 (OTHERWISE 'ANY))
       :EXPECTED 1-2)
      ;; SELECT tests
      ((ZL:SELECT 'THREE (('THREE 'FOUR 'FIVE) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECT 'SIX (('THREE 'FOUR 'FIVE) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :MISSING)
      ((ZL:SELECT 'SIX (('THREE 'FOUR 'FIVE) :FOUND) (('SIX 'SEVEN) :FOUND-TOO))
       :EXPECTED :FOUND-TOO)
      ((ZL:SELECT 'EIGHT (('THREE 'FOUR 'FIVE) :FOUND) (('SIX 'SEVEN) :FOUND-TOO))
       :EXPECTED NIL)
      ;; SELECTQ tests
      ((ZL:SELECTQ 'THREE ((THREE FOUR FIVE) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :FOUND)
      ((ZL:SELECTQ 'SIX ((THREE FOUR FIVE) :FOUND) (OTHERWISE :MISSING))
       :EXPECTED :MISSING)
      ((ZL:SELECTQ 'SIX ((THREE FOUR FIVE) :FOUND) ((SIX SEVEN) :FOUND-TOO))
       :EXPECTED :FOUND-TOO)
      ((ZL:SELECTQ 'EIGHT ((THREE FOUR FIVE) :FOUND) ((SIX SEVEN) :FOUND-TOO))
       :EXPECTED NIL)
      ((ZL:SELECTQ T ((T) 1) (T 2))
       :EXPECTED 1)
      ((ZL:SELECTQ NIL ((T) 1) (T 2))
       :EXPECTED 2)
      )
    :VERBOSE VERBOSE))

||#




(defun (:property i:si:%block-read-test-tagbody phase-1-handler) (body destination)
  (matchp body
    (((success-tag-name . options) . body)
     (unless (or (symbolp success-tag-name) (fixp success-tag-name))
       (phase-1-bad-form "Invalid tag ~S" success-tag-name))
     (let (operand-2-form operand-2-name)
       (do ((o options (cddr o)))
	   ((null o))
	 (selectq (car o)
	   (:operand-2 (setq operand-2-form (cadr o)))
	   (:operand-2-name (setq operand-2-name (cadr o)))
	   (otherwise (phase-1-bad-form "Unrecognized option ~S" (car o)))))
       ;; I don't want to figure out letting now.
       (when operand-2-name
	 (warn "The ~S option to ~S is currently unimplemented."
	       :operand-2-name 'i:si:%block-read-test-tagbody))
       (let* ((compiler:*pframe* (compiler:make-new-block-read-test-pframe))
	      (success-tag (make-tag 'go success-tag-name))
	      (tags nil)
	      (tag-names nil))
	 (compiler:with-lexical-contour
	   (setf (compiler:block-read-test-pframe-tag compiler:*pframe*)
		 success-tag)
	   ;; Don't bother with the hairy stuff in TAGBODY dealing with collapsing
	   ;; duplicate tag names together -- Phase 3 will take care of that.
	   ;; Also, don't bother with hairy cases involving non-local go's for now.
	   (dolist (name body)
	     (when (or (symbolp name) (fixp name))
	       (if (cl:member name tag-names)
		   (phase-1-warning "Tag name ~S used more than once" name)
		   (let ((tag (if (eq name success-tag-name)
				  success-tag
				  (make-tag 'go name))))
		     (push name tag-names)
		     (push tag tags)
		     (push (list (list name) tag)
			   (si:env-tagbodies compiler:*interpreter-lexical-environment*))))))
	   ;; Collect the body and note any non-local GO's.
	   (let ((interval
		   (compiler:with-lexical-contour
		     (let ((compiler:*looping* compiler:*looping*))
		       (compiler:collect-interval
			 (loop for body on body
			       for x = (first body)
			       do (cond ((or (symbolp x) (fixp x))
					 (setf compiler:*looping* t)
					 (emit-tag (compiler:lookup-tag x)))
					(t (phase-1 x *destination-ignore* body)))))))))
	     (when (compiler:nlg-non-local-reference-p compiler:*pframe*)
	       (llc-error "Can't handle non-local GO's in ~S yet."
			  'i:si:%block-read-test-tagbody))
	     (compiler:emit-push-pc success-tag)
	     (phase-1 operand-2-form *destination-stack* nil)
	     (compiler:emit-start-prog compiler:*pframe*)
	     (compiler:emit-interval interval)
	     ;; Compile the code that happens if we drop off the end.
	     (cond ((destination-for-return destination)
		    (phase-1-constant nil destination))
		   (t
		    (compiler:emit-pop 2)
		    (phase-1-constant nil destination)
		    (compiler:emit-end-prog compiler:*pframe*))))))))
    (* (phase-1-bad-form))))

(defun (:property i:si:%block-read-test-internal phase-1-handler) (body destination)
  (let ((pframe compiler:*pframe*))
    (unless (typep pframe 'compiler:new-block-read-test-pframe)
      (phase-1-bad-form "Use of %BLOCK-READ-TEST in an illegal context."))
    (matchp body
      ((bar code require-tos-valid)
       (compiler:emit-block-read-test bar code
				      (compiler:block-read-test-pframe-tag pframe)
				      pframe require-tos-valid)
       (reconcile-destinations *destination-ignore* destination))
      (* (phase-1-bad-form)))))

;;; (for a good laugh, look at optimize.lisp to see what we're undoing here)
;(deftransformer (atom atom-transformer) (form)
;  (if (= (length form) 2)
;      `(not (listp . ,(cdr form)))
;      form))
;
;
;;;; A transformer with no apparent use.  The IGNORE function.
;;;;
;;;; The following is needed to keep from executing the L-machine transformer that un-does the
;;;; ATOM-TO-LISTP transformer (thus causing an  loop).
;(deftransformer (listp listp-to-atom-blocker) (form)
;  form)

(deftransformer (sys:%finish-stack-list finish-stack-list-transformer) (form)
  (matchp form
    (('sys:%finish-stack-list n)
     `(progn (sys:%set-cdr-code-1 (%stack-location-internal 0))	;cdr-nil
	     ,(if (numberp n)
		  `(i:sys:%make-pointer i:sys:dtp-list (%stack-location-internal ,n))
		  `(i:sys:%make-pointer-offset i:sys:dtp-list
					     (%stack-location-internal 0)
					     (- ,n)))))
    (* (phase-1-bad-form))))

(deftransformer (sys:%finish-stack-list* finish-stack-list*-transformer) (form)
  (matchp form
    (('sys:%finish-stack-list* n)
     `(progn (sys:%set-cdr-code-2 (%stack-location-internal 1))	;cdr-normal
	     ,(if (numberp n)
		  `(i:sys:%make-pointer i:sys:dtp-list (%stack-location-internal ,n))
		  `(i:sys:%make-pointer-offset i:sys:dtp-list
					     (%stack-location-internal 0)
					     (- ,n)))))
    (*
      (phase-1-bad-form))))


;;; Special handling for functions with built-in instructions that don't
;;; return the correct value (in fact don't return any value)

;;; define-return-value should be used for Lisp functions that are implemented as
;;; no-operand instructions that don't leave anything on the stack.  The
;;; "returns" parameter describes what it is that the Lisp function returns.
;;; It may be an integer to mean that the function returns its Nth argument,
;;; or NIL to mean that the function returns NIL.  Note that if it is an
;;; integer, it is zero-based.

(defmacro define-return-value (name returns &optional instruction-name)
  `(defun (,name phase-1-hook) (body destination)
     (phase-1-return-special-value body destination
				   ',(or instruction-name name) ,returns)))

(define-return-value i:sys::%write-internal-register 0)
(define-return-value i:sys::%coprocessor-write 0)
(define-return-value i:sys::%memory-write nil)
(define-return-value i:sys::%jump nil)
(define-return-value i:sys::%generic-dispatch nil)
(define-return-value i:sys::%message-dispatch nil)
(define-return-value no-op nil)
(define-return-value rplaca 0)
(define-return-value rplacd 0)
(define-return-value rplaca2 1 rplaca)
(define-return-value rplacd2 1 rplacd)
(define-return-value set 1)
;(define-return-value as-1 0)	;handled below
;(define-return-value as-2 0)
(define-return-value store-array-leader 0)
;(define-return-value system:%1d-aset 0)  ;handled below
(define-return-value system:%p-store-contents nil)
(define-return-value system:%p-store-tag-and-pointer nil)
(define-return-value system:%p-store-cdr-and-contents nil)
(define-return-value system:%halt nil)
;(define-return-value system:%block-store-cdr-and-contents nil)
;(define-return-value system:%block-store-tag-and-pointer nil)
(define-return-value system:%instance-set 0)
;(define-return-value system:ftn-as-1 0)
;(define-return-value system:ftn-double-as-1 0)
;(define-return-value system:ftn-load-array-register nil)
;(define-return-value system:set-float-operating-mode 0)
;(define-return-value system:set-float-operation-status 0)
(define-return-value system:fast-aset-1 0)
(define-return-value sys:%block-1-write nil)
(define-return-value sys:%block-2-write nil)
(define-return-value sys:%block-3-write nil)

;Assuming that phase-4 will be able to call the built-in instruction,
;generate a call to destination ignore, along with code to generate the value.
(defun phase-1-return-special-value (body destination instruction-name returns)
  (let ((n-args (length body))
	(arg-to-save (and (destination-usage destination 0) returns))
	(stack-slot nil)
	repush repush-arg repush-arg-source-locator)
    (when (and (or (null arg-to-save) (< arg-to-save n-args))
	       (loop for b in (get-built-in *compiler* instruction-name nil)
		     for opcode = (built-in-opcode b)
		     for n-arguments = (get-opcode-n-args opcode)
		     for n-vals = (get-opcode-n-returned opcode)
		     do
		 (when (and (zerop n-vals)	;Effect only
			    (= n-arguments n-args))
		   (return t))))
      ;; Phase-4 will be able to assemble the built-in instruction, so generate
      ;; a call to destination ignore, along with code to generate the value.
      ;; Pre-allocate a stack slot if necessary
      (when arg-to-save
	(setq repush-arg-source-locator (nthcdr arg-to-save body))
	(setq repush-arg (car repush-arg-source-locator))
	(cond ((or (constant-form-p repush-arg)
		   (and (symbolp repush-arg)
			(loop for arg in (cdr repush-arg-source-locator)
			      always (or (constant-form-p arg)
					 (symbolp arg)))))
	       ;; the best strategy is to repush the arg,
	       ;; if that doesn't screw evaluation order
	       (setq repush t))
	      ((not (zerop arg-to-save))
	       (emit-const 'nil)
	       (setq stack-slot (make-variable (gensym)))
	       (setf (variable-usage-count stack-slot) 1))))
      ;; Push the arguments, saving one underneath them all
      (loop for args on body
	    as arg = (first args)
	    for arg-no from 0
	    do (cond ((or repush (neq arg-no arg-to-save))
		      (phase-1 arg *destination-stack* args nil))
		     ((zerop arg-to-save)
		      (phase-1 arg *destination-stack* args nil)
		      (emit-copy))
		     (t
		      (phase-1 arg *destination-stack* nil nil)
		      (emit-setq stack-slot))))
      (emit-call (external-function instruction-name) n-args *destination-ignore* 'cl:inline)
      ;; Now we have the value on the stack, unless it is nil or the destination is ignore
      ;; I don't think I need a pop-vars of the stack-slot variable
      (cond (repush
	     (phase-1 repush-arg destination repush-arg-source-locator nil))
	    ((null arg-to-save)
	     (reconcile-destinations *destination-ignore* destination))
	    (t
	     (pop-into-destination destination)))
      t)))

;;; Phase-1-handler's

(defun (throw phase-1-handler) (body destination)
  destination					;unused
  (matchp body
    ((tag-form form)
     (phase-1 (matchp form
		(('values-list values-list-form)
		 `(cl:apply #'i:sys:%throw ,tag-form ,values-list-form))
		(* `(multiple-value-call #'i:sys:%throw (values ,tag-form) ,form)))
	      *destination-ignore* body)
     ;; Go ahead and emit this, so that phase-2 knows that following code is dead.
     (emit-throw))
    (* (phase-1-bad-form
	 "Expected a tag to throw to followed by a form to produce values to be thrown"))))

(defun phase-1-multiple-value-call (body destination apply-p)
  (compiler:collecting-interval-instruction (destination)
    (matchp body
      ((function . args)
       ;; figure out what's going on with the args
       (multiple-value-bind (transformed-args n-values-list all-known)
	   (loop with all-known = 0
		 for arg in args
		 as transformed-arg = (transform arg *destination-multiple*)
		 as n-values = (compiler:fixed-number-of-values transformed-arg)
		 collect transformed-arg into transformed-args
		 collect (and (fixp n-values) n-values) into n-values-list
		 do (when all-known
		      (if (fixp n-values)
			  (incf all-known n-values)
			  (setq all-known nil)))
		 finally (return
			   (values transformed-args n-values-list all-known)))
	 (let* ((function-known (and (not apply-p)
				     (cl:consp function)
				     (cl:member (first function) '(quote function))
				     (cl:consp (cl:rest function))
				     (null (cl:rest (cl:rest function)))
				     (validate-function-spec (second function))
				     (si:definition-has-location-p (second function))
				     (second function)))
		(local (and function-known
			    (eql (first function) 'function)
			    (si:local-function-definition (second function)
							  *interpreter-lexical-environment*)))
		(known-function (and (not local) function-known))
		(values-wanted (and (eql known-function 'values)
				    (destination-n-values destination)))
		(variable (and (cdr (cl:member nil n-values-list))
			       (progn (emit-const nil)
				      (make-variable (gensym)))))
		(variable-set nil)
		(multiple-group-on-stack nil)
		(start-saved-multiple nil)
		(fixed-values-so-far 0)
		(fixed-values-since-start-saved-multiple 0))

	   (when known-function
	     ;; Do type checking
	     (multiple-value-bind (return-type for-effect)
		 (compiler:function-return-type known-function)
	       (when (and for-effect
			  (not (eql 0 (destination-n-values destination))))
		 (phase-1-warning
		   "Compiling a call to ~A for value even though its value is not defined."
		   (function-pr function)))
	       (compiler:check-types-compatible destination return-type)))

	   (with-new-control-stack-state
	     (flet ((handle-arguments ()
		      ;; Now get the arguments on the stack.
		      (loop while transformed-args do
			(let* ((arg (pop transformed-args))
			       (n-values (pop n-values-list)))
			  (cond (n-values
				 (let ((n-this-time n-values))
				   (when values-wanted
				     (setq n-this-time
					   (min n-this-time
						(- values-wanted fixed-values-so-far))))
				   (let-if multiple-group-on-stack
					   ((compiler:*pframe*
					      (let ((pframe
						      (compiler:make-saved-multiple-pframe
							:saved-multiple-offset
							fixed-values-since-start-saved-multiple
							:saved-multiple-variable variable)))
						(push pframe 
						      (compiler:start-saved-multiple-pframes
							start-saved-multiple))
						pframe)))
				     (phase-1 arg (compiler:values-destination n-this-time)
					      args nil))
				   (incf fixed-values-so-far n-this-time)
				   (when start-saved-multiple
				     (incf fixed-values-since-start-saved-multiple n-this-time))
				   (when (and variable (null transformed-args))
				     ;; all this code is done in an invalid pframe, so it better
				     ;; not unwind
				     (compiler:note-variable-reference variable)
				     (emit-var variable)
				     (emit-kludge-stack -1)
				     (when (> fixed-values-so-far 0)
				       (emit-kludge-stack 1)	; for the multiple count
				       (emit-const fixed-values-so-far)
				       (emit-call (external-function '+-internal) 2 *destination-stack*)
				       (emit-kludge-stack -1)))))
				(t
				 (when (and (not multiple-group-on-stack)
					    variable)
				   (setq start-saved-multiple
					 (compiler:emit-start-saved-multiple nil)))
				 (let-if multiple-group-on-stack
					 ((compiler:*pframe*
					    (let ((pframe
						    (compiler:make-saved-multiple-pframe
						      :saved-multiple-offset
						      fixed-values-since-start-saved-multiple
						      :saved-multiple-variable variable)))
					      (push pframe 
						    (compiler:start-saved-multiple-pframes
						      start-saved-multiple))
					      pframe)))
				   (phase-1 arg *destination-multiple* args nil))
				 (unless multiple-group-on-stack
				   (setq multiple-group-on-stack t)
				   (compiler:push-control-stack-state)
				   (note-unknown-group *control-stack-state*))
				 ;; all this code is done in an invalid pframe, so it better
				 ;; not unwind
				 (when variable-set
				   ;; add the current multiple count to the running count
				   (emit-kludge-stack 1)	; for the multiple count
				   (compiler:note-variable-reference variable)
				   (emit-var variable)
				   (emit-call (external-function '+-internal) 2 *destination-stack*)
				   (emit-kludge-stack -1))
				 (cond (transformed-args
					(emit-kludge-stack 1)	; for the multiple count
					(compiler:note-variable-reference variable nil)
					(emit-setq variable)
					(setq variable-set t)
					(emit-pop))
				       ((> fixed-values-so-far 0)
					(emit-kludge-stack 1)	; for the multiple count
					(emit-const fixed-values-so-far)
					(emit-call (external-function '+-internal) 2 *destination-stack*)
					(emit-kludge-stack -1)))))))))

	       (cl:case known-function
		 ((values)
		  (handle-arguments)
		  (cond ((and values-wanted all-known)
			 (reconcile-destinations (compiler:values-destination fixed-values-so-far) destination))
			(t
			 (when all-known
			   (emit-const fixed-values-so-far)
			   (emit-kludge-stack -1))
			 (unless (zerop fixed-values-so-far)
			   (emit-kludge-stack (- fixed-values-so-far)))	; fixed args
			 (reconcile-destinations *destination-multiple* destination))))

		 (otherwise
		   ;; Get the function to be called on the stack.
		   (when (and (or (null all-known)
				  (> all-known *maximum-rest-arg-size*))
			      (not (cl:member known-function *funcalling-functions*)))
		     ;; must use funcall
		     (push (transform function *destination-stack*) transformed-args)
		     (push 1 n-values-list)
		     (setf known-function 'funcall))
		   (multiple-value-bind (call-start-name inline-p)
		       (cond ((and all-known
				   (not apply-p)
				   known-function
				   (sys:validate-function-spec known-function)
				   (si:definition-has-location-p known-function))
			      (values (external-function known-function)
				      (if (cl:member known-function *funcalling-functions*)
					  'cl:notinline
					  nil)))
			     (t
			      (if (cl:member known-function *funcalling-functions*)
				  (emit-fun (external-function known-function))
				  ;; The bindings are so downward funarg handling will work.
				  (let ((*function-name* 'multiple-value-call)
					(*argno* 0))
				    (phase-1 function *destination-stack* body 't 't)))
			      (values (external-function
					(if all-known
					    (if apply-p 'cl:apply 'funcall)
					    (if apply-p '%lexpr-funcall-n '%funcall-n)))
				      'cl:inline)))
		     (let* ((start-call (emit-start-call call-start-name destination))
			    (compiler:*pframe*
			      (make-open-call-pframe :open-call-start-call start-call)))
		       (incf compiler:*multiple-count*)
		       (note-unknown-group *control-stack-state*)
		       (handle-arguments)
		       ;; Actually call the function.
		       (cond (all-known
			      (emit-call call-start-name fixed-values-so-far destination inline-p start-call))
			     (t
			      (unless (zerop fixed-values-so-far)
				(emit-kludge-stack (- fixed-values-so-far)))	; fixed args
			      (emit-call call-start-name 1 destination inline-p start-call)))))))))

	   (when (and variable (not (destination-for-return destination)))
	     (compiler:emit-pop-vars (list variable) destination)))))
      (* (phase-1-bad-form)))))

(defun (return-kludge phase-1-handler) (body destination)
  (declare (ignore destination))
  (matchp body
    ((arg)
     (phase-1 arg *destination-multiple* body)
     (emit-call (external-function 'return-kludge) 1 *destination-ignore*))
    (* (phase-1-bad-form "Bad RETURN-KLUDGE form"))))

(defun (cli::%return-kludge phase-1-handler) (body destination)
  (declare (ignore destination))
  (matchp body
    ((arg)
     (phase-1 arg *destination-stack* arg)
     (emit-call (external-function 'return-kludge) 1 *destination-ignore*))
    (* (phase-1-bad-form "Bad %RETURN-KLUDGE form"))))

#+Ivory-Rev-1
(deftransformer (i:sys:%return-kludge-0 transform-%return-kludge-0) (form)
  (compiler:matchp form
    ((ignore)
     '(return-kludge
	(prog1 (i:sys:%read-internal-register i:sys:%register-continuation)
	       (setf (i:sys:%read-internal-register i:sys:%register-continuation)
		     si:*return-kludge-0-helper-continuation*)
	       (i:compiler:no-op)
	       (i:compiler:no-op))))
    (* (compiler:phase-1-bad-form))))

(defun (%fep-return-kludge-0 phase-1-handler) (body destination)
  (declare (ignore destination))
  (matchp body
    (()
     (let ((tag (make-tag 'go)))
       (phase-1-constant i:sys:%register-continuation *destination-stack*)
       (emit-call (external-function 'i:sys:%read-internal-register) 1 *destination-stack*)
       (compiler:emit-push-pc tag)
       (phase-1-constant i:sys:%register-continuation *destination-stack*)
       (emit-call (external-function 'i:sys:%write-internal-register) 2 *destination-ignore*)
       (emit-call (external-function 'i:compiler:no-op) 0 *destination-ignore*)
       (emit-call (external-function 'i:compiler:no-op) 0 *destination-ignore*)
       (phase-1-constant 1 *destination-stack*)
       (emit-call (external-function 'return-kludge) 1 *destination-ignore*)
       (emit-tag tag)
       (emit-kludge-stack 1)
       (emit-call (external-function 'i:sys:%jump) 1 *destination-ignore*)
       ))))

(defun (cli::%return-multiple phase-1-handler) (body destination)
  (declare (ignore destination))
  ;; >>> I really prefer the syntax (%RETURN-MULTIPLE N), but the L-machine defines
  ;;     it as a function of no arguments, always taking the top-of-stack, so we'll
  ;;     go along with that for the time being. <<<
  (matchp body
    (()
     (emit-call (external-function 'return-multiple) 1 *destination-ignore*))
    (* (phase-1-bad-form "Bad %RETURN-MULTIPLE form"))))

(defun (sys:%block-0-read-alu phase-1-handler) (body destination)
  (phase-1-block-read-alu 'sys:%block-0-read-alu body destination))

(defun (sys:%block-1-read-alu phase-1-handler) (body destination)
  (phase-1-block-read-alu 'sys:%block-1-read-alu body destination))

(defun (sys:%block-2-read-alu phase-1-handler) (body destination)
  (phase-1-block-read-alu 'sys:%block-2-read-alu body destination))

(defun (sys:%block-3-read-alu phase-1-handler) (body destination)
  (phase-1-block-read-alu 'sys:%block-3-read-alu body destination))

(defun phase-1-block-read-alu (function body destination) 
  (unless (= (length body) 1) (phase-1-bad-form))
  (let ((var-name (first body)))
    (unless (symbolp var-name) (phase-1-bad-form))
    (let ((var (lookup-variable var-name)))
      (selectq (variable-type var)
	(lexical
	 (setf (compiler:lexical-modified-p var) t)
      	 (emit-var var)
	 (emit-call (external-function function) 1 destination 'cl:inline))
	(otherwise
	 (phase-1-bad-form "The argument to ~S must be a local variable." function))))))

(defun (%push-n phase-1-handler) (body destination)
  (declare (ignore destination))
  (compiler:matchp body
    ((value)
     (emit-kludge-stack value))
    (* (phase-1-bad-form "Bad %push-n form"))))

(defun (%instruction phase-1-handler) (body destination)
  (compiler:matchp body
    ((value)
     (emit-macro-instruction nil nil value destination))
    ((opcode-name operand-spec)
     (let* ((opcode (symeval (intern (string-append "*" opcode-name "-OPCODE*")
				     (symbol-package '*car-opcode*))))
	    (operand
	      (typecase operand-spec
		(:fixnum operand-spec)
		(:list
		  (let ((mode (first operand-spec))
			(arg (second operand-spec)))
		    (if (string-equal mode "SP")
			(dpb i:sys:stack-addressing-mode-stack-pointer
			     i:sys:%%packed-instruction-addressing-mode
			     (if (numberp arg)
				 (+ arg 255.)
				 (if (and (symbolp arg)
					  (string-equal arg "POP"))
				     0
				     (phase-1-bad-form "Bad %INSTRUCTION operand"))))
			(dpb (selector mode string-equal
			       ("FP" i:sys:stack-addressing-mode-frame-pointer)
			       ("LP" i:sys:stack-addressing-mode-local-pointer)
			       ("IM" i:sys:stack-addressing-mode-immediate))
			     i:sys:%%packed-instruction-addressing-mode
			     (dpb arg i:sys:%%packed-instruction-8-bit-operand 0)))))
		(otherwise (phase-1-bad-form "Bad %INSTRUCTION operand")))))
       (emit-macro-instruction opcode operand nil destination)))
    (((form))
     (emit-macro-instruction nil nil (phase-1 form *destination-stack* body) destination))
    (* (phase-1-bad-form))))

(defun (inline-getf phase-1-handler) (body destination)
  (matchp body
    ((indicator plist default-form)
     (let ((done-tag (make-tag)))
       (phase-1 indicator *destination-stack* body)
       (phase-1 plist *destination-stack* (cdr body))
       (emit-call (external-function 'rgetf) 2 *destination-stack-double* t)
       (cond ((and default-form (not (equal default-form ''nil)))
	      (compiler:emit-jump 'true done-tag 1 2)
	      (phase-1 default-form *destination-stack* (cddr body))
	      (emit-tag done-tag))
	     (t (emit-pop 1)))
       (pop-into-destination destination)))
    (* (phase-1-bad-form "Bad INLINE-GETF form"))))
