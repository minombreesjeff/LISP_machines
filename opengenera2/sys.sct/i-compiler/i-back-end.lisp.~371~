;;; -*- Mode: Lisp; Package: I-LISP-COMPILER; Lowercase: T; Base: 10  ; Syntax: Zetalisp -*-   13-May-1985
;;; This file contains the compiler back end for the I architecture.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; 
;;;

;;; This file contains the functions that assemble byte-lap (i.e.
;;; intermediate representation) into I-architecture instructions. 
;;; Refer to the I machine architecture documents for details.

;;;; Building of the compiled code object.

;;; In general, a given compiled code object is made of many
;;; instruction-arrays.  There is one top-level array, which is the main
;;; code of the function.  Other instruction-arrays can be created
;;; for dispatching instructions, such as argument-takers and selectq,
;;; as well as for quick internal functions.  These form a hierarchy,
;;; which gains depth when a clause of a dispatch contains another
;;; dispatch or a quick internal function definition, etc.  At the end
;;; of processing a given function and all of its quick internal descendants,
;;; the instruction-arrays are all merged into the top-level one.
;;;   instruction-array-parent: An instruction-array, the parent in the hierarchy.
;;;   instruction-array-offset: The location in the parent instruction-array at
;;;   which this instruction array is merged.  0 for the top-level one.
(defstruct (instruction-array :named :array-leader)
  instruction-array-fill-pointer
  instruction-array-parent
  instruction-array-offset
  instruction-array-tags
  instruction-array-oddp			;There is an available odd half-word
  instruction-array-fullp			;The last instruction pushed was a full-word
  instruction-array-current-pc			;The PC of the last instruction assembled
  )

;;; >>> Maybe we should just put the one that's currently L-specific into the
;;;     cross-compiler substrate. <<<
(defstruct (source-locator-array :named :array-leader)
  source-locator-array-fill-pointer
  source-locator-array-parent
  source-locator-array-offset
  )

(defun copy-instruction-array (instruction-array)
  (let* ((length (array-active-length instruction-array))
	 (instruction-tags (instruction-array-tags instruction-array))
	 (it (make-array length :type art-8b :initial-value 0 :fill-pointer length))
	 (ia (make-instruction-array
	       :make-array (:length length :initial-value 0)
	       instruction-array-tags it
	       instruction-array-fill-pointer length)))
    (copy-array-contents instruction-tags it)
    (copy-array-contents instruction-array ia)
    ia))

;;; Find the location in the top-level instruction array at which this instruction
;;; array is merged.
(defun instruction-array-total-offset (instruction-array)
  (loop for ia = instruction-array then (instruction-array-parent ia) until (null ia)
	sum (instruction-array-offset ia)))

(defresource instruction-arrays ()
  :constructor (make-instruction-array
		 :make-array (:length 1000 :initial-value 0)
		 instruction-array-tags (make-array 1000 :type 'art-8b :initial-value 0
						    :fill-pointer 0))
  :deinitializer (cl:fill object nil))

(defresource source-locator-arrays ()
  :constructor (make-source-locator-array :make-array (:length 2000)))

(defvar *all-instruction-arrays*)
(defvar *all-source-locator-arrays*)

(defun allocate-instruction-arrays (parent-instruction-array parent-source-locator-array)
  (let ((ia (allocate-resource 'instruction-arrays))
	(sa (if *use-source-locators* (allocate-resource 'source-locator-arrays))))
    (setf (fill-pointer ia) 0)
    (setf (fill-pointer (instruction-array-tags ia)) 0)
    (setf (instruction-array-oddp ia) nil)
    (setf (instruction-array-fullp ia) nil)
    (setf (instruction-array-parent ia) parent-instruction-array)
    (setf (instruction-array-offset ia) 0)
    (push ia *all-instruction-arrays*)
    (when *use-source-locators*
      (setf (fill-pointer sa) 0)
      (setf (source-locator-array-parent sa) parent-source-locator-array)
      (setf (source-locator-array-offset sa) 0)
      (push sa *all-source-locator-arrays*))
    (values ia sa)))

(defun deallocate-instruction-arrays ()
  (dolist (ia *all-instruction-arrays*)
    (deallocate-resource 'instruction-arrays ia))
  (setq *all-instruction-arrays* nil)
  (when *use-source-locators*
    (dolist (ia *all-source-locator-arrays*)
      (deallocate-resource 'source-locator-arrays ia)))
  (setq *all-source-locator-arrays* nil))

(defun get-opcode-and-operand (half-word-index &optional (ia *instruction-array*))
  (let* ((full-word-index (ash half-word-index -1))
	 (data (aref ia full-word-index))
	 (tag (aref (instruction-array-tags ia) full-word-index))
	 (type (ldb i:sys:%%q-type-within-tag tag)))
    (if (= (dpb 0 (byte 4 0) type)
	   i:sys:dtp-packed-instruction-60)
	(let ((instruction (if (evenp half-word-index)
			       (ldb (byte 18. 0) data)
			       (dpb (ldb (byte 4 0) tag) (byte 4 14.)
				    (ldb (byte 14. 18.) data)))))
	  (values (i-inst-opcode instruction)
		  (i-inst-10-bit-immediate-operand instruction)))
	(ferror "Asking for opcode and operand of a constant.  Type is ~S"
		(nth type i:sys:*data-types*)))))

(defun set-opcode-and-operand (half-word-index opcode operand
			       &optional ia (error-p t))
  (or ia (setq ia *instruction-array*))
  (let* ((full-word-index (ash half-word-index -1))
	 (data (aref ia full-word-index))
	 (tags (instruction-array-tags ia))
	 (tag (aref tags full-word-index))
	 (type (ldb i:sys:%%q-type-within-tag tag)))
    (unless (= (dpb 0 (byte 4 0) type) i:sys:dtp-packed-instruction-60)
      (if error-p
	  (ferror "Trying to change an instruction opcode in a full-word instruction.")
	  ;; The caller will set the other half, so just bash the full data type now.
	  ;; Leave the sequencing alone.
	  (setf (ldb i:sys:%%q-type-within-tag type)
		i:sys:dtp-packed-instruction-60)
	  (setf (aref tags full-word-index) type)))
    (cond ((evenp half-word-index)
	   (setf (aref ia full-word-index)
		 (dpb opcode (byte 8 10.)
		      (dpb operand (byte 10. 0) data))))
	  (t (setf (aref ia full-word-index)
		   (%logdpb (ldb (byte 4 0) opcode) (byte 4 28.)
			    (dpb operand (byte 10. 18.) data)))
	     (setf (aref tags full-word-index)
		   (dpb (ldb (byte 4 4) opcode) (byte 4 0) tag))))))

(defun get-tag-and-data (half-word-index &optional (ia *instruction-array*))
  (let ((word-index (lsh half-word-index -1)))
    (values (aref (instruction-array-tags ia) word-index)
	    (aref ia word-index))))

(defun set-tag-and-data (half-word-index tag data &optional (ia *instruction-array*))
  (let ((word-index (lsh half-word-index -1))
	(tags (instruction-array-tags ia)))
    (setf (aref tags word-index) tag)
    (setf (aref ia word-index) data)))

(defun push-tag-and-data (tag data &optional (ia *instruction-array*))
  (array-push-extend (instruction-array-tags ia) tag)
  (array-push-extend ia data))

(defun instruction-array-current-offset (&optional (ia *instruction-array*))
  (instruction-array-fill-pointer ia))

(defun set-pc-sequencing (half-word-index pc-sequencing &optional (ia *instruction-array*))
  (let* ((word-index (lsh half-word-index -1))
	 (tags (instruction-array-tags ia))
	 (tag (aref tags word-index)))
    (setf (aref tags word-index) (dpb pc-sequencing i:sys:%%q-cdr-code-within-tag tag))))

(defun set-pc-instructions (even-pc sequencing even-opcode even-operand odd-opcode odd-operand)
  (let ((odd (dpb odd-opcode %%packed-instruction-opcode odd-operand)))
    (set-tag-and-data
      even-pc
      (dpbs sequencing %%q-cdr-code-within-tag
	    (ldb %%odd-instruction-tag-component odd) %%q-odd-instruction-within-tag
	    dtp-packed-instruction-60)
      (%logdpbs (ldb %%odd-instruction-data-component odd) %%q-odd-instruction-within-pointer
		even-opcode %%packed-instruction-opcode
		even-operand))))


;;; >>> This stuff might belong more rightly in I-ASSEMBLE. <<<

(defvar *offsetted-opcodes*
	`(,*push-lexical-var-opcode* ,*movem-lexical-var-opcode* ,*pop-lexical-var-opcode*))

(defun operand-bits (type value)
  (selectq type
    ((entry relative-pc byte 10-bit-immediate)
     value)
    (12-bit-unsigned-immediate
     (ldb (byte 10. 0) value))
    (nil 0)
    (otherwise
     (let ((pointer (if (memq type *immediate-operand-types*)
			i:sys:stack-addressing-mode-immediate
			(cl:ecase type
			  (frame-pointer i:sys:stack-addressing-mode-frame-pointer)
			  (local-pointer i:sys:stack-addressing-mode-local-pointer)
			  (stack-pointer i:sys:stack-addressing-mode-stack-pointer)
			  (immediate     i:sys:stack-addressing-mode-immediate)))))
       (dpb pointer (byte 2 8) value)))))

(defun half-word-instruction-bits (opcode operand &optional qual)
  (let* ((type (i-abstract-operand-type operand))
	 (value (i-abstract-operand-value operand)))
    ;; First, fixup opcodes that need it.
    (when (memq opcode *offsetted-opcodes*)
      (incf opcode qual))
    (when (eq type '12-bit-unsigned-immediate)
      (setq opcode (dpb (ldb (byte 2 10.) value) (byte 2 0) opcode)))
    (dpb opcode (byte 8 10.)
	 (dpb (operand-bits type value) (byte 10. 0) 0))))

;;; Some general purpose functions and macros
(defmacro tos-operand ()
  '(i-op stack-pointer 255))
(defmacro tos-pop-operand ()
  '(i-op stack-pointer 0))
(defmacro sp-operand (offset)
  `(i-op stack-pointer (- 255 ,offset)))

(defconst *no-op-instruction-bits* (half-word-instruction-bits *movem-opcode* (sp-operand 0)))
(defconst *branch-instruction-bits* (half-word-instruction-bits *branch-opcode*
								(i-op signed 0)))
(defsubst cdr-code-bits (sequencing length)
  (selectq sequencing
    ((:normal :entry)
     (if (= 1 length)
	 i:sys:sequencing-pc+1
	 i:sys:sequencing-pc-even+2-odd+3))
    (:packed (if (= 1 length)
		 i:sys:sequencing-pc-even+2-odd+3
		 i:sys:sequencing-pc-1))
    (:fence i:sys:sequencing-fence)))


(defun use-stack-addressing-p (variable level location)
  (let ((function (lexical-function variable)))
    (cond ((not (lexical-stack-resident-p variable))
	   ;; Variable resides in local block; always use the frame or local pointer.
	   (values nil location))
	  ((and (eq function *frame-function*)
		(zerop (lexical-multiple-count variable))
		(let ((control-stack-state (lexical-control-stack-state variable)))
		  (or (null control-stack-state)
		      (zerop (control-stack-state-unknown-group-count control-stack-state)))))
	   ;; Variable is pushed by our frame-function, and so its location
	   ;; is fixed with respect to the frame or local pointer.
	   (values nil location))
	  ((or (eq function *function*) (eq function *frame-function*))
	   ;; Variable is pushed by this function itself, and so its location
	   ;; if fixed with respect to the stack pointer.
	   (values t (- level location)))
	  (t
	   (llc-error "Cannot address the variable ~S" variable)))))

(defun local-operand (var level &optional (var-offset 0))
  (multiple-value-bind (stack-p offset)
      (use-stack-addressing-p var level (lexical-location var))
    (let ((operand (if stack-p
		       (sp-operand (1- (+ offset var-offset)))
		       (lexical-var-operand var var-offset))))
      (setf (i-abstract-operand-variable-referenced operand) var)
      operand)))

(defun possible-immediate-operand? (constant &optional (immediate-type 'unsigned))
  (and (typep constant ':fixnum)
       (let ((length (cl:integer-length constant)))
	 (selectq immediate-type
	   (byte ( length 10.))
	   (signed ( length 7.))
	   (unsigned (and ( length 8.) ( constant 0)))
	   (10-bit-immediate ( length 10.))
	   (12-bit-unsigned-immediate (and ( length 12.) ( constant 0)))
	   (otherwise (ferror "Illegal operand type"))))))

(defun lexical-var-operand (var &optional (var-offset 0))
  ;; >>> Doesn't handle free or captive lexicals at the moment.  1-July-1985 MBell <<<
  (let ((loc (+ (lexical-location var) var-offset))
	(fun (function-frame-owner (lexical-function var))))
    ;; Unless we have a rest arg, we can always use FP.
    (if (or (zerop (ldb %%arg-desc-rest-arg (function-args-info fun)))
	    ;; There is a rest arg, but arguments can still be referenced
	    ;; relative to FP.
	    (and (lexical-argument-p var)
		 (not (lexical-rest-arg-p var))))
	(i-op frame-pointer (+ 2 loc))
	(if (lexical-rest-arg-p var)
	    ;; If there is an environment argument, UPDATE-ARG-VARIABLE will add 1 to
	    ;; the location of each argument.  This is fine on the L machine where
	    ;; the &REST arg is just like all the others, but isn't very good on the
	    ;; I machine, so we force the rest-arg to be 0 always.  KLUDGE!!!
	    (i-op local-pointer 0)
	    (i-op local-pointer loc)))))

(defun lexical-variable-environment-offset (var)
  (if (lexical-rest-arg-p var)
      0
      (lexical-location var)))

(defun set-tag-addresses (index)
  ;; If we have tags whose addresses have not yet been set (remember that sequencing
  ;; makes it difficult to figure out the address at the time the tag is seen), then
  ;; set the address now.
  (loop for tag in *all-tags*
	    until (tag-address tag)
	    do
	(setf (tag-address tag) index)))

(defun assemble (opcode operand &optional qual)
  (declare (values half-word-index))
  (let* ((attributes (get-opcode-attributes opcode))
	 (needs-tos (or (cl:member ':needs-tos attributes)
			;; RETURN-SINGLE-TOS needs TOS valid
			(and (eql opcode *return-single-opcode*)
			     (equal operand (i-op 10-bit-immediate i:sys:%register-tos))))))
    (if (and *needs-lp* (cl:member ':smashes-lp attributes))
	(assemble-1 *movem-opcode* (sp-operand 0))
	(when needs-tos
	  (cond (*stack-smashed*
		 (let ((tag-index (assemble-1 *movem-opcode* (sp-operand 0))))
		   (set-tag-addresses tag-index)))
		(t (dolist (tag *tos-tags*)
		     (setf (tag-tos-status tag) 'used))
		   (setf *tos-tags* nil)))))
    (setq *needs-lp*
	  (and (cl:member ':needs-lp attributes)
	       (eq (i-abstract-operand-type operand) 'local-pointer)))
    (let* ((index (assemble-1 opcode operand qual))
	   (tos-unchanged (memq :tos-unchanged attributes))
	   (sets-tos (and tos-unchanged
			  (eq (i-abstract-operand-type operand) 'stack-pointer)
			  (eql (i-abstract-operand-value operand) 0))))
      (unless (and tos-unchanged (not sets-tos))
	(dolist (tag *tos-tags*)
	  (setf (tag-tos-status tag) 'not-used))
	(setf *tos-tags* nil))
      ;; All FINISH-CALL instructions effectively clobber TOS if they're for effect.
      ;; Otherwise set *stack-smashed* from OPDEF information.
      (cond (tos-unchanged
	     (when sets-tos
	       (setf *stack-smashed* t)))
	    ((memq :clobbers-tos attributes)
	     (setf *stack-smashed* t))
	    ((memq :finish-call attributes)
	     (setf *stack-smashed*
		   (eql (ldb (byte 2 8) (I-abstract-operand-value operand))
			I:sys:value-disposition-effect)))
	    (t
	     (setf *stack-smashed* nil)))
      (set-tag-addresses index)
      (setf (instruction-array-current-pc *instruction-array*) index)
      index)))

(defun assemble-1 (opcode operand &optional qual)
  "Side-effects *INSTRUCTION-ARRAY*"
  (declare (values half-word-index))
  (flet ((add-locator (index)
	   (when *use-source-locators*
	     (when ( index (array-length *source-locator-array*))
	       (setq *source-locator-array*
		     (adjust-array-size *source-locator-array* (+ index 400))))
	     (setf (aref *source-locator-array* index) *source-locator*)
	     (scl:maxf (fill-pointer *source-locator-array*) index))
	   ;; Return the index
	   index))
    (let ((tags-array (instruction-array-tags *instruction-array*))
	  (oddp (instruction-array-oddp *instruction-array*))
	  (fullp (instruction-array-fullp *instruction-array*)))
      (let ((bits (half-word-instruction-bits opcode operand qual)))
	;; See if we can improve on the sequencing
	(if oddp
	    (let* ((idx (1- (fill-pointer *instruction-array*)))
		   (data (aref *instruction-array* idx))
		   (tag (aref tags-array idx)))
	      (setf (instruction-array-oddp *instruction-array*) nil)
	      (cond (fullp
		     ;; Previous instruction was full-word - go back another word
		     (let* ((prev-idx (1- idx))
			    (prev-data (aref *instruction-array* prev-idx))
			    (prev-tag  (aref tags-array prev-idx)))
		       (unless (= (ldb (byte 2 4) prev-tag)
				  (ldb (byte 2 4) i:sys:dtp-packed-instruction-60))
			 (ferror "Internal compiler error - no free odd half-word."))
		       (setf (aref *instruction-array* prev-idx)
			     (%logdpb (ldb (byte 14. 0) bits)
				      (byte 14. 18.) prev-data))
		       (setf (aref tags-array prev-idx)
			     (dpb (ldb (byte 4 14.) bits) (byte 4 0) prev-tag))
		       ;; Update the full-word's sequencing.
		       (setf (aref tags-array idx)
			     (dpb i:sys:sequencing-pc-1
				  i:sys:%%q-cdr-code-within-tag tag))
		       ;; Return instruction index
		       (add-locator (1+ (* prev-idx 2)))))
		    ;; Previous instruction was half-word
		    (t
		     (let ((entryp (cl:member opcode '(#.*entry-rest-accepted-opcode*
						       #.*entry-rest-not-accepted-opcode*))))
		       ;; Special-case odd entry-instruction
		       (when entryp
			 (setq bits (dpb 0 (byte 10. 8) bits)))	;Zero the OPCODE field
		       ;; Previous instruction was half-word, just use the high bits
		       (setf (aref *instruction-array* idx)
			     (%logdpb (ldb (byte 14. 0) bits) (byte 14. 18.) data))
		       (setf (aref tags-array idx)
			     (dpb (ldb (byte 4 14.) bits) (byte 4 0)
				  (if entryp
				      tag
				    ;; Change the sequencing to "normal" - see below
				    ;; that it starts off assuming PC+2
				    (dpb i:sys:sequencing-pc+1
					 i:sys:%%q-cdr-code-within-tag tag))))
		       (add-locator (1+ (* idx 2)))))))
	  ;; If we get here, there is no accessible free odd half
	  (let ((full-word-address 
		  (array-push-extend *instruction-array*
				     (%logdpb *no-op-instruction-bits* (byte 14. 18.) bits)
				     400)))
	    (array-push-extend
	      tags-array
	      ;; Start off assuming that we won't be able to fill the
	      ;; empty half-word - this makes things a bit simpler above.
	      (dpb i:sys:sequencing-pc-even+2-odd+3 i:sys:%%q-cdr-code-within-tag
		   (dpb (ldb (byte 4 14.) *no-op-instruction-bits*) (byte 4 0)
			i:sys:dtp-packed-instruction-60))
	      400)
	    ;; Don't forget to indicate that we have a spare half-word available!
	    (unless oddp
	      (setf (instruction-array-oddp *instruction-array*) t))
	    ;; And that the last thing pushed was a half-word
	    (when fullp
	      (setf (instruction-array-fullp *instruction-array*) nil))
	    ;; Return half-word address
	    (add-locator (* 2 full-word-address))))))))

(defun assemble-constant (data-type operand)
  (let ((tags-array (instruction-array-tags *instruction-array*))
	(oddp (instruction-array-oddp *instruction-array*))
	(fullp (instruction-array-fullp *instruction-array*)))
    (if fullp
	;; Note that odd half-word is no longer accessible - because there was
	;; already a full-word after it.
	(when oddp
	  (setf (instruction-array-oddp *instruction-array*) nil))
	(setf (instruction-array-fullp *instruction-array*) t))
    (when (memq data-type
		#+3600'(i:sys:dtp-even-pc i:sys:dtp-odd-pc)
		#+IMACH'(dtp-even-pc dtp-odd-pc))
      ;; Convert from half-word offset within function to full-word.  Will
      ;; need to be fixed up at link time to be a real VMA.
      ;; >>> Oops - operand is probably still NIL. <<<
;      (setq operand (ash operand -1))
      (setq operand 1))
    (let* ((full-word-address (array-push-extend *instruction-array* operand 400))
	   (address (* 2 full-word-address)))
      (array-push-extend
	tags-array
	;; At this point we always assume normal sequencing - if the next instruction
	;; is resequenced, then the cdr-code will get fixed up there.
	(dpb i:sys:sequencing-pc-even+2-odd+3 i:sys:%%q-cdr-code-within-tag
	     data-type))
      ;; Fixup tags
      (set-tag-addresses address)
      ;; Save index away - I guess this means that we really need something at a higher
      ;; level of abstraction for adding things to the instruction-array.
      (setf (instruction-array-current-pc *instruction-array*) address)
      ;; All the full word instructions leave TOS valid.
      (setq *stack-smashed* nil)
      (dolist (tag *tos-tags*)
	(setf (tag-tos-status tag) 'not-used))
      (setf *tos-tags* nil)
      ;; Return half-word address
      address)))

(defun note-branch (type jump-address tag &optional (instruction-array *instruction-array*)
		    				    must-be-single-instruction)
  (let ((branch (make-branch :branch-type type
			     :branch-tag tag
			     :branch-pre-address jump-address
			     :branch-post-address jump-address
			     :branch-extra 0
			     :branch-instruction-array instruction-array
			     :branch-must-be-single-instruction must-be-single-instruction)))
    (push branch *all-branches*)
    branch))

(defun note-tag (tag &optional location (instruction-array *instruction-array*))
  ;; If LOCATION is not supplied, we'll have to fix up the address after when we assemble
  ;; the next instruction since pc sequencing and inline constants make it very difficult
  ;; to determine here what the actual index will be.
  (setf (tag-address tag) location)		;If not supplied, will be fixed up later
  (setf (tag-instruction-array tag) instruction-array)
  (push tag *all-tags*)
  (if *stack-smashed*
      (setf (tag-tos-status tag) 'not-used)
      (push tag *tos-tags*)))


;;; Subroutines of the assemble functions.
(defun assemble-special-location (name &optional (dtp i:sys:dtp-locative))
  (let ((cell (locf (symbol-value-cell name))))
    (when *phase-4-to-core*
      (si:forward-symbol-cell cell))
    (assemble-constant dtp (follow-cell-forwarding cell nil))))

(defun reference-function-spec (fspec index)
  (unless (symbolp fspec)
    (let ((pair))
      (if (setq pair (assoc fspec *fdefinition-location-hints*))
	  (push index (cdr pair))
	  (push (list fspec index) *fdefinition-location-hints*)))))

(defun function-call-starter-instruction (spec &optional force-indirect)
  ;; This may eventually need to be hairier
  (let ((index 
	  (if (and (not force-indirect)
		   (memq spec *funcalling-functions*))
	      (assemble *start-call-opcode* (tos-pop-operand))
	      (assemble-constant
		i:sys:dtp-call-indirect
		(follow-cell-forwarding (fdefinition-location spec t) nil)))))
    (reference-function-spec spec index)
    index))

(defun assemble-normal-start-call (inst &optional force-indirect)
  (let ((pair (assq inst *call-start-alist*))	;See if we've already assembled the finisher
						; this will be of the form:
						; (<start byte-lap> . <finish index>)
	(starter-i
	  (let ((fun (start-call-function inst)))
	    (cl:ecase (function-type fun)
	      ((external reference)
	       (let ((fspec (function-spec fun)))
		 (function-referenced fspec
				      (function-pr (function-frame-owner *function*))
				      (warning-source-locator (inst-source-locator inst)))
		 (when *phase-4-to-core*
		   (when (or (not (fdefinedp fspec))
			     (equal (external-ancestor-function-spec *function*) fspec))
		     (setq *forward-references-exist* t)))
		 (function-call-starter-instruction
		   fspec
		   (or force-indirect (call-force-external (start-call-call inst))))))
	      ((internal)
	       (let ((starter-i (assemble-constant i:sys:dtp-call-compiled-even 0)))
		 (push (cons starter-i inst) *all-pc-tags*)
		 starter-i))
	      ((compiler:interpreter)
	       (assemble-constant
		 i:sys:dtp-call-indirect
		 (compiler:interpreter-function-location fun)))
	      ))))
    (if pair
	;; We've already assembled the finish-call for this starter - change
	;; pair from (<start byte-lap> . <finish index>) to (<start index> . <finish index>)
	(setf (car pair) starter-i)
	;; Normal case - add a placeholder (<start index> . <start byte-lap>) - will be
	;; fixed up by the finish-call assembler
	(push `(,starter-i . ,inst) *call-start-alist*))))

(defun assemble-finish-call-1 (opcode n-args destination)
  (let* ((n-values (destination-n-values destination))
	 (finish-i (assemble opcode (i-op 10-bit-immediate
					  (make-finish-call-n-operand
					    n-args-+1 (1+ n-args)
					    disposition (value-disposition-number
							  (selectq n-values
							    ((0) 0)
							    ((1) 1)
							    (otherwise
							      (if (destination-for-return destination)
								  'return
								  'multiple)))))))))
    (if (destination-for-return destination)
	(when (eql n-values 0)
	  (assemble-return nil))
	(when (and n-values (< 1 n-values))
	  (assemble *take-values-opcode* (i-op unsigned n-values))))
    finish-i))  

(defmethod (assemble-finish-call call-instruction) (&optional (destination call-destination))
  (let* ((n-args call-n-args)
	 (starters call-start-call)
	 (spec (function-spec call-function))
	 (force-external (call-force-external self))
	 (opcode (if force-external
		     *finish-call-n-opcode*
		     (selectq spec
		       (cl:apply *finish-call-n-apply-opcode*)
		       (%funcall-n (setq n-args -1)	;Fake out i-op below
				   *finish-call-tos-opcode*)
		       (%lexpr-funcall-n (setq n-args -1)
					 *finish-call-tos-apply-opcode*)
		       (t *finish-call-n-opcode*))))
	 (finish-i (assemble-finish-call-1 opcode n-args destination)))
    (cond ((null starters)
	   (unless (and (not force-external)
			(memq spec *funcalling-functions*))
	     (ferror "No call starter for this call.")))
	  ((listp starters)
	   ;; Go through all the starters for this finish-call and update the
	   ;; *call-start-alist* database.  The entries we have to fix up are the
	   ;; ones of the form (<start index> . <start byte-lap>).
	   (loop for s in starters
		 for pair = (rassq s *call-start-alist*)
		 for i = (cdr pair)
		 if i
		   ;; We've already assembled this particular starter, change its
		   ;; entry in *call-start-alist* to (<start index> . <finish index>)
		   do (setf (cdr pair) finish-i)
		 else
		   ;; Haven't assembled starter yet, push placeholder onto
		   ;; *call-start-alist*.  This will be fixed up by the start-call
		   ;; assembler.
		   do (push `(,s . ,finish-i) *call-start-alist*)))
	  (t (ferror "Call starters for this call isn't a list")))))

(defun assemble-quick-external-call (inst info)
  inst info ;unused
  (llc-error "Quick external functions are not yet implemented"))

(defun push-constant (value)
  (typecase value
    (:fixnum
      (let ((abs (abs value)))
	(if (< abs 1_8)
	    (let ((op (i-op unsigned abs)))
	      (if (minusp value)
		  (assemble *unary-minus-opcode* op)
		  (assemble *push-opcode* op)))
	    (assemble-constant i:sys:dtp-fixnum value))))
    (:null (assemble-push-n-nils 1))
    (otherwise
      (if (eq value t)
	  (assemble *zerop-opcode* (i-op signed 0))
	  (assemble-constant
	    (progn #-IMACH (fetch-i-data-type-fixnum value)
		   #+IMACH (%data-type value))
	    (if (type-member value dtp-external-value-cell-pointer)
		(%make-pointer dtp-locative value)
		value))))))

;;; See V:>MOON>IMACH>GUIDE>POP.TEXT, and V:>MOON>IMACH>POP.TEXT
(defun assemble-pop (to-pop to-save)
  (cond ((fixp to-pop)
	 (cond ((zerop to-pop))
	       ((fixp to-save)
		(selectq to-save
		  ;;old POP-N
		  (0 (assemble *set-sp-to-address-opcode* (sp-operand to-pop)))
		  ;; old POP-N-SAVE-1
		  (1 (assemble *set-sp-to-address-save-tos-opcode* (sp-operand to-pop)))
		  ;; POP-M-SAVE-N
		  (otherwise
		   (assemble *push-address-sp-relative-opcode*
			     (i-op unsigned (+ -2 to-pop to-save)))
		   (assemble *stack-blt-address-opcode* (sp-operand to-save)))))
	       ((eq to-save 'multiple)		;old POP-N-SAVE-MULTIPLE
		;; First get TO address (base of N values below multiple-group)
		(assemble *push-address-sp-relative-opcode* (sp-operand 0))	;1-base of mvg
		(unless (eql to-pop 1)
		  (assemble *%pointer-plus-opcode* (i-op signed (1+ (- to-pop))))) ;base of N
		;; Next get FROM address (base of multiple group)
		(assemble *push-address-sp-relative-opcode* (sp-operand 1))
		;; Now BLT the stack.
		(assemble *stack-blt-opcode* (tos-pop-operand)))
	       (t (llc-error "Illegal instruction."))))
	((eq to-pop 'multiple)
	 (cond ((fixp to-save)
		(selectq to-save
		  ;; old POP-MULTIPLE - assume for the moment that we do not know the
		  ;; run-time stack level below the multiple group.
		  ;; (That can be optimized later into:
		  ;;       SET-SP-TO-ADDRESS FP|old-level
		  ;;              or
		  ;;       SET-SP-TO-ADDRESS LP|old-level
		  ;;  depending on which base register we're using.)
		  (0 (assemble *push-address-sp-relative-opcode* (tos-pop-operand))
		     ;; This would like to be SET-SP-TO-ADDRESS SP|POP, but SP|POP
		     ;; isn't legal for SET-SP-TO-ADDRESS.
		     (assemble *%write-internal-register-opcode*
					(i-op 10-bit-immediate i:sys:%register-d.sp))
		     (assemble *no-op-opcode* (sp-operand 0)))
		  ;; old POP-MULTIPLE-SAVE-1/n - again, assume that we don't know the
		  ;; run-time stack level.  If we do know it, just assemble this as
		  ;;       SET-SP-TO-ADDRESS-SAVE-TOS FP|n or LP|n
		  (otherwise
		   (assemble *push-opcode* (sp-operand to-save))	;MVG size
		   (assemble *add-opcode* (i-op unsigned to-save))
		   ;; Push the address of the base of the MVG
		   (assemble *push-address-sp-relative-opcode* (tos-pop-operand))
		   ;; When we started, SP|-(to-save-1) would be the address of the
		   ;; first thing to save.  But now the first stack blt arg is on the
		   ;; top of the stack, so we want SP|-to-save.
		   (assemble *stack-blt-address-opcode* (sp-operand to-save)))))
	       ((eq to-save 'multiple)		;old POP-MULTIPLE-SAVE-MULTIPLE
		;;stack[sp+1] := sp - stack[sp] - 1,which is addr of count of lower mult group
		(assemble *push-address-sp-relative-opcode* (sp-operand 0))
		(assemble *cdr-opcode* (tos-pop-operand))	;Size of lower multiple group
		(assemble *add-opcode* (sp-operand 1))	;words to base of lower multiple group-2
		;;stack[sp] := sp - stack[sp] - 1,which is  addr+1 of base of lower mult grp
		(assemble *push-address-sp-relative-opcode* (tos-pop-operand))
		(assemble *%pointer-plus-opcode* (i-op signed -1))
		;;address of base of upper multiple group
		(assemble *push-address-sp-relative-opcode* (sp-operand 1))	
		(assemble *stack-blt-opcode* (tos-pop-operand)))
	       (t (llc-error "Illegal instruction."))))
	(t (llc-error "Illegal instruction."))))

(defun assemble-return (n)
  (cond ((cl:member n '(1 t nil))
	 (assemble *return-single-opcode*
			    (i-op 10-bit-immediate
				  (cl:ecase n 
				    (1 i:sys:%register-tos)
				    ((T) i:sys:%register-constant-t)
				    ((nil 0) i:sys:%register-constant-nil)))))
	((numberp n)      (assemble *return-multiple-opcode* (i-op unsigned n)))
	((eq n 'multiple) (assemble *return-multiple-opcode* (tos-pop-operand)))
	((eq n 'kludge) (assemble *return-kludge-opcode* (tos-pop-operand)))
	(t (llc-error "~S is not a valid RETURN value" n))))

(defun assemble-finish-call-with-known-values (n-values destination inst)
  (assemble-finish-call inst *destination-stack*)
  (push (cons (instruction-array-current-pc *instruction-array*)
	      (ncons n-values))
	*variable-creation-alist*)
  (assemble-destination-for-n-values inst destination n-values nil))

(defun assemble-built-in-call (built-in destination inst)
  ;; >>> This will all change when we redefine the built-in instructions. <<<
  (assemble-built-in-instruction built-in destination inst))

(defun assemble-built-in-instruction (built-in destination inst &optional operand)
  (let* ((opcode (built-in-opcode built-in))
	 (operand (or operand
		      (built-in-operand built-in)
		      ;; Operand is required for all instructions - default it to TOS-POP,
		      ;; or TOS if SP-POP is an illegal operand type for this instruction
		      (let ((operand-types (get-opcode-legal-operand-types opcode)))
			(when operand-types
			  (if (memq 'pop operand-types)	;Yuk
			      (tos-pop-operand)
			      (if (memq 'sp operand-types)
				  (tos-operand)
				  (ferror "I-compiler error - operand required")))))))
	 (n-values (get-opcode-n-returned opcode)))
    (assemble opcode operand)
    (assemble-destination-for-n-values inst destination n-values
				       (get-opcode-attributes opcode))))
    
(defun assemble-destination-for-n-values (inst destination
					  &optional (n-values 1) (attributes nil))
  (let ((dest-n-values (destination-n-values destination)))
    (if (destination-for-return destination)
	(if (eql 0 dest-n-values)
	    (assemble-return nil)
	    (let ((next (next-executable-inst inst)))
	      (unless (and next
			   (eql (inst-opcode next) 'return)
			   (> n-values 0)
			   (eql (compiler:return-n next) n-values)
			   (memq ':return attributes))
		(assemble-return n-values))))
	(cond ((null dest-n-values)
	       (let ((next (inst-next inst)))
		 (cond ((eq (inst-opcode next) 'take-values)
			(let ((values-wanted (take-values-destination next)))
			  (cond ((= values-wanted n-values))
				((< values-wanted n-values)
				 (assemble-pop (- n-values values-wanted) 0))
				((> values-wanted n-values)
				 (assemble-push-n-nils (- values-wanted n-values)))))
			;; Since this can get called from assemble-instructions, smash the code
			(and (setf (inst-next inst) (inst-next next))
			     (setf (inst-prev (inst-next inst)) inst))
			(setf inst next))
		       (t (push-constant n-values)))))
	      ((< dest-n-values n-values)
	       (assemble-pop (- n-values dest-n-values) 0))
	      ((< n-values dest-n-values)
	       (assemble-push-n-nils (- dest-n-values n-values)))))
    inst))

(defun peep-push-nils (inst)
  (loop with names = nil
	with count = 0
	for i = inst then (inst-next i)
	and l = nil then i
	for next = (when i (inst-next i))
	while (and next
		   (not (eq (inst-opcode next) 'setq))
		   (selectq (inst-opcode i)
		     (const
		      (when (null (const-value i))
			(incf count)
			t))
		     (allocate-local-block
		      (incf count (function-local-block-size *function*))
		      t)
		     (name
		      (push i names)
		      t)))
	finally
	(when (plusp count)
	  (cond ((and (eq (inst-opcode i) 'return)
		      (eql (compiler:return-n i) 1))
		 ;; Don't worry about other NIL's
		 (assemble-return NIL)
		 (return i))
		(t (assemble-push-n-nils count)
		   (loop for name in names
			 do (assemble-instruction name *function*))
		   (return l))))))

(defun assemble-push-n-nils (count)
  (cond ((zerop count))
	((= 1 count)
	 ;; >>> Awful kludge required by ECO #... <<<
	 (assemble *zerop-opcode* (i-op signed 1)))
	((< count 1_8.)
	 (assemble *push-n-nils-opcode* (i-op unsigned count)))
	;; >>> I'm not sure this is legal. <<<
	((push-constant count)
	 (assemble *push-n-nils-opcode* (tos-pop-operand)))))

(defun generation-of-variable (variable function &optional (errorp t))
  "Returns the depth of the variable in the lexical environment list."
  (let ((owner (function-frame-owner function)))
    (stack-let ((sharers (cons owner (function-frame-sharers owner))))
      (loop for f first function then (and (eq 'internal (function-type f))
					   (function-parent-function f))
	    with generation = 0
	    until (null f)
	    do
	(if (eq f (lexical-function variable))
	    (return (1+ generation))
	    ;; Only increment the generation count for each extra level in the environment -
	    ;; in other words, don't count actual generations that just pass on their
	    ;; environments.
	    (and (not (function-quick-p f))
		 (not (eq function f))
		 (or (function-use-stack-closure-p f)
		     (function-has-captive-lexicals-p f))
		 (not (memq f sharers))
		 (incf generation)))
	    finally
	      (when errorp 
		(llc-error "Can't find owner function for lexical variable ~S" variable))))))

(defun lexical-subtype (variable function)
  (let ((variable-lexical-function (lexical-function variable)))
    (cond ((or (eq variable-lexical-function function)
	       (and (function-quick-p function)
		    (or (eq variable-lexical-function (function-frame-owner function))
			(memq variable-lexical-function
			      (function-frame-sharers (function-frame-owner function))))))
	   (if (lexical-captive-p variable)
	       (if (lexical-nested-captive-p variable)
		   'nested-captive
		   'captive)
	       'local))
	  ;; Variable is a free lexical of some kind	  
	  (t (values 'free (generation-of-variable variable function t))))))

(defun access-local-lexical-variable (opcode variable level)
  (when (and (memq opcode '(set set-pop))
	     (memq (variable-name variable) '(self self-mapping-table)))
    (let ((original-var (compiler:lexical-original-variable variable)))
      (when (and original-var
		 (= (lexical-location original-var)
		    (if (eq (variable-name variable) 'self) 1 0)))
	(assemble *movem-opcode*
		  (i-op frame-pointer (+ 2 (lexical-location original-var)))))))
  (let ((operand (local-operand variable level)))
    (cond ((and (eq (lexical-class variable) 'logic)
		(eq opcode 'var))
	   (assemble *dereference-opcode* operand))
	  (t
	   (when (and (eq (lexical-class variable) 'array-register)
		      (or (eq opcode 'set)
			  (eq opcode 'set-pop)))
	     (push-constant 0)
	     (assemble *pop-opcode* (local-operand variable level 1)))
	   (selectq opcode
	     (var (assemble *push-opcode* operand))
	     (set (assemble *movem-opcode* operand))
	     (set-pop (assemble *pop-opcode* operand))
	     (var-location (assemble *push-address-opcode* operand))
;	     (take-keyword-argument
;	      (llc-error "TAKE-KEYWORD-ARGUMENT not yet supported in I compiler"))
	     (add (assemble *add-opcode* operand))
	     (otherwise (llc-error "Unknown opcode ~S" opcode)))))))

(defun assemble-lexical-environment-reference (e-offset base-opcode e-operand variable)
  (cond ((and (eq (lexical-class variable) 'array-register)
	      (or (eql base-opcode *movem-lexical-var-opcode*)
		  (eql base-opcode *pop-lexical-var-opcode*)))
	 (cond ((< e-offset *max-offset-for-freevar-insts*)
		;; Use the instructions
		(push-constant 0)
		(assemble *pop-lexical-var-opcode*
			  (if (eq e-operand 'top-of-stack)
			      (sp-operand 1)
			      e-operand)
			  (1+ e-offset))
		(assemble base-opcode
			  (if (eq e-operand 'top-of-stack)
			      (tos-pop-operand)
			      e-operand)
			  e-offset))
	       (t
		;; Use the long format - just do the equivalent of %P-CONTENTS-OFFSET
		(assemble *push-opcode*
			  (if (eq e-operand 'top-of-stack)
			      (sp-operand 1)
			      e-operand))
		(assemble *%pointer-plus-opcode* (i-op signed e-offset))
		(push-constant 0)
		(assemble *pop-lexical-var-opcode* (sp-operand 1) 1)
		(assemble base-opcode (tos-pop-operand) 0))))
	(( e-offset *max-offset-for-freevar-insts*)
	 ;; Use the instructions
	 (assemble base-opcode
		   (if (eq e-operand 'top-of-stack)
		       (tos-pop-operand)
		       e-operand)
		   e-offset))
	(t
	 ;; Use the long format - just do the equivalent of %P-CONTENTS-OFFSET
	 (unless (eq e-operand 'top-of-stack)
	   (assemble *push-opcode* e-operand))
	 (assemble *%pointer-plus-opcode* (i-op signed e-offset))
	 (assemble base-opcode (tos-pop-operand) 0))))

(defun access-environment-variable (fun opcode e variable)
  ;; e is the environment chunk pointer - it will either be the symbol 'TOP-OF-STACK (which
  ;; means that it's the current value at the top of the stack), or a variable which will
  ;; serve as a run-time environment chunk (free or captive list) pointer.
  (let* ((frame-owner-fun (function-frame-owner fun))
	 (e-offset
	  (if (memq (lexical-function variable) `(,fun ,frame-owner-fun))
	      ;; This is a reference to a captive local variable
	      (if (lexical-captive-p variable)
		  (lexical-captive-location variable)
		  (lexical-variable-environment-offset variable))
	      ;; This is a free reference
	      (if (and (eq (function-type fun) 'internal)	;[Can it ever NOT be???]
		       (function-use-stack-closure-p frame-owner-fun))
		  (lexical-variable-environment-offset variable)
		  (lexical-captive-location variable)))))
    ;; Generate the instruction to access the variable.
    (let* ((e-operand (if (eq e 'top-of-stack) e (if *stack-shuffling*
						     (i-op frame-pointer 2)
						     (lexical-var-operand e))))
	   (name (variable-name variable))
	   (insts (assq name *lexical-variable-instructions*))
	   (new-inst
	     (selectq opcode
	       (var (assemble-lexical-environment-reference
		      e-offset *push-lexical-var-opcode* e-operand variable))
	       (set (assemble-lexical-environment-reference
		      e-offset *movem-lexical-var-opcode* e-operand variable))
	       (set-pop (assemble-lexical-environment-reference
			  e-offset *pop-lexical-var-opcode* e-operand variable))
	       (var-location
		(unless (eq e-operand 'top-of-stack)
		  (assemble *push-opcode* e-operand))
		(assemble *%set-tag-opcode* (i-op signed (make-i-tag type i:sys:dtp-locative)))
		(assemble *%pointer-plus-opcode* (i-op signed e-offset)))
	       (otherwise (llc-error "Unknown opcode ~S" opcode)))))
      (if insts
	  (push new-inst (cdr insts))
	  (push (list name new-inst) *lexical-variable-instructions*))
      new-inst)))

(defun access-kludge-captive-variable (opcode variable)
  (let ((offset (lexical-captive-location variable))
	(function (function-frame-owner (lexical-function variable))))
    (if offset
	(let* ((arg-size (function-argument-block-size function))
	       (operand
		(if (zerop (ldb %%arg-desc-rest-arg (function-args-info function)))
		    (i-op frame-pointer (+ offset arg-size 2))
		    (i-op local-pointer (+ offset arg-size)))))
	  (cond ((and (eq (lexical-class variable) 'logic)
		      (eq opcode 'var))
		 (assemble *dereference-opcode* operand))
		(t
		 (when (and (eq (lexical-class variable) 'array-register)
			    (or (eq opcode 'set)
				(eq opcode 'set-pop)))
		   (push-constant 0)
		   (assemble *pop-opcode*
			     (if (zerop (ldb %%arg-desc-rest-arg
					     (function-args-info function)))
				 (i-op frame-pointer (+ offset arg-size 2 1))
				 (i-op local-pointer (+ offset arg-size 1)))))
		 (assemble
		   (selectq opcode
		     (var *push-opcode*)
		     (set *movem-opcode*)
		     (set-pop *pop-opcode*)
		     (var-location *push-address-opcode*)
		     (otherwise (llc-error "Unknown opcode ~S" opcode)))
		   operand))))
	(ferror
	  "Internal compiler error - kludge captive variable has no captive location"))))

(defun access-captive-lexical-variable (opcode variable function
					&optional level (both-homes t))
  (cond ((and (lexical-argument-p variable)
	      *dispatch-interval-p*)
	 ;; All references to arguments from within the argument init-forms must use
	 ;; the local (as opposed to captive) location of the argument, since the
	 ;; captive block gets consed -after- all the args have been taken.
	 (access-local-lexical-variable opcode variable level))
	(t
	 ;; If variable has two homes, store into both of them, because the non-captive home
	 ;; may be referenced by instance-variable-accessing instructions (in ncwhoppers)
	 (when (and both-homes
		    (memq opcode '(set set-pop))
		    (memq (variable-name variable) '(self self-mapping-table))
		    (eq (lexical-function variable) (function-frame-owner function))
		    (not (lexical-stack-resident-p variable)))
	   (let ((location (lexical-location
			     (or (compiler:lexical-original-variable variable)
				 variable))))
	     (when (= location (if (eq (variable-name variable) 'self) 1 0))
	       (assemble *movem-opcode* (i-op frame-pointer (+ 2 location))))))
	 ;; See if we're kludging stack-consed heap-format closures
	 (if (assq 'compiler:evacuable-downward-closures
		   (function-user-declares (function-frame-owner function)))
	     (access-kludge-captive-variable opcode variable)
	     ;; Normal way
	     (let ((env-pointer (get-function-captive-block-pointer function)))
	       (access-environment-variable function opcode env-pointer variable))))))

(defun assemble-get-captive-block-from-generation-captive-list
       (captive-list-var ncaptives)
  "The captive block is (NTHCDR NCAPTIVES CAPTIVE-LIST)."
  (unless (eq captive-list-var 'top-of-stack)
    (access-local-lexical-variable 'var captive-list-var nil))
  (loop repeat ncaptives do (assemble *cdr-opcode* (tos-pop-operand))))

(defun access-nested-lexical-variable (opcode)
  ;; Nested captives are the CAR's of the CONSes.  Assume that when we get here
  ;; the stack is fine.
  (selectq opcode
    (var (assemble *car-opcode* (tos-pop-operand)))
    (set (assemble *rplaca-opcode* (tos-pop-operand)))
    (set-pop (assemble *rplaca-opcode* (tos-pop-operand)) (assemble-pop 1 0))
    (var-location
     (assemble *%set-tag-opcode* (i-op unsigned (make-i-tag type i:sys:dtp-locative))))
;   (take-keyword-argument *take-keyword-argument-opcode*)
    (otherwise (llc-error "Unknown opcode ~S" opcode))))

(defun captive-nesting-level (var function)
  ;; This function assumes that the variables in FUNCTION-LEXICAL-COUNTOUR appear innermost
  ;; first.  This function returns the index of VAR within its generation's environment
  ;; structure.
  (loop with lex-fun = (lexical-function var)
	with n = 0
	for (name . v) in (function-lexical-contour function)
	do (ignore name)
	when (eq var v)
	  return n
	when (and (typep v 'compiler:variable)
		  (eq 'compiler:lexical (variable-type v))
		  (null (compiler:lexical-superseding-variable v))
		  (lexical-nested-captive-p v)
		  (eq (lexical-function v) lex-fun))
	  do (incf n)
	finally
	  (ferror "Internal compiler error - ~S is not part of the lexical contour for ~S"
		  var function)))

(defun access-nested-free-lexical-variable (function opcode env var)
  (unless (eq env 'top-of-stack)
    (access-local-lexical-variable 'var env nil))
  ;; First, get the nested captive cons.
  (loop repeat (captive-nesting-level var function)
	do (assemble *cdr-opcode* (tos-pop-operand)))
  ;; Push the previous top again if we're doing a set.
  (when (memq opcode '(set set-pop))
    (assemble *push-opcode* (sp-operand 1)))
  ;; Now access the variable itself.
  (access-nested-lexical-variable opcode))

(defun access-free-lexical-variable (opcode variable function generation)
  (let ((current-env-pointer (get-environment-list-pointer function))
	(nested-captive-info (function-n-nested-frees (function-frame-owner function)))
	(nested-captive-p (lexical-nested-captive-p variable)))
    (cond ((<= generation 0)
	   ;; Should never hit this error unless compiler is busted.
	   (llc-error "Bad generation count - something broken in compiler"))
	  ;; Reference to one of parent function's captives.
	  ((= 1 generation)
	   (cond (nested-captive-p
		  (access-nested-free-lexical-variable function opcode current-env-pointer
						       variable))
		 ((or (null nested-captive-info) (zerop (car nested-captive-info)))
		  (access-environment-variable function opcode current-env-pointer
					       variable))
		 (t 	
		  ;; If we do have nested lexicals, get the previous generation's captive
		  ;; block.
		  (assemble-get-captive-block-from-generation-captive-list
		    current-env-pointer (car nested-captive-info))
		  (access-environment-variable function opcode 'top-of-stack variable))))
	  ;; Reference more than one generation back.
	  (t
	   ;; First get the current environment (free list) pointer onto the top
	   ;; of the stack.
	   (access-local-lexical-variable 'var current-env-pointer 0)
	   ;; Then just loop adding instructions to replace the top of stack with
	   ;; a pointer to the previous generation's captives, until the top of the
	   ;; stack contains the right environment.
	   (loop with i = 1
		 for f first (function-parent-function function)
		       then (function-parent-function f)
		 for has-captives-p = (function-has-captive-lexicals-p f)
		 for stack-p = (and (eq (function-type f) 'internal)
				    (function-use-stack-closure-p f))
		 for n-nested = (and has-captives-p
				     nested-captive-info
				     (nth (1- i) nested-captive-info))
		 doing
	     ;; Stop when we're at the right level of the environment structure
	     (when (or (eq (function-type f) 'external)
		       (and (or has-captives-p stack-p)
			    (= i generation)))
	       ;; If the variable we're accessing is not nested, we still need to get the
	       ;; captive block.
	       (when (and (not nested-captive-p)
			  n-nested
			  (not (zerop n-nested)))
		 (assemble-get-captive-block-from-generation-captive-list
		   'top-of-stack n-nested))
	       ;; In either case, exit the loop
	       (return (values)))
	     ;; We're not at the right level yet, keep backing up - ignore functions
	     ;; that don't add to the environment.
	     (when (or has-captives-p stack-p)
	       (incf i)
	       ;; Handle nested captives - that is, get the captive block portion of
	       ;; the captive list when we're looking for a variable that isn't one
	       ;; of the nested captives.
	       (when (and n-nested (not (zerop n-nested)))
		 (assemble-get-captive-block-from-generation-captive-list
		   'top-of-stack n-nested))
	       ;; Now get the pointer to the previous generation's environment.
	       ;; Also, remember to special case the situation where the environment
	       ;; is a stack frame and the function refers to instance variables:
	       ;; the link to the previous level environment will be at offset 2
	       ;; of the environment, rather than 0.
	       (if (function-use-stack-closure-p f)
		   (let ((env-var (compiler:get-environment-list-pointer f)))
		     (access-environment-variable f 'var 'top-of-stack env-var))
		   (assemble *push-lexical-var-opcode* (tos-pop-operand) 0))))
	   ;; Now access the variable itself, using the environment pointer left
	   ;; on the stack.
	   (if nested-captive-p
	       (access-nested-free-lexical-variable function opcode 'top-of-stack variable)
	       (access-environment-variable function opcode 'top-of-stack variable))))))

(defun access-nested-captive-lexical-variable (opcode variable level)
  ;; Start by getting the captive cons - the lexical-location of variable in the stack
  ;;  will contain a pointer to the cons.
  (assemble *push-opcode* (local-operand variable level))
  (when (memq opcode '(set set-pop))
    (assemble *push-opcode* (sp-operand 1)))
  ;; Push the previous top again if we're doing a set.
  (access-nested-lexical-variable opcode))

;;; Perform an operation on a variable.  opcode is a Byte Lap opcode, and
;;; currently may be any of var, set, or var-location; in the future this
;;; argument will have more possibilities for the assembly of two or more
;;; Byte Lap instructions together, set-pop in particular.  variable is the
;;; lexical variable to access and level is the stack level at the time of the
;;; access.  This function will become more complicated when it becomes possible
;;; to access lexical variables of parent functions.
(defun access-lexical-variable (opcode variable level &optional function)
  (multiple-value-bind (subtype generation)
      (and function (lexical-subtype variable function))
    (or subtype (setq subtype 'local))		;>>> If no function must assume local <<<
    (selectq subtype
      (local (access-local-lexical-variable opcode variable level))
      (captive (access-captive-lexical-variable opcode variable function level))
      (nested-captive (access-nested-captive-lexical-variable opcode variable level))
      (free (access-free-lexical-variable opcode variable function generation))
      (otherwise (llc-error "Unknown lexical subtype ~S" subtype)))))

(defun assemble-reference-to-internal-function (fun)
  ;; >>> These will have to get fixed up by the loader <<<
  (assemble-constant i:sys:dtp-compiled-function
		     #-imach (function-pr fun)
		     #+imach fun))

(defun find-push-stack-closure-inst-in-interval (interval function)
  ;; [>>> This is a lot like find-first-inst-with-opcode from phase-1. <<<]
  (loop for inst first (interval-first interval) then (inst-next inst)
	until (or (null inst)
		  (and (eq (inst-opcode inst) 'push-stack-closure)
		       (eq function (push-stack-closure-function inst))))
	finally
	(return (or inst
		    (ferror "Couldn't find right PUSH-STACK-CLOSURE inst in ~S" interval)))))

(defun access-environment-variable-for-closure (function contour level)
  ;; Check for any nested captives
  (loop for (name . v) in contour
	do (ignore name)
	when (and (typep v 'compiler:variable)
		  (eq 'compiler:lexical (variable-type v))
		  (null (compiler:lexical-superseding-variable v))
		  (lexical-nested-captive-p v)
		  (eq (lexical-function v) function))
	  do (assemble *push-opcode* (local-operand v level))
	     (return-from access-environment-variable-for-closure nil))
  (let ((var (if (function-has-captive-lexicals-p function)
		 (get-function-captive-block-pointer function)
		 (get-environment-list-pointer function))))
    (access-lexical-variable 'var var level function)))

(defun assemble-lexical-closure (inst fun)
  inst
  ;; There are two cases - stack and general closure.
  (let ((parent-fun (function-parent-function fun)))
    (cond ((or (function-use-stack-closure-p fun)
	       (assq 'compiler:evacuable-downward-closures
		     (function-user-declares (function-frame-owner parent-fun))))
	   ;; In this case, the lexical closure exists somewhere on the stack already,
	   ;; and we need only generate a pointer to it
	   (if (zerop (ldb %%arg-desc-rest-arg (function-args-info *frame-function*)))
	       (assemble *push-address-opcode*
			 (i-op frame-pointer 
			       (+ (push-stack-closure-level
				    (find-push-stack-closure-inst-in-interval
				      (function-interval
					(function-frame-owner parent-fun))
				      fun))
				  2)))	;Closure is after rest arg
	       (assemble *push-address-opcode*
			 (i-op local-pointer
			       (push-stack-closure-level
				 (find-push-stack-closure-inst-in-interval
				   (function-interval
				     (function-frame-owner parent-fun))
				   fun)))))

	   (assemble *%set-tag-opcode* (i-op unsigned i:sys:dtp-lexical-closure)))
	  (t
	   (let ((start-i (assemble-constant
			    i:sys:dtp-call-indirect
			    (follow-cell-forwarding
			      (fdefinition-location 'make-lexical-closure t) nil))))
	     ;; Get the environment.
	     (access-environment-variable-for-closure
	       parent-fun (function-lexical-contour fun) (fun-level inst))
	     ;; Now get internal function.
	     (assemble-reference-to-internal-function fun)
	     ;; Make the closure itself.
	     (let ((finish-i (assemble-finish-call-1 *finish-call-n-opcode* 2 *destination-stack*)))
	       (push `(,start-i . ,finish-i) *call-start-alist*)
	       finish-i))))))

(defun assemble-instance-variable-reference (opcode var)
  ;; The offset into the mapping table isn't known yet, generate fixup at load time
  ;; to get it.
  (let* ((name (variable-name var))
	 (insts (assq name *instance-variable-instructions*))
	 (inst (assemble opcode (i-op unsigned 0))))
    (if insts
	(push inst (cdr insts))
	(push (list name inst) *instance-variable-instructions*))
    inst))

;;; The assemble functions for the generic byte-lap - these produce abstract I architecture
;;; instructions.
(defgeneric assemble-instruction (instruction function)
  (:documentation
    "Assembles INSTRUCTION into an object representation.  FUNCTION is passed for use
by some methods.")
  (declare (values)))

(defgeneric peep-hole-optimizer (instruction function)
  (:documentation
    "Optimizes, and perhaps assembles INSTRUCTION and subsequent instructions in the 
interval. FUNCTION is passed for use by some methods.  Returns NIL, if
ASSEMBLE-INSTRUCTION should be called with INSTRUCTION, or the last byte-lap
instruction that was consumed.")
  (declare (values last-inst-consumed)))

(defmethod (peep-hole-optimizer byte-lap-instruction) (&rest ignore)
  nil)

(definst-method (assemble-instruction no-op) (ignore)
  )						;Don't generate anything

(definst-method (assemble-instruction ensure-mapping-information) (function)
  (let* ((info (lexical-mapping-table-info ensure-mapping-information-self))
	 (family (mapped-access-information-family info))
	 (mt nil))
    (cl:pushnew (list family (mapped-access-information-variables info)
		      (compiler:function-has-mapped-slot-access function))
		*function-mapping-table-families*
		:test #'cl:equal)
    (unless (and ensure-mapping-information-previous-mapping-tables
		 (null (cdr ensure-mapping-information-previous-mapping-tables))
		 (setq mt (car ensure-mapping-information-previous-mapping-tables))
		 (eq (first mt) ensure-mapping-information-mapping-table)
		 (eql (second mt) ensure-mapping-information-segment))
      (access-lexical-variable
	'var ensure-mapping-information-mapping-table inst-level function)
      (unless (<= (clos-internals:mapping-table-family-size family)
		  clos-internals::*mapping-table-segment-size*)
	(assemble *aref-1-opcode* (i-op unsigned 2))
	(unless (zerop ensure-mapping-information-segment)
	  (assemble *%pointer-plus-opcode* (i-op unsigned ensure-mapping-information-segment)))
	(assemble *car-opcode* (tos-pop-operand)))
      (assemble *pop-opcode* (i-op frame-pointer 2))
      (add-names '(self-mapping-table))))
  (unless (and ensure-mapping-information-previous-selfs
	       (null (cdr ensure-mapping-information-previous-selfs))
	       (eq (car ensure-mapping-information-previous-selfs)
		   ensure-mapping-information-self))
    (access-lexical-variable 'var ensure-mapping-information-self inst-level function)
    (assemble *pop-opcode* (i-op frame-pointer 3))
    (add-names '(self))))

#+Ivory-Rev-1
(defun (i:si:%generic-dispatch-pull assemble-function)
       (&rest ignore)
  (assemble *entry-rest-accepted-opcode* (i-op entry 4))
  (assemble *entry-rest-accepted-opcode* (i-op entry 4))
  (assemble *%generic-dispatch-opcode* (i-op frame-pointer 0))
  (assemble *no-op-opcode* (sp-operand 0)))

#+Ivory-Rev-1
(defun (i:si:%message-dispatch-pull assemble-function)
       (&rest ignore)
  (assemble *entry-rest-accepted-opcode* (i-op entry 4))
  (assemble *entry-rest-accepted-opcode* (i-op entry 4))
  (assemble *%message-dispatch-opcode* (i-op frame-pointer 0))
  (assemble *no-op-opcode* (sp-operand 0)))

(defun (i:sys:%pointer-increment assemble-function)
       (&rest ignore)
  (ferror "%POINTER-INCREMENT's argument must be a locative"))

(defun (%set-cdr-code-1 assemble-function)
       (&rest ignore)
  (ferror "%SET-CDR-CODE-NIL's argument must be a locative"))

(defun (%set-cdr-code-2 assemble-function)
       (&rest ignore)
  (ferror "%SET-CDR-CODE-NORMAL's argument must be a locative"))

(defun (i:sys:%merge-cdr-no-pop assemble-function)
       (&rest ignore)
  (ferror "%MERGE-CDR-NO-POP's argument must be a locative"))

(definst-method (peep-hole-optimizer var-location)
		(&rest ignore)
  (when (and (eq (inst-opcode inst-next) 'call)
	     (typep var-location-variable 'compiler:normal-lexical-variable)
	     (memq (function-spec (call-function inst-next))
		   '(%set-cdr-code-1 %set-cdr-code-2
				     i:sys:%pointer-increment i:sys:%merge-cdr-no-pop))
	     (= (call-n-args inst-next)
		(built-in-n-arguments (call-builtin inst-next))))
    (assemble-built-in-instruction
      (call-builtin inst-next) (call-destination inst-next)
      inst-next
      (local-operand var-location-variable var-location-level))
    inst-next))  

;;; NOTE:  THE CALL TO THE TYPE-MEMBER-NO-POP OPTIMIZER HAS BEEN COMMENTED OUT DUE TO ITS
;;; INAPPLICABILITY.
(definst-method (peep-hole-optimizer var) (function)
  (declare (ignore function))
  (let* ((next inst-next)
	 (var var-variable)
	 (next-opcode (inst-opcode next))
	 (setq-variable (and (eq next-opcode 'setq) (setq-variable next))))
    (cond ((variable-can-be-operand-p var)
           (if (and setq-variable
		    (eq (variable-type setq-variable) 'special))
	       (setq-special-peep-hole self next (setq-for-effect next))
	       (let ((var-operand (local-operand var var-level)))
		 (selectq next-opcode
		   (bind
		    (when (= 0 (compiler:bindings-in-control-stack *compiler*))
		      (let ((bvar (bind-variable next)))
			(when bvar
			  (when (eq (i-abstract-operand-type var-operand) 'stack-pointer)
			    ;; Since we're pushing the location, this is going to be off by one.
			    ;;  KLUDGE!
			    (decf (i-abstract-operand-value var-operand)))
			  (assemble-special-location (variable-name bvar))))
		      (assemble *bind-locative-to-value-opcode* var-operand)
		      next))
		   (call
		    (let ((name (function-spec (call-function next))))
		      (cond ((and (eq name 'car) (look-for-set-to-cdr-push-car next var))
			     inst-prev)	;pass over this again if STCPC optimized-in
			    ((and (eq name '<-no-pop)
				  (maybe-optimize-loop-increment-tos self var next)))
			    (t (let ((built-in
				       (and (not (call-force-external next))
					    (loop for b-i in (get name 'built-in)
						  for types = (built-in-format b-i)
						  thereis
						    (when (intersection '(lp fp sp) types)
						      b-i)))))
				 (cond ((and built-in
					     ;; if numbers of args not equal,
					     ;; could be because phase-1 let
					     ;; through bad code like (car a b)
					     ;; after the error message
					     (= (built-in-n-arguments built-in)
						(call-n-args next)))
					(when *p4-trace*
					  (format t "~%~S and ~S optimized into built-in call"
						  self next))
					(assemble-built-in-instruction
					  built-in (call-destination next) next var-operand))
				       ))))))
		   ;; The I start-call instruction can take a general operand.
		   (start-call
		    (when (and (not (call-force-external (start-call-call next)))
			       (memq (function-spec (start-call-function next))
				     *funcalling-functions*))
		      (let ((pair (assq next *call-start-alist*))
			    (i (assemble *start-call-opcode* (local-operand var var-level))))
			(cond (pair
			       ;; We already have a call starter
			       (setf (car pair) i))
			      (t
			       ;; Add an entry to the call-starter database of the form:
			       ;; (<start index> . <start byte-lap>)
			       (push (cons i next) *call-start-alist*))))
		      (when *p4-trace*
			(format t "~%~S and ~S optimized into START-CALL" var next))
		      next))
		   (jump
		    (when (and (neq (jump-condition next) 'ALWAYS)	;don't if uncondx jump
			       (look-for-compilicated-set-to-cdr-push-car next var))
		      ;; pass over this again if SET-TO-CDR-PUSH-CAR was optimized-in
		      inst-prev))
		   (setup-array
		    (assemble-setup-array
		      (compiler:array-register-type
			(compiler:setup-array-register-variable next))
		      var-operand)
		    next)))))
	  ((and (eq (variable-type var) 'special)
		(eq (inst-opcode next) 'bind)
		(eq (bind-variable next) var)
		(= 0 (compiler:bindings-in-control-stack *compiler*)))
	   (assemble-special-location (variable-name var))
	   (assemble *bind-locative-opcode* (tos-pop-operand))
	   next))))

;; Come here if we've seen VAR x followed by CALL 1-LOCAL.
;; Looking for:
;;   inst1:  Const 1
;;   inst2:  Call --INTERNAL 2
;;   inst3:  VAR x (TOS)
;;   inst4:  CALL PLUSP
;;   inst5:  JUMP-IF-TRUE
;; and x must be at the TOS.
(defun maybe-optimize-loop-decrement-tos (inst3)
  (when (and (eq (inst-opcode inst3) 'var)
	     (eql (variable-stack-offset
		    (var-variable inst3)
		    (inst-pre-control-stack-state inst3)
		    (inst-level inst3))
		  1))
    (let ((inst4 (inst-next inst3)))
      (when (and (eq (inst-opcode inst4) 'call)
		 (eq (function-spec (call-function inst4)) 'plusp)
		 (= (call-n-args inst4) 1)
		 (eql 1 (destination-n-values (call-destination inst4))))
	(let ((inst5 (inst-next inst4)))
	  (when (and (eq (inst-opcode inst5) 'jump)
		     (eq (jump-condition inst5) 'true)
		     (= (jump-pops-if-successful inst5) 1)
		     ( (jump-pops-if-not-successful inst5) 1))
	    (note-branch 'loop-decrement-tos
			 (assemble *loop-decrement-tos-opcode* (i-op signed 0))
			 (jump-tag inst5))
	    (unless (> (jump-pops-if-not-successful inst5) 1)
	      (return-from maybe-optimize-loop-decrement-tos inst5))
	    (let ((inst6 (inst-next inst5))
		  (extra-pops (- (jump-pops-if-not-successful inst5) 1)))
	      (when (and (eq (inst-opcode inst6) 'pop)
			 (eql (pop-save-n inst6) 0)
			 (numberp (compiler:pop-n inst6)))
		(assemble-pop (+ extra-pops (compiler:pop-n inst6)) 0)
		(return-from maybe-optimize-loop-decrement-tos inst6))
	      (assemble-pop extra-pops 0)
	      inst5)))))))

;; Stack has
;; SP|-1: x
;; SP|0 : y
;;
;;   inst1:  VAR x
;;   inst2:  Call <-NO-POP
;;   next :  VAR y
;;   next1:  CALL INCREMENT
;;   next2:  JUMP-IF-TRUE
(defun maybe-optimize-loop-increment-tos (inst1 var1 inst2)
  (when (eql (variable-stack-offset
	       var1 (inst-pre-control-stack-state inst1) (inst-level inst1))
	     2)
    (let* ((next (inst-next inst2)))
      (when (and next
		 (eq (inst-opcode next) 'var)
		 (eql (variable-stack-offset
			(var-variable next)
			(inst-pre-control-stack-state next)
			(inst-level next))
		      2))
	(let ((next2 (inst-next next)))
	  (when (and next2
		     (eq (inst-opcode next2) 'call)
		     (eq (function-spec (call-function next2)) '1+local))
	    (let ((next3 (inst-next next2)))
	      (when (and (eq (inst-opcode next3) 'jump)
			 (eq (jump-condition next3) 'true)
			 (= (jump-pops-if-successful next3) 1)
			 (= (jump-pops-if-not-successful next3) 1))
		(note-branch 'loop-increment-tos-less-than
			     (assemble *loop-increment-tos-less-than-opcode* (i-op signed 0))
			     (jump-tag next3))
		next3))))))))

(defun assemble-capture-variable (inst)
  ;; TOS is the variable we are going to catch.  We start the call to
  ;; CAPTURE-VARIABLE and then push the variable (we know that starting
  ;; the call to CAPTURE-VARIABLE will only push two words onto the stack) and then
  ;; push INST's variable onto the stack, finish the call, and pop the stack into the
  ;; original variable.
  (let ((starter-i (function-call-starter-instruction 'capture-variable)))
    (assemble *push-opcode* (sp-operand 2))
    (assemble-instruction inst nil)
    (let* ((inst (inst-next inst))
	   (n-args (call-n-args inst))
	   (destination (call-destination inst))
	   (finish-i (assemble-finish-call-1 *finish-call-n-opcode* n-args destination)))
      (push (cons starter-i finish-i) *call-start-alist*)
      (assemble *set-sp-to-address-save-tos-opcode* (sp-operand 1))
      inst
      )))

;;; The following routine performs this optimization:
;;;  PUSH X                                     PUSH X
;;;  TYPE-MEMBER             optimized into     TYPE-MEMBER-NO-POP
;;;  CONDX-BRANCH                               MODIFIED-CONDX-BRANCH
;;;  PUSH X
;;;
;;; where CONDX-BRANCH turns into MODIFIED-CONDX-BRANCH as follows:
;;;  BRANCH-{T/F}                               BRANCH-{T/F}-AND-EXTRA-POP
;;;  BRANCH-{T/F}-AND-NOPOP                     BRANCH-{T/F}-NOPOP
;;;
;;; The byte-lap we're looking for is #<Inst (Var X)>
;;;                                   #<Inst (Call [type-member-pred] [n-args] [dest])>
;;;                                   #<Inst (Jump-if-[condx] [Tag-name])>
;;;                                   #<Inst (Var X)>
;;; Here, [n-args] should be 1 and [dest] should be STACK, but I'm not checking, since being 
;;; a [type-member-pred] is sufficient to guarantee this.
;;;
;;; This routine used to check for membership in *non-TYPE-MEMBER-optimizable-preds*, but this
;;; type of optimization is more complicated and should be done in "phase 5".

#+ignore  ;; Not called.
(defun find-and-optimize-3-instruction-sequence (poss-pred 1st-push-var)
  (let ((candidate (and (eq (inst-opcode poss-pred) 'CALL)
			(function-spec (call-function poss-pred)))))
    (when (get candidate 'type-member-function)	;is this TYPE-MEMBER?
      (let ((possbr (inst-next poss-pred)))
	(when (and (eq (inst-opcode possbr) 'JUMP)
		   (neq (jump-condition possbr) 'ALWAYS))	;elim uncondx branches
	  (let ((pops-if (jump-pops-if-successful possbr))
		(pops-if-not (jump-pops-if-not-successful possbr)))
	    ;; This test for BRANCH-{T/F} and BRANCH-{T/F}-AND-NO-POP
	    (when (and ( pops-if 1) (= pops-if-not 1))
	      (let ((2ndpush (inst-next possbr)))
		(when (and (eq (inst-opcode 2ndpush) 'VAR)
			   (eq (var-variable 2ndpush) 1st-push-var))
		  (let ((after-2ndpush (inst-next 2ndpush)))
		    (unless (and (eq (inst-opcode after-2ndpush) 'call)
				 (member (function-spec (call-function after-2ndpush))
					 *local-modification-functions*))
		      ;; Tests have succeeded: side-effect byte-lap here.
		      (setf (function-spec (call-function poss-pred))
			    (intern (string-append candidate "-NO-POP") "I-LISP-COMPILER"))
		      (setf (jump-pops-if-not-successful possbr) 0)
		      (setf (inst-next possbr) (inst-next 2ndpush))	;bypass 2nd PUSH
		      (inst-next 2ndpush))))))))))))	;return first thing BEYOND 2nd PUSH


;;; This routine side-effects byte-lap only: it returns T if the optimization was made.
;;;
;;; This optimizes  PUSH X | CAR {| NAME} | PUSH X | SET-TO-CDR into
;;;		    PUSH X | SET-TO-CDR-PUSH-CAR {| NAME}
;;; Also does PUSH X | CAR {| NAME} | SETQ Y | POP-N 1 | PUSH X | SET-TO-CDR into
;;;	      PUSH X | SET-TO-CDR-PUSH-CAR {| NAME} | SETQ Y | POP-N 1
;;;
;;; At this point, we've seen #<Inst (Var X)> and #<Inst (Call CAR)>.
;;;---- This should really be in phase 3, but it's machine dependent.
;;;---- In the second optimization, multiple setq's should be allowed.
(defun look-for-set-to-cdr-push-car (call-CAR-inst 1st-var-var)
  (let* ((2nd-var-inst (inst-next call-CAR-inst))
	 (2nd-var-opcode (when 2nd-var-inst (inst-opcode 2nd-var-inst)))
	 inst inst1 inst2)
    (when (eq 2nd-var-opcode 'name)
      (setq 2nd-var-inst (inst-next 2nd-var-inst))
      (setq 2nd-var-opcode (when 2nd-var-inst (inst-opcode 2nd-var-inst))))
    (cond ((and (eq 2nd-var-opcode 'VAR)
		(eq (var-variable 2nd-var-inst) 1st-var-var)
		(eq (inst-opcode (setq inst (inst-next 2nd-var-inst))) 'call)
		(eq (function-spec (call-function inst)) 'cdr-local))
	   (setf (function-spec (call-function call-CAR-inst)) 'I:SYS:SET-TO-CDR-PUSH-CAR)
	   ;; Use phase 3 technology
	   (let ((compiler:*phase-3-instruction* nil))
	     (compiler:delete-inst 2nd-var-inst inst))
	   t)
	  ((and (eq 2nd-var-opcode 'setq)
		(eq (inst-opcode (setq inst (inst-next 2nd-var-inst))) 'pop)
		(eql (compiler:pop-n inst) 1)
		(eql (pop-save-n inst) 0)
		(eq (inst-opcode (setq inst1 (inst-next inst))) 'var)
		(eq (var-variable inst1) 1st-var-var)
		(eq (inst-opcode (setq inst2 (inst-next inst1))) 'call)
		(eq (function-spec (call-function inst2)) 'cdr-local))
	   (setf (function-spec (call-function call-CAR-inst)) 'I:SYS:SET-TO-CDR-PUSH-CAR)
	   ;; Use phase 3 technology
	   (let ((compiler:*phase-3-instruction* nil))
	     (compiler:delete-inst inst1 inst2))
	   t))))


;;; This routine side-effects byte-lap only: it returns T if the optimization was made.
;;;
;;; This optimizes  PUSH X | CAR | PUSH X | SET-TO-CDR  into  PUSH X | SET-TO-CDR-PUSH-CAR
;;;
;;; At this point, we've seen #<Inst (Var X)> and #<Inst (Call CAR)>.
;(defun look-for-set-to-cdr-push-car (call-CAR-inst 1st-var-var)
;  (let* ((2nd-var-inst (inst-next call-CAR-inst))
;	 (2nd-var-opcode (when 2nd-var-inst (inst-opcode 2nd-var-inst))))
;    (when (eq 2nd-var-opcode 'VAR)
;      (let ((2nd-var-var (var-variable 2nd-var-inst)))
;	(when (eq 2nd-var-var 1st-var-var)
;	  (let* ((call-CDR-inst (inst-next 2nd-var-inst))
;		 (call-CDR-opcode (inst-opcode call-CDR-inst))
;		 (who-we-call (when (eq call-CDR-opcode 'CALL)
;				(function-spec (call-function call-CDR-inst)))))
;	    (when (eq who-we-call 'CDR-LOCAL)
;	      (setf (function-spec (call-function call-CAR-inst)) 'I:SYS:SET-TO-CDR-PUSH-CAR)
;	      (setf (inst-next call-CAR-inst) (inst-next call-CDR-inst))
;	      T)))))))				;return T if optimized

;;; This routine side-effects byte-lap only: it returns T if the optimization was made.
;;;
;;; This optimizes  PUSH X                into  PUSH X 
;;;                 conditional-BRANCH          conditional-BRANCH-with-extra-pop-if-no-BRANCH
;;;                 CAR                         SET-TO-CDR-PUSH-CAR X
;;;                 POP Y                       POP Y
;;;                 SET-TO-CDR X
;;;
;;; The extra pop if no-BRANCH is needed because CAR consumes a stack slot,
;;; while SET-TO-CDR-PUSH-CAR does not.
;;; The byte-lap we're looking for is #<Inst (Var X)>
;;;                                   #<Inst (Jump-[conditional] [tag])>
;;;                                   #<Inst (Call CAR)>
;;;                                   #<Inst (Setq [local])>
;;;                                   #<Inst (Pop)>
;;;                                   #<Inst (Var X)>
;;;                                   #<Inst (Call CDR-LOCAL)>
;;; the last 5 of which become  #<Inst (Var X)>
;;;                             #<Inst (Call SET-TO-CDR-PUSH-CAR)>
;;;                             #<Inst (Setq [local])>
;;;                             #<Inst (Pop)>
;;;
;;; At this point, we've seen #<Inst (Var X)> and #<Inst (Jump-[conditional] [tag])>.
(defun look-for-compilicated-set-to-cdr-push-car (condx-JUMP-inst 1st-var-var)
  (when (zerop (jump-pops-if-not-successful condx-JUMP-inst))
    (let* ((call-CAR-inst (inst-next condx-JUMP-inst))
	   (call-CAR-opcode (when call-CAR-inst (inst-opcode call-CAR-inst)))
	   (who-we-call (when (eq call-CAR-opcode 'CALL)
			  (function-spec (call-function call-CAR-inst)))))
      (when (eq who-we-call 'CAR)
	(let* ((SETQ-inst (inst-next call-CAR-inst))
	       (SETQ-opcode (when SETQ-inst (inst-opcode SETQ-inst))))
	  (when (eq SETQ-opcode 'SETQ)
	    (let* ((POP-inst (inst-next SETQ-inst))
		   (POP-opcode (when POP-inst (inst-opcode POP-inst))))
	      (when (eq POP-opcode 'POP)
		(let* ((2nd-var-inst (inst-next POP-inst))
		       (2nd-var-opcode (when 2nd-var-inst (inst-opcode 2nd-var-inst))))
		  (when (eq 2nd-var-opcode 'VAR)
		    (let ((2nd-var-var (var-variable 2nd-var-inst)))
		      (when (eq 2nd-var-var 1st-var-var)
			(let* ((call-CDR-L-inst (inst-next 2nd-var-inst))
			       (call-CDR-L-opcode
				 (when call-CDR-L-inst (inst-opcode call-CDR-L-inst)))
			       (who-CL-calls (when (eq call-CDR-L-opcode 'CALL)
					       (function-spec
						 (call-function call-CDR-L-inst)))))
			  (when (eq who-CL-calls 'CDR-LOCAL)
			    (setf (function-spec (call-function call-CAR-inst))
				  'I:SYS:SET-TO-CDR-PUSH-CAR)
			    (setf (inst-next POP-inst) (inst-next call-CDR-L-inst))
			    ;; The following hairy SETFs reuse the 2nd VAR instruction.
			    (setf (inst-next condx-JUMP-inst) 2nd-var-inst)
			    (setf (inst-prev 2nd-var-inst) condx-JUMP-inst)
			    (setf (inst-next 2nd-var-inst) call-CAR-inst)
			    (setf (inst-prev call-CAR-inst) 2nd-var-inst)
			    (setf (jump-pops-if-not-successful condx-JUMP-inst) 1)
			    T))))))))))))))	;return T if optimized

(definst-method (assemble-instruction var) (function)
  (let* ((var var-variable)
	 (var-name (variable-name var)))
    (selectq (variable-type var) 
      (lexical (access-lexical-variable 'var var var-level
					(and (not compiler:var-nested-captive-environment)
					     function)))
      (special (assemble-special-location var-name i:sys:dtp-external-value-cell-pointer))
      (instance
       (assemble-instance-variable-reference
	 *push-instance-variable-opcode* var))
      (otherwise (llc-error "Unknown variable type: ~S" (variable-type var))))))

(defmethod (internal-function-needs-closure internal-function) (function-being-assembled)
  (and function-refers-lexically-p
       (not function-quick-p)
       (eq function-parent-function function-being-assembled)))

(definst-method (peep-hole-optimizer fun) (function)
  (declare (ignore function))
  (let ((next inst-next))
    (when (and next
	       (eq (inst-opcode next) 'start-call)
	       (not (call-force-external (start-call-call next)))
	       (memq (function-spec (start-call-function next))
		     *funcalling-functions*)
	       (cl:case (function-type fun-function)
		 ((external reference compiler:interpreter) t)
		 (internal (not (internal-function-needs-closure fun-function *function*)))))
      ;; Change it into a call to this function
      (setf (start-call-function next) fun-function)
      (setf (inst-prev next) inst-prev)
      (when inst-prev
	(setf (inst-next inst-prev) next))
      (assemble-normal-start-call next t)
      next)))

(definst-method (assemble-instruction fun) (&rest ignore)
  (let ((fun fun-function))
    (selectq (function-type fun)
      ((external reference)
       (let* ((fspec (function-spec fun))
	      (index 
		(assemble-constant i:sys:dtp-external-value-cell-pointer
				   (follow-cell-forwarding (fdefinition-location fspec t)
							   nil))))
	 (when *phase-4-to-core*
	   (when (or (not (fdefinedp fspec))
		     (equal (external-ancestor-function-spec *function*) fspec))
	     (setq *forward-references-exist* t)))
	 (reference-function-spec fspec index)
	 index))
      ;; This has to get a little hairy to deal with lexical closures
      (internal
       (if (internal-function-needs-closure fun *function*)
	   (assemble-lexical-closure self fun)
	   ;; No need for lexical-closure
	   (assemble-reference-to-internal-function fun)))
      (compiler:interpreter
       (assemble-constant i:sys:dtp-external-value-cell-pointer
			  (compiler:interpreter-function-location fun)))
      (otherwise
       (llc-error "Unknown function type: ~S" (function-type fun))))))

;;; assemble inline load byte / deposit byte instrs
(defun i-ldb-dpb-assemble (ppss is-dpb dest ptr-byte-op inst)
  (let ((size (byte-size ppss))
	(pos (byte-position ppss))
	(op (make-i-abstract-operand type 'byte value nil)))
    (macrolet ((ldb-dpb-ass (dpb-op ldb-op)
		 `(if is-dpb
		      (assemble ,dpb-op op)
		      (assemble ,ldb-op op))))
      (selectq ptr-byte-op
	((t)					;%P- form
	 (cond ((and ( pos 32.) ( (+ pos size) 40.))	;If extracting from tag, use %P-TAG-
		(setf (i-abstract-operand-value op)
		      (convert-l-to-i-byte-specifier (byte size (- pos 32.)) (not is-dpb)))
		(ldb-dpb-ass *%p-tag-dpb-opcode* *%p-tag-ldb-opcode*))
	       (t					;Use normal %P- form
		(setf (i-abstract-operand-value op)
		      (convert-l-to-i-byte-specifier (byte size pos) (not is-dpb)))
		(ldb-dpb-ass *%p-dpb-opcode* *%p-ldb-opcode*))))
	((nil)
	 (setf (i-abstract-operand-value op)
	       (convert-l-to-i-byte-specifier (byte size pos) (not is-dpb)))
	 (ldb-dpb-ass *dpb-opcode* *ldb-opcode*))
	((char)
	 (setf (i-abstract-operand-value op)
	       (convert-l-to-i-byte-specifier (byte size pos) (not is-dpb)))
	 (ldb-dpb-ass *char-dpb-opcode* *char-ldb-opcode*))))
    (assemble-destination-for-n-values inst dest (if (and (eq ptr-byte-op 't) is-dpb) 0 1))
    t)) ; return t indicating success

(definst-method (peep-hole-optimizer const) (&rest ignore)
  (let* ((const-value const-value)
	 (next inst-next)
	 (next-opcode (when next (inst-opcode next)))
	 (setq-variable (and (eq next-opcode 'setq) (setq-variable next))))
    (cond ((and setq-variable
		(eq (variable-type setq-variable) 'special))
	   (setq-special-peep-hole self next (setq-for-effect next)))
	  ((and (eq next-opcode 'return)
		(cond ((and (null const-value)
			    (= 1 (compiler:return-n next)))
		       ;;;#<Inst (Const NIL)>, #<Inst (Return)>
		       (assemble-return NIL)
		       next)
		      ;;;#<Inst (Const T)>, #<Inst (Return 1)>
		      ((and (eq const-value T)
			    (= 1 (compiler:return-n next)))
		       (assemble-return T)
		       next))))
	  ((null const-value)			;Cheap check
	   (peep-push-nils self))
	  ((and (listp const-value)
		(eq (first const-value) compiler:eval-at-load-time-marker))
	   nil)
	  ((and (eq next-opcode 'start-call)
		(typep const-value :generic-function)
		(not (call-force-external (start-call-call next)))
		(cl:member (function-spec (start-call-function next)) *funcalling-functions*))
	   ;; Change PUSH-GENERIC-FUNCTION, START-CALL SP|POP into DTP-CALL-GENERIC-PREFETCH.
	   ;; (Note:  PREFETCH is generated unconditionally to help the linker.)
	   (let ((pair (assq next *call-start-alist*))
		 (starter-i (assemble-constant i:sys:dtp-call-generic-prefetch const-value)))
	     (if pair
		 (setf (car pair) starter-i)
		 (push `(,starter-i . ,next) *call-start-alist*))
	     next))
	  ((and (eq next-opcode 'call)
		(not (call-force-external next)))
	   (let* ((name (function-spec (call-function next)))
		  (destination (call-destination next))
		  (immediate-type nil)
		  (built-in
		    (loop for b-i in (get name 'built-in)
			  for legal-operand-types = (built-in-format b-i)
			  do (setq immediate-type
				   (loop for type in *immediate-operand-types*
					 thereis (car (member type legal-operand-types))))
			  thereis (and immediate-type b-i)))
		  (value const-value))
	     ;; Convert ADD -1 into SUB 1 so it assembles into an immediate operand.
	     (when (and (or (eq name '+-internal) (eq name '--internal))
			(fixnump const-value)
			(minusp const-value)
			(possible-immediate-operand? (- const-value) immediate-type)
			(= (call-n-args next) 2))
	       (setq name (if (eq name '+-internal) '--internal '+-internal)
		     built-in (car (get name 'built-in))
		     value (- value)))
	     (or ;; Turn ROT with a constant operand into the equivalent LDB with
	         ;; a field-size of 32, which is faster in early versions of the
	         ;; Ivory processor.
	         (when (eql name 'rot)
		   (assemble *ldb-opcode* (make-i-abstract-operand
					    type 'byte
					    value (dpb #o37
						       (byte 5 5)
						       (ldb (byte 5 0) value))))
		   (assemble-destination-for-n-values next destination)
		   next)
		 (when (and built-in (not (typep value :extended-number)))
		   (let ((f (cdr (cl:assoc name '((i:sys:eql . i:sys:eq)
						  (i:sys:eql-no-pop . i:sys:eq-no-pop))))))
		     (when f
		       (setq name f)
		       (setf (function-spec (call-function next)) f)
		       (setq built-in (car (get f 'built-in)))))
		   ;; Allow the following optimization to work.
		   nil)
		 (when (and built-in
			    (eq name '--internal)
			    (eql value 1)
			    (eql 1 (destination-n-values destination)))
		   (maybe-optimize-loop-decrement-tos (inst-next next)))
		 (when (and built-in
			    (or (eq name '+-internal)
				(eq name '--internal)
				(eq name '%pointer-plus))
			    (eql value 1)
			    *stack-smashed*
			    (eql 1 (destination-n-values destination)))
		   (assemble (cl:case name
			       (+-internal *increment-opcode*)
			       (--internal *decrement-opcode*)
			       (%pointer-plus *%pointer-increment-opcode*))
			     (sp-operand 0))
		   next)
		 (when (and built-in
			    (possible-immediate-operand? value immediate-type)
			    ;; if numbers of args not equal, could be because phase-1
			    ;; let through bad code like (car a b) after the error message
			    (let ((built-in-n-args (built-in-n-arguments built-in)))
			      (or (eq built-in-n-args 'compiler:n)	;Kludge city
				  (= built-in-n-args (call-n-args next)))))
		   (let ((op (make-i-abstract-operand type immediate-type value value)))
		     (assemble-built-in-instruction built-in destination next op)))
		 ;; >>> This is the new rel. 7 way of doing things, which we must support
		 ;;     for the time being or remodularize the front end for the I
		 ;;     architecture.  MAB 5/09/86 16:14:09 <<<
		 (selectq name
		   (inverted-ldb (i-ldb-dpb-assemble value nil destination nil next) next)
		   (inverted-dpb (i-ldb-dpb-assemble value t destination nil next) next)
		   (inverted-%p-ldb (i-ldb-dpb-assemble value nil destination t next) next)
		   (inverted-%p-dpb (i-ldb-dpb-assemble value t destination t next) next)
		   (inverted-char-ldb
		    (i-ldb-dpb-assemble value nil destination 'char next)
		    next)
		   (inverted-char-dpb
		    (i-ldb-dpb-assemble value t destination 'char next)
		    next)
		   (%push-stack-value
		    (or (maybe-optimize-copy value (inst-next next))
			(progn (assemble *push-opcode* (sp-operand value))
			       next)))
		   (inverted-%make-pointer
		    (assemble *%set-tag-opcode* (i-op unsigned value))
		    next)
		   #+Ignore   (inverted-%make-pointer-offset
		    (assemble-unsigned-const-opcode *%make-pointer-immed-offset-opcode*
						    value
						    destination)
		    next)
		   (%store-instance-variable-ordered
		     (assemble *pop-instance-variable-ordered-opcode*
			       (i-op unsigned value))
		     next)
		   (%funcall-n
		    (cond ((call-start-call next)
			   ;; Change this into a finish-call for the start-call
			   (setf (function-spec (call-function next)) '%funcall-n*)
			   (setf (call-n-args next) value)
			   (setf (inst-prev next) inst-prev)
			   (when inst-prev (setf (inst-next inst-prev) next))
			   self)
			  (t
			   (assemble-finish-call-1 *finish-call-n-opcode* value destination)
			   next)))
		   (si:%ensure-n-pushes-without-stack-cache-spill
		    (assemble-push-n-nils value)
		    (assemble-destination-for-n-values next (call-destination next) value)
		    next)
		   (cdr
		    (when (locativep const-value)
		      (assemble-constant sys:dtp-external-value-cell-pointer const-value)
		      (assemble-destination-for-n-values next (call-destination next))
		      next))
		   )))))))

(defun (si:%ensure-n-pushes-without-stack-cache-spill assemble-function)
       (&rest ignore)
  (error "~a called without an invalid argument."
	 'si:%ensure-n-pushes-without-stack-cache-spill))

(defun setq-for-effect (setq-inst)
  (let ((next (inst-next setq-inst)))
    (and (eq (inst-opcode next) 'pop)
	 (eql (compiler:pop-n next) 1)
	 (eql (pop-save-n next) 0))))
		
(defun setq-special-peep-hole (push-inst setq-inst for-effect &aux opcode v)
  (cond (for-effect
	 (assemble-special-location (variable-name (setq-variable setq-inst)))
	 (cond ((and (eq (setq opcode (inst-opcode push-inst)) 'var)
		     (eq (variable-type (setq v (var-variable push-inst))) 'lexical))
		(assemble *rplacd-opcode* (local-operand v (1+ (var-level push-inst)))
			  (variable-name v)))
	       ((and (eq opcode 'const)
		     (possible-immediate-operand? (setq v (const-value push-inst)) 'signed))
		(assemble *rplacd-opcode* (i-op signed v)))
	       (t (setq-push-inst push-inst)
		  (assemble *rplacd-opcode* (tos-pop-operand))))
	 (inst-next setq-inst))
	(t
	 (setq-push-inst push-inst)
	 (assemble-special-location (variable-name (setq-variable setq-inst)))
	 (assemble *rplacd-opcode* (sp-operand 1))
	 setq-inst)))

(defun setq-push-inst (inst)
  (selectq (inst-opcode inst)
    (const (assemble-instruction inst nil))
    (var
     (let ((var (var-variable inst)))
       (unless (eq (variable-type var) 'lexical)
	 (ferror "Internal compiler error, please report this error.")
	 #+MBell (ferror "Aw give me a @!!$# break, You arent supposed to be here twit.")
	 )
       (assemble *push-opcode*
		 (local-operand var (var-level inst)) (variable-name var))))
    (otherwise
     (ferror "Cant handle this yet"))))

(defvar *writable-constants*)
(defvar *unsharable-constants*)

(definst-method (assemble-instruction const) (&rest ignore)
  (push-constant const-value)
  (unless compiler:const-read-only
    (cl:pushnew const-value *writable-constants*))
  (unless (eq compiler:const-sharable t)
    (cl:pushnew const-value *unsharable-constants*)))

(definst-method (assemble-instruction compiler:push-pc-array) (&rest ignore)
  (let* ((tags
	   (cl:apply #'list compiler:push-pc-array-tags))
	 (index (push-constant tags)))
    (push index *pc-array-tags*)
    index))

(definst-method (assemble-instruction pop) (&rest ignore)
  (assemble-pop compiler:pop-n pop-save-n))

(defun assemble-add-immediate (n)
  (cond ((plusp n)
	 (assemble *add-opcode* (i-op unsigned n)))
	((minusp n)
	 (assemble *sub-opcode* (i-op unsigned (- n))))))

(definst-method (assemble-instruction compiler:computed-pop) (&rest ignore)
  (let ((variables compiler:computed-pop-variables)
	(to-pop compiler:computed-pop-n)
	(to-save compiler:computed-pop-save-n))
    (dolist (var variables)
      (unless (eq (variable-type var) 'lexical)
	(llc-error "Unhandled variable type: ~S" (variable-type var))))
    ;; add up sizes
    (access-local-lexical-variable 'var (first variables) nil)
    (dolist (var (cdr variables))
      (access-local-lexical-variable 'add var nil))
    (cond ((fixp to-save)
	   (cl:case to-save
	     (0
	       (assemble-add-immediate to-pop)
	       (assemble *push-address-sp-relative-opcode* (tos-pop-operand))
	       (assemble *set-sp-to-address-opcode* (sp-operand 0)))
	     (1
	       (assemble-add-immediate to-pop)
	       (assemble *push-address-sp-relative-opcode* (tos-pop-operand))
	       (assemble *set-sp-to-address-save-tos-opcode* (sp-operand 0)))
	     (otherwise
	       (assemble-add-immediate (+ to-pop to-save -1))
	       (assemble *push-address-sp-relative-opcode* (tos-pop-operand))
	       (assemble *stack-blt-address-opcode* (sp-operand to-save)))))
	  ((eq to-save 'multiple)
	   (assemble *add-opcode* (sp-operand 1))
	   (assemble-add-immediate to-pop)
	   (assemble *push-address-sp-relative-opcode* (tos-pop-operand))
	   ;;address of base of upper multiple group
	   (assemble *push-address-sp-relative-opcode* (sp-operand 1))
	   (assemble *stack-blt-opcode* (tos-pop-operand)))
	  (t (llc-error "Illegal instruction.")))))

(definst-method (peep-hole-optimizer relative-push-address) (&rest ignore)
  (let ((next inst-next))
    (selectq (inst-opcode next)
      (call
       (let* ((destination (call-destination next))
	      (name (function-spec (call-function next)))
	      (built-in (and ;; Only apply to these two instructions, where address-operand
			     ;; means really the address, not to such other instructions
			     ;; as push-cdr-local.
			     (memq name '(%set-cdr-code-1 %set-cdr-code-2
					  i:sys:%pointer-increment
					  i:sys:%merge-cdr-no-pop))
			     (not (call-force-external next))
			     (car (get name 'built-in))))
	      ;; Take locator from function
	      (*source-locator* (inst-source-locator next)))
	 (cond ((and built-in
		     ;; if numbers of args not equal, could be because phase-1
		     ;; let through bad code like (car a b) after the error
		     ;; message
		     (= (built-in-n-arguments built-in) (call-n-args next)))
		(let ((operand (sp-operand relative-push-address-n)))
		  (when *p4-trace*
		    (format t "~%~S and ~S optimized into built-in call" self next))
		  (assemble-built-in-instruction built-in destination next operand))
		next)))))))

(definst-method (peep-hole-optimizer setq) (function)
  (let* ((next inst-next)
	 (var setq-variable)
	 (type (variable-type var)))
    (selectq (inst-opcode next)
      (pop
       (cond ((and (eql (pop-save-n next) 0)
		   (selectq type
		     (lexical (eql (compiler:pop-n next) 1))
		     (special nil)		;>>> Don't have POP-INDIRECT yet. <<<
		     (instance (eql (compiler:pop-n next) 1))
		     (otherwise (llc-error "Unknown variable type: ~S" type))))
	      (selectq type
		(lexical
		 (selectq (lexical-class var)
		   ((normal function-cell logic array-register)
		    (access-lexical-variable 'set-pop var setq-level
					     (and (not compiler:setq-nested-captive-environment)
						  function)))
		   (otherwise (llc-error "Unknown variable class: ~S" (lexical-class var)))))
		(instance
		 (assemble-instance-variable-reference *pop-instance-variable-opcode* var))
		(otherwise
		 (llc-error "Unknown variable type: ~S" type)))
	      next)
	     (t nil))))))

(definst-method (assemble-instruction setq) (function)
  (let ((var setq-variable))
    (selectq (variable-type var)
      (lexical
       (selectq (lexical-class var)
	 ((normal array-register function-cell logic)
	  (access-lexical-variable 'set var setq-level
				   (and (not compiler:setq-nested-captive-environment)
					function)))
	 (otherwise (llc-error "Unknown variable class: ~S" (lexical-class var)))))
      (special
       (assemble-special-location (variable-name var))
       (assemble *rplacd-opcode* (sp-operand 1)))
      (instance
       (assemble-instance-variable-reference *movem-instance-variable-opcode* var))
      (otherwise
       (llc-error "Unknown variable type: ~S" (variable-type var))))))

(definst-method (assemble-instruction start-call) (&rest ignore)
  ;; Calls to functions that are either in microcode or that the assembler knows about
  ;; should already have been processed.
  (assemble-normal-start-call self))

(definst-method (peep-hole-optimizer call) (&rest ignore)
  (let ((function call-function))
    (when (memq (function-type function) '(external compiler:reference))
      (let ((fspec (function-spec function)))
	(when (symbolp fspec)
	  (let ((tem (and (not (eq call-inline-p 'cl:notinline))
			  (get-built-in *compiler* fspec call-n-args))))
	    (when tem
	      (return-from peep-hole-optimizer
		(assemble-built-in-call tem call-destination self)))))
	(let ((tem (compiler:number-of-returned-values fspec)))
	  ;; Function is declared to return a specific number of values via return-kludge
	  (when tem
	    (assemble-finish-call-with-known-values tem call-destination self)))))))

(definst-method (assemble-instruction call) (&rest ignore)
  (let ((function call-function))
    (selectq (function-type function)
      ((internal compiler:interpreter)
       (assemble-finish-call self))
      ((external reference)
       (let ((spec (function-spec function))
	     (not-notinline-p (not (eq call-inline-p 'cl:notinline))))
	 (cond ((symbolp spec)
		(let (tem)
		  (cond ((and not-notinline-p
			      (setq tem (get spec 'assemble-function)))
			 ;; The assembler knows specially about this function.
			 ;; Pass the destination explicitly to make sure that
			 ;; the code doesn't forget to check it.
			 (funcall tem self call-destination))
			((and not-notinline-p
			      (setq tem (get-built-in *compiler* spec call-n-args)))
			 (llc-error "peep-hole optimizer for CALL didn't catch this")
			 ;; This function is in microcode; there are special instructions.
			 (assemble-built-in-call tem call-destination self))
			((setq tem (get spec 'quick-external))
			 ;; This function is one of the quick external functions.
			 (ferror "Don't know what to do with QUICK-EXTERNAL functions."))
			;; It's a normal external function.
			(t (assemble-finish-call self)))))
	       (t (assemble-finish-call self)))))
      (otherwise
       (llc-error "Unknown function type.")))))

(definst-method (assemble-instruction macro-instruction) (&rest ignore)
  (let ((bits macro-instruction-bits))
    (assemble (if bits
		  (get-opcode-name (ldb i:sys:%%packed-instruction-opcode bits))
		  macro-instruction-opcode)
	      (make-i-abstract-operand
		type '10-bit-immediate
		value (if bits
			  (ldb i:sys:%%packed-instruction-10-bit-operand bits)
			  macro-instruction-operand)))))

(definst-method (assemble-instruction push-pc) (&rest ignore)
  (let ((index (assemble-constant i:sys:dtp-even-pc 0)))
    (push (cons index push-pc-tag) *all-pc-tags*)
    index))

(definst-method (assemble-instruction tag) (&rest ignore)
  (note-tag self))

(defun branch-opcode (condition pops-if pops-if-not)
  ;; I think that executing BRANCH-*-AND-NO-POP-ELSE-NO-POP-EXTRA-POP should
  ;; FEP the machine and ground some signal to a power supply.
  (selectq condition
    (always *branch-opcode*)
    (true
     (selector pops-if =
       (0 (selector pops-if-not =
	    (0 *branch-true-no-pop-opcode*)
	    (1 *branch-true-and-no-pop-opcode*)))
       (1 (selector pops-if-not =
	    (0 *branch-true-else-no-pop-opcode*)
	    (1 *branch-true-opcode*)
	    (2 *branch-true-else-extra-pop-opcode*)))
       (2 (selector pops-if-not =
	    (1 *branch-true-and-extra-pop-opcode*)
	    (2 *branch-true-extra-pop-opcode*)))))
    (false
     (selector pops-if =
       (0 (selector pops-if-not =
	    (0 *branch-false-no-pop-opcode*)
	    (1 *branch-false-and-no-pop-opcode*)))
       (1 (selector pops-if-not =
	    (0 *branch-false-else-no-pop-opcode*)
	    (1 *branch-false-opcode*)
	    (2 *branch-false-else-extra-pop-opcode*)))
       (2 (selector pops-if-not =
	    (1 *branch-false-and-extra-pop-opcode*)
	    (2 *branch-false-extra-pop-opcode*)))))))

(defun unparse-branch-opcode (opcode)
  (declare (values condition pops-if pops-if-not))
  (selector opcode =
    (*branch-opcode*						(values 'always 0 0))
    (*branch-true-extra-pop-opcode* 				(values 'true   2 2))
    (*branch-true-opcode* 					(values 'true   1 1))
    (*branch-true-and-extra-pop-opcode* 			(values 'true   2 1))
    (*branch-true-else-no-pop-opcode* 				(values 'true   1 0))
    (*branch-true-else-extra-pop-opcode* 			(values 'true   1 2))
    (*branch-true-and-no-pop-opcode* 				(values 'true   0 1))
    (*branch-true-and-no-pop-else-no-pop-extra-pop-opcode* 	(values 'true   1 1))
    (*branch-true-no-pop-opcode* 				(values 'true   0 0))
    (*branch-false-extra-pop-opcode* 				(values 'false  2 2))
    (*branch-false-opcode* 					(values 'false  1 1))
    (*branch-false-and-extra-pop-opcode* 			(values 'false  2 1))
    (*branch-false-else-no-pop-opcode* 				(values 'false  1 0))
    (*branch-false-else-extra-pop-opcode* 			(values 'false  1 2))
    (*branch-false-and-no-pop-opcode* 				(values 'false  0 1))
    (*branch-false-and-no-pop-else-no-pop-extra-pop-opcode* 	(values 'false  1 1))
    (*branch-false-no-pop-opcode* 				(values 'false  0 0))))

#+ignore
(defun test-branch-opcodes ()
  (loop for opcode in (list *branch-opcode*
			    *branch-true-extra-pop-opcode*
			    *branch-true-opcode*
			    *branch-true-and-extra-pop-opcode*
			    *branch-true-else-no-pop-opcode*
			    *branch-true-else-extra-pop-opcode*
			    *branch-true-and-no-pop-opcode*
			    *branch-true-and-no-pop-else-no-pop-extra-pop-opcode*
			    *branch-true-no-pop-opcode*
			    *branch-false-extra-pop-opcode*
			    *branch-false-opcode*
			    *branch-false-and-extra-pop-opcode*
			    *branch-false-else-no-pop-opcode*
			    *branch-false-else-extra-pop-opcode*
			    *branch-false-and-no-pop-opcode*
			    *branch-false-and-no-pop-else-no-pop-extra-pop-opcode*
			    *branch-false-no-pop-opcode*)
	do (multiple-value-bind (condition pops-if pops-if-not)
	       (unparse-branch-opcode opcode)
	     (let ((xopcode (branch-opcode condition pops-if pops-if-not)))
	       (unless (or (= opcode xopcode)
			 (and (= opcode *branch-true-and-no-pop-else-no-pop-extra-pop-opcode*)
			      (= xopcode *branch-true-opcode*))
			 (and (= opcode *branch-false-and-no-pop-else-no-pop-extra-pop-opcode*)
			      (= xopcode *branch-false-opcode*)))
		 (format t "~%Opcode ~O is ~A ~O ~O, encodes as ~O"
			 opcode condition pops-if pops-if-not xopcode))))))

(definst-method (assemble-instruction jump) (&rest ignore)
  (let ((opcode (branch-opcode jump-condition jump-pops-if-successful
			       jump-pops-if-not-successful)))
    (when jump-error-info
      (ferror "JUMP-ERROR-INFO not supported yet."))
    (let* ((tos-state (not *stack-smashed*))
	   (branch
	     (note-branch
	       (if (eq jump-condition 'always)
		   (progn (if (plusp jump-pops-if-successful)
			      (assemble-pop jump-pops-if-successful 0))
			  'jump)
		   'conditional-jump)
	       (progn 
		 (when (and (eq jump-condition 'always)
			    (null tos-state)
			    (neq (tag-tos-status jump-tag) 'not-used))
		   (setf tos-state 'fixed)
		   (assemble *movem-opcode* (sp-operand 0)))
		 (assemble opcode (i-op signed 0)))
	       jump-tag)))
      (setf (branch-tos-state branch) tos-state)
      branch)))

(definst-method (assemble-instruction return) (&rest ignore)
  (assemble-return compiler:return-n))

(defmethod (push-logic-variable-at-top-of-stack compiler:push-logic-variable-instruction) ()
  (eql (variable-stack-offset compiler:push-logic-variable-variable
			      inst-pre-control-stack-state
			      compiler:push-logic-variable-level
			      :allow-logic-variables t)
       0))

(definst-method (peep-hole-optimizer push-logic-variable) (function)
  ;; similar to peep-push-nils
  (loop with names = nil
	with count = 0
	for i = self then (inst-next i)
	and l = nil then i
	for next = (when i (inst-next i))
	while (and next
		   (not (eq (inst-opcode next) 'setq))
		   (selectq (inst-opcode i)
		     (compiler:push-logic-variable
		      (when (push-logic-variable-at-top-of-stack i)
			(incf count)
			t))
		     (name
		      (push i names)
		      t)))
	finally
	(when (plusp count)
	  (assemble *push-local-logic-variables-opcode* (i-op unsigned count))
	  (loop for name in names
		do (assemble-instruction name function))
	  (return l))))

(definst-method (assemble-instruction push-logic-variable) (function)
  ;; we assume that the peepholer has taken care of those which are being pushed in place
  (assemble-var-location compiler:push-logic-variable-variable
			 compiler:push-logic-variable-level function)
  (assemble *%set-tag-opcode* (i-op unsigned i:sys:dtp-logic-variable)))

(defun assemble-var-location (var level function)
  (let ((type (variable-type var)))
    (selectq type
      (lexical (access-lexical-variable 'var-location var level function))
      (special (assemble-special-location (variable-name var)))
      (instance (assemble-instance-variable-reference
		  *push-address-instance-variable-opcode* var))
      (otherwise (llc-error "Unknown variable type ~S for var-location" type)))))

(definst-method (assemble-instruction var-location) (function)
  (assemble-var-location var-location-variable var-location-level function))

(definst-method (assemble-instruction bind) (&rest ignore)
  ;; When we get here, the value is on the top of the stack.  We have to do this bit
  ;; of kludgery since the BIND-LOCATIVE-TO-VALUE instruction takes its arguments
  ;; in the wrong order - that is, the locative to the location being bound is the
  ;; first argument.  The alternative is to change the front-end to emit different
  ;; byte-lap.
  (lisp:ecase (compiler:bindings-in-control-stack *compiler*)
    ((0)
     (cond (bind-variable
	    (assemble-special-location (variable-name bind-variable))
	    (assemble *bind-locative-to-value-opcode* (sp-operand 1))
	    (assemble-pop 1 0))
	   (t
	    (assemble *bind-locative-to-value-opcode* (tos-pop-operand)))))
    ((3)
     (when bind-variable
       (assemble *push-opcode* (sp-operand 0))
       (assemble-special-location (variable-name bind-variable))
       (assemble *pop-opcode* (sp-operand 2)))
     (assemble *%read-internal-register-opcode* (i-op 10-bit-immediate
						      sys:%register-binding-stack-pointer))
     (assemble *%set-cdr-code-2-opcode* (sp-operand 1))
     (assemble *%set-cdr-code-1-opcode* (sp-operand 0))
     (assemble-constant sys:dtp-call-indirect-prefetch (locf #'compiler:%set-binding-stack-pointer))
     (assemble *push-address-opcode* (sp-operand 4))
     (assemble *finish-call-n-opcode* (i-op 10-bit-immediate
					    (make-finish-call-n-operand
					      n-args-+1 2
					      disposition (value-disposition-number 0)))))))

(definst-method (assemble-instruction unbind) (&rest ignore)
  (lisp:ecase (compiler:bindings-in-control-stack *compiler*)
    ((0)
     (cond ((= unbind-n 0)
	    )
	   ((= unbind-n 1)
	    (assemble *unbind-n-opcode* (i-op unsigned 1)))
	   (t
	    (push-constant unbind-n)
	    (assemble *unbind-n-opcode* (tos-pop-operand)))))
    ((3)
     (assemble-constant sys:dtp-call-indirect-prefetch (locf #'sys:unbind-n-internal))
     (push-constant unbind-n)
     (assemble *finish-call-n-opcode* (i-op 10-bit-immediate
					    (make-finish-call-n-operand
					      n-args-+1 2
					      disposition (value-disposition-number 0)))))))

(defun assemble-catch-open-operand (unwind-protect-p destination)
  (i-op 10-bit-immediate
	(make-catch-open-operand
	  unwind-protect-p (if unwind-protect-p 1 0)
	  value-disposition (value-disposition-number destination))))

(definst-method (assemble-instruction start-catch) (&rest ignore)
  (let* ((dest (destination-size start-catch-destination))
	 (operand (assemble-catch-open-operand nil dest))
	 (tag (catch-internal-tag start-catch-pframe)))
    (if (and tag (inst-next tag))
	(push (cons (assemble-constant i:sys:dtp-even-pc 0) tag) *all-pc-tags*)
	(if (eq dest 'return)
	    (assemble-push-n-nils 1)
	    (ferror "Missing tag for catch with destination not ~A" dest)))
    (assemble *catch-open-opcode* operand
	      (unless (eq dest 'return)
		(make-i-branch-qualifiers
		  condition 'throw
		  pop-condition nil
		  destination tag
		  short-form? nil)))))

(definst-method (assemble-instruction start-unwind-protect) (&rest ignore)
  (push (cons (assemble-constant i:sys:dtp-even-pc 0) start-unwind-protect-handler)
	*all-pc-tags*)
  (assemble *catch-open-opcode*
	    ;; >>> Is the destination -always- 'stack??? <<<
	    (assemble-catch-open-operand t 1)
	    (make-i-branch-qualifiers
	      condition 'unwind-protect
	      pop-condition nil
	      destination start-unwind-protect-handler
	      short-form? nil)))

(definst-method (assemble-instruction end-catch) (&rest ignore)
  (let* ((dest (destination-size end-catch-destination))
	 (pframe end-catch-pframe)
	 (catch-block-sp-offset (+ (catch-pframe-size pframe) compiler:end-catch-extra-pops)))
    (assemble *catch-close-opcode* nil)
    ;; The cleanup code
    (selectq dest
      ((0)
       ;; The catch block is on the top of the stack
       (assemble *set-sp-to-address-opcode* (sp-operand catch-block-sp-offset)))
      ((1)
       ;; The stack contains the catch block and a single value
       (assemble *set-sp-to-address-save-tos-opcode* (sp-operand catch-block-sp-offset)))
      ((return)
       (ferror "Internal compiler error - trying to compile an end-catch to ~A" dest))
      (otherwise
       (assemble-pop catch-block-sp-offset dest)))))

(definst-method (assemble-instruction take-args) (function)
  (let* ((need-to-shuffle-stack (function-needs-to-shuffle-stack function))
	 (n-required (+ take-args-n-required (if need-to-shuffle-stack 2 0)))
	 (n-optional take-args-n-optional)
	 (rest-p take-args-rest-p)
	 (ints take-args-init-intervals)
	 (op1 (i-op entry (+ n-required 2)))
	 (op2 (i-op entry (+ n-required n-optional 2)))
	 entry-inst
	 direct-call-inst)
    (when need-to-shuffle-stack
      ;; Take the environment and the rest as an &REST arg
      (let ((shuffle-entry (assemble *entry-rest-accepted-opcode* (i-op entry 3))))
	(push (list shuffle-entry '.lexical-environment-pointer.)
	      *variable-creation-alist*))
      (assemble *entry-rest-accepted-opcode* (i-op entry 3))
      (let ((rest-arg-inst (assemble-push-n-nils 1)))
	(push (list rest-arg-inst 'arguments) *variable-creation-alist*))
      (assemble-no-ops 1)
      ;; Start a call to a PC a little further along in our code
      (setq direct-call-inst 
	    (assemble-constant
	      i:sys:dtp-call-compiled-even
	      0))
      ;; Pass SELF-MAPPING-TABLE and SELF as arguments
      (let* ((e-var (find-lexical-variable-named function '.lexical-environment-pointer.))
	     (old-e-loc (lexical-location e-var))
	     (*stack-shuffling* t))
	(setf (lexical-location e-var) 0)
	(access-lexical-variable
	  'var
	  (find-lexical-variable-named function 'self-mapping-table)
	  0
	  function)
	(access-lexical-variable
	  'var
	  (find-lexical-variable-named function 'self)
	  0
	  function)
	(setf (lexical-location e-var) old-e-loc))
      ;; Pass the environment
      (assemble *push-opcode* (i-op frame-pointer 2))
      ;; Pass the other arguments
      (assemble *push-opcode* (i-op local-pointer 0))
      (let ((final-address
	      (assemble-finish-call-1 *finish-call-n-apply-opcode* 4 *destination-return*)))
	(when (evenp final-address)
	  (assemble *no-op-opcode* (sp-operand 0))
	  (set-pc-sequencing final-address sequencing-pc-even+2-odd+3)))
      )
    ;; >>> Entry instructions use both half-words of a packed-instruction word. <<<
    (cond (rest-p (setq entry-inst (assemble *entry-rest-accepted-opcode* op1))
		  (assemble *entry-rest-accepted-opcode* op2))
	  (t (setq entry-inst (assemble *entry-rest-not-accepted-opcode* op1))
	     (assemble *entry-rest-not-accepted-opcode* op2)))
    (when need-to-shuffle-stack
      (set-tag-and-data
	direct-call-inst
	(if (oddp entry-inst)
	    (dpb i:sys:sequencing-pc-even+2-odd+3
		 i:sys:%%q-cdr-code-within-tag
		 i:sys:dtp-call-compiled-odd)
	    (dpb i:sys:sequencing-pc-even+2-odd+3
		 i:sys:%%q-cdr-code-within-tag
		 i:sys:dtp-call-compiled-even))
	(lsh entry-inst -1)))
    ;; When we have an init interval to assemble, do so.
    (when ints
      (note-dispatch t 1 ints))			;Entry-size is in full-words
    ;; Add entry for REST arg
    (when (and rest-p (zerop n-optional))
      (assemble-push-n-nils 1)
      (assemble-no-ops 1))
    ;; Add LOCATE-LOCALS when both &OPTIONAL and &REST args
    (setq *first-real-tag* (make-tag))
    (note-tag *first-real-tag*)
    (when (and rest-p (plusp n-optional))
      (assemble *locate-locals-opcode* (tos-operand)))
    ;; Return the entry instruction
    (setq *last-entry-instruction* entry-inst)
    entry-inst))

(definst-method (assemble-instruction take-values) (&rest ignore)
  (assemble *take-values-opcode* (i-op unsigned take-values-destination)))

(defun inst-not-implemented (inst)
  (ferror "~S is not implemented for the I architecture." (inst-opcode inst)))

(definst-method (assemble-instruction take-arg) (&rest ignore)
  (inst-not-implemented self))
(definst-method (assemble-instruction require-args) (&rest ignore)
  (inst-not-implemented self))

;(definst-method (assemble-instruction take-keyword-argument) (function)
;  (let ((type (variable-type take-keyword-argument-rest-arg)))
;    (unless (eq type 'lexical)
;      (llc-error "~S unacceptable variable type for take-keyword-argument instruction"
;		 type)))
;  (assemble *rgetf-opcode* (i-op local-pointer 0))
;  (let* ((interval take-keyword-argument-interval)
;	 (first-inst (inst-next (interval-first interval)))	;Skip the NO-OP
;	 (second-inst (inst-next first-inst)))
;    (if (and (eq (inst-opcode first-inst) 'const)	;Optimize no init form case
;	     (null (const-value first-inst))
;	     (eq second-inst (interval-last interval))
;	     (eq (inst-opcode second-inst) 'no-op))
;	;; Just pop off FOUNDP value returned by RGETF
;	(assemble-pop 1 0)
;	;; Have to branch around the init form code if value found
;	(let ((tag (make-tag)))
;	  (setf (inst-next tag) inst-next)
;	  (setf inst-next tag)
;	  (note-branch 'conditional-jump
;		       (assemble *branch-true-else-extra-pop-opcode* (i-op signed 0))
;		       tag)
;	  (let ((last-inst (interval-last interval)))
;	    ;; Don't assemble the NO-OP at the end of the interval
;	    (when (eq (inst-opcode last-inst) 'no-op)
;	      (let ((new-last (inst-prev last-inst)))
;		(setf (inst-next new-last) nil)
;		(setf (interval-last interval) new-last)))
;	    (assemble-interval interval function))))))

;;; This is used when we need more FP-addressable registers than our caller provided.
(definst-method (assemble-instruction compiler:pad-argument-block) (&rest ignore)
  (let* ((args-info (function-args-info *function*))
	 (old-size (ldb %%arg-desc-max-args args-info))
	 (direct-call-inst (assemble-constant i:sys:dtp-call-compiled-even-prefetch 0)))
    (lisp:assert (ldb-test %%arg-desc-rest-arg args-info))
    (dotimes (i old-size)
      (assemble *push-opcode* (i-op frame-pointer (+ 2 i))))
    (assemble-push-n-nils compiler:pad-argument-block-n)
    (assemble *push-opcode* (i-op local-pointer 0))
    (let ((final-address
	    (assemble-finish-call-1 *finish-call-n-apply-opcode*
				    (+ old-size compiler:pad-argument-block-n 1)
				    *destination-return*)))
      (when (evenp final-address)
	(assemble *no-op-opcode* (sp-operand 0))
	(set-pc-sequencing final-address sequencing-pc-even+2-odd+3)))
    (let ((entry-inst (let ((op1 (i-op entry (+ 2 old-size compiler:pad-argument-block-n))))
			(prog1 (assemble *entry-rest-accepted-opcode* op1)
			       (assemble *entry-rest-accepted-opcode* op1)))))
      (assemble-push-n-nils 1)
      (assemble-no-ops 1)
      (set-tag-and-data
	direct-call-inst
	(dpb (if (oddp entry-inst)
		 i:sys:dtp-call-compiled-odd-prefetch
		 i:sys:dtp-call-compiled-even-prefetch)
	     i:sys:%%q-type-within-tag
	     (get-tag-and-data direct-call-inst))
	(lsh (+ entry-inst 4) -1))
      (setf *stack-smashed* t))))

;; This optimizes PUSH SP|0, FOO SP|POP into FOO SP|0.
;; See also the more common optimization of CONST n, %PUSH-STACK-VALUE.
(definst-method (peep-hole-optimizer copy) (&rest ignore)
  (when (and (null copy-past-multiple)
	     (eq (inst-opcode inst-next) 'call))
    (maybe-optimize-copy copy-n inst-next)))

(defun maybe-optimize-copy (n inst)
  (when (typep inst 'call-instruction)
    (let* ((function (function-spec (call-function inst)))
	   (n-args (call-n-args inst))
	   (built-in (and (not (call-force-external inst))
			  (get-built-in *compiler* function n-args))))
      (when built-in
	(assemble-built-in-instruction
	  built-in (call-destination inst) inst (sp-operand n))))))

(definst-method (assemble-instruction copy) (&rest ignore)
  (if copy-past-multiple
      (progn
	(assemble *push-address-sp-relative-opcode* (sp-operand 0))
	(unless (zerop copy-n)
	  (assemble *%pointer-plus-opcode* (i-op signed (- copy-n))))
	(assemble *car-opcode* (tos-pop-operand)))
      (assemble *push-opcode* (sp-operand copy-n))))

(definst-method (assemble-instruction relative-push-address) (&rest ignore)
  (assemble *push-address-opcode* (sp-operand relative-push-address-n)))

(defun assemble-utility-call (spec n-args destination)
  (if (zerop n-args)
      (let ((starter (assemble-constant i:sys:dtp-call-indirect spec))
	    (finisher (assemble-finish-call-1 *finish-call-n-opcode* n-args destination)))
	(push `(,starter . ,finisher) *call-start-alist*)
	t)
      (ferror "Can't assemble utility calls with args")))

(definst-method (assemble-instruction throw) (&rest ignore)
  (ferror "Internal compiler error - phase-2 should not pass on THROW instructions on the
I machine."))

(definst-method (peep-hole-optimizer allocate-local-block) (&rest ignore)
  (peep-push-nils self))

(definst-method (assemble-instruction allocate-local-block) (&rest ignore)
  (let ((n (function-local-block-size *function*)))
    (when (plusp n)
      (assemble-push-n-nils n))))

(definst-method (assemble-instruction popj) (&rest ignore)
  (selectq popj-save-n
    (0 (assemble *%jump-opcode* (tos-pop-operand)))
    (multiple	(ferror "Can't handle compilation of POPJ with MULTIPLE SAVE-N"))
    (otherwise (ferror "Can't handle compilation of POPJ with SAVE-N = ~S" popj-save-n))))

(definst-method (assemble-instruction pop-vars) (&rest ignore)
  (error "Internal compiler error = phase-2 should not generate POP-VARS instructions on the
I machine."))

(definst-method (assemble-instruction name) (&rest ignore)
  (unless *inhibit-local-map*
    (let ((names (loop for var in name-variables
		       when (and (eq (variable-type var) 'lexical)
				 (not (lexical-captive-p var)))
			 collect  (if (lexical-function-cell-p var)
				      (list (lexical-function-cell-p var))
				      (variable-name var))))
	  (shuffle-p (not (eql *last-entry-instruction* 0))))
      (cond ((typep inst-prev 'take-args-instruction)
	     (let* ((required (+ (take-args-n-required inst-prev)))
		    (optional (take-args-n-optional inst-prev))
		    (rest-p (take-args-rest-p inst-prev))
		    (n-variables (+ required optional (if rest-p 1 0)))
		    (entry *last-entry-instruction*))
	       ;; If there are special args, push NILs for them
	       (loop repeat (- n-variables (length names)) doing (push nil names))
	       (when shuffle-p
		 (setq names (list* 'self-mapping-table 'self names))
		 (incf required 2))
	       (push (cons entry (loop repeat required collect (pop names)))
		     *variable-creation-alist*)
	       (loop for i from (+ entry 2) by 2
		     for var in names
		     doing
		 (push (cons i (list var)) *variable-creation-alist*))
	       t))
	    ((and (null (cdr names))
		  (eq (car names) '.lexical-environment-pointer.)
		  ;; If the name follows the allocate-local-block, then it
		  ;; corresponds to the extra argument, thanks to phase-2.
		  (eq (inst-opcode inst-prev) 'allocate-local-block))
	     ;; If the variable is .LEXICAL-ENVIRONMENT-POINTER.
	     ;; then put it into the arglist where it belongs,
	     ;; instead of here where it doesn't belong.  Barf!!
	     (let ((old-pair (cl:assoc *last-entry-instruction* *variable-creation-alist*)))
	       (if shuffle-p
		   (setf (fourth old-pair) '.lexical-environment-pointer.)
		   (setf (second old-pair) '.lexical-environment-pointer.))))
	    (t (add-names names))))))

(defun add-names (names)
  (let* ((pc (instruction-array-current-pc *instruction-array*))
	 (old-pair (cl:assoc pc *variable-creation-alist*)))
    (if old-pair
	(if (numberp (cadr old-pair))
	    (setf (cddr old-pair) (nconc names (cddr old-pair)))
	    (setf (cdr old-pair) (nconc names (cdr old-pair))))
	(push (cons pc names) *variable-creation-alist*))))

(defun assemble-setup-array (type operand)
  (assemble
    (selectq type
      (normal *setup-1d-array-opcode*)
      (force-1d *setup-force-1d-array-opcode*)
      (otherwise (llc-error "Bad type of array setup ~S" type)))
    operand))

;;; This is popping what it should be able to get directly.
;;; This is fixed by the peephole optimizer, for the easy case.
(definst-method (assemble-instruction setup-array) (&rest ignore)
  (assemble-setup-array
    (compiler:array-register-type compiler:setup-array-register-variable)
    (tos-pop-operand)))

;;; An array register variable thinks its home is the slot with the array word in
;;; it, but the operand for the fast-* instructions indicates the control word.
;;; The assemblers for those instructions call this to derive the operand, by
;;; simple-mindedly offsetting from the normal home by one.
(defun array-register-operand (var level)
  (multiple-value-bind (stack-p offset)
      (use-stack-addressing-p var level (lexical-location var))
    (let ((operand (if stack-p
		       (sp-operand (1- (+ offset -1)))
		       (lexical-var-operand var 1))))
      (setf (i-abstract-operand-variable-referenced operand) var)
      operand)))

(definst-method (assemble-instruction fast-aref) (&rest ignore)
  (assemble *fast-aref-1-opcode*
	    (array-register-operand fast-aref-variable fast-aref-level))
  (assemble-destination-for-n-values self *destination-stack*))

(definst-method (assemble-instruction fast-aset) (&rest ignore)
  (assemble *fast-aset-1-opcode* (array-register-operand fast-aset-variable fast-aset-level)))

(definst-method (peep-hole-optimizer capture-argument) (&rest ignore) nil)

(definst-method (assemble-instruction capture-argument) (function)
  (let ((var capture-argument-variable))
    (if (not (or (lexical-argument-p var)
		 (and (compiler:lexical-supplied-p var)
		      (lexical-captive-p var))))
	(llc-error "Variable ~S is not an argument" var)
	(access-local-lexical-variable 'var var 0)	;>>> More level lossage??? <<<
	(access-captive-lexical-variable 'set-pop var function nil nil))))

(definst-method (peep-hole-optimizer push-stack-closure) (&rest ignore) nil)

(definst-method (assemble-instruction push-stack-closure) (function)
  (let ((internal-function push-stack-closure-function)
	(stack-cons-heap-closures
	  (assq 'compiler:evacuable-downward-closures (function-user-declares *function*))))
    ;; Make sure we're still dealing with a stack closure
    (if (not (or (function-use-stack-closure-p internal-function) stack-cons-heap-closures))
	(ferror "Compiler error - internal function ~S of closure can't be stack-consed"
		internal-function)
	(if stack-cons-heap-closures
	    ;; Environment is captive block
	    (access-environment-variable-for-closure *function* nil push-stack-closure-level)
	    ;; Environment is just the current frame, past the header.
	    (if (compiler:function-has-lp-lexicals (function-frame-owner function))
		(assemble *push-address-opcode* (i-op local-pointer 0))
		(assemble *push-address-opcode* (i-op frame-pointer 2))))
	;; Push internal function
	(assemble-reference-to-internal-function internal-function)
	;; Set the CDR code of the first word
	(assemble *%set-cdr-code-2-opcode* (sp-operand 1)))))

(definst-method (assemble-instruction flavor-mapping-table) (&rest ignore)
  (let* ((flavor flavor-mapping-table-flavor)
	 (insts (assq flavor *mapping-table-instructions*))
	 (assembled-inst (assemble *aref-1-opcode* (i-op unsigned 0))))
    (if insts
	(push assembled-inst (cdr insts))
	(push (list flavor assembled-inst) *mapping-table-instructions*))
    assembled-inst))

(definst-method (assemble-instruction block-read-test) (&rest ignore)
  ;; Make TOS valid if required.
  (when compiler:block-read-test-require-tos-valid
    (cond (*stack-smashed* (assemble-1 *movem-opcode* (sp-operand 0)))
	  (t (dolist (tag *tos-tags*)
	       (setf (tag-tos-status tag) 'not-used))
	     (setf *tos-tags* nil))))
  (assemble (cl:ecase compiler:block-read-test-bar
	      (1 *%block-1-read-test-opcode*)
	      (2 *%block-2-read-test-opcode*)
	      (3 *%block-3-read-test-opcode*))
	    (i-op 10-bit-immediate compiler:block-read-test-code)))

(definst-method (assemble-instruction compiler:arg-supplied-p) (&rest ignore)
  (let* ((arg compiler:arg-supplied-p-arg)
	 (arg-var (compiler:argument-var arg))
	 (var
	   (if (typep arg-var 'compiler:special-variable)
	       (compiler:argument-ivar arg)
	       arg-var))
	 (fun (function-frame-owner (lexical-function var))))
    (when (compiler:lexical-original-variable var)
      (setq var (compiler:lexical-original-variable var)))
    (cond ((zerop (ldb %%arg-desc-rest-arg (function-args-info fun)))
	   (assemble *%read-internal-register-opcode*
		     (i-op 10-bit-immediate i:sys:%register-control-register))
	   (i-ldb-dpb-assemble i:sys:%%cr.argument-size nil *destination-stack* nil self)
	   (assemble *greaterp-opcode* (i-op immediate (+ (lexical-location var) 2))))
	  (t
	   (push-constant (lexical-location var))
	   (assemble *lessp-opcode* (i-op local-pointer 1))))))

(defun (%stack-frame-pointer assemble-function) (inst destination)
  (assemble *push-address-opcode* (i-op frame-pointer 0))
  (assemble-destination-for-n-values inst destination))

(defun (cli::%saved-control-register-address assemble-function) (inst destination)
  (assemble *push-address-opcode* (i-op frame-pointer 1))
  (assemble-destination-for-n-values inst destination))

(defun (%saved-control-register assemble-function) (inst destination)
  (assemble *push-opcode* (i-op frame-pointer 1))
  (assemble-destination-for-n-values inst destination))

(defun (cli::%set-saved-control-register assemble-function) (inst destination)
  (cond ((eql 0 (destination-n-values destination))
	 (assemble *pop-opcode* (i-op frame-pointer 1))
	 (assemble-destination-for-n-values inst destination 0))
	(t
	 (assemble *movem-opcode* (i-op frame-pointer 1))
	 (assemble-destination-for-n-values inst destination))))

(defun (%saved-continuation-register assemble-function) (inst destination)
  (assemble *push-opcode* (i-op frame-pointer 0))
  (assemble-destination-for-n-values inst destination))

(defun (cli::%set-saved-continuation-register assemble-function) (inst destination)
  (cond ((eql 0 (destination-n-values destination))
	 (assemble *pop-opcode* (i-op frame-pointer 0))
	 (assemble-destination-for-n-values inst destination 0))
	(t
	 (assemble *movem-opcode* (i-op frame-pointer 0))
	 (assemble-destination-for-n-values inst destination))))

;;; >>> Note: the next two could probably be defined using a BUILT-IN definition
;;;     on the + instruction. <<<
(defun (1+ assemble-function) (inst destination)
  (cond ((= (call-n-args inst) 1)
	 (assemble *add-opcode* (i-op unsigned 1))
	 (assemble-destination-for-n-values inst destination))
	(t (ferror "1+ only takes 1 argument"))))

(defun (1- assemble-function) (inst destination)
  (cond ((= (call-n-args inst) 1)
	 (assemble *sub-opcode* (i-op unsigned 1))
	 (assemble-destination-for-n-values inst destination))
	(t (ferror "1- only takes 1 argument"))))

(defun (%pointer+1 assemble-function) (inst destination)
  (cond ((= (call-n-args inst) 1)
	 (assemble *%pointer-plus-opcode* (i-op signed 1))
	 (assemble-destination-for-n-values inst destination))
	(t (ferror "%POINTER+1 only takes 1 argument"))))

(defun (sys:%return-multiple assemble-function) (inst destination)
  inst destination
  (ferror "SYS:%RETURN-MULTIPLE is not implemented for the I architecture."))

;;; this is no longer generated (used to be for multiple-value-call)
;(defun (sys:%append-multiple-groups assemble-function) (inst destination)
;  ;; From V:>moon>imach>Guide>pop.text
;  inst destination
;  (assemble *push-address-sp-relative-opcode*	;address of lower group's count
;		      (sp-operand 0))
;  (assemble *car-opcode* (sp-operand 0))	;lower count (leave address in stack)
;  (assemble *add-opcode* (sp-operand 2))	;sum of counts
;  (assemble *pop-opcode* (sp-operand 2))	;set upper count to the sum
;  (assemble *push-opcode* (sp-operand 0))	;copy to-address (address of lower count)
;  (assemble *%pointer-plus-opcode*		;from address (to squeeze lower count out
;		     (i-op signed 1))		; of stack)
;  (assemble *stack-blt-opcode* (tos-pop-operand)))	;copy block down

;;; This is a macro on the I machine
;(defun (%funcall-in-auxiliary-stack-buffer assemble-function) (inst destination)
;  inst destination
;  (ferror "%FUNCALL-IN-AUXILIARY-STACK-BUFFER is not implemented for the I architecture."))

;(defun (type-member assemble-function) (inst destination)
;  inst
;  (assemble *type-member-opcode* NIL)
;  (assemble-value-to-destination destination))

(defun (not assemble-function) (inst destination)
  (assemble
    *type-member-opcode*
    (i-op 12-bit-unsigned-immediate (compute-type-member-operand (list i:sys:dtp-nil))))
  (assemble-destination-for-n-values inst destination))

;;; I know, I know, this may seem gross, but I can't think of any better way of doing it.
;;; The following 4 instructions have been eliminated from Rev 0, since the assembly which
;;; follows is equivalent.
(defun (endp-no-pop assemble-function) (inst destination)
  inst destination
  (assemble *endp-opcode* (tos-operand)))

(defun (plusp-no-pop assemble-function) (inst destination)
  inst destination
  (assemble *plusp-opcode* (tos-operand)))

(defun (minusp-no-pop assemble-function) (inst destination)
  inst destination
  (assemble *minusp-opcode* (tos-operand)))

(defun (zerop-no-pop assemble-function) (inst destination)
  inst destination
  (assemble *zerop-opcode* (tos-operand)))

;;;; Short/long branch management.

;;; Define a type of branch (see the definition of the "branch" structure).
;(defmacro defbranch (opcode inclusive-min exclusive-max)
;  `(progn 'compile
;	  (defprop ,opcode ,inclusive-min min-branch)
;	  (defprop ,opcode ,exclusive-max max-branch)))
;
;(defbranch jump -512. 511.)
;(defbranch conditional-jump -512. 511.)
;(defbranch error -1_30 1_30)

(defun branch-long-p (type length)
  (selectq type
    ((jump loop-decrement-tos loop-increment-tos-less-than)
     (or (< length -512.)
	 (> length 511.)))
    (conditional-jump
     (or (< length -512.)
	 (> length 511.)))
    (error t)
    (otherwise (llc-error "~S is not a known branch type." type))))

(defun fixup-branches ()
  (relocate-branches-and-tags)
  ;; Because of dispatches, the branches are not necessarily in reverse order
  ;; as you might think.  They have to be sorted for pass-over-branches to work.
  (setq *all-branches*
	(sort *all-branches* #'(lambda (b1 b2) (< (branch-pre-address b1)
						  (branch-pre-address b2)))))
  (setq *all-tags*
	(sort *all-tags* #'(lambda (t1 t2) (< (tag-address t1) (tag-address t2)))))
  (loop while (pass-over-branches))
  (spread-code-for-branches)
  (fill-in-branches)
  (insert-code-for-hops)
  )

;;; Adjust the addresses in the branches and the tags to take into account
;;; the merging together of the instruction arrays.
(defun relocate-branches-and-tags ()
  (dolist (branch *all-branches*)
    (incf (branch-pre-address branch)
	  (instruction-array-total-offset (branch-instruction-array branch)))
    (incf (branch-post-address branch)
	  (instruction-array-total-offset (branch-instruction-array branch))))
  (dolist (tag *all-tags*)
    (incf (tag-address tag)
	  (instruction-array-total-offset (tag-instruction-array tag)))))

(defun extra-words-for-branch (branch)
  ;; >>> This whole approach makes no attempt to avoid NO-OPs.  The alternative is
  ;;     to do the branch fixup on an un-sequenced instruction vector, then do a
  ;;     sequencing pass and another fixup pass to set the branch offsets.  It
  ;;     doesn't seem worth it today. <<<
  (let ((type (branch-type branch)))
    (selectq type
      (jump
       (let ((address (branch-pre-address branch)))
	 (if (evenp address)
	     1					;It will only take one extra word
	     ;; This is the hairy case.  If the PC sequencing for the word that contains
	     ;; this branch is the packed type, then it'll take two extra words:
	     ;; 
	     ;; Before:
	     ;; 
	     ;;  PC sequencing|       odd half    |        even half
	     ;;  ---------------------------------------------------------------
	     ;;  +2or+3       |       BRANCH      |  previous packed instruction
	     ;;  -1           |            Full-word constant
	     ;;  
	     ;; After:
	     ;; 
	     ;;  PC sequencing|       odd half    |       even half
	     ;;  ---------------------------------------------------------------
	     ;;  +2or+3       |       NO-OP       |  previous packed instruction
	     ;;  +2or+3       |            Full-word constant
	     ;;  +2or+3       |            Target PC
	     ;;  +2or+3       |       NO-OP       |       %JUMP
	     (let ((tag (get-tag-and-data address)))
	       (if (= (ldb i:sys:%%q-cdr-code-within-tag tag) i:sys:sequencing-pc+1)
		   1				;Only one extra word required
		   2)))))			;Will take 2 extras, as shown above.
      ;; Oddly enough, this one always requires 2 extra words.
      (conditional-jump 2)
      ;; Evenly enough, these always require 3 extra words.
      ((loop-decrement-tos loop-increment-tos-less-than) 3))))

;;; Make one pass over the branches, lengthening anything that still doesn't fit.
;;; Return t if anything was lengthened.  Assumes that *all-branches* and *all-tags*
;;; are sorted by addresses, forward.
(defun pass-over-branches ()
  (loop with did-anything-p = nil
	for branch-tail first (locf *all-branches*) then (cdr branch-tail)
	for branches = (cdr branch-tail)
	doing
    (when (null branches)
      (return did-anything-p))
    (let* ((branch (car branches))
	   (type (branch-type branch))
	   (extra-words (extra-words-for-branch branch))
	   (extra-half-words (* 2 extra-words)))
      (cond ((and (zerop (branch-extra branch))
		  (plusp extra-words))
	     ;; This branch is still in its short format and might need to be lengthened.
	     (let ((length (- (tag-address (branch-tag branch))
			      (branch-post-address branch))))
	       (when (branch-long-p type length)
		 (cond ((branch-must-be-single-instruction branch)
			;; If this is the first such branch, insert code after tyhe
			;; entry vector to skip around the intermediate branch we
			;; have to set up
			(let* ((old-hop-half-words (or (second *hops*) 0))
			       (first-real-location (tag-address *first-real-tag*))
			       (new-hop-half-words
				 (+ old-hop-half-words 3 (if *hops* 0 1)))
			       (extra-words
				 (- (ceiling new-hop-half-words 2)
				    (ceiling old-hop-half-words 2)))
			       (extra-half-words (* 2 extra-words)))
			  (unless *hops*
			    (setq *hops* (list first-real-location 0)))
			  (loop for branches on branches
				doing
			    (when ( (branch-post-address (car branches))
				     first-real-location)
			      (dolist (branch branches)
				(incf (branch-post-address branch) extra-half-words))
			      (return)))
			  (adjust-for-insertion (1- first-real-location) extra-half-words)
			  (setf (second *hops*) new-hop-half-words)
			  (push branch (cddr *hops*))
			  (pop (cdr branch-tail))
			  (setq did-anything-p t)))
		       (t
			;; The branch does not reach; it must be lengthened.
			(setq did-anything-p t)
			(setf (branch-extra branch) extra-words)
			(setf (branch-assembled-long branch) t)
			(dolist (b (cdr branches))
			  (incf (branch-post-address b) extra-half-words))
			(let ((pre-address (branch-pre-address branch)))
			  ;; Sequencing -1 is illegal for a packed instruction.
			  ;; If the sequencing is +1, then the instruction after the
			  ;; branch is at an offset of 1.
			  ;; If the sequencing is even+2, odd+3, then if we are in
			  ;; the odd instruction, the "next" instruction is 3 later.
			  ;; If we're in the even instruction, the next instruction
			  ;; is 2 later, BUT it is either has sequencing -1, in which
			  ;; case we also need to resequence the odd half of this
			  ;; word, or it has some other sequencing, which means the
			  ;; odd half of this word is not reachable, and there is no
			  ;; harm in resequencing starting there.  So, either way, we
			  ;; can start resequencing at the next instruction.
			  (adjust-for-insertion
			    (+ (branch-post-address branch)
			       (if (and (oddp pre-address)
					(= (ldb %%q-cdr-code-within-tag
						(get-tag-and-data pre-address))
					   sequencing-pc-even+2-odd+3))
				   3
				   1))
			    extra-half-words)))))))))))

(defun adjust-for-insertion (here extra-half-words)
  (do ((tags *all-tags* (cdr tags)))
      ((or (null tags)
	   ( (tag-address (car tags)) here))
       (dolist (tag tags)
	 (incf (tag-address tag) extra-half-words))))
  (dolist (pc-tag *all-pc-tags*)
    (when ( (car pc-tag) here)
      (incf (car pc-tag) extra-half-words)))
  (loop for pc-tags on *pc-array-tags* doing
    (when ( (car pc-tags) here)
      (incf (car pc-tags) extra-half-words)))
  (loop for (flavor . insts) in *lexical-variable-instructions* doing
    (ignore flavor)
    (loop for insts on insts
	  doing
      (when ( (car insts) here)
	(incf (car insts) extra-half-words))))
  (loop for (flavor . insts) in *mapping-table-instructions* doing
    (ignore flavor)
    (loop for insts on insts
	  doing
      (when ( (car insts) here)
	(incf (car insts) extra-half-words))))
  (loop for (flavor . insts) in *instance-variable-instructions* doing
    (ignore flavor)
    (loop for insts on insts
	  doing
      (when ( (car insts) here)
	(incf (car insts) extra-half-words))))
  (loop for (fspec . insts) in *fdefinition-location-hints* doing
    (ignore fspec)
    (loop for insts on insts doing
      (when ( (car insts) here)
	(incf (car insts) extra-half-words))))
  (dolist (pair *variable-creation-alist*)
    (when ( (car pair) here)
      (incf (car pair) extra-half-words)))
  (loop for entry in *call-start-alist*
	when (and (numberp (car entry))
		  ( here (car entry)))
	  do (incf (car entry) extra-half-words)
	when (and (numberp (cdr entry))
		  ( here (cdr entry)))
	  do (incf (cdr entry) extra-half-words)))

(defun spread-code-for-branches ()
  (let* ((old-size (fill-pointer *instruction-array*))
	 ;; In this function, DELTA is in full-word units.
	 (delta
	   (+ (loop for branch in *all-branches* sum (branch-extra branch))
	      (if *hops* (ceiling (second *hops*) 2) 0)))
	 (new-size (+ old-size delta)))
    (when (plusp delta)
      (when (> new-size (array-length *instruction-array*))
	(setq *instruction-array* (adjust-array-size *instruction-array* new-size)))
      (setf (fill-pointer *instruction-array*) new-size)
      (when (> new-size (array-length (instruction-array-tags *instruction-array*)))
	(setf (instruction-array-tags *instruction-array*)
	      (adjust-array-size (instruction-array-tags *instruction-array*) new-size)))
      (setf (fill-pointer (instruction-array-tags *instruction-array*)) new-size)
      (when *use-source-locators*
	(let ((2new-size (* new-size 2)))
	  (when (> 2new-size (array-length *source-locator-array*))
	    (setq *source-locator-array*
		  (adjust-array-size *source-locator-array* 2new-size)))
	  (setf (fill-pointer *source-locator-array*) 2new-size)))
      (loop with end = old-size
	    with ta = (instruction-array-tags *instruction-array*)
	    for branch in (reverse *all-branches*)
	    for pre-address = (branch-pre-address branch)
	    for pre-word = (ash pre-address -1)
	    for extra = (branch-extra branch)
	    do
	(unless (zerop extra)
	  ;; This branch is long.  Copy the words including the branch instruction
	  ;; (some of the branch asemblers perform optimizations which assume this
	  ;; has been copied)
	  (loop for x from (1- end) downto pre-word
		as y = (+ x delta)
		do
	    (setf (aref *instruction-array* y)
		  (aref *instruction-array* x))
	    (setf (aref ta y) (aref ta x))
	    (when *use-source-locators*
	      (setf (aref *source-locator-array* (* 2 y))
		    (aref *source-locator-array* (* 2 x)))
	      (setf (aref *source-locator-array* (1+ (* 2 y)))
		    (aref *source-locator-array* (1+ (* 2 x))))))
	  (decf delta extra)
	  (setq end (1+ pre-word)))
	    finally
	      (when *hops*
		(loop for x from (1- end) downto (floor (first *hops*) 2)
		      as y = (+ x delta)
		      doing
		  (setf (aref *instruction-array* y)
			(aref *instruction-array* x))
		  (setf (aref ta y) (aref ta x))
		  (when *use-source-locators*
		    (setf (aref *source-locator-array* (* 2 y))
		    (aref *source-locator-array* (* 2 x)))
		    (setf (aref *source-locator-array* (1+ (* 2 y)))
			  (aref *source-locator-array* (1+ (* 2 x))))))))
      t)))

(defun insert-code-for-hops ()
  (when *hops*
    (let* ((hop-start (first *hops*))
	   (address hop-start)
	   (hops (sort (cddr *hops*)
		       #'(lambda (h1 h2)
			   (< (branch-pre-address h1)
			      (branch-pre-address h2))))))
      (flet ((make-odd-hop (hop address)
	       (let ((disp-address (branch-post-address hop)))
		 (set-opcode-and-operand
		   disp-address
		   *branch-opcode*
		   (- (+ address 1) disp-address)))
	       (set-opcode-and-operand
		 address
		 *%jump-opcode*
		 (operand-bits 'stack-pointer 0))
	       (let ((destination (tag-address (branch-tag hop))))
		 (set-tag-and-data
		   (+ address 1)
		   (make-i-tag cdr-code i:sys:sequencing-pc-1
			       type (if (evenp destination)
					i:sys:dtp-even-pc
					i:sys:dtp-odd-pc))
		   (lsh destination -1))))
	     (make-even-hop (hop address)
	       (let ((destination (tag-address (branch-tag hop))))
		 (let ((disp-address (branch-post-address hop)))
		   (set-opcode-and-operand
		     disp-address
		     *branch-opcode*
		     (- address disp-address)))
		 (set-tag-and-data
		   address
		   (make-i-tag cdr-code i:sys:sequencing-pc-even+2-odd+3
			       type (if (evenp destination)
					i:sys:dtp-even-pc
					i:sys:dtp-odd-pc))
		   (lsh destination -1))
		 (set-tag-and-data (+ address 2)
				   (make-i-tag cdr-code i:sys:sequencing-pc-even+2-odd+3
					       type i:sys:dtp-packed-instruction-60)
				   0)
		 (set-opcode-and-operand
		   (+ address 2)
		   *%jump-opcode*
		   (operand-bits 'stack-pointer 0)))))
	(set-tag-and-data address
			  (make-i-tag cdr-code i:sys:sequencing-pc-even+2-odd+3
				      type i:sys:dtp-packed-instruction-60)
			  0)
	(set-opcode-and-operand
	  address
	  *branch-opcode*
	  (- (tag-address *first-real-tag*) address))
	(incf address)
	(loop for hop in hops
	      for address from address by 3
	      doing
	  (if (oddp address)
	      (make-odd-hop hop address)
	      (make-even-hop hop address)))))))

;;; Fill in the actual instructions, noting that you may need to use
;;; long branches.
(defun fill-in-branches ()
  (dolist (branch *all-branches*)
    (let* ((type (branch-type branch))
	   (address (branch-post-address branch))
	   (tag-address (tag-address (branch-tag branch)))
	   (length (- tag-address address)))
      (funcall (get type 'branch-assemble)
	       branch
	       address
	       length
	       (branch-assembled-long branch)))))

(defun set-%jump-word (address)
  (set-tag-and-data
    address
    (make-i-tag cdr-code i:sys:sequencing-pc-even+2-odd+3
		type (dpb -1 (byte 2 4) (ldb (byte 4 4) *zerop-opcode*)))
    (%logdpb (ldb (byte 4 0) *zerop-opcode*) (byte 4 28.)
	     (dpb (operand-bits 'immediate 1) (byte 10. 18.)
		  (dpb *%jump-opcode* (byte 8. 10.)
		       (operand-bits 'stack-pointer 0))))))

(defun (jump branch-assemble) (branch address length long-p)
  branch ;ignored
  (cond ((not long-p)
	 (block try-optimization
	   (when (eq (branch-type branch) 'jump)
	     ;; Note:  If we assemble something which needs TOS fixed up, the address
	     ;; of the something is the address where TOS is already fixed up.  Thus,
	     ;; we do not have to check for the case:
	     ;;    MOVEM SP|0
	     ;;    Br X
	     ;;    ...
	     ;; X: MOVEM SP|0
	     ;;    Stuff
	     ;;
	     ;; because X will be Stuff.
	     (when (and (branch-tos-state branch)
			( (ldb %%q-type-within-tag (get-tag-and-data (+ address length)))
			   dtp-packed-instruction-60)
			(multiple-value-bind (opcode operand)
			    (get-opcode-and-operand (+ address length))
			  (and (= opcode *movem-opcode*)
			       (= operand (operand-bits 'stack-pointer 255.)))))
	       ;; TOS is valid before the jump, and the jump is to a FIXUP-TOS.
	       ;; Skip the fixup TOS.
	       (let* ((dest (+ address length))
		      (new-length
			(+ length 
			   (select (ldb %%q-cdr-code-within-tag (get-tag-and-data dest))
			     (sequencing-pc+1 1)
			     (sequencing-fence
			      (error "Compiler error: bad sequencing"))
			     (sequencing-pc-1 -1)
			     (sequencing-pc-even+2-odd+3
			      (+ 2 (ldb (byte 1 0) dest)))))))
		 (unless (branch-long-p 'jump new-length)
		   (return-from try-optimization
		     (set-opcode-and-operand address *branch-opcode* new-length)))))
	     (when (and (eq (branch-tos-state branch) 'fixed)
			(eq (tag-tos-status (branch-tag branch)) 'not-used))
	       ;; We fixed up TOS for the jump, but it turned out we didn't need to.
	       ;; Note:  The sequence
	       ;;
	       ;; E+2, O+3  Movem SP|0    |   ...
	       ;; -1        Full word instruction
	       ;;                         | Br X
	       ;;
	       ;; is not possible because the full word instruction would have left
	       ;; TOS valid.
	       ;;
	       ;; Thus, we know that the MOVEM SP|0 will appear in the PC 1 less than
	       ;; the Branch instruction.
	       (if (oddp address)
		   (unless (branch-long-p 'jump (1+ length))
		     (set-pc-sequencing (1- address) sequencing-pc-even+2-odd+3)
		     (return-from try-optimization
		       (set-opcode-and-operand (1- address) *branch-opcode* (1+ length))))
		   (set-pc-sequencing (1- address) sequencing-pc-even+2-odd+3))))
	   (set-opcode-and-operand address *branch-opcode* length)))
	((branch-must-be-single-instruction branch)
	 (ferror "You lose: I-machine can't do this."))
	(t
	 (let ((target-pc-word-address (ash (+ address length) -1)))
	   (cond ((oddp address)
		  (let ((tag (get-tag-and-data address))
			(type  (if (oddp length) i:sys:dtp-even-pc i:sys:dtp-odd-pc)))
		    (cond ((= (ldb i:sys:%%q-cdr-code-within-tag tag) i:sys:sequencing-pc+1)
			   (block do-it
			     (when ( address 5)
			       (multiple-value-bind (tag-5 data-5)
				   (get-tag-and-data (- address 5))
				 (when (and ( (ldb i:sys:%%q-type-within-tag tag-5)
					       i:sys:dtp-packed-instruction-60)
					    (= (ldb (byte 4. 14.) data-5) 3)	;Branch
					    (= (ldb i:sys:%%packed-instruction-10-bit-operand
						      data-5)
						 5))	;to us
				   ;; We are being branched to from a long conditional branch
				   ;; Change to a branch to the even half of us
				   (set-tag-and-data
				     (- address 5) tag-5
				     (%logdpb
				       4 i:sys:%%packed-instruction-10-bit-operand data-5))
				   ;; We become the PC
				   (set-tag-and-data
				     (- address 1)
				     (make-i-tag type type
						 cdr-code i:sys:sequencing-pc-even+2-odd+3)
				     target-pc-word-address)
				   ;; Follow by a jump/no-op
				   (set-opcode-and-operand
				     (+ address 1) *%jump-opcode*
				     (operand-bits 'stack-pointer 0))
				   (set-opcode-and-operand
				     (+ address 2) *zerop-opcode* (operand-bits 'immediate 1))
				   (set-pc-sequencing (1+ address)
						      i:sys:sequencing-pc-even+2-odd+3)
				   (return-from do-it nil))))
			     ;; Change to %JUMP
			     (set-opcode-and-operand address *%jump-opcode*
						     (operand-bits 'stack-pointer 0))
			     ;; Fix up pc sequencing.
			     (set-pc-sequencing address i:sys:sequencing-pc-even+2-odd+3)
			     (set-tag-and-data
			       (1+ address)
			       (make-i-tag type type cdr-code i:sys:sequencing-pc-1)
			       target-pc-word-address)))
				   
			  (t
			   ;; Otherwise it's more complicated.  Must be even+2-odd+3
			   ;; Copy the instruction back, changing the sequencing to
			   ;; skip over the branch.
			   (multiple-value-bind (tag data)
			       (get-tag-and-data (+ address 5))
			     (if (= (ldb i:sys:%%q-cdr-code-within-tag tag)
				    i:sys:sequencing-pc-1)
				 (set-tag-and-data (+ address 1)
						   (dpb i:sys:sequencing-pc-even+2-odd+3
							i:sys:%%q-cdr-code-within-tag
							tag)
						   data)
				 (ferror "Sequencing or compiler mighty confused.")))
			   ;; First replace the old branch with a NO-OP - no need to change
			   ;; sequencing.
			   (set-opcode-and-operand address *zerop-opcode*
						   (operand-bits 'immediate 1))
			   ;; Now add the target PC
			   (set-tag-and-data
			     (+ address 3)
			     (make-i-tag type type cdr-code i:sys:sequencing-pc-even+2-odd+3)
			     target-pc-word-address)
			   ;; Now add the %JUMP and a NO-OP - optimize by making the
			   ;; sequencing skip the NO-OP.
			   (set-%jump-word (+ address 5))))))
		 ;; The branch was in the even half-word
		 (t
		  (set-tag-and-data
		    address
		    (make-i-tag type (if (oddp length) i:sys:dtp-odd-pc i:sys:dtp-even-pc)
				cdr-code i:sys:sequencing-pc-even+2-odd+3)
		    target-pc-word-address)
		  ;; >>> Note that it is critical here that the sequencing of this word
		  ;;     be conserved.  On the other hand, all we're changing here is
		  ;;     the even half-word - SPREAD-CODE-FOR-BRANCHES should have handled
		  ;;     this. <<<
		  (set-opcode-and-operand (+ address 2) *%jump-opcode*
					  (operand-bits 'stack-pointer 0))))))))
	   
(defun reverse-branch-opcode (opcode)
  (multiple-value-bind (condition pops-if pops-if-not)
      (unparse-branch-opcode opcode)
    (branch-opcode
      (compiler:other condition)		;Other condition
      pops-if-not				;Reverse pops-if
      pops-if)))				;and pops-if-not

(defun (conditional-jump branch-assemble) (branch address length long-p)
  branch
  (let ((opcode (get-opcode-and-operand address)))
    (cond ((not long-p)
	   ;; Just change the operand
	   (set-opcode-and-operand address opcode length))
	  (t
	   (let* ((target (+ address length))
		  (target-pc-word-address (ash target -1))
		  (type (if (oddp target) i:sys:dtp-odd-pc i:sys:dtp-even-pc))
		  (reversed-branch-opcode (reverse-branch-opcode opcode))
		  (tag (get-tag-and-data address)))
	     (cond ((oddp address)
		    (let ((extra-offset 
			    (if (= (ldb i:sys:%%q-cdr-code-within-tag tag)
				   i:sys:sequencing-pc+1)
				0
				(progn
				  ;; Copy the constant word back from where it got
				  ;; moved to.
				  (sys:%multiple-value-call-n
				    set-tag-and-data
				    (+ address 1) 1
				    (get-tag-and-data (+ address 5)) 2)
				  2))))
		      ;; Change to reversed branch to the instruction we would have
		      ;; fallen through to - it will now be 5 or 7 half-words away.
		      (set-opcode-and-operand address reversed-branch-opcode
					      (+ 5 extra-offset))
		      ;; Now push the PC of the real branch's destination.
		      (set-tag-and-data
			(+ (1+ address) extra-offset)
			(make-i-tag type type
				    cdr-code i:sys:sequencing-pc-even+2-odd+3)
			target-pc-word-address)
		      ;; Add a %JUMP and a NO-OP (which should never be reached).
		      (set-%jump-word (+ address 3 extra-offset))))
		   ;; The branch was in the even half-word
		   (t
		    (let ((extra-offset
			    (if (= (ldb i:sys:%%q-cdr-code-within-tag tag)
				   i:sys:sequencing-pc+1)
				0
				1)))
		      ;; Change to reversed branch to the instruction we would have
		      ;; fallen through to - it will now be 5 or 6 half-words away.
		      (set-opcode-and-operand address reversed-branch-opcode
					      (+ 5 extra-offset))
		      ;; Add a %JUMP, but with skip sequencing.
		      (set-opcode-and-operand (1+ address) *%jump-opcode*
					      (operand-bits 'stack-pointer 0))
		      (set-pc-sequencing (1+ address)
					 i:sys:sequencing-pc-even+2-odd+3)
		      ;; Now push the PC of the real branch's destination.
		      (set-tag-and-data
			(+ address 2)
			(make-i-tag type type
				    cdr-code i:sys:sequencing-pc-1)
			target-pc-word-address)
		      ;; Now pad the even half-word of the next full-word - this
		      ;; word had better be a copy of the original word that the
		      ;; short branch was in.
		      ;; !!! Don't touch the cdr-code !!!
		      (set-opcode-and-operand (+ address 4) *zerop-opcode*
					      (operand-bits 'immediate 1))))))))))

;; LOOP-DECREMENT-TOS long-branch expansion
;;
;;  Before					After
;;  seq  Odd		Even			seq  Odd     	   Even
;;---------------------------------------------------------------------------
;;  +    LOOP-DEC-TOS	any1			+    DEC SP|0	   any1
;;						+    BR-FALSE	   PLUSP SP|0
;;						++   		   DTP-x-PC
;;						++   NO-OP	   %JUMP
;;---------------------------------------------------------------------------
;;  ++   LOOP-DEC-TOS	any1			++   DEC SP|0	   any1
;;  -    		any2			-		   any2
;;						+    BR-FALSE	   PLUSP SP|0
;;						++   		   DTP-x-PC
;;						++   NO-OP	   %JUMP
;;---------------------------------------------------------------------------
;;  +    any1		LOOP-DEC-TOS		+    PLUSP SP|0	   DEC SP|0
;;						++   %JUMP	   BR-FALSE
;;						-		   DTP-x-PC
;;						+    any1	   NO-OP
;;---------------------------------------------------------------------------
;;  ++   any1		LOOP-DEC-TOS		+    PLUSP SP|0	   DEC SP|0
;;  -			any2			++   %JUMP	   BR-FALSE
;;						-		   DTP-x-PC
;;						++   any1	   NO-OP
;;						-		   any2
;;---------------------------------------------------------------------------
;; Other cases we don't handle because I don't think they can happen, and they're hard.
;; (I challenge you to come up with code which tests case 2.  It can be done!)
;; DLA 4/16/87 17:29:42
;;
;; LOOP-INCREMENT-TOS-LESS-THAN long-branch expansion
;;
;; Suprise, it is the same as LOOP-DECREMENT-TOS.  The parallel expansions are:
;;
;;	LOOP-DECREMENT-TOS	LOOP-INCREMENT-TOS-LESS-THAN
;;	------------------	----------------------------
;;	DECREMENT SP|0		LESSP-NO-POP SP|-1
;;	PLUSP SP|0		INCREMENT SP|-1
;;	BRANCH-FALSE x		BRANCH-FALSE x
;;	DTP-x-PC		DTP-x-PC
;;	%JUMP			%JUMP
;;
;; Therefore the two branch-assembles share most of the code.

(defun (loop-decrement-tos branch-assemble) (branch address length long-p)
  (declare (ignore branch))
  (branch-assemble-loop address length long-p
			*decrement-opcode* (operand-bits 'stack-pointer 255)
			*plusp-opcode* (operand-bits 'stack-pointer 255)))

(defun (loop-increment-tos-less-than branch-assemble) (branch address length long-p)
  (declare (ignore branch))
  (branch-assemble-loop address length long-p
			*lessp-no-pop-opcode* (operand-bits 'stack-pointer 254)
			*increment-opcode* (operand-bits 'stack-pointer 254)))

(defun branch-assemble-loop (address length long-p
			     first-inst first-operand
			     second-inst second-operand)
  (macrolet ((tos () '(operand-bits 'stack-pointer 255))
	     (tos-pop () '(operand-bits 'stack-pointer 0))
	     (goof () '(error "Can't handle this case.")))
    (let ((opcode (get-opcode-and-operand address)))
      (if (not long-p)
	  ;; Just change the operand
	  (set-opcode-and-operand address opcode length)
	  (let* ((target (+ address length))
		 (target-pc-word-address (ash target -1))
		 (type (if (oddp target) i:sys:dtp-odd-pc i:sys:dtp-even-pc))
		 (tag (get-tag-and-data address))
		 (sequencing (ldb i:sys:%%q-cdr-code-within-tag tag)))
	    (if (oddp address)
		(cond ((= sequencing i:sys:sequencing-pc+1)
		       (set-opcode-and-operand address first-inst first-operand)
		       (set-pc-instructions
			 (+ address 1)
			 i:sys:sequencing-pc+1
			 second-inst second-operand
			 *branch-false-opcode* 5)
		       (set-tag-and-data (+ address 3)
					 (%logdpb i:sys:sequencing-pc-even+2-odd+3
						  i:sys:%%q-cdr-code-within-tag
						  type)
					 target-pc-word-address)
		       (set-%jump-word (+ address 5)))
		      ((= sequencing i:sys:sequencing-pc-even+2-odd+3)
		       (unless (= (ldb i:sys:%%q-cdr-code-within-tag
				       (get-tag-and-data (+ address 1)))
				  i:sys:sequencing-pc-1)
			 (goof))
		       (set-opcode-and-operand address first-inst first-operand)
		       (set-pc-instructions
			 (+ address 3) i:sys:sequencing-pc+1
			 second-inst second-operand
			 *branch-false-opcode* 5)
		       (set-tag-and-data (+ address 5)
					 (%logdpb i:sys:sequencing-pc-even+2-odd+3
						  i:sys:%%q-cdr-code-within-tag
						  type)
					 target-pc-word-address)
		       (set-%jump-word (+ address 7)))
		      (t (goof)))
		(cond ((= sequencing i:sys:sequencing-pc+1)
		       (multiple-value-bind (opcode operand)
			   (get-opcode-and-operand (+ address 1))
			 (set-pc-instructions
			   (+ address 6)
			   sequencing-pc-even+2-odd+3
			   opcode operand
			   *no-op-opcode* (tos)))
		       (set-opcode-and-operand address first-inst first-operand)
		       (set-opcode-and-operand (+ address 1) second-inst second-operand)
		       (set-pc-instructions
			 (+ address 2)
			 i:sys:sequencing-pc-even+2-odd+3
			 *branch-false-opcode* 4
			 *%jump-opcode* (tos-pop))
		       (set-tag-and-data (+ address 4)
					 (%logdpb i:sys:sequencing-pc-1
						  i:sys:%%q-cdr-code-within-tag
						  type)
					 target-pc-word-address))
		      ((= sequencing i:sys:sequencing-pc-even+2-odd+3)
		       (unless (= (ldb i:sys:%%q-cdr-code-within-tag
				       (get-tag-and-data (+ address 8)))
				  i:sys:sequencing-pc-1)
			 (goof))
		       (multiple-value-bind (opcode operand)
			   (get-opcode-and-operand (+ address 1))
			 (multiple-value-bind (tag data)
			     (get-tag-and-data (+ address 8))
			   (set-opcode-and-operand address first-inst first-operand)
			   (set-opcode-and-operand (+ address 1) second-inst second-operand)
			   (set-pc-sequencing address i:sys:sequencing-pc+1)
			   (set-pc-instructions
			     (+ address 2) i:sys:sequencing-pc-even+2-odd+3
			     *branch-false-opcode* 6
			     *%jump-opcode* (tos-pop))
			   (set-tag-and-data (+ address 4)
					     (%logdpb i:sys:sequencing-pc-1
						      i:sys:%%q-cdr-code-within-tag
						      type)
					     target-pc-word-address)
			   (set-pc-instructions
			     (+ address 6) i:sys:sequencing-pc-even+2-odd+3
			     *no-op-opcode* (tos)
			     opcode operand)
			   (set-tag-and-data (+ address 8)
					     (%logdpb i:sys:sequencing-pc-1
						      i:sys:%%q-cdr-code-within-tag
						      tag)
					     data))))
		      (t (goof)))))))))

(defun (error branch-assemble) (branch address length long-p)
  branch length long-p address ;ignore
  (ferror "Not supported yet")
  )

#| Test suite for LOOP long branches.  This tests all cases handled by
   the above branch-assemblers, for each loop instruction.  To see if you
   code passed the test, you have to look at the disassembled code and see
   if it's right.  Sorry, I don't feel like automating that!  --DLA

   Note-- This only tests LOOP-DECREMENT-TOS properly.  The LOOP-INCREMENT-TOS-LESS-THAN
   suite still needs to be generated.
 |

(DEFMACRO GENERATE-INSTRUCTIONS (N)
  `(PROGN . ,(LOOP REPEAT N COLLECT '(COMPILER:NO-OP))))

(DEFUN TEST-LONG-BRANCHES-1 (X)
  (DO ((COUNT X (1- COUNT)))
      (( COUNT 0))
    (GENERATE-INSTRUCTIONS 513)))

(DEFUN TEST-LONG-BRANCHES-2 (X)
  (GENERATE-INSTRUCTIONS 1)
  (DO ((COUNT X (1- COUNT)))
      (( COUNT 0))
    (GENERATE-INSTRUCTIONS 513)))

(DEFUN TEST-LONG-BRANCHES-3 (X)
  (DECLARE (SPECIAL *FROB*))
  (DO ((COUNT X (1- COUNT)))
      (( COUNT 0) *FROB*)
    (GENERATE-INSTRUCTIONS 513)))

(DEFUN TEST-LONG-BRANCHES-4 (X)
  (DECLARE (SPECIAL *FROB*))
  (GENERATE-INSTRUCTIONS 1)
  (DO ((COUNT X (1- COUNT)))
      (( COUNT 0) *FROB*)
    (GENERATE-INSTRUCTIONS 513)))

(DEFUN TEST-LONG-BRANCHES-5 ()
  (DECLARE (SPECIAL *FROB*))
  (GENERATE-INSTRUCTIONS 1)
  (LET ((N *FROB*))
    (DECF N)
    (IF (NOT (PLUSP N))
	(PROGN (GENERATE-INSTRUCTIONS 512) 4)
	5)))
||#

;; Accumulate error information
(defun get-error-jump-information ()
  (loop for ej in *all-error-jumps*
	for info = (jump-error-info ej)
	for br = (error-branch info)
	collect (list* (branch-post-address br)
		       (error-function info)
		       (error-variable info)
		       (tag-address (jump-tag ej))
		       (error-info info)) into list
	finally (return (cons ':error-alist list))))

;;; Insert an unconditional branch to tag at location.  If location is not provided,
;;; push the branch onto the end of the instruction array.
(defun insert-branch (tag &optional location (instruction-array *instruction-array*)
				    must-be-single-instruction)
  "LOCATION is a half-word address."
  (if location
      (set-opcode-and-operand location *branch-opcode* 0 instruction-array)
      (let ((*instruction-array* instruction-array))	;assumed by ASSEMBLE-1
	(setq location (assemble-1 *branch-opcode* (i-op signed 0)))))
  (note-branch 'jump location tag instruction-array must-be-single-instruction))

;;;; Dispatch tables.

;;; Assemble a dispatch table.  Interval-list is a list of intervals that are
;;; the alternatives.  There are entry-size instructions for each entry; if the
;;; interval can be compiled into that much space, it fits, otherwise a branch
;;; must be generated.  fall-through-p is whether each entry should fall through
;;; to the next (true for take-arguments, false for selectq).  The intervals
;;; in the list do not include the code to jump to wherever control is supposed
;;; to go after the entry is done.  If fall-through-p is NIL, entry-size should
;;; be at least 2, since you have to do something and then branch.  The length
;;; of interval-list is the size of the dispatch table.
(defun note-dispatch (fall-through-p entry-size interval-list)
  (push (make-dispatch :dispatch-instruction-array *instruction-array*
		       :dispatch-location (fill-pointer *instruction-array*)	;Full-words
		       :dispatch-fall-through-p fall-through-p
		       :dispatch-entry-size entry-size
		       :dispatch-interval-list interval-list
		       :dispatch-source-locator-array *source-locator-array*)
	*all-dispatches*)
  (let ((dispatch-table-size (* entry-size (length interval-list))))	;in full-words
    (assemble-no-ops (* 2 dispatch-table-size))
    (let ((new-length (* 2 (fill-pointer *instruction-array*))))
      (when *use-source-locators*
	(when (> new-length (array-length *source-locator-array*))
	  (setq *source-locator-array* (adjust-array-size *source-locator-array* new-length)))
	(setf (fill-pointer *source-locator-array*) new-length)))))

(defun assemble-skip (&optional (ia *instruction-array*))
  (when (and (instruction-array-oddp ia)
	     (not (instruction-array-fullp ia)))
    (setf (instruction-array-oddp ia) nil)))

;;; Some dispatches may be queued up on *all-dispatches*.  Keep assembling these until
;;; there aren't any, keeping in mind that assembling one may create more, as dispatches
;;; are nested inside the clauses of dispatches.
(defun assemble-all-dispatches ()
  (let ((*dispatch-interval-p* 't))
    (loop until (null *all-dispatches*)
	  do (assemble-dispatch (pop *all-dispatches*)))))

;;; Merge the given child instruction-array into its parent.  If parent-from
;;; is given, copy it in at that address; otherwise, push it onto the end.
;;; Returns the first location after the copied code, in the parent.
(defun merge-instruction-array
       (child-inst child-src call-start-alist instance-variable-instructions
	mapping-table-instructions lexical-variable-instructions fdefinition-location-hints
	pc-tags &optional parent-from)
  (let* ((parent (instruction-array-parent child-inst))
	 (parent-tag (instruction-array-tags parent))
	 (child-tag (instruction-array-tags child-inst))
	 (child-length (fill-pointer child-inst))
	 parent-to)
    (cond ((null parent-from)
	   (setq parent-from (fill-pointer parent))
	   (setq parent-to (+ parent-from child-length))
	   (setf (fill-pointer parent) parent-to)
	   (setf (fill-pointer parent-tag) parent-to)
	   ;; Have to set ODDP and FULLP of the parent to that of the kid
	   (setf (instruction-array-oddp parent)
		 (instruction-array-oddp child-inst))
	   (setf (instruction-array-fullp parent)
		 (instruction-array-fullp child-inst)))
	  (t
	   ;; Set the sequencing to skip over the NO-OP at the end i appropriate.
	   (when (and (instruction-array-oddp child-inst)
		      (not (instruction-array-fullp child-inst)))
	     (setf (ldb i:sys:%%q-cdr-code-within-tag (aref child-tag (1- child-length)))
		   i:sys:sequencing-pc-even+2-odd+3)
	     (setf (instruction-array-oddp child-inst) nil))
	   (setq parent-to (+ parent-from child-length))))
    (setf (instruction-array-offset child-inst) (* 2 parent-from))
    (unless ( parent-to (array-length parent))
      (adjust-array-size parent parent-to)
      (adjust-array-size parent-tag parent-to))
    (copy-array-portion child-inst 0 child-length parent parent-from parent-to)
    (copy-array-portion child-tag 0 child-length parent-tag parent-from parent-to)
    (when *use-source-locators*
      (let ((parent-from (* parent-from 2))
	    (parent-to (* parent-to 2))
	    (child-length (* child-length 2))
	    (parent-src (source-locator-array-parent child-src)))
	(unless ( parent-to (array-length parent-src))
	  (adjust-array-size parent-src parent-to))
	(copy-array-portion child-src 0 child-length parent-src parent-from parent-to)
	(setf (fill-pointer parent-src) (* 2 (fill-pointer parent))))
      (setf (source-locator-array-offset child-src) (instruction-array-offset child-inst)))
    (let ((offset (* 2 parent-from)))
      (loop for (start . end) in call-start-alist doing
	(when (and (numberp start) (numberp end))
	  (push (cons (+ start offset) (+ end offset)) *call-start-alist*)))
      (loop for pair in pc-tags doing (incf (car pair) offset))
      (setq *all-pc-tags* (nconc pc-tags *all-pc-tags*))
      (flet ((fixup-list (location new-elements)
	       (loop for (name . insts) in new-elements
		     for pair = (let ((pair (assq name (location-contents location))))
				  (or pair
				      (let ((pair (ncons name)))
					(push pair (location-contents location))
					pair)))
		     doing
		 (loop for inst in insts doing (push (+ inst offset) (cdr pair))))))
	(fixup-list (locf *instance-variable-instructions*) instance-variable-instructions)
	(fixup-list (locf *mapping-table-instructions*) mapping-table-instructions)
	(fixup-list (locf *lexical-variable-instructions*) lexical-variable-instructions)
	(fixup-list (locf *fdefinition-location-hints*) fdefinition-location-hints)))
    parent-to))

;;; Assemble one dispatch onto the end of the current *instruction-array*.
(defun assemble-dispatch (dispatch)
  (unless (dispatch-fall-through-p dispatch)
    (error "Only FALL-THROUGH dispatches are known to work"))
  (let* ((fall-through-p (dispatch-fall-through-p dispatch))
	 (entry-size (dispatch-entry-size dispatch))
	 (instruction-array (dispatch-instruction-array dispatch))
	 (source-locator-array (dispatch-source-locator-array dispatch))
	 (join-tag (if (not fall-through-p) (make-tag)))
	 (tos-tag (make-tag))
	 (fixup-tos-instruction (half-word-instruction-bits *movem-opcode* (sp-operand 0))))
    (loop with hw-entry-size = (* 2 entry-size)
	  for fw-location from (dispatch-location dispatch) by entry-size
	  for interval in (dispatch-interval-list dispatch)
	  ;; Remember that both DISPATCH-LOCATION and ENTRY-SIZE are in full-words
	  for location = (* 2 fw-location)
	  do
      (multiple-value-bind (ia sa csa ivi mti lvi flh tos-status smashed-p pc-tags)
	  (multiple-value-bind (*instruction-array* *source-locator-array*)
	      (allocate-instruction-arrays instruction-array source-locator-array)
	    (let ((*call-start-alist* nil)
		  (*instance-variable-instructions* nil)
		  (*mapping-table-instructions* nil)
		  (*lexical-variable-instructions* nil)
		  (*fdefinition-location-hints* nil)
		  (*tos-tags* (list tos-tag))
		  (*all-pc-tags* nil))
	      (setq *stack-smashed* nil)
	      (setf (tag-tos-status tos-tag) nil)
	      (assemble-interval interval *function*)
	      (values *instruction-array* *source-locator-array* *call-start-alist*
		      *instance-variable-instructions* *mapping-table-instructions*
		      *lexical-variable-instructions* *fdefinition-location-hints*
		      (tag-tos-status tos-tag) *stack-smashed* *all-pc-tags*)))
	(declare (ignore smashed-p))
	(let ((ia-size (fill-pointer ia)))
	  (cond (fall-through-p
		 ;; The entries just drop through; no branch needed after entry.
		 (cond ((and ( ia-size entry-size)
			     (neq tos-status 'used))
			;; It fits.  Just copy it in.  Unused space will have already
			;; been initialized.
			(merge-instruction-array ia sa csa ivi mti lvi flh pc-tags fw-location))
		       ((and ( ia-size entry-size)
			     (eq tos-status 'used)
			     (instruction-array-oddp ia))
			;; It fits, but we need to fixup TOS.  We assume that
			;; entry-size is 1.
			(let ((pc+1 (1+ location)))
			  (multiple-value-bind (tag data) (get-tag-and-data 0 ia)
			    (declare (ignore tag))
			    (set-tag-and-data
			      location
			      (dpbs sequencing-pc+1 %%q-cdr-code-within-tag
				    (ldb %%odd-instruction-tag-component data)
				    %%q-odd-instruction-within-tag
				    dtp-packed-instruction-60)
			      (%logdpb (ldb %%odd-instruction-data-component data)
				       %%q-odd-instruction-within-pointer
				       fixup-tos-instruction)))
			  (when *source-locator-array*
			    (setf (aref *source-locator-array* pc+1)
				  (aref sa 0)))
			  (flet ((fixup-list (location new-elements)
				   (loop for (name . insts) in new-elements
					 for pair = (let ((pair
							    (assq
							      name
							      (location-contents location))))
						      (or pair
							  (let ((pair (ncons name)))
							    (push pair
								  (location-contents location))
							    pair)))
					 doing
				     (loop for inst in insts doing
				       (push (+ inst pc+1) (cdr pair))))))
			    (fixup-list (locf *instance-variable-instructions*) ivi)
			    (fixup-list (locf *mapping-table-instructions*) mti)
			    (fixup-list (locf *lexical-variable-instructions*) lvi)
			    (fixup-list (locf *fdefinition-location-hints*) flh))))
		       (t
			;; It doesn't fit; jump out to it and jump back to the next entry.
			(let ((out-tag (make-tag))
			      (back-tag (make-tag)))
			  (loop for tag in *all-tags* until (tag-address tag) doing
			    (setf (tag-address tag) (+ location hw-entry-size))
			    (setf (tag-instruction-array tag) *instruction-array*))
			  (note-tag out-tag (* 2 (fill-pointer *instruction-array*)))
			  (note-tag back-tag (+ location hw-entry-size))
			  (merge-instruction-array ia sa csa ivi mti lvi flh pc-tags)
			  (insert-branch back-tag)
			  (cond ((eq tos-status 'used)
				 (set-tag-and-data
				   location
				   (dpbs sequencing-pc+1 %%q-cdr-code-within-tag
					 (ldb %%odd-instruction-tag-component
					      fixup-tos-instruction)
					 %%q-odd-instruction-within-tag
					 dtp-packed-instruction-60)
				   (%logdpb (ldb %%odd-instruction-data-component
						 fixup-tos-instruction)
					    %%q-odd-instruction-within-pointer
					    fixup-tos-instruction))
				 (insert-branch out-tag (1+ location) *instruction-array* t))
				(t (insert-branch out-tag location *instruction-array* t)))
			  ;;It would be possible to not use must-be-single-instruction
			  ;;if entry-size were at least two and the branch-assemble
			  ;;code knew it was ok to get rid of a noop.
			  ))))
		(t
		 ;; The code for the entries join again at the end; a branch is needed.
		 (cond ((< ia-size entry-size)
			;; It fits.  Just copy it in and put in branch.
			(insert-branch
			  join-tag
			  (merge-instruction-array ia sa csa ivi mti lvi flh pc-tags location)))
		       (t
			;; It doesn't fit.  Jump out to it.
			(let ((out-tag (make-tag)))
			  (note-tag out-tag (fill-pointer *instruction-array*))
			  (merge-instruction-array ia sa csa ivi mti lvi flh pc-tags)
			  (insert-branch join-tag)
			  (insert-branch out-tag location *instruction-array* t)))))))))
    (setq *stack-smashed* t)))

;;; Assemble n no-ops at the given location.  This is to fill up dispatch table
;;; entries.  Perhaps it is faster to do a branch than to execute no-ops; if so,
;;; modify this.  Otherwise, we might just want to fill dispatch tables with no-ops
;;; for the benefit of the disassembler, in note-dispatch.
(defun assemble-no-ops (n)
  "Pushes N half-word NO-OP instructions on *INSTRUCTION-ARRAY*."
  (let* ((instruction-array *instruction-array*)
	 (tags (instruction-array-tags instruction-array)))
    (cond ((= n 1)
	   ;; In this case, we are filling out an instruction.  Set the sequencing to
	   ;; skip over us
	   (assemble-1 *movem-opcode* (sp-operand 0))
	   (setf (ldb i:sys:%%q-cdr-code-within-tag
		      (aref tags (- (instruction-array-fill-pointer instruction-array) 1)))
		 i:sys:sequencing-pc-even+2-odd+3))
	  (t
	   ;; We're filling out n/2 pairs of words, so put no-ops in and fill it out.
	   (loop repeat (// n 2) doing
	     (assemble-1 *movem-opcode* (sp-operand 0))
	     (assemble-1 *movem-opcode* (sp-operand 0))
	     (setf (ldb i:sys:%%q-cdr-code-within-tag
			(aref tags (- (instruction-array-fill-pointer instruction-array) 1)))
		   i:sys:sequencing-pc-even+2-odd+3))))))


(defun call-starter-p (type)
  "Returns sublist whose CAR is TYPE, and whose CADR is the prefetch variant for TYPE."
  (memq type *call-starters*))

;(defun fixup-pc-tags ()
;  (loop for (index . pc-tag) in *all-pc-tags*
;	do
;    (multiple-value-bind (tag ignore)
;	(get-tag-and-data index)
;      (let ((type (ldb i:sys:%%q-type-within-tag tag)))
;	(when (= type i:sys:dtp-even-pc)
;	  (let* ((pc-tag-index (typecase pc-tag
;				 ((internal-tag pc-tag go-tag)
;				  (or (tag-address pc-tag)
;				      (ferror "Bad DTP-PC tag")))
;				 (otherwise (ferror "Bad entry in *ALL-PC-TAGS*"))))
;		 (pc-tag-tag (dpb (if (oddp pc-tag-index) i:sys:dtp-odd-pc i:sys:dtp-even-pc)
;				  i:sys:%%q-type-within-tag tag))
;		 (pc-tag-data (lsh pc-tag-index -1)))
;	    (select type
;	      (i:sys:dtp-even-pc
;	       (set-tag-and-data
;		 index
;		 ;; Don't change CDR-CODE
;		 pc-tag-tag
;		 pc-tag-data)))))))))

(defun fixup-pc-arrays ()
  (loop for index in *pc-array-tags* doing
    (multiple-value-bind (tag tags) (get-tag-and-data index)
      ;; Push each tag onto the end of the instructions and data and then make the
      ;; last word had cdr-nil
      (let ((pointer (instruction-array-current-offset)))
	(set-tag-and-data
	  index
	  (dpb i:sys:dtp-list i:sys:%%q-type-within-tag tag)
	  pointer))
      (loop for pc-tags on tags
	    for pc-tag = (car pc-tags)
	    doing
	(let* ((pc-tag-index (typecase pc-tag
			       (go-tag
				 (or (tag-address pc-tag)
				     (ferror "Bad DTP-PC tag")))
			       (otherwise (ferror "Bad entry in *PC-ARRAY-TAGS*"))))
	       (pc-tag-tag (dpb (if (cdr pc-tags) i:sys:cdr-next i:sys:cdr-nil)
				i:sys:%%q-cdr-code-within-tag
				(if (oddp pc-tag-index) i:sys:dtp-odd-pc i:sys:dtp-even-pc)))
	       (pc-tag-data (lsh pc-tag-index -1)))
	  (push-tag-and-data pc-tag-tag pc-tag-data))))))

(defsubst packed-instruction? (index &optional (ia *instruction-array*))
  "INDEX is a half-word index."
    (= (dpb 0 (byte 4 0)
	    (ldb i:sys:%%q-type-within-tag
		 (aref (instruction-array-tags ia) (lsh index -1))))
       i:sys:dtp-packed-instruction-60))

(defun fixup-calls ()
  (labels ((finish-call-p (opcode)
	     (or (= opcode *finish-call-n-opcode*)
		 (= opcode *finish-call-n-apply-opcode*)
		 (= opcode *finish-call-tos-opcode*)
		 (= opcode *finish-call-tos-apply-opcode*)))
	   (process-partner (index partner-index)
	     ;; See if we can optimize the call starter
	     ;; instruction.  If there are no nested calls, and
	     ;; there are fewer than a half-dozen instructions
	     ;; between the call starter and the call finisher,
	     ;; then we should use the prefetch version.
	     ;;  >>> Note that at the moment we're counting the number of
	     ;;      half-words rather than the number of instructions.
	     ;;      We might want to change this. <<<
	     (multiple-value-bind (tag data)
		 (get-tag-and-data index)
	       (let ((type (ldb i:sys:%%q-type-within-tag tag)))
		 ;; DTP-CALL-GENERIC-PREFETCH is generated unconditionally for the benefit
		 ;; of the linker.
		 (unless (= type i:sys:dtp-call-generic-prefetch)
		   (let (call-starter)
		     (when (and (setq call-starter (call-starter-p type))
				(finish-call-p (get-opcode-and-operand partner-index))
				;; 6 is arbitrary
				(let ((distance (- index partner-index)))
				  (and (> 6 (abs distance))
				       ;; >>> This is the wrong algorithm - what we really
				       ;; need here is a code walker, since we're interested
				       ;; in the RUN-TIME sequence of events.  This kludge
				       ;; is benign, though, and does handle at least the
				       ;; packed sequencing case. <<<
				       (loop for i from (min index partner-index)
						   below (max index partner-index)
					     never (and (packed-instruction? i)
							(finish-call-p
							  (get-opcode-and-operand i)))))))
		       ;; >>> This should use some more tasteful association mechanism. <<<
		       (set-tag-and-data
			 index
			 (dpb (cadr call-starter) i:sys:%%q-type-within-tag tag) data))))))))
    (loop for (start . finish) in *call-start-alist*
	  doing
      ;; If a call was started, but exited (as in "(foo (return-from bar))") then
      ;; there will be no finish call because the finish-call is in dead code and
      ;; will have been chopped by PHASE-2.  The compiler is too brain-dead to get
      ;; rid of the start-call and change the intervening code to being
      ;; called-for-effect, so we have to watch out for these orphaned start-calls
      ;; here in the back end.
      (when (and (numberp start) (numberp finish))
	(process-partner start finish)))))

(defun build-i-compiled-code
       (name inst-array src-array n-instructions debug-alist)
  (declare (ignore src-array))
  (let* ((length (cl:length inst-array))
	 (tags (instruction-array-tags inst-array))
	 (data inst-array)
	 (validate-p t)
	 (normal-cons-area
	   (let ((temp (second (cl:assoc 'compiler:area debug-alist))))
	     (if temp (symeval temp) compiled-function-area)))
	 (storage-category-debugging-info (cl:assoc 'si:storage-category debug-alist))
	 (function-storage-category
	   (and *phase-4-to-core*
		(si:decode-storage-category-debugging-info-entry
		  storage-category-debugging-info))))
    (declare (sys:array-register tags data))
    (when (null function-storage-category)
      (setq function-storage-category :unsafeguarded
	    validate-p nil))
    (when (eq function-storage-category :wired)
      (wired-compile-to-core-query name))
    (let ((area (cond ((not *phase-4-to-core*)                       default-cons-area)
		      ((eq function-storage-category :unsafeguarded) normal-cons-area)
		      ((eq function-storage-category :wired)         wired-control-tables)
		      ((eq function-storage-category :safeguarded)   safeguarded-objects-area)
		      (t (error "Unknown storage category ~S" function-storage-category))))
	  (function-references))
      (multiple-value-bind (cca function)
	  (make-compiled-code (+ length (sys:defstorage-size compiled-function))
			      (- length n-instructions)
			      area) 
	(sys:with-block-registers (2)
	  (setf (%block-register 2) function)
	  (loop for i from 0 below length
		for tag = (aref tags i)
		for type = (ldb %%q-type-within-tag tag)
		for ptr = (aref data i)
		doing
	    (cond ((typep ptr 'compiler:function-definition)
		   (push (list ptr i tag) function-references)
		   (si:prepare-for-block-write)
		   (%block-write 2 0))
		  ((or (= type dtp-odd-pc)
		       (= type dtp-even-pc)
		       (= type dtp-call-compiled-even)
		       (= type dtp-call-compiled-odd)
		       (= type dtp-call-compiled-odd-prefetch)
		       (= type dtp-call-compiled-even-prefetch))
		   (si:prepare-for-block-write)
		   (if (typep ptr :fixnum)
		     (%block-write 2 (%set-tag (%pointer-plus function ptr) tag))
		     (%block-write 2 (%set-tag 0 (dpb dtp-fixnum %%q-type-within-tag tag)))))
		  (t (si:prepare-for-block-write)
		     (%block-write 2 (%set-tag ptr tag))))))
	(multiple-value (nil nil function)
	  (si:copy-compiled-function-constants
	    function area (or *phase-4-to-core* :embed-only)))
	(setq cca (compiled-function-cca function))
	(loop for (ptr i tag) in function-references doing
	  (push (list (%make-pointer-offset dtp-locative function i) tag)
		(function-references ptr)))
	(when validate-p
	  (with-stack-list (extra-info name storage-category-debugging-info)
	    (si:validate-function-storage-category-declarations function extra-info)))
	#+Ivory-Rev-1
	(si:fixup-function-entry-instructions function)
	cca))))

;; It can't skip definition, because definition occurs way later, and also this
;; might be an internal function.
(defun wired-compile-to-core-query (name)
  (unless *allow-wired-compile-to-core*
    (let ((stream (if (and (variable-boundp zwei:*typein-window*)
			   (eq (si:follow-syn-stream query-io) zwei:*typein-window*)
			   (variable-boundp zwei:*typeout-window*))
		      zwei:*typeout-window*
		      query-io)))
      (selectq (accept
		'((alist-member :alist
		    (("Yes" :value :yes
		      :documentation "Go ahead and define this wired function.")
		     ("No" :value :no
		      :documentation "Abort this compilation.")
		     ("Proceed" :value :proceed
		      :documentation "Define this wired function, and do not query again until the next compilation.")
		     ("Proceed forever" :value :proceed-forever
		      :documentation "Define this wired function, and never query again."))))
		:display-default nil :prompt-mode :raw
		:stream stream
		:prompt #'(lambda (stream ignore)
			    (format stream
			      "Warning:  You are compiling the wired function ~S to core.~@
			       You have only ~D words of wired space remaining.  Continue?  "
			      name (- %wired-virtual-address-high
				      (+ (region-origin 1) (region-free-pointer 1))))))
	(:yes nil)
	(:no (signal 'sys:abort))
	(:proceed (setq *allow-wired-compile-to-core* t))
	(:proceed-forever (setq-globally *allow-wired-compile-to-core* t)
			  (setq *allow-wired-compile-to-core* t)))
      nil)))

(future-common-lisp:proclaim '(future-common-lisp:declaration sys:translated-function))

(defprop sys:translated-function t si:debug-info)

;;; Some top-level stuff
(defun assemble-function (function)
  (let* ((*all-instruction-arrays* nil)
	 (*all-source-locator-arrays* nil)
	 (*stack-smashed* nil)
	 (*needs-lp* nil)
	 (*tos-tags* nil)
	 (*instance-variable-instructions* nil)
	 (*mapping-table-instructions* nil)
	 (*lexical-variable-instructions* nil)
	 (*fdefinition-location-hints* nil)
	 (*all-branches* nil)
	 (*all-tags* nil)
	 (*all-dispatches* nil)
	 (*all-error-jumps* nil)
	 (*all-pc-tags* nil)
	 (*pc-array-tags* nil)
	 (*call-start-alist* nil)
	 (*frame-function* function)
	 (*variable-creation-alist* nil)
	 (*first-real-tag*)
	 (*hops*)
	 (*stack-shuffling* nil)
	 (*forward-references-exist* nil)
	 (*last-entry-instruction*)
	 (*writable-constants* nil)
	 (*unsharable-constants* nil))
    (multiple-value-bind (*instruction-array* *source-locator-array*)
	(allocate-instruction-arrays nil nil)
      (unwind-protect
	  (progn
	    (let ((*function* function)
		  (default-warning-function (function-pr function)))
	      (let ((error-message-hook
		      (let-closed ((function default-warning-function))
			#'(lambda ()
			    (format t "Error occurred while compiling ~:[at top level~;~S~]"
				    function function)))))
		(assemble-interval (function-interval *function*) *function*)
		(assemble-all-dispatches)
		(dolist (*function* (function-frame-sharers function))
		  (note-tag (function-quick-tag *function*))
		  (assemble-interval (function-interval *function*) *function*))
	  (fixup-branches)
	  ;(fixup-pc-tags)
	  (fixup-calls)
	  (let* ((n-instructions (instruction-array-current-offset))
		 (debug-alist `(,@(and *writable-constants*
				       `((si:writable-constants ,@*writable-constants*)))
				,@(and *unsharable-constants*
				       `((si:unsharable-constants ,@*unsharable-constants*)))
				,@(function-user-declares function)))
		 (extra-info (cons nil debug-alist)))
	    ;; Construct the suffix.
	    ;; First, the debugging info
	    (push-tag-and-data (dpb i:sys:sequencing-fence i:sys:%%q-cdr-code-within-tag
				    (dpb i:sys:dtp-list i:sys:%%q-type-within-tag 0))
			       extra-info)
	    ;; Then any PC "arrays".
	    (fixup-pc-arrays)
	    ;; Now that the function is totally built, make the compiled-code object
	    ;; Now build the actual compiled-function-object
	    (let* ((source-locations
		     ;; build the source-location list
		     (when *use-source-locators*
		       (build-source-location-information
			 *instruction-array* *source-locator-array*)))
		   (compiled-function-object
		     (build-i-compiled-code (function-pr function)
					    *instruction-array*
					    *source-locator-array*
					    n-instructions
					    debug-alist)))
	      (setf (compiler:function-pc-references function) *all-pc-tags*)
	      ;; Issue storage category warnings
	      (let ((constants-array
		      (construct-constants-array *instruction-array* n-instructions)))
		(when constants-array
		  (si:issue-storage-category-warnings
		    (function-pr *function*) constants-array debug-alist)
		  (return-array (prog1 constants-array (setq constants-array nil)))))
	      (when source-locations
		(push `(compiler:source-locators . ,source-locations)
		      (cdr extra-info)))
	      ;; If we've got an internal function here, save it off for fixup later
	      (when (eq (function-type function) 'internal)
		(push function *internal-functions*)
		(when (function-free-lexical-variables function)
		  (loop for free-var in (function-free-lexical-variables function)
			as location = (or (and (lexical-captive-p free-var)
					       (lexical-captive-location free-var))
					  (lexical-location free-var))
			as generation = (generation-of-variable free-var function)
			when (not (and location generation))
			  do (ferror "Internal compiler error - no valid location for variable")
			collect `(,(variable-name free-var)
				  ,(let ((descriptor 0))
				     (setf (lexical-map-variable-generation descriptor)
					   generation)
				     (setf (lexical-map-variable-location descriptor)
					   location)
				     descriptor))
			  into lexical-map
			finally (push `(:lexical-map ,@lexical-map) (cdr extra-info))))
		;; Also mark it as internal for the linker.
		(setf (%p-ldb %%entry-instruction-internal-function-p
			      (%pointer-plus compiled-function-object
					     (defstorage-size compiled-function)))
		      1))
	      ;; Stick all the extra stuff we'll need later, during fixup, onto the
	      ;;  compiled-function's extra-info list
	      (let ((doc (function-documentation-string function)))
		(if (not (null doc))
		    (push `(:documentation ,doc) (cdr extra-info))))
	      (when *instance-variable-instructions*
		(push `(:instance-variable-instructions . ,*instance-variable-instructions*)
		      (cdr extra-info)))
	      (when *mapping-table-instructions*
		(push `(:mapping-table-instructions . ,*mapping-table-instructions*)
		      (cdr extra-info)))
	      (when *variable-creation-alist*
		;; Remove any null elements from the alist, and sort it.
		(let ((vca (canonicalize-variable-creation-alist *variable-creation-alist*)))
		  (when vca
		    (push `(:variable-creation-alist . ,vca) (cdr extra-info)))))
	      (when *lexical-variable-instructions*
		(push `(:lexical-variable-instructions . ,*lexical-variable-instructions*)
		      (cdr extra-info)))
	      (when *fdefinition-location-hints*
		(push `(:fdefinition-location-hints . ,*fdefinition-location-hints*)
		      (cdr extra-info)))
	      (when (function-has-captive-lexicals-p function)
		(loop for captive in (function-lexical-variables function)
		      when (lexical-captive-p captive)
			;;--- Doesn't handle the hairy case of captives inside a loop
			collect `(,(variable-name captive)
				  ,(lexical-captive-location captive))
			  into captive-map
		      finally (push `(:captive-map ,@captive-map) (cdr extra-info))))
	      ;; If the user has declared an arglist, make this the 'arglist property,
	      ;; and save the real arglist under 'system:real-arglist
	      (let ((declared-arglist (assq 'arglist (cdr extra-info)))
		    (real-arglist (let ((ll (function-lambda-list function)))
				    (ldiff ll (memq '&aux ll)))))
		(or (equal real-arglist (cdr declared-arglist))
		    (push (cons (if declared-arglist 'system:real-arglist 'arglist)
				real-arglist)
			  (cdr extra-info))))
	      (let ((language-index (assq 'dbg:function-language-index (cdr extra-info))))
		(when language-index
		  (setf (cca-language-index compiled-function-object) (second language-index))
		  (setf (cdr extra-info) (delq language-index (cdr extra-info)))))
	      ;; And save the compiled-function-object into the compiler's internal structure.
	      #-VLM
	      (setf (function-cca function) compiled-function-object)
	      #+VLM
	      (if (cl:member 'sys:translated-function debug-alist :key #'first)
		  (let* ((decoded-function
			   (vlm-decode-ivory-function
			     (cca-compiled-code-object compiled-function-object)))
			 (new-function (vlm-translate-function decoded-function))
			 (new-compiled-function-object
			       (compiled-function-cca
				 (clos:with-slots (newfun) new-function newfun))))
		    (setf (function-cca function) new-compiled-function-object))
		  (setf (function-cca function) compiled-function-object))
	      (when (and *phase-4-to-core* *forward-references-exist*)
		(record-forward-references function)))))))
	;; On the 3600 the temporary arrays are just added to the compiled-function
	;; object (in BUILD-I-COMPILED-CODE) since it's a structure.  On the I machine
	;; they will get copied into the real DTP-COMPILED-FUNCTION object, so they can
	;; be returned.
	(deallocate-instruction-arrays)))))

(defun assemble-interval (interval &optional function)
  ;>>> Assume function is provided except in the cases of dispatches. <<<
  (let (tem)
    (when *p4-trace* (format t "~&Beginning Assembly Phase"))
    (loop with last-inst = (interval-last interval)
	  for inst = (interval-first interval) then (inst-next inst)
	  as *source-locator* = (inst-source-locator inst)
	  when *p4-trace* do (format t "~%In: ~S" inst)
	  do (cond ((and (or (neq inst last-inst)
			     (typep inst 'call-instruction))
			 ;; Most optimizers look ahead, and will expect INST-NEXT to
			 ;; be an instruction.  One exception is the CALL
			 ;; optimizer, which does not look ahead.  There may be
			 ;; others.  The CALL optimizer must be run, so we have to
			 ;; special-case it here.
			 (setq tem (peep-hole-optimizer inst function)))
		    (setq inst tem))
		   (t (assemble-instruction inst function)))
	  until (eq inst last-inst))))

;; Removes null PC entries, sorts by PC, and replaces gensyms with NIL.
;; This is destructive.
(defun canonicalize-variable-creation-alist (vca)
  (when vca
    (loop for elem in vca do
      ;; Replace gensyms with NIL.
      (loop for sublist on (cdr elem) as var = (car sublist) do
	(when (and (symbolp var)
		   (null (symbol-package var)))
	  (setf (car sublist) nil)))
      ;; Remove trailing NILs.
      (loop while (and (cdr elem)
		       (null (car (last elem))))
	    do (nbutlast elem)))
    ;; Sort by PC, and remove null entries.
    (cl:sort (cl:delete nil vca :key #'cdr) #'< :key #'car)))

;; Get out the source locator information and pass 
;; to compile-function method :source-locators
(defun build-source-location-information (ia sa)
  (ignore ia)
  (loop with last-src = (aref sa 0)
        with array-locs = 0
        for index from 2 below (array-active-length sa)
        as current-src = (aref sa index)
        if (and last-src (neq last-src current-src))
	  do (incf array-locs)
        do (setq last-src current-src)
        finally
	  (when last-src (incf array-locs))
	  (return
	    (loop with last-src = (aref sa 0)
		  with last-pc = 2
		  with array = (make-array array-locs :area si:source-locator-area)
		  with array-index = 0
		  for index from 2 below (array-active-length sa)
		  as current-src = (aref sa index)
		  if (and last-src (neq last-src current-src))
		    do (progn
			 (setf (aref array array-index)
			       (funcall *source-locator-word-maker*
					last-pc
					(- (max last-pc (- index 1)) last-pc)
					last-src))
			 (setq last-src current-src)
			 (incf array-index)
			 (setq last-pc index))
		  do (setq last-src current-src)
		  finally
		    (progn (when last-src
			     (setf (aref array array-index)
				   (funcall *source-locator-word-maker*
					    last-pc
					    (- (max last-pc (- index 1)) last-pc)
					    last-src)))
			   (return array))))))

#-IMACH
(defsubst i-compiled-function-extra-info (compiled-function)
  (aref (i-compiled-function-instructions-data compiled-function)
	(- (i-compiled-function-total-size compiled-function)
	   (i-support::defstorage-size i:sys:compiled-function)
	   (i-compiled-function-suffix-size compiled-function))))

#-IMACH
(defun i-compiled-function-instruction (cca pc)
  (let ((tags (i-compiled-function-instructions-tags cca))
	(data (i-compiled-function-instructions-data cca))
	(offset (ldb (byte 31. 1.) pc)))
    (let ((tag (aref tags offset)))
      ;; Full or packed??
      (cond ((= 3 (ldb (byte 2 4) tag))
	     (if (evenp pc)
		 (ldb i:sys:%%q-even-instruction (aref data offset))
		 (dpb (%logldb (byte 4 0) tag) (byte 4. 14.)
		      (%logldb (byte 14. 18.) (aref data offset)))))
	    (t (error "Not handled yet"))))))

#-IMACH
(cl:defsetf i-compiled-function-instruction (cca pc)(instruction)
  `(set-i-compiled-function-instruction ,cca ,pc ,instruction))

#-IMACH
(defun set-i-compiled-function-instruction (cca pc instruction)
  (let ((tags (i-compiled-function-instructions-tags cca))
	(data (i-compiled-function-instructions-data cca))
	(offset (ldb (byte 31. 1.) pc)))
    (let ((tag (aref tags offset)))
      ;; Full or packed??
      (cond ((= 3 (ldb (byte 2 4) tag))
	     (if (evenp pc)
		 (setf (%logldb i:sys:%%q-even-instruction (aref data offset)) instruction)
		 (progn
		   (setf (ldb (byte 4. 0.) (aref tags offset))
			 (ldb (byte 4. 14.) instruction))
		   (setf (%logldb (byte 14. 18.) (aref data offset))
			 (ldb (byte 14. 0.) instruction)))))
	    (t (error "Not handled yet"))))
    instruction))

(defun fixup-compiled-functions ()
  (when *function-mapping-table-families*
    (let ((all-families nil))
      (loop for (family) in *function-mapping-table-families*
	    for size = (clos-internals:mapping-table-family-size family)
	    doing
	(unless (member family all-families)
	  (setf (clos-internals:mapping-table-family-map-bits family)
		(cl:adjust-array (clos-internals:mapping-table-family-map-bits family)
				 size))
	  (setf (clos-internals:mapping-table-family-map-data family)
		(cl:adjust-array (clos-internals:mapping-table-family-map-data family)
				 size))
	  (push family all-families)))))
  (dolist (fun *function-list*)
    ;; Hang internal functions off their parents' extra-info lists.
    (let* ((fspec (function-pr fun))
	   (cca (function-cca fun))
	   (function (%make-pointer-offset
		       dtp-compiled-function
		       cca (sys:defstorage-size compiled-function)))
	   (extra-info (compiled-function-extra-info cca)))
      ;; Hack internal functions
      (when (memq (function-type fun) '(internal external))
	(when *internal-functions*
	  (loop for int-fun in *internal-functions*
		when (eq (function-frame-owner (function-parent-function int-fun)) fun)
		  collect (cons (function-uid int-fun)
				(%make-pointer-offset
				  dtp-compiled-function
				  (function-cca int-fun)
				  (sys:defstorage-size compiled-function)))
		    into alist
		finally
		  (when alist
		    (push `(:internal-functions . ,(mapcar #'cdr (sortcar alist #'<)))
			  (cdr extra-info))))))
      (loop for (index . pc-tag) in (compiler:function-pc-references fun)
	    for i = (+ (lsh index -1) (defstorage-size compiled-function))
	    for tag = (%tag (%memory-read (%pointer-plus cca i) :set-cdr-next nil))
	    do
	(cl:typecase pc-tag
	  (start-call-instruction
	    (let* ((function (start-call-function pc-tag))
		   (call (start-call-call pc-tag))
		   (call-force-external (call-force-external call))
		   (call-function-spec (function-spec (call-function call)))
		   (call-n-args (and (or call-force-external
					 (cl:member call-function-spec '(funcall cl:apply)))
				     (call-n-args call)))
		   (call-apply-p (and (not call-force-external)
				      (eq call-function-spec 'cl:apply)))
		   (prefetch-p
		     (not (null (cl:member (ldb i:sys:%%q-type-within-tag tag)
					   `(,i:sys:dtp-call-compiled-even-prefetch
					     ,i:sys:dtp-call-compiled-odd-prefetch)))))
		   (call-instruction (cli::direct-call-instruction (cca-compiled-code-object
								     (function-cca function))
								   call-n-args
								   call-apply-p
								   prefetch-p)))
	      (%memory-write (%pointer-plus cca i)
			     (%set-tag call-instruction
				       (dpb (ldb i:sys:%%q-type-within-tag
						 (%tag call-instruction))
					    i:sys:%%q-type-within-tag tag)))))
	  (otherwise
	    (let* ((pc-cca
		     (cl:etypecase pc-tag
		       ((or internal-tag pc-tag) cca)
		       (go-tag (function-cca (compiler::tag-function pc-tag)))))
		   (pc-tag-index (tag-address pc-tag))
		   (pc-tag-tag (dpb (if (oddp pc-tag-index) i:sys:dtp-odd-pc i:sys:dtp-even-pc)
				    i:sys:%%q-type-within-tag tag))
		   (pc-tag-data (lsh pc-tag-index -1)))
	      (%memory-write (%pointer-plus cca i)
			     (%set-tag (%pointer-plus
					 pc-cca
					 (+ pc-tag-data
					    (defstorage-size compiled-function)))
				       pc-tag-tag))))))
      ;; Fixup references to ourselves
      (loop for (location tag) in (function-references fun)
	    doing
	(%memory-write location (%set-tag function tag)))	
      ;; Finalize references to instance variables, if this code is going to be executed.
      (setf (car extra-info) fspec)
      (let ((instance-variable-instructions
	      (cdr (assq ':instance-variable-instructions (cdr extra-info))))
	    (mapping-table-instructions
	      (cdr (assq ':mapping-table-instructions (cdr extra-info)))))
	(when (and *phase-4-to-core*
		   (or instance-variable-instructions mapping-table-instructions))
	  (i:si:fixup-method cca)))
      (let ((mapping-table-family-function (compiler:function-has-mapped-slot-access fun)))
	(when mapping-table-family-function
	  (push
	    `(clos-internals:mapping-table-family
	       ,@(loop for (family vars function) in *function-mapping-table-families*
		       when (eq function mapping-table-family-function)
			 collect (cons family vars)))
	    (cdr extra-info))
	  (let ((mapped-argument-positions 0))
	    (dolist (variable (function-lexical-variables fun))
	      (when (compiler:lexical-mapped-access-p variable)
		(let ((original-variable (or (compiler:lexical-original-variable variable)
					     variable)))
		  (when (lexical-argument-p original-variable)
		    (setq mapped-argument-positions
			  (logior mapped-argument-positions
				  (ash 1 (1- (lexical-location original-variable)))))))))
	    (push `(clos-internals::mapped-arguments ,mapped-argument-positions)
		  (cdr extra-info)))))
      (when *phase-4-to-core*
	(setf (cca-extra-info cca) (si:standardize-extra-info function extra-info))))))

#-IMACH
(defun get-i-compiled-function (fspec &optional parent)
  (typecase fspec
    (:symbol (si:function-spec-get fspec :i-compiled-function))
    (:list
      (selectq (car fspec)
	(:internal
	 (cdr
	   (cl:assoc (third fspec)
		     (cdr (cl:assoc ':internal-functions
				    (cdr (i-compiled-function-extra-info
					   (or parent 
					       (get-i-compiled-function
						 (second fspec))))))))))
	(otherwise
	 (si:function-spec-get fspec :i-compiled-function))))))

(defun construct-constants-array (instruction-array n-instructions)
  (let* ((instruction-tags (instruction-array-tags instruction-array))
	 (result (make-array n-instructions))
	 (result-fill-pointer 0))
    (declare (array-register instruction-array instruction-tags result))
    (loop for i below n-instructions
	  as tag = (aref instruction-tags i)
	  as data = (aref instruction-array i)
	  unless (or (= (ldb (byte 2 4) tag)
			(ldb (byte 2 4) i:sys:dtp-packed-instruction-60))
		     (and (= (ldb i:sys:%%q-type-within-tag tag)
			     i:sys:dtp-compiled-function)
			  (not (cl:typep data #-IMach 'i-compiled-function
					      #+IMach 'compiled-function))))
	    do (setf (aref result result-fill-pointer) data)
	       (incf result-fill-pointer)
	  finally
	    (return
	      (cond ((zerop result-fill-pointer)
		     (return-array result)
		     nil)
		    ((< result-fill-pointer n-instructions)
		     (adjust-array-size result result-fill-pointer))
		    (t result))))))

(defun record-forward-references (function)
  (loop with cca = (function-cca function)
	with ancestor-fspec = (external-ancestor-function-spec function)
	with ancestor-location =
	  (and (si:validate-function-spec ancestor-fspec)
	       (si:definition-has-location-p ancestor-fspec)
	       (follow-cell-forwarding (fdefinition-location ancestor-fspec t) nil))
	for j from (defstorage-size compiled-function)
	repeat (let ((header (%p-pointer cca)))
		 (- (ldb cca-total-size header)
		    (ldb cca-suffix-size header)
		    (defstorage-size compiled-function)))
	as loc = (%p-structure-offset cca j)
	do (let ((ref (%memory-read loc :cycle-type %memory-scavenge :set-cdr-next nil)))
	     (when (or (type-member ref dtp-call-indirect dtp-call-indirect-prefetch)
		       (type-member ref dtp-external-value-cell-pointer)
		       (type-member ref dtp-locative))
	       ;; Might reference a compiled function or variable
	       (cond ((eq (%set-tag ref dtp-locative) ancestor-location)
		      (si:reference-undefined-function-cell loc ancestor-fspec))
		     ((not (location-boundp ref))
		      (multiple-value-bind (fspec cell-type)
			  (disassemble-decode-locative (%set-tag ref dtp-locative) cca j)
			(when (eq :function cell-type)
			  (si:reference-undefined-function-cell loc fspec)))))))))
