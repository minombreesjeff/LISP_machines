;;; -*- Mode: LISP; Base: 8;  Package: HARDCOPY-INTERNALS; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Hardcopy options:

;;; Keyword options given in a hardcopy request are processed by widely differing
;;; pieces of software.  To preserve checking of the names of options while not
;;; requiring each piece of software to know the names of options that it doesn't
;;; handle, hardcopy options are formally declared below.  Spelling errors are
;;; caught quickly, at the cost of not allowing random keywords to be passed
;;; through the upper layers of the software.

(define-hardcopy-options :formatter
  :body-character-style "Style in which text body is printed" si:*null-style*
  :heading-character-style "Style in which text headers are printed" si:*null-style*
  :margins "List of TM BM LM RM (in micas)" nil	; CMB: If :landscape-mode T then LM TM RM BM
						; actually always seems to be L T R B
  :bitmap-only-p "Data will only include bit-map commands" nil
  :page-headings "Whether to put headings on each page" t
  :page-width "" nil
  :page-height "" nil
  :page-heading "Heading to put on the top of each page instead of :TITLE" nil
  :page-heading-date "Date to put in heading instead of :DATA-CREATION-DATE" nil
  :output-stream "Destination of bytes for the output device" nil
  :keep-output-stream-open-p "Whether to suppress closing the output stream" nil
  :landscape-p "Whether to orient the output in landscape or portrait mode" nil
  :new-page-hook "" nil
  :starting-page "The first page to be printed" 1
  :ending-page   "The last page to be printed" nil
  :page-number "The starting page number" 0)



;;;; Base flavor
(defflavor basic-hardcopy-stream
	(device
	 (output-stream nil)			;Most devices need one
	 (keep-output-stream-open-p nil)
	 (page-width 177777777)
	 (page-height 177777777)

	 bounding-box-left			;Area in which the cursor is allowed
	 bounding-box-top
	 bounding-box-right
	 bounding-box-bottom
	 (allow-draw-outside-of-bounding-box nil)

	 (cursor-x -1)				;In hardware units left of character
	 (cursor-y -1)				;Position along baseline
	 (device-cursor-x 0)
	 (device-cursor-y 0)

	 (landscape-p nil)
	 (page-exists-p nil)
	 (page-number 0)
	 (new-page-hook nil)

	 (tab-width 8.)				;In space widths, best we can do
	 space-width
	 line-height
	 baseline

	 (requestor-user-id user-id)
	 (data-creation-date nil)
	 (title nil)
	 (page-heading nil)
	 (page-heading-date nil)
	 )
	(si:line-output-stream-mixin si:character-stream si:output-stream)

  (:init-keywords :bitmap-only-p :copies :margins)
  (:initable-instance-variables device output-stream page-width page-height landscape-p
				requestor-user-id data-creation-date title
				page-heading page-heading-date page-number
				keep-output-stream-open-p)
  (:settable-instance-variables bounding-box-left bounding-box-top bounding-box-right
				bounding-box-bottom allow-draw-outside-of-bounding-box
				tab-width new-page-hook space-width line-height baseline
				data-creation-date title)
  (:required-methods :show-char :set-device-cursorpos :eject-page
		     :device-units-to-micas :micas-to-device-units)
  (:gettable-instance-variables page-number page-heading page-heading-date
				requestor-user-id data-creation-date title
				device output-stream)
  (:method-combination :zmail-hardcopy-options (:append :most-specific-last)))
(defun-in-flavor (update-bounding-box basic-hardcopy-stream)
		 (&optional (margins nil margins-p))
  (unless margins-p				;recover margins from current bounding box
    (setq margins (list (send self :device-units-to-micas bounding-box-left :horizontal)
			(send self :device-units-to-micas (- page-height bounding-box-top)
							  :vertical)
			(send self :device-units-to-micas (- page-width bounding-box-right)
							  :horizontal)
			(send self :device-units-to-micas bounding-box-bottom :vertical))))
  (setq bounding-box-left 0 bounding-box-top page-height
	bounding-box-bottom 0 bounding-box-right page-width)
  (when landscape-p
    (psetq bounding-box-left bounding-box-bottom
	   bounding-box-top (- page-width bounding-box-left)
	   bounding-box-right bounding-box-top
	   bounding-box-bottom (- page-width bounding-box-right))
    (swapf page-width page-height))
  (when margins
    (incf bounding-box-left
	  (send self :micas-to-device-units (first margins) :horizontal))
    (decf bounding-box-top
	  (send self :micas-to-device-units (second margins) :vertical))
    (decf bounding-box-right
	  (send self :micas-to-device-units (third margins) :horizontal))
    (incf bounding-box-bottom
	  (send self :micas-to-device-units (fourth margins) :vertical))))

(defmethod (:init basic-hardcopy-stream) (plist)
  (update-bounding-box (get plist ':margins)))

(defmethod (:deferred-open basic-hardcopy-stream) ()
  (send output-stream :deferred-open-internal
	   (named-lambda set-output-stream (new-stream)
	     (setq output-stream new-stream))))

(defmethod (:close basic-hardcopy-stream :before) (&optional abort-p)
  (unless abort-p
    (send self :force-output)))

(defwhopper (:close basic-hardcopy-stream) (&optional abort-p)
  (unless (eq output-stream 'closed-now)
    (when (and (not abort-p)
	       page-exists-p)
      (send self ':eject-page t))
    (continue-whopper abort-p)
    (unless keep-output-stream-open-p
      (send output-stream ':close abort-p))
    (setq output-stream 'closed-now)))

(defmethod (:eof basic-hardcopy-stream) ()
  (send output-stream ':eof))			

(defmethod (:force-output basic-hardcopy-stream) ()
  (send output-stream ':force-output))

(defmethod (:finish basic-hardcopy-stream) ()
  (send output-stream ':finish))

(defmethod (:can-accept-diagrams-as-lines basic-hardcopy-stream) () nil)

(defmethod (:inside-width basic-hardcopy-stream) ()
  (- bounding-box-right bounding-box-left))

(defmethod (:tyo basic-hardcopy-stream) (char)
  ;; It is important that this happens before the font check, so do it now and be safe.
  (send self ':check-page-exists)
  (selector char char-equal
    (#\tab
     (send self ':increment-cursorpos
	   (- tab-width (\ (send self ':read-cursorpos ':character) tab-width))
	   0 ':character))
    (#\line
     (send self ':increment-cursorpos 0 -1 ':character))
    (#\cr
     (send self ':set-cursorpos 0 nil ':character)
     (send self ':increment-cursorpos 0 -1 ':character))
    (#\page
     (send self ':eject-page))
    (#\bs
     (send self ':increment-cursorpos -1 0 ':character))
    (otherwise
     (send self ':show-char char)
     (setq cursor-x device-cursor-x))))

(defmethod (:fresh-line basic-hardcopy-stream) ()
  (unless (= cursor-x bounding-box-left)
    (send self ':tyo #\cr)
    t))

(defmethod (:eject-page basic-hardcopy-stream :after) (&optional ignore)
  (send self :force-output)
  (setq page-exists-p nil))

(defmethod (:check-page-exists basic-hardcopy-stream) ()
  (when (not page-exists-p)
    (setq page-exists-p t)
    (send self ':home-cursor)
    (incf page-number)
    (send self ':new-page)))

(defmethod (:new-page basic-hardcopy-stream :after) ()
  (when new-page-hook (funcall new-page-hook self page-number)))

(defmethod (:home-cursor basic-hardcopy-stream) ()
  (setq cursor-x bounding-box-left
	cursor-y (- bounding-box-top baseline)))

(defun-in-flavor (assure-easy-case basic-hardcopy-stream) ()
  (send self :check-page-exists)
  (send self :check-exceptions)
  (send self :check-cursorpos))

(defmethod (:show-char basic-hardcopy-stream :before) (ignore)
  (assure-easy-case))

(defmethod (:show-line basic-hardcopy-stream :before) (&rest ignore)
  (assure-easy-case))

(defmethod (:draw-line basic-hardcopy-stream) (from-x from-y to-x to-y &optional (units :device))
  (multiple-value-bind (old-x old-y)
      (send self :read-cursorpos :device)
    (send self :set-cursorpos from-x from-y units)
    (multiple-value-bind (abs-device-to-x abs-device-to-y)
	(send self :un-relative-coordinates to-x to-y units)
      (send self :show-line abs-device-to-x abs-device-to-y))
    (send self :set-cursorpos old-x old-y :device)))

(defmethod (:show-rectangle basic-hardcopy-stream :before) (&rest ignore)
  (assure-easy-case))

(defmethod (:draw-rectangle basic-hardcopy-stream) (width height x y &optional (units :device))
  (multiple-value-bind (old-x old-y)
      (send self :read-cursorpos :device)
    (send self :set-cursorpos x y units)
    (let ((device-width (send self :convert-to-device-units width units :horizontal))
	  (device-height (send self :convert-to-device-units height units :vertical)))
      (send self :show-rectangle device-width device-height))
    (send self :set-cursorpos old-x old-y :device)))

(defmethod (:draw-filled-in-polygon basic-hardcopy-stream) (vertex-list &optional (units :device))
  (let ((twice-vertices (length vertex-list)))
    (when (plusp twice-vertices)
      (unless (evenp twice-vertices)
	(ferror "Odd number of coordinates passed to :draw-filled-in-polygon"))
      (multiple-value-bind (old-x old-y)
	  (send self :read-cursorpos :device)
	(let ((abs-vertex-list (loop for (x y) on vertex-list by #'cddr
				     for (abs-x abs-y) = (multiple-value-list
							   (send self :un-relative-coordinates
								 x y units))
				     collect abs-x
				     collect abs-y)))
	  (send self :show-filled-in-polygon abs-vertex-list))
	(send self :set-cursorpos old-x old-y :device)))))

(defmethod (:draw-filled-in-circle basic-hardcopy-stream) (x y r &optional (units :device))
  (multiple-value-bind (old-x old-y)
      (send self :read-cursorpos :device)
    (multiple-value-bind (abs-x abs-y)
	(send self :un-relative-coordinates x y units)
      ;; If the device has different spacing for horizontal and vertical units, this is
      ;; going to be one funny-looking circle...
      (let ((device-r (send self :convert-to-device-units r units :horizontal)))
	(send self :show-filled-in-circle abs-x abs-y device-r)))
    (send self :set-cursorpos old-x old-y :device)))

(defflavor hardcopy-outside-of-bounding-box
	(cursor-x cursor-y bounding-box-left bounding-box-bottom bounding-box-right
	 bounding-box-top stream)
	(dbg:no-action-mixin error dbg:special-commands-mixin)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report hardcopy-outside-of-bounding-box) (str)
  (format str
	  "Attempt to draw on ~S at ~S,~S, ~%which is to the "
	  stream cursor-x cursor-y )
  (cond ((< cursor-x bounding-box-left)
	 (format str "left"))
	(( cursor-x bounding-box-right)
	 (format str "right")))
  (when (or (< cursor-y bounding-box-bottom)
	    ( cursor-y bounding-box-top))
    (when (or (< cursor-x bounding-box-left)
	      ( cursor-x bounding-box-right))
      (format str " and "))
    (cond ((< cursor-y bounding-box-bottom)
	   (format str "bottom"))
	  (( cursor-y bounding-box-top)
	   (format str "top"))))
  (format str
	  " of the bounding box ~S,~S,~S,~S."
	  bounding-box-left bounding-box-top bounding-box-right bounding-box-bottom))

(defmethod (:special-command hardcopy-outside-of-bounding-box :proceed-forever) ()
  "Proceed and allow drawing outside of bounding box for the rest of the document."
  (send stream ':set-allow-draw-outside-of-bounding-box t)
  ':no-action)

(defmethod (dbg:document-proceed-type hardcopy-outside-of-bounding-box :no-action) (stream)
  (format stream "Proceed and allow drawing outside of bounding box one time."))

;;; Keep this method here so HARDCOPY-OUTSIDE-OF-BOUNDING-BOX is already defined when
;;; first compiling this method.
(defmethod (:check-exceptions basic-hardcopy-stream) ()
  (when (and (or (< cursor-x bounding-box-left)
		 ( cursor-x bounding-box-right)
		 (< cursor-y bounding-box-bottom)
		 ( cursor-y bounding-box-top))
	     (not allow-draw-outside-of-bounding-box))
    (signal 'hardcopy-outside-of-bounding-box ':stream self
	    ':cursor-x cursor-x ':cursor-y cursor-y
	    ':bounding-box-left bounding-box-left ':bounding-box-bottom bounding-box-bottom
	    ':bounding-box-right bounding-box-right ':bounding-box-top bounding-box-top)
    ;; May have ejected the page
    (send self ':check-page-exists)))

;;; Use for condition bind with above
(defun simple-formatter-exception-interceptor (cond &optional recursive)
  (condition-bind-if (not recursive)
		     ;; Printing the filename might wrap a line.
		     ((hardcopy-outside-of-bounding-box
			#'(lambda (cond)
			    (simple-formatter-exception-interceptor cond t))))
    (let ((cursor-x (send cond ':cursor-x))
	  (cursor-y (send cond ':cursor-y)))
      (when ( cursor-x (send cond ':bounding-box-right))
	(let ((stream (send cond ':stream)))
	  (send stream ':tyo #\cr)
	  (multiple-value (cursor-x cursor-y)
	    (send stream ':read-page-cursorpos))))
      (when (< cursor-y (send cond ':bounding-box-bottom))
	;; Preserve the horizontal position
	(let ((stream (send cond ':stream)))
	  (send stream ':tyo #\page)
	  (send stream ':set-page-cursorpos cursor-x nil)))))
  ':no-action)

(compile-flavor-methods hardcopy-outside-of-bounding-box)

(defmethod (:read-cursorpos basic-hardcopy-stream) (&optional (units ':device))
  (send self ':check-page-exists)
  (values (send self ':convert-from-device-units
		(- cursor-x bounding-box-left)
		units ':horizontal)
	  (send self ':convert-from-device-units
		(- cursor-y bounding-box-bottom)
		units ':vertical)))

(defmethod (:read-page-cursorpos basic-hardcopy-stream) (&optional (units ':device))
  (values (send self ':convert-from-device-units cursor-x units ':horizontal)
	  (send self ':convert-from-device-units cursor-y units ':vertical)))

(defmethod (:convert-from-device-units basic-hardcopy-stream) (quan units direction)
  (selectq units
    (:device quan)
    (:character (round quan (selectq direction
			      (:horizontal (max 1 space-width))
			      (:vertical line-height))))
    ;; +++ Shouldn't this be :MICA?  -- joseph
    (:micas (send self ':device-units-to-micas quan direction))
    (:pixel (send self ':device-units-to-pixels quan direction))
    (otherwise (ferror "Unknown unit ~S" units))))

(defmethod (:set-cursorpos basic-hardcopy-stream) (x y &optional (units ':device))
  (send self ':check-page-exists)
  (and x (setq cursor-x (+ (send self ':convert-to-device-units x units ':horizontal)
			   bounding-box-left)))
  (and y (setq cursor-y (+ (send self ':convert-to-device-units y units ':vertical)
			   bounding-box-bottom))))

(defmethod (:un-relative-coordinates basic-hardcopy-stream) (x y &optional (units ':device))
  (values (+ (send self ':convert-to-device-units x units ':horizontal)
	     bounding-box-left)
	  (+ (send self ':convert-to-device-units y units ':vertical)
	     bounding-box-bottom)))

(defmethod (:set-page-cursorpos basic-hardcopy-stream) (x y &optional (units ':device))
  (send self ':check-page-exists)
  (and x (setq cursor-x (send self ':convert-to-device-units x units ':horizontal)))
  (and y (setq cursor-y (send self ':convert-to-device-units y units ':vertical))))

(defmethod (:convert-to-device-units basic-hardcopy-stream) (quan units direction)
  (selectq units
    (:device quan)
    (:character (* quan (selectq direction
			  (:horizontal space-width)
			  (:vertical line-height))))
    (:micas (send self ':micas-to-device-units quan direction))
    (:pixel (send self ':pixels-to-device-units quan direction))
    (otherwise (ferror "Unknown unit ~S" units))))

(defmethod (:increment-cursorpos basic-hardcopy-stream) (dx dy &optional (units ':device))
  (send self ':check-page-exists)
  (incf cursor-x (send self ':convert-to-device-units dx units ':horizontal))
  (incf cursor-y (send self ':convert-to-device-units dy units ':vertical)))

(defmethod (:check-cursorpos basic-hardcopy-stream) ()
  (when (not (and (= cursor-x device-cursor-x) (= cursor-y device-cursor-y)))
    (send self ':set-device-cursorpos)))

(defmethod (:size basic-hardcopy-stream) (&optional (units ':device))
  (values (send self ':convert-from-device-units page-width units ':horizontal)
	  (send self ':convert-from-device-units page-height units ':vertical)))

(defmethod (:inside-size basic-hardcopy-stream) (&optional (units ':device))
  (values (send self ':convert-from-device-units (- bounding-box-right bounding-box-left)
		units ':horizontal)
	  (send self ':convert-from-device-units (- bounding-box-top bounding-box-bottom)
		units ':vertical)))

;;; Decrease size of bounding box and return old value
(defmethod (:allocate-margin basic-hardcopy-stream) (size margin &optional (units ':device))
  (let ((tem (or (assq margin '((:left bounding-box-left :horizontal 1)
				(:top bounding-box-top :vertical -1)
				(:right bounding-box-right :horizontal -1)
				(:bottom bounding-box-bottom :vertical 1)))
		 (ferror "Unknown margin ~S" margin))))
    (let ((old (symeval-in-instance self (second tem))))
      (set-in-instance self (second tem)
		       (+ old
			  (* (send self ':convert-to-device-units size units (third tem))
			     (fourth tem))))
      old)))

(defmethod (:string-length basic-hardcopy-stream) (string &optional (start 0) end)
  (loop for i from start below (or end (string-length string))
	summing (send self ':character-width (aref string i))))
(defmethod (:char-width basic-hardcopy-stream) () space-width)

;; ++ This could be made faster by special-casing (= rotation 2) -- joseph
(defun-in-flavor (rotate-bitmap basic-hardcopy-stream) (array width height rotation)
  (let ((rotation (mod rotation 4)))
    (loop for flop below rotation
	  do (setq array (bit-array-rot-90 width height array 0 0))
	     (swapf width height)))
  (values array width height))

(defmethod (:visible-cursorpos-limits basic-hardcopy-stream)
	   (&optional (units :device))
  (multiple-value-call #'values 0 0 (send self :inside-size units)))

(defmethod (:real-set-cursorpos basic-hardcopy-stream) () :hardcopy)


;; Deferred-opening.  The idea is that I can have a hardcopy stream with fonts
;; and character styles and graphic transforms and stuff to do text formatting,
;; without actually having to open and keep a network connection.  It was supposed
;; to work to send :deferred-open to such a hardcopy stream, which was supposed
;; to establish the network connection, but it doesn't work.

(defflavor deferred-opening-streamoid
	(printer spooler-options)
	()
  :initable-instance-variables)

(defmethod (:deferred-open-internal deferred-opening-streamoid) (setter)
  (funcall setter (send printer :hardcopy-device-stream spooler-options)))

(defmethod (:element-type deferred-opening-streamoid) () 'scl:string-char)

(defmethod (:deferred-opening? deferred-opening-streamoid) () T)
  
(defmethod (si:thin-character-stream deferred-opening-streamoid) () self)

(defmethod (:close deferred-opening-streamoid) (&rest ignore) ())

(defmethod (:force-output deferred-opening-streamoid) () ())

(defmethod (:unclaimed-message deferred-opening-streamoid) (message-name &rest args)
  ;; I tried to make this a cerror, to offer <resume> to
  ;; open and retry, but I couldn't think of a good way
  ;; for it to get its hands on the "outer" stream
  (ignore args)
  (error "The deferred-opening hardcopy stream hasn't been opened yet, for operation ~s"
	 message-name))

;;; Thinning
(defflavor thinning-hardcopy-stream
	(original-output-stream)
	()
  (:required-flavors basic-hardcopy-stream))

(defmethod (make-instance thinning-hardcopy-stream) (&rest ignore)
  ;; If the device is spooled, this gets us the thin-character version
  ;; of the request data stream.  If the device isn't spooled, it's
  ;; essentially a no-op.
  (setf original-output-stream output-stream)
  (setf output-stream (si:thin-character-stream output-stream)))

(defmethod (:formatter-generates-multiple-copies thinning-hardcopy-stream) ()
  (send-if-handles original-output-stream :stream-supports-multiple-copies))

(defmethod (:deferred-open thinning-hardcopy-stream :after) ()
  (setf original-output-stream output-stream)
  (setf output-stream (si:thin-character-stream output-stream)))

(defmethod (:close thinning-hardcopy-stream :after) (&optional abort-p)
  (ignore abort-p)
  (setf output-stream original-output-stream))


;;;; Page buffering

(defstruct (hardcopy-page-buffer :named-array-leader
				 (:constructor make-hardcopy-page-buffer-internal)
				 :conc-name)
  (fill-pointer 0)
  (thin-character-view nil)
  (previous-buffer nil)
  (next-buffer nil)
  (page-number nil))

(defselect ((:property hardcopy-page-buffer named-structure-invoke))
  (:print-self (buffer stream &rest ignore)
   (si:printing-random-object (buffer stream :typep))))

(defconstant *page-buffer-length* 1000)

(defun make-hardcopy-page-buffer (page-number)
  (let ((hardcopy-page-buffer (make-hardcopy-page-buffer-internal
				:make-array (:length *page-buffer-length*
					     :type 'art-8b)
				page-number page-number)))
    (setf (hardcopy-page-buffer-thin-character-view hardcopy-page-buffer)
	  (make-array *page-buffer-length*
		      :type 'art-string
		      :displaced-to hardcopy-page-buffer))
    hardcopy-page-buffer))

(defun hardcopy-page-buffer-add-byte (buffer byte)
  (let ((fill-pointer (hardcopy-page-buffer-fill-pointer buffer))
	(array-length (array-length buffer)))
    (cond (( fill-pointer array-length)
	   (let ((new-buffer (make-hardcopy-page-buffer
			       (hardcopy-page-buffer-page-number buffer))))
	     (setf (aref new-buffer 0) byte)
	     (setf (hardcopy-page-buffer-fill-pointer new-buffer) 1)
	     (setf (hardcopy-page-buffer-previous-buffer new-buffer) buffer)
	     (setf (hardcopy-page-buffer-next-buffer buffer) new-buffer)
	     new-buffer))
	  (T (setf (aref buffer fill-pointer) byte)
	     (setf (hardcopy-page-buffer-fill-pointer buffer)
		   (1+ fill-pointer))
	     buffer))))

;;; This gets called on the head, not the tail
(defun hardcopy-page-buffer-total-bytes (buffer)
  (when (hardcopy-page-buffer-previous-buffer buffer)
    (fsignal "~s is not head of list" buffer))
  (loop for b = buffer then (hardcopy-page-buffer-next-buffer b)
	while b
	sum (fill-pointer b)))

;;; This gets called on the head, not the tail
(defun hardcopy-page-buffer-out (buffer stream type)
  (when (hardcopy-page-buffer-previous-buffer buffer)
    (fsignal "~s is not head of list" buffer))
  (loop for b = buffer then (hardcopy-page-buffer-next-buffer b)
	while b
	do (send stream :string-out 
			(cl:ecase type
			  (:thin-character (hardcopy-page-buffer-thin-character-view b))
			  (:unsigned-byte-8 b))
			0 (hardcopy-page-buffer-fill-pointer b))))

(defflavor hardcopy-stream-page-buffering-output-stream
	(buffer)
	(si:unsigned-byte-8-with-character-output-mixin
	 si:output-stream)
  (:settable-instance-variables buffer))

(defmethod (:tyo hardcopy-stream-page-buffering-output-stream) (char)
  (setf buffer (hardcopy-page-buffer-add-byte buffer (argument-typecase char
						       (:character (char-code char))
						       (:fixnum char)))))

(compile-flavor-methods hardcopy-stream-page-buffering-output-stream) 

(defflavor hardcopy-stream-page-buffering-mixin
	(old-output-stream
	 (page-buffers nil)
	 (copies 1)
	 (print-backwards t)
	 (printing-buffer nil))
	()
  (:required-flavors basic-hardcopy-stream)
  (:initable-instance-variables copies print-backwards))

(defmethod (:init hardcopy-stream-page-buffering-mixin :after) (ignore)
  (setq old-output-stream output-stream
	page-buffers (list (make-hardcopy-page-buffer 0))
	output-stream (make-instance 'hardcopy-stream-page-buffering-output-stream
				     :buffer (car page-buffers))))

(defmethod (:close hardcopy-stream-page-buffering-mixin :before) (&optional abort-p)
  (unless abort-p
    (send self :force-output))
  (setq output-stream old-output-stream)
  (unless abort-p
    (send self ':send-page-buffers)))

(defun-in-flavor (send-some-page-buffers hardcopy-stream-page-buffering-mixin)
		 (formatter-copies sublist-start sublist-end final-p)
  (let* ((total-page-buffer-bytes (* formatter-copies
				     (loop for buffers = sublist-start then (cdr buffers)
					   until (eq buffers sublist-end)
					   as buffer = (car buffers)
					   sum (hardcopy-page-buffer-total-bytes buffer))))
	 (page-buffer-bytes-sent 0)
	 (type (if (cl:subtypep (cl:stream-element-type output-stream) 'cl:character)
		   :thin-character
		   :unsigned-byte-8)))
    (tv:noting-progress ("Hardcopy: sending page buffers")
      (letf ((printing-buffer t))
	(loop for i from 1 to formatter-copies
	      do (loop for buffers = sublist-start then (cdr buffers)
		       until (eq buffers sublist-end)
		       do (hardcopy-page-buffer-out (car buffers) output-stream type)
			  (incf page-buffer-bytes-sent
				(hardcopy-page-buffer-total-bytes (car buffers)))
			  (tv:note-progress page-buffer-bytes-sent total-page-buffer-bytes)
			  (send self :eject-page (and (eq (cdr buffers) sublist-end)
						      (= i copies)
						      final-p))))))))

(defmethod (:send-page-buffers hardcopy-stream-page-buffering-mixin) ()
  (unless print-backwards (setq page-buffers (nreverse page-buffers)))
  (send-some-page-buffers (if (send self :formatter-generates-multiple-copies) 1 copies)
			  page-buffers nil t))

(defmethod (:formatter-generates-multiple-copies hardcopy-stream-page-buffering-mixin) ()
  (send-if-handles output-stream :stream-supports-multiple-copies))

(defwhopper (:eject-page hardcopy-stream-page-buffering-mixin) (&optional last-page)
  (if printing-buffer
      (continue-whopper last-page)
      (progn
	(send self :force-output)
	;; Prohibit any :eject-page methods from actually sending output to the device
	;; stream right now; instead, such methods get to do their stuff when we reprint
	;; all the buffered-up pages.  Hey, I didn't write the code, just this comment.  --joseph
	(letf ((output-stream 'ignore))
	  (continue-whopper last-page))
	;; Since the last page will become the first, each page must start with a font
	;; selection.  This shouldn't hurt.
	(send self :send-if-handles :set-device-current-font nil)
	(unless last-page
	  (let ((newbuf (make-hardcopy-page-buffer page-number)))
	    (push newbuf page-buffers)
	    (send output-stream :set-buffer newbuf))))))

;;;; Simple printer device, e.g. a LPT.

(defflavor simple-hardcopy-stream
	((space-width 1)
	 (line-height 1)
	 (baseline 1)
	 (page-width 132.)			;Some average printer
	 (page-height 60.)
	 (char-box-width 254.)
	 (char-box-height 420.))
	(thinning-hardcopy-stream
	 hardcopy-stream-page-buffering-mixin
	 basic-hardcopy-stream)
  (:gettable-instance-variables line-height)
  (:init-keywords :page-size :character-size)
  (:default-init-plist :print-backwards nil))

;;; The size of the character box and the size of the piece of paper are specified
;;; in the namespace object for the printer.
(defmethod (:init simple-hardcopy-stream :before) (plist)
  (setq landscape-p nil)			;Most printers are probably wide anyway
  (let (width height)
    (setf `(,width ,height) (or (get plist ':character-size) (send device ':character-size)))
    (and width (setq char-box-width width))
    (and height (setq char-box-height height)))
  (let (width height)
    (setf `(,width ,height) (or (get plist ':page-size) (send device ':page-size)))
    (and width (setq page-width width))
    (and height (setq page-height height))))

(defmethod (:init simple-hardcopy-stream :after) (ignore)
  (setq device-cursor-x bounding-box-left
	device-cursor-y (- page-height baseline)))

(defmethod (:device-units-to-micas simple-hardcopy-stream) (quan direction)
  (selectq direction
    (:horizontal (* quan char-box-width))
    (:vertical (* quan char-box-height))))

(defmethod (:micas-to-device-units simple-hardcopy-stream) (quan direction)
  (selectq direction
    (:horizontal (round quan char-box-width))
    (:vertical (round quan char-box-height))))

;;; Printing character
(defmethod (:show-char simple-hardcopy-stream) (char)
  (send output-stream ':tyo char)
  (incf device-cursor-x))

(defmethod (:character-width simple-hardcopy-stream) (ignore) 1)

(defmethod (:body-character-style simple-hardcopy-stream) ()
  si:*null-style*)

(defmethod (:heading-character-style simple-hardcopy-stream) ()
  si:*null-style*)

(defmethod (:eject-page simple-hardcopy-stream) (&optional ignore)
  (send output-stream ':tyo #\page)
  (setq device-cursor-x 0
	device-cursor-y (- page-height baseline)))

;;; Simple minded.  Probably don't need optimization since most printers buffer these days.
;;; Bug: What if device-cursor is below cursor?  Can't crawl back up very well.
(defmethod (:set-device-cursorpos simple-hardcopy-stream) ()
  (unless (= cursor-y device-cursor-y)
    (send output-stream ':tyo #\cr)
    (decf device-cursor-y)
    (setq device-cursor-x 0)
    (loop repeat (- device-cursor-y cursor-y)
	  do (send output-stream ':tyo #\cr))
    (setq device-cursor-y cursor-y))
  (unless (= cursor-x device-cursor-x)
    (loop repeat (- cursor-x device-cursor-x)
	  do (send output-stream ':tyo #\sp))
    (setq device-cursor-x cursor-x)))

(compile-flavor-methods simple-hardcopy-stream)


;;;; Fonts

(defvar *font-cache-tick* 0)

(defstruct (font-table :named :array-leader :conc-name (:export :constructor :accessors))
  nfonts
  nfonts-except-header)

(defflavor hardcopy-stream-font-mixin
	(body-character-style
	 heading-character-style
	 current-character-style
	 merged-current-character-style
	 last-character-type
	 (font-cache (make-instance 'si:variable-style-font-cache
				    :global-tick-symbol '*font-cache-tick*))
	 font-table
	 current-font
	 current-font-number
	 (header-font-number 0)
	 (device-current-font nil))
	()
  ;; ++ adjust callers so these are no longer necc.
  (:gettable-instance-variables current-font current-font-number header-font-number
				heading-character-style body-character-style)
  (:settable-instance-variables device-current-font)	;Really only for decaching.
  (:initable-instance-variables body-character-style heading-character-style)
  ;; This line is OK.
  (:required-flavors basic-hardcopy-stream)
  ;; ++ see if this is still necc.
  (:required-methods :canonicalize-font :set-device-font))

(defmethod (:init hardcopy-stream-font-mixin :after) (plist)
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")  ;; Style specified when making stream takes precedence over
  ;;  style specified for the particular device, which in turn takes precedence over
  ;;  style specified when defining device.
  ;; If slovenly system programmer hasn't defined this latter style, use sensible default.
0  (setq body-character-style
	(si:merge-character-styles
	  (or (get plist :body-character-style) si:*null-style*)
	  (si:merge-character-styles
	    (or (send device :body-character-style) si:*null-style*)
	    (si:merge-character-styles
	      (or (send device :default-body-character-style) si:*null-style*)
	      (si:merge-character-styles
		(or (get (send device :type) 'default-body-character-style) si:*null-style*)
		(si:parse-character-style '(:fix :roman :normal))))))
	heading-character-style
	(si:merge-character-styles
	  (or (get plist :heading-character-style) si:*null-style*)
	  (si:merge-character-styles
	    (or (send device :heading-character-style) si:*null-style*)
	    (si:merge-character-styles
	      (or (send device :default-heading-character-style) si:*null-style*)
	      (si:merge-character-styles
		(or (get (send device :type) 'default-heading-character-style) si:*null-style*)
		(si:parse-character-style '(:fix :bold :normal))))))
	current-character-style si:*null-style*
	merged-current-character-style
	(si:merge-character-styles current-character-style body-character-style)
	last-character-type 0)
1  ;; I just hate this stuff.  -- joseph
0  (let ((display-device-type (send device :display-device-type)))
    (flet ((fontify (character-style)
	     (si:get-font display-device-type si:*standard-character-set* character-style)))
      (setq font-table
	    (make-font-table :make-array (:length 1) nfonts 1 nfonts-except-header 0))
      (setf (aref font-table 0)
	    (send self :canonicalize-font (fontify merged-current-character-style)))
      (setq current-font-number 0
	    current-font (aref font-table 0))
      (send self ':update-space-width))))

(defun-in-flavor (font-for-character-style hardcopy-stream-font-mixin)
		 (character-style &optional (character-set si:*standard-character-set*))
  (setq character-style (si:parse-character-style character-style)
	character-set (si:lookup-character-set character-set))
  (let ((display-device-type (send device :display-device-type)))
    ;; If there's a mapping for the screen, but not this device, maybe use it scaled up.
    (flet ((get-font-with-more-error-recovery
	      (display-device-type character-set character-style)
	     (declare (sys:downward-function))
	     (let ((font (si:get-font si:*b&w-screen* character-set character-style nil)))
	       (setq font (and font (typep font 'font) (font-name font)))
	       ;; If we found a font, set up a "remote" proceed type in case there is no other
	       ;; Flush this kludgery when Common Lisp Error System becomes real
	       (condition-bind
		 ((si:no-character-style-mapping
		    (lambda (condition)
		      (when font
			(si:add-font-substitution condition
			  (lambda (stream)
			    (format stream "Use a scaled version of the TV font ~S." font))
			  (lambda ()
			    (setq font (send self :canonicalize-font-for-character-set
						  font :tv-font character-set))
			    #+ignore ;doesn't work because this kind of :device-font
				     ;is not actually implemented yet
			    (values :replace-entire-style
				    (si:intern-character-style ':device-font font
							       display-device-type))
			    ;; Since the above doesn't work, do this instead
			    (send display-device-type :set-mapping character-set
								   character-style font)
			    (values :replace-entire-style character-style))))
		      nil)))
		 (return-from get-font-with-more-error-recovery
		   (si:get-font display-device-type character-set character-style))))))
      (si:cache-lookup font-cache
		       (if (and (or (neq character-set si:*standard-character-set*)
				    (and (eq (si:cs-family character-style) :device-font)
					 (let ((dev (si:cs-size character-style)))
					   (neq dev display-device-type))
					 (let ((font (si:cs-face character-style)))
					   (and (symbolp font) (boundp font)
						(typep (symeval font) 'font)))))
				(send self :can-scale-tv-font))
			   ;; Slower version with lots of setup.
			   #'get-font-with-more-error-recovery
			   #'si:get-font)
		       display-device-type character-set character-style))))
(defmethod (:can-scale-tv-font hardcopy-stream-font-mixin) () nil)

(defun-in-flavor (update-current-font hardcopy-stream-font-mixin)
		 (new-current-font &optional (charset si:*standard-character-set*))
  (setq current-font-number (send self :maybe-add-font new-current-font :device charset)
	current-font (aref font-table current-font-number)))

(defun-in-flavor (regenerate-character-styles-and-fonts hardcopy-stream-font-mixin) ()
  (let* ((new-merged-current-character-style (si:merge-character-styles current-character-style
									body-character-style))
	 (new-current-font (font-for-character-style new-merged-current-character-style)))
    (setq merged-current-character-style new-merged-current-character-style
	  last-character-type 0)
    (update-current-font new-current-font)
    (send self :update-space-width)))

(defun-in-flavor (set-line-height-from-styles hardcopy-stream-font-mixin) (styles)
  (when styles
    (without-interrupts
      (loop with max-height = -1 and accompanying-baseline
	    for style in styles
	    for  font = (font-for-character-style style)
	    do (multiple-value-bind (line-to-line-height baseline) (send font :height-of-font)
		 (when (> line-to-line-height max-height)
		   (setf max-height line-to-line-height)
		   (setf accompanying-baseline baseline)))
	    finally (setf line-height max-height)
		    (setf baseline accompanying-baseline))))
  (regenerate-character-styles-and-fonts))

(defmethod (:smash-font-map hardcopy-stream-font-mixin) (font-list format)
  ;; Empty out the font map
  (setq font-table (make-font-table :make-array (:length 0) nfonts 0 nfonts-except-header 0))
  (loop for font in font-list do (send self :add-font font format))
  (setq current-font-number 0
	current-font (aref font-table 0))
  (send self ':update-space-width))

(defmethod (:set-body-character-style hardcopy-stream-font-mixin) (character-style)
  (setq body-character-style (si:parse-character-style character-style))
  (set-line-height-from-styles `(,character-style)))

(defmethod (:set-heading-character-style hardcopy-stream-font-mixin) (character-style)
  (setq heading-character-style (si:parse-character-style character-style))
  (set-line-height-from-styles `(,character-style)))

(defmethod (:with-character-style hardcopy-stream-font-mixin)
	   (character-style continuation xstream &optional bind-line-height &rest ignore)
  (declare (sys:downward-funarg continuation))
  (unwind-protect
      (letf ((current-character-style (si:merge-character-styles character-style current-character-style))
	     ;; Establish new binding contour, so we don't affect the stream state
	     ;; as seen by other stack groups.
	     ;; +++ Although what happens if another process does a :set-body-character-style
	     ;;     or :set-heading-character-style on the stream?  Kinda half-baked.
	     (merged-current-character-style merged-current-character-style)
	     (last-character-type last-character-type)
	     (current-font-number current-font-number)
	     (current-font current-font)
	     (space-width space-width))
	(if bind-line-height
	    (letf ((line-height line-height)
		   (baseline baseline))
	      ;; We can't use merged-current-character-style because it isn't set until
	      ;; we call regenerate-character-styles-and-fonts, which is done at the END of
	      ;; set-line-height-from-styles.  Ah well.
	      (set-line-height-from-styles `(,(si:merge-character-styles current-character-style body-character-style)))
	      (funcall continuation xstream))
	    (regenerate-character-styles-and-fonts)
	    (funcall continuation xstream)))
    ;; This has to recompute the font since the default-style may have been changed
    ;; inside the continuation.
    (regenerate-character-styles-and-fonts)))

(defmethod (:set-font hardcopy-stream-font-mixin) (new-font &optional (format ':device))
  (setq current-font-number (if (numberp new-font)
				(if (and ( new-font 0)
					 (< new-font (font-table-nfonts font-table)))
				    new-font
				  (fsignal "Font ~D out of range." new-font)
				  0)
				(loop with new = (send self ':canonicalize-font new-font
						       format)
				      for font being the array-elements of font-table
				      using (index i)
				      when (equal font new) return i
				      finally (ferror "Font ~S not in font table" new-font))))
  (setq current-font (aref font-table current-font-number))
  (setq last-character-type 0)
  (send self ':update-space-width))

(defmethod (:add-font hardcopy-stream-font-mixin)
	   (new-font &optional (format ':device) (charset si:*standard-character-set*))
  (prog1 (font-table-nfonts font-table)
	 (array-push-extend font-table
			    (send self :canonicalize-font-for-character-set
				  new-font format charset))))

;;; Added a new argument, so new protocol required.
(defmethod (:canonicalize-font-for-character-set hardcopy-stream-font-mixin :default)
	   (new-font &optional (format ':device) (charset si:*standard-character-set*))
  (ignore charset)
  (send self :canonicalize-font new-font format))

;;; Returns a font number
(defmethod (:maybe-add-font hardcopy-stream-font-mixin)
	   (new-font &optional (format ':device) (charset si:*standard-character-set*))
  (loop with new = (send self :canonicalize-font-for-character-set new-font format charset)
	for font being the array-elements of font-table
	  using (index i)
	when (equal font new) return i
	finally (return (send self :add-font new-font format charset))))

(defun-in-flavor (font-for-character hardcopy-stream-font-mixin) (char)
  (declare (values font character-set character-style))
  (let ((character-style (si:char-style char)))
    (multiple-value-bind (character-set index)
	(si:char-char-set-and-index char)
      (let ((font (font-for-character-style
		    (si:merge-character-styles character-style
					       merged-current-character-style)
		    character-set)))
	(when ( index 256.)
	  ;; If past the subindex range for this primary font, use it to find secondary.
	  ;; If the font isn't an instance, or doesn't handle this message, then something
	  ;; is messed up anyway, so get an error.
	  (setq font (send font :subindex-font-for-index index)))
	(values font character-set character-style)))))

(defwhopper (:show-char hardcopy-stream-font-mixin) (char)
  ;; Do any page ejects, headings, etc. BEFORE we change the font.  This
  ;; duplicates a :before daemon, which is something of a kludge; the
  ;; stream flavarchy precludes a clean fix.  We must do this before
  ;; changing the style for the character, since the page break handler may
  ;; change things yet again.
  (assure-easy-case)				
  (let ((char-type (si:char-type char)))
    (when ( char-type last-character-type)
      (multiple-value-bind (font charset)
	  (font-for-character char)
	(update-current-font font charset))
      (setq last-character-type char-type)))
  (send self :check-font)
  (send self :set-char-was-used-p char)
  (continue-whopper char))

(defmethod (:new-page hardcopy-stream-font-mixin :after) ()
  ;; A header may have clobbered the font, make sure it is good again for printing.
  (send self ':check-font))

(defmethod (:check-font hardcopy-stream-font-mixin) ()
  (unless (eq current-font device-current-font)
    (send self ':set-device-font)))

(defmethod (:update-space-width hardcopy-stream-font-mixin) ()
  (setq space-width (send self :character-width #\space)))

;;; Dummy when not squishing
(defmethod (:char-was-used-p hardcopy-stream-font-mixin) (&rest ignore) t)
(defmethod (:set-char-was-used-p hardcopy-stream-font-mixin) (ignore) )

(defmethod (:vsp hardcopy-stream-font-mixin) () 1)	;return a kludge constant,
						;since the information is lost.


(defflavor hardcopy-stream-character-substitution-mixin () ()
  (:required-methods :substitute-char)
  (:required-flavors hardcopy-stream-font-mixin))

(defwhopper (:show-char hardcopy-stream-character-substitution-mixin) (char)
  (multiple-value-bind (device-char device-font-number)
      (send self :substitute-char char current-font-number)
    (if ( current-font-number device-font-number)
	(letf ((current-font-number device-font-number)
	       (current-font (aref font-table device-font-number)))
	  (send self :check-font)
	  (send self :set-char-was-used-p device-char)
	  (continue-whopper device-char))
	(continue-whopper char))))


(defflavor hardcopy-stream-font-with-squishing-mixin
	(font-squish-table)
	()
  :gettable-instance-variables
  (:required-flavors hardcopy-stream-font-mixin))

(defmethod (:init hardcopy-stream-font-with-squishing-mixin :after) (ignore)
  (setq font-squish-table (make-array (list (array-length font-table) 256.) ':type 'art-1b)))

(defmethod (:add-font hardcopy-stream-font-with-squishing-mixin :after) (&rest ignore)
  (let* ((nfonts (array-length font-table))
	 (new-font-table (make-array (list nfonts 256.) ':type 'art-1b)))
    (2d-array-blt tv:alu-seta (cl:array-dimension font-squish-table 0) 256.
		  font-squish-table 0 0
		  new-font-table 0 0)
    (setq font-squish-table new-font-table)))

(defmethod (:set-char-was-used-p hardcopy-stream-font-with-squishing-mixin) (char)
  ;; Font switching has already taken care of making there be only 256 entries per font,
  ;; even in character sets with more than that.
  (setf (aref font-squish-table current-font-number (char-subindex char)) 1))

(defmethod (:char-was-used-p hardcopy-stream-font-with-squishing-mixin)
	   (ch font-number &optional ignore)
  (not (zerop (aref font-squish-table font-number ch))))

;;; Variant of the above.  Separate mixin due to compatibility requirements.
;;; font-use-table is indexed by font number.  Possible elements are
;;;  t -- font used someplace
;;;  nil -- font unused
;;;  :unchecked -- font never selected
;;;  :unnecesary -- stream declined to bother recording for this font
;;;  array of per character entrys.  Character entries are
;;;   boolean -- if character ever used (array is often boolean)
;;;   integer -- bitmask of pages using
;;;   array -- boolean indexed by page number.
(defflavor hardcopy-stream-font-with-extended-squishing-mixin
	(font-use-table)
	()
  :gettable-instance-variables
  (:required-flavors hardcopy-stream-font-mixin))

(defmethod (:init hardcopy-stream-font-with-extended-squishing-mixin :after) (ignore)
  (setq font-use-table (make-array (* 10 (ceiling (array-length font-table) 10))
				   :initial-value :unchecked)))

(defmethod (:add-font hardcopy-stream-font-with-extended-squishing-mixin :after) (&rest ignore)
  (let* ((nfonts (font-table-nfonts font-table))
	 (nslots (array-length font-use-table)))
    (when (> nfonts nslots)
      (adjust-array-size font-use-table (* 10 (ceiling nfonts 10)))
      (loop for i from nslots below (array-length font-use-table) do
	(setf (aref font-use-table i) :unchecked)))
    (dotimes (i nfonts)
      (when (eq (aref font-use-table i) :unchecked)
	(setf (aref font-use-table i) 
	      (cl:ecase (send self :need-font-squishing (aref font-table i))
		((nil) :unnecessary)
		((t) (make-array 256. :type 'art-boolean))
		((:per-font) nil)
		((:per-page) (make-array 256. :initial-value 0))))))))

(defmethod (:need-font-squishing hardcopy-stream-font-with-extended-squishing-mixin) (ignore)
  t)

(defmethod (:char-was-used-p hardcopy-stream-font-with-extended-squishing-mixin)
	   (index font-number &optional page-number)
  (let ((font-entry (aref font-use-table font-number)))
    (cl:etypecase font-entry
      (symbol
	(eq font-entry 't))
      (cl:array
	(let ((char-entry (aref font-entry index)))
	  (if (null page-number)
	      (not (or (null char-entry) (eql char-entry 0)))
						;assumes an array contains at least one T
	      (cl:etypecase char-entry
		(symbol char-entry)
		(cl:integer (if (listp page-number)
				(loop for page in page-number
				      thereis (ldb-test (byte 1 page) char-entry))
				(ldb-test (byte 1 page-number) char-entry)))
		(cl:array (if (listp page-number)
			      (loop for page in page-number
				      thereis (and (< page (array-length char-entry))
						   (aref char-entry page)))
			      (and (< page-number (array-length char-entry))
				   (aref char-entry page-number)))))))))))

(defmethod (:set-char-was-used-p hardcopy-stream-font-with-extended-squishing-mixin) (char)
  (let ((font-entry (aref font-use-table current-font-number))
	(page-index (1- page-number)))
    (cl:etypecase font-entry
      (symbol
	(setf (aref font-use-table current-font-number) t))
      (cl:array
	(let ((char-entry (aref font-entry (char-subindex char))))
	  (cl:etypecase char-entry
	    (symbol (setf (aref font-entry (char-subindex char)) t))
	    (cl:integer (if (< page-index 32.)
			    (setf (%logldb (byte 1 page-index) char-entry) 1)
			    (let ((new (make-array (* 10 (ceiling (1+ page-index) 10))
						   :type 'art-boolean)))
			      (dotimes (i 32.)
				(when (ldb-test (byte 1 i) char-entry)
				  (setf (aref new i) t)))
			      (setq char-entry new))
			    (setf (aref char-entry page-index) t))
			(setf (aref font-entry (char-subindex char)) char-entry))
	    (cl:array (when ( page-index (array-length char-entry))
			(adjust-array-size char-entry (* 10 (ceiling (1+ page-index) 10))))
		      (setf (aref char-entry page-index) t))))))))
(defmethod (:combine-font-usages hardcopy-stream-font-with-extended-squishing-mixin)
	   (font-number additional-font-number)
  (let ((dest-font-entry (aref font-use-table font-number))
	(add-font-entry (aref font-use-table additional-font-number)))
    (cond ((and (symbolp dest-font-entry) (symbolp add-font-entry))
	   (when (and add-font-entry (not dest-font-entry))
	     (setf (aref font-use-table font-number) t)))
	  ((symbolp add-font-entry))
	  ((symbolp dest-font-entry)
	   (setf (aref font-use-table font-number) add-font-entry))
	  (t
	   (dotimes (i 256.)
	     (let ((dest-char-entry (aref dest-font-entry i))
		   (add-char-entry (aref add-font-entry i)))
	       (cond ((and (symbolp dest-char-entry) (symbolp add-char-entry))
		      (when (and (not dest-char-entry) add-char-entry)
			(setf (aref dest-font-entry i) t)))
		     ((symbolp add-char-entry))
		     ((symbolp dest-char-entry)
		      (setf (aref dest-font-entry i) add-char-entry))
		     ((and (cl:integerp add-char-entry) (cl:integerp dest-char-entry))
		      (setf (aref dest-font-entry i) (logior add-char-entry dest-char-entry)))
		     ((or (cl:integerp add-char-entry) (cl:integerp dest-char-entry))
		      (when (cl:integerp dest-char-entry)
			(swapf add-char-entry dest-char-entry)
			(setf (aref dest-font-entry i) dest-char-entry))
		      (dotimes (i 32.)
			(when (ldb-test (byte 1 i) add-char-entry)
			  (setf (aref dest-char-entry i) t))))
		     (t
		      (when (> (array-length add-char-entry) (array-length dest-char-entry))
			(swapf add-char-entry dest-char-entry)
			(setf (aref dest-font-entry i) dest-char-entry))
		      (dotimes (i (array-length add-char-entry))
			(when (aref add-char-entry i)
			  (setf (aref dest-char-entry i) t)))))))))))
(defmethod (:font-was-used-p hardcopy-stream-font-with-extended-squishing-mixin)
	   (font-number &optional in-pages)
  (let ((font-entry (aref font-use-table font-number)))
    (cl:etypecase font-entry
      (symbol (not (null font-entry)))
      (cl:array
	(loop for i below 256.
	      thereis (let ((char-entry (aref font-entry i)))
			(if (null in-pages)
			    (not (or (null char-entry) (eql char-entry 0)))
						;assumes an array contains at least one T
			    (cl:etypecase char-entry
			      (symbol (not (null char-entry)))
			      (cl:integer
				(loop for page in in-pages
				      thereis (ldb-test (byte 1 page) char-entry)))
			      (cl:array
				(loop for page in in-pages
				      thereis (and (< page (array-length char-entry))
						   (aref char-entry page))))))))))))
(defmethod (:font-char-use-count hardcopy-stream-font-with-extended-squishing-mixin)
	   (font-number)
  (stack-let ((page-counts (make-array 32. :initial-value 0)))
    (let ((font-entry (aref font-use-table font-number)))
      (when (arrayp font-entry)
	(dotimes (i 256.)
	  (let ((char-entry (aref font-entry i)))
	    (cl:typecase char-entry
	      (cl:integer
		(dotimes (p 32.)
		  (when (ldb-test (byte 1 p) char-entry)
		    (incf (aref page-counts p)))))
	      (cl:array
		(let ((olen (array-length page-counts))
		      (nlen (array-length char-entry)))
		  (when (> nlen olen)
		    (adjust-array-size page-counts nlen)
		    (loop for p from olen below nlen do (setf (aref page-counts p) 0)))
		  (dotimes (p nlen)
		    (when (aref char-entry p)
		      (incf (aref page-counts p)))))))))))
    (loop for char-count being the array-elements of page-counts
	  sum (* 50. (ceiling char-count 50.)))))

(defflavor debug-hardcopy-stream
	(output-stream
	 ;; page-width and page-height are in micas and represent an 8.5" x 11" sheet.
	 (page-width (* 85. 254.))
	 (page-height (* 11. 2540.))
	 (space-width 500.)
	 (baseline 1000.)
	 (line-height 1200.))
	(hardcopy-stream-font-mixin basic-hardcopy-stream))

(defmethod (make-instance debug-hardcopy-stream :after) (&rest ignore)
  (setf output-stream sys:syn-terminal-io))

(defmethod (:update-space-width debug-hardcopy-stream) ())

;;; Device units are already micas, so...
(defmethod (:device-units-to-micas debug-hardcopy-stream) (x units)
  (ignore units)
  (cl:identity x))

(defmethod (:micas-to-device-units debug-hardcopy-stream) (x units)
  (ignore units)
  (cl:identity x))

;;; Pixels really means LGP1 dots for debugging, convert to that resolution.
;;; Use of the LGP1 is arbitrary, but was done long ago, so retain for compatability.
(defmethod (:device-units-to-pixels debug-hardcopy-stream) (quan ignore)
  (round (* quan 240.) 2540.))

(defmethod (:pixels-to-device-units debug-hardcopy-stream) (quan ignore)
  (round (* quan 2540.) 240.))

;;; Printing character
(defmethod (:show-char debug-hardcopy-stream) (char)
  (send output-stream :tyo char))

(defmethod (:show-line debug-hardcopy-stream) (new-x new-y)
  (format t "Line to ~D,~D." new-x new-y))

(defmethod (:show-rectangle debug-hardcopy-stream) (width height)
  (format t "Rectangle width=~D, height=~D.~%" width height))

(defmethod (:eject-page debug-hardcopy-stream) (&optional eof)
  (format output-stream "~&Eject page~:[~; (eof)~].~%" EOF))

(defmethod (:set-device-cursorpos debug-hardcopy-stream) ()
  (format output-stream "~&Set cursorpos X=~D. micas, Y= ~D micas.~%" cursor-x cursor-y)
  (setq device-cursor-x cursor-x device-cursor-y cursor-y))

(defmethod (:canonicalize-font debug-hardcopy-stream) (x &optional ignore)
  x)

(defmethod (:set-device-font debug-hardcopy-stream) ()
  (format output-stream "~&Set font ~O (~S).~%" current-font-number current-font)
  (setq device-current-font current-font))

(compile-flavor-methods debug-hardcopy-stream)

(defflavor window-hardcopy-stream
	((was-selected t)
	 (window-x-offset 0)
	 (window-y-offset 0))
	(hardcopy-stream-font-mixin basic-hardcopy-stream))

(defmethod (:init window-hardcopy-stream :before) (ignore)
  (multiple-value (page-width page-height)
    (send output-stream ':inside-size)))

(defmethod (:init window-hardcopy-stream :after) (ignore)
  ;; Compute simple baseline and line height, ignoring header font
  (loop for i below (font-table-nfonts font-table)
	as (font) = (aref font-table i)
	maximize (font-baseline font) into bl
	finally (setq baseline bl line-height (+ bl (send output-stream ':vsp))))
  (unless (eq output-stream tv:selected-window)
    (setq was-selected nil)
    (send output-stream ':select))
  (send output-stream :clear-window)
  (multiple-value (window-x-offset window-y-offset)
    (send output-stream :visible-cursorpos-limits)))

(defmethod (:close window-hardcopy-stream :after) (&optional ignore)
  (or was-selected (send output-stream ':deactivate)))

;;; Pixels really means LGP dots for debugging, convert to that resolution.
(defmethod (:device-units-to-pixels window-hardcopy-stream) (quan direction)
  (round (* (send self ':device-units-to-micas quan direction) 240.) 2540.))

(defmethod (:pixels-to-device-units window-hardcopy-stream) (quan direction)
  (send self ':micas-to-device-units (round (* quan 2540.) 240.) direction))

(defmethod (:device-units-to-micas window-hardcopy-stream) (quan direction)
  (selectq direction
    (:horizontal (round (* quan (* 85. 254.)) page-width))
    (:vertical (round (* quan (* 11. 2540.)) page-height))))

(defmethod (:micas-to-device-units window-hardcopy-stream) (quan direction)
  (selectq direction
    (:horizontal (round (* quan page-width) (* 85. 254.)))
    (:vertical (round (* quan page-height) (* 11. 2540.)))))

(defmethod (:show-char window-hardcopy-stream) (char)
  (let ((at-x device-cursor-x)
	(at-y device-cursor-y))
    (if landscape-p
	(psetq at-x (- page-height (+ at-y (font-baseline (first device-current-font))))
	       at-y (- page-width at-x))
	(setq at-y (- page-height (+ at-y (font-baseline (first device-current-font))))))
    (send output-stream ':draw-glyph (char-code char) (second device-current-font)
	  (+ at-x window-x-offset)
	  (+ at-y window-y-offset)))
  (incf device-cursor-x (send output-stream ':character-width char
			      (first device-current-font))))

(defmethod (:character-width window-hardcopy-stream) (char)
  (send output-stream ':character-width char (first current-font)))

(defmethod (:show-line window-hardcopy-stream) (new-x new-y)
  (multiple-value-bind (iw ih) (send output-stream :inside-size)
    (ignore iw)
    (send output-stream ':draw-line
	  (+ device-cursor-x window-x-offset) (+ (- ih device-cursor-y) window-y-offset)
	  (+ new-x window-x-offset) (+ (- ih new-y) window-y-offset))))

(defmethod (:show-rectangle window-hardcopy-stream) (width height)
  (multiple-value-bind (iw ih) (send output-stream :inside-size)
    (ignore iw)
    (send output-stream ':draw-rectangle width height
	  (+ device-cursor-x window-x-offset)
	  (+ (- ih device-cursor-y height) window-y-offset))))

(defmethod (:eject-page window-hardcopy-stream) (&optional ignore)
  (send output-stream ':tyi)
  (send output-stream ':clear-window)
  (multiple-value (window-x-offset window-y-offset)
    (send output-stream :visible-cursorpos-limits)))

(defmethod (:set-device-cursorpos window-hardcopy-stream) ()
  (setq device-cursor-x cursor-x device-cursor-y cursor-y))

(defmethod (:set-device-font window-hardcopy-stream) ()
  (setq device-current-font current-font))

(defmethod (:canonicalize-font window-hardcopy-stream) (font &optional (type ':device))
  (let* ((rotation 0)
	 (font-symbol (cl:ecase type
			((:device :tv-font)
			 (cl:typecase font
			   ((or cl:symbol (cl:structure tv:font))
			    font)
			   (otherwise
			     (press-font-tv-font-symbol
			       (multiple-value-bind (family face size)
				   (press:decode-font-name font)
				 (press:make-font-entry family face size))))))
			(:press-font
			  (setq rotation (press:font-rotation font))
			  (press-font-tv-font-symbol font))))
	 (font (send (tv:sheet-get-screen output-stream) :parse-font-descriptor font-symbol))
	 (rfont font))
    (if landscape-p (incf rotation 5400.))
    (selector rotation =
      (0)
      (5400. (setq rfont (send (tv:sheet-get-screen output-stream)
			       :parse-font-descriptor
			       (intern (string-append font-symbol "R")
				       si:pkg-fonts-package))))
      (otherwise (ferror "Rotation of ~D not supported." rotation)))
    (list font rfont)))

(defvar *press-font-to-tv-font-table*
  (let ((stuff '(("LWFIX" 0 10. 0) "CPTFONT"
		 ("LWCENTURYSCHOOLBOOK" 0 105. 0) "HL12"
		 ("LWCENTURYSCHOOLBOOK" 1 105. 0) "HL12I"
		 ("LWCENTURYSCHOOLBOOK" 2 105. 0) "HL12B"
		 ("LWHELVETICA" 1 85. 0)	  "HL10I"
		 ("LWHELVETICA" 2 105. 0)	 "HL12B"
		 ("LWHELVETICA" 2 125. 0)	 "HL14B"
		 ("LWHELVETICA" 2 155. 0)	 "SWISS20B"
		 ("LWSYMBOL" 0 105. 0)		 "SYMBOL12"	;---wrong, of course
		 ("HLWSYMBOL" 0 105. 0)		 "SYMBOL12"	;---ditto
		 )))
    (let ((table (scl:make-hash-table :test #'equal)))
      (loop for (press tv) on stuff by #'rest2
	    do (setf (scl:gethash press table)
		     (intern (string-upcase tv) si:pkg-fonts-package)))
      table))) 

(defun press-font-tv-font-symbol (font &aux family size face)
  (setq family (press:font-family-name font)
	size (press:font-size font)
	face (press:font-face font))
  (or (stack-let ((key (list family face size 0)))
	(or (scl:gethash key *press-font-to-tv-font-table*)
	    (fsignal "Lost ~s ~s ~s" family face size)))
      (cond ((and (member family '("SAIL" "LPT" "FIX" "TVFONT")))
	       (setq family (cond ((> size 10.) "CPTFONT")
				  ((> size 8.) "TVFONT")
				  ((> size 4.) "5X5")
				  (t "TINY"))
		     size nil))
	      (t
	       (setq family (selector family string-equal
			      ("TIMESROMAN" "TR")
			      ("HELVETICA" "HL")
			      ("MATH" "MATH")
			      ("GACHA" (if (< size 10.) "GACHA" "GACH"))
			      ("HIPPO" "HIPO")
			      ("GATES" "GATES")
			      ("SPECIAL" "MATH")
			      ("BLOB" "MATH")
			      ("SYMBOL" "MATH")
			      (otherwise family)))))
	(intern (format nil "~A~@[~D~]~A" (string-upcase family) size
			(if (stringp face) face
			    (selector face =
			      (0 "")
			      (1 "I")
			      (2 "B")
			      (3 "BI")
			      (4 "L")
			      (5 "LI")
			      (6 "C")
			      (12. "E"))))
		si:pkg-fonts-package)))



;;;; Simple output functions

(defun hardcopy-text-file (file-name device &rest options)
  (lexpr-funcall #'hardcopy-file file-name device :format :text options))

;;; Hardcopy a file, using the formatter and bytesize specified by its canonical type.
;;; If the :format keyword is given, use the formatter and bytesize implied by that format.
;;; If the :formatter keyword is given, use that formatter.
(defun hardcopy-file (file-name device &rest options
				       &key (title nil title-p)
					    (format nil format-p)
					    (formatter nil formatter-p)
					    (file-open-options nil file-open-options-p)
				       &allow-other-keys)
  (setq device (get-hardcopy-device device))
  (let ((pathname (fs:merge-pathnames file-name))
	byte-size)
    (when (or title-p format-p formatter-p file-open-options-p)
      (setq options (si:rem-keywords options '(:title :format :formatter :file-open-options))))
    (unless format
      (setq format (get (send pathname :canonical-type) :hardcopy-format-for-this-canonical-type)))
    (unless formatter
      (setq formatter (or (and format
			       (symbolp format)
			       (hardcopy-format-input-formatter (find-hardcopy-format format)))
			  'hardcopy-from-stream)))
    (setq byte-size (and format
			 (symbolp format)
			 (hardcopy-format-binary-file-byte-size (find-hardcopy-format format))))
    (unless file-open-options
      (setq file-open-options (if byte-size
				  `(:characters nil :byte-size ,byte-size)
				  `(:characters t))))
    (with-open-stream (file-stream (let ((error-output nil))
				     (lexpr-funcall #'open pathname file-open-options)))
      (lexpr-funcall formatter format file-stream device
		     ':title (or title
				 (send (send file-stream ':truename) ':string-for-printing))
		     ':data-creation-date (send file-stream ':creation-date)
		     options))))

(defflavor bin8-from-char-stream
	(char-stream
	 buffered-p
	 bin-array
	 char-array
	 offset)
	(si:unsigned-byte-8-stream si:buffered-input-stream)
  (:initable-instance-variables char-stream))

(defmethod (make-instance bin8-from-char-stream) (&key &allow-other-keys)
  (cond ((operation-handled-p char-stream :read-input-buffer)
	 (setf buffered-p t)
	 (setf bin-array (cl:make-array 0 :element-type '(cl:unsigned-byte 8)
					:displaced-to "" :adjustable t)))
	(t
	 (setf buffered-p nil)
	 (setf char-array (cl:make-array 1024 :element-type 'cl:string-char))
	 (setf bin-array (cl:make-array 1024 :element-type '(cl:unsigned-byte 8)
					:displaced-to char-array)))))

(defmethod (:next-input-buffer bin8-from-char-stream) (&optional no-hang-p)
  (if buffered-p
      (multiple-value-bind (buffer start end eor)
	  (send char-stream :read-input-buffer nil no-hang-p)
	(when (null buffer)
	  (return-from :next-input-buffer (values nil nil nil eor)))
	(when (string-fat-p buffer)
	       (setf buffer (string-thin buffer :start start :end end :error-if :fat))
	       (decf end start)
	       (setf start 0))
	(cl:adjust-array bin-array end :displaced-to buffer)
	(setf offset end)
	(values bin-array start end eor))
      (multiple-value-bind (index eof)
	  (send char-stream :string-in nil char-array)
	(if (zerop index)
	    (values nil nil nil eof)
	    (values bin-array 0 index nil)))))

(defmethod (:discard-input-buffer bin8-from-char-stream) (ignore)
  (if buffered-p
      (send char-stream :advance-input-buffer offset)
      nil)
  nil)

(defmethod (:close bin8-from-char-stream) (&optional abort-p)
  (send char-stream :close abort-p))

(compile-flavor-methods bin8-from-char-stream)

(defun general-record-file-input-formatter (format record-stream device &rest options)
  (let ((handled-formats (get (send device :type) :input-hardcopy-formats-for-this-device)))
    (unless (or (memq format handled-formats)
		(and (= (length handled-formats) 1)
		     (eq (first handled-formats) :file)))
      (ferror "Device ~A can't interpret input in ~A format; it only interprets ~A format."
	      (send device :pretty-name) format handled-formats)))
  (let ((spooler-options
	  (hci:merge-spooler-options-against-defaults (hci:extract-spooler-options options))))
    (with-open-stream (device-stream (send device :hardcopy-device-stream spooler-options))
      (let ((device-stream-is-character
	      (cl:subtypep (cl:stream-element-type device-stream) 'character))
	    (record-stream-is-character
	      (cl:subtypep (cl:stream-element-type record-stream) 'character)))
1	;; Adjust the record stream to the device stream if necc0.
	(cond ((and device-stream-is-character (not record-stream-is-character))
	       (setf record-stream (si:thin-character-stream record-stream)))
	      ((and (not device-stream-is-character) record-stream-is-character)
	       (setf record-stream (make-instance 'bin8-from-char-stream :char-stream record-stream)))))
      (stream-copy-until-eof record-stream device-stream))))

;;; The input formatter for :TEXT format

(define-hardcopy-format :text "Text"
  (hardcopy-from-stream (:page-headings t)
			(:starting-page 1)
			(:ending-page nil))
  (simple-hardcopy-stream :character-size
			  :page-size
			  :landscape-p)
  (:text))

(defstruct (heading-info :named :conc-name)
  bounding-box-top				; Send in four and get a free decoder ring
  date-string-start
  date-string-end
  page-position
  heading-string
  date-string)

(defun concoct-heading-info (stream)
  (scl:with-character-style ((send stream :heading-character-style) stream)
    ;; ++ Make sure this spacing stuff works OK.
    (let* ((double-space (send stream ':string-length "00"))
	   (bbl (send stream ':bounding-box-left))
	   (page-position (- (send stream ':bounding-box-right)
			     bbl
			     (send stream ':string-length "Page 0000")))
	   (heading-string (or (send stream ':page-heading)
			       (send stream ':title)))
	   (room-for-date (- page-position
			     (if heading-string
				 (send stream ':string-length heading-string)
				 0)
			     (* 2 double-space)))
	   (date-string (let ((date (or (send stream ':page-heading-date)
					(send stream ':data-creation-date))))
			  (and date
			       (time:print-universal-time date nil))))
	   (date-width (if date-string (send stream ':string-length date-string) 0))
	   (date-end nil))
      (when date-string
	(when (> date-width room-for-date)
	  (setq date-end (string-search-char #\sp date-string))
	  (setq date-width (send stream ':string-length date-string 0 date-end)))
	(when (> date-width room-for-date)
	  (setq date-width 0)
	  (setq date-end 0)))
      (make-heading-info
	bounding-box-top (send stream ':allocate-margin (* 5 254.) ':top ':micas)
	date-string-start (- page-position date-width double-space)
	date-string-end date-end
	page-position page-position
	heading-string heading-string
	date-string date-string))))

(defun hardcopy-print-page-heading (stream heading-info page-number ending-page)
  (declare (arglist stream heading-info-structure current-page ending-page))
  (when (and ending-page (> page-number ending-page))	;Complex way of terminating output
    (*throw 'reached-ending-page nil))
  (let ((bb-top (send stream :bounding-box-top)))
    (multiple-value-bind (cur-x cur-y)
	(send stream :read-cursorpos)
      (unwind-protect
	  (scl:with-character-style ((send stream :heading-character-style) stream)
	    (send stream :set-bounding-box-top (heading-info-bounding-box-top heading-info))
	    (send stream :home-cursor)
	    (when (heading-info-heading-string heading-info)
	      (send stream :string-out (heading-info-heading-string heading-info)))
	    (when (heading-info-date-string heading-info)
	      (send stream :set-cursorpos (heading-info-date-string-start heading-info) nil)
	      (send stream :string-out
		    (heading-info-date-string heading-info) 0 (heading-info-date-string-end heading-info)))
	    (send stream :set-cursorpos (heading-info-page-position heading-info) nil)
	    (format stream "Page ~D" page-number))
	(send stream :set-bounding-box-top bb-top)
	(send stream :set-cursorpos cur-x cur-y))))
  (hardcopy-type-page-number stream heading-info page-number ending-page))

(defun hardcopy-type-page-number (ignore ignore page-number ending-page)
  (when (and ending-page (> page-number ending-page))
    (*throw 'reached-ending-page nil))
  (format t " ~D" page-number)) 

;;;--- disabled for now
(defvar *hardcopy-from-stream-auto-line-height* nil)

;;; Hardcopy formatter for text
;;; STARTING-PAGE and ENDING-PAGE are one relative, and ENDING-PAGE is inclusive.
(defun hardcopy-from-stream (format stream device &rest options
			     &key (page-headings t) starting-page ending-page
				  (auto-line-height *hardcopy-from-stream-auto-line-height*)
			     &allow-other-keys)
  (ignore format)
  (let* ((heading-info)
	 (new-page-hook (if page-headings
			    #'hardcopy-print-page-heading
			    #'hardcopy-type-page-number))
	 ;;; Ack Gag Barf monument #4104: Prevent FS:READ-ATTRIBUTE-LIST from
	 ;;; printing warnings about unknown attributes.  Often this requires
	 ;;; the creation of a background stream which the user must select...
	 (fsattrs (let ((error-output #'si:null-stream))
		    (fs:read-attribute-list nil stream)))
	 (dcs (get (locf fsattrs) :default-character-style)))
    (when dcs
      (if (member :body-character-style options)
	  (if (null (cl:getf options :body-character-style))
	      (setf (cl:getf options :body-character-style) dcs))
	  (setf options (append options `(:body-character-style ,dcs)))))
    (with-open-stream
      (hardcopy-stream
	(lexpr-funcall #'make-hardcopy-stream device
		       :new-page-hook
		       #'(lambda (stream page-number)
			   (funcall new-page-hook
				    stream heading-info page-number ending-page))
		       ;;Remember the comment says that starting-page is 1-based
		       ;;but page-number is for the page BEFORE the one you want
		       :page-number (or (and starting-page (1- starting-page)) 0)
		       (si:rem-keywords options '(:page-headings :starting-page :ending-page))))
      (when page-headings (setq heading-info (concoct-heading-info hardcopy-stream)))
      (format t "~&~A:" (send hardcopy-stream ':title))
      (when starting-page			;Throw away everything up to "starting-page"
	(loop repeat (max 0 (1- starting-page))	;Unfortunately the definition of "page" is
	      do (loop as ch = (send stream ':tyi)	;  character, not physical page
		       until (or (null ch) (char-equal ch #\page))))) ;; ++ sad...
      (*catch (if ending-page 'reached-ending-page 'garbage-tag)
	(condition-bind
	  ((hardcopy-outside-of-bounding-box
	     #'simple-formatter-exception-interceptor))
	  (when (send hardcopy-stream :can-accept-diagrams-as-lines)
	    (send-if-handles stream :set-return-diagrams-as-lines t))
	  (when auto-line-height
	    (send-if-handles hardcopy-stream :set-auto-line-height t))
	  (stream-copy-until-eof stream hardcopy-stream)))))) 


(defun hardcopy-format-from-canonical-type (canonical-type)
  (or (get canonical-type :hardcopy-format-for-this-canonical-type)
      :text))

;;; Hardcopy commands

(DEFVAR *HARDCOPY-ABORT-BACKGROUND-IF-ERROR* T)	;Set to T because we think our users are too
						; naive to handle errors in the background.

;;;Arguments:
;;;  ((type1 file1a file1b...) (type2 file2a file2b...)...)
;;;  hardcopy device
;;;  keyword/value list of standard hardcopy options
(defun cp-background-hardcopy (type-file-alist device delete-after-p
			       &rest hardcopy-options
			       &key (notify-requestor t) &allow-other-keys)
  ;; Collect file names to simplify the notifying process afterwards
  (let ((just-files (loop with result
			  for (nil . files) in type-file-alist
			  do (loop for file in files do (push file result))
			  finally (return result))))
    (condition-case-if *hardcopy-abort-background-if-error* (error)
	 (let ((standard-output #'si:null-stream))
	   (loop for (hardcopy-mode . files-to-do) in type-file-alist
		 do (loop for file in files-to-do
			  do (lexpr-funcall #'hardcopy-file file device
					    :format hardcopy-mode hardcopy-options)))
	   (when notify-requestor
	     (tv:notify nil "Your request~P for ~{~A~^, ~} ~:[has~;have~] been sent to ~A."
			(length just-files) just-files
			(> (length just-files) 1) (send device :pretty-name)))
	   (when delete-after-p
	     (loop for (nil . files-to-do) in type-file-alist
		   do (loop for file in files-to-do do (deletef file)))))
       ((fs:file-error sys:network-error)
	(tv:notify nil "Printing of ~{~A~^, ~} aborted due to error: ~~A~."
		   just-files error)))))

(cp:define-command (com-hardcopy-file :command-table "Printer"
				      :provide-output-destination-keyword nil)
    ((file '((cl:sequence fs:pathname))
	   :confirm t
	   :prompt "file"
	   :documentation "File(s) to print")
     (printer 'sys:printer
	      :prompt "printer name"
	      :default hardcopy:*default-text-printer*
	      :documentation "Name of printer on which to do hardcopy")

     &key
     (title '((scl:null-or-type string) :description "a string")
	    :prompt "a string"
	    :default nil
	    :mentioned-default
	    ;; Don't blow out computing mentioned default 
	    ;; in preview mode, where FILE is NIL.
	    (when file
	      (string-append
		"File: "
		(send (fs:parse-pathname (first file))
		      :string-for-printing)))
	    :documentation "Title to appear on the cover page")
     (file-types '((scl:token-or-type (("Use canonical type" . :use-canonical-type))
				      hardcopy-format))
		 :default (loop for pathname in file	;sequence of files
				with common = nil
				finally (return (or common :use-canonical-type))
				as file-type = (hardcopy-format-from-canonical-type
						 (send pathname :canonical-type)) do
			    (cond ((null common) (setq common file-type))
				  ((neq common file-type) (return ':use-canonical-type))))
		 :prompt "Type of data in file, or /"Use canonical type/""
		 :documentation "File type to interpret for printing")
     (body-character-style `((scl:character-style-for-device
			       :allow-relative nil
			       :device ,(if printer
					    (send printer :display-device-type)
					    ;; Don't blow out if no default yet.
					    si:*b&w-screen*)))
			   :default nil
			   :documentation
			   "Character style in which to print contents of file")
     (heading-character-style `((scl:character-style-for-device
				  :allow-relative nil
				  :device ,(if printer
					       (send printer :display-device-type)
					       si:*b&w-screen*)))
			      :default nil
			      :documentation
			      "Character style in which to print file headings")
     (copies 'cl:integer
	     :default 1
	     :documentation "Number of copies to make")
     (delete 'scl:boolean
	     :mentioned-default t
	     :documentation "Delete file after printing?")
     (orientation '((cl:member :landscape :portrait))
		  :default :portrait
		  :documentation "Orientation to use with respect to the paper")
     (running-head '((cl:member :none :numbered))
		   :default :numbered
		   :documentation "Type of running head on each page")
     (starting-page '((cl:integer 1))
		    :default 1
		    :prompt "First physical page to print"
		    :documentation "First physical page to print")
     (ending-page '((scl:token-or-type (("End of file" . nil)) cl:integer))
		  :default nil :provide-default t
		  :prompt "Last physical page to print"
		  :documentation "Last physical page to print")
     (notify 'scl:boolean :default t :documentation "Notify when done printing")
     (print-cover-page 'scl:boolean :default t :documentation "Add a cover page"))
   ;;---Maybe this check could be addressed in the command line itself, but would be complex
   (when (and (numberp ending-page) (< ending-page starting-page))
     (swapf ending-page starting-page)
     (format t "~&Ending page must be the same as or larger than starting page.
The arguments are being interchanged to print from page ~D through page ~D"
	     starting-page ending-page))
   ;; must get printer defined first
   (unless printer
     (format t "~& There is no default printer, please name one.")
     (setq printer (scl:prompt-and-accept 'printer "Printer name")))
   (setq running-head (neq running-head :none))
   (let* ((files)
	  (file-alist '()))
     (fs:force-user-to-login)			;make local and server login requests, and
     (setq files				;errors, happen in the foreground
	   (loop for file in file
		 nconc (condition-case (error)
			    (if (send file :wild-p)
				(loop for (f . nil)
					  in (cdr (fs:directory-list file :fast :sorted))
				      collect f)
				(when (probef file)
				  (ncons file)))
			  (fs:file-operation-failure (format t "Error: ~A" error)))))
     (cond (files				;if there is something to print, start it
	    (if (neq file-types :use-canonical-type)
		(push (cons (hardcopy-format-from-canonical-type file-types) files) file-alist)
		(loop for file in files
		      as this-type = (hardcopy-format-from-canonical-type (send file :canonical-type))
		      unless (assq this-type file-alist)
			do (push (ncons this-type) file-alist)
		      do (nconc (assq this-type file-alist) (ncons file))))
	    (process-run-function
	      `(:name ,(format nil "CP Hardcopy File ~{~A~^, ~}" file)
		:priority ,*background-hardcopy-priority*)
	      #'cp-background-hardcopy
	      file-alist			; Alist of (type . non-wildcard pathnames)
	      printer
	      delete				; Flag indicating whether to delete after
	      ;;Use the official hardcopy option names here in the calling sequence
	      ;;Command can be extended by collecting new keyword arg and adding to list here
	      ;; assuming that the new arg is valid hardcopy option
	      :title title
	      :copies copies
	      :landscape-p (eq orientation :landscape)	;---not a documented hardcopy option
	      :body-character-style body-character-style 
	      :heading-character-style heading-character-style 
	      :page-headings running-head
	      :starting-page starting-page	;---misdocumented as "number of pages to skip"
	      :ending-page ending-page
	      :notify-requestor notify
	      :print-cover-pages print-cover-page))
	   (t (format t "~& Error: ~A doesn't exist." file)))))

(cp:define-command (com-hardcopy-system :command-table "Printer"
					:provide-output-destination-keyword nil)
    ((system '((scl:type-or-string ((or sct:subsystem sct:system))))
	     :confirm t
	     :documentation "System to hardcopy")
     (printer 'sys:printer
	      :prompt "printer name"
	      :default hardcopy:*default-text-printer*
	      :documentation "Name of printer on which to do hardcopy")

     &key
     (version 'sct:system-version
	      :default :newest
	      :documentation "Which major version of the system to hardcopy")
     (branch `((sct:system-branch :system ,system))
	     :documentation "System branch"
	     :default (or (and system (not (stringp system))
			       (sct:system-default-system-branch system))
			  (dw:presentation-type-default
			    `((sct:system-branch :system ,system))))
	     :when (and (cl:member :version-control cl:*features*)
			(or (stringp system)
			    (sct:system-version-controlled system))))
     (query '((cl:member :everything :yes :confirm-only :no))
	    :mentioned-default :everything
	    :default :confirm-only
	    :documentation
	    "Whether to ask about hardcopying each file")
     (silent 'scl:boolean
	     :default nil
	     :mentioned-default t
	     :documentation "Whether to suppress all terminal output")
     (include-components 'scl:boolean
			 :default t
			 :documentation
			 "Whether to include component systems")
     (title '((scl:null-or-type string) :description "a string")
	    :prompt "a string"
	    :default nil
	    :mentioned-default
	    ;; Don't blow out computing mentioned default 
	    ;; in preview mode, where FILE is NIL.
	    (WHEN system
	      (format nil "System: ~A" system))
	    :documentation "Title to appear on the cover page")
     (body-character-style `((scl:character-style-for-device
			       :allow-relative nil
			       :device ,(send printer :display-device-type)))
			   :default nil
			   :documentation
			   "Character style in which to print contents of file")
     (heading-character-style `((scl:character-style-for-device
				  :allow-relative nil
				  :device ,(send printer :display-device-type)))
			      :default nil
			      :documentation
			      "Character style in which to print file headings")
     (copies 'cl:integer
	     :default 1
	     :documentation "Number of copies to make")
     (orientation '((cl:member :landscape :portrait))
		  :default :portrait
		  :documentation "Orientation to use with respect to the paper")
     (running-head '((cl:member :none :numbered))
		   :default :numbered
		   :documentation "Type of running head on each page"))
   ;; Must get printer defined first
   (unless printer
     (format t "~& There is no default printer, please name one.")
     (setq printer (scl:prompt-and-accept 'printer "Printer name")))
   (setq running-head (neq running-head :none))
   (sct:hardcopy-system system :version version
			:system-branch (and (cl:member :version-control cl:*features*)
					    (or (stringp system)
						(sct:system-version-controlled system))
					    branch)
			:query query :silent silent
			:include-components include-components
			:hardcopy-device printer
			:title title :copies copies
			:landscape-p (eq orientation :landscape)
			:page-headings running-head
			:body-character-style body-character-style
			:heading-character-style heading-character-style))

(defun hardcopy-file-menu (&optional pathname)
  (apply #'com-hardcopy-file
	 (cp:choose-command-arguments 'com-hardcopy-file
				      :initial-arguments (and pathname (list (list pathname)))
				      :mode :accept-values
				      :own-window t)))

(tv:add-to-system-menu-programs-column "Hardcopy" '(hardcopy-file-menu)
				       "Print files on the hardcopy printer")



(dw:define-presentation-to-command-translator hci::com-hardcopy-file
   (fs:pathname
    :gesture nil
    :tester ((pathname &key presentation)
	     (and (neq (dw:presentation-type presentation) 'fs:directory-pathname)
		  (fs:pathname-sequentially-accessible-p pathname)
		  (let ((type (send pathname :canonical-type)))
		    ;; Don't hardcopy binary files unless there's some further magic
		    ;; (ZL:GET so we don't explode on strings)
		    (or (not (zl:get type :binary-file-byte-size))
			(zl:get type :hardcopy-format-for-this-canonical-type)))))
    :documentation ((pathname)
		    (if hardcopy:*default-text-printer*
			(format nil "Hardcopy File ~A on ~A"
			  pathname
			  (let ((neti:*inhibit-validity-checking* t))
			    (send hardcopy:*default-text-printer*
				  :pretty-name)))
		      (format nil "Hardcopy File ~A (specify printer name)" pathname))))
   (pathname)
  (values
    `(hci::com-hardcopy-file (,pathname)) 'cp:command
    :activate (not (null hardcopy:*default-text-printer*))))

