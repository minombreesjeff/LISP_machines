;;; -*-  Mode: LISP; Package: PRESS; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFFLAVOR PRESS-DISPLAY-DEVICE
	()
	(SI:DISPLAY-DEVICE))

(DEFWHOPPER (:GET-MAPPING PRESS-DISPLAY-DEVICE) (CHARSET CHARACTER-STYLE &OPTIONAL INQUIRY-ONLY)
  (IGNORE INQUIRY-ONLY)
  (LET ((SPEC (CONTINUE-WHOPPER CHARSET CHARACTER-STYLE)))
    ;; Just a no-op for now
    SPEC)) 

(COMPILE-FLAVOR-METHODS PRESS-DISPLAY-DEVICE)

(SI:REGISTER-DISPLAY-DEVICE *PRESS-PRINTER* PRESS-DISPLAY-DEVICE)
  
;;; Just a stub, really.
(SI:DEFINE-CHARACTER-STYLE-FAMILIES *PRESS-PRINTER* SI:*STANDARD-CHARACTER-SET*
  '(:FAMILY :FIX (:SIZE :NORMAL (:FACE :ROMAN (:FONT ("LPT" "" 10.))))
	    :HEADING (:SIZE :NORMAL (:FACE :ROMAN (:FONT ("LPT" "" 10.))))))

(DEFINE-HARDCOPY-FORMAT :PRESS
			"Press"
			(HARDCOPY-PRESS-STREAM :STARTING-PAGE :ENDING-PAGE :COPIES)
			(PRESS-STREAM :COPIES :MARGINS)
			(:PRESS))

(DEFINE-HARDCOPY-DEVICE :PRESS
			:BITMAP-PRINTER-P T
			:MULTIPLE-FONT-P T
			:DISPLAY-DEVICE-TYPE *PRESS-PRINTER*
			:DEFAULT-BODY-CHARACTER-STYLE '(:FIX :ROMAN :NORMAL)
			:DEFAULT-HEADING-CHARACTER-STYLE '(:HEADING :BOLD :NORMAL)
			:INPUT-FORMATS (:PRESS)
			:OUTPUT-FORMAT :PRESS
			:HARDCOPY-FILE-FLAVOR PRESS-HARDCOPY-FILE)

(DEFFLAVOR PRESS-HARDCOPY-FILE
	(FONTS-WIDTHS-FILE)
	(PRESS-HARDCOPY-DEVICE-MIXIN HARDCOPY-FILE)
  (:DEFAULT-INIT-PLIST :CANONICAL-TYPE :PRESS)
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:HARDCOPY-HARDWARE-STREAM PRESS-PRINTER) ()
  (FERROR "No support for PRESS printers on LISPM's"))

(COMPILE-FLAVOR-METHODS PRESS-HARDCOPY-FILE PRESS-PRINTER)

(DEFUN GET-PRESS-FILE-HARDCOPY-DEVICE (OUTPUT-FILE
				       &KEY FONTS-WIDTHS-FILE DEVICE-FOR-FONTS-WIDTHS)
  (UNLESS (OR FONTS-WIDTHS-FILE DEVICE-FOR-FONTS-WIDTHS)
    (FERROR "Must specify how to get FONTS.WIDTHS for writing ~A." OUTPUT-FILE))
  (LET ((DEVICE (GET-HARDCOPY-DEVICE (LIST :FILE OUTPUT-FILE :PRESS))))
    (SEND DEVICE ':SET-FONTS-WIDTHS-FILE
	  (OR FONTS-WIDTHS-FILE
	      (SEND DEVICE-FOR-FONTS-WIDTHS ':FONTS-WIDTHS-FILE)))
    DEVICE))



;;; Press file generation

(DEFVAR *PAGE-ENTITY-BUFFER-EXTENSION-SIZE* 4000.)

(DEFRESOURCE PAGE-ENTITY-BUFFER ()
  :CONSTRUCTOR (MAKE-ARRAY *PAGE-ENTITY-BUFFER-EXTENSION-SIZE*
			   ':TYPE 'ART-8B ':FILL-POINTER 0))

(DEFFLAVOR PRESS-STREAM
	((PAGE-WIDTH (* 85. 254.))
	 (PAGE-HEIGHT (* 11. 2540.))
	 
	 (N-CHARS)				;Number of characters sent this part
	 (CURRENT-RECORD-NUMBER 0)		;Record number within file
	 (PENDING-CHARS 0)			;Number of chars output but not yet known
						;about at the "entity" level
	 (DATA-LIST-START)			;Value of PRESS-N-CHARS at start of entity
	 (ENTITY-LIST-START)			;Value of (size of entity buffer) at ..
	 (PAGE-ENTITY-BUFFER (ALLOCATE-RESOURCE 'PAGE-ENTITY-BUFFER))
						;This holds the "entity" portion of the
						;current page
	 (PART-LIST NIL)			;List of elements (part-type record-number
						;		   n-records n-padding-words)

	 (LINE-USE-SPECIAL-OPCODE NIL)		;Alternative is NEWVEC
	 (LINE-WIDTH 25.)			;.01 inch
	 (COPIES 1)

	 LOCAL-FONT-WIDTH-DATA
	 )
	(HARDCOPY-STREAM-FONT-MIXIN BASIC-HARDCOPY-STREAM)
  (:INITABLE-INSTANCE-VARIABLES COPIES)
  (:SETTABLE-INSTANCE-VARIABLES LINE-USE-SPECIAL-OPCODE LINE-WIDTH)
  (:DEFAULT-INIT-PLIST :MARGINS `(2000. 1270. 2000. 1270.)))

;;; This provides nice thin lines, for thinner lines you might want 2 instead of 4
(DEFVAR *LINE-FONT* '(NEWVEC "" 4 0 0 0 NIL))
;;; The way these fonts work is that the point size is the thickness of the line,
;;; and NEWVEC has round ends, HNEWVEC has horizontal ends, and SNEWVEC has square
;;; ends (that is diamond on a 45-degree line).  The way the characters are organized
;;; is:  Consider the right half-box, and all its radii, that is lines proceeding
;;; clockwise from straight-up through straight-down.  The fonts contain vectors to
;;; all points with integral coordinates on half-boxes of various sizes.  The widths
;;; of the characters are set up so that the vectors chain properly.
;;; 
;;; 	000-100    The 16.-bit box
;;; 	120-160    The 8.-bit box
;;; 	170-210    The 4.-bit box
;;; 	214-224    The 2.-bit box
;;; 	226-232    The 1.-bit box
;;; 	240        The 0-bit box (or isolated point).

;;;; Output to the Data and Entity Lists

;;; Macros to output things to the entity buffer
(DEFMACRO ENTITY-BYTE (BYTE)
  `(ARRAY-PUSH-EXTEND PAGE-ENTITY-BUFFER ,BYTE *PAGE-ENTITY-BUFFER-EXTENSION-SIZE*))

(DEFMACRO ENTITY-WORD (WORD &ENVIRONMENT ENV)
  (ONCE-ONLY (WORD &ENVIRONMENT ENV)
    `(PROGN (ENTITY-BYTE (LDB (BYTE 8. 8.) ,WORD))
	    (ENTITY-BYTE (LDB (BYTE 8. 0.) ,WORD)))))

(DEFMACRO ENTITY-32WORD (WORD &ENVIRONMENT ENV)
  (ONCE-ONLY (WORD &ENVIRONMENT ENV)
    `(PROGN (ENTITY-BYTE (LDB (BYTE 8. 24.) ,WORD))
	    (ENTITY-BYTE (LDB (BYTE 8. 16.) ,WORD))
	    (ENTITY-BYTE (LDB (BYTE 8. 8.) ,WORD))
	    (ENTITY-BYTE (LDB (BYTE 8. 0.) ,WORD)))))

;;; Macros to output to the data list.
(DEFMACRO DATA-BYTE (BYTE)
  `(PROGN (SEND OUTPUT-STREAM ':TYO ,BYTE)
	  (INCF N-CHARS)))

(DEFMACRO DATA-WORD (WORD &ENVIRONMENT ENV)
  (ONCE-ONLY (WORD &ENVIRONMENT ENV)
    `(PROGN (DATA-BYTE (LDB (BYTE 8. 8.) ,WORD))
	    (DATA-BYTE (LDB (BYTE 8. 0.) ,WORD)))))

(DEFMACRO DATA-32WORD (WORD &ENVIRONMENT ENV)
  (ONCE-ONLY (WORD &ENVIRONMENT ENV)
    `(PROGN (DATA-BYTE (LDB (BYTE 8. 24.) ,WORD))
	    (DATA-BYTE (LDB (BYTE 8. 16.) ,WORD))
	    (DATA-BYTE (LDB (BYTE 8. 8.) ,WORD))
	    (DATA-BYTE (LDB (BYTE 8. 0.) ,WORD)))))

(DEFUN-IN-FLAVOR (ENTITY-BCPL-STRING PRESS-STREAM) (STRING NBYTES &AUX REAL-LENGTH)
  (SETQ STRING (STRING STRING))
  (ENTITY-BYTE (SETQ REAL-LENGTH (MIN (STRING-LENGTH STRING) (1- NBYTES))))
  (DOTIMES (I REAL-LENGTH)
    (ENTITY-BYTE (CHAR-CODE (AREF STRING I))))
  (DOTIMES (I (- NBYTES (1+ REAL-LENGTH)))
    (DECLARE (IGNORE I))
    (ENTITY-BYTE 0)))


;;;; PRESS FORMAT DECLARATIONS

;;; Set up so #,<SET-X> turns into 356 -- except the compiler chokes!!

(DEFPROP DEFPRESS DEFVAR ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFPRESS (NAME . BODY)
  `(DEFVAR ,NAME ,(CAR BODY)))

;;; These are ENTITY LIST COMMANDS

(DEFPRESS <SHOW-CHARACTERS-SHORT>		  0 + (N-1 1))
(DEFPRESS <SKIP-CHARACTERS-SHORT>		 40 + (N-1 1))
(DEFPRESS <SHOW-CHARACTERS-AND-SKIP>		100 + (N-1 1))
(DEFPRESS <SET-SPACE-X-SHORT>			140 + (X 2))
(DEFPRESS <SET-SPACE-Y-SHORT>			150 + (Y 2))
(DEFPRESS <FONT>				160 + (FONT 1))
(DEFPRESS <SKIP-CONTROL-BYTES-IMMEDIATE>	353 (N 1))
(DEFPRESS <ALTERNATIVE>				354 (EL-TYPES 2) (EL-BYTES 4) (DL-BYTES 4))
(DEFPRESS <ONLY-ON-COPY>			355 (N 1))
(DEFPRESS <SET-X>				356 (X 2))
(DEFPRESS <SET-Y>				357 (Y 2))
(DEFPRESS <SHOW-CHARACTERS>			360 (N 1))
(DEFPRESS <SKIP-CHARACTERS>			361 (N 1))
(DEFPRESS <SKIP-CONTROL-BYTES>			362 (N 2) (TYPE 1))
(DEFPRESS <SHOW-CHARACTER-IMMEDIATE>		363 (CHAR 1))
(DEFPRESS <SET-SPACE-X>				364 (S 2))
(DEFPRESS <SET-SPACE-Y>				365 (S 2))
(DEFPRESS <RESET-SPACE>				366)
(DEFPRESS <SPACE>				367)
(DEFPRESS <SET-BRIGHTNESS>			370 (B 1))
(DEFPRESS <SET-HUE>				371 (H 1))
(DEFPRESS <SET-SATURATION>			372 (S 1))
(DEFPRESS <SHOW-OBJECT>				373 (N 2))
(DEFPRESS <SHOW-DOTS>				374 (N 4))
(DEFPRESS <SHOW-DOTS-OPAQUE>			375 (N 4))
(DEFPRESS <SHOW-RECTANGLE>			376 (WIDTH 2) (HEIGHT 2))
(DEFPRESS <NOP>					377)


;;; These are DATA LIST COMMANDS

(DEFPRESS <<MOVETO>>				  0)
(DEFPRESS <<DRAWTO>>				  1)
(DEFPRESS <<DRAWCURVE>>				  2)

(DEFPRESS <<SET-CODING>>			  1)
(DEFPRESS <<SET-WINDOW>>			  1)
(DEFPRESS <<SET-MODE>>				  2)
(DEFPRESS <<SET-SIZE>>				  2)
(DEFPRESS <<DOTS-FOLLOW>>			  3)
(DEFPRESS <<GET-DOTS-FROM-FILE>>		  4)
(DEFPRESS <<GET-DOTS-FROM-PRESS-FILE>>		  5)
(DEFPRESS <<SET-SAMPLING-PROPERTIES>>		  6)

(DEFPRESS <<SSP-INPUT-INTENSITY>>		  0)
(DEFPRESS <<SSP-OUTPUT-INTENSITY>>		  1)
(DEFPRESS <<SSP-SCREEN>>			  2)
(DEFPRESS <<SSP-DOT>>				  3)

;;;; Finish Press File

;;; Output font directory, part directory, document directory
(DEFMETHOD (:CLOSE PRESS-STREAM :BEFORE) (&OPTIONAL ABORT-P)
  (UNLESS ABORT-P
    ;; The font directory part
    (SETF (FILL-POINTER PAGE-ENTITY-BUFFER) 0)
    (LOOP FOR FONT-NUMBER BELOW (FONT-TABLE-NFONTS FONT-TABLE)
	  AS FONT = (AREF FONT-TABLE FONT-NUMBER)
	  DO (ENTITY-WORD 16.)			;Length in words
	     (ENTITY-BYTE 0)			;Font set 0 **** crock
	     (ENTITY-BYTE FONT-NUMBER)
	     (ENTITY-BYTE 0)			;First char
	     (ENTITY-BYTE 177)			;Last char
	     (ENTITY-BCPL-STRING (STRING-UPCASE (FIRST FONT)) 20.)	;Family
	     (ENTITY-BYTE (ENCODE-PRESS-FACE (SECOND FONT)))	;Face code
	     (ENTITY-BYTE 0)			;Source (same as first char)
	     (ENTITY-WORD (THIRD FONT))		;Positive is points, negative is micas
	     (ENTITY-WORD (FOURTH FONT)))	;Rotation in minutes of arc anticlockwise
    (ENTITY-WORD 0)				;End mark
    (SEND OUTPUT-STREAM ':STRING-OUT PAGE-ENTITY-BUFFER)
    (SEND SELF ':FINISH-PART (FILL-POINTER PAGE-ENTITY-BUFFER) 1)
    ;; That took care of the font directory, now the part directory
    (SETF (FILL-POINTER PAGE-ENTITY-BUFFER) 0)
    (DOLIST (X (REVERSE PART-LIST))		;Not NREVERSE!
      (ENTITY-WORD (FIRST X))			;Part type
      (ENTITY-WORD (SECOND X))			;Starting record number
      (ENTITY-WORD (THIRD X))			;Number of records
      (ENTITY-WORD (FOURTH X)))			;Amount of padding
    (SEND OUTPUT-STREAM ':STRING-OUT PAGE-ENTITY-BUFFER)
    (SEND SELF ':FINISH-PART (FILL-POINTER PAGE-ENTITY-BUFFER) 'FOO)
    ;; The document directory
    (SETF (FILL-POINTER PAGE-ENTITY-BUFFER) 0)
    (ENTITY-WORD 27183.)			;Password
    (ENTITY-WORD (1+ CURRENT-RECORD-NUMBER))	;File size
    (ENTITY-WORD (1- (LENGTH PART-LIST)))	;Number of parts
    (ENTITY-WORD (SECOND (CAR PART-LIST)))	;Record number of part directory
    (ENTITY-WORD (THIRD (CAR PART-LIST)))	;Number of records in part dir
    (ENTITY-WORD 0)				;Back-pointer
    (ENTITY-32WORD 0)				;[Date]
    (ENTITY-WORD 1)				;First copy to print
    (ENTITY-WORD COPIES)			;Last copy to print
    (ENTITY-WORD -1)				;Print all pages
    (ENTITY-WORD -1)				;..
    (ENTITY-WORD -1)				;Default printing mode
    (DOTIMES (I (- 200 13.))			;Padding
      (DECLARE (IGNORE I))
      (ENTITY-WORD -1))
    (ENTITY-BCPL-STRING TITLE 52.)
    (ENTITY-BCPL-STRING REQUESTOR-USER-ID 32.)
    (ENTITY-BCPL-STRING (IF (NULL DATA-CREATION-DATE) ""
			    (TIME:PRINT-UNIVERSAL-TIME DATA-CREATION-DATE NIL))
			40.)
    (SEND OUTPUT-STREAM ':STRING-OUT PAGE-ENTITY-BUFFER)
    (SEND SELF ':FINISH-PART (FILL-POINTER PAGE-ENTITY-BUFFER) 1)))


;;;; Pages

;;; Start a page

(DEFMETHOD (:NEW-PAGE PRESS-STREAM) ()
  (SETF (FILL-POINTER PAGE-ENTITY-BUFFER) 0)
  (SETQ N-CHARS 0)
  (SEND SELF ':OPEN-ENTITY))

;;; Finish a page.

(DEFMETHOD (:EJECT-PAGE PRESS-STREAM) (&OPTIONAL IGNORE)
  (SEND SELF ':CLOSE-ENTITY)
  ;; Make the length of the data buffer a multiple of a word
  (AND (ODDP N-CHARS) (DATA-BYTE 0))
  ;; Output a zero word between the data list and the entity list
  (SEND OUTPUT-STREAM ':TYO 0)
  (SEND OUTPUT-STREAM ':TYO 0)
  ;; Output the entity buffer
  (SEND OUTPUT-STREAM ':STRING-OUT PAGE-ENTITY-BUFFER)
  ;; Pad to a record (512-byte) boundary, and advance CURRENT-RECORD-NUMBER
  (SEND SELF ':FINISH-PART (+ N-CHARS 2 (FILL-POINTER PAGE-ENTITY-BUFFER)) 0)
  )

;;; Hair shared between page parts and other parts
(DEFMETHOD (:FINISH-PART PRESS-STREAM) (NBYTES PART-TYPE &AUX NWORDS NRECORDS PADDING)
  (CHECK-ARG NBYTES EVENP "an even number of bytes")
  (SETQ NWORDS (// NBYTES 2))
  (SETQ PADDING (\ (- 256. (\ NWORDS 256.)) 256.))
  (SETQ NWORDS (+ NWORDS PADDING))
  (SETQ NRECORDS (// NWORDS 256.))
  (DOTIMES (I (* PADDING 2))
    (DECLARE (IGNORE I))
    (SEND OUTPUT-STREAM ':TYO 0))
  (PUSH (LIST PART-TYPE CURRENT-RECORD-NUMBER NRECORDS PADDING) PART-LIST)
  (INCF CURRENT-RECORD-NUMBER NRECORDS))

;;;; Entities

;;; Start an entity

(DEFMETHOD (:OPEN-ENTITY PRESS-STREAM) ()
  (SETQ DATA-LIST-START N-CHARS
	ENTITY-LIST-START (FILL-POINTER PAGE-ENTITY-BUFFER)
	PENDING-CHARS 0
	DEVICE-CURRENT-FONT NIL))

;;; Finish the current entity.
;;; We do not bother to place the entity other than in the corner, since we have
;;; done full bounding box maintenance already anyway.
(DEFMETHOD (:CLOSE-ENTITY PRESS-STREAM) (&AUX (X-OFF 0)
					      (Y-OFF 0)
					      (WIDTH (- BOUNDING-BOX-RIGHT
							BOUNDING-BOX-LEFT))
					      (HEIGHT (- BOUNDING-BOX-BOTTOM
							 BOUNDING-BOX-TOP)))
  (WHEN LANDSCAPE-P
    (SWAPF X-OFF Y-OFF)
    (SWAPF WIDTH HEIGHT))
  (SEND SELF ':PUT-PENDING-CHARS)
  ;; Pad entity to word boundary with NOP
  (AND (ODDP (FILL-POINTER PAGE-ENTITY-BUFFER))
       (ENTITY-BYTE 377))
  ;; Entity trailer
  (ENTITY-BYTE 0)				;Type     **** crocks
  (ENTITY-BYTE 0)				;Font set ****
  (ENTITY-32WORD DATA-LIST-START)		;Begin-byte
  (ENTITY-32WORD (- N-CHARS DATA-LIST-START))	;Byte-length
  (ENTITY-WORD X-OFF)				;X offset (left margin)
  (ENTITY-WORD Y-OFF)				;Y offset (bottom margin)
  (ENTITY-WORD 0)				;Left     ****
  (ENTITY-WORD 0)				;Bottom   ****
  (ENTITY-WORD PAGE-WIDTH)			;Width
  (ENTITY-WORD PAGE-HEIGHT)			;Height
  (ENTITY-WORD					;Entity length
    (// (- (+ (FILL-POINTER PAGE-ENTITY-BUFFER) 2)
	   ENTITY-LIST-START)
	2)))

;;; Finish the current entity if the entity buffer is getting full.
;;; This will cause you to lose your cursor position and selected font.
;;; The problem is that if you have more than 32768 bytes in an entity,
;;; the Alto suffers from 16-bit brain-rot.
(DEFMETHOD (:MAYBE-NEW-ENTITY PRESS-STREAM) ()
  (COND ((> (FILL-POINTER PAGE-ENTITY-BUFFER) 25000.)
	 (SEND SELF ':CLOSE-ENTITY)
	 (SEND SELF ':OPEN-ENTITY))))

;;;; Random Functions

;;; Set (X,Y) position on the page
(DEFMETHOD (:SET-DEVICE-CURSORPOS PRESS-STREAM) ()
  (SEND SELF ':PUT-PENDING-CHARS)
  (LET ((X CURSOR-X)
	(Y CURSOR-Y))
    (AND LANDSCAPE-P
	 (PSETQ X (- PAGE-HEIGHT Y)
		Y X))
    (ENTITY-BYTE 356)	;Set-X
    (ENTITY-WORD X)
    (ENTITY-BYTE 357)	;Set-Y
    (ENTITY-WORD Y))
  (SETQ DEVICE-CURSOR-X CURSOR-X DEVICE-CURSOR-Y CURSOR-Y))

;;; Put show-chars command for any pending characters
(DEFMETHOD (:PUT-PENDING-CHARS PRESS-STREAM) ()
  (COND ((NULL PENDING-CHARS))
	((ZEROP PENDING-CHARS) NIL)
	(( PENDING-CHARS 40) (ENTITY-BYTE (1- PENDING-CHARS)))
	(T (DO () ((< PENDING-CHARS 400))
	     (ENTITY-BYTE 360)
	     (ENTITY-BYTE 377)
	     (DECF PENDING-CHARS 377))
	   (ENTITY-BYTE 360)
	   (ENTITY-BYTE PENDING-CHARS)))
  (SETQ PENDING-CHARS 0))

;;; Output a character.
(DEFMETHOD (:SHOW-CHAR PRESS-STREAM) (CHAR)
  (LET ((WIDTH (AREF (SEVENTH DEVICE-CURRENT-FONT) (CHAR-SUBINDEX CHAR))))
    (IF (MINUSP WIDTH)
	(FORMAT ERROR-OUTPUT "~&~C (~O) undefined character in ~A~D~A~%"
		CHAR CHAR
		(FIRST DEVICE-CURRENT-FONT) (THIRD DEVICE-CURRENT-FONT)
		(SECOND DEVICE-CURRENT-FONT))
	(DATA-BYTE (CHAR-SUBINDEX CHAR))
	(INCF PENDING-CHARS)
	(INCF DEVICE-CURSOR-X WIDTH))))

(DEFMETHOD (:CHARACTER-WIDTH PRESS-STREAM) (CHAR)
  (MAX 0 (AREF (SEVENTH CURRENT-FONT) (CHAR-CODE CHAR))))

(DEFMETHOD (:DEVICE-UNITS-TO-MICAS PRESS-STREAM) (X IGNORE) X)
(DEFMETHOD (:MICAS-TO-DEVICE-UNITS PRESS-STREAM) (X IGNORE) X)

;;; Pixels really means XGP dots, convert to that resolution
(DEFMETHOD (:DEVICE-UNITS-TO-PIXELS PRESS-STREAM) (QUAN IGNORE)
  (// (* QUAN 200.) 2540.))

(DEFMETHOD (:PIXELS-TO-DEVICE-UNITS PRESS-STREAM) (QUAN IGNORE)
  (// (* QUAN 2540.) 200.))

;;;; Font Stuff

(DEFUN DECODE-FONT-NAME (STRING &AUX IDX1 IDX2 (IBASE 10.))
  (DECLARE (VALUES FAMILY FACE SIZE))
  (OR (SETQ IDX1 (STRING-REVERSE-SEARCH-SET '(#/0 #/1 #/2 #/3 #/4 #/5 #/6 #/7 #/8 #/9)
					    STRING))
      (FERROR NIL "No point size in ~A" STRING))
  (SETQ IDX2 (1+ (STRING-REVERSE-SEARCH-NOT-SET '(#/0 #/1 #/2 #/3 #/4 #/5 #/6 #/7 #/8 #/9)
						STRING IDX1)))
  (VALUES (SUBSTRING STRING 0 IDX2)
	  (SUBSTRING STRING (1+ IDX1))
	  (READ-FROM-STRING (SUBSTRING STRING IDX2 (1+ IDX1)))))

;;; Single-letters in the string select features as follows:
;;; B bold, L light
;;; I italic
;;; C condensed
;;; E expanded
(DEFUN ENCODE-PRESS-FACE (STR)
  (SETQ STR (STRING STR))
  (DO ((FACE-CODE 0)
       (I 0 (1+ I))
       (N (STRING-LENGTH STR))
       (CH))
      ((= I N) FACE-CODE)
    (SETQ CH (CHAR-UPCASE (AREF STR I)))
    (SETQ FACE-CODE (+ FACE-CODE
		       (SELECTOR CH CHAR-EQUAL
			 (#/B 2)
			 (#/L 4)
			 (#/I 1)
			 (#/C 6)
			 (#/E 12.)
			 (OTHERWISE (FERROR NIL "~C illegal character in face name /"~A/""
					    CH STR)))))))

;;; Just a stub to keep the compiler quiet during system builds.
(DEFUN TV-FONT-PRESS-FONT (IGNORE)
  (FERROR "This function is not yet implemented."))

(DEFMETHOD (:CANONICALIZE-FONT PRESS-STREAM) (FONT &OPTIONAL (TYPE :DEVICE))
  (AND (EQ TYPE ':TV)
       (SETQ FONT (TV-FONT-PRESS-FONT FONT)))
  (LET (FAMILY-NAME FACE-NAME POINT-SIZE ROTATION)
    (IF (LISTP FONT)
	(SETF `(,FAMILY-NAME ,FACE-NAME ,POINT-SIZE ,ROTATION) FONT)
	(MULTIPLE-VALUE (FAMILY-NAME FACE-NAME POINT-SIZE)
	  (DECODE-FONT-NAME FONT)))
    (OR ROTATION (SETQ ROTATION 0))
    (AND LANDSCAPE-P (INCF ROTATION 5400.))
    ;; For historical reasons, font-width-data routines want to see it as a special var
    (LET ((FONT-WIDTH-DATA LOCAL-FONT-WIDTH-DATA))
      (LET ((WIDTH (GET-FONT-WIDTH-AND-HEIGHT FAMILY-NAME FACE-NAME POINT-SIZE))
	    HEIGHT WIDTH-ARRAY)
	(SETQ HEIGHT (CADR WIDTH) WIDTH (CAR WIDTH))	;Bounding box for font
	(SETQ WIDTH-ARRAY (GET-FONT-WIDTH-DATA FAMILY-NAME FACE-NAME POINT-SIZE))
	(LIST FAMILY-NAME FACE-NAME POINT-SIZE ROTATION WIDTH HEIGHT WIDTH-ARRAY)))))

(DEFMETHOD (:SET-DEVICE-FONT PRESS-STREAM) ()
  (SEND SELF ':PUT-PENDING-CHARS)
  (ENTITY-BYTE (+ 160 CURRENT-FONT-NUMBER))
  (SETQ DEVICE-CURRENT-FONT CURRENT-FONT))

(DEFMETHOD (:INIT PRESS-STREAM :BEFORE) (IGNORE)
  (SETQ LOCAL-FONT-WIDTH-DATA (GET-FONT-WIDTH-DATA-FOR-PRINTER DEVICE)))

(DEFMETHOD (:INIT PRESS-STREAM :AFTER) (IGNORE)
  (SETQ BASELINE (LOOP FOR I BELOW (FONT-TABLE-NFONTS FONT-TABLE)
			  AS FONT = (AREF FONT-TABLE I)
			  MAXIMIZE (SIXTH FONT))
	LINE-HEIGHT BASELINE))

(DEFVAR *NEWVEC-SLOPE-TABLE*)
(DEFVAR *NEWVEC-DX-TABLE*)
(DEFVAR *NEWVEC-DY-TABLE*)

(DEFUN MAKE-NEWVEC-TABLES ()
  (DO ((TBL (MAKE-ARRAY 101))
       (XTBL (MAKE-ARRAY 101))
       (YTBL (MAKE-ARRAY 101))
       (BITS-TO-MICAS (// 2540.0s0 384.))
       (I 0 (1+ I))
       (DX 0)
       (DY 16.))
      ((= I 101)
       (SETQ *NEWVEC-SLOPE-TABLE* TBL
	     *NEWVEC-DX-TABLE* XTBL
	     *NEWVEC-DY-TABLE* YTBL))
    (ASET (COND ((= I 0) 1s18)
		((= I 100) -1s18)
		(T (// (#+CADR SMALL-FLOAT #-CADR FLOAT DY) DX))) TBL I)
    (ASET (* DX BITS-TO-MICAS) XTBL I)
    (ASET (* DY BITS-TO-MICAS) YTBL I)
    (COND ((< I 20) (SETQ DX (1+ DX)))
	  ((< I 60) (SETQ DY (1- DY)))
	  (T (SETQ DX (1- DX))))))

(MAKE-NEWVEC-TABLES)

;;; Draw a line, using rectangles for straight lines and font for diagonal lines.
(DEFMETHOD (:SHOW-LINE PRESS-STREAM) (X1 Y1 &AUX (X0 DEVICE-CURSOR-X)
						 (Y0 DEVICE-CURSOR-Y)
						 (DX (ABS (- X0 X1)))
						 (DY (ABS (- Y0 Y1)))
						 FONT-NUMBER)
  (SEND SELF ':PUT-PENDING-CHARS)
  (SEND SELF ':MAYBE-NEW-ENTITY)		;This should make DPLT work better
  (COND (LINE-USE-SPECIAL-OPCODE
	 (ENTITY-BYTE 201)
	 (ENTITY-WORD X1)
	 (ENTITY-WORD Y1))
	((= X0 X1)				;Vertical line
	 (SEND SELF ':SET-PAGE-CURSORPOS (- X0 (// LINE-WIDTH 2)) (MIN Y0 Y1))
	 (SEND SELF ':SHOW-RECTANGLE LINE-WIDTH DY))
	((= Y0 Y1)				;Horizontal line
	 (SEND SELF ':SET-PAGE-CURSORPOS (MIN X0 X1) (- Y0 (// LINE-WIDTH 2)))
	 (SEND SELF ':SHOW-RECTANGLE DX LINE-WIDTH))
	(T					;Diagonal line, use the font
	 (SETQ FONT-NUMBER (SEND SELF ':MAYBE-ADD-FONT *LINE-FONT*))
	 (UNLESS (= FONT-NUMBER CURRENT-FONT-NUMBER)
	   (SEND SELF ':SET-FONT FONT-NUMBER)
	   (SEND SELF ':CHECK-FONT))
	 (IF (< X1 X0) (PSETQ X0 X1 Y0 Y1 X1 X0 Y1 Y0))	;(X0,Y0) are left end
	 (SEND SELF ':SET-PAGE-CURSORPOS X0 Y0)	;Proceed inevitably toward the right
	 (SEND SELF ':CHECK-CURSORPOS)
	 (AND (< Y1 Y0) (SETQ DY (- DY)))
	 ;; Always use 2 characters of the largest size except for finishing up
	 (DO ((CH2 1 (1+ CH2))
	      (CH1 0 CH2)
	      (SLOPE (// (FLOAT DY) DX)))
	     ((OR (= CH2 100)
		  (< (AREF *NEWVEC-SLOPE-TABLE* CH2) SLOPE))
	      (DO ((X X0 (+ X XINC))
		   (Y Y0 (+ Y YINC))
		   (CH) (XINC) (YINC) (STOP NIL) (RUN)
		   (CDX1 (AREF *NEWVEC-DX-TABLE* CH1))
		   (CDY1 (AREF *NEWVEC-DY-TABLE* CH1))
		   (CDX2 (AREF *NEWVEC-DX-TABLE* CH2))
		   (CDY2 (AREF *NEWVEC-DY-TABLE* CH2))
		   (LENGTH (+ (ABS (- X1 X0)) (ABS (- Y1 Y0)))))
		  (STOP)
		;; If Y would be below the line, use CH1 else use CH2.
		;; Watch out for zero divide possibility.
		(IF (OR (= (SETQ RUN (- (+ X CDX2) X0)) 0)
			(< (// (FLOAT (- (+ Y CDY2) Y0)) RUN) SLOPE))
		    (SETQ CH CH1 XINC CDX1 YINC CDY1)
		  (SETQ CH CH2 XINC CDX2 YINC CDY2))
		;; If getting too close to the endpoint, use a shorter line
		(DO ((STRTL '(0 120 170 214 226) (CDR STRTL))
		     (I CH)
		     (D 2 (* D 2)))
		    ;; This test minimizes distance to endpoint by taxi cab
		    ;; metric without overshooting.
		    ((OR ( (+ (ABS (- (+ Y YINC) Y0)) (ABS (- (+ X XINC) X0)))
			    LENGTH)
			 (SETQ STOP (NULL (CDR STRTL)))))
		  (SETQ CH (+ (// (- CH (CAR STRTL)) 2) (CADR STRTL))
			I (* (// I D) D)
			XINC (// (AREF *NEWVEC-DX-TABLE* I) D)
			YINC (// (AREF *NEWVEC-DY-TABLE* I) D)))
		(COND ((NOT STOP)
		       (DATA-BYTE CH)
		       (INCF PENDING-CHARS)))))))))

(DEFMETHOD (:SHOW-RECTANGLE PRESS-STREAM) (WIDTH HEIGHT)
  (ENTITY-BYTE 376)
  (ENTITY-WORD WIDTH)
  (ENTITY-WORD HEIGHT))

(COMMENT ;THIS DOESN'T WORK SO I DIDN'T CONVERT IT
;;;; Output a BITMAP off a window

;;; Output bitmap as an entity on the current page
;;;    assumes page is open but not an entity
;;; This uses pixel array because the halfword array requires a bitreverse
;;;      due to the DOVERs inflexibility
;;; U, V define the lower left edge of bitmap on page                [micas]
;;; SX0, SY0, SX1, SY1 define the left, top, right, bottom of screen [pixels]

(DEFUN PRESS-TV-BITMAP (U V &OPTIONAL (WINDOW TV:DEFAULT-SCREEN)
				      (SX0 0) (SY0 0) (SX1 (TV:SHEET-WIDTH WINDOW))
				      (SY1 (TV:SHEET-HEIGHT WINDOW)))
  (IF (> SX0 SX1) (PSETQ SX0 SX1 SX1 SX0))
  (IF (> SY0 SY1) (PSETQ SY0 SY1 SY1 SY0))
  (LET ((ARRAY  (TV:SHEET-SCREEN-ARRAY WINDOW))
	(START  0)
	(LINES  (LOGAND (+ 15. (- SY1 SY0)) 1760))
	(DOTS   (LOGAND (+ 15. (- SX1 SX0)) 1760))
	(SIZE   32.)				; a dot is 32 x 32 micas
	(WIDTH  0)
	(HEIGHT 0))
    (SETQ WIDTH  (* DOTS  SIZE)
	  HEIGHT (* LINES SIZE))
    (PRESS-OPEN-ENTITY)
    (PRESS-PUT-PENDING-CHARS)
    (PRESS-SET-CURSOR U V)
    (IF (ODDP PRESS-N-CHARS)
	(PROGN (PRESS-ENTITY-BYTE <SKIP-CHARACTERS-SHORT>)
	       (PRESS-DATA-BYTE 0)))
    (SETQ START PRESS-N-CHARS)			; remember where we are in DL
    (PROGN (PRESS-DATA-BYTE <<SET-CODING>>)
	   (PRESS-DATA-BYTE 0)
	   (PRESS-DATA-WORD DOTS)
	   (PRESS-DATA-WORD LINES))
    (PROGN (PRESS-DATA-BYTE <<SET-MODE>>)
	   (PRESS-DATA-BYTE 3.))		; Dover Requires this direction
    (PROGN (PRESS-DATA-WORD <<SET-SIZE>>)
	   (PRESS-DATA-WORD WIDTH)
	   (PRESS-DATA-WORD HEIGHT))
    (PROGN (PRESS-DATA-WORD <<DOTS-FOLLOW>>)
	   (DO ((Y      SY0 (1+ Y))
		(LAST-Y (+ LINES SY0)))
	       ((>= Y LAST-Y))
	     (DO ((X      SX0 (+ X 16.))
		  (LAST-X (+ DOTS SX0)))
		 ((>= X LAST-X))
	       (PRESS-DATA-WORD
		 (DO ((I 0 (1+ I))
		      (R 0))
		     ((>= I 16.) R)
		   (SETQ R (+ (LSH R 1) (AREF ARRAY (+ (MIN X SX1) I) (MIN Y SY1)))))))))
    (PROGN (PRESS-ENTITY-BYTE   <SHOW-DOTS>)
	   (PRESS-ENTITY-32WORD (// (- PRESS-N-CHARS START) 2)))
    (PRESS-CLOSE-ENTITY U V WIDTH HEIGHT)
    ))
)


;;; Hardcopy a press file

(DEFSTRUCT (PRESS-FILE :NAMED :ARRAY-LEADER :CONC-NAME)
  LENGTH
  PATHNAME
  FIRST-COPY
  LAST-COPY
  STARTING-PAGE
  ENDING-PAGE
  PRINTING-MODE
  FILE-NAME
  USER-NAME
  CREATION-DATE
  NPAGES
  PARTS
  FONT-DIRECTORY
  )

(DEFSTRUCT (FONT-DIRECTORY :NAMED :ARRAY-LEADER :CONC-NAME (MAKE-ARRAY (:LENGTH 1)))
  (NSETS 0)
  FONT-LIST					;List of all fonts used
  )

(DEFSTRUCT (FONT-SET-DIRECTORY :NAMED :ARRAY-LEADER :CONC-NAME (MAKE-ARRAY (:LENGTH 10)))
  (NFONTS 0)
  MAPPING-TABLE					;Indexed by set font number, global font number
  )

(DEFSTRUCT (ENTITY :NAMED :ARRAY :CONC-NAME)
  TYPE
  FONT-SET
  DATA-START
  DATA-LENGTH
  X
  Y
  BB-LEFT
  BB-BOTTOM
  BB-WIDTH
  BB-HEIGHT
  COMMAND-START
  COMMAND-LENGTH
  )

(DEFVAR *COPY*)

(DEFUN HARDCOPY-PRESS-FILE (FILENAME DEVICE &REST OPTIONS)
  (LEXPR-FUNCALL #'HARDCOPY-FILE FILENAME DEVICE :FORMAT :PRESS OPTIONS))

;;;starting-page and ending-page are 1-based and inclusive.  The press file numbering
;;;is zero-based so the options get adjusted here.
(DEFUN HARDCOPY-PRESS-STREAM (FORMAT STREAM DEVICE &REST OPTIONS
			      &KEY STARTING-PAGE ENDING-PAGE COPIES
			      &ALLOW-OTHER-KEYS)
  (IGNORE FORMAT)
  (IF (AND (EQ (SEND DEVICE ':TYPE) ':PRESS)
	   (NOT (TYPEP STREAM 'PRESS-FILE))
	   (NULL STARTING-PAGE) (NULL ENDING-PAGE) (NULL COPIES))
      ;; If not specially processing and printing on a device that accepts press files
      ;; natively, just do that.
      (WITH-OPEN-STREAM (DSTREAM (SEND DEVICE ':HARDCOPY-DEVICE-STREAM))
	(STREAM-COPY-UNTIL-EOF STREAM DSTREAM))
    (LET ((PRESS-FILE (IF (TYPEP STREAM 'PRESS-FILE) STREAM
			  (READ-PRESS-FILE STREAM))))
      (AND STARTING-PAGE (SETF (PRESS-FILE-STARTING-PAGE PRESS-FILE) (1- starting-page)))
      (AND ENDING-PAGE (SETF (PRESS-FILE-ENDING-PAGE PRESS-FILE) (1- ending-page)))
      (WHEN COPIES
	(SETF (PRESS-FILE-FIRST-COPY PRESS-FILE) 1)
	(SETF (PRESS-FILE-LAST-COPY PRESS-FILE) COPIES))
      (WITH-OPEN-STREAM (STREAM (LEXPR-FUNCALL #'MAKE-HARDCOPY-STREAM DEVICE
					       ':MARGINS NIL
					       ':TITLE
					         (OR (GET (LOCF OPTIONS) :TITLE)
						     (PRESS-FILE-FILE-NAME PRESS-FILE))
					       #|	;No, show user printing.
					       ':RECIPIENT
					         (OR (GET (LOCF OPTIONS) :RECIPIENT)
						     (PRESS-FILE-USER-NAME PRESS-FILE))
					       |#
					       ':DATA-CREATION-DATE
					         (OR (GET (LOCF OPTIONS)
							  :DATA-CREATION-DATE)
						     (PRESS-FILE-CREATION-DATE PRESS-FILE))
					       (SI:REM-KEYWORDS OPTIONS
								'(:STARTING-PAGE :ENDING-PAGE
								  :COPIES
								  :TITLE
								 ;:RECIPIENT
								  :DATA-CREATION-DATE))))
	(SEND STREAM :SMASH-FONT-MAP (GET-PRESS-FILE-FONTS PRESS-FILE) :PRESS-FONT)
	(LET* ((FIRST-COPY (PRESS-FILE-FIRST-COPY PRESS-FILE))
	       (LAST-COPY (PRESS-FILE-LAST-COPY PRESS-FILE))
	       (START-PAGE (OR (PRESS-FILE-STARTING-PAGE PRESS-FILE) 0))
	       (END-PAGE (OR (PRESS-FILE-ENDING-PAGE PRESS-FILE)
			      (1- (PRESS-FILE-NPAGES PRESS-FILE))))
	       (NUMBER-OF-PAGES (* (- END-PAGE START-PAGE)
				   (1+ (- LAST-COPY FIRST-COPY))))
	       (CURRENT-PAGE-NUMBER 0))
	  (TV:NOTING-PROGRESS ("Hardcopy: processing Press file pages")
	    (LOOP FOR *COPY* FROM FIRST-COPY TO LAST-COPY
		  AS LAST-COPY-P = (= *COPY* LAST-COPY)
		  DO (LOOP FOR PAGE FROM START-PAGE TO END-PAGE 
			   DO (PRINT-PAGE PRESS-FILE PAGE STREAM)
			      (SEND STREAM ':EJECT-PAGE
				    (AND LAST-COPY-P (= PAGE END-PAGE)))
			      (INCF CURRENT-PAGE-NUMBER)
			      (TV:NOTE-PROGRESS CURRENT-PAGE-NUMBER NUMBER-OF-PAGES)
			      ))))))))

;;; Perhaps this is mainly for debugging press file formatters.
(DEFUN READ-PRESS-FILE-DATA-STRUCTURE (FILE-NAME)
  (WITH-OPEN-FILE (STREAM (FS:MERGE-PATHNAMES FILE-NAME (FS:DEFAULT-PATHNAME () () :PRESS))
			    :DIRECTION :IN
			    :CHARACTERS NIL
			    :BYTE-SIZE (GET :PRESS :BINARY-FILE-BYTE-SIZE))
    (READ-PRESS-FILE STREAM)))

(DEFUN DISPLAY-PRESS-FILE (FILE-NAME)
  (HARDCOPY-FILE FILE-NAME (GET-WINDOW-HARDCOPY-DEVICE) :FORMAT :PRESS))

(DEFUN READ-PRESS-FILE (INPUT-STREAM)
  (FLET ((CHECK-PRESS-FILE-LENGTH (STREAM LENGTH)
	   (COND ((ZEROP LENGTH)
		  (FERROR "The press file ~a is empty!" (SEND STREAM ':PATHNAME)))
		 ((NOT (ZEROP (\ LENGTH 256.)))
		  (FERROR "Length of ~A is not an integral number of records: this is not a press file."
			  (SEND STREAM ':PATHNAME))))))
    ;; Press files are really 16-bit files, but in alto/pdp-10 byte order.
    (WITH-OPEN-STREAM (STREAM INPUT-STREAM)
      (LET ((RAW-LENGTH (SEND STREAM :LENGTH))
	    (PRESS-FILE))
	;; Some streams can figure out what the length is, and some can't (e.g. TCP FTP).
	;; +++ Really now, joseph.  An aversion to PROGN is one thing, this use of TYPECASE another.
	(TYPECASE RAW-LENGTH
	  (:NUMBER
	    (LET ((LENGTH (// RAW-LENGTH 2)))
	      (CHECK-PRESS-FILE-LENGTH STREAM LENGTH)
	      (SETQ PRESS-FILE (MAKE-PRESS-FILE LENGTH LENGTH
						PATHNAME (SEND STREAM ':PATHNAME)
						:MAKE-ARRAY (:LENGTH LENGTH :TYPE 'ART-16B)))
	      (SYS:WITH-STACK-ARRAY (8BIT RAW-LENGTH :TYPE 'ART-8B :DISPLACED-TO PRESS-FILE)
		(MULTIPLE-VALUE-BIND (NIL EOF-P)
		    (SEND STREAM :STRING-IN "Unexpected EOF" 8BIT)
		  (IGNORE EOF-P)		;---verify somehow?
		  ))
	      ;; exchange the bytes
	      (LET ((16BIT PRESS-FILE))		;for array-register decl
		(DECLARE (SYS:ARRAY-REGISTER 16BIT))
		(DOTIMES (I LENGTH)
		  (SETF (AREF 16BIT I)
			(LET ((N (AREF 16BIT I)))
			  (DPB (LDB (BYTE 8 0) N)
			       (BYTE 8 8)
			       (LDB (BYTE 8 8) N))))))
	      #+This-is-the-old-simple-code
	      (LOOP FOR I FROM 0 BELOW LENGTH
		    DO (ASET (DPB (SEND STREAM ':TYI) (BYTE 8. 8.) (SEND STREAM ':TYI))
			     PRESS-FILE I))))
	  (:NULL
	    (SETQ PRESS-FILE (MAKE-PRESS-FILE LENGTH 0
					      PATHNAME (SEND STREAM ':PATHNAME)
					      :MAKE-ARRAY (:LENGTH 0 :TYPE 'ART-16B))
		  RAW-LENGTH 0)
	    (LOOP WITH (UPPER LOWER ELEMENT) DO
	      (SETQ UPPER (SEND STREAM :TYI))
	      (IF UPPER (INCF RAW-LENGTH) (RETURN))
	      (SETQ LOWER (SEND STREAM :TYI))
	      (IF LOWER (INCF RAW-LENGTH) (RETURN))
	      (SETQ ELEMENT (DPB UPPER (BYTE 8 8) LOWER))
	      (IF (\ RAW-LENGTH 256.)
		  (ARRAY-PUSH-EXTEND PRESS-FILE ELEMENT 256.)
		  (ASET ELEMENT PRESS-FILE (// RAW-LENGTH 2))))
	    (SETF (PRESS-FILE-LENGTH PRESS-FILE) (// RAW-LENGTH 2))
	    (CHECK-PRESS-FILE-LENGTH STREAM (PRESS-FILE-LENGTH PRESS-FILE))))
	(DECODE-DOCUMENT-DIRECTORY PRESS-FILE)
	PRESS-FILE))))

(DEFVAR *STARTING-PAGE* NIL)
(DEFVAR *ENDING-PAGE* NIL)

(DEFUN DECODE-DOCUMENT-DIRECTORY (PRESS-FILE &AUX IDX PARTS)
  (LET ((LEN (PRESS-FILE-LENGTH PRESS-FILE)))
    (SETQ IDX (- LEN 256.))
    (LET ((PASS (AREF PRESS-FILE IDX)))
      (UNLESS (= PASS 27183.)
	(FERROR "Incorrect password ~D. instead of ~D.,
The supposed press file ~A does not correctly adhere to the press file format."
		PASS 27183. (PRESS-FILE-PATHNAME PRESS-FILE))))
    (UNLESS (= LEN (* 256. (AREF PRESS-FILE (1+ IDX))))
      (FERROR "Record length mismatch in press file ~S." PRESS-FILE)))
  (LET ((NPARTS (AREF PRESS-FILE (+ IDX 2))))
    (SETQ PARTS (MAKE-ARRAY NPARTS))
    (DECODE-PART-DIRECTORY PRESS-FILE (* (AREF PRESS-FILE (+ IDX 3)) 256.)
			   PARTS NPARTS)
    (SETF (PRESS-FILE-PARTS PRESS-FILE) PARTS)
    (LOOP FOR I FROM 0 BELOW NPARTS
	  WITH FONT-DIR = NIL AND NPAGES = 0
	  AS PART = (AREF PARTS I)
	  WHEN (TYPEP PART 'FONT-DIRECTORY)
	  DO (AND FONT-DIR (FERROR NIL "More than one font directory in ~S" PRESS-FILE))
	     (SETQ FONT-DIR PART)
	  WHEN (LISTP PART)
	  DO (INCF NPAGES)
	  FINALLY (SETF (PRESS-FILE-NPAGES PRESS-FILE) NPAGES)
		  (OR FONT-DIR (FERROR NIL "No font directory in ~S" PRESS-FILE))
		  (SETF (PRESS-FILE-FONT-DIRECTORY PRESS-FILE) FONT-DIR)))
  (SETF (PRESS-FILE-FIRST-COPY PRESS-FILE) (EXTEND-16B-NUMBER (AREF PRESS-FILE (+ IDX 8.))))
  (SETF (PRESS-FILE-LAST-COPY PRESS-FILE) (EXTEND-16B-NUMBER (AREF PRESS-FILE (+ IDX 9.))))
  (LET ((PAGE (EXTEND-16B-NUMBER (AREF PRESS-FILE (+ IDX 10.)))))
    (AND (MINUSP PAGE) (SETQ PAGE NIL))
    (SETF (PRESS-FILE-STARTING-PAGE PRESS-FILE) (OR *STARTING-PAGE* PAGE)))
  (LET ((PAGE (EXTEND-16B-NUMBER (AREF PRESS-FILE (+ IDX 11.)))))
    (AND (MINUSP PAGE) (SETQ PAGE NIL))
    (SETF (PRESS-FILE-ENDING-PAGE PRESS-FILE) (OR *ENDING-PAGE* PAGE)))
  (SETF (PRESS-FILE-PRINTING-MODE PRESS-FILE)
	(EXTEND-16B-NUMBER (AREF PRESS-FILE (+ IDX 12.))))
  (SETF (PRESS-FILE-FILE-NAME PRESS-FILE) (DECODE-BCPL-STRING PRESS-FILE (+ IDX 200)))
  (SETF (PRESS-FILE-USER-NAME PRESS-FILE) (DECODE-BCPL-STRING PRESS-FILE (+ IDX 232)))
  (SETF (PRESS-FILE-CREATION-DATE PRESS-FILE)
	(TIME:PARSE-UNIVERSAL-TIME (DECODE-BCPL-STRING PRESS-FILE (+ IDX 252))))
  PRESS-FILE)

(DEFUN EXTEND-16B-NUMBER (N)
  (IF (BIT-TEST 100000 N)
      (- N 200000)
      N))

;;; Altos are high end firsters
(DEFUN DECODE-BCPL-STRING (PRESS-FILE STARTING-IDX)
  (LOOP WITH IDX = (* STARTING-IDX 2)
	WITH LEN = (SWABBED-AREF PRESS-FILE IDX)
	WITH STRING = (MAKE-ARRAY LEN ':TYPE 'ART-STRING)
	FOR I FROM 0 BELOW LEN
	DO (ASET (CODE-CHAR (SWABBED-AREF PRESS-FILE (SETQ IDX (1+ IDX)))) STRING I)
	FINALLY (RETURN STRING)))

(DEFUN SWABBED-AREF (ARRAY INDEX)
  ;; This used to be (ldb (if ...) ...) which couldn't open-code the ldb.  Now it can.
  (let ((n (AREF ARRAY (LSH INDEX -1))))
    (IF (BIT-TEST INDEX 1)
	(LDB (BYTE 8. 0.) n)
	(LDB (BYTE 8. 8.) n))))

(DEFUN DECODE-PART-DIRECTORY (PRESS-FILE IDX PARTS NPARTS)
  (LOOP FOR I FROM 0 BELOW NPARTS
	AS IDX = IDX THEN (+ IDX 4)
	DO (ASET (FUNCALL (SELECTOR (AREF PRESS-FILE IDX) =
			    (0 #'DECODE-PRINTED-PAGE)
			    (1 #'DECODE-FONT-DIRECTORY)
			    (OTHERWISE (FERROR NIL "Unknown part type ~D"
					       (AREF PRESS-FILE IDX))))
			  PRESS-FILE (* (AREF PRESS-FILE (1+ IDX)) 256.)
			  (* (AREF PRESS-FILE (+ IDX 2)) 256.)
			  (AREF PRESS-FILE (+ IDX 3)))
		 PARTS I)))

(DEFUN DECODE-FONT-DIRECTORY (PRESS-FILE START-IDX LENGTH IGNORE)
  (LET ((FONT-DIRECTORY (MAKE-FONT-DIRECTORY)))
    (LOOP WITH END = (+ START-IDX LENGTH)
	  AS IDX = START-IDX THEN (+ IDX LEN)
	  UNTIL ( IDX END)
	  AS LEN = (AREF PRESS-FILE IDX)
	  UNTIL (ZEROP LEN)
	  AS FONT-AND-SET = (AREF PRESS-FILE (1+ IDX))
	  AS FONT-SET = (LDB (BYTE 8. 8.) FONT-AND-SET)
	  AND FONT = (LDB (BYTE 8. 0.) FONT-AND-SET)
	  WHEN ( FONT-SET (ARRAY-ACTIVE-LENGTH FONT-DIRECTORY))
	  DO (ADJUST-ARRAY-SIZE FONT-DIRECTORY (1+ FONT-SET))
	     (SETF (FONT-DIRECTORY-NSETS FONT-DIRECTORY) (1+ FONT-SET))
	  AS DIR = (OR (AREF FONT-DIRECTORY FONT-SET)
		       (ASET (MAKE-FONT-SET-DIRECTORY) FONT-DIRECTORY FONT-SET))
	  WHEN ( FONT (ARRAY-ACTIVE-LENGTH DIR))
	  DO (ADJUST-ARRAY-SIZE DIR (1+ FONT))
	  DO (SETF (FONT-SET-DIRECTORY-NFONTS DIR) (MAX (FONT-SET-DIRECTORY-NFONTS DIR)
							(1+ FONT)))
	     (ASET (MAKE-FONT-ENTRY (DECODE-BCPL-STRING PRESS-FILE (+ IDX 3))
				    (LDB (BYTE 8. 8.) (AREF PRESS-FILE (+ IDX 15)))
				    (AREF PRESS-FILE (+ IDX 16))
				    (AREF PRESS-FILE (+ IDX 17)))
		   DIR FONT))
    (LET ((FONT-LIST NIL))
      (LOOP FOR SET-NO BELOW (FONT-DIRECTORY-NSETS FONT-DIRECTORY) DOING
	(LET ((SET (AREF FONT-DIRECTORY SET-NO)))
	  (WHEN SET
	    (LET ((INDEXING-TABLE (MAKE-ARRAY (FONT-SET-DIRECTORY-NFONTS SET))))
	      (LOOP FOR FONT-NO BELOW (FONT-SET-DIRECTORY-NFONTS SET) DOING
		(LET ((FONT (AREF SET FONT-NO)))
		  (WHEN FONT
		    (LET ((INDEX (FIND-POSITION-IN-LIST-EQUAL FONT FONT-LIST)))
		      (WHEN (NULL INDEX)
			(SETQ INDEX (LENGTH FONT-LIST))
			(SETQ FONT-LIST (NCONC FONT-LIST (NCONS FONT))))
		      (ASET INDEX INDEXING-TABLE FONT-NO)))))
	      (SETF (FONT-SET-DIRECTORY-MAPPING-TABLE SET) INDEXING-TABLE)))))
      (SETF (FONT-DIRECTORY-FONT-LIST FONT-DIRECTORY) FONT-LIST))
    FONT-DIRECTORY))

(DEFUN DECODE-PRINTED-PAGE (PRESS-FILE START-IDX SIZE PADDING-LENGTH)
  (LOOP WITH ENTITIES
	FOR IDX = (+ START-IDX (- SIZE PADDING-LENGTH 1)) THEN (- IDX LEN)
	AS LEN = (AREF PRESS-FILE IDX)
	WHEN (ZEROP LEN)
	RETURN ENTITIES
	AS TYPE-AND-SET = (AREF PRESS-FILE (- IDX 11.))
	AS EL-LEN = (- LEN 12.)
	DO (PUSH (MAKE-ENTITY TYPE (LDB (BYTE 8. 8.) TYPE-AND-SET)
			      FONT-SET (LDB (BYTE 8. 0.) TYPE-AND-SET)
			      DATA-START (+ (PRESS-32B-NUMBER PRESS-FILE (- IDX 10.))
					    (* START-IDX 2))
			      DATA-LENGTH (PRESS-32B-NUMBER PRESS-FILE (- IDX 8))
			      X (EXTEND-16B-NUMBER (AREF PRESS-FILE (- IDX 6)))
			      Y (EXTEND-16B-NUMBER (AREF PRESS-FILE (- IDX 5)))
			      BB-LEFT (EXTEND-16B-NUMBER (AREF PRESS-FILE (- IDX 4)))
			      BB-BOTTOM (EXTEND-16B-NUMBER (AREF PRESS-FILE (- IDX 3)))
			      BB-WIDTH (EXTEND-16B-NUMBER (AREF PRESS-FILE (- IDX 2)))
			      BB-HEIGHT (EXTEND-16B-NUMBER (AREF PRESS-FILE (1- IDX)))
			      COMMAND-START (* (- IDX 11. EL-LEN) 2)
			      COMMAND-LENGTH (* EL-LEN 2)
			      )
		 ENTITIES)))

(DEFUN PRESS-32B-NUMBER (PRESS-FILE IDX)
  (DPB (AREF PRESS-FILE IDX) (BYTE 16. 16.) (AREF PRESS-FILE (1+ IDX))))

(DEFUN GET-PRESS-FILE-FONTS (PRESS-FILE)
  (FONT-DIRECTORY-FONT-LIST (PRESS-FILE-FONT-DIRECTORY PRESS-FILE)))


(DEFUN MAKE-ENTITY-COMMAND-TABLE (&AUX ARRAY)
  (SETQ ARRAY (MAKE-ARRAY 400))
  (LOOP FOR I FROM 0 BELOW 40
	DO (ASET 'SHOW-CHARACTERS-SHORT ARRAY I))
  (LOOP FOR I FROM 40 BELOW 100
	DO (ASET 'SKIP-CHARACTERS-SHORT ARRAY I))
  (LOOP FOR I FROM 100 BELOW 140
	DO (ASET 'SHOW-CHARACTERS-AND-SKIP ARRAY I))
  (LOOP FOR I FROM 140 BELOW 150
	DO (ASET 'SET-SPACE-X-SHORT ARRAY I))
  (LOOP FOR I FROM 150 BELOW 160
	DO (ASET 'SET-SPACE-Y-SHORT ARRAY I))
  (LOOP FOR I FROM 160 BELOW 200
	DO (ASET 'FONT ARRAY I))
  (LOOP FOR I FROM 200 BELOW 240
	DO (ASET 'AVAILABLE ARRAY I))
  (LOOP FOR I FROM 240 TO 352
	DO (ASET 'SPARE ARRAY I))
  (LOOP FOR I FROM 353 TO 377
	FOR X IN '(;;353			354	    355
		   SKIP-CONTROL-BYTES-IMMEDIATE ALTERNATIVE ONLY-ON-COPY
		   ;;356 357   360	       361	       362
		   SET-X SET-Y SHOW-CHARACTERS SKIP-CHARACTERS SKIP-CONTROL-BYTES
		   ;;363		    364		365	    366
		   SHOW-CHARACTER-IMMEDIATE SET-SPACE-X SET-SPACE-Y RESET-SPACE
		   ;;367 370		371	372	       373	   374
		   SPACE SET-BRIGHTNESS SET-HUE SET-SATURATION SHOW-OBJECT SHOW-DOTS
		   ;;375	    376		   377
		   SHOW-DOTS-OPAQUE SHOW-RECTANGLE NOP
		   )
	DO (ASET X ARRAY I))
  ;;***
  (ASET 'SHOW-LINE ARRAY 201)
  ARRAY)

(DEFVAR *ENTITY-COMMAND-TABLE* (MAKE-ENTITY-COMMAND-TABLE))

(DEFUN PRINT-PAGE (PRESS-FILE *PAGE-NO* STREAM)
  (LOOP FOR TEM BEING THE ARRAY-ELEMENTS OF (PRESS-FILE-PARTS PRESS-FILE)
	WITH N = -1
	WHEN (AND (LISTP TEM) ( (SETQ N (1+ N)) *PAGE-NO*))
	DO (LOOP FOR ENTITY IN TEM
		 DO (PRINT-ENTITY PRESS-FILE ENTITY STREAM))
	   (RETURN T)
	FINALLY (FERROR NIL "Page number out of range ~D" *PAGE-NO*)))

(DEFVAR *FONT-TABLE*)
(DEFVAR *FONT-NO*)
(DEFVAR *ENTITY-X*)
(DEFVAR *ENTITY-Y*)
(DEFVAR *DATA-INDEX*)
(DEFVAR *COMMAND-INDEX*)
(DEFUN PRINT-ENTITY (PRESS-FILE ENTITY STREAM)
  (LET ((*FONT-TABLE* (FONT-SET-DIRECTORY-MAPPING-TABLE
			(AREF (PRESS-FILE-FONT-DIRECTORY PRESS-FILE)
			      (ENTITY-FONT-SET ENTITY)))))
    (SEND STREAM ':SET-FONT (AREF *FONT-TABLE* 0))
    (LOOP WITH *FONT-NO* = 0
	  AND *ENTITY-X* = (ENTITY-X ENTITY)
	  AND *ENTITY-Y* = (ENTITY-Y ENTITY)
	  WITH *DATA-INDEX* = (ENTITY-DATA-START ENTITY)
	  AND *COMMAND-INDEX* = (ENTITY-COMMAND-START ENTITY)
	  WITH END-INDEX = (+ *COMMAND-INDEX* (ENTITY-COMMAND-LENGTH ENTITY))
	  AS COMMAND-NO = (SWABBED-AREF PRESS-FILE *COMMAND-INDEX*)
	  AS COMMAND = (AREF *ENTITY-COMMAND-TABLE* COMMAND-NO)
	  DO (INCF *COMMAND-INDEX*)
	  AS ARG = (SELECTQ (GET COMMAND 'ARG-TYPE)
		     (:NONE NIL)
		     (:SHORT (1+ (LDB (BYTE 5. 0.) COMMAND-NO)))
		     (:FONT (LDB (BYTE 4. 0.) COMMAND-NO))
		     (:BYTE (SWABBED-AREF PRESS-FILE (PROG1 *COMMAND-INDEX*
							    (INCF *COMMAND-INDEX*))))
		     (:WORD (PROG1 (POSSIBLY-SWABBED-16B-WORD PRESS-FILE *COMMAND-INDEX*)
				   (INCF *COMMAND-INDEX* 2)))
		     (:EXTENDED-WORD (PROG1 (EXTEND-16B-NUMBER
					      (POSSIBLY-SWABBED-16B-WORD PRESS-FILE
									 *COMMAND-INDEX*))
					    (INCF *COMMAND-INDEX* 2))))
	  DO (FUNCALL (GET COMMAND 'ENTITY-COMMAND) PRESS-FILE ARG STREAM)
	  UNTIL ( *COMMAND-INDEX* END-INDEX))))

(DEFUN POSSIBLY-SWABBED-16B-WORD (PRESS-FILE INDEX)
  (IF (NOT (BIT-TEST 1 INDEX))
      (AREF PRESS-FILE (LSH INDEX -1))
      (DPB (SWABBED-AREF PRESS-FILE INDEX) (BYTE 8. 8.)
	   (SWABBED-AREF PRESS-FILE (1+ INDEX)))))

(DEFPROP SET-X :EXTENDED-WORD ARG-TYPE)
(DEFUN (SET-X ENTITY-COMMAND) (PRESS-FILE X STREAM)
  PRESS-FILE
  (SEND STREAM ':SET-CURSORPOS (+ X *ENTITY-X*) NIL ':MICAS))

(DEFPROP SET-Y :EXTENDED-WORD ARG-TYPE)
(DEFUN (SET-Y ENTITY-COMMAND) (PRESS-FILE Y STREAM)
  PRESS-FILE
  (SEND STREAM ':SET-CURSORPOS NIL (+ Y *ENTITY-Y*) ':MICAS))

(DEFPROP SHOW-CHARACTERS :BYTE ARG-TYPE)
(DEFPROP SHOW-CHARACTERS PRINT-NCHARS ENTITY-COMMAND)

(DEFVAR *DIAGRAM-ESCAPE-FUNCTIONS* ()
  "If non-null, it is a list of functions which take three args (PRESS-FILE NCHARS STREAM).
   Each function checks the text string.  If it finds its escape sequence, it processes
   the text (drawing a diagram?) and returns non-NIL; otherwise, return NIL.  No functions
   are called after the first to return non-NIL.")

(DEFUN PRINT-NCHARS (PRESS-FILE NCHARS STREAM)
  (OR (AND *DIAGRAM-ESCAPE-FUNCTIONS*
	   (LOOP FOR FUNCTION IN *DIAGRAM-ESCAPE-FUNCTIONS*
		 WHEN (FUNCALL FUNCTION PRESS-FILE NCHARS STREAM)
		   DO (INCF *DATA-INDEX* NCHARS)
		      (RETURN T)))
      (LOOP FOR I FROM 0 BELOW NCHARS
	    AS CH = (CODE-CHAR (SWABBED-AREF PRESS-FILE (PROG1 *DATA-INDEX* (INCF *DATA-INDEX*))))
	    DO (SEND STREAM ':TYO CH))))

;;;Check whether the strings /prefix/ and /suffix/ inclusively surround some text.
;;;If so, return that text in a new string.  This is for use of diagram-escape-functions.
(DEFUN DIAGRAM-ESCAPED-NAME (PREFIX SUFFIX PRESS-FILE NCHARS)
  (LET* ((PREFIX-LEN (STRING-LENGTH PREFIX))
	 (SUFFIX-LEN (STRING-LENGTH SUFFIX))
	 (BOTHFIX-LEN (+ PREFIX-LEN SUFFIX-LEN)))
    (WHEN (AND (> NCHARS BOTHFIX-LEN)
	       (LOOP FOR I BELOW PREFIX-LEN
		     ALWAYS (= (SWABBED-AREF PRESS-FILE (+ *DATA-INDEX* I))
			       (AREF PREFIX I)))
	       (LOOP FOR I FROM (1- SUFFIX-LEN) DOWNTO 0
		     FOR J = (+ *DATA-INDEX* NCHARS -1) THEN (1- J)
		     ALWAYS (= (SWABBED-AREF PRESS-FILE J)
			       (AREF SUFFIX I))))
      (LOOP WITH STRING = (MAKE-ARRAY (- NCHARS BOTHFIX-LEN) :TYPE 'ART-STRING)
	    FOR I BELOW (- NCHARS BOTHFIX-LEN)
	    FOR J FROM (+ *DATA-INDEX* PREFIX-LEN)
	    DO (SETF (AREF STRING I) (CODE-CHAR (SWABBED-AREF PRESS-FILE J)))
	    FINALLY (RETURN STRING)))))

(DEFPROP SHOW-CHARACTER-IMMEDIATE :BYTE ARG-TYPE)
(DEFUN (SHOW-CHARACTER-IMMEDIATE ENTITY-COMMAND) (PRESS-FILE CH STREAM)
  PRESS-FILE
  (SEND STREAM ':TYO (CODE-CHAR CH)))

(DEFPROP SKIP-CHARACTERS :BYTE ARG-TYPE)
(DEFPROP SKIP-CHARACTERS SKIP-NCHARS ENTITY-COMMAND)
(DEFUN SKIP-NCHARS (PRESS-FILE NCHARS STREAM)
  PRESS-FILE STREAM
  (INCF *DATA-INDEX* NCHARS))

(DEFPROP SKIP-CONTROL-BYTES :WORD ARG-TYPE)
(DEFUN (SKIP-CONTROL-BYTES ENTITY-COMMAND) (PRESS-FILE NCHARS STREAM)
  PRESS-FILE STREAM
  (INCF *DATA-INDEX* NCHARS)
  (INCF *COMMAND-INDEX*))

(DEFPROP SKIP-CONTROL-BYTES-IMMEDIATE :BYTE ARG-TYPE)
(DEFUN (SKIP-CONTROL-BYTES-IMMEDIATE ENTITY-COMMAND) (PRESS-FILE NCHARS STREAM)
  PRESS-FILE STREAM
  (INCF *COMMAND-INDEX* NCHARS))

(DEFPROP FONT :FONT ARG-TYPE)
(DEFUN (FONT ENTITY-COMMAND) (PRESS-FILE FONT STREAM)
  PRESS-FILE
  (SEND STREAM ':SET-FONT (AREF *FONT-TABLE* FONT)))

(DEFPROP SET-SPACE-X :WORD ARG-TYPE)
(DEFPROP SET-SPACE-Y :WORD ARG-TYPE)
(DEFUN (SET-SPACE-X ENTITY-COMMAND) (IGNORE WIDTH STREAM)
  (SEND STREAM ':SET-SPACE-WIDTH (SEND STREAM ':MICAS-TO-DEVICE-UNITS WIDTH ':HORIZONTAL)))

(DEFPROP RESET-SPACE :NONE ARG-TYPE)
(DEFUN (RESET-SPACE ENTITY-COMMAND) (IGNORE IGNORE STREAM)
  (SEND STREAM ':UPDATE-SPACE-WIDTH))

(DEFPROP SPACE :NONE ARG-TYPE)

(DEFPROP SET-BRIGHTNESS :BYTE ARG-TYPE)
(DEFPROP SET-HUE :BYTE ARG-TYPE)
(DEFPROP SET-SATURATION :BYTE ARG-TYPE)

(DEFPROP SHOW-OBJECT :WORD ARG-TYPE)

(DEFPROP SHOW-RECTANGLE :NONE ARG-TYPE)
(DEFUN (SHOW-RECTANGLE ENTITY-COMMAND) (PRESS-FILE IGNORE STREAM &AUX WIDTH HEIGHT)
  (SETQ WIDTH (POSSIBLY-SWABBED-16B-WORD PRESS-FILE *COMMAND-INDEX*))
  (SETQ WIDTH (SEND STREAM ':MICAS-TO-DEVICE-UNITS WIDTH ':HORIZONTAL))
  (INCF *COMMAND-INDEX* 2)
  (SETQ HEIGHT (POSSIBLY-SWABBED-16B-WORD PRESS-FILE *COMMAND-INDEX*))
  (SETQ HEIGHT (SEND STREAM ':MICAS-TO-DEVICE-UNITS HEIGHT ':VERTICAL))
  (INCF *COMMAND-INDEX* 2)
  (SEND STREAM ':SHOW-RECTANGLE WIDTH HEIGHT))

(DEFPROP SHOW-LINE :NONE ARG-TYPE)
(DEFUN (SHOW-LINE ENTITY-COMMAND) (PRESS-FILE IGNORE STREAM &AUX NEW-X NEW-Y)
  (SETQ NEW-X (+ *ENTITY-X* (POSSIBLY-SWABBED-16B-WORD PRESS-FILE *COMMAND-INDEX*)))
  (SETQ NEW-X (SEND STREAM ':MICAS-TO-DEVICE-UNITS NEW-X ':HORIZONTAL))
  (INCF *COMMAND-INDEX* 2)
  (SETQ NEW-Y (+ *ENTITY-Y* (POSSIBLY-SWABBED-16B-WORD PRESS-FILE *COMMAND-INDEX*)))
  (SETQ NEW-Y (SEND STREAM ':MICAS-TO-DEVICE-UNITS NEW-Y ':VERTICAL))
  (INCF *COMMAND-INDEX* 2)
  (SEND STREAM ':SHOW-LINE NEW-X NEW-Y))

(DEFPROP SHOW-DOTS :NONE ARG-TYPE)
(DEFPROP SHOW-DOTS-OPAQUE :NONE ARG-TYPE)
(DEFPROP ALTERNATIVE :NONE ARG-TYPE)

(DEFPROP ONLY-ON-COPY :BYTE ARG-TYPE)

(DEFPROP NOP :NONE ARG-TYPE)
(DEFUN (NOP ENTITY-COMMAND) (&REST IGNORE))

(DEFPROP SHOW-CHARACTERS-SHORT :SHORT ARG-TYPE)
(DEFPROP SHOW-CHARACTERS-SHORT PRINT-NCHARS ENTITY-COMMAND)

(DEFPROP SKIP-CHARACTERS-SHORT :SHORT ARG-TYPE)
(DEFPROP SKIP-CHARACTERS-SHORT SKIP-NCHARS ENTITY-COMMAND)

(DEFPROP SHOW-CHARACTERS-AND-SKIP :SHORT ARG-TYPE)
(DEFUN (SHOW-CHARACTERS-AND-SKIP ENTITY-COMMAND) (PRESS-FILE NCHARS STREAM)
  (PRINT-NCHARS PRESS-FILE NCHARS STREAM)
  (INCF *DATA-INDEX*))

(DEFPROP SET-SPACE-X-SHORT :SHORT ARG-TYPE)
(DEFPROP SET-SPACE-Y-SHORT :SHORT ARG-TYPE)

