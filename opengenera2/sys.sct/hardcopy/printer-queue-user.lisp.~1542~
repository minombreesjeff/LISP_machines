D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;;-*- Mode: LISP; Syntax: Common-Lisp; Package: Print ; Base: 10.; Lowercase: Yes; -*-
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

1;;; Define the error flavors for the printer-queue protocol.  These errors are originally
;;; signalled in the printer-queue server, are caught by that server, decomposed into a
;;; form that can be sent across the network, sent to the user, reconstituted, and re-signalled
;;; in the user machine.

;;; All errors defined below must support this method.
0(defgeneric(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") error-variables-and-values0 (error) (:method-combination :append))

1;;; All flavors defined in the protocol should have an entry of the form
;;;   (three-letter-code flavor)
;;; in this list.
0(defvar 2*printer-queue-protocol-error-flavors* 0nil)
1;;; The following macro may be useful:
;;; +++ Someday make this remove duplicates
0(defmacro 2define-three-letter-code0 (code flavor)
  `(push '(,code ,flavor) *printer-queue-protocol-error-flavors*))
(defun flavor-from-three-letter-code (code)
  (second (assoc code *printer-queue-protocol-error-flavors* :test #'string-equal)))

1;;; All the errors defined in the protocol are built on this.
0(defflavor 2printer-queue-protocol-error
0	(three-letter-code)
	(error)
  :readable-instance-variables
  :initable-instance-variables
  (:required-init-keywords :three-letter-code)
  (:required-methods error-variables-and-values))

(defflavor 2network-related-error0 () (printer-queue-protocol-error))

(defflavor 2network-lossage
0	(description)
	(network-related-error)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "NET"))

(define-three-letter-code "NET" 2network-lossage0)

(defmethod 2(error-variables-and-values network-lossage)0 ()
  `(:description ,description))

(defmethod 2(:report network-lossage)0 (stream)
  (format stream "Problems with the network~@[: ~*~A" description))

(compile-flavor-methods 2network-lossage0)

(defflavor 2not-logged-in
0	(user)
	(network-related-error)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "NLI"))

(define-three-letter-code "NLI" 2not-logged-in0)

(defmethod 2(error-variables-and-values not-logged-in)0 ()
  `(:user ,user))

(defmethod 2(:report not-logged-in)0 (stream)
  (format stream "User ~A is not logged in." user))

(compile-flavor-methods 2not-logged-in0)

(defflavor 2no-such-data-channel
0	(data-channel)
	(network-related-error)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "NSD"))

(define-three-letter-code "NSD" 2no-such-data-channel0)

(defmethod 2(error-variables-and-values no-such-data-channel)0 ()
  `(:data-channel ,data-channel))

(defmethod 2(:report no-such-data-channel)0 (stream)
  (format stream "No data channel with handle ~A exists." data-channel))

(compile-flavor-methods 2no-such-data-channel0)

(defflavor 2misc-errors0 () (printer-queue-protocol-error))

(defflavor 2queue-not-accepting-requests
0	(reason)
	(misc-errors)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "QNA"))

(define-three-letter-code "QNA" 2queue-not-accepting-requests0)

(defmethod 2(error-variables-and-values queue-not-accepting-requests)0 ()
  `(:reason ,reason))

(defmethod 2(:report queue-not-accepting-requests)0 (stream)
  (format stream "The queue is not accepting requests because ~A." reason))

(compile-flavor-methods 2queue-not-accepting-requests0)

(defflavor 2no-more-room
0	()
	(misc-errors)
  (:default-init-plist :three-letter-code "NMR"))

(define-three-letter-code "NMR" 2no-more-room0)

(defmethod 2(error-variables-and-values no-more-room)0 ()
  ())

(defmethod 2(:report no-more-room)0 (stream)
  (format stream "The printer queue manager is out of room."))

(compile-flavor-methods 2no-more-room0)


(defflavor 2bad-something-value-error
0	(value)
	(printer-queue-protocol-error)
  :initable-instance-variables)

(defmethod 2(error-variables-and-values bad-something-value-error)0 ()
  `(:value value))

(defmacro 2define-bad-something-value-error0 (something three-letter-code)
  (let ((something-flavor (intern (string-append "BAD-" (string something) "-VALUE"))))
    `(progn
       (defflavor ,something-flavor
	       (,something)
	       (bad-something-value-error)
	 :initable-instance-variables
	 (:default-init-plist :three-letter-code ,three-letter-code))
       (define-three-letter-code ,three-letter-code ,something-flavor)
       (defmethod (error-variables-and-values ,something-flavor) ()
		  `(,',(intern (string something) "") ,,something))
       (defmethod (:report ,something-flavor) (stream)
	 (format stream ,(string-append "The value of the \"~A\" "
					(string-downcase (string something))
					", ~A, was bad.")
		 ,something value))
       (compile-flavor-methods ,something-flavor))))

(define-bad-something-value-error 2characteristic0 "BCH")
(define-bad-something-value-error 2constraint0 "BCO")
(define-bad-something-value-error 2page-spec0 "BPG")
(define-bad-something-value-error 2property0 "BPR")

(defflavor2 bad-reason-value
0	(reason)
	(bad-something-value-error)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "BRE"))

(define-three-letter-code "BRE" 2bad-reason-value0)

(defmethod 2(error-variables-and-values bad-reason-value)0 ()
  `(:reason ,reason))

(defmethod 2(:report bad-reason-value)0 (stream)
  (format stream "\"~A\" is not an acceptable reason." reason))

(compile-flavor-methods 2bad-reason-value0)



(defflavor 2unknown-something-error0 () (printer-queue-protocol-error))

(defmacro2 define-unknown-something-error0 (something three-letter-code)
  (let ((something-flavor (intern (string-append "UNKNOWN-" (string something)))))
    `(progn
       (defflavor ,something-flavor
	       (,something)
	       (unknown-something-error)
	 :initable-instance-variables
	 (:default-init-plist :three-letter-code ,three-letter-code))
       (define-three-letter-code ,three-letter-code ,something-flavor)
       (defmethod (error-variables-and-values ,something-flavor) ()
		  `(,',(intern (string something) "") ,,something))
       (defmethod (:report ,something-flavor) (stream)
	 (format stream ,(string-append "The "
					(string-downcase (string something))
					" \"~A\" is not recognized by this server.")
		 ,something))
       (compile-flavor-methods ,something-flavor))))
  
(define-unknown-something-error 2characteristic0 "UCH")
(define-unknown-something-error 2command0 "UCM")
(define-unknown-something-error 2constraint0 "UCO")
(define-unknown-something-error 2disposition0 "UDI")
(define-unknown-something-error 2extent0 "UEX")
(define-unknown-something-error 2property0 "UPR")
(define-unknown-something-error 2urgency0 "UUR")

1;;; The following need some special tweaks the macro-produced versions can't hack.

0(defflavor 2unknown-printer
0	(printer)
	(unknown-something-error)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "UPI"))

(define-three-letter-code "UPI" 2unknown-printer0)

(defmethod 2(error-variables-and-values unknown-printer)0 ()
  `(:printer ,printer))

(defmethod 2(:report unknown-printer)0 (stream)
  (format stream "The printer ~A is not managed by this server." (send printer :pretty-name)))

(compile-flavor-methods 2unknown-printer0)

(defflavor 2unknown-page-spec
0	(page-spec-type page-spec-value)
	(unknown-something-error)
  :initable-instance-variables
  (:default-init-plist :three-letter-code "UPG"))

(define-three-letter-code "UPG" 2unknown-page-spec0)

(defmethod 2(error-variables-and-values unknown-page-spec)0 ()
  `(:page-spec-type ,page-spec-type :page-spec-value ,page-spec-value))

(defmethod 2(:report unknown-page-spec)0 (stream)
  (format stream "The page spec type ~A (with value ~A) is not recognized by this server."
	  page-spec-type page-spec-value))

(compile-flavor-methods 2unknown-page-spec0)



(defflavor 2queue-entry-error
0	(entry)
	(printer-queue-protocol-error)
  :readable-instance-variables
  :initable-instance-variables)

(defmethod 2(error-variables-and-values queue-entry-error)0 ()
  `(:entry ,entry))

(defmacro2 define-queue-entry-error0 (error three-letter-code format-string)
  `(progn
     (defflavor ,error
	     ()
	     (queue-entry-error)
       (:default-init-plist :three-letter-code ,three-letter-code))
     (define-three-letter-code ,three-letter-code ,error)
     (defmethod (:report ,error) (stream)
       (format stream ,format-string entry))
     (compile-flavor-methods ,error)))

(define-queue-entry-error 2entry-not-found0 "ENF"
  "Attempt to manipulate entry ~A, which is not in the print queue.")
(define-queue-entry-error 2entry-is-printing0 "EIP"
  "Attempt to intervene in progress of entry ~A, but entry is being printed.")
(define-queue-entry-error 2entry-not-printing0 "ENP"
  "Attempt to intervene in progress of entry ~A, but entry was not printing at the time.")
(define-queue-entry-error2 entry-receiving-data0 "ERD"
  "Attempt to write data portion of request ~A, but data portion is already being written.")1;;; Ripped from the NFILE user side.
0(define-queue-entry-error 2channel-refuses-to-free0 "CWF"
  "Attempted to free data channel for request ~A, but timed out. Server hung.")



1;;; This section comprises templates of request-properties, queue policies, and
;;; device characteristics.

0(defvar2 *request-properties*0 nil)

(defflavor2 request-property
0	(name
	 type
	 description
	 default-value
	 format-arg)
	()
  :readable-instance-variables
  :initable-instance-variables)

(compile-flavor-methods 2request-property0)

(defmacro 2define-request-property0 (name type description default-value &optional format-arg types)
  (let ((option-types (or types '(:spooler))))
    `(let* ((old-entry (assoc ',name *request-properties*))
	    (new-rprop (make-instance 'request-property
				      :name ,name
				      :type ',type
				      :description ,description
				      :default-value ,default-value
				      :format-arg (or ,format-arg "~A")))
	    (new-entry (list ,name new-rprop)))
       (when (record-source-file-name ,name 'define-request-property)
	 (when old-entry
	   (setq *request-properties* (delete old-entry *request-properties*)))
	 (push new-entry *request-properties*)
	 (hci:define-hardcopy-option ,name ,description ,default-value . ,option-types)))))

(format:defformat format:printer-pretty-name (:one-arg) (printer parms)
  (ignore parms)
  (format format:*format-output* (send (net:find-object-named :printer printer) :pretty-name)))

1;;; These four are "derived" properties, set by the printer queue server.
0(define-request-property2 :printer0            string  "Printed on"       "" "~\\printer-pretty-name\\")
(define-request-property 2:spool-file-name0    string  "Stored as"        "")
(define-request-property 2:state0              string  "In state"         nil)
(define-request-property 2:qid0                string  "Request ID"       "")
(define-request-property 2:queue-entry-time0   integer "Queued at"        0 "~\\time\\")
1;;; These are specified by the client when the request is created, or defaulted
;;; by hardcopy:make-hardcopy-stream.
0(define-request-property 2:title0              string  "Title"            "unnamed request" nil (:formatter :spooler))
(define-request-property 2:recipient 0         string  "For"              '(send si:*user* :personal-name-first-name-first))
(define-request-property 2:copies0             integer "Number of copies" 1 "~D" (:formatter :spooler))
(define-request-property 2:requestor-user-id0  string  "Requested by"     'zl:user-id)
(define-request-property2 :requestor-host0     string  "Requested from"	;Zmail maybe not loaded
	                                     '(or (send-if-handles net:*local-host* :mail-name)
						  (let ((primary-name
							  (send net:*local-host*
								:primary-name)))
						    (if (stringp primary-name)
							primary-name
						      (send primary-name :string)))))
(define-request-property 2:notify-requestor 0  boolean ""                 t "~:[False~;True~]")
(define-request-property2 :print-cover-pages0  boolean ""                 t "~:[False~;True~]")
(define-request-property 2:data-creation-date0 (or integer null)
					             "Data created at"  '(time:get-universal-time) "~\\time\\" (:formatter :spooler)) 
1;;; +++ I don't think these will be fully implemented for 7.0.
0(define-request-property 2:page-count0         integer "Page count"       0)
(define-request-property2 :forms0              string  "Forms"            "std")
(define-request-property 2:stock0              string  "Paper stock"      "std")

(defun 2defined-request-properties0 ()
  (loop for (name nil) in *request-properties* collect name))

(defun2 get-request-property-template0 (property)
  (loop for (name template) in *request-properties*
	when (eq name property) do (return template)
	finally (return nil)))

(defun2 get-request-property-default-value0 (property)
  (let ((template (get-request-property-template property)))
    (eval (request-property-default-value template))))



(defvar2 *queue-policy-templates*0 nil)

(defflavor 2queue-policy-template
0	(name
	 type
	 description
	 default-value)
	()
  :readable-instance-variables
  :initable-instance-variables)

(compile-flavor-methods2 queue-policy-template0)

(defmacro2 define-queue-policy0 (name type description default-value)
  `(let* ((old-entry (assoc ',name *queue-policy-templates*))
	  (new-qpt (make-instance 'queue-policy-template
				  :name ,name
				  :type ',type
				  :description ,description
				  :default-value ,default-value))
	  (new-entry (list ,name new-qpt)))
     (when (record-source-file-name ,name 'define-queue-policy)
       (when old-entry
	 (setq *queue-policy-templates* (delete old-entry *queue-policy-templates*)))
       (push new-entry *queue-policy-templates*))))

(define-queue-policy2 :page-limit0 integer "Page count" 10000)

(defun2 defined-queue-policies0 ()
  (loop for (name) in *queue-policy-templates* collect name))

(defun 2get-queue-policy-template 0(policy)
  (loop for (name template) in *queue-policy-templates*
	when (eq name policy) do (return template)
	finally (error 'unknown-constraint :constraint policy)))



(defvar2 *printer-characteristic-templates*0 nil)

(defflavor 2printer-characteristic-template
0	(name
	 type
	 description
	 default-value)
	()
  :readable-instance-variables
  :initable-instance-variables)

(compile-flavor-methods2 printer-characteristic-template0)

(defmacro 2define-printer-characteristic0 (name type description default-value)
  `(let* ((old-entry (assoc ',name *printer-characteristic-templates*))
	  (new-dc (make-instance 'printer-characteristic-template
				 :name ,name
				 :type ',type
				 :description ,description
				 :default-value ,default-value))
	  (new-entry (list ,name new-dc)))
     (when (record-source-file-name ,name 'define-printer-characteristic)
       (when old-entry
	 (setq *printer-characteristic-templates* (delete old-entry *printer-characteristic-templates*)))
       (push new-entry *printer-characteristic-templates*))))

(defun2 defined-printer-characteristics0 ()
  (loop for (name) in *printer-characteristic-templates* collect name))

(defun2 get-printer-characteristic-template0 (characteristic)
  (loop for (name template) in *printer-characteristic-templates*
	when (eq name characteristic) do (return template)
	finally (error 'unknown-characteristic :characteristic characteristic)))



(defflavor 2printer-queue-user-data-channel
0	(printer-queue-user
	 (handle nil)
	 (unsafe nil)
	 (in-use nil)
	 stream					; token list stream
	 data-stream				; token list data stream
	 (last-touched-time (get-universal-time))	; for the data channel stream
	 (async-error nil))
	()
  (:readable-instance-variables printer-queue-user handle unsafe in-use stream data-stream)
  (:writable-instance-variables unsafe in-use last-touched-time async-error)
  (:initable-instance-variables printer-queue-user handle stream data-stream)
  (:conc-name data-chan-))

(defflavor2 printer-queue-user
0	((printer nil)
	 (control-stream nil)
	 (last-touched-time (get-universal-time)) ; for the control stream
	 (data-channels nil)
	 (max-data-connections-reached nil)
	 (lock (process:make-lock "Printer Queue Lock" :recursive t))
	 (response-lock (process:make-lock "Printer Queue Response Lock"))
	 service-access-path
	 (responses nil)
	 (control-stream-read (get-universal-time))
	 (control-stream-read-error nil)
	 (user-process-needs-to-read-error nil))
	()
  (:writable-instance-variables last-touched-time)
  (:initable-instance-variables printer  service-access-path)
  (:required-init-keywords     :printer :service-access-path))

(defvar2 *printer-queue-users-for-required-polling*0 nil)

(defmethod 2(:reset printer-queue-user)
0	   (&optional dont-unlock-lock-p (reason "Printer queue user reset"))
  (when control-stream
    (send control-stream ':close-with-reason reason t)
    (setq control-stream nil))
  (without-interrupts
    (setf *printer-queue-users-for-required-polling*
	  (delete self *printer-queue-users-for-required-polling*)))
  (setf responses nil)
  (process:reset-lock response-lock)
  (loop for data-channel in data-channels
	as stream  = (data-chan-stream data-channel)
	do (send stream :close-with-reason reason t))
  (setf data-channels nil)
  (setf max-data-connections-reached nil)
  (unless dont-unlock-lock-p
    (fs:unregister-for-file-connection-scavenger self)
    (process:reset-lock lock)))

;; Verify that connection is still open
(defmethod2 (:test-connections printer-queue-user)0 ()
  (and (send self :test-control-stream)
       (loop for data-channel in data-channels
	     always (send (data-chan-stream data-channel) :connected-p))))

(defmethod 2(:test-control-stream printer-queue-user)0 ()
  (and control-stream
       (send control-stream :connected-p)))

;;; Lock a printer-queue-user around BODY
(defmacro 2lock-printer-queue-user-self0 (&body body)
  `(process:with-lock (lock)
     ,@body))

;;; Check that connection hasn't gone away, making a new one if necessary
(defmethod2 (:validate-control-stream printer-queue-user)0 (&optional no-error-p)
  (lock-printer-queue-user-self
    (setf last-touched-time (get-universal-time))
    (or (send self :test-connections)
	(let ((stream nil))
	  (send self :reset t)			;Arg of T means don't unlock lock
	  (condition-case-if no-error-p ()
	       (setf stream (net:get-connection-for-service service-access-path :token-list t))
	     (net:connection-error nil)
	     (:no-error
	       (setf control-stream stream)
	      (setf user-process-needs-to-read-error nil)
	      (setf control-stream-read-error nil)
	      (fs:register-for-file-connection-scavenger self
							 #'(lambda () (send self :scavenge)))
	      (without-interrupts
		(push self *printer-queue-users-for-required-polling*))
	      t))))))

;;; Get a data channel for this unit.  Makes a new one if none are free.
;;; Prefer ones not needing resynchronization.
(defmethod 2(:get-data-channel printer-queue-user)0 ()
  (block got-data-channel
    (lock-printer-queue-user-self
      (and (not max-data-connections-reached)
	   (let ((channel
		   (loop for i below 3
			 ;;0 for ones not needing resync
			 ;;1 for ones even needing resync
			 ;;2 for make new ones.
			 thereis
			 (loop for data-channel in data-channels
			       when
			       (and (null (data-chan-in-use data-channel)) ;not in use
				    (if (send (data-chan-stream data-channel) :connected-p)
					t
					(setf data-channels
					      (delete data-channel data-channels))
					nil)
				    (or (> i 0) (not (data-chan-unsafe data-channel))))
			       return (progn
					;;Mark as allocated
					(setf (data-chan-in-use data-channel) t)
					data-channel))
			 do (selector i =
			      (0 )
			      (1 (condition-case ()
				     (send self :new-data-connection)
				   (fs:file-error	;really want something better here....
				     (setq max-data-connections-reached t)
				     (return-from got-data-channel nil))))
			      (2 (zl:ferror "Failed to allocate data connection for ~A" self))))))
	     ;; Do some initialization for fresh use.
	     (setf (data-chan-async-error channel) nil)
	     ;; Unspring beartraps
	     (send (data-chan-stream channel) :set-output-exception nil)
	     ;;; The file-connection scavenger is supposed to resynchronize unsafe
	     ;;; DC's if it can grab the lock when he gets ambitious.  If he hasn't
	     ;;; we can do it, too.
	     (send (data-chan-data-stream channel) :discard-current-output-buffer)
	     (when (data-chan-unsafe channel)
	       (send self :resynchronize-data-channel channel))
	     (return-from got-data-channel channel))))))

(defmethod 2(:queue-entry-free-data-channel printer-queue-user)0 (data-channel &optional leave-unsafe)
  (lock-printer-queue-user-self
    (setf (data-chan-last-touched-time data-channel) (get-universal-time))
    (send self :simple-command :queue-entry-free-data-channel "Free data channel"
	  (data-chan-handle data-channel))
    (if (or (not leave-unsafe)
	    (eq (data-chan-unsafe data-channel) :clean-error))
	(setf (data-chan-unsafe data-channel) nil))
    (setf (data-chan-in-use data-channel) nil)))

(defflavor2 0data-channel2-data-stream
0	(data-channel)
	(si:unsigned-byte-8-with-character-output-mixin
	 neti:token-list-output-data-stream)
  (:writable-instance-variables data-channel))

(compile-flavor-methods data-channel2-data-stream0)

;;; Allocate a new data connection
(defmethod2 (:new-data-connection printer-queue-user)0 ()
  (let* ((handle (fs:file-gensym "U"))
	 (id (first (send self :command
			  :queue-entry-create-data-channel
			  "New Data Connection" nil handle)))
	 (stream (send control-stream
		       :start-open-auxiliary-stream t
		       :foreign-id id
		       :stream-options '(:token-list t)))
	 (data-stream (make-instance 'data-channel-data-stream :raw-stream stream))	 
	 (data-channel (make-instance 'printer-queue-user-data-channel
				      :printer-queue-user self
				      :handle handle
				      :stream stream
				      :data-stream data-stream)))
    ;; such language!
    (setf (data-channel-data-stream-data-channel data-stream) data-channel)
    (send stream :complete-connection)
    (without-interrupts
      (push data-channel data-channels))))

;;; Called by scavenger
(defmethod2 (:close-data-connection printer-queue-user)0 (data-channel)
  ;; Called locked, otherwise meaningless.
  (send self :simple-command
	:queue-entry-free-data-channel
	"Close Data Connection"
	(data-chan-handle data-channel))
  (send (data-chan-stream data-channel) :close-with-reason "Delete Data Channel" t)
  (setq data-channels (delete data-channel data-channels)))

(defmethod2 (:resynchronize-data-channel printer-queue-user)0 (data-channel)
  (let ((resync-identifier (fs:file-gensym "UDCRSY")))
    (let ((tid (send self :asynchronous-command-start
		     :queue-entry-resynchronize-data-channel
		     nil			; whostate
		     nil			; handle
		     (data-chan-handle data-channel) resync-identifier)))
      (send (data-chan-stream data-channel) :send-token-list "DATA-CHANNEL-RESYNC-DUMMY" t)
      (send (data-chan-stream data-channel) :send-token-list `("RESYNCHRONIZE" ,resync-identifier) t)
      (send (data-chan-stream data-channel) :force-output)
      (send self :asynchronous-command-wait tid
	    :resynchronize-data-channel "Resync Data Channel" nil)))
  (setf (data-chan-unsafe data-channel) nil))

(defflavor 2request-data-stream
0	(qid
	 data-stream)
	()
  :initable-instance-variables)

(defmethod 2(:unclaimed-message request-data-stream)0 (message &rest args)
  (apply data-stream message args))

(defmethod2 (:element-type request-data-stream)0 () '(unsigned-byte 8))

(defmethod 2(:stream-supports-multiple-copies request-data-stream)0 () t)

(defmethod 2(:string-out request-data-stream)0 (string &optional (start 0) end)
  (send data-stream :string-out string start end))

;;; Prevent the stream from being closed; just send an EOF instead.  It's the responsibility
;;; of the scavenger to get rid of data channels and their associated data-streams.
(defmethod 2(:close request-data-stream)0 (&optional abort-p)
  (unless abort-p
    (send data-stream :force-output))
  (send (send data-stream :raw-stream) :send-token-list :eof)
  (unless abort-p
    (send (send data-stream :raw-stream) :finish))
  (let* ((data-channel (data-channel-data-stream-data-channel data-stream))
	 (printer-queue-user (data-chan-printer-queue-user data-channel)))
    (send printer-queue-user :queue-entry-free-data-channel data-channel)))

(defmethod2 (:which-operations request-data-stream)0 ()
  (si:eliminate-duplicates (append '(:stream-supports-multiple-copies :close)
				    (send data-stream :which-operations))))

(compile-flavor-methods 2request-data-stream0)

(defmethod 2(:set-data-channel-request printer-queue-user)0 (data-channel qid)
  (send self :command :queue-entry-set-data-channel-request "Set Request" nil (data-chan-handle data-channel) qid)
  (make-instance 'request-data-stream :qid qid :data-stream (data-chan-data-stream data-channel)))


;;; The response reader

(defvar2 *printer-queue-response-reader*
0	(let ((proc (make-process "Printer Queue Response Reader")))
	  (process:enable-process-flag proc :system-process)
	  proc))

(defun2 initialize-printer-queue-response-reader0 ()
  (without-interrupts
    (process-preset *printer-queue-response-reader* 'printer-queue-response-reader-top-level)
    (process:process-enable *printer-queue-response-reader*)))

(defmethod2 (:process-control-input-from-server printer-queue-user)0 (response)
  (si:destructuring-bind (response-name response-tid . response-args) response
    (case response-name
      (:notification (tv:notify
		       nil (format nil "From Printer Queue server: ~A" (car response-args))))
      (:async-error
       ;;TID is really a file handle.
       (send self :set-async-error response-tid response-args))
      (otherwise
	(loop for qel on responses
	      ;; They can only queue in front of us, and only we can dequeue ourself,
	      ;; and anyone who we miss because he threads out doesn't matter.
	      as qcell = (car qel)
	      when (string-equal (car qcell) response-tid)
	      return (setf (cdr qcell) response)
	      finally
	      (zl:ferror "Printer Queue response for transaction ~A.  No such pending transaction."
		      response-tid))))))		;f.s.f.

(defmethod2 (:read-and-process-control-stream printer-queue-user)0 ()
  ;; Note that there is a lock inside :read-token-list such that it is an atomic operation.
  (let ((datum (send control-stream :read-token-list nil :no-message)))
    (setq control-stream-read (get-universal-time))
    (cond ((eq datum :no-message) nil)
	  (t (send self :process-control-input-from-server datum)
	     t))))

(defmethod 2(:read-response-for-interrupt printer-queue-user)0 ()
  (loop while (null control-stream-read-error)
	do
	(condition-case (err)
	    (when (null (send self :read-and-process-control-stream))
	      ;;could lose in window, or have no more
	      (return nil))
	  (neti:token-io-unsafe
	    ;; We do it entirely in this process, no control responses to be read.
	    (condition-case (err)
		(send self :resynchronize-control-channel)
	      (error (setq control-stream-read-error err))))
	  (error
	    (setq control-stream-read-error err)))))

(defmethod 2(:control-input-listen printer-queue-user)0 ()
  (and control-stream
       (null control-stream-read-error)
       (send control-stream :listen)))

(defun 2printer-queue-response-reader-condition0 ()
  (loop for server-unit in *printer-queue-users-for-required-polling*
	thereis (send server-unit :control-input-listen)))

(defun2 printer-queue-response-reader-top-level0 ()
  (let ((last-time (zl:time)))
    (loop doing
      (let* ((now (zl:time))
	     (interval (time-difference now last-time)))
	(setf last-time now)
	(loop for server-unit in *printer-queue-users-for-required-polling*
	      do (ignore-errors
		   (when (send server-unit :control-input-listen)
		     (send server-unit :read-response-for-interrupt))))
	;; this tries to poll frequently when there's stuff going on, and only once per second
	;; otherwise. It's pretty gross.  Either I should provide primitives for this sort of
	;; polling, or else I should convert this to event driven completely (but I don't want
	;; to understand that much about the printer queue).
	(if *printer-queue-users-for-required-polling*
	    (process:process-block-and-poll-wait-function
	      "Printer Queue Reader Wait"
	      (max process::*process-wait-interval* (min (/ interval 120.0) 1.))
	      #'(lambda (time-to-adjust-rate)
		  (or (null *printer-queue-users-for-required-polling*)
		      (when time-to-adjust-rate
			(time-lessp time-to-adjust-rate (sys:%microsecond-clock)))
		      (printer-queue-response-reader-condition)))
	      (when (< interval 60.)
		(sys:%32-bit-plus (sys:%microsecond-clock) (* 16666. 5. interval))))
	    (process:process-block-and-poll-wait-function
	      "Printer Queue Reader Wait"
	      ;; otherwise, once a second seems fine.
	      1.
	      #'printer-queue-response-reader-condition))))))



;;; Commands

(defmethod 2(:command printer-queue-user)0 (&rest data)
  (send self :send-in-command-condition-environment :send-and-wait-for-command data))

(defmethod 2(:asynchronous-command-start printer-queue-user)0 (&rest data)
  (send self :send-in-command-condition-environment :send-command data))

(defmethod 2(:asynchronous-command-wait printer-queue-user)0 (&rest tid-cons-args)
  (send self :send-in-command-condition-environment :wait-for-command tid-cons-args))

(defmethod 2(:send-in-command-condition-environment printer-queue-user)0 (message data)
  (catch 'command-result    
    (loop doing
      (condition-case ()
	   (return (send self message data))
	 (neti:token-io-unsafe
	   (send self :resynchronize-control-channel))
	 (neti:mark-seen
	   ;; Mark-seen here is deep confusion.  The server should not be
	   ;; generating marks we didn't ask for.
	   ;; (unless somebody aborted during a blast-to-all-servers-- to be coded)
	   ;; Perhaps treat it as another
	   ;; provocation for resynchronization? (same as TOKEN-IO-UNSAFE?)
	   (zl:ferror "Mark seen during Printer Queue control channel interaction."))))))

(defmethod 2(:resynchronize-control-channel printer-queue-user)0 ()
  (flet ((read-cc-for-cc-resync-id (stream identifier mark-p)
	   (let ((what-i-read (send stream :read-token-list mark-p)))
	     (and (listp what-i-read)
		  (equal (car what-i-read) identifier)))))
    (lock-printer-queue-user-self
      (let ((resync-identifier "USER-RESYNC-DUMMY"))	;user ctrl chan resynchronize
	(send control-stream :send-token-list resync-identifier t)	;mark-p
	;; Gotta send 2.  See comments in server side.
	(setq resync-identifier (fs:file-gensym "UCCRSY"))
	(send control-stream :send-token-list (list resync-identifier) t)
	(loop do
	  (condition-case ()
	       (when (read-cc-for-cc-resync-id control-stream resync-identifier t)
		 (return t))
	     (neti:mark-seen
	       ;; Next read should not be condition-cased.
	       ;; There is NO REASON why it should not be a complete transmission.
	       ;; The server does not ever recoverably abort.
	       (when (read-cc-for-cc-resync-id control-stream resync-identifier nil)
		 (return t)))))))))

(defmethod2 (:send-command printer-queue-user)0 (data)
  (destructuring-bind (command-name whostate handle . command-args) data
    (ignore whostate handle)
    (let ((tid (fs:file-gensym "T")))
      ;;Enqueue a wait-element.
      (loop with qcell = (cons tid nil)
	    with qel = (cons qcell nil)
	    as qcont = responses
	    do (rplacd qel responses)
	    until (store-conditional (locf responses) qcont qel))
      
      ;; Send the command.
      (with-stack-list* (command command-name tid command-args)
	(send control-stream :send-token-list command))
      
      tid)))
    
(defmethod2 (:send-and-wait-for-command printer-queue-user)0 (data)
  (destructuring-bind (command-name whostate data-channel . command-args) data
    (ignore command-args)
    (when data-channel
      (setf (data-chan-unsafe data-channel) command-name))
    (let ((command-tid (send self :send-command data)))
      (with-stack-list (pseudoargs command-tid command-name whostate data-channel)
	(send self :wait-for-command pseudoargs)))))

(defmethod 2(:wait-for-printer-queue-response printer-queue-user)0 (tid whostate)
  (loop with qel = (loop for qe on responses
			 ;; Perhaps immorally using EQ here..
			 when (eq (caar qe) tid)
			   return qe
			 finally (zl:ferror "Printer Queue TID ~A not found in TID queue." tid))
	do (if user-process-needs-to-read-error
	       (send self :read-and-process-control-stream)
	       (progn
		 (process-wait whostate #'(lambda () (or (cdar qel)
							 control-stream-read-error)))
		 (if control-stream-read-error
		     (setf user-process-needs-to-read-error t))))
	when (cdar qel)
	  return (dequeue-printer-queue-response response-lock
						(zl:variable-location responses)
						qel)))

;; This is based on the true fact that the enqueuer only enqueues in the front.
(defun 2dequeue-printer-queue-response0 (lockp qhloc qel)
  (process:with-lock (lockp)
    (loop do
      (catch 'retry
	(loop for prevptr first qhloc
	      ;; We know these conses aren't CDR-coded, so we can
	      ;; develop locatives to their CDR's even though the language
	      ;; doesn't really like it.
			  then (zl:%make-pointer zl:dtp-locative (1+ (zl:%pointer (cdr prevptr))))
	      while prevptr
	      finally (zl:ferror "Printer Queue response queue element ~S not found in queue?"
				 qel)
	      when (eq (cdr prevptr) qel)
		do
	  ;; Some guy might have threaded in in the FRONT.
		  (unless (store-conditional prevptr qel (cdr qel))
		    (throw 'retry nil))
		  (return-from dequeue-printer-queue-response (cdar qel))
	      while (cdr prevptr))))))

(defun-in-flavor (2resignal-printer-queue-error0 2printer-queue-user0) (response-args)
  (destructuring-bind (three-letter-code init-options message) response-args
    (cond ((string-equal three-letter-code "MSC")
	   ;; Apparently this passes its useful information via message.
	   ;; Apparently the error-signalling protocol normally ignores
	   ;; message.  Therefore, it seems that this has to be handled
	   ;; as a special case. - DLW 15 Mar 88
	   (error "Miscellaneous error response:~%~A" message))
	  (t
	   (let ((error-flavor (flavor-from-three-letter-code three-letter-code)))
	     (apply #'signal error-flavor init-options))))))

(defmethod2 (:wait-for-command printer-queue-user)0 (tid-cons-args)
  (destructuring-bind (command-tid command-name whostate data-channel) tid-cons-args
    (destructuring-bind (response-name nil . response-args)
			(send self :wait-for-printer-queue-response command-tid whostate)
      (selector response-name eq
	(command-name
	  ;; The "good answer.."
	  (when data-channel
	    (setf (data-chan-unsafe data-channel) :command-in-progress))
	  (throw 'command-result response-args))
	;; The "bad answer.."
	(:error
	 ;; A solid error, we can say for sure that
	 ;; the data channel is safe, and was not allocated by the server.
	 (when data-channel
	   (setf (data-chan-unsafe data-channel) :clean-error))
	 (resignal-printer-queue-error response-args))
	(otherwise
	  ;; The "Zippy answer..."
	  (zl:ferror "Printer Queue Command for TID ~A was ~A, but response is for ~A?"
		  command-tid command-name response-name))))))

;;; This is NOT the condition that the user sees...
;;; It is based on DBG:DEBUGGER-CONDITION so that we get a blowout as opposed to a
;;; coverup if it should in fact be signalled uncaught.
(defflavor2 printer-queue-user-output-exception0 ()
	   (dbg:debugger-condition))

(defmethod 2(:report printer-queue-user-output-exception)0 (stream)
  (format stream "The Printer Queue User-side implementation has signalled an output exception.~@
		  This is normally an internal condition only.  There is a malfunction~@
		  if this error appears visibly."))

(defmethod 2(:proceed printer-queue-user-output-exception :proceed)0 ()
  t)

(defmethod 2(:document-proceed-type printer-queue-user-output-exception :proceed)0 (report-stream)
  (format report-stream "Retry sending data to output byte stream."))

(compile-flavor-methods 2printer-queue-user-output-exception0)

(defmethod 2(:set-async-error printer-queue-user)0 (handle args)
  (loop for data-channel in data-channels
	when (string-equal handle (data-chan-handle data-channel))
	return (progn
		 (setf (data-chan-async-error data-channel) args)
		 (send (data-chan-stream data-channel) :set-output-exception
		       'printer-queue-user-output-exception))
	finally (zl:ferror "Can't find handle ~A in ~S for output exception." handle self)))

(defmethod 2(:simple-command printer-queue-user)0 (command-name whostate &rest args)
  (lexpr-send self :command command-name whostate nil args))



;;; Scavenger

;; This runs in the File Connection Scavenger process.
;; It needs to run in a real (i.e. non-simple) process because is has to PROCESS-WAIT.

(defun scavenge-printer-queue-connections (printer-queue-user data-channels-to-resync
					   data-channels-to-kill kill-printer-queue-user)
  ;; Lock has been reserved for us, use real process id so we can mylock ok.
  ;; Do data channels first, so blowing out there gets ignored if gonna kill whole server unit.
  (loop for data-channel in data-channels-to-kill do
    (ignore-errors
      (when (null (data-chan-in-use data-channel))
	(send printer-queue-user :close-data-connection data-channel))))
  (loop for data-channel in data-channels-to-resync do
    (ignore-errors
      (when (null (data-chan-in-use data-channel))
	(send printer-queue-user :resynchronize-data-channel data-channel))))
  (when kill-printer-queue-user
    (ignore-errors
      (send printer-queue-user :reset t "Printer Queue Connection Scavenge"))))

;; Keep connections for 5 minutes, then scavenge them.
;; Data channel life is 1/10th that, except if we're killing them off, then
;;   1/40th after the first one we kill.  Don't ask me, it's an NFILE policy.
(defvar *printer-queue-control-connection-timeout*              (* 15    60))
(defvar *printer-queue-data-channel-first-timeout*       (round (* 0.1   *printer-queue-control-connection-timeout*)))
(defvar *printer-queue-data-channel-additional-timeouts* (round (* 0.025 *printer-queue-control-connection-timeout*)))

(defmethod (:scavenge printer-queue-user) ()
  (lock-printer-queue-user-self
    (let ((host-active-p nil))
      (cond
	((not (send self :test-control-stream)))
	(t
	 (loop with time = (get-universal-time)
	       with kill-printer-queue-user = t
	       with first = t
	       with data-channels-to-resync = ()
	       with data-channels-to-kill = ()
	       for data-channel in data-channels
	       ;; +++ Bogus?
	       as l = (if first
			  *printer-queue-data-channel-first-timeout*
			  *printer-queue-data-channel-additional-timeouts*)
	       do (cond
		    ((and (null (data-chan-in-use data-channel))
			  (> (time-difference time (data-chan-last-touched-time data-channel)) l))
		     (setq first nil)
		     (push data-channel data-channels-to-kill))
		    (t (setq host-active-p t)
		       (when (and (not (data-chan-in-use data-channel))
				  (data-chan-unsafe data-channel))
			 (push data-channel data-channels-to-resync))))
	       finally
		 (when (or host-active-p
			   ( (time-difference time last-touched-time)
			      *printer-queue-control-connection-timeout*))
		   (setf host-active-p t)
		   (setf kill-printer-queue-user nil))
		 (when (or data-channels-to-kill data-channels-to-resync kill-printer-queue-user)
		   (scavenge-printer-queue-connections
		     self data-channels-to-resync data-channels-to-kill kill-printer-queue-user)))))
      host-active-p)))

(compile-flavor-methods 2printer-queue-user0 printer-queue-user-data-channel)

(defun printer-queue-user-init ()
  (initialize-printer-queue-response-reader))

(add-initialization "printer-queue-user-init" '(printer-queue-user-init) '(system))



1;;; This is the client agent, that acts on the user's behalf.

0(defflavor 2printer-queue-access-path
0	(printer
	 service-access-path
	 printer-queue-user)
	(su:access-path-log-mixin)
  :readable-instance-variables
  (:writable-instance-variables printer-queue-user)
  (:initable-instance-variables printer  service-access-path)
  (:required-init-keywords     :printer :service-access-path))

(defmethod2 (:unclaimed-message printer-queue-access-path)0 (message &rest args)
  (apply printer-queue-user message args))

(defmethod 2(make-instance printer-queue-access-path)0 (&rest flavor::init-options)
  (ignore flavor::init-options)
  (setf printer-queue-user (make-instance 'printer-queue-user
					 :service-access-path service-access-path
					 :printer printer)))

(defun-in-flavor2 (simple-command printer-queue-access-path)0 (command whostate &rest args)
  (declare (values list-of-results))
  (send printer-queue-user :validate-control-stream)
  (lexpr-send printer-queue-user :simple-command command whostate args))

1;;; use the following list and function when we have to go over the network

0(defvar2 *printer-queue-access-paths*0 nil)

(defun2 find-appropriate-printer-queue-access-path0 (sap)
  (let* ((host (neti:service-access-path-host sap))
	 (args (neti:service-access-path-args sap))
	 (printer (first args))
	 (pqap (loop for pqap in *printer-queue-access-paths*
		     when (and
			    (neti:ns-eq host
				      (neti:service-access-path-host
					(printer-queue-access-path-service-access-path pqap)))
			    (neti:ns-eq printer
					(printer-queue-access-path-printer pqap)))
		       do (return pqap)
		     finally (let ((new-pqap (make-instance 'printer-queue-access-path
							    :printer printer
							    :service-access-path sap)))
			       (push new-pqap *printer-queue-access-paths*)
			       (return new-pqap)))))
    (send pqap :validate-control-stream)
    pqap))



1;;; Two handy utility functions.

0(defun 2printer-string-from-printer0 (printer)
  (send (send printer :name) :qualified-string))

(defun2 printer-from-printer-string0 (printer-string)
  (net:find-object-named :printer printer-string))

(defun 2get-request-being-printed0 (hqc printer)
  ;; Take the latest request in :being-printed state.
  ;; At least that request has a chance of actually
  ;; being printed.
  (let ((request (first
		   (sort 
		     (cdr (queue-query
			    hqc
			    '(:state :being-printed)
			    '(:queue-entry-time :recipient :title :copies)))
		     #'>
		     :key #'(lambda (r) (getf (cdr r) :queue-entry-time))))))
1    ;; Make a Printer-request-for-printer object.
0    (when request `(,request ,printer))))

1;;; Implement hardcopy service over the :printer-queue protocol.  This takes care
;;; of simple hardcopy requests.

0(defmethod 2(queue-create-entry printer-queue-access-path)0 (parameters)
  (declare (values qid))
  (first (simple-command :queue-create-entry "Create Entry" parameters)))

(defmethod 2(queue-entry-create-data-channel printer-queue-access-path)0 ()
  (send printer-queue-user :validate-control-stream)
  (send printer-queue-user :get-data-channel))

(defmethod 2(queue-entry-set-data-channel-request printer-queue-access-path)0 (data-channel qid)
  (send printer-queue-user :set-data-channel-request data-channel qid))

(defun2 make-queue-entry-and-return-request-data-stream0 (sap)
  (declare (values request-data-stream))
  (let* ((args (neti:service-access-path-args sap))
	 (printer (first args))
	 (spooler-options (append (second args)
				  `(:printer ,(printer-string-from-printer printer))))
	 (pqap (find-appropriate-printer-queue-access-path sap))
	 (qid (queue-create-entry pqap spooler-options))
	 (data-channel (queue-entry-create-data-channel pqap))
	 (request-data-stream (queue-entry-set-data-channel-request pqap data-channel qid)))
    request-data-stream))

1;;; +++ Really :byte-stream-with-mark?
0(net:define-protocol2 :printer-queue0 (:hardcopy :byte-stream-with-mark)
  (:desirability 0.4)
  (:invoke make-queue-entry-and-return-request-data-stream))

(chaos:add-contact-name-for-protocol 2:printer-queue0)


(defmacro2 with-printer-queue-controllers0 ((printer-queue-access-path printer) &body body)
  `(dolist (host-access-path (stable-sort
			       (loop for host in (hci:printer-spooler-hosts ,printer)
				     as paths = (net:find-paths-to-service-on-host
						  :printer-queue-control host t)
				     when paths
				       collect (neti::most-desirable-service-access-path
						 paths))
			       #'neti:service-access-path-desirability-greaterp))
     (let ((,printer-queue-access-path (neti:invoke-service-access-path host-access-path
									(list ,printer))))
       (su:with-access-path-logging (,printer-queue-access-path)
	 ,@body))))

(define-presentation-type 2printer-request-for-printer0 ((&key printer))
   :parser ((stream &key type)
	    (values
	      (dw:completing-from-suggestions (stream :type type)
		(with-printer-queue-controllers (hqc printer)
		  (destructuring-bind ((summary-string) . requests)
		     (queue-query hqc () '(:queue-summary :recipient :title :queue-entry-time))
		    (ignore summary-string)
		    (loop for request in requests do
		      (dw:suggest (present-to-string `(,request ,printer) type)
				  `(,request ,printer))))))
	      type))
   :printer ((printer-request stream)
	     (print-printer-request printer-request stream))
   :describer ((stream &key plural-count)
	       (when (numberp plural-count)
		 (setq plural-count (> plural-count 1)))
	       (write-string (if plural-count "printer requests" "a printer request") stream)
	       (format stream " for ~a" (send printer :pretty-name))))
(defun printer-request-string (request)
  (destructuring-bind ((nil . data) nil) request
    (format nil "~A for ~A~@[ (queued at ~\\time\\)~]"
	    (getf data :title) (getf data :recipient) (getf data :queue-entry-time))))

(defun print-printer-request (request stream)
  (write-string (printer-request-string request) stream)
  request)

(define-presentation-type 2printer-request0 ()
   :parser ((stream)
	    (dw:with-presentation-input-context ('printer-request-for-printer :stream stream)
						(blip)
		 (let ((printer 
			 (accept 'sys:printer
				 :stream stream
				 :prompt nil
				 :additional-blip-chars '(#\space))))
		   (let ((delim (dw:read-char-for-accept stream)))
		     (unless (dw:compare-char-for-accept delim #\space)
		       (dw:unread-char-for-accept delim stream)
		       (cp::cp-error nil "You must supply a request for ~a"
				     (send printer :pretty-name))))
		   (let ((request (accept `((printer-request-for-printer :printer ,printer))
					  :stream stream
					  :prompt "request"
					  :inherit-context nil)))
		     request))
	       (otherwise
		 (destructuring-bind (ignore printer) (dw:presentation-blip-object blip)
		   (dw::presentation-replace-input stream (send stream :read-location)
						   (send printer :pretty-name) :dont-quote t)
		   (dw::presentation-replace-input stream (send stream :read-location) " " :dont-quote t)
		   (dw:echo-presentation-blip stream blip))
		 (dw::presentation-blip-object blip))))
   :printer ((printer-request stream)
	     (print-printer-request printer-request stream))
   :describer ((stream)
	       (write-string "a printer or printer request" stream)))

(net:define-protocol 2:printer-queue0 (:printer-queue-control :byte-stream-with-mark)
  (:invoke find-appropriate-printer-queue-access-path))

(defmethod 2(queue-query printer-queue-access-path)0 (request-pattern response-pattern)
  (declare (values request-descriptions unimplemented-responses))
  (simple-command :queue-query "Queue Query" (printer-string-from-printer printer) request-pattern response-pattern))

(defvar2 *request-state-designators*
0	'(:being-initialized     "Initializing"		; just created, not yet initialized.
	  :being-restored        "Restoring"		; being restored from stable storage
	  :data-being-received   "Receiving data"	; request data are being initialized
	  :waiting-to-be-printed "Queued"		; ready and waiting
	  :being-printed	 "Printing"		; being printed
	  :held			 "On hold"		; frozen by operator intervention
	  :deleted		 "Deleted"))

(defun 2show-printer-status-internal0 (printers)
  (when (eq printers :all)
    (setq printers (net:find-objects-from-property-list :printer :site net:*local-site*)))
  (loop for printer in printers as first-spooler-p = t do
    (condition-case (e)
	 (with-printer-queue-controllers (hqc printer)
	   (when first-spooler-p
	     (fresh-line)
	     (write-string "Status of ")
	     (present printer 'sys:printer))
	   (multiple-value-bind (request-descriptions unimplemented-responses)
	       (queue-query hqc () '(:queue-summary :state :queue-entry-time :recipient :title :copies))
	     (macrolet ((censor (response &body body)
			  `(unless (member ',response unimplemented-responses)
			     ,@body)))
	       (destructuring-bind ((summary-string) . requests) request-descriptions
		 (when first-spooler-p
		   (unless (equal summary-string "")
		     (fresh-line)
		     (write-string summary-string))
		   (setq first-spooler-p nil))
		 (fresh-line)
		 (when requests
		   (formatting-table (nil :inter-column-spacing (* 4 (send *standard-output* :character-width #\space)))
		     (formatting-column-headings (nil :underline-p t)
		       (censor :recipient
			 (formatting-cell (nil :align :center) "Recipient"))
		       (censor :queue-entry-time
			 (formatting-cell (nil :align :center) "Queued at"))
		       (censor :state
			 (formatting-cell (nil :align :center) "State"))
		       (censor :title
			 (formatting-cell (nil :align :center) "Title")))
		     (loop for request in requests do
		       (destructuring-bind (ignore . data) request
			 (let* ((state (getf data :state))
				(recipient (getf data :recipient))
				(queue-entry-time (getf data :queue-entry-time))
				(title (getf data :title))
				(copies (getf data :copies))
				(multiple-copies (> copies 1)))
			   (formatting-row ()
			     (dw:with-output-as-presentation
				 (:object `(,request ,printer)
				  :type `((printer-request-for-printer :printer ,printer))
				  :single-box t)
			       (censor :recipient
				 (formatting-cell ()
				   (write-string recipient)))
			       (censor :queue-entry-time
				 (formatting-cell ()
				   (write-string (time:print-universal-time queue-entry-time nil))))
			       (censor :state
				 (formatting-cell ()
				   (write-string (or (getf *request-state-designators* state)
						     "Unknown"))))
			       (censor :title
				 (formatting-cell ()
				   (format t "~A~:[~; (~D copies)~]"
					   title multiple-copies copies))))))))))
		 (fresh-line)))))
       1;; Well, maybe it's running Release  6.1
0       (net:host-does-not-support-service
	 (hci:print-device-status printer)
	 (terpri))
       ((hardcopy:no-spooler-for-printer sys:network-error)
	(format t "~&Error getting status of ")
	(present printer 'sys:printer)
	(write-string ": ")
	(format t "~&  ~~A~~%" e)
	(terpri))
       (:no-error
	 (terpri)))))


(cp:define-command (2show-printer-status0 :command-table "Printer"
					:provide-output-destination-keyword nil)
    ((printers '((dw::token-or-type (:all)
				    ((cl:sequence sys:printer))))
	       :prompt "printer(s)"
	       :default (when hardcopy:*default-text-printer* `(,hardcopy:*default-text-printer*))))
   (show-printer-status-internal printers))
(define-presentation-to-command-translator 2show-printer-status0 (sys:printer :gesture :select)
  (a-printer)
  `(show-printer-status (,a-printer)))

#+++ignore	;Now there is a translator from T  ((sequence T))
(dw:define-token-or-type-sequence-translators sys:printer)

zwei:
(defcom 2com-show-printer-status0 "Show the status of a spooled printer, or all spooled printers at the local site" ()
  (let ((printers (typein-line-accept '((dw::token-or-type (:all)
							   ((cl:sequence sys:printer))))
				      :prompt "Show status of printer(s)"
				      :default-type '((cl:sequence sys:printer))
				      :default (when hardcopy:*default-text-printer*
						 (list hardcopy:*default-text-printer*)))))
    1;; This is pretty gross, having to use :: for somethine defined 5 inches above...
0    (print::show-printer-status-internal printers))
  dis-none)

zwei:
(set-comtab *standard-comtab* nil (make-command-alist '(2com-show-printer-status0)))

(defmethod2 (queue-modify-entry printer-queue-access-path)0 (qid parameter value)
  (simple-command :queue-modify-entry "Modify Entry" (printer-string-from-printer printer) qid parameter value))

1;;; +++ Need command interface

0(defmethod2 (queue-delete-entry printer-queue-access-path)0 (qid)
  (simple-command :queue-delete-entry "Delete Queue Entry" (printer-string-from-printer printer) qid))

(cp:define-command (2delete-printer-request0 :command-table "Printer"
					   :provide-output-destination-keyword nil)
    ((request 'printer-request)
     &key
     (confirm '((cl:member :yes :no :mouse :if-printing))
	      :default :if-printing
	      :mentioned-default :no
	      :documentation
	      "Whether to request confirmation before deleting the request"))
   (when (cond ((eq confirm :yes)
		(yes-or-no-p "Delete ~A" (printer-request-string request)))
	       ((eq confirm :mouse)
		(tv:mouse-y-or-n-p (format nil "Delete ~A" (printer-request-string request))))
	       (t))
     (let ((qid (first (first request)))
	   (printer (second request)))
       (with-printer-queue-controllers (hqc printer)
	 (condition-case (ignore)
	      (return (queue-delete-entry hqc qid))
	    (entry-is-printing
	      (when (or (eq confirm :no)
			(dw:menu-choose '(("Reset the printer, deleting the request" :value t)
					  ("Allow the request to finish printing" :value nil))
					:prompt (format nil "The request being deleted is already printing on ~A."
							(send printer :pretty-name))))
		(condition-case (ignore)
		     (printer-reset hqc (printer-string-from-printer printer) qid :delete
				    (format nil 
					    "Printer reset by ~A to delete request."
					    si:*user*))
1		   ;; If this condition gets signalled, almost certainly it finished printing
		   ;; before the user got around to confirming that she or he wanted the printer reset.
0		   (entry-not-printing nil))))
	    (entry-not-found
	      (format t "The request has already been completed or deleted.")))))))


(define-presentation-to-command-translator
  2delete-printer-request0 (printer-request-for-printer :gesture :delete)
  (a-printer-request)
  `(delete-printer-request ,a-printer-request :confirm :mouse))



(defmethod2 (queue-query-policies printer-queue-access-path)0 ()
  (simple-command :queue-query-policies "Query Queue Policies" (printer-string-from-printer printer)))

1;;; +++ Need command interface

0(defmethod2 (queue-modify-policy printer-queue-access-path)0 (constraint value rejection)
  (simple-command :queue-modify-policy "Modify Queue Policy" (printer-string-from-printer printer) constraint value rejection))

1;;; +++ Need command interface

0(defmethod2 (printer-query-characteristics printer-queue-access-path)0 ()
  (simple-command :printer-query-characteristics "Query Printer Characteristics" (printer-string-from-printer printer)))

1;;; +++ Need command interface

0(defmethod2 (printer-modify-characteristic printer-queue-access-path)0 (characteristic value)
  (simple-command :printer-modify-characteristic "Modify Printer Characteristics" (printer-string-from-printer printer) characteristic value))

1;;; +++ Need command interface

0

(net:define-protocol2 :printer-queue0 (:printer-control :byte-stream-with-mark)
  (:invoke find-appropriate-printer-queue-access-path))

(defmacro2 with-printer-controller0 ((printer-queue-access-path printer) &body body)
  `(let* ((,printer-queue-access-path
	   (neti:invoke-service-on-host :printer-control
					(first (hci:printer-spooler-hosts ,printer))
					printer)))
     (su:with-access-path-logging (,printer-queue-access-path)
       ,@body)))

(defmethod2 (printer-restart printer-queue-access-path)0 (printer qid extent page-spec)
  (simple-command :printer-restart "Restart Printer" printer qid extent page-spec))

1;;; This is a little odd, having this request-oriented command down here among the printer
;;; commands.  It's because, for purposes of user interface, we talk about restarting
;;; requests, not restarting printers printing requests.  If memory serves, VM/370 takes
;;; the latter position.
0(cp:define-command (2restart-printer-request0 :command-table "Printer"
					    :provide-output-destination-keyword nil)
    ((printer-request `((printer-request)))
     &key
     (extent '((member :entire :copy)) :default :entire
	     :documentation "Restart the Entire request or the current Copy.
This value is only used if the request is currently being printed."
	     )
     1;; +++ Relative offsets in here someday
0     (starting-from 'number :default 0
		    :documentation "This option is currently not used."))
   (let ((qid (first (first printer-request)))
	 (printer (second printer-request)))
     (condition-case (e)
	  (with-printer-controller (hdc printer)
	    (let ((previous-state
		    (first (printer-restart
			     hdc
			     (printer-string-from-printer printer)
			     qid extent `(:abs ,starting-from)))))
	      (if previous-state
		  (case previous-state
		    (:held
		      (format t "~&The request was On Hold and is now waiting to be printed."))
		    (:being-printed
		      (if qid
			  (format t "~&The request was restarted.")
			  (format t "~&The printer was reset and the current request (if any) ~
				       was restarted.")))
		    (otherwise
		      (format t "~&The request cannot be restarted since it's ~A."
			      (getf *request-state-designators* previous-state))))
		  (format t "~&No request was being printed."))))
	((hardcopy:no-spooler-for-printer
	   entry-not-found)
	  (format t "~A" e)))))

(define-presentation-to-command-translator
  2restart-printer-request0 (printer-request-for-printer :gesture nil)
  (a-printer-request)
  `(restart-printer-request ,a-printer-request))

(defmethod 2(printer-suspend printer-queue-access-path)0 (printer qid urgency extent page-spec disposition reason)
  (simple-command :printer-suspend "Suspend printer" printer qid urgency extent page-spec disposition reason))

(cp:define-command (2halt-printer0 :command-table "Printer Maintenance"
				 :provide-output-destination-keyword nil)
    ((printer 'net::printer :default hardcopy:*default-text-printer*)
     &key
     (confirm '((boolean))
	      :default *confirm-reset-printer*
	      :prompt "Ask for confirmation"
	      :documentation
	      "Request confirmation if the printer is currently printing a request.")
     (urgency '((member :asap :after-current-request :after-next-copy))
	      :default :asap
	      :documentation
	      "Halt the printer As Soon As Possible (ASAP),
After the current request, or after the next copy of the current request
if the request involves multiple copies.
If no request is being printed, the printer will be halted ASAP."
	      )
     1;; +++ Relative offsets in here someday
0     (starting-from 'number :default 0
		    :documentation
		    "This option is currently not used.")
     (disposition
       '((member :restart :hold :delete))
       :default :hold
       :documentation
       "What disposition the request being printed should have after the printer is reset.")
     ;; scl:token-or-type doesn't list the printer requests.
     (reason 'string :default (format nil "Printer ~A halted by ~A"
				      printer
				      si:*user*)))
   (let ((specific-request nil))
     (condition-case (e)
	  (block halt-printer
	    (with-printer-controller (hqc printer)
	      (if confirm
		  (let ((request-being-printed (get-request-being-printed hqc printer)))
		    (when request-being-printed
		      (format t "~& The current request is being printed:~&~%  ")
		      (present request-being-printed `((printer-request-for-printer
							 :printer ,printer)))
		      (format t "~&~% The request will be ~A."
			      (case disposition
				(:restart "requeued")
				(:hold "put on hold for later processing")
				(:delete "deleted")))
		      (unless (yes-or-no-p "~&Do you still want to halt the printer? ")
			(return-from halt-printer (values)))
1		      ;; Pass on the request to make sure the
		      ;; printer is halted0 1only if the request is still printing.
0		      (setq specific-request request-being-printed))))
	      ;; Now perform the Halt Printer request
	      (let ((qid (first (first specific-request))))
		(printer-suspend hqc (printer-string-from-printer printer)
			     qid
			     (case urgency
			       (:asap :asap)
			       ((:after-current-request :after-next-copy)
				:after-extent))
1			     ;; Extent extracted from Urgency
0			     (case urgency
			       (:after-current-request :entire)
			       (:after-next-copy :copy)
			       (otherwise :reset))
			     `(:abs ,starting-from) disposition reason)
		)))
	(entry-not-printing
	  (format t
		  "The request is no longer being printed, hence the printer was not halted."))
	(hardcopy:no-spooler-for-printer
	  (format t "~A" e)))))

(define-presentation-to-command-translator
  2halt-printer-given-printer0 (sys:printer :gesture nil)
  (a-printer)
  `(halt-printer ,a-printer))

(define-presentation-to-command-translator
  2halt-printer-given-request 0(printer-request-for-printer :gesture nil)
  (a-printer-request)
  `(halt-printer ,(second a-printer-request)))

(defmethod 2(printer-resume printer-queue-access-path)0 (printer)
  (simple-command :printer-resume "Resume Printer" printer))

(cp:define-command (2start-printer0 :command-table "Printer Maintenance"
				  :provide-output-destination-keyword nil)
    ((printer 'net::printer :default hardcopy:*default-text-printer*))
   (condition-case (e)
	(with-printer-controller (hdc printer)
	  (printer-resume hdc (printer-string-from-printer printer)))
      (hardcopy:no-spooler-for-printer
	(format t "~A" e))))
(define-presentation-to-command-translator
  2start-printer0 (sys:printer :gesture nil)
  (a-printer)
  `(start-printer ,a-printer))

(defmethod 2(printer-reset printer-queue-access-path)0 (printer qid disposition reason)
  (simple-command :printer-reset "Reset Printer" printer qid disposition reason))

(defvar2 *confirm-reset-printer*0 t
  "Default setting for confirming reset printer command.")

(cp:define-command (2reset-printer0 :command-table "Printer Maintenance"
				      :provide-output-destination-keyword nil)
    ((printer 'net::printer :default hardcopy:*default-text-printer*)
     &key
     (confirm '((boolean))
	      :default *confirm-reset-printer*
	      :prompt "Ask for confirmation"
	      :documentation
	      "Request confirmation if the printer is currently printing a request.")
     (disposition
       '((member :restart :hold :delete))
       :default :hold
       :documentation
       "What disposition the request being printed should have after the printer is reset.")
     ;; scl:token-or-type doesn't list the printer requests.
     (reason 'string :default (format nil "Printer ~A reset by ~A"
				      printer
				      si:*user*))
     )
   (let ((specific-request nil))
     (condition-case (e)
	  (block reset-printer
	    (with-printer-controller (hqc printer)
	      (if confirm
		  (let ((request-being-printed (get-request-being-printed hqc printer)))
		    (when request-being-printed
		      (format t "~& The current request is being printed:~&~%  ")
		      (present request-being-printed `((printer-request-for-printer
							 :printer ,printer)))
		      (format t "~&~% The request will be ~A."
			      (case disposition
				(:restart "requeued")
				(:hold "put on hold for later processing")
				(:delete "deleted")))
		      (unless (yes-or-no-p "~&Do you still want to reset the printer? ")
			(return-from reset-printer (values)))
1		      ;; Pass on the request to make sure the
		      ;; printer is reset only if the request is still printing.
0		      (setq specific-request request-being-printed))))
	      ;; Now perform the Reset Printer request
	      (let ((qid (first (first specific-request))))
		(printer-reset hqc (printer-string-from-printer printer) qid
			       disposition reason))))
	(entry-not-printing
	  (format t "The request is no longer being printed, hence printer was not reset."))
	(hardcopy:no-spooler-for-printer
	  (format t "~A" e)))))

(define-presentation-to-command-translator
  2reset-printer-given-printer0 (sys:printer :gesture nil)
  (a-printer)
  `(reset-printer ,a-printer))

(define-presentation-to-command-translator
  2reset-printer-given-request 0(printer-request-for-printer :gesture nil)
  (a-printer-request)
  `(reset-printer ,(second a-printer-request)))

