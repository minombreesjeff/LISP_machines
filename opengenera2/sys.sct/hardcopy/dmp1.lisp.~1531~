;;; -*- Mode: LISP; Base: 10.; Package: dmp1; Lowercase: Yes -*-
;;; Dmp1 hardcopy stream interface.  Dmp1 protocol knowledge.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>



;;;  This file contains DMP1 support
;;;
;;; Knowledge of Dmp1 control codes etc.
(defconstant *ascii-esc* (ascii-code :esc))
(defconstant *ascii-sub* (ascii-code :sub))
(defconstant *ascii-stx* (ascii-code :stx))
(defconstant *ascii-lf* (ascii-code :lf))
(defconstant *ascii-tab* (ascii-code :tab))
(defconstant *ascii-cr* (ascii-code :cr))
(defconstant *ascii-vt* (ascii-code :vt))
(defconstant *ascii-bs* (ascii-code :bs))
(defconstant *ascii-ff* (ascii-code :ff))
(defconstant *ascii-nak* (ascii-code :nak))
(defconstant *ascii-space* (ascii-code :sp))
(defconst *escape-char* *ascii-esc*)
(defconst *two-ascii-lfs* (make-array 2 :type 'art-8b :initial-value *ascii-lf*))
(defconst *two-ascii-spaces* (make-array 2 :type 'art-8b :initial-value *ascii-space*))
(defconst *two-ascii-bs-s* (make-array 2 :type 'art-8b :initial-value *ascii-bs*))
(defconst *reverse-line-feed* (fillarray (make-array 2 :type 'art-8b)
					 `(,*escape-char* ,*ascii-lf*)))
(defconst *half-line-feed* (fillarray (make-array 2 :type 'art-8b)
				      `(,*escape-char* ,(char-code #/U))))
(defconst *reverse-half-line-feed* (fillarray (make-array 2 :type 'art-8b)
					      `(,*escape-char* ,(char-code #/D))))

;;;  Random device notes:
;;;  Enlarged mode seems to reset the margin to the right after each carriage return
;;;  Unclear how to down load cent and not signs (printed using escape Y or escape Z)
;;;  Unclear what the download limitations really are - they say 192 characters,
;;;  But codes can be anywhere from 1 to 126??

(defflavor dmp1-display-device
	()
	(si:display-device))

(defwhopper (:get-mapping dmp1-display-device) (charset character-style &optional inquiry-only)
  (ignore inquiry-only)
  (let ((spec (continue-whopper charset character-style)))
    ;; just a no-op for now
    spec))

(compile-flavor-methods dmp1-display-device)

(si:register-display-device *dmp1-printer* dmp1-display-device)
  
;; Would be nice if we could do better than this, but I don't want to
;; take up space in the downloadable font area just to flesh out this set.
;; People who really care can create their own fonts and redefine these
;; style families.
(si:define-character-style-families *dmp1-printer* si:*standard-character-set*
  '(:family :fix (:size :normal (:face :roman "dmp1-courier10"
				       :bold "dmp1-courier10b"
				       :italic "dmp1-ps10i"
				       :bold-italic "dmp1-ps10i"))
	    :heading (:size :normal (:face :roman "dmp1-ps10"
					   :bold "dmp1-ps10b"
					   :italic "dmp1-ps10i"
					   :bold-italic "dmp1-ps10i"))))

(define-hardcopy-format :dmp1
			"DMP1"
			hci::general-record-file-input-formatter
			dmp1-output-stream
			(:DMP1 "DMP1")
			8)

;;; :TIMEOUT of two minutes is initial guess at worst-case.
;;; try to deduce from 4K byte buffer size and
;;; worst-case print speed [lots of  chars].
;;; (although, I'm not sure if :TIMEOUT has any meaning for
;;; output devices.) - Munoz 7/28/89
(define-hardcopy-device :dmp1
			:bitmap-printer-p t
			:multiple-font-p t
			:display-device-type *dmp1-printer*
			:default-body-character-style '(:fix :roman :normal)
			:default-heading-character-style '(:heading :bold :normal)
			:input-formats (:dmp1)
			:output-format :dmp1
			:default-serial-interface-options ((:baud 9600.)
							   (:number-of-data-bits 8.)
							   (:xon-xoff-protocol t)
							   (:parity :even)
							   (:force-output nil)
							   (:timeout (* 60. 60. 2))
							   (:flavor dmp1-serial-stream))
			)

(compile-flavor-methods dmp1-hardcopy-file dmp1-printer)

(defmethod (:hardcopy-stream-flavor dmp1-hardcopy-device-mixin) (ignore)
  'dmp1-output-stream)

(compile-flavor-methods dmp1-hardcopy-device-mixin)

(defun reset-dmp1-device-stream (stream)
  (send stream :tyo *escape-char*)
  (send stream :tyo *ascii-cr*)
  (send stream :tyo (char-to-ascii #/P)))

(defflavor dmp1-serial-stream
	((error-recovery-in-progress nil))
	(binary-printer-serial-stream
	 ;; si:device-timeout-mixin
	 ))

(defmethod (:initialize-printer-stream dmp1-serial-stream :after) ()
  (send self :clear-input))

(defwhopper (:new-output-buffer dmp1-serial-stream) ()
  (condition-bind
    ((serial:serial-timeout
       #'(lambda (error)
	   (when (send self :listen)
	     (loop while (send self :listen) do
	       (let ((response (send self :tyi)))
		 (unless (= response *ascii-nak*)
		   (send self :report-change-of-state
			 :problem
			 (format nil
				 "Unknown response ~A (octal ~O, decimal ~D) on serial stream ~A~@
				  The serial stream timed out."
				 response response response))
		   (signal 'hardcopy:device-not-responding
			   :stimulus-description "output being sent"
			   :expected-response "an ascii NAK character"
			   :stream self
			   :printer printer)))))
	   (setq error-recovery-in-progress t)
	   (if (send self :exists-p)
	       ;; If the printer is still connected, assume paper out.
	       (progn (send self :report-change-of-state :recoverable-device-error
			    "paper out or cover open.")
		      ;; each time we continue, the timeout doubles.
		      ;; probably should be exponential to 1 hour.
		      (send error :proceed :continue))
	       (progn (send self :report-change-of-state :irrecoverable-device-error
			    "serial connection lost.")
		      (signal 'hardcopy:nonexistent-device :printer printer))))))
    (multiple-value-prog1
      (continue-whopper)
      (when error-recovery-in-progress
	(setq error-recovery-in-progress nil)
	(send self :report-change-of-state :operational "no apparent problems.")))))


(defmethod (:reset-device-stream dmp1-serial-stream) ()
  (reset-dmp1-device-stream self))

;;; ELP (parallel port) support code removed by Munoz 7/28/89

(defconstant *pins-in-printhead* 24)
(defconstant *default-baseline* 18)		; Baseline of most common builtin font.
(defconstant *default-intercharacter-spacing* 6)
(defconstant *default-vmi* 30.)
(defconstant *default-hmi* (* 2 15.))
(defconstant *rom-font-location* 0)
(defconstant *ram-font-location* 3)
(defconstant *cartridge-font-location* 1)
(defconstant *letter-resolution* 1)		; 360/inch
(defconstant *correspondence-resolution* 2)	; 180/inch
(defconstant *draft-resolution* 3)		; 120/inch
(defconstant *normal-effect* 0)
(defconstant *bold-effect* 1)
(defconstant *courier-10-font* 0)
(defconstant *prestige-elite-font* 1)
(defconstant *proportional-font* 2)
(defconstant *correspondence-font* 3)
(defconstant *draft-font* 4)
(defconstant *compressed-font* 5)
(defconst *default-rom-font* *courier-10-font*)

(defstruct (dmp1-font-byte (:type :fixnum))
  ((location #o0602)
   (resolution #o0402)
   (number #o0003)))

(defflavor dmp1-output-stream
	((page-width (fixr (* 13.25 360.)))
	 (page-height (* 11. 180.))
	 (baseline 18.)				; +++ this should be verified carefully
	 (line-height 24.)
	 (font-effect *normal-effect*)
	 (font-resolution *letter-resolution*)
	 (font-number (make-dmp1-font-byte location *rom-font-location*
					   resolution *letter-resolution*
					   number *default-rom-font*))
	 (font-baseline-offset *default-baseline*)
	 (font-proportional nil)
	 (font-intercharacter-spacing *default-intercharacter-spacing*)
	 (cr-or-lf-safe t)			; no font effect preclude use of crlf
	 (hmi *default-hmi*)			; devices hmi in 1/360ths!
	 (vmi *default-vmi*)
	 dmp1-x					; Device notion of current X
	 dmp1-y					; Device notion of current Y
	 ;; +++ Flush down-load-fonts someday, just use font-table.
	 (down-load-fonts nil)
	 (bitmap-only-p nil))
	(hardcopy-stream-page-buffering-mixin
	 hardcopy-stream-font-mixin
	 sage::sage-printer-compatibility-stream
	 hardcopy-stream-character-substitution-mixin
	 basic-hardcopy-stream)
  (:initable-instance-variables bitmap-only-p)	; Center bitmap if bitmap-only
  (:default-init-plist :print-backwards nil))

(defmethod (:init dmp1-output-stream :after) (&rest ignore)
  ;; Check for indirect RAM fonts.  We rely on the fact that any indirect RAM fonts
  ;; won't change the baseline and linespacing calculations since the nfonts-except-header
  ;; nonsense precludes any "add-font"'d fonts from being in the calculation.
  (loop for font being array-elements of font-table
	for rom-font = (fed:bfd-get font :dmp1-rom-font-address)
	for indirect-ram-font = (fed:bfd-get font :dmp1-indirect-ram-font)
	do
    (cond (rom-font)
	  (indirect-ram-font
	   (unless (loop for font being array-elements of font-table
			 thereis (eq (fed:bfd-name font) indirect-ram-font))
	     (send self :add-font indirect-ram-font)))
	  (t (if (> (length down-load-fonts) 2)
		 (ferror "Need to download font ~A, but DMP1 font RAM is full." font)
		 (push (ncons font) down-load-fonts)))))
  ;; Compute simple baseline and line height, ignoring header font
  (loop for i below (max 1 (font-table-nfonts-except-header font-table))
	as font = (aref font-table i)
	maximize (// (fed:bfd-baseline font) 2) into bl
	maximize (- (// (fed:bfd-line-spacing font) 2)
		    (// (fed:bfd-baseline font) 2)) into max-descender
	finally (setq font-baseline-offset bl
		      baseline bl
		      line-height (+ bl max-descender)))
  (send self ':initialize-device)
  (send self ':home-coordinates))

;;; Make sure devices modes and internal state variables are consistent
;;; To lessen the likelihood of being screwed by the device being in a
;;; Random state.
(defmethod (:initialize-device dmp1-output-stream) ()
  ;; +++ Why don't we do this?
  ;; (send self ':reset-device)
  (send self ':send-command (char-code #/a) *default-vmi*)
  (send self ':send-command *ascii-ff* (// (if landscape-p page-width page-height)
					  *default-vmi*))	; This actually sets TOF
  (setq font-effect 0)
  (setq font-resolution 1
	font-number 0
	font-baseline-offset *default-baseline*)
  (send self ':send-command (char-code #/#) (make-dmp1-font-byte location *rom-font-location*
						    resolution *letter-resolution*
						    number *default-rom-font*))
  (setq font-proportional nil)
  (send self ':send-command (char-code #/Q))			; Disable proportional spacing
  (setq hmi (* 2 15.))
  (send self ':send-command (char-code #/b) (// hmi 2))	; Set HMI
  (setq vmi line-height)
  (send self ':send-command (char-code #/a) vmi)		; Set VMI
  ;; Reset other random modes that might be set
  (send self ':send-command (char-code #/w) 0)		; Reset enlarged mode
  (send self ':send-command (char-code #/") 0)		; US Character set
  (send self ':send-command (char-code #/2))		; Clear all tabs
  (send output-stream :tyo *ascii-cr*)	; Clear many random modes, graphics, shadow
  (send self ':send-command (char-code #/$) 0 0)		; Make device go to X=0
  (send self ':send-command (char-code #/9))		; Set left margin here
  (send self ':send-command (char-code #//))		; Enable bidirectional printing
  (send self ':send-command (char-code #/!))		; Disable auto CR wraparound
  (send self ':send-command (char-code #/R)))		; Disable auto underscore
  
;;; Assuming the device is at the X/Y origin
;;; Set the internal state to be at device x=0,Y=0
;;; +++ Notice that in landscape mode we assume a left kern of zero.
(defmethod (:home-coordinates dmp1-output-stream) ()
  (setq dmp1-x 0
	dmp1-y 0)
  (let ((y (if landscape-p
	       (- page-width 24.)
	       (- page-height font-baseline-offset))))
    (setq device-cursor-x (if landscape-p y 0)
	  device-cursor-y (if landscape-p 0 y))))

(defmethod (:device-units-to-micas dmp1-output-stream) (quan direction)
  (// (* quan 2540.) (if (eq direction :vertical) 180. 360.)))

(defmethod (:micas-to-device-units dmp1-output-stream) (quan direction)
  (// (* quan (if (eq direction :vertical) 180. 360.)) 2540.))

(defmethod (:device-units-to-pixels dmp1-output-stream) (quan direction)
  (if (eq direction :vertical) quan (// quan 2)))

(defmethod (:pixels-to-device-units dmp1-output-stream) (quan direction)
  (if (eq direction :vertical) quan (* quan 2)))

(defmethod (:send-command dmp1-output-stream) (&rest chars)
  (send output-stream ':tyo *escape-char*)
  (loop for char in chars
	do (send output-stream ':tyo char)))

(defmethod (:send-word-low-byte-first dmp1-output-stream) (word)
  (send output-stream ':tyo (ldb (BYTE 8. 0.) word))
  (send output-stream ':tyo (ldb (BYTE 8. 8.) word)))

(defmethod (:send-word-high-byte-first dmp1-output-stream) (word)
  (send output-stream ':tyo (ldb (BYTE 8. 8.) word))
  (send output-stream ':tyo (ldb (BYTE 8. 0.) word)))

(defmethod (:character-width dmp1-output-stream) (char)
  (let ((bcd (and (< (char-code char) (fed:bfd-fill-pointer current-font))
		  (aref current-font (char-code char)))))
    (cond ((null bcd) 0)
	  (font-proportional
	   (if landscape-p
	       (or (fed:bcd-get bcd ':vertical-width) 0)
	       (fed:bcd-set-width bcd)))
	  (t
	   hmi))))


(defmethod (:set-device-cursorpos dmp1-output-stream) ()
  (let ((x (if landscape-p (- page-height cursor-y) cursor-x))
	(y (if landscape-p cursor-x cursor-y)))
    (send self ':move-to x (- (- page-height font-baseline-offset) y))
    (setq device-cursor-y cursor-y
	  device-cursor-x cursor-x)))

;;; Move to real x and y, don't update device-cursorpos
(defmethod (:move-to dmp1-output-stream) (x y)
  (setq x (max 0 x)
	y (max 0 y))
  (let ((delta-x (- x dmp1-x))
	(delta-y (- y dmp1-y)))
    (flet ((absolute-y-motion ()
	     (send self ':send-command *ascii-vt* (// y vmi))
	     (let ((remainder (\ y vmi)))
	       (if (= remainder (// vmi 2))
		   (send output-stream :string-out *half-line-feed*)
		   (send self ':send-command (char-code #/J) remainder)))))
      (cond ((zerop delta-y))
	    ((plusp delta-y)
	     (cond ((and (= delta-y vmi) cr-or-lf-safe)
		    (send output-stream :tyo *ascii-lf*))
		   ((and (= delta-y (* 2 vmi)) cr-or-lf-safe)
		    (send output-stream :string-out *two-ascii-lfs*))
		   ((= delta-y (// vmi 2))
		    (send output-stream :string-out *half-line-feed*))
		   ((<= delta-y 255.)
		    (send self ':send-command (char-code #/J) delta-y))
		   (t
		    (absolute-y-motion))))
	    (t
	     (setq delta-y (- delta-y))
	     (cond ((= delta-y vmi)
		    (send output-stream :string-out *reverse-line-feed*))
		   ((= delta-y (// vmi 2))
		    (send output-stream :string-out *reverse-half-line-feed*))
		   ((<= delta-y 255.)
		    (send self ':send-command (char-code #/j) delta-y))
		   (t
		    (absolute-y-motion))))))
    (setq dmp1-y y)
    (flet ((absolute-x-motion ()
	     (if (and (zerop x) cr-or-lf-safe nil)
		 (send output-stream :tyo *ascii-cr*)
		 (if (and (zerop (\ x hmi)) (not font-proportional))
		     (send self ':send-command *ascii-tab* (1+ (// x hmi)))
		     (send self ':send-command (char-code #/$)
			   (load-byte x 8 8) (load-byte x 0 8))))))
      (cond ((zerop delta-x))
	    ((plusp delta-x)
	     (cond ((= delta-x hmi)
		    (send output-stream :tyo *ascii-space*))
		   ((= delta-x (* 2 hmi))
		    (send output-stream :string-out *two-ascii-spaces*))
		   (t
		    (absolute-x-motion))))
	    (t
	     (setq delta-x (- delta-x))
	     (cond ((= delta-x hmi)
		    (send output-stream :tyo *ascii-bs*))
		   ((= delta-x (* 2 hmi))
		    (send output-stream :string-out *two-ascii-bs-s*))
		   (t
		    (absolute-x-motion))))))
    (setq dmp1-x x)))

;;; We could map the various strange "international" character sets here if we actually
;;; had a character set of our own that wasn't totally bogus.
;;; The cursor might be advancing a variable amount in proportional space mode...
(defmethod (:show-char dmp1-output-stream) (char)
  (let* ((charbits (char-subindex char))
	 (bcd (aref current-font charbits)))
    (when bcd
      (cond (font-proportional
	     (if (char-equal char #\space)
		 (send self ':move-to (+ dmp1-x (fed:bcd-set-width bcd)) dmp1-y)
		 (let ((left-kern (fed:bcd-left-kern bcd))
		       (raster-width (fed:bcd-raster-width bcd)))
		   (unless (zerop left-kern)
		     (send self ':move-to (max 0 (- dmp1-x left-kern)) dmp1-y))
		   (send output-stream :tyo charbits)
		   (incf dmp1-x (+ raster-width font-intercharacter-spacing))
		   (let ((right-kern (- (fed:bcd-set-width bcd)
					(- raster-width left-kern))))
		     (unless (= right-kern font-intercharacter-spacing)
		       (send self ':move-to (+ dmp1-x (- right-kern
							font-intercharacter-spacing))
			     dmp1-y))))))
	    (t
	     (send output-stream :tyo charbits)
	     (incf dmp1-x hmi)))))
  (if landscape-p
      (setq device-cursor-y (- page-height dmp1-x))
      (setq device-cursor-x dmp1-x)))

(defmethod (:eject-page dmp1-output-stream) (&optional ignore)
  (send output-stream :tyo *ascii-ff*)
  (send self ':send-command (char-code #/$) 0 0)		; Make device go to X=0
  (send self ':home-coordinates))

(defmethod (:show-line dmp1-output-stream) (x2 y2) x2 y2)

;;; This can probably share code with :show-bitmap
(defmethod (:show-rectangle dmp1-output-stream) (width height &aux new-x new-y)
  (setq new-x (+ device-cursor-x width)
	new-y (+ device-cursor-y height))
  (setq device-cursor-x new-x device-cursor-y new-y))

;;; Current protocol is for current position to be upper right, and for
;;; the cursor not to move.
;;; +++ Maybe use 90dpi mode when zoom is 2?
;;; +++ left and top not implemented yet - need hairier offsets etc.
;;; The fact that page-width and height get swapped on landscape is a crock...
;;; Note that landscape requires rotation counter clockwise, while the rotation
;;; argument rotates clockwise!!!!


;; Trying to think about this code is hard.  Suppose the original image looks like
;;
;;				top
;;		abcd efgh ijkl mnop qrst uvwx yz12 3456 
;;		ABCD EFGH IJKL MNOP QRST UVWX YZ() <>[] 
;;	left	D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")abcd efgh ijkl mnop qrst uvwx yz12 34560 .... right
;;		1ABCD EFGH IJKL MNOP QRST UVWX YZ() <>[]
0;;		abcd efgh ijkl mnop qrst uvwx yz12 3456
;;		ABCD EFGH IJKL MNOP QRST UVWX YZ() <>[]
;;   				  ...
;;			        bottom
;;
;; To print this, it first gets rotated clockwise (by the caller) to look like
;;
;;		   left
;;		..Aa 1Aa0Aa
;;		..Bb 1Bb0Bb
;;		..Cc 1Cc0Cc
;;	bottom	..Dd 1Dd0Dd  top
;;		..Ee 1Ee0Ee
;;		..Ff 1Ff0Ff
;;		..Gg 1Gg0Gg
;;		...etc...
;;		  right
;;
;; Now... the DMP1 has a 24 bit print head.  Our caller helps us a
;; little by supplying the raster as an art-8b array.  Therefore, to
;; print the screen across the page of the paper, we start at the upper
;; left, which is top-left in the above rotation.  (Ignoring zooming for
;; the moment, and assuming each character above is a byte,) The first
;; three bytes we output are a folowed by A followed by 1a0, because the
;; first byte is the type byte of the print head.  The next three are
;; b,B,1b0, followed by c,C,1c0, etc, until we get to the right hand (bottom
;; rotated).  The next "24 bit wide line" starts with 1A0,a,A.
;;
;; In the code below, 1n-over0 and 1n-down0 are the number of bytes over and
;; the number of bits down in the rotated image.  1n-over0 measures 8 bit
;; bytes.
;;
;; For zooming, hzoom and vzoom are the original (unrotated) horizontal
;; and vertical zoom factors, respectively.  Horizontal zoom is
;; relatively easy since you just repeat each 24 bit chunk hzoom times.
;; For example, with vzoom=1 and hzoom=3, the above image would get sent
;; as a,A,1a0,a,A,1a0,a,A,1a0,b,B,1b0,b,B,1b0,b,B,1b0,...
;;
;; Vertical zooming is hairier if any speed is wanted, since it is a
;; bit-wise zoom, not a byte-wise zoom.  The trick is to pre-zoom all
;; possible (256) values of each 8 bit byte, in a bit-wise fashion.  The
;; resulting 8*vzoom integer is then pulled apart into 8 bit bytes
;; (because the DMP1 is an 8 bit device).  Instead of the slowest index
;; going directly from top to bottom, it has to go in smaller pieces.
;; The 1sub-over0 variable is the fractional chunk.  What happens then is
;; that the zoomed byte is looked up by the target byte (a,A,1a0,1A0,etc.)
;; and then translated by 1sub-over.

0(defun-in-flavor (zoom-and-send-raster dmp1-output-stream)
		 (image hzoom vzoom stream real-x-origin)
  (multiple-value-bind (n-over n-down)
      (decode-raster-array image)
    (let* ((buffer-size (* n-down 3 hzoom))
	   (buffer (make-array buffer-size :type 'art-8b)))
      (labels ((begin-line (line-width-in-bits)
		 (send self ':send-command (char-code #/H))
		 (send self :send-word-low-byte-first line-width-in-bits))
	       (end-line (left-margin)
		 (send self ':send-command (char-code #/v))
		 (send output-stream :tyo *ascii-cr*)
		 (send self ':send-command (char-code #/$))
		 (send self :send-word-high-byte-first left-margin))
	       (print-line (line-width-in-bits left-margin)
		 (begin-line line-width-in-bits)
		 (if ( line-width-in-bits 0)
		     (send stream :string-out buffer))
		 (end-line left-margin)))

	(if (and (= hzoom 1) (= vzoom 1))
	    
	    ;; Easy case.
	    (loop for over from (1- n-over) downto 0 by 3 do
	      (loop with bidx = 0
		    for down below n-down do
		(loop repeat 3 for over downfrom over do
		  (setf (aref buffer bidx) (if (minusp over) 0 (raster-aref image over down)))
		  (incf bidx)))
	      (print-line n-down real-x-origin))
	    
	    ;; Not so easy case.
	    (loop with zoom-arrays = (make-array `(,vzoom 256.) :type art-8b)
		  initially (loop for raw below 256.
				  as zoomed = (loop repeat 8
						    for bit upfrom 0
						    for pos upfrom 0 by vzoom
						    sum (deposit-byte
							  0 pos vzoom
							  (- (load-byte raw bit 1))))
				  do (loop for sub-over downfrom (- vzoom 1) to 0
					   for pos downfrom (* 8 (- vzoom 1)) by 8
					   do (setf (aref zoom-arrays sub-over raw)
						    (load-byte zoomed pos 8))))
		  with over = (1- n-over)
		  with sub-over = (1- vzoom)
		  while (not (minusp over))
		  do (loop with bidx = 0
			   for down below n-down do
		       (loop repeat 3 with over = over with sub-over = sub-over do
			 (setf (aref buffer bidx)
			       (if (minusp over) 0 (aref zoom-arrays sub-over
							 (raster-aref image over down))))
			 (incf bidx)
			 (decf sub-over)
			 (when (minusp sub-over)
			   (incf sub-over vzoom)
			   (decf over)))
		       (loop repeat (* 3 (1- hzoom)) do
			 (setf (aref buffer bidx) (aref buffer (- bidx 3)))
			 (incf bidx)))
		     
		     (if (loop for bidx below buffer-size thereis ( (aref buffer bidx) 0))
			 (print-line (* hzoom n-down) real-x-origin)
			 (print-line (* hzoom 6)
				     ;crock to make it print SOMETHING and get its act
				     ; together w/r/t vertical spacing.
				     real-x-origin))
		     
		     (decf sub-over 3)
		     (when (minusp sub-over)
		       (Multiple-value (over sub-over)
			 (floor (+ (* over vzoom) sub-over) vzoom)))
		     
		     ))))))





#| test code  |

(defflavor fake-dmp1
	((output-stream #'si:null-stream)
	 target-raster target-span target-y)	 
	())

(defmethod (:send-command fake-dmp1) (ignore))
(defmethod (:send-word-low-byte-first fake-dmp1) (ignore))
(defmethod (:send-word-high-byte-first fake-dmp1) (ignore))

(defmethod (:string-out fake-dmp1) (buffer)
  (let ((target target-raster)
	(span target-span))
    (declare (sys:array-register-1d target))
    (loop for bidx below (array-length buffer) by 3
	  for tidx upfrom (* target-y span) do
      (loop with tidx = tidx repeat 3 for bidx upfrom bidx do
	;; Yes, this strange ROTing is correct!
	(loop repeat 8 for bit = (rot (aref buffer bidx) -7) then (rot bit 1) do
	  (setf (aref target tidx) bit)
	  (incf tidx span))))
    (incf target-y 24.)))

;; Now go up to the top, replace the function spec of the defun-in-flavor to be
;;    (zoom-and-send-raster #-ignore fake-dmp1 #+ignore dmp1-output-stream)
;; Compile it, and then compile :test-it.

(defmethod (:test-it fake-dmp1) (width height hzoom vzoom)
  (setq target-raster (send standard-output :screen-array)
	target-span (multiple-value-bind (ignore ignore span)
			(decode-raster-array target-raster)
		      span)
	target-y 0)
  (setq width (* (ceiling width 32.) 32.)
	height (* (ceiling height 32.) 32.))
  (let* ((rwidth height)
	 (rheight width)
	 (rotated (make-raster-array rwidth rheight :type art-1b))
	 (8b-rotated (make-raster-array (// rwidth 8) rheight
					:type art-8b :displaced-to rotated)))
    (lgp:bit-array-rot-90 width height target-raster 0 0 rotated)
    (zoom-and-send-raster 8b-rotated hzoom vzoom self 0)))

;; To run, try (send (make-instance 'fake-dmp1) 200 200 3 5)
;; or perhaps  (send (make-instance 'fake-dmp1) 200 200 5 3)
;; (You may get errors from fast-aref near the bottom of the screen)

||#



(defmethod (:show-bitmap dmp1-output-stream) (raster width height
						    &key (left 0) (top 0) (hzoom 1) (vzoom 1)
						    (rotate 0))
  top left
  (when bitmap-only-p
    (setq hzoom 2
	  vzoom 2))
  (when landscape-p
    (psetq hzoom vzoom
	   vzoom hzoom))
  ;; This sure seems backwards to me but it does work...
  (let* ((rotated (or (and landscape-p (plusp rotate))
		      (and (not landscape-p) (zerop rotate))))
	 (correctly-rotated-raster (if rotated
				      (rotate-bitmap raster width height 1)
				      raster))
	 (zw (* hzoom width))
	 (zh (* vzoom height)))
    (let* ((bit-width (if rotated width height))
	   (bit-height (if rotated height width))
	   (byte-height (sys:ceiling bit-height 8))
	   (displaced-raster (make-raster-array
			       (* 4 (ceiling (decode-raster-array correctly-rotated-raster)
					     32))
			       bit-width
			      :type art-8b :displaced-to correctly-rotated-raster))
	   (bfd (get-dmp1-font 'fonts:dmp1-courier10)))
      (send self :set-cursorpos
	    (// (max 0 (- page-width (* 2 (if rotated zw zh)))) 2)
	    (// (max 0 (- page-height (if rotated zh zw))) 2))
      (let ((real-x-origin (if landscape-p (- page-height cursor-y) cursor-x))
	    (real-y-origin (if landscape-p (+ cursor-x
						 bit-height
						 -24.
						 (logand bit-height 7))
			       (- cursor-y (1- font-baseline-offset)))))
	
	(send self ':move-to real-x-origin real-y-origin)
	(zoom-and-send-raster displaced-raster hzoom vzoom output-stream real-x-origin)
	
	(fed:bfd-line-spacing bfd)		;Only bullshit distinguishes DMP1 from Fujitsu
						;when we ship its software with the system.
	(if landscape-p
	    (setq device-cursor-y (- cursor-y baseline)
		  device-cursor-x (- cursor-x 24.))
	    (setq device-cursor-y (- cursor-y (- (* 24 (// (+ byte-height 2) 3))
						       (- 24 font-baseline-offset)))
		  device-cursor-x cursor-x))
	(return-array displaced-raster)
	(when rotated
	  (return-array correctly-rotated-raster)))))
  (when bitmap-only-p
    (send self :eject-page)))

;;; DMP1 has three types of fonts:
;;; 1. ROM fonts.
;;;    The :dmp1-rom-font-address bfd property determines which ROM font to select
;;; 2. RAM fonts.
;;;    The font is down loaded into the printer upon first use.
;;; 3. Indirect RAM fonts.
;;;    A special font that implies using the bitmaps from another RAM font, but with
;;;    different "special effects" - see below.
;;;
;;; Special effects:
;;;    Each font can have an associated resolution
;;;      1 - "letter quality" - 360dpi horizontal
;;;      2 - "correspondence" - 180dpi
;;;   or 3 - "draft" - 120dpi
;;;	This parameter in stored under the :dmp1-font-resolution bfd property - defaulting to 1
;;;    Each font can have "shadow-printing" enabled for a bold effect, by having the
;;;    low order bit of the :dmp1-font-effect property non-zero
;;; Only two RAM fonts can be used at a time.
;;; Loadable fonts are restricted to a total raster height of 24 pixels
;;;   and a width of 36 pixels.  No two horizontally adjacent pixels
;;;   may be printed.
;;;
;;; Note that RAM fonts assume an intercharacter spacing of 0 which ROM fonts assume an
;;; intercharacter spacing of *default-intercharacter-spacing*.
;;; Furthermore, for any font, the set-width of the space character should be equal to
;;; its raster width plus the intercharacter spacing for that font.  Note that SPACE
;;; characters are never down loaded.

;;; Directories where dmp1 fonts are found
(defvar *dmp1-font-bfd-search-paths* '("sys:fonts;dmp1;.bfd.newest"))

;;; I use BFD's
(defmethod (:canonicalize-font dmp1-output-stream) (font &optional (type ':device))
  (let* ((font-symbol
	   (cl:ecase type
	     (:device (typecase font
			(:symbol font)
			(:string (intern (string-upcase font) si:pkg-fonts-package))
			(fed:bfont-descriptor (return-from :canonicalize-font font))
			(otherwise
			  (ferror "Font ~A is not a symbol or a string" font))))
	     (:press-font
	       (intern (string-upcase (destructuring-bind (name face size) font
					(format () "~a~d~a" name size face)))
		       si:pkg-fonts-package)))))
    (get-dmp1-font font-symbol)))

fed::
(setup-bfd-io-props '(:dmp1-font-proportional
		      :dmp1-rom-font-address
		      :dmp1-font-resolution
		      :dmp1-font-effect)
		    'write-counted-integer-property
		    'read-counted-integer)

(defun get-dmp1-font (font-symbol)
  (or (get font-symbol 'fed:bfont-descriptor)
      (if (or (get 'fonts:dmp1-courier10 'fed:bfont-descriptor)
	      (with-open-stream (s (loop for dir in *dmp1-font-bfd-search-paths*
					 for path = (send (fs:parse-pathname dir)
							  :new-name "DMP1-COURIER10")
					 when (condition-case ()
						  (open path :direction :in
							:characters :default)
						((fs:file-not-found fs:directory-not-found)
						 ()))
					   return it))
		(when s
		  (fed:read-bfd-from-stream s 'fonts:dmp1-courier10)
		  T)))
	  (fed:find-and-load-bfd font-symbol *dmp1-font-bfd-search-paths*)
	  (ferror "Cannot find the font ~a.~@
		   Perhaps the DMP1 software is not correctly installed?"
		  font-symbol))))

(defun remove-dmp1-fonts ()
  (loop for dir in *dmp1-font-bfd-search-paths*
	nconc (loop for (pathn) in (rest1 (fs:directory-list (send (fs:parse-pathname dir)
								   :new-pathname
								   :name :wild
								   :type :bfd
								   :version :newest)))
		    for sym = (intern (string-upcase (send pathn :name))
				      si:pkg-fonts-package)
		    when (si:nremprop sym 'fed:bfont-descriptor)
		      collect sym)))

;;; Send a font to the printer.
;;; We only allow character codes greater than SPACE.
;;; We count on SPACE not being loaded.
;;; If someone decides that lower codes need loading, DON'T LOAD SPACE, skip it.
;;; Since we will be down loading only every other row of bits, we must make sure that
;;; the row that sits on the baseline is included, since it is important.
;;; Note also that the font is down loaded such that there are 5 pins out of 24 below
;;; the baseline - since all the ROM fonts are aligned this way.  Someday this
;;; could be haired up to allow, e.g. fonts that are 24 bits above the baseline and
;;; none below.  For now the largest size allowed above the baseline is 19.
(defun down-load-font (font index stream)
  (let (start-code end-code)
    (loop for bcd being bfd-elements of font
	  for first = t then nil
	  for last-bcd = bcd
	  when first
	    do (setq start-code (fed:bcd-char-code bcd))
	  when (> (fed:bcd-raster-width bcd) 64)
	    do (ferror "Character ~A in font ~A too wide to down load." bcd font)
;	  when (> (fed:bcd-raster-height bcd) 48)
;	    do (ferror "Character ~A in font ~A too high to down load." bcd font)
	  finally
	    (setq end-code (fed:bcd-char-code last-bcd)))
    (setq start-code (max (char-code #/!) start-code))
    (setq end-code (min (char-code #/~) end-code))
    (when (> (1+ (- end-code start-code)) 96.)
      (ferror "Font ~A has too many characters to down load" font))
    (send stream :tyo *escape-char*)
    (send stream :tyo (char-code #/l))
    (send stream :tyo (logior index (lsh (or (fed:bfd-get font :dmp1-font-resolution) 1)
					 4)))
    (send stream :tyo start-code)
    (send stream :tyo end-code)
    (loop for code from start-code to end-code
	  for bcd = (aref font code)
	  if (and bcd (plusp (fed:bcd-raster-width bcd)))
	    do (let ((width (min 64 (fed:bcd-raster-width bcd)))
		     (height (fed:bcd-raster-height bcd))
		     (top-offset (- (+ (fed:bfd-baseline font)
				       (fed:bcd-top-kern bcd))
				    (* 2 *default-baseline*))))
		 (if (and (minus top-offset)
			  (oddp top-offset))
		     (incf top-offset))
		 (send stream :tyo width)
		 (loop for i below width
		       do (loop repeat 3
				for row-origin from top-offset by 16
				do (send stream :tyo
					 (loop with bits = 0
					       for k below 16 by 2
					       for row = (+ k row-origin)
					       do
					   (flet ((bit (row)
						    (if (or (minusp row)
							    (>= row height))
							0
							(raster-aref bcd i row))))
					     (setq bits (logior (lsh bits 1)
								(bit row)
								(bit (1+ row)))))
					       finally (return bits))))))
	  else do (send stream :tyo 0))))
		 
(defmethod (:set-device-font dmp1-output-stream) ()
  (let* ((resolution (or (fed:bfd-get current-font :dmp1-font-resolution) 1))
	 (rom-font (fed:bfd-get current-font :dmp1-rom-font-address))
	 (location (if rom-font *rom-font-location* *ram-font-location*))
	 (number (or rom-font
		     (let* ((indirect-ram-font (fed:bfd-get current-font
							     :dmp1-indirect-ram-font))
			    (bfd (if indirect-ram-font
				     (get-dmp1-font indirect-ram-font)
				     current-font))
			    (ram-font (assq bfd down-load-fonts)))
		       (unless ram-font
			 (if (> (length down-load-fonts) 2)
			     (ferror "Need to download font ~A, but DMP1 font RAM is full." ram-font)
			     (push (setq ram-font (ncons bfd)) down-load-fonts)))
		       (dlet (((font . index) ram-font))
			 (unless index
			   (rplacd ram-font
				   (setq index (find-position-in-list
						 ram-font down-load-fonts)))
			   (down-load-font font (make-dmp1-font-byte
						  location *ram-font-location*
						  resolution 0
						  number index)
					   output-stream))
			   index)))))
    (let ((new-number (make-dmp1-font-byte location location
					   resolution resolution
					   number number)))
      (when (or (neq font-resolution resolution)
		(neq font-number new-number))
	(setq font-resolution resolution
	      font-number new-number)
	(send self ':send-command (char-code #/#) font-number)))
    (let ((intercharacter-spacing (if rom-font
				      *default-intercharacter-spacing*
				      0)))
      (unless (= intercharacter-spacing font-intercharacter-spacing)
	(setq font-intercharacter-spacing intercharacter-spacing)
	(send self ':send-command #x11 
	      ;; Note that a zero offset needs to be sent as negative - for some reason
	      ;; a positive zero offset causes strange behavior (eats next character etc.)
	      ;; Note also that this doesn't really work unless the intercharacter spacing
	      ;; desired is a multiple of (360/120) or 3.  Bletcho.
	      (logior (if (<= intercharacter-spacing *default-intercharacter-spacing*)
			  #o100 0)
		      (fixr (// (abs (- *default-intercharacter-spacing*
					intercharacter-spacing))
				3.0)))))))
  (let ((effect (or (fed:bfd-get current-font :dmp1-font-effect) 0)))
    (when (neq font-effect effect)
      (setq font-effect effect)
      (send self ':send-command (if (bit-test 1 effect)
				   (char-code #/W)
				   (char-code #/&)))))
  (let* ((ps (not (fed:bfd-is-fixed-width current-font)))
	 (new-hmi (- (let ((bcd (aref current-font (char-code #/space))))
		       (or (and bcd (fed:bcd-set-width bcd))
			   (fed:bfd-char-width current-font)))
		     (if ps
			 font-intercharacter-spacing
			 0))))
    (when (oddp new-hmi)
      ;;(fsignal "HMI can't be odd, sorry.  Fonts need an even width space")
      (incf new-hmi))
    (cond (ps
	   ;;; Set the HMI if we are changing to proportional, or the hmi changed.
	   (unless (and font-proportional
			(= hmi new-hmi))
	     ;;; This stuff is truly bizarre.  Is PS mode, when you send a space,
	     ;;; (assuming its never down loaded) it moves current hmi MINUS
	     ;;; *default-intercharacter-spacing* (NOT font-intercharacter-spacing!)
	     ;;; Thus we fake things out by increasing the hmi we sent to the printer.
	     (send self ':send-command
		   (char-code #/b)
		   (// (+ *default-intercharacter-spacing* new-hmi)
		       2))
	     (send self ':send-command (char-code #/P))))
	  (t
	   (when font-proportional
	     (send self ':send-command (char-code #/Q)))
	   (when (or font-proportional
		     ( new-hmi hmi))
	     (send self ':send-command (char-code #/b) (// new-hmi 2)))))
    (setq hmi new-hmi
	  font-proportional ps))
  (setq cr-or-lf-safe (and (zerop font-effect) (= font-intercharacter-spacing
						  *default-intercharacter-spacing*))
	device-current-font current-font))


;;Stuff for substituting chars from symbol font

(defconst *lispm-charset-in-symbol-font-substitutions*
	  (let ((arr (make-array 32 :type 'art-string :area permanent-storage-area)))
	    (loop with subs = " ! % ) 2 $ Œ1 Š// 4 3 + , - . 9 : /0 ( & ' 5 ; 6 7 8 *"
		  for i below (string-length subs) by 3
		  for lispm-char = (aref subs i)
		  for symbol-char = (aref subs (1+ i))
		  do (setf (aref arr (char-code lispm-char)) symbol-char))
	    arr))

(defmethod (:substitute-char dmp1-output-stream) (char font-num)
  (declare (values device-char device-font-number))
  (check-arg char characterp "a character")
  (flet ((find-it ()
	   (or (loop for font being array-elements of font-table
		     for i from 0
		     when (eq (fed:bfd-name font) 'fonts:dmp1-symbol10)
		       return i)
	       (send self :add-font 'fonts:dmp1-symbol10 :device))))
    (cond ((< (char-code char) (char-code #\space))
	   (values (aref *lispm-charset-in-symbol-font-substitutions* (char-code char))
		   (find-it)))
	  ((< (char-code char) (char-code #\‡))
	   (values char font-num))
	  ((= (char-code char) (char-code #\‡))
	   (values #\< (find-it))) 
	  (T (values char font-num)))))

(compile-flavor-methods dmp1-output-stream)
