;; -*- Mode: Lisp; Package: TCP; Lowercase: Yes; Syntax: Common-lisp -*-
;; Internet Datagram Protocol (Routing)
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; Constants

;(export '*dead-gateway-ping-interval*)
(defparameter *dead-gateway-ping-interval* (* 1 60 60)
  "The interval between sending ICMP echoes to a gateway believed to be down.")

;(export '*live-gateway-ping-interval*)
(defparameter *live-gateway-ping-interval* (* 10 60 60)
  "The interval between sending ICMP echoes to a gateway believed to be up.")

;;; Utilities

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;;This finds all gateways in the local namespace.   It would be nice to go through the search
;;; rules but searching the Internet namespace can be a bear.
0(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")ip-find-network-gateways0 ()
  (neti:without-internet-namespace
    (net:find-objects-from-property-list :host :service '((:gateway :ip :internet-gateway)))))

1;;; Returns T if any address on gateway-1 matches an address on gateway-2.  Gateways are
;;; assumed to be EQUAL if any address matches.
0(defun 2gateway-equal 0(gateway-1 gateway-2
		      &optional (network (neti:local-network-of-type :internet)))
  (map-ip-addresses
    gateway-1 network
    #'(lambda (addr1)
	(map-ip-addresses gateway-2 network
			  #'(lambda (addr2)
			      (when (compare-internet-address addr1 addr2)
				(return-from gateway-equal t)))))))
1;;; This encaches all gateways so we shouldn't don't do any namespacing during intialization
;;; that can cause deadlock problems
0(defun 2find-all-ip-gateways 0()
  (neti:searching-all-namespaces
    (net:find-objects-from-property-list
      :host :service '((:gateway :ip :internet-gateway)))))

1;;; Used to get a new list of gateways on our network from the namespace.  This conses a lot
;;; but it is only used at network reset/get-common-property-lists time
0(defmethod (2find-local-gateways0 ip-protocol) ()
  (let* ((gateway-list
	   (remove-duplicates 
	     1;; Note:  Since the list of gateways can have the same gateway from another
0	     1;;namespace, we need to remove the duplicates.0 1Find-objects-from-property-list
0	     1;;collects them in the order of the search rules so the ones in our namespace
0	     1;;should be last in the list.  Therefore, remove-duplicates should remove the ones
0	     1;;that are not in our namespace first.
0	     (loop with gateways = (remove-duplicates
				     (if (rest interface-list)
					 (find-all-ip-gateways)
					 (ip-find-network-gateways))
				     :test #'gateway-equal)
		   for interface in interface-list
		   for subnet-number = (ip-interface-subnet-number interface)
		   for mask = (ip-interface-mask interface)
		   append (loop for gateway in gateways
				unless (eq gateway net:*local-host*)
				  append
				    (loop for (net address) in
					      (send gateway :network-addresses)
					  when (and (internet-network-eql net network)
						    (compare-internet-address
						      (logand address mask) subnet-number))
					    collect gateway)))
	     :test #'neti:ns-eq))
	 (fep-entry (neti:get-primary-address-entry-of-type :internet))
	 (options (when fep-entry (neti:primary-address-options fep-entry)))
	 (gateway-entry (when options (or (zl:assoc "gw" options)
					  (zl:assoc "gateway" options))))
	 (gateway-address (when gateway-entry (cdr gateway-entry)))
	 (parsed-gateway-address (when gateway-address
				   (parse-internet-address gateway-address))))
    1;; Check to see if the gateway address in the FEP, if any, is an address of one of the
    ;; gateways in the namespace.  
0    (when (and parsed-gateway-address
	       (loop for host in gateway-list
		     as addresses = (host-ip-addresses host network)
		     when (member parsed-gateway-address addresses
				  :test #'compare-internet-address)
		       return nil
		     finally (return t)))
      1;; Create a temporary (uninterned) gateway host
0      (push (neti:make-object-from-property-list
	      :host
	      (format nil "~a|~a|~a" neti:*namespace* network gateway-address)
	      `(:address ((,network ,gateway-address))
		:service ((:gateway :ip :internet-gateway))
		:site ,net:*local-site*
		:system-type :gateway))
	    gateway-list))
    gateway-list))
(defvar *number-of-pings* 6)

(defvar *number-of-ping-loops* 10)

(defvar *number-of-pings* 50)

(defmethod 2(ping-gateways ip-protocol)0 ()
1  ;; Ping the gateways to get address resolutions on them and see if they are up.
0  1;; We need to do this multiple times to account for ARPs, etc.
0  (loop repeat *number-of-ping-loops*
	do (loop for gateway being the hash-elements of gateway-hash-table do
	     (loop repeat *number-of-pings* do	1;4 seems to make this always work
0	       (ip-send-to-protocol *icmp-protocol-number*
				    :icmp-ping-gateway gateway)))
	   1;; Always run the background to finish the job
0	   (background-processing)
	while ;;keep trying while there are dead gateways up to loop limit
	      (loop for gw being the hash-elements of gateway-hash-table 
		    thereis (tcp::ip-gateway-dead gw)))) 

1;;; Compares the current gateways to the namespace and initializes routing if they are not
;;; the same.  (Yes, this is method on the internet-network but it functionally belongs in this
;;; file.
0(defmethod (2update-ip-network-gateways0 internet-network) ()
  (when ip-protocol
    (flet ((collect-addresses (hosts)
	     (sort (remove-duplicates (loop for host in hosts
					    append (host-ip-addresses host self))
				      :test #'compare-internet-address)
		   #'internet-address-lessp)))
      (let ((current-gateway-addresses
	      (collect-addresses 
		(loop for gateway being the hash-elements of (send ip-protocol
								   :gateway-hash-table)
		      collect (ip-gateway-foreign-host gateway))))
	    (new-gateway-addresses
	      (collect-addresses  (find-local-gateways ip-protocol))))
	(unless (equal current-gateway-addresses new-gateway-addresses)
	  (let ((neti::*inhibit-validity-checking* t))
	    (send ip-protocol :initialize-routing))
	  (ping-gateways ip-protocol))))))

1;;; This runs on get-common-property-lists and checks to see if the getways we had cached
;;; are really the ones that are out there.  If not, routing is initialized with the new
;;; set of gateways.
0(defun find-internet-gateways ()
  (loop for network in neti:*local-networks*
			   when (typep network 'internet-network)
			   do (update-ip-network-gateways network)))

(add-initialization "Get Internet Gateways"
		    '(find-internet-gateways)
		    nil
		    'neti:commonly-used-property-lists)
(defun-in-flavor 2(ip-get-subnet ip-protocol)0 (address)
  (let ((number (internet-subnet-number-internal address)))
    (let ((mask (gethash number mask-hash-table)))
      (when mask (setf number (logand address mask))))
    (let ((entry (gethash number subnet-hash-table)))
      (if (and entry (first (first (ip-subnet-gateways entry))))
	  entry
	  (let (new-subnet)
	    (if (rest interface-list)		1; This is a gateway
0		(if default-gateway		1; We have a default-gateway
0		    (loop for (net addr) in (send default-gateway :network-addresses)
			  when (internet-network-eql net network)
			  as gw = (gethash addr gateway-hash-table)
			  when gw
			    return (setq new-subnet (make-ip-subnet
					       :ip self :number number
					       :gateways (list (list gw 1002)))))
		    1;; There is no default gateway, try the default routing net.
0		    (when default-network
		      (let* ((default-number (parse-internet-address default-network))
			     (default-subnet
			       (and default-number
				    ( default-number number)
				    (gethash default-number subnet-hash-table))))
			(when default-subnet
			  (setq new-subnet
				(make-ip-subnet :ip self :number number
						:gateways
						(ip-subnet-gateways default-subnet)))))))
		1;; this isn't a gateway
0		(when (ip-interface-prime-gateways (first interface-list))
		  (setf new-subnet
			(make-ip-subnet
			  :ip self :number number
			  :gateways (loop for gateway in (ip-interface-prime-gateways
							   (first interface-list))
					  collect (list gateway 1002))))))
	    (when new-subnet
	      (setf (gethash number subnet-hash-table) new-subnet))
	    new-subnet)))))

(defun-in-flavor 2(ip-make-route ip-protocol)0 (host addresses)
  (let ((route (make-ip-route :ip self :foreign-host host :foreign-addresses addresses
			      :interface nil :gateway-address nil)))
    (process:with-no-other-processes		1;Lock the cache while we do this
0      (loop for address in addresses
	    do (setf (gethash address route-hash-table) route)
	    when (compare-internet-address address last-address)
	      do (setq last-address-route route)))
    route))

(defun-in-flavor (ip-get-gateway ip-protocol) (interface address &optional host dead-p)
  (or (gethash address gateway-hash-table)
      (when interface
	(let ((gateway (make-ip-gateway
			 :ip self :interface interface :gateway-address address
			 :foreign-host host :foreign-addresses (list address)
			 :max-packet-size (ip-interface-max-packet-size interface)
			 :time-last-alive (time:time) :dead dead-p :desirability 1)))
	  (setf (gethash address gateway-hash-table) gateway)
	  (when (and host
		     (rest interface-list)
		     (member '(:gateway :ip-gateway :internet-gateway-egp)
			     (send host :get :service)
			     :test #'equal))
	    (send (internal-ip-protocol-instance (aref protocol-array *egp-protocol-number*))
		  :egp-add-neighbor gateway))
	  gateway))))

;;; Initialization

(defun-in-flavor 2(ip-initialize-routing-for-host ip-protocol)0 ()
  (loop for gateways = (find-local-gateways self)
	for interface in interface-list
	for subnet-number = (ip-interface-subnet-number interface)
	for mask = (ip-interface-mask interface)
	doing (setf (ip-interface-prime-gateways interface) nil)
	      (loop for gateway in gateways
		    unless (eq gateway net:*local-host*)
		      do (map-ip-addresses
			   gateway network
			   #'(lambda (address)
			       (when (compare-internet-address (logand address mask)
							       subnet-number)
				 (push (ip-get-gateway interface address gateway :never)
					  (ip-interface-prime-gateways interface))))))))

;; This routine walks the entire network graph from the namespace database and figures
;; out all the ways to get from here to there.
(defun-in-flavor 2(ip-initialize-routing-for-gateway ip-protocol)0 ()
  (loop with gateways =
	  (remove net:*local-host*
		  (loop for gw in (find-all-ip-gateways)
			when (neti:network-assoc network (send gw :address))
			  collect gw))
	for these-subnets
	    first (loop for interface in interface-list
			for subnet = (ip-interface-subnet interface)
			collect (list (ip-interface-subnet-number interface)
				      interface
				      (unless
					(zerop (second (first (ip-subnet-gateways subnet))))
					(ip-subnet-gateways subnet))))
		   then next-subnets
	for cost upfrom 1
	for next-subnets = nil
	while these-subnets
	doing
    (loop for (subnet interface gateway-address) in these-subnets
	  do
      (loop for gateway in gateways
	    for addresses = (host-ip-addresses gateway network)
	    for gwa = (loop for address in addresses
			    when (compare-internet-address
				   (internet-subnet-number-internal address)
				   subnet)
			      return (or gateway-address
					 (list (list (ip-get-gateway
						       interface address
						       gateway :never)))))
	    when gwa
	      do
		(loop for address in addresses
		      for gateway-subnet = (internet-subnet-number-internal address)
		      for sn = (or (gethash gateway-subnet subnet-hash-table)
				   (setf (gethash gateway-subnet subnet-hash-table)
					 (make-ip-subnet :ip self
							 :number gateway-subnet)))
		      when (loop with ogws = (ip-subnet-gateways sn)
				 for (gw) in gwa
				 when (loop for (sgw) in (ip-subnet-gateways sn)
					    never (or (eq sgw gw)
						      (and
							(null (ip-route-gateway-address sgw))
							(eq (ip-route-interface gw)
							    (ip-route-interface sgw)))))
				   do (push (list gw cost) (ip-subnet-gateways sn))
				 finally (return (not (eq ogws (ip-subnet-gateways sn)))))
			do (push (list gateway-subnet interface gwa) next-subnets)))))
  1;; Initialize default-gateway and default-network IV's
0  (let ((gw-string (send net:*local-host* :user-get :default-internet-gateway)))
    (when gw-string 
      (setq default-gateway (net:parse-host (string-trim '(#\space) gw-string) t))))
  (setq default-network (send network :user-get :internet-default-routing-network)))

;;; Initialize the routing database.

(defun-in-flavor (ip-get-subnet-masks ip-protocol) ()
  (let* ((masks-string (send network :user-get :internet-subnet-masks))
	 ;; Get a possible mask out of the information from the FEP
	 (fep-entry (neti:get-primary-address-entry-of-type :internet))
	 (fep-mask-entry (when fep-entry
			   (zl:assoc "mask" (neti:primary-address-options fep-entry))))
	 (fep-mask (when fep-mask-entry (cdr fep-mask-entry)))
	 (fep-address (when fep-mask (neti:primary-address-address-string fep-entry)))
	 (result-masks))
    (when masks-string
      (setq result-masks
	    (mapcar #'(lambda (entry)
			(list (parse-internet-address (first entry))
			      (parse-internet-address (second entry))))
		    (let ((*readtable* si:standard-readtable))
		      (read-from-string masks-string)))))
    (when fep-mask
      (pushnew (list (official-internet-subnet-number (parse-internet-address fep-address))
		     (parse-internet-address fep-mask))
	       result-masks :test #'equal))
    result-masks))


1;;; Returns T if routing was initialized.  Returns Nil if not and sends error messages to 
;;; *Error-output*.
0(defmethod2 (:initialize-routing ip-protocol)0 ()
  (setq routing-initialized nil)
  (clrhash gateway-hash-table)
  (clrhash subnet-hash-table)
  (clrhash route-hash-table)
  (clrhash mask-hash-table)
  (setq default-gateway nil
	default-network nil)
  1;; Clear caches
0  (setq last-host nil)
  (setq last-host-route nil)
  (setq last-address 0)
  (setq last-address-route nil)
  ;; Set up the interfaces.
  (block setup-interfaces
    (setq interface-list
	  (loop with special-masks = (ip-get-subnet-masks)
		for (interface . address) in (neti:find-network-interfaces network)
		for mask = (internet-address-mask address -1 0)
		for subnet-number = (logand address mask)
		when special-masks
		  do (let ((new-mask (assoc subnet-number special-masks
					    :test #'compare-internet-address)))
		       (when new-mask
			 (setf mask (second new-mask))
			 (setf (gethash subnet-number mask-hash-table) mask)
			 (setf subnet-number (logand address mask))))
		collect (make-ip-interface
			  :instance interface :local-address address
			  :max-packet-size (send interface :max-packet-size)
			  :dynamic-p (neti:network-interface-dynamic-p interface)
			  :mask mask :subnet-number subnet-number)))
    (when (not interface-list)
      (format *error-output* "~&Unable to bring up IP because of Network/Interface mismatch.  Perhaps you have an IP address without an interface.")
      (return-from setup-interfaces nil))
    ;; Set up the local (loop-back) interface.
    (let* ((local-interface (make-ip-interface :instance :local
					      :local-address (ip-interface-local-address
							       (first interface-list))
					      :max-packet-size neti:raw-packet-buffer-size))
	  (local-host-addresses (host-ip-addresses net:*local-host* network))
	  (local-host-route (ip-make-route net:*local-host* local-host-addresses)))
      (setf (ip-route-source local-host-route) :constant)
      (setf (ip-route-interface local-host-route) local-interface)
      (setf (ip-route-max-packet-size local-host-route) neti:raw-packet-buffer-size)
      (setq local-route local-host-route)
      (setq local-addresses local-host-addresses))
    ;; Set up the global broadcast route
    (let ((broadcast-route (ip-make-route nil (list (build-internet-address 0 0 0 0)
						    (build-internet-address 255 255 255 255)))))
      (setf (ip-route-source broadcast-route)
	    (ip-interface-local-address (first interface-list)))
      (setf (ip-route-gateway-address broadcast-route) *ip-broadcast-address*)
      (setf (ip-route-interface broadcast-route) (first interface-list))
      (setf (ip-route-max-packet-size broadcast-route) *ip-default-max-packet-size*))
    ;; Set up the basic routes and gateways.
    (loop for interface in interface-list
	  for subnet-number = (ip-interface-subnet-number interface)
	  for mask = (ip-interface-mask interface)
	  for official-mask = (internet-address-mask subnet-number -1 0)
	  for offical-broadcast = (internet-address-mask subnet-number 0 -1)
	  for official-number = (logand subnet-number official-mask)
	  for subnet = (make-ip-subnet
			 :ip self :number subnet-number :gateways
			 (list (list
				 (make-ip-gateway
				   :ip self :interface interface :desirability 1
				   :max-packet-size (ip-interface-max-packet-size interface))
				 0)))
	  for broadcast-addresses = (list subnet-number
					  (logior (lognot mask) subnet-number))
	  when (not (compare-internet-address subnet-number official-number))
	    do (setf broadcast-addresses
		     ;; Include the official subnet number for
		     ;; compatibility with 4.2 based unix systems which
		     ;; don't do subnetting.
		     (append broadcast-addresses
			     (list official-number
				   (logior subnet-number offical-broadcast))))
	  for broadcast-route = (ip-make-route nil broadcast-addresses)
	  doing
      (setf (ip-route-interface broadcast-route) interface)
      (setf (ip-route-gateway-address broadcast-route) *ip-broadcast-address*)
      (setf (ip-route-source broadcast-route) :constant)
      (setf (ip-route-max-packet-size broadcast-route)
	    (ip-interface-max-packet-size interface))
      (setf (ip-interface-subnet interface) subnet)
      (setf (gethash subnet-number subnet-hash-table) subnet))
    ;; Find gateways to the rest of the world.
    (ip-initialize-routing-for-host)
    ;;Even more distasteful stuff if we ourselves are a gateway
    (when (rest interface-list)
      (ip-initialize-routing-for-gateway))
    ;; Hook up with the rest of the world.
    (loop for interface in interface-list
	  do (send (ip-interface-instance interface) :add-network network
		   (ip-interface-local-address interface)))
    (setq routing-initialized t)
    t)) 


;;; Background

(defmethod (:background-routing ip-protocol) ()
  ;; Use maphash-snapshot (defined below) to get a snapshot of the hash table rather than
  ;; maphash on the table for the entire duration without-interrupts.  We don't care how
  ;; long this takes to run as long as it doesn't run without-interrupts for long periods.
  ;; Modifications go directly to the hash table.
  (maphash-snapshot #'(lambda (ignore route)
			(unless (or (ip-route-foreign-host route)
				    (null (ip-route-gateway-address route))
				    (compare-internet-address (ip-route-gateway-address route)
							      *ip-broadcast-address*))
			  (setf (ip-route-foreign-host route)
				(net:get-host-from-address
				  (first (ip-route-foreign-addresses route)) network t))))
		    route-hash-table)
  (let ((gateways-died nil))
    (maphash-snapshot #'(lambda (ignore gateway)
			  (when (and (not (ip-gateway-dead gateway))
				     (ip-gateway-time-last-pinged gateway)
				     (time-elapsed-p (* 4 *background-interval*)
						     (ip-gateway-time-last-pinged gateway)))
			    (send self :set-gateway-unreachable gateway :icmp)
			    (setf gateways-died t))
			  (when (if (ip-gateway-dead gateway)
				    (or (not (ip-gateway-time-last-pinged gateway))
					(time-elapsed-p *dead-gateway-ping-interval*
							(ip-gateway-time-last-pinged gateway)
							))
				    (or (ip-gateway-time-last-pinged gateway)
					(time-elapsed-p *live-gateway-ping-interval*
							(ip-gateway-time-last-alive gateway)
							)))
			    (unless (ip-gateway-time-last-pinged gateway)
			      (setf (ip-gateway-time-last-pinged gateway) (time:time)))
			    (ip-send-to-protocol *icmp-protocol-number*
						 :icmp-ping-gateway gateway)))
		      gateway-hash-table)
    (when gateways-died (send self :recompute-all-routes))))

;;; The function used in :background-routing to create a snapshot of the hash table on the
;;; data stack.
(defun maphash-snapshot (function table)
  (sys:with-data-stack
    (multiple-value-bind (keys values)
	;; The 10 is some extra slop in case another process is adding
	;; elements to the table between hash-table-count and maphash
	(let ((number-of-elements (+ 10 (hash-table-count table))))
	  (values (sys:make-stack-array number-of-elements :fill-pointer 0)
		  (sys:make-stack-array number-of-elements :fill-pointer 0)))
      (maphash (lambda (key value)
		   ;; grow the arrays if necessary, but that might
		   ;; copy out to the heap
		   (vector-push-extend key keys)
		   (vector-push-extend value values))
		 table)
      (map nil function keys values))))

(defmethod (:icmp-alive ip-protocol) (address)
  (let ((gateway (ip-get-gateway nil address)))
    (when gateway
      (setf (ip-gateway-time-last-alive gateway) (time:time))
      (setf (ip-gateway-time-last-pinged gateway) nil)
      (when (ip-gateway-dead gateway)
	(send self :set-gateway-reachable gateway)
	(send self :recompute-all-routes)))))

;;; Interface to the world

(defmethod 2(:route-to-host ip-protocol)0 (host)
  (unless routing-initialized
    (process-wait "Routing Initialization"
      #'(lambda (ip-instance) (ip-protocol-routing-initialized ip-instance)) self))	  
  (if (eq host :broadcast)
      1;; If broadcast, use the appropriate route
0      (let ((route (send self :route-to-address *ip-broadcast-address*)))
	(values route (ip-interface-local-address (ip-route-interface route))	      
		*ip-broadcast-address*))
      1;; Find the route
0      (process:with-no-other-processes		1;Protect the caches from corruption
0	(let* ((cache-valid t)
	       (route
		 (cond
		   1;; Is this the local host?
0		   ((neti:ns-eq host net:*local-host*)
		    local-route)
		   1;; Check the cache first
0		   ((neti:ns-eq host last-host) last-host-route)
		   1;; Walk through the addresses searching for a route
0		   ((progn
		      (setq cache-valid nil)
		      (loop with host-addresses = (send host :network-addresses)
			    for (net addr) in host-addresses
			    with net-found-p = nil
			    with route-invalid-p = nil
			    as internet-net-p = (internet-network-eql net network)
			    as possible-route = (and internet-net-p
						     1;; Check the table, but don't use
						     ;; :route-to-address because it will
						     ;; create a new route
0						     (gethash addr route-hash-table))
			    when internet-net-p do (setq net-found-p t)
			    when possible-route
			      1;; Check to make sure all the addresses for this host are known
			      ;; to the route by seeing if they are all a member of the set of
			      ;; addresses known to the route (catches cases where the host has
			      ;; added an address) and when the number of addresses is not
			      ;; equal0 1to the number of addresses known to the route (catches
			      ;; cases0 1where a house looses an address)
0			      do
				(loop for (net2 addr2) in host-addresses
				      with address-set = (ip-route-foreign-addresses
							   possible-route)
				      with address-count = 0
				      when (and (internet-network-eql net2 net)
						(incf address-count)
						(not (compare-internet-address addr addr2))
						(not (member
						       addr2 address-set
						       :test #'compare-internet-address)))
					return (progn (setq possible-route nil)
						      (setq route-invalid-p t))
				      finally (when ( address-count (length address-set))
						1;; We have a route to more addresses than this
						;; host now has, we need to clear the entries
						;; from the route-hash-table to maintain
						;; consistency.
0						(dolist (address address-set)
						  (remhash address route-hash-table))
						(setq possible-route nil)
						(setq route-invalid-p t)))
			    when possible-route return possible-route
			    when route-invalid-p return nil
			    finally (when (null net-found-p)
				      (error
					"Host ~A is not on any internet network." host)))))
		   1;; Found nothing, make a new route
0		   (t (ip-make-route host (host-ip-addresses host network))))))
	  1;; Check to see if this host matches the one in the route and update
0	  (when (not (neti:ns-eq host (ip-route-foreign-host route)))
	    (setf (ip-route-foreign-host route) host))
	  1;; Recompute the route if there is no interface
0	  (unless (ip-route-interface route)
	    (send self :route-recompute route))
	  1;; Cache the host and route
0	  (unless cache-valid
	    (setq last-host host)
	    (setq last-host-route route))
	  (let* ((interface (or (ip-route-interface route)
				1;; This is a kludge but there are times when it is necessary
0				(first interface-list)))
		 (local-address (ip-interface-local-address interface))
		 (mask (ip-interface-mask interface)))
	    (unless interface (error "Can't find an interface to route to host ~A."))
	    (values route
		    local-address
		    (if (eq :local (ip-interface-instance interface))
			local-address
			(loop for address in (ip-route-foreign-addresses route)
			      with local-subnet = (logand local-address mask)
			      when (compare-internet-address (logand address mask) local-subnet)
				return address
			      finally (return (first (ip-route-foreign-addresses route)))))))))))


(defmethod2 (:route-to-address ip-protocol)0 (foreign-address)
  (unless routing-initialized
    (process-wait "Routing Initialization"
      #'(lambda (ip-instance) (ip-protocol-routing-initialized ip-instance)) self))
  (process:with-no-other-processes		1;Protect Caches from timing windows
0    (let* ((cache-valid t)
	   (route (cond
		    1;; Is this one of our addresses?
0		    ((loop for addr in local-addresses
			   when (compare-internet-address foreign-address addr)
			     return local-route))
		    1;; Try the cache next 
0		    ((compare-internet-address foreign-address last-address)
		     last-address-route)
		    1;; Check the hash table next
0		    ((progn (setq cache-valid nil)	1;Invalidate the cache
0			    (gethash foreign-address route-hash-table)))
		    1;; Make a new one
0		    (t (ip-make-route nil (list foreign-address))))))
      (unless (ip-route-interface route)
	(send self :route-recompute route))
      1;; If we didn't find it in the cache, put it there
0      (unless cache-valid
	(setq last-address foreign-address)
	(setq last-address-route route))
      route)))

(defmethod (:route-recompute ip-protocol) (route)
  (let ((gateway-address (ip-route-gateway-address route)))
    ;; Don't recompute gateway routes
    (unless (and gateway-address
		 (compare-internet-address gateway-address *ip-broadcast-address*))
      (setf (ip-route-interface route) nil)
      (setf (ip-route-gateway-address route) nil)
      (setf (ip-route-source route) nil)
      (multiple-value-bind (best-gateway best-foreign-address)
	  (best-gateway-for-route self route)
	(when best-gateway
	  (setf (ip-route-interface route) (ip-route-interface best-gateway))
	  (cond ((ip-route-gateway-address best-gateway)
		 (setf (ip-route-gateway-address route)
		       (ip-route-gateway-address best-gateway))
		 (setf (ip-route-max-packet-size route)
		       ;; In lieu of any better information
		       ;; about the remote host, we have to
		       ;; limit this to the default max.
		       ;; Higher protocols (e.g., TCP) can
		       ;; negotiate a better value.  C.f.,
		       ;; RFC897
		       (min (ip-route-max-packet-size best-gateway)
			    *ip-default-max-packet-size*)
		       ))
		(t (setf (ip-route-gateway-address route) best-foreign-address)
		   (setf (ip-route-max-packet-size route)
			 ;; We assume all hosts on a local
			 ;; net can deal with the interface
			 ;; MTU
			 (ip-interface-max-packet-size
			   (ip-route-interface route)))))
	  (setf (ip-route-source route) best-gateway))))))

(defmethod (best-gateway-for-route ip-protocol) (route)
  (loop with (best-gateway best-cost desirability best-foreign-address)
	for foreign-address in (ip-route-foreign-addresses route)
	for subnet = (ip-get-subnet foreign-address)
	when subnet do
	  (loop for (gateway cost) in (ip-subnet-gateways subnet) do
	    (unless (and (ip-gateway-dead gateway)
			 (not (ip-interface-dynamic-p (ip-route-interface gateway))))
	      (if (or (null best-gateway)
		      ;; Most desirable gateway wins, no matter what.
		      (> (ip-gateway-desirability gateway) desirability)
		      ;; Equally desirable gateways discriminated by cost.
		      (and (= (ip-gateway-desirability gateway) desirability)
			   (< cost best-cost)))
		  (setq best-gateway gateway
			desirability (ip-gateway-desirability gateway)
			best-cost cost
			best-foreign-address foreign-address))))
	finally (return (values best-gateway best-foreign-address))))

(defmethod (:recompute-all-routes ip-protocol) ()
  (maphash #'(lambda (ignore route)
	       (unless (and (ip-route-source route)
			    (symbolp (ip-route-source route)))
		 (send self :route-recompute route)))
	   route-hash-table))

;;; Interface to routing protocols

(defmethod (:set-gateway-reachable ip-protocol) (gateway)
  (when (ip-gateway-dead gateway)
    (setf (ip-gateway-dead gateway) nil)
    (ip-notify nil "Gateway ~A has come up." gateway)))

(defmethod (:set-gateway-unreachable ip-protocol) (gateway reason)
  (unless (ip-gateway-dead gateway)
    (setf (ip-gateway-dead gateway) reason)
    (ip-notify nil "Gateway ~A has gone down (~A)." gateway reason)))

(defmethod (get-gateway-desirability ip-protocol) (gateway-address)
  (let ((gateway (gethash gateway-address gateway-hash-table)))
    (when (null gateway)
      (error "No gateway is known at ~A" (unparse-internet-address gateway-address)))
    (ip-gateway-desirability gateway)))

(defmethod (set-gateway-desirability ip-protocol) (gateway-address desirability)
  (assert (and (>= desirability 0) (<= desirability 1)))
  (let ((gateway (gethash gateway-address gateway-hash-table)))
    (when (null gateway)
      (error "No gateway is known at ~A" (unparse-internet-address gateway-address)))
    (setf (ip-gateway-desirability gateway) desirability))
  (send self :recompute-all-routes))


(defmethod (:set-appropriate-subnets-for-gateway ip-protocol) (gateway subnet-numbers)
  (let ((subnets (loop for subnet in subnet-numbers
		       collect (ip-get-subnet subnet))))
    (maphash #'(lambda (ignore subnet)
		 (let ((elem (assoc gateway (ip-subnet-gateways subnet))))
		   (if (member subnet subnets)
		       (unless elem
			 (push (list gateway 1000) (ip-subnet-gateways subnet)))
		       (when elem
			 (setf (ip-subnet-gateways subnet)
			       (delete elem (ip-subnet-gateways subnet)))))))
	     subnet-hash-table))
  (send self :recompute-all-routes))

(defmethod (:get-appropriate-subnets-for-self ip-protocol) (wrt-gateway)
  (let ((wrt-interface (ip-route-interface wrt-gateway))
	(collection nil))
    (maphash #'(lambda (ignore subnet)
		 (unless (loop for (gateway) in (ip-subnet-gateways subnet)
			       thereis (eq (ip-route-interface gateway) wrt-interface)
			       always (ip-gateway-dead gateway))
		   (push (ip-subnet-number subnet) collection)))
	     subnet-hash-table)
    collection))

1;;; This changes the route to try other addresses upon failure if the host has any other 
;;; addresses.
0(defmethod (:report-failing-route ip-protocol) (route foreign-address)
  (when (compare-internet-address foreign-address (first (ip-route-foreign-addresses route)))
    (setf (ip-route-foreign-addresses route)
	  (append (rest (ip-route-foreign-addresses route)) (list foreign-address))))
  nil)


(defmethod (:icmp-redirect ip-protocol) (complainer pkt gateway-address host-only)
  (let ((destination (load-internet-address pkt 16))
	(gateway-route (send self :route-to-address gateway-address)))
    (cond ((or (not (compare-internet-address
		      (internet-subnet-number-internal gateway-address)
		      (internet-subnet-number-internal complainer)))
	       (compare-internet-address gateway-address complainer))
	   (ip-notify nil "Bad redirect received from ~A to ~A."
		      (unparse-internet-address complainer)
		      (unparse-internet-address gateway-address)))
	  (host-only
	   (let ((route (send self :route-to-address destination)))
	     (if (and (compare-internet-address (ip-route-gateway-address route)
						complainer)
		      (eq (ip-route-interface gateway-route) (ip-route-interface route)))
		 (progn (ip-notify nil "Redirecting Internet route ~A to go via ~A"
				   route (unparse-internet-address gateway-address))
			(setf (ip-route-gateway-address route) gateway-address)
			(setf (ip-route-source route) :redirect))
		 (ip-notify nil "Bad redirect received from ~A."
			    (unparse-internet-address complainer)))))
	  (t (let ((subnet (ip-get-subnet destination)))
	       (loop for gwe in (ip-subnet-gateways subnet)
		     for (gateway) = gwe
		     when (and (ip-route-gateway-address gateway)
			       (eq (ip-route-interface gateway-route)
				   (ip-route-interface gateway))
			       (compare-internet-address
				 complainer (ip-route-gateway-address gateway)))
		       do
			 (setf (ip-subnet-gateways subnet)
			       (cons (list (ip-get-gateway (ip-route-interface gateway)
							   gateway-address)
					   1001)
				     (delete gwe (ip-subnet-gateways subnet))))
			 (ip-notify nil "Changing Internet subnet route for ~A to go via ~A instead of ~A."
				    (unparse-internet-address (ip-subnet-number subnet))
				    (unparse-internet-address gateway-address)
				    (unparse-internet-address complainer))
			 (send self :recompute-all-routes)
			 (return)
		     finally (ip-notify nil
					"Unexpected redirect of ~A to ~A received from ~A."
					(unparse-internet-address destination)
					(unparse-internet-address gateway-address)
					(unparse-internet-address complainer)))))))
  nil)

;;; Debugging

(defselect ((ip-route named-structure-invoke))
  (:print-self (route stream ignore ignore)
   (si:printing-random-object (route stream :typep :no-pointer)
     (format stream "~@[~A ~]~A via ~A"
	     (ip-route-foreign-host route)
	     (mapcar #'unparse-internet-address
		     (ip-route-foreign-addresses route))
	     (ip-peek-routing-gateway-address route)))))

(defselect ((ip-subnet named-structure-invoke))
  (:print-self (subnet stream ignore ignore)
   (si:printing-random-object (subnet stream :typep :no-pointer)
     (format stream "~A"
	     (ip-peek-subnet-name (send (ip-subnet-ip subnet) :network)
				  (ip-subnet-number subnet))))))

(defselect ((ip-gateway named-structure-invoke))
  (:print-self (gateway stream ignore ignore)
   (si:printing-random-object (gateway stream :typep :no-pointer)
     (if (ip-route-gateway-address gateway)
	 (format stream "~@[~A ~]~A"
		 (ip-route-foreign-host gateway)
		 (unparse-internet-address (ip-route-gateway-address gateway)))
	 (format stream "LOCAL")))))

(defmethod 2(:peek-routing ip-protocol)0 ()
  (list ()
	(tv:scroll-parse-item "")
	(tv:scroll-parse-item "Interfaces:")
	(tv:scroll-maintain-list
	  #'(lambda () interface-list)
	  #'(lambda (interface) (ip-peek-interface interface network)))

	(tv:scroll-parse-item "")
	(tv:scroll-maintain-list
	  #'(lambda () (list (rest interface-list)))
	  #'(lambda (ignore) (ip-peek-default-gateway self)))
	
	(tv:scroll-parse-item "")
	(tv:peek-hidden-data
	  "Click to add/remove detailed information."
	  (tv:scroll-maintain-list
	    #'(lambda ()
		(si:eliminate-duplicates
		  (loop for route being the hash-elements of route-hash-table
			collect route)))
	    #'ip-peek-route)
	  "Host Routing:")
	
	(tv:scroll-parse-item "")
	(tv:peek-hidden-data
	  "Click to add/remove detailed information."
	  (tv:scroll-maintain-list
	    #'(lambda ()
		(sort (loop for subnet being the hash-elements of subnet-hash-table
			    unless (integerp subnet)
			    collect subnet)
		      #'ip-sort-by-address))
	    #'ip-peek-subnet)
	  "Subnet Routing:")))

(defun ip-peek-interface (interface network)
  (list ()
	(tv:scroll-parse-item "")
	(tv:scroll-parse-item
	  (format nil "~A at ~A on ~S"
		  (ip-peek-subnet-name network
				       (ip-interface-subnet-number interface))
		  (unparse-internet-address (ip-interface-local-address interface))
		  (ip-interface-instance interface)))
	(tv:scroll-maintain-list
	  #'(lambda () (ip-interface-prime-gateways interface))
	  #'ip-peek-gateway)))
(defmethod 2(ip-peek-default-gateway ip-protocol)0 ()
  (tv:scroll-maintain-list
    #'(lambda () (list default-gateway))
    #'(lambda (gw)
	(list ()
	      (tv:scroll-parse-item
		(format nil "Default Gateway: ~@[~A ~]~@[~A ~]"
			gw (and gw (loop for (net addr nil) in (send gw :address)
					 when (internet-network-eql net network)
					 collect addr)))
		`(:function
		   ,#'(lambda (gate)
			(let ((gateway-obj
			       (and gate (loop for gateway being the hash-elements
						 of gateway-hash-table
					     when (eq gate (ip-gateway-foreign-host gateway))
					       return gateway))))
			  (cond ((not (ip-gateway-dead gateway-obj)) "Alive")
				((ip-interface-dynamic-p (ip-route-interface gateway-obj))
				 "Disconnected")
				(t "Dead"))))
		   (,gw) nil (" ~A")))))))


(defun ip-sort-by-address (s1 s2)
  (internet-address-lessp (ip-subnet-number s1) (ip-subnet-number s2)))

(defun ip-peek-subnet-name (network number)
  (let* ((snn (unparse-internet-address number))
	 (sn (assoc snn (send network :get :subnet) :test #'equal)))
    (format nil "~A~@[ (~A)~]:" snn
	    (when sn
	      (second (assoc :name (second sn)))))))

(defun ip-peek-subnet (subnet)
  (list ()
	(tv:scroll-parse-item
	  (ip-peek-subnet-name (send (ip-subnet-ip subnet) :network)
			       (ip-subnet-number subnet)))
	(tv:scroll-maintain-list
	  #'(lambda ()
	      (sort (ip-subnet-gateways subnet)
		    #'(lambda (g1 g2)
			(< (second g1) (second g2)))))
	  #'(lambda (entry) (ip-peek-gateway (first entry))))))

(defun ip-peek-route (route)
  (tv:scroll-parse-item
    (format nil "~@[~A ~]~A:"
	    (ip-route-foreign-host route)
	    (mapcar #'unparse-internet-address
		    (ip-route-foreign-addresses route)))
    `(:function ip-peek-routing-gateway-address (,route) nil (" via ~A"))
    `(:function ip-route-pkts-out (,route) nil ("  Out: ~5D"))
    ))

(defun ip-peek-routing-gateway-address (routing)
  (let ((address (ip-route-gateway-address routing))
	(interface (ip-route-interface routing)))
    (cond ((null interface) "UNKNOWN")
	  ((null address) "LOCAL")
	  ((compare-internet-address address *ip-broadcast-address*)
	   (format nil "BROADCAST (~A)"
		   (if (symbolp interface)
		       (string interface)
		       (unparse-internet-address (ip-interface-subnet-number interface)))))
	  (t (ip-address-host (send (ip-route-ip routing) :network)
			      (ip-route-gateway-address routing))))))

(defun ip-address-host (network address)
  (format nil "~A~@[ (~A)~]"
	  (send network :unparse-address address)
	  (net:get-host-from-address address network t)))

(defun ip-peek-gateway (gateway)
  (if (ip-route-gateway-address gateway)
      (tv:scroll-parse-item
	(format nil "  Gateway: ~@[~A ~]~A"
		(ip-route-foreign-host gateway)
		(unparse-internet-address (ip-route-gateway-address gateway)))
	`(:function ip-gateway-dead (,gateway) nil
		    ,(if (ip-interface-dynamic-p (ip-route-interface gateway))
			'("  ~:[Alive~;Disconnected~]")
			'("  ~:[Alive~;Dead~]")))
	`(:function ip-gateway-desirability (,gateway) nil ("  (desirability ~A)")))
      (tv:scroll-parse-item
	"  LOCAL")))

