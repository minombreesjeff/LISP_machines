;;; -*- Mode:LISP; Package:ZWEI; Base:8 -*-
;;; Lisp Machine mail reader
;;; Mailing commands and routines, definition are in DEFS
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;;; Compose and send a message

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-MAIL (STRING)
  (FORMAT STRING "Send a message: L: ~A; M: ~A; R: menu."
	  (SEND (FIND-TEMPLATE 'MAIL-TEMPLATE) ':MENU-NAME)
	  (NAME-FROM-MENU-VALUE *MAIL-MIDDLE-MODE* *ZMAIL-MAIL-MENU-ALIST*)))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *MAIL-MIDDLE-MODE* COM-ZMAIL-MAIL)
(ASSOCIATE-TEMPLATE-WITH-COMMAND-DOCUMENTATION MAIL-TEMPLATE COM-ZMAIL-MAIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-ZMAIL-LOCAL-MAIL *LOCAL-MAIL-DOCUMENTATION*)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-LOCAL-MAIL (STRING)
  (APPEND-TO-ARRAY STRING (SEND (FIND-TEMPLATE 'LOCAL-MAIL-TEMPLATE) ':DOCUMENTATION)))

(ASSOCIATE-TEMPLATE-WITH-COMMAND-DOCUMENTATION LOCAL-MAIL-TEMPLATE COM-ZMAIL-LOCAL-MAIL)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MAIL "Send a message.
Left gives normal mail.  Middle is normally Bug, but controlled by *MAIL-MIDDLE-MODE*.
Right gives a menu of Bug, Forward, Mail, Redistribute or Local.
Numeric argument of 1 summons up Redistribute,
Numeric argument of 3 or 4 gives Bug mail."
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (SET-ZMAIL-USER)
  (COMPOSE-FROM-TEMPLATE (CHOOSE-MAIL-TEMPLATE) ':MSGS (AND *MSG* (LIST *MSG*))))

;;; This is sort of a hybrid until we are totally switched over to templates
(DEFVAR *MAIL-TEMPLATE-ALIST*
  '((:BUG BUG-LISPM-TEMPLATE :BUG-REPORT "Send a bug report concerning" GET-BUG-ARG)
    (:MAIL MAIL-TEMPLATE :MAIL)
    (:FORWARD FORWARD-TEMPLATE :FORWARD)
    (:REDISTRIBUTE REDISTRIBUTE-TEMPLATE :REDISTRIBUTE)
    (:LOCAL LOCAL-MAIL-TEMPLATE :LOCAL-MAIL)
    ))

(DEFINE-ZMAIL-GLOBAL *LAST-BUG-REPORT-TEMPLATE* NIL)

(DEFINE-ZMAIL-GLOBAL *LAST-MAIL-TYPE-ITEM* NIL)

(DEFINE-ZMAIL-GLOBAL *MAIL-NUMERIC-ARG-ALIST*
  '((:REDISTRIBUTE . (1))
    (:BUG . (3 4))
    ))

(DEFUN CHOOSE-MAIL-TEMPLATE (&OPTIONAL MODE)
  (COND ((NULL MODE)
	 (LET ((OLD-*ZMAIL-COMMAND-BUTTON* *ZMAIL-COMMAND-BUTTON*))
	   (SETQ MODE (CHOOSE-MAIL-MODE))
	   (AND (EQ OLD-*ZMAIL-COMMAND-BUTTON* ':MIDDLE)
		(SETQ *ZMAIL-COMMAND-BUTTON* (IF (EQ MODE ':BUG) ':RIGHT ':LEFT))))))
  (LET* ((ELEM (ASSQ MODE *MAIL-TEMPLATE-ALIST*))
	 (DEFAULT (OR (AND (EQ MODE :BUG) *LAST-BUG-REPORT-TEMPLATE*)
		      (SECOND ELEM))))
    (LET ((TEMPLATE (CHOOSE-TEMPLATE-FOR-COMMAND (THIRD ELEM) DEFAULT (FOURTH ELEM))))
      (AND (FIFTH ELEM) (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION (FIFTH ELEM)))
      (WHEN (EQ MODE :BUG) (SETQ *LAST-BUG-REPORT-TEMPLATE* TEMPLATE))
      TEMPLATE)))

(DEFUN CHOOSE-MAIL-MODE (&OPTIONAL (TYPE ':MAIL))
  (COND (*NUMERIC-ARG-P*
	 (LOOP FOR (TYP . NUMS) IN *MAIL-NUMERIC-ARG-ALIST*
	       WHEN (MEMQ *NUMERIC-ARG* NUMS) RETURN TYP
	       FINALLY (BARF "A numeric arg of ~D does not mean anything."
			     *NUMERIC-ARG*)))
	(T
	 (WHEN (MEMQ *ZMAIL-COMMAND-BUTTON* '(:MIDDLE :RIGHT))
	   (MULTIPLE-VALUE (TYPE *LAST-MAIL-TYPE-ITEM*)
	     (ZMAIL-MENU-CHOOSE NIL *ZMAIL-MAIL-MENU-ALIST* *LAST-MAIL-TYPE-ITEM*
				NIL *MAIL-MIDDLE-MODE*)))
	 TYPE)))

(DEFUN COMPOSE-FROM-TEMPLATE (TEMPLATE &REST PLIST &AUX EXPANSION)
  (LET ((*RETAIN-COMMON-TAILS* T))
    (SETQ EXPANSION (LEXPR-FUNCALL #'EXPAND-TEMPLATE TEMPLATE PLIST))
    (FUNCALL-TEMPLATE-EXPANSION EXPANSION
				(OR (GET (LOCF EXPANSION) ':COMPOSITION-FUNCTION)
				    #'COMPOSE-VIA-DRAFT-MSG)
				EXPANSION)))

(DEFUN COMPOSE-VIA-DRAFT-MSG (TEMPLATE-EXPANSION)
  (LET ((DRAFT-MSG (MAKE-DRAFT-MSG-FROM-TEMPLATE TEMPLATE-EXPANSION)))
    (CONTINUE-DRAFT-MSG DRAFT-MSG)))

;;; Mail from inside mail
(DEFCOM-FOR-ZMAIL COM-ZMAIL-RECURSIVE-MAIL "Start composing another message" ()
  (ZMAIL-RECURSIVE-MAIL-INTERNAL)
  DIS-NONE)

(DEFUN ZMAIL-RECURSIVE-MAIL-INTERNAL ()
  (LET ((OLD-DRAFT-MSG *DRAFT-MSG*)
	(NEW-DRAFT-MSG (MAKE-DRAFT-MSG-FROM-TEMPLATE (EXPAND-TEMPLATE 'MAIL-TEMPLATE))))
    (UNWIND-PROTECT
	(CATCH 'SEND-IT
	  (SWAP-OUT-MSG-WINDOW)
	  (SEND OLD-DRAFT-MSG :SAVE-WINDOW-STATE)
	  (SEND NEW-DRAFT-MSG :SETUP-FOR-CONTINUE)
	  (SET-MAIL-WINDOW-CONFIGURATION (SEND NEW-DRAFT-MSG :LAST-WINDOW-CONFIGURATION)
					 (FIRST (FIRST (SEND NEW-DRAFT-MSG :WINDOW-POINTS)))
					 NIL)
	  (WITH-EDITOR-BINDINGS
	      (:COMTAB *REPLY-COMTAB*
	       :MODE-LINE-LIST `("Zmail " "Mail " "(" *MODE-NAME-LIST*
				 (*MODE-QUANTITY-NAME* " <" *MODE-QUANTITY-NAME* ">")
				 ") " *ZMAIL-INTERVAL-NAME*
				 (*STYLE-NAME* "  Style: " *STYLE-NAME*)
				 (*MACRO-LEVEL* "  Macro-level: " *MACRO-LEVEL*)
				 "   " *DRAFT-DISPOSITION-MODE-LINE-STRING* "   "
				 (*MODE-LINE-MORE-ABOVE-BELOW* "  "
							       *MODE-LINE-MORE-ABOVE-BELOW*)))
	    (USING-RESOURCE
	        (*DRAFT-DISPOSITION-MODE-LINE-STRING* DRAFT-DISPOSITION-MODE-LINE-STRING)
	      (SEND *CURRENT-COMMAND-LOOP* :EDIT))))
      (SWAP-OUT-MSG-WINDOW)
      (SEND NEW-DRAFT-MSG :SAVE-WINDOW-STATE)
      (FLUSH-DRAFT-IF-UNUSED NEW-DRAFT-MSG)
      (SEND OLD-DRAFT-MSG :SETUP-FOR-CONTINUE)
      (SET-MAIL-WINDOW-CONFIGURATION (SEND OLD-DRAFT-MSG :LAST-WINDOW-CONFIGURATION)
				     (FIRST (FIRST (SEND OLD-DRAFT-MSG :WINDOW-POINTS)))
				     NIL))))

;;; Forwarding
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-FORWARD "Forward current message" ()
  (COMPOSE-FROM-TEMPLATE (CHOOSE-MAIL-TEMPLATE ':FORWARD) ':MSGS (LIST *MSG*)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-FORWARD-ALL
				 "Forward all these messages to someone."
				 ()
  (CHECK-FOR-TOO-MANY-MSGS "forward")
  (COMPOSE-FROM-TEMPLATE (CHOOSE-MAIL-TEMPLATE ':FORWARD)
			 ':MSGS (LIST-SEQUENCE *SEQUENCE*)))

(DEFUN LIST-SEQUENCE (SEQUENCE)
  (LET* ((ARRAY (SEND SEQUENCE ':ARRAY))
	 (LENGTH (ARRAY-ACTIVE-LENGTH ARRAY))
	 (LIST (MAKE-LIST LENGTH)))
    (LOOP FOR I FROM 0 FOR L ON LIST
	  DO (RPLACA L (AREF ARRAY I)))
    LIST))

;;; Note the following is a synonym for COM-ZMAIL-BUG and must stay in step with it.
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REPORT-BUG
				"Send a bug report.  (Synonym for Bug.)"
				(NO-SEQUENCE-OK)
  (COM-ZMAIL-BUG))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-BUG "Send a bug report" (NO-SEQUENCE-OK)
  (COMPOSE-FROM-TEMPLATE
    (CHOOSE-TEMPLATE-FOR-COMMAND ':BUG-REPORT NIL "Send a bug report concerning")))

;;;; Replying

;;; Send a reply
(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-REPLY (STRING &OPTIONAL RECURSIVE)
  (OR RECURSIVE (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'NORMAL-REPLY NIL T))
  (STRING-NCONC STRING "Reply to current message: "
		(GET 'NORMAL-REPLY ':WHO-LINE-DOCUMENTATION)))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER NORMAL-REPLY (STRING &OPTIONAL RECURSIVE)
  (APPEND-TO-ARRAY STRING "L: ")
  (APPEND-TO-ARRAY STRING (SEND (FIND-TEMPLATE 'REPLY-TEMPLATE) ':MENU-NAME))
  ;; This is just for initialization, since this function is called when REPLY-TEMPLATE
  ;; is first defined, before REPLY-MIDDLE-TEMPLATE is defined.
  (LET ((TEMP (FIND-TEMPLATE 'REPLY-MIDDLE-TEMPLATE T)))
    (COND (TEMP
	   (APPEND-TO-ARRAY STRING "; M: ")
	   (APPEND-TO-ARRAY STRING (SEND TEMP ':MENU-NAME)))))
  (LET ((TEMP (FIND-TEMPLATE 'REPLY-RIGHT-TEMPLATE T)))
    (COND (TEMP
	   (APPEND-TO-ARRAY STRING "; R: ")
	   (APPEND-TO-ARRAY STRING (SEND TEMP ':MENU-NAME)))))
  (OR RECURSIVE
      (DOLIST (COM '(COM-ZMAIL-REPLY COM-ZMAIL-REPLY-ALL SUMMARY-REPLY-DOCUMENTATION))
	(UPDATE-COMMAND-WHO-LINE-DOCUMENTATION COM NIL T))))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *REPLY-MODE* NORMAL-REPLY)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *REPLY-WINDOW-MODE* NORMAL-REPLY)
(ASSOCIATE-TEMPLATE-WITH-COMMAND-DOCUMENTATION REPLY-TEMPLATE NORMAL-REPLY)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *MIDDLE-REPLY-MODE* NORMAL-REPLY)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *MIDDLE-REPLY-WINDOW-MODE* NORMAL-REPLY)
(ASSOCIATE-TEMPLATE-WITH-COMMAND-DOCUMENTATION REPLY-MIDDLE-TEMPLATE NORMAL-REPLY)
(ASSOCIATE-TEMPLATE-WITH-COMMAND-DOCUMENTATION REPLY-RIGHT-TEMPLATE NORMAL-REPLY)

(DEFVAR *ZMAIL-REPLY-PROCESSING-LIST* '(DRAFT-REPLY FAILED-MAIL-REPLY NORMAL-REPLY))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REPLY "Reply to current message.
Left uses REPLY-TEMPLATE, middle REPLY-MIDDLE-TEMPLATE.
Right gives a menu of reply templates.
Numeric argument of 1 replies according to 1R-REPLY-TEMPLATE
Numeric argument of 3 or 4 uses 3R-REPLY-TEMPLATE, which yanks in message.
Failed messages from the mailer or draft messages are treated specially." (NUMERIC-ARG-OK)
  (LOOP FOR METHOD IN *ZMAIL-REPLY-PROCESSING-LIST*
	THEREIS (FUNCALL METHOD *MSG*)
	FINALLY (FERROR "Reply was not processed."))
  DIS-NONE)

(DEFINE-ZMAIL-GLOBAL *REPLY-NUMERIC-ARG-ALIST*
  '((1R-REPLY-TEMPLATE . (1))
    (3R-REPLY-TEMPLATE . (3 4))
    ))

(DEFUN NORMAL-REPLY (&REST MSGS)
  (NORMAL-REPLY-INTERNAL (COPYLIST MSGS))
  T)

(DEFUN NORMAL-REPLY-INTERNAL (MSGS)
  (FLET ((FIND-TEMPLATE-NAMED (NAME)
	   (LOOP FOR TEMPLATE IN *TEMPLATES*
		 WHEN (STRING-EQUAL NAME (SEND TEMPLATE :NAME))
		   RETURN TEMPLATE)))
    (LET ((TEMPLATE (COND (*NUMERIC-ARG-P*
			   (LOOP FOR (TEMPLATE . NUMBERS) IN *REPLY-NUMERIC-ARG-ALIST*
				 WHEN (MEMBER *NUMERIC-ARG* NUMBERS)
				   RETURN TEMPLATE
				 FINALLY
				   (BARF "A numeric arg of ~D has no meaning to Reply."
					 *NUMERIC-ARG*)))
			  ((EQ *ZMAIL-COMMAND-BUTTON* :MIDDLE)
			   'REPLY-MIDDLE-TEMPLATE)
			  ((EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
			   'REPLY-RIGHT-TEMPLATE)
			  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Check for Template-for-Reply fields ...
0			  ((DOLIST (MSG MSGS)
			     (LET* ((TFR-NAME
				      (GET (ASSURE-MSG-PARSED MSG) :TEMPLATE-FOR-REPLY))
				    (TFR (WHEN TFR-NAME
					   (IF (LISTP TFR-NAME)
					       (FIND-TEMPLATE-NAMED (FIRST TFR-NAME))
					     (FIND-TEMPLATE-NAMED TFR-NAME)))))
			       (WHEN TFR
				 (RETURN TFR)))))
			  1;; Default
0			  (T 'REPLY-TEMPLATE))))
      (COMPOSE-FROM-TEMPLATE TEMPLATE :MSGS MSGS))))

;;; Special "reply" methods
(DEFUN DRAFT-REPLY (MSG)
  (COND ((MSG-DRAFT-MSG-P MSG)
	 (CONTINUE-DRAFT-MSG (MAKE-DRAFT-MSG-FROM-MSG MSG))
	 T)))

(DEFUN FAILED-MAIL-REPLY (MSG)
  (MULTIPLE-VALUE-BIND (SUCCESS FAILED-MSG-START-BP END-BP FAILED-RECIPIENTS)
      (MSG-MAILER-REJECTION-P MSG)
    (WHEN SUCCESS
      (FAILED-MAILER-RETRY MSG FAILED-MSG-START-BP END-BP FAILED-RECIPIENTS)))) 

(DEFVAR *FAILED-MAIL-PREDICATES* '(LISPM-MAILER-REJECTION-P XMAILR-REJECTION-P
				   COMSAT-REJECTION-P UNIX-MAILER-REJECTION-P)) 

(DEFUN MSG-MAILER-REJECTION-P (MSG)
  (DECLARE (VALUES SUCCESS FAILED-MSG-START-BP END-BP FAILED-RECIPIENTS))
  (DOLIST (PREDICATE *FAILED-MAIL-PREDICATES*)
    (MULTIPLE-VALUE-CALL (LAMBDA (SUCCESS &REST OTHER-VALUES)
			   (WHEN SUCCESS
			     (RETURN (LEXPR-FUNCALL #'VALUES SUCCESS OTHER-VALUES))))
			 (FUNCALL PREDICATE MSG)))) 

(DEFUN COMSAT-REJECTION-P (MSG &AUX START-BP END-BP FAILED-MSG-START-BP FAILED-RECIPIENTS)
  (WHEN (AND (LET ((FROM (CAR (MSG-GET MSG :FROM))))
	       (EQUAL (GET (LOCF FROM) :NAME) "COMSAT"))
	     (SETQ FAILED-MSG-START-BP
(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")	0	   (OR (SEARCH (SETQ START-BP (MSG-START-BP MSG))
			       "
============ Failed message follows: ============
"
			       NIL NIL NIL (SETQ END-BP (MSG-END-BP MSG)))
		       (SEARCH (SETQ START-BP (MSG-START-BP MSG))
			       "
 Failed message follows:
-------
"
			       NIL NIL NIL END-BP))))
    (DO ((LINE (BP-LINE START-BP) (LINE-NEXT LINE))
	 (END-LINE (BP-LINE FAILED-MSG-START-BP))
	 (IDX))
	((EQ LINE END-LINE))
      (FLET ((ADD-FAILED-RECIPIENT (START END)
	       (LET ((NEW-FAILED-RECIPIENTS
		       (CONDITION-CASE ()
			    (PARSE-ADDRESSES LINE START END)
			  (PARSE-ERROR
			    1;; If we can't parse the text that should be a failed recipient,
0			    1;; we'll just include it as a literal address and let the user
0			    1;; edit it appropriately.
0			    `((:NAME
				,(STRING-TRIM *WHITESPACE-CHARS* (SUBSTRING LINE START END)))))
			  )))
		 (SETQ FAILED-RECIPIENTS (APPEND FAILED-RECIPIENTS NEW-FAILED-RECIPIENTS)))))
	(COND ((AND (STRING-EQUAL-START LINE "FAILED: ")
		    (DO ((IDX1 NIL)) (NIL)
		      (OR (AND (SETQ IDX (STRING-REVERSE-SEARCH-CHAR #/; LINE IDX1))
			       (SETQ IDX1 (STRING-REVERSE-SEARCH-CHAR #\SP LINE IDX)))
			  (RETURN NIL))
		      (AND (STRING-EQUAL LINE " at " (- IDX1 3) 0 (1+ IDX1))
			   (RETURN T))))
	       (ADD-FAILED-RECIPIENT 7 IDX))
	      ((SETQ IDX (STRING-SEARCH " is an unknown recipient." LINE))
	       (ADD-FAILED-RECIPIENT 0 IDX)))))
    (VALUES T FAILED-MSG-START-BP END-BP FAILED-RECIPIENTS)))

(DEFUN XMAILR-REJECTION-P (MSG &AUX FAILED-RECIPIENTS-START-BP FAILED-MSG-START-BP
			      FAILED-RECIPIENTS FAILED-MSG-END-BP)
  (WHEN (AND (LET ((FROM (CAR (MSG-GET MSG :FROM))))
	       (EQUAL (GET (LOCF FROM) :PERSONAL-NAME) "The Mailer Daemon"))
	     (SETQ FAILED-RECIPIENTS-START-BP (SEARCH (MSG-START-BP MSG)
						      "
Message "
						      NIL NIL NIL (MSG-END-BP MSG)))
	     (LET ((LINE (BP-LINE FAILED-RECIPIENTS-START-BP)))
	       (OR (STRING-EQUAL LINE "Message failed for the following:")
		   (STRING-EQUAL-START LINE "Message undeliverable ")))
	     (SETQ FAILED-MSG-START-BP
		   (OR (SEARCH FAILED-RECIPIENTS-START-BP
			       "
	    ------------
"
			       NIL NIL NIL (MSG-END-BP MSG))
		       (SEARCH FAILED-RECIPIENTS-START-BP
			       "
            ------------
"
			       NIL NIL NIL (MSG-END-BP MSG)))))
    (DO ((LINE (LINE-NEXT (BP-LINE FAILED-RECIPIENTS-START-BP)) (LINE-NEXT LINE))
	 (END-LINE (LINE-PREVIOUS (BP-LINE FAILED-MSG-START-BP))))
	((EQ LINE END-LINE))
      (SETQ FAILED-RECIPIENTS
	    (APPEND FAILED-RECIPIENTS
		    (CONDITION-CASE ()
			 (LET* ((PARSED (RFC733-LEXER LINE))
				(COLON (ASSQ 'COLON PARSED))
				(END-OF-ADDRESSES (IF COLON (BP-INDEX (THIRD COLON))
						    (STRING-SEARCH-CHAR #/: LINE))))
			   (WHEN END-OF-ADDRESSES
			     (PARSE-ADDRESSES LINE 0 END-OF-ADDRESSES)))
		       (PARSE-ERROR
			 1;; If we can't parse a line that should contain a failed recipient,
0			 1;; we'll include the entire line as a literal address and let the
0			 1;; user edit it appropriately.
0			 `((:NAME ,(STRING-TRIM *WHITESPACE-CHARS* LINE))))))))
    (DO ((LINE (BP-LINE (MSG-END-BP MSG)) PLINE)
	 (PLINE))
	((NOT (STRING-EQUAL (SETQ PLINE (LINE-PREVIOUS LINE)) "-------"))
	 (SETQ FAILED-MSG-END-BP (CREATE-BP LINE 0))))
    (VALUES T FAILED-MSG-START-BP FAILED-MSG-END-BP FAILED-RECIPIENTS)))

(DEFUN LISPM-MAILER-REJECTION-P (MSG &AUX FAILED-RECIPIENTS-START-BP FAILED-MSG-START-BP
					  FAILED-RECIPIENTS FAILED-MSG-END-BP)
  (WHEN (AND (EQUAL (MSG-GET MSG :SUBJECT) "Unable to deliver letter")
	     (LET ((FROM (CAR (MSG-GET MSG :FROM))))
	       (EQUAL (GET (LOCF FROM) :NAME) "Postmaster"))
	     (SETQ FAILED-RECIPIENTS-START-BP (SEARCH (MSG-START-BP MSG)
						      "
Unable to deliver letter to the following recipient"
						      NIL NIL NIL (MSG-END-BP MSG)))
	     (SETQ FAILED-MSG-START-BP (SEARCH FAILED-RECIPIENTS-START-BP
					       "
----- Text of letter follows -----
"
					       NIL NIL NIL (MSG-END-BP MSG))))
    (DO ((LINE (LINE-NEXT (BP-LINE FAILED-RECIPIENTS-START-BP)) (LINE-NEXT LINE))
	 (END-LINE (LINE-PREVIOUS (BP-LINE FAILED-MSG-START-BP))))
	((EQ LINE END-LINE))
      1;; Failure reasons are multi-line so we must be more specific as to which
0      1;; lines we'll try to parse for recipients.  In particular, we'll only look
0      1;; at lines which start with exactly two spaces and contain a colon somewhere.
0      1;; (LispM mailer rejection lines are of the form 0"  ADDRESS:~%    ~REASON~"1).
0      (WHEN (AND (> (LINE-LENGTH LINE) 4)
		 (CHAR-EQUAL (AREF LINE 0) #\Space)
		 (CHAR-EQUAL (AREF LINE 1) #\Space)
		 (CHAR-NOT-EQUAL (AREF LINE 2) #\Space)
		 (STRING-SEARCH-CHAR #/: LINE))
	(SETQ FAILED-RECIPIENTS
	      (APPEND FAILED-RECIPIENTS
		      (CONDITION-CASE ()
			   (LET* ((PARSED (RFC733-LEXER LINE))
				  (COLON (ASSQ 'COLON PARSED))
				  (END-OF-ADDRESSES (IF COLON (BP-INDEX (THIRD COLON))
						      (STRING-SEARCH-CHAR #/: LINE))))
			     (WHEN END-OF-ADDRESSES
			       (PARSE-ADDRESSES LINE 0 END-OF-ADDRESSES)))
			 (PARSE-ERROR
			   1;; If we can't parse a line that should contain a failed recipient,
0			   1;; we'll include the entire line as a literal address and let the
0			   1;; user edit it appropriately.
0			   `((:NAME ,(STRING-TRIM *WHITESPACE-CHARS* LINE)))))))))
    (SETQ FAILED-MSG-END-BP (MSG-END-BP MSG))
    (VALUES T FAILED-MSG-START-BP FAILED-MSG-END-BP FAILED-RECIPIENTS)))

(DEFUN UNIX-MAILER-REJECTION-P (MSG &AUX FAILED-RECIPIENTS-START-BP FAILED-MSG-START-BP
					 FAILED-RECIPIENTS FAILED-MSG-END-BP)
  (WHEN (AND (LET* ((SUBJECT (MSG-GET MSG :SUBJECT))
		    (SUBJECT-TEXT (IF (STRINGP SUBJECT) SUBJECT (OR (FIRST SUBJECT) ""))))
	       (OR (EQUAL SUBJECT-TEXT "Unable to deliver mail")
		   (STRING-SEARCH "Returned mail" SUBJECT-TEXT)))
	     (LET* ((FROM (FIRST (MSG-GET MSG :FROM)))
		    (NAME (CL:GETF FROM :NAME)))
	       (AND NAME (STRING-SEARCH "MAILER-DAEMON" NAME)))
	     (SETQ FAILED-RECIPIENTS-START-BP (SEARCH (MSG-START-BP MSG)
						      "
   ----- Transcript of session follows -----"
						      NIL NIL NIL (MSG-END-BP MSG)))
	     (SETQ FAILED-MSG-START-BP (SEARCH FAILED-RECIPIENTS-START-BP
					       "
   ----- Unsent message follows -----
"
					       NIL NIL NIL (MSG-END-BP MSG))))
    (DO ((LINE (LINE-NEXT (BP-LINE FAILED-RECIPIENTS-START-BP)) (LINE-NEXT LINE))
	 (END-LINE (LINE-PREVIOUS (BP-LINE FAILED-MSG-START-BP))))
	((EQ LINE END-LINE))
      (LET ((END-OF-ADDRESSES (STRING-SEARCH "..." LINE)))
	(WHEN END-OF-ADDRESSES
	  (SETQ FAILED-RECIPIENTS
		(APPEND FAILED-RECIPIENTS
			(CONDITION-CASE ()
			     (PARSE-ADDRESSES LINE 0 END-OF-ADDRESSES)
			   (PARSE-ERROR
			     1;; If we can't parse a line that should contain a failed
0			     1;; recipient, we'll include the entire line as a literal
0			     1;; address and let the user edit it appropriately.
0			     `((:NAME ,(STRING-TRIM *WHITESPACE-CHARS* LINE))))))))))
    (SETQ FAILED-MSG-END-BP (MSG-END-BP MSG))
    (VALUES T FAILED-MSG-START-BP FAILED-MSG-END-BP FAILED-RECIPIENTS)))

;;; These headers do not come over from the enclosed failed message
(DEFVAR *FAILED-RETRY-IGNORED-HEADERS*
  '(:DATE :SENDER :TO :CC :BCC :FCC :BFCC :MESSAGE-ID
    :CHARACTER-STYLES :CHARACTER-TYPE-MAPPINGS :DEFAULT-CHARACTER-STYLE :FONTS :JAPANESE
    :REDISTRIBUTED-DATE :REDISTRIBUTED-BY :REDISTRIBUTED-TO
    :REMAILED-DATE :REMAILED-FROM :REMAILED-TO
    :RESENT-DATE :RESENT-FROM :RESENT-BY :RESENT-SENDER :RESENT-REPLY-TO
    :RESENT-TO :RESENT-CC :RESENT-BCC :RESENT-COMMENTS :RESENT-MESSAGE-ID
    :RETURN-PATH :RECEIVED :RECEIVED-DATE :MAIL-FROM))

(DEFUN FAILED-MAILER-RETRY (MSG START-BP END-BP RECIPIENTS
			    &KEY (SUPERSEDES T)
				 (COMMENTS "Retransmission of failed mail.")
				 TRANSMIT-IMMEDIATELY)
  (MULTIPLE-VALUE-BIND (HEADERS START-BP)
      (PARSE-ITS-MSG-HEADERS START-BP END-BP T)
    (WHEN (LOOP FOR TYPE IN '(:DEFAULT-CHARACTER-STYLE :CHARACTER-TYPE-MAPPINGS
			      :CHARACTER-STYLES :FONTS :JAPANESE)
		THEREIS (CL:GETF HEADERS TYPE))
      (MULTIPLE-VALUE (START-BP END-BP)
	(FATTEN-FAILED-MAIL HEADERS START-BP END-BP T)))
    (WHEN (EQ SUPERSEDES :ASK)
      (SETQ SUPERSEDES (TYPEOUT-BEEP-YES-OR-NO-P "Do you wish to add a Supersedes header? ")))
    (WHEN SUPERSEDES
      (SETQ SUPERSEDES (GENERATE-REFERENCE-HEADER-FROM-HEADERS HEADERS)))
    (LOOP FOR (TYPE VALUE) ON HEADERS BY 'CDDR
	  UNLESS (COND ((EQ TYPE :FROM)
			(AND (= (LENGTH VALUE) 1)
			     (EQUAL USER-ID (CL:GETF (FIRST VALUE) :NAME))))
		       ((MEMQ TYPE *FAILED-RETRY-IGNORED-HEADERS*))
		       ((NOT (KEYWORDP TYPE))))
	    COLLECT TYPE INTO ADDITIONAL AND COLLECT VALUE INTO ADDITIONAL
	  FINALLY
	    (SETQ HEADERS (NCONC `(:TO ,RECIPIENTS) ADDITIONAL)))
    (WHEN SUPERSEDES
      (SETF (CL:GETF HEADERS :SUPERSEDES) (NCONC (CL:GETF HEADERS :SUPERSEDES)
						 (NCONS SUPERSEDES))))
    (WHEN COMMENTS
      (SETF (CL:GETF HEADERS :COMMENTS) (MERGE-COMMENTS (CL:GETF HEADERS :COMMENTS) COMMENTS)))
    (LET ((DRAFT-MSG (LET ((*RETAIN-COMMON-TAILS* T))
		       (MAKE-DRAFT-MSG-FROM-TEMPLATE
			 `(:MSGS-BEING-REPLIED-TO (,MSG)
			   :HEADERS ,HEADERS
			   :STARTING-POINT ((:HEADERS :TO 4))
			   :TEXT ,(COPY-INTERVAL START-BP END-BP T))))))
      (RESTORE-DRAFT-MSG DRAFT-MSG :TRANSMIT-IMMEDIATELY TRANSMIT-IMMEDIATELY))
    T))

(DEFUN FATTEN-FAILED-MAIL (HEADERS START-BP &OPTIONAL END-BP IN-ORDER-P)
  1;; Must make a copy of the interval to avoid changing the original message.
0  (LET ((NEW-INTERVAL (COPY-INTERVAL START-BP END-BP IN-ORDER-P)))
    (LET ((START-BP (INTERVAL-FIRST-BP NEW-INTERVAL))
	  (END-BP (INTERVAL-LAST-BP NEW-INTERVAL)))
      (EPSILON-DECODE-MSG HEADERS NIL NIL NIL START-BP END-BP T)
      (VALUES START-BP END-BP))))

;;; This definition is new; it really goes next to the definition of the
;;; restore draft message command, but that isn't in non-CP zmail yet.
(DEFUN RESTORE-DRAFT-MSG (DRAFT-MSG &KEY TRANSMIT-IMMEDIATELY)
  (IF TRANSMIT-IMMEDIATELY
      (SEND DRAFT-MSG :CONTINUE-AND-TRANSMIT)
      (CONTINUE-DRAFT-MSG DRAFT-MSG)))

;;;; Draft messages and Continue command

1;;; All drafts are built on this.
0(DEFFLAVOR BASIC-DRAFT-MSG
	(HEADERS
	 (HEADERS-HANDLED NIL)
	 TRANSMIT-TEMPLATES
	 (TRANSMIT-TIMESTAMP NIL)
	 (DEFAULT-CHARACTER-STYLE *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)
	 (RECIPIENTS-DONE NIL)
	 (DISPOSITION-SUMMARIES NIL)
	 (PROMPTED-HEADERS NIL))
	()
  (:GETTABLE-INSTANCE-VARIABLES HEADERS TRANSMIT-TIMESTAMP DEFAULT-CHARACTER-STYLE
				RECIPIENTS-DONE DISPOSITION-SUMMARIES PROMPTED-HEADERS)
  (:INITABLE-INSTANCE-VARIABLES HEADERS DEFAULT-CHARACTER-STYLE)
  (:SETTABLE-INSTANCE-VARIABLES DEFAULT-CHARACTER-STYLE))

;;; Drafts whose text and headers are in an editor (so that point can be position to them).
(DEFFLAVOR EDITOR-DRAFT-MSG-MIXIN () ()
  (:REQUIRED-FLAVORS BASIC-DRAFT-MSG))

1;;; Drafts that come from a Zmail command.
0(DEFFLAVOR COMMAND-DRAFT-MSG-MIXIN
	((MSGS-BEING-REPLIED-TO NIL)		;If from reply command
	 (MSGS-BEING-FORWARDED NIL)		;If from forward command
	 (BUG-REPORT NIL)			;This was a bug report
	 (TRANSMIT-TEMPLATES '((BCC-TRANSMIT-TEMPLATE :BCC)
			       (NORMAL-TRANSMIT-TEMPLATE . :RECIPIENT)
			       (FCC-TRANSMIT-TEMPLATE . :FILE-RECIPIENT))))
	()
  (:INITABLE-INSTANCE-VARIABLES MSGS-BEING-REPLIED-TO)
  (:GETTABLE-INSTANCE-VARIABLES MSGS-BEING-REPLIED-TO BUG-REPORT)
  (:REQUIRED-FLAVORS BASIC-DRAFT-MSG)
  (:INIT-KEYWORDS :TEMPLATE-EXPANSION))

1;;; Normal Zmail draft message -- (I.e., drafts created by 0Mail1, 0Reply1, 0Forward1, etc.)
0(DEFFLAVOR DRAFT-MSG
	(HEADER-INTERVAL			1;Headers of message.
0	 REPLY-INTERVAL				1;Body of text.
0	 (CREATION-TICK 0)			1;Used to determine if we're a worthless draft.
0	 (SUMMARY-STRING "Empty")		1;For 0Continue1 command.
0	 (SUMMARY-STRING-TICK *TICK*)		1;When last valid.
0	 (SENT-P NIL)				1;Sent successfully.
0	 (LAST-WINDOW-CONFIGURATION ':MAIL)	1;Value of 2*window-configuration*1 when done.
0	 (PATHNAME NIL)				1;When saved out in a file.
0	 (MSG NIL)				1;In which it is saved.
0	 (WINDOW-POINTS NIL)			1;Saved positions in the various windows.
0	 (HEADER-WINDOW-NLINES *HEADER-WINDOW-NLINES*)
	 UNDO-ENTRY
	 )
	(ZMAIL-MSG-NODE COMMAND-DRAFT-MSG-MIXIN EDITOR-DRAFT-MSG-MIXIN BASIC-DRAFT-MSG)
  (:INITABLE-INSTANCE-VARIABLES LAST-WINDOW-CONFIGURATION)
  (:GETTABLE-INSTANCE-VARIABLES HEADER-INTERVAL REPLY-INTERVAL CREATION-TICK SENT-P
				LAST-WINDOW-CONFIGURATION WINDOW-POINTS HEADER-WINDOW-NLINES)
  (:SETTABLE-INSTANCE-VARIABLES PATHNAME MSG))

(DEFUN MAKE-DRAFT-MSG (&REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-INSTANCE 'DRAFT-MSG OPTIONS))

(DEFUN MAKE-DRAFT-MSG-FROM-TEMPLATE (TEMPLATE-EXPANSION)
  (MAKE-DRAFT-MSG ':TEMPLATE-EXPANSION TEMPLATE-EXPANSION))

(DEFMETHOD (:INIT COMMAND-DRAFT-MSG-MIXIN :AFTER) (PLIST)
  (LOOP FOR (KEY VAL) ON (GET PLIST ':TEMPLATE-EXPANSION) BY 'CDDR
	DO (SELECTQ KEY
	     (:MSGS-BEING-REPLIED-TO
	      (SETQ MSGS-BEING-REPLIED-TO VAL))
	     (:MSGS-BEING-FORWARDED
	      (SETQ MSGS-BEING-FORWARDED VAL))
	     (:BUG-REPORT
	      (SETQ BUG-REPORT VAL))
	     (:TRANSMIT-TEMPLATES
	      (SETQ TRANSMIT-TEMPLATES VAL))
	     (:DEFAULT-CHARACTER-STYLE
	      (SETQ DEFAULT-CHARACTER-STYLE VAL))
	     )))

(DEFMETHOD (:INIT DRAFT-MSG :AFTER) (PLIST)
  (LET* ((LINE (CREATE-LINE 'ART-STRING 0 SELF)))
    (SETQ FIRST-BP (CREATE-BP LINE 0 :NORMAL SELF)
	  LAST-BP (CREATE-BP LINE 0 :MOVES SELF))
    (INSERT LAST-BP #\CR)
    (SETQ HEADER-INTERVAL (MAKE-INSTANCE 'ZMAIL-INTERVAL :FIRST-BP (COPY-BP FIRST-BP :NORMAL)
							 :LAST-BP (COPY-BP FIRST-BP :MOVES)
							 :NAME "Headers")
	  REPLY-INTERVAL (MAKE-INSTANCE 'ZMAIL-INTERVAL :FIRST-BP (COPY-BP LAST-BP :NORMAL) 
							:LAST-BP (COPY-BP LAST-BP :MOVES)
							:NAME "Mail"))
    (SETF (LINE-NODE (BP-LINE FIRST-BP)) HEADER-INTERVAL)
    (SETF (LINE-NODE (BP-LINE LAST-BP)) REPLY-INTERVAL)
    (SETF (NODE-SUPERIOR HEADER-INTERVAL) SELF)
    (SETF (NODE-SUPERIOR REPLY-INTERVAL) SELF)
    (SETF (BP-BUFFER-INTERNAL (INTERVAL-FIRST-BP HEADER-INTERVAL)) HEADER-INTERVAL)
    (SETF (BP-BUFFER-INTERNAL (INTERVAL-LAST-BP HEADER-INTERVAL)) HEADER-INTERVAL)
    (SETF (BP-BUFFER-INTERNAL (INTERVAL-FIRST-BP REPLY-INTERVAL)) REPLY-INTERVAL)
    (SETF (BP-BUFFER-INTERNAL (INTERVAL-LAST-BP REPLY-INTERVAL)) REPLY-INTERVAL)
    (SETQ INFERIORS (LIST HEADER-INTERVAL REPLY-INTERVAL)))
  (SEND HEADER-INTERVAL :PUTPROP T :NOFILL)
  (SEND REPLY-INTERVAL :PUTPROP NIL :NOFILL)	;Let auto fill turn on if appropriate.
  (LET ((EXPANSION (GET PLIST :TEMPLATE-EXPANSION))
	(EXTRA-NLINES 0)
	(ENFORCE-NLINES NIL))
    (OUTPUT-HEADERS (OPEN-INTERVAL-STREAM (INTERVAL-FIRST-BP HEADER-INTERVAL)) EXPANSION)
    (LOOP FOR (KEY VAL) ON EXPANSION BY 'CDDR
	  DO (SELECTQ KEY
	       (:TEXT
		(INSERT-THING LAST-BP VAL))
	       (:WINDOW-CONFIGURATION
		(SETQ LAST-WINDOW-CONFIGURATION VAL))
	       (:DRAFT-PATHNAME
		(SETQ PATHNAME VAL))
	       (:NUMBER-OF-HEADER-LINES
		(SETQ ENFORCE-NLINES VAL))
	       (:NUMBER-OF-EXTRA-HEADER-LINES
		(SETQ EXTRA-NLINES VAL))
	       ))
    (SETQ HEADER-WINDOW-NLINES (OR ENFORCE-NLINES
				   (MIN 10.	;Could be user option
					(MAX (IF (FIXP *HEADER-WINDOW-NLINES*)
						 *HEADER-WINDOW-NLINES*
						 (FIX (* *HEADER-WINDOW-NLINES*
							 (MULTIPLE-VALUE-BIND (NIL Y)
							     (SEND *ZMAIL-WINDOW*
								   :SIZE-IN-CHARACTERS)
							   Y))))
					     (+ EXTRA-NLINES
						(1- (COUNT-LINES HEADER-INTERVAL)))))))
    (SETQ WINDOW-POINTS (GET-COMPOSITION-STARTING-POINTS EXPANSION
							 HEADER-INTERVAL NIL T
							 REPLY-INTERVAL NIL T))
    (SETQ UNDO-ENTRY (MAKE-INSTANCE 'UNDO-DRAFT-MSG :DRAFT-MSG SELF))
    (SETQ CREATION-TICK *TICK*)))

(DEFUN GET-COMPOSITION-STARTING-POINTS (EXPANSION
					HEADER-START-BP HEADER-END-BP HEADER-IN-ORDER-P
					TEXT-START-BP TEXT-END-BP TEXT-IN-ORDER-P)
  (GET-INTERVAL TEXT-START-BP TEXT-END-BP TEXT-IN-ORDER-P)
  (LOOP FOR STARTING-POINT IN (GET (LOCF EXPANSION) ':STARTING-POINT)
	WITH HEADERS-BP AND PREFER-HEADERS
	WITH TEXT-BP = TEXT-END-BP
	DO (SELECTQ (FIRST STARTING-POINT)		;Window name
	     (:HEADERS
	      (OR (FOURTH STARTING-POINT) (SETQ PREFER-HEADERS T))
	      (GET-INTERVAL HEADER-START-BP HEADER-END-BP HEADER-IN-ORDER-P)
	      (SETQ HEADERS-BP HEADER-END-BP)
	      (IF (NOT (NULL (CDR STARTING-POINT)))
		  (LET ((HEADER-NAME (SECOND STARTING-POINT)))
		    (DO ((LINE (BP-LINE HEADER-START-BP) (LINE-NEXT LINE))
			 (END-LINE (BP-LINE HEADER-END-BP)))
			((EQ LINE END-LINE))
		      (AND (LET ((HEADER-LINE-TYPE (HEADER-LINE-TYPE LINE)))
			     (IF (EQ HEADER-LINE-TYPE ':ITS)
				 (MEMQ HEADER-NAME '(:ITS :FROM :DATE :SUBJECT))
				 (EQ HEADER-NAME HEADER-LINE-TYPE)))
			   (RETURN (SETQ HEADERS-BP (CREATE-BP LINE
							       (OR (THIRD STARTING-POINT)
								   (LINE-LENGTH LINE))))))))))
	     (:REPLY
	      (SETQ PREFER-HEADERS NIL)
	      (LET ((TYPE (SECOND STARTING-POINT)))
		(SELECTQ TYPE
		  ((:START :END)
		   (LET ((COUNT (THIRD STARTING-POINT))
			 (CHAR (FOURTH STARTING-POINT))
			 (BP (IF (EQ TYPE :START)
				 TEXT-START-BP
			       TEXT-END-BP)))
		     (WHEN (NULL CHAR) (SETQ CHAR 0))
		     (SETQ TEXT-BP
			   (FORWARD-CHAR
			     (IF (NULL COUNT)
				 BP
			       (FORWARD-LINE BP (IF (EQ TYPE :START)
						    COUNT
						    (- COUNT))
					     T))
			     CHAR T))))
		  (OTHERWISE (SETQ TEXT-BP (THIRD STARTING-POINT))))))
	     (OTHERWISE 
	      (SETQ PREFER-HEADERS NIL)))
	FINALLY (RETURN (LET ((TEXT-ELEM (LIST ':REPLY TEXT-BP))
			      (HEADERS-ELEM (AND HEADERS-BP (LIST ':HEADERS HEADERS-BP))))
			  (COND ((NULL HEADERS-ELEM) (LIST TEXT-ELEM))
				(PREFER-HEADERS (LIST HEADERS-ELEM TEXT-ELEM))
				(T (LIST TEXT-ELEM HEADERS-ELEM)))))))

(DEFMETHOD (:SUMMARY-STRING DRAFT-MSG) ()
  (UNLESS ( TICK SUMMARY-STRING-TICK)
    (SETQ SUMMARY-STRING (SEND SELF ':COMPUTE-SUMMARY-STRING
			       (PARSE-HEADERS-INTERVAL HEADER-INTERVAL) REPLY-INTERVAL))
    (SETQ SUMMARY-STRING-TICK (TICK)))
  SUMMARY-STRING)

;;; Drafts of the default flavor cannot be continued, so they were sent if
;;; any recipients got done.
(DEFMETHOD (:SENT-P BASIC-DRAFT-MSG) ()
  (LOOP FOR (NIL . RECIPIENTS) IN RECIPIENTS-DONE
	THEREIS (NOT (EQUAL RECIPIENTS '(:TRANSMITTING)))))

(DEFMETHOD (:COMPUTE-SUMMARY-STRING BASIC-DRAFT-MSG)
	   (CURRENT-HEADERS TEXT-INTERVAL)
  (LET ((PLIST (LOCF CURRENT-HEADERS))
	(NEW-SUMMARY-STRING NIL))
    (LET ((TO (GET PLIST :TO))
	  (CC (GET PLIST :CC)))
      (WHEN TO
	(SETQ NEW-SUMMARY-STRING (STRING-APPEND "To: " (SUMMARIZE-RECIPIENTS TO 20.))))
      (WHEN (AND CC
		 (OR (NULL TO) (< (STRING-LENGTH NEW-SUMMARY-STRING) 20.)))
	(SETQ NEW-SUMMARY-STRING (STRING-APPEND
				   (IF NEW-SUMMARY-STRING
				       (STRING-APPEND NEW-SUMMARY-STRING "; cc: ")
				       "cc: ")
				   (SUMMARIZE-RECIPIENTS CC 20.)))))
    (WHEN (> (STRING-LENGTH NEW-SUMMARY-STRING) 30.)
      (SETQ NEW-SUMMARY-STRING (SUBSTRING NEW-SUMMARY-STRING 0 30.)))
    (LET ((SUBJECT (GET PLIST :SUBJECT)))
      (WHEN (COND (SUBJECT
		   (WHEN (LISTP SUBJECT)
		     (SETQ SUBJECT (FIRST SUBJECT)))
		   (SETQ SUBJECT (STRING-APPEND "Re: " SUBJECT))
		   T)
		  ((STRINGP TEXT-INTERVAL)
		   NIL)
		  ((NOT (EQUAL (SETQ SUBJECT (FIRST-TEXT-LINE TEXT-INTERVAL))
			       ""))))
	(SETQ NEW-SUMMARY-STRING (IF NEW-SUMMARY-STRING
				     (STRING-APPEND NEW-SUMMARY-STRING "; " SUBJECT)
				     SUBJECT))))
    (COND (NEW-SUMMARY-STRING
	   (WHEN (SEND SELF :SEND-IF-HANDLES :MSGS-BEING-REPLIED-TO)
	     (SETQ NEW-SUMMARY-STRING (STRING-APPEND "Reply: " NEW-SUMMARY-STRING)))
	   (UNLESS (SEND SELF :SENT-P)
	     (SETQ NEW-SUMMARY-STRING (STRING-APPEND NEW-SUMMARY-STRING "; (Not sent)"))))
	  (T
	   (SETQ NEW-SUMMARY-STRING "Empty")))
    NEW-SUMMARY-STRING))

(SCL:DEFINE-PRESENTATION-TYPE BASIC-DRAFT-MSG ((&KEY (SENT 'DONT-CARE)))
   :NO-DEFTYPE T
   :PARSER ((STREAM)
	    (LET ((TOKEN (DW:READ-STANDARD-TOKEN STREAM)))
	      (OR
		(COND ((AND (STRING-EQUAL TOKEN "unsent")
			    (NEQ SENT 'T))	;Cannot say unsent if only allowed sent
		       (MOST-RECENT-DRAFT NIL NIL))
		      ((AND (STRING-EQUAL TOKEN "sent")
			    (NEQ SENT 'NIL))	;Cannot say sent if only allowed unsent
		       (MOST-RECENT-DRAFT NIL T))
		      (T
		       (LET ((INDEX (CL:PARSE-INTEGER TOKEN)))
			 (WHEN INDEX
			   (LET ((DRAFT (COND (( 1 INDEX (LENGTH *DRAFT-LIST*))
					       (NTH (1- INDEX) *DRAFT-LIST*))
					      (( (1+ (LENGTH *DRAFT-LIST*))
						  INDEX
						  (+ (LENGTH *DRAFT-LIST*)
						     (LENGTH *DUMMY-DRAFT-LIST*)))
					       (NTH (- INDEX (LENGTH *DRAFT-LIST*) 1)
						    *DUMMY-DRAFT-LIST*))
					      (T NIL))))
			     (WHEN (DRAFT-MSG-SENT-TYPE-P DRAFT SENT)
			       DRAFT))))))
		(PARSE-FERROR "/"~A/" is not a draft." TOKEN))))
   :PRINTER ((DRAFT-MSG STREAM)
	     (IGNORE SENT)
	     (LET ((INDEX (COND ((MEMQ DRAFT-MSG *DRAFT-LIST*)
				 (1+ (FIND-POSITION-IN-LIST DRAFT-MSG *DRAFT-LIST*)))
				((MEMQ DRAFT-MSG *DUMMY-DRAFT-LIST*)
				 (+ 1 (LENGTH *DRAFT-LIST*)
				    (FIND-POSITION-IN-LIST DRAFT-MSG *DUMMY-DRAFT-LIST*)))
				(T 0))))
	       (FORMAT STREAM "~D  ~A" INDEX (SEND DRAFT-MSG :SUMMARY-STRING))))
   :DESCRIPTION "a message draft")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR CONTINUE-DRAFT
                             (BASIC-DRAFT-MSG "Continue this draft" *ZMAIL-COMTAB*
					      :GESTURE :SELECT
					      :TESTER ((DRAFT-MSG &REST IGNORE)
						       (MEMQ DRAFT-MSG *DRAFT-LIST*)))
			     (DRAFT-MSG)
  `(CONTINUE-DRAFT-MSG ,DRAFT-MSG))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR REVOKE-DRAFT
                             (BASIC-DRAFT-MSG "Revoke this draft" *ZMAIL-COMTAB*
					      :TESTER  ((DRAFT-MSG &REST IGNORE)
							(SEND DRAFT-MSG :SENT-P)))
			     (DRAFT-MSG)
  `(REVOKE-MSG-INTERNAL :DRAFT-MSGS (,DRAFT-MSG)))

(DEFUN MOST-RECENT-DRAFT (&OPTIONAL (NO-ERROR-P NIL) (TYPE 'DONT-CARE))
  (OR (DOLIST (DRAFT *DRAFT-LIST*)
	(WHEN (DRAFT-MSG-SENT-TYPE-P DRAFT TYPE)
	  (RETURN DRAFT)))
      (UNLESS NO-ERROR-P
	(BARF "There are no ~Adrafts." (SELECTQ TYPE
					 ((T) "sent ")
					 ((NIL) "unsent ")
					 (OTHERWISE ""))))))

(DEFUN DRAFT-MSG-SENT-TYPE-P (DRAFT-MSG SENT-TYPE)
  (CL:ECASE SENT-TYPE
    ((T) (SEND DRAFT-MSG :SENT-P))
    ((NIL) (NOT (SEND DRAFT-MSG :SENT-P)))
    ((DONT-CARE) T)))

;;; Resume composition
(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-CONTINUE (STRING)
  (APPEND-TO-ARRAY STRING "Resume sending message:")
  (AND *DRAFT-LIST*
       (LET* ((LEFT-DRAFT-MSG (CAR *DRAFT-LIST*))
	      (MIDDLE-DRAFT-MSG
		(OR (LOOP WITH SM
			  FOR DM IN *DRAFT-LIST*
			  UNLESS (SEND DM :SENT-P)
			    DO (SETQ SM (LOOP FOR RM IN (SEND DM :MSGS-BEING-REPLIED-TO)
					      WHEN (EQ RM *MSG*)
						RETURN DM))
			  WHEN SM
			    RETURN DM)
		    (LOOP FOR DM IN *DRAFT-LIST*
			  UNLESS (SEND DM ':SENT-P)
			    RETURN DM)))
	      (SAME-P (EQ LEFT-DRAFT-MSG MIDDLE-DRAFT-MSG)))
	 (APPEND-TO-ARRAY STRING (IF SAME-P " L,M: " " L: "))
	 (LET ((SUMMARY (SEND LEFT-DRAFT-MSG ':SUMMARY-STRING)))
	   (APPEND-TO-ARRAY STRING SUMMARY 0
			    (MIN (COND (SAME-P 56.)
				       ((NULL MIDDLE-DRAFT-MSG) 58.)
				       (T 27.))
				 (STRING-LENGTH SUMMARY))))
	 (AND MIDDLE-DRAFT-MSG (NOT SAME-P)
	      (LET ((SUMMARY (SEND MIDDLE-DRAFT-MSG ':SUMMARY-STRING)))
		(APPEND-TO-ARRAY STRING "; M: ")
		(APPEND-TO-ARRAY STRING SUMMARY 0 (MIN 27. (STRING-LENGTH SUMMARY)))))
	 (ARRAY-PUSH-EXTEND STRING #/;)))
  (APPEND-TO-ARRAY STRING " R: menu."))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-CONTINUE "Resume sending message.
Left continues the last message.  Middle continues the last unsent message.
Right for menu of drafts or from a message or file." (NO-SEQUENCE-OK)
  (LET ((DRAFT-MSG (GET-DRAFT-MSG-FOR-CONTINUE)))
    (COND ((NULL DRAFT-MSG)
	   (ABORT-CURRENT-COMMAND))
	  ((EQ DRAFT-MSG ':RESTORE-DRAFT)
	   (SETQ DRAFT-MSG (MAKE-DRAFT-MSG-FROM-RESTORED-DRAFT)))
	  ((MEMQ DRAFT-MSG '(:FROM-THIS-MSG :FROM-SOME-MSG))
	   (SETQ DRAFT-MSG (IF (EQ DRAFT-MSG ':FROM-THIS-MSG)
			       (OR *MSG* (BARF "There is no current message"))
			       (CHOOSE-MSG-FROM-SUMMARY "a draft message")))
	   (SETQ DRAFT-MSG (MAKE-DRAFT-MSG-FROM-MSG DRAFT-MSG))))
    (CONTINUE-DRAFT-MSG DRAFT-MSG)))

(DEFVAR *CONTINUE-MENU-ALIST* '(("Unsent drafts" :VALUE :UNSENT-DRAFTS
				 :DOCUMENTATION "All drafts that have not been sent.")
				("Sent drafts" :VALUE :SENT-DRAFTS
				 :DOCUMENTATION "All drafts that have been sent.")
				("All drafts" :VALUE :ALL-DRAFTS
				 :DOCUMENTATION "All drafts, in reverse order of creation.")))

(DEFUN GET-DRAFT-MSG-FOR-CONTINUE ()
  (SELECTQ *ZMAIL-COMMAND-BUTTON*
    ((:LEFT :KBD)
     (OR (CAR *DRAFT-LIST*)
	 (BARF "There are no messages to continue sending")))
    (:MIDDLE
     (OR (LOOP WITH SM
	       FOR DM IN *DRAFT-LIST*
	       UNLESS (SEND DM :SENT-P)
		 DO (SETQ SM (LOOP FOR RM IN (SEND DM :MSGS-BEING-REPLIED-TO)
				   WHEN (EQ RM *MSG*)
				     RETURN DM))
	       WHEN SM
		 RETURN DM)
	 (LOOP FOR DM IN *DRAFT-LIST*
	       UNLESS (SEND DM ':SENT-P)
	       RETURN DM)
	 (BARF "There are no unsent messages to continue sending")))
    (:RIGHT
     (LET ((KIND (ZMAIL-MENU-CHOOSE NIL *CONTINUE-MENU-ALIST* NIL NIL NIL "Choose a menu:")))
       (TV:MENU-CHOOSE
	 (NCONC (LET ((LIST (LOOP FOR DRAFT-MSG IN *DRAFT-LIST*
				  WHEN (SELECTQ KIND
					 (:ALL-DRAFTS T)
					 (:UNSENT-DRAFTS
					  (NULL (SEND DRAFT-MSG :SENT-P)))
					 (:SENT-DRAFTS
					  (SEND DRAFT-MSG :SENT-P)))
				    COLLECT (CONS (TRIM-SUMMARY-STRING
						    (SEND DRAFT-MSG :SUMMARY-STRING))
						  DRAFT-MSG))))
		  (UNLESS (OR LIST (EQ KIND :ALL-DRAFTS))
		    (BARF "There are no ~:[unsent~;sent~] drafts." (EQ KIND :SENT-DRAFTS)))
		  LIST)
		'(("Restore draft file"
		   :VALUE :RESTORE-DRAFT
		   :STYLE (:SWISS :ITALIC :NORMAL)
		   :DOCUMENTATION
		   "Continue sending a message draft that was saved in a file.")
		  ("Restore draft message"
		   :BUTTONS (:FROM-THIS-MSG NIL :FROM-SOME-MSG)
		   :STYLE (:SWISS :ITALIC :NORMAL)
		   :DOCUMENTATION
  "Continue sending message draft saved as message: L: this message; R: specify from summary."
		   )))
		     NIL
		     (RECTANGLE-NEAR-COMMAND-MENU (TV:MOUSE-SHEET (TV:SHEET-MOUSE *ZMAIL-WINDOW*))))))))

(DEFUN TRIM-SUMMARY-STRING (STRING)
  (LET ((CR-POS (STRING-SEARCH-CHAR #\RETURN STRING)))
    (IF CR-POS
	(STRING-APPEND (SUBSTRING STRING 0 CR-POS) " ..."
		       (IF (STRING-SEARCH "(Not sent)" STRING) " (Not sent)" ""))
      STRING)))

(DEFUN CONTINUE-DRAFT-MSG (DRAFT-MSG)
  (ZMAIL-MAIL DRAFT-MSG))

(DEFFLAVOR MSGS-BEING-REPLIED-TO-INTERVAL () (NODE))

(DEFMETHOD (:SETUP-FOR-CONTINUE DRAFT-MSG) ()
  (ZMAIL-UNDO-SAVE UNDO-ENTRY)
  (SETQ MSGS-BEING-REPLIED-TO (DEL-IF #'(LAMBDA (M) (EQ (MSG-PARSED-P M) :KILLED))
				      MSGS-BEING-REPLIED-TO)
	MSGS-BEING-FORWARDED (DEL-IF #'(LAMBDA (M) (EQ (MSG-PARSED-P M) :KILLED))
				     MSGS-BEING-FORWARDED))
  (LET ((DCS (OR DEFAULT-CHARACTER-STYLE *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)))
    (SETQ *HEADER-INTERVAL* HEADER-INTERVAL)
    (SET-WINDOW-INTERVAL *HEADER-WINDOW* *HEADER-INTERVAL*)
    (SET-WINDOW-DEFAULT-CHARACTER-STYLE *HEADER-WINDOW* DCS)
    (MUST-REDISPLAY *HEADER-WINDOW* DIS-ALL)
    (SETQ *REPLY-INTERVAL* REPLY-INTERVAL)
    (SET-WINDOW-INTERVAL *REPLY-WINDOW* *REPLY-INTERVAL*)
    (SET-WINDOW-DEFAULT-CHARACTER-STYLE *REPLY-WINDOW* DCS)
    (MUST-REDISPLAY *REPLY-WINDOW* DIS-ALL))
  (RESET-WINDOW-POINT-PDL *HEADER-WINDOW*)
  (RESET-WINDOW-POINT-PDL *REPLY-WINDOW*)
  (IF ( (LENGTH MSGS-BEING-REPLIED-TO) 1)
      (SETQ *MSGS-BEING-REPLIED-TO-INTERVAL* NIL)
    (SETQ *MSGS-BEING-REPLIED-TO-INTERVAL* (CREATE-INTERVAL NIL NIL
							    'MSGS-BEING-REPLIED-TO-INTERVAL))
    (SETF (NODE-SUPERIOR *MSGS-BEING-REPLIED-TO-INTERVAL*) *MSG-INTERVAL*)
    (DISCARD-CHANGE-HISTORY *MSG-INTERVAL*)
    (LET ((*ENABLE-CHANGE-RECORDING* NIL))
      (INSERT-TEXT-OF-MSGS MSGS-BEING-REPLIED-TO
			   (INTERVAL-LAST-BP *MSGS-BEING-REPLIED-TO-INTERVAL*)
			   NIL)2)0)
  (LOOP FOR (WINDOW POINT TOP MARK) IN (REVERSE WINDOW-POINTS)
	WHEN (SYMBOLP WINDOW)
	  DO (SETQ WINDOW (CL:CASE WINDOW
			    (:HEADERS *HEADER-WINDOW*)
			    (:REPLY *REPLY-WINDOW*)))
	WHEN POINT
	  DO (MOVE-BP (WINDOW-POINT WINDOW) POINT)
	WHEN TOP
	  DO (RECENTER-WINDOW WINDOW :START TOP)
	WHEN MARK
	  DO (MOVE-BP (WINDOW-MARK WINDOW) MARK))
  (MOVE-BP (WINDOW-MARK *REPLY-WINDOW*) (INTERVAL-FIRST-BP *REPLY-INTERVAL*))
  (LET ((*WINDOW* (IF (MEMQ LAST-WINDOW-CONFIGURATION
			    *MSG-WINDOW-CONFIGURATIONS*)
		      *MSG-WINDOW* *REPLY-WINDOW*)))
    (SETQ *STYLE* 0)
    (UPDATE-STYLE-NAME))
  (SETQ *DRAFT-LIST* (CONS SELF (DELQ SELF *DRAFT-LIST*)))
  (SETQ *DRAFT-MSG* SELF))

(DEFMETHOD (:SET-HEADERS DRAFT-MSG) (NEW-HEADERS)
  (SETQ HEADERS NEW-HEADERS
	HEADERS-HANDLED NIL))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REVOKE-MSG
  "Revoke a message already sent.
Message is chosen from sent drafts or message summary window."
				(NO-SEQUENCE-OK)
  (LET* ((DRAFT-MSGS (GET-DRAFT-MSG-FOR-REVOKE))
	 (MSGS NIL)
	 (QUERY NIL))
    (COND ((NULL DRAFT-MSGS)
	   (ABORT-CURRENT-COMMAND))
	  ((MEMQ DRAFT-MSGS '(:FROM-THIS-MSG :FROM-SOME-MSG))
	   (SETQ MSGS (LIST (IF (EQ DRAFT-MSGS :FROM-THIS-MSG)
				(OR *MSG* (BARF "There is no current message."))
			      (CHOOSE-MSG-FROM-SUMMARY "the message to revoke")))
		 DRAFT-MSGS NIL
		 QUERY T))			1;Always ask when revoking a message.
0	  ((ATOM DRAFT-MSGS)
	   (SETQ DRAFT-MSGS (LIST DRAFT-MSGS))))
    (REVOKE-MSG-INTERNAL :DRAFT-MSGS DRAFT-MSGS :MSGS MSGS :QUERY QUERY)))

(DEFUN REVOKE-MSG-INTERNAL (&KEY DRAFT-MSGS MSGS
				 (TEMPLATE 'REVOKE-MSG-TEMPLATE)
				 (DELETE-FCC T)
				 (QUERY :FROM-OTHERS))
  (WHEN QUERY
    (UNLESS (EQ QUERY :FROM-OTHERS)
      (DOLIST (DRAFT DRAFT-MSGS)
	(UNLESS (TYPEOUT-YES-OR-NO-P "~&Do you really want to revoke~%    ~~A~~%  ? "
				     (SEND DRAFT :SUMMARY-STRING))
	  (ABORT-CURRENT-COMMAND))))
    (DOLIST (MSG MSGS)
      (LET* ((FROM (MSG-GET MSG :FROM))
	     (AUTHOR (FIRST FROM))
	     (USER (CL:GETF AUTHOR :USER))
	     (FROM-OTHERS (OR (> (LENGTH FROM) 1)
			      (NOT (IF USER
				       (EQ USER SI:*USER*)
				     (STRING-EQUAL (CL:GETF AUTHOR :NAME) SYS:USER-ID))))))
	(WHEN (OR FROM-OTHERS (NEQ QUERY :FROM-OTHERS))
	  (UNLESS (TYPEOUT-YES-OR-NO-P "~&Do you really want to revoke~%    ~~A~~@
				        ~:[  ~;which you did not send originally~]? "
				       (PROGN (ASSURE-MSG-PARSED MSG) (MSG-SUMMARY-LINE MSG))
				       FROM-OTHERS)
	    (ABORT-CURRENT-COMMAND))))))
  (WHEN (AND DRAFT-MSGS DELETE-FCC)
    (LET ((MSGS-TO-GO NIL))
      (DOLIST (DRAFT-MSG DRAFT-MSGS)
	(LET ((REFERENCES (SEND DRAFT-MSG :REFERENCES)))
	  (DOLIST (BUFFER (SEND DRAFT-MSG :BUFFER-RECIPIENTS))
	    (DOLIST (REF REFERENCES)
	      (LET ((RREF (OR (GET (LOCF REF) :MESSAGE-ID) REF)))
		(NO-DUPLICATES (SEND BUFFER :GET-MSGS-FROM-REFERENCE RREF)
			       (LOCF MSGS-TO-GO)))))))
      (DELETE-MSGS-REMARKING MSGS-TO-GO)))
  (COMPOSE-FROM-TEMPLATE TEMPLATE :DRAFT-MSGS DRAFT-MSGS :MSGS MSGS))

(DEFUN GET-DRAFT-MSG-FOR-REVOKE ()
  (SELECTQ *ZMAIL-COMMAND-BUTTON*
    (:LEFT
     (LET ((DRAFT (FIRST *DRAFT-LIST*)))
       (WHEN (NULL DRAFT)
	 (BARF "There are no messages to revoke."))
       (UNLESS (SEND DRAFT :SENT-P)
	 (BARF "This message was never sent."))))
    (:MIDDLE
     (OR (LOOP FOR DM IN *DRAFT-LIST*
	       WHEN (SEND DM :SENT-P)
	       RETURN DM)
	 (BARF "There are no sent messages to revoke.")))
    (OTHERWISE
     (TV:MENU-CHOOSE (NCONC (LOOP FOR DRAFT-MSG IN *DRAFT-LIST*
				  WHEN (SEND DRAFT-MSG :SENT-P)
				    COLLECT (CONS (SEND DRAFT-MSG :SUMMARY-STRING) DRAFT-MSG))
			    (LOOP FOR DRAFT-MSG IN *DUMMY-DRAFT-LIST*
				  UNLESS (AND (TYPEP DRAFT-MSG 'REDISTRIBUTE-DRAFT-MSG)
					      (EQ (MSG-PARSED-P (SEND DRAFT-MSG :MSG))
						  :KILLED))
				    COLLECT (CONS (SEND DRAFT-MSG :SUMMARY-STRING) DRAFT-MSG))
			    '(("Revoke message in current sequence"
			       :BUTTONS (:FROM-THIS-MSG NIL :FROM-SOME-MSG)
			       :STYLE (:SWISS :ITALIC :NORMAL)
			       :DOCUMENTATION
   "Revoke a message in the current sequence:  L: current message; R: select from summary.")))
		     ))))

(DEFUN FORMAT-DRAFT-DISPOSITION (DISPOSITION)
  (IF (LISTP DISPOSITION)
      (CL:APPLY #'FORMAT NIL (FIRST DISPOSITION)
		(TIME:PRINT-BRIEF-UNIVERSAL-TIME (SECOND DISPOSITION) NIL)
		(NTHCDR 2 DISPOSITION))
      DISPOSITION))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SHOW-DRAFT-DISPOSITIONS 
				"Show disposition of all drafts.
Prints a summary of each draft, whether it was sent or not, and if it was sent, shows the
host that was used."
				(NO-SEQUENCE-OK)
  (LABELS ((SHOW-ONE-DRAFT-LIST (DRAFT-LIST)
	     (DOLIST (DRAFT DRAFT-LIST)
	       (CL:FRESH-LINE *TYPEOUT-WINDOW*)
	       (SCL:PRESENT DRAFT 'BASIC-DRAFT-MSG :STREAM *TYPEOUT-WINDOW*)
	       (SI:WITH-INDENTATION (*TYPEOUT-WINDOW* 2)
		 (CL:FRESH-LINE *TYPEOUT-WINDOW*)
		 (LET ((DISPOSITIONS (SEND DRAFT :DISPOSITION-SUMMARIES)))
		   (WHEN DISPOSITIONS
		     (DOLIST (DISPOSITION DISPOSITIONS)
		       (SEND *TYPEOUT-WINDOW*
			     :LINE-OUT (FORMAT-DRAFT-DISPOSITION DISPOSITION))))))
	       (SEND *TYPEOUT-WINDOW* :TYO #\Return))))
    (LET ((*COMTAB* *ZMAIL-COMTAB*))		;For mouse-sensitivity at **MORE** breaks
      (SHOW-ONE-DRAFT-LIST *DRAFT-LIST*)
      (SHOW-ONE-DRAFT-LIST *DUMMY-DRAFT-LIST*)
      (FORMAT *TYPEOUT-WINDOW* "~&Done.~%")))
  DIS-NONE)

;;;; Normal composition management

(DEFVAR *INSIDE-MAIL* NIL)
(DEFVAR *DRAFT-DISPOSITION-MODE-LINE-STRING* NIL)
(DEFFLAVOR DRAFT-DISPOSITION-MODE-LINE-STRING
	((HEADER-WINDOW-STRING (CL:MAKE-ARRAY 95. :ELEMENT-TYPE 'CHARACTER :FILL-POINTER 0))
	 (OTHER-WINDOW-STRING (CL:MAKE-ARRAY 95. :ELEMENT-TYPE 'CHARACTER :FILL-POINTER 0)))
	())

(DEFMETHOD (COMPUTE-DRAFT-DISPOSITION-STRINGS DRAFT-DISPOSITION-MODE-LINE-STRING) ()
  (SETF (FILL-POINTER HEADER-WINDOW-STRING) 0)
  (SETF (FILL-POINTER OTHER-WINDOW-STRING) 0)
  (LABELS ((KEY-IS-COMMAND (KEY COMMAND)
	     (EQ (COMMAND-LOOKUP KEY *COMTAB*) COMMAND))
	   (KEY-OR-PROPER-KEY (KEY COMMAND)
	     (IF (KEY-IS-COMMAND KEY COMMAND) KEY (KEY-FOR-COMMAND COMMAND))))
    (LET ((ABORT-STRING (FORMAT NIL "~A aborts" (KEY-OR-PROPER-KEY #\Abort 'COM-ABORT-SEND)))
	  (END-KEY-ALWAYS-SENDS (KEY-IS-COMMAND #\End 'COM-SEND-MESSAGE))
	  (END-KEY-IS-MAIL-END (KEY-IS-COMMAND #\End 'COM-MAIL-END))
	  (C-END-KEY-IS-MAIL-END (KEY-IS-COMMAND #\c-End 'COM-MAIL-END))
	  (SEND-MESSAGE-KEY (KEY-FOR-COMMAND 'COM-SEND-MESSAGE)))
      (COND (END-KEY-ALWAYS-SENDS
	     (FORMAT HEADER-WINDOW-STRING "~A, ~A mails~:[~;, ~A adds more text~]"
		     ABORT-STRING
		     #\End
		     (AND C-END-KEY-IS-MAIL-END
			  (MEMQ *DRAFT-EDITOR-END-KEY-TREATMENT* '(:SEND-MSG
								   :BOTH-ADD-MORE-TEXT)))
		     #\c-End)
	     (FORMAT OTHER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\End))
	    ((AND END-KEY-IS-MAIL-END C-END-KEY-IS-MAIL-END)
	     (CL:CASE *DRAFT-EDITOR-END-KEY-TREATMENT*
	       (:SEND-MSG
		 (FORMAT HEADER-WINDOW-STRING "~A, ~C mails, ~C adds more text"
			 ABORT-STRING #\End #\c-End))
	       (:BOTH-SEND-MSG
		 (FORMAT HEADER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\End))
	       (:ADD-MORE-TEXT
		 (FORMAT HEADER-WINDOW-STRING "~A, ~C mails, ~C adds more text"
			 ABORT-STRING #\c-End #\End))
	       (:BOTH-ADD-MORE-TEXT
		 (FORMAT HEADER-WINDOW-STRING "~A, ~C adds more text" ABORT-STRING #\End)))
	     (FORMAT OTHER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\End))
	    (END-KEY-IS-MAIL-END
	     (CL:CASE *DRAFT-EDITOR-END-KEY-TREATMENT*
	       ((:SEND-MSG :BOTH-SEND-MSG)
		(FORMAT HEADER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\End))
	       ((:ADD-MORE-TEXT :BOTH-ADD-MORE-TEXT)
		(FORMAT HEADER-WINDOW-STRING "~A, ~C adds more text" ABORT-STRING #\End)))
	     (FORMAT OTHER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\End))
	    (C-END-KEY-IS-MAIL-END
	     (CL:CASE *DRAFT-EDITOR-END-KEY-TREATMENT*
	       ((:ADD-MORE-TEXT :BOTH-SEND-MSG)
		(FORMAT HEADER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\c-End))
	       ((:SEND-MSG :BOTH-ADD-MORE-TEXT)
		(FORMAT HEADER-WINDOW-STRING "~A, ~C adds more text" ABORT-STRING #\c-End)))
	     (FORMAT OTHER-WINDOW-STRING "~A, ~C mails" ABORT-STRING #\c-End))
	    (T
	     (FORMAT HEADER-WINDOW-STRING "~A, ~A mails" ABORT-STRING SEND-MESSAGE-KEY)
	     (FORMAT OTHER-WINDOW-STRING "~A, ~A mails" ABORT-STRING SEND-MESSAGE-KEY))))))

(DEFMETHOD (:MODE-LINE-NAME DRAFT-DISPOSITION-MODE-LINE-STRING) ()
  (COND ((NOT *INSIDE-MAIL*) OTHER-WINDOW-STRING)
	((OR (EQ *WINDOW* *HEADER-WINDOW*)
	     (AND (EQ *WINDOW* *MSG-WINDOW*)
		  (MEMQ *WINDOW-CONFIGURATION* *MULTI-WINDOW-SENDING-CONFIGURATIONS*)))
	 HEADER-WINDOW-STRING)
	(T OTHER-WINDOW-STRING)))

(COMPILE-FLAVOR-METHODS DRAFT-DISPOSITION-MODE-LINE-STRING)
(DEFRESOURCE DRAFT-DISPOSITION-MODE-LINE-STRING ()
  :CONSTRUCTOR (MAKE-INSTANCE 'DRAFT-DISPOSITION-MODE-LINE-STRING)
  :INITIALIZER (COMPUTE-DRAFT-DISPOSITION-STRINGS OBJECT)
  :INITIAL-COPIES 0)  

(DEFUN ZMAIL-MAIL (DRAFT-MSG)
  (LET ((*INSIDE-MAIL* T)
	(*HEADER-WINDOW-NLINES* (SEND DRAFT-MSG :HEADER-WINDOW-NLINES))
	(CONFIGURATION (SEND DRAFT-MSG :LAST-WINDOW-CONFIGURATION))
	(STARTING-WINDOW (FIRST (FIRST (SEND DRAFT-MSG :WINDOW-POINTS))))
	(OLD-CURRENT-MSG *MSG*)
	(OLD-CONFIGURATION *WINDOW-CONFIGURATION*)
	(OLD-DOC (SEND (WINDOW-SHEET *MSG-WINDOW*) :WHO-LINE-OVERRIDE-DOCUMENTATION-STRING))
	(OLD-MSG-WINDOW-START-BP (COPY-BP (WINDOW-START-BP *MSG-WINDOW*) :NORMAL))
	(OLD-MSG-WINDOW-POINT (COPY-BP (WINDOW-POINT *MSG-WINDOW*) :NORMAL))
	(OLD-MSG-WINDOW-MARK (COPY-BP (WINDOW-MARK *MSG-WINDOW*) :NORMAL)))
    (WITH-BACKGROUND-PROCESS-RUNNING
      (UNWIND-PROTECT
	  (CATCH 'SEND-IT
	    (SEND DRAFT-MSG :SETUP-FOR-CONTINUE)
	    (SET-MAIL-WINDOW-CONFIGURATION CONFIGURATION STARTING-WINDOW NIL)
	    (WITH-EDITOR-BINDINGS
	        (:COMTAB *REPLY-COMTAB*
		 :MODE-LINE-LIST `("Zmail " "Mail " "(" *MODE-NAME-LIST*
				   (*MODE-QUANTITY-NAME* " <" *MODE-QUANTITY-NAME* ">")
				   ") " *ZMAIL-INTERVAL-NAME*
				   (*STYLE-NAME* "  Style: " *STYLE-NAME*)
				   (*MACRO-LEVEL* "  Macro-level: " *MACRO-LEVEL*)
				   "   " *DRAFT-DISPOSITION-MODE-LINE-STRING* "   "
				   (*MODE-LINE-MORE-ABOVE-BELOW* "  "
								 *MODE-LINE-MORE-ABOVE-BELOW*))
		 )
	      (SETF (TV:BLINKER-DESELECTED-VISIBILITY (WINDOW-POINT-BLINKER *MSG-WINDOW*)) :ON)
	      (SEND (WINDOW-SHEET *MSG-WINDOW*) :SET-WHO-LINE-OVERRIDE-DOCUMENTATION-STRING NIL
		    )
	      (USING-RESOURCE
		(*DRAFT-DISPOSITION-MODE-LINE-STRING* DRAFT-DISPOSITION-MODE-LINE-STRING)
		(SEND *CURRENT-COMMAND-LOOP* :EDIT))))
	(SWAP-OUT-MSG-WINDOW)
	(SEND DRAFT-MSG :SAVE-WINDOW-STATE)
	(SEND *MSG-INTERVAL* :REMPROP :NOFILL)
	(FLUSH-DRAFT-IF-UNUSED DRAFT-MSG)
	(UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-CONTINUE)
	(SETF (TV:BLINKER-DESELECTED-VISIBILITY (WINDOW-POINT-BLINKER *MSG-WINDOW*)) NIL)
	(SEND (WINDOW-SHEET *MSG-WINDOW*) :SET-WHO-LINE-OVERRIDE-DOCUMENTATION-STRING OLD-DOC)
	(IF (NEQ OLD-CONFIGURATION *WINDOW-CONFIGURATION*)
	    (SEND *CURRENT-COMMAND-LOOP* :SET-WINDOW-CONFIGURATION OLD-CONFIGURATION)
	  (SETQ TERMINAL-IO *TYPEOUT-WINDOW*)	1;Our 2:edit1 method binds it so we must reset it.
0	  (MUST-REDISPLAY *MSG-WINDOW* DIS-ALL)
	  (SEND *CURRENT-COMMAND-LOOP* :SELECT-RELATIVE))
	(IF (OR *MSGS-BEING-REPLIED-TO-INTERVAL*
		(NOT (MEMQ *MSG* (SEND DRAFT-MSG :MSGS-BEING-REPLIED-TO)))
		(MEMQ (SEND DRAFT-MSG :LAST-WINDOW-CONFIGURATION) *MSG-WINDOW-CONFIGURATIONS*))
	    (ZMAIL-SELECT-MSG *MSG* T NIL)	1;Must reset displayed text
0	    (COMPUTE-CURRENT-MSG-STATE))	1;Can just update attributes.
0	(WHEN (AND *MSG* (EQ *MSG* OLD-CURRENT-MSG))
	  1;; Current message hasn't changed --
	  ;;    Be sure to restore window's prior position on the message as the above
	  ;;    call to 2zmail-select-msg1 (if any) won't in this case and we may have reused
	  ;;    2*msg-window*1 while composing the draft.
0	  (MOVE-BP (WINDOW-POINT *MSG-WINDOW*) OLD-MSG-WINDOW-POINT)
	  (MOVE-BP (WINDOW-MARK *MSG-WINDOW*) OLD-MSG-WINDOW-MARK)
	  (RECENTER-WINDOW *MSG-WINDOW* :START OLD-MSG-WINDOW-START-BP))))
    DIS-NONE))

(DEFMETHOD (:SAVE-WINDOW-STATE DRAFT-MSG) ()
  (SETQ LAST-WINDOW-CONFIGURATION *WINDOW-CONFIGURATION*)
  (WHEN (NOT (MEMQ LAST-WINDOW-CONFIGURATION *MSG-WINDOW-CONFIGURATIONS*))
    (MULTIPLE-VALUE-BIND (NIL NLINES)
	(SEND (WINDOW-SHEET *HEADER-WINDOW*) :SIZE-IN-CHARACTERS)
      (SETQ HEADER-WINDOW-NLINES NLINES)))
  (SETQ WINDOW-POINTS
	(LOOP FOR WINDOW IN *WINDOW-LIST*
	      WHEN (OR (WINDOW-EXPOSED-P WINDOW)
		       (EQ WINDOW *HEADER-WINDOW*)
		       (EQ WINDOW *REPLY-WINDOW*))
		COLLECT (LIST WINDOW
			      (COPY-BP (WINDOW-POINT WINDOW) :NORMAL)
			      (COPY-BP (WINDOW-START-BP WINDOW) :NORMAL)
			      (COPY-BP (WINDOW-MARK WINDOW) :NORMAL))))
  (SEND SELF :SET-DEFAULT-CHARACTER-STYLE
	(SEND (WINDOW-SHEET (IF (MEMQ LAST-WINDOW-CONFIGURATION *MSG-WINDOW-CONFIGURATIONS*)
				*MSG-WINDOW* *REPLY-WINDOW*))
	      :DEFAULT-STYLE)))
(DEFUN FLUSH-DRAFT-IF-UNUSED (DRAFT)
  (WHEN (DRAFT-IS-UNUSED DRAFT)
    (SETQ *DRAFT-LIST* (DELQ DRAFT *DRAFT-LIST*)
	  *DRAFT-MSG* (FIRST *DRAFT-LIST*))))
(DEFMETHOD (DRAFT-IS-UNUSED DRAFT-MSG) ()  
  (AND ( TICK CREATION-TICK)
       (NULL TRANSMIT-TIMESTAMP)))
(DEFMETHOD (DRAFT-IS-UNUSED BASIC-DRAFT-MSG) ()
  NIL)

;;; Set the windows displayed while sending mail.  CONFIGURATION is
;;; either a WINDOW-CONFIGURATION keyword or :MAIL for the default one
;;; window mail configuration.  STARTING-WINDOW is either a window or a
;;; keyword :HEADERS OR :REPLY.  SWITCHING-P means we are already inside
;;; mail and should swap out the old value of point.
(DEFUN SET-MAIL-WINDOW-CONFIGURATION (CONFIGURATION
				      &OPTIONAL STARTING-WINDOW (SWITCHING-P T)
				      &AUX (JUST-SWITCHING-WINDOWS (NULL CONFIGURATION)))
  (COND ((NULL CONFIGURATION)
	 (SETQ CONFIGURATION *WINDOW-CONFIGURATION*))
	((EQ CONFIGURATION :MAIL)
	 (SETQ CONFIGURATION *DEFAULT-MAIL-WINDOW-CONFIGURATION*)))
  ;; Swap out msg window
  (WHEN SWITCHING-P (SWAP-OUT-MSG-WINDOW))
  (UNLESS JUST-SWITCHING-WINDOWS
    (COND ((EQ CONFIGURATION :REPLY)
	   (LET (INTERVAL DEFAULT-CHARACTER-STYLE)
	     (IF (NOT (NULL *MSGS-BEING-REPLIED-TO-INTERVAL*))
		 (SETQ INTERVAL *MSGS-BEING-REPLIED-TO-INTERVAL*)
	       (LET ((MSG (OR (CAR (SEND *DRAFT-MSG* :MSGS-BEING-REPLIED-TO)) *MSG*)))
		 (IF MSG
		     (SETQ INTERVAL (MSG-INTERVAL MSG)
			   DEFAULT-CHARACTER-STYLE (MSG-DEFAULT-CHARACTER-STYLE MSG))
		   ;; Message probably killed, dummy one up
		   (SETQ INTERVAL (CREATE-INTERVAL)))))
	     (SET-MSG-INTERVAL INTERVAL NIL NIL DEFAULT-CHARACTER-STYLE)))
	  ((MEMQ CONFIGURATION *MSG-WINDOW-CONFIGURATIONS*)
	   (SET-MSG-INTERVAL *DRAFT-MSG* NIL NIL (SEND *DRAFT-MSG* :DEFAULT-CHARACTER-STYLE)
			     (NEQ STARTING-WINDOW *MSG-WINDOW*)))))
  ;; Swap in msg window
  (LET ((WINDOW (AND STARTING-WINDOW (SYMBOLP STARTING-WINDOW)
		     (SELECTQ STARTING-WINDOW
		       (:HEADERS *HEADER-WINDOW*)
		       (:REPLY *REPLY-WINDOW*)))))
    (COND ((MEMQ CONFIGURATION *MSG-WINDOW-CONFIGURATIONS*)
	   (SETQ *ZMAIL-INTERVAL-NAME* "Message"
		 STARTING-WINDOW *MSG-WINDOW*)
	   (COND (WINDOW
		  (MOVE-BP (WINDOW-POINT *MSG-WINDOW*) (WINDOW-POINT WINDOW))
		  (MUST-REDISPLAY *MSG-WINDOW* DIS-BPS))))
	  (WINDOW
	   (SETQ STARTING-WINDOW WINDOW))))
  (COND ((NEQ CONFIGURATION *WINDOW-CONFIGURATION*)
	 (SEND *CURRENT-COMMAND-LOOP* :SET-WINDOW-CONFIGURATION CONFIGURATION STARTING-WINDOW)
	 )
	((NULL STARTING-WINDOW))
	((NEQ STARTING-WINDOW *WINDOW*)
	 (MAKE-WINDOW-CURRENT STARTING-WINDOW))
	(T
	 (SELECT-WINDOW STARTING-WINDOW)
	 (SETQ *INTERVAL* (WINDOW-INTERVAL STARTING-WINDOW))))
  (UPDATE-STYLE-NAME)
  (UNLESS JUST-SWITCHING-WINDOWS
    (LABELS ((DEACTIVATE-TYPEOUT (WINDOW)
	       (SEND (WINDOW-TYPEOUT-WINDOW WINDOW) :DEACTIVATE)))
      (COND ((EQ *WINDOW-CONFIGURATION* :REPLY)
	     (DEACTIVATE-TYPEOUT *MSG-WINDOW*)
	     (DEACTIVATE-TYPEOUT *HEADER-WINDOW*)
	     (DEACTIVATE-TYPEOUT *REPLY-WINDOW*))
	    ((MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
	     (DEACTIVATE-TYPEOUT *MSG-WINDOW*))
	    (T
	     (DEACTIVATE-TYPEOUT *HEADER-WINDOW*)
	     (DEACTIVATE-TYPEOUT *REPLY-WINDOW*))))    
    ;; Be sure that the window's modes are properly set.
    (LET-IF *USER-MODES-SET*
	    ((*USER-MODES-SET* NIL))
      (TURN-ON-USER-MODES))))

(DEFUN SWAP-OUT-MSG-WINDOW ()
  (WHEN (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
    (LET* ((MSG-POINT (WINDOW-POINT *MSG-WINDOW*))
	   (WINDOW-TO-MOVE (IF (BP-< MSG-POINT (INTERVAL-FIRST-BP *REPLY-INTERVAL*))
			       *HEADER-WINDOW*
			       *REPLY-WINDOW*)))
      (RESEPARATE-HEADER-AND-TEXT)
      (MOVE-BP (WINDOW-POINT WINDOW-TO-MOVE) MSG-POINT)
      (MUST-REDISPLAY WINDOW-TO-MOVE DIS-BPS))))

(DEFUN RESEPARATE-HEADER-AND-TEXT ()
  (IF (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
      (DO ((LINE (BP-LINE (INTERVAL-FIRST-BP *DRAFT-MSG*)) (LINE-NEXT LINE))
	   (END-LINE (BP-LINE (INTERVAL-LAST-BP *DRAFT-MSG*))))
	  (NIL)
	(WHEN (OR (EQ LINE END-LINE) (LINE-BLANK-P LINE))
	  (MOVE-BP (INTERVAL-LAST-BP *HEADER-INTERVAL*) LINE 0)
	  (MOVE-BP (INTERVAL-FIRST-BP *REPLY-INTERVAL*)
		   (OR (LINE-NEXT LINE) END-LINE) 0)
	  (RETURN NIL)))
      (UNLESS (BEG-LINE-P (INTERVAL-LAST-BP *HEADER-INTERVAL*))
	(INSERT (INTERVAL-LAST-BP *HEADER-INTERVAL*) #\CR))))

1;;; Support for the 2:default-pathname1 message of 2zmail-interval1 --
;;;    Finds the File-References field in the current draft message
0(DEFUN GET-DRAFT-FILE-REFERENCES ()
  (MULTIPLE-VALUE-BIND (START-BP END-BP STOP-AT-BLANK-LINE)
      (MOVE-TO-HEADER-WINDOW NIL)
    (LET ((HEADERS (PARSE-HEADERS-INTERVAL START-BP END-BP T
					   STOP-AT-BLANK-LINE '(:FILE-REFERENCES))))
      (CL:GETF HEADERS :FILE-REFERENCES))))

;;;; Sending

#|
(DEFVAR *MAIL-SENDING-MODE-ALIST*
	'(("COMSAT" :VALUE FILE-SEND-IT :SITE-KEYWORD :COMSAT
	   :DOCUMENTATION "Write a request file for the mailer via the file job.")
	  ("Chaos" :VALUE CHAOS-SEND-IT :SITE-KEYWORD :CHAOS
	   :DOCUMENTATION "Mail via the chaosnet mail protocol to some MAIL server.")
	  ("Chaos Direct" :VALUE CHAOS-DIRECT-SEND-IT :SITE-KEYWORD :CHAOS
						      :DEFAULT-SITE-KEYWORD :DIRECT-CHAOS
	   :DOCUMENTATION "Mail via the chaosnet mail protocol to each host specified.")
	  ("Ether" :VALUE ETHER-SEND-IT :SITE-KEYWORD :ETHER
	   :DOCUMENTATION "Mail via the ethernet mail protocol.")
	  ))
|#

#|
(DEFINE-SITE-ALIST-USER-OPTION (*MAIL-SENDING-MODE* *ZMAIL-USER-OPTION-ALIST*)
			       "Mail sending mode" *MAIL-SENDING-MODE-ALIST*
			       :DEFAULT-MAIL-MODE)
|#

;;; For compatibility, users can SETQ this to something random like FILE-SEND-IT.
(DEFINE-ZMAIL-GLOBAL *MAIL-SENDING-MODE* 'NETWORK-SEND-IT)

;;; Abort it
(DEFCOM-FOR-ZMAIL COM-ABORT-SEND
		  "Abort sending this message."
		  ()
  (COND (*NUMERIC-ARG-P* (BEEP))
	((WINDOW-MARK-P *WINDOW*))
	(*MACRO-LEVEL* (BARF "Aborting to top level."))
	((DRAFT-IS-UNUSED *DRAFT-MSG*)
	 (TYPEIN-LINE "Aborted without editing or sending the message:~@
		       ~2@TThis draft message will be discarded.")
	 (THROW 'SEND-IT NIL))
	(T
	 (TYPEIN-LINE "Aborting without sending the message:~@
		       ~2@TClick on ~'i[Continue]~~@[ or press ~A~] ~
		       to resume editing this message."
		      (IF (EQ (COMMAND-LOOKUP #\Resume *ZMAIL-COMTAB*) 'COM-ZMAIL-CONTINUE)
			  #\Resume
			(KEY-FOR-COMMAND 'COM-ZMAIL-CONTINUE *ZMAIL-COMTAB*)))
	 (THROW 'SEND-IT NIL)))
  DIS-NONE)
;;; Send it off
(DEFCOM-FOR-ZMAIL COM-MAIL-END DOCUMENT-COM-MAIL-END ()
  (IF (KEY-SENDS-MESSAGE *LAST-COMMAND-CHAR*)
      (COM-SEND-MESSAGE)
      (COM-ADD-MORE-TEXT)))

(DEFUN DOCUMENT-COM-MAIL-END (COMMAND CHAR TYPE)
  (IGNORE COMMAND)
  (CL:CASE TYPE
    (:NAME
      (COND ((NULL CHAR) "Mail End")
	    ((KEY-SENDS-MESSAGE CHAR) "Send Message")
	    (T "Add More Text")))
    ((:FULL :SHORT)
      (COND ((NULL CHAR)
	     (IF (EQ TYPE :FULL)
		 (FORMAT T "Send the current message or add more text.~@
			    Which action is taken depends on the key used to invoke this~@
			    command and the setting of ~
			    ~'bzwei:*draft-editor-end-key-treatment*~.")
		 (FORMAT T "Send the current message or add more text.")))
	    ((KEY-SENDS-MESSAGE CHAR)
	     (FORMAT T "Send the current message."))
	    (T
	     (FORMAT T "Reselect the text portion of the message."))))))
(DEFUN KEY-SENDS-MESSAGE (CHAR)
  (COND ((NOT *INSIDE-MAIL*))
	((EQ (COMMAND-LOOKUP CHAR *COMTAB*) 'COM-SEND-MESSAGE))
	((EQ *WINDOW* *REPLY-WINDOW*))
	((AND (EQ *WINDOW* *MSG-WINDOW*)
	      (NOT (MEMQ *WINDOW-CONFIGURATION* *MULTI-WINDOW-SENDING-CONFIGURATIONS*))))
	(T
	 (UNLESS (CL:MEMBER CHAR '(#\End #\c-End) :TEST #'CHAR-EQUAL)
1	   ;; Treat all characters other than  as if they were c-.
0	   (SETQ CHAR #\c-End))
	 (CL:CASE *DRAFT-EDITOR-END-KEY-TREATMENT*
	   (:SEND-MSG (CHAR-EQUAL CHAR #\End))
	   (:BOTH-SEND-MSG T)
	   (:ADD-MORE-TEXT (CHAR-EQUAL CHAR #\c-End))
	   (:BOTH-ADD-MORE-TEXT NIL)))))
(DEFUN EXPLAIN-HOW-TO-SEND-MAIL ()
  (LET* ((END-KEY-COMMAND (COMMAND-LOOKUP #\End *COMTAB*))
	 (END-KEY-IS-END-COMMAND (EQ END-KEY-COMMAND 'COM-MAIL-END)))
    (COND ((EQ END-KEY-COMMAND 'COM-SEND-MESSAGE)
	   (TYPEIN-LINE-DURABLE "~:|Press ~A to send the message when done editing." #\End))
	  ((OR END-KEY-IS-END-COMMAND
	       (KEY-FOR-COMMAND 'COM-MAIL-END))
	   (TYPEIN-LINE-DURABLE "~:|Press ~A~:[~; in the window labeled ~'iMail~~] ~
				    to send the message when done editing."
				(IF END-KEY-IS-END-COMMAND #\End
							   (KEY-FOR-COMMAND 'COM-MAIL-END))
				(AND (MEMQ *WINDOW-CONFIGURATION*
					   *MULTI-WINDOW-SENDING-CONFIGURATIONS*)
				     (OR (NOT END-KEY-IS-END-COMMAND)
					 (MEMQ *DRAFT-EDITOR-END-KEY-TREATMENT*
					       '(:ADD-MORE-TEXT :BOTH-ADD-MORE-TEXT))))))
	  (T
	   (TYPEIN-LINE-DURABLE "~:|~:[Edit~;~
			               ~:*Press ~A to send the message when done editing~]."
				(KEY-FOR-COMMAND 'COM-SEND-MESSAGE))))))

(DEFCOM-FOR-ZMAIL COM-SEND-MESSAGE "Send the current message" ()
  (RESEPARATE-HEADER-AND-TEXT)
  (LET* ((*HANDLE-REFERENCES-LITERALLY* T)	;Use text that is there
	 (*ALLOW-NAMESPACE-SERVER-PARSING-HOST* T)
	 (HEADERS (GET-SEND-HEADERS *HEADER-INTERVAL*)))
    (SEND *DRAFT-MSG* :SAVE-WINDOW-STATE)	;In case of styles
    (SEND *DRAFT-MSG* :SET-HEADERS HEADERS)
    (LET ((*MINI-BUFFER-HISTORY* *ZMAIL-JUNK-MINI-BUFFER-HISTORY*))
      (SEND *DRAFT-MSG* :TRANSMIT))		; don't put <END> in command history
    (*THROW 'SEND-IT T)))

(DEFVAR *SEND-HEADER-ABBREVIATIONS*
  '((:FROM :F) (:SUBJECT :S :RE)))

(DEFUN GET-SEND-HEADERS (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (LET ((HEADERS (LET ((*PRESERVE-ADDRESS-INTERVALS* T))
		   (PARSE-HEADERS-INTERVAL START-BP END-BP IN-ORDER-P))))
    (LOOP FOR (EXPANSION . ABBREVS) IN *SEND-HEADER-ABBREVIATIONS*
	  AS HEADER = (MULTIPLE-VALUE-BIND (IGNORE IGNORE HEADER)
			  (CL:GET-PROPERTIES HEADERS ABBREVS)
			HEADER)
	  WHEN HEADER
	    IF (HEADER-TYPE-TYPEP EXPANSION :ADDRESS)
	      DO (DESTRUCTURING-BIND (TYPE VALUE)
				     (PARSING-HEADERS (PARSE-ERROR)
				       `(,EXPANSION ,(PARSE-ADDRESSES (SECOND HEADER))))
		   (CL:REMF HEADERS (FIRST HEADER))
		   (SETF (CL:GETF HEADERS TYPE) (APPEND (CL:GETF HEADERS TYPE) VALUE)))
	    ELSE
	      DO (SETF (FIRST HEADER) EXPANSION))
    (LET ((LOSING-HEADERS (CL:GETF HEADERS 'LOSING-HEADERS)))
      (WHEN LOSING-HEADERS
	(TYPEIN-LINE "Error parsing headers:~%")
	(MULTIPLE-VALUE-BIND (HEADERS-START-BP HEADERS-END-BP)
	    (MOVE-TO-HEADER-WINDOW)
	  (DOLIST (ERROR LOSING-HEADERS)
	    (IF (SEND ERROR :OPERATION-HANDLED-P :POSITION-AND-REPORT)
		(MULTIPLE-VALUE-BIND (LINE INDEX)
		    (SEND ERROR :POSITION-AND-REPORT *TYPEIN-WINDOW*)
		  (LET ((ERROR-BP (CREATE-BP LINE INDEX)))
		    (WHEN (AND (EQL (ARRAY-LEADER-LENGTH LINE) LINE-LEADER-SIZE)
			       (OR (BP-= HEADERS-START-BP ERROR-BP)
				   (BP-< HEADERS-START-BP ERROR-BP))
			       (BP-< ERROR-BP HEADERS-END-BP))
		      (MOVE-BP (POINT) LINE INDEX)
		      (RETURN (VALUES)))))
	      (SEND ERROR :REPORT *TYPEIN-WINDOW*))))
	(BARF)))
    HEADERS))
1;;; Asks the user for a header missing from the draft message.
0(DEFUN PROMPT-FOR-MISSING-HEADER (TYPE DRAFT-MSG)
  (UNLESS (MEMQ TYPE (SEND DRAFT-MSG :PROMPTED-HEADERS))
    (BEEP)					1;Get the user's attention.
0    (LET* ((NAME (HEADER-TYPE-NAME TYPE))
	   (FIELD (COND ((HEADER-TYPE-TYPEP TYPE :ADDRESS)
			 (PROMPT-FOR-ADDRESSES "~A:" NIL NIL NAME))
			((GET TYPE 'MULTI-LINE-HEADER)
			 (PROMPT-FOR-MULTI-LINE-HEADER NAME))
			(T
			 (PROMPT-FOR-HEADER "~A:" NIL NAME)))))
      (SEND DRAFT-MSG :REMEMBER-PROMPT-FOR-HEADER TYPE)
      (WHEN FIELD
	(UNLESS (EQUAL FIELD "")
	  (SEND DRAFT-MSG :ADD-HEADER TYPE FIELD)
	  (*THROW 'NEW-HEADERS T))))))

(DEFFLAVOR BAD-HEADER-BARF (HEADER-TYPE) (BARF)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:POSITION BAD-HEADER-BARF) ()
  (LET ((BP (ADD-HEADER-FIELD HEADER-TYPE NIL NIL NIL)))
    (VALUES (BP-LINE BP) (BP-INDEX BP))))

(DEFFLAVOR MISSING-HEADER-BARF () (BAD-HEADER-BARF))

(DEFMETHOD (:REPORT MISSING-HEADER-BARF) (STREAM)
  (FORMAT STREAM "You must include a non-empty ~S header" (HEADER-TYPE-NAME HEADER-TYPE)))

(DEFUN COMPLAIN-OF-MISSING-HEADER (HEADER-TYPE)
  (ERROR 'MISSING-HEADER-BARF ':HEADER-TYPE HEADER-TYPE))

(DEFFLAVOR UNHANDLED-HEADER-BARF () (BAD-HEADER-BARF))

(DEFMETHOD (:REPORT UNHANDLED-HEADER-BARF) (STREAM)
  (FORMAT STREAM "The ~S header would not have been transmitted."
	  (HEADER-TYPE-NAME HEADER-TYPE)))

(DEFUN COMPLAIN-OF-UNHANDLED-HEADER (HEADER-TYPE)
  (ERROR 'UNHANDLED-HEADER-BARF ':HEADER-TYPE HEADER-TYPE))

(DEFWHOPPER (:TRANSMIT EDITOR-DRAFT-MSG-MIXIN) ()
  (CONDITION-BIND ((BARF #'SEND-IT-BARF-INTERCEPTOR))
    (TYPEIN-LINE "~:|Sending...")
    (CONTINUE-WHOPPER)))

(DEFUN SEND-IT-BARF-INTERCEPTOR (COND)
  (WHEN (SEND COND :OPERATION-HANDLED-P :POSITION)
    ;;; Move POINT to the source of the error when possible
    (MULTIPLE-VALUE-BIND (LINE INDEX)
	(SEND COND :POSITION)
      (WHEN (AND LINE (EQL (ARRAY-LEADER-LENGTH LINE) LINE-LEADER-SIZE))
	(MOVE-TO-HEADER-WINDOW)
	(MOVE-BP (POINT) LINE INDEX)
	(MUST-REDISPLAY *WINDOW* DIS-BPS))))
  ;; Always pass the condition on to the real BARF handler
  NIL)

(DEFMETHOD (:HEADER-FIELD BASIC-DRAFT-MSG) (TYPE &AUX HEADER)
  (AND (SETQ HEADER (GET (LOCF HEADERS) TYPE))
       (PUSH TYPE HEADERS-HANDLED))
  HEADER)

(DEFMETHOD (:REMEMBER-PROMPT-FOR-HEADER BASIC-DRAFT-MSG) (TYPE)
  (UNLESS (MEMQ TYPE PROMPTED-HEADERS)
    (PUSH TYPE PROMPTED-HEADERS)))

(DEFINE-ZMAIL-GLOBAL *TRANSMIT-TIMESPACE-UNIQUIZER* 0)

(DEFINE-ZMAIL-GLOBAL *MESSAGE-TRANSMIT-HOOK* NIL)
(DEFINE-ZMAIL-GLOBAL *AFTER-MESSAGE-TRANSMIT-HOOK* NIL)

(DEFMETHOD (:TRANSMIT BASIC-DRAFT-MSG :BEFORE) ()
  (LOOP FOR HEADERS ON HEADERS BY 'CDDR
	WHEN (HEADER-TYPE-TYPEP (FIRST HEADERS) :FILE-RECIPIENT)
	  DO (SETF (SECOND HEADERS) (MAPCAR #'STRING (GET-FCC-PATHNAMES (SECOND HEADERS))))))

(DEFUN GET-FCC-PATHNAMES (FCC)
  (IF (LISTP FCC)
      (LOOP FOR STR IN FCC
	    NCONC (GET-FCC-PATHNAMES STR))
    (LET ((LIST (PARSE-COMMA-SEPARATED FCC)))
      (LOOP FOR LIST ON LIST
	    DO (SETF (CAR LIST) (FS:MERGE-PATHNAMES (CAR LIST) *ZMAIL-PATHNAME-DEFAULTS*)))
      LIST)))

(DEFMETHOD (:TRANSMIT BASIC-DRAFT-MSG) (&AUX RECIPIENTS-AND-TEMPLATES)
  (LET ((*RETAIN-COMMON-TAILS* T))		;assure full domain names
    (SETQ RECIPIENTS-DONE NIL
	  DISPOSITION-SUMMARIES NIL
	  PROMPTED-HEADERS NIL
	  TRANSMIT-TIMESTAMP (LIST (TIME:GET-UNIVERSAL-TIME)
				   (SETQ *TRANSMIT-TIMESPACE-UNIQUIZER*
					 (\ (1+ *TRANSMIT-TIMESPACE-UNIQUIZER*) 10.))))
    (LOOP NAMED RETRY				;This is in case the user supplies a header
						; required by one of the subtemplates.
	  DOING
      (*CATCH 'NEW-HEADERS
	(LOOP FOR (TEMPLATE . FIELDS) IN TRANSMIT-TEMPLATES
	      WITH DONE-ALREADY = NIL
	      AS RECIPIENTS = (LOOP FOR (TYPE HEADER) ON HEADERS BY 'CDDR
				    WHEN (AND (NOT (MEMQ TYPE DONE-ALREADY))
					      (IF (LISTP FIELDS)
						  (MEMQ TYPE FIELDS)
						(HEADER-TYPE-TYPEP TYPE FIELDS)))
				      NCONC (LOOP FOR RCPT IN HEADER
						  UNLESS (AND (LISTP RCPT)
							      (GETL (LOCF RCPT)
								    '(:INFERIORS)))
						    COLLECT RCPT)
				      AND DO (PUSH TYPE DONE-ALREADY))
	      WHEN (OR RECIPIENTS (AND (NULL R-AND-T) (EQ FIELDS ':RECIPIENT)))
		COLLECT (LIST
			  RECIPIENTS (EXPAND-TEMPLATE TEMPLATE ':DRAFT-MSG SELF)) INTO R-AND-T
	      FINALLY (RETURN-FROM RETRY (SETQ RECIPIENTS-AND-TEMPLATES R-AND-T)))))
    (LOOP FOR (TYPE VAL) ON HEADERS BY 'CDDR
	  WHEN (AND VAL (NOT (MEMQ TYPE HEADERS-HANDLED)))
	    DO (COMPLAIN-OF-UNHANDLED-HEADER TYPE))
    (COND ((OR (NULL RECIPIENTS-AND-TEMPLATES)
	       (NOT (LOOP FOR (RECIPIENT . NIL) IN RECIPIENTS-AND-TEMPLATES
			  THEREIS RECIPIENT)))
	   (BARF "This message isn't being sent to anyone."))
	  ((CDR RECIPIENTS-AND-TEMPLATES)
	   (LOOP FOR ELEM IN RECIPIENTS-AND-TEMPLATES
		 DO (PUTPROP (LOCF (CADR ELEM)) T ':MULTIPLE-SENDINGS))))
    (LOOP FOR (RECIPIENTS TEMPLATE-EXPANSION) IN RECIPIENTS-AND-TEMPLATES
	  ;; hook for intervention in message transmission.  If there is one, run it; if none
	  ;; or if it returns :CONTINUE-MESSAGE-TRANSMIT, transmit the message normally.
	  WHEN (OR (NULL *MESSAGE-TRANSMIT-HOOK*)
		   (EQ :CONTINUE-MESSAGE-TRANSMIT
		       (FUNCALL *MESSAGE-TRANSMIT-HOOK* RECIPIENTS TEMPLATE-EXPANSION)))
	    DO (FUNCALL-TEMPLATE-EXPANSION TEMPLATE-EXPANSION
					   (OR (GET (LOCF TEMPLATE-EXPANSION) ':SENDING-MODE)
					       *MAIL-SENDING-MODE*)
					   RECIPIENTS TEMPLATE-EXPANSION))
    (WHEN *AFTER-MESSAGE-TRANSMIT-HOOK*
      (FUNCALL *AFTER-MESSAGE-TRANSMIT-HOOK* SELF RECIPIENTS-AND-TEMPLATES))))

(DEFUN-IN-FLAVOR (CURRENT-MESSAGE-ID BASIC-DRAFT-MSG) (EXPANSION)
  (LET* ((TRANSMIT-HEADERS (CL:GETF EXPANSION :HEADERS))
	 (MESSAGE-ID (LOOP FOR (TYPE VALUE) ON TRANSMIT-HEADERS BY 'CDDR
			   WHEN (HEADER-TYPE-TYPEP TYPE :MESSAGE-ID)
			     RETURN VALUE)))
    (IF MESSAGE-ID
	`(:MESSAGE-ID ,MESSAGE-ID)
      (LOOP FOR (TYPE VALUE) ON TRANSMIT-HEADERS BY 'CDDR
	    WHEN (HEADER-TYPE-TYPECASE TYPE
		   (:DATE
		     (SETQ TYPE :DATE)
		     T)
		   (:SENDER
		     (SETQ TYPE :FROM
			   VALUE (SOME-PLIST (FIRST VALUE) '(:NAME :HOST
							     :PERSONAL-NAME :USER)))
		     T))
	      COLLECT TYPE AND COLLECT VALUE))))

(DEFMETHOD (MARK-MESSAGE-TRANSMITTING BASIC-DRAFT-MSG) (EXPANSION)
  (LET ((RDE-ID (CURRENT-MESSAGE-ID EXPANSION)))
    (LOOP FOR RDE IN RECIPIENTS-DONE
	  WHEN (EQUAL RDE-ID (FIRST RDE))
	    RETURN ()
	  FINALLY
	    (PUSH `(,RDE-ID :TRANSMITTING) RECIPIENTS-DONE))))

(DEFUN PRINT-RECIPIENTS-LIST (RECIPIENTS-LIST)
  (SCL:FORMAT-TEXTUAL-LIST RECIPIENTS-LIST #'PRINC :CONJUNCTION "and"))

(DEFMETHOD (:MESSAGE-SENT BASIC-DRAFT-MSG) (RECIPIENTS EXPANSION RECIPIENT-PRINTER
					    &OPTIONAL FORMAT-STRING &REST FORMAT-ARGS)
  ;; Record that this part is done.
  (LET ((RDE-ID (CURRENT-MESSAGE-ID EXPANSION)))
    (LOOP FOR RDE IN RECIPIENTS-DONE
	  WHEN (EQUAL RDE-ID (FIRST RDE))
	    RETURN
	      (SETF (CL:REST RDE) (APPEND RECIPIENTS (CL:DELETE :TRANSMITTING (CL:REST RDE))))
	  FINALLY
	    (PUSH `(,RDE-ID ,@RECIPIENTS) RECIPIENTS-DONE)))
  ;; Now tell the user --
  ;;    Save the timestamp for appropriate output later by print-brief-universal-time.
  (LET ((DISPOSITION
	  (LIST "Message of ~A sent successfully~:[~2*~; to ~VQ~]~@[ ~?~]."
		(FIRST TRANSMIT-TIMESTAMP)
		(NOT (NULL (GET (LOCF EXPANSION) :MULTIPLE-SENDINGS)))
		(LOOP FOR RECIPIENT IN RECIPIENTS
		      COLLECT (WITH-OUTPUT-TO-STRING (STREAM)
				(FUNCALL RECIPIENT-PRINTER RECIPIENT STREAM)))
		'PRINT-RECIPIENTS-LIST
		FORMAT-STRING
		(COPYLIST FORMAT-ARGS))))
    (LET ((STREAM (SEND SELF :REPORT-STREAM)))
      (WHEN STREAM
	(IF (AND (VARIABLE-BOUNDP *TYPEIN-WINDOW*) (EQ STREAM *TYPEIN-WINDOW*)
		 (NULL DISPOSITION-SUMMARIES))	;Clear "Sending..."
	    (TYPEIN-LINE-DURABLE "~:|~A" (FORMAT-DRAFT-DISPOSITION DISPOSITION))
	    (FORMAT STREAM "~&~A~%" (FORMAT-DRAFT-DISPOSITION DISPOSITION)))))
    (PUSH DISPOSITION DISPOSITION-SUMMARIES)))

(DEFMETHOD (:REPORT-STREAM BASIC-DRAFT-MSG) () *TYPEIN-WINDOW*)

;;; For address type recipients
(DEFUN MESSAGE-SENT-ADDRESS-RECIPIENT-PRINTER (RCPT STREAM)
  (STRING-OUT (STRING-FROM-HEADER RCPT ':SHORT) STREAM))

(DEFMETHOD (:TEXT DRAFT-MSG) ()
  (COPY-INTERVAL-WITH-FRESH-LINE *REPLY-INTERVAL*))

(DEFUN COPY-INTERVAL-WITH-FRESH-LINE (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (LET ((INT (COPY-INTERVAL START-BP END-BP IN-ORDER-P)))
    (LET ((END-BP (INTERVAL-LAST-BP INT)))
      (OR (ZEROP (BP-INDEX END-BP)) (INSERT END-BP #\CR)))
    INT))

(DEFMETHOD (:TRANSMIT COMMAND-DRAFT-MSG-MIXIN :AFTER) ()
  (DOLIST (M MSGS-BEING-REPLIED-TO)		;Mark if it was a reply
    (MSG-PUT M T 'ANSWERED))
  (DOLIST (M MSGS-BEING-FORWARDED)
    (MSG-PUT M T 'FORWARDED)))

(DEFMETHOD (:TRANSMIT DRAFT-MSG :BEFORE) ()
  (WHEN RECIPIENTS-DONE
    1;; Retransmission --
    ;;    First let the user know that he's resending a message.
0    (BEEP)					1;Let's be nice and attract his attention...
0    (CL:CASE *ADD-SUPERSEDES-AND-COMMENTS-WHEN-RETRANSMITTING*
      ((:NEVER :SUPERSEDES-ONLY)
       (TYPEIN-LINE "~2@T(~?;~%~3@Tthis copy of the message will~:[not~] ~
		                   supersede any prior transmissions.)"
		    (IF (LOOP FOR (NIL . RECIPIENTS) IN RECIPIENTS-DONE
			      NEVER (NOT (EQUAL RECIPIENTS '(:TRANSMITTING))))
			"Message may have been sent to some recipients"
			"Message has already been sent~:[ to some recipients~]")
		    (LIST SENT-P)
		    (EQ *ADD-SUPERSEDES-AND-COMMENTS-WHEN-RETRANSMITTING* :SUPERSEDES-ONLY)))
      ((:ASK :SUPERSEDES-THEN-ASK :ALWAYS)
       (TYPEOUT-LINE "~@?" (IF (LOOP FOR (NIL . RECIPIENTS) IN RECIPIENTS-DONE
				     NEVER (NOT (EQUAL RECIPIENTS '(:TRANSMITTING))))
			       "Message may have been sent to some recipients."
			       "Message has already been sent~:[ to some recipients~].")
		     SENT-P)
       (WHEN (NEQ *ADD-SUPERSEDES-AND-COMMENTS-WHEN-RETRANSMITTING* :ASK)
	 (TYPEOUT-LINE "~2@TThis copy of the message will supersede any prior transmissions."))
       ))
    1;;    Now, either add 0Supersedes1 and 0Comments1 fields or ask for permission to do so.
0    (LET* ((SUPERSEDE
	     (CL:CASE *ADD-SUPERSEDES-AND-COMMENTS-WHEN-RETRANSMITTING*
	       ((:NEVER) NIL)
	       ((:ASK)
		 (TYPEOUT-YES-OR-NO-P "~2@TDo you want this copy of the message to ~
					   supersede any prior transmissions? "))
	       ((:SUPERSEDES-ONLY :SUPERSEDES-THEN-ASK :ALWAYS) T)))
	   (ADD-COMMENTS
	     (AND SUPERSEDE
		  (CL:CASE *ADD-SUPERSEDES-AND-COMMENTS-WHEN-RETRANSMITTING*
		    ((:NEVER :SUPERSEDES-ONLY) NIL)
		    ((:ASK :SUPERSEDES-THEN-ASK)
		     (TYPEOUT-YES-OR-NO-P "~&~2@TDo you wish to add an explanation ~
					         for this retransmission? "))
		    ((:ALWAYS) T)))))
      (WHEN SUPERSEDE
	(LET ((*HANDLE-REFERENCES-LITERALLY* NIL))
	  (SEND SELF :ADD-HEADER :SUPERSEDES
		(CL:REMOVE-DUPLICATES (APPEND (CL:GETF HEADERS :SUPERSEDES)
					      (SEND SELF :REFERENCES))
				      :TEST #'REFERENCE-EQUAL))))
      (WHEN ADD-COMMENTS
	(LET ((NEW-COMMENTS (PROMPT-FOR-MULTI-LINE-HEADER "Comments"))
	      (CURRENT-COMMENTS (CL:GETF HEADERS :COMMENTS)))
	  (WHEN NEW-COMMENTS
	    (SEND SELF :ADD-HEADER :COMMENTS (MERGE-COMMENTS CURRENT-COMMENTS NEW-COMMENTS)))))
      ))
  (SETQ SENT-P NIL))
(DEFUN MERGE-COMMENTS (OLD-COMMENTS NEW-COMMENTS)
  (FLET ((SPLIT-OR-NCONS (THING)
	   (COND ((LISTP THING) THING)
		 ((STRING-SEARCH #\Return THING)
		  (PARSE-COMMA-SEPARATED THING 0 #.(STRING #\Return)))
		 (T (NCONS THING)))))
    (IF (NULL OLD-COMMENTS) NEW-COMMENTS
      (APPEND (SPLIT-OR-NCONS OLD-COMMENTS) (SPLIT-OR-NCONS NEW-COMMENTS)))))

(DEFMETHOD (:REFERENCES BASIC-DRAFT-MSG) ()
  (LOOP FOR (ID) IN RECIPIENTS-DONE
	COLLECT ID))

(DEFMETHOD (:RECIPIENTS BASIC-DRAFT-MSG) ()
  (LOOP FOR (NIL . RECIPIENTS) IN RECIPIENTS-DONE
	APPEND (SUBSET #'LISTP RECIPIENTS)))

(DEFMETHOD (:BUFFER-RECIPIENTS BASIC-DRAFT-MSG) ()
  (LOOP FOR (NIL . RECIPIENTS) IN RECIPIENTS-DONE
	APPEND (SUBSET #'(LAMBDA (X) (TYPEP X 'SEQUENCE)) RECIPIENTS)))

(DEFMETHOD (:TRANSMIT DRAFT-MSG :AFTER) ()
  (SETQ SENT-P T
	SUMMARY-STRING-TICK -1)
  (WHEN (AND MSG (NEQ (MSG-PARSED-P MSG) :KILLED))
    (MSG-PUT MSG T 'SENT)))

;;; Add a header that the user was prompted for.
(DEFMETHOD (:ADD-HEADER BASIC-DRAFT-MSG) (TYPE HEADER)
  (PUTPROP (LOCF HEADERS) HEADER TYPE))

(DEFMETHOD (:ADD-HEADER EDITOR-DRAFT-MSG-MIXIN :BEFORE) (TYPE HEADER)
  (ADD-HEADER-TYPE-FIELD HEADER TYPE))

(DEFMETHOD (:CONTINUE-AND-TRANSMIT DRAFT-MSG) ()
  (ZMAIL-UNDO-SAVE UNDO-ENTRY)
  (SEND SELF :SET-HEADERS (LET* ((*HANDLE-REFERENCES-LITERALLY* T)
				 (*ALLOW-NAMESPACE-SERVER-PARSING-HOST* T))
			    (GET-SEND-HEADERS HEADER-INTERVAL)))
  (SEND SELF :TRANSMIT)
  DIS-NONE)

;;; Drafts not from inside zmail, or whose text isn't edited.
(DEFFLAVOR DUMMY-DRAFT-MSG
	(TEXT)
	(BASIC-DRAFT-MSG)
  (:INITABLE-INSTANCE-VARIABLES TEXT)
  (:GETTABLE-INSTANCE-VARIABLES TEXT))

(DEFMETHOD (:SUMMARY-STRING DUMMY-DRAFT-MSG) ()
  (SEND SELF ':COMPUTE-SUMMARY-STRING HEADERS TEXT))

(defmethod (:draft-interval dummy-draft-msg) ()
  text)

;;; This is the interface from ZMACS C-X M and (MAIL).
(DEFFLAVOR ZMACS-DRAFT-MSG
	((TRANSMIT-TEMPLATES '((BARF-WHEN-FILE-RECIPIENTS-TEMPLATE . :FILE-RECIPIENT)
			       (BCC-TRANSMIT-TEMPLATE :BCC)
			       (NORMAL-TRANSMIT-TEMPLATE . :RECIPIENT)))
	 (BUG-REPORT NIL))
	(EDITOR-DRAFT-MSG-MIXIN DUMMY-DRAFT-MSG)
  (:SETTABLE-INSTANCE-VARIABLES BUG-REPORT))

(DEFUN SEND-MESSAGE (HEADER-BP1 HEADER-BP2 HEADER-IN-ORDER-P
		     TEXT-BP1 &OPTIONAL TEXT-BP2 TEXT-IN-ORDER-P (window *window*))
  (MAKE-DRAFT-AND-TRANSMIT
    'ZMACS-DRAFT-MSG
    :HEADERS (LET ((*ALLOW-NAMESPACE-SERVER-PARSING-HOST* T))
	       (GET-SEND-HEADERS HEADER-BP1 HEADER-BP2 HEADER-IN-ORDER-P))
    :TEXT (COPY-INTERVAL-WITH-FRESH-LINE TEXT-BP1 TEXT-BP2 TEXT-IN-ORDER-P)
    :BUG-REPORT (SEND-IF-HANDLES (BP-TOP-LEVEL-NODE TEXT-BP1) :BUG-REPORT)
    :DEFAULT-CHARACTER-STYLE (SEND (WINDOW-SHEET WINDOW) :DEFAULT-STYLE)
    ))

;;; This is for use by programs that want to send mail.  It is used by
;;; Converse for mailing failing sends.
(DEFFLAVOR SEND-MESSAGE-STRING-DRAFT-MSG
	((TRANSMIT-TEMPLATES '((DEFAULT-TRANSMIT-TEMPLATE . :RECIPIENT)))
	 (REPORT-STREAM NIL))
	(DUMMY-DRAFT-MSG)
  (:GETTABLE-INSTANCE-VARIABLES REPORT-STREAM)
  (:INITABLE-INSTANCE-VARIABLES REPORT-STREAM))

(DEFUN SEND-MESSAGE-STRING (TO MESSAGE &REST HEADERS &KEY REPORT-STREAM &ALLOW-OTHER-KEYS)
  ;; Copy headers, since stored into draft, which might be saved someplace.
  (SETQ HEADERS `(:TO ,TO . ,(COPYLIST (SI:REM-KEYWORDS HEADERS '(:REPORT-STREAM)))))
  (LOOP FOR HEADERS-LIST ON HEADERS BY 'CDDR
	AS (TYPE HEADER) = HEADERS-LIST
	DOING
    ;; This is user-interface, try real hard to guess what the caller might want.
    ;; Convert strings and lists of strings into internal format.
    (WHEN (TYPECASE HEADER
	    (:STRING T)
	    (:LIST (LOOP FOR PIECE IN HEADER THEREIS (STRINGP PIECE))))
      (WHEN
	(HEADER-TYPE-TYPECASE TYPE
	  (:ADDRESS
	   (TYPECASE HEADER
	     (:STRING
	      (SETQ HEADER (PARSE-ADDRESSES HEADER))
	      T)
	     (:LIST
	      (SETQ HEADER (LOOP FOR ADDR IN HEADER
				 WHEN (STRINGP ADDR)
				 APPEND (PARSE-ADDRESSES ADDR)
				 ELSE COLLECT ADDR))
	      T)))
	  (:DATE
	   (WHEN (LISTP HEADER)
	     (SETQ HEADER (FIRST HEADER)))
	   (SETQ HEADER (PARSE-RFC822-DATE-TIME HEADER))
	   T)
	  (:DATE-AND-OPTIONAL-TIME
	   (UNLESS (LISTP HEADER)
	     (SETQ HEADER (LIST HEADER)))
	   (SETQ HEADER (LOOP FOR DATE IN HEADER
			      COLLECT (MULTIPLE-VALUE-BIND (TIME NIL TIME-P)
					  (TIME:PARSE-UNIVERSAL-TIME DATE)
					(LIST TIME TIME-P))))
	   T))
	(SETF (SECOND HEADERS-LIST) HEADER))))
  (MAKE-DRAFT-AND-TRANSMIT 'SEND-MESSAGE-STRING-DRAFT-MSG
			   :HEADERS HEADERS :TEXT MESSAGE
			   :REPORT-STREAM REPORT-STREAM))

(CP:DEFINE-COMMAND (COM-SEND-MAIL :COMMAND-TABLE "Mail Reading//Sending"
				  :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    ((ADDRESSES '((CL:SEQUENCE ADDRESS))
		:PROMPT "recipients"
		:DOCUMENTATION "Recipient(s) of the message.")
     &KEY (SUBJECT 'STRING
		   :DEFAULT NIL
		   :DOCUMENTATION "Subject of the message.")
	  (CC '((CL:SEQUENCE ADDRESS))
	      :NAME "cc"
	      :PROMPT "recipients"
	      :DEFAULT NIL
	      :DOCUMENTATION "Additional (secondary) recipient(s) of the message.")
	  (FROM '((CL:SEQUENCE ADDRESS))
		:PROMPT "authors"
		:DEFAULT NIL
		:DOCUMENTATION "Author(s) of the message."))
   (FS:FORCE-USER-TO-LOGIN)
   (CONDITION-CASE (.ERROR.)
	(LET ((MESSAGE (QSEND-GET-MESSAGE
			 ADDRESSES STANDARD-INPUT
			 (FORMAT NIL "To: ~A~@[~%cc: ~A~]~@[~%Subject: ~A~]~@[~%From: ~A~]"
				 (CONVERSE-ADDRESSES-STRING ADDRESSES)
				 (WHEN CC
				   (CONVERSE-ADDRESSES-STRING CC))
				 SUBJECT
				 (WHEN FROM
				   (CONVERSE-ADDRESSES-STRING FROM))))))
	  (SEND-MESSAGE-STRING ADDRESSES MESSAGE :REPORT-STREAM STANDARD-OUTPUT
						 :CC CC
						 :SUBJECT SUBJECT
						 :FROM FROM))
      (BARF
	(BEEP)
	(FORMAT CL:*ERROR-OUTPUT* "~&~A" .ERROR.))))

;;;; Mailing methods

(DEFINE-SECTION-NAME |Mailing Methods|)

#|
(DEFINE-ZMAIL-USER-OPTION *DEFAULT-HEADER-FORCE* ':NONE :MENU-ALIST
			  "Default header force (via COMSAT)"
			  *HEADER-FORCE-ALIST*)
(TV:RESTRICT-USER-OPTION *DEFAULT-HEADER-FORCE* :IF :COMSAT)
|#

(DEFINE-ZMAIL-GLOBAL *DEFAULT-HEADER-FORCE* ':NONE)

(DEFVAR *MAIL-QUEUE-FILE* "DSK: .MAIL.; MAIL >")

;;; Sort of weird, since COMSAT likes to generate the headers, we throw away most of the
;;; information accumulated.
(DEFUN FILE-SEND-IT (RECIPIENTS TEMPLATE-EXPANSION &AUX FILE-NAME USER
							(LIST NIL) (PLIST (LOCF LIST))
							(LITERAL-P NIL))
  (LET ((ITS-PATHNAME (FS:USER-HOMEDIR)))
    (SETQ FILE-NAME (FS:PARSE-PATHNAME *MAIL-QUEUE-FILE*
				       (IF (TYPEP ITS-PATHNAME 'FS:ITS-PATHNAME)
					   (SEND ITS-PATHNAME :HOST)
					 "MC"))))
  ;; Use the UNAME for ITS in the file
  (SEND FILE-NAME :HOMEDIR)
  (WHEN (OR (NULL (SETQ USER (SEND (SEND FILE-NAME :HOST) :HOST-USER-ID)))
	    (STRING-EQUAL USER USER-ID))
    (SETQ USER USER-ID))
  (LET ((HEADERS (GET (LOCF TEMPLATE-EXPANSION) :HEADERS)))
    (LET* ((FROM (GET (LOCF HEADERS) :FROM))
	   (SBP (WHEN FROM
		  (FIRST (SECOND (CL:GETF (FIRST FROM) '(:INTERVAL :ORIGINAL-INTERVAL))))))
	   (EBP (WHEN SBP
		  (SECOND (SECOND (CL:GETF (FIRST (LAST FROM))
					   '(:INTERVAL :ORIGINAL-INTERVAL)))))))
      ;; This is somewhat of a kludge, but COMSAT likes to put in the @MIT-MC itself.
      (PUTPROP PLIST
	       (IF (AND SBP EBP) (STRING-INTERVAL SBP EBP) USER)
	       :AUTHOR))
    (LOOP WITH CC = (GET (LOCF HEADERS) :CC)
	  FOR RCPT IN RECIPIENTS
	  WHEN (MEMQ RCPT CC)
	    COLLECT RCPT INTO CCS
	  ELSE
	    COLLECT RCPT INTO TOS
	  FINALLY
	    (WHEN CCS (PUTPROP PLIST CCS :CC))
	    (WHEN TOS (PUTPROP PLIST TOS :TO)))
    (IF (GET (LOCF HEADERS) 'LITERAL-HEADERS)
	(PROGN
	  (PUTPROP PLIST
		   (DPB 7 (BYTE 8 28.) (SEND NET:*LOCAL-HOST* :CHAOS-ADDRESS))
		   :NET-MAIL-FROM-HOST)
	  (SETQ LITERAL-P T))
      (LOOP FOR (TYPE HEADER) ON HEADERS BY 'CDDR
	    WHEN (EQ TYPE :SUBJECT)
	      DO (PUTPROP PLIST HEADER :SUBJECT)
	    ELSE WHEN (NOT (MEMQ TYPE '(:DATE :FROM :SENDER :TO :CC)))
		   DO (SETQ LIST (NCONC LIST
					(LIST :USER-HEADER
					      (STRING-RIGHT-TRIM
						'(#\CR)
						(WITH-OUTPUT-TO-STRING (STREAM)
						  (PRINT-HEADER STREAM HEADER TYPE NIL))))))
			   )))
  (UNLESS (EQ *DEFAULT-HEADER-FORCE* :NONE)
    (PUTPROP PLIST *DEFAULT-HEADER-FORCE* :HEADER-FORCE))
  (PUTPROP PLIST 'ZMAIL :FROM-PROGRAM)
  (PUTPROP PLIST USER :FROM-UNAME)
  (PUTPROP PLIST USER :FROM-XUNAME)
  (LET ((DRAFT-MSG (GET (LOCF TEMPLATE-EXPANSION) :DRAFT-MSG)))
    (WHEN DRAFT-MSG
      (MARK-MESSAGE-TRANSMITTING DRAFT-MSG TEMPLATE-EXPANSION))
    (WITH-OPEN-FILE (STREAM FILE-NAME :DIRECTION :OUTPUT)
      (DO ((LIST (CAR PLIST) (CDDR LIST))
           (TYPE) (ITEMS)
	   (CC-P NIL NIL))
          ((NULL LIST))
        (SETQ TYPE (CAR LIST)
	      ITEMS (CADR LIST))
	(WHEN (EQ TYPE :CC) (SETQ TYPE :TO CC-P T))
        (UNLESS (LISTP ITEMS) (SETQ ITEMS (LIST ITEMS)))
        (DO ((ITEMS ITEMS (CDR ITEMS))
	     (ITEM) (HOST)
	     (OPEN-P NIL NIL))
	    ((NULL ITEMS))
	  (SETQ ITEM (CAR ITEMS))
	  (IF (NEQ TYPE :TO)
	      (FORMAT STREAM "~A:~A~%" TYPE ITEM)
	    (LET ((PL (LOCF ITEM)))
	      (SETQ ITEM (GET PL :NAME)
		    HOST (GET PL :HOST))
	      (LET ((USER (GET PL :USER)))
		(WHEN USER
		  (SETF `(,ITEM ,HOST) (SEND USER :MAIL-ADDRESS))
		  (SETQ HOST `(:OBJECT ,HOST)))))
	    (SELECTQ (FIRST HOST)
	      (:PATH
	       (SETQ ITEM (WITH-OUTPUT-TO-STRING (STREAM)
			    (SEND STREAM :STRING-OUT ITEM)
			    (DOLIST (HOST (REST1 (BUTLAST HOST)))
			      (SEND STREAM :TYO #\@)
			      (IF (STRINGP HOST)
				  (SEND STREAM :STRING-OUT HOST)
				  (SELECTQ (FIRST HOST)
				    ((:DOMAIN :SINGLE)
				     (SEND STREAM :STRING (SECOND HOST)))
				    (:OBJECT
				     (SEND STREAM :STRING-OUT (SEND (SECOND HOST) :MAIL-NAME)))
				    ))))
		     HOST (LET ((HOST (FIRST (LAST HOST))))
			    (IF (STRINGP HOST)
				HOST
				(SELECTQ (FIRST HOST)
				  ((:DOMAIN :SINGLE)
				   (SECOND HOST))
				  (:OBJECT
				   (SEND (SECOND HOST) :MAIL-NAME)))))))
	      ((:DOMAIN :SINGLE)
	       (SETQ HOST (SECOND HOST)))
	      (:OBJECT
	       (SETQ HOST (SEND (SECOND HOST) :MAIL-NAME))))
	    ;; There is no consistent way to send structured recipients.
	    ;; Also, quoting doesn't work right.
	    (LET ((LEN-1 (1- (STRING-LENGTH ITEM))))
	      (COND ((MINUSP LEN-1))
		    ((AND (CHAR= (AREF ITEM 0) #/()
			  (CHAR= (AREF ITEM LEN-1) #/)))
		     (SETQ ITEM (SUBSTRING ITEM 1 LEN-1)
			   OPEN-P T))
		    ((AND (CHAR= (AREF ITEM 0) #/")
			  (CHAR= (AREF ITEM LEN-1) #/"))
		     (SETQ OPEN-P T))))
	    (FORMAT STREAM "~A:(~:[/"~A/"~;~A~]~@[ ~A~]~:[~; (R-OPTION CC)~])~%"
		    TYPE OPEN-P ITEM HOST CC-P))))
      (SEND STREAM :LINE-OUT "TEXT;-1")
      (FUNCALL (IF LITERAL-P #'OUTPUT-HEADERS-AND-TEXT #'OUTPUT-TEXT)
	       STREAM TEMPLATE-EXPANSION))
    (WHEN DRAFT-MSG
      (SEND DRAFT-MSG :MESSAGE-SENT RECIPIENTS TEMPLATE-EXPANSION
	    #'MESSAGE-SENT-ADDRESS-RECIPIENT-PRINTER "via COMSAT on ~A"
	    (SEND (SEND FILE-NAME :HOST) :NAME-AS-FILE-COMPUTER)))))

;;;; Redistribution

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REDISTRIBUTE-MSG "Redistribute this message" ()
  (COMPOSE-FROM-TEMPLATE (CHOOSE-MAIL-TEMPLATE ':REDISTRIBUTE)
			 ':MSGS (LIST *MSG*)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REDISTRIBUTE-ALL "Redistribute these messages" ()
  (CHECK-FOR-TOO-MANY-MSGS "redistribute")
  (COMPOSE-FROM-TEMPLATE (CHOOSE-MAIL-TEMPLATE ':REDISTRIBUTE)
			 ':MSGS (LIST-SEQUENCE *SEQUENCE*)))

;;; This is the thing that does it.
(DEFUN REDISTRIBUTE-COMPOSITION-FUNCTION (EXPANSION)
  (LET ((HEADERS (SOME-PLIST (GET (LOCF EXPANSION) ':HEADERS)
			     '(:REDISTRIBUTED-TO :RESENT-COMMENTS)))
	(TRANSMIT-TEMPLATES (GET (LOCF EXPANSION) ':TRANSMIT-TEMPLATES)))
    (DOLIST (MSG (GET (LOCF EXPANSION) ':MSGS))
      (MAKE-DRAFT-AND-TRANSMIT 'REDISTRIBUTE-DRAFT-MSG ':MSG MSG
			       ':HEADERS HEADERS ':TRANSMIT-TEMPLATES TRANSMIT-TEMPLATES)))
  (COMPUTE-CURRENT-MSG-STATE))

(DEFUN PROMPT-FOR-ADDRESSES (PROMPT &OPTIONAL (BLANK-LINE-ACTION :ERROR)
					      DEFAULT-ADDRESSES
				    &REST PROMPT-ARGS
				    &AUX RECIPIENTS)
  (WHEN DEFAULT-ADDRESSES
    (SEND *ADDRESS-HISTORY* :PUSH (ADDRESS-HEADER-STRING DEFAULT-ADDRESSES)))
  (SETQ RECIPIENTS
	(IF (VARIABLE-BOUNDP ZWEI:*MINI-BUFFER-WINDOW*)	;prompt may happen in LL
	    (LEXPR-FUNCALL #'TYPEIN-LINE-HISTORY-READLINE *ADDRESS-HISTORY* NIL
			   BLANK-LINE-ACTION PROMPT PROMPT-ARGS)
	  (DW:ACCEPT '((CL:STRING))
		     :PROMPT (STRING-APPEND
			       (LEXPR-FUNCALL #'FORMAT NIL PROMPT PROMPT-ARGS) #\SPACE)
		     :PROMPT-MODE :RAW :DISPLAY-DEFAULT NIL :DEFAULT DEFAULT-ADDRESSES)))
  (BARF-ON-ERRORS (PARSE-ERROR)
    (SETQ RECIPIENTS (LET ((*ALLOW-NAMESPACE-SERVER-PARSING-HOST* T))
		       (PARSE-ADDRESSES RECIPIENTS))))
  RECIPIENTS)

(DEFUN PROMPT-FOR-HEADER (PROMPT &OPTIONAL (BLANK-LINE-ACTION :ERROR)
				 &REST PROMPT-ARGS)
  (IF (VARIABLE-BOUNDP ZWEI:*MINI-BUFFER-WINDOW*)	;prompt may happen in LL
      (LEXPR-FUNCALL #'TYPEIN-LINE-HISTORY-READLINE
		     NIL NIL BLANK-LINE-ACTION PROMPT PROMPT-ARGS)
    (DW:ACCEPT '((CL:STRING))
	       :PROMPT (STRING-APPEND (LEXPR-FUNCALL #'FORMAT NIL PROMPT PROMPT-ARGS) #\SPACE)
	       :PROMPT-MODE :RAW :DISPLAY-DEFAULT NIL)))
(DEFUN PROMPT-FOR-MULTI-LINE-HEADER (PROMPT &REST PROMPT-ARGS)
  (LET ((ACCEPT-FUNCTION
	  (IF (VARIABLE-BOUNDP ZWEI:*MINI-BUFFER-WINDOW*) #'TYPEIN-LINE-ACCEPT #'SCL:ACCEPT))
	(PROMPT
	  (FORMAT NIL "~@? (terminate with ): " PROMPT PROMPT-ARGS)))
    (FUNCALL ACCEPT-FUNCTION 'CL:STRING :PROMPT PROMPT
					:PROMPT-MODE :RAW
					:DEFAULT NIL
					:ACTIVATION-CHARS '(#\End #\c-End))))    

;;; A redistributed message.
(DEFFLAVOR REDISTRIBUTE-DRAFT-MSG
	(MSG TRANSMIT-TEMPLATES)
	(DUMMY-DRAFT-MSG)
  (:INITABLE-INSTANCE-VARIABLES MSG TRANSMIT-TEMPLATES)
  (:GETTABLE-INSTANCE-VARIABLES MSG))

(DEFMETHOD (:INIT REDISTRIBUTE-DRAFT-MSG :AFTER) (IGNORE)
  (SETQ TEXT (MULTIPLE-VALUE-BIND (START-BP END-BP)
		 (MSG-BODY-INTERVAL MSG)
	       (IF (NULL END-BP) START-BP
		   (CREATE-INTERVAL START-BP END-BP)))))

(DEFMETHOD (:TRANSMIT REDISTRIBUTE-DRAFT-MSG :AFTER) ()
  (MSG-PUT MSG T 'REDISTRIBUTED))

(DEFMETHOD (:SUMMARY-STRING REDISTRIBUTE-DRAFT-MSG) ()
  (IF (EQ (MSG-PARSED-P MSG) :KILLED)
      (FORMAT NIL "Redistribution of [expunged message]")
    (FORMAT NIL "Redistribution of ~A to ~A"
	    (MSG-DESCRIPTION MSG)
	    (SUMMARIZE-RECIPIENTS (LOOP FOR (TYPE HEADER) ON HEADERS BY 'CDDR
					WHEN (HEADER-TYPE-TYPEP TYPE ':RECIPIENT)
					  APPEND HEADER)
				  30.))))

;;; Redirection

(DEFVAR *REDIRECT-REFERENCE-MSG* NIL)
(DEFVAR *REDIRECTED-MSG* NIL)

;;; The command Redirect Msg.  It queries for addressees to remove from a message,
;;; addressees to add, and any comment that the redirector has.  Then it does four things:
;;;  1> A message is dispatched to the removed addressees, telling them what happened to 
;;;     the message, and with a reference to it.
;;;  2> The original message is redistributed, with a new set of addressees (old and added), 
;;;     with a comment explaining the redirection, and with a Supersedes: header to eliminate
;;;     both the old copy and the reference message in 1> (for recipients who receive both).
;;;  3> The redistributor's in-buffer copy of the original message is altered to contain
;;;     the new addressees and the redirection notation.
;;;  4> The user is queried as to whether a reply is desired, too.  If yes, the normal reply
;;;     is entered.
;;; Due to the nature of the template mechanism, and my understanding of it, the modularity 
;;; of this operation is not wonderful.  It should be cleaned up someday.
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REDIRECT-MSG
				"Redirect this message to a different mailing list." ()
  (LET* ((*REDIRECT-REFERENCE-MSG* NIL)
	 (*REDIRECTED-MSG* NIL)
	 (MSG-RECIPIENTS)
	 (STATUS (ASSURE-MSG-PARSED *MSG*))
	 (MSG-TO (GET STATUS :TO))
	 (MSG-CC (GET STATUS :CC))
	 (MSG-MESSAGE-ID (GET STATUS :MESSAGE-ID))
	 WAS-REFORMATTED-P)
    (WHEN MSG-TO (SETQ MSG-RECIPIENTS (APPEND MSG-RECIPIENTS MSG-TO)))
    (WHEN MSG-CC (SETQ MSG-RECIPIENTS (APPEND MSG-RECIPIENTS MSG-CC)))
    (LET* ((REMOVED-RECIPIENTS
	    (PROMPT-FOR-ADDRESSES "Remove addresses:" NIL (LIST MSG-RECIPIENTS)))
	   (BOGUS-REMOVALS (REPLY-HEADER-TRIM REMOVED-RECIPIENTS MSG-RECIPIENTS NIL NIL)))
      (WHEN BOGUS-REMOVALS
	(TYPEIN-LINE "~{~A~^, ~} ~:[are~;is~] not ~:*~:[~;an ~]original recipient~P."
		     (LOOP FOR B IN BOGUS-REMOVALS COLLECT (GET (LOCF B) :NAME))
		     (= 1 (LENGTH BOGUS-REMOVALS)) (LENGTH BOGUS-REMOVALS))
	(UNLESS (YES-OR-NO-P "Proceed anyway? ")
	  (ABORT-CURRENT-COMMAND)))
      (LET* ((ADDED-RECIPIENTS (PROMPT-FOR-ADDRESSES "Redirect to addresses:" NIL))
	     (BOGUS-ADDITIONS
	       (REMOVED-REDIRECT-HEADER-TRIM ADDED-RECIPIENTS MSG-RECIPIENTS NIL))
	     REMAINING-RECIPIENTS DUPLICATED-RECIPIENTS ORIGINAL-FIELDS COMMENT)
	(WHEN BOGUS-ADDITIONS
	  (TYPEIN-LINE
	    "~{~A~^, ~} ~:[are~;is~] already ~:*~:[~;a ~] recipient~P."
	    (LOOP FOR B IN BOGUS-ADDITIONS COLLECT (GET (LOCF B) :NAME))
	    (= 1 (LENGTH BOGUS-ADDITIONS)) (LENGTH BOGUS-ADDITIONS))
	  (UNLESS (YES-OR-NO-P "Proceed anyway? ")
	    (ABORT-CURRENT-COMMAND)))
	;;this modularity needs improvement re templates used
	(SETQ DUPLICATED-RECIPIENTS
	      (REMOVED-REDIRECT-HEADER-TRIM ADDED-RECIPIENTS REMOVED-RECIPIENTS NIL))
	(WHEN DUPLICATED-RECIPIENTS
	  (TYPEIN-LINE
	    "~{~A~^, ~} ~:[are~;is~] being both removed and deleted."
	    (LOOP FOR B IN DUPLICATED-RECIPIENTS COLLECT (GET (LOCF B) :NAME))
	    (= 1 (LENGTH DUPLICATED-RECIPIENTS)))
	  (UNLESS (YES-OR-NO-P "Proceed anyway? ")
	    (ABORT-CURRENT-COMMAND)))
	(SETQ REMOVED-RECIPIENTS
	      (REMOVED-REDIRECT-HEADER-TRIM
		(REPLY-HEADER-TRIM REMOVED-RECIPIENTS DUPLICATED-RECIPIENTS NIL NIL)
		MSG-RECIPIENTS NIL))
	(SETQ ADDED-RECIPIENTS
	      (REPLY-HEADER-TRIM
		(REPLY-HEADER-TRIM ADDED-RECIPIENTS DUPLICATED-RECIPIENTS NIL NIL)
		MSG-RECIPIENTS NIL NIL))
	(UNLESS (OR REMOVED-RECIPIENTS ADDED-RECIPIENTS)
	  (BARF "No changes were specified."))
	(SETQ REMAINING-RECIPIENTS
	      (APPEND (REPLY-HEADER-TRIM MSG-RECIPIENTS REMOVED-RECIPIENTS NIL NIL)
		      ADDED-RECIPIENTS))
	(UNLESS REMAINING-RECIPIENTS (BARF "No addressees left for redirected message."))
	;; this can be made a user option later
	(SETQ COMMENT (PROMPT-FOR-MULTI-LINE-HEADER "Comment for redirected message"))
	(COMPOSE-FROM-TEMPLATE 'REDIRECT-REDISTRIBUTE-TEMPLATE :MSGS (LIST *MSG*)
			       :REMOVED-RECIPIENTS REMOVED-RECIPIENTS
			       :ADDED-RECIPIENTS ADDED-RECIPIENTS
			       :REDIRECT-COMMENT COMMENT
			       :REDIRECT-DESIGNATION (LOCF *REDIRECTED-MSG*))
	(WHEN REMOVED-RECIPIENTS
	  (COMPOSE-FROM-TEMPLATE 'REDIRECT-REFERENCE-TEMPLATE :MSGS (LIST *MSG*)
				 :REMOVED-RECIPIENTS REMOVED-RECIPIENTS
				 :ADDED-RECIPIENTS ADDED-RECIPIENTS
				 :REDIRECT-COMMENT COMMENT
				 :REDIRECT-DESIGNATION (LOCF *REDIRECT-REFERENCE-MSG*)))
	;; alter the original headers; we have to reparse, and restore reformatting after
	(WITH-MSG-REDISPLAY-DELAYED
	  (WHEN (AND (MSG-GET *MSG* 'REFORMATTED)
		     (MSG-GET *MSG* 'ORIGINAL-HEADERS-INTERVAL))
	    (UNREFORMAT-HEADERS *MSG*)
	    (SETQ WAS-REFORMATTED-P T))
	  (WHEN MSG-TO (SETQ ORIGINAL-FIELDS (NCONC ORIGINAL-FIELDS (LIST :TO MSG-TO))))
	  (WHEN MSG-CC (SETQ ORIGINAL-FIELDS (NCONC ORIGINAL-FIELDS (LIST :CC MSG-CC))))
	  (WHEN MSG-MESSAGE-ID
	    (SETQ ORIGINAL-FIELDS (NCONC ORIGINAL-FIELDS (LIST :MESSAGE-ID MSG-MESSAGE-ID))))
	  (PUTPROP STATUS ORIGINAL-FIELDS 'REDIRECTED)
	  (PUTPROP STATUS			;there had better be a resulting To:
		   (APPEND
		     (REPLY-HEADER-TRIM MSG-TO REMOVED-RECIPIENTS NIL NIL) ADDED-RECIPIENTS)
		   :TO)
	  (IF (SETQ MSG-CC (REPLY-HEADER-TRIM MSG-CC REMOVED-RECIPIENTS NIL NIL))
	      (PUTPROP STATUS MSG-CC :CC)
	      (SI:NREMPROP STATUS :CC))
	  (PUTPROP STATUS (SEND *REDIRECTED-MSG* :TRANSMITTED-MESSAGE-ID) :MESSAGE-ID)
	  (SET-REDIRECTED-HEADERS-PARSE *MSG* '(:TO :CC :MESSAGE-ID))
	  (RESET-HEADER-INTERVAL *MSG*)
	  (ADD-REDIRECTED-TEXT-TO-INTERVAL *MSG* (SEND *REDIRECTED-MSG* :REDIRECTED-TEXT))
	  (WHEN WAS-REFORMATTED-P (REFORMAT-HEADERS *MSG* T)))
	(LET ((CHOICE (FQUERY '(:TYPE :TYI :NO-INPUT-SAVE T
				:CHOICES (((:LEFT "Yes") #/Y #/T #\SPACE)
					  ((NIL "No") #/N #\RUBOUT)
					  ((:RIGHT "Options menu for Reply") #/O)))
			      "Reply to the redirected message, as well? ")))
	  (WHEN CHOICE
	    (SETQ *ZMAIL-COMMAND-BUTTON* CHOICE)
	    (NORMAL-REPLY-INTERNAL (LIST *MSG*))))
	DIS-TEXT))))

(DEFUN ADD-REDIRECTED-TEXT-TO-INTERVAL (MSG STRING)
  (LET* ((NEW-TEXT-INTERVAL (LET ((INT (CREATE-INTERVAL)))
			      (INSERT (INTERVAL-FIRST-BP INT) STRING)
			      INT))
	 (MSG-INTERVAL (MSG-INTERVAL MSG))
	 (HEADERS-END-BP (MSG-GET MSG 'HEADERS-END-BP))
	 (OLD-FIRST-TEXT-LINE (BP-LINE HEADERS-END-BP))
	 (START-PREVIOUS-LINE (LINE-PREVIOUS OLD-FIRST-TEXT-LINE))
	 (FIRST-NEW-LINE (BP-LINE (INTERVAL-FIRST-BP NEW-TEXT-INTERVAL)))
	 (LAST-NEW-LINE (BP-LINE (INTERVAL-LAST-BP NEW-TEXT-INTERVAL))))
    (WITHOUT-INTERRUPTS
      (SETF (LINE-PREVIOUS FIRST-NEW-LINE) START-PREVIOUS-LINE)
      (SETF (LINE-NEXT START-PREVIOUS-LINE) FIRST-NEW-LINE)
      (MOVE-BP HEADERS-END-BP FIRST-NEW-LINE 0)
      (SETF (LINE-NEXT LAST-NEW-LINE) OLD-FIRST-TEXT-LINE)
      (SETF (LINE-PREVIOUS OLD-FIRST-TEXT-LINE) LAST-NEW-LINE)
      ;; Put new text in text interval
      (LOOP FOR LINE FIRST FIRST-NEW-LINE THEN (LINE-NEXT LINE)
	    UNTIL (EQ LINE OLD-FIRST-TEXT-LINE)
	    DO (SETF (LINE-NODE LINE) MSG-INTERVAL)))
    (SETF (MSG-TICK MSG) (TICK))))

(DEFUN SET-REDIRECTED-HEADERS-PARSE (MSG TYPES)
  (LOOP WITH STAT = (LOCF (MSG-STATUS MSG))
	WITH LAST-LINE = (BP-LINE (GET STAT 'HEADERS-END-BP))
	FOR TYPE IN TYPES
	AS NEW-PARSE = (GET STAT TYPE)
	AS NEW-FIELD = (WHEN NEW-PARSE (LIST TYPE NEW-PARSE))
	DO (LOOP WITH MSG-INTERVAL = (MSG-INTERVAL MSG)
		 FOR LINE FIRST (BP-LINE (INTERVAL-FIRST-BP MSG-INTERVAL))
			  THEN (LINE-NEXT LINE)
		 AS LINE-HEADERS = (GET (LOCF (LINE-CONTENTS-PLIST LINE)) 'PARSED-HEADERS)
		 WHEN (EQ (CAR LINE-HEADERS) TYPE)
		   DO (IF NEW-FIELD
			  (PUTPROP (LOCF (LINE-CONTENTS-PLIST LINE)) NEW-FIELD
				   'PARSED-HEADERS)
			(SI:NREMPROP (LOCF (LINE-CONTENTS-PLIST LINE)) 'PARSED-HEADERS))
		 UNTIL (EQ LINE LAST-LINE))))

;;; create a new headers interval out of the parsed headers, and replace
;;; the existing headers interval with it.  If the message had been
;;; reformatted, then reformat the result.
(DEFUN RESET-HEADER-INTERVAL (MSG)
  (LET* ((NEW-HEADERS-INTERVAL
	   (MULTIPLE-VALUE-BIND (INTERVAL FIRST-LINE-ITS-P)
	       (COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG
						  'LITERAL-WITH-ADDRESSES-REFORMAT-TEMPLATE)
	     (WHEN FIRST-LINE-ITS-P
	       (LET ((LAST-BP (INTERVAL-LAST-BP INTERVAL)))
		 (WHEN (ZEROP (BP-INDEX LAST-BP))
		   (DBP LAST-BP))))
	     INTERVAL))
	 (MSG-INTERVAL (MSG-INTERVAL MSG))
	 (HEADERS-END-BP (MSG-GET MSG 'HEADERS-END-BP))
	 (MSG-START-BP (INTERVAL-FIRST-BP MSG-INTERVAL))
	 (OLD-FIRST-LINE (BP-LINE MSG-START-BP))
	 (START-PREVIOUS-LINE (LINE-PREVIOUS OLD-FIRST-LINE))
	 (BODY-START-LINE (BP-LINE HEADERS-END-BP))
	 (OLD-LAST-LINE (LINE-PREVIOUS BODY-START-LINE))
	 (FIRST-NEW-LINE (BP-LINE (INTERVAL-FIRST-BP NEW-HEADERS-INTERVAL)))
	 (LAST-NEW-LINE (BP-LINE (INTERVAL-LAST-BP NEW-HEADERS-INTERVAL))))
    ;; Atomically replace the original headers with these new ones.
    (WITHOUT-INTERRUPTS
      (SETF (LINE-PREVIOUS FIRST-NEW-LINE) START-PREVIOUS-LINE)
      (IF START-PREVIOUS-LINE
	  (SETF (LINE-NEXT START-PREVIOUS-LINE) FIRST-NEW-LINE)
	(MOVE-BP (MSG-REAL-START-BP MSG) FIRST-NEW-LINE 0))
      (MOVE-BP MSG-START-BP FIRST-NEW-LINE 0)
      (SETF (LINE-NEXT LAST-NEW-LINE) BODY-START-LINE)
      (SETF (LINE-PREVIOUS BODY-START-LINE) LAST-NEW-LINE)
      ;; Put new headers in text interval
      (LOOP FOR LINE FIRST FIRST-NEW-LINE THEN (LINE-NEXT LINE)
	    UNTIL (EQ LINE BODY-START-LINE)
	    DO (SETF (LINE-NODE LINE) MSG-INTERVAL))
      ;;Map old headers to a new interval and discard it
      (LET ((NEW-INTERVAL-FOR-OLD NIL))
	(SETQ NEW-INTERVAL-FOR-OLD (CREATE-INTERVAL
				     (CREATE-BP OLD-FIRST-LINE 0 :NORMAL
						NEW-HEADERS-INTERVAL)
				     (CREATE-BP OLD-LAST-LINE 0 :MOVES
						NEW-HEADERS-INTERVAL)))
	(LOOP FOR LINE = OLD-FIRST-LINE THEN (LINE-NEXT LINE)
	      DO (SETF (LINE-NODE LINE) NEW-INTERVAL-FOR-OLD)
	      UNTIL (EQ LINE OLD-LAST-LINE)))
      ;; now strip out old parse and reparse the msg, so everything is consistent
      (SETF (MSG-STATUS *MSG*) (SOME-PLIST (MSG-STATUS *MSG*) *INTERNAL-TYPE-PROPERTIES*)))
    (SET-PARSED-MSG-HEADERS *MSG*))
  (SETF (MSG-TICK MSG) (TICK))
  (REFORMAT-FAKE-OUT-REDISPLAY MSG))

(DEFUN ADDRESS-HEADER-STRING (HEADERS)
  (FORMAT NIL "~{~A~^, ~}"
	  (LOOP FOR HEADER IN HEADERS
		NCONC (LOOP FOR ADR IN HEADER
			    COLLECT (STRING-FROM-HEADER ADR :SHORT)))))

(DEFUN REDIRECT-COMPOSITION-FUNCTION (EXPANSION)
  (LET ((HEADERS (GET (LOCF EXPANSION) :HEADERS))
	(TEXT (GET (LOCF EXPANSION) :TEXT))
	(TRANSMIT-TEMPLATES (GET (LOCF EXPANSION) :TRANSMIT-TEMPLATES))
	(REDIRECT-DESIGNATION (GET (LOCF EXPANSION) :REDIRECT-DESIGNATION))
	(REDIRECTED-TEXT (GET (LOCF EXPANSION) :REDIRECTED-TEXT)))
    (DOLIST (MSG (GET (LOCF EXPANSION) :MSGS))	;yecch; there better be only one msg
      (SETF (CAR REDIRECT-DESIGNATION)
	    (MAKE-DRAFT-AND-TRANSMIT 'REDIRECT-DRAFT-MSG :MSG MSG :TEXT TEXT
				     :HEADERS HEADERS :TRANSMIT-TEMPLATES TRANSMIT-TEMPLATES
				     :REDIRECTED-TEXT REDIRECTED-TEXT))))
  (COMPUTE-CURRENT-MSG-STATE))

;;; A redirected message
(DEFFLAVOR REDIRECT-DRAFT-MSG
	(MSG TRANSMIT-TEMPLATES TEXT TRANSMITTED-MESSAGE-ID REDIRECTED-TEXT)
	(DUMMY-DRAFT-MSG)
  (:INITABLE-INSTANCE-VARIABLES MSG TRANSMIT-TEMPLATES TEXT)
  (:GETTABLE-INSTANCE-VARIABLES MSG TRANSMITTED-MESSAGE-ID REDIRECTED-TEXT)
  (:SETTABLE-INSTANCE-VARIABLES TRANSMITTED-MESSAGE-ID REDIRECTED-TEXT))

(DEFMETHOD (:INIT REDIRECT-DRAFT-MSG :AFTER) (IGNORE)
  (SETQ TRANSMITTED-MESSAGE-ID NIL))

(DEFMETHOD (:TRANSMIT REDIRECT-DRAFT-MSG :AFTER) ()
  (MSG-PUT MSG T 'REDIRECTED))

(DEFMETHOD (:SUMMARY-STRING REDIRECT-DRAFT-MSG) ()
  (IF (EQ (MSG-PARSED-P MSG) :KILLED)
      (FORMAT NIL "Redirection of [expunged message]")
    (FORMAT NIL "Redirection of ~A to ~A"
	    (MSG-DESCRIPTION MSG)
	    (SUMMARIZE-RECIPIENTS (LOOP FOR (TYPE HEADER) ON HEADERS BY 'CDDR
					WHEN (HEADER-TYPE-TYPEP TYPE ':RECIPIENT)
					  APPEND HEADER)
				  30.))))

(DEFINE-SECTION-NAME |Draft Editor Commands|)

(DEFCOM-FOR-ZMAIL COM-ADD-TO-FIELD "Add another to recipient.
With a negative argument, removes the to field
With a zero argument, only selects the start of that field." ()
  (ADD-RECIPIENT-FIELD ':TO)
  DIS-TEXT)

(DEFCOM-FOR-ZMAIL COM-ADD-CC-FIELD "Add another cc recipient.
With a negative argument, removes the cc field
With a zero argument, only selects the start of that field." ()
  (ADD-RECIPIENT-FIELD ':CC)
  DIS-TEXT)

(DEFCOM-FOR-ZMAIL COM-ADD-BCC-FIELD "Add another Bcc recipient.
With a negative argument, removes the Bcc field
With a zero argument, only selects the start of that field." ()
  (ADD-RECIPIENT-FIELD ':BCC)
  DIS-TEXT)

(DEFUN ADD-RECIPIENT-FIELD (TYPE &AUX BP BP2)
  (MULTIPLE-VALUE (BP BP2)
    (ADD-HEADER-FIELD TYPE (MINUSP *NUMERIC-ARG*) (MINUSP *NUMERIC-ARG*) T))
  (AND BP2 (PLUSP *NUMERIC-ARG*) (NOT (END-LINE-P BP))
       (LET ((BP3 (END-LINE BP2 -1)))
	 (IF (< (BP-INDENTATION BP3) *FILL-COLUMN*)
	     (SETQ BP2 (INSERT BP3 ", "))
	     (INSERT BP3 #/,)
	     (COND ((NOT (LINE-BLANK-P (BP-LINE BP2)))
		    (INSERT BP2 #\CR)
		    (SETQ BP2 (BEG-LINE BP2 -1))))
	     (INSERT-MOVING BP2 "    "))
	 (MOVE-BP (POINT) BP2))))

(DEFVAR *SUBJECT-PRONOUN-FROM-LIST*)
(DEFVAR *SUBJECT-PRONOUN-TO-LIST*)
(DEFUN INITIALIZE-SUBJECT-PRONOUN-LISTS (&AUX L1 L2)
  (DOLIST (ELEM '(("I" "you") ("me" "you") ("my" "your")
		  ("mine" "yours") ("here" "there")
		  ("am" "are") ("I'm" "you're")))
    (PUSH (CAR ELEM) L1)
    (PUSH (CADR ELEM) L2)
    (PUSH (CADR ELEM) L1)
    (PUSH (CAR ELEM) L2))
  (SETQ *SUBJECT-PRONOUN-FROM-LIST* (NREVERSE L1)
	*SUBJECT-PRONOUN-TO-LIST* (NREVERSE L2)))

(INITIALIZE-SUBJECT-PRONOUN-LISTS)

(DEFCOM-FOR-ZMAIL COM-CHANGE-SUBJECT-PRONOUNS "Fix up the subject field" ()
  (ADD-HEADER-FIELD :SUBJECT NIL NIL T)
  (LET ((*INTERVAL* (CREATE-INTERVAL (COPY-BP (POINT) :NORMAL)
				     (COPY-BP (BEG-LINE (POINT) 1 T) :MOVES)))
	(OLD-*CASE-REPLACE-P* *CASE-REPLACE-P*))
    1;; Yuck -- You can't bind 2symbol-macro1s even with 2letf1!
0    (UNWIND-PROTECT
	(PROGN
	  (SETF *CASE-REPLACE-P* NIL)
	  (QUERY-REPLACE-LIST (POINT) *SUBJECT-PRONOUN-FROM-LIST* *SUBJECT-PRONOUN-TO-LIST* T))
      (SETF *CASE-REPLACE-P* OLD-*CASE-REPLACE-P*))
    (TYPEIN-LINE "Change Subject Pronouns done."))
  DIS-TEXT)

(DEFCOM-FOR-ZMAIL COM-ADD-SUBJECT-FIELD "Add a Subject field.
With a negative argument, removes the Subject field
With a zero argument, only selects the start of that field." ()
  (ADD-HEADER-FIELD ':SUBJECT (NOT (ZEROP *NUMERIC-ARG*)) (MINUSP *NUMERIC-ARG*) T)
  DIS-TEXT)

(DEFCOM-FOR-ZMAIL COM-ADD-FROM-FIELD "Add a From field.
With a negative argument, removes the From field.
With a zero argument, only selects the start of that field." ()
  (ADD-HEADER-FIELD ':FROM (NOT (ZEROP *NUMERIC-ARG*)) (MINUSP *NUMERIC-ARG*) T)
  DIS-TEXT)

(DEFCOM-FOR-ZMAIL COM-ADD-REPLY-TO-FIELD "Add a Reply-to field.
With a negative argument, removes the Reply-to field.
With a zero argument, only selects the start of that field." ()
  (ADD-HEADER-FIELD ':REPLY-TO (NOT (ZEROP *NUMERIC-ARG*)) (MINUSP *NUMERIC-ARG*) T)
  DIS-TEXT)

(DEFUN ADD-HEADER-FIELD (TYPE DELETE-P DELETE-HEADER-TOO-P MOVE-POINT-P
			 &AUX NAME FIRST-BP LAST-BP STOP-AT-BLANK BP BP2)
  (SETQ NAME (HEADER-TYPE-NAME TYPE))
  (AND MOVE-POINT-P (POINT-PDL-PUSH (POINT) *WINDOW*))
  (MULTIPLE-VALUE (FIRST-BP LAST-BP STOP-AT-BLANK)
    (MOVE-TO-HEADER-WINDOW MOVE-POINT-P))
  (OR (BEG-LINE-P LAST-BP) (INSERT LAST-BP #\CR))
  (DO ((LINE (BP-LINE FIRST-BP) (LINE-NEXT LINE))
       (LAST-LINE (BP-LINE LAST-BP))
       (LEN (STRING-LENGTH NAME)))
      (NIL)
    (AND STOP-AT-BLANK
	 (LINE-BLANK-P LINE)
	 (RETURN (SETQ LAST-BP (CREATE-BP LINE 0))))
    (AND (> (LINE-LENGTH LINE) LEN)
	 (STRING-EQUAL LINE NAME 0 0 LEN LEN)
	 (CHAR-EQUAL (AREF LINE LEN) #/:)
	 (RETURN (SETQ BP (CREATE-BP LINE (1+ LEN)))))
    (AND (EQ LINE LAST-LINE)
	 (RETURN NIL)))
  (COND ((NULL BP)
	 (SETQ BP (COPY-BP LAST-BP))
	 (COND ((NOT DELETE-HEADER-TOO-P)
		(INSERT-MOVING BP NAME)
		(INSERT-MOVING BP ": ")
		(INSERT BP #\CR))))
	(T
	 (IF DELETE-HEADER-TOO-P
	     (SETQ BP (BEG-LINE BP))
	     (SETQ BP (FORWARD-OVER *BLANKS* BP)))
	 (SETQ BP2 (CREATE-BP (DO ((LINE (LINE-NEXT (BP-LINE BP)) (LINE-NEXT LINE))
				   (LAST-LINE (BP-LINE LAST-BP)))
				  ((EQ LINE LAST-LINE) LINE)
				(OR (AND (NOT (ZEROP (LINE-LENGTH LINE)))
					 (MEMQ (AREF LINE 0) *BLANKS*))
				    (RETURN LINE)))
			      0))
	 
	 (COND (DELETE-P
		(AND 
		  (NOT DELETE-HEADER-TOO-P)
		  (SETQ BP2 (END-LINE BP2 -1)))
		(WITH-BP (SAVE-BP BP ':NORMAL)
		  (KILL-INTERVAL BP BP2 T)
		  (MOVE-BP BP SAVE-BP)
		  (SETQ *CURRENT-COMMAND-TYPE* 'KILL))))))
  (AND MOVE-POINT-P (MOVE-BP (POINT) BP))
  (VALUES BP BP2))

(DEFUN MOVE-TO-HEADER-WINDOW (&OPTIONAL (MOVE-P T))
  (DECLARE (VALUES FIRST-BP LAST-BP STOP-AT-BLANK))
  (COND (*INSIDE-MAIL*
	 (IF MOVE-P
	     (SEND *ZMAIL-WINDOW* :SET-MAIL-WINDOW-CONFIGURATION NIL :HEADERS)
	   (RESEPARATE-HEADER-AND-TEXT))
	 (VALUES (INTERVAL-FIRST-BP *HEADER-INTERVAL*) (INTERVAL-LAST-BP *HEADER-INTERVAL*)))
	(T
	 (LET* ((FIRST-BP (INTERVAL-FIRST-BP *INTERVAL*))
		(SECOND-BP (SEARCH FIRST-BP "--Text follows this line--")))
	   (IF SECOND-BP
	       (VALUES FIRST-BP (BEG-LINE SECOND-BP))
	     (VALUES FIRST-BP
		     (INTERVAL-LAST-BP *INTERVAL*)
		     T))))))

(DEFMETHOD (:SET-MAIL-WINDOW-CONFIGURATION ZMAIL-FRAME) (&REST ARGS)
  (APPLY #'SET-MAIL-WINDOW-CONFIGURATION ARGS))

(DEFCOM-FOR-ZMAIL COM-ADD-MORE-TEXT "Reselect the text portion of the message" ()
  (COND (*INSIDE-MAIL*
	 (SET-MAIL-WINDOW-CONFIGURATION NIL ':REPLY)
	 DIS-NONE)
	(T
	 (MOVE-BP (POINT) (INTERVAL-LAST-BP *INTERVAL*))
	 DIS-BPS)))

(DEFVAR *PRUNE-YANKED-HEADERS-KEEP-HEADERS* '(:DATE :FROM :ITS))

(DEFCOM-FOR-ZMAIL COM-PRUNE-YANKED-HEADERS "Shorten up the headers on a yanked message" ()
  (LET ((NEW-POINT (PRUNE-YANKED-HEADERS *REPLY-INTERVAL*)))
    (WHEN NEW-POINT
      (SET-MAIL-WINDOW-CONFIGURATION NIL ':REPLY)	; make sure we are in text window
      (MOVE-BP (POINT) NEW-POINT)))
  DIS-TEXT)

(DEFUN PRUNE-YANKED-HEADERS (FIRST-BP &OPTIONAL LAST-BP IN-ORDER-P)
  (GET-INTERVAL FIRST-BP LAST-BP IN-ORDER-P)
  (BLOCK TOP
    (LET ((BP (COPY-BP FIRST-BP)))
      (DO ((LINE (BP-LINE BP) (LINE-NEXT LINE))
	   (LAST-LINE (BP-LINE LAST-BP))
	   (STATE NIL) (CONTINUATION-TYPE NIL)
	   (TYPE))
	  (NIL)
	(SETQ TYPE (HEADER-LINE-TYPE LINE))
	(COND (CONTINUATION-TYPE
	       (AND (MEMQ TYPE '(:UNKNOWN :ITS)) ;Check for ITS not really strong enough
		    (SETQ TYPE CONTINUATION-TYPE))
	       (SETQ CONTINUATION-TYPE NIL)))
	;; Recognize the most common kinds of continuation line
	(AND (OR (HEADER-TYPE-TYPEP TYPE ':ADDRESS)
		 (HEADER-TYPE-TYPEP TYPE ':REFERENCE))
	     (LET ((LAST-IDX (STRING-REVERSE-SEARCH-NOT-SET '(#\SP #\TAB) LINE)))
	       (AND LAST-IDX (CHAR-EQUAL (AREF LINE LAST-IDX) #/,)))
	     (SETQ CONTINUATION-TYPE TYPE))
	(COND ((EQ TYPE ':UNKNOWN)		;End of headers
	       (COND (STATE
		      (KILL-INTERVAL BP (CREATE-BP LINE 0) T)	;Things to be flushed
		      (SETQ *LAST-COMMAND-TYPE* 'KILL	;Append any more kills
			    *CURRENT-COMMAND-TYPE* 'KILL)))
	       (RETURN-FROM TOP (CREATE-BP LINE 0)))
	      ((MEMQ TYPE *PRUNE-YANKED-HEADERS-KEEP-HEADERS*)
	       (COND (STATE			;Things to be flushed
		      (DELETE-INTERVAL BP (CREATE-BP LINE 0) T)
		      (SETQ STATE NIL))))		;No more
	      (T
	       (COND ((NOT STATE)				;Start flushing here
		      (MOVE-BP BP LINE 0)
		      (SETQ STATE T)))))
	(AND (EQ LINE LAST-LINE) (RETURN-FROM TOP NIL))))))

(DEFUN HEADER-LINE-TYPE (LINE &AUX LEXEMES)
  (IF (NLISTP (SETQ LEXEMES (CONDITION-CASE (ERROR)
				(RFC733-LEXER LINE 0 NIL)
			      (PARSE-ERROR ERROR))))
      ':UNKNOWN
      (SELECTQ (CAAR LEXEMES)
	(EOF ':BLANK)
	(ATOM
	 (SELECTQ (CAADR LEXEMES)
	   ((ATSIGN AT-ATOM)
	    (IF (EQ (CAADDR LEXEMES) 'ATOM)
		':ITS ':UNKNOWN))
	   (COLON
	    (OR (HEADER-NAME-TYPE (CADAR LEXEMES) 0 NIL NIL) ':UNKNOWN))
	   (OTHERWISE
	    ':UNKNOWN)))
	(OTHERWISE
	 ':UNKNOWN))))

(DEFMACRO PRESERVE-MAIL-WINDOW-POINTS (&BODY BODY)
  `(MACROLET ((PRESERVE-WINDOW-POINT ((WINDOW) &BODY BODY)
		`(LET* ((SAVED-POINT (COPY-BP (WINDOW-POINT ,WINDOW) :NORMAL))
			(SAVED-LINE (BP-LINE SAVED-POINT))
			(SAVED-N-LINES
			  (1- (COUNT-LINES (INTERVAL-FIRST-BP (WINDOW-INTERVAL ,WINDOW))
					   SAVED-POINT T)))
			(SAVED-INDEX (BP-INDEX SAVED-POINT)))
		   (PROGN ,@BODY)
		   (RESTORE-WINDOW-POINT ,WINDOW SAVED-POINT SAVED-LINE
					 SAVED-N-LINES SAVED-INDEX))))
     (LABELS ((RESTORE-WINDOW-POINT (WINDOW SAVED-POINT SAVED-LINE SAVED-N-LINES SAVED-INDEX)
		(UNLESS (BP-= SAVED-POINT (WINDOW-POINT WINDOW))
		  (MOVE-BP (WINDOW-POINT WINDOW)
		    (LET ((*INTERVAL* (WINDOW-INTERVAL WINDOW)))
		      (FORWARD-CHAR
			(LOOP WITH START-LINE = (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))
			      WITH END-LINE = (BP-LINE (INTERVAL-LAST-BP *INTERVAL*))
			      FOR LINE = START-LINE THEN (LINE-NEXT LINE)
			      WHEN (EQ LINE SAVED-LINE)
				RETURN (CREATE-BP LINE 0)
			      UNTIL (EQ LINE END-LINE)
			      FINALLY
				(RETURN
				  (FORWARD-LINE (CREATE-BP START-LINE 0) SAVED-N-LINES T)))
			SAVED-INDEX T)))))
	      (EXECUTE-BODY ()
		(MULTIPLE-VALUE-BIND (REDISPLAY-DEGREE)
		    (PROGN ,@BODY)
		  (MUST-REDISPLAY *WINDOW* REDISPLAY-DEGREE))))
       (IF *INSIDE-MAIL*
	   (IF (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
	       (PRESERVE-WINDOW-POINT (*MSG-WINDOW*)
		 (EXECUTE-BODY))
	     (LET ((SAVED-WINDOW *WINDOW*))
	       (PRESERVE-WINDOW-POINT (*REPLY-WINDOW*)
		 (PRESERVE-WINDOW-POINT (*HEADER-WINDOW*)
		   (EXECUTE-BODY)))
	       (UNLESS (EQ SAVED-WINDOW *WINDOW*)
		 (SEND *ZMAIL-WINDOW* :SET-MAIL-WINDOW-CONFIGURATION NIL SAVED-WINDOW))))
	 (PRESERVE-WINDOW-POINT (*WINDOW*)
	   (EXECUTE-BODY)))
       DIS-NONE)))

(DEFCOM-FOR-ZMAIL COM-ADD-FCC-FIELD "Add another file recipient" ()
  (COM-ADD-FCC-FIELD-INTERNAL ':FCC))

(DEFCOM-FOR-ZMAIL COM-ADD-BFCC-FIELD "Add another blind file recipient" ()
  (COM-ADD-FCC-FIELD-INTERNAL ':BFCC))

(DEFUN COM-ADD-FCC-FIELD-INTERNAL (TYPE)
  (IF *NUMERIC-ARG-P*
      (PROGN
	(ADD-RECIPIENT-FIELD TYPE)
	DIS-TEXT)
    (LET ((BUFFER (GET-MOVE-BUFFER NIL NIL T)))
      (IF BUFFER
	  (PRESERVE-MAIL-WINDOW-POINTS
	    (ADD-RECIPIENT-FIELD TYPE)
	    (INSERT-MOVING (POINT) (SEND BUFFER :NAME))
	    DIS-TEXT)
	(ABORT-CURRENT-COMMAND)))))

(DEFCOM-FOR-ZMAIL COM-ADD-IN-REPLY-TO-FIELD "Add an in-reply-to field" ()
  (LET ((IN-REPLY-TO (GENERATE-IN-REPLY-TO-HEADER)))
    (IF IN-REPLY-TO
	(PRESERVE-MAIL-WINDOW-POINTS
	  (ADD-HEADER-TYPE-FIELD IN-REPLY-TO :IN-REPLY-TO)
	  DIS-TEXT)
      (BARF "This draft is not a reply."))))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-ADD-REFERENCES-FIELD
  "Add references to all messages in the current sequence to this draft.")

(DEFCOM-FOR-ZMAIL COM-ADD-REFERENCES-FIELD
  "Add a References field
Adds a reference to each message in the current sequence to the References
field of this draft.  Creates the References field if not already present."
		  ()
  (LET ((ZWEI:*ZMAIL-COMMAND-BUTTON* :FORCE))	;Force the question even if invoked by m-X.
    (CHECK-FOR-TOO-MANY-MSGS "add references to" *SEQUENCE*
			     " in the current sequence to this draft"))
  (LET* ((OLD-REFERENCES (GET-DRAFT-REFERENCES))
	 (NEW-REFERENCES (CL:SET-DIFFERENCE (REFERENCES-FOR-SEQUENCE *SEQUENCE*)
					    OLD-REFERENCES
					    :TEST #'REFERENCE-EQUAL)))
    (UNLESS NEW-REFERENCES
      (BARF "No additional references in this sequence."))
    (PRESERVE-MAIL-WINDOW-POINTS
      (ADD-HEADER-TYPE-FIELD (APPEND OLD-REFERENCES NEW-REFERENCES)
			     :REFERENCES)
      DIS-TEXT)))

(DEFUN GET-DRAFT-REFERENCES ()
  (MULTIPLE-VALUE-BIND (START-BP END-BP STOP-AT-BLANK-LINE)
      (MOVE-TO-HEADER-WINDOW NIL)
    (LET ((HEADERS (PARSE-HEADERS-INTERVAL START-BP END-BP T
					   STOP-AT-BLANK-LINE '(:REFERENCES))))
      (CL:GETF HEADERS :REFERENCES))))

(DEFUN GENERATE-IN-REPLY-TO-HEADER ()
  (GENERATE-REFERENCE-HEADER (SEND *DRAFT-MSG* ':MSGS-BEING-REPLIED-TO)))

(DEFUN GENERATE-REFERENCE-HEADER (MSGS)
  (NREVERSE
    (SI:ELIMINATE-DUPLICATES			;keep the later of duplicated references
      (NREVERSE
	(LOOP FOR MSG IN MSGS
	      AS STATUS = (ASSURE-MSG-PARSED MSG)
	      COLLECT (GENERATE-REFERENCE-HEADER-FROM-HEADERS (CDR STATUS))
	      APPEND (GET STATUS ':INCLUDED-MSGS)))
      #'EQUAL)))

(DEFUN GENERATE-REFERENCE-HEADER-FROM-HEADERS (HEADERS &AUX TEM)
  (IF (SETQ TEM (GET (LOCF HEADERS) ':MESSAGE-ID))
      `(:MESSAGE-ID ,TEM)
      `(:DATE ,(LET ((DATE (GET (LOCF HEADERS) ':DATE)))
		 (AND (LISTP DATE) (SETQ DATE (FIRST DATE)))
		 (AND (FIXP DATE) DATE))
	:FROM ,(CAR (GET (LOCF HEADERS) ':FROM)))))

(DEFUN ADD-HEADER-TYPE-FIELD (VAL TYPE)
  (ADD-HEADER-FIELD TYPE T T T)
  (INSERT-MOVING (POINT)
		 (WITH-OUTPUT-TO-STRING (STREAM)
		   (PRINT-HEADER STREAM VAL TYPE NIL))))

(DEFUN REFERENCES-FOR-SEQUENCE (SEQUENCE)
  (GENERATE-REFERENCE-HEADER (LIST-SEQUENCE SEQUENCE)))

(DEFCOM-FOR-ZMAIL COM-ADD-START-DATE-FIELD "Add a Start-date field" ()
  (ADD-DATE-FIELD ':START-DATE))

(DEFCOM-FOR-ZMAIL COM-ADD-EXPIRATION-DATE-FIELD "Add an Expiration-date field" ()
  (ADD-DATE-FIELD ':EXPIRATION-DATE))

(DEFUN ADD-DATE-FIELD (FIELD)
  (LET ((DATE (TYPEIN-LINE-ACCEPT 'TIME:UNIVERSAL-TIME
				  :PROMPT (FORMAT NIL "Add ~A" (HEADER-TYPE-NAME FIELD))
				  :PROVIDE-DEFAULT NIL)))
    (PRESERVE-MAIL-WINDOW-POINTS
      (ADD-HEADER-TYPE-FIELD DATE FIELD)
      DIS-TEXT)))

(DEFCOM-FOR-ZMAIL COM-ADD-FILE-REFERENCE-FIELD "Add a File-References field" ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Add File-Reference" (PATHNAME-DEFAULTS))))
    (WITH-STACK-LIST (FILE-REFERENCES PATHNAME)
      (ADD-FILE-REFERENCES-TO-DRAFT FILE-REFERENCES))))

(DEFUN ADD-FILE-REFERENCES-TO-DRAFT (FILE-REFERENCES)
  (LET* ((EXISTING-FILE-REFERENCES (GET-DRAFT-FILE-REFERENCES))
	 (NEW-FILE-REFERENCES (CL:SET-DIFFERENCE FILE-REFERENCES EXISTING-FILE-REFERENCES
						 :TEST #'CL:EQUALP)))
    (PRESERVE-MAIL-WINDOW-POINTS
      (DOLIST (FILE NEW-FILE-REFERENCES)
	(ADD-RECIPIENT-FIELD :FILE-REFERENCES)
	(INSERT-MOVING (POINT) (IF (CL:PATHNAMEP FILE)
				   (FULLY-QUALIFIED-PATHNAME-STRING FILE)
				 (STRING FILE))))
      DIS-TEXT)))

;;; Really part of the namespace system.
(DEFMACRO WITH-FULLY-QUALIFIED-NAMES (&BODY BODY)
  `(LET* ((NETI:*NAMESPACE* NETI:*DISTRIBUTION-NAMESPACE*)
	  (NETI:*NAMESPACE-SEARCH-LIST* (SEND NETI:*NAMESPACE* :SEARCH-RULES))
	  (NET:*LOCAL-HOST* NETI:*DISTRIBUTION-LOCAL-HOST*)
	  (SI:LOCAL-HOST NET:*LOCAL-HOST*))
     . ,BODY))

(DEFUN FULLY-QUALIFIED-PATHNAME-STRING (PATHNAME)
  (WHEN (EQ (SEND PATHNAME :SYSTEM-TYPE) :LOGICAL)
    (SETQ PATHNAME (SEND PATHNAME :TRANSLATED-PATHNAME)))
  (WITHOUT-INTERRUPTS
    (SEND PATHNAME :DECACHE-HOST-NAME)
    (PROG1
      (WITH-FULLY-QUALIFIED-NAMES
	(STRING PATHNAME))
      (SEND PATHNAME :DECACHE-HOST-NAME))))

(DEFCOM-FOR-ZMAIL COM-ZMAIL-OTHER-WINDOW "Move to another window" ()
  (ROTATE-TO-OTHER-WINDOW (OR (OTHER-WINDOW) (BARF)))
  DIS-NONE)

(DEFCOM-FOR-ZMAIL COM-ZMAIL-YANK-REPLIED-MSGS
  "Insert the message(s) being replied to.
An argument of 1 means don't indent; an argument of 2 means to
reverse the usual meaning of *PRUNE-HEADERS-AFTER-YANKING*;
an argument of 3 does both."
	()
  (LET ((MSGS (SEND *DRAFT-MSG* :MSGS-BEING-REPLIED-TO)))
    (IF (NULL MSGS)
	(BARF "This draft is not a reply.")
      (YANK-MSGS-INTERNAL MSGS))))

(DEFCOM-FOR-ZMAIL COM-ZMAIL-YANK-CURRENT-MSG
  "Insert the current message.
An argument of 1 means don't indent; an argument of 2 means to
reverse the usual setting of *PRUNE-HEADERS-AFTER-YANKING*;
an argument of 3 does both."
	()
  (YANK-MSGS-INTERNAL (LIST *MSG*)))

;;; Numeric arg of 1 means don't indent;
;;;  Arg of 2 means reverse pruning; 3 for both.
;;;  Yow, is this overloaded yet?
(DEFUN YANK-MSGS-INTERNAL (MSGS)
  (UNLESS (CAR MSGS) (BARF "There is no message to yank in."))
  (WHEN (AND *NUMERIC-ARG-P*
	     (OR (< *NUMERIC-ARG* 1)
		 (> *NUMERIC-ARG* 3)))
    (BARF "Numeric argument must be 1, 2 or 3."))
  (LET ((NEW-CONFIGURATION *WINDOW-CONFIGURATION*))
    (IF (AND *ONE-WINDOW-AFTER-YANK* (EQ NEW-CONFIGURATION :REPLY))
	(SETQ NEW-CONFIGURATION :SEND)
      (SETQ NEW-CONFIGURATION NIL))		;Don't unecessarily change configuration.
    (SET-MAIL-WINDOW-CONFIGURATION NEW-CONFIGURATION :REPLY))
  (LET* ((WINDOW (IF (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
		     *MSG-WINDOW* *REPLY-WINDOW*))
	 (POINT (WINDOW-POINT WINDOW))
	 (MARK (WINDOW-MARK WINDOW))
	 (INDENT-P (NOT (AND *NUMERIC-ARG-P*
			     (OR (EQL *NUMERIC-ARG* 1) (EQL *NUMERIC-ARG* 3)))))
	 (*PRUNE-HEADERS-AFTER-YANKING*
	   (IF (AND *NUMERIC-ARG-P* (OR (EQL *NUMERIC-ARG* 2) (EQL *NUMERIC-ARG* 3)))
	       (NOT *PRUNE-HEADERS-AFTER-YANKING*)
	     *PRUNE-HEADERS-AFTER-YANKING*))
	 (FILE-REFERENCES
	   (CL:REMOVE-DUPLICATES
	     (APPLY #'APPEND
		    (CL:MAP 'LIST #'(LAMBDA (MSG) (MSG-GET MSG :FILE-REFERENCES)) MSGS))
	     1;; Use 2zl:equal1 as some references might be strings instead of pathnames.
0	     :TEST #'EQUAL)))
    (WHEN FILE-REFERENCES
      (ADD-FILE-REFERENCES-TO-DRAFT FILE-REFERENCES))
    (MOVE-BP MARK POINT)
    (POINT-PDL-PUSH POINT WINDOW NIL NIL)
    (LET ((BP (WITH-CUSTOM-UNDO-SAVE (POINT POINT
				      (PROGN (IGNORE BP-POSITIONS)
					     (MAKE-INSERT-RECORD (COPY-BP POINT :NORMAL)
								 (COPY-BP POINT :MOVES))))
		(INSERT-TEXT-OF-MSGS MSGS POINT NIL
				     :INDENTED INDENT-P
				     :TEMPLATE 'REPLY-YANK-REFORMAT-TEMPLATE)2)0))
      (MOVE-BP POINT BP)
      (UPDATE-STYLE-NAME)))
  (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
  DIS-TEXT)

(DEFUN MSG-DESCRIPTION (MSG)
  (LET ((DESC (STRING-FOR-MSG-REFERENCE (FIRST (GET-MSG-REFERENCE-IDS MSG)))))
    ;; Turn "message" into "Message"
    (ASET (CHAR-UPCASE (AREF DESC 0)) DESC 0)
    DESC))

(DEFCOM-FOR-ZMAIL COM-ZMAIL-REPLY-ONE-WINDOW "Just the text of the message being sent" ()
  (SWITCH-MAIL-WINDOW-CONFIGURATION :SEND))

(DEFCOM-FOR-ZMAIL COM-ZMAIL-REPLY-ZERO-WINDOWS "All of message in message window" ()
  (SWITCH-MAIL-WINDOW-CONFIGURATION :BOTH))

(DEFCOM-FOR-ZMAIL COM-ZMAIL-REPLY-TWO-WINDOWS "Both the message and the reply" ()
  (UNLESS (OR *MSGS-BEING-REPLIED-TO-INTERVAL* *MSG*)
    (BARF "There is no message to display."))
  (SWITCH-MAIL-WINDOW-CONFIGURATION :REPLY))

(DEFUN SWITCH-MAIL-WINDOW-CONFIGURATION (NEW-CONFIGURATION)
  (FLET ((PICK-HEADER-OR-REPLY-WINDOW ()
	   (IF (BP-< (WINDOW-POINT *MSG-WINDOW*) (INTERVAL-FIRST-BP *REPLY-INTERVAL*))
	       :HEADERS
	     :REPLY)))
    (LET ((OLD-CONFIGURATION *WINDOW-CONFIGURATION*)
	  (STARTING-WINDOW
	    (COND ((EQ NEW-CONFIGURATION *WINDOW-CONFIGURATION*) *WINDOW*)
		  ((MEMQ NEW-CONFIGURATION *MSG-WINDOW-CONFIGURATIONS*)
		   (SELECT *WINDOW*
		     (*HEADER-WINDOW* :HEADERS)
		     (*REPLY-WINDOW* :REPLY)
		     (*MSG-WINDOW* :REPLY)))	1;Only if in 2:reply1 configuration.
0		  ((EQ NEW-CONFIGURATION :REPLY)
		   (SELECT *WINDOW*
		     ((*HEADER-WINDOW* *REPLY-WINDOW*) *WINDOW*)
		     (*MSG-WINDOW*
		      (PICK-HEADER-OR-REPLY-WINDOW))))
		  (T
		   (SELECTQ *WINDOW-CONFIGURATION*
		     (:REPLY
		      (IF (EQ *WINDOW* *MSG-WINDOW*) :REPLY *WINDOW*))
		     (OTHERWISE
		      (PICK-HEADER-OR-REPLY-WINDOW)))))))
      (SET-MAIL-WINDOW-CONFIGURATION NEW-CONFIGURATION STARTING-WINDOW)
      (WHEN (NEQ (NULL (MEMQ OLD-CONFIGURATION *MULTI-WINDOW-SENDING-CONFIGURATIONS*))
		 (NULL (MEMQ NEW-CONFIGURATION *MULTI-WINDOW-SENDING-CONFIGURATIONS*)))
	(EXPLAIN-HOW-TO-SEND-MAIL))
      DIS-NONE)))

(DEFCOM-FOR-ZMAIL COM-RESTORE-DRAFT-FILE
		  "Restore the saved text of the message from the given file." ()
  (READ-DEFAULT-DRAFT-PATHNAME "Restore draft" (SEND *DRAFT-MSG* ':PATHNAME))
  (SEND *DRAFT-MSG* ':SET-PATHNAME *DEFAULT-DRAFT-FILE-NAME*)
  (SEND *DRAFT-MSG* ':RESTORE-DRAFT-FILE)
  (IF (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
      (MUST-REDISPLAY *MSG-WINDOW* DIS-TEXT)
      (MUST-REDISPLAY *HEADER-WINDOW* DIS-TEXT)
      (MUST-REDISPLAY *REPLY-WINDOW* DIS-TEXT))
  (SET-MAIL-WINDOW-CONFIGURATION NIL ':REPLY)
  (MOVE-BP (POINT) (INTERVAL-LAST-BP *REPLY-INTERVAL*))
  (SETQ *STYLE* 0)
  (UPDATE-STYLE-NAME)
  DIS-NONE)

(DEFUN MAKE-DRAFT-MSG-FROM-RESTORED-DRAFT ()
  (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR :MOUSE #'READ-DEFAULT-DRAFT-PATHNAME "Restore draft")
  (LET ((DRAFT-MSG (MAKE-DRAFT-MSG)))
    (SEND DRAFT-MSG :SET-PATHNAME *DEFAULT-DRAFT-FILE-NAME*)
    (SEND DRAFT-MSG :RESTORE-DRAFT-FILE)
    DRAFT-MSG))

(DEFMETHOD (:RESTORE-DRAFT-FILE DRAFT-MSG) ()
  (WITH-OPEN-FILE (STREAM PATHNAME)
    ;; Read -*- line and flush it if it was there.
    (LET ((GENERIC-PATHNAME (SEND (SEND STREAM ':PATHNAME) ':GENERIC-PATHNAME)))
      (FS:READ-ATTRIBUTE-LIST GENERIC-PATHNAME STREAM))
    (LET ((FIRST-LINE (SEND STREAM ':LINE-IN)))
      (AND (NOT (STRING-EQUAL-START FIRST-LINE "-*-"))
	   (SEND STREAM ':SET-POINTER 0)))
    (DELETE-INTERVAL HEADER-INTERVAL)
    (DO ((INT-STREAM (OPEN-INTERVAL-STREAM HEADER-INTERVAL))
	 (LINE))
	(NIL)
      (AND (OR (NULL (SETQ LINE (FUNCALL STREAM ':LINE-IN LINE-LEADER-SIZE)))
	       (ZEROP (ARRAY-ACTIVE-LENGTH LINE)))
	   (RETURN NIL))
      (FUNCALL INT-STREAM ':LINE-OUT LINE))
    (DELETE-INTERVAL REPLY-INTERVAL)
    (STREAM-INTO-BP STREAM (INTERVAL-LAST-BP REPLY-INTERVAL))))

(DEFCOM-FOR-ZMAIL COM-SAVE-DRAFT-FILE "Save the text of the message being composed." ()
  (AND (NULL (SEND *DRAFT-MSG* ':PATHNAME))
       (READ-DEFAULT-DRAFT-PATHNAME "Save draft" NIL ':WRITE))
  (SAVE-DRAFT-FILE-INTERNAL))

(DEFCOM-FOR-ZMAIL COM-WRITE-DRAFT-FILE
		  "Save the text of the message being composed to the given file." ()
  (READ-DEFAULT-DRAFT-PATHNAME "Write draft" (SEND *DRAFT-MSG* ':PATHNAME) ':WRITE)
  (SAVE-DRAFT-FILE-INTERNAL))

(DEFUN SAVE-DRAFT-FILE-INTERNAL ()
  (WITH-OPEN-FILE (STREAM *DEFAULT-DRAFT-FILE-NAME* ':DIRECTION ':OUTPUT)
    (SEND *DRAFT-MSG* ':SAVE-WINDOW-STATE)	;Uncache fonts
    (FORMAT STREAM "-*- Mode:Text -*-~%")
    (DO ((LINE (BP-LINE (INTERVAL-FIRST-BP *HEADER-INTERVAL*)) (LINE-NEXT LINE))
	 (END-LINE (BP-LINE (INTERVAL-LAST-BP *HEADER-INTERVAL*))))
	((NULL LINE))
      (OR (ZEROP (LINE-LENGTH LINE))		;Don't write blank lines here
	  (FUNCALL STREAM ':LINE-OUT LINE))
      (AND (EQ LINE END-LINE)
	   (RETURN NIL)))
    (FUNCALL STREAM ':TYO #\CR)			;Separate by blank line
    (STREAM-OUT-INTERVAL STREAM *REPLY-INTERVAL* NIL T)
    (CLOSE STREAM)
    (TYPEIN-LINE "Written: ~A" (FUNCALL STREAM ':TRUENAME)))
  (SEND *DRAFT-MSG* ':SET-PATHNAME *DEFAULT-DRAFT-FILE-NAME*)
  DIS-NONE)

(DEFUN READ-DEFAULT-DRAFT-PATHNAME (PROMPT &OPTIONAL DEFAULT (DIRECTION ':READ))
  (SETQ *DEFAULT-DRAFT-FILE-NAME* (ACCEPT-DEFAULTED-PATHNAME
				    PROMPT
				    (OR DEFAULT
					*DEFAULT-DRAFT-FILE-NAME*
					(SEND (FS:USER-HOMEDIR) :NEW-PATHNAME
					      :NAME "DRAFT" :CANONICAL-TYPE :TEXT
					      :VERSION :NEWEST))
				    :SPECIAL-VERSION NIL :DIRECTION DIRECTION)))

(DEFMETHOD (:BP-PRESENTATION-NODE DRAFT-MSG) (BP)
  (MACROLET ((LET-IF-UNBOUND ((VARIABLE UNBOUND-VALUE) &BODY BODY)
	       `(LET-IF (NOT (VARIABLE-BOUNDP ,VARIABLE))
			((,VARIABLE ,UNBOUND-VALUE))
		  ,@BODY)))
    (LET-IF-UNBOUND (*DRAFT-MSG* SELF)
      (LET-IF-UNBOUND (*HEADER-INTERVAL* HEADER-INTERVAL)
	(LET-IF-UNBOUND (*REPLY-INTERVAL* REPLY-INTERVAL)
	  (LET-IF-UNBOUND (*WINDOW-CONFIGURATION* LAST-WINDOW-CONFIGURATION)
	    (RESEPARATE-HEADER-AND-TEXT)
	    (WHEN (EQ (BP-NODE (BEG-LINE BP)) HEADER-INTERVAL)
	      (COMPUTE-HEADER-PRESENTATION-NODES SELF HEADER-INTERVAL))
	    (BP-PRESENTATION-NODE-FOR-ZMAIL BP SELF T)))))))

(DEFVAR *DRAFT-MSG-INTERNAL-HEADERS*
  '(:DATE :DRAFT-COMPOSITION-DATE :MESSAGE-ID
    :CHARACTER-STYLES :CHARACTER-TYPE-MAPPINGS :DEFAULT-CHARACTER-STYLE :FONTS))

(DEFUN MAKE-DRAFT-MSG-FROM-MSG (MSG)
  (UNLESS (MSG-DRAFT-MSG-P MSG)
    (BARF "This is not a saved draft message."))
  (LET ((DRAFT-MSG (OR (MSG-GET MSG 'DRAFT-MSG)
		       (MAKE-DRAFT-MSG))))
    (UNLESS (= (NODE-TICK (MSG-INTERVAL MSG)) (NODE-TICK DRAFT-MSG))
      1;; We have to create a new draft message
0      (SEND DRAFT-MSG :SET-MSG MSG)
      (MSG-PUT MSG DRAFT-MSG 'DRAFT-MSG)
      (WITH-INTERVAL-STREAM (DRAFT-MSG-STREAM DRAFT-MSG)
	(FLET ((INSERT-MSG-HEADERS-AND-TEXT (TYPE START-BP &OPTIONAL END-BP IN-ORDER-P)
		 (GET-INTERVAL START-BP END-BP IN-ORDER-P)
		 (CL:ECASE TYPE
		   (:HEADER
		     (LOOP WITH END-LINE = (BP-LINE END-BP)
			   WITH TEST-BEFORE = (ZEROP (BP-INDEX END-BP))
			   FOR LINE = (BP-LINE START-BP) THEN (LINE-NEXT LINE)
			   UNTIL (AND TEST-BEFORE (EQ LINE END-LINE))
			   WHEN (MULTIPLE-VALUE-BIND (IGNORE IGNORE PROPERTIES)
				    (CL:GET-PROPERTIES
				      (CL:GETF (LINE-CONTENTS-PLIST LINE) 'PARSED-HEADERS)
				      *DRAFT-MSG-INTERNAL-HEADERS*)
				  (NULL PROPERTIES))
			     DO (CL:WRITE-LINE LINE DRAFT-MSG-STREAM)
			   UNTIL (EQ LINE END-LINE)))
		   (:BODY
		     (STREAM-COPY-UNTIL-EOF (OPEN-INTERVAL-STREAM START-BP END-BP T)
					    DRAFT-MSG-STREAM)))))
	  (MAP-OVER-MSG-INTERVALS MSG #'INSERT-MSG-HEADERS-AND-TEXT :USE-ORIGINAL-HEADER T)))
      (LET ((DEFAULT-CHARACTER-STYLE (MSG-DEFAULT-CHARACTER-STYLE MSG)))
	(WHEN DEFAULT-CHARACTER-STYLE
	  (SEND DRAFT-MSG :SET-DEFAULT-CHARACTER-STYLE DEFAULT-CHARACTER-STYLE)))
      (LET ((HEADER-INTERVAL (SEND DRAFT-MSG :HEADER-INTERVAL))
	    (REPLY-INTERVAL (SEND DRAFT-MSG :REPLY-INTERVAL)))
	1;; Separate the headers from the text by finding the first blank line
0	(LOOP WITH END-LINE = (BP-LINE (INTERVAL-LAST-BP DRAFT-MSG))
	      FOR LINE = (BP-LINE (INTERVAL-FIRST-BP DRAFT-MSG)) THEN (LINE-NEXT LINE)
	      WHEN (LINE-BLANK-P LINE)
		DO (MOVE-BP (INTERVAL-LAST-BP HEADER-INTERVAL) LINE 0)
		   (MOVE-BP (INTERVAL-FIRST-BP REPLY-INTERVAL) (LINE-NEXT LINE) 0)
		AND RETURN (VALUES)
	      UNTIL (EQ LINE END-LINE))
	1;; The above code will have given all lines a 2line-node1 of the header interval.
0	1;; We must now fixup the body to have the proper 2line-node1 (the "reply" interval).
0	(LOOP WITH END-LINE = (BP-LINE (INTERVAL-LAST-BP REPLY-INTERVAL))
	      FOR LINE = (BP-LINE (INTERVAL-FIRST-BP REPLY-INTERVAL)) THEN (LINE-NEXT LINE)
	      DO (SETF (LINE-NODE LINE) REPLY-INTERVAL)
	      UNTIL (EQ LINE END-LINE)))
      (CL:SETF (NODE-TICK DRAFT-MSG) (TICK)
	       (NODE-TICK (MSG-INTERVAL MSG)) *TICK*))
    DRAFT-MSG))

(DEFCOM-FOR-ZMAIL COM-SAVE-DRAFT-AS-MSG
		  "Save the text of the draft being composed as a message.
To name a specific buffer, give a numeric argument of 2.
If the draft has already been saved, it will be rewritten into the existing
message, unless forced to be saved as a new message by giving a numeric
argument of 4 (or Control-U).
The arguments actually are taken in bitwise combination, so an argument
of 6 has the combined effect of an argument of 2 and an argument of 4." ()
  (LET* ((PROMPT-FOR-SEQUENCE (CL:LOGBITP 1 *NUMERIC-ARG*))	;Arg=2,6
	 (FORCE (CL:LOGBITP 2 *NUMERIC-ARG*))		        ;Arg=4,6,or c-U
	 (MSG (UNLESS FORCE (SEND *DRAFT-MSG* :MSG)))
	 (NEW-BUFFER NIL)
	 (NEW-MESSAGE-P NIL)
	 (APPARENT-BUFFER (AND MSG (NEQ (MSG-PARSED-P MSG) :KILLED) (MSG-BUFFER MSG))))
    (WHEN (OR PROMPT-FOR-SEQUENCE (NOT APPARENT-BUFFER))
      (SETQ NEW-BUFFER (COND ((NULL *MAIL-FILE-FOR-DRAFTS*)
			      (OR APPARENT-BUFFER
				  (AND (SEQUENCE-BUFFER-P *SEQUENCE*)
				       *SEQUENCE*)
				  *DEFAULT-BUFFER*
				  (LOOP FOR MF IN *SEQUENCE-LIST*
					WHEN (SEQUENCE-BUFFER-P MF)
					  RETURN MF)
				  (BARF
				    "There is no sequence to put a draft message in."
				    )))
			     ((GET-BUFFER-FROM-PATHNAME
				(FS:MERGE-PATHNAMES *MAIL-FILE-FOR-DRAFTS*
						    *ZMAIL-PATHNAME-DEFAULTS*)
				T))))
      (WHEN PROMPT-FOR-SEQUENCE
	(SETQ NEW-BUFFER
	      (OR (DW:MENU-CHOOSE
		    (LOOP FOR SEQ IN *SEQUENCE-LIST*
			  WHEN (SEQUENCE-BUFFER-P SEQ)
			    COLLECT SEQ)
		    :PROMPT "Sequence into which message should be saved"
		    :DEFAULT NEW-BUFFER)
		  (BARF "No sequence was chosen."))))
      (COND ((AND (NOT FORCE) APPARENT-BUFFER (EQ NEW-BUFFER APPARENT-BUFFER))
	     ;; (Implicitly, PROMPT-FOR-SEQUENCE must be true to get here.)
	     ;; The user has selected the buffer he'd have gotten to begin with.
	     ;; That means we entered the wrong piece of code. Rather than abort,
	     ;; and make him retype the command, just pretend he didn't ask for
	     ;; this option so we'll fall through into the next clause.
	     (SETQ PROMPT-FOR-SEQUENCE NIL))
	    (T
	     ;; Ok, the user has committed to a fresh message.
	     ;; Create it and set things up.
	      (SETQ NEW-MESSAGE-P T)
	      (SETQ MSG (MAKE-EMPTY-MSG))
	      (SETF (SEND *DRAFT-MSG* :MSG) MSG)
	      (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY))))
    (WHEN (AND (NOT PROMPT-FOR-SEQUENCE) APPARENT-BUFFER)
      (SETF (MSG-STATUS MSG)
	    (SOME-PLIST (MSG-STATUS MSG)
			*INTERNAL-TYPE-PROPERTIES-WITHOUT-ORIGINAL-HEADERS*))
      (SETF (MSG-TICK MSG) (TICK))
      (SEND *SUMMARY-WINDOW* :NEED-TO-REDISPLAY-MSG MSG))
    (SETF (MSG-INSERTION-TICK MSG) (TICK))	; mark when placed in buffer
    (LET ((END-BP (INTERVAL-LAST-BP *HEADER-INTERVAL*)))
      (UNLESS (BEG-LINE-P END-BP)
	(INSERT END-BP #\CR)))
    (LET ((END-BP (INTERVAL-LAST-BP *REPLY-INTERVAL*)))
      (UNLESS (BEG-LINE-P END-BP)
	(INSERT END-BP #\CR)))
    ;; *** perhaps this should be a user template? ***
    (LET ((INTERVAL (MSG-INTERVAL MSG)))
      (DELETE-INTERVAL INTERVAL)
      (LET ((PLIST (LOCF (MSG-STATUS MSG))))
	(LET ((NOW (TIME:GET-UNIVERSAL-TIME)))
	  (UNLESS (GET PLIST :DATE) (PUTPROP PLIST NOW :DATE))
	  (PUTPROP PLIST NOW :DRAFT-COMPOSITION-DATE))
	(SEND *DRAFT-MSG* :SAVE-WINDOW-STATE)	;Swap out fonts
	(LET ((END-BP (INTERVAL-LAST-BP INTERVAL))
	      (HEADERS `(:HEADERS ,(SOME-PLIST (CDR PLIST)
					       *DRAFT-MSG-INTERNAL-HEADERS*))))
	  (INSERT-MOVING END-BP
			 (WITH-OUTPUT-TO-STRING (STREAM)
			   (OUTPUT-HEADERS STREAM HEADERS)))
	  (INSERT-INTERVAL END-BP *DRAFT-MSG*)))
      (SETF (NODE-TICK INTERVAL) (TICK))
      (SETF (NODE-TICK *DRAFT-MSG*) *TICK*))
    (WHEN NEW-BUFFER (SEND NEW-BUFFER :ADD-MSG MSG))
    (TYPEIN-LINE "Draft ~:[updated~;saved~] in ~A"
		 NEW-MESSAGE-P (SEND (MSG-BUFFER MSG) :NAME))
    (WITH-MSG-REDISPLAY-DELAYED
      (IF NEW-BUFFER
	  (MSG-PUT MSG *DRAFT-MSG* 'DRAFT-MSG)
	(SET-PARSED-MSG-HEADERS MSG))
      (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS MSG))
    (WHEN (EQ MSG *MSG*)
      (MUST-REDISPLAY *MSG-WINDOW* DIS-TEXT)))
  DIS-NONE)

(DEFCOM-FOR-ZMAIL COM-ZMAIL-SET-DEFAULT-CHARACTER-STYLE
  "Sets the default character style for this draft."
		  ()
  (LET ((WINDOW (IF (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
		    *MSG-WINDOW* *REPLY-WINDOW*)))
    (MULTIPLE-VALUE-BIND (NEW-DEFAULT-CHARACTER-STYLE DEFAULT-CHANGED-P)
	(ZMAIL-ACCEPT-DEFAULT-CHARACTER-STYLE WINDOW "draft")
      (WHEN DEFAULT-CHANGED-P
	(PROGN
	  (SEND *DRAFT-MSG* :SET-DEFAULT-CHARACTER-STYLE NEW-DEFAULT-CHARACTER-STYLE)
	  (SET-WINDOW-DEFAULT-CHARACTER-STYLE WINDOW NEW-DEFAULT-CHARACTER-STYLE)
	  (WHEN (EQ WINDOW *REPLY-WINDOW*)
	    (SET-WINDOW-DEFAULT-CHARACTER-STYLE *HEADER-WINDOW* NEW-DEFAULT-CHARACTER-STYLE)))
	)
      DIS-NONE)))

;;;; Special sending (local and fcc)

(DEFUN COMPOSE-VIA-LOCAL-MAIL (TEMPLATE-EXPANSION &AUX BUFFER MSG RESELECT-P)
  (SETQ BUFFER (BUFFER-FOR-LOCAL-MAIL TEMPLATE-EXPANSION))
  ;; Cannot edit if this is a buffer and current sequence is also.
  (UNWIND-PROTECT
    (PROGN
      (WHEN (OR (NULL *SEQUENCE*)
		(AND (NEQ BUFFER *SEQUENCE*)
		     (SEQUENCE-BUFFER-P *SEQUENCE*)))
	(SETQ RESELECT-P *SEQUENCE*)
	(SELECT-SEQUENCE BUFFER))
      (SETQ MSG (TRANSMIT-TO-NEW-MSG BUFFER TEMPLATE-EXPANSION T))
      ;; Add to current if it's a collection.
      (WHEN (AND *SEQUENCE*
		 (NEQ BUFFER *SEQUENCE*)
		 (NOT (SEQUENCE-BUFFER-P *SEQUENCE*)))
	(SEND *SEQUENCE* ':ADD-MSG MSG))
      (ZMAIL-SELECT-MSG MSG)
      (FUNCALL *SUMMARY-WINDOW* ':NEED-FULL-REDISPLAY)
      (MOVE-BP (POINT)
	       (CADAR (GET-COMPOSITION-STARTING-POINTS TEMPLATE-EXPANSION
						       (MSG-INTERVAL MSG) NIL T
						       (MSG-END-BP MSG) (MSG-END-BP MSG) T)))
      (MUST-REDISPLAY *WINDOW* DIS-ALL)
      (COM-EDIT-CURRENT-MSG))
    (WHEN RESELECT-P
      (SELECT-SEQUENCE RESELECT-P))))

(DEFUN BUFFER-FOR-LOCAL-MAIL (&OPTIONAL EXPANSION &AUX NAME)
  (COND ((AND EXPANSION
	      (SETQ NAME (GET (LOCF EXPANSION) ':LOCAL-BUFFER)))
	 (GET-BUFFER-FROM-PATHNAME NAME T))
	(*MSG* (MSG-BUFFER *MSG*))
	((LOOP FOR MF IN *SEQUENCE-LIST*
	       WHEN (SEQUENCE-BUFFER-P MF)
	       RETURN MF))
	(T (BARF "There is no mail buffer to put a local message in."))))

(DEFUN FCC-SENDING-MODE (FILES TEMPLATE-EXPANSION)
  (LOOP WITH DRAFT-MSG = (GET (LOCF TEMPLATE-EXPANSION) :DRAFT-MSG)
	INITIALLY
	  (WHEN DRAFT-MSG
	    (MARK-MESSAGE-TRANSMITTING DRAFT-MSG TEMPLATE-EXPANSION))
	FOR PATHNAME IN FILES
	DO (SETQ PATHNAME (FS:MERGE-PATHNAMES PATHNAME *ZMAIL-PATHNAME-DEFAULTS*))
	AS BUFFER = (LET ((*HANDLE-REFERENCES-LITERALLY* NIL)
			  (*ZMAIL-COMMAND-BUTTON* NIL))
			 (GET-BUFFER-FROM-PATHNAME PATHNAME T))
	COLLECT BUFFER INTO MFS
	DO (TRANSMIT-TO-NEW-MSG BUFFER TEMPLATE-EXPANSION NIL)
	   (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY)
	FINALLY
	  (WHEN DRAFT-MSG
	    (SEND DRAFT-MSG :MESSAGE-SENT MFS TEMPLATE-EXPANSION
		  #'(LAMBDA (BUFFER STREAM)
		      (FORMAT STREAM "buffer ~A" (SEQUENCE-NAME BUFFER)))))))

(DEFUN TRANSMIT-TO-NEW-MSG (BUFFER TEMPLATE-EXPANSION INHIBIT-REFORMATTING)
  (LET* ((MSG (MAKE-EMPTY-MSG))
	 (STAT (LOCF (MSG-STATUS MSG)))
	 (STREAM (OPEN-INTERVAL-STREAM (MSG-END-BP MSG))))
    (OUTPUT-HEADERS STREAM TEMPLATE-EXPANSION T)
    (WITH-BP (HEADERS-END (SEND STREAM ':READ-BP) :NORMAL)
      (LET ((TEXT (GET (LOCF TEMPLATE-EXPANSION) ':TEXT)))
	(COND ((NULL TEXT))
	      ((TYPEP TEXT 'INTERVAL)
	       (INSERT-INTERVAL (MSG-END-BP MSG) TEXT))
	      (T
	       (SEND STREAM ':STRING-OUT TEXT))))
      (LET ((BP (COPY-BP HEADERS-END :NORMAL (MSG-REAL-INTERVAL MSG))))
	;; Must reparse the headers to get the line-contents-plist's correct.
	(SETF (CDR STAT) (PARSE-HEADERS-INTERVAL (MSG-START-BP MSG) BP T))
	(PUTPROP STAT BP 'HEADERS-END-BP)))
    (SETF (MSG-INSERTION-TICK MSG) (TICK))	   ; mark when placed in buffer
    (SETF (MSG-PARSED-P MSG) T)
    (WITH-MSG-REDISPLAY-DELAYED
      (LET ((*HANDLE-REFERENCES-LITERALLY* NIL))
	;; "Verily, let us not handle our references literally."  -- GMP, 20 Nov 85.
	(SYS:LETF-IF INHIBIT-REFORMATTING
		     (((GET STAT 'REFORMATTED) :INHIBIT))
	  (SEND BUFFER :ADD-MSG MSG)))
      (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS MSG))
    (SET-MSG-SUMMARY-LINE MSG STAT)
    MSG))

;;;; Special sending (immediate)

(DEFFLAVOR IMMEDIATE-SEND-DRAFT-MSG (HEADERS) (COMMAND-DRAFT-MSG-MIXIN DUMMY-DRAFT-MSG))

(DEFMETHOD (:INIT IMMEDIATE-SEND-DRAFT-MSG :AFTER) (PLIST)
  (LOOP FOR (KEY VAL) ON (GET PLIST ':TEMPLATE-EXPANSION) BY 'CDDR
	DO (SELECTQ KEY
	     (:HEADERS (SETQ HEADERS VAL))
	     (:TEXT (SETQ TEXT VAL))
	     )))

(DEFUN IMMEDIATE-SEND-COMPOSITION-FUNCTION (TEMPLATE-EXPANSION)
  (MAKE-DRAFT-AND-TRANSMIT 'IMMEDIATE-SEND-DRAFT-MSG
			   ':TEMPLATE-EXPANSION TEMPLATE-EXPANSION)
  DIS-NONE)

(DEFUN MAKE-DRAFT-AND-TRANSMIT (DRAFT-FLAVOR &REST INIT-KEYWORDS)
  (LET ((DRAFT (LEXPR-FUNCALL #'MAKE-INSTANCE DRAFT-FLAVOR INIT-KEYWORDS)))
    (SEND DRAFT ':TRANSMIT)
    (PUSH DRAFT *DUMMY-DRAFT-LIST*)
    (ZMAIL-UNDO-SAVE 'UNDO-DRAFT-MSG ':DRAFT-MSG DRAFT)))

(DEFFLAVOR SEND-IT-FAILS
	(EXPLANATION RECIPIENT-EXPLANATION HOST RESPONSE DRAFT-MSG)
	(BARF)
  :INITABLE-INSTANCE-VARIABLES
  (:INIT-KEYWORDS :RECIPIENT))

(DEFMETHOD (:REPORT SEND-IT-FAILS) (STREAM)
  (FORMAT STREAM "~A from ~A for ~A~@[: ~A~]~%" EXPLANATION HOST RECIPIENT-EXPLANATION
	  RESPONSE)
  (FORMAT STREAM "(Message not sent to ~:[any~;remaining~] recipients.)"
	  (AND DRAFT-MSG
	       (LOOP FOR (NIL . RECIPIENTS) IN (SEND DRAFT-MSG :RECIPIENTS-DONE)
			 THEREIS (NOT (EQUAL RECIPIENTS '(:TRANSMITTING)))))))

(DEFFLAVOR SEND-IT-FAILS-FOR-RECIPIENT (RECIPIENT) (SEND-IT-FAILS)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:POSITION SEND-IT-FAILS-FOR-RECIPIENT) ()
  (LET ((BP (FIRST (CADR (GETL (LOCF RECIPIENT) '(:INTERVAL :ORIGINAL-INTERVAL))))))
    (VALUES (FIRST BP) (SECOND BP))))

;;; This host overrides any default for mailing.
(DEFVAR *MAIL-NETWORK-HOST* NIL
  "This variable may assume the following values:
   NIL -- Let the mailer do what it thinks is best.
   NET:*LOCAL-HOST* -- Send the mail directly to its destination.
   Other host object -- Use that host as a mail server.") 

;;; Generic network sending function.
;;; If there is store and forward mail service provided anyplace at this site, we prefer
;;; that.  Otherwise, we use a dummy on the local machine that connects directly to each host
;;; and does store and forward only to otherwise unreachable places.
;;; If the mailer is loaded, it provides store and forward locally better than anyone else.
;;; If the login machine is a mail server that isn't any worse than anyone else, we use it.
(DEFUN NETWORK-SEND-IT (RECIPIENTS TEMPLATE-EXPANSION)
  (WHEN RECIPIENTS
    (FS:FORCE-USER-TO-LOGIN)
    (NET:KEEPING-NAMESPACE-SERVER
      (LET ((SERVICES (FIND-SORTED-MAIL-SERVICES)))
	(NETWORK-SEND-IT-1 SERVICES RECIPIENTS TEMPLATE-EXPANSION)))))

(DEFUN NETWORK-SEND-IT-1 (SERVICES RECIPIENTS TEMPLATE-EXPANSION)
  (BLOCK NETWORK-SEND-IT-1
    (ERROR-RESTART (ERROR "Retry sending mail via any mail server.")
      (LET ((UNAVAILABLE-HOSTS NIL))
	(LOOP FOR (SERVICE . SVCS) ON SERVICES
	      FOR FIRST FIRST T THEN NIL
	      DO (CATCH-ERROR-RESTART-IF
		   (NOT (NULL SVCS))
		   ((ERROR) "Send mail via ~{~A~^ or ~}"
		    (MAPCAR #'NETI:SERVICE-ACCESS-PATH-HOST SVCS))
		   (CONDITION-CASE-IF (OR (NULL *MAIL-NETWORK-HOST*)
					  (NOT FIRST))
				      ()
		       (RETURN-FROM NETWORK-SEND-IT-1
			 (INVOKE-MAIL-SERVICE SERVICE RECIPIENTS TEMPLATE-EXPANSION T))
		     (NETI:HOST-BELIEVED-UNAVAILABLE
		       (PUSH SERVICE UNAVAILABLE-HOSTS))
		     ((MAILER:MAILER-TEMPORARY-ERROR SYS:CONNECTION-ERROR)))))
	(WHEN (AND UNAVAILABLE-HOSTS
		   (YES-OR-NO-P "Unable to contact any available store-and-forward mail server.
Attempt to use servers which are believed to be unavailable? "))
	  (LOOP FOR (SERVICE . SVCS) ON (NREVERSE UNAVAILABLE-HOSTS)
		DO (CATCH-ERROR-RESTART-IF
		     (NOT (NULL SVCS))
		     ((ERROR) "Send mail via ~{~A~^ or ~}"
		      (MAPCAR #'NETI:SERVICE-ACCESS-PATH-HOST SVCS))
		     (CONDITION-CASE ()
			 (RETURN-FROM NETWORK-SEND-IT-1
			   (INVOKE-MAIL-SERVICE SERVICE RECIPIENTS TEMPLATE-EXPANSION NIL))
		       ((MAILER:MAILER-TEMPORARY-ERROR SYS:CONNECTION-ERROR)))))))
      (IF (OR (NULL SERVICES)
	      (YES-OR-NO-P "Unable to contact any store-and-forward mail server.
Attempt to send mail directly to destination? "))
	  (RETURN-FROM NETWORK-SEND-IT-1
	    (NETWORK-SEND-IT-2 RECIPIENTS TEMPLATE-EXPANSION))
	  (BARF "No mail server responded.")))))

1;;; Here for the real hard work.
0(DEFUN NETWORK-SEND-IT-2 (RECIPIENTS TEMPLATE-EXPANSION
			  &AUX RECIPIENT-HOST-PAIRS RECIPIENT-SERVICE-PAIRS)
  1;; First bucket the recipients among known hosts.
0  (LOOP FOR RECIPIENT IN RECIPIENTS
	FOR HOST = (MAILER:ADDRESS-FIRST-HOP RECIPIENT)
	DO (PUSH RECIPIENT (GET (LOCF RECIPIENT-HOST-PAIRS) (OR HOST :UNKNOWN))))
  1;; Then for each host, find a path to 0STORE-AND-FORWARD-MAIL1 or0 MAIL-TO-USER1 there.
  ;; (We get 0STORE-AND-FORWARD-MAIL1, if possible, so that we can forward through it.)
0  (LOOP FOR LIST ON RECIPIENT-HOST-PAIRS BY 'CDDR
	AS (HOST RECIPIENTS) = LIST
	FOR SERVICE = NIL
	DO (UNLESS (EQ HOST :UNKNOWN)
	     1;; At the local site, save ourselves the trouble of looking.
0	     (UNLESS (EQ (SEND HOST :SITE) NETI:*LOCAL-SITE*)
	       (SETQ SERVICE (CONDITION-CASE ()
				  (NETI:FIND-PATH-TO-SERVICE-ON-HOST :STORE-AND-FORWARD-MAIL
								     HOST)
				(NET:HOST-DOES-NOT-SUPPORT-SERVICE NIL))))
	     (WHEN (NULL SERVICE)
	       (SETQ SERVICE (CONDITION-CASE ()
				  (NETI:FIND-PATH-TO-SERVICE-ON-HOST :MAIL-TO-USER HOST)
				(NET:HOST-DOES-NOT-SUPPORT-SERVICE NIL)))))
	   (UNLESS (NULL SERVICE)
	     (PUTPROP (LOCF RECIPIENT-SERVICE-PAIRS) RECIPIENTS SERVICE)
	     1;; Mark host as done.
0	     (SETF (CAR LIST) NIL)))
  1;; If there are recipients left to be done, match them up with 0STORE-AND-FORWARD-MAIL
1  ;; service at their site if possible; otherwise use any 0STORE-AND-FORWARD-MAIL1 we can.
0  (LOOP WITH UNSPECIFIC-SERVICE = NIL
	FOR (HOST RECIPIENTS) ON RECIPIENT-HOST-PAIRS BY 'CDDR
	WHEN (NOT (NULL HOST))
	  DO (LET ((SITE (AND (NEQ HOST :UNKNOWN) (SEND HOST :SITE))))
	       (LOOP FOR LIST ON RECIPIENT-SERVICE-PAIRS BY 'CDDR
		     AS (SERVICE) = LIST
		     WHEN (AND (EQ (NETI:SERVICE-ACCESS-PATH-SERVICE SERVICE)
				   :STORE-AND-FORWARD-MAIL)
			       (EQ (SEND (NETI:SERVICE-ACCESS-PATH-HOST SERVICE) :SITE) SITE))
		       DO (SETF (CADR LIST) (APPEND (CADR LIST) RECIPIENTS))
			  (RETURN NIL)
		     FINALLY (UNLESS (OR (NULL SITE)
					 (EQ SITE NETI:*LOCAL-SITE*))
			       (LET ((PATHS (WITH-STACK-LIST (THAT-SITE :SITE SITE)
					      (NETI:FIND-PATHS-TO-SERVICE
						:STORE-AND-FORWARD-MAIL THAT-SITE))))
				 (UNLESS (NULL PATHS)
				   (LET ((SERVICE (NETI:MOST-DESIRABLE-SERVICE-ACCESS-PATH
						    PATHS)))
				     (SETF (GET (LOCF RECIPIENT-SERVICE-PAIRS) SERVICE)
					   RECIPIENTS))
				   (RETURN NIL))))
			     (WHEN (NULL UNSPECIFIC-SERVICE)
			       (SETQ UNSPECIFIC-SERVICE
				     (LOOP FOR SERVICE IN RECIPIENT-SERVICE-PAIRS BY 'CDDR
					   WHEN (EQ (NETI:SERVICE-ACCESS-PATH-SERVICE SERVICE)
						    :STORE-AND-FORWARD-MAIL)
					     RETURN SERVICE))
			       (WHEN (NULL UNSPECIFIC-SERVICE)
				 (LET ((PATHS (NET:FIND-PATHS-TO-SERVICE
						:STORE-AND-FORWARD-MAIL)))
				   (SETQ PATHS (DEL-IF
						 #'(LAMBDA (PATH)
						     (EQ (NETI:SERVICE-ACCESS-PATH-HOST PATH)
							 NET:*LOCAL-HOST*))
						 PATHS))
				   (WHEN (NULL PATHS)
				     (FERROR "Could not find a server anywhere to ~
					      handle these recipients: ~{~A~^, ~}"
					     (LOOP FOR (HOST RECIPIENTS)
						       ON RECIPIENT-HOST-PAIRS BY 'CDDR
						   WHEN HOST
						     APPEND (LOOP FOR RECIPIENT IN RECIPIENTS
								  COLLECT (STRING-FROM-HEADER
									    RECIPIENT
									    :SHORT)))))
				   (SETQ UNSPECIFIC-SERVICE
					 (NETI:MOST-DESIRABLE-SERVICE-ACCESS-PATH
					   PATHS)))))
			     (SETF (GET (LOCF RECIPIENT-SERVICE-PAIRS) UNSPECIFIC-SERVICE)
				   (APPEND (GET (LOCF RECIPIENT-SERVICE-PAIRS)
						UNSPECIFIC-SERVICE)
					   RECIPIENTS)))))
  1;; Now everyone is done, do the actual sending.
0  (WHEN (CDDR RECIPIENT-SERVICE-PAIRS)
    (PUTPROP (LOCF TEMPLATE-EXPANSION) T :MULTIPLE-SENDINGS))
  (LOOP FOR (SERVICE RECIPIENTS) ON RECIPIENT-SERVICE-PAIRS BY 'CDDR
	DO (INVOKE-MAIL-SERVICE SERVICE RECIPIENTS TEMPLATE-EXPANSION NIL)))
(DEFUN INVOKE-MAIL-SERVICE (SERVICE-ACCESS-PATH RECIPIENTS TEMPLATE-EXPANSION
			    CACHED-UNAVAILABILITY)
  (MAILER:WITH-MAILER (MAILER SERVICE-ACCESS-PATH
			      :CACHE-UNAVAILABILITY CACHED-UNAVAILABILITY
			      :TIMEOUT MAILER:*NETWORK-DELIVERY-TIMEOUT*)
    (LET ((DRAFT-MSG (GET (LOCF TEMPLATE-EXPANSION) :DRAFT-MSG))
	  (SUCCESSFUL-RECIPIENTS))
      (SEND MAILER :START-MESSAGE `(:USER ,SI:*USER*))
      (LOOP FOR RECIPIENT IN RECIPIENTS
	    DO (CONDITION-CASE (ERROR)
		    (SEND MAILER :VERIFY-RECIPIENT RECIPIENT)
		  (MAILER:MAILER-ERROR
		    (SIGNAL 'ZWEI:SEND-IT-FAILS-FOR-RECIPIENT
			    :EXPLANATION "Error"
			    :HOST (NETI:SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH)
			    :RECIPIENT RECIPIENT
			    :RECIPIENT-EXPLANATION (STRING-FROM-HEADER RECIPIENT :HOST)
			    :RESPONSE (FORMAT NIL "~A" ERROR)
			    :DRAFT-MSG DRAFT-MSG))
		  (:NO-ERROR (PUSH RECIPIENT SUCCESSFUL-RECIPIENTS))))
      (WHEN DRAFT-MSG
	(MARK-MESSAGE-TRANSMITTING DRAFT-MSG TEMPLATE-EXPANSION))
      (FLET ((MAKE-MSG-TEXT (ENCODING-STREAM TEXT-STREAM)
	       (SEND ENCODING-STREAM :SET-STREAM TEXT-STREAM
				     :RESET-MAPPINGS NIL
				     :DUMPING-FAT (CL:GETF
						    (CL:GETF TEMPLATE-EXPANSION :HEADERS)
						    :CHARACTER-TYPE-MAPPINGS))
	       (OUTPUT-HEADERS-AND-TEXT ENCODING-STREAM TEMPLATE-EXPANSION)
	       (SEND ENCODING-STREAM :FORCE-OUTPUT)
	       (SEND ENCODING-STREAM :MAKE-IDLE)))
	(WITH-INPUT-FROM-STRING
	    (STREAM (WITH-OUTPUT-TO-STRING (STREAM)
		      (LET ((SAVING-STREAM (CL:GETF TEMPLATE-EXPANSION :SAVING-STREAM)))
			(IF SAVING-STREAM
			    (MAKE-MSG-TEXT SAVING-STREAM STREAM)
			  (USING-RESOURCE (SAVING-STREAM SI:EPSILON-ENCODING-OUTPUT-STREAM NIL
							 :FLAVOR 'ZMAIL-MSG-SAVING-STREAM)
			    (MAKE-MSG-TEXT SAVING-STREAM STREAM))))))
	  (SEND MAILER :RECEIVE-MESSAGE NIL STREAM)))
      (SEND MAILER :FINISH-MESSAGE)
      ;;Tell Zmail that we made it.
      (WHEN (AND DRAFT-MSG (NOT (NULL SUCCESSFUL-RECIPIENTS)))
	(SEND DRAFT-MSG :MESSAGE-SENT SUCCESSFUL-RECIPIENTS TEMPLATE-EXPANSION
	      #'ZWEI:MESSAGE-SENT-ADDRESS-RECIPIENT-PRINTER "via ~A"
	      (NETI:SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH))))))

(DEFUN FIND-SORTED-MAIL-SERVICES (&OPTIONAL (SITE NET:*LOCAL-SITE*))
  (LET ((SERVICES (FIND-MAIL-SERVICES SITE))
	(MAIL-HOST (OR (SECOND (ZMAIL-USER-MAIL-ADDRESS)) FS:USER-LOGIN-MACHINE)))
    ;; Among equally desirable, prefer hosts at local site, user's mail
    ;; host, hosts at user's mail-host site
    (SETQ SERVICES
	  (CL:SORT SERVICES
		   #'(LAMBDA (PATH1 PATH2)
		       (LET* ((LOCAL-SITE NET:*LOCAL-SITE*)
			      (MAIL-SITE (SEND MAIL-HOST ':SITE))
			      (PATH1-HOST (NETI:SERVICE-ACCESS-PATH-HOST PATH1))
			      (PATH2-HOST (NETI:SERVICE-ACCESS-PATH-HOST PATH2))
			      (PATH1-SITE (SEND PATH1-HOST ':SITE))
			      (PATH2-SITE (SEND PATH2-HOST ':SITE)))
			 (OR 
			   (> (NETI:SERVICE-ACCESS-PATH-DESIRABILITY PATH1)
			      (NETI:SERVICE-ACCESS-PATH-DESIRABILITY PATH2))
			   (AND (EQ PATH1-SITE LOCAL-SITE)
				(NOT (EQ PATH2-SITE LOCAL-SITE)))
			   (AND (EQ PATH1-HOST MAIL-HOST)
				(NOT (EQ PATH2-HOST MAIL-HOST)))
			   (AND (EQ PATH1-SITE MAIL-SITE)
				(NOT (EQ PATH2-SITE MAIL-SITE))))))))
    ;; Move any explicit host to the front.
    (WHEN *MAIL-NETWORK-HOST*
      (LET ((SERVICE
	      (CL:FIND *MAIL-NETWORK-HOST* SERVICES :KEY #'NETI:SERVICE-ACCESS-PATH-HOST)))
	(IF SERVICE
	    (SETQ SERVICES (CONS SERVICE (DELQ SERVICE SERVICES)))
	    (CONDITION-CASE-IF (EQ *MAIL-NETWORK-HOST* NET:*LOCAL-HOST*) ()
		 (PUSH (NETI:FIND-PATH-TO-SERVICE-ON-HOST :STORE-AND-FORWARD-MAIL
							  *MAIL-NETWORK-HOST*)
		       SERVICES)
	       (NET:HOST-DOES-NOT-SUPPORT-SERVICE
		 (SETQ SERVICES NIL))))))
    SERVICES))

(DEFUN FIND-MAIL-SERVICES (&OPTIONAL (SITE NET:*LOCAL-SITE*))
  (NETI:KEEPING-NAMESPACE-SERVER
    (OR 
      (NETI:SEARCHING-ONE-SITE (SITE)
	(NET:FIND-PATHS-TO-SERVICE ':STORE-AND-FORWARD-MAIL))
      (LET ((OTHER-SITES (NETI:GET-OTHER-SITES-IN-MAIL-AREA SITE)))
	(WHEN OTHER-SITES
	  (LOOP FOR OTHER-SITE IN OTHER-SITES
		APPEND (NETI:SEARCHING-ONE-SITE (OTHER-SITE)
			 (NET:FIND-PATHS-TO-SERVICE ':STORE-AND-FORWARD-MAIL))))))))

(ADD-INITIALIZATION "Local mail hosts"
		    '(FIND-MAIL-SERVICES)
		    NIL
		    'NETI:COMMONLY-USED-PROPERTY-LISTS)

1;;; Returns the host object corresponding to the first hop in the address --
;;;    Unlike 2mailer:address-first-hop1, this function simply parses the host
;;;    rather than using 2neti:find-domain-mail-hosts1 as its callers are only
;;;    interested in direct connections as they do not use store and forward
;;;    protocols.
0(DEFUN ADDRESS-HOST-OBJECT (ADDRESS)
  (DECLARE (VALUES HOST HOST-STRING VALID))
  (MULTIPLE-VALUE-BIND (HOST HOST-STRING IGNORE IGNORE)
      (MAILER:ADDRESS-FIRST-HOP-RAW ADDRESS)
    (IF HOST
	(VALUES HOST NIL (SEND HOST :CHECK-VALIDITY))
	(MULTIPLE-VALUE-BIND (HOST VALID)
	    (NET:PARSE-HOST HOST-STRING T)
	  (VALUES HOST HOST-STRING VALID)))))

;;; Address comparison functions

(DEFUN DECOMPOSE-ADDRESS (ADDRESS)
  (VALUES (CL:GETF ADDRESS :NAME)
	  (ADDRESS-HOST-OBJECT ADDRESS)))

(3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI");;; Address comparison is based on textual representation only --
;;;    Trying to compare hosts is too slow as domain names would require resolution
;;;    which involves arbitrary network delays.
0(DEFUN ADDRESS-LESSP (ADDRESS-1 ADDRESS-2)
  (LABELS ((ADDRESS-STRING (ADDRESS)
	     (OR (CL:GETF ADDRESS :STRING-FOR-COMPARISON)
		 (CL:GETF ADDRESS :ORIGINAL-STRING)
		 (LET ((INTERVAL (CL:GETF ADDRESS :INTERVAL)))
		   (WHEN INTERVAL
		     (LET ((STRING (STRING-INTERVAL (FIRST INTERVAL) (SECOND INTERVAL) T)))
		       (PUTPROP (LOCF ADDRESS) STRING :STRING-FOR-COMPARISON)
		       STRING)))
		 (LET ((STRING (STRING-FROM-HEADER ADDRESS :ROUTE)))
		   (PUTPROP (LOCF ADDRESS) STRING :STRING-FOR-COMPARISON)
		   STRING))))
    (STRING-LESSP (ADDRESS-STRING ADDRESS-1) (ADDRESS-STRING ADDRESS-2))))

3#+IGNORE0					3;Real definition if host lookup were fast
0(DEFUN ADDRESS-LESSP (ADDRESS-1 ADDRESS-2)
  (MULTIPLE-VALUE-BIND (NAME-1 HOST-1)
      (DECOMPOSE-ADDRESS ADDRESS-1)
    (MULTIPLE-VALUE-BIND (NAME-2 HOST-2)
	(DECOMPOSE-ADDRESS ADDRESS-2)
      (IF (OR (NULL HOST-1) (NULL HOST-2)
	      (EQ HOST-1 HOST-2)
	      ;;; suppress "sorting by site" as Show Mailing List doesn't display sites
	      #||(MAILER:ALL-MAIL-ADDRESSES-FORWARD-BETWEEN-HOSTS-P HOST-1 HOST-2)||#)
	  (STRING-LESSP NAME-1 NAME-2)
	  (STRING-LESSP (SEND HOST-1 :MAIL-NAME) (SEND HOST-2 :MAIL-NAME))))))

3#+IGNORE0					3;No callers -- Also extremely slow
0;;; DEFAULT-HOST means no explicit host matches any host
(DEFUN ADDRESS-EQUAL (ADDRESS-1 ADDRESS-2 &KEY DEFAULT-HOST)
  (MULTIPLE-VALUE-BIND (NAME-1 HOST-1)
      (DECOMPOSE-ADDRESS ADDRESS-1)
    (MULTIPLE-VALUE-BIND (NAME-2 HOST-2)
	(DECOMPOSE-ADDRESS ADDRESS-2)
      (AND (STRING-EQUAL NAME-1 NAME-2)
	   (COND ((EQ HOST-1 HOST-2))
		 ((NULL HOST-1)
		  (LET ((HOST-1 (GET (LOCF ADDRESS-1) :HOST)))
		    (OR (AND DEFAULT-HOST (NULL HOST-1))
			(AND (NULL HOST-2)
			     (EQUAL HOST-1 (GET (LOCF ADDRESS-2) :HOST))))))
		 ((NULL HOST-2)
		  (LET ((HOST-2 (GET (LOCF ADDRESS-2) :HOST)))
		    (AND DEFAULT-HOST (NULL HOST-2))))
		 ((MAILER:ALL-MAIL-ADDRESSES-FORWARD-BETWEEN-HOSTS-P HOST-1 HOST-2)))))))
