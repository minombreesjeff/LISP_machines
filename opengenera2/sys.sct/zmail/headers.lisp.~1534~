;;; Lisp Machine mail reader -*- Mode:LISP; Package:ZWEI; Base: 8 -*- 
;;; Header defining and printing.  Header parsing is in RFC733.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Insure that a message is parsed -- Returns a pointer to the message's (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")status1 cell.
;;; Whether any parsing occurs is controlled by the value of the message's 2parsed-p1 cell.
;;; 2parsed-p1 may legitimately assume any of the following values:
;;;    2nil1 -- The message isn't parsed.  We'll parse it using it containing buffer's
;;;       2parse-msg1 method and return the status.
;;;    A 2msg-buffer1 instance -- The message isn't parsed.  We'll parse it using the
;;;       2parse-msg1 method of this instance and return the status.  This type of value is
;;;       only used by inbox messages to insure that the message is parsed with the
;;;       proper method and daemons.
;;;    2t1 -- The message has already been parsed.  We can simply return the status.
;;;    2:killed1 -- The message has been killed prior to expunging and, therefore,
;;;       contains no valid data except that needed to preserve reference chains.
;;;       This value is considered an error unless the caller explicitly allows it.
;;;    An 2si:process1 instance -- The message is being parsed by said process.  We will
;;;       wait for the process to complete the parse before returning the status.
0(DEFUN ASSURE-MSG-PARSED (MSG &OPTIONAL KILLED-OK)
  (LET ((PARSED-P (LOCF (MSG-PARSED-P MSG)))
	(STATUS (LOCF (MSG-STATUS MSG))))
    (UNLESS (EQ (LOCATION-CONTENTS PARSED-P) T)
      (STORE-CONDITIONAL PARSED-P CURRENT-PROCESS NIL)
      (LET ((PARSED-P-VALUE (LOCATION-CONTENTS PARSED-P)))
	(UNWIND-PROTECT
	    (COND ((OR (STORE-CONDITIONAL PARSED-P NIL CURRENT-PROCESS)
		       (AND (TYPEP PARSED-P-VALUE 'MSG-BUFFER)
			    (STORE-CONDITIONAL PARSED-P PARSED-P-VALUE CURRENT-PROCESS)))
		   (LET ((PARSING-BUFFER (IF (TYPEP PARSED-P-VALUE 'MSG-BUFFER) PARSED-P-VALUE
					   (MSG-BUFFER MSG)))
			 (*INTERVAL* (MSG-REAL-INTERVAL MSG)))
		     (PARSING-HOSTS
		       (LETF (((MSG-BUFFER MSG) PARSING-BUFFER))
			 (PARSE-MSG PARSING-BUFFER MSG STATUS)))
		     (SETQ PARSED-P-VALUE T)))
		  ((EQ (LOCATION-CONTENTS PARSED-P) :KILLED)
		   (UNLESS KILLED-OK
		     (FERROR NIL "Attempt to parse a dead message.")))
		  (T				1;Being parsed by another process -- wait.
0		   (PROCESS-WAIT "Wait until message parsed"
		     #'(LAMBDA (PARSED-P)
			 (EQ (LOCATION-CONTENTS PARSED-P) T)) PARSED-P)))
	  (STORE-CONDITIONAL PARSED-P CURRENT-PROCESS PARSED-P-VALUE))))
    STATUS))

;;; Change a property
(DEFUN MSG-PUT (MSG PROP INDICATOR)
  (LET ((STATUS (ASSURE-MSG-PARSED MSG))
	(DEFAULT-CONS-AREA *ZMAIL-MSG-AREA*))
    (PUTPROP STATUS PROP INDICATOR))
  (UNLESS (EQ *ZMAIL-BACKGROUND-P* T)		;Don't try updating from the background.
    (SEND *SUMMARY-WINDOW* :NEED-TO-REDISPLAY-MSG MSG))
  (SETF (MSG-TICK MSG) (TICK)))

(DEFVAR *PLIST-INDICATORS-NOT-TO-COMPACT*
	'(ZWEI:SCROLL-ITEM-DISPLAYER
	   ZWEI:ORIGINAL-HEADERS-INTERVAL
	   ZWEI:DELETED
	   ZWEI:RECENT
	   ZWEI:UNSEEN
	   ))

1;;; Record the parsed representation of a message's header in its 2status1 cell --
;;;    This function includes provision to compact the parse so that as much data
;;;    structure as possible is shared amongst headers.  Theoretically, compaction
;;;    reduces the working set for filtering and other similar operations.  (This
;;;    theory should be tested and, if it doesn't hold true, compaction should be
;;;    eliminated as its expensive.)
0(DEFUN SET-PARSED-MSG-HEADERS (MSG &OPTIONAL (STATUS (ASSURE-MSG-PARSED MSG))
					     SUPPRESS-RESTART-HANDLER)
  (LET* ((BUFFER (MSG-BUFFER MSG))
	 (PARSING-BUFFER (IF (TYPEP (MSG-PARSED-P MSG) 'MSG-BUFFER)
			     (MSG-PARSED-P MSG) BUFFER))
	 (HASH-TABLE (SEND BUFFER :PROPERTY-LIST-HASH-TABLE))
	 (HEADERS (MULTIPLE-VALUE-BIND (HEADERS HEADERS-END-BP)
		      (CATCH-ERROR-RESTART-IF-WITH-FORM
			     (NOT SUPPRESS-RESTART-HANDLER)
			     ((ERROR) "Mark the message as unparsable and continue.")
			   (PUTPROP STATUS T 'UNPARSEABLE)
			(PARSE-MSG-TEXT PARSING-BUFFER MSG STATUS))
		    1;; Put it onto 2status1 so it gets 2cdr1-coded by 2append1 and
		    ;; placed on the same page.
0		    (SETF (GET STATUS 'HEADERS-END-BP)
			  1;; We're hanging onto it, must be a permanent 2bp1.
0			  (COPY-BP HEADERS-END-BP :NORMAL (MSG-REAL-INTERVAL MSG)))
		    (WHEN HASH-TABLE
		      (LOOP FOR LINE FIRST (BP-LINE (MSG-START-BP MSG))
				     THEN (LINE-NEXT LINE)
			    WITH END-LINE = (BP-LINE HEADERS-END-BP)
			    UNTIL (EQ LINE END-LINE)
			    DO (LET ((TEM (GETL (LOCF (LINE-CONTENTS-PLIST LINE))
						'(PARSED-HEADERS))))
				 (UNLESS (NULL TEM)
				   (SETF (CADR TEM)
					 (COMPACT-OBJECT (CADR TEM) HASH-TABLE
							 WORKING-STORAGE-AREA
							 *ZMAIL-MSG-AREA*))))))
		    HEADERS))
	 (NEW-STATUS (APPEND (LOCATION-CONTENTS STATUS) HEADERS))
	 (COMPACTED (WHEN HASH-TABLE
		      (MAKE-LIST (LENGTH NEW-STATUS) :AREA *ZMAIL-MSG-AREA*))))
    (WHEN HASH-TABLE
      (LOOP FOR (INDICATOR VALUE) ON NEW-STATUS BY 'CDDR
	    FOR LIST ON COMPACTED BY 'CDDR
	    DO (SETF (CAR LIST) INDICATOR)
	       (SETF (CADR LIST)
		     (IF (MEMQ INDICATOR *PLIST-INDICATORS-NOT-TO-COMPACT*)
			 VALUE
		       (COMPACT-OBJECT VALUE HASH-TABLE
				       WORKING-STORAGE-AREA *ZMAIL-MSG-AREA*)))))
    (SETF (MSG-STATUS MSG) (OR COMPACTED NEW-STATUS))
    1;; Let the user code and reformatting run as if the message had been completely parsed --
0    1;;    It more or less has been.
0    (SYS:LETF-IF (NEQ (MSG-PARSED-P MSG) T)
		 (((MSG-PARSED-P MSG) T))
      (MSG-PARSE-HOOK MSG)
      (REFORMAT-HEADERS MSG)
      (SET-MSG-SUMMARY-LINE MSG STATUS))
    1;; For speed in expunging, always have the attribute, even if 2nil1.
0    (PUTPROP STATUS (GET STATUS 'DELETED) 'DELETED)))

;;; If this is non-NIL, headers are hashed together into their own area, greatly decreasing
;;; the filtering working set.
(DEFINE-ZMAIL-GLOBAL *COMPACT-MSG-STATUS* T)

(DEFUN COMPACT-OBJECT (THING HASH-TABLE FROM-AREA INTO-AREA)
  (IF (NOT *COMPACT-MSG-STATUS*)
      THING
      (COMPACT-OBJECT-1 THING HASH-TABLE FROM-AREA INTO-AREA)))

(DEFUN COMPACT-OBJECT-1 (THING HASH-TABLE FROM-AREA INTO-AREA)
  (IF (NEQ (%AREA-NUMBER THING) FROM-AREA)
      THING
    (LET ((NTHING THING)
	  (RECURSE-P NIL))
      (CATCH 'DONT-HASH
	(SEND HASH-TABLE :MODIFY-HASH THING
	      #'(LAMBDA (IGNORE VALUE EXISTS-P)
		  (DECLARE (SYS:DOWNWARD-FUNCTION))
		  (SETQ NTHING
			(COND (EXISTS-P VALUE)
			      ((LISTP THING)
			       (LET ((CAR (CAR THING)))
				 (COND ((AND (STRINGP CAR)
					     (ARRAY-HAS-LEADER-P CAR))
					;; CAR is probably a line, so THING is probably
					;; a BP.  Don't try to hash it since it probably
					;; won't do any good.
					(THROW 'DONT-HASH NIL))
				       (T
					(SETQ RECURSE-P T)
					(COPYLIST THING INTO-AREA)))))
			      ((AND (STRINGP THING)
				    ;; LINE's seem to end up in WORKING-STORAGE-AREA from
				    ;; time to time.  Just leave them alone.
				    (NOT (ARRAY-HAS-LEADER-P THING)))
			       (SUBSTRING THING 0 NIL INTO-AREA))
			      ((TYPEP THING :EXTENDED-NUMBER)
			       (SI:COPY-EXTENDED-NUMBER THING INTO-AREA))
			      (T THING)))))
	(WHEN RECURSE-P
	  (LOOP FOR CONS = NTHING THEN (CDR CONS)
		AND OCONS = NIL THEN CONS
		UNTIL (ATOM CONS)
		DO (SETF (CAR CONS) (COMPACT-OBJECT-1 (CAR CONS)
						      HASH-TABLE FROM-AREA INTO-AREA))
		FINALLY (WHEN CONS	; Dotted list.
			  (SETF (CDR OCONS)
				(COMPACT-OBJECT-1 CONS HASH-TABLE FROM-AREA INTO-AREA))))))
      NTHING)))

;;; Must not consider lines with the same contents EQ.
(DEFFLAVOR OBJECT-COMPACTING-HASH-TABLE () (SI:GENERIC-HASH-TABLE))

(DEFMETHOD (:HASH-ITEM OBJECT-COMPACTING-HASH-TABLE) (ITEM)
  (OBJECT-COMPACTING-HASH ITEM))

;;; No need for EQUAL-HASH; we special case the only things that should use %pointer
;;; (hosts and pathnames).
(DEFUN OBJECT-COMPACTING-HASH (ITEM)
  (LABELS ((HOST-NAME (HOST)
	     (CONDITION-CASE ()
		  (SEND HOST :NAME)
		(NETI:NAMESPACE-OBJECT-DELETED
		  (LET ((NICKNAMES (SEND HOST :GET :NICKNAME)))
		    (IF (NOT NICKNAMES) "DELETED"
		      (LET* ((NICKNAME (FIRST NICKNAMES))
			     (NAMESPACE (SEND NICKNAME :NAMESPACE))
			     (DOMAIN-NAME (SEND NAMESPACE :INTERNET-DOMAIN-NAME)))
			(IF (NOT DOMAIN-NAME)
				    (SEND NICKNAME :STRING)
			  (STRING-APPEND (SEND NICKNAME :STRING) "." DOMAIN-NAME))))))))
	   (PATHNAME-STRING (PATH)
	     (CONDITION-CASE ()
		  (SEND PATH :STRING-FOR-PRINTING)
		(NETI:NAMESPACE-OBJECT-DELETED	;Pathname's host might get deleted.
		  ""))))
    (TYPECASE ITEM
      (:INSTANCE
	(TYPECASE ITEM
	  (NET:HOST
	    (SYS:SXHASH-STRING (HOST-NAME ITEM)))
	  (FS:PATHNAME
	    (SYS:SXHASH-STRING (PATHNAME-STRING ITEM)))
	  (OTHERWISE 0)))
      (:LIST
	(DO ((ROT 4) (HASH 0) Y)
	    ((ATOM ITEM)
	     (UNLESS (NULL ITEM)
	       (SETQ HASH (LOGXOR (ROT (OBJECT-COMPACTING-HASH ITEM) (- ROT 4)) HASH)))
	     (SI:NON-NEGATIVE-FIXNUM HASH))
	  (SETQ Y (CAR ITEM) ITEM (CDR ITEM))
	  (OR (< (SETQ ROT (+ ROT 7)) 32.) (SETQ ROT (- ROT 32.)))
	  (SETQ HASH (LOGXOR (ROT (TYPECASE Y
				    (:SYMBOL (SYS:SXHASH-STRING (GET-PNAME Y)))
				    (:STRING (SYS:SXHASH-STRING Y))
				    (:FIXNUM Y)
				    (NET:HOST (SYS:SXHASH-STRING (HOST-NAME Y)))
				    (FS:PATHNAME (SYS:SXHASH-STRING (PATHNAME-STRING Y)))
				    (OTHERWISE (OBJECT-COMPACTING-HASH Y)))
				  ROT)
			     HASH))))
      (OTHERWISE
	(SXHASH ITEM)))))

(DEFMETHOD (:EQUAL-ITEMS OBJECT-COMPACTING-HASH-TABLE) (X Y)
  (OBJECT-COMPACTING-HASH-EQUAL X Y))

;;; Just like EQUAL, but non eq strings cannot have a leader longer than 1.
(DEFUN OBJECT-COMPACTING-HASH-EQUAL (A B)
  (PROG EQUAL ()
   L (COND ((EQL A B) (RETURN T))
	   ((NOT (ATOM A))
	    (AND (ATOM B) (RETURN NIL))
	    (PROG ()
	     L1 (COND ((EQL (CAR A) (CAR B)))
		      ((NOT (OBJECT-COMPACTING-HASH-EQUAL (CAR A) (CAR B)))
		       (RETURN-FROM EQUAL NIL)))
		(SETQ A (CDR A) B (CDR B))
		(IF (AND (LISTP A) (LISTP B)) (GO L1) (GO L))))
	   ((STRINGP A)
	    (RETURN (AND (STRINGP B)
			 (LET ((TEM (ARRAY-LEADER-LENGTH A)))
			   (OR (NULL TEM) ( TEM 1)))
			 (LET ((TEM (ARRAY-LEADER-LENGTH B)))
			   (OR (NULL TEM) ( TEM 1)))
			 ;; Really just case dependent string-equal
			 (SYS:%STRING= A 0 B 0 NIL)))))))

(COMPILE-FLAVOR-METHODS OBJECT-COMPACTING-HASH-TABLE)

;;; This function exists so that it can be advised
(DEFUN MSG-PARSE-HOOK (MSG)
  MSG)

;;; Put a header on a message and into the text of the headers too.
;;; Works by munging the original headers of the message and then reformatting again.
(DEFUN ADD-HEADER-TO-MSG (MSG TYPE PROP &KEY DELETE-IF-EMPTY UNDO-SAVE)
  (LET ((STATUS (ASSURE-MSG-PARSED MSG)))
    (MULTIPLE-VALUE-BIND (HEADERS-START-BP HEADERS-END-BP)
	(MSG-ORIGINAL-HEADERS-INTERVAL MSG)
      (WHEN (GET STATUS 'ITS-HEADER-P)
	;; Original is in ITS format, must reformat the original.
	;; Use a conservative template, since this will claim to be
	;; original later.
	(LET ((LOSING (GET STATUS 'LOSING-HEADERS)))
	  (WHEN LOSING
	    (BARF "Cannot parse headers: ~~{~&~A~}~" LOSING)))
	(LET ((INTERVAL (COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG
							   'COMMON-LOSERS-REFORMAT-TEMPLATE)))
	  (WITH-BP (AT-BP HEADERS-END-BP :MOVES)
	    (DELETE-INTERVAL HEADERS-START-BP HEADERS-END-BP T)
	    (INSERT-INTERVAL AT-BP INTERVAL)
	    (INSERT AT-BP #\CR)))
	(PARSE-HEADERS-INTERVAL HEADERS-START-BP HEADERS-END-BP T))
      (WHEN UNDO-SAVE
	(ZMAIL-UNDO-SAVE 'UNDO-ADD-HEADER-TO-MSG ':MSG MSG ':INDICATOR TYPE ':NAME UNDO-SAVE))
      ;; Move back over blank lines
      (DO ((*INTERVAL* (BP-TOP-LEVEL-NODE HEADERS-END-BP))
	   (LINE (BP-LINE HEADERS-END-BP) PREV)
	   (PREV)
	   (BEG-LINE (BP-LINE HEADERS-START-BP)))
	  ((OR (EQ LINE BEG-LINE)
	       (NOT (LINE-BLANK-P (SETQ PREV (LINE-PREVIOUS LINE)))))
	   (SETQ HEADERS-END-BP (CREATE-BP LINE 0))))
      ;; Delete any instances of the old header
      (DO ((LINE (BP-LINE HEADERS-START-BP) (LINE-NEXT LINE))
	   (END-LINE (BP-LINE HEADERS-END-BP))
	   (START-LINE NIL))
	  (NIL)
	(IF (AND (NEQ LINE END-LINE)
		 (LET ((PH (GET (LOCF (LINE-CONTENTS-PLIST LINE)) 'PARSED-HEADERS)))
		   (GET (LOCF PH) TYPE)))
	    (OR START-LINE (SETQ START-LINE LINE))
	    (COND (START-LINE
		   (DELETE-INTERVAL (CREATE-BP START-LINE 0) (CREATE-BP LINE 0) T)
		   (SETQ START-LINE NIL))))
	(AND (EQ LINE END-LINE) (RETURN)))
      (UNLESS (AND DELETE-IF-EMPTY (NULL PROP))
	(LET ((STREAM (OPEN-INTERVAL-STREAM HEADERS-END-BP)))
	  (PRINT-HEADER STREAM PROP TYPE '(:LONG-DATES T))))))
  (WITH-MSG-REDISPLAY-DELAYED
    (WHEN (MSG-GET MSG 'REFORMATTED)
      1;; We must be certain that the message isn't reformatted before we reparse.  Otherwise,
0      1;; if there are errors in the new parse, the message will be left in an inconsistent
0      1;; state.  (It's easier to unreformat first than try to look for the inconsistent state
0      1;; after the fact.)
0      (UNREFORMAT-HEADERS MSG))
    (SETF (MSG-STATUS MSG)
	  (SOME-PLIST (MSG-STATUS MSG) *INTERNAL-TYPE-PROPERTIES-WITHOUT-REFORMATTED*))
    (SETF (MSG-TICK MSG) (TICK))
    (SET-PARSED-MSG-HEADERS MSG))
  (WHEN (AND (VARIABLE-BOUNDP *MSG*)
	     (EQ MSG *MSG*))
    (COMPUTE-CURRENT-MSG-STATE)))

1;;; Header type definition and decoding.

0(DEFMACRO DEFINE-HEADER-TYPE-TYPE (NAME SUPERTYPES &BODY OPTIONS)
  `(DEFINE-HEADER-TYPE-TYPE-1 ',NAME ',SUPERTYPES ',(COPYLIST OPTIONS)))

(DEFPROP DEFINE-HEADER-TYPE-TYPE "Header type type" SI:DEFINITION-TYPE-NAME)

(DEFUN DEFINE-HEADER-TYPE-TYPE-1 (NAME SUPERTYPES OPTIONS)
  (WHEN (SI:RECORD-SOURCE-FILE-NAME NAME 'DEFINE-HEADER-TYPE-TYPE)
    (LET ((ELEM (ASSQ NAME *HEADER-TYPE-TYPE-ALIST*))
	  PARSE-FUNCTION PRINT-FUNCTION)
      (WHEN (NULL ELEM)
	(SETQ ELEM (MAKE-HEADER-TYPE-TYPE-ELEM NAME NAME)
	      *HEADER-TYPE-TYPE-ALIST* (NCONC *HEADER-TYPE-TYPE-ALIST* (NCONS ELEM))))
      (DOLIST (OPT OPTIONS)
	(SELECTQ (CAR OPT)
	  (:PARSE-FUNCTION (SETQ PARSE-FUNCTION (CADR OPT)))
	  (:PRINT-FUNCTION (SETQ PRINT-FUNCTION (CADR OPT)))
	  (OTHERWISE (FERROR "Unknown option type in ~S" OPT))))
      (SETF (HEADER-TYPE-TYPE-ELEM-TYPES ELEM)
	    (COPYLIST				;CDR code to make HEADER-TYPE-TYPEP faster
	      (CONS NAME
		    (SI:ELIMINATE-DUPLICATES
		      (LOOP FOR SUPTYP IN SUPERTYPES
			    AS SUPEL = (OR (ASSQ SUPTYP *HEADER-TYPE-TYPE-ALIST*)
					   (FERROR "Unknown super type ~S" SUPTYP))
			    APPEND (HEADER-TYPE-TYPE-ELEM-TYPES SUPEL)
			    WHEN (NULL PARSE-FUNCTION)
			      DO (SETQ PARSE-FUNCTION (HEADER-TYPE-TYPE-ELEM-PARSE-FUNCTION
							SUPEL))
			    WHEN (NULL PRINT-FUNCTION)
			      DO (SETQ PRINT-FUNCTION (HEADER-TYPE-TYPE-ELEM-PRINT-FUNCTION
							SUPEL)))))))
      (SETF (HEADER-TYPE-TYPE-ELEM-PARSE-FUNCTION ELEM) PARSE-FUNCTION)
      (SETF (HEADER-TYPE-TYPE-ELEM-PRINT-FUNCTION ELEM) PRINT-FUNCTION)
      (WHEN (NULL (SI:GET-SOURCE-FILE-NAME NAME 'DEFINE-HEADER-TYPE))
	(LET ((ELEM (ASSQ NAME *HEADER-TYPE-ALIST*)))
	  (WHEN ELEM
	    (SETQ *HEADER-TYPE-ALIST* (DELQ ELEM *HEADER-TYPE-ALIST*))))
	(REMPROP NAME 'SUPERTYPES)))))

(DEFMACRO DEFINE-HEADER-TYPE (NAME PRETTY-NAME TYPE-TYPE)
  `(DEFINE-HEADER-TYPE-1 ',NAME ',PRETTY-NAME ',TYPE-TYPE))

(DEFPROP DEFINE-HEADER-TYPE "Header type" SI:DEFINITION-TYPE-NAME)

(DEFUN DEFINE-HEADER-TYPE-1 (NAME PRETTY-NAME TYPE-TYPE &OPTIONAL FOR-DEFINE-HEADER-TYPE-TYPE)
  (WHEN (IF FOR-DEFINE-HEADER-TYPE-TYPE
	    1;; Don't record pseudo-definition on behalf of a header type type definition
	    ;; if it's already defined as a real header type.
0	    (NULL (SI:GET-SOURCE-FILE-NAME NAME 'DEFINE-HEADER-TYPE))
	    (SI:RECORD-SOURCE-FILE-NAME NAME 'DEFINE-HEADER-TYPE))
    (LET ((ELEM (ASSQ NAME *HEADER-TYPE-ALIST*)))
      (COND ((NULL ELEM)
	     (SETQ ELEM (MAKE-HEADER-TYPE-ELEM NAME NAME))
	     (SETQ *HEADER-TYPE-ALIST* (NCONC *HEADER-TYPE-ALIST* (NCONS ELEM)))))
      (SETF (HEADER-TYPE-ELEM-PRETTY-NAME ELEM) PRETTY-NAME)
      (SETF (CDDR ELEM)
	    (CDR (OR (ASSQ TYPE-TYPE *HEADER-TYPE-TYPE-ALIST*)
		     (FERROR "Unknown super type ~S" TYPE-TYPE))))
      (SETF (GET NAME 'SUPERTYPES) (REMQ NAME (HEADER-TYPE-ELEM-TYPES ELEM))))
    (IF (HEADER-TYPE-TYPEP NAME :FAT-STRING)
	(CL:PUSHNEW NAME *FONT-CONVERTED-HEADER-LINES*)
	(SETQ *FONT-CONVERTED-HEADER-LINES* (DELQ NAME *FONT-CONVERTED-HEADER-LINES*)))))

;;; Compatibility for old init files
(DEFUN CREATE-RECIPIENT-TYPE-HEADERS ()
  (SETQ *RECIPIENT-TYPE-HEADERS* (LOOP FOR ELEM IN *HEADER-TYPE-ALIST*
				       WHEN (MEMQ :RECIPIENT (HEADER-TYPE-ELEM-TYPES ELEM))
					 COLLECT (HEADER-TYPE-ELEM-NAME ELEM))))

(ADD-INITIALIZATION "Create *RECIPIENT-TYPE-HEADERS*" '(CREATE-RECIPIENT-TYPE-HEADERS) ()
		    '*ZMAIL-SYSTEM-INITIALIZATIONS*)

(DEFUN HEADER-NAME-TYPE (STRING &OPTIONAL (START 0) END (INTERN-IF-UNKNOWN T) &AUX ELEM)
  (IF (SETQ ELEM (LOOP FOR ELEM IN *HEADER-TYPE-ALIST*
		       WHEN (STRING-EQUAL (HEADER-TYPE-ELEM-PRETTY-NAME ELEM) STRING
					  0 START NIL END)
			 RETURN ELEM))
      (VALUES (HEADER-TYPE-ELEM-NAME ELEM) ELEM)
    (WHEN INTERN-IF-UNKNOWN
      (VALUES (INTERN (STRING-THIN (STRING-UPCASE (SUBSTRING STRING START END))
				   :REMOVE-BITS T)
		      SI:PKG-KEYWORD-PACKAGE)
	      NIL))))

;;; Standard header types
(DEFINE-HEADER-TYPE-TYPE :HEADER NIL
  (:PARSE-FUNCTION PARSE-NORMAL-HEADER)
  (:PRINT-FUNCTION PRINT-NORMAL-HEADER))

(DEFINE-HEADER-TYPE-TYPE :FAT-STRING (:HEADER)
  (:PARSE-FUNCTION PARSE-FAT-STRING-HEADER)
  (:PRINT-FUNCTION PRINT-FAT-STRING-HEADER))

(DEFINE-HEADER-TYPE-TYPE :ADDRESS (:HEADER)
  (:PARSE-FUNCTION PARSE-ADDRESS-HEADER)
  (:PRINT-FUNCTION PRINT-ADDRESS-HEADER))

(DEFINE-HEADER-TYPE-TYPE :SENDER-OR-RECIPIENT (:ADDRESS))

(DEFINE-HEADER-TYPE-TYPE :SENDER (:SENDER-OR-RECIPIENT))

(DEFINE-HEADER-TYPE-TYPE :RECIPIENT (:SENDER-OR-RECIPIENT))

(DEFINE-HEADER-TYPE-TYPE :DATE (:HEADER)
  (:PARSE-FUNCTION PARSE-DATE-HEADER)
  (:PRINT-FUNCTION PRINT-DATE-HEADER))

(DEFINE-HEADER-TYPE-TYPE :COMMA-SEPARATED (:HEADER)
  (:PARSE-FUNCTION PARSE-COMMA-SEPARATED-HEADER)
  (:PRINT-FUNCTION PRINT-COMMA-SEPARATED-HEADER))

(DEFINE-HEADER-TYPE-TYPE :COMMA-SEPARATED-KEYWORDS (:HEADER)
  (:PARSE-FUNCTION PARSE-COMMA-SEPARATED-KEYWORDS-HEADER)
  (:PRINT-FUNCTION PRINT-COMMA-SEPARATED-KEYWORDS-HEADER))

(DEFINE-HEADER-TYPE-TYPE :SINGLE-LINE (:HEADER)
  (:PARSE-FUNCTION PARSE-SINGLE-LINE-HEADER)
  (:PRINT-FUNCTION PRINT-SINGLE-LINE-HEADER))

(DEFINE-HEADER-TYPE-TYPE :SINGLE-KEYWORD (:HEADER)
  (:PARSE-FUNCTION PARSE-SINGLE-KEYWORD-HEADER)
  (:PRINT-FUNCTION PRINT-SINGLE-KEYWORD-HEADER))

(DEFINE-HEADER-TYPE-TYPE :REFERENCE (:HEADER)
  (:PARSE-FUNCTION PARSE-REFERENCE-HEADER)
  (:PRINT-FUNCTION PRINT-REFERENCE-HEADER))

;;; This is currently not parsed, things like FCC and BFCC.
(DEFINE-HEADER-TYPE-TYPE :FILE-RECIPIENT (:HEADER))

(DEFINE-HEADER-TYPE-TYPE :FILE-LIST (:HEADER)
  (:PARSE-FUNCTION PARSE-FILE-LIST-HEADER)
  (:PRINT-FUNCTION PRINT-FILE-LIST-HEADER))

(DEFINE-HEADER-TYPE-TYPE :RECEIVED (:HEADER)
  (:PARSE-FUNCTION PARSE-RECEIVED-HEADER)
  (:PRINT-FUNCTION PRINT-RECEIVED-HEADER))

(DEFINE-HEADER-TYPE-TYPE :MESSAGE-ID (:HEADER))

(DEFINE-HEADER-TYPE-TYPE :NUMBER (:HEADER)
  (:PARSE-FUNCTION PARSE-NUMBER-HEADER)
  (:PRINT-FUNCTION PRINT-NUMBER-HEADER))

(DEFINE-HEADER-TYPE-TYPE :INTEGER (:NUMBER)
  (:PARSE-FUNCTION PARSE-INTEGER-HEADER))

(DEFINE-HEADER-TYPE-TYPE :PRIORITY (:HEADER)
  (:PARSE-FUNCTION PARSE-PRIORITY-HEADER)
  (:PRINT-FUNCTION PRINT-PRIORITY-HEADER))

(DEFINE-HEADER-TYPE-TYPE :LISP (:HEADER)
  (:PARSE-FUNCTION PARSE-LISP-HEADER)
  (:PRINT-FUNCTION PRINT-LISP-HEADER))

(DEFINE-HEADER-TYPE-TYPE :DEFAULT-CHARACTER-STYLE (:LISP)
  (:PARSE-FUNCTION PARSE-DEFAULT-CHARACTER-STYLE-HEADER)
  (:PRINT-FUNCTION PRINT-DEFAULT-CHARACTER-STYLE-HEADER))

(DEFINE-HEADER-TYPE-TYPE :CHARACTER-TYPE-MAPPINGS (:LISP)
  (:PARSE-FUNCTION PARSE-CHARACTER-TYPE-MAPPINGS-HEADER))

(DEFINE-HEADER-TYPE-TYPE :JAPANESE (:INTEGER)
  (:PARSE-FUNCTION PARSE-JAPANESE-HEADER))

(DEFUN PARSE-JAPANESE-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE
    ,(CONDITION-CASE ()
	  (OR (PARSE-NUMBER START-LINE START-INDEX NIL 10. T) 24.)
	(SYS:READ-ERROR 24.))))


;;; The order here approximates frequency to cut down search times a little bit.
(DEFINE-HEADER-TYPE :DATE "Date" :DATE)
(DEFINE-HEADER-TYPE :FROM "From" :SENDER)
(DEFINE-HEADER-TYPE :SUBJECT "Subject" :FAT-STRING)
(DEFINE-HEADER-TYPE :TO "To" :RECIPIENT)
(DEFINE-HEADER-TYPE :CC "cc" :RECIPIENT)
(DEFINE-HEADER-TYPE :IN-REPLY-TO "In-Reply-To" :REFERENCE)
(DEFINE-HEADER-TYPE :MAIL-FROM "Mail-from" :HEADER)
(DEFINE-HEADER-TYPE :MESSAGE-ID "Message-ID" :MESSAGE-ID)
(DEFINE-HEADER-TYPE :SENDER "Sender" :SENDER)
(DEFINE-HEADER-TYPE :REPLY-TO "Reply-To" :SENDER)
(DEFINE-HEADER-TYPE :REDISTRIBUTED-BY "Redistributed-by" :SENDER)
(DEFINE-HEADER-TYPE :REDISTRIBUTED-DATE "Redistributed-date" :DATE)
(DEFINE-HEADER-TYPE :REDISTRIBUTED-TO "Redistributed-to" :RECIPIENT)
(DEFINE-HEADER-TYPE :REFERENCES "References" :REFERENCE)
(DEFINE-HEADER-TYPE :DRAFT-COMPOSITION-DATE "Draft-Composition-Date" :DATE)
(DEFINE-HEADER-TYPE :BCC "bcc" :RECIPIENT)
(DEFINE-HEADER-TYPE :EXPIRATION-DATE "Expiration-date" :DATE)
(DEFINE-HEADER-TYPE :FCC "Fcc" :FILE-RECIPIENT)
(DEFINE-HEADER-TYPE :BFCC "BFcc" :FILE-RECIPIENT)
(DEFINE-HEADER-TYPE :DEFAULT-CHARACTER-STYLE "Default-Character-Style"
					     :DEFAULT-CHARACTER-STYLE)
(DEFINE-HEADER-TYPE :CHARACTER-TYPE-MAPPINGS "Character-Type-Mappings"
					     :CHARACTER-TYPE-MAPPINGS)
(DEFINE-HEADER-TYPE :FONTS "Fonts" :COMMA-SEPARATED)
(DEFINE-HEADER-TYPE :KEYWORDS "Keywords" :COMMA-SEPARATED-KEYWORDS)
(DEFINE-HEADER-TYPE :REGARDING "Regarding" :REFERENCE)
(DEFINE-HEADER-TYPE :SUPERSEDES "Supersedes" :REFERENCE)
(DEFINE-HEADER-TYPE :REVOKES "Revokes" :REFERENCE)
(DEFINE-HEADER-TYPE :INCLUDED-REFERENCES "Included-References" :REFERENCE)
(DEFINE-HEADER-TYPE :INCLUDED-MSGS "Included-msgs" :REFERENCE)
(DEFPROP :INCLUDED-MSGS T :ID-REFERENCE)
(DEFINE-HEADER-TYPE :FORWARD-REFERENCES "Forward-References" :REFERENCE)
(DEFINE-HEADER-TYPE :BACKWARD-REFERENCES "Backward-References" :REFERENCE)
(DEFPROP :BACKWARD-REFERENCES T :ID-REFERENCE)
(DEFINE-HEADER-TYPE :FILE-REFERENCES "File-References" :FILE-LIST)
(DEFINE-HEADER-TYPE :RESENT-BCC "Resent-bcc" :RECIPIENT)
(DEFINE-HEADER-TYPE :RESENT-BY "Resent-by" :SENDER)
(DEFINE-HEADER-TYPE :RESENT-DATE "Resent-Date" :DATE)
(DEFINE-HEADER-TYPE :RESENT-CC "Resent-cc" :RECIPIENT)
(DEFINE-HEADER-TYPE :RESENT-FROM "Resent-From" :SENDER)
(DEFINE-HEADER-TYPE :RESENT-MESSAGE-ID "Resent-Message-ID" :MESSAGE-ID)
(DEFINE-HEADER-TYPE :RESENT-REPLY-TO "Resent-Reply-To" :SENDER)
(DEFINE-HEADER-TYPE :RESENT-SENDER "Resent-Sender" :SENDER)
(DEFINE-HEADER-TYPE :RESENT-TO "Resent-To" :RECIPIENT)
(DEFINE-HEADER-TYPE :RESENT-COMMENTS "Resent-Comments" :FAT-STRING)
(DEFPROP :RESENT-COMMENTS T 'MULTI-LINE-HEADER)
(DEFINE-HEADER-TYPE :REMAILED-FROM "Remailed-from" :SENDER)
(DEFINE-HEADER-TYPE :REMAILED-DATE "Remailed-date" :DATE)
(DEFINE-HEADER-TYPE :REMAILED-TO "Remailed-to" :RECIPIENT)
(DEFINE-HEADER-TYPE :REDIRECTED-BY "Redirected-by" :SENDER)
(DEFINE-HEADER-TYPE :REDIRECTED-DATE "Redirected-Date" :DATE)
(DEFINE-HEADER-TYPE :RECEIVED "Received" :RECEIVED)
(DEFINE-HEADER-TYPE :RECEIVED-DATE "Received-Date" :DATE)
(DEFINE-HEADER-TYPE :RETURN-PATH "Return-path" :ADDRESS)
(DEFINE-HEADER-TYPE :PRIORITY "Priority" :PRIORITY)
(DEFINE-HEADER-TYPE :ACKNOWLEDGE-TO "Acknowledge-To" :ADDRESS)
(DEFINE-HEADER-TYPE :COMMENTS "Comments" :FAT-STRING)
(DEFPROP :COMMENTS T 'MULTI-LINE-HEADER)
(DEFINE-HEADER-TYPE :DISPOSITION "Disposition" :SINGLE-KEYWORD)
(DEFINE-HEADER-TYPE :CATEGORY "Category" :HEADER)
(DEFINE-HEADER-TYPE :TEMPLATE-FOR-REPLY "Template-for-reply" :HEADER)
(DEFINE-HEADER-TYPE :APPARENTLY-TO "Apparently-To" :RECIPIENT) ; A Unix-damaged To: field.
(DEFINE-HEADER-TYPE :JAPANESE "Japanese" :JAPANESE)

;;; These headers should get converted most of the time
(DEFINE-HEADER-TYPE :RE "Re" :FAT-STRING)
(DEFINE-HEADER-TYPE :CHARACTER-STYLES "Character-Styles" :CHARACTER-TYPE-MAPPINGS)

;;;; Header printing

(DEFUN OUTPUT-HEADERS-AND-TEXT (STREAM TEMPLATE-EXPANSION)
  (OUTPUT-HEADERS STREAM TEMPLATE-EXPANSION T)
  (OUTPUT-TEXT STREAM TEMPLATE-EXPANSION))

(DEFUN OUTPUT-HEADERS (STREAM TEMPLATE-EXPANSION &OPTIONAL CR-AT-END)
  (LET ((HEADER-LIST (GET (LOCF TEMPLATE-EXPANSION) ':HEADERS)))
    (IF (EQ (GET (LOCF TEMPLATE-EXPANSION) ':HEADER-FORMAT) ':ITS)
	(OUTPUT-ITS-HEADER STREAM (LOCF HEADER-LIST))
	(LOOP FOR (IND HEADER) ON HEADER-LIST BY 'CDDR
	      DO (PRINT-HEADER STREAM HEADER IND TEMPLATE-EXPANSION))
	;; Blank line if requested
	(AND CR-AT-END (FUNCALL STREAM ':TYO #\CR)))))

(DEFUN OUTPUT-ITS-HEADER (STREAM PLIST &AUX TEM)
  (FUNCALL STREAM ':STRING-OUT (STRING-FROM-HEADER (CAR (GET PLIST ':FROM)) ':SHORT))
  (FUNCALL STREAM ':TYO #\SP)
  (COND ((SETQ TEM (GET PLIST ':SENDER))
	 (FUNCALL STREAM ':STRING-OUT "(Sent by ")
	 (FUNCALL STREAM ':STRING-OUT (STRING-FROM-HEADER (CAR TEM) ':SHORT))
	 (FUNCALL STREAM ':STRING-OUT ") ")))	 
  (LET ((TIME:*DATE-PRINTING-FORMAT* :MM//DD//YY))
    (TIME:PRINT-UNIVERSAL-TIME (GET PLIST ':DATE) STREAM))
  (COND ((SETQ TEM (GETL PLIST '(:SUBJECT)))
	 (FUNCALL STREAM ':STRING-OUT " Re: ")
	 (AND (CADR TEM)
	      (FUNCALL STREAM ':STRING-OUT (CADR TEM)))))
  (FUNCALL STREAM ':TYO #\CR)
  (OR (AND (NULL (GET PLIST ':CC))
	   (NULL (CDR (GET PLIST ':TO))))	;One or fewer recipients
      (LOOP FOR (IND . NAME) IN '((:TO . "To") (:CC . "CC"))
	    WITH RECIPIENTS
	    DO (AND (SETQ RECIPIENTS (GET PLIST IND))
		    (PRINT-ADDRESS-HEADER STREAM RECIPIENTS NAME '(:HEADER-FORMAT :SHORT)
					  177777)))))

(DEFINE-HEADER-TYPE-TYPE LITERAL-HEADERS NIL
  (:PRINT-FUNCTION PRINT-LITERAL-HEADERS))

(DEFINE-HEADER-TYPE LITERAL-HEADERS NIL LITERAL-HEADERS)

(DEFUN PRINT-LITERAL-HEADERS (STREAM INTERVAL &REST IGNORE)
  (STREAM-OUT-INTERVAL STREAM INTERVAL))
1;;; Support macro for header field printing functions --
;;;    (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")EXPLANATION
0(DEFMACRO PRINTING-HEADERS ((STREAM NAME VALUE &KEY (MAX-COLUMNS 72.)
						    (MULTIPLE-VALUES :SEPARATE-LINES)
						    (COMMA-SEPARATED NIL)
						    (PRINT-VALUE-P NIL)
						    (STRING-FROM-VALUE NIL))
			    &BODY BODY)
  (CL:CHECK-TYPE MULTIPLE-VALUES (CL:MEMBER :FILLED-LINES :SEPARATE-LINES :SEPARATE-FIELDS))
  (CL:CHECK-TYPE COMMA-SEPARATED SCL:BOOLEAN)
  (CL:ASSERT (OR (NEQ MULTIPLE-VALUES :SEPARATE-FIELDS) (NOT COMMA-SEPARATED)) NIL
	     ":MULTIPLE-VALUES :SEPARATE-FIELDS is incompatible with :COMMA-SEPARATED T.")
  `(PRINTING-HEADERS-INTERNAL ,STREAM ,NAME ,VALUE
			      ,MAX-COLUMNS ,MULTIPLE-VALUES ,COMMA-SEPARATED
			      ,STRING-FROM-VALUE ,PRINT-VALUE-P
     (LAMBDA (,STREAM ,NAME ,VALUE)
       (DECLARE (SYS:DOWNWARD-FUNCTION))
       (IGNORE ,STREAM ,NAME ,VALUE)		1;In case the body doesn't use it...
0       ,@BODY)))
(DEFUN PRINTING-HEADERS-INTERNAL (STREAM FIELD-NAME VALUES
				  MAX-COLUMNS MULTIPLE-VALUES COMMA-SEPARATED
				  STRING-FROM-VALUE-FUNCTION PRINT-VALUE-P-FUNCTION
				  PRINTING-CODE)
  (DECLARE (SYS:DOWNWARD-FUNARG STRING-FROM-VALUE-FUNCTION PRINT-VALUE-P-FUNCTION
				PRINTING-CODE))
  (LET ((FIELD-NAME-SIZE (+ (STRING-LENGTH FIELD-NAME) 2))
	(FIRST-FIELD T)
	AT-BEGINNING-OF-LINE NEXT-COLUMN)
    (LABELS ((PRINT-FIELD-NAME ()
	       (UNLESS FIRST-FIELD
		 (CL:WRITE-CHAR #\Return STREAM))
	       (FORMAT STREAM "~A: " FIELD-NAME)
	       (SETQ FIRST-FIELD NIL
		     AT-BEGINNING-OF-LINE T
		     NEXT-COLUMN FIELD-NAME-SIZE))
	     (DO-ONE-VALUE (VALUE)
	       (LET* ((PRINT-VALUE
			(IF PRINT-VALUE-P-FUNCTION (FUNCALL PRINT-VALUE-P-FUNCTION VALUE) T))
		      (VALUE
			(COND ((NOT PRINT-VALUE) NIL)
			      (STRING-FROM-VALUE-FUNCTION
			       (FUNCALL STRING-FROM-VALUE-FUNCTION VALUE))
			      (T VALUE)))
		      (VALUE-SIZE
			(COND ((NOT PRINT-VALUE) 0)
			      ((EQ MULTIPLE-VALUES :FILLED-LINES) (STRING-LENGTH VALUE))
			      (T MAX-COLUMNS))))
		 (WHEN (OR FIRST-FIELD (EQ MULTIPLE-VALUES :SEPARATE-FIELDS))
		   (PRINT-FIELD-NAME))
		 (WHEN PRINT-VALUE
		   (UNLESS AT-BEGINNING-OF-LINE
		     (WHEN COMMA-SEPARATED
		       (CL:WRITE-CHAR #\, STREAM))
		     (WHEN (> (+ NEXT-COLUMN 2) MAX-COLUMNS)
		       (FORMAT STREAM "~%~V@T" FIELD-NAME-SIZE)
		       (SETQ AT-BEGINNING-OF-LINE T
			     NEXT-COLUMN FIELD-NAME-SIZE))
		     (UNLESS AT-BEGINNING-OF-LINE 
		       (CL:WRITE-CHAR #\Space STREAM)
		       (INCF NEXT-COLUMN  2)))
		   (FUNCALL PRINTING-CODE STREAM FIELD-NAME VALUE)
		   (SETQ NEXT-COLUMN (+ NEXT-COLUMN VALUE-SIZE)
			 AT-BEGINNING-OF-LINE NIL)))))
      (COND ((NULL VALUES)
	     (PRINT-FIELD-NAME))
	    ((LISTP VALUES)
	     (DOLIST (VALUE VALUES)
	       (DO-ONE-VALUE VALUE)))
	    (T
	     (DO-ONE-VALUE VALUES)))
      (CL:WRITE-CHAR #\Return STREAM))))

(DEFUN PRINT-HEADER (STREAM HEADER TYPE EXPANSION &OPTIONAL (MAX-COL 72.)
						  &AUX ELEM NAME FUNCTION)
  (IF (SETQ ELEM (ASSQ TYPE *HEADER-TYPE-ALIST*))
      (SETQ NAME (HEADER-TYPE-ELEM-PRETTY-NAME ELEM)
	    FUNCTION (OR (HEADER-TYPE-ELEM-PRINT-FUNCTION ELEM) #'PRINT-NORMAL-HEADER))
      (SETQ NAME (STRING TYPE)
	    FUNCTION #'PRINT-NORMAL-HEADER))
  (FUNCALL FUNCTION STREAM HEADER NAME EXPANSION MAX-COL))

(DEFUN PRINT-NORMAL-HEADER (STREAM VALUE NAME IGNORE IGNORE)
  (WHEN (AND (STRINGP VALUE) (STRING-SEARCH-CHAR #\CR VALUE))
    1;; Turn a multi-line header into multiple lines so that indentation is canonicalized.
0    (SETQ VALUE (PARSE-COMMA-SEPARATED VALUE 0 "
"
				       )))
  (PRINTING-HEADERS (STREAM NAME VALUE)
    (CL:WRITE-STRING VALUE STREAM)))

(DEFUN PRINT-FAT-STRING-HEADER (STREAM VALUE NAME IGNORE IGNORE)
  (WHEN (AND (STRINGP VALUE) (STRING-SEARCH-CHAR #\CR VALUE))
    1;; Turn a multi-line header into multiple lines so that indentation is canonicalized.
0    (SETQ VALUE (PARSE-COMMA-SEPARATED VALUE 0 "
"
				       )))
  1;; This implementation isn't quite perfect --
0  1;;    We really don't need to reset the type to zero after each line of the field.
0  1;;    However, I didn't want to add another option to 2printing-headers 1which would
0  1;;    only be used by this function.
0  (PRINTING-HEADERS (STREAM NAME VALUE)
    (CL:WRITE-STRING VALUE STREAM)
    (SEND-IF-HANDLES STREAM :BACK-TO-TYPE-ZERO)))

(DEFUN PRINT-COMMA-SEPARATED-HEADER (STREAM VALUE NAME IGNORE MAX-COLUMNS)
  (PRINTING-HEADERS (STREAM NAME VALUE :MAX-COLUMNS MAX-COLUMNS
				       :MULTIPLE-VALUES :FILLED-LINES
				       :COMMA-SEPARATED T)
    (CL:WRITE-STRING VALUE STREAM)))

(DEFUN PRINT-COMMA-SEPARATED-KEYWORDS-HEADER (STREAM VALUE NAME IGNORE MAX-COLUMNS)
  (LET ((HEADER-TYPE (INTERN (STRING-UPCASE NAME) PKG-KEYWORD-PACKAGE)))
    (FLET ((KEYWORD-STRING (KEYWORD)
	     (DECLARE (SYS:DOWNWARD-FUNCTION))
	     (LET ((BUCKET (ASSQ HEADER-TYPE (GET KEYWORD 'KEYWORD-STRING))))
	       (OR (SECOND BUCKET) (STRING KEYWORD)))))
      (PRINTING-HEADERS (STREAM NAME VALUE :MAX-COLUMNS MAX-COLUMNS
					   :MULTIPLE-VALUES :FILLED-LINES
					   :COMMA-SEPARATED T
					   :STRING-FROM-VALUE #'KEYWORD-STRING)
	1;; 2printing-headers 1macro will invoke our printer with the already converted keyword.
0	(CL:WRITE-STRING VALUE STREAM)))))

(DEFUN PRINT-FILE-LIST-HEADER (STREAM VALUE NAME IGNORE MAX-COLUMNS)
  (FLET ((PATHNAME-STRING (X) (IF (CL:PATHNAMEP X) (FULLY-QUALIFIED-PATHNAME-STRING X) X)))
    (PRINTING-HEADERS (STREAM NAME VALUE :MAX-COLUMNS MAX-COLUMNS
					 :MULTIPLE-VALUES :FILLED-LINES
					 :COMMA-SEPARATED T
					 :STRING-FROM-VALUE #'PATHNAME-STRING)
      1;; 2printing-headers 1macro will invoke our printer with the already converted pathname.
0      (CL:WRITE-STRING VALUE STREAM))))

(DEFUN PRINT-SINGLE-LINE-HEADER (STREAM VALUE NAME IGNORE IGNORE)
  (PRINTING-HEADERS (STREAM NAME VALUE :COMMA-SEPARATED T)
    (CL:WRITE-STRING VALUE STREAM)))

(DEFUN PRINT-RECEIVED-HEADER (STREAM VALUE NAME IGNORE IGNORE)
  (LET ((FIELD-NAME-SIZE (+ (STRING-LENGTH NAME) 2)))
    (PRINTING-HEADERS (STREAM NAME VALUE :MULTIPLE-VALUES :SEPARATE-FIELDS)
      (LOOP FOR STRING IN VALUE
	    AS FIRST-TIME = T THEN NIL
	    DO (FORMAT STREAM "~:[~&~V@T~;~*~]~A" FIRST-TIME FIELD-NAME-SIZE STRING)))))

(DEFUN PRETTY-PRINT-RECEIVED-HEADERS (RECEIVED-HEADERS &OPTIONAL (STREAM STANDARD-OUTPUT))
  (LET* ((RECEIVED-HEADERS (REVERSE RECEIVED-HEADERS))
	 (N-RECEIVED-HEADERS (LENGTH RECEIVED-HEADERS)))
    (MACROLET ((RD-FROM (I) `(AREF RECEIVED-DATA (+ (* I 5) 0)))
	       (RD-WITH (I) `(AREF RECEIVED-DATA (+ (* I 5) 1)))
	       (RD-BY (I) `(AREF RECEIVED-DATA (+ (* I 5) 2)))
	       (RD-DATE (I) `(AREF RECEIVED-DATA (+ (* I 5) 3)))
	       (RD-CURRENT-DATE (I) `(AREF RECEIVED-DATA (+ (* I 5) 4))))
      1;; 2dw:formatting-table1 makes multiple passes through our code so we have to build
0      1;; the data that we'll need ahead of time to avoid strange behavior when values are
0      1;; unexpectedly reset to their initial state.
0      (SYS:WITH-STACK-ARRAY (RECEIVED-DATA (* N-RECEIVED-HEADERS 5))
	(LET ((CURRENT-LOCATION :UNKNOWN)
	      (CURRENT-DATE 0))
	  (DOTIMES (I N-RECEIVED-HEADERS)
	    (LET ((RECEIVED (NTH I RECEIVED-HEADERS)))
	      (CL:SETF (RD-FROM I) (CL:GETF RECEIVED :FROM)
		       (RD-WITH I) (OR (CL:GETF RECEIVED :WITH) (CL:GETF RECEIVED :VIA))
		       (RD-BY I) (CL:GETF RECEIVED :BY)
		       (RD-DATE I) (CL:GETF RECEIVED :DATE)
		       (RD-CURRENT-DATE I) CURRENT-DATE)
	      (IF (EQUAL (RD-FROM I) CURRENT-LOCATION)
		  (SETF (RD-FROM I) :SAME)
		  (SETF CURRENT-LOCATION (RD-FROM I)))
	      (IF (EQUAL (RD-BY I) CURRENT-LOCATION)
		  (SETF (RD-BY I) :SAME)
		  (SETF CURRENT-LOCATION (RD-BY I)))
	      (WHEN (NUMBERP (RD-DATE I))
		(SETF CURRENT-DATE (RD-DATE I)))))
	  (CL:FRESH-LINE STREAM)
	  (DW:FORMATTING-TABLE (STREAM)
	    (DOTIMES (I N-RECEIVED-HEADERS)
	      (DW:FORMATTING-ROW (STREAM)
		(DW:FORMATTING-CELL (STREAM)
		  (UNLESS (EQ (RD-FROM I) :SAME)
		    (PRETTY-PRINT-RECEIVED-HEADERS-HOST (RD-FROM I) STREAM)))
		(DW:FORMATTING-CELL (STREAM)
		  (FORMAT STREAM "~:[=>~;>~A>~]" (RD-WITH I) (RD-WITH I)))
		(DW:FORMATTING-CELL (STREAM)
		  (UNLESS (EQ (RD-BY I) :SAME)
		    (PRETTY-PRINT-RECEIVED-HEADERS-HOST (RD-BY I) STREAM)))
		(DW:FORMATTING-CELL (STREAM)
		  (WHEN (NUMBERP (RD-DATE I))
		    (FORMAT STREAM "(~A)"
			    (WITH-OUTPUT-TO-STRING (S)
			      (IF (ZEROP (RD-CURRENT-DATE I))
				  (TIME:PRINT-UNIVERSAL-TIME (RD-DATE I) S)
				  (TIME:PRINT-BRIEF-UNIVERSAL-TIME (RD-DATE I) S
								   (RD-CURRENT-DATE I))))))))))
	  )))))

(DEFUN PRETTY-PRINT-RECEIVED-HEADERS-HOST (HOST STREAM)
  (SELECTQ (FIRST HOST)
    ((:OBJECT :SINGLE)
     (FORMAT STREAM "~A" (SECOND HOST)))
    (:DOMAIN
     (FORMAT STREAM "~A~{.~A~}" (SECOND HOST) (REST2 HOST)))
    (OTHERWISE
     (FORMAT STREAM "?"))))

(DEFUN PRINT-DATE-HEADER (STREAM DATE NAME EXPANSION IGNORE)
  (LET* ((PLIST (LOCF EXPANSION))
	 (DATE-FORMAT (GET PLIST :DATE-FORMAT))
	 (FORCE-NUMERIC-TIMEZONE (GET PLIST :FORCE-NUMERIC-TIMEZONE)))
    (PRINTING-HEADERS (STREAM NAME DATE :MULTIPLE-VALUES :SEPARATE-FIELDS)
      (PRINT-DATE DATE STREAM DATE-FORMAT T T FORCE-NUMERIC-TIMEZONE))))

(DEFUN PRINT-DATE (DATE STREAM FORMAT &OPTIONAL (INCLUDE-TIME T) (INCLUDE-DOW T)
						(FORCE-NUMERIC-TIMEZONE T) INCLUDE-SECONDS)
  (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR
			DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P TIMEZONE)
      1;; 2cl:decode-universal-time1 always returns the absolute year...
0      (CL:DECODE-UNIVERSAL-TIME DATE)
    ;; Don't punctuate: to suppress addition of whitespace before timezone names.
    ;; ENCODE-NUMERIC-TIMEZONE (called by TIMEZONE-STRING) will put the sign in for numeric
    ;; timezones anyway.  The whitespace will be inserted by the FORMAT strings below.
    (LET ((TIMEZONE-STRING (TIME:TIMEZONE-STRING TIMEZONE DAYLIGHT-SAVINGS-P
						 FORCE-NUMERIC-TIMEZONE NIL)))
      (SELECTQ FORMAT
	(:ENGLISH
	 (FORMAT STREAM "~\DATE\ ~A" DATE TIMEZONE-STRING))
	(:CONCISE
	 1;; Concise? -- This format is 3longer1 than the other format.
0	 (FORMAT STREAM "~:[~*~;~A, ~]~D ~A ~D~:[~;, ~2,'0D:~2,'0D ~A~]"
		 INCLUDE-DOW (TIME:DAY-OF-THE-WEEK-STRING DAY-OF-THE-WEEK)
		 DAY (TIME:MONTH-STRING MONTH) YEAR
		 INCLUDE-TIME HOURS MINUTES TIMEZONE-STRING))
	(OTHERWISE
	 (FORMAT STREAM "~:[~*~;~A, ~]~D ~A ~D~:[~; ~2,'0D:~2,'0D~:[~*~;:~2,'0D~] ~A~]"
		 INCLUDE-DOW (TIME:DAY-OF-THE-WEEK-STRING DAY-OF-THE-WEEK :SHORT)
		 DAY (TIME:MONTH-STRING MONTH :SHORT) YEAR
		 INCLUDE-TIME HOURS MINUTES INCLUDE-SECONDS SECONDS TIMEZONE-STRING))))))

(DEFUN PRINT-ADDRESS-HEADER (STREAM ADDRESS NAME EXPANSION MAX-COLUMNS)
  (LET ((FORMAT (CL:GETF EXPANSION :HEADER-FORMAT))
	INFERIORS)
    (LABELS ((PRINT-ADDRESS-P (ADDRESS)
	       (UNLESS (MEMQ ADDRESS INFERIORS)
		 (SETQ INFERIORS (APPEND INFERIORS (CL:GETF ADDRESS :INFERIORS)))
		 T))
	     (ADDRESS-STRING (ADDRESS)
	       (STRING-FROM-HEADER ADDRESS FORMAT)))
      (PRINTING-HEADERS (STREAM NAME ADDRESS :MAX-COLUMNS MAX-COLUMNS
					     :MULTIPLE-VALUES :FILLED-LINES
					     :COMMA-SEPARATED T
					     :PRINT-VALUE-P #'PRINT-ADDRESS-P
					     :STRING-FROM-VALUE #'ADDRESS-STRING)
	1;; 2printing-headers 1macro will invoke our printer with the already converted address.
0	(CL:WRITE-STRING ADDRESS STREAM)))))

(DEFUN PRINT-NUMBER-HEADER (STREAM NUMBER NAME IGNORE IGNORE)
  (PRINTING-HEADERS (STREAM NAME NUMBER :MULTIPLE-VALUES :SEPARATE-FIELDS)
    (FORMAT STREAM "~D" NUMBER)))

(DEFUN PRINT-PRIORITY-HEADER (STREAM PRIORITY NAME IGNORE IGNORE)
  (PRINTING-HEADERS (STREAM NAME PRIORITY :MULTIPLE-VALUES :SEPARATE-FIELDS)
    (FORMAT STREAM "~A" (OR (SECOND (ASSQ PRIORITY *PRIORITY-NAMES*)) PRIORITY))))

(DEFUN PRINT-LISP-HEADER (STREAM OBJECT NAME IGNORE IGNORE)
  (PRINTING-HEADERS (STREAM NAME OBJECT)
    (SCL:WITH-STANDARD-IO-ENVIRONMENT
      (CL:PRIN1 OBJECT STREAM))))

(DEFUN PRINT-DEFAULT-CHARACTER-STYLE-HEADER (STREAM DEFAULT-STYLE NAME IGNORE IGNORE)
  (PRINTING-HEADERS (STREAM NAME DEFAULT-STYLE :MULTIPLE-VALUES :SEPARATE-FIELDS)
    (SCL:WITH-STANDARD-IO-ENVIRONMENT
      (CL:PRIN1 (SI:UNPARSE-CHARACTER-STYLE DEFAULT-STYLE) STREAM))))

;;; T => Generate full domain names when constructing address strings.
;;; NIL => Remove trailing portion of domain names in common with the local host.
;;;    See 2compute-common-tail0 below for more details.
(DEFVAR-RESETTABLE *RETAIN-COMMON-TAILS* T)

3;;; Document acceptable FORMATs?
0(DEFUN STRING-FROM-HEADER (HEADER FORMAT &AUX (PLIST (LOCF HEADER)) TEM)
  (COND ((AND (EQ FORMAT :USE-ORIGINAL)
	      (SETQ TEM (OR (GET PLIST :ORIGINAL-STRING) (GET PLIST :INTERVAL))))
	 (IF (STRINGP TEM)
	     TEM
	   (STRING-INTERVAL (FIRST TEM) (SECOND TEM) T)))
	((SETQ TEM (GETL PLIST '(:INFERIORS)))
	 (IF (NULL (SECOND TEM))
	     (OR (GET PLIST :ORIGINAL-STRING)
		 (LET ((INTERVAL (GET PLIST :INTERVAL)))
		   (STRING-INTERVAL (FIRST INTERVAL) (SECOND INTERVAL) T)))
	   (IF (GET PLIST :FINAL-STRING)
	       (LOOP WITH STR = (MAKE-EMPTY-STRING 20.)
		     FOR INF IN (CADR TEM)
		     FOR INTSTR = (GET (LOCF INF) :INITIAL-STRING)
		     DO (SETQ STR (STRING-NCONC STR INTSTR))
			(LET ((SUBHEAD (STRING-FROM-HEADER INF FORMAT)))
			  (WHEN SUBHEAD
			    (SETQ STR (STRING-NCONC STR SUBHEAD))))
		     FINALLY (RETURN (STRING-NCONC STR (GET PLIST :FINAL-STRING))))
	     (LOOP WITH STR = (MAKE-EMPTY-STRING 20.)
		   WITH (SUP-START SUP-END) = (CADR (GETL PLIST
							  '(:INTERVAL :ORIGINAL-INTERVAL)))
		   FOR START FIRST SUP-START THEN (SECOND INF-INT)
		   FOR INF IN (CADR TEM)
		   AS INF-INT = (CADR (GETL (LOCF INF) '(:INTERVAL :ORIGINAL-INTERVAL)))
		   DO (SETQ STR (STRING-NCONC STR (STRING-INTERVAL START (FIRST INF-INT))))
		      (LET ((SUBHEAD (STRING-FROM-HEADER INF FORMAT)))
			(WHEN SUBHEAD
			  (SETQ STR (STRING-NCONC STR SUBHEAD))))
		   FINALLY (RETURN (STRING-NCONC STR (STRING-INTERVAL START SUP-END)))))))
	(T
	 (LET* ((USER (GET PLIST :USER))
		(STRING (GET PLIST :NAME))
		(ROUTE-SPEC (GET PLIST :ROUTE))
		(PERSONAL-NAME (IF USER
				   (SEND USER :PERSONAL-NAME-FIRST-NAME-FIRST)
				 (GET PLIST :PERSONAL-NAME))))
	   (WHEN (OR USER STRING)
	     (LET ((HOST (GET PLIST :HOST)))
	       (WHEN (NOT (NULL USER))
		 (SETF `(,STRING ,HOST) (SEND USER :MAIL-ADDRESS))
		 (SETQ HOST `(:OBJECT ,HOST)))
	       (WHEN (STRING-EQUAL STRING "")
		 1;; Null string isn't allowed.
0		 (SETQ STRING "<Unknown>"))	1;This string will generate some extra quoting.
0	       (SETQ STRING (RFC822-QUOTE-IF-NECESSARY STRING))
	       (WHEN (AND (EQ FORMAT :LOCAL-DEFAULT-HOST)
			  (GET PLIST :HOST-DEFAULTED))
		 (SETQ HOST NIL))
	       (WHEN HOST
		 (LET-IF (NOT (NULL ROUTE-SPEC))
			 ((*RETAIN-COMMON-TAILS* T))
		   (UNLESS (AND (EQ (FIRST HOST) :OBJECT)
				(EQ FORMAT :ONLY-PERSONAL)
				(SUMMARY-SUPPRESS-HOST-P (SECOND HOST)))
		     (SETQ STRING (STRING-APPEND STRING #/@
						 (STRING-FROM-HOST HOST FORMAT)))))))
	     (WHEN (OR ROUTE-SPEC
		       (EQ FORMAT :ROUTE)
		       (AND PERSONAL-NAME
			    (MEMQ FORMAT '(:USE-ORIGINAL :INCLUDE-PERSONAL :ONLY-PERSONAL))))
	       (WHEN ROUTE-SPEC
		 (SETQ STRING (STRING-APPEND (ROUTE-SPEC-STRING ROUTE-SPEC FORMAT) STRING)))
	       (SETQ STRING (STRING-APPEND #/< STRING #/>))
	       (WHEN (AND PERSONAL-NAME
			  (MEMQ FORMAT '(:USE-ORIGINAL :INCLUDE-PERSONAL :ONLY-PERSONAL)))
		 (IF (EQ FORMAT :ONLY-PERSONAL)
		     (SETQ STRING PERSONAL-NAME)
		   (SETQ PERSONAL-NAME (RFC822-QUOTE-IF-NECESSARY PERSONAL-NAME))
		   (SETQ STRING (STRING-APPEND PERSONAL-NAME #\SP STRING)))))
	     STRING)))))

(DEFUN RFC822-QUOTE-IF-NECESSARY (STRING)
  (IF (STRING-SEARCH-SET "()<>@,;:\/"[]" STRING)
      (WITH-OUTPUT-TO-STRING (S)
	(SEND S :TYO #/")
	(LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF STRING
	      WHEN (MEM #'CHAR-EQUAL CHAR '(#/" #/\))
		DO (SEND S :TYO #/\)
	      DO (SEND S :TYO CHAR))
	(SEND S :TYO #/"))
      STRING))

(DEFUN STRING-FROM-HOST (HOST FORMAT)
  (LABELS ((RETAIN-COMMON-TAILS ()
	     (OR *RETAIN-COMMON-TAILS*
		 (MEMQ FORMAT
		       '(:USE-ORIGINAL :HOST :LOCAL-DEFAULT-HOST :RETAIN-COMMON-TAILS))))
	   (MAYBE-TRIM-TAIL-FROM-STRING (STRING)
	     (IF (RETAIN-COMMON-TAILS)
		 STRING
		 (LOOP FOR TAIL-ELEMENT IN *LOCAL-COMMON-TAIL*
		       WITH LAST = (STRING-LENGTH STRING)
		       AS NEXT = (STRING-REVERSE-SEARCH-CHAR #/. STRING (1- LAST))
		       WHILE (AND NEXT (STRING-EQUAL STRING TAIL-ELEMENT (1+ NEXT) 0 LAST))
		       DO (SETQ LAST NEXT)
		       FINALLY
			 (RETURN (IF (= LAST (STRING-LENGTH STRING)) STRING
				   (NSUBSTRING STRING 0 LAST)))))))
    (CL:ECASE (FIRST HOST)
      (:OBJECT
	(MAYBE-TRIM-TAIL-FROM-STRING (SEND (SECOND HOST) :MAIL-NAME)))
      (:SINGLE
	(MAYBE-TRIM-TAIL-FROM-STRING (SECOND HOST)))
      (:DOMAIN
	(LET ((DOMAIN (IF (RETAIN-COMMON-TAILS)
			  (CL:REST HOST)
			  (LOOP FOR REVERSED-DOMAIN ON (REVERSE (CL:REST HOST))
				FOR TAIL-ELEMENT IN *LOCAL-COMMON-TAIL*
				WHILE (STRING-EQUAL TAIL-ELEMENT (FIRST REVERSED-DOMAIN))
				FINALLY
				  (RETURN (IF REVERSED-DOMAIN (REVERSE REVERSED-DOMAIN)
					    (LIST (SECOND HOST))))))))
	  (WITH-OUTPUT-TO-STRING (STREAM)
	    (LOOP FOR DOMAIN-ELEMENT IN DOMAIN
		  FOR FIRST = T THEN NIL
		  UNLESS FIRST
		    DO (CL:WRITE-CHAR #/. STREAM)
		  DO (CL:WRITE-STRING DOMAIN-ELEMENT STREAM)))))
      (:PATH
	(WITH-OUTPUT-TO-STRING (STREAM)
	  (LOOP FOR (PATH-ELEMENT . REST-OF-PATH) ON (CL:REST HOST)
		FOR FIRST = T THEN NIL
		UNLESS FIRST
		  DO (CL:WRITE-CHAR #\@ STREAM)
		DO (LET-IF (NOT (NULL REST-OF-PATH))
			   ((*RETAIN-COMMON-TAILS* T))
		     (CL:WRITE-STRING (IF (STRINGP PATH-ELEMENT)
					  (MAYBE-TRIM-TAIL-FROM-STRING PATH-ELEMENT)
					  (STRING-FROM-HOST PATH-ELEMENT FORMAT))
				      STREAM))))))))

(DEFUN ROUTE-SPEC-STRING (ROUTE-SPEC FORMAT)
  (WITH-OUTPUT-TO-STRING (STREAM)
    (LOOP FOR DOMAIN IN ROUTE-SPEC
	  FOR FIRST = T THEN NIL
	  UNLESS FIRST
	    DO (CL:WRITE-CHAR #/, STREAM)
	  DO (CL:WRITE-CHAR #/@ STREAM)
	     (LET-IF (NOT FIRST)
		     ((*RETAIN-COMMON-TAILS* T))
	       (CL:WRITE-STRING (STRING-FROM-HOST DOMAIN FORMAT) STREAM)))
    (CL:WRITE-CHAR #/: STREAM)))


;;; The "local common tail" is, actually, the name of the domain containing the local host
;;;
;;;   This value is used by TRIM-DOMAIN-COMMON-TAIL to remove the trailing domains in common
;;;   between the local host and a given host.
;;;
;;;   For example, if the local host is "Larry-Bird.SCRC.Symbolics.COM", the local common tail
;;;   will be ("COM" "Symbolics" "SCRC").  If TRIM-DOMAIN-COMMON-TAIL is then given the host
;;;   name "RUSSIAN.SPA.Symbolics.COM", it will return "RUSSIAN.SPA".
;;;
;;;   By its definition, the local common tail must be updated whenever the definition of the
;;;   local host is changed.  There, NET:LOCAL-NAME-INITIALIZATION-LIST is the proper
;;;   initialization list.
(DEFUN COMPUTE-LOCAL-TAIL ()
  (LET* ((SITE-OF-LOCAL-HOST (SEND NET:*LOCAL-HOST* :SITE))
	 (LOCAL-NAMESPACE
	   (WHEN SITE-OF-LOCAL-HOST (SEND SITE-OF-LOCAL-HOST :LOCAL-NAMESPACE)))
	 (COMMON-TAIL-STRING
	   (WHEN LOCAL-NAMESPACE (SEND LOCAL-NAMESPACE :INTERNET-DOMAIN-NAME))))
    (WHEN COMMON-TAIL-STRING
      (SETQ *LOCAL-COMMON-TAIL*
	    (LOOP FOR START = -1 THEN DOT
		  WHILE START
		  AS DOT = (STRING-SEARCH-CHAR #/. COMMON-TAIL-STRING (1+ START))
		  COLLECT (SUBSTRING COMMON-TAIL-STRING (1+ START) DOT) INTO COMMON-TAIL
		  FINALLY (RETURN (NREVERSE COMMON-TAIL)))))))

(ADD-INITIALIZATION "Compute ZWEI:*LOCAL-COMMON-TAIL*"
		    '(COMPUTE-LOCAL-TAIL)
		    '(:NOW) 'NET:LOCAL-NAME-INITIALIZATION-LIST)

(DEFVAR *HANDLE-REFERENCES-LITERALLY* NIL)

(DEFUN PRINT-REFERENCE-HEADER (STREAM REFERENCE NAME EXPANSION IGNORE)
  (PRINTING-HEADERS (STREAM NAME REFERENCE :COMMA-SEPARATED T)
    (PRINT-REFERENCE REFERENCE STREAM T (GET (LOCF EXPANSION) :FORCE-NUMERIC-TIMEZONE))))

(DEFUN PRINT-REFERENCE (REFERENCE STREAM &OPTIONAL (VERBOSE T) FORCE-NUMERIC-TIMEZONE)
  (DECLARE (SPECIAL *REFERENCE-ID-DUMMY-DATE*))
  (COND ((STRINGP REFERENCE)
	 (CL:WRITE-STRING REFERENCE STREAM))
	((CL:GETF REFERENCE :MESSAGE-ID)
	 (LET ((ID (CL:GETF REFERENCE :MESSAGE-ID)))
	   (IF (LISTP ID)
	       1;; Multi-line ID -- Just write the first line.
0	       (CL:WRITE-STRING (FIRST ID) STREAM)
	     (CL:WRITE-STRING ID STREAM))))
	(T
	 (LET* ((RAW-DATE (CL:GETF REFERENCE :DATE))
		(FIRST-DATE
		  (IF (LISTP RAW-DATE) (LOOP FOR DATE IN RAW-DATE MINIMIZE DATE) RAW-DATE))
		(DATE
		  (WHEN (AND FIRST-DATE (> FIRST-DATE *REFERENCE-ID-DUMMY-DATE*)) FIRST-DATE))
		(RAW-FROM (CL:GETF REFERENCE :FROM))
		(FROM
		  (COND ((EQUAL RAW-FROM '((:NAME "MISSING-FROM-FIELD"))) NIL)
			((STRING-FROM-HEADER RAW-FROM (IF VERBOSE :INCLUDE-PERSONAL :SHORT)))
			(T (CL:GETF RAW-FROM :PERSONAL-NAME)))))
	   (WHEN VERBOSE
	     (CL:WRITE-STRING (IF FROM "The " "Your ") STREAM))
	   (CL:WRITE-STRING "message" STREAM)
	   (WHEN DATE
	     (CL:WRITE-STRING " of " STREAM)
	     (PRINT-DATE DATE STREAM :NORMAL T NIL FORCE-NUMERIC-TIMEZONE))
	   (WHEN FROM
	     (FORMAT STREAM " from ~A" FROM))))))

(DEFUN OUTPUT-TEXT (STREAM TEMPLATE-EXPANSION)
  (LET ((TEXT (GET (LOCF TEMPLATE-EXPANSION) ':TEXT)))
    (COND ((NULL TEXT))
	  ((TYPEP TEXT 'INTERVAL)
	   (STREAM-OUT-INTERVAL STREAM TEXT NIL T))
	  (T
	   (SEND STREAM ':STRING-OUT TEXT)))))

(DEFUN PRINT-SINGLE-KEYWORD-HEADER (STREAM KEYWORD NAME IGNORE IGNORE)
  (PRINTING-HEADERS (STREAM NAME KEYWORD :MULTIPLE-VALUES :SEPARATE-FIELDS)
    (FORMAT STREAM "~A" KEYWORD)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REFORMAT-HEADERS
				"Reformat the headers of this message.
If given an argument, restore the original headers."
				(NUMERIC-ARG-OK)
  (ZMAIL-UNDO-SAVE 'UNDO-REFORMAT ':MSG *MSG*)
  (IF (NOT *NUMERIC-ARG-P*)
      (REFORMAT-HEADERS *MSG* T)
      (UNREFORMAT-HEADERS *MSG*))
  (RECENTER-WINDOW *WINDOW* ':START (MSG-START-BP *MSG*))
  DIS-TEXT)

(DEFPROP COM-ZMAIL-REFORMAT-HEADERS COM-ZMAIL-REFORMAT-ALL ASSOCIATED-ALL-COMMAND)

(DEFPROP COM-ZMAIL-REFORMAT-ALL
	 "Reformat the headers of these messages."
	 :WHO-LINE-DOCUMENTATION)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REFORMAT-ALL "Reformat all these messages.
The headers of each messages are reformatted according to the default reformat template." ()
  (CHECK-FOR-TOO-MANY-MSGS "reformat")
  (LET ((ARRAY (SEND *SEQUENCE* :ARRAY)))
    (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE-REFORMAT)
      (LOOP FOR MSG BEING THE ARRAY-ELEMENTS OF ARRAY
	    DO (SEND *CURRENT-UNDO* :SAVE-MULTIPLE-UNDO :MSG MSG)
	       (REFORMAT-HEADERS MSG T)))
    (RECENTER-WINDOW *WINDOW* :START (MSG-START-BP *MSG*)))
  DIS-TEXT)

(DEFPROP COM-ZMAIL-UNREFORMAT-ALL
	 "Reset the headers of these messages to their orignal contents."
	 :WHO-LINE-DOCUMENTATION)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-UNREFORMAT-ALL "Unreformat all these messages.
The headers of each messages are reset to their original contents." ()
  (CHECK-FOR-TOO-MANY-MSGS "unreformat")
  (LET ((ARRAY (SEND *SEQUENCE* :ARRAY)))
    (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE-REFORMAT)
      (LOOP FOR MSG BEING THE ARRAY-ELEMENTS OF ARRAY
	    DO (SEND *CURRENT-UNDO* :SAVE-MULTIPLE-UNDO :MSG MSG)
	       (UNREFORMAT-HEADERS MSG T)))
    (RECENTER-WINDOW *WINDOW* :START (MSG-START-BP *MSG*))))

(DEFUN UNREFORMAT-HEADERS (MSG &OPTIONAL FORCE-P)
  (IF (NOT (MSG-GET MSG 'REFORMATTED))
      (WHEN (NOT FORCE-P)
	(BARF "The headers for this message have not been reformatted."))
    (LET ((ORIGINAL-HEADERS (MSG-GET MSG 'ORIGINAL-HEADERS-INTERVAL)))
      (WHEN (NULL ORIGINAL-HEADERS)
	(BARF "The original headers for this message haven't been saved."))
      (LET* ((MSG-INTERVAL (MSG-INTERVAL MSG))
	     (MSG-START-BP (INTERVAL-FIRST-BP MSG-INTERVAL))
	     (NEW-FIRST-LINE (BP-LINE MSG-START-BP))
	     (NEW-LAST-LINE (BP-LINE (MSG-GET MSG 'HEADERS-END-BP)))
	     (ORIGINAL-FIRST-BP (INTERVAL-FIRST-BP ORIGINAL-HEADERS))
	     (ORIGINAL-FIRST-LINE (BP-LINE ORIGINAL-FIRST-BP))
	     (ORIGINAL-LAST-LINE (BP-LINE (INTERVAL-LAST-BP ORIGINAL-HEADERS)))
	     (ORIGINAL-LAST-PREVIOUS (LINE-PREVIOUS ORIGINAL-LAST-LINE)))
	(WITHOUT-INTERRUPTS
	  (SI:NREMPROP (LOCF (MSG-STATUS MSG)) 'ORIGINAL-HEADERS-INTERVAL)
	  (LET ((PREVIOUS (LINE-PREVIOUS ORIGINAL-FIRST-LINE)))
	    (AND PREVIOUS (SETF (LINE-NEXT PREVIOUS) ORIGINAL-LAST-LINE))
	    (SETF (LINE-PREVIOUS ORIGINAL-LAST-LINE) PREVIOUS))
	  (MOVE-BP ORIGINAL-FIRST-BP ORIGINAL-LAST-LINE 0)
	  (LET ((PREVIOUS (LINE-PREVIOUS NEW-FIRST-LINE)))
	    (SETF (LINE-PREVIOUS ORIGINAL-FIRST-LINE) PREVIOUS)
	    (IF PREVIOUS
		(SETF (LINE-NEXT PREVIOUS) ORIGINAL-FIRST-LINE)
	      (MOVE-BP (MSG-REAL-START-BP MSG) ORIGINAL-FIRST-LINE 0)))
	  (MOVE-BP MSG-START-BP ORIGINAL-FIRST-LINE 0)
	  (SETF (LINE-NEXT ORIGINAL-LAST-PREVIOUS) NEW-LAST-LINE)
	  (SETF (LINE-PREVIOUS NEW-LAST-LINE) ORIGINAL-LAST-PREVIOUS)
	  (LET ((DUMMY (CREATE-INTERVAL)))
	    (LOOP FOR LINE = NEW-FIRST-LINE THEN (LINE-NEXT LINE)
		  UNTIL (EQ LINE NEW-LAST-LINE)
		  DO (SETF (LINE-NODE LINE) DUMMY)))
	  (LOOP FOR LINE = ORIGINAL-FIRST-LINE THEN (LINE-NEXT LINE)
		UNTIL (EQ LINE NEW-LAST-LINE)
		DO (SETF (LINE-NODE LINE) MSG-INTERVAL)))
	(MSG-PUT MSG NIL 'REFORMATTED)
	(REFORMAT-FAKE-OUT-REDISPLAY MSG)))))

(DEFUN REFORMAT-HEADERS (MSG &OPTIONAL FORCE-P TEMPLATE)
  (LET ((STATUS (LOCF (MSG-STATUS MSG)))	1;Could be called from 2assure-msg-parsed1.
0	(*RETAIN-COMMON-TAILS* NIL))		1;Make reformatted headers easier to read.
0    (WHEN (OR (AND FORCE-P (NULL (GET STATUS 'UNPARSEABLE)))
	      (LOOP FOR INDICATOR IN '(REFORMATTED UNPARSEABLE LOSING-HEADERS)
		    ALWAYS (NULL (GET STATUS INDICATOR))))
      (CATCH-ERROR-RESTART ((ERROR) "Skip reformatting the message.")
	(LET* ((BUFFER (MSG-BUFFER MSG))
	       (TEMPLATE (OR TEMPLATE (SEND BUFFER :REFORMAT-TEMPLATE MSG FORCE-P))))
	  (UNLESS (NULL TEMPLATE)
	    (MULTIPLE-VALUE-BIND (INTERVAL FIRST-LINE-ITS-P)
		(COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG TEMPLATE)
	      (WHEN FIRST-LINE-ITS-P
		(LET ((LAST-BP (INTERVAL-LAST-BP INTERVAL)))
		  (WHEN (ZEROP (BP-INDEX LAST-BP))
		    (DBP LAST-BP))))
	      (LET ((WHERE (SEND BUFFER :SET-REFORMATTED-HEADERS MSG STATUS INTERVAL)))
		1;; Cannot use 2msg-put1 from the background process.
0		(PUTPROP STATUS WHERE 'REFORMATTED)
		(UNLESS (EQ WHERE :IN-CORE)
		  (SETF (MSG-TICK MSG) (TICK)))))
	    (REFORMAT-FAKE-OUT-REDISPLAY MSG)))))))

(DEFVAR-RESETTABLE *SUPPRESS-REFORMAT-FAKE-OUT-REDISPLAY* NIL)
(DEFVAR *REFORMAT-FAKE-OUT-REDISPLAY-CALLED* NIL)

1;; 2redisplay1 can be faked out by start moving up into invisible part of message.
;; But this can be called before the interval has been attached to the message.
0(DEFUN REFORMAT-FAKE-OUT-REDISPLAY (MSG)
  (IF *SUPPRESS-REFORMAT-FAKE-OUT-REDISPLAY*
      (CL:PUSHNEW MSG *REFORMAT-FAKE-OUT-REDISPLAY-CALLED*)
    (WHEN (AND (VARIABLE-BOUNDP *MSG*)
	       (EQ MSG *MSG*)
	       (NEQ (BP-NODE (WINDOW-START-BP *MSG-WINDOW*)) (MSG-INTERVAL MSG))
	       (EQ (INTERVAL-LAST-BP (WINDOW-INTERVAL *MSG-WINDOW*)) (MSG-END-BP MSG)))
      (RECENTER-WINDOW *MSG-WINDOW* :START (MSG-START-BP *MSG*))
      1;; Force redisplay to completion so that if we got here from a mouse command
      ;; the mouse will know what it is pointing at.  This probably belongs in Zwei's
      ;; mouse stuff somewhere, rather than here, but that's all a mess right now.
0      (WHEN (SEND (WINDOW-SHEET *MSG-WINDOW*) :EXPOSED-P)
	(REDISPLAY *MSG-WINDOW* :NONE NIL NIL T)))))

(DEFUN WITH-MSG-REDISPLAY-DELAYED-INTERNAL (CODE)
  (DECLARE (SYS:DOWNWARD-FUNARG CODE))
  (LET-IF (NOT *SUPPRESS-REFORMAT-FAKE-OUT-REDISPLAY*)
	  ((*REFORMAT-FAKE-OUT-REDISPLAY-CALLED* NIL))
    (LET ((*SUPPRESS-REFORMAT-FAKE-OUT-REDISPLAY* T))
      (FUNCALL CODE))
    (WHEN *REFORMAT-FAKE-OUT-REDISPLAY-CALLED*
      (DOLIST (MSG *REFORMAT-FAKE-OUT-REDISPLAY-CALLED*)
	(REFORMAT-FAKE-OUT-REDISPLAY MSG)))))

;;; This interval includes a blank line at the end if there was one in the original,
;;; i.e. unless they were ITS headers.
;;; COPY-MSG-HEADERS-THROUGH-TEMPLATE will never return the blank line, though.
(DEFUN MSG-ORIGINAL-HEADERS-INTERVAL (MSG)
  (DECLARE (VALUES START-BP END-BP))
  (LET ((ORIGINAL (MSG-GET MSG 'ORIGINAL-HEADERS-INTERVAL)))
    (IF ORIGINAL
	(VALUES (INTERVAL-FIRST-BP ORIGINAL) (INTERVAL-LAST-BP ORIGINAL))
	(VALUES (MSG-START-BP MSG)
		(OR (MSG-GET MSG 'HEADERS-END-BP)
		    (MSG-END-BP MSG))))))

(DEFUN MSG-BODY-INTERVAL (MSG)
  (DECLARE (VALUES START-BP END-BP))
  (VALUES (OR (MSG-GET MSG 'HEADERS-END-BP)
	      (MSG-END-BP MSG))
	  (MSG-END-BP MSG)))

(DEFUN CANONICALIZE-YANKED-MSG-LINE-INDENTATION (LINE DELTA)
  (LET* ((REAL-INDENTATION (LINE-INDENTATION LINE))
	 (LENGTH (LINE-LENGTH LINE))
	 (NO-IND-STYLE (IF (ZEROP LENGTH) T
			 (LET ((L LINE))
			   (DECLARE (SYS:ARRAY-REGISTER L))
			   (LOOP WITH INITIAL-STYLE = (SI:CHAR-STYLE-INDEX (AREF L 0))
				 FOR I FROM 1 BELOW LENGTH
				 THEREIS ( (SI:CHAR-STYLE-INDEX (AREF L I)) INITIAL-STYLE)))))
	 (INDENTATION-STYLE (IF NO-IND-STYLE NIL (SI:CHAR-STYLE (AREF LINE 0))))
	 (SHEET (WINDOW-SHEET *WINDOW*))
	 (SW (FONT-SPACE-WIDTH
	       (IF INDENTATION-STYLE
		   (SI:GET-FONT
		     (SEND SHEET :DISPLAY-DEVICE-TYPE) SI:*STANDARD-CHARACTER-SET*
		     (SI:MERGE-CHARACTER-STYLES INDENTATION-STYLE (SEND SHEET :DEFAULT-STYLE)))
		 (CURRENT-FONT *WINDOW*)))))
    (LOOP FOR STEP UPFROM DELTA BY DELTA
	  WHILE (< STEP (+ REAL-INDENTATION DELTA))
	  WHEN ( (ABS (- REAL-INDENTATION STEP)) (// SW 2))
	    DO (RETURN STEP)
	  FINALLY (RETURN REAL-INDENTATION))))

(DEFUN INSERT-TEXT-OF-MSGS (MSGS BP IGNORE
			    &KEY (INDENTED NIL) (TEMPLATE NIL) (SUPPRESS-CR-AFTER-HEADERS NIL)
				 (BEGIN-LINE NIL) (SEPARATOR-LINE NIL) (END-LINE NIL))
  (DECLARE (VALUES BP FONT-ALIST))
  (WITH-INTERVAL-STREAM (STREAM BP BP T)
    (WHEN BEGIN-LINE
      (SEND STREAM :FRESH-LINE)
      (FORMAT STREAM BEGIN-LINE (LENGTH MSGS))
      (SEND STREAM :FRESH-LINE)
      (SETQ BP (SEND STREAM :READ-BP)))
    (LOOP FOR MSG IN MSGS
	  FOR I FROM 0
	  WITH NBP
	  DO (WHEN (PLUSP I)
	       (IF (NULL SEPARATOR-LINE)
		   (SETQ BP (INSERT BP #\CR))
		 (SEND STREAM :SET-BP BP)
		 (SEND STREAM :FRESH-LINE)
		 (FORMAT STREAM SEPARATOR-LINE I)
		 (SEND STREAM :FRESH-LINE)
		 (SETQ BP (SEND STREAM :READ-BP))))
	     (MULTIPLE-VALUE (BP NBP)
	       (INSERT-TEXT-OF-MSG BP MSG TEMPLATE NIL NIL T SUPPRESS-CR-AFTER-HEADERS))
	     (WHEN INDENTED
	       (WITH-BP (SAVED-NBP NBP :NORMAL)
		 (LET ((NON-BLANK-POINT (BACKWARD-OVER '(#\CR) NBP)))
		   (INTERVAL-LINES (BP NON-BLANK-POINT) (START-LINE STOP-LINE)
		     (DO ((LINE START-LINE (LINE-NEXT LINE))
			  (DELTA (* 4 (FONT-SPACE-WIDTH)))
			  (DIAGRAMS-PRESENT))
			 ((EQ LINE STOP-LINE)
			  (WHEN DIAGRAMS-PRESENT
			    (TYPEIN-LINE "Warning: Diagram lines in text were not indented!")))
		       (COND ((LINE-BLANK-P LINE))
			     ((LINE-DIAGRAM LINE)
			      (SETQ DIAGRAMS-PRESENT T))
			     (T
			      (INDENT-LINE
				(CREATE-BP LINE 0)
				(+ DELTA
				   (CANONICALIZE-YANKED-MSG-LINE-INDENTATION LINE DELTA))))))))
		 (MOVE-BP NBP SAVED-NBP)))
	     (SETQ BP NBP))
    (WHEN END-LINE
      (SEND STREAM :SET-BP BP)
      (SEND STREAM :FRESH-LINE)
      (FORMAT STREAM END-LINE (LENGTH MSGS))
      (SEND STREAM :FRESH-LINE)
      (SETQ BP (SEND STREAM :READ-BP))))
  (VALUES BP NIL))

(DEFUN INSERT-TEXT-OF-MSG (AT-BP MSG TEMPLATE
			   &OPTIONAL ignore ignore
				     DECRYPT-IF-NECESSARY
				     SUPPRESS-CR-AFTER-HEADERS
			   &AUX AFTER-BP)
  (DECLARE (VALUES START-BP END-BP FONT-ALIST))
  (WITH-BP (SAVED-AT-BP AT-BP :NORMAL)
    ;; First the headers
    (MULTIPLE-VALUE-BIND (HEADERS-START-BP HEADERS-END-BP)
	(MSG-ORIGINAL-HEADERS-INTERVAL MSG)
      (IF (NOT TEMPLATE)
	  (SETQ AFTER-BP (INSERT-INTERVAL AT-BP HEADERS-START-BP HEADERS-END-BP))
	  (LET ((INTERVAL (COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG TEMPLATE)))
	    (SETQ AFTER-BP (INSERT-INTERVAL AT-BP INTERVAL))
	    (WHEN (AND (NOT SUPPRESS-CR-AFTER-HEADERS)
		       (LINE-BLANK-P (LINE-PREVIOUS (BP-LINE HEADERS-END-BP))))
	      (INSERT-MOVING AFTER-BP #\CR)))))
    (MULTIPLE-VALUE-BIND (BODY-START-BP BODY-END-BP)
	(MSG-BODY-INTERVAL MSG)
      (WHEN (AND DECRYPT-IF-NECESSARY
		 (MSG-GET MSG ':ENCRYPTED))
	(TYPEIN-LINE "~A is encrypted." (MSG-DESCRIPTION MSG))
	(SETQ BODY-START-BP (MSG-DECRYPTED-BODY-INTERVAL MSG)
	      BODY-END-BP NIL))
      (SETQ AFTER-BP (INSERT-INTERVAL AFTER-BP BODY-START-BP BODY-END-BP T)))
    (SETQ AT-BP (COPY-BP SAVED-AT-BP)))
  (VALUES AT-BP AFTER-BP nil))

;+++ deal with losing-headers; just copy the relevant interval
(DEFUN COPY-MSG-HEADERS-THROUGH-TEMPLATE (MSG TEMPLATE &REST PLIST &AUX EXPANSION)
  (SETQ EXPANSION (LEXPR-FUNCALL #'EXPAND-TEMPLATE TEMPLATE ':MSG MSG PLIST))
  (FUNCALL-TEMPLATE-EXPANSION EXPANSION
			      (OR (GET (LOCF EXPANSION) ':OUTPUT-FUNCTION)
				  #'COPY-MSG-HEADERS-THROUGH-TEMPLATE-OUTPUT-FUNCTION)
			      EXPANSION))

(DEFUN COPY-MSG-HEADERS-THROUGH-TEMPLATE-OUTPUT-FUNCTION (TEMPLATE-EXPANSION)
  (LET* ((INTERVAL (CREATE-INTERVAL))
	 (STREAM (INTERVAL-STREAM INTERVAL))
	 (MSG (GET (LOCF TEMPLATE-EXPANSION) ':MSG))
	 (PRESERVE-ORDER (GET (LOCF TEMPLATE-EXPANSION) ':PRESERVE-ORDER))
	 (REFORMAT-HEADER-TYPES (GET (LOCF TEMPLATE-EXPANSION) ':REFORMAT-HEADER-TYPES))
	 (HEADERS-FROM-ORIGINAL (GET (LOCF TEMPLATE-EXPANSION) ':HEADERS-FROM-ORIGINAL))
	 (HEADERS-FROM-ORIGINAL-EXCEPT (LET ((TEM (GETL (LOCF TEMPLATE-EXPANSION)
							'(:HEADERS-FROM-ORIGINAL-EXCEPT))))
					 ;;+++ SCL extended GET
					 (IF TEM (CADR TEM) ':NONE)))
	 HEADERS-START-BP HEADERS-END-BP FIRST-LINE-ITS-P)
    (MULTIPLE-VALUE (HEADERS-START-BP HEADERS-END-BP)
      (MSG-ORIGINAL-HEADERS-INTERVAL MSG))
    (IF PRESERVE-ORDER
	(MULTIPLE-VALUE (NIL FIRST-LINE-ITS-P)
	  (COPY-MSG-HEADERS-THROUGH-TEMPLATE-OUTPUT-FUNCTION-1
	    HEADERS-START-BP HEADERS-END-BP HEADERS-FROM-ORIGINAL-EXCEPT
	    HEADERS-FROM-ORIGINAL STREAM INTERVAL TEMPLATE-EXPANSION REFORMAT-HEADER-TYPES))
      (DOLIST (TYPE HEADERS-FROM-ORIGINAL)
	(LET ((HEADER (MSG-GET MSG TYPE)))
	  (UNLESS (NULL HEADER)
	    (WHEN (OR (LOOP FOR RTYPE IN REFORMAT-HEADER-TYPES
			    THEREIS (HEADER-TYPE-TYPEP TYPE RTYPE))
		      ;; This one does not necessarily need reformatting, search for it first.
		      (WITH-STACK-LIST (THIS-TYPE TYPE)
			(NOT (COPY-MSG-HEADERS-THROUGH-TEMPLATE-OUTPUT-FUNCTION-1
			       HEADERS-START-BP HEADERS-END-BP ':NONE THIS-TYPE
			       STREAM INTERVAL TEMPLATE-EXPANSION NIL
			       T))))
	      ;; This one needs reformatting or wasn't found
	      (PRINT-HEADER STREAM HEADER TYPE TEMPLATE-EXPANSION)))))
      (MULTIPLE-VALUE (NIL FIRST-LINE-ITS-P)
	(COPY-MSG-HEADERS-THROUGH-TEMPLATE-OUTPUT-FUNCTION-1
	  HEADERS-START-BP HEADERS-END-BP HEADERS-FROM-ORIGINAL-EXCEPT NIL STREAM INTERVAL
	  TEMPLATE-EXPANSION REFORMAT-HEADER-TYPES)))
    (VALUES INTERVAL FIRST-LINE-ITS-P)))

(DEFUN COPY-MSG-HEADERS-THROUGH-TEMPLATE-OUTPUT-FUNCTION-1 (HEADERS-START-BP HEADERS-END-BP
							    HEADERS-FROM-ORIGINAL-EXCEPT
							    HEADERS-FROM-ORIGINAL STREAM
							    INTERVAL TEMPLATE-EXPANSION
							    REFORMAT-HEADER-TYPES
							    &OPTIONAL SEARCH-FOR-ONE)
  (LET ((SOMETHING-OUTPUT NIL)
	(FIRST-LINE-ITS-P NIL))
    (LOOP FOR LINE = (BP-LINE HEADERS-START-BP) THEN (LINE-NEXT LINE)
	  WITH END-LINE = (BP-LINE HEADERS-END-BP)
	  WITH LAST-LINE-HEADERS = NIL
	  UNTIL (EQ LINE END-LINE)
	  DO (LET ((LINE-HEADERS (GET (LOCF (LINE-CONTENTS-PLIST LINE)) 'PARSED-HEADERS)))
	       (WHEN (AND LINE-HEADERS
			  (IF SEARCH-FOR-ONE 
			      (LOOP FOR (TYPE NIL) ON LINE-HEADERS BY 'CDDR
				    ALWAYS (MEMQ TYPE HEADERS-FROM-ORIGINAL))
			      (LOOP FOR (TYPE NIL) ON LINE-HEADERS BY 'CDDR
				    THEREIS (OR (MEMQ TYPE HEADERS-FROM-ORIGINAL)
						(AND (NEQ HEADERS-FROM-ORIGINAL-EXCEPT ':NONE)
						     (NOT
						       (MEMQ TYPE
							     HEADERS-FROM-ORIGINAL-EXCEPT))))
				    )))
		 (IF (LOOP FOR (TYPE NIL) ON LINE-HEADERS BY 'CDDR
			   THEREIS (LOOP FOR RTYPE IN REFORMAT-HEADER-TYPES
					 THEREIS (HEADER-TYPE-TYPEP TYPE RTYPE)))
		     ;; Don't output reformation of continuation line more than once.
		     (UNLESS (EQ LINE-HEADERS LAST-LINE-HEADERS)	
		       ;; Individual header needs reformatting
		       (LOOP FOR (TYPE HEADER) ON LINE-HEADERS BY 'CDDR
			     ;; Don't be fooled by stuff like ITS-HEADER-P that isn't meant
			     ;; for human consumption.
			     DO (WHEN (KEYWORDP TYPE)
				  (PRINT-HEADER STREAM HEADER TYPE TEMPLATE-EXPANSION)))
		       (SETQ LAST-LINE-HEADERS LINE-HEADERS))
		     ;; Can take original
		     (LET ((NLINE (COPY-LINE LINE INTERVAL)))
		       (WHEN (NULL SOMETHING-OUTPUT)
			 (SETQ FIRST-LINE-ITS-P (GET (LOCF LINE-HEADERS) 'ITS-HEADER-P)))
		       (SEND STREAM ':LINE-OUT NLINE)))
		 (SETQ SOMETHING-OUTPUT T))))
    (VALUES SOMETHING-OUTPUT FIRST-LINE-ITS-P)))

;;; Until we create SYS:ZMAIL;ADDRESSES ...

(SCL:DEFINE-PRESENTATION-TYPE ADDRESS ((&KEY (HEADER-TYPE :ADDRESS))
				       &KEY (FORMAT :SHORT))
   :DESCRIPTION "an electronic mail address"
   :HISTORY T

   :PARSER ((STREAM)
	    (VALUES
	      (CONDITION-CASE (ERROR)
		   (PARSE-ONE-ADDRESS (DW:READ-STANDARD-TOKEN STREAM))
		 (PARSE-ERROR
		   (PARSE-FERROR "~A" ERROR)))))

   :TYPEP ((ADDRESS)
	   (IGNORE HEADER-TYPE)
	   (AND (CL:CONSP ADDRESS)
		(MEMQ (FIRST ADDRESS) '(:USER :NAME :PERSONAL-NAME
					:HOST :HOST-DEFAULTED
					:INFERIORS :INITIAL-STRING :FINAL-STRING
					:ORIGINAL-STRING :INTERVAL :ORIGINAL-INTERVAL))))
	       
   :PRINTER ((ADDRESS STREAM)
	     (CL:WRITE-STRING
	       (STRING-FROM-HEADER ADDRESS FORMAT) STREAM)))
