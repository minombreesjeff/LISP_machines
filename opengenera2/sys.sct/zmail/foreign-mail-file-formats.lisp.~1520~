;;; -*- Mode:LISP; Package:ZWEI; Base:8 -*-
;;; Lisp Machine mail reader
;;; Operating system dependent mail file handling, extension of MFILES
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>


;;; ITS mail files
(DEFFLAVOR ITS-BUFFER-MIXIN ()
	   (MSG-BUFFER)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR ITS-INBOX-BUFFER () (ITS-BUFFER-MIXIN INBOX-BUFFER))

(DEFMETHOD (:FORMAT-NAME ITS-INBOX-BUFFER) () "Mail")

(DEFMETHOD (:MAIL-FILE-REPARSABLE-P ITS-BUFFER-MIXIN) () T)

;;; Messages on ITS end with a line with a  in it
(DEFMETHOD (LINE-END-OF-MSG-P ITS-BUFFER-MIXIN) (LINE LENGTH IGNORE EOF &AUX END-IDX)
  (COND ((AND (> LENGTH 0) (SETQ END-IDX (STRING-SEARCH-CHAR #/ LINE))
	      (NOT (DO I (1+ END-IDX) (1+ I) ( I LENGTH)
		       (OR (MEM #'CHAR-EQUAL (AREF LINE I) '(#\SP #\TAB #\FF))
			   (RETURN T)))))
	 END-IDX)
	(EOF T)))

;;; Parse a message which might have an ITS header.
(DEFMETHOD (PARSE-MSG-TEXT ITS-BUFFER-MIXIN) (MSG MSG-STATUS)
  (LET ((ORIGINAL (GET MSG-STATUS 'ORIGINAL-HEADERS-INTERVAL)))
    (IF (NULL ORIGINAL)
	(PARSE-ITS-MSG-HEADERS (MSG-INTERVAL MSG) NIL NIL (GET MSG-STATUS 'REFORMATTED))
      (VALUES (PARSE-ITS-MSG-HEADERS ORIGINAL) (GET-MSG-HEADERS-END-BP MSG)))))

;;; Any message from an ITS-style inbox is unseen ...
(DEFMETHOD (PARSE-MSG ITS-INBOX-BUFFER :BEFORE) (MSG STAT)
  (IGNORE MSG)
  (PUTPROP STAT T 'UNSEEN)) 

;;; Write an ITS style message -- Write the out-of-band separator.
(DEFMETHOD (SAVE-MSG ITS-BUFFER-MIXIN :AFTER) (MSG MAIL-FILE-SAVING-STATE)
  (IGNORE MSG MAIL-FILE-SAVING-STATE)
  (SEND STREAM :FRESH-LINE)
  (SEND STREAM :TYO #/))


;;; RMAIL mail files
(ADD-MAIL-BUFFER-FLAVOR 'RMAIL-BUFFER "Rmail" "ITS RMAIL format.")

(DEFFLAVOR RMAIL-BUFFER () (ITS-BUFFER-MIXIN FILE-MAIL-BUFFER))

(DEFMETHOD (:FORMAT-NAME RMAIL-BUFFER) () "Rmail")

(DEFMETHOD (:DEFAULT-CANONICAL-TYPE RMAIL-BUFFER) () :RMAIL)

(DEFMETHOD (SETTABLE-MAIL-FILE-OPTIONS RMAIL-BUFFER) ()
  '(:APPEND))

(DEFMETHOD (UPDATE-OPTIONS-IN-FILE RMAIL-BUFFER) ()
  (LET* ((FIRST-BP (INTERVAL-FIRST-BP HEADER-INTERVAL))
	 (LINE (BP-LINE FIRST-BP))
	 (APPEND-P (SEND SELF :GET :APPEND)))
    (WHEN (NEQ (STRING-EQUAL LINE "*APPEND*") APPEND-P)
      (DELETE-INTERVAL HEADER-INTERVAL)
      (WHEN APPEND-P
	(INSERT FIRST-BP "*APPEND*
"))
      (MARK-SEQUENCE-MODIFIED SELF :HARD T))))

;;; Primary method has already validated that we're not really a BABYL file --
;;;    Check if the first line is "*APPEND*" which controls the setting of the
;;;    :APPEND mail file option.  If said line is present, put it into the buffer's
;;;    header interval to avoid reading it as part of the first message.
(DEFMETHOD (VERIFY-MSG-FILE-FORMAT-AND-LOAD-HEADER RMAIL-BUFFER :AFTER) ()
  (LET* ((LINE (SEND STREAM :LINE-IN LINE-LEADER-SIZE))
	 (APPEND-OPTION (STRING-EQUAL LINE "*APPEND*")))
    (IF APPEND-OPTION
	(INSERT-LINE-WITH-LEADER LINE (BP-LINE (INTERVAL-FIRST-BP HEADER-INTERVAL)))
      (SEND STREAM :SET-POINTER 0))
    (SEND SELF :PUTPROP APPEND-OPTION :APPEND)))

;;; Inbox pathnames for an RMAIL buffer -- Must include the appropriate GMSGS inbox file.
(DEFMETHOD (INBOX-PATHNAMES RMAIL-BUFFER) ()
  (LET ((DEFAULT-INBOX-PATHNAME (DEFAULT-INBOX-PATHNAME PATHNAME))
	(GMSGS-INBOX-PATHNAME (IF *RUN-GMSGS-P* (GMSGS-INBOX-PATHNAME PATHNAME))))
    (COND ((AND DEFAULT-INBOX-PATHNAME GMSGS-INBOX-PATHNAME)
	   (LIST GMSGS-INBOX-PATHNAME DEFAULT-INBOX-PATHNAME))
	  (DEFAULT-INBOX-PATHNAME
	   (LIST DEFAULT-INBOX-PATHNAME))
	  (GMSGS-INBOX-PATHNAME
	   (LIST GMSGS-INBOX-PATHNAME)))))

;;; Save an RMAIL message -- Be sure each message starts on a separate line.
(DEFMETHOD (SAVE-MSG RMAIL-BUFFER :BEFORE) (MSG MAIL-FILE-SAVING-STATE)
  (IGNORE MSG MAIL-FILE-SAVING-STATE)
  (SEND STREAM :FRESH-LINE))

;;; BABYL mail files
;;; Limits of Babyl file formats supported here
(DEFCONST *LOWEST-BABYL-VERSION* 4)
(DEFCONST *HIGHEST-BABYL-VERSION* 5)

(DEFINE-SETTABLE-MAIL-FILE-OPTION :VERSION 5 :NUMBER)

(ADD-MAIL-BUFFER-FLAVOR 'BABYL-BUFFER "Babyl" "ITS//Tenex//Tops-20 BABYL format.")

(DEFFLAVOR BABYL-BUFFER () (ITS-BUFFER-MIXIN FILE-MAIL-BUFFER))

(DEFMETHOD (:FORMAT-NAME BABYL-BUFFER) () "Babyl")

(DEFMETHOD (:DEFAULT-CANONICAL-TYPE BABYL-BUFFER) () :BABYL)

(DEFMETHOD (POSSIBLE-MAIL-FILE-OPTIONS BABYL-BUFFER) ()
  '(:APPEND :BABYL-P :REFORMAT-HEADERS-P :|NO REFORMATION| :|NO ORIGINAL| :REVERSE-NEW-MAIL
    :VERSION :MAIL :OWNER :SORT :DELETE-EXPIRED :KEYWORDS :KEYWORDS-STRING
    :SUMMARY-WINDOW-FORMAT :REFORMAT-TEMPLATE))

(DEFMETHOD (SETTABLE-MAIL-FILE-OPTIONS BABYL-BUFFER) ()
  '(:APPEND :REFORMAT-HEADERS-P :REVERSE-NEW-MAIL :VERSION :MAIL :OWNER :SORT :DELETE-EXPIRED
    :SUMMARY-WINDOW-FORMAT :REFORMAT-TEMPLATE))

(DEFMETHOD (STICKY-MAIL-FILE-OPTIONS BABYL-BUFFER) ()
  '(:APPEND :BABYL-P :VERSION))

;;; The default value for :BABYL-P is T and for :VERSION is *HIGHEST-BABYL-VERSION*.
(DEFMETHOD (DEFAULT-MAIL-FILE-OPTION-VALUE BABYL-BUFFER) (OPTION)
  (CL:CASE OPTION
    (:BABYL-P (VALUES T T))
    (:VERSION (VALUES *HIGHEST-BABYL-VERSION* T))
    (OTHERWISE (VALUES NIL NIL))))

(DEFMETHOD (UPDATE-OPTIONS-IN-FILE BABYL-BUFFER) (&AUX PLIST)
  ;; Cause any pathnames that happen to get parsed without hosts to be for here.
  (FS:SET-DEFAULT-PATHNAME PATHNAME *ZMAIL-PATHNAME-DEFAULTS*)
  (SETQ PLIST (SEND SELF :PROPERTY-LIST-LOCATION))
  (RATIONALIZE-REFORMATTING-OPTIONS PLIST)
  ;; Move this to the first
  (WHEN (OR (NEQ (CAAR PLIST) :BABYL-P) (NEQ (CADAR PLIST) T))
    (SI:NREMPROP PLIST :BABYL-P)
    (PUTPROP PLIST T :BABYL-P))
  (UPDATE-BABYL-OPTIONS-IN-FILE SELF PLIST 
				(BP-LINE (INTERVAL-FIRST-BP HEADER-INTERVAL))
				(BP-LINE (INTERVAL-LAST-BP HEADER-INTERVAL))))

(DEFUN UPDATE-BABYL-OPTIONS-IN-FILE (BUFFER PLIST START-LINE END-LINE &AUX MODIFIED)
  (DO ((LINE START-LINE (LINE-NEXT LINE))
       (DONE NIL)
       (PROPS))
      ((EQ LINE END-LINE)
       (LOOP FOR (IND PROP) ON (CDR PLIST) BY 'CDDR
	     WITH BP = (CREATE-BP LINE 0)
	     WHEN (AND PROP
		       (NOT (MEMQ IND DONE))
		       (GETL IND '(BABYL-OPTION-PARSER BABYL-OPTION-PRINTER BABYL-OPTION-P)))
	     DO (SETQ LINE (STRING-FROM-OPTION IND PLIST)
		      BP (INSERT (INSERT BP LINE) #\CR)
		      MODIFIED T)
	        (LOOP FOR IND IN (OPTION-FROM-STRING LINE) BY 'CDDR
		      DO (PUSH IND DONE))))
    (SETQ PROPS (OPTION-FROM-STRING LINE))
    (WHEN (LOOP FOR (IND PROP) ON PROPS BY 'CDDR
		UNLESS (OR (NOT (MEMQ IND (POSSIBLE-MAIL-FILE-OPTIONS BUFFER)))
			   (EQUAL PROP (GET PLIST IND)))
		  RETURN T)			;Not still the same
      (SETQ MODIFIED T)
      (IF (NOT (LOOP FOR (IND) ON PROPS BY 'CDDR
		     WHEN (GET PLIST IND)
		       RETURN T))		;All properties NIL
	  (LET ((BP (CREATE-BP LINE 0)))
	    (DELETE-INTERVAL BP (BEG-LINE BP 1 T) T))
	(MUNG-NODE (LINE-NODE LINE))
	(SETF (LINE-LENGTH LINE) 0)
	(STRING-FROM-OPTION (CAR PROPS) PLIST LINE)))
    (LOOP FOR IND IN PROPS BY 'CDDR
	  DO (PUSH IND DONE)))
  (WHEN MODIFIED
    (MARK-SEQUENCE-MODIFIED BUFFER :HARD T)))

;;; Read the options section of a BABYL file --
;;;    Our MAKE-INSTANCE and/or TRANSFORM-INSTANCE method has already supplied default values.
(DEFMETHOD (VERIFY-MSG-FILE-FORMAT-AND-LOAD-HEADER BABYL-BUFFER) ()
  (CHECK-MSG-FILE-ELEMENT-TYPE)
  (LET ((FIRST-LINE (SEND STREAM :LINE-IN)))
    (SEND STREAM :SET-POINTER 0)
    (IF (STRING-EQUAL FIRST-LINE "Babyl Options:")
	(LET ((FILE-PROPERTIES (PARSE-BABYL-OPTIONS STREAM HEADER-INTERVAL)))
	  (LOOP FOR (TYPE VALUE) ON FILE-PROPERTIES BY 'CDDR
		DO (SEND SELF :PUTPROP VALUE TYPE)))
      (ERROR 'WRONG-MAIL-FILE-FORMAT :BUFFER SELF
				     :APPARENT-FORMAT (ACTUAL-MAIL-FILE-FORMAT PATHNAME
									       STREAM)
				     :FORMAT-STRING NIL))))

(DEFUN PARSE-BABYL-OPTIONS (STREAM INTERVAL)
  (FS:SET-DEFAULT-PATHNAME (SEND STREAM ':PATHNAME) *ZMAIL-PATHNAME-DEFAULTS*)
  (LET ((END-LINE (BP-LINE (INTERVAL-LAST-BP INTERVAL))))
    (LOOP WITH (LINE EOF)
	  DO (MULTIPLE-VALUE (LINE EOF) (SEND STREAM :LINE-IN LINE-LEADER-SIZE))
	  UNTIL (OR EOF (STRING-SEARCH-CHAR #/ LINE))
	  DO (INSERT-LINE-WITH-LEADER LINE END-LINE)
	  APPEND (LOOP FOR (IND VAL) ON (OPTION-FROM-STRING LINE) BY 'CDDR
		       WHEN (GETL (LOCF OPTIONS) `(,IND))
			 DO (PUTPROP (LOCF OPTIONS) VAL IND)
		       ELSE APPEND (LIST IND VAL))
	    INTO OPTIONS
	  FINALLY (RATIONALIZE-REFORMATTING-OPTIONS (LOCF OPTIONS))
		  (RETURN OPTIONS))))
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Make sure that the three reformatting options are consistent.
0(DEFUN RATIONALIZE-REFORMATTING-OPTIONS (PLIST)
  (LET ((REFORMAT-HEADERS-P-PRESENT (GETL PLIST '(:REFORMAT-HEADERS-P))))
    (IF REFORMAT-HEADERS-P-PRESENT
	1;; 0Reformat-Headers-P1 overrides the older 0No Reformation1 and 0No Original1 options.
0	(LET ((REFORMAT-HEADERS-P (GET PLIST :REFORMAT-HEADERS-P)))
	  (SELECTQ REFORMAT-HEADERS-P
	    (:SAVE-BOTH
	     1;; Save both the original and reformatted headers --
0	     1;;    Not a selectable option but provided for compatibility with 0Babyl1 itself.
0	     (PUTPROP PLIST NIL :|NO REFORMATION|)
	     (PUTPROP PLIST NIL :|NO ORIGINAL|))
	    (NIL				
	     1;; Don't reformat the headers at all.
0	     (PUTPROP PLIST T :|NO REFORMATION|)
	     (PUTPROP PLIST NIL :|NO ORIGINAL|))
	    (T
	     1;; Reformat the headers but save only the originals in the mail file --
0	     1;;    If 0Babyl1 sees any value for the 0No Original1 option, it will never
0	     1;;    save the original headers.  Therefore, we'll set 0No Original1 to
0	     1;;    indicate that both the original and reformatted headers should be
0	     1;;    saved.  Only 0Babyl1 itself will actually save both; 0Zmail1 will
0	     1;;    continue to save only the original headers.  As each message indicates
0	     1;;    whether/not it's reformatted in the file, this is OK.
0	     (PUTPROP PLIST NIL :|NO REFORMATION|)
	     (PUTPROP PLIST NIL :|NO ORIGINAL|))))
1      ;; 0Reformat-Headers-P1 isn't present --
0      1;;    Compute it from the older 0No Reformation1 and0 No Original1 options for compatibility.
0      (LET ((NO-REFORMATION (GET PLIST :|NO REFORMATION|))
	    (NO-ORIGINAL (GET PLIST :|NO ORIGINAL|)))
	(IF NO-REFORMATION
	    1;; No reformatting -- Ignore the setting of 0No Original1.
0	    (PUTPROP PLIST NIL :REFORMAT-HEADERS-P)
	  (SELECTQ NO-ORIGINAL
	    (:SAVE-ORIGINAL
1	     ;; Reformat for display but save the original headers.
0	     (PUTPROP PLIST T :REFORMAT-HEADERS-P))
	    (NIL				
	     1;; Save both the original and reformatted headers.
0	     (PUTPROP PLIST :SAVE-BOTH :REFORMAT-HEADERS-P))
	    (T
	     1;; Save only the reformatted headers --
0	     1;;    We don't honor this option as it would prevent conversations from working.
0	     1;;    Therefore, we treat this as equivalent to 0Save Original1.
0	     (PUTPROP PLIST T :REFORMAT-HEADERS-P))))))))

(DEFVAR *OPTION-SPECIAL-CHARS* '(#/( #/" #// #/0 #/1 #/2 #/3 #/4 #/5 #/6 #/7 #/8 #/9))

;;; Parse a single line of a babyl option or an unparsed message header
(DEFUN OPTION-FROM-STRING (STRING &AUX I TYPE PARSE-FUNCTION PROP)
  (SETQ I (STRING-SEARCH-CHAR #/: STRING)
        TYPE (INTERN (STRING-UPCASE (NSUBSTRING STRING 0 I)) SI:PKG-KEYWORD-PACKAGE))
  (AND I (SETQ I (OR (STRING-SEARCH-NOT-SET '(#\SP #\TAB) STRING (SETQ I (1+ I)))
		     (STRING-LENGTH STRING))))
  (IF (SETQ PARSE-FUNCTION (GET TYPE 'BABYL-OPTION-PARSER))
      (FUNCALL PARSE-FUNCTION TYPE STRING I)
      (COND ((NULL I)
	     (SETQ PROP T))
	    (( I (STRING-LENGTH STRING))
	     (SETQ PROP ""))
	    ((MEMQ (AREF STRING I) *OPTION-SPECIAL-CHARS*)
	     (SCL:WITH-STANDARD-IO-ENVIRONMENT
	       (PKG-BIND SI:PKG-KEYWORD-PACKAGE
		 (SETQ PROP (READ-FROM-STRING STRING NIL I)))))
	    (T
	     (SETQ PROP (SUBSTRING STRING I))))
      (LIST TYPE PROP)))

;;; Convert a message header into a string
(DEFUN STRING-FROM-OPTION (PROP PLIST &OPTIONAL STRING &AUX VAL TEM)
  (OR STRING (SETQ STRING (MAKE-EMPTY-STRING 40)))
  (SETQ VAL (GET PLIST PROP))
  (WITH-OUTPUT-TO-STRING (STREAM STRING)
    (COND ((SETQ TEM (GET PROP 'BABYL-OPTION-PRINTER))
	   (SEND TEM STREAM PROP VAL PLIST))
	  (T
	   (FORMAT STREAM "~:(~A~)" PROP)
	   (UNLESS (EQ VAL T)
	     (SEND STREAM ':TYO #/:)
	     (SCL:WITH-STANDARD-IO-ENVIRONMENT
	       (PKG-BIND SI:PKG-KEYWORD-PACKAGE
		 (FUNCALL (IF (AND (STRINGP VAL)
				   (NOT (MEMQ (AREF VAL 0) *OPTION-SPECIAL-CHARS*))
				   (NOT (STRING-SEARCH-SET '(#\SP #\TAB) VAL)))
			      #'PRINC #'PRIN1)
			  VAL STREAM)))))))
  STRING)

;;; The options themselves
(DEFINE-NOT-SETTABLE-MAIL-FILE-OPTION :BABYL-P)

(DEFUN (:|BABYL OPTIONS| BABYL-OPTION-PARSER) (&REST IGNORE)
  '(:BABYL-P T))

(DEFUN (:BABYL-P BABYL-OPTION-PRINTER) (STREAM &REST IGNORE)
  (FORMAT STREAM "Babyl Options:"))

(DEFUN (:VERSION BABYL-OPTION-PARSER) (IGNORE STRING START &AUX VERSION)
  (SETQ VERSION (PARSE-NUMBER STRING START))
  (AND (OR (NULL VERSION)
	   (< VERSION *LOWEST-BABYL-VERSION*)
	   (> VERSION *HIGHEST-BABYL-VERSION*))
       (FSIGNAL "Babyl version is ~D, not supported by this version of Zmail" VERSION))
  `(:VERSION ,VERSION))

(DEFINE-SETTABLE-MAIL-FILE-OPTION :OWNER NIL :STRING-OR-NIL)

(DEFPROP :OWNER T BABYL-OPTION-P)

(DEFINE-SETTABLE-MAIL-FILE-OPTION :MAIL NIL :PATHNAME-LIST "Inbox pathname(s)")

(DEFPROP :MAIL PATHNAME-LIST-OPTION-PARSER BABYL-OPTION-PARSER)

(DEFUN PATHNAME-LIST-OPTION-PARSER (TYPE STRING START)
  (DO ((I START (1+ J))
       (J)
       (PATHNAME-LIST NIL))
      (NIL)
    (OR (SETQ I (STRING-SEARCH-NOT-SET ZWEI:*WHITESPACE-CHARS* STRING I))
	(RETURN NIL))
    (SETQ J (STRING-SEARCH-CHAR #/, STRING I))
    (PUSH (FS:HEURISTIC-PARSE-MAYBE-HOSTED-PATHNAME
	    (NSUBSTRING STRING I J) *ZMAIL-PATHNAME-DEFAULTS*)
	  PATHNAME-LIST)
    (OR J (RETURN (LIST TYPE (NREVERSE PATHNAME-LIST))))))

(DEFPROP :MAIL PATHNAME-LIST-OPTION-PRINTER BABYL-OPTION-PRINTER)

(DEFINE-SETTABLE-MAIL-FILE-OPTION :GMSGS-HOST NIL :STRING-OR-NIL "Host to run GMSGS on")

(DEFPROP :GMSGS-HOST T BABYL-OPTION-P)

(DEFUN PATHNAME-LIST-OPTION-PRINTER (STREAM PROP PATHNAME-LIST IGNORE)
  (FORMAT STREAM "~:(~A~): ~{~A~^, ~}" PROP
	  (LOOP FOR PATHNAME IN PATHNAME-LIST
		COLLECT (FS:HEURISTIC-PRINT-MAYBE-HOSTED-PATHNAME
			  PATHNAME *ZMAIL-PATHNAME-DEFAULTS*))))

(DEFINE-SETTABLE-MAIL-FILE-OPTION :REVERSE-NEW-MAIL NIL :BOOLEAN)

(DEFUN (:APPEND BABYL-OPTION-PARSER) (IGNORE STRING START &AUX APPEND REVERSE)
  (IF (NULL START)				;Append<nl>
      (SETQ APPEND T)
      (LET ((N (PARSE-NUMBER STRING START NIL 8)))
	(SETQ APPEND (BIT-TEST N 1)
	      REVERSE (BIT-TEST N 2))))
  `(:APPEND ,APPEND :REVERSE-NEW-MAIL ,REVERSE))

(DEFPROP :APPEND PRINT-APPEND-AND-REVERSE-NEW-MAIL BABYL-OPTION-PRINTER)
(DEFPROP :REVERSE-NEW-MAIL PRINT-APPEND-AND-REVERSE-NEW-MAIL BABYL-OPTION-PRINTER)

(DEFUN PRINT-APPEND-AND-REVERSE-NEW-MAIL (STREAM IGNORE IGNORE PLIST &AUX (BITS 0))
  (AND (GET PLIST ':APPEND)
       (SETQ BITS (LOGIOR BITS 1)))
  (AND (GET PLIST ':REVERSE-NEW-MAIL)
       (SETQ BITS (LOGIOR BITS 2)))
  (FORMAT STREAM "Append:~O" BITS))

(DEFINE-SETTABLE-MAIL-FILE-OPTION :REFORMAT-HEADERS-P T :MENU-ALIST
				  "Reformat headers" *REFORMAT-HEADERS-P-ALIST*)
(DEFPROP :REFORMAT-HEADERS-P REFORMAT-HEADERS-P-BABYL-OPTION-PARSER BABYL-OPTION-PARSER)
(DEFPROP :REFORMAT-HEADERS-P REFORMAT-HEADERS-P-BABYL-OPTION-PRINTER BABYL-OPTION-PRINTER)

(DEFUN REFORMAT-HEADERS-P-BABYL-OPTION-PARSER (TYPE STRING START)
  (LIST TYPE (IF (NULL START) T
		 (DOLIST (ELEM *BABYL-REFORMAT-HEADERS-P-PARSE-ALIST*)
		   (AND (STRING-EQUAL (CAR ELEM) STRING 0 START)
			(RETURN (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ELEM)))))))

(DEFUN REFORMAT-HEADERS-P-BABYL-OPTION-PRINTER (STREAM TYPE VALUE IGNORE)
  (FORMAT STREAM "~:(~A~)~:[: ~A~]" TYPE (EQ VALUE T)
	  (NAME-FROM-MENU-VALUE VALUE *BABYL-REFORMAT-HEADERS-P-PARSE-ALIST*)))

(DEFINE-NOT-SETTABLE-MAIL-FILE-OPTION :|NO REFORMATION|)
(DEFPROP :|NO REFORMATION| T BABYL-OPTION-P)

(DEFVAR *BABYL-NO-ORIGINAL-ALIST*
  '(("Yes" :VALUE T) ("No" :VALUE NIL) ("Save Original" :VALUE :SAVE-ORIGINAL)))

(DEFINE-NOT-SETTABLE-MAIL-FILE-OPTION :|NO ORIGINAL|)
(DEFPROP :|NO ORIGINAL| NO-ORIGINAL-BABYL-OPTION-PARSER BABYL-OPTION-PARSER)
(DEFPROP :|NO ORIGINAL| NO-ORIGINAL-BABYL-OPTION-PRINTER BABYL-OPTION-PRINTER)

(DEFUN NO-ORIGINAL-BABYL-OPTION-PARSER (TYPE STRING START)
  (LIST TYPE (IF (NULL START) T
		 (DOLIST (ELEM *BABYL-NO-ORIGINAL-ALIST*)
		   (AND (STRING-EQUAL (CAR ELEM) STRING 0 START)
			(RETURN (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ELEM)))))))

(DEFUN NO-ORIGINAL-BABYL-OPTION-PRINTER (STREAM TYPE VALUE IGNORE)
  (FORMAT STREAM "~:(~A~)~:[: ~A~]" TYPE (EQ VALUE T)
	  (NAME-FROM-MENU-VALUE VALUE *BABYL-NO-ORIGINAL-ALIST*)))

(DEFINE-SETTABLE-MAIL-FILE-OPTION :SORT NIL :MENU-ALIST
				  "Sort predicate" *MAIL-BUFFER-SORT-ALIST*)

(DEFPROP :SORT MENU-ALIST-BABYL-OPTION-PARSER BABYL-OPTION-PARSER)
(DEFPROP :SORT MENU-ALIST-BABYL-OPTION-PRINTER BABYL-OPTION-PRINTER)

(DEFINE-SETTABLE-MAIL-FILE-OPTION :DELETE-EXPIRED NIL :MENU-ALIST
				  "Delete expired messages" *YES-NO-ASK-ALIST*)

(DEFPROP :DELETE-EXPIRED MENU-ALIST-BABYL-OPTION-PARSER BABYL-OPTION-PARSER)
(DEFPROP :DELETE-EXPIRED MENU-ALIST-BABYL-OPTION-PRINTER BABYL-OPTION-PRINTER)

(DEFUN MENU-ALIST-BABYL-OPTION-PARSER (TYPE STRING START)
  (LIST TYPE (IF (NULL START) T
		 (DOLIST (ELEM (FOURTH (ASSQ TYPE *MAIL-FILE-OPTION-ALIST*)))
		   (AND (STRING-EQUAL (CAR ELEM) STRING 0 START)
			(RETURN (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ELEM)))))))

(DEFUN MENU-ALIST-BABYL-OPTION-PRINTER (STREAM TYPE VALUE IGNORE)
  (FORMAT STREAM "~:(~A~)~:[: ~A~]" TYPE (EQ VALUE T)
	  (NAME-FROM-MENU-VALUE VALUE (FOURTH (ASSQ TYPE *MAIL-FILE-OPTION-ALIST*)))))

(DEFUN NAME-FROM-MENU-VALUE (VALUE ITEM-LIST)
  (FIRST (ITEM-FROM-MENU-VALUE VALUE ITEM-LIST)))

(DEFUN ITEM-FROM-MENU-VALUE (VALUE ITEM-LIST)
  (DOLIST (ITEM ITEM-LIST)
    (WHEN (EQ (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ITEM) VALUE)
      (RETURN ITEM))))

(DEFINE-SETTABLE-MAIL-FILE-OPTION :REFORMAT-TEMPLATE NIL :SEXP)

(DEFINE-SETTABLE-MAIL-FILE-OPTION :SUMMARY-WINDOW-FORMAT :DEFAULT :MENU-ALIST
				  "Summary window format" *BABYL-SUMMARY-WINDOW-FORMAT-ALIST*)

(DEFPROP :SUMMARY-WINDOW-FORMAT SUMMARY-WINDOW-FORMAT-BABYL-OPTION-PARSER BABYL-OPTION-PARSER)
(DEFPROP :SUMMARY-WINDOW-FORMAT MENU-ALIST-BABYL-OPTION-PRINTER BABYL-OPTION-PRINTER)

(DEFUN SUMMARY-WINDOW-FORMAT-BABYL-OPTION-PARSER (TYPE STRING START)
  (LIST TYPE (IF (NULL START) T
		 (DOLIST (ELEM *BABYL-SUMMARY-WINDOW-FORMAT-PARSE-ALIST*)
		   (AND (STRING-EQUAL (CAR ELEM) STRING 0 START)
			(RETURN (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ELEM)))))))

(DEFUN SEXP-OPTION-PARSER (TYPE STRING START)
  `(,TYPE ,(SCL:WITH-STANDARD-IO-ENVIRONMENT
	     (PKG-BIND SI:PKG-USER-PACKAGE
	       ;; This really is USER and not keyword.  Keywords should print with
	       ;; colons and T and NIL should be available (not :T and :NIL).
	       (READ-FROM-STRING STRING NIL START)))))

(DEFUN SEXP-OPTION-PRINTER (STREAM PROP SEXP IGNORE)
  (SCL:WITH-STANDARD-IO-ENVIRONMENT
    (PKG-BIND SI:PKG-USER-PACKAGE
      (FORMAT STREAM "~:(~A~): ~S" PROP SEXP))))


(DEFFLAVOR BAD-BABYL-MSG (CONTAINED-ERROR) (PARSE-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (DBG:REPORT BAD-BABYL-MSG) (STREAM)
  (FORMAT STREAM "Malformed message in Babyl file:~%    ~~A~" CONTAINED-ERROR))

(DEFMETHOD (:POSITION-AND-REPORT BAD-BABYL-MSG) (STREAM)
  (DBG:REPORT SELF STREAM)
  (VALUES NIL 0))

;;; Parse the BABYL message status line ...
(DEFMETHOD (PARSE-MSG BABYL-BUFFER :BEFORE) (MSG STAT)
  (LET* ((START-BP (MSG-START-BP MSG))
	 (REAL-START-LINE (BP-LINE (MSG-REAL-START-BP MSG)))
	 (REAL-END-LINE (BP-LINE (MSG-REAL-END-BP MSG)))
	 (START-LINE (DO ((LINE REAL-START-LINE (LINE-NEXT LINE)))
			 ((NOT (LINE-BLANK-P LINE))
			  LINE)
		       (WHEN (EQ LINE REAL-END-LINE)
			 (PUTPROP STAT (MAKE-CONDITION 'NULL-MSG) 'UNPARSEABLE)
			 (RETURN-FROM PARSE-MSG (VALUES)))))
	 (END-LINE (BP-LINE (MSG-END-BP MSG))))
    (CONDITION-CASE (.ERROR.)
	 (FUNCALL (IF (< (SEND SELF :GET :VERSION) 5) #'PARSE-MSG-OLD-BABYL-STATUS-LINE
		    #'PARSE-MSG-NEW-BABYL-STATUS-LINE)
		  START-LINE STAT)
       (ERROR
	 (PUTPROP STAT (MAKE-CONDITION 'BAD-BABYL-MSG :CONTAINED-ERROR .ERROR.) 'UNPARSEABLE)
	 (RETURN-FROM PARSE-MSG (VALUES))))
    (SETQ START-LINE (LINE-NEXT START-LINE))
    (DO ((LINE START-LINE (LINE-NEXT LINE)))
	((STRING-EQUAL LINE "*** EOOH ***")
	 (UNLESS (EQ LINE START-LINE)
	   (PUTPROP STAT (CREATE-INTERVAL (CREATE-BP START-LINE 0) (CREATE-BP LINE 0))
		    'ORIGINAL-HEADERS-INTERVAL))
	 (SETQ START-LINE (LINE-NEXT LINE)))
      (WHEN (EQ LINE END-LINE)
	(CONDITION-CASE (.E.)
	     (FERROR "Missing /"*** EOOH ***/" line.")
	   (FERROR
	     (PUTPROP STAT (MAKE-CONDITION 'BAD-BABYL-MSG :CONTAINED-ERROR .E.) 'UNPARSEABLE)
	     (RETURN-FROM PARSE-MSG (VALUES))))))
    ;;Make lines in the header area point to MSG-REAL-INTERVAL rather than MSG-INTERVAL.
    (DO ((LINE REAL-START-LINE (LINE-NEXT LINE)))
	((EQ LINE START-LINE))
      (SETF (LINE-NODE LINE) (MSG-REAL-INTERVAL MSG)))
    (MOVE-BP START-BP START-LINE 0)))
1;;; Parse a message in a0 BABYL1 buffer --
;;;    We must duplicate the code from (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")its-buffer-mixin1 here so that we can be certain
;;;    that we've "de-babylized" the subject field before the 2msg-buffer1 daemons and
;;;    whoppers run as they use the subject field.
0(DEFMETHOD (PARSE-MSG-TEXT BABYL-BUFFER) (MSG MSG-STATUS)
  (MULTIPLE-VALUE-BIND (HEADERS HEADERS-END-BP)
      (LET ((ORIGINAL (GET MSG-STATUS 'ORIGINAL-HEADERS-INTERVAL)))
	(IF (NULL ORIGINAL)
	    (PARSE-ITS-MSG-HEADERS (MSG-INTERVAL MSG) NIL NIL (GET MSG-STATUS 'REFORMATTED))
	  (VALUES (PARSE-ITS-MSG-HEADERS ORIGINAL) (GET-MSG-HEADERS-END-BP MSG))))
    (MULTIPLE-VALUE-BIND (IGNORE IGNORE RE-ETC)
	(CL:GET-PROPERTIES HEADERS '(:RE))
      (WHEN RE-ETC
	(SETF (FIRST RE-ETC) :SUBJECT)))
    (VALUES HEADERS HEADERS-END-BP)))

;;; Returns an empty message leader.
;;;    The leader must include a non-null status line so that :SET-REFORMATTED-HEADERS
;;;    can function properly on newly inserted messages.
(DEFMETHOD (:NEW-MSG-HEADER-AREA BABYL-BUFFER) ()
  (IF ( (SEND SELF :GET :VERSION) 5)
      ;;; New format BABYL files
      "0,,
*** EOOH ***
"
    ;;; Old format BABYL files
    "0
*** EOOH ***
"))

(DEFMETHOD (UPDATE-MSG-OPTIONS-IN-FILE BABYL-BUFFER) (MSG &AUX MSG-STATUS BP LINE)
  (SETQ MSG-STATUS (ASSURE-MSG-PARSED MSG)
        BP (MSG-REAL-START-BP MSG)
	LINE (BP-LINE BP))
  (SETF (LINE-LENGTH LINE) 0)
  (FUNCALL (IF (< (SEND SELF :GET :VERSION) 5)
	       #'UPDATE-MSG-OLD-BABYL-STATUS-LINE
	       #'UPDATE-MSG-NEW-BABYL-STATUS-LINE)
	   LINE MSG-STATUS)
  (MUNG-BP-LINE-AND-INTERVAL BP)
  (MARK-SEQUENCE-MODIFIED SELF :HARD T))

(DEFMETHOD (RECENT-IS-MSG-OPTION-IN-FILE-P BABYL-BUFFER) ()
  (IF (< (SEND SELF :GET :VERSION) 5)
      NIL
    (ASSOC "recent" *SAVED-INTERNAL-PROPERTIES-ALIST*)))

;;; Save a BABYL file's header -- Write an out-of-band separator.
(DEFMETHOD (SAVE-MAIL-FILE-HEADER BABYL-BUFFER :AFTER) (MAIL-FILE-SAVING-STATE)
  (IGNORE MAIL-FILE-SAVING-STATE)
  (SEND STREAM :FRESH-LINE)
  (SEND STREAM :TYO #/))
1;;; Save a message into a 0BABYL1 file.
0(DEFMETHOD (SAVE-MSG BABYL-BUFFER) (MSG MAIL-FILE-SAVING-STATE)
  (IGNORE MAIL-FILE-SAVING-STATE)
  1;; Write the 0BABYL 1specific portion of the out-of-band separator --
0  1;;    The remainder of the out-of-band separator () is written after the message by
0  1;;    an 2its-buffer-mixin1 method.
0  (CL:WRITE-CHAR #\Page STREAM)
  (CL:WRITE-CHAR #\Return STREAM)
  1;; Setup to write the message --
0  1;;    We'd like to just use 2msg-buffer-save-msg-text1 directly but we can't due to the
0  1;;    possibility of the message's original header being written as part of the 0BABYL
  1;;    specific message leader.  (Sigh)
0  (LET ((HEADER-IN-LEADER (EQ (CL:GETF (MSG-STATUS MSG) 'REFORMATTED) :IN-FILE)))
    (USING-RESOURCE (DUMPER SI:EPSILON-ENCODING-OUTPUT-STREAM NIL
							      :FLAVOR 'ZMAIL-MSG-SAVING-STREAM)
      (MULTIPLE-VALUE-BIND (MSG-NEEDS-ENCODING)
	  (PREPARE-MSG-SAVING-STREAM-FOR-MSG DUMPER STREAM MSG)
	1;; Write the message --
0	1;;    Be sure to properly handle the header wherever it is if the message is being
0	1;;    encoded.  Otherwise, header fields may not be reparsed properly or, worse still,
0	1;;    epsilon sequences will be doubled each time the message is saved to a file.
0	(FLET ((SAVE-INTERVAL (INTERVAL-ID START-BP &OPTIONAL END-BP IN-ORDER-P)
		 (DECLARE (SYS:DOWNWARD-FUNCTION))
		 (MACROLET ((SIMPLE-DUMP ()
			      '(WITH-INTERVAL-STREAM (STREAM START-BP END-BP IN-ORDER-P)
				 (STREAM-COPY-UNTIL-EOF STREAM DUMPER))))
		   (CL:CASE INTERVAL-ID
		     (:LEADER
		       (IF (AND MSG-NEEDS-ENCODING HEADER-IN-LEADER)
			   (ENCODE-MSG-HEADER-INTERVAL DUMPER START-BP END-BP IN-ORDER-P)
			 (SIMPLE-DUMP)))
		     (:HEADER
		       (IF MSG-NEEDS-ENCODING
			   (ENCODE-MSG-HEADER-INTERVAL DUMPER START-BP END-BP IN-ORDER-P)
			 (SIMPLE-DUMP)))
		     (OTHERWISE
		       (SIMPLE-DUMP))))))
	  (MAP-OVER-MSG-INTERVALS MSG #'SAVE-INTERVAL :INCLUDE-WRAPPER T
						      :USE-ORIGINAL-HEADER T)))
      1;; Finish the message.
0      (SEND DUMPER :FORCE-OUTPUT))))

(DEFMETHOD (:SET-PROPERTY-LIST BABYL-BUFFER :BEFORE) (NEW-OPTIONS)
  (LET ((CURRENT-VERSION (SEND SELF :GET :VERSION))
	(NEW-VERSION (GET (LOCF NEW-OPTIONS) :VERSION)))
    (WHEN (AND CURRENT-VERSION NEW-VERSION ( CURRENT-VERSION NEW-VERSION))
      (DOMSGS (MSG SELF)
	(UPDATE-MSG-OPTIONS-IN-FILE SELF MSG)))))

(DEFMETHOD (:PUTPROP BABYL-BUFFER :BEFORE) (VAL KEY)
  (WHEN (AND (EQ KEY :VERSION)
	     (SEND SELF :GET :VERSION)
	     ( VAL (SEND SELF :GET :VERSION)))
    (DOMSGS (MSG SELF)
      (UPDATE-MSG-OPTIONS-IN-FILE SELF MSG))))

;;; Handling of babyl status line at start of message.  Format is:
;;; <status-line>  ::= <reformed-bit> "," <basic-labels> "," <user-labels>
;;; <basic-labels> ::= (<Space> <label-name> ",")*
;;; <user-labels>  ::= (<Space> <label-name> ",")*

(DEFUN PARSE-MSG-NEW-BABYL-STATUS-LINE (LINE STATUS &AUX KEYWORDS)
  (DO ((I 0 (1+ J))
       (STATE 0)				;0 - reformatted, 1 - basic-labels,
						;2 - user-labels
       (LEN (ARRAY-ACTIVE-LENGTH LINE))
       (J) (STR) (TEM))
      (( I LEN))
    (OR (SETQ J (STRING-SEARCH-CHAR #/, LINE I LEN))
	(RETURN))
    (SETQ STR (SUBSTRING LINE I J))
    (SELECTQ STATE
      (0
       (UNLESS (STRING-EQUAL STR "0")
	 (PUTPROP STATUS ':IN-FILE 'REFORMATTED))
       (SETQ STATE 1))
      (1
       (OR (SETQ TEM (CADR (ASS #'STRING-EQUAL STR *SAVED-INTERNAL-PROPERTIES-ALIST*)))
	   (FERROR NIL "Bad status line ~A" LINE))
       (PUTPROP STATUS T TEM))
      (2
       (IF (SETQ TEM (ASS #'STRING-EQUAL STR *KEYWORD-ALIST*))
	   (SETQ TEM (CDR TEM))
	   (SETQ TEM (INTERN (STRING-UPCASE STR) SI:PKG-KEYWORD-PACKAGE))
	   (SETQ *KEYWORD-ALIST* (NCONC *KEYWORD-ALIST* (NCONS (CONS STR TEM)))))
       (PUSH TEM KEYWORDS)))
    (SETQ J (1+ J))
    (AND (= J LEN) (RETURN))
    (SELECTQ (AREF LINE J)
      (#/,
       (AND (> (SETQ STATE (1+ STATE)) 2)
	    (RETURN))
       (SETQ J (1+ J)))
      (#\SP)
      (OTHERWISE
       ;; Unix RMAIL stores labels in the status line without leading spaces.
       (DECF J))))
  (COND (KEYWORDS
	 (SETQ KEYWORDS (NREVERSE KEYWORDS))
	 (PUTPROP STATUS KEYWORDS 'KEYWORDS)
	 (PUTPROP STATUS (STRING-FROM-KEYWORDS KEYWORDS) 'KEYWORDS-STRING))))

(DEFUN UPDATE-MSG-NEW-BABYL-STATUS-LINE (LINE STATUS)
  (ARRAY-PUSH-EXTEND LINE (IF (EQ (GET STATUS 'REFORMATTED) ':IN-FILE) #/1 #/0))
  (ARRAY-PUSH-EXTEND LINE #/,)
  (LOOP FOR (NAME KEY IGNORE-P) IN *SAVED-INTERNAL-PROPERTIES-ALIST*
	DO (UNLESS IGNORE-P
	     (WHEN (GET STATUS KEY)
	       (ARRAY-PUSH-EXTEND LINE #\SP)
	       (APPEND-TO-ARRAY LINE NAME)
	       (ARRAY-PUSH-EXTEND LINE #/,))))
  (ARRAY-PUSH-EXTEND LINE #/,)
  (DOLIST (KEYWORD (GET STATUS 'KEYWORDS))
    (ARRAY-PUSH-EXTEND LINE #\SP)
    (APPEND-TO-ARRAY LINE (CAR (RASSQ KEYWORD *KEYWORD-ALIST*)))
    (ARRAY-PUSH-EXTEND LINE #/,)))

;;; This is settable, but not in the standard way
(DEFINE-NOT-SETTABLE-MAIL-FILE-OPTION :KEYWORDS)
(DEFINE-NOT-SETTABLE-MAIL-FILE-OPTION :KEYWORDS-STRING)

(DEFPROP :KEYWORDS PARSE-KEYWORDS-LIST BABYL-OPTION-PARSER)
(DEFPROP :LABELS PARSE-KEYWORDS-LIST BABYL-OPTION-PARSER)

(DEFUN PARSE-KEYWORDS-LIST (IGNORE STRING &OPTIONAL (START 0) END TEST-ONLY
					  &AUX KEYWORDS-STRING KEYWORDS NEW-KEYWORDS)
  (SETQ KEYWORDS-STRING (SUBSTRING STRING START END))
  (DO ((I0 0 (1+ I1))
       (I1) (I2) (STR))
      (NIL)
    (OR (SETQ I0 (STRING-SEARCH-NOT-SET *WHITESPACE-CHARS* KEYWORDS-STRING I0))
	(RETURN NIL))
    (SETQ I1 (STRING-SEARCH-CHAR #/, KEYWORDS-STRING I0))
    (AND (SETQ I2 (STRING-SEARCH-CHAR #/= KEYWORDS-STRING I0 I1))
	 (SETQ I0 (STRING-SEARCH-NOT-SET *WHITESPACE-CHARS* KEYWORDS-STRING (1+ I2))))
    (SETQ STR (SUBSTRING KEYWORDS-STRING I0 I1))
    (LET* ((NEW NIL)
	   (ELEM (OR (ASSOC STR *KEYWORD-ALIST*)
		     (LET* ((KEY (INTERN (STRING-UPCASE STR) SI:PKG-KEYWORD-PACKAGE))
			    (ELEM (CONS STR KEY)))
		       (SETQ NEW T)
		       (UNLESS TEST-ONLY
			 (SETQ *KEYWORD-ALIST* (NCONC *KEYWORD-ALIST* (NCONS ELEM))))
		       ELEM))))
      (IF (AND TEST-ONLY NEW)
	  (PUSH ELEM NEW-KEYWORDS)
	(PUSH ELEM KEYWORDS)))
    (OR I1 (RETURN NIL)))
  ;;Avoid writing out an empty labels line.
  (AND (NULL KEYWORDS) (NULL NEW-KEYWORDS) (SETQ KEYWORDS-STRING NIL))
  `(:KEYWORDS ,(NREVERSE KEYWORDS) :KEYWORDS-STRING ,KEYWORDS-STRING
    :NEW-KEYWORDS ,(NREVERSE NEW-KEYWORDS)))

;;; This updates the string of all keywords at the head of the file
;;; The idea is that old keywords that are still valid are kept in the old order, and new
;;; ones appended at the end.
(DEFUN (:KEYWORDS BABYL-OPTION-PRINTER) (STREAM IGNORE KEYWORDS PLIST &AUX STRING COMMA-FLAG)
  (SETQ STRING (MAKE-EMPTY-STRING 25.))
  (LET ((KEYWORDS-STRING (GET PLIST ':KEYWORDS-STRING)))
    (AND KEYWORDS-STRING
	 (DO ((I0 0 (1+ I1))
	      (I1) (I2) (STR) (KEY) (ELEM))
	     (NIL)
	   (SETQ I1 (STRING-SEARCH-CHAR #/, KEYWORDS-STRING I0)
		 I2 (STRING-SEARCH-CHAR #/= KEYWORDS-STRING I0 I1)
		 STR (SUBSTRING KEYWORDS-STRING (IF I2 (1+ I2) I0) I1)
		 KEY (INTERN (STRING-UPCASE STR) SI:PKG-KEYWORD-PACKAGE))
	   (COND ((SETQ ELEM (RASSQ KEY KEYWORDS))
		  (SETQ KEYWORDS (REMQ ELEM KEYWORDS))
		  (AND COMMA-FLAG (ARRAY-PUSH-EXTEND STRING #/,))
		  (SETQ COMMA-FLAG T)
		  (APPEND-TO-ARRAY STRING KEYWORDS-STRING I0 I1)))
	   (OR I1 (RETURN NIL)))))
  (DO ((AL KEYWORDS (CDR AL)))
      ((NULL AL))
    (AND COMMA-FLAG (ARRAY-PUSH-EXTEND STRING #/,))
    (SETQ COMMA-FLAG T)
    (APPEND-TO-ARRAY STRING (CAAR AL)))
  (PUTPROP PLIST STRING ':KEYWORDS-STRING)
  (SEND STREAM ':STRING-OUT (IF ( (GET PLIST ':VERSION) 5) "Labels:" "Keywords:"))
  (SEND STREAM ':STRING-OUT STRING))

;;; *** BEGINNING OF OLD BABYL STUFF ***
(DEFVAR *BABYL-BIT-MASK-PROPERTIES*
	'(REFORMATTED				;1
	  UNSEEN				;2 - really stored the other way
	  LOSING-HEADERS			;4
	  ANSWERED				;10
	  FILED					;20
	  ))

(DEFUN PARSE-MSG-OLD-BABYL-STATUS-LINE (LINE STATUS &AUX I)
  (WHEN (CHAR-EQUAL (AREF LINE (SETQ I 0)) #/D)
    (PUTPROP STATUS T 'DELETED)
    (SETQ I 1))
  (DO ((BITS (LOGXOR (PARSE-NUMBER LINE I NIL 8) 2))	;Check SEEN, not UNSEEN
       (L *BABYL-BIT-MASK-PROPERTIES* (CDR L))
       (N 1 (LSH N 1)))
      ((NULL L))
    (AND (BIT-TEST BITS N) (PUTPROP STATUS T (CAR L))))
  (LET ((IDX (STRING-SEARCH-CHAR #/{ LINE)))
    (AND IDX
	 (MULTIPLE-VALUE-BIND (KEYWORDS STRING) (PARSE-KEYWORDS LINE IDX)
	   (PUTPROP STATUS KEYWORDS 'KEYWORDS)
	   (PUTPROP STATUS STRING 'KEYWORDS-STRING)))))

(DEFUN PARSE-KEYWORDS (LINE IDX &AUX (LENGTH (ARRAY-ACTIVE-LENGTH LINE)) KEYWORDS)
  (DO ((I0 IDX (STRING-SEARCH-CHAR #/{ LINE I1 LENGTH))
       (I1) (STR) (KEY))
      ((NULL I0))
    (OR (SETQ I1 (STRING-SEARCH-CHAR #/} LINE (SETQ I0 (1+ I0)) LENGTH))
	(RETURN NIL))
    (SETQ STR (SUBSTRING LINE I0 I1)
	  KEY (INTERN (STRING-UPCASE STR) SI:PKG-KEYWORD-PACKAGE))
    (OR (RASSQ KEY *KEYWORD-ALIST*)
	;; Keywords not officially defined go at the end of the list
	(SETQ *KEYWORD-ALIST* (NCONC *KEYWORD-ALIST* (NCONS (CONS STR KEY)))))
    (PUSH KEY KEYWORDS))
  (SETQ KEYWORDS (NREVERSE KEYWORDS))
  (VALUES KEYWORDS (STRING-FROM-KEYWORDS KEYWORDS)))

(DEFUN UPDATE-MSG-OLD-BABYL-STATUS-LINE (LINE STATUS &AUX (BITS 10000))
  (DO ((L *BABYL-BIT-MASK-PROPERTIES* (CDR L))
       (N 1 (LSH N 1)))
      ((NULL L))
    (AND (GET STATUS (CAR L)) (SETQ BITS (LOGIOR BITS N))))
  (FORMAT LINE "~O" (LOGXOR BITS 2))		;Store SEEN, not UNSEEN
  (DOLIST (KEYWORD (GET STATUS 'KEYWORDS))
    (FORMAT LINE " {~A}" (CAR (RASSQ KEYWORD *KEYWORD-ALIST*))))
  (AND (GET STATUS 'DELETED) (ASET #/D LINE 0)))

;;; *** END OF OLD BABYL STUFF ***

(DEFMETHOD (:SAVE-ORIGINAL-HEADER BABYL-BUFFER) (MSG)
  (AND (IF *BABYL-REFORMATTING-CONTROLLED-BY-FILE*
	   (SEND SELF ':GET ':REFORMAT-HEADERS-P)
	 *REFORMAT-HEADERS-P*)
       ;; Also check that it hasn't been reformatted by BABYL
       (EQ (GET (LOCF (MSG-STATUS MSG)) 'REFORMATTED) ':IN-CORE)))

(DEFMETHOD (:REFORMAT-TEMPLATE BABYL-BUFFER) (IGNORE FORCE-P)
  (UNLESS (AND (NOT (IF *BABYL-REFORMATTING-CONTROLLED-BY-FILE*
			(SEND SELF ':GET ':REFORMAT-HEADERS-P)
		      *REFORMAT-HEADERS-P*))
	       (NOT FORCE-P))
    (OR (SEND SELF ':GET ':REFORMAT-TEMPLATE)
	'DEFAULT-REFORMAT-TEMPLATE)))

(DEFMETHOD (:SAVE-ORIGINAL-HEADER-IN-FILE-P BABYL-BUFFER) ()
  (AND *BABYL-REFORMATTING-CONTROLLED-BY-FILE*
       (EQ (SEND SELF ':GET ':REFORMAT-HEADERS-P) ':SAVE-BOTH)))

;;; This is a copy of the default version in parts.  This funny modularity is to keep
;;; the operation as atomic as possible.
(DEFMETHOD (:SET-REFORMATTED-HEADERS BABYL-BUFFER) (MSG STAT NEW-HEADERS-INTERVAL)
  (LET* ((MSG-INTERVAL (MSG-INTERVAL MSG))
	 (MSG-REAL-INTERVAL (MSG-REAL-INTERVAL MSG))
	 (HEADERS-END-BP (MSG-GET MSG 'HEADERS-END-BP))
	 (WHERE NIL))
    (UNLESS (NULL HEADERS-END-BP)
      (SETQ WHERE :IN-CORE)
      (LET* ((MSG-START-BP (INTERVAL-FIRST-BP MSG-INTERVAL))
	     (OLD-FIRST-LINE (BP-LINE MSG-START-BP))
	     (START-PREVIOUS-LINE (LINE-PREVIOUS OLD-FIRST-LINE))
	     (REAL-START-BP (INTERVAL-FIRST-BP MSG-REAL-INTERVAL))
	     (REAL-START-LINE (BP-LINE REAL-START-BP))
	     (REAL-ORIGINAL-AREA-END-LINE
	       (AND (NULL (GET STAT 'ORIGINAL-HEADERS-INTERVAL))
		    (SEND SELF :SAVE-ORIGINAL-HEADER-IN-FILE-P)
		    (LOOP FOR LINE = REAL-START-LINE THEN (LINE-NEXT LINE)
			  WHEN (STRING-EQUAL LINE "*** EOOH ***")
			    RETURN LINE)))
	     (BODY-START-LINE (BP-LINE HEADERS-END-BP))
	     (OLD-LAST-LINE (LINE-PREVIOUS BODY-START-LINE))
	     (FIRST-NEW-LINE (BP-LINE (INTERVAL-FIRST-BP NEW-HEADERS-INTERVAL)))
	     (LAST-NEW-LINE (BP-LINE (INTERVAL-LAST-BP NEW-HEADERS-INTERVAL)))
	     (NEW-INTERVAL-FOR-OLD NIL))
	;; Atomically replace the original headers with these new ones.
	(WITHOUT-INTERRUPTS
	  (SETF (LINE-PREVIOUS FIRST-NEW-LINE) START-PREVIOUS-LINE)
	  (SETF (LINE-NEXT START-PREVIOUS-LINE) FIRST-NEW-LINE)
	  (MOVE-BP MSG-START-BP FIRST-NEW-LINE 0)
	  (SETF (LINE-NEXT LAST-NEW-LINE) BODY-START-LINE)
	  (SETF (LINE-PREVIOUS BODY-START-LINE) LAST-NEW-LINE)
	  ;; Put new headers in text interval
	  (LOOP FOR LINE FIRST FIRST-NEW-LINE THEN (LINE-NEXT LINE)
		UNTIL (EQ LINE BODY-START-LINE)
		DO (SETF (LINE-NODE LINE) MSG-INTERVAL))
	  (IF (NULL REAL-ORIGINAL-AREA-END-LINE)
	      ;; Second or subsequent reformattings -- Determine where the originals from
	      ;;    the first reformatting were placed so that the REFORMATTED property
	      ;;    will be properly maintained.
	      (LET ((ORIGINAL-HEADERS (GET STAT 'ORIGINAL-HEADERS-INTERVAL)))
		(WHEN ORIGINAL-HEADERS
		  (WHEN (EQ (LINE-NODE (BP-LINE (INTERVAL-FIRST-BP ORIGINAL-HEADERS)))
			    MSG-REAL-INTERVAL)
		    (SETQ WHERE :IN-FILE))))
	    ;; First reformatting -- Save original headers in the message if requested and
	    ;;    reflect this in the status line in case :UPDATE-MSG-OPTIONS-IN-FILE
	    ;;    isn't called before saving (i.e., a background save).
	    (SETF (LINE-PREVIOUS OLD-FIRST-LINE) REAL-START-LINE)
	    (SETF (LINE-NEXT REAL-START-LINE) OLD-FIRST-LINE)
	    (SETF (LINE-PREVIOUS REAL-ORIGINAL-AREA-END-LINE) OLD-LAST-LINE)
	    (SETF (LINE-NEXT OLD-LAST-LINE) REAL-ORIGINAL-AREA-END-LINE)
	    (SETQ WHERE :IN-FILE
		  NEW-INTERVAL-FOR-OLD MSG-REAL-INTERVAL)
	    (ASET #/1 REAL-START-LINE 0))
	  ;; First reformatting -- Create the ORIGINAL-HEADERS-INTERVAL property.
	  (WHEN (NULL (GET STAT 'ORIGINAL-HEADERS-INTERVAL))
	    (LET ((NEW-INTERVAL (CREATE-INTERVAL)))
	      (MOVE-BP (INTERVAL-FIRST-BP NEW-INTERVAL) OLD-FIRST-LINE 0)
	      (IF REAL-ORIGINAL-AREA-END-LINE
		  (MOVE-BP (INTERVAL-LAST-BP NEW-INTERVAL) REAL-ORIGINAL-AREA-END-LINE 0)
		(LET ((LINE (BP-LINE (INTERVAL-LAST-BP NEW-INTERVAL))))
		  (SETF (LINE-PREVIOUS LINE) OLD-LAST-LINE)
		  (SETF (LINE-NEXT OLD-LAST-LINE) LINE))
		(SETQ NEW-INTERVAL-FOR-OLD NEW-INTERVAL))
	      (PUTPROP STAT NEW-INTERVAL 'ORIGINAL-HEADERS-INTERVAL)))
	  ;; Put the old headers into new interval, or into limbo if they are being removed
	  ;; completely.
	  (WHEN (NULL NEW-INTERVAL-FOR-OLD)
	    (SETQ NEW-INTERVAL-FOR-OLD (CREATE-INTERVAL (CREATE-BP OLD-FIRST-LINE 0 :NORMAL
								   MSG-INTERVAL)
							(CREATE-BP OLD-LAST-LINE 0 :MOVES
								   MSG-INTERVAL))))
	  (LOOP FOR LINE = OLD-FIRST-LINE THEN (LINE-NEXT LINE)
		DO (SETF (LINE-NODE LINE) NEW-INTERVAL-FOR-OLD)
		UNTIL (EQ LINE OLD-LAST-LINE)))))
    WHERE))

;;; If a message was reformatted by the inbox, save the original headers
;;; away in the text if requested.
(DEFMETHOD (:NEW-MSG BABYL-BUFFER :AFTER) (MSG &OPTIONAL FROM-INBOX)
  (WHEN FROM-INBOX
    (LET* ((MSG-REAL-INTERVAL (MSG-REAL-INTERVAL MSG))
	   (ORIGINAL-INTERVAL (MSG-GET MSG 'ORIGINAL-HEADERS-INTERVAL)))
      (WHEN (AND ORIGINAL-INTERVAL
		 (SEND SELF ':SAVE-ORIGINAL-HEADER-IN-FILE-P))
	(LET* ((REAL-START-BP (INTERVAL-FIRST-BP MSG-REAL-INTERVAL))
	       (REAL-START-LINE (BP-LINE REAL-START-BP))
	       (REAL-ORIGINAL-AREA-END-LINE
		 (LOOP FOR LINE = REAL-START-LINE THEN (LINE-NEXT LINE)
		       WHEN (STRING-EQUAL LINE "*** EOOH ***")
		       RETURN LINE))
	       (ORIGINAL-FIRST-LINE (BP-LINE (INTERVAL-FIRST-BP ORIGINAL-INTERVAL)))
	       (ORIGINAL-LAST-BP (INTERVAL-LAST-BP ORIGINAL-INTERVAL))
	       (ORIGINAL-LAST-LINE (LINE-PREVIOUS (BP-LINE ORIGINAL-LAST-BP))))
	  (WITHOUT-INTERRUPTS
	    (SETF (LINE-PREVIOUS ORIGINAL-FIRST-LINE) REAL-START-LINE)
	    (SETF (LINE-NEXT REAL-START-LINE) ORIGINAL-FIRST-LINE)
	    (SETF (LINE-PREVIOUS REAL-ORIGINAL-AREA-END-LINE) ORIGINAL-LAST-LINE)
	    (SETF (LINE-NEXT ORIGINAL-LAST-LINE) REAL-ORIGINAL-AREA-END-LINE)
	    (MOVE-BP ORIGINAL-LAST-BP REAL-ORIGINAL-AREA-END-LINE 0)
	    (LOOP FOR LINE = ORIGINAL-FIRST-LINE THEN (LINE-NEXT LINE)
		  UNTIL (EQ LINE REAL-ORIGINAL-AREA-END-LINE)
		  DO (SETF (LINE-NODE LINE) MSG-REAL-INTERVAL)))
	  (ASET #/1 REAL-START-LINE 0)
	  (MSG-PUT MSG ':IN-FILE 'REFORMATTED))))))

;;; T(w)enex mail files.  Each message has one status line of the form
;;; <received-date>,<byte-count>;bits.  E.g.
;;; 30-Jan-81 16:53:05-EST,129;000000000001

(DEFFLAVOR TENEX-BUFFER-MIXIN () (MSG-BUFFER))

(DEFMETHOD (:FORMAT-NAME TENEX-BUFFER-MIXIN) () "Tenex mail")					;Always APPEND-P

(ADD-MAIL-BUFFER-FLAVOR 'FILE-TENEX-BUFFER "Tenex" "Tops-20 MM format.")

(DEFFLAVOR FILE-TENEX-BUFFER () (TENEX-BUFFER-MIXIN FILE-MAIL-BUFFER))

(DEFVAR *TENEX-BIT-MASK-PROPERTIES*
	'(UNSEEN				;1 - really the other way around
	  DELETED				;2
	  ALWAYS-SHOW				;4
	  ANSWERED))				;10

1;;; Interprets what is purported to be a Tenex/TOPS-20 message status line.
0(DEFUN-IN-FLAVOR (PARSE-PROBABLE-TENEX-STATUS-LINE TENEX-BUFFER-MIXIN) (LINE LENGTH)
  (DECLARE (VALUES IS-STATUS-LINE RECEIVED-DATE BYTE-COUNT MSG-FLAGS))
  (LET* ((COMMA-IDX (%STRING-SEARCH-CHAR #/, LINE 0 LENGTH))
	 (SEMI-IDX (WHEN COMMA-IDX (%STRING-SEARCH-CHAR #/; LINE (1+ COMMA-IDX) LENGTH))))
    (IF COMMA-IDX
	(CONDITION-CASE ()
	     (VALUES T
		     (PARSE-RFC822-DATE-TIME LINE 0 COMMA-IDX)
		     (CL:PARSE-INTEGER LINE :START (1+ COMMA-IDX) :END SEMI-IDX
					    :RADIX 10. :JUNK-ALLOWED NIL)
		     (CL:PARSE-INTEGER LINE :START (1+ SEMI-IDX) :END NIL
					    :RADIX 8.
					    :JUNK-ALLOWED NIL :SIGN-ALLOWED NIL))
	   (ERROR
	     (VALUES NIL NIL NIL NIL)))
	(VALUES NIL NIL NIL NIL))))

1;;; Messages in Tenex/TOPS-20 files have a byte count at the front --
;;;   The byte count can be screwed up by rubouts in the file turning themselves and the next
;;;   character into a single LISPM character.  Additionally, the byte count includes the
;;;   CRLFs at the end of each line.
0(DEFMETHOD (LINE-END-OF-MSG-P TENEX-BUFFER-MIXIN) (LINE LENGTH STATE EOF)
  (COND ((NULL STATE)
	 1;; First time for this message -- Get the byte count.
0	 (MULTIPLE-VALUE-BIND (IS-STATUS-LINE IGNORE BYTE-COUNT IGNORE)
	     (PARSE-PROBABLE-TENEX-STATUS-LINE LINE LENGTH)
	   (IF IS-STATUS-LINE
	       (VALUES (= BYTE-COUNT 0) BYTE-COUNT)
	       (VALUES NIL :NO-STATUS-LINE))))
	((AND EOF (ZEROP LENGTH))
	 1;; End of file in the middle of a message terminates it.
0	 (VALUES T NIL))
	((EQ STATE :NO-STATUS-LINE)
	 1;; No status line was found -- Keep looking until we find one.
0	 (MULTIPLE-VALUE-BIND (IS-STATUS-LINE IGNORE IGNORE IGNORE)
	     (PARSE-PROBABLE-TENEX-STATUS-LINE LINE LENGTH)
	   (IF IS-STATUS-LINE
	       (VALUES :START-NEXT NIL)
	       (VALUES NIL :NO-STATUS-LINE))))
	((< STATE LENGTH)
	 1;; Message terminates in the middle of this line.
0	 (LET ((NEW-LINE (MAKE-ARRAY (- LENGTH STATE)
				     :TYPE 'ART-STRING
				     :AREA *ZMAIL-MSG-LINE-AREA*
				     :LEADER-LENGTH LINE-LEADER-SIZE)))
	   (COPY-ARRAY-PORTION LINE STATE LENGTH NEW-LINE 0 (- LENGTH STATE))
	   (SETF (LINE-LENGTH NEW-LINE) (- LENGTH STATE))
	   (VALUES STATE NIL NEW-LINE)))
	(T
	 1;; This line is part of the message (and may also terminate the message).
0	 (SETQ STATE (- STATE (+ LENGTH 2)))
	 (VALUES ( STATE 0) STATE))))

1;;; Parse the Tenex/TOPS-20 message status line ...
0(DEFMETHOD (PARSE-MSG TENEX-BUFFER-MIXIN :BEFORE) (MSG STAT)
  (LET* ((LINE (BP-LINE (MSG-REAL-START-BP MSG)))
	 (LENGTH (LINE-LENGTH LINE)))
    (MULTIPLE-VALUE-BIND (IS-STATUS-LINE RECEIVED-DATE IGNORE MSG-FLAGS)
	(PARSE-PROBABLE-TENEX-STATUS-LINE LINE LENGTH)
      (COND (IS-STATUS-LINE
	     (PUTPROP STAT RECEIVED-DATE 'RECEIVED-DATE)
	     (DO ((BITS (LOGXOR MSG-FLAGS 1))
		  (L *TENEX-BIT-MASK-PROPERTIES* (CDR L))
		  (N 1 (LSH N 1)))
		 ((NULL L))
	       (WHEN (BIT-TEST BITS N) (PUTPROP STAT T (CAR L))))
	     (MOVE-BP (MSG-START-BP MSG) (LINE-NEXT LINE) 0))
	    (T
	     (CONDITION-CASE (FERROR)
		  (FERROR "Message does not start with a valid Tenex//TOPS-20 status line.")
		(FERROR
		  (PUTPROP STAT FERROR 'UNPARSEABLE))))))))

(DEFMETHOD (:NEW-MSG-HEADER-AREA FILE-TENEX-BUFFER) ()
  #\CR)

1;;; Update the Tenex/TOPS-20 status line at the front of the message.
0(DEFMETHOD (UPDATE-MSG-OPTIONS-IN-FILE FILE-TENEX-BUFFER) (MSG)
  (LET* ((STATUS (ASSURE-MSG-PARSED MSG))
	 (STATUS-LINE-BP (MSG-REAL-START-BP MSG))
	 (STATUS-LINE (BP-LINE STATUS-LINE-BP))
	 (DATE
	   (LET ((RAW-DATE (SECOND (GETL STATUS '(RECEIVED-DATE :DATE)))))
	     (COND ((NUMBERP RAW-DATE) RAW-DATE)
		   ((LISTP RAW-DATE) (FIRST RAW-DATE))
		   (T (TIME:GET-UNIVERSAL-TIME)))))
	 (BITS
	   (DO ((L *TENEX-BIT-MASK-PROPERTIES* (REST1 L))
		(BITS 0)
		(N 1 (LSH N 1)))
	       ((NULL L) BITS)
	     (WHEN (GET STATUS (FIRST L)) (SETQ BITS (LOGIOR BITS N))))))
    (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR NIL MSG-IS-DST)
	(TIME:DECODE-UNIVERSAL-TIME DATE TIME:*TIMEZONE*)
      (LET ((BP (MSG-REAL-END-BP MSG)))
	(UNLESS (ZEROP (BP-INDEX BP))
	  (INSERT BP #\RETURN)))
      (SETF (LINE-LENGTH STATUS-LINE) 0)
      (FORMAT STATUS-LINE "~2D-~A-~D ~2,'0D:~2,'0D:~2,'0D~A,~D;~12,'0O"
	      DAY (TIME:MONTH-STRING MONTH :SHORT) YEAR
	      HOURS MINUTES SECONDS
	      (LET ((TIMEZONE-STRING (TIME:TIMEZONE-STRING TIME:*TIMEZONE* MSG-IS-DST NIL T)))
		1;; Tenex/TOPS-20 always expect a leading hyphen in the timezone string.
0		(WHEN (CHAR-EQUAL (AREF TIMEZONE-STRING 0) #\Space)
		  (SETF (AREF TIMEZONE-STRING 0) #\-))
		TIMEZONE-STRING)
	      (COUNT-PDP10-CHARS-IN-MSG MSG)
	      (LOGXOR BITS 1))
      (MUNG-BP-LINE-AND-INTERVAL STATUS-LINE-BP)
      (MARK-SEQUENCE-MODIFIED SELF :HARD T))))

1;;; Special stream flavor that just counts characters.
0(DEFFLAVOR PDP10-CHARACTER-COUNTING-STREAM
	((CHARACTER-COUNT 0))
	(SI:CHARACTER-STREAM SI:OUTPUT-STREAM)
  (:READABLE-INSTANCE-VARIABLES CHARACTER-COUNT)
  (:WRITABLE-INSTANCE-VARIABLES CHARACTER-COUNT))

(DEFMETHOD (:TYO PDP10-CHARACTER-COUNTING-STREAM) (CHAR)
  (INCF CHARACTER-COUNT)
  (WHEN (CHAR-EQUAL CHAR #\Return)
    (INCF CHARACTER-COUNT)))

(COMPILE-FLAVOR-METHODS PDP10-CHARACTER-COUNTING-STREAM)

(DEFRESOURCE PDP10-CHARACTER-COUNTING-STREAM ()
  :CONSTRUCTOR (MAKE-INSTANCE 'PDP10-CHARACTER-COUNTING-STREAM)
  :INITIALIZER (SETF (PDP10-CHARACTER-COUNTING-STREAM-CHARACTER-COUNT OBJECT) 0)
  :INITIAL-COPIES 0)

1;;; Count the number of 0PDP-101 characters in a message --
;;;     Counts each0 #\Return1 as two characters as they are converted to0 CR LF1 when written.
;;;     Also counts any characters added when the message is epsilon encoded --
;;;        In order to make this count properly, we must exactly simulate the actual
;;;        encoding process used when the message is actually written.  However, we'll
;;;        "write" the message to a special flavor of stream that just counts the number
;;;        of characters written.
0(DEFUN COUNT-PDP10-CHARS-IN-MSG (MSG)
  (USING-RESOURCE (COUNTING-STREAM PDP10-CHARACTER-COUNTING-STREAM)
    (USING-RESOURCE (ENCODER SI:EPSILON-ENCODING-OUTPUT-STREAM NIL
							      :FLAVOR 'ZMAIL-MSG-SAVING-STREAM)

      (MULTIPLE-VALUE-BIND (MSG-NEEDS-ENCODING)
	  (PREPARE-MSG-SAVING-STREAM-FOR-MSG ENCODER COUNTING-STREAM MSG)
	1;; Count the characters in the message --
0	1;;    Be sure to properly handle the header if the message is being encoded.
0	(FLET ((COUNT-INTERVAL (INTERVAL-ID START-BP &OPTIONAL END-BP IN-ORDER-P)
		 (DECLARE (SYS:DOWNWARD-FUNCTION))
		 (IF (AND MSG-NEEDS-ENCODING (EQ INTERVAL-ID :HEADER))
		     (ENCODE-MSG-HEADER-INTERVAL ENCODER START-BP END-BP IN-ORDER-P)
		     (WITH-INTERVAL-STREAM (STREAM START-BP END-BP IN-ORDER-P)
		       (STREAM-COPY-UNTIL-EOF STREAM ENCODER)))))
	  (MAP-OVER-MSG-INTERVALS MSG #'COUNT-INTERVAL :USE-ORIGINAL-HEADER T)
	  (COUNT-INTERVAL :TRAILER (MSG-END-BP MSG) (MSG-REAL-END-BP MSG) T)))
      (SEND ENCODER :FORCE-OUTPUT))
    (PDP10-CHARACTER-COUNTING-STREAM-CHARACTER-COUNT COUNTING-STREAM)))

(DEFMETHOD (:MAIL-FILE-REPARSABLE-P TENEX-BUFFER-MIXIN) () T)

(DEFFLAVOR TENEX-INBOX-BUFFER () (TENEX-BUFFER-MIXIN INBOX-BUFFER))

;;; Unix mail files.

;;; UNIX format mail file methods
(DEFFLAVOR UNIX-BUFFER-MIXIN () (MSG-BUFFER))

(DEFMETHOD (:FORMAT-NAME UNIX-BUFFER-MIXIN) () "Unix mail")

(DEFMETHOD (:MAIL-FILE-REPARSABLE-P UNIX-BUFFER-MIXIN) () T)

(DEFCONST *UNIX-FROM-MARKER* "From ")

;;; UNIX messages end before the next "From " line.
(DEFMETHOD (LINE-END-OF-MSG-P UNIX-BUFFER-MIXIN) (LINE IGNORE STATE EOF)
  (VALUES (COND ((NULL STATE) NIL)
		(EOF (LINE-LENGTH LINE))
		((STRING= LINE *UNIX-FROM-MARKER* 0 0 (STRING-LENGTH *UNIX-FROM-MARKER*))
		 ':START-NEXT))
	  T))

;;; Move the start bp to after the "From " line, and the end BP to before
;;; the blank line marking the end.  Remember the parse on the plist for
;;; UPDATE-MSG-OPTIONS-IN-FILE.
(DEFMETHOD (PARSE-MSG UNIX-BUFFER-MIXIN :BEFORE) (MSG STAT &AUX LINE FROM-HEADER)
  (SETQ LINE (BP-LINE (MSG-REAL-START-BP MSG)))
  (WHEN (PLUSP (LINE-LENGTH LINE))
    (SETQ FROM-HEADER (PARSE-UNIX-FROM-HEADER LINE))
    (PUTPROP STAT FROM-HEADER 'UNIX-FROM-HEADER))
  (WHEN (LINE-NEXT LINE)			;Don't try to do anything with null msg
    (MOVE-BP (MSG-START-BP MSG) (LINE-NEXT LINE) 0)
    (FIXUP-UNIX-BUFFER-TRAILER MSG)))

(DEFUN FIXUP-UNIX-BUFFER-TRAILER (MSG)
  (LOOP WITH END-BP = (MSG-END-BP MSG)
	WITH START-BP = (MSG-START-BP MSG)
	WITH REAL-END-BP = (MSG-REAL-END-BP MSG)
	FOR L FIRST (BP-LINE END-BP) THEN (LINE-PREVIOUS L)
	WITH NEW-END
	UNTIL (OR (EQ L (BP-LINE START-BP))	;Empty msg?
		  (PLUSP (LINE-LENGTH L)))
	FINALLY (SETQ NEW-END (CREATE-BP L (LINE-LENGTH L)))
		;; If there isn't any valid text, the headers end may be in the blank lines
	        ;; that we will flush.  Keep the bp put if it's away from this area, else
	        ;; get it between the two blank lines we put in.
		(LET ((HEADERS-END-BP (GET (LOCF (MSG-STATUS MSG)) 'HEADERS-END-BP)))
		  (WITH-BP (SAVED-HEADERS-END (OR HEADERS-END-BP END-BP) :MOVES)
		    (DELETE-INTERVAL NEW-END REAL-END-BP T)
		    (INSERT REAL-END-BP #\CR)
		    (SETF (BP-STATUS SAVED-HEADERS-END) :NORMAL)
		    (INSERT REAL-END-BP #\CR)
		    (WHEN HEADERS-END-BP
		      (MOVE-BP HEADERS-END-BP SAVED-HEADERS-END))))
		(MOVE-BP END-BP (LINE-PREVIOUS (BP-LINE REAL-END-BP)) 0)))

;;; Reformat here:
;;; If we only had a "From " line, fill in an RFC733 "From:" and "Date:".
;;; We should also check for unix-style recipients and fix those, plus
;;; /bin/mail lack of blank line after header.
(DEFMETHOD (PARSE-MSG UNIX-BUFFER-MIXIN :AFTER) (MSG STAT &AUX FROM-HEADER DATE FROM HOST
							       NEED-SUMMARY-UPDATE BP)
  (SETQ FROM-HEADER (GET STAT 'UNIX-FROM-HEADER)
	HOST (SEND PATHNAME ':HOST))
  (UNLESS (ERRORP FROM-HEADER)
    (SETQ BP (COPY-BP (MSG-START-BP MSG)))
    (UNLESS (GET STAT 'RECEIVED-DATE)
      (WHEN (SETQ DATE (SECOND FROM-HEADER))
	(PUTPROP STAT DATE 'RECEIVED-DATE)))
    (UNLESS (GET STAT ':DATE)
      (WHEN (SETQ DATE (SECOND FROM-HEADER))
	(PUTPROP STAT DATE ':DATE)
	(LET ((STRING (WITH-OUTPUT-TO-STRING (STR)
			(PRINT-DATE-HEADER STR DATE "Date" '(:INTERNET-FORMAT T) 70.))))
	  (INSERT-MOVING BP STRING))
	(SETQ NEED-SUMMARY-UPDATE T)))
    (UNLESS (GET STAT ':FROM)
      (WHEN (SETQ FROM (FIRST FROM-HEADER))
	(SETQ NEED-SUMMARY-UPDATE T)
	(FILL-IN-UNSUPPLIED-HOSTS (FIRST FROM-HEADER) HOST)
	(PUTPROP STAT FROM ':FROM)
	(LET ((STRING (WITH-OUTPUT-TO-STRING (STR)
			(PRINT-ADDRESS-HEADER STR FROM "From" NIL 70.))))
	  (INSERT-MOVING BP STRING))))
    (WHEN NEED-SUMMARY-UPDATE
      (INSERT-MOVING BP #\CR)
      (PUTPROP STAT (COPY-BP BP :NORMAL (MSG-REAL-INTERVAL MSG)) 'HEADERS-END-BP)))
  (WHEN (FILL-IN-UNSUPPLIED-HOSTS (GET STAT ':TO) HOST)
    (SETQ NEED-SUMMARY-UPDATE T))
  (WHEN (FILL-IN-UNSUPPLIED-HOSTS (GET STAT ':CC) HOST)
    (SETQ NEED-SUMMARY-UPDATE T))
  (WHEN (FILL-IN-UNSUPPLIED-HOSTS (GET STAT ':FROM) HOST)
    (SETQ NEED-SUMMARY-UPDATE T))
  (WHEN NEED-SUMMARY-UPDATE (SET-MSG-SUMMARY-LINE MSG STAT)))

;;; If no host was supplied, fill it in
(DEFUN FILL-IN-UNSUPPLIED-HOSTS (ADDRESSES HOST)
  ;; Fill in the unsupplied host
  (LOOP WITH HOSTSPEC = `(:OBJECT ,HOST)
	FOR SPEC IN ADDRESSES
	FOR HOSTL = (GETL (LOCF SPEC) '(:HOST))
	WHEN (AND HOSTL (NULL (SECOND HOSTL)))
	  DO (SETF (SECOND HOSTL) HOSTSPEC)))

;;; Parse a UNIX message.
(DEFMETHOD (PARSE-MSG-TEXT UNIX-BUFFER-MIXIN) (MSG MSG-STATUS)
  (LET ((ORIGINAL (GET MSG-STATUS 'ORIGINAL-HEADERS-INTERVAL)))
    (IF (NULL ORIGINAL)
	(PARSE-UNIX-MSG-TEXT (MSG-INTERVAL MSG))
      (VALUES (PARSE-UNIX-MSG-TEXT ORIGINAL) (GET-MSG-HEADERS-END-BP MSG)))))

(DEFUN PARSE-UNIX-MSG-TEXT (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (LET* ((LINE (BP-LINE START-BP))
	 (UNIX-HEADER
	   (WHEN (STRING-EQUAL-START LINE *UNIX-FROM-MARKER*)
	     (PARSE-UNIX-FROM-HEADER LINE)))
	 (START-BP (IF UNIX-HEADER
		       (BEG-LINE START-BP 1)
		     START-BP)))
    (MULTIPLE-VALUE-BIND (HEADERS HEADERS-END-BP)
	(PARSE-HEADERS-INTERVAL START-BP END-BP T 'FIRST-NON-HEADER)
      (WHEN UNIX-HEADER
	(SETF (CL:GETF HEADERS 'UNIX-FROM-HEADER) UNIX-HEADER)
	(WHEN (ERRORP UNIX-HEADER)
	  (PUSH UNIX-HEADER (CL:GETF HEADERS 'LOSING-HEADERS))))
      (VALUES HEADERS HEADERS-END-BP))))

(DEFUN PARSE-UNIX-FROM-HEADER (LINE)
  (CONDITION-CASE (ERROR)
      (LET* ((START (STRING-LENGTH *UNIX-FROM-MARKER*))
	     (END (STRING-SEARCH #\SP LINE START)))
	(LIST (PARSE-ADDRESSES LINE START END)
	      (AND END (TIME:PARSE-UNIVERSAL-TIME LINE (1+ END)))))
    ((PARSE-ERROR TIME:PARSE-ERROR) ERROR)))

(ADD-MAIL-BUFFER-FLAVOR 'UNIX-MAIL-BUFFER "Unix" "Standard UNIX format.")

(DEFFLAVOR UNIX-MAIL-BUFFER () (UNIX-BUFFER-MIXIN FILE-MAIL-BUFFER))

(DEFMETHOD (:NEW-MSG-HEADER-AREA UNIX-MAIL-BUFFER) ()
  "
")

;;; Inbox pathnames for a UNIX mail file --
;;;    Only allow the default inbox based on the mail file's pathname.
(DEFMETHOD (INBOX-PATHNAMES UNIX-MAIL-BUFFER) ()
  (LET ((DEFAULT-INBOX-PATHNAME (DEFAULT-INBOX-PATHNAME PATHNAME)))
    (IF DEFAULT-INBOX-PATHNAME (LIST DEFAULT-INBOX-PATHNAME))))

;;; Be sure "From " line is here!  File is not valid without it.
(DEFMETHOD (UPDATE-MSG-OPTIONS-IN-FILE UNIX-MAIL-BUFFER) (MSG)
  (LET* ((STAT (ASSURE-MSG-PARSED MSG))
	 (UNIX-HEADER (GET STAT 'UNIX-FROM-HEADER))
	 (FROM (GET STAT :FROM))
	 (DATE (GET STAT :DATE))
	 (RECEIVED (GET STAT 'RECEIVED-DATE)))
    (WHEN (LISTP DATE)				;Multi-date messages...
      (SETQ DATE (LOOP FOR D IN DATE
		       MINIMIZE D)))
    (WHEN (LISTP RECEIVED)			;Is this one possible?  Just in case.
      (SETQ DATE (LOOP FOR D IN RECEIVED
		       MINIMIZE D)))
    (WHEN (ERRORP UNIX-HEADER)
      (SETQ UNIX-HEADER `(,(UNIX-DEFAULT-MY-ADDRESS)
			  ,(OR RECEIVED
			       DATE
			       (TIME:GET-UNIVERSAL-TIME)))))
    (LET ((OLD-FROM (FIRST UNIX-HEADER)))
      (LET* ((RECEIVED-DATE (OR RECEIVED
				(SECOND UNIX-HEADER)
				DATE
				(TIME:GET-UNIVERSAL-TIME)))
	     (START-BP (MSG-REAL-START-BP MSG))
	     (LINE (BP-LINE START-BP)))
	(UNLESS (AND (= (LENGTH FROM) (LENGTH OLD-FROM))
		     (STRING-EQUAL-START LINE *UNIX-FROM-MARKER*)
		     (LOOP FOR X IN FROM AND Y IN OLD-FROM
			   ALWAYS (LOOP FOR IND IN '(:NAME :HOST)
					ALWAYS (EQUAL (GET (LOCF X) IND)
						      (GET (LOCF Y) IND)))))
	  (SETQ OLD-FROM (LIST (OR FROM (UNIX-DEFAULT-MY-ADDRESS))
			       RECEIVED-DATE))
	  (COND ((STRING-EQUAL-START LINE *UNIX-FROM-MARKER*)
		 (SETF (LINE-LENGTH LINE) 0))
		((ZEROP (LINE-LENGTH LINE)))
		(T
		 (INSERT START-BP #\CR)
		 (SETQ LINE (BP-LINE START-BP))))
	  (WITH-OUTPUT-TO-STRING (STR LINE)
	    (SEND STR :STRING-OUT *UNIX-FROM-MARKER*)
	    (PRINT-ADDRESS-LIST FROM STR)
	    (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
		(TIME:DECODE-UNIVERSAL-TIME RECEIVED-DATE)
	      (FORMAT STR "  ~A ~A ~2D ~2,'0D:~2,'0D:~2,'0D ~D"
		      (TIME:DAY-OF-THE-WEEK-STRING DAY-OF-THE-WEEK :SHORT)
		      (TIME:MONTH-STRING MONTH :SHORT)
		      DAY HOURS MINUTES SECONDS (+ YEAR 1900.))))
	  (MOVE-BP (MSG-START-BP MSG) (LINE-NEXT LINE) 0)
	  (MUNG-BP-LINE-AND-INTERVAL START-BP)
	  (PUTPROP STAT OLD-FROM 'UNIX-FROM-HEADER)
	  (MARK-SEQUENCE-MODIFIED SELF :HARD T)))))
  (FIXUP-UNIX-BUFFER-TRAILER MSG))

(DEFUN UNIX-DEFAULT-MY-ADDRESS ()
  `((:USER ,SI:*USER*)))

(DEFFLAVOR UNIX-INBOX () (UNIX-BUFFER-MIXIN INBOX-BUFFER))

;;; Any message from a UNIX inbox is unseen ...
(DEFMETHOD (PARSE-MSG UNIX-INBOX :BEFORE) (MSG STAT)
  (IGNORE MSG)
  (PUTPROP STAT T 'UNSEEN))
