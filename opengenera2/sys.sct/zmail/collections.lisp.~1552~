;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; Lisp Machine Mail Reader -- Collection primitives and commands

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Presentation types

0(SCL:DEFINE-PRESENTATION-TYPE SEQUENCE ()
   :NO-DEFTYPE T
   :PARSER ((STREAM &KEY TYPE ORIGINAL-TYPE INITIALLY-DISPLAY-POSSIBILITIES)
	    (VALUES
	      (LET* ((SEQUENCE-FLAVOR (DW:PRESENTATION-TYPE-NAME TYPE))
		     (SELECTOR (COND ((CL:SUBTYPEP SEQUENCE-FLAVOR 'MSG-BUFFER) :BUFFER)
				     ((CL:SUBTYPEP SEQUENCE-FLAVOR 'COLLECTION) :COLLECTION)
				     (T :ANY))))
		(DW:COMPLETING-FROM-SUGGESTIONS (STREAM :TYPE TYPE
							:INITIALLY-DISPLAY-POSSIBILITIES
							  INITIALLY-DISPLAY-POSSIBILITIES)
		  (DOLIST (SEQUENCE *SEQUENCE-LIST*)
		    (WHEN (CL:CASE SELECTOR
			    (:BUFFER (SEQUENCE-BUFFER-P SEQUENCE))
			    (:COLLECTION (NOT (SEQUENCE-BUFFER-P SEQUENCE)))
			    (:ANY T))
		      (DW:SUGGEST (IF (SEQUENCE-BUFFER-P SEQUENCE)
				      (SEND (MSG-BUFFER-PATHNAME SEQUENCE) :STRING-FOR-EDITOR)
				      (SEQUENCE-NAME SEQUENCE))
				  SEQUENCE)))))
	      ORIGINAL-TYPE))
   :PRINTER ((SEQUENCE STREAM)
	     (CL:WRITE-STRING (IF (SEQUENCE-BUFFER-P SEQUENCE)
				  (SEND (MSG-BUFFER-PATHNAME SEQUENCE) :STRING-FOR-EDITOR)
				  (SEQUENCE-NAME SEQUENCE))
			      STREAM))
   :DESCRIBER ((STREAM &KEY TYPE)
	       (CL:WRITE-STRING
		 (LET ((SEQUENCE-FLAVOR (DW:PRESENTATION-TYPE-NAME TYPE)))
		   (COND ((CL:SUBTYPEP SEQUENCE-FLAVOR 'MSG-BUFFER) "a mail file buffer")
			 ((CL:SUBTYPEP SEQUENCE-FLAVOR 'COLLECTION) "a message collection")
			 (T "a message sequence")))
		 STREAM)))

(SCL:DEFINE-PRESENTATION-TYPE UNLOADED-MAIL-FILE ()
   :EXPANDER 'FS:PATHNAME
   :PARSER ((STREAM &KEY TYPE ORIGINAL-TYPE INITIALLY-DISPLAY-POSSIBILITIES)
	    (VALUES
	      (MULTIPLE-VALUE-BIND (IGNORE IGNORE UNLOADED-FILES)
		  (GET-SEQUENCE-ALISTS T)
		(DW:COMPLETING-FROM-SUGGESTIONS (STREAM :TYPE TYPE
							:INITIALLY-DISPLAY-POSSIBILITIES
						          INITIALLY-DISPLAY-POSSIBILITIES)
		  (DOLIST (UNLOADED-FILE UNLOADED-FILES)
		    (DW:SUGGEST (CAR UNLOADED-FILE) (CDR UNLOADED-FILE)))))
	      ORIGINAL-TYPE))
   :PRINTER ((FILE STREAM)
	     (CL:WRITE-STRING (SEND FILE :STRING-FOR-EDITOR) STREAM))
   :DESCRIPTION "an unloaded mail file")

(SCL:DEFINE-PRESENTATION-TYPE SEQUENCE-OR-UNLOADED-MAIL-FILE ((&OPTIONAL
								(SEQUENCE-FLAVOR 'SEQUENCE)))
   :ABBREVIATION-FOR `((OR ,SEQUENCE-FLAVOR UNLOADED-MAIL-FILE))
   :PARSER ((STREAM &KEY ORIGINAL-TYPE DEFAULT INITIALLY-DISPLAY-POSSIBILITIES)
	    (MULTIPLE-VALUE-BIND (CHOICE IGNORE AV-VALUE)
		(SCL:ACCEPT `((OR ,SEQUENCE-FLAVOR UNLOADED-MAIL-FILE))
			    :STREAM STREAM
			    :PROMPT NIL
			    :DEFAULT DEFAULT
			    :INITIALLY-DISPLAY-POSSIBILITIES INITIALLY-DISPLAY-POSSIBILITIES)
	      (VALUES CHOICE ORIGINAL-TYPE AV-VALUE)))
   :PRINTER ((OBJECT STREAM)
	     (CL:ETYPECASE OBJECT
	       (SEQUENCE
		 (SCL:PRESENT OBJECT SEQUENCE-FLAVOR :STREAM STREAM))
	       (FS:PATHNAME
		 (SCL:PRESENT OBJECT 'UNLOADED-MAIL-FILE :STREAM STREAM))))
   :DESCRIBER ((STREAM)
	       (CL:WRITE-STRING
		 (COND ((CL:SUBTYPEP SEQUENCE-FLAVOR 'MSG-BUFFER) "a mail file buffer")
		       ((CL:SUBTYPEP SEQUENCE-FLAVOR 'COLLECTION) "a message collection")
		       (T "a message sequence"))
		 STREAM)))

;;; Primitives for creating and killing collections (sequences)

;;; Creating ...

(DEFUN MAKE-SEQUENCE (TYPE &REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-INSTANCE TYPE OPTIONS))

(DEFMETHOD (:MAKE-SEQUENCE BASIC-ZMAIL) (TYPE &REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-SEQUENCE TYPE OPTIONS))

(DEFMETHOD (MAKE-INSTANCE SEQUENCE) (&KEY OPTIONS &ALLOW-OTHER-KEYS)
  (SEND SELF :SET-PROPERTY-LIST OPTIONS))

(DEFUN ADD-NEW-SEQUENCE (SEQUENCE)
  (SETQ *SEQUENCE-LIST* (NCONC *SEQUENCE-LIST* (NCONS SEQUENCE)))
  (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*SEQUENCE-LIST*))


;;; Killing ...

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-KILL-SEQUENCE
				"Kills a message sequence.
Asks for a sequence name in the minibuffer.
If you ask to kill the current sequence, this command will ask for the
  name of another sequence which will become the current sequence.
If you ask to kill a mail file buffer, you will either be asked to save
  it first or confirm that you picked the proper sequence."
				(DANGEROUS NUMERIC-ARG-OK NO-MSG-OK)
  (COM-ZMAIL-KILL-SEQUENCE-INTERNAL (TYPEIN-LINE-ACCEPT 'SEQUENCE :PROMPT "Kill sequence"
								  :DEFAULT *SEQUENCE*)
				    T))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR KILL-SEQUENCE
						  (SEQUENCE "Kill sequence" *ZMAIL-COMTAB*)
						  (SEQUENCE)
  `(COM-ZMAIL-KILL-SEQUENCE-INTERNAL ,SEQUENCE T))

1;;; For compatibility with old 0INIT1 files, etc.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-KILL-CURRENT-SEQUENCE
				"Kills the current sequence.
Requires confirmation if the buffer being killed is a file buffer."
				(NUMERIC-ARG-OK NO-MSG-OK)
  (COM-ZMAIL-KILL-SEQUENCE-INTERNAL *SEQUENCE* NIL))

(DEFUN COM-ZMAIL-KILL-SEQUENCE-INTERNAL (SEQUENCE ASK-FOR-NEW-SEQUENCE)
  (LET* ((*CURRENT-ZMAIL-TOP-LEVEL-COMMAND* 'COM-ZMAIL-KILL-SEQUENCE)
	 (SEQUENCE-NAME (SEQUENCE-NAME SEQUENCE))
	 (KILLING-*SEQUENCE* (EQ SEQUENCE *SEQUENCE*)))
    (WHEN (SEQUENCE-BUFFER-P SEQUENCE)
      (MULTIPLE-VALUE-BIND (NEEDS-SAVE NEEDS-EXPUNGE)
	  (MAIL-FILE-SAVE-P SEQUENCE :INCOMPLETE-OK T)
	(IF NEEDS-SAVE
	    (LET ((ANSWER (FQUERY `(:STREAM ,*TYPEOUT-WINDOW*
				    :SELECT T
				    :BEEP T
				    :TYPE :READLINE
				    :CHOICES ((:SAVE "Yes")
					      (:KILL "Kill without saving")
					      (:ABORT "Do nothing")))
				  "Mail file buffer ~A contains changes that ~
				   will be lost if you kill it now.~@
				   ~2@T~:[Save~;Expunge and save~] the buffer first?  "
				  SEQUENCE-NAME NEEDS-EXPUNGE)))
	      (CL:CASE ANSWER
		(:SAVE
		  (WHEN NEEDS-EXPUNGE
		    (EXPUNGE-SEQUENCE SEQUENCE))
		  (SAVE-MAIL-FILE SEQUENCE))
		(:KILL)
		(:ABORT
		  (ABORT-CURRENT-COMMAND))))
	    (CHECK-IF-DANGEROUS-COMMAND-OK "kill the mail file buffer ~A" SEQUENCE-NAME))))
    (PROG1
      (IF (AND KILLING-*SEQUENCE* ASK-FOR-NEW-SEQUENCE (LOOP FOR S IN *SEQUENCE-LIST*
								 THEREIS (NEQ S SEQUENCE)))
	  (LET ((NEW-SEQUENCE
		  (LOOP FOR NEW-SEQUENCE = (TYPEIN-LINE-ACCEPT
					     'SEQUENCE :PROMPT "Killing the current ~
								sequence, select which ~
								other sequence?"
						       :DEFAULT (PREVIOUS-SEQUENCE))
			WHEN (NEQ NEW-SEQUENCE SEQUENCE)
			  RETURN NEW-SEQUENCE)))
	    (KILL-SEQUENCE SEQUENCE)
	    (SELECT-SEQUENCE NEW-SEQUENCE))
	  (KILL-SEQUENCE SEQUENCE))
      (TYPEIN-LINE "Sequence ~A killed." SEQUENCE-NAME))))

;;; Kill a collection (a.k.a. sequence).
(DEFGENERIC KILL-SEQUENCE (SEQUENCE &KEY ABORT)
  (DECLARE (VALUES . (REDISPLAY-DEGREE)))
  (:FUNCTION
    (LET ((WAS-CURRENT-SEQUENCE (EQ SEQUENCE *SEQUENCE*)))
      (LOCK-SEQUENCE (SEQUENCE :WRITE)
	(FUNCALL (FLAVOR:GENERIC KILL-SEQUENCE) SEQUENCE :ABORT ABORT))
      (IF WAS-CURRENT-SEQUENCE DIS-TEXT DIS-NONE)))
  ;; The default method ...
  (:METHOD (SEQUENCE)
    (IGNORE ABORT)				;Don't care how its being killed.
    (SETQ *SEQUENCE-LIST* (DELQ SELF *SEQUENCE-LIST*))
    (MSG-POINT-PDL-PURGE NIL SELF)
    (WHEN (EQ SELF *DEFAULT-BUFFER*)
      (SETQ *DEFAULT-BUFFER* NIL))
    (WHEN (EQ SELF *DEFAULT-MOVE-SEQUENCE*)
      (SETQ *DEFAULT-MOVE-SEQUENCE* NIL)
      (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*DEFAULT-MOVE-SEQUENCE*))
    (WHEN (EQ SELF *SEQUENCE*)
      (SELECT-SEQUENCE (FIRST *SEQUENCE-LIST*) NIL T NIL))
    (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*SEQUENCE-LIST*)))


;;; Some default methods for collections

(DEFMETHOD (:PRINT-SELF SEQUENCE) (STREAM IGNORE SLASHIFY)
  (IF SLASHIFY
      (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
	(PRIN1 NAME STREAM))
    (PRINC NAME STREAM)))

(DEFMETHOD (:STRING-FOR-PRINTING SEQUENCE) ()
  NAME)

(DEFMETHOD (:FULL-NAME SEQUENCE) ()
  (SEND SELF :NAME))

;;; Non-NIL implies that we're inserting new mail from an inbox and we shouldn't
;;; mark the sequence as modified.
(DEFVAR *NEW-MSG-INSERTION* NIL)

;;; Mark a sequence as modified.
(DEFGENERIC MARK-SEQUENCE-MODIFIED (SEQUENCE &KEY HARD)
  ;; The default method ...
  (:METHOD (SEQUENCE)
    (LET ((NEW-TICK (TICK)))
      (IF HARD
	  ;; Force a save ...
	  (UNLESS *NEW-MSG-INSERTION*
	    ;;; ... but not while reading new mail which may later be deleted.
	    (SETQ SAVE-REQUIRING-MODIFICATION-TICK NEW-TICK
		  MODIFICATION-TICK NEW-TICK))
	;; "Soft" modification -- In present implementation will also force saves.
	;;    Eventually, we'll provide an option to saving to not save for "soft" mods.
	(SETQ MODIFICATION-TICK NEW-TICK)))))

(DEFUN COLLECTION-AVAILABLE-P (IGNORE COLLECTION IGNORE)
  (OR (NOT (VARIABLE-BOUNDP *SEQUENCE-LIST*))
      (NOT (MEMQ COLLECTION *SEQUENCE-LIST*))))

(DEFUN MAKE-COLLECTION (IGNORE)
  (MAKE-SEQUENCE 'COLLECTION :OPTIONS '(:APPEND T)))

(DEFUN MAKE-NEW-COLLECTION (NAME &OPTIONAL (FULL-NAME NAME) &AUX COLLECTION)
  (SETQ COLLECTION (ALLOCATE-RESOURCE 'COLLECTION))
  (SEND COLLECTION ':SET-NAME NAME)
  (SEND COLLECTION ':SET-FULL-NAME FULL-NAME)
  (SEND COLLECTION ':SET-SAVED-CURRENT-MSG NIL)
  (SETF (FILL-POINTER (SEND COLLECTION ':ARRAY)) 0)
  (ADD-NEW-SEQUENCE COLLECTION)
  COLLECTION)

;;; Simple collections
(DEFRESOURCE COLLECTION ()
  :INITIAL-COPIES 0
  :CONSTRUCTOR MAKE-COLLECTION
  :CHECKER COLLECTION-AVAILABLE-P)

;;; Creating and killing messages

;;; This puts the BP's and intervals in (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*zmail-msg-line-area*
0;;; and the MSG's in 2*zmail-msg-area*0.
;;; Changed 11/13/89 to put the INTERVAL in 2*zmail-msg-area*0 next to the MSG, for
;;; improved paging performance when scanning over collections.
(DEFUN MAKE-EMPTY-MSG (&KEY (TICK (TICK)) (FATTENED-P T)
		       &AUX REAL-INTERVAL INTERVAL START-BP END-BP MSG)
  (LET ((DEFAULT-CONS-AREA *ZMAIL-MSG-LINE-AREA*))
    (SETQ REAL-INTERVAL (CREATE-INTERVAL NIL NIL 'ZMAIL-MSG-NODE)
	  START-BP (COPY-BP (INTERVAL-FIRST-BP REAL-INTERVAL) ':NORMAL)
	  END-BP (COPY-BP (INTERVAL-LAST-BP REAL-INTERVAL) ':MOVES))
    (LET ((DEFAULT-CONS-AREA *ZMAIL-MSG-AREA*))
      (SETQ MSG (MAKE-MSG TICK TICK
			  REAL-INTERVAL REAL-INTERVAL
			  INSERTION-TICK 0)	; conservative assumption
	    INTERVAL (CREATE-INTERVAL START-BP END-BP 'ZMAIL-MSG-NODE)))
    (SETF (MSG-INTERVAL MSG) INTERVAL)
    (SETF (NODE-TICK REAL-INTERVAL) TICK)
    (SETF (NODE-TICK INTERVAL) TICK)
    (SETF (LINE-NODE (BP-LINE END-BP)) INTERVAL)
    (SETF (NODE-SUPERIOR INTERVAL) REAL-INTERVAL)
    (SETF (NODE-INFERIORS REAL-INTERVAL) (LIST INTERVAL))
    (SEND REAL-INTERVAL :SET-MSG MSG)
    (SEND INTERVAL :SET-MSG MSG)
    (SETF (MSG-FATTENED-P MSG) FATTENED-P)
    MSG))

(DEFUN COPY-MSG (MSG &AUX NMSG)
  (ASSURE-MSG-PARSED MSG)
  (SETQ NMSG (MAKE-EMPTY-MSG))
  (MULTIPLE-VALUE-BIND (HEADERS-START-BP HEADERS-END-BP)
      (MSG-ORIGINAL-HEADERS-INTERVAL MSG)
    (MULTIPLE-VALUE-BIND (BODY-START-BP BODY-END-BP)
	(MSG-BODY-INTERVAL MSG)
      (LET ((AT-BP (MSG-END-BP NMSG)))
	(INSERT-INTERVAL AT-BP HEADERS-START-BP HEADERS-END-BP T)
	(INSERT-INTERVAL AT-BP BODY-START-BP BODY-END-BP T))
      (LET ((LINE-MAPPINGS (LOOP FOR LINE FIRST (BP-LINE HEADERS-START-BP)
				   THEN (LINE-NEXT LINE)
				 WITH END-LINE = (BP-LINE HEADERS-END-BP)
				 FOR NLINE FIRST (BP-LINE (MSG-START-BP NMSG))
			           THEN (LINE-NEXT NLINE)
				 COLLECT (CONS LINE NLINE)
				 UNTIL (EQ LINE END-LINE)))
	    (NEW-PLIST-COLLECTION NIL))
	1;; What is this next line for?  -- RWK & GMP, 20 Nov 85
0	(SETF (CAR (CAR (LAST LINE-MAPPINGS))) (BP-LINE BODY-START-BP))
	1;; While we're 2sublis*1ing, update the intervals in the BP's too.
0	(PUSH (CONS (MSG-INTERVAL MSG) (MSG-INTERVAL NMSG)) LINE-MAPPINGS)
	(PUSH (CONS (MSG-REAL-INTERVAL MSG) (MSG-REAL-INTERVAL NMSG)) LINE-MAPPINGS)
	(SETF (MSG-STATUS NMSG) (SUBLIS* LINE-MAPPINGS
					 (SOME-PLIST-NOT (MSG-STATUS MSG)
							 *PROPERTIES-NOT-COPIED*)))
	1;; Some items are legitimate BP's, and must be kept that way.
0	(FLET ((LEGITIMATIZE-BP (BP)
		 (PUSH BP (LINE-BP-LIST (BP-LINE BP)))))
	  (LOOP FOR (PROP LIST-P) IN *BP-PROPERTIES*
		FOR X = (GET (LOCF (MSG-STATUS NMSG)) PROP)
		DO (IF (NOT LIST-P)
		       (WHEN X (LEGITIMATIZE-BP X))
		     (LOOP FOR BP IN X
			   DO (LEGITIMATIZE-BP BP)))))
	1;; Maintain 2eq1ness in the 2parse-headers1 in the 2line-contents-plists1 that are 2eq
0	1;; in the original message so multi-line header fields will not appear as multiple
	;; occurrences of the same field.
0	(LOOP FOR (OLINE . LINE) IN LINE-MAPPINGS
	      AS ENTRY = (WHEN (STRINGP OLINE)
			   (LOOP WITH NEW-LINE-CONTENTS-PLIST =
				   (SUBLIS* LINE-MAPPINGS (LINE-CONTENTS-PLIST OLINE))
				 FOR ENTRY IN NEW-PLIST-COLLECTION
				 WHEN (EQUAL ENTRY NEW-LINE-CONTENTS-PLIST)
				   DO (RETURN ENTRY)
				 FINALLY (PUSH NEW-LINE-CONTENTS-PLIST NEW-PLIST-COLLECTION)
					 (RETURN NEW-LINE-CONTENTS-PLIST)))
	      WHEN (STRINGP LINE)
		DO (SETF (LINE-CONTENTS-PLIST LINE) ENTRY)))))
  (LET* ((OLD-LINE (MSG-SUMMARY-LINE MSG))
	 (NEW-LINE (MAKE-SUMMARY-LINE :MAKE-ARRAY (:LENGTH (ARRAY-ACTIVE-LENGTH OLD-LINE)
						   :TYPE (IF (NULL OLD-LINE) 'ART-STRING
							   (ARRAY-TYPE OLD-LINE))))))
    1;; Copy the summary line.
0    (SETF (MSG-SUMMARY-LINE NMSG) NEW-LINE)
    (COPY-ARRAY-CONTENTS-AND-LEADER OLD-LINE NEW-LINE)
    1;; Give the copy a separate summary line template to avoid updating both simultaneously.
0    (SETF (SUMMARY-LINE-TEMPLATE NEW-LINE) (COPYTREE (SUMMARY-LINE-TEMPLATE NEW-LINE))))
  (SETF (MSG-PARSED-P NMSG) T)
  NMSG)

;;; Just like SUBLIS, but copies ATOM's rather than SYMBOL's.
(DEFUN SUBLIS* (ALIST FORM &AUX CAR CDR)
  (COND ((ATOM FORM)
	 (COND ((SETQ CAR (ASSQ FORM ALIST))
		(CDR CAR))
	       (T FORM)))
	((LISTP FORM)
	 (SETQ CAR (SUBLIS* ALIST (CAR FORM))
	       CDR (SUBLIS* ALIST (CDR FORM)))
	 (COND ((AND (EQ (CAR FORM) CAR)
		     (EQ (CDR FORM) CDR))
		FORM)
	       (T (CONS CAR CDR))))
	(T FORM)))

;;; Mark a message as killed, and throw away any structure not
;;; used by the references code so it can be GC'd.
;;; The DONT-GET-REFERENCES argument is for the used when the whole sequence is being
;;; killed (or the load aborted) rather than just this message expunged.
(DEFUN KILL-MSG (MSG &OPTIONAL DONT-GET-REFERENCES)
  (UNLESS (EQ (MSG-PARSED-P MSG) ':KILLED)
    (UNLESS DONT-GET-REFERENCES
      (MSG-REFERENCES MSG)			;Assure reference info is available
      (GET-MSG-IDS MSG))			;(both sides)
    (SETF (MSG-PARSED-P MSG) ':KILLED)		;mark it killed before bashing
    (DELETE-INTERVAL (MSG-REAL-INTERVAL MSG))
    (SETF (MSG-REAL-INTERVAL MSG) ':KILLED)
    (SETF (MSG-INTERVAL MSG) ':KILLED)
    (SETF (MSG-SUMMARY-LINE MSG) ':KILLED)
    (SETF (MSG-TICK MSG) ':KILLED)
    (SETF (MSG-STATUS MSG) (SOME-PLIST (MSG-STATUS MSG) '(REFERENCES MSG-IDS)))))

;;; This is useful for debugging (at least no one seems to use it).
(DEFUN STRING-MSG (MSG &OPTIONAL NO-HEADER-P)
  (STRING-INTERVAL (IF NO-HEADER-P
		       (MSG-INTERVAL MSG)
		     (MSG-REAL-INTERVAL MSG))))

;; Keep intervals localized with the MSG objects after a dynamic GC.
(DEFUN LOCALIZE-ZMAIL-STRUCTURES-AFTER-DYNAMIC-GC-FLIP ()
  (WHEN (AND (VARIABLE-BOUNDP *ZMAIL-WINDOW*)
	     *ZMAIL-WINDOW*
	     (VARIABLE-BOUNDP SI:*DYNAMIC-GC-FLIP-ARGS*))
    (PROCESS:PROCESS-RUN-FUNCTION
      `(:NAME "Localize Zmail Structures"
	:PRIORITY ,(PROCESS:MAKE-PROCESS-PRIORITY :FOREGROUND 0 :PREEMPTIVE NIL))
      #'(LAMBDA ()
	  (DOLIST (SEQUENCE (SCL:SYMBOL-VALUE-IN-INSTANCE *ZMAIL-WINDOW* '*SEQUENCE-LIST*))
	    (WHEN (SEQUENCE-BUFFER-P SEQUENCE)
	      (LET ((ARRAY (SEND SEQUENCE :ARRAY)))
		(LOOP FOR I BELOW (FILL-POINTER ARRAY)
		      AS MSG = (AREF ARRAY I)
		      DO (COMPILER:FOR-EFFECT (MSG-INTERVAL MSG))))))))))

(CL:PUSHNEW '(LOCALIZE-ZMAIL-STRUCTURES-AFTER-DYNAMIC-GC-FLIP)
	    SI:GC-AFTER-FLIP-LIST
	    :TEST #'EQUAL)

;;; Adding, deleting, and expunging messages in a collection

;;; Adding ...

(DEFMETHOD (:ADD-MSG SEQUENCE :AFTER) (&REST IGNORE)
  (SETQ MODIFICATION-TICK (TICK)))

(DEFMETHOD (:ADD-MSG SEQUENCE) (MSG &OPTIONAL AT-INDEX)
  (LET ((LEN (ARRAY-ACTIVE-LENGTH ARRAY))
	(DELAY-SORT NIL))
    (UNLESS (DOTIMES (I LEN) ;If not already in file
	      (AND (EQ MSG (AREF ARRAY I)) (RETURN T)))
      (IF AT-INDEX
	  (AND (> AT-INDEX LEN)
	       (FERROR "Trying to add a message past the end of the sequence"))
	  (SETQ AT-INDEX (LET ((PREDICATE (SEND SELF ':GET ':SORT))
			       (APPEND-P (SEND SELF ':GET ':APPEND)))
			   (IF (OR (NULL PREDICATE)
				   (SETQ DELAY-SORT
					 (LET ((FUNCTION (GET PREDICATE 'SORT-OPTIMIZER)))
					   (AND FUNCTION
						(MULTIPLE-VALUE-BIND (NIL NIL NIL DELAY)
						    (FUNCALL FUNCTION SELF APPEND-P)
						  DELAY)))))
			       (IF APPEND-P LEN 0)
			       ;; Optimize the case where the message being added goes near
			       ;; the end of the sorted sequence.  (A new message into a
			       ;; buffer sorted by date, for example.)
			       (LETF (((MSG-BUFFER MSG) SELF))
				 (IF APPEND-P
				     (LOOP FOR I DOWNFROM (1- LEN) TO 0
					   WHILE (FUNCALL PREDICATE MSG (AREF ARRAY I))
					   FINALLY (RETURN (1+ I)))
				     (LOOP FOR I FROM 0 BELOW LEN
					   WHILE (FUNCALL PREDICATE MSG (AREF ARRAY I))
					   FINALLY (RETURN I))))))))
      (WHEN (< (ARRAY-LENGTH ARRAY) (1+ LEN))
	(ADJUST-ARRAY-SIZE ARRAY (// (* LEN 5) 4)))
      (SETQ MSG (SEND SELF ':ADD-MSG-TEXT MSG AT-INDEX))
      (DO ((I LEN (1- I))
	   (J (1- LEN) (1- J)))
	  ((< J AT-INDEX))
	(ASET (AREF ARRAY J) ARRAY I))
      (ASET MSG ARRAY AT-INDEX)
      (SETF (FILL-POINTER ARRAY) (1+ LEN))
      (WHEN DELAY-SORT
	(SORT-SEQUENCE-INTERNAL SELF (SEND SELF ':GET ':SORT) (SEND SELF ':GET ':APPEND)
				ARRAY NIL))
      T)))

(DEFMETHOD (:ADD-SEQUENCE SEQUENCE) (SEQUENCE)
  (COND ((ZEROP (SEQUENCE-NMSGS SEQUENCE)))
	((= (SEQUENCE-NMSGS SEQUENCE) 1)
	 ;; Special case single message sequences to insure that sorting works properly.
	 (SEND SELF :ADD-MSG (AREF (SEQUENCE-ARRAY SEQUENCE) 0)))
	(T
	 ;; Normal case.
	 (TV:NOTING-PROGRESS ((FORMAT NIL "Moving into ~A." SELF))
	   (LET* ((NARRAY (SEQUENCE-ARRAY SEQUENCE))
		  (NLENGTH (SEQUENCE-NMSGS SEQUENCE))
		  (PREDICATE (SEND SELF :GET :SORT))
		  (APPEND-P (SEND SELF :GET :APPEND))
		  (DELAY-SORT NIL))
	     (WHEN (OR PREDICATE (NULL APPEND-P))
	       (LET ((NNARRAY (MAKE-ARRAY NLENGTH)))
		 (COPY-ARRAY-CONTENTS NARRAY NNARRAY)
		 (IF (NULL PREDICATE)
		     (ARRAY-NREVERSE NNARRAY)
		   (UNLESS (SORT-SEQUENCE-INTERNAL SEQUENCE PREDICATE APPEND-P NNARRAY T)
		     (SETQ DELAY-SORT T)))
		 (SETQ NARRAY NNARRAY)))
	     ;; Now merge
	     (LOOP FOR OLD-IDX FROM 0
		   WITH LENGTH = (ARRAY-ACTIVE-LENGTH ARRAY)
		   AND NEW-IDX = 0
		   AS NMSG = (AREF NARRAY NEW-IDX)
		   WHEN (OR ( OLD-IDX LENGTH)
			    (EQ APPEND-P (AND PREDICATE (NOT DELAY-SORT)
					      (FUNCALL PREDICATE NMSG (AREF ARRAY OLD-IDX)))))
		     DO (IF (SEND SELF :ADD-MSG NMSG OLD-IDX)
			    (INCF LENGTH)
			  (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI");;; I don't know what this ELSE clause is trying to do.
0			  (DECF OLD-IDX))
			(INCF NEW-IDX)
			(TV:NOTE-PROGRESS NEW-IDX NLENGTH)
		   UNTIL ( NEW-IDX NLENGTH))
	     (WHEN DELAY-SORT
	       (SORT-SEQUENCE-INTERNAL SELF PREDICATE APPEND-P ARRAY NIL)))))))
  
(DEFMETHOD (:ADD-MSG-TEXT SEQUENCE) (MSG AT-INDEX)
  AT-INDEX					;Not used
  MSG)


;;; Deleting ...

(DEFVAR *LAST-DELETED-MSG*)	;Most recently deleted message, for the YANK command.

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-DELETE (STRING)
  (FORMAT STRING "Delete current message: L: ~A; M: ~A; R: menu."
	  (NAME-FROM-MENU-VALUE *NEXT-AFTER-DELETE* *DELETE-DIRECTION-ALIST*)
	  (NAME-FROM-MENU-VALUE *DELETE-MIDDLE-MODE* *DELETE-DIRECTION-ALIST*)))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *NEXT-AFTER-DELETE* COM-ZMAIL-DELETE)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DELETE-MIDDLE-MODE* COM-ZMAIL-DELETE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DELETE "Delete current message.
Normally moves to the next message, but is controlled by *NEXT-AFTER-DELETE*.
Middle normally moves back after deleting, but is controlled by *DELETE-MIDDLE-MODE*.
Right gives a menu, including Remove.  With an argument, deletes the message with that
number." (NUMERIC-ARG-OK)
  (LET (MSG MODE)
    (IF *NUMERIC-ARG-P*
	(SETQ MSG (GET-MSG-FROM-ARG)
	      MODE ':NONE)
	(SETQ MSG *MSG*
	      MODE (CHOOSE-DELETE-MODE)))	
    (COM-ZMAIL-DELETE-INTERNAL MODE MSG)))

(DEFUN CHOOSE-DELETE-MODE ()
  (SELECTQ *ZMAIL-COMMAND-BUTTON*
    (:MIDDLE *DELETE-MIDDLE-MODE*)
    (:RIGHT (OR (TV:MENU-CHOOSE
		  *DELETE-DIRECTION-ALIST* NIL
		  (RECTANGLE-NEAR-COMMAND-MENU (TV:MOUSE-SHEET (TV:SHEET-MOUSE *ZMAIL-WINDOW*))))
		(ABORT-CURRENT-COMMAND)))
    (OTHERWISE *NEXT-AFTER-DELETE*)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DELETE-AND-UP
				 "Delete the current message and move to previous undeleted"
				 ()
  (COM-ZMAIL-DELETE-INTERNAL ':BACKWARD))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REMOVE
  "Remove the current message from the current temporary mail file" ()
  (COM-ZMAIL-DELETE-INTERNAL ':REMOVE))

(DEFUN COM-ZMAIL-DELETE-INTERNAL (MODE &OPTIONAL (MSG *MSG*))
  (IF (OR (EQ MODE ':REMOVE)
	  (AND (MEMQ MODE '(:FORWARD-OR-REMOVE :BACKWARD-OR-REMOVE :NO-OR-REMOVE))
	       (NOT (SEQUENCE-BUFFER-P *SEQUENCE*))))
      (REMOVE-MSG *SEQUENCE* *MSG* (LOCATE-MSG-IN-SEQUENCE *MSG* *SEQUENCE*))
    (MSG-PUT MSG T 'DELETED)
    (SETQ *LAST-DELETED-MSG* MSG)
    (MOVE-AFTER-DELETE MODE)))

(DEFUN MOVE-AFTER-DELETE (MODE)
  (SELECTQ MODE
    ((:BACKWARD :BACKWARD-OR-REMOVE)
     (ZMAIL-SELECT-PREVIOUS-MSG 'MSG-DOES-NOT-HAVE-ATTRIBUTE-P 'DELETED T 1))
    ((:FORWARD :FORWARD-OR-REMOVE)
     (ZMAIL-SELECT-NEXT-MSG 'MSG-DOES-NOT-HAVE-ATTRIBUTE-P 'DELETED T 1))
    (OTHERWISE
     (COMPUTE-CURRENT-MSG-STATE))))

(DEFUN REMOVE-MSG (COLLECTION MSG INDEX &AUX ARRAY LEN)
  (WHEN (SEQUENCE-BUFFER-P COLLECTION)
    (BARF "Cannot remove from a buffer, only a collection"))
  (SETQ ARRAY (SEND COLLECTION ':ARRAY))
  (UNLESS (EQ MSG (AREF ARRAY INDEX))
    (FERROR "~S not in ~Dth position of ~S" MSG INDEX COLLECTION))
  (ZMAIL-UNDO-SAVE 'UNDO-REMOVE ':MSG MSG ':INDEX INDEX ':COLLECTION COLLECTION)
  (MSG-POINT-PDL-PURGE MSG COLLECTION)
  (SETQ LEN (ARRAY-ACTIVE-LENGTH ARRAY))
  (COPY-ARRAY-PORTION ARRAY (1+ INDEX) LEN ARRAY INDEX (SETQ LEN (1- LEN)))
  (SETF (ARRAY-LEADER ARRAY 0) LEN)
  (WHEN (EQ COLLECTION *SEQUENCE*)
    (SEND *SUMMARY-WINDOW* ':NEED-FULL-REDISPLAY)
    (IF (ZEROP LEN)
	(ZMAIL-SELECT-MSG NIL T)
	(ZMAIL-SELECT-MSG (MIN INDEX (1- LEN))))))


;;; Undeleting ...

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-UNDELETE (STRING)
  (FORMAT STRING "Undelete current message: L,M,R: Backward."
;;; to be added
;;  (FORMAT STRING "Undelete current message: L: ~A; M: ~A; R: menu."
;;	  (NAME-FROM-MENU-VALUE *NEXT-AFTER-UNDELETE* *DELETE-DIRECTION-ALIST*)
;;	  (NAME-FROM-MENU-VALUE *UNDELETE-MIDDLE-MODE* *DELETE-DIRECTION-ALIST*)
	  ))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-UNDELETE
				 "Undelete this or the previous deleted message."
				 (NUMERIC-ARG-OK)
  (IF *NUMERIC-ARG-P*
      (LET ((MSG (GET-MSG-FROM-ARG)))
	(OR (MSG-GET MSG 'DELETED)
	    (BARF "Message not deleted"))
	(ZMAIL-UNDELETE-MSG MSG))
      (LET ((ARRAY (SEND *SEQUENCE* ':ARRAY)))
	(DO ((N *MSG-NO* (1- N))
	     (MSG))
	    ((< N 0) (BARF "No deleted messages"))
	  (COND ((MSG-GET (SETQ MSG (AREF ARRAY N)) 'DELETED)
		 (MSG-PUT MSG NIL 'DELETED)
		 (RETURN (ZMAIL-SELECT-MSG N))))))))


;;; Expunging ...

(DEFUN BUFFER-EXPUNGE-QUERY (BUFFER)
  (UNLESS (SEQUENCE-PREDICATE-QUERY BUFFER
				    'MSG-HAS-ATTRIBUTE-P 'DELETED
				    "expunge" "Deleted")
    (THROW 'ABORT-BUFFER-EXPUNGE T)))

2;;; This function should make the list of messages to be processed mouse sensitive.  However,
;;; 0TYPEOUT-YES-OR-NO-P2 doesn't understand mouse clicks at present which prevents us from
;;; doing this.  When we can use mouse sensitive items, the list of options for the items
;;; should be: add to list of processed items, remove from list of processed items,
;;; and display the message (which would require a redisplay of the list after the message).
0(DEFUN SEQUENCE-PREDICATE-QUERY (SEQUENCE PREDICATE ARG ACTION ATTRIBUTE)
  (LET ((N-ACCEPTABLE-MSGS 0))
    (LET ((*COMTAB* *ZMAIL-COMTAB*))		;For mouse-sensitivity at **MORE** breaks
      (DOMSGS (MSG SEQUENCE)
	(WHEN (AND MSG (FUNCALL PREDICATE MSG ARG))
	  (WHEN (ZEROP N-ACCEPTABLE-MSGS)
	    (FORMAT *TYPEOUT-WINDOW* "~&~A messages to be ~Ad from ~A:~%"
		    ATTRIBUTE ACTION SEQUENCE))
	  (INCF N-ACCEPTABLE-MSGS)
	  (TRUNCATED-SENSITIVE-FORMAT MSG 'MSG *TYPEOUT-WINDOW*
				      "~&~\ZWEI:ARROW\~3D~C~A~%"
				      (EQ MSG *MSG*) N-ACCEPTABLE-MSGS
				      (STATUS-LETTER (ASSURE-MSG-PARSED MSG))
				      (MSG-SUMMARY-LINE MSG)))))
    (IF (PLUSP N-ACCEPTABLE-MSGS)
	(TYPEOUT-YES-OR-NO-P "Ok to ~A ~:[it~;them~]? " ACTION (> N-ACCEPTABLE-MSGS 1))
      ;; Sequence contains no "acceptable" messages -- Inform the more global operation
      ;; that it's OK to proceed.
      T)))

(DEFVAR-RESETTABLE *EXPUNGING-SEQUENCE* NIL)	;Anti-recursion

1;; Expunge killed and, optionally, deleted messages from a collection.
0(DEFGENERIC EXPUNGE-SEQUENCE (SEQUENCE &OPTIONAL (DELETED-MSGS T))
  1;; Prevent recursion ...
0  (:FUNCTION
    (UNLESS (EQ *EXPUNGING-SEQUENCE* SEQUENCE)
      (LOCK-SEQUENCE (SEQUENCE :WRITE)
	(LET ((*EXPUNGING-SEQUENCE* SEQUENCE))
	  (FUNCALL (FLAVOR:GENERIC EXPUNGE-SEQUENCE) SEQUENCE DELETED-MSGS)))))
  1;; Standard expunge method ...
0  (:METHOD (SEQUENCE)
    (LET ((OLD-MOD-TICK MODIFICATION-TICK)
	  (BUFFER-P (SEQUENCE-BUFFER-P SELF)))
      (TV:NOTING-PROGRESS ((FORMAT NIL "Expunging ~A." SELF))
	(WHEN (AND *SEQUENCE*
		   (EQ SELF *SEQUENCE*)
		   *MSG*
		   (NEQ *MSG* :NO-SELECT)
		   (OR (EQ (MSG-PARSED-P *MSG*) :KILLED)
		       (AND DELETED-MSGS (CL:GETF (MSG-STATUS *MSG*) 'DELETED))))
	  ;; If this is current sequence and current msg is deleted, find nearest next
	  ;; (or previous) undeleted msg to select, now, while array is intact
	  (ZMAIL-SELECT-MSG
	    (OR (LOOP FOR INDEX FROM (1+ *MSG-NO*) BELOW (SEQUENCE-NMSGS SELF)
		      AS MSG = (AREF ARRAY INDEX)
		      UNLESS (OR (NULL MSG)
				 (EQ (MSG-PARSED-P MSG) :KILLED)
				 (CL:GETF (MSG-STATUS MSG) 'DELETED))
			DO (RETURN INDEX))
		(LOOP FOR INDEX FROM (1- *MSG-NO*) DOWNTO 0
		      AS MSG = (AREF ARRAY INDEX)
		      UNLESS (OR (NULL MSG)
				 (EQ (MSG-PARSED-P MSG) :KILLED)
				 (CL:GETF (MSG-STATUS MSG) 'DELETED))
			DO (RETURN INDEX))
		:NO-SELECT)
	    T NIL))
	(SETQ EXPUNGE-TICK NIL)			;Say partially expunged
	(DO ((NMSGS (FILL-POINTER ARRAY))
	     (TICK (WHEN BUFFER-P (MSG-BUFFER-TICK SELF)))
	     (I 0 (1+ I))
	     (J 0)
	     (MSG))
	    (( I NMSGS)
	     (SETF (FILL-POINTER ARRAY) J)
	     ;;For buffers: if expunging hasn't updated Modified, turn back clock 
	     ;; on Modified to same as last input or Save: Save not needed.
	     (WHEN BUFFER-P
	       ;; But first also update overall attributes of file, see if save needed
	       (UPDATE-OPTIONS-IN-FILE SELF)
	       (WHEN (AND TICK (> (NODE-TICK (MSG-BUFFER-HEADER-INTERVAL SELF)) TICK))
		 (SETQ MODIFICATION-TICK (TICK)))
	       (WHEN (AND TICK
			  ( SAVE-REQUIRING-MODIFICATION-TICK TICK)
			  (= MODIFICATION-TICK OLD-MOD-TICK))
		 (SETQ MODIFICATION-TICK TICK)))
	     (WHEN ( J NMSGS)
	       (WHEN BUFFER-P
		 (EXPUNGE-COLLECTIONS)))
	     (WHEN (AND (NOT BUFFER-P) (ZEROP J))
	       ;; A temporary mail file goes away when it becomes empty.
	       (KILL-SEQUENCE SELF)))
	  (TV:NOTE-PROGRESS I NMSGS)
	  ;; For speed, this does not call MSG-GET, which would parse the
	  ;; message if need be.  If the message has never been parsed, it
	  ;; probably isn't deleted.  Likewise, below it cannot be recent.
	  (COND ((NULL (SETQ MSG (AREF ARRAY I)))	;An aborted expunge
		 (SETQ MODIFICATION-TICK (TICK)))
		;;Smart expunge of buffers arranges for buffer to appear Modified
		;; (Modification-Tick > Tick) only if after expunging, it really is different
		;; from the way it was at the last save.  I.e., reset Modified initially,
		;; then set it only if a msg older than last save is expunged, or...
		((OR (EQ (MSG-PARSED-P MSG) :KILLED)
		     (AND DELETED-MSGS (GET (LOCF (MSG-STATUS MSG)) 'DELETED)))
		 (MSG-POINT-PDL-PURGE MSG (AND (NOT (EQ SELF (MSG-BUFFER MSG)))
					       SELF))
		 (UNLESS BUFFER-P		;If a collection,
		   (SETQ MODIFICATION-TICK (TICK)))	;Note we've changed something.
		 (WHEN BUFFER-P
		   ;; If we're preserving references, and this hasn't been killed,
		   ;; Add in the Forward-References: and Backward-References: fields
		   ;; on ancestors and descendents.
		   (WHEN (AND *PRESERVE-MSG-REFERENCES-ACROSS-EXPUNGE*
			      (NEQ (MSG-PARSED-P MSG) :KILLED))
		     (CROSS-LINK-MSG-REFERENCES MSG))
		   (WHEN (AND TICK
			      ( (MSG-INSERTION-TICK MSG)
				 TICK))		;If expunged msg is older than
		     (SETQ MODIFICATION-TICK (TICK))	;last input, note something changed.
		     (SETQ SAVE-REQUIRING-MODIFICATION-TICK (TICK)))	;Save required.
		   (SETF (AREF ARRAY I) NIL)
		   (KILL-MSG MSG))
		 (SETF (AREF ARRAY I) NIL))
		;; (smart expunge, contd.) ...set Modified if a msg newer than last
		;; save is retained (NOT expunged)
		(T
		 (WHEN (EQ SELF (MSG-BUFFER MSG))
		   (WHEN (AND TICK
			      (> (MAX (MSG-TICK MSG) (NODE-TICK (MSG-INTERVAL MSG)))
				 TICK))
		     ;;If retained msg contents newer than last input, note something changed.
		     (SETQ MODIFICATION-TICK (TICK)))
		   (LET ((*NEW-MSG-INSERTION* (NOT (AND TICK
							( (MSG-INSERTION-TICK MSG)
							   TICK)))))
		     ;; Let's pick up all changes to the msg while we're here
		     ;; (if none, or if retained msg is newer than last input,
		     ;; not marked hard-modified)
		     (UPDATE-MSG-OPTIONS-IN-FILE-IF-NECESSARY SELF MSG))
		   (WHEN (PROG1			; leave nil RECENT property for speed
			   (GET (LOCF (MSG-STATUS MSG)) 'RECENT)	;in searching plist
			   (PUTPROP (LOCF (MSG-STATUS MSG)) NIL 'RECENT))
		     (SETF (MSG-TICK MSG) (TICK))
		     (WHEN (RECENT-IS-MSG-OPTION-IN-FILE-P SELF)
		       ;; Now update again if necessary for benefit of Babyl's recent property
		       (LET ((*NEW-MSG-INSERTION* (NOT (AND TICK ( (MSG-INSERTION-TICK MSG)
								    TICK)))))
			 (UPDATE-MSG-OPTIONS-IN-FILE-IF-NECESSARY SELF MSG)))))
		 (UNLESS (= I J)
		   (WITHOUT-INTERRUPTS
		     (SETF (AREF ARRAY J) MSG)
		     (SETF (AREF ARRAY I) NIL)))
		 (SETQ J (1+ J))))))
      (SETQ EXPUNGE-TICK *BUFFER-EXPUNGE-TICK*)	;Expunge now complete
      (WHEN BUFFER-P
	(SETF (MSG-BUFFER-MSG-UPDATE-TICK SELF) (TICK)))
      (WHEN (AND *SEQUENCE* (EQ SELF *SEQUENCE*))
	(SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY)
	(MAYBE-REDISPLAY-CALENDAR-SEQUENCE)
	(ZMAIL-SELECT-MSG (LET ((LENGTH (ARRAY-ACTIVE-LENGTH ARRAY)))
 			    (COND ((ZEROP LENGTH) NIL)
				  ((AND *MSG*
					(OR (EQ *MSG* :NO-SELECT)
					    (NOT (OR (EQ (MSG-PARSED-P *MSG*) :KILLED)
						     (CL:GETF (MSG-STATUS *MSG*) 'DELETED)))))
				   *MSG*)
				  ((SEND *SEQUENCE* :GET :APPEND)
				   (1- LENGTH))
				  (T 0)))
			  T NIL))
      DIS-NONE)))

(DEFUN EXPUNGE-COLLECTIONS ()
  (LOOP FOR SEQUENCE IN *SEQUENCE-LIST*
	WHEN (NOT (SEQUENCE-BUFFER-P SEQUENCE))
	  DO (EXPUNGE-SEQUENCE SEQUENCE NIL)))

1;;; Link all the messages that point to this message, to all the messages it points to.
;;; Link all the messages that this message points to, back to the ones that point to it.
;;; Include it in the messages pointed to in each direction, so if we find a copy at some
;;; future time, it will be considered part of the conversation.
;;; The forward links are via the 0Forward-References:1 property, and the back-links are
;;; via the 0Backward-References:1 property.
0(DEFUN CROSS-LINK-MSG-REFERENCES (MSG)
  (LOOP WITH IDS = (GET-MSG-IDS MSG)
	WITH FORWARD-REFS = (MSG-GET MSG :FORWARD-REFERENCES)
	WITH BACKWARD-REFS = (MSG-GET MSG :BACKWARD-REFERENCES)
	WITH REFERENCE-UNIVERSE = (SELECT-UNIVERSE-FOR-REFERENCES NIL NIL)
	WITH ANCESTORS = (MSGS-NOT-KILLED
			   (SI:ELIMINATE-DUPLICATES
			     (SEND REFERENCE-UNIVERSE :GET-REFERENCING-MSGS MSG)))
	WITH ANCESTOR-IDS = (LOOP FOR ANCESTOR IN ANCESTORS APPEND (GET-MSG-IDS ANCESTOR))
	WITH DESCENDANTS = (MSGS-NOT-KILLED
			     (SI:ELIMINATE-DUPLICATES
			       (SEND REFERENCE-UNIVERSE :GET-REFERENCED-MSGS MSG)))
	WITH DESCENDANT-IDS = (LOOP FOR DESCENDANT IN DESCENDANTS
				    APPEND (GET-MSG-IDS DESCENDANT))
	FOR ANCESTOR IN ANCESTORS
	FOR STATUS = (LOCF (MSG-STATUS ANCESTOR))
	FOR OLD-IDS = (GET STATUS 'MSG-IDS)
	FOR HEADER = (MSG-REFERENCES-EXCLUDE-IDS
		       (GET-MSG-IDS ANCESTOR)	1;Don't make message point to itself.
0		       (MSG-REFERENCES-ELIMINATE-DUPLICATES
			 (APPEND (MAPCAR #'CDR (APPEND IDS DESCENDANT-IDS))
				 FORWARD-REFS)))
	DO (IF (GET STATUS 'DELETED)		1;If deleted, don't mung text.
0	       (PUTPROP STATUS HEADER :FORWARD-REFERENCES)
	     (WHEN HEADER
	       (ADD-HEADER-TO-MSG ANCESTOR	1;Install forward links on this ancestor.
0				  :FORWARD-REFERENCES HEADER)
	       (LET* ((BUFFER (MSG-BUFFER ANCESTOR))
		      (TICK (MSG-BUFFER-TICK BUFFER))
		      (*NEW-MSG-INSERTION* (NOT (AND TICK
						     ( (MSG-INSERTION-TICK ANCESTOR) TICK)))))
		 (UPDATE-MSG-OPTIONS-IN-FILE-IF-NECESSARY BUFFER ANCESTOR))))
	   (SI:NREMPROP STATUS 'REFERENCES)
	   (SI:NREMPROP STATUS 'MSG-IDS)
	   (UPDATE-MSG-REFERENCES-GLOBALLY ANCESTOR OLD-IDS)
	FINALLY
	  (LOOP FOR DESCENDANT IN DESCENDANTS
		FOR STATUS = (LOCF (MSG-STATUS DESCENDANT))
		FOR OLD-IDS = (GET STATUS 'MSG-IDS)
		FOR HEADER = (MSG-REFERENCES-EXCLUDE-IDS
			       (GET-MSG-IDS DESCENDANT)	1;Don't make message point to itself.
0			       (MSG-REFERENCES-ELIMINATE-DUPLICATES
				 (APPEND (MAPCAR #'CDR (APPEND IDS ANCESTOR-IDS))
					 BACKWARD-REFS)))
		DO (IF (GET STATUS 'DELETED)	1;If deleted, don't mung text.
0		       (PUTPROP STATUS HEADER :BACKWARD-REFERENCES)
		     (WHEN HEADER
		       (ADD-HEADER-TO-MSG DESCENDANT	1;Install back links on this descendant.
0					  :BACKWARD-REFERENCES HEADER)
		       (LET* ((BUFFER (MSG-BUFFER DESCENDANT))
			      (TICK (MSG-BUFFER-TICK BUFFER))
			      (*NEW-MSG-INSERTION* (NOT (AND TICK
							     ( (MSG-INSERTION-TICK DESCENDANT)
								TICK)))))
			 (UPDATE-MSG-OPTIONS-IN-FILE-IF-NECESSARY BUFFER DESCENDANT))))
		   (SI:NREMPROP STATUS 'MSG-IDS)
		   (SI:NREMPROP STATUS 'REFERENCES)
		   (UPDATE-MSG-REFERENCES-GLOBALLY DESCENDANT OLD-IDS))))

(DEFMETHOD (EXPUNGE-SEQUENCE UNIVERSE-SEQUENCE-MIXIN :BEFORE) (&OPTIONAL IGNORE)
  (WHEN (= REFERENCE-HASH-TABLE-TICK 0)		;May be building it in the background
    (SETQ REFERENCE-HASH-TABLE-TICK -1)))

;;; Setting the current sequence and/or message

;;; Collections ...

;(TV:ADD-TYPEOUT-ITEM-TYPE *ZMAIL-TYPEOUT-ITEM-ALIST* COLLECTION "Select" SELECT-SEQUENCE T
;			  "Select this collection.")

;(TV:ADD-TYPEOUT-ITEM-TYPE *ZMAIL-TYPEOUT-ITEM-ALIST* MSG-BUFFER "Select" SELECT-SEQUENCE
;			  T "Select this mail buffer.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SELECT-SEQUENCE
						  (SEQUENCE "Select sequence" *ZMAIL-COMTAB*
							    :GESTURE :SELECT)
						  (SEQUENCE)
  `(SELECT-SEQUENCE ,SEQUENCE))

(DEFUN SELECT-SEQUENCE (SEQUENCE &OPTIONAL DEFAULT-TOO (MSG-TOO T) (SAVE-POINT T))
  (IF SEQUENCE
      (BLOCK NEW-SEQUENCE
	(SEND SEQUENCE :CERTIFY-FOR-SELECTION)
	(WHEN (AND *QUERY-BEFORE-SELECTING-EMPTY-SEQUENCE*
		   (NOT (SEQUENCE-BUFFER-P SEQUENCE))
		   (ZEROP (SEND SEQUENCE :NMSGS)))
	  (UNLESS (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
			  "~A is empty, select it anyway? " (SEND SEQUENCE :NAME))
	    (ABORT-CURRENT-COMMAND)))
	(WHEN (AND *SEQUENCE* *MSG*)
	  (SEND *SEQUENCE* :SET-SAVED-CURRENT-MSG *MSG*)
	  (WHEN SAVE-POINT
	    (MSG-POINT-PDL-PUSH *MSG* *SEQUENCE*)))
	(UNLESS (TYPEP SEQUENCE 'INBOX-BUFFER)
	  (SETQ *SEQUENCE-LIST* (CONS SEQUENCE (DELQ SEQUENCE *SEQUENCE-LIST*))))
	(SETQ *ZMAIL-SEQUENCE-NAME* (SEND SEQUENCE :NAME))
	(WHEN (SEND SEQUENCE :GET :DISABLE-SAVES)
	  (SETQ *ZMAIL-SEQUENCE-NAME* (STRING-APPEND *ZMAIL-SEQUENCE-NAME* " (NoSaves)"))))
    (SETQ *ZMAIL-SEQUENCE-NAME* "No current message sequence"))
  (SEND *SUMMARY-WINDOW* :SET-CURRENT-SEQUENCE SEQUENCE)
  (WHEN DEFAULT-TOO
    (SETQ *DEFAULT-BUFFER* SEQUENCE))
  (SETQ *SEQUENCE* SEQUENCE)
  (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*SEQUENCE*)
  (MAYBE-REDISPLAY-CALENDAR-SEQUENCE)
  (WHEN MSG-TOO
    (ZMAIL-SELECT-MSG (OR (AND *ALWAYS-SELECT-SAVED-CURRENT-MSG*
			       *SEQUENCE*
			       (SEND *SEQUENCE* :SAVED-CURRENT-MSG))
			  *MSG*)
		      T NIL)))

(DEFUN GET-SEQUENCE-ALISTS (&OPTIONAL USE-EDITOR-STRINGS)
  (DECLARE (VALUES BUFFERS-ALIST COLLECTIONS-ALIST UNLOADED-FILES-ALIST))
  (MULTIPLE-VALUE-BIND (BUFFERS-ALIST COLLECTIONS-ALIST)
      (FLET ((BUFFER-NAME (BUFFER)
	       (IF USE-EDITOR-STRINGS (SEND (SEND BUFFER :PATHNAME) :STRING-FOR-EDITOR)
		 (SEND BUFFER :NAME))))
	(LOOP FOR SEQUENCE IN *SEQUENCE-LIST*
	      IF (SEQUENCE-BUFFER-P SEQUENCE)
		COLLECT `(,(BUFFER-NAME SEQUENCE) . ,SEQUENCE) INTO BUFFERS-ALIST
	      ELSE
		COLLECT `(,(SEND SEQUENCE :NAME) . ,SEQUENCE) INTO COLLECTIONS-ALIST
	      FINALLY
		(RETURN (VALUES (SORTCAR BUFFERS-ALIST #'STRING-LESSP)
				(SORTCAR COLLECTIONS-ALIST #'STRING-LESSP)))))
    (FLET ((PATHNAME (STRING-OR-PATH)
	     (FS:MERGE-PATHNAMES STRING-OR-PATH *ZMAIL-PATHNAME-DEFAULTS*))
	   (PATHNAME-NAME (PATH)
	     (IF USE-EDITOR-STRINGS (SEND PATH :STRING-FOR-EDITOR)
	       (SEND PATH :STRING-FOR-PRINTING)))
	   (FILE-IS-UNLOADED-P (PATH)
	     (LOOP FOR (NIL . BUFFER) IN BUFFERS-ALIST
		   NEVER (EQ PATH (SEND BUFFER :PATHNAME)))))
      (LET* ((DEFAULT-FILE (WHEN (NULL *DEFAULT-BUFFER*)
			     (LET ((DEFAULT-FILE-NAME (ZMAIL-DEFAULT-FILE-NAME)))
			       (WHEN DEFAULT-FILE-NAME (PATHNAME DEFAULT-FILE-NAME)))))
	     (DEFAULT-FILE-ITEM (WHEN (AND DEFAULT-FILE (FILE-IS-UNLOADED-P DEFAULT-FILE))
				  `((,(PATHNAME-NAME DEFAULT-FILE) . ,DEFAULT-FILE)))))
	(VALUES
	  BUFFERS-ALIST
	  COLLECTIONS-ALIST
	  (LOOP FOR OTHER-FILE IN `(,@*OTHER-OTHER-MAIL-FILE-NAMES* ,@*OTHER-MAIL-FILE-NAMES*)
		AS OTHER-PATH = (PATHNAME OTHER-FILE)
		WHEN (FILE-IS-UNLOADED-P OTHER-PATH)
		  COLLECT `(,(PATHNAME-NAME OTHER-PATH) . ,OTHER-PATH)
		    INTO UNLOADED-FILES-ALIST
		FINALLY
		  (RETURN (SORTCAR (SI:ELIMINATE-DUPLICATES
				     `(,@UNLOADED-FILES-ALIST . ,DEFAULT-FILE-ITEM)
				     #'(LAMBDA (A B) (EQ (CDR A) (CDR B))))
				   #'STRING-LESSP))))))))

;;; Determine the pathname of the user's default mail file (if any).
(DEFUN ZMAIL-DEFAULT-FILE-NAME (&KEY (HANDLE-ERRORS T))
  (OR *ZMAIL-STARTUP-FILE-NAME*
      (LET* ((POSSIBLE-PATHNAMES (POSSIBLE-DEFAULT-MAIL-FILE-PATHNAMES (FS:USER-HOMEDIR)))
	     (POSSIBLE-PATHNAMES-PLISTS
	       (CONDITION-CASE-IF HANDLE-ERRORS
				  ()
		    (FS:MULTIPLE-FILE-PLISTS POSSIBLE-PATHNAMES)
		  ((FS:FILE-ERROR SYS:NETWORK-ERROR) NIL))))
	(WHEN POSSIBLE-PATHNAMES-PLISTS
	  (LOOP FOR PATHNAME IN POSSIBLE-PATHNAMES
		AS PATHNAME-PLIST = (ASSQ PATHNAME POSSIBLE-PATHNAMES-PLISTS)
		WHEN (> (LENGTH PATHNAME-PLIST) 1)
		  RETURN PATHNAME)))))

#||						2;NOTE: Presently residing in SYS:SYS2;LMMAC.
0(DEFUN SOME-PLIST (PLIST PROPERTIES)
  (DO ((PLIST PLIST (CDDR PLIST))
       (LIST NIL))
      ((NULL PLIST) (NREVERSE LIST))
    (COND ((MEMQ (CAR PLIST) PROPERTIES)
	   (PUSH (CAR PLIST) LIST)
	   (PUSH (CADR PLIST) LIST)))))

(DEFUN SOME-PLIST-NOT (PLIST PROPERTIES)
  (DO ((PLIST PLIST (CDDR PLIST))
       (LIST NIL))
      ((NULL PLIST) (NREVERSE LIST))
    (COND ((NOT (MEMQ (CAR PLIST) PROPERTIES))
	   (PUSH (CAR PLIST) LIST)
	   (PUSH (CADR PLIST) LIST)))))
||#


;;; Messages ...

(DEFINE-ZMAIL-GLOBAL *MOVE-TO-NEXT-MENU-LAST-ITEM* NIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-NEXT (STRING)
  (FORMAT STRING "Move forward: L: ~A; M: ~A; R: menu."
	  (NAME-FROM-MENU-VALUE ':NEXT-UNDELETED *MOVE-TO-NEXT-MENU-ALIST*)
	  (NAME-FROM-MENU-VALUE *NEXT-MIDDLE-MODE* *MOVE-TO-NEXT-MENU-ALIST*)))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *NEXT-MIDDLE-MODE* COM-ZMAIL-NEXT)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-NEXT "Move to next message.
Skips deleted messages.
Middle normally moves to the end, but is controlled by *NEXT-MIDDLE-MODE*.
Right for a menu." (NUMERIC-ARG-OK)
  (LET (MODE)
    (IF (MEMQ *ZMAIL-COMMAND-BUTTON* '(:KBD :LEFT))
	(SETQ MODE ':NEXT-UNDELETED)
	(MULTIPLE-VALUE (MODE *MOVE-TO-NEXT-MENU-LAST-ITEM*)
	  (ZMAIL-MENU-CHOOSE NIL *MOVE-TO-NEXT-MENU-ALIST* *MOVE-TO-NEXT-MENU-LAST-ITEM*
			     NIL *NEXT-MIDDLE-MODE*)))
    (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL MODE)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DOWN-TO-NEXT "Move to next message" (NUMERIC-ARG-OK)
  (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL ':NEXT))

(DEFINE-ZMAIL-GLOBAL *MOVE-TO-PREVIOUS-MENU-LAST-ITEM* NIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-PREVIOUS (STRING)
  (FORMAT STRING "Move backward: L: ~A; M: ~A; R: menu."
	  (NAME-FROM-MENU-VALUE ':PREVIOUS-UNDELETED *MOVE-TO-PREVIOUS-MENU-ALIST*)
	  (NAME-FROM-MENU-VALUE *PREVIOUS-MIDDLE-MODE* *MOVE-TO-PREVIOUS-MENU-ALIST*)))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *PREVIOUS-MIDDLE-MODE* COM-ZMAIL-PREVIOUS)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-PREVIOUS "Move to previous message.
Skips deleted messages.
Middle normally moves to the beginning, but is controlled by *PREVIOUS-MIDDLE-MODE*.
Right for a menu." (NUMERIC-ARG-OK)
  (LET (MODE)
    (IF (MEMQ *ZMAIL-COMMAND-BUTTON* '(:KBD :LEFT))
	(SETQ MODE ':PREVIOUS-UNDELETED)
	(MULTIPLE-VALUE (MODE *MOVE-TO-PREVIOUS-MENU-LAST-ITEM*)
	  (ZMAIL-MENU-CHOOSE NIL *MOVE-TO-PREVIOUS-MENU-ALIST*
			     *MOVE-TO-PREVIOUS-MENU-LAST-ITEM*
			     NIL *PREVIOUS-MIDDLE-MODE*)))
    (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL MODE)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-UP-TO-PREVIOUS "Move to previous message"
				(NUMERIC-ARG-OK)
  (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL ':PREVIOUS))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-NEXT-UNSEEN
				"Move to next unseen message"
				(NUMERIC-ARG-OK)
  (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL :NEXT-UNSEEN))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-PREVIOUS-UNSEEN
				"Move to previous unseen message"
				(NUMERIC-ARG-OK)
  (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL :PREVIOUS-UNSEEN))

(DEFUN COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL (KEY)
  (CL:CHECK-TYPE KEY
		 (CL:MEMBER :FIRST :FIRST-UNDELETED :FIRST-UNSEEN :FIRST-RECENT
			    :LAST :LAST-UNDELETED :LAST-UNSEEN :LAST-RECENT
			    :NEXT :NEXT-UNDELETED :NEXT-UNSEEN :NEXT-RECENT
			    :PREVIOUS :PREVIOUS-UNDELETED :PREVIOUS-UNSEEN :PREVIOUS-RECENT))
  (WHEN (MEMQ KEY '(:FIRST :FIRST-UNDELETED :FIRST-UNSEEN :FIRST-RECENT
		    :LAST :LAST-UNDELETED :LAST-UNSEEN :LAST-RECENT))
    (MSG-POINT-PDL-PUSH *MSG* *SEQUENCE*))
  (MULTIPLE-VALUE-CALL
    (IF (MEMQ KEY '(:NEXT :NEXT-UNDELETED :NEXT-UNSEEN :NEXT-RECENT
		    :FIRST :FIRST-UNDELETED :FIRST-UNSEEN :FIRST-RECENT))
	#'ZMAIL-SELECT-NEXT-MSG
      #'ZMAIL-SELECT-PREVIOUS-MSG)
    (SELECTQ KEY
      ((:NEXT-UNDELETED :PREVIOUS-UNDELETED :LAST-UNDELETED :FIRST-UNDELETED)
       (VALUES 'MSG-DOES-NOT-HAVE-ATTRIBUTE-P 'DELETED))
      ((:NEXT-RECENT :PREVIOUS-RECENT :LAST-RECENT :FIRST-RECENT)
       (VALUES 'UNDELETED-MSG-HAS-ATTRIBUTE-P 'RECENT))
      ((:NEXT-UNSEEN :PREVIOUS-UNSEEN :LAST-UNSEEN :FIRST-UNSEEN)
       (VALUES 'UNDELETED-MSG-HAS-ATTRIBUTE-P 'UNSEEN))
      (OTHERWISE
       (VALUES NIL NIL)))
    (OR *NUMERIC-ARG-P*
	(MEMQ KEY '(:FIRST :FIRST-UNDELETED :LAST :LAST-UNDELETED)))
    *NUMERIC-ARG*
    (SELECTQ KEY
      ((:FIRST :FIRST-UNDELETED :FIRST-UNSEEN :FIRST-RECENT) -1)
      ((:LAST :LAST-UNDELETED :LAST-UNSEEN :LAST-RECENT) (SEQUENCE-NMSGS *SEQUENCE*))
      (OTHERWISE NIL))
    KEY))

(DEFUN ZMAIL-SELECT-NEXT-MSG (&OPTIONAL CONDITION ARG NO-ERROR-P (TIMES 1) AFTER ORIGINAL-MODE)
  (UNLESS AFTER
    (SETQ AFTER *MSG-NO*))
  (LET ((NTIMES TIMES)
	(OK-IDX NIL))
    (LOOP NAMED FOUND DOING
      (LET* ((ARRAY (SEQUENCE-ARRAY *SEQUENCE*))
	     (NMSGS (SEQUENCE-NMSGS *SEQUENCE*)))
	(LOOP FOR INDEX FROM (1+ AFTER) BELOW NMSGS
	      DOING (UNLESS (AND CONDITION
				 (LET ((MSG (AREF ARRAY INDEX)))
				   (NOT (FUNCALL CONDITION MSG ARG))))
		      (SETQ OK-IDX INDEX)
		      (WHEN ( (DECF NTIMES) 0)
			(RETURN-FROM FOUND (ZMAIL-SELECT-MSG INDEX NIL ( TIMES 1)))))))
1      ;; Sequence is exhausted -- Before complaining, try reading a message in case
      ;; we are working with a sequence that is being loaded in the background.
0      (UNLESS (WHEN (READ-NEXT-MSG *SEQUENCE*)
		(SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY)
		T)
	(UNLESS NO-ERROR-P
	  (SELECT-NEXT-OR-PREVIOUS-MSG-ERROR ORIGINAL-MODE CONDITION ARG))
	(UNLESS OK-IDX
	  (SETQ OK-IDX *MSG*))
	(IF OK-IDX
	    (RETURN (ZMAIL-SELECT-MSG OK-IDX))
	  (COMPUTE-CURRENT-MSG-NAME)
	  (SETQ *CURRENT-MSG-KEYWORDS-STRING* NIL)
	  (RETURN DIS-NONE))))))

(DEFUN ZMAIL-SELECT-PREVIOUS-MSG (&OPTIONAL CONDITION ARG NO-ERROR-P (TIMES 1) BEFORE
					    ORIGINAL-MODE)
  (UNLESS BEFORE
    (SETQ BEFORE *MSG-NO*))
  (LET ((ARRAY (SEQUENCE-ARRAY *SEQUENCE*)))
    (DO ((N (1- BEFORE) (1- N))
	 (NTIMES TIMES)
	 (OK-IDX))
	((< N 0)
	 (IF NO-ERROR-P
	     (ZMAIL-SELECT-MSG (OR OK-IDX *MSG*))
	   (SELECT-NEXT-OR-PREVIOUS-MSG-ERROR ORIGINAL-MODE CONDITION ARG)))
      (OR (AND CONDITION (NOT (FUNCALL CONDITION (AREF ARRAY N) ARG)))
	  (PLUSP (SETQ OK-IDX N
		       NTIMES (1- NTIMES)))
	  (RETURN (ZMAIL-SELECT-MSG N NIL ( TIMES 1)))))))

(DEFUN SELECT-NEXT-OR-PREVIOUS-MSG-ERROR (MODE FILTER-FUNCTION FILTER-ARG)
  (COND ((AND (ZEROP *MSG-NO*)
	      (MEMQ MODE '(:PREVIOUS :PREVIOUS-UNDELETED :PREVIOUS-UNSEEN :PREVIOUS-RECENT)))
	 (BARF "Already at the beginning."))
	((AND (= *MSG-NO* (1- (SEQUENCE-NMSGS *SEQUENCE*)))
	      (MEMQ MODE '(:NEXT :NEXT-UNDELETED :NEXT-UNSEEN :NEXT-RECENT)))
	 (BARF "Already at the end."))
	((MEMQ MODE '(:FIRST :LAST))
	 (BARF "There are no messages."))
	(MODE
	 (LET ((TYPE-ADJECTIVE
		 (SELECTQ MODE
		   ((:FIRST-UNDELETED :LAST-UNDELETED :NEXT-UNDELETED :PREVIOUS-UNDELETED)
		    "undeleted")
		   ((:FIRST-UNSEEN :LAST-UNSEEN :NEXT-UNSEEN :PREVIOUS-UNSEEN)
		    "unseen undeleted")
		   ((:FIRST-RECENT :LAST-RECENT :NEXT-RECENT :PREVIOUS-RECENT)
		    "recent undeleted")))
	       (DIRECTION-ADJECTIVE
		 (SELECTQ MODE
		   ((:NEXT-UNDELETED :NEXT-UNSEEN :NEXT-RECENT) "more")
		   ((:PREVIOUS-UNDELETED :PREVIOUS-UNSEEN :PREVIOUES-RECENT) "previous"))))
	   (BARF "There are no~@[ ~A~]~@[ ~A~] messages."
		 DIRECTION-ADJECTIVE TYPE-ADJECTIVE)))
	(T
	 (BARF "There are no more messages of this type: ~A"
	       (FILTER-FUNCTION-COLLECTION-NAME FILTER-FUNCTION FILTER-ARG)))))


(DEFVAR *EMPTY-MSG-INTERVAL* (CREATE-INTERVAL))

1;;; Go to a specified message, specified either as the message itself or a number.
0(DEFUN ZMAIL-SELECT-MSG (MSG &OPTIONAL NO-ERROR-P (SAVE-POINT-P T) (MARK-SEEN T)
			 &AUX (OLD-CURRENT-MSG *MSG*) INDEX START-BP END-BP ARRAY NMSGS
			      MOVE-POINT DEFAULT-CHARACTER-STYLE)
  (IF (EQ MSG :NO-SELECT)
      DIS-NONE
    (IF (NULL *SEQUENCE*)
	(SETQ *MSG-NO* -1
	      *MSG* NIL)
      (SETQ ARRAY (SEND *SEQUENCE* :ARRAY)
	    NMSGS (ARRAY-ACTIVE-LENGTH ARRAY))
      (COND ((NUMBERP MSG)
	     (SETQ *MSG-NO* MSG
		   *MSG* (AREF ARRAY *MSG-NO*)))
	    1;; First try a hint from the summary window's display.
0	    ((AND MSG
		  (SETQ INDEX (MSG-DISPLAYED-INDEX MSG))
		  (< INDEX NMSGS)
		  (EQ MSG (AREF ARRAY INDEX)))
	     (SETQ *MSG-NO* INDEX
		   *MSG* MSG))
	    (T
	     (DO-NAMED FOO ((FLAG NIL T)) (NIL)
	       (DO ((I 0 (1+ I)))
		   (( I NMSGS)
		    (UNLESS NO-ERROR-P
		      (FERROR "Cannot find ~S in current sequence." MSG))
		    (COND ((OR FLAG
			       (NULL (SETQ MSG (SEND *SEQUENCE* ':SAVED-CURRENT-MSG))))
			   (IF (PLUSP NMSGS)
			       (SETQ *MSG-NO* 0	1;If not erring, choose one at random.
0				     *MSG* (AREF ARRAY 0))
			     (SETQ *MSG-NO* -1
				   *MSG* NIL))
			   (RETURN-FROM FOO))))
		 (COND ((EQ MSG (AREF ARRAY I))
			(SETQ *MSG-NO* I
			      *MSG* MSG)
			(RETURN-FROM FOO))))))))
    1;; The current message is not allowed to be killed but the above might select one.
0    (WHEN (AND *MSG* (EQ (MSG-PARSED-P *MSG*) :KILLED))
      (SETQ *MSG-NO* -1
	    *MSG* NIL))
    (SEND *SUMMARY-WINDOW* :SET-CURRENT-MSG *MSG*)
    (WHEN (AND SAVE-POINT-P OLD-CURRENT-MSG (NEQ *MSG* OLD-CURRENT-MSG) *SEQUENCE*)
      (MSG-POINT-PDL-PUSH OLD-CURRENT-MSG *SEQUENCE*))
    (COND (*MSG*
	   (WHEN (AND MARK-SEEN (MSG-GET *MSG* 'UNSEEN))
	     (MSG-PUT *MSG* NIL 'UNSEEN))
	   (SETQ START-BP (MSG-START-BP *MSG*)
		 END-BP (MSG-END-BP *MSG*)
		 DEFAULT-CHARACTER-STYLE (MSG-DEFAULT-CHARACTER-STYLE *MSG*)
		 MOVE-POINT (NEQ *MSG* OLD-CURRENT-MSG)))
	  (T
	   (SETQ START-BP (INTERVAL-FIRST-BP *EMPTY-MSG-INTERVAL*)
		 END-BP (INTERVAL-LAST-BP *EMPTY-MSG-INTERVAL*)
		 MOVE-POINT T)))
    (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-CONTINUE)
    (SET-MSG-INTERVAL START-BP END-BP T DEFAULT-CHARACTER-STYLE MOVE-POINT)
    (COMPUTE-CURRENT-MSG-STATE)))

(DEFUN SET-MSG-INTERVAL (START-BP &OPTIONAL END-BP IN-ORDER-P DEFAULT-CHARACTER-STYLE
					    (MOVE-POINT-P T))
  (LET ((OLD-MSG-INTERVAL (BP-TOP-LEVEL-NODE (INTERVAL-FIRST-BP *MSG-INTERVAL*))))
    (GET-INTERVAL START-BP END-BP IN-ORDER-P)
    (WHEN MOVE-POINT-P
      (MOVE-BP (WINDOW-POINT *MSG-WINDOW*) START-BP)
      (MOVE-BP (WINDOW-MARK *MSG-WINDOW*) START-BP)
      (MOVE-BP (WINDOW-START-BP *MSG-WINDOW*) START-BP))
    (SETF (INTERVAL-FIRST-BP *MSG-INTERVAL*) START-BP)
    (SETF (INTERVAL-LAST-BP *MSG-INTERVAL*) END-BP)
    (RESET-WINDOW-POINT-PDL *MSG-WINDOW*)
    (SET-WINDOW-DEFAULT-CHARACTER-STYLE *MSG-WINDOW* DEFAULT-CHARACTER-STYLE)
    (IF (EQ OLD-MSG-INTERVAL (BP-TOP-LEVEL-NODE START-BP))
	(WHEN MOVE-POINT-P
	  (MUST-REDISPLAY *MSG-WINDOW* DIS-BPS))
      (DISCARD-CHANGE-HISTORY *MSG-INTERVAL*)
      (MUST-REDISPLAY *MSG-WINDOW* DIS-ALL)))) 

(DEFUN RESET-WINDOW-POINT-PDL (WINDOW)
  (DOLIST (POINT (WINDOW-POINT-PDL WINDOW))
    (FLUSH-BP (FIRST POINT)))
  (SETF (WINDOW-POINT-PDL WINDOW) NIL))

2;;; This function really belongs in ZWEI with the default default character style as
;;; an optional argument that defaults to something in SI:.
0(DEFUN SET-WINDOW-DEFAULT-CHARACTER-STYLE (WINDOW NEW-DEFAULT-CHARACTER-STYLE)
  (LET* ((REAL-WINDOW (WINDOW-SHEET WINDOW))
	 (OLD-DEFAULT-CHARACTER-STYLE (SEND REAL-WINDOW :DEFAULT-STYLE))
	 (NEW-DEFAULT-CHARACTER-STYLE
	   (OR NEW-DEFAULT-CHARACTER-STYLE *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)))
    (WHEN (NEQ OLD-DEFAULT-CHARACTER-STYLE NEW-DEFAULT-CHARACTER-STYLE)
      (SEND REAL-WINDOW :SET-DEFAULT-STYLE NEW-DEFAULT-CHARACTER-STYLE)
      (MUST-REDISPLAY WINDOW DIS-ALL))))

(DEFINE-ZMAIL-GLOBAL *SELECT-MSG-HOOKS* NIL)

(DEFUN COMPUTE-CURRENT-MSG-STATE ()
  (UNLESS (EQ *MSG* ':NO-SELECT)		;Unless being delayed
    (MAYBE-REDISPLAY-CALENDAR-MSG *MSG*)
    (COMPUTE-CURRENT-MSG-NAME)
    (SETQ *CURRENT-MSG-KEYWORDS-STRING* (AND *MSG*
					     (OR (MSG-GET *MSG* 'KEYWORDS-STRING) "{}"))))
  (SEND (WINDOW-SHEET *WINDOW*)
	:SET-VSP
	(IF (OR (NULL *MSG*)
		(EQ *MSG* :NO-SELECT))
	    2
	  (LET ((MAPPINGS (MSG-GET *MSG* :CHARACTER-TYPE-MAPPINGS)))
	    (IF (OR (NULL MAPPINGS)
		    (EQ (CAR MAPPINGS) 'LOSING-HEADERS))
		2
	      (LOOP FOR C-T-M IN MAPPINGS
		    FOR (NIL NIL (CHARSET NIL) (NIL NIL SIZE) NIL) = C-T-M
		    MAXIMIZE (IF (NOT (STRING-EQUAL CHARSET "Japanese"))
				 2
			       (SELECTQ SIZE
				 (:NORMAL 4)
				 (:LARGE 8)
				 (:VERY-LARGE 16)
				 (:HUGE 44)
				 (OTHERWISE 16))))))))
  (RUN-HOOKS *SELECT-MSG-HOOKS* 'SELECT-MSG-HOOK)
  DIS-TEXT)

(DEFUN UPDATE-BY-FILTERS-COMMAND-WHO-LINE-DOCUMENTATION ()
  (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-KEYWORDS)
  (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-MOVE))

(DEFUN COMPUTE-CURRENT-MSG-NAME ()
  (UPDATE-BY-FILTERS-COMMAND-WHO-LINE-DOCUMENTATION)
  (SETQ *CURRENT-MSG-NAME*
	(IF *SEQUENCE*
	    (IF *MSG*
		(LET* ((STRING (MAKE-EMPTY-STRING 40))
		       (STATUS (ASSURE-MSG-PARSED *MSG*))
		       (NMSGS (UNLESS (AND (SEQUENCE-BUFFER-P *SEQUENCE*)
					   (EQ (MSG-BUFFER-STATUS *SEQUENCE*) :LOADING))
				(SEQUENCE-NMSGS *SEQUENCE*))))
		  (FORMAT STRING "~4@TMsg #~D//~:[??~;~:*~D~]" (1+ *MSG-NO*) NMSGS)
		  (LOOP FOR (NAME KEY) IN *SAVED-INTERNAL-PROPERTIES-ALIST*
			WITH FLAG = NIL
			DO (WHEN (COND ((EQ KEY 'LAST)
					(AND NMSGS (= *MSG-NO* (1- NMSGS))))
				       ((EQ KEY 'LAST-UNDELETED)
					(AND NMSGS
					     ( *MSG-NO* (1- NMSGS))	;let Last suppress it
					     (LAST-UNDELETED *MSG-NO* *SEQUENCE*)))
				       ((GET STATUS KEY)))
			     (APPEND-TO-ARRAY STRING (IF FLAG ", " " ("))
			     (APPEND-TO-ARRAY STRING NAME)
			     (SETQ FLAG T))
			FINALLY (AND FLAG (ARRAY-PUSH-EXTEND STRING #/))))
		  STRING)
	      "    No messages")
	  "")))

(DEFUN LAST-UNDELETED (MSG-NO SEQUENCE)
  (LET* ((ARRAY (SEND SEQUENCE :ARRAY))
	 (THIS-MSG (AREF ARRAY MSG-NO)))
    (WHEN (AND THIS-MSG (NEQ (MSG-PARSED-P THIS-MSG) :KILLED)
			(NOT (MSG-GET THIS-MSG 'DELETED)))
      (NOT (LOOP FOR I FROM (1+ MSG-NO) BELOW (ARRAY-ACTIVE-LENGTH ARRAY)
		 AS MSG = (AREF ARRAY I)
		 THEREIS (AND MSG (NEQ (MSG-PARSED-P MSG) :KILLED)
				  (NOT (MSG-GET MSG 'DELETED))))))))

;;; Pick the first or last message in a sequence --
;;;    If new messages are prepended, pick the first message; otherwise, pick the last.
(DEFUN FIRST-OR-LAST-MSG (SEQUENCE)
  (WHEN (PLUSP (SEQUENCE-NMSGS SEQUENCE))
    (AREF (SEQUENCE-ARRAY SEQUENCE)
	  (IF (SEQUENCE-APPEND-P SEQUENCE) (1- (SEQUENCE-NMSGS SEQUENCE)) 0))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SET-POP-MARK "Sets or pops the mark.
With no U's, sets the mark at the point, and pushes point onto the point pdl.
With one U, pops the point pdl.
With two U's, pops the point pdl and throws it away" (NUMERIC-ARG-OK)
  (COND (( *NUMERIC-ARG* 3)
	 (MSG-POINT-PDL-PUSH *MSG* *SEQUENCE*)
	 DIS-NONE)
	(( *NUMERIC-ARG* 17)
	 (MSG-POINT-PDL-MOVE (MSG-POINT-PDL-POP)))
	(T
	 (MSG-POINT-PDL-POP)
	 DIS-NONE)))

(DEFUN MAKE-MSG-MARK (&OPTIONAL (MSG *MSG*) (SEQUENCE *SEQUENCE*))
  (IF (EQ MSG ':NO-SELECT) (BARF)
    (LET* ((INT (WINDOW-INTERVAL *MSG-WINDOW*))
	   (START-BP (INTERVAL-FIRST-BP INT)))
      (AND (BP-= (INTERVAL-FIRST-BP INT) (MSG-START-BP MSG))
	   (BP-= (INTERVAL-LAST-BP INT) (MSG-END-BP MSG))
	   (SETQ START-BP (COPY-BP (WINDOW-START-BP *MSG-WINDOW*) ':NORMAL)))
      (LIST MSG SEQUENCE START-BP))))

(DEFUN MSG-POINT-PDL-PUSH (MSG SEQUENCE)
  (COND ((AND (NEQ MSG ':NO-SELECT)
	      (NEQ (MSG-PARSED-P MSG) ':KILLED))
	 (PUSH (MAKE-MSG-MARK MSG SEQUENCE) *MSG-POINT-PDL*)
	 (AND (> (LENGTH *MSG-POINT-PDL*) *POINT-PDL-MAX*)
	      (LET* ((ENTRY (DELETE-LAST-ELEMENT *MSG-POINT-PDL*))
		     (BP (THIRD ENTRY)))
		(IF BP (FLUSH-BP BP)))))))

(DEFUN MSG-POINT-PDL-POP ()
  (OR *MSG-POINT-PDL* (BARF))
  (PROG1 (CAR *MSG-POINT-PDL*)
	 (SETQ *MSG-POINT-PDL* (NCONC (CDR *MSG-POINT-PDL*) (RPLACD *MSG-POINT-PDL* NIL)))))

(SCL:DEFINE-PRESENTATION-TYPE POINT-PDL-ELEMENT ()
  :EXPANDER 'T
  :PRINTER ((ELEMENT STREAM)
	    (FORMAT STREAM "message #~D in ~A"
		    (1+ (LOCATE-MSG-IN-SEQUENCE (FIRST ELEMENT) (SECOND ELEMENT)))
		    (SECOND ELEMENT)))
  )

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MSG-POINT-PDL-MOVE
						  (POINT-PDL-ELEMENT "Select" *ZMAIL-COMTAB*
								     :GESTURE :SELECT)
						  (ELEMENT)
  `(MSG-POINT-PDL-MOVE ,ELEMENT))

(DEFUN MSG-POINT-PDL-MOVE (ENTRY &AUX MSG SEQUENCE START-BP)
  (SETF `(,MSG ,SEQUENCE ,START-BP) ENTRY)
  (UNLESS (EQ SEQUENCE *SEQUENCE*)
    (SELECT-SEQUENCE SEQUENCE NIL NIL NIL))
  (ZMAIL-SELECT-MSG MSG NIL NIL)
  (WHEN START-BP
    (RECENTER-WINDOW *MSG-WINDOW* ':START START-BP))
  DIS-ALL)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MOVE-TO-PREVIOUS-POINT
				"Exchange point and top of point pdl.
A numeric argument rotates top arg entries of the point pdl (the default
numeric argument is 2).  An argument of 1 rotates the whole point pdl
and a negative argument rotates the other way." (NUMERIC-ARG-OK)
  (ROTATE-MSG-POINT-PDL (IF *NUMERIC-ARG-P* *NUMERIC-ARG* 2)))

(DEFVAR *DEFAULT-PREVIOUS-MSG-POINT-ARG* 3)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MOVE-TO-DEFAULT-PREVIOUS-POINT
				"Rotate the point pdl.
A numeric argument specifies the number of entries to rotate, and sets the new default."
				(NUMERIC-ARG-OK)
  (AND *NUMERIC-ARG-P*
       (SETQ *DEFAULT-PREVIOUS-MSG-POINT-ARG* *NUMERIC-ARG*))
  (ROTATE-MSG-POINT-PDL *DEFAULT-PREVIOUS-MSG-POINT-ARG*))

(DEFUN ROTATE-MSG-POINT-PDL (N &AUX ENTRY LIST)
  (SETQ ENTRY (LIST *MSG* *SEQUENCE* (COPY-BP (WINDOW-START-BP *MSG-WINDOW*) ':NORMAL))
	LIST (CONS ENTRY *MSG-POINT-PDL*))
  (ROTATE-TOP-OF-LIST LIST N)
  (SETQ ENTRY (CAR LIST))
  (MSG-POINT-PDL-MOVE ENTRY)
  DIS-BPS)

(DEFUN MSG-POINT-PDL-PURGE (*MSG* *SEQUENCE*)
  (SETQ *MSG-POINT-PDL* (DEL-IF #'(LAMBDA (X)
				    (AND (OR (NULL *MSG*)
					     (EQ (FIRST X) *MSG*))
					 (OR (NULL *SEQUENCE*)
					     (EQ (SECOND X) *SEQUENCE*))))
				*MSG-POINT-PDL*)))

(DEFUN MSG-POINT-PDL-FORWARD-SEQUENCE (FROM TO)
  (DOLIST (ELEM *MSG-POINT-PDL*)
    (COND ((EQ (SECOND ELEM) FROM)
	   (SETF (SECOND ELEM) TO)
	   (AND (BP-< (THIRD ELEM) (MSG-START-BP (FIRST ELEM)))
		(MOVE-BP (THIRD ELEM) (MSG-START-BP (FIRST ELEM))))))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MOUSE-POINT-PDL "Give menu of message point pdl" ()
  (LET (*TYPEOUT-WINDOW* (N 0))
    (IF (TV:SHEET-EXPOSED-P *SUMMARY-WINDOW*)
	(SETQ *TYPEOUT-WINDOW* (SEND *SUMMARY-WINDOW* :TYPEOUT-WINDOW))
      (SETQ *TYPEOUT-WINDOW* (WINDOW-TYPEOUT-WINDOW *WINDOW*))
      (SEND *TYPEOUT-WINDOW* :LINE-OUT *SUMMARY-WINDOW-LABEL*))
    (SEND *TYPEOUT-WINDOW* :OUTPUT-HOLD-EXCEPTION)	;Make sure properly typeout exposed
    (TV:WINDOW-CALL-RELATIVE (*TYPEOUT-WINDOW*)	;For **MORE** blinking
      (LET ((*COMTAB* *ZMAIL-COMTAB*))		;For mouse-sensitivity at **MORE** breaks
	(DOLIST (ELEM *MSG-POINT-PDL*)
	  (LET* ((MSG (CAR ELEM))
		 (STATUS (ASSURE-MSG-PARSED MSG)))
	    (TRUNCATED-SENSITIVE-FORMAT ELEM 'POINT-PDL-ELEMENT *TYPEOUT-WINDOW*
					"~\ZWEI:ARROW\~3D~C~A~%"
					(EQ MSG *MSG*) (SETQ N (1+ N)) (STATUS-LETTER STATUS)
					(MSG-SUMMARY-LINE MSG))))
	(SEND *TYPEOUT-WINDOW* :LINE-OUT "Done.")))
    (CHECK-FOR-ZMAIL-TYPEOUT-WINDOW-TYPEOUT))
  DIS-NONE)

(SCL:DEFINE-PRESENTATION-TYPE MSG-LINE ()
  :EXPANDER 'T
  :PRINTER ((MSG-LINE STREAM)
	    (FORMAT STREAM "the message containing /"~A/"" MSG-LINE)))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SELECT-MSG-FROM-LINE
						  (MSG-LINE "Select" *ZMAIL-COMTAB*
							    :GESTURE :SELECT)
						  (MSG-LINE)
  `(SELECT-MSG-FROM-LINE ,MSG-LINE))

;;; Select the message as pointed to by the typeout window
(DEFUN SELECT-MSG-FROM-LINE (MSG-LINE)
  (DO-UNIVERSE (MSG *SEQUENCE*
		    :NOTE-PROGRESS "Searching through ~A.")
    (WHEN (LOOP WITH END-LINE = (BP-LINE (MSG-END-BP MSG))
		FOR LINE = (BP-LINE (MSG-START-BP MSG)) THEN (LINE-NEXT LINE)
		UNTIL (EQ LINE END-LINE)
		THEREIS (EQ LINE MSG-LINE))
      (RETURN-FROM SELECT-MSG-FROM-LINE (ZMAIL-SELECT-MSG MSG))))
  (BARF "Search failed: ~A" MSG-LINE))

;;; Select a msg, possibly changing to its buffer
(DEFUN SELECT-MSG-AND-POSSIBLY-BUFFER (MSG)
  (LET ((I (MSG-IN-SEQUENCE-P MSG *SEQUENCE*)))
    (COND ((EQ (MSG-PARSED-P MSG) :KILLED)
	   (BARF "The message has been expunged."))
	  ((NULL I)
	   (SELECT-SEQUENCE (MSG-BUFFER MSG) NIL NIL)
	   (ZMAIL-SELECT-MSG MSG NIL NIL))
	  (T
	   (ZMAIL-SELECT-MSG I)))))

(DEFUN MSG-IN-SEQUENCE-P (MSG SEQUENCE)
  (LET ((ARRAY (SEQUENCE-ARRAY SEQUENCE))
	(NMSGS (SEQUENCE-NMSGS SEQUENCE)))
    (DO ((I 0 (1+ I)))
	(( I NMSGS))
      (WHEN (EQ MSG (AREF ARRAY I))
	(RETURN I)))))

(DEFUN LOCATE-MSG-IN-SEQUENCE (MSG SEQUENCE &OPTIONAL (ERROR-P T) &AUX HINT)
  (COND ((AND (SETQ HINT (MSG-DISPLAYED-INDEX MSG))
	      (< HINT (SEQUENCE-NMSGS SEQUENCE))
	      (EQ MSG (AREF (SEQUENCE-ARRAY SEQUENCE) HINT)))
	 HINT)
	((MSG-IN-SEQUENCE-P MSG SEQUENCE))
	(ERROR-P
	 (FERROR "Cannot find ~S in ~S" MSG SEQUENCE))))

;;; Reordering sequences (sorting)

;;; Used by sort and reverse.  Whole sequence order needs rethinking.
(DEFUN SEQUENCE-REARRANGED (SEQUENCE &KEY SOFT)
  (MARK-SEQUENCE-MODIFIED SEQUENCE :HARD (NOT SOFT))
  (WHEN (EQ SEQUENCE *SEQUENCE*)
    (SEND *SUMMARY-WINDOW* ':NEED-FULL-REDISPLAY T)
    (UNLESS (SYMBOLP *MSG*)
      (SETQ *MSG-NO* (LOCATE-MSG-IN-SEQUENCE *MSG* *SEQUENCE*)))
    (COMPUTE-CURRENT-MSG-STATE))
  DIS-TEXT)

;;; Reverse the order of messages in a mail file
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-REVERSE-SEQUENCE
				"Reverse the messages in the current sequence"
				()
  (ZMAIL-UNDO-SAVE 'UNDO-REARRANGE ':NAME "reverse" ':SEQUENCE *SEQUENCE*)
  (REVERSE-SEQUENCE *SEQUENCE*))

(DEFUN REVERSE-SEQUENCE (SEQUENCE)
  (LOCK-SEQUENCE (SEQUENCE :WRITE)
    (ARRAY-NREVERSE (SEND SEQUENCE ':ARRAY)))
  (SEQUENCE-REARRANGED SEQUENCE))

;;; This ought to be someplace else, maybe it is even
(DEFUN ARRAY-NREVERSE (ARRAY)
  (DO ((I 0 (1+ I))
       (J (1- (ARRAY-ACTIVE-LENGTH ARRAY)) (1- J)))
      ((< J I))
    (SWAPF (AREF ARRAY I) (AREF ARRAY J)))
  ARRAY)

(DEFINE-ZMAIL-GLOBAL *LAST-SORT-MODE* 'MSG-DATE-SORT-LESSP)
(DEFINE-ZMAIL-GLOBAL *LAST-SORT-DIRECTION* ':FORWARD)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-SORT (STRING &AUX SEQUENCE-MODE)
  (APPEND-TO-ARRAY STRING "Sort buffer or collection:")
  (APPEND-MULTIPLE-MENU-DOCUMENTATION STRING *MSG-SORT-KEY-ALIST* "by"
				      #/L *LAST-SORT-MODE* *LAST-SORT-DIRECTION*)
  (AND *SEQUENCE*
       (SETQ SEQUENCE-MODE (SEND *SEQUENCE* ':GET ':SORT))
       (APPEND-MULTIPLE-MENU-DOCUMENTATION STRING *MSG-SORT-KEY-ALIST* "by"
					   #/M SEQUENCE-MODE
					   (IF (SEQUENCE-APPEND-P *SEQUENCE*)
					       ':FORWARD ':BACKWARD)))
  (APPEND-TO-ARRAY STRING " R: menu."))

(DEFUN APPEND-MULTIPLE-MENU-DOCUMENTATION (STRING ALIST NAME BUTTON MODE DIRECTION
					   &AUX NAME-1 NAME-2)
  (COND ((AND (SETQ NAME-1 (NAME-FROM-MENU-VALUE DIRECTION (CADR ALIST)))
	      (SETQ NAME-2 (NAME-FROM-MENU-VALUE MODE (CAR ALIST))))
	 (ARRAY-PUSH-EXTEND STRING #\SP)
	 (ARRAY-PUSH-EXTEND STRING BUTTON)
	 (APPEND-TO-ARRAY STRING ": ")
	 (APPEND-TO-ARRAY STRING NAME-1)
	 (ARRAY-PUSH-EXTEND STRING #\SP)
	 (APPEND-TO-ARRAY STRING NAME)
	 (ARRAY-PUSH-EXTEND STRING #\SP)
	 (APPEND-TO-ARRAY STRING NAME-2)
	 (ARRAY-PUSH-EXTEND STRING #\;
			    ))))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *SEQUENCE* COM-ZMAIL-SORT)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SORT "Sort the current buffer or collection.
Click right to specify sort key and//or direction." ()
  (LET ((MODE *LAST-SORT-MODE*)
	(DIRECTION *LAST-SORT-DIRECTION*))
    (SELECTQ *ZMAIL-COMMAND-BUTTON*
      (:MIDDLE
       (SETQ MODE (OR (SEND *SEQUENCE* ':GET ':SORT)
		      'MSG-NOOP-SORT-LESSP)
	     DIRECTION (IF (SEQUENCE-APPEND-P *SEQUENCE*) ':FORWARD ':BACKWARD)))
      (:RIGHT
       (MULTIPLE-VALUE (MODE DIRECTION)
	 (DEFAULTED-MULTIPLE-MENU-CHOOSE-NEAR-MENU *MSG-SORT-KEY-ALIST*
						   *LAST-SORT-MODE* *LAST-SORT-DIRECTION*))
       (SETQ *LAST-SORT-MODE* MODE
	     *LAST-SORT-DIRECTION* DIRECTION)
       (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-SORT)))
    (WHEN (EQ MODE 'MSG-NOOP-SORT-LESSP)	; force noop to be a noop...
      (BARF "There is no default sort key for this sequence."))
    (SORT-SEQUENCE *SEQUENCE* MODE (EQ DIRECTION ':FORWARD))))

(DEFUN SORT-SEQUENCE (SEQUENCE MODE FORWARD-P &OPTIONAL CALLED-FROM-INBOX)
  (WHEN (AND (SEQUENCE-BUFFER-P SEQUENCE) (NOT CALLED-FROM-INBOX))
    (COMPLETE-MAIL-FILE-IO SEQUENCE :ABORT-SAVES T))
  ;; Parse everything now, just in case.
  (DO-UNIVERSE (MSG SEQUENCE
		    :NO-PREPARE T
		    :NOTE-PROGRESS "Parsing messages in ~A.")
    (ASSURE-MSG-PARSED MSG))
  (ZMAIL-UNDO-SAVE 'UNDO-REARRANGE :NAME "sort" :SEQUENCE SEQUENCE)
  (LOCK-SEQUENCE (SEQUENCE :WRITE)
    (SORT-SEQUENCE-INTERNAL SEQUENCE MODE FORWARD-P (SEQUENCE-ARRAY SEQUENCE) NIL))
  (SEQUENCE-REARRANGED SEQUENCE))

(DEFUN SORT-SEQUENCE-INTERNAL (SEQUENCE MODE FORWARD-P ARRAY INCOMPLETE-P)
  (MULTIPLE-VALUE-BIND (PREDICATE TRANSFORMER STABLE-NEEDED DELAY-IF-INCOMPLETE)
      (LET ((FUNCTION (GET MODE 'SORT-OPTIMIZER)))
	(AND FUNCTION (FUNCALL FUNCTION SEQUENCE FORWARD-P)))
    (UNLESS (AND INCOMPLETE-P DELAY-IF-INCOMPLETE)
      (IF PREDICATE
	  (LET ((COPY (MAKE-ARRAY (ARRAY-ACTIVE-LENGTH ARRAY))))
	    (LOOP FOR MSG BEING THE ARRAY-ELEMENTS OF ARRAY USING (INDEX I)
		  DO (ASET (CONS (FUNCALL TRANSFORMER MSG) MSG) COPY I))
	    (FUNCALL (IF STABLE-NEEDED
			 (IF FORWARD-P #'STABLE-SORTCAR #'REVERSE-STABLE-SORTCAR)
			 (IF FORWARD-P #'SORTCAR #'REVERSE-SORTCAR))
		     COPY PREDICATE)
	    (LOOP FOR (NIL . MSG) BEING THE ARRAY-ELEMENTS OF COPY USING (INDEX I)
		  DO (ASET MSG ARRAY I)))
	  (FUNCALL (IF FORWARD-P #'STABLE-SORT #'REVERSE-STABLE-SORT)
		   (SEND SEQUENCE ':ARRAY) MODE))
      T)))

(DEFMACRO DEFINE-NORMAL-SORT-PREDICATE (NAME PREDICATE MENU-NAME DOCUMENTATION TRANSFORMER
					&OPTIONAL (STABLE-NEEDED 'T) DELAY-IF-INCOMPLETE)
  `(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,NAME DEFINE-NORMAL-SORT-PREDICATE))
     (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-NORMAL-SORT-PREDICATE)
     (DEFUN ,NAME (MSG-1 MSG-2)
       ,DOCUMENTATION
       (,PREDICATE ,(SUBST 'MSG-1 'MSG TRANSFORMER)
		   ,(SUBST 'MSG-2 'MSG TRANSFORMER)))
     (DEFUN (:PROPERTY ,NAME SORT-OPTIMIZER) (SEQUENCE IGNORE)
       SEQUENCE
       (VALUES #',PREDICATE
	       #'(LAMBDA (MSG) ,TRANSFORMER)
	       ,STABLE-NEEDED
	       ,DELAY-IF-INCOMPLETE))
     ,(WHEN MENU-NAME
	`(ADD-SORT-PREDICATE-TO-MENU ',NAME ',MENU-NAME ',DOCUMENTATION))))

(DEFPROP DEFINE-NORMAL-SORT-PREDICATE "Zmail normal sort predicate" SI:DEFINITION-TYPE-NAME)

;;; Add the sort predicate to the lists accepted by the sort command and mail buffers
(DEFUN ADD-SORT-PREDICATE-TO-MENU (FUNCTION MENU-NAME DOCUMENTATION)
  (SETQ *SORT-KEY-ALIST-1*
	(NCONC
	  (DEL-IF #'(LAMBDA (SORT-KEY) (EQUAL (CAR SORT-KEY) MENU-NAME)) *SORT-KEY-ALIST-1*)
	  `((,MENU-NAME :VALUE ,FUNCTION :DOCUMENTATION ,DOCUMENTATION))))
  (SETF (FIRST *MSG-SORT-KEY-ALIST*)
	`(,@*SORT-KEY-ALIST-1* ,@(LAST (FIRST *MSG-SORT-KEY-ALIST*))))
  (SETF *MAIL-BUFFER-SORT-ALIST*
	`(,(FIRST *MAIL-BUFFER-SORT-ALIST*) ,@*SORT-KEY-ALIST-1*))
  (LET ((FILE-SORT-OPTION (ASSQ ':SORT *MAIL-FILE-OPTION-ALIST*)))
    (WHEN FILE-SORT-OPTION
      (SETF (FOURTH FILE-SORT-OPTION) `(,@*MAIL-BUFFER-SORT-ALIST*))))
  FUNCTION)

(DEFMACRO DEFINE-HEADER-FIELD-SORT-PREDICATE (HEADER-NAME)
  (MULTIPLE-VALUE-BIND (NAME PREDICATE MENU-NAME DOCUMENTATION TRANSFORMER)
      (HEADER-FIELD-SORT-PARAMETERS HEADER-NAME)
    `(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,HEADER-NAME DEFINE-HEADER-FIELD-SORT-PREDICATE))
       (RECORD-SOURCE-FILE-NAME ',HEADER-NAME 'DEFINE-HEADER-FIELD-SORT-PREDICATE)
       (DEFINE-NORMAL-SORT-PREDICATE ,NAME ,PREDICATE ,MENU-NAME ,DOCUMENTATION
				     ,TRANSFORMER))))

(DEFPROP DEFINE-HEADER-FIELD-SORT-PREDICATE "Header field sort predicate"
	 SI:DEFINITION-TYPE-NAME)

(EVAL-WHEN (COMPILE LOAD EVAL)

(DEFUN HEADER-FIELD-SORT-PARAMETERS (HEADER-NAME)
  (DECLARE (VALUES NAME PREDICATE MENU-NAME DOCUMENTATION TRANSFORMER))
  (LET (SORT-HOW PREDICATE TRANSFORMER)
    (HEADER-TYPE-TYPECASE HEADER-NAME
      ((:DATE :DATE-AND-OPTIONAL-TIME)
       (SETQ SORT-HOW "Chronologically"
	     PREDICATE '<
	     TRANSFORMER `(OR (MSG-GET-DATE MSG ',HEADER-NAME) -1)))
      ((:ADDRESS)
       (SETQ PREDICATE 'MSG-RECIPIENT-LESSP-1)))
    (LET ((MENU-NAME (HEADER-TYPE-NAME HEADER-NAME)))
      (VALUES (INTERN (FORMAT NIL "MSG-~A-SORT-LESSP" HEADER-NAME) *EDITOR-PACKAGE*)
	      (OR PREDICATE 'STRING-OR-NIL-LESSP)
	      MENU-NAME
	      (FORMAT NIL "~A by ~A: field." (OR SORT-HOW "Alphabetically") MENU-NAME)
	      (OR TRANSFORMER
		  (IF (NULL PREDICATE)
		      `(LET ((TEM (MSG-GET MSG ',HEADER-NAME)))
			 (IF (LISTP TEM) (CAR TEM) TEM))
		      `(MSG-GET MSG ',HEADER-NAME)))))))
)

;;; Keep the status quo
(DEFINE-NORMAL-SORT-PREDICATE MSG-NOOP-SORT-LESSP IGNORE NIL NIL MSG NIL)

(DEFUN MSG-GET-DATE (MSG &OPTIONAL (TYPE ':DATE))
  (MSG-STATUS-GET-DATE (ASSURE-MSG-PARSED MSG) TYPE))

(DEFUN MSG-STATUS-GET-DATE (STATUS &OPTIONAL (TYPE ':DATE))
  (LET ((DATE (GET STATUS TYPE)))
    (IF (LISTP DATE) (CAR DATE) DATE)))

(DEFUN MSG-RECIPIENT-LESSP (TYPE MSG-1 MSG-2)
  (MSG-RECIPIENT-LESSP-1 (MSG-GET MSG-1 TYPE) (MSG-GET MSG-2 TYPE)))

(DEFUN MSG-RECIPIENT-LESSP-1 (FIELD-1 FIELD-2)
  (DO ((PL1) (PL2) (STR1) (STR2))
      (NIL)
    (COND ((NULL FIELD-1) (RETURN (NOT (NULL FIELD-2))))
	  ((NULL FIELD-2) (RETURN NIL))
	  ((NOT (STRING-EQUAL (SETQ STR1 (GET (SETQ PL1 (LOCF (CAR FIELD-1))) :NAME))
			      (SETQ STR2 (GET (SETQ PL2 (LOCF (CAR FIELD-2))) :NAME))))
	   (RETURN (STRING-LESSP STR1 STR2)))
	  ((NULL (SETQ STR1 (GET PL1 :HOST))) (RETURN (NOT (NULL (GET PL2 :HOST)))))
	  ((NULL (SETQ STR2 (GET PL2 :HOST))) (RETURN NIL))
	  ((NOT (STRING-EQUAL (SETQ STR1 (STRING-FROM-HOST STR1 :HOST))
			      (SETQ STR2 (STRING-FROM-HOST STR2 :HOST))))
	   (RETURN (STRING-LESSP STR1 STR2))))
    (SETQ FIELD-1 (CDR FIELD-1)
	  FIELD-2 (CDR FIELD-2))))

(DEFUN STRING-OR-NIL-LESSP (STR1 STR2)
  (COND ((NULL STR1) (NOT (NULL STR2)))
	((NULL STR2) NIL)
	(T (STRING-LESSP STR1 STR2))))

(DEFINE-HEADER-FIELD-SORT-PREDICATE :DATE)
(DEFINE-HEADER-FIELD-SORT-PREDICATE :TO)
(DEFINE-HEADER-FIELD-SORT-PREDICATE :FROM)

;;can't just use (define-header-field-sort-predicate :start-date) because it uses
;;< for comparison, and start-date has a list for time.

(defun <-start-date (x y)
  (cond ((and (listp x) (listp y))
	 (< (car x) (car y)))
	((listp x) nil)
	((listp y) t)
	(t (< x y))))

(DEFINE-NORMAL-SORT-PREDICATE MSG-START-DATE-SORT-LESSP
                                <-start-date
                                "Start-date"
                                "Chronologically by Start-date: field."
                                (OR (MSG-GET-DATE MSG ':START-DATE)
                                    -1))

(DEFINE-NORMAL-SORT-PREDICATE MSG-EXPIRATION-DATE-SORT-LESSP
                                <-start-date
                                "Expiration-date"
                                "Chronologically by Expiration-date: field."
                                (OR (MSG-GET-DATE MSG ':EXPIRATION-DATE)
                                    -1))

(DEFINE-NORMAL-SORT-PREDICATE MSG-SUBJECT-SORT-LESSP STRING-OR-NIL-LESSP "Subject"
  "Alphabetically by subject."
  (MSG-GET-CANONICAL-SUBJECT MSG))

(DEFUN MSG-GET-REAL-SUBJECT (MSG)
  (LET* ((STATUS (ASSURE-MSG-PARSED MSG))
	 (REAL-SUBJECT (GET STATUS 'REAL-SUBJECT))
	 (ACTUAL-SUBJECT (GET STATUS :SUBJECT)))
    (COND ((EQ REAL-SUBJECT :ACTUAL-SUBJECT) ACTUAL-SUBJECT)
	  (REAL-SUBJECT)
	  ((NULL ACTUAL-SUBJECT) NIL)
	  (T
	   (LET ((REAL-SUBJECT (SUBJECT-TO-STRING ACTUAL-SUBJECT)))
	     (MSG-PUT MSG (IF (EQ REAL-SUBJECT ACTUAL-SUBJECT)
			      :ACTUAL-SUBJECT
			      REAL-SUBJECT)
		      'REAL-SUBJECT)
	     REAL-SUBJECT)))))

(DEFUN MSG-GET-CANONICAL-SUBJECT (MSG)
  (LET* ((STATUS (ASSURE-MSG-PARSED MSG))
	 (CANONICAL-SUBJECT (GET STATUS 'CANONICAL-SUBJECT))
	 (REAL-SUBJECT (MSG-GET-REAL-SUBJECT MSG)))
    (COND ((EQ CANONICAL-SUBJECT :REAL-SUBJECT) REAL-SUBJECT)
	  (CANONICAL-SUBJECT)
	  ((NULL REAL-SUBJECT) NIL)
	  (T
	   (LET ((CANONICAL-SUBJECT (SUBJECT-TO-STRING (GET-MSG-SUBJECT-CLEVERLY MSG NIL))))
	     (MSG-PUT MSG (IF (STRING-EQUAL CANONICAL-SUBJECT REAL-SUBJECT)
			      :REAL-SUBJECT
			      CANONICAL-SUBJECT)
		      'CANONICAL-SUBJECT)
	     CANONICAL-SUBJECT)))))

(DEFUN KEYWORD-STRING-LESSP (STR1 STR2)
  (COND ((NULL STR1) (NOT (NULL STR2)))
	((NULL STR2) NIL)
	(T (STRING-LESSP STR1 STR2 1 1 (1- (STRING-LENGTH STR1)) (1- (STRING-LENGTH STR2))))))

(DEFINE-NORMAL-SORT-PREDICATE MSG-KEYWORD-LESSP KEYWORD-STRING-LESSP "Keywords"
  "Alphabetically by keywords present."
  (MSG-GET MSG 'KEYWORDS-STRING))

(DEFUN INTERVAL-LESSP-1 (INTERVAL-1 INTERVAL-2)
  (INTERVAL-LESSP INTERVAL-1 NIL T INTERVAL-2 NIL T))

(DEFINE-NORMAL-SORT-PREDICATE MSG-TEXT-STRING-LESSP INTERVAL-LESSP-1 "Text"
  "Alphabetically by actual message text."
  (MSG-INTERVAL MSG))

(DEFINE-NORMAL-SORT-PREDICATE MSG-LENGTH-LESSP < "Length"
  "Numerically by length of message in characters."
  (COMPUTE-MSG-LENGTH MSG))

(DEFUN COMPUTE-MSG-LENGTH (MSG)
  (OR (MSG-GET MSG 'LENGTH)
      (LET ((LENGTH (COUNT-CHARS (MSG-INTERVAL MSG)) ))
	(MSG-PUT MSG LENGTH 'LENGTH)
	LENGTH)))

(DEFUN (:PROPERTY MSG-POSITION-LESSP SORT-OPTIMIZER) (SEQUENCE IGNORE)
  (IF (SEQUENCE-BUFFER-P SEQUENCE)
      (VALUES #'< #'(LAMBDA (MSG) (LOCATE-MSG-IN-SEQUENCE MSG (MSG-BUFFER MSG))) NIL)
      (VALUES #'(LAMBDA (POS-1 POS-2)
		  (IF (EQ (CAR POS-1) (CAR POS-2))
		      (< (CADR POS-1) (CADR POS-2))
		      (STRING-LESSP (CAR POS-1) (CAR POS-2))))
	      #'(LAMBDA (MSG &AUX (BUFFER (MSG-BUFFER MSG)))
		  (LIST (SEND BUFFER ':NAME)
			(LOCATE-MSG-IN-SEQUENCE MSG BUFFER)))
	      T)))

(DEFUN MSG-POSITION-LESSP (MSG-1 MSG-2 &AUX BUFFER-1 BUFFER-2)
  (SETQ BUFFER-1 (MSG-BUFFER MSG-1)
	BUFFER-2 (MSG-BUFFER MSG-2))
  (IF (NEQ BUFFER-1 BUFFER-2)
      (STRING-LESSP (SEND BUFFER-1 ':NAME) (SEND BUFFER-2 ':NAME))
      (DOMSGS (MSG BUFFER-1)
	(COND ((EQ MSG MSG-1) (RETURN T))	;Found first message, it is less
	      ((EQ MSG MSG-2) (RETURN NIL))))))

(DEFUN REVERSE-STABLE-SORT (OBJECT SORT-GREATERP-PREDICATE)
  (DECLARE (SYS:DOWNWARD-FUNARG SORT-GREATERP-PREDICATE))
  (STABLE-SORT OBJECT #'(LAMBDA (X Y) (FUNCALL SORT-GREATERP-PREDICATE Y X))))

(DEFUN REVERSE-STABLE-SORTCAR (OBJECT SORT-GREATERP-PREDICATE)
  (DECLARE (SYS:DOWNWARD-FUNARG SORT-GREATERP-PREDICATE))
  (STABLE-SORTCAR OBJECT #'(LAMBDA (X Y) (FUNCALL SORT-GREATERP-PREDICATE Y X))))

(DEFUN REVERSE-SORT (OBJECT SORT-GREATERP-PREDICATE)
  (DECLARE (SYS:DOWNWARD-FUNARG SORT-GREATERP-PREDICATE))
  (SORT OBJECT #'(LAMBDA (X Y) (FUNCALL SORT-GREATERP-PREDICATE Y X))))

(DEFUN REVERSE-SORTCAR (OBJECT SORT-GREATERP-PREDICATE)
  (DECLARE (SYS:DOWNWARD-FUNARG SORT-GREATERP-PREDICATE))
  (SORTCAR OBJECT #'(LAMBDA (X Y) (FUNCALL SORT-GREATERP-PREDICATE Y X))))

1;;; Moving messages between collections

;;; Single message ...

0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MOVE
				"Move a message into a sequence.
Keyboard:  Without a numeric argument, asks in the minibuffer for the pathname
	     of a mail file which will be created if necessary.
	   With a numeric argument, asks for a sequence name in the minibuffer.
Mouse-Left:  Moves to the sequence used as the target of the last move command.
Mouse-Middle:  Moves the message to one or more sequences as determined by 
	         applying filters to the message.
Mouse-Right:  Displays a menu of existing sequences, unloaded mail files,
  and special actions such as Read/Create file, New Collection, etc."
				(NUMERIC-ARG-OK)
  (MOVE-MSG-INTERNAL *MSG*)
  (COMPUTE-CURRENT-MSG-STATE)
  DIS-NONE)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-MOVE (STRING)
  (UPDATE-MOVE-TO-FILE-WHO-LINE-DOCUMENTATION STRING "Move message into sequence: " *MSG*))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *FILTER-MOVE-MAIL-FILE-ALIST* COM-ZMAIL-MOVE)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MOVE-MAIL-FILE-NAME* COM-ZMAIL-MOVE)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *LAST-HARDCOPY-OPTIONS* COM-ZMAIL-MOVE)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MOVE-SEQUENCE* COM-ZMAIL-MOVE)

1;;; Move a message from the current sequence to its prescribed destination.
0(DEFUN MOVE-MSG-INTERNAL (MSG)
  (LET ((DEFAULTED-MOVE-SEQUENCE (GET-DEFAULTED-MOVE-SEQUENCE MSG))
	(MSG-NO (IF (MSG-DISPLAYED-INDEX MSG) (1+ (MSG-DISPLAYED-INDEX MSG)))))
    (TYPEIN-LINE "Moved~@[ message /#~D~@[ from ~A~]~] to" MSG-NO (SEND *SEQUENCE* :NAME))
    (WHEN (AND (LISTP DEFAULTED-MOVE-SEQUENCE) (= (LENGTH DEFAULTED-MOVE-SEQUENCE) 1))
      (SETQ DEFAULTED-MOVE-SEQUENCE (FIRST DEFAULTED-MOVE-SEQUENCE)))
    (IF (LISTP DEFAULTED-MOVE-SEQUENCE)
	(LOOP WITH INCLUDE-COMMAS = (> (LENGTH DEFAULTED-MOVE-SEQUENCE) 2)
	      FOR (SEQUENCE . OTHER-SEQUENCES) ON DEFAULTED-MOVE-SEQUENCE
	      DO (SEND SEQUENCE :ADD-MSG MSG)
		 (TYPEIN-LINE-MORE " ~:[and ~]~A~:[.~;~:[~;,~]~]"
				   OTHER-SEQUENCES (SEND SEQUENCE :NAME)
				   OTHER-SEQUENCES INCLUDE-COMMAS))
      (SEND DEFAULTED-MOVE-SEQUENCE :ADD-MSG MSG)
      (TYPEIN-LINE-MORE " ~A." (SEND DEFAULTED-MOVE-SEQUENCE :NAME)))))


1;;; Multiple messages ...

0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MOVE-ALL-TO-FILE
				"Moves all messages in this sequence into another sequence.
Keyboard:  Without a numeric argument, asks in the minibuffer for the pathname
	     of a mail file which will be created if necessary.
	   With a numeric argument, asks for a sequence name in the minibuffer.
Mouse-Left:  Moves to the sequence used as the target of the last move command.
Mouse-Middle:  Moves each message to one or more sequences as determined by
	         applying filters individually to each message.
Mouse-Right:  Displays a menu of existing sequences, unloaded mail files,
  and special actions such as Read/Create file, New Collection, etc."
				(NUMERIC-ARG-OK)
  (LET ((SEQUENCE (LET ((*MSG* :NO-SELECT))
		    (GET-DEFAULTED-MOVE-SEQUENCE (FIRST-MSG-IF-ANY) T))))
    (IF (EQ SEQUENCE :INDIVIDUAL-FILTERS)
	(MACROLET ((MAKE-COUNTER (SEQUENCE &OPTIONAL (COUNT 0))
		     `(LIST ,SEQUENCE ,COUNT))
		   (COUNTER-SEQUENCE (COUNTER)
		     `(FIRST ,COUNTER))
		   (COUNTER-COUNT (COUNTER)
		     `(SECOND ,COUNTER)))
	  (LET ((UNMOVED-COUNTER (MAKE-COUNTER NIL))
		(SEQUENCE-COUNTERS NIL))
	    (CHECK-FOR-TOO-MANY-MSGS "move as many as" *SEQUENCE*
				     " to mail buffers determined individually by filtering")
	    (FORMAT T "~&Moving up to ~D message~:P by individual filtering ... "
		    (SEQUENCE-NMSGS *SEQUENCE*))
	    (DO-UNIVERSE (MSG *SEQUENCE* :NOTE-PROGRESS "Moving messages in ~A by filtering.")
	      (LET ((SEQUENCES (GET-MOVE-SEQUENCE-FROM-MSG-BY-FILTERING MSG)))
		(IF SEQUENCES
		    (DOLIST (SEQUENCE SEQUENCES)
		      (WHEN (OR (STRINGP SEQUENCE) (CL:PATHNAMEP SEQUENCE))
			(SETQ SEQUENCE (GET-BUFFER-FROM-PATHNAME SEQUENCE T)))
		      (WHEN SEQUENCE
			(LET ((SEQUENCE-COUNTER (ASSQ SEQUENCE SEQUENCE-COUNTERS)))
			  (IF SEQUENCE-COUNTER
			      (INCF (COUNTER-COUNT SEQUENCE-COUNTER))
			    (PUSH (MAKE-COUNTER SEQUENCE 1) SEQUENCE-COUNTERS)))
			(SEND SEQUENCE :ADD-MSG MSG)
			(WHEN (EQ MSG *MSG*)
			  (SETQ *DEFAULT-MOVE-SEQUENCE* SEQUENCE))))
		  (INCF (COUNTER-COUNT UNMOVED-COUNTER)))))
	    (IF (ZEROP (COUNTER-COUNT UNMOVED-COUNTER))
		(FORMAT T "done.~%")
	      (FORMAT T "~D message~:P not moved." (COUNTER-COUNT UNMOVED-COUNTER)))
	    (DOLIST (COUNTER SEQUENCE-COUNTERS)
	      (WHEN (NOT (ZEROP (COUNTER-COUNT COUNTER)))
		(FORMAT T "~&~4T~D message~:P moved to ~A.~%"
			(COUNTER-COUNT COUNTER) (SEQUENCE-NAME (COUNTER-SEQUENCE COUNTER))))))
	  )
      (CHECK-FOR-TOO-MANY-MSGS "move" *SEQUENCE* (FORMAT NIL " to ~A"
							 (SEQUENCE-NAME SEQUENCE)))
      (TYPEIN-LINE "Moving ~D message~:P to ~A ... "
		   (SEQUENCE-NMSGS *SEQUENCE*) (SEQUENCE-NAME SEQUENCE))
      (SEND SEQUENCE :ADD-SEQUENCE *SEQUENCE*)
      (TYPEIN-LINE-MORE "done.")))
  (COMPUTE-CURRENT-MSG-STATE)
  DIS-NONE)

(DEFPROP COM-ZMAIL-MOVE COM-ZMAIL-MOVE-ALL-TO-FILE ASSOCIATED-ALL-COMMAND)

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *LAST-HARDCOPY-OPTIONS*
					     COM-ZMAIL-MOVE-ALL-TO-FILE)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MOVE-SEQUENCE*
					     COM-ZMAIL-MOVE-ALL-TO-FILE)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-MOVE-ALL-TO-FILE (STRING)
  (UPDATE-MOVE-TO-FILE-WHO-LINE-DOCUMENTATION STRING "Move these messages into mail file: "
					      :INDIVIDUAL-FILTERS))

(DEFINE-COMMAND-MAP-OVER-DOCUMENTATION-UPDATER COM-ZMAIL-MOVE-ALL-TO-FILE
					       (FOR-DEFAULT-OR-MENU)
  (CL:ECASE FOR-DEFAULT-OR-MENU
    (:DEFAULT
      (WHEN (OR *DEFAULT-MOVE-SEQUENCE* *DEFAULT-MOVE-MAIL-FILE-NAME*)
	(FORMAT NIL "Move to ~A"
		(IF *DEFAULT-MOVE-SEQUENCE*
		    (IF (EQ (TYPEP *DEFAULT-MOVE-SEQUENCE*) 'HARDCOPY-MAIL-COLLECTION)
			(SEND *DEFAULT-MOVE-SEQUENCE* :FULL-NAME T)
		      (SEND *DEFAULT-MOVE-SEQUENCE* :NAME))
		  (STRING *DEFAULT-MOVE-MAIL-FILE-NAME*)))))
    (:MENU
      "Move to the destination selected from a menu.")))


1;;; Support ...

0(DEFUN UPDATE-MOVE-TO-FILE-WHO-LINE-DOCUMENTATION (STRING START MSG)
  (SETF (FILL-POINTER STRING) 0)		;In case called not from wholine updater
  (APPEND-TO-ARRAY STRING START)
  (WHEN (OR *DEFAULT-MOVE-SEQUENCE* *DEFAULT-MOVE-MAIL-FILE-NAME*)
    (FORMAT STRING "L: ~A; "
	    (IF *DEFAULT-MOVE-SEQUENCE*
		(IF (EQ (TYPEP *DEFAULT-MOVE-SEQUENCE*) 'HARDCOPY-MAIL-COLLECTION)
		    (SEND *DEFAULT-MOVE-SEQUENCE* :FULL-NAME (EQ MSG :INDIVIDUAL-FILTERS) T)
		  (SEND *DEFAULT-MOVE-SEQUENCE* :NAME))
	      (STRING *DEFAULT-MOVE-MAIL-FILE-NAME*))))
  (LET ((SEQUENCE (COND ((EQ MSG :INDIVIDUAL-FILTERS)
			 :INDIVIDUAL-FILTERS)
			((MEMQ MSG '(NIL :NO-SELECT)) NIL)
			(T
			 (GET-MOVE-SEQUENCE-FROM-MSG-BY-FILTERING MSG)))))
    (COND (SEQUENCE
	   (APPEND-TO-ARRAY STRING "M: ")
	   (LET ((DOC (CADR (ASSQ SEQUENCE '((:NEW-TEMP "New temporary")
					     (:OLD-TEMP "Recycled temporary")
					     (:FIND-FILE "Read//Create file")
					     (:TEXT-FILE "Just text")
					     (:HARDCOPY-WITH-OPTIONS
					    "Hardcopy selecting device and options from menu")
					     (:INDIVIDUAL-FILTERS "By individual filters")
					     )))))
	     (IF DOC (APPEND-TO-ARRAY STRING DOC)
	       (IF (AND (TYPEP SEQUENCE :LIST)
			(> (LENGTH SEQUENCE) 1.))	;more than one matching sequence
		   (SETQ SEQUENCE "By individual filters")	;give as much useful
		 (SETQ SEQUENCE (CAR SEQUENCE)))	;info as possible...
	       (AND (TYPEP SEQUENCE 'SEQUENCE)
		    (SETQ SEQUENCE (SEND SEQUENCE :NAME)))
	       (WHEN (TYPEP SEQUENCE 'HARDCOPY-MAIL-COLLECTION)
		 (SETQ SEQUENCE (SEND SEQUENCE :FULL-NAME (EQ MSG :INDIVIDUAL-FILTERS) T)))
	       (FORMAT STRING "~A" SEQUENCE)))
	   (APPEND-TO-ARRAY STRING "; "))))
  (APPEND-TO-ARRAY STRING "R: menu."))

(DEFUN GET-DEFAULTED-MOVE-SEQUENCE (&OPTIONAL MSG FOR-WHOLE-FILE-P)
  (LET ((SEQUENCE *DEFAULT-MOVE-SEQUENCE*))
    (COND
      (1;; This check causes 0[Map Over/Move(M)]1 to select separate targets for each message.
0       (AND FOR-WHOLE-FILE-P
	    (EQ *ZMAIL-COMMAND-BUTTON* :MIDDLE) *FILTER-MOVE-MAIL-FILE-ALIST*)
       (SETQ SEQUENCE :INDIVIDUAL-FILTERS))
      ((AND (EQ *ZMAIL-COMMAND-BUTTON* :KBD) (NOT *KBD-SAME-AS-MIDDLE*))
       (MULTIPLE-VALUE-BIND (CHOICE)
	   (IF *NUMERIC-ARG-P*
	       1;; Move to an existing sequence or known unloaded mail file --
0	       1;;    Defaults to either the last sequence that was the target of a move or
	       ;;    the default file for move operations if it's already loaded and/or it's
	       ;;    one of the other files listed in the profile.
0	       (LET* ((DEFAULT-MOVE-PATHNAME (DEFAULT-ZMAIL-MOVE-PATHNAME))
		      (DEFAULT (COND (*DEFAULT-MOVE-SEQUENCE*)
				     ((CL:FIND DEFAULT-MOVE-PATHNAME *SEQUENCE-LIST*
					       :TEST #'(LAMBDA (PATH SEQUENCE)
							 (AND (SEQUENCE-BUFFER-P SEQUENCE)
							      (EQL PATH (MSG-BUFFER-PATHNAME
									  SEQUENCE))))))
				     ((MULTIPLE-VALUE-BIND (IGNORE IGNORE UNLOADED-FILES)
					  (GET-SEQUENCE-ALISTS)
					(CL:FIND DEFAULT-MOVE-PATHNAME UNLOADED-FILES
								       :KEY #'CDR))
				      DEFAULT-MOVE-PATHNAME)
				     (T NIL))))
		 (TYPEIN-LINE-ACCEPT 'SEQUENCE-OR-UNLOADED-MAIL-FILE
				     :PROMPT "Move to sequence"
				     :DEFAULT DEFAULT))
	       1;; Move to an arbitrary file.
0	       (ACCEPT-DEFAULTED-PATHNAME "Move to file"
					  (IF (AND *DEFAULT-MOVE-SEQUENCE*
						   (SEQUENCE-BUFFER-P *DEFAULT-MOVE-SEQUENCE*))
					      (MSG-BUFFER-PATHNAME *DEFAULT-MOVE-SEQUENCE*)
					      (DEFAULT-ZMAIL-MOVE-PATHNAME))))
	 (SETQ SEQUENCE (CL:ETYPECASE CHOICE
			  (SEQUENCE CHOICE)
			  (FS:PATHNAME (GET-BUFFER-FROM-PATHNAME CHOICE T)))
	       *DEFAULT-MOVE-SEQUENCE* SEQUENCE)
	 (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*DEFAULT-MOVE-SEQUENCE*)))
      ((NEQ *ZMAIL-COMMAND-BUTTON* :LEFT)
       (MULTIPLE-VALUE (SEQUENCE NIL)
	 (GET-MOVE-BUFFER (AND (NEQ *ZMAIL-COMMAND-BUTTON* :RIGHT) MSG) FOR-WHOLE-FILE-P))
       (COND ((NULL SEQUENCE)
	      (ABORT-CURRENT-COMMAND))
	     ((SYMBOLP SEQUENCE))
	     (T
	      (IF (LISTP SEQUENCE)
		  (SETQ *DEFAULT-MOVE-SEQUENCE* (FIRST SEQUENCE))
		  (SETQ *DEFAULT-MOVE-SEQUENCE* SEQUENCE))
	      (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*DEFAULT-MOVE-SEQUENCE*))
	     ))
      ((NOT (NULL *DEFAULT-MOVE-SEQUENCE*)))
      (*DEFAULT-MOVE-MAIL-FILE-NAME*
       (SETQ SEQUENCE (GET-BUFFER-FROM-PATHNAME *DEFAULT-MOVE-MAIL-FILE-NAME* T)
	     *DEFAULT-MOVE-SEQUENCE* SEQUENCE)
       (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*DEFAULT-MOVE-SEQUENCE*))
      (T
       (BARF "There is no default target for moving.")))
    SEQUENCE))

1;;; 2msg 1is a message to check with filters and look for a buffer from
;;; 2*filter-move-mail-file-alist*1.
0(DEFUN GET-MOVE-BUFFER (&OPTIONAL MSG FOR-WHOLE-FILE-P ONLY-DISK-P &AUX NEW-P)
  (DECLARE (VALUES BUFFER NEW-P))
  (GET-MOVE-BUFFER-MENU FOR-WHOLE-FILE-P ONLY-DISK-P NIL)
  (UNWIND-PROTECT
      (TV:SAVING-MOUSE-POSITION *MOVE-SEQUENCE-MENU*
	(DO ((BUFFER)
	     (ALWAYS-NEW-FLAVOR NIL NIL))
	    (NIL)
	  (IF MSG
	      1;; Let the user get out anything that could appear in the menu, including
	      ;; hardcopy, 2:find-file1, 2:menu-choose1, etc.
0	      (SETQ BUFFER (OR (GET-MOVE-SEQUENCE-FROM-MSG-BY-FILTERING MSG)
			       (BARF "Cannot find suitable filter")))
	    1;; This is a noop if already exposed
0	    (TV:EXPOSE-WINDOW-NEAR *MOVE-SEQUENCE-MENU* (RECTANGLE-NEAR-COMMAND-MENU))
	    (SETQ BUFFER (LET ((TV:*RESTORE-MOUSE-POSITION-AFTER-MENU-SELECTION* NIL))
			   (SEND *MOVE-SEQUENCE-MENU* :CHOOSE)))
	    (SET-COMMAND-BUTTON (SEND *MOVE-SEQUENCE-MENU* :LAST-BUTTONS)))
	  (WHEN (LISTP BUFFER)
	    (LOOP FOR B IN BUFFER
		  WHEN (OR (STRINGP B) (TYPEP B 'FS:PATHNAME))
		    DO (LET ((PATHNAME B))
			 (COND ((SETQ B (GET-BUFFER-FROM-PATHNAME B NIL)))
			       (T
				(SEND *MOVE-SEQUENCE-MENU* :DEACTIVATE)
				(SETQ B
				      (LOAD-OR-CREATE-MAIL-FILE
					PATHNAME
					:NEAR '(:MOUSE)
					:IF-EXISTS (IF ALWAYS-NEW-FLAVOR :QUERY :APPEND)
					:SELECT-FORMAT-AND-OPTIONS
					  (EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
					:FORMAT ALWAYS-NEW-FLAVOR)))))
		  COLLECT B INTO B-LIST
		  FINALLY
		    (SETQ BUFFER B-LIST))
	    (SETQ NEW-P T))
	  (WHEN (EQ BUFFER :MENU-CHOOSE) (SETQ BUFFER NIL MSG NIL))
	  (WHEN (EQ BUFFER :ABORT) (ABORT-CURRENT-COMMAND))
	  (WHEN (EQ BUFFER :NEW-COLLECTION)
	    (LET ((NAME (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR
			  *MOVE-SEQUENCE-MENU* #'TYPEIN-LINE-READLINE "New collection:")))
	      (COND ((SYMBOLP NAME))
		    ((EQUAL NAME "") (BARF))
		    ((MULTIPLE-VALUE-BIND (BUFFERS COLLECTIONS UNLOADED-FILES)
			 (GET-SEQUENCE-ALISTS)
		       (COND ((ASSOC NAME COLLECTIONS)
			      (BARF "There is already a collection named ~A." NAME))
			     ((OR (ASSOC NAME BUFFERS) (ASSOC NAME UNLOADED-FILES))
			      (BARF "There is already a mail file buffer named ~A." NAME))
			     (T NIL))))
		    (T (SETQ BUFFER (MAKE-NEW-COLLECTION NAME))))))
	  (WHEN (EQ BUFFER :OLD-TEMP)
	    (SETQ BUFFER (GET-RECYCLED-COLLECTION "Temp")))
	  (WHEN (MEMQ BUFFER '(:HARDCOPY-LAST :HARDCOPY-DEFAULT :HARDCOPY-WITH-OPTIONS))
	    (SETQ BUFFER (MAKE-HARDCOPY-COLLECTION
			   BUFFER FOR-WHOLE-FILE-P `(:WINDOW ,*MOVE-SEQUENCE-MENU*))))
	  (WHEN (MEMQ BUFFER '(:FIND-FILE :TEXT-FILE))
	    (LET ((DEFAULT (IF (AND *DEFAULT-MOVE-SEQUENCE*
				    (SEQUENCE-BUFFER-P *DEFAULT-MOVE-SEQUENCE*))
			       (SEND *DEFAULT-MOVE-SEQUENCE* :PATHNAME)
			     (DEFAULT-ZMAIL-MOVE-PATHNAME))))
	      (SETQ ALWAYS-NEW-FLAVOR (AND (EQ BUFFER :TEXT-FILE) 'TEXT-MAIL-BUFFER)
		    BUFFER (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR
			     *MOVE-SEQUENCE-MENU*
			     #'ACCEPT-DEFAULTED-PATHNAME (IF ALWAYS-NEW-FLAVOR
							     "Make text mail file"
							   "Read mail file")
			     DEFAULT :SPECIAL-VERSION NIL :DIRECTION
			     (IF ALWAYS-NEW-FLAVOR :WRITE :READ)))))
	  (WHEN (OR (STRINGP BUFFER) (TYPEP BUFFER 'FS:PATHNAME))
	    (LET ((PATHNAME BUFFER))
	      (COND ((SETQ BUFFER (GET-BUFFER-FROM-PATHNAME BUFFER NIL)))
		    (T
		     (SEND *MOVE-SEQUENCE-MENU* :DEACTIVATE)
		     (MULTIPLE-VALUE (BUFFER NEW-P)
		       (LOAD-OR-CREATE-MAIL-FILE PATHNAME
						 :NEAR '(:MOUSE)
						 :IF-EXISTS (IF ALWAYS-NEW-FLAVOR :QUERY
										  :APPEND)
						 :SELECT-FORMAT-AND-OPTIONS
						   (EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
						 :FORMAT ALWAYS-NEW-FLAVOR))))))
	  (WHEN BUFFER
	    (TV:RESTORE-MOUSE-POSITION-IF-NECESSARY)
	    (RETURN (VALUES BUFFER NEW-P)))))
    (SEND *MOVE-SEQUENCE-MENU* :DEACTIVATE)))

(DEFVAR *MOVE-MENU-HARDCOPY-OPTIONS-WHO-LINE-STRING* (MAKE-EMPTY-STRING 95.))

(DEFUN GET-MOVE-BUFFER-MENU (FOR-WHOLE-FILE-P BUFFER-ONLY-P LABEL)
  (MULTIPLE-VALUE-BIND (BUFFERS-ALIST COLLECTIONS-ALIST UNLOADED-FILES-ALIST)
      (GET-SEQUENCE-ALISTS T)
    (LET* ((SPECIAL-ACTIONS `(,@(UNLESS BUFFER-ONLY-P
				  '(("New collection" :VALUE :NEW-COLLECTION
						      :STYLE (:SWISS :ITALIC :NORMAL)
						      :DOCUMENTATION
		       "Create a new collection with a name of your choice and move into it.")
				    ("Recycled collection" :VALUE :OLD-TEMP
							   :STYLE (:SWISS :ITALIC :NORMAL)
							   :DOCUMENTATION
		 "Create a new collection with a name generated by Zmail and move into it.")))
			      ("Read//Create file" :VALUE :FIND-FILE
						   :STYLE (:SWISS :ITALIC :NORMAL)
						   :DOCUMENTATION
  "Read or create a file and then move into its buffer.  L: format from file type; R: select file format (and attributes if new).")
			      ("Just text" :VALUE :TEXT-FILE
					   :STYLE (:SWISS :ITALIC :NORMAL)
					   :DOCUMENTATION
		  "Create a text file which can be edited in Zmacs and move into its buffer.")
			      ,@(UNLESS BUFFER-ONLY-P
				  `(("Hardcopy"
				      :BUTTONS (:HARDCOPY-LAST
						 :HARDCOPY-DEFAULT :HARDCOPY-WITH-OPTIONS)
				      :STYLE (:SWISS :ITALIC :NORMAL)
				      :DOCUMENTATION
				        ,(PROGN
					   (SETF
					     (FILL-POINTER
					       *MOVE-MENU-HARDCOPY-OPTIONS-WHO-LINE-STRING*)
					     0)
					   (HARDCOPY-OPTIONS-WHO-LINE-STRING
					     *LAST-HARDCOPY-OPTIONS*
					     *DEFAULT-HARDCOPY-OPTIONS*
					     *MOVE-MENU-HARDCOPY-OPTIONS-WHO-LINE-STRING*
					     FOR-WHOLE-FILE-P)
					   *MOVE-MENU-HARDCOPY-OPTIONS-WHO-LINE-STRING*))))
			      ,@(WHEN (AND FOR-WHOLE-FILE-P *FILTER-MOVE-MAIL-FILE-ALIST*)
				  `(("By individual filters" :VALUE :INDIVIDUAL-FILTERS
				      :STYLE (:SWISS :ITALIC :NORMAL)
				      :DOCUMENTATION
  "Move each message for which a suitable filter exists into the corresponding file's buffer.")))
			      ("Abort" :VALUE :ABORT
				       :STYLE (:SWISS :ITALIC :NORMAL)
				       :DOCUMENTATION "Abort this command.")))
	   (BUFFER-FILES-MENU-ITEMS `(,@(TV:MAKE-MENU-ITEM-LIST BUFFERS-ALIST
								"Move into this buffer."
								'(NIL :BOLD NIL))
				      ,@(TV:MAKE-MENU-ITEM-LIST UNLOADED-FILES-ALIST
  "Read or create this file and then move into its buffer.  L: format from file type; R: select file format (and attributes if new).")))
	   (COLLECTIONS-MENU-ITEMS (TV:MAKE-MENU-ITEM-LIST COLLECTIONS-ALIST
							   "Move into this collection.")))
      (MULTIPLE-VALUE-BIND (MENU-ITEMS N-COLUMNS)
	  (IF BUFFER-ONLY-P
	      (TV:APPEND-ITEM-LISTS BUFFER-FILES-MENU-ITEMS SPECIAL-ACTIONS)
	    (TV:APPEND-ITEM-LISTS BUFFER-FILES-MENU-ITEMS
				  `(,@COLLECTIONS-MENU-ITEMS
				    ,@(IF ( (LENGTH COLLECTIONS-MENU-ITEMS) 0)
					  '(("" :NO-SELECT T)))
				    ,@SPECIAL-ACTIONS)))
	(SEND *MOVE-SEQUENCE-MENU* :SET-GEOMETRY N-COLUMNS)
	(UNLESS (EQUAL MENU-ITEMS (SEND *MOVE-SEQUENCE-MENU* :ITEM-LIST))
	  (SEND *MOVE-SEQUENCE-MENU* :SET-ITEM-LIST MENU-ITEMS))
	(SEND *MOVE-SEQUENCE-MENU* :SET-LABEL LABEL)
	*MOVE-SEQUENCE-MENU*))))

(DEFUN GET-MOVE-SEQUENCE-FROM-MSG-BY-FILTERING (MSG)
  (SI:ELIMINATE-DUPLICATES
    (LOOP FOR (FILTER . SEQUENCE) IN *FILTER-MOVE-MAIL-FILE-ALIST*
	  WHEN (OR (EQ FILTER T) (MSG-FITS-FILTER-P MSG FILTER))
	  COLLECT SEQUENCE) #'EQUAL))

(DEFUN DEFAULT-ZMAIL-MOVE-PATHNAME ()
  (IF *DEFAULT-MOVE-MAIL-FILE-NAME*
      (FS:MERGE-PATHNAMES *DEFAULT-MOVE-MAIL-FILE-NAME* *ZMAIL-PATHNAME-DEFAULTS*)
      (FS:MERGE-PATHNAMES USER-ID (SEND (FS:USER-HOMEDIR) ':NEW-CANONICAL-TYPE ':XMAIL))))

;;; Miscellaneous

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-RENAME-SEQUENCE (STRING)
  (WHEN *SEQUENCE*
    (FORMAT STRING "Change the ~:[file~]name of this ~:*~:[buffer~;collection~]."
	    (NOT (SEQUENCE-BUFFER-P *SEQUENCE*)))))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *SEQUENCE* COM-ZMAIL-RENAME-SEQUENCE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-RENAME-SEQUENCE
				"Change the name of this buffer or collection."
				(NO-MSG-OK)
  (LET* ((NEW-NAME-OR-PATHNAME
	   (IF (SEQUENCE-BUFFER-P *SEQUENCE*)
	       (ACCEPT-DEFAULTED-PATHNAME "New filename" (SEND *SEQUENCE* :PATHNAME)
					  :SPECIAL-VERSION NIL :DIRECTION :WRITE)
	     (TYPEIN-LINE-READLINE "New name for ~A:" (SEND *SEQUENCE* :NAME))))
	 (NEW-NAME (STRING NEW-NAME-OR-PATHNAME)))
    (UNLESS (EQUAL NEW-NAME (SEND *SEQUENCE* :NAME))
      (RENAME-SEQUENCE-INTERNAL *SEQUENCE* NEW-NAME-OR-PATHNAME)))
  DIS-NONE)

(DEFUN RENAME-SEQUENCE-INTERNAL (SEQUENCE NEW-NAME-OR-PATHNAME
				 &OPTIONAL (NEW-BUFFER-ID NIL CALLER-VALIDATED-RENAMING))
  (LET* ((NEW-NAME (STRING NEW-NAME-OR-PATHNAME))
	 (NEW-BUFFER-ID (IF CALLER-VALIDATED-RENAMING
			    NEW-BUFFER-ID
			  (VALIDATE-RENAME-SEQUENCE SEQUENCE NEW-NAME-OR-PATHNAME))))
    (COND ((SEQUENCE-BUFFER-P SEQUENCE)
1	   ;; Renaming a mail file --
0	   1;;    Update the profile to reflect the new name.
0	   (UPDATE-PROFILE-FOR-RENAMED-MAIL-FILE SEQUENCE NEW-NAME-OR-PATHNAME)
	   (CL:SETF (MSG-BUFFER-PATHNAME SEQUENCE) NEW-NAME-OR-PATHNAME
		    (MSG-BUFFER-ID SEQUENCE) NEW-BUFFER-ID)
1	   ;;    Enable saving and force the file to be saved.
0	   (SEND SEQUENCE :PUTPROP NIL :DISABLE-SAVES)
	   (MARK-SEQUENCE-MODIFIED SEQUENCE :HARD T))
	  (T
	   1;; Renaming a non-mail file.
0	   (WHEN (TYPEP SEQUENCE 'COLLECTION)
	     (SETF (COLLECTION-FULL-NAME SEQUENCE) NEW-NAME))))
    (SETF (SEQUENCE-NAME SEQUENCE) NEW-NAME)
    (WHEN (EQ SEQUENCE *SEQUENCE*)
      (SETQ *ZMAIL-SEQUENCE-NAME* NEW-NAME))))

(DEFUN VALIDATE-RENAME-SEQUENCE (SEQUENCE NEW-NAME-OR-PATHNAME)
  (LET ((NEW-NAME (STRING NEW-NAME-OR-PATHNAME)))
    (MULTIPLE-VALUE-BIND (BUFFERS COLLECTIONS IGNORE)
	(GET-SEQUENCE-ALISTS)
      (WHEN (ASSOC NEW-NAME COLLECTIONS)
	(BARF "There is already a collection named ~A." NEW-NAME))
      (WHEN (ASSOC NEW-NAME BUFFERS)
	(BARF "There is already a mail file buffer named ~A." NEW-NAME)))
    (IF (SEQUENCE-BUFFER-P SEQUENCE)
	1;; Renaming a mail file -- Check for an existing file and query if found.
0	(LET ((FILE-ID (LET ((PROBE (OPEN NEW-NAME :DIRECTION :PROBE
						   :IF-DOES-NOT-EXIST NIL)))
			 (IF PROBE (SEND PROBE :INFO) T))))
	  (COND ((EQ FILE-ID T))
		((TYPEOUT-BEEP-YES-OR-NO-P "A file named ~A already exists~% (~A).~@
					    ~%Do you want to ~
					    ~:[overwrite~;create a newer version of~] it ~
					    with this buffer? "
		   NEW-NAME (DESCRIBE-FILE-INFO FILE-ID)
		   (EQ (SEND NEW-NAME-OR-PATHNAME :VERSION) :NEWEST))
		 FILE-ID)
		(T (ABORT-CURRENT-COMMAND))))
      1;; Renaming a collection.
0      NIL)))

;;; Useful for things that decide based on attributes of a message, pick one
;;; at random.
(DEFUN FIRST-MSG-IF-ANY (&OPTIONAL (SEQUENCE *SEQUENCE*))
  (AND SEQUENCE
       (PLUSP (SEND SEQUENCE ':NMSGS))
       (AREF (SEND SEQUENCE ':ARRAY) 0)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-LIST-SEQUENCES
				"List the current message sequences."
				(NO-SEQUENCE-OK)
  (FORMAT *TYPEOUT-WINDOW*
	  "~& Name:                                    Expunge Save Number of messages~%")
  (MULTIPLE-VALUE-BIND (BUFFERS COLLECTIONS UNLOADED-FILES)
      (GET-SEQUENCE-ALISTS)
    (LIST-SEQUENCES-INTERNAL BUFFERS 'MSG-BUFFER "Buffers:")
    (LIST-SEQUENCES-INTERNAL COLLECTIONS 'COLLECTION "Collections:")
    (WHEN UNLOADED-FILES
      (FORMAT *TYPEOUT-WINDOW* "~&Mail files not yet read in:~%")
      (LOOP FOR (NIL . OTHER-MAIL-FILE) IN UNLOADED-FILES
	    DO (SEND *TYPEOUT-WINDOW* :FRESH-LINE)
	       (SCL:PRESENT OTHER-MAIL-FILE 'UNLOADED-MAIL-FILE :STREAM *TYPEOUT-WINDOW*)
	       (SEND *TYPEOUT-WINDOW* :TYO #\CR))
      (SEND *TYPEOUT-WINDOW* :TYO #\CR)))
  DIS-NONE)

(DEFUN LIST-SEQUENCES-INTERNAL (LIST TYPE PROMPT)
  (WHEN LIST
    (FORMAT *TYPEOUT-WINDOW* "~&~A~%" PROMPT)
    (LOOP FOR (NIL . SEQUENCE) IN LIST
	  DO
      (MULTIPLE-VALUE-BIND (SAVE-P EXPUNGE-P)
	  (MAIL-FILE-SAVE-P SEQUENCE :INCOMPLETE-OK T)
	(CL:FRESH-LINE *TYPEOUT-WINDOW*)
	(SCL:PRESENT SEQUENCE TYPE :STREAM *TYPEOUT-WINDOW*)
	(FORMAT *TYPEOUT-WINDOW* "~45T~C~51T~C~61T~3D~%"
		(IF EXPUNGE-P #\* #\Space)
		(IF SAVE-P #\* #\Space)
		(IF (AND (SEQUENCE-BUFFER-P SEQUENCE)
			 (EQ (MSG-BUFFER-STATUS SEQUENCE) :LOADING))
		    "(Loading)"
		    (SEQUENCE-NMSGS SEQUENCE)))))
    (CL:WRITE-CHAR #\Return *TYPEOUT-WINDOW*)))

;;; Replaced by presentation commands for FS:PATHNAME in SYS:ZMAIL;FILTER.
;(TV:ADD-TYPEOUT-ITEM-TYPE *ZMAIL-TYPEOUT-ITEM-ALIST* OTHER-MAIL-FILE "Read in"
;			  READ-IN-OTHER-MAIL-FILE T
;			  "Read in this file.")

;;; Hardcopy functions

(DEFMETHOD (HARDCOPY-DEVICE HARDCOPY-OPTIONS) ()
  (IF (EQ DEVICE :DEFAULT)
      HARDCOPY:*DEFAULT-TEXT-PRINTER*
    DEVICE))

(DEFMETHOD ((CL:SETF HARDCOPY-DEVICE) HARDCOPY-OPTIONS) (NEW-DEVICE)
  (IF (EQ NEW-DEVICE HARDCOPY:*DEFAULT-TEXT-PRINTER*)
      (SETF DEVICE :DEFAULT)
    (SETF DEVICE NEW-DEVICE)))

(DEFMETHOD (COMPLETE-HARDCOPY-OPTIONS HARDCOPY-OPTIONS) (&OPTIONAL FORCE-P)
  (MACROLET ((COMPLETE (VARIABLE OPTION)
	       `(WHEN (OR FORCE-P (NOT (VARIABLE-BOUNDP ,VARIABLE)))
		  (SETF ,VARIABLE ,OPTION))))
    (COMPLETE DEVICE :DEFAULT)
    (COMPLETE PAGE-HEADER-P *HARDCOPY-PAGE-HEADER-P*)
    (COMPLETE SUMMARY-P *HARDCOPY-SUMMARY-P*)
    (COMPLETE SEPARATE-PAGES *HARDCOPY-SEPARATE-PAGES*)
    (COMPLETE SEPARATOR-LINE *HARDCOPY-SEPARATOR-LINE*)
    (COMPLETE NUMBER-OF-COPIES *HARDCOPY-NUMBER-OF-COPIES*)
    (COMPLETE ORIENTATION *HARDCOPY-ORIENTATION*)
    (COMPLETE REFORMAT-TEMPLATE *HARDCOPY-REFORMAT-TEMPLATE*)))

(DEFMETHOD (HARDCOPY-OPTIONS-EQUAL HARDCOPY-OPTIONS) (OTHER-HARDCOPY-OPTIONS SEQUENCE-P)
  (OR (EQ SELF OTHER-HARDCOPY-OPTIONS)
      (AND (EQ (HARDCOPY-DEVICE SELF) (HARDCOPY-DEVICE OTHER-HARDCOPY-OPTIONS))
	   (EQ PAGE-HEADER-P (HARDCOPY-PAGE-HEADER-P OTHER-HARDCOPY-OPTIONS))
	   (OR (NOT SEQUENCE-P)
	       (AND (EQ SUMMARY-P (HARDCOPY-SUMMARY-P OTHER-HARDCOPY-OPTIONS))
		    (EQ SEPARATE-PAGES (HARDCOPY-SEPARATE-PAGES OTHER-HARDCOPY-OPTIONS))
		    (EQ SEPARATOR-LINE (HARDCOPY-SEPARATOR-LINE OTHER-HARDCOPY-OPTIONS))))
	   (EQ NUMBER-OF-COPIES (HARDCOPY-NUMBER-OF-COPIES OTHER-HARDCOPY-OPTIONS))
	   (EQ ORIENTATION (HARDCOPY-ORIENTATION OTHER-HARDCOPY-OPTIONS))
	   (EQ REFORMAT-TEMPLATE (HARDCOPY-REFORMAT-TEMPLATE OTHER-HARDCOPY-OPTIONS)))))

(DEFMETHOD (HARDCOPY-OPTIONS-DIFFERENCES HARDCOPY-OPTIONS) (OTHER-HARDCOPY-OPTIONS SEQUENCE-P)
  (UNLESS (AND (EQ PAGE-HEADER-P (HARDCOPY-PAGE-HEADER-P OTHER-HARDCOPY-OPTIONS))
	       (OR (NOT SEQUENCE-P)
		   (AND (EQ SUMMARY-P (HARDCOPY-SUMMARY-P OTHER-HARDCOPY-OPTIONS))
			(EQ SEPARATE-PAGES (HARDCOPY-SEPARATE-PAGES OTHER-HARDCOPY-OPTIONS))
			(EQ SEPARATOR-LINE (HARDCOPY-SEPARATOR-LINE OTHER-HARDCOPY-OPTIONS))))
	       (EQ NUMBER-OF-COPIES (HARDCOPY-NUMBER-OF-COPIES OTHER-HARDCOPY-OPTIONS))
	       (EQ ORIENTATION (HARDCOPY-ORIENTATION OTHER-HARDCOPY-OPTIONS))
	       (EQ REFORMAT-TEMPLATE (HARDCOPY-REFORMAT-TEMPLATE OTHER-HARDCOPY-OPTIONS)))
    (WITH-OUTPUT-TO-STRING (STANDARD-OUTPUT)
      (LET ((FIRST-DIFFERENCE T))
	(LABELS ((FORMAT-DIFFERENCE (FORMAT-STRING &REST FORMAT-ARGS)
		   (FORMAT T "~:[, ~]~?" FIRST-DIFFERENCE FORMAT-STRING FORMAT-ARGS)
		   (SETF FIRST-DIFFERENCE NIL)))
	  (UNLESS (EQ NUMBER-OF-COPIES (HARDCOPY-NUMBER-OF-COPIES OTHER-HARDCOPY-OPTIONS))
	    (FORMAT-DIFFERENCE "~:[1 copy~;~D copies~]"
			       ( NUMBER-OF-COPIES 1) NUMBER-OF-COPIES))
	  (UNLESS (EQ PAGE-HEADER-P (HARDCOPY-PAGE-HEADER-P OTHER-HARDCOPY-OPTIONS))
	    (FORMAT-DIFFERENCE "~:[no ~;~]headers" PAGE-HEADER-P))
	  (UNLESS (EQ ORIENTATION (HARDCOPY-ORIENTATION OTHER-HARDCOPY-OPTIONS))
	    (FORMAT-DIFFERENCE "~:[portrait~;landscape~]" (EQ ORIENTATION :LANDSCAPE)))
	  (WHEN SEQUENCE-P
	    (UNLESS (EQ SUMMARY-P (HARDCOPY-SUMMARY-P OTHER-HARDCOPY-OPTIONS))
	      (FORMAT-DIFFERENCE "~:[no summary~;~:[summary only~;summary~]~]"
				 SUMMARY-P (EQ SUMMARY-P T)))
	    (UNLESS (EQ SEPARATE-PAGES (HARDCOPY-SEPARATE-PAGES OTHER-HARDCOPY-OPTIONS))
	      (FORMAT-DIFFERENCE "~:[conserve paper~;separate pages~]" SEPARATE-PAGES))))))))

(DEFUN HARDCOPY-DEVICE-PRETTY-NAME (DEVICE)
  (IF (NULL DEVICE) "None"
    (SEND DEVICE :PRETTY-NAME)))

(DEFMETHOD (HARDCOPY-OPTIONS-WHO-LINE-STRING HARDCOPY-OPTIONS)
	   (DEFAULT-HARDCOPY-OPTIONS STRING SEQUENCE-P)
  (FORMAT STRING "Hardcopy ~:[this message~;these messages~].  " SEQUENCE-P)
  (IF (HARDCOPY-OPTIONS-EQUAL SELF DEFAULT-HARDCOPY-OPTIONS SEQUENCE-P)
      (FORMAT STRING "L,M: ~A; R: Select device and options from a menu."
	      (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE SELF)))
    (FORMAT STRING "L: ~A~@[ (~A)~]; M: ~A; R: Select device and options from a menu."
	    (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE SELF))
	    (HARDCOPY-OPTIONS-DIFFERENCES SELF DEFAULT-HARDCOPY-OPTIONS SEQUENCE-P)
	    (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE DEFAULT-HARDCOPY-OPTIONS)))))

(DEFMETHOD (HARDCOPY-DESCRIBE-OPTIONS HARDCOPY-OPTIONS) (DEFAULT-HARDCOPY-OPTIONS SEQUENCE-P)
  (FORMAT NIL "Hardcopy to ~A~@[ (~A)~]"
	  (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE SELF))
	  (HARDCOPY-OPTIONS-DIFFERENCES SELF DEFAULT-HARDCOPY-OPTIONS SEQUENCE-P)))

(DEFMETHOD (REAL-HARDCOPY-OPTIONS HARDCOPY-OPTIONS) ()
  `(:COPIES ,NUMBER-OF-COPIES
    :LANDSCAPE-P ,(EQ ORIENTATION :LANDSCAPE)))

(DEFSUBST PRINTER-ALIST-IN-ALIST (ALIST)
  (FOURTH (ASSQ '*HARDCOPY-DEVICE* ALIST)))

(DEFUN CHOOSE-HARDCOPY-OPTIONS (HARDCOPY-OPTIONS PROFILE-P SEQUENCE-P NEAR-MODE)
  (LABELS ((COMPUTE-CVV-OPTIONS (&OPTIONAL GET-DEVICE-ALIST-P)
	     (LOOP FOR OPTION-ITEM IN *ZMAIL-HARDCOPY-OPTION-ALIST*
		   FOR OPTION-SYMBOL = (FIRST OPTION-ITEM)
		   WHEN (AND
			  (OR (NOT PROFILE-P)
			      (MEMQ OPTION-SYMBOL *ZMAIL-PROFILE-HARDCOPY-OPTIONS*))
			  (OR SEQUENCE-P
			      (AND (NOT SEQUENCE-P)
				   (NULL (MEMQ OPTION-SYMBOL
					       *ZMAIL-SEQUENCE-HARDCOPY-OPTIONS*)))))
		     COLLECT OPTION-ITEM INTO CVV-OPTIONS
		   FINALLY
		     (WHEN (AND GET-DEVICE-ALIST-P (ASSQ '*HARDCOPY-DEVICE* CVV-OPTIONS))
		       (SETF (PRINTER-ALIST-IN-ALIST *ZMAIL-HARDCOPY-OPTION-ALIST*)
			     `(,@(HARDCOPY:GET-HARDCOPY-DEVICE-ALIST) ("Other" . OTHER)))
		       (SETF (PRINTER-ALIST-IN-ALIST CVV-OPTIONS)
			     (PRINTER-ALIST-IN-ALIST *ZMAIL-HARDCOPY-OPTION-ALIST*)))
		     (RETURN CVV-OPTIONS)))
	   (READ-OTHER-PRINTER (WINDOW PRINTER-ALIST)
	     (LET ((STRING (CATCH-ZWEI-COMMAND-LOOP
			     (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR
			       WINDOW #'TYPEIN-LINE-READLINE "Printer:")))
		   PRINTER)
	       (COND ((NOT (STRINGP STRING)) NIL)
		     ((AND (> (STRING-LENGTH STRING) 0)
			   (OR (SETQ PRINTER (NET:FIND-OBJECT-NAMED :PRINTER STRING NIL))
			       (SETQ PRINTER (NET:FIND-OBJECT-FROM-PROPERTY-LIST
					       :PRINTER :PRETTY-NAME STRING))))
		      (LET ((ITEM (RASSQ PRINTER PRINTER-ALIST)))
			(IF ITEM		;If already have such an item,
			    ITEM		; return it (never mind beeping)
			  (CONS (SEND PRINTER :PRETTY-NAME) PRINTER))))	;New printer
		     (T NIL))))			;Invalid printer name, or just typed <cr>
	   (CHECK-FOR-OTHER-PRINTER (WINDOW VARIABLE OLD-VALUE NEW-VALUE)
	     (LET ((PRINTER-ALIST (PRINTER-ALIST-IN-ALIST *ZMAIL-HARDCOPY-OPTION-ALIST*)))
	       (WHEN *EDITING-PROFILE*
		 (SEND *PROFILE-EDITOR* :VARIABLE-TICK))
	       (WHEN (EQ VARIABLE '*HARDCOPY-DEVICE*)
		 (WHEN (EQ NEW-VALUE 'OTHER)
		   (SETQ NEW-VALUE (READ-OTHER-PRINTER WINDOW PRINTER-ALIST))
		   (IF (NULL NEW-VALUE)
		       (PROGN (BEEP) (SETQ NEW-VALUE OLD-VALUE))
		     (LET ((NEW-ITEM NEW-VALUE)
			   (NEW-VALUE (CDR NEW-VALUE)))
		       (UNLESS (RASSQ NEW-VALUE PRINTER-ALIST)
			 (CL:SETF (PRINTER-ALIST-IN-ALIST *ZMAIL-HARDCOPY-OPTION-ALIST*)
				  (NCONC (SORTCAR (NCONC (BUTLAST PRINTER-ALIST) `(,NEW-ITEM))
						  #'STRING-LESSP)
					 (LAST PRINTER-ALIST)))
			 (SETQ PRINTER-ALIST (PRINTER-ALIST-IN-ALIST
					       *ZMAIL-HARDCOPY-OPTION-ALIST*))
			 (TV:WITH-SHEET-DEEXPOSED (WINDOW)
			   (SEND WINDOW :SETUP (COMPUTE-CVV-OPTIONS)
				 (SEND WINDOW :LABEL)
				 (SEND WINDOW :FUNCTION)
				 (SYMEVAL-IN-INSTANCE WINDOW 'TV:MARGIN-CHOICES))
			   (SEND WINDOW :ADJUST-GEOMETRY-FOR-NEW-VARIABLES
				 (SEND WINDOW :APPROPRIATE-WIDTH 10.)
				 TV:CHOOSE-VARIABLE-VALUES-MAX-LINES)
			   (SEND WINDOW :CENTER-AROUND
				 (+ (SEND WINDOW :X-OFFSET) (// (SEND WINDOW :WIDTH) 2))
				 (+ (SEND WINDOW :Y-OFFSET) (// (SEND WINDOW :HEIGHT) 2)))))
		       (TV:CHOOSE-VARIABLE-VALUES-CHOICE
			 WINDOW (ASSQ '*HARDCOPY-DEVICE* *ZMAIL-HARDCOPY-OPTION-ALIST*)
			 (RASSQ NEW-VALUE PRINTER-ALIST) 0)
		       T)))))))
    (USING-HARDCOPY-OPTIONS (HARDCOPY-OPTIONS :UPDATE-OPTIONS T)
      (LET ((CVV-OPTIONS (COMPUTE-CVV-OPTIONS T)))
	(TV:CHOOSE-VARIABLE-VALUES CVV-OPTIONS :LABEL "Hardcopy options:"
					       :NEAR-MODE NEAR-MODE
					       :MARGIN-CHOICES
					         '("Do It"
						   ("Abort" (ABORT-CURRENT-COMMAND)))
					       :FUNCTION #'CHECK-FOR-OTHER-PRINTER)))
    HARDCOPY-OPTIONS))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *LAST-HARDCOPY-OPTIONS* COM-ZMAIL-HARDCOPY-MSG)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-ZMAIL-HARDCOPY-MSG (MAKE-EMPTY-STRING 95.))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-HARDCOPY-MSG (STRING)
  (HARDCOPY-OPTIONS-WHO-LINE-STRING *LAST-HARDCOPY-OPTIONS* *DEFAULT-HARDCOPY-OPTIONS*
				    STRING NIL))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-HARDCOPY-MSG "Hardcopy the current message." ()
  (SEND (MAKE-HARDCOPY-COLLECTION *ZMAIL-COMMAND-BUTTON* NIL (RECTANGLE-NEAR-COMMAND-MENU))
	:ADD-MSG *MSG*)
  DIS-NONE)

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *LAST-HARDCOPY-OPTIONS* COM-ZMAIL-HARDCOPY-ALL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-ZMAIL-HARDCOPY-ALL (MAKE-EMPTY-STRING 95.))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-HARDCOPY-ALL (STRING)
  (HARDCOPY-OPTIONS-WHO-LINE-STRING *LAST-HARDCOPY-OPTIONS* *DEFAULT-HARDCOPY-OPTIONS*
				    STRING T))

(DEFINE-COMMAND-MAP-OVER-DOCUMENTATION-UPDATER COM-ZMAIL-HARDCOPY-ALL (FOR-DEFAULT-OR-MENU)
  (CL:ECASE FOR-DEFAULT-OR-MENU
    (:DEFAULT
     (HARDCOPY-DESCRIBE-OPTIONS *LAST-HARDCOPY-OPTIONS* *DEFAULT-HARDCOPY-OPTIONS* T))
    (:MENU
      "Hardcopy selecting device and options from a menu")))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-HARDCOPY-ALL "Hardcopy all these messages." ()
  (LET* ((HARDCOPY-SEQUENCE (MAKE-HARDCOPY-COLLECTION *ZMAIL-COMMAND-BUTTON* T
						      (RECTANGLE-NEAR-COMMAND-MENU)))
	 (PRINTING-SUMMARY-ONLY (EQ (HARDCOPY-SUMMARY-P
				      (HARDCOPY-MAIL-COLLECTION-OPTIONS HARDCOPY-SEQUENCE))
				    :JUST-SUMMARY))
	 (*TOO-MANY-MSGS-QUERY-THRESHOLD* (IF PRINTING-SUMMARY-ONLY
					      (* *TOO-MANY-MSGS-QUERY-THRESHOLD* 50.)
					      *TOO-MANY-MSGS-QUERY-THRESHOLD*)))
    (IF PRINTING-SUMMARY-ONLY
	(CHECK-FOR-TOO-MANY-MSGS "hardcopy a summary of")
	(CHECK-FOR-TOO-MANY-MSGS "hardcopy"))
    (SEND HARDCOPY-SEQUENCE :ADD-SEQUENCE *SEQUENCE*)
    DIS-NONE))

(DEFFLAVOR HARDCOPY-MAIL-COLLECTION (OPTIONS
				     (PAGE-HEADER NIL)
				     *STREAM*
				     *PRINTING-SUMMARY*
				     (*PAGE-NUMBER* 0))
	   (SI:PROPERTY-LIST-MIXIN)
  :INITABLE-INSTANCE-VARIABLES
  (:READABLE-INSTANCE-VARIABLES OPTIONS)
  (:WRITABLE-INSTANCE-VARIABLES (HARDCOPY-MAIL-COLLECTION-STREAM *STREAM*))
  (:REQUIRED-INIT-KEYWORDS :OPTIONS))

(DEFMETHOD (MAKE-INSTANCE HARDCOPY-MAIL-COLLECTION :AFTER) (&KEY OPTIONS &ALLOW-OTHER-KEYS)
  (WHEN (NULL (HARDCOPY-DEVICE OPTIONS))
    (BARF "No default text printer defined.")))

(DEFMETHOD (:PRINT-SELF HARDCOPY-MAIL-COLLECTION) (OUTPUT-STREAM &REST IGNORE)
  (SI:PRINTING-RANDOM-OBJECT (SELF OUTPUT-STREAM :TYPEP)
    (PRIN1 (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE OPTIONS)) OUTPUT-STREAM)))

(DEFMETHOD (:NAME HARDCOPY-MAIL-COLLECTION) (&OPTIONAL CAPITALIZE-P)
  (FORMAT NIL "~:[h~;H~]ardcopy device ~A"
	  CAPITALIZE-P
	  (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE OPTIONS))))
(DEFMETHOD (SEQUENCE-NAME HARDCOPY-MAIL-COLLECTION) ()
  (FORMAT NIL "hardcopy device ~A" (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE OPTIONS))))

(DEFMETHOD (:FULL-NAME HARDCOPY-MAIL-COLLECTION) (SEQUENCE-P &OPTIONAL CAPITALIZE-P)
  (FORMAT NIL "~:[h~;H~]ardcopy device ~A~@[ (~A)~]"
	  CAPITALIZE-P
	  (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE OPTIONS))
	  (HARDCOPY-OPTIONS-DIFFERENCES OPTIONS *DEFAULT-HARDCOPY-OPTIONS* SEQUENCE-P)))

(DEFSTRUCT (PAGE-HEADER :NAMED :CONC-NAME)
  BOUNDING-BOX-TOP				; Send in four and get a free decoder ring
  DATE-STRING-START
  DATE-STRING-END
  PAGE-POSITION
  HEADING-STRING
  DATE-STRING)

(DEFUN-IN-FLAVOR (CONSTRUCT-PAGE-HEADERS HARDCOPY-MAIL-COLLECTION) ()  
  (IF (HARDCOPY-PAGE-HEADER-P OPTIONS)
      (SCL:WITH-CHARACTER-STYLE ((SEND *STREAM* :HEADING-CHARACTER-STYLE) *STREAM*)
	;; ++ Make sure this spacing stuff works OK.
	(LET* ((DOUBLE-SPACE (SEND *STREAM* :STRING-LENGTH "00"))
	       (BBL (SEND *STREAM* :BOUNDING-BOX-LEFT))
	       (PAGE-POSITION (- (SEND *STREAM* :BOUNDING-BOX-RIGHT)
				 BBL (SEND *STREAM* :STRING-LENGTH "Page 0000")))
	       (HEADING-STRING (OR (SEND *STREAM* :PAGE-HEADING)
				   (SEND *STREAM* :TITLE)))
	       (ROOM-FOR-DATE (- PAGE-POSITION
				 (IF HEADING-STRING
				     (SEND *STREAM* :STRING-LENGTH HEADING-STRING) 0)
				 (* 2 DOUBLE-SPACE)))
	       (DATE-STRING (LET ((DATE (OR (SEND *STREAM* :PAGE-HEADING-DATE)
					    (SEND *STREAM* :DATA-CREATION-DATE))))
			      (WHEN DATE
				(TIME:PRINT-UNIVERSAL-TIME DATE NIL))))
	       (DATE-WIDTH (IF DATE-STRING (SEND *STREAM* :STRING-LENGTH DATE-STRING) 0))
	       (DATE-END NIL))
	  (WHEN DATE-STRING
	    (WHEN (> DATE-WIDTH ROOM-FOR-DATE)
	      (SETQ DATE-END (STRING-SEARCH-CHAR #\SP DATE-STRING))
	      (SETQ DATE-WIDTH (SEND *STREAM* :STRING-LENGTH DATE-STRING 0 DATE-END)))
	    (WHEN (> DATE-WIDTH ROOM-FOR-DATE)
	      (SETQ DATE-WIDTH 0)
	      (SETQ DATE-END 0)))
	  (SETQ PAGE-HEADER (MAKE-PAGE-HEADER
			      BOUNDING-BOX-TOP (SEND *STREAM* :ALLOCATE-MARGIN (* 5 254.)
						     :TOP :MICAS)
			      DATE-STRING-START (- PAGE-POSITION DATE-WIDTH DOUBLE-SPACE)
			      DATE-STRING-END DATE-END
			      PAGE-POSITION PAGE-POSITION
			      HEADING-STRING HEADING-STRING
			      DATE-STRING DATE-STRING))))))

(DEFMETHOD (PRINT-PAGE-HEADER HARDCOPY-MAIL-COLLECTION) ()
  (WHEN PAGE-HEADER
    (LET ((BB-TOP (SEND *STREAM* :BOUNDING-BOX-TOP)))
      (INCF *PAGE-NUMBER*)
      (MULTIPLE-VALUE-BIND (CUR-X CUR-Y)
	  (SEND *STREAM* :READ-CURSORPOS)
	(UNWIND-PROTECT
	    (PROGN
	      (SCL:WITH-CHARACTER-STYLE ((SEND *STREAM* :HEADING-CHARACTER-STYLE) *STREAM*)
		(SEND *STREAM* :SET-BOUNDING-BOX-TOP
			       (PAGE-HEADER-BOUNDING-BOX-TOP PAGE-HEADER))
		(SEND *STREAM* :HOME-CURSOR)
		(WHEN (PAGE-HEADER-HEADING-STRING PAGE-HEADER)
		  (SEND *STREAM* :STRING-OUT (PAGE-HEADER-HEADING-STRING PAGE-HEADER)))
		(WHEN (PAGE-HEADER-DATE-STRING PAGE-HEADER)
		  (SEND *STREAM* :SET-CURSORPOS
				 (PAGE-HEADER-DATE-STRING-START PAGE-HEADER) NIL)
		  (SEND *STREAM* :STRING-OUT
			(PAGE-HEADER-DATE-STRING PAGE-HEADER) 0
			(PAGE-HEADER-DATE-STRING-END PAGE-HEADER)))
		(SEND *STREAM* :SET-CURSORPOS (PAGE-HEADER-PAGE-POSITION PAGE-HEADER) NIL)
		(IF *PRINTING-SUMMARY*
		    (FORMAT *STREAM* "Page ~A"
			    (STRING-DOWNCASE
			      (WITH-OUTPUT-TO-STRING (STANDARD-OUTPUT)
				(LET ((CL:*PRINT-BASE* :ROMAN)
				      (CL:*PRINT-CASE* :DOWNCASE))
				  (PRINC *PAGE-NUMBER*)))))
		  (FORMAT *STREAM* "Page ~D" *PAGE-NUMBER*)))
	      (WHEN *PRINTING-SUMMARY*
		(SEND *STREAM* :TYO #\Return)
		(SEND *STREAM* :TYO #\Return)
		(LET* ((ORIENTATION (HARDCOPY-ORIENTATION OPTIONS))
		       (SUMMARY-WIDTH (SELECTQ ORIENTATION
					(:PORTRAIT 91.)
					(:LANDSCAPE 116.))))
		  (WHEN (SEND *STREAM* :OPERATION-HANDLED-P :SHOW-LINE)
		    (MULTIPLE-VALUE-BIND (X Y)
			(SEND *STREAM* :READ-PAGE-CURSORPOS)
		      (LET ((X1 (SEND *STREAM* :MICAS-TO-DEVICE-UNITS (- (* SUMMARY-WIDTH 254.)
									 4000.)
								      :HORIZONTAL))
			    (Y1 (- Y (SEND *STREAM* :MICAS-TO-DEVICE-UNITS (// 254. 2)
									   :VERTICAL))))
			(SEND *STREAM* :SET-PAGE-CURSORPOS X Y1)
			(SEND *STREAM* :SHOW-LINE X1 Y1)
			(SEND *STREAM* :SET-PAGE-CURSORPOS X Y)))))
		(SEND *STREAM* :LINE-OUT *SUMMARY-WINDOW-LABEL*)))
	  (SEND *STREAM* :SET-BOUNDING-BOX-TOP BB-TOP)
	  (SEND *STREAM* :SET-CURSORPOS CUR-X CUR-Y))))))

(DEFMACRO WITH-HARDCOPY-OUTPUT ((STREAM NAME &OPTIONAL DATE) &BODY BODY)
  `(WITH-OPEN-STREAM (,STREAM (LEXPR-FUNCALL #'HARDCOPY:MAKE-HARDCOPY-STREAM
					     (HARDCOPY-DEVICE OPTIONS)
					     :TITLE ,NAME
					     :DATA-CREATION-DATE
					       (OR ,DATE (TIME:GET-UNIVERSAL-TIME))
					     :NEW-PAGE-HOOK
					       #'(LAMBDA (&REST IGNORE)
						   (PRINT-PAGE-HEADER SELF))
					     (REAL-HARDCOPY-OPTIONS OPTIONS)))
     (CONDITION-BIND ((HARDCOPY:HARDCOPY-OUTSIDE-OF-BOUNDING-BOX
			#'HARDCOPY:SIMPLE-FORMATTER-EXCEPTION-INTERCEPTOR))
       (SETF (HARDCOPY-MAIL-COLLECTION-STREAM SELF) ,STREAM)
       . ,BODY)))

(DEFMETHOD (:ADD-MSG HARDCOPY-MAIL-COLLECTION) (MSG)
  (LET* ((DATE (MSG-GET-DATE MSG))
	 (MSG-BUFFER (MSG-BUFFER MSG))
	 (MSG-INDEX (LET ((RAW-INDEX (LOCATE-MSG-IN-SEQUENCE MSG MSG-BUFFER NIL)))
		      (WHEN RAW-INDEX (1+ RAW-INDEX)))))
    (WITH-HARDCOPY-OUTPUT (STREAM
			   (FORMAT NIL "Message~@[ #~D~] from ~A"
				   MSG-INDEX (SEQUENCE-NAME MSG-BUFFER))
			   DATE)
      (CONSTRUCT-PAGE-HEADERS)
      (LETF ((*PRINTING-SUMMARY* NIL)
	     (*PAGE-NUMBER* 0))
	(HARDCOPY-ONE-MSG MSG STREAM (LOCATE-MSG-IN-SEQUENCE MSG *SEQUENCE* NIL)
			  NIL (HARDCOPY-REFORMAT-TEMPLATE OPTIONS))))))

(DEFMETHOD (:ADD-SEQUENCE HARDCOPY-MAIL-COLLECTION) (SEQUENCE)
  (LET* ((NAME (SEQUENCE-NAME SEQUENCE))
	 (ARRAY (SEQUENCE-ARRAY SEQUENCE))
	 (NMSGS (SEQUENCE-NMSGS SEQUENCE))
	 (SUMMARY-P (HARDCOPY-SUMMARY-P OPTIONS))
	 (SEPARATE-PAGES (HARDCOPY-SEPARATE-PAGES OPTIONS))
	 (SEPARATOR-LINE (HARDCOPY-SEPARATOR-LINE OPTIONS))
	 (ORIENTATION (HARDCOPY-ORIENTATION OPTIONS))
	 (REFORMAT-TEMPLATE (HARDCOPY-REFORMAT-TEMPLATE OPTIONS))
	 (SUMMARY-WIDTH (SELECTQ ORIENTATION
			  (:PORTRAIT 90.)
			  (:LANDSCAPE 130.))))
    (WITH-HARDCOPY-OUTPUT (STREAM NAME)
      (CONSTRUCT-PAGE-HEADERS)
      (WHEN SUMMARY-P
	(LETF ((*PRINTING-SUMMARY* T)
	       (*PAGE-NUMBER* 0))
	  (TV:NOTING-PROGRESS ((FORMAT NIL "Hardcopying summary of ~A" NAME))
	    (DO ((I 0 (1+ I))
		 (MSG) (STATUS) (STRING))
		(( I NMSGS))
	      (SETQ MSG (AREF ARRAY I)
		    1;; Message must be parsed before the 2msg-summary-line1 is valid.
0		    STATUS (ASSURE-MSG-PARSED MSG)
		    STRING (MSG-SUMMARY-LINE MSG))
	      (FORMAT STREAM " ~3D~C" (1+ I) (STATUS-LETTER STATUS))
	      (SEND STREAM :STRING-OUT STRING 0 (MIN (STRING-LENGTH STRING) SUMMARY-WIDTH))
	      (SEND STREAM :TYO #\CR)
	      (TV:NOTE-PROGRESS (1+ I) NMSGS)))))
      (UNLESS (EQ SUMMARY-P :JUST-SUMMARY)
	(LETF ((*PRINTING-SUMMARY* NIL)
	       (*PAGE-NUMBER* 0))
	  (TV:NOTING-PROGRESS ((FORMAT NIL "Hardcopy messages in ~A" NAME))
	    (DO ((I 0 (1+ I))
		 (MSG)
		 (FIRST-P T NIL))
		(( I NMSGS))
	      (COND ((IF FIRST-P SUMMARY-P SEPARATE-PAGES)
		     (SEND STREAM :TYO #\PAGE))
		    ((AND SEPARATOR-LINE (NOT FIRST-P))
		     (FORMAT STREAM "~@?~&" SEPARATOR-LINE)))
	      (SETQ MSG (AREF ARRAY I))
	      (HARDCOPY-ONE-MSG MSG STREAM I SEQUENCE REFORMAT-TEMPLATE)
	      (TV:NOTE-PROGRESS (1+ I) NMSGS))))))))

(DEFUN HARDCOPY-ONE-MSG (MSG STREAM INDEX SEQUENCE REFORMAT-TEMPLATE)
  (SCL:WITH-CHARACTER-STYLE ((OR (MSG-DEFAULT-CHARACTER-STYLE MSG)
				 *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)
			     STREAM)
    (WHEN INDEX (FORMAT STREAM "Message #~D " (1+ INDEX)))
    (LET ((BUFFER (MSG-BUFFER MSG)))
      (UNLESS (EQ BUFFER SEQUENCE)
	(FORMAT STREAM "(from ~A)" (SEND BUFFER :NAME))))
    (LET ((KEYWORDS (MSG-GET MSG 'KEYWORDS-STRING)))
      (WHEN KEYWORDS
	(SEND STREAM :TYO #\SP)
	(SEND STREAM :STRING-OUT KEYWORDS)))
    (SEND STREAM :TYO #\CR)
    (MULTIPLE-VALUE-BIND (START-BP-OR-INTERVAL END-BP-OR-NIL)
	(IF REFORMAT-TEMPLATE
	    (COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG REFORMAT-TEMPLATE)
	  (MSG-ORIGINAL-HEADERS-INTERVAL MSG))
      (STREAM-OUT-INTERVAL STREAM START-BP-OR-INTERVAL END-BP-OR-NIL T))
    (SEND STREAM :TYO #\CR)
    (MULTIPLE-VALUE-BIND (START-BP END-BP)
	(MSG-BODY-INTERVAL MSG)
      (STREAM-OUT-INTERVAL STREAM START-BP END-BP T))))

1;; Construct a psuedo-collection for a hardcopy operation --
;;    Allows hardcopy to be a target of the Move class of commands.
0(DEFUN MAKE-HARDCOPY-COLLECTION (COMMAND-MODE SEQUENCE-P NEAR-MODE)
  (LET ((HARDCOPY-OPTIONS
	  (SELECTQ COMMAND-MODE
	    (:KBD (SELECT-HARDCOPY-OPTIONS-FROM-KEYBOARD SEQUENCE-P))
	    ((:LEFT :HARDCOPY-LAST) *LAST-HARDCOPY-OPTIONS*)
	    ((:MIDDLE :HARDCOPY-DEFAULT) *DEFAULT-HARDCOPY-OPTIONS*)
	    ((:RIGHT :HARDCOPY-WITH-OPTIONS)
	     (CHOOSE-HARDCOPY-OPTIONS *LAST-HARDCOPY-OPTIONS* NIL SEQUENCE-P NEAR-MODE)))))
    (UNLESS (EQ HARDCOPY-OPTIONS *LAST-HARDCOPY-OPTIONS*)
      (USING-HARDCOPY-OPTIONS (HARDCOPY-OPTIONS)
	(COMPLETE-HARDCOPY-OPTIONS *LAST-HARDCOPY-OPTIONS* T)))
    (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*LAST-HARDCOPY-OPTIONS*)
    (MAKE-INSTANCE 'HARDCOPY-MAIL-COLLECTION :OPTIONS HARDCOPY-OPTIONS)))

1;; Determine which hardcopy options to use when invoked from the keyboard --
;;    We want to use the same options that were for our last hardcopy operation.  However,
;;    if these options differ in any way from the default settings, we'll ask the user
;;    for permission to give him a chance to change his mind.
0(DEFUN SELECT-HARDCOPY-OPTIONS-FROM-KEYBOARD (SEQUENCE-P)
  (LABELS ((ASK-USER (QUERY-STRING HELP-STRING &REST QUERY-AND-HELP-ARGS)
	     (LABELS ((EXPLAIN-CHOICES (STREAM)
			(DECLARE (SYS:DOWNWARD-FUNCTION))
			(IGNORE STREAM)
			(CL:APPLY
			  #'FORMAT *TYPEOUT-WINDOW*
				   "~2&~~@?~~2%" HELP-STRING QUERY-AND-HELP-ARGS)))
	       (SELECTQ (CL:APPLY
			  #'FQUERY `(:SELECT T
				     :BEEP T
				     :TYPE :READLINE
				     :STREAM ,*TYPEOUT-WINDOW*
				     :CHOICES ((:LAST "Yes")
					       (:ABORT "No")
					       (:DEFAULT "Default"))
				     :HELP-FUNCTION ,#'EXPLAIN-CHOICES)
				   QUERY-STRING QUERY-AND-HELP-ARGS)
		 (:LAST *LAST-HARDCOPY-OPTIONS*)
		 (:DEFAULT *DEFAULT-HARDCOPY-OPTIONS*)
		 (:ABORT (ABORT-CURRENT-COMMAND))))))
    (COND ((HARDCOPY-OPTIONS-EQUAL *LAST-HARDCOPY-OPTIONS* *DEFAULT-HARDCOPY-OPTIONS*
				   SEQUENCE-P)
	   1;; Last options used are also the default options -- No problem
0	   *LAST-HARDCOPY-OPTIONS*)
	  ((NEQ (HARDCOPY-DEVICE *LAST-HARDCOPY-OPTIONS*)
		(HARDCOPY-DEVICE *DEFAULT-HARDCOPY-OPTIONS*))
	   1;; Non-default device possibly also with non-default options ...
0	   (ASK-USER "Do you really want to hardcopy ~:[this message~;these messages~] to ~A~
		      ~@[ (~A)~]~%rather than ~A which is your default hardcopy device?  "
		     "Type /"Yes/" to hardcopy ~:[this message~;these messages~] to ~A.~2:*~@
		      Type /"No/" to abort this command.~@
		      Type /"Default/" to hardcopy ~:[this message~;these messages~] ~
		        to ~2*~A."
		     SEQUENCE-P
		     (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE *LAST-HARDCOPY-OPTIONS*))
		     (HARDCOPY-OPTIONS-DIFFERENCES *LAST-HARDCOPY-OPTIONS*
						   *DEFAULT-HARDCOPY-OPTIONS*
						   SEQUENCE-P)
		     (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE *DEFAULT-HARDCOPY-OPTIONS*)
						  )))
	  (T
	   1;; Non-default options but the default device ...
0	   (ASK-USER "Do you really want to hardcopy ~:[this message~;these messages~] to ~A ~
		      using~%the options /"~A/" which are not your default settings?  "
		     "Type /"Yes/" to hardcopy ~:[this message~;these messages~] ~*~
		        using the options /"~A/".~3:*~@
		      Type /"No/" to abort this command.~@
		      Type /"Default/" to hardcopy ~:[this message~;these messages~] ~*~
		        using your default options."
		     SEQUENCE-P
		     (HARDCOPY-DEVICE-PRETTY-NAME (HARDCOPY-DEVICE *LAST-HARDCOPY-OPTIONS*))
		     (HARDCOPY-OPTIONS-DIFFERENCES *LAST-HARDCOPY-OPTIONS*
						   *DEFAULT-HARDCOPY-OPTIONS*
						   SEQUENCE-P))))))
