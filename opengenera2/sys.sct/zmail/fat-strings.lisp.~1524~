D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; -*-0 1Syntax:0 Common-lisp1; Base:0 101; Mode:0 LISP1; Package:0 Zwei1; Lowercase:0 T1 -*-

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;; Zmail's extended character handling.
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

1;;; Whenever we are asked for a new input buffer at the end of the line,
;;; we give out this one.
0(defconst *return-buffer* (make-array 1 :type 'art-8b
				      :initial-value (char-int #\Return)))


1;;; The flavor signalled when a Zmail message attempts to redefine a character type.
0(si:define-escape-decoding-error zmail-msg-invalid-type-redefinition
				 ()
	(:type-index-error t)
    ("Attempt to redefine the character type ~D." si:type-index)
  (:define-type-as-undefined-style
    "Use the style ~S reserved for undefined types." (si:unparse-character-style
							si:*undefined-character-style*))
  (:use-type-zero
    (multiple-value-bind (type-zero-bits type-zero-character-set
			  type-zero-character-set-offset type-zero-style)
	(send si:stream :get-character-type 0)
      (format si:report-stream "Use type 0 (:BITS ~D :CHARSET (~A ~D) :STYLE ~S)."
	      type-zero-bits (send type-zero-character-set :name)
	      type-zero-character-set-offset (si:unparse-character-style type-zero-style)))))

1;;; The flavor signalled when a Zmail message attempts to shutoff epsilon decoding.
0(si:define-escape-decoding-error zmail-msg-invalid-reset-loading-fat
				 ()
	()
    ("Attempt to disable epsilon decoding.")
  (:insert-escape-sequence
    "Insert the escape sequence into the stream and resume processing."))

(defvar-resettable *zmail-msg-being-epsilon-decoded* nil)

(defvar-resettable *zmail-allow-next-msg-redefinition* nil)


1;;; 2line-escape-loading-stream1  -- Font convert a single line, non-destructively.
;;; Supports the following external messages
;;;  2:convert-line1 0line new-line
1;;;    Convert the line.  2line0 is the line to be converted, and 2new-line
1;;;    is a fat line of the same length.
0(defflavor line-escape-loading-stream
	(si:current-char-type
	 (current-line)
	 (line-index 0)
	 (last-line-index 0)
	 (final-line-index 0)
	 (indirect-array (make-array 0 :type 'art-8b :displaced-to ""
				       :displaced-index-offset 512.)))
	(si:escape-loading-stream-mixin
	 si:input-stream
	 si:basic-loading-stream)
  (:readable-instance-variables si:current-char-type))

(defmethod (:init line-escape-loading-stream :after) 2(ignore)
0  (setq si:input-buffer-p t))

(defmethod (:print-self line-escape-loading-stream) (str ignore ignore)
  (si:printing-random-object (self str :typep)))

(defmethod (si:read-pointer-handled-p line-escape-loading-stream) ()
  (values nil t))

(defmethod (:reset-state line-escape-loading-stream :after) (&optional (reset-mappings t))
  (ignore reset-mappings)
  (setq current-line nil
	line-index 0
	last-line-index 0))

(defwhopper (:reset-internal-state line-escape-loading-stream) ()
  (unless *zmail-msg-being-epsilon-decoded*
    (continue-whopper)))

1;;; Zmail never disables epsilon encoding when creating messages; therefore, we should
;;; never encounter the sequence to disable encoding and, if we do, it's an error.
0(defwhopper (:reset-loading-fat line-escape-loading-stream) ()
  (if *zmail-msg-being-epsilon-decoded*
      (signal-proceed-case (() 'zmail-msg-invalid-reset-loading-fat :stream self)
	(:insert-escape-sequence
	  (send self :unread-byte (char-subindex si:fat-unpassword-character))
	  si:escape-quote))
    (continue-whopper)))

(defwhopper (:new-character-type line-escape-loading-stream) (type-index &rest other-args)
  (if (and *zmail-msg-being-epsilon-decoded* (not *zmail-allow-next-msg-redefinition*))
      (flet ((define-if-undefined (bits character-set character-set-offset style)
	       (unless (send self :get-character-type type-index)
		 (let ((*zmail-msg-being-epsilon-decoded* nil))
		   (send self :new-character-type type-index bits
						  `(,character-set ,character-set-offset)
						  style "")))))
	(signal-proceed-case (() 'zmail-msg-invalid-type-redefinition :stream self
								      :type-index type-index)
	  (:use-type-zero			1; use type 0
0	    (multiple-value-bind (type-zero-bits type-zero-character-set
				  type-zero-character-set-offset type-zero-style)
		(send self :get-character-type 0)
	      (define-if-undefined type-zero-bits type-zero-character-set
				   type-zero-character-set-offset type-zero-style)))
	  (:define-type-as-undefined-style	1; use the undefined style
0	    (define-if-undefined 0 nil 0 si:*undefined-character-style*))))
    (setq *zmail-allow-next-msg-redefinition* nil)
    (lexpr-continue-whopper type-index other-args)))

(defmethod (:convert-line line-escape-loading-stream) (line new-line &optional (start 0) end)
  (setq current-line line
	line-index start
	last-line-index start
	final-line-index (or end (string-length line))
	si:input-buffer nil			1;Discard any old input buffer hanging around.
0	si:unread-char-tank nil
	si:unread-byte-tank nil)
  (unless (zerop start)
    (copy-array-portion line 0 start new-line 0 start))
  (multiple-value-bind (nil nil nil diagram)
      (let ((*zmail-msg-being-epsilon-decoded* t))
	(send self :string-line-in "End of file while font-converting line."
	      new-line start end))
    (when (and diagram si:return-diagrams-as-lines)
      (setf (line-diagram new-line) diagram)
      (return-from :convert-line new-line)))
  (when end
    (let ((length (string-length line)))
      (unless ( end length)
	(let* ((new-length (string-length new-line))
	       (new-end (+ new-length (- length end))))
	  (copy-array-portion line end length
			      new-line new-length new-end)
	  (setf (fill-pointer new-line) new-end)))))
  new-line)

(defmethod (:read-input-buffer-1 line-escape-loading-stream) (&optional eof no-hang-p)
  (ignore no-hang-p)
  (if (not current-line)
      (if (not eof)
	  (values nil t)
	(error 'sys:end-of-file :stream self :format-string eof))
    (if (neq current-line t)
	(let ((length (- final-line-index line-index)))
	  (unless (= (sys:array-type-field current-line) art-string)
	    (ferror "While converting to ART-FAT-STRING, ~
		     we reached a line which was already converted."))
	  (si:change-indirect-array indirect-array 'art-8b length current-line line-index)
	  (setq last-line-index line-index)
	  (values indirect-array 0 length))
      (setq current-line nil)
      (values *return-buffer* 0 1))))

(defmethod (:advance-input-buffer-1 line-escape-loading-stream) (index)
  (let ((new-line-index (+ last-line-index index)))
    1;; Only update our buffer's state if our caller has acknowledged more data than previously
0    1;; or our caller is acknowledging the last piece of the line for the first time.
0    (when (or ( new-line-index line-index)
	      (and current-line (neq current-line t)))
      (setq line-index new-line-index)
      (when ( line-index final-line-index)
	(if (eq current-line t)
	    (setq current-line nil)
	  (setq current-line t))))))

(compile-flavor-methods line-escape-loading-stream)

(defresource font-converter ()
  :constructor (make-instance 'line-escape-loading-stream)
  :initializer (send object :reset-state))

(defun font-convert-line (initial-specs line &optional leader-length (start 0) end)
  (using-resource (converter font-converter)
    (loop for spec in initial-specs
	  do (lexpr-send converter :new-character-type spec))
    (if (or (not (zerop (line-escape-loading-stream-current-char-type converter)))
	    (string-search-exact-char #\ line))
	(let ((new-line (make-array (string-length line)
				    :fill-pointer 0
				    :type 'art-fat-string
				    :leader-length leader-length)))
	  (send converter :convert-line line new-line start end)
	  (when leader-length
	    (loop for i from 1 below leader-length
		  do (setf (array-leader new-line i) (array-leader line i))))
	  new-line)
      line)))

(defun font-convert-lines-interval (initial-specs from-bp &optional to-bp in-order-p)
  (get-interval from-bp to-bp in-order-p)
  (using-resource (converter font-converter)
    (loop for (index . def) in initial-specs
	  do (lexpr-send converter :new-character-type index def))
    (send converter :set-return-diagrams-as-lines t)
    (loop with first-line = (bp-line from-bp)
	  with last-line = (bp-line to-bp)
	  for line = first-line then (line-next line)
	  for start = (bp-index from-bp) then 0
	  for end = (when (eq line last-line) (bp-index to-bp))
	  while line
	  when (or (not (zerop (line-escape-loading-stream-current-char-type converter)))
		   (string-search-exact-char #\ line start end))
	    do (loop with new-line = (create-line 'art-fat-string
						  (string-length line)
						  (line-node line))
		     for i below line-leader-size
		     do (setf (array-leader new-line i) (array-leader line i))
		     finally
		       (send converter :convert-line line new-line start end)
		       1;; This isn't exactly right.  Need to do this update for
0		       1;; every escape (i.e. 2:process-escape1 time).
0		       (loop with new-length = (string-length new-line)
			     for bp in (line-bp-list line)
			     when (> (bp-index bp) new-length)
			       do (setf (bp-index bp) new-length))
		       (structure-forward line new-line))
	  until (eq line last-line))))

2;;; Saving into character files

1;;; We save messages into character files in a special way.  First, we
;;; use 2:element-type 'cl:string-char1, but encapsulate it as if we were
;;; using 2:element-type 'cl:character1.  However, we don't output the
;;; character type definitions in-line; those are stored in the header of
;;; each message.

0(defflavor zmail-msg-saving-mixin
	(msg)
	()
  (:required-flavors si:epsilon-encoding-output-stream)
  (:initable-instance-variables msg)
  (:settable-instance-variables msg))

(defmethod (:reset-state zmail-msg-saving-mixin :after) (&optional (reset-mappings t))
  (ignore reset-mappings)
  (setq msg nil))

1;;; NOTE: This code depends on the fact that the character type table starts out empty,
;;;  because eds-define-character-type only returns non-nil when the type is not already
;;;  defined.

0(defmethod (:compute-interval-types zmail-msg-saving-mixin)
	   (default-character-style first-bp &optional last-bp in-order-p
				    &aux (check-for-diagrams (not (stringp first-bp))))
  (declare (values new-type-specs diagrams-present))
  (if (stringp first-bp)
      (psetq first-bp (create-bp first-bp 0)
	     last-bp (create-bp first-bp (string-length first-bp)))
    (get-interval first-bp last-bp in-order-p))
  (loop with start-line = (bp-line first-bp)
	with stop-line = (bp-line last-bp)
	with thin-seen
	with new-type-specs = nil
	with diagrams-present = nil
	for line = start-line then (line-next line)
	for start = (bp-index first-bp) then 0
	for end = (when (eq line stop-line) (bp-index last-bp))
	when (and check-for-diagrams (line-diagram line))
	  do (setq diagrams-present t)
	when (< start (or end (string-length line)))
	  do (cond ((string-fat-p line)
		    (send self :set-up-transition-table line start end)
		    (loop for i from -1 below (fill-pointer si:transition-table)
			  for idx = 0 then (aref si:transition-table i)
			  for ch = (aref line idx)
			  as new-spec =
			     (si:eds-predefine-character-type self ch default-character-style)
			  when new-spec do (push new-spec new-type-specs)))
		   ((not thin-seen)
		    (let ((new-spec
			    (si:eds-predefine-character-type self
							     #\X default-character-style)))
		      (when new-spec (push new-spec new-type-specs)))
		    (setq thin-seen t)))
	until (eq line stop-line)
	finally
	  (return (values new-type-specs diagrams-present))))

1;;; We can't allow the -password to be quoted when dumping a thin message or draft --
;;;    If we allowed the password to be quoted, it won't be unquoted when the containing
;;;    mail file or inbox is read because the message has no character type mappings.  As
;;;    a result, the message will now have two passwords which, when the mail file is saved,
;;;    would be quoted causing it to have four passwords the next time, etc.
0(defwhopper (:start-password-stream zmail-msg-saving-mixin) ()
  (if si:dumping-fat
      (continue-whopper)
    (setq si:password-stream (make-instance 'zmail-password-stream-writearound
					    :stream self
					    :continuation #'(lambda ()
							      (setq si:password-stream nil)
							      (letf ((si:transparent-tyo t))
								(send self :tyo #\)))))))

1;;; Define a new character type mapping while saving or transmitting a message --
;;;
;;;    Zmail predefines mappings for the raw style of characters.  Epsilon encoding
;;;    streams, however, use the merged style to find the appropriate mapping to
;;;    encode in the output stream.  As Zmail never sets the stream's default character
;;;    style and also never uses 2scl:with-character-style1 (or any of its friends), the
;;;    raw style and the merged style are always equivalent and we have no problems.
;;;
;;;    Well, the styles are almost always equivalent --
;;;       If the raw style's size is 2:same1, the merged style's size will be 2nil1.
;;;       When we then try to encode the merged style, we find that it has no mapping
;;;       defined in the stream and, therefore, we try to define one.  Thus, we must
;;;       specially check for this situation and supply the raw style's mapping.
;;;
;;;    Any other attempt to define a character type mapping implies a bug --
;;;       If we're saving a message, a missing mapping is usually caused by a missing
;;;       call to 2update-msg-character-type-mappings1.  If we're transmitting a message,
;;;       a missing mapping is usually caused by a lack of an appropriate clause
;;;       (e.g., 2:character-types-from-draft1) in the transmission template.  In either
;;;       case, the missing mapping indicates that the message's 0Character-Type-Mappings
1;;;       field is incorrect.
;;;
0(defmethod (si:eds-define-character-type zmail-msg-saving-mixin)
	   (character bits-and-set style)
  (let* ((raw-style (si:char-style character))
	 (raw-char-type-spec (si:lookup-char-type-index-2 raw-style bits-and-set)))
    (cond ((and (si:character-style-relative-p raw-style) raw-char-type-spec)
	   (let ((index (si:char-type-spec-type raw-char-type-spec)))
	     (letf ((si:transparent-tyo t))
	       (send self :tyo si:escape-quote)
	       (if (< index 9)
		   (send self :tyo (digit-char index))
		 (send self :tyo #\()
		 (scl:with-standard-io-environment (prin1 index self))
		 (send self :tyo #\)))
	       index)))
	  (msg
	   (let ((msg-number (when (msg-displayed-index msg) (1+ (msg-displayed-index msg))))
		 (msg-character-type-mappings
		   (cl:getf (msg-status msg) :character-type-mappings)))
	     (error 'bad-msg-character-type-mappings
		    "Character-Type-Mappings field of message~@[ ~D~] does not specify ~
		       all the type mappings actually in the message:~@
		     ~4TCharacter-Type-Mappings: ~S~@
		     ~4TMissing type mapping for \"~C\": (~D ~D ~S)~%"
		    msg-number msg-character-type-mappings character
		    (%logldb si:%%char-type-bits bits-and-set)
		    (%logldb si:%%char-type-char-set bits-and-set)
		    (si:unparse-character-style style))))
	  (t
	   (ferror "Attempt to define the character type mapping (~D ~D1 0~S) ~
		    for1 0\"~C\" during message transmission."
		   (%logldb si:%%char-type-bits bits-and-set)
		   (%logldb si:%%char-type-char-set bits-and-set)
		   (si:unparse-character-style style) character)))))

(defmethod (:make-idle zmail-msg-saving-mixin) ()
  (send self :set-stream nil :reset-mappings nil)	1;Don't loose mappings, please.
0  (when si:transition-table
    (deallocate-resource 'si:string-transition-table si:transition-table)
    (setq si:transition-table nil)))

1;;; Replacement for the 2password-checking-stream1 used when dumping thin messages or drafts --
;;;    This stream simply calls the supplied continuation which will turn off use of this
;;;    stream.  It then sends any characters 2:tyo1ed to it along to the real stream as we
;;;    are often called by a 2:string-out1 method.
0(defflavor zmail-password-stream-writearound (stream (continuation nil))
	   (si:output-stream si:character-stream)
  :initable-instance-variables)

(defmethod (:tyo zmail-password-stream-writearound) (char)
  (if (null continuation)
      (send stream :tyo char)
    (funcall continuation)
    (setq continuation nil)))

(defmethod (:finish zmail-password-stream-writearound) ()
  (when continuation
    (funcall continuation)
    (setq continuation nil)))

(compile-flavor-methods zmail-password-stream-writearound)


(defflavor zmail-msg-saving-stream ()
	   (zmail-msg-saving-mixin si:epsilon-encoding-output-stream))

(compile-flavor-methods zmail-msg-saving-stream)

1;;; Compute the character type mappings used in a given interval.
0(defun compute-interval-character-type-mappings (start-bp &optional end-bp in-order-p
								    saving-stream
								    default-character-style)
  (flet ((do-it (saving-stream)
	   (send saving-stream :compute-interval-types default-character-style
						       start-bp end-bp in-order-p)))
    (if (not saving-stream)
	(using-resource (saving-stream 
			  si:epsilon-encoding-output-stream nil
							    :flavor 'zmail-msg-saving-stream)
	  (do-it saving-stream))
      (do-it saving-stream))))

2;;; Loading from files and other places.

0(define-zmail-global *debugging-zmail-epsilon-decoding* nil)

1;;; Establish the proper condition handlers in order to run code which epsilon decodes text --
;;;
;;;    2decoding-body1 is the code which decodes the text.
;;;
;;;    2note-mappings-changed-forms1 is run once if the decoding process notes that the
;;;       character type mappings used to decode the text have changed on the fly.
;;;       The mappings can change if an invalid or undefined character type mapping in
;;;       the text is replaced by a reference to the "undefined style".
;;;
;;;    2decoding-error-forms1 is run if an decoding error which can not be handled by the
;;;      system's simple decoding handler is detected.  2error-var1 will be bound to the
;;;      actual error object in this case.
;;;
0(defmacro with-zmail-epsilon-decoding-handlers ((&body note-mappings-changed-forms)
						(error-var &body decoding-error-forms)
						&body decoding-body)
  (declare (indentation 0 3 2 1))
  `(with-zmail-epsilon-decoding-handlers-internal #'(lambda ()
						      (declare (sys:downward-function))
						      ,@decoding-body)
						  #'(lambda ()
						      (declare (sys:downward-function))
						      ,@note-mappings-changed-forms)
						  #'(lambda (,error-var)
						      (declare (sys:downward-function))
						      ,@decoding-error-forms)))

1;;; Support function for the above macro.
0(defun with-zmail-epsilon-decoding-handlers-internal (decoding-body
						      note-mappings-changed-forms
						      decoding-error-forms)
  (declare (sys:downward-funarg *))
  (let ((note-mapping-changed-forms-called nil))
    (labels ((decoding-handler (condition)
	       (let ((proceed-option
		       (si:escape-loading-stream-decoding-error-simple-handler condition)))
		 (when (eq proceed-option :define-type-as-undefined-style)
		   (unless note-mapping-changed-forms-called
		     (funcall note-mappings-changed-forms))
		   (setq note-mapping-changed-forms-called t
			 *zmail-allow-next-msg-redefinition* t))
		 proceed-option)))
      (condition-case-if (not *debugging-zmail-epsilon-decoding*)
			 (.error.)
	   (condition-bind-if (not *debugging-zmail-epsilon-decoding*)
			      ((si:escape-loading-stream-decoding-error #'decoding-handler)
			       (si:character-style-error
				 #'(lambda (condition)
				     (sys:proceed condition :use-undefined-style))))
	     (funcall decoding-body))
	 (si:escape-loading-stream-decoding-error
	   (funcall decoding-error-forms .error.))))))

1;;; Epsilon decode a message --
;;;    (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")EXPLAIN PLEASE!
0(defun epsilon-decode-msg (msg-headers
			   msg-headers-start-bp msg-headers-end-bp msg-headers-in-order-p
			   msg-body-start-bp msg-body-end-bp msg-body-in-order-p)
  (declare (values character-type-mappings-changed
		   recomputed-character-type-mappings recomputed-fonts recomputed-japanese
		   fatal-decoding-error))
  (multiple-value-bind (character-type-mappings recompute-character-type-mappings)
      (get-character-type-mappings-from-header msg-headers)
    (let ((raw-character-type-mappings (cl:getf msg-headers :character-type-mappings))
	  (fatal-decoding-error))
      (when character-type-mappings
	1;; Convert epsilon encodings in the message into the appropriate fat characters
0	(with-zmail-epsilon-decoding-handlers
	    ((setq recompute-character-type-mappings t))
	    (.error.
	      (setq fatal-decoding-error .error.))
	  1;; Decode the body.
0	  (get-interval msg-body-start-bp msg-body-end-bp msg-body-in-order-p)
	  (font-convert-lines-interval character-type-mappings
				       msg-body-start-bp msg-body-end-bp t)
	  1;; If supplied, decode the appropriate header fields in the header interval.
0	  (when msg-headers-start-bp
	    (get-interval msg-headers-start-bp msg-headers-end-bp msg-headers-in-order-p)
	    (epsilon-decode-msg-headers-interval character-type-mappings
						 msg-headers-start-bp msg-headers-end-bp t))
	  1;; Decode the fields in the actual parse.
0	  (loop for header-type in *font-converted-header-lines*
		for line = (cl:getf msg-headers header-type)
		do (setq line (cl:etypecase line
				  (null)
				  (string
				    (font-convert-line character-type-mappings line))
				  (list
				    (loop for l in line
					  collect (font-convert-line character-type-mappings l)
					    ))))
		     (cl:setf (cl:getf msg-headers header-type) line))))
      (let ((default-character-style (msg-default-character-style-internal msg-headers)))
	1;; Recompute the actual character type mappings if something changed or Japanese.
0	(when recompute-character-type-mappings
	  (using-resource (mappings-computer-stream
			    si:epsilon-encoding-output-stream nil
							      :flavor 'zmail-msg-saving-stream)
	    (macrolet ((compute (start-bp end-bp)
			 `(compute-interval-character-type-mappings ,start-bp ,end-bp t
								    mappings-computer-stream
								    default-character-style)))
	      (setq character-type-mappings
		    (if msg-headers-start-bp
			(nconc (compute msg-headers-start-bp msg-headers-end-bp)
			       (compute msg-body-start-bp msg-body-end-bp))
		      (compute msg-body-start-bp msg-body-end-bp))))))
	(when (and character-type-mappings
		   (not (equal character-type-mappings raw-character-type-mappings)))
	  1;; Now that we've expanded the epsilon encodings in the message, we can
0	  1;; "canonicalize" the type mappings by removing any references to the default
0	  1;; type0 1(no bits, standard character set, and a null character style) and
0	  1;; renumbering0 1the remaining type mappings from 1.
0	  (setq character-type-mappings
		(loop for style in (cl:remove-if
				     #'(lambda (style)
					 (equal (cdr style) (cdr si:*default-type-0-spec*)))
				     character-type-mappings)
		      for char-type from 1
		      do (setf (car style) char-type)
		      collect style)))
	(values
	  (not (equal character-type-mappings raw-character-type-mappings))
	  character-type-mappings
	  (fonts-from-character-type-mappings default-character-style character-type-mappings)
	  (japanese-from-character-type-mappings character-type-mappings)
	  fatal-decoding-error)))))

1;;; Separated from the above code so that it can be called by the 2parse-msg-text1 whopper.
0(defun epsilon-decode-msg-headers-interval (character-type-mappings
					    headers-start-bp headers-end-bp headers-in-order-p)
  (get-interval headers-start-bp headers-end-bp headers-in-order-p)
  (loop with headers-end-line = (bp-line headers-end-bp)
	with test-end-before = (zerop (bp-index headers-end-bp))
	for line = (bp-line headers-start-bp) then (line-next line)
	until (and test-end-before (eq line headers-end-line))
	as (header) = (cl:getf (line-contents-plist line) 'parsed-headers)
	when (memq header *font-converted-header-lines*)
	  do (let* ((start (if (continuation-line-p line)
			       0
			     1;; Do not convert the field name, however
0			     (1+ (or (string-search #\: line)
				     (1- (string-length line))))))
		    (new-line (font-convert-line character-type-mappings
						 line line-leader-size start)))
	       (unless (eq line new-line)
		 (structure-forward line new-line)))
	until (eq line headers-end-line)))

1;;; Separated from the above so it can be called from elsewhere (message saving, mostly).
0(defun get-character-type-mappings-from-header (msg-headers)
  (declare (values character-type-mappings japanese-mappings-added))
  (let* ((raw-character-type-mappings (cl:getf msg-headers :character-type-mappings))
	 (character-styles (cl:getf msg-headers :character-styles))
	 (character-type-mappings
	   (if (and raw-character-type-mappings
		    (neq (first raw-character-type-mappings) 'losing-headers))
	       raw-character-type-mappings
	     1;; Compatibility with early Release 7 worlds --
0	     1;;    Use the Character-Styles field if present and correct.
0	     (unless (eq (first character-styles) 'losing-headers)
	       character-styles)))
	 (japanese-mappings-added))
    (when (not character-type-mappings)
      1;; No valid Character-Type-Mappings in the message header --
0      (let ((fonts (cl:getf msg-headers :fonts)))
	(when fonts
	  1;; Try constructing a set from the Fonts --
0	  1;;    However, if we don't recognize all the fonts, we'll ignore them completely.
0	  (setq character-type-mappings (compute-character-type-mappings-from-fonts fonts))))
      (let ((japanese (cl:getf msg-headers :japanese)))
	(when japanese
	  1;; Include the standard character type mappings for the old style Japanese field --
0	  1;;    We're about to add a bunch of mappings without knowing0 1if they're used;
0	  1;;    therefore, we'll force recomputation of the mappings after decoding the
0	  1;;    message to insure that only the mappings we actually used are added to the
0	  1;;    0Character-Type-Mappings1 field.0 1 We don't have to worry about
0	  1;;    backtranslation of the0 1fonts failing in0 1this0 1case as the appropriate
0	  1;;    backtranslations are part of the system.
0	  (labels ((set-type-from-font (type-idx font)
		     (multiple-value-bind (style char-set offset)
			 (si:backtranslate-font font si:*b&w-screen*)
		       (setq style (si:canonicalize-character-style style))
		       (push `(,type-idx 0 (,(send char-set :name) ,offset)
			       ,(si:unparse-character-style style)
			       ,(string font))
			     character-type-mappings)))
		   (set-types-from-font-list (font-list)
		     (loop for i from 0
			   for font in font-list
			   unless (assoc i character-type-mappings)
			     do (set-type-from-font i font)))
		   (set-types-from-japanese (size font)
		     (loop for i from 0
			   for j from 10.
			   repeat 54.
			   do
		       (push `(,j 0 ("Japanese" ,(* i 1/2)) (nil nil ,size) ,font)
			     character-type-mappings))))
	    (selectq japanese
	      (12
	       (set-types-from-japanese :normal "JIS-12")
	       (set-types-from-font-list 'fonts:(cptfont cptfontb cptfont cptfonti cptfontb)))
	      (16
	       (set-types-from-japanese :large "JIS-16")
	       (set-types-from-font-list 'fonts:(cptfont cptfontb tr12 tr12b tr12i)))
	      (48
	       (set-types-from-japanese :huge "JIS-48")
	       (set-types-from-font-list 'fonts:(dutch20 dutch20b tr12 tr12b tr12i)))
	      (otherwise			1;Also known as 224
0	       (set-types-from-japanese :very-large "JIS-24")
	       (set-types-from-font-list 'fonts:(dutch20 dutch20b tr12 tr12b tr12i)))))
	  (setq japanese-mappings-added t))))
    (values character-type-mappings japanese-mappings-added)))

1;;; Utility for the above which is also needed by Converse --
;;;    Don't try to use the fonts if we can't sucessfully backtranslate them all to styles.
0(defun compute-character-type-mappings-from-fonts (fonts)
  (condition-case ()
       (loop for f in fonts
	     for i from 0
	     with (style char-set offset)
	     do (cl:multiple-value-setq (style char-set offset)
		  (si:backtranslate-font (string f) si:*b&w-screen*))
	     for canonical-style = (si:canonicalize-character-style style)
	     collect (si:make-char-type-spec si:type i
					     si:bits 0
					     si:char-set (si:make-char-type-spec-char-set
							   si:name (send char-set :name)
							   si:offset offset)
					     si:style (si:unparse-character-style
							canonical-style)
					     si:default-font (string f)))
     (error nil)))

1;;; Determines the Release 6 compatible Fonts list given a default character style and a set
;;; of character type mappings.  If the character type mappings include an explicit mapping
;;; for type 0, it's default font is used rather than that derived from the default character
;;; style.  Normally, the character type mappings do not include a definition of type 0 which
;;; is nominally 2(0 0 (nil 0) (nil nil nil) font-name)1 where 2font-name1 is the name of the font
;;; which corresponds to the default character style and is usually 2"cptfont"1.
0(defun fonts-from-character-type-mappings (default-character-style character-type-mappings)
  (let* ((character-type-mappings (si:eliminate-duplicates
				    (sort character-type-mappings
					  #'(lambda (a b) (lessp (first a) (first b))))
				    #'equal))
	 (default-font-0 (si:char-type-spec-default-font
			   (si:char-type-spec-from-char
			     #\Space 0 *zmail-default-default-character-style*)))
	 (font-0 (if (and character-type-mappings
			  (zerop (first (first character-type-mappings))))
		     (prog1
		       (si:char-type-spec-default-font (first character-type-mappings))
		       (pop character-type-mappings))
		   (si:char-type-spec-default-font
		     (si:char-type-spec-from-char
		       #\Space 0 (or default-character-style
				     *zmail-default-default-character-style*))))))
    (loop for character-type-mapping in character-type-mappings
	  for font-name-string = (si:char-type-spec-default-font character-type-mapping)
	  do (cl:check-type font-name-string string)
	  collect font-name-string into font-list
	  finally (when (or font-list (not (equal font-0 default-font-0)))
		    (return `(,font-0 ,@font-list))))))

1;;; Determines the Release 6 compatible value for the Japanese field.
0(defun japanese-from-character-type-mappings (character-type-mappings)
  (dolist (character-type-mapping character-type-mappings)
    (scl:destructuring-bind (ignore ignore (charset ignore) (ignore ignore size) ignore)
       character-type-mapping
      (when (cl:typecase charset
	      (string (string-equal charset "Japanese"))
	      (si:basic-character-set (string-equal (send charset :name) "Japanese"))
	      (otherwise nil))
	(return-from japanese-from-character-type-mappings
	  (cl:case size
	    (:normal 12)
	    (:large 16)
	    (:very-large 24)
	    (:huge 48)
	    (:otherwise 24)))))))

(define-section-name |Miscellaneous Utilities|)

1;;; Determines the character type mappings required to properly epsilon encode a message.
0(defun compute-msg-character-type-mappings (msg default-character-style)
  (let ((new-character-type-mappings)
	diagrams-present)
    (using-resource (mappings-computer-stream
		      si:epsilon-encoding-output-stream nil :flavor 'zmail-msg-saving-stream)
      (send mappings-computer-stream :set-msg msg)
      (labels ((mappings-computer (ignore start-bp &optional end-bp in-order-p)
		 (declare (sys:downward-function))
		 (multiple-value-bind (more-mappings diagrams-in-interval)
		     (compute-interval-character-type-mappings start-bp end-bp in-order-p
							       mappings-computer-stream
							       default-character-style)
		   (setq new-character-type-mappings (nconc new-character-type-mappings
							    more-mappings)
			 diagrams-present (or diagrams-present diagrams-in-interval)))))
	(map-over-msg-intervals msg #'mappings-computer :include-wrapper t
							:use-original-header t)))
    (if (and (null new-character-type-mappings) diagrams-present)
	(list (character-type-mapping-for-type-0 default-character-style))
      new-character-type-mappings)))

1;;; Determines the 0Default-Character-Style1 of a given message.
0(defun msg-default-character-style (msg)
  (msg-default-character-style-internal (location-contents (assure-msg-parsed msg))))

1;;; Does the actual work of the above and is also called from 2epsilon-decode-msg1.
0(defun msg-default-character-style-internal (msg-headers)
  (let ((dcs (cl:getf msg-headers :default-character-style)))
    (cl:typecase dcs
      (si:character-style dcs)
      (list
	(when (typep (first dcs) 'si:character-style)
	  (first dcs)))
      (otherwise nil))))

1;;; Returns the character type mapping definition for type 0 --
;;;    Type 0 is always defined to return thin characters (i.e., no bits, the standard
;;;    character set and the null style).  To be absolutely accurate, we must use the font
;;;    associated with the default character style of the "message" rather than always
;;;    presuming 2CPTFONT1.
0(defun character-type-mapping-for-type-0 (&optional default-character-style)
  (si:char-type-spec-from-char #\Space 0 (or default-character-style
					     *zmail-default-default-character-style*)))

1;;; Update the Character-Type-Mappings and Fonts field in a message to reflect the current
;;; contents of the message.  This function must be called after any operation (e.g., editing)
;;; which may change the styles of the characters in the message.
0(defun update-msg-character-type-mappings (msg)
  (if (eq *zmail-background-p* t)
      1;; This function can not be called in the background.
0      (ferror "update-msg-character-type-mappings invoked on message ~d in the background."
	      (1+ (msg-displayed-index msg)))
    (let* ((default-character-style (msg-default-character-style msg))
	   (old-character-type-mappings (msg-get msg :character-type-mappings))
	   (new-character-type-mappings
	     (compute-msg-character-type-mappings msg default-character-style))
	   (old-fonts (msg-get msg :fonts))
	   (new-fonts (fonts-from-character-type-mappings default-character-style
							  new-character-type-mappings))
	   (old-japanese (msg-get msg :japanese))
	   (new-japanese (japanese-from-character-type-mappings new-character-type-mappings)))
      (with-msg-redisplay-delayed
	(unless (equal old-character-type-mappings new-character-type-mappings)
	  (msg-put msg new-character-type-mappings :character-type-mappings)
	  (add-header-to-msg msg :character-type-mappings new-character-type-mappings
			     :delete-if-empty t))
	(when (msg-get msg :character-styles)
	  1;; Delete any 0Character-Styles1 field which might be left over from early
0	  1;; Release 7 worlds -- Said fields are no longer necessary now that the
0	  1;; message contains a valid 0Character-Type-Mappings1 field.
0	  (add-header-to-msg msg :character-styles nil :delete-if-empty t))
	(unless (equal old-fonts new-fonts)
	  (msg-put msg new-fonts :fonts)
	  (add-header-to-msg msg :fonts new-fonts :delete-if-empty t))
	(unless (equal old-japanese new-japanese)
	  (msg-put msg old-japanese :japanese)
	  (add-header-to-msg msg :japanese new-japanese :delete-if-empty t))))))

1;;; Determine the character type mappings required to properly encode a draft for transmission.
0(defun compute-draft-character-type-mappings (plist)
  (let ((draft (get plist :draft-msg))
	(saving-stream (get plist :saving-stream)))
    (if saving-stream
	(send saving-stream :reset-state)
      (setq saving-stream (make-instance 'zmail-msg-saving-stream))
      (cl:setf (get plist :saving-stream) saving-stream))
    (loop with default-character-style = (cl:getf (get plist :headers)
						  :default-character-style)
	  for (type values) on (get plist :headers) by 'cddr
	  when (memq type *font-converted-header-lines*)
	    nconc (if (cl:listp values)
		      (loop for value in values
			    nconc
			      (compute-interval-character-type-mappings value nil t
									saving-stream
									default-character-style
									))
		    (compute-interval-character-type-mappings values nil t
							      saving-stream
							      default-character-style))
	      into char-types
	  finally
	    (multiple-value-bind (text-mappings diagrams-present)
		(compute-interval-character-type-mappings (send draft :text) nil t
							  saving-stream
							  default-character-style)
	      (return (or (nconc char-types text-mappings)
			  (when diagrams-present
			    (list
			      (character-type-mapping-for-type-0 default-character-style))))))
	    )))

1;;; Prepare the caller's 2zmail-msg-saving-stream1 to save the given message --
;;;    In other words, preload the message's character type mappings into the stream.
0(defun prepare-msg-saving-stream-for-msg (saving-stream data-stream msg)
  (declare (values msg-needs-encoding))
  (multiple-value-bind (character-type-mappings ignore)
      (get-character-type-mappings-from-header (msg-status msg))
    (let ((msg-needs-encoding (not (null character-type-mappings))))
      (send saving-stream :set-stream data-stream :dumping-fat msg-needs-encoding)
      (send saving-stream :set-msg msg)
      (when msg-needs-encoding 
1	;; Message contains text that requires epsilon encoding --
	;;    If we are performing a background save, we may not have yet canonicalized the
0	1;;    0Character-Type-Mappings1 field to list only those mappings that are actually
	;;    used by the message.  Therefore, we must preset the mappings used by the saving
	;;    stream to insure that the message is encoded with the same mappings that will
	;;    be used to decode it when the mail file is next loaded.  As this presetting is
	;;    an inexpensive operation, we'll do it unconditionally rather than only for
0	1;;    background saves.  If we missed a mapping (due to an bogus
0	1;;    0Character-Type-Mappings1 field), the saving stream will detect this and abort
	;;    the save.
0	(send saving-stream :clear-character-types)
	(send saving-stream :preset-character-type :index 0)
	(loop for (index bits (character-set offset) style default-font)
		  in character-type-mappings
	      do (send saving-stream :preset-character-type :index index
							    :bits bits
							    :character-set character-set
							    :offset offset
							    :style (si:parse-character-style
								     style)
							    :default-font default-font)))
      msg-needs-encoding)))

1;;; Write the header interval of a message to a saving stream with epsilon encoding --
;;;    When encoding a message, we must be certain that each line of the header interval
;;;    returns to type zero before starting the next line.  Otherwise, a header field
;;;    which isn't encoded that follows a field which is encoded would have "001" prepended
;;;    to its field name which would prevent it from being properly parsed when next loaded.
0(defun encode-msg-header-interval (saving-stream start-bp &optional end-bp in-order-p)
  (with-interval-stream (stream start-bp end-bp in-order-p)
    (cl:loop
       (multiple-value-bind (line eof)
	   (send stream :line-in)
	 (send saving-stream :string-out line)
	 (if eof
	     (return-from encode-msg-header-interval nil)
	   (send saving-stream :back-to-type-zero)
	   (send saving-stream :tyo #\Return))))))
