;;; -*- Mode: LISP; Package: ZWEI; BASE: 8; Lowercase: Yes; Syntax: Zetalisp -*-
;;; Network message facility
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Accepts either a string or interval and returns a string.
0(defsubst (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")text-as-string0 (text)
  (if (stringp text)
      text
    (string-interval text)))

1;;; Accepts either a string or interval and returns an interval.
0(defsubst 2text-as-interval0 (text)
  (if (stringp text)
      (create-interval text)
    text))

;;; User options
;;; Default changed to :POP-UP by DLW, 5/14/82, after consulting with people.
(defconst 2*converse-default-mode*0 ':pop-up)

(defvar 2*converse-mode* 0*converse-default-mode*
  ":AUTO, :NOTIFY, :NOTIFY-WITH-MESSAGE, or :POP-UP")

(defvar 2*converse-append-p*0 nil "NIL=prepend mode, T=append mode")

(defvar 2*converse-beep-count*0 2 "Number of beeps when message arrives.")

(defvar 2*converse-end-exits*0 nil)	;T means End sends and buries, c-End just sends
					;NIL means vice versa

(defvar 2*converse-fat-line-height*0 3\4
  "Fraction of the line height occupied by a converse header diagram.")

(defvar 2*converse-thin-line-height* 01\4
  "Fraction of the line height occupied by a converse message divider diagram.")

(defvar 2*converse-gagged*0 nil)

;;; These two variables are obsolete.  They are replaced by *CONVERSE-MODE*.
;;; They're being kept around for compatibility, but you should stop setting
;;; then and start setting *CONVERSE-MODE*.
(defvar 2*converse-auto-expose-p*0 t "T=automatic exposure, NIL=notification")

(defvar 2*converse-notify-with-message*0 nil "T=notification includes message, NIL=just sender")

(defun 2qsends-off0 (&optional (gag-message t))
  (setq *converse-gagged* gag-message))

(defun 2qsends-on 0()
  (setq *converse-gagged* nil))



(defconst 2*converse-buffer-munged-message*
0	  "Buffer damaged.  You must do Meta-X Regenerate Buffer to continue.
WARNING: Regenerate Buffer will discard all text typed since the last message was sent.
	 You must save it on the kill ring before before typing this command.")

(defconst 2*converse-point-invalid-message*
0	  "You're not inside a conversation; move into one (or do Meta-X Regenerate Buffer).
WARNING: Regenerate Buffer will discard all text typed since the last message was sent.
	 You must save it on the kill ring before before typing this command.")

(defflavor 2conver
0	  (first-line				;first line in conversation
	   last-line				;last line in conversation
	   (recipients nil)			;with whom are we conversing
	   (ident nil)				;unique id of this message.
						;NIL for the anonymous conversation.
	   (private nil)			;send only to person requested
	   my-node				;node in which this is happening
	   to-line-del				;points to diagram after To: area
	   (with-header-p t)			;whether or not conversation has header
	   (append-mode *converse-append-p*)
	   (oldmsgs nil)			;all the msgs in this conversation
	   )
	  ()
  (:initable-instance-variables recipients ident append-mode with-header-p)
  (:init-keywords :before-line :after-line)
  :gettable-instance-variables)

(defmethod 2(:line-mine? conver)0 (line)
  (eq (line-node line) my-node))

(defmethod 2(:my-ident? conver)0 (id)
  (equal ident id))

(defmethod 2(:my-recipient? conver)0 (the-recipient)
  (labels ((address-string (address)
	     (or (cl:getf address :string-for-comparison)
		 (let ((interval (cl:getf address :interval)))
		   (when interval
		     (let ((string (string-interval (first interval) (second interval) t)))
		       (putprop (locf address) string :string-for-comparison)
		       string)))
		 (let ((string (string-from-header address :route)))
		   (putprop (locf address) string :string-for-comparison)
		   string))))
    1;; We must compare the textual representation of addresses in case the host hasn't
0    1;; yet been resolved to a host object but is still a domain string.  (Of course, if
0    1;; the host is still a string, the comparison may fail due to aliases but it's presently
0    1;; too slow to attempt domain resolution until absolutely necessary.)
0    (loop with the-recipient-address-string = (address-string the-recipient)
	  for recipient in recipients
	  thereis (string-equal the-recipient-address-string (address-string recipient)))))

(defmethod 2(:my-recipients? conver)0 (the-recipients)
  (and (= (length recipients) (length the-recipients))
       (loop for the-recipient in the-recipients
	     always (send self ':my-recipient? the-recipient))))

;;; Return a bp to the line immediatly after "To:".  In the case of a headerless
;;; conversation, the bp is to the end of the "To:" line.
(defmethod 2(:after-to-line-bp conver)0 ()
  (end-of-line (line-previous to-line-del)))

;;; This is really for creating the To: line conversation at the top of the buffer.
(defun-in-flavor 2(init-conversation-without-h conver)0 (after-line before-line &aux line)
  (setq my-node (create-interval (create-bp before-line 0 ':normal)
				 (create-bp after-line 0 ':moves)))
  (setf (node-superior my-node) *interval*)
  (setf (line-node after-line) my-node)
  (setf (line-node before-line) my-node)
  (setq line (make-diagram-line 'converse-line-diagram))
  (setf (line-node line) my-node)
  (let ((*enable-change-recording* nil))
    (insert-line-with-leader line before-line)
    (insert-within-line after-line 0 "To: " 0 4)	;put in To: line
    (setq to-line-del line)
;;  (INSERT (CREATE-BP LINE 0 ':MOVES) #\CR)
    (setq first-line after-line
	  last-line line)))

;; this is for creating the To: line of a normal conversation
(defun-in-flavor 2(init-conversation-with-h conver)0 (after-line before-line &aux line)
  (setq my-node (create-interval (create-bp before-line 0 :normal)
				 (create-bp after-line 0 :moves)))
  (setf (node-superior my-node) *interval*)
  ;; splice in MY-NODE (must check for node type)
  (when (and (typep (line-node after-line) 'node)
	     (node-next (line-node after-line)))
    (setf (node-next (line-node after-line)) my-node))
  (when (and (typep (line-node before-line) 'node)
	     (node-previous (line-node before-line)))
    (setf (node-previous (line-node before-line)) my-node))
  ;; make end of conversation delimiter
  (setq line (make-diagram-line 'converse-line-diagram))
  ;; splice this diagram between AFTER-LINE and BEFORE-LINE
  ;; reason am doing this is to avoid setting nodes for To: line
  (setq last-line line)
  (let ((*enable-change-recording* nil))
    (insert-line-with-leader line before-line)
    ;; must set node after inserting, otherwise wrong node will be used
    (setf (line-node line) my-node)
    (setq to-line-del line)
    ;; put To: line before end delimiter
    (insert (create-bp line 0)
	    (string-append "To: "
			   (converse-addresses-string recipients :retain-common-tails t)
			   #\return #\return))
    ;; make header diagram
    (setq line (make-diagram-line 'converse-header-diagram
				  :name (converse-addresses-string recipients)))
    (setf (line-node line) my-node)
    ;; splice header between AFTER-LINE and To: line
    (insert-line-with-leader line (line-next after-line))
    ;; tell header what name to display
    (setq first-line (line-next after-line))
    ))

;;; Initializes a conversation with correct To: line and diagrams.
;;; Must put itself between AFTER-LINE and BEFORE-LINE.
;;; If HEADER is nil then use AFTER-LINE for first-line and do not generate a 
;;; conversation header diagram. Don't even bother with nodes for BEFORE-LINE.
(defmethod 2(:init conver)0 (init-plist)
  (let ((before-line (get init-plist ':before-line))
	(after-line (get init-plist ':after-line)))
    (if (or (null before-line) (null after-line))
	(ferror nil "You must supply a before-line and an after-line when creating a CONVER"))
    (if with-header-p
	(init-conversation-with-h after-line before-line)
	(init-conversation-without-h after-line before-line))))

1;;; Takes a message and adds it in the right place to the conversation.
0(defmethod 2(:add-msg conver)0 (before text &rest args)
  1;; Inserts all the new text before the old 2to-line-del1 and creates a new 2to-line-del1.
0  (push (list* before text (copylist args)) oldmsgs)
  (unless (send self :conversation-good?)
    (converse-error *converse-buffer-munged-message*))
  (let ((line (make-diagram-line 'converse-line-diagram))
	(*enable-change-recording* nil))
    (cond ((or (eq last-line to-line-del) (not append-mode))
	   1;; Prepending or this conversation is empty.
0	   (insert-line-with-leader line to-line-del)
	   (setf (line-node line) my-node)
	   (setq to-line-del line))
	  (t
	   1;; Appending.
0	   (insert-line-with-leader line last-line)
	   (setf (line-node line) my-node)))
    (let ((bp (create-bp (line-next line) 0)))
      (flet ((insert-piece (piece)
	       (if (char-equal (aref piece (1- (string-length piece))) #\return)
		   (insert-moving bp piece)
		 (insert-moving bp #\return)
		 (with-bp (bp bp)
		   (insert (dbp bp) piece)))))
	(unless (null before)
	  (insert-piece before))
	(cond ((typep text 'interval)
	       (let ((start-bp text) end-bp)
		 (get-interval start-bp end-bp nil)
		 (if (= (bp-index end-bp) 0)
		     (insert-interval bp start-bp end-bp t)
		   (insert bp #\return)
		   (with-bp (bp bp)
		     (insert-interval (dbp bp) start-bp end-bp t)))))
	      1;; Must be a string...
0	      ((string-equal text ""))		1;Don't insert unecessary blank lines if "null"
0	      (t
	       (insert-piece text)))))))

(defun 2converse-find-msg0 (conversation id)
  (loop for msg in (send conversation :oldmsgs)
	as (nil nil . after) = msg
	when (eq (first after) id)
	  do (return msg)))

;;; Finds msg with given id.  Changes the BEFORE from what it was to the newly
;;; supplied BEFORE.  I guess there's no reason to pass in TEXT, we don't really
;;; use it for anything.  Updates the buffer, too. 
(defmethod 2(:replace-msg conver)0 (id before text &rest args)
  (let ((m (converse-find-msg self id))
	(new-msg (list before text (copylist args))))
    (let* ((old-before (string-trim '(#\cr) (first m)))
	   (converse-before
	     (loop for line = first-line then (line-next line)
		   until (string-equal line old-before)
		   finally (return line))))
      (let ((start-bp (make-bp bp-line converse-before
			       bp-index 0
			       bp-status :normal))
	    (end-bp (make-bp bp-line converse-before
			     bp-index (string-length converse-before)
			     bp-status :normal))
	    (*enable-change-recording* nil))
	(delete-interval start-bp end-bp t)
	(insert-moving start-bp (string-trim '(#\cr) before))))
    (setq oldmsgs (cl:substitute new-msg m oldmsgs))))

1;;; Return the 0To:1 field of the message and the interval which is the message text.
0(defmethod 2(:get-to-msg conver)0 ()
  (unless (send self :conversation-good?)
    (converse-error *converse-buffer-munged-message*))
  (let* ((to-line (if with-header-p (line-next first-line) first-line))
	 (text-start-line (line-next to-line))
	 (text-start-bp (when text-start-line (beg-of-line text-start-line)))
	 (text-end-line (line-previous to-line-del))
	 (text-end-bp (end-of-line text-end-line)))
    (unless (string-equal to-line "To:" 0 0 3 3)
      (converse-error "This message doesn't start with /"To:/"."))
    (when (or (null text-start-line)		1;Eh?
0	      (bp-< text-end-bp text-start-bp)
	      (do ((line text-start-line (line-next line)))
		  ((eq line to-line-del) t)
		(when (or (line-diagram line)
			  (string-search-not-set *whitespace-chars* line))
		  (return nil))))
      (converse-error "This message has no contents, only a /"To:/" line."))
    (when (line-diagram text-end-line)
      1;; Message ends with a diagram --
0      1;;    We have to add a blank line in order to avoid losing the diagram.
0      (insert (beg-of-line to-line-del) #\return)
      (setq text-end-bp (ibp text-end-bp)))
    (values (substring to-line 3)
	    (create-interval text-start-bp text-end-bp))))

;;; True if BP lies within a non-blank message that has not yet been sent
(defmethod 2(:bp-in-partial-msg conver)0 (bp)
  (let ((start (beg-of-line (if with-header-p (line-next first-line) first-line)))
	(end (beg-of-line to-line-del)))
    (and (not (bp-< bp start)) (not (bp-< end bp))
	 (bp-< (forward-over '(#\sp #\cr) (if with-header-p (forward-line start 1 t)
					      (forward-char start 3 t)))
	       end))))

;;; returns To: line area to initial state for conversations with headers
(defun-in-flavor 2(restore-to-msg-with-h conver)0 ()
  (let ((*enable-change-recording* nil))
    ;; splice out lines between the header and the To: line delimiter
    (delete-interval (create-bp (line-next first-line) 0)
		     (create-bp to-line-del 0))
    ;; now put in a new To: line
    (insert (create-bp to-line-del 0)
	    (string-append "To: "
			   (converse-addresses-string recipients :retain-common-tails t)
			   #\return #\return))))

;;; returns To: line area to initial state for conversations without headers
(defun-in-flavor 2(restore-to-msg-without-h conver)0 ()
  (let ((*enable-change-recording* nil))
    (with-bp (bp (create-bp first-line 0) ':normal)
      (delete-interval bp (end-of-line (line-previous to-line-del)))
      (setq first-line (bp-line bp)))
    (insert-within-line first-line 0 "To: " 0 4)
    ;;  will have to reset the interval-first-bp of converse buffer to start-line
    ;;  (INSERT (CREATE-BP TO-LINE-DEL 0 ':MOVES) #\CR)
    ))

;;; returns the To: line area to is empty state
(defmethod 2(:restore-to-msg conver)0 ()
  (if (null (send self ':conversation-good?)) 
      (converse-error *converse-buffer-munged-message*))
  ;; what we do depends on whether or not there is a header for this conversation
  (if with-header-p (restore-to-msg-with-h) (restore-to-msg-without-h)))

;;; The following stuff will restore a damaged conversation or conversation buffer

(defflavor 2converse
0	(*converse-list*			;list of all ongoing conversations
	 (*converse-request-queue* nil)		;requests from other processes
		;This is a list of requests, each is cons of function and list of args
	 (*converse-node* nil))			;editor node containing conversations
	()
  (:required-flavors top-level-editor)
  :special-instance-variables
  (:special-instance-variable-binding-methods :edit :delete-all-conversations))

(globally-declare-flavor-instance-variables converse)

;;; This will regenerate the entire buffer in case it has been munged by the user
(defun 2regen-converse-buffer0 ()
  (let ((oldlist (reverse (cdr *converse-list*)))	;old list minus first conversation
	(*enable-structural-diagrams* nil)	; permit us to delete diagrams
	(*enable-change-recording* nil))
    ;; clear everything out of the buffer
    (delete-interval *interval*)
    (insert (interval-first-bp *interval*) #\cr)
    ;; make a headerless To: line conversation
    (let ((c (make-instance 'conver ':with-header-p nil
			    ':after-line (bp-line (interval-first-bp *interval*))
			    ':before-line (bp-line (interval-last-bp *interval*)))))
      ;; create the conversation list
      (setq *converse-list* (list c)))
    ;; now regenerate all the conversations in order
    (dolist (conversation oldlist)
      (regen-setup-conversation conversation))
    ;; move the point to beginning of new buffer
    (move-point (end-line (interval-first-bp *interval*)))))

;;; for regenerating a conversation after main to-line conversation
(defun 2regen-setup-conversation0 (conversation &aux line)
  (if (cdr *converse-list*)
      (setq line (send (cadr *converse-list*) ':first-line))
      (setq line (bp-line (interval-last-bp *interval*))))
  (setq *converse-list*	(append (list (car *converse-list*)) (list conversation)
				(cdr *converse-list*)))
  (send conversation ':regen-yourself (line-previous line) line)
  conversation)

;;; This is almost the same thing as :INIT except go through all the OLDMSGS and add
;;; them to the buffer.
(defmethod 2(:regen-yourself conver)0 (after-line before-line &aux (toldmsgs oldmsgs))
  (setq append-mode *converse-append-p*)
  (if with-header-p (init-conversation-with-h after-line before-line)
		    (init-conversation-without-h after-line before-line))
  (setq oldmsgs nil)
  (dolist (msg (reverse toldmsgs))
    (lexpr-send self ':add-msg msg))) 



(defflavor 2converse-copyable-diagram-mixin
0	()
	())

(defmethod 2(:editor-copy converse-copyable-diagram-mixin)0 ()
  (send self :string-for-file))

(defflavor 2converse-header-diagram0 
	()
	(converse-copyable-diagram-mixin
	 black-line-diagram-with-legend-mixin
	 structural-line-diagram-mixin)
  (:init-keywords :name)
  (:required-init-keywords :name)
  (:default-init-plist :structural t))

(defmethod 2(:init converse-header-diagram :before)0 (init-plist)
  (setq style (si:parse-character-style '(nil :bold nil)))
  (setq height *converse-fat-line-height*)
  (setq legend (format nil "To: ~A" (get init-plist :name))))

(defflavor 2converse-line-diagram
0	()
	(converse-copyable-diagram-mixin
	 black-line-diagram
	 structural-line-diagram-mixin)
  (:default-init-plist :structural t :height *converse-thin-line-height*))



;Use this message to send a request to the Converse process.
;The request is placed on the request queue and the process is awakened
;by forcing keyboard input.
(defmethod 2(:enter-request converse)0 (function &rest args)
  (let ((req (cons function (copylist args))))
    (without-interrupts (push req *converse-request-queue*))
    (send self ':force-kbd-input '(:execute converse-post-command-hook))))

(defmethod 2(:pending-requests converse)0 ()
  *converse-request-queue*)

(defmethod 2(:delete-all-conversations converse)0 ()
  (setq *converse-list* nil)
  (regen-converse-buffer)
  (must-redisplay *window* dis-text))

;;; creates a conversation and splices it in between the anonymous conversation
;;; and the conversation after that.  Special case if no other conversations 
;;; besides anonymous
(defun 2setup-conversation 0(recipients ident &aux conversation line)
  (if (null (converse-buffer-good?))
      (converse-error *converse-buffer-munged-message*))
  (if (cdr *converse-list*)
      (setq line (send (cadr *converse-list*) ':first-line))
      (setq line (bp-line (interval-last-bp *interval*))))
  (setq conversation (make-instance 'conver
				    ':recipients recipients
				    ':ident (or ident (generate-standard-message-id))
				    ':after-line (line-previous line)
				    ':before-line line))
  (setq *converse-list*	(append (list (car *converse-list*)) (list conversation)
				(cdr *converse-list*)))
  conversation)

;;; Try to get Converse to file incoming messages in the right
;;; conversation when they are to multiple recipients, even when the
;;; sender isn't generating ALSO lists (the present state of affairs
;;; with Converse).

(defun 2find-or-setup-conversation0 (&key recipients from ident text &allow-other-keys)
  (or (and ident
	   (dolist (conver *converse-list*)
	     (when (send conver ':my-ident? ident)
	       (return conver))))
      (cond (recipients
	     (dolist (conver *converse-list*)
	       (when (send conver ':my-recipients? recipients)
		 (return conver))))
	    (from
	     ;; Return only a conversation with exactly the same set of
	     ;; conversers as the incoming message.
	     (let ((recipients (cons from (find-also-to-addresses text))))
	       (dolist (conver *converse-list*)
		 (when (send conver ':my-recipients? recipients)
		   (return conver))))))
      ;; Where a conversation is to be created, create it with exactly
      ;; the same set of conversers as the incoming message.
      (setup-conversation
	(or recipients
	    (cons from (find-also-to-addresses text)))
	ident)))

(defun 2find-also-to-addresses0 (text)
  (let* ((text (text-as-string text))
	 (also-keyword "
Also-to: ")
	 (also-index (let ((also-to-loc (string-search also-keyword text)))
		       (and also-to-loc
			    (+ also-to-loc (string-length also-keyword))))))
    (when also-index
      (condition-case ()
	   (parse-addresses
	     (substring text also-index (string-search-char #\cr text also-index)))
	 (error nil)))))

;;; The following stuff will allow a conversation, or buffer to check its
;;; integrity.  For a buffer, that means being able to reach the first and
;;; last lines of every conversation, in the same order that they were put
;;; in the buffer.  Also, the last line of one conversation must be the first
;;; line of another conversation.  A conversation, however, only cares that 
;;; its to-line-delimiter is between its first line and last line, and that
;;; its first line can be reached from the first line in the buffer.

;;; the present definition is a little too stringent: all it should really
;;; check for is a good 1st conversation and a good neighboring conversation
;;; (depending on the direction of the buffer) - more trickieness to come!
(defun 2converse-buffer-good?0 ()
  ;; first line in buffer must be first line of first message
  (and (eq (bp-line (interval-first-bp *interval*))
	   (send (car *converse-list*) ':first-line))
       ;; must be able to get to the last line
       
       ;; check each last line for next line being first line of next conversation
       (do ((c *converse-list* (cdr c)))
	   ((null (cdr c)) t)
	 (if (not (line-reachable? (send (car c) ':first-line)
				   (send (car c) ':last-line)))
	     (return nil))
	 (if (neq (line-next (send (car c) ':last-line))
		  (send (cadr c) ':first-line))
	     (return nil)))))

;;; returns whether or not the TO-LINE-DEL is in between the FIRST-LINE and 
;;; LAST-LINE and also if the FIRST-LINE is reachable in the *CONVERSE-WINDOW*
(defmethod 2(:conversation-good? conver)0 ()
  (and (line-reachable? (bp-line (interval-first-bp *interval*)) first-line)
       (line-reachable? first-line to-line-del)
       (line-reachable? to-line-del last-line)))

;;; will find out if TO-REACH-LINE is somewhere after START-LINE
(defun 2line-reachable?0 (start-line to-reach-line)
  (do () (())
    (if (null start-line) (return nil))
    (if (and (line-next start-line)
	     (neq (line-previous (line-next start-line)) start-line))
	(return nil))				;not a broken link?
    (if (eq start-line to-reach-line) (return t))
    (setq start-line (line-next start-line))))

(defprop 2converse-post-command-hook0 100 command-hook-priority)

;;; Post-command hook to dump out any pending requests
;;; (They might have come in while in a break loop)
(defun 2converse-post-command-hook0 (&optional ignore)
  (when (eq *interval* *converse-node*)
    (dolist (req *converse-request-queue*)
      ;; Remove the request from the queue, since if it can be done at all
      ;; we will do it, and an incoming-message process might be watching
      ;; to see whether we accept it and start processing it.
      (without-interrupts
	(setq *converse-request-queue* (delq req *converse-request-queue*)))
      (catch-zwei-command-loop			;Catch BARF from CONVERSE-ERROR
	(apply (car req) (cdr req))))))



;;;; Commands

(defcom 2com-converse-previous-conversation0 "Move to the previous conversation." ()
  ;;go through all the conversations and find out which one the cursor is in
  (if (null (converse-buffer-good?))
      (barf *converse-buffer-munged-message*))
  (let ((conversation (dolist (c *converse-list*)
			(if (send c ':line-mine? (bp-line (point))) (return c)))))
    (if (null conversation)
	(barf *converse-point-invalid-message*))
    (setq conversation
	  (if (eq (bp-line (send *interval* :last-bp)) (bp-line (point)))
	      ;; special-case kludge for last line in buffer, which is in *first* conversation
	      (first (last *converse-list*))
	    (loop for clist on *converse-list*
		  when (eq (second clist) conversation)
		    ;; if past active point of present conversation, just move up to it
		    do (return (if (bp-< (send (second clist) ':after-to-line-bp) (point))
				   (second clist)
				 (first clist))))))	;else move to previous conversation
    (if conversation
	(move-bp (point) (send conversation ':after-to-line-bp))
      (beep)
      (typein-line "Already at top of conversation list.")))
  dis-bps)

(defcom 2com-converse-next-conversation0 "Move to the next conversation." ()
  ;;go through all the conversations and find out which one the cursor is in
  (if (null (converse-buffer-good?))
      (barf *converse-buffer-munged-message*))
  (let ((conversation (dolist (c *converse-list*)
			(if (send c ':line-mine? (bp-line (point))) (return c)))))
    (if (null conversation)
	(barf *converse-point-invalid-message*))
    (setq conversation
	  (if (eq (bp-line (send *interval* :last-bp)) (bp-line (point)))
	      ;; special-case kludge for last line in buffer, which is in *first* conversation
	      nil
	    (loop for clist on *converse-list*
		  when (eq (first clist) conversation)
		    ;; if before active point of present conversation, just move down to it
		    do (return (if (bp-< (point) (send (first clist) ':after-to-line-bp))
				   (first clist)
				 (second clist))))))	;else move to next conversation
    (if conversation
	(move-bp (point) (send conversation ':after-to-line-bp))
      (beep)
      (typein-line "Already at bottom of conversation list.")))
  dis-bps)

(defcom 2com-converse-regenerate-buffer0 "Restore the Converse buffer to working condition." ()
  (regen-converse-buffer)
  dis-all)

(defcom 2com-converse-abort0 "Exit from CONVERSE." ()
  (converse-quit)
  dis-none)

(defcom 2com-converse-send
0	com-converse-send-documentation
	()
  (converse-send-msg)
  (unless (eq (eql *last-command-char* #\end) (not *converse-end-exits*))
    (converse-quit))
  dis-text)

(defun 2com-converse-send-documentation0 (ignore char op)
  (cond ((eq op ':name)
	 "Converse Send")
	((null char)
	 (princ "Transmit the message, exiting Converse according to *CONVERSE-END-EXITS*"))
	((eq (eql char #\end) (not *converse-end-exits*))
	 (princ "Transmit the message and remain in Converse."))
	(t (princ "Transmit the message and exit Converse."))))

(defcom 2com-converse-delete-conversation0 "Delete the conversation from the buffer." ()
  ;;go through all the conversations and find out which one the cursor is in
  (if (null (converse-buffer-good?))
      (barf *converse-buffer-munged-message*))
  (let ((conversation (dolist (c *converse-list*)
			(when (and (send c ':line-mine? (bp-line (point)))
				   (send c :recipients))			  
			  (return c))))
	(*enable-structural-diagrams* nil)
	(*enable-change-recording* nil))
    (if (null conversation)
	(barf *converse-point-invalid-message*))
    (delq conversation *converse-list*)
    (delete-interval (create-bp (send conversation ':first-line) 0)
		     (create-bp (line-next (send conversation ':last-line)) 0)))
  dis-text)

(defcom 2com-converse-write-buffer0 "Write the entire buffer (all conversations) into a file."
	()
  (let ((pathname (accept-defaulted-pathname "Write conversation to" (pathname-defaults)
					     :special-version nil :direction :write)))
    (with-open-file (stream pathname
			    ':direction ':output
			    ':error ':reprompt)
      (stream-out-interval stream *interval* nil nil nil)))
  dis-none)

(defcom 2com-converse-write-conversation0 "Write a single conversation into a file." ()
  ;;go through all the conversations and find out which one the cursor is in
  (if (null (converse-buffer-good?))
      (barf *converse-buffer-munged-message*))
  (let ((conversation (dolist (c *converse-list*)
			(when (and (send c ':line-mine? (bp-line (point)))
				   (send c :recipients))			  
			  (return c)))))
    (if (null conversation)
	(barf *converse-point-invalid-message*))
    (let ((pathname (accept-defaulted-pathname "Write buffer to" (pathname-defaults)
					       :special-version nil :direction :write)))
      (with-open-file (stream pathname ':direction ':output ':error ':reprompt)
	(stream-out-interval
	  stream
	  (create-bp (or (line-previous (send conversation ':first-line))
			 (send conversation ':first-line)) 0)	; if at beginning of buffer
	  (create-bp (send conversation ':last-line) 0)
	  t nil))))
  dis-none)

(defcom 2com-converse-append-buffer
0	"Append the entire buffer (all conversations) to the end of a file." ()
  (let ((pathname (accept-defaulted-pathname
		    "Append Converse buffer to" (pathname-defaults))))
    (with-open-file (ostream pathname :direction :output :error :reprompt)
      (condition-case (err)
	  (with-open-file (istream pathname :direction :input)
	    (stream-copy-until-eof istream ostream))
	(fs:file-not-found
	  (typein-line "(New File)"))
	(fs:file-operation-failure
	  (barf "Error: ~A" err)))
      (stream-out-interval ostream *interval* nil nil nil)))
  dis-none)

(defcom 2com-converse-append-conversation
0	"Appends the conversation to the end of a file." ()
  ;;go through all the conversations and find out which one the cursor is in
  (if (null (converse-buffer-good?))
      (barf *converse-buffer-munged-message*))
  (let ((conversation (dolist (c *converse-list*)
			(when (and (send c :line-mine? (bp-line (point)))
				   (send c :recipients))			  
			  (return c)))))
    (if (null conversation)
	(barf *converse-point-invalid-message*))
    (let ((pathname (accept-defaulted-pathname
		      "Append Converse conversation to" (pathname-defaults)))
	  (bp1 (create-bp (or (line-previous (send conversation :first-line))
			      (send conversation :first-line)) 0))
	  (bp2 (create-bp (send conversation :last-line) 0)))
      (with-open-file (ostream pathname :direction :output :error :reprompt)
	(condition-case (error)
	    (with-open-file (istream pathname :direction :input)
	      (stream-copy-until-eof istream ostream))
	  (fs:file-not-found (typein-line "(New File)"))
	  (fs:file-operation-failure (barf "Error: ~A" error)))
	(stream-out-interval ostream bp1 bp2 t nil))))
    dis-none)

(defcom 2com-converse-help0 "Explain all the Converse commands." ()
  (let ((end-msg ", without leaving")
	(c-end-msg " and exit from"))
    (when *converse-end-exits*
      (swapf end-msg c-end-msg))
    (format t "You are in Converse, the interactive message editor.

Messages are separated by black lines.  They are organized into conversations, separated by
thick black lines.  To send a message to Fred@Host, move to after the /"To:/" at the beginning
of the buffer, type Fred@Host, type Return, and the message.  Then use ” or c-” to
send it.  This creates a new conversation, which has a template message at the front that you
can use to send Fred more messages.  Then you can use the /"To:/" at the beginning of the
buffer to start new conversations, or use the templates at the beginning of each conversation
to continue that conversation.  Newly-arrived messages get put into the appropriate
conversation, or start new conversations.  You may edit the text of messages and move text
around between messages, but you should avoid trying to edit or move the black lines
themselves.  If instead of saying Fred@Host you just say Fred, Converse will try to find a
Lisp Machine that Fred is logged into and send the message there.

All the usual editor commands can be used to edit your messages.
The following additional commands are provided:
   End                      Send the current message~A Converse.
   Control-End              Send the current message~A Converse.
   Abort                    Get rid of the Converse window.
   Control-M                Mail the current message instead of sending it.
   Control-Meta-[           Move to the previous conversation.
   Control-Meta-]           Move to the next conversation.
   M-X Delete Conversation  Delete the current conversation.
   M-X Write Buffer         Write the entire buffer (all conversations) to a file.
   M-X Write Conversation   Write only the current conversation to a file.
   M-X Append Buffer        Append the entire buffer (all conversations) to the end of a file.
   M-X Append Conversation  Append the current conversation to the end of a file.
   M-X Regenerate Buffer    This may be necessary if, during your editing, you somehow
                            damage the structure of the buffer, by editing in or across
                            the black lines.  This command rebuilds the structure.  Some
                            error messages may ask you to give this command and try again.

The following commands can be given from a Lisp Listener.
   (zl:qsend)                 Enter Converse.
   (zl:qsend dest)	      Read a message from the keyboard and send it to dest.
   (zl:qsend dest message)    Send message to dest.  Note: dest is not evaluated.
   (zl:qreply)		      Reply to the person who sent the last message.
   (zl:qreply message)	      Send message to the person who sent the last message.
   (zwei:qsends-off)	      Reject all incoming messages.
   (zwei:qsends-off message)  Same, but /"message/" is told to anyone who tries sending to you.
   (zwei:qsends-on)	      Undo qsends-off; accept further messages.

The following are user options that you may set in your lispm-init file:

 ZWEI:*CONVERSE-MODE*         What to do if a message arrives and Converse isn't exposed:

    :AUTO - Expose the Converse window as soon as the message arrives.
    :NOTIFY - Just notify that a message has arrived.
    :NOTIFY-WITH-MESSAGE - Same, but include the whole message with the notification.
    :POP-UP - Pop up a little window that lets you reply or get to Converse.

 ZWEI:*CONVERSE-APPEND-P*     If true, new messages are appended to the ends of
			      conversations.  If false (this is the default), they are
			      prepended to the beginnings of conversations.

 ZWEI:*CONVERSE-BEEP-COUNT*   The number of times to beep when a message arrives.  The
			      default value is 2.

 ZWEI:*CONVERSE-END-EXITS*    If true, ” sends the message and buries the Converse window
			      and c-” just sends the message.  If false (the default), the
			      actions of these keys are exchanged.

Type a space to return to Converse top level: "
	    end-msg c-end-msg))
  dis-none)

;;; This is the top-level function for the process
(defvar 2*converse-frame*0)

(defun 2converse-quit0 ()
  (send *converse-frame* ':bury))

(defcom 2com-converse-mail-message
0	"Mail the current message to the specified destination instead of sending it." ()
  (converse-send-msg :mail-p t)
  dis-text)

;;; Associates an ID with each message that's been sent.  So we can locate them again.
(defun 2converse-make-msg-unique-id0 ()
  (gensym))

1;; Figures out what is the message to transmit, sends it, and updates the buffer --
;;    Most errors returned by 2send-msg1 report as complete sentences in their own right;
;;    let them stand by themselves rather than merging them into our own sentence.
0(defun 2converse-send-msg0 (&key mail-p plist errors
			  &aux conversation new-conversation
			       (id (converse-make-msg-unique-id)))
  1;; 2plist1 will only be passed in by 2qsend-msg-simple1.
0  (unless plist
    (cl:multiple-value-setq (plist conversation)
      (converse-get-recipients-and-msg))
    (setq errors (cl:apply #'converse-ensure-msg-can-be-sent plist)))
  (setq new-conversation (apply #'find-or-setup-conversation plist))
  (converse-show-temporary-sending-feedback new-conversation plist id mail-p)
  1;; Now that the message has been safely stowed away, delete the original copy.
0  (when conversation				1;E.g., not called by 2qsend1.
0    (send conversation :restore-to-msg)
    1;; Reposition the cursor into the proper conversation.
0    (if *converse-append-p*
	(move-bp (point) (create-bp (send new-conversation :last-line) 0))
	(move-bp (point) (send new-conversation :after-to-line-bp))))
  (must-redisplay *window* dis-text)
  (process-run-function "Sending Message"
    (lambda (converse-frame plist conversation id output-stream original-errors)
      (declare (dbg:bug-report-recipient-system "Converse"))
      1;; Bind 2output-stream1 to the typein window so that if the background process
      ;; wants to type out it goes somewhere reasonable.  This isn't really right,
      ;; but this situation doesn't come up very often.
0      (let ((errors original-errors))
	1;; Passing in 2errors1 this way has the undesired side-effect0 1that if, for example,
0	1;; services aren't enabled and you choose not to send the message, for a brief
	;; second you'll see 0"Message being sent"1 in the 0Converse1 buffer before it turns
0	1;; into 0"Messate not sent"1.  I don't feel like taking the time to clean this up,
	;; because it's so rare.  (10/3/86 -- doughty)
0	(unwind-protect
	    (unless errors
	      (setq errors
		    (cond
		      (mail-p
		       1;; Invoke 0Zmail1's internal function to send mail.
0		       (send-message-string (get (locf plist) :recipients)
					    (get (locf plist) :text)
					    :subject "[Failing Converse message]"
					    :report-stream output-stream)
		       1;; Always return 2nil1 until we know how to interface to 0Zmail1 errors.
0		       nil)
		      (t
		       1;; Call and return result of 2send-msg1 which does actual network sending.
0		       (condition-case ()
			    (apply #'send-msg plist)
			  (sys:abort
			    :sending-aborted))))))
	  (when errors
	    1;; If the 0Converse1 frame isn't exposed, send a notification about the errors.
0	    (unless (memq (send converse-frame :status) '(:exposed :selected))
	      (converse-notify-from-background-process errors)))
	  (send converse-frame :enter-request
		'converse-update-buffer-from-background-process plist errors
								conversation mail-p id)
	  )))
    *converse-frame* plist new-conversation id *typein-window* errors))

(defun 2format-converse-errors-string0 (errors stream)
  (when (listp errors)
    (format stream "The message could not be delivered.~%")
    (loop for (error recipient) in errors
	  do (format stream "~A: ~~A~~%" (converse-address-string recipient) error))))

(defun 2converse-update-buffer-from-background-process0 (plist errors conversation mail-p id)
  (let ((c (apply 'find-or-setup-conversation plist)))
    (cond ((eq conversation c)
	   (modify-temporary-sending-feedback conversation plist errors mail-p id))
	  (t
	   ;; conversation went away (m-X Delete Conversation) before the message
	   ;; got sent.
	   (multiple-value-bind (before text)
	       (converse-construct-header-line plist errors mail-p)
	     (send c :add-msg before text id)
	     (must-redisplay *window* dis-text))))
    (when (memq (send *converse-frame* :status) '(:exposed :selected))
      (when (listp errors)
	(converse-error
	  (with-output-to-string (stream)
	    (format-converse-errors-string errors stream)))))))

(defun 2converse-notify-from-background-process0 (errors)
  (when (listp errors)
    ;; don't deal with errors like :receiving-disabled
    
    ;; Would really like to NOTIFY with CONVERSE-FRAME as window-of-interest 
    ;; but then the converse frame ends up in the Function-0-S history
    ;; which seems slightly wrong.
    (tv:notify nil
	       (with-output-to-string (stream)
		 (format stream "From process Sending Message:~&")
		 (format-converse-errors-string errors stream)))))


;;; Puts "Message 1being sent0 to ..." into converse buffer.
(defun 2converse-show-temporary-sending-feedback0 (conversation plist id mail-p)
  (send conversation :add-msg
	(format nil "Message ~'ibeing ~:[sent~;mailed~]~ to ~A (~\TIME\)~%"
		mail-p
		(converse-addresses-string (get (locf plist) :recipients))
		(get (locf plist) :date))
	(get (locf plist) :text)
	id)
  (must-redisplay *window* dis-text))

;;; Changes "Message 1being sent0 to .." to "Message sent to ..."
(defun 2modify-temporary-sending-feedback0 (conversation plist errors mail-p id)
  ;; Assume for now that "feedback" is second message of conversation
  (multiple-value-bind (before text)
      (converse-construct-header-line plist errors mail-p)
    (send conversation :replace-msg id before text id)
    (must-redisplay *window* dis-text)))

;;; Construct the "Message sent to ..." line
(defun 2converse-construct-header-line0 (plist errors mail-p)
  (values
    (with-output-to-string (stream)
      (format stream "Message ~:[not ~]~:[sent~;mailed~] to ~A (~\TIME\)~%"
	      (null errors)
	      mail-p
	      (converse-addresses-string (get (locf plist) :recipients))
	      (get (locf plist) :date))
      (selectq errors
	(:receiving-disabled
	 (format stream "Receiving messages was not enabled.~%"))
	(:services-disabled
	 (format stream "Services were not enabled.~%"))
	(:sending-aborted
	 (format stream "Sending of the message was explicitly aborted."))
	(:no-path-to-service
	 (format stream "SEND service was not supported."))
	(:text-must-be-fat
	 (format stream "Message contains characters which can not be transmitted to one or~@
			 more recipients using the protocols available on their machines."))
	(otherwise
	 (format-converse-errors-string errors stream))))
    (get (locf plist) :text)))

;;; This portion of message-sending always runs inside the Converse process,
;;; even if the message was sent using QSEND, after the sending is complete.
(defun 2converse-send-msg-inside0 (plist errors mail-p)
  (let ((conversation (apply #'find-or-setup-conversation plist)))
    (multiple-value-bind (before text)
	(converse-construct-header-line plist errors mail-p)
      (send conversation :add-msg
	    before text
	    ))
    ;; Note that redisplay is needed.
    (must-redisplay *window* dis-text)
    conversation))

;;; Find the message that point is in.  Return the parsed destination and
;;; the body of the message.
(defun 2converse-get-recipients-and-msg0 ()
  (unless (converse-buffer-good?)
    (converse-error *converse-buffer-munged-message*))
  (let ((conversation (dolist (c *converse-list*)
			(if (send c :line-mine? (bp-line (point))) (return c)))))
    (when (null conversation)
      (converse-error *converse-point-invalid-message*))
    (multiple-value-bind (to-line msg-text)
	(send conversation :get-to-msg)
      (let ((recipients (converse-parse-addresses to-line)))
	(values `(:date ,(time:get-universal-time)
		  :recipients ,recipients
		  :ident ,(or (send conversation :ident) (generate-standard-message-id))
		  :text ,msg-text)
		conversation)))))

(defcom 2com-converse-fill-paragraph0 "Fill (or adjust) this (or next) paragraph.
Point stays the same.  A positive argument means to adjust rather than fill." ()
  (let ((int (converse-paragraph-interval (point))))
    (fill-interval int nil t
		   :adjust (and *numeric-arg-p* (plusp *numeric-arg*))))
  dis-text)

(defvar 2*converse-fill-printed-headers*0 '("To: " "Also-to: ")
  "Words that may begin a printed line that should remain a separate line.")

(defun 2converse-paragraph-interval0 (bp)
  (let* ((first-bp
	   (loop with temp-bp = (loop for ibp first (beg-line bp) then (forward-line ibp 1)
				      while ibp
				      unless (or (line-blank-p (bp-line ibp))
						 (bp-looking-at-list
						   ibp *converse-fill-printed-headers*))
					do (return ibp)
				      finally (return (interval-last-bp *interval*)))
		 for jbp first (beg-line temp-bp) then (forward-line jbp -1)
		 when (or (line-blank-p (bp-line jbp))
			  (bp-looking-at-list jbp *converse-fill-printed-headers*))
		   do (return (forward-line jbp 1))))
	 (last-bp (forward-paragraph first-bp 1 t)))
    (create-interval first-bp last-bp)))

(defcom 2com-converse-hardcopy-buffer0 "Hardcopies the entire converse buffer." ()
  (let* ((title "Converse")
	 (spooler-options `(:title ,title)))
    (lexpr-funcall #'hardcopy-interval
		   (interval-first-bp *interval*)
		   (interval-last-bp *interval*)
		   spooler-options)))

(defcom 2com-converse-bug0 "Report a bug in the system." ()
  (let ((system (typein-line-accept 'string
				    :prompt "Report a bug about system"
				    :default "Converse")))
    (fs:force-user-to-login)
    (dbg:mail-bug-report-1 :process-name "Mail from Report Bug command"
			   :system system))
  dis-none)

(defvar 2*converse-comtab*0)
(defvar 2*converse-control-x-comtab*0)

;;; create a comtab for converse with proper commands
(defun 2init-converse-comtab0 ()
  (setq *converse-control-x-comtab*
	(set-comtab "Converse Control-X"
		    '(#/1 com-one-window
		      #/2 com-two-windows
		      #/3 com-view-two-windows
		      #/^ com-grow-window
		      #/O com-other-window))
	*converse-comtab*
	(set-comtab "Converse"
		    '(#\end com-converse-send
		      #\abort com-converse-abort
		      #\control-end com-converse-send
		      #\help com-converse-help
		      #\control-meta-[ com-converse-previous-conversation
		      #\control-meta-] com-converse-next-conversation
		      #\control-m com-converse-mail-message
		      #\m-q com-converse-fill-paragraph
		      #\c-z :undefined
		      #\m-z :undefined
		      #\c-m-z :undefined
		      )
		    '(("Regenerate Buffer" . com-converse-regenerate-buffer)
		      ("Delete Conversation" . com-converse-delete-conversation)
		      ("Write Buffer" . com-converse-write-buffer)
		      ("Write Conversation" . com-converse-write-conversation)
		      ("Append Buffer" . com-converse-append-buffer)
		      ("Append Conversation" . com-converse-append-conversation)
;		      ("Encrypt Message" . COM-CONVERSE-ENCRYPT-MESSAGE)
;		      ("Decrypt Message" . COM-CONVERSE-DECRYPT-MESSAGE)
		      ("Compile File" . com-zmail-compile-file)
		      ("Load File" . com-zmail-load-file)
		      ("Hardcopy Buffer" . com-converse-hardcopy-buffer)
		      ("Bug" . com-converse-bug)
		      ("Report Bug" . com-converse-bug)
		      )))
  (set-comtab-indirection *converse-comtab* *standard-comtab*)
  (set-comtab-indirection *converse-control-x-comtab* *standard-control-x-comtab*)
  (set-comtab *converse-comtab*
	      (list #\c-x (make-extended-command *converse-control-x-comtab*)))
  (cl:pushnew '*converse-comtab* *zwei-comtabs-for-compression*))



(defflavor 2converse-top-level-editor
0       ((*comtab* *converse-comtab*)
	(*mode-line-list*
	  '("Converse " (*converse-gagged* "[Gagged] ") "(" *mode-name-list* ") "
	     (*style-name* "  Style: " *style-name*)
	     (*converse-end-exits*
	       "    End sends and exits, Abort just exits, Control-End just sends"
	       :else
	       "    End just sends, Abort just exits, Control-End sends and exits")))
	(*post-command-hook* '(converse-post-command-hook)))
       (tv:stream-mixin top-level-editor))

(defmethod 2(:init converse-top-level-editor :after)0 (ignore)
  (set-comtab-indirection *mode-control-x-comtab* *converse-control-x-comtab*))

(defflavor 2converse-frame
0	()
	(converse-top-level-editor converse new-panes-zwei-frame
		;These wouldn't be here at all if there was an activity system.
		;Put them at the end for their daemons, don't let them shadow anything.
	 tv:process-mixin tv:select-mixin)
  (:default-init-plist :process '(converse-window-top-level)
		       :save-bits ':delayed))

(defun 2converse-window-top-level0 (*converse-frame*)
  (declare (dbg:bug-report-recipient-system "Converse"))
1  ;; Must have a bit array before trying to do anything, so that we can type messages
  ;; onto the typein-line with the frame deexposed, and because of the usual sort
  ;; of window-system selection bugs with 2:start-delayed-select1.
0  (when (eq (send *converse-frame* :save-bits) :delayed)
    (send *converse-frame* :set-save-bits t))
  (when (typep tv:selected-window 'editor-typeout-window)
    (send tv:selected-window :make-complete))
  (send *converse-frame* :edit)
  (send *converse-frame* :exit))

(defmethod 2(:exit converse-top-level-editor)0 ()
  (send (window-frame *window*) ':bury)
  (si:process-wait-forever))

;This would be in (CONVERSE-FRAME :AFTER :INIT) but it needs to happen before
;(EDITOR :AFTER :INIT).
(defmethod 2(:init converse :after)0 (ignore)
  (setq *window* (send self ':create-new-pane ':expose-p t)))

(defmethod 2(:init converse-frame :after)0 (ignore)
  (let ((*enable-change-recording* nil))
    (insert (interval-last-bp *interval*) #\cr)
    ;; make a headerless To: line conversation
    (let ((c (make-instance 'conver ':with-header-p nil
			    ':after-line (bp-line (interval-first-bp *interval*))
			    ':before-line (bp-line (interval-last-bp *interval*)))))
      ;; create the conversation list
      (setq *converse-list* (list c)))
    (move-bp (point) (end-line (interval-first-bp *interval*)))
    (turn-on-mode 'text-mode)))

(defmethod 2(:create-new-pane converse-frame)0 (&rest args)
  (let ((window (lexpr-send self :create-window 'zwei-window-pane
				 :name "Converse"
				 :margin-components 'dw:((margin-ragged-borders :thickness 1)
							 (margin-white-borders )
							 ;; No :VISIBILITY :IF-REQUESTED,
							 ;;  assume interval is small enough
							 ;;  to display.
							 (margin-scroll-bar :history-noun "conversations"))
			    args)))
    (unless *converse-node*
      (setq *converse-node* (create-interval nil nil 'top-level-node)))
    (set-window-interval window *converse-node*)
    window))

(defmethod 2(:update-labels converse-frame)0 () )

(defmethod 2(:regenerate converse-frame)0 ()
  (regen-converse-buffer))
    
(compile-flavor-methods conver converse-header-diagram converse-line-diagram
			converse-frame)

;;; initialize the command loop and window for converse
(defun 2initialize-converse-command-loop0 ()
  (init-converse-comtab)
  (tv:add-select-key #/C 'zwei:converse-frame "Converse" t)
  (tv:make-window 'converse-frame ':activate-p t)	;Make there be one around
  )

(add-initialization "Start Converse" '(initialize-converse-command-loop) ()
		    '*zmail-system-initializations*)



;;;; User interface outside of converse (mainly the old QSEND command).

(defmacro 2qsend0 (&optional destination message)
  `(qsend-msg ',destination ',message))

(defun 2qsend-msg0 (&optional destination msg)
  (if (null destination)
      (send (find-converse-window) ':select)
      (condition-case (error)
	  (qsend-msg-simple ':recipients (converse-parse-addresses (string destination))
			    ':text (and msg (string msg)))
	(barf (format t "~&~A" error)))))

(defun 2converse-notify0 (format-control &rest format-args)
  1;; If warnings are coming from the background process, turn them into notifications.
0  (let ((real-query-io (si:follow-syn-stream query-io)))
    (cond ((eq real-query-io 'tv:background-stream)
	   (tv:notify nil "From process Sending Message:~&~?" format-control format-args))
	  ((eq real-query-io (and (variable-boundp *typein-window*) *typein-window*))
	   (cl:apply 'typein-line format-control format-args))
	  (t
	   (cl:apply 'format query-io format-control format-args)))))

(defun 2find-converse-window0 ()
  (let ((frame (cli::find-frame-for-activity nil nil
					     #'(lambda (window)
						 (typep window 'converse-frame))
					     #'(lambda (&rest init-options)
						 (cl:apply #'tv:make-window 'converse-frame
									    :activate-p t
									    init-options))
					     :selected-ok t)))
    (unless (tv:sheet-exposed-p frame)
      (tv:set-window-on-usable-screen frame))
    (tv:maybe-reset-window-process frame (send frame :process) :select t)
    frame))

1;;; Checks that it's possible to send a message --
;;;    Verifies that the user can receive a reply.
;;;    Verifies that there's a path for 0SEND1 service to all recipients.
;;;    Also, if the message contains characters that must be fat (e.g., non-standard
;;;       character sets), verifies that the protocol to be used to send the message
;;;       to each recipient can handle fat characters.
0(defun 2converse-ensure-msg-can-be-sent0 (&key recipients text &allow-other-keys)
  1;; Sets things up so a message can be sent.  Returns NIL if everything is
  ;; ok, otherwise returns some state information.
0  (block send-msg
    (fs:force-user-to-login)
    (when *converse-gagged*
      (converse-notify
	      "~&Warning:  Receiving messages is currently disabled~:[.~;:  ~A~]"
	      (stringp *converse-gagged*) *converse-gagged*)
      (selectq (fquery '(:choices
			  (((t "Yes.") #/Y #\space)
			   ((nil "No.") #/N #\rubout)
			   ((enable "Enable receiving messages.") #/E))
			  :beep t)
		       "Do you still want to send the message? " )
	(enable (setq *converse-gagged* nil))
	(nil (return-from send-msg :receiving-disabled))))
    (when (not (or (neti:service-enabled-p :send)
		   (neti:service-enabled-p :converse)))
      (converse-notify
	      "~&Warning:  Send and Converse services are currently disabled.~@
	       Unless you enable them, you will not be able to receive replies.")
      (selectq (fquery '(:choices
			  (((t "Yes.") #/Y #\space)
			   ((nil "No.") #/N #\rubout)
			   ((enable "Enable network servers.") #/E))
			  :beep t)
		       "Do you still want to send the message? ")
	(enable (net:enable-services '(:converse :send)))
	(nil (return-from send-msg :services-disabled))))
    (let ((text-must-be-fat
	    (and text
		 (using-resource (encoding-stream si:epsilon-encoding-output-stream nil
						  :flavor 'zmail-msg-saving-stream
						  :dumping-fat t)
		   (multiple-value-bind (character-type-mappings diagrams-present)
		       (compute-interval-character-type-mappings (text-as-interval
								   (string-thin
								     (text-as-string text)))
								 nil t encoding-stream)
		     (or character-type-mappings diagrams-present))))))
      (loop for recipient in recipients
	    as host = (second (get (locf recipient) :host))
	    as path = (condition-bind
			  ((net:host-does-not-support-service
			     #'neti:host-does-not-support-protocol-specify-path-handler))
			(net:find-path-to-service-on-host :send host))
	    when (null path)
	      do (return-from send-msg :no-path-to-service)
	    unless (or (not text-must-be-fat)
		       1;; (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")Kludge alert!1 --
		       ;;    Builtin knowledge of which protocols can handle fat characters.
0		       (memq (neti:protocol-name (neti:service-access-path-protocol path))
			     '(:converse :smtp)))
	      do (return-from send-msg :text-must-be-fat)))))

;; Most errors returned by SEND-MSG report as complete sentences in their own right.  Let
;; them stand by themselves rather than merging them into our own sentence.
(defun 2qsend-msg-simple0 (&key recipients text ident)
  (fs:force-user-to-login)
  (when (null text)
    (setq text (qsend-get-message recipients)))
  (setq text (string text))			;(qreply 't), etc.
  (when (null ident)
    (setq ident (generate-standard-message-id)))
  (let* ((plist `(:recipients ,recipients :text ,text :ident ,ident
		  :date ,(time:get-universal-time)))  )
    (let ((errors
	    (cl:apply #'converse-ensure-msg-can-be-sent plist)))
    (let ((cf (find-converse-window)))
      (send cf :enter-request 'converse-send-msg
	    :mail-p nil :plist plist :errors errors)))))

;;; This exists just to have a separate history, so that long strings don't end up
;;; in the string history.
(scl:define-presentation-type 2message-string0 ()
  :expander 'string
  :history t)

1;; This function is also called by 2chaos:notify-local-lispms1 and friends.
0(defun 2qsend-get-message0 (recipients &optional (stream standard-input) prompt)
  (prog1
    (scl:accept 'message-string
		:stream stream
		:default nil
		:prompt (format nil
				"~:[To: ~A~;~:*~A~]~%Message: (terminate with ”)~%"
				prompt
				(if (stringp recipients)
				    recipients
				    (converse-addresses-string recipients)))
		:prompt-mode :raw
		:activation-chars '(#\end #\c-end))
    (cl:write-string "[End]" stream)))

(defvar 2*saved-sends*0 nil)
(defvar 2*last-recipients*0 nil)
(defvar 2*last-ident*0 nil)

(defun 2print-sends0 (&optional (stream standard-output))
  (loop for (nil msg) in (reverse *saved-sends*)
	do (format stream "~&~A~%~%" msg)))

(defun 2qreply 0(&optional text)
  (let ((recipients *last-recipients*)
	(ident *last-ident*))			;Avoid timing confusion
    (when (null recipients)
      (ferror "There is no one to reply to"))
    (format error-output "~&Replying to ~A:"
	    (converse-addresses-string recipients))
    (condition-case (error)
	 (qsend-msg-simple :recipients (converse-canonicalize-addresses recipients)
			   :ident ident :text text)
       (barf (format t "~&~A" error)))))



;;;; Network stuff

;;; When a msg comes in, this is called to put it in the buffer, inside the converse
;;; process.
(defun 2converse-receive-msg0 (&rest args &key from text date &allow-other-keys)
  (let ((converse-is-showing
	  ;; Is the Converse window visible on the screen?
	  (memq (send *converse-frame* :status) '(:exposed :selected)))
	(conversation (apply #'find-or-setup-conversation args)))
    ;; Add the message to the conversation
    (send conversation :add-msg nil text)
    ;; Set up the point for easy reply, unless it's in the middle of inputting a message.
    (cond ((and converse-is-showing
		(dolist (c *converse-list*)
		  (and (send c :line-mine? (bp-line (point)))
		       (return (send c :bp-in-partial-msg (point)))))))
	  (*converse-append-p*
	   (move-bp (point) (create-bp (send conversation :last-line) 0)))
	  (t (move-bp (point) (send conversation :after-to-line-bp))))
    ;; Note that redisplay is needed.
    (must-redisplay *window* dis-text)
    ;; Run the pop-up window if desired
    (when (and (not converse-is-showing) (eq *converse-mode* :pop-up))
      (apply #'converse-pop-up-receiver args))
    ;; Type this message on the Converse window.  It may not be exposed, but if
    ;; not, it will be seen the next time the window IS exposed.
    (typein-line-durable "Latest message from ~A at ~\TIME\"
			 (converse-address-string from) date)))

(defun 2converse-pop-up-receiver0 (&key recipients ident from encrypted text &allow-other-keys)
  (let ((converse-flag nil))
    (using-resource (window dw:dynamic-window tv:default-screen :temporary-p t :blinker-p t)
      (multiple-value-bind (left top right bottom) (send tv:default-screen :inside-edges)
	(send window :set-edges left top right (min bottom (+ top 400.))))
      (send window :set-label "Incoming Message")
      (send window :set-more-p t)
      (tv:window-mouse-call (window :deactivate)
	(let ((terminal-io window)
	      (query-io window))
	  (block query
	    (format window "~&Message from ~A:~%" (converse-address-string from))
	    (if (not encrypted)
		(send window :string-out (text-as-string text))
	      (selectq (fquery '(:choices (((decrypt "Decrypt.") #/D)
					   ((converse "Enter Converse.") #/C)
					   ((nothing "Nothing.") #/N #\rubout))
				 :clear-input t
				 :status :exposed)
			       "Text is encrypted.  Action? ")
		((nothing :status)
		 (return-from query nil))
		(converse
		 (return-from query (setq converse-flag t)))
		(decrypt
		 (let ((*typein-window* window))
		   (funcall (get encrypted 'decrypt-interval) window (text-as-interval text)))
		 )))
	    (selectq (fquery '(:choices (((reply "Reply.") #/R #\sp #/T #/Y)
					 ((converse "Enter Converse.") #/C)
					 ((nothing "Nothing.") #/N #\rubout))
			       :clear-input t
			       :status :exposed)
			     "Action? ")
	      ((nothing :status))
	      (reply
	       (let ((real-recipients (converse-verify-recipients (or recipients
								      (list from)))))
		 (condition-case (error)
		      (qsend-msg-simple :recipients real-recipients :ident ident)
		    (barf
		      (format t "~&~A~%Type any character when done: " error)
		      (send terminal-io :tyi)))))
	      (converse
	       (setq converse-flag t)))))))
    (when converse-flag
      (send *converse-frame* :select))))

(defun 2converse-verify-recipients0 (recipients)
  (cl:loop
     (condition-case (error)
	  (return (if (stringp recipients)
		      (converse-parse-addresses recipients)
		    (converse-canonicalize-addresses recipients)))
	(barf
	  (beep)
	  (format t "~&~A" error)
	  (setq recipients (scl:accept 'string :stream standard-input
					       :prompt "To"
					       :provide-default nil))))))



;;; Parse the destination(s) from the user's typein
(defun 2converse-parse-addresses0 (string)
  (let ((list (barf-on-errors (parse-error)
		(let ((*allow-namespace-server-parsing-host* t))
		  (parse-addresses string)))))
    (when (null list)
      (barf "Message isn't being sent to anyone."))
    (converse-canonicalize-addresses list)))

(defun 2converse-canonicalize-addresses0 (addresses)
  (loop	for address in addresses
	do (let ((host (cl:getf address :host)))
	     (cond ((null host)
		    (let ((host-object (decide-host (cl:getf address :name))))
		      (if host-object
			  (setf (cl:getf address :host) `(:object ,host-object))
			(barf "No host given; nowhere to send message."))))
		   ((eq (first host) :domain)
		    (let* ((host-name (format nil "~A~{.~A~}" (second host) (rest2 host)))
			   (host-object (neti:parse-host host-name t)))
		      (if host-object
			  (setf (cl:getf address :host) `(:object ,host-object))
			(barf "~A is not the name of a known host." host-name))))
		   ((neq (first host) :object)
		    (barf "~A is not the name of a known host." (second host)))))
	collect address))

(defun 2decide-host0 (user)
  (let ((items (neti:find-lispms-returning-info-logged-in-as-user user)))
    (cond ((null items)
	   (converse-error "I could not find /"~A/" logged into any host." user))
	  ((null (cdr items)) (caar items))
	  (t
	   (tv:menu-choose
	     (loop for item in items
		   collect (destructuring-bind (host id location idle-time personal-name)
					       item
			     (cons (format nil "~A: ~A~:[~*~; (Idle for ~A)~] ~A"
					   host
					   (cond ((plusp (string-length personal-name))
						  personal-name)
						 ((plusp (string-length id))
						  id)
						 (t user))
					   (plusp (string-length idle-time))
					   idle-time
					   location)
				   host)))
	     "Choose a host for outgoing message")))))



;;; Guts of SEND protocol

;;; Defined earlier than expected necessary to avoid compilation warnings.
(defflavor 2remote-converse-error0 (string to) (sys:network-error)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod 2(:report remote-converse-error)0 (stream)
  (send stream ':string-out string))

;; CONVERSE-ERROR is called for errors which can occur in either Converse or Qsend.
;; BARF is called for errors which can occur only in Converse.
(deff 2converse-error0 'barf)

;;; 1Sends a message -- Returns a list of recipients and corresponding error objects.
0(defun 2send-msg0 (&key recipients from text ident date)
  (block send-msg
    (when (null date)
      (setq date (time:get-universal-time)))
    (when (null from)
      (setq from `(:name ,user-id :host (:object ,neti:*local-host*))))
    (tv:noting-progress-alterable-note ()
      (loop for recipient in recipients
	    with neti:*invoke-service-automatic-retry* = t
	    do (tv:format-progress-note nil "Sending message to ~A."
					(converse-address-string recipient
								 :retain-common-tails t))
	    as host = (second (get (locf recipient) :host))
	    as error = (labels ((retry-if-character-type-problem (.error.)
				  (when (string-search "CHARACTER-TYPE-MAPPINGS"
						       (remote-converse-error-string .error.))
				    (throw 'retried-sending
				      (prog1
					(net:invoke-service-on-host
					  :send host
					  :from from :to recipient
					  :ident ident
					  :recipients recipients
					  :date date
					  :text (condition-case ()
						     (string-thin (text-as-string text)
								  :error-if :fat)
						   (error
						     (error 'remote-converse-error
							    :string (format nil
									    "Message contains ~
									     characters that ~
									     can not be ~
									     sent to ~A"
									    (send host
										  :mail-name))
							    :to (remote-converse-error-to
								  .error.)))))
					(converse-notify "Warning for ~A: ~
							  Removed character style information ~
							  from your message.~%"
							 (converse-address-string
							   (remote-converse-error-to .error.)))
					)))))
			 (condition-case (error)
			      (condition-bind
				  ((net:host-does-not-support-service
				     #'neti:host-does-not-support-protocol-specify-path-handler
				     )
				   (remote-converse-error #'retry-if-character-type-problem))
				(catch 'retried-sending
				  (net:invoke-service-on-host :send host
							      :from from :to recipient
							      :ident ident
							      :recipients recipients
							      :date date :text text)))
			    (sys:network-error
			      error)
			    (:no-error nil)))
	    when error
	      collect (list error recipient)))))



;;; Generic Converse support for all protocols.

1;;; If 2private1 is non-null, the user names must match.
0(defun 2converse-reject-message-p0 (to &optional private)
  (let ((user-name (send si:*user* :lispm-name)))
    (cond ((neti:ns-eq si:*user* si:*not-logged-in-user*)
	   "No user is logged in.")
	  ((and private
		(not (string-equal user-name
				   (cond ((stringp to) to)
					 ((cl:getf to :name))
					 ((cl:getf to :user)
					  (send (cl:getf to :user) :lispm-name))
					 (t "")))))
	   (format nil "Machine is logged in as ~A." user-name))
	  (*converse-gagged*
	   (if (stringp *converse-gagged*)
	       *converse-gagged*
	     (format nil "~A is not accepting messages." user-name)))
	  (t nil))))

;;; Subroutine that beeps when message comes in.
;;; Gets called with all sorts of interesting keyword arguments
;;; (All the args to PROCESS-INCOMING-MESSAGE.)  For now, just beeps.
(defun 2converse-beep0 (&rest ignored)
  (dotimes (ignore *converse-beep-count*) (beep)))

1;;; Entry from the network servers --
;;;    2date1, 2text1, and 2from1 are mandatory.  2recipients1 will be deduced from 2from1 if not given.
;;;    2ident1 is ignored if not given.
0(defun 2converse-process-incoming-message0 (&rest args
					  &key date from recipients ident
					  private encrypted notification text)
  (ignore private)
  (if notification
      1;; Not really a conversation, just notify.
0      (tv:notify nil "Message received from ~A ~\TIME\~%~A"
		 (converse-address-string from)
		 date
		 (string-right-trim '(#\cr #\sp) (text-as-string text)))
    (push (list date text) *saved-sends*)
    (setq *last-recipients* (or recipients (list from))
	  *last-ident* ident)
    1;; Set mode for people using the old variables.
0    (cond (*converse-notify-with-message*
	   (setq *converse-mode* :notify-with-message
		 *converse-notify-with-message* nil
		 *converse-auto-expose-p* t))
	  ((null *converse-auto-expose-p*)
	   (setq *converse-mode* :notify
		 *converse-notify-with-message* nil
		 *converse-auto-expose-p* t)))
    1;; Present the message to the user.
0    (let* ((converse-frame (find-converse-window))
	   (converse-is-showing
	     1;; Is the Converse window visible on the screen?
0	     (memq (send converse-frame :status) '(:exposed :selected)))
	   (need-converse-process nil))
      1;; Beep now so user knows a message is coming.
0      (when (or converse-is-showing (memq *converse-mode* '(:pop-up :auto)))
	(cl:apply 'converse-beep args))
      (lexpr-send converse-frame :enter-request 'converse-receive-msg args)
      (if converse-is-showing
	  (setq need-converse-process t)
	1;; The Converse window is not exposed -- Tell the user in his favorite way.
0	(selectq *converse-mode*
	  (:auto
	   (send converse-frame :mouse-select)
	   (setq need-converse-process t))
	  (:notify
	   1;; Don't specify 2converse-frame1 as the window-of-interest.  It only
0	   1;; makes the notification longer and after all 0Select-C1 is one less
0	   1;; keystroke than 0Function-0-S1.
0	   (tv:notify nil "Message received from ~A" (converse-address-string from)))
	  (:pop-up
	   1;; Pop-up mode is done in the converse process so that only one message
0	   1;; pops up at a time.
0	   (setq need-converse-process t))
	  (otherwise
	   1;; 2:notify-with-message 1or garbage -- See 2:notify1 above.
0	   (if encrypted
	       (tv:notify nil "Encrypted message received from ~A."
			  (converse-address-string from))
	     (tv:notify nil "Message received from ~A:~%~A"
			(converse-address-string from)
			(string-right-trim '(#\cr #\sp) (text-as-string text)))))))
      (when (and need-converse-process
		 (not (process-wait-with-timeout "Converse wakeup" 1000.
			#'(lambda (frame)
			    (null (send frame :pending-requests)))
			converse-frame)))
	(tv:notify nil "You have a pending message from ~A"
		   (converse-address-string from))))))



;;;; Chaos SEND protocol

;;; User side.

;; If the other side refuses the connection we map into this error so that higher
;; levels, seeing a connection error, won't just retry over a different path.

(defflavor 2chaos-send-refused0 (service-access-path contained-error) (sys:network-error)
  :initable-instance-variables)

(defmethod 2(:report chaos-send-refused)0 (stream)
  (send contained-error ':report stream))

(chaos:define-chaos-protocol 2:send0 (:send :byte-stream)
  (:desirability .75)
  (:chaos-contact-name (base-contact-name service)
   (string-append base-contact-name #\sp
		  (let ((to (get (locf (neti:service-access-path-args service)) :to)))
		    (get (locf to) :name))))
  (:invoke (service)
   (let ((plist (locf (neti:service-access-path-args service))))
     (condition-case (error)
	 (with-open-stream (stream (net:get-connection-for-service service))
	   (format stream "~A ~\TIME\~%"
		   (converse-address-string (get plist :from) :retain-common-tails t)
		   (get plist :date))
	   (let ((recipients (get plist :recipients)))
	     (when (cdr recipients)
	       (format stream "Also-to: ~A~%"
		       (converse-addresses-string (remq (get plist :to) recipients)
						  :retain-common-tails t))))
	   (send stream :string-out (string-thin (text-as-string (get plist :text))
						 :remove-bits t)))
       (sys:connection-refused
	 (error 'chaos-send-refused
		:service-access-path service :contained-error error))))))

1;;; Server side.
0(net:define-server 2:send0 (:medium :byte-stream :reject-unless-trusted nil
			  :stream (stream :direction :input :accept-p nil))
   (declare (dbg:bug-report-recipient-system "Converse"))
   (let (host fline to sender text tem)
     (with-open-stream (stream stream)
       (multiple-value-bind (array start end)
	   (send stream :read-input-buffer)
	 (let ((to-start (+ start 5)))
	   (setq to (if ( to-start end)
			"<<No recipient specified>>"
			(substring array to-start end))))
	 (send stream :advance-input-buffer))
       (let ((reject-reason (converse-reject-message-p to)))
	 (if reject-reason
	     (send stream :reject reject-reason)
	   (send stream :accept)		1;Accept before possible namespace server query.
0	   (setq host (send stream :foreign-host))
	   (setq fline (send stream :line-in))
	   (cond ((setq tem (string-search-char #/@ fline))
		  (setq sender (substring fline 0 tem)))
		 ((setq tem (string-search "from " fline))
		  (setq sender (substring fline (+ tem 5)
					  (string-search-set '(#/] #\sp) fline (+ tem 5)))))
		 (t
		  (setq sender "")))
	   (setq sender `(:name ,sender :host (:object ,host)))
	   (setq text (with-output-to-string (sstream)
			(send sstream :line-out fline)
			(when (not (string-equal user-id to))
			  (format sstream "To: ~A~%" to))
			(stream-copy-until-eof stream sstream)))
	   (converse-process-incoming-message :date (time:get-universal-time) :from sender
					      :text text)
	   1;; Try to make sure that a reply will work.
0	   (unless (assq :send (send host :network-services))
	     (push '(:send :chaos :send) (send host :get :service))))))))



;;; New CONVERSE protocol

(chaos:add-contact-name-for-protocol :converse)

(net:define-server 2:converse0 (:medium :byte-stream :stream stream :host host :no-eof t
				      :reject-unless-trusted nil)
   (declare (dbg:bug-report-recipient-system "Converse"))
   (block server
     (let ((*allow-namespace-server-parsing-host* t)
	   date from to also ident private encrypted notification fonts character-type-mappings
	   text error-p)
       (condition-case (error)
	    (loop as line = (send stream :line-in)
		  until (equal line "")
		  do (let* ((idx (string-search-char #\sp line))
			    (key (intern (string-upcase (substring line 0
								   (prog1 idx (incf idx))))
					 pkg-keyword-package)))
		       (selectq key
			 (:date (setq date (time:parse-universal-time line idx)))
			 (:from (setq from (parse-one-address line idx)))
			 (:to (setq to (let ((address (parse-one-address line idx)))
					 (get (locf address) :name))))
			 (:also (push (parse-one-address line idx) also))
			 (:ident (setq ident (substring line idx)))
			 (:private (setq private (string-equal line "YES" idx)))
			 (:encrypted (setq encrypted (intern (substring line idx)
							     pkg-keyword-package)))
			 (:notification (setq notification (string-equal line "YES" idx)))
			 (:character-type-mappings
			  (setq character-type-mappings (condition-bind
							    ((sys:external-symbol-not-found
							       #'(lambda (condition)
								   (sys:proceed condition
										:internal))))
							  (parse-lisp-expressions line idx))))
			 (:fonts (setq fonts (parse-comma-separated line idx)))
			 (otherwise
			  (ferror "/"~A/" is not a recognized CONVERSE message property" key)))
		       ))
	  (sys:network-error
1	    ;; Connection closed while reading message properties, probably because the other
	    ;; end timed out on our accepting the connection and is now retrying via an
	    ;; alternate path.  Croak immediately, without trying to send back a message.
0	    (return-from server nil))
	  (error
	    (format stream "-Parsing or syntax error: ~A~%" error)
	    (setq error-p t))
	  (:no-error
	    (let ((message (converse-reject-message-p to private)))
	      (cond (message
		     (format stream "-~A~%" message)
		     (setq error-p t))
		    ((not (string-equal user-id to))
		     (format stream "%Message will be delivered to ~A.~%" user-id))
		    (t
		     (format stream "+Proceed with message.~%"))))))
       (send stream :force-output)
       (unless error-p
	 (when (null date)
	   (setq date (time:get-universal-time)))
	 (setq also (nreverse also))
	 (setq text (with-output-to-string (sstream)
		      (when (let ((claimed-host (get (locf from) :host)))
			      (cond ((null claimed-host)
				     (putprop (locf from) `(:object ,host) :host)
				     nil)
				    ((not (and (eq (car claimed-host) :object)
					       (eq (cadr claimed-host) host)))
				     t)))
			(format sstream "Received-from-host: ~A~%" host))
		      (unless notification
			(format sstream "~A ~\TIME\~%" (converse-address-string from) date))
		      (when (not (string-equal user-id to))
			(format sstream "To: ~A~%" to))
		      (when also
			(format sstream "Also-to: ~A~%" (converse-addresses-string also)))
		      (stream-copy-until-eof stream sstream)))
	 (when (or character-type-mappings fonts)
1	   ;; Process  encodings in the text.
0	   (unless character-type-mappings
1	     ;; No Character-Type-Mappings supplied but there are fonts -- Backtranslate.
0	     (setq character-type-mappings (compute-character-type-mappings-from-fonts fonts)))
	   (when character-type-mappings
1	     ;; We've got some character type mappings -- Convert the text as well as possible.
0	     (with-zmail-epsilon-decoding-handlers
		 ()
		 (ignore)
	       (let ((converting-interval (create-interval text)))
		 (font-convert-lines-interval character-type-mappings converting-interval)
		 (setq text converting-interval)))))
	 (converse-process-incoming-message :date date :from from
					    :recipients (cons from also) :ident ident
					    :private private :notification notification
					    :encrypted encrypted
					    :text text)
	 (format stream "+Message delivered.~%"))
       (condition-case ()
	    (send stream :finish)
1	  ;; Ingore any errors while sending the "+Message delivered" in case the user at the
	  ;; other end punted the connection.
0	  (sys:network-error)))))

(net:define-protocol 2:converse0 (:send :byte-stream)
  (:invoke-with-stream (stream &key date from to recipients
				    ident private encrypted notification text timeout)
   (neti:with-stream-timeout (stream :io timeout)
     (multiple-value-bind (seconds minutes hours day month year nil daylight-savings-p)
	 (time:decode-universal-time date)
       (format stream "DATE ~D ~A ~D ~2,'0D:~2,'0D:~2,'0D~A~%"
	       day (time:month-string month :short) year
	       hours minutes seconds
	       (time:punctuated-timezone-string time:*timezone* daylight-savings-p)))
     (format stream "FROM ~A~%" (converse-address-string from :retain-common-tails t))
     (format stream "TO ~A~%" (converse-address-string to :retain-common-tails t))
     (dolist (rcpt recipients)
       (unless (eq rcpt to)
	 (format stream "ALSO ~A~%" (converse-address-string rcpt :retain-common-tails t))))
     (when ident
       (format stream "IDENT ~A~%" ident))
     (when private
       (format stream "PRIVATE YES~%"))
     (when encrypted
       (format stream "ENCRYPTED ~A~%" encrypted))
     (when notification
       (format stream "NOTIFICATION YES~%"))
     (using-resource (encoding-stream
		       si:epsilon-encoding-output-stream stream
							 :flavor 'zmail-msg-saving-stream
							 :dumping-fat t)
       (let ((text-interval (text-as-interval text)))
	 (multiple-value-bind (raw-character-type-mappings diagrams-present)
	     (compute-interval-character-type-mappings text-interval nil nil encoding-stream)
	   (let* ((character-type-mappings (or raw-character-type-mappings
					       (when diagrams-present
						 (list (character-type-mapping-for-type-0)))))
		  (fonts (fonts-from-character-type-mappings nil character-type-mappings)))
	     (when character-type-mappings
	       (format stream "CHARACTER-TYPE-MAPPINGS ~{~S ~}~%" character-type-mappings)
	       (format stream "FONTS ~A~{, ~A~}~%" (first fonts) (rest1 fonts)))
	     (send stream :tyo #\cr)
	     (send stream :force-output)
	     (converse-check-response stream to)
	     (if (null character-type-mappings)
		 (send stream :string-out (text-as-string text))
	       (stream-copy-until-eof (open-interval-stream text-interval) encoding-stream))
	     (send stream :eof)))))
     (converse-check-response stream to)
     (close stream :abort))))

(defun 2converse-check-response0 (stream to)
  (let ((line (send stream :line-in)))
    (selector (aref line 0) char-equal
      (#/+ t)
      (#/- (error 'remote-converse-error :string (substring line 1) :to to))
      (#/% (converse-notify "Warning for ~A: ~A~%"
		   (converse-address-string to) (substring line 1)))
      (otherwise (error 'remote-converse-error :string line :to to)))))

(defun 2converse-address-string0 (recipient
				&key ((:retain-common-tails *retain-common-tails*)))
  (string-from-header recipient :short))

(defun 2converse-addresses-string0 (addresses
				  &key ((:retain-common-tails *retain-common-tails*)))
  (with-output-to-string (string)
    (loop for address in addresses
	  for first = t then nil
	  when (not first)
	    do (cl:write-string ", " string)
	  do (cl:write-string (string-from-header address :short) string))))



(cp:define-command (2com-send-converse-message0 :name "Send Message"
					      :command-table "Conversation"
					      :provide-output-destination-keyword nil)
    ((addresses '((cl:sequence address))
		:prompt "recipient"
		:default *last-recipients*
		:documentation "Recipient(s) of interactive message"))
   (fs:force-user-to-login)
   (condition-case (.error.)
	(qsend-msg-simple :recipients (converse-canonicalize-addresses addresses))
      (barf
	(format cl:*error-output* "~&~A" .error.))))



(defvar *show-messages-indentation* 2.)

(cp:define-command (com-show-messages :command-table "Conversation")
    (&key 
      (direction '((cl:member :incoming :outgoing :all :default))
		 :default :default
		 :documentation
		 "Whether to show incoming messages, outgoing messages, or all.")
      (from '((scl:sequence zwei:address))
	    :default nil)
      (recent 'sys:boolean
	      :default nil
	      :mentioned-default t
	      :documentation "Whether to consider only the most recently exchanged messages.")
      (mention-empty-sequences
	'((scl:alist-member :alist (("Yes" . t) ("No" . nil) ("Default" . :default))))
	:default :default
	:mentioned-default t
	:documentation
	"Whether to mention empty message sequences, etc.")
      (order '(scl:member :forward :reverse)
	    :default :forward
	    :documentation "How to order the message presentation.")
      (query '((scl:alist-member :alist (("Yes" . t) ("No" . nil) ("Default" . :default))))
	     :default :default
	     :mentioned-default t
	     :documentation "Whether to ask about each conversation.")
      (start '((cl:integer 1) :description "message number")
	     :default 1
	     :documentation "Number of first message to show.")
      (to '((scl:sequence zwei:address))
	    :default nil)
      (stop '((cl:integer 0) :description "message number")
	    :default nil
	    :provide-default nil
	    :documentation "Number of last message to show.")
      (summarize 'sys:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "If yes, messages are mentioned but not shown."))
   (unless start (setq start 0))
   (let ((people (append from to))
	 (range (cond ((and (= start 1) (not stop)) nil)
		      ((= start 1) (format nil "1-~D" stop))
		      ((not stop) (format nil "~D onward" start))
		      (t (format nil "~D-~D" start stop)))))
     (flet ((network-address-match (test address)
	      (and (string-equal (cl:getf test :name) (cl:getf address :name))
		   (let ((host (cl:getf test :host)))
		     (cond ((not host) t)
			   (t
			    (equal host (cl:getf address :host))))))))
       (when (eq query :default) (setq query (if (or from to recent) nil t)))
       (when (eq mention-empty-sequences :default)
	 (setq mention-empty-sequences (if (or from to summarize) t nil)))
       (when (eq query t)
	 (setq summarize nil))	;QUERY=T and SUMMARIZE=T is meaningless combination
       (dolist (screen tv:all-the-screens)
	 (dolist (window (send screen :inferiors))
	   (when (typep window 'zwei:converse-frame)
	     (dolist (conversation (sys:symeval-in-instance window 'zwei:*converse-list*))
	       (let ((recipients (send conversation :recipients)))
		 (when (or (equal people nil)
			   (cl:some #'(lambda (f)
					(cl:find f recipients :test #'network-address-match))
				    people))
		   (let ((incoming
			   (if (neq direction :default)
			       (cl:member direction '(:incoming :all))
			       (if (null people)
				   t
				   (cl:some #'(lambda (name)
						(cl:find name recipients
							 :test #'network-address-match))
					    from))))
			 (outgoing
			   (if (neq direction :default)
			       (cl:member direction '(:outgoing :all))
			       (if (null people)
				   nil
				   (cl:some #'(lambda (name)
						(cl:find name recipients
							 :test #'network-address-match))
					    to)))))
		     (let ((msgs (do ((m (let ((oldmsgs (send conversation :oldmsgs)))
					   ;; Normalize to backward order to begin with.
					   ;; This makes `recent' processing easier.
					   (if (send conversation :append-mode)
					       (reverse oldmsgs)
					       oldmsgs))
					 (cdr m))
				      (incoming-seen     nil)
				      (outgoing-seen     nil)
				      (current-direction nil)
				      (viewing-old       nil)
				      (r '()))
				     ((or (null m) (and recent viewing-old))
				      ;; Messages in the sequence were pre-reversed.
				      ;; This loop has already reversed the message order.
				      ;; Therefore, at this point, the messages are in
				      ;; forward order.
				      (setq r (if (eq order :forward) r (nreverse r)))
				      (let ((length-r (length r)))
					(setq r
					      (cl:subseq r
							 (min (- start 1) length-r)
							 (if stop (min stop length-r)))))
				      r)
				   (cond ((caar m)
					  (when (and incoming-seen outgoing-seen
						     (neq current-direction :outgoing))
					    (setq viewing-old t))
					  (setq outgoing-seen t)
					  (setq current-direction :outgoing))
					 (t
					  (when (and incoming-seen outgoing-seen
						     (neq current-direction :incoming))
					    (setq viewing-old t))
					  (setq incoming-seen t)
					  (setq current-direction :incoming)))
				   (when (or (not viewing-old) (not recent))
				     (when (if (caar m) outgoing incoming)
				       (push (car m) r)))))
			   (descriptor (with-output-to-string (str)
					 (when range
					   (format str "~A " range))
					 (princ (cond ((and incoming outgoing) "from//to ")
						      (incoming "from ")
						      (t "to "))
						str)
					 (zwei:print-address-list recipients str))))
		       (when recipients
			 (cond ((not msgs)
				(when mention-empty-sequences
				  (format t "~&~'iNo~:[~; recent~] messages ~A.~~%"
					  recent descriptor)))
			       ((if query
				    (cl:y-or-n-p "Show ~:[~;recent ~]messages ~A? "
						 recent descriptor)
				    (progn (format t "~&~'i~:[M~;Recent m~]essages ~A.~~%"
						   recent descriptor)
					   t))
				(unless summarize
				  (format t "~2&")
				  (dolist (datum msgs)
				    (let ((marker  (car  datum))
					  (message (cadr datum)))
				      (when (typep message 'node)
					;; Converse puts in nodes, but
					;; CP command Send Message puts in strings!
					(setq message (string-interval message)))
				      (when (if marker outgoing incoming)
					(format t "~&~@[~VT~]~~@[~A~&~]~A~%~~%"
						*show-messages-indentation*
						marker
						(cl:string-trim '(#\return)
								message))))))))))))))))))))



;;; Forget old messages when disk saving
;;; But don't start up the converse-frame's process if it hasn't been started yet
(defun 2converse-reset0 ()
  (setq *saved-sends* nil)
  (setq *last-recipients* nil)
  (let ((w (tv:find-window-of-flavor 'converse-frame)))
    (if w (send w ':delete-all-conversations))))

(add-initialization "Forget old messages" '(converse-reset) '(:before-cold))

(defun 2regenerate-converse-at-arms-length0 ()
  (let ((w (tv:find-window-of-flavor 'converse-frame)))
    (when w
      (send w :regenerate))))
