;;; -*-  Mode: LISP; Package: ZWEI; Base: 8 -*-
;;; Lisp Machine mail reader
;;; Conversation/Reference stuff
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(DEFFLAVOR REFERENCE-HASH-TABLE-MIXIN
	(SEQUENCE)
	()
  (:INITABLE-INSTANCE-VARIABLES SEQUENCE)
  (:REQUIRED-FLAVORS SI:BASIC-HASH-TABLE))

(DEFMETHOD (:PRINT-SELF REFERENCE-HASH-TABLE-MIXIN) (STREAM IGNORE SLASHIFY-P)
  (LET ((PRINT-NAME (IF (AND (VARIABLE-BOUNDP SEQUENCE) SEQUENCE)
			(SEND SEQUENCE :NAME)
		      "delete-duplicate-messages")))
    (IF SLASHIFY-P
	(SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP :NO-POINTER)
	  (PRINC PRINT-NAME STREAM))
      (SEND STREAM :STRING-OUT PRINT-NAME))))

(DEFMETHOD (:EQUAL-ITEMS REFERENCE-HASH-TABLE-MIXIN) (X Y)
  (REFERENCE-EQUAL (CDR X) (CDR Y)))

(DEFMETHOD (:HASH-ITEM REFERENCE-HASH-TABLE-MIXIN) (KEY)
  (CAR KEY))

;; These are the external store and retrieve messages to
;; use, NOT :GET-HASH or :PUT-HASH!

(DEFMETHOD (:PUT-MSG REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LET ((IDS (GET-MSG-IDS MSG)))
    (DOLIST (ID IDS)
      (SEND SELF ':MODIFY-HASH ID #'STORE-MSG-IN-HASH-TABLE MSG SI:AREA))))

(DEFMETHOD (:PUT-REFERENCING-MSG REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LET ((IDS (GET-MSG-IDS MSG)))
    (DOLIST (ID IDS)
      (SEND SELF ':MODIFY-HASH ID #'STORE-REFERENCING-MSG-IN-HASH-TABLE MSG SI:AREA))))

(DEFMETHOD (:PUT-MSG-BY-ID REFERENCE-HASH-TABLE-MIXIN) (MSG ID)
  (SEND SELF ':MODIFY-HASH ID #'STORE-MSG-IN-HASH-TABLE MSG SI:AREA))

(DEFMETHOD (:PUT-REFERENCING-MSG-BY-ID REFERENCE-HASH-TABLE-MIXIN) (MSG ID)
  (SEND SELF ':MODIFY-HASH ID #'STORE-REFERENCING-MSG-IN-HASH-TABLE MSG SI:AREA))

(DEFMETHOD (:ADD-AND-XREF-MSG REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LOOP FOR ID IN (GET-MSG-IDS MSG)
	DO (SEND SELF ':MODIFY-HASH ID #'STORE-MSG-IN-HASH-TABLE MSG SI:AREA))
  (LOOP FOR REF IN (MSG-REFERENCES MSG)
	FOR ID = (CONS (REFERENCE-HASH REF) REF)
	DO (SEND SELF ':MODIFY-HASH ID #'STORE-REFERENCING-MSG-IN-HASH-TABLE MSG SI:AREA)))

(DEFMETHOD (:DELETE-MSG REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LET ((IDS (GET-MSG-IDS MSG)))
    (DOLIST (ID IDS)
      (SEND SELF ':MODIFY-HASH ID #'DELETE-MSG-FROM-HASH-TABLE MSG))))

(DEFMETHOD (:DELETE-REFERENCING-MSG REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LET ((IDS (GET-MSG-IDS MSG)))
    (DOLIST (ID IDS)
      (SEND SELF ':MODIFY-HASH ID #'DELETE-REFERENCING-MSG-FROM-HASH-TABLE MSG))))

(DEFMETHOD (:DELETE-MSG-FROM-ID REFERENCE-HASH-TABLE-MIXIN) (MSG ID)
  (SEND SELF ':MODIFY-HASH ID #'DELETE-MSG-FROM-HASH-TABLE MSG))

(DEFMETHOD (:DELETE-REFERENCING-MSG-FROM-ID REFERENCE-HASH-TABLE-MIXIN) (MSG ID)
  (SEND SELF ':MODIFY-HASH ID #'DELETE-REFERENCING-MSG-FROM-HASH-TABLE MSG))

(DEFMETHOD (:EXPUNGE-MSG-FROM-HASH-TABLE REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LET ((IDS (GET-MSG-IDS MSG)))
    (DOLIST (ID IDS)
      (SEND SELF ':MODIFY-HASH ID #'EXPUNGE-MSG-FROM-HASH-TABLE MSG))))

(DEFMACRO REF-BUCKET-MSGS (BUCKET)
  `(FIRST ,BUCKET))

(DEFMACRO REF-BUCKET-REFERENCERS (BUCKET)
  `(SECOND ,BUCKET))

(DEFUN STORE-MSG-IN-HASH-TABLE (KEY BUCKET IGNORE MSG AREA)
  KEY
  (IF (NULL BUCKET)
      (SETQ BUCKET (MAKE-LIST 2 ':AREA AREA)))
  (PUSH* MSG (REF-BUCKET-MSGS BUCKET))
  BUCKET)

(DEFUN STORE-REFERENCING-MSG-IN-HASH-TABLE (KEY BUCKET IGNORE MSG AREA)
  KEY
  (IF (NULL BUCKET)
      (SETQ BUCKET (MAKE-LIST 2 ':AREA AREA)))
  (PUSH* MSG (REF-BUCKET-REFERENCERS BUCKET))
  BUCKET)

(DEFUN DELETE-MSG-FROM-HASH-TABLE (KEY BUCKET IGNORE MSG)
  KEY
  (IF BUCKET
      (SETF (REF-BUCKET-MSGS BUCKET) (DELQ MSG (REF-BUCKET-MSGS BUCKET))))
  BUCKET)

(DEFUN DELETE-REFERENCING-MSG-FROM-HASH-TABLE (KEY BUCKET IGNORE MSG)
  KEY
  (IF BUCKET
      (SETF (REF-BUCKET-REFERENCERS BUCKET)
	    (DELQ MSG (REF-BUCKET-REFERENCERS BUCKET))))
  BUCKET)

(DEFUN EXPUNGE-MSG-FROM-HASH-TABLE (KEY BUCKET IGNORE MSG)
  KEY
  (IF BUCKET
      (PROGN (SETF (REF-BUCKET-MSGS BUCKET)
		   (DELQ MSG (REF-BUCKET-MSGS BUCKET)))
	     (SETF (REF-BUCKET-REFERENCERS BUCKET)
		   (DELQ MSG (REF-BUCKET-REFERENCERS BUCKET)))))
  BUCKET)

(DEFMETHOD (:GET-MSGS REFERENCE-HASH-TABLE-MIXIN) (REF)
  (WITH-STACK-LIST* (KEY (REFERENCE-HASH REF) REF)
    (REF-BUCKET-MSGS (SEND SELF ':GET-HASH KEY))))

(DEFMETHOD (:GET-MSGS-BY-ID REFERENCE-HASH-TABLE-MIXIN)  (ID)
  (REF-BUCKET-MSGS (SEND SELF ':GET-HASH ID)))

(DEFMETHOD (:GET-REFERENCING-MSGS-BY-ID REFERENCE-HASH-TABLE-MIXIN) (ID)
  (REF-BUCKET-REFERENCERS (SEND SELF ':GET-HASH ID)))

(DEFMETHOD (:GET-REFERENCING-MSGS REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (SI:ELIMINATE-DUPLICATES
    (NCONC (LOOP FOR ID IN (GET-MSG-IDS MSG)
		 APPEND (SEND SELF ':GET-REFERENCING-MSGS-BY-ID ID))
	   (LOOP FOR REF IN (GET (LOCF (MSG-STATUS MSG)) ':BACKWARD-REFERENCES)
		 FOR NMSGS = (SEND SELF ':GET-MSGS REF)
		 APPEND NMSGS))))

(DEFMETHOD (:GET-REFERENCED-MSGS REFERENCE-HASH-TABLE-MIXIN) (MSG)
  (LOOP FOR REF IN (MSG-REFERENCES MSG)
	APPEND (SEND SELF ':GET-MSGS REF)))

(DEFFLAVOR REFERENCE-HASH-TABLE ()
	   (REFERENCE-HASH-TABLE-MIXIN SI:GENERIC-HASH-TABLE))

(COMPILE-FLAVOR-METHODS REFERENCE-HASH-TABLE)

(DEFMETHOD (:UPDATE-REFERENCE-HASH-TABLE UNIVERSE-SEQUENCE-MIXIN :BEFORE) ()
  (SEND SELF ':PREPARE-UNIVERSE))

(DEFMETHOD (:CREATE-REFERENCE-HASH-TABLE UNIVERSE-SEQUENCE-MIXIN) ()
  (OR REFERENCE-HASH-TABLE
      (SETQ REFERENCE-HASH-TABLE
	    (MAKE-INSTANCE 'REFERENCE-HASH-TABLE
			   ':AREA *ZMAIL-MSG-AREA*
			   ':SIZE (// (* (SEND SELF ':NMSGS) 5) 4)
			   ':SEQUENCE SELF))))

(DEFWHOPPER (:CREATE-REFERENCE-HASH-TABLE UNIVERSE-SEQUENCE-MIXIN) ()
  (LOCK-SEQUENCE (SELF :WRITE)
    (WHEN (NULL REFERENCE-HASH-TABLE)		;Only if not already present
      (SETQ REFERENCE-HASH-TABLE-TICK 0)	;Say not initialized
      (CONTINUE-WHOPPER))))			;Actually do the create

(DEFMETHOD (:UPDATE-REFERENCE-HASH-TABLE UNIVERSE-SEQUENCE-MIXIN) ()
  (LOCK-SEQUENCE (SELF :WRITE)
    (WHEN (NULL REFERENCE-HASH-TABLE)
      (SEND SELF :CREATE-REFERENCE-HASH-TABLE))
    (WHEN (< REFERENCE-HASH-TABLE-TICK *REFERENCE-MODIFICATION-TICK*)
      (DO-UNIVERSE (MSG SELF :NO-PREPARE T
			     :NOTE-PROGRESS "Updating references in ~A.")
	(SEND REFERENCE-HASH-TABLE :ADD-AND-XREF-MSG MSG))
      (SETQ REFERENCE-HASH-TABLE-TICK (TICK)))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SELECT-REFERENCES
  "Select the messages referenced by the current message.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				(NUMERIC-ARG-OK)
  (LOOP WITH COLLECTION = (GET-RECYCLED-COLLECTION "<References>")
	WITH ARRAY = (SEND COLLECTION ':ARRAY)
	FOR MSG IN (FIND-MSGS-FROM-CURRENT-REFERENCES (SELECT-UNIVERSE-FOR-REFERENCES) T)
	DO (ARRAY-PUSH-EXTEND ARRAY MSG)
	FINALLY (RETURN (SELECT-SEQUENCE COLLECTION))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SELECT-CONVERSATION-BY-REFERENCES
  "Select the current message's conversation.

The conversation is defined by finding all messages in the universe which refer to the
current message, are referenced by the current message, refer to or are referenced
by one of those messages, etc.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
   (NUMERIC-ARG-OK)
  (LOOP WITH COLLECTION = (GET-RECYCLED-COLLECTION "<Conversation>")
	WITH ARRAY = (SEND COLLECTION ':ARRAY)
	FOR MSG IN (SORT (FIND-MSGS-FROM-REFERENCES (COPYLIST (MSG-REFERENCES *MSG*))
						    *MSG* (SELECT-UNIVERSE-FOR-REFERENCES)
						    T T)
			 #'MSG-DATE-SORT-LESSP)
	DO (ARRAY-PUSH-EXTEND ARRAY MSG)
	FINALLY (RETURN (SELECT-SEQUENCE COLLECTION))))

(DEFPROP COM-ZMAIL-SELECT-ALL-CONVERSATIONS-BY-REFERENCES
	 "Select the collection of the conversations of all the messages in the current sequence.  R: Universe menu."
	 :WHO-LINE-DOCUMENTATION)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SELECT-ALL-CONVERSATIONS-BY-REFERENCES
  "Select the collection of the conversations of all the messages in the current sequence.

A conversation is defined by finding all messages in the universe which refer to a
specific message, are referenced by said message, refer to or are referenced by one
of those messages, etc.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
   (NUMERIC-ARG-OK)
  (CHECK-FOR-TOO-MANY-MSGS "select conversations over")
  (WHEN (EQ *ZMAIL-COMMAND-BUTTON* :RIGHT) (SETQ *NUMERIC-ARG-P* :CONTROL-U))
  (LET ((UNIVERSE (IF *NUMERIC-ARG-P*
		      (SELECT-UNIVERSE-FOR-REFERENCES)
		      *LOADED-FILES-INDIRECT-UNIVERSE*))
	(ALL-REFERENCES NIL)
	(ALL-MSGS NIL))
    (UNLESS UNIVERSE (ABORT-CURRENT-COMMAND))
    (LOOP WITH *NUMERIC-ARG-P* = NIL
	  FOR MSG BEING THE MSGS IN *SEQUENCE*
	  DO (LET ((REFERENCES (MSG-REFERENCES-NO-DUPLICATES MSG (LOCF ALL-REFERENCES))))
	       (SETQ ALL-MSGS (NCONC ALL-MSGS
				     (FIND-MSGS-FROM-REFERENCES
				       REFERENCES MSG
				       UNIVERSE
				       T T)))))
    (SETQ ALL-MSGS (SORT (SI:ELIMINATE-DUPLICATES ALL-MSGS) #'MSG-DATE-SORT-LESSP))
    (LET* ((COLLECTION (GET-RECYCLED-COLLECTION "<Conversations>"))
	   (ARRAY (SEND COLLECTION ':ARRAY)))
      (DOLIST (MSG ALL-MSGS)
	(ARRAY-PUSH-EXTEND ARRAY MSG))
      (SELECT-SEQUENCE COLLECTION))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-APPEND-CONVERSATION-BY-REFERENCES
  "Appends the messages in the current message's conversation into the current message.

The conversation is defined by finding all messages in the universe which refer to the
current message, are referenced by the current message, refer to or are referenced
by one of those messages, etc.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				(NUMERIC-ARG-OK)
  (LET* ((CONVERSATION (SORT (FIND-MSGS-FROM-REFERENCES (COPYLIST (MSG-REFERENCES *MSG*))
							*MSG* (SELECT-UNIVERSE-FOR-REFERENCES)
							T T)
			     #'MSG-DATE-SORT-LESSP))
	 (OTHER-MSGS (CL:REMOVE-IF #'(LAMBDA (MSG) (OR (EQ MSG *MSG*) (MSG-GET MSG 'DELETED)))
				   CONVERSATION)))
    (IF (NULL OTHER-MSGS)
	DIS-NONE
      (CONCATENATE-MSGS-TO-MSG OTHER-MSGS *MSG*)
      DIS-TEXT)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DELETE-CONVERSATION-BY-REFERENCES
  "Delete the current message's conversation (including the current message).

The conversation is defined by finding all messages in the universe which refer to the
current message, are referenced by the current message, refer to or are referenced
by one of those messages, etc.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
  (NUMERIC-ARG-OK)
  (DELETE-MSGS-REMARKING (FIND-MSGS-FROM-REFERENCES (COPYLIST (MSG-REFERENCES *MSG*))
						    *MSG* (SELECT-UNIVERSE-FOR-REFERENCES)
						    T T))
  (COM-ZMAIL-DELETE-INTERNAL *NEXT-AFTER-DELETE* *MSG*)
  DIS-TEXT)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SELECT-REFERENCED-MSG
  "Select the message referenced by the current message.

If the current message refers to more than one other message, a menu of candidate
messages is displayed.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				(NUMERIC-ARG-OK)
  (SELECT-MSG-AND-POSSIBLY-BUFFER (FIND-MSG-FROM-CURRENT-REFERENCES
				    "Select" (SELECT-UNIVERSE-FOR-REFERENCES))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DELETE-REFERENCED-MSGS
  "Delete the messages referenced by the current message.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				(NUMERIC-ARG-OK)
  (LET ((MSGS (FIND-MSGS-FROM-CURRENT-REFERENCES (SELECT-UNIVERSE-FOR-REFERENCES))))
    (SETQ MSGS (DELQ *MSG* MSGS))
    (DELETE-MSGS-REMARKING MSGS))
  DIS-NONE)

(DEFUN DELETE-MSGS-REMARKING (MSGS)
  (SETQ MSGS (SORT MSGS #'(LAMBDA (X Y) (STRING-LESSP (SEQUENCE-NAME (MSG-BUFFER X))
						      (SEQUENCE-NAME (MSG-BUFFER Y))))))
  (IF (NULL MSGS)
      (TYPEIN-LINE "No messages deleted.")
    (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE :NAME "multiple delete" :INDICATOR 'DELETED)
      (DO ((MSGS MSGS (CDR MSGS))
	   (OMF NIL) (COUNT 0) (DCOUNT 0)
	   (MSG))
	  (NIL)
	(WHEN (OR (NULL MSGS)
		  (NEQ (MSG-BUFFER (SETQ MSG (CAR MSGS))) OMF))
	  (WHEN OMF
	    (TYPEIN-LINE "~:[~D~;No~*~] message~:P deleted from ~A~:[, ~
			  ~D~:[ other~] message~P already deleted~]."
			 (ZEROP COUNT) COUNT (SEQUENCE-NAME OMF)
			 (ZEROP DCOUNT) DCOUNT (ZEROP COUNT) DCOUNT))
	  (WHEN MSGS
	    (SETQ OMF (MSG-BUFFER MSG)
		  COUNT 0
		  DCOUNT 0)))
	(WHEN (NULL MSGS)
	  (RETURN NIL))
	(IF (MSG-GET MSG 'DELETED)
	    (INCF DCOUNT)
	  (INCF COUNT))
	(MSG-PUT-UNDOABLY MSG T 'DELETED)))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-APPEND-TO-REFERENCED-MSG
  "Append the current message into the message it references.

If the current message refers to more than one other message, a menu of candidate
messages is displayed.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				(NUMERIC-ARG-OK)
  (LET ((MSG (FIND-MSG-FROM-CURRENT-REFERENCES "Append to" (SELECT-UNIVERSE-FOR-REFERENCES))))
    (CONCATENATE-MSG-TO-MSG *MSG* MSG)
    (TYPEIN-LINE "Appended to message in ~A" (FUNCALL (MSG-BUFFER MSG) ':NAME)))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MOVE-IN-PLACE-OF-REFERENCED-MSG
  "Replace the message referenced by the current message with the current message.
The current message is also deleted from the current sequence.

If the current message refers to more than one other message, a menu of candidate
messages is displayed.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				()
  (LET* ((MSG (FIND-MSG-FROM-CURRENT-REFERENCES "Move in place of"
						(SELECT-UNIVERSE-FOR-REFERENCES)))
	 (BUFFER (MSG-BUFFER MSG))
	 (INDEX (MSG-IN-SEQUENCE-P MSG BUFFER)))
    (MSG-PUT MSG T 'DELETED)
    (SEND BUFFER ':ADD-MSG *MSG* INDEX)
    (TYPEIN-LINE "Moved to ~A" (FUNCALL BUFFER ':NAME)))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SOURCE-COMPARE-REFERENCED-MSG
  "Source compare the current message against the message it references.

If the current message refers to more than one other message, a menu of candidate
messages is displayed.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
				(NUMERIC-ARG-OK)
  (SOURCE-COMPARE-MSGS *MSG*
		       (FIND-MSG-FROM-CURRENT-REFERENCES
			 "Source compare with" (SELECT-UNIVERSE-FOR-REFERENCES)))
  DIS-NONE)

;;; Argument means give the menu before bothering to look in loaded files.
(DEFUN FIND-MSG-FROM-CURRENT-REFERENCES (&OPTIONAL (PROMPT "Use") TRY-HERE-FIRST
						   (NOT-DELETED T)
					 &AUX MSGS REFS NOT-DELETED-MSGS)
  (SETQ REFS (MSG-REFERENCES *MSG*))
  (SETQ MSGS (DELQ *MSG* (FIND-MSGS-FROM-CURRENT-REFERENCES TRY-HERE-FIRST)))
  (AND (NULL MSGS)
       (BARF "Cannot find the message~P referenced by this command." (LENGTH REFS)))
  (SETQ NOT-DELETED-MSGS
	(IF (NOT NOT-DELETED)
	    MSGS
	  (REM-IF #'(LAMBDA (MSG)
		      (MSG-GET MSG 'DELETED))
		  MSGS)))
  (SETQ MSGS
	(IF (AND (NOT (NULL NOT-DELETED-MSGS)) (NULL (CDR NOT-DELETED-MSGS)))
	    (CAR NOT-DELETED-MSGS)
	    (TV:MENU-CHOOSE (LOOP FOR MSG IN (SORT MSGS #'MSG-DATE-SORT-LESSP)
				  COLLECT `(,(STRING-APPEND
					       (STATUS-LETTER (LOCF (MSG-STATUS MSG)))
					       (MSG-SUMMARY-LINE MSG)
					       *SPACES* *SPACES* *SPACES*)
					    :VALUE ,MSG
					    :STYLE (:FIX :ROMAN :LARGE)
					    :DOCUMENTATION "Select this message"))
			    (FORMAT NIL "~A which message:" PROMPT))))		
  (AND (NULL MSGS) (ABORT-CURRENT-COMMAND))
  MSGS)

;;; TRY-HERE-FIRST-P of NIL means skip looking in current sequence. 
;;; RECURSIVE-P means collect msgs reference by referenced messages as well. 
(DEFUN FIND-MSGS-FROM-CURRENT-REFERENCES (&OPTIONAL TRY-HERE-FIRST
						    (RECURSIVE-P NIL) (REFERENCING-TOO NIL)
					  &AUX REFS)
  (OR (SETQ REFS (MSG-REFERENCES *MSG*))
      (BARF "Cannot find any message references in this message"))
  (FIND-MSGS-FROM-REFERENCES (COPYLIST REFS) *MSG* TRY-HERE-FIRST RECURSIVE-P
			     REFERENCING-TOO))

(DEFUN STRING-FOR-MSG-REFERENCE (REF)
  (WITH-OUTPUT-TO-STRING (STREAM)
    (PRINT-REFERENCE REF STREAM NIL)))

;;; Find messages from this message's references.  The messages are unordered;
;;; they should be sorted before being presented to the user.

(DEFUN FIND-UNDELETED-MSGS-FROM-REFERENCES (REFS MSG TRY-HERE-FIRST RECURSIVE-P
					    REFERENCING-TOO MSGS-SO-FAR)
  (LOOP FOR MSG IN (FIND-MSGS-FROM-REFERENCES (COPYLIST REFS) MSG TRY-HERE-FIRST
					      RECURSIVE-P REFERENCING-TOO MSGS-SO-FAR)
	WHEN (NOT (GET (LOCF (MSG-STATUS MSG)) 'DELETED))
	  COLLECT MSG))

(DEFUN SELECT-UNIVERSE-FOR-REFERENCES (&OPTIONAL SPECIAL-DEFAULT-UNIVERSE
						 (ALLOW-UNIVERSE-MENU T))
  (IF (AND *NUMERIC-ARG-P* ALLOW-UNIVERSE-MENU)
      (LET ((UNIVERSE
	      (GET-UNIVERSE-FUNCTION '(:MOUSE)
				     "Select the universe to search for references:")))
	(OR UNIVERSE (ABORT-CURRENT-COMMAND)))
    (OR *REFERENCE-DEFAULT-UNIVERSE*		;allow users to always override the default
	SPECIAL-DEFAULT-UNIVERSE		;allow some commands to override the default
	*REFERENCED-BUFFERS-INDIRECT-UNIVERSE*)))


(DEFUN FIND-MSGS-FROM-REFERENCES (REFS MSG TRY-HERE-FIRST RECURSIVE-P REFERENCING-TOO
				  &OPTIONAL MSGS-SO-FAR KILLED-MSGS)
  (IF TRY-HERE-FIRST
      (MULTIPLE-VALUE-BIND (GOOD-MSGS NEW-KILLED-MSGS)
	   (GET-MULTIPLE-REFERENCES MSG REFS TRY-HERE-FIRST
				    RECURSIVE-P REFERENCING-TOO
				    MSGS-SO-FAR)
	(FIND-MSGS-FROM-REFERENCES REFS MSG NIL RECURSIVE-P REFERENCING-TOO
				   GOOD-MSGS (APPEND NEW-KILLED-MSGS KILLED-MSGS)))
      (LOOP FOR (FILTER . UNIVERSE) IN *FILTER-REFERENCE-UNIVERSE-ALIST*
	    WITH ANSWER = MSGS-SO-FAR
	    WITH NEW-KILLED-MSGS = KILLED-MSGS
	    DO (MULTIPLE-VALUE (ANSWER NEW-KILLED-MSGS)
		 (IF (MSG-FITS-FILTER-P MSG FILTER)
		     (GET-MULTIPLE-REFERENCES MSG REFS
					      (EXPAND-UNIVERSE-DESCRIPTION UNIVERSE)
					      RECURSIVE-P REFERENCING-TOO
					      ANSWER)
		     (VALUES ANSWER NEW-KILLED-MSGS)))
	    FINALLY
	      (LET ((TO-DO-REFS (LOOP FOR REF IN REFS
				      WHEN (LOOP FOR MSG IN (APPEND ANSWER NEW-KILLED-MSGS)
						 NEVER (MSG-REFERENCE-EQUAL MSG REF))
					COLLECT REF)))
		(WHEN TO-DO-REFS
		  (TYPEIN-LINE "~&~D reference~:P not satisfied." (LENGTH TO-DO-REFS))))
	      (RETURN ANSWER))))

;; Get references.  If RECURSIVE-P, gets the referenced messages.
;; If REFERENCING-TOO, gets messages referencing this one, too.
;; Returns a second value of deleted messages satisfying references.

;; There is a nasty definition problem here involving internal message-ids.  These can
;; be either a list (date sender) or a string from an RFC822-style explicit message-id
;; header.  This function had been finding referencing messages by finding those with
;; references to any of the internal message-ids of a subject message, i.e., either to
;; "<850904084822.2.MARGULIES@REDWING.SCRC.Symbolics.COM>", or to "The message of Wed,
;; 4 Sep 85 08:48 EDT from Margulies@SCRC-YUKON.ARPA".  However, this ran afoul of the
;; ambiguity that happens now and again where two messages have the same sender and
;; the same date (down to the minute).  In these cases, by using all internal
;; message-ids, we lose from the beginning by :GET-MSGS-FROM-REFERENCE finding both
;; the current msg and the superfluous one via the date/sender id.  Also,
;; :GET-REFERENCING-MSGS may occasionally begin to add extraneous references by
;; searching from all ids of the msg it is condsidering.

;; The best fix possible in the circumstances is applied here, using the new function
;; GET-MSG-REFS-MESSAGE-IDS-PREFERRED in this function and in (:METHOD SEQUENCE
;; :GET-REFERENCING-MSGS).  This function returns only explicit message-id strings if
;; there are any, otherwise all the (date sender) ids.  Thus, if a message has a
;; Message-ID: header, we will only find referencing messages via this Message-ID:.
;; Referenced messages can still be found by either kind of reference.  Note that if a
;; message does not have a Message-ID: header, nothing can be done to resolve the
;; ambiguity, so there is the danger of superfluous messages in conversations
;; that contain such a message.

(DEFUN GET-MULTIPLE-REFERENCES (ORIGINAL-MSG IN-REFS UNIVERSE &OPTIONAL RECURSIVE-P
				REFERENCING-TOO
				SO-FAR)
  (LOOP WITH ALL-REFERENCES
	WITH ALL-MSGS = SO-FAR
	FOR REFS = (APPEND (GET-MSG-REFS-MESSAGE-IDS-PREFERRED ORIGINAL-MSG) IN-REFS)
		 THEN (NCONC NEW-REFERENCES (CDR REFS))
	FOR NEW-REFERENCES = NIL
	FOR REF = (FIRST REFS)
	FOR FIRST-TIME-KLUDGE = (NCONS ORIGINAL-MSG) THEN NIL
	WHILE (OR REF FIRST-TIME-KLUDGE)
	DO (LOOP FOR NEW-MSGS
		     = (NO-DUPLICATES
			 (NCONC FIRST-TIME-KLUDGE
				(AND REF (SEND UNIVERSE ':GET-MSGS-FROM-REFERENCE REF)))
			 (LOCF ALL-MSGS))
		     THEN (NCONC NEW-NEW-MSGS (CDR NEW-MSGS))
		 FOR NEW-NEW-MSGS = NIL
		 FOR MSG = (CAR NEW-MSGS)
		 WHILE MSG
		 WHEN RECURSIVE-P
		   NCONC (MSG-REFERENCES-NO-DUPLICATES MSG (LOCF ALL-REFERENCES))
		     INTO FOUND-REFS
		 WHEN REFERENCING-TOO
		   DO (SETQ NEW-NEW-MSGS
			    (NO-DUPLICATES (SEND UNIVERSE ':GET-REFERENCING-MSGS MSG)
					   (LOCF ALL-MSGS)))
		 FINALLY (SETQ NEW-REFERENCES FOUND-REFS))
	FINALLY (RETURN (MSGS-NOT-KILLED ALL-MSGS))))

(DEFUN MSGS-NOT-KILLED (MSGS)
  (LOOP FOR MSG IN MSGS
	WHEN (EQ (MSG-PARSED-P MSG) ':KILLED)
	  COLLECT MSG INTO KILLED-MSGS
	UNLESS (EQ (MSG-PARSED-P MSG) ':KILLED)
	  COLLECT MSG INTO UNKILLED-MSGS
	FINALLY (RETURN (VALUES UNKILLED-MSGS KILLED-MSGS))))

(DEFUN NO-DUPLICATES (ITEMS ALL-LOC)
  (LOOP FOR ITEM IN ITEMS
	WITH ALL = (CAR ALL-LOC)
	FOR PREVIOUSLY-FOUND = (MEMQ ITEM ALL)
	WITH RESULT
	UNLESS PREVIOUSLY-FOUND
	  DO (PUSH ITEM RESULT)
	     (PUSH ITEM ALL)
	FINALLY (RPLACA ALL-LOC ALL)		;Store into running list
		(RETURN RESULT)))

;;; Find all the references in a message, that do not duplicate ones already found.
;;; This is careful about order.

(DEFUN MSG-REFERENCES-NO-DUPLICATES (MSG ALL-REFERENCES-LOC)
  (LOOP FOR REF IN (MSG-REFERENCES MSG)
	WHEN (AND (NOT (MEM #'REFERENCE-EQUAL REF (CDR ALL-REFERENCES-LOC)))
		  (NOT (MEM #'REFERENCE-EQUAL REF FOUND-REFS)))
	  COLLECT REF INTO FOUND-REFS
	FINALLY (RPLACA ALL-REFERENCES-LOC (APPEND FOUND-REFS (CDR ALL-REFERENCES-LOC)))
		(RETURN FOUND-REFS)))

(DEFUN MSG-REFERENCES-ELIMINATE-DUPLICATES (REFS &OPTIONAL ID-P)
  (LOOP FOR REF IN REFS
	WHEN (NOT (MEM (IF ID-P #'(LAMBDA (R1 R2)
				    (REFERENCE-EQUAL (CDR R1) (CDR R2)))
			 #'REFERENCE-EQUAL)
		       REF REFS-SO-FAR))
	  COLLECT REF INTO REFS-SO-FAR
	FINALLY (RETURN REFS-SO-FAR)))

(DEFUN MSG-REFERENCES-EXCLUDE-IDS (EXCLUDED-IDS REFS)
  (LOOP WITH EXCLUDED-REFS = (MAPCAR #'CDR EXCLUDED-IDS)
	FOR REF IN REFS
	WHEN (NOT (MEM #'REFERENCE-EQUAL REF EXCLUDED-REFS))
	  COLLECT REF))

;;; MSG-REFERENCE-EQUAL matches a reference against a message.

(DEFUN MSG-REFERENCE-EQUAL (MSG REF)
  (LOOP FOR ID IN (GET-MSG-IDS MSG)
	THEREIS (REFERENCE-EQUAL REF (CDR ID))))

;;; REFERENCE-EQUAL compares to references.  Two references are considered EQUAL
;;; if the dates are the same, modulo seconds, the FROM: fields the same, modulo
;;; BABYL-stripped hosts, and any other parts being EQUAL.
;;; Also allow different hosts in the same mail address forwarding domain, they may
;;; have been chosen to avoid forwarding %'s.

;;; What it SHOULD do, do the date comparisons modulo a few seconds in addition
;;; to ignoring seconds fields that are zero.  This would mean that it would have
;;; to hash to multiple buckets, which we have decided not to do for the moment.
;;; --RWK & Dodds.

(DEFUN REFERENCE-EQUAL (REF1 REF2)
  (OR (EQUAL REF1 REF2)				D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");For efficiency.
0      (LET ((REF1 (IF (AND (LISTP REF1) (EQ (FIRST REF1) :MESSAGE-ID)) (SECOND REF1) REF1))
	    (REF2 (IF (AND (LISTP REF2) (EQ (FIRST REF2) :MESSAGE-ID)) (SECOND REF2) REF2)))
	(TYPECASE REF1
	  (:STRING (TYPECASE REF2
		     (:STRING (STRING-EQUAL REF1 REF2))
		     (OTHERWISE NIL)))
	  (:LIST (TYPECASE REF2
		   (:LIST (LOOP FOR (IND PROP) ON REF1 BY 'CDDR
				WITH PLIST = (LOCF REF2)
				ALWAYS (REFERENCE-EQUAL-IND PROP (GET PLIST IND) IND)))
		   (OTHERWISE NIL)))))))

(DEFUN REFERENCE-EQUAL-IND (REF-PROP MSG-PROP IND)
  (AND MSG-PROP
       (OR (EQUAL REF-PROP MSG-PROP)
	   (CL:CASE IND
	     (:DATE
	       1;; Unix often inserts multiple Dates so just use the earliest.
0	       (WHEN (CL:LISTP REF-PROP)
		 (SETQ REF-PROP (LOOP FOR DATE IN REF-PROP MINIMIZE DATE)))
	       (WHEN (CL:LISTP MSG-PROP)
		 (SETQ MSG-PROP (LOOP FOR DATE IN MSG-PROP MINIMIZE DATE)))
	       (AND (< (ABS (- REF-PROP MSG-PROP)) 60.)
		    (MULTIPLE-VALUE-BIND (IGNORE
					  REF-MINUTES REF-HOURS REF-DATE REF-MONTH REF-YEAR)
			(CL:DECODE-UNIVERSAL-TIME REF-PROP 0)
		      (MULTIPLE-VALUE-BIND (IGNORE
					    MSG-MINUTES MSG-HOURS MSG-DATE MSG-MONTH MSG-YEAR)
			  (CL:DECODE-UNIVERSAL-TIME MSG-PROP 0)
			1;; Compare ignoring seconds ...
0			(AND (= REF-MINUTES MSG-MINUTES)
			     (= REF-HOURS MSG-HOURS)
			     (= REF-DATE MSG-DATE)
			     (= REF-MONTH MSG-MONTH)
			     (= REF-YEAR MSG-YEAR))))))
	     (:FROM
	       (LOOP FOR (IND PROP) ON REF-PROP BY 'CDDR
		     WITH PLIST = (LOCF MSG-PROP)
		     AS MSG-PROP = (GET PLIST IND)
		     ALWAYS
		       (OR (EQUAL PROP MSG-PROP)
			   (AND (EQ IND :HOST)
				1;; Hosts matter only if present in both references --
				;;    If both are host objects, we make a simple check based
				;;    on mailer equivalency.  Otherwise, we just compare the
				;;    hosts' printed representations.
0				(COND ((NULL PROP))
				      ((NULL MSG-PROP))
				      ((AND (EQ (FIRST PROP) :OBJECT)
					    (EQ (FIRST MSG-PROP) :OBJECT))
				       (MAILER:ALL-MAIL-ADDRESSES-FORWARD-BETWEEN-HOSTS-P
					 (SECOND PROP) (SECOND MSG-PROP)))
				      ((EQUAL (STRING-FROM-HOST PROP :HOST)
					      (STRING-FROM-HOST PROP :HOST))))))))))))
1;;; Hash function for message references --
;;;    Primarily, we hash on the 0Date1, 0From1, and 0Message-ID1 fields.
;;;    When hashing the 0Date1 field, we ignore seconds.
;;;    When hashing the 0From1 field, we ignore hosts as the host isn't always present
;;;       in references especially if 0Babyl1 has reformatted the message.  When
;;;       comparing 0From1 fields, we only compare hosts if present in both references.
0(DEFUN REFERENCE-HASH (REF)
  1;; Canonicalize 0(:message-id <string>)1 into 0<string>1.
0  (WHEN (AND (LISTP REF) (EQ (FIRST REF) :MESSAGE-ID))
    (SETQ REF (SECOND REF)))
  (TYPECASE REF
    (:STRING
      (SI:SXHASH-STRING REF))
    (:LIST
      (LOOP FOR (IND PROP) ON REF BY 'CDDR
	    WITH SUM = 0
	    WITH POINTER-FLAG = NIL
	    DO (CL:CASE IND
		 (:DATE
		   (WHEN (CL:LISTP PROP)
		     (SETQ PROP (LOOP FOR DATE IN PROP MINIMIZE DATE)))
		   (MULTIPLE-VALUE-BIND (IGNORE REF-MINUTES REF-HOURS REF-DATE)
		       1;; Use Universal Time (GMT) when computing the hash function.
0		       (CL:DECODE-UNIVERSAL-TIME PROP 0)
		     (SETQ SUM (LOGXOR SUM (+ (ROT REF-MINUTES 3)
					      (ROT REF-HOURS 7) (ROT REF-DATE 11))))))
		 (:FROM
		   (LOOP FOR (IND PROP) ON PROP BY 'CDDR
			 DO
		     (MULTIPLE-VALUE-BIND (HASH FLAG)
			 (IF (EQ IND :HOST) 0	1;Never include host in hash value.
0			   (SI:EQUAL-HASH PROP))
		       (SETQ SUM (LOGXOR SUM
					 (ROT (SI:SXHASH-STRING (GET-PNAME IND)) 2)
					 (ROT HASH 5))
			     POINTER-FLAG (OR (EQ FLAG 'T) POINTER-FLAG FLAG)))))
		 (OTHERWISE
		   (MULTIPLE-VALUE-BIND (HASH FLAG)
		       (SI:EQUAL-HASH PROP)
		     (SETQ SUM (LOGXOR SUM
				       (ROT (SI:SXHASH-STRING (GET-PNAME IND)) 2)
				       (ROT HASH 5))
			   POINTER-FLAG (OR (EQ FLAG T) POINTER-FLAG FLAG)))))
	    FINALLY
	      (RETURN (VALUES SUM POINTER-FLAG))))
    (OTHERWISE
      (SI:EQUAL-HASH REF))))

(DEFUN MSG-REFERENCES (MSG &AUX STATUS TEM)
  (SETQ STATUS (ASSURE-MSG-PARSED MSG T))
  (IF (SETQ TEM (GETL STATUS '(REFERENCES)))
      (CADR TEM)
      (SETQ TEM (GET-MSG-REFERENCES MSG STATUS))
      (PUTPROP STATUS TEM 'REFERENCES)
      TEM))

(DEFVAR *REFERENCE-ID-DUMMY-DATE* 0)

;; This gets a message's "Reference ID".  That is, the information
;; that's referenced in a message reference.

;;; Note: This does not include all :SENDER and :DATE fields of the message,
;;; so a reference to a redistributed-by wouldn't work.  Probably no one does
;;; that anyway.

(DEFUN GET-MSG-REFERENCE-IDS (MSG &OPTIONAL KILLED-OK)
  (LET* ((STATUS (ASSURE-MSG-PARSED MSG KILLED-OK))
	 (DATE (GET STATUS :DATE))
	 (FROM (GET STATUS :FROM))
	 (IDS))
    (UNLESS DATE
      (SETQ DATE (INCF *REFERENCE-ID-DUMMY-DATE* 60.)))
    (UNLESS FROM
      (SETQ FROM '((:NAME "MISSING-FROM-FIELD"))))
    (DOLIST (FROM FROM)
      (WHEN (CL:GETF FROM :NAME)
	(PUSH `(:DATE ,DATE :FROM ,(SOME-PLIST FROM '(:NAME :HOST))) IDS))
      (WHEN (CL:GETF FROM :PERSONAL-NAME)
	(PUSH `(:DATE ,DATE :FROM ,(SOME-PLIST FROM '(:PERSONAL-NAME))) IDS)))
    (NREVERSE IDS)))

;; Message ID's are computed as a list of possible ways a message
;; can be referenced.  Currently this includes any date/from reference
;; and any :MESSAGE-ID references.  These are stored together as an
;; alist of their hash codes and the ID. 
(DEFUN GET-MSG-IDS (MSG)
  (LET ((STATUS (ASSURE-MSG-PARSED MSG T)))
    (OR (GET STATUS 'MSG-IDS)
	(LET ((LIST NIL))
	  ;; Compute ID for any header of the Message-ID type, since you can revoke or
	  ;; supersede a redistribution.
	  (LOOP FOR (HEADER VALUE) ON (CDR STATUS) BY 'CDDR
		DO (WHEN (HEADER-TYPE-TYPEP HEADER ':MESSAGE-ID)
		     (IF (LISTP VALUE)
			 (DOLIST (ID VALUE)
			   (PUSH (CONS (REFERENCE-HASH ID) ID) LIST))
		       (PUSH (CONS (REFERENCE-HASH VALUE) VALUE) LIST))))
	  (LET ((IDS (GET-MSG-REFERENCE-IDS MSG T)))
	    (WHEN IDS
	      (LOOP FOR ID IN IDS
		    DO (PUSH (CONS (REFERENCE-HASH ID) ID) LIST))))
	  (SETQ LIST (MSG-REFERENCES-ELIMINATE-DUPLICATES
		       ;;Merge the several sources of ID information.
		       ;; message-ids must be first for use of DELETE-DUPLICATES-INTERNAL
		       (APPEND (NREVERSE LIST)
			       (MSG-IDS-FROM-REFERENCES (GET STATUS ':INCLUDED-MSGS)))
		       T))
	  (PUTPROP STATUS LIST 'MSG-IDS)
	  LIST))))

(DEFUN MSG-IDS-FROM-REFERENCES (REFS)
  (LOOP FOR REF IN REFS
	COLLECT (CONS (REFERENCE-HASH REF) REF)))

(DEFUN GET-MSG-REFS (MSG)
  (LOOP FOR REF IN (GET-MSG-IDS MSG)
	COLLECT (CDR REF)))

(DEFUN GET-MSG-REFS-MESSAGE-IDS-PREFERRED (MSG)
  (LOOP FOR REF IN (GET-MSG-IDS MSG)
	WHEN (STRINGP (CDR REF))
	  COLLECT (CDR REF) INTO REFS
	FINALLY (RETURN (IF REFS REFS (GET-MSG-REFS MSG)))))

(DEFUN GET-MSG-REFERENCES (MSG STATUS)
  ;; If there is an IN-REPLY-TO field, use what is says, else get from text
  (OR (LOOP FOR (TYPE HEADER) ON (CDR STATUS) BY 'CDDR
	    WHEN (AND (HEADER-TYPE-TYPEP TYPE :REFERENCE)
		      (NOT (GET TYPE :ID-REFERENCE))
		      (SETQ HEADER		;Reject MM's feeble attempt at In-Reply-To
			    (LOOP FOR REF IN HEADER
				  FOR ID = (IF (STRINGP REF)
					       REF
					     (GET (LOCF REF) :MESSAGE-ID))
				  WHEN ID
				  COLLECT IT
				  ELSE WHEN (GET (LOCF REF) :FROM)
				  COLLECT REF)))
	      APPEND HEADER)
      (GET-MSG-TEXT-REFERENCES MSG)))

   
;;; This should be called on a message after doing anything which might
;;; modify the FROM:, DATE:, or MESSAGE-ID: fields.  It is called with
;;; the result of a (GET-MSG-IDS msg) from before the modification.
;;; If this is not desirable from an efficiency standpoint (say, something
;;; which mungs ALL the headers of a sequence, or something), a
;;; (INVALIDATE-MSG-ID msg) should be done instead.
;;; That will turn force future reference-hacking stuff to scan the
;;; sequence again, and will cause the message to be re-inserted.

(DEFUN UPDATE-MSG-REFERENCES-GLOBALLY (MSG OLD-IDS)
  (LOOP FOR SEQUENCE IN *SEQUENCE-LIST*
	WITH NEW-IDS = (GET-MSG-IDS MSG)
     DO (SEND SEQUENCE ':MSG-ID-CHANGED MSG OLD-IDS NEW-IDS)))

(DEFMETHOD (:XREF-MSG UNIVERSE-SEQUENCE-MIXIN) (MSG)
  (AND REFERENCE-HASH-TABLE
       (SEND REFERENCE-HASH-TABLE ':ADD-AND-XREF-MSG MSG)))

(DEFMETHOD (:NEW-MSG UNIVERSE-SEQUENCE-MIXIN :AFTER) (MSG &OPTIONAL IGNORE)
  (SEND SELF ':XREF-MSG MSG))

(DEFMETHOD (:ADD-MSG UNIVERSE-SEQUENCE-MIXIN :AFTER) (MSG &REST IGNORE)
  (SEND SELF ':XREF-MSG MSG))

(DEFWHOPPER (:MSG-ID-CHANGED UNIVERSE-SEQUENCE-MIXIN) (MSG OLD-IDS NEW-IDS)
  (AND REFERENCE-HASH-TABLE
       ( REFERENCE-HASH-TABLE-TICK *REFERENCE-MODIFICATION-TICK*)
       (NOT (IDS-EQUAL OLD-IDS NEW-IDS))
       (CONTINUE-WHOPPER MSG OLD-IDS NEW-IDS)))

(DEFMETHOD (:MSG-ID-CHANGED FILE-MAIL-BUFFER) (MSG OLD-IDS NEW-IDS)
  (WHEN (EQ SELF (MSG-BUFFER MSG))		1;Don't worry about messages stored elsewhere.
0    (SEND SELF :NOTE-MSG-ID-CHANGED MSG OLD-IDS NEW-IDS)))

(DEFMETHOD (:MSG-ID-CHANGED UNIVERSE-SEQUENCE-MIXIN) (MSG OLD-IDS NEW-IDS)
  (SEND SELF ':NOTE-MSG-ID-CHANGED MSG OLD-IDS NEW-IDS))

(DEFMETHOD (:NOTE-MSG-ID-CHANGED UNIVERSE-SEQUENCE-MIXIN) (MSG OLD-IDS NEW-IDS)
  ;; Delete any old IDs not still valid
  (LOOP FOR OLD-ID IN OLD-IDS
     WHEN (LOOP FOR NEW-ID IN NEW-IDS	;No longer present
		NEVER (REFERENCE-EQUAL (CDR NEW-ID) (CDR OLD-ID)))
       DO (SEND REFERENCE-HASH-TABLE ':DELETE-MSG-FROM-ID MSG OLD-ID)
	  (SEND REFERENCE-HASH-TABLE ':DELETE-REFERENCING-MSG-FROM-ID MSG OLD-ID))
  ;; Add any new IDs not already present.
  (SEND REFERENCE-HASH-TABLE ':ADD-AND-XREF-MSG MSG))

(DEFMETHOD (:GET-MSGS-FROM-REFERENCE UNIVERSE-SEQUENCE-MIXIN) (REF)
  (SEND SELF ':UPDATE-REFERENCE-HASH-TABLE)
  (SEND REFERENCE-HASH-TABLE ':GET-MSGS REF))

(DEFMETHOD (:GET-MSGS-FROM-REFERENCE SEQUENCE) (REF &AUX MSGS)
  (DOMSGS (MSG SELF)
    (IF (MSG-REFERENCE-EQUAL MSG REF)
	(PUSH MSG MSGS)))
  MSGS)

(DEFMETHOD (:GET-REFERENCING-MSGS SEQUENCE) (REFERENCED-MSG)
  (LOOP FOR MSG BEING MSGS IN SELF
	WITH REFS = (GET-MSG-REFS-MESSAGE-IDS-PREFERRED REFERENCED-MSG)
	WHEN (MEM #'MSG-REFERENCE-EQUAL MSG REFS)
	  COLLECT MSG))

(DEFMETHOD (:GET-REFERENCING-MSGS UNIVERSE-SEQUENCE-MIXIN) (REFERENCED-MSG)
  (SEND SELF ':UPDATE-REFERENCE-HASH-TABLE)
  (SEND REFERENCE-HASH-TABLE ':GET-REFERENCING-MSGS REFERENCED-MSG))

(DEFMETHOD (:GET-REFERENCED-MSGS UNIVERSE-SEQUENCE-MIXIN) (REFERENCING-MSG)
  (SEND SELF ':UPDATE-REFERENCE-HASH-TABLE)
  (SEND REFERENCE-HASH-TABLE ':GET-REFERENCED-MSGS REFERENCING-MSG))

;; for the sake of speed with temporary files.

(DEFMETHOD (:GET-FIRST-MSG-FROM-REFERENCE UNIVERSE-SEQUENCE-MIXIN) (REF)
  (FIRST (SEND SELF ':GET-MSGS-FROM-REFERENCE REF)))

(DEFMETHOD (:GET-FIRST-MSG-FROM-REFERENCE SEQUENCE) (REF)
  (DOMSGS (MSG SELF)
    (IF (MSG-REFERENCE-EQUAL MSG REF)
	(RETURN MSG))))

;; True if there is no change in the set of IDs.
(DEFUN IDS-EQUAL (OLD-IDS NEW-IDS)
  (AND (LOOP FOR NEW-ID IN NEW-IDS
	     ALWAYS (LOOP FOR OLD-ID IN OLD-IDS
			  THEREIS (REFERENCE-EQUAL (CDR NEW-ID) (CDR OLD-ID))))
       (OR (AND (NULL (CDR OLD-IDS))		;If more than one, do nxm comparison.
		(NULL (CDR NEW-IDS)))
	   ;; This could be just a check for equal length, but there might be duplicates.
	   (LOOP FOR OLD-ID IN OLD-IDS
		 ALWAYS (LOOP FOR NEW-ID IN NEW-IDS
			      THEREIS (REFERENCE-EQUAL (CDR NEW-ID) (CDR OLD-ID)))))))

(DEFUN INVALIDATE-MSG-ID (MSG OLD-IDS)
  (LET ((STATUS (LOCF (MSG-STATUS MSG))))
    (IF (NOT (IDS-EQUAL OLD-IDS (GET STATUS 'MSG-IDS)))
	(LOOP WITH STATUS = (LOCF (MSG-STATUS MSG))
	      FOR ID IN (GET STATUS 'MSG-IDS)
	      WITH OBSOLETE = (GET STATUS 'OBSOLETE-MSG-IDS)
	      DO (IF (LOOP FOR OLD-ID IN OBSOLETE
			   NEVER (REFERENCE-EQUAL (CDR ID) (CDR OLD-ID)))
		     (PUSH ID OBSOLETE))
	      FINALLY (SI:NREMPROP STATUS 'MSG-IDS)
	      (SETQ *REFERENCE-MODIFICATION-TICK* (TICK))))))

;;; Duplicate message deletion

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-DELETE-DUPLICATE-MSGS
				"Delete any duplicate messages in the current sequence"
				()
  (DELETE-DUPLICATE-MSGS *SEQUENCE*)
  DIS-NONE)

(DEFUN DELETE-DUPLICATE-MSGS (SEQUENCE)
  (DELETE-DUPLICATE-MSGS-INTERNAL SEQUENCE))

(DEFUN DELETE-DUPLICATE-MSGS-INTERNAL (SEQUENCE &OPTIONAL ARRAY (START 0) END)
  (WHEN (NULL ARRAY)
    (SETQ ARRAY (SEND SEQUENCE ':ARRAY)))
  (WHEN (NULL END)
    (SETQ END (ARRAY-ACTIVE-LENGTH ARRAY)))
  (LET ((HASH-TABLE (MAKE-INSTANCE 'REFERENCE-HASH-TABLE
				   :SIZE (// (* (- END START) 5) 4)))
	(NDELETED 0))
    (LOOP FOR INDEX FROM START BELOW END
	  AS MSG = (AREF ARRAY INDEX)
	  DOING
      (LOOP FOR PROP IN '(:SUPERSEDES :REVOKES)
	    DO (LET ((REFS (MSG-GET MSG PROP)))
		 (LOOP FOR REF IN REFS
		       DO (LET ((RREF (COND ((STRINGP REF) REF)
					    ((GET (LOCF REF) :MESSAGE-ID))
					    (T REF))))
			    (LOOP FOR MSG IN (SEND SEQUENCE :GET-MSGS-FROM-REFERENCE RREF)
				  DO (UNLESS (OR (EQ (MSG-PARSED-P MSG) :KILLED)
						 (MSG-GET MSG 'DELETED))
				       (ZMAIL-DELETE-MSG MSG)
				       (INCF NDELETED)))))
		 (WHEN (AND (EQ PROP ':REVOKES) (NOT (NULL REFS))
			    (NOT (MSG-GET MSG 'DELETED)))
		   (ZMAIL-DELETE-MSG MSG)
		   (INCF NDELETED))))
      (LET ((OMSG (SWAPHASH (CAR (GET-MSG-IDS MSG)) MSG HASH-TABLE)))
	(COND ((NULL OMSG))
	      ((AND (NOT (MSG-GET OMSG 'DELETED))	; msgs considered duplicates if 
		    (NOT (MSG-GET MSG 'DELETED))	; neither deleted;
		    (EQUAL (MSG-GET OMSG :RESENT-DATE)	; and if redistributed, only 
			   (MSG-GET MSG :RESENT-DATE))	;  if duplicated in redistribution;
		    (EQUAL (MSG-GET OMSG :REDISTRIBUTED-DATE)
			   (MSG-GET MSG :REDISTRIBUTED-DATE))
		    (OR (AND (MSG-GET OMSG :MESSAGE-ID)	        ;and either
			     (EQUAL (MSG-GET OMSG :MESSAGE-ID)	;:message-ids equal, if any
				    (MSG-GET MSG :MESSAGE-ID)))
			(AND (NULL (MSG-GET OMSG :MESSAGE-ID))
			     (MSG-GET OMSG :SUBJECT)		;or if no :message-ids,
			     (EQUAL (MSG-GET OMSG :SUBJECT)	; subjects equal, if any
				    (MSG-GET MSG :SUBJECT)))
			(AND (NULL (MSG-GET OMSG :MESSAGE-ID))
			     (NULL (MSG-GET OMSG :SUBJECT))	;or if no :message-ids or
			     (MSG-GET OMSG :TO)	                ; :subjects, :to equal, if any
			     (EQUAL (MSG-GET OMSG :TO)
				    (MSG-GET MSG :TO)))))
	       (LOOP FOR PROP IN *INTERNAL-PROPERTIES-TO-INHERIT*
		     AS TEM = (MSG-GET OMSG PROP)
		     WHEN (AND TEM (NULL (MSG-GET MSG PROP)))
		     DO (MSG-PUT MSG TEM PROP))
	       (ZMAIL-DELETE-MSG OMSG)
	       (INCF NDELETED))
	      ;; If we just swapped an undeleted message for a deleted one, put back the
	      ;; undeleted one.  There may still be a duplicate.
	      ((AND (MSG-GET MSG 'DELETED)
		    (NOT (MSG-GET OMSG 'DELETED)))
	       (SWAPHASH (CAR (GET-MSG-IDS OMSG)) OMSG HASH-TABLE)))))
    (TYPEIN-LINE-DURABLE "~&~:[~D~;~*No~] duplicate message~:P deleted."
			 (ZEROP NDELETED) NDELETED)))

;;; Sorting and partitioning by references

(DEFFLAVOR UNKNOWN-REFERENCE-HASH-TABLE () (SI:GENERIC-HASH-TABLE))

(DEFMETHOD (:HASH-ITEM UNKNOWN-REFERENCE-HASH-TABLE) (KEY)
  (CAR KEY))

(DEFMETHOD (:EQUAL-ITEMS UNKNOWN-REFERENCE-HASH-TABLE) (X Y)
  (REFERENCE-EQUAL (CDR X) (CDR Y)))

(COMPILE-FLAVOR-METHODS UNKNOWN-REFERENCE-HASH-TABLE)

(DEFVAR *REFERENCE-BUCKET-NUMBER*)
(DEFVAR *REFERENCE-MSG-BUCKET-HASH-TABLE*)
(DEFVAR *REFERENCE-UNKNOWN-REFERENCE-BUCKET-HASH-TABLE*)
(DEFVAR *REFERENCE-SEQUENCE-REFERENCE-HASH-TABLE*)
(DEFVAR *REFERENCE-BUCKET-EQUIVALENCES*)

(DEFUN PARTITION-SEQUENCE-BY-REFERENCES (SEQUENCE)
  (LET ((*REFERENCE-SEQUENCE-REFERENCE-HASH-TABLE*
	  (LET ((UNIV SEQUENCE))
	    (SEND UNIV ':UPDATE-REFERENCE-HASH-TABLE)
	    (SEND UNIV ':REFERENCE-HASH-TABLE)))
	(*REFERENCE-BUCKET-NUMBER* 0)
	(*REFERENCE-UNKNOWN-REFERENCE-BUCKET-HASH-TABLE*
	  (MAKE-INSTANCE 'UNKNOWN-REFERENCE-HASH-TABLE))
	(*REFERENCE-MSG-BUCKET-HASH-TABLE* (CL:MAKE-HASH-TABLE))
	(*REFERENCE-BUCKET-EQUIVALENCES* NIL))
    ;; First assign buckets for all messages
    (LOOP FOR MSG BEING THE MSGS IN SEQUENCE
	  DOING (GET-MSG-REFERENCE-BUCKET MSG))
    (LOOP FOR L ON *REFERENCE-BUCKET-EQUIVALENCES*
	  DO (SETF (CAR L) (SORT (CAR L) '<)))
    (LOOP FOR MSG BEING THE MSGS IN SEQUENCE
	  AS BUCKET = (GET-MSG-REFERENCE-BUCKET MSG)
	  DO (LOOP FOR ELEM IN *REFERENCE-BUCKET-EQUIVALENCES*
		   WHEN (MEMQ BUCKET ELEM)
		   RETURN (SETQ BUCKET (CAR ELEM)))
	     (PUTPROP (LOCF (MSG-STATUS MSG)) BUCKET 'REFERENCE-BUCKET))))

(DEFUN GET-MSG-REFERENCE-BUCKET (MSG &OPTIONAL DEFAULT-BUCKET)
  (OR (SEND *REFERENCE-MSG-BUCKET-HASH-TABLE* ':GET-HASH MSG)
      (LET ((BUCKET (OR DEFAULT-BUCKET
			(PROG1 *REFERENCE-BUCKET-NUMBER*
			       (INCF *REFERENCE-BUCKET-NUMBER*)))))
	;; Store in case no references or circularities
	(SEND *REFERENCE-MSG-BUCKET-HASH-TABLE* ':PUT-HASH MSG BUCKET)
	(DOLIST (REF (MSG-REFERENCES MSG))
	  (WITH-STACK-LIST* (REF-KEY (REFERENCE-HASH REF) REF)
	    (LET ((OTHER-MSGS (REF-BUCKET-MSGS
				(SEND *REFERENCE-SEQUENCE-REFERENCE-HASH-TABLE*
				      ':GET-HASH REF-KEY))))
	      (IF OTHER-MSGS
		  ;; If we have the messages for this reference, get their buckets,
		  ;; and group these buckets into a conversation.
		  (LOOP FOR OTHER-MSG IN OTHER-MSGS
			AS OTHER-BUCKET = (GET-MSG-REFERENCE-BUCKET OTHER-MSG BUCKET)
			DO (EQUATE-REFERENCE-BUCKETS BUCKET OTHER-BUCKET))
		  (LET ((OTHER-BUCKET (SEND *REFERENCE-UNKNOWN-REFERENCE-BUCKET-HASH-TABLE*
					    ':GET-HASH REF-KEY)))
		    (IF OTHER-BUCKET
			;; Otherwise, if we have a bucket for this reference without a mesage,
			;; group it in.
			(EQUATE-REFERENCE-BUCKETS BUCKET OTHER-BUCKET)
			;; Else remember this unknown reference in this bucket
			(SEND *REFERENCE-UNKNOWN-REFERENCE-BUCKET-HASH-TABLE*
			      ':PUT-HASH (CONS (CAR REF-KEY) (CDR REF-KEY)) BUCKET)))))))
	BUCKET)))

(DEFUN EQUATE-REFERENCE-BUCKETS (BUCKET-1 BUCKET-2)
  (UNLESS (= BUCKET-1 BUCKET-2)
    (LET ((ELEM-1 (LOOP FOR ELEM IN *REFERENCE-BUCKET-EQUIVALENCES*
			WHEN (MEMQ BUCKET-1 ELEM)
			RETURN ELEM))
	  (ELEM-2 (LOOP FOR ELEM IN *REFERENCE-BUCKET-EQUIVALENCES*
			WHEN (MEMQ BUCKET-2 ELEM)
			RETURN ELEM)))
      (IF (AND ELEM-1 ELEM-2)
	  (UNLESS (EQ ELEM-1 ELEM-2)
	    (LET ((TEM (MEMQ ELEM-1 *REFERENCE-BUCKET-EQUIVALENCES*)))
	      (SETQ *REFERENCE-BUCKET-EQUIVALENCES*
		    (DELQ ELEM-2 *REFERENCE-BUCKET-EQUIVALENCES*))
	      (SETF (CAR TEM) (NCONC ELEM-1 ELEM-2))))
	(WHEN (NULL ELEM-1)
	  (SWAPF ELEM-1 ELEM-2)
	  (SWAPF BUCKET-1 BUCKET-2))
	(IF (NULL ELEM-1)
	    (PUSH (LIST BUCKET-1 BUCKET-2) *REFERENCE-BUCKET-EQUIVALENCES*)
	    (LET ((TEM (MEMQ ELEM-1 *REFERENCE-BUCKET-EQUIVALENCES*)))
	      (PUSH BUCKET-2 (CAR TEM))))))))

(DEFINE-NORMAL-SORT-PREDICATE MSG-REFERENCE-SORT-LESSP < "Conversations"
  "Grouped according to conversations."
  (GET (LOCF (MSG-STATUS MSG)) 'REFERENCE-BUCKET)
  ;; Slightly kludgy, get the bucket numbers during optimization setup.
  (PROGN (PARTITION-SEQUENCE-BY-REFERENCES SEQUENCE)
	 T)
  ;; Also delay sorting until all added if merging
  T)



(DEFVAR *MERGE-KEYWORDS-CONFLICT-RESOLUTION-HOOK* NIL)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MERGE-KEYWORDS-IN-CONVERSATION
  "Merge keywords of messages in this conversation.
If all labeled messages in this conversation have same keywords, then distribute
those keywords onto the unlabeled messages.  If some messages in the conversation
are labeled with different keywords than others, offer a menu which permits you
to add/remove keywords from all messages in the conversation.  If this menu 1is0 needed,
its default is to add to all messages only the keywords (if any) which are common to
all labeled messages.

The conversation is defined by finding all messages in the universe which refer to the
current message, are referenced by the current message, refer to or are referenced
by one of those messages, etc.

The universe searched by default includes all loaded files which contain at least
one message from the current sequence.  A numeric argument to this command produces
a menu of universes to search instead of the default."
   (NUMERIC-ARG-OK)
   (LET ((MSGS (FIND-MSGS-FROM-REFERENCES (COPYLIST (MSG-REFERENCES *MSG*))
					  *MSG* (SELECT-UNIVERSE-FOR-REFERENCES)
					  T T))
	 (COMMON-KEYS '())
	 (SPECIAL-KEYS '()))
     (DOLIST (MSG MSGS)
       (LET ((KEYS (MSG-GET MSG 'KEYWORDS)))
	 #||(FORMAT T "~&Msg ~S Keys ~S" MSG KEYS)||#
	 (WHEN KEYS
	   (COND ((NOT (OR SPECIAL-KEYS COMMON-KEYS))
		  (SETQ COMMON-KEYS KEYS))
		 (T
		  (LET ((NEW-COMMON-KEYS (CL:INTERSECTION COMMON-KEYS KEYS)))
		    (DOLIST (SPECIAL-KEY (CL:SET-DIFFERENCE COMMON-KEYS NEW-COMMON-KEYS))
		      (CL:PUSHNEW SPECIAL-KEY SPECIAL-KEYS))
		    (DOLIST (SPECIAL-KEY (CL:SET-DIFFERENCE KEYS COMMON-KEYS))
		      (CL:PUSHNEW SPECIAL-KEY SPECIAL-KEYS))
		    (SETQ COMMON-KEYS NEW-COMMON-KEYS)))))))
     #||(FORMAT T "~&Common: ~:S~%Special: ~:S~%" COMMON-KEYS SPECIAL-KEYS) (BREAK)||#
     (LET ((ALL-KEYS (APPEND COMMON-KEYS SPECIAL-KEYS))
	   (THIS-MSG (LIST *MSG*))
	   (UNLABELED-MSGS
	     (CL:REMOVE-IF #'(LAMBDA (MSG) (MSG-GET MSG 'KEYWORDS)) MSGS)))
       (MULTIPLE-VALUE-BIND (ADD REMOVE MSGS)
	   (COND ((= (LENGTH MSGS) 1)
		  (ZWEI:TYPEIN-LINE "There is only one message in this conversation.")
		  (VALUES NIL NIL NIL))
		 ((NOT ALL-KEYS)
		  (ZWEI:TYPEIN-LINE "No messages in this conversation have keywords.")
		  (VALUES NIL NIL NIL))
		 ((NOT SPECIAL-KEYS)
		  (COND (UNLABELED-MSGS
			 (ZWEI:TYPEIN-LINE "Adding keyword~P ~A to ~R unlabeled message~:P."
					   (LENGTH COMMON-KEYS)
					   (STRING-KEYWORDS-LIST COMMON-KEYS)
					   (LENGTH UNLABELED-MSGS))
			 (VALUES COMMON-KEYS NIL UNLABELED-MSGS))
			(T
			 (ZWEI:TYPEIN-LINE
			   "No messages in this conversation need keywords.")
			 (VALUES NIL NIL NIL))))
		 (T
		  (LET ((ALL-KEYS-SORTED (CL:SORT (MAPCAR #'(LAMBDA (KEY)
							      (RASSQ KEY *KEYWORD-ALIST*))
							  ALL-KEYS)
						  #'STRING-LESSP
						  :KEY #'CAR))
			(DEFAULT-MSGS (OR UNLABELED-MSGS THIS-MSG))
			(DEFAULT-ADD COMMON-KEYS)
			(DEFAULT-REMOVE '()))
		    (WHEN *MERGE-KEYWORDS-CONFLICT-RESOLUTION-HOOK*
		      (CL:MULTIPLE-VALUE-SETQ (DEFAULT-MSGS DEFAULT-ADD DEFAULT-REMOVE)
			;; The hook must return three values, which are the
			;;  messages to affect, the keywords to add,
			;;  and the keywords to remove.  The final choice will be
			;;  confirmed by menu.
			(FUNCALL *MERGE-KEYWORDS-CONFLICT-RESOLUTION-HOOK*
				 DEFAULT-MSGS DEFAULT-ADD DEFAULT-REMOVE
				 :THIS THIS-MSG
				 :ALL MSGS
				 :UNLABELED UNLABELED-MSGS
				 :ALLOW-OTHER-KEYS T)))
		    (DW:ACCEPTING-VALUES
		      (T
			:OWN-WINDOW T
			:LABEL
			(FORMAT NIL "Select keyword operations for this ~
				     conversation's ~R message~:P:  "
				(LENGTH MSGS)))
		      (VALUES (DW:ACCEPT `((DW:ALIST-SUBSET :ALIST ,ALL-KEYS-SORTED))
					 :DEFAULT DEFAULT-ADD
					 :PROMPT "Add")
			      (DW:ACCEPT `((DW:ALIST-SUBSET :ALIST ,ALL-KEYS-SORTED))
					 :DEFAULT DEFAULT-REMOVE
					 :PROMPT "Remove")
			      (DW:ACCEPT `((DW:ALIST-MEMBER
					     :ALIST (("Current only"
						      :VALUE ,THIS-MSG)
						     ("Any unlabeled"
						      :VALUE ,UNLABELED-MSGS)
						     ,@(UNLESS
							 (OR (EQ DEFAULT-MSGS THIS-MSG)
							     (EQ DEFAULT-MSGS UNLABELED-MSGS)
							     (EQ DEFAULT-MSGS MSGS))
							 ;; We can only get here if the
							 ;; conflict resolution hook has
							 ;; returned some non-standard set.
							 `(("Heuristic"
							    :VALUE ,DEFAULT-MSGS)))
						     ("All"
						      :VALUE ,MSGS))))
					 :DEFAULT DEFAULT-MSGS
					 :PROMPT "Which messages in conversation"))))))
	 #|| (FORMAT T "~&Add: ~:S~%Rem: ~:S~%" ADD REMOVE) (BREAK) ||#
	 (DOLIST (MSG MSGS)
	   (LET ((KEYWORDS-PRESENT (MSG-GET MSG 'KEYWORDS)))
	     ;; Watch out--CHANGE-MSG-KEYWORDS expects a freshly-consed argument!
	     (ZWEI:CHANGE-MSG-KEYWORDS MSG
				       (CL:COPY-LIST
					 (CL:UNION ADD
						   (CL:SET-DIFFERENCE KEYWORDS-PRESENT REMOVE)))
				       KEYWORDS-PRESENT)))
	 DIS-NONE))))

