;;; -*- Package: KBIN; Syntax: Common-lisp; Lowercase: Yes; Mode: LISP -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; Clear the table, and make its unused entries signal an error if we try to use them.
(defun reset-load-table ()
  (debugify
    (when *load-command-history*
      (command-history-push "Reset load table" *kbin-table-index* *load-command-history*)))
  (setq *kbin-table-index* 0)
  (fill-array-with-nulls *kbin-load-table*))

(defun reset-permanent-load-table ()
  (debugify
    (when *load-command-history*
      (command-history-push "Reset permanent load table" *kbin-permanent-table-index*
			    *load-command-history*)))
  (setq *kbin-permanent-table-index* 0)
  (fill-array-with-nulls *kbin-permanent-load-table*))

(defun fill-array-with-nulls (array &optional (start-index 0))
  (without-interrupts
    (let ((a-len (zl:array-length array))
	  (a-ptr (locf (aref array start-index))))
      (when (> a-len start-index)
	(sys:%block-store-tag-and-pointer a-ptr (- a-len start-index)
					  sys:dtp-null a-ptr 1)))))

(defun unbound-load-array-location-handler (.error. &optional ignore)
  (unbound-load-array-location-handler-1 .error. t))

(defun unbound-load-array-location-handler-1 (.error. load-p)
  (when (and (typep .error. 'sys:bad-data-type-in-memory)
	     (= (send .error. :data-type) sys:dtp-null))
    (let* ((array (sys:%find-structure-header (send .error. :address)))
	   (array-name (cond ((eq (follow-structure-forwarding *kbin-load-table*) array)
			      '*kbin-load-table*)
			     ((eq (follow-structure-forwarding *kbin-permanent-load-table*)
				  array)
			      '*kbin-permanent-load-table*))))
      (when array-name
	(let ((index (sys:%pointer-difference (send .error. :address) (locf (aref array 0)))))
	  (error "Attempt to ~:[dump a reference to~;reference~] location ~D. of ~S~@
		  before it has been initialized." load-p index array-name))))))

(defun kbin-enter-load-table (value index &optional permanent-p)
  (let ((table (if permanent-p
		   *kbin-permanent-load-table*
		 *kbin-load-table*)))
    (when ( index (zl:array-length table))
      (setq table (grow-load-table table (+ index (truncate index 2))))
      (if permanent-p
	  (setq *kbin-permanent-load-table* table)
	(setq *kbin-load-table* table)))
    (setf (aref table index) value)
    (debugify
      (if permanent-p
	  (when *permanent-load-table-history*
	    (command-history-push index value *permanent-load-table-history*))
	(when *load-table-history*
	  (command-history-push index value *load-table-history*)))
      (when *load-command-history*
	(command-history-push `(,(if permanent-p "Store Perm" "Store") ,index)
			      value *load-command-history*)))
    value))

(defun grow-load-table (table new-size)
  (if ( new-size (zl:array-length table))
      table
    (let ((old-table table)
	  (new-table (make-array new-size)))
      (declare (sys:array-register new-table old-table))
      (loop for i below (length old-table)
	    do (if (location-boundp (locf (aref old-table i)))
		   (setf (aref new-table i) (aref old-table i))
		 (location-makunbound (locf (aref new-table i)))))
      (fill-array-with-nulls new-table (length old-table))
      (structure-forward old-table new-table
			 (si:array-prefix-length old-table)
			 (si:array-prefix-length new-table))
      new-table)))

;;; Info about what area things are supposed to go in.

(define-kbin-load kbin-msg-area (stream)
  (let ((*area* *zmail-msg-area*))
    (kbin-next-value stream)))

(define-kbin-load kbin-msg-line-area (stream)
  (let ((*area* *zmail-msg-line-area*))
    (kbin-next-value stream)))

(define-kbin-load kbin-summary-area (stream)
  (let ((*area* *zmail-summary-area*))
    (kbin-next-value stream)))

(define-kbin-load kbin-header-area (stream)
  (let ((*area* *zmail-header-area*))
    (kbin-next-value stream)))

(define-kbin-load kbin-working-storage-area (stream)
  (let ((*area* sys:working-storage-area))
    (kbin-next-value stream)))

(define-kbin-load kbin-immediate-integer (opcode ignore)
  (+ (ldb %immediate-integer-byte opcode) *min-immediate-integer*))

(define-kbin-load kbin-immediate-table-fetch (opcode stream)
  stream
  (kbin-load-table-fetch (ldb (byte 14 0) opcode)))

(define-kbin-load kbin-immediate-permanent-table-fetch (opcode stream)
  stream
  (kbin-load-permanent-table-fetch (- opcode
				      (dpb kbin-immediate-permanent-table-fetch
					   (byte 8 8)
					   0))))

(define-kbin-load kbin-immediate-string (opcode stream)
  (kbin-load-simple-string-internal stream (ldb (byte 8 0) opcode)))

(define-kbin-load-for-value kbin-immediate-temporary-string (opcode stream)
  (kbin-load-simple-string-internal stream (ldb (byte 8 0) opcode)))

(define-kbin-load-for-permanent-value kbin-immediate-permanent-string (opcode stream)
  (kbin-load-simple-string-internal stream (ldb (byte 8 0) opcode)))

(define-kbin-load kbin-immediate-list (opcode stream)
  (kbin-load-list-internal stream (ldb (byte 8 0) opcode) nil))

(define-kbin-load-for-value kbin-immediate-temporary-list (opcode stream)
  (kbin-load-list-internal stream (ldb (byte 8 0) opcode) nil))

(define-kbin-load-for-permanent-value kbin-immediate-permanent-list (opcode stream)
  (kbin-load-list-internal stream (ldb (byte 8 0) opcode) nil))

(define-kbin-load kbin-immediate-line (opcode stream)
  (kbin-load-line-internal stream (ldb (byte 8 0) opcode) nil))

(define-kbin-load kbin-immediate-fat-line (opcode stream)
  (kbin-load-line-internal stream (ldb (byte 8 0) opcode) t))

;;; New opcodes for Rel-7 strings go here.

(defun kbin-command (opcode stream)
  (let ((fun2 (aref *kbin-second-level-command-table* (ldb (byte 8 0) opcode))))
    (invoke-kbin-load-command fun2 stream)))

(defun kbin-permanent-command (opcode stream)
  (with-table-entry :permanent
    (kbin-command opcode stream)))

(defun kbin-temporary-command (opcode stream)
  (with-table-entry :temporary
    (kbin-command opcode stream)))

(define-kbin-load-for-effect kbin-format-version (stream)
  (let ((version (kbin-next-value stream)))
    (if (numberp version)
	(multiple-value-bind (file-major-version file-minor-version actual-version)
	    (cond (( version 9)
		   D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; As of version 9, a 0KBIN1 file remembers which 0Zmail1 version wrote it.
0		   (values (kbin-next-value stream) (kbin-next-value stream) t))
		  (( 4 version 8)
		   (multiple-value-bind (format-major-version format-minor-version)
		       (get-zmail-version-for-kbin-version version :last)
		     (values format-major-version format-minor-version nil)))
		  (t nil))			1;Unreal version...
0	  (multiple-value-bind (format-major-version format-minor-version)
	      (if ( version 10)
		  1;; As of version 10, a 0KBIN1 file also remembers what was the first version
0		  1;; of 0Zmail1 that could have written it.  By recording this data in the file,
0		  1;; we don't have to back patch (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*kbin-to-zmail-version-translations*1 whenever
0		  1;; a new version is created.
0		  (values (kbin-next-value stream) (kbin-next-value stream))
		(get-zmail-version-for-kbin-version version :first))
	    (cond ((= version *kbin-format-version*))
		  (( *kbin-format-oldest-version* version *kbin-format-version*)
		   1;; Older style file -- Simply let the user know that it will be upgraded.
0		   (zwei:typein-line
		     "KBIN file ~A was written by Zmail ~D.~D~:[ or earlier~].~@
		      It will be upgraded to the current format the next time ~
		      that it is saved."
		     (pathname stream) file-major-version file-minor-version actual-version))
		  (( *kbin-format-version* version (+ *kbin-format-version* 100))
		   1;; Shouldn't be too large a number of new versions before 0KBIN1 is retired.
0		   (multiple-value-bind (current-major-version current-minor-version)
		       (sct:get-system-version :Zmail)
		     (error "KBIN file ~A was written by Zmail ~D.~D~:[ or earlier~].~@
			     Your machine is running Zmail ~D.~D.~@
			     The file contains data which cannot be properly interpreted ~
			     unless your machine is running Zmail version ~D.~D or later.~@
			     Therefore, the file cannot be read at this time."
			    (pathname stream)
			    file-major-version file-minor-version actual-version
			    current-major-version current-minor-version
			    format-major-version format-minor-version)))
		  (t
		   1;; This value for version is quite outside reality.
0		   (error "KBIN file ~A was written using an unsupported version ~D."
			  (pathname stream) version)))))
      1;; Badly formatted file.
0      (error "KBIN file ~A is improperly formatted." (pathname stream)))
    1;; Passed our sanity check -- Remember what version it was written with so that we
0    1;;    can perform necessary conversions as the file is read.
0    (setq *format-version-read* version)))

(defun get-zmail-version-for-kbin-version (version first-or-last)
  (let* ((kbin-zmail-version-translation (assoc version *kbin-to-zmail-version-translations*))
	 (zmail-version (when kbin-zmail-version-translation
			  (ecase first-or-last
			    (:first (second kbin-zmail-version-translation))
			    (:last (third kbin-zmail-version-translation))))))
    (values (first zmail-version) (second zmail-version))))

;;; Just check for possible superset, and warn of problems, don't 2error0.
(define-kbin-load-for-effect kbin-hairy-version (stream)
  (let ((version (kbin-next-value stream)))
    (when (> version bin:*string-dump-format*)
      (warn "File ~A was written using hairy string format ~D, but we have version ~D."
	    (pathname stream) version bin:*string-dump-format*))))

1;;; Compute which header fields in this file aren't properly parsed.
0(define-kbin-load-for-effect kbin-additional-parsed-header-fields (stream)
  (let ((prior-additional-parsed-header-fields (kbin-next-value stream)))
    (setq *unparsed-header-fields* (set-difference *additional-parsed-header-fields*
						   prior-additional-parsed-header-fields))))

1;;; Record how many message should appear in this file.
0(define-kbin-load-for-effect kbin-dumped-msg-count (stream)
  (setq *dumped-msg-count* (kbin-next-value stream)))

(define-kbin-load kbin-table-fetch (stream)
  (kbin-load-table-fetch (kbin-next-value stream)))

(define-kbin-load kbin-permanent-table-fetch (stream)
  (kbin-load-permanent-table-fetch (kbin-next-value stream)))

(define-kbin-load kbin-table-fetch-medium (stream)
  (kbin-load-table-fetch (kbin-next-byte stream)))

(define-kbin-load kbin-permanent-table-fetch-medium (stream)
  (kbin-load-permanent-table-fetch (kbin-next-byte stream)))

(define-kbin-load kbin-long-string (stream)
  (kbin-load-simple-string-internal stream (kbin-next-value stream)))

(defun kbin-load-simple-string-internal (stream length &optional (area *area*)
						&rest make-array-options)
  (let ((string (apply #'make-array length :element-type 'string-char :area area
		       make-array-options)))
    (when (oddp length)
      (setq string (adjust-array string (1+ length))))
    (let ((fat-length (truncate (1+ length) 2)))
      (si:with-indirect-array (buffer 'art-16b string)
	(send stream :string-in t buffer 0 fat-length)))
    (when (oddp length)
      (adjust-array string length))
    string))

1;;; Obsolete
0(defun kbin-load-fat-string-internal (stream length &optional (area *area*)
					     &rest make-array-options)
  (let ((string (apply #'make-array length ':element-type '(unsigned-byte 16) :area area
		       make-array-options)))
    (send stream ':string-in t string 0 length)
    (push string *Rel-6-strings*)
    string))

;;; Load a complex string

(define-kbin-load kbin-hairy-string (stream)
  (ignore stream)
  (send *string-loader* :load-string))

(define-kbin-load kbin-hairy-line (stream)
  (ignore stream)
  (let ((line (send *string-loader* :load-string)))
    (setf (line-length line) (zl:array-length line))
    line))

(define-kbin-load kbin-character-style (stream)
  (let ((spec (kbin-next-value stream)))
    (condition-bind ((si:invalid-character-style-component
		       ;; accept it anyway
		       (lambda (cond) (send cond :proceed :no-action))))
      (si:parse-character-style spec))))

(define-kbin-load kbin-large-integer (stream)
  (kbin-large-integer-internal stream nil))

(define-kbin-load kbin-large-negative-integer (stream)
  (kbin-large-integer-internal stream t))

(defun kbin-large-integer-internal (stream negate-p)
  (let ((nbytes (kbin-next-value stream))
	(result 0))
    (loop repeat nbytes
	  for count upfrom 1
	  for shift upfrom 0 by 16
	  for *default-cons-area* = (if (or negate-p
					    (< count nbytes))
					sys:working-storage-area
					*area*)
	  do (setq result (dpb (kbin-next-byte stream) (byte 16 shift) result)))
    (if negate-p
	(let ((*default-cons-area* *area*))
	  (- result))
      result)))

(define-kbin-load kbin-ratio (stream)
  (/ (kbin-next-value stream)
     (kbin-next-value stream)))

(define-kbin-load kbin-single-float (stream)
  (let* ((low-byte (kbin-next-byte stream))
	 (high-byte (kbin-next-byte stream))
	 (float-as-fixnum (sys:%logdpb high-byte (byte 16 16) low-byte)))
    (sys:%flonum float-as-fixnum)))

(define-kbin-load kbin-double-float (stream)
  (flet ((load-fixnum ()
	   (let ((low-byte (kbin-next-byte stream))
		 (high-byte (kbin-next-byte stream)))
	     (sys:%logdpb high-byte (byte 16 16) low-byte))))
    (let ((low-part-as-fixnum (load-fixnum))
	  (high-part-as-fixnum (load-fixnum))
	  (*default-cons-area* *area*))
      (si:%make-double high-part-as-fixnum low-part-as-fixnum))))

(define-kbin-load kbin-complex (stream)
  (let* ((realpart (kbin-next-value stream))
	 (imagpart (kbin-next-value stream))
	 (*default-cons-area* *area*))
    (complex realpart imagpart)))

(define-kbin-load kbin-list (stream)
  (kbin-load-list-internal stream (kbin-next-value stream) nil))

(define-kbin-load kbin-list* (stream)
  (kbin-load-list-internal stream (kbin-next-value stream) t))

(defun kbin-load-list-internal (stream length dotted-p)
  (let ((list (make-list length ':area *area*)))
    (loop for list on list
	  do (setf (car list) (kbin-next-value stream)))
    (when dotted-p
      (sys:%change-list-to-cons (nthcdr (- length 2) list)))
    list))

(define-kbin-load kbin-cons (stream)
  (cons-in-area (kbin-next-value stream)
		(kbin-next-value stream)
		*area*))

(define-kbin-load kbin-nil (ignore)
  nil)

(define-kbin-load kbin-t (ignore)
  t)

(define-kbin-load kbin-keyword (stream)
  (let ((symbol (kbin-keyword-internal stream sys:pkg-keyword-package)))
    (cond ((and (= *format-version-read* 4)	2;-- Release 6 compatibility kludge
0		(eq symbol :interval-string))
	   :original-string)
	  ((and ( *format-version-read* 5)	;-- Convert to christiantity by lion.
		(eq symbol :character-styles))
	   :character-type-mappings)
	  (t symbol))))

(define-kbin-load kbin-internal-keyword (stream)
  (kbin-keyword-internal stream *editor-package*))

(define-kbin-load kbin-global-symbol (stream)
  (kbin-keyword-internal stream sys:pkg-global-package))

(defun kbin-keyword-internal (stream package)
  (let ((pname (kbin-next-value stream)))
    (intern pname package)))

(define-kbin-load kbin-symbol (stream)
  (let ((package (kbin-next-value stream))
	(symbol-name (kbin-next-value stream)))
    (intern symbol-name (find-package package))))

(define-kbin-load kbin-list-reference (stream)
  (list-in-area *area*
		:date (kbin-next-value stream)
		:from (kbin-next-value stream)))

(define-kbin-load kbin-message-id-reference (stream)
  (list-in-area *area*
		:message-id (kbin-next-value stream)))

(define-kbin-load kbin-bp (stream)
  (let ((line (kbin-next-value stream))
	(loc (kbin-next-value stream))
	(*default-cons-area* *area*))
    (create-bp line loc)))

(define-kbin-load kbin-bp-normal (stream)
  (let ((line (kbin-next-value stream))
	(loc (kbin-next-value stream))
	(*default-cons-area* *area*))
    (create-bp line loc :normal (msg-real-interval *msg-self*))))

(define-kbin-load kbin-bp-moves (stream)
  (let ((line (kbin-next-value stream))
	(loc (kbin-next-value stream))
	(*default-cons-area* *area*))
    (create-bp line loc :moves (msg-real-interval *msg-self*))))

(define-kbin-load kbin-character (stream)
  (let ((bits (kbin-next-value stream))
	(style (kbin-next-value stream))
	(charset-name (kbin-next-value stream))
	(index (kbin-next-value stream)))
    (let ((charset (si:lookup-character-set charset-name))
	  (style-index (si:style-index style t)))
      (make-char (int-char (send charset :make-char index)) bits style-index))))

(define-kbin-load-for-effect kbin-end-of-file (stream)
  stream
  (error "Premature end of file."))

(define-kbin-load-for-effect kbin-end-of-msg (stream)
  stream
  (error "Premature end of message."))

(define-kbin-load kbin-value (stream)
  (kbin-next-value stream))

(define-kbin-load kbin-line (stream)
  (kbin-load-line-internal stream (kbin-next-value stream) nil))

(define-kbin-load kbin-fat-line (stream)
  (kbin-load-line-internal stream (kbin-next-value stream) t))

(define-kbin-load-for-effect kbin-set-line-contents-plist (stream)
  (let ((line (kbin-next-value stream))
	(plist (kbin-next-value stream)))
    (setf (line-contents-plist line) plist)))
(define-kbin-load-for-effect kbin-set-line-plist (stream)
  (let ((line (kbin-next-value stream))
	(plist (kbin-next-value stream)))
    (setf (zwei:line-plist line) plist)))

2;;; --- Release 6 KBIN compatibility.0  Just ignores the right number of arguments.
(define-kbin-load-for-effect kbin-set-line-bp-list (stream)
  (let ((line (kbin-next-value stream))
	(bps (kbin-next-value stream)))
    (ignore line bps)))

(defun kbin-load-line-internal (stream length fat-p)
  (let ((line (funcall (if fat-p
			   #'kbin-load-fat-string-internal
			 #'kbin-load-simple-string-internal)
		       stream length *zmail-msg-line-area*
		       ':leader-length line-leader-size)))
    (setf (line-length line) length)
    line))

(define-kbin-load kbin-interval (stream)
  (let ((interval (create-interval)))
    (kbin-load-interval-internal stream interval)
    interval))

(defun kbin-load-interval-internal (stream into-interval)
  (let* ((nlines (kbin-next-value stream))
	 (end-bp (interval-last-bp into-interval))
	 (at-line (bp-line end-bp)))
    (loop repeat nlines
	  as line = (kbin-next-value stream)
	  do (insert-line-with-leader line at-line)
	  finally (move-bp end-bp line (line-length line)))))

(define-kbin-load-for-effect kbin-file-property-list (stream)
  stream
  (error "File property list in middle of file."))

(define-kbin-load-for-effect kbin-msg (stream)
  stream
  (error "Message in the middle of file."))

(define-kbin-load-for-effect kbin-msg-status (stream)
  stream
  (error "Message status in the middle of file."))

(define-kbin-load-for-effect kbin-msg-summary-line (stream)
  stream
  (error "Message summary line in the middle of file."))

(define-kbin-load-for-effect kbin-hairy-msg-summary-line (stream)
  stream
  (error "Message summary line in the middle of file."))

(define-kbin-load-for-effect kbin-msg-flags (stream)
  stream
  (error "Message flags in the middle of file."))

(define-kbin-load kbin-pathname (stream)
  (let ((value (kbin-next-value stream)))
    (condition-case ()
	 (fs:parse-pathname value nil *zmail-pathname-defaults*)
       ((sys:unknown-host-name fs:unknown-pathname-host fs:invalid-pathname-syntax)
	value))))

(define-kbin-load kbin-user (stream)
  (net:find-object-named ':user (kbin-next-value stream)))

(define-kbin-load kbin-host (stream)
  (let ((name (kbin-next-value stream)))
    (condition-case (.error.)
	(net:parse-host name)
      ((sys:unknown-host-name net:object-not-found)
	(kbin-find-object-named-in-namespace :host name neti:*namespace*)))))

;;; The following stuff fakes namespace objects, if we find something
;;; we can't hack.

(defun kbin-find-object-named-in-namespace (class name namespace &rest plist)
  (or (if (not (instancep name))
	  (neti:find-object-named-in-namespace
	    class name
	    (typecase namespace
	      (neti:namespace namespace)
	      (null neti:*namespace*)
	      (otherwise
		(kbin-find-object-named-in-namespace :namespace namespace nil)))
	    nil)
	(neti:find-object-named class name nil))
      (apply #'register-anonymous-object class name namespace plist)))

(defun get-anonymous-object (class name namespace)
  (stack-let ((key (list class name namespace)))
    (send *anonymous-object-hash-table* :get-hash key)))

(defun register-anonymous-object (class name namespace &rest plist)
  (or (get-anonymous-object class name namespace)
      (let* ((flavor (funcall (get class 'net:object-flavor-function) plist))
	     (names (if namespace
			(list (make-instance 'neti:name
					     :namespace (kbin-find-object-named-in-namespace
							  :namespace namespace nil)
					     :string name))
		      (list name)))
	     (object (make-instance flavor :names names :class class)))
	(send object :set-property-list (copylist plist))
	(send *anonymous-object-hash-table* :put-hash (list class name namespace) object)
	object)))

(define-kbin-load kbin-qualified-host (stream)
  (let* ((namespace (kbin-next-value stream))
	 (name (kbin-next-value stream)))
    (kbin-find-object-named-in-namespace :host name namespace)))

(define-kbin-load kbin-object-host (stream)
  (let ((string (kbin-next-value stream)))
    (parse-domain-or-host string)))

(define-kbin-load kbin-namespace (stream)
  (let ((name (kbin-next-value stream)))
    (kbin-find-object-named-in-namespace :namespace name nil)))

(define-kbin-load kbin-namespace-with-domain (stream)
  (let ((name (kbin-next-value stream))
	(domain (kbin-next-value stream)))
    (kbin-find-object-named-in-namespace :namespace name nil :internet-domain-name domain)))

(define-kbin-load kbin-font (stream)
  (let ((font-name (kbin-next-value stream)))
    (when (stringp font-name)
      (setq font-name (intern (string font-name) "FONTS")))
    (when (not (boundp font-name))
      (fed:find-and-load-font font-name))
    (symbol-value font-name)))

(define-kbin-load kbin-error (stream)
  (let ((flavor (kbin-next-value stream))
	(options (kbin-next-value stream)))
    (apply #'make-instance flavor options)))

(define-kbin-load kbin-msg-self (stream)
  stream
  (or *msg-self*
      (error "Reference to message being constructed, when no message being constructed.")))

(define-kbin-load kbin-instance (stream)
  (let* ((old-area *area*)
	 (*area* sys:working-storage-area)
	 (form (kbin-next-value stream))	;Don't cons stuff in the wrong area!
	 (*area* old-area)
	 (*default-cons-area* *area*))
    (eval form)))

1;;; Load a diagram.
0(define-kbin-load kbin-diagram (stream)
  (let ((form (kbin-next-value stream))
	1;; Be sure to also cons the diagram itself in the appropriate area.
0	(*default-cons-area* *area*))
    (eval form)))

1;;; Load the binary encoding of a graphics diagram.
0(define-kbin-load kbin-graphics-diagram-binary-encoding (stream)
  (let* ((array-size (kbin-next-value stream))
	 (words-to-load (ceiling array-size 2))
	 (binary-encoding (make-array array-size :element-type '(unsigned-byte 8)
						 :area *area*)))
    (dotimes (i words-to-load)
      (let* ((first-byte-index (* i 2))
	     (second-byte-index (when (< (1+ first-byte-index) array-size)
				  (1+ first-byte-index)))
	     (encoded-bytes (kbin-next-byte stream)))
	(setf (aref binary-encoding first-byte-index) (ldb (byte 8 8) encoded-bytes))
	(when second-byte-index
	  (setf (aref binary-encoding second-byte-index) (ldb (byte 8 0) encoded-bytes)))))
    binary-encoding))

(define-kbin-load kbin-scroll-item-displayer (stream)
  (let ((msg (kbin-msg-self stream)))
    (make-fake-scroll-item msg)))

(define-kbin-load-for-effect kbin-load-table-estimate (stream)
  (let ((size (kbin-next-value stream)))
    (if (or (not (variable-boundp *kbin-permanent-load-table*))
	    (null *kbin-permanent-load-table*))
	(setq *kbin-permanent-load-table* (make-array (min size 400)))
      (setq *kbin-permanent-load-table*
	    (grow-load-table *kbin-permanent-load-table* size)))))

(defun kbin-next-value (stream)
  (loop for value = (kbin-next-command stream)
	while (eq value *no-value-marker*)
	finally (return value)))

(defun kbin-next-command (stream)
  (let* ((op (kbin-next-byte stream))
	 (fun1 (aref *kbin-first-level-command-table* (ldb (byte 8 8) op))))
    (invoke-kbin-load-command fun1 op stream)))

;;; Called with stream at start
(defun kbin-load-file-property-list (stream buffer)
  (condition-bind ((sys:bad-data-type-in-memory #'unbound-load-array-location-handler))
    (unless (variable-boundp *kbin-load-table*)
      (setq *kbin-load-table* (make-array #o400)))
    (debugify
      (when *load-command-history*
	(command-history-reset *load-command-history*)))
    (reset-load-table)
    (debugify
      (when *load-table-history*
	(command-history-reset *load-table-history*)))
    (let ((op (kbin-next-byte stream)))
      (unless (= op kbin-format-version)
	(let ((apparent-format (zwei:actual-mail-file-format (zwei:msg-buffer-pathname buffer)
							     stream)))
	  (error 'zwei:wrong-mail-file-format :buffer buffer
					      :apparent-format apparent-format
					      :format-string
					        (unless apparent-format
						  "File does not start with version opcode.")
					      )))
      (send stream :untyi op)
      (kbin-next-command stream))
    (let ((op (kbin-next-byte stream)))
      (unless (= op kbin-load-table-estimate)
	(error "File header does not include estimate of load-table size."))
      (send stream :untyi op)
      (kbin-next-command stream))
    (reset-permanent-load-table)
    (debugify
      (when *permanent-load-table-history*
	(command-history-reset *permanent-load-table-history*)))
    (let ((op (kbin-next-byte stream)))
      (unless (= op kbin-file-property-list)
	(error "Start of file is not property list.")))
    (kbin-next-value stream)))

(defun kbin-load-one-msg (stream file-tick buffer)
  (declare (values . (msg more-msgs-available)))
  (condition-bind ((sys:bad-data-type-in-memory #'unbound-load-array-location-handler))
    (loop with original-area = *area*
	  for *area* first original-area then area
	  for area = original-area
	  doing
      (let ((op (kbin-next-byte stream))
	    (*area* *area*))
	(command-history-push-op
	  op
	  (select op
	    (kbin-msg
	     (let ((msg (make-empty-msg :tick file-tick)))
	       (setf (msg-buffer msg) buffer)
	       (kbin-load-msg stream msg)
	       (debugify
		 (command-history-push-op op msg *load-command-history*))
	       (return (values msg t))))
	    (kbin-end-of-file
	     (debugify
	       (command-history-push-op op nil *load-command-history*))
	     (return (values nil nil)))
	    (kbin-header-area (setq area *zmail-header-area*))
	    (kbin-summary-area (setq area *zmail-summary-area*))
	    (kbin-msg-area (setq area *zmail-msg-area*))
	    (kbin-msg-line-area (setq area *zmail-msg-line-area*))
	    (kbin-working-storage-area (setq area sys:working-storage-area))
	    (otherwise
	     (error "Unexpected ~A opcode (~O) seen where message expected."
		    (decode-kbin-opcode op) op)))
	  *load-command-history*)))))

(defun kbin-load-msg-status (stream *msg-self*)
  (let ((value (kbin-next-value stream)))
    (setf (msg-status *msg-self*) value)))

(defun kbin-load-msg (stream *msg-self*)
  (let ((*rel-6-strings* nil))			1;Temporary hack for Rel-6 compatibility
0    (reset-load-table)
    (debugify
      (when *load-table-history*
	(command-history-reset *load-table-history*)))
    (loop with original-area = *area*
	  for *area* first original-area then area
	  for area = original-area
	  doing
      (let ((op (kbin-next-byte stream)))
	(command-history-push-op
	  op
	  (select op
	    (kbin-msg-status
	     (kbin-load-msg-status stream *msg-self*))
	    (kbin-msg-interval
	     (kbin-load-interval-internal stream (msg-interval *msg-self*)))
	    (kbin-msg-summary-line
	     (let* ((length (kbin-next-value stream))
		    (line (kbin-load-simple-string-internal
			    stream length *area*
			    ':leader-length summary-line-length)))
	       (setf (summary-line-length line) length)
	       (setf (summary-line-template line) (kbin-next-value stream))
	       (setf (msg-summary-line *msg-self*) line)
	       line))
	    (kbin-hairy-msg-summary-line
	     (let ((line (send *string-loader* :load-string)))
	       (setf (summary-line-length line) (zl:array-length line))
	       (setf (summary-line-template line) (kbin-next-value stream))
	       (setf (msg-summary-line *msg-self*) line)))
	    (kbin-msg-flags
	     (setf (msg-flags *msg-self*) (kbin-next-value stream)))
	    (kbin-end-of-msg
	     (debugify
	       (command-history-push-op op *msg-self* *load-command-history*))
	     (return))
	    ((kbin-set-line-plist kbin-set-line-contents-plist kbin-set-line-bp-list)
	     (send stream ':untyi op)
	     (kbin-next-command stream))
	    (kbin-header-area (setq area *zmail-header-area*))
	    (kbin-summary-area (setq area *zmail-summary-area*))
	    (kbin-msg-area (setq area *zmail-msg-area*))
	    (kbin-msg-line-area (setq area *zmail-msg-line-area*))
	    (kbin-working-storage-area (setq area sys:working-storage-area))
	    (otherwise
	     (error "Unexpected ~A opcode (~O) seen where message expected."
		    (decode-kbin-opcode op) op)))
	  *load-command-history*)))
1    ;; Must say the message is parsed at this time, despite any Rel-6 conversion still
    ;; pending, because 2update-msg-character-type-mappings1 wants to see it parsed.
0    (setf (msg-parsed-p *msg-self*) t)
    1;; Perform any required conversions on the message.
0    (if (> *format-version-read* 4)
	1;; Genera 7.0 or later release...
0	(when *rel-6-strings*
	  (error "Release 6 strings encountered in a file ~
		  written by Genera 7.0 or later release."))
      1;; Release 6 format -- Fatten any old-style strings.
0      (when (or *rel-6-strings* (getf (msg-status *msg-self*) :fonts))
	1;; Check for an explicit Fonts field to properly convert in the case where the
0	1;; entire message is supposed to be in a specific font.
0	(fix-up-rel6-strings *msg-self*))
      (remf (msg-status *msg-self*) 'zwei:font-alist))
    (when (< *format-version-read* 7)
      1;; File was created before message keywords were properly propogated to the file header.
0      (zwei:add-keywords-in-msg-to-buffer *msg-self* (msg-buffer *msg-self*)))
    (when (< *format-version-read* 9)
      1;; File was created before 2parsed-headers1 properties were dumped correctly.
0      (fix-up-parsed-headers-properties *msg-self*))
    (when (< *format-version-read* 11)
      1;; File was created before the summary line templates were properly "un2eq1ed" when
0      1;; updating (e.g., manipulating keywords) or copying producing "invisible keywords".
0      (zwei:set-msg-summary-line *msg-self* (locf (msg-status *msg-self*))))
    (when (< *format-version-read* 15)
      1;; File was created before the 2msg-ids1 property was properly computed.
0      (when (getf (msg-status *msg-self*) 'zwei:msg-ids)
	(remf (msg-status *msg-self*) 'zwei:msg-ids)
	(zwei:get-msg-ids *msg-self*)))
    (when (< *format-version-read* 16)
      1;; Several problems were fixed by version 16 of 0KBIN1 --
      ;;    0Received1 fields are no longer parsed at message parsing time --
      ;;       We can't use the 2*unparsed-header-fields*1 mechanism below as, in this case,
      ;;       we're switching from a parsed to an unparsed representation.
      ;;    The 2draft-msg1 property was incorrectly stored as a simple Zwei node preventing
      ;;       the 0Continue1 and 0Reply1 commands from operating properly.
      ;;    Diagrams with non-integer scales couldn't be saved because 0KBIN1 had no
      ;;       mechanism to dump floating point or complex numbers.
0      (when (getf (msg-status *msg-self*) 'zwei:draft-msg)
	(remf (msg-status *msg-self*) 'zwei:draft-msg))
      (when (or (getf (msg-status *msg-self*) :received)
		1;; Mailer rejection slips contain 0Received1 fields in their body --
0		1;;    If the user has retransmitted the message before saving it, we'll
		;;    have parsed the message body and left old-style 0Received1 field
		;;    data structures in the 2parsed-headers1 properties of the body.
0		(zwei:msg-mailer-rejection-p *msg-self*))
	(if (eq *zmail-background-p* t)
	    1;; Can't reparse a message in the background (sigh).
0	    (zwei:queue-zmail-background-response reparse-msg *msg-self*)
	    (zwei:reparse-msg *msg-self*))))
    (when (< *format-version-read* 17)
      1;; Several problems will be fixed by version 17 of 0KBIN1 --
0      1;;   The 2headers-end-bp1 property was dumped incorrectly.
0      (loop with end-bp = (msg-get *msg-self* 'zwei:headers-end-bp)
	    with end-line = (bp-line (interval-last-bp (msg-interval *msg-self*)))
	    as line = (bp-line (interval-first-bp (msg-interval *msg-self*)))
		    then (line-next line)
	    until (eq line end-line)
	    if (eq line (bp-line end-bp))
	      return nil
	    if (equalp line (bp-line end-bp))
	      do (setf (bp-line end-bp) line)
		 (return)
	    finally
	      (setf (bp-line end-bp) end-line))
      1;;0   1Header type types were also improperly defined as header types --
0      1;;0   1   In other words, some header fields in a message were parsed as if they
0      1;;0   1   had a real structure rather than simply being string fields.  The classic
0      1;;0   1   example of this error is the 0"Address"1 header field which is a postal
0      1;;0   1   address but was parsed as if it were a list of mail addresses.
0      1;;0   1   (Fixing this error should have bumped the version number of 0KBIN1 files but
0      1;;0   1    then older Genera releases wouldn't correct the still broken 2headers-end-bp1.
0      (loop for (type value) on (msg-status *msg-self*) by 'cddr
	    when (and (assoc type zwei:*header-type-type-alist*)
		      (null (assoc type zwei:*header-type-alist*))
		      (not (stringp value))
		      (not (and (listp value)
				(loop for value in value
				      always (stringp value)))))
	      do (if (eq *zmail-background-p* t)
		     1;; Can't reparse a message in the background (sigh).
0		     (zwei:queue-zmail-background-response reparse-msg *msg-self*)
		     (zwei:reparse-msg *msg-self*))
	      and return))
    (when *unparsed-header-fields*
1      ;; File was created before some header fields were defined.
0      (reparse-msg-for-newly-defined-fields *msg-self* *unparsed-header-fields*))
    *msg-self*))

(zwei:define-zmail-background-response reparse-msg (msg) ()
  (zwei:reparse-msg msg))

(defun reparse-msg-for-newly-defined-fields (msg new-fields)
  (loop for (type value) on (msg-status msg) by 'cddr
	when (member type new-fields)
	  when (or (stringp value)
		   (and (listp value)
			(loop for value in value
			      thereis (stringp value))))
	    do (if (eq *zmail-background-p* t)
		   1;; Can't reparse a message in the background (sigh).
0		   (zwei:queue-zmail-background-response reparse-msg msg)
		 (zwei:reparse-msg msg))
	    and return))

(defun fix-up-parsed-headers-properties (msg)
  (multiple-value-bind (headers-start-bp headers-end-bp)
      (zwei:msg-original-headers-interval msg)
    (loop with end-line = (bp-line headers-end-bp)
	  with changed-something = nil
	  with prior-parsed-headers = nil
	  for line = (bp-line headers-start-bp) then (line-next line)
	  as parsed-headers = (getf (line-contents-plist line) 'zwei:parsed-headers)
	  if (and (equal parsed-headers prior-parsed-headers)
		  (neq parsed-headers prior-parsed-headers))
	    do (setf 
		 (getf (line-contents-plist line) 'zwei:parsed-headers) prior-parsed-headers
		 changed-something t)
	  else
	    do (setf prior-parsed-headers parsed-headers)
	  until (eq line end-line)
	  finally
	    (when (and changed-something (getf (msg-status msg) 'zwei:reformatted))
	      (zwei:reformat-headers msg t)))))

(defun fix-up-rel6-strings (msg)
  (let ((fonts (getf (msg-status msg) :fonts)))
    (unless fonts
      (error "There are no fonts with which to update this Rel-6 message:  ~S." msg))
    (stack-let ((type-array (make-array 256)))
      (loop for font in fonts
	    for i from 0
	    do (multiple-value-bind (style charset charset-offset)
		   (si:backtranslate-font font si:*b&w-screen*)
		 (setq style (si:canonicalize-character-style style))
		 (setf (aref type-array i)
		       (ldb sys:%%char-all-but-subindex
			    (dpb (send charset :decode-offset charset-offset)
				 sys:%%char-char-set
				 (dpb (si:style-index style t)
				      sys:%%char-style
				      0))))))
      (loop for str in *Rel-6-strings*
	    do (fatten-string-in-place str type-array))
      (unless (zerop (aref type-array 0))
	(fatten-the-thin-strings-to-new-type-0 msg (aref type-array 0)))
      (update-msg-character-type-mappings msg))))

(defun fatten-string-in-place (str type-array)
  (let ((new-str (make-array (array-dimensions str) :leader-list (list-array-leader str)
			     :element-type 'character))
	(str str)
	(type-array type-array))
    (declare (sys:array-register-1d str new-str)
	     (sys:array-register type-array))
    (loop for i below (zl:array-length str)
	  for byte = (sys:%1d-aref str i)
	  do (setf (sys:%1d-aref new-str i)
		   (int-char (dpb (aref type-array (ldb (byte 8 8) byte))
				  sys:%%char-all-but-subindex
				  (ldb (byte 8 0) byte)))))
    (structure-forward str new-str)
    new-str))

(defun fatten-the-thin-strings-to-new-type-0 (msg new-type-0)
  (labels ((change-interval-type-0 (type first-bp &optional last-bp in-order-p)
	     (unless (eq type :leader)
	       (get-interval first-bp last-bp in-order-p)
	       (loop with start-line = (bp-line first-bp)
		     with end-line = (bp-line last-bp)
		     for line = start-line then (line-next-in-buffer line)
		     for new-line = (zwei:create-line 'art-fat-string (line-length line) nil)
		     do (copy-array-contents-and-leader line new-line)
			(let ((new-line new-line))
			  (declare (sys:array-register new-line))
			  (loop for i below (line-length new-line)
				do
			    (setf (aref new-line i)
				  (zwei:in-current-style (aref new-line i) new-type-0))))
			(structure-forward line new-line)
		     until (eq line end-line)))))
    (map-over-msg-intervals msg #'change-interval-type-0)))
