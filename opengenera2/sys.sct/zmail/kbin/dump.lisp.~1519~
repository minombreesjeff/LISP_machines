;;; -*- Syntax: Common-lisp; Lowercase: Yes; Mode: LISP; Package: KBIN -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>


;;; Things named KBIN-XDUMP take locatives to the object being dumped.
;;; Things named KBIN-DUMP take the actual object being dumped.

;;;; Dumping

(defun kbin-dump-opcode (stream opcode &optional (object *no-value-marker*))
  ;; This business detects failure to dump the object we think we're putting
  ;; into the table, because of a bogus conditionalization, etc.  It does not
  ;; detect any sort of forward referencing or anything like that.
  (let ((object (follow-forwarding object)))
    (unless (eq object *no-value-marker*)
      (when *next-object-table*
	(unless (eq object *next-object-table-object*)
	  (error "Dumping ~S into ~:[temporary~;permanent~] table~%when we expected ~S."
		 object
		 (ecase *next-object-table*
		   (:temporary nil)
		   (:permanent t))
		 *next-object-table-object*))
	(let ((level-1 (level-1 opcode)))
	  (select level-1
	    (kbin-command
	     (setf (level-1 opcode)
		   (ecase *next-object-table*
		     (:temporary kbin-temporary-command)
		     (:permanent kbin-permanent-command))))
	    (otherwise
	     (let ((mapping (assoc level-1 *level-one-table-codes*)))
	       (if mapping
		   (setf (level-1 opcode)
			 (ecase *next-object-table*
			   (:temporary (second mapping))
			   (:permanent (third mapping))))
		 (send stream :tyo
		       (ecase *next-object-table*
			 (:temporary (dpb kbin-temporary-command (byte 8 8) kbin-value))
			 (:permanent (dpb kbin-permanent-command (byte 8 8) kbin-value))))))))
	  )
	(setq *next-object-table* nil
	      *next-object-table-object* nil)))
    (when *dump-command-history*
      (command-history-push-op opcode object *dump-command-history*))
    (send stream :tyo opcode)))
;;; Copy one level into *zmail-header-area*.
(defun copy-into-zmail-area-1 (object &optional (area *zmail-header-area*))
  (macrolet ((doit (follow forward copy)
	       `(let ((object (,follow object)))
		  (if (= (sys:%area-number object) area)
		      object
		    (let ((new-object (,copy object area)))
		      (,forward object new-object)
		      new-object)))))
    (labels ((copy-string (string area)
	       (let ((new-string (zl:make-array (length string)
						:area area
						:type (sys:array-type string)
						:leader-length (array-leader-length string))))
		 (copy-array-contents-and-leader string new-string)
		 new-string)))
      (typecase object
	(cons
	  (doit sys:follow-list-forwarding forward-list-to-its-copy copylist))
	(string
	  (doit sys:follow-structure-forwarding structure-forward copy-string))
	(bignum
	  (doit identity ignore si:copy-extended-number))
	(otherwise object)))))
(defun forward-list-to-its-copy (old-list new-list)
  (without-interrupts				;this shouldn't be necessary
    (sys:%p-store-cdr-type-and-pointer (sys:follow-list-forwarding old-list)
				       sys:cdr-nil sys:dtp-header-forward
				       new-list)))
(defun follow-forwarding (object)
  (typecase object
    (cons
      (sys:follow-list-forwarding object))
    (string
      (sys:follow-structure-forwarding object))
    (otherwise
      object)))

;;; Slightly different message than when we're dumping.
(defun enter-unbound-load-array-location-handler (.error. &optional ignore)
  (unbound-load-array-location-handler-1 .error. nil))

(defun kbin-dump-file-property-list (stream size-estimate property-list dumped-msg-count)
  (send *string-dumper* :reset-character-types)	D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Don't use leftovers.
0  (condition-bind ((sys:bad-data-type-in-memory #'enter-unbound-load-array-location-handler))
    (command-body
      (unless (variable-boundp *kbin-load-table*)
	(setq *kbin-load-table* (make-array #o400)))
      (fill-array-with-nulls *kbin-load-table*)
      (when *dump-table-history*
	(command-history-reset *dump-table-history*))
      (when *permanent-dump-table-history*
	(command-history-reset *permanent-dump-table-history*))
      (when *dump-command-history*
	(command-history-reset *dump-command-history*))
      (send *kbin-dump-table* :clear-hash)
      (setq *kbin-table-index* 0)
      1;; Record the 0KBIN1 format used along with the current version of 0Zmail
      1;; and the first version of 0Zmail1 that could have written this file.
0      (kbin-dump-opcode stream kbin-format-version *kbin-format-version*)
      (command-body
	(kbin-dump-integer stream *kbin-format-version*)
	(multiple-value-bind (zmail-major-version zmail-minor-version)
	    (sct:get-system-version :Zmail)
	  (kbin-dump-integer stream zmail-major-version)
	  (kbin-dump-integer stream zmail-minor-version))
	(multiple-value-bind (format-major-version format-minor-version)
	    (get-zmail-version-for-kbin-version *kbin-format-version* :first)
	  (kbin-dump-integer stream format-major-version)
	  (kbin-dump-integer stream format-minor-version)))
      1;; Record the estimated size of the load table and setup the table
0      (kbin-dump-opcode stream kbin-load-table-estimate size-estimate)
      (if (or (not (variable-boundp *kbin-permanent-load-table*))
	      (null *kbin-permanent-load-table*))
	  (setq *kbin-permanent-load-table* (make-array (min size-estimate 400)))
	(when (< (zl:array-length *kbin-permanent-load-table*)
		 (* size-estimate .75))
	  (setq *kbin-permanent-load-table*
		(make-array (min size-estimate 400)))))
      (fill-array-with-nulls *kbin-permanent-load-table*)
      (command-body
	(kbin-dump-integer stream size-estimate))
      1;; Now begin dumping the property list
0      (kbin-dump-opcode stream kbin-file-property-list property-list)
1      ;; Record the string dumper version where it will be loaded for effect
0      (kbin-dump-opcode stream kbin-hairy-version bin:*string-dump-format*)
      (command-body
	(kbin-dump-integer stream bin:*string-dump-format*))
      1;; Record the list of additional parsed header fields where it will be loaded for effect
0      (kbin-dump-opcode stream kbin-additional-parsed-header-fields
			       *additional-parsed-header-fields*)
      (command-body
	(kbin-dump-list stream *additional-parsed-header-fields*))
      1;; Record the number of messages in the file where it will be loaded for effect.
0      (kbin-dump-opcode stream kbin-dumped-msg-count dumped-msg-count)
      (command-body
	(kbin-dump-integer stream dumped-msg-count))
      1;; Actually dump the property list
0      (command-body
	(kbin-dump-list stream property-list)))))

;;; If non-NIL, we are dumping the status of the message.  Any lines should be entered
;;; into the dump table, so that they will be EQ to the corresponding part of the interval.
(defvar *dumping-msg-status* nil)

(defun kbin-dump-msg (stream *msg-self*)
  (send *string-dumper* :reset-character-types)	;So we can someday do random-access to msgs
  (condition-bind ((sys:bad-data-type-in-memory #'enter-unbound-load-array-location-handler))
    (command-body
      (send *kbin-dump-table* :clear-hash)
      (setq *kbin-table-index* 0)
      (fill-array-with-nulls *kbin-load-table*)
      (kbin-dump-opcode stream kbin-msg *msg-self*)
      (command-body
	(kbin-dump-msg-status stream *msg-self*))
      (command-body
	(kbin-dump-interval-internal stream (msg-interval *msg-self*) kbin-msg-interval))
      (command-body
	(let ((summary-line (msg-summary-line *msg-self*)))
	  (when summary-line
	    (if (not (string-fat-p summary-line))
		(kbin-dump-string-internal stream summary-line nil kbin-msg-summary-line)
		(kbin-dump-hairy-string-internal stream summary-line nil
						 kbin-hairy-msg-summary-line))
	    (kbin-dump-permanent-equal (stream *zmail-summary-area*)
				       (template (summary-line-template summary-line))
	      (kbin-xdump-object stream (locf (summary-line-template summary-line)))))))
      (kbin-dump-opcode stream kbin-msg-flags (msg-flags *msg-self*))
      (command-body
	(kbin-dump-integer stream (msg-flags *msg-self*)))
      (kbin-dump-opcode stream kbin-end-of-msg *msg-self*))))

;;; Start dumping a list.  This supplies the opcode and the length to
;;; construct a list; the caller is responsible for dumping the elements
;;; of the list.  See the macro KBIN-DUMP-LIST-X for a convenient way
;;; to do this.
(defun kbin-dump-list-init (stream object &optional plist-type msg length)
  (let ((length (or length (list-length object))))
    (unless length
      (error "Cannot dump circular list ~Q." #'(lambda () (write object :circle t))))
    (when (and plist-type (oddp length))
      (error "Cannot dump odd length ~A property-list ~:[here~*~;in message ~S~]."
	     plist-type msg msg))
    (if (< length (lsh 1 8))
	(kbin-dump-opcode stream (dpb kbin-immediate-list (byte 8 8) length) object)
      (kbin-dump-opcode stream kbin-list object)
      (kbin-dump-integer stream length))
    length))

(defun compact-msg-status-list (msg)
  (let ((status (msg-status msg)))
    (unless (loop for l on status
		  for cdr-code = (sys:%p-cdr-code l)
		  always (sys:%area-number l)
		  always (or (= cdr-code sys:cdr-next)
			     (= cdr-code sys:cdr-nil)))
      (loop with new-status = (make-list (list-length status) :area *zmail-msg-area*)
	    for nl on new-status
	    for i in status
	    do (setf (car nl) i)
	    finally (setq status new-status))
      (setf (msg-status msg) status))
    status))

;;; T means to copy the status list whenever it is non-contiguous or
;;; in the wrong area.  NIL means to copy it only if it's in the wrong area.
(defvar *copy-msg-status-list* t)

(defun kbin-dump-msg-status (stream *msg-self*)
  (when *copy-msg-status-list*
    (compact-msg-status-list *msg-self*))
  (dump-into-area (stream *zmail-msg-area*)
		  (status (msg-status *msg-self*))
    (kbin-dump-opcode stream kbin-msg-status *msg-self*)
    (command-body
      (kbin-dump-plist (stream status "status")
		       (ind nil val-loc)
	(if (keywordp ind)
	    (kbin-xdump-parsed-header stream ind val-loc)
	  (case ind
	    (references (kbin-xdump-references stream val-loc))
	    (msg-ids (kbin-xdump-msg-ids stream val-loc))
	    (headers-end-bp (kbin-xdump-bp stream val-loc))
	    (zwei:draft-msg
	      1;; The (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")draft-msg1 property is the actual draft which was saved as this message --
	      ;;    Don't bother dumping its value as it can't be recreated when the file
	      ;;    is reloaded.  Instead, we'll just let the 0Continue1 or 0Reply1 commands
	      ;;    create a new draft message from whole cloth as they're already quite
	      ;;    willing to do.
0	      (kbin-dump-opcode stream kbin-nil nil))
	    (otherwise
	      (kbin-xdump-object stream val-loc))))))))

(defun kbin-dump-line-contents-plist (stream string)
  (dump-into-area (stream *zmail-msg-line-area*)
		  (line-contents-plist (line-contents-plist string))
    (kbin-dump-opcode stream kbin-set-line-contents-plist line-contents-plist)
    (command-body
      (kbin-dump-string stream string t t)
      (kbin-dump-plist-case (stream line-contents-plist "line contents plist")
			    (indicator value value-location)
	(parsed-headers (kbin-xdump-parsed-headers stream value-location))
	(otherwise nil)))))

1;;; We put the top level of this in the line area, since it's only needed if
;;; we're hacking the lines in some way.
0(defun kbin-xdump-parsed-headers (stream headers-loc)
  1;; We must move the object beforehand, since 2kbin-dump-temporary1 insists on
0  1;; dumping the object we started with.  Moving the 2kbin-dump-temporary1 inside
0  1;; a 2dump-into-area1 could result in redundant area-shifts, so we do this by
0  1;; hand.
0  (with-line-setups-delayed (stream)
    (msg-areaf (location-contents headers-loc) *zmail-msg-line-area*)
    (kbin-dump-temporary (stream (location-contents headers-loc))
      (let ((headers (location-contents headers-loc)))
	(dumping-into-area (stream *zmail-msg-line-area* headers)
	  (kbin-dump-plist (stream headers "parsed headers")
			   (ind val val-loc)
	    (kbin-xdump-parsed-header stream ind val-loc)))))))

(defun kbin-dump-line-plist (stream string)
  (dump-into-area (stream *zmail-msg-line-area*)
		  (line-plist (zwei:line-plist string))
    (kbin-dump-opcode stream kbin-set-line-plist line-plist)
    (command-body
      (kbin-dump-string stream string t t)
      (kbin-dump-plist-case (stream line-plist "line plist")
			    (indicator value value-location)
	(:diagram
	  1;; Diagram property can be null if this message was originally a draft that's
	  ;; been stored in the buffer and said draft at one time actually used diagrams. 
0	  (if value
	      (kbin-dump-diagram stream value)
	      (kbin-dump-opcode stream kbin-nil value)))
	(otherwise nil)))))

1;;; Dump a diagram by asking it for a form that will recreate it --
;;;    All diagrams are based on 2zwei:line-diagram-mixin1 which has a default method for
;;;    the 2:form-for-file1 message so we don't have to worry about undumpable diagrams.
0(defun kbin-dump-diagram (stream diagram)
  (let ((form (send diagram :form-for-file)))
    (dumping-into-area (stream *zmail-msg-line-area* diagram)
      (kbin-dump-opcode stream kbin-diagram diagram)
      (command-body
	(dumping-into-area (stream sys:working-storage-area form)
	  (let ((function (car form))
		(arguments (cdr form)))
	    (kbin-dump-list-init stream form)
	    (command-body
	      (typecase function
		(symbol (kbin-dump-symbol stream function))
		(list (kbin-dump-permanent-equal (stream sys:working-storage-area)
						 (nil function)
			(kbin-dump-list stream function)))
		(otherwise (kbin-dump-ferror function)))
	      (dumping-into-area (stream *zmail-msg-line-area* arguments)
		(dolist (argument arguments)
		  (typecase argument
		    (list
		      (if (and (eq (first argument) 'quote)
			       (= (length argument) 2)
			       (compiler:constant-form-p (second argument)))
			  1;; Self-evaluating object.
0			  (kbin-xdump-object stream (locf (second argument)))
			(kbin-xdump-object stream (locf argument))))
		    (otherwise
		      (kbin-xdump-object stream (locf argument)))))))))))))

(defun kbin-xdump-parsed-header (stream ind header-loc)
  (dump-into-area (stream *zmail-header-area*)
		  (nil (location-contents header-loc))
    (with-line-setups-delayed (stream)
      (header-type-typecase ind
	(:address (kbin-xdump-addresses stream header-loc))
	(:date (kbin-xdump-date stream header-loc))
	((:message-id :subject)
	 (kbin-xdump-string-or-list-header stream header-loc))
	(:reference
	  (kbin-xdump-references stream header-loc))
	(:received
	  (kbin-xdump-received-header stream header-loc))
	(otherwise
	  (kbin-xdump-object stream header-loc))))))

(defun kbin-xdump-string-or-list-header (stream header-loc)
  (dump-into-area (stream *zmail-header-area*)
		  (header (location-contents header-loc))
    (etypecase header
      (list (kbin-dump-permanent-equal (stream *zmail-header-area*)
				       (header (location-contents header-loc))
	      (kbin-dump-list-init stream header)
	      (loop for h on header
		    do (kbin-xdump-string stream (locf (car h))))))
      (string
	(kbin-xdump-string stream header-loc)))))

1;;; 0Received1 field is a list of lists of strings.
0(defun kbin-xdump-received-header (stream header-loc)
  (kbin-dump-list-x (stream (location-contents header-loc) *zmail-header-area*)
		    (nil rcpt-loc)
    (dump-into-area (stream *zmail-header-area*)
		    (rcpt (location-contents rcpt-loc))
      (kbin-xdump-string-or-list-header stream rcpt-loc))))

;;; Assumption:  It's not worth trying to fold lists of references, just the
;;; individual references.  Some savings, yes, but how many people reply to any
;;; individual message?

(defun kbin-xdump-references (stream references-loc)
  (kbin-dump-list-x (stream (location-contents references-loc) *zmail-header-area*)
		    (nil ref-loc)
    (kbin-xdump-reference stream ref-loc)))

(defun kbin-xdump-reference (stream reference-loc)
  (typecase (location-contents reference-loc)
    (string (kbin-xdump-string stream reference-loc))
    (list (if (and (getf (location-contents reference-loc) :date)
		    (getf (location-contents reference-loc) :from))
	       (kbin-xdump-list-reference stream reference-loc)
	     (if (getf (location-contents reference-loc) :message-id)
		 (kbin-xdump-message-id-reference stream reference-loc)
	       (kbin-dump-permanent-equal (stream *zmail-header-area*)
					  (reference (location-contents reference-loc))
		 (kbin-xdump-object stream reference-loc)))))
    (otherwise
      (kbin-dump-permanent-equal (stream *zmail-header-area*)
				 (reference (location-contents reference-loc))
	(kbin-xdump-object stream reference-loc)))))

(defun kbin-xdump-message-id-reference (stream reference-loc)
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (reference (location-contents reference-loc))
    (if ( (list-length reference) 2)
	(kbin-xdump-object stream reference)
      (kbin-dump-opcode stream kbin-message-id-reference reference)
      (command-body
	(kbin-xdump-string stream (locf (second reference)))))))

;;; Dump a :reference type header that is in list form.
(defun kbin-xdump-list-reference (stream reference-loc)
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (reference (location-contents reference-loc))
    (cond ((and (= (list-length reference) 4)
		(loop for (ind) on reference by 'cddr
		      always (or (eq ind ':from) (eq ind :date))))
	   ;; Special (normal) case: only :DATE and :FROM
	   (kbin-dump-opcode stream kbin-list-reference reference)
	   (command-body
	     (kbin-xdump-date stream (locf (getf (location-contents reference-loc) :date)))
	     (kbin-xdump-address stream (locf (getf (location-contents reference-loc) :from)))))
	  (t ;; other cruft, do it the hard way.
	   (kbin-dump-plist (stream reference "reference")
			    (ind val val-loc)
	     (case ind
	       (:from (kbin-xdump-address stream val-loc))
	       (:date (kbin-xdump-date stream val-loc))
	       (otherwise (dump-into-area (stream *zmail-header-area*)	;? Reasonable?
					  (nil (location-contents val))
			    (kbin-xdump-object stream val-loc)))))))))

;;; It is assumed that only a message would have it's list of ids, everyone else would
;;; just use references.  Hence we don't compact a list of ID's.

(defun kbin-xdump-msg-ids (stream ids-loc)
  (kbin-dump-list-x (stream (location-contents ids-loc) *zmail-header-area*)
		    (nil id-loc)
    (kbin-xdump-msg-id stream id-loc)))

(defun kbin-xdump-msg-id (stream id-loc)
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (id (location-contents id-loc))
    (kbin-dump-opcode stream kbin-cons id)
    (command-body
      (kbin-dump-integer stream (car id))
      (kbin-xdump-reference stream (locf (cdr id))))))

(defun kbin-xdump-addresses (stream addresses-loc)
  ;; Do this BEFORE putting it into the table with the wrong hash key!
  (loop for adr-list on (location-contents addresses-loc)
	for adr-loc = (locf (car adr-list))
	do (convert-intervals-to-string adr-loc))
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (addresses (location-contents addresses-loc))
    (kbin-dump-list-x (stream addresses)
		      (nil address-loc)
      (kbin-xdump-address stream address-loc))))

;;; All this :ORIGINAL-STRING hackery should now be obsolete.
;;; Zmail does this for itself.

;;; All these STRING-INTERVAL's cons.  Too bad there isn't a way to
;;; first check whether the needed string exists.  Need a kind of hash
;;; table which takes strings with start and end indicies...

(defun convert-intervals-to-string (address)
  (flet ((convert-intervals-to-string-normal (address)
	  (let ((interval (getf (location-contents address) :interval)))
	    (when interval
	      (loop for l on (location-contents address) by 'cddr
		    for (tag val) = l
		    when (eq tag :interval)
		    do (setf (first l) :original-string
			     (second l) (string-interval (first val) (second val) t))
		    (return nil))))))
    (let ((inferiors (getf (location-contents address) :inferiors)))
      (if (null inferiors)
	  (convert-intervals-to-string-normal address)
	(convert-intervals-to-string-inferiors address)
	(convert-intervals-to-string-normal address)))))

(defun convert-intervals-to-string-inferiors (address)
  (let* ((inferiors (getf (location-contents address) :inferiors))
	 (top-interval (getf (location-contents address) :interval))
	 (top-start (first top-interval))
	 (top-end (second top-interval))
	 (last-inf (car (last inferiors)))
	 (last-inf-end (second (getf last-inf :interval))))
    (loop for i on inferiors
	  for start first top-start then iend
	  for (istart iend) = (getf (first i) :interval)
	  when istart
	    do (remf (first i) :interval)
	       (setf (first i)
		     (nconc (first i) `(:initial-string ,(string-interval start istart))))
	       (convert-intervals-to-string (locf (first i))))
    (when (and last-inf-end top-end)
      (setf (location-contents address)
	    (nconc (location-contents address)
		   `(:final-string ,(string-interval last-inf-end top-end)))))))

(defun kbin-xdump-address (stream address-loc)
  ;; Do this BEFORE putting it into the table with the wrong hash key!
  (convert-intervals-to-string address-loc)
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (address (location-contents address-loc))
    (kbin-dump-plist (stream address "address")
		     (ind val val-loc)
      (case ind
	(:name (kbin-xdump-string stream val-loc))
	(:host (kbin-xdump-general-host stream val-loc))
	((:original-string :initial-string :final-string
	  :personal-name :distribution-list)
	 (kbin-xdump-string stream val-loc))
	(:inferiors (kbin-xdump-addresses stream val-loc))
	(:interval (error "Interval still found in address ~S."
			  (location-contents address-loc)))
	(otherwise (kbin-xdump-object stream val-loc))))))

(defun kbin-xdump-general-host (stream host-loc)
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (host (location-contents host-loc))
    (typecase host
      (list (if (and (eq (car host) :object)
		     (= (list-length host) 2))
		(kbin-dump-object-host stream host)
	      (kbin-dump-list stream host)))
      (otherwise (kbin-xdump-object stream host-loc)))))

;;; Dump a :OBJECT type host.
(defun kbin-dump-object-host (stream host)
  (let* ((object (second host))
	 (iname (condition-case ()
		     (send object :mail-name)
		   (neti:namespace-object-deleted
		     (let ((nicknames (send object :get :nickname)))
		       (if (not nicknames) "DELETED"
			 (let* ((nickname (first nicknames))
				(namespace (send nickname :namespace))
				(domain-name (send namespace :internet-domain-name)))
			   (if (not domain-name)
			       (send nickname :string)
			     (string-append (send nickname :string) "." domain-name)))))))))
    (kbin-dump-opcode stream kbin-object-host host)
    (command-body
      (dumping-into-area (stream sys:working-storage-area iname)
	(kbin-dump-string stream iname)))))

;;; Really, KBIN-DUMP-TEMPORARY should be taking an AREA argument; we shouldn't
;;; be copying if we've already seen it!
(defun kbin-xdump-bp (stream bp-loc)
  (dump-into-area (stream *zmail-msg-line-area*)
		  (bp (location-contents bp-loc))
    (kbin-dump-temporary (stream bp)
      (with-line-setups-delayed (stream)
	(kbin-dump-opcode stream
			  (ecase (bp-status bp)
			    ((nil) kbin-bp)
			    (:normal kbin-bp-normal)
			    (:moves kbin-bp-moves))
			  bp)
	(command-body
	  (kbin-dump-string stream (bp-line bp) t t)
	  (kbin-dump-integer stream (bp-index bp)))))))

;;; Dump a "pair" of BP's (i.e. a list of two BP's)
(defun kbin-xdump-bp-pair (stream object-loc)
  (dump-into-area (stream *zmail-msg-line-area*)
		  (object (location-contents object-loc))
    (unless (and object
		 (cdr object)
		 (null (cddr object)))
      (error "Attempt to dump BP pair of length  2"))
    (with-line-setups-delayed (stream)
      (kbin-dump-list-init stream object)
      (command-body
	(kbin-xdump-bp stream (locf (first object)))
	(kbin-xdump-bp stream (locf (second object)))))))

;;; Separate function to make it easier to experiment
(defun kbin-xdump-date (stream date-loc)
  (kbin-dump-permanent-equal (stream *zmail-header-area*)
			     (nil (location-contents date-loc))
    (kbin-xdump-object stream date-loc)))

(defun kbin-dump-character (stream character)
  (let ((bits (char-bits character))
	(style (si:char-style character)))
    (multiple-value-bind (charset index)
	(si:char-char-set-and-index character)
      (let ((charset-name (send charset :name)))
	(kbin-dump-opcode stream kbin-character character)
	(command-body
	  (kbin-dump-integer stream bits)
	  (kbin-dump-character-style stream style)
	  (kbin-dump-symbol stream charset-name)
	  (kbin-dump-integer stream index))))))

1;;; Dump an arbitrary "random" object --
;;;    Nothing here makes use of the locative to actually modify things
;;;    but this is an "2xdump1" form, just in case.
0(defun kbin-xdump-object (stream object-loc)
  (let ((object (location-contents object-loc)))
    (typecase object
      (number (kbin-dump-number stream object))
      (null (kbin-dump-opcode stream kbin-nil object))
      (list (kbin-dump-list stream object))
      (symbol (kbin-dump-symbol stream object))
      (interval (kbin-dump-interval stream object))
      (fs:pathname (kbin-dump-pathname stream object))
      (net:host (kbin-dump-host stream object))
      (neti:namespace (kbin-dump-namespace stream object))
      (si:user (kbin-dump-user stream object))
      (zl:font (kbin-dump-font stream object))
      (zl:error (kbin-dump-error stream object))
      (msg
	(if (eq object *msg-self*)
	    (kbin-dump-msg-self stream object)
	  (error "Cannot dump references to other messages.")))
      (character-style
	(kbin-dump-character-style stream object))
      (instance
	(kbin-dump-instance stream object))
      (array
	(case (zl:array-type object)
	  ((art-string art-fat-string)
	   (let ((leader-length (array-leader-length object)))
	     (cond ((or (null leader-length) ( leader-length 1))
		    (kbin-dump-string stream object))
		   ((= leader-length line-leader-size)
		    1;; If we're dumping a line at random, we'd better force it into the table.
0		    (kbin-dump-string stream object t t))
		   (t
		    (error "Cannot dump this string: ~S" object)))))
	  (art-q
	    1;; Support dumping the value of the 2zwei:scroll-item-displayer1 property.
0	    (if (and (eql (array-leader-length object) 2)
		     (= (zl:array-length object) 4)
		     (null (fill-pointer object))
		     (listp (array-leader object 1))
		     (eq (car (array-leader object 1)) 'summary-mouse)
		     (eq (second (array-leader object 1)) *msg-self*))
		(kbin-dump-scroll-item-displayer stream object)
	      (kbin-dump-ferror object)))
	  (sys:art-8b
	    1;; Support dumping the binary encoding of a graphics diagram.
0	    (if (and (let ((leader-length (array-leader-length object)))
		       (or (null leader-length)
			   (= leader-length 0)))
		     (= (length (array-dimensions object)) 1))
		(kbin-dump-graphics-diagram-binary-encoding stream object)
	      (kbin-dump-ferror object)))
	  (otherwise
	    (kbin-dump-ferror object))))
      (character (kbin-dump-character stream object))
      (otherwise (kbin-dump-ferror object)))))

(defun kbin-dump-msg-self (stream object)
  (unless (eq object *msg-self*)
    (error "Attempt to dump a reference ~S when it is not the current message." object))
  (kbin-dump-opcode stream kbin-msg-self object))

(defun kbin-dump-instance (stream object)
  (if (not (send object :operation-handled-p :kbin-file-form))
      (kbin-dump-ferror object)
    (let ((form (send object :kbin-file-form)))
      (kbin-dump-opcode stream kbin-instance object)
      (command-body
	(kbin-dump-function-call stream form)))))

;;; This is assumed to be a function at top level.  We should really be using
;;; the language tools here.

;;; Part of the reason for this hair, is to keep from dumping the same code
;;; over and over again.  The priority tools, for example, include a large
;;; quoted list, that we just want to dump *ONCE*.  Otherwise, our file gets
;;; too huge.

;;; The function called had better not depend on the lines being set up.
;;; The setup for any lines contained happens AFTER the function is called.

(defun kbin-dump-function-call (stream call)
  (let ((fun (car call))
	(args (cdr call)))
    (kbin-dump-list-init stream call)
    (command-body
      (typecase fun
	(symbol (kbin-dump-symbol stream fun))
	(list (kbin-dump-permanent-equal (stream sys:working-storage-area)
					 (nil fun)
		(kbin-dump-list stream fun)))
	(otherwise (kbin-dump-ferror fun)))
      (with-line-setups-delayed (stream)
	(loop for arg in args
	      do (typecase arg
		   (list (if (eq (car arg) 'quote)
			     (kbin-dump-permanent-equal (stream sys:working-storage-area)
							(nil arg)
			       (unless (and (listp (cdr arg)) (null (cddr arg)))
				 (error "Illegal quoted form; can't be dumped:  ~S" arg))
			       (kbin-dump-list-init stream arg)
			       (command-body
				 (kbin-dump-symbol stream 'quote)
				 (kbin-dump-permanent-equal (stream sys:working-storage-area)
							    (val (second arg))
				   (kbin-xdump-object stream (locf val)))))
			   (kbin-xdump-object stream (locf arg))))
		   (otherwise (kbin-xdump-object stream (locf arg)))))))))

(defun kbin-dump-scroll-item-displayer (stream object)
  object
  (kbin-dump-opcode stream kbin-scroll-item-displayer object))
1;;; Dump the binary encoding of a graphics diagram.
0(defun kbin-dump-graphics-diagram-binary-encoding (stream binary-encoding)
  (dumping-into-area (stream *zmail-msg-line-area* binary-encoding)
    (kbin-dump-opcode stream kbin-graphics-diagram-binary-encoding binary-encoding)
    (let* ((array-size (array-dimension binary-encoding 0))
	   (words-to-dump (ceiling array-size 2)))
      (kbin-dump-integer stream array-size)
      (dotimes (i words-to-dump)
	(let* ((first-byte-index (* i 2))
	       (second-byte-index (when (< (1+ first-byte-index) array-size)
				    (1+ first-byte-index)))
	       (encoded-bytes
		 (dpb (aref binary-encoding first-byte-index) (byte 8 8)
		      (dpb (if second-byte-index (aref binary-encoding second-byte-index) 0)
			   (byte 8 0) 0))))
	  (send stream :tyo encoded-bytes))))))

1;;; Dump any kind of number.
0(defun kbin-dump-number (stream number)
  (typecase number
    (integer (kbin-dump-integer stream number))
    (ratio (kbin-dump-ratio stream number))
    (float (kbin-dump-float stream number))
    (complex (kbin-dump-complex stream number))))

1;;; Dump any kind of integer.
0(defun kbin-dump-integer (stream integer)
  (if ( *min-immediate-integer* integer *max-immediate-integer*)
      (kbin-dump-opcode stream
			(encode-immediate-integer integer)
			integer)
    (flet ((dump-integer ()
	     (if (not (minusp integer))
		 (kbin-dump-opcode stream kbin-large-integer integer)
	       (kbin-dump-opcode stream kbin-large-negative-integer integer)
	       (setq integer (- integer)))
	     (let ((length (truncate (+ (integer-length integer) 15.) 16.)))
	       (command-body
		 (kbin-dump-integer stream length)
		 (dotimes (i length)
		   (let ((pos (* i 16.)))
		     (send stream ':tyo (ldb (byte 16. pos) integer))))))))
      (if *next-object-table*			;Don't put in table if already putting
	  (dump-integer)			;something in table (kludge)
	(kbin-dump-temporary (stream integer)
	  (dump-integer))))))

1;;; Split into a separate subroutine so it can be called by 2zwei:kbin-msg-file-format-p1.
0(defun encode-immediate-integer (integer)
  (+ (dpb kbin-immediate-integer (byte 8 8) 0)
     (ldb %immediate-integer-byte (- integer *min-immediate-integer*))))

(defun kbin-dump-ratio (stream ratio)
  (kbin-dump-opcode stream kbin-ratio ratio)
  (command-body
    (kbin-dump-integer stream (numerator ratio))
    (kbin-dump-integer stream (denominator ratio))))

(defun kbin-dump-float (stream float)
  (flet ((dump-fixnum (fixnum)
	   (send stream :tyo (sys:%logldb (byte 16 00) fixnum))
	   (send stream :tyo (sys:%logldb (byte 16 16) fixnum))))
    (typecase float
      (single-float
	(kbin-dump-opcode stream kbin-single-float float)
	(let ((float-as-fixnum (sys:%fixnum float)))
	  (dump-fixnum float-as-fixnum)))
      (double-float
	(kbin-dump-opcode stream kbin-double-float float)
	(let ((low-part-as-fixnum (sys:double-low float))
	      (high-part-as-fixnum (sys:double-high float)))
	  (dump-fixnum low-part-as-fixnum)
	  (dump-fixnum high-part-as-fixnum))))))

(defun kbin-dump-complex (stream complex)
  (kbin-dump-opcode stream kbin-complex complex)
  (kbin-dump-number stream (realpart complex))
  (kbin-dump-number stream (imagpart complex)))

(defun kbin-dump-list (stream list)
  (loop for l on list
	count t into length
	as dotify = (atom l)
	until dotify
	finally (cond ((and (not dotify) (< length (lsh 1 8)))
		       (kbin-dump-opcode stream (dpb kbin-immediate-list (byte 8 8)
						     length)
					 list))
		      ((and dotify (= length 2))
		       (kbin-dump-opcode stream kbin-cons list))
		      (t (kbin-dump-opcode stream
					   (if dotify kbin-list* kbin-list)
					   list)
			 (command-body (kbin-dump-integer stream length))))
	(command-body
	  (loop for i from 0 below length
		for ol = (locf list) then l
		for l = list then (cdr l)
		for item-loc = (if (and dotify (= i (1- length)))
				   (locf (cdr ol))
				 (locf (car l)))
		do (kbin-xdump-object stream item-loc)))))

(defun kbin-xdump-string (stream string-loc &optional (area *zmail-header-area*))
  (kbin-dump-permanent-equal (stream area)
			     (string (location-contents string-loc))
    (kbin-dump-string stream string)))

(defun lookup-area-opcode (area-value)
  (loop for (area-name opcode-name) in *zmail-area-table*
	when (= (eval area-name) area-value)
	do (return (values area-name (eval opcode-name)))
	finally (error "~D is not a known area number.  See *ZMAIL-AREA-TABLE*.")))
(defun kbin-dump-string (stream string &optional (line-p nil) force-into-table)
  (let* ((line-contents-plist (when line-p (line-contents-plist string)))
	 (line-plist (when line-p (zwei:line-plist string)))
	 (bps (when line-p (line-bp-list string))))
    1;; Determine if we must force the line into the table --
0    1;;    2bp1's --
0    1;;       We don't really need to force the line into the table.  Instead, we could
0    1;;       just check to see if it's already there because we always dump the 2bp1's
0    1;;       first and they always force the line into the table.
0    1;;    2line-plist1 or 2line-contents-plist1 --
0    1;;       The line must be in the table to insure that, when loading, setting the
0    1;;       2line-plist1 or 2line-contents-plist1 refers to the identical string.
0    (when (or line-contents-plist line-plist bps)
      (setq force-into-table t))
    (flet ((dump-string (stream string)
	     (let ((fat-p (string-fat-p string)))
	       (multiple-value-bind (immediate-opcode long-opcode function)
		   (if (not line-p)
		       (if fat-p
			   (values nil kbin-hairy-string #'kbin-dump-hairy-string-internal)
			 (values kbin-immediate-string kbin-long-string
				 #'kbin-dump-string-internal))
		     (if fat-p
			 (values nil kbin-hairy-line #'kbin-dump-hairy-string-internal)
		       (values kbin-immediate-line kbin-line #'kbin-dump-string-internal)))
		 (funcall function stream string immediate-opcode long-opcode)))))
      (if force-into-table
	  (let ((dumped-string))
	    (kbin-dump-temporary (stream string)
	      (dump-string stream string)
	      (setq dumped-string t))
	    (when dumped-string
	      (when (or line-contents-plist line-plist bps)
		(if *delay-line-setups*
		    1;; Can't set the 2line-plist1 or 2line-contents-plist1 --
0		    1;;    We're already dumping something that's contained in it.
0		    (push string *delayed-line-setups*)
		  (when line-contents-plist
		    (kbin-dump-line-contents-plist stream string))
		  (when line-plist
		    (kbin-dump-line-plist stream string))))))
	(dump-string stream string)))))
(defun clean-up-delayed-line-setups (stream)
  (flet ((setup-line (line)
	   (let ((line-contents-plist (line-contents-plist line))
		 (line-plist (zwei:line-plist line)))
	     (when line-contents-plist
	       (kbin-dump-line-contents-plist stream line))
	     (when line-plist
	       (kbin-dump-line-plist stream line)))))
    (dolist (line *delayed-line-setups*)
      (setup-line line)))
  (setq *delayed-line-setups* nil))

(defun kbin-dump-string-internal (stream string immediate-opcode long-opcode)
  (let ((length (zl:string-length string)))
    (if (and immediate-opcode (< length (lsh 1 8)))
	(kbin-dump-opcode stream (dpb immediate-opcode (byte 8 8) length) string)
      (kbin-dump-opcode stream long-opcode string)
      (command-body (kbin-dump-integer stream length)))
    ;; From 0 to length; i.e. we only dump the active portion if it has a fill pointer.
    (si:with-indirect-array (buffer 'art-16b string 0 length)
      (send stream :string-out buffer)
      (when (oddp length)
	(send stream :tyo (char-int (char string (1- length))))))))

(defun kbin-dump-hairy-string-internal (stream string immediate-opcode long-opcode)
  (ignore immediate-opcode)
  (kbin-dump-opcode stream long-opcode string)
  (command-body
    (send *string-dumper* :dump-string string)))

(defun kbin-dump-character-style (stream style)
  (kbin-dump-permanent (stream style)
    (kbin-dump-opcode stream kbin-character-style style)
    (let ((style-spec (si:unparse-character-style style)))
      (dumping-into-area (stream sys:working-storage-area style-spec)
	(kbin-dump-list stream style-spec)))))

(defun kbin-dump-interval (stream interval)
  (kbin-dump-temporary (stream interval)
    (clean-up-delayed-line-setups stream)
    (kbin-dump-interval-internal stream interval kbin-interval)))

(defun kbin-dump-interval-internal (stream interval opcode)
  (dumping-into-area (stream *zmail-msg-line-area* interval)
    (kbin-dump-opcode stream opcode interval)
    (command-body
      (let* ((first-line (bp-line (interval-first-bp interval)))
	     (last-line (bp-line (interval-last-bp interval)))
	     (length (loop for line = first-line then (line-next line)
			   sum 1
			   until (eq line last-line))))
	(kbin-dump-integer stream length)
	(loop for line = first-line then (line-next line)
	      for start-p = t then nil
	      for end-p = (eq line last-line)
	      do (kbin-dump-string stream line t (or start-p end-p))
	      until end-p)))))

(defun kbin-dump-symbol (stream symbol)
  (macrolet ((dump-symbol (opcode)
	       `(kbin-dump-permanent (stream symbol)
		  (kbin-dump-opcode stream ,opcode symbol)
		  (command-body
		    (kbin-dump-string stream (symbol-name symbol))))))
    (select (symbol-package symbol)
      (sys:pkg-keyword-package (dump-symbol kbin-keyword))
      (*editor-package* (dump-symbol kbin-internal-keyword))
      (sys:pkg-global-package
       (case symbol
	 ((t) (kbin-dump-opcode stream kbin-t symbol))
	 ((nil) (kbin-dump-opcode stream kbin-nil symbol))
	 (otherwise (dump-symbol kbin-global-symbol))))
      (otherwise
       (kbin-dump-permanent (stream symbol)
	 (kbin-dump-opcode stream kbin-symbol symbol)
	 (command-body
	   (kbin-dump-string stream (package-name (symbol-package symbol)))
	   (kbin-dump-string stream (symbol-name symbol))))))))

;;; Some special kinds of objects.

(defun kbin-dump-pathname (stream pathname)
  (kbin-dump-temporary (stream pathname)
    (kbin-dump-opcode stream kbin-pathname pathname)
    (command-body
      (let ((string (string pathname)))
	(dumping-into-area (stream sys:working-storage-area string)
	  (kbin-dump-string stream string))))))

(defun kbin-dump-host (stream host)
  (kbin-dump-permanent (stream host)
    (let ((name (condition-case ()
		     (send host :primary-name)
		   (neti:namespace-object-deleted
		     (let ((nicknames (send host :get :nickname)))
		       (if (not nicknames) "DELETED"
			 (let* ((nickname (first nicknames))
				(namespace (send nickname :namespace))
				(domain-name (send namespace :internet-domain-name)))
			   (if (not domain-name)
			       (send nickname :string)
			     (string-append (send nickname :string) "." domain-name)))))))))
      (etypecase name
	(neti:name
	 (let* ((namespace (send name :namespace))
		(string (send name :string)))
	   (kbin-dump-opcode stream kbin-qualified-host host)
	   (command-body
	     (kbin-dump-namespace stream namespace)
	     (dumping-into-area (stream sys:working-storage-area string)
	       (kbin-dump-string stream string)))))
	(string
	 (kbin-dump-opcode stream kbin-host host)
	 (command-body
	   (dumping-into-area (stream sys:working-storage-area name)
	     (kbin-dump-string stream name))))))))

(defun kbin-dump-namespace (stream namespace)
  (kbin-dump-permanent (stream namespace)
    (let ((name (send namespace :name))
	  (domain (send namespace :internet-domain-name)))
      (cond ((and domain (not (string-equal domain (string name))))
	     (kbin-dump-opcode stream kbin-namespace-with-domain namespace)
	     (command-body
	       (kbin-dump-symbol stream name)
	       (dumping-into-area (stream sys:working-storage-area domain)
		 (kbin-dump-string stream domain))))
	    (t (kbin-dump-opcode stream kbin-namespace namespace)
	       (command-body
		 (kbin-dump-symbol stream name)))))))

(defun kbin-dump-user (stream user)
  (kbin-dump-permanent (stream user)
    (kbin-dump-opcode stream kbin-user user)
    (command-body
      (let ((string (string user)))
	(dumping-into-area (stream sys:working-storage-area string)
	  (kbin-dump-string stream string))))))

(defun kbin-dump-font (stream font)
  (kbin-dump-permanent (stream font)
    (kbin-dump-opcode stream kbin-font font)
    (command-body
      (kbin-dump-symbol stream (zl:font-name font)))))

(defun kbin-dump-error (stream error)
  (with-line-setups-delayed (stream)
    (kbin-dump-temporary (stream error)
      (kbin-dump-opcode stream kbin-error error)
      (flet ((dump-error (flavor init-options)
	       (command-body
		 (kbin-dump-symbol stream flavor)
		 (dumping-into-area (stream sys:working-storage-area init-options)
		   (kbin-dump-plist (stream init-options "error init options")
				    (nil nil val-loc)
		     (kbin-xdump-object stream val-loc))))))
	(if (operation-handled-p error :kbin-dump-init-options)
	    (dump-error (type-of error) (send error :kbin-dump-init-options))
	  ;; Unknown error, just preserve the report as a 2ferror0.
	  (let ((report-string (with-output-to-string (str)
				 (send error :report str))))
	    (stack-let ((init-options `(:format-string ,report-string :format-args nil)))
	      (dump-error 'zl:ferror init-options))))))))
	      

(defmethod (:kbin-dump-init-options parse-grammar-error) ()
  `(:token ,zwei:token))

(defmethod (:kbin-dump-init-options time:parse-error) ()
  `(:time-string ,time:time-string
    :format-string ,dbg:format-string :format-args ,dbg:format-args))

(defmethod (:kbin-dump-init-options header-line-without-colon) ()
  `(:line ,line))

(defmethod (:kbin-dump-init-options fs:unknown-pathname-host) ()
  `(:name ,fs:name))

(defmethod (:kbin-dump-init-options domain-syntax-error) ()
  `(:format-string ,dbg:format-string :format-args ,dbg:format-args :position ,zwei:position))

(defmethod (:kbin-dump-init-options domain-syntax-parse-error) ()
  `(:contained-error ,zwei:contained-error :start-bp ,zwei:start-bp :end-bp ,zwei:end-bp))

(defun kbin-dump-ferror (object)
  (declare (dbg:error-reporter))
  (error "I don't know how to dump ~S" object))

(defun temporary-dump-error (index object)
  (declare (dbg:error-reporter))
  (error "Storing second object at temporary location ~D.~@
	  Location already contains ~S~@
	  Attempting to store ~S."
	 index (aref *kbin-load-table* index) object))

(defun permanent-dump-error (index object)
  (declare (dbg:error-reporter))
  (error "Storing second object at permanent location ~D.~@
	  Location already contains ~S~@
	  Attempting to store ~S."
	 index (aref *kbin-permanent-load-table* index) object))


(defun kbin-enter-dump-table (stream object &optional (force-into-table t) permanent-p)
  (let* ((table (if permanent-p *kbin-permanent-dump-table* *kbin-dump-table*))
	 (load-table (if permanent-p *kbin-permanent-load-table* *kbin-load-table*))
	 (index (send table :get-hash object)))
    (values
      (cond (index
	     (unless (eql (aref load-table index) object)
	       (error "Wrong object being referenced at index ~D.~@
		       Expected ~S~@
		       Found ~S."
		      index object (aref load-table index)))
	     (cond ((or (and permanent-p
			     ( index *immediate-permanent-table-fetch-max-index*))
			(and (not permanent-p)
			     ( index *immediate-table-fetch-max-index*)))
		    (kbin-dump-opcode stream
				      (+ (dpb (if permanent-p
						  kbin-immediate-permanent-table-fetch
						kbin-immediate-table-fetch)
					      (byte 8 8) 0)
					 index)
				      object))
		   ((< index (lsh 1 16))
		    (kbin-dump-opcode stream
				      (if permanent-p
					  kbin-permanent-table-fetch-medium
					kbin-table-fetch-medium)
				      object)
		    (send stream ':tyo index))
		   (t
		    (kbin-dump-opcode stream
				      (if permanent-p
					  kbin-permanent-table-fetch
					kbin-table-fetch)
				      object)
		    (command-body
		      (kbin-dump-integer stream index))))
	     t)
	    ((null force-into-table)
	     nil)
	    (permanent-p
	     (setq index *kbin-permanent-table-index*)
	     (incf *kbin-permanent-table-index*)
	     (send *kbin-permanent-dump-table* :put-hash object index)
	     (when *permanent-dump-table-history*
	       (command-history-push index object *permanent-dump-table-history*))
	     (when *dump-command-history*
	       (command-history-push `("Permanent store" ,index) object
				     *dump-command-history*))
	     nil)
	    (t
	     (setq index *kbin-table-index*)
	     (incf *kbin-table-index*)
	     (send *kbin-dump-table* ':put-hash object index)
	     (when *dump-table-history*
	       (command-history-push index object *dump-table-history*))
	     (when *dump-command-history*
	       (command-history-push `("Store" ,index) object *dump-command-history*))
	     nil))
      index)))

(defun kbin-enter-permanent-dump-table (stream object &optional (force-into-table t))
  (kbin-enter-dump-table stream object force-into-table *kbin-permanent-dump-table*))

;;; Internal function of the KBIN-DUMP-PERMANENT macro
(defun kbin-dump-permanent-internal (stream object continuation)
  (declare (sys:downward-funarg continuation))
  (let ((index *kbin-permanent-table-index*)
	(table *kbin-permanent-load-table*)
	(object (follow-forwarding object)))
    (unless (kbin-enter-permanent-dump-table stream object)
      (set-dump-table :permanent object)
      (multiple-value-prog1
	(funcall continuation)
	(when ( index (zl:array-length table))
	  (setq *kbin-permanent-load-table*
		(setq table
		      (grow-load-table table (+ index (truncate index 2))))))
	(if (location-boundp (locf (aref table index)))
	    (permanent-dump-error index object)
	  (setf (aref table index) object))))))

;;; If we already have seen this EQ object, it should be in the permanent
;;; dump table already.  Otherwise, if there's no EQUAL version, enter this one there.
;;; If there IS an EQUAL version, redo the KBIN-ENTER-PERMANENT-DUMP-TABLE.

(defun kbin-enter-permanent-dump-table-equal (stream object &optional new-object-fun
						     (area *zmail-header-area*))
  (declare (sys:downward-funarg new-object-fun))
  (multiple-value-bind (in-table-p index)
      (kbin-enter-permanent-dump-table stream object nil)
    (if in-table-p
	(values in-table-p index )
      (let* ((new-object (send *kbin-equal-dump-table* :get-hash object)))
	(unless new-object
	  (setq new-object (msg-areaf object area))
	  (send *kbin-equal-dump-table* :put-hash new-object new-object))
	(when new-object-fun
	  (funcall new-object-fun new-object)
	  ;; If We're updating the caller, update the remembered object, too.
	  (when (eq object *next-object-table-object*)
	    (setq *next-object-table-object* new-object)))
	(kbin-enter-permanent-dump-table stream new-object)))))

;;; This is the internals of the KBIN-DUMP-PERMANENT-EQUAL macro.
;;; It takes care of calling the continuation if need be, (i.e. if
;;; kbin-enter-permanent-dump-table-equal says it needs to be dumped),
;;; decoding the area argument if that isn't a compile-time constant,
;;; binding *DUMPING-AREA*, and error checking for clobbering the load table.

(defun kbin-dump-permanent-equal-internal (stream object new-object-fun continuation
						  &optional (area-name '*zmail-header-area*)
							    area-opcode)
  (declare (sys:downward-funarg new-object-fun continuation))
  (let ((area (if (symbolp area-name)
		  (symbol-value area-name)
		area-name))
	(object (follow-forwarding object)))
    (unless (and area-opcode
		 (symbolp area-name))
      (multiple-value-setq (area-name area-opcode)
	(lookup-area-opcode area)))
    (multiple-value-bind (in-table-p index)
	(kbin-enter-permanent-dump-table-equal
	  stream object
	  (when *compact-while-dumping*
	    #'(lambda (new-object)
		(declare (sys:downward-function))
		(setq object new-object)
		(funcall new-object-fun new-object)))
	  area)
      (unless in-table-p
	(set-dump-table :permanent object)
	(let ((old-area *dumping-area*)
	      (*dumping-area* area-name)
	      (*indent-level* *indent-level*)
	      (table *kbin-permanent-load-table*))
	  (multiple-value-prog1
	    (progn
	      (unless (eq *dumping-area* old-area)
		(incf *indent-level*)
		(kbin-dump-opcode stream area-opcode object))
	      (funcall continuation))
	    (when ( index (zl:array-length table))
	      (setq *kbin-permanent-load-table*
		    (setq table
			  (grow-load-table table (+ index (truncate index 2))))))
	    (if (location-boundp (locf (aref table index)))
		(permanent-dump-error index object)
	      (setf (aref table index) object))))))))

;;; Internals of KBIN-DUMP-TEMPORARY macro.
(defun kbin-dump-temporary-internal (stream object continuation)
  (declare (sys:downward-funarg continuation))
  (let ((index *kbin-table-index*)
	(table *kbin-load-table*)
	(object (follow-forwarding object)))
    (unless (kbin-enter-dump-table stream object)
      (set-dump-table :temporary object)
      (multiple-value-prog1
	(funcall continuation)
	(when ( index (zl:array-length table))
	  (setq *kbin-load-table*
		(setq table
		      (grow-load-table table (+ index (truncate index 2))))))
	(if (location-boundp (locf (aref table index)))
	    (temporary-dump-error index object)
	  (setf (aref table index) object))))))
