;;; Lisp Machine mail reader -*- Base: 8; Mode: LISP; Package: ZWEI -*- 
;;; Some special Zmail windows, definition are in DEFS
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(DEFFLAVOR MODE-LINE-PANE () (TV:PANE-MIXIN ZMACS-MODE-LINE-WINDOW))

(DEFMETHOD (:REDISPLAY MODE-LINE-PANE :BEFORE) (&REST IGNORE)
  (WHEN (VARIABLE-BOUNDP *OPTIONS-MODIFIED-P*)
    (SETQ *OPTIONS-MODIFIED-P* (AND (> *VARIABLE-TICK* *EDITOR-VARIABLE-TICK*) " %"))))

(DEFUN TRUNCATED-SENSITIVE-FORMAT (OBJECT TYPE STREAM FORMAT-STRING &REST FORMAT-ARGS)
  (DW::WITH-OUTPUT-TRUNCATION (STREAM :HORIZONTAL T)
    (DW:WITH-OUTPUT-AS-PRESENTATION (:TYPE TYPE :OBJECT OBJECT :STREAM STREAM)
      (LEXPR-FUNCALL #'FORMAT STREAM FORMAT-STRING FORMAT-ARGS))))

(DEFFLAVOR LINE-TRUNCATING-ZMAIL-TYPEOUT-WINDOW ()
	   (TV:TRUNCATABLE-LINES-MIXIN ZMAIL-TYPEOUT-WINDOW))

;;; This is still used by DAY-IN-PERIOD-PANE, because it is built on TEXT-SCROLL-WINDOW.
(DEFFLAVOR TRUNCATING-MOUSE-SENSITIVE-ITEMS
	((TRUNCATE-P NIL))
	()
  (:REQUIRED-FLAVORS TV:BASIC-MOUSE-SENSITIVE-ITEMS))

(DEFMETHOD (:TRUNCATED-ITEM TRUNCATING-MOUSE-SENSITIVE-ITEMS) (TYPE ITEM &REST FORMAT-ARGS)
  ;; Do this before recording the Y position in case of more processing and wraparound
  (SEND SELF ':HANDLE-EXCEPTIONS)
  (LET ((ENTRY (LIST TYPE ITEM TV:CURSOR-X TV:CURSOR-Y TV:(SHEET-INSIDE-RIGHT)
		     TV:(+ CURSOR-Y LINE-HEIGHT))))
    (PUSH ENTRY TV:ITEM-LIST)
    (*CATCH 'LINE-OVERFLOW
      (LET-GLOBALLY ((TRUNCATE-P T))
	(IF FORMAT-ARGS (LEXPR-FUNCALL #'FORMAT SELF FORMAT-ARGS) (PRINC ITEM SELF))
	(SETF (FIFTH ENTRY) TV:CURSOR-X)))))

(DEFMETHOD (:END-OF-LINE-EXCEPTION TRUNCATING-MOUSE-SENSITIVE-ITEMS :BEFORE) ()
  (AND TRUNCATE-P
       (*THROW 'LINE-OVERFLOW T)))

(DEFFLAVOR ARROW-PRINTING-MIXIN () ()
  (:REQUIRED-FLAVORS TV:STREAM-MIXIN))

(DEFMETHOD (:PRINT-ARROW ARROW-PRINTING-MIXIN) (TYPE)
  (SCL:WITH-CHARACTER-STYLE ('(:FIX :ROMAN :NORMAL) SELF)
    (SEND SELF :TYO (SELECTQ TYPE
		      ((:CURRENT T) #\Arrow:Right-Short-Open-Arrow)
		      (:MARKED #\Arrow:Center-Dot)
		      (:MARK-SURVEY-CURRENT #\Arrow:Right-Arrowhead)
		      (:MARK-SURVEY-MARKED-AND-CURRENT #\Arrow:Right-Arrowhead-Dot)))))

(FORMAT:DEFFORMAT ARROW (:ONE-ARG) (ARG IGNORE)
  (COND ((NULL ARG)
	 (SEND FORMAT:*FORMAT-OUTPUT* ':TYO #\SP))
	((SEND FORMAT:*FORMAT-OUTPUT* ':OPERATION-HANDLED-P ':PRINT-ARROW)
	 (SEND FORMAT:*FORMAT-OUTPUT* ':PRINT-ARROW ARG))
	(T
	 (SEND FORMAT:*FORMAT-OUTPUT* ':TYO (SELECTQ ARG
					      ((:CURRENT T) #/)
					      (:MARKED #/x)
					      (:MARK-SURVEY-CURRENT #/>)
					      (:MARK-SURVEY-MARKED-AND-CURRENT #/))))))

(DEFFLAVOR ZMAIL-TYPEOUT-WINDOW () (#||TRUNCATING-MOUSE-SENSITIVE-ITEMS||#
				    EDITOR-TYPEOUT-WINDOW
				    ARROW-PRINTING-MIXIN)
  #||
  (:DEFAULT-INIT-PLIST :ITEM-TYPE-ALIST *ZMAIL-TYPEOUT-ITEM-ALIST*)
  ||#
  )

(DEFMETHOD (:MORE-TYI ZMAIL-TYPEOUT-WINDOW) ()
  (LOOP AS CHARACTER = (IF (OR *INSIDE-BREAK* (> DBG:*DEBUGGER-LEVEL* 0))
			   (SYS:READ-CHARACTER SELF :NOTIFICATION NIL :PRESENTATION-CONTEXT T)
			   (LET ((STANDARD-INPUT SELF))
			     (EDITOR-INPUT :ANY-TYI 'COMMAND :ABORT T :SUSPEND T))) DO
    (UNLESS (NULL (DW::INTERCEPT-SCROLL-KEY SELF CHARACTER))
      (WHEN (OR (CHARACTERP CHARACTER)
		(AND (LISTP CHARACTER)
		     (LET ((CA (CAR CHARACTER)))
		       (OR (GET CA 'SI:BLIP-HANDLER)
			   (EQ (SI:INPUT-EDITOR-OPTION :BLIP-HANDLER) CA)
			   (MEMQ CA '(:TYPEOUT-EXECUTE SUMMARY-EXECUTE :MENU :MOUSE
						       SUMMARY-MOUSE MODE-LINE :MOUSE-BUTTON
						       PRESENTATION-COMMAND))))))
	(RETURN CHARACTER)))))

(DEFFLAVOR ZMAIL-WINDOW-WITH-TYPEOUT-MIXIN
	()
	()
  (:REQUIRED-FLAVORS TV:STREAM-MIXIN TV:WINDOW-WITH-TYPEOUT-MIXIN))

(DEFMETHOD (:INIT ZMAIL-WINDOW-WITH-TYPEOUT-MIXIN :BEFORE) (IGNORE)
  (SETQ TV:TYPEOUT-WINDOW
	`(ZMAIL-TYPEOUT-WINDOW :IO-BUFFER ,TV:IO-BUFFER)))

(DEFFLAVOR ZMAIL-WHO-LINE-OVERRIDE-MIXIN
	((WHO-LINE-OVERRIDE-DOCUMENTATION-STRING NIL))
	()
  (:REQUIRED-FLAVORS TV:SHEET)
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING ZMAIL-WHO-LINE-OVERRIDE-MIXIN :OVERRIDE) ()
  (AND (SEND SELF ':WHO-LINE-OVERRIDE-P)
       WHO-LINE-OVERRIDE-DOCUMENTATION-STRING))

(DEFMETHOD (:WHO-LINE-OVERRIDE-P ZMAIL-WHO-LINE-OVERRIDE-MIXIN) ()
  T)

(DEFMACRO WITH-ZMAIL-SUMMARY-WHO-LINE-DOCUMENTATION (DOCUMENTATION &BODY FORMS)
  (LET ((TEMP (MAKE-SYMBOL "OLD-DOCUMENTATION")))
    `(LET ((,TEMP (SEND *SUMMARY-WINDOW* :WHO-LINE-OVERRIDE-DOCUMENTATION-STRING)))
       (UNWIND-PROTECT (PROGN
			 (SEND *SUMMARY-WINDOW* :SET-WHO-LINE-OVERRIDE-DOCUMENTATION-STRING
			       ,DOCUMENTATION)
			 ,@FORMS)
	 (SEND *SUMMARY-WINDOW* :SET-WHO-LINE-OVERRIDE-DOCUMENTATION-STRING ,TEMP)))))

(DEFFLAVOR ZMAIL-WINDOW (INTERVAL-NAME)
	   (TV:PANE-MIXIN TV:DONT-SELECT-WITH-MOUSE-MIXIN
	    ZMAIL-WINDOW-WITH-TYPEOUT-MIXIN ZWEI-WINDOW ZMAIL-WHO-LINE-OVERRIDE-MIXIN)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES
  (:DEFAULT-INIT-PLIST
   :MARGIN-COMPONENTS '((DW:MARGIN-RAGGED-BORDERS :THICKNESS 1)
			(DW:MARGIN-WHITE-BORDERS )
			(DW:MARGIN-SCROLL-BAR :SHAFT-WHITESPACE-THICKNESS 4
					      :HISTORY-NOUN "message")
			(DW:MARGIN-LABEL :STRING NIL))))

(DEFMETHOD (:INIT ZMAIL-WINDOW :AFTER) (PLIST)
  (IGNORE PLIST)
  (WHEN (OR (NOT (VARIABLE-BOUNDP INTERVAL-NAME)) (NULL INTERVAL-NAME))
    (SETQ INTERVAL-NAME TV:NAME))		;Use window's name as a last resort.
  (SEND SELF :SET-LABEL INTERVAL-NAME))

(DEFMETHOD (:MOUSE-CLICK ZMAIL-WINDOW) (BUTTON &REST IGNORE)
  (COND ((AND (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-1-1)
	      (NOT (DO SHEET TV:SELECTED-WINDOW (SEND SHEET ':SUPERIOR) (NULL SHEET)
		     (AND (EQ SHEET *ZMAIL-WINDOW*) (RETURN T)))))
	 (TV:MOUSE-SELECT *ZMAIL-WINDOW*)
	 T)))

(DEFMETHOD (:MODE-LINE-WINDOW ZMAIL-WINDOW) ()
  (SEND TV:SUPERIOR ':MODE-LINE-WINDOW))

(DEFMETHOD (:PANE-SIZE-FOR-TEXT ZMAIL-WINDOW) (REM-WIDTH REM-HEIGHT IGNORE IGNORE STACKING)
  (IF (EQ STACKING ':HORIZONTAL) REM-WIDTH
    (+ TV:TOP-MARGIN-SIZE TV:BOTTOM-MARGIN-SIZE
       (* TV:LINE-HEIGHT
	  (// (+ (1- TV:LINE-HEIGHT)
		 (RANGE (* TV:LINE-HEIGHT (COUNT-LINES (WINDOW-INTERVAL ZWEI-WINDOW)))
			(// (* REM-HEIGHT 3) 20.)	;.015
			(// REM-HEIGHT 2)))	;.050
	      TV:LINE-HEIGHT)))))

(DEFMETHOD (:NOTIFICATION-CELL ZMAIL-WINDOW) ()
  (SEND (SEND SELF :ALIAS-FOR-SELECTED-WINDOWS) :NOTIFICATION-CELL))

(DEFMETHOD (:NOTIFICATION-MODE ZMAIL-WINDOW) ()
  (SEND (SEND SELF :ALIAS-FOR-SELECTED-WINDOWS) :NOTIFICATION-MODE))


;;; Stuff related to the summary window
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *CONFIGURE-MIDDLE-MODE* COM-ZMAIL-CONFIGURE) 

(DEFUN CONFIGURE-LEFT-MODE (&OPTIONAL (MODE *WINDOW-CONFIGURATION*))
  (COND ((AND (MEMQ MODE *CALENDAR-WINDOW-CONFIGURATIONS*) (NEQ MODE :CALENDAR))
	 :CALENDAR)
	((EQ MODE :BOTH) :MSG)
	(T :BOTH)))

(DEFUN CONFIGURE-MIDDLE-MODE (&OPTIONAL (MIDDLE-MODE *CONFIGURE-MIDDLE-MODE*)
					(CURRENT-MODE *WINDOW-CONFIGURATION*))
  (IF (EQ MIDDLE-MODE :SUMMARY-OR-MSG)
      (SELECTQ CURRENT-MODE
	(:SUMMARY :MSG)
	(:MSG :SUMMARY)
	(OTHERWISE :SUMMARY))
    MIDDLE-MODE))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-CONFIGURE (STRING)
  (LET ((CURRENT-MODE (IF *EXPLICIT-OPTION-UPDATE* *PREVIOUS-WINDOW-CONFIGURATION*
			*WINDOW-CONFIGURATION*)))
    (FORMAT STRING "Change window configuration:  L: ~A; M: ~A; R: menu."
	    (NAME-FROM-MENU-VALUE (CONFIGURE-LEFT-MODE CURRENT-MODE)
				  *WINDOW-CONFIGURATION-ALIST*)
	    (NAME-FROM-MENU-VALUE (CONFIGURE-MIDDLE-MODE *CONFIGURE-MIDDLE-MODE* CURRENT-MODE)
				  *WINDOW-CONFIGURATION-ALIST*))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-CONFIGURE "Change window configuration.
Left both summary and message displayed.
Right gives menu of window configurations." (NO-SEQUENCE-OK)
  (LET ((CONFIG (IF (MEMQ *ZMAIL-COMMAND-BUTTON* '(:RIGHT :MIDDLE))
		    (CONFIGURE-MIDDLE-MODE
		      (ZMAIL-MENU-CHOOSE NIL *COM-CONFIGURE-CONFIGURATION-ALIST*
					 NIL (RECTANGLE-NEAR-COMMAND-MENU (TV:MOUSE-SHEET (TV:SHEET-MOUSE *ZMAIL-WINDOW*)))
					 *CONFIGURE-MIDDLE-MODE*))
		  (CONFIGURE-LEFT-MODE))))
    (LET ((CALENDAR-P (MEMQ CONFIG *CALENDAR-WINDOW-CONFIGURATIONS*)))
      (WHEN CALENDAR-P
	(SETUP-FOR-CALENDAR-CONFIGURATION CONFIG))
      (SET-MAIN-WINDOW-CONFIGURATION CONFIG)
      (WHEN CALENDAR-P
	(POST-SETUP-FOR-CALENDAR-CONFIGURATION CONFIG))))
  DIS-NONE)

(DEFUN SET-MAIN-WINDOW-CONFIGURATION (CONFIG &OPTIONAL FORCE-P)
  (WHEN (OR (NEQ CONFIG *WINDOW-CONFIGURATION*) FORCE-P)
    (SEND *CURRENT-ZMAIL-COMMAND-LOOP* ':SET-WINDOW-CONFIGURATION CONFIG)
    (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-CONFIGURE)))

(DEFUN DEFINE-SUMMARY-FORMAT-TEMPLATE-WORKER (NAME TEMPLATE MENU-NAME DOCUMENTATION-PREFIX)
  (WHEN (RECORD-SOURCE-FILE-NAME NAME 'DEFINE-SUMMARY-FORMAT-TEMPLATE)
    (MACROLET ((REPLACE-OR-PUSH (ITEM LIST)
		 `(IF (ASSOC (FIRST ,ITEM) ,LIST)
		      (SETF (FIRST (MEMQ (ASSOC (FIRST ,ITEM) ,LIST) ,LIST)) ,ITEM)
		    (SETQ ,LIST (NCONC ,LIST (NCONS ,ITEM))))))
      (LET ((TEMPLATE-DEFINITION-ITEM `(,NAME . ,TEMPLATE)))
	(REPLACE-OR-PUSH TEMPLATE-DEFINITION-ITEM *SUMMARY-TEMPLATE-ABBREVIATIONS*))
      (LET* ((*DEFAULT-SUMMARY-TEMPLATE* NAME)
	     (DOCUMENTATION (FORMAT NIL "~A:  No. ~A"
				    DOCUMENTATION-PREFIX (SET-MSG-SUMMARY-LINE NIL NIL)))
	     (TEMPLATE-MENU-ITEM `(,MENU-NAME :VALUE ,NAME :DOCUMENTATION ,DOCUMENTATION)))
	(REPLACE-OR-PUSH TEMPLATE-MENU-ITEM *SUMMARY-WINDOW-FORMAT-ALIST*)))
    (SCL:DESTRUCTURING-BIND (USE-DEFAULT-ITEM &REST IGNORE)
			    *BABYL-SUMMARY-WINDOW-FORMAT-ALIST*
      (SETQ *BABYL-SUMMARY-WINDOW-FORMAT-ALIST* `(,USE-DEFAULT-ITEM
						  ,@*SUMMARY-WINDOW-FORMAT-ALIST*)))
    (SCL:DESTRUCTURING-BIND (T-ITEM NIL-ITEM REMINDER-ITEM &REST IGNORE)
			    *BABYL-SUMMARY-WINDOW-FORMAT-PARSE-ALIST*
      (SETQ *BABYL-SUMMARY-WINDOW-FORMAT-PARSE-ALIST* `(,T-ITEM ,NIL-ITEM ,REMINDER-ITEM
							,@*BABYL-SUMMARY-WINDOW-FORMAT-ALIST*)
	    ))
    (LET ((TEMPLATE-OPTION (ASSQ '*DEFAULT-SUMMARY-TEMPLATE* *ZMAIL-USER-OPTION-ALIST*)))
      (WHEN TEMPLATE-OPTION
	(SETF (FOURTH TEMPLATE-OPTION) (COPYLIST *SUMMARY-WINDOW-FORMAT-ALIST*))
	(WHEN (VARIABLE-BOUNDP *ZMAIL-WINDOW*)
	  (RECONSTRUCT-PROFILE-CVV-WINDOW *ZMAIL-WINDOW*))))
    (LET ((TEMPLATE-OPTION (ASSQ :SUMMARY-WINDOW-FORMAT *MAIL-FILE-OPTION-ALIST*)))
      (WHEN TEMPLATE-OPTION
	(SETF (FOURTH TEMPLATE-OPTION) (COPYLIST *BABYL-SUMMARY-WINDOW-FORMAT-ALIST*))))))

(DEFINE-ZMAIL-GLOBAL *STATUS-LETTER-PROPERTY-ALIST*
  '((KILLED . #\D)
    (DELETED . #\D)
    (UNPARSEABLE . #\Space)
    (ANSWERED . #\A)
    (UNSEEN . #\-)
    (OTHERWISE . #\:)))

(DEFUN STATUS-LETTER (STATUS)
  (LOOP FOR (IND . LETTER) IN *STATUS-LETTER-PROPERTY-ALIST*
	WHEN (OR (EQ IND 'OTHERWISE)
		 (GET STATUS IND))
	RETURN LETTER))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION SET-MSG-SUMMARY-LINE *SUMMARY-WINDOW-LABEL*)

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *SEQUENCE* SET-MSG-SUMMARY-LINE)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION :SUMMARY-WINDOW-FORMAT SET-MSG-SUMMARY-LINE)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER SET-MSG-SUMMARY-LINE (STRING)
  (APPEND-TO-ARRAY STRING "  No. ")
  (SET-MSG-SUMMARY-LINE NIL NIL STRING *SEQUENCE*)
  (WHEN (MEMQ *WINDOW-CONFIGURATION* *SUMMARY-WINDOW-CONFIGURATIONS*)
    ;;Make a copy of the string for the label, since ours gets ASET here.
    (SEND *SUMMARY-WINDOW* :SET-LABEL (STRING-APPEND STRING)))
  STRING)

;;; Compute the summary line for a message, given the msg and the status plist
(DEFUN SET-MSG-SUMMARY-LINE (MSG STATUS &OPTIONAL LINE SEQUENCE &AUX TEMPLATE)
  (UNLESS LINE
    (SETQ LINE (MAKE-SUMMARY-LINE)))
  (SETQ TEMPLATE (IF (AND (OR MSG SEQUENCE)
			  (SETQ TEMPLATE (SEND (IF MSG (MSG-BUFFER MSG) SEQUENCE)
					       :GETL '(:SUMMARY-WINDOW-FORMAT)))
			  (NEQ (SECOND TEMPLATE) :DEFAULT))
		     (SECOND TEMPLATE)
		   *DEFAULT-SUMMARY-TEMPLATE*))
  (WHEN (SYMBOLP TEMPLATE)
    (SETQ TEMPLATE
	  (LOOP FOR TEMP = TEMPLATE
			 THEN (OR (CDR (ASSQ TEMPLATE *SUMMARY-TEMPLATE-ABBREVIATIONS*))
				  (CDR (ASSQ *DEFAULT-SUMMARY-TEMPLATE*
					     *SUMMARY-TEMPLATE-ABBREVIATIONS*)))
		WHEN (NOT (SYMBOLP TEMP))
		  RETURN TEMP)))
  (LOOP FOR (KEY VAL) ON TEMPLATE BY 'CDDR
	DO (FUNCALL (GET KEY 'SUMMARY-PRINTER) LINE VAL MSG STATUS)
	COLLECT `(,KEY ,VAL ,(SUMMARY-LINE-LENGTH LINE)) INTO TEMP
	FINALLY (SETF (SUMMARY-LINE-TEMPLATE LINE) TEMP))
  (WHEN (AND MSG STATUS)
    (SETF (MSG-SUMMARY-LINE MSG) LINE))
  LINE)

(DEFUN (:BLANK SUMMARY-PRINTER) (LINE COLS MSG STATUS)
  MSG STATUS
  (APPEND-TO-ARRAY LINE *SPACES* 0 COLS))

(DEFUN (:SIZE SUMMARY-PRINTER) (LINE COLS MSG STATUS)
  (COND (STATUS
	 (NUMBER-INTO-ARRAY LINE (COUNT-LINES (MSG-INTERVAL MSG)) 10.
			    (SUMMARY-LINE-LENGTH LINE) COLS)
	 (SETF (SUMMARY-LINE-LENGTH LINE) (+ (SUMMARY-LINE-LENGTH LINE) COLS)))
	(T
	 (APPEND-TO-ARRAY LINE "Lines" 0 (MIN COLS 5))
	 (APPEND-TO-ARRAY LINE *SPACES* 0 (MAX (- COLS 5) 0))))
  (ARRAY-PUSH-EXTEND LINE #\SP))

(DEFUN (:DATE SUMMARY-PRINTER) (LINE TYPE IGNORE STATUS &AUX DATE)
  (COND ((NULL STATUS)
	 (AND (MEMQ TYPE '(:DATE :DATE-AND-TIME))
	      (APPEND-TO-ARRAY LINE " Date "))
	 (AND (MEMQ TYPE '(:DATE-AND-TIME :TIME))
	      (APPEND-TO-ARRAY LINE "Time ")))
	((SETQ DATE (CADR (GETL STATUS '(:DATE :DRAFT-COMPOSITION-DATE))))
	 (AND (LISTP DATE) (SETQ DATE (CAR DATE)))
	 (MULTIPLE-VALUE-BIND (NIL MINUTES HOURS DAY MONTH)
	     (TIME:DECODE-UNIVERSAL-TIME DATE)
	   (SETQ MONTH (TIME:MONTH-STRING MONTH ':SHORT))
	   ;; This used to use a ~:[ and only a single FORMAT statement but that
	   ;; added ~50msecs to the execution time (per message).  This could be made
	   ;; even faster by not using FORMAT at all, but that would only save a
	   ;; few (2-3) msecs and is not worth the consequent code-uglification.
	   (SELECTQ TYPE
	     (:DATE
	      (FORMAT LINE "~2D-~A " DAY MONTH))
	     (:DATE-AND-TIME
	      (FORMAT LINE "~2D-~A ~2,'0D~2,'0D " DAY MONTH HOURS MINUTES))
	     (:TIME
	      (FORMAT LINE "~2,'0D~2,'0D " HOURS MINUTES)))))
	(T
	 (APPEND-TO-ARRAY LINE *SPACES* 0
			  (+ (IF (MEMQ TYPE '(:DATE :DATE-AND-TIME)) 7 0)
			     (IF (MEMQ TYPE '(:DATE-AND-TIME :TIME)) 5 0))))))

(DEFUN (:RECIPIENTS SUMMARY-PRINTER) (LINE SIZE IGNORE STATUS)
  (LET (STR1 LEN1
	STR2 LEN2)
    (IF STATUS
	(LET* ((MSG-IS-DRAFT (GET STATUS :DRAFT-COMPOSITION-DATE))
	       (FROM (OR (GET STATUS :FROM)
			 (AND MSG-IS-DRAFT `((:USER ,SI:*USER*))))))
	  (SETQ STR1 (SUMMARIZE-ERROR-OR-RECIPIENTS FROM (1- SIZE) STATUS)
		STR2 (SUMMARIZE-ERROR-OR-RECIPIENTS (GET STATUS :TO) (1- SIZE) STATUS)))
      (SETQ STR1 "From"
	    STR2 "To"))
    (SETQ LEN1 (MIN (MAX (// (1- SIZE) 2)
			 (- SIZE (SETQ LEN2 (STRING-LENGTH STR2)) 1))
		    (STRING-LENGTH STR1))
	  LEN2 (MIN (- SIZE LEN1 1) LEN2))
    (APPEND-TO-ARRAY LINE STR1 0 LEN1)
    (APPEND-TO-ARRAY LINE "" 0 1)
    (APPEND-TO-ARRAY LINE STR2 0 LEN2)
    (APPEND-TO-ARRAY LINE *SPACES* 0 (- SIZE (+ LEN1 LEN2)))
    (RETURN-ARRAY STR2)
    (RETURN-ARRAY STR1)))

(DEFUN (:KEYWORDS SUMMARY-PRINTER) (LINE IGNORE IGNORE STATUS &AUX KEYSTR)
    (COND ((AND STATUS (SETQ KEYSTR (GET STATUS 'KEYWORDS-STRING)))
	   (APPEND-TO-ARRAY LINE KEYSTR)
	   (ARRAY-PUSH-EXTEND LINE #\SP))))

(DEFUN (:SUBJECT SUMMARY-PRINTER) (LINE IGNORE MSG STATUS &AUX SUBJ)
  (SETQ SUBJ (CADR (GETL STATUS '(:SUBJECT :S))))
  (COND ((NULL STATUS)
	 (SETQ SUBJ "Subject or Text"))
	((LISTP SUBJ)
	 (SETQ SUBJ (FOLD-MULTI-LINE-SUBJECT (FORMAT NIL "~{~A~^ ~}" SUBJ))))
	((NOT (NULL SUBJ))
	 (SETQ SUBJ (FOLD-MULTI-LINE-SUBJECT SUBJ)))
	((GET STATUS ':ENCRYPTED)
	 (SETQ SUBJ "[Encrypted message]"))
	(T
	 (SETQ SUBJ (MSG-FIRST-TEXT-LINE MSG))))
  (LET ((SIDX (IF *SUMMARY-SUBJECT-TRIM-SPACES*
		  (OR (STRING-SEARCH-NOT-SET *BLANKS* SUBJ) (STRING-LENGTH SUBJ))
		  0)))
    (when (and status msg
	       (string-fat-p subj))
      (setq line (make-summary-line-fat line)))
    (APPEND-TO-ARRAY LINE SUBJ SIDX)))

(DEFUN FOLD-MULTI-LINE-SUBJECT (SUBJECT)
  (IF (OR (NOT *SUMMARY-SUBJECT-TRIM-SPACES*)
	  (NOT (STRING-SEARCH-CHAR #\RETURN SUBJECT)))
      SUBJECT
      (LET ((STRING (MAKE-ARRAY (STRING-LENGTH SUBJECT)
				:TYPE (ARRAY-TYPE SUBJECT) :FILL-POINTER 0)))
	(LOOP AS START = 0 THEN END
	      AS END = (STRING-SEARCH-CHAR #\RETURN SUBJECT START)
	      DO (APPEND-TO-ARRAY STRING SUBJECT START
				  (LET ((TEM (STRING-REVERSE-SEARCH-NOT-SET *BLANKS* SUBJECT
									    END START)))
				    (IF TEM (1+ TEM) START)))
	      UNTIL (NULL END)
	      WHILE (SETQ END (STRING-SEARCH-NOT-SET *BLANKS* SUBJECT (1+ END)))
	      DO (ARRAY-PUSH-EXTEND STRING #\SP))
	STRING)))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Update a specific portion of a message's summary line.
0(DEFUN UPDATE-MSG-SUMMARY-LINE (MSG FIELD-NAME)
  (LET* ((OLD-LINE (MSG-SUMMARY-LINE MSG))
	 1;; We must make a complete copy of the summary line template as 0KBIN1 files share
0	 1;; their templates and we don't want to improperly update other messages' templates.
0	 (NEW-TEMPLATE (COPYTREE (SUMMARY-LINE-TEMPLATE OLD-LINE))))
    (MULTIPLE-VALUE-BIND (FIELD LINE-PREFIX-END)
	1;; Find the field in the template and how much text exists before it in the line.
0	(DO ((TEMPLATE NEW-TEMPLATE (CL:REST TEMPLATE))
	     (PRIOR-FIELD NIL (FIRST TEMPLATE)))
	    ((NULL TEMPLATE))
	  (WHEN (EQ FIELD-NAME (FIRST (FIRST TEMPLATE)))
	    (RETURN (VALUES (FIRST TEMPLATE) (IF PRIOR-FIELD (THIRD PRIOR-FIELD) 0)))))
      (WHEN FIELD
	1;; The field is in the template -- Construct an updated new line.
0	(LET ((NEW-LINE (MAKE-SUMMARY-LINE :MAKE-ARRAY (:LENGTH (SUMMARY-LINE-LENGTH OLD-LINE)
							:TYPE (IF (NULL OLD-LINE) 'ART-STRING
								(ARRAY-TYPE OLD-LINE))))))
	  1;; Copy the text from the old line before the updated field.
0	  (APPEND-TO-ARRAY NEW-LINE OLD-LINE 0 LINE-PREFIX-END)
	  1;; Put the updated field into the new line.
0	  (FUNCALL (GET FIELD-NAME 'SUMMARY-PRINTER)
		   NEW-LINE (SECOND FIELD) MSG (LOCF (MSG-STATUS MSG)))
	  1;; Copy any text after the updated field from the old line.
0	  (APPEND-TO-ARRAY NEW-LINE OLD-LINE (THIRD FIELD))
	  1;; Correct the template entry of the update field and any that follow it to
0	  1;; reflect how much the line has grown or shrunk.
0	  (LET ((LINE-SIZE-DELTA (- (SUMMARY-LINE-LENGTH OLD-LINE)
				    (SUMMARY-LINE-LENGTH NEW-LINE))))
	    (DOLIST (F (MEMQ FIELD NEW-TEMPLATE))
	      (DECF (THIRD F) LINE-SIZE-DELTA)))
	  1;; Finally, update the message itself.
0	  (CL:SETF (SUMMARY-LINE-TEMPLATE NEW-LINE) NEW-TEMPLATE
		   (MSG-SUMMARY-LINE MSG) NEW-LINE)
	  (WHEN (VARIABLE-BOUNDP *SUMMARY-WINDOW*)
	    (SEND *SUMMARY-WINDOW* :NEED-TO-REDISPLAY-MSG MSG)))))))


(2 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI");;; Explanation Please!

0(DEFVAR *SITES-IGNORED-IN-SUMMARY* NIL)
(DEFVAR *DOMAINS-IGNORED-IN-SUMMARY* NIL)

(DEFUN SET-SITES-IGNORED-IN-SUMMARY ()
  (SETQ *SITES-IGNORED-IN-SUMMARY* (NETI:GET-OTHER-SITES-IN-MAIL-AREA NET:*LOCAL-SITE*))
  (CL:PUSHNEW NET:*LOCAL-SITE* *SITES-IGNORED-IN-SUMMARY*)
  (LOOP INITIALLY
	  (SETQ *DOMAINS-IGNORED-IN-SUMMARY* NIL)
	FOR SITE IN *SITES-IGNORED-IN-SUMMARY*
	AS DOMAIN-NAME = (SEND (SEND SITE :LOCAL-NAMESPACE) :INTERNET-DOMAIN-NAME)
	WHEN DOMAIN-NAME
	  DO (LET* ((COMPONENTS (PDOH-PARSE-INTO-COMPONENTS DOMAIN-NAME
							    0 (STRING-LENGTH DOMAIN-NAME)))
		    (DOMAIN-NAME-LIST (MAPCAR #'PDOH-STRING-FROM-COMPONENT COMPONENTS)))
	       (CL:PUSHNEW DOMAIN-NAME-LIST *DOMAINS-IGNORED-IN-SUMMARY*
			   :TEST #'CL:EQUALP))
	FINALLY (SETQ *DOMAINS-IGNORED-IN-SUMMARY* (NREVERSE *DOMAINS-IGNORED-IN-SUMMARY*))))

(ADD-INITIALIZATION "Set *SITES-IGNORED-IN-SUMMARY*"
		    '(SET-SITES-IGNORED-IN-SUMMARY)
		    '(SITE NORMAL))

(ADD-INITIALIZATION "Set *SITES-IGNORED-IN-SUMMARY*"
		    '(SET-SITES-IGNORED-IN-SUMMARY)
		    ()
		    '*ZMAIL-SYSTEM-INITIALIZATIONS*)

(DEFUN SUMMARY-SUPPRESS-HOST-P (HOST)
  (LET ((NETI:*INHIBIT-VALIDITY-CHECKING* T))
    (OR (LET ((HOST (SI:PARSE-HOST HOST T)))
	  (AND HOST (MEMQ (SEND HOST :GET :SITE) *SITES-IGNORED-IN-SUMMARY*)))
	(LET ((LOCAL-HOST (SECOND (ZMAIL-USER-MAIL-ADDRESS))))
	  (IF (STRINGP HOST)
	      (SEND LOCAL-HOST ':PATHNAME-HOST-NAMEP HOST)
	      (EQ HOST LOCAL-HOST))))))

(DEFUN SUMMARY-SUPPRESS-DOMAIN-P (DOMAIN)
  (LOOP FOR SUPPRESSED-DOMAIN IN *DOMAINS-IGNORED-IN-SUMMARY*
	THEREIS (AND (= (LENGTH DOMAIN) (1+ (LENGTH SUPPRESSED-DOMAIN)))
		     (CL:EQUALP (CDR DOMAIN) SUPPRESSED-DOMAIN))))

(DEFFLAVOR UNDISPLAYABLE-RECIPIENT (CONTAINED-ERROR) (ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT UNDISPLAYABLE-RECIPIENT) (STREAM)
  (FORMAT STREAM "Error while displaying recipient in summary:~%  ~~A~" CONTAINED-ERROR))

(DEFUN SUMMARIZE-ERROR-OR-RECIPIENTS (HEADER SIZE STATUS)
  (IF (NULL HEADER)
      "<Unknown>"
    (CONDITION-CASE (ERR)
	 (SUMMARIZE-RECIPIENTS HEADER SIZE)
       (ERROR (PUSH (MAKE-INSTANCE 'UNDISPLAYABLE-RECIPIENT :CONTAINED-ERROR ERR)
		    (GET STATUS 'LOSING-HEADERS))
	      "???"))))

1;;; Compress a list of recipients.
0(DEFUN SUMMARIZE-RECIPIENTS (ADDRESSES SUMMARY-WIDTH)
  (LET ((SUMMARY-STRING (MAKE-EMPTY-STRING SUMMARY-WIDTH))
	(NETI:*INHIBIT-VALIDITY-CHECKING* T)
	(*RETAIN-COMMON-TAILS* NIL))
    (DECLARE (SPECIAL *RETAIN-COMMON-TAILS*))
    (LABELS ((ADD-CHARACTER (CHAR)
	       (UNLESS (ARRAY-PUSH SUMMARY-STRING CHAR)
		 (RETURN-FROM SUMMARIZE-RECIPIENTS SUMMARY-STRING)))
	     (ADD-STRING (STRING)
	       (LOOP FOR I FROM 0 BELOW (STRING-LENGTH STRING)
		     DO (ADD-CHARACTER (AREF STRING I)))))
      (LOOP FOR (ADDRESS OTHER-ADDRESSES) ON ADDRESSES
	    AS (TYPE VALUE) = (MULTIPLE-VALUE-BIND (IGNORE IGNORE PLIST)
				  (CL:GET-PROPERTIES ADDRESS '(:NAME :USER))
				PLIST)
	    DO
	(CL:CASE TYPE
	  (:USER
	    (UNLESS (EQ VALUE SI:*USER*)
	      (ADD-STRING (STRING VALUE))))
	  (:NAME
	    (UNLESS (STRING-EQUAL VALUE USER-ID)
	      (ADD-STRING VALUE))
	    (BLOCK ADD-HOSTS
	      (LABELS ((ADD-HOST (HOST)
			 (IF (SUMMARY-SUPPRESS-HOST-P HOST)
			     (RETURN-FROM ADD-HOSTS (VALUES))
			   (ADD-CHARACTER #\@)
			   (IF (OR (STRINGP HOST)
				   (LET ((STRING (SEND HOST :SHORT-NAME)))
				     (UNLESS (STRING-SEARCH-CHAR #/| STRING)
				       (SETQ HOST STRING)
				       T)))
			       (ADD-STRING HOST)
			       (ADD-STRING (STRING-FROM-HOST `(:OBJECT ,HOST) :LONG)))))
		       (ADD-DOMAIN (DOMAIN)
			 (IF (SUMMARY-SUPPRESS-DOMAIN-P (REST1 DOMAIN))
			     (RETURN-FROM ADD-HOSTS (VALUES))
			   (ADD-CHARACTER #\@)
			   (ADD-STRING (STRING-FROM-HOST DOMAIN :LONG)))))
		(LET ((HOST (CL:GETF ADDRESS :HOST)))
		  (SELECTQ (FIRST HOST)
		    (:DOMAIN
		     (ADD-DOMAIN HOST))
		    (:PATH
		     (DOLIST (HOST (REST1 HOST))
		       (COND ((STRINGP HOST)
			      (ADD-HOST HOST))
			     ((EQ (FIRST HOST) :DOMAIN)
			      (ADD-DOMAIN HOST))
			     (T
			      (DOLIST (HOST (REST1 HOST))
				(ADD-HOST HOST))))))
		    (OTHERWISE
		     (DOLIST (HOST (REST1 HOST))
		       (ADD-HOST HOST)))))))))
	(WHEN (AND TYPE OTHER-ADDRESSES)
	  (ADD-CHARACTER #\,))))
    SUMMARY-STRING))

(DEFUN MSG-FIRST-TEXT-LINE (MSG)
  (LET ((*INTERVAL* (MSG-INTERVAL MSG)))	;For the primitives like LINE-BLANK-P
    (FIRST-TEXT-LINE *INTERVAL*)))

;;; Returns the first line that is likely to be meaningful
(DEFUN FIRST-TEXT-LINE (BP1 &OPTIONAL BP2 IN-ORDER-P &AUX TEM)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (DO ((LINE (BP-LINE BP1) (LINE-NEXT LINE))
       (END-LINE (BP-LINE BP2))
       (STATE ':START))
      (NIL)
    (COND ;; Recognize lisp machine bug reports.  This could perhaps be more general.
	  ((AND (EQ STATE ':RESTART)
		(SETQ TEM (STRING-SEARCH-NOT-SET '(#\SP #\TAB) LINE))
		(STRING-EQUAL-START LINE "In " TEM)
		(OR (STRING-SEARCH " System " LINE)
		    (STRING-SEARCH " Release " LINE)
		    (STRING-SEARCH " Remote-file " LINE)))	;MIT has to be different
	   (SETQ STATE ':BUG-REPORT))
	  ((EQ STATE ':BUG-REPORT)
	   (WHEN (LINE-BLANK-P LINE)
	     (SETQ STATE ':MAYBE-MIT-BUG-REPORT)))
	  ;; Watch for MIT's "Insert your description of the circumstances here:"
	  ((EQ STATE ':MAYBE-MIT-BUG-REPORT)
	   (COND ((LINE-BLANK-P LINE))		;After an arbitrary number of blanks
		 ((PROGN (SETQ TEM (STRING-SEARCH-NOT-SET '(#\SP #\TAB) LINE))
			 (STRING-EQUAL-START LINE "Insert your description" TEM))
		  (SETQ STATE ':RESTART))
		 ((PROBABLE-ITS-HEADER-P LINE) (SETQ STATE ':RESTART))
		 (T (RETURN LINE))))
	  ((LINE-BLANK-P LINE)
	   (SETQ STATE ':RESTART))
	  ((AND (MEMQ STATE '(:START :RESTART))
		(PROBABLE-ITS-HEADER-P LINE))
	   (SETQ STATE ':RESTART))
	  ;; Recognize continuation of bug report
	  ((EQ STATE ':BUG-REPORT)
	   (AND (STRING-SEARCH ", on " LINE)
		(SETQ STATE ':RESTART)))
	  ;; Recognize start of *MSG's
	  ((AND (MEMQ STATE '(:START :RESTART))
		(STRING-EQUAL-START LINE "MSG: ")))
	  ((OR (MEMQ STATE '(:START :HEADERS-START))
	       (LET ((COLON (STRING-SEARCH-CHAR #/: LINE)))
		 (AND COLON
		      (HEADER-NAME-TYPE LINE
					(STRING-SEARCH-NOT-SET '(#\SP #\TAB) LINE)
					COLON NIL))))
	   (SETQ STATE (IF (MEMQ STATE '(:START :HEADERS-START)) ':HEADERS-START ':HEADERS)))
	  (T (RETURN LINE)))
    (AND (EQ LINE END-LINE)
	 (RETURN ""))))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-SUMMARY-TEMPLATE*
					     CHANGE-MSGS-SUMMARY-LINES)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER CHANGE-MSGS-SUMMARY-LINES (IGNORE)
  (WHEN (AND *EXPLICIT-OPTION-UPDATE* (NOT *RESET-OPTIONS-FROM-PROFILE-EDITOR*))
    ;; Update summary lines only when *DEFAULT-SUMMARY-TEMPLATE* is changed by clicking
    ;; in the CVV window.  (Use of Reset and Defaults buttons should not result in the
    ;; user being queried.)
    (LOOP FOR SEQUENCE IN *SEQUENCE-LIST*
	  WITH ASKED-P = NIL
	  WHEN (SEQUENCE-BUFFER-P SEQUENCE)
	    DO (COND ((NULL ASKED-P)
		      (OR (TYPEOUT-BEEP-YES-OR-NO-P
			    "Also change any summary lines already computed? ")
			  (RETURN NIL))
		      (SETQ ASKED-P T)))
	       (CHANGE-SEQUENCE-MSGS-SUMMARY-LINES SEQUENCE T))))

(DEFUN CHANGE-SEQUENCE-MSGS-SUMMARY-LINES (SEQUENCE &OPTIONAL FORCE-P)
  (WHEN (OR FORCE-P
	    (TYPEOUT-BEEP-YES-OR-NO-P "Also change any summary lines already computed? "))
    (WHEN (EQ SEQUENCE *SEQUENCE*)
      (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION :SUMMARY-WINDOW-FORMAT))
    (LOOP FOR MSG BEING THE MSGS IN SEQUENCE
	  WHEN (EQ (MSG-PARSED-P MSG) T)
	    DO (SET-MSG-SUMMARY-LINE MSG (ASSURE-MSG-PARSED MSG)))
    (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY)))

(DEFFLAVOR ZMAIL-SUMMARY-TYPEOUT-WINDOW () (ZMAIL-TYPEOUT-WINDOW))

;;; Normal scroll redisplay is the one that knows about the typeout window
(DEFMETHOD (:MAKE-COMPLETE ZMAIL-SUMMARY-TYPEOUT-WINDOW :AFTER) ()
  (SEND TV:SUPERIOR ':NEED-FULL-REDISPLAY))

(DEFFLAVOR ZMAIL-SUMMARY-SCROLL-WINDOW
	((CURRENT-SEQUENCE NIL)
	 (CURRENT-MSG NIL)
	 (MSGS-TO-BE-REDISPLAYED NIL)
	 (RECENTER-P NIL)
	 (LAST-DISPLAYED-TOP-SEQUENCE NIL))
	(TV:PANE-MIXIN TV:DONT-SELECT-WITH-MOUSE-MIXIN
	 DW:MARGIN-MIXIN
	 ARROW-PRINTING-MIXIN TV:SCROLL-MOUSE-MIXIN TV:SCROLL-WINDOW-WITH-TYPEOUT-MIXIN
	 TV:WINDOW-WITH-TYPEOUT-MIXIN TV:BASIC-SCROLL-WINDOW
	 ZMAIL-WHO-LINE-OVERRIDE-MIXIN TV:MARGINLESS-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES CURRENT-SEQUENCE CURRENT-MSG RECENTER-P)
  (:DEFAULT-INIT-PLIST
   :TRUNCATION T :SAVE-BITS ':DELAYED :CR-NOT-NEWLINE-FLAG 1
   :DISPLAY-ITEM (SUMMARY-DISPLAY-ITEM)
   :MARGIN-COMPONENTS `((DW:MARGIN-BORDERS)
			(DW:MARGIN-SCROLL-BAR :SHAFT-WHITESPACE-THICKNESS 4
					      :HISTORY-NOUN "messages")
			(DW:MARGIN-LABEL :MARGIN :TOP
					 :BOX :INSIDE
					 :STRING ,(CL:COPY-SEQ *SUMMARY-WINDOW-LABEL*))
			(DW:MARGIN-WHITE-BORDERS))))

(DEFMETHOD (:INIT ZMAIL-SUMMARY-SCROLL-WINDOW :BEFORE) (IGNORE)
  (SETQ TV:TYPEOUT-WINDOW
	`(ZMAIL-SUMMARY-TYPEOUT-WINDOW :IO-BUFFER ,TV:IO-BUFFER)))

(DEFMETHOD (:MODE-LINE-WINDOW ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  *GLOBAL-MODE-LINE-WINDOW*)

(DEFVAR *SUMMARY-WINDOW-PSUEDO-MOUSE-DOCUMENTATION-STRING*
  (MAKE-ARRAY 1. :TYPE ART-STRING :FILL-POINTER 0))

(DEFMETHOD (:MOUSE-DOCUMENTATION-STRING ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  *SUMMARY-WINDOW-PSUEDO-MOUSE-DOCUMENTATION-STRING*)

(DEFMETHOD (:FINISH-DELAYED-SELECT ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  NIL)

(DEFMETHOD (:SET-CURRENT-SEQUENCE ZMAIL-SUMMARY-SCROLL-WINDOW) (SEQUENCE)
  (COND ((NEQ CURRENT-SEQUENCE SEQUENCE)
	 (SETQ MSGS-TO-BE-REDISPLAYED T
	       RECENTER-P T)
	 (SETQ CURRENT-SEQUENCE SEQUENCE))))

(DEFWHOPPER (:REDISPLAY ZMAIL-SUMMARY-SCROLL-WINDOW) (&REST ARGS)
  (IF CURRENT-SEQUENCE
      (LOCK-SEQUENCE (CURRENT-SEQUENCE :READ)
	(WHEN CURRENT-SEQUENCE (SEND CURRENT-SEQUENCE :CERTIFY-FOR-SELECTION))
	;; It is the responsibility of the caller(s) to ensure the current message
	;; is not expunged.
	(LEXPR-CONTINUE-WHOPPER ARGS))
    (LEXPR-CONTINUE-WHOPPER ARGS)))
(DEFUN SUMMARY-SCROLL-DISPLAY-ITEM-STEPPER (WINDOW INDEX)
  (LET ((CURRENT-SEQUENCE (SEND WINDOW :CURRENT-SEQUENCE)))
    (IF CURRENT-SEQUENCE
	(LET ((MSG (AREF (SEQUENCE-ARRAY CURRENT-SEQUENCE) INDEX)))
	  (WHEN MSG
	    (SETF (MSG-DISPLAYED-INDEX MSG) INDEX))
	  (VALUES MSG
		  (INCF INDEX)
		  ( INDEX (SEQUENCE-NMSGS CURRENT-SEQUENCE))))
      (VALUES NIL (INCF INDEX) T))))

(DEFMETHOD (:REDISPLAY ZMAIL-SUMMARY-SCROLL-WINDOW :BEFORE) (&REST IGNORE
							     &AUX TOP-SEQUENCE)
  (WHEN (LISTP MSGS-TO-BE-REDISPLAYED)
    (SETQ MSGS-TO-BE-REDISPLAYED (REM-IF #'(LAMBDA (MSG) (EQ (MSG-PARSED-P MSG) :KILLED))
					 MSGS-TO-BE-REDISPLAYED))) 
  (WHEN (AND CURRENT-SEQUENCE (PLUSP (SEQUENCE-NMSGS CURRENT-SEQUENCE)))
    (SETQ TOP-SEQUENCE (MSG-BUFFER (SUMMARY-SCROLL-DISPLAY-ITEM-STEPPER SELF 0))))
  (UNLESS (EQ LAST-DISPLAYED-TOP-SEQUENCE TOP-SEQUENCE)
    (SETQ TV:TOP-ITEM NIL TV:TARGET-TOP-ITEM NIL))
  (SETQ LAST-DISPLAYED-TOP-SEQUENCE TOP-SEQUENCE)
  (WHEN TOP-SEQUENCE
    (SEND TOP-SEQUENCE :CERTIFY-FOR-SELECTION)))

(DEFMETHOD (:SET-CURRENT-MSG ZMAIL-SUMMARY-SCROLL-WINDOW) (MSG)
  (COND ((NEQ CURRENT-MSG MSG)
	 (COND ((NEQ MSGS-TO-BE-REDISPLAYED T)
		(AND CURRENT-MSG (PUSH* CURRENT-MSG MSGS-TO-BE-REDISPLAYED))
		(AND MSG (PUSH* MSG MSGS-TO-BE-REDISPLAYED))))
	 (SETQ CURRENT-MSG MSG)))
  (SETQ RECENTER-P T))

(DEFMETHOD (:NEED-TO-REDISPLAY-MSG ZMAIL-SUMMARY-SCROLL-WINDOW) (MSG)
  (OR (EQ MSGS-TO-BE-REDISPLAYED T)
      (PUSH* MSG MSGS-TO-BE-REDISPLAYED)))

(DEFMETHOD (:NEED-FULL-REDISPLAY ZMAIL-SUMMARY-SCROLL-WINDOW) (&OPTIONAL RECENTER-TOO)
  (SETQ MSGS-TO-BE-REDISPLAYED T)
  (AND RECENTER-TOO (SETQ RECENTER-P T)))

(DEFMETHOD (:REDISPLAY-AS-NECESSARY ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  (AND (SEND TV:TYPEOUT-WINDOW ':BOTTOM-REACHED)
       (SETQ MSGS-TO-BE-REDISPLAYED T))
  (COND ((OR MSGS-TO-BE-REDISPLAYED RECENTER-P)
	 (AND CURRENT-MSG RECENTER-P (NEQ MSGS-TO-BE-REDISPLAYED T)
	      (SEND SELF ':DISPLAY-VALIDATE-CURRENT-MSG-POSITION))
	 (IF (EQ MSGS-TO-BE-REDISPLAYED T)	;Full redisplay needed
	     (SEND SELF ':REDISPLAY)
	     (TV:SCROLL-MAINTAIN-LIST-UPDATE-STATES MSGS-TO-BE-REDISPLAYED SELF))
	 (SETQ MSGS-TO-BE-REDISPLAYED NIL
	       RECENTER-P NIL))))

(DEFUN SUMMARY-SCROLL-ITEM-INITIALIZER ()
  (LET ((CURRENT-SEQUENCE (SEND TV:*SCROLL-WINDOW* :CURRENT-SEQUENCE)))
    (AND CURRENT-SEQUENCE (PLUSP (SEND CURRENT-SEQUENCE ':NMSGS))
	 0)))

;;; Idea from DCP to speed up scroll window setup for sequence switches
;;;   9 oct 84
(DEFUN SUMMARY-SCROLL-DISPLAY-ITEM-DISPLAYER (MSG)
  (AND MSG
       (OR (GET (LOCF (MSG-STATUS MSG)) 'SCROLL-ITEM-DISPLAYER)
	   (FAKE-SCROLL-ITEM MSG))))

;; Faster way to make scroll items, and do less random consing.
;; This also gives us control over what area it is consed in!
;; RWK 6 Apr 85

(DEFUN FAKE-SCROLL-ENTRY (&REST ELEMENTS)
  (LET ((ENTRY (MAKE-ARRAY 12. :AREA *ZMAIL-SUMMARY-AREA*)))
    (DECLARE (SYS:ARRAY-REGISTER ENTRY))
    (LOOP FOR I FROM 0
	  FOR E IN ELEMENTS
	  DO (SETF (AREF ENTRY I) E))
    ENTRY))

(DEFUN MAKE-FAKE-SCROLL-ITEM (MSG)
  (LET ((ITEM (MAKE-ARRAY 4 :LEADER-LENGTH TV:SCROLL-ITEM-LEADER-OFFSET
			  :AREA *ZMAIL-SUMMARY-AREA*)))
    (DECLARE (SYS:ARRAY-REGISTER ITEM))
    (LET ((SUMMARY-LINE-MOUSE-STUFF (LIST-IN-AREA *ZMAIL-SUMMARY-AREA* 'SUMMARY-MOUSE MSG)))
      (SETF (TV:SCROLL-ITEM-LINE-SENSITIVITY ITEM) SUMMARY-LINE-MOUSE-STUFF)
      (SETF (AREF ITEM 0)
	    (FAKE-SCROLL-ENTRY 'TV:SCROLL-ENTRY-CALL-FUNCTION-FUNCTION
			       'SUMMARY-DISPLAY-UPDATE (CDR SUMMARY-LINE-MOUSE-STUFF)
			       0 0 0 1 NIL
			       (NCONS-IN-AREA NIL *ZMAIL-SUMMARY-AREA*)
			       NIL '("~\ZWEI:ARROW\"))))
    (SETF (AREF ITEM 1)
	  (FAKE-SCROLL-ENTRY 'TV:SCROLL-ENTRY-CALL-FUNCTION-FUNCTION
			     #'TV:VALUE '(0)
			     0 0 0 0 T
			     (NCONS-IN-AREA NIL *ZMAIL-SUMMARY-AREA*) NIL '("~3D")))
    (SETF (AREF ITEM 2)
	  (FAKE-SCROLL-ENTRY 'TV:SCROLL-ENTRY-CALL-FUNCTION-FUNCTION
			     #'TV:VALUE '(1)
			     0 0 0 1 NIL
			     (NCONS-IN-AREA NIL *ZMAIL-SUMMARY-AREA*) NIL '("~C")))
    (SETF (AREF ITEM 3)
	  (FAKE-SCROLL-ENTRY 'ZMAIL-SUMMARY-LINE-SCROLL-ENTRY-FUNCTION
			     #'TV:VALUE '(2)
			     0 0 0 0 T
			     (NCONS-IN-AREA NIL *ZMAIL-SUMMARY-AREA*)))
    ITEM))

(DEFSELECT (ZMAIL-SUMMARY-LINE-SCROLL-ENTRY-FUNCTION TV:SCROLL-ENTRY-CALL-FUNCTION-FUNCTION)
  (:CHANGED-P (ENTRY US)
   (COND ((NOT (CL:EQUAL (TV:SCROLL-ENTRY-DATA ENTRY) (FUNCALL US :RECOMPUTE ENTRY)))
	  (SETF (TV:SCROLL-ENTRY-PRINTED-FORM ENTRY) NIL)
	  T)
	 (T NIL))))

;;; Given a message, add a scroll item.
(DEFUN FAKE-SCROLL-ITEM (MSG)
  (LET ((ITEM (MAKE-FAKE-SCROLL-ITEM MSG)))
    (PUTPROP (LOCF (MSG-STATUS MSG)) ITEM 'SCROLL-ITEM-DISPLAYER)
    ITEM))

#||
;;; This is what the above (fake-scroll-item etc.) simulates.
(DEFUN MAKE-SCROLL-ITEM-DISPLAYER (MSG)
  (LET ((NEW (TV:SCROLL-PARSE-ITEM
	       ':MOUSE `(SUMMARY-MOUSE ,MSG)
	       `(:FUNCTION SUMMARY-DISPLAY-UPDATE (,MSG) 1 ("~\ZWEI:ARROW\"))
	       `(:VALUE 0 NIL ("~3D"))
	       `(:VALUE 1 1 ("~C"))
	       `(:VALUE 2 NIL NIL))))
    (PUTPROP (LOCF (MSG-STATUS MSG)) NEW 'SCROLL-ITEM-DISPLAYER)))

||#

(DEFVAR *KILLED-MSG-STATUS* '(KILLED T))
(DEFVAR *UNPARSEABLE-MSG-STATUS* '(UNPARSEABLE T))

(DEFUN SUMMARY-DISPLAY-UPDATE (MSG)
  (LET-IF (NOT (VARIABLE-BOUNDP *SUMMARY-WINDOW*))
	  1;; The (3 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")parse-msg1 method for inboxes indirectly references the summary window --
	  ;;    If we are invoked in the scroll process, this variable will be unbound so
	  ;;    we must be certain to supply a value here.
0	  ((*SUMMARY-WINDOW* TV:*SCROLL-WINDOW*))
    (LET* ((STATUS (IF (EQ (MSG-PARSED-P MSG) :KILLED)
		       (LOCF *KILLED-MSG-STATUS*)
		     (CONDITION-CASE ()
			  (ASSURE-MSG-PARSED MSG)
			(ERROR
			  (LOCF *UNPARSEABLE-MSG-STATUS*)))))
	   (SUMMARY-LINE (COND ((GET STATUS 'KILLED) "    **** Killed Message ****")
			       ((GET STATUS 'UNPARSEABLE) "    **** Unparsable Message ****")
			       (T (MSG-SUMMARY-LINE MSG))))
	   (VALUE-SEQUENCE (TV:VALUE-SEQUENCE)))
      (SETF (TV:VALUE-SEQUENCE-REF VALUE-SEQUENCE 2) SUMMARY-LINE)
      (SETF (TV:VALUE-SEQUENCE-REF VALUE-SEQUENCE 1) (STATUS-LETTER STATUS))
      (SETF (TV:VALUE-SEQUENCE-REF VALUE-SEQUENCE 0) (1+ (MSG-DISPLAYED-INDEX MSG)))
      (COND ((GET STATUS 'MARKED)
	     (IF (EQ MSG *MARK-SURVEY-CURRENT-MSG*) :MARK-SURVEY-MARKED-AND-CURRENT :MARKED))
	    ((EQ MSG *MARK-SURVEY-CURRENT-MSG*) :MARK-SURVEY-CURRENT)
	    ((EQ MSG (SEND TV:*SCROLL-WINDOW* :CURRENT-MSG)) :CURRENT)))))
(DEFUN SUMMARY-SCROLL-PRE-PROCESS-FUNCTION (ITEM)
  (TV:SCROLL-MAINTAIN-LIST-UPDATE-FUNCTION ITEM)	1;Do numbering pass.
0  (AND (SEND TV:*SCROLL-WINDOW* :CURRENT-MSG)
       (SEND TV:*SCROLL-WINDOW* :CURRENT-SEQUENCE)
       (PLUSP (SEQUENCE-NMSGS (SEND TV:*SCROLL-WINDOW* :CURRENT-SEQUENCE)))
       (SEND TV:*SCROLL-WINDOW* :RECENTER-P)
       (SEND TV:*SCROLL-WINDOW* :DISPLAY-VALIDATE-CURRENT-MSG-POSITION)))

(DEFUN SUMMARY-DISPLAY-ITEM ()
  (TV:SCROLL-MAINTAIN-LIST
    #'SUMMARY-SCROLL-ITEM-INITIALIZER
    #'SUMMARY-SCROLL-DISPLAY-ITEM-DISPLAYER
    NIL
    #'(LAMBDA (INDEX) (SUMMARY-SCROLL-DISPLAY-ITEM-STEPPER TV:*SCROLL-WINDOW* INDEX))
    T
    #'SUMMARY-SCROLL-PRE-PROCESS-FUNCTION))

(DEFMETHOD (:DISPLAY-VALIDATE-CURRENT-MSG-POSITION ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  (AND *SUMMARY-SCROLL-FRACTION*
       (LET* ((CURRENT-INDEX (MSG-DISPLAYED-INDEX CURRENT-MSG))
	      (TOP-INDEX (OR TV:TOP-ITEM 0))
	      (N-LINES (TV:SHEET-NUMBER-OF-INSIDE-LINES))
	      (BOTTOM-INDEX (+ TOP-INDEX N-LINES))
	      NEW-TARGET)
	 (COND ((NULL CURRENT-INDEX))		;Not displayed yet
	       ((< CURRENT-INDEX TOP-INDEX)
		(SETQ NEW-TARGET (- CURRENT-INDEX
				    (FIX (* *SUMMARY-SCROLL-FRACTION* N-LINES)))))
	       (( CURRENT-INDEX BOTTOM-INDEX)
		(SETQ NEW-TARGET (+ (- CURRENT-INDEX N-LINES)
				    (FIX (* *SUMMARY-SCROLL-FRACTION* N-LINES))))))
	 (WHEN NEW-TARGET
	   (SETQ TV:TARGET-TOP-ITEM (MAX 0 NEW-TARGET)
		 MSGS-TO-BE-REDISPLAYED T)))))

;;; If told to scroll explicitly, don't jump back
(DEFMETHOD (:SCROLL-TO ZMAIL-SUMMARY-SCROLL-WINDOW :AFTER) (&REST IGNORE)
  (SETQ RECENTER-P NIL))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  (WHEN TV:CURRENT-ITEM
    (GET 'ZMAIL-SUMMARY-MOUSE :WHO-LINE-DOCUMENTATION)))

(DEFMETHOD (:WHO-LINE-OVERRIDE-P ZMAIL-SUMMARY-SCROLL-WINDOW) ()
  TV:CURRENT-ITEM)

(DEFINE-ZMAIL-GLOBAL *LAST-SUMMARY-MOUSE-ITEM* NIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER ZMAIL-SUMMARY-MOUSE (STRING)
  (FORMAT STRING "Operate on this message: L: Select;  M: ~A; R: menu."
	  (NAME-FROM-MENU-VALUE *SUMMARY-MOUSE-MIDDLE-MODE*
				*SUMMARY-MOUSE-MIDDLE-MENU-ALIST*)))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *SUMMARY-MOUSE-MIDDLE-MODE* ZMAIL-SUMMARY-MOUSE)

(DEFUN ZMAIL-SUMMARY-MOUSE (MSG)
  (WHEN (EQ (MSG-PARSED-P MSG) ':KILLED)
    (BARF "Message has been expunged."))
  (LET ((BUTTON *ZMAIL-COMMAND-BUTTON*)
	(OPTION ':SELECT))
    (UNLESS (EQ BUTTON ':LEFT)
      (MULTIPLE-VALUE (OPTION *LAST-SUMMARY-MOUSE-ITEM*)
	(ZMAIL-MENU-CHOOSE NIL
			   (IF (EQ *ZMAIL-COMMAND-BUTTON* ':MIDDLE)
			       *SUMMARY-MOUSE-MIDDLE-MENU-ALIST*
			       (LOOP FOR ELEM IN *SUMMARY-MOUSE-MENU-ALIST*
				     WHEN (LET ((FILTER (GET ELEM ':FILTER)))
					    (COND ((NULL FILTER)
						   T)
						  ((LISTP FILTER)
						   (LEXPR-FUNCALL (CAR FILTER) MSG
								  (CDR FILTER)))
						  (T
						   (FUNCALL FILTER MSG))))
				     DO (LET ((FUNCTION (GET ELEM ':DOCUMENTATION-UPDATER)))
					  (WHEN FUNCTION
					    (FUNCALL FUNCTION (GET ELEM ':DOCUMENTATION)
						     MSG)))
				     AND COLLECT ELEM))
			   *LAST-SUMMARY-MOUSE-ITEM* '(:MOUSE) *SUMMARY-MOUSE-MIDDLE-MODE*
			   (FORMAT NIL "Message #~D" (1+ (MSG-DISPLAYED-INDEX MSG)))))
      (IF (EQ BUTTON ':MIDDLE)
	  (SETQ *ZMAIL-COMMAND-BUTTON* ':RIGHT
		BUTTON ':LEFT)
	  (SETQ BUTTON *ZMAIL-COMMAND-BUTTON*)))
    (INVOKE-SUMMARY-MOUSE-OPTION OPTION MSG BUTTON))
  DIS-TEXT)

(DEFUN INVOKE-SUMMARY-MOUSE-OPTION (OPTION MSG BUTTON)
  (LET ((FUNCTION (GET OPTION 'SUMMARY-MOUSE-OPTION)))
    (WHEN (NULL FUNCTION)
      (BARF "~S is not a known summary mouse option." OPTION))
    (FUNCALL FUNCTION MSG BUTTON)))

(DEFUN SEQUENCE-NOT-BUFFER-P (IGNORE)
  (NOT (SEQUENCE-BUFFER-P *SEQUENCE*)))

(DEFUN MSG-NOT-DRAFT-MSG-P (MSG)
  (NOT (MSG-DRAFT-MSG-P MSG)))

(DEFUN (:DELETE-OR-REMOVE SUMMARY-MOUSE-OPTION) (MSG BUTTON)
  (INVOKE-SUMMARY-MOUSE-OPTION (IF (SEQUENCE-BUFFER-P *SEQUENCE*)
				   ':DELETE-OR-UNDELETE
				   ':REMOVE)
			       MSG BUTTON))

(DEFUN (:DELETE-OR-UNDELETE SUMMARY-MOUSE-OPTION) (MSG BUTTON)
  (INVOKE-SUMMARY-MOUSE-OPTION (IF (MSG-GET MSG 'DELETED) ':UNDELETE ':DELETE)
			       MSG BUTTON))

(DEFUN (:SELECT SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (WHEN (EQ *WINDOW-CONFIGURATION* ':SUMMARY)
    (SEND *CURRENT-ZMAIL-COMMAND-LOOP* ':SET-WINDOW-CONFIGURATION ':MSG))
  (SELECT-MSG-AND-POSSIBLY-BUFFER MSG)
  (MUST-REDISPLAY *MSG-WINDOW* DIS-ALL))

(DEFUN (:DELETE SUMMARY-MOUSE-OPTION) (MSG BUTTON)
  (UNLESS (MSG-GET MSG 'DELETED)
    (ZMAIL-DELETE-MSG MSG BUTTON)))

(DEFUN (:UNDELETE SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (WHEN (MSG-GET MSG 'DELETED)
    (ZMAIL-UNDELETE-MSG MSG)))

(DEFUN (:REMOVE SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (REMOVE-MSG *SEQUENCE* MSG (LOCATE-MSG-IN-SEQUENCE MSG *SEQUENCE*)))

(DEFUN (:KEYWORDS SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (ZMAIL-KEYWORDS-MSG MSG))

(DEFUN (:REPLY SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (ZMAIL-SELECT-MSG MSG)
  (COM-ZMAIL-REPLY))

(DEFUN (:MOVE SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (MOVE-MSG-INTERNAL MSG))

(DEFUN UPDATE-SUMMARY-MOVE-TO-FILE-WHO-LINE-DOCUMENTATION (STRING MSG)
  (UPDATE-MOVE-TO-FILE-WHO-LINE-DOCUMENTATION STRING "Move this message into sequence: " MSG))

(DEFUN (:APPEND SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (ZMAIL-CONCATENATE-MSG MSG))

(DEFUN (:FILTER SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (SELECT-SEQUENCE (MAKE-COLLECTION-FROM-FILTER-FROM-MSG MSG)))

(DEFUN (:FORWARD SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (ZMAIL-SELECT-MSG MSG)
  (COM-ZMAIL-FORWARD))

(DEFUN (:REDISTRIBUTE SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (ZMAIL-SELECT-MSG MSG)
  (COM-ZMAIL-REDISTRIBUTE-MSG))

(DEFUN (:SURVEY SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (SURVEY-FROM-FILTER (MSG-CONVERSATION-COLLECTION MSG T) 'MSG-TRUE-FILTER NIL))

(DEFUN (:CONVERSATION SUMMARY-MOUSE-OPTION) (MSG IGNORE)
  (ZMAIL-SELECT-MSG MSG)
  (COM-ZMAIL-SELECT-CONVERSATION-BY-REFERENCES))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION SUMMARY-REPLY-DOCUMENTATION
				       *SUMMARY-REPLY-DOCUMENTATION*)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER SUMMARY-REPLY-DOCUMENTATION
					       (STRING &OPTIONAL RECURSIVE)
  (OR RECURSIVE (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'NORMAL-REPLY NIL T))
  (STRING-NCONC STRING "Select and reply to this message: "
		(GET 'NORMAL-REPLY ':WHO-LINE-DOCUMENTATION)))

(DEFFLAVOR ZMAIL-MAIN-COMMAND-MENU-PANE () (MENU-COMMAND-MENU-MIXIN TV:COMMAND-MENU-PANE))

;;; Keyword hacking menu

(DEFFLAVOR ZMAIL-MULTIPLE-MENU-MIXIN
	(NEW-FUNCTION)
	(TV:MULTIPLE-MENU-MIXIN)
  (:SETTABLE-INSTANCE-VARIABLES NEW-FUNCTION)
  (:DEFAULT-INIT-PLIST :COLUMNS 3
    		       :SPECIAL-CHOICES '(("Abort" :VALUE ABORT
						   :DOCUMENTATION "Abort this command.")
					  ("Do It" :VALUE DO-IT
					   :DOCUMENTATION "Use highlighted items.")
					  ("New" :VALUE NEW
						 :DOCUMENTATION "Add a new item."))))

(DEFFLAVOR ZMAIL-MULTIPLE-MENU () (ZMAIL-MULTIPLE-MENU-MIXIN TV:MENU))

(DEFFLAVOR POP-UP-ZMAIL-MULTIPLE-MENU () (ZMAIL-MULTIPLE-MENU-MIXIN TV:POP-UP-MENU))
1;;; This is the message to call, it takes a keyword alist and a list of currently on
;;; keywords, and returns updated versions of each.
0(DEFMETHOD (:MULTIPLE-CHOOSE ZMAIL-MULTIPLE-MENU-MIXIN) (ITEM-LIST CURRENTLY-ACTIVE
							 &OPTIONAL (NEAR-MODE '(:MOUSE)))
  (LET ((OLD-STATUS (SEND SELF :STATUS)))
    (UNWIND-PROTECT
	(TV:SAVING-MOUSE-POSITION SELF
	  (SEND SELF :SET-ITEM-LIST ITEM-LIST)
	  (SEND SELF :SET-HIGHLIGHTED-VALUES CURRENTLY-ACTIVE)
	  (TV:EXPOSE-WINDOW-NEAR SELF NEAR-MODE)
	  (DO ((CHOICE (SEND SELF :CHOOSE) (SEND SELF :CHOOSE)))
	      (NIL)
	    (COND ((EQ CHOICE 'DO-IT)
		   (TV:RESTORE-MOUSE-POSITION-IF-NECESSARY)
		   (RETURN-FROM :MULTIPLE-CHOOSE
		     (VALUES ITEM-LIST (SEND SELF :HIGHLIGHTED-VALUES))))
		  ((EQ CHOICE 'ABORT)
		   (RETURN-FROM :MULTIPLE-CHOOSE
		     (VALUES ITEM-LIST :ABORT)))
		  ((EQ CHOICE 'NEW)
		   (LET ((NEW (FUNCALL NEW-FUNCTION SELF ITEM-LIST CURRENTLY-ACTIVE)))
		     (WHEN NEW
		       (UNLESS (MEMBER NEW ITEM-LIST)
			 (SETQ ITEM-LIST (NCONC ITEM-LIST (NCONS NEW)))
1			 ;; This isn't all right but it prevents errors trying to expose --
			 ;;    It would be nice if this were handled by the menu system.
0			 (SEND SELF :DEEXPOSE)
			 (LET ((OHI (TV:MENU-HIGHLIGHTED-ITEMS SELF)))
			   (SEND SELF :SET-ITEM-LIST ITEM-LIST)
			   (SEND SELF :SET-HIGHLIGHTED-ITEMS OHI))
			 (TV:EXPOSE-WINDOW-NEAR SELF '(:MOUSE)))
		       (SEND SELF :ADD-HIGHLIGHTED-ITEM NEW)))))))
      (SEND SELF :SET-STATUS OLD-STATUS))))
(DEFUN ZMAIL-MULTIPLE-MENU-CHOOSE (ITEM-LIST CURRENTLY-ACTIVE NEW-FUNCTION
				   &OPTIONAL (NEAR-MODE '(:MOUSE)) LABEL)
  (USING-RESOURCE (MENU POP-UP-ZMAIL-MULTIPLE-MENU *ZMAIL-WINDOW*)
    (SEND MENU :SET-NEW-FUNCTION NEW-FUNCTION)
    (SEND MENU :SET-LABEL LABEL)
    (MULTIPLE-VALUE-BIND (NEW-ITEM-LIST NEWLY-ACTIVE)
	(SEND MENU :MULTIPLE-CHOOSE ITEM-LIST CURRENTLY-ACTIVE NEAR-MODE)
      (IF (EQ NEWLY-ACTIVE :ABORT)
	  (ABORT-CURRENT-COMMAND)
	  (VALUES NEW-ITEM-LIST NEWLY-ACTIVE)))))

(DEFUN MULTIPLE-MENU-NEW-KEYWORD (WINDOW KEYWORD-ALIST &OPTIONAL IGNORE)
  (LET ((KEYWORD-STRING (CATCH-ZWEI-COMMAND-LOOP
			  (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR
			    WINDOW #'TYPEIN-LINE-READLINE "New keyword:"))))
    (COND ((NOT (STRINGP KEYWORD-STRING)) NIL)
	  ((> (STRING-LENGTH KEYWORD-STRING) 0)
	   (LET* ((KEYWORD-SYMBOL (INTERN (STRING-UPCASE KEYWORD-STRING)
					  SI:PKG-KEYWORD-PACKAGE))
		  (KEYWORD-ITEM (RASSQ KEYWORD-SYMBOL KEYWORD-ALIST)))
	     (IF (NOT KEYWORD-ITEM)
		 1;; A legitimately new keyword.
0		 (CONS KEYWORD-STRING KEYWORD-SYMBOL)
	       1;; Already have this keyword -- Return it anyway but beep as a warning.
0	       (BEEP)
	       KEYWORD-ITEM)))
	  (T
	   1;; Just typed return.
0	   (BEEP)
	   NIL))))

(DEFUN MULTIPLE-MENU-NEW-PATHNAME (WINDOW ITEM-LIST &OPTIONAL IGNORE)
  (LET ((PATH (CATCH-ZWEI-COMMAND-LOOP
		(MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR
		  WINDOW #'ACCEPT-DEFAULTED-PATHNAME
		  "New file" (DEFAULT-ZMAIL-MOVE-PATHNAME))))
	)
    (WHEN (CL:PATHNAMEP PATH)
      (LET* ((PATH-STRING (SEND PATH :STRING-FOR-EDITOR))
	     (PATH-ITEM (ASSOC PATH-STRING ITEM-LIST)))
	(IF (NOT PATH-ITEM)
	    1;; A legitimately new pathname.
0	    (CONS PATH-STRING PATH)
	  1;; Already have this pathname -- Return it anyway but beep as a warning
0	  (BEEP)
	  PATH-ITEM)))))

(DEFFLAVOR CLICK-REMEMBERING-MIXIN
	((LAST-BUTTONS 1))
	()
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:MOUSE-BUTTONS CLICK-REMEMBERING-MIXIN :AFTER) (BD IGNORE IGNORE)
  (SETQ LAST-BUTTONS BD))

(DEFFLAVOR CLICK-REMEMBERING-POP-UP-MENU ()
	   (CLICK-REMEMBERING-MIXIN TV:WINDOW TV:POP-UP-MENU))

(DEFFLAVOR ZMAIL-MOMENTARY-MENU () (CLICK-REMEMBERING-MIXIN TV:WINDOW TV:MOMENTARY-MENU))

(DEFFLAVOR ZMAIL-MOMENTARY-COMMAND-MENU () (MENU-COMMAND-MENU-MIXIN ZMAIL-MOMENTARY-MENU))

(DEFFLAVOR ZMAIL-DYNAMIC-MOMENTARY-COMMAND-MENU () (TV:DYNAMIC-ITEM-LIST-MIXIN
						    ZMAIL-MOMENTARY-COMMAND-MENU))

(DEFUN ZMAIL-MENU-CHOOSE (MENU &OPTIONAL ITEM-LIST DEFAULT-ITEM NEAR-MODE MIDDLE PROMPT)
  (DECLARE (VALUES VALUE ITEM))
  (FLET ((MENU-CHOOSE (MENU)
	   (COND ((EQ *ZMAIL-COMMAND-BUTTON* :MIDDLE)
		  (UNLESS MIDDLE
		    (BARF "No user option has been set for this command."))
		  (SETQ *ZMAIL-COMMAND-BUTTON* :LEFT
			DEFAULT-ITEM (CL:FIND MIDDLE ITEM-LIST
					      :KEY #'TV:MENU-EXECUTE-NO-SIDE-EFFECTS)))
		 ((EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
		  (TV:SAVING-MOUSE-POSITION MENU
		    (TV:EXPOSE-WINDOW-NEAR MENU (OR NEAR-MODE (RECTANGLE-NEAR-COMMAND-MENU)))
		    (WHEN DEFAULT-ITEM
		      (MULTIPLE-VALUE-BIND (X Y)
			  (SEND MENU :ITEM-CURSORPOS DEFAULT-ITEM)
			(WHEN (AND X Y)
			  (SEND MENU :SET-MOUSE-POSITION (+ X (TV:SHEET-INSIDE-LEFT MENU))
				(+ Y (TV:SHEET-INSIDE-TOP MENU))))))
		    (UNLESS (SEND MENU :CHOOSE)
		      (ABORT-CURRENT-COMMAND))
		    (TV:RESTORE-MOUSE-POSITION-IF-NECESSARY)
		    (SETQ DEFAULT-ITEM (SEND MENU :LAST-ITEM))
		    (SET-COMMAND-BUTTON (SEND MENU :LAST-BUTTONS))))
		 ((NULL DEFAULT-ITEM)
		  (BARF "There is no default for this command yet.")))
	     (VALUES (SEND MENU :EXECUTE DEFAULT-ITEM) DEFAULT-ITEM)))
    (WHEN (NULL MENU)
      (SETQ MENU 'ZMAIL-MOMENTARY-MENU))
    (IF (SYMBOLP MENU)
	1;; Caller wants us to temporarily allocate a menu --
0	1;;    We can't use the 3using-resource1 form here as it requires the resource to be
0	1;;    known at compile time.  The following code is the equivalent of 3using-resource1.
0	(LET (REAL-MENU .RESOURCE-DESCRIPTOR.)
	  (UNWIND-PROTECT
	      (PROGN
		(MULTIPLE-VALUE (REAL-MENU .RESOURCE-DESCRIPTOR.)
		  (ALLOCATE-RESOURCE MENU *ZMAIL-WINDOW*))
		(SEND REAL-MENU :SET-LABEL PROMPT)
		(SEND REAL-MENU :SET-ITEM-LIST ITEM-LIST)
		(SEND REAL-MENU :SET-LAST-ITEM DEFAULT-ITEM)
		(MENU-CHOOSE REAL-MENU))
	    (WHEN REAL-MENU
	      (DEALLOCATE-RESOURCE MENU REAL-MENU .RESOURCE-DESCRIPTOR.))))
      1;; Caller has supplied an actual menu.
0      (SETQ ITEM-LIST (SEND MENU :ITEM-LIST))
      (MENU-CHOOSE MENU))))

(DEFUN SET-COMMAND-BUTTON (BUTTON)
  (SETQ *ZMAIL-COMMAND-BUTTON* (NTH (IF (MOUSE-CHAR-P BUTTON)
					(CHAR-MOUSE-BUTTON BUTTON)
					(1- (HAULONG BUTTON)))
				    '(:LEFT :MIDDLE :RIGHT))))

1;;; Return location of last selected item for use as a near-mode.
0(DEFUN RECTANGLE-NEAR-COMMAND-MENU (&OPTIONAL (TOP-SHEET *ZMAIL-WINDOW*))
  (COND ((CHARACTERP *LAST-COMMAND-CHAR*)
	 #+IGNORE '(:KBD)
	 1;; Really should return the previous value but only Zmail understands it and this
0	 1;; function's value is often used as an argument to 3tv:expose-window-near1.
0	 #-IGNORE `(:WINDOW ,*MODE-LINE-WINDOW*))
	((AND (LISTP *LAST-COMMAND-CHAR*) (EQ (FIRST *LAST-COMMAND-CHAR*) :MENU))
	 (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	     (SEND (FOURTH *LAST-COMMAND-CHAR*) :ITEM-RECTANGLE (SECOND *LAST-COMMAND-CHAR*))
	   (MULTIPLE-VALUE-BIND (XOFF YOFF)
	       (TV:SHEET-CALCULATE-OFFSETS (FOURTH *LAST-COMMAND-CHAR*) TOP-SHEET)
	     `(:RECTANGLE ,(+ LEFT XOFF) ,(+ TOP YOFF) ,(+ RIGHT XOFF) ,(+ BOTTOM YOFF)))))
	(T
	 '(:MOUSE))))

(DEFUN DEFAULTED-MULTIPLE-MENU-CHOOSE-NEAR-MENU (ALIST &REST DEFAULTS)
  (SETQ DEFAULTS (TV:DEFAULTED-MULTIPLE-MENU-CHOOSE ALIST DEFAULTS
		   (RECTANGLE-NEAR-COMMAND-MENU (TV:MOUSE-SHEET (TV:SHEET-MOUSE *ZMAIL-WINDOW*)))))
  (OR DEFAULTS (ABORT-CURRENT-COMMAND))
  (VALUES-LIST DEFAULTS))

(DEFUN MENU-CHOOSE-WITH-NEW (ITEM-LIST NEW-FUNCTION &OPTIONAL (NEAR-MODE '(:MOUSE)) LABEL
						    &AUX VALUE)
  (USING-RESOURCE (MENU ZMAIL-MOMENTARY-MENU *ZMAIL-WINDOW*)
    (SEND MENU ':SET-LABEL LABEL)
    (SEND MENU ':SET-ITEM-LIST (CONS '("New" :VALUE :NEW
				       :STYLE (:DUTCH :ITALIC :NORMAL)
				       :DOCUMENTATION "Specify a new item.")
				     ITEM-LIST))
    (SEND MENU ':SET-LAST-ITEM NIL)
    (TV:EXPOSE-WINDOW-NEAR MENU NEAR-MODE)
    (OR (SETQ VALUE (SEND MENU ':CHOOSE)) (ABORT-CURRENT-COMMAND))
    (IF (EQ VALUE ':NEW)
	(SEND MENU ':EXECUTE-NO-SIDE-EFFECTS (FUNCALL NEW-FUNCTION MENU ITEM-LIST))
	VALUE)))

;;; Dynamic windows stuff

(DEFMETHOD (:MOUSE-MOTION-PENDING ZMAIL-FRAME) () NIL)

(DEFMETHOD (:PRESENTATION-INPUT-BLIP-HANDLER ZMAIL-FRAME) (BLIP)
  (SELECTQ (FIRST BLIP)
    (:MOUSE-CLICK
     (DW::DYNAMIC-WINDOW-PRESENTATION-INPUT-BLIP-HANDLER BLIP))))

;;; Not sure where to put this.  It's really a window interface, but
;;; doesn't do any window system hacking.

(DEFUN COMPUTE-HEADER-PRESENTATION-NODES (BUFFER
					  &OPTIONAL HEADERS-START-BP HEADERS-END-BP IN-ORDER-P
						    STOP-AT-BLANK-LINE)
  (CLEAR-INTERVAL-PRESENTATION-NODES BUFFER)
  (WHEN (NULL HEADERS-START-BP)
    (SETQ HEADERS-START-BP BUFFER))
  (GET-INTERVAL HEADERS-START-BP HEADERS-END-BP IN-ORDER-P)
  (CONDITION-CASE ()
       (LET ((*PRESERVE-ADDRESS-INTERVALS* T))
	 (PARSE-HEADERS-INTERVAL HEADERS-START-BP HEADERS-END-BP T STOP-AT-BLANK-LINE))
     (ERROR))
  (ADD-INTERVAL-HEADER-PRESENTATION-NODES HEADERS-START-BP HEADERS-END-BP T))

(DEFUN ADD-INTERVAL-HEADER-PRESENTATION-NODES (HEADERS-START-BP HEADERS-END-BP IN-ORDER-P)
  (GET-INTERVAL HEADERS-START-BP HEADERS-END-BP IN-ORDER-P)
  (LET ((START-LINE (BP-LINE HEADERS-START-BP))
	(END-LINE (BP-LINE HEADERS-END-BP))
	(START-BP HEADERS-START-BP)
	(LAST-HEADERS NIL))
    (LOOP AS LINE = START-LINE THEN (LINE-NEXT LINE)
	  DOING (LET ((THIS-HEADERS (GET (LOCF (LINE-CONTENTS-PLIST LINE)) 'PARSED-HEADERS)))
		  (UNLESS (EQ THIS-HEADERS LAST-HEADERS)
		    (LET ((END-BP (BEG-OF-LINE LINE)))
		      (WHEN LAST-HEADERS
			(ADD-HEADER-PRESENTATION-NODES LAST-HEADERS START-BP END-BP))
		      (SETQ START-BP END-BP
			    LAST-HEADERS THIS-HEADERS))))
	  UNTIL (EQ LINE END-LINE))))

(DEFUN ADD-HEADER-PRESENTATION-NODES (HEADERS START-BP &OPTIONAL END-BP IN-ORDER-P)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (LABELS ((ADD-ADDRESS-HEADER-PRESENTATION-NODES (HEADER SUPERIOR)
	     (LET ((INTERVAL (GET (LOCF HEADER) :INTERVAL)))
	       (WHEN INTERVAL
		 (LET ((PRESENTATION-NODE (ADD-PRESENTATION-NODE HEADER 'ADDRESS
								 (FIRST INTERVAL)
								 (SECOND INTERVAL)
								 SUPERIOR)))
		   (DOLIST (INFERIOR (GET (LOCF HEADER) :INFERIORS))
		     (ADD-ADDRESS-HEADER-PRESENTATION-NODES INFERIOR PRESENTATION-NODE)))))))
    (LET ((PRESENTATION-NODE (ADD-PRESENTATION-NODE HEADERS 'PARSED-HEADERS
						    START-BP END-BP NIL)))
      (LOOP FOR (TYPE HEADER) ON HEADERS BY 'CDDR
	    DOING
	(HEADER-TYPE-TYPECASE TYPE
	  (:ADDRESS
	    (DOLIST (ADDRESS HEADER)
	      (ADD-ADDRESS-HEADER-PRESENTATION-NODES ADDRESS PRESENTATION-NODE)))
	  (:FILE-RECIPIENT
	    (IGNORE-ERRORS			1;Ignore if 3fs:merge-pathnames1 should blow up.
0	      1;; Avoid unwanted namespace queries --
0	      1;;    Currently, this header type doesn't contain fully qualified pathnames
0	      1;;    and, further, isn't parsed when the message is loaded.  Consequently,
0	      1;;    in order to add a meaningfull presentation node, we have to parse the
0	      1;;    pathname here as a consequence of mouse motion.  Therefore, we'll
0	      1;;    accept not always getting a pathname as a tradeoff to making this case
0	      1;;    faster by suppressing namespace queries.  The correct fix, of course,
0	      1;;    is to parse this type of header normally at message loading.
0	      (PARSING-HOST-OBJECT
		(ADD-PRESENTATION-NODE (FS:MERGE-PATHNAMES HEADER) 'FS:PATHNAME
				       (SEARCH START-BP #/: NIL NIL NIL END-BP) END-BP
				       PRESENTATION-NODE))))
	  (:SUBJECT
	    (ADD-PRESENTATION-NODE HEADER 'SUBJECT
				   (SEARCH START-BP #/: NIL NIL NIL END-BP) END-BP
				   PRESENTATION-NODE))
	  (:FILE-LIST
	    (ADD-COMMA-SEPARATED-PRESENTATION-NODES HEADER PRESENTATION-NODE NIL
						    START-BP END-BP T
						    :TEST #'CL:PATHNAMEP)))))))

(DEFUN ADD-COMMA-SEPARATED-PRESENTATION-NODES (LIST SUPERIOR TYPE
					       START-BP &OPTIONAL END-BP IN-ORDER-P
					       &KEY TEST)
  (DECLARE (SYS:DOWNWARD-FUNARG *))
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (SETQ START-BP (SEARCH START-BP #/: NIL NIL NIL END-BP))
  (LOOP FOR THING IN LIST
	WHILE START-BP
	DO (SETQ START-BP (FORWARD-OVER *WHITESPACE-CHARS* START-BP))
	AS NEXT-BP = (SEARCH START-BP #/, NIL NIL NIL END-BP)
	WHEN (OR (NULL TEST) (FUNCALL TEST THING))
	  DO (ADD-PRESENTATION-NODE THING (OR TYPE (CL:TYPE-OF THING))
				    START-BP
				    (OR NEXT-BP (BACKWARD-OVER *WHITESPACE-CHARS* END-BP))
				    SUPERIOR)
	WHILE NEXT-BP
	DO (SETQ START-BP (FORWARD-CHAR NEXT-BP))))

(DEFMETHOD (:BP-PRESENTATION-NODE MAIL-BUFFER) (BP)
  (LET ((HEADERS-END-BP (LET ((*INTERVAL* SELF))
			  (SEARCH FIRST-BP "--Text follows this line--"))))
    (WHEN (AND HEADERS-END-BP (BP-< BP HEADERS-END-BP))
      (COMPUTE-HEADER-PRESENTATION-NODES SELF FIRST-BP (BEG-LINE HEADERS-END-BP) T))
    (BP-PRESENTATION-NODE-FOR-ZMAIL BP SELF T)))

(DEFMETHOD (:BP-PRESENTATION-NODE ZMAIL-INTERVAL) (BP)
  (LET ((OTHER (BP-NODE (BEG-LINE BP))))
    (UNLESS (EQ OTHER SELF)
      (SEND-IF-HANDLES OTHER :RECOMPUTE-PRESENTATION-NODES BP))))

(DEFMETHOD (:BP-PRESENTATION-NODE ZMAIL-MSG-NODE) (BP)
  (WHEN (MSG-GET MSG 'REFORMATTED)
    (CONDITION-CASE ()
	 (LET ((*PRESERVE-ADDRESS-INTERVALS* T))
	   (PARSE-HEADERS-INTERVAL (MSG-START-BP MSG) (MSG-BODY-INTERVAL MSG) T))
       (ERROR)))
  (ADD-INTERVAL-HEADER-PRESENTATION-NODES (MSG-START-BP MSG) (MSG-BODY-INTERVAL MSG) T)
  (BP-PRESENTATION-NODE-FOR-ZMAIL BP SELF T))

(DEFUN BP-PRESENTATION-NODE-FOR-ZMAIL (BP BUFFER &OPTIONAL CACHE-ONLY)
  (OR (BP-PRESENTATION-NODE BP BUFFER CACHE-ONLY)
      (LET ((OTHER (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*)))
	(UNLESS (EQ (SEND BUFFER :MAJOR-MODE) OTHER)
	  (SEND-IF-HANDLES OTHER :BP-PRESENTATION-NODE BP BUFFER)))))

(DEFFLAVOR BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION (ITEM) (DW:PRESENTATION)
  :READABLE-INSTANCE-VARIABLES)

(DEFMETHOD ((CL:SETF BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION-ITEM)
	    BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION)
	   (NEW-ITEM)
  (SETQ ITEM NEW-ITEM
	DW::OBJECT (TV:TYPEOUT-ITEM-ITEM ITEM)
	DW::TYPE (TV:TYPEOUT-ITEM-TYPE ITEM)))

(DEFMETHOD (DW::PRESENTATION-MOUSE-SENSITIVE-BOXES
	     BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION)
	   (&REST IGNORE)
  (LET ((LEFT (TV:TYPEOUT-ITEM-LEFT ITEM))
	(TOP (TV:TYPEOUT-ITEM-TOP ITEM))
	(RIGHT (TV:TYPEOUT-ITEM-RIGHT ITEM))
	(BOTTOM (TV:TYPEOUT-ITEM-BOTTOM ITEM)))
    `((,LEFT ,TOP ,RIGHT ,BOTTOM))))

(DEFFLAVOR BASIC-MOUSE-SENSITIVE-ITEMS-TO-DYNAMIC-MOUSE-KLUDGE
	((FPT-1 (MAKE-INSTANCE 'BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION))
	 (FPT-2 (MAKE-INSTANCE 'BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION)))
	(DW::DYNAMIC-MOUSE-MIXIN TV:BASIC-MOUSE-SENSITIVE-ITEMS)
  )

(DEFMETHOD (:DISPLAYED-PRESENTATION-AT-POSITION
	     BASIC-MOUSE-SENSITIVE-ITEMS-TO-DYNAMIC-MOUSE-KLUDGE)
	   (X Y &OPTIONAL IGNORE)
  (LET ((ITEM (SEND SELF :MOUSE-SENSITIVE-ITEM (+ (TV:SHEET-INSIDE-LEFT) X)
		    (+ (TV:SHEET-INSIDE-TOP) Y))))
    (WHEN ITEM
      (SWAPF FPT-1 FPT-2)
      (SETF (BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION-ITEM FPT-1) ITEM)
      FPT-1)))

;;; The following will make the summary window obey the dynamic windows protocol instead of
;;; SUMMARY-MOUSE blip protocol.  Mix DW:DYNAMIC-MOUSE-MIXIN into ZMAIL-SUMMARY-SCROLL-WINDOW
;;; and replace ZMAIL-SUMMARY-MOUSE with a bunch of DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR's on MSG and
;;; you can use it.

#||

;;; Total crockery to make the summary window mouse work right before a proper implementation
;;; of dynamic scroll windows.

(DEFVAR *SUMMARY-MOUSE-FAKE-PRESENTATION* (MAKE-INSTANCE
					    'BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION
					    :TYPE 'MSG))

(DEFMETHOD (:DISPLAYED-PRESENTATION-AT-POSITION ZMAIL-SUMMARY-SCROLL-WINDOW)
	   (X Y &OPTIONAL IGNORE)
  (LET ((ITEM (SEND SELF :MOUSE-SENSITIVE-ITEM (+ (TV:SHEET-INSIDE-LEFT) X)
					       (+ (TV:SHEET-INSIDE-TOP) Y))))
    (WHEN ITEM
      (LET ((MSG (SECOND ITEM)))
	(SETF (BASIC-MOUSE-SENSITIVE-ITEMS-FAKE-PRESENTATION-ITEM
		*SUMMARY-MOUSE-FAKE-PRESENTATION*)
	      MSG)
	*SUMMARY-MOUSE-FAKE-PRESENTATION*))))
||#
