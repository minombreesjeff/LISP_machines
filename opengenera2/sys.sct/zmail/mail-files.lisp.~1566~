;;; -*- Mode:LISP; Package:ZWEI; Base:8 -*-
;;; Lisp Machine mail reader
;;; Mail file handling, definition are in DEFS
;;; Various Universe flavors are defined in FILTER and UNIVERSES.
;;; Some reference-related messages in REFERENCES.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; Disk mail files -- Primitive operations (creation, expunging, killing)

(DEFMETHOD (MAKE-INSTANCE MSG-BUFFER :AFTER) (&REST IGNORE)
  (UNLESS (VARIABLE-BOUNDP HEADER-INTERVAL)
    (SETQ HEADER-INTERVAL (CREATE-INTERVAL))))

(DEFMETHOD (MAKE-INSTANCE FILE-MAIL-BUFFER :AFTER) (&KEY OPTIONS DEFAULT-BUFFER
						    &ALLOW-OTHER-KEYS)
  (SETQ NAME (SEND PATHNAME :STRING-FOR-PRINTING)
	TICK (TICK)
	MSG-UPDATE-TICK TICK
	ORIGINAL-OPTIONS (COPYLIST OPTIONS))	;Remember options requested by the user.
  (SEND SELF :SET-PROPERTY-LIST (COMPLETE-MAIL-FILE-OPTIONS SELF ORIGINAL-OPTIONS))
  (WHEN DEFAULT-BUFFER
    (WHEN (NULL (SEND SELF :GET :MAIL))
      (LET ((INBOX-PATHNAMES (INBOX-PATHNAMES SELF)))
	(WHEN INBOX-PATHNAMES
	  (SEND SELF :PUTPROP INBOX-PATHNAMES :MAIL)))))
  (ADD-NEW-SEQUENCE SELF))

;;; Convert between different flavors of mail file
(DEFMETHOD (FLAVOR:TRANSFORM-INSTANCE FILE-MAIL-BUFFER) ()
  (SEND SELF :SET-PROPERTY-LIST (COMPLETE-MAIL-FILE-OPTIONS SELF ORIGINAL-OPTIONS))
  (WHEN STREAM
    (UNWIND-PROTECT
	(SYS:WITHOUT-ABORTS ("A cleanup form is closing the stream ~S for ~A.~@
		              Aborting before the cleanup is complete could leave ~
		              the stream open indefinitely."
			     STREAM NAME)
	  (IGNORE-ERRORS
	    (CL:CLOSE STREAM :ABORT T)))
      (SETQ STREAM NIL))))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Expunge a mail file --
;;;    Flush any in-progress (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")parse-old-msgs1 background requests and requeue them after the
;;;    expunge is completed to insure that we don't accidently parse new messages as if they
;;;    were old messages.
0(DEFWHOPPER (EXPUNGE-SEQUENCE FILE-MAIL-BUFFER) (&OPTIONAL (DELETED-MSGS T))
  (LET ((OLD-PARSE-REQUESTS (FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF 'PARSE-OLD-MSGS)))
    (UNWIND-PROTECT
	(CATCH 'ABORT-BUFFER-EXPUNGE
	  (CONTINUE-WHOPPER DELETED-MSGS))
      (WHEN OLD-PARSE-REQUESTS
	(LET ((START (COND ((NULL FIRST-MSG-FROM-INBOXES) 0)	;No inbox messages
			   ((SEQUENCE-APPEND-P SELF) 0)		;Inbox msgs after old mail
			   (T					;Inbox msgs before old mail
			    (+ FIRST-MSG-FROM-INBOXES TOTAL-MSGS-FROM-INBOXES))))
	      (END (COND ((NULL FIRST-MSG-FROM-INBOXES) NIL)
			 ((SEQUENCE-APPEND-P SELF) FIRST-MSG-FROM-INBOXES)
			 (T NIL))))
	  (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-OLD-MSGS SELF :START START :END END))))))

;;; Expunge a mail file -- Be sure its idling.
(DEFMETHOD (EXPUNGE-SEQUENCE FILE-MAIL-BUFFER :BEFORE) (&OPTIONAL (DELETED-MSGS T))
  1;; Before we can expunge a mail file, we must be certain that all its messages
  ;; are present and that, if we're reading new mail into it, its new mail is
0  1;; fully parsed in order to have the proper 2recent 1properties.
0  (COMPLETE-MAIL-FILE-IO SELF :ABORT-SAVES T)
  (WHEN DELETED-MSGS
    (SEND SELF :DELETE-EXPIRED *DELETE-EXPIRED-MSGS*)
    (WHEN *QUERY-BEFORE-EXPUNGE*
      (BUFFER-EXPUNGE-QUERY SELF)))
  (SETQ *BUFFER-EXPUNGE-TICK* (TICK)))		;Let all the collections know.

(DEFMETHOD (:DELETE-EXPIRED MSG-BUFFER) (WHEN)
  (WHEN (EQ WHEN ':PER-FILE)
    (SETQ WHEN (SEND SELF ':GET ':DELETE-EXPIRED)))
  (LET ((NOW (TIME:GET-UNIVERSAL-TIME)))
    (WHEN (OR (EQ WHEN T)
	      (AND (EQ WHEN ':ASK)
		   (SEQUENCE-PREDICATE-QUERY SELF
					     'MSG-EXPIRED-AND-NOT-DELETED-P NOW
					     "delete" "Expired")))
      (DOMSGS (MSG SELF)
	(AND MSG				;Incremental expunge
	     (MSG-EXPIRED-AND-NOT-DELETED-P MSG NOW)
	     (MSG-PUT MSG T 'DELETED))))))

(DEFUN MSG-EXPIRED-AND-NOT-DELETED-P (MSG NOW)
  (LET ((STATUS (ASSURE-MSG-PARSED MSG)))
    (AND (NOT (GET STATUS 'DELETED))
	 (LET ((EXPIRATION-DATE (GET STATUS :EXPIRATION-DATE)))
	   (COND ((NULL EXPIRATION-DATE) NIL)
		 ((LISTP EXPIRATION-DATE) (> NOW (FIRST (LAST EXPIRATION-DATE))))
		 (T (> NOW EXPIRATION-DATE)))))))

1;;; Kill the messages in a message buffer before killing the buffer.
0(DEFMETHOD (KILL-SEQUENCE MSG-BUFFER :BEFORE) (&KEY ABORT)
  (IGNORE ABORT)
  (WITH-BACKGROUND-PROCESS-LOCKED
    (FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF))
  (DO-UNIVERSE (MSG SELF :NO-PREPARE T :NOTE-PROGRESS "Killing ~A.")
    1;; Don't preserve message references during a user-initiated 2kill-sequence1 --
0    1;;    In order to preserve references, we have to parse any unparsed messages which
0    1;;    will just make killing the message buffer slower.  As reference hash tables are
0    1;;    per-sequence, the newly generated references will simply be thrown out as
0    1;;    the buffer is killed.  2[Note -- This optimization may have to be flushed when
    1;;    2we convert to a global reference hash table.]
0    (KILL-MSG MSG T))
  1;; Get rid of any collections which no longer contain any messages.
0  (EXPUNGE-COLLECTIONS))

1;;; Close the message buffer's stream (if any) and update its status.
0(DEFMETHOD (KILL-SEQUENCE MSG-BUFFER :AFTER) (&KEY ABORT)
  (UNWIND-PROTECT
      (WHEN STREAM
	(WITHOUT-ABORTS-IF ABORT
			   ("A cleanup form is closing the stream ~S for ~A.~@
			     Aborting before the cleanup is complete could leave ~
			     the stream open indefinitely."
			    STREAM NAME)
	  (IGNORE-ERRORS
	    (CL:CLOSE STREAM :ABORT T))))	1;Always close stream as if aborting.
0    (SETQ STREAM NIL
	  STATUS :KILLED)))

;;; Kill a mail file buffer -- Be sure that the inboxes are locked
(DEFWHOPPER (KILL-SEQUENCE FILE-MAIL-BUFFER) (&KEY ABORT)
  (LOCK-BUFFER-AND-INBOXES (SELF :WRITE)
    (CONTINUE-WHOPPER :ABORT ABORT)))

;;; Kill a mail file buffer.
(DEFMETHOD (KILL-SEQUENCE FILE-MAIL-BUFFER :AFTER) (&KEY ABORT)
  (WITH-BACKGROUND-PROCESS-LOCKED
    (FLUSH-ZMAIL-BACKGROUND-REQUESTS-INTERNAL *ZMAIL-BACKGROUND-MAIL-CHECK-QUEUE*
					      SELF 'MAIL-CHECK))
  (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
	DO (KILL-SEQUENCE INBOX-BUFFER :ABORT ABORT))
  (SETQ INSERTED-INBOXES NIL
	INBOXES-BEING-INSERTED NIL
	FIRST-MSG-FROM-INBOXES NIL
	TOTAL-MSGS-FROM-INBOXES NIL))

(DEFWHOPPER (:ADD-MSG MSG-BUFFER) (MSG &OPTIONAL AT-INDEX)
  (LOCK-SEQUENCE (SELF :WRITE)
    (CONTINUE-WHOPPER MSG AT-INDEX)))

(DEFWHOPPER (:ADD-SEQUENCE MSG-BUFFER) (SEQUENCE)
  (LOCK-SEQUENCE (SELF :WRITE)
    (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE-MOVE)
      (CONTINUE-WHOPPER SEQUENCE))))

(DEFMETHOD (:ADD-MSG-TEXT FILE-MAIL-BUFFER) (MSG AT-INDEX)
  (IGNORE AT-INDEX)
  (LET ((INVALIDATE-SUMMARY))
    (WHEN (MSG-BUFFER MSG)
      1;; Be sure that the message is parsed first to avoid copying format specific headers
0      1;; and trailers (e.g., the status line and original headers in a Babyl file).
0      (ASSURE-MSG-PARSED MSG)
      (LET ((COPY (COPY-MSG MSG)))
	(ZMAIL-UNDO-SAVE-OR-MULTIPLE 'UNDO-MOVE :MSG MSG :COPY COPY)
	(MSG-PUT MSG T 'FILED)
	(COND (*DELETE-AFTER-MOVE-TO-BUFFER*
	       (MSG-PUT MSG T 'DELETED)
	       (WHEN (EQ MSG *MSG*)
		 (MUST-REDISPLAY *MSG-WINDOW* (MOVE-AFTER-DELETE *NEXT-AFTER-DELETE*))))
	      ((EQ MSG *MSG*)
	       (COMPUTE-CURRENT-MSG-STATE)))
	(SETF (MSG-INSERTION-TICK COPY) (TICK))	1;Note when put in buffer
0	(ADD-KEYWORDS-IN-MSG-TO-BUFFER COPY SELF)
	(SETQ MSG COPY))
      (SETQ INVALIDATE-SUMMARY T))
    (SEND SELF :NEW-MSG MSG)
    (REFORMAT-HEADERS MSG)
    (WHEN INVALIDATE-SUMMARY
      (SET-MSG-SUMMARY-LINE MSG (ASSURE-MSG-PARSED MSG))))
  MSG)

(DEFUN ADD-KEYWORDS-IN-MSG-TO-BUFFER (MSG BUFFER)
  (LOOP WITH BUFFER-KEYWORDS = (SEND BUFFER :GET :KEYWORDS)
	WITH NEW-KEYWORDS-FOR-BUFFER = NIL
	FOR KEYWORD IN (MSG-GET MSG 'KEYWORDS)
	AS KEYWORD-PAIR = (RASSQ KEYWORD *KEYWORD-ALIST*)
	WHEN (NULL KEYWORD-PAIR)
	  1;; Shouldn't happen but let's not take any chances...
0	  DO (SETQ KEYWORD-PAIR (CONS (STRING-DOWNCASE KEYWORD) KEYWORD)
		   *KEYWORD-ALIST* (NCONC *KEYWORD-ALIST* (NCONS KEYWORD-PAIR)))
	UNLESS (RASSQ KEYWORD BUFFER-KEYWORDS)
	  DO (SETQ BUFFER-KEYWORDS (NCONC BUFFER-KEYWORDS (NCONS KEYWORD-PAIR))
		   NEW-KEYWORDS-FOR-BUFFER T)
	FINALLY
	  (WHEN NEW-KEYWORDS-FOR-BUFFER
	    (SEND BUFFER :PUTPROP BUFFER-KEYWORDS :KEYWORDS))))

(DEFUN-IN-FLAVOR (REPLACE-REAL-HEADER-AREA SEQUENCE)
		 (MSG STRING &AUX START-BP MSG-REAL-INTERVAL)
  (SETQ START-BP (MSG-START-BP MSG)
	MSG-REAL-INTERVAL (MSG-REAL-INTERVAL MSG))
  (DELETE-INTERVAL (INTERVAL-FIRST-BP MSG-REAL-INTERVAL) START-BP T)
  (INSERT-MOVING START-BP STRING)
  (UPDATE-MSG-OPTIONS-IN-FILE SELF MSG))

(DEFMETHOD (:NEW-MSG FILE-MAIL-BUFFER) (MSG &OPTIONAL FROM-INBOX)
  (SETF (MSG-BUFFER MSG) SELF)
  (WHEN (AND FROM-INBOX (TYPEP (MSG-PARSED-P MSG) 'INBOX-BUFFER))
1    ;; Message is from an inbox but wasn't parsed successfully by the inbox --
    ;;    All subsequent attempts to parse this message must now use the mail file's
    ;;    parse methods as we've changed the message's header area to conform to that
    ;;    expected by the mail file.
0    (SETF (MSG-PARSED-P MSG) NIL))
  (LET ((BEFORE (SEND SELF :NEW-MSG-HEADER-AREA))
	(*NEW-MSG-INSERTION* T))
    (REPLACE-REAL-HEADER-AREA MSG BEFORE))
  (MARK-SEQUENCE-MODIFIED SELF)
  MSG)

(DEFMETHOD (:NEW-MSG-HEADER-AREA FILE-MAIL-BUFFER) ()
  "")

;;; Options manipulation --
;;;    Mail file options are stored on the buffer's property list.  Unfortunately, a number
;;;    of non-mail file options are also stored there.  These true properties must be
;;;    preserved by all of the following generic functions, etc.  Eventually, mail file
;;;    options should be maintained separately from the buffer's properties.

(DEFINE-SETTABLE-MAIL-FILE-OPTION :APPEND NIL :BOOLEAN
  "Append messages moved into file")


;;; Generic functions

;;; Returns the list of all mail file options defined for this type of buffer.
(DEFGENERIC POSSIBLE-MAIL-FILE-OPTIONS (FILE-MAIL-BUFFER)
  (DECLARE (ARGLIST . (FILE-MAIL-BUFFER))
	   (VALUES . (OPTIONS-LIST)))
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    `(:APPEND)))

;;; Returns the list of mail file options which may be changed by the user.
(DEFGENERIC SETTABLE-MAIL-FILE-OPTIONS (FILE-MAIL-BUFFER)
  (DECLARE (ARGLIST . (FILE-MAIL-BUFFER))
	   (VALUES . (OPTIONS-LIST)))
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    NIL))					;No settable options.

;;; Returns a list of mail file options which should be inherited by new buffers if this
;;; buffer is the current sequence when the new buffer is created.
(DEFGENERIC STICKY-MAIL-FILE-OPTIONS (FILE-MAIL-BUFFER)
  (DECLARE (ARGLIST . (FILE-MAIL-BUFFER))
	   (VALUES . (OPTIONS-LIST)))
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    `(:APPEND)))

;;; Given a set of mail file options, this generic function supplies appropriate default
;;; values for any missing options --
;;;    If given, the :PATHNAME keyword is used to select the host specific default values
;;;    to use rather than using those derived from the buffer's pathname.  This keyword
;;;    is used mainly by those functions (e.g., CREATE-BUFFER-FOR-NEW-MAIL-FILE) which
;;;    need to generate a complete set of options before actually creating a buffer.
(DEFGENERIC COMPLETE-MAIL-FILE-OPTIONS (BUFFER-OR-FORMAT SUPPLIED-OPTIONS
					&KEY ((:PATHNAME OVERRIDING-PATHNAME)))
  (DECLARE (ARGLIST . (FILE-MAIL-BUFFER SUPPLIED-OPTIONS &KEY PATHNAME))
	   (VALUES . (COMPLETE-OPTIONS)))
  (:FUNCTION
    (CL:ETYPECASE BUFFER-OR-FORMAT
      (FILE-MAIL-BUFFER
	(FUNCALL (FLAVOR:GENERIC COMPLETE-MAIL-FILE-OPTIONS)
		 BUFFER-OR-FORMAT SUPPLIED-OPTIONS :PATHNAME OVERRIDING-PATHNAME))
      (SYMBOL
	(LET ((FORMAT-FLAVOR (FLAVOR:FIND-FLAVOR BUFFER-OR-FORMAT NIL)))
	  (CL:ASSERT (AND FORMAT-FLAVOR (MEMQ 'FILE-MAIL-BUFFER
					      (FLAVOR::FLAVOR-ALL-COMPONENTS FORMAT-FLAVOR)))
		     ()
		     "~A is not the name of a mail file format." BUFFER-OR-FORMAT)
	  (FUNCALL (FLAVOR:GENERIC COMPLETE-MAIL-FILE-OPTIONS)
		   (FLAVOR::FLAVOR-TEMPLATE-INSTANCE FORMAT-FLAVOR) SUPPLIED-OPTIONS
		   :PATHNAME OVERRIDING-PATHNAME)))))
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    (APPEND
      (LOOP WITH SUPPORTED-OPTIONS = (POSSIBLE-MAIL-FILE-OPTIONS SELF)
	    FOR (OPTION VALUE) ON SUPPLIED-OPTIONS BY 'REST2
	    WHEN (OR (NULL (ASSQ OPTION *MAIL-FILE-OPTION-ALIST*))
		     (MEMQ OPTION SUPPORTED-OPTIONS))
	      COLLECT OPTION AND COLLECT VALUE)
      (LOOP WITH (DEFAULT-VALUE DEFAULT-VALUE-DEFINED) = NIL
	    FOR OPTION IN (POSSIBLE-MAIL-FILE-OPTIONS SELF)
	    WHEN (MULTIPLE-VALUE-BIND (IGNORE IGNORE OPTION-PRESENT)
		     (CL:GET-PROPERTIES SUPPLIED-OPTIONS `(,OPTION))
		   (NULL OPTION-PRESENT))
	      DO (CL:MULTIPLE-VALUE-SETQ (DEFAULT-VALUE DEFAULT-VALUE-DEFINED)
		   (DEFAULT-MAIL-FILE-OPTION-VALUE SELF OPTION :PATHNAME OVERRIDING-PATHNAME))
	      AND WHEN DEFAULT-VALUE-DEFINED
		    COLLECT OPTION AND COLLECT DEFAULT-VALUE))))

;;; Determine the default value for a mail file option --
;;;    If given, the :PATHNAME keyword is used to select the host specific default
;;;    value rather than using the pathname associated with the buffer.  Note that
;;;    the :PATHNAME keyword is not passed to the actual methods of this generic.
(DEFGENERIC DEFAULT-MAIL-FILE-OPTION-VALUE (BUFFER-OR-FORMAT OPTION
					    &KEY ((:PATHNAME OVERRIDING-PATHNAME)))
  (DECLARE (ARGLIST . (FILE-MAIL-BUFFER MAIL-FILE-OPTION &KEY PATHNAME))
	   (VALUES . (DEFAULT-VALUE DEFAULT-VALUE-DEFINED)))
  (:FUNCTION
    (LET* ((FORMAT (CL:ETYPECASE BUFFER-OR-FORMAT
		     (FILE-MAIL-BUFFER (TYPEP BUFFER-OR-FORMAT))
		     (SYMBOL
		       (LET ((FORMAT (FLAVOR:FIND-FLAVOR BUFFER-OR-FORMAT NIL)))
			 (CL:ASSERT (AND FORMAT (MEMQ 'FILE-MAIL-BUFFER
						      (FLAVOR::FLAVOR-ALL-COMPONENTS FORMAT)))
				    ()
				    "~A is not the name of a mail file format."
				    BUFFER-OR-FORMAT)
			 FORMAT))))
	   (BUFFER (CL:ETYPECASE BUFFER-OR-FORMAT
		     (FILE-MAIL-BUFFER BUFFER-OR-FORMAT)
		     (SYMBOL (FLAVOR::FLAVOR-TEMPLATE-INSTANCE FORMAT)))))
      ;; First check for a system and format specific default ...
      (MULTIPLE-VALUE-BIND (DEFAULT-VALUE DEFAULT-VALUE-DEFINED)
	  (HOST-DEFAULT-MAIL-FILE-OPTION-VALUE (OR OVERRIDING-PATHNAME
						   (MSG-BUFFER-PATHNAME BUFFER))
					       FORMAT OPTION)
	(IF DEFAULT-VALUE-DEFINED
	    (VALUES DEFAULT-VALUE DEFAULT-VALUE-DEFINED)
	  ;; ... then check for a format specific default ...
	  (MULTIPLE-VALUE-BIND (DEFAULT-VALUE DEFAULT-VALUE-DEFINED)
	      (FUNCALL (FLAVOR:GENERIC DEFAULT-MAIL-FILE-OPTION-VALUE) BUFFER OPTION)
	    (IF DEFAULT-VALUE-DEFINED
		(VALUES DEFAULT-VALUE DEFAULT-VALUE-DEFINED)
	      ;; ... and finally, check for the global default defined by the option itself.
	      (MULTIPLE-VALUE-BIND (IGNORE DEFAULT-VALUE DEFAULT-VALUE-DEFINED)
		  (CL:GET-PROPERTIES (CL:SYMBOL-PLIST OPTION) '(TV:DEFAULT-VALUE))
		(VALUES DEFAULT-VALUE (NOT (NULL DEFAULT-VALUE-DEFINED))))))))))
  (:METHOD-ARGLIST OPTION)
  ;;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
   (IGNORE OPTION)
   (VALUES NIL NIL)))				;No format specific default.

;;; Update the list of options at the start of the file.
(DEFGENERIC UPDATE-OPTIONS-IN-FILE (FILE-MAIL-BUFFER)
  (DECLARE (ARGLIST . (FILE-MAIL-BUFFER)))
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    NIL))					;Don't do anything special.

;;; Remember new options recorded in the file for future format transformations, etc.
(DEFMETHOD (UPDATE-OPTIONS-IN-FILE FILE-MAIL-BUFFER :AFTER) ()
  (SETQ ORIGINAL-OPTIONS (COPYLIST (SEND SELF :PROPERTY-LIST))))


1;;; Change the options for a mail file by using a CVV menu -- This function will change
;;;     the file's pathname and format if requested by the user.
0(DEFUN CHOOSE-MAIL-FILE-OPTIONS (BUFFER)
  (LET* ((OLD-PATHNAME (MSG-BUFFER-PATHNAME BUFFER))
	 (OLD-FLAVOR (TYPEP BUFFER))
	 (OLD-OPTIONS (SEND BUFFER :PROPERTY-LIST)))
    (CATCH-ZWEI-COMMAND-LOOP			1;In case aborted.
0      (MULTIPLE-VALUE-BIND (NEW-PATHNAME NEW-FLAVOR NEW-OPTIONS)
	  (CHOOSE-MAIL-FILE-OPTIONS-INTERNAL OLD-PATHNAME OLD-FLAVOR OLD-OPTIONS
					     :INCLUDING-PATHNAME T)
	(LET* ((NEW-APPEND (CL:GETF NEW-OPTIONS :APPEND))
	       (OK-TO-REVERSE (AND (NEQ NEW-APPEND (CL:GETF OLD-OPTIONS :APPEND))
				   (> (SEQUENCE-NMSGS BUFFER) 1)
				   (TYPEOUT-BEEP-YES-OR-NO-P
				     "Reverse the messages already in ~A? " NEW-PATHNAME)))
	       (NEW-BUFFER-ID (IF (EQ NEW-PATHNAME OLD-PATHNAME)
				  (MSG-BUFFER-ID BUFFER)
				(VALIDATE-RENAME-SEQUENCE BUFFER NEW-PATHNAME))))
	  (IF (NEQ NEW-FLAVOR OLD-FLAVOR)
	      (SETF BUFFER (CONVERT-BUFFER-FORMAT BUFFER NEW-FLAVOR NEW-PATHNAME
						  NEW-BUFFER-ID NEW-OPTIONS))
	    (SEND BUFFER :SET-PROPERTY-LIST NEW-OPTIONS)
	    (WHEN (NEQ NEW-PATHNAME OLD-PATHNAME)
	      (RENAME-SEQUENCE-INTERNAL BUFFER NEW-PATHNAME NEW-BUFFER-ID)))
	  (WHEN OK-TO-REVERSE
	    (REVERSE-SEQUENCE BUFFER))
	  (UNLESS (EQ (CL:GETF OLD-OPTIONS :SUMMARY-WINDOW-FORMAT)
		      (CL:GETF NEW-OPTIONS :SUMMARY-WINDOW-FORMAT))
	    (CHANGE-SEQUENCE-MSGS-SUMMARY-LINES BUFFER))
	  (QUEUE-MAIL-CHECK-REQUESTS BUFFER)
	  (WHEN (EQ BUFFER *SEQUENCE*)
	    (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*SEQUENCE*)))))))

(DEFUN CHOOSE-MAIL-FILE-OPTIONS-INTERNAL (OLD-PATHNAME OLD-FLAVOR OLD-OPTIONS
					  &KEY (NEAR '(:MOUSE))
					       (INCLUDING-PATHNAME NIL))
  (DECLARE (VALUES NEW-PATHNAME NEW-FLAVOR NEW-OPTIONS))
  (LET* ((NEW-PATHNAME OLD-PATHNAME)
	 (NEW-FLAVOR OLD-FLAVOR)
	 (VALUES-STASH
	   (LOOP FOR ITEM IN *MAIL-FILE-OPTION-ALIST*
		 AS OPTION = (FIRST ITEM)
		 AS VALUE = (CL:GETF
			      OLD-OPTIONS OPTION
			      (DEFAULT-MAIL-FILE-OPTION-VALUE OLD-FLAVOR
							      OPTION :PATHNAME OLD-PATHNAME))
		 COLLECT `(,OPTION ,VALUE))))
    (DECLARE (SPECIAL NEW-PATHNAME NEW-FLAVOR))
    (LABELS ((COMPUTE-PATHNAME-FLAVORS-ALIST ()
	       (LET ((FLAVORS-ALIST))
		 (DOLIST (FLAVOR (NATIVE-MAIL-FILE-FORMATS NEW-PATHNAME))
		   (PUSH (OR (CL:FIND FLAVOR *MAIL-BUFFER-FLAVOR-ALIST*
				      :KEY #'TV:MENU-EXECUTE-NO-SIDE-EFFECTS)
			     (CONS (STRING FLAVOR) FLAVOR))
			 FLAVORS-ALIST))
		 (UNLESS (CL:MEMBER 'TEXT-MAIL-BUFFER FLAVORS-ALIST
				    :KEY #'TV:MENU-EXECUTE-NO-SIDE-EFFECTS)
		   (PUSH (CL:FIND 'TEXT-MAIL-BUFFER *MAIL-BUFFER-FLAVOR-ALIST*
				  :KEY #'TV:MENU-EXECUTE-NO-SIDE-EFFECTS)
			 FLAVORS-ALIST))
		 (NREVERSE FLAVORS-ALIST)))
	     (FIXUP-ALIST (ALIST)
	       (LOOP FOR (VARIABLE . OPTIONS) IN ALIST
		     COLLECT `(,(LET ((ITEM (ASSQ VARIABLE VALUES-STASH)))
				  (LOCF (SECOND ITEM)))
			       . ,OPTIONS)))
	     (COMPUTE-MAIL-FILE-OPTIONS-ALIST ()
	       `(,@(WHEN INCLUDING-PATHNAME
		    `((NEW-PATHNAME "Pathname" :PATHNAME)))
		 ,`(NEW-FLAVOR "Format" :MENU-ALIST ,(COMPUTE-PATHNAME-FLAVORS-ALIST))
		 ,@(FIXUP-ALIST
		     (LOOP FOR OPTION IN (FLAVOR:FUNCALL-HANDLER NEW-FLAVOR
								 'SETTABLE-MAIL-FILE-OPTIONS)
			   WHEN (ASSQ OPTION *MAIL-FILE-OPTION-ALIST*)
			     COLLECT IT))))
	     1;; This internal function expects to be called within a 2tv:with-sheet-deexposed
0	     1;; of the CVV window --
0	     1;;    By letting our caller do the 2tv:with-sheet-deexposed1, it can ask questions
0	     1;;    and/or type messages.  Since our caller has to deexpose the CVV to do I/O,
0	     1;;    we get less deexpose/reexpose cycles by insisting that he always do it.
0	     (RECONSTRUCT-CVV-MENU (WINDOW)
	       (SEND WINDOW :SETUP (COMPUTE-MAIL-FILE-OPTIONS-ALIST)
				   (FORMAT NIL "Options for ~A:" NEW-PATHNAME)
				   (SEND WINDOW :FUNCTION)
				   (SYMEVAL-IN-INSTANCE WINDOW 'TV:MARGIN-CHOICES))
	       (SEND WINDOW
		     :ADJUST-GEOMETRY-FOR-NEW-VARIABLES (SEND WINDOW :APPROPRIATE-WIDTH 10.)
							TV:CHOOSE-VARIABLE-VALUES-MAX-LINES)
	       (SEND WINDOW
		     :CENTER-AROUND (+ (SEND WINDOW :X-OFFSET) (// (SEND WINDOW :WIDTH) 2))
				    (+ (SEND WINDOW :Y-OFFSET) (// (SEND WINDOW :HEIGHT) 2)))
	       T)
	     (SET-NEW-PATHNAME (PATHNAME)
	       (SETF NEW-PATHNAME (FS:MERGE-PATHNAMES PATHNAME *ZMAIL-PATHNAME-DEFAULTS*))
	       (FS:SET-DEFAULT-PATHNAME NEW-PATHNAME *ZMAIL-PATHNAME-DEFAULTS*)
	       NEW-PATHNAME)
	     (UPDATE-OPTIONS (WINDOW VARIABLE OLD-VALUE NEW-VALUE)
	       (IGNORE OLD-VALUE NEW-VALUE)	1;0TV:CVV1 has already changed the value.
0	       (CL:CASE VARIABLE
		 (NEW-PATHNAME
		   (TV:WITH-SHEET-DEEXPOSED (WINDOW)
		     (SET-NEW-PATHNAME NEW-PATHNAME)	1;Merge and update defaults, please.
0		     (UNLESS (MEMQ NEW-FLAVOR (NATIVE-MAIL-FILE-FORMATS NEW-PATHNAME))
		       (BEEP)
		       (TYPEIN-LINE "~A is not an acceptable format for the pathname ~A."
				    (FLAVOR:FUNCALL-HANDLER NEW-FLAVOR :FORMAT-NAME)
				    NEW-PATHNAME)
		       (SET-NEW-PATHNAME OLD-VALUE))
		     (RECONSTRUCT-CVV-MENU WINDOW)))
		 (NEW-FLAVOR
		   (TV:WITH-SHEET-DEEXPOSED (WINDOW)
		     (LET ((DEFAULT-FORMAT (DEFAULT-MAIL-FILE-FORMAT NEW-PATHNAME))
			   (NEW-CANONICAL-TYPE (FLAVOR:FUNCALL-HANDLER
						 NEW-FLAVOR :DEFAULT-CANONICAL-TYPE)))
		       (WHEN (AND DEFAULT-FORMAT	1;Pathname implies a different format.
0				  (NEQ DEFAULT-FORMAT NEW-FLAVOR)
				  NEW-CANONICAL-TYPE)	1;But there's a new type we could use.
0			 (LET ((NEWER-PATHNAME (SEND NEW-PATHNAME
						     :NEW-CANONICAL-TYPE NEW-CANONICAL-TYPE)))
			   (BEEP)
			   (TYPEIN-LINE "The mail file will be renamed to ~A." NEWER-PATHNAME)
			   (SET-NEW-PATHNAME NEWER-PATHNAME))))
		     (RECONSTRUCT-CVV-MENU WINDOW))))))
      (FS:SET-DEFAULT-PATHNAME NEW-PATHNAME *ZMAIL-PATHNAME-DEFAULTS*)
      (LET ((FS:*DEFAULT-PATHNAME-DEFAULTS* *ZMAIL-PATHNAME-DEFAULTS*))
	(TV:CHOOSE-VARIABLE-VALUES (COMPUTE-MAIL-FILE-OPTIONS-ALIST)
				   :LABEL (FORMAT NIL "Options for ~A:" NEW-PATHNAME)
				   :NEAR-MODE NEAR
				   :MARGIN-CHOICES '("Do It"
						     ("Abort" (ABORT-CURRENT-COMMAND)))
				   :FUNCTION #'UPDATE-OPTIONS)
	(UNLESS (MEMQ NEW-FLAVOR (NATIVE-MAIL-FILE-FORMATS NEW-PATHNAME))
	  (BARF "~A is not an acceptable format for the pathname ~A."
		(FLAVOR:FUNCALL-HANDLER NEW-FLAVOR :FORMAT-NAME) NEW-PATHNAME))
	(VALUES
	  NEW-PATHNAME
	  NEW-FLAVOR
	  (APPEND (LOOP FOR (OPTION VALUE) ON OLD-OPTIONS BY 'CDDR
			UNLESS (ASSQ OPTION *MAIL-FILE-OPTION-ALIST*)
			  COLLECT OPTION AND COLLECT VALUE)
		  (LOOP FOR VARIABLE IN (FLAVOR:FUNCALL-HANDLER NEW-FLAVOR
								'POSSIBLE-MAIL-FILE-OPTIONS)
			APPEND (ASSQ VARIABLE VALUES-STASH))))))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-CHANGE-MAIL-FILE-OPTIONS
				"Change a mail file's attributes.
Without a numeric argument, changes the attributes for the current sequence
  if it's a mail file buffer.
With a numeric argument, asks for a mail file in the minibuffer."
				(NO-MSG-OK NUMERIC-ARG-OK)
  (LET ((BUFFER (IF *NUMERIC-ARG-P*
		    (TYPEIN-LINE-ACCEPT 'FILE-MAIL-BUFFER
					:PROMPT "Change options for mail file"
					:DEFAULT (DOLIST (SEQUENCE *SEQUENCE-LIST*)
						   (WHEN (SEQUENCE-BUFFER-P SEQUENCE)
						     (RETURN SEQUENCE))))
		    *SEQUENCE*)))
    (UNLESS (SEQUENCE-BUFFER-P BUFFER)
      (BARF "~A is not a mail file buffer." (SEQUENCE-NAME BUFFER)))
    (CHOOSE-MAIL-FILE-OPTIONS BUFFER)
    DIS-NONE))

1;;; Default canonical type for all mail files.
0(DEFMETHOD (:DEFAULT-CANONICAL-TYPE FILE-MAIL-BUFFER) ()
  NIL)						1;There is no default canonical type.

;;; Convert a buffer to a different format.
0(DEFUN CONVERT-BUFFER-FORMAT (OLD-BUFFER NEW-FLAVOR NEW-PATHNAME NEW-BUFFER-ID NEW-OPTIONS)
  (COMPLETE-MAIL-FILE-IO OLD-BUFFER :ABORT-SAVES T)	1;Be sure the old buffer is dormant.
0  (LET ((NEW-BUFFER (MAKE-SEQUENCE NEW-FLAVOR :PATHNAME NEW-PATHNAME
					      :ID NEW-BUFFER-ID
					      :OPTIONS NEW-OPTIONS)))
    (UNWIND-PROTECT-CASE ()
	(LET ((OLD-WAS-*SEQUENCE* (EQ OLD-BUFFER *SEQUENCE*))
	      (OLD-WAS-*DEFAULT-BUFFER* (EQ OLD-BUFFER *DEFAULT-BUFFER*))
	      (OLD-WAS-*DEFAULT-MOVE-SEQUENCE* (EQ OLD-BUFFER *DEFAULT-MOVE-SEQUENCE*)))
	  1;; Copy the inbox state to prevent reading new mail more than once --
0	  1;;    The above call to 2complete-mail-file-io1 will guarentee that all inboxes have
0	  1;;    been inserted into the buffer and, therefore, we need only copy the list of
0	  1;;    inserted inboxes.
0	  (SETF (FILE-MAIL-BUFFER-INSERTED-INBOXES NEW-BUFFER)
		(FILE-MAIL-BUFFER-INSERTED-INBOXES OLD-BUFFER))
	  1;; Copy the messages in the old buffer to the new buffer -- The guts of conversion.
0	  (SYS:WITHOUT-ABORTS ("Converting ~A to ~A format.~@
			        Aborting now would leave the buffer partially converted;~@
				those messages already converted will ~
				no longer be in the buffer."
			       (SEQUENCE-NAME OLD-BUFFER) (SEND NEW-BUFFER :FORMAT-NAME))
	    (TYPEIN-LINE "Converting ~A to ~A format ... (please stand by) ... "
			 (SEQUENCE-NAME OLD-BUFFER) (SEND NEW-BUFFER :FORMAT-NAME))
	    (LET ((*PROPERTIES-NOT-COPIED* *PROPERTIES-NOT-COPIED-DURING-CONVERSION*)
		  (*DELETE-AFTER-MOVE-TO-BUFFER* NIL)	1;No need to delete as we go.
0		  (*MSG* :NO-SELECT))			1;Don't bother updating the mode line.
0	      (DO-UNIVERSE (MSG OLD-BUFFER :NOTE-PROGRESS "Converting ~A.")
		1;; Explicit position suppresses all sorting which would be superfluous.
0		(SEND NEW-BUFFER :ADD-MSG MSG (SEQUENCE-NMSGS NEW-BUFFER))
		1;; Kill the old message immediately without saving references.
0		(KILL-MSG MSG T)))
	    (TYPEIN-LINE-MORE "done."))
	  1;; Create and fill the new buffer's reference hash table.
0	  (SEND NEW-BUFFER :UPDATE-REFERENCE-HASH-TABLE)
	  1;; Update global variables.
0	  (IF OLD-WAS-*SEQUENCE*
	      (SELECT-SEQUENCE NEW-BUFFER OLD-WAS-*DEFAULT-BUFFER*)	1;Sets 2*default-buffer*
0	    (WHEN OLD-WAS-*DEFAULT-BUFFER*
	      (SETQ *DEFAULT-BUFFER* NEW-BUFFER)))
	  (WHEN OLD-WAS-*DEFAULT-MOVE-SEQUENCE*
	    (SETQ *DEFAULT-MOVE-SEQUENCE* NEW-BUFFER))
	  1;; Flush the now useless old buffer.
0	  (SETF (SEQUENCE-NAME OLD-BUFFER) (FORMAT NIL "old copy of ~A"
						   (SEQUENCE-NAME OLD-BUFFER)))
	  (KILL-SEQUENCE OLD-BUFFER)
	  1;; Allow the new buffer to be saved and, further, force it to be saved.
0	  (SEND NEW-BUFFER :PUTPROP NIL :DISABLE-SAVES)
	  (MARK-SEQUENCE-MODIFIED NEW-BUFFER :HARD T)
	  NEW-BUFFER)
      (:ABORT
	(EXPUNGE-SEQUENCE OLD-BUFFER NIL)
	(SETF (SEQUENCE-NAME NEW-BUFFER) (FORMAT NIL "new copy of ~A"
						 (SEQUENCE-NAME NEW-BUFFER)))
	(KILL-SEQUENCE NEW-BUFFER :ABORT T)))))

1;;; Define a new type of mail file format.
0(DEFUN ADD-MAIL-BUFFER-FLAVOR (FLAVOR NAME &OPTIONAL DOCUMENTATION &AUX CDR ELEM)
  (SETQ CDR (IF (NULL DOCUMENTATION) FLAVOR `(:VALUE ,FLAVOR :DOCUMENTATION ,DOCUMENTATION)))
  (IF (SETQ ELEM (ASSOC NAME *MAIL-BUFFER-FLAVOR-ALIST*))
      (SETF (CDR ELEM) CDR)
      (PUSH (CONS NAME CDR) *MAIL-BUFFER-FLAVOR-ALIST*)))

;;; Return the element type to be used when reading/writing a mail file/inbox.
(DEFGENERIC MSG-FILE-ELEMENT-TYPE (MSG-BUFFER &KEY ((:PATHNAME PATHNAME-OVERRIDE)))
  ;; The default method -- Correct for all formats except KBIN
  (:METHOD (MSG-BUFFER)
    (IGNORE PATHNAME-OVERRIDE)
    'CL:STRING-CHAR))

;;; Verifies the format of a mail file/inbox and loads its header (if any) --
;;;    If the file format is incorrect, this generic should signal the WRONG-MAIL-FILE-FORMAT
;;;    condition and include its best guess as to the actual file format.
(DEFGENERIC VERIFY-MSG-FILE-FORMAT-AND-LOAD-HEADER (MSG-BUFFER)
  ;; The default method -- Rejects binary and BABYL files and assumes no header is present.
  ;;    (Note that an :AFTER daemon on this method can be used to load a header
  ;;     if desired.  See, for example, RMAIL-BUFFER in SHARED-MAIL-FILE-FORMATS.)
  (:METHOD (MSG-BUFFER)
    (CHECK-MSG-FILE-ELEMENT-TYPE)
    (CHECK-NOT-KBIN-MSG-FILE)
    (CHECK-NOT-BABYL-MSG-FILE)))

;;; Check that the file is stored in the proper mode for its format.
(DEFUN-IN-FLAVOR (CHECK-MSG-FILE-ELEMENT-TYPE MSG-BUFFER) ()
  (LET ((DESIRED-ELEMENT-TYPE (MSG-FILE-ELEMENT-TYPE SELF))
	(STREAM-ELEMENT-TYPE (CL:STREAM-ELEMENT-TYPE STREAM)))
    (UNLESS (CL:SUBTYPEP DESIRED-ELEMENT-TYPE STREAM-ELEMENT-TYPE)
      (LET ((APPARENT-FORMAT (ACTUAL-MAIL-FILE-FORMAT PATHNAME STREAM)))
	(ERROR 'WRONG-MAIL-FILE-FORMAT :BUFFER SELF
				       :APPARENT-FORMAT APPARENT-FORMAT
				       :FORMAT-STRING
				         (UNLESS APPARENT-FORMAT
					   "It appears to be a ~:[binary~;text~] file.")
				       :FORMAT-ARGS
				         `(,(CL:SUBTYPEP 'CL:STRING-CHAR STREAM-ELEMENT-TYPE))
				       )))))

;;; Reject KBIN files --
;;;    On file systems which always return character streams when opening with :DEFAULT
;;;    element type, we must explicitly check that the file isn't a KBIN file as the element
;;;    type check above will pass.
(DEFUN-IN-FLAVOR (CHECK-NOT-KBIN-MSG-FILE MSG-BUFFER) ()
  (WHEN (KBIN-MSG-FILE-P PATHNAME STREAM)	;Use method defined on the pathname to decide.
    (ERROR 'WRONG-MAIL-FILE-FORMAT :BUFFER SELF
				   :APPARENT-FORMAT 'KBIN:KBIN-BUFFER
				   :FORMAT-STRING NIL)))

;;; Reject BABYL files.
(DEFUN-IN-FLAVOR (CHECK-NOT-BABYL-MSG-FILE MSG-BUFFER) ()
  (LET ((FIRST-LINE (SEND STREAM :LINE-IN)))
    (SEND STREAM :SET-POINTER 0)
    (WHEN (STRING-EQUAL FIRST-LINE "Babyl Options:")
      (ERROR 'WRONG-MAIL-FILE-FORMAT :BUFFER SELF
				     :APPARENT-FORMAT 'BABYL-BUFFER
				     :FORMAT-STRING NIL))))

;;; Loading old mail files -- Top Level

1;;; Edit an existing mail file or create the buffer for a new one.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-EDIT-MAIL-FILE
				"Edit a mail file.
Reads the pathname of a mail file from the minibuffer and reads said mail
file into a Zmail mail file buffer.  If the mail file does not exist, an
empty mail file buffer is created which, when saved, will create the mail
file with the requested pathname."
				(NO-SEQUENCE-OK)
  (SET-ZMAIL-USER)
  (LET ((FILE (ACCEPT-DEFAULTED-PATHNAME "Edit mail file" (DEFAULT-UNLOADED-MAIL-FILE))))
    (COM-ZMAIL-EDIT-OR-EXAMINE-FILE-INTERNAL FILE)))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-MAIL-FILE
						  (FS:PATHNAME "Edit mail file" *ZMAIL-COMTAB*
							       :GESTURE :SELECT)
						  (FILE)
  `(COM-ZMAIL-EDIT-OR-EXAMINE-FILE-INTERNAL ,FILE :NEAR '(:MOUSE)))

1;;; Examine an existing mail file -- Disable saves for the buffer after reading the file.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-EXAMINE-MAIL-FILE
				"Examine an existing mail file.
Reads the pathname of a mail file from the minibuffer, reads said mail file
into a Zmail mail file buffer, and then disables saving of the buffer.
The mail file must already exist."
				(NO-SEQUENCE-OK)
  (SET-ZMAIL-USER)
  (LET ((FILE  (ACCEPT-DEFAULTED-PATHNAME "Examine mail file" (DEFAULT-UNLOADED-MAIL-FILE))))
    (COM-ZMAIL-EDIT-OR-EXAMINE-FILE-INTERNAL FILE :IF-DOES-NOT-EXIST :ERROR
						  :OPTIONS '(:DISABLE-SAVES T))))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EXAMINE-MAIL-FILE
						  (FS:PATHNAME "Examine mail file"
							       *ZMAIL-COMTAB*
							       :GESTURE :SELECT-AND-ACTIVATE)
						  (FILE)
  `(COM-ZMAIL-EDIT-OR-EXAMINE-FILE-INTERNAL ,FILE :NEAR '(:MOUSE)
						  :IF-DOES-NOT-EXIST :ERROR
						  :OPTIONS '(:DISABLE-SAVES T)))

1;;; For the above commands and translators.
0(DEFUN COM-ZMAIL-EDIT-OR-EXAMINE-FILE-INTERNAL (FILE &REST LOAD-OR-CREATE-MAIL-FILE-OPTIONS)
  (SELECT-SEQUENCE (CL:APPLY 'LOAD-OR-CREATE-MAIL-FILE FILE LOAD-OR-CREATE-MAIL-FILE-OPTIONS)))



;;; Support for CP's "Edit File 1file0 :Editor Zmail"

(DEFUN EDIT-MAIL-FILE-FROM-ZMAIL (FILE)
  (SET-ZMAIL-USER)
  (COM-ZMAIL-EDIT-OR-EXAMINE-FILE-INTERNAL FILE))	;Returns proper display degree

(DEFUN MAIL-FILE-P (FILE)
  (LET* ((PATHNAME (CL:PATHNAME FILE)) (CTYPE (SEND PATHNAME :CANONICAL-TYPE)))
    (IF (AND (SYMBOLP CTYPE) (GET CTYPE :BINARY-FILE-BYTE-SIZE))
	(EQ CTYPE ':KBIN)
	T)))

(DEFUN CANONICALIZE-NEWEST (FILE)
  (LET* ((PATHNAME (CL:PATHNAME FILE))
	 (VERSION (CL:PATHNAME-VERSION PATHNAME)))
    (IF (NUMBERP VERSION)
	(LET* ((NEWEST-FILE (IGNORE-ERRORS (CL:PROBE-FILE (SEND FILE :NEW-VERSION :NEWEST))))
	       (NEWEST-VERSION (IF NEWEST-FILE (CL:PATHNAME-VERSION NEWEST-FILE))))
	  (IF (EQL NEWEST-VERSION VERSION)
	      (SEND FILE :NEW-VERSION :NEWEST)
	      PATHNAME))
	PATHNAME)))

(DEFUN EDIT-MAIL-FILE-FROM-OUTSIDE-ZMAIL
       (FILE &OPTIONAL (ZMAIL-WINDOW
			 (OR (IF (BOUNDP 'ZWEI:*ZMAIL-WINDOW*) ZWEI:*ZMAIL-WINDOW*)
			     (ERROR "Can't find the Zmail window."))))
  (SEND ZMAIL-WINDOW :FORCE-KBD-INPUT `(:TYPEOUT-EXECUTE EDIT-MAIL-FILE-FROM-ZMAIL ,FILE))
  (SEND ZMAIL-WINDOW :ACTIVATE)
  (SEND ZMAIL-WINDOW :EXPOSE)
  (SEND ZMAIL-WINDOW :SELECT))

(DEFUN EDIT-MAIL-FILES-FROM-OUTSIDE-ZMAIL (FILES)
  (MAPC #'EDIT-MAIL-FILE-FROM-OUTSIDE-ZMAIL FILES))

(SI:DEFINE-FILE-EDITOR EDIT-MAIL-FILES-FROM-OUTSIDE-ZMAIL
  :AFTER "Zmacs"
  :PRETTY-NAME "Zmail"
  :FILE-FILTER 'MAIL-FILE-P
  :FILE-FILTER-DESCRIPTION "mail file"
  :SOURCE-FILTER 'CANONICALIZE-NEWEST
  :PERMIT-MULTIPLE T
  :CONTEXT-FILTER #'(LAMBDA () (NOT (SYS:REMOTE-TERMINAL-P)))
  :CONTEXT-FILTER-DESCRIPTION "on the main screen")



(DEFUN DEFAULT-UNLOADED-MAIL-FILE ()
  (COND ((AND *SEQUENCE* (SEQUENCE-BUFFER-P *SEQUENCE*))
	 (MSG-BUFFER-PATHNAME *SEQUENCE*))
	(*DEFAULT-BUFFER*
	 (MSG-BUFFER-PATHNAME *DEFAULT-BUFFER*))
	(T
	 (DEFAULT-ZMAIL-MOVE-PATHNAME))))

1;;; Obsolete interface.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-SELECT-ARBITRARY-FORMAT-MAIL-FILE
				"Read in a file in a specified format.
The filename is read from the minibuffer and a menu of known file formats given
to specify how to read it in."
				(NO-SEQUENCE-OK)
  (SET-ZMAIL-USER)
  (SELECT-ARBITRARY-FORMAT-MAIL-FILE (SELECT-BUFFER-FIND-FILE :KBD)))

;;; Invoked indirectly by the ZMAIL function (defined in TOP) -- If no pathname is specified
;;; and there's no default buffer, we'll read the user's default mail file and its new mail,
;;; if any.  If an explicit pathname is provided, we'll load it if necessary and select its
;;; buffer as the current sequence.  Otherwise, we'll do nothing.
(DEFUN SELECT-SEQUENCE-IF-NEEDED (PATHNAME)
  (SET-ZMAIL-USER)
  (IF (AND *DEFAULT-BUFFER* (NULL PATHNAME))
      ;; Default mail file has already been read and the user isn't asking for a new file.
      DIS-NONE
    (IF PATHNAME
	;; Explicit mail file -- Read and select it.
	(LET* ((PATHNAME (FS:MERGE-PATHNAMES PATHNAME *ZMAIL-PATHNAME-DEFAULTS*))
	       (BUFFER (GET-BUFFER-FROM-PATHNAME PATHNAME)))
	  (UNLESS BUFFER
	    (SETQ BUFFER (LOAD-OR-CREATE-MAIL-FILE PATHNAME :IF-DOES-NOT-EXIST :QUERY
							    :USE-BACKGROUND T)))
	  (SELECT-SEQUENCE BUFFER))
      ;; No explicit pathname and no default buffer -- Read the default mail
      ;; file and its new mail, if any.
      (LET ((*ZMAIL-COMMAND-BUTTON* :KBD))	;Act like the user typed "G".
	(READ-NEW-MAIL-TOP-LEVEL)))))

;;; Load and select a mail file using a format selected by the user.
(DEFUN SELECT-ARBITRARY-FORMAT-MAIL-FILE (PATHNAME &KEY (NEAR '(:KBD)) INCLUDE-COMPUTE)
  (LET ((FORMAT (SELECT-ARBITRARY-FORMAT-BUFFER-FLAVOR PATHNAME
						       :NEAR NEAR
						       :INCLUDE-COMPUTE INCLUDE-COMPUTE)))
    (MULTIPLE-VALUE-BIND (BUFFER IGNORE)
	(LOAD-OR-CREATE-MAIL-FILE PATHNAME :NEAR NEAR :FORMAT FORMAT)
      (SELECT-SEQUENCE BUFFER))))

;;; Find/Create a sequence given its name --
;;;    If no sequence of the given name already exists and we are asked to create one,
;;;    we'll create a mail file buffer using the name as the pathname.
(DEFUN GET-MAIL-BUFFER-FROM-NAME (NAME &OPTIONAL CREATE-P DISABLE-SAVES-P)
  (COND ((DOLIST (SEQUENCE *SEQUENCE-LIST*)
	   (WHEN (STRING-EQUAL NAME (SEND SEQUENCE :NAME))
	     (RETURN SEQUENCE))))
	(CREATE-P
	 (LOAD-OR-CREATE-MAIL-FILE (FS:MERGE-PATHNAMES NAME *ZMAIL-PATHNAME-DEFAULTS*)
				   :OPTIONS `(:DISABLE-SAVES ,DISABLE-SAVES-P)))))

;;; Find/Create a mail file buffer given its pathname.
(DEFUN GET-BUFFER-FROM-PATHNAME (PATHNAME &OPTIONAL CREATE-P)
  (SETQ PATHNAME (FS:MERGE-PATHNAMES PATHNAME *ZMAIL-PATHNAME-DEFAULTS*))
  (COND ((DOLIST (SEQUENCE *SEQUENCE-LIST*)
	   (AND (SEQUENCE-BUFFER-P SEQUENCE)
		(EQ PATHNAME (SEND SEQUENCE ':PATHNAME))
		(RETURN SEQUENCE))))
	(CREATE-P
	 (LOAD-OR-CREATE-MAIL-FILE PATHNAME))))

1;;; Loading old mail -- Middle Level

;;; Load an existing mail file or create a new one.
0(DEFUN LOAD-OR-CREATE-MAIL-FILE (PATHNAME
				 &REST ALL-KEYWORDS
				 &KEY (IF-EXISTS :APPEND)
				      (IF-DOES-NOT-EXIST :CREATE)
				 &ALLOW-OTHER-KEYS)
  (DECLARE (ARGLIST . (PATHNAME &KEY (NEAR '(:KBD)) (IF-EXISTS :APPEND)
				     (IF-DOES-NOT-EXIST :CREATE) SILENT USE-BACKGROUND
				     DEFAULT-BUFFER SELECT-FORMAT-AND-OPTIONS FORMAT OPTIONS))
	   (VALUES . (BUFFER NEW-FILE)))	2;Is NEW-FILE result useful????
0  (CL:CHECK-TYPE IF-EXISTS (CL:MEMBER :APPEND :QUERY :ERROR))
  (CL:CHECK-TYPE IF-DOES-NOT-EXIST (CL:MEMBER :CREATE :QUERY :ERROR))
  (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					(.ERROR.)
       (BARF "~A" .ERROR.)
    (MULTIPLE-VALUE-BIND (PATHNAME PROBE)
	(LOOP NAMED GET-PATHNAME-AND-PROBE
	      FOR NEXT-PATHNAME = (FS:MERGE-PATHNAMES PATHNAME *ZMAIL-PATHNAME-DEFAULTS*)
				THEN (ACCEPT-DEFAULTED-PATHNAME "Use what file instead"
								NEXT-PATHNAME)
	      AS PATHNAME-IS-WILD = (SEND NEXT-PATHNAME :WILD-P)
	      AS PROBE = (UNLESS PATHNAME-IS-WILD
			   (OPEN NEXT-PATHNAME :DIRECTION :PROBE :IF-DOES-NOT-EXIST NIL))
	      IF PATHNAME-IS-WILD
		DO 1;; We don't implement wildcards yet ...
0		   (CL:CASE IF-EXISTS
		     (:QUERY
		       1;; ... and we're allowed to ask for a new pathname.
0		       (BEEP)
		       (TYPEOUT-LINE "Wildcard pathnames (~A) are not yet implemented."
				     NEXT-PATHNAME))
		     ((:APPEND :ERROR)
		      (BARF "Wildcard pathnames (~A) are not yet implemented." NEXT-PATHNAME)))
	      ELSE IF PROBE
		DO 1;; The file exists ...
0		  (CL:CASE IF-EXISTS
		    (:APPEND
		      (RETURN-FROM GET-PATHNAME-AND-PROBE (VALUES NEXT-PATHNAME PROBE)))
		    (:QUERY
		      1;; ... ask if it's OK to use and, if not, ask for another pathname.
0		      (WHEN (TYPEOUT-BEEP-YES-OR-NO-P
			      "The mail file ~A already exists~% (~A).~%~@
			       Do you want to read it? "
			      NEXT-PATHNAME (DESCRIBE-FILE-INFO (SEND PROBE :INFO)))
			(RETURN-FROM GET-PATHNAME-AND-PROBE (VALUES NEXT-PATHNAME PROBE))))
		    (:ERROR
		      (BARF "The mail file ~A already exists." NEXT-PATHNAME)))
	      ELSE
		DO 1;; The file doesn't exist ...
0		  (CL:CASE IF-DOES-NOT-EXIST
		    (:CREATE
		      (RETURN-FROM GET-PATHNAME-AND-PROBE (VALUES NEXT-PATHNAME PROBE)))
		    (:QUERY
		      1;; ... ask if it's OK to create and, if not, ask for another pathname.
0		      (WHEN (TYPEOUT-BEEP-YES-OR-NO-P "The mail file ~A does not exist.~@
						       ~2TDo you want to create it? "
						      NEXT-PATHNAME)
			(RETURN-FROM GET-PATHNAME-AND-PROBE (VALUES NEXT-PATHNAME PROBE))))
		    (:ERROR
		      (BARF "The mail file ~A does not exist." NEXT-PATHNAME))))
      (SI:WITH-REM-KEYWORDS (OPTIONS ALL-KEYWORDS '(:IF-EXISTS :IF-DOES-NOT-EXIST))
	(IF PROBE
	    (VALUES (CL:APPLY #'CREATE-BUFFER-AND-LOAD-MAIL-FILE PATHNAME PROBE OPTIONS) NIL)
	  (VALUES (CL:APPLY #'CREATE-BUFFER-FOR-NEW-MAIL-FILE PATHNAME OPTIONS) T))))))

1;;; Background request to preload all mail files listed in the user's profile --
;;;    We simply queue a response to the foreground to ask it to preload all the mail files.
;;;    We can't do this in the background as we don't have access to 2*sequence-list*1.
;;;    We can't do this when 2preload-zmail1 is executed as we're probably not inside 0Zmail
1;;;       and we have to wait until the user's profile is loaded.
0(DEFINE-ZMAIL-BACKGROUND-REQUEST PRELOAD-ALL-MAIL-FILES ()
     ()
  (QUEUE-ZMAIL-BACKGROUND-RESPONSE PRELOAD-ALL-MAIL-FILES)
  (ZMAIL-BACKGROUND-REQUEST-COMPLETE))

1;;; Actual workhorse for the above preload request.
0(DEFINE-ZMAIL-BACKGROUND-RESPONSE PRELOAD-ALL-MAIL-FILES ()
     ()
  (MULTIPLE-VALUE-BIND (IGNORE IGNORE UNLOADED-FILES-ALIST)
      (GET-SEQUENCE-ALISTS)
    (DOLIST (UFA-ENTRY UNLOADED-FILES-ALIST)
      (LET* ((PATHNAME (FS:MERGE-PATHNAMES (CDR UFA-ENTRY) *ZMAIL-PATHNAME-DEFAULTS*))
	     (REQUEST (MAKE-BACKGROUND-INSTANCE 'PRELOAD-MAIL-FILE `(,PATHNAME)
						'ZMAIL-BACKGROUND-REQUEST-FLAVOR
						'ZMAIL-BACKGROUND-REQUEST-REQUEST-ARGUMENTS
						"request")))
	(SETF (LOCATION-CONTENTS *ZMAIL-BACKGROUND-PRELOAD-QUEUE*)
	      (NCONC (LOCATION-CONTENTS *ZMAIL-BACKGROUND-PRELOAD-QUEUE*) (NCONS REQUEST)))))))

1;;; Background request to start preloading an existing mail file --
;;;    Anyone that queues these requests ensures that we're given fully merged pathnames.
0(DEFINE-ZMAIL-BACKGROUND-REQUEST PRELOAD-MAIL-FILE (PATHNAME &KEY DISABLE-SAVES)
     (:PRINT-FORMAT "~A~:[ (NoSaves)~]" :PRINT-FORMAT-ARGS (PATHNAME (NOT DISABLE-SAVES)))
  (TRAP-BACKGROUND-ERRORS ((ERROR) "Unable to preload Zmail file ~A" PATHNAME)
			  ()
       (ZMAIL-BACKGROUND-REQUEST-COMPLETE)	1;Nothing we can do if the file doesn't exist.
0    (LET ((PROBE (OPEN PATHNAME :DIRECTION :PROBE :IF-DOES-NOT-EXIST :ERROR)))
      (TRAP-BACKGROUND-ERRORS ((ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR) "")
			      (:SUPPRESS-NOTIFICATION T :ERROR-OBJECT .ERROR.)
	   (BLOCK PRELOAD-MAIL-FILE-SOFT-FAILURE
	     (QUEUE-ZMAIL-BACKGROUND-RESPONSE PRELOAD-MAIL-FILE-ERROR
					      PATHNAME DISABLE-SAVES PROBE .ERROR.)
	     (ZMAIL-BACKGROUND-REQUEST-COMPLETE))
	(SETQ SEQUENCE
	      (PRELOAD-CREATE-BUFFER-AND-LOAD-MAIL-FILE *ZMAIL-WINDOW*
							PATHNAME PROBE DISABLE-SAVES))
	(WHEN (AND SEQUENCE (MSG-BUFFER-STREAM SEQUENCE))
	  1;; Successfully opened --
	  ;;    Queue a request to load the file at the front of the preload queue.
0	  (QUEUE-ZMAIL-BACKGROUND-REQUEST-INTERNAL *ZMAIL-BACKGROUND-PRELOAD-QUEUE*
						   'LOAD-MAIL-FILE-MSGS SEQUENCE))
	(ZMAIL-BACKGROUND-REQUEST-COMPLETE)))))

;;; Process an error attempting to preload a mail file --
;;;    Resignal the error in the foreground in order to get an appropriate debugger menu
;;;    and, if the user agrees, retry the operation.
(DEFINE-ZMAIL-BACKGROUND-RESPONSE PRELOAD-MAIL-FILE-ERROR (PATHNAME DISABLE-SAVES PROBE ERROR)
     (:PRINT-FORMAT "~A~:[ (NoSaves)~] ~A"
      :PRINT-FORMAT-ARGS (PATHNAME (NOT DISABLE-SAVES) (TYPEP ERROR)))
  (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					(.ERROR.)
       (BARF "~A" .ERROR.)
    (IF (TYPEP ERROR 'PRELOAD-FILE-CONFLICT)
	;; Special case finding the wrong version of the file in a buffer when preloading --
	;;    Simply retry the operation so that it will ask the user what to do.
	(CREATE-BUFFER-AND-LOAD-MAIL-FILE PATHNAME PROBE :USE-BACKGROUND T
							 :OPTIONS `(:DISABLE-SAVES
								     ,DISABLE-SAVES))
      (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-BACKGROUND-FILE-ERROR)
	(CATCH-ERROR-RESTART (ZMAIL-BACKGROUND-FILE-ERROR
			       "Abort reading ~A." PATHNAME)
	  (CATCH-ERROR-RESTART-WITH-FORM (ZMAIL-BACKGROUND-FILE-ERROR
					   "Retry reading ~A in the foreground." PATHNAME)
	       (CREATE-BUFFER-AND-LOAD-MAIL-FILE PATHNAME PROBE :OPTIONS `(:DISABLE-SAVES
									    ,DISABLE-SAVES))
	    (CATCH-ERROR-RESTART-WITH-FORM (ZMAIL-BACKGROUND-FILE-ERROR
					     "Retry reading ~A in the background." PATHNAME)
		 (CREATE-BUFFER-AND-LOAD-MAIL-FILE PATHNAME PROBE :USE-BACKGROUND T
								  :OPTIONS `(:DISABLE-SAVES
									      ,DISABLE-SAVES))
	      (ERROR 'ZMAIL-BACKGROUND-FILE-ERROR :ERROR ERROR :FORMAT-STRING ""))))))))


;;; Support functions for the above ...

;;; Create a buffer for an existing mail file and load it -- If the appropriate buffer
;;; already exists, ask the user what to do.  Also, allow the user to select the file
;;; format to be used to load the mail file.
(DEFUN CREATE-BUFFER-AND-LOAD-MAIL-FILE (PATHNAME PROBE
					 &REST ALL-KEYWORDS
					 &KEY (NEAR '(:KBD))
					      SILENT
					      FOR-PRELOADING
					      USE-BACKGROUND
					      DEFAULT-BUFFER
					      SELECT-FORMAT-AND-OPTIONS
					      FORMAT OPTIONS)
  (IGNORE SILENT)				;For CREATE-BUFFER-FOR-NEW-MAIL-FILE only
  (LET ((BUFFER (GET-BUFFER-FROM-PATHNAME PATHNAME)))
    (WHEN BUFFER
      ;; The appropriate buffer already exists ...
      (UNLESS (EQ (MSG-BUFFER-STATUS BUFFER) :LOADING)
	;; ... and it isn't already loading (probably through PRELOAD-ZMAIL).
	(MULTIPLE-VALUE-BIND (NEW-FILE-DESC OLD-FILE-DESC)
	    (STREAM-CHECK-FILE-INFO PROBE (SEND BUFFER :ID))
	  (WHEN NEW-FILE-DESC
	    ;; ... and it's different from the copy on the file computer.
	    (IF FOR-PRELOADING
		(ERROR 'PRELOAD-FILE-CONFLICT "")	;See PRELOAD-MAIL-FILE-ERROR response.
	      (WHEN (TYPEOUT-BEEP-YES-OR-NO-P
		      "~&Since you last read or wrote ~A~% (~A),~@
		         a new version has appeared on the file computer~% (~A).~%~@
		         Do you want the new version instead? "
		      PATHNAME OLD-FILE-DESC NEW-FILE-DESC)
		;; The user has decided that they want the new version ...
		(KILL-SEQUENCE BUFFER)
		;; ... so call ourselves again knowing that we now won't find a buffer.
		(RETURN-FROM CREATE-BUFFER-AND-LOAD-MAIL-FILE
		  (CL:APPLY #'CREATE-BUFFER-AND-LOAD-MAIL-FILE PATHNAME PROBE ALL-KEYWORDS))))
	    )))
      ;; ... and it either matches the file computer's version or the user wants to keep it.
      (RETURN-FROM CREATE-BUFFER-AND-LOAD-MAIL-FILE (VALUES BUFFER))))
  ;; There's no buffer yet ...
  (LET* ((CURRENT-FORMAT (IF SELECT-FORMAT-AND-OPTIONS
			     (SELECT-ARBITRARY-FORMAT-BUFFER-FLAVOR PATHNAME :NEAR NEAR)
			   (OR FORMAT
			       (DEFAULT-MAIL-FILE-FORMAT PATHNAME)
			       (DEFAULT-DEFAULT-MAIL-FILE-FORMAT PATHNAME))))
	 (HANDLE-FORMAT-ERRORS (AND (NULL FORMAT) (NOT SELECT-FORMAT-AND-OPTIONS)))
	 (BUFFER (MAKE-SEQUENCE CURRENT-FORMAT :PATHNAME PATHNAME
					       :OPTIONS OPTIONS
					       :DEFAULT-BUFFER DEFAULT-BUFFER)))
    (CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL BUFFER HANDLE-FORMAT-ERRORS
					       :FOR-PRELOADING FOR-PRELOADING
					       :USE-BACKGROUND USE-BACKGROUND)
    BUFFER))

;;; Find/Create a mail file buffer and start loading its mail file --
;;;    Invoked in the Zmail background process by the PRELOAD-MAIL-FILE background request,
;;;    this method exists to insure that Zmail's special instance variables are bound.
(DEFMETHOD (PRELOAD-CREATE-BUFFER-AND-LOAD-MAIL-FILE BASIC-ZMAIL)
	   (PATHNAME PROBE DISABLE-SAVES)
  (CREATE-BUFFER-AND-LOAD-MAIL-FILE PATHNAME PROBE :FOR-PRELOADING T
						   :USE-BACKGROUND T
						   :OPTIONS `(:DISABLE-SAVES ,DISABLE-SAVES)))

;;; For COMPLETE-MAIL-FILE-IO and the LOAD-MAIL-FILE-MSGS-ERROR background response...
(DEFUN CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL (BUFFER HANDLE-FORMAT-ERRORS
						  &KEY FOR-PRELOADING
						       USE-BACKGROUND
						       ALREADY-OPEN
						       DISPLAY-TOTALS-ONLY)
  (LOCK-SEQUENCE (BUFFER :WRITE)
    (LET ((PATHNAME (MSG-BUFFER-PATHNAME BUFFER))
	  (CURRENT-FORMAT (TYPEP BUFFER))
	  (CURRENT-FORMAT-NAME (SEND BUFFER :FORMAT-NAME)))
      (UNWIND-PROTECT-CASE ()
	  (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
						     (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI");; KLUDGE until default set complete:
0						     FS:FILE-ERROR SYS:NETWORK-ERROR)
	    (CATCH-ERROR-RESTART-WITH-FORM ((FS:FILE-ERROR SYS:NETWORK-ERROR ZMAIL-FILE-ERROR)
					    "Abort reading ~A." PATHNAME)
		 (ABORT-CURRENT-COMMAND)
	      (ERROR-RESTART-WITH-FORM ((WRONG-MAIL-FILE-FORMAT)
					"Retry reading ~A in a different format." PATHNAME)
		   (BLOCK TRY-NEW-FORMAT
		     (SETQ CURRENT-FORMAT (SELECT-ARBITRARY-FORMAT-BUFFER-FLAVOR PATHNAME)
			   CURRENT-FORMAT-NAME (FLAVOR:FUNCALL-HANDLER CURRENT-FORMAT
								       :FORMAT-NAME)
			   HANDLE-FORMAT-ERRORS NIL)
		     (CHANGE-INSTANCE-FLAVOR BUFFER CURRENT-FORMAT))
		;; Try once with a handler that changes to the apparent format ...
		(WHEN (AND HANDLE-FORMAT-ERRORS (NOT ALREADY-OPEN))
		  (ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR ZMAIL-FILE-ERROR)
				  "Retry reading ~A in ~A format."
				  PATHNAME CURRENT-FORMAT-NAME)
		    (CONDITION-CASE-IF HANDLE-FORMAT-ERRORS (ERR)
			 (BLOCK OPEN-WITH-HANDLER
			   (START-LOADING-MAIL-FILE BUFFER)
			   (SETQ ALREADY-OPEN T))	;Got it...
		       (WRONG-MAIL-FILE-FORMAT
			 (ABORT-LOADING-MAIL-FILE BUFFER :NEW-MAIL NIL :KILL-SEQUENCE NIL)
			 (LET ((APPARENT-FORMAT (WRONG-MAIL-FILE-FORMAT-APPARENT-FORMAT ERR))
			       (FORMAT-STRING (WRONG-MAIL-FILE-FORMAT-FORMAT-STRING ERR))
			       (FORMAT-ARGS (WRONG-MAIL-FILE-FORMAT-FORMAT-ARGS ERR)))
			   (IF (NULL APPARENT-FORMAT)
			       (ERROR 'WRONG-MAIL-FILE-FORMAT :BUFFER BUFFER
							      :APPARENT-FORMAT NIL
							      :FORMAT-STRING FORMAT-STRING
							      :FORMAT-ARGS FORMAT-ARGS)
			     (SETQ CURRENT-FORMAT APPARENT-FORMAT
				   CURRENT-FORMAT-NAME (FLAVOR:FUNCALL-HANDLER CURRENT-FORMAT
									       :FORMAT-NAME))
			     (CHANGE-INSTANCE-FLAVOR BUFFER CURRENT-FORMAT)))))))
		;; Try "forever" until we suceed ...
		(ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR ZMAIL-FILE-ERROR)
				"Retry reading ~A in ~A format." PATHNAME CURRENT-FORMAT-NAME)
		  (UNWIND-PROTECT-CASE ()
		      (BLOCK OPEN-AND-LOAD
			(UNLESS ALREADY-OPEN
			  (START-LOADING-MAIL-FILE BUFFER))
			(UNLESS FOR-PRELOADING
			  ;; Don't read messages if we're just setting up a preload.
			  (LOAD-MAIL-FILE-MSGS BUFFER
					       :USE-BACKGROUND USE-BACKGROUND
					       :DISPLAY-TOTALS-ONLY DISPLAY-TOTALS-ONLY)
			  (WHEN (EQ (MSG-BUFFER-STATUS BUFFER) :LOADED)
			    (FINISH-LOADING-MAIL-FILE BUFFER))))
		    (:ABORT
		      (ABORT-LOADING-MAIL-FILE BUFFER :NEW-MAIL NIL :KILL-SEQUENCE NIL)
		      (SETQ ALREADY-OPEN NIL)))))))
	(:ABORT
	  (WHEN BUFFER (ABORT-LOADING-MAIL-FILE BUFFER)))))))

;;; Create a buffer for a non-existant mail file -- Allow the user to select the file's
;;; format and mail file options if requested.
(DEFUN CREATE-BUFFER-FOR-NEW-MAIL-FILE (PATHNAME
					&KEY (NEAR '(:KBD))
					     SILENT
					     USE-BACKGROUND
					     DEFAULT-BUFFER
					     SELECT-FORMAT-AND-OPTIONS
					     FORMAT OPTIONS)
  (IGNORE USE-BACKGROUND)			;For CREATE-BUFFER-AND-LOAD-MAIL-FILE only
  (WHEN (EQUAL NEAR '(:KBD))
    (SETQ NEAR `(:WINDOW, *MODE-LINE-WINDOW*)))
  (UNLESS SILENT
    (TYPEIN-LINE "(New file ~A)" PATHNAME))
  (LABELS ((OPTION-PRESENT-P (OPTIONS OPTION)
	     (MULTIPLE-VALUE-BIND (IGNORE IGNORE OPTION-PRESENT)
		 (CL:GET-PROPERTIES OPTIONS `(,OPTION))
	       OPTION-PRESENT)))
    (LET* ((DEFAULTING-BUFFER
	     ;; Select a buffer to be used to supply defaults for format and options ...
	     (LET ((BUFFER (COND ((SEQUENCE-BUFFER-P *SEQUENCE*) *SEQUENCE*)
				 ((AND *DEFAULT-MOVE-SEQUENCE*
				       (SEQUENCE-BUFFER-P *DEFAULT-MOVE-SEQUENCE*))
				  *DEFAULT-MOVE-SEQUENCE*)
				 (*DEFAULT-BUFFER*))))
	       ;; ... but only if its format is acceptable to the new buffer's system.
	       (WHEN (MEMQ (TYPEP BUFFER) (NATIVE-MAIL-FILE-FORMATS PATHNAME)) BUFFER)))
	   (DEFAULT-FORMAT
	     (OR FORMAT
		 (DEFAULT-MAIL-FILE-FORMAT PATHNAME)
		 ;; Use defaulting buffer's format when acceptable only if the
		 ;; pathname's type doesn't imply a more obvious default format.
		 (WHEN DEFAULTING-BUFFER (TYPEP DEFAULTING-BUFFER))
		 (DEFAULT-DEFAULT-MAIL-FILE-FORMAT PATHNAME)))
	   (INITIAL-OPTIONS
	     (IF DEFAULTING-BUFFER
		 ;; Add "sticky" options from the defaulting buffer to our caller's list.
		 (APPEND OPTIONS
			 (LOOP FOR OPTION IN (STICKY-MAIL-FILE-OPTIONS DEFAULTING-BUFFER)
			       AS VALUE = (SEND DEFAULTING-BUFFER :GET OPTION)
			       UNLESS (OPTION-PRESENT-P OPTIONS OPTION)
				 COLLECT OPTION AND COLLECT VALUE))
	       OPTIONS)))
      ;; Select proper setting for :APPEND mail file option based on the user's profile ...
      (CL:ECASE *NEW-MAIL-FILE-APPEND-P*
	(:APPEND
	  (SETF (CL:GETF INITIAL-OPTIONS :APPEND) T))
	(:PREPEND
	  (SETF (CL:GETF INITIAL-OPTIONS :APPEND) NIL))
	(:STICKY)
	(:ASK
	  (UNLESS SELECT-FORMAT-AND-OPTIONS
	    ;; ... only if we aren't going to put up the CVV window.
	    (LET ((NEAR (IF (EQUAL NEAR `(:WINDOW, *MODE-LINE-WINDOW*)) '(:KBD) NEAR)))
	      (SETF (CL:GETF INITIAL-OPTIONS :APPEND)
		    (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR-RAW NEAR
		      #'TYPEIN-LINE-ACCEPT `((DW:MENU-CHOOSE :ALIST (("Append" . T)
								     ("Prepend" . NIL)))
					     :DESCRIPTION "an append option")
					   :DEFAULT (CL:GETF INITIAL-OPTIONS :APPEND)
					   :PROMPT (FORMAT NIL "Select append//prepend for ~A"
							   PATHNAME)
					   :INITIALLY-DISPLAY-POSSIBILITIES T))))))
      (IF SELECT-FORMAT-AND-OPTIONS
	  ;; Put up the CVV window with format and options.
	  (LET ((COMPLETE-OPTIONS (COMPLETE-MAIL-FILE-OPTIONS DEFAULT-FORMAT INITIAL-OPTIONS
							      :PATHNAME PATHNAME)))
	    (MULTIPLE-VALUE-BIND (IGNORE DESIRED-FORMAT DESIRED-OPTIONS)
	      (CHOOSE-MAIL-FILE-OPTIONS-INTERNAL PATHNAME DEFAULT-FORMAT COMPLETE-OPTIONS
						 :NEAR NEAR)
	      (MAKE-SEQUENCE DESIRED-FORMAT :PATHNAME PATHNAME :ID T :OPTIONS DESIRED-OPTIONS
					    :DEFAULT-BUFFER DEFAULT-BUFFER)))
	;; Create the buffer using the settings derived above.
	(MAKE-SEQUENCE DEFAULT-FORMAT :PATHNAME PATHNAME :ID T :OPTIONS INITIAL-OPTIONS
				      :DEFAULT-BUFFER DEFAULT-BUFFER)))))

;;; Ask the user for a mail file format.
(DEFUN SELECT-ARBITRARY-FORMAT-BUFFER-FLAVOR (PATHNAME &KEY (NEAR '(:KBD)) INCLUDE-COMPUTE)
  (LET ((FLAVOR-ALIST
	  (LOOP FOR ITEM IN *MAIL-BUFFER-FLAVOR-ALIST*
		WHEN (FLAVOR:FUNCALL-HANDLER (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ITEM)
					     :MAIL-FILE-REPARSABLE-P)
		  COLLECT ITEM INTO FLAVOR-ALIST
		FINALLY
		  (WHEN INCLUDE-COMPUTE
		    (PUSH
		      `("Compute" :VALUE NIL :DOCUMENTATION "Determine format from content.")
		      FLAVOR-ALIST))
		  (RETURN FLAVOR-ALIST))))
    (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR NEAR
      #'TYPEIN-LINE-ACCEPT `((DW:MENU-CHOOSE :ALIST ,FLAVOR-ALIST)
			     :DESCRIPTION "a mail file format")
			   :INITIALLY-DISPLAY-POSSIBILITIES T
			   :PROMPT (FORMAT NIL "Mail file format for ~A" PATHNAME)
			   :DEFAULT (IF INCLUDE-COMPUTE NIL
				      (OR (DEFAULT-MAIL-FILE-FORMAT PATHNAME)
					  (DEFAULT-DEFAULT-MAIL-FILE-FORMAT PATHNAME))))))

;;; Loading old mail files -- Low Level Primitives

;;; Start loading a mail file --
;;;    Open the mail file, verify its format, and load its header (if any).
;;;
;;;    In order to prevent any pending inboxes from finishing too soon, the
;;;    ABORT-LOADING-MAIL-FILE method will leave us in :LOADING state when there are
;;;    pending inboxes even though, technically, we're :IDLE again.  Therefore, we'll
;;;    accept that situation as a valid state here.
;;;
;;;    This method relies on its caller to establish an appropriate UNWIND-PROTECT
;;;    that aborts loading the mail file.
;;;
(DEFMETHOD (START-LOADING-MAIL-FILE FILE-MAIL-BUFFER) ()
  (CL:ASSERT (OR (EQ STATUS :IDLE)
		 (AND (EQ STATUS :LOADING) (NOT (NULL INBOXES-BEING-INSERTED)))) ()
	     "START-LOADING-MAIL-FILE invoked for buffer ~S while in state ~A." SELF STATUS)
  (SETQ STATUS :LOADING)
  (OPEN-MAIL-FILE SELF :DIRECTION :INPUT)
  (VERIFY-MSG-FILE-FORMAT-AND-LOAD-HEADER SELF)
  (QUEUE-MAIL-CHECK-REQUESTS SELF)
  (WHEN (EQ SELF *SEQUENCE*)
    (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION :SUMMARY-WINDOW-FORMAT)))

(DEFWHOPPER (START-LOADING-MAIL-FILE FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

;;; Open a mail file for input/output
(DEFGENERIC OPEN-MAIL-FILE (FILE-MAIL-BUFFER &KEY DIRECTION)
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    (LET ((ELEMENT-TYPE (MSG-FILE-ELEMENT-TYPE SELF)))
      (CL:ECASE DIRECTION
	(:INPUT
	  (CONDITION-CASE (.ERROR.)
	       (SETQ STREAM (OPEN PATHNAME :DIRECTION :INPUT :ELEMENT-TYPE ELEMENT-TYPE))
	     (FS:INVALID-BYTE-SIZE
	       ;; Element type for this mail file format is incompatible with the file's
	       ;; actual byte size:
	       ;;   Open the file with 2:element-type0 2:default0, ask the 2actual-mail-file-format
0	       ;;   generic to compute the real format (if possible) and signal the
	       ;;   2wrong-mail-file-format0 condition.  Our standard handlers for this
	       ;;   condition will close the file and then reopen it with the proper
	       ;;   element type.
	       (SETQ STREAM (OPEN PATHNAME :DIRECTION :INPUT :ELEMENT-TYPE :DEFAULT))
	       (LET ((STREAM-ELEMENT-TYPE (CL:STREAM-ELEMENT-TYPE STREAM))
		     (APPARENT-FORMAT (ACTUAL-MAIL-FILE-FORMAT PATHNAME STREAM)))
		 (ERROR 'WRONG-MAIL-FILE-FORMAT :BUFFER SELF
						:APPARENT-FORMAT APPARENT-FORMAT
						:FORMAT-STRING
						  (UNLESS APPARENT-FORMAT
						    "It appears to be a ~
						     ~:[binary~;text~] file.")
						:FORMAT-ARGS
						  `(,(CL:SUBTYPEP 'CL:STRING-CHAR
								  STREAM-ELEMENT-TYPE)))))))
	(:OUTPUT
	  (SETQ STREAM (IF (MEMQ (SEND PATHNAME :VERSION) '(:NEWEST :UNSPECIFIC))
			   (OPEN PATHNAME :DIRECTION :OUTPUT :ELEMENT-TYPE ELEMENT-TYPE)
			 (OPEN PATHNAME :DIRECTION :OUTPUT :ELEMENT-TYPE ELEMENT-TYPE
					:IF-EXISTS :SUPERSEDE)))
	  (WHEN (AND (EQ ID 'T)			;New file.
		     (NOT (NULL *DEFAULT-MAIL-BUFFER-GENERATION-RETENTION-COUNT*)))
	    (CONDITION-CASE (.ERROR.)
		 (SEND STREAM :CHANGE-PROPERTIES T
			      :GENERATION-RETENTION-COUNT
			        *DEFAULT-MAIL-BUFFER-GENERATION-RETENTION-COUNT*)
	       ((FS:FILE-ERROR SYS:NETWORK-ERROR)
		(TYPEIN-LINE "Warning: ~~A~" .ERROR.)))))))))

;;; Load all messages from the mail file into its buffer.
(DEFMETHOD (LOAD-MAIL-FILE-MSGS FILE-MAIL-BUFFER) (&KEY USE-BACKGROUND DISPLAY-TOTALS-ONLY)
  (CL:ASSERT (EQ STATUS :LOADING) ()
	     "LOAD-MAIL-FILE-MSGS invoked for buffer ~S while in state ~A." SELF STATUS)
  (UNLESS DISPLAY-TOTALS-ONLY
    (CL:APPLY (IF USE-BACKGROUND #'TYPEIN-LINE #'TYPEIN-LINE-DURABLE)
	      "Reading ~A file ~A ... " (SEND SELF :FORMAT-NAME) (SEND STREAM :TRUENAME)
	      NIL))
  (IF USE-BACKGROUND
      (QUEUE-ZMAIL-BACKGROUND-REQUEST LOAD-MAIL-FILE-MSGS SELF)
    (LOOP WHILE (READ-NEXT-MSG SELF))
    (WHEN (EQ SELF *SEQUENCE*)
      (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY T))
    (LET ((N-MSGS-READ (- (SEQUENCE-NMSGS SELF) (OR TOTAL-MSGS-FROM-INBOXES 0))))
      (IF DISPLAY-TOTALS-ONLY
	  (TYPEIN-LINE-DURABLE "~D message~:P read from ~A file ~A."
			       N-MSGS-READ (SEND SELF :FORMAT-NAME) (SEND STREAM :TRUENAME))
	(TYPEIN-LINE-MORE-DURABLE "~D message~:P." N-MSGS-READ)))
    (SETQ STATUS :LOADED)))

(DEFWHOPPER (LOAD-MAIL-FILE-MSGS FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

;;; Load a mail file's messages in the background.
(DEFINE-ZMAIL-BACKGROUND-REQUEST LOAD-MAIL-FILE-MSGS (&AUX LOADING-DONE)
     (:USES-SEQUENCE T
      :INIT-FORM
        (LET ((PROCESS				;May be created by the background if preload.
		(IF (EQ *ZMAIL-BACKGROUND-P* T) CURRENT-PROCESS *ZMAIL-BACKGROUND-PROCESS*)))
	  (SETF (FS:FILE-DATA-STREAM-PROCESS (MSG-BUFFER-STREAM SEQUENCE)) PROCESS))
      :FLUSH-FORM
        (LET ((STREAM (MSG-BUFFER-STREAM SEQUENCE)))
	  (WHEN STREAM
	    (SETF (FS:FILE-DATA-STREAM-PROCESS STREAM) CURRENT-PROCESS))))
  (TRAP-BACKGROUND-ERRORS (ERROR
			    "Unable to read ~A file ~A"
			    (SEND SEQUENCE :FORMAT-NAME) (SEQUENCE-NAME SEQUENCE))
			  ()
       (BLOCK LOAD-MAIL-FILE-MSGS-HARD-FAILURE
	 (QUEUE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-ERROR SEQUENCE :FATAL T)
	 (ZMAIL-BACKGROUND-REQUEST-COMPLETE))
    (TRAP-BACKGROUND-ERRORS ((ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR) "")
			    (:SUPPRESS-NOTIFICATION T :ERROR-OBJECT .ERROR.)
	 (BLOCK LOAD-MAIL-FILE-MSGS-SOFT-FAILURE
	   (QUEUE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-ERROR SEQUENCE :ERROR .ERROR.)
	   (ZMAIL-BACKGROUND-REQUEST-COMPLETE))
      (SETQ LOADING-DONE (LOOP REPEAT *BACKGROUND-LOAD-QUANTUM*
			       FOR MORE-MSGS-AVAILABLE = (READ-NEXT-MSG SEQUENCE)
			       WHILE (AND MORE-MSGS-AVAILABLE
					  (NOT (STOP-ZMAIL-BACKGROUND-FOR-FOREGROUND-P)))
			       FINALLY (RETURN (NOT MORE-MSGS-AVAILABLE))))
      (IF LOADING-DONE
	  (BLOCK LOADING-COMPLETED
	    (QUEUE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-COMPLETED SEQUENCE)
	    (ZMAIL-BACKGROUND-REQUEST-COMPLETE))
	(BLOCK LOADING-CONTINUES
	  (QUEUE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-CONTINUES SEQUENCE)
	  (ZMAIL-BACKGROUND-REQUEST-INCOMPLETE))))))

1;;; Foreground processing when a mail has finished loading in the background.
0(DEFINE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-COMPLETED ()
     (:USES-SEQUENCE T)
  (WHEN (EQ (MSG-BUFFER-STATUS SEQUENCE) :LOADING)
    1;; Don't bother if it was already finished to benefit an overanxious user...
0    (WHEN (EQ SEQUENCE *SEQUENCE*)
      (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY T))
    (LOCK-SEQUENCE (SEQUENCE :WRITE)
      (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					    (.ERROR.)
	   (BARF "~A" .ERROR.)
	(UNWIND-PROTECT-CASE ()
	    (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
						       3;; KLUDGE til default set complete:
0						       FS:FILE-ERROR SYS:NETWORK-ERROR)
	      (CATCH-ERROR-RESTART-WITH-FORM ((ZMAIL-FILE-ERROR FS:FILE-ERROR
								SYS:NETWORK-ERROR)
					      "Abort reading ~A." (SEQUENCE-NAME SEQUENCE))
		  (ABORT-CURRENT-COMMAND)
		(CATCH-ERROR-RESTART-WITH-FORM ((ZMAIL-FILE-ERROR FS:FILE-ERROR
								  SYS:NETWORK-ERROR)
						"Retry reading ~A in the foreground."
						(SEQUENCE-NAME SEQUENCE))
		    (CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL SEQUENCE NIL)
		  (CATCH-ERROR-RESTART-WITH-FORM ((ZMAIL-FILE-ERROR FS:FILE-ERROR
								    SYS:NETWORK-ERROR)
						  "Retry reading ~A in the background."
						  (SEQUENCE-NAME SEQUENCE))
		      (CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL SEQUENCE NIL
									  :USE-BACKGROUND T)
		    (UNWIND-PROTECT-CASE ()
			(PROGN
			  (SETF (MSG-BUFFER-STATUS SEQUENCE) :LOADED)
			  (FINISH-LOADING-MAIL-FILE SEQUENCE :DISPLAY-TOTALS T))
		      (:ABORT
			(ABORT-LOADING-MAIL-FILE SEQUENCE :NEW-MAIL NIL
							  :KILL-SEQUENCE NIL)))))))
	  (:ABORT
	    (ABORT-LOADING-MAIL-FILE SEQUENCE)))))))

;;; Foreground processing when a mail file loaded a few more messages
(DEFINE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-CONTINUES ()
     (:USES-SEQUENCE T)
  (UNLESS (EQ (MSG-BUFFER-STATUS SEQUENCE) :KILLED)
    (WHEN (EQ SEQUENCE *SEQUENCE*)
      (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY T))))

;;; Foreground processing when an error occurs while loading a mail file in the background --
;;;    If the error isn't fatal, give the user a chance to retry reading.
(DEFINE-ZMAIL-BACKGROUND-RESPONSE LOAD-MAIL-FILE-MSGS-ERROR (&KEY FATAL ERROR)
     (:USES-SEQUENCE T)
  (WHEN (EQ (MSG-BUFFER-STATUS SEQUENCE) :LOADING)
    ;; Don't bother if it was already finished/aborted to benefit an overanxious user...
    (IF (OR FATAL (NULL ERROR))			;Can't offer to retry if no error indication.
	(ABORT-LOADING-MAIL-FILE SEQUENCE)
      (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					    (.ERROR.)
	   (BARF "~A" .ERROR.)
	(UNWIND-PROTECT-CASE ()
	    (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-BACKGROUND-FILE-ERROR)
	      (CATCH-ERROR-RESTART-WITH-FORM (ZMAIL-BACKGROUND-FILE-ERROR
					       "Abort reading ~A." (SEQUENCE-NAME SEQUENCE))
		   (ABORT-CURRENT-COMMAND)
		(CATCH-ERROR-RESTART-WITH-FORM (ZMAIL-BACKGROUND-FILE-ERROR
						 "Retry reading ~A in the foreground."
						 (SEQUENCE-NAME SEQUENCE))
		     (CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL SEQUENCE NIL)
		  (CATCH-ERROR-RESTART-WITH-FORM (ZMAIL-BACKGROUND-FILE-ERROR
						   "Retry reading ~A in the background."
						   (SEQUENCE-NAME SEQUENCE))
		       (CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL SEQUENCE NIL
									   :USE-BACKGROUND T)
		    (UNWIND-PROTECT-CASE ()
			(ERROR 'ZMAIL-BACKGROUND-FILE-ERROR :ERROR ERROR :FORMAT-STRING "")
		      (:ABORT
			(ABORT-LOADING-MAIL-FILE SEQUENCE :NEW-MAIL NIL
							  :KILL-SEQUENCE NIL)))))))
	  (:ABORT
	    (ABORT-LOADING-MAIL-FILE SEQUENCE)))))))

;;; Finish loading a mail file --
;;;    Close the mail file stream, start a background parse of our old mail, and finish
;;;    reading new mail if all our pending inboxes are ready.
(DEFMETHOD (FINISH-LOADING-MAIL-FILE FILE-MAIL-BUFFER) (&KEY DISPLAY-TOTALS)
  (CL:ASSERT (EQ STATUS :LOADED) ()
	     "FINISH-LOADING-MAIL-FILE invoked for buffer ~S while in state ~A." SELF STATUS)
  (WHEN DISPLAY-TOTALS
    (TYPEIN-LINE-DURABLE "~D message~:P read from ~A file ~A."
			 (- (SEQUENCE-NMSGS SELF) (OR TOTAL-MSGS-FROM-INBOXES 0))
			 (SEND SELF :FORMAT-NAME) (SEND STREAM :TRUENAME)))
  (WHEN STREAM
    (CL:CLOSE STREAM)
    (SETQ ID (SEND STREAM :INFO)
	  STREAM NIL))
  (LET ((START (COND ((NULL FIRST-MSG-FROM-INBOXES) 0)	;No inbox messages
		     ((SEQUENCE-APPEND-P SELF) 0)	;Inbox messages after old mail
		     (T					;Inbox messages before old mail
		      (+ FIRST-MSG-FROM-INBOXES TOTAL-MSGS-FROM-INBOXES))))
	(END (COND ((NULL FIRST-MSG-FROM-INBOXES) NIL)
		   ((SEQUENCE-APPEND-P SELF) FIRST-MSG-FROM-INBOXES)
		   (T NIL))))
    (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-OLD-MSGS SELF :START START :END END))
  (WHEN INBOXES-BEING-INSERTED
    ;; We're reading new mail -- Check to see if we can now finish said process ...
    (SETQ STATUS :READING-NEW-MAIL)
    (WHEN (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
		ALWAYS (EQ (MSG-BUFFER-STATUS INBOX-BUFFER) :INSERTED))
      (FINISH-READING-NEW-MAIL SELF)))
  ;; Update status ...
  (WHEN (EQ STATUS :LOADED)
    (SETQ STATUS :IDLE))
  ;; Remember mail file options read from the file for future format transformations, etc.
  (SETQ ORIGINAL-OPTIONS (COPYLIST (SEND SELF :PROPERTY-LIST)))
  (WHEN (EQ SELF *SEQUENCE*)
    ;; Select a message if the mail file was selected before any messages were loaded.
    (WHEN (OR (NOT (VARIABLE-BOUNDP *MSG*)) (NULL *MSG*))
      (MUST-REDISPLAY *MSG-WINDOW* (ZMAIL-SELECT-MSG (FIRST-OR-LAST-MSG SELF) T)))
    ;; Update the current message's name now that we know how many messages are in the file.
    (COMPUTE-CURRENT-MSG-NAME)))

(DEFWHOPPER (FINISH-LOADING-MAIL-FILE FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

1;;; Abort loading a mail file --
;;;    By default, this method will also abort reading any new mail and will kill the sequence
;;;    although options are provided to suppress this behavior.   Due to the duration of
;;;    the 2unwind-protect1s above, this method can be invoked while the buffer is 2:idle1 should
;;;    the user abort at an appropriate point.  When completed, the buffer will either be
;;;    dead or will be 2:idle1 or 2:loading1.  If the buffer was reading new mail and the caller
;;;    doesn't ask to abort said reading, we'll leave the buffer 2:loading1 so that any new
;;;    mail which is read won't be processed before we can restart loading.
0(DEFMETHOD (ABORT-LOADING-MAIL-FILE FILE-MAIL-BUFFER) (&KEY (NEW-MAIL T)
							    (KILL-SEQUENCE T))
  (CL:ASSERT (MEMQ STATUS '(:KILLED :IDLE :LOADING :LOADED :READING-NEW-MAIL)) ()
	     "ABORT-LOADING-MAIL-FILE invoked for buffer ~S while in state ~A." SELF STATUS)
  (UNLESS (OR (EQ STATUS :KILLED)
	      (AND (EQ STATUS :IDLE) (NEQ ID T)))
    1;; Don't have to do anything if it's already dead or idle ...
0    (IF KILL-SEQUENCE
	(KILL-SEQUENCE SELF :ABORT T)		1;The easy way out ...
0      1;; Caller wants the buffer to surive ...
0      (WITH-BACKGROUND-PROCESS-LOCKED
	(FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF 'LOAD-MAIL-FILE-MSGS 'PARSE-OLD-MSGS))
      (WHEN NEW-MAIL
	1;; ... but not any new mail.
0	(WHEN INBOXES-BEING-INSERTED
	  (IF (EQ STATUS :LOADED) (SETQ STATUS :LOADING))	1;For 2abort-reading-new-mail1...
0	  (ABORT-READING-NEW-MAIL SELF)))
      1;; Get rid of any old mail which has been read ...
0      (SYS:WITHOUT-ABORTS ("Undoing incomplete reading of mail into ~A.~@
		Aborting this could leave that sequence in an inconsistent state~@
		and leave half-killed messages that might cause problems later."
			   NAME)
	(IF (AND FIRST-MSG-FROM-INBOXES (PLUSP TOTAL-MSGS-FROM-INBOXES)
		 (SEQUENCE-APPEND-P SELF))
	    1;; Inbox messages are present and they are appended to the mail file --
	    ;;    We must kill the old messages, move the inbox messages down, and fixup
	    ;;    any background parsing requests.
0	    (LET ((NEW-PARSE-REQUESTS (WITH-BACKGROUND-PROCESS-LOCKED
					(FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF
									 'PARSE-NEW-MSGS)))
		  (N-OLD-MSGS (- (SEQUENCE-NMSGS SELF) TOTAL-MSGS-FROM-INBOXES)))
	      (TV:NOTING-PROGRESS ((FORMAT NIL "Killing old messages in ~A." NAME))
		(LOOP FOR I FROM 0 BELOW FIRST-MSG-FROM-INBOXES
		      UNLESS (NULL (AREF ARRAY I))
			DO (KILL-MSG (AREF ARRAY I) T)
			   (SETF (AREF ARRAY I) NIL)
			   (TV:NOTE-PROGRESS I FIRST-MSG-FROM-INBOXES)))
	      (WITHOUT-INTERRUPTS
		(LOOP FOR I FROM FIRST-MSG-FROM-INBOXES BELOW (SEQUENCE-NMSGS SELF)
		      FOR J FROM 0
		      DO (SETF (AREF ARRAY J) (AREF ARRAY I)))
		(CL:SETF (SEQUENCE-NMSGS SELF) TOTAL-MSGS-FROM-INBOXES
			 FIRST-MSG-FROM-INBOXES 0))
	      (UPDATE-CURRENT-MSG-STATE-AFTER-MSG-INSERTION SELF 0 (- N-OLD-MSGS))
	      (LOOP FOR REQUEST IN NEW-PARSE-REQUESTS
		    AS START = (ZMAIL-PARSE-NEW-MSGS-BACKGROUND-REQUEST-START REQUEST)
		    AS END = (ZMAIL-PARSE-NEW-MSGS-BACKGROUND-REQUEST-END REQUEST)
		    DO (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-NEW-MSGS SELF
						       :START (- START N-OLD-MSGS)
						       :END (- END N-OLD-MSGS))))
	  1;; No inbox messages or they're prepended -- We can just kill the old messages.
0	  (TV:NOTING-PROGRESS ((FORMAT NIL "Killing old messages in ~A." NAME))
	    (LOOP WITH FIRST-OLD-MSG = (OR TOTAL-MSGS-FROM-INBOXES 0)
		  WITH NMSGS-TO-KILL = (- (SEQUENCE-NMSGS SELF) FIRST-OLD-MSG)
		  FOR I FROM FIRST-OLD-MSG REPEAT NMSGS-TO-KILL
		  UNLESS (NULL (AREF ARRAY I))
		    DO (KILL-MSG (AREF ARRAY I) T)
		       (SETF (AREF ARRAY I) NIL)
		       (TV:NOTE-PROGRESS (- I FIRST-OLD-MSG) NMSGS-TO-KILL)))
	  (SETF (SEQUENCE-NMSGS SELF) (OR TOTAL-MSGS-FROM-INBOXES 0))))
      (UNWIND-PROTECT
	  (WHEN STREAM
	    1;; Close any open stream ...
0	    (SYS:WITHOUT-ABORTS ("A cleanup form is closing the stream ~S for ~A.~@
				  Aborting before the cleanup is complete could leave ~
				  the stream open indefinitely."
				 STREAM NAME)
	      (IGNORE-ERRORS
		(CL:CLOSE STREAM :ABORT T))))
	(SETQ STREAM NIL
	      1;; Set our status to reflect that we've aborted ...
0	      STATUS (IF INBOXES-BEING-INSERTED :LOADING :IDLE)))
      (WHEN (EQ SELF *SEQUENCE*)
	1;; Select a new current message if the old one was just killed above.
0	(COND ((ZEROP (SEQUENCE-NMSGS SELF))
	       1;; Empty sequence.
0	       (MUST-REDISPLAY *MSG-WINDOW* (ZMAIL-SELECT-MSG NIL T)))
	      ((AND (VARIABLE-BOUNDP *MSG*) *MSG* (NEQ (MSG-PARSED-P *MSG*) :KILLED))
	       1;; Old current message is still intact.
0	       (COMPUTE-CURRENT-MSG-NAME))
	      1;; If we fall into these clauses, there must be some newly read mail left after
	      ;; the backround load of the mail file proper was aborted.  Select the message
	      ;; closest to where the old messages would have been loaded ...
0	      ((SEQUENCE-APPEND-P SELF)
	       1;; ... new mail is appended -- pick the first message.
0	       (MUST-REDISPLAY *MSG-WINDOW* (ZMAIL-SELECT-MSG 0 T)))
	      (T
	       1;; ... new mail is prepended -- pick the last message.
0	       (MUST-REDISPLAY *MSG-WINDOW* (ZMAIL-SELECT-MSG (1- (SEQUENCE-NMSGS SELF)) T))))
	))))

(DEFWHOPPER (ABORT-LOADING-MAIL-FILE FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

;;; Reading new mail -- Top Level

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-GET-NEW-MAIL-FROM-INBOX
  "Read new mail:  Mouse-L: for current buffer;  Mouse-M: specify inbox for current buffer;  Mouse-R: specify the buffer by menu")

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-GET-NEW-MAIL-FROM-INBOX
				"Read new mail for a buffer from one or more inboxes.

Keyboard or Mouse-L:  Read new mail for the current buffer from its default inboxes.
Mouse-M:  Read new mail for the current buffer from any inbox you specify.
Mouse-R:  Read new mail for a buffer you select from a menu from its default inboxes."
				(NO-SEQUENCE-OK)
  (SET-ZMAIL-USER)
  (READ-NEW-MAIL-TOP-LEVEL))


(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-GMSGS
				"Run GMSGS for the default buffer."
				()
  (SET-ZMAIL-USER)
  (UNLESS *DEFAULT-BUFFER*
    (BARF "There is no default buffer."))
  (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					(.ERROR.)
       (BARF "~A" .ERROR.)
    (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
					       3;; KLUDGE until default set is complete:
0					       FS:FILE-ERROR SYS:NETWORK-ERROR)
      (CHECK-BUFFER-STATUS-FOR-READ-NEW-MAIL *DEFAULT-BUFFER*)
      (SELECT-SEQUENCE *DEFAULT-BUFFER*)
      (MULTIPLE-VALUE-BIND (GMSGS-INBOX-PATHNAME)
	  (RUN-GMSGS-FOR-BUFFER *DEFAULT-BUFFER*)
	(IF GMSGS-INBOX-PATHNAME
	    (READ-NEW-MAIL *DEFAULT-BUFFER* `(,GMSGS-INBOX-PATHNAME))
	  (TYPEIN-LINE "No new system messages for ~A." (SEQUENCE-NAME *DEFAULT-BUFFER*))
	  DIS-NONE)))))


;;; Top level internal interface used by several commands.
(DEFUN READ-NEW-MAIL-TOP-LEVEL ()
  (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					(.ERROR.)
       (BARF "~A" .ERROR.)
    (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
					       3;; KLUDGE until default set is complete:
0					       FS:FILE-ERROR SYS:NETWORK-ERROR)
      (MULTIPLE-VALUE-BIND (BUFFER DEFAULT-BUFFER-P ABORT-LOADING-IF-UNWOUND)
	  ;; Determine the "target" buffer.
	  (GET-BUFFER-FOR-READ-NEW-MAIL)
	(UNWIND-PROTECT-CASE ()
	    (BLOCK REST
	      (CHECK-BUFFER-STATUS-FOR-READ-NEW-MAIL BUFFER)
	      ;; Select the buffer before reading any new mail.
	      (SELECT-SEQUENCE BUFFER DEFAULT-BUFFER-P)
	      (MULTIPLE-VALUE-BIND (INBOX-PATHNAMES DEFAULT-INBOXES)
		  ;; Determine which inboxes should be read.
		  (GET-INBOXES-FOR-READ-NEW-MAIL BUFFER)
		;; Run GMSGS if necessary.
		(MULTIPLE-VALUE-BIND (GMSGS-INBOX-PATHNAME)
		    (RUN-GMSGS-FOR-BUFFER BUFFER :CONDITIONAL T :ERROR #'TYPEIN-LINE)
		  (WHEN GMSGS-INBOX-PATHNAME
		    (PUSH GMSGS-INBOX-PATHNAME INBOX-PATHNAMES)))
		;; Actually read the new mail.
		(WHEN DEFAULT-INBOXES
		  (QUEUE-MAIL-CHECK-REQUESTS BUFFER))
		(READ-NEW-MAIL BUFFER INBOX-PATHNAMES)))
	  (:ABORT
	    (WHEN (AND BUFFER ABORT-LOADING-IF-UNWOUND)
	      (ABORT-LOADING-MAIL-FILE BUFFER))))))))

;;; Determine the buffer to be used by a Get New Mail from Inbox command.
(DEFUN GET-BUFFER-FOR-READ-NEW-MAIL ()
  (DECLARE (VALUES . (BUFFER DEFAULT-BUFFER-P ABORT-LOADING-IF-UNWOUND)))
  (LET ((ABORT-LOADING-IF-UNWOUND NIL))
    (VALUES
      (COND ((EQ *ZMAIL-COMMAND-BUTTON* :RIGHT) (GET-SELECT-SEQUENCE T T))
	    (*SEQUENCE* (IF (SEQUENCE-BUFFER-P *SEQUENCE*) *SEQUENCE*
			  (BARF "Can't read new mail for ~A because it's not a mail file."
				(SEQUENCE-NAME *SEQUENCE*))))
	    (*DEFAULT-BUFFER*)
	    (T
	     ;; No current sequence or default buffer -- Use the default mail file.
	     (LET ((DEFAULT-FILE-NAME
		     (ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR)
				     "Retry looking for your default mail file.")
		       (ZMAIL-DEFAULT-FILE-NAME :HANDLE-ERRORS NIL))))
	       (WHEN (NULL DEFAULT-FILE-NAME)
		 ;; ... there's no default mail file -- offer to create first one.
		 (SETQ DEFAULT-FILE-NAME (FIRST (POSSIBLE-DEFAULT-MAIL-FILE-PATHNAMES
						  (FS:USER-HOMEDIR)))))
	       ;; ... Start loading the mail file.
	       (SETQ ABORT-LOADING-IF-UNWOUND T)
	       (LOAD-OR-CREATE-MAIL-FILE DEFAULT-FILE-NAME
					 :IF-DOES-NOT-EXIST :QUERY
					 :USE-BACKGROUND *COMPLETE-GET-INBOX-IN-BACKGROUND*
					 :DEFAULT-BUFFER T))))
      (AND (NULL *DEFAULT-BUFFER*) (NULL *SEQUENCE*))
      ABORT-LOADING-IF-UNWOUND)))
    
;;; Determine the inbox pathnames to be used by a Get New Mail from Inbox command.
(DEFUN GET-INBOXES-FOR-READ-NEW-MAIL (BUFFER)
  (DECLARE (VALUES . (INBOX-PATHNAMES DEFAULT-INBOXES)))
  (IF (AND (NEQ *ZMAIL-COMMAND-BUTTON* :MIDDLE)
	   (NOT (NULL (INBOX-PATHNAMES BUFFER))))
      (VALUES (INBOX-PATHNAMES BUFFER) T)
    (LOOP WITH DEFAULT-PATHNAME = (OR (FIRST (INBOX-PATHNAMES BUFFER))
				      (DEFAULT-INBOX-PATHNAME (MSG-BUFFER-PATHNAME BUFFER)
							      :FOR-DEFAULT T))
	  FOR INBOX-PATHNAME = (ACCEPT-DEFAULTED-PATHNAME (FORMAT NIL
								  "Read new mail for ~A from"
								  (SEQUENCE-NAME BUFFER))
							  DEFAULT-PATHNAME)
	  DO
      (COND ((EQ INBOX-PATHNAME (MSG-BUFFER-PATHNAME BUFFER))
	     (BEEP)
	     (TYPEOUT-LINE "You can't read new mail for ~A from itself." INBOX-PATHNAME))
	    ((NULL (NATIVE-INBOX-FORMAT INBOX-PATHNAME))
	     (BEEP)
	     (TYPEOUT-LINE "~A is not an acceptable inbox pathname." INBOX-PATHNAME))
	    (T
	     (RETURN (VALUES (LIST INBOX-PATHNAME) NIL)))))))

1;;; Verify that a mail file buffer is in the proper status to read new mail or to run0 GMSGS1 --
;;;    If the status is 2:loaded1 or 2:saved1, the buffer has just been loaded or saved in the
;;;    background but the background response indicating this hasn't been processed yet so
;;;    we'll do it ourselves.  If the status is 2:saving1, we've been asked to read new mail
;;;    while a background save is ongoing so we'll abort the save as we'll start a new one
;;;    after the new mail is read.
0(DEFUN CHECK-BUFFER-STATUS-FOR-READ-NEW-MAIL (BUFFER)
  (WITH-BACKGROUND-PROCESS-LOCKED
    (CL:CASE (MSG-BUFFER-STATUS BUFFER)
      ((:LOADED :SAVED)
       (COMPLETE-MAIL-FILE-IO BUFFER))
      (:SAVING
	(COMPLETE-MAIL-FILE-IO BUFFER :ABORT-SAVES T)))))


;;; Run GMSGS for the given mail file buffer --
;;;    GMSGS is a program implemented several systems which puts unseen systems messages
;;;    into an inbox suitable for reading by a mail reader like Zmail.  This function will,
;;;    if requested, determine whether GMSGS should even be run based on the mail file's
;;;    internal options and the user's profile.
(DEFUN RUN-GMSGS-FOR-BUFFER (BUFFER &KEY CONDITIONAL (STREAM STANDARD-OUTPUT) (ERROR #'BARF))
  (DECLARE (VALUES . (GMSGS-INBOX-PATHNAME)))
  (LET ((RUNNING NIL)
	(GMSGS-HOST NIL)
	(GMSGS-INBOX-PATHNAME NIL)
	(GMSGS-CONTACT NIL))
    (LABELS ((GMSGS-ERROR (FORMAT-STRING &REST FORMAT-ARGS)
	       (IF RUNNING
		   (CL:APPLY ERROR "Error while running GMSGS on ~A for ~A:~%~4T~~@?~"
			     GMSGS-HOST (SEQUENCE-NAME BUFFER) FORMAT-STRING FORMAT-ARGS)
		 (CL:APPLY ERROR "Unable to run GMSGS for ~A:~%~4T~~@?~"
			   (SEQUENCE-NAME BUFFER) FORMAT-STRING FORMAT-ARGS))
	       (RETURN-FROM RUN-GMSGS-FOR-BUFFER (VALUES NIL))))
      (WHEN (OR (NOT CONDITIONAL)
		;; Caller has asked us to check if it's OK to run GMSGS now ...
		(LET ((GMSGS-OPTION (OR (SEND BUFFER :GET :GMSGS-P)
					(WHEN (EQ BUFFER *DEFAULT-BUFFER*) *RUN-GMSGS-P*))))
		  (CL:CASE GMSGS-OPTION
		    (:YES T)
		    (:ONCE-ONLY (NOT (SEND BUFFER :GET :GMSGS-HAS-BEEN-RUN)))
		    (OTHERWISE NIL))))
	;; OK to to run GMSGS -- Determine the host and pathname of GMSGS's output file ...
	(CONDITION-CASE (.ERROR.)
	     (BLOCK DO-GMSGS
	       (LET ((GMSGS-HOST-OR-STRING (OR (SEND BUFFER :GET :GMSGS-HOST)
					       (SEND (MSG-BUFFER-PATHNAME BUFFER) :HOST))))
		 (IF (STRINGP GMSGS-HOST-OR-STRING)
		     (MULTIPLE-VALUE-BIND (HOST VALID)
			 (NET:PARSE-HOST GMSGS-HOST-OR-STRING T)
		       (IF VALID
			   (SETQ GMSGS-HOST HOST)
			 (ERROR 'GMSGS-FILE-ERROR "Unknown host ~A." GMSGS-HOST-OR-STRING)))
		   (SETQ GMSGS-HOST GMSGS-HOST-OR-STRING)))
	       (SETQ GMSGS-INBOX-PATHNAME (GMSGS-INBOX-PATHNAME (FS:USER-HOMEDIR GMSGS-HOST)))
	       (UNLESS GMSGS-INBOX-PATHNAME
		 (ERROR 'GMSGS-FILE-ERROR "No place to put the results of GMSGS on ~A."
			GMSGS-HOST))
	       (SETQ GMSGS-CONTACT (CL:CASE (SEND GMSGS-HOST :SYSTEM-TYPE)
				     (:ITS
				       (FORMAT NIL "GMSGS ~A;~A //G~A"
					       (FIRST (SEND GMSGS-INBOX-PATHNAME :DIRECTORY))
					       (SEND GMSGS-INBOX-PATHNAME :NAME)
					       *GMSGS-OTHER-SWITCHES*))
				     (:TOPS-20 "GMSGS //ZMAIL")
				     (OTHERWISE "GMSGS")))
	       ;; Setup is complete -- Now we can actually run GMSGS...
	       (SETQ RUNNING T)
	       (WITH-OPEN-STREAM (GMSGS-STREAM (CHAOS:OPEN-STREAM GMSGS-HOST
								  GMSGS-CONTACT
								  :DIRECTION :INPUT))
		 (STREAM-COPY-UNTIL-EOF GMSGS-STREAM STREAM)))
	   ((FS:FILE-ERROR SYS:NETWORK-ERROR ZMAIL-FILE-ERROR) (GMSGS-ERROR "~A" .ERROR.)))))
    (VALUES GMSGS-INBOX-PATHNAME)))

;;; Reading new mail -- Low Level Primitives

;;; An inbox file which has been or is being inserted into a buffer.
(CL:DEFSTRUCT (INSERTED-INBOX (:TYPE LIST) :CONC-NAME)
  PATHNAME
  (TRUENAME NIL)
  RENAME-WHEN-READ
  (FILE-ID NIL))

1;;; List of all files currently being inserted into this mail file buffer.
0(DEFMETHOD (ALL-INSERTED-FILES FILE-MAIL-BUFFER) ()
  (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
	APPEND (INBOX-BUFFER-INSERTED-FILES INBOX-BUFFER)))

1;;; List all files currently inserted or being inserted into this mail file buffer.
0(DEFMETHOD (ALL-INSERTED-INBOXES FILE-MAIL-BUFFER) ()
  (SI:ELIMINATE-DUPLICATES
    (APPEND INSERTED-INBOXES (ALL-INSERTED-FILES SELF))
    #'(LAMBDA (FILE-1 FILE-2)
	(EQ (INSERTED-INBOX-TRUENAME FILE-1) (INSERTED-INBOX-TRUENAME FILE-2)))))

;;; Return the inbox pathnames for a given mail file.
(DEFGENERIC INBOX-PATHNAMES (FILE-MAIL-BUFFER)
  (DECLARE (VALUES . (INBOX-PATHNAMES)))
  (:FUNCTION
    (MULTIPLE-VALUE-BIND (INBOX-PATHNAMES)
	(FUNCALL (FLAVOR:GENERIC INBOX-PATHNAMES) FILE-MAIL-BUFFER)
      ;; Reject any attempt to use the mail file as its own inbox...
      (LET ((OUR-GENERIC-PATHNAME
	      (SEND (MSG-BUFFER-PATHNAME FILE-MAIL-BUFFER) :GENERIC-PATHNAME)))
	(IF (LOOP FOR INBOX-PATHNAME IN INBOX-PATHNAMES
		  AS INBOX-GENERIC-PATHNAME = (SEND INBOX-PATHNAME :GENERIC-PATHNAME)
		  THEREIS (EQ OUR-GENERIC-PATHNAME INBOX-GENERIC-PATHNAME))
	    (BARF "~A is its own inbox." (SEQUENCE-NAME FILE-MAIL-BUFFER))
	  INBOX-PATHNAMES))))
  ;; The default method --
  ;;    Either the list of pathnames stored as the :MAIL mail file option or the default
  ;;    inbox pathname derived from the mail file's pathname.
  (:METHOD (FILE-MAIL-BUFFER)
    (OR (SEND SELF :GET :MAIL)
	(LET ((DEFAULT-INBOX-PATHNAME (DEFAULT-INBOX-PATHNAME PATHNAME)))
	  (IF DEFAULT-INBOX-PATHNAME (LIST DEFAULT-INBOX-PATHNAME))))))


1;;; Split out from the 2read-new-mail1 method to make the code easier to read ...
0(DEFUN-IN-FLAVOR (READ-THE-INBOXES FILE-MAIL-BUFFER) ()
  (LET (ERRING-INBOX-BUFFER)
    (CONDITION-BIND ((INBOX-REQUIRES-SAVE #'INBOX-REQUIRES-SAVE-HANDLER))
      (CATCH 'STOP-READING-NEW-MAIL
	(TAGBODY				1;Sigh...
0	  CONTINUE-READING-THE-INBOXES
	     (CATCH 'SAVE-AND-CONTINUE-READING-NEW-MAIL
	       (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
		     WHEN (EQ (MSG-BUFFER-STATUS INBOX-BUFFER) :IDLE)
		       DO (SETQ ERRING-INBOX-BUFFER INBOX-BUFFER)	1;In case of error.
0			  (CATCH-ERROR-RESTART-WITH-FORM ((ZMAIL-FILE-ERROR FS:FILE-ERROR
									    SYS:NETWORK-ERROR)
							  "Skip reading any more ~
							   new mail for ~A."
							  NAME)
			      (THROW 'STOP-READING-NEW-MAIL T)
			    (ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR)
					    "Retry reading ~A." (SEQUENCE-NAME INBOX-BUFFER))
			      (LOAD-INBOX INBOX-BUFFER)))
			  (INSERT-INBOX INBOX-BUFFER SELF))
	       (RETURN-FROM READ-THE-INBOXES T))
	  SAVE-AND-CONTINUE-READING-NEW-MAIL
	     1;; Control arrives here iff the user has chosen to save the mail file
	     ;; and then continue reading new mail --
0	     1;;    Insert what we can from this inbox.
0	     (INSERT-INBOX ERRING-INBOX-BUFFER SELF :FORCE T)
	     1;;    Finish loading, parsing, and inserting and then save.
0	     (COMPLETE-MAIL-FILE-IO SELF)
	     (SAVE-MAIL-FILE SELF :FORCE T)
	     1;;    Reset our state so that we can resume reading properly.
0	     (CL:SETF FIRST-MSG-FROM-INBOXES (IF (SEQUENCE-APPEND-P SELF)
						 (SEQUENCE-NMSGS SELF) 0)
		      TOTAL-MSGS-FROM-INBOXES 0
		      STATUS :READING-NEW-MAIL)
	     (GO CONTINUE-READING-THE-INBOXES)))
      1;; Control arrives here iff the user has chosen to stop reading new mail in mid-stream --
0      1;;    Insert what we can of the current inbox and leave it 2:parsing1 or 2:inserted1.
0      (INSERT-INBOX ERRING-INBOX-BUFFER SELF :FORCE T)
      1;;    Flush any pending inboxes which weren't inserted otherwise --
      ;;       If we parse inboxes in the background, when the parsing is finished, we
0      1;;       won't execute the 2finish-reading-new-mail1 method because all the pending
0      1;;       inboxes won't be 2:inserted1.0 1 If we don't parse inboxes in the background,
0      1;;       we'll try to 2finish-reading-new-mail1 now and it will fail because some
0      1;;       of the inboxes won't be 2:inserted1.
0      (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
	    UNLESS (MEMQ (MSG-BUFFER-STATUS INBOX-BUFFER) '(:PARSING :INSERTED))
	      DO (SETQ INBOXES-BEING-INSERTED (DELQ INBOX-BUFFER INBOXES-BEING-INSERTED))
		 (KILL-SEQUENCE INBOX-BUFFER :ABORT T))
      NIL)))

1;;; Handles the 2inbox-requires-save1 condition --
;;;    The 2*autosave-if-inbox-requires-save* 1profile option controls what action to take.
;;;    The default setting of this option causes us to ask the user what to do.
0(DEFUN INBOX-REQUIRES-SAVE-HANDLER (CONDITION)
  (LET ((SAVING-IS-OK (MEMQ :SAVE-AND-CONTINUE-READING-NEW-MAIL (DBG:PROCEED-TYPES CONDITION)))
	(BUFFER (INBOX-REQUIRES-SAVE-BUFFER CONDITION))
	(FIRST-INBOX (INBOX-REQUIRES-SAVE-FIRST-INBOX CONDITION)))
    (COND ((EQ *AUTOSAVE-IF-INBOX-REQUIRES-SAVE* :ASK)
	   1;; User wants us to ask whether it's OK to save the buffer ...
0	   (IF (AND SAVING-IS-OK
		    (TYPEOUT-BEEP-YES-OR-NO-P "The current contents of the mail file ~A~@
					       must be saved before reading~:[ any more~] ~
					       new mail.~@
					       ~2@TSave it now (without expunging it first)?  "
					      (SEQUENCE-NAME BUFFER) FIRST-INBOX))
	       1;; ... and he said it's OK to save.
0	       (SYS:PROCEED CONDITION :SAVE-AND-CONTINUE-READING-NEW-MAIL T)
	       1;; ... and he said it's not OK or this buffer can't be saved --
	       ;;    Stop reading new mail and print a warning if we didn't ask permission.
0	       (SYS:PROCEED CONDITION :STOP-READING-NEW-MAIL SAVING-IS-OK)))
	  (*AUTOSAVE-IF-INBOX-REQUIRES-SAVE*
	   1;; Automatically save the file ...
0	   (IF SAVING-IS-OK
	       1;; ... and it's an acceptable choice for this buffer.
0	       (SYS:PROCEED CONDITION :SAVE-AND-CONTINUE-READING-NEW-MAIL)
	       1;; ... but this buffer can't be saved.
0	       (SYS:PROCEED CONDITION :STOP-READING-NEW-MAIL)))
	  (T
	   1;; User wants to stop reading new mail.
0	   (SYS:PROCEED CONDITION :STOP-READING-NEW-MAIL)))))

1;;; Read new mail for a given buffer from the specified inboxes...
0(DEFMETHOD (READ-NEW-MAIL FILE-MAIL-BUFFER) (INBOX-PATHNAMES)
  (CL:ASSERT (MEMQ STATUS '(:IDLE :LOADING :READING-NEW-MAIL)) ()
	     "READ-NEW-MAIL invoked for buffer ~S while in state ~A." SELF STATUS)
  (CL:ASSERT (OR (NULL INBOXES-BEING-INSERTED) (NEQ STATUS :IDLE)) ()
	     "READ-NEW-MAIL invoked for buffer ~S although inboxes (~{~S~}) are being read."
	     SELF INBOXES-BEING-INSERTED)
  1;; Wait for the background process to go idle and then put it to rest --
  ;;    If the mail file is being loaded in the background, we don't want to allow any old
  ;;    mail to be loaded while we're reading new mail.  If we did allow this overlap, it's
  ;;    possible for old messages to be read which would cause new messages to be improperly
  ;;    parsed and/or not parsed at all.  3(Is this really true?  Shouldn't all the
0  1;;    3locking1 3and background sleeping prevent this???)
0  (WITH-BACKGROUND-PROCESS-LOCKED
    (LET ((WAS-PARSING-MSGS (FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF 'PARSE-OLD-MSGS)))
      (FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF 'PARSE-NEW-MSGS)
      (UNWIND-PROTECT-CASE ()
	  (LOCK-SEQUENCE (SELF :WRITE)
	    (WHEN (EQ STATUS :IDLE)
	      (SETQ STATUS :READING-NEW-MAIL))
	    (UNLESS INBOXES-BEING-INSERTED
	      1;; New mail wasn't being read before this invocation of 2read-new-mail1 --
	      ;;    Initialize the instance variables used to track where the new mail
	      ;;    actually is in the mail file buffer.
0	      (SETQ FIRST-MSG-FROM-INBOXES (IF (SEQUENCE-APPEND-P SELF) (SEQUENCE-NMSGS SELF) 0
					       )
		    TOTAL-MSGS-FROM-INBOXES 0))
	    1;; Update our list of pending inboxes to include those requested by our caller.
0	    (SETQ INBOXES-BEING-INSERTED
		  (APPEND INBOXES-BEING-INSERTED
			  (LOOP FOR INBOX-PATHNAME IN INBOX-PATHNAMES
				AS INBOX-FLAVOR = (NATIVE-INBOX-FORMAT INBOX-PATHNAME)
				COLLECT (MAKE-INSTANCE INBOX-FLAVOR :PARENT-BUFFER SELF
								    :PATHNAME INBOX-PATHNAME)))
		  )
	    1;; Now do the real work ...
0	    (LET ((SELECTED-MSG NIL)
		  (REDISPLAY-DEGREE DIS-NONE))
	      (LOCK-BUFFER-AND-INBOXES (SELF :WRITE)
		(READ-THE-INBOXES)		1;Bingo!
0		(WHEN WAS-PARSING-MSGS
		  1;; Requeue the request to parse old messages if it was flushed above --
		  ;;    If we've read new mail, the old messages may now be at a different
		  ;;    position in the buffer so we have to redo the request with the
		  ;;    appropriate new boundaries.
0		  (LET ((START (IF (SEQUENCE-APPEND-P SELF)
				   0 (+ FIRST-MSG-FROM-INBOXES TOTAL-MSGS-FROM-INBOXES)))
			(END (IF (SEQUENCE-APPEND-P SELF) FIRST-MSG-FROM-INBOXES NIL)))
		    (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-OLD-MSGS SELF :START START
									:END END)))
		(COND ((PLUSP TOTAL-MSGS-FROM-INBOXES)
		       1;; New mail was read --
0		       1;;    Select the first message read from an inbox.
0		       (SETQ SELECTED-MSG (AREF ARRAY FIRST-MSG-FROM-INBOXES))
		       (IF (EQ SELF *SEQUENCE*)
			   (SETQ REDISPLAY-DEGREE (ZMAIL-SELECT-MSG SELECTED-MSG))
			   (SETQ SAVED-CURRENT-MSG SELECTED-MSG))
		       1;;    Parse the new mail in an appropriate process ...
0		       (COND (*COMPLETE-GET-INBOX-IN-BACKGROUND*
			      1;; ... at our leisure in the background.
0			      (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-NEW-MSGS
							      SELF
							      :START FIRST-MSG-FROM-INBOXES
							      :END (+ FIRST-MSG-FROM-INBOXES
								      TOTAL-MSGS-FROM-INBOXES))
			      )
			     (T
			      1;; ... immediately in the foreground.
0			      (LABELS ((SET-RECENT-AND-INFORM-PARENT (IGNORE MSG)
					 (DECLARE (SYS:DOWNWARD-FUNCTION))
					 (UNLESS (CL:GETF (MSG-STATUS MSG) 'RECENT)
					   (SEND SELF :NEW-MSG MSG T)
					   (SETF (CL:GETF (MSG-STATUS MSG) 'RECENT) T))))
				(PARSE-MSGS SELF :START FIRST-MSG-FROM-INBOXES
						 :END (+ FIRST-MSG-FROM-INBOXES
							 TOTAL-MSGS-FROM-INBOXES)
						 :PROGRESS-NOTE (FORMAT NIL
									"Parsing new messages ~
									 in ~A."
									NAME)
						 1;; Get the parsing done as well as possible.
0						 :HANDLE-ERRORS :IGNORE
						 :POST-PARSING-FUNCTION
						   #'SET-RECENT-AND-INFORM-PARENT))
1			      ;; Run inbox hooks, sorting, etc. if the file is fully loaded.
0			      (NOTE-DONE-PARSING-NEW-MSGS SELF))))
		      (T
		       1;; No new mail was read --
		       ;;    Inform the user and select an appropriate message.
0		       (TYPEIN-LINE "No new mail for ~A." NAME)
		       (SETQ INBOXES-BEING-INSERTED NIL
			     FIRST-MSG-FROM-INBOXES NIL
			     TOTAL-MSGS-FROM-INBOXES NIL)
		       (WHEN (EQ STATUS :READING-NEW-MAIL)
			 (SETQ STATUS :IDLE))
		       (SETQ SELECTED-MSG (FIRST-OR-LAST-MSG SELF))
		       (WHEN *ALWAYS-JUMP-AFTER-GET-NEW-MAIL-FROM-INBOX*
			 (IF (EQ SELF *SEQUENCE*)
			     (SETQ REDISPLAY-DEGREE (ZMAIL-SELECT-MSG SELECTED-MSG T))
			     (SETQ SAVED-CURRENT-MSG SELECTED-MSG)))))
		REDISPLAY-DEGREE)))
	(:ABORT
	  (ABORT-READING-NEW-MAIL SELF)
	  (WHEN WAS-PARSING-MSGS
	    1;; Requeue the request to parse old messages if it was flushed above ...
0	    (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-OLD-MSGS SELF)))))))

1;;; Invoked by the background when all new messages for a mail file buffer have been parsed --
;;;    Mark all inboxes that were 2:parsing1 as 2:inserted1.
;;;    If all inboxes are now 2:inserted1, finish processing the new mail by running inbox
;;;       hooks, sorting, etc. but iff the mail file itself has been fully loaded.
0(DEFMETHOD (NOTE-DONE-PARSING-NEW-MSGS FILE-MAIL-BUFFER) ()
  (CL:ASSERT (MEMQ STATUS '(:LOADING :READING-NEW-MAIL)) ()
	     "NOTE-DONE-PARSING-NEW-MSGS invoked for buffer ~S  while in state ~A."
	     SELF STATUS)
  (LOCK-BUFFER-AND-INBOXES (SELF :WRITE)
    (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
	  WHEN (EQ (MSG-BUFFER-STATUS INBOX-BUFFER) :PARSING)
	    DO (SETF (MSG-BUFFER-STATUS INBOX-BUFFER) :INSERTED))
    (WHEN (AND (EQ STATUS :READING-NEW-MAIL)
	       (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
		     ALWAYS (EQ (MSG-BUFFER-STATUS INBOX-BUFFER) :INSERTED)))
      (FINISH-READING-NEW-MAIL SELF))))

(DEFINE-ZMAIL-GLOBAL *INSERT-INBOX-HOOKS* NIL)

1;;; Completed reading and parsing new mail for a buffer --
;;;    Run any inbox hooks, sort the buffer, and start a background save as appropriate.
0(DEFMETHOD (FINISH-READING-NEW-MAIL FILE-MAIL-BUFFER) (&KEY FORCE)
  (CL:ASSERT (EQ STATUS :READING-NEW-MAIL) ()
	     "FINISH-READING-NEW-MAIL invoked for buffer ~S while in state ~A." SELF STATUS)
  (LOCK-BUFFER-AND-INBOXES (SELF :WRITE)
    (TYPEIN-LINE-DURABLE "~D new message~:P read into ~A." TOTAL-MSGS-FROM-INBOXES NAME)
    1;; Flush the inbox buffers and update our list of inserted files.
0    (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
	  DO (FINISH-INSERTING-INBOX INBOX-BUFFER SELF :FORCE FORCE))
    1;; Run any inbox hooks.
0    (RUN-HOOKS *INSERT-INBOX-HOOKS* 'INSERT-INBOX-HOOK SELF ARRAY FIRST-MSG-FROM-INBOXES
	       (+ FIRST-MSG-FROM-INBOXES TOTAL-MSGS-FROM-INBOXES))
    1;; Sort the buffer if needed.
0    (LET ((SORT (SEND SELF :GET :SORT)))
      (WHEN SORT
	(SORT-SEQUENCE SELF SORT (SEQUENCE-APPEND-P SELF) T)))
    1;; Flush the hash table used by message parse compaction.
0    (WHEN PROPERTY-LIST-HASH-TABLE
      (SEND PROPERTY-LIST-HASH-TABLE :NEW-ARRAY 2000.))
    1;; Update our state.
0    (SETQ STATUS :IDLE
	  FIRST-MSG-FROM-INBOXES NIL
	  TOTAL-MSGS-FROM-INBOXES NIL))
  1;; Start the background save if appropriate.
0  (UNLESS FORCE
    (CATCH-ERROR-RESTART ((ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
			  "Skip background save of ~A file ~A."
			  (SEND SELF :FORMAT-NAME) NAME)
      (SAVE-MAIL-FILE SELF :USE-BACKGROUND T)))
  (WHEN (EQ SELF *SEQUENCE*)
    (COMPUTE-CURRENT-MSG-NAME)))

1;;; Abort reading new mail for a buffer --
;;;    Abort loading all of our inboxes and flush any messages which have been inserted but
;;;    not yet finished.  (See 2finish-reading-new-mail1 above.)  Due to the duration of the
;;;    2unwind-protect1s above, this method can be invoked while the buffer is 2:idle1 should the
;;;    user abort at an appropriate point.
0(DEFMETHOD (ABORT-READING-NEW-MAIL FILE-MAIL-BUFFER) ()
  (CL:ASSERT (MEMQ STATUS '(:KILLED :IDLE :LOADING :LOADED :READING-NEW-MAIL)) ()
	     "ABORT-READING-NEW-MAIL invoked for buffer ~S while in state ~A." SELF STATUS)
  (UNLESS (MEMQ STATUS '(:KILLED :IDLE))
    (LOCK-BUFFER-AND-INBOXES (SELF :WRITE)
      (WITH-BACKGROUND-PROCESS-LOCKED
	(FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF 'PARSE-NEW-MSGS))
      (LOOP FOR INBOX-BUFFER IN INBOXES-BEING-INSERTED
	    DO (ABORT-LOADING-INBOX INBOX-BUFFER))
      (WHEN (AND TOTAL-MSGS-FROM-INBOXES (NOT (ZEROP TOTAL-MSGS-FROM-INBOXES)))
	(SYS:WITHOUT-ABORTS ("Undoing incomplete reading of new mail into ~A.~@
		Aborting this could leave that sequence in an inconsistent state~@
		and leave half-killed messages that might cause problems later."
			     NAME)
	  (TV:NOTING-PROGRESS ((FORMAT NIL "Killing new messages in ~A." NAME))
	    (LOOP FOR I FROM FIRST-MSG-FROM-INBOXES REPEAT TOTAL-MSGS-FROM-INBOXES
		  UNLESS (NULL (AREF ARRAY I))
		    DO (KILL-MSG (AREF ARRAY I) T)
		       (SETF (AREF ARRAY I) NIL)
		       (TV:NOTE-PROGRESS (- I FIRST-MSG-FROM-INBOXES) TOTAL-MSGS-FROM-INBOXES)
		       ))
	  (WITHOUT-INTERRUPTS
	    (LET ((FIRST-MSG-AFTER-INBOXES (+ FIRST-MSG-FROM-INBOXES TOTAL-MSGS-FROM-INBOXES))
		  )
	      (WHEN (< FIRST-MSG-AFTER-INBOXES (SEQUENCE-NMSGS SELF))
		(LOOP FOR I FROM FIRST-MSG-AFTER-INBOXES BELOW (SEQUENCE-NMSGS SELF)
		      FOR J FROM FIRST-MSG-FROM-INBOXES
		      DO (SETF (AREF ARRAY J) (AREF ARRAY I)))))
	    (SETF (SEQUENCE-NMSGS SELF) (- (SEQUENCE-NMSGS SELF) TOTAL-MSGS-FROM-INBOXES))
	    (SETQ FIRST-MSG-FROM-INBOXES NIL
		  TOTAL-MSGS-FROM-INBOXES NIL))
	  (LET ((OLD-SELECTED-MSG (IF (EQ SELF *SEQUENCE*)
				      (WHEN (VARIABLE-BOUNDP *MSG*) *MSG*)
				    SAVED-CURRENT-MSG))
		(NEW-SELECTED-MSG :NO-SELECT))
	    1;; Select a new current message if the old one was just killed above.
0	    (COND ((ZEROP (SEQUENCE-NMSGS SELF))
		   1;; Empty sequence.
0		   (SETQ NEW-SELECTED-MSG NIL))
		  ((AND OLD-SELECTED-MSG (NEQ (MSG-PARSED-P OLD-SELECTED-MSG) :KILLED))
		   1;; Old current message is still intact.
0		   (SETQ NEW-SELECTED-MSG OLD-SELECTED-MSG))
		  (T
		   1;; Some old mail is left -- Select the message closest to where the new
		   ;; mail would have been inserted.
0		   (SETQ NEW-SELECTED-MSG (FIRST-OR-LAST-MSG SELF))))
	    (IF (EQ SELF *SEQUENCE*)
		(IF (EQ NEW-SELECTED-MSG OLD-SELECTED-MSG)
		    (COMPUTE-CURRENT-MSG-NAME)
		  (MUST-REDISPLAY *MSG-WINDOW* (ZMAIL-SELECT-MSG NEW-SELECTED-MSG T)))
	      (SETQ SAVED-CURRENT-MSG NEW-SELECTED-MSG)))))
      (SETQ INBOXES-BEING-INSERTED NIL
	    STATUS (IF (EQ STATUS :READING-NEW-MAIL) :IDLE STATUS)))))

(DEFUN RUN-HOOKS (HOOK-LIST HOOK-PROP &REST ARGUMENTS)
  (DOLIST (ACTION HOOK-LIST)
    (LET ((FUNCTION (GET ACTION HOOK-PROP)))
      (WHEN (NULL FUNCTION)
	(FERROR "Unknown inbox hook action: ~S" ACTION))
      (LEXPR-FUNCALL FUNCTION ARGUMENTS))))

;;; This does the delete over the whole sequence rather than just the new mail.
(DEFUN (:DELETE-DUPLICATES-ALL INSERT-INBOX-HOOK) (BUFFER &REST IGNORE)
  (DELETE-DUPLICATE-MSGS BUFFER))

;;; This on the other hand just does it for the new mail.
(DEFUN (:DELETE-DUPLICATES-NEW INSERT-INBOX-HOOK) (BUFFER ARRAY START END)
  (DELETE-DUPLICATE-MSGS-INTERNAL BUFFER ARRAY START END))

;;;+++ For compatibility (delete from here after a while)
(DEFUN (:DELETE-DUPLICATES INSERT-INBOX-HOOK) (BUFFER &REST IGNORE)
  ;; This does the delete over the whole sequence rather than just the new mail.
  (DELETE-DUPLICATE-MSGS BUFFER))

;;; Saving mail files -- Top Level

(DEFVAR-RESETTABLE *ZMAIL-SAVE-IN-PROGRESS* NIL)

(DEFVAR *ZMAIL-MULTIPLE-SAVE-IN-PROGRESS* NIL)

(DEFVAR *ZMAIL-QUIT-MENU-ALIST*
	'((("Don't Save" :VALUE :NOSAVE :DOCUMENTATION "Don't save out any files.")
	   ("Ask" :VALUE :ASK :DOCUMENTATION "Give a menu for saving of files.")
	   ("Save" :VALUE :SAVE :DOCUMENTATION "Save out all changed files."))
	  (("Quit" :VALUE :QUIT :DOCUMENTATION "Select calling window.")
	   ("Logout" :VALUE :LOGOUT :DOCUMENTATION "Logout when done writing."))))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-ZMAIL-QUIT
  "Save and exit:  L,M: save all; R: menu for Save mode // Logout.")

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-QUIT
				"Save and exit.
Expunge deleted messages, write out changes and exit.
Right gives menu of options."
				(DANGEROUS NO-SEQUENCE-OK)
  (LET ((SAVE-MODE :SAVE)
	(LOGOUT-MODE :QUIT))
    (COND ((EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
	   (MULTIPLE-VALUE (SAVE-MODE LOGOUT-MODE)
	     (DEFAULTED-MULTIPLE-MENU-CHOOSE-NEAR-MENU *ZMAIL-QUIT-MENU-ALIST*
						       SAVE-MODE LOGOUT-MODE)))
	  ((EQ *ZMAIL-COMMAND-BUTTON* :KBD)
	   (CHECK-IF-DANGEROUS-COMMAND-OK
	     "expunge and save all your mail files and then exit Zmail")))
    (SELECTQ SAVE-MODE
      (:NOSAVE)
      (:SAVE (ZMAIL-SAVE-ALL))
      (:ASK (ZMAIL-SAVE-MENU)))
    (SELECTQ LOGOUT-MODE
      (:QUIT)
      (:LOGOUT (LOGOUT))))
  (MUST-REDISPLAY *MSG-WINDOW* DIS-TEXT)
  (*THROW 'EXIT-TOP-LEVEL T))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-NOT-MODIFIED
				"Mark this mail file as not needing saving"
				(NO-MSG-OK)
  (UNMODIFY-SEQUENCE *SEQUENCE*)
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-ENABLE-SAVES-FOR-BUFFER
				"Enable subsequent saves for this mail file."
				(NO-MSG-OK)
  (LET ((SEQUENCE-NAME (SEQUENCE-NAME *SEQUENCE*)))
    (UNLESS (SEQUENCE-BUFFER-P *SEQUENCE*)
      (BARF "~A is not a mail file." SEQUENCE-NAME))
    (WHEN (SEND *SEQUENCE* :GET :DISABLE-SAVES)
      (SEND *SEQUENCE* :PUTPROP NIL :DISABLE-SAVES)
      (SETQ *ZMAIL-SEQUENCE-NAME* SEQUENCE-NAME)
      (REDISPLAY-MODE-LINE)
      (TYPEIN-LINE "Saves enabled for ~A." SEQUENCE-NAME)))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DISABLE-SAVES-FOR-BUFFER
				"Disable subsequent saves for this mail file."
				(NO-MSG-OK)
  (LET ((SEQUENCE-NAME (SEQUENCE-NAME *SEQUENCE*)))
    (UNLESS (SEQUENCE-BUFFER-P *SEQUENCE*)
      (BARF "~A is not a mail file." SEQUENCE-NAME))
    (UNLESS (SEND *SEQUENCE* :GET :DISABLE-SAVES)
      (SEND *SEQUENCE* :PUTPROP T :DISABLE-SAVES)
      (SETQ *ZMAIL-SEQUENCE-NAME* (STRING-APPEND SEQUENCE-NAME " (NoSaves)"))
      (REDISPLAY-MODE-LINE)
      (TYPEIN-LINE "Saves disabled for ~A." SEQUENCE-NAME)))
  DIS-NONE)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION COM-ZMAIL-SAVE-ALL-MAIL-FILES
"L: Expunge & write out all files; M: Expunge this; R: Expunge // Save // Kill menu.")

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SAVE-ALL-MAIL-FILES
				"Expunge and write out all files.
Right gives a menu for Expunge, Save or Kill for each file."
				(DANGEROUS NO-SEQUENCE-OK)
  (SELECTQ *ZMAIL-COMMAND-BUTTON*
    ((:KBD :LEFT)
     (WHEN (EQ *ZMAIL-COMMAND-BUTTON* :KBD)
       (CHECK-IF-DANGEROUS-COMMAND-OK "expunge and save all your mail files"))
     (ZMAIL-SAVE-ALL))
    (:MIDDLE
     (COM-ZMAIL-EXPUNGE))
    (:RIGHT
     (ZMAIL-SAVE-MENU)))
  DIS-TEXT)

1;;; For compatibility with old 0INIT1 files.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND-SYNONYM COM-ZMAIL-SAVE COM-ZMAIL-SAVE-ALL-MAIL-FILES)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-EXPUNGE-SEQUENCE
				"Expunge the current sequence."
				(DANGEROUS NO-MSG-OK)
  (COM-ZMAIL-EXPUNGE-SEQUENCE-INTERNAL *SEQUENCE*))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EXPUNGE-SEQUENCE
						  (SEQUENCE "Expunge sequence" *ZMAIL-COMTAB*)
						  (SEQUENCE)
  `(COM-ZMAIL-EXPUNGE-SEQUENCE-INTERNAL ,SEQUENCE))

1;;; For compatibility with old 0INIT1 files.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND-SYNONYM COM-ZMAIL-EXPUNGE COM-ZMAIL-EXPUNGE-SEQUENCE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SAVE-MAIL-FILE
				"Save the current mail file.
Without a numeric argument, expunges deleted messages from the current
  mail file buffer and writes the updated buffer to its mail file.
With a numeric argument, starts saving the current mail file in a background
  process.  Deleted messages are not expunged.  The Abort Background Save
  command can be used to stop the background save."
				(DANGEROUS NUMERIC-ARG-OK NO-MSG-OK)
  (COM-ZMAIL-SAVE-MAIL-FILE-INTERNAL *SEQUENCE* *NUMERIC-ARG-P*))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SAVE-MAIL-FILE
						  (MSG-BUFFER "Save mail file" *ZMAIL-COMTAB*)
						  (SEQUENCE)
  `(COM-ZMAIL-SAVE-MAIL-FILE-INTERNAL ,SEQUENCE NIL))

1;;; For compatibility with old 0INIT1 files.
0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SAVE-CURRENT-BUFFER
				"Save only the current buffer without expunging."
				(NO-MSG-OK)
  (COM-ZMAIL-SAVE-MAIL-FILE-INTERNAL *SEQUENCE* NIL NIL))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-START-BACKGROUND-SAVE
				"Save the current mail file in the background."
				(NO-MSG-OK)
  (COM-ZMAIL-SAVE-MAIL-FILE-INTERNAL *SEQUENCE* T))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-ABORT-BACKGROUND-SAVE
				"Abort an ongoing background save of the current mail file."
				(NO-MSG-OK)
  (LET ((SEQUENCE-NAME (SEQUENCE-NAME *SEQUENCE*)))
    (UNLESS (SEQUENCE-BUFFER-P *SEQUENCE*)
      (BARF "~A is not a mail file." SEQUENCE-NAME))
    (UNLESS (EQ (MSG-BUFFER-STATUS *SEQUENCE*) :SAVING)
      (BARF "There is no background save of ~A in progress." SEQUENCE-NAME))
    (COMPLETE-MAIL-FILE-IO *SEQUENCE* :ABORT-SAVES T)
    (TYPEIN-LINE "Background save of ~A aborted." SEQUENCE-NAME))
  DIS-NONE)

;;; Invoked from the Logout CP command.
(DEFUN ZMAIL-SAVE-ALL-FILES (&OPTIONAL (QUERY-P T) EXPUNGE-P FILES-TO-SAVE)
  (ZMAIL-SAVE-ALL-FILES-EXECUTE (ZMAIL-SAVE-ALL-FILES-QUERY QUERY-P EXPUNGE-P FILES-TO-SAVE)
				EXPUNGE-P))

(DEFUN ZMAIL-SAVE-ALL-FILES-QUERY (&OPTIONAL (QUERY-P T) EXPUNGE-P FILES-TO-SAVE)
  (SEND *ZMAIL-WINDOW* :SAVE-ALL-FILES-QUERY QUERY-P EXPUNGE-P FILES-TO-SAVE TERMINAL-IO))

(DEFUN ZMAIL-SAVE-ALL-FILES-EXECUTE (FILES-TO-SAVE EXPUNGE-P)
  (SEND *ZMAIL-WINDOW* :SAVE-ALL-FILES-EXECUTE FILES-TO-SAVE EXPUNGE-P TERMINAL-IO))


;;; Support functions for the above commands, etc.

;;; Expunge all collections and expunge and save all mail files --
;;;    All expunging is done before any saving to cause any questions that may be asked
;;;    to occur together chronologically.  We save the default buffer last as it's probably
;;;    the largest and will take longest.
(DEFUN ZMAIL-SAVE-ALL ()
  (LET-GLOBALLY ((*ZMAIL-MULTIPLE-SAVE-IN-PROGRESS* T)
		 (*ZMAIL-SAVE-IN-PROGRESS* T))
    (DOLIST (SEQUENCE *SEQUENCE-LIST*)
      (EXPUNGE-SEQUENCE SEQUENCE))
    (DOLIST (SEQUENCE *SEQUENCE-LIST*)
      (WHEN (SEQUENCE-BUFFER-P SEQUENCE)
	(UNLESS (EQ SEQUENCE *DEFAULT-BUFFER*)
	  (CATCH 'ZMAIL-MULTIPLE-SAVE		;Intercept individual save aborts
	    (SAVE-MAIL-FILE SEQUENCE)))))
    (UNLESS (NULL *DEFAULT-BUFFER*)
      (CATCH 'ZMAIL-MULTIPLE-SAVE		;Intercept individual save aborts 
	(SAVE-MAIL-FILE *DEFAULT-BUFFER*)))))

;;; Expunge and save all files on behalf of the Logout CP command.
(DEFMETHOD (:SAVE-ALL-FILES ZMAIL-FRAME) (QUERY-P EXPUNGE-P FILES-TO-SAVE CALLERS-TERMINAL-IO)
  (LET-GLOBALLY ((*ZMAIL-MULTIPLE-SAVE-IN-PROGRESS* T)
		 (*ZMAIL-SAVE-IN-PROGRESS* T))
    (SEND SELF :SAVE-ALL-FILES-EXECUTE
	  (SEND SELF :SAVE-ALL-FILES-QUERY QUERY-P EXPUNGE-P FILES-TO-SAVE CALLERS-TERMINAL-IO)
	  EXPUNGE-P CALLERS-TERMINAL-IO)))

(DEFMETHOD (:SAVE-ALL-FILES-QUERY ZMAIL-FRAME)
	   (QUERY-P EXPUNGE-P FILES-TO-SAVE CALLERS-TERMINAL-IO)
  (LETF ((FILES-TO-SAVE (OR FILES-TO-SAVE	;default to saving all buffers
			    (WHEN (VARIABLE-BOUNDP *SEQUENCE-LIST*) *SEQUENCE-LIST*)))
	 (*TYPEIN-WINDOW* CALLERS-TERMINAL-IO)
	 (*TYPEOUT-WINDOW* CALLERS-TERMINAL-IO))
    (LET-GLOBALLY ((*ZMAIL-MULTIPLE-SAVE-IN-PROGRESS* T)
		   (*ZMAIL-SAVE-IN-PROGRESS* T))
      (LOOP WITH BUFFERS-TO-SAVE = NIL
	    FOR BUFFER IN FILES-TO-SAVE
	    WHEN (AND (SEQUENCE-BUFFER-P BUFFER)
		      (MAIL-FILE-SAVE-P BUFFER)
		      (OR (NOT QUERY-P)
			  (FQUERY NIL "~:[S~;Expunge and s~]ave mail buffer ~A ? " EXPUNGE-P
				  (SEQUENCE-NAME BUFFER))))
	      DO (PUSH BUFFER BUFFERS-TO-SAVE)
	    FINALLY (RETURN (REVERSE BUFFERS-TO-SAVE))))))

(DEFMETHOD (:SAVE-ALL-FILES-EXECUTE ZMAIL-FRAME) (BUFFERS-TO-SAVE EXPUNGE-P
								  CALLERS-TERMINAL-IO)
  (LETF ((*TYPEIN-WINDOW* CALLERS-TERMINAL-IO)
	 (*TYPEOUT-WINDOW* CALLERS-TERMINAL-IO))
    (LET-GLOBALLY ((*ZMAIL-MULTIPLE-SAVE-IN-PROGRESS* T)
		   (*ZMAIL-SAVE-IN-PROGRESS* T))
      (DOLIST (BUFFER BUFFERS-TO-SAVE)
	(WHEN EXPUNGE-P
	  (EXPUNGE-SEQUENCE BUFFER))
	(CATCH 'ZMAIL-MULTIPLE-SAVE	     ; intercept individual save aborts
	  (SAVE-MAIL-FILE BUFFER))))))

;;; Determine what actions (expunging, unmodifying, saving, killing) to take based on a menu.
(DEFUN ZMAIL-SAVE-MENU ()
  (MULTIPLE-VALUE-BIND (BUFFERS-ALIST COLLECTIONS-ALIST IGNORE)
      (GET-SEQUENCE-ALISTS T)
    (LET* ((EXPUNGE-SAVE-MENU
	     `(,@(LOOP FOR (SEQUENCE-NAME . SEQUENCE) IN BUFFERS-ALIST
		       AS DISABLE-SAVES-P = (SEND SEQUENCE :GET :DISABLE-SAVES)
		       COLLECT
			 (MULTIPLE-VALUE-BIND (SAVE-P EXPUNGE-P)
			     (MAIL-FILE-SAVE-P SEQUENCE)
			   `(,SEQUENCE ,SEQUENCE-NAME
			     ((:EXPUNGE ,EXPUNGE-P)
			      ,@(UNLESS DISABLE-SAVES-P `((:SAVE ,(OR SAVE-P EXPUNGE-P))))
			      :KILL
			      ,@(UNLESS DISABLE-SAVES-P '(:UNMODIFY))))))
	       ,@(LOOP FOR (SEQUENCE-NAME . SEQUENCE) IN COLLECTIONS-ALIST
		       COLLECT
			 (MULTIPLE-VALUE-BIND (IGNORE EXPUNGE-P)
			     (MAIL-FILE-SAVE-P SEQUENCE)
			   `(,SEQUENCE ,SEQUENCE-NAME
			     ((:EXPUNGE ,EXPUNGE-P) :KILL))))))
	   (EXPUNGE-SAVE-CHOICES
	     (TV:MULTIPLE-CHOOSE "Mail files and collections:"
				 EXPUNGE-SAVE-MENU
				 '((:EXPUNGE "Expunge" NIL NIL NIL NIL)
				   (:UNMODIFY "UnModify" NIL NIL NIL NIL)
				   (:SAVE "Save" NIL (:UNMODIFY) NIL NIL)
				   (:KILL "Kill" NIL (:UNMODIFY) NIL NIL))
				 '(:MOUSE) 50.)))
      (LET-GLOBALLY ((*ZMAIL-MULTIPLE-SAVE-IN-PROGRESS* T)
		     (*ZMAIL-SAVE-IN-PROGRESS* T))
	(LOOP FOR (SEQUENCE . KEYWORDS) IN EXPUNGE-SAVE-CHOICES
	      WHEN (MEMQ :EXPUNGE KEYWORDS)
		UNLESS (AND (MEMQ :KILL KEYWORDS) (NOT (MEMQ :SAVE KEYWORDS)))
		  ;; No need to expunge if we're going to kill the file without saving it.
		  DO (EXPUNGE-SEQUENCE SEQUENCE)
	      WHEN (MEMQ :UNMODIFY KEYWORDS)
		DO (UNMODIFY-SEQUENCE SEQUENCE T)
	      WHEN (MEMQ :SAVE KEYWORDS)
		DO (CATCH 'ZMAIL-MULTIPLE-SAVE
		     (SAVE-MAIL-FILE SEQUENCE))
	      WHEN (MEMQ :KILL KEYWORDS)
		DO (KILL-SEQUENCE SEQUENCE))))))

(DEFUN COM-ZMAIL-EXPUNGE-SEQUENCE-INTERNAL (SEQUENCE)
  (LET ((*CURRENT-ZMAIL-TOP-LEVEL-COMMAND* 'COM-ZMAIL-EXPUNGE-SEQUENCE)
	(SEQUENCE-NAME (SEQUENCE-NAME SEQUENCE)))
    (COND ((NOT (SEQUENCE-BUFFER-P SEQUENCE))
	   (EXPUNGE-SEQUENCE SEQUENCE))
	  ((ZEROP (SEQUENCE-NMSGS SEQUENCE))
	   (BARF "There are no messages in ~A." SEQUENCE-NAME))
	  (T
	   (CHECK-IF-DANGEROUS-COMMAND-OK "permanently remove all deleted messages from ~
					  ~:[the mail file ~A~;this mail file~]"
					  (EQ SEQUENCE *SEQUENCE*) SEQUENCE-NAME)
	   (EXPUNGE-SEQUENCE SEQUENCE)))
    DIS-TEXT))

(DEFUN COM-ZMAIL-SAVE-MAIL-FILE-INTERNAL (SEQUENCE USE-BACKGROUND
					  &OPTIONAL (EXPUNGE (NOT USE-BACKGROUND)))
  (LET ((*CURRENT-ZMAIL-TOP-LEVEL-COMMAND* 'COM-ZMAIL-SAVE-MAIL-FILE)
	(SEQUENCE-NAME (SEQUENCE-NAME SEQUENCE)))
    (UNLESS (SEQUENCE-BUFFER-P SEQUENCE)
      (BARF "~A is not a mail file buffer." SEQUENCE-NAME))
    (WHEN (SEND SEQUENCE :GET :DISABLE-SAVES)
      (BARF "Saving is disabled for ~A." SEQUENCE-NAME))
    (WHEN EXPUNGE
      (CHECK-IF-DANGEROUS-COMMAND-OK "expunge and save ~:[the mail file ~A~;this mail file~]"
				     (EQ SEQUENCE *SEQUENCE*) SEQUENCE-NAME)
      (EXPUNGE-SEQUENCE SEQUENCE))
    1;; Must specify 2:force t1 when a background save is requested to insure that we'll
    ;; start the background save even though automatic background saving is inhibited.
0    (SAVE-MAIL-FILE SEQUENCE :USE-BACKGROUND USE-BACKGROUND :FORCE USE-BACKGROUND)
    DIS-NONE))

;;; Mark a mail file as not needing to be saved.
(DEFUN UNMODIFY-SEQUENCE (SEQUENCE &OPTIONAL SILENT-P)
  (WHEN (MAIL-FILE-SAVE-P SEQUENCE)		;Never true for collections.
    (LET ((NEW-TICK (TICK)))
      (CL:SETF (MSG-BUFFER-MSG-UPDATE-TICK SEQUENCE) NEW-TICK
	       (MSG-BUFFER-TICK SEQUENCE) NEW-TICK))
    (UNLESS SILENT-P
      (TYPEIN-LINE "Not modified."))))

;;; Abort saving a mail file --
;;;    If saving multiple files, proceed to the next; otherwise, abort the entire command.
(DEFUN ABORT-CURRENT-SAVE-COMMAND (&OPTIONAL FORMAT-STRING &REST FORMAT-ARGS)
  (WHEN FORMAT-STRING
    (BEEP)
    (CL:APPLY #'TYPEIN-LINE FORMAT-STRING FORMAT-ARGS))
  (IF *ZMAIL-MULTIPLE-SAVE-IN-PROGRESS*
      (THROW 'ZMAIL-MULTIPLE-SAVE T)
    (ABORT-CURRENT-COMMAND)))

1;;; Saving mail files -- Middle Level

;;; Does this mail file need to be saved? --
;;;   Update the "in-file" copy of all modified messages and mail file options
;;;   and then check to see if the modification ticks request a save.
;;;   3(Support for suppressing save on "soft" modifications will go here.)
0(DEFUN MAIL-FILE-SAVE-P (BUFFER &KEY INCOMPLETE-OK)
  (DECLARE (VALUES SAVE-P EXPUNGE-P))
  (CL:CHECK-TYPE BUFFER (OR FILE-MAIL-BUFFER COLLECTION) "a mail file buffer or a collection")
  (LET ((SEQUENCE-BUFFER-P (SEQUENCE-BUFFER-P BUFFER))
	SAVE-P
	EXPUNGE-P)
    (UNLESS (SEND BUFFER :GET :DISABLE-SAVES)
      (DO-UNIVERSE (MSG BUFFER
			:PARSING NIL
			:NOTE-PROGRESS (WHEN SEQUENCE-BUFFER-P
					 "Updating message attributes in ~A.")
			:NO-PREPARE INCOMPLETE-OK)
	(WHEN SEQUENCE-BUFFER-P
	  (UPDATE-MSG-OPTIONS-IN-FILE-IF-NECESSARY BUFFER MSG))
	(WHEN (NOT EXPUNGE-P)
	  (WHEN (CL:GETF (MSG-STATUS MSG) 'DELETED)
	    (SETQ EXPUNGE-P T))))
      (WHEN SEQUENCE-BUFFER-P
	(SETF (MSG-BUFFER-MSG-UPDATE-TICK BUFFER) (TICK))
	1;; This may require that the file be saved out.
0	(UPDATE-OPTIONS-IN-FILE BUFFER)
	(WHEN (OR 1;; Never saved.
0		  (EQ (MSG-BUFFER-ID BUFFER) T)
		  1;; Hard modified.
0		  (> (SEQUENCE-SAVE-REQUIRING-MODIFICATION-TICK BUFFER) (MSG-BUFFER-TICK
									  BUFFER))
		  1;; Soft modified.
0		  (> (SEQUENCE-MODIFICATION-TICK BUFFER) (MSG-BUFFER-TICK BUFFER))
		  1;; Inboxes eligible for deletion --
		  ;;    Save may not happen depending on results of expunging but
		  ;;    we want to delete the inboxes no matter what happens.
0		  (AND (TYPEP BUFFER 'FILE-MAIL-BUFFER)
		       (NOT (NULL (FILE-MAIL-BUFFER-INSERTED-INBOXES BUFFER)))))
	  (SETQ SAVE-P T))))
    (VALUES SAVE-P EXPUNGE-P)))

1;;; Save a mail file.
0(DEFUN SAVE-MAIL-FILE (BUFFER &KEY FORCE USE-BACKGROUND)
  (CL:CHECK-TYPE BUFFER FILE-MAIL-BUFFER "a mail file buffer")
  1;; Don't do anything if background saves are inhibited and we aren't being forced...
0  (UNLESS (AND USE-BACKGROUND (NOT FORCE) *INHIBIT-BACKGROUND-SAVES*)
    (COMPLETE-MAIL-FILE-IO BUFFER :ABORT-SAVES T)	1;Can't save unless completely loaded.
0    (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					  (.ERROR.)
	 (ABORT-CURRENT-SAVE-COMMAND "~A" .ERROR.)
      (LET-GLOBALLY ((*ZMAIL-SAVE-IN-PROGRESS* T))
	(COND ((OR (AND FORCE (NOT (SEND BUFFER :GET :DISABLE-SAVES)))
		   (MAIL-FILE-SAVE-P BUFFER))
	       (WHEN FORCE
		 1;; When forced, be sure that all message attributes are up to date.
0		 (MAIL-FILE-SAVE-P BUFFER))
	       (LET ((OWNER (SEND BUFFER :GET :OWNER)))
		 (WHEN (AND OWNER (NOT (STRING-EQUAL OWNER USER-ID)))
		   (UNLESS (TYPEOUT-BEEP-YES-OR-NO-P "~&The mail file ~A is owned by ~A.~@
						      ~2TSave it anyway? "
						     (SEQUENCE-NAME BUFFER) OWNER)
		     (ABORT-CURRENT-SAVE-COMMAND))))
	       (LET* ((PATHNAME (MSG-BUFFER-PATHNAME BUFFER))
		      (BUFFER-ID (MSG-BUFFER-ID BUFFER))
		      (FILE-ID (FILE-INFO-FOR-SAVE BUFFER PATHNAME)))
		 (UNLESS (EQUAL BUFFER-ID FILE-ID)
		   (UNLESS (IF (LISTP BUFFER-ID)
			       (TYPEOUT-BEEP-YES-OR-NO-P
				 "~&Since you last read or wrote ~A~% (~A),~@
			          ~:[it has been deleted.  Save it anew?~;~
				     a new version has appeared on the file computer~% (~A).~@
				     ~%Do you want to ~
				     ~:[overwrite~;create a newer version of~] it?~] "
				 PATHNAME (DESCRIBE-FILE-INFO BUFFER-ID)
				 (LISTP FILE-ID)
				 (IF (LISTP FILE-ID) (DESCRIBE-FILE-INFO FILE-ID))
				 (EQ (SEND PATHNAME :VERSION) :NEWEST))
			     (TYPEOUT-BEEP-YES-OR-NO-P
			       "~&A file named ~A already exists~% (~A).~@
			        ~%Do you want to ~
				~:[overwrite~;create a newer version of~] it? "
			       PATHNAME (DESCRIBE-FILE-INFO FILE-ID)
			       (EQ (SEND PATHNAME :VERSION) :NEWEST)))
		     (ABORT-CURRENT-SAVE-COMMAND))))
	       (SAVE-MAIL-FILE-INTERNAL BUFFER :USE-BACKGROUND USE-BACKGROUND))
	      ((SEND BUFFER :GET :DISABLE-SAVES)
	       (UNLESS *ZMAIL-MULTIPLE-SAVE-IN-PROGRESS*	1;Complain if explicit save.
0		 (TYPEIN-LINE "Saving is disabled for ~A." (SEQUENCE-NAME BUFFER))))
	      (T
	       (TYPEIN-LINE "No changes need to be written in ~A." (SEQUENCE-NAME BUFFER))))))
    )
  DIS-NONE)

1;;; Simple probe but first we establish the appropriate restart handlers for save I/O.
0(DEFUN FILE-INFO-FOR-SAVE (BUFFER PATHNAME)
  (LET ((NAME (SEQUENCE-NAME BUFFER))
	(FORMAT-NAME (SEND BUFFER :FORMAT-NAME)))
    (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
					       3;; KLUDGE until default set is complete:
0					       FS:FILE-ERROR SYS:NETWORK-ERROR)
      (CATCH-ERROR-RESTART-IF-WITH-FORM *ZMAIL-MULTIPLE-SAVE-IN-PROGRESS*
					((ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					 "Skip saving ~A file ~A." FORMAT-NAME NAME)
	   (ABORT-CURRENT-SAVE-COMMAND)
	(ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR)
			"Retry saving ~A file ~A." FORMAT-NAME NAME)
	  (LET ((PROBE
		  (OPEN PATHNAME :DIRECTION :PROBE :IF-DOES-NOT-EXIST NIL)))
	    (IF PROBE (SEND PROBE :INFO) T)))))))

;;; Mail File Saving State --
;;;    This structure is created as a local variable in SAVE-MAIL-FILE-INTERNAL
;;;    and is then passed to all methods involved in saving the mail file except
;;;    FINISH-SAVING-MAIL-FILE and ABORT-SAVING-MAIL-FILE as it's not possible to
;;;    guarentee that the structure will be available due to timing problems
;;;    with the background process.
;;;
;;;    The FORMAT-SLOT slot is reserved for use by any format specific saving methods.
(CL:DEFSTRUCT (MAIL-FILE-SAVING-STATE (:TYPE LIST) (:CONC-NAME "MFSS-"))
  (CURRENT-MSG NIL)
  FORMAT-SLOT)

;;; Construct any format specific state information required to save the mail file --
;;;    This information is saved in the FORMAT-SLOT slot of a MAIL-FILE-SAVING-STATE
;;;    structure which is created as alocal variable of SAVE-MAIL-FILE-INTERNAL.
;;;    The structure is passed to all methods involved in saving the mail file.
;;;    Said functions should use this object to pass information needed to properly
;;;    save the mail file.
(DEFGENERIC MAIL-FILE-SAVING-STATE (FILE-MAIL-BUFFER)
  ;; The default method -- Use an interval stream.
  ;;    The default SAVE-MSG method expects the saving state FORMAT-SLOT to be an
  ;;    interval stream for its proper operation.  Use of an interval stream as the
  ;;    saving state FORMAT-SLOT is normally correct for any format which stores its
  ;;    messages as text.  (I.e., all supported formats except KBIN.)
  (:METHOD (FILE-MAIL-BUFFER)
    (OPEN-INTERVAL-STREAM HEADER-INTERVAL)))

;;; For COMPLETE-MAIL-FILE-IO and the SAVE-MAIL-FILE-MSGS-ERROR background response...
(DEFUN SAVE-MAIL-FILE-INTERNAL (BUFFER &KEY USE-BACKGROUND ALREADY-OPEN OLD-MFSS (START 0))
  (LET ((NAME (SEQUENCE-NAME BUFFER))
	(FORMAT-NAME (SEND BUFFER :FORMAT-NAME)))
    (LOCK-SEQUENCE (BUFFER :WRITE)
      (LET ((MFSS (OR OLD-MFSS			;Might be supplied by COMPLETE-MAIL-FILE-IO.
		      (MAKE-MAIL-FILE-SAVING-STATE :FORMAT-SLOT (MAIL-FILE-SAVING-STATE
								  BUFFER)))))
	(DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
						   3;; KLUDGE until default set complete:
0						   FS:FILE-ERROR SYS:NETWORK-ERROR)
	  (CATCH-ERROR-RESTART-IF-WITH-FORM *ZMAIL-MULTIPLE-SAVE-IN-PROGRESS*
					    ((ZMAIL-FILE-ERROR FS:FILE-ERROR
							       SYS:NETWORK-ERROR)
					     "Skip saving ~A file ~A." FORMAT-NAME NAME)
	       (ABORT-CURRENT-SAVE-COMMAND)
	    (ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR)
			    "Retry saving ~A file ~A." FORMAT-NAME NAME)
	      (ERROR-RESTART-WITH-FORM (BAD-MSG-CHARACTER-TYPE-MAPPINGS
					 "Fix the message and retry saving ~A file ~A."
					 FORMAT-NAME NAME)
		   (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS (MFSS-CURRENT-MSG MFSS))
		(UNWIND-PROTECT-CASE ()
		    (MULTIPLE-VALUE-BIND (MUST-WRITE-MSGS)
			(IF ALREADY-OPEN T
			  (START-SAVING-MAIL-FILE BUFFER MFSS))
		      (WHEN MUST-WRITE-MSGS
			(SAVE-MAIL-FILE-MSGS BUFFER MFSS START
					     :USE-BACKGROUND USE-BACKGROUND))
		      (WHEN (EQ (MSG-BUFFER-STATUS BUFFER) :SAVED)
			(FINISH-SAVING-MAIL-FILE BUFFER
						 (IF MUST-WRITE-MSGS :SAVED :NO-CHANGES))))
		  (:ABORT
		    (ABORT-SAVING-MAIL-FILE BUFFER)))))))))))

;;; Saving mail files -- Low Level Primitives
  
;;; Start saving a mail file --
;;;    Open the mail file for output and write its header (if any).
(DEFMETHOD (START-SAVING-MAIL-FILE FILE-MAIL-BUFFER) (MAIL-FILE-SAVING-STATE)
  (DECLARE (VALUES . (MUST-WRITE-MSGS)))
  (IGNORE MAIL-FILE-SAVING-STATE)		;We don't need it ourselves.
  (CL:ASSERT (EQ STATUS :IDLE) ()
	     "START-SAVING-MAIL-FILE invoked for buffer ~S while in state ~A." SELF STATUS)
  (COND ((AND ( MODIFICATION-TICK TICK) ( SAVE-REQUIRING-MODIFICATION-TICK TICK))
	 ;; No actual changes in the contents of the mail file --
	 ;;    We won't write anything.  However, we'll go to the :SAVED state so that
	 ;;    FINISH-SAVING-MAIL-FILE will be invoked to delete any pending inboxes and
	 ;;    inform the user as to what happened.
	 (SETQ STATUS :SAVED)
	 (VALUES NIL))
	(T
	 ;; Mail file really has been changed.
	 (SETQ STATUS :SAVING)
	 (OPEN-MAIL-FILE SELF :DIRECTION :OUTPUT)
	 (SAVE-MAIL-FILE-HEADER SELF MAIL-FILE-SAVING-STATE)
	 (VALUES T))))

(DEFWHOPPER (START-SAVING-MAIL-FILE FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

;;; Save the mail file's header into the file on the file computer.
(DEFGENERIC SAVE-MAIL-FILE-HEADER (FILE-MAIL-BUFFER MAIL-FILE-SAVING-STATE)
  ;; The default method -- This method works for any format which stores its header
  ;; information in text form.  (I.e., all supported formats except KBIN.)
  ;; 2This method expects (MFSS-FORMAT-SLOT MAIL-FILE-SAVING-STATE) to be an interval stream.
0  (:METHOD (FILE-MAIL-BUFFER)
    (CL:CHECK-TYPE (MFSS-FORMAT-SLOT MAIL-FILE-SAVING-STATE) INTERVAL-STREAM
		   "an interval stream")
    (SEND (MFSS-FORMAT-SLOT MAIL-FILE-SAVING-STATE) :SET-INTERVAL HEADER-INTERVAL)
    (STREAM-COPY-UNTIL-EOF (MFSS-FORMAT-SLOT MAIL-FILE-SAVING-STATE) STREAM)))

;;; Write all messages from a buffer into the corresponding mail file --
;;;   The START argument should be 0 unless called on behalf of COMPLETE-MAIL-FILE-IO.
(DEFMETHOD (SAVE-MAIL-FILE-MSGS FILE-MAIL-BUFFER) (MAIL-FILE-SAVING-STATE START
						   &KEY USE-BACKGROUND)
  (CL:ASSERT (EQ STATUS :SAVING) ()
	     "SAVE-MAIL-FILE-MSGS invoked for buffer ~S while in state ~A." SELF STATUS)
  (IF USE-BACKGROUND
      (QUEUE-ZMAIL-BACKGROUND-REQUEST SAVE-MAIL-FILE-MSGS
				      SELF MAIL-FILE-SAVING-STATE :START START)
    (TV:NOTING-PROGRESS ((FORMAT NIL "Saving ~A file ~A." (SEND SELF :FORMAT-NAME) NAME))
      (DO ((NMSGS (SEQUENCE-NMSGS SELF))
	   (I START (1+ I)))
	  (( I NMSGS)
	   (SETQ STATUS :SAVED))
	(SETF (MFSS-CURRENT-MSG MAIL-FILE-SAVING-STATE) (AREF ARRAY I))
	(SAVE-MSG SELF (MFSS-CURRENT-MSG MAIL-FILE-SAVING-STATE) MAIL-FILE-SAVING-STATE)
	(TV:NOTE-PROGRESS I NMSGS)))))

;;; Background request which writes all messages from a buffer into the mail file.
(DEFINE-ZMAIL-BACKGROUND-REQUEST SAVE-MAIL-FILE-MSGS (MFSS
						      &KEY (START 0)
						      &AUX NEXT-MSG PROGRESS-NOTE)
     (:USES-SEQUENCE T
      :INIT-FORM
        (LET ((PROCESS				;May be created in the background?
		(IF (EQ *ZMAIL-BACKGROUND-P* T) CURRENT-PROCESS *ZMAIL-BACKGROUND-PROCESS*)))
	  (SETF (FS:FILE-DATA-STREAM-PROCESS (MSG-BUFFER-STREAM SEQUENCE)) PROCESS)
	  (SETQ NEXT-MSG START))
      :FLUSH-FORM
        (LET ((STREAM (MSG-BUFFER-STREAM SEQUENCE)))
	  (WHEN STREAM
	    (SETF (FS:FILE-DATA-STREAM-PROCESS STREAM) CURRENT-PROCESS))
	  (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE))
      :PRINT-FORMAT "~@[ from ~D~]" :PRINT-FORMAT-ARGS (NEXT-MSG))
  ;; Don't create the progress note until we actually start executing the request.
  (UNLESS PROGRESS-NOTE
    (SETQ PROGRESS-NOTE (TV:ADD-PROGRESS-NOTE (FORMAT NIL "Saving ~A file ~A."
						      (SEND SEQUENCE :FORMAT-NAME)
						      (SEQUENCE-NAME SEQUENCE)))))
  (TRAP-BACKGROUND-ERRORS (ERROR "Unable to save ~A file ~A"
				 (SEND SEQUENCE :FORMAT-NAME) (SEQUENCE-NAME SEQUENCE))
			  ()
       (BLOCK SAVE-MAIL-FILE-MSGS-HARD-FAILURE
	 (QUEUE-ZMAIL-BACKGROUND-RESPONSE SAVE-MAIL-FILE-MSGS-ERROR SEQUENCE MFSS :FATAL T)
	 (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	 (ZMAIL-BACKGROUND-REQUEST-COMPLETE))
    (TRAP-BACKGROUND-ERRORS ((ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR) "")
			    (:SUPPRESS-NOTIFICATION T :ERROR-OBJECT .ERROR.)
	 (BLOCK SAVE-MAIL-FILE-MSGS-SOFT-FAILURE
	   (QUEUE-ZMAIL-BACKGROUND-RESPONSE SAVE-MAIL-FILE-MSGS-ERROR SEQUENCE MFSS
					    :ERROR .ERROR.)
	   (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	   (ZMAIL-BACKGROUND-REQUEST-COMPLETE))
      (LOCK-SEQUENCE (SEQUENCE :READ)
	(DO ((ARRAY (SEQUENCE-ARRAY SEQUENCE))
	     (NMSGS (SEQUENCE-NMSGS SEQUENCE))
	     (I NEXT-MSG (1+ I))
	     (WRITTEN-THIS-PASS 0 (1+ WRITTEN-THIS-PASS)))
	    ((OR (STOP-ZMAIL-BACKGROUND-FOR-FOREGROUND-P)
		 ( I NMSGS) ( WRITTEN-THIS-PASS *BACKGROUND-SAVE-QUANTUM*))
	     (SETQ NEXT-MSG I)
	     (IF (< I NMSGS)
		 (ZMAIL-BACKGROUND-REQUEST-INCOMPLETE)
	       (QUEUE-ZMAIL-BACKGROUND-RESPONSE SAVE-MAIL-FILE-MSGS-COMPLETED SEQUENCE)
	       (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	       (ZMAIL-BACKGROUND-REQUEST-COMPLETE)))
	  (SETF (MFSS-CURRENT-MSG MFSS) (AREF ARRAY I))
	  (SAVE-MSG SEQUENCE (MFSS-CURRENT-MSG MFSS) MFSS)
	  (TV:NOTE-PROGRESS I NMSGS PROGRESS-NOTE))))))

1;;; Foreground processing when a mail file has finished saving in the background.
0(DEFINE-ZMAIL-BACKGROUND-RESPONSE SAVE-MAIL-FILE-MSGS-COMPLETED ()
     (:USES-SEQUENCE T)
  (WHEN (EQ (MSG-BUFFER-STATUS SEQUENCE) :SAVING)
    1;; Don't bother if it was already finished to benefit an overanxious user...
0    (LOCK-SEQUENCE (SEQUENCE :WRITE)
      (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					    (.ERROR.)
	   (BARF "~A" .ERROR.)
	(LET ((NAME (SEQUENCE-NAME SEQUENCE))
	      (FORMAT-NAME (SEND SEQUENCE :FORMAT-NAME)))
	  (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-FILE-ERROR
						     3;; KLUDGE until default set complete:
0						     FS:FILE-ERROR SYS:NETWORK-ERROR)
	    (CATCH-ERROR-RESTART ((ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
				  "Abort saving ~A file ~A." FORMAT-NAME NAME)
	      (CATCH-ERROR-RESTART-WITH-FORM ((ZMAIL-FILE-ERROR FS:FILE-ERROR
								SYS:NETWORK-ERROR)
					      "Retry saving ~A file ~A in the foreground."
					      FORMAT-NAME NAME)
		  (SAVE-MAIL-FILE-INTERNAL SEQUENCE)
		(CATCH-ERROR-RESTART-WITH-FORM ((ZMAIL-FILE-ERROR FS:FILE-ERROR
								  SYS:NETWORK-ERROR)
						"Retry saving ~A file ~A in the background."
						FORMAT-NAME NAME)
		    (SAVE-MAIL-FILE-INTERNAL SEQUENCE :USE-BACKGROUND T)
		  (UNWIND-PROTECT-CASE ()
		      (PROGN
			(SETF (MSG-BUFFER-STATUS SEQUENCE) :SAVED)
			(FINISH-SAVING-MAIL-FILE SEQUENCE :SAVED))
		    (:ABORT
		      (ABORT-SAVING-MAIL-FILE SEQUENCE))))))))))))

;;; Foreground processing when an error occurs while saving a mail file in the background --
;;;    If the error isn't fatal, give the user a change to retry saving.
(DEFINE-ZMAIL-BACKGROUND-RESPONSE SAVE-MAIL-FILE-MSGS-ERROR (MFSS
							     &KEY FATAL ERROR)
     (:USES-SEQUENCE T)
  (WHEN (EQ (MSG-BUFFER-STATUS SEQUENCE) :SAVING)
    ;; Don't bother if it was already finished/aborted to benefit an overanxious user...
    (IF (OR FATAL (NULL ERROR))			;Can't offer to retry if no error indication.
	(ABORT-SAVING-MAIL-FILE SEQUENCE)
      (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					    (.ERROR.)
	   (BARF "~A" .ERROR.)
	(LET ((NAME (SEQUENCE-NAME SEQUENCE))
	      (FORMAT-NAME (SEND SEQUENCE :FORMAT-NAME))
	      (CHARACTER-TYPE-MAPPING-ERROR (TYPEP ERROR 'BAD-MSG-CHARACTER-TYPE-MAPPINGS)))
	  (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (ZMAIL-BACKGROUND-FILE-ERROR)
	    (CATCH-ERROR-RESTART (ZMAIL-BACKGROUND-FILE-ERROR
				   "Abort saving ~A file ~A." FORMAT-NAME NAME)
	      (CATCH-ERROR-RESTART-IF-WITH-FORM (NOT CHARACTER-TYPE-MAPPING-ERROR)
						(ZMAIL-BACKGROUND-FILE-ERROR
						  "Retry saving ~A file ~A in the foreground."
						  FORMAT-NAME NAME)
		   (SAVE-MAIL-FILE-INTERNAL SEQUENCE)
		(CATCH-ERROR-RESTART-IF-WITH-FORM (NOT CHARACTER-TYPE-MAPPING-ERROR)
		       (ZMAIL-BACKGROUND-FILE-ERROR
			 "Retry saving ~A file ~A in the background."
			 FORMAT-NAME NAME)
		     (SAVE-MAIL-FILE-INTERNAL SEQUENCE :USE-BACKGROUND T)
		  (CATCH-ERROR-RESTART-IF-WITH-FORM CHARACTER-TYPE-MAPPING-ERROR
			 (ZMAIL-BACKGROUND-FILE-ERROR
			   "Fix the message and retry saving ~A file ~A in the background."
			   FORMAT-NAME NAME)
		       (BLOCK FIX-AND-RETRY
			 (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS (MFSS-CURRENT-MSG MFSS))
			 (SAVE-MAIL-FILE-INTERNAL SEQUENCE :USE-BACKGROUND T))
		    (UNWIND-PROTECT-CASE ()
			(ERROR 'ZMAIL-BACKGROUND-FILE-ERROR :ERROR ERROR :FORMAT-STRING "")
		      (:ABORT
			(ABORT-SAVING-MAIL-FILE SEQUENCE)))))))))))))

;;; Finish saving a mail file --
;;;    Close the mail file stream and delete any inboxes that were inserted.
(DEFMETHOD (FINISH-SAVING-MAIL-FILE FILE-MAIL-BUFFER) (DISPOSITION)
  (CL:ASSERT (EQ STATUS :SAVED) ()
	     "FINISH-SAVING-MAIL-FILE invoked for buffer ~S while in state ~A." SELF STATUS)
  (IF (NULL STREAM)
      (CL:ECASE DISPOSITION
	(:SAVED					;Shouldn't really be possible, but ...
	  (TYPEIN-LINE "Written: ~A" NAME))
	(:NO-CHANGES
	  (TYPEIN-LINE "No changes need to be written in ~A." NAME)))
    (CL:CLOSE STREAM)
    (CL:ECASE DISPOSITION
      (:SAVED
	(TYPEIN-LINE "Written: ~A" (SEND STREAM :TRUENAME)))
      (:NO-CHANGES				;Shouldn't really be possible, but ...
	(TYPEIN-LINE "No changes need to be written in ~A." NAME)))
    (SETQ ID (SEND STREAM :INFO)
	  STREAM NIL))
  (WHEN INSERTED-INBOXES
    (LOOP FOR REST-OF-INBOXES ON INSERTED-INBOXES
	  AS INBOX = (FIRST REST-OF-INBOXES)
	  WHEN INBOX
	    DO (CONDITION-CASE ()
		    (CL:DELETE-FILE (INSERTED-INBOX-TRUENAME INBOX))
		  (FS:FILE-NOT-FOUND NIL))	;It's OK if the inbox was already deleted.
	       (SETF (FIRST REST-OF-INBOXES) NIL)	;Avoid duplicate deletions.
	    AND COUNT T INTO N-INBOXES-DELETED
	  FINALLY
	    (WHEN (PLUSP N-INBOXES-DELETED)
	      (TYPEIN-LINE-MORE "  (~[~1;One inbox~:;~:*~D inboxes~] deleted.)"
				N-INBOXES-DELETED)))
    (SETQ INSERTED-INBOXES NIL))
  ;; Update our status, etc.
  (SETQ TICK (TICK)
	STATUS :IDLE))

(DEFWHOPPER (FINISH-SAVING-MAIL-FILE FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-BUFFER-AND-INBOXES (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

1;;; Abort saving a mail file --
;;;    Due to the duration of the 2unwind-protect1s above, this method can be invoked while
;;;    the buffer is 2:idle1 should the user abort at an appropriate point.
0(DEFMETHOD (ABORT-SAVING-MAIL-FILE FILE-MAIL-BUFFER) ()
  (CL:ASSERT (MEMQ STATUS '(:KILLED :IDLE :SAVING :SAVED)) ()
	     "ABORT-SAVING-MAIL-FILE invoked for buffer ~S while in state ~A." SELF STATUS)
  (WHEN (MEMQ STATUS '(:SAVING :SAVED))
    1;; Don't do anything if we weren't actually saving or if we've been killed.
0    (WITH-BACKGROUND-PROCESS-LOCKED
      (FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF 'SAVE-MAIL-FILE-MSGS))
    (UNWIND-PROTECT
	(WHEN STREAM
	  (SYS:WITHOUT-ABORTS ("A cleanup form is closing the stream ~S for ~A.~@
			        Aborting before the cleanup is complete could leave ~
				the stream open indefinitely."
			       STREAM NAME)
	    (IGNORE-ERRORS
	      (CL:CLOSE STREAM :ABORT T))))
      (SETQ STREAM NIL
	    STATUS :IDLE))))

(DEFWHOPPER (ABORT-SAVING-MAIL-FILE FILE-MAIL-BUFFER) (&REST ARGS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

;;; Message reading
  
1;;; Read the next message from a file into its buffer --
;;;    This generic function reads a message from the stream attached to the file
;;;    corresponding to this buffer and inserts said message into the buffer.  A non-2nil
1;;;    return value indicates that there may be more messages to be read from the file.
;;;
;;;    The actual methods which underly this generic function return two values -- the
;;;    message just read and the indicator described above.  This generic then inserts the
;;;    message using the 2insert-msg1 generic function defined below.
;;;
;;;    This generic function is defined as a NOOP for non 2msg-buffer1 sequences as several
;;;    parts of 0Zmail1 call this generic unconditionally.  (When the offending functions are
;;;    fixed, this generic should be redefined only for 2msg-buffer1 sequences.)
0(DEFGENERIC READ-NEXT-MSG (SEQUENCE)
  (DECLARE (ARGLIST . (MSG-BUFFER))
	   (VALUES . (MORE-MSGS-AVAILABLE)))
  (:FUNCTION
    (CL:ETYPECASE SEQUENCE
      (MSG-BUFFER
	(LOCK-SEQUENCE (SEQUENCE :WRITE)
	  (IF (EQ (MSG-BUFFER-STATUS SEQUENCE) :LOADING)
	      (MULTIPLE-VALUE-BIND (MSG MORE-MSGS-AVAILABLE)
		  (FUNCALL (FLAVOR:GENERIC READ-NEXT-MSG) SEQUENCE)
		(WHEN MSG
		  (INSERT-MSG SEQUENCE MSG))
		(VALUES MORE-MSGS-AVAILABLE))
	      (VALUES NIL))))
      (SEQUENCE
	(VALUES NIL)))))
     
;;; Default message reading method -- This method works for any text-based formats
;;;    which store multiple messages per file.  (I.e., all supported formats except
;;;    KBIN and DIRECTORY-MAIL.)
;;;
;;;    Each format must implement the LINE-END-OF-MSG-P method.  This method is called
;;;    with four arguments -- the current line (LINE), its length (LENGTH), a format-specific
;;;    state cell (STATE), which will be NIL for the first line of the message, and the
;;;    end-of-file indicator (EOF).  The method must return three values:
;;;
;;;       END-IDX indicates whether the current line ends the currrent message --
;;;          If NIL, this line is part of the current message.
;;;          If T, this line is both part of the current message and is the last line of
;;;             the message.
;;;          If numeric, it indicates that this line contains the end of this message and,
;;;             possibly, the start of the next.  The first END-IDX characters of the current
;;;             line are included in the current message; NEW-LINE must be set appropriately.
;;;          If :START-NEXT, the current line is the first line of the next message and the
;;;             current message is completed.
;;;
;;;       STATE is the updated value of the format-specific state and is passed to the next
;;;          invocation of the LINE-END-OF-MSG-P method.
;;;
;;;       NEW-LINE is the value to be used as the first line of the next message when a
;;;          line both ends one message and starts the next.  This value should only be
;;;          non-NIL when END-IDX is numeric.
;;;
(DEFMETHOD (READ-NEXT-MSG MSG-BUFFER) ()
  (DECLARE (VALUES . (MSG MORE-MSGS-AVAILABLE)))
  (LOOP WITH FILE-TICK = (OR TICK *TICK*)
	WITH MSG = NIL
	WITH STATE = NIL
	WITH EOF = NIL
	WITH (END-IDX INSERT-LINE NEW-LINE)
	FOR LINE = (SEND SELF :GET 'NEXT-MSG-START-LINE) THEN NIL
	UNLESS LINE
	  DO ;; Read the next line if there isn't one from the last message.
	    (LET ((DEFAULT-CONS-AREA *ZMAIL-MSG-LINE-AREA*))
	      (MULTIPLE-VALUE (LINE EOF)
		(SEND STREAM :LINE-IN LINE-LEADER-SIZE)))
	WHEN (AND EOF (OR (NULL LINE) (ZEROP (LINE-LENGTH LINE))) (NULL MSG))
	  RETURN (VALUES NIL NIL)
	AS LENGTH = (LINE-LENGTH LINE)
	WHEN (AND (NULL MSG)
		  (NOT (LOOP FOR I FROM 0 BELOW LENGTH
			     ALWAYS (MEM #'CHAR-EQUAL (AREF LINE I) '(#\SP #\TAB)))))
	  DO ;; If this has real text, make a message to save it in.
	    (CL:SETF MSG (MAKE-EMPTY-MSG :TICK FILE-TICK :FATTENED-P NIL)
		     (MSG-BUFFER MSG) SELF
		     INSERT-LINE (BP-LINE (MSG-REAL-END-BP MSG)))
	DO ;; See if this line ends the message.
	  (MULTIPLE-VALUE (END-IDX STATE NEW-LINE)
	    (LINE-END-OF-MSG-P SELF LINE LENGTH STATE EOF))
	WHEN (AND MSG (COND ((NULL END-IDX) T)
			    ((EQ END-IDX 'T) T)
			    ((NOT (NUMBERP END-IDX)) NIL)
			    ((PLUSP END-IDX)
			     (SETF (LINE-LENGTH LINE) END-IDX)
			     T)
			    (T NIL)))
	  DO ;; If any or all of the line is to be saved, insert it.
	    (INSERT-LINE-WITH-LEADER LINE INSERT-LINE)
	WHEN END-IDX
	  DO ;; End of the message
	    (COND (EOF				;... and the file also.
		   (SEND SELF :REMPROP 'NEXT-MSG-START-LINE))
		  ((EQ END-IDX :START-NEXT)	;... but this line starts the next message.
		   (SEND SELF :PUTPROP LINE 'NEXT-MSG-START-LINE))
		  (T				;... but we might have start of next message.
		   (SEND SELF :PUTPROP NEW-LINE 'NEXT-MSG-START-LINE)))
	    (RETURN-FROM READ-NEXT-MSG (VALUES MSG (NOT EOF)))))


;;; Insert a freshly read message into its buffer --
;;;    This generic function is called directly by the READ-NEXT-MSG generic function, above.
;;;    Like READ-NEXT-MSG, this generic is defined as a NOOP for non MSG-BUFFER sequences.
(DEFGENERIC INSERT-MSG (SEQUENCE MSG)
  (DECLARE (ARGLIST . (MSG-BUFFER MSG)))
  (:FUNCTION
    (CL:ETYPECASE SEQUENCE
      (MSG-BUFFER
	(FUNCALL (FLAVOR:GENERIC INSERT-MSG) SEQUENCE MSG)
	(SETF (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) (1- *REFERENCE-MODIFICATION-TICK*)
	      ))
      (SEQUENCE
	NIL)))
  ;; The default method simply adds the message to the end of the buffer ...
  (:METHOD (MSG-BUFFER)
    (ARRAY-PUSH-EXTEND ARRAY MSG)))

1;;; Insert a freshly read message into a mail file -- Allow for messages inserted by inboxes.
0(DEFMETHOD (INSERT-MSG FILE-MAIL-BUFFER) (MSG)
  (COND ((AND FIRST-MSG-FROM-INBOXES (PLUSP TOTAL-MSGS-FROM-INBOXES) (SEQUENCE-APPEND-P SELF))
	 1;; Inbox messages are present and they are appended to the mail file --
	 ;;    We must insert the new message before the first inbox message.
0	 1;;    If a background request to parse the inbox messages has already been queued,
0	 1;;    we must requeue it with updated 2:start1 and 2:end1 arguments to ensure that all
	 ;;    inbox messages are parsed properly and that none of the old messages are
	 ;;    accidently parsed as inbox messages.
0	 (LET ((NMSGS (SEQUENCE-NMSGS SELF)))
	   (WITHOUT-INTERRUPTS
	     (WHEN (= (ARRAY-LENGTH ARRAY) NMSGS)
	       (ADJUST-ARRAY-SIZE ARRAY (FLOOR (* 5\4 (1+ NMSGS)))))
	     (LOOP FOR I FROM (1- NMSGS) DOWNTO FIRST-MSG-FROM-INBOXES
		   FOR J DOWNFROM NMSGS
		   DO (SETF (AREF ARRAY J) (AREF ARRAY I)))
	     (SETF (AREF ARRAY FIRST-MSG-FROM-INBOXES) MSG)
	     (INCF FIRST-MSG-FROM-INBOXES)
	     (INCF (SEQUENCE-NMSGS SELF))))
	 (LET ((OLD-PARSE-NEW-MSGS-REQUESTS (FLUSH-ZMAIL-BACKGROUND-REQUESTS SELF
									     'PARSE-NEW-MSGS)))
	   (CL:ASSERT (OR (NULL OLD-PARSE-NEW-MSGS-REQUESTS) (NEQ *ZMAIL-BACKGROUND-P* T)) ()
		      "INSERT-MSG invoked in background for buffer ~S ~
		       while PARSE-NEW-MSGS requests (~S) are still pending."
		      SELF OLD-PARSE-NEW-MSGS-REQUESTS)
	   (LOOP FOR REQUEST IN OLD-PARSE-NEW-MSGS-REQUESTS
		 AS START = (ZMAIL-PARSE-NEW-MSGS-BACKGROUND-REQUEST-START REQUEST)
		 AS END = (ZMAIL-PARSE-NEW-MSGS-BACKGROUND-REQUEST-END REQUEST)
		 DO (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-NEW-MSGS SELF :START (1+ START)
									:END (1+ END))))
	 (LET ((NEW-MSG-NO (1- FIRST-MSG-FROM-INBOXES)))
	   (IF (EQ *ZMAIL-BACKGROUND-P* T)
	       (NOTIFY-ZMAIL-OF-MSG-INSERTION *FOREGROUND-WINDOW* SELF NEW-MSG-NO)
	       (UPDATE-CURRENT-MSG-STATE-AFTER-MSG-INSERTION SELF NEW-MSG-NO))))
	(T
	 1;; Either no inbox messages or the inbox messages are prepended to the mail file --
	 ;;    We can simply append the new message to the end of the mail file.
0	 (ARRAY-PUSH-EXTEND ARRAY MSG))))

;;; Update *MSG-NO* to reflect that a new message has been inserted at the specified
;;; position in the given sequence --
;;;    If said sequence is the current sequence, we must increment *MSG-NO* if it refers
;;;    to a message past the one just inserted.  Otherwise, the next/previous commands will
;;;    fail to operate properly.
(DEFUN UPDATE-CURRENT-MSG-STATE-AFTER-MSG-INSERTION (SEQUENCE NEW-MSG-NO
						     &OPTIONAL (N-MSGS-INSERTED 1))
  (WHEN (EQ SEQUENCE *SEQUENCE*)
    (WHEN ( *MSG-NO* NEW-MSG-NO)
      (INCF *MSG-NO* N-MSGS-INSERTED)
      (UNLESS (MINUSP *MSG-NO*)
	(COMPUTE-CURRENT-MSG-NAME)))))

;;; Invoke the above function from outside the Zmail process (i.e., the from the background).
(DEFMETHOD (NOTIFY-ZMAIL-OF-MSG-INSERTION BASIC-ZMAIL) (SEQUENCE NEW-MSG-NO
							&OPTIONAL (N-MSGS-INSERTED 1))
  (UPDATE-CURRENT-MSG-STATE-AFTER-MSG-INSERTION SEQUENCE NEW-MSG-NO N-MSGS-INSERTED))

;;; Message writing

;;; Update the message so that its present attribute set will be saved in the mail file.
(DEFGENERIC UPDATE-MSG-OPTIONS-IN-FILE (FILE-MAIL-BUFFER MSG)
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    (IGNORE MSG)))				;Don't do anything special.

;;; Update the message attributes only if the message has changed in some way
(DEFGENERIC UPDATE-MSG-OPTIONS-IN-FILE-IF-NECESSARY (FILE-MAIL-BUFFER MSG)
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    (WHEN (> (MAX (MSG-TICK MSG) (NODE-TICK (MSG-INTERVAL MSG))) MSG-UPDATE-TICK)
      (UPDATE-MSG-OPTIONS-IN-FILE SELF MSG))))

;;; Determine if the RECENT attribute of messages is saved in a mail file.
(DEFGENERIC RECENT-IS-MSG-OPTION-IN-FILE-P (FILE-MAIL-BUFFER)
  ;; The default method ...
  (:METHOD (FILE-MAIL-BUFFER)
    NIL))					;... No

1;;; Save a message into the mail file on the file computer.
0(DEFGENERIC SAVE-MSG (FILE-MAIL-BUFFER MSG MAIL-FILE-SAVING-STATE)
1  ;; Default method --
0  1;;    This method works for any format which stores multiple messages per file in text form.
0  1;;    (I.e., all supported formats except KBIN and DIRECTORY-MAIL.)
0  (:METHOD (FILE-MAIL-BUFFER)
    (MSG-BUFFER-SAVE-MSG-TEXT MSG STREAM (MFSS-FORMAT-SLOT MAIL-FILE-SAVING-STATE))))

1;;; Save a message in text form.
0(DEFUN MSG-BUFFER-SAVE-MSG-TEXT (MSG FILE-STREAM INTERVAL-STREAM)
  (IGNORE INTERVAL-STREAM)
  (USING-RESOURCE (DUMPER SI:EPSILON-ENCODING-OUTPUT-STREAM NIL
							    :FLAVOR 'ZMAIL-MSG-SAVING-STREAM)
    (MULTIPLE-VALUE-BIND (MSG-NEEDS-ENCODING)
	(PREPARE-MSG-SAVING-STREAM-FOR-MSG DUMPER FILE-STREAM MSG)
      1;; Write the message --
0      1;;    Be sure to properly handle the header if the message is being encoded.
0      (FLET ((SAVE-INTERVAL (INTERVAL-ID START-BP &OPTIONAL END-BP IN-ORDER-P)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (IF (AND MSG-NEEDS-ENCODING (EQ INTERVAL-ID :HEADER))
		   (ENCODE-MSG-HEADER-INTERVAL DUMPER START-BP END-BP IN-ORDER-P)
		 (WITH-INTERVAL-STREAM (STREAM START-BP END-BP IN-ORDER-P)
		   (STREAM-COPY-UNTIL-EOF STREAM DUMPER)))))
	(MAP-OVER-MSG-INTERVALS MSG #'SAVE-INTERVAL :INCLUDE-WRAPPER T
						    :USE-ORIGINAL-HEADER T)))
    (SEND DUMPER :FORCE-OUTPUT)))

1;;; Message parsing and reformatting

;;; Parse a related group of messages in a buffer --
;;;    Options are provided to parse only a small fraction of the group per call, to control
;;;    the effect of parse errors, and to perform special actions after parsing a message.
0(DEFUN PARSE-MSGS (BUFFER &KEY (START 0) END PROGRESS-NOTE REAL-START QUANTUM
			       (HANDLE-ERRORS :SIGNAL) (STOP-PARSING-PREDICATE #'FALSE)
			       POST-PARSING-FUNCTION
			  &AUX ADDED-PROGRESS-NOTE)
  (DECLARE (ARGLIST . (BUFFER &KEY (START 0) END
				   (PROGRESS-NOTE
				     (FORMAT NIL "Parsing messages in ~A." BUFFER))
				   (REAL-START START)
				   (QUANTUM (- (SEQUENCE-NMSGS BUFFER) REAL-START))
				   (HANDLE-ERRORS :SIGNAL)
				   (STOP-PARSING-PREDICATE
				     #'(LAMBDA (BUFFER INDEX) NIL))
				   (POST-PARSING-FUNCTION
				     #'(LAMBDA (BUFFER MSG) (SEND BUFFER :XREF-MSG MSG)))))
	   (VALUES . (PARSING-COMPLETED LAST-PARSED N-ACTUALLY-PARSED))
	   (SYS:DOWNWARD-FUNARG *))
  (CL:CHECK-TYPE PROGRESS-NOTE (CL:OR NULL STRING TV:PROGRESS-NOTE) "a progress note or NIL")
  (CL:CHECK-TYPE HANDLE-ERRORS (CL:MEMBER :SIGNAL :IGNORE))
  1;; Provide default settings for missing keywords.
0  (UNLESS END
    (SETQ END (SEQUENCE-NMSGS BUFFER)))
  (UNLESS PROGRESS-NOTE
    (SETQ PROGRESS-NOTE (FORMAT NIL "Parsing messages in ~A." BUFFER)))
  (UNLESS REAL-START
    (SETQ REAL-START START))
  (UNLESS QUANTUM
    (SETQ QUANTUM (- (SEQUENCE-NMSGS BUFFER) REAL-START)))
  (UNLESS POST-PARSING-FUNCTION
    (SETQ POST-PARSING-FUNCTION #'(LAMBDA (BUFFER MSG) (SEND BUFFER :XREF-MSG MSG))))
  1;; Now do the actual work.
0  (UNWIND-PROTECT
      (BLOCK DO-IT
	(UNLESS (TYPEP PROGRESS-NOTE 'TV:PROGRESS-NOTE)
	  (SETQ PROGRESS-NOTE (TV:ADD-PROGRESS-NOTE PROGRESS-NOTE)
		ADDED-PROGRESS-NOTE T))
	(LOCK-SEQUENCE (BUFFER :READ)
	  (PARSING-HOSTS
	    (DO ((INDEX REAL-START (1+ INDEX))
		 (N-ACTUALLY-PARSED 0))
		1;; On extremely rare occasions, the background parse requests will invoke
0		1;; this function with a 2:real-start1 value that is past the end of the
0		1;; sequence.  Therefore, we use 21 rather than 2=1 in our end tests.
0		((OR (= INDEX END)		1;Parsed all the messages.
0		     (FUNCALL STOP-PARSING-PREDICATE BUFFER INDEX)	1;Caller's termination.
0		     ( N-ACTUALLY-PARSED QUANTUM))	1;Parsed our quantum for this pass.
0		 (VALUES (= INDEX END) (1- INDEX) N-ACTUALLY-PARSED))
	      (LET ((MSG (AREF (SEQUENCE-ARRAY BUFFER) INDEX)))
		(LET-IF (EQ HANDLE-ERRORS :IGNORE)
			((*BACKGROUND-ERRORS-INVOKE-DEBUGGER* T))
		  (CONDITION-CASE-IF (EQ HANDLE-ERRORS :IGNORE) ()
		       (TRAP-BACKGROUND-ERRORS ((ERROR)
						"Error parsing message #~D in ~A; ~
						 parsing continues with the next message"
						(1+ INDEX) (SEQUENCE-NAME BUFFER))
					       ()
			    ()			;Nothing special if an error occurs.
			 (UNLESS (NULL MSG)
			   (WHEN (OR (NULL (MSG-PARSED-P MSG))
				     (TYPEP (MSG-PARSED-P MSG) 'MSG-BUFFER))
			     (ASSURE-MSG-PARSED MSG)
			     (INCF N-ACTUALLY-PARSED))
			   (FUNCALL POST-PARSING-FUNCTION BUFFER MSG)))
		     (ERROR NIL)))
		(TV:NOTE-PROGRESS (- INDEX START) (- END START) PROGRESS-NOTE))))))
    (WHEN ADDED-PROGRESS-NOTE
      (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE))))

;;; Background request that parses a mail file's old messages.
(DEFINE-ZMAIL-BACKGROUND-REQUEST PARSE-OLD-MSGS (&KEY (START 0) END
						      &AUX LAST-PARSED PROGRESS-NOTE)
     (:USES-SEQUENCE T
      :INIT-FORM
        (BLOCK INITIALIZE
	  (SEND SEQUENCE :CREATE-REFERENCE-HASH-TABLE)	;Setup reference hash for background.
	  (SETF (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) 0)
	  (SETQ LAST-PARSED (1- START)))	;Must initialize by hand for 1+
      :FLUSH-FORM
        (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
      :PRINT-FORMAT "~:[from ~D ~;~*~]~@[below ~D ~]~:[~;~D done~]"
      :PRINT-FORMAT-ARGS ((ZEROP START) START END (PLUSP (1+ LAST-PARSED)) (1+ LAST-PARSED)))
  ;; Don't create the progress note until we actually start executing the request.
  (UNLESS PROGRESS-NOTE
    (SETQ PROGRESS-NOTE (TV:ADD-PROGRESS-NOTE (FORMAT NIL "Parsing messages in ~A."
						      (SEQUENCE-NAME SEQUENCE)))))
  (IF (EQ (MSG-BUFFER-STATUS SEQUENCE) :KILLED)
      (BLOCK SEQUENCE-KILLED
	(TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	(ZMAIL-BACKGROUND-REQUEST-COMPLETE))
    (LABELS ((STOP-FOR-FOREGROUND-COMMAND (IGNORE IGNORE)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (STOP-ZMAIL-BACKGROUND-FOR-FOREGROUND-P)))
      (MULTIPLE-VALUE-BIND (FINISHED NEW-LAST-PARSED IGNORE)
	  (PARSE-MSGS SEQUENCE :START START
			       :END END
			       :PROGRESS-NOTE PROGRESS-NOTE
			       :REAL-START (1+ LAST-PARSED)
			       :QUANTUM *BACKGROUND-PARSE-QUANTUM*
			       :STOP-PARSING-PREDICATE #'STOP-FOR-FOREGROUND-COMMAND)
	(SETQ LAST-PARSED NEW-LAST-PARSED)
	(IF (NOT FINISHED)
	    (ZMAIL-BACKGROUND-REQUEST-INCOMPLETE)
	  (WHEN ( (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) 0)
	    (SETF (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) (TICK)))
	  (LET ((HASH-TABLE (MSG-BUFFER-PROPERTY-LIST-HASH-TABLE SEQUENCE)))
	    (WHEN HASH-TABLE
	      (SEND HASH-TABLE :NEW-ARRAY 2000.)))
	  (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	  (ZMAIL-BACKGROUND-REQUEST-COMPLETE))))))

1;;; Background request that parses the new messages inserted into a mail file from an inbox.
0(DEFINE-ZMAIL-BACKGROUND-REQUEST PARSE-NEW-MSGS (&KEY (START 0) END
						      &AUX LAST-PARSED PROGRESS-NOTE)
     (:USES-SEQUENCE T
      :INIT-FORM
        (BLOCK INITIALIZE
	  (SEND SEQUENCE :CREATE-REFERENCE-HASH-TABLE)	1;Setup reference hash for background.
0	  (SETF (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) 0)
	  (SETQ LAST-PARSED (1- START)))	1;Must initialize by hand for 1+.
0      :FLUSH-FORM
        (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
      :PRINT-FORMAT "~:[ from ~D~;~*~]~@[ below ~D~]~:[~; ~D done~]"
      :PRINT-FORMAT-ARGS ((ZEROP START) START END (PLUSP (1+ LAST-PARSED)) (1+ LAST-PARSED)))
1  ;; Don't create the progress note until we actually start executing the request.
0  (UNLESS PROGRESS-NOTE
    (SETQ PROGRESS-NOTE (TV:ADD-PROGRESS-NOTE (FORMAT NIL "Parsing new messages in ~A."
						      (SEQUENCE-NAME SEQUENCE)))))
  (IF (EQ (MSG-BUFFER-STATUS SEQUENCE) :KILLED)
      (BLOCK SEQUENCE-KILLED
	(TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	(ZMAIL-BACKGROUND-REQUEST-COMPLETE))
    (LABELS ((STOP-FOR-FOREGROUND-COMMAND (IGNORE IGNORE)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (STOP-ZMAIL-BACKGROUND-FOR-FOREGROUND-P))
	     (SET-RECENT-AND-INFORM-PARENT (IGNORE MSG)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (UNLESS (CL:GETF (MSG-STATUS MSG) 'RECENT)
		 (SEND SEQUENCE :NEW-MSG MSG T)
		 (SETF (CL:GETF (MSG-STATUS MSG) 'RECENT) T))))
      (MULTIPLE-VALUE-BIND (FINISHED NEW-LAST-PARSED IGNORE)
	  (PARSE-MSGS SEQUENCE :START START
			       :END END
			       :PROGRESS-NOTE PROGRESS-NOTE
			       :REAL-START (1+ LAST-PARSED)
			       :QUANTUM *BACKGROUND-PARSE-QUANTUM*
			       :STOP-PARSING-PREDICATE #'STOP-FOR-FOREGROUND-COMMAND
			       :POST-PARSING-FUNCTION #'SET-RECENT-AND-INFORM-PARENT)
	(SETQ LAST-PARSED NEW-LAST-PARSED)
	(IF (NOT FINISHED)
	    (ZMAIL-BACKGROUND-REQUEST-INCOMPLETE)
	  (QUEUE-ZMAIL-BACKGROUND-RESPONSE DONE-PARSING-NEW-MSGS SEQUENCE)
	  (WHEN ( (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) 0)
	    (SETF (SEQUENCE-REFERENCE-HASH-TABLE-TICK SEQUENCE) (TICK)))
	  (LET ((HASH-TABLE (MSG-BUFFER-PROPERTY-LIST-HASH-TABLE SEQUENCE)))
	    (WHEN HASH-TABLE
	      (SEND HASH-TABLE :NEW-ARRAY 2000.)))
	  (TV:REMOVE-PROGRESS-NOTE PROGRESS-NOTE)
	  (ZMAIL-BACKGROUND-REQUEST-COMPLETE))))))

1;;; Complete the processing of new mail after all the messages have been parsed.
0(DEFINE-ZMAIL-BACKGROUND-RESPONSE DONE-PARSING-NEW-MSGS () (:USES-SEQUENCE T)
  (NOTE-DONE-PARSING-NEW-MSGS SEQUENCE))

1;;; Parse a single message -- Parsing is logically divided into two levels.
;;;
;;;   The top level is implemented by the 2parse-msg1 generic function.  This level is
;;;   responsible for recording the results of the parse in the message's 2status1 cell.
;;;   In addition, any special processing of non-header information in the message
;;;   (e.g., 0BABYL/TENEX1 status line parsing, adding 2unseen1 properties) must be done
;;;   at this level.  Care is taken to only call this level once per message.
;;;
;;;   The second level is implemented by the 2parse-msg-text1 generic function.  This
;;;   level is responsible for actually constructing the internal representation of a
;;;   message header.  This level is normally invoked from the 2set-parsed-msg-headers
1;;;   function.  2set-parsed-msg-headers1 may be called numerous times on any message as
;;;   a consequence of editing, adding/deleting header fields, etc.
;;;
;;;   Both levels of the parse are supplied with a 2msg-status1 parameter.  This parameter
;;;   is a pointer to the message's 2status1 cell.  In theory, either level may record
;;;   non-header properties of the message in the 2status1 cell while parsing a message.
;;;   In practice, however, this use of the 2status1 cell should be limited to the top level.

;;; Top level of the message parser.
0(DEFGENERIC PARSE-MSG (MSG-BUFFER MSG MSG-STATUS)
  (:FUNCTION
    (CATCH-ERROR-RESTART-WITH-FORM ((ERROR) "Mark the message as unparsable and continue.")
	 (PUTPROP MSG-STATUS T 'UNPARSEABLE)
      (FUNCALL (FLAVOR:GENERIC PARSE-MSG) MSG-BUFFER MSG MSG-STATUS)))
  1;; The default method ...
0  (:METHOD (MSG-BUFFER)
    (SET-PARSED-MSG-HEADERS MSG MSG-STATUS T)
    (LET ((BUFFER-TICK (OR (MSG-BUFFER-TICK (MSG-BUFFER MSG)) (1+ (TICK)))))
      (SETF (MSG-INSERTION-TICK MSG) (1- BUFFER-TICK)))))

;;; Insures that the message summary line has the proper "fatness" ...
(DEFMETHOD (PARSE-MSG MSG-BUFFER :AFTER) (MSG MSG-STATUS)
  (LET ((SUBJECT (GET MSG-STATUS :SUBJECT)))
    (WHEN (COND ((NULL SUBJECT) NIL)
		((LISTP SUBJECT)
		 (LOOP FOR SUBJECT IN SUBJECT
		       THEREIS (STRING-FAT-P SUBJECT)))
		(T
		 (STRING-FAT-P SUBJECT)))
      (MAKE-MSG-SUMMARY-LINE-FAT MSG)
      (UPDATE-MSG-SUMMARY-LINE MSG :SUBJECT))))

(DEFUN MAKE-MSG-SUMMARY-LINE-FAT (MSG)
  (LET ((NEW-SUMMARY-LINE (MAKE-SUMMARY-LINE-FAT (MSG-SUMMARY-LINE MSG))))
    (SETF (MSG-SUMMARY-LINE MSG) NEW-SUMMARY-LINE)))

(DEFUN MAKE-SUMMARY-LINE-FAT (LINE)
  (IF (AND LINE (STRING-FAT-P LINE))
      LINE
    (LET ((NEW-SUMMARY-LINE (MAKE-FAT-SUMMARY-LINE)))
      (WHEN LINE
	(COPY-ARRAY-CONTENTS-AND-LEADER LINE NEW-SUMMARY-LINE)
	(STRUCTURE-FORWARD LINE NEW-SUMMARY-LINE))
      NEW-SUMMARY-LINE)))

1;;; "Fatten" (i.e., process epsilon escapes in) a message after parsing --
;;;    Implemented as a whopper surrounding the second level of message parsing as, logically,
;;;    it is not a proper part of either level of the parse.
0(DEFWHOPPER (PARSE-MSG-TEXT MSG-BUFFER) (MSG MSG-STATUS)
  (MULTIPLE-VALUE-BIND (HEADER-PLIST HEADERS-END-BP)
      (CONTINUE-WHOPPER MSG MSG-STATUS)
    (UNLESS (MSG-FATTENED-P MSG)
1      ;; Epsilon escape sequences in the message must only be processed once when the message
      ;; is first read from a file.  Once this processing and the Character-Type-Mappings vs.
      ;; Fonts "canonicalization" have been completed, all changes which may affect the
      ;; fattness of the message (e.g., Edit Current Msg) must include a call to
0      ;; 2update-msg-character-type-mappings0.
      (LET ((BODY-START-BP HEADERS-END-BP)
	    (BODY-END-BP (MSG-END-BP MSG))
	    (BOTH-HEADERS-PRESENT (AND (EQ (GET MSG-STATUS 'REFORMATTED) :IN-FILE)
				       (GET MSG-STATUS 'ORIGINAL-HEADERS-INTERVAL))))
	(MULTIPLE-VALUE-BIND (HEADERS-START-BP DECODING-HEADERS-END-BP)
	    1;; Messages in some files may have both their original and reformatted headers --
0	    1;;    Epsilon decode the original headers in the call to 2epsilon-decode-msg1.
0	    (IF BOTH-HEADERS-PRESENT
		(VALUES (GET MSG-STATUS 'ORIGINAL-HEADERS-INTERVAL) NIL)
	      (VALUES (INTERVAL-FIRST-BP (MSG-INTERVAL MSG)) HEADERS-END-BP))
	  (MULTIPLE-VALUE-BIND (MAPPINGS-CHANGED CHARACTER-TYPE-MAPPINGS FONTS JAPANESE
						 FATAL-DECODING-ERROR)
	      (EPSILON-DECODE-MSG HEADER-PLIST HEADERS-START-BP DECODING-HEADERS-END-BP T
					       BODY-START-BP BODY-END-BP T)
	    1;; Now, if necessary, epsilon decode the reformatted headers.
0	    (WHEN BOTH-HEADERS-PRESENT
	      (LET* ((HEADERS-START-BP (INTERVAL-FIRST-BP (MSG-INTERVAL MSG)))
		     (HEADERS-END-BP HEADERS-END-BP))	1;Eh?
0		(UNWIND-PROTECT
		    (PROGN
		      (PARSE-HEADERS-INTERVAL HEADERS-START-BP HEADERS-END-BP T NIL
					      *FONT-CONVERTED-HEADER-LINES*)
		      (EPSILON-DECODE-MSG-HEADERS-INTERVAL CHARACTER-TYPE-MAPPINGS
							   HEADERS-START-BP HEADERS-END-BP T))
		  1;; Remove the 2parsed-headers1 property from the reformatted header.
0		  (LOOP WITH HEADERS-END-LINE = (BP-LINE HEADERS-END-BP)
			WITH TEST-END-BEFORE = (ZEROP (BP-INDEX HEADERS-END-BP))
			FOR LINE = (BP-LINE HEADERS-START-BP) THEN (LINE-NEXT LINE)
			UNTIL (AND TEST-END-BEFORE (EQ LINE HEADERS-END-LINE))
			DO (REMPROP (LOCF (LINE-CONTENTS-PLIST LINE)) 'PARSED-HEADERS)
			UNTIL (EQ LINE HEADERS-END-LINE)))))
	    1;; The message has now been fattened.
0	    (SETF (MSG-FATTENED-P MSG) T)
	    (WHEN MAPPINGS-CHANGED
	      1;; In order for 2add-header-to-msg1 to work properly, the message must appear0 1to
0	      1;; be completely parsed and the message must know where its headers end.
0	      1;; Therefore, we temporarily bind 2msg-parsed-p 1and supply the appropriate
0	      1;; 2headers-end-bp1 property.  Note that 2add-header-to-msg1 completes the parsing
0	      1;; of0 1the message which0 1is why we return no headers when it is called to
0	      1;; prevent0 1the headers0 1from appearing twice in the message status.
0	      (LETF (((MSG-PARSED-P MSG) T))
		(SETF (CL:GETF (MSG-STATUS MSG) 'HEADERS-END-BP)
		      (COPY-BP HEADERS-END-BP :NORMAL (MSG-REAL-INTERVAL MSG)))
		(WITH-MSG-REDISPLAY-DELAYED
		  (ADD-HEADER-TO-MSG MSG :CHARACTER-TYPE-MAPPINGS CHARACTER-TYPE-MAPPINGS)
		  (WHEN (CL:GETF HEADER-PLIST :CHARACTER-STYLES)
		    1;; Delete any Character-Styles fields as they have now been superseeded by
0		    1;; the Character-Type-Mappings fields that we just added.
0		    (ADD-HEADER-TO-MSG MSG :CHARACTER-STYLES NIL :DELETE-IF-EMPTY T))
		  (ADD-HEADER-TO-MSG MSG :FONTS FONTS :DELETE-IF-EMPTY T)
		  (ADD-HEADER-TO-MSG MSG :JAPANESE JAPANESE :DELETE-IF-EMPTY T))
		(SETQ HEADER-PLIST NIL
		      HEADERS-END-BP (CL:GETF (MSG-STATUS MSG) 'HEADERS-END-BP))))
	    1;; Record any fatal epsilon decoding errors in the 2losing-headers1 of the message.
0	    (WHEN FATAL-DECODING-ERROR
	      (IF HEADER-PLIST
		  (PUSH FATAL-DECODING-ERROR (CL:GETF HEADER-PLIST 'LOSING-HEADERS))
		(PUSH FATAL-DECODING-ERROR (CL:GETF (MSG-STATUS MSG) 'LOSING-HEADERS))))))))
      (VALUES HEADER-PLIST HEADERS-END-BP)))

;;; Second level of the message parser.
(DEFGENERIC PARSE-MSG-TEXT (MSG-BUFFER MSG MSG-STATUS)
  (DECLARE (VALUES . (HEADERS HEADERS-END-BP)))
  ;; The default method -- Always parse the original headers (if present).
  (:METHOD (MSG-BUFFER)
    (LET ((ORIGINAL (GET MSG-STATUS 'ORIGINAL-HEADERS-INTERVAL)))
      (IF (NULL ORIGINAL)
	  (PARSE-HEADERS-INTERVAL (MSG-INTERVAL MSG) NIL NIL T)
	(VALUES (PARSE-HEADERS-INTERVAL ORIGINAL) (GET-MSG-HEADERS-END-BP MSG))))))

(DEFUN GET-MSG-HEADERS-END-BP (MSG)
  ;; Returns where the headers in the text end also.
  (LOOP WITH *INTERVAL* = (MSG-INTERVAL MSG)
	FOR LINE = (BP-LINE (MSG-START-BP MSG)) THEN (LINE-NEXT LINE)
	WITH BLANK-LINE-SEEN = NIL
	WITH END-LINE = (BP-LINE (MSG-END-BP MSG))
	UNTIL (EQ LINE END-LINE)
	IF (LINE-BLANK-P LINE)
	DO (SETQ BLANK-LINE-SEEN T)
	ELSE IF BLANK-LINE-SEEN DO (LOOP-FINISH)
	FINALLY (RETURN (CREATE-BP LINE 0))))

;;; Most formats do not have a way of saving the original at all.
(DEFMETHOD (:SAVE-ORIGINAL-HEADER MSG-BUFFER) (MSG)
  MSG
  #||(EQ *REFORMAT-HEADERS-P* ':SAVE-ORIGINAL)||#
  *REFORMAT-HEADERS-P*)

(DEFMETHOD (:REFORMAT-TEMPLATE MSG-BUFFER) (MSG FORCE-P)
  MSG
  (AND (OR *REFORMAT-HEADERS-P* FORCE-P)
       'DEFAULT-REFORMAT-TEMPLATE))

(DEFMETHOD (:SET-REFORMATTED-HEADERS MSG-BUFFER) (MSG STAT NEW-HEADERS-INTERVAL)
  (LET* ((MSG-INTERVAL (MSG-INTERVAL MSG))
	 (HEADERS-END-BP (MSG-GET MSG 'HEADERS-END-BP)))
    (UNLESS (NULL HEADERS-END-BP)
      (LET* ((MSG-START-BP (INTERVAL-FIRST-BP MSG-INTERVAL))
	     (OLD-FIRST-LINE (BP-LINE MSG-START-BP))
	     (START-PREVIOUS-LINE (LINE-PREVIOUS OLD-FIRST-LINE))
	     (BODY-START-LINE (BP-LINE HEADERS-END-BP))
	     (OLD-LAST-LINE (LINE-PREVIOUS BODY-START-LINE))
	     (FIRST-NEW-LINE (BP-LINE (INTERVAL-FIRST-BP NEW-HEADERS-INTERVAL)))
	     (LAST-NEW-LINE (BP-LINE (INTERVAL-LAST-BP NEW-HEADERS-INTERVAL))))
	;; Atomically replace the original headers with these new ones.
	(WITHOUT-INTERRUPTS
	  (SETF (LINE-PREVIOUS FIRST-NEW-LINE) START-PREVIOUS-LINE)
	  (IF START-PREVIOUS-LINE
	      (SETF (LINE-NEXT START-PREVIOUS-LINE) FIRST-NEW-LINE)
	      (MOVE-BP (MSG-REAL-START-BP MSG) FIRST-NEW-LINE 0))
	  (MOVE-BP MSG-START-BP FIRST-NEW-LINE 0)
	  (SETF (LINE-NEXT LAST-NEW-LINE) BODY-START-LINE)
	  (SETF (LINE-PREVIOUS BODY-START-LINE) LAST-NEW-LINE)
	  ;; Put new headers in text interval
	  (LOOP FOR LINE FIRST FIRST-NEW-LINE THEN (LINE-NEXT LINE)
		UNTIL (EQ LINE BODY-START-LINE)
		DO (SETF (LINE-NODE LINE) MSG-INTERVAL))
	  (LET ((NEW-INTERVAL-FOR-OLD NIL))
	    (WHEN (NULL (GET STAT 'ORIGINAL-HEADERS-INTERVAL))
	      (LET ((NEW-INTERVAL (CREATE-INTERVAL)))
		(MOVE-BP (INTERVAL-FIRST-BP NEW-INTERVAL) OLD-FIRST-LINE 0)
		(LET ((LINE (BP-LINE (INTERVAL-LAST-BP NEW-INTERVAL))))
		  (SETF (LINE-PREVIOUS LINE) OLD-LAST-LINE)
		  (SETF (LINE-NEXT OLD-LAST-LINE) LINE))
		(PUTPROP STAT NEW-INTERVAL 'ORIGINAL-HEADERS-INTERVAL)
		(SETQ NEW-INTERVAL-FOR-OLD NEW-INTERVAL)))
	    (WHEN (NULL NEW-INTERVAL-FOR-OLD)
	      (SETQ NEW-INTERVAL-FOR-OLD (CREATE-INTERVAL
					   (CREATE-BP OLD-FIRST-LINE 0 :NORMAL
						      MSG-INTERVAL)
					   (CREATE-BP OLD-LAST-LINE 0 :MOVES
						      MSG-INTERVAL))))
	    (LOOP FOR LINE = OLD-FIRST-LINE THEN (LINE-NEXT LINE)
		  DO (SETF (LINE-NODE LINE) NEW-INTERVAL-FOR-OLD)
		  UNTIL (EQ LINE OLD-LAST-LINE)))))
      ':IN-CORE)))

1;;; Inboxes --
;;;
;;;    An inbox is a message file into which a mailer places a user's newly arrived mail.
;;;
;;;    The0 Get New Mail From Inbox1 command reads new mail from one or more inboxes and
;;;    inserts it into a mail file for processing and possible permanent storage.  If the
;;;    user doesn't explicitly specify which inbox should be read by the command, it will
;;;    read the default inboxes for the mail file.  The default inboxes for a mail file
;;;    are either those listed in the 2:mail1 mail file option of the file or the single
;;;    file derived whose pathname is derived from the pathname of the mail file.  (See the
;;;    2inbox-pathnames1 generic function, above.)
;;;
;;;    Before an inbox is read, it is renamed to a name based on its original name.  (See
;;;    the 2rename-inbox-pathname1 generic function in0 MAILBOX-PATHNAMES1.)  This renaming
;;;    allows the mailer to continue to deliver new mail to the user and also insures that,
;;;    when the user asks to read new mail again, we won't read some mail twice.
;;;
;;;    The list of renamed inboxes which have been inserted into a mail file are
;;;    remembered by the mail file.  When the mail file is finally saved, the inboxes
;;;    are deleted.  When the user asks to read new mail, we check for any undeleted
;;;    renamed inboxes which are not listed as being inserted in the mail file and, if
;;;    present, read them in addition to the normally named inbox.  In this manner, we
;;;    guarentee that mail can't be lost due to machine failures, etc.

;;; Inbox buffers --
;;;
;;;    An inbox buffer is a temporary buffer which exists while new mail is being read
;;;    from an inbox.  The inbox buffer contains a list of the files which have already
;;;    been read into itself.  In addition, it contains the list of files to be read which
;;;    includes the inbox proper and any corresponding undeleted renamed inboxes.  The
;;;    buffer also knows the mail file into which the inboxes are to be inserted.
;;;
;;;    An inbox buffer may be in one of the following states:
;;;
;;;       2:idle1 -- The inbox buffer has just been created and is ready for a 2load-inbox1.
;;;          The buffer may also be in this state after some of its files have been read
;;;          but reading was aborted because reading the next file would require saving
;;;          the mail file in order to delete a renamed file before renaming said file.
;;;
;;;       2:loading1 -- Messages are being read from the files in the inbox.
;;;
;;;       2:loaded1 -- A transient state which indicates that all messsages have been
;;;          read from all the files known by the inbox buffer.  An inbox buffer in this
;;;          state is ready to be inserted into its mail file via the 2insert-inbox
1;;;          generic function.
;;;
;;;       2:parsing1 -- The inbox buffer's messages have been inserted into the mail file
;;;          and are being parsed in the background.  When the parsing is completed,
;;;          the inbox buffer will enter the 2:inserted1 state and inform its mail file
;;;          that its insertion has completed.
;;;
;;;       2:inserted1 -- The inbox buffer's messages have been inserted into the mail file
;;;          and have been parsed.  However, there are other inboxes which must still
;;;          be read and inserted into the mail file before the inbox hooks and sorting
;;;          may take place.  After all inboxes are inserted, the 2finish-reading-new-mail
1;;;          generic function is invoked on the mail file to transfer the file lists
;;;          from the inbox buffers to the mail files and to finally kill the inbox buffers.
;;;          If, 2finish-reading-new-mail1 is invoked to allow a forced saving of the
;;;          mail file (see 2:idle1), the inbox buffer will return to the 2:idle1 state if
;;;          it still has unread files.
;;;
0(DEFFLAVOR INBOX-BUFFER
	(PARENT-BUFFER
	 (FILES-BEING-INSERTED NIL)
	 (FILE-BEING-READ NIL)
	 LOADING-TRUENAME
	 (NMSGS-ALREADY-READ 0)
	 (INSERTED-FILES NIL)
	 (FORCIBLY-INSERTED NIL))
	(MSG-BUFFER)
  (:READABLE-INSTANCE-VARIABLES PARENT-BUFFER FILES-BEING-INSERTED INSERTED-FILES)
  (:INITABLE-INSTANCE-VARIABLES PARENT-BUFFER)
  (:INIT-KEYWORDS :PATHNAME)
  (:REQUIRED-INIT-KEYWORDS :PARENT-BUFFER :PATHNAME))

1;;; Create an inbox buffer -- Generate the list of files which should be read.
0(DEFMETHOD (MAKE-INSTANCE INBOX-BUFFER) (&KEY ((:PATHNAME USER-PATHNAME)) &ALLOW-OTHER-KEYS)
  (SETQ PATHNAME (SEND USER-PATHNAME :TRANSLATED-PATHNAME)
	NAME (FORMAT NIL "~A for ~A"
		     (SEND PATHNAME :STRING-FOR-PRINTING) (SEND PARENT-BUFFER :NAME))
	STATUS :IDLE)
  (PUSH (MAKE-INSERTED-INBOX :PATHNAME PATHNAME :RENAME-WHEN-READ T)
	FILES-BEING-INSERTED)
  (ERROR-RESTART ((FS:FILE-ERROR SYS:NETWORK-ERROR)
		  "Retry finding the files in ~A." NAME)
    (LOOP WITH ALREADY-INSERTED-INBOXES = (ALL-INSERTED-INBOXES PARENT-BUFFER)
	  FOR PATH-AND-PROPERTIES
	      IN (NREVERSE (CONDITION-CASE ()
				(FS:DIRECTORY-LIST (RENAME-INBOX-PATHNAME PATHNAME :WILD T)
						   :SORTED)
			      1;; The 0TOPS-201 0QFILE1 implementation signals an error when no
0			      1;; files match the pathname given to 2fs:directory-list1.  (It
0			      1;; should, like other systems, just return either 2nil1 or the
0			      1;; entry for the directory.)  Since it's unlikely that this
0			      1;; bug will ever get fixed, we'll just catch it here.
0			      (FS:FILE-NOT-FOUND NIL)))
	  AS PATH = (FIRST PATH-AND-PROPERTIES)
	  WHEN PATH
	    UNLESS (CL:MEMBER PATH ALREADY-INSERTED-INBOXES
			      :TEST #'(LAMBDA (PATH INBOX)
					(EQ PATH (INSERTED-INBOX-TRUENAME INBOX))))
	      DO (PUSH (MAKE-INSERTED-INBOX :PATHNAME PATH :RENAME-WHEN-READ NIL)
		       FILES-BEING-INSERTED))))

;;; Use the parent buffer's summary window display format when parsing messages --
;;;    This action must be implemented as an :AFTER daemon to be certain that it occurs
;;;    after the MAKE-INSTANCE primary method of SEQUENCE which does a :SET-PROPERTY-LIST.
(DEFMETHOD (MAKE-INSTANCE INBOX-BUFFER :AFTER) (&REST IGNORE)
  (WHEN (SEND PARENT-BUFFER :GETL '(:SUMMARY-WINDOW-FORMAT))
    (SEND SELF :PUTPROP
	  (SEND PARENT-BUFFER :GET :SUMMARY-WINDOW-FORMAT) :SUMMARY-WINDOW-FORMAT)))

;;; Kill an inbox buffer -- Be sure that the parent buffer is locked.
(DEFWHOPPER (KILL-SEQUENCE INBOX-BUFFER) (&KEY ABORT)
  (LOCK-INBOX-AND-BUFFER (SELF :WRITE)
    (CONTINUE-WHOPPER :ABORT ABORT)))

;;; Kill an inbox buffer.
(DEFMETHOD (KILL-SEQUENCE INBOX-BUFFER :AFTER) (&KEY ABORT)
  (IGNORE ABORT)
  (WHEN PARENT-BUFFER
    (SETF (FILE-MAIL-BUFFER-INBOXES-BEING-INSERTED PARENT-BUFFER)
	  (DELQ SELF (FILE-MAIL-BUFFER-INBOXES-BEING-INSERTED PARENT-BUFFER))))
  (SETQ PARENT-BUFFER NIL
	FILES-BEING-INSERTED NIL
	FILE-BEING-READ NIL
	NMSGS-ALREADY-READ 0
	INSERTED-FILES NIL))

;;; Return the element type to be used when reading/writing a mail file.
(DEFMETHOD (MSG-FILE-ELEMENT-TYPE INBOX-BUFFER) (&KEY ((:PATHNAME PATHNAME-OVERRIDE)))
  (IGNORE PATHNAME-OVERRIDE)
  'CL:STRING-CHAR)				;We'll interpret the epsilon's ourselves...

1;;; Find and open the next file listed by this inbox buffer --
;;;    This function has no unwind protection as it is provided by our caller.
0(DEFUN-IN-FLAVOR (OPEN-NEXT-INBOX-FILE INBOX-BUFFER) ()
  (DECLARE (VALUES . (NEXT-FILE-WAS-OPENED)))
  (LOOP NAMED FIND-NEXT-INBOX
	WITH ORIGINAL-STREAM
	WHILE FILES-BEING-INSERTED
	AS FILE = (CL:POP FILES-BEING-INSERTED)
	AS PATHNAME = (INSERTED-INBOX-PATHNAME FILE)
	IF (INSERTED-INBOX-RENAME-WHEN-READ FILE)
	  DO (LET* ((RENAMED-PATHNAME (RENAME-INBOX-PATHNAME PATHNAME))
		    (RENAMED-TRUENAME (IF (EQ (SEND RENAMED-PATHNAME :VERSION) :WILD)
					  (SEND RENAMED-PATHNAME :NEW-PATHNAME
						:NEW-VERSION (SEND PATHNAME :VERSION))
					  RENAMED-PATHNAME)))
	       (UNLESS (EQ (SEND RENAMED-TRUENAME :VERSION) :NEWEST)
		 (LOOP FOR F IN (ALL-INSERTED-INBOXES PARENT-BUFFER)
		       WHEN (EQ (INSERTED-INBOX-TRUENAME F) RENAMED-TRUENAME)
			 DO 1;; Fake that the file is being read so that if the user elects
			    ;; to save and continue, our caller's unwind protection will put
			    ;; this file back on the list of files yet to be read.  (It's
			    ;; presently in limbo.)
0			   (SETQ FILE-BEING-READ FILE)
			   (SIGNAL-PROCEED-CASE
			       (()
				'INBOX-REQUIRES-SAVE :BUFFER PARENT-BUFFER
						     :FIRST-INBOX (NULL (ALL-INSERTED-FILES
									  PARENT-BUFFER))
						     :FORMAT-STRING NIL)
			     (:SAVE-AND-CONTINUE-READING-NEW-MAIL
			       (THROW 'SAVE-AND-CONTINUE-READING-NEW-MAIL T))
			     (:STOP-READING-NEW-MAIL
			       (THROW 'STOP-READING-NEW-MAIL T)))))
	       (CL:MULTIPLE-VALUE-SETQ (STREAM ORIGINAL-STREAM)
		 (OPEN-AND-RENAME-INBOX PATHNAME RENAMED-PATHNAME SELF)))
	ELSE
	  DO (SETQ STREAM (OPEN PATHNAME :DIRECTION :INPUT
					 :IF-DOES-NOT-EXIST NIL
					 :ELEMENT-TYPE (MSG-FILE-ELEMENT-TYPE SELF)))
	WHEN STREAM
	  DO 1;; We've found another file that needs to be read.
0	    (CL:SETF (INSERTED-INBOX-TRUENAME FILE) (TRUE-TRUENAME STREAM)
		     (INSERTED-INBOX-FILE-ID FILE) (SEND STREAM :INFO)
		     PATHNAME (SEND (OR ORIGINAL-STREAM STREAM) :PATHNAME)
		     FILE-BEING-READ FILE
		     LOADING-TRUENAME (SEND (OR ORIGINAL-STREAM STREAM) :TRUENAME))
	    (VERIFY-MSG-FILE-FORMAT-AND-LOAD-HEADER SELF)
	  AND RETURN T))

1;;; Open and rename an inbox file.
0(DEFUN OPEN-AND-RENAME-INBOX (PATHNAME RENAMED-PATHNAME BUFFER)
  (DECLARE (VALUES . (STREAM ORIGINAL-STREAM)))
  (LET ((ORIGINAL-STREAM (OPEN PATHNAME :DIRECTION :PROBE :IF-DOES-NOT-EXIST NIL)))
    (IF ORIGINAL-STREAM
	(DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (INBOX-RENAME-ERROR)
	  (BLOCK RENAME-FILE
	    (ERROR-RESTART-ONCE-OR-FOREVER (INBOX-RENAME-ERROR
					     ("Retry renaming inbox ~A for 15 seconds."
					      "Retry renaming inbox ~A indefinitely.")
					     PATHNAME)
	      (LOOP FOR COUNT FROM 1 TO 4
		    DO (CONDITION-CASE ()
			    (MULTIPLE-VALUE-BIND (IGNORE IGNORE NEW-TRUENAME)
				1;; 3Horrible kludge to bypass bug in our TCP-FTP1 --
				;;    Our 0TCP-FTP1 file access path doesn't bother to check
				;;    with the server machine when asked to make a 2:probe
1				;;    opening unless the server is a 0TOPS-201, 0Multics1, or
				;;    0Unix1; 3instead, it will always claim that the file
1				;;    3exists!1  Therefore, if we're supposed to rename the
				;;    file, the following call to 2cl:rename-file 1will fail
				;;    so we'll just have to catch the 2fs:file-not-found1 here.
0				(CONDITION-CASE ()
				     (CL:RENAME-FILE PATHNAME RENAMED-PATHNAME)
				   (FS:FILE-NOT-FOUND
				     (RETURN-FROM OPEN-AND-RENAME-INBOX (VALUES NIL NIL))))
			      (IGNORE-ERRORS
				1;; Renamed inboxes should not be automatically deleted by
				;; the file system's handling of multiple generations --
				;;    Thus, we try to set the generation retention count to
				;;    NIL disable the mechanism after renaming the file.
				;;    3(Change renaming mechanism to not rely on
1				;;     3multiple versions in a future release?)
0				(FS:CHANGE-FILE-PROPERTIES NEW-TRUENAME NIL
							   :GENERATION-RETENTION-COUNT NIL))
			      (RETURN-FROM RENAME-FILE (VALUES)))
			  ((FS:FILE-OPEN-FOR-OUTPUT FS:FILE-LOCKED)
			   (IF (= COUNT 4)
			       (ERROR 'INBOX-RENAME-ERROR
				      "Unable to rename inbox ~A; it is persistently busy."
				      PATHNAME)
			     (PROCESS-SLEEP (* 60. 5.) "Inbox Rename Wait")))))))
	  (VALUES (OPEN RENAMED-PATHNAME :DIRECTION :INPUT
					 :ELEMENT-TYPE (MSG-FILE-ELEMENT-TYPE BUFFER))
		  ORIGINAL-STREAM))
      (VALUES NIL NIL))))

1;;; Kludge to bypass a bug in 0ITS QFILE1 --
;;;     The truename of a stream returned by an 0ITS QFILE1 opening has the system name as its
;;;     device name rather than the primary device name (i.e., "0DSK1").  As a result, these
;;;     truenames aren't 2eq1 to other pathnames referencing the same file as they should be.
;;;0	1(This lack of 2eq1ness prevents us from properly checking if the mail file must be
;;;0	1saved before reading a new inbox.)  Therefore, we'll fix any broken truenames here.
0(DEFUN TRUE-TRUENAME (STREAM)
  (LET* ((TRUENAME (SEND STREAM :TRUENAME))
	 (TRUENAME-HOST (SEND TRUENAME :HOST))
	 (TRUENAME-HOST-TYPE (SEND TRUENAME-HOST :SYSTEM-TYPE))
	 (TRUENAME-DEVICE (SEND TRUENAME :DEVICE)))
    (IF (AND (EQ TRUENAME-HOST-TYPE :ITS)
	     (SEND TRUENAME-HOST :PATHNAME-HOST-NAMEP TRUENAME-DEVICE))
	(SEND TRUENAME :NEW-DEVICE (SEND TRUENAME :PRIMARY-DEVICE))
      TRUENAME)))

;;; Read all the messages from an inbox file.
(DEFUN-IN-FLAVOR (READ-INBOX-FILE-MSGS INBOX-BUFFER) ()
  (TYPEIN-LINE-DURABLE "Reading ~A file ~A for ~A ... "
		       (SEND SELF :FORMAT-NAME) (OR LOADING-TRUENAME (SEND STREAM :TRUENAME))
		       (SEQUENCE-NAME PARENT-BUFFER))
  (LOOP WHILE (READ-NEXT-MSG SELF))
  (TYPEIN-LINE-MORE-DURABLE "~D new message~:P." (- (SEQUENCE-NMSGS SELF) NMSGS-ALREADY-READ))
  )

1;;; Close an inbox file --
;;;    If the read completed normally, we'll add this file to the list of files inserted
;;;    in the inbox and ready for insertion into the mail file.  On the other hand,
;;;    if we're aborting the read, we'll flush any messages that were read from this file
;;;    and put it back onto the list of files waiting to be read.  In this way, the various
;;;    restart handlers will be able to retry reading properly.
0(DEFUN-IN-FLAVOR (CLOSE-INBOX-FILE INBOX-BUFFER) (&KEY ABORT)
  (WHEN FILE-BEING-READ
    1;; Only do this if we were actually reading something ...
0    (IF ABORT
	1;; ... incomplete read.
0	(BLOCK READ-FAILED	  
	  (WHEN (> (SEQUENCE-NMSGS SELF) NMSGS-ALREADY-READ)
	    (SYS:WITHOUT-ABORTS ("Aborting reading ~A."
				 (INSERTED-INBOX-TRUENAME FILE-BEING-READ))
	      (TV:NOTING-PROGRESS ((FORMAT NIL "Killing messages read from ~A."
					   (INSERTED-INBOX-TRUENAME FILE-BEING-READ)))
		(LOOP WITH NMSGS-TO-KILL = (- (SEQUENCE-NMSGS SELF) NMSGS-ALREADY-READ)
		      FOR I FROM NMSGS-ALREADY-READ REPEAT NMSGS-TO-KILL
		      UNLESS (NULL (AREF ARRAY I))
			DO (KILL-MSG (AREF ARRAY I) T)
			   (SETF (AREF ARRAY I) NIL)
			   (TV:NOTE-PROGRESS (- I NMSGS-ALREADY-READ) NMSGS-TO-KILL)))
	      (SETF (SEQUENCE-NMSGS SELF) NMSGS-ALREADY-READ)))
	  1;; If we suceeded in renaming this file before we started reading it, be sure
	  ;; we don't try to rename it again as that would fail.
0	  (WHEN (AND (INSERTED-INBOX-RENAME-WHEN-READ FILE-BEING-READ)
		     (NOT (NULL (INSERTED-INBOX-TRUENAME FILE-BEING-READ))))
	    (CL:SETF (INSERTED-INBOX-PATHNAME FILE-BEING-READ) (INSERTED-INBOX-TRUENAME
								 FILE-BEING-READ)
		     (INSERTED-INBOX-RENAME-WHEN-READ FILE-BEING-READ) NIL))
	  (PUSH FILE-BEING-READ FILES-BEING-INSERTED)
	  (SETQ FILE-BEING-READ NIL))
      1;; ... successful read.
0      (SETQ INSERTED-FILES (NCONC INSERTED-FILES (NCONS FILE-BEING-READ))
	    FILE-BEING-READ NIL
	    NMSGS-ALREADY-READ (SEQUENCE-NMSGS SELF))))
  (WHEN STREAM
    (IF ABORT
	(UNWIND-PROTECT
	    (SYS:WITHOUT-ABORTS ("A cleanup form is closing the stream ~S.~@
				  Aborting before the cleanup is complete could leave ~
				  the stream open indefinitely."
				 STREAM)
	      (IGNORE-ERRORS
		(CL:CLOSE STREAM :ABORT T)))
	  (SETQ STREAM NIL))
      1;; Close the stream normally and forget only if we succeed ...
0      (CL:CLOSE STREAM)
      (SETQ STREAM NIL))))

;;; Load an inbox -- Read (and rename as appropriate) all files defined as part of this inbox.
(DEFMETHOD (LOAD-INBOX INBOX-BUFFER) ()
  (CL:ASSERT (EQ STATUS :IDLE) ()
	     "LOAD-INBOX invoked for inbox ~S while in state ~A." SELF STATUS)
  (LOCK-SEQUENCE (SELF :WRITE)
    (SETQ STATUS :LOADING)
    (UNWIND-PROTECT-CASE ()
	(LOOP WHILE (OPEN-NEXT-INBOX-FILE)
	      DO (READ-INBOX-FILE-MSGS)
		 (CLOSE-INBOX-FILE))
      (:ABORT
	(CLOSE-INBOX-FILE :ABORT T)
	(SETQ STATUS :IDLE)))			;Inbox is ready to be restarted.
    (SETQ STATUS :LOADED)))

1;;; Insert the messages from the inbox into our parent buffer --
;;;
;;;    In order to make the inbox messages available as quickly as possible, we insert
;;;    them into our parent before they are parsed.  If the user's profile enables using
;;;    the background, we'll request that the messages be parsed there; otherwise, we'll
;;;    parse them now as the entire 2read-new-mail1 operation is being performed synchronously.
;;;    2(msg-parsed-p msg)1 of these messages is set to the inbox so that whenever one of these
;;;    messages is parsed, it is parsed using the inbox's 2parse-msg1 method which may be
;;;    different from that of the mail file.  
;;;
;;;    If the 2:force1 keyword is 2non-nil1, this method is being invoked in order to save the
;;;    mail file with whatever's been inserted so that one of our inbox files can be renamed.
;;;    In this case, the inbox should have been reverted to the 2:idle1 state by the
;;;    2unwind-protect-case1 of 2load-inbox1.
0(DEFMETHOD (INSERT-INBOX INBOX-BUFFER) (BUFFER &KEY FORCE)
  (CL:ASSERT (OR (EQ STATUS :LOADED) (AND FORCE (EQ STATUS :IDLE))) ()
	     "INSERT-INBOX~:[ (:FORCE T)~] invoked for inbox ~S while in state ~A."
	     (NOT FORCE) SELF STATUS)
  (CL:ASSERT (OR FORCE (AND (NULL FILE-BEING-READ) (NULL FILES-BEING-INSERTED))) ()
	     "INSERT-INBOX invoked for inbox ~S before all files have been read." SELF)
  (CL:ASSERT (EQ BUFFER PARENT-BUFFER) ()
	     "INSERT-INBOX invoked for inbox ~S from buffer ~S." SELF BUFFER)
  (LOCK-INBOX-AND-BUFFER (SELF :WRITE)
    1;; Try to keep the user from aborting with an inconsistent buffer.
0    (SYS:WITHOUT-ABORTS ("Inserting inbox ~A into ~A.~@
			  Aborting now would leave the buffer in an inconsistent state;~@
			  some of the newly read messages will be lost."
			 NAME PARENT-BUFFER)
      (LET* ((PARENT-APPENDS (SEQUENCE-APPEND-P PARENT-BUFFER))
	     (PARENT-REVERSES (SEND PARENT-BUFFER :GET :REVERSE-NEW-MAIL))
	     (FIRST-NEW-MSG (COND ((AND PARENT-APPENDS PARENT-REVERSES)
				   (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES PARENT-BUFFER))
				  ((AND PARENT-APPENDS (NOT PARENT-REVERSES))
				   (SEQUENCE-NMSGS PARENT-BUFFER))
				  ((AND (NOT PARENT-APPENDS) PARENT-REVERSES)
				   0)
				  ((AND (NOT PARENT-APPENDS) (NOT PARENT-REVERSES))
				   (FILE-MAIL-BUFFER-TOTAL-MSGS-FROM-INBOXES PARENT-BUFFER))))
	     (N-NEW-MSGS-READ (SEQUENCE-NMSGS SELF))
	     (PARENT-ARRAY (SEQUENCE-ARRAY PARENT-BUFFER))
	     (PARENT-NEW-NMSGS (+ (SEQUENCE-NMSGS PARENT-BUFFER) N-NEW-MSGS-READ)))
	(WHEN (PLUSP N-NEW-MSGS-READ)
	  1;; Reverse the new mail if requested.
0	  (WHEN (SEND PARENT-BUFFER :GET :REVERSE-NEW-MAIL)
	    (ARRAY-NREVERSE ARRAY)
	    (SEQUENCE-REARRANGED PARENT-BUFFER :SOFT T))
	  1;; Copy the messages without interrupts to be absolutely safe.
0	  (WITHOUT-INTERRUPTS
	    (WHEN (< (ARRAY-LENGTH PARENT-ARRAY) PARENT-NEW-NMSGS)
	      1;; ... grow the parent buffer's array to 125% of the needed size.
0	      (ADJUST-ARRAY-SIZE PARENT-ARRAY (FLOOR (* 5\4 PARENT-NEW-NMSGS))))
	    (UNLESS ( FIRST-NEW-MSG (SEQUENCE-NMSGS PARENT-BUFFER))
	      1;; ... move old messages up when prepending new mail.
0	      (LOOP FOR I FROM (1- (SEQUENCE-NMSGS PARENT-BUFFER)) DOWNTO FIRST-NEW-MSG
		    FOR J DOWNFROM (1- PARENT-NEW-NMSGS)
		    DO (SETF (AREF PARENT-ARRAY J) (AREF PARENT-ARRAY I))))
	    1;; ... actually copy the messages while removing them from the inbox.
0	    (LOOP FOR I FROM 0 BELOW N-NEW-MSGS-READ
		  FOR J FROM FIRST-NEW-MSG
		  DO (CL:SETF (AREF PARENT-ARRAY J) (AREF ARRAY I)
			      (AREF ARRAY I) NIL)
		     (WHEN (AREF PARENT-ARRAY J)
		       1;; ... make the messages appear to belong to the parent buffer
		       ;;     while using the inbox's parse method.
0		       (CL:SETF (MSG-BUFFER (AREF PARENT-ARRAY J)) PARENT-BUFFER
				(MSG-PARSED-P (AREF PARENT-ARRAY J)) SELF)))
	    1;; ... update fill pointers, etc.
0	    (CL:SETF (SEQUENCE-NMSGS PARENT-BUFFER) PARENT-NEW-NMSGS
		     (SEQUENCE-NMSGS SELF) 0
		     NMSGS-ALREADY-READ 0)
	    (INCF (FILE-MAIL-BUFFER-TOTAL-MSGS-FROM-INBOXES PARENT-BUFFER) N-NEW-MSGS-READ))
	  (WHEN (EQ PARENT-BUFFER *SEQUENCE*)
	    (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY T)))
	(IF (ZEROP N-NEW-MSGS-READ)
	    1;; Nothing read -- by definition, this inbox is inserted.
0	    (SETQ STATUS :INSERTED)
	    1;; Something was read --
0	    1;;    The 2read-new-mail1 method will either parse the messages immediately
	    ;;    or queue an appropriate background request.
0	    (SETQ STATUS :PARSING)))))
  (SETQ FORCIBLY-INSERTED FORCE))

;;; Parse a message in an inbox --
;;;    Actually, the message really resides in a mail file but its MSG-PARSED-P cell
;;;    identifies the inbox from which it was read to guarentee proper parsing.  Insure
;;;    that the mail file recognizes it now has a new message from an inbox and mark the
;;;    message with the RECENT attribute.
(DEFWHOPPER (PARSE-MSG INBOX-BUFFER) (MSG MSG-STATUS)
  (MULTIPLE-VALUE-PROG1
    (CONTINUE-WHOPPER MSG MSG-STATUS)
    (LETF (((MSG-PARSED-P MSG) T))
      (SEND PARENT-BUFFER :NEW-MSG MSG T)
      (MSG-PUT MSG T 'RECENT))))

;;; Use the same reformatting as our parent
(DEFMETHOD (:REFORMAT-TEMPLATE INBOX-BUFFER) (MSG FORCE-P)
  (SEND PARENT-BUFFER :REFORMAT-TEMPLATE MSG FORCE-P))

1;;; Finish the insertion of an inbox --
;;;    Move the list of files read from the inbox to our parent buffer.
;;;
;;;    If the 2:force1 keyword is 2non-nil1, we are being called so that we might save the mail
;;;    file and any new mail already read before renaming an inbox.  In this case, this inbox
;;;    is allowed to be idle or to contain unread files.  If there are unread files, we
;;;    leave the inbox on our parent's list of unprocessed inboxes and return to the idle
;;;    state to allow a subsequent 2load-inbox1 method to operate properly.
;;;
;;;    If the 2forcibly-inserted1 instance variable is 2non-nil1, we were forcibly inserted
;;;    earlier as part of stopping a 2read-new-mail1 operation mid-stream because to
;;;    continue would have required saving the mail file which the user didn't want to do
;;;    at this time.  Therefore, the inbox is again allowed to contain unread files. 
;;;    However, unlike the previous case, we'll flush the inbox from our parent's list
;;;    this time as we want to act as if we were inserted normally.
;;;
0(DEFMETHOD (FINISH-INSERTING-INBOX INBOX-BUFFER) (BUFFER &KEY FORCE)
  (CL:ASSERT (OR (EQ STATUS :INSERTED) (AND FORCE (EQ STATUS :IDLE))) ()
	     "FINISH-INSERTING-INBOX~:[ (:FORCE T)~] invoked for inbox ~S while in state ~A."
	     (NOT FORCE) SELF STATUS)
  (CL:ASSERT (OR FORCE FORCIBLY-INSERTED
		 (AND (NULL FILE-BEING-READ) (NULL FILES-BEING-INSERTED))) ()
	     "FINISH-INSERTING-INBOX invoked for inbox ~S before all files have been read."
	     SELF)
  (CL:ASSERT (EQ BUFFER PARENT-BUFFER) ()
	     "FINISH-INSERTING-INBOX invoked for inbox ~S from buffer ~S." SELF BUFFER)
  (LABELS ((FLUSH-AND-DIE ()
	     (SETF (FILE-MAIL-BUFFER-INBOXES-BEING-INSERTED PARENT-BUFFER)
		   (DELQ SELF (FILE-MAIL-BUFFER-INBOXES-BEING-INSERTED PARENT-BUFFER)))
	     (KILL-SEQUENCE SELF)))
    (WHEN (EQ STATUS :INSERTED)
      (LOCK-INBOX-AND-BUFFER (SELF :WRITE)
	(SETF (FILE-MAIL-BUFFER-INSERTED-INBOXES PARENT-BUFFER)
	      (NCONC (FILE-MAIL-BUFFER-INSERTED-INBOXES PARENT-BUFFER) INSERTED-FILES))
	(COND ((AND (NULL FILE-BEING-READ) (NULL FILES-BEING-INSERTED))
	       1;; Really finished0 1-- Remove from parent's list and self destruct.
0	       (FLUSH-AND-DIE))
	      (FORCE
	       1;; Forcibly finished with unread files -- Return to 2:idle1 state.
0	       (SETQ STATUS :IDLE))
	      (FORCIBLY-INSERTED
	       1;; Forcibly inserted but ordinary finish --
0	       1;;    We're done even if there are unread files present.
0	       (FLUSH-AND-DIE)))))))

;;; Abort loading an inbox --
;;;    Invoked from our parent's ABORT-READING-NEW-MAIL message to clean up a single inbox.
(DEFMETHOD (ABORT-LOADING-INBOX INBOX-BUFFER) ()
  (CL:ECASE STATUS
    ((:IDLE :KILLED))				;Nothing need be done.
    ((:LOADING :LOADED)
     ;; Flush all knowledge of any files yet to be read, close the stream,
     ;; and self destruct which will get rid of any messages that might have been read.
     (SETQ FILE-BEING-READ NIL
	   FILES-BEING-INSERTED NIL)
     (CLOSE-INBOX-FILE :ABORT T)
     (KILL-SEQUENCE SELF :ABORT T))
    ((:PARSING :INSERTED)
     ;; Simply self destruct -- Any messages we read have already been inserted into
     ;; our parent buffer and it will kill them.
     (KILL-SEQUENCE SELF :ABORT T))))

;;; Checking for new mail --
;;;
;;;    Every mail file may have one or more default inboxes used to read new mail.  In order
;;;    to aid the user, whenever a mail file is loaded, we add a background request per inbox
;;;    to periodically check for new mail.  These background requests are placed in a
;;;    separate queue all of whose entries are executed by the background process whenever
;;;    the Zmail frame is exposed (ZMAIL-BACKGROUND-CHECK-FOR-NEW-MAIL).  Each request is
;;;    responsible for deciding when to actually probe the file computer for new mail.
;;;
;;;    In addition, the Check For New Mail command may be issued to explicitly check for
;;;    new mail from the foreground.  When this is done, the automatic reminders issued by
;;;    the background are disabled until new mail arrives again.

(DEFVAR *INBOX-CHECK-PERIOD* (* 60. 30.))	;Check every 30 seconds ...
(DEFVAR *INBOX-CHECK-MAX-IDLE-TIME* (* 60. 60. 15.))	;... unless idle more than 15 minutes.
(DEFVAR *INBOX-CHECK-REPEAT-INTERVAL* (* 60. 60. 5))	;Repeat announcement every 5 minutes.

;;; Command interface --
;;;    Checking for new mail in the foreground will suppress periodic reminders from the
;;;    background until some mail arrives after the last use of this command.
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-CHECK-FOR-NEW-MAIL
				"Check whether there is new mail on the file computer."
				(NO-SEQUENCE-OK)
  (DOLIST (SEQUENCE *SEQUENCE-LIST*)
    (WHEN (SEQUENCE-BUFFER-P SEQUENCE)
      (QUEUE-MAIL-CHECK-REQUESTS SEQUENCE)))
  (LET ((MAIL-CHECK-QUEUE (LOCATION-CONTENTS *ZMAIL-BACKGROUND-MAIL-CHECK-QUEUE*)))
    (IF (NULL MAIL-CHECK-QUEUE)
	(BARF "No mail files with known inboxes have been loaded.")
      (UNLESS (LOOP WITH PRINTED-SOMETHING = NIL
		    FOR MAIL-CHECK-REQUEST IN MAIL-CHECK-QUEUE
		    WHEN (PLUSP (CHECK-FOR-NEW-MAIL MAIL-CHECK-REQUEST :FOREGROUND T))
		      DO (SETQ PRINTED-SOMETHING T)
		    FINALLY
		      (RETURN PRINTED-SOMETHING))
	(TYPEIN-LINE "No new mail."))))
  DIS-NONE)

;;; Probing a file will sometimes hang if the foreign host stops responding so we
;;; arrange to signal this condition if it takes more than a minute to probe the inbox.
;;; If we do timeout, we'll defer background checking just as we do for I/O errors.
(DEFFLAVOR MAIL-CHECK-TIMEOUT
	(INBOX-PATHNAME SEQUENCE)
	(ERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:INIT-KEYWORDS :DIRECTION :STREAM))

(DEFMETHOD (DBG:REPORT MAIL-CHECK-TIMEOUT) (STREAM)
  (FORMAT STREAM "Timeout checking for new mail in ~A for ~A" INBOX-PATHNAME SEQUENCE))

(COMPILE-FLAVOR-METHODS MAIL-CHECK-TIMEOUT)

;;; New mail check background request --
;;;    Defines a flavor with the necessary state variables to check for new mail
;;;    in the specified inbox on behalf of a specific mail file.
(DEFINE-ZMAIL-BACKGROUND-REQUEST MAIL-CHECK (INBOX-PATHNAME
					     &AUX (LAST-NEW-MAIL-TIME 0)
						  (LAST-TIME-CHECKED 0)
						  (LAST-TIME-DISPLAYED 0)
						  (FOREGROUND-CHECKED NIL))
     (:USES-SEQUENCE T
      :PRINT-FORMAT "in ~A" :PRINT-FORMAT-ARGS (INBOX-PATHNAME))
  (TRAP-BACKGROUND-ERRORS ((ERROR)
			   "Error checking for new mail in ~A for ~A" INBOX-PATHNAME SEQUENCE)
			  ()
       (ZMAIL-BACKGROUND-REQUEST-COMPLETE)	;Stop checking if anything unexpected occurs.
    (CONDITION-CASE ()
	 (NET:WITH-STREAM-TIMEOUT (NIL :CONNECT (* 60. 60.)
				       'MAIL-CHECK-TIMEOUT :INBOX-PATHNAME INBOX-PATHNAME
							   :SEQUENCE SEQUENCE)
2	   0(CHECK-FOR-NEW-MAIL SELF))
       ((MAIL-CHECK-TIMEOUT FS:FILE-ERROR SYS:REMOTE-NETWORK-ERROR)
	;; Some form of I/O failure -- stop checking for 5 minutes.
	(SETQ LAST-TIME-CHECKED (TIME-INCREMENT (TIME) (* 60. 60. 5))))
       (FS:LOGIN-REQUIRED
	 ;; User would have to login -- just try again when next appropriate.
	 (SETQ LAST-TIME-CHECKED (TIME)))
       (:NO-ERROR
	 ;; Check was made OK.
	 (SETQ LAST-TIME-CHECKED (TIME))))
    (ZMAIL-BACKGROUND-REQUEST-INCOMPLETE)))

1;;; Actual check for new mail --
;;;    Invoked by both the background request and the foreground command.
0(DEFMETHOD (CHECK-FOR-NEW-MAIL ZMAIL-MAIL-CHECK-BACKGROUND-REQUEST) (&KEY FOREGROUND)
  (DECLARE (VALUES . (LAST-NEW-MAIL-TIME)))
  (WHEN FOREGROUND
    (SETQ FOREGROUND-CHECKED T))		1;Suppress reminders if user explicitly asks.
0  (WHEN (OR FOREGROUND
	    1;; Don't check too often or if the user's been idle a long time...
0	    (AND ( (TIME-DIFFERENCE (TIME) LAST-TIME-CHECKED) *INBOX-CHECK-PERIOD*)
		 (> *INBOX-CHECK-MAX-IDLE-TIME* (TIME-DIFFERENCE (TIME)
								 TV:KBD-LAST-ACTIVITY-TIME))))
    (CONDITION-CASE-IF FOREGROUND
		       (.ERROR.)
	 (LET* ((TRUENAME (PROBEF INBOX-PATHNAME))
		(CREATION-DATE (WHEN TRUENAME
				 (GET (SEND TRUENAME :PROPERTIES) :CREATION-DATE))))
	   (LABELS ((HHMM (TIME)
		      (TV:WHOLINE-WATCH-STRING-FROM-TIME TIME :INCLUDE-DAY-OF-THE-WEEK NIL
							 :INCLUDE-DATE NIL))
		    (ANNOUNCE-NEW-MAIL-FROM-BACKGROUND ()
		      (QUEUE-ZMAIL-BACKGROUND-RESPONSE TYPEIN-LINE-DURABLE
						       "New mail in ~A for ~A at ~A."
						       INBOX-PATHNAME SEQUENCE
						       (HHMM CREATION-DATE))
		      (SETQ LAST-TIME-DISPLAYED (TIME))))
	     (WHEN CREATION-DATE
	       1;; There's new mail ...
0	       (IF (> CREATION-DATE LAST-NEW-MAIL-TIME)
		   1;; ... and some has arrived since we last announced it.
0		   (IF FOREGROUND
		       (TYPEIN-LINE "New mail in ~A for ~A at ~A."
				    INBOX-PATHNAME SEQUENCE (HHMM CREATION-DATE))
		     (ANNOUNCE-NEW-MAIL-FROM-BACKGROUND)
		     (SETQ FOREGROUND-CHECKED NIL))	1;We can start issuing reminders again.
0		 1;; ... but nothing new has arrived since our last announcement ...
0		 (IF FOREGROUND
		     1;; ... but we always announce new mail if called from the foreground.
0		     (TYPEIN-LINE "New mail in ~A for ~A at ~A as previously reported."
				  INBOX-PATHNAME SEQUENCE (HHMM CREATION-DATE)) 
		   1;; ... so we might want to remind the user.
0		   (WHEN (AND (NOT FOREGROUND-CHECKED)
			      *INBOX-CHECK-REPEAT-INTERVAL*
			      (> (TIME-DIFFERENCE (TIME) LAST-TIME-DISPLAYED)
				 *INBOX-CHECK-REPEAT-INTERVAL*))
		     (ANNOUNCE-NEW-MAIL-FROM-BACKGROUND))))
	       (SETQ LAST-NEW-MAIL-TIME CREATION-DATE)))
	   1;; Update our record of when mail last arrived.
0	   (SETQ LAST-NEW-MAIL-TIME (OR CREATION-DATE 0)))
       1;; Handle I/O errors during foreground checks --
0       1;;    Print the appropriate error message and return a positive value to inform our
0       1;;    caller that something was printed and he'd better not claim there's no new mail.
0       ((FS:FILE-ERROR SYS:NETWORK-ERROR)
	(TYPEIN-LINE "Unable to check for new mail in ~A for ~A:~%~@4T~~A~"
		     INBOX-PATHNAME SEQUENCE .ERROR.)
	1))))

(DEFUN QUEUE-MAIL-CHECK-REQUESTS (BUFFER)
  (WITH-BACKGROUND-PROCESS-LOCKED
    (LET ((OLD-MAIL-CHECK-REQUESTS
	    (FLUSH-ZMAIL-BACKGROUND-REQUESTS-INTERNAL *ZMAIL-BACKGROUND-MAIL-CHECK-QUEUE*
						      BUFFER 'MAIL-CHECK))
	  (INBOX-PATHNAMES (INBOX-PATHNAMES BUFFER)))
      (DOLIST (INBOX-PATHNAME INBOX-PATHNAMES)
	(LET ((OLD-REQUEST
		(CL:FIND INBOX-PATHNAME OLD-MAIL-CHECK-REQUESTS
			 :KEY #'ZMAIL-MAIL-CHECK-BACKGROUND-REQUEST-INBOX-PATHNAME)))
	  (IF OLD-REQUEST
	      (PUSH OLD-REQUEST (LOCATION-CONTENTS *ZMAIL-BACKGROUND-MAIL-CHECK-QUEUE*))
	    (QUEUE-ZMAIL-BACKGROUND-REQUEST-INTERNAL *ZMAIL-BACKGROUND-MAIL-CHECK-QUEUE*
						     'MAIL-CHECK BUFFER INBOX-PATHNAME)))))))

1;;; Complete any I/O in progress for the given mail file --
;;;    Invoked by operations which require that a mail file be dormant, this function
;;;    usurps any background I/O activity on the file and completes it immediately in
;;;    the foreground.
;;;
;;;    Certain operations (e.g., 2:map-over-msgs1) only require that the mail file be
;;;    loaded.  For these operations, the 2:ignore-saves 1keyword should be used to
;;;    tell this function not to try to complete background saves in the foreground but
;;;    to let them proceed normally.
;;;
;;;    Other operations (e.g., 2save-mail-file1, 2sort-sequence1) know that any background
;;;    save operation should be aborted.  For 2save-mail-file1, a foreground save is about
;;;    to be started and there's no need to save the file twice.  For operations like
;;;    2sort-sequence1, the mail file is about to be significantly modified and a new save
;;;    will be immediately required.  For all of these operations, the 2:abort-saves
1;;;    keyword should be used.
;;;
;;;    Note -- This function appears here in the source so that all the background request
;;;    types it references will be defined before it is compiled to avoid compiler warnings.
0(DEFUN COMPLETE-MAIL-FILE-IO (BUFFER &KEY IGNORE-SAVES ABORT-SAVES)
  (CL:CHECK-TYPE BUFFER FILE-MAIL-BUFFER "a mail file buffer")
  (CATCH-IF-NOT-DEBUGGER-MENU-CONDITION (ZMAIL-FILE-ERROR FS:FILE-ERROR SYS:NETWORK-ERROR)
					(.ERROR.)
       (BARF "~A" .ERROR.)
    (LET-GLOBALLY ((*ZMAIL-SAVE-IN-PROGRESS* T))
      (WITH-BACKGROUND-PROCESS-LOCKED
	(LOCK-BUFFER-AND-INBOXES (BUFFER :WRITE)
	  (LOOP WITH DESIRED-STATES = (IF IGNORE-SAVES
					  '(:IDLE :KILLED :SAVING :SAVED)
					  '(:IDLE :KILLED))
		WITH FLUSHED-REQUESTS
		UNTIL (MEMQ (MSG-BUFFER-STATUS BUFFER) DESIRED-STATES)
		DOING
1	    ;; Flush pending background requests on each pass --
	    ;;    Some of the processing below will queue new background requests which
	    ;;    we will presently complete in the foreground.  However, we must restore
	    ;;    any 2parse-old-msgs1 requests as they have no effect on I/O and are not
	    ;;    completed by this function.
0	    (SETQ FLUSHED-REQUESTS (FLUSH-ZMAIL-BACKGROUND-REQUESTS BUFFER))
	    (MULTIPLE-VALUE-BIND (FOUND START END)
		(LOOP FOR FR IN FLUSHED-REQUESTS
		      WHEN (TYPEP FR 'ZMAIL-PARSE-OLD-MSGS-BACKGROUND-REQUEST)
			RETURN (VALUES T
				       (ZMAIL-PARSE-OLD-MSGS-BACKGROUND-REQUEST-START FR)
				       (ZMAIL-PARSE-OLD-MSGS-BACKGROUND-REQUEST-END FR)))
	      (WHEN FOUND
		(QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-OLD-MSGS BUFFER :START START
								      :END END)))
	    (COMPLETE-MAIL-FILE-IO-SINGLE-STEP BUFFER FLUSHED-REQUESTS ABORT-SAVES)))))))

(ZWEI:DEFINDENTATION (PROTECTED 1 1))		1;Kludge to make the following indent properly.

;;; Split from the above for convenience...
0(DEFUN COMPLETE-MAIL-FILE-IO-SINGLE-STEP (BUFFER FLUSHED-REQUESTS ABORT-SAVES)
  (MACROLET ((PROTECTED (((OPERATION &REST OPERATION-ARGS)
			  (ABORTING-CONSEQUENCES &REST ABORTING-CONSEQUENCES-ARGS))
			 &BODY BODY)
	       `(WITH-STACK-LIST (OPERATION-ARGS ,@OPERATION-ARGS)
		  (WITH-STACK-LIST (ABORTING-CONSEQUENCES-ARGS ,@ABORTING-CONSEQUENCES-ARGS)
		    (SYS:WITHOUT-ABORTS
		        ("Zmail is ~?~@[~@
			  in preparation for executing the ~'i~A~ command~].~@
			  Aborting now would ~?."
			 ,OPERATION OPERATION-ARGS
			 (AND *CURRENT-ZMAIL-TOP-LEVEL-COMMAND*
			      (ZWEI:COMMAND-NAME *CURRENT-ZMAIL-TOP-LEVEL-COMMAND*))
			 ,ABORTING-CONSEQUENCES ABORTING-CONSEQUENCES-ARGS)
		      ,@BODY)))))
    (LABELS ((NOTIFY (FORMAT-STRING &REST FORMAT-ARGS)
	       (BEEP)
	       (CL:APPLY 'TYPEIN-LINE FORMAT-STRING FORMAT-ARGS)))
      1;; Complete processing of the current state as appropriate.
0      (CL:ECASE (MSG-BUFFER-STATUS BUFFER)
	(:LOADING
	  1;; Mail file was loading in the background -- Do it here.
0	  (NOTIFY "Reading the rest of ~A file ~A in the foreground ..."
		  (SEND BUFFER :FORMAT-NAME) (CL:TRUENAME (MSG-BUFFER-STREAM BUFFER)))
	  (PROTECTED (("reading the rest of ~A file ~A"
		       (SEND BUFFER :FORMAT-NAME) (CL:TRUENAME (MSG-BUFFER-STREAM BUFFER)))
		      ("also abort reading the file ~
		        which will kill any messages already read.~@
		        If you abort now, you will have to re-execute ~
			~:[the ~'b~S~ form~*~;~*the ~'i~A~ command~]~@
			in order to start reading this file again"
		       (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES BUFFER)
		       'ZWEI:PRELOAD-ZMAIL 'ZWEI:COM-GET-NEW-MAIL-FROM-INBOX))
	    (CREATE-BUFFER-AND-LOAD-MAIL-FILE-INTERNAL BUFFER NIL
						       :ALREADY-OPEN T
						       :DISPLAY-TOTALS-ONLY T)))
	(:LOADED
	  1;; Mail file finished loading in the background but we haven't processed
0	  1;; the 2load-mail-file-msgs-done1 response yet -- Finish loading it here.
0	  (NOTIFY "Cleaning up after reading ~A file ~A in the background ..."
		  (SEND BUFFER :FORMAT-NAME) (CL:TRUENAME (MSG-BUFFER-STREAM BUFFER)))
	  (PROTECTED (("cleaning up after reading ~A file ~A in the background"
		       (SEND BUFFER :FORMAT-NAME) (CL:TRUENAME (MSG-BUFFER-STREAM BUFFER)))
		      ("leave the file buffer in an inconsistent state~@[~*~@
		        and would also leave the new messages in the buffer unparsable~@
			until after the next ~'i~A~ command~]"
		       (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES BUFFER)
		       'ZWEI:COM-GET-NEW-MAIL-FROM-INBOX))
	    (FINISH-LOADING-MAIL-FILE BUFFER :DISPLAY-TOTALS T)))
	(:READING-NEW-MAIL
	  1;; Reading new mail into the mail file -- We'll only find this state if
	  ;; the inboxes are being parsed in the background.  Finish parsing the
	  ;; messages and then finish reading the new mail.
0	  (NOTIFY "Processing new mail for ~A in the foreground ..." (SEQUENCE-NAME BUFFER))
	  (UNWIND-PROTECT-CASE ()
	      (WHEN (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES BUFFER)
		(LABELS ((SET-RECENT-AND-INFORM-PARENT (IGNORE MSG)
			   (DECLARE (SYS:DOWNWARD-FUNCTION))
			   (UNLESS (CL:GETF (MSG-STATUS MSG) 'RECENT)
			     (SEND BUFFER :NEW-MSG MSG T)
			     (SETF (CL:GETF (MSG-STATUS MSG) 'RECENT) T))))
		  (PARSE-MSGS BUFFER :START (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES BUFFER)
				     :END (+ (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES BUFFER)
					     (FILE-MAIL-BUFFER-TOTAL-MSGS-FROM-INBOXES BUFFER))
				     :PROGRESS-NOTE (FORMAT NIL "Parsing new messages in ~A."
							    (SEQUENCE-NAME BUFFER))
				     1;; Get the parsing done as well as possible.
0				     :HANDLE-ERRORS :IGNORE
				     :POST-PARSING-FUNCTION #'SET-RECENT-AND-INFORM-PARENT))
		(LOOP FOR INBOX-BUFFER IN (FILE-MAIL-BUFFER-INBOXES-BEING-INSERTED BUFFER)
		      WHEN (EQ (MSG-BUFFER-STATUS INBOX-BUFFER) :PARSING)
			DO (SETF (MSG-BUFFER-STATUS INBOX-BUFFER) :INSERTED)))
	    (:ABORT
	      1;; If the user aborts here, we can safely requeue the parse request.
0	      (QUEUE-ZMAIL-BACKGROUND-REQUEST PARSE-NEW-MSGS
					      BUFFER
					      :START (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES
						       BUFFER)
					      :END (+ (FILE-MAIL-BUFFER-FIRST-MSG-FROM-INBOXES
							BUFFER)
						      (FILE-MAIL-BUFFER-TOTAL-MSGS-FROM-INBOXES
							BUFFER)))))
	  (PROTECTED (("processing new mail for ~A" (SEQUENCE-NAME BUFFER))
		      ("leave the file buffer in an inconsistent state~@
		        and would also leave the new messages in the buffer unparsable~@
			until after the next ~'i~A~ command"
		       'ZWEI:COM-GET-NEW-MAIL-FROM-INBOX))
	    (FINISH-READING-NEW-MAIL BUFFER :FORCE T)))
	(:SAVING
1	  ;; Mail file is being saved in the background -- Do it here or abort.
0	  (IF ABORT-SAVES
	      (ABORT-SAVING-MAIL-FILE BUFFER)
	    (NOTIFY "Saving the rest of ~A file ~A in the foreground ..."
		    (SEND BUFFER :FORMAT-NAME) (SEQUENCE-NAME BUFFER))
	    (PROTECTED (("saving the rest of ~A file ~A"
			 (SEND BUFFER :FORMAT-NAME) (SEQUENCE-NAME BUFFER))
			("also abort saving the file"))
	      (MULTIPLE-VALUE-BIND (MFSS START)
		  (LOOP FOR REQUEST IN FLUSHED-REQUESTS
			WHEN (TYPEP REQUEST 'ZMAIL-SAVE-MAIL-FILE-MSGS-BACKGROUND-REQUEST)
			  RETURN (VALUES
				   (ZMAIL-SAVE-MAIL-FILE-MSGS-BACKGROUND-REQUEST-MFSS REQUEST)
				   (ZMAIL-SAVE-MAIL-FILE-MSGS-BACKGROUND-REQUEST-NEXT-MSG
				     REQUEST)))
		(SAVE-MAIL-FILE-INTERNAL BUFFER :ALREADY-OPEN T
						:OLD-MFSS MFSS :START START)))))
	(:SAVED
1	  ;; Mail file finished saving in the background but we haven't processed
0	  1;; the 2save-mail-file-msgs-done1 response yet -- Do it here or abort.
0	  (IF ABORT-SAVES
	      (ABORT-SAVING-MAIL-FILE BUFFER)
	    (NOTIFY "Cleaning up after saving ~A file ~A in the background ..."
		    (SEND BUFFER :FORMAT-NAME) (SEQUENCE-NAME BUFFER))
	    (PROTECTED (("cleaning up after saving ~A file ~A"
			 (SEND BUFFER :FORMAT-NAME) (SEQUENCE-NAME BUFFER))
			("leave the file buffer in an inconsistent state"))
	      (FINISH-SAVING-MAIL-FILE BUFFER :SAVED))))))))

;;; Assure that a mail file is completely loaded.
(DEFUN ASSURE-MAIL-BUFFER-FULLY-LOADED (BUFFER)
  (SEND BUFFER :EXPUNGE-IF-NEEDED)
  (WHEN (MEMQ (MSG-BUFFER-STATUS BUFFER) '(:LOADING :LOADED))
    (COMPLETE-MAIL-FILE-IO BUFFER :IGNORE-SAVES T)))

1;;; Abort any I/O in progress for the given mail file --
0(DEFUN ABORT-MAIL-FILE-IO (BUFFER)
  (CL:CHECK-TYPE BUFFER FILE-MAIL-BUFFER "a mail file buffer")
  (WITH-BACKGROUND-PROCESS-LOCKED
    (FLUSH-ZMAIL-BACKGROUND-REQUESTS BUFFER)
    (LOCK-BUFFER-AND-INBOXES (BUFFER :WRITE)
      (LOOP UNTIL (MEMQ (MSG-BUFFER-STATUS BUFFER) '(:IDLE :KILLED))
	    DOING
	(CL:ECASE (MSG-BUFFER-STATUS BUFFER)
	  ((:LOADING :LOADED)
	   (ABORT-LOADING-MAIL-FILE BUFFER))
	  (:READING-NEW-MAIL
	    (ABORT-READING-NEW-MAIL BUFFER))
	  ((:SAVING :SAVED)
	   (ABORT-SAVING-MAIL-FILE BUFFER)))))))

;;; Simple write-only mail files without separators
(DEFFLAVOR TEXT-MAIL-BUFFER () (FILE-MAIL-BUFFER))

(ADD-MAIL-BUFFER-FLAVOR 'TEXT-MAIL-BUFFER "Text" "Messages separated by blank lines.")

(DEFMETHOD (:FORMAT-NAME TEXT-MAIL-BUFFER) () "Text")

(DEFMETHOD (:MAIL-FILE-REPARSABLE-P TEXT-MAIL-BUFFER) () NIL)

;;; If we try to read one of these in, get one big message
(DEFMETHOD (LINE-END-OF-MSG-P TEXT-MAIL-BUFFER) (LINE LENGTH STATE EOF)
  (IGNORE LINE LENGTH STATE)
  EOF)						;Not end of message until end of file.

;;; Write a message -- Add the separator.
(DEFMETHOD (SAVE-MSG TEXT-MAIL-BUFFER :AFTER) (MSG MAIL-FILE-SAVING-STATE)
  (IGNORE MSG MAIL-FILE-SAVING-STATE)
  (SEND STREAM :FRESH-LINE)
  (SEND STREAM :STRING-OUT *TEXT-MAIL-FILE-SEPARATOR*)
  (SEND STREAM :FRESH-LINE))

;;; Always save the reformatted headers.  Output isn't expected to be parsable.
(DEFMETHOD (:SAVE-ORIGINAL-HEADER TEXT-MAIL-BUFFER) (MSG)
  MSG
  NIL)
