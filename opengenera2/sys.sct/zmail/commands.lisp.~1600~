;;; -*- Mode:LISP; Package:ZWEI; Base:8 -*- 
;;; Lisp Machine mail reader
;;; Zmail Commands
;;; Definitions in DEFS
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; Set up main command table

(DEFUN INITIALIZE-ZMAIL-COMTABS (MODE-COMTAB MODE-CONTROL-X-COMTAB)
  (SET-COMTAB MODE-COMTAB '(#\h-F COM-FORWARD-ADDRESS
			    #\h-B COM-BACKWARD-ADDRESS
			    #\h-K COM-KILL-ADDRESS
			    #\h-RUBOUT COM-BACKWARD-KILL-ADDRESS
			    #\h-T COM-EXCHANGE-ADDRESSES
			    #\c-sh-W COM-WHOIS-ADDRESS
			    ))
  (SET-COMTAB MODE-CONTROL-X-COMTAB '(#/A COM-ADD-MORE-TEXT
				      #/C COM-ADD-CC-FIELD
				      #/S COM-ADD-SUBJECT-FIELD
				      #/T COM-ADD-TO-FIELD))

  (SETQ *ZMAIL-COMTAB* (SET-COMTAB "Zmail"
			 '(
			   #\Keyboard:Down COM-ZMAIL-NEXT
			   #\Control-Keyboard:Down COM-ZMAIL-DOWN-TO-NEXT
			   #\Meta-Keyboard:Down COM-ZMAIL-NEXT-UNSEEN
			   #\Keyboard:Up COM-ZMAIL-PREVIOUS
			   #\Control-Keyboard:Up COM-ZMAIL-UP-TO-PREVIOUS
			   #\Meta-Keyboard:Up COM-ZMAIL-PREVIOUS-UNSEEN
			   #\Keyboard:Home COM-ZMAIL-START-OF-MSG
			   #\Control-Keyboard:Home COM-START-OF-SUMMARY-WINDOW
			   #\Keyboard:Back-Scroll COM-ZMAIL-SCROLL-MSG-PREVIOUS-SCREEN
			   #\Control-Keyboard:Back-Scroll COM-SCROLL-BACK-TYPEOUT-WINDOW
			   #\Keyboard:Find COM-ZMAIL-FIND-STRING
			   #\Keyboard:Undo COM-ZMAIL-UNDO
			   #\Keyboard:Redo COM-ZMAIL-REDO
			   #\c-D COM-ZMAIL-DELETE-AND-UP
			   #\c-F COM-ZMAIL-FIND-STRING
			   #\c-G COM-BEEP
			   #\c-L COM-ZMAIL-RECENTER-MSG-OR-SUMMARY-WINDOW
			   #\c-N COM-ZMAIL-DOWN-TO-NEXT
			   #\c-P COM-ZMAIL-UP-TO-PREVIOUS
			   #\c-R COM-EDIT-CURRENT-MSG
			   #\c-U COM-QUADRUPLE-NUMERIC-ARG
			   #\c-V COM-ZMAIL-SCROLL-MSG-NEXT-SCREEN
			   #\c-Z COM-QUIT
			   #\c-SP COM-ZMAIL-SET-POP-MARK
			   #\m-N COM-ZMAIL-NEXT-UNSEEN
			   #\m-P COM-ZMAIL-PREVIOUS-UNSEEN
			   #\m-V COM-ZMAIL-SCROLL-MSG-PREVIOUS-SCREEN
			   #\m-X COM-ZMAIL-EXTENDED-COMMAND
			   #\m-< COM-ZMAIL-START-OF-MSG
			   #\m-> COM-ZMAIL-END-OF-MSG
			   #\m-? COM-ZMAIL-SELF-DOCUMENT
			   #\m-~ COM-ZMAIL-NOT-MODIFIED
			   #\c-m-L COM-ZMAIL-SELECT-PREVIOUS-SEQUENCE
			   #\c-m-V COM-SCROLL-SUMMARY-WINDOW
			   #\c-m-sh-V COM-SCROLL-SUMMARY-WINDOW-BACKWARD
			   #\c-m-< COM-START-OF-SUMMARY-WINDOW
			   #\c-m-> COM-END-OF-SUMMARY-WINDOW
			   #\c-m-Y COM-ZMAIL-REPEAT-LAST-MINI-BUFFER-COMMAND
			   #\c-m-sh-Y COM-ZMAIL-REPEAT-LAST-MATCHING-MINI-BUFFER-COMMAND
			   #\c-m-SP COM-ZMAIL-MOVE-TO-PREVIOUS-POINT
			   #\c-m-? COM-DOCUMENTATION
			   #\m-sh-D COM-SHOW-DOCUMENTATION
			   #/. COM-ZMAIL-START-OF-MSG
			   #/? COM-ZMAIL-HELP
			   #/C COM-ZMAIL-CONTINUE
			   #/D COM-ZMAIL-DELETE
			   #/E COM-ZMAIL-EXPUNGE-SEQUENCE
			   #/F COM-ZMAIL-FORWARD
			   #/G COM-GET-NEW-MAIL-FROM-INBOX
			   #/H COM-ZMAIL-REFORMAT-HEADERS
			   #/J COM-ZMAIL-JUMP
			   #/L COM-ZMAIL-KEYWORDS
			   #/M COM-ZMAIL-MAIL
			   #/N COM-ZMAIL-NEXT
			   #/O COM-ZMAIL-MOVE
			   #/P COM-ZMAIL-PREVIOUS
			   #/Q COM-ZMAIL-QUIT
			   #/R COM-ZMAIL-REPLY
			   #/S COM-ZMAIL-SAVE-ALL-MAIL-FILES
			   #/U COM-ZMAIL-UNDELETE
			   #/X COM-ZMAIL-EXTENDED-COMMAND
			   #/Z COM-ZMAIL-LARGE-ARGUMENT
			   #\Meta-W COM-SAVE-REGION
			   #\BREAK COM-ZMAIL-BREAK
			   #\BS COM-ZMAIL-SCROLL-MSG-PREVIOUS-SCREEN
			   #\SCROLL COM-ZMAIL-SCROLL-MSG-NEXT-SCREEN
			   #\m-SCROLL COM-ZMAIL-SCROLL-MSG-PREVIOUS-SCREEN
			   #\c-Scroll COM-SCROLL-TYPEOUT-WINDOW
			   #\c-m-Scroll COM-SCROLL-BACK-TYPEOUT-WINDOW
			   #\HELP COM-ZMAIL-HELP
			   #\REFRESH COM-ZMAIL-REFRESH
			   #\RESUME COM-ZMAIL-CONTINUE
			   #\SP COM-ZMAIL-SCROLL-MSG-NEXT-SCREEN
			   #/- COM-NEGATE-NUMERIC-ARG
			   #\c-- COM-NEGATE-NUMERIC-ARG
			   #\m-- COM-NEGATE-NUMERIC-ARG
			   #\c-m-- COM-NEGATE-NUMERIC-ARG
			   (#/0 10.) COM-NUMBERS
			   (#\c-0 10.) COM-NUMBERS
			   (#\m-0 10.) COM-NUMBERS
			   (#\c-m-0 10.) COM-NUMBERS
			   )))

  (SETQ *ZMAIL-CONTROL-X-COMTAB* (SET-COMTAB "Zmail Control-X"
					     '(#\B COM-ZMAIL-SELECT-SEQUENCE
					       #\c-B COM-ZMAIL-LIST-SEQUENCES
					       #\c-F COM-ZMAIL-EDIT-MAIL-FILE
					       #\c-sh-F COM-ZMAIL-EDIT-FILE
					       #\K COM-ZMAIL-KILL-SEQUENCE
					       #\M COM-ZMAIL-MAIL
					       #\c-R COM-ZMAIL-EXAMINE-MAIL-FILE
					       #\c-S COM-ZMAIL-SAVE-MAIL-FILE)))
  (SET-COMTAB *ZMAIL-COMTAB* `(#\c-X ,(MAKE-EXTENDED-COMMAND *ZMAIL-CONTROL-X-COMTAB*)))

  (SET-COMTAB *ZMAIL-COMTAB* `(#\MOUSE-R ,(MAKE-MENU-COMMAND
					    '(COM-ZMAIL-SELECT-CONVERSATION-BY-REFERENCES
					       COM-ZMAIL-FORWARD COM-ZMAIL-REDIRECT-MSG
					       COM-ZMAIL-REDISTRIBUTE-MSG
					       COM-ZMAIL-HARDCOPY-MSG
					       COM-ZMAIL-KILL-RING-SAVE-MSG
					       COM-SET-EXPIRATION-DATE COM-SET-START-DATE
					       COM-ZMAIL-SET-MSG-DEFAULT-CHARACTER-STYLE
					       COM-EXPLAIN-BAD-HEADER COM-SHOW-RECEIVED-PATH
					       COM-ZMAIL-ENCRYPT-MSG COM-ZMAIL-DECRYPT-MSG
					       COM-ZMAIL-UNDIGESTIFY
					       COM-ADD-FILE-REFERENCES COM-ZMAIL-SHOW-FILE
					       COM-ZMAIL-HARDCOPY-FILE COM-ZMAIL-EDIT-FILE
					       COM-ZMAIL-COMPILE-FILE COM-ZMAIL-LOAD-FILE
					       COM-ZMAIL-SHOW-MAILING-LIST)
					    #'ZMAIL-CHOOSE-MENU-COMMAND)))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")  ;; 0Zmail1 has a policy that the 0m-X1 and0 Mouse-Right1 commands lists be identical in the
  ;; message editor's comtab.  However, 0Show Expanded Mailing List1,0 1which is a synonym for
  ;; 0Show Mailing List1, is not included in the0 Mouse-Right 1menu but0 1is available via0 m-X1.
0  (LET ((COMMAND-LIST '(COM-ADD-TO-FIELD COM-ADD-CC-FIELD COM-ADD-BCC-FIELD
			COM-ADD-FCC-FIELD COM-ADD-BFCC-FIELD COM-ADD-SUBJECT-FIELD
			COM-ADD-IN-REPLY-TO-FIELD COM-ADD-REFERENCES-FIELD
			COM-ADD-MORE-TEXT COM-ADD-FROM-FIELD COM-ADD-FILE-REFERENCE-FIELD
			COM-ADD-REPLY-TO-FIELD
			COM-ADD-START-DATE-FIELD COM-ADD-EXPIRATION-DATE-FIELD
			COM-ZMAIL-SET-MSG-DEFAULT-CHARACTER-STYLE
			COM-ZMAIL-SHOW-FILE COM-ZMAIL-HARDCOPY-FILE COM-ZMAIL-EDIT-FILE
			COM-ZMAIL-COMPILE-FILE COM-ZMAIL-LOAD-FILE
			COM-ZMAIL-SHOW-MAILING-LIST COM-ZMAIL-WHOIS)))
    (SETQ *MSG-COMTAB* (SET-COMTAB "Editing Message"
				   '(#\END COM-QUIT
				     #\c-ALTMODE COM-QUIT
				     #\ABORT COM-ZMAIL-ABORT
				     )
				   (MAKE-COMMAND-ALIST
				     (APPEND COMMAND-LIST
					     '(COM-SHOW-EXPANDED-MAILING-LIST)))))
    (SET-COMTAB *MSG-COMTAB* `(#\MOUSE-R ,(MAKE-MENU-COMMAND COMMAND-LIST))))
  (SET-COMTAB-INDIRECTION *MSG-COMTAB* MODE-COMTAB)

  (SETQ *MSG-CONTROL-X-COMTAB* (SET-COMTAB "Composing Message Control-X" NIL))
  (SET-COMTAB-INDIRECTION *MSG-CONTROL-X-COMTAB* MODE-CONTROL-X-COMTAB)

  (SETQ *REPLY-CONTROL-X-COMTAB*
	(SET-COMTAB "Reply Control-X"
		    '(#/1 COM-ZMAIL-REPLY-ONE-WINDOW
		      #/2 COM-ZMAIL-REPLY-TWO-WINDOWS
		      #/0 COM-ZMAIL-REPLY-ZERO-WINDOWS
		      #/M COM-ZMAIL-RECURSIVE-MAIL
		      #/O COM-ZMAIL-OTHER-WINDOW
		      #/Y COM-PRUNE-YANKED-HEADERS
		      #\c-R COM-RESTORE-DRAFT-FILE
		      #\c-S COM-SAVE-DRAFT-FILE
		      #\c-W COM-WRITE-DRAFT-FILE
		      #\c-Y COM-ZMAIL-YANK-REPLIED-MSGS
		      #\c-m-S COM-SAVE-DRAFT-AS-MSG)))
  (SET-COMTAB-INDIRECTION *REPLY-CONTROL-X-COMTAB* *MSG-CONTROL-X-COMTAB*)

  1;; Zmail has a policy that the0 m-X1 and0 Mouse-Right1 commands lists be0 1identical in0 1the
0  1;; draft editor's comtab.  Therefore, 0Yank Replied Messages1 is available both as0 c-X c-Y
  1;; and0 1via0 m-X 1in order to be sure that it appears in the0 Mouse-Right1 menu along with
0  1;; 0Yank Current Message1.  There is one exception, however.  0Show Expanded Mailing List1,
0  1;; which0 1is a synonym for0 Show Mailing List1, is not0 1included in the0 Mouse-Right1 menu but
0  1;; is only0 1available via0 m-X1.
0  (LET ((COMMAND-LIST '(COM-ADD-TO-FIELD COM-ADD-CC-FIELD COM-ADD-BCC-FIELD
			COM-ADD-FCC-FIELD COM-ADD-BFCC-FIELD COM-ADD-SUBJECT-FIELD
			COM-ADD-IN-REPLY-TO-FIELD COM-ADD-REFERENCES-FIELD
			COM-ADD-MORE-TEXT COM-ADD-FROM-FIELD COM-ADD-FILE-REFERENCE-FIELD
			COM-ADD-REPLY-TO-FIELD
			COM-ADD-START-DATE-FIELD COM-ADD-EXPIRATION-DATE-FIELD
			COM-ZMAIL-SET-DEFAULT-CHARACTER-STYLE
			COM-ZMAIL-YANK-REPLIED-MSGS COM-ZMAIL-YANK-CURRENT-MSG
			COM-PRUNE-YANKED-HEADERS
			COM-SEND-MESSAGE COM-ABORT-SEND COM-RESTORE-DRAFT-FILE
			COM-WRITE-DRAFT-FILE COM-SAVE-DRAFT-FILE COM-SAVE-DRAFT-AS-MSG
			COM-CHANGE-SUBJECT-PRONOUNS
			COM-ENCRYPT-TEXT COM-DECRYPT-TEXT
			COM-ZMAIL-SHOW-FILE COM-ZMAIL-HARDCOPY-FILE COM-ZMAIL-EDIT-FILE
			COM-ZMAIL-COMPILE-FILE COM-ZMAIL-LOAD-FILE
			COM-ZMAIL-SHOW-MAILING-LIST COM-ZMAIL-WHOIS)))
    (SETQ *REPLY-COMTAB* (SET-COMTAB "Reply"
				     '(#\END COM-MAIL-END
				       #\c-END COM-MAIL-END
				       #\c-ALTMODE COM-SEND-MESSAGE
				       #\ABORT COM-ABORT-SEND
				       #\c-Z COM-ABORT-SEND
				       #\c-] COM-ABORT-SEND)
				     (MAKE-COMMAND-ALIST
				       (APPEND COMMAND-LIST
					       '(COM-SHOW-EXPANDED-MAILING-LIST)))))
    (SET-COMTAB *REPLY-COMTAB* `(#\c-X ,(MAKE-EXTENDED-COMMAND *REPLY-CONTROL-X-COMTAB*)))
    (SET-COMTAB *REPLY-COMTAB* `(#\MOUSE-R ,(MAKE-MENU-COMMAND COMMAND-LIST))))
  (SET-COMTAB-INDIRECTION *REPLY-COMTAB* MODE-COMTAB)

  (SETQ *OTHER-COMMAND-ALIST* (MAKE-COMMAND-ALIST '(COM-ZMAIL-HARDCOPY-MSG
						    COM-ZMAIL-RENAME-SEQUENCE
						    COM-ZMAIL-SHOW-FILE
						    COM-ZMAIL-WHOIS)))

  (DOLIST (COMTAB '(*ZMAIL-COMTAB* *MSG-COMTAB* *REPLY-COMTAB*))
    (CL:PUSHNEW COMTAB *ZWEI-COMTABS-FOR-COMPRESSION*))
  (DOLIST (ALIST '(*ZMAIL-TOP-LEVEL-COMMAND-NAME-ALIST* *ZMAIL-EDITOR-COMMAND-ALIST*))
    (CL:PUSHNEW ALIST *ZWEI-COMMAND-ALISTS-FOR-COMPRESSION*)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SELF-DOCUMENT
				"ZWEI line self help"
				(NO-SEQUENCE-OK)
  (LET ((*COMTAB* *ZMAIL-COMTAB*))
    (COM-SELF-DOCUMENT)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-APROPOS
				"List commands whose names contain a given string."
				(NO-SEQUENCE-OK)
  (MULTIPLE-VALUE-BIND (FUNCTION KEY)
      (GET-EXTENDED-SEARCH-STRINGS "Apropos. (Substring:)")
    (DOLIST (X *ZMAIL-TOP-LEVEL-COMMAND-NAME-ALIST*)
      (LET ((COMMAND (CDR X)))
	(AND (FUNCALL FUNCTION KEY (COMMAND-NAME COMMAND))
	     (DOCUMENT-ZMAIL-COMMAND COMMAND))))
    (FORMAT T "~%Done.~%"))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-HELP
				"Minimal self help.
Displays the documentation of the command corresponding to
a given keystroke or menu item."
				(NO-SEQUENCE-OK)
  (FORMAT T "~2&Select command by pressing a character or clicking on the menu, ~
                or press /"*/" for all: ")
  (TV:WINDOW-CALL-RELATIVE (*TYPEOUT-WINDOW*)
    (LET ((CH (SEND STANDARD-INPUT :ANY-TYI)))
      (SI:WITH-INDENTATION (STANDARD-OUTPUT 2)
	(IF (EQL CH #/*)
	    (DOLIST (CMD (SETQ *ZMAIL-TOP-LEVEL-COMMAND-NAME-ALIST*
			       (SORTCAR *ZMAIL-TOP-LEVEL-COMMAND-NAME-ALIST* #'STRING-LESSP)))
	      (DOCUMENT-ZMAIL-COMMAND (CDR CMD)))
	  (ZMAIL-HELP-INTERNAL CH))
	(FORMAT T "~2&Press Space to remove this display, or press any other character ~
		      or click on the menu~%to execute a command: "))))
  DIS-NONE)

(DEFUN ZMAIL-HELP-INTERNAL (CH &OPTIONAL COMMAND)
  (COND (COMMAND
	 (FORMAT T "  This ~:[command~;selection~]" (LISTP COMMAND)))
	((CHARACTERP CH)
	 (COND ((SETQ COMMAND (COMMAND-LOOKUP CH *ZMAIL-COMTAB*))
		(FORMAT T "~2&~:C" CH))
	       (T
		(FORMAT T "~2&~:C is not defined.~&" CH))))
	((AND (LISTP CH) (EQ (CAR CH) ':MENU))
	 (FORMAT T "~2&This selection")
	 (SET-COMMAND-BUTTON (THIRD CH))
	 (SETQ COMMAND (CDADR CH))))
  (WHEN COMMAND
    (DOCUMENT-KEY-1 CH *ZMAIL-COMTAB* NIL COMMAND)
    (SETQ COMMAND (COND ((EQ COMMAND 'COM-ZMAIL-EXTENDED-COMMAND)
			 (LET ((COM (GET-ZMAIL-EXTENDED-COMMAND "Document Zmail command:"
								"documented")))
			   (AND (EQUAL COM "") (BARF))
			   COM))
			((EQ *ZMAIL-COMMAND-BUTTON* ':RIGHT)
			 (SELECTQ COMMAND
			   (COM-ZMAIL-MAP-OVER
			    (ZMAIL-MENU-CHOOSE *ZMAIL-MAP-COMMAND-MENU*))
			   (COM-ZMAIL-OTHER-COMMANDS
			    (ZMAIL-MENU-CHOOSE 'ZMAIL-MOMENTARY-COMMAND-MENU
					       *OTHER-COMMAND-ALIST*))
			   (OTHERWISE NIL)))))
    (WHEN COMMAND
      (SEND STANDARD-OUTPUT :TYO #\RETURN)
      (SI:WITH-INDENTATION (STANDARD-OUTPUT 2)
	(ZMAIL-HELP-INTERNAL CH COMMAND)))))

(DEFUN DOCUMENT-ZMAIL-COMMAND (COMMAND)
  (FORMAT T "~2&~25,5,2A" (COMMAND-NAME COMMAND))
  (PRINT-DOC ':SHORT COMMAND)
  (FORMAT T "~&")
  (LET ((FOUND))
    (WHEN (RASSQ COMMAND *ZMAIL-COMMAND-ALIST*)
      (FORMAT T "~&   Invoked from the main command menu~%")
      (SETQ FOUND T))
    (WHEN (RASSQ COMMAND *OTHER-COMMAND-ALIST*)
      (FORMAT T "~&   ~:[Invoked~; or~] from the /"Other/" command menu~%" FOUND)
      (SETQ FOUND T))
    (WHEN (RASSQ COMMAND *ZMAIL-MAP-COMMAND-ALIST*)
      (FORMAT T "~&  ~:[Invoked~; or~] from the /"Map over/" command menu~%" FOUND)
      (SETQ FOUND T))  
    (WHEN (> (FIND-COMMAND-ON-KEYS
	       COMMAND 4 (FORMAT NIL "   ~:[Invoked~; or~] by:  " FOUND) *ZMAIL-COMTAB*)
	     0)
      (TERPRI)
      (SETQ FOUND T))
    (UNLESS FOUND
      (FORMAT T "~&   Invoked by:  m-X ~A~%" (COMMAND-NAME COMMAND)))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DESCRIBE-COMMAND
				"Displays the full documentation for a Zmail command.
It reads the command name from the minibuffer with completion and displays
the documentation in the typeout window."
				(NO-SEQUENCE-OK)
  (LET ((COM (GET-ZMAIL-EXTENDED-COMMAND "Describe Zmail command:" "documented")))
    (WHEN (EQUAL COM "") (BARF))
    (PRINT-DOC :FULL COM))
  DIS-NONE)

1;;; Recursive means updating a substring.
0(DEFUN UPDATE-COMMAND-WHO-LINE-DOCUMENTATION (COMMAND &OPTIONAL (TELL-WHO-LINE T) RECURSIVE)
  (LET ((STRING (OR (GET COMMAND :WHO-LINE-DOCUMENTATION)
		    (MAKE-EMPTY-STRING 95.)))
	(FUNCTION (GET COMMAND 'WHO-LINE-DOCUMENTATION-UPDATER)))
    (SETF (FILL-POINTER STRING) 0)
    (PUTPROP COMMAND STRING :WHO-LINE-DOCUMENTATION)
    (CONDITION-CASE (ERROR)
	 (IF RECURSIVE
	     (FUNCALL FUNCTION STRING T)
	     (FUNCALL FUNCTION STRING))
       (ERROR
	 (SETF (FILL-POINTER STRING) 0)
	 (FORMAT STRING "** Error: ~A **" ERROR)))
    (WHEN (AND TELL-WHO-LINE TV:WHO-LINE-DOCUMENTATION-WINDOW)
      (SEND TV:WHO-LINE-DOCUMENTATION-WINDOW :SET-WHO-LINE-ITEM-STATE NIL))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-EXTENDED-COMMAND
				"Execute any top-level command"
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (LET ((COMMAND
	  (GET-ZMAIL-EXTENDED-COMMAND
	    (FORMAT NIL "Command:~:[  (Arg = ~A)~]"
		    (NOT *NUMERIC-ARG-P*)
		    (FORMAT-ARGUMENT *NUMERIC-ARG-P* *NUMERIC-ARG*)))))
      (LET ((*CURRENT-COMMAND* COMMAND))
	(FUNCALL *CURRENT-COMMAND*))))
 
(DEFUN GET-ZMAIL-EXTENDED-COMMAND (PROMPT &OPTIONAL REASON-TO-GET-COMMAND COMTAB)
  (IGNORE REASON-TO-GET-COMMAND)
  (IF COMTAB
      (GET-EXTENDED-COMMAND PROMPT COMTAB)
      (READ-EXTENDED-COMMAND-NAME *ZMAIL-TOP-LEVEL-COMMAND-NAME-ALIST* PROMPT)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")COM-ZMAIL-SET-KEY
0  "Install a Zmail command on a specified key.

If the key is currently holding a command prefix (like Control-X), it will ask
you for another character, so that you can redefine Control-X commands.  However,
with a numeric argument, it will assume you want to redefine Control-X itself,
and will not ask for another character."
				(NUMERIC-ARG-OK NO-MSG-OK)
  (LET ((*COMTAB* *ZMAIL-COMTAB*))
    (INSTALL-COMMAND-INTERNAL (GET-ZMAIL-EXTENDED-COMMAND "Command to install:" "installed")))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-LARGE-ARGUMENT
				"A large number for argument to command."
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (SETQ *NUMERIC-ARG* (* 37777777 (SIGNUM *NUMERIC-ARG*))
	*NUMERIC-ARG-P* ':INFINITY)
  ':ARGUMENT)

(DEFVAR *ZMAIL-MENU-COMMAND-LIST-ALIST* NIL)

(DEFUN ZMAIL-CHOOSE-MENU-COMMAND (COMMAND-LIST)
  (LET* ((COMMAND-LIST-DESC
	   (OR (ASSQ COMMAND-LIST *ZMAIL-MENU-COMMAND-LIST-ALIST*)
	       (FIRST (PUSH (LIST COMMAND-LIST NIL) *ZMAIL-MENU-COMMAND-LIST-ALIST*))))
	 (LAST-COMMAND (SECOND COMMAND-LIST-DESC)))
    (LOOP FOR (NIL . COMMAND) IN COMMAND-LIST
	  WHEN (GET COMMAND 'WHO-LINE-DOCUMENTATION-UPDATER)
	    DO (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION COMMAND))
    (SETQ *ZMAIL-COMMAND-BUTTON* :RIGHT)	;Always pop-up the menu...
    (MULTIPLE-VALUE-BIND (COMMAND LAST-COMMAND)
	(ZMAIL-MENU-CHOOSE 'ZMAIL-MOMENTARY-COMMAND-MENU COMMAND-LIST LAST-COMMAND
			   '(:MOUSE) NIL "Choose a command:")
      (SETF (SECOND COMMAND-LIST-DESC) LAST-COMMAND)
      COMMAND)))


1;;; c-m-Y and c-m-sh-Y --
;;;    Use the standard Zwei definitions but be sure that the proper context is established.

0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REPEAT-LAST-MINI-BUFFER-COMMAND
  "Repeats a recent minibuffer command.
A numeric argument does the nth previous one.  An argument of 0 lists which
ones are remembered."
				(NUMERIC-ARG-OK NO-SEQUENCE-OK)
  (WITH-SPECIAL-INSTANCE-VARS-BOUND-OUTSIDE-INSTANCE
        ((*COMTAB* *ZMAIL-COMTAB*))
    (COM-REPEAT-LAST-MINI-BUFFER-COMMAND)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REPEAT-LAST-MATCHING-MINI-BUFFER-COMMAND
  "Repeats a recent minibuffer command that contains a substring.
A numeric argument does the nth previous one.  An argument of 0 lists which
ones are remembered."
				(NUMERIC-ARG-OK NO-SEQUENCE-OK)
  (WITH-SPECIAL-INSTANCE-VARS-BOUND-OUTSIDE-INSTANCE
        ((*COMTAB* *ZMAIL-COMTAB*))
    (COM-REPEAT-LAST-MATCHING-MINI-BUFFER-COMMAND)))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR
  RE-EXECUTE-ZMAIL-MINI-BUFFER-COMMAND-FROM-MOUSE (MINI-BUFFER-COMMAND "Re-execute command"
								       *ZMAIL-COMTAB*
								       :GESTURE :SELECT)
						  (MINI-BUFFER-COMMAND)
  `(RE-EXECUTE-MINI-BUFFER-COMMAND-FROM-MOUSE ,MINI-BUFFER-COMMAND))

(DEFUN CHECK-IF-DANGEROUS-COMMAND-OK (DESCRIPTION &REST DESCRIPTION-ARGS)
  (WHEN (COND ((EQ *ASK-BEFORE-EXECUTING-DANGEROUS-ZMAIL-COMMANDS* :ALL))
	      ((EQ *ASK-BEFORE-EXECUTING-DANGEROUS-ZMAIL-COMMANDS* :SELECTIVE)
	       (MEMQ *CURRENT-ZMAIL-TOP-LEVEL-COMMAND* *SELECTED-DANGEROUS-ZMAIL-COMMANDS*))
	      (T NIL))
    (UNLESS (TYPEOUT-BEEP-YES-OR-NO-P "Do you really want to ~?? "
				      DESCRIPTION DESCRIPTION-ARGS)
      (ABORT-CURRENT-COMMAND))))

(DEFUN WITH-EDITOR-BINDINGS-INTERNAL (BODY MODE COMTAB MODE-LINE-LIST)
  (DECLARE (SYS:DOWNWARD-FUNARG BODY))
  (LABELS ((COPY-SPARSE-COMTAB (OLD-COMTAB NEW-COMTAB)
	     (SETF (COMTAB-KEYBOARD-ARRAY NEW-COMTAB) (COPYTREE (COMTAB-KEYBOARD-ARRAY
								  OLD-COMTAB)))
	     (SETF (COMTAB-MOUSE-ARRAY NEW-COMTAB) (COPYTREE (COMTAB-MOUSE-ARRAY OLD-COMTAB)))
	     (SETF (COMTAB-EXTENDED-COMMANDS NEW-COMTAB)
		   (WHEN (COMTAB-EXTENDED-COMMANDS OLD-COMTAB)
		     (LET ((COPY (SI:MAKE-AARRAY (ARRAY-LENGTH (COMTAB-EXTENDED-COMMANDS
								 OLD-COMTAB)))))
		       (COPY-ARRAY-CONTENTS-AND-LEADER (COMTAB-EXTENDED-COMMANDS OLD-COMTAB)
						       COPY)
		       COPY)))
	     (SETF (COMTAB-INDIRECT-TO NEW-COMTAB) (COMTAB-INDIRECT-TO OLD-COMTAB)))
	   (MAKE-SPARSE-COMTAB-COPY (OLD-COMTAB)
	     (LET ((NEW-COMTAB (CREATE-SPARSE-COMTAB (COMTAB-NAME OLD-COMTAB) T)))
	       (COPY-SPARSE-COMTAB OLD-COMTAB NEW-COMTAB)
	       NEW-COMTAB)))
    (WITH-SPECIAL-INSTANCE-VARS-BOUND-OUTSIDE-INSTANCE
      ((*COMTAB* COMTAB)
       (*STYLE* 0)
       (*STYLE-NAME* NIL)
       (*QUANTITY-MODE* NIL)
       (*QUANTITY-MODE-SAVE* NIL)
       (*MODE-QUANTITY-NAME* NIL)
       (*MODE-LINE-LIST* MODE-LINE-LIST)
       (*MODE-LIST* NIL)
       (*MAJOR-MODE* (MAJOR-MODE-FROM-KEYWORD MODE))
       (*MODE-NAME-LIST* NIL)
       (*MACRO-LEVEL* NIL)
       (*MODE-WORD-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *WORD-SYNTAX-TABLE*))
       (*MODE-LIST-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *CL-LIST-SYNTAX-TABLE*))
       (*USER-MODES-SET* NIL)
       (*COMMAND-HOOK* NIL)
       (*POST-COMMAND-HOOK* NIL))
      (LET ((OLD-MODE-COMTAB (MAKE-SPARSE-COMTAB-COPY *MODE-COMTAB*))
	    (OLD-MODE-CONTROL-X-COMTAB (MAKE-SPARSE-COMTAB-COPY *MODE-CONTROL-X-COMTAB*)))
	(SET-VARIABLE-VALUE '*STANDARD-COMMAND* 'COM-SELF-INSERT :BUFFER)
	(UNWIND-PROTECT
	    (FUNCALL BODY)
	  (COPY-SPARSE-COMTAB OLD-MODE-COMTAB *MODE-COMTAB*)
	  (COPY-SPARSE-COMTAB OLD-MODE-CONTROL-X-COMTAB *MODE-CONTROL-X-COMTAB*)
	  (SET-VARIABLE-VALUE '*STANDARD-COMMAND* 'COM-SELF-INSERT :BUFFER))))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-EDIT-CURRENT-MSG "Edit the current message" ()
  (EDIT-CURRENT-MSG))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-CURRENT-MSG
			     (BP "Edit this message" *ZMAIL-COMTAB*
				 :BLANK-AREA T
				 :GESTURE :SELECT
				 :TESTER ((BP &KEY WINDOW)
					  (EDIT-CURRENT-MSG-TESTER BP WINDOW)))
			     (BP &KEY WINDOW)
  `(MOUSE-EDIT-CURRENT-MSG ,(OR BP (MOUSE-BP (SEND WINDOW :ZWEI-WINDOW))))) 

(DEFUN EDIT-CURRENT-MSG-TESTER (BP WINDOW)
  (AND (VARIABLE-BOUNDP *MSG*)
       *MSG*
       (OR (AND BP
		(EQ (BP-TOP-LEVEL-NODE BP) (BP-TOP-LEVEL-NODE (MSG-START-BP *MSG*))))
	   (AND WINDOW
		(EQ (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW) *MSG-WINDOW*))))) 

(DEFUN MOUSE-EDIT-CURRENT-MSG (MOUSE-BP)
  (MUST-REDISPLAY *MSG-WINDOW* (EDIT-CURRENT-MSG MOUSE-BP)))

(DEFUN EDIT-CURRENT-MSG (&OPTIONAL MOUSE-BP)
  (EDIT-MSG *MSG* MOUSE-BP))

1;;; Edit a message --
;;;    At present, we can only edit the current message.  This function exists mainly to
;;;    provide a local binding of the message being edited.  Otherwise, if the user logs out
;;;    while editing a message, 2*msg*1 might be set to 2nil1 before our 2unwind-protect1 runs and
;;;    we'll try to reference it anyway and generate a trip to the debugger.
0(DEFUN EDIT-MSG (MSG &OPTIONAL MOUSE-BP)
  (UNLESS (EQ MSG *MSG*)
    (FERROR "Can only edit the current message."))
  (ZMAIL-UNDO-SAVE 'UNDO-EDIT :MSG MSG)
  1;; Edit the original headers.
0  (LET* ((REFORMATTED-P (AND (MSG-GET MSG 'REFORMATTED)
			     (MSG-GET MSG 'ORIGINAL-HEADERS-INTERVAL)))
	 (BP-IN-HEADER-P (AND MOUSE-BP (BP-< MOUSE-BP (MSG-BODY-INTERVAL MSG)))))
    (WHEN REFORMATTED-P
      (UNREFORMAT-HEADERS MSG)
      (WHEN BP-IN-HEADER-P
	1;; Desired location was in the reformatted header --
	;;    Find the equivalent line in the original header.
	;;    If none is found, use the first line of the original header.
0	(MULTIPLE-VALUE-BIND (HEADER-START-BP HEADER-END-BP)
	    (MSG-ORIGINAL-HEADERS-INTERVAL MSG)
	  (SETQ MOUSE-BP (LOOP FOR LINE = (BP-LINE HEADER-START-BP) THEN (LINE-NEXT LINE)
			       WHEN (EQUAL LINE (BP-LINE MOUSE-BP))
				 DO (RETURN (CREATE-BP LINE (BP-INDEX MOUSE-BP)))
			       UNTIL (EQ LINE (BP-LINE HEADER-END-BP))
			       FINALLY (RETURN HEADER-START-BP)))))
      (REDISPLAY *MSG-WINDOW* :NONE NIL NIL T)	1;Make sure display information is accurate.
0      (WHEN MOUSE-BP
	(MULTIPLE-VALUE-BIND (BPX BPY)
	    (FIND-BP-IN-WINDOW-COORDS MOUSE-BP *MSG-WINDOW*)
	  (WHEN (NULL BPX)
	    1;; Desired location has moved offscreen -- Use the last location onscreen instead.
0	    (LET ((LAST-PLINE
		    (LOOP FOR PLINE FROM (1- (WINDOW-N-PLINES *MSG-WINDOW*)) DOWNTO 0
			  WHEN (STRINGP (PLINE-LINE *MSG-WINDOW* PLINE))
			    RETURN PLINE)))
	      (SETQ MOUSE-BP (IF LAST-PLINE
				 (CREATE-BP (PLINE-LINE *MSG-WINDOW* LAST-PLINE)
					    (1- (PLINE-TO-INDEX *MSG-WINDOW* LAST-PLINE)))
			       (COPY-BP (INTERVAL-LAST-BP (WINDOW-INTERVAL *MSG-WINDOW*))))))
	    (MULTIPLE-VALUE (BPX BPY)
	      (FIND-BP-IN-WINDOW-COORDS MOUSE-BP *MSG-WINDOW*))
	    (WHEN (NULL BPX) (BARF)))
	  (LET ((SHEET (WINDOW-SHEET *MSG-WINDOW*)))
	    (SEND SHEET :SET-MOUSE-CURSORPOS (+ BPX (// (TV:SHEET-CHAR-WIDTH SHEET) 2))
		  (+ BPY (// (* 3 (TV:SHEET-LINE-HEIGHT SHEET)) 4)))))
	(MOVE-BP (WINDOW-POINT *MSG-WINDOW*) MOUSE-BP)))
    (LET ((OLD-CONFIG *WINDOW-CONFIGURATION*)
	  (OLD-DOC (SEND (WINDOW-SHEET *WINDOW*) :WHO-LINE-OVERRIDE-DOCUMENTATION-STRING))
	  (OLD-TICK (NODE-TICK (MSG-REAL-INTERVAL MSG)))
	  EXIT-STATE NO-CHANGE)
      (WITH-BACKGROUND-PROCESS-LOCKED
	(UNWIND-PROTECT
	    (PROGN
	      (UNLESS (OR (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
			  (MEMQ *WINDOW-CONFIGURATION* *CALENDAR-WINDOW-CONFIGURATIONS*))
		(SET-MAIN-WINDOW-CONFIGURATION :MSG))
	      (MAKE-WINDOW-CURRENT *MSG-WINDOW*)
	      (SELECT-WINDOW *MSG-WINDOW*)
	      (MUST-REDISPLAY *WINDOW* DIS-BPS)
	      (UPDATE-STYLE-NAME)
	      (WITH-EDITOR-BINDINGS
		(:MODE :TEXT			1;Always use text mode for existing messages.
0		 :COMTAB *MSG-COMTAB*
		 :MODE-LINE-LIST
	             '("Zmail " "Editing message " "(" *MODE-NAME-LIST*
		       (*MODE-QUANTITY-NAME* " <" *MODE-QUANTITY-NAME* ">")
		       ") " *ZMAIL-SEQUENCE-NAME* *CURRENT-MSG-NAME*
		       (*STYLE-NAME* "  Style: " *STYLE-NAME*)
		       (*MACRO-LEVEL* "  Macro-level: " *MACRO-LEVEL*)
		       (*MODE-LINE-MORE-ABOVE-BELOW* "  " *MODE-LINE-MORE-ABOVE-BELOW*)))
		(SETF (TV:BLINKER-DESELECTED-VISIBILITY (WINDOW-POINT-BLINKER *WINDOW*)) :ON)
		(SEND (WINDOW-SHEET *WINDOW*) :SET-WHO-LINE-OVERRIDE-DOCUMENTATION-STRING NIL)
		(SETQ EXIT-STATE (SEND *CURRENT-ZMAIL-COMMAND-LOOP* :EDIT))
		DIS-TEXT))
	  (SETF (TV:BLINKER-DESELECTED-VISIBILITY (WINDOW-POINT-BLINKER *WINDOW*)) NIL)
	  (SEND (WINDOW-SHEET *WINDOW*) :SET-WHO-LINE-OVERRIDE-DOCUMENTATION-STRING OLD-DOC)
	  (SETQ NO-CHANGE (= (NODE-TICK (MSG-REAL-INTERVAL MSG)) OLD-TICK))
	  (WHEN (AND NO-CHANGE REFORMATTED-P)
	    (REFORMAT-HEADERS MSG))
	  (WHEN (EQ EXIT-STATE :ABORTED)
	    (UNLESS (OR NO-CHANGE (UNDO-EDIT-MSG MSG))
	      (SETQ EXIT-STATE NIL)))
	  (IF (EQ EXIT-STATE :ABORTED)
	      (TYPEIN-LINE "Aborting edit of current message.")
	    (UNLESS NO-CHANGE
	      (REPARSE-MSG MSG)
	      (WHEN (> (NODE-TICK (MSG-REAL-INTERVAL MSG)) OLD-TICK)
		(SETF (MSG-TICK MSG) (TICK))	1;Munge message.
0		(MARK-SEQUENCE-MODIFIED (MSG-BUFFER MSG))))
	    (TYPEIN-LINE ""))
	  (SETF (WINDOW-MARK-P *MSG-WINDOW*) NIL)
	  (SEND *CURRENT-ZMAIL-COMMAND-LOOP* :SELECT-RELATIVE)
	  (WHEN (NEQ *WINDOW-CONFIGURATION* OLD-CONFIG)
	    (SET-MAIN-WINDOW-CONFIGURATION OLD-CONFIG)))))))

(DEFUN UNDO-EDIT-MSG (MSG)
  (IGNORE MSG)
  (LET (ENTRY)
    (LOOP WHILE *UNDO-HISTORY*
	  DO (POP *UNDO-HISTORY* ENTRY)
	  UNTIL (TYPEP ENTRY 'UNDO-EDIT))
    (IF (OR (NULL ENTRY)
	    (SEND ENTRY :CHECK-FOR-KILLED-MSGS))
	(PROGN
	  (FERROR "There is no edit entry to undo.")
	  NIL)
      (SEND ENTRY :UNDO)
      T)))

(DEFUN REPARSE-MSG (MSG)
  (WITH-MSG-REDISPLAY-DELAYED
    (LET ((OLD-IDS (GET-MSG-IDS MSG)))
      (MULTIPLE-VALUE-BIND (BODY-START-BP BODY-END-BP)
	  (MSG-BODY-INTERVAL MSG)
	(LOOP WITH END-LINE = (BP-LINE BODY-END-BP)
	      FOR LINE FIRST (BP-LINE BODY-START-BP) THEN (LINE-NEXT LINE)
	      WHILE LINE
	      WHEN (CL:GETF (LINE-CONTENTS-PLIST LINE) 'PARSED-HEADERS)
		DO (CL:REMF (LINE-CONTENTS-PLIST LINE) 'PARSED-HEADERS)
	      UNTIL (EQ LINE END-LINE)))
      (SETF (MSG-STATUS MSG) (SOME-PLIST (MSG-STATUS MSG) *INTERNAL-TYPE-PROPERTIES*))
      (SET-PARSED-MSG-HEADERS MSG)
      (SEND *SUMMARY-WINDOW* :NEED-TO-REDISPLAY-MSG MSG)
      (UPDATE-MSG-REFERENCES-GLOBALLY MSG OLD-IDS))
    (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS MSG))
  (WHEN (EQ MSG *MSG*)
    (SET-WINDOW-DEFAULT-CHARACTER-STYLE *MSG-WINDOW* (MSG-DEFAULT-CHARACTER-STYLE *MSG*))
    (COMPUTE-CURRENT-MSG-STATE))		;May not have losing headers any more, say
  MSG)

(DEFCOM-FOR-ZMAIL COM-ZMAIL-ABORT "Abort edit, go to Zmail top level." ()
  (*THROW 'EXIT-TOP-LEVEL :ABORTED))

(DEFMETHOD (:EDIT ZMAIL-COMMAND-LOOP-MIXIN :BEFORE) ()
  (DECLARE (SPECIAL *INSIDE-MAIL*))
  (IF *INSIDE-MAIL*
      (EXPLAIN-HOW-TO-SEND-MAIL)
    (TYPEIN-LINE-DURABLE "~:|~:[Edit~;~:*Press ~A when done editing~]."
			 (IF (EQ (COMMAND-LOOKUP #\END *COMTAB*) 'COM-QUIT)
			     #\END
			   (KEY-FOR-COMMAND 'COM-QUIT)))))

;;; Applies a function to the intervals of a message.
(DEFUN MAP-OVER-MSG-INTERVALS (MSG INTERVAL-FUNCTION &KEY INCLUDE-WRAPPER USE-ORIGINAL-HEADER)
  (DECLARE (SYS:DOWNWARD-FUNARG INTERVAL-FUNCTION))
  (WHEN INCLUDE-WRAPPER
    (FUNCALL INTERVAL-FUNCTION :LEADER (MSG-REAL-START-BP MSG) (MSG-START-BP MSG) T))
  ;; The following LET should really be a MULTIPLE-VALUE-BIND of a call to MSG-BODY-INTERVAL.
  ;; However, MSG-BODY-INTERVAL will cause the message to be parsed which is not acceptable
  ;; as MAP-OVER-MSG-INTERVALS may be called on unparsed messages and the caller will expect
  ;; the messages to remain unparsed.
  (LET ((BODY-START-BP  (OR (CL:GETF (MSG-STATUS MSG) 'HEADERS-END-BP)
			    (MSG-END-BP MSG)))
	(BODY-END-BP (MSG-END-BP MSG)))
    (IF (AND USE-ORIGINAL-HEADER (EQ (MSG-PARSED-P MSG) T))
	(LET ((ORIGINAL-INTERVAL (WHEN (SEND (MSG-BUFFER MSG) :SAVE-ORIGINAL-HEADER MSG)
				   (CL:GETF (MSG-STATUS MSG) 'ORIGINAL-HEADERS-INTERVAL))))
	  (IF ORIGINAL-INTERVAL
	      (FUNCALL INTERVAL-FUNCTION :HEADER ORIGINAL-INTERVAL)
	    (FUNCALL INTERVAL-FUNCTION :HEADER (MSG-START-BP MSG) BODY-START-BP T)))
      (FUNCALL INTERVAL-FUNCTION :HEADER (MSG-START-BP MSG) BODY-START-BP T))
    (FUNCALL INTERVAL-FUNCTION :BODY BODY-START-BP BODY-END-BP T))
  (WHEN INCLUDE-WRAPPER
    (FUNCALL INTERVAL-FUNCTION :TRAILER (MSG-END-BP MSG) (MSG-REAL-END-BP MSG) T)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SET-MSG-DEFAULT-CHARACTER-STYLE
  "Sets the default character style for this message."
				()
  (MULTIPLE-VALUE-BIND (NEW-DEFAULT-CHARACTER-STYLE DEFAULT-CHANGED-P)
      (ZMAIL-ACCEPT-DEFAULT-CHARACTER-STYLE *MSG-WINDOW* "message")
    (WHEN DEFAULT-CHANGED-P
      (LET ((MSG-DEFAULT-CHARACTER-STYLE
	      (UNLESS (EQ NEW-DEFAULT-CHARACTER-STYLE *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)
		NEW-DEFAULT-CHARACTER-STYLE)))
	(ZMAIL-UNDO-SAVE 'UNDO-SET-DEFAULT-CHARACTER-STYLE :MSG *MSG*)
	(WITH-MSG-REDISPLAY-DELAYED
	  (ADD-HEADER-TO-MSG *MSG* :DEFAULT-CHARACTER-STYLE MSG-DEFAULT-CHARACTER-STYLE
			     :DELETE-IF-EMPTY T)
	  (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS *MSG*))	1; Fonts field may need to change
0	(SET-WINDOW-DEFAULT-CHARACTER-STYLE *MSG-WINDOW* NEW-DEFAULT-CHARACTER-STYLE)))
    DIS-NONE))

(DEFUN ZMAIL-ACCEPT-DEFAULT-CHARACTER-STYLE (WINDOW OBJECT)
  (DECLARE (VALUES NEW-DEFAULT-CHARACTER-STYLE DEFAULT-CHANGED-P))
  (LET* ((REAL-WINDOW (WINDOW-SHEET WINDOW))
	 (DEFAULT-CHARACTER-STYLE (SEND REAL-WINDOW :DEFAULT-STYLE))
	 (NEW-DEFAULT-CHARACTER-STYLE
	   (TYPEIN-LINE-ACCEPT `((SCL:CHARACTER-STYLE-FOR-DEVICE
				   :DEVICE ,SI:*B&W-SCREEN*
				   :ALLOW-RELATIVE NIL))
			       :DEFAULT DEFAULT-CHARACTER-STYLE
			       :PROMPT (FORMAT
					 NIL "Set the default character style for this ~A to"
					 OBJECT))))
    (VALUES NEW-DEFAULT-CHARACTER-STYLE
	    (NEQ NEW-DEFAULT-CHARACTER-STYLE DEFAULT-CHARACTER-STYLE))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-EXPLAIN-BAD-HEADER 
				"Explain why this message has bad-header" ()
  (LET ((UNPARSABLE (MSG-GET *MSG* 'UNPARSEABLE))
	(ERRORS (MSG-GET *MSG* 'LOSING-HEADERS)))
    (FLET ((REPORT-ERROR (ERROR)
	     (DBG:REPORT ERROR STANDARD-OUTPUT)
	     (CL:FRESH-LINE STANDARD-OUTPUT)))
      (COND ((TYPEP UNPARSABLE 'ERROR)
	     (REPORT-ERROR UNPARSABLE))
	    (UNPARSABLE
	     (TYPEOUT-LINE "This message can not be parsed."))
	    (ERRORS
	     (DOLIST (ERROR ERRORS)
	       (REPORT-ERROR ERROR)))
	    (T
	     (TYPEIN-LINE "There's nothing wrong with this message.")))))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-SHOW-RECEIVED-PATH
  "Show how this message travelled as indicated by Received: headers"
				()
  (LET ((RECEIVED (REALLY-PARSE-RECEIVED-HEADERS (MSG-GET *MSG* :RECEIVED))))
    (IF (NULL RECEIVED)
	(TYPEIN-LINE "Beats me (no Received headers).")
	(PRETTY-PRINT-RECEIVED-HEADERS RECEIVED)))
  DIS-NONE)

;;; Keyword stuff

;;; List of keywords on, keywords off
(DEFINE-ZMAIL-GLOBAL *DEFAULT-KEYWORDS* NIL)

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *FILTER-KEYWORDS-ALIST* COM-ZMAIL-KEYWORDS)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-KEYWORDS (STRING)
  (UPDATE-KEYWORDS-WHO-LINE-DOCUMENTATION STRING *MSG*))

(DEFUN UPDATE-KEYWORDS-WHO-LINE-DOCUMENTATION (STRING MSG)
  (STORE-ARRAY-LEADER 0 STRING 0)		;In case not called from updater
  (APPEND-TO-ARRAY STRING "Change keywords on this message: ")
  (COND ((OR (CAR *DEFAULT-KEYWORDS*) (CADR *DEFAULT-KEYWORDS*))
	 (APPEND-TO-ARRAY STRING "L:")
	 (LET ((ON (CAR *DEFAULT-KEYWORDS*))
	       (OFF (CADR *DEFAULT-KEYWORDS*)))
	   (COND (ON
		  (APPEND-TO-ARRAY STRING " add ")
		  (APPEND-TO-ARRAY STRING (STRING-FROM-KEYWORDS ON))))
	   (COND (OFF
		  (AND ON (ARRAY-PUSH-EXTEND STRING #/,))
		  (APPEND-TO-ARRAY STRING " remove ")
		  (APPEND-TO-ARRAY STRING (STRING-FROM-KEYWORDS OFF)))))
	 (APPEND-TO-ARRAY STRING "; ")))
  (IF MSG (UPDATE-KEYWORDS-WHO-LINE-DOCUMENTATION-1 STRING MSG))
  (APPEND-TO-ARRAY STRING "R: menu."))

(DEFUN UPDATE-KEYWORDS-WHO-LINE-DOCUMENTATION-1 (STRING MSG)
  (AND *FILTER-KEYWORDS-ALIST* MSG
       (IF (EQ MSG ':INDIVIDUAL-FILTERS)
	   (APPEND-TO-ARRAY STRING "M: by individual filters; ")
	   (LET ((KEYS (GET-KEYWORDS-FROM-MSG-BY-FILTERING MSG)))
	     (COND (KEYS
		    (APPEND-TO-ARRAY STRING "M: add ")
		    (APPEND-TO-ARRAY STRING (STRING-FROM-KEYWORDS KEYS))
		    (APPEND-TO-ARRAY STRING "; ")))))))

(DEFFLAVOR ZMAIL-KEYWORD-HISTORY () (HISTORY))

(DEFVAR *ZMAIL-KEYWORD-HISTORY*
	(MAKE-INSTANCE 'ZMAIL-KEYWORD-HISTORY :NAME "Keyword"))

(DEFUN STRING-KEYWORDS-LIST (KEYWORDS)
  (LET ((KEYWORDS (IF (STRINGP KEYWORDS)
		      ;; e.g., "Foo,Bar"
		      (MAPCAR #'CDR
			      (CL:GETF (PARSE-KEYWORDS-LIST NIL KEYWORDS 0 NIL T)
				       :KEYWORDS))
		      KEYWORDS)))
    (WITH-OUTPUT-TO-STRING (STREAM)
						;From ZMAIL-KEYWORDS-MSG -kmp 22-Sep-89
      (LOOP FOR KEY IN KEYWORDS
	    AS COMMA-P FIRST NIL THEN T
	    AS NAME = (IF (ATOM KEY)
			  ;; e.g., :FOO
			  (OR (CAR (RASSQ KEY *KEYWORD-ALIST*)) KEY)
			  ;; e.g., ("Foo" . :FOO)
			  (CAR KEY))
	    WHEN COMMA-P DO (STRING-OUT ", " STREAM)
	    DO (STRING-OUT NAME STREAM)))))

(DEFMETHOD (:CANONICALIZE-DEFAULT ZMAIL-KEYWORD-HISTORY) (ELEMENT)
  (STRING-KEYWORDS-LIST ELEMENT))

(DEFWHOPPER (:PUSH ZMAIL-KEYWORD-HISTORY) (ELEMENT)
  (LET ((NEW      (STRING-KEYWORDS-LIST ELEMENT))
	(PREVIOUS (CAR LIST)))
    (IF (OR (STRING-EQUAL NEW "") (AND PREVIOUS (STRING-EQUAL NEW PREVIOUS)))
	(WITHOUT-INTERRUPTS (SETQ ROTATION 0 TEMPORARY-ELEMENT 0))	;Do essential update
	(CONTINUE-WHOPPER NEW))))

(DEFWHOPPER (:FUNCALL-WITH-DEFAULT ZMAIL-KEYWORD-HISTORY) (ELEMENT FUNCTION &REST ARGS)
  (LEXPR-CONTINUE-WHOPPER (STRING-KEYWORDS-LIST ELEMENT) FUNCTION ARGS))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-KEYWORDS
    "Change keywords for the current message.
Left does same as last keywords operation.  Middle adds keywords per matching
filters in filter-keywords association list.  Right gives a menu." ()
  (ZMAIL-KEYWORDS-MSG *MSG*)
  DIS-NONE)

(DEFUN ZMAIL-KEYWORDS-MSG (MSG)
  (LET ((OLD-KEYWORDS (MSG-GET MSG 'KEYWORDS))
	(NEW-KEYWORDS)
	(UPDATE-DEFAULTS T))			1;Presume we're going to change the defaults.
0    (ZMAIL-UNDO-SAVE 'UNDO-KEYWORDS :MSG MSG)
    (COND ((EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
	   (SETQ NEW-KEYWORDS (CHOOSE-KEYWORDS (FORMAT NIL "Set keywords~@[ for message #~D~]:"
						       (LET ((IDX (LOCATE-MSG-IN-SEQUENCE
								    MSG *SEQUENCE*)))
							 (AND IDX (1+ IDX))))
					       OLD-KEYWORDS)))
	  ((OR (EQ *ZMAIL-COMMAND-BUTTON* :MIDDLE)
	       (AND (EQ *ZMAIL-COMMAND-BUTTON* :KBD) *KBD-SAME-AS-MIDDLE*))
	   (SETQ NEW-KEYWORDS (OR (GET-KEYWORDS-FROM-MSG-BY-FILTERING MSG OLD-KEYWORDS)
				  (BARF "No matching keyword filters found."))))
	  ((EQ *ZMAIL-COMMAND-BUTTON* :KBD)
	   (LET* ((STRING (WITH-ZMAIL-SUMMARY-WHO-LINE-DOCUMENTATION
			    "L: Use keywords of this message.  M: Copy keywords of this message into minibuffer."
			    (*CATCH 'ZMAIL-KEYWORDS-MSG-MOUSE-DWIM
			      (CONDITION-BIND ((UNKNOWN-SPECIAL-COMMAND
						 #'ZMAIL-KEYWORDS-MSG-MOUSE-DWIM))
				(TYPEIN-LINE-HISTORY-READLINE
				  *ZMAIL-KEYWORD-HISTORY*
				  OLD-KEYWORDS
				  NIL
				  "Keywords for this message (separated by commas):")))))
		  (PL (PARSE-KEYWORDS-LIST NIL STRING 0 NIL T)))
	     (UNLESS (LOOP FOR (KWD) IN (CL:GETF PL :NEW-KEYWORDS)
			   ALWAYS (TYPEIN-LINE-Y-OR-N-P
				    (FORMAT NIL "Create new keyword /"~A/"? " KWD)))
	       (TYPEIN-LINE "No keywords added or deleted.")
	       (ABORT-CURRENT-COMMAND))
	     (SETQ PL (PARSE-KEYWORDS-LIST NIL STRING)
		   NEW-KEYWORDS (MAPCAR 'CDR (CL:GETF PL :KEYWORDS)))))
	  ((OR (FIRST *DEFAULT-KEYWORDS*) (SECOND *DEFAULT-KEYWORDS*))
	   (SETQ NEW-KEYWORDS OLD-KEYWORDS
		 UPDATE-DEFAULTS NIL)
	   (DOLIST (KEY (FIRST *DEFAULT-KEYWORDS*))	1;Keywords on
0	     (PUSH* KEY NEW-KEYWORDS))
	   (DOLIST (KEY (SECOND *DEFAULT-KEYWORDS*))	1;Keywords off
0	     (SETQ NEW-KEYWORDS (REMQ KEY NEW-KEYWORDS))))
	  (T
	   (BARF "No default action for keyword commands yet.")))
    (WHEN UPDATE-DEFAULTS
      (SETQ *DEFAULT-KEYWORDS* (LIST (LOOP FOR KEY IN NEW-KEYWORDS
					   UNLESS (MEMQ KEY OLD-KEYWORDS)
					     COLLECT KEY)
				     (LOOP FOR KEY IN OLD-KEYWORDS
					   UNLESS (MEMQ KEY NEW-KEYWORDS)
					     COLLECT KEY)))
      (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-KEYWORDS))
    (CHANGE-MSG-KEYWORDS MSG NEW-KEYWORDS OLD-KEYWORDS)))

(DEFUN ZMAIL-KEYWORDS-MSG-MOUSE-DWIM (CONDITION)
  ;; General idea for this taken from ZMAIL-FILTER-MINI-BUFFER-UNKNOWN-SPECIAL-COMMAND  -kmp
  (WHEN (EQ (SEND CONDITION ':COMMAND-TYPE) 'SUMMARY-MOUSE)
    (LET* ((MSG (CADAR (SEND CONDITION ':REST)))
	   (KEYWORDS-TOUCHED (MSG-GET MSG 'KEYWORDS)))
      (CL:CASE (THIRD (SEND CONDITION :REST))
	(#\Mouse-L
	 (IF (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
	     ;; User has not typed anything yet.
	     (*THROW 'ZMAIL-KEYWORDS-MSG-MOUSE-DWIM
		     (STRING-KEYWORDS-LIST (MSG-GET MSG 'KEYWORDS)))
	     ;; User has typed something.  Replace what he typed with the new stuff
	     ;; but fall through to code below to make him type Return or End to confirm.
	     ;; He can get back the stuff we killed by using c-Y.
	     (ZWEI:KILL-INTERVAL (INTERVAL-FIRST-BP *INTERVAL*)
				 (INTERVAL-LAST-BP *INTERVAL*)
				 T)))
	((#\Mouse-M #\c-Mouse-M))		;continue
	(OTHERWISE (BARF)))
      (LET* ((KEYWORDS-PRESENT-INFO
	       (IGNORE-ERRORS
		 (PARSE-KEYWORDS-LIST NIL (STRING-INTERVAL *INTERVAL*) 0 NIL T)))
	     (KEYWORDS-PRESENT
	       (MAPCAR #'CDR (APPEND (CL:GETF KEYWORDS-PRESENT-INFO :KEYWORDS)
				     (CL:GETF KEYWORDS-PRESENT-INFO :NEW-KEYWORDS))))
	     (KEYWORDS (CL:SET-DIFFERENCE KEYWORDS-TOUCHED KEYWORDS-PRESENT)))
	(IF (NOT KEYWORDS)
	    (BEEP)
	  (MOVE-BP (POINT) (INTERVAL-LAST-BP *INTERVAL*))
	  (DELETE-AROUND '(#\Space #\Tab #\,) (POINT))
	  (UNLESS (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
	    (INSERT-MOVING (POINT) ", "))
	  (INSERT-MOVING (POINT) (STRING-KEYWORDS-LIST KEYWORDS))
	  (MUST-REDISPLAY *WINDOW* DIS-TEXT))))
    (*THROW 'ZWEI-COMMAND-LOOP T)))

(DEFUN CHOOSE-KEYWORDS (&OPTIONAL LABEL OLD-KEYWORDS)
  (SEND *KEYWORD-WINDOW* :SET-LABEL LABEL)
  (WHEN *KEYWORD-ALIST-SORT-PREDICATE*
    (SETQ *KEYWORD-ALIST* (SORTCAR *KEYWORD-ALIST*
				   (EVAL (EVAL *KEYWORD-ALIST-SORT-PREDICATE*))))
    (SETQ *KEYWORD-ALIST* (SI:COLUMN-INVERT-LIST *KEYWORD-ALIST*
						 (FIRST (SEND *KEYWORD-WINDOW* :GEOMETRY)))))
  (UNWIND-PROTECT
      (LET ((NEW-KEYWORDS))
	(MULTIPLE-VALUE (*KEYWORD-ALIST* NEW-KEYWORDS)
	  (SEND *KEYWORD-WINDOW* :MULTIPLE-CHOOSE *KEYWORD-ALIST* OLD-KEYWORDS
						  (RECTANGLE-NEAR-COMMAND-MENU)))
	(IF (EQ NEW-KEYWORDS :ABORT)
	    (ABORT-CURRENT-COMMAND)
	    NEW-KEYWORDS))
    (WHEN *KEYWORD-ALIST-SORT-PREDICATE*
      (SETQ *KEYWORD-ALIST* (SORTCAR *KEYWORD-ALIST*
				     (EVAL (EVAL *KEYWORD-ALIST-SORT-PREDICATE*)))))))

(DEFUN GET-KEYWORDS-FROM-MSG-BY-FILTERING (MSG &OPTIONAL OLD-KEYWORDS)
  (MULTIPLE-VALUE-BIND (KEYWORDS)
      (CL:REMOVE-DUPLICATES
	(CL:CONCATENATE 'LIST
			(LOOP FOR (FILTER . KEYWORDS) IN *FILTER-KEYWORDS-ALIST*
			      WHEN (MSG-FITS-FILTER-P MSG FILTER)
				APPEND KEYWORDS)
			OLD-KEYWORDS))
    (DOLIST (KEYWORD KEYWORDS)
      (UNLESS (RASSQ KEYWORD *KEYWORD-ALIST*)
	(PUSH (CONS (STRING-DOWNCASE KEYWORD) KEYWORD) *KEYWORD-ALIST*)))
    KEYWORDS))

(DEFUN CHANGE-MSG-KEYWORDS (MSG NEW-KEYWORDS OLD-KEYWORDS &AUX MSG-BUFFER BUFFER-KEYS)
  ;; Canonicalize the order of keywords for the msg to the order for the file.
  (SETQ MSG-BUFFER (MSG-BUFFER MSG)
	BUFFER-KEYS (SEND MSG-BUFFER ':GET ':KEYWORDS)
	NEW-KEYWORDS (LET ((*KEYWORD-ALIST* BUFFER-KEYS))
		       (SORT NEW-KEYWORDS #'(LAMBDA (KEY1 KEY2)
					      (DO ((L *KEYWORD-ALIST* (CDR L))
						   (KEY))
						  ((NULL L)
						   (STRING-LESSP KEY1 KEY2))
						(SETQ KEY (CDAR L))
						(COND ((EQ KEY KEY1) (RETURN T))
						      ((EQ KEY KEY2) (RETURN NIL))))))))
  (COND ((EQUAL OLD-KEYWORDS NEW-KEYWORDS))	;Did not change
	(T
	 (DO ((KEYS NEW-KEYWORDS (CDR KEYS))
	      (ELEM) (FLAG NIL))
	     ((NULL KEYS)
	      (AND FLAG (SETF (SEND MSG-BUFFER ':GET ':KEYWORDS)
			      BUFFER-KEYS)))
	   (OR (MEMQ (SETQ ELEM (RASSQ (CAR KEYS) *KEYWORD-ALIST*)) BUFFER-KEYS)
	       (SETQ BUFFER-KEYS (NCONC BUFFER-KEYS (NCONS ELEM))
		     FLAG T)))
	 (MSG-PUT MSG NEW-KEYWORDS 'KEYWORDS)
	 (LET ((STRING (AND NEW-KEYWORDS (STRING-FROM-KEYWORDS NEW-KEYWORDS))))
	   (MSG-PUT MSG STRING 'KEYWORDS-STRING)
	   (UPDATE-MSG-SUMMARY-LINE MSG ':KEYWORDS)
	   (COND ((EQ MSG *MSG*)
		  (SETQ *CURRENT-MSG-KEYWORDS-STRING* (OR STRING "{}"))
		  (UPDATE-BY-FILTERS-COMMAND-WHO-LINE-DOCUMENTATION)))))))

(DEFUN STRING-FROM-KEYWORDS (KEYWORDS &AUX STR)
  (DO ((KEYS KEYWORDS (CDR KEYS))
       (LENGTH 1))
      ((NULL KEYS)
       (SETQ STR (MAKE-ARRAY LENGTH ':TYPE 'ART-STRING)))
    (SETQ LENGTH (+ LENGTH (ARRAY-ACTIVE-LENGTH (CAR (RASSQ (CAR KEYS) *KEYWORD-ALIST*)))
		    1)))
  (ASET #/{ STR 0)
  (DO ((KEYS KEYWORDS (CDR KEYS))
       (I0 1 (1+ I1))
       (I1) (KEY) (LEN))
      ((NULL KEYS)
       (ASET #/} STR I1))
    (SETQ KEY (CAR (RASSQ (CAR KEYS) *KEYWORD-ALIST*))
	  LEN (ARRAY-ACTIVE-LENGTH KEY)
	  I1 (+ I0 LEN))
    (COPY-ARRAY-PORTION KEY 0 LEN STR I0 I1)
    (ASET #\SP STR I1))
  STR)

1;;; Redisplay related commands.

0(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REFRESH
				 "Complete redisplay"
				 (NO-SEQUENCE-OK)
  (DOLIST (WINDOW *WINDOW-LIST*)
    (LET ((TYPEOUT-WINDOW (WINDOW-TYPEOUT-WINDOW WINDOW)))
      (WHEN TYPEOUT-WINDOW
	(SEND TYPEOUT-WINDOW :MAKE-COMPLETE))))
  (SEND *CURRENT-ZMAIL-COMMAND-LOOP* :REFRESH)
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SCROLL-MSG-NEXT-SCREEN
				"Displays the next screen of the message.
With a numeric argument, the mesage text is scrolled up by that many lines."
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (MULTIPLE-VALUE-BIND (SCROLL-ARG SCROLL-ARG-TYPE)
      (INTERPRET-SCROLLING-NUMERIC-ARG)
    (SCROLL-MSG-WINDOW-INTERNAL :RELATIVE SCROLL-ARG SCROLL-ARG-TYPE)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SCROLL-MSG-PREVIOUS-SCREEN
				"Displays the previous screen of the message.
With a numeric argument, the message text is scrolled down by that many lines."
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (MULTIPLE-VALUE-BIND (SCROLL-ARG SCROLL-ARG-TYPE)
      (INTERPRET-SCROLLING-NUMERIC-ARG)
    (SCROLL-MSG-WINDOW-INTERNAL :RELATIVE (- SCROLL-ARG) SCROLL-ARG-TYPE)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-RECENTER-MSG-OR-SUMMARY-WINDOW
				"Redisplay the message or summary window.

If the message window is visible, it is redisplayed; otherwise, the summary
window is redisplayed.  When redisplaying the message window, the line 
containing point is repositioned according to the numeric argument.  When
redisplaying the summary window, the summary line for the current message
is repositioned.

If a numeric argument is not given, the affected line is placed near the
center of the window according to the value of the Center Fraction variable.

If a numeric argument is given, the affected line is placed at the
line in the window corresponding to the argument.  An argument of zero is the
top line, one is the next line, etc.  An argument of -1 is the bottom line,
-2 is the next to the bottom line, etc."
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (IF (EQ *WINDOW-CONFIGURATION* :SUMMARY)
      (SCROLL-SUMMARY-WINDOW-INTERNAL :CENTER *NUMERIC-ARG* *NUMERIC-ARG-P*)
    (SCROLL-MSG-WINDOW-INTERNAL :ABSOLUTE *NUMERIC-ARG* *NUMERIC-ARG-P*)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-START-OF-MSG
				 "Scroll back to start of message"
				 (NO-SEQUENCE-OK)
  (SCROLL-MSG-WINDOW-INTERNAL :BEGINNING))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-END-OF-MSG "Go to the end of the message."
				(NO-SEQUENCE-OK)
  (SCROLL-MSG-WINDOW-INTERNAL :END))

(DEFUN SCROLL-MSG-WINDOW-INTERNAL (MODE &OPTIONAL SCROLL-ARG SCROLL-ARG-TYPE)
  (UNLESS (OR (MEMQ *WINDOW-CONFIGURATION* *MSG-WINDOW-CONFIGURATIONS*)
	      (MEMQ *WINDOW-CONFIGURATION* *CALENDAR-WINDOW-CONFIGURATIONS*))
    (BARF))
  (CL:ECASE MODE
    (:CHECK)					;allows caller to check configuration first
    (:FORWARD
      (RECENTER-WINDOW-RELATIVE *WINDOW* +1 :SCREEN))
    (:BACKWARD
      (RECENTER-WINDOW-RELATIVE *WINDOW* -1 :SCREEN))
    (:BEGINNING
      (WHEN *MSG*
	(MSG-POINT-PDL-PUSH *MSG* *SEQUENCE*))
      (RECENTER-WINDOW *WINDOW* :START (INTERVAL-FIRST-BP *INTERVAL*)))
    (:END
      (WHEN *MSG*
       (MSG-POINT-PDL-PUSH *MSG* *SEQUENCE*))
      (MOVE-BP (POINT) (INTERVAL-LAST-BP *INTERVAL*))
      (MUST-REDISPLAY *WINDOW* DIS-BPS)
      (RECENTER-WINDOW *WINDOW* :ABSOLUTE
		       (LET ((SHEET (WINDOW-SHEET *WINDOW*)))
			 (- (SEND SHEET :INSIDE-HEIGHT) (POINT-LINE-HEIGHT SHEET (POINT))))
		       :PIXEL))
    (:RELATIVE
      (RECENTER-WINDOW-RELATIVE *WINDOW* SCROLL-ARG
					 (CL:ECASE SCROLL-ARG-TYPE
					   (:LINES :LINE)
					   (:SCREENS :SCREEN))))
    (:ABSOLUTE
      (IF SCROLL-ARG-TYPE
	  (RECENTER-WINDOW *WINDOW* :ABSOLUTE SCROLL-ARG :LINE)
	(MUST-REDISPLAY *WINDOW* DIS-ALL)
	(RECENTER-WINDOW *WINDOW* :ABSOLUTE))))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-SCROLL-SUMMARY-WINDOW
				 "Scroll the summary window"
				 (NO-MSG-OK NUMERIC-ARG-OK)
  (IF (ZEROP *NUMERIC-ARG*)
      (LET ((TARGET (MSG-DISPLAYED-INDEX *MSG*)))
	(IF TARGET
	    (SCROLL-SUMMARY-WINDOW-INTERNAL :ABSOLUTE TARGET)
	    (BARF)))
    (MULTIPLE-VALUE-BIND (SCROLL-ARG SCROLL-ARG-TYPE)
      (INTERPRET-SCROLLING-NUMERIC-ARG)
    (SCROLL-SUMMARY-WINDOW-INTERNAL :RELATIVE SCROLL-ARG SCROLL-ARG-TYPE))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-SCROLL-SUMMARY-WINDOW-BACKWARD
				 "Scroll the summary window backward"
				 (NO-MSG-OK NUMERIC-ARG-OK)
  (IF (ZEROP *NUMERIC-ARG*)
      (SCROLL-SUMMARY-WINDOW-INTERNAL :ABSOLUTE (MSG-DISPLAYED-INDEX *MSG*))
    (MULTIPLE-VALUE-BIND (SCROLL-ARG SCROLL-ARG-TYPE)
      (INTERPRET-SCROLLING-NUMERIC-ARG)
    (SCROLL-SUMMARY-WINDOW-INTERNAL :RELATIVE (- SCROLL-ARG) SCROLL-ARG-TYPE))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-START-OF-SUMMARY-WINDOW
				"Go to the beginning of the summary window"
				(NO-MSG-OK)
  (SCROLL-SUMMARY-WINDOW-INTERNAL :ABSOLUTE 0))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-END-OF-SUMMARY-WINDOW
				"Go to the end of the summary window"
				(NO-MSG-OK)
  (LET* ((N-LINES (TV:SHEET-NUMBER-OF-INSIDE-LINES *SUMMARY-WINDOW*))
	 (LAST-MSG-NO (IF *SEQUENCE* (1- (SEQUENCE-NMSGS *SEQUENCE*)) 0))
	 (NEW-TOP-MSG (MAX (- LAST-MSG-NO (FLOOR N-LINES 2)) 0)))
    (SCROLL-SUMMARY-WINDOW-INTERNAL :ABSOLUTE NEW-TOP-MSG)))

(DEFUN SCROLL-SUMMARY-WINDOW-INTERNAL (MODE SCROLL-ARG &OPTIONAL SCROLL-ARG-TYPE)
  (UNLESS (MEMQ *WINDOW-CONFIGURATION* *SUMMARY-WINDOW-CONFIGURATIONS*)
    (BARF))
  (LET ((N-LINES (TV:SHEET-NUMBER-OF-INSIDE-LINES *SUMMARY-WINDOW*)))
    (CL:ECASE MODE
      (:ABSOLUTE
	(SEND *SUMMARY-WINDOW* :SCROLL-TO SCROLL-ARG :ABSOLUTE))
      (:RELATIVE
	(LET ((AMOUNT (CL:ECASE SCROLL-ARG-TYPE
			(:LINES SCROLL-ARG)
			(:SCREENS (* SCROLL-ARG (1- N-LINES))))))
	  (IF (COND ((ZEROP AMOUNT) NIL)	1;Zero relative movement is always OK.
0		    ((PLUSP AMOUNT)		1;Moving "down".
0		     ( (+ (SYMEVAL-IN-INSTANCE *SUMMARY-WINDOW* 'TV:TOP-ITEM) AMOUNT)
			(SEQUENCE-NMSGS *SEQUENCE*)))
		    1;; Moving "up" has several different sanity checks.
0		    ((ZEROP (SYMEVAL-IN-INSTANCE *SUMMARY-WINDOW* 'TV:TOP-ITEM)))
		    ((< (SEQUENCE-NMSGS *SEQUENCE*) N-LINES)
		     NIL)			1;Always OK if it's a short sequence.
0		    (T
		     ( (+ (SYMEVAL-IN-INSTANCE  *SUMMARY-WINDOW* 'TV:BOTTOM-ITEM) AMOUNT) 0)))
	      (BEEP)				1;Don't improperly abort0 Mark Survey1.
0	      (SEND *SUMMARY-WINDOW* :SCROLL-TO AMOUNT :RELATIVE))))
      (:CENTER
	(LET ((TARGET (MAX 0 (- (MSG-DISPLAYED-INDEX *MSG*)
				(IF SCROLL-ARG-TYPE
				    (RANGE (+ SCROLL-ARG (IF (MINUSP SCROLL-ARG) N-LINES 0))
					   0 (1- N-LINES))
				    (* (1+ N-LINES) *CENTER-FRACTION*))))))
	  (SEND *SUMMARY-WINDOW* :SCROLL-TO TARGET :ABSOLUTE)))))
  DIS-NONE)

(DEFUN INTERPRET-SCROLLING-NUMERIC-ARG ()
  (DECLARE (VALUES SCROLL-ARG SCROLL-ARG-TYPE))
  (VALUES (CL:CASE *NUMERIC-ARG-P*
	    (NIL 1)
	    (:SIGN -1)
	    (OTHERWISE *NUMERIC-ARG*))
	  (CL:CASE *NUMERIC-ARG-P*
	    ((NIL :SIGN) :SCREENS)
	    (OTHERWISE :LINES))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-JUMP
				 "Move to a specific message"
				 (NUMERIC-ARG-OK)
  (IF *NUMERIC-ARG-P*
      (ZMAIL-SELECT-MSG (1- (RANGE *NUMERIC-ARG* 1 (SEND *SEQUENCE* ':NMSGS))))
      (COM-ZMAIL-NEXT-OR-PREVIOUS-INTERNAL ':FIRST-UNDELETED)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-BREAK
				"Break loop"
				(NO-SEQUENCE-OK)
  (SEND *TYPEOUT-WINDOW* :OUTPUT-HOLD-EXCEPTION)
  (TV:WINDOW-CALL-RELATIVE (*TYPEOUT-WINDOW*)
    (UNWIND-PROTECT
	(WITH-BACKGROUND-PROCESS-RUNNING
	  (LET ((*INSIDE-BREAK* T))
	    (BREAK ZMAIL)))
      (SEND *CURRENT-ZMAIL-COMMAND-LOOP* :EXPOSE-MODE-LINE-WINDOW))
    (SEND *TYPEOUT-WINDOW* :MAKE-COMPLETE))
  DIS-NONE)

(DEFINE-ZMAIL-GLOBAL *LAST-MAP-MENU-ITEM* NIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-MAP-OVER (STRING)
  (FLET ((GET-COMMAND-MAP-OVER-DOCUMENTATION (COMMAND FOR-DEFAULT-OR-MENU)
	   (IF (GET COMMAND 'MAP-OVER-DOCUMENTATION-UPDATER)
	       (FUNCALL (GET COMMAND 'MAP-OVER-DOCUMENTATION-UPDATER) FOR-DEFAULT-OR-MENU)
	     (NAME-FROM-MENU-VALUE COMMAND *ZMAIL-MAP-COMMAND-ALIST*))))
    (FORMAT STRING "Operate on all messages: ~@[L: ~A; ~]~@[M: ~A; ~]R: menu."
	    (IF *LAST-MAP-MENU-ITEM*
		(GET-COMMAND-MAP-OVER-DOCUMENTATION (CDR *LAST-MAP-MENU-ITEM*) :DEFAULT))
	    (IF *MAP-MIDDLE-MODE*
		(GET-COMMAND-MAP-OVER-DOCUMENTATION *MAP-MIDDLE-MODE* :MENU)))))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *MAP-MIDDLE-MODE* COM-ZMAIL-MAP-OVER)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *LAST-HARDCOPY-OPTIONS* COM-ZMAIL-MAP-OVER)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MOVE-SEQUENCE* COM-ZMAIL-MAP-OVER)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MAP-OVER-KEYWORDS* COM-ZMAIL-MAP-OVER)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MAP-OVER-UNKEYWORDS* COM-ZMAIL-MAP-OVER)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-MAP-OVER "Perform operation on these messages.
Left defaults to same as last Map command.  Middle is a user option.
Right gives menu of operations."
				 (DANGEROUS NO-MSG-OK NUMERIC-ARG-OK)
  (WHEN (EQ *ZMAIL-COMMAND-BUTTON* :RIGHT)
    (LOOP FOR (NIL . COMMAND) IN *ZMAIL-MAP-COMMAND-ALIST*
	  WHEN (GET COMMAND 'WHO-LINE-DOCUMENTATION-UPDATER)
	    DO (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION COMMAND)))
  (LET (COMMAND
	(OUR-*ZMAIL-COMMAND-BUTTON* *ZMAIL-COMMAND-BUTTON*)
	(LAST-*LAST-MAP-MENU-ITEM* *LAST-MAP-MENU-ITEM*))
    (MULTIPLE-VALUE (COMMAND *LAST-MAP-MENU-ITEM*)
      (ZMAIL-MENU-CHOOSE *ZMAIL-MAP-COMMAND-MENU* NIL *LAST-MAP-MENU-ITEM*
			 NIL *MAP-MIDDLE-MODE*))
    ;; try not to define Map Over(L) redundantly with Map Over(M)
    (WHEN (AND LAST-*LAST-MAP-MENU-ITEM* (EQ COMMAND *MAP-MIDDLE-MODE*))
      (SETQ *LAST-MAP-MENU-ITEM* LAST-*LAST-MAP-MENU-ITEM*))
    (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-MAP-OVER)
    ;; If click middle on map over, make like click right on corresponding selection.
    (WHEN (EQ OUR-*ZMAIL-COMMAND-BUTTON* :MIDDLE)
      (SETQ *ZMAIL-COMMAND-BUTTON* :RIGHT))
    ;; the check for too many messages was misplaced here, because in
    ;; general more specs will be required from the user, some of which
    ;; will reduce the number of messages involved.  It's a drag, but
    ;; the check has to be inserted into every map-over command.
    (FUNCALL COMMAND)))

(DEFUN CHECK-FOR-TOO-MANY-MSGS (WHAT &OPTIONAL (SEQUENCE *SEQUENCE*) (EXTRA-TEXT ""))
  (WHEN (AND (NEQ *ZMAIL-COMMAND-BUTTON* :KBD)
	     (COND ((EQ *ASK-BEFORE-EXECUTING-DANGEROUS-ZMAIL-COMMANDS* :ALL))
		   ((EQ *ASK-BEFORE-EXECUTING-DANGEROUS-ZMAIL-COMMANDS* :SELECTIVE)
		    (MEMQ 'COM-ZMAIL-MAP-OVER *SELECTED-DANGEROUS-ZMAIL-COMMANDS*))
		   (T NIL))
	     (> (SEQUENCE-NMSGS SEQUENCE) *TOO-MANY-MSGS-QUERY-THRESHOLD*))
    (UNLESS (TYPEOUT-BEEP-YES-OR-NO-P "Do you really want to ~A all ~D messages~A? "
				      WHAT (SEQUENCE-NMSGS SEQUENCE) EXTRA-TEXT)
      (ABORT-CURRENT-COMMAND))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DELETE-ALL
				"Delete these messages."
				()
  (CHECK-FOR-TOO-MANY-MSGS "delete")
  (SEND *SUMMARY-WINDOW* ':NEED-FULL-REDISPLAY)
  (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE :NAME "delete all" :INDICATOR 'DELETED)
    (DOMSGS (MSG *SEQUENCE*)
      (UNLESS (MSG-GET MSG 'DELETED)
	(MSG-PUT-UNDOABLY MSG T 'DELETED))))
  (COMPUTE-CURRENT-MSG-STATE))

(DEFPROP COM-ZMAIL-DELETE COM-ZMAIL-DELETE-ALL ASSOCIATED-ALL-COMMAND)

1;;; Separated from above so that it can move to the next undeleted message.
0(DEFUN (COM-ZMAIL-DELETE ASSOCIATED-MAP-COMMAND) (UNIVERSE FILTER-FUNCTION FILTER-ARG)
  (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE :NAME "multiple delete" :INDICATOR 'DELETED)
    (DO-UNIVERSE (MSG UNIVERSE
		      :NOTE-PROGRESS "Deleting matching messages in ~A")
      (WHEN (FUNCALL FILTER-FUNCTION MSG FILTER-ARG)
	(UNLESS (MSG-GET MSG 'DELETED)
	  (MSG-PUT-UNDOABLY MSG T 'DELETED)))))
  (IF (AND *MSG* (MSG-GET *MSG* 'DELETED))
      (MOVE-AFTER-DELETE (CHOOSE-DELETE-MODE))
      DIS-NONE))

(DEFPROP COM-ZMAIL-UNDELETE COM-ZMAIL-UNDELETE-ALL ASSOCIATED-ALL-COMMAND)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-UNDELETE-ALL
				 "Undelete all these messages."
				 ()
  (CHECK-FOR-TOO-MANY-MSGS "undelete")
  (SEND *SUMMARY-WINDOW* ':NEED-FULL-REDISPLAY)
  (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE :NAME "undelete all" :INDICATOR 'DELETED)
    (DOMSGS (MSG *SEQUENCE*)
      (WHEN (MSG-GET MSG 'DELETED)
	(MSG-PUT-UNDOABLY MSG NIL 'DELETED))))
  (COMPUTE-CURRENT-MSG-STATE))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-TYPE "Type this message." ()
  (WITH-OVERLYING-WINDOW (STREAM)
    (ZMAIL-TYPE-MSG *MSG* :STREAM STREAM))
  DIS-NONE)

(DEFPROP COM-ZMAIL-TYPE COM-ZMAIL-TYPE-ALL ASSOCIATED-ALL-COMMAND)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-TYPE-ALL
				 "Type out all these messages."
				 ()
  (CHECK-FOR-TOO-MANY-MSGS "type out")
  (WITH-OVERLYING-WINDOW (STANDARD-OUTPUT)
    (ZMAIL-TYPE-MSG-SEQUENCE))
  DIS-NONE)

(DEFUN ZMAIL-TYPE-MSG-SEQUENCE (&OPTIONAL (SEQUENCE *SEQUENCE*) &REST OPTIONS)
  (DO-UNIVERSE (MSG SEQUENCE :NOTE-PROGRESS "Typing messages in ~A")
    (LEXPR-FUNCALL #'ZMAIL-TYPE-MSG MSG OPTIONS)))

;;; Cribbed from CP Zmail.
(DEFUN ZMAIL-TYPE-MSG (MSG &KEY (REFORMAT-TEMPLATE T) (STREAM STANDARD-OUTPUT)
				(MARK-SEEN NIL))
  (PRINT-MSG-ATTRIBUTES MSG STREAM)
  (SCL:WITH-CHARACTER-STYLE ((MSG-DEFAULT-CHARACTER-STYLE MSG) STREAM)
    (MULTIPLE-VALUE-BIND (HEADERS-START-BP HEADERS-END-BP)
	(SELECTQ REFORMAT-TEMPLATE
	  ((NIL) (MSG-ORIGINAL-HEADERS-INTERVAL MSG))
	  ((T) (VALUES (MSG-START-BP MSG)
		       (OR (MSG-GET MSG 'HEADERS-END-BP)
			   (MSG-END-BP MSG))))
	  (OTHERWISE (COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG REFORMAT-TEMPLATE)))
      (MULTIPLE-VALUE-BIND (BODY-START-BP BODY-END-BP)
	  (MSG-BODY-INTERVAL MSG)
	(WHEN (MSG-GET MSG :ENCRYPTED)
	  (SETQ BODY-START-BP (MSG-DECRYPTED-BODY-INTERVAL MSG)
		BODY-END-BP NIL))
	(STREAM-OUT-INTERVAL STREAM HEADERS-START-BP HEADERS-END-BP T)
	(TERPRI STREAM)
	(STREAM-OUT-INTERVAL STREAM BODY-START-BP BODY-END-BP T))))
  (CL:FRESH-LINE STREAM)
  (WHEN MARK-SEEN
    (MSG-PUT MSG NIL 'UNSEEN)))

(DEFUN PRINT-MSG-ATTRIBUTES (MSG &OPTIONAL (STREAM STANDARD-OUTPUT))
  (CL:FRESH-LINE STREAM)
  #||
  (WHEN (OPERATION-HANDLED-P STREAM :DRAW-RECTANGLE)
    (LET ((BASELINE (SEND STREAM :BASELINE)))
      (MULTIPLE-VALUE-BIND (X Y)
	  (SEND STREAM :READ-CURSORPOS)
	(SEND STREAM :DRAW-RECTANGLE 20 (FLOOR BASELINE 3) X (+ Y (CEILING BASELINE 3)))))
    (SEND STREAM :INCREMENT-CURSORPOS 30 0))
  ||#
  (MULTIPLE-VALUE-BIND (INDEX SEQUENCE)
      (LOCATE-MSG-IN-SOME-SEQUENCE MSG)
    (FORMAT STREAM "Message #~D~:[ in ~A~;~*~] (~D line~:P)"
	    (1+ INDEX) (EQ SEQUENCE *SEQUENCE*) (SEND SEQUENCE :NAME)
	    (COUNT-LINES (MSG-INTERVAL MSG)))
    (LET ((FLAG NIL))
      (LOOP FOR (NAME KEY) IN *SAVED-INTERNAL-PROPERTIES-ALIST*
	    DOING
	(WHEN (COND ((EQ KEY 'LAST)
		     (= INDEX (1- (SEQUENCE-NMSGS SEQUENCE))))
		    ((EQ KEY 'LAST-UNDELETED)
		     (AND ( INDEX (1- (SEQUENCE-NMSGS SEQUENCE)))	;let Last suppress it
			  (NOT (MSG-GET MSG 'DELETED))
			  (LOOP FOR MSG BEING THE ARRAY-ELEMENTS OF (SEND SEQUENCE :ARRAY)
				    FROM (1+ INDEX)
				ALWAYS (MSG-GET MSG 'DELETED))))
		    ((MSG-GET MSG KEY)))
	  (CL:WRITE-STRING (IF FLAG ", " " (") STREAM)
	  (CL:WRITE-STRING NAME STREAM)
	  (SETQ FLAG T)))
      (WHEN FLAG (CL:WRITE-STRING ")" STREAM))))
  (FORMAT STREAM "~@[ {~A}~]~%" (MSG-GET MSG 'KEYWORDS-STRING)))

(DEFUN LOCATE-MSG-IN-SOME-SEQUENCE (MSG)
  (DECLARE (VALUES INDEX SEQUENCE))
  (LET ((INDEX (LOCATE-MSG-IN-SEQUENCE MSG *SEQUENCE* NIL)))
    (IF INDEX
	(VALUES INDEX *SEQUENCE*)
	(LET ((HOME-BUFFER (MSG-BUFFER MSG)))
	  (VALUES (LOCATE-MSG-IN-SEQUENCE MSG HOME-BUFFER) HOME-BUFFER))))) 

(DEFUN MAKE-SEQUENCE-STREAM (SEQUENCE)
  (LET-CLOSED ((*ARRAY* (SEND SEQUENCE ':ARRAY)) (*I* -1)
	       (*LINE*) (*END-LINE*))
    'SEQUENCE-IO))

;;; Bare minimum for typing out purposes
(LOCAL-DECLARE ((SPECIAL *ARRAY* *I* *LINE* *END-LINE*))

(DEFSELECT SEQUENCE-IO
  (:LINE-IN (&OPTIONAL SIZE EOF)
   (COND ((NULL *LINE*)
	  (IF ( (SETQ *I* (1+ *I*)) (ARRAY-ACTIVE-LENGTH *ARRAY*))
	      (IF EOF (ERROR EOF) (VALUES (CANONICALIZE-LINE "" SIZE) T))
	      (LET ((MSG (AREF *ARRAY* *I*)))
		(SETQ *LINE* (BP-LINE (MSG-START-BP MSG))
		      *END-LINE* (BP-LINE (MSG-END-BP MSG))))
	      (SEQUENCE-IO ':LINE-IN SIZE EOF)))
	 ((EQ *LINE* *END-LINE*)
	  (SETQ *LINE* NIL)
	  (CANONICALIZE-LINE "" SIZE))
	 (T
	  (PROG1 (CANONICALIZE-LINE *LINE* SIZE)
		 (SETQ *LINE* (LINE-NEXT *LINE*))))))
  (:CLOSE (&REST IGNORE)
   T)
  (:CURRENT-MSG-NO ()
   *I*)))

(DEFUN CANONICALIZE-LINE (LINE SIZE &AUX LEN RET-LINE)
  (IF (NULL SIZE) LINE
      (SETQ LEN (ARRAY-ACTIVE-LENGTH LINE)
	    RET-LINE (MAKE-ARRAY LEN ':TYPE 'ART-STRING
				     ':LEADER-LENGTH (IF (NUMBERP SIZE) SIZE NIL)))
      (COPY-ARRAY-CONTENTS LINE RET-LINE)
      (AND (NUMBERP SIZE) (STORE-ARRAY-LEADER LEN RET-LINE 0))
      RET-LINE))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-FIND-STRING
  "Move to the next message, following the current one, that contains the specified string.
With a negative numeric argument, searches backward, for the next previous message 
with the specified string."
				(NUMERIC-ARG-OK)
  (MULTIPLE-VALUE-BIND (FUNCTION STRING)
      (ZMAIL-READ-FIND-SEARCH-STRING (IF (MINUSP *NUMERIC-ARG*)
					 "Find string reverse" "Find string"))
    (MULTIPLE-VALUE-BIND (START END FROM-END NOTE-STRING)
	(IF (MINUSP *NUMERIC-ARG*)
	    (VALUES 0 *MSG-NO*			1;Reverse 2do-universe1 is exclusive...
0		    T "Searching backward through ~A.")
	  (VALUES (1+ *MSG-NO*) NIL NIL "Searching forward through ~A."))
      (DO-UNIVERSE (MSG *SEQUENCE*
			:START START
			:END END
			:FROM-END FROM-END
			:NO-PREPARE T		1;Don't force loading to completion.
0			:PARSING NIL		1;We won't be parsing any messages.
0			:NOTE-PROGRESS NOTE-STRING)
	1;; Don't need to parse messages when looking for a string -- 0[Jump(R)]1 will do that.
0	(WHEN (AND (NOT (CL:GETF (MSG-STATUS MSG) 'DELETED))
		   (FUNCALL FUNCTION (MSG-START-BP MSG) STRING NIL NIL NIL (MSG-END-BP MSG)))
	  (RETURN-FROM COM-ZMAIL-FIND-STRING (ZMAIL-SELECT-MSG MSG))))
      (BARF "Search failed: ~A" (IF (STRINGP STRING) STRING (FIRST STRING))))))

(DEFUN ZMAIL-BOYER-SEARCH (TARGET KEY &OPTIONAL IGNORE IGNORE IGNORE LIMIT-BP)
  (MULTIPLE-VALUE-BIND (STRING SKIP-TABLE REOCCURRENCE-TABLE)
      (IF (LISTP KEY)
	  (VALUES (FIRST KEY) (SECOND KEY) (THIRD KEY))
	(VALUES KEY NIL NIL))
    (SEARCH TARGET STRING NIL NIL NIL LIMIT-BP NIL SKIP-TABLE REOCCURRENCE-TABLE)))

(DEFINE-ZMAIL-GLOBAL *CONCATENATE-REFORMAT-TEMPLATE* 'DEFAULT-REFORMAT-TEMPLATE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DELETE-AND-SAVE-MSG
				"Delete the current msg and save its text to be yanked back"
				()
  (COM-ZMAIL-KILL-RING-SAVE-MSG)
  (COM-ZMAIL-DELETE))

(DEFUN ONE-BLANK-LINE (BP &AUX (*INTERVAL* (BP-TOP-LEVEL-NODE BP)))
  (DELETE-AROUND '(#\CR) BP)
  (OR (BEG-LINE-P BP) (INSERT-MOVING BP #\CR))
  (OR (LINE-BLANK-P (BP-LINE BP)) (INSERT BP #\CR)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-YANK-MSG
				"Appends a message to the end of the current message.
Without a numeric argument, appends the last deleted message.
With a numeric argument, appends that message from this sequence."
				(NUMERIC-ARG-OK)
  (WITH-MSG-REDISPLAY-DELAYED
    (LET ((MSG (IF *NUMERIC-ARG-P* (GET-MSG-FROM-ARG) *LAST-DELETED-MSG*)))
      (WHEN (NULL MSG)
	(BARF "No messages have yet been deleted and you did not give a numeric argument."))
      (WHEN (EQ MSG *MSG*)
	(BARF "Can't yank a message into itself."))
      (WHEN (EQ (MSG-PARSED-P MSG) :KILLED)
	(BARF "Can't yank a message that has already been expunged."))
      1;;This uses 2(point) 1because it really wants to end up between the messages.
0      (LET ((POINT (POINT)))
	(MOVE-BP POINT (MSG-END-BP *MSG*))
	(INSERT-TEXT-OF-MSG POINT MSG *CONCATENATE-REFORMAT-TEMPLATE*)
	(ONE-BLANK-LINE POINT))
      (WITH-STACK-LIST (MSGS MSG)
	(MERGE-MSGS-REFERENCES MSGS *MSG*)
	(MERGE-MSGS-FILE-REFERENCES MSGS *MSG*))
      (MSG-PUT MSG T 'DELETED)
      (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS *MSG*)))
  (UPDATE-MSG-SUMMARY-LINE *MSG* :SIZE)
  DIS-TEXT)

(DEFUN GET-MSG-FROM-ARG ()
  (AND (OR (< *NUMERIC-ARG* 1)
	   (> *NUMERIC-ARG* (SEND *SEQUENCE* ':NMSGS)))
       (BARF "Argument out of range"))
  (AREF (SEND *SEQUENCE* ':ARRAY) (1- *NUMERIC-ARG*)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-OCCUR
  "Show lines within messages containing the given search string."
				()
  (LET ((*TYPEOUT-WINDOW* (IF (TV:SHEET-EXPOSED-P *SUMMARY-WINDOW*)
			      (SEND *SUMMARY-WINDOW* :TYPEOUT-WINDOW)
			    (WINDOW-TYPEOUT-WINDOW *WINDOW*))))
    (CHECK-FOR-TOO-MANY-MSGS "search for a string in")
    (MULTIPLE-VALUE-BIND (FUN STR)
	(ZMAIL-READ-FIND-STRING-SEARCH-STRING "Message lines containing")
      (SEND *TYPEOUT-WINDOW* :OUTPUT-HOLD-EXCEPTION)	;Make sure properly typeout exposed
      (TV:WINDOW-CALL-RELATIVE (*TYPEOUT-WINDOW*)	;For **MORE** blinking
	(LET ((*COMTAB* *ZMAIL-COMTAB*))	;For mouse-sensitivity at **MORE** breaks
	  (DO ((STREAM (MAKE-SEQUENCE-STREAM *SEQUENCE*))
	       (LINE) (EOF))
	      (NIL)
	    (MULTIPLE-VALUE (LINE EOF)
	      (SEND STREAM :LINE-IN NIL))
	    (WHEN EOF
	      (RETURN NIL))
	    (WHEN (FUNCALL FUN STR LINE)
	      (TRUNCATED-SENSITIVE-FORMAT LINE 'MSG-LINE *TYPEOUT-WINDOW* "~A~%" LINE)))
	  (SEND *TYPEOUT-WINDOW* :LINE-OUT "Done."))))
    (CHECK-FOR-ZMAIL-TYPEOUT-WINDOW-TYPEOUT))
  DIS-NONE)

(DEFUN ZMAIL-BOYER-STRING-SEARCH (KEY TARGET)
  (MULTIPLE-VALUE-BIND (STRING SKIP-TABLE REOCCURRENCE-TABLE)
      (IF (LISTP KEY)
	  (VALUES (FIRST KEY) (SECOND KEY) (THIRD KEY))
	(VALUES KEY NIL NIL))
    (IF (AND SKIP-TABLE REOCCURRENCE-TABLE)
	(BOYER-SEARCH-INTERNAL STRING TARGET SKIP-TABLE REOCCURRENCE-TABLE
			       0 (STRING-LENGTH TARGET))
      (STRING-SEARCH KEY TARGET))))

(DEFUN ZMAIL-READ-FIND-STRING-SEARCH-STRING (PROMPT)
  (DECLARE (VALUES FUNCTION KEY))
  (ZMAIL-READ-FIND-STRING PROMPT)
  (VALUES-LIST *ZMAIL-FIND-STRING-SEARCH-DEFAULT*))

(DEFUN ZMAIL-READ-FIND-SEARCH-STRING (PROMPT)
  (DECLARE (VALUES FUNCTION KEY))
  (ZMAIL-READ-FIND-STRING PROMPT)
  (VALUES-LIST *ZMAIL-FIND-SEARCH-DEFAULT*))

(DEFUN ZMAIL-READ-FIND-STRING (PROMPT)
  (LET ((STR (GET-EXTENDED-SEARCH-16B-STRING PROMPT *ZMAIL-FIND-DEFAULT*)))
    (UNLESS (EQ STR *ZMAIL-FIND-DEFAULT*)
      (SETQ *ZMAIL-FIND-DEFAULT* STR)		1;Save for next time.
0      (MULTIPLE-VALUE-BIND (STRINGS EXPR CR-P)
	  (PARSE-EXTENDED-SEARCH-STRING STR)
	(SETQ *ZMAIL-FIND-SEARCH-DEFAULT*
	        (COND ((NLISTP STRINGS)
		       `(ZMAIL-BOYER-SEARCH (,STRINGS
					     ,(GENERATE-BOYER-SKIP-TABLE STRINGS)
					     ,(GENERATE-BOYER-REOCCURRENCE-TABLE STRINGS))))
		      (EXPR
		       `(FSM-EXPR-SEARCH (,STRINGS ,EXPR)))
		      (T
		       `(FSM-SEARCH ,STRINGS)))
	      *ZMAIL-FIND-STRING-SEARCH-DEFAULT*
	        (IF (OR (LISTP STRINGS) CR-P)
		    `(FSM-STRING-SEARCH (,(IF (LISTP STRINGS) STRINGS `(,STRINGS))
					 ,EXPR ,CR-P))
		  `(ZMAIL-BOYER-STRING-SEARCH (,STRINGS
					       ,(GENERATE-BOYER-SKIP-TABLE STRINGS)
					       ,(GENERATE-BOYER-REOCCURRENCE-TABLE STRINGS)))))
	))))

(DEFUN MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR-RAW (WHERE FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (LABELS ((CALL-POP-UP-MINI-BUFFER-EDITOR (WHERE)
	     (LET ((*MODE-LINE-MORE-ABOVE-BELOW* NIL))	1;Not defined inside Zmail (yet).
0	       (LEXPR-SEND *POP-UP-MINI-BUFFER-EDITOR*
			   :CALL-MINI-BUFFER-NEAR-WINDOW WHERE FUNCTION ARGS)))
	   (CALL-POP-UP-MINI-BUFFER-EDITOR-IF-EXPOSED (WINDOW)
	     (IF (TV:SHEET-EXPOSED-P WINDOW)
		 (CALL-POP-UP-MINI-BUFFER-EDITOR WINDOW)
	       (CL:APPLY FUNCTION ARGS))))
    (CL:CASE WHERE
      ((:MOUSE :LEFT :MIDDLE :RIGHT)
       (CALL-POP-UP-MINI-BUFFER-EDITOR :MOUSE))
      (:KBD
	(CL:APPLY FUNCTION ARGS))
      (OTHERWISE
	(CL:ETYPECASE WHERE
	  (TV:SHEET
	    (CALL-POP-UP-MINI-BUFFER-EDITOR-IF-EXPOSED WHERE))
	  (LIST
	    (CL:ECASE (FIRST WHERE)
	      (:KBD
		(CL:APPLY FUNCTION ARGS))
	      ((:MOUSE :LEFT :MIDDLE :RIGHT)
	       (CALL-POP-UP-MINI-BUFFER-EDITOR :MOUSE))
	      (:WINDOW
		(CALL-POP-UP-MINI-BUFFER-EDITOR-IF-EXPOSED (SECOND WHERE))))))))))

(DEFUN MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR (WHERE FUNCTION &REST ARGS)
  (LET ((VALUE (CL:APPLY #'MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR-RAW WHERE FUNCTION ARGS)))
    (WHEN (OR (EQ VALUE NIL) (EQ VALUE T))
      (ABORT-CURRENT-COMMAND))
    VALUE))

(DEFVAR *DEFAULT-MAP-OVER-KEYWORDS* NIL "Last keywords added to all of a set of messages.")
(DEFVAR *DEFAULT-MAP-OVER-UNKEYWORDS*
	NIL "Last keywords removed from all of a set of messages.")

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *FILTER-KEYWORDS-ALIST* COM-ZMAIL-KEYWORDS-ALL)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MAP-OVER-KEYWORDS*
					     COM-ZMAIL-KEYWORDS-ALL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-KEYWORDS-ALL (STRING)
  (APPEND-TO-ARRAY STRING "Put some keywords on all these messages: ")
  (WHEN *DEFAULT-MAP-OVER-KEYWORDS*
    (APPEND-TO-ARRAY STRING "L: ")
    (APPEND-TO-ARRAY STRING (STRING-FROM-KEYWORDS *DEFAULT-MAP-OVER-KEYWORDS*))
    (APPEND-TO-ARRAY STRING "; "))
  (UPDATE-KEYWORDS-WHO-LINE-DOCUMENTATION-1 STRING ':INDIVIDUAL-FILTERS)
  (APPEND-TO-ARRAY STRING "R: menu."))

(DEFINE-COMMAND-MAP-OVER-DOCUMENTATION-UPDATER COM-ZMAIL-KEYWORDS-ALL (FOR-DEFAULT-OR-MENU)
  (CL:ECASE FOR-DEFAULT-OR-MENU
    (:DEFAULT
      (IF *DEFAULT-MAP-OVER-KEYWORDS*
	  (FORMAT NIL "Add keywords ~A" (STRING-FROM-KEYWORDS *DEFAULT-MAP-OVER-KEYWORDS*))))
    (:MENU
      "Add keywords selected from a menu")))

(DEFPROP COM-ZMAIL-KEYWORDS COM-ZMAIL-KEYWORDS-ALL ASSOCIATED-ALL-COMMAND)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-KEYWORDS-ALL
				 "Put some keywords on all these messages."
				 ()
  (ZMAIL-KEYWORDS-ALL T))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *FILTER-KEYWORDS-ALIST* COM-ZMAIL-UNKEYWORDS-ALL)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *DEFAULT-MAP-OVER-UNKEYWORDS*
					     COM-ZMAIL-UNKEYWORDS-ALL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-UNKEYWORDS-ALL (STRING)
  (APPEND-TO-ARRAY STRING "Remove some keywords from all these messages: ")
  (WHEN *DEFAULT-MAP-OVER-UNKEYWORDS*
    (APPEND-TO-ARRAY STRING "L: ")
    (APPEND-TO-ARRAY STRING (STRING-FROM-KEYWORDS *DEFAULT-MAP-OVER-UNKEYWORDS*))
    (APPEND-TO-ARRAY STRING "; "))
  (UPDATE-KEYWORDS-WHO-LINE-DOCUMENTATION-1 STRING ':INDIVIDUAL-FILTERS)
  (APPEND-TO-ARRAY STRING "R: menu."))

(DEFINE-COMMAND-MAP-OVER-DOCUMENTATION-UPDATER COM-ZMAIL-UNKEYWORDS-ALL (FOR-DEFAULT-OR-MENU)
  (CL:ECASE FOR-DEFAULT-OR-MENU
    (:DEFAULT
      (IF *DEFAULT-MAP-OVER-UNKEYWORDS*
	  (FORMAT NIL "Remove keywords ~A"
		  (STRING-FROM-KEYWORDS *DEFAULT-MAP-OVER-UNKEYWORDS*))))
    (:MENU
      "Remove keywords selected from a menu")))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-UNKEYWORDS-ALL
				 "Remove some keywords from all these messages."
				 ()
  (ZMAIL-KEYWORDS-ALL NIL))

(DEFUN ZMAIL-KEYWORDS-ALL (ON-P &AUX KEYWORDS)
  (SETQ KEYWORDS (CL:ECASE *ZMAIL-COMMAND-BUTTON*
		   ((:LEFT :KBD)
		    (IF ON-P *DEFAULT-MAP-OVER-KEYWORDS* *DEFAULT-MAP-OVER-UNKEYWORDS*))
		   (:MIDDLE
		     :INDIVIDUAL-FILTERS)
		   (:RIGHT
		     (REVERSE
		       (CHOOSE-KEYWORDS
			 (FORMAT NIL "Keywords to ~:[remove from~;add to~] all messages:"
				 ON-P))))))
  (UNLESS KEYWORDS (BARF "No keywords specified."))
  (WHEN (EQ KEYWORDS :INDIVIDUAL-FILTERS)
    (UNLESS (LOOP FOR (NIL . KWD) IN *FILTER-KEYWORDS-ALIST* THEREIS KWD)
      (BARF "There are no keyword-associated individual filters.")))
  (CHECK-FOR-TOO-MANY-MSGS
    (FORMAT NIL
	    "~:[remove~;add~]~:[ the~;~] keyword~P ~:[~{~A~^, ~}~;by individual filters~*~] ~
           ~:[from~;to~]"
	    ON-P (EQ KEYWORDS :INDIVIDUAL-FILTERS)
	    (IF (EQ KEYWORDS :INDIVIDUAL-FILTERS) 2 (LENGTH KEYWORDS))
	    (EQ KEYWORDS :INDIVIDUAL-FILTERS) KEYWORDS ON-P))
  (WITH-MULTIPLE-UNDO (UNDO-MULTIPLE-KEYWORDS)
    (DOMSGS (MSG *SEQUENCE*)
      (LET* ((OLD-KEYWORDS (MSG-GET MSG 'KEYWORDS))
	     (CHANGES (IF (EQ KEYWORDS :INDIVIDUAL-FILTERS)
			  (GET-KEYWORDS-FROM-MSG-BY-FILTERING MSG)
			KEYWORDS))
	     (NEW-KEYWORDS (IF ON-P
			       (DO ((L CHANGES (CDR L))
				    (NL (REVERSE OLD-KEYWORDS)))
				   ((NULL L) (NREVERSE NL))
				 (OR (MEMQ (CAR L) NL)
				     (PUSH (CAR L) NL)))
			     (DO ((L OLD-KEYWORDS (CDR L))
				  (NL NIL))
				 ((NULL L) (NREVERSE NL))
			       (OR (MEMQ (CAR L) CHANGES)
				   (PUSH (CAR L) NL))))))
	(SEND *CURRENT-UNDO* :SAVE-MULTIPLE-UNDO :MSG MSG)
	(CHANGE-MSG-KEYWORDS MSG NEW-KEYWORDS OLD-KEYWORDS))))
  (UNLESS (EQ KEYWORDS :INDIVIDUAL-FILTERS)
    (IF ON-P
	(SETQ *DEFAULT-MAP-OVER-KEYWORDS* KEYWORDS)
      (SETQ *DEFAULT-MAP-OVER-UNKEYWORDS* KEYWORDS)))
  (IF ON-P
      (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*DEFAULT-MAP-OVER-KEYWORDS*)
    (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION '*DEFAULT-MAP-OVER-UNKEYWORDS*))
  (SEND *SUMMARY-WINDOW* :NEED-FULL-REDISPLAY)
  (COMPUTE-CURRENT-MSG-STATE))			;Update mode line, etc.


(DEFUN (COM-ZMAIL-MAIL ASSOCIATED-ALL-COMMAND) ()
  (SELECTQ (CHOOSE-MAIL-MODE)
    (:FORWARD (COM-ZMAIL-FORWARD-ALL))
    (:REDISTRIBUTE (COM-ZMAIL-REDISTRIBUTE-ALL))
    (OTHERWISE (BARF "That command does not take a filter argument"))))

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-REPLY-ALL
					       (STRING &OPTIONAL RECURSIVE)
  (OR RECURSIVE (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'NORMAL-REPLY NIL T))
  (STRING-NCONC STRING "Reply to these messages: "
		(GET 'NORMAL-REPLY ':WHO-LINE-DOCUMENTATION)))

(DEFPROP COM-ZMAIL-REPLY COM-ZMAIL-REPLY-ALL ASSOCIATED-ALL-COMMAND)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REPLY-ALL
				"Reply to all these messages at once." ()
  (CHECK-FOR-TOO-MANY-MSGS "reply to")
  (NORMAL-REPLY-INTERNAL (LIST-SEQUENCE *SEQUENCE*))
  DIS-NONE)

(DEFPROP COM-ZMAIL-CONCATENATE COM-ZMAIL-CONCATENATE-ALL ASSOCIATED-ALL-COMMAND)

(DEFPROP COM-ZMAIL-CONCATENATE-ALL
	 "Append these messages to the first one, delete the rest."
	 :WHO-LINE-DOCUMENTATION)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-CONCATENATE-ALL "Append these messages together.
The text of the first message becomes the concatenation of the text of all messages.
All but resultant first message are then marked as deleted." ()
  (CHECK-FOR-TOO-MANY-MSGS "concatenate")
  (LET* ((SEQUENCE-MSGS (LISTARRAY (SEQUENCE-ARRAY *SEQUENCE*)))
	 (FIRST-MSG (FIRST SEQUENCE-MSGS))
	 (OTHER-MSGS (REST1 SEQUENCE-MSGS)))
    (CONCATENATE-MSGS-TO-MSG OTHER-MSGS FIRST-MSG)
    (ZMAIL-SELECT-MSG FIRST-MSG)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-CONCATENATE
				 "Append the current message to another message"
				 ()
  (ZMAIL-CONCATENATE-MSG *MSG* T))

(DEFUN ZMAIL-CONCATENATE-MSG (MSG &OPTIONAL CHOOSE-P)
  (LET ((INTO-MSG (IF (OR CHOOSE-P (SELECTQ *ZMAIL-COMMAND-BUTTON*
				      (:RIGHT T)
				      (:MIDDLE
				       (BARF "Click middle doesn't make sense here."))))
		       (CHOOSE-MSG-FROM-SUMMARY "another message")
		     *MSG*)))
    (CONCATENATE-MSG-TO-MSG MSG INTO-MSG))
  DIS-NONE)

(DEFUN CONCATENATE-MSG-TO-MSG (MSG INTO-MSG
			       &OPTIONAL (TEMPLATE *CONCATENATE-REFORMAT-TEMPLATE*))
  (WITH-STACK-LIST (MSGS MSG)
    (CONCATENATE-MSGS-TO-MSG MSGS INTO-MSG TEMPLATE))
  (ZMAIL-DELETE-MSG MSG))

(DEFUN CONCATENATE-MSGS-TO-MSG (MSGS INTO-MSG
				&OPTIONAL (TEMPLATE *CONCATENATE-REFORMAT-TEMPLATE*))
  (WHEN (CL:FIND INTO-MSG MSGS)
    (BARF "Can't concatenate message to itself."))
  (WITH-MULTIPLE-UNDO (UNDO-CONCATENATE)
    (SEND *CURRENT-UNDO* :SAVE-UNDO :MSG INTO-MSG)
    (LET ((BP (MSG-END-BP INTO-MSG)))
      (DOLIST (MSG MSGS)
	(SEND *CURRENT-UNDO* :SAVE-MULTIPLE-UNDO :MSG MSG)
	(INSERT BP #\Return)
	(INSERT-TEXT-OF-MSG BP MSG TEMPLATE)
	(MSG-PUT-UNDOABLY MSG T 'DELETED))))
  (WITH-MSG-REDISPLAY-DELAYED
    (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS INTO-MSG)
    (MERGE-MSGS-REFERENCES MSGS INTO-MSG)
    (MERGE-MSGS-FILE-REFERENCES MSGS INTO-MSG))
  (UPDATE-MSG-SUMMARY-LINE INTO-MSG :SIZE))

(DEFUN MERGE-MSGS-REFERENCES (FROM-MSGS INTO-MSG)
  (LET ((MSG-REFS (LOOP FOR MSG IN FROM-MSGS APPEND (MSG-REFERENCES MSG)))
	(MSG-IDS (LOOP FOR MSG IN FROM-MSGS APPEND (GET-MSG-IDS MSG)))
	(OLD-MSG-IDS (GET-MSG-IDS INTO-MSG)))
    (SETQ MSG-REFS (APPEND (MSG-REFERENCES INTO-MSG) MSG-REFS))
    (SETQ MSG-IDS (APPEND (GET-MSG-IDS INTO-MSG) MSG-IDS))
    (SETQ MSG-REFS (MSG-REFERENCES-ELIMINATE-DUPLICATES MSG-REFS))
    (SETQ MSG-IDS (MSG-REFERENCES-ELIMINATE-DUPLICATES MSG-IDS T))
    (SETQ MSG-REFS (MSG-REFERENCES-EXCLUDE-IDS MSG-IDS MSG-REFS))
    (MSG-PUT INTO-MSG MSG-REFS 'REFERENCES)
    (MSG-PUT INTO-MSG MSG-IDS 'MSG-IDS)
    (UPDATE-MSG-REFERENCES-GLOBALLY INTO-MSG OLD-MSG-IDS)
    (ADD-HEADER-TO-MSG INTO-MSG ':INCLUDED-MSGS (MAPCAR #'CDR MSG-IDS))
    (WHEN MSG-REFS
      (ADD-HEADER-TO-MSG INTO-MSG ':INCLUDED-REFERENCES MSG-REFS))))

(DEFUN MERGE-MSGS-FILE-REFERENCES (FROM-MSGS INTO-MSG)
  (LET* ((CURRENT-FILES (MSG-GET INTO-MSG :FILE-REFERENCES))
	 (OTHER-FILES (LOOP FOR MSG IN FROM-MSGS
			    APPEND (MSG-GET MSG :FILE-REFERENCES)))
	 (NEW-FILES (CL:REMOVE-DUPLICATES (APPEND CURRENT-FILES OTHER-FILES) :TEST #'EQUAL)))
    (ADD-HEADER-TO-MSG INTO-MSG :FILE-REFERENCES NEW-FILES :DELETE-IF-EMPTY T)))

(DEFUN ZMAIL-DELETE-MSG (MSG &OPTIONAL (BUTTON ':KBD))
  (IF (EQ MSG *MSG*)
      (MUST-REDISPLAY *WINDOW*
		      (LET ((*ZMAIL-COMMAND-BUTTON* BUTTON)
			    (*NUMERIC-ARG-P* NIL))
			(COM-ZMAIL-DELETE)))
      (MSG-PUT MSG T 'DELETED)))

(DEFUN ZMAIL-UNDELETE-MSG (MSG)
  (MSG-PUT MSG NIL 'DELETED)
  (IF (EQ MSG *MSG*)
      (COMPUTE-CURRENT-MSG-STATE)
      DIS-NONE))

(DEFUN CHOOSE-MSG-FROM-SUMMARY (PROMPT)
  (WHEN (OR (NULL *SEQUENCE*)
	    (ZEROP (SEND *SEQUENCE* :NMSGS)))
    (BARF "There are no messages from which to choose."))
  (PROMPT-LINE "Select ~A with the mouse or type a message number." PROMPT)
  (UNWIND-PROTECT
      (LOOP DOING
	(MULTIPLE-VALUE-BIND (THING KEY)
	    (WITH-INPUT-EDITING-OPTIONS ((:PREEMPTABLE :BLIP)
					 (:NO-INPUT-SAVE T)
					 (:PROMPT "Message number: "))
	      ;; This should just be calling (PROMPT-AND-READ :INTEGER) so that the user
	      ;; gets a reasonable error message if something other than a number is typed
	      ;; or if the number is out of range.  However, PROMPT-AND-READ doesn't handle
	      ;; BLIPs properly so we can't use it.
	      (WITH-INPUT-EDITING (QUERY-IO :LINE)
		(LOOP AS LINE = (READLINE QUERY-IO)
		      DO (LET ((NUMBER (PARSE-NUMBER LINE 0 NIL 10. T)))
			   (WHEN (AND NUMBER (PLUSP NUMBER)
				      ( NUMBER (SEND *SEQUENCE* :NMSGS)))
			     (RETURN (VALUES (AREF (SEND *SEQUENCE* :ARRAY) (1- NUMBER))
					     :MSG))))
			 (BEEP))))		;let the user know we didn't accept his input
	  (SELECTQ KEY
	    (:MSG (RETURN THING))
	    (:BLIP
	     (SELECTQ (FIRST THING)
	       (SUMMARY-MOUSE
		(LET ((MSG (CADADR THING)))
		  (TYPEIN-LINE-MORE "~D" (1+ (MSG-DISPLAYED-INDEX MSG)))
		  (RETURN MSG)))
	       (T
		(BEEP)				;let the user know we didn't like his blip
		(SEND QUERY-IO :CLEAR-INPUT))))	;flush the blip and any typeahead
	    )))
    (SEND QUERY-IO :MAKE-COMPLETE)))

(DEFMACRO ADD-OTHER-COMMANDS (&REST COMMANDS)
  `(SETQ *OTHER-COMMAND-ALIST*
	 (APPEND *OTHER-COMMAND-ALIST*
		 (MAKE-COMMAND-ALIST ',(COPYLIST COMMANDS)))))

(DEFINE-ZMAIL-GLOBAL *LAST-OTHER-MENU-ITEM* NIL)

;;; Let the user specify what this does if (s)he wants
(DEFINE-ZMAIL-GLOBAL *MIDDLE-OTHER-COMMAND* NIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-OTHER-COMMANDS (STRING)
  (FORMAT STRING "Execute auxiliary command: ~@[L: ~A; ~]~@[M: ~A; ~]R: menu."
	  (IF (EQ (CDR *LAST-OTHER-MENU-ITEM*) 'COM-ZMAIL-HARDCOPY-MSG)
	      (HARDCOPY-DESCRIBE-OPTIONS
		*LAST-HARDCOPY-OPTIONS* *DEFAULT-HARDCOPY-OPTIONS* NIL)
	    (CAR *LAST-OTHER-MENU-ITEM*))
	  (IF (EQ *MIDDLE-OTHER-COMMAND* 'COM-ZMAIL-HARDCOPY-MSG)
	      "Hardcopy selecting device and options from menu"
	    (NAME-FROM-MENU-VALUE *MIDDLE-OTHER-COMMAND* *OTHER-COMMAND-ALIST*))))

(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *MIDDLE-OTHER-COMMAND* COM-ZMAIL-OTHER-COMMANDS)
(ASSOCIATE-OPTION-WITH-COMMAND-DOCUMENTATION *LAST-HARDCOPY-OPTIONS* COM-ZMAIL-OTHER-COMMANDS)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-OTHER-COMMANDS "Execute an auxiliary command.
Left defaults to last command used.  Middle is a user option.
Right gives a menu of these commands." (NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (LET ((OLD-ZMAIL-COMMAND-BUTTON *ZMAIL-COMMAND-BUTTON*)
	(COMMAND (CHOOSE-OTHER-COMMAND)))
    ;;; If click middle to get the command, treat it as if we clicked right on the command.
    (WHEN (EQ OLD-ZMAIL-COMMAND-BUTTON :MIDDLE)
      (SETQ *ZMAIL-COMMAND-BUTTON* :RIGHT))
    (FUNCALL COMMAND)))

(DEFUN CHOOSE-OTHER-COMMAND (&AUX COMMAND)
  (UNLESS *OTHER-COMMAND-ALIST* (BARF "No other commands"))
  (LOOP FOR (NIL . COMMAND) IN *OTHER-COMMAND-ALIST*
	WHEN (GET COMMAND 'WHO-LINE-DOCUMENTATION-UPDATER)
	  DO (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION COMMAND))
  (MULTIPLE-VALUE (COMMAND *LAST-OTHER-MENU-ITEM*)
    (ZMAIL-MENU-CHOOSE 'ZMAIL-MOMENTARY-COMMAND-MENU *OTHER-COMMAND-ALIST*
		       *LAST-OTHER-MENU-ITEM* NIL *MIDDLE-OTHER-COMMAND*))
  (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-OTHER-COMMANDS)
  COMMAND)

;;; Make Show Printer Status available in Zmail.
(ADOPT-COMMAND-AS-ZMAIL-TOP-LEVEL-COMMAND 'COM-SHOW-PRINTER-STATUS)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-HARDCOPY-FILE
				"Sends a file to the local hardcopy device for printing."
				(NO-SEQUENCE-OK)
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Hardcopy file" (DEFAULT-PATHNAME))))
    (RUN-HARDCOPY-FILE-BACKGROUND PATHNAME))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-COMPILE-FILE
 "Compile a specified file.  With a numeric arg, prompts for an output file."
 (NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (LET* ((DEFAULT (DEFAULT-PATHNAME))
	 (PATH (ACCEPT-DEFAULTED-PATHNAME "Compile file" DEFAULT :SPECIAL-TYPE :LISP))
	 (OUT-PATH (AND *NUMERIC-ARG-P*
			(ACCEPT-DEFAULTED-PATHNAME (FORMAT NIL "Compile ~A into file" PATH)
						 PATH :SPECIAL-TYPE :BIN :DIRECTION :WRITE))))
    (TYPEIN-LINE "Compiling ~A~@[ into ~A~] ... " PATH OUT-PATH)
    (COMPILER:COMPILE-FILE PATH OUT-PATH)
    (TYPEIN-LINE-MORE "Done."))
  DIS-NONE)

;;; Vanilla load-file command taking its default the same way as Show File 
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-LOAD-FILE
				"Load a specified file." (NO-SEQUENCE-OK)
  (LET* ((DEFAULT (DEFAULT-PATHNAME))
	 (DEFAULT-CANONICAL-TYPE (SEND DEFAULT :CANONICAL-TYPE))
	 (TYPE-FOR-READ (WHEN (AND DEFAULT-CANONICAL-TYPE
				   (GET DEFAULT-CANONICAL-TYPE :BINARY-FILE-BYTE-SIZE))
			  DEFAULT-CANONICAL-TYPE))			
	 (PATHNAME (READ-UNDEFAULTED-PATHNAME "Load file:" DEFAULT TYPE-FOR-READ))
	 (PATH (SEND (FS:MERGE-PATHNAMES PATHNAME DEFAULT NIL) :NEW-PATHNAME
		     :TYPE (OR (SEND PATHNAME :TYPE) TYPE-FOR-READ)
		     :VERSION (SEND PATHNAME :VERSION))))
    ;; Send the "Loading foo" message to the typein window.
    ;; This isn't exactly right.
    (LET ((STANDARD-OUTPUT *TYPEIN-WINDOW*))
      (TYPEIN-LINE "~:|")
      (LOAD PATH)
      (TYPEIN-LINE "Done.")))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SHOW-FILE
				"Show a specified file."
  (NO-SEQUENCE-OK)
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Show file" (DEFAULT-PATHNAME))))
    (ZMAIL-SHOW-FILE PATHNAME))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SHOW-MAIL
				"Show any new mail."
				(NO-SEQUENCE-OK)
  (SHOW-MAIL-INTERNAL
    #'(LAMBDA (MF)
	(ZMAIL-SHOW-FILE MF "No new mail."
			 (FLAVOR:FUNCALL-HANDLER (OR (DEFAULT-MAIL-FILE-FORMAT MF)
						     (DEFAULT-DEFAULT-MAIL-FILE-FORMAT MF))
						 'MSG-FILE-ELEMENT-TYPE
						 :PATHNAME MF))))
  DIS-NONE)

;;; Equivalent command for Zmacs
(DEFCOM COM-SHOW-MAIL "Shows any new mail." ()
  (SHOW-MAIL-INTERNAL
    #'(LAMBDA (MF)
	(VIEW-FILE MF NIL (FLAVOR:FUNCALL-HANDLER (OR (DEFAULT-MAIL-FILE-FORMAT MF)
						      (DEFAULT-DEFAULT-MAIL-FILE-FORMAT MF))
						  'MSG-FILE-ELEMENT-TYPE
						  :PATHNAME MF))))
  DIS-NONE)

(SET-COMTAB *STANDARD-COMTAB* NIL (MAKE-COMMAND-ALIST '(COM-SHOW-MAIL)))

(DEFUN SHOW-MAIL-INTERNAL (FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (LET ((NEW-MF (LOOP FOR MF IN (POSSIBLE-DEFAULT-MAIL-FILE-PATHNAMES
				  (FS:USER-HOMEDIR (SECOND (ZMAIL-USER-MAIL-ADDRESS))))
		      THEREIS (DEFAULT-INBOX-PATHNAME MF))))
    (IF (AND NEW-MF (PROBEF NEW-MF))
	(FUNCALL FUNCTION NEW-MF)
      (TYPEIN-LINE "No new mail."))))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR ZMAIL-SHOW-FILE
						  (FS:PATHNAME "Show file" *ZMAIL-COMTAB*)
						  (FILE)
  `(ZMAIL-SHOW-FILE ,FILE))

(DEFUN ZMAIL-SHOW-FILE (PATHNAME &OPTIONAL (MESSAGE-IF-NOT-FOUND "No such file.")
					   (ELEMENT-TYPE :DEFAULT))
  (CONDITION-CASE (.ERROR.)
       (CONDITION-BIND ((SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
			  #'SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR-QUERY-HANDLER)
			(SI:ESCAPE-LOADING-STREAM-DECODING-ERROR
			  #'SI:ESCAPE-LOADING-STREAM-DECODING-ERROR-QUERY-HANDLER))
	 (SI:WITH-OPEN-CHARACTER-FILE (STREAM PATHNAME :PRESERVE-DATES T
						       :ELEMENT-TYPE ELEMENT-TYPE)
	   (WITH-OVERLYING-WINDOW (WINDOW)
	     (VIEW-STREAM STREAM WINDOW))))
     (FS:FILE-NOT-FOUND
       (BARF MESSAGE-IF-NOT-FOUND))
     (FS:FILE-OPERATION-FAILURE
       (BARF "~A" .ERROR.))
     (SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
       (ABORT-CURRENT-COMMAND)))
  NIL)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-EDIT-FILE
				"Edit a specified file using Zmacs."
				(NO-SEQUENCE-OK)
  (COM-ZMAIL-EDIT-FILE-INTERNAL))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR ZMAIL-EDIT-FILE
						  (FS:PATHNAME "Edit file using Zmacs"
							       *ZMAIL-COMTAB*
							       :GESTURE :EDIT-DEFINITION)
						  (FILE)
  `(COM-ZMAIL-EDIT-FILE-INTERNAL ,FILE))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR DRAFT-EDIT-FILE
						  (FS:PATHNAME "Edit file using Zmacs"
							       *REPLY-COMTAB*
							       :GESTURE :EDIT-DEFINITION)
						  (FILE)
  `(COM-ZMAIL-EDIT-FILE-INTERNAL ,FILE))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-MSG-EDIT-FILE
						  (FS:PATHNAME "Edit file using Zmacs"
							       *MSG-COMTAB*
							       :GESTURE :EDIT-DEFINITION)
						  (FILE)
  `(COM-ZMAIL-EDIT-FILE-INTERNAL ,FILE))

(DEFUN COM-ZMAIL-EDIT-FILE-INTERNAL (&OPTIONAL PATHNAME (EDITOR :DEFAULT))
  (UNLESS PATHNAME
    (SETQ PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Edit file" (DEFAULT-PATHNAME))))
  (STACK-LET ((FILES (LIST PATHNAME)))
    (WHEN (SETQ EDITOR (SI:EDIT-FILE-DEFAULT EDITOR FILES T))
      (FUNCALL (SI:FILE-EDITOR-FUNCTION EDITOR) (SI:FILE-FILE-SOURCE EDITOR FILES))))
  DIS-NONE)

(DEFINE-ZMAIL-GLOBAL *ZMAIL-KEYBOARD-MACROS* NIL)
(DEFINE-ZMAIL-GLOBAL *LAST-KEYBOARD-MACRO-ITEM* NIL)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER COM-ZMAIL-REPLAY-KEYBOARD-MACRO (STRING)
  (FORMAT STRING "Replay a keyboard macro:  ~@[L: ~A; ~]R: menu."
	  *LAST-KEYBOARD-MACRO-ITEM*))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-REPLAY-KEYBOARD-MACRO "Replay a keyboard macro.
Left defaults to last keyboard macro used.
Right gives menu of possibilities." (NO-SEQUENCE-OK)
  (OR (MEMQ ':MACRO-EXECUTE (SEND STANDARD-INPUT ':WHICH-OPERATIONS))
      (BARF "This stream doesnt support macros"))
  (LET (MACRO)
    (MULTIPLE-VALUE (MACRO *LAST-KEYBOARD-MACRO-ITEM*)
      (ZMAIL-MENU-CHOOSE NIL *ZMAIL-KEYBOARD-MACROS* *LAST-KEYBOARD-MACRO-ITEM*))
    (OR (AND MACRO
	     (SETQ MACRO (GET MACRO 'MACRO-STREAM-MACRO)))
	(BARF))
    (UPDATE-COMMAND-WHO-LINE-DOCUMENTATION 'COM-ZMAIL-REPLAY-KEYBOARD-MACRO)
    (SEND STANDARD-INPUT ':MACRO-EXECUTE MACRO 1)))

(DEFMACRO ADD-ZMAIL-KEYBOARD-MACROS NAMES
  `(SETQ *ZMAIL-KEYBOARD-MACROS*
	 (APPEND *ZMAIL-KEYBOARD-MACROS*
		 ',(MAPCAR #'(LAMBDA (X) (INTERN (GET-PNAME X) SI:PKG-KEYWORD-PACKAGE))
			   NAMES))))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-KILL-RING-SAVE-MSG
				"Save the current message on the kill ring.
An argument saves with the original headers."
				(NUMERIC-ARG-OK)
  (LET ((INTERVAL (IF *NUMERIC-ARG-P*
		      (LET ((INTERVAL (CREATE-INTERVAL)))
			(INSERT-TEXT-OF-MSG (INTERVAL-LAST-BP INTERVAL) *MSG* NIL)
			INTERVAL)
		      (MSG-INTERVAL *MSG*))))
    (KILL-RING-SAVE-INTERVAL INTERVAL))
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-KILL-RING-YANK-MSG
				"Pop the top of the kill ring into a message." (NO-MSG-OK)
  (LET* ((BUFFER (BUFFER-FOR-LOCAL-MAIL))
	 (INTERVAL (SEND *KILL-HISTORY* :YANK))
	 (MSG (MAKE-NEW-MSG-FROM-INTERVAL INTERVAL)))
    (SEND BUFFER :ADD-MSG MSG)
    (WHEN (AND *SEQUENCE*
	       (NEQ BUFFER *SEQUENCE*)
	       (NOT (SEQUENCE-BUFFER-P *SEQUENCE*)))
      (SEND *SEQUENCE* ':ADD-MSG MSG))
    (UPDATE-MSG-CHARACTER-TYPE-MAPPINGS MSG)
    (SEND *SUMMARY-WINDOW* ':NEED-FULL-REDISPLAY)
    (ZMAIL-SELECT-MSG MSG))) 

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-ENABLE-BACKGROUND-PROCESS-WHEN-DEEXPOSED
  "Allow the background process to run even though the Zmail frame is not exposed."
				(NO-SEQUENCE-OK)
  (SETQ *HANG-BACKGROUND-PROCESS-WHEN-DEEXPOSED* NIL)
  (TYPEIN-LINE "Background process enabled while Zmail frame is deexposed.")
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-DISABLE-BACKGROUND-PROCESS-WHEN-DEEXPOSED
  "Prevent the background process from running unless the Zmail frame is exposed."
				(NO-SEQUENCE-OK)
  (SETQ *HANG-BACKGROUND-PROCESS-WHEN-DEEXPOSED* T)
  (TYPEIN-LINE "Background process disabled while Zmail frame is deexposed.")
  DIS-NONE)

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-WHOIS
				"Print user-directory information on a given user."
				(NO-SEQUENCE-OK)
  (UNWIND-PROTECT
    (MULTIPLE-VALUE-BIND (NIL USER)
	(CHOOSE-OR-READLINE-ADDRESS :SENDER-OR-RECIPIENT "Whois" NIL T
				    (LET ((FROM (AND *MSG*
						     (FIRST (OR (MSG-GET *MSG* :FROM)
								(MSG-GET *MSG* :SENDER))))))
				      (AND FROM (STRING-FROM-HEADER FROM :SHORT))))
      (BARF-ON-ERRORS (SYS:NETWORK-ERROR)
	(CHAOS:WHOIS USER)))
    (WHEN (SEND *SUMMARY-WINDOW* :EXPOSED-P)
      (SEND *SUMMARY-WINDOW* :REDISPLAY-AS-NECESSARY)))
  DIS-NONE)

1;;; Provide the ability to invoke Zmacs to edit a function spec found in the
;;; current message while at Zmail top-level.
0(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR ZMAIL-EDIT-CODE-FRAGMENT
   (SYS:EXPRESSION
     "Edit definition" *ZMAIL-COMTAB*
     :GESTURE :EDIT-FUNCTION)
   (EXPRESSION &KEY PRESENTATION)
  (MULTIPLE-VALUE-BIND (FUNCTION-SPEC DEFINITION-TYPE)
      (EXPRESSION-TO-FUNCTION-SPEC EXPRESSION NIL T NIL PRESENTATION)
    (WHEN FUNCTION-SPEC
      `(ED (EDIT-DEFINITION ,FUNCTION-SPEC ,(AND DEFINITION-TYPE (LIST DEFINITION-TYPE)))))))

(DEFUN SOURCE-COMPARE-MSGS (MSG-1 MSG-2)
  (SRCCOM:SOURCE-COMPARE-FILES (MAKE-SOURCE-COMPARE-FILE-FROM-MSG MSG-1)
			       (MAKE-SOURCE-COMPARE-FILE-FROM-MSG MSG-2)))

(DEFUN MAKE-SOURCE-COMPARE-FILE-FROM-MSG (MSG)
  (SRCCOM:MAKE-SRCCOM-FILE
    :FILE-NAME (FORMAT NIL "in ~A" (SEND (MSG-BUFFER MSG) ':NAME))
    :FILE-TYPE (FORMAT NIL "msg #~D" (1+ (LOCATE-MSG-IN-SEQUENCE MSG *SEQUENCE*)))
    :FILE-STREAM (OPEN-INTERVAL-STREAM (MSG-INTERVAL MSG))
    :FILE-MAJOR-MODE ':TEXT
    :FILE-BP-TABLE (MAKE-ARRAY 100. :FILL-POINTER 0)))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ADD-FILE-REFERENCES "Add a File-References field" ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Add File-References" (PATHNAME-DEFAULTS)
					     :SPECIAL-TYPE :LISP)))
    (UNLESS (CL:FIND PATHNAME (MSG-GET *MSG* :FILE-REFERENCES) :TEST #'CL:EQUALP)
      (ADD-HEADER-TO-MSG *MSG*
			 :FILE-REFERENCES (CONS PATHNAME (MSG-GET *MSG* :FILE-REFERENCES))
			 :UNDO-SAVE "Add File-References"))
    DIS-TEXT))

(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ADD-MESSAGE-REFERENCES "Add references to the current message.
Prompts for a reference or references.  Terminate by pressing End.  
Normally, typing a message reference is too cumbersome, however, so you can
click mouse-Left on a message in the summary area to use its Message-ID immediately,
or you can click mouse-Middle on a message in the summary area to have its Message-ID
inserted into the minibuffer.  Using mouse-Middle is especially useful if you
mean to add several message references at once because you don't have to reissue
this command several times--you can just accumulate all of the references in the
minibuffer at once and then finally press End." ()
  (LET ((REFERENCES (TYPEIN-LINE-READ-REFERENCES "Add message references"))
	(USABLE-REFERENCES '())
	(CURRENT-REFERENCES (MSG-REFERENCES *MSG*)))
    (UNLESS REFERENCES (BARF "No references specified."))
    (DOLIST (REFERENCE REFERENCES)
      (UNLESS (CL:MEMBER REFERENCE CURRENT-REFERENCES :TEST #'REFERENCE-EQUAL)
	(PUSH REFERENCE USABLE-REFERENCES)))
    (COND ((NOT USABLE-REFERENCES)
	   (BARF "This message already has such ~:[a reference~;references~]."
		 (CDR REFERENCES)))
	  (T
	   (ADD-HEADER-TO-MSG *MSG*
			      :REFERENCES (APPEND (MSG-GET *MSG* :REFERENCES)
						  USABLE-REFERENCES)
			      :UNDO-SAVE "Add References")))
    DIS-TEXT))



(DEFUN TYPEIN-LINE-READ-REFERENCES (&OPTIONAL (PROMPT "Message references"))
  (*CATCH 'ZMAIL-REFERENCES-MSG-MOUSE-DWIM
    (LET ((REFERENCES-STRING
	    (WITH-ZMAIL-SUMMARY-WHO-LINE-DOCUMENTATION
	      "L: Use ID of this message.  M: Copy ID of this message into minibuffer."
	      (CONDITION-BIND ((UNKNOWN-SPECIAL-COMMAND #'ZMAIL-REFERENCES-MSG-MOUSE-DWIM))
		(LET ((*MINI-BUFFER-COMTAB* *MINI-BUFFER-MULTI-LINE-COMTAB*))
		  (ZWEI:TYPEIN-LINE-READLINE
		    "~A: (Type text terminated by End, or select message with mouse.)"
		    PROMPT))))))
      (FLET ((PARSE (STRING)
	       (LET ((RESULT (REMOVE NIL (PARSE-REFERENCE STRING))))
		 (WHEN (AND (NOT (EQUAL STRING "")) (NULL RESULT))
		   (ERROR "Unable to parse ~S as a message reference." STRING))
		 RESULT)))
	(BARF-ON-ERRORS (SYS:ERROR)
          (CL:REMOVE-DUPLICATES 
	    (APPLY #'APPEND
		   (MAPCAR #'PARSE
			   (PARSE-COMMA-SEPARATED REFERENCES-STRING 0 *COMMA-RETURN*)))
	    :TEST #'REFERENCE-EQUAL))))))

(DEFUN ZMAIL-REFERENCES-MSG-MOUSE-DWIM (CONDITION)
  ;; Copied with mods from ZMAIL-KEYWORDS-MSG-MOUSE-DWIM. -kmp 25-Nov-90
  (WHEN (EQ (SEND CONDITION ':COMMAND-TYPE) 'SUMMARY-MOUSE)
    (LET* ((MSG (CADAR (SEND CONDITION ':REST)))
	   (MSG-IDS (GENERATE-REFERENCE-HEADER (LIST MSG))))
      (CL:CASE (THIRD (SEND CONDITION :REST))
	(#\Mouse-L
	 (IF (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
	     ;; User has not typed anything yet.
	     (*THROW 'ZMAIL-REFERENCES-MSG-MOUSE-DWIM MSG-IDS)
	     ;; User has typed something.  Replace what he typed with the new stuff
	     ;; but fall through to code below to make him type Return or End to confirm.
	     ;; He can get back the stuff we killed by using c-Y.
	     (ZWEI:KILL-INTERVAL (INTERVAL-FIRST-BP *INTERVAL*)
				 (INTERVAL-LAST-BP *INTERVAL*)
				 T)))
	((#\Mouse-M #\c-Mouse-M))		;continue
	(OTHERWISE (BARF)))
      (LET* ((REFERENCES-PRESENT
	       (IGNORE-ERRORS
		 (REMOVE NIL
			 (APPLY #'APPEND
				(MAPCAR #'PARSE-REFERENCE
					(PARSE-COMMA-SEPARATED (STRING-INTERVAL *INTERVAL*)
							       0
							       *COMMA-RETURN*))))))
	     (REFERENCES (CL:SET-DIFFERENCE MSG-IDS REFERENCES-PRESENT
					    :TEST #'REFERENCE-EQUAL)))
	(IF (NOT REFERENCES)
	    (BEEP)
	  (MOVE-BP (POINT) (INTERVAL-LAST-BP *INTERVAL*))
	  (DELETE-AROUND '(#\Space #\Tab #\Return #\,) (POINT))
	  (UNLESS (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
	    (INSERT-MOVING (POINT) *COMMA-RETURN*))
	  (DO ((R REFERENCES (CDR R))) ((NULL R))
	    (INSERT-MOVING (POINT) (STRING-FOR-MSG-REFERENCE (CAR R)))
	    (WHEN (CDR R) (INSERT-MOVING (POINT) *COMMA-RETURN*)))
	  (MUST-REDISPLAY *WINDOW* DIS-TEXT))))
    (*THROW 'ZWEI-COMMAND-LOOP T)))


(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SHOW-MAILING-LIST
  "Show the expansion of a mailing list by contacting network servers.
With a numeric argument, expands to all levels." 
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (LET* ((DEFAULT (LOOP FOR TO IN (AND *MSG* (MSG-GET *MSG* :TO))
			THEREIS (AND TO (NOT (GET (LOCF TO) :INFERIORS)) TO)))
	 (ADDRESSES (TYPEIN-LINE-ACCEPT '((CL:SEQUENCE ADDRESS))
					:PROMPT "Show mailing list"
					:DEFAULT (AND DEFAULT (LIST DEFAULT)))))
    (SHOW-MAILING-LIST-INTERNAL ADDRESSES *NUMERIC-ARG-P*)))

;;; Synonym for 1Show Mailing List0 -- Named identically to the CP command.
(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-SHOW-EXPANDED-MAILING-LIST
 "Show the expansion of a mailing list by contacting network servers.
With a numeric argument, expands to all levels."
				(NO-SEQUENCE-OK NUMERIC-ARG-OK)
  (COM-ZMAIL-SHOW-MAILING-LIST))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR ZMAIL-SHOW-MAILING-LIST
			     (ADDRESS "Show Mailing List" *ZMAIL-COMTAB*
				      :GESTURE :SELECT)
			     (ADDRESS)
  `(SHOW-MAILING-LIST-INTERNAL (,ADDRESS) NIL))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR ZMAIL-SHOW-MAILING-LIST-ALL-LEVELS
			     (ADDRESS "Show Mailing List [All Levels]" *ZMAIL-COMTAB*)
			     (ADDRESS)
  `(SHOW-MAILING-LIST-INTERNAL (,ADDRESS) T))

(DEFCOM COM-SHOW-MAILING-LIST
  "Show the expansion of a mailing list by contacting network servers.
With a numeric argument, expands to all levels." ()
  (LET ((ADDRESSES (TYPEIN-LINE-ACCEPT '((CL:SEQUENCE ADDRESS))
				       :PROMPT "Show mailing list")))
    (SHOW-MAILING-LIST-INTERNAL ADDRESSES *NUMERIC-ARG-P*)))

(DEFCOM COM-SHOW-EXPANDED-MAILING-LIST
 "Show the expansion of a mailing list by contacting network servers.
With a numeric argument, expands to all levels." ()
  (COM-SHOW-MAILING-LIST))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDITOR-SHOW-MAILING-LIST
			     (ADDRESS "Show Mailing List" *STANDARD-COMTAB*
				      :GESTURE :SELECT
				      :TESTER ((&REST IGNORE)
					       (EDITOR-SHOW-MAILING-LIST-TESTER)))
			     (ADDRESS)
  `(SHOW-MAILING-LIST-INTERNAL (,ADDRESS) NIL))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDITOR-SHOW-MAILING-LIST-ALL-LEVELS
			     (ADDRESS "Show Mailing List [All Levels]" *STANDARD-COMTAB*
				      :TESTER ((&REST IGNORE)
					       (EDITOR-SHOW-MAILING-LIST-TESTER)))
			     (ADDRESS)
  `(SHOW-MAILING-LIST-INTERNAL (,ADDRESS) T)) 

(DEFUN EDITOR-SHOW-MAILING-LIST-TESTER ()
  (OR (NOT (VARIABLE-BOUNDP *MINI-BUFFER-COMMAND-IN-PROGRESS*))
      (NULL *MINI-BUFFER-COMMAND-IN-PROGRESS*)))

;;; ADDRESSES is a string or a list of parsed addresses
;;; MATCHING, if supplied, is a list of strings
(DEFUN SHOW-MAILING-LIST-INTERNAL (ADDRESSES EXPAND-ALL-LEVELS &OPTIONAL MATCHING)
  (WHEN (STRINGP ADDRESSES)
    (BARF-ON-ERRORS (PARSE-ERROR)
      (SETQ ADDRESSES (PARSE-ADDRESSES ADDRESSES))))
  (MAP-OVER-EXPANDED-ADDRESSES ADDRESSES
			       #'(LAMBDA (ADDRESS DEPTH)
				   (DECLARE (SYS:DOWNWARD-FUNCTION))
				   (IF (TYPEP ADDRESS 'ERROR)
				       (FORMAT T "~&~V@T~~A~" (* DEPTH 2) ADDRESS)
				     (SCL:INDENTING-OUTPUT (STANDARD-OUTPUT (* DEPTH 2))
				       (CL:FRESH-LINE)
				       (SCL:PRESENT ADDRESS 'ADDRESS))))
			       :EXPAND-ALL-LEVELS EXPAND-ALL-LEVELS
			       :MATCHING MATCHING
			       :SORT T)
  (CL:FRESH-LINE)
  DIS-NONE)

(DEFUN MAP-OVER-EXPANDED-ADDRESSES (ADDRESSES FUNCTION-OF-ADDRESS-AND-DEPTH
				    &KEY EXPAND-ALL-LEVELS MATCHING SORT INCLUDE-FILES)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION-OF-ADDRESS-AND-DEPTH))
  (LOOP FOR ADDRESSES ON ADDRESSES
	WHEN (NULL (CL:GETF (FIRST ADDRESSES) :HOST))
	  DO (SETF (CL:GETF (FIRST ADDRESSES) :HOST) `(:OBJECT
							,(SECOND (ZMAIL-USER-MAIL-ADDRESS)))))
  (LET (*MAILERS* *ALL-ADDRESSES*)
    (DECLARE (SPECIAL *MAILERS* *ALL-ADDRESSES*))
    (UNWIND-PROTECT-CASE (ABORTED)
	(MAP-OVER-EXPANDED-ADDRESSES-INTERNAL ADDRESSES FUNCTION-OF-ADDRESS-AND-DEPTH
					      EXPAND-ALL-LEVELS MATCHING SORT
					      0 NIL NIL INCLUDE-FILES)
      (:ALWAYS
	(LOOP FOR (NIL MAILER) IN *MAILERS*
	      DO (SEND MAILER :CLOSE ABORTED))))))

(DEFUN MAP-OVER-EXPANDED-ADDRESSES-INTERNAL (ADDRESSES FUNCTION-OF-ADDRESS-AND-DEPTH
					     EXPAND-ALL-LEVELS MATCHING SORT-P
					     DEPTH UNPROCESSED-SUPERIORS FROM-HOST
					     INCLUDE-FILES)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION-OF-ADDRESS-AND-DEPTH)
	   (SPECIAL *MAILERS* *ALL-ADDRESSES*))
  (WHEN FROM-HOST
    (LOOP FOR ADDRESSES ON ADDRESSES
	  UNLESS (TYPEP (FIRST ADDRESSES) 'ERROR)
	    WHEN (NULL (CL:GETF (FIRST ADDRESSES) :HOST))
	      DO (SETF (CL:GETF (FIRST ADDRESSES) :HOST) `(:OBJECT ,FROM-HOST))))
  (WHEN SORT-P
    (SETQ ADDRESSES (SORT ADDRESSES #'(LAMBDA (ADDRESS-1 ADDRESS-2)
					(COND ((TYPEP ADDRESS-1 'ERROR) T)
					      ((TYPEP ADDRESS-2 'ERROR) NIL)
					      (T (ADDRESS-LESSP ADDRESS-1 ADDRESS-2)))))))
  (DOLIST (ADDRESS ADDRESSES)
    (WHEN (AND INCLUDE-FILES (NOT (TYPEP ADDRESS 'ERROR)))
      (MULTIPLE-VALUE-BIND (USER HOST)
	  (DECOMPOSE-ADDRESS ADDRESS)
	(WHEN (AND HOST
		   (SELECTQ (SEND HOST :SYSTEM-TYPE)
		     (:LISPM
		      (STRING-SEARCH-CHAR #/> USER))
		     ((:TENEX :TOPS-20)
		      (WHEN (AND (PLUSP (STRING-LENGTH USER))
				 (CHAR-EQUAL (AREF USER 0) #/*))
			(SETQ USER (SUBSTRING USER 1))
			T))
		     ((:UNIX :UNIX42)
		      (STRING-SEARCH-CHAR #// USER))))
	  (NCONC ADDRESS
		 `(:FILE ,(FS:MERGE-PATHNAMES USER (FS:DEFAULT-PATHNAME NIL HOST)))))))
    (LET ((PROCESS-THIS (OR (TYPEP ADDRESS 'ERROR)
			    (NULL MATCHING)
			    (LOOP FOR KEY IN MATCHING
				  THEREIS (STRING-SEARCH KEY (STRING-FROM-HEADER ADDRESS
										 :SHORT))))))
      (WHEN PROCESS-THIS
	(LABELS ((PROCESS-UNPROCESSED-SUPERIORS (LIST DEPTH)
		   (WHEN (CDR LIST)
		     (PROCESS-UNPROCESSED-SUPERIORS (REST1 LIST) (- DEPTH 1)))
		   (FUNCALL FUNCTION-OF-ADDRESS-AND-DEPTH (FIRST LIST) DEPTH)))
	  (WHEN UNPROCESSED-SUPERIORS
	    (PROCESS-UNPROCESSED-SUPERIORS UNPROCESSED-SUPERIORS (- DEPTH 1))
	    (SETQ UNPROCESSED-SUPERIORS NIL)))
	(FUNCALL FUNCTION-OF-ADDRESS-AND-DEPTH ADDRESS DEPTH))
      (UNLESS (OR (AND (NOT EXPAND-ALL-LEVELS)	;If not showing all levels and got to a list,
		       (CDR ADDRESSES)		;stop and don't expand it too,
		       (NOT (ZEROP DEPTH)))	;but not on the first go round.
		  (TYPEP ADDRESS 'ERROR)
		  (LOOP FOR OTHER IN *ALL-ADDRESSES*
			THEREIS (LOOP FOR IND IN '(:NAME :HOST)
				      ALWAYS (EQUAL (GET (LOCF ADDRESS) IND)
						    (GET (LOCF OTHER) IND)))))
	(PUSH ADDRESS *ALL-ADDRESSES*)
	(MULTIPLE-VALUE-BIND (HOST HOST-STRING)
	    (ADDRESS-HOST-OBJECT ADDRESS)
	  (UNLESS (AND HOST (EQ HOST FROM-HOST))
	    (LET ((THIS-HOST HOST)
		  (MAILER (SECOND (ASSQ HOST *MAILERS*)))
		  (EXPANDED NIL))
	      (CONDITION-CASE (ERROR)
		   (BLOCK EXPAND-RECIPIENT
		     (WHEN (NULL MAILER)
		       (SETQ
			 MAILER
			 (IF (NULL HOST)
			     (IF (CL:GETF ADDRESS :HOST)
				 ;; Address includes a host -- We can't find its mailer.
				 (LET ((HOST (CL:REST (CL:GETF ADDRESS :HOST))))
				   (IF (NULL HOST-STRING)
				       ;; Proably an unresolved domain host...
				       (FORMAT
					 T "~&~VX/"~A~{.~A~}/" is not the name ~
					        of a known host.~%"
					 (+ (* DEPTH 2) 2) (FIRST HOST) (CL:REST HOST))
				       (FORMAT
					 T "~&~VX/"~A/" is not the name of a known host.~%"
					 (+ (* DEPTH 2) 2) HOST-STRING))
				   (RETURN-FROM EXPAND-RECIPIENT (VALUES)))
				 (LET* ((HOSTS
					  (LOOP FOR PATH IN (FIND-MAIL-SERVICES)
						COLLECT
						  (NETI:SERVICE-ACCESS-PATH-HOST PATH)))
					(PATHS
					  (LOOP FOR HOST IN HOSTS
						AS PATH
						   =
						   (CONDITION-BIND
						     ((NET:HOST-DOES-NOT-SUPPORT-SERVICE
							#'NETI:HOST-DOES-NOT-SUPPORT-PROTOCOL-SPECIFY-PATH-HANDLER))
						     (NETI:FIND-PATH-TO-SERVICE-ON-HOST
						       :EXPAND-MAIL-RECIPIENT HOST))
						WHEN PATH COLLECT PATH)))
				   (WHEN (NULL PATHS)
				     (BARF "No local mailer."))
				   (LOOP FOR PATHS ON PATHS
					 DOING
				     (SETQ THIS-HOST (NETI:SERVICE-ACCESS-PATH-HOST
						       (CAR PATHS)))
				     (CONDITION-CASE-IF (CDR PATHS) ()
					  (RETURN (NETI:INVOKE-SERVICE-ACCESS-PATH
						    (CAR PATHS) NIL))
					(SYS:NETWORK-ERROR)))))
			     (NETI:INVOKE-SERVICE-ACCESS-PATH-WITH-CACHED-UNAVAILABILITY
			       (CONDITION-BIND
				 ((NET:HOST-DOES-NOT-SUPPORT-SERVICE
				    #'NETI:HOST-DOES-NOT-SUPPORT-PROTOCOL-SPECIFY-PATH-HANDLER))
				 (NETI:FIND-PATH-TO-SERVICE-ON-HOST
				   :EXPAND-MAIL-RECIPIENT HOST))
			       (* 60. 5) NIL)))
		       (PUSH (LIST HOST MAILER) *MAILERS*))
		     (SETQ EXPANDED (SEND MAILER :EXPAND-RECIPIENT ADDRESS T)))
		 (MAILER:MAILER-ERROR
		   (FORMAT T "~&~VX~A~%" (+ (* DEPTH 2) 2) ERROR))
		 (SYS:NETWORK-ERROR
		   (WHEN MAILER
		     (SEND MAILER :CLOSE :ABORT)
		     (LET ((ELEM (LOOP FOR ELEM IN *MAILERS*
				       WHEN (EQ (SECOND ELEM) MAILER) RETURN ELEM)))
		       (SETQ *MAILERS* (DELQ ELEM *MAILERS*))))
		   (FORMAT T "~&~VX~A~%" (+ (* DEPTH 2) 2) ERROR)))
	      (WHEN EXPANDED
		(WITH-STACK-LIST* (MORE-SUPERIORS ADDRESS UNPROCESSED-SUPERIORS)
		  (MAP-OVER-EXPANDED-ADDRESSES-INTERNAL EXPANDED FUNCTION-OF-ADDRESS-AND-DEPTH
							EXPAND-ALL-LEVELS MATCHING SORT-P
							(+ DEPTH 1)
							(WHEN (NOT PROCESS-THIS)
							  MORE-SUPERIORS)
							THIS-HOST INCLUDE-FILES))))))))))


(DEFINE-ZMAIL-TOP-LEVEL-COMMAND COM-ZMAIL-EDIT-KEYWORDS-LIST
				"Edit the current global keywords list using a keywords menu.
Click on keywords in the menu to toggle their inclusion state
 (highlighted = to be kept).  Click on /"New/" to be prompted for new keywords to be added.
 /"Do it/" installs the new state from the menu, /"Abort/" leaves the list unchanged."
				(NO-MSG-OK)
 (LET ((RESULT *KEYWORD-ALIST*))
   (LET* ((*KEYWORD-ALIST* (COPYLIST *KEYWORD-ALIST*))
	  (OLD-LIST (LOOP FOR (NIL . KWD) IN *KEYWORD-ALIST* COLLECT KWD))
	  (NEW-LIST (CHOOSE-KEYWORDS "Edit Keyword List" OLD-LIST)))
     (UNLESS (EQ NEW-LIST OLD-LIST)		; i.e., menu choose was aborted
       (SETQ RESULT (LOOP FOR ENTRY IN *KEYWORD-ALIST*
			  AS (NIL . KWD) = ENTRY
			  WHEN (MEMQ KWD NEW-LIST)
			    COLLECT ENTRY))))
   (SETQ *KEYWORD-ALIST* RESULT))
 DIS-NONE)

(CP:DEFINE-COMMAND (SI:COM-SHOW-EXPANDED-MAILING-LIST
		     :NAME "Show Expanded Mailing List" :COMMAND-TABLE "Mailer")
    ((ADDRESSES '((CL:SEQUENCE ADDRESS)))
     &KEY
     (ALL-LEVELS 'SCL:BOOLEAN
		 :DEFAULT NIL
		 :MENTIONED-DEFAULT T
		 :DOCUMENTATION "Show all levels of the expansion recursively")
     (MATCHING '((CL:SEQUENCE STRING))
	       :DOCUMENTATION "Show only addresses matching the given string"))
   (MAP-OVER-EXPANDED-ADDRESSES ADDRESSES
				#'(LAMBDA (ADDRESS DEPTH)
				    (DECLARE (SYS:DOWNWARD-FUNCTION))
				    (IF (TYPEP ADDRESS 'ERROR)
					(FORMAT T "~&~V@T~~A~" (* DEPTH 2) ADDRESS)
					(SCL:INDENTING-OUTPUT (T (* DEPTH 2))
					  (CL:FRESH-LINE)
					  (SCL:PRESENT ADDRESS 'ADDRESS))))
				:EXPAND-ALL-LEVELS ALL-LEVELS
				:MATCHING MATCHING
				:SORT T))

(SCL:DEFINE-PRESENTATION-TO-COMMAND-TRANSLATOR COM-SHOW-EXPANDED-MAILING-LIST
   (ADDRESS) (ADDRESS)
  `(SI:COM-SHOW-EXPANDED-MAILING-LIST (,ADDRESS)))

(SCL:DEFINE-PRESENTATION-TO-COMMAND-TRANSLATOR COM-SHOW-EXPANDED-MAILING-LIST-ALL-LEVELS
   (ADDRESS :GESTURE NIL) (ADDRESS)
  `(SI:COM-SHOW-EXPANDED-MAILING-LIST (,ADDRESS) :ALL-LEVELS T))

(SCL:DEFINE-PRESENTATION-TRANSLATOR ADDRESS-TO-FILE (ADDRESS FS:PATHNAME) (ADDRESS)
   (CL:GETF ADDRESS :FILE))

(SCL:DEFINE-PRESENTATION-TRANSLATOR USER-AT-HOST-OR-SITE-TO-ADDRESS
				(CP::USER-AT-HOST-OR-SITE ADDRESS) (USER-AT-HOST)
  (LET ((USER (CL:GETF USER-AT-HOST :USER))
	(HOST (CL:GETF USER-AT-HOST :HOST)))
    (WHEN (AND USER HOST)
      `(:NAME ,USER :HOST (:OBJECT ,HOST)))))

(SCL:DEFINE-PRESENTATION-TRANSLATOR ADDRESS-TO-USER-AT-HOST-OR-SITE
   (ADDRESS CP::USER-AT-HOST-OR-SITE) (ADDRESS)
  (MULTIPLE-VALUE-BIND (USER HOST)
      (DECOMPOSE-ADDRESS ADDRESS)
    (WHEN (AND USER HOST)
      `(:USER ,USER :HOST ,HOST))))

(CP:DEFINE-COMMAND (SI:COM-SHOW-MAIL :NAME "Show Mail" :COMMAND-TABLE "Mail Reading//Sending")
    ((MAILBOXES '((CL:SEQUENCE FS:PATHNAME))
		:DOCUMENTATION "mailbox file(s) to view"
		:DEFAULT (LIST
			   (LOOP FOR MF IN (POSSIBLE-DEFAULT-MAIL-FILE-PATHNAMES
					     (FS:USER-HOMEDIR
					       (SECOND (SEND SI:*USER* :MAIL-ADDRESS))))
				 THEREIS (DEFAULT-INBOX-PATHNAME MF)))
		:PROMPT "mailbox files"))
   (LET ((FOUND-P NIL))
     (DOLIST (MF MAILBOXES)
       (WHEN (PROBEF MF)
	 (VIEWF MF STANDARD-OUTPUT
		(FLAVOR:FUNCALL-HANDLER (OR (DEFAULT-MAIL-FILE-FORMAT MF)
					    (DEFAULT-DEFAULT-MAIL-FILE-FORMAT MF))
					'MSG-FILE-ELEMENT-TYPE
					:PATHNAME MF))
	 (SETQ FOUND-P T)))
     (UNLESS FOUND-P
       (FORMAT T "No new mail."))))

(CP:DEFINE-COMMAND (SI:COM-INITIALIZE-MAIL :COMMAND-TABLE "Mail Reading//Sending"
					:PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    ()
   (LET ()
     (DECLARE (SPECIAL *ZMAIL-WINDOW*))
     (IF (AND (VARIABLE-BOUNDP *ZMAIL-WINDOW*)
	      (LOOP FOR W FIRST TV:SELECTED-WINDOW THEN (SEND W :SUPERIOR)
		    WHILE W
		    THEREIS (EQ W *ZMAIL-WINDOW*)))
	 (PROGN
	   (BEEP)
	   (FORMAT T "~2&~2TYou cannot initialize Zmail from an inferior of the Zmail frame!~@
                   ~3TDo it from a top-level Lisp Listener."))
	 (WHEN (YES-OR-NO-P
		 (FORMAT NIL
			 "WARNING: This command will completely initialize the state of the Zmail~% ~
                   process on your machine.  All existing buffers and customizations of~% ~
                   the Zmail environment will be lost.  Are you sure you want to do that? "))
	   (FORMAT T "~%")
	   (LET ((SAVE-OK T)
		 (SAVE-LIST
		   (WHEN (VARIABLE-BOUNDP *ZMAIL-WINDOW*)
		     (LOOP FOR SEQUENCE
			       IN (SYMEVAL-IN-INSTANCE *ZMAIL-WINDOW* '*SEQUENCE-LIST*)
			   WHEN (CONDITION-CASE (ERROR)
				     (AND (SEQUENCE-BUFFER-P SEQUENCE)
					  (MAIL-FILE-SAVE-P SEQUENCE))
				   (ERROR (FORMAT T "~& Buffer ~A is in abnormal condition; ~@
  it can't be tested for need to save: ~~A~" (SEND SEQUENCE :NAME) ERROR)
					  NIL))
			     COLLECT SEQUENCE))))
	     (WHEN SAVE-LIST
	       (LET ((SAVE-BUFFERS (FQUERY
				     '(:CHOICES (((:NOSELECTIVE "Yes.")
						  #/Y #\SP #/T)
						 ((NIL "No.") #/N #\RUBOUT)
						 ((:SELECTIVE "Selectively.") #/S)))
				     "~&  There are some mail files that need saving; save them? ")))
		 (WHEN SAVE-BUFFERS
		   (FORMAT T "~2&")
		   (CONDITION-CASE (ERROR)
			(ZMAIL-SAVE-ALL-FILES (EQ SAVE-BUFFERS :SELECTIVE) NIL SAVE-LIST)
		      (ERROR (FORMAT T "~& Unable to complete saving of buffers.~%~4T~~A~" ERROR)
			     (SETQ SAVE-OK
				   (YES-OR-NO-P "Complete initializing of mail anyway?")))))))
	     (WHEN SAVE-OK
	       (INITIALIZE-ZMAIL)))))))

(CP:DEFINE-COMMAND (SI:COM-SAVE-MAIL-BUFFERS :COMMAND-TABLE "Mail Reading//Sending"
					  :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    (&KEY (QUERY 'SCL:BOOLEAN
		 :DEFAULT T
		 :DOCUMENTATION "Ask whether to save each mail file buffer")
	  (EXPUNGE 'SCL:BOOLEAN
		   :DEFAULT T
		   :DOCUMENTATION "Whether to expunge each mail file buffer before saving"))
   (UNLESS (SAVE-MAIL-BUFFERS QUERY EXPUNGE)
     (FORMAT T "~&Zmail isn't available at this time.")))

(DEFUN SAVE-MAIL-BUFFERS (ASK? EXPUNGE?)
  (SAVE-MAIL-BUFFERS-EXECUTE (SAVE-MAIL-BUFFERS-QUERY ASK? EXPUNGE?) EXPUNGE?))

(DEFUN SAVE-MAIL-BUFFERS-QUERY (ASK? EXPUNGE?)
  (WHEN *ZMAIL-SAVE-IN-PROGRESS*
    (FORMAT T "~& Waiting for mail file buffer save to complete ...")
    (PROCESS-WAIT "Mail save wait"
      #'(LAMBDA () (NULL *ZMAIL-SAVE-IN-PROGRESS*)))
    (FORMAT T " done."))
  ;; Don't bother trying if Zmail isn't loaded or isn't initialized ...
  (WHEN (AND (VARIABLE-BOUNDP *ZMAIL-WINDOW*)
	     *ZMAIL-WINDOW*)
    (ZMAIL-SAVE-ALL-FILES-QUERY ASK? EXPUNGE?)))

(DEFUN SAVE-MAIL-BUFFERS-EXECUTE (BUFFERS-TO-SAVE EXPUNGE?)
  (WHEN BUFFERS-TO-SAVE
    (ZMAIL-SAVE-ALL-FILES-EXECUTE BUFFERS-TO-SAVE EXPUNGE?)
    T))

(si:define-application-logout-initialization save-mail-buffers-logout-initialization
 ((save-mail '((cl:member :yes :no :ask))
	    :default :ask
	    :documentation "Save modified mail buffers before logging out")
  (expunge-mail 'scl:boolean :Default t :documentation "Expunge mail buffers"))
  (unless (eq save-mail :no)
    (zwei:save-mail-buffers-execute
      (si:application-logout-separate-querying
	(zwei:save-mail-buffers-query (eq save-mail :ask) expunge-mail))
      expunge-mail)))


;;; KMP's Show Zmail Status facility for inquiring about Zmail's status from remote terminals.

(CP:DEFINE-COMMAND (COM-SHOW-ZMAIL-STATUS :COMMAND-TABLE "Mail Reading//Sending") ()
  (FIND-AND-SHOW-ZMAIL-STATUS))

(DEFUN FIND-AND-SHOW-ZMAIL-STATUS (&KEY IF-DOES-NOT-EXIST)
  "Types out useful information about the current state of Zmail."
  (LABELS ((FIND-ZMAIL-WINDOW ()
	     (IF (BOUNDP 'ZWEI:*ZMAIL-WINDOW*) ZWEI:*ZMAIL-WINDOW*))
	   (ZMAIL-SEQUENCE (PROCESS)
	     (LET ((STACK-GROUP (SEND PROCESS :STACK-GROUP)))
	       (WHEN STACK-GROUP
		 (VALUES (SYMEVAL-IN-STACK-GROUP '*ZMAIL-SEQUENCE-NAME* STACK-GROUP))))))
    (LET ((ZMAIL-WINDOW (FIND-ZMAIL-WINDOW)))
      (COND ((NOT ZMAIL-WINDOW)
	     (WHEN (EQ IF-DOES-NOT-EXIST NIL) (RETURN-FROM FIND-AND-SHOW-ZMAIL-STATUS NIL))
	     (FORMAT T "~&No Zmail window found.~%"))
	    (T
	     (LET ((ZMAIL-PROCESS (SEND ZMAIL-WINDOW :PROCESS)))
	       (LET ((SEQ (ZMAIL-SEQUENCE ZMAIL-PROCESS)))
		 (COND ((SEND ZMAIL-PROCESS :ARREST-REASONS)
			(FORMAT T "~&~A has been arrested.~%" ZMAIL-WINDOW))
		       ((NOT (SEND ZMAIL-PROCESS :RUN-REASONS))
			(FORMAT T "~&~A has no run reasons.~%" ZMAIL-WINDOW))
		       (T
			(FORMAT T "~&~A is in state ~A~:[ (in ~A)~;~].~%"
				ZMAIL-WINDOW
				(SEND ZMAIL-PROCESS :WHOSTATE)
				(AND SEQ (STRING-EQUAL SEQ "No current message sequence"))
				SEQ))))
	       (SI:SHOW-OPEN-FILES #'(LAMBDA (STREAM)
				       (LET ((PATH (SEND STREAM :PATHNAME)))
					 (OR (STRING-EQUAL (SEND PATH :NAME) "MAIL")
					     (STRING-EQUAL (SEND PATH :TYPE) "BABYL")
					     (STRING-EQUAL (SEND PATH :TYPE) "XMAIL"))))))))
      ZMAIL-WINDOW)))


;;; KMP's Scan Mail facility for reading mail from remote terminals.

(CP:DEFINE-COMMAND (COM-SCAN-MAIL :COMMAND-TABLE "Mail Reading//Sending")
		   ((MAILBOX 'CL:PATHNAME
			     :DOCUMENTATION "Mailbox file to scan."
			     :DEFAULT (SCAN-MAIL-DEFAULT-MAIL-FILE-NAME)
			     :PROMPT "mailbox file"))
   (LET ((PATH (PROBEF MAILBOX)))
     (COND ((NOT PATH) (FORMAT T "~&No mail in ~A." MAILBOX))
	   (T (COND ((SCAN-MAIL-LOOP PATH)
		     (FORMAT T "~&Finished ~A." PATH)
		     (WHEN (NOT (TYPEP TERMINAL-IO 'TV:SHEET))	;Remote terminal
		       (IF (EQ (SEND MAILBOX :GENERIC-PATHNAME)
			       (SEND (SCAN-MAIL-DEFAULT-MAIL-FILE-NAME) :GENERIC-PATHNAME))
			   (MAYBE-GET-INBOX-FOR-SCAN-MAIL))))
		    (T
		     (FORMAT T "~&Aborted ~A." PATH)))))))

;;; This determines whether or not blank lines are displayed during Scan Mail.
;;; Possible values are:
;;;  NIL		Never display blank lines.
;;;  T			Always display blank lines.
;;;  :REMOTE-TERMINAL	Only display blank lines when using a remote terminal.
;;;  :LOCAL-TERMINAL	Only display blank lines when using a console.
(DEFVAR *SCAN-MAIL-SHOW-BLANK-LINES* NIL)

;;; This determines which headers will be displayed by Scan Mail before
;;; querying about whether to display the rest of the message.  The
;;; headers are compared using string-equal, starting at the beginning
;;; of a line.
(DEFVAR *SCAN-MAIL-HEADERS-TO-SHOW* '("Date:"
				      "From:"
				      "To:"
				      "Cc:"
				      "Subject:"
				      "File-References:"
				      "Comments:"
				      "Resent-From:"
				      "Resent-To:"
				      "Resent-Date:"
				      "Bcc:"
				      "Resent-Comments:"))

(DEFUN SCAN-MAIL-LOOP (PATH)
  "Internal loop used by SCAN-MAIL."
  (BLOCK READ-MAIL
    (WITH-OPEN-FILE (MAIL-STREAM PATH
				 :DIRECTION :INPUT
				 :ELEMENT-TYPE (FLAVOR:FUNCALL-HANDLER
						 (OR (DEFAULT-MAIL-FILE-FORMAT PATH)
						     (DEFAULT-DEFAULT-MAIL-FILE-FORMAT PATH))
						 'MSG-FILE-ELEMENT-TYPE
						 :PATHNAME PATH))
      (LET ((N 0) (LEN (SEND MAIL-STREAM :LENGTH)))
	(FLET ((CLEAR ()
		 (LET ((P (SEND MAIL-STREAM :READ-POINTER)))
		   (FORMAT T "~:|")
		   (UNLESS (= P LEN)
		     (FORMAT T "Message #~D (~D%)~%"
			     (INCF N) (FLOOR (* P 100.) LEN))))))
	  (CLEAR)
	  (DO ((LINE (READLINE MAIL-STREAM NIL) (READLINE MAIL-STREAM NIL))
	       (MSG-ID NIL) (HEADER T) (OFF NIL))
	      ((NULL LINE) T)
	    (CONDITION-CASE ()
		(COND (HEADER
		       (COND ((STRING-EQUAL LINE "")
			      (SETQ HEADER NIL)
			      (DO () (NIL)	;Don't let --More-- get in the way.
				(CONDITION-CASE ()
				    (SELECTQ (FQUERY '(:CHOICES
							(((:MORE  "Yes"  ) #/Y #/y #\Space )
							 ((:FLUSH "No"   ) #/N #/n #\Rubout)
							 ((:REPLY "Reply") #/R #/r         )
							 ((:EXIT  "Exit" ) #/X #/x #\End
							  #\Escape)))
						     ">>>Show rest of message? ")
				      (:MORE  (SETQ OFF NIL) (RETURN T))
				      (:FLUSH (SETQ OFF T)   (RETURN T))
				      (:REPLY (REPLY-TO-SCAN-MAIL-MSG MSG-ID))
				      (:EXIT  (RETURN-FROM READ-MAIL NIL)))
				  (SYS:ABORT NIL))))
			     ((LOOP FOR HEADER IN *SCAN-MAIL-HEADERS-TO-SHOW*
				    AS HLEN = (STRING-LENGTH HEADER)
				    THEREIS (STRING-EQUAL LINE HEADER 0 0 HLEN HLEN))
			      (SETQ OFF NIL)
			      (FORMAT T "~&~A" LINE))
			     ((STRING-EQUAL LINE "Message-Id:" 0. 0. 11. 11.)
			      (SETQ OFF T)
			      (SETQ MSG-ID (STRING-TRIM '(#\Tab #\Space)
							(SUBSTRING LINE 11.))))
			     ((AND (NOT OFF) (MEMQ (AREF LINE 0) '(#\Space #\Tab)))
			      ;; The OFF variable notes whether the most recent non-indented 
			      ;; header was shown, so we know whether to show continuation
			      ;; lines. -kmp 14-Sep-89
			      (FORMAT T "~&~A" LINE))
			     (T
			      (SETQ OFF T))))
		      ((OR (STRING-EQUAL LINE "")
			   (STRING-EQUAL LINE "")
			   (STRING-SEARCH ";00" LINE)
			   (STRING-SEARCH ";01" LINE)
			   (STRING-SEARCH ";10" LINE)
			   (STRING-SEARCH ";11" LINE))
		       (UNLESS OFF
			 (CONDITION-CASE ()
			     (SELECTQ (FQUERY '(:CHOICES
						 (((:REPLY "Yes"  ) #/Y #/y #\Space #/R #/r)
						  ((:NO-OP "No"   ) #/N #/n #\Rubout)
						  ((:EXIT  "Exit" ) #/X #/x #\End #\Escape)))
					      ">>>Reply? ")
			       (:REPLY (REPLY-TO-SCAN-MAIL-MSG MSG-ID))
			       (:EXIT  (RETURN-FROM READ-MAIL NIL))
			       (:NO-OP NIL))
			   (SYS:ABORT NIL)))
		       (CLEAR)
		       (SETQ OFF NIL MSG-ID NIL HEADER T))
		      ((NOT OFF)
		       (IF (IF (SYS:REMOTE-TERMINAL-P)
			       (MEMBER *SCAN-MAIL-SHOW-BLANK-LINES* '(T :REMOTE-TERMINAL))
			       (MEMBER *SCAN-MAIL-SHOW-BLANK-LINES* '(T :LOCAL-TERMINAL)))
			   (TERPRI)
			   (CL:FRESH-LINE))
		       (CL:WRITE-STRING LINE)))
	      (SYS:ABORT (SETQ OFF T)))))))))

(DEFUN SCAN-MAIL-DEFAULT-MAIL-FILE-NAME ()
  "Returns the name of the default mail file to be used by SCAN-MAIL"
  (DECLARE (VALUES PATHNAME))
  (DOLIST (MF (POSSIBLE-DEFAULT-MAIL-FILE-PATHNAMES
		(FS:USER-HOMEDIR
		  (SECOND (SEND SI:*USER* :MAIL-ADDRESS)))))
    (LET ((PATH (DEFAULT-INBOX-PATHNAME MF)))
      (IF PATH (RETURN PATH)))))

(DEFUN MAYBE-GET-INBOX-FOR-SCAN-MAIL ()
  "Offers to simulate a [Get Inbox] if it seems appropriate."
  (LET ((ZMAIL-WINDOW (FIND-AND-SHOW-ZMAIL-STATUS :IF-DOES-NOT-EXIST NIL)))
    (WHEN (AND ZMAIL-WINDOW
	       ;; Maybe this query should come only if viewing a sequence which has an inbox
	       ;;  which is the mail being viewed...?
	       (YES-OR-NO-P "Ask it to Get Inbox? "))
      (LET ((ZMAIL-PROCESS (SEND ZMAIL-WINDOW :PROCESS))) 
	(UNLESS (SEND ZMAIL-PROCESS :RUN-REASONS)
	  (SEND ZMAIL-PROCESS :RUN-REASON))
	(SEND ZMAIL-WINDOW :FORCE-KBD-INPUT #/G)))))

(DEFUN REPLY-TO-SCAN-MAIL-MSG (&OPTIONAL MSG-ID DEFAULT-TO DEFAULT-CC DEFAULT-SUBJ)
  (WITH-INPUT-EDITING-OPTIONS ((:NO-INPUT-SAVE T))
    (LET (TO CC SUBJ TEXT)
      (WHEN (OR (SETQ TO (PROMPT-AND-READ :STRING-OR-NIL "To: "))
		DEFAULT-TO
		(SETQ TO (PROMPT-AND-READ :STRING-OR-NIL "To (Another Return will abort): ")))
	(SETQ CC   (OR (PROMPT-AND-READ :STRING-OR-NIL "Cc: ") DEFAULT-CC))
	(SETQ SUBJ (OR (PROMPT-AND-READ :STRING-OR-NIL "Subject: ") DEFAULT-SUBJ))
	(SETQ TEXT (PROMPT-AND-READ :DELIMITED-STRING "Msg:~%"))
	(LEXPR-FUNCALL #'SEND-MESSAGE-STRING TO TEXT
		       :REPORT-STREAM STANDARD-OUTPUT
		       (APPEND (IF CC     `(:CC ,CC))
			       (IF SUBJ   `(:SUBJECT ,SUBJ))
			       (IF MSG-ID `(:IN-REPLY-TO ,MSG-ID))))
	(PROCESS-SLEEP 150. "Allow Time to Read Msg")))))

