;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-
;;; RFC733 address parser
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; The address grammar --
;;;    An interval is parsed into a list of addresses.  Each address is a property list.
;;;
;;;    The indicators are:
;;;       (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB"):name1 (string) - the mailbox at the particular site.
;;;	  2:host1 ((type object)) - path to the site.
;;;	  2:user1 (user object) - a network system user object as a mailbox.
;;;	  2:personal-name1 (string) - a string that might possibly be the user's real name.
;;;	  2:original-string1 (string) - the parsed area as a string
;;;	  2:interval1 (`((,start-string ,start-index) (,end-string ,end-index))) - the parsed
;;;	     area as a0 Zwei1 interval.  This form is only used by message composition
;;;	     and transmission.  Normally, 2:original-string1 is used.
;;;       2:distribution-list1 (string) - for 0Foo: mumble ;
1;;;	  2:bracketed-list1 (string) - for 0Foo <mumble, frotz>1 with more than 1 address
;;;	  2:inferiors1 (addresses) - for bracketing type headers like above
;;;	  2:initial-string1 (string) - the parsed area preceeding an address in a distribution
;;;	     or bracketed list.
;;;       2:final-string1 (string) - the parsed area following the final address in
;;;          a distribution or bracketed list.
;;;	  2:postal1 (string) - for 0:Postal:
1;;;	  2:include1 (string) - likewise for 0:Include:

(DEFINE-PARSE-GRAMMAR ADDRESSES
  (:LEXER RFC733-LEXER)
  (:LEXEMES LEFT-BRACKET RIGHT-BRACKET ATSIGN COMMA SEMI COLON QUOTED-STRING COMMENT
	    CLOSE AT-ATOM ATOM PERIOD)
  (:PRECEDENCES (ATSIGN COLON QUOTED-STRING) ATOM WORD NOWORD PHRASE)
  (:IGNORED COMMENT)
  (:RIGHT-ASSOCIATIVE ATSIGN AT-ATOM)
  )

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESSES ADDRESSES)
			      NIL FALSE)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESSES ADDRESSES)
			      (ADDRESS) IDENTITY)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESSES ADDRESSES)
			      (ADDRESS COMMA ADDRESSES) ADDRESS-COMMA-ADDRESS)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESS ADDRESSES)
			      (HOST-PHRASE) LIST)

;;; Recognize comments for FOO at MIT-AI (Fred Foobar) specially
(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESS ADDRESSES)
			      (HOST-PHRASE COMMENT) HOST-PHRASE-WITH-COMMENT)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESS ADDRESSES)
			      (PHRASES LEFT-BRACKET ADDRESSES RIGHT-BRACKET)
			      ADDRESSES-IN-BRACKETS)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESS ADDRESSES)
			      (PHRASES LEFT-BRACKET ATSIGN ROUTE COLON ADDRESSES
			       RIGHT-BRACKET)
			      ADDRESSES-IN-BRACKETS-WITH-ROUTE)

(ADD-PARSE-GRAMMAR-PRODUCTION (ROUTE ADDRESSES) (ROUTE-ELEMENT) NCONS)

(ADD-PARSE-GRAMMAR-PRODUCTION (ROUTE-ELEMENT ADDRESSES) (DOMAIN-HOST-INDICATOR)
			      ROUTE-ELEMENT-WITH-DOMAINS)

(ADD-PARSE-GRAMMAR-PRODUCTION (ROUTE ADDRESSES) (ROUTE-ELEMENT COMMA ATSIGN ROUTE)
			      APPEND-ROUTING-PATHS)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESS ADDRESSES)
			      (PHRASES COLON ADDRESSES SEMI)
			      ADDRESS-DISTRIBUTION-LIST)

(ADD-PARSE-GRAMMAR-PRODUCTION (ADDRESS ADDRESSES)
			      (COLON ATOM COLON ADDRESS)
			      COLON-ATOM-COLON-ADDRESS)

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASES ADDRESSES)
			      NIL FALSE
  (:PRECEDENCE NOWORD))

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASES ADDRESSES)
			      (PHRASE PHRASES) APPEND-PHRASES)

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASE ADDRESSES)
			      (WORD) IDENTITY
  (:PRECEDENCE WORD))

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASE ADDRESSES)
			      (WORD PHRASE)
			      APPEND-PHRASES
  (:PRECEDENCE WORD))

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASE ADDRESSES)
			      (WORD PERIOD PHRASE)
			      WORD-PERIOD-WORD
  (:PRECEDENCE WORD))

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASE ADDRESSES)
			      (WORD PERIOD)
			      WORD-PERIOD
  (:PRECEDENCE WORD))

(ADD-PARSE-GRAMMAR-PRODUCTION (WORD ADDRESSES)
			      (ATOM) CDR)

(ADD-PARSE-GRAMMAR-PRODUCTION (WORD ADDRESSES)
			      (AT-ATOM) CDR
  (:PRECEDENCE ATOM))

(ADD-PARSE-GRAMMAR-PRODUCTION (WORD ADDRESSES)
			      (QUOTED-STRING)
			      CDR)

(ADD-PARSE-GRAMMAR-PRODUCTION (HOST-PHRASE ADDRESSES)
			      (PHRASE-FOR-HOST HOST-INDICATOR)
			      ADDRESS-HOST-PHRASE)

(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASE-FOR-HOST ADDRESSES)
			      (PHRASE) IDENTITY
  (:PRECEDENCE PHRASE))

;;; This is not legal 733, it makes "(BUG ZWEI) at MIT-AI" work.
(ADD-PARSE-GRAMMAR-PRODUCTION (PHRASE-FOR-HOST ADDRESSES)
			      (COMMENT) COMMENT-PHRASE-FOR-HOST)

;;; This is not legal 733, but every tenex site in the world sends addresses without hosts.
(ADD-PARSE-GRAMMAR-PRODUCTION (HOST-INDICATOR ADDRESSES)
			      NIL FALSE)

(ADD-PARSE-GRAMMAR-PRODUCTION (HOST-INDICATOR ADDRESSES)
			      (PATH-DOMAIN-INDICATOR)
			      ADDRESS-PATH-DOMAIN-INDICATOR)

(ADD-PARSE-GRAMMAR-PRODUCTION (PATH-DOMAIN-INDICATOR ADDRESSES)
			      (AT-DOMAIN)
			      ADDRESS-PATH-LAST-DOMAIN)

(ADD-PARSE-GRAMMAR-PRODUCTION (PATH-DOMAIN-INDICATOR ADDRESSES)
			      (AT-DOMAIN PATH-DOMAIN-INDICATOR)
			      ADDRESS-PATH-MORE-DOMAINS)

(ADD-PARSE-GRAMMAR-PRODUCTION (AT-DOMAIN ADDRESSES)
			      (AT DOMAIN-HOST-INDICATOR)
			      ADDRESS-AT-DOMAIN)

(ADD-PARSE-GRAMMAR-PRODUCTION (DOMAIN-HOST-INDICATOR ADDRESSES)
			      (SUB-DOMAIN)
			      ADDRESS-LAST-SUBDOMAIN)

(ADD-PARSE-GRAMMAR-PRODUCTION (DOMAIN-HOST-INDICATOR ADDRESSES)
			      (SUB-DOMAIN PERIOD DOMAIN-HOST-INDICATOR)
			      ADDRESS-MORE-SUBDOMAINS)

(ADD-PARSE-GRAMMAR-PRODUCTION (SUB-DOMAIN ADDRESSES)
			      (ATOM) IDENTITY)

(ADD-PARSE-GRAMMAR-PRODUCTION (SUB-DOMAIN ADDRESSES)
			      (AT-ATOM) IDENTITY)

(ADD-PARSE-GRAMMAR-PRODUCTION (AT ADDRESSES)
			      (ATSIGN) IDENTITY)

(ADD-PARSE-GRAMMAR-PRODUCTION (AT ADDRESSES)
			      (AT-ATOM) IDENTITY
  (:PRECEDENCE ATSIGN))

(BUILD-PARSE-GRAMMAR ADDRESSES)



1;;; Action routines --
;;;    These functions aren't #'(lambda (...) ...)'s because that wouldn't get compiled at
;;;    top level like this.

0(DEFUN ADDRESS-COMMA-ADDRESS (ADDRESS IGNORE ADDRESSES)
  (NCONC ADDRESS ADDRESSES))

(DEFUN HOST-PHRASE-WITH-COMMENT (HOST-PHRASE COMMENT)
  (LET ((PLIST (LOCF HOST-PHRASE)))
    (LET ((STRING (SECOND COMMENT)))
      (PUTPROP PLIST (SUBSTRING STRING 1 (1- (STRING-LENGTH STRING))) :PERSONAL-NAME))
    ;; Include comment in original string / interval
    (IF *PRESERVE-ADDRESS-INTERVALS*
	(SETF (SECOND (GET PLIST :INTERVAL)) (FOURTH COMMENT))
      (LET* ((ADDRESS-ORIGINAL-STRING (GET PLIST :ORIGINAL-STRING))
	     (ADDRESS-START-BP (SEARCH (THIRD COMMENT) ADDRESS-ORIGINAL-STRING T T))
	     (ADDRESS-END-BP (FORWARD-CHAR ADDRESS-START-BP
					   (STRING-LENGTH ADDRESS-ORIGINAL-STRING) T)))
	(SETF (GET PLIST :ORIGINAL-STRING)
	      (STRING-APPEND (GET PLIST :ORIGINAL-STRING)
			     (STRING-INTERVAL ADDRESS-END-BP (FOURTH COMMENT) T))))))
  (LIST HOST-PHRASE))

(DEFUN ADDRESSES-IN-BRACKETS (PHRASES LEFT-BRACKET ADDRESSES RIGHT-BRACKET)
  (IBP (THIRD RIGHT-BRACKET) T)
  (IF PHRASES
      (IF (= (LENGTH ADDRESSES) 1)
	  ;; For just one address, treat as Fred Foobar <FOO at MIT-AI>
	  (LET ((PLIST (LOCF (FIRST ADDRESSES)))
		(PNAME (FIRST PHRASES)))
	    (PUTPROP PLIST PNAME :PERSONAL-NAME)
	    ;; Include phrases and bracket in original string/interval
	    (IF *PRESERVE-ADDRESS-INTERVALS*
		(LET ((INTERVAL (GET PLIST :INTERVAL)))
		  (SETF (FIRST INTERVAL) (SECOND PHRASES))
		  (SETF (SECOND INTERVAL) (THIRD RIGHT-BRACKET)))
	      (PUTPROP PLIST (STRING-INTERVAL (SECOND PHRASES) (THIRD RIGHT-BRACKET) T)
		       :ORIGINAL-STRING)))
	;; Otherwise treat as a list
	(LET* ((ADDRESS NIL)
	       (PLIST (LOCF ADDRESS)))
	  (PUTPROP PLIST (FIRST PHRASES) :BRACKETED-LIST)
	  (SETF (THIRD PHRASES) (THIRD RIGHT-BRACKET))
	  (IF *PRESERVE-ADDRESS-INTERVALS*
	      (PUTPROP PLIST (CDR PHRASES) :INTERVAL)
	    (LOOP WITH LIST-ORIGINAL-STRING =
		    (STRING-INTERVAL (SECOND PHRASES) (THIRD PHRASES) T)
		  WITH START = 0
		  FOR ADDRESS ON ADDRESSES
		  AS ADDRESS-PLIST = (LOCF (FIRST ADDRESS))
		  AS ADDRESS-ORIGINAL-STRING = (GET ADDRESS-PLIST :ORIGINAL-STRING)
		  AS ADDRESS-INDEX =
		     (STRING-SEARCH ADDRESS-ORIGINAL-STRING LIST-ORIGINAL-STRING START)
		  DO (PUTPROP ADDRESS-PLIST
			      (SUBSTRING LIST-ORIGINAL-STRING START ADDRESS-INDEX)
			      :INITIAL-STRING)
		     (SETF START (+ ADDRESS-INDEX (STRING-LENGTH ADDRESS-ORIGINAL-STRING)))
		  FINALLY
		    (PUTPROP PLIST (SUBSTRING LIST-ORIGINAL-STRING START) :FINAL-STRING)
		    (PUTPROP PLIST LIST-ORIGINAL-STRING :ORIGINAL-STRING)))
	  (PUTPROP PLIST (COPYLIST ADDRESSES) :INFERIORS)
	  (PUSH ADDRESS ADDRESSES)))
    (WHEN (= (LENGTH ADDRESSES) 1)
      ;; If only one address but no phrases, we must still include the brackets in the
      ;; address' original string / interval
      (LET ((PLIST (LOCF (FIRST ADDRESSES))))
	;; Include phrases and bracket in original string/interval
	(IF *PRESERVE-ADDRESS-INTERVALS*
	    (LET ((INTERVAL (GET PLIST :INTERVAL)))
	      (SETF (FIRST INTERVAL) (THIRD LEFT-BRACKET))
	      (SETF (SECOND INTERVAL) (THIRD RIGHT-BRACKET)))
	  (PUTPROP PLIST
		   (STRING-INTERVAL (THIRD LEFT-BRACKET) (THIRD RIGHT-BRACKET) T)
		   :ORIGINAL-STRING)))))
  ADDRESSES)

(DEFUN ADDRESSES-IN-BRACKETS-WITH-ROUTE (PHRASES LEFT-BRACKET IGNORE ROUTE IGNORE
					 ADDRESSES RIGHT-BRACKET)
  (LET ((ADDRESSES (ADDRESSES-IN-BRACKETS PHRASES LEFT-BRACKET ADDRESSES RIGHT-BRACKET)))
    (LOOP FOR ADDRS ON ADDRESSES
	  DO (PUTPROP (LOCF (CAR ADDRS)) ROUTE ':ROUTE))
    ADDRESSES))

(DEFUN ROUTE-ELEMENT-WITH-DOMAINS (DOMAIN-LIST)
  (PARSE-DOMAIN-OR-HOST-TOKEN DOMAIN-LIST))

(DEFUN APPEND-ROUTING-PATHS (DOMAIN IGNORE IGNORE DOMAINS)
  (CONS DOMAIN DOMAINS))

(DEFUN ADDRESS-DISTRIBUTION-LIST (PHRASES IGNORE ADDRESSES SEMI)
  (WHEN PHRASES
    (LET* ((ADDRESS NIL)
	   (PLIST (LOCF ADDRESS)))
      (PUTPROP PLIST (FIRST PHRASES) :DISTRIBUTION-LIST)
      (SETF (THIRD PHRASES) (IBP (THIRD SEMI) T))
      (IF *PRESERVE-ADDRESS-INTERVALS*
	  (PUTPROP PLIST (CDR PHRASES) :INTERVAL)
	(LOOP WITH LIST-ORIGINAL-STRING = (STRING-INTERVAL (SECOND PHRASES) (THIRD PHRASES) T)
	      WITH START = 0
	      FOR ADDRESS ON ADDRESSES
	      AS ADDRESS-PLIST = (LOCF (FIRST ADDRESS))
	      AS ADDRESS-ORIGINAL-STRING = (GET ADDRESS-PLIST :ORIGINAL-STRING)
	      AS ADDRESS-INDEX =
		   (STRING-SEARCH ADDRESS-ORIGINAL-STRING LIST-ORIGINAL-STRING START)
	      DO (PUTPROP ADDRESS-PLIST (SUBSTRING LIST-ORIGINAL-STRING START ADDRESS-INDEX)
					:INITIAL-STRING)
		 (SETF START (+ ADDRESS-INDEX (STRING-LENGTH ADDRESS-ORIGINAL-STRING)))
	      FINALLY
		(PUTPROP PLIST (SUBSTRING LIST-ORIGINAL-STRING START) :FINAL-STRING)
		(PUTPROP PLIST LIST-ORIGINAL-STRING :ORIGINAL-STRING)))
      (PUTPROP PLIST (COPYLIST ADDRESSES) :INFERIORS)
      (PUSH ADDRESS ADDRESSES)))
  ADDRESSES)

(DEFUN COLON-ATOM-COLON-ADDRESS (COLON ATOM COLON2 ADDRESSES)
  (LET ((TYPE (INTERN (STRING-UPCASE (SECOND ATOM)) SI:PKG-KEYWORD-PACKAGE)))
    (LOOP FOR ADDRESS ON ADDRESSES
	  AS ADDRESS-PLIST = (LOCF (FIRST ADDRESS))
	  AS OLD-TYPE-AND-VALUE = (GETL ADDRESS-PLIST '(:NAME))
	  WHEN OLD-TYPE-AND-VALUE
	    DO (SETF (FIRST OLD-TYPE-AND-VALUE) TYPE)))
  (WHEN (= (LENGTH ADDRESSES) 1)
    (IF *PRESERVE-ADDRESS-INTERVALS*
	(LET ((INTERVAL (GET (LOCF (FIRST ADDRESSES)) :INTERVAL)))
	  (SETF (FIRST INTERVAL) (THIRD COLON)))
      (LET* ((ADDRESS-ORIGINAL-STRING (GET (LOCF (FIRST ADDRESSES)) :ORIGINAL-STRING))
	     (ADDRESS-END-BP (SEARCH (THIRD COLON2) ADDRESS-ORIGINAL-STRING NIL T))
	     (ADDRESS-START-BP (FORWARD-CHAR ADDRESS-END-BP
					     (- (STRING-LENGTH ADDRESS-ORIGINAL-STRING)) T)))
	(PUTPROP (LOCF (FIRST ADDRESSES))
		 (STRING-APPEND (STRING-INTERVAL (THIRD COLON) ADDRESS-START-BP T)
				ADDRESS-ORIGINAL-STRING)
		 :ORIGINAL-STRING))))
  ADDRESSES)

(DEFUN APPEND-PHRASES (PHRASE PHRASES)
  (COND (PHRASES
	 (SETF (FIRST PHRASE) (STRING-INTERVAL (SECOND PHRASE) (THIRD PHRASES)))
	 (SETF (THIRD PHRASE) (THIRD PHRASES))))
  PHRASE)

(DEFUN WORD-PERIOD-WORD (PHRASE IGNORE PHRASES)
  (APPEND-PHRASES PHRASE PHRASES))

(DEFUN WORD-PERIOD (WORD PERIOD)
  (APPEND-PHRASES WORD (PERIOD-TO-WORD PERIOD)))

(DEFUN PERIOD-TO-WORD (PERIOD)
  (LET ((BP (THIRD PERIOD)))
    (LIST "." BP (IBP (COPY-BP BP) T))))

(DEFFLAVOR UNKNOWN-USER-OBJECT-IN-ADDRESS (CONTAINED-ERROR POSITION) (PARSE-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT UNKNOWN-USER-OBJECT-IN-ADDRESS) (STREAM)
  (SEND CONTAINED-ERROR ':REPORT STREAM))

(DEFMETHOD (:POSITION-AND-REPORT UNKNOWN-USER-OBJECT-IN-ADDRESS) (STREAM)
  (SEND CONTAINED-ERROR ':REPORT STREAM)
  (VALUES (BP-LINE POSITION) (BP-INDEX POSITION)))

(DEFUN ADDRESS-HOST-PHRASE (PHRASE HOST)
  (WHEN HOST
    (SETF (THIRD PHRASE) (THIRD HOST)))
  (COND ((AND (NULL HOST) (NOT (NULL *DEFAULT-HOST-WHEN-PARSING*)))
	 `(:NAME ,(CAR PHRASE) :HOST ,(IF (TYPEP *DEFAULT-HOST-WHEN-PARSING* 'NET:HOST)
					  `(:OBJECT ,*DEFAULT-HOST-WHEN-PARSING*)
					`(:DOMAIN ,*DEFAULT-HOST-WHEN-PARSING*))
	   ,@(IF *PRESERVE-ADDRESS-INTERVALS*
		 `(:INTERVAL ,(CDR PHRASE))
	       `(:ORIGINAL-STRING ,(STRING-INTERVAL (SECOND PHRASE) (THIRD PHRASE))))))
	((AND (NULL HOST) (STRING-SEARCH-CHAR #/| (CAR PHRASE)))
	 (CONDITION-CASE (USER)
	      (NET:FIND-OBJECT-NAMED :USER
				     (LET ((STRING (CAR PHRASE)))
				       (IF (CHAR-EQUAL (AREF STRING 0) #/|)
					   (SUBSTRING STRING 1)
					 STRING)))
	    (NET:OBJECT-NOT-FOUND
	      (ERROR 'UNKNOWN-USER-OBJECT-IN-ADDRESS
		     :CONTAINED-ERROR USER :POSITION (CADR PHRASE)))
	    (:NO-ERROR
	      `(:USER ,USER
		,@(IF *PRESERVE-ADDRESS-INTERVALS*
		      `(:INTERVAL ,(CDR PHRASE))
		    `(:ORIGINAL-STRING ,(STRING-INTERVAL (SECOND PHRASE) (THIRD PHRASE))))))))
	(T
	 `(:NAME ,(CAR PHRASE) :HOST ,(CAR HOST)
	   ,@(IF *PRESERVE-ADDRESS-INTERVALS*
		 `(:INTERVAL ,(CDR PHRASE))
	       `(:ORIGINAL-STRING ,(STRING-INTERVAL (SECOND PHRASE) (THIRD PHRASE))))))))

(DEFUN COMMENT-PHRASE-FOR-HOST (COMMENT &AUX NAME INTERVAL)
  (SETF `(COMMENT ,NAME . ,INTERVAL) COMMENT)
  (AND (STRING-EQUAL NAME "(BUG " 0 0 5 5)
       (SETQ NAME (STRING-APPEND "BUG-" (SUBSTRING NAME 5 (1- (STRING-LENGTH NAME))))))
  `(,NAME . ,INTERVAL))

(DEFUN ADDRESS-PATH-DOMAIN-INDICATOR (PATH)
  (IF (NULL (CL:REST (FIRST PATH)))
      (SETF (FIRST PATH) (FIRST (FIRST PATH)))
      (PUSH :PATH (FIRST PATH)))
  PATH)

(DEFUN ADDRESS-PATH-LAST-DOMAIN (DOMAIN)
  (SETF (FIRST DOMAIN) (LIST (FIRST DOMAIN)))
  DOMAIN)

(DEFUN ADDRESS-PATH-MORE-DOMAINS (DOMAIN PATH)
  (PUSH (FIRST DOMAIN) (FIRST PATH))
  (SETF (SECOND PATH) (SECOND DOMAIN))
  PATH)

(DEFUN ADDRESS-AT-DOMAIN (ATSIGN DOMAIN)
  (CL:SETF (SECOND DOMAIN) (THIRD ATSIGN)
	   (FIRST DOMAIN) (PARSE-DOMAIN-OR-HOST-TOKEN DOMAIN))
  DOMAIN)

(DEFUN ADDRESS-LAST-SUBDOMAIN (SUBDOMAIN)
  (SETF (SECOND SUBDOMAIN) (LIST (SECOND SUBDOMAIN)))
  (CL:REST SUBDOMAIN))

(DEFUN ADDRESS-MORE-SUBDOMAINS (SUBDOMAIN IGNORE DOMAIN)
  (CL:SETF (FIRST DOMAIN) (CONS (SECOND SUBDOMAIN) (FIRST DOMAIN))
	   (SECOND DOMAIN) (THIRD SUBDOMAIN))
  DOMAIN)



;;; Domain/Host Name Parser

;;; Error flavors used by the domain/host name parser
(DEFFLAVOR DOMAIN-SYNTAX-ERROR ((POSITION NIL))
	   (FERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES POSITION))

(DEFFLAVOR DOMAIN-SYNTAX-PARSE-ERROR ((CONTAINED-ERROR NIL)
				      START-BP END-BP)
	   (PARSE-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES CONTAINED-ERROR))

(DEFMETHOD (:REPORT DOMAIN-SYNTAX-PARSE-ERROR) (STREAM)
  (MULTIPLE-VALUE-BIND (LINE POSITION)
      (DSPE-COMPUTE-POSITION CONTAINED-ERROR START-BP END-BP)
    (FORMAT STREAM "~&In ~S,~%~VT~%" LINE
	    (LOOP FOR COUNT FROM 4		;"In /""
		  FOR INDEX FROM 0 BELOW POSITION
		  AS CHAR = (AREF LINE INDEX)
		  WHEN (MEM #'CHAR-EQUAL CHAR '(#/" #//))
		    DO (INCF COUNT)		;Two places for these
		  ELSE WHEN (CHAR-EQUAL CHAR #\CR)
		    DO (SETQ COUNT 0)
		  FINALLY (RETURN COUNT)))
  (SEND CONTAINED-ERROR :REPORT STREAM)))

(DEFMETHOD (:POSITION-AND-REPORT DOMAIN-SYNTAX-PARSE-ERROR) (STREAM)
  (SEND CONTAINED-ERROR :REPORT STREAM)
  (DSPE-COMPUTE-POSITION CONTAINED-ERROR START-BP END-BP))

(DEFUN DSPE-COMPUTE-POSITION (CONTAINED-ERROR START-BP END-BP)
  (LET ((POSITION (OR (SEND-IF-HANDLES CONTAINED-ERROR :POSITION) 0)))
    (LOOP FOR LINE = (BP-LINE START-BP) THEN (LINE-NEXT LINE)
	  AS START-INDEX = (BP-INDEX START-BP) THEN 0
	  AS END-INDEX = (IF (EQ LINE (BP-LINE END-BP)) (BP-INDEX END-BP) (LINE-LENGTH LINE))
	  AS LINE-IN-USE = (- END-INDEX START-INDEX)
	  WHEN ( POSITION LINE-IN-USE)
	    DO (RETURN (VALUES LINE (+ START-INDEX POSITION)))
	  ELSE
	    DO (DECF POSITION LINE-IN-USE)
	  UNTIL (EQ LINE (BP-LINE END-BP))
	  FINALLY (RETURN (VALUES (BP-LINE END-BP) (BP-INDEX END-BP))))))

(COMPILE-FLAVOR-METHODS DOMAIN-SYNTAX-ERROR DOMAIN-SYNTAX-PARSE-ERROR)

;;; Domain/host name parser used by various address parser productions --
;;;    The grammar defined to parse addresses does not properly understand the syntax of
;;;    domain literals ([text]) and, therefore, we can not directly use the domain list
;;;    generated by the parse.  However, as the only lexemes that the parse allows in a
;;;    domain/host name are atoms, we can safely reconstruct the text of the domain/host
;;;    name and give that to PARSE-DOMAIN-OR-HOST which will split it into its
;;;    proper components.
(DEFUN PARSE-DOMAIN-OR-HOST-TOKEN (DOMAIN-OR-HOST-TOKEN)
  (LET ((DOMAIN-OR-HOST (FIRST DOMAIN-OR-HOST-TOKEN))
	(START-BP (SECOND DOMAIN-OR-HOST-TOKEN))
	(END-BP (THIRD DOMAIN-OR-HOST-TOKEN)))
    (CONDITION-CASE (.ERROR.)
	 (PDOH (TYPECASE DOMAIN-OR-HOST
		 (:STRING DOMAIN-OR-HOST)
		 (:LIST (LOOP FOR DOMAIN IN DOMAIN-OR-HOST
			      FOR STRING FIRST DOMAIN THEN (STRING-APPEND STRING #/. DOMAIN)
			      FINALLY (RETURN STRING)))
		 (OTHERWISE
		   (ERROR 'DOMAIN-SYNTAX-ERROR
			  :FORMAT-STRING "Bad domain/host name token type."))))
       (ERROR
	 (ERROR 'DOMAIN-SYNTAX-PARSE-ERROR :CONTAINED-ERROR .ERROR.
					   :START-BP START-BP
					   :END-BP END-BP)))))

;;; Domain/host name parser used by callers which have not tokenized their input --
;;;    Care must be taken when using this function that, if it signals an error, said error
;;;    is not stored in the LOSING-HEADERS of a draft message unless STRING is, in fact,
;;;    an editor LINE.  Otherwise, the draft's :TRANSMIT message will attempt to move the
;;;    cursor of the header interval to the error by sending the error a :POSITION-AND-REPORT
;;;    message and the editor will lose trying to move somewhere which is not in an interval.
(DEFUN PARSE-DOMAIN-OR-HOST (STRING &OPTIONAL (START 0) (END (STRING-LENGTH STRING)))
  (CONDITION-CASE (.ERROR.)
       (PDOH STRING START END)
     (ERROR
       (ERROR 'DOMAIN-SYNTAX-PARSE-ERROR :CONTAINED-ERROR .ERROR.
					 :START-BP `(,STRING ,START)
					 :END-BP `(,STRING ,END)))))

;;; Converts a domain/host string into the appropriate object --
;;;    Special cases for compatibility with older style addressing:
;;;       (1) A string consisting of a single subdomain is treated as an old style host name.
;;;       (2) A string consisting of a single domain-literal is treated as an ARPA network
;;;	      address.  Use of domain-literals in multi-component domain names is not really
;;;	      supported but, then, their semantics are not at all clear.
(DEFUN PDOH (STRING &OPTIONAL (START 0) (END (STRING-LENGTH STRING)))
  (LET ((COMPONENTS (PDOH-PARSE-INTO-COMPONENTS STRING START END)))
    (PARSING-HOST-OBJECT
      (CL:CASE (LENGTH COMPONENTS)
	(0
	  (ERROR 'DOMAIN-SYNTAX-ERROR :FORMAT-STRING "Null domain specification."))
	(1
	  (DESTRUCTURING-BIND (TYPE . VALUE) (CAR COMPONENTS)
	    (CL:CASE TYPE
	      (:SUBDOMAIN
		(LET ((OBJECT (NET:PARSE-HOST VALUE T)))
		  (IF OBJECT
		      `(:OBJECT ,OBJECT)
		    `(:SINGLE ,(SUBSTRING STRING START END)))))
	      (:DOMAIN-LITERAL
		(LET ((INTERNET (NET:LOCAL-NETWORK-OF-TYPE :INTERNET NIL)))
		  (IF INTERNET
		      `(:OBJECT ,(NET:GET-HOST-FROM-ADDRESS
				   (SEND INTERNET :PARSE-ADDRESS VALUE) INTERNET))
		    `(:SINGLE ,(SUBSTRING STRING START END))))))))
	(OTHERWISE
	  (LET ((COMPONENT-STRINGS (MAPCAR #'PDOH-STRING-FROM-COMPONENT COMPONENTS)))
	    (OR (WHEN *ALLOW-NAMESPACE-SERVER-PARSING-HOST*
		  (LET ((OBJECT (NETI:PARSE-DOMAIN-HOST COMPONENT-STRINGS NIL)))
		    (WHEN OBJECT
		      `(:OBJECT ,OBJECT))))
		`(:DOMAIN ,@COMPONENT-STRINGS))))))))

(DEFUN PDOH-PARSE-INTO-COMPONENTS (STRING START END)
  (LOOP WITH (VALUE END-INDEX)
	FOR START-INDEX = START THEN (IF END-INDEX (1+ END-INDEX) END)
	UNTIL ( START-INDEX END)
	AS TYPE = (SELECTOR (AREF STRING START-INDEX) CHAR-EQUAL
		    (#/[ :DOMAIN-LITERAL)
		    (#/.
		     (ERROR 'DOMAIN-SYNTAX-ERROR :POSITION START-INDEX 
			    :FORMAT-STRING "Null component in domain."))
		    (OTHERWISE :SUBDOMAIN))
	DO (SELECTQ TYPE
	     (:SUBDOMAIN
	      (SETQ END-INDEX (STRING-SEARCH-CHAR #/. STRING (1+ START-INDEX) END)
		    VALUE (SUBSTRING STRING START-INDEX (OR END-INDEX END)))
	      (LET ((FAILING-CHAR-INDEX (STRING-SEARCH-SET '(#/[ #/] #/\) VALUE)))
		(WHEN FAILING-CHAR-INDEX
		  (ERROR 'DOMAIN-SYNTAX-ERROR
			 :POSITION (+ FAILING-CHAR-INDEX START-INDEX)
			 :FORMAT-STRING "Invalid character /"~C/" in domain component."
			 :FORMAT-ARGS `(,(AREF VALUE FAILING-CHAR-INDEX))))))
	     (:DOMAIN-LITERAL
	      (LOOP FOR CHECKED-INDEX = (1+ START-INDEX) THEN (+ BREAK-INDEX 2)
		    AS BREAK-INDEX = (STRING-SEARCH-SET
				       '(#/[ #/] #/\) STRING CHECKED-INDEX END)
		    UNLESS BREAK-INDEX
		      DO (ERROR 'DOMAIN-SYNTAX-ERROR :POSITION START-INDEX
				:FORMAT-STRING "Missing /"]/" in domain literal.")
		    DO (SELECTOR (AREF STRING BREAK-INDEX) CHAR-EQUAL
			 (#/[
			  (ERROR 'DOMAIN-SYNTAX-ERROR :POSITION BREAK-INDEX
				 :FORMAT-STRING "Unquoted /"[/" in domain literal."))
			 (#/]
			  (SETQ END-INDEX (1+ BREAK-INDEX))
			  (UNLESS (OR ( END-INDEX END)
				      (CHAR-EQUAL #/. (AREF STRING END-INDEX)))
			    (ERROR 'DOMAIN-SYNTAX-ERROR :POSITION END-INDEX
			      :FORMAT-STRING "Domain literal can not be followed by a /"~C/"."
			      :FORMAT-ARGS `(,(AREF STRING END-INDEX))))
			  (LOOP-FINISH))
			 (OTHERWISE		; must be \
			   (WHEN (= BREAK-INDEX (1- END))
			     (ERROR 'DOMAIN-SYNTAX-ERROR :POSITION BREAK-INDEX
			       :FORMAT-STRING "Nothing follows /"\/" in domain literal."))))
		    FINALLY
		      (SETQ VALUE (SUBSTRING STRING (1+ START-INDEX) BREAK-INDEX)))))
	COLLECT (CONS TYPE VALUE)
	FINALLY (WHEN (CHAR-EQUAL (AREF STRING (1- END)) #/.)
		  (ERROR 'DOMAIN-SYNTAX-ERROR :POSITION (1- END)
			 :FORMAT-STRING "Null component in domain."))))

(DEFUN PDOH-FIND-OBJECT-IN-DOMAIN (OBJECT DOMAIN)
  (FLET ((STRING-FROM-COMPONENTS (COMPONENTS)
	   (LOOP FOR COMPONENT IN COMPONENTS
		 FOR STRING FIRST (PDOH-STRING-FROM-COMPONENT COMPONENT)
			    THEN (STRING-APPEND STRING #/.
						(PDOH-STRING-FROM-COMPONENT COMPONENT))
		 FINALLY (RETURN STRING))))
    (LET ((NAMESPACE (MAILER:FIND-NAMESPACE-FROM-DOMAIN (STRING-FROM-COMPONENTS DOMAIN))))
      (WHEN NAMESPACE
	(CONDITION-CASE ()
	     (NETI:FIND-OBJECT-NAMED-IN-NAMESPACE :HOST (STRING-FROM-COMPONENTS OBJECT)
						  NAMESPACE)
	   (NET:OBJECT-NOT-FOUND NIL))))))

(DEFUN PDOH-STRING-FROM-COMPONENT (COMPONENT)
  (DESTRUCTURING-BIND (TYPE . VALUE) COMPONENT
    (SELECTQ TYPE
      (:SUBDOMAIN VALUE)
      (:DOMAIN-LITERAL (STRING-APPEND #/[ VALUE #/])))))



1;;; Major parsing interfaces

0(DEFUN PARSE-ADDRESSES-INTERVAL (START-BP &OPTIONAL END-BP IN-ORDER-P &AUX LEXEMES)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (SETQ LEXEMES (RDTBL-LEXER RFC733 (BP-LINE START-BP) (BP-INDEX START-BP)
			     (BP-LINE END-BP) (BP-INDEX END-BP)))
  (LET-IF (OR (NOT (VARIABLE-BOUNDP *INTERVAL*))
	      (NOT (EQ (BP-NODE START-BP) *INTERVAL*)))
	  ((*INTERVAL* (CREATE-INTERVAL START-BP END-BP)))
    (MAP-THIN-STRING-OVER-ADDRESSES (PARSE-DRIVER LEXEMES (GET 'ADDRESSES 'PARSE-GRAMMAR)))))

(DEFUN PARSE-ADDRESSES (STRING &OPTIONAL (START 0) END)
  (UNLESS END (SETQ END (STRING-LENGTH STRING)))
  (LET* ((*INTERVAL* (CREATE-INTERVAL STRING))
	 (START-BP (FORWARD-CHAR (COPY-BP (INTERVAL-FIRST-BP *INTERVAL*)) START))
	 (END-BP (FORWARD-CHAR (COPY-BP (INTERVAL-FIRST-BP *INTERVAL*)) END T)))
    (PARSE-ADDRESSES-INTERVAL START-BP END-BP T)))

;;; Coerece all strings in the parsed form of a list of addresses into simple (thin) strings.
;;; However, to avoid damaging the ZWEI LINE objects contained in an address' :INTERVAL
;;; property, this function will never coerce anything in the element following :INTERVAL.
(DEFUN MAP-THIN-STRING-OVER-ADDRESSES (ADDRESSES)
  (LOOP AS PRIOR-ELEMENT = NIL THEN (FIRST REMAINDER)
	FOR REMAINDER ON ADDRESSES
	DO (COND ((EQ PRIOR-ELEMENT :INTERVAL))
		 ((STRINGP (FIRST REMAINDER))
		  (SETF (FIRST REMAINDER)
			(STRING-THIN (FIRST REMAINDER) :REMOVE-BITS T)))
		 ((LISTP (FIRST REMAINDER))
		  (MAP-THIN-STRING-OVER-ADDRESSES (FIRST REMAINDER)))))
  ADDRESSES)

(DEFFLAVOR PARSED-OTHER-THAN-ONE-ADDRESS (STRING ADDRESSES) (PARSE-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT PARSED-OTHER-THAN-ONE-ADDRESS) (STREAM)
  (IF (NULL ADDRESSES)
      (STRING-OUT "No" STREAM)
      (STRING-OUT "More than one" STREAM))
  (FORMAT STREAM " address in ~A." STRING))

(DEFMETHOD (:POSITION-AND-REPORT PARSED-OTHER-THAN-ONE-ADDRESS) (STREAM)
  (SEND SELF :REPORT STREAM)
  (IF (NULL ADDRESSES)
      (VALUES STRING 0)
    (LET ((ORIGINAL-STRING (GET (LOCF (SECOND ADDRESSES)) :ORIGINAL-STRING))
	  (INTERVAL (GET (LOCF (SECOND ADDRESSES)) :INTERVAL)))
      (IF ORIGINAL-STRING
	  (VALUES ORIGINAL-STRING 0)
	(VALUES (BP-LINE (FIRST INTERVAL)) (BP-INDEX (FIRST INTERVAL)))))))

;;; Parse the addresses in an SMTP reply --
;;;    There's one address per line following the reply code and continuation indicator.
;;;    This function is implemented here to cut down on unecessary CREATE-INTERVALs.
;;;    2Note -- This function assumes that the last line of the reply does not include
0;;;    2a Return character.  (MAILER:SMTP-CHECK-REPLY0 2returns replies of this form.)
0(DEFUN PARSE-ADDRESSES-IN-SMTP-REPLY (REPLY &OPTIONAL COLLECT-ERRORS)
  (PARSING-HOSTS
    (LET ((*ALLOW-NAMESPACE-SERVER-PARSING-HOST* T)
	  (*INTERVAL* (CREATE-INTERVAL REPLY)))
      (LOOP WITH END-LINE = (BP-LINE (INTERVAL-LAST-BP *INTERVAL*))
	    FOR LINE = (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)) THEN (LINE-NEXT LINE)
	    FOR START-BP = (CREATE-BP LINE (OR (1+ (STRING-SEARCH-SET "- " LINE)) 0))
	    FOR END-BP = (CREATE-BP LINE (LINE-LENGTH LINE))
	    COLLECT (CONDITION-CASE-IF COLLECT-ERRORS (.ERROR.)
			 (LET ((ADDRESSES (PARSE-ADDRESSES-INTERVAL START-BP END-BP T)))
			   (IF (= (LENGTH ADDRESSES) 1)
			       (FIRST ADDRESSES)
			     (ERROR 'PARSED-OTHER-THAN-ONE-ADDRESS :ADDRESSES ADDRESSES
								   :STRING LINE)))
		       (PARSE-ERROR .ERROR.))
	    UNTIL (EQ LINE END-LINE)))))

;;; Parse a single address, used mostly by network servers.
;;; Just call the full parser and barf if get more than one address.
(DEFUN PARSE-ONE-ADDRESS (STRING &OPTIONAL (START 0) END ALLOW-ZERO)
  (LET ((ADDRESSES (LET ((*ALLOW-NAMESPACE-SERVER-PARSING-HOST* T))
		     (PARSE-ADDRESSES STRING START END))))
    (WHEN (IF (NULL ADDRESSES)
	      (NOT ALLOW-ZERO)
	    (NOT (NULL (CDR ADDRESSES))))
      (ERROR 'PARSED-OTHER-THAN-ONE-ADDRESS :ADDRESSES ADDRESSES
					    :STRING (IF (AND (ZEROP START)
							     (NULL END))
							STRING
						      (SUBSTRING STRING START END))))
    (FIRST ADDRESSES)))



;;; Address movement
(DEFCOM-FOR-ZMAIL COM-FORWARD-ADDRESS "Move one or more addresses forward." (KM)
  (MOVE-BP (POINT) (OR (FORWARD-ADDRESS (POINT) *NUMERIC-ARG*) (BARF)))
  DIS-BPS)

(DEFCOM-FOR-ZMAIL COM-BACKWARD-ADDRESS "Move one or more addresses backward." (KM)
  (MOVE-BP (POINT) (OR (FORWARD-ADDRESS (POINT) (- *NUMERIC-ARG*)) (BARF)))
  DIS-BPS)

(DEFCOM-FOR-ZMAIL COM-KILL-ADDRESS "Kill one or more addresses forward." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-ADDRESS *NUMERIC-ARG*))

(DEFCOM-FOR-ZMAIL COM-BACKWARD-KILL-ADDRESS "Kill one or more addresses backward." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-ADDRESS (- *NUMERIC-ARG*)))

(DEFCOM-FOR-ZMAIL COM-EXCHANGE-ADDRESSES
		  "Interchange the addresses before and after the cursor." ()
  (EXCHANGE-SUBR 'FORWARD-ADDRESS *NUMERIC-ARG*)
  DIS-TEXT)

(DEFCOM-FOR-ZMAIL COM-MARK-ADDRESS "Set mark one or more addresses from point." (SM)
  (LET (BP1 BP2)
    (SETQ BP1 (FORWARD-ADDRESS (POINT) *NUMERIC-ARG* T))
    (SETQ BP2 (FORWARD-ADDRESS BP1 (MINUS *NUMERIC-ARG*) T))
    (AND (MINUSP *NUMERIC-ARG*)
	 (SWAPF BP1 BP2))
    (MOVE-BP (POINT) BP1)
    (MOVE-BP (MARK) BP2))
  DIS-BPS)

(DEFUN FORWARD-ADDRESS (BP &OPTIONAL (TIMES 1) FIXUP-P)
  (COND ((ZEROP TIMES)
	 (COPY-BP BP))
	((PLUSP TIMES)
	 (DO ((LINE (BP-LINE BP))
	      (END-LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
	      (START-BP) (START-ADDRESS)
	      (END-BP) (END-ADDRESS)
	      (INTERVAL))
	     (NIL)
	   (SETQ START-ADDRESS NIL
		 END-ADDRESS NIL)
	   (DOLIST (ADDRESS (ADDRESSES-STARTING-ON-LINE LINE))
	     (AND (SETQ INTERVAL (GET (LOCF ADDRESS) ':INTERVAL))
		  (NOT (BP-< (FIRST INTERVAL) BP))
		  (OR (NULL START-ADDRESS) (BP-< (FIRST INTERVAL) START-BP))
		  (SETQ START-BP (FIRST INTERVAL)
			START-ADDRESS ADDRESS)))
	   (DOLIST (ADDRESS (ADDRESSES-ENDING-ON-LINE LINE))
	     (AND (SETQ INTERVAL (GET (LOCF ADDRESS) ':INTERVAL))
		  (BP-< BP (SECOND INTERVAL))
		  (OR (NULL END-ADDRESS) (BP-< (SECOND INTERVAL) END-BP))
		  (SETQ END-BP (SECOND INTERVAL)
			END-ADDRESS ADDRESS)))
	   (COND ((AND (NULL START-ADDRESS) (NULL END-ADDRESS))
		  (AND (EQ LINE END-LINE)
		       (RETURN (AND FIXUP-P (COPY-BP (INTERVAL-LAST-BP *INTERVAL*)))))
		  (SETQ LINE (LINE-NEXT LINE)))
		 (T
		  (SETQ BP (IF (OR (NULL END-BP) (AND START-BP (BP-< START-BP END-BP)))
			       (SECOND (GET (LOCF START-ADDRESS) ':INTERVAL))
			       END-BP)
			LINE (BP-LINE BP)
			TIMES (1- TIMES))
		  (AND (ZEROP TIMES) (RETURN BP))))))
	(T
	 (DO ((LINE (BP-LINE BP))
	      (START-LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
	      (END-BP) (END-ADDRESS)
	      (START-BP) (START-ADDRESS)
	      (INTERVAL))
	     (NIL)
	   (SETQ END-ADDRESS NIL
		 START-ADDRESS NIL)
	   (DOLIST (ADDRESS (ADDRESSES-ENDING-ON-LINE LINE))
	     (AND (SETQ INTERVAL (GET (LOCF ADDRESS) ':INTERVAL))
		  (NOT (BP-< BP (SECOND INTERVAL)))
		  (OR (NULL END-ADDRESS) (BP-< END-BP (SECOND INTERVAL)))
		  (SETQ END-BP (SECOND INTERVAL)
			END-ADDRESS ADDRESS)))
	   (DOLIST (ADDRESS (ADDRESSES-STARTING-ON-LINE LINE))
	     (AND (SETQ INTERVAL (GET (LOCF ADDRESS) ':INTERVAL))
		  (BP-< (FIRST INTERVAL) BP)
		  (OR (NULL START-ADDRESS) (BP-< START-BP (FIRST INTERVAL)))
		  (SETQ START-BP (FIRST INTERVAL)
			START-ADDRESS ADDRESS)))
	   (COND ((AND (NULL END-ADDRESS) (NULL START-ADDRESS))
		  (AND (EQ LINE START-LINE)
		       (RETURN (AND FIXUP-P (COPY-BP (INTERVAL-LAST-BP *INTERVAL*)))))
		  (SETQ LINE (LINE-PREVIOUS LINE)))
		 (T
		  (SETQ BP (IF (OR (NULL START-BP) (AND END-BP (BP-< START-BP END-BP)))
			       (FIRST (GET (LOCF END-ADDRESS) ':INTERVAL))
			       START-BP)
			LINE (BP-LINE BP)
			TIMES (1+ TIMES))
		  (AND (ZEROP TIMES) (RETURN BP))))))))

(DEFUN ADDRESSES-STARTING-ON-LINE (LINE &AUX PLIST TEM)
  (SETQ PLIST (LOCF (LINE-CONTENTS-PLIST LINE)))
  (IF (SETQ TEM (GETL PLIST '(STARTING-ADDRESSES)))
      (CADR TEM)
      (PARSE-ADDRESSES-AROUND-LINE LINE)
      (GET PLIST 'STARTING-ADDRESSES)))

(DEFUN ADDRESSES-ENDING-ON-LINE (LINE &AUX PLIST TEM)
  (SETQ PLIST (LOCF (LINE-CONTENTS-PLIST LINE)))
  (IF (SETQ TEM (GETL PLIST '(ENDING-ADDRESSES)))
      (CADR TEM)
      (PARSE-ADDRESSES-AROUND-LINE LINE)
      (GET PLIST 'ENDING-ADDRESSES)))

(DEFUN PARSE-ADDRESSES-AROUND-LINE (LINE &AUX START-LINE END-LINE)
  (DO ((FIRST-LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))))
      ((OR (EQ LINE FIRST-LINE)
	   (NOT (CONTINUATION-LINE-P LINE))))
    (SETQ LINE (LINE-PREVIOUS LINE)))
  (SETQ START-LINE LINE)
  (DO ((LAST-LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*))))
      (NIL)
    (SETQ END-LINE LINE)
    (AND (EQ LINE LAST-LINE) (RETURN))
    (SETQ LINE (LINE-NEXT LINE))
    (AND (NOT (CONTINUATION-LINE-P LINE)) (RETURN)))
  (DO ((LINE START-LINE (LINE-NEXT LINE))
       (PLIST))
      (NIL)
    (SETQ PLIST (LOCF (LINE-CONTENTS-PLIST LINE)))
    (PUTPROP PLIST NIL 'STARTING-ADDRESSES)
    (PUTPROP PLIST NIL 'ENDING-ADDRESSES)
    (AND (EQ LINE END-LINE) (RETURN)))
  (LET ((*PRESERVE-ADDRESS-INTERVALS* T))
    (LOOP FOR (TYPE ADDRESSES) ON (PARSE-ONE-HEADER START-LINE END-LINE) BY 'CDDR
	  WHEN (HEADER-TYPE-TYPEP TYPE :ADDRESS)
	    DO (DOLIST (ADDRESS ADDRESSES)
		 (LET ((INTERVAL (GET (LOCF ADDRESS) :INTERVAL)))
		   (COND (INTERVAL
			  (LET ((START-LINE (BP-LINE (FIRST INTERVAL))))
			    (PUSH ADDRESS (GET (LOCF (LINE-CONTENTS-PLIST START-LINE))
					       'STARTING-ADDRESSES)))
			  (LET ((END-LINE (BP-LINE (SECOND INTERVAL))))
			    (PUSH ADDRESS (GET (LOCF (LINE-CONTENTS-PLIST END-LINE))
					       'ENDING-ADDRESSES))))))))))

(DEFUN CONTINUATION-LINE-P (LINE)
  (AND (PLUSP (LINE-LENGTH LINE))
       (MEM #'CHAR-EQUAL (AREF LINE 0) '(#\SP #\TAB))))

(DEFCOM-FOR-ZMAIL COM-WHOIS-ADDRESS "Do a whois of the address before point." ()
  (LET* ((POINT (POINT))
	 (ADDRESS (DOLIST (ADDRESS (ADDRESSES-STARTING-ON-LINE (BP-LINE POINT)))
		    (WHEN (LET ((INTERVAL (GET (LOCF ADDRESS) ':INTERVAL)))
			    (AND INTERVAL
				 (BP-< (FIRST INTERVAL) POINT)
				 (NOT (BP-< (SECOND INTERVAL) POINT))))
		      (RETURN ADDRESS)))))
    (UNLESS ADDRESS (BARF))
    (SETQ ADDRESS (STRING-FROM-HEADER ADDRESS ':SHORT))
    (LET-IF (EQ *WINDOW* *HEADER-WINDOW*)
	    ((*TYPEOUT-WINDOW* (WINDOW-TYPEOUT-WINDOW *REPLY-WINDOW*)))
      (CHAOS:WHOIS ADDRESS *TYPEOUT-WINDOW*)))
  DIS-NONE)

(3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")#+IGNORE0					3;Actual 2defflavor3 is in SYS:ZMAIL;DEFS.
0(DEFFLAVOR NULL-MSG () (PARSE-ERROR))

(DEFMETHOD (DBG:REPORT NULL-MSG) (STREAM)
  (CL:WRITE-STRING "Message is empty." STREAM))

(DEFMETHOD (:POSITION-AND-REPORT NULL-MSG) (STREAM)
  (DBG:REPORT SELF STREAM)
  (VALUES NIL 0))


1;;; Header parsing --  Parse headers in the given interval, returning a list
0(DEFUN PARSE-HEADERS-INTERVAL (START-BP &OPTIONAL END-BP IN-ORDER-P STOP-AT-BLANK-LINE
						  ALLOWED-TYPES)
  (DECLARE (VALUES HEADERS HEADERS-END-BP))
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (LET* ((END-LINE (BP-LINE END-BP))
	 (START-LINE (DO ((*INTERVAL* (LINE-TOP-LEVEL-NODE END-LINE))
			  (LINE (BP-LINE START-BP) (LINE-NEXT LINE)))
			 ((NOT (LINE-BLANK-P LINE))
			  LINE)
		       (WHEN (EQ LINE END-LINE)
			 (RETURN-FROM PARSE-HEADERS-INTERVAL
			   (VALUES `(UNPARSEABLE ,(MAKE-CONDITION 'NULL-MSG))
				   (COPY-BP END-BP))))))
	 (HEADERS)
	 (HEADERS-END-BP))
    (DO ((LINE START-LINE (UNLESS DONE (LINE-NEXT LINE)))
	 (FIRST-LINE NIL)
	 (LAST-LINE NIL LINE)
	 (DONE NIL)
	 (LINE-IS-BLANK NIL NIL))
	(DONE)
      (WHEN (COND ((NULL LINE) (SETQ DONE T))
		  ((AND (EQ LINE END-LINE) (ZEROP (BP-INDEX END-BP))) (SETQ DONE T))
		  ((EQ LAST-LINE END-LINE) (SETQ DONE T))
		  ((ZEROP (LINE-LENGTH LINE))	1;Blank line.
0		   (WHEN (AND FIRST-LINE STOP-AT-BLANK-LINE)
		     (SETQ HEADERS-END-BP (CREATE-BP (OR (LINE-NEXT LINE) LINE) 0)
			   DONE T))
		   (SETQ LINE-IS-BLANK T))
		  ((CONTINUATION-LINE-P LINE) NIL)	1;Continuation line.
0		  (T T))
1	;; We're now at the start of the next field, the start of the message body,
	;; or at the end of the interval...
0	(WHEN FIRST-LINE
	  (LET ((FIELD-HEADERS (PARSE-ONE-HEADER FIRST-LINE LAST-LINE ALLOWED-TYPES)))
	    (WHEN (AND (EQ STOP-AT-BLANK-LINE 'FIRST-NON-HEADER)
		       (EQ (FIRST FIELD-HEADERS) 'LOSING-HEADERS)
		       (TYPEP (FIRST (SECOND FIELD-HEADERS)) 'HEADER-LINE-WITHOUT-COLON))
	      1;; Stopping at the first non-header field -- Note where the headers really end.
0	      (SETQ HEADERS-END-BP (CREATE-BP FIRST-LINE 0))
	      (RETURN))
	    (WHEN FIELD-HEADERS
	      1;; Record the field's parse in its lines' property lists.
0	      (LOOP FOR LINE = FIRST-LINE THEN (LINE-NEXT LINE)
		    DO (PUTPROP
			 (LOCF (LINE-CONTENTS-PLIST LINE)) FIELD-HEADERS 'PARSED-HEADERS)
		    UNTIL (EQ LINE LAST-LINE))
	      1;; Add the field's parse to the interval's.
0	      (LOOP FOR (TYPE VALUE) ON FIELD-HEADERS BY 'CDDR
		    AS SUBLIST = (PROG1 (GET (LOCF HEADERS) TYPE)
					(SI:NREMPROP (LOCF HEADERS) TYPE))
		    DO (SETQ SUBLIST (IF SUBLIST
					 (APPEND (IF (CL:LISTP SUBLIST) SUBLIST
						   (NCONS SUBLIST))
						 (IF (CL:LISTP VALUE) VALUE (NCONS VALUE)))
				       VALUE)
			     HEADERS (NCONC HEADERS (LIST TYPE SUBLIST)))))))
	1;; This line will be the first line of the next field (if any)...
0	(SETQ FIRST-LINE (UNLESS LINE-IS-BLANK LINE))))
    (WHEN (NULL HEADERS-END-BP)
      (SETQ HEADERS-END-BP (COPY-BP END-BP)))
    (VALUES HEADERS HEADERS-END-BP)))

(DEFFLAVOR HEADER-LINE-WITHOUT-COLON (LINE) (PARSE-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:POSITION-AND-REPORT HEADER-LINE-WITHOUT-COLON) (STREAM &AUX (INDEX 0))
  (PRINC "No colon on this line; " STREAM)
  (ATOM-WORD-SYNTAX-BIND
    (LET ((BP (CREATE-BP LINE 0))
	  BP1 NAME PREV)
      (SETQ BP (FORWARD-TO-WORD BP 1 T)
	    BP1 (FORWARD-WORD BP 1 T))
      (COND ((AND (EQ (BP-LINE BP) (BP-LINE BP1))
		  (SETQ NAME (HEADER-NAME-TYPE (BP-LINE BP)
					       (BP-INDEX BP) (BP-INDEX BP1) NIL)))
	     (SETQ INDEX (BP-INDEX BP1))
	     (FORMAT STREAM "~A: is a valid field name, perhaps a colon is missing." NAME))
	    ((AND (SETQ PREV (LINE-PREVIOUS LINE))
		  (SETQ PREV (GET (LOCF (LINE-CONTENTS-PLIST PREV)) 'PARSED-HEADERS)))
	     (FORMAT STREAM "perhaps this is meant to be a continuation of the ~A: line."
		     (HEADER-TYPE-NAME (CAR PREV))))
	    (T
	     (FORMAT STREAM "perhaps a field name is missing.")))))
  (VALUES LINE INDEX))

(DEFMETHOD (:REPORT HEADER-LINE-WITHOUT-COLON) (STREAM)
  (FORMAT STREAM "No colon was found in ~S" LINE))
1;;; Parse a single line or line and continuation line(s).
0(DEFUN PARSE-ONE-HEADER (START-LINE END-LINE &OPTIONAL ALLOWED-TYPES)
  (LET ((INDEX (STRING-SEARCH-CHAR #/: START-LINE)))
    (IF INDEX
	(MULTIPLE-VALUE-BIND (TYPE ELEM)
	    (HEADER-NAME-TYPE START-LINE 0 INDEX)
	  (WHEN (OR (NULL ALLOWED-TYPES)
		    (LOOP FOR SUPERTYPE IN ALLOWED-TYPES
			  THEREIS (HEADER-TYPE-TYPEP TYPE SUPERTYPE)))
	    (SETQ INDEX (OR (STRING-SEARCH-NOT-SET '(#\SP #\TAB) START-LINE (1+ INDEX))
			    (LINE-LENGTH START-LINE)))
	    (IF (AND (EQ START-LINE END-LINE) (= INDEX (LINE-LENGTH START-LINE)))
		`(,TYPE NIL)
	      (FUNCALL (OR (HEADER-TYPE-ELEM-PARSE-FUNCTION ELEM) #'PARSE-NORMAL-HEADER)
		       TYPE START-LINE INDEX END-LINE))))
      `(LOSING-HEADERS (,(MAKE-INSTANCE 'HEADER-LINE-WITHOUT-COLON :LINE START-LINE))))))

(DEFUN PARSE-ONE-HEADER-INTERNAL (START-LINE START-INDEX END-LINE &AUX FLAG)
  (DECLARE (VALUES LINE INDEX FLAG))
  (LET ((*INTERVAL* (LINE-TOP-LEVEL-NODE END-LINE)))
    (COND ((NEQ START-LINE END-LINE)
	   (SETQ START-LINE (STRING-THIN (STRING-INTERVAL (CREATE-BP START-LINE START-INDEX)
							  (END-OF-LINE END-LINE) T)
					 :REMOVE-BITS T)
		 START-INDEX 0
		 FLAG T))
	  ((STRING-FAT-P START-LINE)
	   (SETQ START-LINE (STRING-THIN (SUBSTRING START-LINE START-INDEX)
					 :REMOVE-BITS T)
		 START-INDEX 0
		 FLAG T))))
  (VALUES START-LINE START-INDEX FLAG))

(DEFUN PARSE-ONE-FAT-HEADER-INTERNAL (START-LINE START-INDEX END-LINE &AUX FLAG)
  (DECLARE (VALUES LINE INDEX FLAG))
  (LET ((*INTERVAL* (LINE-TOP-LEVEL-NODE END-LINE)))
    (WHEN (NEQ START-LINE END-LINE)
      (SETQ START-LINE (STRING-INTERVAL (CREATE-BP START-LINE START-INDEX)
					(END-OF-LINE END-LINE) T)
	    START-INDEX 0
	    FLAG T)))
  (VALUES START-LINE START-INDEX FLAG))

(DEFUN PARSE-NORMAL-HEADER (TYPE START-LINE START-INDEX END-LINE &AUX FLAG)
  (MULTIPLE-VALUE (START-LINE START-INDEX FLAG)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE ,(IF FLAG START-LINE (SUBSTRING START-LINE START-INDEX))))

(DEFUN PARSE-FAT-STRING-HEADER (TYPE START-LINE START-INDEX END-LINE &AUX FLAG)
  (MULTIPLE-VALUE (START-LINE START-INDEX FLAG)
    (PARSE-ONE-FAT-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE ,(IF FLAG START-LINE (SUBSTRING START-LINE START-INDEX))))

(DEFUN PARSE-ADDRESS-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (LET ((*INTERVAL* (LINE-TOP-LEVEL-NODE END-LINE)))
    (PARSING-HEADERS (PARSE-ERROR)
      (LIST TYPE
	    (PARSE-ADDRESSES-INTERVAL (CREATE-BP START-LINE START-INDEX)
				      (END-OF-LINE END-LINE)
				      T)))))

(DEFUN PARSE-DATE-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (PARSING-HEADERS (TIME:PARSE-ERROR)
    (LIST TYPE
	  (PARSE-RFC822-DATE-TIME START-LINE START-INDEX))))

(DEFUN PARSE-FILE-LIST-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE
    ,(LOOP FOR PATH IN (PARSE-COMMA-SEPARATED START-LINE START-INDEX)
	   COLLECT
	     (CONDITION-CASE ()
		  (FS:MERGE-PATHNAMES PATH *ZMAIL-PATHNAME-DEFAULTS*)
		((SYS:UNKNOWN-HOST-NAME FS:PATHNAME-ERROR FS:INVALID-PATHNAME-SYNTAX)
		 (LET ((START (STRING-SEARCH-NOT-SET *WHITESPACE-CHARS* PATH)))
		   (IF START
		       (SUBSTRING PATH START)
		     "")))))))

(DEFCONST *COMMA-RETURN* (FORMAT NIL ",~%"))

(DEFUN PARSE-SINGLE-LINE-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE ,(PARSE-COMMA-SEPARATED START-LINE START-INDEX *COMMA-RETURN*)))

(DEFUN PARSE-REFERENCE-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (IF *HANDLE-REFERENCES-LITERALLY*
      `(,TYPE ,(PARSE-COMMA-SEPARATED START-LINE START-INDEX *COMMA-RETURN*))
      `(,TYPE ,(PARSE-COMMA-SEPARATED START-LINE START-INDEX *COMMA-RETURN*
				      #'PARSE-REFERENCE NIL T))))

(DEFUN PARSE-SINGLE-KEYWORD-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (LET* ((STRING (STRING-TRIM '(#\SPACE #\TAB) (SUBSTRING START-LINE START-INDEX)))
	 (KEYWORD (INTERN (STRING-UPCASE STRING) SI:PKG-KEYWORD-PACKAGE)))
    `(,TYPE ,KEYWORD)))

(DEFUN PARSE-COMMA-SEPARATED-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE ,(PARSE-COMMA-SEPARATED START-LINE START-INDEX)))

(DEFUN PARSE-COMMA-SEPARATED-KEYWORDS-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (LET ((KEYWORDS (PARSE-COMMA-SEPARATED START-LINE START-INDEX)))
    (LOOP FOR KEYWORD IN KEYWORDS
	  FOR SYMBOL = (INTERN (STRING-UPCASE KEYWORD) PKG-KEYWORD-PACKAGE)
	  FOR BUCKET = (ASSQ TYPE (GET SYMBOL 'KEYWORD-STRING))
	  UNLESS BUCKET
	    DO (SETQ BUCKET `(,TYPE ,KEYWORD))
	       (PUSH BUCKET (GET SYMBOL 'KEYWORD-STRING))
	  COLLECT SYMBOL INTO KEYWORD-LIST
	  FINALLY (RETURN `(,TYPE ,KEYWORD-LIST)))))
(DEFUN PARSE-LISP-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (PARSING-HEADERS (SYS:READ-ERROR)
    `(,TYPE
      ,(MULTIPLE-VALUE-BIND (START-LINE START-INDEX)
	   (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE)
	 (PARSE-LISP-EXPRESSIONS START-LINE START-INDEX)))))

(DEFUN PARSE-LISP-EXPRESSIONS (START-LINE START-INDEX)
  (LOOP WITH VAL
	WITH IDX = START-INDEX
	WITH EOF-FLAG = '(EOF)
	DO (MULTIPLE-VALUE (VAL IDX)
	     (SCL:WITH-STANDARD-IO-ENVIRONMENT
	       (CL:READ-FROM-STRING START-LINE NIL EOF-FLAG :START IDX)))
	UNTIL (EQ VAL EOF-FLAG)
	COLLECT VAL))
(DEFUN PARSE-CHARACTER-TYPE-MAPPINGS-HEADER (TYPE START-LINE START-INDEX END-LINE)
  `(,TYPE
    ,(PARSING-HEADERS (ERROR)
       (LET ((PARSE (PARSE-CHARACTER-STYLE-RELATED-HEADER START-LINE START-INDEX END-LINE)))
	 (LOOP FOR SPEC IN PARSE
	       FOR (INDEX . TYPE-DEFINITION) = SPEC
	       UNLESS (CL:TYPEP INDEX '(CL:INTEGER 0 *))
		 DO (FERROR "Illegal type index ~S in character type specification ~S."
			    INDEX SPEC)
	       DO (CONDITION-CASE (ERROR)
		       (PROGN
			 (SI:VALIDATE-CHARACTER-TYPE-DEFINITION TYPE-DEFINITION)
			 1;; Parse style to fully validate it as the above function doesn't.
0			 (SI:PARSE-CHARACTER-STYLE (THIRD TYPE-DEFINITION)))
		     (ERROR
		       (FERROR "Error in definition of character type ~D:~%~4T~~A~"
			       INDEX ERROR))))
	 PARSE))))
(DEFUN PARSE-DEFAULT-CHARACTER-STYLE-HEADER (TYPE START-LINE START-INDEX END-LINE)
  `(,TYPE
    ,(PARSING-HEADERS (ERROR)
       (LET ((PARSE (PARSE-CHARACTER-STYLE-RELATED-HEADER START-LINE START-INDEX END-LINE)))
	 (IF (> (LENGTH PARSE) 1)
	     (FERROR "Multiple specifications in default character style ~S." PARSE)
	   (LET ((STYLE (SI:PARSE-CHARACTER-STYLE (FIRST PARSE))))
	     (UNLESS (SI:STYLE-VALID-P STYLE NIL)
	       (FERROR "Default character style ~S does not specify family, face, and size."
		       (FIRST PARSE)))
	     STYLE))))))
(DEFUN PARSE-CHARACTER-STYLE-RELATED-HEADER (START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE-BIND (START-LINE START-INDEX)
      (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE)
    (CONDITION-BIND ((SYS:EXTERNAL-SYMBOL-NOT-FOUND
		       #'(LAMBDA (CONDITION) (SYS:PROCEED CONDITION :INTERNAL))))
      (PARSE-LISP-EXPRESSIONS START-LINE START-INDEX))))

(DEFUN PARSE-COMMA-SEPARATED (LINE &OPTIONAL (INDEX 0) (COMMA ",") (FUNCTION #'SUBSTRING)
					     (END NIL) (SPLICE-P NIL))
  (UNLESS END (SETQ END (STRING-LENGTH LINE)))
  (LET ((RESULT (LOOP WITH SIZE = (STRING-LENGTH COMMA)
		      FOR START-IDX = INDEX
				    THEN (OR (STRING-SEARCH-NOT-SET
					       '(#\SP #\TAB #\return #\line)
					       LINE
					       (+ END-IDX SIZE) END)
					     END)
		      AS END-IDX = (STRING-SEARCH COMMA LINE START-IDX END)
		      COLLECT (FUNCALL FUNCTION LINE START-IDX (OR END-IDX END))
		      UNTIL (NULL END-IDX))))
    (IF SPLICE-P (APPLY #'NCONC RESULT) RESULT)))

(DEFUN PROBABLE-ITS-HEADER-P (LINE &OPTIONAL (START 0) END)
  (DECLARE (VALUES DATE-START FROM-ADDRESSES))
  (UNLESS END
    (SETQ END (STRING-LENGTH LINE)))
  (LET ((COLON-IDX (STRING-SEARCH-CHAR #/: LINE START END)))
    1;; If there's a colon on the line, it must be part of the date and, therfore, it must
0    1;; be preceeded by at least one space which separates the date from the from "field".
0    (WHEN COLON-IDX
      (UNLESS (> COLON-IDX (OR (STRING-SEARCH-CHAR #\SP LINE START END) END))
	(RETURN-FROM PROBABLE-ITS-HEADER-P (VALUES NIL))))
    1;; The first user name must be no more than six characters --
0    1;;    No longer valid as it prevents us from recognizing LispM-generated ITS headers.
0    #+IGNORE
    (UNLESS (STRING-SEARCH-CHAR #/@ LINE START (MIN END 7))
      (RETURN-FROM PROBABLE-ITS-HEADER-P (VALUES NIL)))
    1;; We must be able to lexically analyze the line at least up to the colon found above.
0    (LET ((LEXEMES (CONDITION-CASE (.ERROR.)
			(RFC733-LEXER LINE START (OR COLON-IDX END))
		      (PARSE-ERROR .ERROR.))))
      (UNLESS (LISTP LEXEMES)
	(RETURN-FROM PROBABLE-ITS-HEADER-P (VALUES NIL)))
      1;; Try parsing the from "field" -- One or more simple addresses (i.e., Name@Host)
0      1;;    All but the last address may omit the @Host part.
0      (MACROLET ((LEXEME-TYPE (LEXEME) `(FIRST ,LEXEME))
		 (LEXEME-VALUE (LEXEME) `(SECOND ,LEXEME))
		 (LEXEME-START-BP (LEXEME) `(THIRD ,LEXEME))
		 (LEXEME-END-BP (LEXEME) `(FOURTH ,LEXEME)))
	(FLET ((I-OR-S (START-LEXEME END-LEXEME)
		 (IF *PRESERVE-ADDRESS-INTERVALS*
		     `(:INTERVAL (,(LEXEME-START-BP START-LEXEME)
				  ,(LEXEME-END-BP END-LEXEME)))
		   `(:ORIGINAL-STRING ,(STRING-INTERVAL (LEXEME-START-BP START-LEXEME)
							(LEXEME-END-BP END-LEXEME) T)))))
	  (LOOP NAMED PARSE-FROM-FIELD
		AS FIRST-LEXEME = (FIRST LEXEMES)
		UNLESS (EQ (LEXEME-TYPE FIRST-LEXEME) 'ATOM)
		  RETURN NIL
		AS NAME = (LEXEME-VALUE FIRST-LEXEME)
		AS LAST-LEXEME = NIL
		AS HOST = NIL
		AS INTERVAL-OR-STRING = NIL
		IF (MEMQ (LEXEME-TYPE (SECOND LEXEMES)) '(ATSIGN AT-ATOM))
		  1;; User name with a host.
0		  DO (LOOP WITH FIRST-HOST-LEXEME = (THIRD LEXEMES)
			   FOR (LAST-HOST-LEXEME DELIMITER-LEXEME) ON (REST2 LEXEMES) BY 'CDDR
			   UNTIL (OR (NULL DELIMITER-LEXEME)
				     (NEQ (LEXEME-TYPE DELIMITER-LEXEME) 'PERIOD))
			   UNLESS (EQ (LEXEME-TYPE LAST-HOST-LEXEME) 'ATOM)
			     DO (RETURN-FROM PARSE-FROM-FIELD (VALUES NIL))
			   FINALLY
			     (SETQ LAST-LEXEME LAST-HOST-LEXEME
				   HOST (CONDITION-CASE ()
					     (PARSE-DOMAIN-OR-HOST LINE
					       (BP-INDEX (LEXEME-START-BP FIRST-HOST-LEXEME))
					       (BP-INDEX (LEXEME-END-BP LAST-HOST-LEXEME)))
					   (DOMAIN-SYNTAX-PARSE-ERROR
					     (RETURN-FROM PARSE-FROM-FIELD (VALUES NIL))))
				   INTERVAL-OR-STRING (I-OR-S FIRST-LEXEME LAST-LEXEME)))
		ELSE
		  1;; User name without a host.
0		  DO (SETQ LAST-LEXEME FIRST-LEXEME
			   HOST NIL
			   INTERVAL-OR-STRING (I-OR-S FIRST-LEXEME FIRST-LEXEME))
		1;; Have another address -- Add it to the list and flush its lexemes.
0		COLLECT `(:NAME ,NAME ,@(WHEN HOST `(:HOST ,HOST)) ,@INTERVAL-OR-STRING)
		  INTO ADDRESSES
		DO (LOOP UNTIL (EQ LAST-LEXEME (POP LEXEMES)))
		1;; Check the next lexeme to decide whether or not to stop.
0		AS NEXT-LEXEME-TYPE = (LEXEME-TYPE (FIRST LEXEMES))
		DO (COND ((EQ NEXT-LEXEME-TYPE 'COMMA))
			 ((AND HOST (MEMQ NEXT-LEXEME-TYPE '(ATOM COMMENT)))
			  (RETURN (VALUES (BP-INDEX (LEXEME-START-BP (FIRST LEXEMES)))
					  ADDRESSES)))
			 (T
			  (RETURN NIL)))
		   (POP LEXEMES)))))))

;;; Parse an abbreviated ITS style header
(DEFUN PARSE-ITS-HEADER (LINE DATE-START END FROM-ADDRESSES &AUX LIST)
  (SETQ LIST `(:FROM ,FROM-ADDRESSES))
  (LET ((SENT-BY-END (+ DATE-START 9)))
    (AND (STRING-EQUAL "(Sent by " LINE 0 DATE-START 9 SENT-BY-END)
	 (LET ((BEFORE-AT-POS (STRING-SEARCH-CHAR #/@ LINE SENT-BY-END)))
	   (SETQ LIST `(,@LIST :SENDER ((,@(IF BEFORE-AT-POS
					       `(:NAME ,(SUBSTRING LINE SENT-BY-END
								   BEFORE-AT-POS)
						 :HOST ,(CONDITION-CASE ()
							     (PARSE-DOMAIN-OR-HOST
							       (SUBSTRING
								 LINE (1+ BEFORE-AT-POS)
								 (SETQ DATE-START
								       (STRING-SEARCH-CHAR
									 #/) LINE
									 BEFORE-AT-POS))))
							   (DOMAIN-SYNTAX-PARSE-ERROR
							     `(:SINGLE
								,(SUBSTRING LINE
									    (1+ BEFORE-AT-POS)
									    DATE-START)))))
					     `(:NAME ,(SUBSTRING
							LINE SENT-BY-END
							(SETQ DATE-START (STRING-SEARCH-CHAR
									   #/) LINE
									   SENT-BY-END)))))
					 ,@(IF *PRESERVE-ADDRESS-INTERVALS*
					       `(:INTERVAL ((,LINE ,SENT-BY-END)
							    (,LINE ,DATE-START)))
					     `(:ORIGINAL-STRING
						,(SUBSTRING LINE SENT-BY-END DATE-START))))))
		 DATE-START (1+ DATE-START)))))
  (LET ((RE (STRING-SEARCH "Re: " LINE DATE-START END)))
    (SETQ LIST (APPEND LIST
		       (PARSING-HEADERS (TIME:PARSE-ERROR)
			 (LIST ':DATE
			       (TIME:PARSE-UNIVERSAL-TIME LINE DATE-START RE
							  NIL NIL T NIL NIL NIL)))))
    (AND RE
	 (SETQ LIST `(,@LIST
		      :SUBJECT ,(STRING-TRIM '(#\SP) (NSUBSTRING LINE (+ RE 4) END))))))
  `(,@LIST ITS-HEADER-P T))

;;; Parse the head of a *MSG type message
(DEFUN PARSE-*MSG-START (START-LINE END-LINE)
  (DECLARE (VALUES STATUS START-LINE))
  (DO ((LINE START-LINE (LINE-NEXT LINE))
       (STATUS NIL))
      ((EQ LINE END-LINE)
       (VALUES STATUS LINE))
    (COND ((STRING-EQUAL-START LINE :MSG)
	   (SETQ STATUS (APPEND STATUS (LIST :*MSG
					     (DO ((I)
						  (J 4)
						  (LIST NIL (CONS (SUBSTRING LINE I J) LIST)))
						 (NIL)
					       (OR (AND J
							(SETQ I (STRING-SEARCH-NOT-CHAR
								  #\SP LINE J)))
						   (RETURN (NREVERSE LIST)))
					       (SETQ J (STRING-SEARCH-CHAR #\SP LINE I)))))))
	  ((STRING-EQUAL-START LINE :DISTRIB)
	   (SETQ STATUS (APPEND STATUS (LIST :DISTRIB
					     (DO ((I)
						  (J 8 (1+ J))
						  (LIST NIL))
						 (NIL)
					       (SETQ I (STRING-SEARCH-NOT-CHAR #\SP LINE J)
						     J (STRING-SEARCH-CHAR #/, LINE I))
					       (PUSH (SUBSTRING LINE I J) LIST)
					       (OR J (RETURN (NREVERSE LIST))))))))
	  ((STRING-EQUAL-START LINE :EXPIRES)
	   (SETQ STATUS (APPEND STATUS (PARSING-HEADERS (TIME:PARSE-ERROR)
					 (LIST :EXPIRES
					       (TIME:PARSE-UNIVERSAL-TIME
						 LINE 8 (LINE-LENGTH LINE)
						 NIL NIL T NIL NIL NIL))))))
	  (T
	   (RETURN (VALUES STATUS LINE))))))

(DEFFLAVOR BAD-FORMAT-COMSYS-FORWARDED-TO-FIELD (STRING) (ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT BAD-FORMAT-COMSYS-FORWARDED-TO-FIELD) (STREAM)
  (FORMAT STREAM "~S is not a properly formatted COMSYS Forwarded-To: field" STRING))

(DEFINE-HEADER-TYPE-TYPE :COMSYS-FORWARDED-TO (:HEADER)
  (:PARSE-FUNCTION PARSE-COMSYS-FORWARDED-TO-HEADER))

(DEFINE-HEADER-TYPE :FORWARDED-TO "Forwarded-to" :COMSYS-FORWARDED-TO)
(DEFINE-HEADER-TYPE :FORWARDED-TO-TO NIL :RECIPIENT)
(DEFINE-HEADER-TYPE :FORWARDED-TO-CC NIL :RECIPIENT)
(DEFINE-HEADER-TYPE :FORWARDED-TO-BY NIL :SENDER)
(DEFINE-HEADER-TYPE :FORWARDED-TO-DATE NIL :DATE)

(DEFUN PARSE-COMSYS-FORWARDED-TO-HEADER (IGNORE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (PARSING-HEADERS (BAD-FORMAT-COMSYS-FORWARDED-TO-FIELD PARSE-ERROR TIME:PARSE-ERROR)
    (LET (TO FROM DATE)
      (OR (AND (SETQ DATE (STRING-REVERSE-SEARCH " on " START-LINE))
	       (SETQ FROM (STRING-REVERSE-SEARCH " by " START-LINE DATE)))
	  (ERROR 'BAD-FORMAT-COMSYS-FORWARDED-TO-FIELD
		 ':STRING (SUBSTRING START-LINE START-INDEX)))
      (SETQ TO (PARSE-ADDRESSES START-LINE START-INDEX FROM)
	    FROM (PARSE-ADDRESSES START-LINE (+ FROM 4) DATE)
	    DATE (TIME:PARSE-UNIVERSAL-TIME START-LINE (+ DATE 4) NIL NIL NIL T NIL NIL NIL))
      `(:FORWARDED-TO (:TO ,TO :FROM ,FROM :DATE ,DATE)
	:FORWARDED-TO-TO ,TO
	:FORWARDED-TO-FROM ,FROM
	:FORWARDED-TO-DATE ,DATE))))

(DEFUN PARSE-ITS-MSG-HEADERS (START-BP &OPTIONAL END-BP IN-ORDER-P REFORMATTED)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (LET* ((REAL-END-LINE (BP-LINE END-BP))
	 (START-LINE (DO ((*INTERVAL* (LINE-TOP-LEVEL-NODE REAL-END-LINE))
			  (LINE (BP-LINE START-BP) (LINE-NEXT LINE)))
			 ((NOT (LINE-BLANK-P LINE))
			  LINE)
		       (WHEN (EQ LINE REAL-END-LINE)
			 (RETURN-FROM PARSE-ITS-MSG-HEADERS
			   (VALUES `(UNPARSEABLE ,(MAKE-CONDITION 'NULL-MSG))
				   (CREATE-BP REAL-END-LINE 0)))))))
    (MULTIPLE-VALUE-BIND (EARLY-HEADERS START-LINE)
	(IF (STRING-EQUAL-START START-LINE "MSG:")
	    (PARSE-*MSG-START START-LINE REAL-END-LINE)
	  (VALUES NIL START-LINE))
      (MULTIPLE-VALUE-BIND (DATE-START FROM-ADDRESSES)
	  (IF REFORMATTED (VALUES NIL NIL)
	    (PROBABLE-ITS-HEADER-P START-LINE))
	(IF (NULL DATE-START)
	    (MULTIPLE-VALUE-BIND (HEADERS STOP-BP)
		(PARSE-HEADERS-INTERVAL START-BP END-BP T T)
	      (VALUES (APPEND EARLY-HEADERS HEADERS) STOP-BP))
	  (LET ((ITS-HEADERS (PARSE-ITS-HEADER START-LINE DATE-START (LINE-LENGTH START-LINE)
					       FROM-ADDRESSES)))
	    (SETF (CL:GETF (LINE-CONTENTS-PLIST START-LINE) 'PARSED-HEADERS) ITS-HEADERS)
	    (LET* ((START-LINE (LINE-NEXT START-LINE))
		   (END-LINE (DO ((LINE START-LINE (LINE-NEXT LINE)))
				 ((OR (EQ LINE REAL-END-LINE)
				      (AND (NOT (STRING-EQUAL-START LINE "To: "))
					   (NOT (STRING-EQUAL-START LINE "cc: "))))
				  LINE)))
		   (ADDITIONAL-HEADERS
		     (UNLESS (EQ START-LINE END-LINE)
		       (PARSE-HEADERS-INTERVAL (CREATE-BP START-LINE 0)
					       (LET ((LINE (LINE-PREVIOUS END-LINE)))
						 (CREATE-BP LINE (LINE-LENGTH LINE)))
					       T))))
	      (VALUES (APPEND EARLY-HEADERS ITS-HEADERS ADDITIONAL-HEADERS)
		      (CREATE-BP END-LINE 0)))))))))

(DEFUN STRING-EQUAL-START (STRING PATTERN &OPTIONAL (START 0))
  (OR (STRINGP PATTERN)
      (SETQ PATTERN (STRING PATTERN)))
  (%STRING-EQUAL STRING START PATTERN 0 (ARRAY-ACTIVE-LENGTH PATTERN)))

(DEFPROP :ADDRESS-LIST
	 (PRINT-ADDRESS-LIST READ-ADDRESS-LIST NIL
	  NIL NIL "Click left to enter list of addresses from the keyboard.")
	 TV:CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN READ-ADDRESS-LIST (STREAM)
  (LET ((*PRESERVE-ADDRESS-INTERVALS* NIL))	;we'd end up flushing the :INTERVAL's, so...
    (PARSE-ADDRESSES (READLINE STREAM))))

(DEFUN PRINT-ADDRESS-LIST (ADDRESSES STREAM)
  (LOOP FOR ADDRESS IN ADDRESSES
	FOR FIRST = T THEN NIL
	WHEN (NOT FIRST)
	  DO (CL:WRITE-STRING ", " STREAM)
	DO (CL:WRITE-STRING (STRING-FROM-HEADER ADDRESS :SHORT) STREAM)))

;;; Reference parsing

;;; Parse the in-reply-to field.  This understands everything i could find in the minutes
;;; of HEADER-PEOPLE, which will serve as the network standard for now.
(DEFUN PARSE-REFERENCE (STRING &OPTIONAL (START 0) END)
 (UNLESS END (SETQ END (STRING-LENGTH STRING)))
 (NCONS	;; Turn a normal result into a list since caller expects a list.
        ;; To return more than one id, use (RETURN-FROM PARSE-REFERENCE list). -kmp 2-Oct-89
  (PARSING-HEADERS (PARSE-ERROR TIME:PARSE-ERROR)
    (UNLESS ( START END)
      ;;"<80265.32584.6980 @ Darcom-hq>"
      (IF (AND (CHAR-EQUAL (AREF STRING START) #/<) (CHAR-EQUAL (AREF STRING (1- END)) #/>))
	  `(:MESSAGE-ID ,(SUBSTRING STRING START END))
	(LET (DATE FROM FROM-OK TEM TEM1 TEM2 TEM3 MESSAGE-ID)
	  (COND ((NULL (SETQ START (STRING-SEARCH-NOT-SET *BLANKS* STRING START END))))
		;;"Your message of 21 Sep 1980 22:12 PDT"
		((STRING-EQUAL-START STRING "Your message of " START)
		 ;; RAND peculiarity
		 (WHEN (STRING-EQUAL STRING ")." (- END 2) 0 END)
		   (SETQ END (1- END)))
		 (SETQ DATE (PARSE-RFC822-DATE-TIME STRING (+ START 16.) END)
		       FROM-OK T))
		;;"Message of 12 Mar 81 at 1937 PST by Admin.MRC@SU-SCORE"
		;;"The message of 27 Apr 81 13:53-EDT from Daniel L. Weinreb <DLW at MIT-AI>"
		((AND (LOOP FOR STARTER IN '("Message of " "The message of " "Msg of")
			    THEREIS (WHEN (STRING-EQUAL-START STRING STARTER START)
				      (SETQ TEM1 (STRING-LENGTH STARTER))
				      T))
		      (LOOP FOR PREP IN '(" by " " from ")
			    THEREIS (WHEN (SETQ TEM (STRING-SEARCH PREP STRING START END))
				      (SETQ TEM2 (STRING-LENGTH PREP))
				      T)))
		 (SETQ DATE (PARSE-RFC822-DATE-TIME STRING (+ START TEM1) TEM)
		       FROM (PARSE-ADDRESSES STRING (+ TEM TEM2) END))
		 (WHEN (LISTP FROM)
		   (SETQ FROM-OK T
			 FROM (SOME-PLIST (CAR FROM) '(:NAME :HOST)))))
		;;"Earl A. Killian's message of 23 Mar 81 03:41-EST"
		((AND (SETQ TEM (STRING-SEARCH " message of " STRING START END))
		      ;;"Rick Gumpertz' message ..."
		      (SETQ TEM1 (STRING-REVERSE-SEARCH-CHAR #/' STRING TEM START)))
		 (LET ((DATE-START (+ TEM 12.)) TEM3)
		   (WHEN (AND
			   ;; Yankee Doodle's message of 04-Jul-76 <17760704.1@U.S.A>
			   (SETQ TEM2 (STRING-REVERSE-SEARCH-CHAR #/< STRING END DATE-START))
			   (SETQ TEM3
				 (STRING-REVERSE-SEARCH-NOT-SET *BLANKS* STRING END TEM2))
			   (CHAR= (AREF STRING TEM3) #/>))
		     (SETQ MESSAGE-ID (SUBSTRING STRING TEM2 (+ TEM3 1)))
		     (SETQ END TEM2))
		   (SETQ DATE (PARSE-RFC822-DATE-TIME STRING DATE-START END)
			 FROM (PARSE-ADDRESSES STRING START TEM1))
		   (WHEN (LISTP FROM)
		     (SETQ FROM-OK T
			   FROM (CAR FROM))
		     (IF (NULL (GET (LOCF FROM) :HOST))
			 (SETQ FROM `(:PERSONAL-NAME ,(GET (LOCF FROM) :NAME)))
			 (SETQ FROM (SOME-PLIST FROM '(:NAME :HOST)))))))
		;;"Message from Richard M. Stallman <RMS at MIT-AI> of 28-May-81 2333-EDT"
		((AND (STRING-EQUAL-START STRING "Message from " START)
		      (SETQ TEM (STRING-REVERSE-SEARCH " of " STRING END START)))
		 (SETQ FROM (PARSE-ADDRESSES STRING (+ 13. START) TEM)
		       DATE (PARSE-RFC822-DATE-TIME STRING (+ TEM 4) END))
		 (WHEN (LISTP FROM)
		   (SETQ FROM-OK T
			 FROM (SOME-PLIST (CAR FROM) '(:NAME :HOST)))))
		;;<19910122191418.4.KMP@BOBOLINK.SCRC.Symbolics.COM>; from "Kent M Pitman" at Jan 22, 91 2:14 pm
		;;<9101260746.AA12013@kolyma> "jonl@lucid.com"
		((AND (CHAR-EQUAL (AREF STRING START) #/<)
		      (SETQ TEM (STRING-SEARCH ">" STRING START))
		      (OR (AND (SETQ TEM1 (STRING-SEARCH " from " STRING TEM))
			       (SETQ TEM2 (STRING-REVERSE-SEARCH " at " STRING END TEM1))
			       (SETQ TEM3 ':FROM-AND-DATE))
			  (AND (SETQ TEM1 (STRING-SEARCH "/"" STRING TEM))
			       (SETQ TEM2 (STRING-REVERSE-SEARCH "/"" STRING END TEM1))
			       (SETQ TEM3 ':FROM-ONLY))))
		 (SETQ MESSAGE-ID (SUBSTRING STRING START (1+ TEM)))
		 (SELECT TEM3
		   (:FROM-AND-DATE
		    (SETQ FROM (PARSE-ADDRESSES STRING (+ TEM1 6) TEM2)
			  DATE (PARSE-RFC822-DATE-TIME STRING (+ TEM2 4) END)))
		   (:FROM-ONLY
		    (SETQ FROM (PARSE-ADDRESSES STRING (1+ TEM1) TEM2)
			  DATE 0)))
		 (WHEN (LISTP FROM)
		   (SETQ FROM-OK T
			 FROM (SOME-PLIST (CAR FROM) '(:NAME :HOST)))))
		;; Anything else?
		)
	  (LET ((FROM-AND-DATE (WHEN (AND FROM-OK (NUMBERP DATE))
				 `(:DATE ,DATE . ,(AND FROM `(:FROM ,FROM))))))
	    (COND ((AND FROM-AND-DATE MESSAGE-ID)
		   (RETURN-FROM PARSE-REFERENCE
		     (LIST `(:MESSAGE-ID ,MESSAGE-ID) FROM-AND-DATE)))
		  (MESSAGE-ID
		   `(:MESSAGE-ID ,MESSAGE-ID))
		  (FROM-AND-DATE)
		  (T (RETURN-FROM PARSE-REFERENCE NIL))))))))))

#||

(DEFUN TEST-PARSE-REFERENCE (&OPTIONAL SHOW-RESULTS)
  (LET ((PROBLEMS '()))
    (DOLIST (ENTRY
	      '(;; Bogus stuff
		("<foo"
		 ;; Can't find anything to help us get a foothold on parsing.
		 )
		("The message of bad date from Someone"
		 ;; Format recognized but bad component
		 (ZWEI:LOSING-HEADERS))
		;; Original test cases, based on comments in the code...
		("<80265.32584.6980 @ Darcom-hq>"
		 (:MESSAGE-ID "<80265.32584.6980 @ Darcom-hq>"))
		("Your message of 21 Sep 1980 22:12 PDT"
		 (:DATE 2547436320.))
		("Your message of 21 Sep 1980 22:12 PDT (something)."
		 (:DATE 2547436320.))
		("Message of 12 Mar 81 at 1937 PST by Admin.MRC@SU-SCORE"
		 (:DATE 2562291420. :FROM (:NAME "Admin.MRC" :HOST (:SINGLE "SU-SCORE"))))
		("The message of 27 Apr 81 13:53-EDT from Daniel L. Weinreb <DLW at MIT-AI>"
		 (:DATE 2566230780. :FROM (:NAME "DLW" :HOST (:SINGLE "MIT-AI"))))
		("Earl A. Killian's message of 23 Mar 81 03:41-EST"
		 (:DATE 2563173660. :FROM (:PERSONAL-NAME "Earl A. Killian")))
		("Rick Gumpertz' message of 23 Mar 81 03:41-EST"
		 (:DATE 2563173660. :FROM (:PERSONAL-NAME "Rick Gumpertz")))
		("Message from Richard M. Stallman <RMS at MIT-AI> of 28-May-81 2333-EDT"
		 (:DATE 2568943980. :FROM (:NAME "RMS" :HOST (:SINGLE "MIT-AI"))))
		;; Test cases added when listification of result was done...
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT"
		 ;; Control situation #1 -- Normal case for this branch of the code.
		 (:DATE 2827159020. :FROM (:PERSONAL-NAME "Kent M Pitman")))
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT hi"
		 ;; Control situation #2 -- Garbage following time.
		 (ZWEI:LOSING-HEADERS))
		("<foo>"
		 ;; Control situation #3 -- Just a message id
		 (:MESSAGE-ID "<foo>"))
		("<>"
		 ;; Control situation #4 -- Null message id
		 (:MESSAGE-ID "<>"))
		("<foo> "
		 ;; Control situation #5 -- Extra whitespace after message id.
		 ;; is this a bug, or does the caller of PARSE-REFERENCE
		 ;; just make sure this never ends up happening?
		 )
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT <foo>"
		 ;; Goal situation: This is what we wanted to fix.
		 ;; Behavior consistent with control situation #3 above.
		 (:MESSAGE-ID "<foo>")
		 (:DATE 2827159020. :FROM (:PERSONAL-NAME "Kent M Pitman")))
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT <>"
		 ;; Test boundary condition -- empty message id.
		 ;; Behavior consistent with control situation #4 above.
		 (:MESSAGE-ID "<>")
		 (:DATE 2827159020. :FROM (:PERSONAL-NAME "Kent M Pitman")))
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT <"
		 ;; Stray "<", which we're keying on to notice the message id.
		 ;; Behavior consistent with control situation #2 above.
		 (ZWEI:LOSING-HEADERS))
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT >"
		 ;; Stray ">", which we're keying on to notice the message id.
		 ;; Behavior consistent with control situation #2 above.
		 (ZWEI:LOSING-HEADERS))
		("Kent M Pitman's message of Thu, 3 Aug 89 13:57 EDT  <foo>      "
		 ;; Extra whitespace after message ID
		 ;; This is at least as good as control situation #5 above!
		 (:MESSAGE-ID "<foo>")
		 (:DATE 2827159020. :FROM (:PERSONAL-NAME "Kent M Pitman")))
		("KMP@STONY-BROOK's message of Thu, 3 Aug 89 13:57 EDT        "
		 ;; Control situation #6: Hosted user name.
		 (:DATE 2827159020. :FROM
			(:NAME "KMP" :HOST (:OBJECT #.(NET:PARSE-HOST "STONY-BROOK")))))
		("Kent M Pitman <KMP@STONY-BROOK>'s message of Thu, 3 Aug 89 13:57 EDT"
		 ;; Angle brackets in hosted user name.
		 ;; Consistent with control situation #6 above.  Note that these angle brackets
		 ;; are not mistaken for a message id.
		 (:DATE 2827159020. :FROM
			(:NAME "KMP" :HOST (:OBJECT #.(NET:PARSE-HOST "STONY-BROOK")))))
		("Kent M Pitman <KMP@STONY-BROOK>'s message of Thu, 3 Aug 89 13:57 EDT <foo>"
		 ;; Angle brackets in hosted user name.
		 ;; Consistent with goal situation above.
		 (:MESSAGE-ID "<foo>")
		 (:DATE 2827159020. :FROM
			(:NAME "KMP" :HOST (:OBJECT #.(NET:PARSE-HOST "STONY-BROOK")))))
		("Gregor.pa@Xerox.COM's message of Sun, 4 Jun 89 12:13 PDT <19890604191319.8.GREGOR@SPIFF.parc.xerox.com>"
		 ;; An old bug report.
		 (:MESSAGE-ID "<19890604191319.8.GREGOR@SPIFF.parc.xerox.com>")
		 (:DATE 2821979580. :FROM (:NAME "Gregor.pa" :HOST (:DOMAIN "Xerox" "COM"))))
		("<19910122191418.4.KMP@BOBOLINK.SCRC.Symbolics.COM>; from /"Kent M Pitman/" at Jan 22, 91 2:14 pm"
		 (:MESSAGE-ID "<19910122191418.4.KMP@BOBOLINK.SCRC.Symbolics.COM>")
		 (:DATE 25321606570 :FROM (:NAME "Kent M Pitman" :HOST NIL)))
		("<19910122191418.4.KMP@BOBOLINK.SCRC.Symbolics.COM>; from /"Kent M Pitman/" at Jan 22, 91 2:14 pm ?"
		 ;; Garbage after the date -- Consistent with control situation #2 above.
		 (ZWEI:LOSING-HEADERS))
		("<9101260746.AA12013@kolyma> /"jonl@lucid.com/""
		 (:MESSAGE-ID "<9101260746.AA12013@kolyma>")
		 (:DATE 0 :FROM (:NAME "jonl" :HOST (:DOMAIN "lucid" "com"))))
		("<9101260746.AA12013@kolyma> /"jonl@lucid.com@/""
		 ;; Invalid address inside the quotes.
		 (ZWEI:LOSING-HEADERS))
		))
      (LET* ((INPUT (CAR ENTRY))
	     (RESULT (ZWEI:PARSE-REFERENCE INPUT))
	     (CORRECT (CDR ENTRY)))
	(WHEN SHOW-RESULTS
	  (FORMAT T "~&Input:    ~A~%Result:   ~S~%Expected: ~S~%" INPUT RESULT CORRECT))
	(UNLESS (AND (= (LENGTH RESULT) (LENGTH CORRECT))
		     (CL:EVERY #'(LAMBDA (X Y)
				   (OR
				     ;; If we're comparing errors, don't be too picky...
				     (AND (EQ (CAR X) 'ZWEI:LOSING-HEADERS)
					  (EQ (CAR Y) 'ZWEI:LOSING-HEADERS))
				     (EQUAL X Y)))
			       RESULT CORRECT))
	  (PUSH (LIST INPUT :RESULT RESULT :EXPECTED CORRECT) PROBLEMS))))
    (IF (NOT PROBLEMS) :WIN
	`(:LOSE ,@(NREVERSE PROBLEMS)))))

||#


;;; Figure out what message if any was yanked into the body of this one as a reply.
(DEFUN GET-MSG-TEXT-REFERENCES (MSG &AUX START-BP END-BP REFLIST)
  (MULTIPLE-VALUE (START-BP END-BP)
    (MSG-BODY-INTERVAL MSG))
  (GET-INTERVAL START-BP END-BP T)
  (DO ((LINE (BP-LINE START-BP) (LINE-NEXT LINE))
       (END-LINE (BP-LINE END-BP))
       (LEN) (TEM) (TEM1) (FROM) (DATE))
      ((EQ LINE END-LINE))
    (CONDITION-CASE (IGNORE)
	(COND ((NOT (PLUSP (SETQ LEN (LINE-LENGTH LINE)))))
	      ((MEMQ (AREF LINE 0) *BLANKS*)	;Possibly indented line
	       (LET ((START-IDX (STRING-SEARCH-NOT-SET *BLANKS* LINE)))
		 (COND ((NULL START-IDX) NIL)	;Lines entirely of blanks are not ITS headers
		       ((MULTIPLE-VALUE (TEM TEM1)
			  (PROBABLE-ITS-HEADER-P LINE START-IDX))
			(SETQ TEM (PARSE-ITS-HEADER LINE TEM LEN TEM1))
			(COND ((SETQ TEM (SOME-PLIST TEM '(:DATE :FROM)))
			       (LET* ((PLIST (LOCF TEM))
				      (TEM1 (GET PLIST ':FROM)))
				 (AND TEM1
				      (PUTPROP PLIST (SOME-PLIST (CAR TEM1) '(:NAME :HOST))
					       ':FROM)))
			       (PUSH TEM REFLIST))))
		       ((AND (SETQ TEM (STRING-SEARCH-CHAR #/: LINE START-IDX LEN))
			     (STRING-EQUAL LINE "DATE" START-IDX 0 TEM))
			(SETQ DATE (PARSE-RFC822-DATE-TIME LINE (1+ TEM) LEN))
			(LET* ((LINE (LINE-NEXT LINE))
			       (LEN (LINE-LENGTH LINE)))
			  (AND (EQ START-IDX (STRING-SEARCH-NOT-SET *BLANKS* LINE))
			       (SETQ TEM (STRING-SEARCH-CHAR #/: LINE START-IDX LEN))
			       (STRING-EQUAL LINE "FROM" START-IDX 0 TEM)
			       (LISTP (SETQ TEM (PARSE-ADDRESSES LINE (1+ TEM) LEN)))
			       (PUSH
				 `(:DATE ,DATE :FROM ,(SOME-PLIST (CAR TEM) '(:NAME :HOST)))
				 REFLIST)))))))
	      ((COND ;; Good old MSG
		 ((AND (STRING-EQUAL-START LINE "In response to the message sent ")
		       (SETQ TEM (STRING-SEARCH " from " LINE)))
		  (SETQ DATE (PARSE-RFC822-DATE-TIME LINE 32. TEM)
			FROM (PARSE-ADDRESSES LINE (+ TEM 6)))
		  T)
		 ;; In reply to in body of message from some weird mail system in NLS.
		 ((AND (STRING-EQUAL-START LINE "In reply to the message from ")
		       (SETQ TEM (STRING-REVERSE-SEARCH-CHAR #/, LINE LEN)))
		  (SETQ FROM (PARSE-ADDRESSES LINE 29. TEM)
			DATE (PARSE-RFC822-DATE-TIME LINE (1+ TEM)))
		  T)
		 (T NIL))
	       (COND ((AND (LISTP FROM) (NUMBERP DATE))
		      (PUSH `(:DATE ,DATE :FROM ,(SOME-PLIST (FIRST FROM) '(:NAME :HOST)))
			    REFLIST)))))
      ((PARSE-ERROR TIME:PARSE-ERROR) NIL)))
  (NREVERSE REFLIST))

(DEFUN PARSE-PRIORITY-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (PARSING-HEADERS (FERROR)
    (LET* ((STRING (STRING-TRIM '(#\Space #\Tab) (SUBSTRING START-LINE START-INDEX)))
	   (KEYWORD (INTERN (STRING-UPCASE STRING) SI:PKG-KEYWORD-PACKAGE)))
      (UNLESS (ASSQ KEYWORD *PRIORITY-NAMES*)
	(FERROR "~S is not a known priority name." STRING))
      `(,TYPE ,KEYWORD))))

(DEFUN PARSE-INTEGER-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (PARSING-HEADERS (SYS:READ-ERROR FERROR)
    (LET ((NUMBER (PARSE-NUMBER START-LINE START-INDEX NIL 10. T)))
      (UNLESS NUMBER
	(FERROR "~S is not an integer." (SUBSTRING START-LINE START-INDEX)))
      `(,TYPE ,NUMBER))))

(DEFUN PARSE-NUMBER-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  (PARSING-HEADERS (SYS:READ-ERROR FERROR)
    (LET ((NUMBER (SCL:WITH-STANDARD-IO-ENVIRONMENT
		    (READ-FROM-STRING START-LINE NIL START-INDEX))))
      (UNLESS (NUMBERP NUMBER)
	(FERROR "~S is not a number." NUMBER))
      `(,TYPE ,NUMBER))))


;;; Parse a received header into a property list.
(DEFVAR *RECEIVED-MAGIC-KEYWORDS*
  '((:FROM . :HOST)
    (:BY . :HOST)
    (:VIA . :KEYWORD)
    (:WITH . :KEYWORD)
    (:ID . :STRING)
    (:FOR . :ADDRESSES)))

(DEFUN PARSE-RECEIVED-HEADER (TYPE START-LINE START-INDEX END-LINE)
  (MULTIPLE-VALUE (START-LINE START-INDEX)
    (PARSE-ONE-HEADER-INTERNAL START-LINE START-INDEX END-LINE))
  `(,TYPE (,(PARSE-COMMA-SEPARATED START-LINE START-INDEX "
"))))

(DEFUN REALLY-PARSE-RECEIVED-HEADERS (VALUES)
  (LOOP FOR VALUE IN VALUES
	COLLECT
	  (SYS:WITH-STACK-ARRAY (REAL-STRING
				  (+ (1- (LENGTH VALUE))
				     (CL:REDUCE #'+ (CL:MAP 'LIST #'STRING-LENGTH VALUE)))
				  :TYPE 'ART-STRING :FILL-POINTER 0)
	    (LOOP FOR STRING IN VALUE
		  FOR FIRST-TIME = T THEN NIL
		  UNLESS FIRST-TIME
		    DO (ARRAY-PUSH REAL-STRING #\Space)
		  DO (SYS:WITH-STACK-ARRAY (NEXT-PART
					     (STRING-LENGTH STRING)
					     :TYPE 'ART-STRING
					     :DISPLACED-TO REAL-STRING
					     :DISPLACED-INDEX-OFFSET (FILL-POINTER REAL-STRING)
					     )
		       (COPY-ARRAY-CONTENTS STRING NEXT-PART))
		     (INCF (FILL-POINTER REAL-STRING) (STRING-LENGTH STRING)))
	    (REALLY-PARSE-ONE-RECEIVED-HEADER REAL-STRING))))

(DEFUN REALLY-PARSE-ONE-RECEIVED-HEADER (STRING)
  (LET ((START 0)
	(END (STRING-LENGTH STRING))
	PLIST)
    (LET ((SEMI (STRING-REVERSE-SEARCH-CHAR #/; STRING END START)))
      (WHEN SEMI
	(PUTPROP (LOCF PLIST) (PARSING-HEADERS (TIME:PARSE-ERROR)
				(PARSE-RFC822-DATE-TIME STRING (1+ SEMI) END))
			      :DATE)
	(SETQ END SEMI)))
    (WITH-STACK-LIST* (WHITESPACE-CHARS #/( *WHITESPACE-CHARS*)
      (LABELS ((SKIP-COMMENT (START)
		 (LET ((DEPTH 1))
		   (LOOP WHILE (< (1+ START) END)
			 DOING
		     (LET ((NEXT-CHAR (STRING-SEARCH-SET '(#/( #/) #/\) STRING (1+ START) END))
			   )
		       (UNLESS NEXT-CHAR
			 (RETURN END))
		       (SELECTOR (AREF STRING NEXT-CHAR) CHAR-EQUAL
			 (#/(
			  (INCF DEPTH)
			  (SETQ START NEXT-CHAR))
			 (#/)
			  (DECF DEPTH)
			  (IF (ZEROP DEPTH)
			      (RETURN (1+ NEXT-CHAR))
			      (SETQ START NEXT-CHAR)))
			 (#/\
			  (SETQ START (1+ NEXT-CHAR))))))))
	       (SKIP (PLACE)
		 (COND ((AND (< PLACE END) (CHAR-EQUAL (AREF STRING PLACE) #/())
			(SKIP-COMMENT PLACE))
		       ((STRING-SEARCH-NOT-SET *WHITESPACE-CHARS* STRING PLACE END))
		       (T END)))
	       (SKIP-WHITESPACE (START)
		 (LOOP FOR PLACE = (SKIP START) THEN (SKIP PLACE)
		       WHEN (OR ( PLACE END)
				(NOT (MEM #'CHAR-EQUAL (AREF STRING PLACE) WHITESPACE-CHARS)))
			 RETURN PLACE)))
	(LOOP DOING
	  (LET ((SPACE (STRING-SEARCH-SET WHITESPACE-CHARS STRING START END)))
	    (WHEN (NULL SPACE)
	      (RETURN))
	    (LET* ((AFTER-SPACE (SKIP-WHITESPACE SPACE))
		   (NEXT-SPACE (OR (STRING-SEARCH-SET WHITESPACE-CHARS STRING AFTER-SPACE END)
				   END)))
	      (LOOP FOR (KEYWORD . TYPE) IN *RECEIVED-MAGIC-KEYWORDS*
		    DO (WHEN (STRING-EQUAL KEYWORD STRING 0 START NIL SPACE)
			 (PUTPROP (LOCF PLIST)
				  (PARSING-HEADERS (PARSE-ERROR)
				    (SELECTQ TYPE
				      (:HOST
				       (PARSE-DOMAIN-OR-HOST STRING AFTER-SPACE NEXT-SPACE))
				      (:KEYWORD
				       (INTERN (STRING-UPCASE
						 (SUBSTRING STRING AFTER-SPACE NEXT-SPACE))
					       PKG-KEYWORD-PACKAGE))
				      (:STRING
				       (SUBSTRING STRING AFTER-SPACE NEXT-SPACE))
				      (:ADDRESSES
				       (PARSE-ADDRESSES STRING AFTER-SPACE NEXT-SPACE))))
				  KEYWORD)))
	      (SETQ START (SKIP-WHITESPACE NEXT-SPACE)))))))
    PLIST))
