;;; Lisp Machine mail reader -*- Base: 8; Mode: LISP; Package: ZWEI -*- 
;;; Template routines
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;;; Basics

;;; This associates keywords with flavor names, for the :TYPE option
(DEFVAR *TEMPLATE-TYPE-ALIST* NIL)

(DEFMACRO DEFINE-TEMPLATE-TYPE (FLAVOR-NAME TYPE-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS
				&BODY OPTIONS)
  `(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,FLAVOR-NAME DEFFLAVOR))
     (DEFFLAVOR ,FLAVOR-NAME ,INSTANCE-VARIABLES ,COMPONENT-FLAVORS . ,OPTIONS)
     (PUSH '(,TYPE-NAME ,FLAVOR-NAME) *TEMPLATE-TYPE-ALIST*)
     (DEFMETHOD (:TYPE ,FLAVOR-NAME) () ',TYPE-NAME)))

(DEFPROP DEFINE-TEMPLATE-TYPE DEFFLAVOR DEFINITION-FUNCTION-SPEC-TYPE)

;;; This is the base flavor.
(DEFFLAVOR TEMPLATE
	(NAME
	 (READ-ONLY NIL)
	 MENU-NAME
	 (MENU-FONT NIL)
	 (DOCUMENTATION "")
	 (COMMAND-TYPES NIL)
	 (INCLUDED-BY-TEMPLATE-TYPES NIL)
	 EXPANSION)
	()
  (:REQUIRED-METHODS :TYPE)
  (:METHOD-COMBINATION :DEFTEMPLATE-KEYWORD :CASE
                       :EXPANSION-KEYWORD :CASE)
  (:INITABLE-INSTANCE-VARIABLES NAME)
  (:GETTABLE-INSTANCE-VARIABLES NAME MENU-NAME MENU-FONT DOCUMENTATION)
  (:INIT-KEYWORDS :OPTIONS))

(DEFMETHOD (:PRINT-SELF TEMPLATE) (STREAM &REST IGNORE)
  (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP :NO-POINTER)
    (PRINC NAME STREAM)))

(DEFUN FIND-TEMPLATE (NAME &OPTIONAL NO-ERROR-P)
  (IF (TYPEP NAME 'TEMPLATE) NAME
      (LOOP FOR TEMPLATE IN *TEMPLATES*
	    WHEN (EQ NAME (SEND TEMPLATE ':NAME))
	    RETURN TEMPLATE
	    FINALLY (OR NO-ERROR-P (FERROR "No template named ~S found" NAME)))))

(DEFMACRO DEFTEMPLATE (NAME &BODY OPTIONS)
  `(DEFTEMPLATE-1 ',NAME ',(COPYLIST OPTIONS)))

(DEFPROP DEFTEMPLATE "Template" SI:DEFINITION-TYPE-NAME)

(DEFUN DEFTEMPLATE-1 (NAME OPTIONS)
  (LET ((TYPE (OR (CADR (ASSQ ':TYPE OPTIONS))
		  (FERROR "Must specify the type for template ~S" NAME))))
    (COND (;; Always record, warn only if really not allowed to  redefine.
	   (LET-IF (NOT (ASSQ ':READ-ONLY OPTIONS)) ((INHIBIT-FDEFINE-WARNINGS T))
	     (SI:RECORD-SOURCE-FILE-NAME NAME 'DEFTEMPLATE))
	   (LET ((OLD (FIND-TEMPLATE NAME T)))
	     ;; This is REMQ so that we can keep a cache of menu alists for template choosing.
	     (AND OLD (SETQ *TEMPLATES* (REMQ OLD *TEMPLATES*))))
	   (SETQ TYPE (OR (CADR (ASSQ TYPE *TEMPLATE-TYPE-ALIST*))
			  (FERROR "Unknown template type ~S for ~S" TYPE NAME)))
	   (PUSH (MAKE-INSTANCE TYPE ':NAME NAME ':OPTIONS OPTIONS) *TEMPLATES*)
	   (UPDATE-COMMAND-DOCUMENTATION-ASSOCIATED-WITH-OPTION NAME)))))

(DEFMETHOD (:INIT TEMPLATE) (PLIST)
  (LOOP FOR OPTION IN (GET PLIST ':OPTIONS)
	WITH DEFINITION-TIME-KEYWORDS = (SEND SELF ':DEFTEMPLATE-KEYWORD ':WHICH-OPERATIONS)
	WHEN (MEMQ (CAR OPTION) DEFINITION-TIME-KEYWORDS)
	DO (LEXPR-SEND SELF ':DEFTEMPLATE-KEYWORD OPTION)
	ELSE COLLECT OPTION INTO EXPANSION-TIME-OPTIONS
	FINALLY (SETQ EXPANSION EXPANSION-TIME-OPTIONS))
  (AND (NOT (VARIABLE-BOUNDP MENU-NAME))
       (SETQ MENU-NAME (STRING NAME))))

;;; This is a dummy, since type has to be known before instantiation
(DEFMETHOD (:DEFTEMPLATE-KEYWORD TEMPLATE :TYPE) (IGNORE) )

(DEFMETHOD (:DEFTEMPLATE-KEYWORD TEMPLATE :DOCUMENTATION) (DOC)
  (SETQ DOCUMENTATION DOC))

(DEFMETHOD (:DEFTEMPLATE-KEYWORD TEMPLATE :NAME) (NAM &OPTIONAL FONT)
  (SETQ MENU-NAME NAM)
  (AND FONT (SETQ MENU-FONT FONT)))

(DEFMETHOD (:DEFTEMPLATE-KEYWORD TEMPLATE :READ-ONLY) ()
  (SETQ READ-ONLY T))

(DEFMETHOD (:DEFTEMPLATE-KEYWORD TEMPLATE :AVAILABLE-FOR-COMMANDS) (&REST COM-TYPES)
  (SETQ COMMAND-TYPES (COPYLIST COM-TYPES)))

(DEFMETHOD (:DEFTEMPLATE-KEYWORD TEMPLATE :AVAILABLE-FOR-TEMPLATES) (&REST TEM-TYPES)
  (SETQ INCLUDED-BY-TEMPLATE-TYPES (COPYLIST TEM-TYPES)))

;;; This is the main workhorse for expanding a template at composition time
;;; ARG is somewhat type dependent.  E.g. for reply templates it is a list of
;;; messages being replied to.
(DEFUN EXPAND-TEMPLATE (TEMPLATE-NAME &REST PLIST)
  (SETQ PLIST (COPYLIST PLIST))
  (SEND (FIND-TEMPLATE TEMPLATE-NAME) ':EXPAND (LOCF PLIST))
  PLIST)

(DEFUN FUNCALL-TEMPLATE-EXPANSION (TEMPLATE-EXPANSION FUNCTION &REST ARGS &AUX VARS VALS)
  (SETF (LIST VARS VALS) (GET (LOCF TEMPLATE-EXPANSION) ':SPECIAL-BINDINGS))
  (PROGV VARS VALS
    (APPLY FUNCTION ARGS)))

(DEFMETHOD (:EXPAND TEMPLATE) (PLIST)
  (LOOP FOR (KEY . OPTIONS) IN EXPANSION
	DO (LEXPR-SEND SELF ':EXPANSION-KEYWORD KEY PLIST OPTIONS)))

(DEFMETHOD (:EXPANSION-KEYWORD TEMPLATE :TEMPLATE) (PLIST TEMPLATE-NAME)
  "Include the expansion of another template in this expansion."
  (SEND (FIND-TEMPLATE TEMPLATE-NAME) ':EXPAND PLIST))

(DEFMETHOD (:EXPANSION-KEYWORD TEMPLATE :IF) (PLIST TEST &REST BODY)
  (DECLARE (SPECIAL PLIST))		;For EVAL
  (LET ((ELSE (MEMQ ':ELSE BODY))
	START END)
    (IF (EVAL TEST) (SETQ START BODY END ELSE) (SETQ START (CDR ELSE) END NIL))
    (DO ((L START (CDR L))) ((EQ L END))
      (LEXPR-SEND SELF ':EXPANSION-KEYWORD (CAAR L) PLIST (CDAR L)))))

(DEFMETHOD (:EXPANSION-KEYWORD TEMPLATE :BIND) (PLIST VALUE VARIABLE)
  (LET ((ELEM (GET PLIST ':SPECIAL-BINDINGS)))
    (OR ELEM (PUTPROP PLIST (SETQ ELEM (LIST NIL NIL)) ':SPECIAL-BINDINGS))
    (PUSH VARIABLE (CAR ELEM))
    (PUSH VALUE (CADR ELEM))))

(DEFMETHOD (:EXPANSION-KEYWORD TEMPLATE :CHOOSE-VALUES) (PLIST
							       LABEL &REST BODY)
  (DECLARE (SPECIAL PLIST))
  (LOOP FOR (EXP-KEY (VALUE TYPE DOC . CHOOSE-ARGS) . EXP-ARGS) IN BODY
	AS EXP = `(,EXP-KEY ,(EVAL VALUE) . ,EXP-ARGS)
	COLLECT EXP INTO EXPANSIONS
	COLLECT `(,(LOCF (CADR EXP)) ,(EVAL DOC) ,TYPE . ,(MAPCAR #'EVAL CHOOSE-ARGS))
	  INTO CHOICES
	FINALLY (TV:CHOOSE-VARIABLE-VALUES
		  CHOICES ':LABEL LABEL
		  ':MARGIN-CHOICES '("Do It" ("Abort" (ABORT-CURRENT-COMMAND))))
		(LOOP FOR (EXP-KEY . EXP-ARGS) IN EXPANSIONS
		      DO (LEXPR-SEND SELF ':EXPANSION-KEYWORD EXP-KEY PLIST EXP-ARGS))))

(DEFMETHOD (:EXPANSION-KEYWORD TEMPLATE :PROPERTY) (PLIST INDICATOR VALUE)
  (PUTPROP PLIST VALUE INDICATOR))

(DEFMETHOD (:COMMAND-TYPEP TEMPLATE) (TYPE)
  (MEMQ TYPE COMMAND-TYPES))

(DEFVAR *TEMPLATE-COMMAND-ALIST-CACHE* NIL)

(DEFSTRUCT (TEMPLATE-ALIST-CACHE-ELEM :LIST* :CONC-NAME)
  COMMAND-TYPE
  TEMPLATES
  LAST-ITEM
  ALIST)

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Given a command type, return a menu alist of templates usable for that command.
0(DEFUN TEMPLATE-COMMAND-ALIST (COMMAND-TYPE)
  (LET ((CACHE (ASSQ COMMAND-TYPE *TEMPLATE-COMMAND-ALIST-CACHE*))
	COMMAND-ALIST)
    (IF (AND CACHE (EQ *TEMPLATES* (TEMPLATE-ALIST-CACHE-ELEM-TEMPLATES CACHE)))
	(SETQ COMMAND-ALIST (TEMPLATE-ALIST-CACHE-ELEM-ALIST CACHE))
      (SETQ COMMAND-ALIST (SORT (LOOP FOR TEMPLATE IN *TEMPLATES*
				      WHEN (SEND TEMPLATE :COMMAND-TYPEP COMMAND-TYPE)
					COLLECT `(,(SEND TEMPLATE :MENU-NAME)
						  :VALUE ,TEMPLATE
						  :FONT ,(SEND TEMPLATE :MENU-FONT)
						  :DOCUMENTATION
						    ,(SEND TEMPLATE :DOCUMENTATION)))
				#'(LAMBDA (A B)
				    (LET ((FONTA (GET (LOCF (CDR A)) :FONT))
					  (FONTB (GET (LOCF (CDR B)) :FONT)))
				      (COND ((EQ FONTA FONTB)
					     (STRING-LESSP (CAR A) (CAR B)))
					    ((EQ FONTA NIL))
					    ((EQ FONTB NIL) NIL)
					    (T
					     (STRING-LESSP (GET-PNAME FONTA)
							   (GET-PNAME FONTB))))))))
      (UNLESS CACHE
	(PUSH (SETQ CACHE (MAKE-TEMPLATE-ALIST-CACHE-ELEM COMMAND-TYPE COMMAND-TYPE))
	      *TEMPLATE-COMMAND-ALIST-CACHE*))
      (SETF (TEMPLATE-ALIST-CACHE-ELEM-TEMPLATES CACHE) *TEMPLATES*)
      (SETF (TEMPLATE-ALIST-CACHE-ELEM-ALIST CACHE) COMMAND-ALIST)
      (SETF (TEMPLATE-ALIST-CACHE-ELEM-LAST-ITEM CACHE) NIL))
  (VALUES COMMAND-ALIST CACHE)))

(SCL:DEFINE-PRESENTATION-TYPE TEMPLATE ((&KEY COMMAND-TYPE))
   :NO-DEFTYPE T
   :PARSER ((STREAM &KEY TYPE INITIALLY-DISPLAY-POSSIBILITIES)
	    (MULTIPLE-VALUE-BIND (TEMPLATE IGNORE IGNORE)
		(DW:COMPLETING-FROM-SUGGESTIONS
		    (STREAM :TYPE TYPE
			    :INITIALLY-DISPLAY-POSSIBILITIES INITIALLY-DISPLAY-POSSIBILITIES)
		  (LOOP FOR ELEM IN (TEMPLATE-COMMAND-ALIST COMMAND-TYPE)
			DO (DW:SUGGEST (FIRST ELEM) (TV:MENU-EXECUTE-NO-SIDE-EFFECTS ELEM))))
	      (VALUES TEMPLATE TYPE)))
   :PRINTER ((TEMPLATE STREAM)
	     (IGNORE COMMAND-TYPE)
	     (CL:WRITE-STRING (SEND TEMPLATE :MENU-NAME) STREAM))
   :DESCRIBER ((STREAM)
	       (IF (EQ COMMAND-TYPE :BUG-REPORT)
		   (CL:WRITE-STRING "a bug report category" STREAM)
		 (FORMAT STREAM "a ~(~A~) template" COMMAND-TYPE))))

(DEFUN GET-TEMPLATE-DEFAULT (TEMPLATE)
  (LOOP DOING (SETQ TEMPLATE (FIND-TEMPLATE TEMPLATE))
	WHILE (EQ (SEND TEMPLATE :TYPE) :INDIRECT)
	DO (SETQ TEMPLATE (SEND TEMPLATE :INDIRECT-TO)))
  TEMPLATE)

(DEFUN SAME-TEMPLATES-P (TEM-1 TEM-2)
  (EQ (GET-TEMPLATE-DEFAULT TEM-1) (GET-TEMPLATE-DEFAULT TEM-2)))

;;; Get a template for use by a command.  LEFT, if specified, overrides the last item clicked
;;; which is otherwise the default.
(DEFUN CHOOSE-TEMPLATE-FOR-COMMAND (TYPE &OPTIONAL LEFT PROMPT)
  (COND ((AND LEFT (MEMQ *ZMAIL-COMMAND-BUTTON* '(:LEFT :KBD)))
	 LEFT)
	((AND (EQ *ZMAIL-COMMAND-BUTTON* :KBD) (EQ TYPE :BUG-REPORT))
	 (MULTIPLE-VALUE-BIND (VALUE IGNORE)
	     (TYPEIN-LINE-ACCEPT `((SCL:TYPE-OR-STRING ((TEMPLATE :COMMAND-TYPE ,TYPE))))
				 :PROMPT PROMPT)
	   (CL:ETYPECASE VALUE
	     (TEMPLATE VALUE)
	     (STRING
	       (COND ((STRING-EQUAL VALUE "")
		      (BARF "You must supply a bug report category."))
		     ((TYPEIN-LINE-BEEP-YES-OR-NO-P
			"/"~A/" is not the name of a known bug report category.~@
			~2TDo you wish to send a report to Bug-~A?  "
			VALUE VALUE)
		      (ADD-BUG-RECIPIENT VALUE))
		     (T
		      (ABORT-CURRENT-COMMAND)))))))
	((EQ *ZMAIL-COMMAND-BUTTON* :KBD)
	 (TYPEIN-LINE-ACCEPT `((TEMPLATE :COMMAND-TYPE ,TYPE)) :PROMPT PROMPT))
	(T
	 (MULTIPLE-VALUE-BIND (ALIST CACHE)
	     (TEMPLATE-COMMAND-ALIST TYPE)
	   (MULTIPLE-VALUE-BIND (VALUE ITEM)
	       (ZMAIL-MENU-CHOOSE NIL ALIST (TEMPLATE-ALIST-CACHE-ELEM-LAST-ITEM CACHE))
	     (SETF (TEMPLATE-ALIST-CACHE-ELEM-LAST-ITEM CACHE) ITEM)
	     VALUE)))))

(DEFUN DEFAULT-TEMPLATE-MENU-NAME (TYPE)
  (MULTIPLE-VALUE-BIND (IGNORE CACHE)
      (TEMPLATE-COMMAND-ALIST TYPE)
    (WHEN CACHE
      (LET ((LAST-ITEM (TEMPLATE-ALIST-CACHE-ELEM-LAST-ITEM CACHE)))
	(WHEN LAST-ITEM
	  (LET ((TEMPLATE (FIND-TEMPLATE (TV:MENU-EXECUTE-NO-SIDE-EFFECTS LAST-ITEM) T)))
	    (WHEN TEMPLATE
	      (SEND TEMPLATE :MENU-NAME))))))))

;;;; Specific types

;;; Templates that are just known by name by the program, and which therefore indirect
(DEFINE-TEMPLATE-TYPE INDIRECT-TEMPLATE :INDIRECT (INDIRECT-TO COMMAND-TYPE) (TEMPLATE)
  :GETTABLE-INSTANCE-VARIABLES)

;;; Unlike most templates, :TEMPLATE is handled as at init time rather than expansion time.
(DEFMETHOD (:DEFTEMPLATE-KEYWORD INDIRECT-TEMPLATE :TEMPLATE) (TEMPLATE)
  (SETQ INDIRECT-TO TEMPLATE))

(DEFMETHOD (:DEFTEMPLATE-KEYWORD INDIRECT-TEMPLATE :COMMAND-TYPE) (TYPE)
  (SETQ COMMAND-TYPE TYPE))

(DEFMETHOD (:INIT INDIRECT-TEMPLATE :AFTER) (IGNORE)
  (OR (VARIABLE-BOUNDP INDIRECT-TO)
      (FERROR "No template to indirect to was specified for ~S" SELF))
  (OR (NULL EXPANSION)
      (FERROR "Only a template to indirect to may be specified for ~S" SELF)))

;;; This could also be handled by letting EXPANSION have the template in it.
(DEFMETHOD (:EXPAND INDIRECT-TEMPLATE) (PLIST)
  (SEND (FIND-TEMPLATE INDIRECT-TO) ':EXPAND PLIST))

(DEFMETHOD (:DOCUMENTATION INDIRECT-TEMPLATE) ()
  (IF (OR (NULL DOCUMENTATION) (STRING-EQUAL DOCUMENTATION ""))
      (SEND (FIND-TEMPLATE INDIRECT-TO) ':DOCUMENTATION)
    DOCUMENTATION))

(DEFMETHOD (:MENU-NAME INDIRECT-TEMPLATE) ()
  (SEND (FIND-TEMPLATE INDIRECT-TO) ':MENU-NAME))

;;; Templates dealing with header generation, either composition or sending
(DEFFLAVOR HEADER-TEMPLATE () (TEMPLATE))

;;; If VALUE is not given, an empty header is setup to be filled in
(DEFMETHOD (:EXPANSION-KEYWORD HEADER-TEMPLATE :HEADER-FIELD)
	   (PLIST HEADER &OPTIONAL VALUE)
  (DECLARE (SPECIAL PLIST))		;For EVAL
  (SETQ VALUE (EVAL VALUE))
  (AND (STRINGP VALUE) (HEADER-TYPE-TYPEP HEADER ':ADDRESS)
       (SETQ VALUE (PARSE-ADDRESSES VALUE)))
  (SEND SELF ':ADD-HEADER PLIST HEADER VALUE))

;;; Like above, but no header if not there.
(DEFMETHOD (:EXPANSION-KEYWORD HEADER-TEMPLATE :HEADER-FIELD-UNLESS-NIL)
	   (PLIST HEADER VALUE)
  (DECLARE (SPECIAL PLIST))		;For EVAL
  (AND (SETQ VALUE (EVAL VALUE))
       (SEND SELF ':ADD-HEADER PLIST HEADER VALUE)))


(DEFMETHOD (:ADD-HEADER HEADER-TEMPLATE) (PLIST HEADER VALUE)
  (PUTPROP PLIST (NCONC (GET PLIST ':HEADERS) (LIST HEADER VALUE)) ':HEADERS))

(DEFMETHOD (:EXPANSION-KEYWORD HEADER-TEMPLATE :HEADER-FORMAT)
	   (PLIST FORMAT)
  (PUTPROP PLIST FORMAT ':HEADER-FORMAT))

(DEFMETHOD (:EXPANSION-KEYWORD HEADER-TEMPLATE :INTERNET-FORMAT) (PLIST)
  (PUTPROP PLIST T ':INTERNET-FORMAT))

(DEFMETHOD (:EXPANSION-KEYWORD HEADER-TEMPLATE :TEXT) (PLIST TEXT)
  (SEND SELF ':ADD-TEXT PLIST (EVAL TEXT)))

;;; TEXT can be either an interval or a string.
(DEFMETHOD (:ADD-TEXT HEADER-TEMPLATE) (PLIST TEXT &AUX OLD)
  (IF (SETQ OLD (GET PLIST ':TEXT))
      (IF (TYPEP OLD 'INTERVAL)
	  (INSERT-THING (INTERVAL-LAST-BP OLD) TEXT)
	  (PUTPROP PLIST (IF (NOT (TYPEP TEXT 'INTERVAL))
			     (STRING-APPEND OLD TEXT)
			     (INSERT-THING (INTERVAL-FIRST-BP TEXT) OLD)
			     TEXT)
		   ':TEXT))
      (PUTPROP PLIST TEXT ':TEXT)))

;;; Composition templates: mail, reply, forward, redistribute, etc.
(DEFINE-TEMPLATE-TYPE COMPOSITION-TEMPLATE :COMPOSE () (HEADER-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :STARTING-POINT)
	   (PLIST &REST WINDOW-AND-ARGS)
  "Specify where cursor is when starting to compose."
  (PUSH (COPYLIST WINDOW-AND-ARGS) (GET PLIST ':STARTING-POINT)))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :WINDOW-CONFIGURATION)
	   (PLIST CONFIG)
  (PUTPROP PLIST CONFIG ':WINDOW-CONFIGURATION))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :COMPOSITION-FUNCTION)
	   (PLIST FUNCTION)
  (PUTPROP PLIST FUNCTION ':COMPOSITION-FUNCTION))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :TRANSMIT-TEMPLATES)
	   (PLIST &REST LISTS)
  (PUTPROP PLIST (LOOP FOR X IN LISTS
		       WHEN (ATOM X) COLLECT `(,X . :RECIPIENT)
		       ELSE COLLECT X)
	   ':TRANSMIT-TEMPLATES))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :DRAFT-PATHNAME)
	   (PLIST PATHNAME)
  (PUTPROP PLIST PATHNAME ':DRAFT-PATHNAME))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :NUMBER-OF-HEADER-LINES)
	   (PLIST NLINES)
  (PUTPROP PLIST NLINES ':NUMBER-OF-HEADER-LINES))

(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :NUMBER-OF-EXTRA-HEADER-LINES)
	   (PLIST NLINES)
  (PUTPROP PLIST NLINES ':NUMBER-OF-EXTRA-HEADER-LINES))


(DEFMETHOD (:EXPANSION-KEYWORD COMPOSITION-TEMPLATE :FONTS) (PLIST FONTS)
  (ignore plist fonts)
  nil)

(DEFFLAVOR MSG-TEMPLATE-MIXIN () ()
  (:REQUIRED-FLAVORS COMPOSITION-TEMPLATE))

(DEFMETHOD (:EXPAND MSG-TEMPLATE-MIXIN :BEFORE) (PLIST)
  (OR (GET PLIST ':MSGS) (BARF "There is no current message")))

(DEFMETHOD (:EXPANSION-KEYWORD MSG-TEMPLATE-MIXIN :TEXT-FROM-MSGS)
	   (PLIST &REST OPTIONS)
  (SETQ OPTIONS (LOOP FOR (OPT VAL) ON OPTIONS BY 'CDDR
		      COLLECT OPT COLLECT (EVAL VAL)))
  (LET ((INT (CREATE-INTERVAL)))
    (LEXPR-FUNCALL #'INSERT-TEXT-OF-MSGS
		   (GET PLIST ':MSGS)
		   (INTERVAL-LAST-BP INT) nil
		   OPTIONS)
    (SEND SELF ':ADD-TEXT PLIST INT)))

(DEFINE-TEMPLATE-TYPE MAIL-TEMPLATE :MAIL () (COMPOSITION-TEMPLATE))

1;;; Bug reporting.
0(DEFMETHOD (:EXPANSION-KEYWORD MAIL-TEMPLATE :BUG-REPORT) (PLIST PROGRAM)
  (LET ((MENU-NAME (SEND SELF :MENU-NAME)))
    (WHEN (EQ PROGRAM :OTHER)
      (SETQ PROGRAM (MAYBE-CALL-POP-UP-MINI-BUFFER-EDITOR
		      :MOUSE #'TYPEIN-LINE-READLINE "Send a bug report about:"))
      (WHEN (EQUAL PROGRAM "") (BARF))
      (LET ((NEW-TEMPLATE (ADD-BUG-RECIPIENT PROGRAM)))
	(SETQ MENU-NAME (SEND NEW-TEMPLATE :MENU-NAME))))
    (MULTIPLE-VALUE-BIND (WHO WHAT)
	(PARSE-BUG-ARG PROGRAM MENU-NAME)
      (PUTPROP PLIST PROGRAM :BUG-REPORT)
      (SETQ WHO (OR *BUG-REPORT-RECIPIENT-OVERRIDE* (GET PLIST :ADDRESSEE-NAME) WHO))
      (SEND SELF :ADD-HEADER PLIST :TO (PARSE-ADDRESSES WHO))
      (SEND SELF :ADD-TEXT PLIST WHAT))))

;; must come before :BUG-REPORT in the DEFTEMPLATE options...
(DEFMETHOD (:EXPANSION-KEYWORD MAIL-TEMPLATE :ADDRESSEE-NAME)
	   (PLIST NAME)
  (PUTPROP PLIST NAME ':ADDRESSEE-NAME))

(DEFUN ADD-BUG-RECIPIENT (NAME &OPTIONAL DOCUMENTATION MENU-NAME ADDRESSEE-NAME)
  (WHEN (STRING-EQUAL "BUG-" NAME 0 0 4 4)
    (SETQ NAME (SUBSTRING NAME 4)))
  (SETQ NAME (STRING NAME)
	MENU-NAME (IF MENU-NAME (STRING MENU-NAME) NAME)
	DOCUMENTATION (IF DOCUMENTATION (STRING DOCUMENTATION)
			(FORMAT NIL "Report problems in the ~A system." (OR MENU-NAME NAME)))
	ADDRESSEE-NAME (WHEN ADDRESSEE-NAME (STRING ADDRESSEE-NAME)))
  (LET ((TEMPLATE-NAME (INTERN (STRING-APPEND "BUG-" (STRING-UPCASE NAME) "-TEMPLATE")
			       *EDITOR-PACKAGE*)))
    (DEFTEMPLATE-1 TEMPLATE-NAME
		   `((:TYPE :MAIL) (:NAME ,MENU-NAME)
		     (:DOCUMENTATION ,DOCUMENTATION) (:AVAILABLE-FOR-COMMANDS :BUG-REPORT)
		     (:ADDRESSEE-NAME ,ADDRESSEE-NAME) (:BUG-REPORT ,NAME)
		     (:TEMPLATE BUG-REPORT-TEMPLATE)))
    (FIND-TEMPLATE TEMPLATE-NAME T)))

(DEFUN ADD-BUG-RECIPIENT-FOR-SYSTEM (SYSTEM)
  (LET* ((TEMPLATE-NAME (SCT:SYSTEM-SHORT-NAME SYSTEM))
	 (PRETTY-NAME (SCT:SYSTEM-PRETTY-NAME SYSTEM))
	 (BUG-REPORTS (SCT:SYSTEM-BUG-REPORTS SYSTEM))
	 (DEFAULT-DOCUMENTATION (FORMAT NIL "Report problems in the ~A system." PRETTY-NAME))
	 (DEFAULT-MAILING-LIST (FORMAT NIL "Bug-~:(~A~)" (SCT:SYSTEM-NAME SYSTEM))))
    (FLET ((MAKE-LIST-NAME (NAME)
	     (IF (STRING-EQUAL "Bug-" NAME 0 0 4 (MIN (STRING-LENGTH NAME) 4))
		 NAME
		 (FORMAT NIL "Bug-~A" NAME))))
      (WHEN BUG-REPORTS
	(MULTIPLE-VALUE-BIND (DOCUMENTATION MENU-NAME MAILING-LIST)
	    (COND ((EQ BUG-REPORTS T)
		   (VALUES DEFAULT-DOCUMENTATION PRETTY-NAME DEFAULT-MAILING-LIST))
		  ((ATOM BUG-REPORTS)
		   (VALUES DEFAULT-DOCUMENTATION BUG-REPORTS (MAKE-LIST-NAME BUG-REPORTS)))
		  ((SYMBOLP (FIRST BUG-REPORTS))
		   (VALUES (CL:GETF BUG-REPORTS :DOCUMENTATION DEFAULT-DOCUMENTATION)
			   (CL:GETF BUG-REPORTS :NAME PRETTY-NAME)
			   (CL:GETF BUG-REPORTS :MAILING-LIST DEFAULT-MAILING-LIST)))
		  (T
		   (VALUES (OR (SECOND BUG-REPORTS) DEFAULT-DOCUMENTATION)
			   (FIRST BUG-REPORTS)
			   (MAKE-LIST-NAME (FIRST BUG-REPORTS)))))
	  (ADD-BUG-RECIPIENT TEMPLATE-NAME DOCUMENTATION MENU-NAME MAILING-LIST))))))

(DEFUN ADD-BUG-RECIPIENTS-FOR-DEFINED-SYSTEMS ()
  (DOLIST (SYSTEM SCT:*ALL-SYSTEMS*)
    (LET ((BUG-REPORT-DESC (SCT:SYSTEM-BUG-REPORTS SYSTEM)))
      (WHEN BUG-REPORT-DESC
	(ADD-BUG-RECIPIENT-FOR-SYSTEM SYSTEM)))))

(ADD-INITIALIZATION "Setup Bug- Recipients" '(ADD-BUG-RECIPIENTS-FOR-DEFINED-SYSTEMS) ()
		    '*ZMAIL-SYSTEM-INITIALIZATIONS*)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION GET-BUG-ARG *BUG-DOCUMENTATION*)

(DEFINE-COMMAND-WHO-LINE-DOCUMENTATION-UPDATER GET-BUG-ARG (STRING)
  (FORMAT STRING "Send a bug report:~@[ L: BUG-~A; ~] R: menu."
	  (DEFAULT-TEMPLATE-MENU-NAME ':BUG-REPORT)))

;;; Replying
(DEFINE-TEMPLATE-TYPE REPLY-TEMPLATE :REPLY () (MSG-TEMPLATE-MIXIN COMPOSITION-TEMPLATE))

(DEFMETHOD (:EXPAND REPLY-TEMPLATE :BEFORE) (PLIST)
  (PUTPROP PLIST (GET PLIST ':MSGS) ':MSGS-BEING-REPLIED-TO)
  (PUTPROP PLIST NIL ':SENDERS-ALREADY-QUERIED))

(DEFMETHOD (:EXPANSION-KEYWORD REPLY-TEMPLATE :REPLY-HEADERS)
	   (PLIST &REST PAIRS)
  "Arguments are lists of (reply-header-type original-header-type)"
  (SEND SELF ':REPLY-HEADERS PLIST PAIRS))

(DEFMETHOD (:REPLY-HEADERS REPLY-TEMPLATE) (PLIST PAIRS)
  (MAKE-REPLY-HEADERS PLIST PAIRS NIL))

(DEFMETHOD (:EXPANSION-KEYWORD REPLY-TEMPLATE :REPLY-HEADERS-OR-HEADER-FIELDS)
	   (PLIST &REST PAIRS)
  "Arguments are lists of (reply-header-type original-header-type)"
  (SEND SELF ':REPLY-HEADERS-OR-HEADER-FIELDS PLIST PAIRS))

(DEFMETHOD (:REPLY-HEADERS-OR-HEADER-FIELDS REPLY-TEMPLATE) (PLIST PAIRS)
  ;; copy contents of original headers, but always include a
  ;; reply-header-type field, even if original contents were nil
  (MAKE-REPLY-HEADERS PLIST PAIRS T))

(DEFUN MAKE-REPLY-HEADERS (PLIST PAIRS EVEN-IF-EMPTY)
  (LOOP WITH DONT-REPLY-TO = (GET PLIST :DONT-REPLY-TO)
	AND ALTERNATIVE-REPLY-TO = (GET PLIST :ALTERNATIVE-REPLY-TO)
	AND MSGS = (GET PLIST :MSGS)
	AND FORMAT = (GET PLIST :HEADER-FORMAT)
	AND ALREADY-DONE = NIL
	FOR (OUTPUT-TYPE INPUT-TYPE) IN PAIRS
	AS OUTPUT-VALUE = (HEADER-TYPE-TYPECASE INPUT-TYPE
			    (:ADDRESS
			      (LOOP FOR MSG IN MSGS
				    AS STATUS = (ASSURE-MSG-PARSED MSG)
				    AS RCPT = (IF (EQ INPUT-TYPE :SENDER)
						  (SENDER-REPLY-HEADER-MAYBE-TRIM
						    PLIST MSG
						    (OR (GET STATUS :REPLY-TO)
							(GET STATUS :FROM))
						    DONT-REPLY-TO ALTERNATIVE-REPLY-TO
						    FORMAT T)
						(REPLY-HEADER-TRIM 
						  (GET STATUS INPUT-TYPE)
						  DONT-REPLY-TO ALTERNATIVE-REPLY-TO
						  FORMAT T))
				    APPEND (REPLY-HEADER-TRIM
					     (REPLY-HEADER-TRIM RCPT ALREADY-DONE NIL FORMAT)
					     HEADERS NIL FORMAT)
				      INTO HEADERS
				    FINALLY (SETQ ALREADY-DONE (APPEND ALREADY-DONE HEADERS))
					    (RETURN HEADERS)))
			    (:FILE-LIST
			      (LOOP FOR MSG IN MSGS
				    AS STATUS = (ASSURE-MSG-PARSED MSG)
				    AS FILES = (GET STATUS INPUT-TYPE)
				    WHEN FILES
				      APPEND FILES INTO ALL-FILES
				    FINALLY
				      (RETURN (CL:REMOVE-DUPLICATES ALL-FILES :TEST #'EQUAL)))
			      )
			    (OTHERWISE
			      (LOOP FOR MSG IN MSGS
				    AS STATUS = (ASSURE-MSG-PARSED MSG)
				    THEREIS (GET STATUS INPUT-TYPE))))
	WHEN (OR OUTPUT-VALUE EVEN-IF-EMPTY)
	  COLLECT OUTPUT-TYPE INTO HEADERS AND COLLECT OUTPUT-VALUE INTO HEADERS
	FINALLY
	  (PUTPROP PLIST (NCONC (GET PLIST :HEADERS) HEADERS) :HEADERS)))

(DEFUN SENDER-REPLY-HEADER-MAYBE-TRIM (PLIST MSG LIST-TO-TRIM LIST-TO-REMOVE LIST-TO-REPLACE
				       FORMAT &OPTIONAL STAR-SPECIAL)
  (LET ((ORIGINAL-LIST LIST-TO-TRIM)
	(TRIMMED-LIST (REPLY-HEADER-TRIM LIST-TO-TRIM LIST-TO-REMOVE LIST-TO-REPLACE
					 FORMAT STAR-SPECIAL)))
    (UNLESS (EQUAL TRIMMED-LIST ORIGINAL-LIST)
      (LET ((REMOVED (REPLY-HEADER-TRIM ORIGINAL-LIST TRIMMED-LIST NIL NIL))
	    (SENDERS-ALREADY-QUERIED (GET PLIST :SENDERS-ALREADY-QUERIED)))
	(LOOP WITH MSG-INDEX = (IF (MSG-DISPLAYED-INDEX MSG) (1+ (MSG-DISPLAYED-INDEX MSG)))
	      FOR ORIGINATOR IN REMOVED
	      AS ORIGINATOR-NAME = (GET (LOCF ORIGINATOR) :NAME)
	      UNLESS (MEMBER ORIGINATOR-NAME SENDERS-ALREADY-QUERIED)
		DO (UNLESS (TYPEOUT-BEEP-YES-OR-NO-P
			     "~A, ~:[one of ~;~]the originator~P of ~:[the ~]message~@[ ~D~],~
			      ~@Tis in your Don't-Reply-To list.~@
			      ~2@TIs it OK to omit ~A from the recipients? "
			     ORIGINATOR-NAME (= 1 (LENGTH ORIGINAL-LIST))
			     (LENGTH ORIGINAL-LIST) MSG-INDEX MSG-INDEX ORIGINATOR-NAME)
		     (PUSH ORIGINATOR TRIMMED-LIST))
		   (PUTPROP PLIST (PUSH ORIGINATOR-NAME SENDERS-ALREADY-QUERIED)
			    :SENDERS-ALREADY-QUERIED))))
    TRIMMED-LIST))

(DEFUN REPLY-HEADER-TRIM (LIST-TO-TRIM LIST-TO-REMOVE LIST-TO-REPLACE FORMAT
			  &OPTIONAL STAR-SPECIAL)
  (LOOP FOR NEW IN LIST-TO-TRIM
	DO (LET ((NEW-NAME (CDR (ASSOC (GET (LOCF NEW) :NAME) LIST-TO-REPLACE))))
	     (WHEN NEW-NAME
	       ;; replacements are by :NAME only, so force their host to the user's mail host
	       (SETQ NEW (COPYLIST NEW))
	       (SETF (GET (LOCF NEW) :NAME) NEW-NAME)
	       (SETF (GET (LOCF NEW) :HOST)
		     `(:OBJECT ,(SECOND (ZMAIL-USER-MAIL-ADDRESS))))))
	UNLESS (OR (WARN-OF-UNANSWERABLE-HEADER NEW FORMAT)
		   (MEMQ NEW INFERIORS)
		   (LOOP FOR OLD IN LIST-TO-REMOVE
			 THEREIS (REPLY-HEADER-TRIM-EQUAL NEW OLD STAR-SPECIAL)))
	COLLECT NEW
	WHEN (AND (GETL (LOCF NEW) '(:DISTRIBUTION-LIST :BRACKETED-LIST))
		  (EQ FORMAT ':USE-ORIGINAL))
	NCONC (GET-HEADER-INFERIORS NEW) INTO INFERIORS))

(DEFUN REPLY-HEADER-TRIM-EQUAL (NEW OLD STAR-SPECIAL &AUX SL NL)
  (COND ((AND STAR-SPECIAL (STRINGP OLD))
	 (SETQ SL (STRING-LENGTH OLD))
	 (AND (> SL 0)				;check for empty string
	      (CHAR-EQUAL (AREF OLD (1- SL)) #/*)
	      (SETQ SL (1- SL) NL SL)))
	(T
	 (SETQ OLD (GET (LOCF OLD) ':NAME))))
  (SETQ NEW (GET (LOCF NEW) ':NAME))
  (STRING-EQUAL NEW OLD 0 0 NL SL))

(DEFUN GET-HEADER-INFERIORS (HEADER)
  (LOOP FOR INF IN (GET (LOCF HEADER) ':INFERIORS)
	NCONC (CONS INF (GET-HEADER-INFERIORS INF))))

(DEFUN WARN-OF-UNANSWERABLE-HEADER (HEADER FORMAT &AUX (PLIST (LOCF HEADER)))
  (COND ((GET PLIST ':NAME)
	 NIL)					;OK, normal header
	((AND (GETL PLIST '(:DISTRIBUTION-LIST :BRACKETED-LIST))
	      (GET PLIST ':INFERIORS))
	 (NEQ FORMAT ':USE-ORIGINAL))		;Use or ignore silently
	(T
	 (FORMAT T "~&Cannot reply to /"~A/", address flushed~%"
		 (STRING-FROM-HEADER HEADER ':USE-ORIGINAL))
	 T)))

(DEFMETHOD (:EXPANSION-KEYWORD REPLY-TEMPLATE :IN-REPLY-TO) (PLIST)
  (SEND SELF ':ADD-HEADER PLIST ':IN-REPLY-TO
	(GENERATE-REFERENCE-HEADER (GET PLIST ':MSGS))))

(DEFMETHOD (:EXPANSION-KEYWORD REPLY-TEMPLATE :DONT-REPLY-TO)
	   (PLIST &REST ADDRESSES)
  (PUTPROP PLIST (APPEND (GET PLIST :DONT-REPLY-TO) (COPYLIST ADDRESSES)) ':DONT-REPLY-TO))

;;; NOTE: this item takes a single list of addresses, not an &rest
(DEFMETHOD (:EXPANSION-KEYWORD REPLY-TEMPLATE :ADDITIONAL-DONT-REPLY-TO)
	   (PLIST ADDRESSES)
  (SETF (GET PLIST :DONT-REPLY-TO)
	(APPEND (GET PLIST :DONT-REPLY-TO) (COPYLIST (EVAL ADDRESSES)))))

(DEFMETHOD (:EXPANSION-KEYWORD REPLY-TEMPLATE :ALTERNATIVE-REPLY-TO)
	   (PLIST ADDRESS-ALIST)
  (SETF (GET PLIST :ALTERNATIVE-REPLY-TO)	;list of alternates if there are alternates
	(APPEND (GET PLIST :ALTERNATIVE-REPLY-TO) (LOOP FOR ELEM IN (EVAL ADDRESS-ALIST)
							AS (NIL . ALT) = ELEM
							WHEN ALT COLLECT ELEM)))
  (SETF (GET PLIST :DONT-REPLY-TO)		;simple dont-replies if no alternates
	(APPEND (GET PLIST :DONT-REPLY-TO) (LOOP FOR ELEM IN (EVAL ADDRESS-ALIST)
						 AS (ADR . ALT) = ELEM
						 UNLESS ALT COLLECT ADR))))

(DEFINE-TEMPLATE-TYPE REVOKE-TEMPLATE :REVOKE () (COMPOSITION-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD REVOKE-TEMPLATE :REVOKE-SUBJECT) (PLIST)
  (LET ((SUBJECT (NCONC (LOOP FOR MSG IN (GET PLIST :MSGS)
			      AS SUBJECT = (MSG-GET MSG :SUBJECT)
			      WHEN SUBJECT
				WHEN (LISTP SUBJECT) APPEND SUBJECT
			        ELSE COLLECT SUBJECT)
			(LOOP FOR DRAFT-MSG IN (GET PLIST :DRAFT-MSGS)
			      AS SUBJECT = (LET ((HEADERS (SEND DRAFT-MSG :HEADERS)))
					     (GET (LOCF HEADERS) :SUBJECT))
			      WHEN SUBJECT
				WHEN (LISTP SUBJECT) APPEND SUBJECT
			        ELSE COLLECT SUBJECT))))
    (WHEN SUBJECT
      (SEND SELF :ADD-HEADER PLIST :SUBJECT SUBJECT))))

(DEFMETHOD (:EXPANSION-KEYWORD REVOKE-TEMPLATE :REVOKES) (PLIST)
  (LET ((REFERENCES (NCONC (LOOP FOR MSG IN (GET PLIST :MSGS)
				 COLLECT (GENERATE-REFERENCE-HEADER-FROM-HEADERS
					   (CDR (ASSURE-MSG-PARSED MSG))))
			   (LOOP FOR DRAFT-MSG IN (GET PLIST :DRAFT-MSGS)
				 APPEND (SEND DRAFT-MSG :REFERENCES)))))
    (WHEN REFERENCES
      (SEND SELF :ADD-HEADER PLIST :REVOKES REFERENCES))))

(DEFMETHOD (:EXPANSION-KEYWORD REVOKE-TEMPLATE :REVOKE-TO) (PLIST)
  (LET ((RECIPIENTS (NCONC (LOOP FOR MSG IN (GET PLIST :MSGS)
				 NCONC (LOOP FOR (TYPE HEADER)
					       ON (CDR (ASSURE-MSG-PARSED MSG))
					       BY 'CDDR
					     WHEN (HEADER-TYPE-TYPEP TYPE :RECIPIENT)
					     APPEND HEADER))
			   (LOOP FOR DRAFT-MSG IN (GET PLIST :DRAFT-MSGS)
				 APPEND (SEND DRAFT-MSG :RECIPIENTS)))))
    (WHEN RECIPIENTS
      (SEND SELF :ADD-HEADER PLIST :TO RECIPIENTS))))

;;; Forwarding
(DEFINE-TEMPLATE-TYPE FORWARD-TEMPLATE :FORWARD () (MSG-TEMPLATE-MIXIN COMPOSITION-TEMPLATE))

(DEFMETHOD (:EXPAND FORWARD-TEMPLATE :BEFORE) (PLIST)
  (PUTPROP PLIST (GET PLIST ':MSGS) ':MSGS-BEING-FORWARDED))

(DEFMETHOD (:EXPANSION-KEYWORD FORWARD-TEMPLATE :FORWARDED-SUBJECT) (PLIST)
  (SEND SELF ':ADD-HEADER PLIST ':SUBJECT
	(LOOP FOR MSG IN (GET PLIST ':MSGS)
	      AS STATUS = (ASSURE-MSG-PARSED MSG)
	      AS FROM = (CAR (GET STATUS ':FROM))
	      AND SUBJECT = (GET STATUS ':SUBJECT)
	      COLLECT (WITH-OUTPUT-TO-STRING (STREAM)
			(SEND STREAM :TYO #/[)
			(SEND STREAM :STRING-OUT (IF FROM (STRING-FROM-HEADER FROM ':LONG)
						   "From: ??"))
			(SEND STREAM :STRING-OUT ": ")
			(SYS:WITH-INDENTATION (STREAM (SEND STREAM :READ-CURSORPOS))
			  (COND ((NULL SUBJECT)
				 (SEND STREAM :STRING-OUT "Forwarded"))
				((LISTP SUBJECT)
				 (LOOP FOR STRING IN SUBJECT
				       WITH FLAG = NIL
				       DOING (IF FLAG
						 (SEND STREAM :TYO #\CR)
						 (SETQ FLAG T))
					     (SEND STREAM :STRING-OUT STRING)))
				(T
				 (SEND STREAM :STRING-OUT SUBJECT))))
			(SEND STREAM :TYO #/])))))

(DEFMETHOD (:EXPANSION-KEYWORD FORWARD-TEMPLATE :FILE-REFERENCES) (PLIST)
  (MAKE-REPLY-HEADERS PLIST '((:FILE-REFERENCES :FILE-REFERENCES)) NIL))

(DEFMETHOD (:EXPANSION-KEYWORD FORWARD-TEMPLATE :INCLUDED-MSGS) (PLIST)
  (LET ((INCLUDED-MSGS
	  (MSG-REFERENCES-ELIMINATE-DUPLICATES (LOOP FOR MSG IN (GET PLIST :MSGS)
						     APPEND (GET-MSG-IDS MSG))
					       T)))
    (WHEN INCLUDED-MSGS
      (SEND SELF :ADD-HEADER PLIST :INCLUDED-MSGS (CL:MAP 'LIST #'CDR INCLUDED-MSGS)))))

(DEFMETHOD (:EXPANSION-KEYWORD FORWARD-TEMPLATE :INCLUDED-REFERENCES) (PLIST)
  (LET* ((INCLUDED-MSGS
	   (MSG-REFERENCES-ELIMINATE-DUPLICATES (LOOP FOR MSG IN (GET PLIST :MSGS)
						      APPEND (GET-MSG-IDS MSG))
						T))
	 (INCLUDED-REFERENCES
	   (MSG-REFERENCES-EXCLUDE-IDS INCLUDED-MSGS
	     (MSG-REFERENCES-ELIMINATE-DUPLICATES (LOOP FOR MSG IN (GET PLIST :MSGS)
							APPEND (MSG-REFERENCES MSG))))))
    (WHEN INCLUDED-REFERENCES
      (SEND SELF :ADD-HEADER PLIST :INCLUDED-REFERENCES INCLUDED-REFERENCES))))

;;;; Transmission
(DEFINE-TEMPLATE-TYPE TRANSMISSION-TEMPLATE :TRANSMIT () (HEADER-TEMPLATE))

(DEFMETHOD (:EXPAND TRANSMISSION-TEMPLATE :BEFORE) (PLIST)
  (LET ((DRAFT (GET PLIST :DRAFT-MSG)))
    (PUTPROP PLIST (IF DRAFT
		       (FIRST (SEND DRAFT :TRANSMIT-TIMESTAMP)) (TIME:GET-UNIVERSAL-TIME))
	     :TRANSMIT-TIME)
    (PUTPROP PLIST NIL 'COMPUTED-DEFAULT-CHARACTER-STYLE)
    (PUTPROP PLIST NIL 'COMPUTED-CHARACTER-TYPE-MAPPINGS)
    (PUTPROP PLIST T :FORCE-NUMERIC-TIMEZONE)))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :SENDING-MODE)
	   (PLIST MODE)
  (PUTPROP PLIST MODE ':SENDING-MODE))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :STANDARD-DATE)
	   (PLIST &OPTIONAL (HEADER-TYPE ':DATE))
  (SEND SELF ':ADD-HEADER PLIST HEADER-TYPE (GET PLIST ':TRANSMIT-TIME)))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :STANDARD-FROM)
	   (PLIST &OPTIONAL (HEADER-TYPE :FROM) (IF-DAEMON :PROMPT-FOR-IT))
  (LET* ((HEADERS (GET PLIST :HEADERS))
	 (FROM (GET (LOCF HEADERS) HEADER-TYPE)))
    (COND ((NULL FROM)
	   (SETQ FROM `((:USER ,SI:*USER*)))
	   (WHEN (EQ (SEND SI:*USER* :TYPE) :DAEMON)
	     (SELECTQ IF-DAEMON
	       ((NIL))
	       ((:COMPLAIN) (COMPLAIN-OF-MISSING-HEADER :FROM))
	       (OTHERWISE (PROMPT-FOR-MISSING-HEADER :FROM (GET PLIST :DRAFT-MSG)))))
	   (SEND SELF :ADD-HEADER PLIST HEADER-TYPE FROM))
	  ((NOT (AND (= (LENGTH FROM) 1)
		     (LET* ((FFROM (CAR FROM))
			    (USER (GET (LOCF FFROM) :USER)))
		       (IF USER (EQ USER SI:*USER*)
			   (EQUAL USER-ID (GET (LOCF FFROM) :NAME))))))
	   (SEND SELF :ADD-HEADER PLIST :SENDER
		 ;; Don't want to include the personal name, so expand here.
		 (LET ((MAIL-ADDRESS (ZMAIL-USER-MAIL-ADDRESS)))
		   `((:NAME ,(FIRST MAIL-ADDRESS)
		      :HOST (:OBJECT ,(SECOND MAIL-ADDRESS))))))))))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :DEFAULT-HOST)
	   (PLIST &OPTIONAL HOST)
  (SETQ HOST (COND (HOST
		    (LET ((TEM (EVAL HOST)))
		      (IF (ATOM TEM)
			  (CONDITION-CASE (HST)
			      (NET:PARSE-HOST TEM)
			    (SYS:UNKNOWN-HOST-NAME `(:SINGLE ,TEM))
			    (:NO-ERROR HST))
			  TEM)))
		   (T
		    (LIST ':OBJECT (SECOND (ZMAIL-USER-MAIL-ADDRESS))))))
  ;; Make sure everyone has a host who should
  (LOOP FOR (IND PROPS) ON (GET PLIST ':HEADERS) BY 'CDDR DO
    (WHEN (HEADER-TYPE-TYPEP IND ':ADDRESS)
      (LOOP FOR PROP ON PROPS DO
	(LET ((PL (LOCF (CAR PROP))))
	  (UNLESS (GET PL ':USER)
	    (LET ((HST (GET PL ':HOST)))
	      (WHEN (NULL HST)
		(PUTPROP PL HOST ':HOST)
		(NCONC (CAR PROP) (LIST ':HOST-DEFAULTED T))
		(LET ((TEM (GETL PL '(:INTERVAL))))	;This can no longer be used
		  (AND TEM (RPLACA TEM ':ORIGINAL-INTERVAL)))))))))))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :STANDARD-MESSAGE-ID)
	   (PLIST &OPTIONAL (HEADER-TYPE ':MESSAGE-ID))
  (UNLESS (GET (LOCF (GET PLIST :HEADERS)) HEADER-TYPE)
    (SEND SELF ':ADD-HEADER PLIST HEADER-TYPE
	  (GENERATE-STANDARD-MESSAGE-ID
	    (GET PLIST ':TRANSMIT-TIME)
	    (LET ((DRAFT-MSG (GET PLIST ':DRAFT-MSG)))
	      (AND DRAFT-MSG (SECOND (SEND DRAFT-MSG ':TRANSMIT-TIMESTAMP))))))))

(DEFUN GENERATE-STANDARD-MESSAGE-ID (&OPTIONAL TIME UNIQUIZER)
  (STRING-APPEND
    #/<
    (STRING-FROM-HEADER
      `(:NAME ,(MULTIPLE-VALUE-BIND (SECS MINS HOURS DAY MONTH YEAR)
		   (CL:DECODE-UNIVERSAL-TIME (OR TIME (CL:GET-UNIVERSAL-TIME)) 0)	1;UT
0		 (FORMAT NIL "~4,'0D~2,'0D~2,'0D~2,'0D~2,'0D~2,'0D.~D.~A"
			 YEAR MONTH DAY HOURS MINS SECS
			 (OR UNIQUIZER
			     (SETQ *TRANSMIT-TIMESPACE-UNIQUIZER*
				   (\ (1+ *TRANSMIT-TIMESPACE-UNIQUIZER*) 10.)))
			 SI:*USER*))
	:HOST (:OBJECT ,NET:*LOCAL-HOST*))
      :HOST)
    #/>))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :HEADER-FROM-DRAFT)
	   (PLIST TYPE &OPTIONAL (OUTPUT-TYPE TYPE))
  (LET ((FIELD (SEND (GET PLIST ':DRAFT-MSG) ':HEADER-FIELD TYPE)))
    (AND FIELD (NOT (EQUAL FIELD ""))
	 (SEND SELF ':ADD-HEADER PLIST OUTPUT-TYPE FIELD))))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :REQUIRED-HEADER-FROM-DRAFT)
	   (PLIST TYPE &OPTIONAL PROMPT-FOR-IT)
  (LET ((FIELD (SEND (GET PLIST ':DRAFT-MSG) ':HEADER-FIELD TYPE)))
    (IF (AND FIELD (NOT (EQUAL FIELD "")))
	(SEND SELF ':ADD-HEADER PLIST TYPE FIELD)
	(IF PROMPT-FOR-IT
	    (PROMPT-FOR-MISSING-HEADER TYPE (GET PLIST ':DRAFT-MSG))
	    (COMPLAIN-OF-MISSING-HEADER TYPE)))))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :REJECT-HEADER-IN-DRAFT) (PLIST TYPE)
  (LET ((FIELD (SEND (GET PLIST :DRAFT-MSG) :HEADER-FIELD TYPE)))
    (WHEN (AND FIELD (NOT (EQUAL FIELD "")))
      (COMPLAIN-OF-UNHANDLED-HEADER TYPE))))

(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :TEXT-FROM-DRAFT) (PLIST)
  (SEND SELF ':ADD-TEXT PLIST (SEND (GET PLIST ':DRAFT-MSG) ':TEXT)))

1;;; (2 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")NOTE1 --
;;;    All transmission templates must include an expansion keyword method to add the
;;;0    Default-Character-Style1 field.  Normally, this method here is used but some
;;;0    1transmission types (e.g., redistribution and redirection) have their own mechanisms.
0(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :DEFAULT-CHARACTER-STYLE-FROM-DRAFT)
	   (PLIST)
  (UNLESS (GET PLIST 'COMPUTED-DEFAULT-CHARACTER-STYLE)
    (LET* ((DRAFT (GET PLIST :DRAFT-MSG))
	   (DEFAULT-CHARACTER-STYLE (SEND DRAFT :DEFAULT-CHARACTER-STYLE)))
      (UNLESS (EQ DEFAULT-CHARACTER-STYLE *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)
	(SEND SELF :ADD-HEADER PLIST :DEFAULT-CHARACTER-STYLE DEFAULT-CHARACTER-STYLE)))
    (PUTPROP PLIST T 'COMPUTED-DEFAULT-CHARACTER-STYLE))
  (CL:GETF (GET PLIST :HEADERS) :DEFAULT-CHARACTER-STYLE))

1;;; Compatibility with Release 6 transmission templates.
0(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :FONTS-FROM-DRAFT)
	   (PLIST &OPTIONAL NO-HEADER)
  (IGNORE NO-HEADER)
  (UNLESS (GET PLIST 'COMPUTED-CHARACTER-TYPE-MAPPINGS)
    (SEND SELF :EXPANSION-KEYWORD :CHARACTER-TYPE-MAPPINGS-FROM-DRAFT PLIST)))

1;;; Compatibility with older Release 7 transmission templates.
0(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :CHARACTER-STYLES-FROM-DRAFT) (PLIST)
  (UNLESS (GET PLIST 'COMPUTED-CHARACTER-TYPE-MAPPINGS)
    (SEND SELF :EXPANSION-KEYWORD :CHARACTER-TYPE-MAPPINGS-FROM-DRAFT PLIST)))

1;;; Compute the draft's 0Character-Type-Mappings1, 0Fonts1, and 0Japanese1 fields --
;;;    The 0Fonts1 and 0Japanese1 fields are computed to provide compatibility with Release 6.
0(DEFMETHOD (:EXPANSION-KEYWORD TRANSMISSION-TEMPLATE :CHARACTER-TYPE-MAPPINGS-FROM-DRAFT)
	   (PLIST)
  (UNLESS (GET PLIST 'COMPUTED-DEFAULT-CHARACTER-STYLE)
    1;; We can't do our work here without already having computed the default character style.
0    (FERROR "Can't compute a draft's character type mappings ~
	     without knowing its default character style."))
  (UNLESS (GET PLIST 'COMPUTED-CHARACTER-TYPE-MAPPINGS)
    (LET* ((CHARACTER-TYPE-MAPPINGS (COMPUTE-DRAFT-CHARACTER-TYPE-MAPPINGS PLIST))
	   (DEFAULT-CHARACTER-STYLE (CL:GETF (GET PLIST :HEADERS) :DEFAULT-CHARACTER-STYLE))
	   (FONTS (FONTS-FROM-CHARACTER-TYPE-MAPPINGS DEFAULT-CHARACTER-STYLE
						      CHARACTER-TYPE-MAPPINGS))
	   (JAPANESE (JAPANESE-FROM-CHARACTER-TYPE-MAPPINGS CHARACTER-TYPE-MAPPINGS)))
      (WHEN CHARACTER-TYPE-MAPPINGS
	(SEND SELF :ADD-HEADER PLIST :CHARACTER-TYPE-MAPPINGS CHARACTER-TYPE-MAPPINGS))
      (WHEN FONTS
	(SEND SELF :ADD-HEADER PLIST :FONTS FONTS))
      (WHEN JAPANESE
	(SEND SELF :ADD-HEADER PLIST :JAPANESE JAPANESE)))
    (PUTPROP PLIST T 'COMPUTED-CHARACTER-TYPE-MAPPINGS)))

;;; Hybrid
(DEFINE-TEMPLATE-TYPE LOCAL-MAIL-TEMPLATE :LOCAL ()
		      (COMPOSITION-TEMPLATE TRANSMISSION-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD LOCAL-MAIL-TEMPLATE :LOCAL-BUFFER) (PLIST BUFFER)
  (PUTPROP PLIST BUFFER ':LOCAL-BUFFER))

(DEFINE-TEMPLATE-TYPE REDISTRIBUTE-COMPOSITION-TEMPLATE :REDISTRIBUTE-COMPOSE ()
		      (COMPOSITION-TEMPLATE))

(DEFINE-TEMPLATE-TYPE REDISTRIBUTE-TRANSMISSION-TEMPLATE :REDISTRIBUTE-TRANSMIT ()
		      (TRANSMISSION-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD REDISTRIBUTE-TRANSMISSION-TEMPLATE :HEADERS-FROM-MSG)
	   (PLIST &OPTIONAL (TEMPLATE 'REDISTRIBUTE-HEADERS-REFORMAT-TEMPLATE))
  (LET* ((MSG (SEND (GET PLIST ':DRAFT-MSG) ':MSG))
	 (HEADERS-INTERVAL (COPY-MSG-HEADERS-THROUGH-TEMPLATE MSG TEMPLATE)))
    (SEND SELF ':ADD-HEADER PLIST 'LITERAL-HEADERS HEADERS-INTERVAL)))

(DEFMETHOD (:EXPANSION-KEYWORD REDISTRIBUTE-TRANSMISSION-TEMPLATE
			       :DEFAULT-CHARACTER-STYLE-FROM-MSG)
	   (PLIST)
  (UNLESS (GET PLIST 'COMPUTED-DEFAULT-CHARACTER-STYLE)
    (LET* ((MSG (SEND (GET PLIST :DRAFT-MSG) :MSG))
	   (DEFAULT-CHARACTER-STYLE (OR (MSG-DEFAULT-CHARACTER-STYLE MSG)
					*ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)))
      (UNLESS (EQ DEFAULT-CHARACTER-STYLE *ZMAIL-DEFAULT-DEFAULT-CHARACTER-STYLE*)
	(SEND SELF :ADD-HEADER PLIST :DEFAULT-CHARACTER-STYLE DEFAULT-CHARACTER-STYLE)))
    (PUTPROP PLIST T 'COMPUTED-DEFAULT-CHARACTER-STYLE)))

(DEFWHOPPER (:EXPANSION-KEYWORD REDISTRIBUTE-TRANSMISSION-TEMPLATE) (KEYWORD &REST ARGS)
  (IF (EQ KEYWORD :CHARACTER-TYPE-MAPPINGS-FROM-DRAFT)
      (WITH-STACK-LIST* (*FONT-CONVERTED-HEADER-LINES*
			  'LITERAL-HEADERS *FONT-CONVERTED-HEADER-LINES*)
	(LEXPR-CONTINUE-WHOPPER KEYWORD ARGS))
    (LEXPR-CONTINUE-WHOPPER KEYWORD ARGS)))

;;; Redirection (to different adressees, with audit trail)
(DEFINE-TEMPLATE-TYPE REDIRECT-COMPOSITION-TEMPLATE :REDIRECT-COMPOSE ()
		      (REDISTRIBUTE-COMPOSITION-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :ONLY-REMOVED-RECIPIENTS)
	   (PLIST)
  (SETF (GET PLIST :DO-REPLY-TO)
	(APPEND (GET PLIST :DO-REPLY-TO) (COPYTREE (GET PLIST :REMOVED-RECIPIENTS)))))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :REMOVE-REMOVED-RECIPIENTS)
	   (PLIST)
  (SETF (GET PLIST :DONT-REPLY-TO)
	(APPEND (GET PLIST :DONT-REPLY-TO) (COPYTREE (GET PLIST :REMOVED-RECIPIENTS)))))

;; bad modularity: this must come after any other keyword that fills the same field.
(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :ADD-ADDED-RECIPIENTS)
	   (PLIST FIELD)
  (PUTPROP (LOCF (GET PLIST :HEADERS))
	   (NCONC (GET (LOCF (GET PLIST :HEADERS)) FIELD)
		  (COPYTREE (GET PLIST :ADDED-RECIPIENTS))) FIELD))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :REDIRECTED-TEXT)
	   (PLIST REF-TEXT)
  (LET* ((ADDED (LOOP FOR ADR IN (GET PLIST :ADDED-RECIPIENTS)
		      COLLECT (STRING-FROM-HEADER ADR :USE-ORIGINAL)))
	 (REMOVED (LOOP FOR ADR IN (GET PLIST :REMOVED-RECIPIENTS)
			COLLECT (STRING-FROM-HEADER ADR :USE-ORIGINAL)))
	 (COMMENT (GET PLIST :REDIRECT-COMMENT))
	 (STRING (FORMAT NIL "[~A message has been redirected:~@
  ~2T~~:[~*~;~A~@
       ~]~2T~~:[~3*~;~{~A~^, ~} ~:[have~;has~] been removed~:[~;;~@
       ~]~]~:[~2*~;~{~A~^, ~} ~:[have~;has~] been added~].]~~~&"
			REF-TEXT (AND COMMENT (NOT (STRING-EQUAL COMMENT ""))) COMMENT
			REMOVED REMOVED (= 1 (LENGTH REMOVED))
			ADDED ADDED ADDED (= 1 (LENGTH ADDED)))))
    (SEND SELF :ADD-TEXT PLIST STRING)
    (PUTPROP PLIST STRING :REDIRECTED-TEXT)))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :REFERENCES)
	   (PLIST)
  (SEND SELF ':ADD-HEADER PLIST :REFERENCES (GENERATE-REFERENCE-HEADER (GET PLIST ':MSGS))))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :SUPERSEDES)
	   (PLIST &REST REFERENCES)
  (IF REFERENCES
      (LOOP FOR REFERENCE IN REFERENCES
	    AS VAL = (EVAL REFERENCE)
	    WHEN VAL
	      NCONC (IF (EQ VAL :CURRENT-MSGS)
			(LOOP FOR MSG IN (GET PLIST ':MSGS)
			      AS STATUS = (ASSURE-MSG-PARSED MSG)
			      COLLECT (GENERATE-REFERENCE-HEADER-FROM-HEADERS (CDR STATUS)))
		      (NCONS (LIST :MESSAGE-ID VAL))) INTO SUP-LIST
	    FINALLY (WHEN SUP-LIST (SEND SELF ':ADD-HEADER PLIST :SUPERSEDES SUP-LIST)))
    (SEND SELF ':ADD-HEADER PLIST :SUPERSEDES
	  (LOOP FOR MSG IN (GET PLIST ':MSGS)
		AS STATUS = (ASSURE-MSG-PARSED MSG)
		COLLECT (GENERATE-REFERENCE-HEADER-FROM-HEADERS (CDR STATUS))))))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :HEADERS-FROM-REFERENCED-MSG)
	   (PLIST &REST HEADERS)
  (LOOP FOR MSG IN (GET PLIST :MSGS)
	DO (LOOP FOR HEADER IN HEADERS
		 AS CONTENTS = (MSG-GET MSG HEADER)
		 WHEN CONTENTS
		   DO (SEND SELF ':ADD-HEADER PLIST HEADER CONTENTS))))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :HEADERS-FROM-REFERENCED-MSG-EXCEPT)
	   (PLIST &REST HEADERS)
  (LOOP FOR MSG IN (GET PLIST :MSGS)
	DO (LOOP FOR PL ON (CAR (ASSURE-MSG-PARSED MSG)) BY 'CDDR
		 AS TYPE = (CAR PL)
		 AS CONTENTS = (CADR PL)
		 WHEN (EQ (SYMBOL-PACKAGE TYPE) (PKG-FIND-PACKAGE "keyword"))
		   UNLESS (MEMQ TYPE HEADERS)
		     DO (SEND SELF ':ADD-HEADER PLIST TYPE CONTENTS))))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :REMOVED-REDIRECT-HEADERS)
	   (PLIST &REST PAIRS)
  "Arguments are lists of (reply-header-type original-header-type)"
  (SEND SELF :REMOVED-REDIRECT-HEADERS PLIST PAIRS))

(DEFMETHOD (:REMOVED-REDIRECT-HEADERS REDIRECT-COMPOSITION-TEMPLATE) (PLIST PAIRS)
  (MAKE-REMOVED-REDIRECT-HEADERS PLIST PAIRS))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :RETAINED-REDIRECT-HEADERS)
	   (PLIST &REST PAIRS)
  "Arguments are lists of (reply-header-type original-header-type)"
  (SEND SELF :RETAINED-REDIRECT-HEADERS PLIST PAIRS)) 

(DEFMETHOD (:RETAINED-REDIRECT-HEADERS REDIRECT-COMPOSITION-TEMPLATE) (PLIST PAIRS)
  (MAKE-REPLY-HEADERS PLIST PAIRS NIL))

(DEFUN MAKE-REMOVED-REDIRECT-HEADERS (PLIST PAIRS)
  (LOOP WITH DO-REPLY-TO = (GET PLIST ':DO-REPLY-TO)
	AND MSGS = (GET PLIST ':MSGS)
	AND FORMAT = (GET PLIST ':HEADER-FORMAT)
	AND ALREADY-DONE = NIL
	FOR (OUTPUT-TYPE INPUT-TYPE) IN PAIRS
	AS HEADER = (IF (NOT (HEADER-TYPE-TYPEP INPUT-TYPE ':ADDRESS))
			(LOOP FOR MSG IN MSGS
			      AS STATUS = (ASSURE-MSG-PARSED MSG)
			      THEREIS (GET STATUS INPUT-TYPE))
			(LOOP FOR MSG IN MSGS
			      AS STATUS = (ASSURE-MSG-PARSED MSG)
			      AS RCPT = (REMOVED-REDIRECT-HEADER-TRIM 
					  (GET STATUS INPUT-TYPE) DO-REPLY-TO FORMAT)
			      APPEND (REPLY-HEADER-TRIM
				       (REPLY-HEADER-TRIM RCPT ALREADY-DONE NIL FORMAT)
				       HEADERS NIL FORMAT)
			        INTO HEADERS
			      FINALLY (SETQ ALREADY-DONE (APPEND ALREADY-DONE
								 HEADERS))
				      (RETURN HEADERS)))
	WHEN HEADER
	  COLLECT OUTPUT-TYPE INTO HEADERS AND COLLECT HEADER INTO HEADERS
	FINALLY (PUTPROP PLIST (LOOP WITH OLD = (GET PLIST :HEADERS)
				     FOR PL ON HEADERS BY 'CDDR
				     AS TYPE = (CAR PL)
				     AS CONTENTS = (CADR PL)
				     DO (PUTPROP (LOCF OLD)
						 (NCONC (GET (LOCF OLD) TYPE) CONTENTS) TYPE)
				     FINALLY (RETURN OLD))
			 :HEADERS)))

(DEFUN REMOVED-REDIRECT-HEADER-TRIM (LIST-TO-TRIM LIST-TO-RETAIN FORMAT
				     &OPTIONAL STAR-SPECIAL)
  (LOOP FOR NEW IN LIST-TO-TRIM
	UNLESS (OR (WARN-OF-UNANSWERABLE-HEADER NEW FORMAT)
		   (MEMQ NEW INFERIORS)
		   (NOT (LOOP FOR OLD IN LIST-TO-RETAIN
			      THEREIS (REPLY-HEADER-TRIM-EQUAL NEW OLD STAR-SPECIAL))))
	COLLECT NEW
	WHEN (AND (GETL (LOCF NEW) '(:DISTRIBUTION-LIST :BRACKETED-LIST))
		  (EQ FORMAT ':USE-ORIGINAL))
	NCONC (GET-HEADER-INFERIORS NEW) INTO INFERIORS))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-COMPOSITION-TEMPLATE :TEXT-FROM-MSGS)
	   (PLIST &REST OPTIONS)
  (SETQ OPTIONS (LOOP FOR (OPT VAL) ON OPTIONS BY 'CDDR
		      COLLECT OPT COLLECT (EVAL VAL)))
  (LET ((INT (CREATE-INTERVAL)))
    (LEXPR-FUNCALL #'INSERT-TEXT-OF-MSGS
		   (GET PLIST ':MSGS)
		   (INTERVAL-LAST-BP INT) nil
		   OPTIONS)
    (SEND SELF ':ADD-TEXT PLIST INT)))

(DEFINE-TEMPLATE-TYPE REDIRECT-TRANSMISSION-TEMPLATE :REDIRECT-TRANSMIT
		      ()
		      (REDISTRIBUTE-TRANSMISSION-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD REDIRECT-TRANSMISSION-TEMPLATE :STANDARD-MESSAGE-ID)
	   (PLIST &OPTIONAL (HEADER-TYPE ':MESSAGE-ID))
  (UNLESS (GET (LOCF (GET PLIST :HEADERS)) HEADER-TYPE)
    (SEND SELF ':ADD-HEADER PLIST HEADER-TYPE
	  (GENERATE-STANDARD-MESSAGE-ID
	    (GET PLIST ':TRANSMIT-TIME)
	    (LET ((DRAFT-MSG (GET PLIST ':DRAFT-MSG)))
	      (AND DRAFT-MSG (SECOND (SEND DRAFT-MSG ':TRANSMIT-TIMESTAMP)))))))
  (WHEN (EQ HEADER-TYPE :MESSAGE-ID)
    (LET ((DRAFT-MSG (GET PLIST ':DRAFT-MSG)))
      (WHEN DRAFT-MSG
	(SEND DRAFT-MSG :SET-TRANSMITTED-MESSAGE-ID
	      (GET (LOCF (GET PLIST :HEADERS)) :MESSAGE-ID))))))

;;;; Compatibility with old init files
(DEFFLAVOR COMPATIBLE-TEMPLATE-MIXIN () ()
  (:REQUIRED-FLAVORS TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD COMPATIBLE-TEMPLATE-MIXIN :COMPATIBLE-HEADER-FORMAT)
	   (PLIST OPTION)
  (PUTPROP PLIST (EVAL OPTION) ':HEADER-FORMAT))

(DEFINE-TEMPLATE-TYPE COMPATIBLE-COMPOSITION-TEMPLATE :COMPATIBLE-COMPOSE
		      () (COMPATIBLE-TEMPLATE-MIXIN COMPOSITION-TEMPLATE))

(DEFINE-TEMPLATE-TYPE COMPATIBLE-MAIL-TEMPLATE :COMPATIBLE-MAIL
		      () (COMPATIBLE-TEMPLATE-MIXIN MAIL-TEMPLATE))

(DEFINE-TEMPLATE-TYPE COMPATIBLE-FORWARD-TEMPLATE :COMPATIBLE-FORWARD
		      () (COMPATIBLE-TEMPLATE-MIXIN FORWARD-TEMPLATE))

(DEFINE-TEMPLATE-TYPE COMPATIBLE-LOCAL-MAIL-TEMPLATE :COMPATIBLE-LOCAL
		      () (COMPATIBLE-TEMPLATE-MIXIN LOCAL-MAIL-TEMPLATE))

(DEFINE-TEMPLATE-TYPE COMPATIBLE-TRANSMISSION-TEMPLATE :COMPATIBLE-TRANSMIT
		      () (COMPATIBLE-TEMPLATE-MIXIN TRANSMISSION-TEMPLATE))

(DEFINE-TEMPLATE-TYPE COMPATIBLE-REPLY-TEMPLATE :COMPATIBLE-REPLY
		      () (COMPATIBLE-TEMPLATE-MIXIN REPLY-TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD COMPATIBLE-REPLY-TEMPLATE :COMPATIBLE-DONT-REPLY-TO)
	   (PLIST)
  (PUTPROP PLIST
	   (APPEND (GET PLIST :DONT-REPLY-TO) (COPYLIST *DONT-REPLY-TO*)) ':DONT-REPLY-TO))

(DEFMETHOD (:EXPANSION-KEYWORD COMPATIBLE-REPLY-TEMPLATE :COMPATIBLE-REPLY-MODES)
	   (PLIST REPLY-MODE REPLY-WINDOW-MODE)
  (SEND SELF ':COMPATIBLE-REPLY-MODES PLIST (EVAL REPLY-MODE) (EVAL REPLY-WINDOW-MODE)))

(DEFVAR *COMPATIBLE-REPLY-MODE-ALIST*
  '((:ALL (:TO :SENDER) (:TO :TO) (:CC :CC))
    (:ALL-CC (:TO :SENDER) (:CC :TO) (:CC :CC))
    (:CC-ALL (:TO :TO) (:CC :SENDER) (:CC :CC))
    (:TO (:TO :SENDER) (:TO :TO))
    (:TO-CC (:TO :SENDER) (:CC :TO))
    (:CC-TO (:TO :TO) (:CC :SENDER))
    (:SENDER (:TO :SENDER))))

(DEFMETHOD (:COMPATIBLE-REPLY-MODES COMPATIBLE-REPLY-TEMPLATE)
	   (PLIST REPLY-MODE REPLY-WINDOW-MODE &OPTIONAL (PRUNE-HEADERS NIL PH-GIVEN))
  (PUTPROP PLIST (SELECTQ REPLY-WINDOW-MODE
		   (:TWO-WINDOWS :REPLY)
		   (:ONE-WINDOW :MAIL)
		   (:YANK
		    (LET-IF PH-GIVEN
			    ((*PRUNE-HEADERS-AFTER-YANKING* PRUNE-HEADERS))
		      (LET ((INT (CREATE-INTERVAL)))
			(INSERT-TEXT-OF-MSGS (GET PLIST :MSGS)
					     (INTERVAL-LAST-BP INT)
					     NIL	;Formally the FONTS-ALIST
					     :INDENTED T
					     :TEMPLATE 'REPLY-YANK-REFORMAT-TEMPLATE)
			(SEND SELF :ADD-TEXT PLIST INT)))
		    :MAIL))
	   :WINDOW-CONFIGURATION)
  (SEND SELF :REPLY-HEADERS PLIST (CDR (ASSQ REPLY-MODE *COMPATIBLE-REPLY-MODE-ALIST*))))

(DEFMETHOD (:EXPANSION-KEYWORD COMPATIBLE-REPLY-TEMPLATE :COMPATIBLE-CHOOSE-REPLY-MODES)
	   (PLIST)
  (MULTIPLE-VALUE-BIND (REPLY-MODE REPLY-WINDOW-MODE PRUNE-HEADERS-MODE)
      (DEFAULTED-MULTIPLE-MENU-CHOOSE-NEAR-MENU *REPLY-MODES-ALIST*
						*REPLY-MODE* *REPLY-WINDOW-MODE*
						(SELECTQ *PRUNE-HEADERS-AFTER-YANKING*
						  (NIL :DONT-PRUNE)
						  (T :PRUNE)))
    (SEND SELF :COMPATIBLE-REPLY-MODES PLIST REPLY-MODE REPLY-WINDOW-MODE
					     (SELECTQ PRUNE-HEADERS-MODE
					       (:PRUNE T)
					       (:DONT-PRUNE NIL)))))

(DEFMETHOD (:INIT COMPATIBLE-REPLY-TEMPLATE :AFTER) (IGNORE)
  (LET ((OLD-MENU-NAME MENU-NAME))
    (SETQ MENU-NAME (MAKE-EMPTY-STRING 20.))
    (APPEND-TO-ARRAY MENU-NAME OLD-MENU-NAME)))

(DEFMETHOD (:MENU-NAME COMPATIBLE-REPLY-TEMPLATE :BEFORE) (&AUX EXP)
  (COND ((SETQ EXP (ASSQ ':COMPATIBLE-REPLY-MODES EXPANSION))
	 (SETF (FILL-POINTER MENU-NAME) 0)
	 (APPEND-TO-ARRAY MENU-NAME
			  (NAME-FROM-MENU-VALUE (EVAL (SECOND EXP))
						(CAR *REPLY-MODES-ALIST*)))
	 (APPEND-TO-ARRAY MENU-NAME " // ")
	 (APPEND-TO-ARRAY MENU-NAME
			  (NAME-FROM-MENU-VALUE (EVAL (THIRD EXP))
						(CADR *REPLY-MODES-ALIST*))))))

;;;; Header refomatting

(DEFINE-TEMPLATE-TYPE REFORMAT-TEMPLATE :REFORMAT () (TEMPLATE))

(DEFMETHOD (:EXPANSION-KEYWORD REFORMAT-TEMPLATE :HEADER-FORMAT)
	   (PLIST FORMAT)
  (PUTPROP PLIST FORMAT ':HEADER-FORMAT))

(DEFMETHOD (:EXPANSION-KEYWORD REFORMAT-TEMPLATE :PRESERVE-ORDER) (PLIST)
  (PUTPROP PLIST T ':PRESERVE-ORDER))

(DEFMETHOD (:EXPANSION-KEYWORD REFORMAT-TEMPLATE :HEADERS-FROM-ORIGINAL)
	   (PLIST &REST HEADERS)
  (SETF (GET PLIST ':HEADERS-FROM-ORIGINAL)
	(APPEND (GET PLIST ':HEADERS-FROM-ORIGINAL) (COPYLIST HEADERS))))

(DEFMETHOD (:EXPANSION-KEYWORD REFORMAT-TEMPLATE :HEADERS-FROM-ORIGINAL-EXCEPT)
	   (PLIST &REST HEADERS)
  (PUTPROP PLIST (COPYLIST HEADERS) ':HEADERS-FROM-ORIGINAL-EXCEPT))

(DEFMETHOD (:EXPANSION-KEYWORD REFORMAT-TEMPLATE :REFORMAT-HEADER-TYPES)
	   (PLIST &REST TYPES)
  (SETF (GET PLIST ':REFORMAT-HEADER-TYPES)
	(APPEND (GET PLIST ':REFORMAT-HEADER-TYPES) (COPYLIST TYPES))))

(DEFMETHOD (:EXPANSION-KEYWORD REFORMAT-TEMPLATE :DATE-FORMAT) (PLIST FORMAT)
  (PUTPROP PLIST FORMAT ':DATE-FORMAT))

(COMPILE-FLAVOR-METHODS REFORMAT-TEMPLATE)
