;;; -*- Mode: LISP; Package: neti; Base: 10; Lowercase: Yes; Syntax: zetalisp -*-
;; Internet Domain stuff
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|
(defun zwei:translate-domain-host-1 (domain host-name)
  (let ((ns (mailer:find-namespace-from-domain domain)))
    (or (neti:searching-one-namespace (ns)
	  (net:find-object-named :host host-name nil))
	(query-domain-host ns host-name))))
|#

#|
(defun mailer:find-namespace-from-domain (dotname)
  (let ((neti:*inhibit-validity-checking* t))
    (or (loop for ns in (send net:*namespace* :objects-of-class :namespace)
	      when (equal dotname (send ns :get :internet-domain-name))
		return ns)
	(neti:add-or-change-object
	  :namespace (neti:parse-and-intern-name :namespace dotname net:*namespace* nil)
	  `(:search-rules (neti:**self**) :internet-domain-name ,dotname
			  :primary-name-server
			  (,(net:get-host-from-address
			      (tcp:parse-internet-address "10.0.0.51")
			      :internet nil :service '((:namespace :udp :domain)))))
	  
	  net:*namespace*))))
|#

(dw:define-program-framework
  domain-server-log-program
  :pretty-name "Domain Server Log"
  :command-definer define-domain-server-log-command
  :command-table (:inherit-from '("colon full command"
				  "standard arguments"
				  "standard scrolling"
				  "global")
		  :kbd-accelerator-p nil)
  :configurations `((main
		      (:layout
			(main :column title log command-menu listener))
		      (:sizes
			(main
			  (title 1 :lines)
			  :then (command-menu :ask-window self :size-for-pane command-menu)
			  :then (log 0.75)
			  :then (listener :even)))))
  :panes ((log :display
	       :more-p nil
	       :end-of-page-mode :scroll
	       :deexposed-typeout-action :permit
	       :margin-components
	       '((dw::margin-borders)
		 (dw::margin-scroll-bar)
		 (dw::margin-white-borders :thickness 3)
		 (dw::margin-label
		   :string "Domain Server Log"
		   :style (:sans-serif :italic :normal))))
	  (listener :listener
		    :more-p nil
		    :margin-components
		    '((dw::margin-borders)
		      (dw::margin-scroll-bar)
		      (dw::margin-white-borders)))
	  (command-menu :command-menu
			:margin-components
			'((dw::margin-borders)
			  (dw::margin-white-borders)
			  (dw::margin-label
			    :string "Domain Server Commands"
			    :style (:sans-serif :italic :normal))))
	  (title :title :redisplay-string "Domain Server"))
  :state-variables ((log-monitor)))

(define-domain-server-log-command (com-load-domain-file :menu-accelerator "Load")
				  ((file 'fs:pathname)
				   (origin 'cl:string :confirm t))
  (initialize-log-monitor-early)
  (domain-load-file file origin t))

(define-domain-server-log-command (com-clear-log-history :menu-accelerator "Clear")
				  ()
   (initialize-log-monitor-early)
   (send (dw:get-program-pane 'log) :clear-history))

(define-domain-server-log-command (com-launch-domain-server :menu-accelerator "Launch")
    ((file 'fs:pathname :default (fs:parse-pathname "SYS:SITE;LAUNCH-DOMAIN-SERVER.TEXT")))
   (initialize-log-monitor-early)
   (launch-domain-server t file))

(define-domain-server-log-command
  (com-land-domain-server :menu-accelerator "Land") ()
   (land-domain-server))

(defflavor domain-server-log
	(program
	 frame)
	su::(log-interactive-mixin
	    log-hosts-mixin log-file-mixin log-monitor-mixin basic-log)
  (:initable-instance-variables program frame)
  (:writable-instance-variables program frame)
  )

(defmethod (su:server-description domain-server-log) (open-reason)
  open-reason
  "Logs requests made of a domain server")

(defvar *domain-server-log* nil)

(defvar *domain-server-enabled* nil "T if server is open for business")

(defvar *server-primary-domains* nil "Domains we are primary server for")

(defvar *server-secondary-domains* nil "Domains we are a secondary for")

(compile-flavor-methods domain-server-log)

#| These are not used until such time as domains can take user directed maintainance direction

(defun query-domain-host (namespace host-name)
  (let ((nap (neti:invoke-service-on-host
	       :domain (first (send namespace :get :primary-name-server)))))
    (multiple-value-bind (success list)
	(send nap :query namespace :host
	      :name (neti:parse-and-intern-name :host host-name namespace nil))
      (when success
	(first list)))))
|#

#|
(defmethod (domain-init-namespace domain-access-path) (namespace)
  (cond ((null internet-namespace)
	 (setf internet-namespace namespace)
	 (setf domain-name (domain-cvt-namespace-name internet-namespace))
	 (multiple-value-bind (ignore network ignore)
	     (neti:decode-service-access-path-for-medium neti:service-access-path)
	   (setf internet-network network)))
	((eq internet-namespace namespace))
	(t (error "You can only use one namespace a domain server."))))
|#
;;;

#|
(defmethod (:delete-object domain-access-path) (namespace object on-behalf-of)
  object on-behalf-of
  (domain-init-namespace self namespace)
  (error "Can't do maintenance operations yet."))
|#

#|
(defmethod (:get-brief-incremental-update domain-access-path) (namespace starting-timestamp)
  starting-timestamp
  (domain-init-namespace self namespace)
  (send namespace :set-latest-validation-timestamp
	(send self :get-latest-timestamp namespace)))
|#

#|
(defmethod (:get-full-incremental-update domain-access-path) (namespace starting-timestamp)
  starting-timestamp
  (domain-init-namespace self namespace)
  (error "Can't do maintenance operations yet."))
|#

#|
(defmethod (:get-latest-timestamp domain-access-path) (namespace)
  (domain-init-namespace self namespace)
  (time:get-universal-time))
|#

#|
(defmethod (:query domain-access-path)
	   (namespace class &key name &allow-other-keys &rest property-list)
  (domain-init-namespace self namespace)
  (block query
    (loop do
      (select class
	(:host
	 (if name
	     (let* ((dname (list* (send name :string) domain-name))
		    (response (send self :transaction
				    `(:opcode :query :query t :recursion-desired t
					      :questions ((,dname :* :internet)))))
		    (answer (zl:get (locf response) :answers))
		    (new-plist))
	       (loop for (nil type nil nil val) in answer
		     do (select type
			  (:address (push (list internet-network val)
				    (zl:get (locf new-plist) :address)))
			  (:canonical-name (setf dname val))
			  (:host-info
			   (setf (zl:get (locf new-plist) :machine-type)
				 (nic-to-machine-type (first val)))
			   (setf (zl:get (locf new-plist) :system-type)
				 (nic-to-system-type (second val))))))
	       (when new-plist
		 (return-from query
		   (values t
			   (list (neti:add-or-change-object
				   class (neti:parse-name (first dname) nil namespace)
				   new-plist namespace)))))
	       (let ((authorities (zl:get (locf response) :authorities)))
		 (unless authorities
		   (return-from query (values t nil)))
		 (domain-set-namespace-server namespace (zwei:translate-domain-host (rr-rdata (first authorities))))))
	     (return-from query nil)))
	(:namespace
	 (return-from query
	   (values t (when (and (or (null name)
				    (eq name (send internet-namespace :name)))
				(neti:find-object-from-property-list-compare
				  internet-namespace :namespace property-list))
		       (list internet-namespace)))))
	(otherwise
	 (return-from query (values t nil)))))))
|#

#|
(defmethod (:reload-namespace domain-access-path) (namespace)
  (domain-init-namespace self namespace)
  (error "Can't do maintenance operations yet."))
|#

#|
(defmethod (:update-object domain-access-path) (namespace object on-behalf-of)
  object on-behalf-of
  (domain-init-namespace self namespace)
  (error "Can't do maintenance operations yet."))
|#

#| Obsolete
(defmethod (:query namespace-domain) (query)
  (domain-query-internal self (rr-name-list query) (rr-type query) (rr-class query)))
|#

#|
(defmethod (domain-query-internal namespace-domain) (name type &optional (class :internet))
  (net:keeping-namespace-server
    (loop with ns-name = (neti:parse-name (first name) nil namespace)
	  with authoritative-p = t
	  with *domain-rrs* = nil
	  with *domain-additional-rrs* = nil
	  with *domain-rrs-examined* = nil
	  for ns-class in '(:host :user)
	  for object = (condition-case ()
			    (neti:find-object-named-in-namespace ns-class ns-name namespace)
			  (net:object-not-found nil))
	  when object
	    do (setq authoritative-p 
		     (and authoritative-p (multiple-value-bind (then now)
					      (send object ':check-validity)
					    (or then now))))	; we'll accept either
	       (domain-rrs-for-object-internal object namespace class type)
	       (when (and (not (eq ns-name (send object :primary-name namespace)))
			  (or *domain-rrs-examined*
			      (eq type :canonical-name)))
		 (push (make-rr name-list name type :canonical-name class class
				rdata (domain-cvt-primary-name object namespace))
		       *domain-rrs*))
	  finally (return (values *domain-rrs*	; the data
				  authoritative-p	; authoritative flag for caller
				  *domain-additional-rrs*
				  *domain-rrs-examined*)))))
|#

#|
(defmethod (:iquery namespace-domain) (query)
  (net:keeping-namespace-server
    (with-stack-list (neti:*namespace-search-list* namespace)
      (cond ((and (memq (rr-type query) '(:canonical-name :mailbox-for-user 
					  :mail-delivery :mail-forwarding 
					  :mail-group :mail-rename))
		  (not (equal (send self :domain-name) (cdr (rr-rdata query)))))	;rest1
	     nil)
	    ((eq (rr-type query) :canonical-name)
	     (let ((object (or (net:find-object-named :host (first (rr-rdata query)) nil)
			       (net:find-object-named :user (first (rr-rdata query)) nil))))
	       (when object
		 (loop with primary-name = (send object :primary-name namespace)
		       for name in (send object :names)
		       unless (eq name primary-name)
			 collect (make-rr name-list (list* (send name :string)
							   (domain-cvt-namespace-name
							     (send name :namespace))) 
					  type (rr-type query) class (rr-class query))))))
	    (T (loop with args = 
		       (select (rr-type query)
			 (:address `(:host ,namespace
				     :address ((,(domain-class-to-network (rr-class query))
						,(rr-rdata query)))))
			 (:name-server)
			 (:mail-delivery `(:host ,namespace
					   :name ,(neti:parse-name (first (rr-rdata query))
								   nil namespace)
					   :service ((:mail-to-user :* :*))))
			 (:mail-forwarding (let ((host (net:find-object-named
							 :host (first (rr-rdata query)) nil)))
					     (when (and host (assq :store-and-forward-mail
								   (send host :service)))
					       `(:host ,namespace
						 :service ((:mail-to-user :* :*))
						 :site ,(send host :site)))))
			 ;;(:canonical-name)
			 (:start-of-authority)
			 (:mailbox-for-user
			  `(:user ,namespace
			    :mail-address (:* ,(net:find-object-named
						 :host (first (rr-rdata query))))))
			 (:mail-group)
			 (:mail-rename)
			 (:null-rr)
			 (:well-known-services)
			 (:pointer)
			 (:host-info
			  `(:host ,namespace
			    :machine-type ,(nic-to-machine-type
					     (first (rr-rdata query)))
			    :system-type ,(nic-to-system-type
					    (second (rr-rdata query)))))
			 (:mail-info)
			 )
		     for object in (when args
				     (global:lexpr-funcall
				       #'neti:find-objects-from-property-list-in-namespace
				       args))
		     collect (make-rr name-list (domain-cvt-primary-name object namespace) 
				      type (rr-type query) class (rr-class query))
		       ))))))
|#

#|
(defmethod (:authorities namespace-domain) (class)
  (let ((*domain-rrs* nil) (*domain-additional-rrs* nil) (*domain-rrs-examined* nil))
    (loop for host in (append (send namespace :primary-name-server)
			      (send namespace :secondary-name-server))
	  unless (eq host net:*local-host*)
	    do (let ((pname (domain-cvt-primary-name host namespace)))
		 (push (make-rr name-list (domain-cvt-namespace-name namespace)
				class class type :name-server rdata pname)
		       *domain-rrs*)
		 (domain-find-additional-rrs pname class :address)))
    (values *domain-rrs* *domain-additional-rrs* *domain-rrs-examined*)))
|#

(defun domain-class-to-network (class)
  (when (memq class '(:internet))
    (net:find-object-named :network (select class
				      (:internet "internet|internet")))))


;;;

(defflavor domain-server-mixin (record-stream) ()
  :abstract-flavor)

(defvar *domain-server-request* ())


;;;
;;; This function is called by the server to do queries on behalf of clients.
;;; It's rather similar to the usual domain-query, but behaves slightly differently
;;; with regard to authoritativeness and CNAME records.  Some, or all of this
;;; behaviour maybe should end up in system, but this code needs a rethink before that
;;; can happen.
;;;
(defun domain-server-query (name-list &optional (query-type ':*) (query-class ':*)
			    (ask-server-if-not-in-cache t)
			    (ok-to-recurse-internally t))
  (declare (values answers rcode authoritative-p additional))
  ;;
  ;; first see if the domain being asked about is one that this server is authoritative for.
  ;;
  (flet ((subdomain-p (d1 d2)			; d1 is subdomain of d2
		      (and (>= (length d1) (length d2))
			   (let ((subd1 (nthcdr (- (length d1) (length d2)) d1)))
			     (loop for d1name in subd1
				   for d2name in d2
				   always (string-equal d1name d2name))))))
    (let ((local-host-authoritative (or (loop for p in *server-primary-domains* 
					      thereis (subdomain-p name-list p))
					(loop for p in *server-secondary-domains* 
					      thereis (subdomain-p name-list p)))))
      ;;
      ;; If we're asked for SOA, special case that out here.  Until somebody comes up with
      ;; a better model for rationalizing namespaces and domains, it has to be done this way,
      ;; as everything else about things in namespaces is found by asking about foo.namespace,
      ;; but this asks about the namespace itself.
      ;;
      (cond ((eq query-type ':start-of-authority)
	     (let* ((namespace (neti:find-object-from-property-list
				 :namespace :internet-domain-name
				 (format nil "~{~A~@{.~A~}~}" name-list)))
		    (soa-record (and namespace (make-soa-record-for-namespace namespace 
									      query-class))))
	       (if namespace
		   (values (list soa-record) nil t nil)
		   (domain-query name-list query-type query-class ask-server-if-not-in-cache))))
	    (t
	     ;; first find the domain object mentioned, if any
	     (let ((domain-object (or (find-namespace-domain name-list ':create)
				      (find-address-domain name-list :create)
				      (find-domain name-list 
						   (if (not local-host-authoritative)
						       ':create))))
		   answers rcode authoritative-p additional)
	       (unless domain-object
		 ;;
		 ;; if no object, and we are authoritative, return name-error
		 ;;
		 (when local-host-authoritative
		   (return-from domain-server-query (values nil ':name-error t nil)))
		 ;; try to find servers, get the info desired etc
		 (domain-query name-list query-type query-class ask-server-if-not-in-cache)
		 ;; and find the new domain object created
		 (setq domain-object (find-domain name-list)))
	       ;; Now see if there are any Cname records
	       (let ((aka (and (neq query-type :canonical-name)	;don't jump the gun
			       (domain-rrs domain-object
					   ':canonical-name ':* ':up-to-date t))))
		 (cond ((and aka ok-to-recurse-internally)
			(multiple-value-bind (answers rcode authoritative-p additional)
			    (domain-server-query (rr-rdata (first aka)) query-type query-class 
						 ask-server-if-not-in-cache nil)
			  (values (append aka answers) rcode
				  (or authoritative-p local-host-authoritative)
				  additional)))
		       (t
			(multiple-value (answers rcode authoritative-p additional)
			  (domain-query domain-object query-type query-class
					ask-server-if-not-in-cache))
			(unless additional
			  (loop for answer in answers 
				when (rr-rdata answer) 
				  do
				    (selectq (rr-type answer)
				      ((:mail-forwarding :name-server)
				       (setq additional
					     (append additional (domain-query (rr-rdata answer) ':address 
									      (rr-class answer) 
									      ask-server-if-not-in-cache))))
				      (:mail-x
				       (setq additional
					     (append additional (domain-query (second (rr-rdata answer))
									      ':address 
									      (rr-class answer) 
									      ask-server-if-not-in-cache)))))))
			(setq authoritative-p (or authoritative-p local-host-authoritative))
			;; If we are giving out authoritative information, we got a request
			;; about something we are responsible for.  If it was loaded from a file,
			;; it's ttl will be large.  Don't give out infor with time-to-live greater
			;; than 6 hr.
			(when authoritative-p
			  (loop for answer in answers do
			    (setf (rr-ttl answer) (min (rr-ttl answer) (* 6 3600.)))))
			;; And finally return
			(values (si:eliminate-duplicates (append aka answers))
				rcode authoritative-p 
				additional))))))))))



;;;
;;; I'm really sorry about these.  When I get around to it, fix these things
;;; to use code to make these log entries comprehensible instead of making
;;; format do all the work...
;;;
(defvar *domain-server-request-format-string*
	"Request from ~A: ~~{~{~{~A~@{.~A~}~} ~A ~A~*~*~@{~&~{~A~@{.~A~}~} ~A ~A~*~*~}~}~}~"
  )

;;; was "Responding: ~~{~{~&~A ~~{~{~&~{~A~@{.~A~}~} ~A ~A ~A ~A~}~}~~}~}~" 

(defvar *domain-server-response-elt-string* "~{~A~@{.~A~}~} ~A ~A ~A ~A")

(defvar 
  *domain-server-response-format-string*
  (string-append
  "Response to ~A:  ~~{~{"
  "~A ~~{~{"         *domain-server-response-elt-string* "~}"
  "~@{~&~{"           *domain-server-response-elt-string* "~}~}~}~~}"
  "~@{~&~A ~~{~{"    *domain-server-response-elt-string* "~}"
  "~@{~&~{"           *domain-server-response-elt-string* "~}~}~}~~}"
  "~}~") "Teco Lives!")

(DEFVAR *DOMAIN-BUG-RECIPIENTS* NIL)

(defmethod (:server-top-level domain-server-mixin) ()
  (when (null *domain-server-log*)
    (initialize-log-monitor-early))
  (let ((neti:*inhibit-validity-checking* t)
	(su:*log* *domain-server-log*)
	(*log-domain-requests* t)
	(*debug-domain-requests* nil)
	;;(*domain-site-servers* ())
	(*domain-default-recursion-request* ())
	(server-errors nil)
	(network-stream (send self :get-record-stream)))
    (condition-bind
      ((error 
	 #'(lambda (error)
	     (dbg:automatic-bug-report
	       error
	       :flavors '()
	       :sender "Domain-Server"
	       :recipients (OR *DOMAIN-BUG-RECIPIENTS* DBG:*AUTOBUG-RECIPIENTS*)
	       :server self)
	     (su:log-event :normal (with-output-to-string (s) (dbg:report error s)))
	     (push error server-errors)
	     (throw 'exit-query nil))))
      (catch 'exit-query
	(loop while (process-wait-with-timeout "Domain Request" (* 60 60)
		      #'send network-stream :listen)
	      for request = (domain-parse-message network-stream)			    
	      while request
	      do (when *log-domain-requests*
		   (su:log-event
		     ':normal
		     *domain-server-request-format-string*
		     (send self :foreign-host) 
		     (get (locf request) ':questions)))
	      when (get (locf request) :query)
		do (setq server-errors nil)
		   (setf (get (locf request) :query) nil)
		   (when *domain-server-enabled*
		     (catch 'exit-query
		       (select (get (locf request) :opcode)
			 (:query 
			  (let* ((query (first (get (locf request) :questions)))
				 (recursion-desired (get (locf request)
							 ':recursion-desired))
				 (rrs) (return-code) (authoritative) (additional))
			    (cond ((eq (rr-type query) ':authority-xfer)
				   (handle-zone-transfer-request request network-stream))
				  (t
				   ;;
				   ;; make sure we're not trying to create one that we're
				   ;; responsible for... later
				   ;;
				   (unless recursion-desired
				     (su:log-event ':normal "Non-recursive request"))
				   (condition-case (error)
					(progn
					  (multiple-value (rrs return-code 
							   authoritative additional)
					    ;;
					    ;; Query the domain.  If recursion requested, do
					    ;; the whole shootin match, else just return what
					    ;; we have cached, if anything.
					    ;;
					    (domain-server-query (rr-name-list query)
								 (rr-type query)
								 (rr-class query)
								 recursion-desired))
					  ;;
					  ;; If we have answers to a recursive request, and
					  ;; the data is still alive, say it's authoritative.
					  ;;
					  (when recursion-desired
					    (loop for answer in rrs 
						  do (setq authoritative
							   (or authoritative
							       (> (rr-ttl answer) 0))))))
				      (domain-resolver-error	; pass along to requestor
					(let ((error-rr (send error ':error-rr)))
					  (setf (get (locf request) ':rcode) 
						(get (locf error-rr) ':rcode)))))
				   (setf (get (locf request) ':authoritative) 
					 authoritative)
				   ;;
				   ;; If we have collected some answers here that have NIL rdata,
				   ;; don't send them along to our client.
				   ;;
				   (setf (get (locf request) ':answers) 
					 (loop for record in rrs
					       unless (null (rr-rdata record))
						 collect record))
				   ;;
				   (when (eq return-code ':name-error)
				     (setf (getf request ':rcode) ':name-error))
				   (setf (get (locf request) ':authorities) nil)
				   (setf (get (locf request) ':additional) additional)
				   (unless (or (get (locf request) ':answers)
					       authoritative recursion-desired)
				     (loop with class = (rr-class query)
					   for parent-name on (rr-name-list query)
					   do (multiple-value-bind (nsrrs nil nil adrrs)
						  (domain-server-query parent-name
								       ':name-server
								       class
								       nil)
						(when nsrrs
						  (setf (get (locf request) ':authorities) nsrrs)
						  (setf (get (locf request) ':additional) adrrs)
						  (return)))))))))
			 (:iquery
;			  (loop with query = (first (zl:get (locf request) :answers))
;				for domain being the hash-elements of *local-domain-hash-table*
;				append (send domain :iquery query) into rrs
;				finally (setf (zl:get (locf request) :questions) rrs))
			  (setf (get (locf request) :rcode) :refused))
			 (otherwise
			  (setf (zl:get (locf request) :rcode) :not-implemented)))))
		   (setf (get (locf request) ':recursion-available) t)
						; always true on
						; lispm servers
		   (when server-errors
		     (setf (get (locf request) ':rcode) ':server-failure)
		     (loop for error in server-errors do
		       (su:log-event :problem "Error: ~A" error)))
		   (when (null *domain-server-enabled*)
		     (setf (get (locf request) ':rcode) ':refused))
		   (domain-send-message network-stream request nil nil)
		   (when *log-domain-requests*
		     (su:log-event 
		       :normal
		       *domain-server-response-format-string*
		       (send self ':foreign-host)
		       (loop for tag in '(:answers :authorities :additional)
			     as stuff = (get (locf request) tag)
			     when stuff
			       collect `(,tag ,stuff))))
		   )
	)
      )
    ))



;;;

(defflavor domain-byte-stream-server () (domain-server-mixin neti:byte-stream-server))

(defmethod (:get-record-stream domain-byte-stream-server) ()
  (make-instance 'domain-byte-stream-record-stream :stream (send self :stream)))

(compile-flavor-methods domain-byte-stream-server)

(net:define-server :domain (:medium :byte-stream 
			    :stream (stream :characters ())
			    :flavor domain-byte-stream-server
			    :reject-unless-trusted nil
			    :error-disposition :ignore
			    :who-line t))

(defflavor domain-udp-server () (domain-server-mixin udp-server))

(defmethod (:get-record-stream domain-udp-server) ()
  (make-instance 'domain-udp-record-stream :stream (send self :connection)))

(compile-flavor-methods domain-udp-server)

(net:define-server :domain-simple (:medium :udp :reject-unless-trusted nil :flavor domain-udp-server))



;;;
;;; Stuff for the Domain Server Background process.
;;;

(defvar *domain-server-background* nil)		; holds the running process

(defvar *domain-server-background-to-do* nil)



;;;



(defflavor soa-request-indirect-stream
	(network-stream
	 original-query
	 answer-only)
	()
	(:initable-instance-variables))

(defmethod (:init soa-request-indirect-stream :after) (&rest ignore)
  (setf (cl:getf original-query ':query) nil)
  (setf answer-only (copytree original-query))
  (setf (cl:getf answer-only ':questions) nil))

(defmethod (:dump-rr soa-request-indirect-stream) (rr)
  (when (rr-rdata rr)
    (setf (cl:getf answer-only ':answers) (list rr))
    (domain-send-message network-stream answer-only nil nil)
    ))




(defun make-soa-record (namespace server postmaster origin &optional (class ':*))
  (make-rr name-list origin class class type :start-of-authority
	   rdata `(,server ,postmaster
		   ,(ldb (byte 16 0) (send namespace :validation-timestamp))
		   86400
		   3600
		   86400
		   3600)))



(defvar *postmaster-name-for-soa* "Postmaster")



(defun make-soa-record-for-namespace (namespace &optional (class ':*))
  (let* ((server-host-name
	   (send (first (first (send namespace ':primary-server-access-paths)))
		 ':primary-name))
	 (namespace-domain-name-list (parse-domain-style-name 
				       (send (send server-host-name ':namespace)
					     ':internet-domain-name)))
	 (server-host-domain-name-list (append (list (send server-host-name ':string))
					       namespace-domain-name-list)))
    (make-soa-record namespace server-host-domain-name-list 
		     (cons *postmaster-name-for-soa* namespace-domain-name-list)
		     namespace-domain-name-list class)))



(defun handle-zone-transfer-request (original-query network-stream)
  ;;
  ;; Find the domain, see if we are authoritative for it.
  ;;
  (let* ((name-being-asked-about (rr-name-list (first (cl:getf original-query ':questions))))
	 (namespace-tail-name (format nil "~{~A~@{.~A~}~}" name-being-asked-about))
	 (namespace (neti:find-object-from-property-list
			   :namespace :internet-domain-name
			   namespace-tail-name))
	 (domain-object (find-domain name-being-asked-about)))
    (cond (namespace
	   (keeping-namespace-server
	     (let* ((soa-record (make-soa-record-for-namespace namespace ':*))
		    (answer-stream (make-instance 'soa-request-indirect-stream 
						  ':network-stream network-stream
						  ':original-query original-query)))
	       (send answer-stream ':dump-rr soa-record)
	       (domain-dump-namespace-to-stream namespace 
						(domain-cvt-namespace-name namespace)
						answer-stream)
	       (send answer-stream ':dump-rr soa-record)
	       )))
	  ;;
	  ;; no namespace, eh?  ok, see if it's some other zone we are responsible for
	  ;;
	  ((and domain-object (authoritative domain-object))
	   (let ((soa-record (or (first (domain-query domain-object ':start-of-authority ':*))
				 (make-rr name-list name-being-asked-about
					  class ':*
					  type ':start-of-authority
					  rdata `(,(parse-domain-style-name
						     (send *local-host* ':mail-name))
						  ,(cons *postmaster-name-for-soa* 
							 (parse-domain-style-name
							   (send *local-host* ':mail-name)))
						  0
						  86400
						  3600
						  86400
						  3600))))
		 (answer-stream (make-instance 'soa-request-indirect-stream 
					       ':network-stream network-stream
						':original-query original-query)))
	     (send answer-stream ':dump-rr soa-record)
	     (maphash #'(lambda (key obj) 
			  (when (and (or (and (= (1+ (length key)) 
						 (length name-being-asked-about))
					      (equal name-being-asked-about (cdr key)))
					 (equal key name-being-asked-about))
				     (authoritative obj))
			    (loop for datum in (domain-rrs obj) do
			      (unless (eq (rr-type datum) ':start-of-authority)
				(send answer-stream ':dump-rr datum)))))
		      *domain-hash-table*)
	     (send answer-stream ':dump-rr soa-record)
	   )))))



(defun domain-dump-namespace-to-stream (namespace origin stream)
  (flet ((dump-ns (host)
	   (when (let ((svcs (send host :service)))
		   (or (cl:member '(:domain :tcp :domain) svcs ':test #'eql)
		       (cl:member '(:domain :udp :domain-simple) svcs ':test #'eql)))
	     (send stream :dump-rr
		   (make-rr name-list origin class :internet type :name-server
			    rdata (domain-cvt-primary-name host namespace))))))
    (mapc #'dump-ns (send namespace :primary-name-server))
    (mapc #'dump-ns (send namespace :secondary-name-server)))
  (loop for class in '(:user :host)
	do (neti:searching-one-namespace (namespace)
	     (loop for object in (sort (neti:find-objects-from-property-list class)
				       #'(lambda (o1 o2)
					   (flet ((ns (o)
						    (send (send o :primary-name namespace) :string)))
					     (string< (ns o1) (ns o2)))))
		   do (mapc #'(lambda (rr)
				(send stream :dump-rr rr))
			    (domain-rrs-for-object object namespace :internet :*))
		      (let ((pnl (domain-cvt-primary-name object namespace))
			    (nnl (domain-cvt-namespace-name namespace)))
			(mapc #'(lambda (name)
				  (unless (eq name (send object :primary-name namespace))
				    (send stream :dump-rr
					  (make-rr name-list (list* (send name :string)
								    nnl)
						   class :internet
						   type :canonical-name rdata pnl))))
			      (send object :names-in-namespace namespace)))
		      ))))




(defun domain-dump-namespace (namespace server postmaster)	
  (net:keeping-namespace-server
    (setf namespace (net:find-object-named :namespace namespace))
    (setq server (parse-domain-style-name server))
    (setq postmaster (parse-domain-style-name postmaster))
    (let ((origin (domain-cvt-namespace-name namespace)))
      (with-open-stream (stream (make-instance 'domain-file
					       :origin origin
					       :stream zl:standard-output))
	(send stream ':dump-rr (make-soa-record namespace server postmaster origin))
	(domain-dump-namespace-to-stream namespace origin stream)))))




(defun make-domain-file (namespace primary-server 
			 &optional (postmaster *postmaster-name-for-soa*) (file ""))
  (setf namespace (net:find-object-named :namespace namespace))
  (setf file (fs:merge-pathnames 
	       file
	       (fs:parse-pathname (format () "sys:site;~A-domain.text" 
						(send namespace :name))
				  )))
  (with-open-file (zl:standard-output file :direction :output)
    (domain-dump-namespace namespace primary-server postmaster)))



;;;
;;; stuff for loading domain files.
;;; to do: deal with '.', '..', and continuation lines
;;;
(defvar *domain-load-origin*)


(defvar *domain-last-read-name*)

(defflavor eol-detecting-encapsulated-stream-kludge
	(stream
	 (eol t))
	()
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:tyi eol-detecting-encapsulated-stream-kludge) ()
  (let ((ch (send stream ':tyi)))
    (setq eol (or (null ch) (char-equal ch #\return)))
    ch))

(defmethod (:any-tyi eol-detecting-encapsulated-stream-kludge) (&optional eof)
  (let ((ch (lexpr-send stream :any-tyi eof)))
    (setq eol (or (null ch) (char-equal ch #\return)))
    ch))

(defmethod (:untyi eol-detecting-encapsulated-stream-kludge) (ch)
  (send stream ':untyi ch))

(defmethod (eol eol-detecting-encapsulated-stream-kludge) ()
  eol)

(defmethod (:interactive eol-detecting-encapsulated-stream-kludge) () ())


;;;
;;; booting the server environment...
;;;
(defun initialize-log-monitor-early ()
  (when *domain-server-log*
    (su:forcibly-unlock-log *domain-server-log*))
  (let ((frame (if *domain-server-log*
		   (domain-server-log-frame *domain-server-log*)
		   (or (dw::find-program-window 'domain-server-log-program :create-p nil)
		       (dw::find-program-window 'domain-server-log-program)))))
    (when (null (domain-server-log-program-log-monitor (send frame :program)))
      (send frame :set-save-bits t)		D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Make the inferiors be relatively exposed.
0      (let ((log-pane (send frame :get-pane 'log)))
	(setf (domain-server-log-program-log-monitor (send frame :program))
	      (setq *domain-server-log*
		    (make-instance 'domain-server-log
				   :frame frame
				   :program (send frame :program)
				   :window log-pane
				   :directory nil)))))))
(defun(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") find-domain-server-log-program0 ()
  (if *domain-server-log*
1      ;; already there, so use it.
0      (domain-server-log-frame *domain-server-log*)
1      ;; not already there, make one (but don't initialize log!)
0      (dw::find-program-window 'domain-server-log-program)))

(tv:add-select-key #\@ '(2find-domain-server-log-program0) "Domain Server Log" nil)

(defun domain-load-dialnet-registry (pathname)
  ;;
  ;; first say we're a server
  ;;
  (let* ((existing-dialnet-domain
	   (find-dialnet-domain '("dialnet" "symbolics" "com")))
	 (dialnet-domain (or (and (typep existing-dialnet-domain 'dialnet-domain)
				  existing-dialnet-domain)
			     (make-instance 'dialnet-domain 
					':name-list '("dialnet" "symbolics" "com"))))
	 (local-host-name (send *local-host* ':primary-name))
	 (local-host-namestring (send local-host-name ':string))
	 (local-host-namespace (send local-host-name ':namespace))
	 (local-host-domain-name 
	   (append (list local-host-namestring)
		   (parse-domain-style-name
		     (send local-host-namespace ':internet-domain-name)))))
    (loop for class in '(:internet :chaos :dial)
	  do
      (set-domain-rrs dialnet-domain ':name-server class 
		      `((99999999. ,local-host-domain-name))))
    (with-open-file (file pathname ':direction ':input ':if-does-not-exist nil)
      (cond ((null file)
	     (su:log-event ':problem "Unable to open ~A" pathname))
	    (t
	     (su:log-event ':normal "Loading dialnet registry ~A" pathname)
	     (loop for entry = (read file nil)		
		   with last-entry
		   while entry do
	       (selectq (car entry) 
		 ((:subnet :telenet-pad) (setq last-entry nil))
		 (:host (setq last-entry entry))
		 (:domain
		  (let ((rel-6-style-host-name (second last-entry)))
		    (when (and last-entry (eq (car last-entry) ':host)
			       (string-equal (fourth entry) rel-6-style-host-name))
		      (let* ((base-domain (parse-domain-style-name (second entry)))
			     (site (first base-domain))
			     (host-name nil)
			     (host-alias-name nil))
			(setq host-name 
			      (if (and site
				       (zerop (or (string-search (string-append site "-")
								 rel-6-style-host-name)
						  -1)))	; great.  just great.
				  (progn
				    ;; Make rel-6 type dialnet host "names"
				    (setq host-alias-name
					  (append `(,rel-6-style-host-name)
						  '("dialnet" "symbolics" "com")))
				    (substring rel-6-style-host-name 
					       (+ (string-length site) 1)))
				  (fourth entry)))
			(when host-name
			  (let* ((host-domain-name (append (list host-name) base-domain))
				 
				 (site-domain (make-instance 'dialnet-domain 
							     ':name-list base-domain))
				 (host-domain (make-instance 'dialnet-domain 
							     ':name-list host-domain-name))
				 (alias-domain (and host-alias-name
						    (make-instance 'dialnet-domain
								   ':name-list host-alias-name))))
			    (su:log-event :normal "~&Generating ~@[~A, ~]~A and ~A" 
					  alias-domain host-domain site-domain)		     
			    (set-domain-rrs host-domain ':address ':dial 
					    `((99999999. ,(fourth last-entry))))
			    (set-domain-rrs host-domain ':well-known-services ':dial
					    '((99999999. ((:store-and-forward-mail :smtp)
							  (:mail-to-user :smtp)
							  (:expand-mail-recipient :smtp)
							  (:mail-probe :mail-probe)))))
			    (set-domain-rrs host-domain ':host-info ':dial
					    '((99999999. ("symbolics-3600" "lispm"))))
			    ;;
			    ;; this is not really right.  We need to do something here about 
			    ;; figuring out who is the appropriate mail-forwarder for this
			    ;; host on internet and cahos.  maybe stuff in file?  later...
			    ;;
			    (set-domain-rrs site-domain ':mail-x ':*
					    `((99999999. (1 ,host-domain-name))))
			    ;;
			    (and alias-domain
				 (set-domain-rrs alias-domain ':canonical-name ':dial
						 `((99999999. ,host-domain-name))))))))
		    ))
		 (otherwise (setq last-entry nil))
		 )))))))

(defun launch-domain-server (&optional complain-if-disabled fname override-namespace)
  (process-run-function "Launching Domain Server"
    #'launch-domain-server-internal complain-if-disabled fname override-namespace))

(defun launch-domain-server-internal (complain-if-disabled fname override-namespace)
  ;;
  ;; very first thing to do is check the namespace to see if local host offers
  ;; :DOMAIN service.  When override's not set, we only launch when the namespspace
  ;; says we offer the service.
  ;;
  (cond ((or override-namespace (cl:member :domain (send *local-host* :service)
					   :test #'(lambda (x y) (eq x (car y)))))
	 (land-domain-server)			1;Make sure all clean before restarting0.
	 (initialize-log-monitor-early)
	 (let ((su:*log* *domain-server-log*))
	   (unless fname
	     (setq fname (fs:parse-pathname "SYS:SITE;LAUNCH-DOMAIN-SERVER.TEXT")))
	   (let* ((*domain-load-origin*)
		  (package (pkg-find-package :keyword))
		  (*domain-last-read-name* nil))
	     (fs:with-automatic-login-to-sys-host
	       (with-open-file (file-stream fname :direction :input :if-does-not-exist nil)
		 (if file-stream
		     (let ((f (make-instance 'eol-detecting-encapsulated-stream-kludge
					     :stream file-stream)))
		       (su:log-event :normal "Booting domain server with ~A" fname)
		       (flet ((skip-white-space (f)
				(loop for char = (send f :tyi)
				      until (or (char-equal char #\Return)
						(not (cl:member char '(#\Space #\Tab))))
				      finally (send f :untyi char))))
			 (flet ((skip-white-space-and-read-string (f)
				  (skip-white-space f)
				  (read-delimited-string '(#\Space #\Tab #\Return) f)))
			   (loop as tag = (read f nil)
				 while tag 
				 do (selectq tag
				      (:domain 
				       (skip-white-space f)
				       (cl:pushnew (let ((*domain-load-origin* nil))
						     (domain-file-read-name f))
						   *server-primary-domains*
						   :test #'equal))
				      ;;
				      (:primary 
				       (let ((origin (skip-white-space-and-read-string f))
					     (path (skip-white-space-and-read-string f)))
					 (cl:pushnew (parse-domain-style-name origin) 
						     *server-primary-domains*
						     :test #'equal)
					 (domain-load-file path origin t)))
				      ;;
				      (:secondary 
				       (let* ((secondary-domain
						(skip-white-space-and-read-string f))
					      (host-or-address
						(skip-white-space-and-read-string f)))
					 (when (and (plusp (string-length secondary-domain))
						    (plusp (string-length host-or-address)))
					   (add-domain-background-queue-entry 
					     (universal-time-in-minutes)	; now
					     '(:always 60)	; check every 60 minutes
					     :zone-transfer
					     secondary-domain
					     host-or-address)
					   (su:log-event :normal
							 "Queueing event ~A for ~A from ~A"
							 :zone-transfer secondary-domain
							 host-or-address))))
				      ;;
				      (:dialnet 
				       (let ((origin (skip-white-space-and-read-string f))
					     (path (skip-white-space-and-read-string f)))
					 (cl:pushnew (parse-domain-style-name origin) 
						     *server-primary-domains*
						     :test #'equal)
					 (domain-load-dialnet-registry path)))
				      ;; ignore rest for now
				      )
				    (loop while (not (eol f)) do
				      (send f :tyi))))))
		     (su:log-event :normal "Unable to open boot file ~S." fname))))
	   (initialize-domain-resolver)
	   (setq *domain-default-recursion-request* nil
		 *domain-site-servers* nil)	; if we launch, we're standalone
	   (reinitialize-domain-resolver)
	   (setq *domain-server-enabled* t)
	   (cond ((eq *domain-resolver-status* :enabled)
		  (su:log-event :normal "Boot finished; enabling service")
		  )
		 (t
		  (su:log-event :problem
				"No root servers for local site; local service enabled.")
		  (setq *domain-resolver-status* :enabled-within-site)
		  ))
	   ;;
	   ;; start the background process
	   ;;
	   (setq *domain-server-background* (process-run-function "Domain Server Background"
					      #'domain-server-background-top-level))
	   )))
	;; not offerring service.
	(t
	 (when complain-if-disabled
	   1;; Our caller is responsible for ensuring that the domain log is already setup.
0	   (let ((su:*log* *domain-server-log*))
	     (su:log-event :normal "Domain service is not enabled.")))))
  )

(defun land-domain-server ()
  ;(sys:disable-services '(:domain))
  (when *domain-server-background*
    (send *domain-server-background* ':kill)
    (setq *domain-server-background* nil))
  (setq *domain-server-background-to-do* nil)
  (setq *domain-server-enabled* nil))



;;;
;;; this automatically boots the server at enable-services time
;;;
(defun (:property :domain sys:enable-services) (ignore)
  (launch-domain-server nil))

;;;
;;; origin is the unparsed name, ie scrc.symbolics.com
;;;
(defun domain-load-file (fname origin primary-p)
  (setf origin (parse-domain-style-name origin))
  (let ((*domain-load-origin* origin)
	(*domain-last-read-name* origin)
	(su:*log* *domain-server-log*)
	(package (pkg-find-package ':keyword)))
    (with-open-file (file fname :direction :input :if-does-not-exist nil)
      (cond (file
	     (su:log-event :normal "Starting Load of file ~S with origin ~S" fname origin)
	     (let ((kludge (make-instance 'eol-detecting-encapsulated-stream-kludge
					  :stream file)))
	       (loop for rr = (domain-file-read-rr kludge)
		     while rr
		     for name-list = (rr-name-list rr)
		     do (when *debug-domain-requests* 
			  (format t "~&~S" rr))
			;;collect rr
			(when (let ((diff (- (length name-list) (length origin))))
				(and (<= 0 diff)
				     (equal (nthcdr diff name-list) origin)))
			  (loop for name on name-list
				for domain = (find-domain name :create :ignore-nonexistant-domains)
				when (<= (length origin) (length name))
				  do (set-authoritative domain t)
				     (when primary-p
				       (set-local-host-is-primary-server domain t))))
			(process-domain-answers `(,rr) t primary-p)
			))
	     (su:log-event :normal "Finished loading ~S" fname))
	    (t
	     (su:log-event :problem "Couldn't find file ~A" fname)))
      )))



(defun domain-file-read-key (file alist)
  (multiple-value-bind (key type)
      (read file)
    (if (not (eq type ':symbol)) 
	(second (rass #'(lambda (x y) (eq x (second y))) key alist)))))

(defun domain-file-read-name (file)
  (multiple-value-bind (name type)
      (read file)
    (let ((string-name (cl:ecase type
			 (symbol (string name))
			 (si:integer (format nil "~D" name)))))
      (if (string-search-char #\. string-name)
	  (let ((parsed-name (parse-domain-style-name string-name)))
	    (if (string-equal (first (last parsed-name)) "")	; ended with a dot?
		(reverse (cdr (reverse parsed-name)))	; isn't there a better
							; way to dyke out the last elt?
		(append parsed-name *domain-load-origin*)))	; no dot, treat it as relative
	  (append (list string-name) *domain-load-origin*)))))

(defun domain-file-read-rr (file)
  (loop while (not (eol file)) do
    (send file ':tyi))				; find beginning of next line
  (let ((time-to-live (* 4 60 60 60))		; default 4 hours
	(rr))
    (loop for first-char = (send file ':tyi) 
	  while first-char do      
      (selectq first-char
	(#/; (readline file nil))
	(#/return nil)				; just ignore it and keep looping
	(otherwise
	 (let* ((n (selectq first-char
		     (#\@ (setq time-to-live (* 30 24 60 60 60))	; a month, more or less
		      *domain-load-origin*)
		     ((#/space #/tab) *domain-last-read-name*)
		     (otherwise
		      (progn (send file ':untyi first-char)
			     (setq *domain-last-read-name* 
				   (domain-file-read-name file))))))
		(c (domain-file-read-key file *domain-classes*))
		(tp (domain-file-read-key file *domain-types*))
		(r (domain-file-read-rdata file tp c)))
	   (setq rr (make-rr name-list n class c type tp ttl time-to-live rdata r)))))
	  until rr
	  finally (progn
		    (loop while (not (eol file)) do
		      (send file ':tyi))
		    (return rr)))))


(defun chaos-dial-wks-reader (file)
  (let ((package (pkg-find-package "keyword")))
    (read file)))
(defun chaos-a-reader (file)
  (list (domain-file-read-name file)
	(let ((cl:*read-base* 8))
	  (read file))))
(defun domain-file-read-rdata (file type &optional (class ':internet))
  (let ((f (cond ((and (eq type ':well-known-services)
		       (cl:member class '(:chaos :dial)))
		  #'chaos-dial-wks-reader)
		 ((and (eq type ':address)
		       (cl:member class '(:chaos)))
		  #'chaos-a-reader)
		 (t
		  (get type 'domain-file-read-rdata)))))
    (if f
	(funcall f file)
	(domain-file-read-name file))))

(defun (:property :start-of-authority domain-file-read-rdata) (file)
  (append (list (domain-file-read-name file)
		(domain-file-read-name file))
	  (read file)))

(defun (:property :address domain-file-read-rdata) (file)
  (string (read file)))

(defun (:property :well-known-services domain-file-read-rdata) (file)
  `(,(string (read file))
    ,(cdr (rassq (read file) *internet-protocol-number-to-name-alist*))
    ,(loop with l = (readline file nil)
	    with i = 0
	    with token
	    do (multiple-value (token i)
		 (read-from-string l nil i))
	    while token
	    collect token)))

(defun (:property :host-info domain-file-read-rdata) (file)
  (list (format nil "~A" (read file))
	(format nil "~A" (read file))))

(defun (:property :mail-x domain-file-read-rdata) (file)
  (list (read file)
	(domain-file-read-name file)))

;;;
;;; The domain server background process.  
;;; Nothing too fancy here.  *domain-server-background-to-do* is an alist of
;;; universal-times and things to do.  For now, that's just pending requests.
;;;

(defstruct (domain-server-background-entry :list :conc-name)
  time-to-execute				; universal-time-in-minutes to do this
  requeue					; (:always delta-t), :if-failed
  type						; :zone-transfer, for now
  parameters)					; Rest of stuff to do with query

(defun add-domain-background-queue-entry (when requeue type &rest what)
  (without-interrupts 
    (push (make-domain-server-background-entry time-to-execute when
					       requeue requeue
					       type type
					       parameters (copylist what))
	  *domain-server-background-to-do*)))

(defun remove-domain-background-queue-entry (entry)
  (without-interrupts (delq entry *domain-server-background-to-do*))
  entry)



(defun domain-queue-interesting-entry ()
  (loop for e in *domain-server-background-to-do* 
	as time-to-do-entry = (domain-server-background-entry-time-to-execute e)
	when (>= (universal-time-in-minutes) time-to-do-entry)
	  return e))

(defun domain-server-background-top-level ()
  (let ((*log-domain-requests* t)
	(su:*log* *domain-server-log*))
    (loop doing (process-wait "Domain Server Background" 
		  #'domain-queue-interesting-entry)
	  as entry = (domain-queue-interesting-entry)
	  as requeue = (domain-server-background-entry-requeue entry)
	  when entry 
	    do (unless (and (listp requeue) (eq (first requeue) ':always))
		 (remove-domain-background-queue-entry entry))
	       (let ((success
		       (selectq (domain-server-background-entry-type entry)
			 (:zone-transfer
			  (cl:apply #'zone-transfer-if-necessary
				    (domain-server-background-entry-parameters entry))))))
		 ;;
		 ;; requeue it if necessary
		 ;;
		 (cond ((and (listp requeue) (eq (first requeue) ':always))
			(setf (domain-server-background-entry-time-to-execute entry)
			      (+ (domain-server-background-entry-time-to-execute entry)
				 (if success (second requeue) 15))))
		       ((not success) 
			(cl:apply #'add-domain-background-queue-entry
			  (+ (domain-server-background-entry-time-to-execute entry) 15)
			  requeue
			  (domain-server-background-entry-type entry)
			  (domain-server-background-entry-parameters entry))))))))





;;;
;;; zone transfer user side.
;;;
(defun zone-transfer-user (zone-name host-name)
  (let ((host))
    (when (stringp host-name)
      (setq host (if (not (cl:digit-char-p (aref host-name 0)))	; internet addr?
		     (condition-case (error) 
			  (parse-host host-name t t)
			(error nil))
		     (parse-host (string-append "internet|" host-name) nil nil))))
    (cond ((null host)
	   (if *log-domain-requests*
	       (su:log-event :problem "Couldn't zone transfer ~A, couldn't parse host ~A"
			     zone-name host-name)
;	       (ferror "Couldn't zone transfer ~A, couldn't parse host ~A" zone-name 
;		       host-name)
	       ))
	  (t
	   ;;
	   ;; make up an access path by hand, and use it to invoke service on this sucker,
	   ;; to ensure that we get byte stream service.  datagrams won't do here.  
	   ;;
	   (condition-case ()
		(let ((service-access-paths (find-paths-to-service-on-host-1
					      ':domain 
					      (find-protocol-named ':domain)
					      host
					      ':byte-stream))
		      success)
		  (loop for sap in service-access-paths 
			as stream = (invoke-service-domain-with-domain sap)
			as zone-data =
			   (and stream (send stream ':transaction 
					     `(:opcode :query
					       :query t
					       :id 0
					       :questions (,(make-rr name-list
								     (parse-domain-style-name
								       zone-name)
								     class ':*
								     type ':authority-xfer)))
					     t))
			do (when stream (send stream ':close))
			until zone-data
			finally
			  (progn
			    (setq success
				  (and (eq (rr-type (first (cl:getf (first zone-data)
								    ':answers)))
					   ':start-of-authority)
				       (eq (rr-type (first (cl:getf (first (last zone-data))
								    ':answers)))
					   ':start-of-authority)))
			    (loop for datum in zone-data do 
			      (loop for tag in '(:answers :authorities :additional) do
				(process-domain-answers (cl:getf datum tag) t)))))
		  
		  (when *log-domain-requests* 
		    (su:log-event :normal (if success
					      "Successfully transferred zone ~A from ~A."
					      "Failed to transfer zone ~A from ~A.  Requeued.")
				  zone-name host))
		  success)
	      (sys:network-error nil))))))



(defun zone-transfer-if-necessary (zone-name host-name)
;  (let ((host)
;	(zone-name-list (parse-domain-style-name zone-name)))
;    (when (stringp host-name)
;      (setq host (condition-case (error) 
;		      (parse-host host-name t t)
;		    (error (parse-host (string-append "internet|" host-name) nil nil)))))
;;;
;    (let* ((my-latest-soa-record (first (domain-rrs (find-domain zone-name-list)
;						   ':start-of-authority ':* 
;						   ':up-to-date nil)))
;	  (his-current-soa-record (first (cl:getf (domain-query-host 
;						    host 
;						    zone-name-list
;						    ':start-of-authority
;						    ':*)))))
;;;
;;; NOTE!!!!! This isn't done the 'correct' way because of another screw case in this
;;; non-designed scheme.  The correct way to do this would be to check the SOA for the zone
;;; and only snarf over a new copy if the serial number changed.  We can't do that because
;;; the domain data structs that we snarfed the last time are busily decaying their timeout
;;; values, and will expire shortly if we don't get a new copy of the zone (regardless of
;;; whether it's changed)  The fix for this would be to either alter the way authoritative
;;; native domains decay their timeouts (ei don't) or, when finding that the serial number
;;; in the SOA hasn't changed, go thru all the domains in this zone (how to find them?) and
;;; update their timeouts.  Yech.  For now, be simple minded, and snarf the zone regardless
;;;
  (zone-transfer-user zone-name host-name))


