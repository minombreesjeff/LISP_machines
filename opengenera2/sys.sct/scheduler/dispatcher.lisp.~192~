;;; -*- Mode: LISP; Syntax: Common-lisp; Package: process; Base: 10; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; this implementation is bogus, and is just a placeholder for the real function.
(DEFUN REGISTER-PROCESS-FOR-SEQUENCE-BREAK (PROC)
  (DECLARE (VALUES HANDLE))
  (WHEN (<= (SI:LEVEL-TYPE (LDB SYS:%%REGION-LEVEL
				(SYS:REGION-BITS (SYS:%REGION-NUMBER PROC))))
	    SI:%LEVEL-TYPE-SAFEGUARDED)
    (RETURN-FROM REGISTER-PROCESS-FOR-SEQUENCE-BREAK PROC))
  (LET ((SG (PROCESS-STACK-GROUP PROC)))
    (WHEN (AND SG (EQ (SYS:SG-NAME SG) PROC))
      (RETURN-FROM REGISTER-PROCESS-FOR-SEQUENCE-BREAK SG)))
  (DOTIMES (INDEX (ARRAY-TOTAL-SIZE *REGISTERED-PROCS-FOR-INTERRUPT*))
    (WHEN (STORE-CONDITIONAL (LOCF (AREF *REGISTERED-PROCS-FOR-INTERRUPT* INDEX))
			     NIL PROC)
      (RETURN INDEX))))

(DEFUN UNREGISTER-PROCESS-FOR-SEQUENCE-BREAK (HANDLE)
  (TYPECASE HANDLE
    (FIXNUM
      (SETF (AREF *REGISTERED-PROCS-FOR-INTERRUPT* HANDLE) NIL))))

(DEFMACRO WITH-PROCESS-INTERRUPT-HANDLE ((HANDLE &OPTIONAL (PROCESS '*CURRENT-PROCESS*))
					 &BODY BODY)
  `(LET ((,HANDLE NIL))
     (UNWIND-PROTECT
	 (PROGN (SETF ,HANDLE (REGISTER-PROCESS-FOR-SEQUENCE-BREAK ,PROCESS))
		,@BODY)
       (UNREGISTER-PROCESS-FOR-SEQUENCE-BREAK ,HANDLE))))

(DEFVAR *QUEUED-WAKEUPS-IMAGE* (MAKE-ARRAY *SB-WAKEUP-QUEUE-SIZE*))

(DEFSUBST COPY-WAKEUPS-AND-DISPATCH (&KEY PREEMPTIVE-ONLY ENABLE-ABORTS)
  (SI:AVOID-STACK-OVERFLOW 500.)
  (LOOP
    (SETF %*CHECK-FOR-PREEMPTION* NIL)
    (WHEN (PLUSP (FILL-POINTER *QUEUED-WAKEUPS*))
      (LET* ((IMAGE *QUEUED-WAKEUPS-IMAGE*)
	     (N (LET* ((WAKEUPS *QUEUED-WAKEUPS*)
		       (LN (LOCF (FILL-POINTER WAKEUPS))))
		  (DECLARE (SYS:ARRAY-REGISTER WAKEUPS))
		  (LOOP
		    (LET ((N (LOCATION-CONTENTS LN)))
		      (DOTIMES (I N)
			(SETF (AREF IMAGE I) (AREF WAKEUPS I)))
		      (WHEN (STORE-CONDITIONAL LN N 0) (RETURN N)))))))
	(DECLARE (SYS:ARRAY-REGISTER IMAGE))
	(DOTIMES (I N)
	  (LET ((REAL-P (LET ((P (AREF IMAGE I)))
			  (TYPECASE P
			    (FIXNUM
			      (AREF *REGISTERED-PROCS-FOR-INTERRUPT* P))
			    ((AND ARRAY SYS:STACK-GROUP)
			     (SYS:SG-NAME P))
			    (OTHERWISE P)))))
	    (WHEN (INSTANCEP REAL-P)
	      (PROCESS-WAKEUP REAL-P))))))
    (UNLESS (EQ %REAL-CURRENT-PROCESS
		(IF (OR PREEMPTIVE-ONLY
			(< (SYS:%32-BIT-DIFFERENCE (SYS:%MICROSECOND-CLOCK)
						   *PROCESS-START-TIME*)
			   *PROCESS-PREEMPT-INTERVAL*))
		    (FIND-HIGHEST-PRIORITY-PREEMPTIVE-PROCESS)
		    (FIND-HIGHEST-PRIORITY-PROCESS)))
      (IF ENABLE-ABORTS
	  (SYS:WITH-ABORTS-ENABLED (UNWIND-PROTECT)
	    (RUN-PROCESS-DISPATCHER))
	  (RUN-PROCESS-DISPATCHER)))
    (SETF *PREEMPTION-ENABLED* T)
    (WHEN (NOT %*CHECK-FOR-PREEMPTION*) (RETURN NIL))
    (SETF *PREEMPTION-ENABLED* NIL)))

#+3600
(DEFUN PREEMPT-CURRENT-PROCESS ()
  (DECLARE (SYS:SAFEGUARDED-FUNCTION SYS:DISABLE-REFERENCE-VALIDATION)
	   (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS)
	   (DBG:ERROR-REPORTER))
  (LET ((SAVED-FLOAT-STATUS (SYS:FLOAT-OPERATION-STATUS)))
    (UNWIND-PROTECT
	(COPY-WAKEUPS-AND-DISPATCH)
      (SETF (SYS:FLOAT-OPERATION-STATUS) SAVED-FLOAT-STATUS)
      (SETF *PREEMPTION-ENABLED* T))))

#+IMACH
(DEFUN PREEMPT-CURRENT-PROCESS ()
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS)
	   (DBG:ERROR-REPORTER))
  (SI:SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
    (UNWIND-PROTECT
	(COPY-WAKEUPS-AND-DISPATCH)
      (SETF *PREEMPTION-ENABLED* T)))
  NIL)

;;; This function is called by WITH-SCHEDULER-LOCKED when preemption is to be reenabled.
(DEFUN PREEMPTION-BEING-REENABLED ()
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS)
	   (DBG:ERROR-REPORTER))
  (DECLARE (SYS:SAFEGUARDED-FUNCTION SYS:DISABLE-REFERENCE-VALIDATION))
  (COND (SYS:INHIBIT-SCHEDULING-FLAG
	 (UNLESS (EQ %REAL-CURRENT-PROCESS (FIND-HIGHEST-PRIORITY-PREEMPTIVE-PROCESS))
	   ;; Dispatch to another process when SYS:INHIBIT-SCHEDULING-FLAG clears
	   (SI:%SET-PREEMPT-PENDING)
	   (SETQ %*CHECK-FOR-PREEMPTION* T))
	 (SETF *PREEMPTION-ENABLED* T))
	(T
	 (COPY-WAKEUPS-AND-DISPATCH :PREEMPTIVE-ONLY T :ENABLE-ABORTS T)))
  NIL)

(DEFVAR *WHOSTATE-FOR-PAGE-WAIT* "Page")

(DEFUN BLOCK-FOR-PAGE-FETCH (VMA WAITER-INDEX)
  #+3600 (DECLARE (SYS:SAFEGUARDED-FUNCTION SYS:DISABLE-REFERENCE-VALIDATION))
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS)
	   (DBG:ERROR-REPORTER))
  (LET ((HANDLE NIL))
    (UNWIND-PROTECT
	(UNWIND-PROTECT
	    (PROGN
	      (COMPILER:%ERROR-WHEN STORAGE::*PAGE-FAULT-EXIT-FUNCTION*
		(FUNCALL (SHIFTF STORAGE::*PAGE-FAULT-EXIT-FUNCTION* NIL)
			 VMA SYS:%PAGE-PHT-MISS))
	      (COND ((EQ *CURRENT-PROCESS* *NULL-PROCESS*)
		     (SI:%FUNCALL-IN-AUX-STACK #'STORAGE::WAIT-FOR-DISK-DONE))
		    (T
		     (SETF HANDLE (REGISTER-PROCESS-FOR-SEQUENCE-BREAK *CURRENT-PROCESS*))
		     (SETF (AREF STORAGE::*PAGE-WAITER-PROCESS* WAITER-INDEX) HANDLE)
		     (UNLESS (EQ T (AREF STORAGE::*PAGE-WAITER-VPN* WAITER-INDEX))
		       (PROCESS-BLOCK-INTERNAL
			 %REAL-CURRENT-PROCESS 'BLOCKED *PAGE-WAIT-QUEUE*
			 *WHOSTATE-FOR-PAGE-WAIT*
			 #'(LAMBDA (WAITER-INDEX)
			     (EQ T (AREF STORAGE::*PAGE-WAITER-VPN* WAITER-INDEX)))
			 WAITER-INDEX)))))
	  (SETF (AREF STORAGE::*PAGE-WAITER-VPN* WAITER-INDEX) NIL)
	  (PREEMPTION-BEING-REENABLED)
	  (UNREGISTER-PROCESS-FOR-SEQUENCE-BREAK HANDLE))
      (SETF *PREEMPTION-ENABLED* T))))



(DEFVAR *PROCESS-RUN-WHOSTATE* "Run")

(DEFMETHOD (SET-RUN-LIGHT-FOR-PROCESS PROCESS) ()
  (IF (LDB-TEST %%PROCESS-DEBUG-NO-RUN-LIGHT DEBUG-FLAG)
      (SI:CLEAR-RUN-LIGHT SYS:PROCESS-RUN-LIGHT)
      (SI:SET-RUN-LIGHT SYS:PROCESS-RUN-LIGHT))
  (IF (SCHEDULER-QUEUE-EMPTY? *PAGE-WAIT-QUEUE*)
      (SI:CLEAR-RUN-LIGHT SYS:DISK-RUN-LIGHT)
      (SI:SET-RUN-LIGHT SYS:DISK-RUN-LIGHT)))

;; both of these assume that %real-current-process is already set.
(DEFMACRO %PREAMBLE-ON-ENTRY-TO-PROCESS (&OPTIONAL IN-SCHEDULER)
  `(PROGN
     (SI:WITH-METERING-DISABLED
       (SETUP-PROCESS-METERS %REAL-CURRENT-PROCESS))
     (WHEN (AND METERING:*METERING-GLOBALLY-ENABLED*
		(NOT (ZEROP (PROCESS-METERING-INFO-EXISTS %REAL-CURRENT-PROCESS))))
       (let ((metering:*metering-enabled* nil))
	 (LOOP FOR CONTROL IN
		   (PMI-SWITCHES (PROCESS-METERING-INFO %REAL-CURRENT-PROCESS))
	       ;; This only gets called when Metering is really loaded
	       DO (METERING::ENTER-PROCESS CONTROL %REAL-CURRENT-PROCESS))))
     (SI:WITH-METERING-DISABLED
       (LET ((METERING:*METERING-STACK* *SCHEDULER-METERING-STACK*))
	 (METERING:START-METERING-INTERVAL (PER-PROCESS NIL NIL :ENV (:SCHEDULER))
					   (PROCESS)
	   %REAL-CURRENT-PROCESS)))
     (SETF *IN-PROCESS-DISPATCHER* NIL)
     (SETF *CURRENT-PROCESS* %REAL-CURRENT-PROCESS)
     ,@(WHEN IN-SCHEDULER
	 `((SETF METERING:*METERING-ENABLED* METERING::*SCHED-COMMUNICATE-METERING-ENABLED*)
	   (SETF METERING::*METERING-OVERHEAD-ACCOUNTED*
		 METERING::*SCHED-COMMUNICATE-METERING-ACCOUNTED*)))
     (SETF (PROCESS-WHOSTATE %REAL-CURRENT-PROCESS) *PROCESS-RUN-WHOSTATE*)))

(DEFMACRO %POSTSCRIPT-ON-EXIT-FROM-PROCESS (NEXT-PROCESS CURRENT-TIME)
  `(PROGN
     ,(WHEN NEXT-PROCESS
	`(SET-RUN-LIGHT-FOR-PROCESS NEXT-PROCESS))
     (SETQ METERING:*METERING-ENABLED* METERING::*METERING-GLOBALLY-ENABLED*)
     (SETQ METERING::*METERING-OVERHEAD-ACCOUNTED* NIL)
     (SETF *IN-PROCESS-DISPATCHER* T)
     #+ENABLE-CURRENT-PROCESS-NIL
     (SETQ *CURRENT-PROCESS* NIL)
     (LET ((METERING::*METERING-STACK* *SCHEDULER-METERING-STACK*))
       (METERING::END-METERING-INTERVAL (PER-PROCESS NIL NIL :ENV (:SCHEDULER))
					(PROCESS)
	 %REAL-CURRENT-PROCESS))
     (WHEN (AND METERING:*METERING-GLOBALLY-ENABLED*
		(NOT (ZEROP (PROCESS-METERING-INFO-EXISTS %REAL-CURRENT-PROCESS))))
       (LET ((METERING:*METERING-ENABLED* NIL))
	 (LOOP FOR CONTROL IN
		   (PMI-SWITCHES (PROCESS-METERING-INFO %REAL-CURRENT-PROCESS))
	       ;; This only gets called when Metering is really loaded
	       DO (METERING::EXIT-PROCESS CONTROL %REAL-CURRENT-PROCESS))))
     (WHEN %REAL-CURRENT-PROCESS
       (UPDATE-PROCESS-METERS %REAL-CURRENT-PROCESS ,CURRENT-TIME)
       (UNLESS (OR %%PROCESS-SWITCH-IN-PROGRESS
		   (NULL (PROCESS-STACK-GROUP %REAL-CURRENT-PROCESS)))
	 (SETF (PROCESS-STACK-GROUP %REAL-CURRENT-PROCESS) SYS:%CURRENT-STACK-GROUP)))
     (WHEN (LDB-TEST %%PROCESS-DEBUG-FUNCALL-POLICY-HOOK-ON-PROCESS-SWITCH
		     (PROCESS-DEBUG-FLAG %REAL-CURRENT-PROCESS))
       (FUNCALL *POLICY-HOOK-PROCESS-SWITCH-OCCURRED* %REAL-CURRENT-PROCESS))))

(DEFMACRO %PREAMBLE-ON-SWITCH-TO-PROCESS (&OPTIONAL IN-SCHEDULER)
  `(PROGN
     (SETF %%PROCESS-SWITCH-IN-PROGRESS NIL)
     (%PREAMBLE-ON-ENTRY-TO-PROCESS ,in-scheduler)))

(DEFUN RUN-PROCESS-DISPATCHER ()
  (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS))
  (DECLARE (INLINE PROCESS-STACK-GROUP PROCESS-INITIAL-FORM))
  ;; Shut off run light
  (SI:CLEAR-RUN-LIGHT SYS:PROCESS-RUN-LIGHT)
  (LET* ((CURRENT-TIME (SI:%MICROSECOND-CLOCK))
	 (NEXT-PROCESS (FIND-HIGHEST-PRIORITY-PROCESS))
	 ;; don't set these up now.  They get set by %preamble and %postscript when we
	 ;; actually leave the process and enter the scheduler...
	 (METERING::*SCHED-COMMUNICATE-METERING-ENABLED* METERING::*METERING-ENABLED*)
	 (METERING::*METERING-ENABLED* METERING::*METERING-ENABLED*)
	 (METERING::*SCHED-COMMUNICATE-METERING-ACCOUNTED*
	   METERING::*METERING-OVERHEAD-ACCOUNTED*)
	 (METERING::*METERING-OVERHEAD-ACCOUNTED* METERING::*METERING-OVERHEAD-ACCOUNTED*)
	 (METER-ENABLE-FLAG NIL)
	 (*DEBUG-IO* "Error in the dispatcher"))
    ;; this can cause overflows, so disable function call metering
    (SI:WITH-METERING-DISABLED
      (WHEN *SHOW-PROCESS-SWITCHES*
	(SI:IGNORE-ERRORS-IN-SCHEDULER (TV:WHO-LINE-UPDATE)))
      ;; Check to make sure that highest priority process is not already running.
      (IF (EQ %REAL-CURRENT-PROCESS NEXT-PROCESS)
	  (PROGN
	    (INCF *USELESS-DISPATCHER-ENTRIES*)
	    (METERING:DEFINE-METERING-POINT (PROCESS-SWITCH NIL NIL :ENV (:SCHEDULER))
					    (OLD-PROCESS NEW-PROCESS)
	      %REAL-CURRENT-PROCESS
	      NEXT-PROCESS))
	  (PROGN
	    (%POSTSCRIPT-ON-EXIT-FROM-PROCESS NEXT-PROCESS CURRENT-TIME)
	    (METERING:DEFINE-METERING-POINT (PROCESS-SWITCH NIL NIL :ENV (:SCHEDULER))
					    (OLD-PROCESS NEW-PROCESS)
	      %REAL-CURRENT-PROCESS
	      NEXT-PROCESS)
	    ;; Can't allow traps here (when %real-current-process doesn't refer to this stack
	    ;; group) that might enter the debugger (including stack overflow), so
	    ;; we'll signal it now, before we update %REAL-CURRENT-PROCESS.
	  
	    ;; better safe than sorry; give us some margin, look for 500. words.
	    (SI:AVOID-STACK-OVERFLOW 500.)
	    (SETF %%PROCESS-SWITCH-IN-PROGRESS 'T)
	    (UNWIND-PROTECT
		(LET ((SG (PROCESS-STACK-GROUP
			    (PROGN
			      (SETQ %REAL-CURRENT-PROCESS NEXT-PROCESS)
			      #-ENABLE-CURRENT-PROCESS-NIL
			      (SETQ *CURRENT-PROCESS* NEXT-PROCESS)
			      NEXT-PROCESS))))
		  (IF (ZL:TYPEP SG ':STACK-GROUP)
		      (STACK-GROUP-RESUME SG NIL)
		      #||
		      (IF (TYPEP NEXT-PROCESS 'STACKLESS-PROCESS)
			  (LET ((*INSIDE-STACKLESS-PROCESS* 'T))
			    (HANDLE-ERRORS-IN-STACKLESS-PROCESS
			      (APPLY (CAR (PROCESS-INITIAL-FORM NEXT-PROCESS))
				     (CDR (PROCESS-INITIAL-FORM NEXT-PROCESS)))))
			  (STACK-GROUP-RESUME
			    (SPAWN-SIMPLE-PROCESS SG %REAL-CURRENT-PROCESS) NIL))
		      ||#
		      (STACK-GROUP-RESUME
			(SPAWN-SIMPLE-PROCESS SG %REAL-CURRENT-PROCESS) NIL)))
	      ;; Disable traps on function calls - but remember state
	      (SETF METER-ENABLE-FLAG (SYS:%CURRENT-STACK-GROUP-METER-ENABLE-FLAG))
	      (SETF (SYS:%CURRENT-STACK-GROUP-METER-ENABLE-FLAG) NIL)
	      (%PREAMBLE-ON-SWITCH-TO-PROCESS T)))))
    ;; Restore traps on function calls state
    (SETF (SYS:%CURRENT-STACK-GROUP-METER-ENABLE-FLAG) METER-ENABLE-FLAG))
  (VALUES))

;;; PROCESS-INTERRUPT will put this on the stack in place of RUN-PROCESS-DISPATCHER.
;;; it has to do everything run-process-dispatcher does on return from a stack-group switch,
;;; *plus* it must enable preemption, because if you hadn't allowed it, you wouldn't have 
;;; been in run-process-dispatcher, would you?
;;; then it must call the apply FUNCTION to the ARGS (these arguments are forced there by
;;; PROCESS-INTERRUPT.  On return, it *must* disable preemption, because all callers
;;; of RUN-PROCESS-DISPATCHER *must* be called inside a WITH-SCHEDULER-LOCKED.
;;; It must restore the wait-function, and set the wakeup-waiting switch of the
;;; process, in case it was called by process-block-internal.  This will force the wait 
;;; function to be re-evaluated.
(DEFUN INTERRUPT-PROCESS-DISPATCHER (WHOSTATE VERIFY-FUNCTION VERIFY-ARGS FUNCTION &REST ARGS)
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS)
	   (DBG:ERROR-REPORTER))
  ;; in-scheduler is 't, because we know that run-process-dispatcher is on the stack above us.
  (%PREAMBLE-ON-SWITCH-TO-PROCESS T)
  (TV:WHO-LINE-PROCESS-CHANGE %REAL-CURRENT-PROCESS)
  ;; protect in case someone accidentally calls us directly, instead of process-interrupt
  ;; hackery, and preserve state of preemption-enabled.
  (LET ((OLD-PREEMPTION-ENABLED *PREEMPTION-ENABLED*)
	(OLD-INHIBIT-SCHEDULING-FLAG SI:INHIBIT-SCHEDULING-FLAG))
    (CLI::WITH-FLOATING-POINT-STATUS-SAVED
	(LET ((*DEBUG-IO* SI:SYN-TERMINAL-IO))
	  (SETF *PREEMPTION-ENABLED* 'T)
	  (APPLY FUNCTION ARGS))
      (SETF *PREEMPTION-ENABLED* OLD-PREEMPTION-ENABLED)
      (SETF SI:INHIBIT-SCHEDULING-FLAG OLD-INHIBIT-SCHEDULING-FLAG)
      ;; (%POSTSCRIPT-ON-EXIT-FROM-PROCESS %REAL-CURRENT-PROCESS (SYS:%MICROSECOND-CLOCK))
      ;; restore old "wait-state".
      (WHEN (ZEROP (LDB PROCESS-DEBUG-RESET-IN-PROGRESS
			(PROCESS-DEBUG-FLAG %REAL-CURRENT-PROCESS)))
	(SETF (PROCESS-WHOSTATE %REAL-CURRENT-PROCESS) WHOSTATE)
	(TV:WHO-LINE-PROCESS-CHANGE %REAL-CURRENT-PROCESS)
	(SETF (PROCESS-VERIFY-FUNCTION %REAL-CURRENT-PROCESS) VERIFY-FUNCTION)
	(SETF (PROCESS-VERIFY-FUNCTION-ARGS %REAL-CURRENT-PROCESS) VERIFY-ARGS))
      ;; force PROCESS-BLOCK-INTERNAL to re-evaluate the verify-function
      (SETF (PROCESS-WAKEUP-WAITING-SWITCH %REAL-CURRENT-PROCESS) 'T))))

(DEFVAR *BREAK-ON-INHIBIT-SCHEDULING-IN-NULL-PROCESS* 'T)

(DEFUN NULL-PROCESS-TOP-LEVEL (&REST IGNORE)
  (SETQ *PREEMPTION-ENABLED* 'T)
  (LET ((SI:INHIBIT-SCHEDULING-FLAG NIL)
	(*DEBUG-IO* "Error in Final Null Process"))
    (LOOP DOING
      (WHEN (AND (OR SI:INHIBIT-SCHEDULING-FLAG (NOT *PREEMPTION-ENABLED*))
		 *BREAK-ON-INHIBIT-SCHEDULING-IN-NULL-PROCESS*)
	(TV:KBD-USE-COLD-LOAD-STREAM "Found inhibit-scheduling-flag in Null Process" T))
      )))

(DEFUN IDLE-PROCESS-TOP-LEVEL (&REST IGNORE)
  (SETQ *PREEMPTION-ENABLED* 'T)
  (LET ((SI:INHIBIT-SCHEDULING-FLAG NIL)
	(*DEBUG-IO* "Error in Null Process"))
    (LOOP DOING
      (WHEN (AND (OR SI:INHIBIT-SCHEDULING-FLAG (NOT *PREEMPTION-ENABLED*))
		 *BREAK-ON-INHIBIT-SCHEDULING-IN-NULL-PROCESS*)
	(TV:KBD-USE-COLD-LOAD-STREAM "Found inhibit-scheduling-flag in Null Process" T))
      ;; No process to run, do idle time stuff 
      (WHEN *SHOW-PROCESS-SWITCHES*
	(SI:IGNORE-ERRORS-IN-SCHEDULER (TV:WHO-LINE-UPDATE)))
      #+3600
      ;; do some sequence break work, so we don't have to wait for the clock.
      (WHEN (PLUSP (FILL-POINTER *QUEUED-WAKEUPS*))
	;; this will flush the sequence-break queue, in case sequence-break went off
	;; during a stack-group switch.
	(WITH-SCHEDULER-LOCKED))
      (IDLE-POLL-WAIT-FUNCTIONS 4)
      (UNLESS SI:INHIBIT-IDLE-SCAVENGING-FLAG
	(WITH-SCHEDULER-LOCKED
	  (SI:%GC-SCAVENGE SI:GC-IDLE-SCAVENGE-QUANTUM SI:GC-IDLE-SCAVENGE-MAX-TIME)))
      ;; With less time spent in disk-wait, it's easy for this to not get run.
      #-VLM
      (%FUNCALL-IN-AUX-STACK #'STORAGE::STORAGE-BACKGROUND-FUN)
      #+VLM
      ;; On the VLM, we want to avoid having the emulator running continuously and
      ;; using all of the host CPU.  Therefore, we issue this coprocessor read to wait
      ;; for the VLM's life support to detect an event (e.g., incoming network packet)
      ;; which means that there's work for us to do again.  However, if the GC hasn't
      ;; finished scavenging, we should let it do so before waiting or background
      ;; scavenging will run much more slowly than reasonable.
      (WHEN (OR SI:INHIBIT-IDLE-SCAVENGING-FLAG	;Don't worry about the GC if inhibited.
		SI:%GC-FLIP-READY)
	(UNLESS *NEXT-TIMER-WAKEUP-TIME*
	  ;; If no timer is pending, we still need to wakeup periodically to avoid hanging.
	  (SYS:%COPROCESSOR-WRITE 750000. SYS:%COPROCESSOR-REGISTER-WAIT-FOR-EVENT))
	(SYS:%COPROCESSOR-READ SYS:%COPROCESSOR-REGISTER-WAIT-FOR-EVENT)))))

;;
;; top level

(DEFUN PROCESS-TOP-LEVEL (&OPTIONAL IGNORE)
  (DECLARE (INLINE PROCESS-DEBUG-FLAG))
  (LOOP
    (LET ((*TERMINAL-IO* (IF (LDB-TEST %%PROCESS-DEBUG-NO-BACKGROUND-INTERACTOR
				       (PROCESS-DEBUG-FLAG %REAL-CURRENT-PROCESS))
			     TV:COLD-LOAD-STREAM
			     TV:DEFAULT-BACKGROUND-STREAM))
	  ;; for protection
	  (SI:INHIBIT-SCHEDULING-FLAG NIL)
	  (PROCESS %REAL-CURRENT-PROCESS))
      (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS (PROCESS-DEBUG-FLAG PROCESS)) 0)
      (SETQ *PREEMPTION-ENABLED* 'T)
      (%PREAMBLE-ON-SWITCH-TO-PROCESS)
      (PROCESS-TOP-LEVEL-1 PROCESS))))

(DEFMETHOD (PROCESS-TOP-LEVEL-1 PROCESS) ()
  (UNLESS (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG)
    (UNWIND-PROTECT
	(CATCH-ERROR-RESTART-IF (LDB-TEST %%PROCESS-DEBUG-NOT-RESTARTABLE DEBUG-FLAG)
				((ERROR SYS:ABORT) "Exit process ~A" NAME)
	  (ERROR-RESTART-IF (NOT (LDB-TEST %%PROCESS-DEBUG-NOT-RESTARTABLE DEBUG-FLAG))
			    ((ERROR SYS:ABORT) "Restart process ~A" NAME)
	    (APPLY (CAR INITIAL-FORM) (CDR INITIAL-FORM))
	    (SI:PROCESS-FLUSH-BACKGROUND-STREAM)))
      (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 0)
      (SI:PROCESS-FLUSH-BACKGROUND-STREAM))
    (SETF (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) 1))
  (WITH-SCHEDULER-LOCKED
    (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) NIL)
    (PROCESS-DISABLE SELF)
    (SETF STATE 'DEAD)
    (SETF WAIT-FUNCTION #'FALSE)
    (SETF WAIT-ARGUMENT-LIST NIL)
    (WHEN WAIT-RECORD
      (DEALLOCATE-RESOURCE 'WAIT-SLOTS WAIT-RECORD)
      (SETQ WAIT-RECORD NIL))
    (COND ((LDB-TEST PROCESS-DEBUG-DEALLOCATE-STACK-GROUP DEBUG-FLAG)
	   (PUSHNEW SELF *DEAD-PROCESSES-FOR-DEBUGGING*)
	   (SETF WHOSTATE "(dead process)"))
	  ((NOT (NULL INITIAL-STACK-GROUP-DESCRIPTOR))
	   (SETF (SYS:SG-NAME INITIAL-STACK-GROUP) "Process")
	   (CONDITION-CASE ()
		(DEALLOCATE-RESOURCE 'STACK-GROUP-FOR-PROCESS
				     INITIAL-STACK-GROUP INITIAL-STACK-GROUP-DESCRIPTOR)
	      (SI:RESOURCE-ERROR NIL))
	   (SETF STACK-GROUP NIL)
	   (SETF INITIAL-STACK-GROUP NIL)
	   (SETF INITIAL-STACK-GROUP-DESCRIPTOR NIL)))
    (WHEN (LDB-TEST PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG)
      (SETF *ALL-PROCESSES* (DELETE SELF *ALL-PROCESSES* :COUNT 1)))
    ;; current-process is guaranteed to be NEQ to find-highest-priority-process because
    ;; we just made it unrunnable.
    (RUN-PROCESS-DISPATCHER)
    ;; If this returns it means that we are going to reuse this stack group.
    ))

;;
(DEFVAR *SIMPLE-STACK-GROUP-1-CACHE* NIL)
(DEFVAR *SIMPLE-STACK-GROUP-ALLOCS* 0)
(DEFVAR *SIMPLE-STACK-GROUP-CACHE-ALLOCS* 0)

;; stack-group should generally be NIL
(DEFUN SPAWN-SIMPLE-PROCESS (STACK-GROUP PROCESS)
  (IGNORE STACK-GROUP)
  (SI:INCF* *SIMPLE-STACK-GROUP-ALLOCS*)
  (OR (LET ((SG *SIMPLE-STACK-GROUP-1-CACHE*))
	(WHEN (AND SG (STORE-CONDITIONAL (LOCF *SIMPLE-STACK-GROUP-1-CACHE*) SG NIL))
	  (SI:INCF* *SIMPLE-STACK-GROUP-CACHE-ALLOCS*)
	  (SETF (SYS:SG-NAME SG) PROCESS)
	  SG))
      (MULTIPLE-VALUE-BIND (SG DESCRIPTOR)
	  (ALLOCATE-RESOURCE 'STACK-GROUP-FOR-SIMPLE-PROCESS)
	(SETF (PROCESS-INITIAL-STACK-GROUP-DESCRIPTOR PROCESS) DESCRIPTOR)
	(SETF (SYS:SG-NAME SG) PROCESS)
	SG)))

(DEFUN RETURN-SIMPLE-PROCESS-SG (STACK-GROUP &OPTIONAL DESCRIPTOR)
  (SETF (SYS:SG-NAME STACK-GROUP) "Simple Process")
  (UNLESS (STORE-CONDITIONAL (LOCF *SIMPLE-STACK-GROUP-1-CACHE*) NIL STACK-GROUP)
    (CONDITION-CASE ()
	 (DEALLOCATE-RESOURCE 'STACK-GROUP-FOR-SIMPLE-PROCESS STACK-GROUP DESCRIPTOR)
       (SI:RESOURCE-ERROR NIL))))

(DEFMETHOD (SIMPLE-PROCESS-DIED SIMPLE-PROCESS) (KILL)
  (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) NIL)
  (SETF STACK-GROUP NIL)
  (SETF WAIT-FUNCTION (CAR INITIAL-STACK-GROUP))
  (SETF WAIT-ARGUMENT-LIST (CDR INITIAL-STACK-GROUP))
  (WHEN WAIT-RECORD
    (DEALLOCATE-RESOURCE 'WAIT-SLOTS WAIT-RECORD)
    (SETQ WAIT-RECORD NIL))
  (WHEN KILL
    (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL-SELF 'DEAD NIL)
    (SETQ ARREST-REASONS NIL)
    (SETQ RUN-REASONS NIL)
    (WHEN (LDB-TEST PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG)
      (SETF *ALL-PROCESSES* (DELETE SELF *ALL-PROCESSES* :COUNT 1)))))

(DEFUN SIMPLE-PROCESS-TOP-LEVEL (&OPTIONAL IGNORE)
  (DECLARE (INLINE PROCESS-VERIFY-FUNCTION PROCESS-VERIFY-FUNCTION-ARGS PROCESS-INITIAL-FORM
		   PROCESS-INITIAL-STACK-GROUP PROCESS-WHOSTATE PROCESS-DEBUG-FLAG))
  ;; it's going to be NIL anyway, when we get here, but for completeness...
  (SETQ *PREEMPTION-ENABLED* NIL)
  ;; %%PROCESS-SWITCH-IN-PROGRESS is still 'T here, because we aren't really in *any*
  ;; process.
  (LET ((SI:INHIBIT-SCHEDULING-FLAG NIL)
	(WE-ARE-THE-DISPATCHER NIL)
	(DESCRIPTOR NIL)
	(*DEBUG-IO* "Error in dispatcher"))
    (WHEN (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES
		    (PROCESS-DEBUG-FLAG %REAL-CURRENT-PROCESS))
      (SIMPLE-PROCESS-DIED %REAL-CURRENT-PROCESS T))
    (LOOP DOING
      (LET* ((NEXT-PROCESS (FIND-HIGHEST-PRIORITY-PROCESS))
	     (SG (PROCESS-STACK-GROUP NEXT-PROCESS)))
	(SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS (PROCESS-DEBUG-FLAG %REAL-CURRENT-PROCESS))
	      0)
	(IF WE-ARE-THE-DISPATCHER
	    (METERING:DEFINE-METERING-POINT (PROCESS-SWITCH NIL NIL :ENV (:SCHEDULER))
					    (OLD-PROCESS NEW-PROCESS)
	      %REAL-CURRENT-PROCESS NEXT-PROCESS)
	    ;; we've come from another dispatcher, and we have a waiting simple-process.
	    ;; Therefore, the descriptor is ours.
	    (WHEN (AND SG (EQL SG SYS:%CURRENT-STACK-GROUP) (PROCESS-SIMPLE-P NEXT-PROCESS))
	      ;; get an up-to-date resource-descriptor.
	      (SETF DESCRIPTOR (PROCESS-INITIAL-STACK-GROUP-DESCRIPTOR NEXT-PROCESS))
	      ;; Someone preset the stack-group, so we'd better recover.
	      (SETF SG NIL)))
	(SET-RUN-LIGHT-FOR-PROCESS NEXT-PROCESS)
	(IF (ZL:TYPEP SG ':STACK-GROUP)
	    (PROGN
	      ;; this should still be 'T, anyway.
	      (SETF %%PROCESS-SWITCH-IN-PROGRESS 'T)
	      (RETURN-SIMPLE-PROCESS-SG SYS:%CURRENT-STACK-GROUP DESCRIPTOR)
	      ;; do this here, so an error above doesn't screw up someones stack-group
	      (SETF %REAL-CURRENT-PROCESS NEXT-PROCESS)
	      ;; for users
	      (SETF *CURRENT-PROCESS* NEXT-PROCESS)
	      (STACK-GROUP-RESUME SG NIL)
	      ;; we don't reset %%PROCESS-SWITCH-IN-PROGRESS because we still are in between
	      ;; processes in a very real way.

	      ;; we came here from another process-dispatcher, via stack-group-resume, so
	      ;; we don't need to update the meters.
	      (SETF WE-ARE-THE-DISPATCHER NIL))
	    (LET ((NEW-PRIORITY T))
	      (UNWIND-PROTECT
		  (LET ((*TERMINAL-IO* 
			  (IF (LDB-TEST %%PROCESS-DEBUG-NO-BACKGROUND-INTERACTOR
					(PROCESS-DEBUG-FLAG NEXT-PROCESS))
			      TV:COLD-LOAD-STREAM
			      TV:DEFAULT-BACKGROUND-STREAM)))
		    (SETF WE-ARE-THE-DISPATCHER 'T)
		    (SETF %REAL-CURRENT-PROCESS NEXT-PROCESS)
		    (SETF *IN-PROCESS-DISPATCHER* T)
		    (SETF *CURRENT-PROCESS*
			  #+enable-current-process-nil NIL
			  #-enable-current-process-nil NEXT-PROCESS)
		    (SETF (PROCESS-STACK-GROUP NEXT-PROCESS) SYS:%CURRENT-STACK-GROUP)
		    ;; not "in-scheduler" here, because we have no state to save.
		    (%PREAMBLE-ON-SWITCH-TO-PROCESS)
		    (SI:WITH-METERING-DISABLED
		      (SETF (PROCESS-VERIFY-FUNCTION NEXT-PROCESS) #'TRUE)
		      (SETF (PROCESS-VERIFY-FUNCTION-ARGS NEXT-PROCESS) NIL)
		      (TV:WHO-LINE-PROCESS-CHANGE NEXT-PROCESS)
		      (STOP-POLL-OF-SIMPLE-PROCESS NEXT-PROCESS))
		    (SETF *PREEMPTION-ENABLED* 'T)
		    (ERROR-RESTART ((ERROR SYS:ABORT)
				    "Restart process ~A"
				    (PROCESS-NAME %REAL-CURRENT-PROCESS))
		      (LOOP DOING
			(WHEN (NOT (PROCESS-WAKEUP-WAITING-SWITCH NEXT-PROCESS))
			  (LET ((*TERMINAL-IO*
				  (IF (LDB-TEST %%PROCESS-DEBUG-NO-BACKGROUND-INTERACTOR
						(PROCESS-DEBUG-FLAG NEXT-PROCESS))
				      TV:COLD-LOAD-STREAM
				      TV:DEFAULT-BACKGROUND-STREAM))
				(*DEBUG-IO* SI:SYN-TERMINAL-IO))
			    (MULTIPLE-VALUE-BIND (FUNCTION ARGS)
				(PROCESS-INITIAL-FUNCTION-AND-ARGS NEXT-PROCESS)
			      (APPLY FUNCTION ARGS))))
			(SETF *PREEMPTION-ENABLED* NIL)
			(SETF (PROCESS-WAKEUP-WAITING-SWITCH NEXT-PROCESS) NIL)
			(LET* ((VERIFY-FUNCTION-SPEC (PROCESS-INITIAL-STACK-GROUP NEXT-PROCESS))
			       (VERIFY-FUNCTION (CAR VERIFY-FUNCTION-SPEC))
			       (VERIFY-FUNCTION-ARGS (CDR VERIFY-FUNCTION-SPEC)))
			  (SETF NEW-PRIORITY (APPLY VERIFY-FUNCTION VERIFY-FUNCTION-ARGS))
			  (WHEN (NULL NEW-PRIORITY)
			    ;; make sure sequence break doesn't try to wake us up.
			    (SETF (PROCESS-VERIFY-FUNCTION NEXT-PROCESS) VERIFY-FUNCTION)
			    (SETF (PROCESS-VERIFY-FUNCTION-ARGS NEXT-PROCESS)
				  VERIFY-FUNCTION-ARGS)
			    (WHEN (OR (EQ (PROCESS-WHOSTATE NEXT-PROCESS)
					  *PROCESS-RUN-WHOSTATE*)
				      (STRING= (PROCESS-WHOSTATE NEXT-PROCESS) "Run"))
			      (SETF (PROCESS-WHOSTATE NEXT-PROCESS)
				    (OR (PROCESS-TOP-LEVEL-WHOSTATE NEXT-PROCESS)
					"SIMPLE-PROCESS wait")))
			    (SI:WITH-METERING-DISABLED
			      (LET ((INTERVAL (PROCESS-POLLING-INTERVAL NEXT-PROCESS)))
				(WHEN INTERVAL
				  (POLL-SIMPLE-PROCESS NEXT-PROCESS INTERVAL T))))
			    (RETURN))
			  (SET-PROCESS-PRIORITY NEXT-PROCESS NEW-PRIORITY)
			  (PREEMPTION-BEING-REENABLED)))))
		(SETF *PREEMPTION-ENABLED* NIL)
		(%POSTSCRIPT-ON-EXIT-FROM-PROCESS NIL (SYS:%MICROSECOND-CLOCK))
		(SETF %%PROCESS-SWITCH-IN-PROGRESS 'T)
		(SI:CLEAR-RUN-LIGHT SYS:PROCESS-RUN-LIGHT)
		(SETF (PROCESS-STACK-GROUP NEXT-PROCESS) NIL)
		(SETF (PROCESS-INITIAL-STACK-GROUP-DESCRIPTOR NEXT-PROCESS) NIL)
		(WHEN (NULL NEW-PRIORITY)
		  (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL NEXT-PROCESS 'BLOCKED NIL)))))))))

#||
;; when you patch simple-process-top-level, you should run this:
(process::with-scheduler-locked
  (when process::*simple-stack-group-1-cache*
    (si:stack-group-preset process::*simple-stack-group-1-cache*
			   'process::simple-process-top-level))
  (si:map-resource 'process::stack-group-for-simple-process
		   #'(lambda (sg in-use-p resource)
		       (unless in-use-p
			 (si:stack-group-preset sg 'process::simple-process-top-level)))))
||#

(DEFUN PROCESS-ALLOW-PREEMPTION ()
  (LET ((OLD-PREEMPTION *PREEMPTION-ENABLED*))
    (UNWIND-PROTECT
	(PROGN (SETF *PREEMPTION-ENABLED* T)
	       (WITH-SCHEDULER-LOCKED
		 ;; causes instantaneous priority to be recomputed.
		 (RECALCULATE-PRIORITY %REAL-CURRENT-PROCESS)
		 (UNLESS (EQL %REAL-CURRENT-PROCESS (FIND-HIGHEST-PRIORITY-PROCESS))
		   (RUN-PROCESS-DISPATCHER))))
      (SETF *PREEMPTION-ENABLED* OLD-PREEMPTION)
      #+ignore
      (TV:WHO-LINE-RUN-STATE-UPDATE))))


