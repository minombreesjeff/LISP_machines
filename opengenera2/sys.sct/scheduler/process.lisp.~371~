;;; -*- Mode: LISP; Syntax: Common-lisp; Package: process; Base: 10; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFRESOURCE STACK-GROUP-FOR-PROCESS ()
  :CONSTRUCTOR (LET ((OBJECT (MAKE-STACK-GROUP "Process"
					       :REGULAR-PDL-SIZE #+3600 #O7000 #+IMACH #O20000
					       :ABSOLUTE-CONTROL-STACK-LIMIT #O30000
					       :SPECIAL-PDL-SIZE #+3600 #O500 #+IMACH #O2000
					       :ABSOLUTE-BINDING-STACK-LIMIT #O4000
					       :SAFE 0)))
		 (STACK-GROUP-PRESET OBJECT #'PROCESS-TOP-LEVEL)
		 OBJECT))

(DEFRESOURCE STACK-GROUP-FOR-SIMPLE-PROCESS ()
  :CONSTRUCTOR (LET ((SG (MAKE-STACK-GROUP "Simple Process"
					   :REGULAR-PDL-SIZE #+3600 #O7000 #+IMACH #O20000
					   :ABSOLUTE-CONTROL-STACK-LIMIT #O30000
					   :SPECIAL-PDL-SIZE #+3600 #O500 #+IMACH #O2000
					   :ABSOLUTE-BINDING-STACK-LIMIT #O4000
					   :SAFE 0)))
		 (SI:STACK-GROUP-PRESET SG #'PROCESS::SIMPLE-PROCESS-TOP-LEVEL)
		 SG))

;; Process creation

(DEFUN NO-INITIAL-FUNCTION-ERROR ()
  (ERROR "The process was not given an initial function."))

(DEFUN MAKE-PROCESS (NAME &REST INIT-ARGS &KEY
		     (PRIORITY *DEFAULT-PROCESS-PRIORITY*)
		     (INITIAL-FUNCTION NIL) (INITIAL-FUNCTION-ARGUMENTS NIL)
		     (VERIFY-FUNCTION NIL) (VERIFY-FUNCTION-ARGUMENTS NIL)
		     (FLAVOR NIL)
		     (RUN-REASONS NIL REASONS-SUPPLIED) (AREA NIL)
		     SIMPLE-P INTERRUPT-HANDLER SYSTEM-PROCESS
		     FLAGS
		     &ALLOW-OTHER-KEYS)
  (IF FLAVOR
      (SETQ SIMPLE-P (SUBTYPEP FLAVOR 'SIMPLE-PROCESS))
      (SETQ FLAVOR (IF SIMPLE-P 'SIMPLE-PROCESS 'PROCESS)))
  (LET ((NEW-PROCESS
	  (LET ((LIST-AREA AREA))
	    (WHEN (NULL AREA)
	      (SETQ LIST-AREA SYS:WORKING-STORAGE-AREA)
	      (SETQ AREA (IF INTERRUPT-HANDLER
			     SYS:SAFEGUARDED-OBJECTS-AREA
			     SYS:WORKING-STORAGE-AREA)))
	    (LET ((INITIALLY-RUNNABLE (AND (NOT (NULL INITIAL-FUNCTION))
					   (NOT (AND SIMPLE-P (NULL VERIFY-FUNCTION))))))
	      (COND (REASONS-SUPPLIED
		     (WHEN (AND RUN-REASONS (NOT INITIALLY-RUNNABLE))
		       (ERROR "The process cannot be made active because no initial function was supplied."))
		     (UNLESS (LISTP RUN-REASONS)
		       (SETQ RUN-REASONS (LIST-IN-AREA LIST-AREA RUN-REASONS))))
		    (T
		     (WHEN INITIALLY-RUNNABLE
		       (SETQ RUN-REASONS (LIST-IN-AREA LIST-AREA :ENABLE))))))
	    (LET ((INITIAL-FORM (IF INITIAL-FUNCTION
				    (LIST*-IN-AREA LIST-AREA
						   INITIAL-FUNCTION INITIAL-FUNCTION-ARGUMENTS)
				    (LIST-IN-AREA LIST-AREA #'NO-INITIAL-FUNCTION-ERROR))))
	      (COND (SIMPLE-P
		     (WHEN (NULL VERIFY-FUNCTION)
		       (SETQ VERIFY-FUNCTION #'FALSE))
		     (LET ((PREDICATE-FORM (LIST*-IN-AREA LIST-AREA
							  VERIFY-FUNCTION
							  VERIFY-FUNCTION-ARGUMENTS)))
		       (IF (EQ FLAVOR 'SIMPLE-PROCESS)
			   (APPLY #'MAKE-SIMPLE-PROCESS-INTERNAL NAME
				  INITIAL-FORM PREDICATE-FORM RUN-REASONS AREA
				  INIT-ARGS)
			   (APPLY #'MAKE-INSTANCE FLAVOR :NAME NAME
				  :INITIAL-FORM INITIAL-FORM
				  :PREDICATE-FORM PREDICATE-FORM
				  :RUN-REASONS RUN-REASONS
				  :AREA AREA
				  :ALLOW-OTHER-KEYS T
				  INIT-ARGS))))
		    (T
		     (IF (EQ FLAVOR 'PROCESS)
			 (APPLY #'MAKE-PROCESS-INTERNAL NAME INITIAL-FORM RUN-REASONS AREA
				INIT-ARGS)
			 (APPLY #'MAKE-INSTANCE FLAVOR :NAME NAME
				:INITIAL-FORM INITIAL-FORM
				:RUN-REASONS RUN-REASONS
				:AREA AREA
				:ALLOW-OTHER-KEYS T
				INIT-ARGS))))))))
    (WHEN SYSTEM-PROCESS
      (SETF (LDB PROCESS-DEBUG-SYSTEM-PROCESS (PROCESS-DEBUG-FLAG NEW-PROCESS)) 1))
    (WHEN FLAGS
      (LOOP FOR (FLAG VALUE) ON FLAGS by #'CDDR DO
	(SET-PROCESS-FLAG NEW-PROCESS FLAG VALUE)))
    (WITH-SCHEDULER-LOCKED
      (PUSH NEW-PROCESS *ALL-PROCESSES* :AREA SI:WORKING-STORAGE-AREA)
      (SET-PRIORITY NEW-PROCESS PRIORITY)
      (PROCESS-CONSIDER-RUNNABILITY NEW-PROCESS))
    NEW-PROCESS))

(DEFPARAMETER *LEGAL-STACK-GROUP-INIT-KEYWORDS-FOR-PROCESS*
	      '(:SG-AREA :SAFE
		:REGULAR-PDL-AREA :SPECIAL-PDL-AREA
		:REGULAR-PDL-SIZE :SPECIAL-PDL-SIZE
		:ABSOLUTE-CONTROL-STACK-LIMIT :ABSOLUTE-BINDING-STACK-LIMIT))

(DEFMETHOD (MAKE-INSTANCE PROCESS) (&REST INIT-PLIST)
  (SETF (LDB %%PROCESS-DEBUG-FUNCALL-POLICY-HOOK-ON-PROCESS-SWITCH DEBUG-FLAG) 1)
  (SETQ BASE-QUANTUM QUANTUM)
  (SETQ PROCESS-PRIORITY (MAKE-ARRAY 20 :FILL-POINTER 0 :AREA (SYS:%AREA-NUMBER SELF)))
  (VECTOR-PUSH-EXTEND *DEFAULT-PROCESS-PRIORITY* PROCESS-PRIORITY)
  (SETQ PRIORITY *DEFAULT-PROCESS-PRIORITY*)  ;instantaneous priority is the same
  (RESET-SCHEDULER-INFO SELF)
  (WHEN (NOT SIMPLE-P)
    (COND (STACK-GROUP
	   (SETQ INITIAL-STACK-GROUP STACK-GROUP)
	   (SETQ STATE 'ARRESTED))
	  ((LOOP FOR KEY IN INIT-PLIST BY 'CDDR
		 THEREIS (MEMBER KEY *LEGAL-STACK-GROUP-INIT-KEYWORDS-FOR-PROCESS*))
	   (SETQ INITIAL-STACK-GROUP
		 (APPLY #'SI:MAKE-STACK-GROUP NAME :ALLOW-OTHER-KEYS T INIT-PLIST))
	   (SETQ STACK-GROUP INITIAL-STACK-GROUP)))))

(DEFMETHOD (MAKE-INSTANCE SIMPLE-PROCESS) (&KEY &ALLOW-OTHER-KEYS)
  ;; Put these two lists, touched each time the process runs, on the same page as the process
  (WHEN (AND INITIAL-FORM INITIAL-STACK-GROUP)
    (LET ((ARRAY (MAKE-ARRAY (+ (LENGTH INITIAL-FORM) (LENGTH INITIAL-STACK-GROUP))
			     :AREA (SYS:%AREA-NUMBER SELF)))
	  (I 0))
      (LOOP FOR (ELEM . MORE) ON INITIAL-FORM DO
	(SYS:%P-STORE-CDR-AND-CONTENTS (LOCF (AREF ARRAY I)) ELEM
				       (IF MORE SYS:CDR-NEXT SYS:CDR-NIL))
	(INCF I))
      (LOOP FOR (ELEM . MORE) ON INITIAL-STACK-GROUP
	    FOR J FROM I DO
	(SYS:%P-STORE-CDR-AND-CONTENTS (LOCF (AREF ARRAY J)) ELEM
				       (IF MORE SYS:CDR-NEXT SYS:CDR-NIL)))
      (SETQ INITIAL-FORM (SYS:%MAKE-POINTER SYS:DTP-LIST (LOCF (AREF ARRAY 0)))
	    INITIAL-STACK-GROUP (SYS:%MAKE-POINTER SYS:DTP-LIST (LOCF (AREF ARRAY I))))))
  (SETQ WAIT-FUNCTION (CAR INITIAL-STACK-GROUP))
  (SETQ WAIT-ARGUMENT-LIST (CDR INITIAL-STACK-GROUP))
  (SETQ WHOSTATE TOP-LEVEL-WHOSTATE))

(DEFMETHOD (SYS:PRINT-SELF PROCESS) (STREAM IGNORE SLASHIFY-P)
  (IF SLASHIFY-P
      (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
	(PRINC NAME STREAM)
	(LET* ((PRI (PROCESS-PROCESS-PRIORITY SELF))
	       (CLASS (SCHEDULER-PRIORITY-CLASS PRI)))
	  (WHEN PRI
	    (FORMAT STREAM " (~D ~D)"
		    CLASS
		    (IF (OR (= CLASS *PROCESS-PRIORITY-CLASS-FOREGROUND*)
			    (= CLASS *PROCESS-PRIORITY-CLASS-INTERACTIVE*))
			(BACK-CONVERT-FOREGROUND-PRIORITY (SCHEDULER-PRIORITY-PRIORITY PRI))
			(SCHEDULER-PRIORITY-PRIORITY PRI))))))
      (PRINC NAME STREAM)))

(DEFUN PROCESS-RUN-FUNCTION (NAME-OR-KWDS FUNCTION &REST ARGS)
  "Run a function in its own process.  The process is reused if the machine is warm booted
or if the process is reset."
  (IF (LISTP NAME-OR-KWDS)
      (APPLY #'PROCESS-RUN-FUNCTION-2 FUNCTION ARGS NAME-OR-KWDS)
      (PROCESS-RUN-FUNCTION-2 FUNCTION ARGS :NAME NAME-OR-KWDS)))

(DEFUN PROCESS-RUN-FUNCTION-2 (FUNCTION ARGS
			       &REST MAKE-PROCESS-ARGS
			       &KEY
			       (NAME "Anonymous")
			       (RESTART-AFTER-BOOT NIL)
			       (RESTART-AFTER-RESET RESTART-AFTER-BOOT)
			       (WARM-BOOT-ACTION (IF RESTART-AFTER-BOOT
						     'PROCESS-WARM-BOOT-DELAYED-RESTART
						     'PROCESS-WARM-BOOT-RESET))
			       &ALLOW-OTHER-KEYS)
  (SI:WITH-REM-KEYWORDS (PROCESS-ARGS MAKE-PROCESS-ARGS '(:WARM-BOOT-ACTION))
    (LET ((PROCESS
	    (APPLY
	      #'MAKE-PROCESS NAME :RUN-REASONS NIL
	      :INITIAL-FUNCTION FUNCTION :INITIAL-FUNCTION-ARGUMENTS (COPY-LIST ARGS)
	      :WARM-BOOT-ACTION (CASE WARM-BOOT-ACTION
				  ((:FLUSH) 'PROCESS-FLUSH)
				  (OTHERWISE WARM-BOOT-ACTION))
	      PROCESS-ARGS)))
      (SETF (LDB-TEST %%PROCESS-DEBUG-NOT-RESTARTABLE (PROCESS-DEBUG-FLAG PROCESS))
	    (NOT RESTART-AFTER-RESET))
      (ENABLE PROCESS)
      PROCESS)))





(DEFUN PROCESS-P (THING)
  (TYPEP THING 'PROCESS))

(DEFUN MAP-OVER-ALL-PROCESSES (FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (MAP NIL #'(LAMBDA (P) (APPLY FUNCTION P ARGS))
       *ALL-PROCESSES*))

(DEFUN MAP-OVER-ACTIVE-PROCESSES (FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (MAP NIL #'(LAMBDA (P)
	       (WHEN (PROCESS-ACTIVE-P P)
		 (APPLY FUNCTION P ARGS)))
       *ALL-PROCESSES*))



;; Process primitives.  Block/wakeup and variants.

(DEFSUBST-IN-FLAVOR (PROCESS-FORCE-WAKEUP-2 PROCESS) ()
  (SI:AVOID-STACK-OVERFLOW 500.)
  (SETQ RUNNABLE-START-TIME (SYS:%MICROSECOND-CLOCK))
  (MAKE-PROCESS-RUNNABLE-SELF)
  (WHEN SCHEDULER-QUEUE
    (SCHEDULER-QUEUE-DELETE SCHEDULER-QUEUE SELF))
  (INSERT-ON-RUNNABLE-QUEUE SELF)
  T)

(DEFSUBST-IN-FLAVOR (EVALUATE-WAIT-FUNCTION PROCESS) ()
  (CONDITION-BIND-DEFAULT ((DBG:DEBUGGER-CONDITION
			     #'(LAMBDA (ERROR)
				 (IGNORE ERROR)
				 (THROW 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION NIL))))
    (LET ((SYS:DEFAULT-CONS-AREA SI:WORKING-STORAGE-AREA)
	  (*CURRENT-PROCESS* SELF)
	  (*EVALUATING-VERIFY-FUNCTIONS* T))
      (APPLY WAIT-FUNCTION WAIT-ARGUMENT-LIST))))
       
(DEFSUBST-IN-FLAVOR (PROCESS-WAKEUP-2 PROCESS) ()
  (LET ((VERIFY (BLOCK VERIFY
		  (CATCH 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION
		    (RETURN-FROM VERIFY
		      (EVALUATE-WAIT-FUNCTION)))
		  (SETQ WAKEUP-WAITING-SWITCH T)
		  T)))
    (WHEN (NOT (NULL VERIFY))
      (WHEN (NOT (EQ VERIFY T))
	(SET-PRIORITY SELF VERIFY))
      (SI:AVOID-STACK-OVERFLOW 500.)
      (SETQ RUNNABLE-START-TIME (SYS:%MICROSECOND-CLOCK))
      (MAKE-PROCESS-RUNNABLE-SELF)
      (WHEN SCHEDULER-QUEUE
	(SCHEDULER-QUEUE-DELETE SCHEDULER-QUEUE SELF))
      (INSERT-ON-RUNNABLE-QUEUE SELF)
      T)))

(DEFMETHOD (PROCESS-WAKEUP PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (CASE STATE
      ((RUNNABLE)
       (OR (NOT (NULL SCHEDULER-QUEUE))
	   (PROCESS-WAKEUP-2)))
      ((ARRESTED)
       (INCF *ARRESTED-WAKEUPS*))
      ((DEAD)
       (INCF *DEAD-WAKEUPS*)
       (WHEN (LDB-TEST PROCESS-DEBUG-DEBUG-WAKEUPS DEBUG-FLAG)
	 (CERROR "Ignore wakeup" "~S tried to wakeup ~S, which is a :DEAD process."
		 %REAL-CURRENT-PROCESS SELF)))
      (T
	;; We need something like #'ignore-errors-in-scheduler around this.
	;; Which should wake the process up, informing it about the error in
	;; its verify function.
	(PROCESS-WAKEUP-2))))) 

(DEFMETHOD (PROCESS-FORCE-WAKEUP PROCESS) ()
  ;; wakeup a process regardless of its verify-function.
  (WITH-SCHEDULER-LOCKED
    (SETQ WAIT-FUNCTION #'TRUE)
    (SETQ WAIT-ARGUMENT-LIST NIL)
    (CASE STATE
      ((RUNNABLE)
       (UNLESS SCHEDULER-QUEUE
	 (PROCESS-FORCE-WAKEUP-2))
       T)
      ((ARRESTED)
       (INCF *ARRESTED-WAKEUPS*))
      ((DEAD)
       (INCF *DEAD-WAKEUPS*)
       (WHEN (LDB-TEST PROCESS-DEBUG-DEBUG-WAKEUPS DEBUG-FLAG)
	 (CERROR "Ignore wakeup" "~S tried to wakeup ~S, which is a 'DEAD process."
		 %REAL-CURRENT-PROCESS SELF)))
      (T
	(PROCESS-FORCE-WAKEUP-2)
	T))))

(DEFMETHOD (PROCESS-WAKEUP-WITHOUT-TEST PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (CASE STATE
      ((RUNNABLE)
       (UNLESS SCHEDULER-QUEUE
	 (SETQ WAKEUP-WAITING-SWITCH T)
	 (PROCESS-FORCE-WAKEUP-2))
       'T)
      ((ARRESTED)
       (INCF *ARRESTED-WAKEUPS*))
      ((DEAD)
       (INCF *DEAD-WAKEUPS*)
       (WHEN (LDB-TEST PROCESS-DEBUG-DEBUG-WAKEUPS DEBUG-FLAG)
	 (CERROR "Ignore wakeup" "~S tried to wakeup ~S, which is a :DEAD process."
		 %REAL-CURRENT-PROCESS SELF)))
      (T
	(SETQ WAKEUP-WAITING-SWITCH T)
	(PROCESS-FORCE-WAKEUP-2)
	'T))))

(DEFMETHOD (PROCESS-RECONSIDER-WAKEUP PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (WHEN (PROCESS-RUNNABLE-P-SELF)
      (CATCH 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION
	(WHEN (NOT (EVALUATE-WAIT-FUNCTION))
	  (%FORCE-PROCESS-NOT-RUNNABLE SELF 'BLOCKED NIL))))))



;;;;

;; PROCESS-BLOCK

;; Takes a verify function.  This function is called when the process
;; becomes runnable, to determine whether it really should be woken up.
;; If context switching were free, or cheaper, then this optimization
;; would be pointless, since calling process-block inside a loop is a
;; lot more flexible.  However we want to avoid the cost of flushing the
;; stack cache, and messing with the binding stack when possible.

;; Verify function shouldn't have free references, since there is no way of knowing
;; what context it will be called in.

(DEFUN PROCESS-BLOCK (WHOSTATE VERIFY-FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG VERIFY-FUNCTION))
  (APPLY #'PROCESS-BLOCK-INTERNAL %REAL-CURRENT-PROCESS 'BLOCKED NIL WHOSTATE
	 VERIFY-FUNCTION ARGS))

(DEFUN PROMOTION-BLOCK (SCHEDULER-QUEUE WHOSTATE VERIFY-FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG VERIFY-FUNCTION))
  (APPLY #'PROCESS-BLOCK-INTERNAL
	 %REAL-CURRENT-PROCESS 'PROMOTION-BLOCKED SCHEDULER-QUEUE WHOSTATE
	 VERIFY-FUNCTION ARGS))

(DEFUN CL:SLEEP (N-SECONDS &KEY (SLEEP-REASON "Sleep"))
  (PROCESS-BLOCK-WITH-TIMEOUT N-SECONDS SLEEP-REASON #'FALSE))

(DEFUN PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION (WHOSTATE INTERVAL FUNCTION &REST ARGUMENTS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (IF SI:*NEW-SCHEDULER-ENABLED*
      (LET ((PROC %REAL-CURRENT-PROCESS)
	    (NEW-PRIORITY (APPLY FUNCTION ARGUMENTS)))
	;; Verify that we really want to go blocked.
	(IF NEW-PRIORITY
	    (UNLESS (EQL NEW-PRIORITY 'T)
	      (WITH-SCHEDULER-LOCKED
		(SET-PRIORITY PROC NEW-PRIORITY)))
	    (POLL-WAIT-FUNCTION PROC WHOSTATE INTERVAL FUNCTION ARGUMENTS)))
      (APPLY #'SI:PROCESS-SPIN-WAIT WHOSTATE FUNCTION ARGUMENTS)))

(DEFUN BLOCK-AND-POLL-WITH-TIMEOUT
       (N-SECONDS WHOSTATE INTERVAL FUNCTION &REST ARGUMENTS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (WITH-PROCESS-BLOCK-TIMEOUT (N-SECONDS TIMER)
    (APPLY
      #'PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
      WHOSTATE INTERVAL
      #'(LAMBDA (TIMER FUNCTION &REST ARGUMENTS)
	  (OR (TIMER-EXPIRED-P TIMER) (APPLY FUNCTION ARGUMENTS)))
      TIMER FUNCTION ARGUMENTS)))

(DEFUN PROCESS-WAIT (WHOSTATE FUNCTION &REST ARGUMENTS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (APPLY #'PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
	 WHOSTATE *PROCESS-WAIT-INTERVAL* FUNCTION ARGUMENTS))

;;; Returns T if condition is true, NIL if you time out.
;;; If TIME is NIL, then this is effectively PROCESS-WAIT, but exists
;;; for the convenience of user programs.
(DEFUN PROCESS-WAIT-WITH-TIMEOUT (WHOSTATE TIME FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (COND ((NOT SI:*NEW-SCHEDULER-ENABLED*)
	 ;; if scheduler isn't enabled, process-block- will poll, and this way we don't
	 ;; need to use timeouts. (or wait-function polling)
	 (APPLY #'PROCESS-BLOCK-WITH-TIMEOUT TIME WHOSTATE FUNCTION ARGS))
	(TIME
	 (WITH-PROCESS-BLOCK-TIMEOUT (TIME TIMER)
	   (APPLY #'PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
		  WHOSTATE *PROCESS-WAIT-INTERVAL*
		  #'(LAMBDA (TIMER FUNCTION &REST ARGS)
		      (OR (TIMER-EXPIRED-P TIMER)
			  (APPLY FUNCTION ARGS)))
		  TIMER FUNCTION ARGS)))
	(T 
	 (APPLY #'PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
		WHOSTATE *PROCESS-WAIT-INTERVAL* FUNCTION ARGS)))
  (NOT (NULL (APPLY FUNCTION ARGS))))

(DEFUN PROCESS-WAIT-FOREVER (&OPTIONAL (WHOSTATE "Wait Forever"))
  (PROCESS-BLOCK WHOSTATE #'FALSE))

;; this is bullshit, since you probably want to defer wakeups that aren't lexically scoped,
;; too.  But this *does* cover some of the common cases.
(DEFMACRO WITH-WAKEUPS-DEFERRED (BODY &OPTIONAL BLOCKING-FORM)
  (WHEN BLOCKING-FORM
    (UNLESS (AND (LISTP BLOCKING-FORM) (EQ (CAR BLOCKING-FORM) 'PROCESS-BLOCK))
      (ERROR "BLOCKING-FORM, ~S, must be a call to PROCESS-BLOCK" BLOCKING-FORM)))
  (LET ((WAKEUPS (GENSYM))
	(FORCED-WAKEUPS (GENSYM)))
    `(LET ((,WAKEUPS NIL)
	   (,FORCED-WAKEUPS NIL))
       (FLET ((DEFER-PROCESS-WAKEUP (PROCESS)
		(PUSH PROCESS ,WAKEUPS))
	      (DEFER-PROCESS-FORCE-WAKEUP (PROCESS)
		(PUSH PROCESS ,FORCED-WAKEUPS)))
	 (MULTIPLE-VALUE-PROG1
	   ,BODY
	   (WITH-SCHEDULER-LOCKED
	     (MAPC #'PROCESS-FORCE-WAKEUP ,FORCED-WAKEUPS)
	     (MAPC #'PROCESS-WAKEUP ,WAKEUPS)
	     ,BLOCKING-FORM))))))

(ZWEI:DEFINDENTATION (WITH-WAKEUPS-DEFERRED 0 4 1 2))


;;
;; internal functions
;;
(DEFSUBST %FORCE-PROCESS-NOT-RUNNABLE-INTERNAL (PROC TYPE QUEUE)
  (WHEN (PROCESS-RUNNABLE-P PROC)
    (SI:INCF* (PROCESS-TIME-RUNNABLE PROC)
	      (SYS:%32-BIT-DIFFERENCE (SYS:%MICROSECOND-CLOCK)
				      (PROCESS-RUNNABLE-START-TIME PROC))))
  (MAKE-PROCESS-NOT-RUNNABLE PROC)
  (WHEN QUEUE
    (SCHEDULER-QUEUE-INSERT QUEUE PROC))
  (SETF (PROCESS-STATE PROC) TYPE))

(DEFSUBST %FORCE-PROCESS-NOT-RUNNABLE (PROC TYPE QUEUE)
  (WITH-SCHEDULER-LOCKED
    (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL PROC TYPE QUEUE)))

(DEFSUBST-IN-FLAVOR (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL-SELF PROCESS) (TYPE QUEUE)
  (WHEN (PROCESS-RUNNABLE-P-SELF)
    (SI:INCF* TIME-RUNNABLE
	      (SYS:%32-BIT-DIFFERENCE (SYS:%MICROSECOND-CLOCK)
				      RUNNABLE-START-TIME)))
  (MAKE-PROCESS-NOT-RUNNABLE SELF)
  (WHEN QUEUE
    (SCHEDULER-QUEUE-INSERT QUEUE SELF))
  (SETQ STATE TYPE))

(DEFSUBST-IN-FLAVOR (%FORCE-PROCESS-NOT-RUNNABLE-SELF PROCESS) (TYPE QUEUE)
  (WITH-SCHEDULER-LOCKED
    (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL-SELF TYPE QUEUE)))

(DEFSUBST PROCESS-BLOCK-INTERNAL-1 (PROC TYPE QUEUE)
  (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL PROC TYPE QUEUE)
  ;; We explicitly call the scheduler here because if you call
  ;; process-block you are yielding the processor - even if you are
  ;; inside of a with-scheduler-locked.  And if you are inside nested
  ;; WITH-SCHEDULER-LOCKEDs, you won't yield the processor until much later
  ;; than you expect.  (imagine looping inside a WITH-SCHEDULER-LOCKED with a
  ;; call to PROCESS-BLOCK inside the loop.)
  (RUN-PROCESS-DISPATCHER))

(DEFUN PROCESS-BLOCK-INTERNAL (PROC TYPE NEW-QUEUE WHOSTATE VERIFY-FUNCTION &REST ARGS)
  (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS))
  (DECLARE (INLINE PROCESS-WAKEUP-WAITING-SWITCH
		   PROCESS-VERIFY-FUNCTION
		   PROCESS-VERIFY-FUNCTION-ARGS
		   PROCESS-WHOSTATE))
  (WHEN (NOT (EQ *CURRENT-PROCESS* %REAL-CURRENT-PROCESS))
    (COND
      (*EVALUATING-VERIFY-FUNCTIONS* (THROW 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION NIL))
      ((NOT (EQ PROC %REAL-CURRENT-PROCESS))
       (CERROR "Force the process to re-evaluate the verify function in its own stack-group"
	       "Process ~A tried to BLOCK when *CURRENT-PROCESS* was bound incorrectly." proc)
       (THROW 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION NIL))
      (T (ERROR "Process ~A tried to BLOCK when *CURRENT-PROCESS* was bound incorrectly."))))
  (LET ((OLD-WHOSTATE (WHEN WHOSTATE (PROCESS-WHOSTATE PROC))))
    (WITH-SCHEDULER-LOCKED
      (SETF (PROCESS-WAKEUP-WAITING-SWITCH PROC) NIL)
      (LET ((NEW-PRIORITY (CATCH 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION
			    (APPLY VERIFY-FUNCTION ARGS))))
	;; Verify that we really want to go blocked.
	(COND
	  (NEW-PRIORITY
	   ;; We don't.
	   (SET-PRIORITY PROC NEW-PRIORITY))
	  ;; can we block?
	  ((NOT SI:*NEW-SCHEDULER-ENABLED*)
	   (CL:APPLY #'SI:PROCESS-SPIN-WAIT WHOSTATE VERIFY-FUNCTION ARGS)
	   NIL)
	  (T
	   ;; We are going to block.
	   ;; Don't have to worry about atomically setting verify-function and arguments,
	   ;; since sequence-break never calls it.
	   (SETF (PROCESS-VERIFY-FUNCTION PROC) VERIFY-FUNCTION)
	   (SETF (PROCESS-VERIFY-FUNCTION-ARGS PROC) ARGS)
	   (SETF (PROCESS-WAKEUP-WAITING-SWITCH PROC) NIL)
	   (LOOP with process-in-waiters-queue-p
		 DOING (WHEN WHOSTATE
			 (SETF (PROCESS-WHOSTATE PROC) WHOSTATE)
			 ;; I'm copying this strategy from the old
			 ;; scheduler, but it seems inefficient for process
			 ;; switch to call this.  The who line updater
			 ;; should poll processes since process-switches are
			 ;; much more frequent than who-line updates.
			 (TV:WHO-LINE-PROCESS-CHANGE PROC))
		       ;; 
		       ;; If the process is in the waiters vector, make
		       ;; sure we don't get screwed by process-interrupt
		       ;; removing us while we're not looking
		       ;;
		       (setq process-in-waiters-queue-p
			     (let ((waiter (process-wait-record proc)))
			       (and waiter (not (null (waiting-process-index waiter))))))
		       (PROCESS-BLOCK-INTERNAL-1 PROC TYPE NEW-QUEUE)
		 UNTIL
		 ;; Did sequence break (or someone who can't evaluate the wait-function
		 ;; themselves) nab us?
		   (OR process-in-waiters-queue-p	; if we were in the waiters queue,
						;         just exit now, and let caller
						;         deal with putting us back
		       (NOT (PROCESS-WAKEUP-WAITING-SWITCH PROC))
		       ;; sequence break tried to wake us up.
		       ;; make sure verify function is true.
		       (SETF (PROCESS-WAKEUP-WAITING-SWITCH PROC) NIL)
		       ;; verify function might have been changed out from under us.
		       (LET ((NEW-PRIORITY (CATCH 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION
					     (APPLY (PROCESS-VERIFY-FUNCTION PROC)
						    (PROCESS-VERIFY-FUNCTION-ARGS PROC)))))
			 (WHEN NEW-PRIORITY 
			   (SET-PRIORITY PROC NEW-PRIORITY))
			 NEW-PRIORITY))))))
      ;; Can't leave &REST args lying around anywhere.
      (SETF (PROCESS-VERIFY-FUNCTION-ARGS PROC) NIL)
      (SETF (PROCESS-VERIFY-FUNCTION PROC) #'TRUE)
      (WHEN WHOSTATE 
	(SETF (PROCESS-WHOSTATE PROC) OLD-WHOSTATE)
	(TV:WHO-LINE-PROCESS-CHANGE PROC)))))


;;priority

(DEFSUBST-IN-FLAVOR (%PROCESS-PROMOTED-P PROCESS) ()
  (NOT (NULL BASE-PRIORITY)))

(DEFMETHOD (PROCESS-PROMOTED-P PROCESS) ()
  (%PROCESS-PROMOTED-P))

;; needs to be called inside a with-scheduler-locked.
(DEFSUBST-IN-FLAVOR (%PROCESS-PRIORITY-LEVEL PROCESS) ()
  (MAX 0 (1- (FILL-POINTER PROCESS-PRIORITY))))

(DEFMETHOD (PROCESS-PRIORITY-LEVEL-INTERNAL PROCESS) ()
  (WITH-SCHEDULER-LOCKED (%PROCESS-PRIORITY-LEVEL)))

(DEFSUBST-IN-FLAVOR (%PROCESS-PRIORITY-IN-REGION-INTERNAL PROCESS) ()
  (> (FILL-POINTER PROCESS-PRIORITY) 1))

(DEFMETHOD (%PROCESS-PRIORITY-IN-REGION PROCESS) ()
  (%PROCESS-PRIORITY-IN-REGION-INTERNAL))

(DEFMETHOD (PROCESS-PROCESS-PRIORITY PROCESS) ()
  (AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL)))

(DEFMETHOD (PROCESS::PROCESS-BASE-PROCESS-PRIORITY PROCESS) ()
  (AREF PROCESS::PROCESS-PRIORITY 0))

;; the next five functions need to be called inside a WITH-SCHEDULER-LOCKED.
(DEFMETHOD (RECALCULATE-PRIORITY PROCESS) ()
  (SET-PRIORITY-INTERNAL SELF (GET-INSTANTANEOUS-PRIORITY SELF
				(AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL)))))

;; these four functions are called with a PROCESS-PRIORITY
(DEFMETHOD (SET-PRIORITY PROCESS) (NEW-PRIORITY)
  (UNLESS (OR (EQ NEW-PRIORITY 'T) (EQ NEW-PRIORITY NIL))
    (LET* ((OLD-PRIORITY (AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL)))
	   (INSTANTANEOUS-PRIORITY
	     (ADJUSTED-INSTANTANEOUS-PRIORITY SELF OLD-PRIORITY NEW-PRIORITY)))
      (UNLESS (OR (EQ INSTANTANEOUS-PRIORITY 'T) (EQ INSTANTANEOUS-PRIORITY NIL))
	(SETF (AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL)) NEW-PRIORITY)
	(SET-PRIORITY-INTERNAL SELF INSTANTANEOUS-PRIORITY))))
  NEW-PRIORITY)

(DEFMETHOD (PUSH-PROCESS-PRIORITY PROCESS) (NEW-PRIORITY)
  (LET ((OLD-PRIORITY (AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL))))
    (COND ((OR (EQ NEW-PRIORITY 'T) (EQ NEW-PRIORITY NIL))
	   (SI:FAST-VECTOR-PUSH-EXTEND OLD-PRIORITY PROCESS-PRIORITY))
	  (T
	   (SI:FAST-VECTOR-PUSH-EXTEND NEW-PRIORITY PROCESS-PRIORITY)
	   (SET-PRIORITY-INTERNAL SELF
	     (ADJUSTED-INSTANTANEOUS-PRIORITY SELF OLD-PRIORITY NEW-PRIORITY))))
    NEW-PRIORITY))

(DEFMETHOD (SET-BASE-PRIORITY PROCESS) (NEW-PRIORITY)
  (UNLESS (OR (EQ NEW-PRIORITY 'T) (EQ NEW-PRIORITY NIL))
    (LET ((OLD-PRIORITY (AREF PROCESS-PRIORITY 0)))
      (SETF (AREF PROCESS-PRIORITY 0) NEW-PRIORITY)
      (WHEN (= (FILL-POINTER PROCESS-PRIORITY) 1)
	(SET-PRIORITY-INTERNAL SELF
	  (ADJUSTED-INSTANTANEOUS-PRIORITY SELF OLD-PRIORITY NEW-PRIORITY)))))
  NEW-PRIORITY)

(DEFMETHOD (POP-PROCESS-PRIORITY PROCESS) ()
  (WHEN (%PROCESS-PRIORITY-IN-REGION-INTERNAL)
    (LET* ((OLD-PRIORITY (SI:FAST-VECTOR-POP PROCESS-PRIORITY))
	   (NEW-PRIORITY (AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL))))
      (UNLESS (EQL OLD-PRIORITY NEW-PRIORITY)
	(SET-PRIORITY-INTERNAL SELF
	  (ADJUSTED-INSTANTANEOUS-PRIORITY SELF OLD-PRIORITY NEW-PRIORITY)))))
  (AREF PROCESS-PRIORITY (%PROCESS-PRIORITY-LEVEL)))

(DEFMETHOD (SET-PRIORITY-LEVEL PROCESS) (NEW-PRIORITY LEVEL)
  (with-scheduler-locked
    (LET ((CURRENT-LEVEL (%PROCESS-PRIORITY-LEVEL)))
      (WHEN ( LEVEL CURRENT-LEVEL)
	(LET ((OLD-PRIORITY (AREF PROCESS-PRIORITY LEVEL)))
	  (IF (OR (NULL NEW-PRIORITY) (EQL NEW-PRIORITY 'T))
	      (SETF NEW-PRIORITY OLD-PRIORITY)
	      (SETF (AREF PROCESS-PRIORITY LEVEL) NEW-PRIORITY))
	  (WHEN (AND (= LEVEL CURRENT-LEVEL)
		     (NOT (EQL OLD-PRIORITY NEW-PRIORITY)))
	    (SET-PRIORITY-INTERNAL SELF
	      (ADJUSTED-INSTANTANEOUS-PRIORITY SELF OLD-PRIORITY NEW-PRIORITY)))))
      NEW-PRIORITY)))

;; must be called from inside a with-scheduler-locked if (PROCESS-SCHEDULER-QUEUE SELF) is a
;; runnable queue.
;; This knows about the representation of priorities.
;; this is called with a SCHEDULER-PRIORITY
(DEFMETHOD (SET-PRIORITY-INTERNAL PROCESS) (NEW-PRIORITY)
  (LET ((PRIORITY-CHANGED NIL)
	(OLD-PRIORITY PRIORITY))
    (COND ((OR (EQ NEW-PRIORITY 'T) (EQ NEW-PRIORITY NIL)))
	  ;; scheduler priority
	  ((NUMBERP NEW-PRIORITY)
	   (WHEN (SCHEDULER-PRIORITY-REAL-TIME-CLASS NEW-PRIORITY)
	     (SETF (LDB %%SCHEDULER-PRIORITY-PRIORITY-WITHOUT-PREEMPTION NEW-PRIORITY)
		   (LDB %%SCHEDULER-PRIORITY-PRIORITY-WITHOUT-PREEMPTION 
			(SYS:%32-BIT-PLUS (SCHEDULER-PRIORITY-PRIORITY NEW-PRIORITY)
					  (SYS:%MICROSECOND-CLOCK)))))
	   (IF (%PROCESS-PROMOTED-P)
	       (PROGN
		 (SETQ BASE-PRIORITY NEW-PRIORITY)
		 (WHEN (SCHEDULER-PRIORITY-LESSP NEW-PRIORITY OLD-PRIORITY)
		   (SETQ PRIORITY NEW-PRIORITY)
		   (SETQ PRIORITY-CHANGED 'T)))
	       (PROGN
		 (SETQ PRIORITY NEW-PRIORITY)
		 (SETQ PRIORITY-CHANGED 'T))))
	  ;; It isn't an instantaneous priority; we have to interpret it.
	  ;; it must be a process-priority (programmer priority)
	  ;; This shouldn't get here.  Soon, we'll put in a breakpoint for debugging.
	  (T (SET-PRIORITY SELF NEW-PRIORITY)))
    (WHEN PRIORITY-CHANGED
      (WHEN SCHEDULER-QUEUE
	(UNLESS (AND (OR (NOT (PROCESS-RUNNABLE-P-SELF))
			 (EQL SCHEDULER-QUEUE (AREF *RUNNABLE-PROCESSES*
						    (SCHEDULER-PRIORITY-CLASS NEW-PRIORITY))))
		     (AND (OR (NULL PREVIOUS-PROCESS)
			      (FUNCALL (SCHEDULER-QUEUE-PREDICATE SCHEDULER-QUEUE)
				       PREVIOUS-PROCESS SELF))
			  (OR (NULL NEXT-PROCESS)
			      (FUNCALL (SCHEDULER-QUEUE-PREDICATE SCHEDULER-QUEUE)
				       SELF NEXT-PROCESS))))
	  (LET ((Q SCHEDULER-QUEUE))
	    (SI:AVOID-STACK-OVERFLOW 100.)
	    (SCHEDULER-QUEUE-DELETE Q SELF)
	    (IF (EQ STATE 'RUNNABLE)
		;; this tries to shift the order of the processes to the smallest possible
		;; extent.
		(IF (SCHEDULER-PRIORITY-LESSP OLD-PRIORITY NEW-PRIORITY)
		    (INSERT-HIGH-ON-RUNNABLE-QUEUE SELF)
		    (INSERT-ON-RUNNABLE-QUEUE SELF))
		(SCHEDULER-QUEUE-INSERT Q SELF)))))
      (WHEN (EQL STATE 'PROMOTION-BLOCKED)
	(LOOP WITH UPGRADE = (SCHEDULER-PRIORITY-LESSP NEW-PRIORITY OLD-PRIORITY)
	      FOR PR BEING THE ARRAY-ELEMENTS OF PROMOTING-SET DO
	  (COND ((PROMOTION-RECORD-CURRENT-PROMOTION PR)
		 (LET ((OTHER (PROMOTION-RECORD-OTHER-PROCESS PR)))
		   (IF UPGRADE
		       (ADJUST-PROMOTED-PRIORITY OTHER (PROCESS-PRIORITY OTHER) NEW-PRIORITY)
		       (RECOMPUTE-PROMOTED-PRIORITY OTHER))))
		((AND UPGRADE (SCHEDULER-PRIORITY-LESSP
				NEW-PRIORITY
				(PROCESS-PRIORITY (PROMOTION-RECORD-OTHER-PROCESS PR))))
		 (PROMOTE-PRIORITY
		   (PROMOTION-RECORD-OTHER-PROCESS PR) (PROMOTION-RECORD-OTHER-PROMOTION PR))))))))
  NEW-PRIORITY)

;; This is called *after* the priority of a process has changed due to promotion.  It
;; finds the right place on the scheduler queue, and propogates the priority through
;; if this process is promotion blocked
(DEFMETHOD (ADJUST-PROMOTED-PRIORITY PROCESS) (OLD-PRIORITY NEW-PRIORITY)
  (WHEN SCHEDULER-QUEUE
    (UNLESS (AND (OR (NOT (PROCESS-RUNNABLE-P-SELF))
		     (EQL SCHEDULER-QUEUE (AREF *RUNNABLE-PROCESSES*
						(SCHEDULER-PRIORITY-CLASS NEW-PRIORITY))))
		 (AND (OR (NULL PREVIOUS-PROCESS)
			  (FUNCALL (SCHEDULER-QUEUE-PREDICATE SCHEDULER-QUEUE)
				   PREVIOUS-PROCESS SELF))
		      (OR (NULL NEXT-PROCESS)
			  (FUNCALL (SCHEDULER-QUEUE-PREDICATE SCHEDULER-QUEUE)
				   SELF NEXT-PROCESS))))
      (LET ((Q SCHEDULER-QUEUE))
	(SI:AVOID-STACK-OVERFLOW 100.)
	(SCHEDULER-QUEUE-DELETE Q SELF)
	(IF (EQ STATE 'RUNNABLE)
	    (IF (SCHEDULER-PRIORITY-LESSP OLD-PRIORITY NEW-PRIORITY)
		(INSERT-ON-RUNNABLE-QUEUE SELF)
		(INSERT-HIGH-ON-RUNNABLE-QUEUE SELF))
	    (SCHEDULER-QUEUE-INSERT Q SELF)))))
  (WHEN (AND (EQL STATE 'PROMOTION-BLOCKED) (NOT (EQL OLD-PRIORITY NEW-PRIORITY)))
    (LOOP WITH UPGRADE = (SCHEDULER-PRIORITY-LESSP NEW-PRIORITY OLD-PRIORITY)
	  FOR PR BEING THE ARRAY-ELEMENTS OF PROMOTING-SET DO
      (COND ((PROMOTION-RECORD-CURRENT-PROMOTION PR)
	     (LET ((OTHER (PROMOTION-RECORD-OTHER-PROCESS PR)))
	       (IF UPGRADE
		   (ADJUST-PROMOTED-PRIORITY OTHER (PROCESS-PRIORITY OTHER) NEW-PRIORITY)
		   (RECOMPUTE-PROMOTED-PRIORITY OTHER))))
	    ((AND UPGRADE (SCHEDULER-PRIORITY-LESSP
			    NEW-PRIORITY
			    (PROCESS-PRIORITY (PROMOTION-RECORD-OTHER-PROCESS PR))))
	     (PROMOTE-PRIORITY
	       (PROMOTION-RECORD-OTHER-PROCESS PR) (PROMOTION-RECORD-OTHER-PROMOTION PR)))))))

;; promotion

(defstruct (promotion-record)
  (my-uid nil)
  (other-process nil)
  (other-uid nil)
  (other-promotion nil)  ;; for efficiency, records index in other's promotion/promoting set.
  (current-promotion nil))

(defmacro add-promotion-record (array)
  `(let ((total-size (array-leader ,array 1))
	 (fill-pointer (fill-pointer ,array)))
     (when (= fill-pointer total-size)
       (loop repeat 3 do
	 (vector-push-extend (make-promotion-record) ,array 3))
       (setf (fill-pointer ,array) fill-pointer)
       (setf (array-leader ,array 1) (+ total-size 3)))
     (incf (fill-pointer ,array))
     (aref ,array fill-pointer)))

;; redetermine the priority from scratch based on base-priority and the
;; promotion set
(defsubst-in-flavor (%recompute-promoted-priority process) ()
  (loop with new-priority = base-priority
	with new-promotion = nil
	with old-priority = priority 
	for pr being the array-elements of promotion-set
	as pri1 =
	   (process-priority (promotion-record-other-process pr)) do
    (setf (promotion-record-current-promotion pr) nil)
    (let ((other (promotion-record-other-promotion pr)))
      (when other (setf (promotion-record-current-promotion pr) nil)))
    (when (scheduler-priority-lessp pri1 new-priority)
      (setq new-promotion pr)
      (setq new-priority pri1))
	finally
	  (setq priority new-priority)
	  (when new-promotion
	    (setf (promotion-record-current-promotion new-promotion) t)
	    (setf (promotion-record-current-promotion
		    (promotion-record-other-promotion new-promotion)) t))
	  (adjust-promoted-priority self old-priority priority)))

(defmethod (recompute-promoted-priority process) ()
 (%recompute-promoted-priority))

;; as an optimization, if you know that a particular promotion record will determine the 
;; priority of the process, you can call %PROMOTE-PRIORITY instead of 
;; %RECOMPUTE-PROMOTED-PRIORITY
(defsubst-in-flavor (%promote-priority process) (promotion-record)
  (unless (promotion-record-current-promotion promotion-record)
    (when (> 1 (length promotion-set))
      (loop for opr being the array-elements of promotion-set do
	(setf (promotion-record-current-promotion opr) nil)
	(let ((oother (promotion-record-other-promotion opr)))
	  (when oother (setf (promotion-record-current-promotion oother) nil)))))
    (setf (promotion-record-current-promotion promotion-record) t)
    (let ((other (promotion-record-other-promotion promotion-record)))
      (when other
	(setf (promotion-record-current-promotion other) t))))
  (let ((old-priority priority)
	(new-priority (process-priority (promotion-record-other-process promotion-record))))
    (setq priority new-priority)
    (adjust-promoted-priority self old-priority new-priority)))

(defmethod (promote-priority process) (promotion-record)
  (%promote-priority promotion-record))

(defmacro find-promotion-record (array my-uid other-p other-uid)
  `(loop for pr being the array-elements of ,array
	 do (when (and (eql (promotion-record-my-uid pr) ,my-uid)
		       (eql (promotion-record-other-process pr) ,other-p)
		       (eql (promotion-record-other-uid pr) ,other-uid))
	      (return pr))))

(defmethod (add-promotion-to-promotion-set process) (uid2 p1 uid1 other)
  (let* ((promoted-p (%PROCESS-PROMOTED-P))
	 (pr (or (and promoted-p (find-promotion-record promotion-set uid2 p1 uid1))
		 (add-promotion-record promotion-set))))
    (setf (promotion-record-my-uid pr) uid2)
    (setf (promotion-record-other-process pr) p1)
    (setf (promotion-record-other-uid pr) uid1)
    (setf (promotion-record-other-promotion pr) other)
    (unless promoted-p
      (setq base-priority priority))
    (cond ((scheduler-priority-lessp (process-priority p1) priority)
	   (%promote-priority pr))
	  ((scheduler-priority-lessp priority (process-priority p1))
	   (when (promotion-record-current-promotion pr)
	     (%recompute-promoted-priority))))
    pr))

(defmethod (add-promotion-to-promoting-set process) (uid1 p2 uid2)
  (let ((pr (or (find-promotion-record promoting-set uid1 p2 uid2)
		(add-promotion-record promoting-set))))
    (setf (promotion-record-my-uid pr) uid1)
    (setf (promotion-record-other-process pr) p2)
    (setf (promotion-record-other-uid pr) uid2)
    (setf (promotion-record-other-promotion pr) nil)
    (setf (promotion-record-current-promotion pr) nil)
    pr))

(defun add-promotion (p1 uid1 p2 uid2)
  "Process P1 with UID1 is promoting process P2 with UID2.  When P2 finishes UID2, or
P1 quits UID1 this promotion will be removed (by finish-promotions or remove-promotions
respectively.)"
  (with-scheduler-locked
    (let* ((pr1 (add-promotion-to-promoting-set p1 uid1 p2 uid2))
	   (pr2 (add-promotion-to-promotion-set p2 uid2 p1 uid1 pr1)))
      (setf (promotion-record-other-promotion pr1) pr2)
      pr2)))

(defgeneric remove-promotions (p1 uid1) 
  "Note that P1 has finished UID1.  Remove all promotions done for P1 at UID1")
(defgeneric finish-promotions (p2 uid2) 
  "Note that P2 has finished UID2.  Remove all promotions done to P2 at UID2")

(defmethod (remove-promotions-from-promotion-set process) (p1 uid1)
  (loop with need-priority-adjust = nil
	with work-done = nil
	with idx = 0
	with n = (1- (fill-pointer promotion-set))
	while ( idx n)
	as pr = (aref promotion-set idx) do
    (if (and (eql (promotion-record-other-uid pr) uid1)
	     (eql (promotion-record-other-process pr) p1))
	(progn
	  (setq work-done t)
	  (unless (= n idx)
	    (setf (aref promotion-set idx) (aref promotion-set n))
	    (setf (aref promotion-set n) pr))
	  (decf n)
	  ;; clear out potentially stack-consed entries.
	  (setf (promotion-record-my-uid pr) nil)
	  (setf (promotion-record-other-uid pr) nil)
	  (when (promotion-record-current-promotion pr) (setq need-priority-adjust t))
	  (setf (promotion-record-current-promotion pr) nil))
	(incf idx))
	finally
	  (when work-done
	    (let ((new-fill-pointer (1+ n))
		  (old-priority priority))
	      (setf (fill-pointer promotion-set) new-fill-pointer)
	      (cond ((zerop new-fill-pointer)
		     (setq priority base-priority)
		     (setq base-priority nil)
		     (when need-priority-adjust
		       (adjust-promoted-priority self old-priority priority)))
		    (t (when need-priority-adjust
			 (%recompute-promoted-priority))))))))

(defmethod (remove-promotions-from-promoting-set process) (p2 uid2)
  (loop with idx = 0
	with n = (1- (fill-pointer promoting-set))
	while ( idx n)
	as pr = (aref promoting-set idx) do
    (if (and (eql (promotion-record-other-uid pr) uid2)
	     (eql (promotion-record-other-process pr) p2))
	(progn
	  (unless (= n idx)
	    (setf (aref promoting-set idx) (aref promoting-set n))
	    (setf (aref promoting-set n) pr))
	  (decf n)
	  ;; clear out potentially stack-consed entries.
	  (setf (promotion-record-my-uid pr) nil)
	  (setf (promotion-record-other-uid pr) nil))
	(incf idx))
	finally (setf (fill-pointer promoting-set) (1+ n))))

(defmethod (remove-promotion-from-promotion-set process) (promotion-record)
  (loop with need-priority-adjust = nil
	with work-done = nil
	with idx = 0
	with n = (1- (fill-pointer promotion-set))
	while ( idx n)
	as pr = (aref promotion-set idx) do
    (if (eql promotion-record pr)
	(progn
	  (setq work-done t)
	  (unless (= n idx)
	    (setf (aref promotion-set idx) (aref promotion-set n))
	    (setf (aref promotion-set n) pr))
	  (decf n)
	  ;; clear out potentially stack-consed entries.
	  (setf (promotion-record-my-uid pr) nil)
	  (setf (promotion-record-other-uid pr) nil)
	  (when (promotion-record-current-promotion pr) (setq need-priority-adjust t))
	  (setf (promotion-record-current-promotion pr) nil)
	  (loop-finish))
	(incf idx))
	finally
	  (when work-done
	    (let ((new-fill-pointer (1+ n))
		  (old-priority priority))
	      (setf (fill-pointer promotion-set) new-fill-pointer)
	      (cond ((zerop new-fill-pointer)
		     (setq priority base-priority)
		     (setq base-priority nil)
		     (when need-priority-adjust
		       (adjust-promoted-priority self old-priority priority)))
		    (t (when need-priority-adjust
			 (%recompute-promoted-priority))))))))

(defmethod (remove-promotion-from-promoting-set process) (promotion-record)
  (loop with idx = 0
	with n = (1- (fill-pointer promoting-set))
	while ( idx n)
	as pr = (aref promoting-set idx) do
    (if (eql promotion-record pr)
	(progn
	  (unless (= n idx)
	    (setf (aref promoting-set idx) (aref promoting-set n))
	    (setf (aref promoting-set n) pr))
	  (decf n)
	  ;; clear out potentially stack-consed entries.
	  (setf (promotion-record-my-uid pr) nil)
	  (setf (promotion-record-other-uid pr) nil)
	  (loop-finish))
	(incf idx))
	finally (setf (fill-pointer promoting-set) (1+ n))))
  
(defmethod (remove-promotions process) (uid1)
  (with-scheduler-locked
    ;; small optimization to make up for careless callers who want to call us to be safe, even
    ;; if the call is unnecessary.
    (when (plusp (fill-pointer promoting-set))
      (loop with idx = 0
	    with n = (1- (fill-pointer promoting-set))
	    while ( idx n)
	    as pr = (aref promoting-set idx) do
	(if (eql (promotion-record-my-uid pr) uid1)
	    (progn
	      (unless (= n idx)
		(setf (aref promoting-set idx) (aref promoting-set n))
		(setf (aref promoting-set n) pr))
	      (decf n)
	      ;; clear out potentially stack-consed entries.
	      (setf (promotion-record-my-uid pr) nil)
	      (setf (promotion-record-other-uid pr) nil)
	      ;; we are consistent now, fixup the partner
	      (let ((other (promotion-record-other-promotion pr)))
		(when other
		  (remove-promotion-from-promotion-set
		    (promotion-record-other-process pr) other))))
	    (incf idx))
	    finally (setf (fill-pointer promoting-set) (1+ n))))))

(defmethod (finish-promotions process) (uid2)
  (with-scheduler-locked
    ;; small optimization to make up for careless callers who want to call us to be safe, even
    ;; if the call is unnecessary.
    (when (plusp (fill-pointer promotion-set))
      (loop with work-done = nil
	    with need-priority-adjust = nil
	    with idx = 0
	    with n = (1- (fill-pointer promotion-set))
	    while ( idx n)
	    as pr = (aref promotion-set idx) do
	(if (eql (promotion-record-my-uid pr) uid2)
	    (progn
	      (setq work-done t)
	      (unless (= n idx)
		(setf (aref promotion-set idx) (aref promotion-set n))
		(setf (aref promotion-set n) pr))
	      (decf n)
	      ;; clear out potentially stack-consed entries.
	      (setf (promotion-record-my-uid pr) nil)
	      (setf (promotion-record-other-uid pr) nil)
	      (when (promotion-record-current-promotion pr) (setq need-priority-adjust t))
	      (setf (promotion-record-current-promotion pr) nil)
	      ;; we are consistent now, fixup the partner
	      (let ((other (promotion-record-other-promotion pr)))
		(when other
		  (remove-promotion-from-promoting-set
		    (promotion-record-other-process pr) other))))
	    (incf idx))
	    finally
	      (when work-done
		(let ((new-fill-pointer (1+ n))
		      (old-priority priority))
		  (setf (fill-pointer promotion-set) new-fill-pointer)
		  (cond ((zerop new-fill-pointer)
			 (setq priority base-priority)
			 (setq base-priority nil)
			 (when need-priority-adjust
			   (adjust-promoted-priority self old-priority priority)))
			(t (when need-priority-adjust (%recompute-promoted-priority))))))))))

(DEFUN-IN-FLAVOR (ENSURE-STACK-GROUP PROCESS) ()
  (COND ((NULL INITIAL-STACK-GROUP)
	 (MULTIPLE-VALUE-SETQ (INITIAL-STACK-GROUP INITIAL-STACK-GROUP-DESCRIPTOR)
	   (ALLOCATE-RESOURCE 'STACK-GROUP-FOR-PROCESS))
	 (SETQ STACK-GROUP INITIAL-STACK-GROUP)
	 (SETF (SYS:SG-NAME STACK-GROUP) SELF)
	 (SETQ STATE 'ARRESTED))
	((NULL STACK-GROUP)
	 (SETQ STACK-GROUP INITIAL-STACK-GROUP)
	 (WHEN (EQ STATE 'DEAD)
	   (SYS:STACK-GROUP-PRESET STACK-GROUP #'PROCESS-TOP-LEVEL)
	   (SETQ STATE 'ARRESTED)))))

;; Don't call this on the *null-process*, or any of the system processes.
#+3600
(DEFMETHOD (PROCESS-INTERRUPT PROCESS) (FUNCTION &REST ARGS)
  (IF (EQ SELF %REAL-CURRENT-PROCESS)
      (APPLY FUNCTION ARGS)
      (DO (SG-STATE) (NIL)			;Loop until in interruptible state
	(WITH-SCHEDULER-LOCKED
	  (IF SIMPLE-P
	      (WHEN (NULL STACK-GROUP)
		(SETQ STACK-GROUP (SPAWN-SIMPLE-PROCESS NIL SELF)))
	      (ENSURE-STACK-GROUP))
	  (SETQ SG-STATE (SYS:SG-STATUS-BITS STACK-GROUP))
	  (LET* ((FP (SYS:SG-FRAME-POINTER STACK-GROUP))	;Current frame
		 (PFP (SYS:FRAME-PREVIOUS-FRAME FP))	;Caller of the frame
		 (SP (SYS:SG-STACK-POINTER STACK-GROUP)))	;Top of stack is saved PC
	    (WHEN (AND (ZEROP (SYS:SG-NONRESUMABILITY STACK-GROUP))
		       (= (SYS:SG-ARG-STATUS STACK-GROUP) SYS:%SG-ARG-RESUME)
		       (EQ (SYS:FRAME-FUNCTION FP) #'STACK-GROUP-RESUME)
		       (OR (EQ (SYS:FRAME-FUNCTION PFP) #'RUN-PROCESS-DISPATCHER)
			   (LET ((FUNCTION (SYS:FRAME-FUNCTION PFP)))
			     (EQL (SYS:FUNCTION-NAME FUNCTION) 'RUN-PROCESS-DISPATCHER))))
	      ;; setup STACK-GROUP-RESUME and RUN-PROCESS-DISPATCHER to just return,
	      ;; and not execute any code.
	      ;; INTERRUPT-PROCESS-DISPATCHER will do all the appropriate cleanups

	      ;; this make stack-group-resume return through run-process-dispatcher
	      (SETF (SYS:FRAME-VALUE-DISPOSITION FP) SYS:%CALL-FOR-RETURN)
	      (SETF (SYS:SG-ARG-STATUS STACK-GROUP) SYS:%SG-ARG-BREAK))
	    ;; If now in safe state to interrupt, do so
	    (WHEN (AND (ZEROP (SYS:SG-NONRESUMABILITY STACK-GROUP))
		       (= (SYS:SG-ARG-STATUS STACK-GROUP) SYS:%SG-ARG-BREAK))
	      (DBG:SG-ENSURE-CONTROL-STACK-SPACE STACK-GROUP (+ 100 (LENGTH ARGS)))
	      ;; Build new frame on top of stack, clobbering over the return PC
	      (SETQ SG-STATE (CAR SP))
	      (SETQ PFP FP)
	      (SETQ FP (SYS:%MAKE-POINTER-OFFSET
			 SI:DTP-LOCATIVE SP
			 (+ (LENGTH ARGS)
			    4
			    (1- (SYS:DEFSTORAGE-SIZE SI:STACK-FRAME)))))
	      (SETF (SYS:FRAME-PREVIOUS-TOP FP)
		    (SYS:%MAKE-POINTER-OFFSET SI:DTP-LOCATIVE SP -1))
	      (SETF (SYS:FRAME-PREVIOUS-FRAME FP) PFP)
	      ;; don't bother executing any code in STACK-GROUP-RESUME
	      (SETF (SYS:FRAME-VALUE-DISPOSITION FP) SI:%CALL-FOR-RETURN)
	      (SETF (SYS:FRAME-RETURN-PC FP) SG-STATE)
	      (SETF (SYS:FRAME-MISC-DATA FP) 0)	;No cleanup, no special call
	      ;; whostate, verify-function, verify-args, function, + args
	      (SETF (SYS:FRAME-NUMBER-OF-ARGS FP) (+ 4 (LENGTH ARGS)))
	      (SETF (SYS:FRAME-FUNCTION FP) #'INTERRUPT-PROCESS-DISPATCHER)
	      (WITH-STACK-LIST*
		(FULL-ARGLIST WHOSTATE WAIT-FUNCTION WAIT-ARGUMENT-LIST FUNCTION ARGS)
		(LOOP FOR ARG IN FULL-ARGLIST
		      AS P = SP THEN (SYS:%MAKE-POINTER-OFFSET SI:DTP-LOCATIVE P 1)
		      DO (SYS:%P-STORE-CDR-CODE P SI:CDR-NEXT)
			 (SYS:%P-STORE-CONTENTS P ARG)))
	      (SETF (SYS:SG-FRAME-POINTER STACK-GROUP) FP)
	      (SETF (SYS:SG-STACK-POINTER STACK-GROUP) FP)
	      ;; Set stack group's PC so that when it wakes up the function gets called
	      (SYS:%P-STORE-CONTENTS FP SYS:RESTART-TRAPPED-CALL-ESCAPE-PC)
	      (WHEN (EQ STATE 'WAITING)
		(LET ((WAITER (PROCESS-WAIT-RECORD SELF)))
		  (WHEN WAITER
		    (WITH-WAITERS-LOCKED (WAITERS)
		      (REMOVE-WAITER-FROM-QUEUE WAITER WAITERS)))))
	      (PROCESS-FORCE-WAKEUP SELF)
	      (RETURN (VALUES))))
	  ;Interrupt will go off when process next scheduled
	  (PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
	    "Interruptible"
	    2.
	    #'(LAMBDA (P S)
		( (SYS:SG-STATUS-BITS (PROCESS-STACK-GROUP P)) S))
	    SELF SG-STATE))))
  NIL)

#+IMACH
(DEFMETHOD (PROCESS-INTERRUPT PROCESS) (FUNCTION &REST ARGS)
  (IF (EQ SELF %REAL-CURRENT-PROCESS)
      (APPLY FUNCTION ARGS)
      (DO (SG-STATE) (NIL)			;Loop until in interruptible state
	;; The WITH-SCHEDULER-LOCKED insures that no interrupts, or
	;; *anything* will be handled on the target stack group,
	;; because it won't be current until we finish.  
	;; We really shouldn't go blocked in here - that means we can't
	;; cons, or anything.
	(WITH-SCHEDULER-LOCKED
	  (IF SIMPLE-P
	      (WHEN (NULL STACK-GROUP)
		(SETQ STACK-GROUP (SPAWN-SIMPLE-PROCESS NIL SELF)))
	      (ENSURE-STACK-GROUP))
	  (SETQ SG-STATE (SYS:SG-STATUS-BITS STACK-GROUP))
	  (LET* ((CR (SYS:SG-CONTROL-REGISTER STACK-GROUP)))	;Top of stack is saved PC
	    (WHEN (AND (ZEROP (SYS:SG-NONRESUMABILITY STACK-GROUP))
		       (= (SYS:SG-ARG-STATUS STACK-GROUP) SYS:%SG-ARG-RESUME)
		       (EQ (si:%find-structure-header (SYS:SG-NEXT-PC STACK-GROUP))
			   #'STACK-GROUP-RESUME)
		       (LET ((FUNCTION (SI:%FIND-STRUCTURE-HEADER
					 (SYS:SG-CONTINUATION STACK-GROUP))))
			 (OR (EQ FUNCTION #'RUN-PROCESS-DISPATCHER)
			     (EQL (SYS:FUNCTION-NAME FUNCTION) 'RUN-PROCESS-DISPATCHER))))
	      ;; setup STACK-GROUP-RESUME and RUN-PROCESS-DISPATCHER to just return,
	      ;; and not execute any code.
	      ;; INTERRUPT-PROCESS-DISPATCHER will do all the appropriate cleanups

	      ;; this make stack-group-resume return through run-process-dispatcher
	      (SETF (SYS:%LOGLDB SYS:%%CR.VALUE-DISPOSITION CR)
		    SYS:VALUE-DISPOSITION-RETURN)
	      (SETF (SYS:SG-CONTROL-REGISTER STACK-GROUP) CR)
	      (SETF (SYS:SG-ARG-STATUS STACK-GROUP) SYS:%SG-ARG-BREAK))
	    ;; If now in safe state to interrupt, do so
	    (WHEN (AND (ZEROP (SYS:SG-NONRESUMABILITY STACK-GROUP))
		       (= (SYS:SG-ARG-STATUS STACK-GROUP) SYS:%SG-ARG-BREAK))
	      (DBG:SG-ENSURE-CONTROL-STACK-SPACE STACK-GROUP (+ 100 (LENGTH ARGS)))
	      (WITH-STACK-LIST*
		(FULL-ARGLIST WHOSTATE WAIT-FUNCTION WAIT-ARGUMENT-LIST FUNCTION ARGS)
		(APPLY #'SI:PUT-CALL-ON-STACK-GROUP
		       STACK-GROUP SYS:VALUE-DISPOSITION-RETURN 0
		       #'INTERRUPT-PROCESS-DISPATCHER FULL-ARGLIST))
	      (WHEN (EQ STATE 'WAITING)
		(LET ((WAITER (PROCESS-WAIT-RECORD SELF)))
		  (WHEN WAITER
		    (WITH-WAITERS-LOCKED (WAITERS)
		      (REMOVE-WAITER-FROM-QUEUE WAITER WAITERS)))))
	      (PROCESS-FORCE-WAKEUP SELF)
	      (RETURN (VALUES))))
	  ;Interrupt will go off when process next scheduled
	  (PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
	    "Interruptible"
	    2.
	    #'(LAMBDA (P S)
		( (SYS:SG-STATUS-BITS (PROCESS-STACK-GROUP P)) S))
	    SELF SG-STATE))))
  NIL)

;;; Like PROCESS-INTERRUPT, but only do it if the process is abortable.
;;; THROW-TAG defines where we plan to throw to, to delimit abortability, or NIL
;;; if WITHOUT-ABORTS at any level applies.  BOTTOM-FRAME delimits the search for that,
;;; we don't look lower than that in the stack for catches for that tag.
;;; If it doesn't become abortable after TIME-OUT, just return list of without-aborts reasons.
;;; Returns T if it succeeds, NIL if the process goes away.
(DEFUN PROCESS-INTERRUPT-WHEN-ABORTABLE (PROCESS FUNCTION ARGS
					 &KEY (TIME-OUT (* 5 60))	;5 seconds
					      (THROW-TAG NIL)
					      (BOTTOM-FRAME NIL))
  (WHEN (EQ PROCESS %REAL-CURRENT-PROCESS)	;No point in waiting in this case
    (SETQ TIME-OUT 0))
  (LABELS ((MOLEST (PENDING THROW-TAG BOTTOM-FRAME FUNCTION ARGS)
	     (LET ((REASONS (SI:THROW-INHIBIT-REASONS THROW-TAG NIL BOTTOM-FRAME)))
	       (COND (REASONS	;Cannot interrupt yet
		      (SETF (PPA-REASONS PENDING) (MAPCAR #'COPY-LIST REASONS))
		      (SETF (PPA-STATE PENDING) ':WAIT)
		      (PROCESS-WAKEUP (PPA-ATTACKER PENDING)))
		     (T
		      (SETF (PPA-STATE PENDING) ':DONE)
		      (PROCESS-WAKEUP (PPA-ATTACKER PENDING))
		      (APPLY FUNCTION ARGS))))))
    (LET ((PENDING (MAKE-PENDING-PROCESS-ABORT :VICTIM PROCESS
					       :ATTACKER %REAL-CURRENT-PROCESS
					       :ACTION 'PROCESS-INTERRUPT-WHEN-ABORTABLE
					       :STATE ':WAKEUP
					       :REASONS NIL
					       :FUNCTION #'MOLEST
					       :ARGUMENTS (LIST THROW-TAG BOTTOM-FRAME
								FUNCTION ARGS))))
      (WITH-SCHEDULER-LOCKED
	(PUSH PENDING SI:*PENDING-PROCESS-ABORTS*))
      (UNWIND-PROTECT
	  (LOOP WITH START = (ZL:TIME) DO		;Keep stabbing until the blood flows
	    (UNLESS (EQ (PPA-STATE PENDING) ':DONE)
	      (SETF (PPA-STATE PENDING) ':INTERRUPT)
	      (PROCESS-INTERRUPT PROCESS #'MOLEST PENDING THROW-TAG BOTTOM-FRAME FUNCTION ARGS)
	      ;; Wait for the interrupt function to get called in the other process.
	      ;; Time out after a few seconds, in case the process has gone inactive or
	      ;; something (a timing hazard) caused the interrupt function to be
	      ;; aborted before it stored into CELL.
	      (PROCESS-BLOCK-WITH-TIMEOUT (IF TIME-OUT (/ TIME-OUT 60s0) 15.)
					  "Initiate interrupt"
					  #'(LAMBDA (PENDING)
					      (NEQ (PPA-STATE PENDING) ':INTERRUPT))
					  PENDING))
	    (WHEN (EQ (PPA-STATE PENDING) ':DONE)
	      (RETURN T))				;Succeeded
	    (UNLESS (PROCESS-ACTIVE-P PROCESS)
	      (RETURN NIL))				;Process gone
	    (WHEN (TIME-ELAPSED-P TIME-OUT START)
	      (RETURN (PPA-REASONS PENDING)))		;Never became abortable
	    (SETF (PPA-STATE PENDING) ':WAIT)
	    (WITH-SCHEDULER-LOCKED
	      (WAKEUP-ON-CHANGE-OF-PROCESS-STATE PROCESS %REAL-CURRENT-PROCESS)
	      (PROCESS-BLOCK-WITH-TIMEOUT
		.3 "Await abortable"
		#'(LAMBDA (PROCESS PENDING)
		    (OR (EQ (PROCESS-STATE PROCESS) 'DEAD)
			(NEQ (PPA-STATE PENDING) ':WAIT)))
		PROCESS PENDING))
	    (UNLESS (PROCESS-ACTIVE-P PROCESS)
	      (RETURN NIL)))				;Process gone
	;; UNWIND-PROTECT cleanup handler
	(WITH-SCHEDULER-LOCKED
	  (SETQ SI:*PENDING-PROCESS-ABORTS* (DELETE PENDING SI:*PENDING-PROCESS-ABORTS*)))))))

;; this is (must) always be called inside a WITH-SCHEDULER-LOCKED
(DEFMETHOD (PROCESS-CONSIDER-RUNNABILITY PROCESS) ()
  (LET ((OLD-STATE STATE))
    (COND ((OR (NULL RUN-REASONS) (NOT (NULL ARREST-REASONS)))
	   (CASE STATE
	     ((RUNNABLE)
	      (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL-SELF 'ARRESTED NIL))
	     ((DEAD ARRESTED))
	     (OTHERWISE
	       (SETQ STATE 'ARRESTED))))
	  (T
	   (CASE STATE
	     ((DEAD ARRESTED)
	      (UNLESS SIMPLE-P
		(ENSURE-STACK-GROUP))
	      (PUSHNEW SELF *ALL-PROCESSES*)
	      (SETQ STATE 'UNARRESTED)
	      ;; If process's stack group is in a bad state,
	      ;; make it wait instead of actually running (unless it's current!).
	      (WHEN (AND %REAL-CURRENT-PROCESS	;Prevents lossage in PROCESS-INITIALIZE
			 (NOT (EQL %REAL-CURRENT-PROCESS SELF))
			 (ZL:TYPEP STACK-GROUP ':STACK-GROUP)
			 (NOT (SI:SG-RESUMABLE-P STACK-GROUP)))
		(PROCESS-FLUSH SELF))
	      (PROCESS-WAKEUP SELF)
	      (WHEN (EQ STATE 'WAITING)
		(START-POLLING-PROCESSES))))))	; in case this is the first waiter
    (WHEN (AND (NOT (EQ OLD-STATE STATE))
	       SI:*NEW-SCHEDULER-ENABLED*)
      (NOTE-PROCESS-STATE-CHANGE SELF OLD-STATE)
      (TV:WHO-LINE-PROCESS-CHANGE SELF))
    NIL))

(DEFMETHOD (PROCESS-ENABLE PROCESS) ()
  (WITH-SCHEDULER-LOCKED 
    (SETQ RUN-REASONS (LIST ':ENABLE))
    (SETQ ARREST-REASONS NIL)
    (PROCESS-CONSIDER-RUNNABILITY SELF)))

(DEFMETHOD (PROCESS-DISABLE PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (SETQ RUN-REASONS NIL)
    (SETQ ARREST-REASONS NIL)
    (PROCESS-CONSIDER-RUNNABILITY SELF)))

(DEFMETHOD (PRESET-BASIC PROCESS) (FUNCTION &REST ARGS)
  (SETQ INITIAL-FORM (CONS FUNCTION (COPY-LIST ARGS))))

(DEFMETHOD (PROCESS-PRESET PROCESS) (FUNCTION &REST ARGS)
  (SETQ INITIAL-FORM (CONS FUNCTION (COPY-LIST ARGS)))
  (PROCESS-RESET SELF))

(DEFMETHOD (PROCESS-PRESET SIMPLE-PROCESS) (FUNCTION &REST ARGS)
  (SETQ INITIAL-FORM (CONS FUNCTION (COPY-LIST ARGS)))
  (PROCESS-RESET SELF))

(DEFMETHOD (PRESET-SIMPLE-PROCESS SIMPLE-PROCESS)
	   (INITIAL-FUNCTION INITIAL-ARGS PREDICATE PREDICATE-ARGS)
  (WITH-SCHEDULER-LOCKED
    (APPLY #'SET-SIMPLE-PROCESS-PREDICATE-FUNCTION SELF PREDICATE PREDICATE-ARGS)
    (APPLY #'PROCESS-PRESET SELF INITIAL-FUNCTION INITIAL-ARGS)))

(DEFMETHOD (SET-SIMPLE-PROCESS-PREDICATE-FUNCTION SIMPLE-PROCESS) (PREDICATE &REST ARGS)
  (WITH-SCHEDULER-LOCKED
    (LET ((PREDICATE-FORM (STACK-LET ((NEW-FORM (CONS PREDICATE ARGS)))
			    (LET ((OLD-FORM INITIAL-STACK-GROUP))
			      (COND ((EQUAL NEW-FORM OLD-FORM)
				     OLD-FORM)
				    (( (LENGTH NEW-FORM) (LENGTH OLD-FORM))
				     (LOOP FOR CONS1 ON NEW-FORM
					   FOR CONS2 ON OLD-FORM
					   DO (SETF (CAR CONS2) (CAR CONS1))
					   FINALLY (SETF (CDR CONS2) NIL)
						   (RETURN OLD-FORM)))
				    (T
				     (COPY-LIST NEW-FORM
						(IF (LDB-TEST SYS:%%REGION-TEMPORARY
							      (SYS:AREA-REGION-BITS SI:DEFAULT-CONS-AREA))
						    SI:WORKING-STORAGE-AREA
						    SI:DEFAULT-CONS-AREA))))))))
      (SETQ INITIAL-STACK-GROUP PREDICATE-FORM)
      (SETQ WAIT-FUNCTION PREDICATE)
      (SETQ WAIT-ARGUMENT-LIST (CDR PREDICATE-FORM))
      (WAKEUP SELF)
      NIL)))

(DEFMETHOD (POLL-SIMPLE-PROCESS SIMPLE-PROCESS)
	   (&OPTIONAL (INTERVAL *PROCESS-WAIT-INTERVAL*) (FORCE NIL))
  (IF INTERVAL
      (WITH-SCHEDULER-LOCKED
	(SETQ POLLING-INTERVAL INTERVAL)
	;; if not in hibernation just set the interval, and on exit it will work.
	(UNLESS (AND STACK-GROUP (NOT FORCE))
	  ;; if scheduler isn't enabled yet, (a) don't go blocked on the lock, and (b)
	  ;; it's pointless to add yourself to the waiters queue, because it might yet to be
	  ;; initialized, in which case you'll just be pulled out of it.
	  (IF SI:*NEW-SCHEDULER-ENABLED*
	      (POLL-WAIT-FUNCTION-FOR-SIMPLE-PROCESS SELF INTERVAL
						     WAIT-FUNCTION WAIT-ARGUMENT-LIST)
	      ;; this might be a no-op, depending on just -how- uninitialized the world is
	      (WAKEUP-WITHOUT-TEST SELF))))
      (STOP-POLLING-WAIT-FUNCTION-FOR-SIMPLE-PROCESS SELF WAIT-RECORD))
  NIL)

(DEFMETHOD (STOP-POLL-OF-SIMPLE-PROCESS SIMPLE-PROCESS) ()
  (STOP-POLLING-WAIT-FUNCTION-FOR-SIMPLE-PROCESS SELF WAIT-RECORD))

(DEFMETHOD (PROCESS-RESET PROCESS) (&OPTIONAL UNWIND-OPTION KILL (WITHOUT-ABORTS ':ASK))
  "UNWIND-OPTION: T, never unwind; :UNLESS-CURRENT or NIL, unwinds the stack unless
the stack group is either in the current process or is the current stack group;
:ALWAYS, always unwinds the stack.  KILL is T to kill the process after optionally
unwinding it.  WITHOUT-ABORTS says what to do if the process is not currently
abortable: :ASK (the default) means consult the user, :FORCE means reset it anyway,
NIL means to return a list of the reasons why it cannot be aborted."
  (ECASE WITHOUT-ABORTS
    ((NIL :ASK :FORCE))
    ((T) (SETQ WITHOUT-ABORTS :FORCE)))
  (LOOP WITH START = (ZL:TIME)			;Keep stabbing until the blood flows
	WITH PAUSE = T				;PAUSE is T if we're timing out
	WITH REASONS DO				;REASONS is list of reasons why we can't
    (BLOCK WITH-SCHEDULER-LOCKED
      (WITH-SCHEDULER-LOCKED
	(WHEN (AND (EQ SELF %REAL-CURRENT-PROCESS) (NOT %%PROCESS-SWITCH-IN-PROGRESS)
		   SI:*NEW-SCHEDULER-ENABLED*)
	  ;; Make sure instance variable, maintained by scheduler, is up to date
	  (SETQ STACK-GROUP SYS:%CURRENT-STACK-GROUP))
	;; reset metering info.  This might be too large a hammer, since it can confuse
	;; the metering tool.
	(SETQ METERING-FLAGS 0)
	(RESET-SCHEDULER-INFO SELF)
	(WHEN (AND INITIAL-STACK-GROUP (NOT (ZEROP (SI:SG-ACTIVE-BIT INITIAL-STACK-GROUP))))
	  ;; Recover from confusion that happens when warm-booting out of
	  ;; a stack-group switch.
	  ;; The process ends up thinking that it owns Lisp Listener 1's stack-group.
	  (SETQ STACK-GROUP INITIAL-STACK-GROUP))
	;; Note -- the following code is not logically necessary.  However,
	;; it is here to make the cold-load come up when DBG:UNWIND-SG
	;; is not loaded yet.  We avoid unwinding the stack-group if it
	;; has just been created.
	(WHEN (OR (NULL STACK-GROUP) (SI:SG-NEVER-RUN STACK-GROUP))
	  (SETQ UNWIND-OPTION T))
	;; See if it's safe to reset the process now, if it's going to be unwound
	(UNLESS (OR (EQ UNWIND-OPTION T)
		    (AND (EQ SELF %REAL-CURRENT-PROCESS) (NOT (EQ UNWIND-OPTION ':ALWAYS))))
	  (SETQ REASONS (SI:THROW-INHIBIT-REASONS NIL STACK-GROUP))
	  (UNLESS (EQ STACK-GROUP INITIAL-STACK-GROUP)
	    (SETQ REASONS
		  (NCONC REASONS (SI:THROW-INHIBIT-REASONS NIL INITIAL-STACK-GROUP))))
	  (WHEN REASONS
	    (SETQ REASONS (MAPCAR #'COPY-LIST REASONS))	;Evacuate possible stack lists
	    (IF (EQ WITHOUT-ABORTS ':FORCE)
		(SI:NOTE-FORCIBLE-ABORT SELF REASONS)
		(RETURN-FROM WITH-SCHEDULER-LOCKED))))
	;; It's safe, go ahead
	(LET ((RESTART-FUN (IF (OR (NULL INITIAL-STACK-GROUP)
				   (EQ STACK-GROUP INITIAL-STACK-GROUP))
			       #'PROCESS-TOP-LEVEL
			       (LET ((PROC SELF))
				 #'(LAMBDA (&REST IGNORE)	;Unwind and switch SG's
				     (%PREAMBLE-ON-SWITCH-TO-PROCESS)
				     (DBG:UNWIND-SG
				       (PROCESS-INITIAL-STACK-GROUP %REAL-CURRENT-PROCESS)
				       #'PROCESS-TOP-LEVEL PROC NIL))))))
          ;; Give it a new lease on life:
	  (WHEN (EQ STATE 'DEAD)
	    (PUSHNEW SELF *ALL-PROCESSES*))
	  ;; If the process can't be restarted, kill it.
	  (WHEN (LDB-TEST %%PROCESS-DEBUG-NOT-RESTARTABLE DEBUG-FLAG)
	    (SETQ KILL T)
	    (SETF (LDB-TEST PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) T))
	  ;; Unwind any state
	  (IF (EQ SELF %REAL-CURRENT-PROCESS)
	      (COND ((EQ UNWIND-OPTION ':ALWAYS)
		     (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 1)
		     (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) KILL)
		     (SI:%UNWIND-TO-FRAME-AND-FUNCALL NIL RESTART-FUN SELF))
		    (KILL
		     (PROCESS-DISABLE %REAL-CURRENT-PROCESS)))
	      ;; Cause the process, when next scheduled, to unwind itself and
	      ;; call its initial function in the right stack group.
	      (COND ((EQ SYS:%CURRENT-STACK-GROUP STACK-GROUP)
		     ;; Not current process, but our stack group is the one running.
		     ;; Respect NOUNWIND
		     (COND ((EQ UNWIND-OPTION ':ALWAYS)
			    (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 1)
			    (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) KILL)
			    (SI:%UNWIND-TO-FRAME-AND-FUNCALL NIL RESTART-FUN SELF))
			   ((AND KILL %REAL-CURRENT-PROCESS)
			    (PROCESS-DISABLE %REAL-CURRENT-PROCESS))))
		    ((NEQ UNWIND-OPTION 'T)
		     (setf (ldb process-debug-reset-in-progress debug-flag) 1)
		     (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) KILL)
		     (DBG:UNWIND-SG STACK-GROUP RESTART-FUN SELF T)
		     (WHEN KILL
		       (SETQ ARREST-REASONS NIL)
		       (SETQ RUN-REASONS '(:KILL))
		       (PROCESS-CONSIDER-RUNNABILITY SELF)))
		    (T
		     (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 0)
		     (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) NIL)
		     ; when we unwind the stack, it automatically cleans up promotions, but
		     ; here we have to explicitly fix it up.
		     (RESET-PRIORITY-INTERNAL SELF)
		     ; ditto for current-lock
		     (SETQ CURRENT-LOCK NIL)
		     (WHEN (AND INITIAL-STACK-GROUP-DESCRIPTOR STACK-GROUP)
		       (PUSH STACK-GROUP *STACK-GROUPS-NOT-UNWOUND*))
		     (COND (KILL
			    (PROCESS-DISABLE SELF)
			    (SETQ STATE 'DEAD)
			    (COND (INITIAL-STACK-GROUP-DESCRIPTOR
				   (SETQ STACK-GROUP NIL)
				   (SETQ INITIAL-STACK-GROUP NIL)
				   (SETQ INITIAL-STACK-GROUP-DESCRIPTOR NIL))
				  (T
				   (SETQ STACK-GROUP INITIAL-STACK-GROUP)))
			    (WHEN (LDB-TEST PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG)
			      (SETQ *ALL-PROCESSES* (DELETE SELF *ALL-PROCESSES*))))
			   (T
			    (COND (INITIAL-STACK-GROUP-DESCRIPTOR
				   (MULTIPLE-VALUE-SETQ (INITIAL-STACK-GROUP INITIAL-STACK-GROUP-DESCRIPTOR)
				     (ALLOCATE-RESOURCE 'STACK-GROUP-FOR-PROCESS))
				   (SETQ STACK-GROUP INITIAL-STACK-GROUP)
				   (SETF (SYS:SG-NAME STACK-GROUP) SELF))
				  (INITIAL-STACK-GROUP
				   (SETQ STACK-GROUP INITIAL-STACK-GROUP)
				   (SYS:STACK-GROUP-PRESET STACK-GROUP #'PROCESS-TOP-LEVEL))))))))
	  ;; Wake up
	  (PROCESS-FORCE-WAKEUP SELF)
	  ;; We're done.
	  (RETURN-FROM PROCESS-RESET NIL))))
    ;; The process could not be reset at this time
    ;; This does not use *PENDING-PROCESS-ABORTS* because there isn't the problem of the
    ;; user pounding on the c-Abort key here, and it isn't clear that doing one :RESET
    ;; should have an effect on another :RESET.
    (COND ((NEQ WITHOUT-ABORTS :ASK)
	   (RETURN-FROM PROCESS-RESET REASONS))
	  ((AND (NOT (EQ SELF %REAL-CURRENT-PROCESS))
		(NOT (AND PAUSE (TIME-ELAPSED-P SI:*DEFAULT-PROCESS-ABORT-TIMEOUT* START)))
		;; is it worth waiting?
		(PROCESS-WAKEABLE-P-SELF))
	   ;; Try waiting for a brief while
	   (WITH-SCHEDULER-LOCKED
	     (WAKEUP-ON-CHANGE-OF-PROCESS-STATE SELF %REAL-CURRENT-PROCESS)
	     (PROCESS-BLOCK-WITH-TIMEOUT
	       .4 "Await abortable"
	       #'(LAMBDA (PROCESS) (AND (NOT (PROCESS-RUNNABLE-P PROCESS))
					(NOT (PROCESS-WAKEABLE-P PROCESS))))
	       SELF)))
	  (T
	   ;; Consult with user
	   (CASE (PROCESS-ABORT-QUERY NAME (IF KILL "kill" "abort") REASONS T 2
					  (AND (NEQ SELF %REAL-CURRENT-PROCESS)
					       si:*DEFAULT-PROCESS-ABORT-TIMEOUT*)
					  T NIL NIL NIL)
	     (WAIT (SETQ START (ZL:TIME) PAUSE T))
	     (WAIT-INDEFINITELY (SETQ PAUSE NIL))
	     (DEBUG (PROCESS-ASYNCHRONOUS-BREAK SELF)
		    (RETURN-FROM PROCESS-RESET NIL))
	     (ABORT (SI:NOTE-FORCIBLE-ABORT SELF REASONS)
		    (SETQ WITHOUT-ABORTS ':FORCE))
	     (SKIP (FORMAT T "~&The attempt to ~:[abort~;kill~] ~A has been abandoned.~%"
			   KILL NAME)
		   (RETURN-FROM PROCESS-RESET REASONS)))))))

(DEFMETHOD (PROCESS-RESET SIMPLE-PROCESS)
	   (&OPTIONAL UNWIND-OPTION KILL (WITHOUT-ABORTS ':ASK))
  (LOOP WITH START = (ZL:TIME)			;Keep stabbing until the blood flows
	WITH PAUSE = T				;PAUSE is T if we're timing out
	WITH REASONS DO				;REASONS is list of reasons why we can't
    (BLOCK WITH-SCHEDULER-LOCKED
      (WITH-SCHEDULER-LOCKED
	(IF STACK-GROUP
	    (PROGN
	      (WHEN (AND (EQ SELF %REAL-CURRENT-PROCESS) (NOT %%PROCESS-SWITCH-IN-PROGRESS)
			 SI:*NEW-SCHEDULER-ENABLED*)
		;; Make sure instance variable, maintained by scheduler, is up to date
		(SETQ STACK-GROUP SYS:%CURRENT-STACK-GROUP))
	      ;; reset metering info.  This might be too large a hammer, since it can confuse
	      ;; the metering tool.
	      (SETQ METERING-FLAGS 0)
	      (RESET-SCHEDULER-INFO SELF)
	      ;; Note -- the following code is not logically necessary.  However,
	      ;; it is here to make the cold-load come up when DBG:UNWIND-SG
	      ;; is not loaded yet.  We avoid unwinding the stack-group if it
	      ;; has just been created.
	      (WHEN (SI:SG-NEVER-RUN STACK-GROUP)
		(SETQ UNWIND-OPTION T))
	      ;; See if it's safe to reset the process now, if it's going to be unwound
	      (UNLESS (OR (EQ UNWIND-OPTION T)
			  (AND (EQ SELF %REAL-CURRENT-PROCESS) (NOT (EQ UNWIND-OPTION ':ALWAYS))))
		(SETQ REASONS (SI:THROW-INHIBIT-REASONS NIL STACK-GROUP))
		(WHEN REASONS
		  (SETQ REASONS (MAPCAR #'COPY-LIST REASONS))	;Evacuate possible stack lists
		  (IF (EQ WITHOUT-ABORTS ':FORCE)
		      (SI:NOTE-FORCIBLE-ABORT SELF REASONS)
		      (RETURN-FROM WITH-SCHEDULER-LOCKED))))
	      ;; It's safe, go ahead
	      ;; Give it a new lease on life:
	      (WHEN (EQ STATE 'DEAD)
		(PUSHNEW SELF *ALL-PROCESSES*))
	      ;; Set up
	      (IF (EQ SELF %REAL-CURRENT-PROCESS)
		  (COND ((EQ UNWIND-OPTION ':ALWAYS)
			 (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 1)
			 (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) KILL)
			 (SI:%UNWIND-TO-FRAME-AND-FUNCALL NIL #'SIMPLE-PROCESS-TOP-LEVEL))
			(KILL
			 (PROCESS-DISABLE %REAL-CURRENT-PROCESS)))
		  ;; Cause the process, when next scheduled, to unwind itself and
		  ;; call its initial function in the right stack group.
		  (COND ((EQ SYS:%CURRENT-STACK-GROUP STACK-GROUP)
			 ;; Not current process, but our stack group is the one running.
			 ;; Respect NOUNWIND
			 (COND ((EQ UNWIND-OPTION ':ALWAYS)
				(SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 1)
				(SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) KILL)
				(SI:%UNWIND-TO-FRAME-AND-FUNCALL NIL #'SIMPLE-PROCESS-TOP-LEVEL))
			       ((AND KILL %REAL-CURRENT-PROCESS)
				(PROCESS-DISABLE %REAL-CURRENT-PROCESS))))
			((NEQ UNWIND-OPTION 'T)
			 (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 1)
			 (SETF (LDB-TEST %%PROCESS-DEBUG-RELEASE-RESOURCES DEBUG-FLAG) KILL)
			 (DBG:UNWIND-SG STACK-GROUP #'SIMPLE-PROCESS-TOP-LEVEL SELF T)
			 (WHEN KILL
			   (SETQ ARREST-REASONS NIL)
			   (SETQ RUN-REASONS '(:KILL))
			   (PROCESS-CONSIDER-RUNNABILITY SELF))
			 ;; Wake up
			 (PROCESS-FORCE-WAKEUP SELF)
			 ;; need to set wakeup-waiting-switch to force it to re-evaluate
			 ;; top level verify-function
			 (SETQ WAKEUP-WAITING-SWITCH T))
			(T
			 (PUSH STACK-GROUP *STACK-GROUPS-NOT-UNWOUND*)
			 (PROCESS-FLUSH SELF)
			 (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 0)
			 ; when we unwind the stack, it automatically cleans up promotions, but
			 ; here we have to explicitly fix it up.
			 (RESET-PRIORITY-INTERNAL SELF)
			 ; ditto for current-lock
			 (SETQ CURRENT-LOCK NIL)
			 (WHEN POLLING-INTERVAL
			   (POLL-SIMPLE-PROCESS SELF POLLING-INTERVAL))
			 (SIMPLE-PROCESS-DIED SELF KILL))))
	      ;; We're done.
	      (RETURN-FROM PROCESS-RESET NIL))
	    (PROGN
	      ;; reset metering info.  This might be too large a hammer, since it can confuse
	      ;; the metering tool.
	      (SETQ METERING-FLAGS 0)
	      (RESET-SCHEDULER-INFO SELF)
	      (WHEN POLLING-INTERVAL
		(POLL-SIMPLE-PROCESS SELF POLLING-INTERVAL))
	      ;; Set up
	      (COND (KILL
		     (WHEN (ZEROP (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG))
		       (SETQ RUN-REASONS NIL)
		       (SETQ ARREST-REASONS NIL)
		       (%FORCE-PROCESS-NOT-RUNNABLE-INTERNAL-SELF 'DEAD NIL)
		       (SETQ WAIT-FUNCTION #'FALSE)
		       (SETQ WAIT-ARGUMENT-LIST NIL)
		       (UNLESS (ZEROP (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET
					   DEBUG-FLAG))
			 (SETQ *ALL-PROCESSES* (DELETE SELF *ALL-PROCESSES*))
			 (STOP-POLL-OF-SIMPLE-PROCESS SELF)
			 (SETF (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) 0))))
		    (T
		     ;; Give it a new lease on life:
		     (WHEN (EQ STATE 'DEAD)
		       (PUSHNEW SELF *ALL-PROCESSES*)
		       (SETQ STATE (IF (OR (NULL RUN-REASONS) (NOT (NULL ARREST-REASONS)))
				       'ARRESTED
				       'BLOCKED)))
		     ;; Wake up
		     (SETQ WAIT-FUNCTION (CAR INITIAL-STACK-GROUP))
		     (SETQ WAIT-ARGUMENT-LIST (CDR INITIAL-STACK-GROUP))
		     (PROCESS-WAKEUP SELF)))
	      ;; all pending resets are finished.
	      (SETF (LDB PROCESS-DEBUG-RESET-IN-PROGRESS DEBUG-FLAG) 0)
	      ;; We're done.
	      (RETURN-FROM PROCESS-RESET NIL)))))
    ;; The process could not be reset at this time
    ;; This does not use *PENDING-PROCESS-ABORTS* because there isn't the problem of the
    ;; user pounding on the c-Abort key here, and it isn't clear that doing one :RESET
    ;; should have an effect on another :RESET.
    (COND ((NEQ WITHOUT-ABORTS :ASK)
	   (RETURN-FROM PROCESS-RESET REASONS))
	  ((AND (NOT (EQ SELF %REAL-CURRENT-PROCESS))
		(NOT (AND PAUSE (TIME-ELAPSED-P SI:*DEFAULT-PROCESS-ABORT-TIMEOUT* START)))
		;; is it worth waiting?
		(PROCESS-WAKEABLE-P-SELF))
	   ;; Try waiting for a brief while
	   (WITH-SCHEDULER-LOCKED
	     (WAKEUP-ON-CHANGE-OF-PROCESS-STATE SELF %REAL-CURRENT-PROCESS)
	     (PROCESS-BLOCK-WITH-TIMEOUT
	       .4 "Await abortable"
	       #'(LAMBDA (PROCESS) (AND (NOT (PROCESS-RUNNABLE-P PROCESS))
					(NOT (PROCESS-WAKEABLE-P PROCESS))))
	       SELF)))
	  (T
	   ;; Consult with user
	   (CASE (PROCESS-ABORT-QUERY NAME (IF KILL "kill" "abort") REASONS T 2
					  (AND (NEQ SELF %REAL-CURRENT-PROCESS)
					       SI:*DEFAULT-PROCESS-ABORT-TIMEOUT*)
					  T NIL NIL NIL)
	     (WAIT (SETQ START (ZL:TIME) PAUSE T))
	     (WAIT-INDEFINITELY (SETQ PAUSE NIL))
	     (DEBUG (PROCESS-ASYNCHRONOUS-BREAK SELF)
		    (RETURN-FROM PROCESS-RESET NIL))
	     (ABORT (SI:NOTE-FORCIBLE-ABORT SELF REASONS)
		    (SETQ WITHOUT-ABORTS ':FORCE))
	     (SKIP (FORMAT T "~&The attempt to ~:[abort~;kill~] ~A has been abandoned.~%"
			   KILL NAME)
		   (RETURN-FROM PROCESS-RESET REASONS)))))))

(DEFMETHOD (RESET-PRIORITY-INTERNAL PROCESS) ()
  (SETF (FILL-POINTER PROCESS-PRIORITY) 1)
  (LET ((UIDS NIL))
    (DOTIMES (I (FILL-POINTER PROMOTING-SET))
      (PUSHNEW (PROMOTION-RECORD-MY-UID (AREF PROMOTING-SET I)) UIDS))
    (LOOP FOR UID IN UIDS DO (REMOVE-PROMOTIONS SELF UID))
    (SETQ UIDS NIL)
    (DOTIMES (I (FILL-POINTER PROMOTION-SET))
      (PUSHNEW (PROMOTION-RECORD-MY-UID (AREF PROMOTION-SET I)) UIDS))
    (LOOP FOR UID IN UIDS DO (FINISH-PROMOTIONS SELF UID)))
  (WITH-SCHEDULER-LOCKED
    (SET-PRIORITY-INTERNAL SELF (GET-INSTANTANEOUS-PRIORITY SELF (AREF PROCESS-PRIORITY 0))))
  NIL)

(ADD-INITIALIZATION "Reset *PROCESSES-FORCIBLY-ABORTED*"
		    '(SETQ SI:*PROCESSES-FORCIBLY-ABORTED* NIL)
		    '(:BEFORE-COLD))

(ADD-INITIALIZATION "Reset SI:*PROCESSES-FORCIBLY-RESET-AT-WARM-BOOT*"
		    '(SETQ SI:*PROCESSES-FORCIBLY-RESET-AT-WARM-BOOT* NIL)
		    '(:BEFORE-COLD))

;Convert into strings now, in case some object (perhaps from a resource)
;changes its printed representation or becomes unprintable later.
(DEFUN SI:NOTE-FORCIBLE-ABORT (PROCESS REASONS)
  (IF SI:*NEW-SCHEDULER-ENABLED*
      (PUSH (CONS (PROCESS-NAME PROCESS)
		  (LOOP FOR REASON IN REASONS
			COLLECT
			  (WITH-OUTPUT-TO-STRING (*STANDARD-OUTPUT*)
			    (DBG:PRINT-CAREFULLY "forced abort reason"
			      (APPLY #'FORMAT T REASON)))))
	    SI:*PROCESSES-FORCIBLY-ABORTED*)
    (PUSH (CONS (PROCESS-NAME PROCESS)
		(LOOP FOR REASON IN REASONS
		      COLLECT
			(WITH-OUTPUT-TO-STRING (*STANDARD-OUTPUT*)
			  (DBG:PRINT-CAREFULLY "forced abort reason"
			    (APPLY #'FORMAT T REASON)))))
	  SI:*PROCESSES-FORCIBLY-RESET-AT-WARM-BOOT*)))


;;;; Process abort mechanism

;;; List of elements (victim attacker wakeup-flag)
(SYS:DEFVAR-RESETTABLE *PENDING-PROCESS-ABORTS* NIL)

(DEFUN PROCESS-ASYNCHRONOUS-BREAK (PROCESS)
  (PROCESS-INTERRUPT PROCESS
		     #'DBG:ENTER-DEBUGGER (DBG:MAKE-CONDITION 'DBG:ASYNCHRONOUS-BREAK)))

;;; Returns T on success, NIL on failure
;;; ALL is T to abort all the way, NIL to abort to innermost command level
;;; MESSAGE is printed on the process's TERMINAL-IO if not NIL
;;; STREAM overrides the destination for MESSAGE
;;; TIME-OUT is how long to wait in 60ths of a second
;;; QUERY is NIL to give up after that long, T to query the user what to do,
;;;  :POP-UP to query the user through a pop-up window,
;;;  or :COLD to query the user via the cold-load stream
;;;--- This is rife with timing hazards that are difficult to fix.
;;;--- One is that the process can terminate and be reused without our
;;;--- noticing, and then we can abort the wrong process.
(DEFUN PROCESS-ABORT (PROCESS &KEY MESSAGE ALL (QUERY T)
		      (TIME-OUT SI:*DEFAULT-PROCESS-ABORT-TIMEOUT*) STREAM)
  (LABELS ((ABORT (ALL MESSAGE STREAM)		;Subroutine to actually do the work
	     (WHEN MESSAGE
	       (TV:KBD-UNIMPORTANT-MESSAGE MESSAGE (OR STREAM *TERMINAL-IO*)))
	     (IF ALL (PROCESS-RESET %REAL-CURRENT-PROCESS ':ALWAYS) (SIGNAL 'SI:ABORT))
	     (SEND (OR STREAM *TERMINAL-IO*) :STRING-OUT "
[Sorry, no ABORT handlers found in this process.]
"))
	   (MOLEST (PENDING ALL MESSAGE STREAM PROCESS)	;Process interrupt function
	     (LET ((REASONS (SI:THROW-INHIBIT-REASONS
			      (AND (NOT ALL)
				   (DBG:CONDITION-THROW-TAG 'ABORT))))
		   (STATE (PPA-STATE PENDING)))
	       (COND (REASONS			;Cannot abort yet
		      (SETF (PPA-REASONS PENDING) (MAPCAR #'COPY-LIST REASONS))
		      (WHEN (EQ STATE ':INTERRUPT)
			(SETF (PPA-STATE PENDING) ':WAIT)
			(PROCESS-WAKEUP (PPA-ATTACKER PENDING))))
		     ((AND (EQL PROCESS %REAL-CURRENT-PROCESS)
			   (NOT (MEMBER STATE '(:DONE :QUERY))))
		      (SETF (PPA-STATE PENDING) ':DONE)
		      (PROCESS-WAKEUP (PPA-ATTACKER PENDING))
		      (ABORT ALL MESSAGE STREAM))))))
    ;; PENDING is for inter-process communication.  It's heap rather than stack
    ;; allocated to avoid clobbering somebody else's stack if this process gives up
    ;; before the other process stores into PPA-STATE or PPA-REASONS.
    (LET ((PENDING (MAKE-PENDING-PROCESS-ABORT :VICTIM PROCESS
					       :ATTACKER %REAL-CURRENT-PROCESS
					       :ACTION 'PROCESS-ABORT
					       :STATE ':WAKEUP
					       :REASONS NIL
					       :FUNCTION #'MOLEST
					       :ARGUMENTS (LIST ALL MESSAGE STREAM PROCESS)))
	  (HAVE-SHEET-LOCK NIL)
	  (PAUSE T)
	  TEM)
      (COND ((EQ PROCESS %REAL-CURRENT-PROCESS)	;No point in waiting in this case
	     (SETQ TIME-OUT 0))
	    ((SETQ TEM (LOOP FOR ELEM IN SI:*PENDING-PROCESS-ABORTS* DO
			 (WHEN (AND (EQ (PPA-VICTIM ELEM) PROCESS)
				    (EQ (PPA-ACTION ELEM) 'PROCESS-ABORT)
				    (NEQ (PPA-STATE ELEM) ':DONE))
			   (RETURN ELEM))))
	     (COND ((NULL QUERY))		;If not supposed to interact, don't
		   ((MEMBER (PPA-STATE TEM)	;Force the existing attacker to query now
			    '(:WAIT :INTERRUPT :SHEET-LOCK))
		    (SETF (PPA-STATE TEM) ':WAKEUP)
		    (PROCESS-WAKEUP (PPA-ATTACKER TEM)))
		   (T (BEEP)))			;Indicate someone else is doing it already
	     (RETURN-FROM PROCESS-ABORT NIL))	;Only one attacker at a time, please
	    (T
	     (WITH-SCHEDULER-LOCKED
	       (PUSH PENDING SI:*PENDING-PROCESS-ABORTS*))))
      (UNWIND-PROTECT
	  (LOOP AS START = (ZL:TIME) DO			;Keep stabbing until the blood flows
	    (LOOP DO (UNLESS (EQ (PPA-STATE PENDING) ':DONE)
		       (SETF (PPA-STATE PENDING) ':INTERRUPT)
		       (PROCESS-INTERRUPT PROCESS		;Try to abort it
					  #'MOLEST PENDING ALL MESSAGE STREAM PROCESS)
		       ;; Wait for the interrupt function to get called in the other process.
		       ;; Time out after a few seconds, in case the process has gone inactive
		       ;; or something (a timing hazard) caused the interrupt function to be
		       ;; aborted before it stored into CELL.
		       (PROCESS-BLOCK-WITH-TIMEOUT (IF TIME-OUT (/ TIME-OUT 60s0) 15.)
						  "Initiate abort"
						  #'(LAMBDA (PENDING)
						      (NEQ (PPA-STATE PENDING) ':INTERRUPT))
						  PENDING))
		     (WHEN (EQ (PPA-STATE PENDING) ':DONE)
		       (RETURN-FROM PROCESS-ABORT T))	;Succeeded
		     (UNLESS (PROCESS-ACTIVE-P PROCESS)
		       (RETURN-FROM PROCESS-ABORT NIL))	;Process gone
		  UNTIL (OR (AND PAUSE (TIME-ELAPSED-P TIME-OUT START))
			    (AND QUERY (EQ (PPA-STATE PENDING) ':WAKEUP))
			    (EQ (PROCESS-STATE PROCESS) 'DEAD))
		  DO (SETF (PPA-STATE PENDING) ':WAIT)
		     (WITH-SCHEDULER-LOCKED
		       (WAKEUP-ON-CHANGE-OF-PROCESS-STATE PROCESS %REAL-CURRENT-PROCESS)
		       (PROCESS-BLOCK-WITH-TIMEOUT
			 .3 "Await abortable"
			 #'(LAMBDA (PROCESS PENDING)
			     (OR (EQ (PROCESS-STATE PROCESS) 'DEAD)
				 (NEQ (PPA-STATE PENDING) ':WAIT)))
			 PROCESS PENDING))
		  UNTIL (OR (EQ (PROCESS-STATE PROCESS) 'DEAD)
			    (AND QUERY (EQ (PPA-STATE PENDING) ':WAKEUP))))
	    ;; Timed out, consult with user, possibly on the cold-load stream
	    (UNLESS QUERY
	      (RETURN-FROM PROCESS-ABORT NIL))
	    ;; If we're going to do a pop up query check that the default screen
	    ;; exists and is exposed.
	    (WHEN (AND (EQ QUERY ':POP-UP)
		       (OR (NULL TV:DEFAULT-SCREEN)
			   (NOT (TV:SHEET-EXPOSED-P TV:DEFAULT-SCREEN))))
	      (SETQ QUERY ':COLD))
	    (WHEN (EQ QUERY ':POP-UP)
	      ;; Wait until we can get the sheet lock, but don't wait too too long
	      (SETF (PPA-STATE PENDING) ':SHEET-LOCK)
	      (PROCESS-WAIT-WITH-TIMEOUT
		"Sheet Lock" 10.
		#'(LAMBDA (PENDING SCREEN PROCESS)
		    (OR (NEQ (PPA-STATE PENDING) ':SHEET-LOCK)
			(TV:SHEET-CAN-GET-LOCK SCREEN PROCESS)))
		PENDING TV:DEFAULT-SCREEN %REAL-CURRENT-PROCESS)
	      ;; Check if we've succeeded in aborting the process while
	      ;; waiting for the sheet lock.
	      (WHEN (EQ (PPA-STATE PENDING) ':DONE)
		(RETURN-FROM PROCESS-ABORT T))
	      ;; Try to grab the sheet lock.  If we still can't get it, use
	      ;; the cold load stream.
	      (WITHOUT-INTERRUPTS 
		(COND ((TV:SHEET-CAN-GET-LOCK TV:DEFAULT-SCREEN %REAL-CURRENT-PROCESS)
		       (SETQ HAVE-SHEET-LOCK T)
		       (TV:SHEET-GET-LOCK-INTERNAL TV:DEFAULT-SCREEN %REAL-CURRENT-PROCESS))
		      (T
		       (SETQ QUERY ':COLD)))))
	    ;; Change my pending process abort state to :QUERY, but quit if
	    ;; the state was :DONE.
	    (WHEN (EQ (SHIFTF (PPA-STATE PENDING) ':QUERY) ':DONE)
	      (RETURN-FROM PROCESS-ABORT T))
	    (CASE (CASE QUERY
		    (:POP-UP
		      (USING-RESOURCE (*TERMINAL-IO* TV:POP-UP-TEXT-WINDOW TV:DEFAULT-SCREEN)
			(SEND *TERMINAL-IO* :SET-LABEL
			      "Process-Abort Query (press  for help)")
			;; The position and size are the same as for the Converse
			;; and Notification pop-up windows.  Keep them the same so
			;; that it looks familiar to the user.  This window actually
			;; has to be a little taller so the whole Help message will fit.
			(MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
			    (SEND TV:DEFAULT-SCREEN :INSIDE-EDGES)
			  (SEND *TERMINAL-IO* :SET-POSITION LEFT TOP)
			  (SEND *TERMINAL-IO* :SET-SIZE (- RIGHT LEFT) (+ #o400 50))
			  (IGNORE BOTTOM))
			(SEND *TERMINAL-IO* :CLEAR-INPUT)
			(TV:WINDOW-CALL (*TERMINAL-IO* :DEACTIVATE)
			  (WITHOUT-INTERRUPTS
			    (TV:SHEET-RELEASE-LOCK TV:DEFAULT-SCREEN %REAL-CURRENT-PROCESS)
			    (SETQ HAVE-SHEET-LOCK NIL))
			  (LET ((*QUERY-IO* SI:SYN-TERMINAL-IO))
			    (PROCESS-ABORT-QUERY
			      PROCESS "abort" (PPA-REASONS PENDING) T 2 TIME-OUT T NIL T
			      ':SELECTED)))))
		    (:COLD
		      (LET ((*TERMINAL-IO* *TERMINAL-IO*)	;Protect against SETQ below
			    (*QUERY-IO* SI:SYN-TERMINAL-IO)
			    (SYS:INHIBIT-SCHEDULING-FLAG SYS:INHIBIT-SCHEDULING-FLAG))
			(WITH-SCHEDULER-LOCKED
			  (UNWIND-PROTECT
			      (PROGN
				(DBG:USE-COLD-LOAD-STREAM "Process cannot be aborted")
				(PROCESS-ABORT-QUERY
				  PROCESS "abort" (PPA-REASONS PENDING) T 2 TIME-OUT T NIL T
				  NIL))
			    (DBG:RECOVER-FROM-COLD-LOAD-STREAM)))))
		    (OTHERWISE
		      (PROCESS-ABORT-QUERY
			PROCESS "abort" (PPA-REASONS PENDING) T 2 TIME-OUT T NIL T
			NIL)))
	      (DEBUG
		(PROCESS-ASYNCHRONOUS-BREAK PROCESS)
		(RETURN-FROM PROCESS-ABORT NIL))
	      (ABORT
		(SI:NOTE-FORCIBLE-ABORT PROCESS (PPA-REASONS PENDING))
		(PROCESS-INTERRUPT PROCESS #'ABORT ALL MESSAGE STREAM)
		(RETURN-FROM PROCESS-ABORT T))
	      ((SKIP :STATUS)
		(UNLESS (OR (EQ QUERY ':COLD)	;Don't display then immediately erase
			    (EQ QUERY ':POP-UP))	;Window is gone already
		  (FORMAT T "~&The attempt to abort ~A has been abandoned.~%"
			  PROCESS))
		(RETURN-FROM PROCESS-ABORT NIL))
	      (WAIT-INDEFINITELY
		(SETQ PAUSE NIL))
	      (WAIT
		(SETQ PAUSE T))))
	;; UNWIND-PROTECT cleanup form for the whole function
	(WITH-SCHEDULER-LOCKED
	  (SETQ SI:*PENDING-PROCESS-ABORTS* (DELETE PENDING SI:*PENDING-PROCESS-ABORTS*)))
	(WHEN HAVE-SHEET-LOCK
	  (TV:SHEET-RELEASE-LOCK TV:DEFAULT-SCREEN %REAL-CURRENT-PROCESS))))))

;;; REASONS came from the function THROW-INHIBIT-REASONS
;;; The innermost reason is first on the list
;;; Result is one of the symbols SKIP, WAIT, WAIT-INDEFINITELY, ABORT, or DEBUG
(DEFUN PROCESS-ABORT-QUERY (PROCESS VERB REASONS SUPPRESS-UNWIND-PROTECT
			    INDENTATION TIME-OUT DEBUG TRAVESTY WAKEABLE
			    STATUS
			    &AUX (HELPED NIL))
  ;; First print the reasons why the process cannot be aborted
  ;; I tried including this in the FQUERY prompt so it would be repeated after
  ;; the help message, but that didn't look very good.
  (WHEN (EQ PROCESS %REAL-CURRENT-PROCESS) (SETQ PROCESS NIL))
  (FORMAT T "~&~:[The program~;Process ~:*~A~] cannot safely be ~Aed at this time."
	  PROCESS VERB)
  (SEND *QUERY-IO* :CLEAR-INPUT)
  (SYS:WITH-INDENTATION (*STANDARD-OUTPUT* INDENTATION)
    (LET ((SPECIFIC NIL)
	  (FIRST T))
      (DOLIST (REASON REASONS)
	(BLOCK SUPPRESS
	  (IF (EQ (FIRST REASON) SI:*UNWIND-PROTECT-THROW-INHIBIT-REASON*)
	      (WHEN SPECIFIC (RETURN-FROM SUPPRESS))	;already gave a more specific message
	      (SETQ SPECIFIC SUPPRESS-UNWIND-PROTECT))
	  (FRESH-LINE)				;Really fresh-line
	  (UNLESS FIRST
	    (FRESH-LINE))			;Blank line separates multiple reasons
	  (SETQ FIRST NIL)
	  (APPLY #'FORMAT *STANDARD-OUTPUT* REASON)))))
  ;; Now query the user, with very carefully crafted help
  ;; The order of these choices has been carefully chosen based on user interface concepts
  ;; The most common choice is first, the least likely choice for most users is last
  (STACK-LET* ((READLINE-CHOICES
		 `(,@(AND (NOT TRAVESTY) `((SKIP "Skip")))
		   ,@(AND TIME-OUT (PLUSP TIME-OUT)
			  `((WAIT "Wait")
			    (WAIT-INDEFINITELY "Indefinitely wait")))
		   (ABORT ,(STRING-CAPITALIZE VERB))
		   ,@(AND DEBUG `((DEBUG "Debug")))))
	       (TYI-CHOICES
		 `(,@(AND (NOT TRAVESTY) `(((SKIP "Skip") #\S)))
		   ,@(AND TIME-OUT (PLUSP TIME-OUT)
			  `(((WAIT "Wait") #\W)
			    ((WAIT-INDEFINITELY "Indefinitely wait") #\I)))
		   ((ABORT ,(STRING-CAPITALIZE VERB)) ,(AREF (STRING-CAPITALIZE VERB) 0))
		   ,@(AND DEBUG `(((DEBUG "Debug") #\D)))))
	       (CHOICES (IF STATUS TYI-CHOICES READLINE-CHOICES))
	       (OPTIONS `(:TYPE ,(IF STATUS ':TYI ':READLINE)
			  :CHOICES ,CHOICES
			  :LIST-CHOICES NIL
			  :NO-INPUT-SAVE T
			  :STATUS ,STATUS
			  :HELP-FUNCTION
    ,(LAMBDA (STREAM)
       (FORMAT STREAM "~&The current program operation is one that the programmer expected~@
			 to run to completion.  Aborting this operation partway through~@
			 could leave the program in an inconsistent state and interfere~@
			 with its proper operation.~%~A~2%"
	       (IF TRAVESTY "Your only choice is:" "Your choices are:"))
       (LET ((NOUN (IF PROCESS "process" "program")))
	 ;; Descriptions are capitalized even though they are not complete sentences,
	 ;; because this is a table, not running text, and it looks better that way.
	 (UNLESS TRAVESTY
	   (FORMAT STREAM "~8@TSkip   Abandons this attempt to ~A the ~A.~%" VERB NOUN))
	 (WHEN (AND TIME-OUT (PLUSP TIME-OUT))
	   (FORMAT STREAM
	     "~8@TWait   Waits until the ~A reaches a point where it can safely be ~Aed.~@
		    ~15@TOffers these choices again if ~D seconds elapse and it still ~
							cannot be ~Aed.~@
	      ~8@TIndefinitely wait   Keeps waiting for as long as it takes."
	     NOUN VERB (ROUND TIME-OUT 60.) VERB)
	   (WHEN WAKEABLE
	     (FORMAT STREAM "  Another attempt~@
		    ~15@Tto ~A stops waiting and offers these choices again."
		     VERB))
	   (FRESH-LINE STREAM))
	 (FORMAT STREAM "~8@T~5:  ~:*~:s the ~A by force, accepting the risk of damage.~%"
		 VERB NOUN)
	 (WHEN DEBUG
	   (FORMAT STREAM "~8@TDebug  Enters the Debugger for detailed investigation.~%"))
	 (FRESH-LINE STREAM))		;looks better with blank lines around table
       (SETQ HELPED T)))))
    (FQUERY OPTIONS
	    (IF TRAVESTY
		"Your only choice is to ~Q and accept the risk of damaging the program,~@
		 because the program's designer did not anticipate this error~Q: "
		"Do you want to ~Q?~Q ")
	    (LAMBDA ()
	      (DECLARE (SYS:DOWNWARD-FUNCTION))
	      (FORMAT-TEXTUAL-LIST
		CHOICES
		#'(LAMBDA (CHOICE STREAM)
		    (PRINC (IF STATUS (SECOND (FIRST CHOICE)) (SECOND CHOICE)) STREAM))
		:CONJUNCTION "or")
	      (WHEN STATUS
		(PRINC " (")
		(FORMAT-TEXTUAL-LIST
		  CHOICES
		  #'(LAMBDA (CHOICE STREAM)
		      (PRINC (SECOND CHOICE) STREAM))
		  :CONJUNCTION "or")
		(PRINC ")")))
	    (LAMBDA ()
	      (DECLARE (SYS:DOWNWARD-FUNCTION))
	      (UNLESS HELPED
		(PRINC " (press  for help)"))))))

;; Called when exiting SYS:WITHOUT-ABORTS if SI:*PENDING-PROCESS-ABORTS* is non-null
(DEFUN CHECK-PENDING-PROCESS-ABORTS ()
  (SYS:WITH-ABORTS-ENABLED (UNWIND-PROTECT)
    (CHECK-PENDING-PROCESS-ABORTS-1)))

(DEFUN CHECK-PENDING-PROCESS-ABORTS-1 ()
  (UNLESS (OR SYS:INHIBIT-SCHEDULING-FLAG (NOT *PREEMPTION-ENABLED*))
    (DOLIST (PENDING SI:*PENDING-PROCESS-ABORTS*)
      (WHEN (AND (EQ (PPA-VICTIM PENDING) %REAL-CURRENT-PROCESS)
		 (NEQ (PPA-STATE PENDING) ':DONE)
		 (NEQ (PPA-STATE PENDING) ':QUERY))
	(APPLY (PPA-FUNCTION PENDING) PENDING (PPA-ARGUMENTS PENDING))))))

;;; process info stuff.

(DEFMETHOD (RESET-SCHEDULER-INFO PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (SETF (LDB %%PROCESS-DEBUG-FUNCALL-POLICY-HOOK-ON-PROCESS-SWITCH DEBUG-FLAG) 1)
    (MULTIPLE-VALUE-BIND (LOW HIGH) (TIME:FULL-MICROSECOND-TIME)
      (SETQ RECENT-RUN-TIME
	    (SYS:%32-BIT-PLUS PROCESS-USECOND-TIME-1
			      (IF (AND (EQ SELF %REAL-CURRENT-PROCESS)
				       ;; work during process-initialization, too.
				       MICROSECOND-TIME-SCHEDULED)
				  (SYS:%32-BIT-DIFFERENCE
				    (SI:%MICROSECOND-CLOCK) MICROSECOND-TIME-SCHEDULED)
				  0)))
      (SETQ RECENT-MICROSECOND-CLOCK LOW)
      (SETQ SNAPSHOT-RUN-TIME RECENT-RUN-TIME
	    SNAPSHOT-RUNNABLE-TIME (PROCESS-RUNNABLE-TIME SELF)
	    SNAPSHOT-PAGING-TIME (PROCESS-DISK-WAIT-TIME-MILLISECONDS SELF)
	    SNAPSHOT-MICROSECOND-CLOCK-LOW LOW
	    SNAPSHOT-MICROSECOND-CLOCK-HIGH HIGH
	    EARLIER-SNAPSHOT-RUN-TIME SNAPSHOT-RUN-TIME
	    EARLIER-SNAPSHOT-RUNNABLE-TIME SNAPSHOT-RUNNABLE-TIME
	    EARLIER-SNAPSHOT-PAGING-TIME SNAPSHOT-PAGING-TIME
	    EARLIER-SNAPSHOT-MICROSECOND-CLOCK-LOW LOW
	    EARLIER-SNAPSHOT-MICROSECOND-CLOCK-HIGH HIGH))))

(DEFMETHOD (PROCESS-IDLE-TIME PROCESS) ()
  (IF (EQ SELF %REAL-CURRENT-PROCESS)
      0
      (WHEN LAST-TIME-RUN
	(TIME-DIFFERENCE (ZL:TIME) LAST-TIME-RUN))))

(DEFMETHOD (PROCESS-RUN-TIME PROCESS) ()
  ;; make this work in both old and new scheduler...
  (WITHOUT-INTERRUPTS
    (WITH-SCHEDULER-LOCKED
      (+ (GET-VALUE-FROM-DOUBLE-INTEGER PROCESS-USECOND-TIME-1 PROCESS-USECOND-TIME-2)
	 (IF (EQ SELF %REAL-CURRENT-PROCESS)
	     (SYS:%32-BIT-DIFFERENCE (SI:%MICROSECOND-CLOCK) MICROSECOND-TIME-SCHEDULED)
	     0)))))

(DEFMETHOD (PROCESS-DISK-WAIT-TIME PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    ;; eventually this meter will be in microseconds.
    (ASH (+ DISK-WAIT-TIME (IF (EQL SELF %REAL-CURRENT-PROCESS)
			       (- SI:*MS-TIME-PAGE-FAULT* *PROCESS-DISK-TIME*)
			       0))
	 10.)))

(DEFMETHOD (PROCESS-DISK-WAIT-TIME-LOW PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    ;; eventually this meter will be in microseconds.
    (LSH (+ (LDB (BYTE (- (BYTE-SIZE SYS:%%Q-FIXNUM) 10.) 0) DISK-WAIT-TIME)
	    (IF (EQL SELF %REAL-CURRENT-PROCESS)
		;; si:*ms-time-page-fault* is always a fixnum, since it is incremented by
		;; SI:INCF*, so we don't have to worry about not consing a bignum.
		(sys:%32-bit-difference SI:*MS-TIME-PAGE-FAULT* *PROCESS-DISK-TIME*)
		0))
	 10.)))

(DEFMETHOD (PROCESS-DISK-WAIT-TIME-MILLISECONDS PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (+ DISK-WAIT-TIME (IF (EQL SELF %REAL-CURRENT-PROCESS)
			  (- SI:*MS-TIME-PAGE-FAULT* *PROCESS-DISK-TIME*)
			  0))))

(DEFMETHOD (PROCESS-PAGE-FAULT-COUNT PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (+ PAGE-FAULT-COUNT (IF (EQL SELF %REAL-CURRENT-PROCESS)
			  (- SI:*COUNT-PAGE-FETCHES* *PROCESS-PAGE-FAULTS*)
			  0))))

(DEFMETHOD (PROCESS-CPU-TIME PROCESS) ()
  (MAX (- (PROCESS-RUN-TIME SELF) (PROCESS-DISK-WAIT-TIME SELF)) 0))

(DEFMETHOD (PROCESS-RUNNABLE-TIME PROCESS) ()
  (IF (PROCESS-RUNNABLE-P-SELF)
      (WITH-SCHEDULER-LOCKED
	(SYS:%32-BIT-PLUS
	  TIME-RUNNABLE
	  ;; if we're runnable then RUNNABLE-START-TIME must be valid, even though
	  ;; initialized to garbage (0).
	  (SYS:%32-BIT-DIFFERENCE (SYS:%MICROSECOND-CLOCK) RUNNABLE-START-TIME)))
      TIME-RUNNABLE))

(DEFMETHOD (PERCENT-CPU PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (MULTIPLE-VALUE-BIND (O-PROCESS-TIME O-RUNNABLE-TIME)
	(IF (MULTIPLE-VALUE-BIND (LOW-NOW HIGH-NOW) (TIME:FULL-MICROSECOND-TIME)
	      (MULTIPLE-VALUE-BIND (LOW-DIFFERENCE BORROW)
		  (SYS:%SUB-BIGNUM-STEP LOW-NOW SNAPSHOT-MICROSECOND-CLOCK-LOW 0)
		(AND (ZEROP (- HIGH-NOW SNAPSHOT-MICROSECOND-CLOCK-HIGH BORROW))
		     (> LOW-DIFFERENCE *SCHEDULER-PEEK-INTERVAL-USECS*))))
	    ;; Process has gone inactive
	    (VALUES SNAPSHOT-RUN-TIME SNAPSHOT-RUNNABLE-TIME)
	    ;; Process is active, don't use too recent a snapshot
	    (VALUES EARLIER-SNAPSHOT-RUN-TIME EARLIER-SNAPSHOT-RUNNABLE-TIME))
      (LET ((PROCESS-TIME (SYS:%32-BIT-PLUS
			    PROCESS-USECOND-TIME-1
			    (IF (EQ SELF %REAL-CURRENT-PROCESS)
				(SYS:%32-BIT-DIFFERENCE
				  (SI:%MICROSECOND-CLOCK) MICROSECOND-TIME-SCHEDULED)
				0)))
	    (DELTA (SYS:%32-BIT-DIFFERENCE (PROCESS-RUNNABLE-TIME SELF) O-RUNNABLE-TIME)))
	(IF (ZEROP DELTA)
	    100.0
	    (* 100.0 (/ (FLOAT (SYS:%32-BIT-DIFFERENCE PROCESS-TIME O-PROCESS-TIME) 0.0)
			(FLOAT DELTA 0.0))))))))

(DEFMETHOD (PERCENT-PAGING PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (MULTIPLE-VALUE-BIND (O-PROCESS-TIME O-PAGING-TIME)
	(IF (MULTIPLE-VALUE-BIND (LOW-NOW HIGH-NOW) (TIME:FULL-MICROSECOND-TIME)
	      (MULTIPLE-VALUE-BIND (LOW-DIFFERENCE BORROW)
		  (SYS:%SUB-BIGNUM-STEP LOW-NOW SNAPSHOT-MICROSECOND-CLOCK-LOW 0)
		(AND (ZEROP (- HIGH-NOW SNAPSHOT-MICROSECOND-CLOCK-HIGH BORROW))
		     (> LOW-DIFFERENCE *SCHEDULER-PEEK-INTERVAL-USECS*))))
	    ;; Process has gone inactive
	    (VALUES SNAPSHOT-RUN-TIME SNAPSHOT-PAGING-TIME)
	    ;; Process is active, don't use too recent a snapshot
	    (VALUES EARLIER-SNAPSHOT-RUN-TIME EARLIER-SNAPSHOT-PAGING-TIME))
      (LET* ((PROCESS-TIME (PROCESS-RUN-TIME-LOW SELF))
	     (PAGING-TIME (PROCESS-DISK-WAIT-TIME-MILLISECONDS SELF))
	     (DELTA1 (- PAGING-TIME O-PAGING-TIME))
	     (DELTA2 (SYS:%32-BIT-DIFFERENCE PROCESS-TIME O-PROCESS-TIME)))
	(IF (OR (ZEROP DELTA1) (ZEROP DELTA2))
	    0.0
	    (* 100.0 (/ (* 1000.0 (FLOAT DELTA1)) DELTA2)))))))

(DEFMETHOD (PERCENT-UTILIZATION PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (MULTIPLE-VALUE-BIND (LOW-NOW HIGH-NOW) (TIME:FULL-MICROSECOND-TIME)
      (MULTIPLE-VALUE-BIND (O-PROCESS-TIME O-MICROSECOND-CLOCK-LOW O-MICROSECOND-CLOCK-HIGH)
	  (IF (MULTIPLE-VALUE-BIND (LOW-DIFFERENCE BORROW)
		  (SYS:%SUB-BIGNUM-STEP LOW-NOW SNAPSHOT-MICROSECOND-CLOCK-LOW 0)
		(AND (ZEROP (- HIGH-NOW SNAPSHOT-MICROSECOND-CLOCK-HIGH BORROW))
		     (> LOW-DIFFERENCE *SCHEDULER-PEEK-INTERVAL-USECS*)))
	      ;; Process has gone inactive
	      (VALUES SNAPSHOT-RUN-TIME SNAPSHOT-MICROSECOND-CLOCK-LOW
		      SNAPSHOT-MICROSECOND-CLOCK-HIGH)
	      ;; Process is active, don't use too recent a snapshot
	      (VALUES EARLIER-SNAPSHOT-RUN-TIME EARLIER-SNAPSHOT-MICROSECOND-CLOCK-LOW
		      EARLIER-SNAPSHOT-MICROSECOND-CLOCK-HIGH))
	(LET* ((PROCESS-TIME (SYS:%32-BIT-PLUS
			       PROCESS-USECOND-TIME-1
			       (IF (EQ SELF %REAL-CURRENT-PROCESS)
				   (SYS:%32-BIT-DIFFERENCE LOW-NOW MICROSECOND-TIME-SCHEDULED)
				   0))))
	  (* 100.0
	     ;; don't let this get too out of hand, if the poller gets too far behind.
	     (MIN 5.0
		  (/ (FLOAT (SYS:%32-BIT-DIFFERENCE PROCESS-TIME O-PROCESS-TIME) 0.0)
		     (IF ( (- HIGH-NOW O-MICROSECOND-CLOCK-HIGH) 1)
			 (MULTIPLE-VALUE-BIND (DIFF BORROW)
			     (SYS:%SUB-BIGNUM-STEP LOW-NOW O-MICROSECOND-CLOCK-LOW 0)
			   (IF (AND (PLUSP DIFF) ( BORROW 1))
			       (FLOAT DIFF 0.0)
			       (FLOAT CL:MOST-POSITIVE-FIXNUM 0.0)))
			 (FLOAT CL:MOST-POSITIVE-FIXNUM 0.0))))))))))

(DEFMETHOD (PROCESS-INITIAL-FUNCTION-AND-ARGS PROCESS) ()
  (VALUES (CAR INITIAL-FORM) (CDR INITIAL-FORM)))


(DEFMETHOD (PROCESS-FLUSH PROCESS) ()
  "Put a process into 'flushed' state.  The process will remain flushed until it is reset."
  (UNLESS (EQ SELF %REAL-CURRENT-PROCESS)
    (SETQ WAIT-FUNCTION #'FALSE)
    (SETQ WAIT-ARGUMENT-LIST NIL)
    (WHEN (PROCESS-RUNNABLE-P-SELF)
      (%FORCE-PROCESS-NOT-RUNNABLE-SELF 'BLOCKED NIL))
    (SETQ WHOSTATE "Flushed")))

(DEFMETHOD (PROCESS-RESET-AND-ENABLE PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (PROCESS-RESET SELF)
    (PROCESS-ENABLE SELF)))

(DEFMETHOD (PROCESS-RESET-AND-DISABLE PROCESS) ()
  (WITH-SCHEDULER-LOCKED
    (PROCESS-PRESET SELF
		    #'(LAMBDA (PROCESS OLD-INITIAL-FORM)
			(PROCESS-PRESET PROCESS OLD-INITIAL-FORM)
			(PROCESS-DISABLE PROCESS)
			(PROCESS-RESET PROCESS :ALWAYS NIL :FORCE))
		    SELF
		    INITIAL-FORM)
    (PROCESS-ENABLE SELF)))

;; a process is active if it is WAKEABLE
(DEFMETHOD (PROCESS-ACTIVE-P PROCESS) ()
  (PROCESS-WAKEABLE-P-SELF))

(DEFMETHOD (FLUSHED-P PROCESS) ()
  (APPLY #'FALSE-VERIFY-FUNCTION WAIT-FUNCTION WAIT-ARGUMENT-LIST))

(DEFMETHOD (PROCESS-ENABLE-RUN-REASON PROCESS) (&OPTIONAL (REASON ':USER))
  (WITH-SCHEDULER-LOCKED
    (COND ((NOT (MEMBER REASON RUN-REASONS))
	   (PUSH REASON RUN-REASONS)
	   (PROCESS-CONSIDER-RUNNABILITY SELF)))))

(DEFMETHOD (PROCESS-DISABLE-RUN-REASON PROCESS) (&OPTIONAL (REASON ':USER))
  (WITH-SCHEDULER-LOCKED
    (SETQ RUN-REASONS (DELETE REASON RUN-REASONS))
    (PROCESS-CONSIDER-RUNNABILITY SELF)))

(DEFMETHOD (PROCESS-ENABLE-ARREST-REASON PROCESS) (&OPTIONAL (REASON ':USER))
  (WITH-SCHEDULER-LOCKED
    (COND ((NOT (MEMBER REASON ARREST-REASONS))
	   (PUSH REASON ARREST-REASONS)
	   (PROCESS-CONSIDER-RUNNABILITY SELF)))))

(DEFMETHOD (PROCESS-DISABLE-ARREST-REASON PROCESS) (&OPTIONAL (REASON ':USER))
  (WITH-SCHEDULER-LOCKED
    (SETQ ARREST-REASONS (DELETE REASON ARREST-REASONS))
    (PROCESS-CONSIDER-RUNNABILITY SELF)))

(DEFMETHOD (PROCESS-KILL PROCESS) (&OPTIONAL (WITHOUT-ABORTS ':ASK))
  (SETF (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) 1)
  (PROCESS-RESET SELF ':ALWAYS T WITHOUT-ABORTS))

(DEFMETHOD (PROCESS-RESET-AND-RELEASE-RESOURCES PROCESS) (&OPTIONAL (WITHOUT-ABORTS ':ASK))
  (SETF (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) 0)
  (PROCESS-RESET SELF ':ALWAYS T WITHOUT-ABORTS))



;; new names.  Next pass I'll make these the real names, and copy all of the old
;; names down here.
;; The reason I'm doing it in this order is that I don't have a 404 world to make
;; the changes in, so this is a source-only change.  I don't want to refer to these
;; by other functions until (a) they're defined (!) and (b) they are the primitive ones.

(DEFUN ABORT (&REST ARGS)
  (APPLY #'PROCESS-ABORT ARGS))

(DEFUN ACTIVE-P (PROCESS)
  (PROCESS-ACTIVE-P PROCESS))

(DEFUN ALLOW-PREEMPTION ()
  (PROCESS-ALLOW-PREEMPTION))

(DEFUN BLOCK-AND-POLL-WAIT-FUNCTION (WHOSTATE INTERVAL VERIFY-FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG VERIFY-FUNCTION))
  (APPLY #'PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION WHOSTATE INTERVAL VERIFY-FUNCTION ARGS))

(DEFUN BLOCK-PROCESS (WHOSTATE VERIFY-FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG VERIFY-FUNCTION))
  (APPLY #'PROCESS-BLOCK WHOSTATE VERIFY-FUNCTION ARGS))

(DEFMACRO BLOCK-WITH-DEADLINE-ON-WAKEUP ((WHOSTATE VERIFY-FUNCTION) &BODY BODY)
  `(PROCESS-BLOCK-WITH-DEADLINE-ON-WAKEUP (,WHOSTATE ,VERIFY-FUNCTION) ,@BODY))

(DEFUN BLOCK-WITH-TIMEOUT (TIMEOUT WHOSTATE VERIFY-FUNCTION &REST ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG VERIFY-FUNCTION))
  (APPLY #'PROCESS-BLOCK-WITH-TIMEOUT TIMEOUT WHOSTATE VERIFY-FUNCTION ARGS))

(DEFUN DISABLE (PROCESS)
  (PROCESS-DISABLE PROCESS))

(DEFUN DISABLE-ARREST-REASON (PROCESS &OPTIONAL (REASON ':USER))
  (PROCESS-DISABLE-ARREST-REASON PROCESS REASON))

(DEFUN DISABLE-RUN-REASON (PROCESS &OPTIONAL (REASON ':USER))
  (PROCESS-DISABLE-RUN-REASON PROCESS REASON))

(DEFUN ENABLE (PROCESS)
  (PROCESS-ENABLE PROCESS))

(DEFUN ENABLE-ARREST-REASON (PROCESS &OPTIONAL (REASON ':USER))
  (PROCESS-ENABLE-ARREST-REASON PROCESS REASON))

(DEFUN ENABLE-RUN-REASON (PROCESS &OPTIONAL (REASON ':USER))
  (PROCESS-ENABLE-RUN-REASON PROCESS REASON))

(DEFUN FLUSH (PROCESS)
  (PROCESS-FLUSH PROCESS))

(DEFUN FORCE-WAKEUP (PROCESS)
  (PROCESS-FORCE-WAKEUP PROCESS))

(DEFUN INTERRUPT (PROCESS FUNCTION &REST ARGS)
  (APPLY #'PROCESS-INTERRUPT PROCESS FUNCTION ARGS))

(DEFMETHOD (KILL PROCESS) (&KEY (IF-CURRENT-PROCESS T) (IF-WITHOUT-ABORTS :ASK))
  (SETF (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) 1)
  (PROCESS-RESET SELF
		 (IF IF-CURRENT-PROCESS :ALWAYS :UNLESS-CURRENT)
		 T
		 IF-WITHOUT-ABORTS))

(DEFUN PRESET (PROCESS FUNCTION &REST ARGS)
  (APPLY #'PROCESS-PRESET PROCESS FUNCTION ARGS))

(DEFUN RECONSIDER-WAKEUP (PROCESS)
  (PROCESS-RECONSIDER-WAKEUP PROCESS))

(DEFUN RESET (PROCESS &KEY (IF-CURRENT-PROCESS T) (IF-WITHOUT-ABORTS :ASK))
  (PROCESS-RESET PROCESS
		 (IF IF-CURRENT-PROCESS :ALWAYS :UNLESS-CURRENT)
		 NIL
		 IF-WITHOUT-ABORTS))

(DEFUN RESET-AND-ENABLE (PROCESS)
  (PROCESS-RESET-AND-ENABLE PROCESS))

(DEFMETHOD (RESET-AND-RELEASE-RESOURCES PROCESS)
	   (&KEY (IF-CURRENT-PROCESS T) (IF-WITHOUT-ABORTS :ASK))
  (SETF (LDB PROCESS-DEBUG-KILL-PROCESS-ON-RESET DEBUG-FLAG) 0)
  (PROCESS-RESET SELF
		 (IF IF-CURRENT-PROCESS :ALWAYS :UNLESS-CURRENT)
		 T
		 IF-WITHOUT-ABORTS))

(DEFUN RUNNABLE-P (PROCESS)
  (PROCESS-RUNNABLE-P PROCESS))

(DEFUN WAIT-FOREVER (&OPTIONAL (WHOSTATE "Wait Forever"))
  (PROCESS-WAIT-FOREVER WHOSTATE))

(DEFUN WAKEUP (PROCESS)
  (PROCESS-WAKEUP PROCESS))

(DEFUN WAKEUP-WITHOUT-TEST (PROCESS)
  (PROCESS-WAKEUP-WITHOUT-TEST PROCESS))
