;;; -*- Syntax: Common-lisp; Base: 10; Mode: LISP; Package: PROCESS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; To do:
;; (a) multiple-reader/ single writer lock. (see comments)

;;; this probably should all be done inside a timer, rather than in its own process.

(SI:DEFVAR-RESETTABLE *WAIT-FUNCTION-POLLER-INITIALIZED* NIL)
(DEFVAR *WAIT-FUNCTION-POLLER*)
(DEFVAR *BACKGROUND-WAIT-FUNCTION-POLLER* NIL)
(DEFVAR *PROCESS-WAITERS* NIL)
(DEFVAR *WAIT-FUNCTION-TIMER*)
(DEFVAR *POLL-WAITERS-MINIMUM-INTERVAL* NIL)
(DEFVAR *BACKGROUND-WAIT-FUNCTION-POLLING-INTERVAL* .03)
(DEFVAR *IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL*
	(CEILING (/ (* 5 *BACKGROUND-WAIT-FUNCTION-POLLING-INTERVAL*) *TIMER-UNITS*)))
(DEFVAR *WAIT-FUNCTION-POLLER-ERROR-RECOVER-INTERVAL* 30000000) ; 1/2 of a minute.
(DEFCONSTANT INITIAL-WAITERS-QUEUE-SIZE 50)

(DEFVAR *IDLE-TIME-WAIT-FUNCTION-POLLING-INDEX* 0)
(DEFVAR *IDLE-TIME-WAIT-FUNCTION-POLLING-START* (SI:%MICROSECOND-CLOCK))

(DEFVAR *WAITING-PROCESSES* NIL)
(DEFVAR *UNSAFE-TO-WAIT* NIL)

(DEFSTRUCT (WAITING-PROCESS :NAMED :CONC-NAME
	    (:MAKE-ARRAY (:AREA SYS:PERMANENT-STORAGE-AREA))	;don't let the GC move these
	    (:COPIER NIL) (:PREDICATE NIL))
  PROCESS			;The process that is waiting
  WAIT-FUNCTION			;The function that returns true when it's done waiting
  ARGS				;Arguments to that function, normally the list is
				;embedded inside this very structure
  INTERVAL			;Number of microseconds between polls
  SPARE
  TIME-LAST-POLLED		;Microsecond clock reading when last polled
  INDEX				;Index in *WAITING-PROCESSES* queue
  ARGUMENT-STORAGE		;Space for argument list begins here
  ARG-2 ARG-3 ARG-4 ARG-5 ARG-6 ARG-7)	;Space for up to seven arguments

(DEFRESOURCE WAIT-SLOTS ()
  :CONSTRUCTOR (MAKE-WAITING-PROCESS)
  :DEINITIALIZER (FILL OBJECT NIL :START 1)
  :INITIAL-COPIES 51)		;So the active ones are all together in virtual memory

(DEFUN PROCESS-POLLING-PREDICATE ()
  (AND (NOT (NULL *PROCESS-WAITERS*))
       (NOT (TIMER-PENDING-P *WAIT-FUNCTION-TIMER*))))

(DEFUN SET-IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL (NEW-INTERVAL)
  (IF NEW-INTERVAL
      (COND ((NUMBERP NEW-INTERVAL) (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL*
					  ;; convert from seconds to internal-timer-units.
					  (CEILING (/ NEW-INTERVAL *TIMER-UNITS*))))
	    ((EQL NEW-INTERVAL :NEVER) (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL* 0.))
	    (T (CERROR "Ignore this specification"
		       "Don't know how to set the polling interval to ~S" NEW-INTERVAL)))
      (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL* NIL)))

(DEFUN START-POLLING-PROCESSES ()
  (WHEN (AND *WAIT-FUNCTION-POLLER-INITIALIZED* *PROCESS-WAITERS*)
    (PROCESS-FORCE-WAKEUP *WAIT-FUNCTION-POLLER*)
    (PROCESS-WAKEUP *BACKGROUND-WAIT-FUNCTION-POLLER*)))

(DEFUN INITIALIZE-PROCESS-POLLERS-DATA-STRUCTURES ()
  ;; cleanup for GC.
  (SI:FILL-ARRAY *WAITING-PROCESSES* NIL NIL)	;Fill even past the fill-pointer
  (SETF (FILL-POINTER *WAITING-PROCESSES*) 0)
  (SETQ *PROCESS-WAITERS* NIL))

(DEFUN INITIALIZE-PROCESS-POLLERS ()  
  (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-INDEX* 0)
  (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-START* (SI:%MICROSECOND-CLOCK))
  (SETQ *UNSAFE-TO-WAIT* NIL)

  (PROCESS-ENABLE *WAIT-FUNCTION-POLLER*)
  (PROCESS-ENABLE *BACKGROUND-WAIT-FUNCTION-POLLER*)
  (SETQ *WAIT-FUNCTION-POLLER-INITIALIZED* 'T))

(DEFMACRO WITH-WAITERS-LOCKED ((LOCAL &OPTIONAL IGNORE) &BODY BODY)
  (LET ((OLD-PREEMPT (GENSYM)))
    `(LET ((,OLD-PREEMPT *PREEMPTION-ENABLED*))
       ,OLD-PREEMPT
       (WITH-SCHEDULER-LOCKED
	 (MACROLET ((WITH-WAITERS-UNLOCKED (&BODY BODY)
		     `(LET ((*UNSAFE-TO-WAIT* NIL))
			(UNWIND-PROTECT
			    (PROGN
			      (WHEN ,',OLD-PREEMPT
				(SETQ *PREEMPTION-ENABLED* NIL)
				(PREEMPTION-BEING-REENABLED))
			      ,@BODY)
			  (SETQ *PREEMPTION-ENABLED* NIL)))))
	   (LET ((,LOCAL *WAITING-PROCESSES*)
		 (*UNSAFE-TO-WAIT* T))
	     ,@BODY))))))

(DEFUN SAFE-TO-PROCESS-WAIT-P (PROCESS)
  (NOT (OR (NOT SI:*NEW-SCHEDULER-ENABLED*)
	   (NOT *WAIT-FUNCTION-POLLER-INITIALIZED*)
	   (NOT *WAITING-PROCESSES*)
	   (LDB-TEST PROCESS-DEBUG-UNSAFE-TO-WAIT (PROCESS-DEBUG-FLAG PROCESS))
	   (EQL PROCESS PROCESS::*TIMER-TASK*)
	   *UNSAFE-TO-WAIT*)))

;;; Add more checking here...
(DEFSUBST ADD-WAITER-TO-QUEUE (WAITER QUEUE)
  (LET ((LEN (LENGTH QUEUE))
	(INDEX (WAITING-PROCESS-INDEX WAITER)))
    (UNLESS (AND INDEX (< INDEX LEN) (EQL (AREF QUEUE INDEX) WAITER))
      (SETF (WAITING-PROCESS-INDEX WAITER) LEN)
      (VECTOR-PUSH-EXTEND WAITER QUEUE))))

(DEFSUBST REMOVE-WAITER-FROM-QUEUE (WAITER QUEUE)
  (LET ((INDEX (WAITING-PROCESS-INDEX WAITER))
	(LENGTH (SYS:VECTOR-LENGTH QUEUE)))
    (WHEN (AND INDEX (< INDEX LENGTH) (EQ (AREF QUEUE INDEX) WAITER))
      (LET ((NEW-WAITER (VECTOR-POP QUEUE)))
	(SETF (AREF QUEUE INDEX) NEW-WAITER)
	(SETF (WAITING-PROCESS-INDEX NEW-WAITER) INDEX))
      (SETF (WAITING-PROCESS-INDEX WAITER) NIL)
      (WHEN (= LENGTH 1)
	(SETQ *PROCESS-WAITERS* NIL)))))

(DEFUN ADD-WAITING-PROCESS (WAITER)
  (WITH-WAITERS-LOCKED (WAITERS)
    (ADD-WAITER-TO-QUEUE WAITER WAITERS)
    (SETQ *PROCESS-WAITERS* 'T)
    (PROCESS-WAKEUP *WAIT-FUNCTION-POLLER*)))

(DEFUN REMOVE-WAITING-PROCESS (WAITER)
  (WITH-WAITERS-LOCKED (WAITERS)
    (REMOVE-WAITER-FROM-QUEUE WAITER WAITERS)))

(DEFUN STOP-POLLING-PROCESS-WAIT-FUNCTION (PROCESS)
  (WHEN (AND *WAIT-FUNCTION-POLLER-INITIALIZED* *WAITING-PROCESSES*)
    ;; reader lock promise to write
    (WITH-WAITERS-LOCKED (WAITERS)
      (STACK-LET ((DEAD-GUYS (MAKE-ARRAY (SYS:VECTOR-LENGTH WAITERS) :FILL-POINTER 0)))
	(LOOP FOR WAITER BEING THE ARRAY-ELEMENTS OF WAITERS DO
	  (WHEN (EQL PROCESS (WAITING-PROCESS-PROCESS WAITER))
	    (VECTOR-PUSH-EXTEND WAITER DEAD-GUYS)))
	;; writer lock within reader lock
	(LOOP FOR REMOVABLE-ENTRY BEING THE ARRAY-ELEMENTS OF DEAD-GUYS DO
	  (REMOVE-WAITER-FROM-QUEUE REMOVABLE-ENTRY WAITERS))))))

(DEFUN ADJUST-POLL-WAITERS-INTERVAL (NEW-MINIMUM WAITERS)
  (IGNORE WAITERS)
  (SETQ *POLL-WAITERS-MINIMUM-INTERVAL* (MAX NEW-MINIMUM *TIMER-RESOLUTION*)))

(SYS:DEFVAR-RESETTABLE *EVALUATING-VERIFY-FUNCTIONS* NIL)

;;; Called from POLL-WAIT-FUNCTIONS and friends
(DEFSUBST EVALUATE-POLLED-WAIT-FUNCTION (WAITER)
  (SETF (WAITING-PROCESS-TIME-LAST-POLLED WAITER) (SYS:%MICROSECOND-CLOCK))
  (LET* ((PROCESS (WAITING-PROCESS-PROCESS WAITER))
	 (VERIFY (WHEN PROCESS
		   (BLOCK VERIFY
		     (CATCH 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION
		       (CONDITION-BIND-DEFAULT ((DBG:DEBUGGER-CONDITION
						  (LAMBDA (ERROR)
						    (IGNORE ERROR)
						    (THROW 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION T)
						    )))
			 (LET ((SYS:DEFAULT-CONS-AREA SYS:WORKING-STORAGE-AREA)
			       (*CURRENT-PROCESS* PROCESS)
			       (*EVALUATING-VERIFY-FUNCTIONS* T))
			   (RETURN-FROM VERIFY
			     (APPLY (WAITING-PROCESS-WAIT-FUNCTION WAITER)
				    (WAITING-PROCESS-ARGS WAITER))))))
		     T))))
	(WHEN VERIFY
	  ;; If not wakeable, should not have called the wait-function, but we don't
	  ;; want to take the page fault to test wakeable until it's time to wake up
	  (WHEN (PROCESS-WAKEABLE-P PROCESS)
	    ;; See if verify function wants to change the process's priority
	    (UNLESS (EQ VERIFY T)
	      (WITH-SCHEDULER-LOCKED		;actually redundant, but keep in case
						;WITH-WAITERS-LOCKED is redesigned
		(SET-PRIORITY PROCESS VERIFY)))
	    ;; Try to avoid calling the wait-function twice
	    (IF (AND (EQ (PROCESS-WAIT-FUNCTION PROCESS)
			 (WAITING-PROCESS-WAIT-FUNCTION WAITER))
		     (EQUAL (PROCESS-WAIT-ARGUMENT-LIST PROCESS)
			    (WAITING-PROCESS-ARGS WAITER)))
		(PROCESS-FORCE-WAKEUP PROCESS)
		(PROCESS-WAKEUP PROCESS))))))

(DEFUN POLL-WAIT-FUNCTIONS ()
  (LET ((*DEBUG-IO* "Error in Wait Function Poller"))	; use the cold-load stream
    ;; reader lock
    (WITH-WAITERS-LOCKED (WAITERS)
      (COND ((ZEROP (LENGTH WAITERS))
	     (SETQ *PROCESS-WAITERS* NIL)
	     (SETQ *POLL-WAITERS-MINIMUM-INTERVAL* NIL))
	    (T
	     (LET ((NEW-MINIMUM *WAIT-FUNCTION-POLLER-ERROR-RECOVER-INTERVAL*))
	       (UNWIND-PROTECT
		   (LOOP FOR WAITER BEING THE ARRAY-ELEMENTS OF WAITERS 
			 ;;added testing for process being NIL -- Kalman
			 AS PROCESS = (WAITING-PROCESS-PROCESS WAITER)
			 AS INTERVAL = (WAITING-PROCESS-INTERVAL WAITER) 
			 WHEN PROCESS
			   DO
			     (WHEN (< INTERVAL NEW-MINIMUM)
			       (SETQ NEW-MINIMUM INTERVAL))
			     (UNLESS (SI:UNSIGNED-< (SYS:%32-BIT-DIFFERENCE (SYS:%MICROSECOND-CLOCK)
									    (WAITING-PROCESS-TIME-LAST-POLLED WAITER))
						    INTERVAL)
			       (EVALUATE-POLLED-WAIT-FUNCTION WAITER)))
		 (ADJUST-POLL-WAITERS-INTERVAL NEW-MINIMUM WAITERS)
		 (RESET-TIMER-RELATIVE-TIMER-UNITS *WAIT-FUNCTION-TIMER* NEW-MINIMUM))))))))

(DEFUN BACKGROUND-POLL-WAIT-FUNCTIONS ()
  (LET ((*DEBUG-IO* "Error in Background Wait Function Poller"))
						; use the cold-load stream
    (LOOP DOING
      ;; reader lock
      (WITH-WAITERS-LOCKED (WAITERS)
	(WHEN (PLUSP (LENGTH WAITERS))
	  (LOOP FOR WAITER BEING THE ARRAY-ELEMENTS OF WAITERS DO
	    (EVALUATE-POLLED-WAIT-FUNCTION WAITER))
	  (WHEN *POLL-WAITERS-MINIMUM-INTERVAL*
	    (RESET-TIMER-RELATIVE-TIMER-UNITS
	      *WAIT-FUNCTION-TIMER* *POLL-WAITERS-MINIMUM-INTERVAL*))))
      (SLEEP *BACKGROUND-WAIT-FUNCTION-POLLING-INTERVAL*
	     :SLEEP-REASON "Background wait-function polling"))))

(DEFUN IDLE-POLL-WAIT-FUNCTIONS (&OPTIONAL (N 1))
  (UNLESS (OR (AND *WAIT-FUNCTION-POLLER-INITIALIZED*
		   *IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL*
		   (< *IDLE-TIME-WAIT-FUNCTION-POLLING-INTERVAL*
		      (LDB (BYTE 31. 0)
			   (SYS:%32-BIT-DIFFERENCE (SI:%MICROSECOND-CLOCK)
						   *IDLE-TIME-WAIT-FUNCTION-POLLING-START*))))
	      (NOT *WAIT-FUNCTION-POLLER-INITIALIZED*))
    (WHEN SI:CLOCK-FUNCTION-LIST		;in case user pushed directly onto the
      (RUN-CLOCK-QUEUE))			;the list without calling ADD-CLOCK-FUNCTION
    (WITH-WAITERS-LOCKED (WAITERS)
      (LET* ((NWAITERS (LENGTH WAITERS))
	     (COUNT N))
	(WHEN (PLUSP NWAITERS)
	  (LET* ((START-INDEX (1+ *IDLE-TIME-WAIT-FUNCTION-POLLING-INDEX*))
		 (INDEX (IF ( NWAITERS START-INDEX) 0 START-INDEX)))
	    (LOOP FOR FIRST-TIME FIRST T THEN NIL
		  FOR I FIRST INDEX THEN (MOD (1+ I) NWAITERS)
		  UNTIL (AND (NOT FIRST-TIME) (= I INDEX)) 
		  AS WAITER = (AREF WAITERS I) DO
	      (EVALUATE-POLLED-WAIT-FUNCTION WAITER)
	      (DECF COUNT)
	      (UNLESS (PLUSP COUNT) (LOOP-FINISH))
		  FINALLY (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-INDEX* I))))))))

(DEFUN VERIFY-FUNCTION (F &REST ARGS)
  (NOT (NULL (APPLY F ARGS))))

(DEFVAR *FALSE-WAIT-FUNCTIONS* (LIST 'IGNORE 'FALSE #'IGNORE #'FALSE))

(DEFUN FALSE-VERIFY-FUNCTION (F &REST ARGS)
  (MEMBER (IF (OR (EQ F 'VERIFY-FUNCTION) (EQ F #'VERIFY-FUNCTION)) (CAR ARGS) F)
	  *FALSE-WAIT-FUNCTIONS*))

(DEFVAR *CACHED-WAIT-INTERVAL* PROCESS::*PROCESS-WAIT-INTERVAL*)
(DEFVAR *CACHED-WAIT-INTERVAL-RESULT* (CEILING (/ *CACHED-WAIT-INTERVAL* *TIMER-UNITS*)))

(DEFMACRO CONVERT-WAIT-POLLER-INTERVAL (INTERVAL)
  `(IF (EQL ,INTERVAL *CACHED-WAIT-INTERVAL*)
       *CACHED-WAIT-INTERVAL-RESULT*
       (CEILING (/ ,INTERVAL *TIMER-UNITS*))))

(DEFVAR *TIMER-TASK-WAITING* NIL)

(DEFUN POLL-WAIT-FUNCTION (PROCESS WHOSTATE INTERVAL FUNCTION ARGUMENTS)
  (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (DBG:INVISIBLE-FRAME :SCHEDULER-INTERNALS))
  (DECLARE (INLINE TIMER-ARGS (SETF TIMER-PRIORITY) (SETF TIMER-NAME)))
  ;; If waiting forever, don't need to poll
  (IF (MEMBER (IF (OR (EQ FUNCTION 'VERIFY-FUNCTION) (EQ FUNCTION #'VERIFY-FUNCTION))
		  (CAR ARGUMENTS)
		  FUNCTION)
	      *FALSE-WAIT-FUNCTIONS*)
      (APPLY #'PROCESS-BLOCK-INTERNAL PROCESS 'WAITING NIL WHOSTATE FUNCTION ARGUMENTS)
      ;; Check for recursive wait before bashing anything
      ;; If the process doesn't already have a waiting-process record, give it one
      (LET ((WAITER (OR (PROCESS-WAIT-RECORD PROCESS)
			(SETF (PROCESS-WAIT-RECORD PROCESS)
			      (ALLOCATE-RESOURCE 'WAIT-SLOTS)))))
	;; If POLL-WAIT-FUNCTION called PROCESS-BLOCK-INTERNAL, which called the FUNCTION
	;; before actually blocking, and the FUNCTION called PROCESS-WAIT, we would come
	;; back here recursively and smash our WAITER structure.
	(WHEN (WAITING-PROCESS-INDEX WAITER)
	  (THROW 'TRIED-TO-BLOCK-IN-VERIFY-FUNCTION NIL))
	(COMPILER:%ERROR-UNLESS (PLUSP INTERVAL)
	  (LOOP UNTIL (PLUSP INTERVAL) DO
	    (CERROR "Select a new polling interval"
		    "An unacceptable polling interval (~D) was specified" INTERVAL)
	    (SETQ INTERVAL (ACCEPT '((NUMBER (0)) :DESCRIPTION
				     "a number of seconds.  This interval will determine
  how frequently the wait function for this process will be evaluated")
				   :PROMPT "Polling interval in seconds"
				   :DEFAULT PROCESS:*PROCESS-WAIT-INTERVAL*))))
	(SETQ INTERVAL (CONVERT-WAIT-POLLER-INTERVAL INTERVAL))
	(SETF (WAITING-PROCESS-INTERVAL WAITER) INTERVAL)
	(SETF (WAITING-PROCESS-PROCESS WAITER) PROCESS)
	(SETF (WAITING-PROCESS-WAIT-FUNCTION WAITER) FUNCTION)
	(IF (OR (NULL ARGUMENTS)
		(> (LENGTH ARGUMENTS) 7))	;7 = WAITING-PROCESS-ARGUMENT-STORAGE
	    (SETF (WAITING-PROCESS-ARGS WAITER) ARGUMENTS)
	    ;; Copy the argument list to minimize system working set size
	    (LET ((ARGUMENT-STORAGE (LOCF (WAITING-PROCESS-ARGUMENT-STORAGE WAITER))))
	      (LOOP FOR (ARG . MORE) ON ARGUMENTS
		    FOR PTR = ARGUMENT-STORAGE
			    THEN (SYS:%MAKE-POINTER-OFFSET SYS:DTP-LOCATIVE PTR 1) DO
		(SYS:%P-STORE-CDR-AND-CONTENTS PTR ARG (IF MORE SYS:CDR-NEXT SYS:CDR-NIL)))
	      (SETF (WAITING-PROCESS-ARGS WAITER)
		    (SYS:%MAKE-POINTER SYS:DTP-LIST ARGUMENT-STORAGE))))
	(SETF (WAITING-PROCESS-TIME-LAST-POLLED WAITER)
	      (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-START* (SYS:%MICROSECOND-CLOCK)))
	(COND ((SAFE-TO-PROCESS-WAIT-P PROCESS)
	       (WITH-WAITERS-LOCKED (WAITERS)
		 (LET* ((OLD-MINIMUM *POLL-WAITERS-MINIMUM-INTERVAL*)
			(MINIMUM (IF (OR (NULL OLD-MINIMUM) (< INTERVAL OLD-MINIMUM))
				     INTERVAL
				     OLD-MINIMUM)))
		   (ADJUST-POLL-WAITERS-INTERVAL MINIMUM WAITERS)
		   (UNWIND-PROTECT
		       (loop do
			 (PROGN
			   (ADD-WAITER-TO-QUEUE WAITER WAITERS)
			   (SETQ *PROCESS-WAITERS* 'T)
			   (UNLESS (AND (TIMER-PENDING-P *WAIT-FUNCTION-TIMER*)
					(EQL MINIMUM OLD-MINIMUM))
			     (RESET-TIMER-RELATIVE-TIMER-UNITS *WAIT-FUNCTION-TIMER* MINIMUM))
			   (WITH-WAITERS-UNLOCKED
			     (APPLY #'PROCESS-BLOCK-INTERNAL
				    PROCESS 'WAITING NIL WHOSTATE FUNCTION ARGUMENTS)))
			 ;;--- Yeeeeaaah!
			 ;; This little UNTIL clause means that we can call a process
			 ;; wait function after it has already returned T.  If the wait
			 ;; function has some kind of side effects that differ in the
			 ;; T and NIL cases (e.g., CLIM's TRACKING-POINTER), this can
			 ;; cause problems.  On the other hand, if we don't have this
			 ;; looping structure with this behavior, sometimes the process
			 ;; will hang because it gets removed from the wait queue without
			 ;; actually ever running.
			 until (apply function arguments))
		     (REMOVE-WAITER-FROM-QUEUE WAITER WAITERS)
		     (FILL WAITER NIL :START 1)))))
	      (T
	       (WHEN (EQ PROCESS *TIMER-TASK*)
		 ;; We'll never recover
		 (LET ((*DEBUG-IO* "Primary Timer Task tried to WAIT.")
		       (*TIMER-TASK-WAITING* T))
		   (CATCH-ERROR-RESTART
		     (ERROR
		       "Continue normally and hope that something will wakeup the timer task"
		       NIL)
		     (UNLESS *TIMER-TASK-WAITING*  ;; avoid some recursive blowouts.
		       (CERROR "Allocate a new primary timer task and let the current process safely wait"
			       "Primary Timer Task tried to WAIT."))
		     (SETQ *TIMER-TASK* (GET-NEW-TIMER-TASK)))))
	       (FLET ((PERIODIC-WAKEUP (PERIODIC-TIMER SINGLE-WAITER)
			(WHEN PERIODIC-TIMER
			  (RESET-TIMER-RELATIVE-TIMER-UNITS
			    PERIODIC-TIMER (WAITING-PROCESS-INTERVAL SINGLE-WAITER)))
			(PROCESS-WAKEUP (WAITING-PROCESS-PROCESS SINGLE-WAITER))))
		 (USING-RESOURCE (TIMER SYSTEM-TIMERS #'PERIODIC-WAKEUP NIL WAITER)
		   (SETF (AREF (SECOND (TIMER-ARGS TIMER)) 0) TIMER)
		   (SETF (TIMER-NAME TIMER) "Wait function timer")
		   (SETF (TIMER-PRIORITY TIMER) (MAKE-PROCESS-PRIORITY :FOREGROUND 110))
		   (RESET-TIMER-RELATIVE-TIMER-UNITS TIMER INTERVAL)
		   (APPLY #'PROCESS-BLOCK-INTERNAL
			  PROCESS 'WAITING NIL WHOSTATE FUNCTION ARGUMENTS))))))))

;; internal function.  Must be called inside a with-scheduler-locked.
(DEFUN POLL-WAIT-FUNCTION-FOR-SIMPLE-PROCESS (PROCESS INTERVAL FUNCTION ARGUMENTS)
  ;; If waiting forever, don't need to poll
  (UNLESS (MEMBER (IF (OR (EQ FUNCTION 'VERIFY-FUNCTION) (EQ FUNCTION #'VERIFY-FUNCTION))
		      (CAR ARGUMENTS)
		      FUNCTION)
		  *FALSE-WAIT-FUNCTIONS*)
    ;; If the process doesn't already have a waiting-process record, give it one
    (LET ((WAITER (OR (PROCESS-WAIT-RECORD PROCESS)
		      (SETF (PROCESS-WAIT-RECORD PROCESS)
			    (ALLOCATE-RESOURCE 'WAIT-SLOTS)))))
      (COMPILER:%ERROR-UNLESS (PLUSP INTERVAL)
	(LET ((*DEBUG-IO* "Error in the scheduler"))
	  (LOOP UNTIL (PLUSP INTERVAL) DO
	    (CERROR "Select a new polling interval"
		    "An unacceptable polling interval (~D) was specified" INTERVAL)
	    (SETQ INTERVAL (ACCEPT '((NUMBER (0)) :DESCRIPTION
				     "a number of seconds.  This interval will determine
how frequently the wait function for this process will be evaluated")
				   :PROMPT "Polling interval in seconds"
				   :DEFAULT PROCESS:*PROCESS-WAIT-INTERVAL*)))))
      (SETQ INTERVAL (CONVERT-WAIT-POLLER-INTERVAL INTERVAL))
      (SETF (WAITING-PROCESS-INTERVAL WAITER) INTERVAL)
      (SETF (WAITING-PROCESS-PROCESS WAITER) PROCESS)
      (SETF (WAITING-PROCESS-WAIT-FUNCTION WAITER) FUNCTION)
      (IF (OR (NULL ARGUMENTS)
	      (> (LENGTH ARGUMENTS) 7))		;7 = WAITING-PROCESS-ARGUMENT-STORAGE
	  (SETF (WAITING-PROCESS-ARGS WAITER) ARGUMENTS)
	  ;; Copy the argument list to minimize system working set size
	  (LET ((ARGUMENT-STORAGE (LOCF (WAITING-PROCESS-ARGUMENT-STORAGE WAITER))))
	    (LOOP FOR (ARG . MORE) ON ARGUMENTS
		  FOR PTR = ARGUMENT-STORAGE
			  THEN (SYS:%MAKE-POINTER-OFFSET SYS:DTP-LOCATIVE PTR 1) DO
	      (SYS:%P-STORE-CDR-AND-CONTENTS PTR ARG (IF MORE SYS:CDR-NEXT SYS:CDR-NIL)))
	    (SETF (WAITING-PROCESS-ARGS WAITER)
		  (SYS:%MAKE-POINTER SYS:DTP-LIST ARGUMENT-STORAGE))))
      (SETF (WAITING-PROCESS-TIME-LAST-POLLED WAITER)
	    (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-START* (SYS:%MICROSECOND-CLOCK)))
      (WITH-WAITERS-LOCKED (WAITERS)
	(LET* ((OLD-MINIMUM *POLL-WAITERS-MINIMUM-INTERVAL*)
	       (MINIMUM (IF (OR (NULL OLD-MINIMUM) (< INTERVAL OLD-MINIMUM))
			    INTERVAL
			    OLD-MINIMUM)))
	  (ADJUST-POLL-WAITERS-INTERVAL MINIMUM WAITERS)
	  (ADD-WAITER-TO-QUEUE WAITER WAITERS)
	  (SETQ *PROCESS-WAITERS* 'T)
	  (UNLESS (AND (TIMER-PENDING-P *WAIT-FUNCTION-TIMER*) (EQL MINIMUM OLD-MINIMUM))
	    (RESET-TIMER-RELATIVE-TIMER-UNITS *WAIT-FUNCTION-TIMER* MINIMUM)))))))

(DEFUN STOP-POLLING-WAIT-FUNCTION-FOR-SIMPLE-PROCESS (PROCESS WAITER)
  (WHEN (AND WAITER (EQL (WAITING-PROCESS-PROCESS WAITER) PROCESS))
    (WITH-WAITERS-LOCKED (WAITERS)
      (WHEN (EQL (WAITING-PROCESS-PROCESS WAITER) PROCESS)
	(REMOVE-WAITER-FROM-QUEUE WAITER WAITERS)
	(FILL WAITER NIL :START 1)
	T))))

;; value is value of (FUNCALL BODY)
(DEFUN WITH-WAIT-FUNCTION-POLLING-INTERNAL (BODY INTERVAL FUNCTION ARGUMENTS)
  (DECLARE (SYS:DOWNWARD-FUNARG BODY))
  (IF (MEMBER (IF (OR (EQ FUNCTION 'VERIFY-FUNCTION) (EQ FUNCTION #'VERIFY-FUNCTION))
		  (CAR ARGUMENTS)
		  FUNCTION)
	      *FALSE-WAIT-FUNCTIONS*)
      (FUNCALL BODY)
      (USING-RESOURCE (WAITER WAIT-SLOTS)
	(COMPILER:%ERROR-UNLESS (PLUSP INTERVAL)
	  (LOOP UNTIL (PLUSP INTERVAL) DO
	    (CERROR "Select a new polling interval"
		    "An unacceptable polling interval (~D) was specified" INTERVAL)
	    (SETQ INTERVAL (ACCEPT '((NUMBER (0)) :DESCRIPTION
				     "a number of seconds.  This interval will determine
how frequently the wait function for this process will be evaluated")
				   :PROMPT "Polling interval in seconds"
				   :DEFAULT PROCESS:*PROCESS-WAIT-INTERVAL*))))
	(SETQ INTERVAL (CONVERT-WAIT-POLLER-INTERVAL INTERVAL))
	(SETF (WAITING-PROCESS-INTERVAL WAITER) INTERVAL)
	(SETF (WAITING-PROCESS-PROCESS WAITER) %REAL-CURRENT-PROCESS)
	(SETF (WAITING-PROCESS-WAIT-FUNCTION WAITER) FUNCTION)
	(IF (OR (NULL ARGUMENTS)
		(> (LENGTH ARGUMENTS) 7))	;7 = WAITING-PROCESS-ARGUMENT-STORAGE
	    (SETF (WAITING-PROCESS-ARGS WAITER) ARGUMENTS)
	    ;; Copy the argument list to minimize system working set size
	    (LET ((ARGUMENT-STORAGE (LOCF (WAITING-PROCESS-ARGUMENT-STORAGE WAITER))))
	      (LOOP FOR (ARG . MORE) ON ARGUMENTS
		    FOR PTR = ARGUMENT-STORAGE
			    THEN (SYS:%MAKE-POINTER-OFFSET SYS:DTP-LOCATIVE PTR 1) DO
		(SYS:%P-STORE-CDR-AND-CONTENTS PTR ARG (IF MORE SYS:CDR-NEXT SYS:CDR-NIL)))
	      (SETF (WAITING-PROCESS-ARGS WAITER)
		    (SYS:%MAKE-POINTER SYS:DTP-LIST ARGUMENT-STORAGE))))
	(SETF (WAITING-PROCESS-TIME-LAST-POLLED WAITER)
	      (SETQ *IDLE-TIME-WAIT-FUNCTION-POLLING-START* (SYS:%MICROSECOND-CLOCK)))
	(IF (SAFE-TO-PROCESS-WAIT-P %REAL-CURRENT-PROCESS)
	    (WITH-WAITERS-LOCKED (WAITERS)
	      (LET* ((OLD-MINIMUM *POLL-WAITERS-MINIMUM-INTERVAL*)
		     (MINIMUM (IF (AND OLD-MINIMUM (< INTERVAL OLD-MINIMUM))
				  INTERVAL
				  OLD-MINIMUM)))
		(ADJUST-POLL-WAITERS-INTERVAL MINIMUM WAITERS)
		(UNWIND-PROTECT
		    (PROGN
		      (ADD-WAITER-TO-QUEUE WAITER WAITERS)
		      (SETQ *PROCESS-WAITERS* 'T)
		      (UNLESS (TIMER-PENDING-P *WAIT-FUNCTION-TIMER*)
			(RESET-TIMER-RELATIVE-TIMER-UNITS *WAIT-FUNCTION-TIMER* MINIMUM))
		      (WITH-WAITERS-UNLOCKED
			(FUNCALL BODY)))
		  (WITH-WAITERS-LOCKED (WAITERS)
		    (REMOVE-WAITER-FROM-QUEUE WAITER WAITERS)))))
	    (FLET ((PERIODIC-WAKEUP (PERIODIC-TIMER SINGLE-WAITER)
		     (WHEN PERIODIC-TIMER
		       (RESET-TIMER-RELATIVE-TIMER-UNITS
			 PERIODIC-TIMER (WAITING-PROCESS-INTERVAL SINGLE-WAITER)))
		     (PROCESS-WAKEUP (WAITING-PROCESS-PROCESS SINGLE-WAITER))))
	      (USING-RESOURCE (TIMER SYSTEM-TIMERS #'PERIODIC-WAKEUP)
		(SETF (AREF (SECOND (TIMER-ARGS TIMER)) 0) TIMER)
		(SETF (TIMER-NAME TIMER) "Wait function timer")
		(SETF (TIMER-PRIORITY TIMER) (MAKE-PROCESS-PRIORITY :FOREGROUND 120))
		(RESET-TIMER-RELATIVE-TIMER-UNITS TIMER INTERVAL)
		(FUNCALL BODY)))))))

(DEFMACRO WITH-WAIT-FUNCTION-POLLING ((INTERVAL FUNCTION &REST ARGS) &BODY BODY)
  (LET ((ARGS-HOLDER (GENSYM)))
    `(WITH-STACK-LIST (,ARGS-HOLDER ,@ARGS)
       (WITH-WAIT-FUNCTION-POLLING-INTERNAL
	 #'(LAMBDA () (DECLARE (SYS:DOWNWARD-FUNCTION)) ,@BODY)
	 ,INTERVAL
	 ,FUNCTION
	 ,ARGS-HOLDER))))

(DEFUN CLEAN-UP-PROCESS-WAITERS ()
  (LET ((DEAD-GUYS NIL))
    ;; reader
    (WITH-WAITERS-LOCKED (WAITERS)
      (LOOP FOR WAITER BEING THE ARRAY-ELEMENTS OF WAITERS USING (INDEX INDEX) DO
	(LET ((PROCESS (WAITING-PROCESS-PROCESS WAITER))
	      (STORED-INDEX (WAITING-PROCESS-INDEX WAITER)))
	  (UNLESS (EQL INDEX STORED-INDEX)
	    (LET ((REAL-WAITER (AND STORED-INDEX (AREF WAITERS STORED-INDEX))))
	      (IF (EQL REAL-WAITER WAITER)
		  ;; oops.  Duplicate.
		  (PUSH REAL-WAITER DEAD-GUYS)
		  (SETF (WAITING-PROCESS-INDEX WAITER) INDEX))))
	  (UNLESS (PROCESS-WAKEABLE-P PROCESS)
	    (PUSH WAITER DEAD-GUYS)))))
    (LOOP FOR WAITER IN DEAD-GUYS DO
      (REMOVE-WAITING-PROCESS WAITER))))


