;;; -*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; This software is based on ideas published by Richard C. Waters
;;; His aid is gratefully acknowledged

;;; This is a new implementation of GPRINT for the Lisp Machine.
;;; Started by DLW 1/16-20/83.  Work resumed 2/10/83.
;;; Converted to Common Lisp by Eric Benson 3/84

;;; Note: the redo/continue feature is not implemented and may never be.
;;; Same with the circularity checker, which is not Common-Lisp-like.
;;;  Made Common Lisp compatible by EB, 3/84
;;; The print-like argument and the gprint function are useless and easy to write yourself.
;;; The gexploding stuff; just use with-output-to-string etc.
;;; Strange gforce-mores feature.
;;; The gcheck-indentation kludge.
;;; The following things are being dropped in the recoding:
;;;   Variables gabbreved, gtruncated, gnowprinting; gcheckrecursion, grptr, gparents.
;;;   Functions gredo, gcontinue.


;;; This file contains the guts of the printer.

;;; Auxiliary functions called by generated code.

;;; This is called at the beginning of a [] loop.  If it returns true, the
;;; loop immediately exits.
(defun initial-test ()
  (cond ((atom *value*)
	 ;; If it's not a list, then exit the loop.
	 t)
	(t
	 ;; It's a list, allow the loop to proceed.
	 (when *inspecting*
	   (setq *locative* (locf (car *value*))))
	 nil)))

;;; This is called to advance to the next element of *value* inside a [] loop.
;;; If it returns true, the loop immediately exits.
(defun go-to-next ()
  (setq *locative* (locf (cdr *value*)))
  (pop *value*)
  (cond ((null *value*))			;End of list, return from loop.
	((or (atom *value*)			;Dotted list
	     (and *print-circle*		;Or circular table entry
		  (duplicate-entry-p (find-in-duplicates-table *value*))))
	 (gformat ",{0'. '*}" *value*)		;   Print a dot and the item,
	 t)					;   and return from loop.
	((check-length (null (cdr *value*)) (car *value*)))
	(t
	 ;; Everything is OK, allow the loop to proceed.
	 (when *inspecting*
	   (setq *locative* (locf (car *value*))))
	 nil)))

;;; This is called to advance to the next element of *value* inside a [] loop,
;;; if a PERIOD token is coming soon.  The returned value is ignored.
(defun go-to-next-period ()
  (setq *locative* (locf (cdr *value*)))
  (pop *value*))

;;; If *print-length* has been exceeded, then queue up a " ..." and return T.
;;; lastp says whether we're on the last item of the list; next-item is the
;;; next item, if we're not at the end.
(defun check-length (lastp next-item)
  next-item
  (when (and (not lastp) (>= (eqs-length *eqs-ptr*) *actual-print-length*))
    (gformat "~")
    (with-sensitivity (*locative* (:sensitivity-ellipsis-start :sensitivity-ellipsis-end))
      (gformat "'...'"))
    t))

;;; Enqueue.

;;; enqueue is called by the code generated from the formatting strings.
;;; type is a keyword symbol saying what to do.  object is an argument,
;;; whose meaning depends on type (see comments at defstruct of queue).
;;; State variables:
;;; *enqueued-size* is the total sizes of all :princ, :prin1, :special, 
;;; and :space commands in the queue from 0 to the *queue-in* pointer.
;;; *dequeued-size* is the same from 0 to the *queue-out* pointer, so their
;;; difference is the total size of what's waiting in the queue to be printed.
;;; Note: *queue-in* is always > *queue-out*; the queue is not "circular".
(defun enqueue (type object &aux size)
  ;; Compute the size.
  (setq size (case type
	       (:start nil)		;Don't know the size yet.
	       (:newline		;For :block or :initial, don't know yet.  Else unused.
		(if (member object '(:block :initial)) nil 0))
	       (:prin1
		 (let ((*print-pretty* nil)
		       (*print-circle* nil));finding size doesn't count as printing
		   ;; Compute size, with slashes.
		   (bounded-flatsize object *total-line-length*)))
	       (:princ			;Compute size, without slashes.
		(let ((*print-pretty* nil)
		      (*print-circle* nil)) ;finding size doesn't count as printing
		  (bounded-flatc object *total-line-length*)))
	       (:special (string-length object))
	       (:space object)		;The argument is the size.
	       ((:ind :end :tab :eval
		 :sensitivity-ellipsis-start :sensitivity-ellipsis-end
		 :sensitivity-expression-start :sensitivity-expression-end) 0)	;Unused.
	       (otherwise (error "~S is not a known type" type))))
  ;; Fill in the queue entry.
  (setf (queue-type *queue-in*) type)
  (setf (queue-object *queue-in*) object)
  (setf (queue-size *queue-in*) size)
  ;; Do special processing for :start and :end.
  (case type
    (:start
     ;; Push a new entry on the enqueueing stack.
     (let ((old-level (eqs-level *eqs-ptr*)))
       (push-eqs)
       (setf (eqs-queue-ptr *eqs-ptr*)	;Save pointer to corresponding queue entry.
	     *queue-in*)
       (setf (eqs-level *eqs-ptr*)	;Current level for prinlevel checks.
	     (if (equal object 0) old-level (1+ old-level)))
       (setf (eqs-length *eqs-ptr*) 0)	;Start counting length for prinlength checks.
       (setf (eqs-saved-size *eqs-ptr*)	;Saved *enqueued-size* to compute structure's size.
	     *enqueued-size*)))
    (:end
     (let ((queue-ptr (eqs-queue-ptr *eqs-ptr*)))
       (unless (minusp queue-ptr)
	 ;; The :start entry is still in the queue.  We now know the structure's size.
	 (setf (queue-size queue-ptr)
	       (setq size (- *enqueued-size* (eqs-saved-size *eqs-ptr*))))
	 (update-sizes queue-ptr size)))	;Propagate the size to waiting newlines.
     ;; Pop the entry from the enqueueing stack.
     (pop-eqs)))
  ;; Update the total size.
  (when (member type '(:princ :prin1 :special :space))
    (incf *enqueued-size* size))
  ;; If this is a real Lisp object, count it against the eqs-length.
  (when (member type '(:princ :prin1 :end))
    (incf (eqs-length *eqs-ptr*)))
  ;; If we now know the size of the stuff between two newline-points, propagate
  ;; the size of that stuff back to the earlier newline-point.
  (when (eq type ':newline)
    (update-sizes *queue-in* 0))
  (push-queue)
  (setq *queue-max* (max *queue-max* *queue-in*))

  ;; Now try to dequeue any entries that are ready to be printed.
  (loop while (< *queue-out* *queue-in*) do
	(cond ((not (null (queue-size *queue-out*)))
	       ;; The size of the item is known; print it.
	       (print-out))
	      ((or (and (eq type ':newline) (eq object ':always))
		   (> (- *enqueued-size* *dequeued-size*) *total-line-length*))
	       ;; Either a forced newline is upon us, or there's more stuff in the
	       ;; queue than fits on a line.  Don't bother to wait to compute the size,
	       ;; just print it, preceded by a newline if possible.
	       (setf (queue-size *queue-out*) #o7777777)
	       (print-out))
	      (t
	       ;; It's not time yet; stop trying to dequeue.
	       (return)))
	;; The top item has been printed out.  Add to *dequeued-size* and get rid of the item.
	(when (member (queue-type *queue-out*) '(:princ :prin1 :special :space))
	  (incf *dequeued-size* (queue-size *queue-out*)))
	(incf *queue-out* *queue-size*))

  ;; If the queue was left empty, reset pointers.  Invalidate all existing eqs-queue-ptrs.
  ;; Otherwise if the queue is more than half empty, garbage collect it.
  (cond ((= *queue-in* *queue-out*)
	 (setq *queue-in* 0
	       *queue-out* 0
	       *enqueued-size* 0
	       *dequeued-size* 0)
	 (loop for i from 0 to *eqs-ptr* by *eqs-size* do
	   (setf (eqs-queue-ptr i) -1)))
	((> (* *queue-out* 2) *queue-in*)
	 (loop for i from 0 to *eqs-ptr* by *eqs-size* do
	   (decf (eqs-queue-ptr i) *queue-out*))
	 (replace *queue* *queue* :start2 *queue-out* :end2 *queue-in*
		  :end1 (- *queue-in* *queue-out*))
	 (decf *queue-in* *queue-out*)
	 (setq *queue-out* 0))))

;; Dump out anything left over in the queue when we are done
(defun flush-queue ()
  (update-sizes *queue-in* 0)  
  (loop while (< *queue-out* *queue-in*) do
    (when (null (queue-size *queue-out*))
      (setf (queue-size *queue-out*) 0))
    (print-out)
    (incf *queue-out* *queue-size*)))

;;; Now that we know the size of the queue entry pointed to by ptr, go back
;;; the queue to find any :newline/:block entries right before us and set
;;; their queue-size from it.  Do not back up over a :start, which has its
;;; own handling of size propagation.
(defun update-sizes (ptr size)
  (loop until (< (decf ptr *queue-size*) *queue-out*)
	do (case (queue-type ptr)
	     ((:princ :prin1 :special :eval :space
	       :sensitivity-ellipsis-start :sensitivity-ellipsis-end
	       :sensitivity-expression-start :sensitivity-expression-end)
	      (incf size (queue-size ptr)))
	     ((:newline)
	      (when (eq (queue-object ptr) ':block)
		(setf (queue-size ptr) size))
	      (return nil))
	     ((:end :ind))
	     (otherwise (return nil)))))

;;; print-out is called from enqueue.  It prints out the queue item pointed
;;; to by *queue-out*.  The caller is responsible for actually updating *queue-out*.
;;; State variables:
;;; *depth* is normally zero.  It becomes positive when we are inside a list that
;;; completely fits on the current line; its value is the depth in such lists.
;;; The best way to understand this crucial state variable is to notice that it controls
;;; whether :newline/:normal will cause a new line or not.  While *depth* is
;;; positive, print-out mostly doesn't do anything except simply print out items
;;; on the current line and watch for it to become zero again.
;;; *went-up* means that there was a :end on this physical line; that is, we have
;;; gone up out of list structure while printing this line.
;;; *pending* is the number of pending spaces; they only get actually printed if
;;; there's something to come after them before the line ends.
;;; *pending-newline* is a flag meaning that a newline is pending, again only
;;; if something will actually come after it.
;;; *line-number* is the count of lines printed, for *print-start/end-line*.
;;; *free* is the number of free character positions left on this line.
;;; *line-length* is the total length of a line, and so (- *line-length *free*)
;;; is the number of characters that have already been printed on this line.
;;; *total-line-length* is the total length of a line, including the left
;;; margin.  The :newline :initial queue entry will cause a newline if the
;;; left margin is so large that it's forcing the text to be crammed to the
;;; right too much.

(defun print-out ()
  (let ((type (queue-type *queue-out*))
	(object (queue-object *queue-out*))
	(size (queue-size *queue-out*)))
    ;; First decide whether this item puts us onto a new line.
    (when (and (zerop *depth*)		;If *depth* > 0, it all fits, so no newline.
	       (or (and (eq type ':newline)
			(case object
			  ((:always :normal) t)
			  (:miser (miser-mode-p))
			  (:block
			   (or *went-up*
			       (and (< (dqs-pending-indent *dqs-ptr*)
				       (- *line-length* *free*))
				    (> size *free*))))
			  (:initial
			    ;; Putting in this newline would cause the stuff queued so far
			    ;; to take two lines, plus however many mandatory newlines it
			    ;; contains.  If the last item would cause overflow onto
			    ;; an additional line, it is not counted.
			    ;; Estimate the number of lines that the queued stuff would
			    ;; take without this newline.  There are some approximations
			    ;; here, but it should be close enough.  If it's at least two
			    ;; more lines than with this newline, put in this newline.
			    ;; This is a heuristic; to decide for sure would require
			    ;; infinite lookahead.  Assuming :newline :normal does the
			    ;; same thing on both passes is another heuristic approximation.
			    ;; Also put in the newline if not doing so would cause a long
			    ;; symbol to overflow the right margin.
			    (flet ((lookahead (line-length limit)
				    (declare (values n-lines limit line-overflow))
				    (loop for ptr from *queue-out* by *queue-size* below limit
					  with size = 0 with ind = 0 with n-lines = 1
					  with possible-newline = nil
					  with line-overflow = nil with allow-newline = nil
					  with went-up = nil with depth = 0
					  with *dqs-ptr* = *dqs-ptr*
					  until (> size *total-line-length*)
					  finally
					    ;; Don't force a newline when printing an atom
					    ;; (actually when no newline could occur within
					    ;; the text), because too many uses of PRINC
					    ;; (or ~A) depend on newlines not being inserted.
					    (unless allow-newline
					      (setq line-overflow nil))
					    (return (values n-lines ptr line-overflow))
					  as qsize = (queue-size ptr) do
				     (case (queue-type ptr)
				      ((:princ :prin1 :special :eval :space
					:sensitivity-ellipsis-start :sensitivity-ellipsis-end
					:sensitivity-expression-start
					:sensitivity-expression-end)
				       (incf size qsize)
				       (when (> size line-length)
					 ;; Allow for crock below that sometimes newlines
					 (cond ((and (zerop depth)
						     (member (queue-type ptr)
							     '(:princ :prin1 :special))
						     (> size line-length)
						     ( (+ ind qsize) line-length))
						(setq size (+ ind qsize))
						(incf n-lines)
						(setq went-up nil))
					       ((not possible-newline)
						;; Would overflow right margin if initial
						;; newline omitted, and there are no
						;; :newline :blocks of unresolved size,
						;; so force a newline at the front.
						(setq line-overflow t)))))
				      (:start
				       (cond ((and (zerop depth)
						   (or (null qsize)
						       (> (+ qsize size) line-length)))
					      (push-dqs)
					      (setf (dqs-pending-indent *dqs-ptr*) ind)
					      (setq ind size)
					      (unless (< (+ size *miser-width*) line-length)
						(incf ind)))
					     (t (incf depth))))
				      (:ind
				       (when (and (zerop depth)
						  (< (+ size *miser-width*) line-length))
					 (incf ind (or (queue-object ptr)
						       (let ((*queue-out* ptr))
							 (get-indentation)))))
				       ;; Crock for one-element list -- without this,
				       ;; if it runs off the right margin, a newline
				       ;; would be inserted before the close parenthesis
				       (setq allow-newline t))
				      (:end
				       (cond ((zerop depth)
					      (setq ind (dqs-pending-indent *dqs-ptr*))
					      (pop-dqs)
					      (setq went-up t))
					     (t (decf depth))))
				      (:newline
				       (unless (eq (queue-object ptr) ':initial)
					 (setq allow-newline t))
				       (when (zerop depth)
					 (when (case (queue-object ptr)
						 ((:always :normal) t)
						 (:miser ( (+ ind *miser-width*)
							    line-length))
						 (:block
						  (cond (went-up)
							((null qsize)
							 ;; Assuming it's too big to fit gives
							 ;; better results than assuming small
							 (setq possible-newline t)
							 (< ind size))
							(t (and (< ind size)
								(> (+ size qsize) line-length)
								)))))
					   (setq size ind)
					   (incf n-lines)
					   (setq went-up nil))))))))
			      (multiple-value-bind (n-long-lines limit)
				  (lookahead *total-line-length* *queue-in*)
				(multiple-value-bind (n-short-lines nil line-overflow)
				    (lookahead *line-length* limit)
				  (cond ((or ( n-short-lines (+ n-long-lines 2))
					     line-overflow)
					 ;; Put in the extra newline
					 (setq *left-margin* (or *overriding-left-indent* 0)
					       *line-length* *total-line-length*)
					 t)
					(t
					 ;; Do not put in the extra newline.  Don't need extra
					 ;; lookahead any more so decrease *total-line-length*
					 (setq *total-line-length* *line-length*)
					 nil))))))))
		   ;; Put a newline before this item if we have a succession of close
		   ;; parentheses that would run off the end of the line or we are printing
		   ;; a really long atom that would run off the end of the line if printed
		   ;; in its normal position.  Only do this if it buys something, of course.
		   (and (member type '(:princ :prin1 :special))
			(> size *free*)
			( (+ (dqs-pending-indent *dqs-ptr*) size)
			   *line-length*))
		   ))
      ;; Yes, this entry puts us onto a new line.
      (setq *pending-newline* t)
      (setq *pending* (dqs-pending-indent *dqs-ptr*))
      (setq *free* (- *line-length* *pending*))
      (setq *went-up* nil))
    ;; Process the item, according to its type.
    (case type
      (:start
       (incf *print-out-level*)
       (cond ((and (zerop *depth*) (> size *free*))
	      ;; This substructure doesn't fit either, so keep *depth* zero.
	      ;; Push an entry on the dequeueing stack.
	      (push-dqs)
	      (setf (dqs-pending-indent *dqs-ptr*)	;Save current indentation level
		    (- *line-length* *free*))
	      (when (miser-mode-p)	;:ind is ignored in miser mode; just use 1 instead.
		(incf (dqs-pending-indent *dqs-ptr*)))
	      (setf (dqs-tab-size *dqs-ptr*) -1))
	     (t (incf *depth*))))
      (:ind
       (when (and (zerop *depth*)		;There's no queue entry if *depth* > 0.
		  (not (miser-mode-p)))		;:ind is ignored in miser mode.
	 (setf (dqs-pending-indent *dqs-ptr*)
	       (max (+ (dqs-pending-indent *dqs-ptr*)
		       (or object (get-indentation)))
		    0))))
      (:end
       (decf *print-out-level*)
       (cond ((zerop *depth*)
	      (setq *went-up* t)
	      (pop-dqs))
	     (t (decf *depth*))))
      ((:sensitivity-ellipsis-start :sensitivity-expression-start)
       (setq *pending-sensitivity-type* type
	     *pending-sensitivity-object* object))
      ((:sensitivity-ellipsis-end :sensitivity-expression-end)
       (case type
	 (:sensitivity-expression-end
	   (funcall *inspecting* :end :location object))
	 (:sensitivity-ellipsis-end
	   (funcall *inspecting* :end :location object :type 'expression-length-ellipsis))))
      ((:princ :prin1 :special :eval)
       ;; The time has come to actually print something.
       ;; If there is a pending newline, do it.
       (when *pending-newline*
	 (when ( *line-number* *print-end-line*)	;If passed end-line, quit.
	   (throw 'finished nil))
	 (when ( *line-number* *print-start-line*)	;If printing not suppressed,
	   (write-char #\Return *stream*)
	   (incf *pending* *left-margin*))
	 (incf *line-number*)
	 (setq *pending-newline* nil))
       ;; If there are pending spaces, do them.
       (when ( *line-number* *print-start-line*)	;If printing not suppressed,
	 (let ((to-go *pending*))
	   (loop while (> to-go 0) do
	     (cond ((= to-go 1)
		    (write-char #\Space *stream*)
		    (decf to-go))
		   (t
		    (let ((n (min 100 to-go)))
		      (write-string #.(make-array 100 :element-type 'string-char
						  :initial-element #\space)
				    *stream* :start 0 :end n)
		      (decf to-go n)))))))
       (setq *pending* 0)
       ;; If there is pending presentation start, start it now.
       (when *pending-sensitivity-type*
	 (ecase *pending-sensitivity-type*
	   (:sensitivity-expression-start
	     (funcall *inspecting* :start :location *pending-sensitivity-object*))
	   (:sensitivity-ellipsis-start
	     (funcall *inspecting* :start :location *pending-sensitivity-object*
		      :type 'expression-length-ellipsis)))
	 (setq *pending-sensitivity-type* nil))
       ;; Now actually do it.
       (cond ((eq type ':eval)
	      (eval object))
	     (( *line-number* *print-start-line*)	;If printing not suppressed,
	      (case type			; do what prin1 or princ would do
		(:prin1				; in non-pretty, non-circle case
		  (simple-print-object object t *stream*))
		(:princ
		 (simple-print-object object nil *stream*))
		(:special
		  ;; Send single-character strings out with :tyo, which saves some
		  ;; time on dynamic windows compared with sending them via :string-out,
		  ;; for instance it does one less :read-cursorpos
		  ;; Making these objects characters instead of strings in the first
		  ;; place would be better, but more difficult
		  ;; Use array-total-size because it compiles as an instruction
		  (if (= (array-total-size object) 1)
		      (send *stream* :tyo (aref object 0))
		      (send *stream* :string-out object))))))
       (decf *free* size))
      (:space
       (when (minusp object)			;Limit negative spaces to undo pending space.
	 (setq object (max (- *pending*) object)))
       (incf *pending* object)
       (decf *free* object))
      (:tab
       (when (and (zerop *depth*)
		  (not *pending-newline*))
	 (let* ((tab (cond (object)		;Tab size explicitly supplied.
			   ((not (minusp (dqs-tab-size *dqs-ptr*)))
			    ;; Not supplied.  If computed for this level, use it.
			    (dqs-tab-size *dqs-ptr*))
			   (t
			    ;; Not computed yet.  Compute it, save it, and use it.
			    (setf (dqs-tab-size *dqs-ptr*) (estimate-tab-size))
			    (dqs-tab-size *dqs-ptr*))))
		(offset (mod (- (- *line-length* *free*)
				(dqs-pending-indent *dqs-ptr*))
			   tab)))
	   (when (not (zerop offset)) (setq offset (- tab offset)))
	   (incf *pending* offset)
	   (decf *free* offset)))))))

;;; If the pending-indent of the containing structure leaves over fewer columns
;;; than *miser-width*, then we are in miser mode, in which :ind is ignored and
;;; :newline/:miser causes a newline.
(defun miser-mode-p ()
  (< *line-length*
     (+ *miser-width*
	(if (plusp *dqs-ptr*)
	    (dqs-pending-indent (- *dqs-ptr* *dqs-size*))
	    0))))

;;; This computes the pending-indent for a level when it is not explicitly specified.
;;; Go over the queue, adding up the width of everything up to the first :prin1 or
;;; :princ, and any :space after it.  In the usual case, if you just use () in your
;;; control string, the indentation defaults to the sum of the lengths of the open
;;; paren, the first item in the list, and any blank space after it.  Note that
;;; if there isn't enough stuff queued up, the answer will be too small, but this 
;;; only happens when you're printing up against the right margin.
(defun get-indentation ()
  (let ((indent 0)
	(found-print nil))
    (loop for i from *queue-out* below *queue-in* by *queue-size* do
	  (case (queue-type i)
	    ((:prin1 :princ)
	     (when found-print (return))
	     (setq found-print t)
	     (incf indent (queue-size i)))
	    (:space
	     (incf indent (queue-size i)))
	    (:special
	     (when found-print (return))
	     (incf indent (queue-size i)))))
    indent))

;;; This computes the tab size for a level of structure, when the :tab command
;;; doesn't provide it explicitly.  It looks over the queue to form its estimate.
;;; It always returns a size large enough to hold at least one element.
(defun estimate-tab-size ()
  (let ((answer 2))
    (loop with level = 0			;Level of substructure.
	  for i from *queue-out* below *queue-in* by *queue-size* do
	  (let ((size (queue-size i)))		;Size of this element.
	    (when (and (zerop level)		;(Don't look inside substructures)
		       (numberp size))		;If size is known,
	      (setq answer (max size answer))))	; then max it in.
	  (case (queue-type i)
	    (:start (incf level))
	    (:end (decf level))))
    (incf answer)				;Allow for a space between items.
    (incf answer (/ answer 5))			;Pad by 20% for good luck.
    (let ((space (- *line-length* (dqs-pending-indent *dqs-ptr*))))
      ;; space is the amount of room on each line.  Adjust answer up so that
      ;; we don't lose space at the end simply due to roundoff error.
      ;; Note that (/ space answer) is the number of items per line.
      (when (> space answer)
	(setq answer (/ space (/ space answer)))))
    answer))

;;; Safety
(defun bounded-flatsize (x bound)
  (bounded-flat-operation #'prin1 x bound))

(defun bounded-flatc (x bound)
  (bounded-flat-operation #'princ x bound))

(defun bounded-flat-operation (fcn x bound)
  (let ((ioch 0))
    (labels ((flat-stream (op &rest args)
	       (declare (sys:downward-function))
	       (case op
		     (:tyo (incf ioch)
		      (when (> ioch bound)
			(return-from bounded-flat-operation ioch)))
		     (:string-out
		       (destructuring-bind (string &optional from to) args
			 (incf ioch (- (or to (string-length string))
				       (or from 0))))
		       (when (> ioch bound)
			 (return-from bounded-flat-operation ioch)))
		     (:string-length (destructuring-bind (string
							   &optional (from 0)
							   (to (string-length string)))
							 args
				       (- to from)))
		     (:which-operations '(:tyo :string-out :string-length))
		     (otherwise
		       (sys:stream-default-handler #'flat-stream op (first args)
						   (rest args))))))
      (funcall fcn x #'flat-stream))
    ioch))

;--- gdispatch already computed the same computations that this does to determine
;--- if there is a print-self handler, it's a pity having to do them over again.
;--- I suppose there could be two more queue keywords and this could be a
;--- separate function from the regular simple-print-object
(defun simple-print-object (object escape stream)
  ;; Speed bum
  (unless (or (and (instancep object)
		   (not (eql-dispatch-instance-p object)))
	      (funcallable-instance-p object)
	      (arrayp object))
    (return-from simple-print-object
      (let ((si:*print-error* nil))
	(si:print-object object 0 escape stream (send stream :which-operations) t))))
  ;; This stream is given to a :print-self method.  It captures any print operations
  ;; performed by that method and re-enters the printer, preserving printer state
  ;; such as circular-printer anaphora, *print-depth* cutoff.
  ;; The lexical closure is made by hand so that it can be evacuated into the heap.
  (stack-let* ((environment (list object escape stream nil))	;nils are filled in later
	       (print-self-stream (cons environment nil)))
    (flet ((print-self-stream (environment op &rest args)
	     (macrolet ((object () `(first environment))
			(escape () `(second environment))
			(stream () `(third environment))
			(print-self-stream () `(fourth environment)))
	       (when (and (eq op ':send-if-handles)
			  (member (car args) '(:string-out :tyo :print :gprint)))
		 (setq op (pop args)))
	       (case op
		 (:print
		   (let ((xstream (print-self-stream)))
		     (si:with-sensitivity-flag ((first args) xstream)
		       (si:print-object (first args) (second args) (third args)
					xstream '(:string-out :tyo :print :gprint)
			 ;; If prin1 of an instance includes princ of itself in its
			 ;; printed representation, the princ is usually going to appear
			 ;; differently and so should not count as a duplicate.  This is
			 ;; a heuristic but it works better with this in than with it out.
			 (if (and (eq (first args) (object))
				  (escape)
				  (not *print-escape*))
			     t
			     ':print-self)))
		     t))
		 (:gprint
		   (let ((xstream (third args)))
		     (si:with-sensitivity-flag ((first args) xstream)
		       (gprint:print-object (first args) (second args) xstream
			 ;; If prin1 of an instance includes princ of itself in its
			 ;; printed representation, the princ is usually going to appear
			 ;; differently and so should not count as a duplicate.  This is
			 ;; a heuristic but it works better with this in than with it out.
			 (if (and (eq (first args) (object))
				  (escape)
				  (not *print-escape*))
			     t
			     ':print-self)))
		     t))
		 (:which-operations '(:string-out :tyo :print :gprint))
		 (otherwise (apply (stream) op args))))))
      (setf (cdr print-self-stream) #'print-self-stream)
      (setq print-self-stream (%make-pointer dtp-lexical-closure print-self-stream))
      (setf (fourth environment) print-self-stream)
      (let ((si:*print-error* nil))
	(cond ((and (instancep object) (operation-handled-p object :print-self))
	       (let ((*actual-print-level* (- *actual-print-level* *print-out-level* 1)))
		 (send object :print-self print-self-stream (1+ *print-out-level*) escape)))
	      ((funcallable-instance-p object)
	       (let ((*actual-print-level* (- *actual-print-level* *print-out-level* 1))
		     (*print-escape* escape))
		 (clos:print-object object print-self-stream)))
	      ((and (arrayp object)
		    (let ((name (named-structure-p object)))
		      (and (symbolp name)
			   (get name 'named-structure-invoke)
			   (member ':print-self
				   (named-structure-invoke object :which-operations)))))
	       (let ((*actual-print-level* (- *actual-print-level* *print-out-level* 1)))
		 (named-structure-invoke object :print-self print-self-stream
					 (1+ *print-out-level*) escape)))
	      (t
	       (si:print-object object 0 escape stream (send stream :which-operations) t)))))))

;;; The dispatcher.

;;; They are the heart of the interface to sensitive output.
(defmacro with-sensitivity ((&optional (locative 'locative)
				       (types '(:sensitivity-expression-start
						:sensitivity-expression-end)))
			   &body body)
  `(progn (when (and *inspecting* ,locative)
	    (enqueue ',(first types) ,locative))
	  ,@body
	  (when (and *inspecting* ,locative)
	    (enqueue ',(second types) ,locative))))

;;; User-bindable lists of special hook functions.
(defvar *special-formatters* nil "Hooks called for all objects")
(defvar *overriding-list-formatters* nil "Hooks called for lists, before suggested format")
(defvar *list-formatters* nil "Hooks called for lists")
(defvar *array-formatters* nil "Hooks called for arrays")

;;; User-bindable formatter functions.
(defvar *function-formatter* 'format-function
  "Formatter of function-call forms")
(defvar *symbol-car-formatter* 'format-1block
  "Formatter of forms with unknown symbols in their cars")
(defvar *lambda-combination-formatter* 'format-lambda-combination
  "Formatter of lambda-combination forms")
(defvar *non-symbol-car-formatter* 'format-1block
  "Formatter of forms with unknown non-symbol objects in their cars")
(defvar *data-formatter* 'format-data
  "Formatter of non-code lists")
(defvar *property-list-formatter* 'format-property-list
  "Formatter of property lists")
(defvar *association-list-formatter* 'format-association-list
  "Formater of (dotted) association lists")

;;; This function takes a Lisp object and decides what to do with it.  Basically,
;;; it enqueues objects, and so the queue has to be ready to run at the time this
;;; is called.  If it sees a list, its action depends on whether suggested-format
;;; is provided.  If suggested-format is nil, it assumes the object is a Lisp form
;;; and uses the car to figure out what to do.  If suggested-format is not nil, it
;;; should be a function, and it is applied to the list to handle it.  There are also
;;; the various lists of hooks above that let you control what goes on inside here.
;;; This function also does print-level checking and calls the inspector hook function.
(defun gdispatch (suggested-format object)
  (let ((locative *locative*) (*locative* nil)	;New level for inspector.
	(basic-printer #|*basic-printer*|# (if *print-escape* :prin1 :princ))
	(depth-exceeded? ( (eqs-level *eqs-ptr*) *actual-print-level*))
	entry)
    (cond ((and *print-circle*
		(progn (setf entry (find-in-duplicates-table object))
		       (duplicate-entry-p entry)))
	   (if (printed-duplicate-entry-p entry)
	       (let ((*print-base* 10.))
		 (with-sensitivity ()
		   (gformat "'#'*'#'" (- entry)))
		 (return-from gdispatch nil))
	       (progn (set-printed-duplicate-entry object entry)
		      (let ((*print-base* 10.))
			(gformat "'#'*'='" entry))))))
    (cond ((and (null depth-exceeded?)
		(loop for fn in *special-formatters* do
		  (when (funcall fn object) (return t))))
	   ;; Try special formatters.  If any return t, done.
	   nil)
	  ((or (symbolp object) (numberp object) (stringp object) (bit-vector-p object))
	   ;; Simple atom, just enqueue it.
	   (with-sensitivity ()
	     (enqueue basic-printer object)))
	  ((consp object)
	   (with-sensitivity ()
	     (cond (depth-exceeded?
		    (enqueue :princ "#"))
		   ((loop for fn in *overriding-list-formatters*
			  thereis (funcall fn object))
		    ;; First the overriding list formatters get their chance at the object.
		    nil)
		   ((and (plusp *gprint-backquote-depth*)
			 (assoc (first object) *readable-backquote-formatters*))
		    (funcall (second (assoc (first object) *readable-backquote-formatters*))
			     object))
		   ((not (null suggested-format))
		    ;; If a suggested-format was provided, it takes over.
		    (funcall suggested-format object))
		   ((loop for fn in *list-formatters* thereis (funcall fn object))
		    ;; Next the regular list formatters get their chance.
		    nil)
		   (t
		    (let ((first (first object)))
		      (funcall		;Find a function to call on the list.
			(cond ((symbolp first)
			       (cond ((get first 'formatter))
				     ((fboundp first) *function-formatter*)
				     (t *symbol-car-formatter*)))
			      ((si:interpreted-lambda-p first)
			       *lambda-combination-formatter*)
			      (t *non-symbol-car-formatter*))
			object))))))
	  ((named-structure-p object)
	   (with-sensitivity ()
	     (if depth-exceeded?
		 (enqueue :princ "#")
		 (let* ((name (named-structure-symbol object))
			(operations (and (symbolp name) (get name 'named-structure-invoke)
					 (named-structure-invoke object
								 :which-operations))))
		   (cond ((member :format-self operations)
			  (named-structure-invoke object :format-self *stream*))
			 ((member :print-self operations)
			  ;; :PRINT-SELF overrides #S.
			  (enqueue basic-printer object))
			 ((and (symbolp name)
			       (get name 'si:defstruct-description)
			       (or si:print-readably *print-structure-contents*))
			  (format-structure-contents
			    (list*
			      name
			      (loop for (slot . plist)
					in (si:defstruct-description-slot-alist
					     (get name 'si:defstruct-description))
				    collect (intern (symbol-name slot) "")
				    collect
				      (eval `(,(si:defstruct-slot-description-ref-macro-name
						 plist)
					      ',object))))))
			 (t (enqueue basic-printer object)))))))
	  ((instancep object)
	   (with-sensitivity ()
	     (cond (depth-exceeded? (enqueue :princ "#"))
		   ((and (not (eql-dispatch-instance-p object))
			 (operation-handled-p object ':format-self))
		    (send object ':format-self *stream*))
		   (t (enqueue basic-printer object)))))
	  ((funcallable-instance-p object)
	   (with-sensitivity ()
	     (if depth-exceeded?
		 (enqueue :princ "#")
		 (if (clos-internals:operation-handled-p object ':format-self)
		     (clos-internals:format-self object *stream*)
		     (enqueue basic-printer object)))))
	  ((and (arrayp object)
		*print-array*
		(or (null *print-array-length*)
		    (> *print-array-length* (zl:array-active-length object))))
	   (with-sensitivity ()
	     (if depth-exceeded?
		 (enqueue :princ "#")
		 (loop for fn in *array-formatters* do
		   (when (funcall fn object) (return))
		       finally (format-array object)))))
	  (t
	   (with-sensitivity ()
	     (enqueue basic-printer object))))))


;;; The top level.

(defresource stacks ()
  :constructor (make-array 100.)
  :initial-copies 2)

(defresource queues ()
  :constructor (make-array 1000.)
  :initial-copies 1)

(defun print-object (object &optional suggested-format (stream *standard-output*)
				      (recursive nil))
  (let ((dbg:*printing-monitor-message* dbg:*inhibit-monitoring-during-print*)
	(full-gprint nil))
    (condition-bind
        ((error #'(lambda (condition)
		    (condition-case ()
			 ;; Normal printing method got an error.  If appropriate
			 ;; substitute a default printed representation similar
			 ;; to what PRINT-RANDOM-OBJECT prints.  But if that
			 ;; gets an error (maybe the stream is dead), go back
			 ;; to signalling the original error.
			 ;; Do this on interactive streams, so we can inspect and
			 ;; debug busted objects, but don't do it on non-interactive
			 ;; streams, where we would rather be able to debug the error.
			 (unless si:*print-error*
			   (when (cl:case si:*print-error-suppress*
				   (:interactive (send stream :interactive))
				   (otherwise si:*print-error-suppress*))
			     (unless (typep condition 'print-not-readable)
			       (let ((si:*print-error* t))
				 (when full-gprint (flush-queue))
				 (printing-random-object (object stream)
				   (si:print-raw-string "Error printing object " stream)
				   (si:print-raw-string
				     (string (or (si:allow-recursive-wired-ferror
						   (ignore-errors (type-of object)))
						 (data-type object)))
				     stream))
				 ;; Make sure the stream is really working
				 (send stream :force-output)
				 (return-from print-object object)))))
		       (error
			 ;; Error while printing the substitute p.r., give up
			 (setq si:*print-error* t)
			 nil)))))

      ;; Give the stream a chance to handle it (e.g. for mouse-sensitivity)
      (unless (and (not recursive)
		   (send-if-handles stream :gprint object suggested-format stream))

	;; If gdispatch isn't going to do anything, avoid the setup overhead
	;; This assumes *special-formatters* isn't going to do anything with these objects
	(cond (*locative*)
	      ((symbolp object)
	       (return-from print-object
		 (si:print-pname-string object *print-escape* stream)))
	      ((numberp object)
	       (return-from print-object
		 (typecase object
		   (fixnum (si:print-fixnum-or-bignum object stream))
		   (single-float (si:print-flonum object stream))
		   #+3600
		   (otherwise (si:print-extended-number object stream nil 0 nil))
		   #+IMACH
		   (bignum (si:print-fixnum-or-bignum object stream))
		   #+IMACH
		   (rational (si:print-rational object stream))
		   #+IMACH
		   (complex (si:print-complex object stream))
		   #+IMACH
		   (double-float (si:print-flonum object stream)))))
	      ((and (arrayp object)
		    (let ((object (follow-structure-forwarding object)))
		      (and (= (%p-data-type object) dtp-header-i)
			   (= (%p-ldb %%header-type-field object) %header-type-array)))
		    (not (named-structure-p object))
		    (or (stringp object) (bit-vector-p object)))
	       (return-from print-object
		 (si:print-array-contents object 0 *print-escape* stream nil nil))))

	(using-resource (*queue* queues)
	  (using-resource (*eqs* stacks)
	    (using-resource (*dqs* stacks)
	      (let* ((*stream* stream)
		     ;; Queue pointers and stack pointers.
		     (*queue-in* 0) (*queue-out* 0) (*queue-max* 0)
		     (*eqs-ptr* 0) (*dqs-ptr* 0)
		     ;; State variables for enqueue and print-out.
		     (*enqueued-size* 0) (*dequeued-size* 0)
		     (*depth* 0) (*went-up* nil)
		     (*pending* 0) (*pending-newline* nil)
		     (*pending-sensitivity-type* nil) (*pending-sensitivity-object* nil)
		     (*actual-print-length* (if (eq recursive ':print-self)
						*actual-print-length*
						(or *print-length* most-positive-fixnum)))
		     (*actual-print-level* (if (eq recursive ':print-self)
						*actual-print-level*
						(or *print-level* most-positive-fixnum)))
		     (*print-out-level* 0)
		     (*line-number* 0)
		     (*left-margin*
		       (or *overriding-left-indent*
			   (send-if-handles *stream* :read-cursorpos :character)
			   0))
		     (*total-line-length*
		       (or *overriding-line-length*
			   (send-if-handles *stream* :size-in-characters)
			   95.))
		     (*line-length*
		       (- *total-line-length* *left-margin*))
		     (*free* *line-length*)
		     (*print-pretty* (not (null *print-pretty*))))

		;; Interpret formatting specification
		(etypecase suggested-format
		  (boolean
		    (setq suggested-format nil))
		  (keyword
		    (setq suggested-format (eval
					     (second
					       (assoc suggested-format
						      *standard-formatters*))))
		    ;; Format subexpressions as data too
		    (when (and *print-pretty* (neq suggested-format :code))
		      (setq *print-pretty* :data)))
		  (function ))

		;; Set up the zero-entries of the enqueueing and dequeueing stacks.
		(setf (eqs-queue-ptr 0) -1)
		(setf (eqs-level 0) 0)
		(setf (eqs-length 0) 0)
		(setf (eqs-saved-size 0) 0)
		(setf (dqs-tab-size 0) -1)
		(setf (dqs-pending-indent 0) 0)
		(catch 'finished
		  (setq full-gprint t)
		  (cond ((eq recursive ':print-self)
			 (gdispatch suggested-format object)
			 (setq full-gprint nil)
			 (flush-queue))
			(t
			 (with-circular-printer-tables
			   (when *print-circle* (find-duplicates object))
			   (unless (zerop *left-margin*)
			     (enqueue :newline :initial))
			   (gdispatch suggested-format object)
			   (setq full-gprint nil)
			   (flush-queue))))
		  (when (or (not (zerop *eqs-ptr*)) (not (zerop *dqs-ptr*)))
		    (error "Not enough }s in formatting string")))
		(si:fill-array *queue* *queue-max* nil)	;Don't hold onto garbage
		)))))
    object)))

;;; Functions for testing.

(defun gform (x)
  (terpri)
  (print-object x))

(defun gfile (x)
  (with-open-file (stream x)
    (loop for object = (read stream nil) while object do
	  (gform object)
	  (terpri))))
