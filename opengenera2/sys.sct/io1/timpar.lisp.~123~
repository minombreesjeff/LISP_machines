;;;     -*- Syntax: Zetalisp; Mode: Lisp; Package: Time; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Convert Date To Binary for the Lisp Machine    DLW 9/14/80
;;; Take a description of a time (including a date) in any of many commonly
;;; understood formats, parse it and return it in a machine-usable form.

;;; Look at the definition of *TEST-CASES* later in this file for examples
;;; of time formats that the time parser tries to understand, followed by
;;; a list of more esoteric things that it might someday be made to work on.

(DEFVAR *TIME-PACKAGE* (PKG-FIND-PACKAGE "TIME"))

;;; Random list function.
(DEFUN DELQ-ALL (LIST SYMBOLS)
  (DOLIST (SYMBOL SYMBOLS)
    (SETQ LIST (DELQ SYMBOL LIST)))
  LIST)


;;; Lexical analyzer.

;;; Improve performance by trying to stay away from INTERN at run-time,
;;; which is slow.
(DEFCONST *SPECIAL-CHAR-SYMBOLS* '((#/- . -) (#/+ . +) (#// . //)
				   (#/: . /:) (#/, . /,) (#/. . /.) (#/; . /;)
				   (#/@ . /@)))

(DEFCONST *MONTH-SYMBOLS* '(("JAN" . JAN) ("FEB" . FEB) ("MAR" . MAR) ("APR" . APR)
			    ("MAY" . MAY) ("JUN" . JUN) ("JUL" . JUL) ("AUG" . AUG)
			    ("SEP" . SEP) ("OCT" . OCT) ("NOV" . NOV) ("DEC" . DEC)))

(DEFUN MONTH-INTERN (STRING PACKAGE)
  (OR (AND (= (STRING-LENGTH STRING) 3)
	   (CDR (ASSOC STRING *MONTH-SYMBOLS*)))
      (INTERN STRING PACKAGE)))

;;; If all character comparisons were performed with CHAR-EQUAL and
;;; CHAR-LESSP, then this macro would not be needed.
(DEFMACRO LEX-REF (INDEX) `(AREF STRING ,INDEX))

;;; This function is the lexical analyzer of the parser; it splits a string
;;; up into tokens.  It takes a string, and optionally the starting and finishing
;;; indexes of a substring within the string to use.  It returns a list.
;;; Each element of the list corresponds to a token.  Numbers, interpreted
;;; in decimal, appear in the list as two-lists; the first element is a fixnum
;;; giving the value of the number, and the second is the number of digits
;;; (including leading zeroes!).  Any other token appears as
;;; a symbol (interned in the Time package).
(DEFUN LEXICALLY-ANALYZE (STRING &OPTIONAL (START 0) (END (STRING-LENGTH STRING)))
  (WHEN (SI:ASSURE-FAT-STRING STRING T)
    (SETQ STRING (SI:CHANGE-STRING-CHARACTER-STYLE
		   STRING
		   ;; remove all character style
		   '(NIL NIL NIL))))
  ;; Each time around this loop we either skip over some uninteresting text,
  ;; or we cons another token onto the list of tokens.
  (DO ((INDEX START)
       (RESULT NIL))
      (( INDEX END)
       (NREVERSE RESULT))
    (LET ((CHAR (LEX-REF INDEX)))
      (COND ((MEMQ CHAR '(#\SP #\TAB #/' #\CR))
	     ;; This is a whitespace character, ignore it.
	     (SETQ INDEX (1+ INDEX)))
	    ((ASSQ CHAR *SPECIAL-CHAR-SYMBOLS*)
	     ;; This is a special character.  Make a new token which is is
	     ;; symbol whose name is that character.
	     (PUSH (CDR (ASSQ CHAR *SPECIAL-CHAR-SYMBOLS*)) RESULT)
	     (SETQ INDEX (1+ INDEX)))
	    ((DIGIT-CHAR-P CHAR)
	     ;; This is the beginning of a number in decimal.  Make a new token
	     ;; which is a fixnum of this number's value.
	     (DO ((I (1+ INDEX) (1+ I))
		  (DIGITS 1 (1+ DIGITS))
		  (N 0))
		 (NIL)
	       (SETQ N (+ (* N 10.) (DIGIT-CHAR-P CHAR)))
	       (COND ((OR ( I END)
			  (NOT (DIGIT-CHAR-P (SETQ CHAR (LEX-REF I)))))
		      (PUSH (LIST N DIGITS) RESULT)
		      (SETQ INDEX I)
		      (RETURN NIL)))))
	    ((ALPHA-CHAR-P CHAR)
	     ;; This is the beginning of an alphabetic token.  Scan over all contiguous
	     ;; letters, upcasing them, and make a new token which is a symbol.
	     (DO ((I INDEX (1+ I)))
		 ((OR ( I END)
		      (LET ((CHAR (LEX-REF I)))
			;; If it is not a letter (and some other stuff true), break.
			(AND (NOT (ALPHA-CHAR-P CHAR))
			     ;; This clause is to make "A.M." and "P.M." work, but note
			     ;; that trailing dots are ignored (see below).
			     (NOT (CHAR-EQUAL CHAR #/.))
			     ;; If we are inside an alphabetic token and see a hypen followed
			     ;; by a letter, accept this; e.g. "twenty-third".
			     (NOT (AND (CHAR-EQUAL CHAR #/-)
				       (< (1+ I) END)
				       (ALPHA-CHAR-P (LEX-REF (1+ I)))
				       ;; Special kludge: if it is AM- or PM-, break
				       ;; here; some hosts send AM-EDT and such.
				       (NOT (MERIDIEM-STRING-P STRING INDEX I)))))))
		  (PUSH (MONTH-INTERN
			  (STRING-UPCASE
			    (NSUBSTRING STRING
					INDEX
					;; Strip trailing dots, for "Wed." and "Oct.".
					;; Unfortunately also for "A.M.", see way below.
					(IF (CHAR-EQUAL (LEX-REF (1- I)) #/.)
					    (1- I)
					    I)))
			  *TIME-PACKAGE*)
			RESULT)
		  (SETQ INDEX I))))
	    ((CHAR-EQUAL CHAR #/()
	     ;; This is the beginning of a parenthesized string.  RFC733 defines such
	     ;; to be equivalent to whitespace, so we ignore this string.  The "Laurel"
	     ;; program puts days of the week in parens, but these are redundant so it
	     ;; is OK to ignore them.
	     (DO ((I INDEX (1+ I)))
		 ((OR ( I END)
		      (CHAR-EQUAL (LEX-REF I) #/)))
		  (SETQ INDEX (1+ I)))))
	    (T
	     (BARF "Unknown character ~C" CHAR))))))

;;; MMcM reports that at least one network host sends times containing the string
;;; AM-EDT to report meridiem and time zone.  In order for us to understand this,
;;; we have to separate it into two tokens specially, even though usually we don't
;;; break at "-" (for the benefit of numbers like "twenty-three").  This is a
;;; special-case kludge, of course.
(DEFUN MERIDIEM-STRING-P (STRING INDEX I)
  (AND (= I (+ INDEX 2))
       (MEMBER (SUBSTRING STRING INDEX I) '("AM" "PM"))))

;;; Defining patterns.

;;; A pattern is a list of N pattern elements, which are compared one-for-one
;;; with the first N elements of the token list we are analyzing.  Each
;;; pattern element may be:
;;; (a) A symbol or fixnum, which matches exactly that symbol or fixnum.
;;; (b) A list whose CAR is a "special pattern" symbol, in which case a special
;;;        function associated with that symbol is invoked.
;;; (c) A list of one symbol, which is interpreted as an arbitrary predicate
;;;        of one argument, which is applied to the token and should return
;;;        true if the token "matches".
;;;
;;; Note: symbols with FIXNUM-STRING properties are treated as if they
;;; were fixnums, rather than symbols.  This is for English cardinal and
;;; ordinal numbers.
;;;
;;; The following special pattern symbols exist, with the following special "forms":
;;;  (FIXP), which matches any fixnum.
;;;  (FIXP <n>), which matches any fixnum with exactly n digits.
;;;  (FIXP <m> <n>), which matches any fixnum with between m and n digits inclusive.
;;;  (FRACTION), which matches any fraction, with articles before or after.
;;;    These fractions are phrases like "a half", not numbers and slashes.
;;;  (FRACTION T), which matches any fraction, not including articles after.
;;;  (ANY-OF <pattern-element> <pattern-element> ...), which matches if any of the
;;;    pattern elements match.
;;;  (GET <property-indicator>), which matches if the token is a symbol with a
;;;    non-NIL <property-indicator> property.
;;;  (ANY), which matches any single token.

;;; Examples:
;;;   ((FIXP 1 2) /: (FIXP 2) /: (FIXP 2))    Matches 11:30:15
;;;   ((GET MONTH) (FIXP 1 2) /, (FIXP 4))    Matches Jan 23, 1980
;;;   (12. (GET MERIDIEM))                    Matches 12 pm or 12 am
;;;   ()                                      Matches anything
;;;   ((ANY))                                 Matches anything except no tokens.

;;; The special form DEFPATTERN defines a pattern, information about when to try to
;;; match it, and what to do if it is matched.  The form looks like this:
;;; (DEFPATTERN <from-state> <pattern> <to-state> <lambda-list> . <body>)
;;; The parser has a state, represented by a symbol.
;;; It finds all the DEFPATTERNs for its current
;;; state by finding all those with <from-state> EQ to the current state.
;;; It applies each pattern in succession.  When it finds a pattern that
;;; matches, it invokes the associated function (defined by the <lambda-list>
;;; and <body> of the DEFPATTERN) and sets the state to <to-state>; it also
;;; CDRs off the matched portion of the token list, proceeding with the rest
;;; of the list.  The argument to the function defined by DEFPATTERN are
;;; all those tokens in the token list that matched the pattern, except
;;; those that were expressed in the pattern as symbols or fixnums (since
;;; these are just constants, the function is not interested in them).
;;; (Those that were expressed as ANY-OF pattern elements ARE passed
;;; to the function, even if the token is a constant, just in case the
;;; function cares which of the choices was taken.
;;;
;;; The parse proceeds until there are no tokens left and the state
;;; has a FINAL-STATE property of T.
;;;
;;; There is another version of DEFPATTERN called DEFPATTERN-PEEK, which
;;; is the same except that it "looks ahead" at the tokens, without
;;; passing over them.  Also, the tokens are not passed to the function;
;;; the function must take zero arguments.
;;;
;;; NOTE that the order of DEFPATTERNs in this file is significant, and
;;; defines the order in which patterns are checked.
;;;
;;; A data structure that allows the parser to find all the patterns is
;;; constructed at LOAD-time.  A list of known states is maintained as
;;; the value of *STATES*.  Each state is given a PATTERNS property,
;;; consisting of a list of elements of the form:
;;;  (<pattern> <to-state> <function-to-call> <skip-tokens>)
;;; These lists are CONSed up in reverse order, and NREVERSEd at the end.
;;; <skip-tokens> is true for DEFPATTERN and false for DEFPATTERN-PEEK.

(DEFMACRO DEFPATTERN (FROM-STATE PATTERN TO-STATE LAMBDA-LIST &BODY BODY)
  (LET ((FUNCTION-NAME (GENSYM)))
    `(PROGN 'COMPILE
	    (DEFUN ,FUNCTION-NAME ,LAMBDA-LIST (PROGN ,@BODY))
	    (DEFINE-PATTERN ',FROM-STATE ',PATTERN ',TO-STATE ',FUNCTION-NAME T))))

(DEFMACRO DEFPATTERN-PEEK (FROM-STATE PATTERN TO-STATE LAMBDA-LIST &BODY BODY)
  (LET ((FUNCTION-NAME (GENSYM)))
    `(PROGN 'COMPILE
	    (DEFUN ,FUNCTION-NAME ,LAMBDA-LIST (PROGN ,@BODY))
	    (DEFINE-PATTERN ',FROM-STATE ',PATTERN ',TO-STATE ',FUNCTION-NAME NIL))))

;(DEFVAR *STATES* NIL)  Need to check if unbound.
(DEFVAR *STATES*)

;;; This function gets invoked once at load-time before any of the patters
;;; are defined.  There must be exactly one top-level call to this
;;; function in the file, and it must be before all the DEFPATTERNs.
(DEFUN START-PATTERNS ()
  (IF (VARIABLE-BOUNDP *STATES*)
      ;; We are reloading.
      (DOLIST (STATE *STATES*)
	(SI:NREMPROP STATE 'PATTERNS)))
  (SETQ *STATES* NIL))

;;; This function runs once at load-time for each DEFPATTERN.  This DEFUN must
;;; appear before any calls to DEFPATTERN in this file.
(DEFUN DEFINE-PATTERN (FROM-STATE PATTERN TO-STATE FUNCTION-NAME SKIP-PATTERNS)
  (OR (MEMQ FROM-STATE *STATES*)
      (PUSH FROM-STATE *STATES*))
  (PUSH (LIST PATTERN TO-STATE FUNCTION-NAME SKIP-PATTERNS)
	(GET FROM-STATE 'PATTERNS)))

;;; This function gets invoked once at load-time after all the patterns
;;; are defined.  There must be exactly one top-level call to this
;;; function in this file, and it must be after all the DEFPATTERNs.
(DEFUN FINISH-PATTERNS ()
  (DOLIST (STATE *STATES*)
    (SETF (GET STATE 'PATTERNS)
	  (NREVERSE (GET STATE 'PATTERNS)))))

;;; Parser.

(DEFVAR *DEFAULT-REL-SIGN*)

;;; This is the function that interprets patterns according to the algorithm
;;; described above.  It returns the final value of STATE.
(DEFUN PARSE-1 (TOKEN-LIST INITIAL-STATE)
  (LET ((*DEFAULT-REL-SIGN*
	  (IF (MEMQ 'AGO TOKEN-LIST) '- '+)))
    (DO ((STATE INITIAL-STATE)
	 (TOKENS TOKEN-LIST))
	((AND (NULL TOKENS) (GET STATE 'FINAL-STATE))
	 STATE)
      ;; Try matching the first tokens of TOKENS against all the patterns
      ;; associated with STATE.
      (DO ((TRIES (GET STATE 'PATTERNS) (CDR TRIES)))
	  ((NULL TRIES)
	   (BARF "No pattern matches the tokens ~S in state ~S" TOKENS STATE))
	
	(LET ((TRY (CAR TRIES))
	      MATCHED-TOKENS)
	  ;; TRY represents one of the patterns associated with STATE; it looks
	  ;; like (<pattern> <to-state> <function-name> <skip-tokens>).
	  (COND ((MULTIPLE-VALUE (NIL MATCHED-TOKENS)
		   (PATTERN-MATCH (FIRST TRY) TOKENS))
		 ;; Found it!  Run the function, advance over the matched tokens,
		 ;; go to the new state and continue.
		 (LET ((RESULT (PATTERN-INVOKE (FIRST TRY) MATCHED-TOKENS
					       (THIRD TRY) (FOURTH TRY))))
		   (IF (FOURTH TRY)
		       (SETQ TOKENS RESULT)))
		 (SETQ STATE (SECOND TRY))
		 (RETURN NIL))))))))

;;; Try to match PATTERN against the beginning of TOKEN-LIST.
;;; Return possibly altered token list if they match, else NIL.
(DEFUN PATTERN-MATCH (PATTERN TOKEN-LIST)
  (DECLARE (VALUES MATCHP EDITED-TOKEN-LIST))
  ;; Check specially for two possible first elements of the pattern
  ;; that are the ones we check for in parsing dates from file servers.
  (DO ((PATTERN PATTERN (CDR PATTERN))
       (ENTIRE-TOKEN-LIST TOKEN-LIST)
       (EDITED-TOKEN-LIST)
       (TOKEN-LIST TOKEN-LIST))
      (NIL)
    (COND ((NULL PATTERN)
	   ;; We've matched each element.  Matches!
	   (RETURN (VALUES T ENTIRE-TOKEN-LIST)))
	  ((NULL TOKEN-LIST)
	   ;; There is more pattern, but no more tokens.  No match.
	   (RETURN NIL))
	  ((NOT (MULTIPLE-VALUE (NIL TOKEN-LIST EDITED-TOKEN-LIST)
		  (MATCH-ELEMENT (CAR PATTERN) TOKEN-LIST ENTIRE-TOKEN-LIST)))
	   ;; This element does not match, lose.
	   (RETURN NIL))
	  (EDITED-TOKEN-LIST
	   (SETQ ENTIRE-TOKEN-LIST EDITED-TOKEN-LIST)))))

;;; Predicate: Does PATTERN-ELEMENT match the first TOKEN(s) of TOKEN-LIST?
;;; Second value the remaining tokens not matched.
(DEFUN MATCH-ELEMENT (PATTERN-ELEMENT TOKEN-LIST ENTIRE-TOKEN-LIST
		      &AUX (TOKEN (CAR TOKEN-LIST))
		      (REMAINING-TOKEN-LIST (CDR TOKEN-LIST))
		      EDITED-TOKEN-LIST
		      MATCHP)
  (DECLARE (VALUES MATCHP REMAINING-TOKEN-LIST EDITED-TOKEN-LIST))
  (SETQ MATCHP
    (COND ((SYMBOLP PATTERN-ELEMENT)
	   ;; The pattern element is a symbol; matching is judged by EQness.
	   (eq PATTERN-ELEMENT TOKEN))
	  ((FIXP PATTERN-ELEMENT)
	   ;; Match any fixnum of this value, no matter what its length.
	   (OR
	     ;; Detect multi-token fractions of all sorts, plus noise words.
	     (MULTIPLE-VALUE-BIND (FLAG REMAINING EDITED-LIST)
		 (MATCH-FRACTION PATTERN-ELEMENT TOKEN-LIST ENTIRE-TOKEN-LIST)
	       (IF FLAG
		   (SETQ REMAINING-TOKEN-LIST REMAINING
			 EDITED-TOKEN-LIST EDITED-LIST))
	       FLAG)
	     ;; Next possibility: a number made of digits.
	     (AND (LISTP TOKEN)
		  (FIXP (FIRST TOKEN))
		  (= (FIRST TOKEN) PATTERN-ELEMENT))
	     ;; Other possibility: a string number.
	     (AND (SYMBOLP TOKEN)
		  (GET TOKEN 'FIXNUM-STRING)
		  (= (GET TOKEN 'VALUE) PATTERN-ELEMENT))))
	  ((EQ (FIRST PATTERN-ELEMENT) 'FRACTION)
	   (MULTIPLE-VALUE-BIND (FLAG REMAINING EDITED-LIST)
	       (MATCH-FRACTION PATTERN-ELEMENT TOKEN-LIST ENTIRE-TOKEN-LIST
			       (SECOND PATTERN-ELEMENT))
	     (IF FLAG
		 (SETQ REMAINING-TOKEN-LIST REMAINING
		       EDITED-TOKEN-LIST EDITED-LIST))
	     FLAG))
	  ((EQ (FIRST PATTERN-ELEMENT) 'FIXP)
	   ;; Match certain fixnums.
	   (OR
	     ;; Detect multi-token fractions of all sorts, plus noise words.
	     (AND (EQUAL PATTERN-ELEMENT '(FIXP))
		  (MULTIPLE-VALUE-BIND (FLAG REMAINING EDITED-LIST)
		      (MATCH-FRACTION PATTERN-ELEMENT TOKEN-LIST ENTIRE-TOKEN-LIST)
		    (IF FLAG
			(SETQ REMAINING-TOKEN-LIST REMAINING
			      EDITED-TOKEN-LIST EDITED-LIST))
		    FLAG))
	     ;; Next possibility: a number made of digits.
	     (AND (LISTP TOKEN)
		  (FIXP (FIRST TOKEN))
		  (MATCH-NUMBER PATTERN-ELEMENT (SECOND TOKEN)))
	     ;; Other possibility: a string number.
	     (AND (SYMBOLP TOKEN)
		  (GET TOKEN 'FIXNUM-STRING)
		  (MATCH-NUMBER PATTERN-ELEMENT (IF (> (GET TOKEN 'VALUE) 9.) 2 1)))))
	  ((EQ (FIRST PATTERN-ELEMENT) 'ANY)
	   ;; Match any token.
	   T)
	  ((EQ (FIRST PATTERN-ELEMENT) 'ANY-OF)
	   ;; If the TOKEN is any of these things, match.
	   (MEMQ TOKEN (REST1 PATTERN-ELEMENT)))
	  ((EQ (FIRST PATTERN-ELEMENT) 'GET)
	   ;; If TOKEN is a symbol with this property, match.
	   (AND (SYMBOLP TOKEN)
		(GET TOKEN (SECOND PATTERN-ELEMENT))))
	  (T
	   ;; Not a "special" form.  This is a predicate to apply.
	   (FUNCALL (FIRST PATTERN-ELEMENT) TOKEN))))
  (VALUES MATCHP
	  REMAINING-TOKEN-LIST
	  EDITED-TOKEN-LIST))

(DEFUN MATCH-FRACTION (PATTERN-ELEMENT TOKEN-LIST ENTIRE-TOKEN-LIST
		       &OPTIONAL DONT-INCLUDE-FOLLOWING-ARTICLES
		       &AUX (TOKEN (CAR TOKEN-LIST))
		       (REMAINING-TOKEN-LIST (CDR TOKEN-LIST))
		       EDITED-TOKEN-LIST
		       MATCHP (NUMBER-OF-TOKENS 1))
  (DECLARE (VALUES MATCHP REMAINING-TOKEN-LIST EDITED-TOKEN-LIST))
  (OR
    ;; "2.5"
    (AND (LISTP TOKEN)
	 (FIXP (CAR TOKEN))
	 (EQ (SECOND TOKEN-LIST) '/.)
	 (LISTP (THIRD TOKEN-LIST))
	 (FIXP (CAR (THIRD TOKEN-LIST)))
	 (SETQ MATCHP (READ-FROM-STRING
			(FORMAT NIL "~D.~D" (CAR TOKEN) (CAR (THIRD TOKEN-LIST)))))
	 (SETQ NUMBER-OF-TOKENS 3))
    ;; ".5"
    (AND (EQ TOKEN '/.)
	 (LISTP (SECOND TOKEN-LIST))
	 (FIXP (CAR (SECOND TOKEN-LIST)))
	 (SETQ MATCHP (READ-FROM-STRING
			(FORMAT NIL "~D.~D" 0 (CAR (SECOND TOKEN-LIST)))))
	 (SETQ NUMBER-OF-TOKENS 2))
    ;; "2 a half", which is what we get from "2 and a half"
    ;; since "and" is a noise word.
    (AND (LISTP TOKEN)
	 (FIXP (CAR TOKEN))
	 (MULTIPLE-VALUE-BIND (FRACTION REMAINING)
	     (MATCH-FRACTION '(FIXP) (CDR TOKEN-LIST) ENTIRE-TOKEN-LIST
			     DONT-INCLUDE-FOLLOWING-ARTICLES)
	   (IF FRACTION
	       (SETQ MATCHP (+ (CAR TOKEN) FRACTION)
		     NUMBER-OF-TOKENS (LENGTH (LDIFF TOKEN-LIST REMAINING))
		     DONT-INCLUDE-FOLLOWING-ARTICLES T))
	   FRACTION))
    ;; "A half", etc.
    (AND (SYMBOLP TOKEN)
	 (GET TOKEN 'ARTICLE)
	 (SYMBOLP (CADR TOKEN-LIST))
	 (GET (CADR TOKEN-LIST) 'FRACTION)
	 (SETQ MATCHP (GET (CADR TOKEN-LIST) 'VALUE))
	 (SETQ NUMBER-OF-TOKENS 2))
    ;; just "Half".
    (AND (SYMBOLP TOKEN)
	 (GET TOKEN 'FRACTION)
	 (SETQ MATCHP (GET TOKEN 'VALUE))))
  (AND (FIXP PATTERN-ELEMENT)
       MATCHP
       ( PATTERN-ELEMENT MATCHP)
       (SETQ MATCHP NIL))
  ;; Now discard an article or proposition following the fraction, if any.
  ;; "half a", etc.
  (COND ((NOT DONT-INCLUDE-FOLLOWING-ARTICLES)
	 (LET ((TOKEN-AFTER (NTH NUMBER-OF-TOKENS TOKEN-LIST)))
	   (AND (EQ TOKEN-AFTER 'OF)
		(INCF NUMBER-OF-TOKENS)))
	 (LET ((TOKEN-AFTER (NTH NUMBER-OF-TOKENS TOKEN-LIST)))
	   (AND (SYMBOLP TOKEN-AFTER)
		(GET TOKEN-AFTER 'ARTICLE)
		(INCF NUMBER-OF-TOKENS)))))
  ;; Now edit out the tokens we want to replace, if more than one.
  (IF ( NUMBER-OF-TOKENS 1)
      (SETQ REMAINING-TOKEN-LIST (NTHCDR NUMBER-OF-TOKENS TOKEN-LIST)
	    EDITED-TOKEN-LIST
	    (APPEND (LDIFF ENTIRE-TOKEN-LIST TOKEN-LIST)
		    (LIST (LIST MATCHP))
		    REMAINING-TOKEN-LIST)))
  (VALUES MATCHP REMAINING-TOKEN-LIST EDITED-TOKEN-LIST))


;;; Internal function of MATCH-ELEMENT for matching numbers.
(DEFUN MATCH-NUMBER (PATTERN-ELEMENT LENGTH)
  (SELECTQ (LENGTH PATTERN-ELEMENT)
    (1 T)
    (2 (= (SECOND PATTERN-ELEMENT) LENGTH))
    (3 (AND ( (SECOND PATTERN-ELEMENT) LENGTH)
	    ( (THIRD PATTERN-ELEMENT) LENGTH)))))

;;; Call FUNCTION, passing it all the tokens of TOKEN-LIST that were
;;; matched by PATTERN, except the constants.
(DEFUN PATTERN-INVOKE (PATTERN TOKEN-LIST FUNCTION PASS-ARGUMENTS &AUX NARGS)
  (SETQ NARGS (IF (NOT PASS-ARGUMENTS) 0
		  (LOOP FOR X IN PATTERN COUNT (NOT (ATOM X)))))
  (PROG ()
	(%START-FUNCTION-CALL FUNCTION NIL NARGS NIL)
	(IF (NOT PASS-ARGUMENTS) (GO END-LOOP))        ; Don't give it arguments.
     LOOP (COND ((NULL PATTERN)
		 (GO END-LOOP)))
	(COND ((NOT (ATOM (CAR PATTERN)))
	       (%PUSH (CAR TOKEN-LIST))))
	(SETQ PATTERN (CDR PATTERN))
	(SETQ TOKEN-LIST (CDR TOKEN-LIST))
	(GO LOOP)
     END-LOOP
	(%FINISH-FUNCTION-CALL FUNCTION NIL NARGS NIL)
	(RETURN TOKEN-LIST)))

;;; Given a token that represents a number, return the number's value.
(DEFUN NUMBER-VALUE (TOKEN)
  (COND ((AND (LISTP TOKEN)
	      (NUMBERP (FIRST TOKEN)))
	 ;; This is a number token made of digits.
	 (FIRST TOKEN))
	((AND (SYMBOLP TOKEN)
	      (GET TOKEN 'FIXNUM-STRING))
	 ;; This is an English ordinal or cardinal.
	 (GET TOKEN 'VALUE))
	(T (FERROR NIL "The token ~S is not a number at all." TOKEN))))

;;; Keywords.

;;; This stuff runs at LOAD time.  It sets up properties on various interesting
;;; keyword symbols, so that patterns can check for these properties.

;;; The argument is a list of lists.  Each list is a bunch of spellings
;;; of a value, each of which is a string; successive lists have successive values,
;;; starting at FIRST-VALUE.  Each spelling is turned into a symbol, which gets
;;; a VALUE property of the fixnum value, and a <TYPE> property of T.
(DEFUN ASSIGN-TYPE-AND-VALUES (TYPE LIST-OF-LISTS FIRST-VALUE)
  (DO ((REST LIST-OF-LISTS (CDR REST))
       (I FIRST-VALUE (1+ I)))
      ((NULL REST))
    (DOLIST (STRING (CAR REST))
      (IF (STRINGP STRING)			; Don't bash plist of NIL.
	  (LET ((SYMBOL (INTERN (STRING-UPCASE STRING) *TIME-PACKAGE*)))
	    (PUTPROP SYMBOL I 'VALUE)
	    (PUTPROP SYMBOL T TYPE))))))

;;; NOTE: This file must be loaded after the TIME file.
(ASSIGN-TYPE-AND-VALUES 'DAY-OF-THE-WEEK *DAYS-OF-THE-WEEK* 0)
(ASSIGN-TYPE-AND-VALUES 'MONTH *MONTHS* 1)

;;; Take a list of lists of symbols.  Every symbol gets a <type> property
;;; of T and a VALUE property of the first symbol of the list.
(DEFUN ASSIGN-TYPE-AND-VALUES-SYMBOLS (TYPE VALUE-PROP-NAME LIST-OF-LISTS)
  (DOLIST (LIST-OF-SYMBOLS LIST-OF-LISTS)
    (LET ((FIRST-SYMBOL (FIRST LIST-OF-SYMBOLS)))
      (DOLIST (SYMBOL LIST-OF-SYMBOLS)
	(PUTPROP SYMBOL FIRST-SYMBOL VALUE-PROP-NAME)
	(PUTPROP SYMBOL T TYPE)))))

(ASSIGN-TYPE-AND-VALUES-SYMBOLS 'HALF-DAY 'VALUE
 '((NOON N)
   (MIDNIGHT M)))

(ASSIGN-TYPE-AND-VALUES-SYMBOLS 'OFFSET 'OFFSET-VALUE
 '((YEARS YEAR YRS YR Y)
   (MONTHS MONTH MO)
   (WEEKS WEEK WKS WK)
   (DAYS DAY DA DY D)
   (HOURS HOUR HRS HR H)
   (MINUTES MINUTE MINS MIN MN M)
   (SECONDS SECOND SECS SEC SC S)))

;;; Note that the lexical analyzer strips trailing periods off alphabetic tokens.
(ASSIGN-TYPE-AND-VALUES-SYMBOLS 'MERIDIEM 'VALUE
 '((AM |A.M.| |A.M|)
   (PM |P.M.| |P.M|)))

(DEFUN ASSIGN-TIME-ZONES ()
  (DOLIST (ZONE-SPEC *TIMEZONES*)
    (LET ((VALUE (FIRST ZONE-SPEC)))
      (IF (NOT (NULL (SECOND ZONE-SPEC)))
	  (ASSIGN-ZONE (SECOND ZONE-SPEC) VALUE))
      (IF (NOT (NULL (THIRD ZONE-SPEC)))
	  (ASSIGN-ZONE (THIRD ZONE-SPEC) VALUE))
      (IF (CHARACTERP (FOURTH ZONE-SPEC))
	  (ASSIGN-ZONE (STRING (FOURTH ZONE-SPEC)) VALUE)))))

(DEFUN ASSIGN-ZONE (STRING VALUE)
  (IF (STRINGP STRING)				; Don't bash plist of NIL.
      (LET ((SYMBOL (INTERN STRING *TIME-PACKAGE*)))
	(PUTPROP SYMBOL VALUE 'ZONE-VALUE)	; Can't use VALUE: N and M are half-days too!
	(PUTPROP SYMBOL T 'TIME-ZONE))))

(ASSIGN-TIME-ZONES)
(ASSIGN-ZONE "UT" 0)

(PUTPROP '- T 'SIGN)
(PUTPROP '+ T 'SIGN)

;;; Cardinal and ordinal numbers.
(DEFUN ASSIGN-NUMBERS ()
  (DOTIMES (I 32.)
    (ASSIGN-NUMBER I (INTERN (STRING-UPCASE (FORMAT NIL "~:R" I)) *TIME-PACKAGE*))
    (ASSIGN-NUMBER I (INTERN (STRING-UPCASE (FORMAT NIL "~R" I)) *TIME-PACKAGE*)))
  ;; Sixty is a useful number to have around
  (ASSIGN-NUMBER 60. (INTERN (STRING-UPCASE (FORMAT NIL "~:R" 60.)) *TIME-PACKAGE*))
  (ASSIGN-NUMBER 60. (INTERN (STRING-UPCASE (FORMAT NIL "~R" 60.)) *TIME-PACKAGE*)))

(DEFUN ASSIGN-NUMBER (NUMBER SYMBOL)
  (PUTPROP SYMBOL T 'FIXNUM-STRING)
  (PUTPROP SYMBOL NUMBER 'VALUE))

(ASSIGN-NUMBERS)

;;; Make indefinite articles work, so that "a minute" and "an hour" will be accepted.
(ASSIGN-NUMBER 1 'A)
(ASSIGN-NUMBER 1 'AN)

;;; Make "a half" and "half a" work in MATCH-ELEMENT.
(DEFPROP A T ARTICLE)
(DEFPROP AN T ARTICLE)
(DEFPROP ONE T ARTICLE)
(DEFPROP HALF T FRACTION)
(DEFPROP QUARTER T FRACTION)
(ASSIGN-NUMBER .5 'HALF)
(ASSIGN-NUMBER .25 'QUARTER)

;;; German numbers.
(IF (GET ':GERMAN 'SI:PRINC-FUNCTION)
    (ASSIGN-GERMAN-NUMBERS))

(DEFUN ASSIGN-GERMAN-NUMBERS ()
  (LET ((BASE ':GERMAN))
    (DOTIMES (I 32.)
      (ASSIGN-NUMBER I (INTERN (STRING-UPCASE (FORMAT NIL "~S" I)) *TIME-PACKAGE*)))
    (ASSIGN-NUMBER 60. (INTERN (STRING-UPCASE (FORMAT NIL "~S" 60.)) *TIME-PACKAGE*))))


;;; The patterns.

;;; Buzz words.
(DEFCONST *NOISE-WORDS* '(THE AND AT ST ND RD TH /;))

(START-PATTERNS)

;; This format is what UNIX mail uses.  It's so bizarre I'm not even going to
;; try to integrate it with everything else; just check for exactly this. --RWK

(DEFPATTERN MAIN ((GET DAY-OF-THE-WEEK) (GET MONTH) (FIXP 1 2)
		  (FIXP 1 2) /: (FIXP 2) /: (FIXP 2) (FIXP 4)) MAIN
	    (DAY-OF-THE-WEEK MONTH DATE HOUR MINUTE SECOND YEAR)
   (SET-DAY-OF-THE-WEEK DAY-OF-THE-WEEK)
   (SET-MONTH-FROM-NAME MONTH)
   (SET-DATE DATE)
   (SET-HOUR HOUR)
   (SET-MINUTE MINUTE)
   (SET-SECOND SECOND)
   (SET-YEAR YEAR))

;;; 3-Jan-80 means Jan 3, 1980.  Put this one early for efficiency.
(DEFPATTERN MAIN ((FIXP 1 2) - (GET MONTH) - (FIXP 2)) MAIN
	    (DATE MONTH YEAR-OF-CENTURY)
  (SET-DATE DATE)
  (SET-MONTH-FROM-NAME MONTH)
  (SET-YEAR-OF-CENTURY YEAR-OF-CENTURY))

;;; 3/15/80 means March 15, 1980.  15/3/80 means March 15, 1980 to a European.
;;; If both the numbers are small, an ambuguity must be dealt with.
(DEFPATTERN MAIN ((FIXP 1 2) // (FIXP 1 2) // (FIXP 2)) MAIN
	    (MONTH DATE YEAR-OF-CENTURY)
  (SET-MONTH-AND-DATE MONTH DATE)
  (SET-YEAR-OF-CENTURY YEAR-OF-CENTURY))

;;; 11:30 means 11 hours and 30 minutes, go look for seconds.
(DEFPATTERN MAIN ((FIXP 1 2) /: (FIXP 2)) SECOND
	    (HOUR MINUTE)
  (SET-HOUR HOUR)
  (SET-MINUTE MINUTE))

;;; March 15 means March 15; go look for a year preceeded by a comma.
(DEFPATTERN MAIN ((GET MONTH) (FIXP 1 2)) YEAR-COMMA
	    (MONTH DATE)
  (SET-MONTH-FROM-NAME MONTH)
  (SET-DATE DATE))

;;; 15 March means March 15; go look for a year.
(DEFPATTERN MAIN ((FIXP 1 2) (GET MONTH)) YEAR-COMMA
	    (DATE MONTH)
  (SET-DATE DATE)
  (SET-MONTH-FROM-NAME MONTH))

;;; The fifteenth of march
(DEFPATTERN MAIN ((FIXP 1 2) OF (GET MONTH)) YEAR-COMMA
	    (DATE MONTH)
  (SET-DATE DATE)
  (SET-MONTH-FROM-NAME MONTH))

;;; 3/15/1980 means March 15, 1980.  Same European problem.
(DEFPATTERN MAIN ((FIXP 1 2) // (FIXP 1 2) // (FIXP 4)) MAIN
	    (MONTH DATE YEAR)
  (SET-MONTH-AND-DATE MONTH DATE)
  (SET-YEAR YEAR))

;;; 3/15 means March 15, year defaults.  Same European problem.
(DEFPATTERN MAIN ((FIXP 1 2) // (FIXP 1 2)) MAIN
	    (MONTH DATE)
  (SET-MONTH-AND-DATE MONTH DATE))

;;; Note: GDixon's convert_date_to_binary_.rd believes in YY-MM-DD; the code
;;; below believes in MM-DD-YY.  RFC733 does not allow numeric months at all.
;;; Three cheers for RFC733!

;;; 3-15-80 means March 15, 1980.  Same European problem.
(DEFPATTERN MAIN ((FIXP 1 2) - (FIXP 1 2) - (FIXP 2)) MAIN
	    (MONTH DATE YEAR-OF-CENTURY)
  (SET-MONTH-AND-DATE MONTH DATE)
  (SET-YEAR-OF-CENTURY YEAR-OF-CENTURY))

;;; 3-15-1980 means March 15, 1980.  Same European problem.
(DEFPATTERN MAIN ((FIXP 1 2) - (FIXP 1 2) - (FIXP 4)) MAIN
	    (MONTH DATE YEAR)
  (SET-MONTH-AND-DATE MONTH DATE)
  (SET-YEAR YEAR))

;;; 1980-3-15 means March 15, 1980.
(DEFPATTERN MAIN ((FIXP 4) - (FIXP 1 2) - (FIXP 1 2)) MAIN
	    (YEAR MONTH DATE)
  (SET-MONTH MONTH)
  (SET-DATE DATE)
  (SET-YEAR YEAR))

;;; 3-15 means March 15, year defaults.  Same European problem.
(DEFPATTERN MAIN ((FIXP 1 2) - (FIXP 1 2)) MAIN
	    (MONTH DATE)
  (SET-MONTH-AND-DATE MONTH DATE))

;;; Jan-3-80 means Jan 3, 1980.
(DEFPATTERN MAIN ((GET MONTH) - (FIXP 1 2) - (FIXP 2)) MAIN
	    (MONTH DATE YEAR-OF-CENTURY)
  (SET-MONTH-FROM-NAME MONTH)
  (SET-DATE DATE)
  (SET-YEAR-OF-CENTURY YEAR-OF-CENTURY))

;;; Jan-3-1980 means Jan 3, 1980.
(DEFPATTERN MAIN ((GET MONTH) - (FIXP 1 2) - (FIXP 4)) MAIN
	    (MONTH DATE YEAR)
  (SET-MONTH-FROM-NAME MONTH)
  (SET-DATE DATE)
  (SET-YEAR YEAR))

;;; 3-Jan-1980 means Jan 3, 1980.
(DEFPATTERN MAIN ((FIXP 1 2) - (GET MONTH) - (FIXP 4)) MAIN
	    (DATE MONTH YEAR)
  (SET-DATE DATE)
  (SET-MONTH-FROM-NAME MONTH)
  (SET-YEAR YEAR))

;;; 1980-MAR-15 means March 15, 1980.
(DEFPATTERN MAIN ((FIXP 4) - (GET MONTH) - (FIXP 1 2)) MAIN
	    (YEAR MONTH DATE)
  (SET-MONTH-FROM-NAME MONTH)
  (SET-DATE DATE)
  (SET-YEAR YEAR))

;;; 1130.4 means 11 hours and 30.4 minutes, in Multics internal headers,
;;; which Zmail sometimes actually sees.  (I think this happens when
;;; a QSEND from Multics turns into mail.)
(DEFPATTERN MAIN ((FIXP 4) /. (FIXP 1)) MAIN
	    (HHMM TENTHS-OF-MINUTES)
  (SET-HHMM HHMM)
  (SET-TENTHS-OF-MINUTE TENTHS-OF-MINUTES))

;;; 1130. means 11 hours and 30 minutes and zero seconds.
(DEFPATTERN MAIN ((FIXP 4) /.) MAIN
	    (HHMM)
  (SET-HHMM HHMM))

;;; 1130 PM means 11 hours and 30 minutes and zero seconds, P.M.
(DEFPATTERN MAIN ((FIXP 4) (GET MERIDIEM)) MAIN
	    (HHMM MERIDIEM)
  (SET-HHMM HHMM)
  (SET-MERIDIEM MERIDIEM))

;;; 1130 means 11 hours and 30 minutes and zero seconds.
;;; 1985 means the year 1985.
;;; Heuristicate as best we can.
(DEFPATTERN MAIN ((FIXP 4)) MAIN
	    (NUM)
  (SET-HHMM-OR-YEAR NUM))

;;; 19850401-2251 means 10:51 PM April 1 1985 on some BITNET machines.
(DEFPATTERN MAIN ((FIXP 8) - (FIXP 4)) MAIN
	    (YYYYMMDD HHMM)
  (SET-HHMM HHMM)
  (SET-YYYYMMDD YYYYMMDD))

;;; 113015 means 11 hours, 30 minutes and 15 seconds.
(DEFPATTERN MAIN ((FIXP 6)) MAIN
	    (HHMMSS)
  (SET-HHMMSS HHMMSS))

;;; Looking for seconds, :23 means 23 seconds, look for AM/PM.
;;; .23 works too; this is a European form.
(DEFPATTERN SECOND ((ANY-OF /: /.) (FIXP 1 2)) MERIDIEM
	    (IGNORE SECOND)
  (SET-SECOND SECOND))

;;; Looking for seconds, not finding them, look for AM/PM.
(DEFPATTERN SECOND () MERIDIEM
	    ()
  (SET-SECOND '(0 2)))

;;; Looking for meridiem, AM means AM and PM means PM, go back to main state.
(DEFPATTERN MERIDIEM ((GET MERIDIEM)) MAIN
	    (MERIDIEM)
  (SET-MERIDIEM MERIDIEM))

;;; Looking for meridiem, not finding it, go back to main state.
(DEFPATTERN MERIDIEM () MAIN
	    ()
  )

;;; 4 PM means what you would think.
(DEFPATTERN MAIN ((FIXP 1 2) (GET MERIDIEM)) MAIN
	    (HOUR MERIDIEM)
  (SET-HOUR HOUR)
  (SET-MERIDIEM MERIDIEM)
  (SET-MINUTE '(0 2))
  (SET-SECOND '(0 2)))

;;; Day of the week, as in "Friday, Jan 5"
(DEFPATTERN MAIN ((GET DAY-OF-THE-WEEK) /,) MAIN
	    (DAY-OF-THE-WEEK)
  (SET-DAY-OF-THE-WEEK DAY-OF-THE-WEEK))

;;; Day of the week.
(DEFPATTERN MAIN ((GET DAY-OF-THE-WEEK)) MAIN
	    (DAY-OF-THE-WEEK)
  (SET-DAY-OF-THE-WEEK DAY-OF-THE-WEEK))

;;; These patterns inserted by CAL 10/24/80

;;; "today"
(DEFPATTERN MAIN (TODAY) MAIN
	    ()
  (SET-TODAY))

;;; "yesterday"
(DEFPATTERN MAIN (YESTERDAY) MAIN
	    ()
  (SET-YESTERDAY))

;;; "tomorrow"
(DEFPATTERN MAIN (TOMORROW) MAIN
	    ()
  (SET-TOMORROW))

;;; "now"
(DEFPATTERN MAIN (NOW) MAIN
	    ()
  (SET-NOW))

;;; "2 days before jan 30"
(DEFPATTERN MAIN ((FIXP) (GET OFFSET) BEFORE) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-OFFSET '- OFFSET-VALUE OFFSET-UNITS))

;;; "2 minutes past"
(DEFPATTERN MAIN ((FIXP) (GET OFFSET) PAST) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-OFFSET '+ OFFSET-VALUE OFFSET-UNITS))

;;; "half past"
(DEFPATTERN MAIN ((FRACTION) PAST) MAIN
	    (HOUR-VALUE)
  (SET-OFFSET '+ HOUR-VALUE 'HOURS))

;;; "20 past"
(DEFPATTERN MAIN ((FIXP) PAST) MAIN
	    (MINUTE-VALUE)
  (SET-OFFSET '+ MINUTE-VALUE 'MINUTES))

(DEFPROP OF T OF-OR-TO)
(DEFPROP TO T OF-OR-TO)

;;; "2 minutes of"
(DEFPATTERN MAIN ((FIXP) (GET OFFSET) (GET OF-OR-TO)) MAIN
	    (OFFSET-VALUE OFFSET-UNITS IGNORE)
  (SET-OFFSET '- OFFSET-VALUE OFFSET-UNITS))

;;; "a quarter of"
(DEFPATTERN MAIN ((FRACTION T) (GET OF-OR-TO)) MAIN
	    (HOUR-VALUE IGNORE)
  (SET-OFFSET '- HOUR-VALUE 'HOURS))

;;; "20 of"
(DEFPATTERN MAIN ((FIXP) (GET OF-OR-TO)) MAIN
	    (MINUTE-VALUE IGNORE)
  (SET-OFFSET '- MINUTE-VALUE 'MINUTES))

;;; "The day before yesterday" or "day before yesterday"
(DEFPATTERN MAIN ((GET OFFSET) BEFORE) MAIN
	    (OFFSET-UNITS)
  (SET-OFFSET '- '(1 1) OFFSET-UNITS))

;;; "2 days after jan 15"
(DEFPATTERN MAIN ((FIXP) (GET OFFSET) AFTER) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-OFFSET '+ OFFSET-VALUE OFFSET-UNITS))

;;; "The day after jan 15", "day after tomorrow"
(DEFPATTERN MAIN ((GET OFFSET) AFTER) MAIN
	    (OFFSET-UNITS)
  (SET-OFFSET '+ '(1 1) OFFSET-UNITS))

;;; "5 minutes from now"
(DEFPATTERN MAIN ((FIXP) (GET OFFSET) FROM) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-OFFSET '+ OFFSET-VALUE OFFSET-UNITS))

;;; "3 days ago" or "3 minutes ago" or whatever
(DEFPATTERN MAIN ((FIXP) (GET OFFSET) AGO) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-NOW)
  (SET-OFFSET '- OFFSET-VALUE OFFSET-UNITS))

(DEFPATTERN MAIN ((FIXP) (GET OFFSET) HENCE) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-NOW)
  (SET-OFFSET '+ OFFSET-VALUE OFFSET-UNITS))
  
;;; "dlw's birthday"
(DEFPATTERN MAIN ((ANY) S BIRTHDAY) MAIN
	      (NAME)
  (SET-BIRTHDAY NAME))

;;; KMP@MC's birthday
(DEFPATTERN MAIN ((ANY) /@ (ANY) S BIRTHDAY) MAIN
	    (NAME HOST)
  (SET-BIRTHDAY NAME HOST))

;;; "my birthday"
(DEFPATTERN MAIN (MY BIRTHDAY) MAIN
	    ()
  (SET-BIRTHDAY SI:*USER*))

;;; 11.30 works like 11:30; this is a European form.
(DEFPATTERN MAIN ((FIXP 1 2) /. (FIXP 2)) SECOND
	    (HOUR MINUTE)
  (SET-HOUR HOUR)
  (SET-MINUTE MINUTE))

;;; Ed says that Agatha Christie books use 11.3 to mean 11:30:00, also.
(DEFPATTERN MAIN ((FIXP 1 2) /. (FIXP 1)) SECOND
	    (HOUR TENS-OF-MINUTES)
  (SET-HOUR HOUR)
  (SET-TENS-OF-MINUTES TENS-OF-MINUTES))

;;; 12 Noon and friends.
;;; This must follow "3 minutes from ...", which includes "12 m from ...".
(DEFPATTERN MAIN (12. (GET HALF-DAY)) MAIN
 	    (HALF-DAY)
  (SET-HALF-DAY HALF-DAY))

;;; Noon and friends.
(DEFPATTERN MAIN ((GET HALF-DAY)) MAIN
	    (HALF-DAY)
  (SET-HALF-DAY HALF-DAY))


;;; - 3 minutes
(DEFPATTERN MAIN ((GET SIGN) (FIXP) (GET OFFSET)) MAIN
	    (SIGN OFFSET-VALUE OFFSET-UNITS)
  (SET-OFFSET SIGN OFFSET-VALUE OFFSET-UNITS))

;;; 3 minutes or 3 hours or whatever
;;; *default-rel-sign* is set to '- for "ago", '+ otherwise
(DEFPATTERN MAIN ((FIXP) (GET OFFSET)) MAIN
	    (OFFSET-VALUE OFFSET-UNITS)
  (SET-OFFSET *DEFAULT-REL-SIGN* OFFSET-VALUE OFFSET-UNITS))

;;; This must follow all other MAIN patterns that have a FIXP as the first token.
;;; This pattern can be invoked by either "86 Sept 2" or "The 14th" (of this month)
(DEFPATTERN MAIN ((FIXP 1 2)) MAIN
	    (YEAR-OR-DATE)
  (SET-YEAR-OF-CENTURY-OR-DATE YEAR-OR-DATE))

;;; Time zones
(DEFPATTERN MAIN ((GET TIME-ZONE)) MAIN
	    (TIME-ZONE)
  (SET-TIME-ZONE TIME-ZONE))

;;; Time zones preceeded by a hyphen
(DEFPATTERN MAIN (- (GET TIME-ZONE)) MAIN
	    (TIME-ZONE)
  (SET-TIME-ZONE TIME-ZONE))


;;;The printed representation of timezones is exactly the oposite of our
;;;internal representation, e.g. if our local timezone were printed as -0500
;;;then *timezone* would be +5.
(DEFUN SET-TIME-ZONE-FROM-NUMBER (NUMBER)
  (WHEN (NOT (NULL *ABS-TIME-ZONE*))
    (BARF "Time zone specified twice."))
  (SETQ *ABS-TIME-ZONE*
	(- (LET* ((MINUTES (\ NUMBER 100.))
		  (ZONE (// NUMBER 100.)))
	     (COND ((> (ABS ZONE) 24.)
		    (BARF "Time zone hours out of range."))
		   ((> (ABS MINUTES) 59.)
		    (BARF "Time zone minutes out of range."))
		   ((ZEROP MINUTES)
		    ZONE)
		   (T
		    (+ ZONE (// (FLOAT MINUTES) 60.))))))))


(DEFPATTERN MAIN (+ (FIXP 4)) MAIN
	    (TIME-ZONE)
  (SET-TIME-ZONE-FROM-NUMBER (NUMBER-VALUE TIME-ZONE)))

(DEFPATTERN MAIN (- (FIXP 4)) MAIN
	    (TIME-ZONE)
  (SET-TIME-ZONE-FROM-NUMBER (- (NUMBER-VALUE TIME-ZONE))))

(DEFPATTERN MAIN (CHRISTMAS) MAIN
	    ()
	    (SET-CHRISTMAS))

(DEFPATTERN MAIN (HALLOWEEN) MAIN
	    ()
	    (SET-HALLOWEEN))

(DEFPATTERN MAIN (NEW YEARS) MAIN
	    ()
	    (SET-NEW-YEARS))

(DEFPATTERN MAIN (NEW YEARS DAY) MAIN
	    ()
	    (SET-NEW-YEARS))

;;; If we encounter random commas in MAIN state, we have to just ignore them
;;; in order to win in such cases as "Thursday, 21 May 1981, 00:27-EDT"
(DEFPATTERN MAIN (/,) MAIN
	    ()
  )

;;; Handle a general time followed by FROM (or something like it)
;;; and another time.
(DEFPROP FROM + DIRECTION)
(DEFPROP AFTER + DIRECTION)
(DEFPROP BEFORE - DIRECTION)
(DEFPROP TILL - DIRECTION)
(DEFPROP TO - DIRECTION)

(DEFPATTERN MAIN ((GET DIRECTION)) MAIN
	    (DIRECTION)
	    (MOVE-ABS-TO-OFFSET (GET DIRECTION 'DIRECTION)))

;;; Anything else
(DEFPATTERN MAIN ((ANY)) MAIN
	    (TOKEN)
  (BARF "Unrecognized date//time format, starting with token ~A." TOKEN))

;;; If nothing is left and we are in MAIN state, that is the end.
(PUTPROP 'MAIN 'T 'FINAL-STATE)

(DEFPATTERN YEAR-COMMA (/,) YEAR
	    ()
  )

;;; If there isn't a comma, go look for the regular kinds of years.
(DEFPATTERN YEAR-COMMA () YEAR
	    ()
  )

;;; We are now in the state of looking for a year.  If we see a number,
;;; that may be a year or it may be the start of something else.  For
;;; example, "6 Jan 59" versus "6 Jan 59 minutes" or "6 Jan 3:23:12".
;;; So we have to look ahead for various possibilities and return to
;;; the main state if any of them are happening.  Otherwise, a number
;;; gets interpreted as a year in this context.
(DEFPATTERN-PEEK YEAR ((FIXP) /.) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR ((FIXP) //) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR ((FIXP) /:) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR ((FIXP) (GET MERIDIEM)) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR (12. (GET HALF-DAY)) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR ((GET SIGN) (FIXP) (GET OFFSET)) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR ((FIXP) (GET OFFSET)) MAIN
		 ()
  )

(DEFPATTERN-PEEK YEAR ((FIXP) (GET MONTH)) MAIN
		 ()
  (BARF "Date and month seen where year expected."))

;;; Finally, there is no other way to interpret the number.  If there
;;; is a number it must be a year.
(DEFPATTERN YEAR ((FIXP)) MAIN
	    (YEAR)
  (SET-YEAR YEAR))

;;; Not a number at all.
(DEFPATTERN YEAR () MAIN
	    ()
  )

;;; This is the end of the patterns.  Don't add new ones after this!
(FINISH-PATTERNS)

;;; Special variables.

;;; These variables hold the time values found in the string.  NIL means
;;; that no such value has been seen yet.

;;; Absolute values.
(DEFVAR *ABS-YEAR*)
(DEFVAR *ABS-MONTH*)
(DEFVAR *ABS-DATE*)
(DEFVAR *ABS-HOUR*)
(DEFVAR *ABS-MINUTE*)
(DEFVAR *ABS-SECOND*)
(DEFVAR *ABS-DAY-OF-THE-WEEK*)
(DEFVAR *ABS-TIME-ZONE*)

;;; Relative values, from offsets.
(DEFVAR *REL-YEAR*)
(DEFVAR *REL-MONTH*)
(DEFVAR *REL-DATE*)
(DEFVAR *REL-HOUR*)
(DEFVAR *REL-MINUTE*)
(DEFVAR *REL-SECOND*)
(DEFVAR *REL-DAY-OF-THE-WEEK*)
;(DEFVAR *REL-TIME-ZONE*)

;;; Values of the "base" time.
(DEFVAR *BASE-YEAR*)
(DEFVAR *BASE-MONTH*)
(DEFVAR *BASE-DATE*)
(DEFVAR *BASE-HOUR*)
(DEFVAR *BASE-MINUTE*)
(DEFVAR *BASE-SECOND*)

(DEFVAR *RELATIVE-P*)

;;; Action functions.

;;; These are the functions invoked by the bodies of the DEFPATTERNs.

(DEFUN SET-MONTH-FROM-NAME (MONTH)
  (IF (NOT (NULL *ABS-MONTH*))
      (BARF "Month specified twice."))
  (SETQ *ABS-MONTH* (GET MONTH 'VALUE)))

(DEFUN SET-MONTH (MONTH)
  (IF (NOT (NULL *ABS-MONTH*))
      (BARF "Month specified twice."))
  (SETQ *ABS-MONTH* (NUMBER-VALUE MONTH)))

(DEFUN SET-DATE (DATE)
  (IF (NOT (NULL *ABS-DATE*))
      (BARF "Date specified twice."))
  (SETQ *ABS-DATE* (NUMBER-VALUE DATE)))

;;;--- Old version flushed 4/24/84 243.650
;;; Here we have to deal with the incompatibility betweeen U.S. and European
;;; date format.  If either number is greater than 12., then that number
;;; cannot be the month and so must be the date.  Otherwise, default based
;;; on the location of the machine.
;(DEFUN SET-MONTH-AND-DATE (FIRST SECOND)
;  (SETQ FIRST (NUMBER-VALUE FIRST) SECOND (NUMBER-VALUE SECOND))
;  (COND ((> FIRST 12.)
;	 (SETQ *ABS-MONTH* SECOND *ABS-DATE* FIRST))
;	((> SECOND 12.)
;	 (SETQ *ABS-MONTH* FIRST *ABS-DATE* SECOND))
;	((MEMQ *TIMEZONE* '(1 0 -1 -2 -3 -4 -5))
;	 ;; Europe, kind of.  (Soneone should check a map, and find out
;	 ;; how the Soviet write dates, when we enter that market...)
;	 (SETQ *ABS-MONTH* SECOND *ABS-DATE* FIRST))
;	(T
;	 ;; Patriotic American date format.
;	 (SETQ *ABS-MONTH* FIRST *ABS-DATE* SECOND))))

(DEFUN SET-MONTH-AND-DATE (FIRST SECOND)
  (SETQ FIRST (NUMBER-VALUE FIRST) SECOND (NUMBER-VALUE SECOND))
  (SETQ *ABS-MONTH* FIRST *ABS-DATE* SECOND))

;;; This version takes a fixnum, rather than a two-list.
(DEFUN SET-YEAR-INTERNAL (YEAR)
  (WHEN *ABS-YEAR*
    (BARF "Year specified twice."))
  (SETQ *ABS-YEAR* YEAR))

(DEFUN SET-YEAR (YEAR)
  (SET-YEAR-INTERNAL (NUMBER-VALUE YEAR)))


;;; Modified to default century as suggested by CLtL, rather than like
;;; Multics by ptw 5/10/90
(DEFUN SET-YEAR-OF-CENTURY (YEAR-OF-CENTURY)
  (SET-YEAR-INTERNAL
    (LET ((YEAR (NUMBER-VALUE YEAR-OF-CENTURY))
	  (THIS-YEAR (1- (CLI::GET-CURRENT-YEAR-FOR-DEFAULTING))))
      (MULTIPLE-VALUE-BIND (NIL RESIDUE)
	  (ROUND (- THIS-YEAR YEAR) 100)
	(- THIS-YEAR RESIDUE)))))

(DEFUN SET-HHMM-OR-YEAR (HHMM-OR-YEAR)
  (IF (< (MOD (NUMBER-VALUE HHMM-OR-YEAR) 100.) 60.)
      (SET-HHMM HHMM-OR-YEAR)
      (SET-YEAR HHMM-OR-YEAR)))

(DEFUN SET-YEAR-OF-CENTURY-OR-DATE (YEAR-OR-DATE)
  (IF ( (NUMBER-VALUE YEAR-OR-DATE) 31.)
      (SET-DATE YEAR-OR-DATE)
      (SET-YEAR-OF-CENTURY YEAR-OR-DATE)))

(DEFUN SET-YYYYMMDD (DATE)
  (WHEN *ABS-YEAR*
    (BARF "Year specified twice."))
  (WHEN *ABS-MONTH*
    (BARF "Month specified twice."))
  (WHEN *ABS-DATE*
    (BARF "Date specified twice."))
  (SETQ DATE (NUMBER-VALUE DATE)
	*ABS-YEAR* (// DATE 10000.)
	DATE (- DATE (* *ABS-YEAR* 10000.))
	*ABS-MONTH* (// DATE 100.)
	*ABS-DATE* (- DATE (* *ABS-MONTH* 100.))))
	

(DEFUN SET-HHMM (TIME)
  (WHEN *ABS-HOUR*
    (BARF "Hour specified twice."))
  (WHEN *ABS-MINUTE*
    (BARF "Minute specified twice."))
  (SETQ TIME (NUMBER-VALUE TIME)
	*ABS-HOUR* (// TIME 100.)
	*ABS-MINUTE* (\ (FIX TIME) 100.)))

(DEFUN SET-HHMMSS (TIME)
  (WHEN *ABS-HOUR*
    (BARF "Hour specified twice."))
  (WHEN *ABS-MINUTE*
    (BARF "Minute specified twice."))
  (WHEN *ABS-SECOND*
    (BARF "Second specified twice."))
  (SETQ TIME (NUMBER-VALUE TIME)
	*ABS-HOUR* (// TIME 10000.)
	TIME (- TIME (* *ABS-HOUR* 10000.))
	*ABS-MINUTE* (// TIME 100.)
	*ABS-SECOND* (\ (FIX TIME) 100.)))

(DEFUN SET-HOUR (HOUR)
  (IF (NOT (NULL *ABS-HOUR*))
      (BARF "Hour specified twice."))
  (SETQ *ABS-HOUR* (NUMBER-VALUE HOUR)))

(DEFUN SET-MINUTE (MINUTE)
  (IF (NOT (NULL *ABS-MINUTE*))
      (BARF "Minute specified twice."))
  (SETQ *ABS-MINUTE* (NUMBER-VALUE MINUTE)))

(DEFUN SET-TENS-OF-MINUTES (TENS-OF-MINUTES)
  (IF (NOT (NULL *ABS-MINUTE*))
      (BARF "Minute specified twice."))
  (SETQ *ABS-MINUTE* (* 10. (NUMBER-VALUE TENS-OF-MINUTES))))

(DEFUN SET-SECOND (SECOND)
  (IF (NOT (NULL *ABS-SECOND*))
      (BARF "Second specified twice."))
  (SETQ *ABS-SECOND* (NUMBER-VALUE SECOND)))

(DEFUN SET-TENTHS-OF-MINUTE (TENTHS)
  (IF (NOT (NULL *ABS-SECOND*))
      (BARF "Second specified twice."))
  (SETQ *ABS-SECOND* (* 6 (NUMBER-VALUE TENTHS))))

(DEFUN SET-MERIDIEM (MERIDIEM)
  (IF (OR (NOT (NUMBERP *ABS-HOUR*))
	  (< *ABS-HOUR* 0.)
	  (> *ABS-HOUR* 12.))
      (BARF "Meridiem value ~A seen in bad context." MERIDIEM))
  (SETQ *ABS-HOUR*
	(IF (EQ (GET MERIDIEM 'VALUE) 'PM)
	    (IF (= *ABS-HOUR* 12.) 12. (+ *ABS-HOUR* 12.))
	    (IF (= *ABS-HOUR* 12.) 0 *ABS-HOUR*))))

(DEFUN SET-HALF-DAY (HALF-DAY)
  (IF (NOT (NULL *ABS-SECOND*))
      (BARF "Second specified twice, by the half-day value /"~A/"." HALF-DAY))
  (IF (NOT (NULL *ABS-HOUR*))
      (BARF "Hour specified twice, by the half-day value /"~A/"." HALF-DAY))
  (IF (NOT (NULL *ABS-MINUTE*))
      (BARF "Minute specified twice, by the half-day value /"~A/"." HALF-DAY))
  (SETQ *ABS-HOUR* (IF (EQ (GET HALF-DAY 'VALUE) 'NOON)
		       12.
		       0.)
	*ABS-MINUTE* 0
	*ABS-SECOND* 0))

(DEFUN SET-DAY-OF-THE-WEEK (DAY-OF-THE-WEEK)
  (IF (NOT (NULL *ABS-DAY-OF-THE-WEEK*))
      (BARF "Day of the week specified twice."))
  (SETQ *ABS-DAY-OF-THE-WEEK* (GET DAY-OF-THE-WEEK 'VALUE)))

(DEFUN SET-TIME-ZONE (TIME-ZONE)
  (IF (NOT (NULL *ABS-TIME-ZONE*))
      (BARF "Time zone specified twice."))
  (SETQ *ABS-TIME-ZONE* (GET TIME-ZONE 'ZONE-VALUE)))

(DEFUN SET-OFFSET (SIGN VALUE UNITS)
  (LET ((VALUE (* (NUMBER-VALUE VALUE) (IF (EQ SIGN '+) 1. -1.))))
    (SELECTQ (GET UNITS 'OFFSET-VALUE)
      (YEARS (SETQ *REL-YEAR* (+ *REL-YEAR* VALUE)))
      (MONTHS (SETQ *REL-MONTH* (+ *REL-MONTH* VALUE)))
      (WEEKS (SETQ *REL-DATE* (+ *REL-DATE* (* 7 VALUE))))
      (DAYS (SETQ *REL-DATE* (+ *REL-DATE* VALUE)))
      (HOURS (SETQ *REL-HOUR* (+ *REL-HOUR* VALUE)))
      (MINUTES (SETQ *REL-MINUTE* (+ *REL-MINUTE* VALUE)))
      (SECONDS (SETQ *REL-SECOND* (+ *REL-SECOND* VALUE)))
      (OTHERWISE (BARF "Bad units" UNITS)))))

;;; Used in handling "2:30 from now".
;;; Turn the time we have so far into an offset,
;;; and clear out the absolute time.
(DEFUN MOVE-ABS-TO-OFFSET (SIGN)
  (AND *ABS-YEAR* (SETQ *REL-YEAR* (FUNCALL SIGN (OR *REL-YEAR* 0) *ABS-YEAR*)))
  (AND *ABS-MONTH* (SETQ *REL-MONTH* (FUNCALL SIGN (OR *REL-MONTH* 0) *ABS-MONTH*)))
  (AND *ABS-DATE* (SETQ *REL-DATE* (FUNCALL SIGN (OR *REL-DATE* 0) *ABS-DATE*)))
  (AND *ABS-HOUR* (SETQ *REL-HOUR* (FUNCALL SIGN (OR *REL-HOUR* 0) *ABS-HOUR*)))
  (AND *ABS-MINUTE*
       (SETQ *REL-MINUTE* (FUNCALL SIGN (OR *REL-MINUTE* 0) *ABS-MINUTE*)))
  (AND *ABS-SECOND*
       (SETQ *REL-SECOND* (FUNCALL SIGN (OR *REL-SECOND* 0) *ABS-SECOND*)))
  (SETQ *ABS-YEAR* NIL
	*ABS-MONTH* NIL
	*ABS-DATE* NIL
	*ABS-HOUR* NIL
	*ABS-MINUTE* NIL
	*ABS-SECOND* NIL)
  (SETQ *RELATIVE-P* ':RELATIVE))

(DEFUN SET-TODAY ()
  (SETQ *ABS-DATE* *BASE-DATE*)
  (SETQ *ABS-MONTH* *BASE-MONTH*)
  (SETQ *ABS-YEAR* *BASE-YEAR*)
  (SETQ *RELATIVE-P* ':RELATIVE))

(DEFUN SET-YESTERDAY ()
  (SETQ *ABS-DATE* *BASE-DATE*)
  (SETQ *REL-DATE* (1- *REL-DATE*))
  (SETQ *ABS-MONTH* *BASE-MONTH*)
  (SETQ *ABS-YEAR* *BASE-YEAR*)
  (SETQ *RELATIVE-P* ':RELATIVE))

(DEFUN SET-TOMORROW ()
  (SETQ *ABS-DATE* *BASE-DATE*)
  (SETQ *REL-DATE* (1+ *REL-DATE*))
  (SETQ *ABS-MONTH* *BASE-MONTH*)
  (SETQ *ABS-YEAR* *BASE-YEAR*)
  (SETQ *RELATIVE-P* ':RELATIVE))

(DEFUN SET-NOW ()
  (SETQ *ABS-SECOND* *BASE-SECOND*)
  (SETQ *ABS-MINUTE* *BASE-MINUTE*)
  (SETQ *ABS-HOUR* *BASE-HOUR*)
  (SETQ *ABS-DATE* *BASE-DATE*)
  (SETQ *ABS-MONTH* *BASE-MONTH*)
  (SETQ *ABS-YEAR* *BASE-YEAR*)
  (SETQ *RELATIVE-P* ':RELATIVE))

(DEFUN SET-CHRISTMAS ()
  (SETQ *ABS-DATE* 25)
  (SETQ *ABS-MONTH* 12))

(DEFUN SET-HALLOWEEN ()
  (SETQ *ABS-SECOND* 0)
  (SETQ *ABS-MINUTE* 0)
  (SETQ *ABS-HOUR* 0)
  (SETQ *ABS-DATE* 31)
  (SETQ *ABS-MONTH* 10)
  (SETQ *ABS-YEAR*
	(COND ((OR (> *BASE-MONTH* 10)
		   (AND (= *BASE-MONTH* 10) (> *BASE-DATE* 31)))
	       (1+ *BASE-YEAR*))
	      (T *BASE-YEAR*))) ;if after October 31, then next year
  )

(DEFUN SET-NEW-YEARS ()
  (SETQ *ABS-SECOND* *BASE-SECOND*)
  (SETQ *ABS-MINUTE* *BASE-MINUTE*)
  (SETQ *ABS-HOUR* *BASE-HOUR*)
  (SETQ *ABS-DATE* *BASE-DATE*)
  (SETQ *ABS-MONTH* *BASE-MONTH*)
  (SETQ *ABS-YEAR* *BASE-YEAR*)
  (SETQ *RELATIVE-P* ':RELATIVE))

(DEFUN SET-BIRTHDAY (USER &OPTIONAL HOST)
  (PARSE-1 (LEXICALLY-ANALYZE
	     (COND ((NULL HOST)
		    (LET* ((USER-OBJECT (IF (TYPEP USER 'SI:USER) USER
					    (NET:FIND-OBJECT-NAMED ':USER (STRING USER))))
			   (BIRTHDAY (SEND USER-OBJECT ':GET ':BIRTHDAY)))
		      (OR BIRTHDAY
			  (FERROR "Can't find ~A's birthday." USER))))
		   (T
		    (FIND-BIRTHDAY (WITH-OUTPUT-TO-STRING (STREAM)
				  (CHAOS:FINGER NIL STREAM
						':USER (STRING USER)
						':HOST (NET:PARSE-HOST HOST)
						':WHOIS T))))))
	   'MAIN))

;;; Top level.

;;; These are the top level functions and external entrypoints that call
;;; the lexical analyzer and parser; the parser calls the action routines.
;;; Any of these callees may call BARF to report an error; BARF is guaranteed
;;; to THROW out, and therefore not return to its caller.

(DEFMACRO CHECK-RANGE (VARIABLE LOWER UPPER STRING)
  `(IF (OR (< ,VARIABLE ,LOWER)
	   (> ,VARIABLE ,UPPER))
       (BARF "~D is ~:[more~;less~] than the number of ~A."
	     ,VARIABLE (< ,VARIABLE ,LOWER) ,STRING)))

(DEFUN PARSE (STRING &OPTIONAL (START 0) END (FUTUREP T)
	      BASE-TIME MUST-HAVE-TIME DATE-MUST-HAVE-YEAR
	      TIME-MUST-HAVE-SECOND (DAY-MUST-BE-VALID T))
  (DECLARE (VALUES SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P
			RELATIVE-P))
  (MULTIPLE-VALUE-BIND (ANSWER RELATIVE-P)
      (PARSE-UNIVERSAL-TIME STRING START END FUTUREP BASE-TIME MUST-HAVE-TIME
			    DATE-MUST-HAVE-YEAR TIME-MUST-HAVE-SECOND DAY-MUST-BE-VALID)
    (COND ((STRINGP ANSWER)
	   ANSWER)
	  (T
	   (MULTIPLE-VALUE-BIND (SECS MINUTES HOURS DAY MONTH
				 YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P)
	       (DECODE-UNIVERSAL-TIME ANSWER)
	     (VALUES SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P
		     RELATIVE-P))))))

(DEFUN PARSE-UNIVERSAL-TIME (*TIME-BEING-PARSED*
			     &OPTIONAL (START 0) END (FUTUREP T) BASE-TIME
			     MUST-HAVE-TIME DATE-MUST-HAVE-YEAR
			     TIME-MUST-HAVE-SECOND (DAY-MUST-BE-VALID T))
  (DECLARE (VALUES UNIVERSAL-TIME RELATIVE-P TIME-SPECIFIED-P))
  (DECLARE (SPECIAL *TIME-BEING-PARSED*))
  (IF (AND MUST-HAVE-TIME (EQ *TIME-BEING-PARSED* ""))
      (BARF "no time supplied"))
  (IF (NULL END)
      (SETQ END (STRING-LENGTH *TIME-BEING-PARSED*)))
  (LET (*ABS-YEAR* *ABS-MONTH* *ABS-DATE* *ABS-HOUR* *ABS-MINUTE* *ABS-SECOND*
	*ABS-DAY-OF-THE-WEEK* *ABS-TIME-ZONE*
	(*REL-YEAR* 0) (*REL-MONTH* 0) (*REL-DATE* 0) (*REL-HOUR* 0) (*REL-MINUTE* 0)
	(*REL-SECOND* 0) *REL-DAY-OF-THE-WEEK*
;	*REL-TIME-ZONE*
	*BASE-YEAR* *BASE-MONTH* *BASE-DATE* *BASE-HOUR* *BASE-MINUTE* *BASE-SECOND*
	*RELATIVE-P* TIME-SPECIFIED-P)
    
    ;; Compute the "base" time: the time to which the string is relative.
    (COND ((NULL BASE-TIME)
	   ;; Time is relative to right now.
	   (MULTIPLE-VALUE (*BASE-SECOND* *BASE-MINUTE* *BASE-HOUR* *BASE-DATE*
			    *BASE-MONTH* *BASE-YEAR*)
	     (GET-TIME))
	   ;; If the time is not known, assume a default base time so that we
	   ;; can still parse fully-specified date/times (e.g. in the file system)
	   (IF (NULL *BASE-SECOND*)
	       (SETQ *BASE-SECOND* 0 *BASE-MINUTE* 0 *BASE-HOUR* 0
		     *BASE-DATE* 1 *BASE-MONTH* 1 *BASE-YEAR* 0)))
	  (T
	   ;; Time is relative to a specified time.
	   (MULTIPLE-VALUE (*BASE-SECOND* *BASE-MINUTE* *BASE-HOUR*
			    *BASE-DATE* *BASE-MONTH* *BASE-YEAR*)
	     (DECODE-UNIVERSAL-TIME  BASE-TIME))))
    (SETQ *BASE-YEAR* (+ 1900. *BASE-YEAR*))
    
    ;; Do the parse, calling the action routines, which work by setting the
    ;; ABS and REL special variables bound above.
    (PARSE-1 (DELQ-ALL (LEXICALLY-ANALYZE *TIME-BEING-PARSED* START END) *NOISE-WORDS*) 'MAIN)
    (IF (AND DATE-MUST-HAVE-YEAR (NULL *ABS-YEAR*))
	(BARF "no year supplied"))
    (IF (AND TIME-MUST-HAVE-SECOND (NULL *ABS-SECOND*))
	(BARF "no seconds supplied"))
    (SETQ TIME-SPECIFIED-P (NOT (NULL (OR *ABS-HOUR* *ABS-MINUTE* *ABS-SECOND*))))
    
    ;; Now apply lots of defaults.
    
    ;; There are many terms, from the lowest order (seconds) to the highest
    ;; order (years).  A legal date must specify some contiguous subsequence
    ;; of these.  The low unspecified ones get zeroed; the high unspecified
    ;; ones are either the next in the future or the previous in the past.
    ;; Time zones and days of the week are handled specially.
    
    ;; First, the following code allows a day of the week to be used to
    ;; specify a year, month, and date, when it is supposed to.
    (IF (AND (NULL *ABS-YEAR*)
	     (NULL *ABS-MONTH*)
	     (NULL *ABS-DATE*)
	     (NOT (NULL *ABS-DAY-OF-THE-WEEK*)))
	;; Day of week specified the year, month, and date.
	(LET ((UT (ENCODE-UNIVERSAL-TIME 0 0 0 *BASE-DATE* *BASE-MONTH* *BASE-YEAR*)))
	  (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL NIL NIL BASE-DAY-OF-THE-WEEK)
	      (DECODE-UNIVERSAL-TIME UT)
	    (LET ((DELTA-DAYS (- *ABS-DAY-OF-THE-WEEK* BASE-DAY-OF-THE-WEEK)))
	      (IF FUTUREP
		  (DO () ((> DELTA-DAYS 0))
		    (SETQ DELTA-DAYS (+ DELTA-DAYS 7)))
		  (DO () ((< DELTA-DAYS 0))
		    (SETQ DELTA-DAYS (- DELTA-DAYS 7))))
	      (MULTIPLE-VALUE (NIL NIL NIL *ABS-DATE* *ABS-MONTH* *ABS-YEAR*)
		(COMPUTE-RELATIVE 0 0 0 (+ *BASE-DATE* DELTA-DAYS)
				  *BASE-MONTH* *BASE-YEAR*))))))
    
    ;; Non-specified low-order terms get set to zero (or the moral equivalent
    ;; of zero), up to the first speicified term.
    (DO ((TERMS '(*ABS-SECOND* *ABS-MINUTE* *ABS-HOUR*
			       *ABS-DATE* *ABS-MONTH* *ABS-YEAR*) (CDR TERMS))
	 (BASE-TERMS '(*BASE-SECOND* *BASE-MINUTE* *BASE-HOUR*
				     *BASE-DATE* *BASE-MONTH* *BASE-YEAR*)
		     (CDR BASE-TERMS))
	 (LOWEST '(0 0 0 1 1 -100000000) (CDR LOWEST))
	 (HIGHEST '(59. 59. 23. NIL 12. 100000000) (CDR HIGHEST))
	 (STATE 'DEFAULT-LOW-TERMS)
	 (COMPARISON 'EQUAL)
	 (OPERATION NIL))
	((NULL TERMS)
	 (IF (EQ STATE 'DEFAULT-LOW-TERMS)
	     (BARF "No time was specified.")))
      RESTART
      (LET ((TERM-VALUE (SYMEVAL (CAR TERMS)))
	    (BASE-TERM-VALUE (SYMEVAL (CAR BASE-TERMS))))
	(SELECTQ STATE
	  (DEFAULT-LOW-TERMS
	   ;; Non-specified low-order terms get set to default values, which
	   ;; are zero or one depending on whether the quantity is zero-based
	   ;; or one-based.
	   (COND ((NULL TERM-VALUE)
		  ;; Term is non-specified, default it.
		  (SET (CAR TERMS) (CAR LOWEST)))
		 (T
		  ;; Term is specified: go to the next state and try again.
		  (SETQ STATE 'SKIP-OVER-SPECIFIED)
		  (GO RESTART))))
	  (SKIP-OVER-SPECIFIED
	   ;; Now we are moving over the contiguous subsequence of values
	   ;; specified by the user.
	   (COND ((NOT (NULL TERM-VALUE))
		  ;; This value was specified by the user.
		  (COND ((> TERM-VALUE BASE-TERM-VALUE)
			 ;; Specified time is later than the base time.
			 (SETQ COMPARISON 'LATER))
			((< TERM-VALUE BASE-TERM-VALUE)
			 ;; Specified time is earlier than the base time.
			 (SETQ COMPARISON 'EARLIER))
			;; If these terms are equal, use the old value of
			;;   COMPARISON based on the lower order terms.
			))
		 (T
		  ;; Term is not specified; go to the next state and try again.
		  ;; This SETQ is documented at the next state.
		  (SETQ OPERATION
			(SELECTQ COMPARISON
			  (EQUAL
			   ;; The specified and base times are equal, do nothing.
			   'EQUAL)
			  (LATER
			   ;; Specified time is later than base time.
			   (IF FUTUREP 'EQUAL 'SUB1))
			  (EARLIER
			   ;; Specified time is earlier than base time.
			   (IF FUTUREP 'ADD1 'EQUAL))))
		  (SETQ STATE 'DEFAULT-HIGH-TERMS)
		  (GO RESTART))))
	  (DEFAULT-HIGH-TERMS
	   ;; Non-specified high-order terms come from the base time.  The
	   ;; tricky thing is that we may have to add or subtract one, depending
	   ;; on FUTUREP and COMPARISON, which requires propagating carry or
	   ;; borrow.  This information is encoded in OPERATION, which is SETQed
	   ;; above (so that we don't do it each time around the loop!).
	   (IF (NOT (NULL TERM-VALUE))
	       ;; Foo, the rest of the high-order terms have to be unspecified.
	       (BARF "Unrecognized pattern of defaulting."))
	   (SELECTQ OPERATION
	     (EQUAL
	      ;; We are just copying base time into abs time.  Keep doing it.
	      (SET (CAR TERMS) BASE-TERM-VALUE))
	     (ADD1
	      ;; Set this term one higher than it is in the base time.
	      (LET ((HIGHEST-VALUE
		      ;; Compute the highest legal value for this term.
		      (IF (EQ (CAR TERMS) '*ABS-DATE*)
			  ;; Highest possible value for dates depends on
			  ;; which month this is.
			  (MONTH-LENGTH *BASE-MONTH* *BASE-YEAR*)
			  ;; Other highest values are just constants.
			  (CAR HIGHEST))))
		(COND ((< BASE-TERM-VALUE HIGHEST-VALUE)
		       ;; No carry.  Just add one, and copy the rest.
		       (SET (CAR TERMS) (1+ BASE-TERM-VALUE))
		       (SETQ OPERATION 'EQUAL))
		      (T
		       ;; Carry into next term.
		       (SET (CAR TERMS) (CAR LOWEST))))))
	     (SUB1
	      ;; Set this term one lower than it is in the base time.
	      (COND ((> BASE-TERM-VALUE (CAR LOWEST))
		     ;; No borrow.  Just subtract one, and copy the rest.
		     (SET (CAR TERMS) (1- BASE-TERM-VALUE))
		     (SETQ OPERATION 'EQUAL))
		    (T
		     ;; Borrow from the next term.
		     (SET (CAR TERMS)
			  (IF (EQ (CAR TERMS) '*ABS-DATE*)
			      ;; Highest possible value for dates depends on
			      ;; which month the previous month was.
			      (LET ((MONTH (1- *BASE-MONTH*))
				    (YEAR *BASE-YEAR*))
				(WHEN (= MONTH 0)
				  (SETQ MONTH 1 YEAR (1- YEAR)))
				(MONTH-LENGTH MONTH YEAR))
			      ;; Other highest values are just constants.
				   (CAR HIGHEST))))))
		  (OTHERWISE
		   (FERROR NIL "Bad value of OPERATION ~S" OPERATION))))
	       (OTHERWISE
		(FERROR NIL "Bad value of STATE ~S" STATE)))))
	 
	 ;; Now hack other random defaults.
;	 (IF (NULL *ABS-TIME-ZONE*)
;	     (SETQ *ABS-TIME-ZONE* *TIMEZONE*))
;	 (SETQ *REL-TIME-ZONE* *ABS-TIME-ZONE*)
	 
	 ;; Check ranges.
	 (CHECK-RANGE *ABS-SECOND* 0 59. "seconds in a minute")
	 (CHECK-RANGE *ABS-MINUTE* 0 59. "minutes in an hour")
	 (CHECK-RANGE *ABS-HOUR* 0 23. "hours in a day")
						;Check this before MONTH-STRING call!
	 (CHECK-RANGE *ABS-MONTH* 1 12. "months in a year")
	 (CHECK-RANGE *ABS-DATE*
		      1
		      (MONTH-LENGTH *ABS-MONTH* *ABS-YEAR*)
		      (FORMAT NIL "days in ~A" (MONTH-STRING *ABS-MONTH*)))
	 (IF (AND DAY-MUST-BE-VALID (NOT (NULL *ABS-DAY-OF-THE-WEEK*)))
	     (VERIFY-DATE *ABS-DATE* *ABS-MONTH* *ABS-YEAR* *ABS-DAY-OF-THE-WEEK*))
	 
	 ;; Now put it together.
	 (MULTIPLE-VALUE (*ABS-SECOND* *ABS-MINUTE* *ABS-HOUR* *ABS-DATE* *ABS-MONTH* *ABS-YEAR*)
	   (COMPUTE-RELATIVE (+ *ABS-SECOND* *REL-SECOND*)
			     (+ *ABS-MINUTE* *REL-MINUTE*)
			     (+ *ABS-HOUR* *REL-HOUR*)
			     (+ *ABS-DATE* *REL-DATE*)
			     (+ *ABS-MONTH* *REL-MONTH*)
			     (+ *ABS-YEAR* *REL-YEAR*)))
	 (VALUES (ENCODE-UNIVERSAL-TIME *ABS-SECOND* *ABS-MINUTE* *ABS-HOUR*
					*ABS-DATE* *ABS-MONTH* *ABS-YEAR* *ABS-TIME-ZONE*)
		 *RELATIVE-P* TIME-SPECIFIED-P)))

;;; Parse a date spec relative to some reference date/time, which is
;;; presumed to be either a UT or a string parsable as a date (which
;;; better not be ambiguous).  This makes Future-P a lot more
;;; meaningful, since it doesn't operate wrt a moving target, namely the
;;; present moment.  For example, (PARSE-UNIVERSAL-TIME-RELATIVE "5pm" "today")
;;; will return the same value whether the present time is before or after 5 pm.
(DEFUN PARSE-UNIVERSAL-TIME-RELATIVE (DATE-SPEC REFERENCE-DATE-SPEC
				      &OPTIONAL (FUTURE-P T)
				      &AUX REFERENCE-DATE)
  (SETQ REFERENCE-DATE
	(IF (NUMBERP REFERENCE-DATE-SPEC)
	    REFERENCE-DATE-SPEC
	  ;; if you make the reference ambiguous, you get what you deserve
	  (PARSE-UNIVERSAL-TIME REFERENCE-DATE-SPEC)))
  (PARSE-UNIVERSAL-TIME DATE-SPEC 0 NIL FUTURE-P REFERENCE-DATE))

;;; Parse a time spec so that with any missing components, it is
;;; defaulted to the present value of the beginning of the
;;; smallest-grained missing part.  Thus "1 June" will parse as 1 June
;;; of the present year, regardless of whether today is before or after
;;; 1 June; "3pm" will parse as 15:00 on today's date, whether it is
;;; presently before or after 3 pm.  "Thursday" will parse as Thursday
;;; of this week, whether today is Monday or Friday.
(DEFUN PARSE-PRESENT-BASED-UNIVERSAL-TIME (*TIME-BEING-PARSED*)
  (DECLARE (VALUES UNIVERSAL-TIME RELATIVE-P TIME-SPECIFIED-P))
  (DECLARE (SPECIAL *TIME-BEING-PARSED*))
  (LET (*ABS-YEAR* *ABS-MONTH* *ABS-DATE* *ABS-HOUR* *ABS-MINUTE* *ABS-SECOND*
	*ABS-DAY-OF-THE-WEEK* *ABS-TIME-ZONE*
	(*REL-YEAR* 0) (*REL-MONTH* 0) (*REL-DATE* 0) (*REL-HOUR* 0) (*REL-MINUTE* 0)
	(*REL-SECOND* 0) *REL-DAY-OF-THE-WEEK*
;	*REL-TIME-ZONE*
	*BASE-YEAR* *BASE-MONTH* *BASE-DATE* *BASE-HOUR* *BASE-MINUTE* *BASE-SECOND*
	*RELATIVE-P* TIME-SPECIFIED-P
	(START 0) (END (STRING-LENGTH *TIME-BEING-PARSED*)))
    
    ;; Compute the "base" time: the time to which the string is relative.
    ;; Time is relative to "right now", as amended below.
    (MULTIPLE-VALUE (*BASE-SECOND* *BASE-MINUTE* *BASE-HOUR* *BASE-DATE*
		     *BASE-MONTH* *BASE-YEAR*)
      (GET-TIME))
    ;; If the time is not known, assume a default base time so that we
    ;; can still parse fully-specified date/times (e.g. in the file system)
    (IF (NULL *BASE-SECOND*)
	(SETQ *BASE-SECOND* 0 *BASE-MINUTE* 0 *BASE-HOUR* 0
	      *BASE-DATE* 1 *BASE-MONTH* 1 *BASE-YEAR* 0))
    (SETQ *BASE-YEAR* (+ 1900. *BASE-YEAR*))
    
    ;; Do the parse, calling the action routines, which work by setting the
    ;; ABS and REL special variables bound above.
    (PARSE-1
      (DELQ-ALL
	(LEXICALLY-ANALYZE *TIME-BEING-PARSED* START END) *NOISE-WORDS*) 'MAIN)
    (SETQ TIME-SPECIFIED-P (NOT (NULL (OR *ABS-HOUR* *ABS-MINUTE* *ABS-SECOND*))))
    
    ;; Now apply lots of defaults.
    
    ;; There are many terms, from the lowest order (seconds) to the highest
    ;; order (years).  A legal date must specify some contiguous subsequence
    ;; of these.  The low unspecified ones get zeroed; the high unspecified
    ;; ones are the present frames: this year, this month, etc.
    ;; Days of the week are handled specially.  Time zones are presently not hacked.
    
    ;; First, the following code allows a day of the week to be used to
    ;; specify a year, month, and date, when it is supposed to.  If only
    ;; the day of the week is given, it is taken as that day of "this
    ;; week".  An unresolved issue here is whether the week starts on
    ;; Monday or Sunday; GET-TIME says Monday, so that's how works for now.
    (IF (AND (NULL *ABS-YEAR*)
	     (NULL *ABS-MONTH*)
	     (NULL *ABS-DATE*)
	     (NOT (NULL *ABS-DAY-OF-THE-WEEK*)))
	;; Day of week specified the year, month, and date.
	(LET ((UT (ENCODE-UNIVERSAL-TIME 0 0 0 *BASE-DATE* *BASE-MONTH* *BASE-YEAR*)))
	  (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL NIL NIL BASE-DAY-OF-THE-WEEK)
	      (DECODE-UNIVERSAL-TIME UT)
	    (LET ((DELTA-DAYS (- *ABS-DAY-OF-THE-WEEK* BASE-DAY-OF-THE-WEEK)))
	      (MULTIPLE-VALUE (NIL NIL NIL *ABS-DATE* *ABS-MONTH* *ABS-YEAR*)
		(COMPUTE-RELATIVE 0 0 0 (+ *BASE-DATE* DELTA-DAYS)
				  *BASE-MONTH* *BASE-YEAR*))))))

    ;; Non-specified low-order terms get set to zero (or the moral equivalent
    ;; of zero), up to the first speicified term.
    (LOOP WITH STATE = 'DEFAULT-LOW-TERMS
	  FOR TERMS ON '(*ABS-SECOND* *ABS-MINUTE* *ABS-HOUR*
				      *ABS-DATE* *ABS-MONTH* *ABS-YEAR*)
	  FOR BASE-TERMS ON '(*BASE-SECOND* *BASE-MINUTE* *BASE-HOUR*
					    *BASE-DATE* *BASE-MONTH* *BASE-YEAR*)
	  FOR LOWEST ON '(0 0 0 1 1 -100000000)
	  AS TERM-VALUE = (SYMEVAL (CAR TERMS))
	  AS BASE-TERM-VALUE = (SYMEVAL (CAR BASE-TERMS))
	  DO (SELECTQ-EVERY STATE
	       (DEFAULT-LOW-TERMS
		 ;; Non-specified low-order terms get set to default values, which
		 ;; are zero or one depending on whether the quantity is zero-based
		 ;; or one-based.
		 (IF (NULL TERM-VALUE)
		     ;; Term is non-specified, default it.
		     (SET (CAR TERMS) (CAR LOWEST))
		   ;; Term is specified: go to the next state and try again.
		   (SETQ STATE 'SKIP-OVER-SPECIFIED)))
	       (SKIP-OVER-SPECIFIED
		 ;; Now we are moving over the contiguous subsequence of values
		 ;; specified by the user.
		 (WHEN (NULL TERM-VALUE)
		   ;; Term is not specified; go to the next state and try again.
		   ;; [Else this value was specified by the user.  Fine.]
		   (SETQ STATE 'DEFAULT-HIGH-TERMS)))
	       (DEFAULT-HIGH-TERMS
		 ;; Non-specified high-order terms come from the base time.
		 (WHEN (NOT (NULL TERM-VALUE))
		   ;; Foo, the rest of the high-order terms must be unspecified.
		   (BARF "Unrecognized pattern of defaulting."))
		 ;; We are just copying base time into abs time.  Keep doing it.
		 (SET (CAR TERMS) BASE-TERM-VALUE))
	       (OTHERWISE
		 (FERROR NIL "Bad value of STATE ~S" STATE)))
	  FINALLY (WHEN (EQ STATE 'DEFAULT-LOW-TERMS)
		    (BARF "No time was specified.")))

	 ;; Check ranges.
	 (CHECK-RANGE *ABS-SECOND* 0 59. "seconds in a minute")
	 (CHECK-RANGE *ABS-MINUTE* 0 59. "minutes in an hour")
	 (CHECK-RANGE *ABS-HOUR* 0 23. "hours in a day")
						;Check this before MONTH-STRING call!
	 (CHECK-RANGE *ABS-MONTH* 1 12. "months in a year")
	 (CHECK-RANGE *ABS-DATE*
		      1
		      (MONTH-LENGTH *ABS-MONTH* *ABS-YEAR*)
		      (FORMAT NIL "days in ~A" (MONTH-STRING *ABS-MONTH*)))
	 (IF (NOT (NULL *ABS-DAY-OF-THE-WEEK*))
	     (VERIFY-DATE *ABS-DATE* *ABS-MONTH* *ABS-YEAR* *ABS-DAY-OF-THE-WEEK*))
	 
	 ;; Now put it together.
	 (MULTIPLE-VALUE (*ABS-SECOND* *ABS-MINUTE*
			  *ABS-HOUR* *ABS-DATE* *ABS-MONTH* *ABS-YEAR*)
	   (COMPUTE-RELATIVE (+ *ABS-SECOND* *REL-SECOND*)
			     (+ *ABS-MINUTE* *REL-MINUTE*)
			     (+ *ABS-HOUR* *REL-HOUR*)
			     (+ *ABS-DATE* *REL-DATE*)
			     (+ *ABS-MONTH* *REL-MONTH*)
			     (+ *ABS-YEAR* *REL-YEAR*)))
	 (VALUES (ENCODE-UNIVERSAL-TIME *ABS-SECOND* *ABS-MINUTE* *ABS-HOUR*
					*ABS-DATE* *ABS-MONTH* *ABS-YEAR* *ABS-TIME-ZONE*)
		 *RELATIVE-P* TIME-SPECIFIED-P)))

;;; This function will accept dates such as -1,March 1980 and return 28,Febuary 1980
;;; CAL 10/24/80

(DEFUN COMPUTE-RELATIVE (SECOND MINUTE HOUR DATE MONTH YEAR)
  (PROG (M)
    (SETQ SECOND (+ SECOND (* 60 (+ MINUTE (* 60 (+ HOUR (* 24 DATE)))))))
    (SETQ DATE (FIX (// (FLOAT SECOND) 86400)))
    (SETQ SECOND (- SECOND (* DATE 86400)))
    (SETQ HOUR (FIX (// SECOND 3600)))
    (SETQ SECOND (\ (FIX SECOND) 3600))
    (SETQ MINUTE (FIX (// SECOND 60)))
    (SETQ SECOND (\ SECOND 60))
    (SETQ YEAR (+ YEAR (FIX (// (FLOAT (1- MONTH)) 12))))
    (SETQ MONTH (1+ (\ (+ 12 (\ (1- MONTH) 12)) 12)))
 L1 (SETQ M (MONTH-LENGTH MONTH YEAR))
    (COND ((> DATE M)
	   (SETQ DATE (- DATE M))
	   (SETQ MONTH (1+ MONTH))
	   (COND ((> MONTH 12) (SETQ MONTH 1) (SETQ YEAR (1+ YEAR))))
	   (GO L1))
	  ((< DATE 1)				
	   (SETQ MONTH (1- MONTH))
	   (COND ((= MONTH 0) (SETQ MONTH 12) (SETQ YEAR (1- YEAR))))
	   (SETQ DATE (+ (MONTH-LENGTH MONTH YEAR) DATE))
	   (GO L1)))       
    (RETURN (VALUES SECOND MINUTE HOUR DATE MONTH YEAR))))

(DEFUN FIND-BIRTHDAY (STRING &AUX X)
  (SETQ X (STRING-SEARCH "birthday" STRING))
  (IF (NULL X) (BARF "Can't find birthday"))
  (SUBSTRING STRING (+ 9 X) (STRING-SEARCH ";" STRING (+ 9 X))))

(DEFFLAVOR PARSE-ERROR
	(TIME-STRING)
	(FERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFUN BARF (FORMAT-STRING &REST FORMAT-ARGS)
  (DECLARE (SPECIAL *TIME-BEING-PARSED*))
  (ERROR 'PARSE-ERROR
	 ':TIME-STRING *TIME-BEING-PARSED*
	 ':FORMAT-STRING FORMAT-STRING
	 ':FORMAT-ARGS (COPYLIST FORMAT-ARGS)))

(COMPILE-FLAVOR-METHODS PARSE-ERROR)

(DEFUN TEST ()
  (LOOP WITH NOW = (GET-UNIVERSAL-TIME)
	FOR TIME = (PROMPT-AND-READ `(:DATE :OR-NIL T :BASE-TIME ,NOW) "Time tester: ")
	WHILE TIME
	DO (PRINT-UNIVERSAL-TIME TIME)
	   (FORMAT T "~2%")))

;;; This function should be run whenever you make a major change to the
;;; parser.  It has an exhaustive set of test cases, all of which should
;;; be verified.
(DEFCONST *TEST-CASES*
	'("March 15, 1960" "15 March 1960" "3//15//60" "3//15//1960"
	  "3-15-60" "3-15" "3-March-60" "3-Mar-60" "March-3-60"
	  "3-Aug-1923"
	  "Aug 9, 1910" "Aug 9, 10" "Aug 9, 10AM" "Aug 9, 10:30" "Aug 9, 10:30AM"
	  "1130." "11:30" "11:30:17" "11:30 pm" "11:30 AM" "1130" "113000"
	  "11.30" "11.30.00" "11.3" "11 pm" "1130 pm" "12 noon"
	  "midnight" "m" "Friday, March 15, 1980" "6:00 gmt" "3:00 pdt"
	  "15 March 60" "15 march 60 seconds"
	  "Fifteen March 60" "The Fifteenth of March, 1960;"
	  "The Fifteenth" "The 15th"
	  "Twenty-one March 1960"       ; Test out hyphens in alphabetic tokens.
	  "20-May-82 1:16AM-EDT (Thu)"  ; MMcM got this in the mail once.
	  "5//20//82 2:25 P.M."         ; Lexical analysis of periods in alpha tokens.
	  "fri mar 15 12:00:00 1960"    ; Weird Unix format.
	  "WED. OCT. 6, 1982"           ; Seen in the mail once, I don't know why.
	  "Thursday, 21 May 1981, 00:27-EDT"
	  "1984-4-3"			;ISO
	  "1984-April-3"
	  "One minute after March 3, 1960"
	  "Three days ago" "5 hours ago"
	  "Two days after March 3, 1960"
	  "Three minutes after 23:59:59 Dec 31, 1959"
	  "Now" "Today" "Yesterday" "two days after tomorrow"
	  "one day before yesterday" "the day after tomorrow"

	  "half past noon" "half a minute past noon"
	  "20 past noon" "a minute past midnight"
	  
	  "2.5 days from now" "2.5m from now"
	  "2.5 hours after tomorrow"
	  ".5 days from now"
	  "2 and a half days from now"
	  "2 hours and 20 minutes from tomorrow"
	  "5h3m from tomorrow"
	  ;; Leave these last in case server is down!
	  "my birthday" "the day before my birthday"
	  "1 hour before dlw's birthday"
	  "ED@MIT-MC's birthday"

	  ;;How about some cases with non-normal character styles:

	  "D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")March 15, 19600" "1150 March 1960" "3//151//600" "3//15//1960"
	  "13-15-600" "3-15" "3-March-60" "3-Mar-60" "M1arch0-3-60"
	  "3-Aug-1923"
	  "1Aug0 9, 1910" "Aug 91,0 10" "Aug 9, 101AM0" "Aug 9, 110:300" "Aug 9, 101:030AM"
	  "11301.0" "11:30" "11:30:17" "11:30 pm" "11:30 AM" "1130" "113000"
	  "11.30" "11.30.00" "11.3" "11 pm" "1130 pm" "12 noon"
	  "midnight" "m" "Friday, March 15, 1980" "6:00 gmt" "3:00 pdt"
	  "15 March 60" "15 march 60 1seconds0"
	  "Fifteen March 60" "The Fifteenth of March, 1960;"
	  "The Fifteenth" "The 15th"
	  "Twenty-one March 1960"       ; Test out hyphens in alphabetic tokens.
	  "20-May-82 1:16AM-EDT (Thu)"  ; MMcM got this in the mail once.
	  "5//20//82 2:25 P.M."         ; Lexical analysis of periods in alpha tokens.
	  "fri 1mar0 15 12:00:00 1960"    ; Weird Unix format.
	  "WED. OCT. 6, 1982"           ; Seen in the mail once, I don't know why.
	  "Thursday, 121 May 19810, 00:27-EDT"
	  "1984-4-3"			;ISO
	  "1984-April-3"
	  "(2 0 (NIL 0) (NIL :ITALIC :VERY-LARGE) "BIGFNTI")One minute after March 3, 19600"
	  "Three days ago" "5 hours ago"
	  "Two 1days0 after March 3, 1960"
	  "Three minutes after 23:59:59 Dec 31, 1959"
	  "Now" "Today" "Yesterday" "two days after tomorrow"
	  "one day before yesterday" "the day after tomorrow"

	  "half past 1noon0" "half a minute past noon"
	  "20 past 1noon0" "a minute past midnight"))

;;; Here are some more things that have been suggested.  If the parser
;;; is made to work on them, add them to the list of test cases.
;;; 
;;; "a quarter of an hour from now"  This is accepted but misinterpreted
;;;     because the phrase "a quarter of" means 15 mins before!!
;;; "three and a half minutes from now"
;;; "quarter of five" because "five" is not a time.
;;; "7 o'clock"
;;; "midnight tonight"   (I realize that, say, "4 tonight" is ambiguous)
;;; 
;;; "Friday the 13th"
;;; "2:30 from now"       This might be considered ambiguous
;;; "2.5 ms from now"       ; i.e., millisecond
;;; "2.5s from now"
;;; "fourty-eight hours from now"   Funny spelling?
;;; 
;;; "a fortnight from now"
;;; "a millenium from now", century, decade - HDT says these are impossible
;;; "a century from now"
;;; "a decade from now"
;;; "the second saturday from now"
;;; "the second full moon from now"
;;; "the second low tide from now"
;;; "the second vernal equinox from now"
;;; "sunrise"  ; longitude and latitude are part of the site info, right?
;;; "this saturday"   ; though "saturday" work
;;; "next saturday"
;;; "last saturday"
;;; "the saturday before last"
;;; "the first saturday in january"
;;; "january"  ; though "january 1" work
;;; "spring"
;;; "friday the 13th"
;;; "easter"
;;; "Washington's Birthday"  ; though "GJS's Birthday" works (but see (*))
;;; "Washington's Birthday (traditional)"
;;; "GJS's last logout"
;;; "System 210 release date"
;;; "OZ:<AGRE.PAPERS>READ.TXT's write date"
;;; "registration day"

;;; Also, following comment from Phil Agre:
;;; (*) Sussman's inquir entry lists his birthday as being February 8, 1947 while
;;; mine just says July 8, with the result that "GJS's birthday" has 47. in its
;;; year slot while "Agre's birthday" has 83. in its year slot.  Oh well.  Oh yes,
;;; I also like how "GJS's birthday" doesn't blow up if AI is down.

(DEFUN TEST-PARSER (&OPTIONAL ERROR-P &AUX ANS RELATIVE-P)
  (TERPRI)
  (DOLIST (CASE *TEST-CASES*)
    (FORMAT T "~41A   " CASE)
    (CONDITION-CASE-IF (NOT ERROR-P) (ERROR)
	(MULTIPLE-VALUE (ANS RELATIVE-P)
	  (PARSE-UNIVERSAL-TIME CASE))
      (ERROR (PRINC ERROR))
      (:NO-ERROR
       (FORMAT T "~15A" (SELECTQ RELATIVE-P
			  (:RELATIVE "Relative")
			  ((NIL) "Absolute")
			  (OTHERWISE RELATIVE-P)))
       (PRINT-UNIVERSAL-TIME ANS)))
    (TERPRI)))

;;; Time interval stuff.
(defvar time-interval-array (make-array '(50. 2.)))

(defvar time-interval-unit-types 0)

(defun time-interval-to-seconds (string &aux (total 0))
  (let ((*time-being-parsed* string))
    (declare (special *time-being-parsed*))
    (do ((ix 0)
	 (l (string-length string)))
	((or (null ix) ( ix l)) total)
      
      (let ((token-start (string-search-not-char #\SP string ix)))
	(if (null token-start) (return total))
	(multiple-value-bind (units token-end)
	    (parse-number string token-start)
	  (if (null units)
	      (barf "~S encountered where number expected in time interval spec."
		    (substring string token-start
			       (string-search-char #\SP string token-start))))
	  (let ((token-start (string-search-not-char #\SP string token-end)))
	    (if (null token-start)
		(barf "Units specification missing from time interval string"))
	    (setq ix (string-search-char #\SP string token-start))
	    (let ((uval (loop for i from 0 below time-interval-unit-types
			      when
			      (string-equal
				(aref time-interval-array i 0) string 0 token-start nil ix)
			      return (aref time-interval-array i 1)
			      finally (barf "Unknown unit of time: ~A"
					    (substring string token-start ix)))))
	      (if (char-equal #/y (aref string token-start))	;years?
		  (if (> units 3)		;good till 1999.
		      (incf total (* (// units 4)
				     (time-interval-to-seconds "1 day")))))
	      (incf total (* uval units)))))))))

(defun init-time-interval-array ()
  (aset "second" time-interval-array 0 0)
  (aset 1 time-interval-array 0 1)
  (setq time-interval-unit-types 1)
  (dolist (l '(("1 second" "seconds" "s" "sec" "secs")
	       ("60 seconds" "minute" "minutes" "min" "mins" "m")
	       ("60 minutes" "hour" "hours" "hr" "hrs" "h")
	       ("24 hours" "day" "days")
	       ("7 days" "week" "weeks" "wk" "wks")
	       ("365 days" "year" "years" "yr" "yrs")))
    (let ((value (time-interval-to-seconds (car l))))
      (dolist (newname (cdr l))
	(aset newname time-interval-array time-interval-unit-types 0)
	(aset value time-interval-array time-interval-unit-types 1)
	(incf time-interval-unit-types)))))

(init-time-interval-array)

(defun seconds-to-interval-string (secs)
  (cond ((zerop secs)
	 "0 seconds")
	((minusp secs)
	 (string-append "minus " (seconds-to-interval-string (- secs))))
	(T (do ((i 0 (1+ i))
		(last nil))
	       (( i time-interval-unit-types)
		(seconds-to-interval-string-1 last secs))
	     (if (> (aref time-interval-array i 1) secs)
		 (return (seconds-to-interval-string-1 last secs))
	       (if (or (null last)
		       (not (= (aref time-interval-array i 1)
			       (aref time-interval-array last 1))))
		   (setq last i)))))))

(defvar *four-year-cycle* (time-interval-to-seconds "4 Years"))
(defvar *seconds-in-day* (time-interval-to-seconds "1 day"))

(defconst *subsecond-units* '("msec" "usec" "nsec"))

(defun seconds-to-interval-string-1 (index secs)
  (when (or (null index) (zerop index))
    (return-from seconds-to-interval-string-1
      (let ((log (- (floor (cl:log secs 10) 3))))
	(if (and (plusp log) (<= log (length *subsecond-units*)))
	    (format nil "~D ~A" (* secs (expt 1000 log)) (cl:elt *subsecond-units* (1- log)))
	    (format nil "~D second~:P" secs)))))
  (when (>= secs *four-year-cycle*)
    (decf secs (* (floor secs *four-year-cycle*) *seconds-in-day*)))
  (multiple-value-bind (quo rem)
      (floor secs (aref time-interval-array index 1))
    (if (zerop rem)
	(format nil "~D ~A~P" quo (aref time-interval-array index 0) quo)
	(format nil "~D ~A~P ~A" quo (aref time-interval-array index 0) quo
		(seconds-to-interval-string rem)))))

(defun parse-interval-or-never (string &optional start end)
  (setq string (string-trim '(#\SP #\TAB)
			    (if (null (or start end))
				string
				(substring string start end))))
  (if (member string '("none" "no" "" "never" "not ever" "nil" "()"))
      nil
      (time-interval-to-seconds string)))

(defun print-interval-or-never (interval &optional (stream standard-output))
  (send stream ':string-out
	(if (null interval) "never"
	    (time:seconds-to-interval-string interval))))

(FORMAT:DEFFORMAT FORMAT:TIME-INTERVAL (:ONE-ARG) (INTERVAL IGNORE)
  (SCL:PRESENT INTERVAL 'TIME-INTERVAL :STREAM FORMAT:*FORMAT-OUTPUT*))

;;; This returns the universal time of the next moment after the current time that is
;;; OFFSET after the "natural" start of the next INTERVAL.  For example:
;;; (next-time "1 hr")  the universal time of the next hour after now.
;;; (next-time "1 day" "3 hours")  the universal time of then next 3AM (local time).
(defun next-time (interval &optional offset)
  (declare (values next-time interval))
  (let* ((time (time:get-universal-time))
	 (zone (- *timezone* (if (daylight-savings-p) 1 0)))
	 (time-ignoring-zone (- time (* 3600. zone))))
    (setq interval (or (parse-interval-or-never interval) *seconds-in-day*)
	  offset (or (parse-interval-or-never offset) 0))
    (values
      (+ offset time interval (- (mod time-ignoring-zone interval)))
      interval)))


;;; Now that the time parser is loaded, we can fix up times remembered as strings by
;;; the system generator.
(ADD-INITIALIZATION "TIME-PARSER-LOADED" '(FS:CANONICALIZE-COLD-LOADED-TIMES) '(ONCE))
