;;; -*- Mode:LISP; Package:TIME; Base:8 -*-
;;; Date and time routines
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Note: days and months are kept one-based throughout, as much as possible.
;;; Days of the week are zero-based on Monday.

;;; [Maybe this should have a global variable which causes it to use AM/PM in place
;;;  of 24-hour time, in all relevant functions?]

;;; Hardware dependencies

(DEFUN MICROSECOND-TIME ()
  (MULTIPLE-VALUE-BIND (LOW HIGH) (FULL-MICROSECOND-TIME)
    (DPB HIGH (BYTE 32. 32.) (DPB LOW (BYTE 32. 0) 0))))

(DEFCONSTANT *MICROSECOND-TIME-LOW-SIZE* 31.)

(DEFUN FIXNUM-MICROSECOND-TIME ()
  (DECLARE (VALUES LOW-31-BITS TOP-1-BIT))
  (LET ((TIME (SYS:%MICROSECOND-CLOCK)))
    (VALUES (LDB (BYTE 31. 00) TIME) (LDB (BYTE 1 31.) TIME))))

(DEFCONSTANT *YEAR-ZERO* 1900.)
(DEFCONSTANT *FIRST-MONDAY-IN-YEAR-ZERO* 0)	;1 Jan 1900 was a Monday
(DEFCONSTANT *YEAR-ZERO-LEAP* 0)		;1900 was not a leap year
(DEFCONSTANT *YEAR-MINUS-ONE-MOD-FOUR* 3.)
(DEFCONSTANT *YEAR-MINUS-ONE-MOD-CENTURY* 99.)
(DEFCONSTANT *LEAP-CENTURY-OFFSET-OF-YEAR-MINUS-ONE* 2)
						;1800 was the second century in the
						;leap century cycle. Every fourth century
						;is a leap year.  Next is the year 2000.

;;; Conversion routines, universal time is seconds since 1-jan-00 00:00-GMT

(DEFVAR *TIMEZONE* 5)

(defun set-*timezone* (new-timezone)
  (setq *timezone* new-timezone)
  #+IMach
  (setq sys:*timezone-offset-minutes* (- (round (* 60. new-timezone))))
  #+IMach
  (when (variable-boundp sys:*timezone-name*)
    (setf (fill-pointer sys:*timezone-name*) 0)
    ;; FEP can't do daylight-savings, so we pretend its not.
    (format sys:*timezone-name* "~A" (timezone-string new-timezone nil))))

;;;Allow either a mnemonic, a la *timezones* or a flonum of the form n.0 or n.5 to specify
;;;an offset from GMT.  *TIMEZONE* is always a number.
(DEFUN SITE-TIMEZONE-INITIALIZE ()
  (LET ((TIMEZONE (SEND NET:*LOCAL-SITE* ':TIMEZONE)))
    (CONDITION-CASE (ERROR)
	 (SET-*TIMEZONE* (SCL:ACCEPT-FROM-STRING 'TIME:TIMEZONE (STRING TIMEZONE)))
       (ERROR
	 (FORMAT ERROR-OUTPUT "~&Your site's timezone specification is invalid.~%")
	 (DBG:REPORT ERROR ERROR-OUTPUT)
	 (FORMAT ERROR-OUTPUT "~&A timezone should be specified as ")
	 (DW:DESCRIBE-PRESENTATION-TYPE 'TIME:TIMEZONE ERROR-OUTPUT)
	 (FORMAT ERROR-OUTPUT "~&Using EST timezone instead.")
	 (SET-*TIMEZONE* 5)))))

(DEFSUBST YEAR-RELATIVE-TO (YEAR NEW-BASE-YEAR &OPTIONAL (CURRENT-BASE-YEAR 0))
  (+ YEAR (- CURRENT-BASE-YEAR NEW-BASE-YEAR)))

(DEFSUBST ABSOLUTE-YEAR (YEAR &OPTIONAL (BASE-YEAR *YEAR-ZERO*))
  (+ YEAR BASE-YEAR))

(DEFSUBST CANONICALIZE-YEAR (YEAR &OPTIONAL (MILLENIUM 1900.))
  (IF (< YEAR 1000.) (ABSOLUTE-YEAR YEAR MILLENIUM) YEAR))

;;; One-based array of cumulative days per month.
(DEFCONSTANT *CUMULATIVE-MONTH-DAYS-TABLE*
	     '#.(CL:MAKE-ARRAY 13. :INITIAL-CONTENTS
			       '(0 0 31. 59. 90. 120. 151. 181. 212. 243. 273. 304. 334.)))

(DEFUN MAKE-MONTH-DAY-TABLE (MONTHS)
  (LET ((TABLE (MAKE-ARRAY (APPLY #'+ MONTHS))))
    (LET ((INDEX 0))
      (DOTIMES (MONTH (LENGTH MONTHS))
	(DOTIMES (DAY (NTH MONTH MONTHS))
	  (SETF (AREF TABLE INDEX) (DPB MONTH (BYTE 4 5) DAY))
	  (INCF INDEX))))
    TABLE))

(DEFCONST *REGULAR-MONTH-DAY-TABLE*
	  (MAKE-MONTH-DAY-TABLE '#10R(31 28 31 30 31 30 31 31 30 31 30 31)))

(DEFCONST *LEAP-MONTH-DAY-TABLE*
	  (MAKE-MONTH-DAY-TABLE '#10R(31 29 31 30 31 30 31 31 30 31 30 31)))

;; This code depends on getting the year based on *year-zero*
;; this returns the number of leap years during the first full-years-passed years.
(DEFUN NUMBER-OF-LEAP-YEARS (FULL-YEARS-PASSED)
  (LET ((CENTURIES-PASSED
	  (FLOOR (+ FULL-YEARS-PASSED *YEAR-MINUS-ONE-MOD-CENTURY*) 100.)))
    ;; leap years are all years divisible by 4, but not non-leap-centuries
    (+ (- (FLOOR (+ FULL-YEARS-PASSED *YEAR-MINUS-ONE-MOD-FOUR*) 4) CENTURIES-PASSED)
       ;; add leap centuries back in.
       (FLOOR (+ *LEAP-CENTURY-OFFSET-OF-YEAR-MINUS-ONE* CENTURIES-PASSED) 4))))

;;; The guts of DECODE-UNIVERSAL-TIME.  This part doesn't worry about daylight savings time.
(DEFUN DECODE-UNIVERSAL-TIME-INTERNAL (UNIVERSAL-TIME OFFSET)
  (DECLARE (VALUES SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK))
  (MULTIPLE-VALUE-BIND (DAYS SECONDS)
      (IF (AND (BIGP UNIVERSAL-TIME)
	       (PLUSP UNIVERSAL-TIME)
	       (= (SI:BIGNUM-LENGTH UNIVERSAL-TIME) 1)
	       (FIXNUMP OFFSET))
	  ;; Non-consing version for the normal case.
	  (MULTIPLE-VALUE-BIND (LOW HIGH)
	      (SYS:%ADD-BIGNUM-STEP (SI:BIGNUM-REF UNIVERSAL-TIME 0) OFFSET 0)
	    (SYS:%DIVIDE-BIGNUM-STEP LOW (+ HIGH (SI:FIXNUM-SIGN OFFSET)) 86400.))
	  ;; What we really mean.
	  (FLOOR (+ UNIVERSAL-TIME OFFSET) 86400.))
    ;; full-years-passed are the total number of full years that have finished.
    ;; day-in-year is zero based.
    (MULTIPLE-VALUE-BIND (FULL-YEARS-PASSED DAY-IN-YEAR)
	(TRUNCATE DAYS 365.)
      (LET ((LEAP-YEAR-P (LEAP-YEAR-P (ABSOLUTE-YEAR FULL-YEARS-PASSED))))
	(DECF DAY-IN-YEAR (NUMBER-OF-LEAP-YEARS FULL-YEARS-PASSED))
	(LOOP WHILE (MINUSP DAY-IN-YEAR)
	      DO (DECF FULL-YEARS-PASSED)
		 (SETF LEAP-YEAR-P (LEAP-YEAR-P (ABSOLUTE-YEAR FULL-YEARS-PASSED)))
		 (INCF DAY-IN-YEAR (IF LEAP-YEAR-P 366. 365.)))
	(LET ((MD-ENTRY (AREF (IF LEAP-YEAR-P *LEAP-MONTH-DAY-TABLE* *REGULAR-MONTH-DAY-TABLE*)
			      DAY-IN-YEAR)))
	  (MULTIPLE-VALUE-BIND (HOURS SECONDS)
	      (FLOOR SECONDS 3600.)
	    (MULTIPLE-VALUE-BIND (MINUTES SECONDS)
		(FLOOR SECONDS 60.)
	      (VALUES SECONDS MINUTES HOURS
		      (1+ (LDB (BYTE 5 0) MD-ENTRY)) (1+ (LDB (BYTE 4 5) MD-ENTRY))
		      (ABSOLUTE-YEAR FULL-YEARS-PASSED)
		      (MOD (- DAYS *FIRST-MONDAY-IN-YEAR-ZERO*) 7)))))))))
#|| 
(defun date-dif (a b)
  (let ((ap (floor (time:parse-universal-time a ) 86400.))
	(bp (floor (time:parse-universal-time b) 86400.)))
    (- ap bp)))
;;
;;verify the decoder by checking that dates parse and decode
;;back to themselves.  Maybe not a perfect test, but pretty 
;;good.
;;
time:
(defun check-random-date (n)
  (loop repeat n
	as year = (+  1000. (random 2000.))
	as month = (1+ (random 12.))
	as day = (1+ (random 28))
	as str = (format nil "~A ~D, ~D"
			 (first (nth (1- month) *months*))
			 day
			 year)
	as parsed = (time:parse-universal-time str)
	do
    (multiple-value-bind (secs minutes hours pday pmonth pyear)
	(time:decode-universal-time parsed)
      (ignore secs minutes hours)
      (incf pyear 1900.)
      (unless (and (eql day pday)
		   (eql month pmonth)
		   (eql year pyear))
	(error "misparse of ~A as ~A ~D, ~D" str
	       (first (nth (1- pmonth) *months*))
	       pday
	       pyear
	       )))))
;;
;;verify the parser by checking that every year has the expected number
;;of days.  This will print the exceptions to the 365/366 rule, which
;;are the century years except the 0 mod 400 years, which are leap yers
;;any others indicate errors in the time parser.  At present, the parser
;;blows it on year 999.  Tough.
;;
(defun check-year-length ()
  (loop for i from 2200. downto 0 by 1
	as days = (time:date-dif (format nil "Jan 1 ~D" i)(format nil "Jan 1 ~D" (1- i)))
	as expected-days = (if (zerop (mod (1- i) 4)) 366. 365.)
	unless (eql days expected-days)
	  do (format t "~&~D = ~D " (1- i) days)))
||#

;; Takes Univeral Time (seconds since 1/1/1900) as a 32-bit number
(DEFUN CL:DECODE-UNIVERSAL-TIME (UNIVERSAL-TIME &OPTIONAL GIVEN-TIMEZONE)
  (DECLARE (VALUES SECS MINUTES HOURS DAY MONTH YEAR
		   DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P TIMEZONE))
  (DECLARE (ARGLIST UNIVERSAL-TIME &OPTIONAL (TIMEZONE *TIMEZONE*)))
  (LET* ((TIMEZONE (OR GIVEN-TIMEZONE *TIMEZONE*))
	 (OFFSET (- (ROUND (* TIMEZONE 3600.)))))
    (MULTIPLE-VALUE-BIND (SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
	(DECODE-UNIVERSAL-TIME-INTERNAL UNIVERSAL-TIME OFFSET)
      (LET ((DAYLIGHT-SAVINGS-P NIL))
	(WHEN (AND (NULL GIVEN-TIMEZONE)
		   (DAYLIGHT-SAVINGS-TIME-P HOURS DAY MONTH YEAR))
	  (MULTIPLE-VALUE (SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
	    (DECODE-UNIVERSAL-TIME-INTERNAL UNIVERSAL-TIME (+ OFFSET 3600.)))
	  (SETF DAYLIGHT-SAVINGS-P T))
	(VALUES SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P TIMEZONE)
	))))

;; Takes Univeral Time (seconds since 1/1/1900) as a 32-bit number
(DEFUN DECODE-UNIVERSAL-TIME (UNIVERSAL-TIME &OPTIONAL TIMEZONE)
  (DECLARE (VALUES SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P))
  (DECLARE (ARGLIST UNIVERSAL-TIME &OPTIONAL (TIMEZONE *TIMEZONE*)))
  (MULTIPLE-VALUE-BIND (SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P
			IGNORE)
      (CL:DECODE-UNIVERSAL-TIME UNIVERSAL-TIME TIMEZONE)
    (VALUES SECS MINUTES HOURS DAY MONTH (YEAR-RELATIVE-TO YEAR 1900.)
	    DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P)))

(DEFUN CL:GET-DECODED-TIME ()
  (DECLARE (VALUES SECOND MINUTE HOUR DATE MONTH YEAR
		   DAY-OF-WEEK DAYLIGHT-SAVINGS-TIME-P TIMEZONE))
  (MULTIPLE-VALUE-BIND (UT OFFSET)
      (GET-UNIVERSAL-TIME-AND-OFFSET)
    (DECF OFFSET (ROUND (* 3600. *TIMEZONE*)))
    (MULTIPLE-VALUE-BIND (SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
	(DECODE-UNIVERSAL-TIME-INTERNAL UT OFFSET)
      (LET ((DAYLIGHT-SAVINGS-P NIL))
	(WHEN (DAYLIGHT-SAVINGS-TIME-P HOURS DAY MONTH YEAR)
	  (MULTIPLE-VALUE (SECS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
	    (DECODE-UNIVERSAL-TIME-INTERNAL UT (+ OFFSET 3600.)))
	  (SETF DAYLIGHT-SAVINGS-P T))
	(VALUES SECS MINUTES HOURS DAY MONTH YEAR
		DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P *TIMEZONE*)))))

(DEFUN GET-TIME ()
  (AND *TIMEBASE-INITIALIZED*
       (MULTIPLE-VALUE-BIND (SECOND MINUTE HOUR DATE MONTH YEAR
			     DAY-OF-WEEK DAYLIGHT-SAVINGS-TIME-P IGNORE)
	   (CL:GET-DECODED-TIME)
	 (VALUES SECOND MINUTE HOUR DATE MONTH (YEAR-RELATIVE-TO YEAR 1900.)
		 DAY-OF-WEEK DAYLIGHT-SAVINGS-TIME-P))))

;;; Support for daylight savings time

(DEFUN DAYLIGHT-SAVINGS-TIME-P (HOURS DAY MONTH YEAR)
  (COND
    ;; Standard time if this timezone doesn't have daylight time
    ((NULL (THIRD (CL:ASSOC (1- *TIMEZONE*) *TIMEZONES*)))
     NIL)
    ;; Standard time if before 2 am first Sunday in April
    ((OR (< MONTH 4)
	 (AND (= MONTH 4)
	      (LET ((FSA (FIRST-SUNDAY-IN-APRIL YEAR)))
		(OR (< DAY FSA)
		    (AND (= DAY FSA) (< HOURS 2))))))
     NIL)
    ;; Standard time if after 1 am last Sunday in October
    ((OR (> MONTH 10.)
	 (AND (= MONTH 10.)
	      (LET ((LSO (LAST-SUNDAY-IN-OCTOBER YEAR)))
		(OR (> DAY LSO)
		    (AND (= DAY LSO) ( HOURS 1))))))
     NIL)
    (T T)))

(DEFUN FIRST-SUNDAY-IN-APRIL (YEAR)
  (WHEN (> YEAR 1000.)
    (SETQ YEAR (YEAR-RELATIVE-TO YEAR 1900.)))
  ;; This copied from GDWOBY routine in ITS
  (LET ((DOW-BEG-YEAR
	  (LET ((B (\ (+ YEAR 1899.) 400.)))
	    (\ (- (+ (1+ B) (SETQ B (// B 4))) (// B 25.)) 7)))
	(FEB29 (IF (LEAP-YEAR-P (ABSOLUTE-YEAR YEAR 1900.)) 1 0)))
    (LET ((DOW-APRIL-1 (\ (+ DOW-BEG-YEAR -1 90. FEB29) 7)))
      (- 7. DOW-APRIL-1))))

(DEFUN LAST-SUNDAY-IN-APRIL (YEAR)
  (WHEN (> YEAR 1000.)
    (SETQ YEAR (YEAR-RELATIVE-TO YEAR 1900.)))
  ;; This copied from GDWOBY routine in ITS
  (LET ((DOW-BEG-YEAR
	  (LET ((B (\ (+ YEAR 1899.) 400.)))
	    (\ (- (+ (1+ B) (SETQ B (// B 4))) (// B 25.)) 7)))
	(FEB29 (IF (LEAP-YEAR-P (ABSOLUTE-YEAR YEAR 1900.)) 1 0)))
    (LET ((DOW-APRIL-30 (\ (+ DOW-BEG-YEAR 119. FEB29) 7)))
      (- 30. DOW-APRIL-30))))

(DEFUN LAST-SUNDAY-IN-OCTOBER (YEAR)
  (LET ((LSA (LAST-SUNDAY-IN-APRIL YEAR)))
    ;; Days between April and October = 31+30+31+31+30 = 153  6 mod 7
    ;; Therefore the last Sunday in October is one less than the last Sunday in April
    ;; unless that gives 24. in which case it is 31, or 23, in which case it is 30.
    (SELECTOR LSA =
      (25. 31.)
      (24. 30.)
      (OTHERWISE (1- LSA)))))

;;; Returns universal time, as a 32-bit number of seconds since 1/1/00 00:00-GMT
(DEFUN ENCODE-UNIVERSAL-TIME (SECONDS MINUTES HOURS DAY MONTH YEAR
			      &OPTIONAL TIMEZONE)
  (SETQ YEAR (YEAR-RELATIVE-TO (CANONICALIZE-YEAR YEAR) *YEAR-ZERO*))
  (UNLESS TIMEZONE
    (SETQ TIMEZONE (IF (DAYLIGHT-SAVINGS-TIME-P HOURS DAY MONTH (ABSOLUTE-YEAR YEAR))
		       (1- *TIMEZONE*) *TIMEZONE*)))
  (LET ((DAYS-PASSED-SINCE-TIME-ZERO (+ (1- DAY) (AREF *CUMULATIVE-MONTH-DAYS-TABLE* MONTH)
					(* YEAR 365.) (NUMBER-OF-LEAP-YEARS YEAR))))
    (WHEN (AND (> MONTH 2) (LEAP-YEAR-P (ABSOLUTE-YEAR YEAR)))
      (INCF DAYS-PASSED-SINCE-TIME-ZERO))	;After 29-Feb in a leap year.
    (+ SECONDS (* 60. MINUTES) (* 3600. HOURS)
       (ROUND (* TIMEZONE 3600.))		;timezone can be a non-integer, e.g. NST=3.5
       (* DAYS-PASSED-SINCE-TIME-ZERO 86400.))))	;Return number of seconds.

;;; Maintenance functions

(DEFVAR *TIMEBASE-INITIALIZED* NIL)

;;; We start at 0 so that GET-UNIVERSAL-TIME can work before we know what time it is.
(DEFVAR *CURRENT-UNIVERSAL-TIME* 0)
(DEFVAR *LAST-UNIVERSAL-TIME-MICROSECONDS64-LOW* 0)
(DEFVAR *LAST-UNIVERSAL-TIME-MICROSECONDS64-HIGH* 0)
(DEFVAR *LAST-UNIVERSAL-TIME-RESIDUE* 0)
(DEFVAR *LAST-UNIVERSAL-TIME-SECONDS* 0)

;;; This function computes the number of seconds since the universal time was updated
;;; and the appropriate new values for the state variables.  It is used by GET-UNIVERSAL-TIME
;;; when it updates the current universal time.
(DEFUN GET-UNIVERSAL-TIME-1 ()
  (MULTIPLE-VALUE-BIND (LOW HIGH)
      (FULL-MICROSECOND-TIME)
    (LET ((LM64 (SYS:%LSHC-BIGNUM-STEP LOW HIGH (- 32. 6.)))
	  (HM64 (LSH HIGH -6.)))
      (MULTIPLE-VALUE-BIND (LDIFF BORROW)
	  (SYS:%SUB-BIGNUM-STEP LM64 *LAST-UNIVERSAL-TIME-MICROSECONDS64-LOW* 0)
	(LET* ((HDIFF (SYS:%SUB-BIGNUM-STEP HM64 *LAST-UNIVERSAL-TIME-MICROSECONDS64-HIGH*
					    BORROW))
	       (DIFF (+ LDIFF (ASH HDIFF 32.))))
	  (MULTIPLE-VALUE-BIND (SECONDS RESIDUE)
	      (FLOOR (+ *LAST-UNIVERSAL-TIME-RESIDUE* DIFF) (ASH 1000000. -6.))
	    (WHEN (PLUSP SECONDS)
	      (SETF *LAST-UNIVERSAL-TIME-MICROSECONDS64-LOW* LM64)
	      (SETF *LAST-UNIVERSAL-TIME-MICROSECONDS64-HIGH* HM64)
	      (SETF *LAST-UNIVERSAL-TIME-RESIDUE* RESIDUE)
	      (INCF *LAST-UNIVERSAL-TIME-SECONDS* SECONDS)
	      NIL)))))))

;;; This isn't allowed to return NIL, that breaks things.  Just returns what it knew last time.
(DEFUN GET-UNIVERSAL-TIME ()
  (DECLARE (VALUES SECONDS-SINCE-JANUARY-1-1900-GMT))
  (WITHOUT-INTERRUPTS
    (GET-UNIVERSAL-TIME-1)
    (IF (ZEROP *LAST-UNIVERSAL-TIME-SECONDS*)
	*CURRENT-UNIVERSAL-TIME*
	(INCF *CURRENT-UNIVERSAL-TIME* (CL:SHIFTF *LAST-UNIVERSAL-TIME-SECONDS* 0)))))

;;; A non-consing alternative to GET-UNIVERSAL-TIME.
(DEFUN GET-UNIVERSAL-TIME-AND-OFFSET ()
  (DECLARE (VALUES SECONDS-SINCE-JANUARY-1-1900-GMT SECONDS-SINCE-THEN))
  (WITHOUT-INTERRUPTS
    (GET-UNIVERSAL-TIME-1)
    (VALUES *CURRENT-UNIVERSAL-TIME* *LAST-UNIVERSAL-TIME-SECONDS*)))



;; This is no longer (25-Jun-86) used at boot time because the calendar 
;; clock is too unreliable for this service needed.
#||
;;; This is called during boot to set up the current time.
(DEFUN INITIALIZE-TIMEBASE-BOOT ()
  (LET ((UT (TIME:READ-CALENDAR-CLOCK)))
    (WHEN (NULL UT)
      ;; Calendar clock not set, try the network.
      (SETF UT (NETI:GET-TIME-FROM-NETWORK))
      (WHEN UT
	;; We now have a time, set the calendar clock, if possible.
	(CONDITION-CASE ()
	     (TIME:SET-CALENDAR-CLOCK UT)
	   (ERROR NIL))))
    (WHEN (NULL UT)
      ;; Still not set, ask the user.
      (SETF UT (LOOP FOR STRING = (PROMPT-AND-READ :STRING-OR-NIL
						   "Please type the date and time: ")
		     WHILE STRING
		     DO (CONDITION-CASE (ERROR)
			     (RETURN (PARSE-UNIVERSAL-TIME STRING))
			   (PARSE-ERROR
			     (PRINC ERROR QUERY-IO))))))
    (WHEN UT
      (INITIALIZE-TIMEBASE-INTERNAL UT))))
||#

(DEFUN INITIALIZE-TIMEBASE-INTERNAL (UT)
  (WITHOUT-INTERRUPTS
    (set-*timezone* *timezone*)
    (LET ((DIFF (- UT (TIME:GET-UNIVERSAL-TIME))))	;remember difference (new - old)
      (INCF *CURRENT-UNIVERSAL-TIME* DIFF)
      (SETF *TIMEBASE-INITIALIZED* T))))

(DEFVAR *INITIALIZE-TIMEBASE-FROM-CALENDAR-CLOCK* NIL
  "Skip trying to read from network or prompting user")

(DEFUN INITIALIZE-TIMEBASE (&OPTIONAL UT
			    (USE-NETWORK
			      (NOT (OR
				     *INITIALIZE-TIMEBASE-FROM-CALENDAR-CLOCK*
				     (STRING-EQUAL (SEND NET:*LOCAL-SITE* :STANDALONE)
						   "Yes")))))
  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Default method of getting time:  Try the network first and then the hardware clock
0  (FLET ((GET-TIME ()
	  (IF USE-NETWORK 
	      (SETQ UT (OR (NET:GET-TIME-FROM-NETWORK)
			   (READ-CALENDAR-CLOCK)))
	      (SETQ UT (READ-CALENDAR-CLOCK)))))
    (LET ((INITIALIZE-CALENDAR-CLOCK NIL))
      (WHEN (NULL UT)
	1;; The sequence of events is different for the various architectures
0	#+IMACH
	(SYS:SYSTEM-CASE
1	  ;; MacIvory0,1 Solstice, and Zora should read from the host clock first.
0	  ((Embedded Zora)
	    (SETQ UT (READ-CALENDAR-CLOCK))
	    (IF (NOT UT) (SETQ UT (NET:GET-TIME-FROM-NETWORK))))
1	  ;; XL400s should read from the network first.
0	  (OTHERWISE
	    (GET-TIME)))
1	;; 3600s try the network first.
0	#+3600
	(GET-TIME)
1	;; OK, test again to see if we have a time.  The above might have failed
	;; If we don't, then we have to prompt the user.
0	(WHEN (NULL UT)
	  (CL:WRITE-STRING "The current timezone is ")
	  (SCL:PRESENT *TIMEZONE* 'TIMEZONE)
	  (CL:FRESH-LINE)
	  (SETQ INITIALIZE-CALENDAR-CLOCK T)
	  (SETQ UT
		(LOOP FOR STRING = (PROMPT-AND-READ
			       :STRING
			       "Unable to get time from the network or the calendar clock.  ~&Please type the date and time:  ")
		WHILE STRING
		DO (CONDITION-CASE (ERROR)
			(RETURN (PARSE-UNIVERSAL-TIME STRING))
		      (PARSE-ERROR
			(PRINC ERROR QUERY-IO)))))))
1      ;; By this time, we are assured to have a UT, so initialize the timebase.
0      (INITIALIZE-TIMEBASE-INTERNAL UT)
1      ;; If we had to prompt the user, set the calendar-clock too.
0      (WHEN (AND INITIALIZE-CALENDAR-CLOCK  ( SYS:FEP-VERSION-NUMBER 17.))	1;Sigh
0	(SET-CALENDAR-CLOCK UT)))))

(ADD-INITIALIZATION "Forget time" '(SETQ *TIMEBASE-INITIALIZED* NIL) '(:SYSTEM-SHUTDOWN))

(DEFUN SET-LOCAL-TIME (&OPTIONAL NEW-TIME)
  (AND (STRINGP NEW-TIME)
       (SETQ NEW-TIME (TIME:PARSE-UNIVERSAL-TIME NEW-TIME)))
  (INITIALIZE-TIMEBASE NEW-TIME NIL))

(DEFUN SET-CALENDAR-CLOCK (NEW-TIME)
  (WHEN (STRINGP NEW-TIME) (SETQ NEW-TIME (TIME:PARSE-UNIVERSAL-TIME NEW-TIME)))
  (CHECK-ARG NEW-TIME FIXP "an integer")
  (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
      (TIME:DECODE-UNIVERSAL-TIME NEW-TIME 0)
    #+3600
    (UNLESS (FUNCALL (SELECTQ SYS:*IO-BOARD-TYPE*
		       (:OBS #'SI:SET-CALENDAR-CLOCK-INTERNAL)
		       (:NBS #'CLI::NBS-SET-CALENDAR-CLOCK-INTERNAL))
		     SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
      (FERROR "Unable to set calendar clock."))
    ;; There are two IMach system-cases here: the first one is for
    ;; setting hardware clocks, the second for embedding host clocks.
    ;; Some systems (e.g. Solstice) have both.
    #+IMACH
    (SYS:SYSTEM-CASE
      ((Merlin Zora)
       (UNLESS (CLI::MERLIN-SET-CALENDAR-CLOCK-INTERNAL
		 SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
	 (FERROR "Unable to set calendar clock.")))
      (Domino
	(UNLESS (CLI::DOMINO-SET-CALENDAR-CLOCK-INTERNAL
		  SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
	  (FERROR "Unable to set calendar clock.")))
      (Otherwise NIL))
    #+IMach
    (SYS:SYSTEM-CASE
      (Solstice
	(RPC::SOLSTICE-SET-CALENDAR-CLOCK-INTERNAL NEW-TIME :ERROR-P T))
      (MACIVORY
	(UNLESS (MACINTOSH-INTERNALS::MACIVORY-SET-CALENDAR-CLOCK-INTERNAL NEW-TIME)
	  (FERROR "Unable to set calendar clock.")))
      (VLM
	(UNLESS (CLI::VLM-SET-CALENDAR-CLOCK-INTERNAL
		  SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
	  (FERROR "Unable to set calendar clock.")))
      (Otherwise NIL))
    )
  NIL)

(DEFUN READ-CALENDAR-CLOCK (&OPTIONAL EVEN-IF-BAD)
  (DECLARE (VALUES UT-OR-NIL))
  (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
      (PROGN
	#+3600
	(FUNCALL (SELECTQ SYS:*IO-BOARD-TYPE*
		   (:OBS #'SI:READ-CALENDAR-CLOCK-INTERNAL)
		   (:NBS #'CLI::NBS-READ-CALENDAR-CLOCK-INTERNAL))
		 EVEN-IF-BAD)
	#+IMACH
	(SYS:SYSTEM-CASE
	  (Solstice
	    (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
		(CLI::SOLSTICE-READ-CALENDAR-CLOCK-INTERNAL)
	      (IF SECONDS
		  (VALUES SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-WEEK)
		  (CLI::MERLIN-READ-CALENDAR-CLOCK-INTERNAL EVEN-IF-BAD))))
	  ((Merlin Zora)
	   (CLI::MERLIN-READ-CALENDAR-CLOCK-INTERNAL EVEN-IF-BAD))
	  (MACIVORY
	    (MACINTOSH-INTERNALS::MACIVORY-READ-CALENDAR-CLOCK-INTERNAL))
	  (Domino
	    (CLI::DOMINO-READ-CALENDAR-CLOCK-INTERNAL EVEN-IF-BAD))
	  (VLM
	    (CLI::VLM-READ-CALENDAR-CLOCK-INTERNAL EVEN-IF-BAD))
	  (OTHERWISE NIL)))
    DAY-OF-WEEK					;not needed
    (AND SECONDS				;values returned
	 (AND (<= 0 SECONDS 59.)
	      (<= 0 MINUTES 59.)
	      (<= 0 HOURS 23.)
	      (<= 1 MONTH 12.)
	      (<= 85. YEAR 99.))
	 (TIME:ENCODE-UNIVERSAL-TIME SECONDS MINUTES HOURS DAY MONTH YEAR 0))))

;;; This is a stub.  The timebase is now updated by the sequence-break handler.
(DEFUN UPDATE-TIMEBASE ()
  *TIMEBASE-INITIALIZED*)

;;; One-based lengths of months
(DEFVAR *MONTH-LENGTHS* '(0 31. 28. 31. 30. 31. 30. 31. 31. 30. 31. 30. 31.))

(DEFUN MONTH-LENGTH (MONTH YEAR)
  (IF (= MONTH 2)
      (IF (LEAP-YEAR-P YEAR) 29. 28.)
      (NTH MONTH *MONTH-LENGTHS*)))

(DEFUN LEAP-YEAR-P (YEAR)
  (SETQ YEAR (CANONICALIZE-YEAR YEAR))
  (AND (ZEROP (\ YEAR 4))
       (OR (NOT (ZEROP (\ YEAR 100.)))
	   (ZEROP (\ YEAR 400.)))))

(DEFUN DAYLIGHT-SAVINGS-P (&OPTIONAL (*TIMEZONE* *TIMEZONE*))
  (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL NIL NIL NIL DST-P)
      (GET-TIME)
    DST-P))

(DEFUN DEFAULT-YEAR ()
  (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL NIL YEAR)
      (GET-TIME)
    YEAR))

(DEFUN PRINT-CURRENT-TIME (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (AND *TIMEBASE-INITIALIZED*
       (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR)
	   (GET-TIME)
         (PRINT-TIME SECONDS MINUTES HOURS DAY MONTH YEAR STREAM))))

(FORMAT:DEFFORMAT FORMAT:DATIME (:NO-ARG) (IGNORE)
  (WHEN *TIMEBASE-INITIALIZED*
    (LET ((UT (GET-UNIVERSAL-TIME)))
      (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM FORMAT:*FORMAT-OUTPUT*
				       :OBJECT UT
				       :TYPE 'UNIVERSAL-TIME)
	(PRINT-UNIVERSAL-TIME UT FORMAT:*FORMAT-OUTPUT*)))))

(DEFUN PRINT-UNIVERSAL-TIME (UT &OPTIONAL (STREAM STANDARD-OUTPUT) TIMEZONE)
  ;;Let DECODE-UNIVERSAL-TIME default the timezone if wanted, as that fcn
  ;;must know to suppress DST iff TIMEZONE is supplied.
  (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR)
      (DECODE-UNIVERSAL-TIME UT TIMEZONE)
    (PRINT-TIME SECONDS MINUTES HOURS DAY MONTH YEAR STREAM)))

(FORMAT:DEFFORMAT FORMAT:TIME (:ONE-ARG) (UT IGNORE)
  (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM FORMAT:*FORMAT-OUTPUT*
				   :OBJECT UT
				   :TYPE 'UNIVERSAL-TIME)
    (PRINT-UNIVERSAL-TIME UT FORMAT:*FORMAT-OUTPUT*))
  )

;; Can be :MM/DD/YY, :MM/DD/YYYY, :DD-MMM-YY, :DD-MMM-YYYY, or :ISO
(DEFVAR *DATE-PRINTING-FORMAT* :MM//DD//YY)

(ADD-INITIALIZATION "Establish date printing format"
   '(LET* ((USER-PROPERTIES (SEND NET:*LOCAL-SITE* :GET :USER-PROPERTY))
	   (DATE-PRINTING-FORMAT (SECOND (ASSQ :DATE-PRINTING-FORMAT USER-PROPERTIES))))
      (WHEN DATE-PRINTING-FORMAT
	(LET ((DPF (INTERN (STRING-UPCASE DATE-PRINTING-FORMAT) PKG-KEYWORD-PACKAGE)))
	  (WHEN (MEMQ DPF '(:MM//DD//YY :MM//DD//YYYY :DD-MMM-YY :DD-MMM-YYYY :ISO))
	    (SETQ-GLOBALLY *DATE-PRINTING-FORMAT* DPF)))))
   '(:SITE))

(DEFFLAVOR TIME-FORMAT-ERROR (EXISTING-FORMAT SUBSTITUTE-FORMAT)
	   (ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(DEFMETHOD (DBG:REPORT TIME-FORMAT-ERROR) (STREAM)
  (FORMAT STREAM "Can't print time using ~A format" EXISTING-FORMAT))

(DEFMETHOD (SYS:PROCEED TIME-FORMAT-ERROR :USE-LONG-FORMAT) ()
  (VALUES :USE-LONG-FORMAT))

(DEFMETHOD (DBG:DOCUMENT-PROCEED-TYPE TIME-FORMAT-ERROR :USE-LONG-FORMAT)
	   (STREAM)
  (FORMAT STREAM "Use ~A format instead" SUBSTITUTE-FORMAT))

(COMPILE-FLAVOR-METHODS TIME-FORMAT-ERROR)

(DEFMACRO WITH-LONG-DATE-FORMAT-IF-NEEDED (&BODY BODY)
  `(CONDITION-BIND
     ((TIME-FORMAT-ERROR #'(LAMBDA (ERROR)
			     (WHEN (DBG:PROCEED-TYPE-P ERROR :USE-LONG-FORMAT)
			       (DBG:PROCEED ERROR :USE-LONG-FORMAT)))))
     . ,BODY))

(DEFUN PRINT-TIME (SECONDS MINUTES HOURS DAY MONTH YEAR &OPTIONAL (STREAM STANDARD-OUTPUT)
		   (REF-UT (GET-UNIVERSAL-TIME)))
  (SETQ YEAR (YEAR-RELATIVE-TO (CANONICALIZE-YEAR YEAR) *YEAR-ZERO*))
  (LET ((*DATE-PRINTING-FORMAT* *DATE-PRINTING-FORMAT*))
    (WHEN (MEMQ *DATE-PRINTING-FORMAT* '(:MM//DD//YY :DD-MMM-YY))
      (MULTIPLE-VALUE-BIND (IGNORE IGNORE IGNORE IGNORE IGNORE REF-YEAR)
	  (DECODE-UNIVERSAL-TIME REF-UT)
	(IF (<= -50. (- YEAR REF-YEAR) 49.)
	    (SETQ YEAR (MOD YEAR 100.))
	  (LET ((NEW-FORMAT (SELECTQ *DATE-PRINTING-FORMAT*
			      (:MM//DD//YY :MM//DD//YYYY)
			      (:DD-MMM-YY :DD-MMM-YYYY))))
	    (SIGNAL-PROCEED-CASE (() 'TIME-FORMAT-ERROR
				  :EXISTING-FORMAT *DATE-PRINTING-FORMAT*
				  :SUBSTITUTE-FORMAT NEW-FORMAT)
	      (:USE-LONG-FORMAT (SETQ *DATE-PRINTING-FORMAT* NEW-FORMAT)))))))
    (FLET ((PRINT-IT (STREAM)
	     (CL:ECASE *DATE-PRINTING-FORMAT*
	       (:MM//DD//YY
		(FORMAT STREAM "~D//~2,'0D//~2,'0D"
			MONTH DAY YEAR))
	       (:MM//DD//YYYY
		(FORMAT STREAM "~D//~2,'0D//~4D"
			MONTH DAY (+ *YEAR-ZERO* YEAR)))
	       (:DD-MMM-YY
		(FORMAT STREAM "~D-~A-~2,'0D"
			DAY (FIRST (NTH (1- MONTH) *MONTHS*)) YEAR))
	       (:DD-MMM-YYYY
		(FORMAT STREAM "~D-~A-~4D"
			DAY (FIRST (NTH (1- MONTH) *MONTHS*)) (+ *YEAR-ZERO* YEAR)))
	       (:ISO
		(FORMAT STREAM "~4D-~2,'0D-~2,'0D"
			(+ *YEAR-ZERO* YEAR) MONTH DAY)))
	     (FORMAT STREAM " ~2,'0D:~2,'0D:~2,'0D" HOURS MINUTES SECONDS)))
      (IF (NULL STREAM)
	  (CL:WITH-OUTPUT-TO-STRING (STRING-STREAM)
	    (PRINT-IT STRING-STREAM))
	  (PRINT-IT STREAM)))))

(DEFUN PRINT-CURRENT-DATE (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (AND *TIMEBASE-INITIALIZED*
       (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
	   (GET-TIME)
         (PRINT-DATE SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK STREAM))))

(DEFUN PRINT-UNIVERSAL-DATE (UT &OPTIONAL (STREAM STANDARD-OUTPUT) TIMEZONE)
  (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK)
      (DECODE-UNIVERSAL-TIME UT TIMEZONE)
    (PRINT-DATE SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK STREAM)))

(FORMAT:DEFFORMAT FORMAT:DATE (:ONE-ARG) (UT IGNORE)
  (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM FORMAT:*FORMAT-OUTPUT*
				   :OBJECT UT
				   :TYPE 'UNIVERSAL-TIME)
    (PRINT-UNIVERSAL-DATE UT FORMAT:*FORMAT-OUTPUT*)))

(DEFUN PRINT-DATE (SECONDS MINUTES HOURS DAY MONTH YEAR DAY-OF-THE-WEEK
		   &OPTIONAL (STREAM STANDARD-OUTPUT))
  (SETQ MONTH (MONTH-STRING MONTH)
	DAY-OF-THE-WEEK (DAY-OF-THE-WEEK-STRING DAY-OF-THE-WEEK)
	YEAR (CANONICALIZE-YEAR YEAR))
  (FORMAT STREAM
	  "~A the ~:R of ~A, ~D/; ~D:~2,48D:~2,48D ~A"
	  DAY-OF-THE-WEEK DAY MONTH YEAR (1+ (\ (+ HOURS 11.) 12.)) MINUTES SECONDS
	  (COND ((AND (ZEROP SECONDS)
		      (ZEROP MINUTES)
		      (MEMQ HOURS '(0 12.)))
		 (IF (= HOURS 0) "midnight" "noon"))
		(( HOURS 12.) "pm")
		(T "am")) ))

(DEFUN PRINT-BRIEF-UNIVERSAL-TIME (UT &OPTIONAL (STREAM STANDARD-OUTPUT)
				   (REF-UT (GET-UNIVERSAL-TIME)))
  "Prints only those aspects of the time, UT, that differ from the current time.
Always prints hours and minutes; never prints seconds."
  (MULTIPLE-VALUE-BIND (IGNORE MINUTES HOURS DAY MONTH YEAR)
      (DECODE-UNIVERSAL-TIME UT)
    (MULTIPLE-VALUE-BIND (IGNORE IGNORE IGNORE REF-DAY REF-MONTH REF-YEAR)
	(DECODE-UNIVERSAL-TIME REF-UT)
      (LET ((YEAR-DIGITS 2)
	    (SHORT-YEAR YEAR))
	(IF (<= -50. (- YEAR REF-YEAR) 49.)
	  (SETQ SHORT-YEAR (MOD YEAR 100.))
	  (PROGN
	    (SETQ YEAR-DIGITS 4
		  SHORT-YEAR (+ YEAR *YEAR-ZERO*))
	  (WHEN (MEMQ *DATE-PRINTING-FORMAT* '(:MM//DD//YY :DD-MMM-YY))
	    (LET ((NEW-FORMAT (SELECTQ *DATE-PRINTING-FORMAT*
				(:MM//DD//YY :MM//DD//YYYY)
				(:DD-MMM-YY :DD-MMM-YYYY))))
	      (CL:CERROR "Use ~*~A format instead" "Can't print time using ~A format"
			 *DATE-PRINTING-FORMAT*
			 NEW-FORMAT)))))
	(FLET ((PRINT-IT (STREAM)
		 ;; If not same day, print month and day numerically
		 ;; If not same year, print year
		 ;; Always print hours colon minutes, even if same as now
		 (UNLESS (AND (= DAY REF-DAY) (= MONTH REF-MONTH) (= YEAR REF-YEAR))
		   (CL:ECASE *DATE-PRINTING-FORMAT*
		     ((:MM//DD//YY :MM//DD//YYYY)
		      (FORMAT STREAM "~D//~2,'0D" MONTH DAY)
		      (WHEN ( YEAR REF-YEAR)
			(FORMAT STREAM "//~V,'0D"
				YEAR-DIGITS
				SHORT-YEAR)))
		     (:ISO
		      ;; Always a 4-digit year
		      (FORMAT STREAM "~4D-~2,'0D-~2,'0D"
			      (+ *YEAR-ZERO* YEAR) MONTH DAY))
		     ((:DD-MMM-YY :DD-MMM-YYYY)
		      (FORMAT STREAM "~D-~A" DAY (FIRST (NTH (1- MONTH) *MONTHS*)))
		      (WHEN ( YEAR REF-YEAR)
			(FORMAT STREAM "-~V,'0D"
				YEAR-DIGITS
				SHORT-YEAR))))
		   (TYO #/SPACE STREAM))
		 (FORMAT STREAM "~2,'0D:~2,'0D" HOURS MINUTES)))
	  (IF (NULL STREAM)
	      (CL:WITH-OUTPUT-TO-STRING (STRING-STREAM)
		(PRINT-IT STRING-STREAM))
	      (PRINT-IT STREAM)))))))


;;; Some useful strings and accessing functions.

;;; Days of the week.  Elements must be (in order):
;;; (1) Three-letter form.
;;; (2) Full spelling.
;;; (3) Middle-length form if any, else NIL.
;;; (4) Francais.
;;; (5) Deutsch.
;;; (6) Italiano.
(DEFVAR *DAYS-OF-THE-WEEK* '(("Mon" "Monday" NIL "lundi" "Montag" "Lunedi")
			     ("Tue" "Tuesday" "Tues" "mardi" "Dienstag" "Martedi")
			     ("Wed" "Wednesday" NIL "mercredi" "Mittwoch" "Mercoledi")
			     ("Thu" "Thursday" "Thurs" "jeudi" "Donnerstag" "Giovedi")
			     ("Fri" "Friday" NIL "vendredi" "Freitag" "Venerdi")
			     ("Sat" "Saturday" NIL "samedi" "Samstag" "Sabato")
			     ("Sun" "Sunday" NIL "dimanche" "Sonntag" "Domenica")
			     ))

(DEFUN DAY-OF-THE-WEEK-STRING (DAY-OF-THE-WEEK &OPTIONAL (MODE ':LONG) &AUX STRINGS)
  (SETQ STRINGS (NTH DAY-OF-THE-WEEK *DAYS-OF-THE-WEEK*))
  (SELECTQ MODE
    (:SHORT (FIRST STRINGS))
    (:LONG (SECOND STRINGS))
    (:MEDIUM (OR (THIRD STRINGS) (FIRST STRINGS)))
    (:FRENCH (FOURTH STRINGS))
    (:GERMAN (FIFTH STRINGS))
    (:ITALIAN (SIXTH STRINGS))
    (OTHERWISE (FERROR NIL "~S is not a known mode" MODE))))


;;; Months of the year:  Elements must be (in order):
;;; (1) Three-letter form.
;;; (2) Full spelling.
;;; (3) Middle-length form if any, else NIL.
;;; (4) Francais.
;;; (5) Roman numerals (used in Europe).
;;; (6) Deutsch.
;;; (7) Italiano.
(DEFVAR *MONTHS* '(("Jan" "January" NIL "janvier" "I" "Januar" "Gennaio")
		   ("Feb" "February" NIL "fevrier" "II" "Februar" "Febbraio")
		   ("Mar" "March" NIL "mars" "III" "Maerz" "Marzo")
		   ("Apr" "April" NIL "avril" "IV" "April" "Aprile")
		   ("May" "May" NIL "mai" "V" "Mai" "Maggio")
		   ("Jun" "June" NIL "juin" "VI" "Juni" "Giugno")
		   ("Jul" "July" NIL "juillet" "VII" "Juli" "Luglio")
		   ("Aug" "August" NIL "aout" "VIII" "August" "Agosto")
		   ("Sep" "September" "Sept" "septembre" "IX" "September" "Settembre")
		   ("Oct" "October" NIL "octobre" "X" "Oktober" "Ottobre")
		   ("Nov" "November" "Novem" "novembre" "XI" "November" "Novembre")
		   ("Dec" "December" "Decem" "decembre" "XII" "Dezember" "Dicembre")
		   ))

(DEFUN MONTH-STRING (MONTH &OPTIONAL (MODE ':LONG) &AUX STRINGS)
  (SETQ STRINGS (NTH (1- MONTH) *MONTHS*))
  (SELECTQ MODE
    (:SHORT (FIRST STRINGS))
    (:LONG (SECOND STRINGS))
    (:MEDIUM (OR (THIRD STRINGS) (FIRST STRINGS)))
    (:FRENCH (FOURTH STRINGS))
    (:ROMAN (FIFTH STRINGS))
    (:GERMAN (SIXTH STRINGS))
    (:ITALIAN (SEVENTH STRINGS))
    (OTHERWISE (FERROR NIL "~S is not a known mode" MODE))))

;;;Format of the timezone list:
;;;  1st element is the offset from GMT, in our internal representation.  Positive
;;;numbers are west of GMT and negative numbers are east of GMT.  This is the opposite
;;;of the printed representation of timezone.  For example the internal representation of
;;;EST is 5 but its printed representation could be EST or -0500.
;;;  2nd element of the list is the an accepted symbol representing this timezone.  If 
;;;this element is NIL then we don't know of an accepted symbol.
;;;  3rd element of the list (if non-Nil) is a symbol representing a daylight savings
;;;time.  There are some standard times for which we have rules for deciding if it
;;;is currently daylight savings time there.  The rules are defined by 
;;;TIME:DAYLIGHT-SAVINGS-TIME-P.
;;;The symbol representing the daylight savings version of a timezone that switches to 
;;;daylight savings time automatically according to those rules (EDT vs. EST for example)
;;;does not appear as the second element of any of these lists.  You won't find a second
;;;element containing EDT or PDT for example.  Other daylight or summer times for which
;;;we don't have rules -do- appear as real timezones in the second element of some list
;;;and the site's timezone does not automatically change.
;;;For example, users will have to manually change their timezone from MET to MEST
;;;at the right time of year.

(DEFVAR *TIMEZONES*
	'((12. NIL NIL #/M)
	  (11. "NT" NIL NIL)			;Nome Time
	  (11. "BST" NIL #/L)			;Bering
	  (10. "HST" "BDT" #/K)			;Hawaiian
	  (10. "AHST" NIL NIL)			;Alaska-Hawaii Standard Time
	  (9. "YST" "HDT" #/I)			;Yukon Standard Time
	  (8. "PST" "YDT" #/H)			;Pacific Standard Time
	  (7. "MST" "PDT" #/G)			;Mountain Standard Time
	  (6. "CST" "MDT" #/F)			;Central Standard Time
	  (5. "EST" "CDT" #/E)			;Eastern Standard Time
	  (4. "AST" "EDT" #/D)			;Atlantic Standard Time
	  (3.5 "NST" NIL -1)			;Newfoundland Standard Time.  Why is -1 here?
	  (3. "GST" "ADT" #/C)			;Greenland  Standard Time
	  (2. "AT" NIL #/B)			;Azores Time
	  (1. "WAT" NIL #/A)			;West Africa Time
	  (0. "UT" NIL NIL)			;Universal Time
	  (0. "Z" NIL NIL)			;Universal Time
	  (0. "GMT" NIL #/Z)			;Greenwich Mean Time
	  (-1. "CET" NIL #/N)			;Central European Time
	  (-1. "MET" NIL NIL)			;Middle Europe Time
	  (-1. "MEWT" NIL NIL)			;Middle Europe Winter Time
	  (-1. "BST" NIL NIL)			;British Summer Time
	  (-1. "SWT" NIL NIL)			;Swedish Winter Time
	  (-1. "FWT" NIL NIL)			;French Winter Time
	  (-2. "MEST" NIL NIL)			;Middle Europe Summer Time
	  (-2. "EET" NIL #/O)			;Eastern European Time
	  (-2. "SST" NIL NIL)			;Swedish Summer Time
	  (-2. "FST" NIL NIL)			;French Summer Time
	  (-3. "BT" NIL #/P)			;Baghdad Time
	  (-4. "ZP4" NIL #/Q)			;GMT +4  hours.
	  (-5. "ZP5" NIL #/R)			;GMT +5  hours.
	  (-5.5 "IST" NIL NIL)			;Indian Standard Time
	  (-6. "ZP6" NIL NIL)			;GMT +6  hours.
	  (-7. "WAST" NIL #/T)			;West Australian Standard Time
	  (-7.5 "JT" NIL NIL)			;Java Time
	  (-8. "WADT" NIL #/U)			;West Australian Daylight Time
	  (-8. "CCT" NIL NIL)			;China Coast Time
	  (-9. "JST" NIL #/V)			;Japan Standard Time
	  (-9.5 "CAST" NIL NIL)			;Central Australian Standard Time
	  (-9.5 "SAST" NIL NIL)			;South Australian Standard Time
	  (-10. "EAST" NIL #/W)			;East Australian Standard Time
	  (-10.5 "CADT" NIL NIL)		;Central Australian Daylight Time
	  (-10.5 "SADT" NIL NIL)		;South Australian Daylight Time
	  (-11. "EADT" NIL #/X)			;East Australian Daylight Time
	  (-12. "NZT" NIL NIL)			;New Zealand Time
	  (-13. "NZD" NIL NIL)))		;New Zealand Daylight Time

;;;Given a fixnum or flonum multiple of .5 return a signed string permissable to
;;;RFC822 like +0500.
;;;The printed representation of timezones is exactly the oposite of our
;;;internal representation, e.g. if our local timezone were printed as -0500
;;;then *timezone* would be +5.
(DEFUN ENCODE-NUMERIC-TIMEZONE (NUMBER &AUX (SIGN (MINUSP NUMBER)) HOURS MINUTES)
  (MULTIPLE-VALUE (HOURS MINUTES)
    (TRUNCATE (ABS NUMBER)))
  (FORMAT NIL "~:[-~;+~]~4,'0D" SIGN (+ (* 100. HOURS) (ROUND (* 60. MINUTES)))))

;;;Return a string for the given timezone.
;;;When PUNCTUATE is non-NIL, return a timezone string with leading punctuation:
;;;#\space for timezones that have mnemonics, e.g. " EST"
;;;#\-     for zones west of GMT, e.g. "-0300"
;;;#\+     for zones east of GMT, e.g. "+0100"
(DEFUN TIMEZONE-STRING (&OPTIONAL (TIMEZONE *TIMEZONE*)
			(DAYLIGHT-SAVINGS-P (DAYLIGHT-SAVINGS-P TIMEZONE))
			;;These should be keywords.  There are no callers
			;;that use these arguments except the ones I've changed.
			FORCE-NUMERIC-P PUNCTUATE)
  (LET* ((OFFSET (IF DAYLIGHT-SAVINGS-P (1- TIMEZONE) TIMEZONE))
	 (ENTRY (CL:FIND OFFSET *TIMEZONES* :TEST #'= :KEY #'FIRST))
	 (N-ENTRIES (CL:COUNT OFFSET *TIMEZONES* :TEST #'= :KEY #'FIRST))
	 (STRING (IF DAYLIGHT-SAVINGS-P (THIRD ENTRY)
		      (SECOND ENTRY))))
    ;;If caller wants a number, or there's more than one symbol and we can't
    ;;decide, or there's no symbol, then just use a numeric representation
    (IF (OR FORCE-NUMERIC-P (NOT (= N-ENTRIES 1)) (NOT STRING))
	(ENCODE-NUMERIC-TIMEZONE OFFSET)
	(IF PUNCTUATE
	    (FORMAT NIL " ~A" STRING)
	    STRING))))

;;;Return a timezone string with leading punctuation:
;;;#\space for timezones that have mnemonics, e.g. " EST"
;;;#\-     for zones west of GMT, e.g. "-0300"
;;;#\+     for zones east of GMT, e.g. "+0100"
(DEFUN PUNCTUATED-TIMEZONE-STRING (&OPTIONAL (TIMEZONE *TIMEZONE*)
				  (DAYLIGHT-SAVINGS-P (DAYLIGHT-SAVINGS-P TIMEZONE))
				  FORCE-NUMERIC)
  (TIMEZONE-STRING TIMEZONE DAYLIGHT-SAVINGS-P FORCE-NUMERIC T))


;;; NORMAL since ACCEPT-FROM-STRING not defined during bootstrapping.
(ADD-INITIALIZATION "SITE-TIMEZONE-INITIALIZE" '(SITE-TIMEZONE-INITIALIZE) '(SITE NORMAL))

;;; Date and time parsing

;;; Check that a date is ok: day is within month; and day-of-week, if specified, is valid
(DEFUN VERIFY-DATE (DAY MONTH YEAR DAY-OF-THE-WEEK)
  (COND ((> DAY (MONTH-LENGTH MONTH YEAR))
	 (FORMAT NIL "~A only has ~D day~:P" (MONTH-STRING MONTH) (MONTH-LENGTH MONTH YEAR)))
	(DAY-OF-THE-WEEK
	 (LET ((UT (ENCODE-UNIVERSAL-TIME 0 0 0 DAY MONTH YEAR)))
	   (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL NIL NIL CORRECT-DAY-OF-THE-WEEK)
	       (DECODE-UNIVERSAL-TIME UT)
	     (AND ( DAY-OF-THE-WEEK CORRECT-DAY-OF-THE-WEEK)
		  (FORMAT NIL "~A the ~:R ~D is a ~A, not a ~A"
			  (MONTH-STRING MONTH) DAY YEAR
			  (DAY-OF-THE-WEEK-STRING CORRECT-DAY-OF-THE-WEEK)
			  (DAY-OF-THE-WEEK-STRING DAY-OF-THE-WEEK))))))
	(T
	 NIL)))

#||
(DEFUN TEST ()
  (DO ((LINE)) (NIL)
    (TERPRI)
    (SETQ LINE (READLINE))
    (AND (EQUAL LINE "") (RETURN NIL))
    (MULTIPLE-VALUE-BIND (SECONDS NIL DAY MONTH YEAR NIL NIL ERRMES)
	(PARSE-DATE-AND-TIME LINE)
      (IF ERRMES
	  (PRINC ERRMES)
	  (PRINT-DATE-AND-TIME SECONDS DAY MONTH YEAR)))))

(DEFUN PRINT-DATE-AND-TIME (SECONDS MINUTES HOURS DAY MONTH YEAR &AUX MINUTES HOURS)
  (SETQ	MONTH (MONTH-STRING MONTH ':SHORT))
  (FORMAT T "~D-~A-~D ~D:~2,48D:~2,48D"
	  DAY MONTH YEAR HOURS MINUTES SECONDS))
||#

#||
;;;
;;;  the following routines are obsolete!!
;;;

;; Takes Univeral Time (seconds since 1/1/1900) as a 32-bit number
;; Algorithm from KLH's TIMRTS.
(DEFUN TIME-BREAK-UNIVERSAL (UNIVERSAL-TIME &OPTIONAL (TIMEZONE *TIMEZONE*)
					    &AUX SECS DAY MONTH YEAR DAY-OF-THE-WEEK DST-P)
  (DECLARE (RETURN-LIST SECS DAY MONTH YEAR DAY-OF-THE-WEEK DAYLIGHT-SAVINGS-P))
  (MULTIPLE-VALUE (SECS DAY MONTH YEAR DAY-OF-THE-WEEK)
    (TIME-BREAK-UNIVERSAL-WITHOUT-DST UNIVERSAL-TIME TIMEZONE))
  (AND (SETQ DST-P (DAYLIGHT-SAVINGS-TIME-P (\ SECS 3600.) DAY MONTH YEAR))
       ;; See if it's daylight savings time, time-zone number gets smaller if so.
       (MULTIPLE-VALUE (SECS DAY MONTH YEAR DAY-OF-THE-WEEK)
	 (TIME-BREAK-UNIVERSAL-WITHOUT-DST UNIVERSAL-TIME (1- TIMEZONE))))
  (VALUES SECS DAY MONTH YEAR DAY-OF-THE-WEEK DST-P))

(DEFUN TIME-BREAK-UNIVERSAL-WITHOUT-DST (UNIVERSAL-TIME &OPTIONAL (TIMEZONE *TIMEZONE*)
							&AUX X SECS DAY MONTH YEAR)
  (DECLARE (RETURN-LIST SECS DAY MONTH YEAR DAY-OF-THE-WEEK))
  (SETQ UNIVERSAL-TIME (- UNIVERSAL-TIME (* TIMEZONE 3600.)))
  (SETQ SECS (\ UNIVERSAL-TIME 86400.)		;(* 24. 60. 60.)
	X (// UNIVERSAL-TIME 86400.))		;Days since genesis.
  (LET ((B (\ X 365.))
	(A (// X 365.)))
    (COND ((NOT (ZEROP A))
	   (SETQ B (- B (LSH (1- A) -2)))
	   (COND ((< B 0)
		  (SETQ A (1- A))
		  (SETQ B (+ B 365.))
		  (AND (NOT (BIT-TEST A 3))
		       (SETQ B (1+ B)))))))
    (DO ((C 12. (1- C)))
	(( B (AREF *CUMULATIVE-MONTH-DAYS-TABLE* C))
	 (COND ((AND (NOT (BIT-TEST A 3))
		     (> C 2))
		(SETQ B (1- B))
		(AND (< B (AREF *CUMULATIVE-MONTH-DAYS-TABLE* C))
		     (SETQ C (1- C)))
		(AND (= C 2)
		     (SETQ B (1+ B)))))
	 (SETQ B (- B (AREF *CUMULATIVE-MONTH-DAYS-TABLE* C)))
	 (SETQ YEAR A)
	 (SETQ MONTH C)
	 (SETQ DAY (1+ B)))))
  (VALUES SECS DAY MONTH YEAR (\ (- X *FIRST-MONDAY-IN-YEAR-ZERO*) 7)))

;;; These are the functions the user should call
;;; If they can't find out what time it is, they return NIL

(DEFUN WHAT-TIME (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (AND *TIMEBASE-INITIALIZED*
       (MULTIPLE-VALUE-BIND (SECONDS MINUTES HOURS DAY MONTH YEAR)
	   (GET-TIME)
         (AND STREAM (TERPRI STREAM))
         (PRINT-TIME STREAM SECONDS MINUTES HOURS DAY MONTH YEAR))))

(DEFUN TIME-PRINT-UNIVERSAL (UT &OPTIONAL (STREAM STANDARD-OUTPUT) (TIMEZONE *TIMEZONE*))
  (MULTIPLE-VALUE-BIND (SECONDS DAY MONTH YEAR)
      (TIME-BREAK-UNIVERSAL UT TIMEZONE)
    (LET (MINUTES HOURS)
      (SETQ MINUTES (// SECONDS 60.)
	    SECONDS (\ SECONDS 60.))
      (SETQ HOURS (// MINUTES 60.)
	    MINUTES (\ MINUTES 60.))
      (PRINT-TIME STREAM SECONDS MINUTES HOURS DAY MONTH YEAR))))

||#



(ADD-INITIALIZATION "Initialize Time Base" '(INITIALIZE-TIMEBASE) '(:NOW)
		    'NETI:AFTER-ALL-NETWORKS-INITIALIZATION-LIST)

;;; Using a timer to update the universal time every fifteen minutes ensures
;;; that the clock won't stop if nothing asks for the universal for more than
;;; 36 minutes.  (E.g., if running on an NXP1000 without a console.):
(CL:DEFPARAMETER *UPDATE-UNIVERSAL-TIME-INTERVAL* (* 15. 60.))

(DEFVAR *UPDATE-UNIVERSAL-TIME-TIMER*
	(PROCESS:CREATE-TIMER-CALL 'UPDATE-UNIVERSAL-TIME () :NAME "Update Universal Time"))

(DEFUN UPDATE-UNIVERSAL-TIME ()
  (GET-UNIVERSAL-TIME-1)
  (PROCESS:RESET-TIMER-RELATIVE *UPDATE-UNIVERSAL-TIME-TIMER* *UPDATE-UNIVERSAL-TIME-INTERVAL*)
  NIL)

(ADD-INITIALIZATION "Update Universal Time" '(UPDATE-UNIVERSAL-TIME) '(:NOW :SYSTEM))
