;;; -*- Mode: Lisp; Syntax: Zetalisp; Base: 10; Package: Zwei; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Spelling corrector: user interface.

;;; Zwei history for the "Prompt" command.
(defvar *spell-word-history* (make-instance 'history :name "Replace String"))

;;; List of all dictionaries that are searched to see whether a
;;; word is spelled correctly.
(defvar *dictionaries* nil)

;;; Alist of all dictionaries that appears in the menu, offered to the user
;;; to update.  This should be a subset of the dictionaries in *dictionaries*.
;;; Each element is a menu-dict-item; see the structure definition below.
(defvar *menu-dict-items* nil)

;;; For purposes of this user interface, the dictionary's pathname's
;;; string-for-editor is used as the full name of the dictionary.
;;; (Short names appear on the menu, when not ambiguous; they are
;;; the name component of the pathname.)
(defun dictionary-name (d)
  (send (spell:dictionary-pathname d) :string-for-editor))

;;; Internal functions for scanning over a portion of an editor buffer
;;; and invoking the spelling corrector on individual words.

(defun make-spell-syntax-table ()
  (let ((table (make-array 256)))
    (dotimes (i 256) (setf (aref table i) word-delimiter))
    (loop for i from (char-code #/A) to (char-code #/Z) do
      (setf (aref table i) word-alphabetic))
    (loop for i from (char-code #/a) to (char-code #/z) do
      (setf (aref table i) word-alphabetic))
    (setf (aref table (char-code #/')) word-alphabetic)
    table))

(defvar *spell-word-syntax-table* (make-spell-syntax-table))

(defvar *temporary-dictionary*)			;Delay consing 10,000 long array until needed.

(defun spelling-correct-interval (first-bp last-bp section-name)
  (if (variable-boundp *temporary-dictionary*)
      (spell:make-empty *temporary-dictionary*)
      (setq *temporary-dictionary* (spell:make-empty-dictionary)))
  (let ((*mode-word-syntax-table* *spell-word-syntax-table*))
    ;; Either BP might be in the middle of a word.  Narrow the region so that
    ;; any word-fragments at either end are excluded.
    (let ((backup (forward-word first-bp -1)))
      (when backup (setq first-bp (forward-word backup))))
    (let ((forward (forward-word last-bp)))
      (when forward (setq last-bp (forward-word forward -1))))
    (let ((corrected-any-p nil))
      (with-bp (last-bp last-bp :moves)
	(catch 'abort
	  (loop for end-of-word = (forward-word first-bp) do
	    (when (or (null end-of-word)
		      (bp-< last-bp end-of-word))
	      (return nil))
	    (let ((start-of-word (forward-word end-of-word -1)))
	      (when (spelling-correct-word start-of-word end-of-word
					   :temp-dictionary *temporary-dictionary*)
		(setq corrected-any-p t))
	      (setq first-bp (forward-word start-of-word))))))
      (unless corrected-any-p
	(typein-line "The ~A is spelled correctly." section-name)))))

;;; Commands to invoke spelling correction.

(defcom com-spell-region "Perform spelling correction on the region." ()
  (prepare-for-spell-command)
  (cond ((window-region-p)
	 (region (first last)
	   (spelling-correct-interval first last "region")))
	(t
	 (let ((i (paragraph-interval (point))))
	   (spelling-correct-interval
	     (interval-first-bp i)
	     (interval-last-bp i)
	     "paragraph"))))
  dis-text)

(defcom com-spell-buffer "Perform spelling correction on the current buffer." ()
  (prepare-for-spell-command)
  (spelling-correct-interval
    (interval-first-bp *interval*)
    (interval-last-bp *interval*)
    "buffer")
  dis-text)

;;; forward-word 1 means: Pass over any non-alphas, pass over any
;;; alphas, and return with an alpha on the left and a non-alpha on the
;;; right.  If you run into the end, return an end bp iff fixup-p was
;;; true, OR if we were in the middle of alphas.

;;; The exact definition of "this word" is as follows:
;;;  If we are in the middle of a word, do that word.
;;;  If we are at the beginning of a word, do the word we're at the beginning of.
;;;  If we are at the end of a word, do the word we're at the end of.
;;;  If we are in the middle of whitespace, do the previous word.

;;;	Before	After	Meaning
;;;	------	-----	------
;;;	Alpha	Alpha	We're within the word.
;;;	Alpha	Delim	We're at the end of the word.
;;;	Alpha	End	We're at the end of the word.
;;;	Delim	Alpha	We're at the beginning of the word.
;;;	Delim	Delim	We're inside whitespace, look left for a word.
;;;	Delim	End	We're inside whitespace, look left for a word.
;;;	End	Alpha	We're at the beginning of the word.
;;;	End	Delim	No word.
;;;	End	End	No word.

(defcom com-spell-this-word "Perform spelling correction on the current word.
If there is a region defined, perform spelling correction on the whole region." ()
  (prepare-for-spell-command nil)
  (cond ((window-region-p)
	 (region (first last)
	   (spelling-correct-interval first last "region")))
	(t
	 (let* ((point (point))
		(*mode-word-syntax-table* *spell-word-syntax-table*)
		(char-before (bp-char-before point))
		(char-after (bp-char point))
		(syntax-before (and (not (bp-= point (interval-first-bp *interval*)))
				    (char-syntax char-before *spell-word-syntax-table*)))
		(syntax-after (and (not (bp-= point (interval-last-bp *interval*)))
				   (char-syntax char-after *spell-word-syntax-table*)))
		start-of-word-bp)
	   (cond ((and (null syntax-before)
		       (not (eql syntax-after word-alphabetic)))
		  (barf "There is no current word; point is at the beginning."))
		 ((and (not (eql syntax-before word-alphabetic))
		       (eql syntax-after word-alphabetic))
		  ;; We're at the beginning of a word.
		  (setq start-of-word-bp point))
		 (t
		  ;; All other cases are handled by going backward over a word,
		  ;; and then going forward over a word.
		  (setq start-of-word-bp (forward-word (point) -1))
		  (unless start-of-word-bp
		    ;; This can happen if syntax-before is word-delimiter.
		    (barf "There is no current word; point is at the beginning."))))
	   (catch 'abort 
	     (let ((end-of-word-bp (forward-word start-of-word-bp 1)))
	       ;; Double-quotes handle themselves since they are accounted for in
	       ;; Zwei's syntax-tables.  Single-quotes need to be handled specially,
	       ;; especially in light of TeX.
	       (when (and (char-equal (bp-char start-of-word-bp) #\')
			  (char-equal (bp-char (forward-char end-of-word-bp -1)) #\'))
		 (setq start-of-word-bp (forward-char start-of-word-bp 1)
		       end-of-word-bp (forward-char end-of-word-bp -1)))
	       (spelling-correct-word-saving-point
		 start-of-word-bp end-of-word-bp
		 :say-if-correct t
		 :avoid-typein-line *mini-buffer-command-in-progress*))))))
  dis-text)

;;; This is like spelling-correct-word except it goes to some trouble to
;;; try to preserve the location of point with repect to the starting
;;; and ending points of the word being corrected.  This was suggested
;;; by Bawden, based on Klotz's improvement to an MIT spell program.
(defun spelling-correct-word-saving-point
       (start-of-word end-of-word &key temp-dictionary say-if-correct avoid-typein-line)
  (let* ((line (bp-line (point)))
	 (point-index (bp-index (point)))
	 (start-index (bp-index start-of-word))
	 (end-index (bp-index end-of-word))
	 (start-delta (- start-index point-index))
	 (end-delta (- point-index end-index))
	 (new-word (spelling-correct-word start-of-word end-of-word
					  :temp-dictionary temp-dictionary
					  :say-if-correct say-if-correct
					  :avoid-typein-line avoid-typein-line)))
    ;; If point was originally closer to the end of the word than the
    ;; beginning of the word, restore point's location relative to the
    ;; end of the word.  Otherwise restore it to where it was
    ;; originally.
    (move-point line (if (and new-word (< (abs end-delta) (abs start-delta)))
			 (+ start-index (array-active-length new-word) end-delta)
			 point-index))
    new-word))

(defcom com-spell-word "Prompt for a word and perform spelling correction on it." ()
  (prepare-for-spell-command nil)
  (let* ((word (string-trim
		 *blanks*
		 (typein-line-readline "Word to perform spelling correction on:")))
	 (n-bytes (array-active-length word)))
    (cond ((zerop n-bytes)
	   (typein-line "No word was provided.  (To spell the word at the cursor, use m-$.)"))
	  ((word-in-dictionaries-p word n-bytes)
	   (typein-line "The word /"~a/" appears to be spelled properly." word))
	  (t
	   (let ((corrections (get-all-corrections word)))
	     (format t  "/"~a/" is unknown and possibly misspelled." word)
	     (selectq (length corrections)
	       (0 (format t "~&There are no possible corrected spellings.~&"))
	       (1 (format t "~&A possible corrected spelling is: /"~a/"~&"
			  (first corrections)))
	       (otherwise
		(format t "~&Possible corrected spellings of /"~a/" are:" word)
		(dolist (c corrections) (format t "~&/"~a/"" c))
		(terpri)))))))
 dis-text)

;;; Internal functions to use spell facility to do correction.

;;; Given a word at least two characters long, return :upper, :lower,
;;; :capitalized.  For purposes of determining case-kind, ignore any
;;; leading non-alphabetics, i.e.  a leading apostrophe.
(defun case-kind (word)
  (let ((n (if (cl:alpha-char-p (aref word 0)) 0 1)))
    (let ((char-0 (aref word n))
	  (char-1 (aref word (1+ n))))
      (if (upper-case-p char-0)
	  (if (upper-case-p char-1) :upper :capitalized)
	  :lower))))

;;; Given an upper-case word and a case-kind, return a string
;;; that's like that word but in the same kind of case.
(defun word-of-case-kind (word case-kind)
  (selectq case-kind
    (:upper word)
    (:lower (string-downcase word))
    (:capitalized
     (let ((ans (string-downcase word)))
       (setf (aref ans 0) (char-upcase (aref ans 0)))
       (unless (cl:alpha-char-p (aref ans 0))
	 (setf (aref ans 1) (char-upcase (aref ans 1))))
       ans))))

;;; Search for the word in all the *dictionaries*, and also in the
;;; temp-dictionary if one is provided.  If the word is found, return
;;; the dictionary in which it was found, or return T if it was "found"
;;; but not in any dictionary (e.g. one-character string).  Otherwise,
;;; return NIL.  If the caller knows the length of the word, he should
;;; pass it in, to save a tiny bit of time.
(defun word-in-dictionaries-p (word n-bytes &optional temp-dictionary)
  (condition-case ()
       (spell:encode-string
	 word
	 n-bytes
	 #'(lambda (ignore list n-bytes hash)
	     (or (< n-bytes 2)
		 (loop for dictionary in *dictionaries* do
		   (when (spell:lookup-word dictionary list n-bytes hash)
		     (return dictionary)))
		 (and temp-dictionary
		      (spell:lookup-word temp-dictionary list n-bytes hash)
		      temp-dictionary)))
	 nil)
     (spell:cannot-encode t)))

;;; Return a list of all the corrections of word, looking up in all the
;;; dictionaries in *dictionaries*, in case compatible with word,
;;; without duplicates.  If extra-dictionary is provided, look in that
;;; dictionary too.
(defun get-all-corrections (word &optional extra-dictionary)
  (let ((case-kind (case-kind word)))
    (mapcar #'(lambda (x) (word-of-case-kind x case-kind))
	    (cl:delete-duplicates
	      (loop for dictionary in (if (null extra-dictionary)
					  *dictionaries*
					  (cons extra-dictionary *dictionaries*))
		    nconc (spell:get-list-of-corrections dictionary word))
	      :test #'string-equal))))

;;; If the word is replaced with a new word, return the new word, as an
;;; all-uppercase string.  Otherwise, return NIL.  Note: This can throw,
;;; with tag abort.  All callers must set up a catch.
(defun spelling-correct-word
       (start-of-word end-of-word &key temp-dictionary say-if-correct avoid-typein-line)
  (using-resource (word spell::utility-strings)
    (let* ((line (bp-line start-of-word))
	   (start-charpos (bp-index start-of-word))
	   (end-charpos (bp-index end-of-word)))
      (let ((n-bytes (- end-charpos start-charpos)))
	(copy-array-portion line start-charpos end-charpos word 0 n-bytes)
	(setf (fill-pointer word) n-bytes)
	(let ((dictionary (word-in-dictionaries-p word n-bytes temp-dictionary)))
	  (cond (dictionary
		 (when say-if-correct
		   (unless avoid-typein-line
		     (typein-line "/"~a/" is spelled correctly" word)
		     (if (eq dictionary t)
			 (typein-line-more ".")
			 (let ((pathname (spell:dictionary-pathname dictionary)))
			   (cond ((eq pathname *pathname-of-basic-dictionary*)
				  (typein-line-more "."))
				 (t
				  (scl:with-character-style ('(nil :italic :small)
							     *typein-window*)
				    (typein-line-more " (according to ~A)."
						      (send pathname :name))))))))))
		(t
		 ;; The word appears to be misspelled.
		 (unless avoid-typein-line
		   (typein-line "/"~a/" is unknown and possibly misspelled." word))
		 ;; Highlight the word in the buffer, using region underlining.
		 (move-bp (point) start-of-word)
		 (move-bp (mark) end-of-word)
		 (setf (window-mark-p *window*) t)
		 (must-redisplay *window* dis-text)
		 (redisplay *window*)
		 ;; check if the user chooses to substitute the new for the old
		 (multiple-value-bind (new-word explicit-p not-found-p)
		     (get-corrected-word-from-user word temp-dictionary avoid-typein-line)
		   (when new-word
		     (unless avoid-typein-line
		       (typein-line "Correcting /"~A/" to /"~A/"." word new-word))
		     (let ((old-*crp* *case-replace-p*)
			   (old-*srp* *style-replace-p*))
		       (unwind-protect
			   (progn
			     (set '*case-replace-p*
				  ;; If the user explicitly used the Shift key, keep case.
				  (not (and explicit-p
					    (loop for char being the array-elements
						      of new-word
						  thereis (upper-case-p char)))))
			     ;; Retain character style
			     (set '*style-replace-p* nil)
			     (case-replace start-of-word end-of-word new-word t))
			 (set '*case-replace-p* old-*crp*)
			 (set '*style-replace-p* old-*srp*))))
		   (setf (window-mark-p *window*) nil)
		   (redisplay *window*)
		   (cond (not-found-p
			  ;; Try again.
			  (or (spelling-correct-word
				start-of-word (forward-word start-of-word)
				:temp-dictionary temp-dictionary
				:say-if-correct say-if-correct
				:avoid-typein-line avoid-typein-line)
			      ;; The next try didn't result in a new word.  But from the
			      ;; point of view of our caller, new-word is the new word.
			      new-word))
			 (t
			  ;; It was fine, so return the new word.
			  new-word))))))))))

;;; get-corrected-word-from-user: the menu.

(defflavor spell-momentary-menu
	()
	(tv:keyboard-sensitive-menu-mixin tv:momentary-menu))

(compile-flavor-methods spell-momentary-menu)

(tv:defwindow-resource spell-momentary-menu ()
  :make-window (spell-momentary-menu)
  :initializer (send object :set-geometry nil nil nil nil nil nil)
  :reusable-when :deexposed)

;;; NOTE the following non-obvious structure: "Accept" has two meanings,
;;; depending on whether a temp dictionary is in use or not.  If there
;;; is a temp dictionary, it puts the word into it; if not, then it
;;; behaves as "Accept Once" would.  This is because if there is no temp
;;; dictionary, there is no distinction between "Accept" and "Accept
;;; Once", and so we only offer "Accept", but internally it does what
;;; "Accept Once" does.  This affects c-A analogously.

;;; NOTE on keyboard input: there's no way to accept keyboard input
;;; except by explicitly listing each keystroke, using this mixin.  We
;;; may need our own mixin to do numbers and letters, if we want to put
;;; in keyboard commands to let you select new spellings or temp
;;; dictionaries from the keyboard.  Consider this for the next round of
;;; changes.

(defconst *prompt-item*
	  '("Prompt" :value :prompt :style (nil :bold nil)
	    :documentation
	    "Type the corrected spelling in the typein line."))

(defconst *accept-item*
	  '("Accept" :value :accept-once :style (nil :bold nil)
	    :documentation
	    "Accept this spelling as the correct spelling."))

(defconst *accept-once-item*
	  '("Accept once" :value :accept-once :style (nil :bold nil)
	    :documentation
	    "Accept this spelling as the correct spelling, just this once."))

(defconst *accept-command-item*
	  '("Accept" :value :accept-command :style (nil :bold nil)
	    :documentation
	    "Accept this spelling as the correct spelling, for the rest of this command."))

;;; Mouse documentation strings for the answers returned by
;;; get-all-corrections.  I'm afraid it would be too expensive to cons
;;; up a big string for each answer every time a menu pops up, so I'd
;;; like to use a resource.  However, the updater of the mouse
;;; documentation line thinks that any given string never changes, so
;;; you have to give it different strings to foil its cache.  Therefore,
;;; we have to switch between two separate resources of strings!

(defvar *prefix-of-mouse-documentation-for-answer*
	      "Replace the marked word with /"")

(defvar *prefix-length* (string-length *prefix-of-mouse-documentation-for-answer*))

(defvar *length-of-mouse-documentation-strings*
	(+ *prefix-length* spell:*max-spell-word-length* 5))	; 5 for punctuation etc.

(defresource mouse-documentation-strings-1 ()
  :constructor (scl:make-array *length-of-mouse-documentation-strings*
			       :element-type 'character :fill-pointer 0)
  :initial-copies 10)

(defresource mouse-documentation-strings-2 ()
  :constructor (scl:make-array *length-of-mouse-documentation-strings*
			       :element-type 'character :fill-pointer 0)
  :initial-copies 10)

;;; Flips between NIL and T to select which resource to use.
(defvar *mouse-documentation-string-state* nil)

(defun get-all-answer-menu-items (word temp-dictionary)
  (let* ((answers (get-all-corrections word temp-dictionary))
	 (state (setq *mouse-documentation-string-state*
		      (not *mouse-documentation-string-state*)))
	 (resource-name (if state
			    'mouse-documentation-strings-1
			    'mouse-documentation-strings-2)))
    (loop for answer in answers
	  collect
	  (list answer :value answer :style '(nil nil nil)
		:documentation
	    (let ((string (allocate-resource resource-name))
		  (answer-length (string-length answer)))
	      (copy-array-portion *prefix-of-mouse-documentation-for-answer*
				  0 *prefix-length* string 0 *prefix-length*)
	      (copy-array-portion answer 0 answer-length string *prefix-length*
				  (+ *prefix-length* answer-length))
	      (copy-array-portion "/"." 0 2 string (+ *prefix-length* answer-length)
				  (+ *prefix-length* answer-length 2))
	      (setf (fill-pointer string) (+ *prefix-length* answer-length 2))
	      string)))))

(defun deallocate-resources-from-answer-menu-items (item-list)
  (let ((resource-name (if *mouse-documentation-string-state*
			    'mouse-documentation-strings-1
			    'mouse-documentation-strings-2)))
    (dolist (item item-list)
      (when (and (cl:listp item)
		 (stringp (second (memq :value item))))
	(deallocate-resource resource-name (second (memq :documentation item)))))))

;;; word is a misspelled word.  Ask the user what to do.  If this
;;; returns a string, then that's a new spelling from the user.  A
;;; second returned value of T means it was explicitly typed by the
;;; user, as opposed to just coming from a dictionary.  A third returned
;;; value means that the new word is not in the dictionaries, which can
;;; only happen if the user was prompted and typed an unknown word.  If
;;; the function returns NIL, that means to accept the original
;;; spelling.  Note: This can throw, with tag abort.
(defun get-corrected-word-from-user (word &optional temp-dictionary avoid-typein-line)
  (declare (values new-word explicit-p not-found-p))
  (let* ((answers (get-all-answer-menu-items word temp-dictionary))
	 (choice
	   (let ((editor-screen (send (window-sheet *window*) :screen)))
	     (using-resource (menu spell-momentary-menu editor-screen)
	       (setf (tv:keyboard-sensitive-menu-mixin-char-to-item-alist menu)
		     '((#\abort . (#\abort :value :abort))
		       (#\c-P . (#\c-P :value :prompt))
		       (#\c-A . (#\c-A :value :accept-keyboard))
		       (#\c-O . (#\c-O :value :accept-once))))
	       (send menu :set-item-list
		     (if temp-dictionary
			 (list* *prompt-item* *accept-once-item* *accept-command-item*
				(append *menu-dict-items* answers))
			 (list* *prompt-item* *accept-item*
				(append *menu-dict-items* answers))))
	       (send menu :set-label (string-append "Spelling: " word))
	       (send menu :set-last-item
		     (if temp-dictionary *accept-command-item* *accept-item*))
	       (tv:saving-mouse-position editor-screen
		 (tv:mouse-set-sheet-then-call editor-screen
		   #'(lambda ()
		       (expose-the-menu menu)
		       (prog1 (send menu :choose)
			      (tv:restore-mouse-position-if-necessary)
			      (deallocate-resources-from-answer-menu-items
				(send menu :item-list))))))))))
    (cl:etypecase choice
      (string
	choice)
      (symbol
	(when (eq choice :accept-keyboard)
	  (setq choice (if temp-dictionary :accept-command :accept-once)))
	(cl:ecase choice
	  (:prompt
	   ;; Prompt the user for a new spelling.
	   (let ((new-word
		   (funcall
		     (if avoid-typein-line
			 #'typein-line-history-readline-near-mouse
			 #'typein-line-history-readline)
		     *spell-word-history*
		     word			; The default, for c-m-Y.
		     t				; If user types a blank line, use word.
		     "Type the corrected spelling of /"~A/":" word)))
	     ;; Some confirmation messages.
	     (unless avoid-typein-line
	       (cond ((string= new-word word)
		      ;; Special case: the user typed in exactly the
		      ;; same thing, including u&l case.
		      (typein-line "Leaving the word /"~A/" as it is." word)
		      (setq new-word nil)
		      (values new-word t))
		     ((not (word-in-dictionaries-p
			     new-word (array-active-length new-word) temp-dictionary))
		      ;; Unknown word.  Warn the user and return the not-found-p value.
		      (typein-line "Warning: /"~A/" is not in the dictionary." new-word)
		      (values new-word t t))
		     (t
		      ;; The new word is in the dictionaries, so everything is OK.
		      (values new-word t))))))
	  (:accept-once nil)
	  ((nil)
	   ;; The user slid off the momentary menu.  Treat this as :accept-once.
	   nil)
	  (:accept-command
	   (spell:encode-string
	     (string-upcase word) (array-active-length word) #'spell:add-word temp-dictionary)
	   nil)
	  (:abort
	    (throw 'abort nil))))
      (spell:dictionary
	(spell:encode-string
	  (string-upcase word) (array-active-length word) #'spell:add-word choice)
	nil))))

;;; This is a modified version of the zwei:typein-line-readline-near-window function
;;; that uses typein-line-history-readline instead of typein-line-readline.
(defun typein-line-history-readline-near-mouse (history default blank-line-defaults
						prompt-string &rest prompt-args)
  ;; This LET is something of a kludge, but just because the Zmacs user
  ;; is in the mini-buffer doesn't mean that this kind of standalone
  ;; mini-buffer should be prohibited from working.
  (let ((*mini-buffer-command-in-progress* nil))
    (using-resource (editor editor-for-temporary-mini-buffer-resource)
      (lexpr-funcall editor ':call-mini-buffer-near-window :mouse
		     #'typein-line-history-readline
		     history default blank-line-defaults prompt-string prompt-args))))

(defstruct (menu-dict-item (:type :list) (:conc-name mdi-))
  name
  (value-keyword :value)
  dictionary
  (style-keyword :style)
  (style '(nil :italic nil))
  (documentation-keyword :documentation)
  documentation)

(defun update-names-of-dictionaries ()
  (dolist (item *menu-dict-items*)
    (setf (mdi-name item)
	  (send (spell:dictionary-pathname (mdi-dictionary item)) :name)))
  ;; Check for duplications, and substitute longer name.
  (loop for (first . rest) on *menu-dict-items* do
    (let ((name (mdi-name first)))
      (cond ((assoc name rest)
	     (dolist (item *menu-dict-items*)
	       (when (equal (mdi-name item) name)
		 (setf (mdi-name item)
		       (send (spell:dictionary-pathname (mdi-dictionary item))
			     :string-for-editor)))))))))

(defun add-menu-dictionary (dictionary)
  (push (make-menu-dict-item
	  dictionary dictionary
	  documentation (format nil "Accept this spelling and add it to dictionary ~A"
				(send (spell:dictionary-pathname dictionary)
				      :string-for-editor)))
	*menu-dict-items*)
  (update-names-of-dictionaries))

(defun delete-menu-dictionary (dictionary) ;if not there, return
  (dolist (item *menu-dict-items*)
    (when (eq dictionary (mdi-dictionary item))
      (setq *menu-dict-items* (delq item *menu-dict-items*))
      (update-names-of-dictionaries)
      (return nil))))

(defun menu-dictionary-p (dictionary)
  (dolist (item *menu-dict-items*)
    (when (eq dictionary (mdi-dictionary item))
      (return t))))

;;; Editor commands to manipulate dictionaries.

;;; Returns a dictionary name and a dictionary, or NIL if no dictionary
;;; is selected.
(defun prompt-for-spell-dictionary (prompt)
  (declare (values name dictionary))
  (let ((dictionary
	  (typein-line-accept 'spell-dictionary
			      :prompt prompt
			      :default (car *dictionaries*))))
    (values (dictionary-name dictionary) dictionary)))

(scl:define-presentation-type spell-dictionary ()
   :history t
   :parser ((stream &key initially-display-possibilities)
	    (values
	      (dw:completing-from-suggestions
		(stream
		  :delimiters *buffer-name-completing-delims*
		  :type 'spell-dictionary
		  :initially-display-possibilities
		  initially-display-possibilities)
		(dolist (dictionary *dictionaries*)
		  (dw:suggest (dictionary-name dictionary) dictionary)))))
   :printer ((dictionary stream) (cl:write-string (dictionary-name dictionary) stream))
   :description "a spell dictionary")

(defcom com-read-spell-dictionary "Read a spelling-correction dictionary from a file.
By default, the dictionary is added to the menu, so you can add words to it.
If a numeric argment is given, the dictionary is not added to the menu.
The filename given should be of a dictionary in either character or binary." ()
  (prepare-for-spell-command)
  (let ((pathname (accept-defaulted-pathname
		    "Read spelling-correction dictionary from file"
		    (pathname-defaults)
		    :special-type :dict)))
    (read-spell-dictionary pathname (not *numeric-arg-p*)))
  dis-none)

(defcom com-show-spell-dictionaries "Show the list of spelling-correction dictionaries.
At any time, there is a list of dictionaries that are used by the spelling correction
commands.  This command show you the list." ()
  (cond ((null *dictionaries*)
	 (format t "There are no spelling-correction dictionaries currently read in.~%"))
	(t
	 (format t "List of spelling-correction dictionaries currently read in:~2%")
	 (let ((cw (send standard-output :char-width)))
	   (scl:formatting-table (standard-output :inter-column-spacing (* cw 10))
	     (dolist (d *dictionaries*)
	       (scl:formatting-row ()
		 (scl:formatting-cell () "")
		 (scl:formatting-cell ()
		   (scl:present d 'spell-dictionary))
		 (scl:formatting-cell ()
		   (format t "(~6D words)" (spell:count-words d)))
		 (scl:formatting-cell ()
		   (let ((notes nil))
		     (when (menu-dictionary-p d)
		       (push "on the menu" notes))
		     (when (spell:dictionary-modified-p d)
		       (push "modified" notes))
		     (when notes
		       (format t "(")
		       (scl:format-textual-list notes #'princ)
		       (format t ")"))))))))
	 (format t "~2%Done.~%")))
  dis-none)

;;; This used to be called Remove, but it was too similar to Read in m-X completion.
(defcom com-kill-spell-dictionary "Kill a dictionary from the list of dictionaries.
At any time, there is a list of dictionaries that are used by the spelling correction
commands.  To see the set, use m-X Show Spell Dictionaries.  This command lets you
remove any dictionary from the set.  This doesn't affect the file on disk.
You type in the pathname of the dictionary in name-first order (like Zmacs buffer names).
Completion is available." ()
  (unless *dictionaries* (barf "There are no spell dictionaries loaded."))
  (multiple-value-bind (name dictionary)
      (prompt-for-spell-dictionary "Name of dictionary to kill")
    (when dictionary
      (setq *dictionaries* (delq dictionary *dictionaries*))
      (delete-menu-dictionary dictionary)
      (typein-line "Dictionary ~A has been killed." name)))
  dis-none)

;;; Save the dictionary to its file.  Recover gracefully if the file
;;; already exists because the pathname's version isn't :newest.  This
;;; actually happened to CWR once, possibly because he selected a
;;; pathname using the mouse, or something.
(defun save-dictionary-carefully (dictionary)
  (condition-case (error)
       (spell:save-dictionary dictionary)
     (fs:file-already-exists
       (let* ((d-pathname (spell:dictionary-pathname dictionary))
	      (n-pathname (send d-pathname :new-version :newest)))
	 (beep)
	 (format t "~%Error: While trying to save dictionary ~A:"
		 (dictionary-name dictionary))
	 (format t "~%the file ~A already exists." (send error :pathname))
	 (format t "~%Press C to change the directory's pathname~%   from ~A to ~A"
		 d-pathname n-pathname)
	 (format t "~%Press N to do nothing, and so not save the directory.~2%")
	 (selectq (fquery `(:choices (((change "Change") #\C)
				      ((nothing "Nothing") #\N))
			    :stream ,terminal-io)
			  "Change the pathname, or do nothing? ")
	   (change
	    (setf (spell:dictionary-pathname dictionary) n-pathname)
	    (spell:save-dictionary dictionary)))))))

(defcom com-save-spell-dictionary "Save a dictionary from the list of dictionaries.
At any time, there is a list of dictionaries that are used by the spelling correction
commands.  To see the set, use m-X Show Spell Dictionaries.  This command lets you
save any dictionary from the set into its pathname.  If the dictionary isn't modified,
this doesn't do anything.  Completion is available." ()
  (unless *dictionaries* (barf "There are no spell dictionaries loaded."))
  (multiple-value-bind (nil dictionary)
      (prompt-for-spell-dictionary "Name of dictionary to save")
    (when dictionary
      (save-dictionary-carefully dictionary)
      ;; Must get the dictionary-name afresh, since
      ;; save-dictionary-carefully can change it!
      (typein-line "Dictionary ~A has been saved." (dictionary-name dictionary))))
  dis-none)

(defcom com-save-all-spell-dictionaries "Save all dictionaries on the list of dictionaries.
At any time, there is a list of dictionaries that are used by the spelling correction
commands.  To see the set, use m-X Show Spell Dictionaries.  This command saves
each modified dictionary of the set into its pathname." ()
  (unless *dictionaries* (format t "There are no spell dictionaries loaded."))
  (dolist (dictionary *dictionaries*)
    (when (spell:dictionary-modified-p dictionary)
      (save-dictionary-carefully dictionary)
      (typein-line "Dictionary ~A has been saved." (dictionary-name dictionary))))
  dis-none)

;;; Entrypoint for the Logout command.  User interface designed to be
;;; consistent with that of zwei:save-all-files.
(defun save-all-spell-dictionaries (&optional (ask t))
  (save-all-spell-dictionaries-execute (save-all-spell-dictionaries-query ask)))

(defun save-all-spell-dictionaries-query (&optional (ask t))
  (let ((dicts nil))
    (dolist (dictionary *dictionaries*)
      (when (and (spell:dictionary-modified-p dictionary)
		 (or (not ask)
		     (cl:y-or-n-p "Save spell dictionary ~A ? " (dictionary-name dictionary))))
	(push dictionary dicts)))
    (reverse dicts)))

(defun save-all-spell-dictionaries-execute (dicts)
  (dolist (dict dicts)
    (save-dictionary-carefully dict)))


(si:define-application-logout-initialization save-spell-dictionaries-logout-initialization
 ((save-spell-dictionaries '((cl:member :yes :no :ask))
			  :default :ask
			  :documentation
			  "Save modified spell dictionaries before logging out"))
  (unless (eq save-spell-dictionaries :no)
    (zwei:save-all-spell-dictionaries-execute
      (si:application-logout-separate-querying
	(zwei:save-all-spell-dictionaries-query (eq save-spell-dictionaries :ask))))))

(defcom com-show-contents-of-spell-dictionary "Show all the words in a spell dictionary.
With a numeric argument, prompt for a filename and write the words to a file.
At any time, there is a list of dictionaries that are used by the spelling correction
commands.  To see the set, use m-X Show Spell Dictionaries.  This command shows
all of the words in one of those dictionaries.  Completion is available." ()
  (unless *dictionaries* (barf "There are no spell dictionaries loaded."))
  (multiple-value-bind (name dictionary)
      (prompt-for-spell-dictionary "Name of dictionary to show the contents of")
    (when dictionary
      (cond (*numeric-arg-p*
	     (with-open-file (file-stream
			       (accept-defaulted-pathname
				 (format nil "Write words of dictionary ~A to file"
					 (dictionary-name dictionary))
				 (pathname-defaults)
				 :special-type :text)
			       :direction :output)
	       (spell:print-words-sorted dictionary file-stream)))
	    (t
	     (format t "Contents of spell dictionary ~A~2%" name)
	     (spell:print-words-sorted dictionary)))))
  dis-none)

(defcom com-compile-spell-dictionary
	"Compile a character spelling-correction dictionary into a binary one.
The binary format loads more quickly than the character format.
Prompts for two filenames.  The first is the existing character dictionary,
which can be any text file.  The second says where to put the new binary
dictionary.  Binary dictionary files usually have a (canonical) file type
of DICT." ()
  (let* ((char-pathname (accept-defaulted-pathname
			  "Compile character dictionary file"
			  (pathname-defaults)
			  :special-type :text))
	 (bin-pathname (accept-defaulted-pathname
			 (format nil "Compile ~A into binary file" char-pathname)
			 char-pathname
			 :special-type :dict :special-version nil :direction :write)))
    (spell:write-binary-dictionary
      (with-open-file (char-stream char-pathname)
	(spell:read-character-dictionary char-stream bin-pathname))))
  dis-none)

(defcom com-add-word-to-spell-dictionary
	"Add a word to a spelling-correction dictionary.  Prompts for both." ()
  (let ((word (string-trim
		*blanks*
		(typein-line-readline "Word to add:"))))
    (multiple-value-bind (name dictionary)
	(prompt-for-spell-dictionary
	  (format nil "Name of dictionary to add /"~A/" to" word))
      (when dictionary
	(cond ((spell:encode-string
		 (string-upcase word)
		 (array-active-length word)
		 #'spell:lookup-word
		 dictionary)
	       (barf "The word /"~A/" was already in dictionary ~A." word name))
	      (t
	       (spell:encode-string
		 (string-upcase word)
		 (array-active-length word)
		 #'spell:add-word
		 dictionary)
	       (typein-line "Added /"~A/" to dictionary ~A." word name))))))
  dis-none)

(defcom com-delete-word-from-spell-dictionary
	"Delete a word from a spelling-correction dictionary.  Prompts for both." ()
  (let ((word (string-trim
		*blanks*
		(typein-line-readline "Word to delete:"))))
    (multiple-value-bind (name dictionary)
	(prompt-for-spell-dictionary
	  (format nil "Name of dictionary to delete /"~A/" from" word))
      (when dictionary
	(cond ((spell:encode-string
		 (string-upcase word)
		 (array-active-length word)
		 #'spell:delete-word
		 dictionary)
	       (typein-line "Deleted /"~A/" from dictionary ~A." word name))
	      (t
	       (barf "The word /"~A/" was not found in dictionary ~A." word name))))))
  dis-none)

(defcom com-spell-file
	"Read through a set of files and collect misspellings into a buffer.
Prompts for a wildcard pathname, and a buffer name.  Reads through all of those files,
and finds all of the words therein that aren't in any of the dictionaries.  Prints all
of these words into a new buffer." ()
  (prepare-for-spell-command)
  (let ((wildcard-pathname
	  (accept-defaulted-pathname "File(s) to search (wildcards allowed)"
				   (pathname-defaults)))
	(buffer
	  (loop for b = (read-buffer-name "Buffer to put results in" :other t)
		until b finally (return b)))
	(misspellings (spell:make-empty-dictionary)))
    (loop for (pathname) in (cdr (fs:directory-list wildcard-pathname :fast)) do
      (with-open-file (file-stream pathname :element-type 'character)
	(spell:map-over-words-from-stream
	  file-stream
	  #'(lambda (word n-chars)
	      (unless (word-in-dictionaries-p word n-chars)
		(spell:encode-string word n-chars #'spell:add-word misspellings))))))
    (spell:print-words-sorted
      misspellings
      (let ((bp (interval-last-bp buffer)))
	(open-interval-stream bp bp t)))
    (typein-line "Misspellings in ~A written to buffer ~A." wildcard-pathname buffer))
  dis-none)

(defcom com-tags-spell
	"Read through the buffers of the tags table and collect misspellings into a buffer.
Reads through all the buffers of the current tags table, and finds all
of the words therein that aren't in any of the dictionaries.  Prints all
of these words into a new buffer." ()
  (prepare-for-spell-command)
  (let ((original-buffer *interval*)
	(tags-buffer (select-tag-table nil))
	(result-buffer
	  (loop for b = (read-buffer-name "Buffer to put results in" :other t)
		until b finally (return b)))
	(misspellings (spell:make-empty-dictionary)))
    (send tags-buffer :restart)
    ;; When the last buffer is reached, :next-file does abort-current-command.
    ;; This non-modularity must be answered by the following non-modularity:
    (catch 'zwei-command-loop
      (loop do
	(send tags-buffer :next-file nil)
	(format t "~%Checking for misspellings in buffer ~A." (send *interval* :name))
	(map-over-words-in-interval
	  *interval*
	  #'(lambda (word n-chars)
	      (unless (word-in-dictionaries-p word n-chars)
		(spell:encode-string word n-chars #'spell:add-word misspellings))))))
    (format t "~%Done.~%")
    (spell:print-words-sorted
      misspellings
      (let ((bp (interval-last-bp result-buffer)))
	(open-interval-stream bp bp t)))
    (typein-line "Misspellings in tags files written to buffer ~A." result-buffer)
    (send *zmacs-command-loop* :set-interval original-buffer))
  dis-none)

(defun map-over-words-in-interval (interval function)
  (loop for line = (bp-line (interval-first-bp interval)) then (line-next-in-buffer line) do
    (loop with index = 0
	  with last-index = (line-length line)
	  with start-word = 0 do
      ;; Skip forward over non-word-components like delimiters and blanks.
      (loop while (< index last-index) do
	(let ((char (aref line index)))
	  (when (or (alpha-char-p char) (char-equal char #\'))
	    (return nil)))
	(incf index))
      ;; Now we're at the beginning of a word (or end of line).
      (setq start-word index)
      ;; Move forward over word components.
      (loop while (< index last-index) do
	(let ((char (aref line index)))
	  (when (not (or (alpha-char-p char) (char-equal char #\')))
	    (return nil)))
	(incf index))
      (let ((word-length (- index start-word)))
	(when (> word-length 1)
	  ;; We've found an actual word.
	  (funcall function
		   (substring line start-word index)
		   word-length)))
      (when ( index last-index) (return nil)))
	until (eq line (bp-line (interval-last-bp interval)))))

;;; Install the spell commands in the standard Zwei comtab.

(defun install-spell-commands ()
  (set-comtab *standard-comtab*
	      '(#\Meta-$ com-spell-this-word)
	      (make-command-alist
		'(com-spell-region com-spell-buffer com-spell-word
                  com-read-spell-dictionary com-show-spell-dictionaries
		  com-show-contents-of-spell-dictionary
		  com-kill-spell-dictionary com-save-spell-dictionary
		  com-save-all-spell-dictionaries com-compile-spell-dictionary
		  com-add-word-to-spell-dictionary
		  com-delete-word-from-spell-dictionary
		  com-spell-file com-tags-spell))))

(install-spell-commands)

;;; Other functions.

;;; If this is true, any use of spell commands should automatically read
;;; in a set of dictionaries from the "usual" places.  If it's false,
;;; then no automatic reading should happen, either because it already
;;; happened, or because the user is taking care of it manually.
(defvar *automatically-read-dictionaries* t)

;;; This function is externally advertised.
(defun read-spell-dictionary (pathname &optional (menu-p t))
  (setq *automatically-read-dictionaries* nil)
  (read-spell-dictionary-internal pathname menu-p :reload))
  
;;; Internal version of read-spell-dictionary that does not affect the
;;; value of *automatically-read-dictionaries*.  If menu-p, this dictionary
;;; is put onto the menu.  if-loaded says what to if there's already a
;;; dictionary on the list with this pathname: :ignore means to assume
;;; that the existing one is OK and do nothing, and :reload means to
;;; kill the existing one and load a new one from the file system.
(defun read-spell-dictionary-internal (pathname &optional (menu-p t) (if-loaded :ignore))
  (setq pathname (fs:merge-pathnames pathname))
  ;; If an earlier version of the same dictionary is loaded, delete it.
  (dolist (dictionary *dictionaries*)
    (when (eq pathname (spell:dictionary-pathname dictionary))
      (when (eq if-loaded :ignore)
	(return-from read-spell-dictionary-internal t))
      (setq *dictionaries* (delq dictionary *dictionaries*))
      (delete-menu-dictionary dictionary)
      (return nil)))
  (with-open-file (stream pathname :element-type :default)
    (let ((dictionary
	    (funcall (if (send stream :characters)
			 #'spell:read-character-dictionary
			 #'spell:read-binary-dictionary)
		     stream pathname)))
      (push dictionary *dictionaries*)
      (when menu-p
	(add-menu-dictionary dictionary))))
  t)

(defconst *pathname-of-basic-dictionary* (fs:parse-pathname "SYS: DATA; BASIC.DICT.NEWEST"))

;;; This function is externally advertised.  It's also called
;;; automatically if you invoke spelling correction and there aren't any
;;; dictionaries read in.  It returns a list whose elements are of the
;;; form (pathname result), one for each standard dictionary, where
;;; result is nil if the dictionary was read in successfully, and an error
;;; object saying what went wrong otherwise.  Note that the personal home
;;; directory spell dictionary is not required, so if it reads is successfully
;;; it's reported in the returned value, but if it is not found, it is simply
;;; omitted.  If :for-general-use is provided, the caller is asserting that
;;; this Lisp environment will be used by many people, which right now means
;;; that the attempt to locate a personal (home dir) dictionary is supporessed.
(defun read-standard-spell-dictionaries (&key for-general-use)
  (catch-error-restart (error "Skip reading standard spell dictionaries")
    (let ((result nil))
      (flet ((read-it (filename menu-p)
	       (let ((pathname (fs:merge-pathnames filename)))
		 (push (list pathname (read-spell-dictionary-carefully
					pathname menu-p for-general-use))
		       result))))
	(read-it *pathname-of-basic-dictionary* nil)
	(loop for (indicator value) in (send net:*local-site* :get :user-property) do
	  (when (eq indicator :spell-dictionary)
	    (read-it value nil)))
	(unless for-general-use
	  (let* ((pn (send (fs:user-homedir) :new-pathname
			   :name "SPELL" :canonical-type :dict :version :newest))
		 (answer (read-spell-dictionary-carefully pn)))
	    (cond ((not (typep answer 'fs:file-error))
		   (push (list pn answer) result))
		  (t
		   (let* ((text-pn (send pn :new-pathname :canonical-type :text))
			  (text-answer (read-spell-dictionary-carefully text-pn)))
		     (when (not (typep text-answer 'fs:file-error))
		       (push (list text-pn text-answer) result))))))))
      result)))

(defun prepare-for-spell-command (&optional (page-in-spell-structures t))
  (when *automatically-read-dictionaries*
    (read-standard-spell-dictionaries-interactively))
  (when page-in-spell-structures
    (flet ((page-in-dictionary (dictionary)
	     (sys:page-in-array (spell:dictionary-encoded-strings dictionary) nil nil nil)
	     (loop for spell-table being the array-elements
		     of (spell:dictionary-spell-tables dictionary)
		   when spell-table
		     do (sys:page-in-array (spell:spell-table-offset-array spell-table)
					   nil nil nil))))
      (tv:noting-progress ("Paging in spell tables")
	(when (variable-boundp *temporary-dictionary*)
	  (page-in-dictionary *temporary-dictionary*))
	(cl:map nil #'page-in-dictionary *dictionaries*)))))

(defun read-standard-spell-dictionaries-interactively ()
  (typein-line "Reading standard spell dictionaries...")
  (let* ((result (read-standard-spell-dictionaries))
	 (n-errors (loop for (nil answer) in result count answer)))
    (cond ((zerop n-errors)
	   (typein-line-more " Done."))
	  (t
	   (format t (if (= n-errors 1)
			 "There was an error"
			 "There were ~S errors") n-errors)
	   (format t " reading the standard spell dictionaries.~2%")
	   (let ((cw (send standard-output :char-width)))
	     (scl:formatting-table (standard-output :inter-column-spacing (* cw 10))
	       (scl:formatting-column-headings ()
		 (scl:formatting-cell () "")
		 (dolist (x '("Dictionary" "Error"))
		   (scl:formatting-cell () (scl:with-underlining () (princ x)))))
	       (loop for (pathname answer) in result do
		 (when answer
		   (scl:formatting-row ()
		     (scl:formatting-cell () "")
		     (scl:formatting-cell () (scl:present pathname))
		     (scl:formatting-cell ()
		       (cond ((send answer :operation-handled-p :report-without-pathname)
			      (send answer :report-without-pathname standard-output))
			     ((send answer :operation-handled-p :report)
			      (send answer :report standard-output))
			     (t (princ answer)))))))))
	   (send standard-output :fresh-line)
	   ;; Special message if there was a lookup error for the primary directory.
	   (let ((p (assoc (fs:merge-pathnames *pathname-of-basic-dictionary*) result)))
	     (when (and p (typep (second p) 'fs:file-lookup-error))
	       (format t "~2&Possibly the reason for the probem is that the source tape isn't loaded at your site.~%")))
	   (when (not (yes-or-no-p "Continue with spelling correction anyway? "))
	     (barf))))))

;;; Internal function.  Like read-spell-dictionary, but hide various
;;; errors.  Return NIL if it succeeds, or a condition object if there's
;;; an error.
(defun read-spell-dictionary-carefully (pathname &optional (menu-p t) for-general-use)
  (block top
    (catch-error-restart (error "Skip reading spell dictionary ~a" pathname)
      (error-restart (error "Retry reading spell dictionary ~a" pathname)
	;; Be paranoid about the pathname.
	(condition-case (err)
	     (setq pathname (fs:merge-pathnames pathname))
	   (error (return-from top err)))
	(condition-case (err)
	     (read-spell-dictionary-internal pathname menu-p)
	   ((fs:file-error fs:network-error)
	    (return-from top err)))))
    (unless for-general-use
      (setq *automatically-read-dictionaries* nil))
    nil))

;;; This function is externally advertised.  It's mainly intended to be
;;; used in patch files.
(defun add-words-to-spell-dictionary (pathname list-of-words
				      &optional ok-if-dictionary-not-found)
  (setq pathname (fs:merge-pathnames pathname))
  (cl:check-type list-of-words list)
  (let ((dictionary
	  (dolist (d *dictionaries*)
	    (when (eq pathname (spell:dictionary-pathname d))
	      (return d)))))
    (when (null dictionary)
      (when ok-if-dictionary-not-found (return-from add-words-to-spell-dictionary nil))
      (ferror "There is no dictionary loaded with the pathname ~S" pathname))
    (dolist (word list-of-words)
      (cl:check-type word string)
      (let ((word-length (array-active-length word)))
	(when (> word-length 1)
	  (spell:encode-string
	    (string-upcase word)
	    word-length
	    #'spell:add-word
	    dictionary)))))
  t)

;;; This function is externally advertised.  It's mainly intended to be
;;; used in patch files.
(defun delete-words-from-spell-dictionary (pathname list-of-words
					   &optional ok-if-dictionary-not-found)
  (setq pathname (fs:merge-pathnames pathname))
  (cl:check-type list-of-words list)
  (let ((dictionary
	  (dolist (d *dictionaries*)
	    (when (eq pathname (spell:dictionary-pathname d))
	      (return d)))))
    (when (null dictionary)
      (when ok-if-dictionary-not-found (return-from delete-words-from-spell-dictionary nil))
      (ferror "There is no dictionary loaded with the pathname ~S" pathname))
    (dolist (word list-of-words)
      (cl:check-type word string)
      (let ((word-length (array-active-length word)))
	(when (> word-length 1)
	  (spell:encode-string
	    (string-upcase word)
	    word-length
	    #'spell:delete-word
	    dictionary)))))
  t)

;;; Various ways to prompt with the mouse.

(defvar *expose-the-menu* :corner)

;;; Return the rectangular area occupied by the marked word, in outside
;;; coordinates relative to superior.  If superior is nil, just return
;;; inside coordinates relative to the pane's window.
(defun marked-area (superior)
  (declare (values x1 y1 x2 y2))
  (destructuring-bind (left top right bottom)
		      (first (interval-highlighting-boxes *window* (point) (mark)))
    (let ((sheet (window-sheet *window*)))
      (cond (superior
	     (multiple-value-bind (x-offset y-offset)
		 (tv:sheet-calculate-offsets sheet superior)
	       (incf left x-offset)
	       (incf right x-offset)
	       (incf top y-offset)
	       (incf bottom y-offset)))
	    (t
	     (decf left (tv:sheet-left-margin-size sheet))
	     (decf right (tv:sheet-left-margin-size sheet))
	     (decf top (tv:sheet-top-margin-size sheet))
	     (decf bottom (tv:sheet-top-margin-size sheet)))))
    (values left top right bottom)))

(defun expose-the-menu (menu)
  (selectq *expose-the-menu*
    (:mouse
     (tv:expose-window-near menu '(:mouse)))
    (:right
     ;; Toy version to expose the menu just to the right of the word.
     (tv:expose-window-near
       menu 
       ;; The :rectangle spec is expected in outside coordinates
       ;; w.r.t. the menu's superior.
       (cons ':rectangle (multiple-value-list (marked-area (send menu :superior))))))
    (:corner
     ;; Expose the menu in the lower-right corner of the pane.  But if that
     ;; would overlap the word, the scoot it up a bit.
     (let ((superior (send menu :superior))
	   (pane (window-sheet *window*)))
       (when (eq pane (window-sheet *mini-buffer-window*))
	 (setq pane (send (send pane :superior) :superior)))
       (multiple-value-bind (menu-width menu-height)
	   (send menu :size)
	 (multiple-value-bind (pane-inside-width pane-inside-height)
	     (send pane :inside-size)
	   (let ((menu-x (- pane-inside-width menu-width))
		 (menu-y (- pane-inside-height menu-height)))
	     (multiple-value-bind (nil word-top word-right word-bottom)
		 (marked-area nil)
	       (when (and (> word-bottom menu-y)
			  (> word-right menu-x))
		 ;; Menu would overlap the word.  Move the menu up.
		 ;; The item height term is a fudge factor.
		 (setq menu-y (- word-top menu-height (- word-bottom word-top))))
	       (when (minusp menu-y)
		 ;; Uh-oh.  The menu is too tall to fit.  Try a new geometry.
		 (multiple-value-bind (nil menu-inside-height)
		     (send menu :inside-size)
		   (let ((max-height (if (and (> word-bottom menu-y)
					      (> word-right menu-x))
					 (- pane-inside-height word-top)
					 pane-inside-height))
			 (margins (- menu-height menu-inside-height)))
		     (send menu :set-geometry 
			   (ceiling menu-inside-height (- max-height margins)))))
		 (multiple-value (menu-width menu-height) (send menu :size))
		 (setq menu-x (- pane-inside-width menu-width)
		       menu-y (- pane-inside-height menu-height))
		 (when (and (> word-bottom menu-y)
			    (> word-right menu-x))
		   (setq menu-y (- word-top menu-height (- word-bottom word-top))))))
	     (cond ((minusp menu-y)
		    ;; After all that, it still doesn't fit.  Punt all this smarts.
		    (send menu :set-geometry 1)
		    (tv:expose-window-near menu '(:mouse)))
		   (t		    
		    ;; Now we have the real menu position, in inside coords of the pane.
		    (multiple-value-bind (x-offset y-offset)
			(tv:sheet-calculate-offsets pane superior)
		      (send menu :set-position
			    (+ menu-x (tv:sheet-left-margin-size pane) x-offset)
			    (+ menu-y (tv:sheet-top-margin-size pane)  y-offset))
		      (send menu :expose)
		      (multiple-value-bind (x y)
			  (send menu :item-cursorpos (send menu :last-item))
			(cond ((and x y)
			       (send menu :set-mouse-position
				     (+ x (tv:sheet-inside-left menu))
				     (+ y (tv:sheet-inside-top menu))))
			      (t
			       (send menu :set-mouse-position
				     (// menu-width 2) (// menu-height 2)))))))))))))))
