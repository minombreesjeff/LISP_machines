;;; -*- Mode: LISP; Syntax: Common-lisp; Package: FED; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;These are the definitions for the new font hacking stuff.
;;;The elements of a FONT-DESCRIPTOR are either NIL or a CHAR-DESCRIPTOR.
;;;If NIL then this character is not defined for this font.

(defstruct (font-descriptor :array-leader :named
			    (:conc-name nil)
			    (:constructor-make-array-keywords length
							      #+fixed (element-type t)
							      #-fixed (type 'sys:art-q)
							      ))
	   (fd-fill-pointer 0)
	   fd-name
	   fd-line-spacing		;Vertical distance between baselines.
	   fd-baseline			;Vertical distance from top of characters
					;in this font.  The baseline is what is
					;aligned for different fonts.
	   fd-blinker-height		;Height of a "blinker" in this font.
	   fd-blinker-width		;Width of a "blinker" in this font.
	   fd-space-width		;Width of a space.
	   fd-double-width-p		;T means this font is intended for display
					;with twice as many pixels per unit distance
					;in the horizontal direction. (ESCAPE 7)

					;The rest is for saving info that
					;comes in Xerox fonts, so we don't lose it.
	   (fd-vert-resolution 3840.)	;Dots per inch, times ten.
	   (fd-horiz-resolution 3840.)	;" "
					;Default is right for the Dover.
	   (fd-rotation 0)		;Rotation in degrees.
	   )

;A CHAR-DESCRIPTOR is a two dimensional array (with leader).
;The first dimension is the height of the character and the second is the width

(defstruct (char-descriptor :array-leader :named
			    (:conc-name nil)
			    (:constructor-make-array-keywords length
							      #+fixed element-type
							      #-fixed type
							      ))
	   cd-fill-pointer
	   cd-name
	   cd-char-width		;The horizontal distance taken by this character
	   cd-char-vert-width		;Vertical spacing caused by this character
					;(always 0 for the usual horizontal font).
					;For the sake of Xerox fonts.
	   cd-char-left-kern)		;The distance to the left to move before placing the
					;character.  A left kern of -5 means the array is to
					;be placed 5 units to the right of the current position.
;NOTE: the CHAR-WIDTH is measured from the current position to the new position.
;the LEFT-KERN is not used in this computation therefore if the LEFT-KERN plus
;the width (second dimension) of the array is greater than the CHAR-WIDTH the
;character will overlap the next character on the line.
;A positive value of LEFT-KERN will cause the character to overlap the space of the
;last character.

(defsubst cd-raster-height (cd)
  (array-dimension cd 0))

(defsubst cd-raster-width (cd)
  (array-dimension cd 1))

;;(loop for (big-half little-half) being successive-halvings of n do ...)
;;Too bad about arrogating the destructuring syntax, I guess.

(eval-when (load compile)

(define-loop-path successive-halvings
		  successive-halvings-loop-expander
  (of)						;allowable prepositions
  )



) ;eval-when

;The functions in this file
;are used to convert between the various formats for fonts as used on the LISP
;Machine.  These are the formats currently supported in some way:
;	KST format is used for communication with the PDP-10.
;	FD (or Font Descriptor) Format is used as a machine resident format
;		which is easily manipulated.  The format consists of a #o200
;		or more element array with a leader.  The elements of this array are
;		themselves two dimensional arrays which contain the actual
;		pixel values for the character.
;	FONT (or internal) Format is the format actually used by the tv display
;		routines.  The format is fairly complicated and its direct
;		use is not recommended when a conversion to FD format would
;		be better.
;	AL format is used for ALTO fonts.
;	AC another xerox format.
;	KS kerned strike xerox format.
;	AST stars and spaces.

;Conversion functions:
; FONT-INTO-FONT-DESCRIPTOR FONTNAME => FONT-DESCRIPTOR
;  (you might really want FONT-NAME-FONT-DESCRIPTOR, which remembers the FONT-DESCRIPTOR)
; FONT-DESCRIPTOR-INTO-FONT FONT-DESCRIPTOR => FONTNAME
; READ-X-INTO-FONT FILENAME &OPTIONAL FONTNAME => FONTNAME
; READ-X-INTO-FONT-DESCRIPTOR FILENAME &OPTIONAL FONTNAME => FONT-DESCRIPTOR
; WRITE-FONT-INTO-X FONTNAME &OPTIONAL FILENAME => OUTPUT-TRUENAME
; WRITE-FONT-DESCRIPTOR-INTO-X FONT-DESCRIPTOR &OPTIONAL FILENAME => OUTPUT-TRUENAME

; Routines that know about the machine dependent internal font format (rather than going
; through the font-descriptor intermediate format) are in LFONT or QFONT as appropriate.

;Other useful functions in here:
; THICKEN-FONT[-DESCRIPTOR], makes B(old) fonts.
; ROTATE-FONT[-DESCRIPTOR], makes R(otated) fonts.  I.e. landscape from portrait.

; CD-RASTER-RANGE CHAR-DESCRIPTOR => MINX MINY MAXX MAXY
; CD-UNUSED-RASTER-HEIGHT CHAR-DESCRIPTOR => BOTTOM TOP

;First some helping functions:

;Maximum raster width of an FD format font
(defun max-raster-width (font-descriptor &aux (guess 0) temp)
  (do ((char-code 0 (1+ char-code))
       (font-length (length font-descriptor)))
      (( char-code font-length) guess)
    (cond ((setq temp (aref font-descriptor char-code))
	   (setq guess (max guess (cd-raster-width temp)))))))

;Maximum raster height of an FD format font
(defun max-raster-height (font-descriptor &aux (guess 0) temp)
  (do ((char-code 0 (1+ char-code))
       (font-length (length font-descriptor)))
      (( char-code font-length) guess)
    (cond ((setq temp (aref font-descriptor char-code))
	   (setq guess (max guess (cd-raster-height temp)))))))

;;; Memoizing version of FONT-INTO-FONT-DESCRIPTOR
;;; that wants a font name (symbol in FONTS:) rather than the font itself.
;;; The FONT-DESCRIPTOR property of the symbol holds the descriptor.
;;; The FONT-DESCRIBED property holds the font itself which the descriptor matches.
;;; If anyone changes the font, we can see that the old descriptor is no good.
(defun font-name-font-descriptor (fontname &aux fd)
  (setq fd (get fontname 'font-descriptor))
  (cond ((and fd (eq (get fontname 'font-described) (symbol-value fontname))))
	(t (setq fd (font-into-font-descriptor (symbol-value fontname)))
	   (setf (get fontname 'font-described) (symbol-value fontname))
	   (setf (get fontname 'font-descriptor) fd)))
  fd)

;;; Set a font given a font descriptor.  Keep the descriptor around.
;;; Forward the old definition of the font to the new one.
(defun font-name-set-font-and-descriptor (fontname font-descriptor)
  (let ((oldfont (and (boundp fontname) (symbol-value fontname))))
    (set fontname (font-descriptor-into-font font-descriptor))
    (and oldfont (structure-forward oldfont (symbol-value fontname)))
    (setf (get fontname 'font-descriptor) font-descriptor)
    (setf (get fontname 'font-described) (symbol-value fontname))
    (si:nremprop fontname 'bfont-descriptor)
    (si:nremprop fontname 'bfont-described)
    font-descriptor))

(defun fd-store-cd (fd cd ch)
  (and ( ch (array-total-size fd))
       (adjust-array fd (+ ch #o100)))
  (and ( ch (fd-fill-pointer fd))
       (setf (fd-fill-pointer fd) (1+ ch)))
  (setf (aref fd ch) cd))

;; Given filename and fontname from filename &optional fontname, canonicalize them
(defun get-input-filename-and-fontname (filename fontname file-canonical-type)
  (declare (values filename fontname))
  (setq filename
	(fs:merge-pathnames
	  filename
	  (send (fs:default-pathname (pathname-defaults))
		':new-canonical-type file-canonical-type)))
  (or fontname (setq fontname (send filename ':name)))
  (and (stringp fontname) (setq fontname (intern (string-upcase fontname) si:pkg-fonts-package)))
  (values filename fontname))

;; Read in a kst file and make and return a FONT-DESCRIPTOR,
;; which is an alternate convenient representation for a font.
(defun read-kst-into-font-descriptor (filename &optional fontname &aux fd)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':kst))
  (with-open-file (stream filename :element-type '(cl:unsigned-byte 9.))
    (setq fd (make-font-descriptor :fd-name fontname :length 128))
    ;; Discard KSTID.
    (dotimes (i 4) (funcall stream ':tyi))
    ;; Discard column position adjust until I find out what it means.
    (or (zerop (funcall stream ':tyi))
	(error nil
		"Nonzero column-position-adjust in font ~A -- what does that mean?"
		fontname))
    (setf (fd-space-width fd) 0)		;Just in case no space character.
    (setf (fd-baseline fd) (funcall stream ':tyi))
    (setf (fd-line-spacing fd) (read-kst-halfword stream))
    (setf (fd-blinker-height fd)
	  (fd-line-spacing fd))
    (setf (fd-name fd) fontname)
    (let (kern char-code raster-width char-width byte-list byte-list-head cd tem
	  (line-height (fd-line-spacing fd)))
      (loop as header = (logior (ash (read-kst-halfword stream) 18.)
				(read-kst-halfword stream))
	    until (= header -1)
	    unless (= header 1)
	      do (error nil "~O where character header expected; KST file misformatted"
			     header)
	do
	(setq kern (read-kst-halfword stream))
	(setq char-code (read-kst-halfword stream))
	(setq raster-width (read-kst-halfword stream))
	(setq char-width (read-kst-halfword stream))
	(setq cd (make-char-descriptor
		   :length (list line-height raster-width)
		   #+fixed #+fixed :element-type 'bit
		   #-fixed #-fixed :type 'sys:art-1b
		   ))
	(setf (cd-char-width cd) char-width)
	(setf (cd-char-left-kern cd) kern)
	(fd-store-cd fd cd char-code)
	(and (= char-code (char-code #\Sp))
	     (setf (fd-space-width fd) char-width))
	;; read in the bits of the character
	(setq byte-list nil
	      byte-list-head (list nil nil nil nil))
	(dotimes (vpos line-height)
	  ;; Read in the next row.
	  (dotimes (hpos raster-width)
	    ;; If byte is exhausted, get next byte into (car byte-list)
	    (cond ((zerop (rem hpos 8))
		   (setq byte-list (read-kst-bytes stream byte-list byte-list-head))))
	    (setq tem (logand 1 (lsh (car byte-list) (- (rem hpos 8)))))
	    (setf (aref cd vpos hpos) tem)))))
    ;; Truncate fd to discard unused elements at the end.
    (do ((i (1- (array-total-size fd)) (1- i)))
	((or (minusp i)
	     (aref fd i))
	 (adjust-array fd (1+ i))))
    (setf (fd-fill-pointer fd) (array-total-size fd))
    ;; Set width of blinker and space fields from the space character.
    (setf (fd-blinker-width fd)
	  (fd-space-width fd)))
  fd)

;; Scan a kst file and return two values which are the
;; raster width and raster height needed in a TV format font to contain that font.
(defun read-kst-max-raster-width (filename &aux raster-height (raster-width 0)
						char-raster-width)
  (setq filename (fs:merge-pathnames
		   filename
		   (send (fs:default-pathname (pathname-defaults))
			 ':new-canonical-type ':kst)))
  (with-open-file (stream filename :element-type '(cl:unsigned-byte 9.))
    ;; Discard KSTID.
    (dotimes (i 4) (funcall stream ':tyi))
    ;; Discard column-position-adjust
    (funcall stream ':tyi)
    ;; Discard baseline.
    (funcall stream ':tyi)
    ;; Remember font line height as raster height.
    (setq raster-height (read-kst-halfword stream))
    ;; Keep maxing raster widths of characters into raster-width
    (setq raster-width 0)
    (loop as header = (logior (ash (read-kst-halfword stream) 18.) (read-kst-halfword stream))
	  until (= header -1)
	  unless (= header 1)
	    do (error nil "~O where character header expected; KST file misformatted" header)
      do
      ;; Ignore char's left kern.
      (read-kst-halfword stream)
      ;; Ignore its character code.
      (read-kst-halfword stream)
      ;; Max in its raster width
      (setq char-raster-width (read-kst-halfword stream))
      (setq raster-width (max raster-width char-raster-width))
      ;; Ignore its character width.
      (read-kst-halfword stream)
      ;; Skip the bits of the character
      (let ((bytes (* raster-height (floor (+ char-raster-width 7) 8))))
	(setq bytes (* 4 (floor (+ bytes 3) 4)))
	(dotimes (i bytes)
	  (funcall stream ':tyi)))))
  (values raster-width raster-height))

;; Fetch the next 8-bit byte where stream is a 9-bit byte stream.
;; byte-list-head should be a list of 4 things we can clobber.
;; byte-list is a tail of it.
;; We advance it, and if it is empty we fill byte-list-head
;; with four more 8-bit bytes and return that.
;; The car of our value is the next byte.
;; Save the value for the byte-list arg next time.
(defun read-kst-bytes (stream byte-list byte-list-head)
  (or (cdr byte-list)
      ;; Exhausted the word - read another.
      (let ((hwd1 (read-kst-halfword stream))
	    (hwd2 (read-kst-halfword stream)))
	(setq byte-list byte-list-head)
	;; Turn it into 4 8-bit bytes in byte-list.
	(rplaca byte-list (ldb (byte 8. 10.) hwd1))
	(rplaca (cdr byte-list) (ldb (byte 8. 2.) hwd1))
	(rplaca (cddr byte-list)
		(+ (lsh (ldb (byte 2. 0.) hwd1) 6)
		   (ldb (byte 6. 12.) hwd2)))
	(rplaca (cdddr byte-list) (ldb (byte 8. 4.) hwd2))
	byte-list)))

;; Read two 9-bit bytes from stream, make an 18-bit halfword,
;; and sign-extend it.
(defun read-kst-halfword (stream &aux hwd)
  (setq hwd (dpb (funcall stream ':tyi) (byte 9. 9.) (funcall stream ':tyi)))
  (cond ((logtest hwd #o400000)
	 (logior hwd #o-400000))
	(t hwd)))

;;; Given FONTNAME and FILENAME from FONTNAME &OPTIONAL FILENAME, canonicalize them.
(defun get-output-filename-and-fontname (fontname filename file-canonical-type)
  (declare (values fontname filename))
  (and (stringp fontname) (setq fontname (intern (string-upcase fontname) si:pkg-fonts-package)))
  (or filename (setq filename (string fontname)))
  (setq filename
	(fs:merge-pathnames
	  filename
	  (send (fs:default-pathname (pathname-defaults))
		':new-canonical-type file-canonical-type)))
  (values fontname filename))

(defun get-output-filename-from-font-descriptor (font-descriptor filename file-type)
  (or filename (setq filename (string (fd-name font-descriptor))))
  (fs:merge-pathnames filename
		      (send (fs:default-pathname (pathname-defaults))
			    ':new-canonical-type file-type)))

(defun write-font-descriptor-into-kst (fd &optional filename
					  &aux (font-length (length fd)))
  (setq filename (get-output-filename-from-font-descriptor fd filename ':kst))
  (with-open-file (stream filename :direction :output :element-type '(cl:unsigned-byte 9.))
    ;; Write KSTID as 0.
    (dotimes (i 4) (funcall stream ':tyo 0))
    ;; Write column position adjust as 0.
    (funcall stream ':tyo 0)
    ;; Write baseline and height into second header word.
    (funcall stream ':tyo (fd-baseline fd))
    (write-kst-halfword stream (fd-line-spacing fd))
    ;; Then write out all the characters.
    (let (cd char-height byte-count byte byte-list byte-list-head)
       (dotimes (char-code font-length)
          (cond ((and (setq cd (aref fd char-code))
                      ;; Wide fonts without chars-exist-tables can have 0-width chars.
                      (or (not (zerop (cd-raster-width cd)))
                          (not (zerop (cd-char-width cd)))))
            ;; Each char must start with a word containing a 1.
            (write-kst-halfword stream 0)
            (write-kst-halfword stream 1)
            ;; left kern and char code fill the next word.
            (write-kst-halfword stream (cd-char-left-kern cd))
            (write-kst-halfword stream char-code)
            ;; Raster width and char width are the next word.
            (write-kst-halfword stream (cd-raster-width cd))
            (write-kst-halfword stream (cd-char-width cd))
	    ;; Write out the bits of the character
            ;; Byte-list and its head are used to accumulate 4 bytes
            ;; and then output them at once as a word.
            ;; This is needed because the stream wants 9-bit bytes.
            (setq byte-list-head (list nil nil nil nil))
            (setq byte-list byte-list-head)
            (setq byte-count 0)
            (setq char-height (cd-raster-height cd))
            (and (> char-height (fd-line-spacing fd))
                 (error nil "Character ~C height exceeds font line height in KST file"
                         char-code))
            (cond ((not (zerop (cd-raster-width cd)))
		   (dotimes (vpos (fd-line-spacing fd))
		     ;; Prepare to extract next row of char from font.
		     (setq byte 0)
		     ;; Get the row a bit at a time and fill up 8-bit bytes.
		     ;; Output the bytes when full.  Output the excess at the end.
		     ;; Count the bytes output with byte-count
		     (dotimes (hpos (cd-raster-width cd))
		       (cond ((and (= (rem hpos 8) 0) (not (zerop hpos)))
			      (setq byte-count (1+ byte-count))
			      (setq byte-list
				    (write-kst-byte stream byte byte-list byte-list-head))
			      (setq byte 0)))
		       (or ( vpos char-height)
			   (setq byte (+ byte (lsh (aref cd vpos hpos) (rem hpos 8))))))
		     (setq byte-list (write-kst-byte stream byte byte-list byte-list-head))
		     (setq byte-count (1+ byte-count)))
		   ;; Pad to a word boundary.
		   (do () ((zerop (rem byte-count 4)))
		     (setq byte-list (write-kst-byte stream 0 byte-list byte-list-head))
		     (setq byte-count (1+ byte-count))))))))
       ;; Mark end of file with two -1 words.
       (dotimes (i 8)
	 (funcall stream ':tyo #o777)))
    (funcall stream ':close)
    (funcall stream ':truename)))

;; Write an 8-bit byte to the kst file.  We pack 4 bytes per word.
;; The stream is assumed to want 9-bit bytes.
;; Byte-list-head should be a list of length 4 we can clobber.
;; byte-list should initially be the same thing;  we return a new value to set it to.
(defun write-kst-byte (stream byte byte-list byte-list-head)
  (rplaca byte-list byte)
  (pop byte-list)
  (cond ((null byte-list)
	 (setq byte-list byte-list-head)
	 (write-kst-halfword stream
			     (+ (lsh (first byte-list) 10.)
				(lsh (second byte-list) 2.)
				(ldb (byte 2. 6.) (third byte-list))))
	 (write-kst-halfword stream
			     (+ (lsh (ldb (byte 6. 0.) (third byte-list)) 12.)
				(lsh (fourth byte-list) 4)))))
  byte-list)

(defun write-kst-halfword (stream halfword)
  (funcall stream ':tyo (ldb (byte 9. 9.) halfword))
  (funcall stream ':tyo (ldb (byte 9. 0.) halfword)))

;; ALTO .AL format
;;;??? Not yet converted to load more than #o200 chars into a font.

;; Load an ALTO font file into a font, the easy way, via a font descriptor
(defun read-al-into-font (filename &optional fontname)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':al))
  (font-name-set-font-and-descriptor fontname
				     (read-al-into-font-descriptor filename fontname))
  fontname)

;; Load an ALTO font file into a font descriptor
(defun read-al-into-font-descriptor (filename &optional fontname
				     &aux fd array line-height proportional max-width)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':al))
  (setq fd (make-font-descriptor :fd-name fontname))
  (setf (fd-name fd) fontname)
  (with-open-file (stream filename :element-type '(cl:unsigned-byte 16.))
    (setq line-height (funcall stream ':tyi))
    (setf (fd-line-spacing fd) line-height)
    (setf (fd-blinker-height fd) line-height)
    (let ((baseline-and-max-width (funcall stream ':tyi)))
      (setq proportional (ldb-test (byte 1. 15.) baseline-and-max-width))
      (setf (fd-baseline fd) (ldb (byte 7. 8.) baseline-and-max-width))
      (setf (fd-space-width fd) (setq max-width (ldb (byte 8. 0.) baseline-and-max-width))))
    (setq array (make-array 1000. :element-type '(unsigned-byte 16) :leader-list '(0)))
    (do ch (funcall stream ':tyi) (funcall stream ':tyi) (null ch)
      (vector-push-extend ch array)))
  (do ((ch 0 (1+ ch))
       (cd)
       (char-width))
      (( ch #o200))	;Alto font could have #o400 characters, our fonts don't yet
    (setq char-width 0)
    (do ((idx ch)
	 (xw))
	(nil)
      (setq idx (+ idx (aref array idx)))
      (setq xw (aref array idx))
      (if (zerop (prog1 (logand xw 1) (setq xw (floor xw 2))))
	  (setq char-width (+ char-width 16.)
		idx xw)
	  (return (setq char-width (+ char-width xw)))))
    (setq cd (make-char-descriptor :length (list line-height char-width)
				   #+fixed #+fixed :element-type 'bit
				   #-fixed #-fixed :type 'sys:art-1b))
    (setf (cd-char-width cd) char-width)
    (and (= ch (char-code #\Sp)) (setf (fd-space-width fd) char-width))
    (setf (cd-char-left-kern cd) 0)
    (fd-store-cd fd cd ch)
    (read-al-into-font-descriptor-1 cd array ch 0))
  (setf (fd-fill-pointer fd) #o200)
  ;; Set width of blinker and space fields from the space character.
  (setf (fd-blinker-width fd) (fd-space-width fd))
  fd)

;;;IDX is the address of the character-pointer
(defun read-al-into-font-descriptor-1 (cd array idx xoff &aux xw hd-and-xh)
  (setq idx (+ idx (aref array idx)))
  (setq xw (aref array idx)
	hd-and-xh (aref array (1+ idx)))
  (do ((i (- idx (ldb (byte 8. 0.) hd-and-xh)) (1+ i))
       (y (ldb (byte 8. 8.) hd-and-xh) (1+ y)))
      ((= i idx))
    (do ((bits (aref array i) (lsh bits 1))
	 (x xoff (1+ x))
	 (cw (cd-char-width cd)))
	((or (zerop bits) ( x cw)))		;Can be garbage to right of raster
      (and (logtest #o100000 bits)
	   (setf (aref cd y x) 1))))
  (or (logtest 1 xw)
      (read-al-into-font-descriptor-1 cd array (floor xw 2) (+ xoff 16.))))

(defun write-font-into-al (fontname &optional filename)
  (multiple-value-setq (fontname filename)
    (get-output-filename-and-fontname fontname filename ':al))
  (let ((fd (font-name-font-descriptor fontname)))
    (write-font-descriptor-into-al fd filename)))

;I don't think this does the desired thing for variable-width ("proportional") fonts
(defun write-font-descriptor-into-al (fd &optional filename &aux array carray line-height)
  (setq filename (get-output-filename-from-font-descriptor fd filename ':al))
  (with-open-file (stream filename :direction :output :element-type '(cl:unsigned-byte 16.))
    (funcall stream ':tyo (setq line-height (fd-line-spacing fd)))
    (funcall stream ':tyo (dpb (fd-baseline fd) (byte 7. 8.) (fd-space-width fd)))
    (setq array (make-array 1000. :element-type '(unsigned-byte 16) :leader-list '(0))	;Data array
	  carray (make-array #o400 :element-type '(unsigned-byte 16) :leader-list '(#o400)))	;Non self-rel chars
    ;; Store dummy
    (vector-push-extend 1 array)
    (vector-push-extend 0 array)
    (loop for ch from 0 below (fd-fill-pointer fd)
	  as cd = (aref fd ch)
	  unless (null ch)
	  do (loop with char-width = (cd-char-width cd)
		   with ch = ch with (xw hd-xh)
		   for xoff from 0 by 16. below char-width
		   do (setq hd-xh (write-al-column cd xoff array))
		      (setf (aref carray ch) (array-leader array 0))
		      (setq xw (if (> (- char-width xoff) 16.)
				   (* (setq ch (prog1 (array-leader carray 0)
						      (vector-push-extend 0 carray)))
				      2)
				   (1+ (* (- char-width xoff) 2))))
		      (vector-push-extend xw array)
		      (vector-push-extend hd-xh array))
	  else do (setf (aref carray ch) 0))
    (loop for i from 0 below (length carray)	;Make self-relative
	  do (setf (aref carray i)
		   (- (+ (aref carray i) (length carray)) i)))
    (funcall stream ':string-out carray)
    (funcall stream ':string-out array)
    (funcall stream ':close)
    (funcall stream ':truename)))

(defun write-al-column-row (cd xoff y)
  (loop with stuff = 0
	for x from (+ xoff (cd-char-left-kern cd)) below (cd-raster-width cd)
	as mask = #o100000 then (lsh mask -1) until (zerop mask)
	when (and (not (minusp x)) (not (zerop (aref cd y x))))
	  do (setq stuff (logior stuff mask))
	finally (return stuff)))

(defun write-al-column (cd xoff array &aux (hd 0) (xc 0))
  (loop for y from 0 to (loop for y from (1- (cd-raster-height cd)) downto 0
			      while (zerop (write-al-column-row cd xoff y))
			      finally (return y))
	as row = (write-al-column-row cd xoff y)
	do (if (and (zerop row) (zerop xc))
	       (setq hd (1+ hd))
	       (vector-push-extend row array)
	       (setq xc (1+ xc))))
  (dpb hd (byte 8. 8.) xc))

;; ALTO .KS format
;; Load a kerned-strike file into a font
(defun read-ks-into-font (filename &optional fontname)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':ks))
  (font-name-set-font-and-descriptor fontname
	(read-ks-into-font-descriptor filename fontname))
  fontname)

;; Load a kerned-strike font file into a font descriptor
(defun read-ks-into-font-descriptor (filename &optional fontname
					      &aux fd line-height max-width wd fixed-width
					      min-char max-char strike-nwds fbbox
					      ascent descent words-per-raster
					      bitmap bitmap16 index)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':ks))
  (setq fd (make-font-descriptor :fd-name fontname))
  (setf (fd-name fd) fontname)
  (with-open-file (stream filename :element-type '(cl:unsigned-byte 16.))
    (setq wd (funcall stream ':tyi))
    (or (logtest #o100000 wd) (error nil "Not \"new format\""))
    (and (logtest #o40000 wd) (error nil "StrikeIndex format not understood"))
    (setq fixed-width (logtest #o20000 wd))
    (or (logtest #o10000 wd) (error nil "PlainStrike format not understood"))
    (setq min-char (funcall stream ':tyi) max-char (funcall stream ':tyi))
    (setq max-width (funcall stream ':tyi))
    (setq fbbox (funcall stream ':tyi))		;Font bounding-box X-offset
    (if (logtest #o100000 fbbox) (setq fbbox (- fbbox #o200000)))	;signed
    (dotimes (i 3) (funcall stream ':tyi))	;Ignore rest of font bounding box
    (setq strike-nwds (funcall stream ':tyi)
	  ascent (funcall stream ':tyi)
	  descent (funcall stream ':tyi))
    (setq line-height (+ ascent descent))
    (funcall stream ':tyi)			;Ignore xoffset
    (setq words-per-raster (funcall stream ':tyi))
    (setf (fd-line-spacing fd) line-height)
    (setf (fd-blinker-height fd) line-height)
    (setf (fd-baseline fd) ascent)
    (setf (fd-space-width fd) max-width)
    ;; Now copy the bitmap (the goddamn words are bit-reversed!)
    (setq bitmap16 (make-array (list words-per-raster line-height) :element-type '(unsigned-byte 16))
	  bitmap (make-array (list (* words-per-raster 16.) line-height)
			     :element-type 'bit :displaced-to bitmap16))
    (dotimes (y line-height)
      (dotimes (x words-per-raster)
	(setf (aref bitmap16 (- words-per-raster x 1) y) (funcall stream ':tyi))))
    ;; Copy the index segment
    (setq index (make-array (+ (- max-char min-char) 3) :element-type '(unsigned-byte 16)))
    (dotimes (i (array-total-size index))
      (setf (aref index i) (funcall stream ':tyi)))
    ;; Read the width table and make the characters
    (loop for ch from min-char to (min (1+ max-char) #o177) with cd
	  as xleft = (aref index (- ch min-char))
	  as xright = (aref index (1+ (- ch min-char)))
	  as wde = (funcall stream ':tyi)
	  unless (= wde #o177777)		;Nonexistent character
	  do (setq cd (make-char-descriptor
			:length (list line-height (- xright xleft))
			#+fixed #+fixed :element-type 'bit
			#-fixed #-fixed :type 'sys:art-1b))
	     (setf (cd-char-width cd) (ldb (byte 8. 0.) wde))
	     (and (= ch (char-code #\Sp)) (setf (fd-space-width fd) (cd-char-width cd)))
	     (setf (cd-char-left-kern cd) (- (+ (ldb (byte 8. 8.) wde) fbbox)))
	     (setf (aref fd ch) cd)
	     (loop for y from 0 below line-height do
	       (loop for x from 0 below (- xright xleft)
		     as bmx downfrom (- (cd-raster-height bitmap) xleft 1)
		     do (setf (aref cd y x) (aref bitmap bmx y)))))
  (setf (fd-fill-pointer fd) #o200)
  ;; Set width of blinker and space fields from the space character.
  (setf (fd-blinker-width fd) (fd-space-width fd))
  fd))

;;; Some useful font munging functions
(defun thicken-font-descriptor (fd &optional new-name &aux len nfd)
  (or new-name (setq new-name (intern (string-append (fd-name fd) #\B) si:pkg-fonts-package)))
  (setq len (length fd)
	nfd (make-font-descriptor :length len
				  #+fixed #+fixed :element-type 't
				  #-fixed #-fixed :type 'sys:art-q
				  :fd-fill-pointer (fd-fill-pointer fd)
				  :fd-name new-name
				  :fd-line-spacing (fd-line-spacing fd)
				  :fd-baseline (fd-baseline fd)
				  :fd-blinker-height (fd-blinker-height fd)
				  :fd-blinker-width (fd-blinker-width fd) :fd-space-width (fd-space-width fd)))
  (do ((i 0 (1+ i))
       (cd) (ncd))
      (( i len))
    (and (setq cd (aref fd i))
	 (let ((width (cd-raster-width cd))
	       (height (cd-raster-height cd)))
	   (setq ncd (make-char-descriptor :length (list height (1+ width))
					   #+fixed #+fixed :element-type '(unsigned-byte 4)
					   #-fixed #-fixed :type 'sys:art-4b 
					   :cd-char-width (1+ (cd-char-width cd))
					   :cd-char-left-kern (cd-char-left-kern cd)))
	   ;; copy -- don't use COPY-ARRAY-CONTENTS, as the dims mismatch
	   (dotimes (row height)
	     (dotimes (col width)
	       (setf (aref ncd row col) (aref cd row col)))
	     (setf (aref ncd row width) 0))
	   ;; thicken
	   (dotimes (row height)
	     (dotimes (col width)
	       (setf (aref ncd row (1+ col))
		     (logior (aref ncd row (1+ col)) (aref cd row col)))))
	   (setf (aref nfd i) ncd))))
  nfd)

(defun thicken-font (font-symbol &aux fd nfd nfs)
  (setq fd (font-name-font-descriptor font-symbol)
	nfd (thicken-font-descriptor fd)
	nfs (fd-name nfd))
  (font-name-set-font-and-descriptor nfs nfd)
  nfs)

(defun unthicken-font-descriptor (fd new-name &aux len nfd)
  (setq len (length fd)
	nfd (make-font-descriptor :length len
				  #+fixed #+fixed :element-type 't
				  #-fixed #-fixed :type 'sys:art-q
				  :fd-fill-pointer (fd-fill-pointer fd)
				  :fd-name new-name
				  :fd-line-spacing (fd-line-spacing fd)
				  :fd-baseline (fd-baseline fd)
				  :fd-blinker-height (fd-blinker-height fd)
				  :fd-blinker-width (fd-blinker-width fd) :fd-space-width (fd-space-width fd)))
  (do ((i 0 (1+ i))
       (cd) (ncd))
      (( i len))
    (and (setq cd (aref fd i))
	 (let ((width (cd-raster-width cd))
	       (height (cd-raster-height cd)))
	   (setq ncd (make-char-descriptor :length (list height width)
					   #+fixed #+fixed :element-type '(unsigned-byte 4)
					   #-fixed #-fixed :type 'sys:art-4b 
					   :cd-char-width (cd-char-width cd)
					   :cd-char-left-kern (cd-char-left-kern cd)))
	   ;; dims match here, can use copy-array-contents
	   (copy-array-contents cd ncd)
	   ;110  100
	   (dotimes (row height)
	     (loop for col from (1- width) above 0
		   as right = 0 then this
		   as this first (aref cd row col) then left
		   as left = (aref cd row (1- col))
		   when (and (= left 1) (= this 1) (= right 0))
		     do (setf (aref ncd row col) 0)))
	   (setf (aref nfd i) ncd))))
  nfd)

(defun unthicken-font (font-symbol nfs &aux fd nfd)
  (setq fd (font-name-font-descriptor font-symbol)
	nfd (unthicken-font-descriptor fd nfs))
  (font-name-set-font-and-descriptor nfs nfd)
  nfs)

(defun rotate-font-descriptor (fd &aux length nfd)
  (setq length (length fd)
	nfd (make-font-descriptor :length length
				  :fd-fill-pointer (fd-fill-pointer fd)
				  :fd-name (intern (string-append (fd-name fd) #\R) si:pkg-fonts-package)
				  :fd-baseline (fd-space-width fd)
				  :fd-line-spacing (fd-space-width fd)
				  :fd-blinker-height (fd-blinker-width fd)
				  :fd-blinker-width (fd-blinker-height fd)
				  :fd-space-width (fd-line-spacing fd)
				  :fd-rotation 90.))
  (loop for ch from 0 below length
	as cd = (aref fd ch)
	when cd
	do (setf (aref nfd ch) (rotate-char-descriptor cd)))
  nfd)

(defun rotate-char-descriptor (cd)
  (let* ((hei (cd-raster-height cd))
	 (wid (cd-raster-width cd))
	 (ncd (make-char-descriptor :length (list wid hei)
				    #+fixed #+fixed :element-type (array-element-type cd)
				    #-fixed #-fixed :type (sys:array-type cd) 
				    :cd-char-left-kern 0 :cd-char-width hei)))
    (loop for x from 0 below wid do
      (loop for y from 0 below hei do
	(setf (aref ncd (- wid x 1) y)
	      (aref cd y x))))
    ncd))

(defun rotate-font (font-symbol &aux fd nfd nfs)
  (setq fd (font-name-font-descriptor font-symbol)
	nfd (rotate-font-descriptor fd)
	nfs (fd-name nfd))
  (font-name-set-font-and-descriptor nfs nfd)
  nfs)

(defmacro sign-extend (16bit-word)
  `(let ((word ,16bit-word))
     (if ( word #o100000)
	 (- word #o200000)
	 word)))

(defmacro high-byte (word)
  `(lsh ,word -8))

(defmacro low-byte (word)
  `(boole 1 #o377 ,word))

;Get next 16-bit word from input-file
(defun next-word ()
  (declare (special input-file))
  (funcall input-file ':tyi "Unexpected EOF on AC file"))

(compiler:function-defined 'press:bcpl-string)
(compiler:function-defined 'press:decode-font-name)
(compiler:function-defined 'press:decode-face)

;Read in an AC file as a Lisp machine font.
(defun read-ac-into-font (filename &optional fontname)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':ac))
  (font-name-set-font-and-descriptor fontname
				     (read-ac-into-font-descriptor filename fontname))
  fontname)

(defun read-ac-into-font-descriptor (filename &optional fontname
					      &aux family-name face-code point-size)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':ac))
  (with-open-file (input-file filename :element-type '(cl:unsigned-byte 16.))
    (declare (special input-file))
    (setf (values family-name face-code point-size)
	  (press:decode-font-name (string fontname)))
    (let ((code-alist nil)
	  (segment-data nil)
	  family-code tem segment
	  fd
	  (wd 0))
      (setq wd (next-word))
      ;; Read IXN entries (type 1)
      (do () ((not (= (lsh wd -12.) 1)))
	(let ((code (next-word))
	      (name (press:bcpl-string 20. input-file)))
	  (push (cons code name) code-alist))
	(setq wd (next-word)))
      ;; Find out the code number for the font family to be used,
      ;; either the specified one or the only one.
      (cond (family-name
	     (or (setq family-code (car (rassoc family-name code-alist :test #'equal)))
		 (error nil "Font family ~A not present in AC file" family-name)))
	    ((cdr code-alist)
	     (error nil "Font dictionary ~A: font family not specified" filename))
	    (t (setq family-code (caar code-alist))))
      ;; Read Index Entries (type 3) for AC segments.
      (do () ((not (= (lsh wd -12.) 3)))
	(setq wd (next-word))			;family,,face
	(setq tem
	      (list (high-byte wd)		;Family code number.
		    (press:decode-face (low-byte wd))	;Face name
		    (progn (setq wd (next-word))	;bc,,ec
			   (high-byte wd))	;First code
		    (low-byte wd)		;Last code
		    (next-word)			;Size
		    (next-word)			;Rotation
		    (+ (lsh (next-word) 16.) (next-word))	;Segment SA
		    (+ (lsh (next-word) 16.) (next-word))	;Segment Len
		    (next-word)			;horiz resolution
		    (next-word)))		;vert resolution
	(and (= (car tem) family-code) (push tem segment-data))
	(setq wd (next-word)))
      ;; Now should have type-0 entry (end of index)
      (case (lsh wd -12.)
	(0 )
	(5 (error nil "There are OrbitChars segments in this file -- I don't grok them"))
	(otherwise
	  (error nil "~O - Bullshit in file where type 0 IX expected" wd)))
      ;; Now either there should be only one segment or the face code and size
      ;; should have been specified.
      (cond ((and point-size face-code)
	     (dolist (seg segment-data)
	       (and (string-equal (cadr seg) face-code)
		    (= (floor (+ 1270. (* (fifth seg) 72.)) 2540.) point-size)
		    (return (setq segment seg))))
	     (or segment (error nil "Font ~A not found in AC file" fontname)))
	    ((cdr segment-data)
	     (error "Font dictionary ~A: point size or face code not specified" filename))
	    (t (setq segment (car segment-data)
		     point-size (floor (+ 1270. (* (fifth segment) 72.)) 2540.))))
      (funcall input-file ':set-pointer (seventh segment))
      (let ((bc (third segment))
	    (ec (fourth segment))
	    (baseline 0)
	    (xwidths (make-array #o400))
	    (ywidths (make-array #o400))
	    (box-x-offset (make-array #o400))
	    (box-y-offset (make-array #o400))
	    (box-x-size (make-array #o400))
	    (box-y-size (make-array #o400))
	    (char-data-position (make-array #o400))
	    line-height)
	;; read in the widths info from the segment.
	(do ((i bc (1+ i))) ((> i ec))
	  (setf (aref xwidths i)
		(+ (sign-extend (next-word)) (/ (next-word) 65536.0)))
	  (setf (aref ywidths i)
		(+ (sign-extend (next-word)) (/ (next-word) 65536.0)))
	  (setf (aref box-x-offset i) (sign-extend (next-word)))
	  (setf (aref box-y-offset i) (sign-extend (next-word)))
	  (setf (aref box-x-size i) (sign-extend (next-word)))
	  (setf (aref box-y-size i) (sign-extend (next-word))))
	;; Read relative pointers to character data beginnings
	;; and convert them to absolute pointers within the file.
	(do ((i bc (1+ i))
	     (starting-position (funcall input-file ':read-pointer)))
	    ((> i ec))
	  (setf (aref char-data-position i)
		(+ (lsh (next-word) 32.)
		   (next-word)
		   starting-position)))
	(setq fontname (string-append (cdr (assoc family-code code-alist))
				      (format nil "~D" point-size)
				      (or (second segment) "")))
	(setq fontname (intern (string-upcase fontname) si:pkg-fonts-package))
	(setq fd (make-font-descriptor :fd-name fontname
				       :length (1+ ec)))
	(setf (fd-fill-pointer fd) (1+ ec))
	(setf (fd-vert-resolution fd) (nth 9 segment))
	(setf (fd-horiz-resolution fd) (nth 8 segment))
	(setf (fd-rotation fd) (nth 5 segment))
	(do ((height 0)
	     (i bc (1+ i)))
	    ((> i ec)
	     (setq line-height (+ height baseline))
	     (setf (fd-line-spacing fd) line-height)
	     (setf (fd-blinker-height fd) line-height)
	     (setf (fd-baseline fd) (- line-height baseline)))
	  (cond (( (aref box-y-size i) -1)
		 (setq height (max height (+ (aref box-y-size i) (aref box-y-offset i))))))
	  (cond (( (aref box-y-size i) -1)
		 (setq baseline (max baseline (- (aref box-y-offset i)))))))
	(do ((ch bc (1+ ch))
	     (char-width)
	     (raster-height)
	     (raster-width)
	     (char-y-offset)
	     (wd)
	     (cd))
	    ((> ch ec))
	  (cond (( (aref box-y-size ch) -1)
		 (setq char-width (aref xwidths ch))
		 (setq raster-width (aref box-x-size ch))
		 (setq raster-height (aref box-y-size ch))
		 (setq char-y-offset (aref box-y-offset ch))
		 (setq cd (make-char-descriptor :length (list line-height raster-width)
						#+fixed #+fixed :element-type 'bit
						#-fixed #-fixed :type 'sys:art-1b))
		 (setf (cd-char-width cd) (floor char-width))
		 (setf (cd-char-vert-width cd) (floor (aref ywidths ch)))
		 (and (= ch (char-code #\Sp)) (setf (fd-space-width fd) (floor char-width)))
		 (setf (cd-char-left-kern cd) (- (aref box-x-offset ch)))
		 ;; Store the CD in the font descriptor
		 (setf (aref fd ch) cd)
		 ;; Verify that the relative pointer to this character's data was right.
		 (or (= (aref char-data-position ch)
			(funcall input-file ':read-pointer))
		     (error nil "Inconsistent character data pointer for character ~C" ch))
		 ;; Skip a word of redundant info on raster height and width.
		 (let ((tem (next-word)))
		   (or (= tem (dpb (ceiling raster-height #o20) (byte 6. 10.) raster-width))
		       (error nil
	"Inconsistent raster size data at front of character bits for character ~C"
			       ch)))
		 ;; Raster lines go vertically up, leftmost line first.
		 (dotimes (hpos raster-width)
		   ;; Read in the next vertical scan line.
		   (dotimes (vpos raster-height)
		     ;; If wd is exhausted, get next word into wd
		     (cond ((zerop (rem vpos 16.))
			    (setq wd (next-word))))
		     (setq tem (ldb (byte 1. 15.) (lsh wd (rem vpos 16.))))
		     (or ( (+ vpos baseline char-y-offset) line-height)
			 (setf (aref cd (- line-height 1 (+ vpos baseline char-y-offset)) hpos) tem)))))))
	;; Set width of blinker and space fields from the space character.
	(setf (fd-blinker-width fd) (fd-space-width fd))
	(or (= (funcall input-file ':read-pointer)
	       (+ (nth 6 segment) (nth 7 segment)))
	    (error nil "Inconsistent data-length in index of AC file"))
	fd))))

;;; This returns in array units, which are from the upper-left corner
(defun cd-raster-range (cd)
  (declare (values minx miny maxx maxy))
  (loop with height = (cd-raster-height cd)
	and width = (cd-raster-width cd)
	with minx = width and miny = height
	and maxx = 0 and maxy = 0
	for x from 0 below width
	do (loop for y from 0 below height
		 when (not (zerop (aref cd y x)))
		 do (setq minx (min minx x)
			  maxx (max maxx (1+ x))
			  miny (min miny y)
			  maxy (max maxy (1+ y))))
	finally (return (values (min minx maxx) (min miny maxy) maxx maxy))))

;Return how many rasters are empty (all 0)
;at the bottom of the character and at the top.
(defun cd-unused-raster-height (cd)
  (declare (values bottom top))
  (let* ((dims (array-dimensions cd))
	 bottom top
	 (height (car dims))
	 (width (cadr dims)))
    (dotimes (i height)
      (and (dotimes (j width)
	     (and (not (zerop (aref cd i j)))
		  (return t)))
	   (return (setq top i))))
    (dotimes (i height)
      (and (dotimes (j width)
	     (and (not (zerop (aref cd (- height i 1) j)))
		  (return t)))
	   (return (setq bottom i))))
    (cond (top (values bottom top))
	  ;; Handle case where all data is empty.
	  (t (values height 0)))))

;Write an AC file from a Lisp machine font.
(defun write-font-into-ac (fontname &optional filename)
  (multiple-value-setq (fontname filename)
    (get-output-filename-and-fontname fontname filename ':ac))
  (let ((fd (font-name-font-descriptor fontname)))
    (write-font-descriptor-into-ac fd filename)))

(compiler:function-defined 'press:encode-press-face)
(compiler:function-defined 'press:decode-font-name)

(defun write-font-descriptor-into-ac (fd &optional filename
					 &aux family-name face-code point-size bc ec)
  (setq filename (get-output-filename-from-font-descriptor fd filename ':ac))
  (setf (values family-name face-code point-size)
	(press:decode-font-name (string (fd-name fd))))
  (with-open-file (output-file filename :direction :output :element-type '(cl:unsigned-byte 16.))
    (let* ((font-length (length fd))
	   unused-top-rasters unused-bottom-rasters
	   char-data-size-table (total-data-size 0))

      (and (> font-length #o400)
	   (progn (setq font-length #o400)
		  (zl:fsignal "Font contains codes above #o377 which AC file cannot hold")))

      (setq unused-top-rasters (make-array font-length)
	    unused-bottom-rasters (make-array font-length))

      ;; Figure out range of chars to actually output.
      (dotimes (i font-length)
	(and (aref fd i) (return (setq bc i))))
      (do ((i (1- font-length) (1- i)))
	  ((minusp i))
	(and (aref fd i) (return (setq ec i))))

      ;; Precompute how much data each character is going to require.
      ;; Count number of words of rasters, plus 1 word of info before them.
      (setq char-data-size-table (make-array font-length))
      (dotimes (char-code font-length)
	(let* ((cd (aref fd char-code))
	       (data-size 0))
	  (and cd
	       (multiple-value-bind (tem1 tem2)
		   (cd-unused-raster-height cd)
		 (setf (aref unused-bottom-rasters char-code) tem1)
		 (setf (aref unused-top-rasters char-code) tem2)
		 (setq data-size (1+ (* (ceiling (- (cd-raster-height cd) tem1 tem2) #o20)
					(cd-raster-width cd))))))
	  (setq total-data-size (+ total-data-size data-size))
	  (setf (aref char-data-size-table char-code) data-size)))
      (setq total-data-size (+ total-data-size (* 10. (- ec bc -1))))
      ;; Index entry type 1, 12. words long.
      (funcall output-file ':tyo (dpb 1 (byte 4. 12.) 12.))
      ;; Family code - always 1, since we only write one family.
      (funcall output-file ':tyo 1)
      ;; Write the family name now.
      (do ((i 0 (1+ i))
	   (len (string-length family-name))
	   (high-byte (string-length family-name)))
	  ((= i 19.))
	(let ((ch (if (< i len)
		      (aref family-name i)
		      0)))
	  (if high-byte
	      (progn (funcall output-file ':tyo
			      (dpb high-byte (byte 8. 8.) ch))
		     (setq high-byte nil))
	      (setq high-byte ch))))
      ;; Now write the index entry for the data segment.
      ;; Type 3, 11. words long.
      (funcall output-file ':tyo (dpb 3 (byte 4. 12.) 11.))
      ;; Now family code and face code.
      (funcall output-file ':tyo (dpb 1 (byte 8. 8.) (press:encode-press-face face-code)))
      ;; Now range of characters actually existing in the font.
      (funcall output-file ':tyo (dpb bc (byte 8. 8.) ec))
      ;; Now size of font.
      (funcall output-file ':tyo (floor (+ (* point-size 2540.) 36.) 72.))
      ;; Rotation is 0.
      (funcall output-file ':tyo 0)
      ;; Position in file of start of data (2 words).
      (funcall output-file ':tyo 0)
      (funcall output-file ':tyo 24.)
      ;; Number of words of data.
      (funcall output-file ':tyo (ldb (byte 16. 16.) total-data-size))
      (funcall output-file ':tyo (ldb (byte 16. 0.) total-data-size))
      ;; Resolutions
      (funcall output-file ':tyo (fd-horiz-resolution fd))
      (funcall output-file ':tyo (fd-vert-resolution fd))
      ;; Index entry type 0, end of index.
      (funcall output-file ':tyo 1)
     
      ;; Output descriptions of the characters in the font.
      (do ((char-code bc (1+ char-code)))
	  ((> char-code ec))
	(let ((cd (aref fd char-code)))
	  (cond ((null cd)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo 0)
		 (funcall output-file ':tyo #o177777))
		(t
		 (let ((char-width (cd-char-width cd)))
		   (funcall output-file ':tyo (floor char-width))
		   (funcall output-file ':tyo
			    (floor (* 65536. (- char-width (floor char-width))))))
		 (let ((char-vert-width (or (cd-char-vert-width cd) 0)))
		   (funcall output-file ':tyo (floor char-vert-width))
		   (funcall output-file ':tyo
			    (floor (* 65536. (- char-vert-width (floor char-vert-width))))))
		 (funcall output-file ':tyo (- (cd-char-left-kern cd)))
		 (funcall output-file ':tyo (+ (- (fd-baseline fd)
						  (fd-line-spacing fd))
					       (aref unused-bottom-rasters char-code)))
		 (funcall output-file ':tyo (cadr (array-dimensions cd)))
		 (funcall output-file ':tyo (- (car (array-dimensions cd))
					       (aref unused-bottom-rasters char-code)
					       (aref unused-top-rasters char-code)))))))
      ;; Output offsets to data for each character.
      (let* ((current-pos (+ 24. (* 8 (- ec bc -1))))
	     (expected-data-start
	       (+ current-pos (* 2 (- ec bc -1)))))
	(do ((char-code bc (1+ char-code)))
	    ((> char-code ec))
	  (let ((offset (- expected-data-start current-pos)))
	    (funcall output-file ':tyo (ldb (byte 16. 16.) offset))
	    (funcall output-file ':tyo (ldb (byte 16. 0.) offset)))
	  (setq expected-data-start
		(+ expected-data-start
		   (aref char-data-size-table char-code)))))
      
      ;; Now output the rasters themselves.
      (do ((char-code bc (1+ char-code)))
	  ((> char-code ec))
	(let* (wd
	       (cd (aref fd char-code)))
	  (cond (cd
		 (let* ((raster-width (cd-raster-width cd))
			(raster-bottom-skip (aref unused-bottom-rasters char-code))
			(real-raster-height (cd-raster-height cd))
			(raster-height (- real-raster-height
					  raster-bottom-skip
					  (aref unused-top-rasters char-code))))
		   ;; Output redundant raster size info word.
		   (funcall output-file ':tyo
			    (dpb (ceiling raster-height #o20)
				 (byte 6. 10.)
				 (cd-raster-width cd)))
		   ;; Raster lines go vertically up, leftmost line first.
		   (dotimes (hpos raster-width)
		     (setq wd 0)
		     ;; Write the next vertical scan line.
		     (dotimes (vpos raster-height)
		       (setq wd (+ wd (lsh (aref cd (- real-raster-height
						       1 vpos raster-bottom-skip)
						 hpos)
					   
					   (- #o17 (rem vpos #o20)))))
		       ;; If wd is full, output it.
		       (and (zerop (rem (1+ vpos) 16.))
			    (progn (funcall output-file ':tyo wd)
				   (setq wd 0))))
		     ;; Output partially-filled word at end.
		     (or (zerop (rem raster-height 16.))
			 (funcall output-file ':tyo wd)))))))))
    (funcall output-file ':close)
    (funcall output-file ':truename)))

(defun read-ast-into-font (filename &optional fontname)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':ast))
  (font-name-set-font-and-descriptor fontname
				     (read-ast-into-font-descriptor filename fontname))
  fontname)

(defun read-ast-into-font-descriptor (filename &optional fontname &aux fd)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname ':ast))
  (with-open-file (stream filename)
    (setq fd (make-font-descriptor :fd-name fontname :length 128))
    (read-ast-dn stream)			;DISCARD KSTID
    (setf (fd-line-spacing fd) (read-ast-dn stream))
    (setf (fd-baseline fd) (read-ast-dn stream))
    (read-ast-dn stream)			;COLUMN POSITION ADJUSTMENT
    (setf (fd-space-width fd) 0)		;Just in case no space character.
    (setf (fd-blinker-height fd)
	  (fd-line-spacing fd))
    (setf (fd-name fd) fontname)
    (let (kern char-code raster-width input-raster-width char-width
	  cd ch (line-height (fd-line-spacing fd)))
      (do ()
	  ((null (read-ast-next-page stream)))
	(setq char-code (read-ast-on stream))
	(setq input-raster-width (read-ast-dn stream) raster-width input-raster-width)
	(setq char-width (read-ast-dn stream))
	(setq kern (read-ast-dn stream))
	(cond ((< kern 0)			;FED COMPACT RASTER LOSSAGE
	       (setq raster-width (+ raster-width (abs kern)))
	       (setq kern 0)))
	(setq cd (make-char-descriptor
		   :length (list line-height raster-width)
		   #+fixed #+fixed :element-type 'bit
		   #-fixed #-fixed :type 'sys:art-1b
		   ))
	(setf (cd-char-width cd) char-width)
	(setf (cd-char-left-kern cd) kern)
	(fd-store-cd fd cd char-code)
	(and (= char-code (char-code #\Sp))
	     (setf (fd-space-width fd) char-width))
	(block top
	 (do ((vpos 0 (1+ vpos))) ((= vpos line-height))
	  (do ((hcnt 0 (1+ hcnt)))
	      ((= hcnt input-raster-width)
	       (do ((ch)) ()
		 (cond ((or (null (setq ch (send stream :tyi)))
			    (char-equal ch #\Return))
			(return nil))
		       ((char-equal ch #\Page)
			(funcall stream ':untyi ch)
			(return-from top nil))
		       ((not (char-equal ch #\Space))
			(error nil "non space seen past raster width")))))
	    (setq ch (send stream :tyi))
	    (cond ((null ch)
		   (return-from top nil))
		  ((char-equal ch #\Form)
		   (send stream :untyi ch)
		   (return-from top nil))
		  ((let ((code (char-code ch)))
		     (or (< code #o40) (> code #o200)))
		   (do () ((char-equal ch #\Return)) (setq ch (send stream :tyi)))
		   (return nil))
		  ((not (char-equal ch #\space))
		   (setf (aref cd vpos (+ hcnt (- raster-width input-raster-width))) 1))))))
     ; (COND ((> CHAR-CODE #o37) (TYO CHAR-CODE))
     ;	      (T (PRINC '^) (TYO (+ #o100 CHAR-CODE))))
	)
      ;; Truncate fd to discard unused elements at the end.
      (do ((i (1- (array-total-size fd)) (1- i)))
	  ((or (minusp i)
	       (aref fd i))
	   (adjust-array fd (1+ i))))
      (setf (fd-fill-pointer fd) (array-total-size fd))
      ;; Set width of blinker and space fields from the space character.
      (setf (fd-blinker-width fd)
	    (fd-space-width fd))
      fd)))

(defun read-ast-dn (stream)
  (parse-integer (send stream :line-in) :junk-allowed t))

(defun read-ast-on (stream)
  (parse-integer (send stream :line-in) :radix 8 :sign-allowed nil :junk-allowed t))

(defun read-ast-next-page (stream)
  (prog (ch)
    (cond ((null (setq ch (send stream :tyi))) (return nil))
	  ((char-equal ch #\Form)
	   (setq ch (send stream :tyi))
	   (if (null ch)
	       (return nil)
	     (send stream :untyi ch)
	     (return t)))
	  (t (error nil "Random char where FF expected")))))

(defun write-font-into-ast (fontname &optional filename)
  (multiple-value-setq (fontname filename)
    (get-output-filename-and-fontname fontname filename ':ast))
  (let ((fd (font-name-font-descriptor fontname)))
    (write-font-descriptor-into-ast fd filename)))

(defun write-font-descriptor-into-ast (fd &optional filename
					  &aux (font-length (length fd)))
  (setq filename (get-output-filename-from-font-descriptor fd filename ':ast))
  (with-open-file (stream filename :direction :output)
    (format stream "0 KSTID ~A"  filename)
    (format stream "~%~D HEIGHT" (fd-line-spacing fd))
    (format stream "~%~D BASE LINE" (fd-baseline fd))
    (format stream "~%0 COLUMN POSITION ADJUSTMENT~%")
    ;; Then write out all the characters.
    (let (cd char-height)
      (dotimes (char-code font-length)
	(cond ((and (setq cd (aref fd char-code))
                      ;; Wide fonts without chars-exist-tables can have 0-width chars.
		    (or (not (zerop (cd-raster-width cd)))
			(not (zerop (cd-char-width cd)))))
	       (funcall stream ':tyo #\Form)
	       (format stream "~O CHARACTER CODE ~A" char-code filename)
	       (format stream "~%~D RASTER WIDTH" (cd-raster-width cd))
	       (format stream "~%~D CHARACTER WIDTH" (cd-char-width cd))
	       (format stream "~%~D LEFT KERN~%" (cd-char-left-kern cd))
	       (setq char-height (cd-raster-height cd))
	       (dotimes (vpos char-height)
		 (dotimes (hpos (cd-raster-width cd))
		   (funcall stream ':tyo (if (zerop (aref cd vpos hpos))
					     #\Space
					     #\*)))
		 (funcall stream ':tyo #\Return))))))
    (funcall stream ':close)
    (funcall stream ':truename)))

#-CADR
(deff font-descriptor-into-font 'font-descriptor-into-l-font)

(defun font-descriptor-into-l-font (font-descriptor)
  (let* ((n-chars (fd-fill-pointer font-descriptor))
	 (raster-height (max-raster-height font-descriptor))
	 (raster-width (max-raster-width font-descriptor))
	 (chars-exist-table nil)
	 (char-width-table nil)
	 (indexing-table nil)
	 (left-kern-table nil)
	 (space-width (fd-space-width font-descriptor))
	 (total-width 0)
	 font)
    (loop for ch from 0 below n-chars
	  as cd = (aref font-descriptor ch)
	  when (null cd)
	  do (setq chars-exist-table t)
	  else do (incf total-width (cd-raster-width cd))
		  (or (= (cd-char-width cd) space-width)
		      (setq char-width-table t))
		  (and (not (zerop (cd-char-left-kern cd)))
		       (setq left-kern-table t)))
    ;; The dumper will need to know to convert this to ART-BOOLEAN when ready to use
    ;; the real machine.
    (and chars-exist-table (setq chars-exist-table (make-array n-chars
							       :element-type #+CADR 'art-1b
								      #-CADR 'boolean)))
    (and char-width-table (setq char-width-table (make-array n-chars :initial-element 0)))
    ;; Make an indexing table only if not fixed width.  Is this right?
    (and (or char-width-table chars-exist-table)
	 (setq indexing-table (make-array (1+ n-chars) :element-type '(unsigned-byte 16) :initial-element 0)))
    (and left-kern-table (setq left-kern-table (make-array n-chars :initial-element 0)))
    (and (not indexing-table)
	 (setq total-width (* n-chars raster-width)))
    (setq total-width (* (floor (+ total-width 31.) 32.) 32.))
    (setq font (tv:make-font tv:fill-pointer n-chars
			       tv:name (fd-name font-descriptor)
			       tv:char-height (fd-line-spacing font-descriptor)
			       tv:char-width space-width
			       tv:raster-height raster-height
			       tv:raster-width raster-width
			       tv:baseline (fd-baseline font-descriptor)
			       tv:blinker-width (fd-blinker-width font-descriptor)
			       tv:blinker-height (fd-blinker-height font-descriptor)
			       tv:chars-exist-table chars-exist-table
			       tv:char-width-table char-width-table
			       tv:indexing-table indexing-table
			       tv:left-kern-table left-kern-table
			       :make-array
			       (:type 'art-1b
				      :dimensions
				      (raster-width-and-height-to-make-array-dimensions
					total-width raster-height))))
    (loop for ch from 0 below n-chars
	  with x = 0 and last-ch
	  as cd = (aref font-descriptor ch)
	  when cd
	  do (and chars-exist-table (setf (aref chars-exist-table ch) 1))
	     (and char-width-table (setf (aref char-width-table ch) (cd-char-width cd)))
	     (and left-kern-table (setf (aref left-kern-table ch) (cd-char-left-kern cd)))
	     (let ((cd-raster-width (cd-raster-width cd))
		   (cd-raster-height (cd-raster-height cd)))
	       (loop for cd-col from 0 below cd-raster-width
		     for font-x from x
		     do (loop for cd-row from 0 below cd-raster-height
			      for font-y from 0
			      do (setf (raster-aref font font-x font-y)
				       (aref cd cd-row cd-col))))
	       (if (null indexing-table)
		   (incf x raster-width)
		   (setf (aref indexing-table ch) x)
		   (setq last-ch ch)
		   (incf x cd-raster-width)))
	  else when indexing-table do (setf (aref indexing-table ch) x)
	  finally (when indexing-table
		    (loop for i from (1+ last-ch) to n-chars
			  do (setf (aref indexing-table i) x))))
    font))

;;;; Real machine routines
#-CADR
(progn 'compile

;;; Create an FD format font from an internal format font

(defun font-into-font-descriptor (font)
  (let* ((font-length (font-fill-pointer font))
	 (font-descriptor (make-font-descriptor :length font-length
						:fd-fill-pointer font-length
						:fd-name (font-name font)
						:fd-line-spacing (font-char-height font)
						:fd-baseline (font-baseline font)
						:fd-blinker-height (font-blinker-height font)
						:fd-blinker-width (font-blinker-width font)
						:fd-space-width (font-char-width font))))
    (loop for char-code from 0 below font-length
	  with cet = (font-chars-exist-table font)
	  and cwt = (font-char-width-table font)
	  and lkt = (font-left-kern-table font)
	  and raster-height = (font-raster-height font)
	  with raster-width and character-width and left-kern and cd
	  when (or (null cet) (aref cet char-code))
	  do (setq character-width (if cwt (aref cwt char-code) (font-char-width font))
		   raster-width (font-char-min-raster-width font char-code)
		   left-kern (if lkt (aref lkt char-code) 0))
	     (setq cd (make-char-descriptor
			:length (list raster-height raster-width)
			#+fixed #+fixed :element-type (array-element-type font)
			#-fixed #-fixed :type (sys:array-type font) 
			:cd-char-width character-width :cd-char-left-kern left-kern))
	     (setf (aref font-descriptor char-code) cd)
	     (loop for cd-row from 0 below raster-height
		   for font-y from 0 do
	       (loop for cd-col from 0 below raster-width
		     for font-x from 0 do
		 (setf (aref cd cd-row cd-col)
		       ;; CDs are math[row,column] arrays, FONTs are [X,Y]rasters
		       (font-get-pixel font char-code font-x font-y)))))
    font-descriptor))

(defun font-get-pixel (font char x y)
  (if (or ( char (font-fill-pointer font))
	  (let ((cet (font-chars-exist-table font)))
	    (and (not (null cet)) (null (aref cet char)))))
      (error "The character ~O does not exist in ~S" char font)
      (let ((fit (font-indexing-table font))
	    cx cw)
	(if fit
	    (setq cx (aref fit char)
		  cw (- (aref fit (1+ char)) cx))
	    (setq cw (font-raster-width font)
		  cx (* cw char)))
	(if ( x cw) (error "The column ~O is beyond the width, ~O in ~S" x cw font))
	(raster-aref font (+ cx x) y))))

(defun font-set-pixel (pixel font char x y)
  (if (or ( char (font-fill-pointer font))
	  (let ((cet (font-chars-exist-table font)))
	    (and (not (null cet)) (null (aref cet char)))))
      (error "The character ~O does not exist in ~S" char font)
      (let ((fit (font-indexing-table font))
	    cx cw)
	(if fit
	    (setq cx (aref fit char)
		  cw (- (aref fit (1+ char)) cx))
	    (setq cw (font-raster-width font)
		  cx (* cw char)))
	(if ( x cw) (error "The column ~O is beyond the width, ~O in ~S" x cw font))
	(setf (raster-aref font (+ cx x) y) pixel))))

;;; Store a character in a font.  Given a font and corresponding FD, both are
;;; updated by storing a given CD for a given character code.
;;; If the CD can be stored into the existing font, that is done.
;;; Otherwise, a new font is made from the updated FD and the old font forwarded to it.
(defun font-name-store-cd (fontname cd char-code &aux font)
  (let ((width (cd-raster-width cd))
	(height (cd-raster-height cd))
	(fd (font-name-font-descriptor fontname))
	cx cw)
    (fd-store-cd fd cd char-code)
    (and (= char-code (char-code #\Sp))
	 (setf (fd-space-width fd) (cd-char-width cd)))
    (if (or (not (boundp fontname))
	    (null (setq font (symbol-value fontname)))
	    ( char-code (font-fill-pointer font))
	    (let ((cet (font-chars-exist-table font)))
	      (and (not (null cet)) (null (aref cet char-code))))
	    (> height (font-raster-height font))
	    (> width
	       (let ((fit (font-indexing-table font)))
		 (if fit
		     (setq cx (aref fit char-code)
			   cw (- (aref fit (1+ char-code)) cx))
		     (setq cw (font-raster-width font)
			   cx (* cw char-code)))
		 cw))
	    (and (null (font-char-width-table font))
		 ( (cd-char-width cd) (font-char-width font)))
	    (and (null (font-left-kern-table font))
		 (not (zerop (cd-char-left-kern cd)))))
	;; Changing the font radically, must make a new one
	(font-name-set-font-and-descriptor fontname fd)
	;; The CD's raster may be smaller than the char's raster in the font.
	(loop for cd-row from 0 below (min height (font-raster-height font))
	      for font-y from 0
	      do (loop for cd-col from 0 below (min cw width)
		       for font-x from cx
		       ;;CD's are (row, col), fonts are (x,y) rasters
		       do (setf (raster-aref font font-x font-y) (aref cd cd-row cd-col)))
	      ;;Fill in the part of the font char raster to the right of the cd raster.
	      do (loop with n = (min cw width)
		       for cd-col from n below cw
		       for font-x from (+ cx n)
		       do (setf (raster-aref font font-x font-y) 0)))
	;;Fill in the part of the font char raster below the cd raster.
	(loop for font-y from (min height (font-raster-height font))
	        below (font-raster-height font)
	      do (loop repeat cw
		       as font-x from cx
		       do (setf (raster-aref font font-x font-y) 0)))
	(let ((cwt (font-char-width-table font)))
	  (and cwt (setf (aref cwt char-code) (cd-char-width cd))))
	(let ((lkt (font-left-kern-table font)))
	  (and lkt (setf (aref lkt char-code) (cd-char-left-kern cd))))
	fd)))

;; Read in a KST file and define a font.  Always uses a FD as an intermediary.
(defun read-kst-into-font (filename &optional fontname)
  (multiple-value-setq (filename fontname)
    (get-input-filename-and-fontname filename fontname "KST"))
  (font-name-set-font-and-descriptor
    fontname (read-kst-into-font-descriptor filename fontname))
  fontname)

(defun write-font-into-kst (fontname &optional filename)
  (multiple-value-setq (fontname filename)
    (get-output-filename-and-fontname fontname filename ':kst))
  (write-font-descriptor-into-kst (font-name-font-descriptor fontname) filename))

);#-CADR

;;;; Cross-conversion routines
#+CADR
(progn 'compile

(defun all-loaded-font-symbols ()
  (loop for font being interned-symbols in si:pkg-fonts-package
	when (and (boundp font) (typep (symeval font) 'font))
	collect font))

(defvar *all-fonts-loaded-before* (all-loaded-font-symbols))

(defun load-all-fonts ()
  (let ((dir-pathname (fs:parse-pathname "SYS: FONTS; * QBIN >")))
    (setq dir-pathname (send dir-pathname ':new-type
			 (first (send dir-pathname ':types-for-canonical-type
				      si:*default-binary-file-type*))))
    (loop for (pathname) in (cdr (fs:directory-list dir-pathname ':fast))
	do (setq pathname (send pathname ':new-version ':newest))
	when (not (send pathname ':get ':file-id-package-alist))
	do (load pathname))))

(defun convert-all-fonts ()
  (loop for font being the interned-symbols in si:pkg-fonts-package
	when (and (boundp font)
		  (not (memq font *all-fonts-loaded-before*))
		  (typep (symeval font) 'font))
	do (format t "~&Converting ~A..." font)
	   (format t "~A~%" (convert-font font))))

(defun convert-font (font-name)
  (let* ((font-descriptor (font-name-font-descriptor font-name))
	 (l-font (font-descriptor-into-l-font font-descriptor)))
    (putprop font-name l-font 'l-font)
    (let ((lbin:*boolean-type-arrays* (let ((x (font-chars-exist-table l-font)))
					(and x (ncons x)))))
      (lbin:dump-forms-to-file (fs:make-pathname ':host "SYS" ':directory si:pkg-fonts-package
						 ':name (string font-name))
			       `((setq ,font-name ',l-font))
			       '(:package :fonts)))))
);#+CADR

;;; Hook them into the font editor

(define-font-file-type :ast
  (:documentation "Asterisk based format")
  (:read (file)
   (values nil (read-ast-into-font-descriptor file)))
  (:write (font-symbol ignore file)
   (write-font-into-ast font-symbol file)))

(define-font-file-type :kst
  (:documentation "MIT ITS format")
  (:read (file)
   (values nil (read-kst-into-font-descriptor file)))
  (:write (font-symbol ignore file)
   (write-font-into-kst font-symbol file)))

(define-font-file-type :ac
  (:documentation "A Xerox format")
  (:read (file)
   (values nil (read-ac-into-font-descriptor file)))
  (:write (font-symbol ignore file)
   (write-font-into-ac font-symbol file)))

(define-font-file-type :al
  (:documentation "A Xerox format")
  (:read (file)
   (values nil (read-al-into-font-descriptor file))))
