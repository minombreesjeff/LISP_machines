;;; -*- Mode: LISP; Syntax: Common-lisp; Package: POSTSCRIPT; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(defvar *lexer*)				;Defined by the read table compiler.

;;; Used for interning name identifiers.
(defparameter *name-package* (find-package "postscript-dictionary"))

;;; Return the next token in the input stream.
(defun scan-next-token (stream &optional (lexer *lexer*))
  (labels ((lex-next-char ()
	     (let ((char (read-char stream nil)))
	       (if (null char)
		   (values char (si:rdtbl-eof-code lexer))
		   (values char (si:rdtbl-code lexer (char-code char))))))
	   (skip-whitespace ()
	     (loop
	       (multiple-value-bind (char code)
		   (lex-next-char)
		 (unless (and char (logtest #o1 (si:rdtbl-bits lexer (char-code char))))
		   (return (values char code))))))
	   )
    (loop
      (let ((fsm (si:rdtbl-fsm lexer))
	    (state (si:rdtbl-starting-state lexer)))
	(si:using-token-buffer (string)
	  (multiple-value-bind (char state-code)
	      (skip-whitespace)
	    (loop do
	      (setq state (aref fsm state state-code))
	      (unless (integerp state)
		(return))
	      (si:append-character-to-token string char)
	      (multiple-value-setq (char state-code)
		(lex-next-char)))
	    (when string
	      (si:finish-token string))
	    (let ((indicator (si:rdtbl-read-function-property lexer))
		  (action (rest state)))
	      (ecase (first state)
		(:unread
		  ;; Only unread non-whitespace break.
		  (unless (or (null char)
			      (logtest #o1 (si:rdtbl-bits lexer (char-code char))))
		    (unread-char char stream))
		  (return
		    (funcall (get action indicator) string stream)))
		(:argument
		  (return
		    (funcall (get action indicator) stream char)))
		(:no-return
		  (funcall (get action indicator) stream char))))))))))

(defun (integer scan-token) (token ignore)
  (parse-integer token))

(defun (real scan-token) (token ignore)
  (read-from-string token))

(defun (radix scan-token) (token ignore)
  (let* ((sharp (string-search-char #\# token))
	 (radix (parse-integer token :end sharp :sign-allowed nil)))
    (parse-integer token :start (1+ sharp) :radix radix :sign-allowed nil)))

(defun (name scan-token) (token ignore)
  (intern (string-flipcase token) *name-package*))

(defun (comment scan-token) (stream ignore)
  (loop as char = (read-char stream nil)
	until (or (null char)
		  (char-equal char #\newline))))

(defun (string scan-token) (stream ignore)
  (sys:with-stack-array (string 20 :element-type 'string-char :fill-pointer 0)
    (let ((level 1))
      (loop
	(let ((char (read-char stream nil)))
	  (case char
	    ((nil) (sys:parse-ferror "EOF in the middle of a string"))
	    ((#\()
	     (vector-push-extend char string)
	     (incf level))
	    ((#\))
	     (if (zerop (decf level))
		 (return)
		 (vector-push-extend char string)))
	    ((#\\)
	     (let ((next (read-char stream nil)))
	       (case next
		 ((#\n #\r)
		  (vector-push-extend #\newline string))
		 ((#\t)
		  (vector-push-extend #\tab string))
		 ((#\b)
		  (vector-push-extend #\bs string))
		 ((#\f)
		  (vector-push-extend #\ff string))
		 ((#\\ #\( #\))
		  (vector-push-extend next string))
		 (otherwise
		   (when (digit-char-p next)
		     (let ((n (digit-char-p next)))
		       (loop repeat 2 do
			 (setq next (read-char stream))
			 (let ((m (digit-char-p next)))
			   (if m (setq n (+ (* n 8) m))
			       (unread-char next)
			       (return))))
		       (vector-push-extend (code-char n) string)))))))
	    (otherwise
	      (vector-push-extend char string))))))
    (copy-seq string)))

(defparameter *mark* '(mark))

(defun (mark scan-token) (ignore ignore) *mark*)

(defun (unmark scan-token) (ignore ignore) '(unmark))

(defparameter *eof* '(eof))

(defun (eof scan-token) (ignore ignore) *eof*)

(zl:defstruct (procedure :named-array-leader :conc-name)
  (length 0))

(defparameter *unproc* '(unproc))

(defun (unproc scan-token) (ignore ignore) *unproc*)

(defun (proc scan-token) (stream ignore)
  (sys:with-stack-array (procedure 10 :fill-pointer 0)
    (loop
      (let ((token (scan-next-token stream)))
	(cond ((eq token *eof*)
	       (sys:parse-ferror "EOF in the middle of a procedure body"))
	      ((eq token *unproc*)
	       (return))
	      (t
	       (vector-push-extend token procedure)))))
    (let ((value (make-procedure length (length procedure)
				 :make-array (:length (length procedure)))))
      (replace value procedure)
      value)))

(defun (quote scan-token) (stream ignore)
  (let ((name (scan-next-token stream)))
    `',name))

(defun (hex-string scan-token) (stream ignore)
  (sys:with-stack-array (string 20 :element-type 'string-char :fill-pointer 0)
    (let ((half nil))
      (loop
	(let ((char (read-char stream nil)))
	  (case char
	    ((nil) (sys:parse-ferror "EOF in the middle of a string."))
	    ((#\>) (return))
	    ((#\space #\newline #\tab))
	    (otherwise
	      (let ((n (digit-char-p char 16)))
		(unless n
		  (sys:parse-ferror "~C is not a valid hexidecimal digit" char))
		(if (null half)
		    (setq half (* n 16))
		  (vector-push-extend (code-char (+ half n)) string)
		  (setq half nil))))))))
    (copy-seq string)))

;;;; Dictionaries

(defvar *system-dictionary* (make-hash-table))
(defvar *error-dictionary* (make-hash-table))

(defvar *standard-font-charstyle-mappings* (make-hash-table))

(defun add-font-mappings (mappings)
  (loop for (name family face) in mappings
	do (setf (gethash (intern (string-flipcase name) *name-package*)
			  *standard-font-charstyle-mappings*)
		 (si:intern-character-style family face nil))))

;;; Array indexed by string-char char-code.
;;; Values are name identifiers of the "drawing routines", i.e. the standard names.
(defvar *standard-encoding* (make-array 256 :initial-element '*:\.notdef))

;;; Inverse of above.  Keys are names, values are characters.  This should include the
;;; non-standard ones too, i.e. the symbol font should be implemented as an alternate
;;; character set.
(defvar *character-name-decoding* (make-hash-table))

(defun add-standard-encoding (inits)
  (flet ((add-encoding (char code name)
	   (setf (aref *standard-encoding* code) name)
	   (setf (gethash name *character-name-decoding*) char)))
    (loop for code from #o40 to #o177 do
      (let ((char (code-char code)))
	(add-encoding char code
		      (intern (string (char-flipcase char)) *name-package*))))
    (dolist (init inits)
      (destructuring-bind (char name &optional (code (char-code char))) init
	(add-encoding char code name)))))

(defun dictionary-initialize ()
  (setf (gethash '*:systemdict *system-dictionary*) *system-dictionary*)
  (setf (gethash '*:errordict *system-dictionary*) *error-dictionary*)
  ;; This is really Adobe specific, but since so many programs like to change things
  ;; in here, may as well give them a bitbucket.
  (setf (gethash '*:statusdict *system-dictionary*) (make-hash-table))
  (setf (gethash '*:null *system-dictionary*) nil)
  (setf (gethash '*:false *system-dictionary*) nil)
  (setf (gethash '*:true *system-dictionary*) t)

  (add-font-mappings '(("Helvetica" :swiss :roman)
		       ("Helvetica-Oblique" :swiss :italic)
		       ("Helvetica-Bold" :swiss :bold)
		       ("Helvetica-BoldOblique" :swiss :bold-italic)
		       ("Times-Roman" :dutch :roman)
		       ("Times-Italic" :dutch :italic)
		       ("Times-Bold" :dutch :bold)
		       ("Times-BoldItalic" :dutch :bold-italic)
		       ("Courier" :fix :roman)
		       ("Courier-Oblique" :fix :italic)
		       ("Courier-Bold" :fix :bold)
		       ("Courier-BoldOblique" :fix :bold-italic)
		       ;+++
		       ("Symbol" :fix :roman)
		       ))

  (add-standard-encoding nil)			;+++ Should have all the names.
  (setf (gethash '*:|sTANDARDeNCODING| *system-dictionary*) *standard-encoding*)
  )

(add-initialization "Setup system dictionaries" '(dictionary-initialize) '(:once))

(defstruct (built-in-operator (:constructor make-built-in-operator (name arguments)))
  name
  arguments)

(defstruct (path :named-array-leader (:make-array (:length 100)))
  (length 0))

(import '(dw::fintern))

(defmacro define-graphics-state (&body vars)
  `(progn
     (defflavor graphics-state
	     (interpreter-state . ,vars)
	     (graphics:basic-pattern)
       :initable-instance-variables
       :writable-instance-variables
       (:constructor make-graphics-state (interpreter-state)))
     . ,(loop for var in vars
	      when (consp var) do (setq var (first var))
	      collect `(progn
			 (defmethod (,(fintern "INTERPRETER-STATE-~A" var) interpreter-state)
				    ()
			   (,(fintern "GRAPHICS-STATE-~A" var) graphics-state))
			 (defmethod ((setf ,(fintern "INTERPRETER-STATE-~A" var))
				     interpreter-state)
				    (new-val)
			   (setf (,(fintern "GRAPHICS-STATE-~A" var) graphics-state)
				 new-val))))))

(defun copy-graphics-state (to from)
  (let ((fl (sys:%instance-flavor to)))
    (assert (eq fl (sys:%instance-flavor from)))
    (flavor::%block-copy-allow-null from to (flavor::flavor-instance-size fl)))
  to)

(defflavor interpreter-state
	((operand-stack (make-array 100 :fill-pointer 0))
	 (dictionary-stack (make-array 20 :fill-pointer 0))
	 (graphics-state-stack (make-array 32 :fill-pointer 0))
	 (font-directory (make-hash-table))
	 (proc-level 0)
	 graphics-state
	 user-transform-matrix
	 (input-stream *standard-input*)
	 (standard-input *standard-input*)
	 (standard-output *standard-output*)
	 (page-incomplete nil)
	 (page-ready nil)
	 (window-output-p nil)
	 )
	()
  :initable-instance-variables
  (:init-keywords :output-stream :graphics-transform)
  :writable-instance-variables)

(define-graphics-state
  (transform-matrix (graphics::make-graphics-transform))
  (color 0)
  (screen-frequency nil) (screen-angle nil) (screen-procedure nil) (special-gray-pattern nil)
  (x-position nil) (y-position nil)
  (path ())
  (clipping-paths ())
  (font nil)
  (line-width 1)
  (line-end-shape :butt)
  (line-joint-shape :miter)
  (transfer-procedure (make-procedure))		;{} is identity function.
  (flatness 0)	 
  (line-miter-limit 10)
  (line-dash-pattern #())
  (line-dash-offset 0)
  (output-stream *standard-output*))

(defmethod (init-graphics graphics-state) ()
  (replace transform-matrix (interpreter-state-user-transform-matrix interpreter-state))
  (setq path nil
	x-position nil y-position nil
	path nil clipping-paths nil
	color 0 special-gray-pattern nil screen-procedure nil
	line-width 1
	line-end-shape :butt line-joint-shape :miter line-miter-limit 10
	line-dash-pattern #() line-dash-offset 0))

(defmethod (graphics:stream-transform interpreter-state) ()
  (funcall (flavor:generic graphics:stream-transform) graphics-state))

(defmethod (graphics::with-new-stream-transform interpreter-state) (&rest args)
  (apply (flavor:generic graphics::with-new-stream-transform) graphics-state args))

(defmethod (graphics:stream-transform graphics-state) () transform-matrix)

(defmethod (graphics::with-new-stream-transform graphics-state)
	   (transform continuation xstream)
  (letf ((transform-matrix transform))
    (funcall continuation xstream)))

(defmethod (make-instance interpreter-state)
	   (&key (output-stream *standard-output*)
		 (graphics-transform (graphics:stream-transform output-stream) gt-p)
		 (window-output-p nil)
	    &allow-other-keys)
  (setq graphics-state (make-graphics-state self))
  (setf (graphics-state-output-stream graphics-state) output-stream)
  (when (and window-output-p (not gt-p))
    (setq graphics-transform (page-scaled-window-graphics-transform output-stream)))
  (setq user-transform-matrix graphics-transform)
  (setf (aref dictionary-stack 0) *system-dictionary*)
  (let ((user-dictionary (make-hash-table)))
    (setf (aref dictionary-stack 1) user-dictionary)
    (setf (gethash '*:userdict user-dictionary) user-dictionary)
    (setf (gethash '*:|fONTdIRECTORY| user-dictionary) font-directory))
  (setf (fill-pointer dictionary-stack) 2)
  (init-graphics graphics-state))

(defmethod (interpreter-top-level interpreter-state) ()
  (catch 'quit
    (execute-file self input-stream)))

(defmethod (execute-file interpreter-state) (file)
  (catch 'stop
    (loop
      (let ((token (scan-next-token file)))
	(execute-token self token)))))

(defmethod (operand-stack-push interpreter-state) (object)
  (vector-push-extend object operand-stack))

(defmethod (operand-stack-pop interpreter-state) ()
  (let ((tem (vector-pop operand-stack 'bos)))
    (if (eq tem 'bos)
	(signal-error self '*:stackunderflow)
	tem)))

(defmethod (operand-stack-push-sequence interpreter-state) (sequence)
  (vector-push-portion-extend operand-stack sequence))

(defmethod (operand-stack-pop-sequence interpreter-state) (into-sequence)
  (let ((length (length into-sequence)))
    (replace into-sequence operand-stack :start2 (- (fill-pointer operand-stack) length))
    (decf (fill-pointer operand-stack) length)))

(defmethod (save-graphics-state interpreter-state) ()
  (let ((new (make-graphics-state self)))
    (copy-graphics-state new graphics-state)
    (setf (graphics-state-transform-matrix new)
	  (copy-seq (graphics-state-transform-matrix new)))
    (vector-push-extend new graphics-state-stack)
    new))

(defmethod (restore-graphics-state interpreter-state) (all)
  (when (plusp (fill-pointer graphics-state-stack))
    (let ((old (if all
		   (prog1 (aref graphics-state-stack 0)
			  (setf (fill-pointer graphics-state-stack) 0))
		   (vector-pop graphics-state-stack))))
      (copy-graphics-state graphics-state old))))

(defvar *trace-p* nil)

(defmethod (execute-token interpreter-state) (token)
  (when *trace-p*
    (fresh-line *trace-output*)
    (print-typed-object token *trace-output*)
    (format *trace-output* "~& Stack: ")
    (format-textual-list (interpreter-state-operand-stack self) #'print-typed-object
			 :stream *trace-output*))
  (typecase token
    ((and symbol (not boolean))
     (let ((value (lookup-name self token)))
       (typecase value
	 ((procedure)
	  (execute-procedure self value))
	 ((built-in-operator)
	  (execute-built-in-operator self value))
	 (otherwise
	  (operand-stack-push self value)))))
    (cons
      (ecase (first token)
	(quote (operand-stack-push self (second token)))
	(eof (throw 'stop nil))
	(mark (operand-stack-push self *mark*))
	(unmark
	  (let* ((index (or (position *mark* operand-stack :from-end t)
			    (signal-error self '*:unmatchedmark)))
		 (array (subseq operand-stack (1+ index))))
	    (setf (fill-pointer operand-stack) index)
	    (operand-stack-push self array)))))
    (built-in-operator
      (execute-built-in-operator self token))
    (otherwise
      (operand-stack-push self token))))

(defmethod (execute-procedure interpreter-state) (procedure &rest args)
  (dolist (arg args)
    (operand-stack-push self arg))
  (letf ((proc-level (1+ proc-level)))
    (loop for token being the array-elements of procedure do
      (execute-token self token))))

(defmethod (lookup-name interpreter-state) (name &key (if-does-not-exist :error))
  (declare (values value found-p))
  (loop for dict being the array-elements of dictionary-stack
	    downfrom (1- (fill-pointer dictionary-stack)) to 0
	do
    (let ((value (gethash name dict 'undefined)))
      (unless (eq value 'undefined)
	(return-from lookup-name (values value t)))))
  (case if-does-not-exist
    (:error (signal-error self '*:undefined name))))

(defmethod (define-name interpreter-state) (name value &key (if-exists nil))
  (when if-exists
    (loop for dict being the array-elements of dictionary-stack
	      downfrom (1- (fill-pointer dictionary-stack)) to 0
	  do
      (let ((value (gethash name dict 'undefined)))
	(unless (eq value 'undefined)
	  (return-from define-name (setf (gethash name dict) value))))))
  (setf (gethash name (aref dictionary-stack (1- (fill-pointer dictionary-stack)))) value))

(defmethod (set-color interpreter-state) (color)
  (when (numberp color)
    (execute-procedure self (graphics-state-transfer-procedure graphics-state) color)
    (setq color (operand-stack-pop self)))
  (setf (graphics-state-color graphics-state) color)
  (let ((screen-proc (graphics-state-screen-procedure graphics-state)))
    (if (null screen-proc)
	(setf (graphics-state-special-gray-pattern graphics-state) nil)
	(let ((special-gray (graphics-state-special-gray-pattern graphics-state)))
	  (let ((size (special-gray-pattern-size graphics-state user-transform-matrix)))
	    (unless (and special-gray (= size (graphics:stipple-array-x-phase special-gray)))
	      (setq special-gray (graphics:make-stipple-array
				   :dimensions (list size (lcm size 32))
				   :type 'sys:art-1b
				   :x-phase size))))
	  (let ((gray (if (numberp color) color
			  (/ (expt (color:color-intensity color) 2) 3))))
	    (when (eql (graphics:stipple-array-gray-level special-gray) gray)
	      (return-from set-color nil))
	    (fill-special-gray-pattern graphics-state special-gray gray self)
	    (setf (graphics:stipple-array-gray-level special-gray) gray))
	  (rotate-special-gray-pattern graphics-state special-gray)
	  (multiple-value-bind (width size) (decode-raster-array special-gray)
	    (loop for x from size below width by size do
	      (bitblt tv:alu-seta size size special-gray 0 0 special-gray x 0)))
	  (setf (graphics-state-special-gray-pattern graphics-state) special-gray)))))

(defmethod (special-gray-pattern-size graphics-state) (matrix)
  ;; screen-frequency is cells per device inch.
  ;; get units per cell and transform to pixels per cell.
  (let ((pixels-per-cell (graphics:transform-distance (/ 72.0 screen-frequency) 0 matrix)))
    (max 1 (round pixels-per-cell))))

(defmethod (fill-special-gray-pattern graphics-state) (stipple level interpreter)
  (let ((size (graphics:stipple-array-x-phase stipple)))
    (bitblt tv:alu-setz size size stipple 0 0 stipple 0 0)
    (stack-let ((indices (make-array (* size size 3))))
      (let ((index 0))
	(loop for y from 0 below size do
	  (loop for x from 0 below size do
	    (flet ((convert-n (index) (1- (/ (* index 2.0) size))))
	      (execute-procedure interpreter screen-procedure (convert-n x) (convert-n y)))
	    (setf (aref indices index) (operand-stack-pop interpreter))
	    (setf (aref indices (1+ index)) x)
	    (setf (aref indices (+ index 2)) y)
	    (incf index 3))))
      (sort-grouped-array indices 3 #'>)
      (loop repeat (floor (* size size (- 1 level)))
	    for index from 0 by 3 do
	(setf (raster-aref stipple (aref indices (1+ index)) (aref indices (+ index 2))) 1)))))

(defmethod (rotate-special-gray-pattern graphics-state) (stipple)
  (let ((rotation (* 90 (round (mod screen-angle 360) 90)))
	(size (graphics:stipple-array-x-phase stipple)))
    (unless (zerop rotation)
      (let ((stipple stipple))
	(declare (sys:array-register-1d stipple))
	(multiple-value-bind (nil nil span)
	    (decode-raster-array stipple)
	  (let ((size/2 (floor size 2)))
	    (loop repeat size/2
		  for +y from (- size size/2)
		  for -y downfrom (1- size/2)
		  do
	      (loop repeat size/2
		    for +x from (- size size/2)
		    for -x downfrom (1- size/2)
		    do
		(ecase rotation
		  (90
		    (rotatef (sys:%1d-aref stipple (+ +x (* +y span)))
			     (sys:%1d-aref stipple (+ -y (* +x span)))
			     (sys:%1d-aref stipple (+ -x (* -y span)))
			     (sys:%1d-aref stipple (+ +y (* -x span)))))
		  (180
		    (rotatef (sys:%1d-aref stipple (+ +x (* +y span)))
			     (sys:%1d-aref stipple (+ -x (* -y span)))))
		  (270
		    (rotatef (sys:%1d-aref stipple (+ +x (* +y span)))
			     (sys:%1d-aref stipple (+ +y (* -x span)))
			     (sys:%1d-aref stipple (+ -x (* -y span)))
			     (sys:%1d-aref stipple (+ -y (* +x span))))))))))))))

(defmethod (graphics:pattern-call-with-drawing-parameters graphics-state)
	   (function &rest ignore)
  (cond (special-gray-pattern
	 (funcall function :stipple special-gray-pattern))
	((not (numberp color))
	 (funcall function :color color))
	(t
	 (funcall function :gray-level (- 1 color)))))


(defmethod (execute-built-in-operator interpreter-state) (built-in)
  (execute-argument-template self
			     (built-in-operator-name built-in)
			     (built-in-operator-arguments built-in)))

(defmethod (execute-argument-template interpreter-state) (function template)
  (sys:with-stack-array (args (length template) :fill-pointer 0 :type 'sys:art-q-list)
    (loop while template do
      (let ((type (pop template))
	    (object (operand-stack-pop self)))
	(if (typep object type)
	    (vector-push-extend object args)
	    (signal-error self '*:typecheck object type))))
    (nreverse args)
    (multiple-value-call #'(lambda (&rest args)
			     (dolist (arg args)
			       (operand-stack-push self arg)))
			 (apply function self (g-l-p args)))))

(defun install-built-in-operator (name arguments)
  (check-type name (and symbol
			(satisfies (lambda (sym) (eq (symbol-package sym) *name-package*)))))
  (let ((operator (make-built-in-operator name arguments)))
    (setf (gethash name *system-dictionary*) operator)
    operator))

(defun construct-argument-template (arguments)
  (values (loop for arg in arguments
		collect (if (atom arg) arg (car arg)))
	  ;; Note that the template is reversed from the arglist, so that
	  ;; you can pop things off as you match.
	  (let ((template nil))
	    (dolist (arg arguments)
	      (let ((type (if (atom arg) 't (second arg))))
		(push type template)))
	    template)))

(defmacro define-operator (name values arguments &body body &environment env)
  (multiple-value-bind (arglist argument-template)
      (construct-argument-template arguments)
    (multiple-value-bind (declarations nil body documentation)
	(si:parse-body-declarations body env arglist)
      `(progn
	 (defun ,name (self . ,arglist)
	   ,@(and documentation (list documentation))
	   (declare (sys:function-parent ,name define-operator))
	   ,@(and declarations `((declare ,@declarations)))
	   (ignore self)
	   ,(ecase values
	      (:no-value `(progn ,@body (values)))
	      (:one-value `(values (progn . ,body)))
	      (:multiple-values `(progn . ,body))))
	 (install-built-in-operator ',name ',argument-template))))) 

(defprop define-operator defun zwei:definition-function-spec-type)

(defmacro define-unary-arithmetic-operator (name
					    &optional (function (intern (symbol-name name))))
  `(define-operator ,name :one-value (x)
     (declare (sys:function-parent ,name define-operator))
     (,function x)))

(defprop define-unary-arithmetic-operator defun zwei:definition-function-spec-type)

(defmacro define-binary-arithmetic-operator (name
					     &optional (function (intern (symbol-name name))))
  `(define-operator ,name :one-value (x y)
     (declare (sys:function-parent ,name define-binary-arithmetic-operator))
     (,function x y)))

(defprop define-binary-arithmetic-operator defun zwei:definition-function-spec-type)

(defmacro define-comparison-operator (name number-function string-function)
  `(define-operator ,name :one-value (x y)
     (declare (sys:function-parent ,name define-comparison-operator))
     (if (stringp x)
	 (,string-function x y)
	 (,number-function x y))))

(defprop define-comparison-operator defun zwei:definition-function-spec-type)

(defmacro define-boolean-or-bit-unary-operator (name integer-function)
  `(define-operator ,name :one-value (x)
     (declare (sys:function-parent ,name define-boolean-or-bit-unary-operator))
     (if (integerp x)
	 (,integer-function x)
	 (,(intern (symbol-name name)) x))))

(defprop define-boolean-or-bit-unary-operator defun zwei:definition-function-spec-type)

(defmacro define-boolean-or-bit-binary-operator (name integer-function)
  `(define-operator ,name :one-value (x y)
     (declare (sys:function-parent ,name define-boolean-or-bit-binary-operator))
     (if (integerp x)
	 (,integer-function x y)
	 (,(intern (symbol-name name)) x y))))

(defprop define-boolean-or-bit-binary-operator defun zwei:definition-function-spec-type)

(defmacro define-path-operator (name values arguments &body body)
  `(define-operator ,name ,values ,arguments
     (declare (sys:function-parent ,name define-path-operator))
     . ,body))

(defprop define-path-operator defun zwei:definition-function-spec-type)

(defun print-typed-atomic-object (object stream)
  (typecase object
    (number (write object :stream stream))
    (boolean (write-string (if object "true" "false") stream))
    (symbol (write-string (string-flipcase (symbol-name object)) stream))
    (string (write-string object stream))
    (otherwise (write-string "--nostringval--" stream))))

(defun print-typed-object (object stream)
  (typecase object
    ((or number symbol)
     (print-typed-atomic-object object stream))
    (string
      (write-char #\( stream)
      (loop for char being the array-elements of object
	    do (cond ((char-equal char #\return)
		      (write-string "\n" stream))
		     ((char-equal char #\tab)
		      (write-string "\t" stream))
		     ((char-equal char #\bs)
		      (write-string "\b" stream))
		     ((string-search-char char "()\\")
		      (write-char #\\ stream)
		      (write-char char stream))
		     (( (char-code char) 128)
		      (format stream "\\~D" (char-code char) ))
		     (t
		      (write-char char stream))))
      (write-char #\) stream))
    (procedure
      (write-char #\{ stream)
      (format-textual-list object #'print-typed-object :separator " " :filled t
			   :stream stream)
      (write-char #\} stream))
    (vector
      (write-char #\[ stream)
      (format-textual-list object #'print-typed-object :separator " " :filled t
			   :stream stream)
      (write-char #\] stream))
    (cons
      (case (first object)
	(mark (write-string "-marktype-" stream))
	(quote
	  (write-char #\/ stream)
	  (print-typed-atomic-object (second object) stream))
	(otherwise
	  (write object :stream stream))))
    (hash-table
      (write-string "-dicttype-" stream))
    (built-in-operator
      (format stream "--~(~A~)--" (built-in-operator-name object)))
    (otherwise
     (write object :stream stream))))

(defflavor postscript-error
	(error arguments interpreter)
	(error)
  :initable-instance-variables)

(defmethod (dbg:report postscript-error) (stream)
  (format stream "Interpreter error: ")
  (print-typed-atomic-object error stream)
  (when arguments
    (format stream "~&Args: ")
    (format-textual-list arguments #'print-typed-object :stream stream))
  (when (plusp (length (interpreter-state-operand-stack interpreter)))
    (format stream "~&Stack: ")
    (format-textual-list (interpreter-state-operand-stack interpreter)
			 #'print-typed-object :stream stream))
  )

(defmethod (signal-error interpreter-state) (error &rest arguments)
  (let ((proc (gethash error *error-dictionary*)))
    (if proc
	(execute-procedure proc)
	(error 'postscript-error :error error :arguments (copy-list arguments)
				 :interpreter self)))
  (throw 'stop t))

(defmacro with-window-transform ((window) &body body)
  `(graphics:with-graphics-transform (,window
				      (list 1 0 0 -1 0
					    (multiple-value-bind (nil nil nil bottom)
						(send ,window :visible-cursorpos-limits)
					      bottom)))
     . ,body))

(defmacro-in-flavor (with-clipped-output-stream interpreter-state) ((var) &body body)
  `(with-clipped-output-stream-internal
     (dw::named-continuation with-clipped-output-stream (,var) . ,body)))

(defun-in-flavor (with-clipped-output-stream-internal interpreter-state) (continuation)
  (let ((output-stream (graphics-state-output-stream graphics-state))
	(clipping-paths (graphics-state-clipping-paths graphics-state)))
    (if window-output-p
	(with-window-transform (output-stream)
	  (with-clipped-output-stream-internal-1 continuation output-stream clipping-paths))
	(with-clipped-output-stream-internal-1 continuation output-stream clipping-paths))))

(defun with-clipped-output-stream-internal-1 (continuation xstream clipping-paths)
  (if (null clipping-paths)
      (funcall continuation xstream)
      (destructuring-bind (type path) (pop clipping-paths)
	(ecase type
	  ((:non-zero :odd-even)
	   (graphics:with-clipping-path (xstream
					  #'(lambda (stream) (trace-path path stream))
					  :winding-rule type)
	     (with-clipped-output-stream-internal-1 continuation xstream clipping-paths)))
	  ))))

(defun-in-flavor (check-window-page-status interpreter-state) ()
  (when page-incomplete
    (format *query-io* "~&Type a space to see next page: ")
    (read-char *query-io*)
    (setq page-incomplete nil))
  (unless page-ready
    (let ((output-stream (graphics-state-output-stream graphics-state)))
      (send output-stream :clear-window)
      (with-window-transform (output-stream)
	(graphics:with-graphics-transform (output-stream user-transform-matrix)
	  (graphics:draw-rectangle 0 11 8.5 0 :filled nil :scale-thickness nil
					      :thickness 2 :scale 72
					      :stream output-stream)))
      (multiple-value-bind (left nil nil bottom)
	  (send output-stream :visible-cursorpos-limits)
	(send output-stream :set-cursorpos left (- bottom
						   (* (send output-stream :line-height) 2))))
      (setq page-ready t))))

;;; Come up with a nicely centered transform matrix that has the same shape as a piece
;;; of paper and a scale of 72 units per inch.
(defun page-scaled-window-graphics-transform (window)
  (multiple-value-bind (width height)
      (send window :inside-size)
    (let ((scale (/ (min (/ (- width 100) 8.5) (/ (- height 100) 11.0)) 72.0)))
      (list scale 0 0 scale
	    (/ (- width (* scale 8.5 72.0)) 2)
	    (/ (- height (* scale 11 72.0)) 2)))))

(defmethod (draw-current-path interpreter-state) (&rest args
						  &key (filled t)
						  &allow-other-keys)
  (when window-output-p
    (check-window-page-status))
  (flet ((do-it (output-stream &rest args)
	   (apply #'graphics:draw-path
		  #'(lambda (stream)
		      (trace-path (graphics-state-path graphics-state) stream))
		  :pattern graphics-state :opaque t
		  :stream output-stream
		  args)))
    (with-clipped-output-stream (output-stream)
      (if filled
	  (apply #'do-it output-stream args)
	  ;; Cannot easily use :scale-thickness and :scale-dashes, since the scale given
	  ;; to the output stream isn't the same as ours.
	  (let* ((scale (let ((matrix (graphics-state-transform-matrix graphics-state)))
			  (max (abs (graphics:transform-distance 1 0 matrix))
			       (abs (graphics:transform-distance 0 1 matrix)))))
		 (thickness (* scale (graphics-state-line-width graphics-state)))
		 (ndashes (length (graphics-state-line-dash-pattern graphics-state)))
		 (dash-pattern nil))
	    (when (plusp ndashes)
	      (setq dash-pattern (make-array
				   ndashes
				   :initial-contents (graphics-state-line-dash-pattern
						       graphics-state)))
	      (dotimes (i ndashes)
		(setf (aref dash-pattern i) (* scale (aref dash-pattern i)))))
	    (apply #'do-it output-stream
		   :thickness thickness :scale-thickness nil
		   :dashed (plusp ndashes) :scale-dashes nil
		   :dash-pattern dash-pattern
		   :initial-dash-phase (graphics-state-line-dash-offset graphics-state)
		   :line-end-shape (graphics-state-line-end-shape graphics-state)
		   :line-joint-shape (graphics-state-line-joint-shape graphics-state)
		   args)))))
  (setf (graphics-state-path graphics-state) nil))

(defmethod (current-path-bounding-box interpreter-state) ()
  (unless (graphics-state-path graphics-state)
    (signal-error self '*:nocurrentpoint))
  (multiple-value-bind (right bottom nil nil left top)
      (dw:continuation-output-size
	#'(lambda (stream)
	    (trace-path (graphics-state-path graphics-state) stream))
	(graphics-state-output-stream graphics-state))
    (multiple-value-setq (left top)
      (graphics:stream-untransform-point left top self))
    (multiple-value-setq (right bottom)
      (graphics:stream-untransform-point right bottom self))
    (values left top right bottom)))

(defmethod (current-position interpreter-state) ()
  (current-position graphics-state))

(defmethod (add-to-path interpreter-state) (&rest args)
  (apply #'add-to-path graphics-state args))

(defmethod (add-arc-to-path interpreter-state) (&rest args)
  (apply #'add-arc-to-path graphics-state args))

(defmethod (add-arc-to-to-path interpreter-state) (&rest args)
  (apply #'add-arc-to-to-path graphics-state args))

(defmethod (close-path interpreter-state) ()
  (close-path graphics-state))

(defmethod (start-new-subpath interpreter-state) (x y)
  (start-new-subpath graphics-state x y))

(defmethod (current-position graphics-state) ()
  (graphics:untransform-point x-position y-position transform-matrix))

(defmethod (add-to-path graphics-state) (type final-x final-y &rest other-points)
  (let ((subpath (first path)))
    (unless (and subpath x-position)
      (signal-error interpreter-state '*:nocurrentpoint))
    (multiple-value-setq (final-x final-y)
      (graphics:transform-point final-x final-y transform-matrix))
    (vector-push-extend type subpath)
    (vector-push-extend final-x subpath)
    (vector-push-extend final-y subpath)
    (loop for (x y) on other-points by 'cddr
	  do
      (multiple-value-setq (x y)
	(graphics:transform-point x y transform-matrix))
      (vector-push-extend x subpath)
      (vector-push-extend y subpath)))
  (setq x-position final-x
	y-position final-y))

(defmethod (close-path graphics-state) ()
  (let ((subpath (first path)))
    (when (and subpath x-position)
      (setq x-position nil y-position nil)
      (vector-push-portion-extend subpath #(:close nil nil)))))

(defmethod (start-new-subpath graphics-state) (x y)
  (let ((subpath (first path)))
    (if (and subpath (= (fill-pointer subpath) 3))
	(setf (fill-pointer subpath) 0)
	(setq subpath (make-path))
	(push subpath path))
    (multiple-value-setq (x y)
      (graphics:transform-point x y transform-matrix))
    (vector-push-extend :start subpath)
    (vector-push-extend x subpath)
    (vector-push-extend y subpath))
  (setq x-position x
	y-position y))

(defmethod (add-arc-to-path graphics-state) (center-x center-y radius start-theta end-theta
					     &key clockwise)
  (let ((subpath (first path)))
    (unless (and subpath x-position)
      (let ((initial-x (+ center-x (* radius (cos start-theta))))
	    (initial-y (+ center-y (* radius (sin start-theta)))))
	(start-new-subpath self initial-x initial-y)
	(setq subpath (first path))))
    (vector-push-extend :arc subpath)
    (multiple-value-bind (final-x final-y)
	(graphics:transform-point (+ center-x (* radius (cos end-theta)))
				  (+ center-y (* radius (sin end-theta)))
				  transform-matrix)
      (vector-push-extend final-x subpath)
      (vector-push-extend final-y subpath)
      (setq x-position final-x
	    y-position final-y))
    (multiple-value-setq (center-x center-y)
      (graphics:transform-point center-x center-y transform-matrix))
    (vector-push-extend center-x subpath)
    (vector-push-extend center-y subpath)
    (vector-push-extend (if clockwise (- radius) radius) subpath)
    (multiple-value-bind (rotation scale-x scale-y)
	(graphics:decompose-transform transform-matrix)
      (vector-push-extend rotation subpath)
      (vector-push-extend scale-x subpath)
      (vector-push-extend scale-y subpath)
      (vector-push-extend start-theta subpath)
      (vector-push-extend end-theta subpath))))

(defmethod (add-arc-to-to-path graphics-state) (tangent-intersection-x tangent-intersection-y
						to-x to-y radius)
  (multiple-value-bind (from-x from-y)
      (current-position self)
    (multiple-value-bind (center-x center-y theta-1 theta-2 clockwise
			  tangent-point-x1 tangent-point-y1
			  tangent-point-x2 tangent-point-y2)
	(graphics:draw-circular-arc-to-compute-points
	  from-x from-y to-x to-y tangent-intersection-x tangent-intersection-y radius)
      (add-arc-to-path self center-x center-y radius theta-1 theta-2
		       :clockwise clockwise)
      (values tangent-point-x1 tangent-point-y1 tangent-point-x2 tangent-point-y2))))

(defun trace-path (path stream)
  (dolist (subpath path)
    (let* ((index 0)
	   (length (length subpath)))
      (flet ((next-elem () (aref subpath (prog1 index (incf index)))))
	(loop do
	  (when ( index length)
	    (return))
	  (let* ((type (next-elem))
		 (x (next-elem))
		 (y (next-elem)))
	    (ecase type
	      (:start (graphics:set-current-position x y :stream stream))
	      (:substart (graphics:set-current-position x y :stream stream :explicit nil))
	      (:line (graphics:draw-line-to x y :stream stream))
	      (:curve (graphics:draw-bezier-curve-to x y
						     (next-elem) (next-elem)
						     (next-elem) (next-elem)
						     :stream stream))
	      (:arc
		(let* ((center-x (next-elem))
		       (center-y (next-elem))
		       (radius (next-elem))
		       (clockwise (minusp radius))
		       (rotation (next-elem))
		       (scale-x (next-elem))
		       (scale-y (next-elem))
		       (start-theta (next-elem))
		       (end-theta (next-elem)))
		  (graphics:with-graphics-translation (stream center-x center-y)
		    (graphics:with-graphics-rotation (stream rotation)
		      (graphics:with-graphics-scale (stream scale-x scale-y)
			(graphics:draw-circle 0 0 (abs radius)
					      :start-angle start-theta :end-angle end-theta
					      :clockwise clockwise :filled nil
					      :join-to-path t :stream stream))))))
	      (:close (graphics:close-path :stream stream)))))))))

;;; Row-major, big-ender.
(defmethod (read-image-raster interpreter-state) (width height bits/sample proc)
  (let* ((string nil)
	 (string-index 0)
	 (string-length 0))
    (sys:with-bit-reversing
      (graphics:decoding-raster-by-byte-rows ((raster bytes
					       :row-bytes row-bytes :index bindex)
					      (width height bits/sample)
					      :note-progress t :named read-loop)
	  (flet ((next-string-char ()
		   (when ( string-index string-length)
		     (execute-procedure self proc)
		     (setq string (operand-stack-pop self))
		     (when (zerop (setq string-length (string-length string)))
		       (return-from read-loop))
		     (setq string-index 0))
		   (prog1 (aref string string-index)
			  (incf string-index))))
	    (loop for index from bindex
		  repeat row-bytes
		  do
	      (setf (aref bytes index) (sys:bit-reverse-8 (char-code (next-string-char))))))
	(ecase bits/sample
	  ((1)
	   ;; 1 is white, so reverse.
	   (sys:%draw-rectangle width height 0 0 boole-xor raster))
	  ((2)
	   (dotimes (y height)
	     (dotimes (x width)
	       (setf (raster-aref raster x y)
		     (- 3 (sys:bit-reverse-2 (raster-aref raster x y)))))))
	  ((4)
	   (dotimes (y height)
	     (dotimes (x width)
	       (setf (raster-aref raster x y)
		     (- 15 (sys:bit-reverse-4 (raster-aref raster x y)))))))
	  ((8)
	   (dotimes (y height)
	     (dotimes (x width)
	       (setf (raster-aref raster x y)
		     (- 255 (sys:bit-reverse-8 (raster-aref raster x y))))))))
	raster))))

(defmethod (draw-image-raster interpreter-state) (raster width height transform
						  &key (opaque t))
  (when window-output-p
    (check-window-page-status))
  (with-clipped-output-stream (output-stream)
    (graphics:with-graphics-transform (output-stream (graphics:stream-transform self))
      ;;+++ No halftone image drawing primitive in the system.  So, reduce to a one-bit
      ;;image here.
      (let ((nbits (sys:array-bits-per-element (sys:array-type-field raster))))
	(when (> nbits 1)
	  (let ((new-raster (graphics:make-raster-array-with-correct-width
			      width height :element-type 'bit)))
	    (let ((raster raster)
		  (new-raster new-raster))
	      (declare (sys:array-register-1d raster new-raster))
	      (multiple-value-bind (nil nil old-span)
		  (decode-raster-array raster)
		(multiple-value-bind (nil nil new-span)
		    (decode-raster-array new-raster)
		  (let ((threshold (ash 1 (1- nbits))))
		    (loop for y below height
			  for oy from 0 by old-span
			  for ny from 0 by new-span
			  do
		      (loop for x below width
			    for ox from oy
			    for nx from ny
			    do
			(when ( (sys:%1d-aref raster ox) threshold)
			  (setf (sys:%1d-aref new-raster nx) 1))))))))
	    (setq raster new-raster))))
      (graphics:draw-image raster 0 0
			   :image-right width :image-bottom height
			   :stream output-stream
			   :transform (graphics:invert-transform (coerce transform 'list))
			   :pattern graphics-state :opaque opaque))))

(defsubst font-font-matrix (font)
  (gethash '*:|fONTmATRIX| font))

(defsubst font-font-type (font)
  (gethash '*:|fONTtYPE| font))

(defsubst font-encoding-array (font)
  (gethash '*:|eNCODING| font))

(defmethod (try-to-create-font interpreter-state) (name)
  (let ((style (gethash name *standard-font-charstyle-mappings*)))
    (when (null style)
      (signal-error self '*:invalidfont name))
    (let ((font (make-hash-table))
	  (matrix (coerce graphics:*identity-transform* 'vector)))
      (setf (font-encoding-array font) *standard-encoding*)
      (setf (gethash '*:%style font) style)
      (setf (font-font-type font) -1)
      (setf (font-font-matrix font) matrix)
      (setf (gethash name font-directory) font)
      font)))

(defmethod (compute-string-width interpreter-state) (string)
  (let ((x 0) (y 0))
    (map-over-string-elements self string :sizing
			      #'(lambda (char-before width height char-after)
				  (declare (sys:downward-function))
				  (ignore char-after)
				  (when char-before
				    (incf x width)
				    (incf y height))))
    (values x y)))

(defmethod (show-string-internal interpreter-state) (string movement-function)
  (declare (sys:downward-funarg movement-function))
  (map-over-string-elements self string :drawing
			    #'(lambda (char-before width height char-after)
				(declare (sys:downward-function))
				(when char-before
				  (if char-after
				      (funcall movement-function
					       char-before char-after width height)
				      (increment-char-position self width height))))))

(defvar *char-width-handler* #'ignore)

(defmethod (set-current-char-width interpreter-state) (width height)
  (funcall *char-width-handler* width height))

;;; Width function is called before, after, and between characters.
;;; Arguments are char-to-left, width, height, char-to-right.
;;; chars are nil at boundaries.
(defmethod (map-over-string-elements interpreter-state) (string mode width-function)
  (declare (sys:downward-funarg width-function))
  (let ((font (graphics-state-font graphics-state)))
    (unless font
      (signal-error self '*:invalidfont))
    (let ((font-matrix (coerce (font-font-matrix font) 'list)))
      (save-graphics-state self)
      (ecase (font-font-type font)
	((-1)					;Use TV fonts
	 (flet ((do-it (output-stream)
		  (let ((style (gethash '*:%style font))
			(encoding (font-encoding-array font))
			(last-char nil) (last-char-width nil) (last-char-height nil))
		    (loop for char being the array-elements of string do
		      (funcall width-function last-char last-char-width last-char-height char)
		      (setq last-char char)
		      (let ((char (gethash (aref encoding (char-code char))
					   *character-name-decoding*)))
			(multiple-value-setq (last-char-width last-char-height)
			  (if (null char)
			      (values 0 0)
			      (sys:with-stack-array (char-string 1 :element-type 'character)
				(setf (aref char-string 0) char)
				(when (eq mode :drawing)
				  (graphics:with-graphics-transform (self font-matrix)
				    (multiple-value-bind (x y)
					(current-position self)
				      (graphics:draw-string-image
					char-string x y
					:transform (graphics:stream-transform self)
					:character-style style
					:character-size 1 :scale-down-allowed nil
					:pattern graphics-state :opaque t
					:stream output-stream))))
				(values
				  (send output-stream :draw-string-size char-string style 1)
				  0))))
			(multiple-value-setq (last-char-width last-char-height)
			  (if last-char-width	;never set when fonts aren't known about
			      (graphics:transform-distance last-char-width last-char-height
							   font-matrix)
			      (values 0 0)))))
		    (funcall width-function last-char last-char-width last-char-height nil))))
	   (if (eq mode :sizing)
	       (do-it (graphics-state-output-stream graphics-state))
	     (when (and window-output-p (eq mode :drawing))
	       (check-window-page-status))
	     (with-clipped-output-stream (output-stream)
	       (do-it output-stream)))))
	((3)					;User defined
	 (let* ((build (gethash '*:|bUILDcHAR| font))
		(last-char nil)
		(last-char-width nil) (last-char-height nil)
		(*char-width-handler*
		  #'(lambda (width height)
		      (declare (sys:downward-function))
		      (multiple-value-setq (last-char-width last-char-height)
			(graphics:transform-distance width height font-matrix))
		      (when (eq mode :sizing)
			(throw 'just-sizing nil)))))
	   (loop for char being the array-elements of string
		 do
	     (funcall width-function last-char last-char-width last-char-height char)
	     (save-graphics-state self)
	     ;; Current position becomes 0,0
	     (let ((matrix (interpreter-state-transform-matrix self)))
	       (graphics:compose-transforms matrix font-matrix)
	       (graphics:compose-transforms matrix
					    (multiple-value-bind (x y)
						(current-position self)
					      (list 1 0 0 1 x y))))
	     (catch 'just-sizing
	       (execute-procedure self build font (char-code char)))
	     (restore-graphics-state self nil)
	     (setq last-char char))
	   (funcall width-function last-char last-char-width last-char-height nil))))
      (let ((x (graphics-state-x-position graphics-state))
	    (y (graphics-state-y-position graphics-state)))
	(restore-graphics-state self nil)
	(let ((subpath (first (graphics-state-path graphics-state))))
	  (unless subpath
	    (setq subpath (make-path))
	    (push subpath (graphics-state-path graphics-state)))
	  (vector-push-extend :substart subpath)
	  (vector-push-extend x subpath)
	  (vector-push-extend y subpath))
	(setf (graphics-state-x-position graphics-state) x)
	(setf (graphics-state-y-position graphics-state) y)))))

(defmethod (increment-char-position interpreter-state) (width height)
  (multiple-value-setq (width height)
    (graphics:transform-distance width height (graphics:stream-transform self)))
  (incf (graphics-state-x-position graphics-state) width)
  (incf (graphics-state-y-position graphics-state) height))

(export '(display-from-stream))

(defun display-from-stream (input-stream &rest args)
  (let ((interpreter (apply #'make-instance 'interpreter-state :input-stream input-stream
			    args)))
    (interpreter-top-level interpreter)))

(cp:define-command (com-display-postscript-file :command-table "Utilities")
    ((file 'pathname))
   (with-open-file (stream file)
     (display-from-stream stream
			  :standard-input *query-io*
			  :standard-output *trace-output*
			  :window-output-p t))
   (format t "~&Done.~%"))

;;; Someday maybe select page number from file.
(defun postscript-file-binary-encoding (file &optional ignore)
  (graphics:binary-encode-graphics-to-array
    #'(lambda (*standard-output*)
	(with-open-file (input-stream file)
	  (display-from-stream input-stream)))))

(sage:define-picture-type :postscript
  :binary-encoding postscript-file-binary-encoding
  :edit-drawing zwei:ed
  :argument-reader read-filename)

(defun read-filename ()
  (values (zwei:accept-defaulted-pathname "Postscript source file" (zwei:pathname-defaults)
					  :special-type :postscript)
	  ""))

(images:define-image-file-format :postscript
  :pretty-name "PostScript"
  :description "Reads any PostScript images, writes EPSF compatible"
  :read-function read-images-from-ps-file
  :write-function write-images-to-ps-file
  :calling-sequence :image-sequence)

(defflavor image-extracting-interpreter-state
	((images nil))
	(interpreter-state)
  :readable-instance-variables)

(defmethod (draw-image-raster image-extracting-interpreter-state)
	   (raster width height &rest ignore)
  (let ((image (images:make-image-from-raster raster :width width :height height)))
    (images::reflect-image image :vertical)
    (push image images)))

(defflavor dummy-graphics-stream () (graphics::raster-graphics-mixin)
  (:constructor make-dummy-graphics-stream ()))

(defmethod (:unclaimed-message dummy-graphics-stream) (&rest ignore) )

(defun read-images-from-ps-file (file)
  (with-open-file (file-stream file :element-type 'string-char)
    (let ((interpreter (make-instance 'image-extracting-interpreter-state
				      :input-stream file-stream
				      :output-stream (make-dummy-graphics-stream))))
      (interpreter-top-level interpreter)
      (image-extracting-interpreter-state-images interpreter))))

(defun write-images-to-ps-file (file images)
  (images::hardcopy-image (first images) `(:file ,file :postscript) :attempt-rle t))

(compile-flavor-methods graphics-state interpreter-state
			image-extracting-interpreter-state dummy-graphics-stream)
