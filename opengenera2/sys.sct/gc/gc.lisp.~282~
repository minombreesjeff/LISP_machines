;;; -*- Mode: Lisp; Base: 8; Package: System-Internals -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;					+---------------------------------------+
;;					|       SATISFACTION GUARANTEED		|
;;;					|     OR DOUBLE YOUR GARBAGE BACK	|
;;;; Symbolics Garbage Collector	|		       			|
;;;;					|  	   Cape Cod Refuse Co.		|
;;;;					|	Wellfleet, Massachusetts	|
;;;; Remodularized March 1987 by DLA	|					|
;;;					|	    Inventors of the		|
;;					|	Copying Garbage Collector	|
;					+---------------------------------------+


;;; This file contains the machine-independent part of the Garbage Collector.
;;; LM2 garbage collection is no longer supported.
;;; Machine-dependent code may be found in 
;;;   SYS;xCONS     (storage allocators)
;;;   SYS2;xGC      (GC primitives called by this file, and architectural extensions)
;;;   SYS2;xGC-DEFS (Machine-dependent macros)
;;; All user interface routines may be found in SYS2;GC-CONTROL-PANEL

;;; GC depends on GC-DEFS for variable declarations and xGC-DEFS for
;;; machine-dependent macros.

;;; Variables

;;; GC Status Reporting

;This queue enables reports from the GC process to come out in the
;right order and to be deferred until critical operations are
;complete so that they don't get disrupted.
(DEFVAR *GC-REPORT-QUEUE* NIL)

;Only one process at a time outputting to GC-REPORT-STREAM, please.
(DEFVAR *GC-REPORT-STREAM-LOCK* (PROCESS:MAKE-LOCK "GC Report Stream Lock"))

;Args like FORMAT, but stream comes from GC-REPORT-STREAM
;This function is used to report normal activities of the GC, such as flipping.
;For abnormal events that the user should see even if normal reports are
;disabled, use TV:NOTIFY.
(DEFUN GC-REPORT (FORMAT-CONTROL &REST FORMAT-ARGS)
  (COND ((OR (EQ GC-REPORT-STREAM T)
	     (NOT (AND (VARIABLE-BOUNDP GC-PROCESS) (EQ CURRENT-PROCESS GC-PROCESS))))
	 ;; Issue the report immediately if we are not in the GC process, or
	 ;; if it is a notification (notifications are just queued for delivery
	 ;; by another process).
	 (LEXPR-FUNCALL #'GC-REPORT-1 GC-REPORT-STREAM FORMAT-CONTROL FORMAT-ARGS))
	(GC-REPORT-STREAM
	 ;; Don't try to do stream output from the GC process, since it might get
	 ;; hung up.  Put the report on a queue for later delivery by another process.
	 (SETQ *GC-REPORT-QUEUE* (NCONC *GC-REPORT-QUEUE*
					(NCONS (LIST* GC-REPORT-STREAM
						      FORMAT-CONTROL
						      (COPYLIST FORMAT-ARGS))))))))

;;; Similar to GC-REPORT, for things that get boring if they happen too often.
;;; WARNING-CLASS is a unique symbol classifies this warning.
;;; If warnings are going to notifications, and a warning of the same class has been
;;; displayed within the past GC-WARNING-INTERVAL, then ignore the warning.
(DEFUN GC-WARNING (WARNING-CLASS FORMAT-CONTROL &REST FORMAT-ARGS &AUX LAST-TIME)
  (WHEN (AND ;; Warnings must be enabled, and
	     GC-WARNINGS-ENABLE
	     (OR ;; The warnings are going to someplace other than notifications, or
		 (NEQ GC-REPORT-STREAM T)
		 ;; This must be the first warning of this class, or
		 (NULL (SETQ LAST-TIME (CDR (ASSQ WARNING-CLASS LAST-GC-WARNING-TIME-ALIST))))
		 ;; There must be a warning interval and it must have elapsed.
		 (AND GC-WARNING-INTERVAL
		      (TIME-ELAPSED-P GC-WARNING-INTERVAL LAST-TIME))))
    ;; If we're issuing a warning, then keep track of the time we gave it.
    (LET ((ELEMENT (ASSQ WARNING-CLASS LAST-GC-WARNING-TIME-ALIST)))
      (IF ELEMENT
	  (SETF (CDR ELEMENT) (TIME))
	  (PUSH (CONS WARNING-CLASS (TIME)) LAST-GC-WARNING-TIME-ALIST)))
    ;; Send the loser his warning.
    (LEXPR-FUNCALL #'GC-REPORT FORMAT-CONTROL FORMAT-ARGS)))

;Print the deferred reports (called by GC process)
(DEFUN EMPTY-GC-REPORT-QUEUE ()
  (WHEN *GC-REPORT-QUEUE*
    (PROCESS-RUN-FUNCTION '(:NAME "GC Report" :PRIORITY 10.)
			  #'(LAMBDA (QUEUE)
			      (DOLIST (X QUEUE)
				(LEXPR-FUNCALL #'GC-REPORT-1 X)))
			  *GC-REPORT-QUEUE*)
    (SETQ *GC-REPORT-QUEUE* NIL)))

;Run in a separate process so the GC process never hangs
(DEFUN GC-REPORT-1 (STREAM FORMAT-CONTROL &REST FORMAT-ARGS)
  (COND ((NULL STREAM))
	((EQ STREAM T)
	 (LEXPR-FUNCALL #'TV:NOTIFY NIL FORMAT-CONTROL FORMAT-ARGS))
	(T
	 (PROCESS:WITH-LOCK (*GC-REPORT-STREAM-LOCK*)
	   (FORMAT STREAM "~&~\DATIME\ ~~?~" FORMAT-CONTROL FORMAT-ARGS)))))

  ;;
;;;;;;  Plummer Hysteresis
  ;;

;;; Before this version of hysteresis, there was a one-level region
;;; hystersis which was implemented using the global variabls
;;; si:*scavenge-region*.  [That version is still here, by the way.
;;; This new version takes precedence.]  There was a previous experiment
;;; to extend this by remembering, in addition to the last region, the
;;; last copyspace area, the last static region, the last static area,
;;; etc.  That experiment was a failure (i.e., it didn't help).

;;; The idea here is to remember a complete history of copyspace
;;; regions, in Most-Recently-Used fashion (MRU).  By doing this, there
;;; is a much greater likelihood that complete data structures that span
;;; several regions (e.g., list and structure) and/or several areas
;;; (sigh) will get transported at about the same time, thus increasing
;;; locality.  (This couldn't happen before because if the scavenger
;;; succeeded in one region, or if it had to give up because of
;;; work-units, it wouldn't necessarily pick up where it left off.

;;; The theory is that TRANSPORT-TRAP will use (PUSH-*GC-HYSTERESIS*
;;; REGION) in addition to (SETQ *SCAVENGE-REGION* REGION).  The
;;; scavenger will never [effectively] (POP-*GC-HYSTERESIS* REGION)
;;; until >after< it finishes that region.  This keeps it working on the
;;; same region until it is finished (or until it is preempted by a
;;; transport, in which case it will return to that region when the
;;; transitive closure of new regions followed by the transport take
;;; over).

;;; The data structure and algorithm were chosen so that insert, delete
;;; and first-element are all constant time operations, and so that a
;;; MRU data structure is maintained.  They are kept in
;;; SAFEGUARDED-OBJECTS-AREA because they are referenced by the
;;; scavenger and must therefore be static.  This data structure is
;;; circular when there is more than one item on *GC-HYSTERESIS*.
;;; That's OK.  If you really want to look at it, use
;;; SI:PRINT-*GC-HYSTERESIS*.

(defstruct (gc-hysteresis
	     :list*
	     (:conc-name gc-hyst-)
	     (:constructor nil)
	     (:alterant nil))
  region
  next
  prev)

;; Embed all the gc-hysteresi in an array, to save a minimal amount of safeguarded storage,
;; and to get rid of the only safeguarded list region.
(defun create-gc-hysteresis-objects ()
  (loop with n = number-of-regions
	with objects = (make-array (* 3 n) :type art-q-list
					   :area safeguarded-objects-area)
	with region = 0
	with i = 0
	while (< region n)
	do (setf (aref objects i) (floor i 3))
	   (setf (%p-cdr-code (aloc objects i)) cdr-next)
	   (incf i)
	   (setf (%p-cdr-code (aloc objects i)) cdr-normal)
	   (incf i)
	   (setf (%p-cdr-code (aloc objects i)) cdr-nil)
	   (incf i)
	   (incf region)
	finally (return objects)))

(defvar-safeguarded *gc-hysteresis* nil)
(defvar *gc-hysteresis-objects* (create-gc-hysteresis-objects))

(defsubst pop-*gc-hysteresis* (region)
  ;; only pop if the region is at the head.  This should always be the
  ;; case; but be sure anyway.  --- Maybe FERROR instead?  This gets
  ;; called inside the scavenger.
  (let ((hyst *gc-hysteresis*))
    (when (and hyst (= (gc-hyst-region hyst) region))
      (let ((next (gc-hyst-next hyst)))
	(setf (gc-hyst-next hyst) nil)
	(when next (setf (gc-hyst-prev next) nil))
	(setf *gc-hysteresis* next))))
  nil)

(defsubst push-*gc-hysteresis* (region)
  ;; Push the region onto *GC-HYSTERESIS*.  This really plucks the old
  ;; object out, unlinks it as necessary, and then 'pushes' it on the
  ;; front.  This gets called by the transporter and scavenger.
  (let ((now *gc-hysteresis*))
    (unless (and now (= (gc-hyst-region now) region))
      (let ((hyst (%make-pointer dtp-list
				 (aloc *gc-hysteresis-objects* (+ region region region)))))
	(let ((prev (gc-hyst-prev hyst))
	      (next (gc-hyst-next hyst)))
	  (when prev (setf (gc-hyst-next prev) next))
	  (when next (setf (gc-hyst-prev next) prev)))
	(setf (gc-hyst-prev hyst) nil)
	(setf (gc-hyst-next hyst) now)
	(when now (setf (gc-hyst-prev now) hyst))
	(setf *gc-hysteresis* hyst))))
  nil)

(defun print-*gc-hysteresis* ()
  (loop for hyst = *gc-hysteresis* then (gc-hyst-next hyst) while hyst do
    (prin1-then-space (gc-hyst-region hyst))))

;;; Flipper

;; Bit vector of extant oldspace levels
(DEFVAR-SAFEGUARDED *GC-OLDSPACE-LEVEL-MASK*
  (MAKE-ARRAY %NUMBER-OF-LEVELS :AREA SAFEGUARDED-OBJECTS-AREA :TYPE ART-BOOLEAN))

;; It is often convenient to switch between using an array of levels
;; and fixnum masks of ephemeral levels.  The following macros hide the gross
;; and efficient way we do this.  A lot of the grossness is gratuitous.

;; This is a bit vector of all ephemeral levels which are oldspace.
(DEFMACRO EPHEMERAL-OLDSPACE-LEVEL-MASK (&OPTIONAL (ARRAY '*GC-OLDSPACE-LEVEL-MASK*))
  `(%P-CONTENTS-OFFSET ,ARRAY 1))

;; Set all levels to be newspace.
#+IMach
(DEFMACRO ZERO-GC-OLDSPACE-LEVEL-MASK ()
  `(WITH-SYSTEM-BLOCK-REGISTERS (1)
     (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS *GC-OLDSPACE-LEVEL-MASK* 1))
     (SI:PREPARE-FOR-BLOCK-WRITE)
     (%BLOCK-WRITE 1 0)
     (%BLOCK-WRITE 1 0)))

#+3600
(DEFUN ZERO-GC-OLDSPACE-LEVEL-MASK ()
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET ((GC-OLDSPACE-LEVEL-MASK *GC-OLDSPACE-LEVEL-MASK*))
    (DECLARE (ARRAY-REGISTER GC-OLDSPACE-LEVEL-MASK))
    (LOOP FOR I BELOW %NUMBER-OF-LEVELS
	  DO (SETF (AREF GC-OLDSPACE-LEVEL-MASK I) NIL))))

;; Set all levels to be oldspace as specified by some other mask.
#+IMach
(DEFMACRO SET-GC-OLDSPACE-LEVEL-MASK (NEW-MASK)
  ;;--- This had better only be called without interrupts!
  `(SAVING-REGISTERS-FOR-EFFECT (%REGISTER-BAR-2)
     (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS ,NEW-MASK 1))
     (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS *GC-OLDSPACE-LEVEL-MASK* 1))
     (SI:PREPARE-FOR-BLOCK-WRITE)
     (%BLOCK-WRITE 2 (%BLOCK-READ 1 :FIXNUM-ONLY T))
     (%BLOCK-WRITE 2 (%BLOCK-READ 1 :FIXNUM-ONLY T :PREFETCH NIL))))

#+3600
(DEFUN SET-GC-OLDSPACE-LEVEL-MASK (NEW-MASK)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET ((GC-OLDSPACE-LEVEL-MASK *GC-OLDSPACE-LEVEL-MASK*)
	(NEW-MASK NEW-MASK))
    (DECLARE (ARRAY-REGISTER GC-OLDSPACE-LEVEL-MASK NEW-MASK))
    (LOOP FOR I BELOW %NUMBER-OF-LEVELS
	  DO (SETF (AREF GC-OLDSPACE-LEVEL-MASK I) (AREF NEW-MASK I)))))

;; Construct a level mask array from fixnum masks.
#+IMach
(DEFMACRO WITH-LEVEL-MASK-ARRAY ((VAR EPHEMERAL-LEVEL-MASK &OPTIONAL (DYNAMIC-LEVEL-MASK 0))
				 &BODY BODY)
  `(LET* ((.HEADER. (%SET-TAG (%LOGDPBS ART-BOOLEAN ARRAY-TYPE-FIELD
					64. ARRAY-SHORT-LENGTH-FIELD 0)
			      (%LOGDPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
				       DTP-HEADER-I)))
	  (.WORD1. ,EPHEMERAL-LEVEL-MASK)
	  (.WORD2. ,DYNAMIC-LEVEL-MASK)
	  (,VAR (%SET-TAG (LOCF .HEADER.) DTP-ARRAY)))
     .WORD1. .WORD2.
     . ,BODY))

#+3600
(DEFMACRO WITH-LEVEL-MASK-ARRAY ((VAR EPHEMERAL-LEVEL-MASK &OPTIONAL (DYNAMIC-LEVEL-MASK 0))
				 &BODY BODY)
  `(WITH-STACK-ARRAY (,VAR 64. :TYPE ART-BOOLEAN)
     (LET ((.P. ,VAR))
       (%P-STORE-CONTENTS-INCREMENT-POINTER ,EPHEMERAL-LEVEL-MASK .P.)
       (%P-STORE-CONTENTS-INCREMENT-POINTER ,DYNAMIC-LEVEL-MASK .P.))
     . ,BODY))

;;; Temporary debugging meters.
(DEFVAR-SAFEGUARDED LAST-GC-FLIP-METERS
  (G-L-P (MAKE-ARRAY 64. :AREA SAFEGUARDED-OBJECTS-AREA :TYPE ART-Q-LIST)))

(DEFUN PRINT-GC-FLIP-METERS ()
  (LOOP WITH TOTAL = 0 WITH X
	FOR (NAME TIME) ON LAST-GC-FLIP-METERS BY #'CDDR
	AND LAST-TIME = NIL THEN TIME
	UNTIL (NULL TIME)
	WHEN LAST-TIME
	  DO (INCF TOTAL (SETQ X (%32-BIT-DIFFERENCE TIME LAST-TIME)))
	     (FORMAT T "~%~30<~A:~;~>  ~8D microseconds" NAME X)
	FINALLY
	  (FORMAT T "~2%~30<~A:~;~>  ~8D microseconds" "Total" TOTAL)))

;; This is the main GC flipper.  It is called -INTERNAL to make sure
;; that people who don't know what they're doing don't call it.
;; Callers of this function are expected to
;;   - disable interrupts
;;   - GC-WAIT-UNTIL-FLIP-OKAY
;;   - Ensure %GC-FLIP-READY and GC-RECLAIMED-OLDSPACE are true
;;   - check that sufficient free space exists for the GC

;; MODE is either :DYNAMIC or :EPHEMERAL
;; The regions flipped are controlled by the following arguments:
;;   FLIP-AREA-MASK is a boolean array at least (N-AREAS) long, or NIL for all eligible.
;;   FLIP-REGION-MASK is a boolean array at least (N-REGIONS) long, or NIL for all eligible.
;;   FLIP-LEVEL-MASK is a boolean array for levels to be flipped, or NIL for all eligible.
;;      The level mask must be specified for ephemeral GC.
;; The transporter is set up to migrate objects by using ONE of the following arguments:
;;   REGION-MIGRATION-ARRAY maps each region to be flipped to copyspace levels.
;;   LEVEL-MIGRATION-ARRAY maps levels to copyspace levels.
;;   If neither is specified, a migration map is set up to do the default thing.
;; Reordering is performed after a flip under control of the following arguments:
;;   REORDERINGS is a list reorderings to transport immediately in the specified order.
;;   INCREMENTAL-REORDERING is an argument to pass on to TRANSPORT-REORDERINGS.
(DEFUN GC-FLIP-INTERNAL (MODE FLIP-AREA-MASK FLIP-REGION-MASK FLIP-LEVEL-MASK
			 REGION-MIGRATION-ARRAY LEVEL-MIGRATION-ARRAY
			 REORDERINGS INCREMENTAL-REORDERING BLOCK-TRANSPORT-REGION-MASK
			 &AUX (OLD-INHIBIT-CONSING-FLAG *INHIBIT-CONSING-FLAG*)
			      (*INHIBIT-CONSING-FLAG* OLD-INHIBIT-CONSING-FLAG)
			      EPHEMERAL-MODE
			      (GC-FLIP-METERS LAST-GC-FLIP-METERS);--
			      (STATIC-FLIP NIL))
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE ERROR COPYSPACE RESIDENT-PAGES
				    MAKE-SIMPLE-STACK-ARRAY :EPHEMERAL))
  (MACROLET ((FLIP-AREA-P (AREA)
	       `(OR (NULL FLIP-AREA-MASK)
		    (AREF FLIP-AREA-MASK ,AREA)))
	     (FLIP-REGION-P (REGION)
	       `(OR (NULL FLIP-REGION-MASK)
		    (AREF FLIP-REGION-MASK ,REGION)))
	     (DO-FLIPPABLE-REGIONS ((AREA REGION BITS LEVEL-TYPE) &BODY BODY)
	       `(LOOP WITH ,LEVEL-TYPE FOR ,AREA BELOW (N-AREAS)
		      WHEN (FLIP-AREA-P ,AREA) DO
		  (DO-AREA-REGIONS (,REGION ,AREA)
		    (LET ((,BITS (REGION-BITS ,REGION)))
		      (SELECTOR (LDB %%REGION-SPACE-TYPE ,BITS) =
			((%REGION-SPACE-NEW %REGION-SPACE-COPY)
			 (SETQ ,LEVEL-TYPE (LEVEL-TYPE (LDB %%REGION-LEVEL ,BITS)))
			 (WHEN (AND (IF (NULL FLIP-LEVEL-MASK)
					( ,LEVEL-TYPE %LEVEL-TYPE-DYNAMIC)
				      (AREF FLIP-LEVEL-MASK (LDB %%REGION-LEVEL ,BITS)))
				    (FLIP-REGION-P ,REGION))
			   . ,BODY)))))))
	     (METER-FLIP (NAME)
	       `(PROGN (SETF (CAR GC-FLIP-METERS) ,NAME)
		       (SETQ GC-FLIP-METERS (CDR GC-FLIP-METERS))
		       (SETF (CAR GC-FLIP-METERS) (%MICROSECOND-CLOCK))
		       (SETQ GC-FLIP-METERS (CDR GC-FLIP-METERS)))))
    (LOOP FOR SUBLIST ON GC-FLIP-METERS DO (SETF (CAR SUBLIST) NIL));--
    (METER-FLIP NIL)
    (SELECTQ MODE
      (:EPHEMERAL
       (SETQ EPHEMERAL-MODE T)
       (WHEN (OR REORDERINGS INCREMENTAL-REORDERING)
	 (ERROR "Reorderings may not be specified for an ephemeral flip.")))
      (:DYNAMIC)
      (OTHERWISE (ERROR "GC-FLIP-INTERNAL mode must be :DYNAMIC or :EPHEMERAL")))
    
    ;; Check to make sure this is okay.
    (UNLESS INHIBIT-SCHEDULING-FLAG
      (ERROR "GC-FLIP-INTERNAL called with scheduling enabled"))
    
    ;; Make sure we don't flip what we shouldn't.
    ;; A dynamic flip while the ephemeral GC is active would almost work if the rest
    ;; of the scavenger state were reset.  However, it would prevent the ephemeral GC
    ;; from completing until the dynamic GC completed, so it's better to wait then flip.
    (UNLESS (AND %GC-FLIP-READY GC-RECLAIMED-OLDSPACE)
      (ERROR "Cannot flip without first completing the previous garbage collection"))
    
    (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-GC-POINTER
				  AREA-REGION-LIST REGION-LIST-THREAD
				  #+3600 REGION-ORIGIN #+3600 REGION-LENGTH
				  REGION-FREE-POINTER LEVEL-TYPE)
      
      ;;--- This shouldn't be necessary, but I'm going to temporarily put it here
      ;;--- to try to track down a bug.
      ;;--- Later:  I believe I've now tracked this down.
      (DOTIMES (REGION (N-REGIONS))
	(WHEN (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION)) %REGION-SPACE-OLD)
	  (ERROR "GC Internal Error:  GC completed but oldspace exists while flipping?")))

      (METER-FLIP "Setup")

      ;; Update meters and reset per-flip meters, consing bignums now where it is safe.
      (MACROLET ((UPDATE-TOTALS (TOTAL-METER PER-FLIP-METER)
		   `(INCF ,TOTAL-METER (CL:SHIFTF ,PER-FLIP-METER 0))))
	(UPDATE-TOTALS TOTAL-TRANSPORTER-WORDS TRANSPORTER-WORDS)
	(UPDATE-TOTALS SCAVENGER-FIRST-PASS-TOTAL-WORDS SCAVENGER-FIRST-PASS-WORDS)
	(UPDATE-TOTALS SCAVENGER-FINAL-PASS-TOTAL-WORDS SCAVENGER-FINAL-PASS-WORDS)
	(UPDATE-TOTALS SCAVENGER-RESIDENT-PAGES-TOTAL-WORDS SCAVENGER-RESIDENT-PAGES-WORDS)
	(UPDATE-TOTALS SCAVENGER-ESRT-TOTAL-WORDS (LDB (BYTE 32 0) SCAVENGER-ESRT-WORDS)))
      
      (METER-FLIP "Update meters")

      ;; Check that we're really going to flip
      ;; and set up the "real" region mask array for later use.
      (WITH-STACK-ARRAY (REAL-REGION-MASK (N-REGIONS) :TYPE ART-BOOLEAN)
	(DECLARE (ARRAY-REGISTER REAL-REGION-MASK))
	(LET ((FLIP NIL))
	  (DO-FLIPPABLE-REGIONS (AREA REGION BITS LEVEL-TYPE)
	    (SETQ FLIP T)
	    (SETF (AREF REAL-REGION-MASK REGION) T)
	    (WHEN (< LEVEL-TYPE %LEVEL-TYPE-DYNAMIC)
	      (SETQ STATIC-FLIP T)
	      ;; Signal this here before it's too late.
	      (WHEN (< LEVEL-TYPE %LEVEL-TYPE-STATIC)
		(ERROR "Attempt to flip a safeguarded or wired region"))))
	  (UNLESS FLIP
	    (RETURN-FROM GC-FLIP-INTERNAL NIL)))
      
	(METER-FLIP "Check for flippable regions")
  
	;; Now we know we're going to flip.
	
	;; Set up all the consing measurers.  This is the last chance we have to do
	;; this before we inhibit consing.
	(DECF *CONS-WORK-DONE* (+ (%STRUCTURE-CACHE-LENGTH) (%LIST-CACHE-LENGTH)))
	(INCF TOTAL-CONS-WORK-DONE *CONS-WORK-DONE*)	;This can cons a bignum.
	(SETQ *CONS-WORK-DONE* 0 *SCAV-WORK-DONE* 0)
	(SETF (%STRUCTURE-CACHE-LENGTH) 0)
	(SETF (%LIST-CACHE-LENGTH) 0)
	(SETQ GC-PAGE-CONS-ALARM-MARK CL:MOST-NEGATIVE-FIXNUM)
	
	;; Inhibit consing.  This has to come before setting the
	;; scavenger status, since otherwise NOTE-CONS-WORK-DONE will
	;; not work properly until the flip has completed.
	(SETQ *INHIBIT-CONSING-FLAG* T)
	(CLEAR-CONS-CACHES)
	(%CLEAR-CACHES)
	
	;; Reset scavenger status
	(SETQ %GC-FLIP-READY NIL)
	(SETQ GC-RECLAIMED-OLDSPACE NIL)
	(SETQ *SCAVENGE-REGION* NIL)
	(LOOP WHILE *GC-HYSTERESIS* DO
	  (POP-*GC-HYSTERESIS* (GC-HYST-REGION *GC-HYSTERESIS*)))
	(COND (EPHEMERAL-MODE
		(SETQ *SCAVENGER-STATE* 'RESIDENT-PAGES
		      *SCAVENGER-RESIDENT-PAGES-STATE* 0
		      *EPHEMERAL-GC-IN-PROGRESS* T)
		(SET-GC-OLDSPACE-LEVEL-MASK FLIP-LEVEL-MASK))
	      (T (SETQ *SCAVENGER-STATE* 'COPYSPACE)
		 (SETQ *EPHEMERAL-GC-IN-PROGRESS* NIL)
		 (ZERO-GC-OLDSPACE-LEVEL-MASK)))
	(SETQ *TRANSPORTER-BREAK-WEAK-LINKS* NIL)

	(METER-FLIP "Reset scavenger state")

	;; Frob the REGION-GC-POINTERs.
	;; The scavenge pointer should be 0 for dynamic GC's, to make sure everything
	;; gets scavenged.  For ephemeral GC's, the ephemeral scavenger will get all
	;; references, so all we'll have to scavenge is copyspace.
	(LOOP FOR REGION BELOW (N-REGIONS)
	      AS BITS = (REGION-BITS REGION)
	      WHEN (LDB-TEST %%REGION-SCAVENGE-ENABLE BITS)
		DO (SETF (REGION-GC-POINTER REGION)
			 (IF EPHEMERAL-MODE
			     (REGION-FREE-POINTER REGION)
			     0)))
	
	(METER-FLIP "Fixup REGION-GC-POINTERs")

	#+3600
	(WITH-FAST-STORAGE-ACCESSORS (REGION-FREE-POINTER-BEFORE-FLIP)
	  (LOOP FOR REGION BELOW (N-REGIONS)
		DO (SETF (REGION-FREE-POINTER-BEFORE-FLIP REGION)
			 (REGION-FREE-POINTER REGION))))
	#+IMach
	;; The above is too slow. 
	(WITH-SYSTEM-BLOCK-REGISTERS (1 2)
	  (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS .REGION-FREE-POINTER. 1))
	  (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS *REGION-FREE-POINTER-BEFORE-FLIP* 1))
	  (PREPARE-FOR-BLOCK-WRITE)
	  (DOTIMES (IGNORE (%FIXNUM-CEILING (N-REGIONS) 8))
	    (LET ((A (%BLOCK-READ 1))		    (B (%BLOCK-READ 1))
		  (C (%BLOCK-READ 1))		    (D (%BLOCK-READ 1))
		  (E (%BLOCK-READ 1))		    (F (%BLOCK-READ 1))
		  (G (%BLOCK-READ 1 :PREFETCH NIL)) (H (%BLOCK-READ 1 :PREFETCH NIL)))
	      (%BLOCK-WRITE 2 A) (%BLOCK-WRITE 2 B)
	      (%BLOCK-WRITE 2 C) (%BLOCK-WRITE 2 D)
	      (%BLOCK-WRITE 2 E) (%BLOCK-WRITE 2 F)
	      (%BLOCK-WRITE 2 G) (%BLOCK-WRITE 2 H))))

	(INCF %GC-GENERATION-NUMBER)
	(WHEN (NOT EPHEMERAL-MODE)
	  (INCF %GC-DYNAMIC-GENERATION-NUMBER)
	  (WHEN STATIC-FLIP
	    (INCF %GC-STATIC-GENERATION-NUMBER)))
	#+IGNORE (ENTER-SCAVENGE-TRACE %SCAV-OP-FLIP %GC-GENERATION-NUMBER)
	
	(METER-FLIP "Copy REGION-FREE-POINTER, etc")

	;; Do the flip.
	(LOOP WITH (BITS LEVEL)
	      FOR REGION BELOW (N-REGIONS)
	      WHEN (AREF REAL-REGION-MASK REGION) DO
	  (SETF (REGION-BITS REGION)
		(%LOGDPBS 0 %%REGION-SCAVENGE-ENABLE
			  %REGION-SPACE-OLD %%REGION-SPACE-TYPE
			  (SETQ BITS (REGION-BITS REGION))))
	  ;; Store the level number which should be used for copyspace for this
	  ;; region in the low 8 bits of the GC-POINTER.  The next 16 bits are
	  ;; the cached copyspace region, which is set to -1 to indicate that
	  ;; the cache is empty for this region.
	  (SETQ LEVEL (LDB %%REGION-LEVEL BITS))
	  (SETF (REGION-GC-POINTER REGION)
		(DPBS (OR (AND REGION-MIGRATION-ARRAY (AREF REGION-MIGRATION-ARRAY REGION))
			  (AND LEVEL-MIGRATION-ARRAY (AREF LEVEL-MIGRATION-ARRAY LEVEL))
			  (DEFAULT-COPYSPACE-LEVEL-FOR-LEVEL LEVEL EPHEMERAL-MODE))
		      %%GC-POINTER-COPYSPACE-LEVEL
		      #+IMACH -1 #+IMACH %%GC-POINTER-COPYSPACE-REGION 0))

	  ;; Inform 3600 hardware of the flip.
	  #+3600 (FILL-GC-MAP (REGION-ORIGIN REGION) (REGION-LENGTH REGION)
			      (IF (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL BITS))
				  %GC-MAP-OLD-EPHEMERAL
				  %GC-MAP-OLD))

	  ;; Give back any unused quanta at end of region
	  (SHORTEN-REGION REGION))

	#+VLM
	;; Flush the stack-cache, to update the VLM enable logic
	(%coprocessor-write (compiler:%stack-location-internal 0) #o1201)

	#+IMACH (REINITIALIZE-OLDSPACE-REGISTERS)
	#+imach (SET-PHT-TRANSPORT-ENABLES)
	#+imach (SETQ %COPYSPACE-TRANSPORT-TRAP-CLEARED 0)
	#+imach (METER-FLIP "Set registers and PHT")

	(METER-FLIP "Do the flip")

	(clear-snap-out-cache)			;moved earlier (was after reorderings) kr & ptw

	;; Do the reorderings now before we scavenge the stack buffer.
	;; The call to SHORTEN-REGION above will have guaranteed that there's enough
	;; space on the stack to do this without reloading the stack buffer.
	(WHEN REORDERINGS
	  (TRANSPORT-REORDERINGS REORDERINGS INCREMENTAL-REORDERING))
	
	(METER-FLIP "Do reorderings")

	(WHEN BLOCK-TRANSPORT-REGION-MASK
	  (LET ((BLOCK-TRANSPORT-REGION-MASK BLOCK-TRANSPORT-REGION-MASK))
	    (DECLARE (ARRAY-REGISTER BLOCK-TRANSPORT-REGION-MASK))
	    (LOOP FOR REGION BELOW (N-REGIONS)
		  WHEN (AND (AREF REAL-REGION-MASK REGION)
			    (AREF BLOCK-TRANSPORT-REGION-MASK REGION))
		    DO (EVACUATE-OLDSPACE-REGION REGION))))

	;; Transport these now before letting everyone else loose.
	(%TRANSPORT-MACHINE-STATE)
    
	#+VLM
	;; The VLM has very large instruction and data caches.  We must flush them
	;; now to ensure that all appropriate transport traps will occur and to
	;; remove any stale oldspace references in the instruction cache for this
	;; and other safeguarded functions.
	(%coprocessor-write t %coprocessor-register-flush-id-caches)

	(METER-FLIP "Transport Machine State")

	;; Return T to indicate that we really flipped.
	T)))) 

(DEFUN DEFAULT-COPYSPACE-LEVEL-FOR-LEVEL (LEVEL EPHEMERAL-MODE)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (COND ;; Nonephemeral levels always migrate to themselves by default.
	((NOT (EPHEMERAL-LEVEL-P LEVEL)) LEVEL)
	;; Ephemeral levels depend on *EPHEMERAL-MIGRATION-MODE* in ephemeral GC's.
	(EPHEMERAL-MODE
	 (SELECTQ *EPHEMERAL-MIGRATION-MODE*
	   ;; :NORMAL migrates to the next normal level.
	   (:NORMAL (AREF *EPHEMERAL-GC-NORMAL-NEXT-LEVEL* LEVEL))
	   ;; :DYNAMIC migrates everything to dynamic space.
	   (:DYNAMIC %DYNAMIC-LEVEL)
	   ;; :KEEP migrates to the next kept level, but the last level
	   ;; migrates to itself.
	   (:KEEP (LET ((L (AREF *EPHEMERAL-GC-KEEP-NEXT-LEVEL* LEVEL)))
		    (IF (= L %DYNAMIC-LEVEL) LEVEL L)))
	   ;; :COLLECT, :EXTRA just migrate to the next KEEP level.
	   ;; LEVELS-TO-FLIP ensures that the last level doesn't get
	   ;; flipped in :COLLECT mode.
	   (OTHERWISE (AREF *EPHEMERAL-GC-KEEP-NEXT-LEVEL* LEVEL))))
	;; Ephemeral levels become dynamic in dynamic GC's.
	(T %DYNAMIC-LEVEL)))

;;; Higher level flipping routines.

(DEFVAR *DYNAMIC-GC-FLIP-ARGS*)

;; This is the high level worker for any dynamic GC flip.
;; Returns :INCREMENTAL if it flipped and thinks it can survive incremental scavenging.
;; Returns :IMMEDIATE if it flipped and doesn't think it can survive incremental scavenging.
;; Returns NIL if it decides not to flip, for whatever reason.
;;
;; Arguments
;;   RATIO is the expected good-data ratio (a la GC-FLIP-RATIO).
;;   RECLAIM is the type of reclamation to follow.  It is one of
;;	   :INCREMENTAL (default) -- this is a dynamic GC
;;	   :IMMEDIATE -- this is an immediate GC
;;	   :PREFER-INCREMENTAL -- :INCREMENTAL if we can do it, else :IMMEDIATE.
;;   INSUFFICIENT-ADDRESS-SPACE-ACTION is one of the following:
;;	   :QUERY (default) asks if you really want to flip.
;;	   :PROCEED blithely proceeds.
;;	   :NOTIFY notifies you and doesn't flip.
;;	   :NOTIFY-PROCEED notifies you and proceeds.
;;	   :ABORT simply returns NIL
;;	   :ERROR signals a FERROR
;;   RECLAIM-OLDSPACE is examined if we're called while reclaiming oldspace.
;;	   If it is true, we reclaim oldspace, and then flip.
;;	   If it is false, we return NIL immediately.
;;   AREA-LIST, if specified, is a list of areas to flip.  Only eligible regions from
;;	   those areas are flipped.  By default all areas are considered.
;;   REGION-LIST, if specified, is a list of regions to flip.  Only those regions are
;;	   flipped, and only if they are eligible.  If both AREA-LIST and REGION-LIST
;;	   are specified, then the eligible intersection is flipped.
;;   LEVEL-LIST, if specified, is a list of levels to flip.
;;   REORDERINGS is a list of reorderings to perform after flipping.
;;   INCREMENTAL-REORDERING is an argument to pass on to TRANSPORT-REORDERINGS.
(DEFUN DYNAMIC-GC-FLIP (&REST REST
			&KEY (RATIO GC-FLIP-RATIO)
			     (RECLAIM :INCREMENTAL)
			     (INSUFFICIENT-ADDRESS-SPACE-ACTION :QUERY)
			     (RECLAIM-OLDSPACE T)
			     ;; Control of what gets flipped
			     (AREA-MASK NIL)
			     (REGION-MASK NIL)
			     (LEVEL-MASK NIL)
			     ;; Control of where it goes
			     (REGION-MIGRATION-ARRAY NIL)
			     (LEVEL-MIGRATION-ARRAY NIL)
			     (AREA-MIGRATION-ARRAY NIL)
			     ;; Control of initial transporting.
			     (REORDERINGS NIL)
			     (INCREMENTAL-REORDERINGS NIL)
			     (BLOCK-TRANSPORT-REGION-MASK NIL)
			&AUX (TEMP NIL))
  (WHEN NESTED-INHIBIT-GC-FLIPS-FLAG
    (FERROR "You cannot call ~S inside ~S" 'DYNAMIC-GC-FLIP 'INHIBIT-GC-FLIPS))
  (UNLESS %GC-FLIP-READY
    (IF RECLAIM-OLDSPACE
	(GC-RECLAIM-OLDSPACE)
	(RETURN-FROM DYNAMIC-GC-FLIP NIL)))
  (MULTIPLE-VALUE-BIND (COMMITTED AVAILABLE IMMEDIATE-COMMITTED)
      (LET ((GC-RECLAIM-IMMEDIATELY (EQ RECLAIM :IMMEDIATE)))
	(GC-GET-COMMITTED-FREE-SPACE AREA-MASK REGION-MASK))
    (TAGBODY RETRY
      (COND ((OR ( (* COMMITTED RATIO) AVAILABLE)
		 (AND GC-FLIP-MINIMUM-RATIO
		      ( (* COMMITTED GC-FLIP-MINIMUM-RATIO) AVAILABLE))
		 (SELECTQ INSUFFICIENT-ADDRESS-SPACE-ACTION
		   (:QUERY
		    (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
		      (IF (EQ RECLAIM :IMMEDIATE)
			  "There are ~:D words of free space available, but doing an~3*~@
			 immediate garbage collection could require up to ~
			 ~:D words (~D%).~@
			 Do you want to risk a GC anyway? "
			  "There are ~:D words of free space available, but doing an~@
			 incremental garbage collection could require up to ~
			 ~:D words (~D%).~@
			 ~:\SI:GC-COMMAND\ would require up to ~:D words (~D%).~@
			 Do you want to risk an incremental GC anyway? ")
		      AVAILABLE COMMITTED (// (* COMMITTED 100.) AVAILABLE)
		      '(COM-START-GC :IMMEDIATELY)
		      IMMEDIATE-COMMITTED (// (* IMMEDIATE-COMMITTED 100.) AVAILABLE)))
		   (:PROCEED T)
		   (:NOTIFY-PROCEED
		    (LET* ((IMMEDIATE (EQ RECLAIM :IMMEDIATE))
			   (COMMITTED (IF IMMEDIATE IMMEDIATE-COMMITTED COMMITTED)))
		     (TV:NOTIFY NIL
		      "GC is proceeding even though there may be insufficient address space.~@
		       There are ~:D words of free space available.~@
		       This ~:[incremental~;immediate~] garbage collection could require ~
		       up to ~:D words (~D%)."
		      AVAILABLE IMMEDIATE COMMITTED (// (* COMMITTED 100.) AVAILABLE))
		     T))
		   ((:ABORT :NOTIFY) NIL)
		   (OTHERWISE			; :ERROR
		    (CL:CERROR "Proceed with the garbage collection"
		      (IF (EQ RECLAIM :IMMEDIATE)
			  "Attempt to flip with insufficient address space available.
			   There are ~:D words of free space available, but doing an~2*~@
			   immediate garbage collection could require up to ~
			   ~:D words (~D%)."
			  "Attempt to flip with insufficient address space available.
			   There are ~:D words of free space available, but doing an~@
			   incremental garbage collection could require up to ~
			   ~:D words (~D%).~@
			   ~:\SI:GC-COMMAND\ would require up to ~:D words (~D%).")
		      AVAILABLE COMMITTED (// (* COMMITTED 100.) AVAILABLE)
		      '(COM-START-GC :IMMEDIATELY)
		      IMMEDIATE-COMMITTED (// (* IMMEDIATE-COMMITTED 100.) AVAILABLE))
		    T)))
	     (MULTIPLE-VALUE-BIND (DYNAMIC-SIZE STATIC-SIZE FREE-SIZE)
		 (GC-GET-SPACE-SIZES AREA-MASK REGION-MASK)
	       (WHEN GC-REPORTS-ENABLE
		 ;;--- "Partial" is not always right here, especially in IMMEDIATE-GC.
		 ;;--- This notice should say how much is being flipped.
		 (GC-REPORT
		   "GC: ~:[~;Partial ~]Dynamic GC started.  ~
		    Dynamic space=~:D, Static space=~:D, Free space=~:D"
		   (OR AREA-MASK REGION-MASK) DYNAMIC-SIZE STATIC-SIZE FREE-SIZE))
	       ;; Perform whatever actions other programs need to do on flips
	       (LET ((*DYNAMIC-GC-FLIP-ARGS* REST))
		 (INITIALIZATIONS 'BEFORE-DYNAMIC-GC-LIST T)
		 (EVALUATE-GC-LIST 'GC-EVERY-FLIP-LIST GC-EVERY-FLIP-LIST)
		 (EVALUATE-GC-LIST 'GC-NEXT-FLIP-LIST
				   (PROG1 GC-NEXT-FLIP-LIST
					  (SETQ GC-NEXT-FLIP-LIST GC-SECOND-NEXT-FLIP-LIST
						GC-SECOND-NEXT-FLIP-LIST NIL))))
	       (COND ((WITHOUT-INTERRUPTS
			;; Hack AREA-MIGRATION-ARRAY here, since GC-FLIP-INTERNAL doesn't.
			(WITH-DATA-STACK
			  (WHEN AREA-MIGRATION-ARRAY
			    (UNLESS REGION-MIGRATION-ARRAY
			      (SETQ REGION-MIGRATION-ARRAY (MAKE-STACK-ARRAY (N-REGIONS))))
			    (LOOP FOR AREA BELOW (N-AREAS)
				  AS AREA-MIGRATION = (AREF AREA-MIGRATION-ARRAY AREA)
				  WHEN AREA-MIGRATION
				    DO (DO-AREA-REGIONS (REGION AREA)
					 (UNLESS (AREF REGION-MIGRATION-ARRAY REGION)
					   (SETF (AREF REGION-MIGRATION-ARRAY REGION)
						 AREA-MIGRATION)))))
			  ;; Make sure it is really okay to flip
			  (GC-WAIT-UNTIL-FLIP-OKAY)
			  ;; Now flip unless someone else did first
			  (WHEN (AND %GC-FLIP-READY GC-RECLAIMED-OLDSPACE)
			    (GC-FLIP-INTERNAL :DYNAMIC AREA-MASK REGION-MASK LEVEL-MASK
					      REGION-MIGRATION-ARRAY LEVEL-MIGRATION-ARRAY
					      REORDERINGS INCREMENTAL-REORDERINGS
					      BLOCK-TRANSPORT-REGION-MASK))))
		      (SETQ LAST-GC-WARNING-WORDS NIL)
		      (SETQ LAST-GC-IMMEDIATELY-WARNING-WORDS NIL)
		      (WAKEUP-GC-PROCESS))
		     (T (GC-REPORT "Partial Dynamic GC performed no work.")
			(SETQ TEMP T)))
	       (WHEN (AND REORDERINGS
			  (PLUSP (ARRAY-ACTIVE-LENGTH *REORDER-DIDNT-TRANSPORT*)))
		 (GC-REPORT "Warning:  GC failed to properly reorder some objects.~@
			     The array ~S contains a vector of some of those objects."
			    '*REORDER-DIDNT-TRANSPORT*))
	       ;; Perform whatever actions other programs need to do on flips
	       (LET ((*DYNAMIC-GC-FLIP-ARGS* REST))
		 (EVALUATE-GC-LIST 'GC-AFTER-FLIP-LIST GC-AFTER-FLIP-LIST))
	       (RETURN-FROM DYNAMIC-GC-FLIP
		 (COND (TEMP NIL)
		       ((EQ RECLAIM :IMMEDIATE) :IMMEDIATE)
		       (T :INCREMENTAL)))))
	    ((EQ RECLAIM :PREFER-INCREMENTAL)
	     (WHEN (EQ INSUFFICIENT-ADDRESS-SPACE-ACTION :NOTIFY)
	       (TV:NOTIFY NIL
			  "There are ~:D words of free space available, but doing an incremental
dynamic garbage collection could require up to ~:D words (~D%).
An immediate GC is being attempted instead, which could require up to ~:D words (~D%).
Use the ~\SI:GC-COMMAND\ command for more information."
			  AVAILABLE COMMITTED (// (* COMMITTED 100.) AVAILABLE)
			  IMMEDIATE-COMMITTED (// (* IMMEDIATE-COMMITTED 100.) AVAILABLE)
			  `(COM-SHOW-GC-STATUS)))
	     (SETQ RECLAIM :IMMEDIATE)
	     (GO RETRY))
	    ((EQ INSUFFICIENT-ADDRESS-SPACE-ACTION :NOTIFY)
	     (TV:NOTIFY NIL
			"There are ~:D words of free space available, but doing an incremental
dynamic garbage collection could require up to ~:D words (~D%).
Perform the ~:\SI:GC-COMMAND\ command if you want to risk doing it anyway, or
try ~:\SI:GC-COMMAND\, which could require up to ~:D words (~D%).
Use the ~\SI:GC-COMMAND\ command for more information."
			AVAILABLE COMMITTED (// (* COMMITTED 100.) AVAILABLE)
			`(COM-START-GC :DYNAMIC ) `(COM-START-GC :IMMEDIATELY )
			IMMEDIATE-COMMITTED (// (* IMMEDIATE-COMMITTED 100.) AVAILABLE)
			`(COM-SHOW-GC-STATUS))
	     NIL)))))

(DEFUN EPHEMERAL-GC-FLIP (&OPTIONAL EPHEMERAL-LEVEL-MASK)
  (WHEN NESTED-INHIBIT-GC-FLIPS-FLAG
    (FERROR "You cannot call EPHEMERAL-GC-FLIP inside an INHIBIT-GC-FLIPS"))
  (UNLESS %GC-FLIP-READY (GC-RECLAIM-OLDSPACE))	;In case not reclaimed already
  ;; Perform whatever actions other programs need to do on flips
  (EVALUATE-GC-LIST 'GC-EVERY-FLIP-LIST GC-EVERY-FLIP-LIST)
  (EVALUATE-GC-LIST 'GC-NEXT-FLIP-LIST
		    (PROG1 GC-NEXT-FLIP-LIST
			   (SETQ GC-NEXT-FLIP-LIST GC-SECOND-NEXT-FLIP-LIST
				 GC-SECOND-NEXT-FLIP-LIST NIL)))
  (WHEN
    (WITHOUT-INTERRUPTS
      ;; Make sure it is really okay to flip
      (GC-WAIT-UNTIL-FLIP-OKAY EPHEMERAL-LEVEL-MASK)
      ;; Now flip unless someone else did first
      (WHEN (AND %GC-FLIP-READY GC-RECLAIMED-OLDSPACE)
	(WITH-LEVEL-MASK-ARRAY (MASK (OR EPHEMERAL-LEVEL-MASK (LEVELS-TO-FLIP)))
	  (GC-FLIP-INTERNAL :EPHEMERAL NIL NIL MASK NIL NIL NIL NIL NIL))
	;; Note well: do not set LAST-GC-WARNING-WORDS and LAST-GC-IMMEDIATELY-WARNING-WORDS
	;; to NIL here.  Only the dynamic GC should reinitialize the state of the "you
	;; need to turn the GC on" warnings.  If the ephemeral GC did this, it would
	;; cause annoying useless warnings as the amount of free space goes up and down
	;; near the threshold for gc-immediately.  By not resetting the state, we get
	;; the warnings only if the amount of free space goes continuously down.
	))
    ;; Get to here with interrupts enabled again if we actually did flip.
    (WAKEUP-GC-PROCESS)
    ;; Report what levels we just flipped, showing relative levels numbers
    ;; within areas rather than the meaningless-to-the-user absolute level numbers.
    ;; Don't worry about reporting flipping of unassigned levels.
    ;; Cannot easily do this before flipping, so report may take a little
    ;; while to come out, unlike the dynamic GC's report.  Too bad.
    (WHEN GC-EPHEMERAL-REPORTS-ENABLE
      (GC-REPORT "GC: Flip~VQ." (EPHEMERAL-OLDSPACE-LEVEL-MASK)
		 #'(LAMBDA (MASK)
		     (LOOP FOR (AREA TOP-LEVEL) IN *EPHEMERAL-AREAS* WITH FLAG = NIL
			   ;; How many levels of this area are being flipped
			   AS N = (LOOP FOR LEVEL = TOP-LEVEL
					      THEN (AREF *EPHEMERAL-GC-KEEP-NEXT-LEVEL* LEVEL)
					WHILE (EPHEMERAL-LEVEL-P LEVEL)
					COUNT (CL:LOGTEST (ROT 1 LEVEL) MASK))
			   DO
		       (WHEN (> N 0)
			 ;; Comma between areas
			 (IF FLAG
			     (SEND FORMAT:*FORMAT-OUTPUT* :TYO #/,)
			     (SETQ FLAG T))
			 ;; Report the levels in this area
			 (LOOP FOR LEVEL = TOP-LEVEL THEN (AREF *EPHEMERAL-GC-KEEP-NEXT-LEVEL*
								LEVEL)
			       WITH DONE = 0
			       WHILE (< DONE N)
			       FOR ORDINAL FROM 1 DO
			   (WHEN (CL:LOGTEST (ROT 1 LEVEL) MASK)
			     (WHEN (> DONE 0)
			       (WHEN (> N 2)
				 (SEND FORMAT:*FORMAT-OUTPUT* :TYO #/,))
			       (WHEN (= DONE (1- N))
				 (SEND FORMAT:*FORMAT-OUTPUT* :STRING-OUT " and")))
			     (FORMAT FORMAT:*FORMAT-OUTPUT* " ~:R" ORDINAL)
			     (INCF DONE)))
			 (FORMAT FORMAT:*FORMAT-OUTPUT* " ephemeral level~P of ~A"
				 N AREA))))))
    ;; Perform whatever actions other programs need to do on flips
    (EVALUATE-GC-LIST 'GC-AFTER-FLIP-LIST GC-AFTER-FLIP-LIST)
    T))

;;; Immediately perform an ephemeral garbage collection of the specified area
;;; :ALL-LEVELS is true to GC all levels, false to GC just the first level
;;; :MODE controls migration from ephemeral space to dynamic space
;;; Returns T if it flips, NIL if it doesn't
(DEFUN EPHEMERAL-GC-FLIP-AREA (AREA &KEY (ALL-LEVELS NIL)
					 (MODE *EPHEMERAL-MIGRATION-MODE*))
  (CHECK-ARG AREA (OR (AND (SYMBOLP AREA) (CL:MEMBER AREA AREA-LIST))
		      (AND (FIXNUMP AREA) ( 0 AREA) (< AREA (N-AREAS))))
	     "an area name or an area number")
  (WHEN (SYMBOLP AREA) (SETQ AREA (CL:POSITION AREA AREA-LIST)))
  (CL:CHECK-TYPE MODE (CL:MEMBER :NORMAL :DYNAMIC :KEEP :COLLECT :EXTRA))
  (LET ((EPHEMERAL-LEVEL-MASK 0))
    (IF ALL-LEVELS
	(DO-AREA-REGIONS (REGION AREA)
	  (LET* ((BITS (REGION-BITS REGION))
		 (LEVEL (LDB %%REGION-LEVEL BITS))
		 (SPACE (LDB %%REGION-SPACE-TYPE BITS)))
	    (WHEN (AND (EPHEMERAL-LEVEL-P LEVEL)
		       (OR (= SPACE %REGION-SPACE-NEW)
			   (= SPACE %REGION-SPACE-COPY)))
	      (SETQ EPHEMERAL-LEVEL-MASK (LOGIOR (ROT 1 LEVEL) EPHEMERAL-LEVEL-MASK)))))
	(LET ((LEVEL (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA))))
	  (WHEN (EPHEMERAL-LEVEL-P LEVEL)
	    (SETQ EPHEMERAL-LEVEL-MASK (ROT 1 LEVEL)))))
    (IF (ZEROP EPHEMERAL-LEVEL-MASK)
	(UNLESS (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA)))
	  (ERROR "~S is not an ephemeral area" (AREA-NAME AREA)))
	(LET ((*EPHEMERAL-MIGRATION-MODE* MODE))
	  (EPHEMERAL-GC-FLIP EPHEMERAL-LEVEL-MASK)))))

;;; Assume for top-level command description.
;;; With a colon, doesn't allow sensitive inferiors.
;;; Use ~\gc-command\ with things like '(com-start-gc :immediately)
;;; to get things printed as "Start GC :Immediately" but sensitive
;;; as "Start GC :Immediately Yes"
(format:defformat gc-command (:one-arg) (command ignore)
  (let ((real-command (apply 'cp:build-command command)))
    (dw:with-output-as-presentation (:type 'cp:command
				     :object real-command
				     :stream format:*format-output*)
      (present command 'cp:command :stream format:*format-output*
	       :acceptably :very
	       :for-context-type 'cp:command-or-form
	       :allow-sensitive-inferiors (not format:colon-flag)))))

;;; This must be called without-interrupts and only from one of the two flip routines above.
(DEFUN GC-WAIT-UNTIL-FLIP-OKAY (&OPTIONAL EPHEMERAL)
  (LET ((FLAG NIL))
    (LOOP WITH START-TIME = (TIME)
	  FOR INTERVAL = GC-FLIP-INHIBIT-TIME-UNTIL-WARNING THEN (* INTERVAL 2)
	  DO (COND ((NOT (ZEROP GC-FLIP-INHIBIT))
		    ;; Cause any processes that try to inhibit flipping to
		    ;; defer while the ones that have already inhibited
		    ;; flipping finish up what they are doing.
		    (DOLIST (P PROCESS:*ALL-PROCESSES*)
		      (SETF (PROCESS-DEFERENCE P) NIL))
		    (SETQ GC-FLIP-WAITING CURRENT-PROCESS)
		    ;; It works to process-wait inside this without-interrupts,
		    ;; as long as inhibit-scheduling-flag remains set
		    ;; when our stack group resumes.
		    (PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION "Flip Inhibited" 0.25
		      #'(LAMBDA (START-TIME INTERVAL)
			  (OR (ZEROP GC-FLIP-INHIBIT)
			      (TIME-ELAPSED-P INTERVAL START-TIME)))
		      (TIME) INTERVAL)
		    (UNLESS (ZEROP GC-FLIP-INHIBIT)
		      (LET ((PROCESSES '()))
			(PROCESS:MAP-OVER-ACTIVE-PROCESSES
			  (LAMBDA (P)
			    (LET ((SG (PROCESS-STACK-GROUP P)))
			      (WHEN (AND (CL:TYPEP SG 'STACK-GROUP)
					 (SYMEVAL-IN-STACK-GROUP 'NESTED-INHIBIT-GC-FLIPS-FLAG
								 SG))
				(PUSH P PROCESSES)))))
			(TV:NOTIFY NIL "Warning:  GC is waiting to flip, but flipping ~
					has been inhibited for ~\TIME-INTERVAL\.~
					~@[~%Flipping is being inhibited by ~{~A~^, ~}.~]"
				   (// (TIME-DIFFERENCE (TIME) START-TIME) 60.)
				   PROCESSES))
		      (SETQ FLAG T)))
		   ((WIRED-DYNAMIC-SPACE-P EPHEMERAL)
		    ;; Since WIRED-DYNAMIC-SPACE-P is such a PIG, don't call
		    ;; it from the scheduler
		    (LOOP REPEAT (// INTERVAL 60.)
			  AS ADDR = (WIRED-DYNAMIC-SPACE-P EPHEMERAL)
			  DO (UNLESS ADDR (RETURN))
			     (CL:SLEEP 1 :SLEEP-REASON "Wired dynamic space wait")
			  FINALLY
			    (TV:NOTIFY NIL "Warning:  GC is waiting to flip, but ~
					    the existence of wired dynamic space~@
					    ~@? has inhibited flipping ~
					    for the past ~\TIME-INTERVAL\."
				       #-VLM "at ~\SI:ADDRESS\ in ~S"
				       #+VLM "~2*"
				       ADDR (AREA-NAME (%AREA-NUMBER ADDR))
				       (// (TIME-DIFFERENCE (TIME) START-TIME) 60.))
			    (SETQ FLAG T)))
		   (T (RETURN))))
    (SETQ GC-FLIP-WAITING NIL)
    (WHEN FLAG
      (TV:NOTIFY NIL "GC: Finished waiting to flip."))))

(DEFUN EVALUATE-GC-LIST (LIST-NAME LIST)
  (LOOP NAMED DAVID-KAUFMAN FOR FORM IN LIST DO
    (CONDITION-CASE (ERROR)
	 (EVAL FORM)
       (ERROR (TV:NOTIFY NIL "Error processing ~S:~%~4@T~~A~" LIST-NAME ERROR)))))

;; Compatibility and testing
(COMPILER:MAKE-OBSOLETE GC-FLIP-NOW "use SI:DYNAMIC-GC-FLIP")
(DEFUN GC-FLIP-NOW (&OPTIONAL (RATIO GC-FLIP-RATIO) NO-QUERY MAYBE-RECLAIM-IMMEDIATELY)
  (DECLARE (IGNORE MAYBE-RECLAIM-IMMEDIATELY))
  (DYNAMIC-GC-FLIP :RATIO RATIO
		   :RECLAIM (IF GC-RECLAIM-IMMEDIATELY :IMMEDIATE :INCREMENTAL)
		   :INSUFFICIENT-ADDRESS-SPACE-ACTION (CL:ECASE NO-QUERY
							((T) :PROCEED)
							((NIL) :QUERY)
							((:NOTIFY) :NOTIFY))))

(COMPILER:MAKE-OBSOLETE GC-FLIP-EPHEMERAL-SPACES-NOW "use SI:EPHEMERAL-GC-FLIP")
(DEFUN GC-FLIP-EPHEMERAL-SPACES-NOW (&REST LEVELS)
  (EPHEMERAL-GC-FLIP (IF (NULL LEVELS)
			 NIL
			 (LOOP WITH LEVEL-MASK = 0
			       FOR LEVEL IN LEVELS
			       DO (SETQ LEVEL-MASK (LOGIOR (ROT 1 LEVEL) LEVEL-MASK))
			       FINALLY (RETURN LEVEL-MASK)))))


;;; Free Space and Work Calculations

;;; If called when %GC-FLIP-READY is true, returns a conservative (over) estimate of
;;; the amount of free space which will be used up during the next cycle before
;;; %GC-FLIP-READY can set again.  This is based on the way consing drives scavenging.
;;; Also returns the current amount of free space since it happens to know it.

;;; In the below, the size of static and dynamic spaces are at the time of the flip,
;;; which is bigger than the current values.  The objective is to compute how much
;;; bigger they can be allowed to grow.

;;; Total scavenger work = amount of static space to be scavenged
;;;			   + 2 x dynamic space (which is both scavenged and copied)
;;;			   + scavenging of static space consed after the flip
;;;				[dynamic space consed after the flip is newspace
;;;				 rather than copyspace and need not be scavenged]
;;; Total consing (consumption of free space) =
;;;			(1/K) x scav work
;;;			+ amount of dynamic space which is copied
;;;			+ region breakage
;;; K=4 in the current microcode
;;;
;;; Uncertainties which can use up more free space:
;;;	Consing after the flip in static space rather than dynamic or exited space
;;;	Region breakage
;;;	Consing during GC process wakeup delay
;;; Uncertainties which decrease consumption of free space:
;;;	Scavenging by the idle-loop rather than by CONS
;;;	Certain fixed areas which count as static space but aren't actually scavenged
;;;	Shrinkage of dynamic space (generally some is garbage and will be
;;;		neither copied nor scavenged)
;;;	Consing of additional static space before the flip, which is less
;;;		expensive than additional dynamic space.
;;;	Space already assigned to regions but not yet allocated by CONS
;;;
;;; For maximum delay of flipping, we want to allow enough consing before the
;;; flip so that the remaining free space is exactly equal to the consing after
;;; the flip.  The algebraic manipulation is as follows (incorporating the
;;; worst case assumptions: no garbage, all consing before flip is dynamic,
;;; all consing after flip is static).  Normally I wouldn't bother commenting
;;; this but several people have got it wrong, so it must be hard.
;;;	F0 = free space now
;;;	D0 = dynamic space now
;;;	ND = additional dynamic space consed before the flip
;;;	S0 = static space now
;;;	W  = scavenger work to do after the flip
;;;	C  = consing required after the flip.
;;;
;;; C = D0 + ND + W/k		;copy all dynamic plus do necessary scavenger work
;;; W = S0 + 2(D0 + ND) + W/k	;scav static, scav and copy all dynamic, scav new static
;;; F0 = ND + C			;free space divided between before & after consing
;;; 
;;; (k-1)W = k S0 + 2k D0 + 2k ND	;solving for W
;;; C = D0 + ND + (S0 + 2 D0 + 2 ND)/(k-1)	;plugging W into C's equation
;;; C = (k+1)D0/(k-1) + S0/(k-1) + (k+1)(F0-C)/(k-1)	;plugging in ND
;;; 2kC = (k+1)(D0+F0) + S0		;solving for C
;;;
;;; Note that old-space is counted as dynamic, i.e. we assume that none of it is garbage.
;;; Third value is the amount of free space necessary in order to do
;;; a non-incremental GC.  The difference is that scavenging and copying are "free"
;;; rather than being driven by consing.

;; This can cons and return bignums!
(DEFUN GC-GET-COMMITTED-FREE-SPACE ( &OPTIONAL AREA-MASK REGION-MASK
				     &AUX (K 4) )	;K is the magic constant
  (DECLARE (VALUES COMMITTED-FREE-SPACE FREE-SPACE IMMEDIATE-COMMITTED-FREE-SPACE))
  (MULTIPLE-VALUE-BIND (DYNAMIC-SIZE STATIC-SIZE FREE-SIZE OLD-SIZE)
	(GC-GET-SPACE-SIZES AREA-MASK REGION-MASK)
    (LET ((CONSING ;Amount of space committed before next flip could complete
		   (// (+ (* (+ K 1) (+ DYNAMIC-SIZE OLD-SIZE FREE-SIZE)) STATIC-SIZE)
		       (* 2 K)))
	  (IMMEDIATE ;Amount of space needed in non-incremental mode
		     (+ DYNAMIC-SIZE		;Assume all this will need to be copied
			(MULTIPLE-VALUE-BIND (NIL MORE-DYNAMIC)	;and this
			    (GET-MAX-GC-WORK-REMAINING)
			  MORE-DYNAMIC))))
      (INCF IMMEDIATE (// (- FREE-SIZE IMMEDIATE) 2))	;Copying of stuff consed before flip
      (VALUES (+ (IF GC-RECLAIM-IMMEDIATELY IMMEDIATE CONSING)
		 1000000)			;add 256K as a fudge for region breakage
	      FREE-SIZE
	      (+ IMMEDIATE 1000000)))))		; (+ fudge factor)

;;; Free space available for consing before we must flip
;;; This can return a bignum!
(DEFUN GC-GET-UNCOMMITTED-FREE-SPACE ()
  (MULTIPLE-VALUE-BIND (COMMITTED-FREE-SPACE FREE-SPACE)
      (GC-GET-COMMITTED-FREE-SPACE)
    ;;Hook to let the user influence how conservative the garbage
    ;;collector will be.  GC-FLIP-RATIO may be a flonum.
    (VALUES (ROUND (- FREE-SPACE (+ (* GC-FLIP-RATIO COMMITTED-FREE-SPACE)
				    GC-DELTA))))))

;;; The number of words now waiting to be scavenged.
;;; More data may appear and need to be scavenged before we are finished.
;;; This can return a bignum (but it's unlikely).
(DEFUN GET-DIRECT-GC-WORK-REMAINING ()
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-FREE-POINTER REGION-GC-POINTER
				REGION-FREE-POINTER-BEFORE-FLIP)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (LOOP WITH GC-FLIP-READY = %GC-FLIP-READY
	  WITH BITS FOR REGION FROM 0 BELOW (N-REGIONS)
	  UNLESS (ZEROP (LDB %%REGION-SCAVENGE-ENABLE (SETQ BITS (REGION-BITS REGION))))
	    SUM (- (IF (OR GC-FLIP-READY
			   (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-COPY))
		       (REGION-FREE-POINTER REGION)
		       (REGION-FREE-POINTER-BEFORE-FLIP REGION))
		   (REGION-GC-POINTER REGION)))))

;;; An upper bound on the number of words to be scavenged before reclamation.
;;; The second value is the part which is not certain (u.b. minus l.b.).
;;; This can return a bignum (but it's unlikely).
(DEFUN GET-MAX-GC-WORK-REMAINING ()
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD
				REGION-BITS REGION-FREE-POINTER)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (LET ((POSSIBLE-ADDITIONAL-DATA		;Maximum amount that might yet be copied
	    (LOOP FOR AREA FROM 0 BELOW (N-AREAS)
		  SUM (LET ((OLD 0) (COPY 0))
			(DO-AREA-REGIONS (REGION AREA)
			  (SELECTOR (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION)) =
			    (%REGION-SPACE-OLD (INCF OLD (REGION-FREE-POINTER REGION)))
			    (%REGION-SPACE-COPY (INCF COPY (REGION-FREE-POINTER REGION)))))
			(MAX (- OLD COPY) 0)))))
      (VALUES (+ POSSIBLE-ADDITIONAL-DATA (GET-DIRECT-GC-WORK-REMAINING))
	      POSSIBLE-ADDITIONAL-DATA))))

;;; Maybe this should be in STORAGE?
(DEFUN COUNT-FREE-QUANTA ()
  (LET ((COUNT 0))
    #+IMach (WITH-BLOCK-REGISTERS (1 2)
	      (SETF (%BLOCK-REGISTER 2) STORAGE::*ADDRESS-SPACE-MAP-ADDRESS*)
	      (DOTIMES (IGNORE (LSH 1 (BYTE-SIZE %%VMA-ADDRESS-SPACE-MAP-HIGH)))
		(LET ((HIGH-CONTENTS (%BLOCK-READ 2 :CYCLE-TYPE %MEMORY-RAW :PREFETCH NIL)))
		  (IF (NULL HIGH-CONTENTS)
		      (INCF COUNT (DPB 1 %%QUANTUM-ADDRESS-SPACE-MAP-HIGH 0))
		    (SETF (%BLOCK-REGISTER 1) HIGH-CONTENTS)
		    (DOTIMES (IGNORE (LSH 1 (BYTE-SIZE %%VMA-ADDRESS-SPACE-MAP-LOW)))
		      (LET ((A (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-RAW
					      :FIXNUM-ONLY T :PREFETCH NIL)))
			(WHEN (LDB-TEST (BYTE 1 15.) A) (INCF COUNT))
			(WHEN (LDB-TEST (BYTE 1 31.) A) (INCF COUNT))))))))
    #+3600 (LET ((ASM *ADDRESS-SPACE-MAP*))
	     (DECLARE (ARRAY-REGISTER ASM))
	     (LOOP FOR I BELOW %NUMBER-OF-VIRTUAL-QUANTA
		   WHEN (NOT (REGION-VALID-P (AREF ASM I)))
		     DO (INCF COUNT)))
    COUNT))

;;; Compute total occupation of dynamic space, static space, free space,
;;; and old space.  Note that space allocated to dynamic areas but not
;;; yet consed counts as free space, because a flip will return it
;;; (except for quantum breakage).  This is handled in GET-FREE-SPACE-SIZE
;;; not in GC-GET-SPACE-SIZES because unlike the A-machine we worry about
;;; disk space allocation separately from address space allocation.
;;; Space allocated to nonadjustable regions but not yet consed is not counted at
;;; all, because it can't be reclaimed and we don't know whether anyone
;;; will ever want to cons in that particular area.
;;;
;;; If the mask arguments are given, then those regions which fail the mask arguments
;;; are counted as static space rather than dynamic space.  So what this returns
;;; is valid numbers for a flip with the given mask.
;;;
;;; Any of the values returned here can be bignums.
;;;--- This needs to take a LEVEL-MASK as well.  Update the callers.
(DEFUN GC-GET-SPACE-SIZES (&OPTIONAL AREA-MASK REGION-MASK)
  (DECLARE (VALUES DYNAMIC-SIZE STATIC-SIZE FREE-SIZE OLD-SIZE))
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD
				#+3600 REGION-QUANTUM-LENGTH REGION-FREE-POINTER REGION-BITS
				LEVEL-TYPE)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (LET ((SWAP-SPACE-AVAILABLE (DPB *COUNT-REMAINING-SWAP-PAGES* %%VMA-PAGE-NUM 0)))
      (LOOP WITH SZ
	    WITH DYNAMIC-SIZE = 0
	    WITH STATIC-SIZE = 0
	    WITH FREE-QUANTA = (COUNT-FREE-QUANTA)
	    WITH OLD-SIZE = 0
	    FINALLY (RETURN (VALUES DYNAMIC-SIZE STATIC-SIZE
				    ;; Try to save some consing for the common case.
				    (IF ( (LDB %%VMA-QUANTUM-NUM SWAP-SPACE-AVAILABLE)
					   FREE-QUANTA)
					;; Still have to do MIN here...
					(MIN SWAP-SPACE-AVAILABLE
					     (* FREE-QUANTA %ADDRESS-SPACE-QUANTUM-SIZE))
					SWAP-SPACE-AVAILABLE)
				    OLD-SIZE))
	    FOR AREA BELOW (N-AREAS) DO
	(DO-AREA-REGIONS (REGION AREA)
	  (LET ((BITS (REGION-BITS REGION)))
	    #+3600 (WHEN (LDB-TEST %%REGION-ADJUSTABLE-SIZE REGION)
		     (INCF FREE-QUANTA (- (REGION-QUANTUM-LENGTH REGION)
					  (%FIXNUM-CEILING (REGION-FREE-POINTER REGION)
							   %ADDRESS-SPACE-QUANTUM-SIZE))))
	    (SETQ SZ (REGION-FREE-POINTER REGION))
	    (SELECTOR (LDB %%REGION-SPACE-TYPE BITS) =
	      ((%REGION-SPACE-NEW %REGION-SPACE-COPY)
	       (IF (AND (OR (NULL AREA-MASK) (AREF AREA-MASK AREA))
			(OR (NULL REGION-MASK) (AREF REGION-MASK REGION))
			( (LEVEL-TYPE (LDB %%REGION-LEVEL BITS)) %LEVEL-TYPE-DYNAMIC))
		   (INCF DYNAMIC-SIZE SZ)
		   (INCF STATIC-SIZE SZ)))
	      (%REGION-SPACE-OLD
	       (INCF OLD-SIZE SZ))
	      (OTHERWISE ;Stacks
	       (INCF STATIC-SIZE SZ)))))))))

;;--- Make callers use this.
(DEFUN GC-GET-LEVEL-SIZES (&OPTIONAL AREA-MASK REGION-MASK
				     LEVEL-NEW-SIZE LEVEL-COPY-SIZE LEVEL-OLD-SIZE)
  (DECLARE (VALUES LEVEL-NEW-SIZE LEVEL-COPY-SIZE LEVEL-OLD-SIZE FREE-SIZE))
  (UNLESS LEVEL-NEW-SIZE
    (SETQ LEVEL-NEW-SIZE (MAKE-ARRAY %NUMBER-OF-LEVELS :INITIAL-VALUE 0)))
  (UNLESS LEVEL-COPY-SIZE
    (SETQ LEVEL-COPY-SIZE (MAKE-ARRAY %NUMBER-OF-LEVELS :INITIAL-VALUE 0)))
  (UNLESS LEVEL-OLD-SIZE
    (SETQ LEVEL-OLD-SIZE (MAKE-ARRAY %NUMBER-OF-LEVELS :INITIAL-VALUE 0)))
  (LET ((FREE-QUANTA (COUNT-FREE-QUANTA))
	(SWAP-SPACE-AVAILABLE (DPB *COUNT-REMAINING-SWAP-PAGES* %%VMA-PAGE-NUM 0))
	(LEVEL-NEW-SIZE LEVEL-NEW-SIZE)
	(LEVEL-COPY-SIZE LEVEL-COPY-SIZE)
	(LEVEL-OLD-SIZE LEVEL-OLD-SIZE))
    (DECLARE (ARRAY-REGISTER LEVEL-NEW-SIZE LEVEL-COPY-SIZE LEVEL-OLD-SIZE))
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD
				  #+3600 REGION-QUANTUM-LENGTH REGION-FREE-POINTER REGION-BITS)
      (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
      (LOOP FOR AREA BELOW (N-AREAS) DO
	(WHEN (OR (NULL AREA-MASK) (AREF AREA-MASK AREA))
	  (DO-AREA-REGIONS (REGION AREA)
	    (WHEN (OR (NULL REGION-MASK) (AREF REGION-MASK REGION))
	      (LET* ((BITS (REGION-BITS REGION))
		     (LEVEL (LDB %%REGION-LEVEL BITS))
		     (SZ (REGION-FREE-POINTER REGION)))
		#+3600 (WHEN (LDB-TEST %%REGION-ADJUSTABLE-SIZE REGION)
			 (INCF FREE-QUANTA (- (REGION-QUANTUM-LENGTH REGION)
					      (%FIXNUM-CEILING (REGION-FREE-POINTER REGION)
							       %ADDRESS-SPACE-QUANTUM-SIZE))))
		(SELECTOR (LDB %%REGION-SPACE-TYPE BITS) =
		  (%REGION-SPACE-COPY (INCF (AREF LEVEL-COPY-SIZE LEVEL) SZ))	  ;Copy
		  (%REGION-SPACE-OLD  (INCF (AREF LEVEL-OLD-SIZE LEVEL) SZ))	  ;Old
		  (OTHERWISE	      (INCF (AREF LEVEL-NEW-SIZE LEVEL) SZ))))))));New & Stacks
      (VALUES LEVEL-NEW-SIZE LEVEL-COPY-SIZE LEVEL-OLD-SIZE
	      ;; Try to save some consing for the common case.
	      (IF ( (LDB %%VMA-QUANTUM-NUM SWAP-SPACE-AVAILABLE) FREE-QUANTA)
		  ;; Still have to do MIN here...
		  (MIN (* FREE-QUANTA %ADDRESS-SPACE-QUANTUM-SIZE) SWAP-SPACE-AVAILABLE)
		  SWAP-SPACE-AVAILABLE)))))

;;--- This shows %PERMANENT-AREA being mostly copyspace.  Fix that??
(DEFUN SHOW-LEVEL-SIZES (&OPTIONAL AREA-MASK REGION-MASK
			 &AUX (TYPE-NEW 0) (TYPE-COPY 0) (TYPE-OLD 0)
			      (TOTAL-NEW 0) (TOTAL-COPY 0) (TOTAL-OLD 0))
  (STACK-LET ((LEVEL-NEW-SIZE (MAKE-ARRAY %NUMBER-OF-LEVELS :INITIAL-VALUE 0))
	      (LEVEL-COPY-SIZE (MAKE-ARRAY %NUMBER-OF-LEVELS :INITIAL-VALUE 0))
	      (LEVEL-OLD-SIZE (MAKE-ARRAY %NUMBER-OF-LEVELS :INITIAL-VALUE 0)))
    (MULTIPLE-VALUE-BIND (NIL NIL NIL FREE-SIZE)
	(GC-GET-LEVEL-SIZES AREA-MASK REGION-MASK
			    LEVEL-NEW-SIZE LEVEL-COPY-SIZE LEVEL-OLD-SIZE)
      (FORMAT T "~%~26T~'i   Newspace     Copyspace      Oldspace~")
      (LOOP FOR TYPE FROM (1+ %LEVEL-TYPE-UNALLOCATED) TO %LEVEL-TYPE-EPHEMERAL DO
	(SETQ TYPE-NEW 0 TYPE-COPY 0 TYPE-OLD 0)
	(LOOP FOR LEVEL BELOW %NUMBER-OF-LEVELS
	      WHEN (= (LEVEL-TYPE LEVEL) TYPE)
		DO (LET ((NEW (AREF LEVEL-NEW-SIZE LEVEL))
			 (COPY (AREF LEVEL-COPY-SIZE LEVEL))
			 (OLD (AREF LEVEL-OLD-SIZE LEVEL)))
		     (INCF TYPE-NEW NEW)
		     (INCF TYPE-COPY COPY)
		     (INCF TYPE-OLD OLD)
		     (FORMAT T "~%  ~\SI:LEVEL\~26T~11:D   ~11:D   ~11:D"
			     LEVEL NEW COPY OLD)))
	(FORMAT T "~%  ~'iTotal ~\SI:LEVEL-TYPE\~~26T~11:D   ~11:D   ~11:D~%"
		TYPE TYPE-NEW TYPE-COPY TYPE-OLD)
	(INCF TOTAL-NEW TYPE-NEW)
	(INCF TOTAL-COPY TYPE-COPY)
	(INCF TOTAL-OLD TYPE-OLD))
      (FORMAT T "~%  ~'iGrand Total~~26T~11:D   ~11:D   ~11:D"
	      TOTAL-NEW TOTAL-COPY TOTAL-OLD)
      (FORMAT T "~%  ~'iFree Space~~26T~11:D" FREE-SIZE))))

(DEFUN NUMBER-OF-FREE-REGIONS ()
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS)
    (+ (LOOP FOR REGION BELOW (N-REGIONS)
	     COUNT (ZEROP (REGION-BITS REGION)))
       (- NUMBER-OF-REGIONS (N-REGIONS)))))

;;; Oldspace Flushing

(DEFVAR *INSIDE-GC-RECLAIM-OLDSPACE* NIL)

;;; This function gets rid of oldspace.
(DEFUN GC-RECLAIM-OLDSPACE ()
  (LET ((*INSIDE-GC-RECLAIM-OLDSPACE* T))
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST AREA-NAME AREA-REGION-BITS
				  REGION-LIST-THREAD REGION-BITS REGION-FREE-POINTER
				  REGION-FREE-POINTER-BEFORE-FLIP)
      ;; Make sure all regions are clean (no pointers to oldspace)
      (%GC-SCAVENGE)
      ;; First process reaching here reports oldspace statistics
      ;; Need to be without interrupts when we go into this state, and we need to
      ;; stay that way long enough to collect the reporting information.
      (LET ((DATA
	      (WITHOUT-INTERRUPTS
		(WHEN (AND (NOT GC-RECLAIMED-OLDSPACE)
			   (STORE-CONDITIONAL (VARIABLE-LOCATION GC-RECLAIM-OLDSPACE-REPORTED)
					      NIL T))
		  (LOOP FOR REGION BELOW (N-REGIONS)
			AS SPACE = (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
			WHEN (= SPACE %REGION-SPACE-OLD)
			  SUM (REGION-FREE-POINTER REGION) INTO OLD-SIZE
			WHEN (= SPACE %REGION-SPACE-COPY)
			  SUM (- (REGION-FREE-POINTER REGION)
				 (REGION-FREE-POINTER-BEFORE-FLIP REGION)) INTO COPY-SIZE
			FINALLY
			  (INCF TOTAL-OLDSPACE-RECLAIMED OLD-SIZE)
			  ;; Report to user if enabled.  Which variable to look at depends on
			  ;; which garbage collector evacuated this oldspace.
			  (WHEN (IF *EPHEMERAL-GC-IN-PROGRESS* GC-EPHEMERAL-REPORTS-ENABLE
				    GC-REPORTS-ENABLE)
			    (GC-REPORT "GC: Flushing oldspace.  ~:D words collected into ~:D words (~2$% reclaimed)."
				       OLD-SIZE COPY-SIZE (// (* 100.0 (- OLD-SIZE COPY-SIZE)) OLD-SIZE))))
		  (AND GC-AREA-RECLAIM-REPORT
		       (IF *EPHEMERAL-GC-IN-PROGRESS*
			   (NEQ GC-AREA-RECLAIM-REPORT ':DYNAMIC)
			   (NEQ GC-AREA-RECLAIM-REPORT ':EPHEMERAL))
		       (LOOP FOR AREA FROM 0 BELOW (N-AREAS)
			     AS COPY = 0 AS OLD = 0
			     DO (DO-AREA-REGIONS (REGION AREA)
				  (SELECT (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
				    (%REGION-SPACE-COPY
				     (INCF COPY (- (REGION-FREE-POINTER REGION)
						   (REGION-FREE-POINTER-BEFORE-FLIP REGION))))
				    (%REGION-SPACE-OLD
				     (INCF OLD (REGION-FREE-POINTER REGION)))))
			     UNLESS (ZEROP OLD)
			       NCONC (LIST (// (* (- OLD COPY) 100.) OLD)
					   (AREA-NAME AREA)
					   (- OLD COPY))))))))
	(WHEN DATA
	  (GC-REPORT "GC: ~{~D% of ~S was reclaimed (~:D words).~^~%   ~}" DATA)))

      (LET ((GENERATION %GC-GENERATION-NUMBER))
	;; Temporary bug-trapping code.
	#+IMACH (WITHOUT-INTERRUPTS
		  (WHEN (AND %GC-FLIP-READY
			     (NOT GC-RECLAIMED-OLDSPACE)
			     (= %GC-GENERATION-NUMBER GENERATION)
			     *VERIFY-NO-RESIDENT-OLDSPACE*)
		    (%FUNCALL-IN-AUX-STACK #'VERIFY-NO-RESIDENT-OLDSPACE)))
	;; Discard oldspace
	(DOTIMES (AREA (N-AREAS))
	  (GC-RECLAIM-OLDSPACE-AREA AREA GENERATION))
	(WITHOUT-INTERRUPTS
	  (WHEN (AND %GC-FLIP-READY (NOT GC-RECLAIMED-OLDSPACE)
		     (= %GC-GENERATION-NUMBER GENERATION))
	    ;; These checks should be redundant.
	    (DOTIMES (REGION (N-REGIONS))
	      (WHEN (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION)) %REGION-SPACE-OLD)
		(ERROR "GC Internal Error:  Oldspace regions exist after reclaiming oldspace")))
	    ;; Only one process in here please, even if multiple processes
	    ;; get into GC-RECLAIM-OLDSPACE-AREA.  Do this only if %GC-FLIP-READY is still
	    ;; on, that is, some other process didn't complete the GC and flip again.
	    (SETQ *EPHEMERAL-GC-IN-PROGRESS* NIL)
	    (ZERO-GC-OLDSPACE-LEVEL-MASK)
	    ;; This isn't strictly necessary.
	    #+IMACH (REINITIALIZE-OLDSPACE-REGISTERS)
	    ;; Reclaim any ephemeral level numbers no longer being used
	    (LET ((MASK 0))
	      ;; Find all levels being directly used
	      (LOOP FOR I BELOW (N-AREAS) AS BITS = (AREA-REGION-BITS I) DO
		(WHEN (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL BITS))
		  (SETQ MASK (LOGIOR MASK (ROT 1 (LDB %%REGION-LEVEL BITS))))))
	      (LOOP FOR I BELOW (N-REGIONS) AS BITS = (REGION-BITS I) DO
		(WHEN (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL BITS))
		  (SETQ MASK (LOGIOR MASK (ROT 1 (LDB %%REGION-LEVEL BITS))))))
	      (LOOP FOR (AREA TOP-LEVEL) IN *EPHEMERAL-AREAS*
		    DO (IGNORE AREA)
		       (SETQ MASK (LOGIOR MASK (ROT 1 TOP-LEVEL))))
	      ;; Take transitive closure through object propagation table
	      (LOOP FOR LEVEL BELOW %NUMBER-OF-EPHEMERAL-LEVELS
		    DO (WHEN (CL:LOGTEST (ROT 1 LEVEL) MASK)
			 (LET ((LEVEL LEVEL))
			   (LOOP DOING (SETQ LEVEL (AREF *EPHEMERAL-GC-NORMAL-NEXT-LEVEL* LEVEL))
				 WHILE (EPHEMERAL-LEVEL-P LEVEL)
				 UNTIL (CL:LOGTEST (ROT 1 LEVEL) MASK)
				 DO (SETQ MASK (LOGIOR (ROT 1 LEVEL) MASK))))
			 (LET ((LEVEL LEVEL))
			   (LOOP DOING (SETQ LEVEL (AREF *EPHEMERAL-GC-KEEP-NEXT-LEVEL* LEVEL))
				 WHILE (EPHEMERAL-LEVEL-P LEVEL)
				 UNTIL (CL:LOGTEST (ROT 1 LEVEL) MASK)
				 DO (SETQ MASK (LOGIOR (ROT 1 LEVEL) MASK))))))
	      ;; Free all levels that are not being used
	      (LOOP FOR LEVEL BELOW %NUMBER-OF-EPHEMERAL-LEVELS
		    DO (UNLESS (CL:LOGTEST (ROT 1 LEVEL) MASK)
			 (DEALLOCATE-LEVEL LEVEL NIL))))
	    ;; Now inform whomever that we've flipped.
	    (EVALUATE-GC-LIST 'GC-NEXT-RECLAIM-OLDSPACE-LIST
			      (PROG1 GC-NEXT-RECLAIM-OLDSPACE-LIST
				     (SETQ GC-NEXT-RECLAIM-OLDSPACE-LIST NIL)))
	    (EVALUATE-GC-LIST 'GC-EVERY-RECLAIM-OLDSPACE-LIST GC-EVERY-RECLAIM-OLDSPACE-LIST)
	    ;; It is now safe to flip again
	    (SETQ GC-RECLAIMED-OLDSPACE T
		  GC-RECLAIM-OLDSPACE-REPORTED NIL)
	    ;; Wake up daemon process (there is more space now)
	    (SETQ GC-DAEMON-PAGE-CONS-ALARM CL:MOST-NEGATIVE-FIXNUM)
	    T))))))

;;; GC-RECLAIM-OLDSPACE-AREA - deletes all old-space regions of a specified area,
;;; unthreading from the lists, and returning the virtual memory to free.
;;; Call this for each area, if %GC-FLIP-READY is true and before calling GC-FLIP-INTERNAL.
(DEFUN GC-RECLAIM-OLDSPACE-AREA (AREA GENERATION)
  (CHECK-ARG AREA (AND (NUMBERP AREA) ( AREA 0) (< AREA (N-AREAS)))
	     "an area number")
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD AREA-REGION-BITS
				REGION-BITS)
    (LOOP NAMED TOP DO			;Iterate with interrupts enabled over regions
      (WHEN (PLUSP GC-RECLAIM-OLDSPACE-INHIBIT)
	(PROCESS::PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION "Reclaim Oldspace Inhibited" 0.5
	  #'(LAMBDA (GENERATION)
	      (OR (ZEROP GC-RECLAIM-OLDSPACE-INHIBIT)
		  GC-RECLAIMED-OLDSPACE
		  ( %GC-GENERATION-NUMBER GENERATION)))
	  GENERATION))
      (WITHOUT-INTERRUPTS		;Prevent flipping, change of region list threads
	(UNLESS %GC-FLIP-READY		;Mustn't reclaim unless no pointers to it exist
	  (RETURN-FROM TOP NIL))
	(UNLESS (= %GC-GENERATION-NUMBER GENERATION)
	  (RETURN-FROM TOP NIL))
	(UNLESS (PLUSP GC-RECLAIM-OLDSPACE-INHIBIT)
	  (DO ((PREV-REGION NIL REGION)
	       (REGION (AREA-REGION-LIST AREA) NEXT-REGION)
	       (NEXT-REGION)
	       (AREA-BITS (AREA-REGION-BITS AREA)))
	      (NIL)
	    (UNLESS (REGION-VALID-P REGION)
	      (RETURN-FROM TOP NIL))		;No more oldspace exists
	    ;; This is here so SHORTEN-REGION can dethread empty regions.
	    (SETQ NEXT-REGION (REGION-LIST-THREAD REGION))
	    (SELECT (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
	      (%REGION-SPACE-OLD
	       (IF PREV-REGION
		   (SETF (REGION-LIST-THREAD PREV-REGION) (REGION-LIST-THREAD REGION))
		   (SETF (AREA-REGION-LIST AREA) (REGION-LIST-THREAD REGION)))
	       (%FREE-REGION REGION)
	       (INCF *GC-OLDSPACE-REGIONS-RECLAIMED*)
	       (RETURN))				;Allow a chance for an interrupt
	      (%REGION-SPACE-COPY
	       (COND ((= (LDB %%REGION-LEVEL (REGION-BITS REGION))
			 (LDB %%REGION-LEVEL AREA-BITS))
		      ;; Change to normal space type so that it can be used
		      ;; for normal consing
		      ;;--- This doesn't buy much, considering that the region allocator
		      ;;--- packed it in with no room to expand.  Maybe the region allocator
		      ;;--- should do something different.
		      (SETF (REGION-BITS REGION)
			    (%LOGDPBS (LDB %%REGION-SCAVENGE-ENABLE AREA-BITS)
				      %%REGION-SCAVENGE-ENABLE
				      (LDB %%REGION-SPACE-TYPE AREA-BITS) %%REGION-SPACE-TYPE
				      (REGION-BITS REGION))))
		     ((NOT *EPHEMERAL-GC-IN-PROGRESS*)
		      ;; This was a dynamic garbage collection, so the next flip will
		      ;; probably not be for a long time.  Leave the region set to copyspace
		      ;; so more things can be copied into it by the next garbage collection,
		      ;; but shorten it since it won't be used for quite a while.
		      ;; If this was an ephemeral garbage collection, don't shorten the region
		      ;; since we will be transporting more objects into it soon enough.
		      (SHORTEN-REGION REGION)))))))))))

;;; Scavenger

;;; This is the driver for the scavenger.  It decides which region to scavenge, and how much
;;; work the scavenger should do, then disables interrupts and calls SCAVENGE-REGION which
;;; actually does the work.  The amount of time spent with interrupts inhibited
;;; is limited to improve response.
;;; 
;;; Work-units is the number of words to scavenge, or NIL which means scavenge till done.
;;; Max-time is the maximum number of microseconds to run, or NIL which means no limit.
;;; If both of these arguments are specified, it returns when the first one goes off.
;;; 
;;; This can be called from the scheduler and also from processes, both inside of
;;; CONS and directly.  There had better be only one process running the scavenger
;;; at a time; this function takes care of the necessary interlocking, which is
;;; done with WITHOUT-INTERRUPTS to prevent users from molesting it by aborting
;;; or arresting the process, and to simplify SCAVENGE-REGION.
(DEFUN %GC-SCAVENGE (&OPTIONAL WORK-UNITS MAX-TIME CONS)
  (UNLESS %GC-FLIP-READY			;Speedup if nothing to do
    (INCF SCAVENGER-TOTAL-TIMES)
    (WHEN CONS (INCF CONS-SCAVENGE-TOTAL-TIMES))
    (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-GC-POINTER
				  REGION-FREE-POINTER REGION-FREE-POINTER-BEFORE-FLIP)
      (LOOP UNTIL				;Exit if inner loop returns T
	(WITHOUT-INTERRUPTS
	  (METER-MS-AND-PF (SCAVENGER (CONS-SCAVENGE CONS))
	    ;; Critical section begins.  Some of this isn't really critical, but it
	    ;; doesn't hurt to add a little more code to the without-interrupts,
	    ;; since most of the time will be spent in SCAVENGE-REGION anyway.
	    (SET-RUN-LIGHT SCAVENGE-RUN-LIGHT)
	    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
	    (PROG1
	     (INHIBIT-CONSING
	      (LOOP WITH *SCAVENGE-IN-PROGRESS* = T
		    WITH FOUND = NIL
		    WITH BITS = NIL
		    WITH REGION = -1
		    AS SCAVENGER-STATE = *SCAVENGER-STATE* DO
		(COND (%GC-FLIP-READY
		       (RETURN T))		;Some other process completed scavenging
		      (*GC-HYSTERESIS*
		       ;; This stronger, and will eventually replace, *SCAVENGE-REGION*
		       (SETQ REGION (GC-HYST-REGION *GC-HYSTERESIS*))
		       (POP-*GC-HYSTERESIS* REGION)	;will get pushed back later
		       (SETQ *SCAVENGE-REGION* NIL)
		       (SETQ SCAVENGER-STATE 'COPYSPACE)
		       (SETQ FOUND T))
		      (*SCAVENGE-REGION*
		       ;; If directed to start scavenging at a particular region, do so.
		       ;; The transporter could direct our attention to a region, otherwise
		       ;; this is the region that was being scavenged most recently.
		       (SETQ REGION *SCAVENGE-REGION*)
		       (SETQ *SCAVENGE-REGION* NIL)
		       (SETQ SCAVENGER-STATE 'COPYSPACE)
		       (SETQ FOUND T))
		      ((EQ SCAVENGER-STATE 'COPYSPACE)
		       ;; Just do the next region.
		       (INCF REGION)
		       (UNLESS (< REGION (N-REGIONS))
			 ;; If we looked at every region, and found no regions that could
			 ;; contain pointers to oldspace, then we also know that no new
			 ;; pointers to oldspace could have been created (only transporting
			 ;; can create them), hence the scavenge is done.
			 (UNLESS FOUND
			   ;; See whether a weakspace pass is still needed
			   (WHEN (OR *TRANSPORTER-BREAK-WEAK-LINKS*
				     (CL:DOTIMES (REGION (N-REGIONS) T)
				       (WHEN (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
						%REGION-SPACE-WEAK)
					 (UNLESS (ZEROP (REGION-FREE-POINTER REGION))
					   (RETURN NIL)))))
			     ;; All done.  Set up for oldspace reclamation.
			     (SETQ *GC-OLDSPACE-REGIONS-RECLAIMED* 0
				   *GC-RECLAIM-OLDSPACE-TOTAL-OLDSPACE-REGIONS*
				   (COUNT-OLDSPACE-REGIONS))
			     ;; Setting this to T means *SCAV-WORK-DONE* will not be used
			     ;; until the next flip.  Set *SCAV-WORK-DONE* to NIL to catch
			     ;; any bugs.
			     (SETQ %GC-FLIP-READY T)
			     (WAKEUP-GC-PROCESS)
			     (LET ((*INHIBIT-CONSING-FLAG* NIL))
			       ;; Allow this to be a bignum
			       (INCF TOTAL-SCAV-WORK-DONE *SCAV-WORK-DONE*)
			       (SETQ *SCAV-WORK-DONE* NIL))
			     (CLEAR-CONS-CACHES)	;Reinhibit consing
			     (RETURN T))
			   ;; Regular scavenging is done, but we still have to go back
			   ;; and clean up weakspace, which we do by making a second
			   ;; scavenger pass, over the weakspace regions this time,
			   ;; using a different transporter that snaps out gc-forwards
			   ;; but replaces references to oldspace with dtp-null.
			   (SETQ *SCAVENGER-STATE* (IF *EPHEMERAL-GC-IN-PROGRESS*
						       'RESIDENT-PAGES 'COPYSPACE))
			   (SETQ *SCAVENGER-RESIDENT-PAGES-STATE* 0)
			   (SETQ *TRANSPORTER-BREAK-WEAK-LINKS* T))
			 ;; We've been through every region, but we aren't necessarily
			 ;; done yet because we may not have started with the first region
			 ;; if FOUND is T, and if FOUND is NIL we still have to do weakspace.
			 ;; Allow an interrupt and then try again.
			 (RETURN NIL))))
		;; If we have a region that requires scavenging, or if we have some
		;; ephemeral scavenging to do, do it.  Otherwise loop and try another region.
		(WHEN (OR (NEQ SCAVENGER-STATE 'COPYSPACE)
			  (AND (LDB-TEST %%REGION-SCAVENGE-ENABLE
					 (SETQ BITS (REGION-BITS REGION)))
			       (IF *TRANSPORTER-BREAK-WEAK-LINKS*
				   (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-WEAK)
				   ( (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-WEAK))
			       (> (IF (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-COPY)
				      (REGION-FREE-POINTER REGION)
				      (REGION-FREE-POINTER-BEFORE-FLIP REGION))
				  (REGION-GC-POINTER REGION))))
		  (SETQ FOUND T)		;might not scavenge entire region this pass
		  (LET ((BASE-WORK (REAL-SCAV-WORK-DONE))
			(WORK (IF WORK-UNITS (MIN WORK-UNITS SCAVENGE-WORK-PER-WHACK)
				  SCAVENGE-WORK-PER-WHACK))
			(TIME (IF MAX-TIME (MIN MAX-TIME SCAVENGE-MICROSECONDS-PER-WHACK)
				  SCAVENGE-MICROSECONDS-PER-WHACK)))
		    (SELECTQ SCAVENGER-STATE
		      (COPYSPACE
		       (PUSH-*GC-HYSTERESIS* REGION)
		       (SETQ *SCAVENGE-REGION* REGION)
		       (SCAVENGE-REGION REGION WORK TIME))
		      (RESIDENT-PAGES
		       (SCAVENGE-RESIDENT-PAGES WORK TIME))
		      (ESRT
		       (SCAVENGE-ESRT WORK TIME)))
		    ;; Maybe that's enough incremental scavenging for now?
		    (WHEN (OR (AND WORK-UNITS
				   (NOT (PLUSP (DECF WORK-UNITS
						     (- (REAL-SCAV-WORK-DONE)
							BASE-WORK)))))
			      (AND MAX-TIME
				   (NOT (PLUSP (DECF MAX-TIME
						     (%32-BIT-DIFFERENCE (%MICROSECOND-CLOCK)
									 ENTRY-TIME))))))
		      (RETURN T))
		    ;; Not finished, but allow interrupts before proceeding
		    (RETURN NIL)))))
	     (CLEAR-RUN-LIGHT SCAVENGE-RUN-LIGHT)
	     ))))))
  ;; Return how much we didn't get done.  Caller can figure out how much we did.
  WORK-UNITS)

(DEFUN COUNT-OLDSPACE-REGIONS ()
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS)
    (LOOP FOR REGION BELOW (N-REGIONS)
	  COUNT (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))
		   %REGION-SPACE-OLD))))

;"Smart" scavenger:
;Prefetch copyspace and oldspace pages.
;Use a simplified version of Knuth's scheme for increasing locality of copied structure.
;The goal is to try to copy objects onto the same page as the pointer to them.
;Knuth's scheme involves an elaborate data structure, but once you realize that
;it costs nothing to scavenge a page twice, since the second time you don't take
;any page faults and you don't take any transport traps, the whole thing boils
;down to scavenging the partially-full page at the end of a region first.
;
;This must be called without interrupts.
;--- This has to be totally rewritten to work with negative addresses!
(DEFUN SCAVENGE-REGION (REGION WORK-UNITS MAX-TIME
			&AUX #+3600 (STACK-BUFFER-KLUDGE NIL))
  (SETQ MAX-TIME (%32-BIT-PLUS (%MICROSECOND-CLOCK) MAX-TIME))	;When to stop
  (WITH-FAST-STORAGE-ACCESSORS (REGION-FREE-POINTER REGION-FREE-POINTER-BEFORE-FLIP)
    (LOOP WITH ORIGIN = (REGION-ORIGIN REGION)	;---Constant
	  WITH SPACE = (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION))	;---Constant
	  ;;---Can be reset after FINAL-PASS
	  WITH ORIGINAL-GC-POINTER = (REGION-GC-POINTER REGION)
	  ;;--- This is where you're scavenging, roughly.  It seems to be reset
	  ;;--- by lots of things.  I'm not sure what resets it.  Hmm, maybe
	  ;;--- this state is all in FINAL-PASS?  This variable is both relative
	  ;;--- and absolute througout this program.
	  WITH POINTER = ORIGINAL-GC-POINTER
	  ;;--- The first pass is scavenging the last partially-full pagein the region,
	  ;;--- apparently plus everything else that gets consed beyond it by transports.
	  WITH FINAL-PASS = T			;i.e. POINTER = REGION-GC-POINTER
	  ;;--- This is where we've gotten to in the first pass.
	  ;;--- When it gets incremented up to the free pointer, revert back to scavenging
	  ;;--- in the region.
	  WITH END-POINTER = CL:MOST-NEGATIVE-FIXNUM	  ;GC-pointer for first pass
	  ;;--- Internal state variables for stack regions
	  WITH SKIP-OVER-STACK = NIL
	  WITH STACK-POINTER
	  ;;--- When POINTER  PREFETCH-MARK, prefetch and recalculate what to do.
	  ;;--- These are absolute, so will not work as they are with negative addresses.
	  WITH PREFETCH-MARK = CL:MOST-NEGATIVE-FIXNUM	  ;pointer at which to start prefetch
	  WITH OTHER-PREFETCH-MARK = CL:MOST-NEGATIVE-FIXNUM ;for the other pass
	  WITH BASE-WORK = (REAL-SCAV-WORK-DONE)
	  WITH DELAY = SCAVENGE-REGION-SWITCH-DELAY
	  WITH START-POINTER			;metering
	  ;; The chunk at free-pointer-before-flip in a copyspace region
	  ;; is half in the ESRT scan and half in the copyspace scan on
	  ;; an ephemeral flip.  On the VLM, whoever gets there first
	  ;; must do the whole chunk, rather than just from the
	  ;; gc-pointer (or re-enable traps).  Once the gc-pointer has
	  ;; moved, we know the page is treatable as a "normal" page
	  #+VLM #+VLM #+VLM #+VLM
	  with trick-page = (progn
			      (and *ephemeral-gc-in-progress*
				   (= space %region-space-copy)
				   (= pointer (region-free-pointer-before-flip region))))
      AS START-TIME = (%MICROSECOND-CLOCK)	;..
      AS START-FETCHES = *COUNT-PAGE-FETCHES*	;..
      AS FREE = (IF (= SPACE %REGION-SPACE-COPY)
		    (REGION-FREE-POINTER REGION)
		    (REGION-FREE-POINTER-BEFORE-FLIP REGION))
      DO
      ;; If we have caught up to the free pointer, we are done with this pass
      (IF ( POINTER FREE)
	  (IF FINAL-PASS
	      (PROGN (SETQ *SCAVENGE-REGION* NIL)
		     (POP-*GC-HYSTERESIS* REGION)
		     (RETURN NIL))
	      (PSETQ END-POINTER POINTER
		     POINTER ORIGINAL-GC-POINTER
		     PREFETCH-MARK OTHER-PREFETCH-MARK
		     OTHER-PREFETCH-MARK PREFETCH-MARK
		     FINAL-PASS T))
	  ;; If there is a partially-full page at the end of the region and the
	  ;; gc-pointer isn't caught up to there yet, scavenge that page first.
	  (WHEN (AND (= SPACE %REGION-SPACE-COPY)
		     (NOT (ZEROP (LDB #+VLM %%word-within-chunk #-VLM %%VMA-WORD-OFFSET FREE)))
		     ( (LDB #+VLM %%vma-chunk-num #-VLM %%VMA-PAGE-NUM POINTER)
			(LDB #+VLM %%vma-chunk-num #-VLM %%VMA-PAGE-NUM FREE)))
	    (IF FINAL-PASS
		(AND (> FREE END-POINTER)
		     (PSETQ POINTER (MAX (DPB 0
					      #+VLM %%word-within-chunk
					      #-VLM %%VMA-WORD-OFFSET
					      FREE) END-POINTER)
			    PREFETCH-MARK OTHER-PREFETCH-MARK
			    OTHER-PREFETCH-MARK PREFETCH-MARK
			    FINAL-PASS NIL))
		(SETQ POINTER (DPB 0
				   #+VLM %%word-within-chunk
				   #-VLM %%VMA-WORD-OFFSET
				   FREE)))))
      AS COUNT = (- FREE POINTER) DO
      ;; Temporarily change POINTER from a relative address to an absolute address
      (INCF POINTER ORIGIN)
      (SETQ START-POINTER POINTER)
      ;; If we did all we were supposed to, do slow recalculation again
      ;; But if we interrupted due to a transport, don't be slow
      (COND (( POINTER PREFETCH-MARK)
	     ;; Slow recalculations of what to scavenge, and page prefetching
	     ;; If scavenging a stack, don't go past where its stack pointer is now.
	     ;; This is most important for the current stack, since otherwise we can
	     ;; blow out inside of TRANSPORT-TRAP.  Objects past the stack-pointer
	     ;; should not be GC-protected, for niceness and because SI:FULL-GC depends on
	     ;; the binding stack not protecting obsolete objects.
	     ;; Note: this depends on knowing that we don't do two passes on stack
	     ;; space, because it isn't copy space.
	     (WHEN (LDB-TEST %%SPACE-TYPE-STACK SPACE)
	       (MULTIPLE-VALUE-BIND (STACK-BASE STACK-ACTIVE-SIZE STACK-TOTAL-SIZE)
		   (DECODE-STACK-ADDRESS POINTER)
		 (UNLESS (NULL STACK-BASE)	;Inactive stack treated as ordinary space
		   ;; Arrange to scavenge the active part of the stack then zoom up to the end
		   (SETQ STACK-POINTER (+ STACK-BASE STACK-ACTIVE-SIZE))
		   (SETQ COUNT (- STACK-POINTER POINTER))
		   (SETQ SKIP-OVER-STACK (+ STACK-BASE STACK-TOTAL-SIZE))
		   ;; 3600 Feature
		   #+3600
		   (WHEN ( POINTER %STACK-BUFFER-LOW STACK-POINTER)
		     (IF (< POINTER %STACK-BUFFER-LOW)
			 (SETQ COUNT (- %STACK-BUFFER-LOW POINTER))
			 (SETQ STACK-BUFFER-KLUDGE T))))))
	     (WHEN FINAL-PASS
	       ;; Do less scavenging than maximum possible if desired
	       (WHEN (AND (PLUSP WORK-UNITS) (> COUNT WORK-UNITS))
		 (SETQ COUNT WORK-UNITS))
	       ;; Prefetch pages going to be scanned, unless it is the page at the end
	       ;; of the region, which is very likely already resident and in any
	       ;; case is only a single page, so the prefetch would be inutile.
	       (WHEN SCAVENGE-COPYSPACE-PREFETCH
		 (GC-PREFETCH-PAGES POINTER
				    (MIN (1+ (- (LDB %%VMA-PAGE-NUM (+ POINTER COUNT -1))
						(LDB %%VMA-PAGE-NUM POINTER)))
					 SCAVENGE-COPYSPACE-PREFETCH))))
	     #-VLM
	     ;; Prefetch oldspace pages going to be touched.  Remember up to 8
	     ;; pages that were prefetched.
	     (WHEN (AND SCAVENGE-OLDSPACE-PREFETCH #+3600 (NOT STACK-BUFFER-KLUDGE))
	       (AND SCAVENGE-MAX-LOOKAHEAD
		    (> COUNT SCAVENGE-MAX-LOOKAHEAD)
		    (SETQ COUNT SCAVENGE-MAX-LOOKAHEAD))
	       (LET ((P POINTER)
		     (LIMIT (+ POINTER COUNT))
		     (PREFETCH-COUNTER SCAVENGE-OLDSPACE-PREFETCH)
		     OLDP)
		 (WITH-STACK-LIST (VPN-MEMORY NIL NIL NIL NIL NIL NIL NIL NIL)
		   (LOOP WITH VPN-MEMORY-INSERT = VPN-MEMORY
			 DO (MULTIPLE-VALUE (P OLDP) (%SCAN-FOR-OLDSPACE P LIMIT))
			 UNTIL (NULL OLDP)
			 DO (LET ((VPN (LDB %%VMA-PAGE-NUM OLDP)))
			      (WHEN (NOT (CL:MEMBER VPN VPN-MEMORY))
				;; Don't know about this one yet
				(WHEN (GC-PREFETCH-PAGES OLDP 1)
				  ;; a disk-op was done, remember vpn and bump counter
				  (WHEN VPN-MEMORY-INSERT
				    ;; there is room for more remembering
				    (SETF (CAR VPN-MEMORY-INSERT) VPN)
				    (SETF VPN-MEMORY-INSERT (CDR VPN-MEMORY-INSERT)))
				  (UNLESS (PLUSP (DECF PREFETCH-COUNTER))
				    (RETURN)))))))))
	     ;; Remember next place to do these slow computations
	     (SETQ PREFETCH-MARK (+ POINTER COUNT)))
	    (T 
	     ;; We interrupted due to a transport, don't be slow
	     ;; Don't pass PREFETCH-MARK
	     (WHEN (> (+ POINTER COUNT) PREFETCH-MARK)
	       (SETQ COUNT (- PREFETCH-MARK POINTER)))
	     ;; Do less scavenging than maximum possible if desired
	     (WHEN (AND FINAL-PASS (PLUSP WORK-UNITS) (> COUNT WORK-UNITS))
	       (SETQ COUNT WORK-UNITS))
	     ;; In second iteration on a stack, don't go past the stack pointer
	     (WHEN (AND SKIP-OVER-STACK (> (+ POINTER COUNT) STACK-POINTER))
	       (SETQ COUNT (- STACK-POINTER POINTER)))))
      ;; VLM must always scavenge full chunks -- especially copyspace to
      ;; cover the case of transporting into the page you are scavening:
      ;; since the page will end up disabled, you had better complete
      ;; it! (but don't scavenge beyond the top of a stack:  it may have
      ;; hyperspace pointers; and beware not to claim you scavenged
      ;; beyond the free pointer! (see below))
      #+VLM
      (progn
	;; The "trick page" will only be examined in the final pass:  if
	;; the free-pointer is in the same page as the gc-pointer, there
	;; is no first pass; if it's in a different page, we know the
	;; first pass is not doing the trick page.
	(when (and final-pass trick-page)
	  (incf count (ldb %%word-within-chunk pointer))
	  (setq pointer (chunk-base-address pointer))
	  (setq trick-page nil))
	(setq count (- (round-to-chunk (+ pointer count)) pointer))
	(when skip-over-stack
	  (setq count (min count (- stack-pointer pointer)))))
      ;; Scavenge until an evacuation occurs, then think again about what to do
      ;; When doing weakspace, no need to stop after an evacuation
      #+IMach
      (SETQ POINTER (%BLOCK-TRANSPORT POINTER COUNT *TRANSPORTER-BREAK-WEAK-LINKS*))
      #+3600  (LOOP WITH LIMIT = (+ POINTER COUNT)
		    DOING (SETQ POINTER (IF STACK-BUFFER-KLUDGE
					    (BLOCK-TRANSPORT-AMEM POINTER COUNT)
					    (%BLOCK-TRANSPORT POINTER COUNT)))
		    WHILE *TRANSPORTER-BREAK-WEAK-LINKS*
		    DO (SETQ COUNT (- LIMIT POINTER))
		    WHILE (PLUSP COUNT))
      ;; Metering
      (COND (FINAL-PASS
	     (UPDATE-MS-METER SCAVENGER-FINAL-PASS-MILLISECONDS START-TIME)
	     (INCF SCAVENGER-FINAL-PASS-PAGE-FETCHES (- *COUNT-PAGE-FETCHES* START-FETCHES))
	     (INCF SCAVENGER-FINAL-PASS-WORDS (- POINTER START-POINTER))
	     (INCF SCAVENGER-FINAL-PASS-TIMES))
	    (T
	     (UPDATE-MS-METER SCAVENGER-FIRST-PASS-MILLISECONDS START-TIME)
	     (INCF SCAVENGER-FIRST-PASS-PAGE-FETCHES (- *COUNT-PAGE-FETCHES* START-FETCHES))
	     (INCF SCAVENGER-FIRST-PASS-WORDS (- POINTER START-POINTER))
	     (INCF SCAVENGER-FIRST-PASS-TIMES)))
      ;; Store back state and decide if we have done enough work for now
      (AND SKIP-OVER-STACK
	   ( POINTER STACK-POINTER)
	   (SETQ POINTER SKIP-OVER-STACK
		 SKIP-OVER-STACK NIL))
      (SETQ POINTER (- POINTER ORIGIN))
      (WHEN FINAL-PASS
	(LET ((WORK (- POINTER ORIGINAL-GC-POINTER))
	      (FIRST-WORD (DPB 0 SYS:%%Q-POINTER-WITHIN-PAGE ORIGINAL-GC-POINTER))
	      (LAST-WORD (DPB 0 SYS:%%Q-POINTER-WITHIN-PAGE POINTER)))
	  (SETF (REGION-GC-POINTER REGION)
		(SETQ ORIGINAL-GC-POINTER #+VLM (min free pointer) #-VLM POINTER))
	  (AND (> LAST-WORD FIRST-WORD)
	       SCAVENGE-POSTPURGE-ENABLE
	       (PAGE-OUT-WORDS (+ ORIGIN FIRST-WORD) (- LAST-WORD FIRST-WORD)
			       :WRITE-MODIFIED :DEFERRED))
	  (INCF *SCAV-WORK-DONE* WORK)
	  (DECF DELAY WORK)
	  ;; If the transporter has extended a copyspace, distinct from the one
	  ;; we are working on now, go work on the last page of that copyspace
	  ;; so as to maintain locality in the copied structure.
	  (AND (MINUSP DELAY)
	       ( *SCAVENGE-REGION* REGION)
	       (RETURN NIL))))
      ;; Whichever pass we're on, stop if enough work has been done or enough time has passed
      ;; First pass doesn't do scavenger work directly, but still does it via transporter
      (WHEN (OR (NOT (PLUSP (INCF WORK-UNITS		;INCF by a negative amount
				  (- BASE-WORK
				     (SETQ BASE-WORK (REAL-SCAV-WORK-DONE))))))
		(NOT (PLUSP (%32-BIT-DIFFERENCE MAX-TIME (%MICROSECOND-CLOCK)))))
	(RETURN NIL)))))

;;; Prefetch these pages and normalize them, since we are pretty certain to
;;; reference them.  We often prefetch the same page over and over, so it's
;;; worth a quick check to see whether the page is already in.
;;; Returns NIL if it definitely did not initiate a disk operation.
;;;---- IMach can probably do better than this in testing for disk ops.
(DEFUN GC-PREFETCH-PAGES (ADDRESS N-PAGES)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LOOP WHILE (PLUSP N-PAGES) DO
    (COND #+3600 ((%PHYSICAL-ADDRESS-CACHE ADDRESS)
		  ;; can't seem to use PHYSICAL-RESIDENT-P because we aren't on
		  ;; the aux stack and things can still move around behind our
		  ;; back and cause errors.  It WIRED-FERRORs in pending-get
		  ;; called from pht-lookup.  Apparently taking a page fault in
		  ;; certain circumstances while in pht-lookup causes this.
		  (SETQ ADDRESS (+ ADDRESS PAGE-SIZE)
			N-PAGES (1- N-PAGES)))
	  (T
	   (%FUNCALL-IN-AUX-STACK #'USER-PREFETCH-PAGES ADDRESS N-PAGES NIL T)
	   (RETURN T)))))

;Scavenge some probably-nonresident pages, as directed by the ESRT
;--- Also meter page prefetches somehow
;--- Also meter CPU time spent in ESRT-SCAN (mostly spent prefetching?)
(DEFUN SCAVENGE-ESRT (WORK-UNITS MAX-TIME)
  (LET ((START-TIME (%MICROSECOND-CLOCK))	;Metering
	(START-FETCHES *COUNT-PAGE-FETCHES*)	;..
	(PAGES-DONE 0))				;..
    (LOOP NAMED LOOP
	  WITH ADDRESS = 0 WITH N-PAGES WITH MASK = (EPHEMERAL-OLDSPACE-LEVEL-MASK)
	  DO (MULTIPLE-VALUE (ADDRESS N-PAGES)
	       (ESRT-SCAN MASK ADDRESS (1+ (OR SCAVENGE-ESRT-PREFETCH 0))))
	     (UNLESS ADDRESS
	       ;; Entire ESRT has been processed, so advance to next phase
	       (SETQ *SCAVENGER-STATE* 'COPYSPACE)
	       (RETURN-FROM LOOP))
	     ;; Scavenge these pages
	     (LOOP REPEAT
		     #-VLM N-PAGES
		     #+VLM (ldb %%vpn-chunk-num n-pages)
		   AS BASE-WORK = (REAL-SCAV-WORK-DONE)
		   DO #+IGNORE (ENTER-SCAVENGE-TRACE %SCAV-OP-ESRT (EXTRACT-VPN ADDRESS))
		      #+VLM
		      (cl:assert (zerop (ldb %%word-within-chunk address)) ()
				 "Unaligned page scavenge")
		      (SCAVENGE-PAGE ADDRESS)
		      (setq ADDRESS
			    (storage::address-plus ADDRESS
						   #-VLM PAGE-SIZE
						   #+VLM %address-space-chunk-size))
		      (INCF PAGES-DONE)
		      ;; If we've done enough work for now, save state and exit
		      (WHEN (OR *SCAVENGE-REGION*
				*GC-HYSTERESIS*
				(MINUSP (DECF WORK-UNITS
					      (- (REAL-SCAV-WORK-DONE) BASE-WORK)))
				(< MAX-TIME (%32-BIT-DIFFERENCE (%MICROSECOND-CLOCK)
								START-TIME)))
			(ESRT-SCAN -1 ADDRESS 0)
			(RETURN-FROM LOOP))))
    ;; Metering
    (UPDATE-MS-METER SCAVENGER-ESRT-MILLISECONDS START-TIME)
    (INCF SCAVENGER-ESRT-PAGE-FETCHES (- *COUNT-PAGE-FETCHES* START-FETCHES))
    (INCF* SCAVENGER-ESRT-WORDS (%FIXNUM-MULTIPLY PAGES-DONE
						 #-VLM PAGE-SIZE
						 #+VLM %address-space-chunk-size))
    (INCF SCAVENGER-ESRT-TIMES)
    NIL))

;Scavenge one page that is thought, by the RESIDENT-PAGES or the ESRT, to be interesting
;*SCAV-WORK-DONE* is updated by a sort-of arbitrary amount.  There is no issue
; of finishing the GC before running out of address space; this is only a way
; to make the scavenge happen incrementally at some reasonable rate, pegged to
; the rate of consing of new objects.  Note that various overheads that take
; time, such as skipping bogus pages, are not accounted for as *SCAV-WORK-DONE*.
;Note that *SCAVENGE-REGION* is only checked between pages; this is deliberate.
;---Probably should open-code some of the crap this calls
;---Metering (or should we leave it entirely to the callers?)
(DEFUN SCAVENGE-PAGE (ADDRESS)
  (LET ((REGION (%REGION-NUMBER ADDRESS)))
    (WHEN REGION				;Ignore if not in any region (can't happen?)
      (LET* ((BITS (REGION-BITS REGION))
	     (SPACE (LDB %%REGION-SPACE-TYPE BITS)))
	(UNLESS (OR (= SPACE %REGION-SPACE-OLD)		;Ignore oldspace
		    (IF *TRANSPORTER-BREAK-WEAK-LINKS*
			( SPACE %REGION-SPACE-WEAK)	;Do only weakspace
			(= SPACE %REGION-SPACE-WEAK)))	;Do only strongspace
	  ;;--- Note: we could do further optimization to avoid prefetching
	  ;;--- pages indicated by the ESRT that are not going to be
	  ;;--- touched here because of the region-space-type.
	  (WHEN (LDB-TEST %%REGION-SCAVENGE-ENABLE BITS)
	    ;; Page is in a scavengeable space, but could be in the nonextant part
	    ;; of the region or off the end of a stack
	    ;; For VLM "page" means a protection unit, which is a chunk
	    (LET* ((LIMIT (+ ADDRESS #-VLM PAGE-SIZE #+VLM %ADDRESS-SPACE-CHUNK-SIZE))
		   (FREE (+ (REGION-ORIGIN REGION) (REGION-FREE-POINTER REGION)))
		  #+3600
		  (STACK-BUFFER-KLUDGE NIL))
	      (WHEN (< ADDRESS FREE)		;Ignore if page does not exist at all
		(WHEN (LDB-TEST %%SPACE-TYPE-STACK SPACE)
		  (MULTIPLE-VALUE-BIND (STACK-BASE STACK-ACTIVE-SIZE)
		      (DECODE-STACK-ADDRESS ADDRESS)
		    (WHEN STACK-BASE		;Inactive stack treated as ordinary space
		      ;; Set FREE to address of first word in this page to be ignored
		      (SETQ FREE (MAX (+ STACK-BASE STACK-ACTIVE-SIZE) ADDRESS))
		      #+3600
		      (WHEN ( %STACK-BUFFER-LOW ADDRESS %STACK-BUFFER-LIMIT)
			;; Goddamn block reads don't work from A-memory
			(SETQ STACK-BUFFER-KLUDGE T))))
		  ;; VLM always does whole pages, except for stacks, to update properly
		  #+VLM
		  (when (> limit free)
		    ;; don't look at the part of the page after the free pointer
		    (setq limit free)))
		#-VLM
		(WHEN (> LIMIT FREE)
		  ;; Don't look at the part of the page after the free pointer
		  (SETQ LIMIT FREE))
		#-VLM
		;; Prefetch oldspace pages that are going to be touched
		(WHEN (AND SCAVENGE-OLDSPACE-PREFETCH #+3600 (NOT STACK-BUFFER-KLUDGE))
		  (LET ((P ADDRESS)
			(PREFETCH-COUNTER SCAVENGE-OLDSPACE-PREFETCH)
			(LAST-VPN NIL)
			OLDP)
		    (LOOP DO (MULTIPLE-VALUE (P OLDP)
			       (%SCAN-FOR-OLDSPACE P LIMIT))
			  UNTIL (NULL OLDP)
			  DO (WHEN (NEQ (LDB %%VMA-PAGE-NUM OLDP) LAST-VPN)
			       (SETQ LAST-VPN (LDB %%VMA-PAGE-NUM OLDP))
			       (OR (NOT (GC-PREFETCH-PAGES OLDP 1))
				   (PLUSP (DECF PREFETCH-COUNTER))
				   (RETURN))))))
		;; Account for work going to be done
		(LET ((WORK (- LIMIT ADDRESS)))
		  (INCF *SCAV-WORK-DONE* WORK)
		  (IF (PLUSP WORK)
		      (PROGN
			;; Scavenge whole page (don't stop on evacuation)
			#+3600 (LOOP DOING
				 (SETQ ADDRESS
				       (IF STACK-BUFFER-KLUDGE
					   (BLOCK-TRANSPORT-AMEM ADDRESS (- LIMIT ADDRESS))
					   (%BLOCK-TRANSPORT ADDRESS (- LIMIT ADDRESS))))
				     WHILE (< ADDRESS LIMIT))
			#+imach (%BLOCK-TRANSPORT ADDRESS (- LIMIT ADDRESS) T))
		      #+VLM
		      ;; a forwarded stack may get enabled, but never needs scavenging
		      (LET ((PHT-INDEX (PHT-LOOKUP (STORAGE::EXTRACT-VPN ADDRESS))))
			(STORAGE::VM-WRITE-ATTRIBUTE TRANSPORT-DISABLE PHT-INDEX T))))
		    ))))))))


;;; Progress Notes
(DEFVAR *GC-PROGRESS-NOTE* NIL)

;; This is set back to :FOREGROUND by the world-release script.
(DEFVAR *GC-PROGRESS-NOTE-ENABLE* (LIST :EPHEMERAL :BACKGROUND :DYNAMIC :BACKGROUND))

(DEFVAR *GC-OLDSPACE-REGIONS-RECLAIMED* 0)		;For RECLAIM-OLDSPACE progress.

(DEFVAR *GC-RECLAIM-OLDSPACE-TOTAL-OLDSPACE-REGIONS*)	;Ditto.

;; "User Interface"
(DEFUN ENABLE-GC-PROGRESS-NOTES (&KEY (DYNAMIC NIL DYNAMIC-P)
				      (EPHEMERAL NIL EPHEMERAL-P))
  (WHEN EPHEMERAL-P
    (CL:CHECK-TYPE EPHEMERAL (CL:MEMBER NIL :FOREGROUND :BACKGROUND :OVERRIDE)))
  (WHEN DYNAMIC-P
    (CL:CHECK-TYPE DYNAMIC (CL:MEMBER NIL :FOREGROUND :BACKGROUND :OVERRIDE)))
  (LET ((ENABLE *GC-PROGRESS-NOTE-ENABLE*))
    (WHEN EPHEMERAL-P (SETF (GETF ENABLE :EPHEMERAL) EPHEMERAL))
    (WHEN DYNAMIC-P (SETF (GETF ENABLE :DYNAMIC) DYNAMIC))
    ENABLE))

;; "Wholine Interface"
(DEFUN GET-GC-PROGRESS-NOTE (WHO-SHEET)
  (UNLESS *GC-PROGRESS-NOTE*
    (SETQ *GC-PROGRESS-NOTE*
	  (LET ((DEFAULT-CONS-AREA PERMANENT-STORAGE-AREA))
	    (TV:MAKE-PROGRESS-NOTE :NAME "" :PROCESS 'GC))))
  (FLET ((RETURN-PROGRESS-NOTE (NAME NUMERATOR DENOMINATOR)
	   (LET ((GC-PROGRESS-NOTE *GC-PROGRESS-NOTE*))
	     (UNLESS (EQ (TV:PROGRESS-NOTE-NAME GC-PROGRESS-NOTE) NAME)
	       (SETF (TV:PROGRESS-NOTE-NAME GC-PROGRESS-NOTE) NAME)
	       (SEND WHO-SHEET :CLOBBERED))
	     (SETF (TV:PROGRESS-NOTE-FRACTION-DONE-NUMERATOR GC-PROGRESS-NOTE) NUMERATOR)
	     (SETF (TV:PROGRESS-NOTE-FRACTION-DONE-DENOMINATOR GC-PROGRESS-NOTE) DENOMINATOR)
	     GC-PROGRESS-NOTE)))
      (IF %GC-FLIP-READY
	  (UNLESS GC-RECLAIMED-OLDSPACE
	    (RETURN-PROGRESS-NOTE "GC:  Reclaiming oldspace"
				  *GC-OLDSPACE-REGIONS-RECLAIMED*
				  *GC-RECLAIM-OLDSPACE-TOTAL-OLDSPACE-REGIONS*))
	  (SELECTQ *SCAVENGER-STATE*
	    (COPYSPACE
	     (MULTIPLE-VALUE-BIND (NUMERATOR DENOMINATOR)
		 (COPYSPACE-PROGRESS)
	       (RETURN-PROGRESS-NOTE (IF *TRANSPORTER-BREAK-WEAK-LINKS*
					 "GC:  Scanning weakspace"
					 (IF *EPHEMERAL-GC-IN-PROGRESS*
					     "GC:  Scanning copyspace"
					     "GC:  Scavenging oldspace references"))
				     NUMERATOR DENOMINATOR)))
	    (RESIDENT-PAGES
	     (MULTIPLE-VALUE-BIND (NUMERATOR DENOMINATOR)
		 (RESIDENT-PAGES-PROGRESS)
	       (RETURN-PROGRESS-NOTE (IF *TRANSPORTER-BREAK-WEAK-LINKS*
					 "GC:  Scanning resident weakspace pages"
					 "GC:  Scanning resident pages")
				     NUMERATOR DENOMINATOR)))
	    (ESRT
	     (MULTIPLE-VALUE-BIND (NUMERATOR DENOMINATOR)
		 (ESRT-PROGRESS)
	       (RETURN-PROGRESS-NOTE (IF *TRANSPORTER-BREAK-WEAK-LINKS*
					 "GC:  Scanning nonresident weakspace pages"
					 "GC:  Scanning nonresident pages")
				     NUMERATOR DENOMINATOR)))))))

(DEFUN COPYSPACE-PROGRESS ()
  (WITH-FAST-STORAGE-ACCESSORS (REGION-FREE-POINTER REGION-GC-POINTER REGION-BITS
				REGION-FREE-POINTER-BEFORE-FLIP)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (LOOP WITH DYNAMIC = (NOT *EPHEMERAL-GC-IN-PROGRESS*)
	  WITH CURRENT-WORK-DONE = 0
	  WITH TOTAL-WORK = 0
	  FOR REGION BELOW (N-REGIONS)
	  AS BITS = (REGION-BITS REGION)
	  WHEN (LDB-TEST %%REGION-SCAVENGE-ENABLE BITS)
	    DO (LET* ((OFP (REGION-FREE-POINTER-BEFORE-FLIP REGION))
		      (FP (REGION-FREE-POINTER REGION))
		      (GC (REGION-GC-POINTER REGION))
		      (ORIGINAL-GC (IF DYNAMIC 0 OFP)))
		 (INCF TOTAL-WORK (IF (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-COPY)
				      (- FP ORIGINAL-GC)
				      (- OFP ORIGINAL-GC)))
		 (INCF CURRENT-WORK-DONE (- GC ORIGINAL-GC)))
	  FINALLY (IF (ZEROP TOTAL-WORK) (INCF TOTAL-WORK))
		  (RETURN (VALUES CURRENT-WORK-DONE TOTAL-WORK)))))

(DEFUN ESRT-PROGRESS ()
  (%FUNCALL-IN-AUXILIARY-STACK-BUFFER VALUES #'AUX-ESRT-PROGRESS))

;;; Incremental GC and the GC Process
;;;----Doing DYNAMIC-GC-FLIP doesn't kick this.  Fix that somehow?

;; Set this to T to force the GC process to recalculate whether or not to flip.
(DEFVAR *WAKEUP-GC-PROCESS* NIL)

(DEFUN WAKEUP-GC-PROCESS (&OPTIONAL FORCE)
  (WHEN (VARIABLE-BOUNDP GC-PROCESS)
    (WHEN FORCE (SETQ *WAKEUP-GC-PROCESS* T))
    (PROCESS:PROCESS-WAKEUP GC-PROCESS)))

;;; This function runs in a separate process.  It wakes up when oldspace needs
;;; to be reclaimed and when a flip is required, and does them.
(DEFUN GC-PROCESS ()
  ;; Process has just started up, enable other parts of GC
  (UNLESS GC-ON
    (PROCESS:PROCESS-WAIT-FOREVER))		;Await GC-ON
  (SETQ INHIBIT-SCAVENGING-FLAG NIL		;Enable scavenging during cons
	INHIBIT-IDLE-SCAVENGING-FLAG NIL)	;Enable scavenging by scheduler during idle
  ;; Loop forever.  This loop restarts after each flip.
  (LOOP WITH TEMPORARY-IMMEDIATE-MODE = NIL	;Set to T for one cycle to reclaim immediately
	WITH DYNAMIC-GC-ON = (GET (LOCF GC-ON) :DYNAMIC)	;Remember which garbage
	WITH EPHEMERAL-GC-ON = (GET (LOCF GC-ON) :EPHEMERAL)	; collectors are turned on.
	WITH DYNAMIC-GC = NIL			;Type of most recent garbage collection
	WITH GENERATION = NIL			;Generation after our last flip.
	DO
    (SETQ *WAKEUP-GC-PROCESS* NIL)
    (SETQ GENERATION %GC-GENERATION-NUMBER)
    (EMPTY-GC-REPORT-QUEUE)
    (OR TEMPORARY-IMMEDIATE-MODE
	(IF DYNAMIC-GC GC-RECLAIM-IMMEDIATELY GC-RECLAIM-EPHEMERAL-IMMEDIATELY)
	;; Wait until scavenger done, unless we aren't doing real-time garbage collection.
	;; This can't be simply PROCESS-BLOCK due to timing problems.
	(PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
	  "Await Scavenge" 1 #'(LAMBDA () %GC-FLIP-READY)))
    ;; If doing an immediate GC, run the scavenger at the specified priority,
    ;; which defaults to high priority.
    (UNLESS %GC-FLIP-READY
      (SEND CURRENT-PROCESS :SET-PRIORITY GC-PROCESS-IMMEDIATE-RECLAIM-PRIORITY)
      (%GC-SCAVENGE))
    ;; Then flush oldspace and print "flushing oldspace" message.
    ;; Decrease the priority of the GC process while doing this, since it could
    ;; take a long time and we want to allow other people to use the machine.
    ;; Of course, their consing had better be negligible or we could run out of address space.
    (SEND CURRENT-PROCESS :SET-PRIORITY GC-PROCESS-BACKGROUND-PRIORITY)
    (GC-RECLAIM-OLDSPACE)
    (PROCESS:SET-PROCESS-PRIORITY CURRENT-PROCESS
				  (PROCESS:MAKE-PROCESS-PRIORITY
				    :FOREGROUND GC-PROCESS-FOREGROUND-PRIORITY
				    :PREEMPTIVE T))
    ;; Now decide when to flip.  This loop restarts after each process-wait.
    (LOOP UNTIL ( %GC-GENERATION-NUMBER GENERATION)	;Someone else flipped
      AS DYNAMIC-ALARM = (GC-PAGE-CONS-ALARM)
      AS DYNAMIC-ROOM-LEFT = (IF DYNAMIC-GC-ON
				 (GC-GET-UNCOMMITTED-FREE-SPACE)
				 T)
	;Use *CONS-WORK-DONE* rather than (GC-PAGE-CONS-ALARM) since we are concerned
	;about the exact size of ephemeral space, not about the amount of free disk space.
      AS EPHEMERAL-ALARM = (WITHOUT-INTERRUPTS
			     (- *CONS-WORK-DONE*
				(%STRUCTURE-CACHE-LENGTH)
				(%LIST-CACHE-LENGTH)))
      AS EPHEMERAL-ROOM-LEFT = (IF EPHEMERAL-GC-ON
				   (CONSING-UNTIL-EPHEMERAL-FLIP)
				   T)
      DO (COND ((AND (NEQ DYNAMIC-ROOM-LEFT T)
		     (< DYNAMIC-ROOM-LEFT %ADDRESS-SPACE-QUANTUM-SIZE))
		;; Had better flip now, less than GC-DELTA words left, or getting
		;; very close to that ("allowing 3 words more consing before flip"!) 
		(WHEN (DYNAMIC-GC-FLIP :INSUFFICIENT-ADDRESS-SPACE-ACTION :NOTIFY
				       :RECLAIM (IF GC-RECLAIM-IMMEDIATELY-IF-NECESSARY
						    :IMMEDIATE :INCREMENTAL))
		  ;; Flipping succeeded
		  (SETQ DYNAMIC-GC T)
		  (SETQ TEMPORARY-IMMEDIATE-MODE NIL)	;Not in emergency any more
		  (RETURN))	;Return to outer loop
		;; Flipping failed
		(WHEN GC-RECLAIM-IMMEDIATELY-IF-NECESSARY
		  ;; Flip anyway, if we possibly can
		  (WHEN (LET ((GC-RECLAIM-IMMEDIATELY T))
			  (DYNAMIC-GC-FLIP :INSUFFICIENT-ADDRESS-SPACE-ACTION :NOTIFY))
		    (SETQ DYNAMIC-GC T)
		    (SETQ TEMPORARY-IMMEDIATE-MODE T)
		    (RETURN)))	;Return to outer loop for reclaim
		;; Not enough space, don't risk flipping.
		(EMPTY-GC-REPORT-QUEUE)
		(SETQ DYNAMIC-GC-ON NIL
		      ;; assumes :dynamic and :ephemeral are only keywords.  Can't do
		      ;; (SETF (GET (LOCF GC-ON) :DYNAMIC) NIL) because
		      ;; the list is sometimes constant.
		      GC-ON (IF EPHEMERAL-GC-ON
				'(:EPHEMERAL T)
			        NIL)))
	       ((AND (NULL EPHEMERAL-ROOM-LEFT) (EPHEMERAL-GC-FLIP))
		(SETQ DYNAMIC-GC NIL)
		(SETQ TEMPORARY-IMMEDIATE-MODE NIL)	;Not in emergency any more
		(RETURN))			;Return to outer loop
	       ((NOT (OR DYNAMIC-GC-ON EPHEMERAL-GC-ON))
		;; GC has turned itself off
		(PROCESS:PROCESS-WAIT-FOREVER))
	       ((NULL EPHEMERAL-ROOM-LEFT)
		;; We thought it was time for an ephemeral flip, but no levels
		;; were actually flipped.  Just go around the loop again.
		NIL)	       
	       (T ;; Wait a while before flipping, then compute frob again	       
		(WHEN (NEQ DYNAMIC-ROOM-LEFT T)
		  (SETQ GC-PAGE-CONS-ALARM-MARK
			(+ (// DYNAMIC-ROOM-LEFT PAGE-SIZE) DYNAMIC-ALARM)))
		(EMPTY-GC-REPORT-QUEUE)
		;; Note that PROCESS-FORCE-WAKEUP can be used to force any of these to
		;; continue.
		(IF EPHEMERAL-GC-ON
		    (IF DYNAMIC-GC-ON
			(PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
			  "Await ephemeral or dynamic full" 1
			  ;; Above whostate is 3 characters too long to fit
			  ;; in the wholine, and 6 characters too long for Peek,
			  ;; but use it anyway for the benefit of GC-STATUS.
			  #'(LAMBDA (ALARM GENERATION)
			      (OR (> (- *CONS-WORK-DONE*
					(%STRUCTURE-CACHE-LENGTH)
					(%LIST-CACHE-LENGTH))
				     ALARM)
				  (> (GC-PAGE-CONS-ALARM) GC-PAGE-CONS-ALARM-MARK)
				  ( %GC-GENERATION-NUMBER GENERATION)
				  *WAKEUP-GC-PROCESS*))
			  (+ EPHEMERAL-ALARM EPHEMERAL-ROOM-LEFT)
			  GENERATION)
			(PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION "Await ephemeral full" 1
			  #'(LAMBDA (ALARM GENERATION)
			      (OR (> (- *CONS-WORK-DONE*
					(%STRUCTURE-CACHE-LENGTH)
					(%LIST-CACHE-LENGTH))
				     ALARM)
				  ( %GC-GENERATION-NUMBER GENERATION)
				  *WAKEUP-GC-PROCESS*))
			  (+ EPHEMERAL-ALARM EPHEMERAL-ROOM-LEFT)
			  GENERATION))
		    (IF DYNAMIC-GC-ON
		       (PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION "Await dynamic full" 1
			 #'(LAMBDA (GENERATION)
			     (OR (> (GC-PAGE-CONS-ALARM) GC-PAGE-CONS-ALARM-MARK)
				 ( %GC-GENERATION-NUMBER GENERATION)
				 *WAKEUP-GC-PROCESS*))
			 GENERATION)
			(PROCESS:PROCESS-WAIT-FOREVER "Await GC enabled")))
		(SETQ *WAKEUP-GC-PROCESS* NIL))))))

;; Returns a mask of all base levels.
(DEFUN BASE-EPHEMERAL-LEVEL-MASK ()
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-BITS)
    (LET ((MASK 0))
      (DOTIMES (AREA (N-AREAS))
	(LET ((LEVEL (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA))))
	  (WHEN (EPHEMERAL-LEVEL-P LEVEL)
	    (SETQ MASK (LOGIOR MASK (ROT 1 LEVEL))))))
      MASK)))

;; This mask gets its bits set when an ephemeral level which would otherwise
;; flip is inhibited due to :COLLECT migration mode.
(DEFVAR *DELAYED-EPHEMERAL-LEVELS* 0)

;Returns NIL if it is time to flip ephemeral space, otherwise returns
;the minimum number of additional words that could need to be
;consed before it might be time for an ephemeral flip.
(DEFUN CONSING-UNTIL-EPHEMERAL-FLIP ()
  (WHEN (AND (NEQ *EPHEMERAL-MIGRATION-MODE* :COLLECT)
	     (NOT (ZEROP *DELAYED-EPHEMERAL-LEVELS*)))
    ;; Previously delayed flipping can now be flipped.
    (RETURN-FROM CONSING-UNTIL-EPHEMERAL-FLIP NIL))
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-FREE-POINTER)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (LET ((MASK (BASE-EPHEMERAL-LEVEL-MASK))
	  (N-WORDS CL:MOST-POSITIVE-FIXNUM)
	  (CAPACITY *EPHEMERAL-GC-FLIP-CAPACITY*))
      (DECLARE (ARRAY-REGISTER CAPACITY))
      ;; Loop over the levels in this set and see how much space is left before
      ;; they reach capacity.
      (DO ((LEVEL (1- %NUMBER-OF-EPHEMERAL-LEVELS) (1- LEVEL)))
	  ((< LEVEL 0))
	(SETQ MASK (ROT MASK 1))
	(WHEN (LDB-TEST (BYTE 1 0) MASK)
	  (LOOP FOR REGION BELOW (N-REGIONS)
		AS BITS = (REGION-BITS REGION)
		WHEN (AND (= (LDB %%REGION-LEVEL BITS) LEVEL)
			  (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-NEW))
		  SUM (REGION-FREE-POINTER REGION) INTO SIZE
		FINALLY
		  (SETQ N-WORDS (MIN (- (AREF CAPACITY LEVEL) SIZE) N-WORDS))
		  (WHEN (MINUSP N-WORDS)
		    (RETURN-FROM CONSING-UNTIL-EPHEMERAL-FLIP NIL)))))
      N-WORDS)))

(DEFUN LEVELS-TO-FLIP ()
  (DECLARE (VALUES MASK))
  (LET ((BASE-MASK (BASE-EPHEMERAL-LEVEL-MASK)))
    (LOGIOR
      (IF (ZEROP BASE-MASK) 0
	(WITH-STACK-ARRAY (SIZE %NUMBER-OF-EPHEMERAL-LEVELS :TYPE ART-FIXNUM)
	  (DECLARE (ARRAY-REGISTER SIZE))
	  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-FREE-POINTER)
	    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
	    (LOOP FOR REGION BELOW (N-REGIONS)
		  AS BITS = (REGION-BITS REGION)
		  AS LEVEL = (LDB %%REGION-LEVEL BITS)
		  WHEN (AND (EPHEMERAL-LEVEL-P LEVEL)
			    (OR (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-NEW)
				(= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-COPY)))
		    DO (INCF (AREF SIZE LEVEL) (REGION-FREE-POINTER REGION)))
	    ;; Choose the levels to flip based on the migration mode.
	    ;; The algorithms, combined below, are:
	    ;; :DYNAMIC - If the first level is full, flip all levels.
	    ;; :NORMAL  - Flip all normal levels up to the first unfull normal level.
	    ;; :KEEP    - Flip all levels upto the first unfull level.
	    ;; :EXTRA   - Flip all levels upto the first unfull level.
	    ;; :COLLECT - Flip all levels upto the first unfull level,
	    ;;            but don't ever flip the last level.  If the last level
	    ;;            was full but prohibited from flipping, remember it.
	    (LET ((CAPACITY *EPHEMERAL-GC-FLIP-CAPACITY*)
		  (KEEP-LEVEL *EPHEMERAL-GC-KEEP-NEXT-LEVEL*)
		  (NEXT-LEVEL *EPHEMERAL-GC-NORMAL-NEXT-LEVEL*)
		  (MASK 0))
	      (DECLARE (ARRAY-REGISTER CAPACITY NEXT-LEVEL KEEP-LEVEL))
	      (LOOP FOR LEVEL BELOW %NUMBER-OF-EPHEMERAL-LEVELS
		    WHEN (BIT-MEMBER LEVEL BASE-MASK)
		      DO (LOOP WITH FLIP-REST-OF-LEVELS = (EQ *EPHEMERAL-MIGRATION-MODE*
							      :DYNAMIC)
			       FOR LEVEL = LEVEL THEN (AREF KEEP-LEVEL LEVEL)
			       UNTIL (NOT (EPHEMERAL-LEVEL-P LEVEL))
			       WHILE (OR FLIP-REST-OF-LEVELS
					 ( (AREF SIZE LEVEL) (AREF CAPACITY LEVEL)))
			       WHEN (AND (EQ *EPHEMERAL-MIGRATION-MODE* :COLLECT)
					 (NOT (EPHEMERAL-LEVEL-P (AREF KEEP-LEVEL LEVEL))))
				 DO (SETQ *DELAYED-EPHEMERAL-LEVELS*
					  (LOGIOR *DELAYED-EPHEMERAL-LEVELS* (ROT 1 LEVEL)))
				    (LOOP-FINISH)
			       WHEN (AND (NOT FLIP-REST-OF-LEVELS)
					 (EQ *EPHEMERAL-MIGRATION-MODE* :NORMAL)
					 (NOT (EPHEMERAL-LEVEL-P (AREF NEXT-LEVEL LEVEL))))
				 DO (SETQ FLIP-REST-OF-LEVELS T)
			       DO (SETF MASK (LOGIOR MASK (ROT 1 LEVEL)))))
	      MASK))))
      ;; Hack delayed ephemeral areas.
      (IF (OR (ZEROP *DELAYED-EPHEMERAL-LEVELS*)
	      (EQ *EPHEMERAL-MIGRATION-MODE* :COLLECT))
	  0
	(LOOP WITH MASK = 0
	      WITH KEEP-LEVEL = *EPHEMERAL-GC-KEEP-NEXT-LEVEL*
	      FOR DELAYED-LEVEL BELOW %NUMBER-OF-EPHEMERAL-LEVELS
	      WHEN (BIT-MEMBER DELAYED-LEVEL *DELAYED-EPHEMERAL-LEVELS*)
		DO (LET ((AREA (EPHEMERAL-LEVEL-AREA DELAYED-LEVEL)))
		     (WHEN AREA
		       (LOOP FOR LEVEL = (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA))
				       THEN (AREF KEEP-LEVEL LEVEL)
			     WHILE (EPHEMERAL-LEVEL-P LEVEL)
			     DO (SETQ MASK (LOGIOR MASK (ROT 1 LEVEL))))))
	      FINALLY (SETQ *DELAYED-EPHEMERAL-LEVELS* 0)
		      (RETURN MASK))))))

;; This should be just an aref, not an exhaustive search!
(DEFUN EPHEMERAL-LEVEL-AREA (LEVEL)
  (LET ((KEEP-LEVEL *EPHEMERAL-GC-KEEP-NEXT-LEVEL*))
    (DECLARE (ARRAY-REGISTER KEEP-LEVEL))
    (DOTIMES (AREA (N-AREAS))
      (LOOP FOR L = (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA))
		  THEN (AREF KEEP-LEVEL L)
	    WHILE (EPHEMERAL-LEVEL-P L)
	    WHEN (= LEVEL L)
	      DO (RETURN-FROM EPHEMERAL-LEVEL-AREA AREA)))))

(DEFUN SHOW-LEVEL-CAPACITIES ()
  (WITH-STACK-ARRAY (LEVEL-SIZE %NUMBER-OF-EPHEMERAL-LEVELS :TYPE ART-FIXNUM)
    (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-FREE-POINTER AREA-REGION-BITS
				  EPHEMERAL-GC-KEEP-NEXT-LEVEL AREA-NAME)
      (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
      (LOOP FOR REGION BELOW (N-REGIONS)
	    AS BITS = (REGION-BITS REGION)
	    WHEN (AND (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL BITS))
		      (OR (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-NEW)
			  (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-COPY)))
	      DO (LET* ((LEVEL (LDB %%REGION-LEVEL BITS))
			(SIZE (+ (REGION-FREE-POINTER REGION) (AREF LEVEL-SIZE LEVEL))))
		   (SETF (AREF LEVEL-SIZE LEVEL) SIZE))
	    FINALLY
	      (FLET ((DESCRIBE-LEVEL (LEVEL &OPTIONAL GENERATION)
		       (LET* ((CAPACITY (AREF *EPHEMERAL-GC-FLIP-CAPACITY* LEVEL))
			      (SIZE (AREF LEVEL-SIZE LEVEL)))
			 (FORMAT T "~%  ~@[Generation ~D, ~]Level ~2D, ~
					Capacity ~6D, Size ~6D, Remaining ~6D"
				 GENERATION LEVEL CAPACITY SIZE (- CAPACITY SIZE)))))
		(LET ((MASK 0))
		  (DOTIMES (AREA (N-AREAS))
		    (LET ((INITIAL-LEVEL (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA))))
		      (WHEN (EPHEMERAL-LEVEL-P INITIAL-LEVEL)
			(FORMAT T "~%~A" (AREA-NAME AREA))
			(LOOP FOR LEVEL = INITIAL-LEVEL
					THEN (EPHEMERAL-GC-KEEP-NEXT-LEVEL LEVEL)
			      FOR GENERATION FROM 1
			      WHILE (EPHEMERAL-LEVEL-P LEVEL)
			      DO (DESCRIBE-LEVEL LEVEL GENERATION)
				 (SETF MASK (LOGIOR (ROT 1 LEVEL) MASK))))))
		  (LOOP WITH BOGUS FOR LEVEL BELOW %NUMBER-OF-EPHEMERAL-LEVELS
			WHEN (AND (= (LEVEL-TYPE LEVEL) %LEVEL-TYPE-EPHEMERAL)
				  (NOT (BIT-MEMBER LEVEL MASK)))
			  DO (WHEN (NULL BOGUS)
			       (FORMAT T "~%Orphan Levels")
			       (DESCRIBE-LEVEL LEVEL)
			       (SETQ BOGUS T)))))))))

(DEFUN GC-ON (&REST OPTIONS &KEY (EPHEMERAL (CL:GETF GC-ON :EPHEMERAL))
				 (DYNAMIC   (CL:GETF GC-ON :DYNAMIC))
				 (QUERY-P T))
  "Turn on the incremental garbage collector"
  (SETQ OPTIONS (COND (OPTIONS
		       ;; Not an old-style compatible call.  See if turning GC off.
		       (UNLESS (OR EPHEMERAL DYNAMIC)
			 (GC-OFF)
			 (RETURN-FROM GC-ON '(:EPHEMERAL NIL :DYNAMIC NIL)))
		       ;; make a copy which has the merged state
		       (LIST :EPHEMERAL EPHEMERAL :DYNAMIC DYNAMIC))
		      (T
		       ;; If neither :EPHEMERAL nor :DYNAMIC is specified, turn them both on
		       (SETQ EPHEMERAL T DYNAMIC T)
		       '(:EPHEMERAL T :DYNAMIC T))))
  (UNLESS (VARIABLE-BOUNDP GC-PROCESS)
    ;; Priority of GC process must be lower than priority of network and keyboard
    ;; processes and higher than priority of ordinary processes that cons a lot.
    (SETQ GC-PROCESS (PROCESS:MAKE-PROCESS
		       "Garbage Collector"
		       :SYSTEM-PROCESS T
		       :PRIORITY (PROCESS:MAKE-PROCESS-PRIORITY
				   :FOREGROUND GC-PROCESS-FOREGROUND-PRIORITY
				   :PREEMPTIVE T))))
  ;; Reset GC-PROCESS if running, so its wait condition becomes up to date
  (PROCESS-DISABLE GC-PROCESS)
  (PROCESS-PRESET GC-PROCESS 'GC-PROCESS)
  (WHEN (AND %GC-FLIP-READY
	     DYNAMIC
	     (MINUSP (GC-GET-UNCOMMITTED-FREE-SPACE)))
    ;; GC-PROCESS might decide it is too late to flip.  Anticipate.
    (MULTIPLE-VALUE-BIND (COMMITTED AVAILABLE IMMEDIATE-COMMITTED)
	(GC-GET-COMMITTED-FREE-SPACE)
      (SETQ COMMITTED (* COMMITTED GC-FLIP-RATIO))
      (SETQ IMMEDIATE-COMMITTED (* IMMEDIATE-COMMITTED GC-FLIP-RATIO))
      (OR ( COMMITTED AVAILABLE)
	  (AND QUERY-P
	       (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
		       (IF (NOT GC-RECLAIM-IMMEDIATELY)
			   "There are ~:D words of free space available, but doing an~@
			 incremental garbage collection could require up to ~:D words (~D%).~@
			 ~:\SI:GC-COMMAND\ would require up to ~:D words (~D%).~@
			 Do you want to risk turning on the garbage collector anyway? "
			   "There are ~:D words of free space available, but doing a~@
			 garbage collection could require up to ~:D words (~D%),~@
			 even though you are in non-incremental mode.
			 Do you want to risk turning on the garbage collector anyway? ")
		       AVAILABLE COMMITTED (// (* COMMITTED 100.) AVAILABLE)
		       `(COM-START-GC :IMMEDIATELY )
		       IMMEDIATE-COMMITTED (// (* IMMEDIATE-COMMITTED 100.) AVAILABLE)))
	  ;; User said not to turn on the dynamic GC after all.  But if the ephemeral
	  ;; GC is already on, leave the GC process running.
	  (RETURN-FROM GC-ON (PROG1 GC-ON (PROCESS-ENABLE GC-PROCESS)))))
    ;; Flip here rather than letting the GC process do it, so it doesn't
    ;; decide to turn itself right back off
    (DYNAMIC-GC-FLIP :INSUFFICIENT-ADDRESS-SPACE-ACTION :PROCEED))
  ;; Enable the ephemeral areas to actually create ephemeral objects
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-BITS)
    (LOOP FOR (AREA TOP-LEVEL) IN *EPHEMERAL-AREAS*
	  DO (SETQ AREA (SYMEVAL AREA))
	     (SETF (AREA-REGION-BITS AREA)
		   (DPB (IF EPHEMERAL TOP-LEVEL %DYNAMIC-LEVEL) %%REGION-LEVEL
			(AREA-REGION-BITS AREA)))))
  (CLEAR-CONS-CACHES)    
  (SETQ GC-ON OPTIONS)
  (PROCESS-ENABLE GC-PROCESS)			;Start flipper process
  ;; return an indication of what is on.
  GC-ON)

(DEFUN GC-OFF ()
  "Turn off the incremental garbage collector"
  (WHEN (VARIABLE-BOUNDP GC-PROCESS)
    (PROCESS-DISABLE GC-PROCESS)		;Disable flipper process
    (WHEN (EQ GC-FLIP-WAITING GC-PROCESS)
      (SETQ GC-FLIP-WAITING NIL)))
  ;; Prevent the ephemeral areas from actually creating ephemeral objects
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-BITS)
    (LOOP FOR (AREA) IN *EPHEMERAL-AREAS*
	  DO (SETQ AREA (SYMEVAL AREA))
	     (SETF (AREA-REGION-BITS AREA)
		   (DPB %DYNAMIC-LEVEL %%REGION-LEVEL (AREA-REGION-BITS AREA)))))
  (CLEAR-CONS-CACHES)
  (SETQ INHIBIT-SCAVENGING-FLAG T		;Disable scavenging during cons
        INHIBIT-IDLE-SCAVENGING-FLAG T		;Disable scavenging during idle time
	GC-ON NIL))

;;; Nonincremental GC
;;;--- Replace with IMMEDIATE-GC

(DEFUN GC-IMMEDIATELY (&OPTIONAL NO-QUERY)
  "Perform a non-incremental garbage collection.
  This takes less time and requires less free space than an incremental GC,
  but requires you to wait for it to finish."
  (WHEN (OR NO-QUERY
	    (IF (OR %GC-FLIP-READY *EPHEMERAL-GC-IN-PROGRESS*)
		;; Make sure there is enough space to flip before doing it
		(MULTIPLE-VALUE-BIND (IGNORE AVAILABLE COMMITTED)
		    (GC-GET-COMMITTED-FREE-SPACE)
		  (OR ( COMMITTED AVAILABLE)
		      (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
			      "There are ~:D words of free space available, ~
			       but doing a garbage collection~@
			       could require up to ~:D words (~D%).  ~
			       Do you want to garbage collect~@
			       anyway, assuming that at most ~D% of dynamic space ~
			       contains good data? "
			      AVAILABLE COMMITTED (// (* COMMITTED 100.) AVAILABLE)
			      (// (* AVAILABLE 100.) COMMITTED))))
		;; Already started a GC, make sure there is enough space to finish copying
		(MULTIPLE-VALUE-BIND (NIL ADDITIONAL-COPYING)
		    (GET-MAX-GC-WORK-REMAINING)
		  (MULTIPLE-VALUE-BIND (NIL NIL FREE-SIZE)
		      (GC-GET-SPACE-SIZES)
		    (OR ( ADDITIONAL-COPYING FREE-SIZE)
			(FQUERY FORMAT:YES-OR-NO-P-OPTIONS
				"There are ~:D words of free space available, ~@
				 but up to ~:D words of data may need to be copied.~@
				 Do you want to complete the garbage collection anyway? "
				FREE-SIZE ADDITIONAL-COPYING))))))
    ;; User has said that it is okay.  Now check %GC-FLIP-READY again in
    ;; case the GC process did a dynamic flip in the meantime.  If we
    ;; haven't already flipped, flip.  Then finish copying all objects
    ;; condemned by the most recent flip.
    (LET-GLOBALLY ((GC-IMMEDIATELY-IN-PROGRESS T))
      (IF (OR %GC-FLIP-READY *EPHEMERAL-GC-IN-PROGRESS*)
	  (DYNAMIC-GC-FLIP :RATIO 1 :INSUFFICIENT-ADDRESS-SPACE-ACTION :PROCEED)
	  (UNLESS NO-QUERY
	    (FORMAT ERROR-OUTPUT
		    "~&[Dynamic GC already in progress is being completed immediately; ~
			a new GC will not be started]~%")))
      (GC-RECLAIM-OLDSPACE))))

;; Explicitly Garbage Collect:

#+IGNORE (PROGN

;; FULL-GC-STATIC-AREAS is machine-dependent
;; These static areas can get cleaned up in a full GC.

;; The existing regions of these dynamic areas are made static and moved
;; to PERMANENT-STORAGE-AREA when the :SYSTEM-RELEASE option is used.
;; The areas themselves remain dynamic.  The theory is that any objects
;; that are in use at full-gc time are like to remain in use forever.
;; The second element of each sublist controls list regions, the third
;; structure regions.  PROPERTY-LIST-AREA is deliberately not on this
;; list, but perhaps it should be.

(DEFVAR FULL-GC-AREAS-WHOSE-EXISTING-OBJECTS-BECOME-STATIC
	'((WORKING-STORAGE-AREA T T)
	  (FLAVOR::*FLAVOR-AREA* T T)
	  (TV:SHEET-AREA NIL T)
	  (TV:BLINKER-AREA T T)
	  (TV:WHO-LINE-AREA NIL T)))

;; Static areas cleaned up by FULL-GC
(DEFVAR FULL-GC-STATIC-AREAS
	'(PKG-AREA			;Packages may have grown.
	  FS:PATHNAME-AREA		;This contains garbage as of system 222.
	  NETI:*NAMESPACE-OBJECT-AREA*	;Clean up unreferenced objects.
	  TV:*FONT-AREA*
	  ))

;; These areas have regions which are static, but which should be GC'd every
;; FULL-GC (not just SYSTEM-RELEASE).  All regions are remade static after FULL-GC.
(DEFVAR FULL-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC
	'(PROPERTY-LIST-AREA
	  ))

;; Static areas cleaned up by FULL-GC :SYSTEM-RELEASE T
(DEFCONST FULL-GC-SYSTEM-RELEASE-STATIC-AREAS
	  '(PNAME-AREA				;Because of GC-PNAMES
	    PERMANENT-STORAGE-AREA		;I don't know why any more
	    DEBUG-INFO-AREA			;In case FULL-GC :SYSTEM-RELEASE T is done twice
	     ))


;; Run a full gc with the intention of compressing the band immediately thereafter.
;;  1.  Reset temporary areas
;;  2.  Setup static areas to be cleaned up.
;;  3.  Flip.
;;  4.  Scavenge and flush oldspace.
;;  5.  Make static areas static again.
;;
;; This doesn't use the CLEAN-UP-STATIC-AREA hack because we would have to flip twice
;; to make them static again.

;; The :SYSTEM-RELEASE keyword argument enables extra things done only when
;; releasing a system, but not normally done by users when compressing their
;; own bands.

;; Compiled functions are not GC'd here, since that causes them to be
;; poorly ordered in memory, noticeably decreasing paging performance.
;; However, when :SYSTEM-RELEASE is specified, pointers to obsolete
;; compiled functions are removed, so REORDER-MEMORY will cause the
;; obsolete functions to be GC'd.

(DEFUN FULL-GC (&REST ARGS &KEY SYSTEM-RELEASE &ALLOW-OTHER-KEYS)
  (DECLARE (ARGLIST &KEY SYSTEM-RELEASE DEBUG-INFO SOURCE-FILE-NAMES REMOVE-VC-INFO))
  (LET ((GC-STATE (IF GC-ON (COPYLIST GC-ON) '(:DYNAMIC NIL :EPHEMERAL NIL)))
	(*FULL-GC-FOR-SYSTEM-RELEASE* SYSTEM-RELEASE))	;So inits can know.
    (UNWIND-PROTECT
	(PROGN
	  (WHEN SYSTEM-RELEASE
	    (FORMAT ERROR-OUTPUT
  "~&Use of the :SYSTEM-RELEASE option to SI:FULL-GC is reserved to Symbolics.~@
     Use by customers is not recommended or supported."))
	  (WHEN SYSTEM-RELEASE
	    (REMOVE-POINTERS-TO-COMPILED-FUNCTIONS))	;Must be done first.
	  (INITIALIZATIONS 'BEFORE-FULL-GC-INITIALIZATION-LIST T)
	  (GC-OFF)
	  (GC-RECLAIM-OLDSPACE)			;make sure that there is no oldspace
	  (WITHOUT-INTERRUPTS
	    (LET ((GC-REPORT-STREAM STANDARD-OUTPUT)
		  (GC-WARNINGS-ENABLE T)
		  (GC-REPORTS-ENABLE T)
		  (GC-AREA-RECLAIM-REPORT T)
		  (GC-RECLAIM-IMMEDIATELY T)
		  (NETI:*INHIBIT-VALIDITY-CHECKING* T)
		  ;; Don't hit a more-break while without-interrupts.
		  (TV:MORE-PROCESSING-GLOBAL-ENABLE NIL)
		  (AUX-GC-STATIC-AREAS NIL)
		  (AUX-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC NIL))
	      (INCF *FULL-GC-COUNT*)
	      (WHEN SYSTEM-RELEASE
		(INCF *SYSTEM-RELEASE-GC-COUNT*))
	      (INITIALIZATIONS 'FULL-GC-INITIALIZATION-LIST T)
	      (MULTIPLE-VALUE (AUX-GC-STATIC-AREAS
			       AUX-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC)
		(APPLY #'AUX-GC-BEFORE-FLIP ARGS))
	      #+3600 (WHEN SYSTEM-RELEASE
		       (GC-PERMANENT-OBJECTS))	;Should be after other initializations
	      (CDR-CODE-ALL-PLISTS)		;Must be after all other initializations
	      (WHEN SYSTEM-RELEASE
		(LOOP FOR (AREA . TYPES) IN FULL-GC-AREAS-WHOSE-EXISTING-OBJECTS-BECOME-STATIC
		      DO (MAKE-AREA-DYNAMIC (SYMEVAL AREA)))
		(LOOP FOR AREA IN FULL-GC-SYSTEM-RELEASE-STATIC-AREAS
		      DO (MAKE-AREA-DYNAMIC (SYMEVAL AREA))))
	      (LOOP FOR AREA IN FULL-GC-STATIC-AREAS
		    DO (MAKE-AREA-DYNAMIC (SYMEVAL AREA)))
	      (LOOP FOR AREA IN FULL-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC
		    DO (MAKE-AREA-DYNAMIC (SYMEVAL AREA)))
	      (LOOP FOR AREA IN AUX-GC-STATIC-AREAS
		    DO (MAKE-AREA-DYNAMIC (SYMEVAL AREA)))
	      (LOOP FOR AREA IN AUX-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC
		    DO (MAKE-AREA-DYNAMIC (SYMEVAL AREA)))
	      (GC-FLIP-NOW :INSUFFICIENT-ADDRESS-SPACE-ACTION :PROCEED)
	      (GC-RECLAIM-OLDSPACE)
	      (WHEN SYSTEM-RELEASE
		(LOOP FOR (AREA . TYPES) IN FULL-GC-AREAS-WHOSE-EXISTING-OBJECTS-BECOME-STATIC
		      DO (MAKE-AREA-REGIONS-PERMANENT (SYMEVAL AREA) TYPES))
		(LOOP FOR AREA IN FULL-GC-SYSTEM-RELEASE-STATIC-AREAS
		      DO (MAKE-AREA-STATIC-INTERNAL (SYMEVAL AREA))))
	      (LOOP FOR AREA IN AUX-GC-STATIC-AREAS
		    DO (MAKE-AREA-STATIC-INTERNAL (SYMEVAL AREA)))
	      (LOOP FOR AREA IN AUX-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC
		    DO (MAKE-AREA-REGIONS-PERMANENT (SYMEVAL AREA) '(T T)))
	      (LOOP FOR AREA IN FULL-GC-STATIC-AREAS
		    DO (MAKE-AREA-STATIC-INTERNAL (SYMEVAL AREA)))
	      (LOOP FOR AREA IN FULL-GC-DYNAMIC-AREAS-WHOSE-REGIONS-BECOME-STATIC
		    DO (MAKE-AREA-REGIONS-PERMANENT (SYMEVAL AREA) '(T T)))
	      (APPLY #'AUX-GC-AFTER-FLIP ARGS)
	      (INITIALIZATIONS 'AFTER-FULL-GC-INITIALIZATION-LIST T))))
      (CL:APPLY #'GC-ON :QUERY-P NIL GC-STATE))))

) ;;#+ignore

;;;  This is used by WITH-PROGRESS-REPORT for most of the Full GC initializations.

(DEFUN PROGRESS-REPORT-FUNCTION (TEXT CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (FORMAT T "~&Beginning ~A..." TEXT)
  (LET ((START-TIME (TIME)))
    (FUNCALL CONTINUATION)
    (LET ((TIME (TIME-DIFFERENCE (TIME) START-TIME)))
      (FORMAT T "~&...Done ~A -- process took " TEXT)
      (TIME:PRINT-INTERVAL-OR-NEVER (ROUND TIME 60.))
      (TYO #/.)
      TIME)))

;; This hack eliminates duplicate strings from PNAME-AREA
;; by structure-forwarding them.  In System 211.54 (A-machine), this got back
;; 133222. out of 370412. words in PNAME-AREA in 5 minutes.  Total of 36166 distinct strings.
;; This buys very little on the L machine, indicating that most of those strings weren't pnames.
;; The corresponding hack for extended numbers is fast, but only gets you 1267. words.
;;
;;--- This could work in :LAYERED-IDS-RELEASE by only sharing from new symbols.
(DEFINE-GC-OPTIMIZATION GC-PNAMES :LAYERED-SYSTEM-RELEASE
  (:ORDER (:BEFORE COMPRESS-DEBUG-INFO))
  (:DOCUMENTATION "Share pnames of interned symbols between packages")
  (:BEFORE-FLIP (IGNORE)
    (SI:WITH-PROGRESS-REPORT ("eliminating duplicate print names")
      (USING-SYSTEM-TEMPORARY-AREA
	(LET ((TABLE (CL:MAKE-HASH-TABLE
		       :SIZE 100000. :GROWTH-FACTOR 2.0 :AREA SYSTEM-TEMPORARY-AREA
		       :TEST #'SI:PKG-COMPARE-PNAMES :HASH-FUNCTION #'SI:SXHASH-STRING
		       :LOCKING NIL :STORE-HASH-CODE T :NUMBER-OF-VALUES 0))
	      (WORDS-SAVED 0)
	      (STRINGS-SAVED 0))
	  (SI:MAP-OVER-OBJECTS-IN-AREA
	    PNAME-AREA #'REGION-PREDICATE-STRUCTURE
	    #'(LAMBDA (IGNORE IGNORE STRING ADDR SIZE)
		(WHEN (AND (= (%P-DATA-TYPE ADDR) DTP-HEADER-I)
			   (STRINGP STRING)
			   (NOT (ARRAY-HAS-LEADER-P STRING))
			   (NOT (ARRAY-DISPLACED-P STRING)))
		  (SCL:MODIFY-HASH TABLE STRING
				   #'(LAMBDA (KEY IGNORE FOUNDP)
				       ;;(DECLARE (SYS:DOWNWARD-FUNCTION))
				       (COND (FOUNDP
					      (STRUCTURE-FORWARD STRING KEY)
					      (INCF STRINGS-SAVED)
					      (INCF WORDS-SAVED SIZE)
					      KEY)
					     (T KEY)))))))
	  (GC-OPTIMIZATION-REPORT "~%Reclaimed ~:D strings occupying ~:D words in PNAME-AREA,~@
		  leaving a total of ~:D distinct strings."
				  STRINGS-SAVED WORDS-SAVED (CL:HASH-TABLE-COUNT TABLE)))))))

(DEFINE-GC-OPTIMIZATION LOCALIZE-DEFVARS SYMBOLICS-SYSTEM-RELEASE
  (:DOCUMENTATION "Localize some system structures")
  (:BEFORE-FLIP (IGNORE)
    (DOLIST (SYMBOL *LOCALIZED-DEFVARS*)
      (LET ((TREE-P T))
	(WHEN (CL:CONSP SYMBOL)
	  (SETQ SYMBOL (FIRST SYMBOL)
		TREE-P (SECOND SYMBOL)))
	(SET SYMBOL (LET* ((OLD (SYMEVAL SYMBOL))
			   (AREA (%AREA-NUMBER OLD)))
		      (SELECTQ TREE-P
			((T) (COPYTREE OLD AREA))
			((1) (COPYLIST OLD AREA))
			(OTHERWISE (LOCALIZE-TREE OLD TREE-P AREA)))))))))

#| These aren't supported anymore.  Maybe make a compatible interface someday... |

;;; Make a dynamic area static.  On the next flip, when it's all been compacted
;;; into new/copy space, change the space-type to static.
(DEFUN MAKE-AREA-STATIC (AREA)
  (CHECK-ARG AREA (AND (NUMBERP AREA) ( AREA 0) (< AREA (N-AREAS)))
	     "an area number")
  (PUSH `(MAKE-AREA-STATIC-INTERNAL ,AREA) GC-NEXT-FLIP-LIST)
  T)

(DEFUN MAKE-AREA-STATIC-INTERNAL (AREA)
  (WITHOUT-INTERRUPTS
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-BITS AREA-REGION-LIST REGION-LIST-THREAD
				  REGION-BITS)
      (SETF (AREA-REGION-BITS AREA)
	    (%LOGDPBS 1 %%REGION-SCAVENGE-ENABLE
		      %REGION-SPACE-STATIC %%REGION-SPACE-TYPE
		      (AREA-REGION-BITS AREA)))
      (DO-AREA-REGIONS (REGION AREA)
	(LET ((BITS (REGION-BITS REGION)))
	  (WHEN (AND (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-NEW)
		     (NOT (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL BITS))))
	    (SETF (REGION-BITS REGION)
		  (%LOGDPBS 1 %%REGION-SCAVENGE-ENABLE
			    %REGION-SPACE-STATIC %%REGION-SPACE-TYPE BITS))))))))

;;; Make existing regions in this area STATIC, and not available for consing.
(DEFUN MAKE-AREA-REGIONS-PERMANENT (AREA TYPES)
  (WITHOUT-INTERRUPTS
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD REGION-BITS)
      (DO-AREA-REGIONS (REGION AREA)
	(LET ((BITS (REGION-BITS REGION)))
	  (WHEN (AND (NTH (LDB %%REGION-REPRESENTATION-TYPE BITS) TYPES)
		     (OR (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-NEW)
			 (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-COPY))
		     (NOT (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL BITS))))
	    (SETF (REGION-BITS REGION)
		  (%LOGDPBS 1			 %%REGION-NO-CONS
			    1			 %%REGION-SCAVENGE-ENABLE
			    %REGION-SPACE-STATIC %%REGION-SPACE-TYPE
			    BITS))
	    (SHORTEN-REGION REGION)))))))

;;; Make a static area dynamic.  This can happen right away, although it really
;;; only takes effect on the next flip, when the area will acquire its first oldspace.
(DEFUN MAKE-AREA-DYNAMIC (AREA)
  (CHECK-ARG AREA (AND (NUMBERP AREA) ( AREA 0) (< AREA (N-AREAS)))
	     "an area number")
  (WITHOUT-INTERRUPTS
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-BITS AREA-REGION-LIST REGION-LIST-THREAD)
      (SETF (AREA-REGION-BITS AREA)
	    (%LOGDPB (IF %GC-FLIP-READY 0 1) %%REGION-SCAVENGE-ENABLE
		     (%LOGDPB %REGION-SPACE-NEW %%REGION-SPACE-TYPE (AREA-REGION-BITS AREA))))
      (DO-AREA-REGIONS (REGION AREA)
	(MAKE-REGION-DYNAMIC REGION)))))

;;; Anything that flips a static region must go through this function so that
;;; %GC-STATIC-GENERATION-NUMBER is properly maintained.
(DEFUN MAKE-REGION-DYNAMIC (REGION)
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS)
    (LET ((BITS (REGION-BITS REGION)))
      (WHEN (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-STATIC)
	(SETQ *STATIC-GC-FLAG* T)
	(SETF (REGION-BITS REGION)
	      (%LOGDPB (IF %GC-FLIP-READY 0 1) %%REGION-SCAVENGE-ENABLE
		       (%LOGDPB %REGION-SPACE-NEW %%REGION-SPACE-TYPE BITS)))
	NIL))))

;;; "Clean up" a static area by garbage collecting it once, thus compactifying
;;; it and freeing anything it points to.  This works by changing the area to dynamic,
;;; then after the next flip it will all be in oldspace.  On the flip after that,
;;; the non-garbage contents will have moved into new/copy space, and we can change
;;; the area's type back to static.  Note, while all this is going on, you better
;;; not change your mind.
(DEFUN CLEAN-UP-STATIC-AREA (AREA)
  (CHECK-ARG AREA (AND (NUMBERP AREA)
		       ( AREA 0)
		       (< AREA (N-AREAS))
		       (= (LDB %%REGION-SPACE-TYPE (AREA-REGION-BITS AREA))
			  %REGION-SPACE-STATIC))
	     "the area number of a static area")
  (PUSH `(MAKE-AREA-STATIC-INTERNAL ,AREA) GC-SECOND-NEXT-FLIP-LIST)
  (MAKE-AREA-DYNAMIC AREA))

(DEFUN MAKE-AREA-TEMPORARY (AREA &OPTIONAL (TEMPORARY-P T) &AUX X)
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-BITS AREA-REGION-LIST REGION-LIST-THREAD
				REGION-BITS)
    (SETQ X (IF TEMPORARY-P 1 0))
    (SETF (AREA-REGION-BITS AREA)
	  (%LOGDPB X %%REGION-TEMPORARY (AREA-REGION-BITS AREA)))
    (DO-AREA-REGIONS (REGION AREA)
      (SETF (REGION-BITS REGION) (%LOGDPB X %%REGION-TEMPORARY (REGION-BITS REGION))))
    TEMPORARY-P))

||#

;;; Hook for DISK-SAVE

(DEFUN GC-ALL-EPHEMERAL-OBJECTS-TO-DYNAMIC-SPACE-IMMEDIATELY ()
  "Internal function for Incremental Disk Save"
  ;; Bind this to NIL so the resulting world doesn't have notifications in it about this flip.
  (LET ((SI:GC-EPHEMERAL-REPORTS-ENABLE NIL))
    (WITH-EPHEMERAL-MIGRATION-MODE :DYNAMIC
      ;; This contortion is necessary to make sure we flip all ephemeral
      ;; levels.  If we aren't careful, we could enter here with the EGC
      ;; already running.  We wait for it to finish, but when it finishes,
      ;; it may flip behind our back and not flip everything.  Therefore,
      ;; we have to wait again.
      (LOOP DOING (PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION "GC ready to flip" 0.25
		    #'(LAMBDA () (AND %GC-FLIP-READY GC-RECLAIMED-OLDSPACE)))
	    UNTIL (LET-GLOBALLY ((GC-IMMEDIATELY-IN-PROGRESS T))
		    (PROG1 (WITHOUT-INTERRUPTS
			     (WHEN %GC-FLIP-READY
			       (EPHEMERAL-GC-FLIP -1)
			       T))		;this causes the loop to exit
			   (GC-RECLAIM-OLDSPACE)))))))

(DEFVAR *COLD-BOOT-GC-GENERATION-NUMBER*		-1)
(DEFVAR *COLD-BOOT-GC-DYNAMIC-GENERATION-NUMBER*	-1)
(DEFVAR *COLD-BOOT-GC-STATIC-GENERATION-NUMBER*		-1)

(DEFUN GC-SHUTDOWN ()
  (WHEN (VARIABLE-BOUNDP GC-PROCESS)
    (SEND GC-PROCESS :FLUSH))			;Disable flipper process
  (GC-RECLAIM-OLDSPACE)
  (DOLIST (GC-METER *GC-METERS*)
    (SET GC-METER 0))
  (SETQ LAST-GC-WARNING-WORDS NIL
	LAST-GC-IMMEDIATELY-WARNING-WORDS NIL
	LAST-GC-TOO-LATE-WARNING-WORDS NIL
	LAST-GC-WARNING-TIME-ALIST NIL
	GC-IMMEDIATELY-IN-PROGRESS NIL
	NESTED-INHIBIT-GC-FLIPS-FLAG NIL
	GC-FLIP-INHIBIT 0)
  (SETQ *COLD-BOOT-GC-GENERATION-NUMBER* %GC-GENERATION-NUMBER
	*COLD-BOOT-GC-DYNAMIC-GENERATION-NUMBER* %GC-DYNAMIC-GENERATION-NUMBER
	*COLD-BOOT-GC-STATIC-GENERATION-NUMBER* %GC-STATIC-GENERATION-NUMBER)
  NIL)

(ADD-INITIALIZATION "Reset GC variables" '(GC-SHUTDOWN) '(SYSTEM-SHUTDOWN))

;;; GC-Daemon facility.

;;; A GC-daemon is a set of address-space conditions to wait for, and a
;;; function to run (in a separate process) when conditions are met.

;;; This simple process implements the queue
(DEFVAR GC-DAEMON-PROCESS)

;;; Each element on this queue is a list at least four long:
;;;	(name function region-cons-alarm page-cons-alarm)
;;; If either alarm is  the value in the queue, the function is called
;;; in a background process with the queue element as its argument.
;;; If any oldspace is reclaimed, all entries on the queue go off, since the
;;; allocation of address space has just changed.  This may need improvement
;;; in the future, when oldspace reclamation is more frequent.
(DEFVAR GC-DAEMON-QUEUE NIL)

(DEFVAR GC-DAEMON-PAGE-CONS-ALARM 0)
(DEFVAR GC-DAEMON-REGION-CONS-ALARM 0)

;;; Add to the queue.  Arguments are how many more regions and pages 
;;; must be consed before the function goes off.  If you want your
;;; queue element to be more than four long, pre-create it and pass it in
(DEFUN GC-DAEMON-QUEUE (NAME FUNCTION N-REGIONS N-PAGES &OPTIONAL ELEM)
  (OR ELEM (SETQ ELEM (ASSQ NAME GC-DAEMON-QUEUE)) (SETQ ELEM (LIST NAME FUNCTION NIL NIL)))
  (WITHOUT-INTERRUPTS
    (SETF (THIRD ELEM) (+ %REGION-CONS-ALARM N-REGIONS))
    (SETF (FOURTH ELEM) (+ (GC-PAGE-CONS-ALARM) N-PAGES))
    (OR (MEMQ ELEM GC-DAEMON-QUEUE)
	(PUSH ELEM GC-DAEMON-QUEUE))
    (SETQ GC-DAEMON-PAGE-CONS-ALARM CL:MOST-NEGATIVE-FIXNUM)))	;Wake up daemon process

(DEFUN GC-DAEMON-PREDICATE ()
  (OR ( %REGION-CONS-ALARM GC-DAEMON-REGION-CONS-ALARM)
      ( (GC-PAGE-CONS-ALARM) GC-DAEMON-PAGE-CONS-ALARM)))

;;; This is the function that runs in the GC Daemon process
(DEFUN GC-DAEMON-FUNCTION ()
  ;; Fire off any interesting queue entries
  (DOLIST (ELEM GC-DAEMON-QUEUE)
    (WHEN (OR ( %REGION-CONS-ALARM (THIRD ELEM))
	      ( (GC-PAGE-CONS-ALARM) (FOURTH ELEM)))
      (SETQ GC-DAEMON-QUEUE (DELQ ELEM GC-DAEMON-QUEUE))
      (FUNCALL (SECOND ELEM) ELEM)))
  ;; Cause process to sleep until next interesting time
  (IF GC-DAEMON-QUEUE
      (SETQ GC-DAEMON-REGION-CONS-ALARM (LOOP FOR ELEM IN GC-DAEMON-QUEUE
					      MINIMIZE (THIRD ELEM))
	    GC-DAEMON-PAGE-CONS-ALARM (LOOP FOR ELEM IN GC-DAEMON-QUEUE
					    MINIMIZE (FOURTH ELEM)))
      (SETQ GC-DAEMON-REGION-CONS-ALARM
	    (SETQ GC-DAEMON-PAGE-CONS-ALARM CL:MOST-POSITIVE-FIXNUM)))
  (START-POLLING-GC-DAEMON))

(DEFUN START-GC-DAEMON ()
  (UNLESS (VARIABLE-BOUNDP GC-DAEMON-PROCESS)
    (SETQ GC-DAEMON-PROCESS (PROCESS:MAKE-PROCESS "GC Daemon"
			      :SIMPLE-P T :SYSTEM-PROCESS T
			      :INITIAL-FUNCTION #'GC-DAEMON-FUNCTION
			      :INITIAL-FUNCTION-ARGUMENTS NIL
			      :VERIFY-FUNCTION #'GC-DAEMON-PREDICATE
			      :VERIFY-FUNCTION-ARGUMENTS NIL
			      :TOP-LEVEL-WHOSTATE "GC Daemon"
			      :RUN-REASONS NIL
			      :PRIORITY (PROCESS:MAKE-PROCESS-PRIORITY :FOREGROUND
								       GC-DAEMON-PRIORITY)
			      :WARM-BOOT-ACTION 'GC-DAEMON-RESTART))
    (SETF (PROCESS::PROCESS-WAIT-RECORD GC-DAEMON-PROCESS)
	  (ALLOCATE-RESOURCE 'PROCESS::WAIT-SLOTS))
    (PROCESS:ENABLE GC-DAEMON-PROCESS))
  (START-POLLING-GC-DAEMON))

(DEFUN START-POLLING-GC-DAEMON ()
  ;; Make sure this process gets polled
  (LET ((WAITER (PROCESS::PROCESS-WAIT-RECORD GC-DAEMON-PROCESS)))
    (SETF (PROCESS::WAITING-PROCESS-INTERVAL WAITER) (// 1 PROCESS:*TIMER-UNITS*))
    (SETF (PROCESS::WAITING-PROCESS-PROCESS WAITER) GC-DAEMON-PROCESS)
    (SETF (PROCESS::WAITING-PROCESS-WAIT-FUNCTION WAITER) #'GC-DAEMON-PREDICATE)
    (SETF (PROCESS::WAITING-PROCESS-ARGS WAITER) NIL)
    (SETF (PROCESS::WAITING-PROCESS-TIME-LAST-POLLED WAITER) (SYS:%MICROSECOND-CLOCK))
    (PROCESS::WITH-WAITERS-LOCKED (WAITERS)
      (PROCESS::ADD-WAITER-TO-QUEUE WAITER WAITERS)
      (SETF PROCESS::*PROCESS-WAITERS* 'T)
      (UNLESS (PROCESS:TIMER-PENDING-P PROCESS::*WAIT-FUNCTION-TIMER*)
	(PROCESS:RESET-TIMER-RELATIVE PROCESS::*WAIT-FUNCTION-TIMER* 1)))))

(DEFUN GC-DAEMON-RESTART (P)
  (GC-DAEMON-REQUEUE)
  (START-POLLING-GC-DAEMON)
  (PROCESS:PROCESS-WARM-BOOT-DELAYED-RESTART P))

(DEFUN GC-DAEMON-REQUEUE ()
  ;; %REGION-CONS-ALARM and (GC-PAGE-CONS-ALARM) have changed unpredictably
  ;; so schedule all gc-daemons to go off almost immediately
  (DOLIST (ELEM GC-DAEMON-QUEUE)
    (GC-DAEMON-QUEUE (FIRST ELEM) (SECOND ELEM) 1 1 ELEM)))

(PUSH* '(GC-DAEMON-REQUEUE) GC-AFTER-FLIP-LIST)

;;; GC-daemon that tells you that you had better turn on the garbage collector
(DEFUN GC-NEEDS-TO-BE-TURNED-ON (ELEM &AUX THRESHOLD WARNING-THRESHOLD)
  (MULTIPLE-VALUE-BIND (COMMITTED AVAILABLE IMMEDIATE-COMMITTED)
      (GC-GET-COMMITTED-FREE-SPACE)
    (SETQ COMMITTED (FIX (* COMMITTED GC-FLIP-RATIO))
	  IMMEDIATE-COMMITTED (FIX (* IMMEDIATE-COMMITTED GC-FLIP-RATIO))
	  WARNING-THRESHOLD (IF (CL:GETF GC-ON ':EPHEMERAL)
				GC-WARNING-EPHEMERAL-THRESHOLD
				GC-WARNING-THRESHOLD))
    (COND ((OR (CL:GETF GC-ON ':DYNAMIC) GC-IMMEDIATELY-IN-PROGRESS)
	   ;; The dynamic GC is on or an immediate garbage collection is in progress,
	   ;; so don't hassle the guy, just wait for a little while
	   ;; (128K of consing) then see if the GC has turned itself off.
	   (SETQ THRESHOLD (- AVAILABLE 400000)))
	  ((> IMMEDIATE-COMMITTED AVAILABLE)
	   ;; It's too late for any form of garbage collection.
	   (WHEN (OR (NULL LAST-GC-TOO-LATE-WARNING-WORDS)
		     (> (* LAST-GC-TOO-LATE-WARNING-WORDS GC-WARNING-RATIO)
			AVAILABLE))
	     (GC-WARNING :MISSED-IMMEDIATE-GC
"GC: You may have missed your last chance to perform a ~:\SI:GC-COMMAND\
command.  There are ~:D words of address space left.
Use the ~\SI:GC-COMMAND\ command for more information."
			 `(COM-START-GC :IMMEDIATELY ) AVAILABLE `(COM-SHOW-GC-STATUS))
	     (SETQ LAST-GC-TOO-LATE-WARNING-WORDS AVAILABLE))
	   (SETQ THRESHOLD (FIX (* LAST-GC-TOO-LATE-WARNING-WORDS GC-WARNING-RATIO))))
	  ((AND (> COMMITTED AVAILABLE) LAST-GC-WARNING-WORDS)
	   ;; It's too late for dynamic garbage collection, and we haven't said so yet.
	   (GC-WARNING :MISSED-DYNAMIC-GC
"GC: You may have missed your last chance to perform a ~:\SI:GC-COMMAND\
command.  There are ~:D words of address space left.
Use the ~\SI:GC-COMMAND\ command for more information."
		      `(COM-START-GC :DYNAMIC ) AVAILABLE `(COM-SHOW-GC-STATUS))
	   (SETQ LAST-GC-WARNING-WORDS NIL)
	   ;; Wake up when the last chance to :Start GC :Immediately approaches.
	   (SETQ THRESHOLD (- AVAILABLE
			      (// (- AVAILABLE (+ IMMEDIATE-COMMITTED WARNING-THRESHOLD))
				  4))))
	  ((AND (> COMMITTED AVAILABLE)
		(< (- AVAILABLE IMMEDIATE-COMMITTED) WARNING-THRESHOLD))
	   ;; It's too late for dynamic garbage collection, and the time for immediate
	   ;; garbage collection is approaching.
	   ;; Will not get here if GC-RECLAIM-IMMEDIATELY is set.
	   (WHEN (OR (NULL LAST-GC-IMMEDIATELY-WARNING-WORDS)
		     (> (* LAST-GC-IMMEDIATELY-WARNING-WORDS GC-WARNING-RATIO)
			(- AVAILABLE IMMEDIATE-COMMITTED)))
	     (GC-WARNING :NEED-IMMEDIATE-GC
"GC: Only ~:D more words of address space can be used before it will be too
late to perform a ~:\SI:GC-COMMAND\ command.  A total of ~:D words remain.
Use the ~\SI:GC-COMMAND\ command for more information."
			 (- AVAILABLE IMMEDIATE-COMMITTED) `(COM-START-GC :IMMEDIATELY )
			 AVAILABLE `(COM-SHOW-GC-STATUS))
	     (SETQ LAST-GC-IMMEDIATELY-WARNING-WORDS (- AVAILABLE IMMEDIATE-COMMITTED)))
	   (SETQ THRESHOLD (MAX (FIX (* LAST-GC-IMMEDIATELY-WARNING-WORDS GC-WARNING-RATIO))
				(- AVAILABLE (// (- AVAILABLE IMMEDIATE-COMMITTED) 4)))))
	  ((> COMMITTED AVAILABLE)
	   ;; The time for immediate garbage collection is not yet approaching, and the
	   ;; time for dynamic garbage collection has already passed.
	   ;; Wake up when the last chance to :Start GC :Immediately approaches.
	   (SETQ THRESHOLD (- AVAILABLE
			      (// (- AVAILABLE (+ IMMEDIATE-COMMITTED WARNING-THRESHOLD))
				  4))))
	  ((< (- AVAILABLE COMMITTED) WARNING-THRESHOLD)
	   ;; The last chance for :Start GC :Dynamic is approaching.
	   (WHEN (OR (NULL LAST-GC-WARNING-WORDS)
		     (> (* LAST-GC-WARNING-WORDS GC-WARNING-RATIO)
			(- AVAILABLE COMMITTED)))
	     (GC-WARNING :NEED-DYNAMIC-GC 
"GC: Only ~:D more words of address space can be used before it will be too
late to perform a ~:\SI:GC-COMMAND\ command.  A total of ~:D words remain.
Use the ~\SI:GC-COMMAND\ command for more information."
			 (- AVAILABLE COMMITTED) `(COM-START-GC :DYNAMIC )
			 AVAILABLE `(COM-SHOW-GC-STATUS))
	     (SETQ LAST-GC-WARNING-WORDS (- AVAILABLE COMMITTED)))
	   (SETQ THRESHOLD (MAX (FIX (* LAST-GC-WARNING-WORDS GC-WARNING-RATIO))
				(- AVAILABLE (// (- AVAILABLE COMMITTED) 4)))))
	  (T ;; Nothing to say yet, wait until gc-warning-threshold is approached
	     (SETQ THRESHOLD
		   (- AVAILABLE (// (- AVAILABLE (+ COMMITTED WARNING-THRESHOLD)) 4)))))
    ;; Re-queue self until AVAILABLE drops below THRESHOLD
    (GC-DAEMON-QUEUE 'GC-NEEDS-TO-BE-TURNED-ON 'GC-NEEDS-TO-BE-TURNED-ON
		     7777777			;don't care about regions
		     (// (- AVAILABLE THRESHOLD) PAGE-SIZE)
		     ELEM)))

;;; GC-daemon that watches for exhaustion of address space

;;; Controlling parameters:
;;; Amount of free space at which to start complaining, fraction by which to go down
(DEFCONST ADDRESS-SPACE-WARNING-LOW-WORDS 1000000.)
(DEFCONST ADDRESS-SPACE-WARNING-LOW-REGIONS 50.)
(DEFCONST ADDRESS-SPACE-WARNING-WORDS-RATIO 0.75)
(DEFCONST ADDRESS-SPACE-WARNING-REGIONS-RATIO 0.75)
;; These two are where it last notified the user (infinity initially)
(DEFVAR ADDRESS-SPACE-WARNING-WORDS CL:MOST-POSITIVE-FIXNUM)
(DEFVAR ADDRESS-SPACE-WARNING-REGIONS CL:MOST-POSITIVE-FIXNUM)

(DEFUN ADDRESS-SPACE-WARNING (ELEM &AUX (COMPLAIN NIL) FREE-WORDS)
  ;; Is it time to complain?
  (LET ((FREE-REGIONS (NUMBER-OF-FREE-REGIONS)))
    (MULTIPLE-VALUE (NIL NIL FREE-WORDS) (GC-GET-SPACE-SIZES))
    (COND ((AND ( FREE-WORDS ADDRESS-SPACE-WARNING-LOW-WORDS)
		( FREE-REGIONS ADDRESS-SPACE-WARNING-LOW-REGIONS))
	   ;; No need to complain at all, and reset complaint threshold in case
	   ;; more paging space was added.  Don't reset all the way to infinity,
	   ;; as we don't want to get a lot of extra warnings if due to EGC the
	   ;; free space is hovering right around ADDRESS-SPACE-WARNING-LOW-WORDS.
	   (SETQ ADDRESS-SPACE-WARNING-WORDS
		   (FLOOR (* FREE-WORDS ADDRESS-SPACE-WARNING-WORDS-RATIO))
		 ADDRESS-SPACE-WARNING-REGIONS
		   (FLOOR (* FREE-REGIONS ADDRESS-SPACE-WARNING-REGIONS-RATIO))))
	  ((OR (< FREE-WORDS
		  (* ADDRESS-SPACE-WARNING-WORDS ADDRESS-SPACE-WARNING-WORDS-RATIO))
	       (< FREE-REGIONS
		  (* ADDRESS-SPACE-WARNING-REGIONS ADDRESS-SPACE-WARNING-REGIONS-RATIO)))
	   ;; Time to complain again, space significantly lower than last time
	   (SETQ COMPLAIN '<
		 ADDRESS-SPACE-WARNING-WORDS FREE-WORDS
		 ADDRESS-SPACE-WARNING-REGIONS FREE-REGIONS))
	  ((AND (> FREE-REGIONS
		   (// ADDRESS-SPACE-WARNING-LOW-REGIONS ADDRESS-SPACE-WARNING-REGIONS-RATIO))
		(> FREE-WORDS
		   (// ADDRESS-SPACE-WARNING-LOW-WORDS ADDRESS-SPACE-WARNING-WORDS-RATIO)))
	   ;; Significantly more space than there was before, let user know
	   (SETQ COMPLAIN '>
		 ADDRESS-SPACE-WARNING-WORDS FREE-WORDS
		 ADDRESS-SPACE-WARNING-REGIONS FREE-REGIONS)))
    ;; Re-queue self until enough more space is used up that either we reach the point
    ;; to start complaining, or the amount free decreases by the ratio parameter.
    (GC-DAEMON-QUEUE 'ADDRESS-SPACE-WARNING 'ADDRESS-SPACE-WARNING
		     (IF (> FREE-REGIONS ADDRESS-SPACE-WARNING-LOW-REGIONS)
			 (- FREE-REGIONS ADDRESS-SPACE-WARNING-LOW-REGIONS)
			 (FIX (* FREE-REGIONS (- 1 ADDRESS-SPACE-WARNING-REGIONS-RATIO))))
		     (IF (> FREE-WORDS ADDRESS-SPACE-WARNING-LOW-WORDS)
			 (// (- FREE-WORDS ADDRESS-SPACE-WARNING-LOW-WORDS) PAGE-SIZE)
			 (FIX (* (// FREE-WORDS PAGE-SIZE)
				 (- 1 ADDRESS-SPACE-WARNING-WORDS-RATIO))))
		     ELEM)
    ;; If suppose to complain, do so
    (AND COMPLAIN
	 (TV:NOTIFY NIL "~:[Address space low!  ~]~
You have ~D region~:P and ~:D word~:P of address space left.
If space runs out, the machine will crash."
		    (EQ COMPLAIN '>) FREE-REGIONS FREE-WORDS))))

;;; Scavenger Control ---Change this

(DEFVAR-SAFEGUARDED *SCAVENGE-IN-PROGRESS* NIL)	;Bound to T by scavenger
(DEFVAR-SAFEGUARDED *SCAVENGER-STATE*)	;One of the symbols RESIDENT-PAGES, ESRT, COPYSPACE

;; *SCAVENGER-RESIDENT-PAGES-STATE* is now in STORAGE, since on Ivory
;; it has to reset it.

;;; Meters

(DEFUN PRINT-GC-METER-INTERNAL (STRING MILLISECONDS PAGE-FETCHES TIMES)
  (FORMAT T "~%~20A ~14:D ~9:D  ~9:D"
	  STRING TIMES (ROUND MILLISECONDS 1000.) PAGE-FETCHES)
  (UNLESS (ZEROP TIMES)
    (FORMAT T "     ~4,1,8$  ~4,1,8$"
	    (// (FLOAT MILLISECONDS) TIMES) (// (FLOAT PAGE-FETCHES) TIMES))))

(DEFUN PRINT-GC-METERS ()
  (FORMAT T "~&Operation~28T# Times~39TSeconds~47TPage Fetches~62Tms//time~72Tpf//time")
  (FORMAT T "~%Transporter:")
  (PRINT-GC-METER-INTERNAL "  (from scavenger)" SCAVENGE-TRANSPORTER-MILLISECONDS
			   SCAVENGE-TRANSPORTER-PAGE-FETCHES SCAVENGE-TRANSPORTER-TIMES)
  (PRINT-GC-METER-INTERNAL "  (from user)"
			   (- TRANSPORTER-MILLISECONDS SCAVENGE-TRANSPORTER-MILLISECONDS)
			   (- TRANSPORTER-PAGE-FETCHES SCAVENGE-TRANSPORTER-PAGE-FETCHES)
			   (- TRANSPORTER-TIMES SCAVENGE-TRANSPORTER-TIMES))
  (PRINT-GC-METER-INTERNAL "  (total)" TRANSPORTER-MILLISECONDS
			   TRANSPORTER-PAGE-FETCHES TRANSPORTER-TIMES)
  (LET ((REAL-TOTAL-TRANSPORTER-WORDS (+ TOTAL-TRANSPORTER-WORDS TRANSPORTER-WORDS)))
    (UNLESS (ZEROP REAL-TOTAL-TRANSPORTER-WORDS)
      (FORMAT T "~%  (per word)~21T~14:D~61T~4,1,8$  ~4,1,8$"
	REAL-TOTAL-TRANSPORTER-WORDS
	(// (FLOAT TRANSPORTER-MILLISECONDS) REAL-TOTAL-TRANSPORTER-WORDS)
	(// (FLOAT TRANSPORTER-PAGE-FETCHES) REAL-TOTAL-TRANSPORTER-WORDS))))
  (FORMAT T "~%Scavenger:")
  (PRINT-GC-METER-INTERNAL "  (from CONS)" CONS-SCAVENGE-MILLISECONDS
			   CONS-SCAVENGE-PAGE-FETCHES CONS-SCAVENGE-TOTAL-TIMES)
  (PRINT-GC-METER-INTERNAL "     (per whack)" CONS-SCAVENGE-MILLISECONDS
			   CONS-SCAVENGE-PAGE-FETCHES CONS-SCAVENGE-TIMES)
  (PRINT-GC-METER-INTERNAL "  (idle//other)"
			   (- SCAVENGER-MILLISECONDS CONS-SCAVENGE-MILLISECONDS)
			   (- SCAVENGER-PAGE-FETCHES CONS-SCAVENGE-PAGE-FETCHES)
			   (- SCAVENGER-TOTAL-TIMES CONS-SCAVENGE-TOTAL-TIMES))
  (PRINT-GC-METER-INTERNAL "     (per whack)"
			   (- SCAVENGER-MILLISECONDS CONS-SCAVENGE-MILLISECONDS)
			   (- SCAVENGER-PAGE-FETCHES CONS-SCAVENGE-PAGE-FETCHES)
			   (- SCAVENGER-TIMES CONS-SCAVENGE-TIMES))
  (PRINT-GC-METER-INTERNAL "  (total)" SCAVENGER-MILLISECONDS
			   SCAVENGER-PAGE-FETCHES SCAVENGER-TIMES)
  (PRINT-GC-METER-INTERNAL "  (first pass)" SCAVENGER-FIRST-PASS-MILLISECONDS
			   SCAVENGER-FIRST-PASS-PAGE-FETCHES SCAVENGER-FIRST-PASS-TIMES)
  (LET ((SCAV-FIRST-PASS-WORDS (+ SCAVENGER-FIRST-PASS-TOTAL-WORDS
				  SCAVENGER-FIRST-PASS-WORDS)))
    (UNLESS (ZEROP SCAV-FIRST-PASS-WORDS)
      (FORMAT T "~%~4T(per word)~21T~14:D~61T~4,1,8$  ~4,1,8$"
	      SCAV-FIRST-PASS-WORDS
	      (// (FLOAT SCAVENGER-FIRST-PASS-MILLISECONDS) SCAV-FIRST-PASS-WORDS)
	      (// (FLOAT SCAVENGER-FIRST-PASS-PAGE-FETCHES) SCAV-FIRST-PASS-WORDS))))
  (PRINT-GC-METER-INTERNAL "  (final pass)" SCAVENGER-FINAL-PASS-MILLISECONDS
			   SCAVENGER-FINAL-PASS-PAGE-FETCHES SCAVENGER-FINAL-PASS-TIMES)
  (LET ((SCAV-FINAL-PASS-WORDS (+ SCAVENGER-FINAL-PASS-TOTAL-WORDS
				  SCAVENGER-FINAL-PASS-WORDS)))
    (UNLESS (ZEROP SCAV-FINAL-PASS-WORDS)
      (FORMAT T "~%~4T(per word)~21T~14:D~61T~4,1,8$  ~4,1,8$"
	      SCAV-FINAL-PASS-WORDS
	      (// (FLOAT SCAVENGER-FINAL-PASS-MILLISECONDS) SCAV-FINAL-PASS-WORDS)
	      (// (FLOAT SCAVENGER-FINAL-PASS-PAGE-FETCHES) SCAV-FINAL-PASS-WORDS))))
  (PRINT-GC-METER-INTERNAL "  (resident)" SCAVENGER-RESIDENT-PAGES-MILLISECONDS SCAVENGER-RESIDENT-PAGES-PAGE-FETCHES
			   SCAVENGER-RESIDENT-PAGES-TIMES)
  (LET ((SCAV-RESIDENT-PAGES-WORDS (+ SCAVENGER-RESIDENT-PAGES-TOTAL-WORDS
			    SCAVENGER-RESIDENT-PAGES-WORDS)))
    (UNLESS (ZEROP SCAV-RESIDENT-PAGES-WORDS)
      (FORMAT T "~%~4T(per page)~21T~14:D~61T~4,1,8$  ~4,1,8$"
	      (// SCAV-RESIDENT-PAGES-WORDS PAGE-SIZE)
	      (// (FLOAT SCAVENGER-RESIDENT-PAGES-MILLISECONDS) (// SCAV-RESIDENT-PAGES-WORDS PAGE-SIZE))
	      (// (FLOAT SCAVENGER-RESIDENT-PAGES-PAGE-FETCHES) (// SCAV-RESIDENT-PAGES-WORDS PAGE-SIZE)))))
  (PRINT-GC-METER-INTERNAL "  (ESRT)" SCAVENGER-ESRT-MILLISECONDS SCAVENGER-ESRT-PAGE-FETCHES
			   SCAVENGER-ESRT-TIMES)
  (LET ((SCAV-ESRT-WORDS (+ SCAVENGER-ESRT-TOTAL-WORDS
			    SCAVENGER-ESRT-WORDS)))
    (UNLESS (ZEROP SCAV-ESRT-WORDS)
      (FORMAT T "~%~4T(per page)~21T~14:D~61T~4,1,8$  ~4,1,8$"
	      (// SCAV-ESRT-WORDS PAGE-SIZE)
	      (// (FLOAT SCAVENGER-ESRT-MILLISECONDS) (// SCAV-ESRT-WORDS PAGE-SIZE))
	      (// (FLOAT SCAVENGER-ESRT-PAGE-FETCHES) (// SCAV-ESRT-WORDS PAGE-SIZE))))))

;;; Kludges to hide inter-machine incompatibilities

;Note that this number can be negative and can go up twice as fast as consing
;is actually occurring.  It is done this way because swap space can be used
;up by fragmentation and by things other than consing, especially copying of
;pages from the load file into the page file.
(DEFSUBST GC-PAGE-CONS-ALARM ()
  (- *COUNT-CREATED-PAGES*			;Goes up as space used by consing
     *COUNT-REMAINING-SWAP-PAGES*))		;Goes down as swap space exhausted

;Set region's length to its free-pointer
(DEFUN SHORTEN-REGION (REGION)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (WITHOUT-INTERRUPTS
    (CLEAR-CONS-CACHES)
    (WITH-FAST-STORAGE-ACCESSORS (REGION-FREE-POINTER)
      (LET ((NEW-LENGTH (%FIXNUM-CEILING (REGION-FREE-POINTER REGION)
					 %ADDRESS-SPACE-QUANTUM-SIZE)))
	(IF (ZEROP NEW-LENGTH)
	    (WITH-FAST-STORAGE-ACCESSORS (REGION-AREA AREA-REGION-LIST REGION-LIST-THREAD)
	      (LOOP WITH AREA = (REGION-AREA REGION)
		    FOR R = (AREA-REGION-LIST AREA) THEN (REGION-LIST-THREAD R)
		    AND P = NIL THEN R
		    UNTIL (= R REGION)
		    FINALLY (IF P (SETF (REGION-LIST-THREAD P) (REGION-LIST-THREAD R))
				(SETF (AREA-REGION-LIST AREA) (REGION-LIST-THREAD R))))
	      (%FREE-REGION REGION))
	    (WITH-FAST-STORAGE-ACCESSORS (REGION-QUANTUM-LENGTH REGION-CREATED-PAGES)
	      (LET ((CUR-LENGTH (REGION-QUANTUM-LENGTH REGION)))
		(WHEN (< NEW-LENGTH CUR-LENGTH)
		  (FREE-ADDRESS-SPACE (+ (REGION-QUANTUM-ORIGIN REGION) NEW-LENGTH)
				      (- CUR-LENGTH NEW-LENGTH)
				      REGION)
		  (WHEN (#+3600 < #+IMach %UNSIGNED-LESSP
			   (%LOGDPB NEW-LENGTH %%VMA-QUANTUM-NUM 0)
			   (REGION-CREATED-PAGES REGION))
		    (SETF (REGION-CREATED-PAGES REGION)
			  (%LOGDPB NEW-LENGTH %%VMA-QUANTUM-NUM 0)))
		  (SETF (REGION-QUANTUM-LENGTH REGION) NEW-LENGTH)))))))))

;;; Safeguarding
#| Obsolete, hopefully |

;;--- This is probably obsolete.
;;--- At best, it needs to be rethought.
(DEFVAR *SAFEGUARD-COMPILED-FUNCTION* NIL)	;Hook for GC-COMPILED-FUNCTIONS

;Set safeguard bits on all regions needed to run the transporter so they won't be flipped.
;We don't bother setting the safeguard bits on WIRED-CONTROL-TABLES, PAGE-TABLE-AREA,
;DISK-SAVE-AREA, GC-TABLE-AREA, and STACK-AREA, since no one will ever try to flip those.
(DEFUN SET-SAFEGUARD-BITS ()
  ;; Start by clearing all safeguard bits
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS)
    (CL:DOTIMES (REGION (N-REGIONS))
      (SETF (LDB %%REGION-SAFEGUARD (REGION-BITS REGION)) 0))
    ;; For now, safeguard everything known about by microcode, since we don't clear
    ;; oldspace pointers out of "the machine" yet.  (Some of this is protecting the
    ;; escape-functions, which needs to be done anyway.)  Also everything known
    ;; in the FEP communication area.  Not the System communication area, however.
    ;; There don't seem to be symbols for these.
    ;; Everything known about by the microcode is everything from the microcode
    ;; communication area through the microcode escape constants, except for the
    ;; other-stack-group-data, which are always stale when not running on aux stack.
    (FLET ((SAFEGUARD-BLOCK (POINTER LIMIT)
	     (LET (#+3600 (ADDRESS-SPACE-MAP *ADDRESS-SPACE-MAP*)
		   (SAFEGUARD-BLOCK-TYPE-MAP
		     '#.(LOOP WITH ARRAY = (MAKE-ARRAY (LENGTH *DATA-TYPES*) :TYPE ART-BOOLEAN)
			      FOR TYPE BELOW (LENGTH *DATA-TYPES*)
			      DO (SETF (AREF ARRAY TYPE)
				       (AND (%POINTER-TYPE-P TYPE)
					    ( TYPE DTP-SYMBOL)
					    ( TYPE DTP-NIL)
					    ( TYPE DTP-NULL)
					    ( TYPE DTP-ELEMENT-FORWARD)
					    #+IMach ( TYPE DTP-CALL-COMPILED-EVEN)
					    #+IMach ( TYPE DTP-CALL-COMPILED-EVEN-PREFETCH)
					    #+IMach ( TYPE DTP-CALL-COMPILED-ODD)
					    #+IMach ( TYPE DTP-CALL-COMPILED-ODD-PREFETCH)
					    #+IMach ( TYPE DTP-CALL-GENERIC)
					    #+IMach ( TYPE DTP-CALL-GENERIC-PREFETCH)
					    ))
			      FINALLY (RETURN ARRAY))))
	       (DECLARE (SYS:ARRAY-REGISTER #+3600 ADDRESS-SPACE-MAP SAFEGUARD-BLOCK-TYPE-MAP))
	       (SETQ POINTER (%POINTER POINTER)
		     LIMIT (%POINTER LIMIT))
	       (LOOP DO (WHEN (AREF SAFEGUARD-BLOCK-TYPE-MAP (%P-DATA-TYPE POINTER))
			  (LET ((REGION
				  #+3600 (AREF ADDRESS-SPACE-MAP
					       (LDB %%VMA-QUANTUM-NUM (%P-POINTER POINTER)))
				  #+IMach (%REGION-NUMBER (%P-POINTER POINTER))))
			    (WHEN (PROGN #+3600 (REGION-VALID-P REGION)
					 #+IMach REGION)
			      (SAFEGUARD-REGION REGION "reference from ~\SI:ADDRESS\"
						POINTER))))
			(INCF POINTER)
		     UNTIL (EQ POINTER LIMIT)))))
      #+3600  (SAFEGUARD-BLOCK 0 400)
      #+3600  (SAFEGUARD-BLOCK (SECOND (ASSQ 'A-MEMORY-VARIABLES *MAGIC-LOCATIONS*))
			       (SECOND (ASSQ 'OTHER-STACK-GROUP-DATA *MAGIC-LOCATIONS*)))
      #+3600  (SAFEGUARD-BLOCK (SECOND (ASSQ 'MICROCODE-CONSTANTS *MAGIC-LOCATIONS*))
			       (THIRD (ASSQ 'MICROCODE-ESCAPE-CONSTANTS *MAGIC-LOCATIONS*)))
      #+IMach (SAFEGUARD-BLOCK %TRAP-VECTOR-BASE
			       (+ %TRAP-VECTOR-BASE %TRAP-VECTOR-LENGTH)))
    ;; T and NIL would need to be safeguarded because there are copies of them in B-memory
    ;; but the cold-load generator has already taken care of that.
  
    ;; Getting to the point: safeguard everything needed to run the TRANSPORT-TRAP function.
    (SAFEGUARD-OBJECT #'TRANSPORT-TRAP)
    ;; Do just enough of the escape out of the microcode cons routines
    ;; to satisfy the needs of the transporter.  Trying to do more than
    ;; this will get into all sorts of trouble copying stack groups in GC-COMPILED-FUNCTIONS.
    #+3600 ;-----
    (SAFEGUARD-OBJECT #'%ALLOCATE-BLOCK)
    ;; If called for value, return T if only legally safeguardable areas have been safeguarded.
    ;; But avoid the calculation if the value is just going to be thrown away.
    (WHEN #+3600  ( (FRAME-VALUE-DISPOSITION (%STACK-FRAME-POINTER)) %CALL-FOR-EFFECT)
	  #+IMach ( (LDB %%CR.VALUE-DISPOSITION
			  (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		     VALUE-DISPOSITION-EFFECT)
      (WITH-FAST-STORAGE-ACCESSORS (LEVEL-TYPE REGION-BITS)
	(LOOP FOR REGION BELOW (N-REGIONS)
	      AS BITS = (REGION-BITS REGION)
	      WHEN (AND (LDB-TEST %%REGION-SAFEGUARD BITS)
			(> (LEVEL-TYPE (LDB %%REGION-LEVEL BITS)) %LEVEL-TYPE-SAFEGUARDED))
		DO ;(FORMAT T "~%Region ~O, Area ~S" REGION (AREA-NAME (REGION-AREA REGION)))
		   (RETURN NIL)
	      FINALLY (RETURN T))))))

(DEFCONST *REPORT-DYNAMIC-SAFEGUARDING* NIL)

(DEFUN SAFEGUARD-REGION (REGION REASON &REST ARGS)
  (WHEN (AND *REPORT-DYNAMIC-SAFEGUARDING*
	     (ZEROP (LDB %%REGION-SAFEGUARD (REGION-BITS REGION))))
    (FORMAT T "~&Safeguarding region ~O of ~A for ~?."
	    REGION (AREA-NAME (%AREA-NUMBER (REGION-ORIGIN REGION))) REASON ARGS))
  (SETF (LDB %%REGION-SAFEGUARD (REGION-BITS REGION)) 1)
  NIL)


;; Warning: Do not patch this variable directly, other systems and utilities dynamically
;; add to it.  PUSH or CONS, buster.
(DEFVAR *TRANSPORTER-UNSAFEGUARDED-REFERENCES*
	'(FERROR ERROR SIGNAL DBG:CHECK-ARG-1 DBG:CHECK-ARG-2
		 DBG:CHECK-TYPE-1 TRANSPORT-ERROR-INTERNAL SET-SAFEGUARD-BITS
		 TRANSPORT-ERROR-ADDITIONAL-INFO
		 ;; Only do the -TRANSPORT ones
		 %ALLOCATE-LIST-BLOCK-ESCAPE %ALLOCATE-STRUCTURE-BLOCK-ESCAPE
		 ;; This is really wired, not unsafeguarded, but we have to ignore it
		 ;; since it calls back into TRANSPORT-TRAP, which would cause infinite
		 ;; recursion in SAFEGUARDE-OBJECT.  Sigh.
		 #+IMach %BLOCK-TRANSPORT
		 ))

(DEFUN SAFEGUARD-OBJECT (OBJ)
  (MACROLET ((TYPE-MAP ()
	       ;; open-code %pointer-type-p and associated data-type checks via a table lookup
	       ;; Note that the compiler combines all references to this macro and
	       ;; actually makes only a single constant.  Nice of it.
	       ;; Exclude symbols because we happen to know that they are only referenced
	       ;; in error situations.  Exclude unbound markers for the same reason.
	       ;;--- I don't know why dtp-element-forward is excluded.
	       (LOOP WITH ARRAY = (MAKE-ARRAY (LENGTH *DATA-TYPES*) :TYPE ART-BOOLEAN)
		     FOR TYPE BELOW (LENGTH *DATA-TYPES*)
		     DO (SETF (AREF ARRAY TYPE)
			      (AND (%POINTER-TYPE-P TYPE)
				   ( TYPE DTP-SYMBOL)
				   ( TYPE DTP-NIL)
				   ( TYPE DTP-NULL)
				   ( TYPE DTP-ELEMENT-FORWARD)
				   #+IMach ( TYPE DTP-CALL-COMPILED-EVEN)
				   #+IMach ( TYPE DTP-CALL-COMPILED-EVEN-PREFETCH)
				   #+IMach ( TYPE DTP-CALL-COMPILED-ODD)
				   #+IMach ( TYPE DTP-CALL-COMPILED-ODD-PREFETCH)
				   #+IMach ( TYPE DTP-CALL-GENERIC)
				   #+IMach ( TYPE DTP-CALL-GENERIC-PREFETCH)
				   ))
		     FINALLY (RETURN ARRAY)))
	     (FAST-COMPILED-FUNCTION-NAME (COMPILED-FUNCTION)
	       #+3600
	       `(CAR (%P-CONTENTS-OFFSET ,COMPILED-FUNCTION
		       (- -2 (%P-LDB %%ENTRY-INSTRUCTION-TABLE-SIZE ,COMPILED-FUNCTION))))
	       #+IMach
	       `(LET ((.HDR. (%SET-TAG (%MEMORY-READ (%POINTER-PLUS ,COMPILED-FUNCTION
						       (- (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
						     :CYCLE-TYPE %MEMORY-SCAVENGE)
				      DTP-FIXNUM)))
		  (CAR (%MEMORY-READ (%POINTER-PLUS ,COMPILED-FUNCTION
				       (- (LDB CCA-TOTAL-SIZE .HDR.)
					  (LDB CCA-SUFFIX-SIZE .HDR.)
					  (DEFSTORAGE-SIZE COMPILED-FUNCTION))))))))
    (COND ((LOCATIVEP OBJ)			;Safeguard the cell and its contents
						;Don't safeguard other references from the
						;object containing the locative
	   (LET ((CONTENTS (AND (LOCATION-BOUNDP OBJ) (LOCATION-CONTENTS OBJ))))
	     ;; Don't safeguard functions only used for error handling.  Don't even
	     ;; safeguard cells containing them (presumed to be forwarded).
	     (UNLESS (AND (TYPEP CONTENTS ':COMPILED-FUNCTION)
			  (MEMQ (FAST-COMPILED-FUNCTION-NAME CONTENTS)
				*TRANSPORTER-UNSAFEGUARDED-REFERENCES*))
	       (LET ((REGION (%REGION-NUMBER OBJ)))
		 (WHEN REGION (SAFEGUARD-REGION REGION "locative ~S" OBJ)))
	       (WHEN (AREF (TYPE-MAP) (%DATA-TYPE CONTENTS))
		 ;; Be careful not to recurse infinitely on circular structures
		 ;; or traverse irrelevant variables
		 (COND ((EQ OBJ (LOCF *GC-HYSTERESIS*))
			(WHEN CONTENTS
			  (WHEN *REPORT-DYNAMIC-SAFEGUARDING*
			    (FORMAT T "~&Warning:  *GC-HYSTERESIS* is not NIL"))
			  (SAFEGUARD-REGION (%REGION-NUMBER CONTENTS) "object ~S" CONTENTS)))
		       ((EQ OBJ (LOCF *REORDERINGS*)))
		       (T (SAFEGUARD-OBJECT CONTENTS)))))))
	  ((TYPEP OBJ ':COMPILED-FUNCTION)	;Safeguard the function and what it calls
	   (LET ((REGION (%REGION-NUMBER OBJ)))
	     (WHEN (AND REGION
			;; Wired functions have to be written safely
			(NOT (= REGION WIRED-CONTROL-TABLES)))
	       (SAFEGUARD-REGION REGION "object ~S" OBJ)
	       (LET ((SAFEGUARD-OBJECT-TYPE-MAP (TYPE-MAP)))
		 (DECLARE (SYS:ARRAY-REGISTER SAFEGUARD-OBJECT-TYPE-MAP))
		 #+3600
		 (LOOP REPEAT (%P-LDB %%ENTRY-INSTRUCTION-TABLE-SIZE OBJ)
		       FOR P FIRST (%MAKE-POINTER-OFFSET DTP-LOCATIVE OBJ -1)
			     THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P -1)
		       WHEN (AREF SAFEGUARD-OBJECT-TYPE-MAP (%P-DATA-TYPE P))
			 DO (SAFEGUARD-OBJECT (LOCATION-CONTENTS P)))
		 #+IMach
		 (WITH-BLOCK-REGISTERS (2)	;Force callee-saves
		   (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS OBJ 1))
		   (LOOP AS WORD = (%BLOCK-READ 2 :CYCLE-TYPE %MEMORY-SCAVENGE
						  :SET-CDR-NEXT NIL :PREFETCH NIL)
			 AS TAG = (%TAG WORD)
			 UNTIL (= (LDB %%Q-CDR-CODE-WITHIN-TAG TAG) SEQUENCING-FENCE)
			 WHEN (AREF SAFEGUARD-OBJECT-TYPE-MAP (LDB %%Q-TYPE-WITHIN-TAG TAG))
			   DO (SAFEGUARD-OBJECT
				(IF (TYPE-MEMBER WORD DTP-EXTERNAL-VALUE-CELL-POINTER
						      DTP-LOCATIVE
						      DTP-CALL-INDIRECT
						      DTP-CALL-INDIRECT-PREFETCH)
				    (%SET-TAG WORD DTP-LOCATIVE)
				    WORD))))
		 (WHEN *SAFEGUARD-COMPILED-FUNCTION*
		   (FUNCALL *SAFEGUARD-COMPILED-FUNCTION* OBJ))))))
	  ((STRINGP OBJ))			;Don't safeguard strings (error messages)
	  ((OR (= (%DATA-TYPE OBJ) DTP-EVEN-PC)	;Don't infinite recurse on PC's, which are
	       (= (%DATA-TYPE OBJ) DTP-ODD-PC))) ;assumed to be within the same function
	  ((OR (ARRAYP OBJ) (LISTP OBJ) (SYMBOLP OBJ))	;Safeguard other objects
	   (LET ((REGION (%REGION-NUMBER OBJ)))
	     (WHEN REGION
	       ;; Safeguard the region the object is in.
	       ;; Safeguard the contents of lists, but not arrays (region tables, etc)
	       ;; or symbols (used in error situations only, hopefully).
	       (LOOP WITH OBJ = OBJ
		     DO (SAFEGUARD-REGION REGION "object ~S" OBJ)
		     WHILE (AND (LISTP OBJ) (NOT (ZEROP REGION)))
		     WHEN (AREF (TYPE-MAP) (%DATA-TYPE (CAR OBJ)))
		       DO (SAFEGUARD-OBJECT (CAR OBJ))
		     DO (SETQ OBJ (CDR OBJ))))))
	  (T (ERROR "Don't know how to safeguard ~S" OBJ)))))

||#

;;; ROOM command

;;; DEFVAR of ROOM moved to SYS: SYS; LDATA so that MAKE-AREA (called by BUILD-INITIAL-PACKAGES)
;;; doesn't trip over unbound variable.

;(ROOM) tells about the default areas
;(ROOM area1 area2...) tells about those areas
;(ROOM T) tells about all areas
;(ROOM NIL) prints only the header, does not do any areas
(DEFUN ROOM (&REST ARGS)
  (FORMAT T
   #+3600 "~&Highest address: ~D pages.  Pages in use: ~D.  Swap space available: ~D pages~%"
   #+imach "~&Pages in use: ~D.  Swap space available: ~D pages~%"
   #+3600 (FIND-MAX-ADDR)
	  (ESTIMATE-DISK-SAVE-SIZE) (SWAP-SPACE-AVAILABLE))
  (COND ((NULL ARGS)
	 (SETQ ARGS ROOM))
	((EQUAL ARGS '(T))
	 (FORMAT T "Unless otherwise noted, area names are in the SYSTEM package~%")
	 (SETQ ARGS AREA-LIST)))
  (COND ((NOT (EQUAL ARGS '(NIL)))
	 (DOLIST (AREA ARGS)
	   (ROOM-PRINT-AREA (IF (SYMBOLP AREA) (SYMEVAL AREA) AREA))))))

#+3600
;;; Find the highest address in the virtual memory.  If you call this without
;;; inhibiting interrupts, the result is not strictly correct since some
;;; other process could invalidate it at any time by CONSing.  However,
;;; it gives you a good idea and a lower bound.  The answer is in number
;;; of pages.
;;; This is pretty meaningless on post-CADRs.
(DEFUN FIND-MAX-ADDR ()
  (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS REGION-ORIGIN REGION-LENGTH)
    (DO ((REGION 0 (1+ REGION))
	 (MAX-ADDR 0)
	 (NREGIONS (N-REGIONS)))
	(( REGION NREGIONS)
	 (// MAX-ADDR PAGE-SIZE))
      ;; Check each region.  If it is free, ignore it.  Otherwise,
      ;; find the highest address of that region, and get the
      ;; highest such address.
      (UNLESS (= (LDB %%REGION-SPACE-TYPE (REGION-BITS REGION)) %REGION-SPACE-FREE)
	(LET ((MAX (+ (REGION-ORIGIN REGION) (REGION-LENGTH REGION))))
	  (WHEN (> MAX MAX-ADDR)
	    (SETQ MAX-ADDR MAX)))))))

(DEFUN ROOM-PRINT-AREA (AREA &AUX LENGTH USED N-REGIONS (PACKAGE PKG-SYSTEM-PACKAGE))
  (LET ((NAME (AREA-NAME AREA)))
    (COND ((NOT (NULL NAME))
	   (MULTIPLE-VALUE (LENGTH USED N-REGIONS)
	     (ROOM-GET-AREA-LENGTH-USED AREA))
	   (FORMAT T "~51,1,1,'.<~S~;(~D region~:P)~> ~DK allocated, ~DK used.~%"
		   NAME N-REGIONS
		   (// (+ LENGTH 1777) 2000) (// (+ USED 1777) 2000))))
    T))

(DEFUN ROOM-GET-AREA-LENGTH-USED (AREA &OPTIONAL LEVEL)
  (LET ((LENGTH 0)
	(USED 0)
	(N-REGIONS 0))
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD REGION-BITS
				  REGION-LENGTH REGION-FREE-POINTER)
      (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
      (DO-AREA-REGIONS (REGION AREA)
	(WHEN (OR (NULL LEVEL) (= (LDB %%REGION-LEVEL (REGION-BITS REGION)) LEVEL))
	  (INCF N-REGIONS)
	  (INCF LENGTH (REGION-LENGTH REGION))
	  (INCF USED (REGION-FREE-POINTER REGION))))
      (VALUES LENGTH USED N-REGIONS))))

;This is the number of disk pages in swap space not committed to extant pages and
;not already committed to pages past the free-pointer of extant regions.  This
;does not allow for the possible using-up of swap-space by bringing pages in
;from the load image.
(DEFUN SWAP-SPACE-AVAILABLE ()
  *COUNT-REMAINING-SWAP-PAGES*)

;;; Returns non-NIL if there are any wired pages in dynamic space.
;;; This is checked before flipping since wiredness is not preserved by transportation.
;;; The value actually returned is the address of the first wired dynamic page found.
;;; EPHEMERAL is NIL for dynamic flips, else a mask of ephemeral levels to be flipped.
;;;--- Instead of calling this every flip, wiring and unwiring should
;;;--- keep track of these things.
;;;--- This also needs to keep track of a finer grain...
(DEFUN WIRED-DYNAMIC-SPACE-P (EPHEMERAL)
  #+IMach
  (LET ((ZONE-COUNT-WIRED-PAGES STORAGE::*ZONE-COUNT-WIRED-PAGES*))
    (DECLARE (ARRAY-REGISTER ZONE-COUNT-WIRED-PAGES))
    (WHEN (AND (ZEROP (AREF ZONE-COUNT-WIRED-PAGES %EPHEMERAL-ZONE))
	       (OR EPHEMERAL
		   (WITH-FAST-STORAGE-ACCESSORS (ZONE-LEVEL LEVEL-TYPE)
		     (LOOP FOR ZONE FROM %FIRST-DYNAMIC-ZONE TO %LAST-DYNAMIC-ZONE
			   AS ZONE-LEVEL = (ZONE-LEVEL ZONE)
			   WHEN (AND (LEVEL-VALID-P ZONE-LEVEL)
				     ( (LEVEL-TYPE ZONE-LEVEL) %LEVEL-TYPE-DYNAMIC))
			     ALWAYS (ZEROP (AREF ZONE-COUNT-WIRED-PAGES ZONE))))))
      (RETURN-FROM WIRED-DYNAMIC-SPACE-P NIL)))
  #+VLM T
  ;; --- The only caller only uses this expensively computed address to
  ;; complain with!
  #-VLM
  (STORAGE::WITH-QUICK-MMPT-ACCESSORS
    (WITH-FAST-STORAGE-ACCESSORS (REGION-BITS LEVEL-TYPE)
      (LOOP FOR MMPT-INDEX FROM 0 BELOW STORAGE::*MMPT-SIZE*
	    AS MMPT-ENTRY = (STORAGE::MMPT-ENTRY MMPT-INDEX)
	    THEREIS (AND (ZEROP (STORAGE::MMPT-ENTRY-INVALID-VPN MMPT-ENTRY))
			 (= %MMPT-STATUS-WIRED (STORAGE::MMPT-ENTRY-STATUS MMPT-ENTRY))
			 ;; This saves extra calls to %REGION-NUMBER for wired and
			 ;; safeguarded objects.
			 #+imach ( (LDB (BYTE (1- (BYTE-SIZE %%VPN-ZONE-NUM))
					      (1+ (BYTE-POSITION %%VPN-ZONE-NUM)))
					 (STORAGE::MMPT-ENTRY-VPN MMPT-ENTRY))
				    (LSH %WIRED-ZONE -1))
			 (LET ((REGION-BITS (REGION-BITS
					      (%REGION-NUMBER
						(%LOGDPB (STORAGE::MMPT-ENTRY-VPN MMPT-ENTRY)
							 %%VMA-PAGE-NUM 0)))))
			   (SELECT (LDB %%REGION-SPACE-TYPE REGION-BITS)
			     ((%REGION-SPACE-NEW %REGION-SPACE-COPY)
			      (IF EPHEMERAL
				  (AND (EPHEMERAL-LEVEL-P (LDB %%REGION-LEVEL REGION-BITS))
				       (CL:LOGTEST (ROT 1 (LDB %%REGION-LEVEL REGION-BITS))
						   EPHEMERAL))
				  ( (LEVEL-TYPE (LDB %%REGION-LEVEL REGION-BITS))
				     %LEVEL-TYPE-DYNAMIC)))))
			 (%LOGDPB (STORAGE::MMPT-ENTRY-VPN MMPT-ENTRY)
				  %%VMA-PAGE-NUM 0))))))

;; Snap locatives to compiled functions
;;   VERBOSE causes this to print a summary.
;;   MODIFIED-ONLY causes references from unmodified pages not to be snapped.  This is
;;   useful to keep IDS size down, but currently it is not called anywhere.
;;   FORCE causes this to run regardless of what we think the optimization state is.
(DEFUN OPTIMIZE-COMPILED-FUNCTIONS (&OPTIONAL (VERBOSE T) (MODIFIED-ONLY NIL) (FORCE NIL)
				    &AUX (FORWARD-COUNT 0) (NOT-FORWARD-COUNT 0)
					 TIME1 TIME2)
  (IF (AND (NOT FORCE)
	   (LOOP DO
	     (CL:ECASE *COMPILED-FUNCTION-OPTIMIZATION-STATE*
	       ((NIL) (RETURN NIL))
	       ((T) (RETURN T))
	       ((:MODIFIED-ONLY) (RETURN MODIFIED-ONLY))
	       ((:OPTIMIZING)
		(PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION "Optimization Finish" 0.392
		  #'(LAMBDA () (NEQ *COMPILED-FUNCTION-OPTIMIZATION-STATE* :OPTIMIZING)))))))
      (WHEN VERBOSE
	(FORMAT T "~&No compiled functions need to be optimized."))
    ;; Optimizations seem necessary.
    (SETQ *COMPILED-FUNCTION-OPTIMIZATION-STATE* :OPTIMIZING)
    (SETQ TIME1 (TIME))
    (UNLESS *SYSOUT-ENABLED-P*
      (SETQ MODIFIED-ONLY NIL))
    (TV:NOTING-PROGRESS ("Optimizing compiled functions")
      (FLET ((AREA-PREDICATE (AREA)
	       (OR (= AREA WIRED-CONTROL-TABLES)
		   (= AREA SAFEGUARDED-OBJECTS-AREA)
		   (= AREA COMPILED-FUNCTION-AREA))))
	(LET ((TOTAL-SPACE 0)
	      (BASE 0))
	  (DECLARE (UNSPECIAL BASE))		;&^%$&^%$^&
	  ;; Quickly figure out how much memory we have to run over, for progress notes.
	  (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
	  (MAP-OVER-REGIONS #'AREA-PREDICATE #'REGION-PREDICATE-STRUCTURE
	    (LAMBDA (AREA REGION)
	      (DECLARE (IGNORE AREA))
	      (INCF TOTAL-SPACE (REGION-FREE-POINTER REGION))))
	  ;; Now run over it.
	  (WITH-PREFETCHING-DISABLED COMPILED-FUNCTION-AREA
	    (MAP-OVER-REGIONS #'AREA-PREDICATE #'REGION-PREDICATE-STRUCTURE
	      (LAMBDA (AREA REGION)
		(DECLARE (IGNORE AREA))
		(LET ((BASE-1 (- (REGION-ORIGIN REGION) BASE)))
		  (MAP-OVER-OBJECTS-IN-REGION REGION
		    (LAMBDA (ADDRESS HEADER LEADER SIZE)
		      (DECLARE (IGNORE SIZE))
		      (WHEN (TYPEP HEADER :COMPILED-FUNCTION)
			(TV:NOTE-PROGRESS (- ADDRESS BASE-1) TOTAL-SPACE)
			(MULTIPLE-VALUE-BIND (C1 C2)
			    (SNAP-FORWARDED-LOCATIVES LEADER MODIFIED-ONLY)
			  (INCF FORWARD-COUNT C1)
			  (INCF NOT-FORWARD-COUNT C2))))))
		(INCF BASE (REGION-FREE-POINTER REGION))))))))
    ;; Set the optimization state unless somebody has modified in another process
    (STORE-CONDITIONAL (LOCF *COMPILED-FUNCTION-OPTIMIZATION-STATE*)
		       :OPTIMIZING
		       (OR (ZEROP NOT-FORWARD-COUNT) :MODIFIED-ONLY))
    (SETQ TIME2 (TIME))
    (WHEN VERBOSE
      (FORMAT T "~&~6D reference~:P snapped from compiled functions." FORWARD-COUNT)
      (WHEN MODIFIED-ONLY
	(FORMAT T "~%~6D reference~:P from unmodified pages were not snapped."
		NOT-FORWARD-COUNT))
      (FORMAT T "~%Snapping references from compiled functions took ~\TIME-INTERVAL\."
	      (ROUND (TIME-DIFFERENCE TIME2 TIME1) 60.))))
  (VALUES FORWARD-COUNT NOT-FORWARD-COUNT))

#+3600
(DEFUN SNAP-FORWARDED-LOCATIVES (CCA &OPTIONAL MODIFIED-ONLY)
  (LET ((COUNT 0) (NOT-MODIFIED-COUNT 0))
    (LOOP FOR J FROM (DEFSTORAGE-SIZE COMPILED-FUNCTION)
	  REPEAT (COMPILED-FUNCTION-TABLE-SIZE CCA)
	  AS LOC = (%P-STRUCTURE-OFFSET CCA J)
	  WHEN (LOCATION-BOUNDP LOC)
	    DO (LET ((REF (LOCATION-CONTENTS LOC)))
		 (WHEN (LOCATIVEP REF)
		   ;; Might reference a compiled function or variable
		   (LET ((FORWARD (FOLLOW-CELL-FORWARDING REF NIL)))
		     ;; Don't write if not necessary.  This keeps
		     ;; the number of modified pages down for IDS.
		     (UNLESS (EQ REF FORWARD)
		       (IF (OR (NOT MODIFIED-ONLY)
			       (SYSOUT-BITMAP (LDB %%VMA-PAGE-NUM (%POINTER LOC))))
			   (PROGN (INCF COUNT)
				  (SETF (%P-CONTENTS-OFFSET CCA J) FORWARD))
			   (INCF NOT-MODIFIED-COUNT)))))))
    (VALUES COUNT NOT-MODIFIED-COUNT)))

#+IMach
(DEFUN SNAP-FORWARDED-LOCATIVES (CCA &OPTIONAL MODIFIED-ONLY)
  (LET ((COUNT 0) (NOT-MODIFIED-COUNT 0))
    (LOOP FOR J FROM (DEFSTORAGE-SIZE COMPILED-FUNCTION)
	  REPEAT (LET ((HEADER (%P-POINTER CCA)))
		   (- (LDB CCA-TOTAL-SIZE HEADER)
		      (LDB CCA-SUFFIX-SIZE HEADER)
		      (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
	  AS LOC = (%P-STRUCTURE-OFFSET CCA J)
	  DO (LET ((REF (%MEMORY-READ LOC :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL)))
	       (WHEN (OR (TYPE-MEMBER REF DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH)
			 (TYPE-MEMBER REF DTP-EXTERNAL-VALUE-CELL-POINTER)
			 (TYPE-MEMBER REF DTP-LOCATIVE))
		 ;; Might reference a compiled function or variable
		 ;; Follow forwarding pointers except for EVCPs
		 (LET ((FORWARD (%MEMORY-READ-ADDRESS REF :CYCLE-TYPE %MEMORY-BIND-READ)))
		   ;; Don't write if not necessary.  This keeps
		   ;; the number of modified pages down for IDS.
		   (UNLESS (EQ REF FORWARD)
		     (IF (OR (NOT MODIFIED-ONLY)
			     (SYSOUT-BITMAP (LDB %%VMA-PAGE-NUM (%POINTER LOC))))
			 (PROGN (INCF COUNT)
				(%MEMORY-WRITE LOC (%SET-TAG FORWARD (%TAG REF))))
			 (INCF NOT-MODIFIED-COUNT)))))))
    (VALUES COUNT NOT-MODIFIED-COUNT)))

(DEFUN OPTIMIZE-COMPILED-FUNCTIONS-BEFORE-COLD ()
  (OPTIMIZE-COMPILED-FUNCTIONS NIL *INCREMENTAL-DISK-SAVE*))

(ADD-INITIALIZATION "Optimize Compiled Functions"
		    '(OPTIMIZE-COMPILED-FUNCTIONS-BEFORE-COLD)
		    '(BEFORE-COLD))

(DEFINE-GC-OPTIMIZATION OPTIMIZE-COMPILED-FUNCTIONS :LAYERED-IDS-RELEASE
  (:DOCUMENTATION "Optimize references to redefined functions")
  (:BEFORE-FLIP (INCREMENTAL-P)
    (WITH-PROGRESS-REPORT-IF *ENABLE-GC-OPTIMIZATION-REPORTS* ("optimizing compiled functions")
      (OPTIMIZE-COMPILED-FUNCTIONS *ENABLE-GC-OPTIMIZATION-REPORTS* INCREMENTAL-P T))))

;; GC Cleanups.

(DEFPROP DEFINE-GC-CLEANUP "GC Cleanup" DEFINITION-TYPE-NAME)

;;(DEFVAR GC-CLEANUP-LIST ())		; In LDATA

(DEFMACRO DEFINE-GC-CLEANUP (NAME (&REST FQUERY-ARGS) &BODY BODY)
  `(PROGN (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-GC-CLEANUP)
	  (DEFPROP ,NAME ,FQUERY-ARGS GC-CLEANUP-QUERY-ARGS)
	  (CL:PUSHNEW ',NAME GC-CLEANUP-LIST)
	  (DEFUN (:PROPERTY ,NAME GC-CLEANUP) ()
	    (DECLARE (FUNCTION-PARENT ,NAME DEFINE-GC-CLEANUP))
	    . ,BODY)))

(DEFUN RUN-GC-CLEANUPS (&OPTIONAL QUERY (STREAM QUERY-IO))
  (LOOP FOR CLEANUP IN (IF (NOT QUERY) GC-CLEANUP-LIST
			 (DW:ACCEPTING-VALUES (STREAM)
			   (LET ((STRING "GC Cleanup Tasks"))
			     (DW:WITH-REDISPLAYABLE-OUTPUT (:UNIQUE-ID STRING
							    :CACHE-VALUE STRING
							    :STREAM STREAM)
			       (CL:WRITE-LINE STRING STREAM)))
			   (LOOP FOR CLEANUP IN GC-CLEANUP-LIST
				 AS QUERY = (GET CLEANUP 'GC-CLEANUP-QUERY-ARGS)
				 WHEN (OR (EQ QUERY T)
					  (ACCEPT 'BOOLEAN :STREAM STREAM
					    :PROMPT (STRING-APPEND "  "
						      (STRING-RIGHT-TRIM "? "
							(CL:APPLY #'CL:FORMAT NIL QUERY))
						      "?  ")
					    :PROMPT-MODE :RAW :DEFAULT T :PROVIDE-DEFAULT T))
				   COLLECT CLEANUP)))
	DO (FUNCALL (GET CLEANUP 'GC-CLEANUP))))

(DEFINE-GC-CLEANUP RESET-ALL-OUTPUT-HISTORIES ("Reset interactor output histories? ")
  (LET ((TV:*ASYNCHRONOUS-WINDOW-OPERATION* T))
    (MAP-OVER-OBJECTS-IN-AREA TV:SHEET-AREA #'REGION-PREDICATE-STRUCTURE
      (LAMBDA (REGION ADDRESS HEADER LEADER SIZE)
	(DECLARE (IGNORE REGION ADDRESS LEADER SIZE))
	(WHEN (AND (INSTANCEP HEADER)
		   (TYPEP HEADER 'TV:ESSENTIAL-WINDOW)
		   (SEND HEADER :INTERACTOR-P))
	  (SEND HEADER :CLEAR-HISTORY))))))

(DEFINE-GC-CLEANUP RESET-LISP-TOP-LEVEL-VARIABLES
		   ("Reset LISP-TOP-LEVEL variables such as ~S and ~S?" '* '+)
  (LET ((SYMBOLS '(- * ** *** + ++ +++ // //// //////)))
    (LOOP FOR SYMBOL IN SYMBOLS DO (SET SYMBOL NIL))
    (MAP-OVER-STACK-GROUP-SPECIAL-BINDINGS
      (LAMBDA (SG THING TYPE LOCATION)
	(DECLARE (IGNORE SG) (DOWNWARD-FUNCTION))
	(WHEN (AND (EQ TYPE :VARIABLE) (MEMQ THING SYMBOLS))
	  (SETF (LOCATION-CONTENTS LOCATION) NIL))))))

;;; Hacks to deal with safeguarding compiled functions.

(DEFSTRUCT (SCNODE :ARRAY :CONC-NAME)
  OBJECT
  STORAGE-CATEGORY
  DISABLE-REFERENCE-VALIDATION
  DECLARED-UNSAFEGUARDED-REFERENCES
  DECLARED-SAFEGUARDED-REFERENCES
  DECLARED-WIRED-REFERENCES
  UNSAFEGUARDED-REFERENCES
  SAFEGUARDED-REFERENCES
  WIRED-REFERENCES
  UNSAFEGUARDED-CALLERS
  SAFEGUARDED-CALLERS
  WIRED-CALLERS
  )

;; This looks for
;;   - Undeclared downward references (same as warnings)
;;   - Unbound downward references (same as warnings)
;;   - Nonexistent declared references
;;   - Wired/Safeguarded variables/functions which aren't referenced by wired/safeguarded code.
;;   - Lists all downward references and disable-reference-validation.
(DEFUN VERIFY-STORAGE-CATEGORIES ()
  (LET ((DATABASE (CL:MAKE-HASH-TABLE :TEST #'EQ :LOCKING NIL :SIZE 2500.)))
    (LABELS ((NOTE (FORMAT-STRING &REST FORMAT-ARGS)
	       (FORMAT T "~&Warning:  ")
	       (LEXPR-FUNCALL #'FORMAT T FORMAT-STRING FORMAT-ARGS))
	     (LEGAL-FOR-DISABLE-REFERENCE-VALIDATION (FUNC)
	       (OR #+3600 (= (LDB %%VMA-EQUALS-AMEM
				  (%POINTER (FOLLOW-CELL-FORWARDING
					      (FDEFINITION-LOCATION
						(COMPILED-FUNCTION-NAME FUNC))
					      NIL)))
			     %VMA-EQUALS-AMEM)
		   #+3600 (%BLOCK-SEARCH-EQ FUNC
			    (ALOC ARITHMETIC-UNARY-OPERATION-DISPATCH 0 0)
			    (* 12 6))
		   #+3600 (LOOP FOR ARRAY BEING THE ARRAY-ELEMENTS OF
				    ARITHMETIC-BINARY-OPERATION-DISPATCH
				THEREIS (%BLOCK-SEARCH-EQ FUNC
							  (ALOC ARRAY 0 0)
							  (* 6 6)))
		   #+IMach (%BLOCK-SEARCH-EQ (%MAKE-POINTER-OFFSET DTP-EVEN-PC FUNC 0)
					     %TRAP-VECTOR-BASE
					     %TRAP-VECTOR-LENGTH)
		   #+IMach (%BLOCK-SEARCH-EQ (%MAKE-POINTER-OFFSET DTP-EVEN-PC FUNC 1)
					     %TRAP-VECTOR-BASE
					     %TRAP-VECTOR-LENGTH)))
	     (GET-NODE (OBJECT)
	       (OR (CLI::FAST-TABLE-GET DATABASE OBJECT)
		   (LET ((NODE (MAKE-SCNODE OBJECT OBJECT
					    STORAGE-CATEGORY (ACTUAL-STORAGE-CATEGORY
							       :CONSTANT OBJECT))))
		     (SETF (CL:GETHASH OBJECT DATABASE) NODE)))))
      ;; First enter functions into the database
      (MAP-COMPILED-FUNCTIONS '(:WIRED :SAFEGUARDED) NIL
			      "Scanning wired and safeguarded functions"
	(LAMBDA (FUNCTION CCA &AUX NODE)
	  (WHEN (FUNCTION-SAME-AS-FUNCTION-FROM-NAME FUNCTION)
	    (SETQ NODE (GET-NODE FUNCTION))
	    (MULTIPLE-VALUE-BIND (FUNCTION-STORAGE-CATEGORY
				  DISABLE-REFERENCE-VALIDATION
				  WIRED-REFERENCES
				  SAFEGUARDED-REFERENCES
				  UNSAFEGUARDED-REFERENCES)
		(DECODE-STORAGE-CATEGORY-DEBUGGING-INFO
		  (CDR (CCA-EXTRA-INFO-FOR-DEBUGGING CCA)))
	      (UNLESS (EQ (ACTUAL-STORAGE-CATEGORY :CONSTANT FUNCTION)
			  FUNCTION-STORAGE-CATEGORY)
		(NOTE "~S is declared ~S, but is actually ~S"
		      (COMPILED-FUNCTION-NAME FUNCTION)
		      FUNCTION-STORAGE-CATEGORY
		      (ACTUAL-STORAGE-CATEGORY :CONSTANT FUNCTION)))
	      (WHEN DISABLE-REFERENCE-VALIDATION
		(SETF (SCNODE-DISABLE-REFERENCE-VALIDATION NODE) T)
		(UNLESS (LEGAL-FOR-DISABLE-REFERENCE-VALIDATION FUNCTION)
		  (NOTE "~S function ~S has reference validation disabled"
			FUNCTION-STORAGE-CATEGORY (COMPILED-FUNCTION-NAME FUNCTION))))
	      (SETF (SCNODE-DECLARED-WIRED-REFERENCES NODE)
		    WIRED-REFERENCES)
	      (SETF (SCNODE-DECLARED-SAFEGUARDED-REFERENCES NODE)
		    SAFEGUARDED-REFERENCES)
	      (SETF (SCNODE-DECLARED-UNSAFEGUARDED-REFERENCES NODE)
		    UNSAFEGUARDED-REFERENCES)
	      (FLET ((HACK-REF (TYPE REF &OPTIONAL IGNORE)
		       (SETQ REF
			     (CL:CASE TYPE
			       (:FUNCTION
				 (UNLESS (FDEFINEDP REF)
				   (NOTE "~S function ~S references ~
					   the undefined function ~S"
					 FUNCTION-STORAGE-CATEGORY
					 (COMPILED-FUNCTION-NAME FUNCTION)
					 REF)
				   (RETURN-FROM HACK-REF NIL))
				 (LET ((DEF (FDEFINITION REF)))
				   (UNLESS (TYPEP DEF :COMPILED-FUNCTION)
				     (NOTE "~S function ~S references ~S, ~@
					    ~10Xwhose definition is not a compiled function"
					   FUNCTION-STORAGE-CATEGORY
					   (COMPILED-FUNCTION-NAME FUNCTION)
					   REF)
				     (RETURN-FROM HACK-REF NIL))
				   DEF))
			       (:VARIABLE
				 (FOLLOW-CELL-FORWARDING
				   (VALUE-CELL-LOCATION REF) NIL))
			       (OTHERWISE
				 (UNLESS (%POINTERP REF)
				   (RETURN-FROM HACK-REF NIL))
				 REF)))
		       (LET ((REF-NODE (GET-NODE REF)))
			 (COND ((WIRED-P REF)
				(PUSH* REF-NODE (SCNODE-WIRED-REFERENCES NODE)))
			       ((SAFEGUARDED-P REF)
				(PUSH* REF-NODE (SCNODE-SAFEGUARDED-REFERENCES NODE)))
			       (T (PUSH* REF-NODE (SCNODE-UNSAFEGUARDED-REFERENCES NODE))))
			 (COND ((EQ FUNCTION-STORAGE-CATEGORY :WIRED)
				(PUSH* NODE (SCNODE-WIRED-CALLERS REF-NODE)))
			       ((EQ FUNCTION-STORAGE-CATEGORY :SAFEGUARDED)
				(PUSH* NODE (SCNODE-SAFEGUARDED-CALLERS REF-NODE)))
			       (T (PUSH* NODE (SCNODE-UNSAFEGUARDED-CALLERS REF-NODE)))))))
	      (DO-FUNCTION-REFERENCES (TYPE REF) FUNCTION
		(IF (AND (EQ TYPE :CONSTANT)
			 (NSYMBOLP REF))
		    (MAP-OVER-REFERENCE REF NIL #'HACK-REF)
		    (HACK-REF TYPE REF))))))))
      ;; Now scan the variables.
      (LET ((SAFEGUARDED-ORPHANS NIL)
	    (WIRED-ORPHANS NIL)
	    (ROOT-WIRED-FUNCTIONS NIL)
	    (ROOT-SAFEGUARDED-FUNCTIONS NIL)
	    (DOWNWARD-SAFEGUARDED-REFERENCES NIL)
	    (DOWNWARD-UNSAFEGUARDED-REFERENCES NIL))
	(DO-OBJECTS ((SYMBOL)
		     :REGION-PREDICATE #'REGION-PREDICATE-STRUCTURE
		     :AREA-PREDICATE #'(LAMBDA (AREA)
					 (OR #+IMach (= AREA WIRED-CONTROL-TABLES)
					     (= AREA SAFEGUARDED-OBJECTS-AREA)
					     (= AREA SYMBOL-AREA))))
	  (WHEN (SYMBOLP SYMBOL)
	    (LET ((ACTUAL (ACTUAL-STORAGE-CATEGORY :VARIABLE SYMBOL))
		  (DECLARED (CL:GET SYMBOL 'VARIABLE-STORAGE-CATEGORY :UNSAFEGUARDED)))
	      ;; If the symbol itself is wired or safeguarded and the
	      ;; value cell is unforwarded, treat the value cell as unsafeguarded.
	      (WHEN (AND (WIRED-OR-SAFEGUARDED-P SYMBOL)
			 (EQ (LOCF (SYMBOL-VALUE-CELL SYMBOL))
			     (FOLLOW-CELL-FORWARDING (LOCF (SYMBOL-VALUE-CELL SYMBOL)) NIL)))
		(SETQ ACTUAL :UNSAFEGUARDED))
	      (WHEN (NEQ ACTUAL DECLARED)
		;;--- Don't warn about symbols in the parallel package.
		;;--- This is a crock.
		(LET ((PKG (CL:SYMBOL-PACKAGE SYMBOL)))
		  (WHEN (OR (NULL PKG)
			    (LET ((NAME (PKG-NAME PKG)))
			      (NOT (OR (%STRING= NAME 0 "L" 0 2)
				       (%STRING= NAME 0 "I" 0 2)))))
		    (NOTE "Variable ~S is ~S but declared ~S" SYMBOL ACTUAL DECLARED))))
	      (LET* ((CELL (FOLLOW-CELL-FORWARDING (LOCF (SYMBOL-VALUE-CELL SYMBOL)) NIL))
		     (NODE (CLI::FAST-TABLE-GET DATABASE CELL)))
		(WHEN (AND (NEQ ACTUAL :UNSAFEGUARDED)
			   (OR (NULL NODE)
			       (IF (EQ ACTUAL :WIRED)
				   (NULL (SCNODE-WIRED-CALLERS NODE))
				   (NULL (SCNODE-SAFEGUARDED-CALLERS NODE)))))
		  ;; Don't issue this warning for communication variables.
		  ;; Assume they're there for some other purpose.
		  (UNLESS (LOOP FOR (NIL LOW HIGH) IN *MAGIC-LOCATIONS*
				THEREIS (AND (NOT (%POINTER-LESSP CELL LOW))
					     (%POINTER-LESSP CELL HIGH)))
		    (IF (EQ ACTUAL :SAFEGUARDED)
			(PUSH SYMBOL SAFEGUARDED-ORPHANS)
			(PUSH SYMBOL WIRED-ORPHANS))))))))
	;; Now scan the database...
	(MAPHASH (LAMBDA (OBJECT NODE)
		   (WHEN (TYPEP OBJECT :COMPILED-FUNCTION)
		     (LET ((STORAGE-CATEGORY (SCNODE-STORAGE-CATEGORY NODE)))
		       (UNLESS (EQ STORAGE-CATEGORY :UNSAFEGUARDED)
			 ;; Here we have a safeguarded or wired function.
			 (WHEN (IF (EQ STORAGE-CATEGORY :SAFEGUARDED)
				   (NULL (SCNODE-SAFEGUARDED-CALLERS NODE))
				   (NULL (SCNODE-WIRED-CALLERS NODE)))
			   (LET ((NAME (COMPILED-FUNCTION-NAME OBJECT)))
			     (IF (EQ STORAGE-CATEGORY :SAFEGUARDED)
				 (PUSH NAME ROOT-SAFEGUARDED-FUNCTIONS)
				 (PUSH NAME ROOT-WIRED-FUNCTIONS)))))
		       (LET ((DECLARED-SAFEGUARDED
			       (SCNODE-DECLARED-SAFEGUARDED-REFERENCES NODE))
			     (DECLARED-UNSAFEGUARDED
			       (SCNODE-DECLARED-UNSAFEGUARDED-REFERENCES NODE))
			     FOUND-SAFEGUARDED FOUND-UNSAFEGUARDED)
			 (LOOP FOR REF IN DECLARED-SAFEGUARDED
			       DO (PUSH* REF DOWNWARD-SAFEGUARDED-REFERENCES))
			 (LOOP FOR REF IN DECLARED-UNSAFEGUARDED
			       DO (PUSH* REF DOWNWARD-UNSAFEGUARDED-REFERENCES))
			 (UNLESS (SCNODE-DISABLE-REFERENCE-VALIDATION NODE)
			   (FLET ((DECODE-REF (REF)
				    (TYPECASE REF
				      (:LOCATIVE
					(VALUES (COMPILER:DISASSEMBLE-DECODE-LOCATIVE REF)
						:VARIABLE))
				      (:COMPILED-FUNCTION
					(VALUES (COMPILED-FUNCTION-NAME REF)
						:FUNCTION))
				      (OTHERWISE (VALUES REF :CONSTANT)))))
			     (WHEN (EQ STORAGE-CATEGORY :WIRED)
			       (LOOP FOR REF IN (SCNODE-SAFEGUARDED-REFERENCES NODE) DOING
				 (SETQ REF (SCNODE-OBJECT REF))
				 (MULTIPLE-VALUE-BIND (REF-SYM REF-TYPE)
				     (DECODE-REF REF)
				   (IF (OR (MEMQ REF-SYM DECLARED-SAFEGUARDED)
					   (SYMBOLP REF))
				       (PUSH* REF-SYM FOUND-SAFEGUARDED)
				       (NOTE "~S Function ~S references ~S ~S ~S"
					     STORAGE-CATEGORY
					     (COMPILED-FUNCTION-NAME OBJECT)
					     (ACTUAL-STORAGE-CATEGORY :CONSTANT REF)
					     REF-TYPE REF-SYM)))))
			     (LOOP FOR REF IN (SCNODE-UNSAFEGUARDED-REFERENCES NODE) DOING
			       (SETQ REF (SCNODE-OBJECT REF))
			       (MULTIPLE-VALUE-BIND (REF-SYM REF-TYPE)
				   (DECODE-REF REF)
				 (IF (MEMQ REF-SYM DECLARED-UNSAFEGUARDED)
				     (PUSH* REF-SYM FOUND-UNSAFEGUARDED)
				     (NOTE "~S Function ~S references ~S ~S ~S"
					   STORAGE-CATEGORY
					   (COMPILED-FUNCTION-NAME OBJECT)
					   (ACTUAL-STORAGE-CATEGORY :CONSTANT REF)
					   REF-TYPE REF-SYM))))))
			 (LOOP FOR REF IN (APPEND (CL:SET-DIFFERENCE DECLARED-SAFEGUARDED
								     FOUND-SAFEGUARDED)
						  (CL:SET-DIFFERENCE DECLARED-UNSAFEGUARDED
								     FOUND-UNSAFEGUARDED))
			       DO (NOTE "Function ~S declares a reference to ~S, ~
					 but references no such object."
					(COMPILED-FUNCTION-NAME OBJECT)
					REF))))))
	       DATABASE)
	(LET ((PACKAGE NIL))
	  (FLET ((SORT-PREDICATE (X Y)
		   (STRING-LESSP (FORMAT NIL "~S" X)
				 (FORMAT NIL "~S" Y))))
	    (WHEN WIRED-ORPHANS
	      (FORMAT T "~2%The following variables are wired, ~
			    but not referenced from wired code:~{~%  ~S~}"
		      (SORT WIRED-ORPHANS #'SORT-PREDICATE)))
	    (WHEN SAFEGUARDED-ORPHANS
	      (FORMAT T "~2%The following variables are safeguarded, ~
			    but not referenced from safeguarded code:~{~%  ~S~}"
		      (SORT SAFEGUARDED-ORPHANS #'SORT-PREDICATE)))
	    (FORMAT T "~2%Found the following root wired functions:~{~%  ~S~}"
		    (SORT ROOT-WIRED-FUNCTIONS #'SORT-PREDICATE))
	    (FORMAT T "~2%Found the following root safeguarded functions:~{~%  ~S~}"
		    (SORT ROOT-SAFEGUARDED-FUNCTIONS #'SORT-PREDICATE))
	    (FORMAT T "~2%The safeguarded objects were referenced downwardly:~{~%  ~S~}"
		    (SORT DOWNWARD-SAFEGUARDED-REFERENCES #'SORT-PREDICATE))
	    (FORMAT T "~2%The unsafeguarded objects were referenced downwardly:~{~%  ~S~}"
		    (SORT DOWNWARD-UNSAFEGUARDED-REFERENCES #'SORT-PREDICATE))
	    DATABASE
	    ))))))

;;--- This needs to do better with symbols.
#+IGNORE
(DEFUN FIND-THINGS-WHICH-NEED-TO-BE-SAFEGUARDED
       (&OPTIONAL (PRINT-DECLARATIONS NIL) (STREAM STANDARD-OUTPUT))
  ;; Create a hash table of things that we have moved
  (LET ((COMPILED-FUNCTION-RELOCATIONS (CL:MAKE-HASH-TABLE)))
    (FLET ((TATTLE (FUNCTION &OPTIONAL PRINT-REFERENCE-DECLARATION &AUX REFS VARS)
	     (DECLARE (DOWNWARD-FUNCTION))
	     (SETQ FUNCTION (FDEFINITION (FUNCTION-NAME FUNCTION)))
	     (UNLESS (OR (STORAGE-CATEGORY-LESSP :UNSAFEGUARDED
						 (ACTUAL-STORAGE-CATEGORY :CONSTANT FUNCTION))
			 (GETHASH FUNCTION COMPILED-FUNCTION-RELOCATIONS))
	       (FORMAT STREAM "~%Function ~S" (FUNCTION-NAME FUNCTION))
	       (PUTHASH FUNCTION T COMPILED-FUNCTION-RELOCATIONS)
	       (PUTHASH (LOCF (COMPILED-FUNCTION-FUNCTION-CELL
				(COMPILED-FUNCTION-CCA FUNCTION)))
			T COMPILED-FUNCTION-RELOCATIONS)
	       (DO-FUNCTION-CONSTANTS (CONST) FUNCTION
		 (MAP-OVER-REFERENCE CONST NIL
		   (LAMBDA (TYPE REF IGNORE)
		     (WHEN (AND (EQ TYPE :VARIABLE)
				(NOT (STORAGE-CATEGORY-LESSP :UNSAFEGUARDED
				       (ACTUAL-STORAGE-CATEGORY :VARIABLE REF)))
				(NOT (GETHASH CONST COMPILED-FUNCTION-RELOCATIONS)))
		       (PUSH REF VARS)
		       (PUTHASH CONST T COMPILED-FUNCTION-RELOCATIONS))
		     (WHEN (AND PRINT-REFERENCE-DECLARATION
				(OR (MEMQ TYPE '(:VARIABLE :FUNCTION))
				    (SYMBOLP REF))
				(MEMQ (DECLARED-STORAGE-CATEGORY TYPE REF NIL)
				      '(NIL :UNSAFEGUARDED))
				(NOT (MEMQ REF REFS)))
		       (PUSH REF REFS)))))
	       (WHEN REFS
		 (LET ((PACKAGE (IF (SYMBOLP (FUNCTION-NAME FUNCTION))
				    (SYMBOL-PACKAGE (FUNCTION-NAME FUNCTION))
				    PKG-GLOBAL-PACKAGE)))
		   (FORMAT STREAM "~%  (UNSAFEGUARDED-REFERENCE ~S" (CAR REFS))
		   (LOOP FOR REF IN (CDR REFS) DO
		     (FORMAT STREAM "~%                           ~S" REF))
		   (FORMAT STREAM ")")))
	       (DOLIST (VAR VARS)
		 (FORMAT STREAM "~%Variable ~S" VAR)))))
      ;; Copy all escape functions known by microcode
      (LET ((MAGIC (ASSQ 'MICROCODE-ESCAPE-ROUTINES *MAGIC-LOCATIONS*)))
	(LOOP FOR P = (SECOND MAGIC) THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)
	      UNTIL (EQ P (THIRD MAGIC)) DO
	  (WHEN (LOCATION-BOUNDP P)
	    (LET ((PC (LOCATION-CONTENTS P)))
	      (UNLESS (STORAGE-CATEGORY-LESSP :UNSAFEGUARDED
					      (ACTUAL-STORAGE-CATEGORY :CONSTANT PC))
		(FORMAT STREAM "~%Escape PC ~S" PC)
		(PUTHASH PC T COMPILED-FUNCTION-RELOCATIONS))))))
      ;; Copy all functions needed by garbage collector (transporter and flipper)
      (LET ((*SAFEGUARD-COMPILED-FUNCTION* #'TATTLE))
	(SET-SAFEGUARD-BITS)
	(SAFEGUARD-OBJECT #'GC-FLIP-AREAS))
      ;; Allow sequence breaks to have a chance, if we're going to have sequence breaks.
      (TATTLE #'MAYBE-PREEMPT-CURRENT-PROCESS PRINT-DECLARATIONS)
      ;; Copy all other functions known about by microcode, but don't copy what they call.
      ;; This copy is just to prevent extra regions from getting safeguarded.
      (LOOP WITH START = (SECOND (ASSQ 'MICROCODE-CONSTANTS *MAGIC-LOCATIONS*))
	    WITH LIMIT = (THIRD (ASSQ 'MICROCODE-ESCAPE-CONSTANTS *MAGIC-LOCATIONS*))
	    FOR P = START THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)
	    UNTIL (EQ P LIMIT)
	    WHEN (AND (LOCATION-BOUNDP P)
		      (TYPEP (LOCATION-CONTENTS P) :COMPILED-FUNCTION)
		      (= (%AREA-NUMBER (LOCATION-CONTENTS P)) COMPILED-FUNCTION-AREA))
	      DO (TATTLE (LOCATION-CONTENTS P) PRINT-DECLARATIONS))))
  NIL)

;; Called by FULL-GC :SYSTEM-RELEASE T
(DEFUN REMOVE-POINTERS-TO-COMPILED-FUNCTIONS ()
  (WITH-PROGRESS-REPORT ("removing garbage pointers to compiled functions")
    ;; Get rid of all :PREVIOUS-DEFINITION properties
    (DO-ALL-SYMBOLS (X)
      (NREMPROP X :PREVIOUS-DEFINITION)
      (LET ((FL (AND X (FLAVOR:FIND-FLAVOR X NIL))))
	(WHEN FL
	  (DOLIST (MH (FLAVOR::FLAVOR-LOCAL-FUNCTIONS FL))
	    (NREMPROP (LOCF (FLAVOR::METHOD-HOLDER-PLIST MH)) :PREVIOUS-DEFINITION))
	  (DOLIST (MTE (FLAVOR::FLAVOR-METHOD-TABLE FL))
	    (DOLIST (MH (CDR MTE))
	      (NREMPROP (LOCF (FLAVOR::METHOD-HOLDER-PLIST MH)) :PREVIOUS-DEFINITION))))))
    ;; Get rid of :PREVIOUS-DEFINITION properties in various other hidey-holes
    ;; "Don't point like that; it's not polite"
    (REMHASH ':PREVIOUS-DEFINITION *FUNCTION-SPEC-HASH-TABLES*)
    (LOOP FOR MH BEING THE HASH-ELEMENTS OF FLAVOR::*UNDEFINED-METHOD-HASH-TABLE*
	  DO (NREMPROP (LOCF (FLAVOR::METHOD-HOLDER-PLIST MH)) :PREVIOUS-DEFINITION))
    ;; Remove pointers from function cell database.
    (RATIONALIZE-WAYWARD-FUNCTION-CELLS T)))

;;; Print various statistics
;;; Enhancements of 9/82 mostly thanks to RMS
(DEFUN GC-STATUS (&OPTIONAL (STREAM STANDARD-OUTPUT))
  ;; Status of ephemeral GC, including whether it is on
  (FORMAT STREAM "~&Status of the ephemeral garbage collector:~60T~:[Off~;On~]"
	  (GET (LOCF GC-ON) :EPHEMERAL))
  (LOOP FOR (AREA LEVEL) IN *EPHEMERAL-AREAS* DO
    (TERPRI STREAM)
    (LOOP FOR GENERATION FROM 1 WHILE (EPHEMERAL-LEVEL-P LEVEL) DO
      (MULTIPLE-VALUE-BIND (LENGTH USED)
	  (ROOM-GET-AREA-LENGTH-USED (SYMEVAL AREA) LEVEL)
	(FORMAT STREAM "~:(~:R~) level of ~S: capacity ~DK, ~DK allocated, ~DK used.~%"
		GENERATION AREA (CEILING (AREF *EPHEMERAL-GC-FLIP-CAPACITY* LEVEL) 2000)
		(CEILING LENGTH 2000) (CEILING USED 2000))
	(SETQ LEVEL (AREF *EPHEMERAL-GC-KEEP-NEXT-LEVEL* LEVEL)))))

  ;; Status of dynamic GC, including whether it is on
  (FORMAT STREAM "~2&Status of the dynamic garbage collector:~60T~:[Off~;On~]~%"
	  (GET (LOCF GC-ON) :DYNAMIC))
  (MULTIPLE-VALUE-BIND (COMMITTED-FREE-SPACE FREE-SPACE IMMEDIATE-COMMITTED-FREE-SPACE)
      (GC-GET-COMMITTED-FREE-SPACE)
    (MULTIPLE-VALUE-BIND (DYNAMIC-SIZE STATIC-SIZE FREE-SIZE OLD-SIZE)
	(GC-GET-SPACE-SIZES)
      (FORMAT STREAM "Dynamic (new+copy) space ~:D.  Old space ~:D.  Static space ~:D.~%"
	      DYNAMIC-SIZE OLD-SIZE STATIC-SIZE)
      (IF %GC-FLIP-READY
	  (LET ((COMMITTED (+ (FIX (* GC-FLIP-RATIO COMMITTED-FREE-SPACE)) GC-DELTA)))
	    (FORMAT STREAM "Free space ~:D.  Committed guess ~:D~
			    ~:[ times ratio (~4F) gives ~:D,~% ~;~*~*, ~]"
		      FREE-SPACE COMMITTED-FREE-SPACE
		      (= GC-FLIP-RATIO 1) GC-FLIP-RATIO COMMITTED)
	    (IF (> FREE-SPACE COMMITTED)
		(FORMAT STREAM "leaving ~:D to use before~:[~@
	your last chance to do ~:\SI:GC-COMMAND\ without risking running out of space~
			~; flipping~].~%"
		      (- FREE-SPACE COMMITTED) (GET (LOCF GC-ON) :DYNAMIC)
		      `(COM-START-GC :DYNAMIC ))
		(FORMAT STREAM "putting you ~:D words past the~@
	point where an incremental garbage collection risks running out of space.~%"
			(- COMMITTED FREE-SPACE)))
	    (COND (GC-IMMEDIATELY-IN-PROGRESS)
		  ((> FREE-SPACE IMMEDIATE-COMMITTED-FREE-SPACE)
		   (FORMAT STREAM "There are ~:D words available before ~
	~:\SI:GC-COMMAND\ might run out of space.~%"
			   (- FREE-SPACE IMMEDIATE-COMMITTED-FREE-SPACE)
			   `(COM-START-GC :IMMEDIATELY ))
		   (FORMAT STREAM "Doing ~:\SI:GC-COMMAND\ now would ~
					take roughly ~\TIME-INTERVAL\.~%"
			   `(COM-START-GC :IMMEDIATELY )
			   ;; In system 254, with 1024K physical memory, took 6.5 minutes to
			   ;; GC-IMMEDIATELY with 4.33MW static and 1.18MW dynamic space.
			   ;; These numbers crank that up to 9 minutes so we'll look good.
			   (* (ROUND (+ (* 8e-5 STATIC-SIZE) (* 15e-5 DYNAMIC-SIZE))
				     60.) 60.)))
		  (T (FORMAT STREAM
		      "There is not enough space left for ~:\SI:GC-COMMAND\ unless~@
			no more than ~D% of dynamic space is good data (not garbage).~%"
		      `(COM-START-GC :IMMEDIATELY )
		      (// (* FREE-SPACE 100.) IMMEDIATE-COMMITTED-FREE-SPACE))))
	    (LET ((IP (GC-IN-PLACE-TEMPORARY-STORAGE-ESTIMATE)))
	      (IF (> FREE-SPACE IP)
		  (FORMAT STREAM "There are ~:D words remaining before ~\SI:GC-COMMAND\~@
				  might run out of space.  (The current estimate of its~@
				  memory requirements is ~:D words.)~%"
			  (- FREE-SPACE IP) '(COM-START-GC :IMMEDIATELY :IN-PLACE) IP)
		  (FORMAT STREAM "There is not enough space left for ~\SI:GC-COMMAND\~@
				  to complete.  (The current estimate of its~@
				  memory requirements is ~:D words.)  There may be ~@
				  enough space for partial GC's using ~\SI:GC-COMMAND\.~%"
			  '(COM-START-GC :IMMEDIATELY :IN-PLACE) IP
			  '(COM-START-GC :IMMEDIATELY :IN-PLACE :SELECTIVE :YES))))
	    (FORMAT STREAM
		    "There are ~:D words available if you elect not to garbage collect.~%"
		    FREE-SPACE))
	  ;; Here if there is scavenging work still to be done, which implies that there
	  ;; is already a garbage collection in progress
	  (MULTIPLE-VALUE-BIND (WORK UNCERTAINTY)
	      (GET-MAX-GC-WORK-REMAINING)
	    (FORMAT STREAM "Minimum scavenging remaining ~:D, maximum possible ~:D.~@
			    Free space ~:D (of which ~:D might be needed for copying).~%"
		    (- WORK UNCERTAINTY) WORK
		    FREE-SIZE UNCERTAINTY)))))

  (MAYBE-WARN-ABOUT-SWAP-MIGRATION STREAM)

  ;; Status of the GC process and the scavenger
  (FORMAT STREAM "~%Garbage collector process state: ~A~%"
	  (COND ((NOT (VARIABLE-BOUNDP GC-PROCESS)) "Nonexistent")
		((PROCESS-ARREST-REASONS GC-PROCESS) "Arrested")
		((NOT (PROCESS:PROCESS-ACTIVE-P GC-PROCESS)) "Disabled")
		(T (PROCESS-WHOSTATE GC-PROCESS))))
  (UNLESS %GC-FLIP-READY
    (IF (NOT *TRANSPORTER-BREAK-WEAK-LINKS*)
	(FORMAT STREAM "The scavenger is busy finding old objects that are still ~
			in use and transporting~@
			them.  Currently it is ~A~%"
		(SELECTQ *SCAVENGER-STATE*
		  (RESIDENT-PAGES
		   "finding ephemeral objects referenced by pages in main memory.")
		  (ESRT "finding ephemeral objects referenced by pages on disk.")
		  (OTHERWISE "finding objects referenced by Copy space or Static space.")))
	(FORMAT STREAM "The scavenger is busy removing references to objects that ~
			no longer exist.  Currently ~@
			it is ~A~%"
		(SELECTQ *SCAVENGER-STATE*
		  (RESIDENT-PAGES
		   "finding ephemeral references from Weak space pages in main memory.")
		  (ESRT "finding ephemeral references from Weak space pages on disk.")
		  (OTHERWISE "traversing Weak space.")))))
  (WHEN GC-IMMEDIATELY-IN-PROGRESS
    (FORMAT STREAM "GC-IMMEDIATELY is in progress.~%"))
  (FORMAT STREAM "Scavenging during cons: ~:[On~;Off~], ~
		  Scavenging when machine idle: ~:[On~;Off~]~%"
	  INHIBIT-SCAVENGING-FLAG INHIBIT-IDLE-SCAVENGING-FLAG)
  (WHEN GC-FLIP-WAITING
    (FORMAT STREAM "The garbage collector is currently waiting for ~
		~D process~:*~[~1;~:;es~] to cease inhibiting flips.~%"
	    GC-FLIP-INHIBIT))
  (UNLESS (EQ *EPHEMERAL-MIGRATION-MODE* :NORMAL)
    (FORMAT STREAM "~S is ~S; " '*EPHEMERAL-MIGRATION-MODE* *EPHEMERAL-MIGRATION-MODE*)
    (SELECTQ *EPHEMERAL-MIGRATION-MODE*
      (:KEEP
       (FORMAT STREAM "Ephemeral objects that survive ~@
		       garbage collections are not turning into dynamic objects.~%"))
      (:COLLECT
       (FORMAT STREAM "Ephemeral objects that survive ~@
		       garbage collections are not turning into dynamic objects ~@
		       and the last levels do not flip.~%"))
      (:DYNAMIC
       (FORMAT STREAM "Ephemeral objects are being forced into dynamic objects.~%"))
      (:EXTRA
       ;;--- The following statement is true about :KEEP and :COLLECT, too.
       (FORMAT STREAM "Ephemeral objects which survive ~@
		       garbage collections are being progressed through extra levels~@
		       before turning into dynamic objects."))
      (OTHERWISE
       (FORMAT STREAM "an illegal value; being set back to :NORMAL~%")
       (SETQ *EPHEMERAL-MIGRATION-MODE* :NORMAL))))

  ;; History of garbage collections that have occurred in the past
  (LET* ((TOTAL %GC-GENERATION-NUMBER)
	 (FULL *FULL-GC-COUNT*)	
	 (DYNAMIC (- %GC-DYNAMIC-GENERATION-NUMBER FULL))
	 (EPHEMERAL (- TOTAL DYNAMIC FULL))
	 (REAL-TOTAL-CONS-WORK-DONE (+ TOTAL-CONS-WORK-DONE
				       (WITHOUT-INTERRUPTS
					 (- *CONS-WORK-DONE*
					    (%STRUCTURE-CACHE-LENGTH)
					    (%LIST-CACHE-LENGTH)))))
	 (REAL-TOTAL-SCAV-WORK-DONE (+ TOTAL-SCAV-WORK-DONE (IF %GC-FLIP-READY
								0 *SCAV-WORK-DONE*)))
	 (REAL-TOTAL-TRANSPORTER-WORDS (+ TOTAL-TRANSPORTER-WORDS TRANSPORTER-WORDS)))
    (FORMAT STREAM "The GC generation count is ~D ~
			(~D full GC~A, ~D dynamic GC~A, and ~D ephemeral GC~A).
Since cold boot ~:D words have been consed~:[, ~:D words of garbage have
been reclaimed~@[ (at most ~:D words of garbage might be reclaimed during
this GC)~], and ~:D words of non-garbage have been transported.
The total /"scavenger work/" required to accomplish this was ~:D units~].~%"
	    TOTAL FULL (IF (= FULL 1) "" "'s")
	    DYNAMIC (IF (= DYNAMIC 1) "" "'s") EPHEMERAL (IF (= EPHEMERAL 1) "" "'s")
	    REAL-TOTAL-CONS-WORK-DONE (ZEROP REAL-TOTAL-SCAV-WORK-DONE)
	    (- TOTAL-OLDSPACE-RECLAIMED
	       (IF %GC-FLIP-READY
		   ;; don't include words for the current scavenge
		   REAL-TOTAL-TRANSPORTER-WORDS
		   TOTAL-TRANSPORTER-WORDS))
	    (AND (NOT %GC-FLIP-READY)
		 (MULTIPLE-VALUE-BIND (NIL NIL NIL OLD-SIZE)
		     (GC-GET-SPACE-SIZES)
		   (- OLD-SIZE TRANSPORTER-WORDS)))
	    REAL-TOTAL-TRANSPORTER-WORDS
	    REAL-TOTAL-SCAV-WORK-DONE))

  ;; Advertisement (since we removed the few gc parameters that used to be shown here)
  (FORMAT STREAM "Use ~\SI:GC-COMMAND\ to examine or modify the GC parameters.~%"
	  `(COM-SET-GC-OPTIONS)))

;; This returns T if the load bitmap is empty except for wired and stack pages.
;; It's fairly slow, but okay for the immediate purpose.
(DEFUN LOAD-BITMAP-EMPTY-P ()
  (STACK-LET ((BITMAPS STORAGE::*LOAD-BITMAPS*)
	      (OKAY-REGIONS (MAKE-ARRAY (N-REGIONS) :TYPE ART-BOOLEAN)))
    (DECLARE (ARRAY-REGISTER BITMAPS OKAY-REGIONS))
    (LOOP FOR REGION BELOW (N-REGIONS)
	  AS BITS = (REGION-BITS REGION)
	  WHEN (OR (LDB-TEST %%REGION-STACK BITS)
		   (= (LDB %%REGION-LEVEL BITS) %WIRED-LEVEL))
	    DO (SETF (AREF OKAY-REGIONS REGION) T))
    (DOTIMES (BITMAP-NUM %NUMBER-OF-BITMAPS)
      (LET ((BITMAP (AREF BITMAPS BITMAP-NUM)))
	(WHEN BITMAP
	  (LET ((BITMAP BITMAP))
	    (DECLARE (ARRAY-REGISTER BITMAP))
	    (LOOP FOR I BELOW (CL:LENGTH BITMAP)
		  WHEN (AND (AREF BITMAP I)
			    (LET ((REGION (%REGION-NUMBER
					    (DEPOSIT-VPN
					      (DPB BITMAP-NUM %%VPN-BITMAP-NUM I) 0))))
			      (OR (NULL REGION)	;Shouldn't happen, but be conservative
				  (NOT (AREF OKAY-REGIONS REGION)))))
		    DO (RETURN-FROM LOAD-BITMAP-EMPTY-P NIL))))))
    T))

(DEFUN MAYBE-WARN-ABOUT-SWAP-MIGRATION (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (WHEN (AND (NOT (LOAD-BITMAP-EMPTY-P))
	     (EQL %GC-DYNAMIC-GENERATION-NUMBER
		  *COLD-BOOT-GC-DYNAMIC-GENERATION-NUMBER*))
    (LET ((TOPIC (AND (VARIABLE-BOUNDP #'SAGE:FIND-RECORD-GROUP-FOR-TOPIC-AND-TYPE)
		      (FIRST (SAGE:FIND-RECORD-GROUP-FOR-TOPIC-AND-TYPE
			       "Swap Migration and Garbage Collection" NIL)))))
      (FORMAT STREAM 
"~%Warning:  The current Garbage Collector storage estimates may not be accurate~@
due to the difficulty of estimating swap migration.  For more information,~@
see the documentation section /""
	      )
      (IF TOPIC
	  (PRESENT TOPIC 'SAGE:RECORD-GROUP :STREAM STREAM)
	  (FORMAT STREAM "Swap Migration and Garbage Collection"))
      (FORMAT STREAM "/".~%")
      T)))


;; Testing
;; This loops through all storage looking for pointers to hyperspace and malformed objects.

(DEFUN VERIFY-STORAGE-CONVENTIONS (&KEY (VERBOSE T)
					(SCAN-WEAKSPACE T)
					(SCAN-TEMPORARY T)
					(ALLOW-OLDSPACE T)
					(ALLOW-WEAKSPACE T)
					(ALLOW-TEMPORARY T)
					(CHECK-FOR-MALFORMED-STRUCTURES T)
				   &AUX BITS)
  (WHEN VERBOSE (FORMAT T "~%Verifying storage conventions..."))
  (MACROLET ((HACK (ADDRESS &OPTIONAL LISTP PREV-CDR)
	       #+IMach `(LET ((WORD (%MEMORY-READ ,ADDRESS
						  :CYCLE-TYPE %MEMORY-SCAVENGE
						  :SET-CDR-NEXT NIL)))
			  (AND (%POINTER-TYPE-P (%DATA-TYPE WORD))
			       ( (LDB %%VMA-ZONE-NUM (%POINTER WORD)) %WIRED-ZONE)
			       ;; Ignore pointers to this portion of address space,
			       ;; which is reserved for nonexistent memory, but only
			       ;; when they appear in places where Cyphers expects to
			       ;; find them.
			       (OR ( (LDB %%VMA-OBLAST-NUM (%POINTER WORD))
				      (DPB %BOUNDARY-ZONE %%OBLAST-ZONE-NUM
					   (LDB %%VMA-OBLAST-NUM -1)))
				   (LET ((BITS (REGION-BITS (OR (%REGION-NUMBER ,ADDRESS)
								0))))
				     (IF (LDB-TEST %%REGION-STACK BITS)
					 ( (LDB %%REGION-SPACE-TYPE BITS)
					    %REGION-SPACE-CONTROL-STACK)
					 (LET ((X (%FIND-STRUCTURE-HEADER ,ADDRESS)))
					   (OR (NOT (TYPEP X :STACK-GROUP))
					       (%POINTER-LESSP ,ADDRESS (LOCF (SG-BAR-1 X)))
					       (%POINTER-LESSP (LOCF (SG-BAR-3 X)) ,ADDRESS)
					       )))))
			       (LET ((REGION (%REGION-NUMBER (%POINTER WORD))) BITS)
				 (OR (NULL REGION)
				     (PROGN (SETQ BITS (REGION-BITS REGION)) NIL)
				     ( (%POINTER-DIFFERENCE WORD (REGION-ORIGIN REGION))
					(REGION-FREE-POINTER REGION))
				     (UNLESS ALLOW-OLDSPACE
				       (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-OLD))
				     (UNLESS ALLOW-WEAKSPACE
				       (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-WEAK))
				     (UNLESS ALLOW-TEMPORARY
				       (AND (LDB-TEST %%REGION-TEMPORARY BITS)
					    (IF ALLOW-WEAKSPACE
						( (LDB %%REGION-SPACE-TYPE BITS)
						   %REGION-SPACE-WEAK)
						T)))))
			       (FORMAT T "~%   ~\SI:ADDRESS\//  ~A ~\SI:ADDRESS\"
				       ,ADDRESS (NTH (%DATA-TYPE WORD) *DATA-TYPES*)
				       (%POINTER WORD))
			       (WHEN REGION
				 (FORMAT T " ~A ~A"
					 (AREA-NAME (REGION-AREA REGION))
					 (IF (< (LDB %%REGION-SPACE-TYPE BITS)
						(LENGTH *REGION-SPACE-TYPES*))
					     (SUBSTRING (NTH (LDB %%REGION-SPACE-TYPE BITS)
							     *REGION-SPACE-TYPES*)
							(STRING-LENGTH "%REGION-SPACE-"))
					     (LDB %%REGION-SPACE-TYPE BITS)))
				 (WHEN ( (%POINTER-DIFFERENCE WORD (REGION-ORIGIN REGION))
					  (REGION-FREE-POINTER REGION))
				   (FORMAT T " past free-pointer"))
				 (WHEN (LDB-TEST %%REGION-TEMPORARY BITS)
				   (FORMAT T " temporary-area"))))
			  ,(WHEN PREV-CDR
			     `(WHEN ,LISTP
				(LET ((THIS-CDR (LDB %%Q-CDR-CODE-WITHIN-TAG (%TAG WORD))))
				  ;; CDR-NIL must follow CDR-NORMAL and CDR-3 is illegal.
				  (COND ((= THIS-CDR 3)
					 (FORMAT T "~%   ~\SI:ADDRESS\//  cdr-code error, ~
						    unused cdr-code 3 seen."
						 ,ADDRESS))
					((AND (= ,PREV-CDR CDR-NORMAL)
					      ( THIS-CDR CDR-NIL))
					 (FORMAT T "~%   ~\SI:ADDRESS\//  cdr-code error, ~
						    ~A instead of CDR-NIL after CDR-NORMAL."
						 ,ADDRESS (NTH THIS-CDR *CDR-CODES*))))
				  (SETQ ,PREV-CDR THIS-CDR)))))
	       #+3600 `(LET ((TAG (%P-LDB %%Q-TAG ,ADDRESS)))
			 (WHEN (%POINTER-TYPE-P (LDB %%Q-TYPE-WITHIN-TAG TAG))
			   (LET ((POINTER (%P-POINTER ,ADDRESS)))
			     (UNLESS (= (LDB %%VMA-EQUALS-PMA POINTER) %VMA-EQUALS-PMA)
			       (LET ((REGION (%REGION-NUMBER POINTER)) BITS)
				 (WHEN (OR (NULL REGION)
					   (PROGN (SETQ BITS (REGION-BITS REGION)) NIL)
					   ( (%POINTER-DIFFERENCE POINTER
								   (REGION-ORIGIN REGION))
					      (REGION-FREE-POINTER REGION))
					   (UNLESS ALLOW-OLDSPACE
					     (= (LDB %%REGION-SPACE-TYPE BITS)
						%REGION-SPACE-OLD))
					   (UNLESS ALLOW-WEAKSPACE
					     (= (LDB %%REGION-SPACE-TYPE BITS)
						%REGION-SPACE-WEAK))
					   (UNLESS ALLOW-TEMPORARY
					     (AND (LDB-TEST %%REGION-TEMPORARY BITS)
						  (IF ALLOW-WEAKSPACE
						      ( (LDB %%REGION-SPACE-TYPE BITS)
							 %REGION-SPACE-WEAK)
						      T))))
				   (FORMAT T "~%   ~\SI:ADDRESS\//  ~A ~\SI:ADDRESS\"
					   ,ADDRESS
					   (NTH (LDB %%Q-TYPE-WITHIN-TAG TAG) *DATA-TYPES*)
					   POINTER)
				   (WHEN REGION
				     (FORMAT T " ~A ~A"
					     (AREA-NAME (REGION-AREA REGION))
					     (IF (< (LDB %%REGION-SPACE-TYPE BITS)
						    (LENGTH *REGION-SPACE-TYPES*))
						 (SUBSTRING (NTH (LDB %%REGION-SPACE-TYPE BITS)
								 *REGION-SPACE-TYPES*)
							    (STRING-LENGTH "%REGION-SPACE-"))
						 (LDB %%REGION-SPACE-TYPE BITS)))
				     (WHEN ( (%POINTER-DIFFERENCE POINTER
								   (REGION-ORIGIN REGION))
					      (REGION-FREE-POINTER REGION))
				       (FORMAT T " past free-pointer"))
				     (WHEN (LDB-TEST %%REGION-TEMPORARY BITS)
				       (FORMAT T " temporary-area"))))))))
			 ,(WHEN PREV-CDR
			    `(WHEN ,LISTP
			       (LET ((THIS-CDR (LDB %%Q-CDR-CODE-WITHIN-TAG TAG)))
				 ;; CDR-NIL must follow CDR-NORMAL and CDR-3 is illegal.
				 (WHEN (OR (AND (= ,PREV-CDR CDR-NORMAL)
						( THIS-CDR CDR-NIL))
					   (= THIS-CDR 3))
				   (COND ((= THIS-CDR 3)
					 (FORMAT T "~%   ~\SI:ADDRESS\//  cdr-code error, ~
						    unused cdr-code 3 seen."
						 ,ADDRESS))
					((AND (= ,PREV-CDR CDR-NORMAL)
					      ( THIS-CDR CDR-NIL))
					 (FORMAT T "~%   ~\SI:ADDRESS\//  cdr-code error, ~
						    ~A instead of CDR-NIL after CDR-NORMAL."
						 ,ADDRESS (NTH THIS-CDR *CDR-CODES*)))))
				 (SETQ ,PREV-CDR THIS-CDR)))))))
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD
				  REGION-BITS REGION-FREE-POINTER REGION-ORIGIN)
      (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
      (DOTIMES (AREA (N-AREAS))
	(WHEN VERBOSE (FORMAT T "~% Area ~A" (AREA-NAME AREA)))
	(DO-AREA-REGIONS (REGION AREA)
	  (SETQ BITS (REGION-BITS REGION))
	  (WHEN VERBOSE (FORMAT T "~%  Region ~O" REGION))
	  ;; Scan the region for bogus pointers
	  (IF (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-OLD)
	      (WHEN VERBOSE (FORMAT T " (oldspace)"))
	    (COND ((NOT (AREA-PREDICATE-AREAS-WITH-OBJECTS AREA))
		   (WHEN VERBOSE (FORMAT T " (system area not scanned)")))
		  ((OR (AND (NOT SCAN-WEAKSPACE)
			    (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-WEAK))
		       (AND (NOT SCAN-TEMPORARY)
			    (LDB-TEST %%REGION-TEMPORARY BITS)
			    (NOT (AND SCAN-WEAKSPACE
				      (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-WEAK)))))
		   (WHEN VERBOSE (FORMAT T " (not scanned)")))
		  (T 
		   (LET* ((ORIGIN (REGION-ORIGIN REGION))
			  (LIMIT (+ (REGION-FREE-POINTER REGION) ORIGIN)))
		     (SCANNING-THROUGH-MEMORY SCAN (ORIGIN LIMIT)
		       (IF (LDB-TEST %%REGION-STACK BITS)
			   (LOOP WITH ADDRESS = ORIGIN
				 WHILE (%POINTER-LESSP ADDRESS LIMIT) DO
			     (MULTIPLE-VALUE-BIND (STACK-BASE STACK-ACTIVE-SIZE TOTAL-SIZE)
				 (DECODE-STACK-ADDRESS ADDRESS)
			       (IF (NULL STACK-BASE)
				   (PROGN (CHECK-MEMORY-SCAN SCAN ADDRESS)
					  (HACK ADDRESS)
					  (INCF ADDRESS))
				   (LOOP FOR Q FROM STACK-BASE REPEAT STACK-ACTIVE-SIZE DO
				     (CHECK-MEMORY-SCAN SCAN Q)
				     (HACK Q))
				   (SETQ ADDRESS (+ (%POINTER STACK-BASE) TOTAL-SIZE)))))
			   (LOOP WITH LISTP = (= (LDB %%REGION-REPRESENTATION-TYPE BITS)
						 %REGION-REPRESENTATION-TYPE-LIST)
				 WITH PREV-CDR = CDR-NIL
				 FOR Q FROM ORIGIN BELOW LIMIT
				 DO (CHECK-MEMORY-SCAN SCAN Q)
				    (HACK Q LISTP PREV-CDR)
				 FINALLY (UNLESS (= PREV-CDR CDR-NIL)
					   ;; Last cdr in list space must be CDR-NIL
					   (FORMAT T "~%   ~\SI:ADDRESS\//  cdr-code error, ~
						      ~A instead of CDR-NIL at end of region."
						   Q (OR (NTH PREV-CDR *CDR-CODES*) PREV-CDR)
						   ))))))))
	    ;; Verify that structures are well formed.
	    ;; This also verifies %FIND-STRUCTURE-EXTENT.
	    (WHEN (AND CHECK-FOR-MALFORMED-STRUCTURES
		       ( AREA PAGE-TABLE-AREA)
		       ( AREA GC-TABLE-AREA)
		       (NOT (LDB-TEST %%REGION-STACK BITS))
		       (= (LDB %%REGION-REPRESENTATION-TYPE BITS)
			  %REGION-REPRESENTATION-TYPE-STRUCTURE)
		       (NOT (OR (AND (NOT SCAN-WEAKSPACE)
				     (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-WEAK))
				(AND (NOT SCAN-TEMPORARY)
				     (LDB-TEST %%REGION-TEMPORARY BITS)
				     (NOT (AND SCAN-WEAKSPACE
					       (= (LDB %%REGION-SPACE-TYPE BITS)
						  %REGION-SPACE-WEAK)))))))
	      (MAP-OVER-OBJECTS-IN-REGION REGION #'IGNORE))))))))

;;; Initializations now that whole GC is loaded

;;; Allow GC to be loaded before processes for testing.
(WHEN (FBOUNDP 'MAKE-PROCESS)
  (START-GC-DAEMON)
  (GC-DAEMON-QUEUE 'GC-NEEDS-TO-BE-TURNED-ON 'GC-NEEDS-TO-BE-TURNED-ON 0 0)
  (GC-DAEMON-QUEUE 'ADDRESS-SPACE-WARNING 'ADDRESS-SPACE-WARNING 0 0))

;;; Make WORKING-STORAGE-AREA (which is DEFAULT-CONS-AREA) able to hold ephemeral objects

(MAKE-AREA :NAME 'WORKING-STORAGE-AREA :N-LEVELS 2 :CAPACITY 200000. :GC :EPHEMERAL)
