;;;-*- Syntax: Zetalisp; Mode: LISP; Package: SI; Base: 8 -*-
;;; L machine binary file dumper
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFUN WRITING-BIN-FILE-1 (CONTINUATION FILE SET-LOAD-DEFAULT-P)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (DECLARE (VALUES BINARY-TRUENAME))
  (WITH-OPEN-FILE (STREAM (BIN-FILE-PATHNAME FILE SET-LOAD-DEFAULT-P)
			  :DIRECTION :OUTPUT :ELEMENT-TYPE '(CL:UNSIGNED-BYTE 16.))
    (FUNCALL CONTINUATION STREAM)))

(DEFUN WRITING-BIN-STREAM-1 (CONTINUATION STREAM &OPTIONAL NO-TABLE-P)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (DECLARE (VALUES BINARY-TRUENAME))
  (WITH-EPHEMERAL-MIGRATION-MODE :COLLECT
    (LET ((*BIN-DUMP-TABLE* (AND (NOT NO-TABLE-P)
				 (CL:MAKE-HASH-TABLE :TEST #'EQL :LOCKING NIL))))
      (START-BIN-FILE STREAM)
      (LET ((*BIN-DUMP-INDEX* 0)
	    (*BIN-DUMP-PACKAGE* PACKAGE)
	    (*BIN-DUMP-SYNTAX* (CURRENT-LISP-SYNTAX)))
	(FUNCALL CONTINUATION STREAM))
      (END-BIN-FILE STREAM))))

(DEFUN START-BIN-FILE (STREAM)
  (SEND STREAM ':TYO BIN-OP-FORMAT-VERSION)
  (DUMP-OBJECT *VERSION-NUMBER* STREAM))

(DEFUN END-BIN-FILE (STREAM)
  (SEND STREAM :TYO BIN-OP-EOF)
  (CLOSE STREAM)
  (VALUES (SEND STREAM :TRUENAME)
	  (SEND STREAM :INFO)))

;;; Called if OBJECT should be the next thing entered into the dump table.
;;; EXPLICIT means that this would not normally produce a value and an explicit command
;;; to do so should be put in.
;;; DELAYED means that complex machinations will occur at load time before the object
;;; is actually entered into the table.  Doing it this way detects circularities.
(DEFUN ENTER-TABLE (OBJECT STREAM &OPTIONAL EXPLICIT DELAYED NO-TABLE INITIALIZER)
  (WHEN *BIN-DUMP-TABLE*
    (WHEN EXPLICIT
      (IF INITIALIZER
	  (SEND STREAM :TYO BIN-OP-TABLE-STORE-INITIALIZER)
	  (SEND STREAM :TYO BIN-OP-TABLE-STORE)))
    (UNLESS NO-TABLE
      (SETF (CL:GETHASH OBJECT *BIN-DUMP-TABLE*)
	    (IF DELAYED T *BIN-DUMP-INDEX*))))
  (INCF *BIN-DUMP-INDEX*))

;;; Call this with the value that ENTER-TABLE returned after putting into the
;;; file the commands that will finally create the object.
(DEFUN FINISH-ENTER-TABLE (OBJECT BIN-DUMP-INDEX &OPTIONAL NO-TABLE)
  (WHEN (AND (NOT NO-TABLE) *BIN-DUMP-TABLE*)
    (SETF (CL:GETHASH OBJECT *BIN-DUMP-TABLE*) (1- BIN-DUMP-INDEX))))

(DEFUN DUMP-FORMS-TO-FILE (FILENAME FORMS &OPTIONAL FILE-ATTRIBUTE-LIST)
  (DECLARE (VALUES BINARY-TRUENAME))
  ;; If no package is specified for the file, use the USER package.
  (UNLESS (GET (LOCF FILE-ATTRIBUTE-LIST) ':PACKAGE)
    (PUTPROP (LOCF FILE-ATTRIBUTE-LIST) :ZETALISP-USER :PACKAGE))
  (WRITING-BIN-FILE (STREAM FILENAME)
    (DUMP-ATTRIBUTE-LIST FILE-ATTRIBUTE-LIST STREAM)
    (DOLIST (FORM FORMS)
      (DUMP-FORM-TO-EVAL FORM STREAM))))

(DEFUN DUMP-OBJECT (OBJECT STREAM &AUX INDEX)
  (COND ((AND (TYPEP OBJECT ':FIXNUM) (< -1_13 OBJECT 1_13))
	 (SEND STREAM ':TYO (DPB BIN-OP-NUMBER-IMMEDIATE %%BIN-OP-HIGH
				 (LDB (BYTE 12. 0) OBJECT))))
	((SETQ INDEX (AND *BIN-DUMP-TABLE* (CL:GETHASH OBJECT *BIN-DUMP-TABLE*)))
	 (COND ((NOT (FIXP INDEX))
		(FERROR "The object ~S is circular or self-referential.~@
			BIN files cannot deal with this; at load time the object~@
			would be needed before it has been created." OBJECT))
	       ((< INDEX 1_14)
		(SEND STREAM ':TYO (DPB BIN-OP-TABLE-FETCH-IMMEDIATE %%BIN-OP-HIGH INDEX)))
	       ((< INDEX 1_20)
		(SEND STREAM ':TYO BIN-OP-TABLE-FETCH-MEDIUM)
		(SEND STREAM ':TYO INDEX))
	       (T
		(SEND STREAM ':TYO BIN-OP-TABLE-FETCH-LARGE)
		(SEND STREAM ':TYO (LDB (BYTE 20 0) INDEX))	;low order bits first
		(SEND STREAM ':TYO (LDB (BYTE 20 20) INDEX)))))
	#+IMach
	((MAYBE-DUMP-EMBEDDED-CONSTANT OBJECT STREAM))
	(T
	 (TYPECASE OBJECT
	   (:SYMBOL (DUMP-SYMBOL OBJECT STREAM))
	   (:FIXNUM (DUMP-32-BIT-FIXNUM OBJECT STREAM))
	   #+VLM
	   (:NATIVE-INSTRUCTION
	     (DUMP-NATIVE-INSTRUCTION OBJECT STREAM))
	   (:STRING (IF (OR ( 8 (ARRAY-ELEMENT-BYTE-SIZE OBJECT))
			    (ARRAY-HAS-LEADER-P OBJECT)
			    (ARRAY-INDIRECT-P OBJECT))
			(DUMP-ARRAY OBJECT STREAM)
			(DUMP-STRING OBJECT STREAM)))
	   (:LIST (DUMP-LIST OBJECT STREAM))
	   (:LOCATIVE (DUMP-LOCATIVE OBJECT STREAM))
	   ((:COMPILED-FUNCTION)
	    #+3600(DUMP-L-COMPILED-FUNCTION OBJECT STREAM)
	    #+IMACH(DUMP-I-COMPILED-FUNCTION OBJECT STREAM))
	   (SI:CHARACTER-STYLE (DUMP-CHARACTER-STYLE OBJECT STREAM))
	   (SI:BASIC-CHARACTER-SET (DUMP-CHARACTER-SET OBJECT STREAM))
	   (:ARRAY
	     (COND ((TYPEP OBJECT 'PACKAGE)
		    (DUMP-PACKAGE OBJECT STREAM))
		   (T
		    (DUMP-ARRAY OBJECT STREAM))))
	   (:INSTANCE (DUMP-INSTANCE OBJECT STREAM))
	   (:FIX (DUMP-LARGE-INTEGER OBJECT STREAM))
	   (:RATIONAL (DUMP-RATIO OBJECT STREAM))
	   (:SINGLE-FLOAT (DUMP-IEEE-SINGLE-FLOAT OBJECT STREAM))
	   (:DOUBLE-FLOAT (DUMP-IEEE-DOUBLE-FLOAT OBJECT STREAM))
	   (:COMPLEX	  (DUMP-COMPLEX OBJECT STREAM))
	   (:EXTENDED-NUMBER (DUMP-EXTENDED-NUMBER OBJECT STREAM))
	   (:CHARACTER (DUMP-CHARACTER OBJECT STREAM))
	   (:GENERIC-FUNCTION (DUMP-GENERIC-FUNCTION OBJECT STREAM))
	   (:FUNCALLABLE-INSTANCE (DUMP-INSTANCE OBJECT STREAM))
	   (OTHERWISE
	     (WHEN (INTERPRETED-FUNCTION-P OBJECT)
	       (MULTIPLE-VALUE-BIND (LAMBDA-EXP CLOSURE)
		   (INTERPRETED-FUNCTION-LAMBDA-EXPRESSION OBJECT)
		 (WHEN (NOT CLOSURE)
		   (ENTER-TABLE OBJECT STREAM T)
		   (RETURN-FROM DUMP-OBJECT
		     (DUMP-FORM-TO-EVAL `#',LAMBDA-EXP STREAM)))))
	     (LET ((LAST-DITCH (GET (DATA-TYPE OBJECT) 'SI:DUMP-OBJECT)))
	       (WHEN LAST-DITCH
		 (RETURN-FROM DUMP-OBJECT
		   (FUNCALL LAST-DITCH OBJECT STREAM))))
	     (FERROR "Cannot dump object ~S" OBJECT))))))

(DEFUN DUMP-FORM-TO-EVAL (FORM STREAM)
  (COND ((NOT (IF (ATOM FORM)
		  (COND ((OR (NUMBERP FORM)
			     (MEMQ FORM '(T NIL))
			     (TYPEP FORM :COMPILED-FUNCTION))
			 (DUMP-OBJECT FORM STREAM)
			 T))
		  (SELECTQ (CAR FORM)
		    (QUOTE
		     (DUMP-OBJECT (CADR FORM) STREAM)
		     T)
		    (PUTPROP
		     (SEND STREAM ':TYO BIN-OP-PUTPROP)
		     (LOOP REPEAT 3 FOR FORM IN (CDR FORM)
			   DO (DUMP-FORM-TO-EVAL FORM STREAM))
		     T)
		    (SI:DEFVAR-1
		     (SEND STREAM ':TYO (DPB BIN-OP-DEFVAR %%BIN-OP-HIGH (LENGTH (CDR FORM))))
		     (DUMP-OBJECT (CADR FORM) STREAM)
		     (LOOP FOR FORM IN (CDDR FORM)
			   DO (DUMP-OBJECT FORM STREAM))
		     T)
		    (SI:DEFCONST-1
		     (SEND STREAM ':TYO
			   (DPB BIN-OP-DEFCONST %%BIN-OP-HIGH (LENGTH (CDR FORM))))
		     (DUMP-OBJECT (CADR FORM) STREAM)
		     (LOOP FOR I FROM 0
			   FOR FORM IN (CDDR FORM)
			   DO (FUNCALL (IF (= I 0) #'DUMP-FORM-TO-EVAL #'DUMP-OBJECT)
				       FORM STREAM))
		     T)
		    (SETQ
		     (LOOP FOR (SYMBOL VALUE) ON (CDR FORM) BY 'CDDR
			   DO (SEND STREAM ':TYO BIN-OP-SETQ)
			      (DUMP-OBJECT SYMBOL STREAM)
			      (DUMP-FORM-TO-EVAL VALUE STREAM))
		     T)
		    (MAKE-INSTANCE
		     (SEND STREAM ':TYO (DPB BIN-OP-MAKE-INSTANCE-IMMEDIATE
					     %%BIN-OP-HIGH (LENGTH (CDDR FORM))))
		     (LOOP FOR THING IN (CDR FORM)
			   DO (DUMP-FORM-TO-EVAL THING STREAM))
		     T)
		    (FDEFINE
		     (DESTRUCTURING-BIND (NIL FSPEC DEFINITION
					      &OPTIONAL CAREFULLY-P NO-QUERY-P)
					 FORM
		       (WHEN (AND (NOT NO-QUERY-P) CAREFULLY-P)
			 (SEND STREAM :TYO BIN-OP-FDEFINE)
			 (DUMP-FORM-TO-EVAL FSPEC STREAM)
			 (BLOCK DUMP-DEFINITION
			   (WHEN (CL:CONSP DEFINITION)
			     (FLET ((CONSTANT-FORM-P (THING)
				      (IF (CL:CONSP THING)
					  (EQ (FIRST THING) 'QUOTE)
					  (IF (SYMBOLP THING)
					      (OR (EQ THING NIL)
						  (EQ THING T))
					      T)))
				    (CONSTANT-EVAL (THING)
				      (IF (CL:CONSP THING) (SECOND THING) THING)))
			       (SELECTQ (FIRST DEFINITION)
				 ((CONS)
				  (WHEN (AND (CONSTANT-FORM-P (SECOND DEFINITION))
					     (CONSTANT-FORM-P (THIRD DEFINITION))
					     (NULL (CDDDR DEFINITION)))
				    (DUMP-OBJECT
				      (CONS (CONSTANT-EVAL (SECOND DEFINITION))
					    (CONSTANT-EVAL (THIRD DEFINITION)))
				      STREAM)
				    (RETURN-FROM DUMP-DEFINITION)))
				 ((LIST SI:%LIST-1 SI:%LIST-2 SI:%LIST-3)
				  (WHEN (EVERY (CL:REST DEFINITION) #'CONSTANT-FORM-P)
				    (DUMP-OBJECT (MAPCAR #'CONSTANT-EVAL (CL:REST DEFINITION))
						 STREAM)
				    (RETURN-FROM DUMP-DEFINITION))))))
			   (DUMP-FORM-TO-EVAL DEFINITION STREAM))
			 T)))
		    (OTHERWISE
		     NIL))))
	 (SEND STREAM ':TYO BIN-OP-FORM)
	 (DUMP-OBJECT FORM STREAM))))

(DEFUN DUMP-PACKAGE (PACKAGE STREAM)
  (ENTER-TABLE PACKAGE STREAM)
  (LET ((SYNTAX (IF *BIN-DUMP-SYNTAX* (SI:FIND-LISP-SYNTAX *BIN-DUMP-SYNTAX*))))
    (LET ((NAME (PACKAGE-NAME-FOR-SYNTAX PACKAGE SYNTAX NIL)))
      (SEND STREAM :TYO BIN-OP-PACKAGE)
      (DUMP-OBJECT (IF (OR (NOT NAME) (NOT SYNTAX))
		       (PKG-NAME PACKAGE)
		       (CONS (LISP-SYNTAX-SHORT-NAME SYNTAX)
			     NAME))
		   STREAM))))

(DEFUN DUMP-SYMBOL (SYMBOL STREAM)
  (ENTER-TABLE SYMBOL STREAM)
  (COND ((NULL (SYMBOL-PACKAGE SYMBOL))
	 (SEND STREAM ':TYO BIN-OP-PACKAGE-SYMBOL)
	 (DUMP-OBJECT 'NIL STREAM))
	(T
	 (LET ((PACKAGE-STRING NIL)
	       (SYNTAX-ESCAPE-P NIL)
	       (INTERNAL-P NIL))
	   (SI:PKG-SYMBOL-PREFIX
	     ;; A result in PACKAGE-STRING of
	     ;;  "FOO"               means FOO:
	     ;;  ("FOO" SI:INTERNAL) means FOO::
	     ;; For multiple packages, they look like:
	     ;;     ("FOO" "BAR" "BAZ")             for FOO:BAR:BAZ:
	     ;;  or ("FOO" "BAR" "BAZ" SI:INTERNAL) for FOO:BAR:BAZ::
	     #'(LAMBDA (NAME IGNORE FLAG)
		 ;; Flag will be NIL     (package external prefix),
		 ;;              T       (package internal prefix),
		 ;;           or :SYNTAX (syntax prefix)
		 (COND ((EQ FLAG :SYNTAX)
			;; This means we'll have to dump the package object separately.
			(SETQ SYNTAX-ESCAPE-P T))
		       (T
			 (SETQ PACKAGE-STRING
			       (IF (NULL PACKAGE-STRING)
				   NAME
				   (NCONC (IF (LISTP PACKAGE-STRING)
					      PACKAGE-STRING
					      (NCONS PACKAGE-STRING))
					  (NCONS NAME))))
			 (WHEN FLAG			;Will be the last package
			   (SETQ INTERNAL-P T)
			   (SETQ PACKAGE-STRING
				 (NCONC (IF (LISTP PACKAGE-STRING)
					    PACKAGE-STRING
					    (NCONS PACKAGE-STRING))
					(NCONS 'INTERNAL)))))))
	     SYMBOL
	     *BIN-DUMP-PACKAGE* *BIN-DUMP-SYNTAX*)
	   (COND (SYNTAX-ESCAPE-P
		  (SEND STREAM :TYO BIN-OP-PACKAGE-SYMBOL)
		  (DUMP-OBJECT (IF INTERNAL-P
				   (LIST (SYMBOL-PACKAGE SYMBOL) 'INTERNAL)
				   (SYMBOL-PACKAGE SYMBOL))
			       STREAM))
		 ((NULL PACKAGE-STRING)
		  (SEND STREAM ':TYO BIN-OP-SYMBOL))
		 (T
		  (SEND STREAM ':TYO BIN-OP-PACKAGE-SYMBOL)
		  (DUMP-OBJECT PACKAGE-STRING STREAM))))))
  (DUMP-OBJECT (GET-PNAME SYMBOL) STREAM))

(DEFUN DUMP-STRING (STRING STREAM)
  (ENTER-TABLE STRING STREAM)
  (LET ((LENGTH (STRING-LENGTH STRING)))
    (IF (< LENGTH 1_14)
	(SEND STREAM ':TYO (DPB BIN-OP-STRING-IMMEDIATE %%BIN-OP-HIGH LENGTH))
	(SEND STREAM ':TYO BIN-OP-STRING)
	(DUMP-OBJECT LENGTH STREAM))
    (LOOP FOR I FROM 0 BELOW (BOOLE 2 1 LENGTH) BY 2	;TV:ALU-ANDCA
	  DO (SEND STREAM ':TYO (DPB (CHAR-CODE (AREF STRING (1+ I)))
				     (BYTE 8. 8.) (CHAR-CODE (AREF STRING I))))
	  FINALLY (AND ( I LENGTH)
		       (SEND STREAM ':TYO (CHAR-CODE (AREF STRING I)))))))

(DEFUN DUMP-LIST (LIST STREAM)
  (COND ((EQ (CAR LIST) COMPILER:EVAL-AT-LOAD-TIME-MARKER)
	 (ENTER-TABLE LIST STREAM T)
	 (DUMP-FORM-TO-EVAL (CDR LIST) STREAM))
	((OR *BIN-DUMP-NO-LIST-SHARING* (NULL *BIN-DUMP-TABLE*))
	 (DUMP-UNSHARED-LIST LIST STREAM))
	(T
	 (DUMP-SHARED-LIST LIST STREAM))))	 

(DEFUN DUMP-SHARED-LIST (LIST STREAM)
  (LET ((COUNT 1)
	(DOTIFY NIL))
    ;; Find the unshared part of the list.
    (LET ((L (CDR LIST)))
      (CL:LOOP
	 (WHEN (NULL L) (RETURN))
	 (WHEN (OR (ATOM L)
		   (EQ (CAR L) COMPILER:EVAL-AT-LOAD-TIME-MARKER)
		   (GETHASH L *BIN-DUMP-TABLE*))
	   (SETF DOTIFY T)
	   (RETURN))
	 (INCF COUNT)
	 (SETF L (CDR L))))
    ;; Dump the length
    (COND ((< COUNT 1_11.)
	   (SEND STREAM :TYO
		 (DPBS BIN-OP-INITIALIZE-LIST-IMMEDIATE %%BIN-OP-HIGH
		       (IF DOTIFY 1 0) (BYTE 1 11.)
		       COUNT)))
	  (T
	   (SEND STREAM :TYO BIN-OP-INITIALIZE-LIST)
	   (DUMP-OBJECT DOTIFY STREAM)
	   (DUMP-OBJECT COUNT STREAM)))
    ;; Enter the conses in the dump table.
    (LET ((L LIST))
      (LOOP REPEAT COUNT DO
	(ENTER-TABLE L STREAM)
	(SETF L (CDR L))))
    ;; Dump the elements.
    (LET ((L LIST))
      (LOOP REPEAT COUNT DO
	(DUMP-OBJECT (POP L) STREAM))
      (WHEN DOTIFY
	(DUMP-OBJECT L STREAM)))))

(DEFUN DUMP-UNSHARED-LIST (LIST STREAM)
  (LET* ((NO-TABLE (NOT (EQ *BIN-DUMP-NO-LIST-SHARING* :HEAD-ONLY)))
	 (INDEX (ENTER-TABLE LIST STREAM NIL T NO-TABLE)))
    (LOOP FOR L ON LIST
	  COUNT T INTO LENGTH
	  AS DOTIFY = (OR (ATOM L)
			  (EQ (CAR L) COMPILER:EVAL-AT-LOAD-TIME-MARKER))
	  UNTIL DOTIFY
	  FINALLY (COND ((< LENGTH 1_14)
			 (SEND STREAM ':TYO
			       (DPB (IF DOTIFY
					BIN-OP-LIST*-IMMEDIATE
					BIN-OP-LIST-IMMEDIATE)
				    %%BIN-OP-HIGH LENGTH)))
			(T
			 (SEND STREAM ':TYO (IF DOTIFY BIN-OP-LIST* BIN-OP-LIST))
			 (DUMP-OBJECT LENGTH STREAM)))
		  (LOOP FOR I FROM 0 BELOW LENGTH
			FOR L = LIST THEN (CDR L)
			DO (DUMP-OBJECT (IF (AND DOTIFY (= I (1- LENGTH))) L (CAR L))
					STREAM)))
    (FINISH-ENTER-TABLE LIST INDEX NO-TABLE)))

(DEFUN DUMP-LOCATIVE (LOCATIVE STREAM)
  (MULTIPLE-VALUE-BIND (OBJECT TYPE)
      (COMPILER:DISASSEMBLE-DECODE-LOCATIVE LOCATIVE)
    (CL:ECASE TYPE
      (:VARIABLE
	(ENTER-TABLE LOCATIVE STREAM)
	(SEND STREAM :TYO BIN-OP-VALUE-CELL-LOCATION)
	(DUMP-OBJECT OBJECT STREAM))
      (:FUNCTION
	(ENTER-TABLE LOCATIVE STREAM)
	(SEND STREAM :TYO BIN-OP-FDEFINITION-LOCATION)
	(DUMP-OBJECT OBJECT STREAM))
      (:LOAD-FORM
	(DUMP-FORM-TO-EVAL OBJECT STREAM)))))

(DEFVAR-RESETTABLE *DUMPING-COMPILED-FUNCTIONS* NIL)

#+3600
(DEFUN DUMP-L-COMPILED-FUNCTION (FUNCTION STREAM &AUX CCA EXTRA-INFO)
  (WITH-STACK-LIST* (*DUMPING-COMPILED-FUNCTIONS* FUNCTION *DUMPING-COMPILED-FUNCTIONS*)
    (ENTER-TABLE FUNCTION STREAM)
    (SEND STREAM ':TYO BIN-OP-L-COMPILED-FUNCTION)
    (SETQ CCA (SYS:COMPILED-FUNCTION-CCA FUNCTION))
    (DUMP-OBJECT (SYS:CCA-N-OBJECTS CCA) STREAM)
    (DUMP-OBJECT (SYS:CCA-N-INSTRUCTIONS CCA) STREAM)
    (DUMP-OBJECT (SYS:COMPILED-FUNCTION-HEADER-WORD-2 CCA) STREAM)
    (SETQ EXTRA-INFO (CCA-EXTRA-INFO-FOR-DEBUGGING CCA))
    (DUMP-OBJECT EXTRA-INFO STREAM)
    (LOOP WITH HINTS = (CDR (ASSQ ':FDEFINITION-LOCATION-HINTS (CDR EXTRA-INFO)))
	  FOR I FROM 0 BELOW (SYS:CCA-N-OBJECTS CCA)
	  AS OBJECT = (SYS:CCA-OBJECT CCA I)
	  AS HINT = (AND (LOCATIVEP OBJECT) (CAR (RASSQ I HINTS)))
	  WHEN HINT DO (ENTER-TABLE OBJECT STREAM)
		       (SEND STREAM ':TYO BIN-OP-FDEFINITION-LOCATION)
		       (DUMP-OBJECT HINT STREAM)
	  ELSE DO (DUMP-OBJECT OBJECT STREAM))
    ;; Now write a bit stream in 16-bits from the 17-bit instructions.
    ;; This cons'es 32-bit bignums and might want to be improved therefore.
    (LOOP FOR N-BITS FROM 0
	  FOR N-INST FROM 0 BELOW (SYS:CCA-N-INSTRUCTIONS CCA)
	  WITH WORD = 0
	  WHEN (= N-BITS 16.)
	    DO (SEND STREAM ':TYO (LOAD-BYTE WORD 16. 16.))
	       (SETQ N-BITS 0)
	  DO (SETQ WORD (DEPOSIT-BYTE (LOAD-BYTE WORD 16. N-BITS)
				      N-BITS 17. (SYS:CCA-INSTRUCTION CCA N-INST)))
	     (SEND STREAM ':TYO (LOAD-BYTE WORD 0 16.))
	  FINALLY (SEND STREAM ':TYO (LOAD-BYTE WORD 16. N-BITS)))))

#+IMACH
(DEFUN DUMP-I-COMPILED-FUNCTION (FUNCTION STREAM)
  (WITH-STACK-LIST* (*DUMPING-COMPILED-FUNCTIONS* FUNCTION *DUMPING-COMPILED-FUNCTIONS*)
    (ENTER-TABLE FUNCTION STREAM)
    (SEND STREAM ':TYO BIN-OP-I-COMPILED-FUNCTION)
    (MACROLET ((SEND-WORD (STREAM WORD)
			  (ONCE-ONLY (WORD)
			    `(PROGN (SEND ,STREAM :TYO (LDB (BYTE 16. 00.) ,WORD))
				    (SEND ,STREAM :TYO (LDB (BYTE 16. 16.) ,WORD)))))
	       (SEND-TAG (STREAM TAG &REST BITS)
			 (LOOP WITH RESULT = 0
			       FOR BIT IN BITS
			       DOING
			   (CL:ECASE BIT
			     (:TYPE-FROM-TAG
			       (SETF (LDB %%I-COMPILED-FUNCTION-TYPE-FROM-TAG RESULT) 1))
			     (:IMMEDIATE (SETF (LDB %%I-COMPILED-FUNCTION-IMMEDIATE RESULT) 1))
			     (:RELATIVE (SETF (LDB %%I-COMPILED-FUNCTION-RELATIVE RESULT) 1)))
			       FINALLY
				 (RETURN
				   `(SEND ,STREAM :TYO
					  ,(IF (ZEROP RESULT)
					       TAG
					       `(LOGIOR ,TAG ,RESULT)))))))
      (LET* ((CCA (SYS:COMPILED-FUNCTION-CCA FUNCTION))
	     (TOTAL-SIZE (CCA-TOTAL-SIZE CCA))
	     (SUFFIX-SIZE (CCA-SUFFIX-SIZE CCA))
	     (EXTRA-INFO (CCA-EXTRA-INFO-FOR-DEBUGGING CCA))
	     (FDEFINITION-HINTS (CDR (ASSQ ':FDEFINITION-LOCATION-HINTS (CDR EXTRA-INFO)))))
	(DUMP-OBJECT TOTAL-SIZE STREAM)
	(DUMP-OBJECT SUFFIX-SIZE STREAM)

	;; Dump extra-info needed by storage categories and area
	(LET ((STORAGE-CATEGORY (CL:ASSOC 'SI:STORAGE-CATEGORY (CDR EXTRA-INFO)))
	      (AREA (CL:ASSOC 'COMPILER:AREA (CDR EXTRA-INFO))))
	  (DUMP-OBJECT (IF STORAGE-CATEGORY
			   (IF AREA
			       (LIST (FIRST EXTRA-INFO) STORAGE-CATEGORY AREA)
			       (LIST (FIRST EXTRA-INFO) STORAGE-CATEGORY))
			   (IF AREA
			       (LIST (FIRST EXTRA-INFO) AREA)
			       (LIST (FIRST EXTRA-INFO))))
		       STREAM))

	(FLET ((DUMP-LOCATIVE-REFERENCE (TAG LOCATIVE OFFSET FDEFINITION-HINTS STREAM)
		 (SEND-TAG STREAM TAG :TYPE-FROM-TAG)
		 ;; See if there are any hints about this
		 (LET* ((PC (* 2 OFFSET))
			(INDEX)
			(REFERENCE
			  (LOOP FOR (FSPEC . INDICES) IN FDEFINITION-HINTS
				DOING
			    (WHEN (CL:MEMBER PC INDICES)
			      (RETURN FSPEC)))))
		   (IF REFERENCE
		       (IF (SETQ INDEX (AND *BIN-DUMP-TABLE*
					    (CL:GETHASH LOCATIVE *BIN-DUMP-TABLE*)))
			   (COND ((< INDEX 1_14)
				  (SEND STREAM ':TYO
					(DPB BIN-OP-TABLE-FETCH-IMMEDIATE
					     %%BIN-OP-HIGH INDEX)))
				 ((< INDEX 1_20)
				  (SEND STREAM ':TYO BIN-OP-TABLE-FETCH-MEDIUM)
				  (SEND STREAM ':TYO INDEX))
				 (T
				  (SEND STREAM ':TYO BIN-OP-TABLE-FETCH-LARGE)
				  (SEND STREAM ':TYO (LDB (BYTE 20 0) INDEX))
				  (SEND STREAM ':TYO (LDB (BYTE 20 20) INDEX))))
			   (PROGN
			     (ENTER-TABLE LOCATIVE STREAM)
			     (SEND STREAM :TYO BIN-OP-FDEFINITION-LOCATION)
			     (DUMP-OBJECT REFERENCE STREAM)))
		       (DUMP-OBJECT LOCATIVE STREAM)))))
	  (LOOP FOR PTR FIRST (%MAKE-POINTER-OFFSET
				DTP-LOCATIVE CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION))
			THEN (%POINTER-PLUS PTR 1)
		FOR OFFSET FROM 0 BELOW (- TOTAL-SIZE (DEFSTORAGE-SIZE COMPILED-FUNCTION))
		DOING
	    (LET* ((WORD (%MEMORY-READ PTR :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))
		   (TAG (%TAG WORD)))
	      ;; Immediate data
	      (COND ((OR (TYPE-MEMBER WORD
				      DTP-PACKED-INSTRUCTION-60 DTP-PACKED-INSTRUCTION-61
				      DTP-PACKED-INSTRUCTION-62 DTP-PACKED-INSTRUCTION-63
				      DTP-PACKED-INSTRUCTION-64 DTP-PACKED-INSTRUCTION-65
				      DTP-PACKED-INSTRUCTION-66 DTP-PACKED-INSTRUCTION-67)
			 (TYPE-MEMBER WORD
				      DTP-PACKED-INSTRUCTION-70 DTP-PACKED-INSTRUCTION-71
				      DTP-PACKED-INSTRUCTION-72 DTP-PACKED-INSTRUCTION-73
				      DTP-PACKED-INSTRUCTION-74 DTP-PACKED-INSTRUCTION-75
				      DTP-PACKED-INSTRUCTION-76 DTP-PACKED-INSTRUCTION-77)
			 (TYPE-MEMBER WORD DTP-FIXNUM DTP-SINGLE-FLOAT DTP-SMALL-RATIO)
			 (AND (TYPEP WORD :CHARACTER)
			      (ZEROP (CHAR-LDB-INTERNAL %%CHAR-CHAR-SET WORD))
			      (ZEROP (CHAR-LDB-INTERNAL %%CHAR-STYLE WORD))))
		     ;; Immediate data
		     (SEND-TAG STREAM TAG :IMMEDIATE :TYPE-FROM-TAG)
		     (SEND-WORD STREAM (%POINTER WORD)))
		    ((TYPE-MEMBER WORD
				  DTP-EXTERNAL-VALUE-CELL-POINTER
				  DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH)
		     (DUMP-LOCATIVE-REFERENCE
		       TAG (%SET-TAG WORD DTP-LOCATIVE) OFFSET FDEFINITION-HINTS STREAM))
		    ((TYPE-MEMBER WORD DTP-CALL-GENERIC-PREFETCH)
		     (SEND-TAG STREAM TAG :TYPE-FROM-TAG)
		     (DUMP-OBJECT (%MAKE-POINTER DTP-GENERIC-FUNCTION WORD) STREAM))
		    ((TYPE-MEMBER WORD DTP-CALL-GENERIC)
		     ;; This is a direct call generated by the linker.  Dump it as
		     ;; an indirect call.
		     (DUMP-LOCATIVE-REFERENCE
		       ;;--- Need to parse code to determine the prefetch bit.
		       (DPB DTP-CALL-INDIRECT %%Q-TYPE-WITHIN-TAG TAG)
		       (FOLLOW-CELL-FORWARDING
			 (FDEFINITION-LOCATION (GENERIC-FUNCTION-NAME
						 (%SET-TAG WORD DTP-GENERIC-FUNCTION)))
			 NIL)
		       OFFSET FDEFINITION-HINTS STREAM))
		    ;; See if this is a pointer into this function, as opposed to a
		    ;; pointer elsewhere.  If this is the case, we have to dump a
		    ;; relative pointer.
		    ((AND (NOT (%POINTER-LESSP WORD FUNCTION))
			  (%UNSIGNED-LESSP (%POINTER-DIFFERENCE WORD CCA) TOTAL-SIZE))
		     (SEND-TAG STREAM TAG :RELATIVE :TYPE-FROM-TAG :IMMEDIATE)
		     (SEND-WORD STREAM (%POINTER-DIFFERENCE WORD FUNCTION)))
		    ((TYPE-MEMBER WORD
				  DTP-CALL-COMPILED-EVEN
				  DTP-CALL-COMPILED-ODD
				  DTP-CALL-COMPILED-EVEN-PREFETCH
				  DTP-CALL-COMPILED-ODD-PREFETCH)
		     (LET ((PC (%SET-TAG WORD
					 (IF (TYPE-MEMBER WORD
							  DTP-CALL-COMPILED-EVEN-PREFETCH
							  DTP-CALL-COMPILED-EVEN)
					     DTP-EVEN-PC
					     DTP-ODD-PC))))
		       (MULTIPLE-VALUE-BIND (CALLED-FUNCTION OFFSET)
			   (DECODE-PC PC)
			 (IF (MEMQ CALLED-FUNCTION
				   (COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS FUNCTION))
			     (PROGN
			       (SEND-TAG STREAM TAG :TYPE-FROM-TAG)
			       (DUMP-OBJECT PC STREAM))
			     ;; Dump this as if it were a CALL-INDIRECT.
			     ;; Note that this clause has to come after
			     ;; the relative pointer check since the
			     ;; compiler generates direct calls within a
			     ;; compiled function.
			     (DUMP-LOCATIVE-REFERENCE
			       (DPB (IF (TYPE-MEMBER WORD
						     DTP-CALL-COMPILED-EVEN
						     DTP-CALL-COMPILED-ODD)
					DTP-CALL-INDIRECT
					DTP-CALL-INDIRECT-PREFETCH)
				    %%Q-TYPE-WITHIN-TAG
				    TAG)
			       (LOCF (CCA-FUNCTION-CELL
				       (COMPILED-FUNCTION-CCA CALLED-FUNCTION)))
			       OFFSET FDEFINITION-HINTS STREAM)))))
		    (T
		      (SEND-TAG STREAM TAG)
		      (DUMP-OBJECT WORD STREAM))))))))))

(DEFPROP DTP-ODD-PC DUMP-PC DUMP-OBJECT)
(DEFPROP DTP-EVEN-PC DUMP-PC DUMP-OBJECT)

(DEFUN DUMP-PC (PC STREAM)
  (MULTIPLE-VALUE-BIND (FUNCTION OFFSET)
      (DECODE-PC PC)
    (CL:ETYPECASE FUNCTION
      (CL:COMPILED-FUNCTION
	(COND ((MEMQ FUNCTION *DUMPING-COMPILED-FUNCTIONS*)
	       (ENTER-TABLE PC STREAM T)
	       (DUMP-FORM-TO-EVAL `(LOAD-PC ',(COMPILED-FUNCTION-NAME FUNCTION)
					    ,OFFSET)
				  STREAM))
	      #+IMach
	      ((DOLIST (DUMPED-FUNCTION *DUMPING-COMPILED-FUNCTIONS*)
		 (WHEN (MEMQ FUNCTION
			     (COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS
			       DUMPED-FUNCTION))
		   (RETURN T)))
	       (ENTER-TABLE PC STREAM T)
	       (DUMP-FORM-TO-EVAL `(%MAKE-PC ,FUNCTION ,OFFSET) STREAM))
	      (T
	       (ERROR "PC ~S is not in a function being dumped." PC)))))))

#+Imach
(DEFUN (:PROPERTY DTP-PHYSICAL-ADDRESS DUMP-OBJECT) (PHYSICAL-ADDRESS STREAM)
  (DUMP-FORM-TO-EVAL `(%SET-TAG ,(%FIXNUM PHYSICAL-ADDRESS) ,DTP-PHYSICAL-ADDRESS) STREAM))

;; Constants embedded in compiled functions.
#+IMach
(DEFUN MAYBE-DUMP-EMBEDDED-CONSTANT (OBJECT STREAM)
  (DECLARE (VALUES DUMPED-P))
  (LET ((TYPE (SYS:%DATA-TYPE OBJECT)))
    (WHEN (SYS:%POINTER-TYPE-P TYPE)
      (LET ((FUNCTIONS *DUMPING-COMPILED-FUNCTIONS*))
	(WHEN FUNCTIONS
	  (LET* ((FUNCTION (CAR FUNCTIONS))
		 (CCA (COMPILED-FUNCTION-CCA FUNCTION))
		 (TOTAL-SIZE (CCA-TOTAL-SIZE CCA))
		 (OFFSET (%POINTER-DIFFERENCE OBJECT CCA)))
	    (WHEN (AND (NOT (MINUSP OFFSET)) (%UNSIGNED-LESSP OFFSET TOTAL-SIZE))
	      ;; This is an embedded constant, so dump it specially.
	      ;; The low 3 bits of the operand encode the data type, and the high 9 bits
	      ;; are the offset from the CCA.  If an encoding doesn't work this way, then
	      ;; we just dump a form to evaluate.
	      (BLOCK TRY-FAST
		(WHEN (< OFFSET 1_9)
		  (LET ((DATA-TYPE-CODE (SELECT TYPE
					  (DTP-LIST 0)
					  (DTP-LEXICAL-CLOSURE 1)
					  (DTP-DYNAMIC-CLOSURE 2)
					  (DTP-DOUBLE-FLOAT 3)
					  (DTP-BIG-RATIO 4)
					  (DTP-COMPLEX 5)
					  (DTP-COMPILED-FUNCTION 6)
					  (DTP-LOCATIVE 7)
					  (OTHERWISE (RETURN-FROM TRY-FAST)))))
		    (SEND STREAM :TYO (DPBS BIN-OP-EMBEDDED-CONSTANT-IMMEDIATE %%BIN-OP-HIGH
					    OFFSET (BYTE 9 3)
					    DATA-TYPE-CODE))
		    (RETURN-FROM MAYBE-DUMP-EMBEDDED-CONSTANT T))))
	      ;; This works because CCA will get dumped out with DTP-LOCATIVE, above.
	      (DUMP-FORM-TO-EVAL `(%MAKE-POINTER-OFFSET ,TYPE ,CCA ,OFFSET) STREAM)
	      ;; Return T so that the caller won't dump the object again.
	      T)))))))

#+IMach
(DEFUN DUMP-NATIVE-INSTRUCTION (FIXNUM STREAM)
  ;; Dumps as 2 16 bit chunks, least significant chunk first.  Does not enter in the table
  (SETQ FIXNUM (%POINTER FIXNUM))
  (SEND STREAM ':TYO BIN-OP-NATIVE-INSTRUCTION)
  (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 00.) FIXNUM))
  (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 16.) FIXNUM)))

(DEFUN DUMP-GENERIC-FUNCTION (GENERIC-FUNCTION STREAM)
  (DUMP-FORM-TO-EVAL (FLAVOR::GENERIC-FUNCTION-FASD-FORM GENERIC-FUNCTION)
		     STREAM))

(DEFUN DUMP-ARRAY (ARRAY STREAM)
  (LET ((NSS (NAMED-STRUCTURE-P ARRAY)))
    (WHEN NSS
      (LET ((NSI (GET NSS 'NAMED-STRUCTURE-INVOKE)))
	(WHEN (AND NSI (MEMQ :FASD-FORM (FUNCALL NSI :WHICH-OPERATIONS)))
	  (ENTER-TABLE ARRAY STREAM T)
	  (RETURN-FROM DUMP-ARRAY
	    (DUMP-FORM-TO-EVAL (FUNCALL NSI :FASD-FORM ARRAY) STREAM))))))
  (ENTER-TABLE ARRAY STREAM)
  (MULTIPLE-VALUE-BIND (DIMENSIONS OPTIONS)
      (DECODE-ARRAY ARRAY)
    (IF (GET (LOCF OPTIONS) ':DISPLACED-TO)
	(DUMP-ARRAY-1 STREAM DIMENSIONS OPTIONS)
	(LET ((LENGTH (ARRAY-LENGTH ARRAY))	;Flattened size
	      (N-BITS (CDR (ASSQ (GET (LOCF OPTIONS) ':TYPE) ARRAY-BITS-PER-ELEMENT)))
	      (FLOAT NIL))
	  ;; Detect the case where it is a Q array containing only immediate numbers
	  ;; all of the same data type.  This can be dumped more efficiently.
	  (AND (NULL N-BITS) (PLUSP LENGTH)
	       (LET* ((A ARRAY)
		      (TYPE (%DATA-TYPE (%1D-AREF A 0))))
		 (DECLARE (ARRAY-REGISTER-1D A))
		 (WHEN (AND (OR (= TYPE #+3600 DTP-FIX #+IMACH DTP-FIXNUM)
				(= TYPE #+3600 DTP-FLOAT #+IMACH DTP-SINGLE-FLOAT))
			    (LOOP FOR I FROM 1 BELOW LENGTH
				  ALWAYS (= (%DATA-TYPE (%1D-AREF A I)) TYPE)))
		   (SETQ N-BITS 32.)
		   (WHEN (= TYPE #+3600 DTP-FLOAT #+IMACH DTP-SINGLE-FLOAT) (SETQ FLOAT T))
		   (PUSH 0 OPTIONS)
		   (PUSH ':INITIAL-VALUE OPTIONS))))
	  (COND ((NULL N-BITS)			;Q type array
		 (SEND STREAM ':TYO BIN-OP-INITIALIZE-AND-RETURN-ARRAY)
		 (DUMP-ARRAY-1 STREAM DIMENSIONS OPTIONS)
		 (DUMP-OBJECT LENGTH STREAM)
		 (LET ((Q-ARRAY (IF (NOT (CL:LISTP DIMENSIONS)) ARRAY
				    (MAKE-ARRAY LENGTH ':DISPLACED-TO ARRAY))))
		   (DOTIMES (I LENGTH)
		     (DUMP-OBJECT (AREF Q-ARRAY I) STREAM))
		   (OR (EQ ARRAY Q-ARRAY) (RETURN-ARRAY Q-ARRAY))))
		(T
		 (LET* ((RESIDUE 0)
			(16-ARRAY (COND ((AND (NOT (CL:LISTP DIMENSIONS)) (= N-BITS 16.))
					 ARRAY)
					(T
					 (MULTIPLE-VALUE (LENGTH RESIDUE)
					   (FLOOR (* LENGTH N-BITS) 16.))
					 (MAKE-ARRAY LENGTH ':TYPE 'ART-16B
						     ':DISPLACED-TO (AND (NOT FLOAT)
									 ARRAY))))))
		   ;; Defeat error checking for floating-point arrays
		   ;; by copying into ART-16B instead of using an indirect array
		   (WHEN FLOAT
		     (SEND STREAM ':TYO BIN-OP-CONVERT-ARRAY-TO-FLOATING)
		     (LOOP FOR P = (%1D-ALOC ARRAY 0)
				 THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)
			   FOR Q = (%MAKE-POINTER-OFFSET DTP-LOCATIVE 16-ARRAY
							 (ARRAY-DATA-OFFSET 16-ARRAY))
				 THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE Q 1)
			   REPEAT (// LENGTH 2)
			   DO (%P-STORE-CONTENTS Q (%P-LDB %%Q-FIXNUM P))))
		   (SEND STREAM ':TYO BIN-OP-INITIALIZE-AND-RETURN-NUMERIC-ARRAY)
		   (DUMP-ARRAY-1 STREAM DIMENSIONS OPTIONS)
		   (DUMP-OBJECT (IF (ZEROP RESIDUE) LENGTH (1+ LENGTH)) STREAM)
		   (SEND STREAM ':STRING-OUT 16-ARRAY 0 LENGTH)
		   (UNLESS (ZEROP RESIDUE)
		     ;; Dump out the partial 16-bit word.  Can't get it from the indirect
		     ;; array because that would violate array bounds checking.  Can't get
		     ;; it from the original array because it might not be a numeric array.
		     (LET ((BIT-ARRAY (MAKE-ARRAY RESIDUE :TYPE 'ART-1B :DISPLACED-TO ARRAY
						  :DISPLACED-INDEX-OFFSET (* LENGTH 16.))))
		       (SEND STREAM ':TYO
			     (LOOP FOR I FROM 0 BELOW RESIDUE
				   SUM (ASH (AREF BIT-ARRAY I) I)))
		       (RETURN-ARRAY BIT-ARRAY)))
		   (OR (EQ ARRAY 16-ARRAY) (RETURN-ARRAY 16-ARRAY)))))))))

(DEFUN DUMP-ARRAY-1 (STREAM DIMENSIONS OPTIONS)
  (SEND STREAM ':TYO (DPB BIN-OP-ARRAY %%BIN-OP-HIGH (// (LENGTH OPTIONS) 2)))
  (DUMP-OBJECT DIMENSIONS STREAM)
  (DOLIST (FORM OPTIONS)
    (DUMP-OBJECT FORM STREAM)))

(DEFUN DECODE-ARRAY (ARRAY &AUX DIMENSIONS OPTIONS)
  (SETQ DIMENSIONS (IF (= (ARRAY-/#-DIMS ARRAY) 1) (ARRAY-LENGTH ARRAY)
		       (ARRAY-DIMENSIONS ARRAY)))
  (LET ((TYPE (ARRAY-TYPE ARRAY)))
    (OR (EQ TYPE 'ART-Q)
	(SETQ OPTIONS `(:TYPE ,TYPE . ,OPTIONS))))
  (AND (ARRAY-HAS-LEADER-P ARRAY)
       (SETQ OPTIONS `(:LEADER-LIST ,(LIST-ARRAY-LEADER ARRAY) . ,OPTIONS)))
  (AND (NAMED-STRUCTURE-P ARRAY)
       (SETQ OPTIONS `(:NAMED-STRUCTURE-SYMBOL ,(NAMED-STRUCTURE-SYMBOL ARRAY) . ,OPTIONS)))
  (AND (ARRAY-DISPLACED-P ARRAY)
       (LET ((TEM (SI:ARRAY-INDEX-OFFSET ARRAY)))
	 (SETQ OPTIONS `(:DISPLACED-TO ,(SI:ARRAY-INDIRECT-TO ARRAY)
			 ,@(AND TEM (NOT (ZEROP TEM)) `(:DISPLACED-INDEX-OFFSET ,TEM))
			 . ,OPTIONS))
	 #+3600
	 (WHEN (SELECTOR (ARRAY-DISPATCH-FIELD ARRAY) =
		 ((%ARRAY-DISPATCH-LONG %ARRAY-DISPATCH-LONG-MULTIDIMENSIONAL) T))
	   (SETQ OPTIONS `(:ADJUSTABLE T . ,OPTIONS)))
	 #+IMACH
	 (UNLESS (ZEROP (ARRAY-LONG-PREFIX-BIT ARRAY))
	   (SETQ OPTIONS `(:ADJUSTABLE T . ,OPTIONS)))
	 (WHEN (AND (LISTP DIMENSIONS) (> (LENGTH DIMENSIONS) 1)
		    (ARRAYP (SI:ARRAY-INDIRECT-TO ARRAY))
		    ;; displaced multidimensional arrays must be
		    ;; array-dispatch-long-multidimensional
		    #+3600
		    (LOOP FOR AXIS DOWNFROM (LENGTH DIMENSIONS) TO 2
			  FOR OFFSET
			      DOWNFROM (1- (ARRAY-LONG-PREFIX-LENGTH-FIELD ARRAY))
			  WITH RUNNING = 1
			  AS MULTIPLIER = (ARRAY-DIMENSION-N AXIS ARRAY)
			  DO (SETQ RUNNING (* RUNNING MULTIPLIER))
			  THEREIS ( RUNNING (%P-CONTENTS-OFFSET ARRAY OFFSET)))
		    #+IMACH
		    (NOT (ZEROP (ARRAY-DISCONTIGUOUS-BIT ARRAY)))
		    )
	   (SETQ OPTIONS `(:DISPLACED-CONFORMALLY T . ,OPTIONS)))
	 ))
  (VALUES DIMENSIONS OPTIONS))


;;; number types

(DEFUN DUMP-32-BIT-FIXNUM (FIXNUM STREAM)
  ;; dumps as 2 16 bit chunks, least significant chunk first.  Does not enter in the table
  (SEND STREAM ':TYO BIN-OP-32-BIT-FIXNUM)
  (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 00.) FIXNUM))
  (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 16.) FIXNUM)))

(DEFUN DUMP-LARGE-INTEGER (NUMBER STREAM)
  (ENTER-TABLE NUMBER STREAM)
  (IF (NOT (MINUSP NUMBER))
      (SEND STREAM ':TYO BIN-OP-INTEGER)
      (SEND STREAM ':TYO BIN-OP-NEGATIVE-INTEGER)
      (SETQ NUMBER (- NUMBER)))
  (LET ((LENGTH (CEILING (HAULONG NUMBER) 16.)))
    (DUMP-OBJECT LENGTH STREAM)
    (LOOP REPEAT LENGTH
	  FOR POS FROM 0 BY 16.
	  DO (SEND STREAM ':TYO (LOAD-BYTE NUMBER POS 16.)))))

(DEFUN DUMP-IEEE-SINGLE-FLOAT (SINGLE-FLOAT STREAM)
  ;; Dumps the 32 bit object as 2 16 bit chunks, -> MOST <- significant
  ;; first.  Does not enter in the table.
  (LET ((FIXNUM (%FIXNUM SINGLE-FLOAT)))
    (SEND STREAM ':TYO BIN-OP-IEEE-SINGLE-FLOAT)
    (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 16.) FIXNUM))
    (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 00.) FIXNUM))))

(DEFUN DUMP-IEEE-DOUBLE-FLOAT (DOUBLE-FLOAT STREAM)
  ;; Dumps the 64 bit object as 4 16 bit chunks, -> MOST <- significant
  ;; first to -> LEAST <- significant last.  Does not enter in the table
  (LET ((HIGH (SI:DOUBLE-HIGH DOUBLE-FLOAT))
	(LOW  (SI:DOUBLE-LOW  DOUBLE-FLOAT)))
    (SEND STREAM ':TYO BIN-OP-IEEE-DOUBLE-FLOAT)
    (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 16.) HIGH))
    (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 00.) HIGH))
    (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 16.) LOW))
    (SEND STREAM ':TYO (%LOGLDB (BYTE 16. 00.) LOW))))

(DEFUN DUMP-RATIO (NUMBER STREAM)
  (ENTER-TABLE NUMBER STREAM)
  (SEND STREAM ':TYO BIN-OP-RATIO)
  (DUMP-OBJECT (SI:RATIONAL-NUMERATOR NUMBER) STREAM)
  (DUMP-OBJECT (SI:RATIONAL-DENOMINATOR NUMBER) STREAM))

(DEFUN DUMP-COMPLEX (COMPLEX STREAM)
  ;; Does not enter into table
  (SEND STREAM ':TYO BIN-OP-COMPLEX)
  (DUMP-OBJECT (SI:COMPLEX-REALPART COMPLEX) STREAM)
  (DUMP-OBJECT (SI:COMPLEX-IMAGPART COMPLEX) STREAM))



(DEFVAR *COUNT-DUMP-FLOAT* 0)
;; --- this should be obsolete.  Remove before Release 8.  Also dump and unbin
(DEFUN DUMP-FLOAT (NUMBER STREAM)
  (INCF *COUNT-DUMP-FLOAT*)
  (ENTER-TABLE NUMBER STREAM)
  (MULTIPLE-VALUE-BIND (MANTISSA EXPONENT SIGN)
      (INTEGER-DECODE-FLOAT NUMBER)
    (WHEN (AND (ZEROP MANTISSA)
	       (NUMBERP EXPONENT))
      (SETF EXPONENT 0))
    (SEND STREAM ':TYO (IF (MINUSP SIGN) BIN-OP-NEGATIVE-FLOAT BIN-OP-FLOAT))
    (DUMP-OBJECT MANTISSA STREAM)
    (DUMP-OBJECT EXPONENT STREAM)))

(DEFVAR *COUNT-DUMP-EXTENDED-NUMBER* 0)
;; --- this should be obsolete.  Remove before Release 8.  Also the dump and unbin.

;Assumes only that no data is stored in the cdr codes
;and that the format doesn't change between the dumping system and the loading system
;Use this for doubles, complexes, whatever else pops up
(DEFUN DUMP-EXTENDED-NUMBER (NUMBER STREAM)
  (INCF *COUNT-DUMP-EXTENDED-NUMBER*)
  (ENTER-TABLE NUMBER STREAM)
  (SEND STREAM ':TYO BIN-OP-EXTENDED-NUMBER)
  (LET ((N (%STRUCTURE-TOTAL-SIZE NUMBER)))
    (DUMP-OBJECT N STREAM)
    (DUMP-OBJECT (%P-LDB-OFFSET %%Q-POINTER NUMBER 0) STREAM)
    (LOOP FOR I FROM 1 BELOW N
	  DO (DUMP-OBJECT (%P-CONTENTS-OFFSET NUMBER I) STREAM))))



(DEFUN DUMP-INSTANCE (INSTANCE STREAM)
  ;; Prepare for the result of evaluating the form to be stored into the bin-load-table
  (MULTIPLE-VALUE-BIND (MAKER INITIALIZER)
      (IF (OR (FUNCALLABLE-INSTANCE-P INSTANCE)
	      (NOT (FLAVOR-INSTANCE-P INSTANCE)))
	  (CLOS:MAKE-LOAD-FORM INSTANCE)
	  (VALUES (SEND INSTANCE :FASD-FORM)))
    (LET ((INDEX (ENTER-TABLE INSTANCE STREAM T T NIL INITIALIZER)))
      (DUMP-FORM-TO-EVAL MAKER STREAM)
      (FINISH-ENTER-TABLE INSTANCE INDEX))
    (WHEN INITIALIZER
      (DUMP-FORM-TO-EVAL INITIALIZER STREAM))))

(DEFUN DUMP-ATTRIBUTE-LIST (PLIST STREAM)
  (LET ((PKG (GET (LOCF PLIST) ':PACKAGE))
	(SYNTAX (GET (LOCF PLIST) :SYNTAX)))
    (WHEN PKG
      (SETQ *BIN-DUMP-PACKAGE* (FIND-PACKAGE-FOR-SYNTAX PKG SYNTAX)))
    (WHEN SYNTAX
      (SETQ *BIN-DUMP-SYNTAX* (FIND-LISP-SYNTAX SYNTAX))))
  (SEND STREAM ':TYO BIN-OP-FILE-ATTRIBUTE-LIST)
  ;; Put package prefixes on everything in the plist since it will be loaded in
  ;; the wrong package.  This way the symbols in the plist will always
  ;; be loaded into exactly the same package they were dumped from,
  ;; while the rest of the symbols in the file will be free to follow
  ;; the usual rules for intern.
  (LET ((*BIN-DUMP-PACKAGE* NIL)
	(*BIN-DUMP-SYNTAX*  NIL))
    (DUMP-OBJECT PLIST STREAM)))

(DEFUN DUMP-CHARACTER (CHAR STREAM)
  (ENTER-TABLE CHAR STREAM)
  (COND ((AND (ZEROP (CHAR-LDB-INTERNAL %%CHAR-CHAR-SET CHAR))
	      (ZEROP (CHAR-LDB-INTERNAL %%CHAR-STYLE CHAR)))
	 ;; The BIN-OP-SMALL-CHARACTER case prevents infinite recursion
	 ;; in dumping NIL.NIL.NIL, (remember symbol's pname's!).
	 ;; (Not to mention being a hell of a lot more efficient!)
	 (SEND STREAM ':TYO BIN-OP-SMALL-CHARACTER)
	 ;; Explicit hackery here.  We dump a 12-bit number here.
	 ;; CHAR-SUBINDEX is known to be 8 bits, and BITS, 4.
	 (DUMP-OBJECT (DPB (CHAR-BITS CHAR) (BYTE 4 8)
			   (CHAR-SUBINDEX CHAR))
		      STREAM))
	(T
	 (SEND STREAM ':TYO BIN-OP-CHARACTER)
	 (DUMP-OBJECT (CHAR-BITS CHAR) STREAM)
	 (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	     (CHAR-CHAR-SET-AND-INDEX CHAR)
	   (DUMP-OBJECT CHAR-SET STREAM)
	   (DUMP-OBJECT INDEX STREAM))
	 (DUMP-OBJECT (CHAR-STYLE CHAR) STREAM))))

(DEFUN DUMP-CHARACTER-STYLE (STYLE STREAM)
  (LET ((INDEX (ENTER-TABLE STYLE STREAM NIL T)))
    (SEND STREAM :TYO BIN-OP-CHARACTER-STYLE)
    (DUMP-OBJECT (CS-FAMILY STYLE) STREAM)
    (DUMP-OBJECT (CS-FACE STYLE) STREAM)
    (DUMP-OBJECT (CS-SIZE STYLE) STREAM)
    (DUMP-OBJECT (CS-EXTENDED-ATTRIBUTES STYLE) STREAM)
    (FINISH-ENTER-TABLE STYLE INDEX)))

(DEFUN DUMP-CHARACTER-SET (CHAR-SET STREAM)
  (LET ((INDEX (ENTER-TABLE CHAR-SET STREAM NIL T)))
    (SEND STREAM :TYO BIN-OP-CHARACTER-SET)
    (DUMP-OBJECT (SEND CHAR-SET :NAME) STREAM)
    (FINISH-ENTER-TABLE CHAR-SET INDEX)))
