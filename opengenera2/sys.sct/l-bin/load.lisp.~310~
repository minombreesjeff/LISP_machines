;;;-*- Mode:LISP; Package:SI; Base:8. -*-
;;; L machine binary file loader
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFRESOURCE BIN-LOAD-TABLE ()
  :CONSTRUCTOR (MAKE-ARRAY 1000 :FILL-POINTER 0)
  :INITIALIZER (SETF (FILL-POINTER OBJECT) 0)
  :DEINITIALIZER (SI:FILL-ARRAY OBJECT (CL:LENGTH OBJECT) NIL)
  :CLEAR-FOR-GC :CLEANUP
  )

(DEFUN LOADING-BIN-FILE-INTERNAL
       (STREAM NEXT-COMMAND-FUNCTION CONTINUATION SKIP-READING-ATTRIBUTE-LIST)
  (LET ((*BIN-NEXT-COMMAND-FUNCTION* NEXT-COMMAND-FUNCTION)
	(*BIN-LOAD-INDEX* 0)
	(*BIN-LOAD-STREAM-BUFFERED-P* (OPERATION-HANDLED-P STREAM :READ-INPUT-BUFFER))
	(*LOADING-COMPILED-FUNCTIONS* NIL)
	(*BIN-DEFINITION-FORWARD-REFERENCE-ALIST* NIL)
	(PATCH-SOURCE-FILE-PATHNAME NIL)
	(FUTURE-COMMON-LISP:*LOAD-TRUENAME* (SEND-IF-HANDLES STREAM :TRUENAME)))
    (MULTIPLE-VALUE-BIND (FUTURE-COMMON-LISP:*LOAD-PATHNAME* PATHNAME-PLIST
			  FDEFINE-FILE-PATHNAME SI:FASL-GENERIC-PATHNAME-PLIST)
	(SEND STREAM :GENERIC-PATHNAME-AND-PLIST)
      (USING-RESOURCE (*BIN-LOAD-TABLE* BIN-LOAD-TABLE)
	(LET ((*BIN-LOAD-TABLE-LENGTH* (ARRAY-LENGTH *BIN-LOAD-TABLE*)))
	  (BIN-LOAD-START STREAM SKIP-READING-ATTRIBUTE-LIST)
	  ;; Enter appropriate environment defined by file attribute list
	  (MULTIPLE-VALUE-BIND (VARS VALS)
	      (FS:FILE-ATTRIBUTE-BINDINGS SI:FASL-GENERIC-PATHNAME-PLIST)
	    (PROGV VARS VALS
	      (LET ((*BIN-LOAD-PACKAGE* PACKAGE)
		    (*BIN-LOAD-SYNTAX* (CURRENT-LISP-SYNTAX)))
		(FUNCALL CONTINUATION FUTURE-COMMON-LISP:*LOAD-PATHNAME* PATHNAME-PLIST)))))))))

;; Changed 6/27/85 by DLA not to hack *NO-VALUE-MARKER* or worry about multiple values.
;; None of the callers of this grok multiple values, and open coding saves lots of time.
(DEFSUBST BIN-NEXT-VALUE (STREAM)
  (BIN-NEXT-COMMAND STREAM))

(DEFMACRO WITH-FAST-BIN-NEXT-VALUE ((STREAM-VAR) &BODY BODY)
  `(LET ((.BIN-NEXT-COMMAND-FUNCTION. *BIN-NEXT-COMMAND-FUNCTION*))
     (MACROLET ((FAST-BIN-NEXT-VALUE ()
		  '(FUNCALL .BIN-NEXT-COMMAND-FUNCTION. ,STREAM-VAR)))
       . ,BODY)))

;(DEFUN BIN-NEXT-VALUE (STREAM)
;  (DO (VAL1 VAL2 VAL3) (NIL)
;    (MULTIPLE-VALUE (VAL1 VAL2 VAL3)
;      (BIN-NEXT-COMMAND STREAM))
;    (OR (EQ VAL1 *NO-VALUE-MARKER*)
;	(RETURN (VALUES VAL1 VAL2 VAL3)))))

(DEFSUBST BIN-NEXT-BYTE (STREAM)
  (OR (SEND STREAM :TYI)
      (BIN-UNEXPECTED-EOF-ERROR)))

(DEFUN BIN-UNEXPECTED-EOF-ERROR ()
  (DECLARE (DBG:ERROR-REPORTER))
  (FERROR "Unexpected end of file before logical end of binary data"))

(DEFUN BIN-LOAD-TOP-LEVEL (STREAM)
  (CATCH 'BIN-LOAD-DONE
    (LOOP DOING (BIN-NEXT-COMMAND STREAM))))

(DEFUN BIN-LOAD-START (STREAM &OPTIONAL SKIP-READING-ATTRIBUTE-LIST)
  (LET ((WORD (BIN-NEXT-BYTE STREAM)))
    (OR (= WORD BIN-OP-FORMAT-VERSION)
	(FERROR NIL "~A is not a BIN file" (SEND STREAM ':TRUENAME)))
    (SEND STREAM ':UNTYI WORD)
    (BIN-NEXT-COMMAND STREAM))
  ;; Read in the file attribute list before choosing a package.
  (UNLESS SKIP-READING-ATTRIBUTE-LIST
    (LET ((WORD (BIN-NEXT-BYTE STREAM)))
      (SEND STREAM ':UNTYI WORD)
      (AND (= WORD BIN-OP-FILE-ATTRIBUTE-LIST)
	   (BIN-NEXT-COMMAND STREAM)))))

(DEFVAR *BIN-OP-LOAD-COMMAND-TABLE* (MAKE-BIN-OP-DISPATCH-TABLE))

;;; A command that may return a value, but does not store it in the table
(DEFMACRO DEFINE-LOAD-COMMAND (OP-NAME ARGLIST &BODY BODY)
  `(DEFINE-BIN-COMMAND-OP ,OP-NAME DEFINE-LOAD-COMMAND
			  *BIN-OP-LOAD-COMMAND-TABLE* "LOAD-" ,ARGLIST
     . ,BODY))

;;; A command that does not return a value at all
(DEFMACRO DEFINE-LOAD-COMMAND-FOR-EFFECT (OP-NAME ARGLIST &BODY BODY)
  `(DEFINE-BIN-COMMAND-OP ,OP-NAME DEFINE-LOAD-COMMAND-FOR-EFFECT
			  *BIN-OP-LOAD-COMMAND-TABLE* "LOAD-" ,ARGLIST
     ,@BODY
     *NO-VALUE-MARKER*))

;;; A command that returns a value stored in the next slot in the table
(DEFMACRO DEFINE-LOAD-COMMAND-FOR-VALUE (OP-NAME ARGLIST &BODY BODY)
  `(DEFINE-BIN-COMMAND-OP ,OP-NAME DEFINE-LOAD-COMMAND-FOR-VALUE
			  *BIN-OP-LOAD-COMMAND-TABLE* "LOAD-" ,ARGLIST
     (ENTER-BIN-LOAD-TABLE (PROGN . ,BODY))))

(DEFMACRO ENTER-BIN-LOAD-TABLE (VALUE)
  `(LET ((.INDEX. *BIN-LOAD-INDEX*))
     (SETQ *BIN-LOAD-INDEX* (1+ .INDEX.))
     (ENTER-BIN-LOAD-TABLE-INTERNAL ,VALUE .INDEX.)))

(DEFUN ENTER-BIN-LOAD-TABLE-INTERNAL (VALUE INDEX)
  (LET ((BIN-LOAD-TABLE *BIN-LOAD-TABLE*))
    (WHEN ( INDEX *BIN-LOAD-TABLE-LENGTH*)
      (SETQ *BIN-LOAD-TABLE*
	    (SETQ BIN-LOAD-TABLE
		  (ADJUST-ARRAY-SIZE BIN-LOAD-TABLE
				     (SETQ *BIN-LOAD-TABLE-LENGTH*
					   (* 2 *BIN-LOAD-TABLE-LENGTH*))))))
    (UNLESS (< INDEX (CL:LENGTH BIN-LOAD-TABLE))
      (SETF (FILL-POINTER BIN-LOAD-TABLE) (1+ INDEX)))
    (ASET VALUE BIN-LOAD-TABLE INDEX)
    VALUE))

(DEFUN BIN-LOAD-NEXT-COMMAND (STREAM)
  (WITH-DECODED-BIN-OPCODE (INDEX EXTRA-ARG) (BIN-NEXT-BYTE STREAM)
    (LET ((FUNCTION (OR (BIN-OP-DISPATCH *BIN-OP-LOAD-COMMAND-TABLE* INDEX)
			(FERROR "BIN OP ~O unknown." INDEX))))
      (IF EXTRA-ARG
	  (FUNCALL FUNCTION STREAM EXTRA-ARG)
	  (FUNCALL FUNCTION STREAM)))))

;;; This is a copy of the :COMPILE-DATA property of the file being loaded, or NIL.
;;; It exists so that any subsystem can check for obsolete or incompatible systems.
(DEFVAR FASLOAD-COMPILE-DATA NIL)

;;; This is the stream being loaded.
(DEFVAR FASL-STREAM)

(DEFVAR *DEFAULT-BINARY-FILE-TYPE* #+3600 ':BIN
				   #+(AND IMACH (NOT VLM)) ':IBIN
				   #+(AND IMACH VLM) ':VBIN)

(DEFF LOAD-BINARY-FILE 'BIN-LOAD-FILE)

(DEFUN BIN-FILE-PATHNAME (FILE &OPTIONAL SET-P)
  (LET ((BIN-PATHNAME
	  (SEND (FS:MERGE-PATHNAMES FILE
				    (SEND (FS:DEFAULT-PATHNAME FS:LOAD-PATHNAME-DEFAULTS)
					  :NEW-CANONICAL-TYPE *DEFAULT-BINARY-FILE-TYPE*))
		:NEW-PATHNAME :VC-VERSION NIL :VC-BRANCH NIL)))
    (WHEN SET-P (FS:SET-DEFAULT-PATHNAME BIN-PATHNAME FS:LOAD-PATHNAME-DEFAULTS))
    BIN-PATHNAME))

(DEFUN BIN-LOAD-FILE (FILE &OPTIONAL INTO-PACKAGE NO-MSG-P)
  (WITH-OPEN-FILE (STREAM (BIN-FILE-PATHNAME FILE T) ':CHARACTERS NIL ':ERROR ':REPROMPT)
    (BIN-LOAD-FILE-INTERNAL STREAM INTO-PACKAGE NO-MSG-P)))


(DEFF LOAD-BINARY-FILE-INTERNAL 'BIN-LOAD-FILE-INTERNAL)

(DEFUN BIN-LOAD-PRETTY-PATHNAME (PATHNAME)
  PATHNAME)

#||
  (IF (AND (TYPEP PATHNAME 'FS:PATHNAME)
	   (SEND PATHNAME :TRUENAME)
	   (OR (EQ (SEND PATHNAME :VERSION) ':NEWEST)
	       (NULL (SEND PATHNAME :VERSION))))
      (FORMAT NIL "~A~@[(~D)~]" PATHNAME (SEND (SEND PATHNAME :TRUENAME) :VERSION))
      PATHNAME)
||#

;;; Cleanups needed for 7.1 type compatibility.
(DEFVAR *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE* NIL)

;;; Enable the above feature.
(DEFVAR-RESETTABLE *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE-ENABLE* NIL)

(DEFUN CLEANUP-BIN-LOAD-FUNCTIONS-TO-CALL ()
  (WHEN *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE*
    ;; Do them in the order they were defined.
    (SETQ *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE*
	  (NREVERSE *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE*))
    (LET ((*FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE-ENABLE* NIL))	;Just in case.
      (TV:DOLIST-NOTING-PROGRESS (FUN *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE*
				      "Cleaning up 7.1-format type expansions.")
	(FUNCALL FUN)))
    (SETQ *FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE* NIL)))

(ADD-INITIALIZATION "Finialize pending 7.1 type definitions"
		    '(CLEANUP-BIN-LOAD-FUNCTIONS-TO-CALL)
		    '(:WARM))

(DEFUN BIN-LOAD-FILE-INTERNAL (STREAM INTO-PACKAGE NO-MSG-P)
  (DECLARE (VALUES PATHNAME BINARY-TRUENAME))
  ;; If we're loading a file, any type definitions up to now must be
  ;; complete, so go ahead and finish them up.
  (CLEANUP-BIN-LOAD-FUNCTIONS-TO-CALL)
  (LET ((*FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE* NIL)
	(*FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE-ENABLE* T))
    (UNWIND-PROTECT
	(LOADING-BIN-FILE (STREAM PATHNAME #'BIN-LOAD-NEXT-COMMAND)
	  (LET* (;; Note that *BIN-LOAD-SYNTAX* was already bound in LOADING-BIN-FILE,
		 ;; so it needn't be bound again here.  The only reason that
		 ;; *BIN-LOAD-PACKAGE* is bound [again] here is in case we want to override
		 ;; the file's binding of package. -kmp 26-Jan-90
		 (PACKAGE (PKG-FIND-PACKAGE (OR INTO-PACKAGE PACKAGE)
					    ':ASK NIL *BIN-LOAD-SYNTAX*))
		 (*BIN-LOAD-PACKAGE* PACKAGE)
		 (FASL-STREAM STREAM)
		 (FASLOAD-COMPILE-DATA (GET SI:FASL-GENERIC-PATHNAME-PLIST ':COMPILE-DATA)))
	    (UNLESS (OR INTO-PACKAGE NO-MSG-P)
	      (FORMAT T "~&Loading ~A into package ~A~%"
		(BIN-LOAD-PRETTY-PATHNAME PATHNAME) *BIN-LOAD-PACKAGE*))
	    (LET* ((DUMPED-SOURCE-MODE-KEYWORD (GET SI:FASL-GENERIC-PATHNAME-PLIST ':MODE))
		   (SOURCE-MODE
		     (WHEN (VARIABLE-BOUNDP #'ZWEI:MAJOR-MODE-FROM-KEYWORD)
		       (ZWEI:MAJOR-MODE-FROM-KEYWORD
			 (OR DUMPED-SOURCE-MODE-KEYWORD :LISP) :SILENT))))
	      (IF SOURCE-MODE
		  (LOADING-FILE SI:FASL-GENERIC-PATHNAME-PLIST
		    (SEND SOURCE-MODE ':LOAD-BINARY-FILE
			  SI:FASL-GENERIC-PATHNAME-PLIST
			  STREAM))
		(LOADING-FILE SI:FASL-GENERIC-PATHNAME-PLIST (BIN-LOAD-TOP-LEVEL STREAM))))
	    (SET-FILE-STREAM-LOADED-ID STREAM *BIN-LOAD-PACKAGE*))
	  (VALUES PATHNAME (SEND STREAM :TRUENAME)))
      (CLEANUP-BIN-LOAD-FUNCTIONS-TO-CALL))))

(DEFUN BINARY-FILE-STREAM-ATTRIBUTE-LIST (STREAM)
  (LOADING-BIN-FILE (STREAM IGNORE #'BIN-LOAD-NEXT-COMMAND IGNORE T)
    (AND (= (BIN-NEXT-BYTE STREAM) BIN-OP-FILE-ATTRIBUTE-LIST)
	 (LET ((*BIN-LOAD-PACKAGE* SI:PKG-USER-PACKAGE)
	       (*BIN-LOAD-SYNTAX* NIL))
	   (VALUES (BIN-NEXT-VALUE STREAM))))))

(DEFINE-LOAD-COMMAND BIN-OP-NUMBER-IMMEDIATE (IGNORE VALUE)
  (SIGN-EXTEND-IMMEDIATE-OPERAND VALUE))

(DEFVAR *SUPPRESS-VERSION-WARNING* NIL)

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-FORMAT-VERSION (STREAM)
  (LET ((VERSION (BIN-NEXT-VALUE STREAM)))
    (COND ((= VERSION *VERSION-NUMBER*))
	  ((AND (= VERSION 3) (MEMQ *VERSION-NUMBER* '(4 5)))
	   (WHEN (NOT *SUPPRESS-VERSION-WARNING*)
	     (SIGNAL 'BINARY-FILE-OBSOLETE-VERSION-3	; this will return for [resume]
		     :PATHNAME (SEND-IF-HANDLES STREAM :PATHNAME))))
	  ((AND (= VERSION 4) (= *VERSION-NUMBER* 5))
	   ;; Version 4 can be loaded as is into a version 5 world
	   )
	  (T (FERROR NIL "Format version is ~D, which is not supported" VERSION)))))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-FILE-ATTRIBUTE-LIST (STREAM)
  (LET* ((*BIN-LOAD-PACKAGE* PKG-USER-PACKAGE)
	 (*BIN-LOAD-SYNTAX* NIL)
	 (PLIST (BIN-NEXT-VALUE STREAM)))
    ;; Make the source file really correspond to where things were compiled from.
    (WHEN FDEFINE-FILE-PATHNAME
      (LET ((SOURCE-PATHNAME (GET (LOCF PLIST) :SOURCE-FILE-GENERIC-PATHNAME)))
	(COND ((AND SOURCE-PATHNAME
		    (INSTANCEP SOURCE-PATHNAME)
		    (NOT (STRINGP FDEFINE-FILE-PATHNAME)))
	       ;; If this property is present, then it was put here by the compiler
	       ;; because the compiler noticed that the generic pathname of the binary
	       ;; file was not the same as the generic pathname of the source file.
	       ;; Therefore, we should change FDEFINE-FILE-PATHNAME to be the generic
	       ;; pathname of the original source file, so that the source-file-name
	       ;; properties will be set up correctly.
	       ;;   If the binary file was opened via a logical host, but the value
	       ;; of this property is a physical host, then back-translate the
	       ;; physical pathname so that the source-file-name properties will also
	       ;; use the logical host.
	       (UNLESS (TYPEP SOURCE-PATHNAME 'FS:LOGICAL-PATHNAME)
		 (SETQ SOURCE-PATHNAME (SEND FDEFINE-FILE-PATHNAME
					     :BACK-TRANSLATED-PATHNAME SOURCE-PATHNAME)))
	       (SETQ FDEFINE-FILE-PATHNAME (SEND SOURCE-PATHNAME :GENERIC-PATHNAME))
	       (SETQ SI:FASL-GENERIC-PATHNAME-PLIST
		     (SEND FDEFINE-FILE-PATHNAME :PROPERTY-LIST-LOCATION))))))
						;--- temporary bug catcher
    #||
    (WHEN (GETL (LOCF PLIST) '(USER:PACKAGE FONTS:PACKAGE))
      (FORMAT ERROR-OUTPUT "~&WARNING: the attribute list of ~A, ~S, appears to have been compiled in an old system.
This file probably won't work and should be recompiled."
	      (SEND STREAM :PATHNAME) PLIST)
      (SETQ PLIST (LOOP FOR X IN PLIST
			COLLECT (IF (SYMBOLP X) (INTERN (STRING X) PKG-KEYWORD-PACKAGE) X))))
    ||#
    (DO PLIST PLIST (CDDR PLIST) (NULL PLIST)
	(COND ((EQ (FIRST PLIST) :QFASL-SOURCE-FILE-UNIQUE-ID)
	       (LET ((PATHNAME (SECOND PLIST)))
		 (UNLESS (OR (GET (LOCF PLIST) :BINARY-SOURCE-FILE-ORIGINAL-TRUENAME)
			     (NOT (INSTANCEP PATHNAME)))
		   (SETF (GET SI:FASL-GENERIC-PATHNAME-PLIST
			      :BINARY-SOURCE-FILE-ORIGINAL-TRUENAME)
			 (STRING PATHNAME)))
		 (UNLESS (STRINGP PATHNAME)
		   (WHEN (AND (INSTANCEP PATHNAME)
			      (TYPEP FDEFINE-FILE-PATHNAME 'FS:LOGICAL-PATHNAME))
		     (WHEN (NEQ (SEND FDEFINE-FILE-PATHNAME :HOST) (SEND PATHNAME :HOST))
		       (SETF PATHNAME (SEND FDEFINE-FILE-PATHNAME
					    :BACK-TRANSLATED-PATHNAME PATHNAME))
		       (WHEN (NEQ (SEND FDEFINE-FILE-PATHNAME :HOST) (SEND PATHNAME :HOST))
			 (COMPILER:WARN
			   NIL "The source file pathname ~A stored in the binary file cannot be converted to logical host ~A.~%~
                              The file was either compiled improperly or compiled with an old version of the compiler."
			   (SECOND PLIST) (SEND FDEFINE-FILE-PATHNAME :HOST)))))
		   (SETF (GET SI:FASL-GENERIC-PATHNAME-PLIST :QFASL-SOURCE-FILE-UNIQUE-ID)
			 PATHNAME))))
	      (T (PUTPROP SI:FASL-GENERIC-PATHNAME-PLIST (CADR PLIST) (CAR PLIST)))))))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-EOF (IGNORE)
  (THROW 'BIN-LOAD-DONE T))

(DEFINE-LOAD-COMMAND BIN-OP-TABLE-FETCH-IMMEDIATE (IGNORE INDEX)
  (AREF *BIN-LOAD-TABLE* INDEX))

(DEFINE-LOAD-COMMAND BIN-OP-TABLE-FETCH-MEDIUM (STREAM)
  (AREF *BIN-LOAD-TABLE* (BIN-NEXT-BYTE STREAM)))

(DEFINE-LOAD-COMMAND BIN-OP-TABLE-FETCH-LARGE (STREAM)
  (LET ((LOW-ORDER (BIN-NEXT-BYTE STREAM))
	(HIGH-ORDER (BIN-NEXT-BYTE STREAM)))
  (AREF *BIN-LOAD-TABLE* (DPB HIGH-ORDER (BYTE 20 20) LOW-ORDER))))

(DEFINE-LOAD-COMMAND BIN-OP-TABLE-FETCH (STREAM)
  (AREF *BIN-LOAD-TABLE* (BIN-NEXT-VALUE STREAM)))

(DEFINE-LOAD-COMMAND BIN-OP-TABLE-STORE (STREAM)
  (ENTER-BIN-LOAD-TABLE (BIN-NEXT-VALUE STREAM)))

(DEFINE-LOAD-COMMAND BIN-OP-TABLE-STORE-INITIALIZER (STREAM)
  (PROG1 (ENTER-BIN-LOAD-TABLE (BIN-NEXT-VALUE STREAM))
	 (BIN-NEXT-COMMAND STREAM)))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-PACKAGE (STREAM)
  (SI:WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (PROG ((DATA (FAST-BIN-NEXT-VALUE)))
	  (TYPECASE DATA
	    ;; String means this is the name was gotten from the global registry,
	    ;; with ZL:PKG-NAME
	    (:STRING (RETURN (PKG-FIND-PACKAGE DATA)))
	    ;; List means this name is Syntax relative, as in
	    ;; ("ZL" . "USER")
	    (:LIST
	      (WHEN (AND (STRINGP (CAR DATA)) (STRINGP (CDR DATA)))
		(RETURN
		  (SYS:FIND-PACKAGE-FOR-SYNTAX (CDR DATA) (CAR DATA))))))
	  (ERROR "Bad format in BIN-OP-PACKAGE: ~S" DATA))))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-SYMBOL (STREAM)
  (CL:INTERN (BIN-NEXT-VALUE STREAM) *BIN-LOAD-PACKAGE*))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-PACKAGE-SYMBOL (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET ((PKG (FAST-BIN-NEXT-VALUE))
	  (PNAME (FAST-BIN-NEXT-VALUE)))
      (TYPECASE PKG
	(:NULL (MAKE-SYMBOL PNAME))
	(:STRING (SETQ PKG (PKG-FIND-PACKAGE PKG NIL *BIN-LOAD-PACKAGE* *BIN-LOAD-SYNTAX*))
	 (FUNCALL (PKG-PREFIX-INTERN-FUNCTION PKG) PNAME PKG))
	(:ARRAY ;Really a package
	  (UNLESS (TYPEP PKG 'PACKAGE)
	    (ERROR "Expected a package but got an array: ~S" PKG))
	  (FUNCALL (PKG-PREFIX-INTERN-FUNCTION PKG) PNAME PKG))
	(:LIST (MULTIPLE-VALUE-BIND (PKG INTERNAL)
		   (GET-PACKAGE-FROM-REFNAME-LIST PKG)
		 (FUNCALL (IF INTERNAL #'CL:INTERN (PKG-PREFIX-INTERN-FUNCTION PKG))
			  PNAME PKG)))))))

(DEFUN GET-PACKAGE-FROM-REFNAME-LIST (PKGS)
  (LET ((WRT-PACKAGE *BIN-LOAD-PACKAGE*)
	(INTERNAL NIL))
    (DOLIST (PKG PKGS)
      (IF (EQ PKG 'INTERNAL)
	  (SETQ INTERNAL T)
	  (SETQ WRT-PACKAGE (PKG-FIND-PACKAGE PKG NIL WRT-PACKAGE *BIN-LOAD-SYNTAX*))))
    (VALUES WRT-PACKAGE INTERNAL)))

;; Create a forwarded home for the symbol cell if one doesn't exist.
(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-VALUE-CELL-LOCATION (STREAM)
  (LET ((CELL (VALUE-CELL-LOCATION (BIN-NEXT-VALUE STREAM))))
    (UNLESS (= (%P-DATA-TYPE CELL) DTP-ONE-Q-FORWARD)
      (FORWARD-SYMBOL-CELL CELL))
    (FOLLOW-CELL-FORWARDING CELL NIL)))

;follow-cell-forwarding snaps out one-q-forwards put in by LOCALIZE-FUNCTION-CELLS
(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-FDEFINITION-LOCATION (STREAM)
  (LET* ((FSPEC (BIN-NEXT-VALUE STREAM))
	 (LOCATION (FOLLOW-CELL-FORWARDING (SYS:FDEFINITION-LOCATION FSPEC) NIL)))
    (WHEN (NOT (FDEFINEDP FSPEC))
      (PUSH (LIST LOCATION FSPEC .INDEX.)	;.INDEX. is the load-index we're going into.
	    *BIN-DEFINITION-FORWARD-REFERENCE-ALIST*))
    LOCATION))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-STRING-IMMEDIATE (STREAM LENGTH)
  (LOAD-STRING STREAM LENGTH))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-STRING (STREAM)
  (LOAD-STRING STREAM))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-LIST-IMMEDIATE (STREAM LENGTH)
  (LOAD-LIST STREAM LENGTH))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-LIST (STREAM)
  (LOAD-LIST STREAM))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-LIST*-IMMEDIATE (STREAM LENGTH)
  (LOAD-LIST* STREAM LENGTH))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-LIST* (STREAM)
  (LOAD-LIST* STREAM))

(DEFINE-LOAD-COMMAND BIN-OP-INITIALIZE-LIST-IMMEDIATE (STREAM ARG)
  (LOAD-NEW-LIST STREAM (LDB-TEST (BYTE 1 11.) ARG) (LDB (BYTE 11. 0) ARG)))

(DEFINE-LOAD-COMMAND BIN-OP-INITIALIZE-LIST (STREAM)
  (LOAD-NEW-LIST STREAM (BIN-NEXT-VALUE STREAM) (BIN-NEXT-VALUE STREAM)))


;;; Number loaders

(DEFINE-LOAD-COMMAND BIN-OP-32-BIT-FIXNUM (STREAM)
  (LET* ((LOW (BIN-NEXT-BYTE STREAM))
	 (HIGH (BIN-NEXT-BYTE STREAM)))
    (%LOGDPB HIGH (BYTE 16. 16.) LOW)))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-INTEGER (STREAM)
  (LOAD-INTEGER STREAM))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-NEGATIVE-INTEGER (STREAM)
  (- (LOAD-INTEGER STREAM)))

(DEFINE-LOAD-COMMAND BIN-OP-IEEE-SINGLE-FLOAT (STREAM)
  (LOAD-IEEE-SINGLE-FLOAT STREAM))

(DEFINE-LOAD-COMMAND BIN-OP-IEEE-DOUBLE-FLOAT (STREAM)
  (LOAD-IEEE-DOUBLE-FLOAT STREAM))		  

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-RATIO (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((NUMERATOR (FAST-BIN-NEXT-VALUE))
	   (DENOMINATOR (FAST-BIN-NEXT-VALUE)))
      (SI:%MAKE-RATIONAL NUMERATOR DENOMINATOR))))

(DEFINE-LOAD-COMMAND BIN-OP-COMPLEX (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((REALPART (FAST-BIN-NEXT-VALUE))
	   (IMAGPART (FAST-BIN-NEXT-VALUE)))
      (%MAKE-COMPLEX REALPART IMAGPART))))

;; --- If counters in the dumper show this to be obsolete, remove it before Release 8
(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-EXTENDED-NUMBER (STREAM)
  (LOAD-EXTENDED-NUMBER STREAM))

;; --- If counters in the dumper show this to be obsolete, remove it before Release 8
(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-FLOAT (STREAM)
  (LOAD-FLOAT STREAM NIL))

;; --- If counters in the dumper show this to be obsolete, remove it before Release 8
(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-NEGATIVE-FLOAT (STREAM)
  (LOAD-FLOAT STREAM T))



;;; ASCII character in standard font
(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-SMALL-CHARACTER (STREAM)
  (LET ((NUMBER (BIN-NEXT-VALUE STREAM)))
    (CODE-CHAR (LDB (BYTE 8 0) NUMBER) (LDB (BYTE 4 8) NUMBER))))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-CHARACTER (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((BITS (FAST-BIN-NEXT-VALUE))
	   (CHAR-SET (FAST-BIN-NEXT-VALUE))
	   (INDEX (FAST-BIN-NEXT-VALUE))
	   (STYLE (FAST-BIN-NEXT-VALUE))
	   (CHAR (CODE-CHAR (SEND CHAR-SET :DECODE-INDEX INDEX) BITS)))
      (SETF (CHAR-STYLE-INDEX CHAR) (STYLE-INDEX STYLE T))
      CHAR)))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-CHARACTER-STYLE (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((FAMILY (FAST-BIN-NEXT-VALUE))
	   (FACE (FAST-BIN-NEXT-VALUE))
	   (SIZE (FAST-BIN-NEXT-VALUE))
	   (EXTENDED-ATTRIBUTES (FAST-BIN-NEXT-VALUE))
	   (STYLE (INTERN-CHARACTER-STYLE FAMILY FACE SIZE)))
      ;; Extended Attributes belong as an argument to INTERN-CHARACTER-STYLE, above.
      ;; For now, we just preserve them, until INTERN-STYLE is fixed.
      (SETF (CS-EXTENDED-ATTRIBUTES STYLE) EXTENDED-ATTRIBUTES)
      STYLE)))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-CHARACTER-SET (STREAM)
  (LET ((NAME (BIN-NEXT-VALUE STREAM)))
    (LOOKUP-CHARACTER-SET NAME)))

(DEFINE-LOAD-COMMAND BIN-OP-FORM (STREAM)
  (EVAL (BIN-NEXT-VALUE STREAM)))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-ARRAY (STREAM LENGTH)
  (LOAD-ARRAY STREAM LENGTH))


(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-L-COMPILED-FUNCTION (STREAM)
  STREAM
  #+3600(LOAD-L-COMPILED-FUNCTION STREAM)
  #+IMACH (FERROR "It is not possible to load functions compiled for 3600s on Ivory"))

(DEFINE-LOAD-COMMAND-FOR-VALUE BIN-OP-I-COMPILED-FUNCTION (STREAM)
  STREAM
  #+IMACH (LOAD-I-COMPILED-FUNCTION STREAM)
  #+3600 (FERROR "It is not possible to load functions compiled for Ivory on 3600s"))

(DEFINE-LOAD-COMMAND BIN-OP-MAKE-INSTANCE-IMMEDIATE (STREAM LENGTH)
  (INITIALIZE-INSTANCE STREAM LENGTH))

#+IMach
(DEFINE-LOAD-COMMAND BIN-OP-EMBEDDED-CONSTANT-IMMEDIATE (IGNORE OPERAND)
  (%SET-TAG
    (%POINTER-PLUS (CDAR *LOADING-COMPILED-FUNCTIONS*)
		   (- (LDB (BYTE 9 3) OPERAND)
		      (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
    (AREF #.(CL:MAKE-ARRAY 8 :ELEMENT-TYPE '(CL:UNSIGNED-BYTE 8)
			     :INITIAL-CONTENTS '(#.DTP-LIST		 ;0
						 #.DTP-LEXICAL-CLOSURE	 ;1
						 #.DTP-DYNAMIC-CLOSURE	 ;2
						 #.DTP-DOUBLE-FLOAT	 ;3
						 #.DTP-BIG-RATIO	 ;4
						 #.DTP-COMPLEX		 ;5
						 #.DTP-COMPILED-FUNCTION ;6
						 #.DTP-LOCATIVE))	 ;7 ... and no spares
	  (LDB (BYTE 3 0) OPERAND))))

#+IMach
(DEFINE-LOAD-COMMAND BIN-OP-NATIVE-INSTRUCTION (STREAM)
  (LET* ((LOW (BIN-NEXT-BYTE STREAM))
	 (HIGH (BIN-NEXT-BYTE STREAM)))
    (%SET-TAG (%LOGDPB HIGH (BYTE 16. 16.) LOW) DTP-SPARE-IMMEDIATE-1)))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-FDEFINE (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET ((FSPEC (FAST-BIN-NEXT-VALUE))
	  (DEFINITION (FAST-BIN-NEXT-VALUE)))
      (LET ((*STORE-BACK-EXPANDED-EXTRA-INFO* NIL))	;Checking storage categories.
	(FDEFINE FSPEC DEFINITION T))
      ;; We no longer have to remember this function spec in our forward references.
      ;; Delete it so the alist doesn't grow too large.
      ;; Also follow cell forwarding in the copy of the function cell in the table.
      (DO* ((TAIL (LOCF *BIN-DEFINITION-FORWARD-REFERENCE-ALIST*) SUBLIST)
	    (SUBLIST (CDR TAIL) (CDR SUBLIST)))
	   ((NULL SUBLIST) NIL)
	(WHEN (EQ (SECOND (CAR SUBLIST)) FSPEC)
	  (LET ((INDEX (THIRD (CAR SUBLIST))))
	    (SETF (AREF *BIN-LOAD-TABLE* INDEX)
		  (SYS:FOLLOW-CELL-FORWARDING (AREF *BIN-LOAD-TABLE* INDEX) NIL))
	    (SETF (CDR TAIL) (CDR SUBLIST))
	    (RETURN NIL)))))))

(DEFINE-LOAD-COMMAND BIN-OP-SETQ (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (SET (FAST-BIN-NEXT-VALUE) (FAST-BIN-NEXT-VALUE))))

(DEFINE-LOAD-COMMAND BIN-OP-PUTPROP (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (PUTPROP (FAST-BIN-NEXT-VALUE) (FAST-BIN-NEXT-VALUE) (FAST-BIN-NEXT-VALUE))))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-DEFCONST (STREAM LENGTH)
  (BIN-DEFCONST-1 STREAM LENGTH #'SI:DEFCONST-1-INTERNAL NIL))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-DEFVAR (STREAM LENGTH)
  (BIN-DEFCONST-1 STREAM LENGTH #'SI:DEFVAR-1-INTERNAL T))

(DEFUN BIN-DEFCONST-1 (STREAM LENGTH FUNCTION PUSH-ENV)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET ((COUNT LENGTH))
      (WHEN PUSH-ENV (INCF LENGTH))
      (TAGBODY
	(%START-FUNCTION-CALL FUNCTION NIL LENGTH NIL)
	(WHEN PUSH-ENV (%PUSH NIL))		;ENV argument
	(UNLESS (PLUSP COUNT) (GO END-LOOP))	;Shouldn't happen
     LOOP
	(%PUSH (FAST-BIN-NEXT-VALUE))
	(IF (PLUSP (DECF COUNT)) (GO LOOP))
     END-LOOP
	(%FINISH-FUNCTION-CALL FUNCTION NIL LENGTH NIL)
     NIL))))

;(DEFUN BIN-DEFCONST-1 (STREAM LENGTH FUNCTION)
; (LOOP WITH REST = (MAKE-LIST LENGTH)
;	FOR I FROM 0 BELOW LENGTH
;	FOR L = REST THEN (CDR L)
;	DO (RPLACA L (BIN-NEXT-VALUE STREAM))
;	FINALLY
;	  (LEXPR-FUNCALL FUNCTION REST)))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-INITIALIZE-ARRAY (STREAM)
  (INITIALIZE-ARRAY STREAM))

(DEFINE-LOAD-COMMAND-FOR-EFFECT BIN-OP-INITIALIZE-NUMERIC-ARRAY (STREAM)
  (INITIALIZE-NUMERIC-ARRAY STREAM))

(DEFINE-LOAD-COMMAND BIN-OP-INITIALIZE-AND-RETURN-ARRAY (STREAM)
  (INITIALIZE-ARRAY STREAM))

(DEFINE-LOAD-COMMAND BIN-OP-INITIALIZE-AND-RETURN-NUMERIC-ARRAY (STREAM)
  (INITIALIZE-NUMERIC-ARRAY STREAM))

(DEFINE-LOAD-COMMAND BIN-OP-CONVERT-ARRAY-TO-FLOATING (STREAM)
  (CONVERT-ARRAY-TO-FLOATING STREAM))


;;;; Utility functions

(DEFUN LOAD-NEW-LIST (STREAM DOTIFY LENGTH)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET ((LIST (MAKE-LIST (IF DOTIFY (1+ LENGTH) LENGTH))))
      (LET ((L LIST))
	(LOOP REPEAT LENGTH DO
	  (ENTER-BIN-LOAD-TABLE L)
	  (SETF L (CDR L))))
      (LET ((L LIST)
	    (OL LIST))
	(LOOP REPEAT LENGTH DO
	  (SETF (CAR L) (FAST-BIN-NEXT-VALUE))
	  (SETF OL L)
	  (SETF L (CDR L)))
	(WHEN DOTIFY
	  (%CHANGE-LIST-TO-CONS OL)
	  (SETF (CDR OL) (FAST-BIN-NEXT-VALUE))))
      LIST)))

(DEFUN LOAD-LIST (STREAM &OPTIONAL LENGTH)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (WHEN (NULL LENGTH)
      (SETQ LENGTH (FAST-BIN-NEXT-VALUE)))
    (LET ((LIST (MAKE-LIST LENGTH)))
      (LOOP REPEAT LENGTH
	    FOR L = LIST THEN (CDR L)
	    DO (RPLACA L (FAST-BIN-NEXT-VALUE)))
      LIST)))

(DEFUN LOAD-LIST* (STREAM &OPTIONAL LENGTH)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (WHEN (NULL LENGTH)
      (SETQ LENGTH (FAST-BIN-NEXT-VALUE)))
    (LET ((LIST (MAKE-LIST LENGTH)))
      (LOOP REPEAT LENGTH
	    FOR L = LIST THEN (CDR L)
	    DO (RPLACA L (FAST-BIN-NEXT-VALUE)))
      ;; (%P-STORE-CDR-CODE (NTHCDR (- LENGTH 2) LIST) CDR-NORMAL)
      ;; Avoid wasting time calling NTHCDR.
      (%P-DPB-OFFSET CDR-NORMAL %%Q-CDR-CODE LIST (- LENGTH 2))
      LIST)))

(DEFUN LOAD-STRING (STREAM &OPTIONAL (LENGTH (BIN-NEXT-VALUE STREAM)))
  (LET ((STRING (MAKE-ARRAY LENGTH ':TYPE 'ART-STRING))
	(INDEX 0) WORD)
    (DECLARE (ARRAY-REGISTER STRING))
    (IF *BIN-LOAD-STREAM-BUFFERED-P*
	(LOOP WHILE (< INDEX LENGTH)		D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");keep going around until we fill the string
0	      DO
	  (MULTIPLE-VALUE-BIND (BUFFER BUFFER-INDEX BUFFER-END)
	      (SEND STREAM :READ-INPUT-BUFFER)
	    (LET ((BUFFER BUFFER))
	      (DECLARE (ARRAY-REGISTER BUFFER))
	      1;; loop to use up each buffer
0	      (LOOP WHILE (AND (< BUFFER-INDEX BUFFER-END)
			       1;; but stop when we have filled the string.
0			       (< INDEX LENGTH))
		    DO
		(SETQ WORD (AREF BUFFER BUFFER-INDEX))
		(INCF BUFFER-INDEX)
		(SETF (AREF STRING INDEX) (CODE-CHAR (LDB (BYTE 8 0) WORD)))
		(INCF INDEX)
		1;; only pick up the second byte if we have a place to put it.
0		(WHEN (< INDEX LENGTH)
		  (SETF (AREF STRING INDEX)
			(CODE-CHAR (LDB (BYTE 8 8) WORD)))
		  (INCF INDEX)))
	      1;; ok, account for this buffer, in whole or in part.
0	      (SEND STREAM :ADVANCE-INPUT-BUFFER BUFFER-INDEX))))
	(LOOP WHILE (< INDEX LENGTH)
	      DO (SETF (AREF STRING INDEX)
		       (CODE-CHAR (LDB (BYTE 8 0) (SETQ WORD (BIN-NEXT-BYTE STREAM)))))
		 (INCF INDEX)
	      WHILE (< INDEX LENGTH)
	      DO (SETF (AREF STRING INDEX) (CODE-CHAR (LDB (BYTE 8 8) WORD)))
		 (INCF INDEX)))
    STRING))

(DEFUN LOAD-INTEGER (STREAM &OPTIONAL (LENGTH (BIN-NEXT-VALUE STREAM)))
  (COND ((= LENGTH 1) (BIN-NEXT-BYTE STREAM))
	((= LENGTH 2) (MAKE-32-BIT-NUMBER (BIN-NEXT-BYTE STREAM) (BIN-NEXT-BYTE STREAM)))
	(T (LOOP WITH WORD = (CONS-BIGNUM 0 (CEILING LENGTH 2))
		 WITH WORD-SET = (GET-BIGNUM-ADVANCING-POINTER WORD 0)
		 REPEAT (FLOOR LENGTH 2) DO
	     (BIGNUM-ADVANCE-SET WORD-SET (ROT (%LOGDPB (BIN-NEXT-BYTE STREAM) (BYTE 16. 16.)
							(BIN-NEXT-BYTE STREAM))
					       16.))
	     FINALLY (WHEN (ODDP LENGTH) (BIGNUM-ADVANCE-SET WORD-SET (BIN-NEXT-BYTE STREAM)))
		     (RETURN WORD)))))

(DEFUN LOAD-IEEE-SINGLE-FLOAT (STREAM)
  ;; dumped -> MOST <- significant first
  (LET* ((HIGH (BIN-NEXT-BYTE STREAM))
	 (LOW (BIN-NEXT-BYTE STREAM)))
    (%FLONUM (%LOGDPB HIGH (BYTE 16. 16.) LOW))))

(DEFUN LOAD-IEEE-DOUBLE-FLOAT (STREAM)
  ;; dumped -> MOST <- significant first
  (LET* ((FIRST-HIGH  (BIN-NEXT-BYTE STREAM))
	 (FIRST-LOW   (BIN-NEXT-BYTE STREAM))
	 (SECOND-HIGH (BIN-NEXT-BYTE STREAM))
	 (SECOND-LOW  (BIN-NEXT-BYTE STREAM)))
    (%MAKE-DOUBLE (%LOGDPB  FIRST-HIGH (BYTE 16. 16.)  FIRST-LOW)
		  (%LOGDPB SECOND-HIGH (BYTE 16. 16.) SECOND-LOW))))

;; --- If counters in dumper show this to be obsolete, remove it before Release 8
(DEFUN LOAD-FLOAT (STREAM NEGATIVE)
  (LET ((MANTISSA (BIN-NEXT-VALUE STREAM))
	(EXPONENT (BIN-NEXT-VALUE STREAM)))
    (MAKE-FLOAT-INTERNAL NEGATIVE MANTISSA EXPONENT)))

;; --- If counters in dumper show this to be obsolete, remove it before Release 8
#+3600
(DEFUN LOAD-EXTENDED-NUMBER (STREAM)
  (LET* ((LENGTH (BIN-NEXT-VALUE STREAM))
	 (NUMBER (%MAKE-STRUCTURE DTP-EXTENDED-NUMBER DTP-HEADER-I %HEADER-TYPE-NUMBER
				  (BIN-NEXT-VALUE STREAM) DEFAULT-CONS-AREA LENGTH)))
    (LOOP FOR I FROM 1 BELOW LENGTH
	  DO (%P-STORE-CONTENTS-OFFSET (BIN-NEXT-VALUE STREAM) NUMBER I))
    NUMBER))

#+IMACH
(DEFUN LOAD-EXTENDED-NUMBER (STREAM)
  (LET ((LENGTH (BIN-NEXT-VALUE STREAM))
	(3600-HEADER-TYPE (BIN-NEXT-VALUE STREAM)))
    (UNLESS (= LENGTH 2)
      (FERROR "Reading extended number which is not a double, rational, or complex"))
    (LET ((FIRST (BIN-NEXT-VALUE STREAM))
	  (SECOND (BIN-NEXT-VALUE STREAM)))
      (SELECTOR 3600-HEADER-TYPE =
	(0 (FERROR "BIGNUM dumped as extended number"))
	(1 (%MAKE-RATIONAL FIRST SECOND))
	(2 (%MAKE-COMPLEX FIRST SECOND))
	(3 (%MAKE-DOUBLE FIRST SECOND))))))

(DEFUN MAKE-FLOAT-INTERNAL (NEGATIVE MANTISSA EXPONENT)
  (COND ((OR (EQ EXPONENT :INFINITY) (EQ EXPONENT :NAN))	;SYMBOLP would work
	 (%FLONUM (%LOGDPB (IF NEGATIVE 1 0) %%SINGLE-SIGN
			   (DPB %SINGLE-EXPONENT-MAX %%SINGLE-EXPONENT MANTISSA))))
	((ZEROP MANTISSA)
	 ;; do zero separately, so that -0.0 works
	 (%FLONUM (%LOGDPB (IF NEGATIVE 1 0) %%SINGLE-SIGN 0)))
	(T
	 (WITHOUT-FLOATING-UNDERFLOW-TRAPS
	   ;; do the negate first, just in case any of the floating-point operations round
	   (ASH (FLOAT (IF NEGATIVE (- MANTISSA) MANTISSA))
		EXPONENT)))))

;; This now hacks areas.  EXTRA-INFO goes into DEBUG-INFO-AREA.  The debugging info
;; is then searched to find the disposition of the remaining objects.  Care must be
;; taken so that objects shared by the dumper will not be shared in such a way that
;; the sharing will not work at runtime.  This unfortunately means copying the objects
;; loaded, and letting GC reclaim whatever it can.
#+3600
(DEFUN LOAD-L-COMPILED-FUNCTION (STREAM &OPTIONAL FOR-UNBIN)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((VALIDATE-P T)
	   (N-OBJECTS (FAST-BIN-NEXT-VALUE))
	   (N-INSTRUCTIONS (FAST-BIN-NEXT-VALUE))
	   (HEADER-WORD-2 (FAST-BIN-NEXT-VALUE))
	   (EXTRA-INFO (FAST-BIN-NEXT-VALUE)))
      (LET ((FUNCTION-STORAGE-CATEGORY
	      (AND (NOT FOR-UNBIN)
		   (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO (CDR EXTRA-INFO)))))
	(WHEN (NULL FUNCTION-STORAGE-CATEGORY)
	  (SETQ FUNCTION-STORAGE-CATEGORY :UNSAFEGUARDED
		VALIDATE-P NIL))
	(LET* ((AREA
		 (COND (FOR-UNBIN				      WORKING-STORAGE-AREA)
		       ((EQ FUNCTION-STORAGE-CATEGORY :UNSAFEGUARDED)
			(LET ((TEMP (CL:ASSOC 'COMPILER:AREA (CDR EXTRA-INFO))))
			  (IF TEMP (SYMEVAL (SECOND TEMP)) COMPILED-FUNCTION-AREA)))
		       ((EQ FUNCTION-STORAGE-CATEGORY :WIRED)	      WIRED-CONTROL-TABLES)
		       ((EQ FUNCTION-STORAGE-CATEGORY :SAFEGUARDED)   SAFEGUARDED-OBJECTS-AREA)
		       (T (ERROR "Unknown storage category ~S" FUNCTION-STORAGE-CATEGORY))))
	       (CCA (MAKE-COMPILED-CODE N-OBJECTS N-INSTRUCTIONS AREA))
	       (OBJECT (CCA-COMPILED-CODE-OBJECT CCA)))
	  (WITH-STACK-LIST* (*LOADING-COMPILED-FUNCTIONS* OBJECT *LOADING-COMPILED-FUNCTIONS*)
	    (SETF (COMPILED-FUNCTION-HEADER-WORD-2 CCA) HEADER-WORD-2)
	    (SETF (COMPILED-FUNCTION-EXTRA-INFO CCA) EXTRA-INFO)
	    (SETF (COMPILED-FUNCTION-FUNCTION-CELL CCA) NIL)	;Will get set later
	    (LOOP FOR I FROM 0 BELOW N-OBJECTS
		  DO (SETF (CCA-OBJECT CCA I) (FAST-BIN-NEXT-VALUE)))
	    ;; Load the instructions in the fastest loop possible.
	    (FUNCALL (IF *BIN-LOAD-STREAM-BUFFERED-P*
			 #'LOAD-L-COMPILED-FUNCTION-INTERNAL-BUFFERED
			 #'LOAD-L-COMPILED-FUNCTION-INTERNAL-UNBUFFERED)
		     STREAM OBJECT N-INSTRUCTIONS)
	    (UNLESS FOR-UNBIN
	      (LET ((DEBUG-ALIST (CDR EXTRA-INFO)))
		(AND (OR (ASSQ ':INSTANCE-VARIABLE-INSTRUCTIONS DEBUG-ALIST)
			 (ASSQ ':MAPPING-TABLE-INSTRUCTIONS DEBUG-ALIST))
		     (SI:FIXUP-METHOD CCA))
		;; Verify the proper compilation environment.
		(LET ((ENTRY (CL:ASSOC :CONSTANTS-OPEN-CODED DEBUG-ALIST)))
		  (WHEN ENTRY
		    (VERIFY-OPEN-CODED-CONSTANTS (CAR EXTRA-INFO) (CADR ENTRY))))
		;; Remove lambda expressions from :MACROS-EXPANDED.  The pre-7.5
		;; compiler generated these, and they just bloat the who-calls database.
		(LET ((ELEM (CL:ASSOC :MACROS-EXPANDED DEBUG-ALIST)))
		  (WHEN (AND ELEM
			     (LOOP FOR MACRO IN (CADR ELEM)
				   THEREIS (AND (CL:CONSP MACRO)	;Make common case fast
						(NOT (VALIDATE-FUNCTION-SPEC MACRO)))))
		    (SETF (CADR ELEM) (REM-IF-NOT #'VALIDATE-FUNCTION-SPEC (CADR ELEM)))
		    (WHEN (NULL (CADR ELEM))
		      (DELQ ELEM EXTRA-INFO)))))
	      (BIN-RECORD-FORWARD-REFERENCES OBJECT))
	    ;; Copy the constants into the proper storage category
	    (UNLESS (EQL DEFAULT-CONS-AREA AREA)
	      (COPY-COMPILED-FUNCTION-CONSTANTS OBJECT AREA))
	    ;; Validate the storage categories if there is a declaration.
	    (WHEN VALIDATE-P
	      (VALIDATE-FUNCTION-STORAGE-CATEGORY-DECLARATIONS OBJECT))
	    ;; Now copy into the right area and maybe compact.  Did not
	    ;; do this before because above routines rely on standard format
	    ;; debugging info and would have converted it right back.
	    (WHEN (AND (NOT FOR-UNBIN)
		       (VARIABLE-BOUNDP #'STANDARDIZE-EXTRA-INFO))
	      (SETF (COMPILED-FUNCTION-EXTRA-INFO CCA)
		    (STANDARDIZE-EXTRA-INFO OBJECT EXTRA-INFO)))
	    OBJECT))))))

#+3600
(DEFUN LOAD-L-COMPILED-FUNCTION-INTERNAL-BUFFERED (STREAM OBJECT N-INSTRUCTIONS)
  (MULTIPLE-VALUE-BIND (BUFFER INDEX END)
      (SEND STREAM :READ-INPUT-BUFFER)
    (LET ((BUFFER BUFFER))
      (DECLARE (SYS:ARRAY-REGISTER BUFFER))
      (LOOP WITH INST-LOC = (%MAKE-POINTER DTP-LOCATIVE OBJECT)
	    WITH INST-IDX = 0
	    WITH HALF = NIL
	    WITH WORD1 = 0 WITH WORD2 = 0
	    FOR N-BITS FROM 0 BY 16.
	    ;; WORD1 has (MIN N-BITS 17.) bits in it, and WORD2 has (- N-BITS 17.)
	    WHEN ( N-BITS 17.)
	      DO (COND ((SETQ HALF (NOT HALF))	;Low half
			(%P-DPB (LDB (BYTE 1 20) WORD1) %%Q-LOW-INSTR-HIGH-BIT INST-LOC)
			(%P-DPB WORD1 %%Q-LOW-INSTR INST-LOC))
		       (T			;High half
			(%P-DPB (LDB (BYTE 1 20) WORD1) %%Q-HIGH-INSTR-HIGH-BIT INST-LOC)
			(%P-DPB WORD1 %%Q-HIGH-INSTR INST-LOC)
			(SETQ INST-LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE INST-LOC 1))))
		 (AND ( (INCF INST-IDX) N-INSTRUCTIONS)
		      (RETURN (SEND STREAM :ADVANCE-INPUT-BUFFER INDEX)))
		 (SETQ WORD1 WORD2)
		 (DECF N-BITS 17.)
	    DO					;(BIN-NEXT-BYTE STREAM)
	(LOOP WHEN (< INDEX END)
		RETURN (PROGN (SETQ WORD2 (AREF BUFFER INDEX)) (INCF INDEX))
	      DO (SEND STREAM :ADVANCE-INPUT-BUFFER)
		 (MULTIPLE-VALUE (BUFFER INDEX END) (SEND STREAM :READ-INPUT-BUFFER)))
	       ;; WORD1 has N-BITS bits in it, now give it some bits from WORD2
	       ;; without getting involved with any bignums.
	(SETQ WORD1 (LOGIOR WORD1 (LSH WORD2 N-BITS))
	      WORD2 (LSH WORD2 (- N-BITS 17.)))))))

#+3600
(DEFUN LOAD-L-COMPILED-FUNCTION-INTERNAL-UNBUFFERED (STREAM OBJECT N-INSTRUCTIONS)
  (LOOP WITH INST-LOC = (%MAKE-POINTER DTP-LOCATIVE OBJECT)
	WITH INST-IDX = 0
	WITH HALF = NIL
	WITH WORD1 = 0 WITH WORD2 = 0
	FOR N-BITS FROM 0 BY 16.
	;; WORD1 has (MIN N-BITS 17.) bits in it, and WORD2 has (- N-BITS 17.)
	WHEN ( N-BITS 17.)
	  DO (COND ((SETQ HALF (NOT HALF))	;Low half
		    (%P-DPB (LDB (BYTE 1 20) WORD1) %%Q-LOW-INSTR-HIGH-BIT INST-LOC)
		    (%P-DPB WORD1 %%Q-LOW-INSTR INST-LOC))
		   (T				;High half
		    (%P-DPB (LDB (BYTE 1 20) WORD1) %%Q-HIGH-INSTR-HIGH-BIT INST-LOC)
		    (%P-DPB WORD1 %%Q-HIGH-INSTR INST-LOC)
		    (SETQ INST-LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE INST-LOC 1))))
	     (AND ( (INCF INST-IDX) N-INSTRUCTIONS) (RETURN NIL))
	     (SETQ WORD1 WORD2)
	     (DECF N-BITS 17.)
	DO (SETQ WORD2 (BIN-NEXT-BYTE STREAM))
	   ;; WORD1 has N-BITS bits in it, now give it some bits from WORD2
	   ;; without getting involved with any bignums.
	   (SETQ WORD1 (LOGIOR WORD1 (LSH WORD2 N-BITS))
		 WORD2 (LSH WORD2 (- N-BITS 17.)))))

#+IMACH
;;;--- This needs to be tweaked to use :READ-INPUT-BUFFER, %BLOCK-WRITE, etc.
(DEFUN LOAD-I-COMPILED-FUNCTION (STREAM &OPTIONAL FOR-UNBIN)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((VALIDATE-P T)
	   (TOTAL-SIZE (FAST-BIN-NEXT-VALUE))
	   (SUFFIX-SIZE (FAST-BIN-NEXT-VALUE))
	   (NUMBER-OF-INSTRUCTIONS (- TOTAL-SIZE SUFFIX-SIZE
				      (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
	   (NAME-AND-STORAGE (FAST-BIN-NEXT-VALUE))
	   (FUNCTION-STORAGE-CATEGORY
	     (AND (NOT FOR-UNBIN)
		  (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO (CDR NAME-AND-STORAGE)))))
      (WHEN (NULL FUNCTION-STORAGE-CATEGORY)
	(SETQ FUNCTION-STORAGE-CATEGORY :UNSAFEGUARDED
	      VALIDATE-P NIL))
      (LET ((AREA
	      (COND (FOR-UNBIN					   WORKING-STORAGE-AREA)
		    ((EQ FUNCTION-STORAGE-CATEGORY :UNSAFEGUARDED)
		     (LET ((TEMP (CL:ASSOC 'COMPILER:AREA (CDR NAME-AND-STORAGE))))
		       (IF TEMP (SYMEVAL (SECOND TEMP)) COMPILED-FUNCTION-AREA)))
		    ((EQ FUNCTION-STORAGE-CATEGORY :WIRED)	   WIRED-CONTROL-TABLES)
		    ((EQ FUNCTION-STORAGE-CATEGORY :SAFEGUARDED)   SAFEGUARDED-OBJECTS-AREA)
		    (T (ERROR "Unknown storage category ~S" FUNCTION-STORAGE-CATEGORY)))))
	(MULTIPLE-VALUE-BIND (CCA FUNCTION)
	    (MAKE-COMPILED-CODE TOTAL-SIZE SUFFIX-SIZE AREA)
	  (LET ((BASE-ADDRESS (%MAKE-POINTER DTP-LOCATIVE FUNCTION)))
	    (STACK-LET ((SI:*LOADING-COMPILED-FUNCTIONS*
			  (LIST* (CONS (CAR NAME-AND-STORAGE) FUNCTION)
				 SI:*LOADING-COMPILED-FUNCTIONS*)))
	      (LOOP FOR OFFSET BELOW (- TOTAL-SIZE (DEFSTORAGE-SIZE COMPILED-FUNCTION)) DO
		(LET* ((LOCATION-BEING-SET (%POINTER-PLUS BASE-ADDRESS OFFSET))
		       (OPCODE-TAG (SEND STREAM :TYI))
		       (DATA-1 (IF (LDB-TEST SI:%%I-COMPILED-FUNCTION-IMMEDIATE OPCODE-TAG)
				   (DPB (SEND STREAM :TYI)
					(BYTE 20 0)
					(ROT (SEND STREAM :TYI) 20))
				   (FAST-BIN-NEXT-VALUE)))
		       (DATA-2 (IF (LDB-TEST SI:%%I-COMPILED-FUNCTION-RELATIVE OPCODE-TAG)
				   (PROGN (UNLESS (AND (NOT (MINUSP DATA-1))
						       (< DATA-1 (- TOTAL-SIZE 2)))
					    (ERROR "Invalid relative opcode in BIN file"))
					  (%POINTER-PLUS BASE-ADDRESS DATA-1))
				   DATA-1)))
		  (WHEN (AND (< OFFSET NUMBER-OF-INSTRUCTIONS)
			     (= OPCODE-TAG #O1410)
			     (= DATA-2 0))
		    (FSIGNAL "Bogus full word encountered loading function ~s"
			     (CAR NAME-AND-STORAGE)))
		  (%MEMORY-WRITE LOCATION-BEING-SET
		    (%SET-TAG DATA-2
			      (IF (AND (LDB-TEST SI:%%I-COMPILED-FUNCTION-TYPE-FROM-TAG
						 OPCODE-TAG)
				       ;; if it's something that should have been evaluated,
				       ;; don't create an illegal pointer
				       (NOT (AND FOR-UNBIN
						 (CL:CONSP DATA-2)
						 (EQ (CAR DATA-2) '**EVAL**))))
				  (LDB (BYTE 10 0) OPCODE-TAG)
				  (DPB (LDB %%Q-CDR-CODE-WITHIN-TAG OPCODE-TAG)
				       %%Q-CDR-CODE-WITHIN-TAG
				       (%TAG DATA-2)))))))
	      (LET ((EXTRA-INFO (LOCATION-CONTENTS
				  (%POINTER-PLUS CCA (- TOTAL-SIZE SUFFIX-SIZE)))))
		(UNLESS FOR-UNBIN
		  (LET ((DEBUG-ALIST (CDR EXTRA-INFO)))
		    (AND (OR (CL:ASSOC ':INSTANCE-VARIABLE-INSTRUCTIONS DEBUG-ALIST)
			     (CL:ASSOC ':MAPPING-TABLE-INSTRUCTIONS DEBUG-ALIST))
			 (SI:FIXUP-METHOD CCA))
		    ;; Verify the proper compilation environment.
		    (LET ((ENTRY (CL:ASSOC :CONSTANTS-OPEN-CODED DEBUG-ALIST)))
		      (WHEN ENTRY
			(VERIFY-OPEN-CODED-CONSTANTS (CAR EXTRA-INFO) (CADR ENTRY))))
		    ;;--- Fixup old debug-info from systems < 416.73 (MacIvory Beta Test).
		    ;;--- Remove this form if we know there are no more affected files anymore.
		    #+IGNORE
		    (LET ((ELEM (CL:ASSOC :INTERNAL-FUNCTIONS DEBUG-ALIST)))
		      (COND ((NULL (CDR ELEM))
			     ;; Call for effect is okay since elem is somewhere in the cdr.
			     (DELQ ELEM EXTRA-INFO))
			    ((AND ELEM (CL:CONSP (CADR ELEM)))
			     (SETF (CDR ELEM) (MAPCAR #'CDR (SORTCAR (CDR ELEM) #'<))))))
		    ;; Remove lambda expressions from :MACROS-EXPANDED.  The pre-7.5
		    ;; compiler generated these, and they just bloat the who-calls database.
		    (LET ((ELEM (CL:ASSOC :MACROS-EXPANDED DEBUG-ALIST)))
		      (WHEN (AND ELEM
				 (LOOP FOR MACRO IN (CADR ELEM)
				       THEREIS (AND (CL:CONSP MACRO)	;Make common case fast
						    (NOT (VALIDATE-FUNCTION-SPEC MACRO)))))
			(SETF (CADR ELEM) (REM-IF-NOT #'VALIDATE-FUNCTION-SPEC (CADR ELEM)))
			(WHEN (NULL (CADR ELEM))
			  (DELQ ELEM EXTRA-INFO)))))
		  #+Ivory-Rev-1 (FIXUP-FUNCTION-ENTRY-INSTRUCTIONS FUNCTION)
		  (BIN-RECORD-FORWARD-REFERENCES FUNCTION))
		;; Copy the constants into the proper storage category
		(MULTIPLE-VALUE (NIL NIL FUNCTION)
		  (COPY-COMPILED-FUNCTION-CONSTANTS FUNCTION AREA T))
		(SETQ CCA (COMPILED-FUNCTION-CCA FUNCTION))
		;; Validate the storage categories if there is a declaration.
		(WHEN VALIDATE-P
		  (VALIDATE-FUNCTION-STORAGE-CATEGORY-DECLARATIONS FUNCTION))
		;; Copy the real extra-info into DEBUG-INFO-AREA.
		(WHEN (AND (NOT FOR-UNBIN)
			   (VARIABLE-BOUNDP #'STANDARDIZE-EXTRA-INFO))
		  (%P-STORE-CONTENTS (%POINTER-PLUS CCA (- TOTAL-SIZE SUFFIX-SIZE))
				     (STANDARDIZE-EXTRA-INFO FUNCTION EXTRA-INFO)))
		FUNCTION))))))))

#+3600
(DEFUN LOAD-PC (FSPEC OFFSET)
  (%MAKE-PC (OR (CL:FIND FSPEC *LOADING-COMPILED-FUNCTIONS*
			 :TEST #'EQUAL :KEY #'COMPILED-FUNCTION-NAME)
		(ERROR "Not loading function ~S." FSPEC))
	    OFFSET))

#+IMACH
(DEFUN LOAD-PC (FSPEC OFFSET)
  (%MAKE-PC (CDR (OR (CL:ASSOC FSPEC *LOADING-COMPILED-FUNCTIONS* :TEST #'EQUAL)
		     (ERROR "Not loading function ~S." FSPEC)))
	    OFFSET))

(DEFUN BIN-RECORD-FORWARD-REFERENCES (FUNCTION)
  (LET* ((ANCESTOR-FSPEC (LOOP WITH FSPEC = (FUNCTION-NAME FUNCTION)
			       DO (IF (AND (CL:CONSP FSPEC) (EQ (FIRST FSPEC) :INTERNAL))
				      (SETQ FSPEC (SECOND FSPEC))
				      (RETURN FSPEC))))
	 (ANCESTOR-LOCATION
	   (AND (VALIDATE-FUNCTION-SPEC ANCESTOR-FSPEC)
		(DEFINITION-HAS-LOCATION-P ANCESTOR-FSPEC)
		(FOLLOW-CELL-FORWARDING (FDEFINITION-LOCATION ANCESTOR-FSPEC) NIL)))
	 (LOCATIONS *BIN-DEFINITION-FORWARD-REFERENCE-ALIST*))
    (WHEN (OR LOCATIONS ANCESTOR-LOCATION)
      #+3600  (DO-COMPILED-FUNCTION-CONSTANT-TABLE (CONSTANT LOCATION) FUNCTION
		(WHEN (LOCATIVEP CONSTANT)
		  (IF (EQ CONSTANT ANCESTOR-LOCATION)
		      (REFERENCE-UNDEFINED-FUNCTION-CELL LOCATION ANCESTOR-FSPEC)
		      (LET ((ENTRY (ASSQ CONSTANT LOCATIONS)))
			(WHEN (AND ENTRY
				   ;; Could be defined via some agent
				   ;; other than BIN-OP-FDEFINE.
				   (NOT (LOCATION-BOUNDP CONSTANT)))
			  (REFERENCE-UNDEFINED-FUNCTION-CELL LOCATION (SECOND ENTRY)))))))
      #+IMach (DO-COMPILED-FUNCTION-INSTRUCTIONS
		(CONSTANT LOCATION :BAR 2 :PREFETCH T :SKIP-ENTRY-INSTRUCTION T) FUNCTION
		(WHEN (TYPE-MEMBER CONSTANT DTP-LOCATIVE
				   DTP-EXTERNAL-VALUE-CELL-POINTER
				   DTP-CALL-INDIRECT
				   DTP-CALL-INDIRECT-PREFETCH)
		  (IF (EQ (%SET-TAG CONSTANT DTP-LOCATIVE) ANCESTOR-LOCATION)
		      (REFERENCE-UNDEFINED-FUNCTION-CELL LOCATION ANCESTOR-FSPEC)
		      (LET ((ENTRY (CL:ASSOC (%SET-TAG CONSTANT DTP-LOCATIVE) LOCATIONS)))
			(WHEN (AND ENTRY
				   ;; Could be defined via some agent
				   ;; other than BIN-OP-FDEFINE.
				   (NOT (LOCATION-BOUNDP CONSTANT)))
			  (REFERENCE-UNDEFINED-FUNCTION-CELL LOCATION (SECOND ENTRY))))))))))

(DEFVAR *OPEN-CODED-CONSTANTS-NOT-TO-CHECK* NIL)

(DEFUN VERIFY-OPEN-CODED-CONSTANTS (FUNCTION CONSTANT-VALUE-ALIST)
  (CL:DOLIST (VALUE CONSTANT-VALUE-ALIST)
    (LET ((SYMBOL (POP VALUE)))
      (UNLESS (CL:MEMBER SYMBOL *OPEN-CODED-CONSTANTS-NOT-TO-CHECK*)
	(LET* ((CONSTANTP-CHANGE (AND (CL:GET SYMBOL 'SPECIAL)
				      (NOT (CL:GET SYMBOL 'DEFCONSTANT))))
	       (BOUNDP (BOUNDP SYMBOL))
	       (EQLP (AND BOUNDP (EQL (SYMEVAL SYMBOL) VALUE))))
	  (COND ((AND CONSTANTP-CHANGE EQLP)
		 (WARN "The function ~S contains an inline reference to the~@
	                constant ~S, but that symbol is no longer defined as a constant.~@
                        The value, ~S, is still the same."
		       FUNCTION SYMBOL VALUE))
		((OR CONSTANTP-CHANGE (AND BOUNDP (NOT EQLP)))
		 (SIGNAL-PROCEED-CASE (() 'INLINE-CONSTANT-VALUE-CHANGED
				       :FUNCTION FUNCTION
				       :CONSTANT SYMBOL
				       :OLD-VALUE VALUE)
		   (:NO-ACTION)
		   (:INHIBIT-FUTURE-WARNINGS
		     (PUSH SYMBOL *OPEN-CODED-CONSTANTS-NOT-TO-CHECK*))))
		(T)))))))

;;--- This could be improved to call the optimized MAKE-ARRAY functions when possible.
;;--- The dumper would have to do the work, though.
(DEFUN LOAD-ARRAY (STREAM OPT-LENGTH)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((DIMENSIONS (FAST-BIN-NEXT-VALUE))
	   (NARGS (1+ (* OPT-LENGTH 2)))
	   (COUNT OPT-LENGTH))
      (TAGBODY
	(%START-FUNCTION-CALL #'MAKE-ARRAY RETURN NARGS NIL)
	(%PUSH DIMENSIONS)
	(UNLESS (PLUSP COUNT) (GO END-LOOP))
     LOOP
	(%PUSH (FAST-BIN-NEXT-VALUE)) ;keyword
	(%PUSH (FAST-BIN-NEXT-VALUE)) ;value
	(IF (PLUSP (DECF COUNT)) (GO LOOP))
     END-LOOP
	(RETURN-FROM LOAD-ARRAY
	  (%FINISH-FUNCTION-CALL MAKE-ARRAY RETURN NARGS NIL))))))

(DEFUN INITIALIZE-ARRAY (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (LET* ((ARRAY (FAST-BIN-NEXT-VALUE))
	   (LENGTH (FAST-BIN-NEXT-VALUE)))
      (DECLARE (ARRAY-REGISTER-1D ARRAY))
      (DOTIMES (I LENGTH)
	(%1D-ASET (FAST-BIN-NEXT-VALUE) ARRAY I))
      ARRAY)))

(DEFUN INITIALIZE-NUMERIC-ARRAY (STREAM)
  (WITH-FAST-BIN-NEXT-VALUE (STREAM)
    (WITH-DATA-STACK
      (LET* ((ARRAY (FAST-BIN-NEXT-VALUE))
	     (LENGTH (FAST-BIN-NEXT-VALUE))
	     (RESIDUE 0)
	     (N-BITS (OR (ARRAY-BITS-PER-ELEMENT (ARRAY-TYPE-FIELD ARRAY))
			 32.))
	     (16-ARRAY (COND ((AND (= N-BITS 16.)
				   (= (ARRAY-/#-DIMS ARRAY) 1)
				   (NOT (ARRAY-HAS-LEADER-P ARRAY)))
			      ARRAY)
			     (T
			      (WHEN (< N-BITS 16.)
				(SETQ RESIDUE (MOD (* (ARRAY-LENGTH ARRAY) N-BITS) 16.))
				(UNLESS (ZEROP RESIDUE)
				  (DECF LENGTH)))
			      (MAKE-STACK-ARRAY LENGTH :TYPE 'ART-16B :DISPLACED-TO ARRAY)))))
	(SEND STREAM :STRING-IN NIL 16-ARRAY 0 LENGTH)
	(UNLESS (ZEROP RESIDUE)
	  ;; Load a partial 16-bit word.  Can't store it into the indirect
	  ;; array because that would violate array bounds checking.  Can't store
	  ;; it into the original array because it might not be a numeric array.
	  (LET ((WORD (BIN-NEXT-BYTE STREAM))
		(BIT-ARRAY (MAKE-STACK-ARRAY RESIDUE :TYPE 'ART-1B :DISPLACED-TO ARRAY
					     :DISPLACED-INDEX-OFFSET (* LENGTH 16.))))
	    (DECLARE (ARRAY-REGISTER BIT-ARRAY))
	    (DOTIMES (I RESIDUE)
	      (ASET WORD BIT-ARRAY I)
	      (SETQ WORD (ASH WORD -1)))))
	ARRAY))))
  
(DEFUN CONVERT-ARRAY-TO-FLOATING (STREAM)
  (LET ((ARRAY (BIN-NEXT-VALUE STREAM)))
    #+3600
    (LOOP FOR P = (%1D-ALOC ARRAY 0) THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE P 1)
	  REPEAT (ARRAY-LENGTH ARRAY)
	  DO (%P-DPB (ASH DTP-FLOAT -4) %%Q-HIGH-TYPE P))
    #+IMACH
    (WITH-BLOCK-REGISTERS (2 3)
      (SETF (%BLOCK-REGISTER 2) (%1D-ALOC ARRAY 0))
      (SETF (%BLOCK-REGISTER 3) (%BLOCK-REGISTER 2))
      (UNROLL-BLOCK-FORMS ((ARRAY-LENGTH ARRAY) 4)
        (%BLOCK-WRITE 3 (%SET-TAG (%BLOCK-READ 2) DTP-SINGLE-FLOAT))))
    ARRAY))

(DEFVAR *CAN-MAKE-INSTANCES* NIL)

(DEFUN INITIALIZE-INSTANCE (STREAM LENGTH)
  (LET* ((FLAVOR-NAME (BIN-NEXT-VALUE STREAM))
	 (INIT-PLIST (LOAD-LIST STREAM LENGTH)))
    (LEXPR-FUNCALL (IF *CAN-MAKE-INSTANCES* #'MAKE-INSTANCE #'MAKE-INSTANCE-COLD)
		   FLAVOR-NAME INIT-PLIST)))
