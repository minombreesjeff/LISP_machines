;;; -*- Mode: LISP; Syntax: Common-lisp; Package: NFS; Base: 10; Lowercase: Yes; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; This file implements the protocol version independent part of the lisp
;;; machine user end for the Sun Network File System (NFS) Protocol, as
;;; specified in the sun Network File System Protocol Specification, Revision
;;; B of 17 February 1986.

;;; First, here's the definition of the protocol that the version dependent
;;; part of the file access path has to support.

(defgeneric fap-fhandle-times (nfs-access-path fhandle)
  (declare (values mtime ctime)))

(defgeneric fap-unmount (nfs-access-path pathname))

(defgeneric fap-unmount-all (nfs-access-path))

(defgeneric fap-try-mount (nfs-access-path pathname fhandle
					   &optional errorp for-pathname for-operation)
  (declare (values fhandle)))

(defgeneric fap-nfs-exports (nfs-access-path)
  (declare (values exports)))

(defgeneric fap-read-link (nfs-access-path fhandle pathname truename)
  (declare (values pathname)))

(defgeneric fap-read-link-with-caching (nfs-access-path fhandle pathname truename fattr)
  (declare (values pathname merged-pathname)))

(defgeneric fap-lookup-dirpart-in-directory
	    (nfs-access-path pathname dir-pathname dir-fhandle link-opaque-p links-taken
			     mount-out-dir-truename mount-in-dir-truename mtime ctime)
  (declare (values truename dir-truename dir-fhandle links-taken mtime ctime)))

(defgeneric fap-lookup-nampart-in-directory
	    (nfs-access-path pathname dir-pathname dir-fhandle link-opaque-p links-taken
			     mount-out-dir-truename mount-in-dir-truename mtime ctime)
  (declare (values truename dir-truename fhandle links-taken mtime ctime)))

(defgeneric fap-rename-internal (nfs-access-path old-dir-fhandle old-truename oldname
						 new-dir-fhandle new-truename newname))

(defgeneric fap-delete-internal (nfs-access-path dir-fhandle truename filename))

(defgeneric fap-expunge-internal (nfs-access-path dir-fhandle truename filename)
  (declare (values nblocks)))

(defgeneric fap-create-directory-internal (nfs-access-path dir-fhandle truename filename))

(defgeneric fap-create-link-internal
	    (nfs-access-path dir-fhandle truename filename linkfrom-path linkto-path))

(defgeneric fap-fattr-etc-to-property-list (nfs-access-path fattr pathname truename fhandle)
  (declare (values property-list)))

(defgeneric fap-change-properties-internal
	    (nfs-access-path pathname fhandle truename properties)
  (declare (values property-list)))

(defgeneric fap-properties-internal (nfs-access-path pathname fhandle truename)
  (declare (values property-list)))

(defgeneric fap-trivial-directory-list-internal (nfs-access-path dir-fhandle truename filename)
  (declare (values property-lists)))

(defgeneric fap-uncached-scan-directory
	    (nfs-access-path pathname truename dir-fhandle mtime ctime function)
  (declare (sys:downward-funarg function)))

(defgeneric fap-stat (nfs-access-path pathname truename dir-fhandle fhandle operation)
  (declare (values plist mtime ctime)))

(defgeneric fap-directory-list-start-future (nfs-access-path dir-fhandle truename)
  (declare (values future)))

(defgeneric fap-directory-list-finish-future (nfs-access-path dir-fhandle pathname future)
  (declare (values plist)))

(defgeneric fap-directory-list-abort-future (nfs-access-path future))

(defgeneric fap-global-file-properties (nfs-access-path dir-fhandle truename)
  (declare (values fs-property-list)))

(defgeneric fap-create-file (nfs-access-path dir-fhandle pathname fhandle &optional mode)
  (declare (values pathname fhandle plist)))

(defgeneric fap-check-access-for-output-internal (nfs-access-path pathname fhandle fattr)
  "Cause an access check to be made to see whether we can do output to this file.")

(defgeneric fap-create-output-temp
	    (nfs-access-path pathname dir-fhandle fhandle &optional mode fattr)
  "Creates a temporary file in the same directory as the given
   pathname that is suitable for output and later renaming to the pathname
   when you want to close the stream."
  (declare (values truename fhandle plist)))

(defgeneric fap-truncate-file (nfs-access-path fhandle pathname))

(defgeneric fap-fhandle-etc-for-open
	    (nfs-access-path dir-fhandle pathname direction byte-size
			     if-exists if-does-not-exist error fhandle links-taken
			     mount-out-dir-truename mount-in-dir-truename
			     dir-mtime dir-ctime)
  (declare (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist)))

(defgeneric fap-file-access-path-open-internal
	    (nfs-access-path fhandle dir-fhandle pathname truename direction
			     characters binary byte-size preserve-dates
			     raw direct fake-characters plist buffer-pointer
			     length open-mode output-temp-pathname)
  (declare (values stream binary-p)))

;;; Methods that depend on the pathname syntax of the host

(defgeneric fap-nfs-parse-pathname (nfs-access-path string &optional relative-to-host)
  (declare (values pathname)))

(defgeneric fap-nfs-parse-filename (nfs-access-path string directory-pathname)
  (declare (values pathname)))

(defgeneric fap-nfs-pathname-string-for-host (nfs-access-path pathname)
  (declare (values string)))

(defgeneric fap-nfs-filename-string-for-host (nfs-access-path pathname)
  (declare (values string)))

(defgeneric fap-nfs-temporary-pathname (nfs-access-path pathname counter)
  (declare (values pathname)))

(defgeneric fap-close-finish-rename-pathname (nfs-access-path pathname counter)
  (declare (values pathname)))

(defgeneric fap-nfs-mount-string-for-host (nfs-access-path pathname)
  (declare (values string)))

(defflavor nfs-access-path-mixin
	((transport-agent nil)
	 (unix-name-lookup-access-path nil)
	 (remote-filesystems nil)
	 (dir-fhandle-cache nil)
	 (dir-fhandle-cache-lock (process:make-lock "NFS Dir Fhandle Cache Lock"
						    :type :multiple-reader-single-writer))
	 (dir-contents-cache nil)
	 (dir-contents-cache-lock (process:make-lock "NFS Dir Contents Cache Lock"
						     :type :multiple-reader-single-writer))
	 (link-cache nil)
	 (link-cache-lock (process:make-lock "NFS Link Cache Lock"
					     :type :multiple-reader-single-writer))
	 (mount-alist nil)
	 (mount-alist-lock (process:make-lock "NFS Mount Alist Lock"
					      :type :multiple-reader-single-writer))
	 (exports nil)
	 (inhibit-dir-fhandle-cache-validity-checking nil)
	 (inhibit-dir-contents-cache-validity-checking nil)
	 (inhibit-output-access-checking nil)
	 (unmount-idle-mounts-timer nil))
	()
  (:required-flavors fs:user-file-access-path)
  (:required-methods
   fap-fhandle-times
   fap-unmount-all
   fap-try-mount
   fap-nfs-exports
   fap-read-link
   fap-read-link-with-caching
   fap-lookup-dirpart-in-directory
   fap-lookup-nampart-in-directory
   fap-rename-internal
   fap-delete-internal
   fap-expunge-internal
   fap-create-directory-internal
   fap-create-link-internal
   fap-fattr-etc-to-property-list
   fap-change-properties-internal
   fap-properties-internal
   fap-trivial-directory-list-internal
   fap-uncached-scan-directory
   fap-stat
   fap-directory-list-start-future
   fap-directory-list-finish-future
   fap-directory-list-abort-future
   fap-global-file-properties
   fap-create-file
   fap-check-access-for-output-internal
   fap-create-output-temp
   fap-truncate-file
   fap-fhandle-etc-for-open
   fap-file-access-path-open-internal
   fap-nfs-parse-pathname
   fap-nfs-parse-filename
   fap-nfs-pathname-string-for-host
   fap-nfs-filename-string-for-host
   fap-nfs-temporary-pathname
   fap-close-finish-rename-pathname
   fap-nfs-mount-string-for-host
   fap-pathname-for-creation
   fap-get-newest-version
   fap-unmount
   )
  (:functions directory-list-fill-in-properties)
  (:locatable-instance-variables 
   inhibit-dir-fhandle-cache-validity-checking
   inhibit-dir-contents-cache-validity-checking)
  (:conc-name fap-)
  :abstract-flavor)

(defmethod (make-instance nfs-access-path-mixin) (&rest ignore)
  (setq unmount-idle-mounts-timer
	(process:create-timer-call
	  #'fap-unmount-idle-mounts (list self)
	  :name (format nil "NFS Unmount Idle Mounts ~A" (send fs:host :short-name)))))

(defmethod (fap-transport-agent nfs-access-path-mixin) ()
  (or transport-agent
      (prog1 (setq transport-agent (host-udp-transport-agent fs:host))
	     (udp-agent-note-dependent transport-agent self))))

(defmethod (dependent-note-udp-agent-closed nfs-access-path-mixin) (agent)
  (when (eq agent transport-agent)
    (setq transport-agent nil)
    (udp-agent-note-dependent agent self t)))

(defmethod (fap-unix-name-lookup-access-path nfs-access-path-mixin) ()
  (or unix-name-lookup-access-path
      (prog1 (setq unix-name-lookup-access-path (host-unix-name-lookup-access-path fs:host))
	     (unix-name-lookup-access-path-note-dependent
	       unix-name-lookup-access-path self))))

(defmethod (dependent-note-unix-name-lookup-access-path-reset nfs-access-path-mixin) (path)
  (when (eq path unix-name-lookup-access-path)
    (setq unix-name-lookup-access-path nil)
    (unix-name-lookup-access-path-note-dependent path self t)))

(defwhopper (:set-host-user-id nfs-access-path-mixin) (new-user-id &optional new-password)
  (multiple-value-bind (user-id password)
      (authentication-initialize (fap-transport-agent self) new-user-id new-password)
    (continue-whopper user-id password)))

(defmethod (:host-user-id nfs-access-path-mixin) ()
  (unless fs:host-user-id (send self :set-host-user-id nil))
  (values fs:host-user-id fs:host-password))

(defgeneric fap-ensure-authentication (nfs-access-path))

(defmethod (fap-ensure-authentication nfs-access-path-mixin) ()
  (unless (and fs:host-user-id
	       (eq (authentication-username (fap-transport-agent self)) fs:host-user-id))
    (send self :set-host-user-id fs:host-user-id fs:host-password)))

(defflavor no-nfs-version-available
	(errors)
	(nfs-error)
  (:initable-instance-variables errors)
  (:gettable-instance-variables errors)
  (:required-init-keywords :errors))

(defmethod (:report-without-pathname no-nfs-version-available) (stream)
  (format stream "There appears to be no usable version of NFS running on ~A."
	  (send self :foreign-host)))

(defmethod (dbg:report no-nfs-version-available :after) (stream)
  (loop for (version error) in errors
	do (format stream "~&For protocol version ~D, this error occurred:~%    ~~A~"
		   version error)))

(compile-flavor-methods no-nfs-version-available)

(defvar *nfs-access-path-flavor-alist* nil)

(defgeneric nfs-access-path-flavor (host))

(defvar *show-nfs-progress-notes* t)

(defmethod (nfs-access-path-flavor fs:active-pathname-host) ()
  (block found
    (let ((errors nil))
      (tv:noting-progress-if (or *show-nfs-progress-notes* (tv:show-progress-note :network))
	  ((format nil "NFS Determining which protocol version to use for ~A" self))
	(labels ((host-typep (type)
		   (cond ((listp type)
			  (loop for type in type thereis (host-typep type)))
			 ((keywordp type)
			  (eq type (send self :system-type)))
			 (t
			  (typep self type))))
		 (test-predicate (version predicate)
		   (condition-case (error)
			(funcall predicate self)
		      (rpc-error
			(push (list version error) errors)
			nil))))
	  (loop for (version . elements) in
		    (stable-sort *nfs-access-path-flavor-alist* #'> :key #'first)
	     do (loop for (type predicate flavor) in elements
		   when (and (host-typep type)
			     (test-predicate version predicate))
		     do (return-from found flavor)))))
      (error 'no-nfs-version-available
	     :foreign-host self
	     :errors (remove-duplicates errors :key #'first)))))

(fs:define-file-protocol :nfs (:udp)
  (:desirability .60)
  (:access-path-flavor (host) (nfs-access-path-flavor host))
  (:property :big-packets 10240)
  )

(tcp:add-udp-port-for-protocol :nfs 2049)

(defmethod (:sample-pathname nfs-access-path-mixin) ()
  (send fs:host :sample-pathname))

(defmethod (:parse-truename nfs-access-path-mixin) (pathname)
  (fs:parse-pathname pathname fs:host (send fs:host :sample-pathname))) 

(defun-in-flavor (nfs-fap nfs-access-path-mixin) (pathname operation)
  (let ((host (send pathname :host)))
    (if (neti:ns-eq host fs:host)
	self
      (nfs-access-path-for-host host pathname operation))))

;;; dir-fhandle-cache stuff

(defmacro with-dir-fhandle-cache-validity-checking-inhibited
	  ((fap dir-pathname) &body body)
  `(letf (((fap-inhibit-dir-fhandle-cache-validity-checking ,fap)
	   (cons ,dir-pathname (fap-inhibit-dir-fhandle-cache-validity-checking ,fap))))
     ,@body))

(defun-in-flavor (dir-fhandle-cache-decache nfs-access-path-mixin) (pathname)
  (let ((fhandle (process:with-lock (dir-fhandle-cache-lock :mode :write)
		   (let ((info (assoc pathname dir-fhandle-cache)))
		     (when info
		       (setq dir-fhandle-cache (delete info dir-fhandle-cache))
		       (cadr info))))))
    (when fhandle (deallocate-resource 'nfs-fhandle fhandle))))

(defparameter *dir-fhandle-cache-reap-time* (* 5 60 60))

(defun-in-flavor (dir-fhandle-cache-reap nfs-access-path-mixin) ()
  (process:with-lock (dir-fhandle-cache-lock :mode :write)
    (loop for info in dir-fhandle-cache
	  for (pathname fhandle mtime ctime qtime) = info
	  initially (progn pathname mtime ctime)
	  when (time:time-elapsed-p *dir-fhandle-cache-reap-time* qtime)
	    do (setq dir-fhandle-cache (delete info dir-fhandle-cache))
	       (deallocate-resource 'nfs-fhandle fhandle))))

(defgeneric fap-dir-fhandle-cache-lookup
	    (nfs-access-path pathname dir-fhandle &optional mtime ctime)
  (declare (values found-p mtime ctime)))

(defmethod (fap-dir-fhandle-cache-lookup nfs-access-path-mixin)
	   (pathname dir-fhandle &optional mtime ctime)
  (declare (values found-p mtime ctime))
  (dir-fhandle-cache-reap)
  (with-nfs-fhandle (fhandle)
    (let ((info (process:with-lock (dir-fhandle-cache-lock :mode :read)
		  (let ((info (assoc pathname dir-fhandle-cache)))
		    (when info
		      (copy-nfs-fhandle (second info) fhandle)
		      (cddr info))))))
      (if info
	  (destructuring-bind (cached-mtime cached-ctime cached-qtime) info
	    (declare (ignore cached-qtime))
	    (cond ((or (member pathname inhibit-dir-fhandle-cache-validity-checking)
		       (progn
			 (unless (and mtime ctime)
			   (multiple-value-setq (mtime ctime)
			     (fap-fhandle-times self fhandle)))
			 (and mtime (eql cached-mtime mtime)
			      ctime (eql cached-ctime ctime))))
		   (copy-nfs-fhandle fhandle dir-fhandle)
		   (values t mtime ctime))
		  (t
		   (dir-fhandle-cache-decache pathname)
		   (values nil mtime ctime))))
	(values nil mtime ctime)))))

(defparameter *dir-fhandle-cache-limit* 16)

(defun-in-flavor (dir-fhandle-cache-flush nfs-access-path-mixin) ()
  (loop for fhandle in (process:with-lock (dir-fhandle-cache-lock :mode :write)
			 (loop for (pathname fhandle mtime ctime qtime) in dir-fhandle-cache
			       initially (progn pathname mtime ctime qtime)
			       collect fhandle into fhandles
			       finally (setq dir-fhandle-cache nil)
				       (return fhandles)))
	do (deallocate-resource 'nfs-fhandle fhandle)))

(defun-in-flavor (dir-fhandle-cache-encache nfs-access-path-mixin)
		 (pathname fhandle mtime ctime)
  (when (and pathname fhandle mtime ctime)
    (when (and ( (length dir-fhandle-cache) *dir-fhandle-cache-limit*)
	       (null (assoc pathname dir-fhandle-cache)))
      (dir-fhandle-cache-flush))
    (process:with-lock (dir-fhandle-cache-lock :mode :write)
      (let ((info (or (assoc pathname dir-fhandle-cache)
		      (car (push (list pathname (allocate-resource 'nfs-fhandle) mtime ctime
				       (sys:time))
				 dir-fhandle-cache)))))
	(copy-nfs-fhandle fhandle (second info))
	(setf (third info) mtime)
	(setf (fourth info) ctime)
	(setf (fifth info) (sys:time))))))

(defun-in-flavor (dir-fhandle-cache-update nfs-access-path-mixin)
		 (pathname fhandle old-mtime old-ctime new-mtime new-ctime)
  (process:with-lock (dir-fhandle-cache-lock :mode :write)
    (let ((info (assoc pathname dir-fhandle-cache)))
      (when info
	(if (or (not (eql old-mtime (third info)))
		(not (eql old-ctime (fourth info))))
	    (setq dir-fhandle-cache (delete info dir-fhandle-cache))
	  (copy-nfs-fhandle fhandle (second info))
	  (setf (third info) new-mtime)
	  (setf (fourth info) new-ctime))))))

;;; dir-contents-cache stuff

(defmacro with-dir-contents-cache-validity-checking-inhibited
	  ((fap dir-pathname) &body body)
  `(letf (((fap-inhibit-dir-contents-cache-validity-checking ,fap)
	   (cons ,dir-pathname (fap-inhibit-dir-contents-cache-validity-checking ,fap))))
     ,@body))

(defun-in-flavor (dir-contents-cache-decache nfs-access-path-mixin) (pathname)
  (process:with-lock (dir-contents-cache-lock :mode :write)
    (let ((record (assoc pathname dir-contents-cache)))
      (when record
	(setq dir-contents-cache (delete record dir-contents-cache))
	(cadr record)))))

(defparameter *dir-contents-cache-reap-time* (* 5 60 60))

(defun-in-flavor (dir-contents-cache-reap nfs-access-path-mixin) ()
  (process:with-lock (dir-contents-cache-lock :mode :write)
    (loop for record in dir-contents-cache
	  for (pathname contents mtime ctime qtime) = record
	  initially (progn pathname contents mtime ctime)
	  when (time:time-elapsed-p *dir-contents-cache-reap-time* qtime)
	    do (setq dir-contents-cache (delete record dir-contents-cache)))))

(defun-in-flavor (with-mount-point-resetting-internal nfs-access-path-mixin)
		 (operation function)
  (declare (sys:downward-funarg function))
  (let ((should-reset nil))
    (block with-mount-point-resetting
      (tagbody
	retry
	   (return-from with-mount-point-resetting
	     (error-restart (fs:file-not-found
			      "Retry ~A after resetting the mount information for ~A."
			      operation fs:host)
	       (cond (should-reset
		      (fap-mount-point-reset self))
		     (t
		      (setq should-reset t)))
	       (funcall function)))))))

(defmacro-in-flavor (with-mount-point-resetting nfs-access-path-mixin)
		    ((operation) &body body)
  `(with-mount-point-resetting-internal ,operation #'(lambda () ,@body)))

(zwei:defindentation (with-mount-point-resetting 0 4 1 1))

(defun-in-flavor (pathname-to-fhandle-and-truename nfs-access-path-mixin)
		 (pathname operation link-opaque-p fhandle)
  (declare (values fhandle truename mount-out-dir-truename mount-in-dir-truename))
  (with-mount-point-resetting ('pathname-to-fhandle-and-truename)
    (loop with links-taken = nil
	  with truename = pathname
	  with truename-checked-1 = nil
	  with truename-checked-2 = nil
	  with true-fhandle = nil
	  with mount-out-dir-truename = nil
	  with mount-in-dir-truename = nil
	  with dir-truename = nil 
	  with dir-fhandle = nil
	  with dir-mtime = nil
	  with dir-ctime = nil
	  with dir-fap = self
	  unless dir-truename
	    do (multiple-value-setq
		 (truename mount-out-dir-truename mount-in-dir-truename
			   dir-truename dir-fhandle)
		 (fap-best-mount-for-pathname
		   (nfs-fap truename 'pathname-to-fhandle-and-truename)
		   truename operation fhandle))
	       (setq dir-mtime nil dir-ctime nil)
	       (setq dir-fap (nfs-fap dir-truename 'pathname-to-fhandle-and-truename))
	  when (eq truename dir-truename)
	    ;; Handle case where the file is a directory, and we have the
	    ;; fhandle for it.
	    return (values dir-fhandle truename
			   mount-out-dir-truename mount-in-dir-truename
			   dir-mtime dir-ctime)
	  for truename-directory = (send truename :directory-pathname-as-file)
	  if (or (eq truename-directory dir-truename)
		 (and (neq truename truename-checked-1)
		      (multiple-value-bind (found-p mtime ctime)
			  (fap-dir-fhandle-cache-lookup
			    dir-fap truename-directory dir-fhandle)
			(setq truename-checked-1 truename)
			(when found-p
			  (setq dir-truename truename-directory
				dir-mtime mtime dir-ctime ctime))
			found-p)))
	    do (multiple-value-setq (truename dir-truename true-fhandle links-taken
					      dir-mtime dir-ctime)
		 (fap-lookup-nampart-in-directory
		   dir-fap truename truename-directory dir-fhandle link-opaque-p links-taken
		   mount-out-dir-truename mount-in-dir-truename
		   dir-mtime dir-ctime))
	  else
	    do (unless (eq truename truename-checked-2)
		 (setq truename-checked-2 truename)
		 (loop for dir first truename-directory
			       then (send dir :directory-pathname-as-file)
		       until (or (eq dir dir-truename)
				 (multiple-value-bind (found-p mtime ctime)
				     (fap-dir-fhandle-cache-lookup dir-fap dir dir-fhandle)
				   (when found-p
				     (setq dir-truename dir dir-mtime mtime dir-ctime ctime))
				   found-p))))
	       (multiple-value-setq (truename dir-truename dir-fhandle links-taken
					      dir-mtime dir-ctime)
		 (fap-lookup-dirpart-in-directory
		   dir-fap truename dir-truename dir-fhandle nil links-taken
		   mount-out-dir-truename mount-in-dir-truename
		   dir-mtime dir-ctime))
	  when true-fhandle
	    return (values true-fhandle truename
			   mount-out-dir-truename mount-in-dir-truename
			   dir-mtime dir-ctime))))	  

(defun-in-flavor (dir-contents-cache-lookup nfs-access-path-mixin)
		 (pathname &optional mtime ctime)
  (declare (values contents found-p mtime ctime))
  (dir-contents-cache-reap)
  (let ((record (process:with-lock (dir-contents-cache-lock :mode :read)
		  (assoc pathname dir-contents-cache))))
    (if record
	(destructuring-bind
	  (cached-pathname cached-contents cached-mtime cached-ctime cached-qtime)
	    record
	  (declare (ignore cached-pathname cached-qtime))
	  (cond ((or (member pathname inhibit-dir-contents-cache-validity-checking)
		     (progn
		       (unless (and mtime ctime)
			 (with-nfs-fhandle (fhandle)
			   (multiple-value-bind (fhfoundp fhmtime fhctime)
			       (fap-dir-fhandle-cache-lookup self pathname fhandle)
			     (when (and fhmtime fhctime)
			       (setq mtime fhmtime ctime fhctime))
			     (unless fhfoundp 
			       (pathname-to-fhandle-and-truename
				 pathname 'dir-contents-cache-lookup t fhandle))
			     (unless (and mtime ctime)
			       (multiple-value-setq (mtime ctime)
				 (fap-fhandle-times self fhandle))))))
		       (and (eql cached-mtime mtime) (eql cached-ctime ctime))))
		 (values cached-contents t mtime ctime))
		(t
		 (dir-contents-cache-decache pathname)
		 (values nil nil mtime ctime))))
      (values nil nil mtime ctime))))

(defparameter *dir-contents-cache-limit* 16)

(defun-in-flavor (dir-contents-cache-flush nfs-access-path-mixin) ()
  (process:with-lock (dir-contents-cache-lock :mode :write)
    (setq dir-contents-cache nil)))

(defun-in-flavor (dir-contents-cache-encache nfs-access-path-mixin)
		 (pathname contents mtime ctime)
  (when (and pathname mtime ctime)
    (when (and ( (length dir-contents-cache) *dir-contents-cache-limit*)
	       (not (assoc pathname dir-contents-cache)))
      (dir-contents-cache-flush))
    (process:with-lock (dir-contents-cache-lock :mode :write)
      (let ((record (or (assoc pathname dir-contents-cache)
			(car (push (list pathname contents mtime ctime (sys:time))
				   dir-contents-cache)))))
	(setf (second record) contents)
	(setf (third record) mtime)
	(setf (fourth record) ctime)
	(setf (fifth record) (sys:time))))))

(defun-in-flavor (dir-contents-cache-update nfs-access-path-mixin)
		 (pathname contents old-mtime old-ctime new-mtime new-ctime)
  (process:with-lock (dir-contents-cache-lock :mode :write)
    (let ((record (assoc pathname dir-contents-cache)))
      (when record
	(if (or (not (eql old-mtime (third record)))
		(not (eql old-ctime (fourth record))))
	    (setq dir-contents-cache (delete record dir-contents-cache))
	  (setf (second record) contents)
	  (setf (third record) new-mtime)
	  (setf (fourth record) new-ctime))))))

(defparameter *dir-contents-cache-window-of-vulnerability-time* (* 10 60))

(defun-in-flavor (updating-dir-caches-internal nfs-access-path-mixin)
		 (pathname fhandle-function contents-function body-function)
  (declare (sys:downward-funarg fhandle-function contents-function body-function))
  (with-nfs-fhandle (fhandle)
    (let ((initial-time (time:time)))
      (multiple-value-bind (fhandle-found-p fhandle-mtime fhandle-ctime)
	  ;; Check to see if the directory fhandle is still validly in the cache
	  (fap-dir-fhandle-cache-lookup self pathname fhandle)
	(multiple-value-bind (contents contents-found-p contents-mtime contents-ctime)
	    ;; Check to see if the directory contents are still validly in the cache
	    (dir-contents-cache-lookup pathname fhandle-mtime fhandle-ctime)
	  (multiple-value-prog1
	    ;; Do the operation
	    (funcall body-function)
	    ;; Fix up the caches if there were valid entries in them in the
	    ;; first place.
	    (when (or fhandle-found-p contents-found-p)
	      (unless fhandle-found-p
		;; We don't have a valid fhandle, but we do have valid
		;; contents.  We need a valid fhandle to get the times. Fill
		;; in the fhandle with valid data.
		(pathname-to-fhandle-and-truename
		  pathname 'updating-dir-caches-internal t fhandle))
	      (multiple-value-bind (mtime ctime)
		  ;; Get the new real times.
		  (fap-fhandle-times self fhandle)
		(when fhandle-found-p
		  ;; The fhandle was valid before we did our operation, so now
		  ;; update the fhandle cache with a valid fhandle and times.
		  (dir-fhandle-cache-update
		    pathname (funcall fhandle-function fhandle)
		    fhandle-mtime fhandle-ctime
		    mtime ctime))
		(when contents-found-p
		  ;; The contents were valid before we did our operation, so
		  ;; now update the contents cache with valid contents and
		  ;; times.
		  (dir-contents-cache-update
		    pathname (funcall contents-function contents)
		    contents-mtime contents-ctime
		    mtime ctime)))
	      ;; If all this took too long then invalidate the cache entries,
	      ;; since the probability of something having happened behind our
	      ;; back is high.
	      (when (time:time-elapsed-p
		      *dir-contents-cache-window-of-vulnerability-time* 
		      initial-time)
		(dir-fhandle-cache-decache pathname)
		(dir-contents-cache-decache pathname)))))))))

(defmacro-in-flavor (updating-dir-caches nfs-access-path-mixin)
		    ((pathname fhandle contents) &body body)
  `(updating-dir-caches-internal
     ,pathname
     #'(lambda (fhandle) ,fhandle)
     #'(lambda (contents) ,contents)
     #'(lambda () ,@body)))

(zwei:defindentation (updating-dir-caches 0 4 1 1))


;;; link-cache stuff

(defun-in-flavor (link-cache-decache nfs-access-path-mixin) (pathname)
  (process:with-lock (link-cache-lock :mode :write)
    (let ((info (assoc pathname link-cache)))
      (when info
	(setq link-cache (delete info link-cache))
	(cadr info)))))

(defparameter *link-cache-reap-time* (* 5 60 60))

(defun-in-flavor (link-cache-reap nfs-access-path-mixin) ()
  (process:with-lock (link-cache-lock :mode :read)
    (loop for record in link-cache
	  for (pathname link mtime ctime qtime) = record
	  initially (progn pathname link mtime ctime)
	  when (time:time-elapsed-p *link-cache-reap-time* qtime)
	    do (setq link-cache (delete record link-cache)))))

(defun-in-flavor (link-cache-lookup nfs-access-path-mixin)
		 (pathname mtime ctime)
  (declare (values link-if-found mtime ctime))
  (link-cache-reap)
  (let ((info (process:with-lock (link-cache-lock :mode :write)
		(cdr (assoc pathname link-cache)))))
    (if info
	(destructuring-bind (link cached-mtime cached-ctime cached-qtime) info
	  (declare (ignore cached-qtime))
	  (cond ((and mtime ctime
		      (= mtime cached-mtime)
		      (= ctime cached-ctime))
		 (values link mtime ctime))
		(t
		 (link-cache-decache pathname)
		 (values nil mtime ctime))))
      (values nil mtime ctime))))

(defparameter *link-cache-limit* 64)

(defun-in-flavor (link-cache-flush nfs-access-path-mixin) ()
  (process:with-lock (link-cache-lock :mode :write)
    (setq link-cache nil)))

(defun-in-flavor (link-cache-encache nfs-access-path-mixin)
		 (pathname link mtime ctime)
  (when (and pathname link mtime ctime)
    (when ( (length link-cache) *link-cache-limit*)
      (link-cache-flush))
    (process:with-lock (link-cache-lock :mode :write)
      (let ((info (or (assoc pathname link-cache)
		      (car (push (list pathname link mtime ctime (sys:time)) link-cache)))))
	(setf (second info) link)
	(setf (third info) mtime)
	(setf (fourth info) ctime)
	(setf (fifth info) (sys:time))))))

(defun-in-flavor (read-link-with-caching nfs-access-path-mixin)
		 (fhandle pathname truename mtime ctime)
  (let ((link (or (link-cache-lookup truename mtime ctime)
		  (let ((link (fap-read-link self fhandle pathname truename)))
		    (link-cache-encache truename link mtime ctime)
		    link))))
    (values link 
	    (send link :merge-pathnames
		  (send truename :new-pathname
			:raw-name (send link :raw-name)
			:raw-type (send link :raw-type)
			:version (send link :version)
			:vc-version (send link :vc-version))
		  (send link :version)
		  (send link :vc-version)))))

;;; User end of mounting stuff.

(defstruct (mount-entry (:type list) (:copier nil))
  dir dev entrypoint fhandle fs-plist type (time (time:time)))

(defparameter *mount-expiration-time* (* 5 60 60))

(defun-in-flavor (reset-unmount-idle-mounts-timer nfs-access-path-mixin) ()
  (let ((delta
	  (process:with-lock (mount-alist-lock :mode :read)
	    (loop with time = (time:time)
		  with should-reset = nil
		  for entry in mount-alist
		  for last-used-at = (mount-entry-time entry)
		  for time-elapsed = (time:time-difference time last-used-at)
		  for time-remaining = (- *mount-expiration-time* time-elapsed)
		  when (or (mount-entry-fhandle entry)
			   (listp (mount-entry-type entry)))
		    do (setq should-reset t)
		    and minimize time-remaining into delta
		  finally (when should-reset (return delta))))))
    (if delta
	(process:reset-timer-relative unmount-idle-mounts-timer (max (/ delta 60.0) 0.5))
      (process:clear-timer unmount-idle-mounts-timer))))

(defgeneric fap-lookup-mount-entry (nfs-access-path dir fhandle pathname)
  (declare (values dir dev entrypoint fhandle fs-plist type)))

(defmethod (fap-lookup-mount-entry nfs-access-path-mixin) (dir fhandle pathname)
  (declare (values dir dev entrypoint fhandle fs-plist type)
	   (ignore pathname))
  (multiple-value-prog1
    (process:with-lock (mount-alist-lock :mode :read)
      (let ((entry (find dir mount-alist :key #'mount-entry-dir)))
	(when entry
	  (setf (mount-entry-time entry) (time:time))
	  (return-from fap-lookup-mount-entry
	    (values
	      (mount-entry-dir entry)
	      (mount-entry-dev entry)
	      (mount-entry-entrypoint entry)
	      (when (mount-entry-fhandle entry)
		(copy-nfs-fhandle (mount-entry-fhandle entry) fhandle)
		fhandle)
	      (mount-entry-fs-plist entry)
	      (mount-entry-type entry))))))
    (reset-unmount-idle-mounts-timer)))

(defgeneric fap-add-mount-entry (nfs-access-path dir dev entrypoint fhandle fs-plist type)
  (declare (values fhandle)))

(defmethod (fap-add-mount-entry nfs-access-path-mixin)
	   (dir dev entrypoint fhandle fs-plist type)
  (multiple-value-prog1
    (process:with-lock (mount-alist-lock :mode :write)
      (let ((entry (or (find dir mount-alist :key #'mount-entry-dir)
		       (car (push (make-mount-entry :dir dir :dev dev :entrypoint entrypoint
						    :fs-plist fs-plist :type type)
				  mount-alist)))))
	(when (or (neq (mount-entry-dev entry) dev)
		  (neq (mount-entry-entrypoint entry) entrypoint))
	  (setf (mount-entry-dev entry) dev)
	  (setf (mount-entry-entrypoint entry) entrypoint)
	  (when (mount-entry-fhandle entry)
	    (deallocate-resource 'nfs-fhandle (shiftf (mount-entry-fhandle entry) nil)))
	  (setf (mount-entry-fs-plist entry) nil))
	(when fhandle 
	  (if (mount-entry-fhandle entry)
	      (copy-nfs-fhandle fhandle (mount-entry-fhandle entry))
	    (let ((entry-fhandle (allocate-resource 'nfs-fhandle)))
	      (copy-nfs-fhandle fhandle entry-fhandle)
	      (setf (mount-entry-fhandle entry) entry-fhandle)))
	  (setf (mount-entry-fs-plist entry) nil))
	(when fs-plist
	  (setf (mount-entry-fs-plist entry) fs-plist))
	(when type
	  (setf (mount-entry-type entry) type))
	(setf (mount-entry-time entry) (time:time)))
      (setq mount-alist (sys:localize-tree mount-alist))
      fhandle)
    (reset-unmount-idle-mounts-timer)))

(defgeneric fap-map-mount-entries (nfs-access-path function)
  (declare (sys:downward-funarg function)))

(defmethod (fap-map-mount-entries nfs-access-path-mixin) (function)
  (declare (sys:downward-funarg function))
  (process:with-lock (mount-alist-lock :mode :read)
    (loop for entry in mount-alist
	  when (funcall function
			(mount-entry-dir entry) (mount-entry-dev entry)
			(mount-entry-entrypoint entry) (mount-entry-fhandle entry)
			(mount-entry-fs-plist entry) (mount-entry-type entry)
			(mount-entry-time entry))
	    do (setf (mount-entry-time entry) (time:time))))
  (reset-unmount-idle-mounts-timer))

(defgeneric fap-remove-mount-entry (access-path-mixin fhandle))

(defmethod (fap-remove-mount-entry nfs-access-path-mixin) (fhandle)
  (process:with-lock (mount-alist-lock :mode :write)
    (loop for entry in mount-alist
	  when (and (mount-entry-fhandle entry)
		    (nfs-fhandle-equal (mount-entry-fhandle entry) fhandle))
	    do (deallocate-resource 'nfs-fhandle (shiftf (mount-entry-fhandle entry) nil))
	       (setf (mount-entry-fs-plist entry) nil)
	       (setf (mount-entry-time entry) (time:time))
	       (when (null (mount-entry-type entry))
		 (setq mount-alist (delete entry mount-alist)))))
  (reset-unmount-idle-mounts-timer))

(defgeneric fap-flush-mount-entries (nfs-access-path))

(defmethod (fap-flush-mount-entries nfs-access-path-mixin) ()
  (process:with-lock (mount-alist-lock :mode :write)
    (loop for entry in mount-alist
	  when (mount-entry-fhandle entry)
	    do (deallocate-resource 'nfs-fhandle (shiftf (mount-entry-fhandle entry) nil)))
    (setq mount-alist nil))
  (reset-unmount-idle-mounts-timer))

(defun-in-flavor (pathname-contained-p nfs-access-path-mixin) (pathname directory)
  (let ((pathname-dir (send pathname :raw-directory))
	(directory-dir (send directory :raw-directory)))
    (or (eq directory-dir :root)
	(and (listp pathname-dir)
	     (listp directory-dir)
	     (>= (length pathname-dir) (length directory-dir))
	     (loop for x in pathname-dir
		   for y in directory-dir
		   always (and (stringp x)
			       (stringp y)
			       (string= x y)))))))

(defun-in-flavor (deepest-directory-containing nfs-access-path-mixin)
		 (pathname directories)
  (loop with deepest-depth = -1
	with deepest-directory = nil
	for directory in directories
	for as-dir = (as-dir directory)
	for raw-directory = (send as-dir :raw-directory)
	for depth = (if (listp raw-directory) (length raw-directory) 0)
	when (and (> depth deepest-depth)
		  (pathname-contained-p pathname as-dir))
	  do (setq deepest-depth depth deepest-directory directory)
	finally (return deepest-directory)))

(defun-in-flavor (mount-entry-can-be-unmounted-p nfs-access-path-mixin) (entry)
  (when (mount-entry-fhandle entry)
    (when (and (not (null fs:open-streams))
	       (loop with dev = (mount-entry-dev entry)
		     with devs = (loop for entry in mount-alist
				       when (mount-entry-fhandle entry)
					 collect (mount-entry-dev entry))
		     for stream in fs:open-streams
		     for truename = (send stream :truename)
		     thereis (eq dev (deepest-directory-containing truename devs))))
      (setf (mount-entry-time entry) (time:time)))
    (time:time-elapsed-p *mount-expiration-time* (mount-entry-time entry))))

(defun-in-flavor (mount-entry-can-be-deleted-p nfs-access-path-mixin) (entry)
  (and (null (mount-entry-fhandle entry))
       (time:time-elapsed-p *mount-expiration-time* (mount-entry-time entry))
       (let ((type (mount-entry-type entry)))
	 (or (null type)
	     (and (consp type)
		  (every
		    #'(lambda (entry)
			(or (not (consp (mount-entry-type entry)))
			    (not (every #'eq type (mount-entry-type entry)))
			    (and (time:time-elapsed-p
				   *mount-expiration-time*
				   (mount-entry-time entry))
				 (null (mount-entry-fhandle entry)))))
		    mount-alist))))))

(defgeneric fap-unmount-idle-mounts (nfs-access-path))  

(defmethod (fap-unmount-idle-mounts nfs-access-path-mixin) ()
  ;; First reap the caches 
  (dir-fhandle-cache-reap)
  (dir-contents-cache-reap)
  (link-cache-reap)
  ;; Then unmount any mounts that have been idle.
  (let ((pathnames nil)
	(time (time:time)))
    (process:with-lock (mount-alist-lock :mode :write)
      (dolist (entry mount-alist)
	(when (mount-entry-can-be-unmounted-p entry)
	  (deallocate-resource 'nfs-fhandle (shiftf (mount-entry-fhandle entry) nil))
	  (setf (mount-entry-fs-plist entry) nil)
	  (pushnew (mount-entry-dev entry) pathnames)))
      (dolist (entry mount-alist)
	(when (mount-entry-can-be-deleted-p entry)
	  (setq mount-alist (delete entry mount-alist))))
      (dolist (entry mount-alist)
	(when (and (or (mount-entry-fhandle entry)
		       (listp (mount-entry-type entry)))
		   (time:time-elapsed-p
		     *mount-expiration-time*
		     (mount-entry-time entry)
		     time))
	  (setf (mount-entry-time entry) time))))
    (unless (eq si:*user* si:*not-logged-in-user*)
      (condition-case ()
	   (dolist (pathname pathnames)
	     (fap-unmount self pathname))
	 ((rpc-error fs:file-error network-error fs:login-required)))))
  ;; Finally reset the timer so this gets done again
  (reset-unmount-idle-mounts-timer))

;;; Only works for example-pathname and example-truename being directories
;;; and that the directories that are in the example are all there in the pathname
(defun-in-flavor (true-pathname-like nfs-access-path-mixin)
		 (example-pathname example-truename pathname)
  (declare (values truename))
  (cond ((eq example-pathname example-truename)
	 pathname)
	((eq example-pathname pathname)
	 example-truename)
	(t
	 (setq example-pathname (as-dir example-pathname))
	 (setq example-truename (as-dir example-truename))
	 (let* ((exmp-dir (send example-pathname :raw-directory))
		(exmp-dir (when (listp exmp-dir) exmp-dir))
		(true-dir (send example-truename :raw-directory))
		(true-dir (cond ((not (listp true-dir))
				 nil)
				((eq (car true-dir) :relative)
				 (fs:merge-relative-directory true-dir exmp-dir))
				((member nil true-dir)
				 (fs:merge-directories true-dir exmp-dir))
				(t
				 true-dir)))
		(path-dir (send pathname :raw-directory))
		(path-dir (when (listp path-dir) path-dir)))
	   ;; Sanity check
	   (unless (and ( (length exmp-dir) (length path-dir))
			(loop for exmp-dirent in exmp-dir
			      for path-dirent in path-dir
			      unless (string-equal exmp-dirent path-dirent)
				return nil
			      finally (return t)))
	     (error "example ~A and ~A don't agree well enough for trueing"
		    example-pathname pathname))
	   (let* ((path-host (send pathname :host))
		  (new-host (send example-truename :host))
		  (new-dev (send example-truename :raw-device))
		  (new-dir (or (append true-dir (nthcdr (length exmp-dir) path-dir)) :root)))
	     (if (and (eq (send path-host :system-type) (send new-host :system-type))
		      (eq (neti:host-unix-versions-enabled path-host :directory path-dir)
			  (neti:host-unix-versions-enabled new-host :directory new-dir)))
		 ;; Do the common case fast
		 (fs:make-pathname
		   :host new-host
		   :raw-device new-dev
		   :raw-directory new-dir
		   :raw-name (send pathname :raw-name)
		   :raw-type (send pathname :raw-type)
		   :version (send pathname :version))
	       ;; The general case
	       (let* ((new-dir-path
			(fs:make-pathname
			  :host new-host
			  :raw-device new-dev
			  :raw-directory new-dir))
		      (new-fap (nfs-fap new-dir-path 'true-pathname-like)))
		 (fap-nfs-parse-pathname
		   new-fap
		   (string-append
		     (fap-nfs-pathname-string-for-host new-fap new-dir-path)
		     (fap-nfs-filename-string-for-host self pathname))))))))))

(defflavor cant-mount-on-another-host
	(filesystem correct-host)
	(nfs-error)
  (:gettable-instance-variables filesystem correct-host)
  (:initable-instance-variables filesystem correct-host)
  (:required-init-keywords :filesystem :correct-host))

(defmethod (:report-without-pathname cant-mount-on-another-host) (stream)
  (format stream "Couldn't mount the filesystem for \"~A\"; on ~A, it's on ~A."
	  filesystem correct-host (send pathname :host)))

(compile-flavor-methods cant-mount-on-another-host) 

(defflavor cant-mount-anything
	(last-error)
	(nfs-error)
  (:initable-instance-variables last-error)
  (:required-init-keywords :last-error))

(defmethod (:report-without-pathname cant-mount-anything) (stream)
  (format stream "No NFS mount could be made on host ~A.~@
                  The error report for the last mount attempted was:~@
                  ~4T~~A~"
	  (send (send self :pathname) :host)
	  last-error))

(compile-flavor-methods cant-mount-anything)

(defflavor unknown-nfs-mount-pathname-host
	(mount-pathname-string name)
	(nfs-error)
  (:initable-instance-variables mount-pathname-string name)
  (:gettable-instance-variables mount-pathname-string name)
  (:required-init-keywords :mount-pathname-string :name))

(defmethod (:report-without-pathname unknown-nfs-mount-pathname-host) (stream)
  (format stream "The file is inaccessible because it's in the filesystem ~S,~@
                  which can't be mounted, as ~S is not a known file server host."
	  (send self :mount-pathname-string)
	  (send self :name)))

(compile-flavor-methods unknown-nfs-mount-pathname-host)

(defun-in-flavor (parse-mtab-lispm-pathname nfs-access-path-mixin) (pathname)
  ;; Do another parse to catch any fep pathnames
  (let* ((defpath (fs:make-pathname :host (send pathname :host) :directory :root))
	 (path (fs:parse-pathname (send pathname :string-for-host) nil defpath))
	 (h (send path :host)))
    ;; See if it's a fep pathname
    (if (typep h 'fs:fep-file-host)
	;; If it is, make it a remote fep pathname
	(fs:parse-pathname
	  (send path :string-for-host)
	  nil
	  (fs:parse-pathname (format nil "~A|~A:>" (send pathname :host) h)))
      pathname)))

(defun-in-flavor (lookup-mtab-host nfs-access-path-mixin)
		 (host hostname &optional errorp)
  (or (let ((host-info (hostname->host (fap-unix-name-lookup-access-path self) hostname)))
	(when host-info
	  (let* ((internet (net:local-network-of-type :internet))
		 (address (first host-info)))
	    (if (loop for (net addr) in (send host :network-addresses)
		      when (and (eq net internet) (eql addr address))
			return t)
		host
	      (let ((address-host (net:get-host-from-address address internet)))
		(unless (or (send address-host :system-type)
			    (null (send host :system-type)))
		  (send address-host :putprop (send host :system-type) :system-type)
		  (send address-host :change-of-attributes)
		  (change-instance-flavor address-host (type-of host)))
		address-host)))))
      (net:parse-host hostname (null errorp))))

(defflavor automount-directory
	(dir dev)
	(nfs-error)
  (:initable-instance-variables dir dev)
  (:required-init-keywords :dir :dev))

(defmethod (:report-without-pathname automount-directory) (stream)
  (format stream "~A is an automount directory and can't be directly accessed" dir))

(compile-flavor-methods automount-directory)

(defun-in-flavor (parse-mtab-dir-pathname nfs-access-path-mixin)
		 (mtab-pathname default-pathname)
  (if (string-search-char #\/ mtab-pathname)
      (multiple-value-bind (device directory name type ignore)
	  (send (make-instance 'fs:unix42-pathname :host fs:host)
		:parse-namestring nil mtab-pathname)
	(multiple-value-bind (ignore ignore name type version)
	    (send default-pathname :parse-namestring nil
		  (if (or (null name) (eq name :unspecific))
		      (if (or (null type) (eq type :unspecific))
			  ""
			(string-append "." type))
		    (if (or (null type) (eq type :unspecific))
			name
		      (string-append name "." type))))
	  (as-file (send default-pathname :new-pathname
			 :raw-device device
			 :raw-directory directory
			 :raw-name name
			 :raw-type type
			 :version version))))
    (as-file (fs:parse-pathname mtab-pathname nil default-pathname))))

(defun-in-flavor (parse-mtab-host-qualified-dev-pathname nfs-access-path-mixin)
		 (mtab-pathname hostpart namepart default-pathname &optional errorp)
  (if (string= namepart "(pid" :end1 4)
      (if errorp
	  (error 'automount-directory :dir default-pathname :dev mtab-pathname)
	mtab-pathname)
    (let* ((host (lookup-mtab-host (send default-pathname :host) hostpart errorp)))
      (if host
	  (let* ((host-default-pathname (fs:make-pathname :host host :directory :root))
		 (pathname (parse-mtab-dir-pathname namepart host-default-pathname)))
	    (if (typep host 'fs:lispm-host)
		(parse-mtab-lispm-pathname pathname)
	      pathname))
	mtab-pathname))))

;;; If the mtab pathname can't be parsed, then just return the string, but
;;; don't signal any errors. This is because we want to handle reading an mtab
;;; that refers to hosts that we don't know about. We should only signal an
;;; error when we actually try to access any files on the unknown host.
(defun-in-flavor (parse-mtab-dev-pathname nfs-access-path-mixin)
		 (mtab-pathname default-pathname &optional errorp)
  (condition-case-if (not errorp) (err)
       (let ((colonpos (string-search-char #\: mtab-pathname)))
	 (if colonpos
	     (parse-mtab-host-qualified-dev-pathname
	       mtab-pathname
	       (substring mtab-pathname 0 colonpos)
	       (substring mtab-pathname (1+ colonpos))
	       default-pathname errorp)
	   (parse-mtab-dir-pathname mtab-pathname default-pathname)))
     (fs:pathname-error mtab-pathname)))

;;; Do some checking on a mount entry to verify whether it is well formed.
;;; The checking basically is such that if the truename part of the mount
;;; entry is still a string, then try parsing it one more time, and if that
;;; parse fails, signal an error that explains that we can't mount the
;;; filesystem for the pathname given because the filesystem lies on some
;;; other host that us unknown.
(defun-in-flavor (verify-mount-entry nfs-access-path-mixin)
		 (dir dev entrypoint fhandle fs-plist type)
  (declare (values dir dev entrypoint fh fs-plist type))
  (condition-case (err)
       (or (not (null fhandle))
	   (and (pathnamep dev) (pathnamep entrypoint))
	   (and (listp dev) (listp entrypoint)
		(or (and (loop for dev in dev always (pathnamep dev))
			 (loop for entrypoint in entrypoint always (pathnamep entrypoint)))
		    (loop for unparsed-dev in dev
			  for unparsed-entrypoint in entrypoint
			  for parsed-dev = (parse-mtab-dev-pathname unparsed-dev dir)
			  for parsed-entrypoint =
			      (and (pathnamep parsed-dev)
				   (parse-mtab-dev-pathname unparsed-entrypoint dev))
			  when (pathnamep parsed-entrypoint)
			    collect parsed-dev into good-devs
			    and collect parsed-entrypoint into good-entrypoints
			  finally
			    (when good-devs
			      (fap-add-mount-entry
				self dir
				(setq dev good-devs)
				(setq entrypoint good-entrypoints)
				fhandle fs-plist type))
			    (return t))
		    (progn
		      (setq dev (first dev) entrypoint (first entrypoint))
		      nil)))
	   (fap-add-mount-entry
	     self dir
	     (setq dev (parse-mtab-dev-pathname dev dir t))
	     (setq entrypoint (parse-mtab-dev-pathname entrypoint dev t))
	     fhandle fs-plist type))
     (fs:unknown-pathname-host
       (error 'unknown-nfs-mount-pathname-host
	      :name (send err :name)
	      :mount-pathname-string (if (pathnamep dev) entrypoint dev)
	      :pathname dir)))
  (values dir dev entrypoint fhandle fs-plist type))

;;; The interface for mount calls from other FAPs
(defgeneric fap-mount-filesystem
	    (nfs-access-path-mixin pathname fhandle errorp for-pathname for-operation)
  (declare (values dir-fhandle)))

(defmethod (fap-mount-filesystem nfs-access-path-mixin)
	   (pathname fhandle errorp for-pathname for-operation)
  (declare (values dir-fhandle))
  (multiple-value-bind (dir dev entrypoint fh fs-plist type)
      (fap-lookup-mount-entry self pathname fhandle for-pathname)
    (declare (ignore dir dev entrypoint fs-plist type))
    (or fh (fap-try-mount self pathname fhandle errorp for-pathname for-operation))))

(defun-in-flavor (mount-info-from-mount-entry nfs-access-path-mixin)
		 (dir dev entrypoint fh fhandle fs-plist type for-pathname for-operation)
  (declare (values truename mount-out-dir-truename mount-in-dir-truename
		   dir-truename dir-fhandle fs-plist type))
  (fap-ensure-authentication self)
  (multiple-value-bind (dir dev entrypoint fh fs-plist type)
      (verify-mount-entry dir dev entrypoint fh fs-plist type)
    (cond ((eq fh fhandle)
	   (values
	     (true-pathname-like dir entrypoint for-pathname)
	     dir entrypoint dev fhandle fs-plist type))
	  ((listp dev)
	   ;; Handle multiple choice mounts by using the first mount we can
	   ;; make.
	   (loop for d in dev
		 for e in entrypoint
		 for truename = (true-pathname-like dir e for-pathname)
		 for fh = (condition-case ()
			       (fap-mount-filesystem
				 (nfs-fap truename for-operation)
				 d fhandle t for-pathname for-operation)
			     ((rpc-error sys:network-error fs:file-error)))
		 when fh
		   do (fap-add-mount-entry self dir d e nil nil type)
		   and return (values truename dir e d fh fs-plist type)
		 finally
		   (return
		     (let ((truename
			     (true-pathname-like dir (first entrypoint) for-pathname)))
		       (values truename
			       dir (first entrypoint) (first dev)
			       (fap-mount-filesystem
				 (nfs-fap truename for-operation)
				 (first dev) fhandle t for-pathname for-operation)
			       fs-plist type)))))
	  (t
	   (let ((truename (true-pathname-like dir entrypoint for-pathname)))
	     (values truename dir entrypoint dev
		     (fap-mount-filesystem
		       (nfs-fap truename for-operation)
		       dev fhandle t for-pathname for-operation)
		     fs-plist type))))))

(defun-in-flavor (search-for-mount nfs-access-path-mixin) (pathname operation fhandle)
  (declare (values truename mount-out-dir-truename mount-in-dir-truename
		   dir-truename dir-fhandle fs-plist type))
  ;; Search back from most specific to most general of our current mounts
  ;; to see if there's a mount that we can use already
  (loop with first-pn = (as-file pathname)
	with root-pn = (root-directory-as-file pathname)
	for pn first first-pn then (send pn :directory-pathname-as-file)
	do (multiple-value-bind (dir dev entrypoint fh fs-plist type)
	       (fap-lookup-mount-entry self pn fhandle pathname)
	     (when (and dir dev entrypoint)
	       (return (mount-info-from-mount-entry
			 dir dev entrypoint fh fhandle fs-plist type pathname operation))))
	until (eq pn root-pn)))

(defun-in-flavor (do-a-mount nfs-access-path-mixin) (pathname operation fhandle)
  (declare (values truename mount-out-dir-truename mount-in-dir-truename
		   dir-truename dir-fhandle))
  ;; Assuming there's no mount that we can use already. Try mounts from most
  ;; general to most specific until we are successful.
  (loop with path = (as-dir pathname)
	with host = (send path :host)
	with device = (send path :raw-device)
	with directory = (send path :raw-directory)
	for depth to (if (listp directory) (length directory) 0)
	for pn first (fs:make-pathname
		       :host host
		       :raw-device device
		       :raw-directory :root)
	       then (send pn :new-raw-directory (subseq directory 0 depth))
	for directory-pn = (send pn :directory-pathname-as-file)
	for dir-fhandle = (fap-mount-filesystem
			    self directory-pn fhandle nil pathname operation)
	when (and dir-fhandle (not (errorp dir-fhandle)))
	  return (values pathname
			 directory-pn
			 directory-pn
			 directory-pn
			 dir-fhandle)
	finally (error 'cant-mount-anything
		       :pathname pathname
		       :operation operation
		       :last-error dir-fhandle)))

(defun-in-flavor (get-exports nfs-access-path-mixin) ()
  (let ((old-exports (second exports))
	(new-exports nil))
    (unwind-protect-case ()
	(condition-case (error)
	     (let ((note-progress
		     (or *show-nfs-progress-notes* (tv:show-progress-note :network))))
	       (tv:noting-progress-if note-progress
		   ((format nil "NFS ~:[determining~;checking~] ~A exports"
		   old-exports (send self :host)))
		 (setq new-exports (fap-nfs-exports self))
		 (if (and (listp old-exports)
			  (= (length new-exports) (length old-exports))
			  (every #'string= new-exports old-exports))
		     (setq new-exports old-exports)
		   (loop with defpath = (fs:make-pathname :host fs:host :raw-directory :root)
			 with denominator = (length new-exports)
			 for numerator upfrom 0
			 for entry in new-exports
		      do (when note-progress
			   (tv:note-progress numerator denominator))
			 (let ((pathname (condition-case ()
					      (parse-mtab-dir-pathname entry defpath)
					    ((fs:pathname-error fatal-error zl:ferror)))))
			   (when pathname
			     (fap-add-mount-entry
			       self pathname pathname pathname nil nil :export)))))))
	   (rpc-error
	     (setq new-exports error)))
      (:normal
	(setq exports (list (time:time) new-exports)))
      (:abort
	(setq exports nil)))))

(defparameter *exports-validity-time* (* 5 60 60))

(defun-in-flavor (maybe-get-exports nfs-access-path-mixin) ()
  (when (let ((exports exports))
	  (or (null exports)
	      (not (numberp (first exports)))
	      (time:time-elapsed-p *exports-validity-time* (first exports))))
    (get-exports)))

(defun-in-flavor (get-remote-filesystems nfs-access-path-mixin) ()
  (let ((new-remote-filesystems nil))
    (let ((note-progress (or *show-nfs-progress-notes* (tv:show-progress-note :network))))
      (tv:noting-progress-if note-progress
	  ((format nil "NFS determining ~A remote filesystems" (send self :host)))
	(unwind-protect-case ()
	    (progn 
	      (send fs:host :check-validity)
	      (setq new-remote-filesystems
		    (loop for (indicator value) in (send fs:host :user-property)
			  when (eq indicator :nfs-remote-filesystem)
			    collect (string-trim " " value)))
	      (loop with defpath = (fs:make-pathname :host fs:host :raw-directory :root)
		    with denominator = (length new-remote-filesystems)
		    for numerator upfrom 0
		    for string in new-remote-filesystems
		 do (when note-progress
		      (tv:note-progress numerator denominator))
		    (let* ((index1 (string-search-char #\sp string))
			   (index2 (and index1
					(string-search-not-char #\sp string :start index1)))
			   (dir (and index1
				     (substring string 0 index1)))
			   (dev (and index2
				     (substring string index2)))
			   (pathname (and dir
					  (parse-mtab-dir-pathname dir defpath))))
		      (when (and pathname dev)
			(fap-add-mount-entry
			  self pathname dev dev nil nil :remote-filesystem)))))
	  (:normal 
	    (setq remote-filesystems (list (time:time) new-remote-filesystems)))
	  (:abort
	    (setq remote-filesystems nil)))))))

(defparameter *remote-filesystems-validity-time* (* 5 60 60))

(defun-in-flavor (maybe-get-remote-filesystems nfs-access-path-mixin) ()
  (when (let ((remote-filesystems remote-filesystems))
	  (or (null remote-filesystems)
	      (not (numberp (first remote-filesystems)))
	      (time:time-elapsed-p *remote-filesystems-validity-time*
				   (first remote-filesystems))))
    (get-remote-filesystems)))

(defgeneric fap-mount-checks (nfs-access-path-mixin))

(defmethod (fap-mount-checks nfs-access-path-mixin) ()
  ;; Get the exports for the host if we haven't already.
  (maybe-get-exports)
  ;; Get remote filesystem info for the host if we haven't already.
  (maybe-get-remote-filesystems)
  ;; Unmount old idle mounts
  (fap-unmount-idle-mounts self))

(defgeneric fap-mount-paths (nfs-access-path-mixin))

(defmethod (fap-mount-paths nfs-access-path-mixin) ()
  (loop for entry in
	    (process:with-lock (mount-alist-lock :mode :read)
	      (loop for entry in mount-alist
		    collect (list (mount-entry-dir entry)
				  (mount-entry-dev entry)
				  (mount-entry-entrypoint entry))))
	for (dir dev entrypoint) = entry
	unless (and (pathnamep dev) (pathnamep entrypoint))
	  do (setq dev (parse-mtab-dev-pathname dev dir))
	     (unless (errorp dev)
	       (setq entrypoint (parse-mtab-dev-pathname entrypoint dev))
	       (unless (errorp entrypoint)
		 (fap-add-mount-entry self dir dev entrypoint nil nil nil)
		 (setf (third entry) entrypoint))
	       (setf (second entry) dev))
	unless (or (errorp dev) (errorp entrypoint))
	  collect entry))

(defmethod (fap-mount-paths nfs-access-path-mixin :before) ()
  (fap-mount-checks self))

(defun-in-flavor (retrying-mount-1 nfs-access-path-mixin) (function)
  (declare (sys:downward-funarg function))
  (let ((retry nil))
    (error-restart (error
		     "Retry MOUNT after resetting the file access path for ~A"
		     fs:host)
      (if retry
	  (send self :reset)
	(setf retry t))
      (funcall function))))

(defmacro-in-flavor (retrying-mount nfs-access-path-mixin) (&body body)
  `(retrying-mount-1 #'(lambda () ,@body)))

(defgeneric fap-best-mount-for-pathname-1 (nfs-access-path pathname operation fhandle))

(defmethod (fap-best-mount-for-pathname-1 nfs-access-path-mixin)
	   (pathname operation fhandle)
  (fap-mount-checks self)
  ;; See whether we know where to mount for this pathname
  (multiple-value-bind
    (truename mount-out-dir-truename mount-in-dir-truename dir-truename dir-fhandle)
      (search-for-mount pathname operation fhandle)
    (unless truename
      (tv:noting-progress-if (or *show-nfs-progress-notes* (tv:show-progress-note :network))
	  ((format nil "NFS finding mount for ~A ~((~A)~)"
		   (send pathname :string-for-wholine) operation))
	;; Well that didn't work, now try anything.
	(multiple-value-setq
	  (truename mount-out-dir-truename mount-in-dir-truename dir-truename dir-fhandle)
	  (do-a-mount pathname operation fhandle))))
    (values truename mount-out-dir-truename mount-in-dir-truename
	    dir-truename dir-fhandle)))

(defgeneric fap-best-mount-for-pathname (nfs-access-path-mixin pathname operation fhandle))

(defmethod (fap-best-mount-for-pathname nfs-access-path-mixin)
	   (pathname operation fhandle)
  (declare (values truename mount-out-dir-truename mount-in-dir-truename
		   dir-truename dir-fhandle))
  (if (neq (send pathname :host) fs:host)
      (error 'cant-mount-on-another-host
	     :correct-host fs:host
	     :filesystem pathname
	     :pathname pathname
	     :operation operation)
    (retrying-mount (fap-best-mount-for-pathname-1 self pathname operation fhandle))))

(defgeneric fap-show-nfs-mounts
	    (nfs-access-path-mixin &optional (stream *standard-output*)))

(defmethod (fap-show-nfs-mounts nfs-access-path-mixin)
	   (&optional (stream *standard-output*))
  (let ((dirs nil))
    (fap-map-mount-entries
      self
      #'(lambda (dir dev entrypoint fhandle fs-plist type time)
	  (declare (ignore fhandle fs-plist time))
	  (push (list (as-dir dir)
		      (if (pathnamep dev) (as-dir dev) dev)
		      (if (eq entrypoint dev)
			  ""
			(if (pathnamep entrypoint) (as-dir entrypoint) entrypoint))
		      (or type ""))
		dirs)
	  nil))
    (setq dirs (sort dirs #'fs:pathname-lessp :key #'first))
    (format stream "~&~%NFS Mounts for ~A (~@[a ~A ~]running ~A):~%  "
	    fs:host (send fs:host :machine-type) (send fs:host :system-type))
    (formatting-table (stream)
      (formatting-row (stream)
	(formatting-cell (stream) (princ "dir" stream))
	(formatting-cell (stream) (princ "fs" stream))
	(formatting-cell (stream) (princ "entry" stream))
	(formatting-cell (stream) (princ "type" stream)))
      (loop for (dir dev entrypoint type) in dirs
	    do (formatting-row (stream)
		 (formatting-cell (stream) (princ dir stream))
		 (formatting-cell (stream) (princ dev stream))
		 (formatting-cell (stream) (princ entrypoint stream))
		 (formatting-cell (stream) (princ type stream)))))
    (rpc:authentication-describe (fap-transport-agent self) stream)))

(cp:define-command (com-show-nfs-mounts :command-table "NFS" :name "Show NFS Mounts")
    ((host `((token-or-type nil net:host))))
   (fap-show-nfs-mounts (nfs-access-path-for-host host nil 'show-nfs-status)))

(defgeneric fap-highest-existing-version-number
	    (nfs-access-path pathname dir-fhandle dir-mtime dir-ctime)
  (declare (values highest-version)))

(defmethod (fap-highest-existing-version-number nfs-access-path-mixin)
	   (pathname dir-fhandle dir-mtime dir-ctime)
  (let ((highver 0))
    (let ((directory (send (send pathname :directory-pathname-as-file)
			   :pathname-as-directory))
	  (wild-path (send pathname :new-version :wild)))
      (fap-scan-directory
	(nfs-fap pathname 'fap-highest-existing-version-number)
	dir-fhandle directory directory 
	#'(lambda (truename)
	    (when (and (send wild-path :pathname-match truename)
		       (or (not (send pathname :wild-p))
			   (eq (send pathname :new-version (send truename :version))
			       truename)))
	      (let ((version (send truename :version)))
		(unless (numberp version) (setq version most-positive-fixnum))
		(setq highver (max highver version))))
	    nil)
	dir-mtime dir-ctime))
    highver))

(defgeneric fap-get-newest-version
	    (nfs-access-path pathname dir-fhandle dir-mtime dir-ctime outputp)
  (declare (values pathname)))

(defun-in-flavor (fap-get-newest-version-if-needed nfs-access-path-mixin)
		 (pathname dir-fhandle dir-mtime dir-ctime &optional outputp)
  (declare (values filename truename))
  (let* ((truename (if (or (null (send pathname :version))
			   (eq (send pathname :version) :newest))
		       (fap-get-newest-version
			 self pathname dir-fhandle dir-mtime dir-ctime outputp)
		     pathname))
	 (filename (fap-nfs-filename-string-for-host self truename)))
    (values filename truename)))

(defgeneric fap-mount-point-reset (nfs-access-path))

(defmethod (fap-mount-point-reset nfs-access-path-mixin) ()
  (setq exports nil)
  (setq remote-filesystems nil)
  (dir-fhandle-cache-flush)
  (dir-contents-cache-flush)
  (link-cache-flush)
  (fap-flush-mount-entries self))

(defun-in-flavor (pathname-to-dir-fhandle-and-truename nfs-access-path-mixin)
		 (pathname operation fhandle)
  (declare (values dir-fhandle truename mount-out-dir-truename mount-in-dir-truename
		   dir-mtime dir-ctime))
  (with-mount-point-resetting ('pathname-to-dir-fhandle-and-truename)
    (loop with links-taken = nil
	  with dirpath = (send pathname :directory-pathname-as-file)
	  with truename = dirpath
	  with truename-checked-1 = nil
	  with truename-checked-2 = nil
	  with mount-out-dir-truename = nil
	  with mount-in-dir-truename = nil
	  with dir-truename = nil 
	  with dir-fhandle = nil
	  with dir-mtime = nil
	  with dir-ctime = nil
	  with dir-fap = self
	  unless (send truename :raw-name)
	    do (setf truename (send truename :directory-pathname-as-file))
	  unless dir-truename
	    do (multiple-value-setq
		 (truename mount-out-dir-truename mount-in-dir-truename
			   dir-truename dir-fhandle)
		 (fap-best-mount-for-pathname
		   (nfs-fap truename 'pathname-to-fhandle-and-truename)
		   truename operation fhandle))
	       (setq dir-mtime nil dir-ctime nil)
	       (setq dir-fap (nfs-fap dir-truename 'pathname-to-fhandle-and-truename))
	  when (or (eq truename dir-truename)
		   (and (neq truename truename-checked-1)
			(multiple-value-bind (found-p mtime ctime)
			    (fap-dir-fhandle-cache-lookup dir-fap truename dir-fhandle)
			  (setq truename-checked-1 truename)
			  (when found-p
			    (setq dir-truename truename dir-mtime mtime dir-ctime ctime) t)
			  found-p)))
	    return (values dir-fhandle
			   (true-pathname-like
			     (send dirpath :pathname-as-directory)
			     (send truename :pathname-as-directory)
			     pathname)
			   mount-out-dir-truename
			   mount-in-dir-truename
			   dir-mtime dir-ctime)
	  do (unless (eq truename truename-checked-2)
	       (setq truename-checked-2 truename)
	       (loop for dir first (send truename :directory-pathname-as-file)
			     then (send dir :directory-pathname-as-file)
		     until (or (eq dir dir-truename)
			       (multiple-value-bind (found-p mtime ctime)
				   (fap-dir-fhandle-cache-lookup dir-fap dir dir-fhandle)
				 (when found-p
				   (setq dir-truename dir dir-mtime mtime dir-ctime ctime))
				 found-p))))
	     (multiple-value-setq
	       (truename dir-truename dir-fhandle links-taken dir-mtime dir-ctime)
	       (fap-lookup-dirpart-in-directory
		 dir-fap (send truename :pathname-as-directory)
		 dir-truename dir-fhandle nil links-taken
		 mount-out-dir-truename mount-in-dir-truename
		 dir-mtime dir-ctime)))))

(defflavor rename-across-hosts
	()
	(fs:rename-across-hosts
	 nfs-error))

(defmethod (:report-without-pathname rename-across-hosts) (stream)
  (format stream "You can't rename across hosts."))

(compile-flavor-methods rename-across-hosts)

(defwhopper (fap-rename-internal nfs-access-path-mixin)
	    (old-dir-fhandle old-truename oldname new-dir-fhandle new-truename newname)
  (let ((old-dir-truename (send old-truename :directory-pathname-as-file))
	(new-dir-truename (send new-truename :directory-pathname-as-file)))
    (if (eq old-dir-truename new-dir-truename)
	(updating-dir-caches (old-dir-truename
			       fhandle (adjoin new-truename (remove old-truename contents)))
	  (multiple-value-prog1
	    (continue-whopper
	      old-dir-fhandle old-truename oldname new-dir-fhandle new-truename newname)
	    (dir-fhandle-cache-decache old-truename)
	    (dir-contents-cache-decache old-truename)
	    (dir-fhandle-cache-decache new-truename)
	    (dir-contents-cache-decache new-truename)))
      (updating-dir-caches (old-dir-truename fhandle (remove old-truename contents))
	(updating-dir-caches (new-dir-truename fhandle (adjoin new-truename contents))
	  (multiple-value-prog1
	    (continue-whopper
	      old-dir-fhandle old-truename oldname new-dir-fhandle new-truename newname)
	    (dir-fhandle-cache-decache old-truename)
	    (dir-contents-cache-decache old-truename)
	    (dir-fhandle-cache-decache new-truename)
	    (dir-contents-cache-decache new-truename)))))))

(defmethod (:rename nfs-access-path-mixin) (old-pathname new-pathname)
  (declare (values old-pathname new-pathname))
  (with-nfs-fhandle (fhandle)
    (multiple-value-bind
      (old-dir-fhandle old-truename ignore ignore old-dir-mtime old-dir-ctime)
	(pathname-to-dir-fhandle-and-truename old-pathname :rename fhandle)
      (with-nfs-fhandle (fhandle)
	(multiple-value-bind
	  (new-dir-fhandle new-truename ignore ignore new-dir-mtime new-dir-ctime)
	    (pathname-to-dir-fhandle-and-truename new-pathname :rename fhandle)
	  (multiple-value-bind (oldname old-truename)
	      (fap-get-newest-version-if-needed
		old-truename old-dir-fhandle old-dir-mtime old-dir-ctime)
	    (multiple-value-bind (newname new-truename)
		(fap-get-newest-version-if-needed
		  new-truename new-dir-fhandle new-dir-mtime new-dir-ctime t)
	      (unless (eq (send old-truename :host) (send new-truename :host))
		(error 'rename-across-hosts
		       :pathname old-truename
		       :operation :rename
		       :new-pathname new-truename))
	      (fap-rename-internal
		(nfs-fap old-truename :rename) old-dir-fhandle old-truename oldname
		new-dir-fhandle new-truename newname)
	      (values old-truename new-truename))))))))

(defwhopper (fap-delete-internal nfs-access-path-mixin)
	    (dir-fhandle truename filename)
  (updating-dir-caches ((send truename :directory-pathname-as-file)
			fhandle (remove truename contents))
    (multiple-value-prog1
      (continue-whopper dir-fhandle truename filename)
      (dir-fhandle-cache-decache truename)
      (dir-contents-cache-decache truename))))

(defmethod (:delete nfs-access-path-mixin) (pathname)
  (with-nfs-fhandle (fhandle)
    (multiple-value-bind (dir-fhandle truename ignore ignore dir-mtime dir-ctime)
	(pathname-to-dir-fhandle-and-truename pathname :delete fhandle)
      (multiple-value-bind (filename truename)
	  (fap-get-newest-version-if-needed truename dir-fhandle dir-mtime dir-ctime)
	(fap-delete-internal (nfs-fap truename :delete) dir-fhandle truename filename))))
  t)

(defwhopper (fap-expunge-internal nfs-access-path-mixin)
	    (dir-fhandle truename filename)
  (updating-dir-caches ((send truename :directory-pathname-as-file)
			fhandle (remove truename contents))
    (multiple-value-prog1
      (continue-whopper dir-fhandle truename filename)
      (dir-fhandle-cache-decache truename)
      (dir-contents-cache-decache truename))))

(defmethod (:expunge nfs-access-path-mixin) (pathname &rest ignore)
  (with-nfs-fhandle (fhandle)
    (multiple-value-bind (dir-fhandle truename ignore ignore dir-mtime dir-ctime)
	(pathname-to-dir-fhandle-and-truename pathname :expunge fhandle)
      (multiple-value-bind (filename truename)
	  (fap-get-newest-version-if-needed truename dir-fhandle dir-mtime dir-ctime)
	(fap-expunge-internal (nfs-fap truename :expunge) dir-fhandle truename filename)))))

(defwhopper (fap-create-directory-internal nfs-access-path-mixin)
	    (dir-fhandle truename filename)
  (updating-dir-caches ((send truename :directory-pathname-as-file)
			fhandle (adjoin truename contents))
    (multiple-value-prog1
      (continue-whopper dir-fhandle truename filename)
      (dir-fhandle-cache-decache truename)
      (dir-contents-cache-decache truename))))

(defmethod (:create-directory nfs-access-path-mixin) (pathname &rest options)
  (declare (values pathname)
	   (ignore options))
  (with-nfs-fhandle (fhandle)
    (let* ((dir-path-as-file (send pathname :directory-pathname-as-file)))
      (multiple-value-bind (dir-fhandle truename)
	  (pathname-to-dir-fhandle-and-truename dir-path-as-file :create-directory fhandle)
	(fap-create-directory-internal
	  (nfs-fap truename :create-directory) dir-fhandle truename
	  (fap-nfs-filename-string-for-host self truename))
	(as-dir truename)))))

(defwhopper (fap-create-link-internal nfs-access-path-mixin)
	    (dir-fhandle truename filename linkfrom-path linkto-path)
  (updating-dir-caches ((send truename :directory-pathname-as-file)
			fhandle (adjoin truename contents))
    (multiple-value-prog1
      (continue-whopper dir-fhandle truename filename linkfrom-path linkto-path)
      (dir-fhandle-cache-decache truename)
      (dir-contents-cache-decache truename))))

(defmethod (:create-link nfs-access-path-mixin) (linkfrom-path linkto-path &rest options)
  (declare (values linkfrom-path linkto-path)
	   (ignore options))
  (with-nfs-fhandle (fhandle)
    (multiple-value-bind (dir-fhandle truename ignore ignore dir-mtime dir-ctime)
	(pathname-to-dir-fhandle-and-truename linkfrom-path :create-link fhandle)
      (multiple-value-bind (filename truename)
	  (fap-get-newest-version-if-needed truename dir-fhandle dir-mtime dir-ctime t)
	(fap-create-link-internal
	  (nfs-fap truename :create-link)
	  dir-fhandle truename filename linkfrom-path linkto-path)
	(values truename linkto-path)))))

(defflavor invalid-property-list
	(plist)
	(fs:change-property-failure
	 nfs-error)
  (:initable-instance-variables plist)
  (:required-init-keywords :plist))

(defmethod (:report-without-pathname invalid-property-list) (stream)
  (format stream "~S is not a valid property list." plist))

(compile-flavor-methods invalid-property-list)

(defconstant *changeable-properties*
	     '(:protection
		:author
		:account
		:length-in-bytes
		:creation-date
		:reference-date))

(defflavor unknown-property
	(property)
	(fs:unknown-property
	 nfs-error)
  (:initable-instance-variables property)
  (:required-init-keywords :property))

(defmethod (:report-without-pathname unknown-property) (stream)
  (format stream "~S is not a changeable property.  The changeable properties are~%" property)
  (format stream "~{~#[~1;~<~%~0,70:;and ~>~]~<~%~1,70:;~S~>~^, ~}." *changeable-properties*))

(compile-flavor-methods unknown-property)

(defmethod (fap-change-properties-internal nfs-access-path-mixin :before)
	   (pathname fhandle truename properties)
  (declare (ignore pathname fhandle))
  (unless (and (listp properties)
	       (evenp (length properties))
	       (loop for (ind nil) on properties by #'cddr
		     always (keywordp ind)))
    (error 'invalid-property-list
	   :operation :change-properties
	   :pathname truename
	   :plist properties))
  (loop for (indicator nil) on properties by #'cddr
	unless (member indicator *changeable-properties*)
	  do (error 'unknown-property
		    :operation :change-properties
		    :pathname truename
		    :property indicator)))

(defwhopper (fap-change-properties-internal nfs-access-path-mixin)
	    (pathname fhandle truename properties)
  (updating-dir-caches (truename fhandle contents)
    (continue-whopper pathname fhandle truename properties)))

(defmethod (:change-properties nfs-access-path-mixin) (pathname &rest properties)
  (with-nfs-fhandle (fhandle)
    (multiple-value-bind (fhandle truename)
	(pathname-to-fhandle-and-truename pathname :change-properties t fhandle)
      (fap-change-properties-internal
	(nfs-fap truename :change-properties) pathname fhandle truename properties))))

(defmethod (:properties nfs-access-path-mixin) (pathname)
  (declare (values file-properties))
  (with-nfs-fhandle (fhandle)
    (multiple-value-bind (fhandle truename)
	(pathname-to-fhandle-and-truename pathname :properties t fhandle)
      (fap-properties-internal (nfs-fap truename :properties) pathname fhandle truename))))

(defun-in-flavor (trivial-directory-list nfs-access-path-mixin) (pathname options)
  (with-nfs-fhandle (dir-fhandle)
    (multiple-value-bind (dir-fhandle truename ignore ignore dir-mtime dir-ctime)
	(pathname-to-dir-fhandle-and-truename pathname :properties dir-fhandle)
      (let ((fap (nfs-fap truename :directory-list)))
	(cons (when (null (member :fast options))
		(fap-global-file-properties fap dir-fhandle truename))
	      (condition-case ()
		   (multiple-value-bind (filename truename)
		       (fap-get-newest-version-if-needed
			 truename dir-fhandle dir-mtime dir-ctime)
		     (fap-trivial-directory-list-internal fap dir-fhandle truename filename))
		 (fs:file-not-found)))))))

(defun-in-flavor (cached-scan-directory nfs-access-path-mixin)
		 (contents function)
  (declare (sys:downward-funarg function))
  (loop for pathname in contents
	until (funcall function pathname)))

;;; calls the function on the successive filename's of each entry and
;;; the fhandle of the directory until the function returns non-nil
(defgeneric fap-scan-directory
	    (nfs-access-path-mixin dir-fhandle pathname truename function mtime ctime)
  (declare (sys:downward-funarg function)))

(defflavor nfs-directory-stream-for-wholine
	((length nil)
	 (plist nil)
	 (truename nil)
	 (pointer 0))
	(si:file-data-stream-mixin
	 si:stream)
  (:initable-instance-variables length plist truename pointer)
  (:gettable-instance-variables length plist truename))

(defmethod (:read-pointer nfs-directory-stream-for-wholine) ()
  pointer)

(defmethod (:set-pointer nfs-directory-stream-for-wholine) (new-pointer)
  (setq pointer new-pointer))

(defmethod (:direction nfs-directory-stream-for-wholine) ()
  :input)

(compile-flavor-methods nfs-directory-stream-for-wholine)

(defwhopper (fap-uncached-scan-directory nfs-access-path-mixin)
	    (pathname truename dir-fhandle mtime ctime function)
  (declare (sys:downward-funarg function))
  (with-open-stream (stream (make-instance 'nfs-directory-stream-for-wholine
					   :file-access-path self
					   :translated-pathname truename 
					   :pathname pathname
					   :truename truename))
    (continue-whopper
      pathname truename dir-fhandle mtime ctime
      #'(lambda (pathname)
	  (declare (sys:downward-function))
	  (send stream :set-pointer (1+ (send stream :read-pointer)))
	  (funcall function pathname)))))

(defmethod (fap-scan-directory nfs-access-path-mixin)
	   (dir-fhandle pathname truename function mtime ctime)
  (declare (sys:downward-funarg function))
  (let* ((as-if-empty nil)
	 (as-file (send truename :directory-pathname-as-file))
	 (as-dir (send as-file :pathname-as-directory)))
    (error-restart ((fs:file-error rpc-error)
		    "Proceed as if ~A is an empty directory"
		    as-dir)
      (unless as-if-empty
	(setq as-if-empty t)
	(multiple-value-bind (contents found-p mtime ctime)
	    (dir-contents-cache-lookup as-file mtime ctime)
	  (if found-p
	      (cached-scan-directory contents function)
	    (fap-uncached-scan-directory
	      self pathname truename dir-fhandle mtime ctime function)))))))

(defparameter *parallel-futures-to-use-for-directory-list* 16)

(defun-in-flavor (directory-list-start-futures nfs-access-path-mixin)
		 (dir-fhandle dirlist)
  (loop with fap = nil
	for pair in dirlist
	for pathname = (car pair)
	unless (cdr pair)
	  do (unless fap (setq fap (nfs-fap pathname :directory-list)))
	     (setf (cdr pair)
		   (list :rpc-future
			 (fap-directory-list-start-future fap dir-fhandle pathname)))))

(defun-in-flavor (directory-list-finish-futures nfs-access-path-mixin)
		 (dir-fhandle dirlist)
  (loop with fap = nil
	for element in dirlist
	for pathname = (car element)
	when (eq (second element) :rpc-future)
	  do (unless fap (setq fap (nfs-fap pathname :directory-list)))
	     (let ((as-if-it-doesnt-exist nil))
	       (error-restart ((fs:file-error rpc-error)
			       "Proceed as if ~A doesn't exist"
			       pathname)
		 (cond (as-if-it-doesnt-exist
			(fap-directory-list-abort-future
			  self
			  (prog1 (third element) (setf (cdr element) nil))))
		       (t
			(setq as-if-it-doesnt-exist t)
			(setf (cdr element)
			      (condition-case ()
				   (fap-directory-list-finish-future
				     fap dir-fhandle pathname (third element))
				 (fs:file-not-found)))
			;; If it's a directory, make sure the pathname is
			;; that of a directory.
			(when (getf (cdr element) :directory)
			  (condition-case ()
			       (setf (car element)
				     (send (send (car element) :pathname-as-directory)
					   :directory-pathname-as-file))
			     ((fs:pathname-error zl:ferror sys:fatal-error))))))))))

(defun-in-flavor (directory-list-abort-futures nfs-access-path-mixin)
		 (dirlist)
  (loop for element in dirlist
	when (eq (second element) :rpc-future)
	  do (fap-directory-list-abort-future
	       self (prog1 (third element) (setf (cdr element) nil)))))

(defun-in-flavor (directory-list-fill-in-properties-internal nfs-access-path-mixin)
		 (dir-fhandle dirlist)
  (unwind-protect-case ()
      (progn
	;; First pass, start up all the futures.
	(directory-list-start-futures dir-fhandle dirlist)
	;; Second pass, convert all the futures into plists by finishing them
	(directory-list-finish-futures dir-fhandle dirlist))
    (:abort
      (directory-list-abort-futures dirlist))))

(defun-in-flavor (directory-list-fill-in-properties nfs-access-path-mixin)
		 (dir-fhandle dirlist)
  (when dirlist
    (let ((dirlist-length (length dirlist))
	  (dir (send (send (car (first dirlist)) :directory-pathname-as-file)
		     :pathname-as-directory)))
      (with-open-stream (stream (make-instance 'nfs-directory-stream-for-wholine
					       :file-access-path self
					       :translated-pathname dir
					       :pathname dir
					       :truename dir
					       :length dirlist-length))
	(loop with flimit = *parallel-futures-to-use-for-directory-list* 
	      for i below dirlist-length by flimit
	      do (send stream :set-pointer i)
		 (directory-list-fill-in-properties-internal
		   dir-fhandle
		   (subseq dirlist i (min (+ i flimit) dirlist-length))))))))

(defun-in-flavor (multiple-file-plists-dir-alist-entry nfs-access-path-mixin)
		 (pathname dpaf)
  (let ((as-if-it-doesnt-exist nil))
    (error-restart ((fs:file-error rpc-error) "Proceed as if ~A doesn't exist" dpaf)
      (cond (as-if-it-doesnt-exist
	     (list dpaf nil nil nil nil nil nil))
	    (t
	     (setq as-if-it-doesnt-exist t)
	     (condition-case ()
		  (multiple-value-bind (dir-fhandle index-hint)
		      (allocate-resource 'nfs-fhandle)
		    (unwind-protect-case ()
			(multiple-value-bind (dir-fhandle truename ignore ignore
					      dir-mtime dir-ctime)
			    (pathname-to-dir-fhandle-and-truename
			      pathname :multiple-file-plists dir-fhandle)
			  (list dpaf (send truename :directory-pathname-as-file)
				dir-fhandle dir-mtime dir-ctime index-hint
				(nfs-fap truename :multiple-file-plists)))
		      (:abort
			(deallocate-resource 'nfs-fhandle dir-fhandle index-hint))))
		((fs:directory-not-found cant-mount-anything)
		 (list dpaf nil nil nil nil nil nil))))))))

(defun-in-flavor (multiple-file-plists-start-futures nfs-access-path-mixin)
		 (dir-info result)
  (loop for pair in result
	for (truename nil dir-fhandle nil nil nil fap) in dir-info
	unless (or (cdr pair) (null dir-fhandle))
	  do (setf (cdr pair)
		   (list :rpc-future
			 (fap-directory-list-start-future fap dir-fhandle truename)))))

(defun-in-flavor (multiple-file-plists-finish-futures nfs-access-path-mixin)
		 (dir-info result)
  (loop for (truename nil dir-fhandle nil nil nil fap) in dir-info
	for element in result
	when (eq (second element) :rpc-future)
	  do (let ((as-if-it-doesnt-exist nil))
	       (error-restart ((fs:file-error rpc-error)
			       "Proceed as if ~A doesn't exist"
			       truename)
		 (cond (as-if-it-doesnt-exist
			(fap-directory-list-abort-future
			  self
			  (prog1 (third element) (setf (cdr element) nil))))
		       (t
			(setq as-if-it-doesnt-exist t)
			(setf (cdr element)
			      (condition-case ()
				   (fap-directory-list-finish-future
				     fap dir-fhandle truename (third element))
				 (fs:file-not-found)))
			;; I don't know why other file protocols do this, but
			;; because they do I guess we should too.
			(when (getf (cdr element) :link-to)
			  (setf (cdr element) nil))
			;; Add the truename
			(when (cdr element)
			  (setf (cdr element)
				(list* :truename truename
				       (cdr element))))))))))

(defun-in-flavor (multiple-file-plists-abort-futures nfs-access-path-mixin)
		 (dir-info result)
  (loop for (nil nil nil nil nil nil fap) in dir-info
	for element in result
	when (eq (second element) :rpc-future)
	  do (fap-directory-list-abort-future
	       fap (prog1 (third element) (setf (cdr element) nil)))))

(defmethod (:multiple-file-plists nfs-access-path-mixin) (files &rest ignore)
  (let ((dir-alist nil)
	(length (length files))
	(dir-info nil)
	(result nil))
    (unwind-protect 
	(progn
	  ;; Gather the directory info
	  (loop for pathname in files
		for dpaf = (send pathname :directory-pathname-as-file)
		for info = (cdr (or (assoc dpaf dir-alist)
				    (car (push (multiple-file-plists-dir-alist-entry
						 pathname dpaf)
					       dir-alist))))
		for (dtaf dir-fhandle dir-mtime dir-ctime nil nil) = info
		for truename = (and dir-fhandle
				    (multiple-value-bind (ignore truename)
					(fap-get-newest-version-if-needed
					  (true-pathname-like dpaf dtaf pathname)
					  dir-fhandle dir-mtime dir-ctime)
				      truename))
		do (push (cons truename info) dir-info))
	  ;; Contruct the result list
	  (loop for file in files
		do (push (cons file nil) result))
	  ;; Now get the file properties
	  (loop with flimit = *parallel-futures-to-use-for-directory-list* 
		for i below length by flimit
		for this-dir-alist-batch = (subseq dir-info i (min (+ i flimit) length))
		for this-result-batch = (subseq result i (min (+ i flimit) length))
		do (unwind-protect-case ()
		       (progn
			 ;; First pass, start up all the futures.
			 (multiple-file-plists-start-futures
			   this-dir-alist-batch this-result-batch)
			 ;; Second pass, convert all the futures into plists
			 ;; by finishing them.
			 (multiple-file-plists-finish-futures
			   this-dir-alist-batch this-result-batch))
		     (:abort
		       (multiple-file-plists-abort-futures
			 this-dir-alist-batch this-result-batch)))))
      (loop for (nil nil dir-fhandle nil nil index-hint nil) in dir-alist
	    when dir-fhandle
	    do (deallocate-resource 'nfs-fhandle dir-fhandle index-hint)))
    result))

(defparameter *try-truncate-on-access-error* t)

(defparameter *warn-when-trying-truncate-on-access-error* t)

(defflavor trying-truncate-on-access-error
	(format-string format-args)
	(condition)
  (:initable-instance-variables format-string format-args)
  (:required-init-keywords :format-string :format-args))

(defmethod (dbg:report trying-truncate-on-access-error) (stream)
  (apply #'format stream format-string format-args))

(compile-flavor-methods trying-truncate-on-access-error)

(defun-in-flavor (with-truncate-retrying-internal nfs-access-path-mixin)
		 (if-exists pathname direction byte-size fhandle dir-fhandle fattr
			    dir-mtime dir-ctime function)
  (declare (sys:downward-funarg function))
  (let ((truncate nil))
    (block with-truncate-retrying
      (tagbody 
	normal 
	   (return-from with-truncate-retrying
	     (error-restart ((fs:access-error)
			     "Retry ~A with ~S ~S" 'open :if-exists :truncate)
	       (if truncate (go retry) (setq truncate t))
	       (condition-case-if *try-truncate-on-access-error* (error)
		    (funcall function)
		  (fs:access-error
		    (when *warn-when-trying-truncate-on-access-error*
		      (warn 'trying-truncate-on-access-error
			    "~A of ~A failed with ~S ~S:~%    ~~A~~%Retrying ~A with ~S ~S."
			    'open pathname :if-exists if-exists error
			    'open :if-exists :truncate))
		    (go retry)))))
	retry
	   (return-from with-truncate-retrying
	     (letf ((inhibit-output-access-checking t))
	       (fap-if-exists-on-open
		 self :truncate pathname direction byte-size
		 fhandle dir-fhandle fattr dir-mtime dir-ctime)))))))

(defmacro-in-flavor (with-truncate-retrying nfs-access-path-mixin)
		    ((if-exists pathname direction byte-size fhandle dir-fhandle fattr
				dir-mtime dir-ctime)
		     &body body)
  `(with-truncate-retrying-internal
     ,if-exists ,pathname ,direction ,byte-size ,fhandle ,dir-fhandle ,fattr
     ,dir-mtime ,dir-ctime
     #'(lambda () ,@body)))

(zwei:defindentation (with-truncate-retrying 0 4 1 1))

(defflavor file-write-protected	(options) (fs:access-error nfs-error)
  :initable-instance-variables)

(defmethod (:report-without-pathname file-write-protected) (stream)
  (format stream "The file is write protected."))

(defmethod (dbg:proceed file-write-protected :continue) ()
  :no-action)

(defmethod (dbg:document-proceed-type file-write-protected :continue) (stream)
  (format stream "Proceed with ~A of ~A~@[ with~{ ~S~}~] anyway."
	  (send self :operation) (send self :pathname) options))

(compile-flavor-methods file-write-protected)

(defun-in-flavor (check-access-for-output nfs-access-path-mixin)
		 (pathname fhandle fattr if-exists)
  (declare (dbg:error-reporter))
  (unless (or inhibit-output-access-checking
	      (fap-check-access-for-output-internal self pathname fhandle fattr))
    (signal-proceed-case (() 'file-write-protected
			  :pathname pathname
			  :operation 'open
			  :options (list :if-exists if-exists))
      (:continue))))

(defun-in-flavor (plist-length-in-bytes nfs-access-path-mixin) (plist byte-size)
  (declare (values length-in-bytes))
  (let ((plist-length-in-bytes (getf plist :length-in-bytes))
	(plist-byte-size (getf plist :byte-size)))
    (if (numberp plist-length-in-bytes)
	(if (numberp plist-byte-size)
	    (floor (* plist-length-in-bytes plist-byte-size) byte-size)
	  plist-length-in-bytes)
      nil)))
						
;;; Methods for handling :if-exists cases for open

(defgeneric fap-if-exists-on-open
	    (nfs-access-path if-exists
			     pathname direction byte-size fhandle dir-fhandle fattr
			     dir-mtime dir-ctime)
  "Handle :if-exists cases for OPENs"
  (:method-combination :case))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :new-version)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :new-version)
  (with-truncate-retrying
       (:new-version pathname direction byte-size fhandle dir-fhandle fattr
		     dir-mtime dir-ctime)
    (let ((pathname 
	    (if (numberp (send pathname :version))
		(send pathname :new-version (1+ (send pathname :version)))
	      (multiple-value-bind (ignore truename)
		  (fap-get-newest-version-if-needed
		    (send pathname :new-version :newest) dir-fhandle dir-mtime dir-ctime t)
		truename))))
      (multiple-value-bind (output-temp-pathname fhandle plist)
	  (fap-create-output-temp self pathname dir-fhandle fhandle nil fattr)
	(values fhandle pathname nil 0 :new-version output-temp-pathname plist)))))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :rename)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :rename)
  (with-truncate-retrying
       (:rename pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
    (multiple-value-bind (output-temp-pathname fhandle plist)
	(fap-create-output-temp self pathname dir-fhandle fhandle nil fattr)
      (values fhandle pathname nil 0 :rename output-temp-pathname plist))))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :rename-and-delete)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :rename-and-delete)
  (with-truncate-retrying
       (:rename-and-delete pathname direction byte-size fhandle dir-fhandle fattr
			   dir-mtime dir-ctime)
    (multiple-value-bind (output-temp-pathname fhandle plist)
	(fap-create-output-temp self pathname dir-fhandle fhandle nil fattr)
      (values fhandle pathname nil 0 :rename-and-delete output-temp-pathname plist))))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :overwrite)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (ignore dir-fhandle direction dir-mtime dir-ctime)
	   (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :overwrite)
  (let ((plist (cdr (fap-fattr-etc-to-property-list self fattr pathname pathname fhandle))))
    (values fhandle pathname (plist-length-in-bytes plist byte-size) 0 :overwrite nil plist)))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :truncate)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (ignore dir-fhandle byte-size direction dir-mtime dir-ctime)
	   (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :truncate)
  (fap-truncate-file self fhandle pathname)
  (values fhandle pathname nil 0 :truncate nil
	  (cdr (fap-fattr-etc-to-property-list self fattr pathname pathname fhandle))))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :append)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (ignore dir-fhandle direction dir-mtime dir-ctime)
	   (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :append)
  (let ((plist (cdr (fap-fattr-etc-to-property-list self fattr pathname pathname fhandle))))
    (values fhandle pathname nil (plist-length-in-bytes plist byte-size) :append nil plist)))

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :supersede)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (check-access-for-output pathname fhandle fattr :supersede)
  (with-truncate-retrying
       (:supersede pathname direction byte-size fhandle dir-fhandle fattr
		   dir-mtime dir-ctime)
    (multiple-value-bind (output-temp-pathname fhandle plist)
	(fap-create-output-temp self pathname dir-fhandle fhandle nil fattr)
      (values fhandle pathname nil 0 :supersede output-temp-pathname plist))))

(defflavor nfs-eexist () (fs:file-already-exists nfs-error))

(defmethod (:report-without-pathname nfs-eexist) (stream)
  (write-string "File exists" stream))

(compile-flavor-methods nfs-eexist)

(defmethod (fap-if-exists-on-open nfs-access-path-mixin :error)
	   (pathname direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (ignore direction byte-size fhandle dir-fhandle fattr dir-mtime dir-ctime))
  (error 'nfs-eexist :pathname pathname :operation  :open))
  
(defun-in-flavor (handle-exists-on-open nfs-access-path-mixin)
		 (unversioned-pathname pathname direction byte-size if-exists
				       error fhandle dir-fhandle fattr dir-mtime dir-ctime)
  (declare (ignore unversioned-pathname)
	   (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (if (not (member direction '(:output :io)))
      (let ((plist (cdr (fap-fattr-etc-to-property-list
			  self fattr pathname pathname fhandle))))
	(values fhandle pathname (plist-length-in-bytes plist byte-size) 0 :exists nil plist))
    (if if-exists
	(fap-if-exists-on-open self if-exists
			       pathname direction byte-size fhandle dir-fhandle fattr
			       dir-mtime dir-ctime)
      (if (and (member direction '(nil :probe)) (null error))
	  (error 'nfs-eexist :pathname pathname :operation :open)
	nil))))

;;; Methods for handling :if-does-not-exist at open

(defgeneric fap-pathname-for-creation (host pathname unversioned-pathname))

(defwhopper (fap-create-file nfs-access-path-mixin)
	    (dir-fhandle pathname fhandle &optional mode)
  (updating-dir-caches ((send pathname :directory-pathname-as-file)
			fhandle (adjoin pathname contents))
    (multiple-value-prog1
      (continue-whopper dir-fhandle pathname fhandle mode)
      (dir-fhandle-cache-decache pathname)
      (dir-contents-cache-decache pathname))))

(defgeneric fap-if-does-not-exist-on-open
	    (nfs-access-path if-does-not-exist
			     dir-fhandle unversioned-pathname pathname direction
			     byte-size fhandle)
  "Handle :if-soes-not-exist cases for OPENs"
  (:method-combination :case))

(defmethod (fap-if-does-not-exist-on-open nfs-access-path-mixin :create)
	   (dir-fhandle unversioned-pathname pathname direction byte-size fhandle)
  (declare (ignore direction byte-size))
  (let ((pathname (fap-pathname-for-creation self pathname unversioned-pathname)))
    (multiple-value-bind (pathname fhandle plist)
	(fap-create-file self dir-fhandle pathname fhandle)
      (values fhandle pathname nil 0 :create nil plist))))

(defflavor nfs-enoent () (fs:file-not-found nfs-error))

(defmethod (:report-without-pathname nfs-enoent) (stream)
  (write-string "No such file or directory" stream))

(compile-flavor-methods nfs-enoent)

(defmethod (fap-if-does-not-exist-on-open nfs-access-path-mixin :error)
	   (dir-fhandle unversioned-pathname pathname direction byte-size fhandle)
  (declare (ignore dir-fhandle unversioned-pathname direction byte-size fhandle))
  (error 'nfs-enoent :pathname pathname :operation :open))

(defun-in-flavor (handle-does-not-exist-on-open nfs-access-path-mixin) 
		 (dir-fhandle unversioned-pathname pathname direction byte-size
			      if-does-not-exist error fhandle)
  (declare (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  (if if-does-not-exist
      (fap-if-does-not-exist-on-open
	self if-does-not-exist
	dir-fhandle unversioned-pathname pathname direction byte-size fhandle)
    (if (and (member direction '(nil :probe)) (null error))
	(error 'nfs-enoent :pathname pathname :operation :open)
      nil)))

(defflavor nfs-circular-link
	(links-taken)
	(fs:circular-link nfs-error)
  (:initable-instance-variables links-taken)
  (:required-init-keywords :links-taken))

(defmethod (:report-without-pathname nfs-circular-link) (stream)
  (format stream "Too many links"))

(defmethod (dbg:report nfs-circular-link :after) (stream)
  (format stream "The links followed:")
  (loop for (pathname link link-pathname link-to) in links-taken
	do (format stream "~%  ~~A  ~A~@[~%  (really ~A  ~A)~]~"
		   pathname link link-pathname link-to)))

(compile-flavor-methods nfs-circular-link)

(defparameter *maximum-link-depth-allowed* 8)

(defun-in-flavor (check-link-count nfs-access-path-mixin) (links-taken pathname operation)
  (declare (dbg:error-reporter))
  (when ( (length links-taken) *maximum-link-depth-allowed*)
    (error 'nfs-circular-link
	   :pathname pathname
	   :operation operation
	   :links-taken links-taken)))

(defun-in-flavor (handle-link-on-open nfs-access-path-mixin)
		 (dir-fhandle unversioned-pathname pathname direction byte-size
			      if-exists if-does-not-exist
			      error fhandle fattr links-taken 
			      mount-out-dir-truename mount-in-dir-truename)
  (declare (ignore unversioned-pathname)
	   (values fhandle truename length buffer-pointer open-mode
		   output-temp-pathname plist))
  ;; Make sure we're not in a loop of links.
  (check-link-count links-taken pathname 'handle-link-on-open)
  (multiple-value-bind (link-to merged-link-to)
      (fap-read-link-with-caching
	self fhandle pathname
	(true-pathname-like
	  mount-in-dir-truename mount-out-dir-truename
	  pathname)
	fattr)
    (let ((links-taken (cons (list pathname link-to nil nil) links-taken)))
      (multiple-value-bind (dir-fhandle truename ignore ignore dir-mtime dir-ctime)
	  (pathname-to-dir-fhandle-and-truename merged-link-to :open dir-fhandle)
	(fap-fhandle-etc-for-open
	  (nfs-fap truename :open) dir-fhandle truename direction byte-size
	  if-exists if-does-not-exist error fhandle links-taken
	  mount-out-dir-truename mount-in-dir-truename dir-mtime dir-ctime)))))

(defmethod (fs:file-access-path-open nfs-access-path-mixin)
	   (translated-pathname
	     pathname
	     &key
	     element-type
	     direction
	     preserve-dates
	     if-exists
	     if-does-not-exist
	     fake-characters
	     direct
	     error
	     raw
	     &allow-other-keys)
  (declare (values stream binary))  
  (fs:check-stream-element-type element-type :protocol "NFS")
  (let* ((characters (if (eq element-type :default)
			 (file-characters-p translated-pathname direction)
			 (subtypep element-type 'character)))
	 (byte-size-from-element-type (fs:byte-size-from-element-type element-type))
	 (byte-size (if (eq byte-size-from-element-type :default)
			(file-byte-size translated-pathname characters)
		      byte-size-from-element-type))
	 (fake-characters (and characters fake-characters))
	 (binary (or (not characters) fake-characters)))
    (with-nfs-fhandle (dir-fhandle)
      (multiple-value-bind
	(dir-fhandle truename mount-out-dir-truename mount-in-dir-truename
	 dir-mtime dir-ctime)
	  (pathname-to-dir-fhandle-and-truename translated-pathname :open dir-fhandle)
	(with-nfs-fhandle (fhandle)
	  (multiple-value-bind
	    (fhandle truename length buffer-pointer open-mode output-temp-pathname plist)
	      (fap-fhandle-etc-for-open
		(nfs-fap truename :open) dir-fhandle truename direction byte-size
		if-exists if-does-not-exist error fhandle nil
		mount-out-dir-truename mount-in-dir-truename dir-mtime dir-ctime)
	    (fap-file-access-path-open-internal
	      (nfs-fap truename :open) fhandle dir-fhandle
	      pathname truename direction characters binary byte-size
	      preserve-dates raw direct fake-characters
	      plist buffer-pointer length open-mode output-temp-pathname)))))))

(defparameter *default-transfer-size* 512)

;;; Customers with 36xx machines occasionally complain about extremely
;;; slow or hung NFS transfers.  This happens especially but not
;;; exclusively on G-machines (which have small or few packet buffers).
;;; It is felt that this might be due to the machine getting swamped by
;;; large NFS UDP packets.  Decreasing these parameters has improved NFS
;;; performace for these customers.
(defparameter *local-network-transfer-size* #-3600 4096 #+3600 2048)
(defparameter *local-subnet-transfer-size* #-3600 8192 #+3600 2048)

(defun-in-flavor (host-on-local-network-p nfs-access-path-mixin) ()
  (loop with inet = (neti:local-network-of-type :internet)
	with local = (tcp::official-internet-subnet-number
		       (second (assoc inet (send net:*local-host* :network-addresses))))
	for (network address) in (send fs:host :network-addresses)
	thereis (and (eq network inet)
		     (= local (tcp::official-internet-subnet-number address)))))
			 
(defun-in-flavor (host-on-local-subnet-p nfs-access-path-mixin) ()
  (loop with inet = (neti:local-network-of-type :internet)
	with local = (tcp:internet-subnet-number
		       (second (assoc inet (send net:*local-host* :network-addresses))))
	for (network address) in (send fs:host :network-addresses)
	thereis (and (eq network inet)
		     (= local (tcp:internet-subnet-number address)))))

(defun-in-flavor (transfer-size nfs-access-path-mixin) ()
  (let ((transfer-size-string (send fs:host :user-get :nfs-transfer-size)))
    (cond (transfer-size-string (values (parse-integer transfer-size-string :junk-allowed t)))
	  ((host-on-local-subnet-p) *local-subnet-transfer-size*)
	  ((host-on-local-network-p) *local-network-transfer-size*)
	  (t *default-transfer-size*))))

(defun-in-flavor (directory-probe nfs-access-path-mixin)
		 (pathname dir-fhandle)
  (declare (values dir-fhandle truename mtime ctime))
  (let ((as-if-it-doesnt-exist nil)
	(pathname (send pathname :translated-pathname)))
    (error-restart ((fs:file-error rpc-error)
		    "Proceed as if ~A doesn't exist"
		    (send pathname :directory-pathname-as-file))
      (unless as-if-it-doesnt-exist
	(setq as-if-it-doesnt-exist t)
	(condition-case ()
	     (multiple-value-bind (dir-fhandle truename ignore ignore mtime ctime)
		 (pathname-to-dir-fhandle-and-truename
		   pathname 'directory-probe dir-fhandle)
	       (values dir-fhandle truename mtime ctime))
	   ((fs:directory-not-found fs:wrong-kind-of-file)))))))

(defun-in-flavor (all-directories-scan nfs-access-path-mixin)
		 (pathname before during after)
  (with-nfs-fhandle (dir-fhandle)
    (let ((dirpath (send pathname :new-raw-directory (or before :root))))
      (multiple-value-bind (dir-fhandle path-as-dir mtime ctime)
	  (directory-probe dirpath dir-fhandle)
	(when path-as-dir
	  (let* ((wild-dir (and path-as-dir (send path-as-dir :down-directory-level during)))
		 (wild-path (send wild-dir :directory-pathname-as-file))
		 (answer nil))
	    (fap-scan-directory
	      (nfs-fap path-as-dir :all-directories) dir-fhandle dirpath path-as-dir
	      #'(lambda (truename)
		  (when (send wild-path :pathname-match truename)
		    (push (ncons truename) answer))
		  nil)
	      mtime ctime)
	    ;; Answer contains all pathnames that match the name.  Now collect
	    ;; those names that are directories.
	    (directory-list-fill-in-properties dir-fhandle answer)
	    (loop for pair in answer
		  for (thispath . plist) = pair
		  when (or (getf plist :directory)
			   (and (getf plist :link-to) (neq (first after) :wild-inferiors)))
		    collect
		      (let* ((thispath-as-dir (send thispath :pathname-as-directory))
			     (thisdirlist-or-root (send thispath-as-dir :raw-directory))
			     (thisdirlist
			       (if (eq thisdirlist-or-root :root) nil thisdirlist-or-root))
			     (newdirlist (append thisdirlist after))
			     (newpath (send thispath-as-dir :new-raw-directory newdirlist)))
			(list newpath thisdirlist)))))))))

(defun-in-flavor (all-directories-expand nfs-access-path-mixin) (pathname spec)
  (declare (values expanded-directories directories-yet-to-be-expanded))
  (destructuring-bind (wildpath dirlist) spec
    (let ((expanded-directories nil)
	  (directories-yet-to-be-expanded nil))
      (loop with directory-or-root = (send wildpath :raw-directory)
	    with directory = (if (eq directory-or-root :root) nil directory-or-root)
	    for dirpart = (pop directory)
	    for dirlistpart = (pop dirlist)
	    when (and (null dirlistpart) (eq dirpart :wild-inferiors))
	      do (push :wild-inferiors directory)
		 (setq directories-yet-to-be-expanded
		       (nconc directories-yet-to-be-expanded
			      (all-directories-scan
				pathname unwild-dirparts :wild directory)))
		 (setf dirpart nil)
	    until (null dirpart)
	    when (and (null dirlistpart)
		      (or (eq dirpart :wild)
			  (and (stringp dirpart)
			       (string-search-char #\* dirpart))))
	      do (setq directories-yet-to-be-expanded
		       (nconc directories-yet-to-be-expanded
			      (all-directories-scan
				pathname unwild-dirparts dirpart directory)))
	      and return nil
	    collect dirpart into unwild-dirparts
	    finally
	      (let* ((raw-dir (or unwild-dirparts :root))
		     (exp-dir (send pathname :new-raw-directory raw-dir)))
		(with-nfs-fhandle (dir-fhandle)
		  (multiple-value-bind (dir-fhandle truedir mtime ctime)
		      (directory-probe exp-dir dir-fhandle)
		    (declare (ignore dir-fhandle mtime ctime))
		    (when truedir (push truedir expanded-directories))))))
      (values expanded-directories directories-yet-to-be-expanded))))

(defun-in-flavor (all-directories-seed nfs-access-path-mixin) (pathname dir-fhandle)
  (declare (values dir-fhandle truename seed mtime ctime))
  (let* ((dir (send pathname :raw-directory))
	 (dir (if (eq dir :root) nil dir))
	 (dir (if (eq dir :wild) '(:wild-inferiors) dir))
	 (pathname (fs:make-pathname
		     :host (send pathname :host)
		     :raw-device (send pathname :raw-device)
		     :raw-directory dir))
	 (unwild-part (loop for patpart in dir
			    until (or (eq patpart :wild-inferiors)
				      (eq patpart :wild)
				      (and (stringp patpart)
					   (string-search-char #\* patpart)))
			    collect patpart))
	 (wild-part (nthcdr (length unwild-part) dir))
	 (unwild-dir (send pathname :new-raw-directory (or unwild-part :root))))
    (multiple-value-bind
      (dir-fhandle truename mount-out-dir-truename mount-in-dir-truename mtime ctime)
	(pathname-to-dir-fhandle-and-truename unwild-dir :all-directories dir-fhandle)
      (declare (ignore mount-out-dir-truename mount-in-dir-truename))
      (let* ((truedir (send truename :raw-directory))
	     (truedir-list (if (eq truedir :root) nil truedir))
	     (seeddir-list (append truedir-list wild-part))
	     (seeddir (send truename :new-raw-directory (or seeddir-list :root))))
	(values dir-fhandle truename (list (list seeddir nil)) mtime ctime)))))

(defmethod (:all-directories nfs-access-path-mixin) (pathname options)
  (let ((note-progress (or *show-nfs-progress-notes* (tv:show-progress-note :network))))
    (tv:noting-progress-if note-progress
	((format nil "NFS All directories ~A" (send pathname :string-for-wholine)))
      (with-nfs-fhandle (fhandle)
	(multiple-value-bind (fhandle truename seed mtime ctime)
	    (all-directories-seed pathname fhandle)      
	  (declare (ignore fhandle mtime ctime))
	  (loop with expanded-directories = nil
		with directories-yet-to-be-expanded = seed
		until (null directories-yet-to-be-expanded)
		for directory = (pop directories-yet-to-be-expanded)
	     when note-progress
	       do (tv:note-progress (length expanded-directories)
				    (+ (length expanded-directories)
				       (length directories-yet-to-be-expanded)))
	     do (multiple-value-bind (expanded yet-to-be)
		    (all-directories-expand truename directory)
		  (setf expanded-directories (nconc expanded expanded-directories))
		  (setf directories-yet-to-be-expanded
			(nconc yet-to-be directories-yet-to-be-expanded)))
	     finally
	       (return
		 (if (member ':sorted options)
		     (sort expanded-directories #'fs:pathname-lessp :key #'first)
		     expanded-directories))))))))

;;; Directory list

(defun-in-flavor (directory-list-hack-newestp nfs-access-path-mixin) (dirlist)
  ;; First sort the dirlist
  (setf dirlist (sort dirlist #'fs:pathname-lessp :key #'first))
  ;; Then loop over it only collecting the newest version of files.
  (loop with highver-entry = nil
	for highver-pathname = (car highver-entry)
	for entry = (pop dirlist)
	for pathname = (car entry)
	when (and highver-entry
		  (or (null pathname)
		      (neq (send highver-pathname :new-version (send pathname :version))
			   pathname)))
	  collect (prog1 highver-entry (setq highver-entry nil))
	if (null highver-entry)
	  do (setq highver-entry entry)
	else
	  when (and pathname
		    (let ((pathname-version (send pathname :version))
			  (highver-version (send highver-pathname :version)))
		      (or (not (numberp pathname-version))
			  (and (numberp highver-version)
			       (< highver-version pathname-version)))))
	    do (setq highver-entry entry)
	until (null pathname)))

(defun-in-flavor (directory-list-scan nfs-access-path-mixin)
		 (dir-fhandle directory pattern fastp mtime ctime)
  (let* ((newestp (eq (send pattern :version) :newest))
	 (wild-path (if newestp (send pattern :new-version :wild) pattern))
	 (answer nil))
    (fap-scan-directory
      (nfs-fap pattern :directory-list) dir-fhandle directory directory
      #'(lambda (truename)
	  (when (send wild-path :pathname-match truename)
	    (push (ncons truename) answer))
	  nil)
      mtime ctime)
    (when newestp (setf answer (directory-list-hack-newestp answer)))
    (unless fastp
      (directory-list-fill-in-properties dir-fhandle answer)
      ;; Splice out any entries with null plists, since that means we're
      ;; supposed to pretend that they don't exist.
      (loop for pair in answer
	    for (pathname . plist) = pair 
	    initially (progn pathname)
	    when (null plist) do (setq answer (delete pair answer))))
    answer))

(defun-in-flavor (directory-list-from-expanded-directories nfs-access-path-mixin)
		 (expanded-directories pathname options)
  (with-nfs-fhandle (dir-fhandle)
    (loop with fastp = (member :fast options)
	  for directory in expanded-directories
	  nconcing
	    (multiple-value-bind (dir-fhandle truename ignore ignore mtime ctime)
		(pathname-to-dir-fhandle-and-truename directory :directory-list dir-fhandle)
	      (directory-list-scan
		dir-fhandle truename
		(fs:merge-pathnames
		  truename pathname
		  (send truename :valid-version (send pathname :version))
		  (send truename :valid-vc-version (send pathname :vc-version)))
		fastp mtime ctime)))))

(defmethod (:directory-list nfs-access-path-mixin) (pathname options)
  (if (member :sorted options)
      (let ((dirlist (send self :directory-list pathname (remove :sorted options))))
	(setf (cdr dirlist) (sort (cdr dirlist) #'fs:pathname-lessp :key #'first))
	dirlist)
    (if (send pathname :wild-p)
	(with-nfs-fhandle (dir-fhandle)
	  (multiple-value-bind (dir-fhandle truename seed mtime ctime)
	      (all-directories-seed pathname dir-fhandle)
	    (declare (ignore mtime ctime))
	    (cons (when (null (member :fast options))
		    (fap-global-file-properties
		      (nfs-fap truename :directory-list) dir-fhandle truename))
		  (when truename
		    (let ((expanded-directories nil)
			  (note-progress (or *show-nfs-progress-notes*
					     (tv:show-progress-note :network))))
		      (tv:noting-progress-if note-progress
			  ((format nil "NFS All directories ~A"
				   (send pathname :string-for-wholine)))
			(loop with directories-yet-to-be-expanded = seed
			      until (null directories-yet-to-be-expanded)
			      for directory = (pop directories-yet-to-be-expanded)
			   do (multiple-value-bind (expanded yet-to-be)
				  (all-directories-expand truename directory)
				(setf expanded-directories
				      (nconc expanded expanded-directories))
				(setf directories-yet-to-be-expanded
				      (nconc yet-to-be directories-yet-to-be-expanded)))))
		      (directory-list-from-expanded-directories
			expanded-directories pathname options))))))
      (trivial-directory-list pathname options))))

;;; Completion stuff.  In general it's conservative in that it uses string=
;;; in a lot of places instead of string-equal.  This means that it will work
;;; best on UNIX pathnames, but will indicate that completion fails more than
;;; it should on lisp machine pathnames. Hopefully, nobody will ever notice.

(defun-in-flavor (filter-candidates nfs-access-path-mixin) (string candidates message)
  (when (stringp string)
    (loop for (candidate) in candidates
	  for component = (send candidate message)
	  when (string= component string)
	    collect (ncons candidate))))

(defun-in-flavor (gather-completions nfs-access-path-mixin) (component candidates message)
  (delete-duplicates
    (loop with string = (if (stringp component) component "") 
	  for len = (string-length string)
	  for (candidate) in candidates
	  for candidate-component = (send candidate message)
	  when (if (stringp candidate-component)
		   (and ( (string-length candidate-component) len)
			(string= (substring candidate-component 0 len) string))
		 (eq component candidate-component))
	    collect candidate-component)
    :test #'(lambda (x y) (or (eq x y) (and (stringp x) (stringp y) (string= x y))))))

(defun-in-flavor (complete-component-from-candidates nfs-access-path-mixin)
		 (component candidates message)
  (declare (values string goodp))
  (let ((completions (gather-completions component candidates message)))
    (cond ((null completions)
	   (values component nil))
	  ((= (length completions) 1)
	   (values (car completions) t))
	  ((and (not (stringp component)) (member component completions))
	   (values component nil))
	  (t
	   (loop with len = (string-length (car completions))
		 with goodp = t
		 with so-far = (car completions)
		 for completion in completions
		 when (< (string-length completion) len)
		   do (setf goodp nil)
		      (setf len (string-length completion))
		      (setf so-far (substring so-far 0 len))
		 unless (string= (substring completion 0 len) so-far)
		   do (setf goodp nil)
		      (setf len (let ((s1 completion)
				      (s2 so-far))
				  (declare (sys:array-register s1 s2))
				  (loop for i below len
					until (not (char= (aref s1 i) (aref s2 i)))
					finally (return i))))
		      (setf so-far (substring so-far 0 len))
		 finally (return (values so-far goodp)))))))

(defun-in-flavor (completion-exact-match-from-candidates nfs-access-path-mixin)
		 (pathname candidates)
  (loop for (candidate) in candidates
	when (and (string= (send pathname :raw-name) (send candidate :raw-name))
		  (string= (send pathname :raw-type) (send candidate :raw-type))
		  (or (eql (send candidate :version) (send pathname :version))
		      (member (send pathname :version) '(nil :newest :unspecific))))
	  return candidate))

(defun-in-flavor (completion-check-if-its-a-directory nfs-access-path-mixin)
		 (pathname candidates)
  (declare (values pathname dirp))
  (let ((dirp nil)
	(truename (completion-exact-match-from-candidates pathname candidates)))
    (when truename 
      (condition-case (err)
	   (when (getf (cdr (send self :properties truename)) :directory)
	     ;; Hack to remove ".directory" so if we're completing a
	     ;; string in a subdirectory of a lisp machine filesystem
	     ;; mounted on a unix host
	     (when (and (typep pathname 'fs:unix-family-pathname-mixin)
			(member (send pathname :type) '("directory" "dir")
				:test #'string-equal))
	       (setf pathname (send pathname :new-raw-type :unspecific)))
	     (setf pathname (send pathname :pathname-as-directory))
	     (setf dirp t))
	 ((rpc-error fs:file-error fs:pathname-error))))
    (values pathname dirp)))

(defun-in-flavor (output-mode-completion-from-candidates nfs-access-path-mixin)
		 (pathname candidates default)
  (let ((name (send pathname :raw-name))
	(type (send pathname :raw-type))
	(version (send pathname :version))
	(goodp t)
	(dirp nil))
    (when (and (not (null name))
	       (not (eq name :unspecific))
	       (or (null type) (eq type :unspecific))
	       (or (null version) (eq version :unspecific) (eq version :newest)))
      (multiple-value-setq (name goodp)
	(complete-component-from-candidates name candidates :raw-name)))
    (when (and goodp
	       (not (null name))
	       (not (eq name :unspecific))
	       (not (null type))
	       (not (eq type :unspecific))
	       (or (null version) (eq version :unspecific) (eq version :newest)))
      (multiple-value-setq (type goodp)
	(complete-component-from-candidates
	  type (filter-candidates name candidates :raw-name) :raw-type)))
    (when (and (or (null name) (eq name :unspecific))
	       (not (null (send default :raw-name))))
      (setf name (send default :raw-name)))
    (when (and (or (null type) (eq type :unspecific) (equal type ""))
	       (not (null (send default :raw-type))))
      (setf type (send default :raw-type)))
    (setf pathname (send pathname :new-pathname :raw-name name :raw-type type))
    ;; The pathname may be a directory
    (multiple-value-setq (pathname dirp)
      (completion-check-if-its-a-directory pathname candidates))
    (values (send pathname :string-for-host)
	    (and (null dirp) (if (assoc pathname candidates) :old :new)))))

(defun-in-flavor (new-ok-mode-completion-from-candidates nfs-access-path-mixin)
		 (pathname candidates default)
  (let ((name (send pathname :raw-name))
	(type (send pathname :raw-type))
	(version (send pathname :version))
	(goodp t)
	(dirp nil))
    (when (and (not (null name))
	       (not (eq name :unspecific))
	       (or (null type) (eq type :unspecific))
	       (or (null version) (eq version :unspecific) (eq version :newest)))
      (multiple-value-setq (name goodp)
	(complete-component-from-candidates name candidates :raw-name)))
    (when (and goodp
	       (not (null name))
	       (not (eq name :unspecific))
	       (not (null type))
	       (not (eq type :unspecific))
	       (or (null version) (eq version :unspecific) (eq version :newest)))
      (multiple-value-setq (type goodp)
	(complete-component-from-candidates
	  type (filter-candidates name candidates :raw-name) :raw-type)))
    (when (and (or (null name) (eq name :unspecific))
	       (not (null (send default :raw-name))))
      (if (loop for (pathname) in candidates
		thereis (string= (send default :raw-name) (send pathname :raw-name)))
	  (setf name (send default :raw-name))
	(when candidates
	  (loop for last-pathname first (caar candidates) then pathname
		for (pathname) in candidates
		unless (string= (send last-pathname :raw-name) (send pathname :raw-name))
		  return (setf name (send default :raw-name))
		finally (setf name (send last-pathname :raw-name))))))		
    (when (and (or (null type) (eq type :unspecific) (equal type ""))
	       (not (null (send default :raw-type))))
      (loop with default-p = nil
	    with multiple-types-p = nil
	    with name-pathname = nil
	    for (pathname) in candidates
	    when (and (string= name (send pathname :raw-name))
		      (eq type :unspecific)
		      (eq (send pathname :type) :unspecific))
	      return :unspecific
	    when (and (string= name (send pathname :raw-name))
		      (string= (send default :raw-type) (send pathname :raw-type)))
	      do (setf default-p t)
	    when (string= name (send pathname :raw-name))
	      do (if (or (null name-pathname)
			 (string= (send name-pathname :raw-type) (send pathname :raw-type)))
		     (setf name-pathname pathname)
		   (setf multiple-types-p t))
	    finally (if default-p 
			(setf type (send default :raw-type))
		      (if (and (null multiple-types-p)
			       (not (null name-pathname)))
			  (setf type (send name-pathname :raw-type))
			(setf type (send default :raw-type))))))
    (setf pathname (send pathname :new-pathname :raw-name name :raw-type type))
    ;; The pathname may be a directory
    (multiple-value-setq (pathname dirp)
      (completion-check-if-its-a-directory pathname candidates))
    (values (send pathname :string-for-host)
	    (and (not dirp) (if (assoc pathname candidates) :old :new)))))

(defun-in-flavor (input-mode-completion-from-candidates nfs-access-path-mixin)
		 (pathname candidates default)
  (let ((name (send pathname :raw-name))
	(type (send pathname :raw-type))
	(version (send pathname :version))
	(goodp t)
	(dirp nil))
    (when (and (or (null type) (eq type :unspecific))
	       (or (null version) (eq version :unspecific) (eq version :newest)))
      (cond ((and (not (null name)) (not (eq name :unspecific)))
	     (multiple-value-setq (name goodp)
	       (complete-component-from-candidates name candidates :raw-name)))
	    ((eq (send default :raw-name) :wild)
	     (setf name (send default :raw-name)))))
    (when (and goodp
	       (not (null name))
	       (not (eq name :unspecific))
	       (or (null version) (eq version :unspecific) (eq version :newest))
	       (not (progn (multiple-value-setq (pathname dirp)
			     (completion-check-if-its-a-directory
			       (send pathname :new-raw-name name) candidates))
			   dirp)))
      (multiple-value-setq (type goodp)
	(complete-component-from-candidates
	  type
	  (filter-candidates name candidates :raw-name)
	  :raw-type)))
    (cond ((or goodp
	       (and name (neq name :unspecific))
	       (null (send default :raw-name))))
	  ((loop for (pathname) in candidates
		 thereis (string= (send default :raw-name) (send pathname :raw-name)))
	   (setf name (send default :raw-name)))
	  (t
	   (when candidates
	     (loop for last-pathname first (caar candidates) then pathname
		   for (pathname) in candidates
		   unless (string= (send last-pathname :raw-name) (send pathname :raw-name))
		     return (setf goodp nil)
		   finally (setf name (send last-pathname :raw-name))))))
    (cond ((or goodp
	       (and type (neq type :unspecific) (not (equal type "")))
	       (null (send default :raw-type))))
	  ((eq (send default :raw-type) :wild)
	   (setf type (send default :raw-type))
	   (setf goodp t))
	  (t
	   (loop with default-p = nil
		 with multiple-types-p = nil
		 with name-pathname = nil
		 for (pathname) in candidates
		 when (and (string= name (send pathname :raw-name))
			   (eq type :unspecific)
			   (eq (send pathname :type) :unspecific))
		   return :unspecific
		 when (and (string= name (send pathname :raw-name))
			   (string= (send default :raw-type) (send pathname :raw-type)))
		   do (setf default-p t)
		 when (string= name (send pathname :raw-name))
		   do (if (or (null name-pathname)
			      (string= (send name-pathname :raw-type)
				       (send pathname :raw-type)))
			  (setf name-pathname pathname)
			(setf multiple-types-p t))
		 finally (if default-p 
			     (setf type (send default :raw-type) goodp t)
			   (if (and (null multiple-types-p)
				    (not (null name-pathname)))
			       (setf type (send name-pathname :raw-type))
			     (setf goodp nil))))))
    (unless dirp
      (setf pathname (send pathname :new-pathname :raw-name name :raw-type type))
      ;; The pathname may be a directory
      (when goodp
	(multiple-value-setq (pathname dirp)
	  (completion-check-if-its-a-directory pathname candidates))))
    (values (send pathname :string-for-host) (and (not dirp) goodp :old))))

(defmethod (complete-from-candidates nfs-access-path-mixin)
	   (pathname candidates default direction new-ok)
  (cond ((eq direction :output)
	 (output-mode-completion-from-candidates pathname candidates default))
	(new-ok
	 (new-ok-mode-completion-from-candidates pathname candidates default))
	(t
	 (input-mode-completion-from-candidates pathname candidates default))))

(defmethod (:complete-string nfs-access-path-mixin) (default string options)
  (condition-case ()
       (let* ((direction :input)
	      (new-ok nil)
	      (parse (fs:parse-pathname string nil default))
	      (merged (send parse :merge-pathnames default
			    (send parse :version)
			    (send parse :vc-version)))
	      (merged-directories
		(send parse :new-raw-directory (send merged :raw-directory)))
	      (dirpath (fs:make-pathname
			 :host (send merged :host)
			 :raw-device (send merged :raw-device)
			 :raw-directory (send merged :raw-directory)
			 :name :wild
			 :type :wild
			 :version :wild)))
	 ;; Set the string to be now the string with merged directories. That way
	 ;; If we lose later, at least we have merged the directories.
	 (setf string (send merged-directories :string-for-host))
	 ;; Parse the options
	 (loop for option in options
	       do (case option
		    ((:deleted))
		    ((:read :in) (setf direction :input))
		    ((:print :out :write) (setf direction :output))
		    ((:old) (setf new-ok nil))
		    ((:new-ok) (setf new-ok t))
		    (otherwise (error "~S is not a recognized completion option" option))))
	 (complete-from-candidates
	   self
	   merged-directories
	   (cdr (send self :directory-list dirpath '(:fast)))
	   default
	   direction
	   new-ok))
     ((fs:file-operation-failure fs:pathname-error)
      (values string nil))))

(defmethod (:update-homedir nfs-access-path-mixin) (ignore)
  (setf fs:homedir-pathname
	(as-dir
	  (fs:parse-pathname
	    (username->homedir (fap-unix-name-lookup-access-path self)
			       (send self :host-user-id))
	    fs:host (send fs:host :sample-pathname)))))

(defgeneric fap-delete-excess-versions (nfs-access-path pathname count))

(defmethod (fap-delete-excess-versions nfs-access-path-mixin) (pathname count)
  (when (numberp (send pathname :version))
    (let* ((sorted-list
	     (sort (cdr (send self :directory-list
			      (send pathname :new-version :wild) '(:fast)))
		   #'>
		   :key #'(lambda (entry)
			    (let* ((pathname (first entry))
				   (version (send pathname :version)))
			      (or (and (numberp version) version)
				  most-positive-fixnum)))))
	   (complete-list (delete-duplicates (cons pathname sorted-list) :from-end t))
	   (delete-list (nthcdr (max 0 count) complete-list)))
      (when delete-list
	(error-restart (error "Retry DELETE of ~A" (caar delete-list))
	  (loop while delete-list
		for path = (caar delete-list)
		do (condition-case ()
			(send self :delete path)
		      ((fs:file-not-found fs:access-error)))
		   (pop delete-list)))))))

(defmethod (:reset nfs-access-path-mixin) ()
  (fap-mount-point-reset self)
  (when transport-agent
    (authentication-reset transport-agent)
    (udp-agent-note-dependent transport-agent self t)
    (setq transport-agent nil))
  (setq unix-name-lookup-access-path nil))

;;; Random stuff

(defflavor no-nfs-access-path
	(host (error nil))
	(nfs-error)
  (:default-init-plist :protocol-name :nfs)
  (:initable-instance-variables host error)
  (:required-init-keywords :host))

(defmethod (:report-without-pathname no-nfs-access-path) (stream)
  (format stream "No NFS access path can be made to host ~A." host)
  (when error
    (format stream "~&The error signalled was:~%    ~~A~" error)))

(compile-flavor-methods no-nfs-access-path)

(defgeneric nfs-access-path-available-for-host-p (host))

(defmethod (nfs-access-path-available-for-host-p fs:active-pathname-host) ()
  (or (loop for fap in fs:file-access-paths
	    when (typep fap 'nfs-access-path-mixin)
	      return t)
      (loop for sap in (net:find-paths-to-service-on-host :file self t)
	    when (eq (neti:protocol-name (neti:service-access-path-protocol sap)) :nfs)
	      return t)
      (not (null (condition-case ()
		      (neti:find-paths-for-medium-to-host
			:udp (neti:find-protocol-named :nfs :file) self)
		    (sys:network-error nil))))))

(defgeneric nfs-access-path-for-host (host pathname operation))

(defmethod (nfs-access-path-for-host fs:active-pathname-host) (pathname operation)
  (condition-case-if nil (err)
       (or (loop for fap in fs:file-access-paths
		 when (typep fap 'nfs-access-path-mixin) thereis fap)
	   (first
	     (last 
	       (setq fs:file-access-paths
		     (nconc fs:file-access-paths
			    (list (neti:invoke-service-access-path
				    (neti:make-service-access-path 
				      neti:service :file
				      neti:host self
				      neti:protocol (neti:find-protocol-named :nfs :file)
				      neti:medium
				      (first (neti:find-paths-for-medium-to-host
					       :udp
					       (neti:find-protocol-named :nfs :file)
					       self))
				      neti:desirability 1)
				    (list pathname operation))))))))
     ((sys:network-error rpc-error nfs-error)
      (error 'no-nfs-access-path
	     :host self
	     :error err
	     :pathname pathname
	     :operation operation))))

(defun use-nfs (host)
  (setq host (si:parse-host host))
  (send host :file-reset t)
  (nfs-access-path-for-host host nil :use-nfs))

