;;; -*- Mode: LISP; Syntax: Common-lisp; Package: RPC; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; This is UNIX-NAME-LOOKUP.LISP. UNL for short.
						
;;; This file implements a Genera user end of the UNIX equivalent of many of
;;; the NAMESPACE services.  It provides for per-host mappings of usernames to
;;; UNIX uids, groupnames to gids, the inverse mappings, and assorted other
;;; mappings.  It is used for RPC authentication and for NFS.

;;; The way UNIX machines look up names follows the history of UNIX
;;; development.  For example, the way a user name is translated to a UNIX uid
;;; is by first consulting the /etc/passwd file on the local machine.  If an
;;; entry is found in the /etc/passwd file for the user named "+" before an
;;; entry was found for the user name being looked up, the Yellow Pages are
;;; then used to look up the user name.

;;; This file is an attempt to emulate the hierarchy of databases is by
;;; providing a hierarchy of database search for each lookup.  The hierarchy
;;; is listed here in the order of lookup:

;;; FILE         (/etc/passwd, /etc/group, /etc/hosts ...)
;;; YELLOW-PAGES Sun's Yellow Pages
;;; NAMESPACE    mapping for sites that don't run Yellow Pages and don't 
;;;              have readable files can be put on namespace objects
;;; DEFAULT      uses special variables

;;; This hierarchy is implemented by a having a mixin for each database, and
;;; by making some of the lookup methods combine with OR method combination.
;;; The order of the hierarchy is then determined by the order of the mixins
;;; in the flavor object being used for the lookup.

;;; The goal of the procedures in this file is to return the same data that a
;;; lookup on the UNIX would return.  In practice, this may be impossible.

;;; For example, to look up a user name, UNIX machines first look in the file
;;; /etc/passwd.  This may not be possible to emulate from the network, as the
;;; file may not be accessible to network file access - the root directory of
;;; the machine may not be exported for NFS mounting.  In this case, the
;;; Yellow Pages will be consulted without first checking the /etc/passwd
;;; file.  If there was an entry in the /etc/passwd file that shadowed the
;;; yellow pages then lookup on the UNIX box would have returned a different
;;; value than that on the Lispm.

;;; The lookup procedures defined in this file are designed so that they be
;;; called recursively.  This is done by skipping a particular database if it
;;; is currently being accessed for the same operation.  

;;; For example, consider the problem of determining the uid of the currently
;;; logged in user.  The first database to be searched is the file database,
;;; but in order to read a file, NFS must know some uid to use for
;;; authentication, so it will also do a lookup to determine the uid of the
;;; currently logged in user.  This lookup will skip the file lookup process
;;; and continue on to the Yellow Pages database.  The Yellow Paes may return
;;; some uid, NFS used to read the files, and the FILE database lookup will
;;; finally return some uid.

;;; Here are the procedures that should be used to perform the UNIX-name-lookup
;;; operations.

;;; Getting a UNIX-name-lookup access path

(defgeneric host-unix-name-lookup-access-path
	    (host)
  (declare (values unix-name-lookup-access-path))
  "Returns the UNIX-name-lookup access path for the host.")

;;; The passwd database.

(defgeneric username->passwd (unix-name-lookup-access-path username)
  "Returns the decoded passwd entry for the given username."
  (declare (values passwd defauled-p))
  (:method-combination :or))

(defgeneric username->password (unix-name-lookup-access-path username)
  "Returns the encrypted password for the given username."
  (declare (values password defaulted-p)))

(defgeneric username->uid (unix-name-lookup-access-path username)
  "Returns the UNIX uid for the given username."
  (declare (values uid defaulted-p)))

(defgeneric username->gid (unix-name-lookup-access-path username)
  "Returns the UNIX gid (as if from the \"passwd\" file) for the given username."
  (declare (values gid defaulted-p)))

(defgeneric username->gecos (unix-name-lookup-access-path username)
  "Returns the gecos entry for the given username."
  (declare (values gecos defaulted-p)))

(defgeneric username->homedir (unix-name-lookup-access-path username)
  "Returns the home directory (as a string) for the given username."
  (declare (values homedir defaulted-p)))

(defgeneric username->shell  (unix-name-lookup-access-path username)
  "Returns the shell for the given username."
  (declare (values shell defaulted-p)))

(defgeneric uid->passwd (unix-name-lookup-access-path uid)
  "Returns the decoded passwd entry for the given uid."
  (declare (values passwd defaulted-p))
  (:method-combination :or))

(defgeneric uid->username (unix-name-lookup-access-path uid)
  "Returns the username for the given UNIX uid."
  (declare (values username defaulted-p)))

;;; The group database.

(defgeneric groupname->group (unix-name-lookup-access-path groupname)
  "Returns the decoded group entry for the given username."
  (declare (values group defaulted-p))
  (:method-combination :or))

(defgeneric groupname->gid (unix-name-lookup-access-path groupname)
  "Returns the UNIX gid for the given groupname."
  (declare (values gid defaulted-p)))

(defgeneric groupname->password (unix-name-lookup-access-path groupname)
  "Returns the encrypted password for the given groupname."
  (declare (values password defaulted-p)))

(defgeneric groupname->usernames (unix-name-lookup-access-path groupname)
  "Returns the usernames for the given groupname."
  (declare (values usernames defaulted-p)))

(defgeneric gid->group (unix-name-lookup-access-path gid)
  "Returns the decoded group entry for the given gid."
  (declare (values group defaulted-p))
  (:method-combination :or))

(defgeneric gid->groupname (unix-name-lookup-access-path gid)
  "Returns the groupname for the given UNIX gid."
  (declare (values groupname defaulted-p))
  (:method-combination :or))

(defgeneric username->gids (unix-name-lookup-access-path username)
  "Returns the UNIX gids (as if from the \"group\" file) for the given username."
  (declare (values (gids defaulted-p)))
  (:method-combination :or))

;;; The hosts database

(defgeneric hostname->host (unix-name-lookup-access-path hostname)
  "Returns the parsed host entry for the given hostname."
  (declare (values host defaulted-p))
  (:method-combination :or))

(defgeneric hostname->address (unix-name-lookup-access-path hostname)
  "Returns the primary IP address for the given hostname."
  (declare (values address defaulted-p)))

(defgeneric address->host (unix-name-lookup-access-path address)
  "Returns the parsed host entry for the given IP address."
  (declare (values host defaulted-p))
  (:method-combination :or))

(defgeneric address->hostname (unix-name-lookup-access-path address)
  "Returns the hostname for the given IP address."
  (declare (values hostname defaulted-p)))

;;; The base flavor.

(defflavor unix-name-lookup-access-path-mixin
	(host
	 (dependents nil))
	()
  (:required-methods
   username->passwd
   uid->passwd
   groupname->group
   gid->group
   hostname->host
   address->host)
  (:initable-instance-variables host)
  (:readable-instance-variables host)
  (:conc-name unix-name-lookup-access-path-)
  (:required-init-keywords :host)
  :abstract-flavor)

(defgeneric unix-name-lookup-access-path-note-dependent
	    (unix-name-lookup-access-path dependent &optional delete-p)
  )

(defmethod (unix-name-lookup-access-path-note-dependent unix-name-lookup-access-path-mixin)
	   (dependent &optional delete-p)
  (if delete-p
      (setq dependents (delete dependent dependents))
    (pushnew dependent dependents)))

(defgeneric dependent-note-unix-name-lookup-access-path-reset
	    (unix-name-lookup-access-path-dependent unix-name-lookup-access-path)
  )

(defmethod (:reset unix-name-lookup-access-path-mixin :after) ()
  (loop for dependent in dependents
	do (dependent-note-unix-name-lookup-access-path-reset dependent self)))

(defgeneric unix-name-lookup-access-path-report
	    (unix-name-lookup-access-path stream format)
  (:method-combination :progn)
  )

(defmethod (unix-name-lookup-access-path-report unix-name-lookup-access-path-mixin)
	   (stream format)
  (ecase format
    (:brief (princ host stream))
      ))

(defmethod (sys:print-self unix-name-lookup-access-path-mixin)
	   (stream print-depth slashify-p)
  (if slashify-p
      (sys:printing-random-object (self stream :typep)
	(sys:print-self self stream print-depth nil))
    (unix-name-lookup-access-path-report self stream :brief)))

(defmacro-in-flavor (with-recursion-prevented unix-name-lookup-access-path-mixin)
		    ((operation) &body body)
  `(locally
     (declare (special ,operation))
     (unless (and (variable-boundp ,operation) (member self ,operation))
       (with-stack-list* (,operation self (and (variable-boundp ,operation) ,operation))
	 (let ((,operation ,operation))
	   (declare (special ,operation))
	   ,@body)))))

(zwei:defindentation (with-recursion-prevented 0 4 1 1))

(defparameter *default-username* "nobody" "The default username for UNIX name lookups.")
(defparameter *default-password* "" "The default password for UNIX name lookups.")
(defparameter *default-uid* -2 "The default uid for UNIX name lookups.")
(defparameter *default-gid* -2 "The default gid for UNIX name lookups.")
(defparameter *default-shell* "/bin/csh" "The default shell for UNIX name lookups.")
(defparameter *default-home-directory-parent* "/usr"
  "The default parent directory for home directories in UNIX name lookups.")

(defun-in-flavor (make-passwd unix-name-lookup-access-path-mixin)
		 (&key username password uid gid gecos home-directory shell)
  (let* ((username
	   (or username
	       (and uid (format nil "uid#~D" uid))
	       *default-username*))
	 (password
	   (or password
	       *default-password*))
	 (uid
	   (or uid
	       (and (> (string-length username) 4)
		    (string= username "uid#" :end1 4)
		    (parse-integer username :start 4 :junk-allowed t))
	       *default-uid*))
	 (gid
	   (or gid
	       *default-gid*))
	 (gecos
	   (or gecos
	       username))
	 (home-directory
	   (or home-directory
	       (string-append *default-home-directory-parent* "/" username)))
	 (shell
	   (or shell
	       *default-shell*)))
    (list username password uid gid gecos home-directory shell)))

(defparameter *default-groupname* "unknown" "The default groupname for UNIX name lookups.")
(defparameter *default-usernames* nil "The default usernames for UNIX name lookups.")

(defun-in-flavor (make-group unix-name-lookup-access-path-mixin)
		 (&key groupname password gid usernames)
  (let* ((groupname
	   (or groupname
	       (and gid (format nil "gid#~D" gid))
	       *default-groupname*))
	 (password
	   (or password
	       *default-password*))
	 (gid
	   (or gid
	       (and (> (string-length groupname) 4)
		    (string= groupname "gid#" :end1 4)
		    (parse-integer groupname :start 4 :junk-allowed t))
	       *default-gid*))
	 (usernames
	   (or usernames
	       *default-usernames*)))
    (list groupname password gid usernames)))

(defun-in-flavor (make-gids unix-name-lookup-access-path-mixin)
		 (&key gids)
  gids)

(defun-in-flavor (make-host unix-name-lookup-access-path-mixin)
		 (&key address hostnames)
  (cons address hostnames))

(defun-in-flavor (decode-passwd-line unix-name-lookup-access-path-mixin)
		 (line)
  (unless (zerop (string-length line))
    (let ((decoded-line
	    (loop for start first 0 then (1+ end)
		  for end = (string-search-char #\: line :start start)
		  collect (substring line start end)
		  while end)))
      (when (and (= (length decoded-line) 7)
		 (setf (third decoded-line)
		       (parse-integer (third decoded-line) :junk-allowed t))
		 (setf (fourth decoded-line)
		       (parse-integer (fourth decoded-line) :junk-allowed t)))
	decoded-line))))

(defun-in-flavor (decode-group-line unix-name-lookup-access-path-mixin)
		 (line)
  (unless (zerop (string-length line))
    (let ((decoded-line
	    (loop for start first 0 then (1+ end)
		  for end = (string-search-char #\: line :start start)
		  collect (substring line start end)
		  while end)))
      (when (= (length decoded-line) 3)
	(setq decoded-line (nconc decoded-line (list ""))))
      (when (= (length decoded-line) 4)
	(setf (fourth decoded-line)
	      (loop with usernames = (fourth decoded-line)
		    for start first 0 then (1+ end)
		    for end = (string-search-char #\, usernames :start start)
		    for username = (substring usernames start end)
		    unless (zerop (string-length username))
		      collect username
		    while end))
	(when (setf (third decoded-line) (parse-integer (third decoded-line) :junk-allowed t))
	  decoded-line)))))

(defun-in-flavor (decode-hosts-line unix-name-lookup-access-path-mixin)
		 (line)
  (unless (zerop (string-length line))
    (let ((decoded-line
	    (loop with whitespace = '(#\space #\tab #.(code-char (char-to-ascii #\tab)))
		  for start first 0 then (string-search-not-set whitespace line :start end)
		  while start
		  until (char= (aref line start) #\#)
		  for end = (string-search-set whitespace line :start start)
		  collect (substring line start end)
		  while end)))
      (when (and (> (length line) 1)
		 (setf (first decoded-line)
		       (condition-case ()
			    (neti:parse-internet-address (first decoded-line))
			  (error nil))))
	decoded-line))))

(defun-in-flavor (get-host-prop-string unix-name-lookup-access-path-mixin)
		 (host keyword default-value)
  (let ((host-string (send host :user-get keyword)))
    (if (stringp host-string)
	host-string
      (let* ((site (send host :site))
	     (site-string (and (typep site 'neti:site) (send site :user-get keyword))))
	(if (stringp site-string)
	    site-string
	  (loop for namespace in (append (and (typep site 'neti:site)
					      (ncons (send site :local-namespace)))
					 (send host :namespaces))
		for namespace-string = (send namespace :user-get keyword)
		when (stringp namespace-string)
		  return namespace-string
		finally (return default-value)))))))

(defun-in-flavor (get-host-prop-boolean unix-name-lookup-access-path-mixin)
		 (host keyword default-value)
  (let ((string (get-host-prop-string host keyword (if default-value "YES" "NO"))))
    (or (zerop (string-length string))
	(not (char-equal (aref string 0) #\N)))))

(defun-in-flavor (update-entry-in-table unix-name-lookup-access-path-mixin)
		 (new-entry key table timeout)
  (when key
    (let ((old-entry (gethash key table)))
      (if (and old-entry (first old-entry))
	  (when (time:time-elapsed-p timeout (second old-entry) (second new-entry))
	    (if (first new-entry)
		(setf (gethash key table) new-entry)
	      (setf (gethash key table) (list (first old-entry) (second new-entry)))))
	(setf (gethash key table) new-entry)))))

(defgeneric group-database-needs-rebuilding (unix-name-lookup-access-path)
  (:method-combination :or))

(defgeneric group-database (unix-name-lookup-access-path)
  (:method-combination :append))

(defgeneric group-database-rebuild (unix-name-lookup-access-path new-database)
  (:method-combination :progn))

(defun-in-flavor (group-database-check unix-name-lookup-access-path-mixin)
		 ()
  (when (group-database-needs-rebuilding self)
    (group-database-rebuild self (group-database self))))

(defun-in-flavor (group-database-username-gids unix-name-lookup-access-path-mixin)
		 (group-database function)
  (declare (downward-funarg function))
  (loop with username-gids-hash-table = (make-hash-table :test #'string= :locking nil)
	for (groupname password gid usernames) in group-database
	initially (progn password groupname)
	do (loop for username in usernames
		 do (setf (gethash username username-gids-hash-table)
			  (nconc (gethash username username-gids-hash-table) (ncons gid))))
	finally
	  (loop for gids being the hash-elements of username-gids-hash-table
			 with-key username
		do (funcall function username :gids (list (delete-duplicates gids))))))

(defwhopper (username->passwd unix-name-lookup-access-path-mixin) (username)
  (let ((username (string-downcase (string-thin username))))
    (multiple-value-bind (passwd defaulted-p)
	(continue-whopper username)
      (if (and defaulted-p (> (string-length username) 8))
	  (multiple-value-bind (passwd1 defaulted-p1)
	      (continue-whopper (substring username 0 8))
	    (if defaulted-p1
		(values passwd defaulted-p)
	      (values passwd1 defaulted-p1)))
	(values passwd defaulted-p)))))

(defwhopper (username->gids unix-name-lookup-access-path-mixin) (username)
  (let ((username (string-downcase (string-thin username))))
    (multiple-value-bind (gids defaulted-p)
	(continue-whopper username)
      (if (and defaulted-p (> (string-length username) 8))
	  (multiple-value-bind (gids1 defaulted-p1)
	      (continue-whopper (substring username 0 8))
	    (if defaulted-p1
		(values gids defaulted-p)
	      (values gids1 defaulted-p1)))
	(values gids defaulted-p)))))

(defwhopper (groupname->group unix-name-lookup-access-path-mixin) (groupname)
  (continue-whopper (string-downcase (string-thin groupname))))

(defwhopper (hostname->host unix-name-lookup-access-path-mixin) (hostname)
  (continue-whopper (string-downcase (string-thin hostname))))

(defmethod (username->password unix-name-lookup-access-path-mixin)
	   (username)
  (multiple-value-bind (passwd defaulted-p)
      (username->passwd self username)
    (values (second passwd) defaulted-p)))

(defmethod (username->uid unix-name-lookup-access-path-mixin)
	   (username)
  (multiple-value-bind (passwd defaulted-p)
      (username->passwd self username)
    (values (third passwd) defaulted-p)))

(defmethod (username->gid unix-name-lookup-access-path-mixin)
	   (username)
  (multiple-value-bind (passwd defaulted-p)
      (username->passwd self username)
    (values (fourth passwd) defaulted-p)))

(defmethod (username->gecos unix-name-lookup-access-path-mixin)
	   (username)
  (multiple-value-bind (passwd defaulted-p)
      (username->passwd self username)
    (values (fifth passwd) defaulted-p)))

(defmethod (username->homedir unix-name-lookup-access-path-mixin)
	   (username)
  (multiple-value-bind (passwd defaulted-p)
      (username->passwd self username)
    (values (sixth passwd) defaulted-p)))

(defmethod (username->shell unix-name-lookup-access-path-mixin)
	   (username)
  (multiple-value-bind (passwd defaulted-p)
      (username->passwd self username)
    (values (seventh passwd) defaulted-p)))

(defmethod (uid->username unix-name-lookup-access-path-mixin)
	   (uid)
  (multiple-value-bind (passwd defaulted-p)
      (uid->passwd self uid)
    (values (first passwd) defaulted-p)))

(defmethod (groupname->password unix-name-lookup-access-path-mixin)
	   (groupname)
  (multiple-value-bind (group defaulted-p)
      (groupname->group self groupname)
    (values (second group) defaulted-p)))

(defmethod (groupname->gid unix-name-lookup-access-path-mixin)
	   (groupname)
  (multiple-value-bind (group defaulted-p)
      (groupname->group self groupname)
    (values (third group) defaulted-p)))

(defmethod (groupname->usernames unix-name-lookup-access-path-mixin)
	   (groupname)
  (multiple-value-bind (group defaulted-p)
      (groupname->group self groupname)
    (values (third group) defaulted-p)))

(defmethod (gid->groupname unix-name-lookup-access-path-mixin)
	   (gid)
  (multiple-value-bind (group defaulted-p)
      (gid->group self gid)
    (values (first group) defaulted-p)))

(defmethod (hostname->address unix-name-lookup-access-path-mixin)
	   (hostname)
  (multiple-value-bind (host defaulted-p)
      (hostname->host self hostname)
    (values (first host) defaulted-p)))

(defmethod (address->hostname unix-name-lookup-access-path-mixin)
	   (address)
  (multiple-value-bind (host defaulted-p)
      (address->host self address)
    (values (second host) defaulted-p)))

;;; The default implementation.

(defflavor default-unix-name-lookup-access-path-mixin
	((default-username-passwd-hash-table (make-hash-table :test 'string=))
	 (default-uid-passwd-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (default-groupname-group-hash-table (make-hash-table :test 'string=))
	 (default-gid-group-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (default-username-gids-hash-table (make-hash-table :test 'string=)))
	()
  (:required-flavors unix-name-lookup-access-path-mixin)
  :abstract-flavor)

(defmethod (:reset default-unix-name-lookup-access-path-mixin :after)
	   ()
  (clrhash default-username-passwd-hash-table)
  (clrhash default-uid-passwd-hash-table)
  (clrhash default-groupname-group-hash-table)
  (clrhash default-gid-group-hash-table)
  (clrhash default-username-gids-hash-table))

(defun-in-flavor (default-make-passwd default-unix-name-lookup-access-path-mixin)
		 (&key username password uid gid gecos home-directory shell)
  (let ((passwd (make-passwd :username username :password password :uid uid :gid gid
			     :gecos gecos :home-directory home-directory :shell shell)))
    (setf (gethash (first passwd) default-username-passwd-hash-table) passwd)
    (setf (gethash (third passwd) default-uid-passwd-hash-table) passwd)
    passwd))

(defmethod (username->passwd default-unix-name-lookup-access-path-mixin)
	   (username)
  (values (or (gethash username default-username-passwd-hash-table)
	      (default-make-passwd :username username))
	  t))

(defmethod (uid->passwd default-unix-name-lookup-access-path-mixin)
	   (uid)
  (values (or (gethash uid default-uid-passwd-hash-table)
	      (default-make-passwd :uid uid))
	  t))

(defun-in-flavor (default-make-group default-unix-name-lookup-access-path-mixin)
		 (&key groupname password gid usernames)
  (let ((group (make-group :groupname groupname :password password :gid gid
			   :usernames usernames)))
    (setf (gethash (first group) default-groupname-group-hash-table) group)
    (setf (gethash (third group) default-gid-group-hash-table) group)
    group))

(defmethod (groupname->group default-unix-name-lookup-access-path-mixin)
	   (groupname)
  (values (or (gethash groupname default-groupname-group-hash-table)
	      (default-make-group :groupname groupname))
	  t))

(defmethod (gid->group default-unix-name-lookup-access-path-mixin)
	   (gid)
  (values (or (gethash gid default-gid-group-hash-table)
	      (default-make-group :gid gid))
	  t))

(defparameter *default-gids* nil "The default gids for UNIX name lookups.")

(defun-in-flavor (default-make-gids default-unix-name-lookup-access-path-mixin)
		 (username &key gids)
  (let ((gids (make-gids :gids (or gids (list *default-gids*)))))
    (setf (gethash username default-username-gids-hash-table) gids)
    gids))

(defmethod (username->gids default-unix-name-lookup-access-path-mixin)
	   (username)
  (values (or (gethash username default-username-gids-hash-table)
	      (default-make-gids username))
	  t))

;;; The namespace implementation.

(defflavor namespace-unix-name-lookup-access-path-mixin
	((use-namespace-for-unix-name-lookup nil)
	 (namespace-username-passwd-hash-table (make-hash-table :test 'string=))
	 (namespace-uid-passwd-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (namespace-username-gids-hash-table (make-hash-table :test 'string=))
	 (namespace-hostname-host-hash-table (make-hash-table :test 'string=))
	 (namespace-address-host-hash-table (make-hash-table :test 'eql :ignore-gc t)))
	()
  (:required-flavors unix-name-lookup-access-path-mixin)
  :abstract-flavor)

(defmethod (:reset namespace-unix-name-lookup-access-path-mixin :after)
	   ()
  (setq use-namespace-for-unix-name-lookup nil)
  (clrhash namespace-username-passwd-hash-table)
  (clrhash namespace-uid-passwd-hash-table)
  (clrhash namespace-username-gids-hash-table)
  (clrhash namespace-hostname-host-hash-table)
  (clrhash namespace-address-host-hash-table))

(defparameter *namespace-unix-name-lookup-cache-validity-time* (* 20 60 60)
  "The time that cached namespace unix-name-lookup values are valid (60ths of a second).")

(defun-in-flavor (user-username namespace-unix-name-lookup-access-path-mixin) (user)
  (declare (values username))
  (string-downcase (or (send user :host-user-id host) (string user))))

(defun-in-flavor (tokenize-user-property namespace-unix-name-lookup-access-path-mixin)
		 (line)
  (loop with set = '(#\sp #\return #\tab #\line #\,)
	for lastpos first 0 then pos
	while lastpos
	for startpos = (string-search-not-set set line :start lastpos)
	while startpos
	for pos = (string-search-set set line :start startpos)
	collect (substring line startpos pos)))

(defun-in-flavor (user-decode namespace-unix-name-lookup-access-path-mixin)
		 (user property)
  (or (loop with user-properties = (send user :user-property)
	    for prefix in '("RPC-HOST-" "NFS-HOST-")
	    for keyword = (intern (string-append prefix property) "KEYWORD")
	    thereis (loop for user-property in user-properties
			  for (key val) = user-property
			  when (eq key keyword)
			    thereis (let ((tokens (tokenize-user-property val)))
				      (when (eq (net:parse-host (car tokens) t) host)
					(cdr tokens)))))
      (loop with user-properties = (send user :user-property)
	    for prefix in '("RPC-" "NFS-")
	    for keyword = (intern (string-append prefix property) "KEYWORD")
	    thereis (loop for user-property in user-properties
			  for (key val) = user-property
			  when (eq key keyword)
			    thereis (tokenize-user-property val)))))

(defun-in-flavor (namespace-make-gids namespace-unix-name-lookup-access-path-mixin)
		 (username &key gids)
  (let ((new-entry
	  (list (make-gids :gids gids)
		(time:time))))
    (update-entry-in-table new-entry username namespace-username-gids-hash-table
			   *namespace-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defun-in-flavor (namespace-make-passwd namespace-unix-name-lookup-access-path-mixin)
		 (user &key username password uid gid gecos home-directory shell gids)
  (let* ((new-username
	   (or username
	       (and user
		    (user-username user))))
	 (new-uid
	   (or uid
	       (and user
		    (let ((uid-string (first (user-decode user :uid))))
		      (and uid-string
			   (parse-integer uid-string :junk-allowed t))))))
	 (new-entry
	   (list (and user 
		      (make-passwd
			:username new-username
			:password password
			:uid new-uid
			:gid (or gid
				 (and user
				      (let ((gid-string (first (user-decode user :gid))))
					(and gid-string
					     (parse-integer gid-string :junk-allowed t)))))
			:gecos gecos
			:home-directory (or home-directory
					    (and user
						 (first (user-decode user :homedir))))
			:shell shell))
		 (time:time))))
    (update-entry-in-table new-entry new-username namespace-username-passwd-hash-table
			   *namespace-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry new-uid namespace-uid-passwd-hash-table
			   *namespace-unix-name-lookup-cache-validity-time*)
    (namespace-make-gids
      new-username 
      :gids (or gids
		(and user
		     (list (loop for gids-string in (user-decode user :gids)
				 collecting (parse-integer gids-string :junk-allowed t))))))
    (first new-entry)))

(defparameter *use-namespace-for-unix-name-lookup* t
  "Setting this to NIL disables the use of the Namespace for unix-name-lookup.")

(defparameter *default-use-namespace-for-unix-name-lookup* t
  "Default choice for use of the Namespace for unix-name-lookup.")

(defun-in-flavor (use-namespace-for-unix-name-lookup-p
		   namespace-unix-name-lookup-access-path-mixin)
		 ()
  (when *use-namespace-for-unix-name-lookup*
    (unless (and use-namespace-for-unix-name-lookup
		 (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
					   (second use-namespace-for-unix-name-lookup))))
      (setq use-namespace-for-unix-name-lookup
	    (list (if *default-use-namespace-for-unix-name-lookup*
		      (and (get-host-prop-boolean host :rpc-use-namespace t)
			   (get-host-prop-boolean host :nfs-use-namespace t))
		    (or (get-host-prop-boolean host :rpc-use-namespace nil)
			(get-host-prop-boolean host :nfs-use-namespace nil)))
		  (time:time))))
    (first use-namespace-for-unix-name-lookup)))

(defun-in-flavor (users-with-user-property namespace-unix-name-lookup-access-path-mixin)
		 (property)
  (let ((net:*namespace-search-list*
	  (delete-duplicates
	    (append (send host :namespaces)
		    (send si:*user* :namespaces)
		    (list net:*namespace*))
	    :from-end t)))
    (delete-duplicates
      (neti:keeping-namespace-server
	(nconc
	  (loop for prefix in '("RPC-HOST-" "NFS-HOST-")
		for keyword = (intern (string-append prefix property) "KEYWORD")
		nconc (loop for user in (neti:find-objects-from-property-list
					  :user :user-property `((,keyword :*)))
			    for val = (user-decode user property)
			    when val collect (cons user val)))
	  (loop for prefix in '("RPC-" "NFS-")
		for keyword = (intern (string-append prefix property) "KEYWORD")
		nconc (loop for user in (neti:find-objects-from-property-list
					  :user :user-property `((,keyword :*)))
			    for val = (user-decode user property)
			    when val collect (cons user val)))))
      :key #'car)))

(defun-in-flavor (namespace-username->passwd namespace-unix-name-lookup-access-path-mixin)
		 (username)
  (let ((entry (gethash username namespace-username-passwd-hash-table)))
    (if (and entry
	     (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
				       (second entry))))
	(first entry)
      (or
	(loop for (user) in (users-with-user-property "UID")
	      when (string= (user-username user) username)
		return (namespace-make-passwd user :username username))
	(loop for (user) in (users-with-user-property "GID")
	      when (string= (user-username user) username)
		return (namespace-make-passwd user :username username))
	(loop for (user) in (users-with-user-property "GIDS")
	      when (string= (user-username user) username)
		return (namespace-make-passwd user :username username))
	(loop for (user) in (users-with-user-property "HOMEDIR")
	      when (string= (user-username user) username)
		return (namespace-make-passwd user :username username))
	(namespace-make-passwd nil :username username)))))

(defmethod (username->passwd namespace-unix-name-lookup-access-path-mixin)
	   (username)
  (when (use-namespace-for-unix-name-lookup-p)
    (namespace-username->passwd username)))

(defmethod (uid->passwd namespace-unix-name-lookup-access-path-mixin)
	   (uid)
  (when (use-namespace-for-unix-name-lookup-p)
    (let ((entry (gethash uid namespace-uid-passwd-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
					 (second entry))))
	  (first entry)
	(or (loop for (user uid-string) in (users-with-user-property "UID")
		  for parsed-uid = (parse-integer uid-string :junk-allowed t)
		  when (and parsed-uid (= parsed-uid uid))
		    return (namespace-make-passwd user :uid uid))
	    (namespace-make-passwd nil :uid uid))))))

(defmethod (username->gids namespace-unix-name-lookup-access-path-mixin)
	   (username)
  (when (use-namespace-for-unix-name-lookup-p)
    (let ((entry (gethash username namespace-username-gids-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
					 (second entry))))
	  (first entry)
	(let ((entry (progn (namespace-username->passwd username)
			    (gethash username namespace-username-gids-hash-table))))
	  (if (and entry
		   (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
					     (second entry))))
	      (first entry)
	    (namespace-make-gids username :gids nil)))))))

(defparameter *namespace-unix-name-lookup-use-domain-style-host-names* t
  "Use domain-style host names from Namespace hosts for unix-name-lookup.")

(defun-in-flavor (host-hostname namespace-unix-name-lookup-access-path-mixin)
		 (host-object)
  (string-downcase
    (let* ((primary-name (send host-object :primary-name))
	   (primary-name-string (if (stringp primary-name)
				    primary-name
				  (send primary-name :string)))
	   (idn (send host-object :internet-domain-name))
	   (namespace (and (not (stringp primary-name)) (send primary-name :namespace)))
	   (namespace-idn (and namespace (send namespace :internet-domain-name))))
      (or (and (null *namespace-unix-name-lookup-use-domain-style-host-names*)
	       primary-name-string)
	  (and idn
	       (not (string-search "Dialnet" idn))
	       idn)
	  (and (null idn)
	       namespace-idn
	       (not (string-search "Dialnet" namespace-idn))
	       (format nil "~A.~A" primary-name-string namespace-idn))
	  primary-name-string))))

(defun-in-flavor (namespace-make-host namespace-unix-name-lookup-access-path-mixin)
		 (host-object &key address hostnames)
  (let* ((new-address
	   (or address
	       (and host-object 
		    (second (assoc (neti:local-network-of-type :internet)
				   (send host-object :network-addresses))))))
	 (new-hostnames
	   (or hostnames
	       (and host-object 
		    (list (host-hostname host-object)))))
	 (new-entry
	   (list (and host-object
		      (make-host
			:address new-address
			:hostnames new-hostnames))
		 (time:time))))
    (update-entry-in-table new-entry (first new-hostnames) namespace-hostname-host-hash-table
			   *namespace-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry new-address namespace-address-host-hash-table
			   *namespace-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defmethod (hostname->host namespace-unix-name-lookup-access-path-mixin)
	   (hostname)
  (when (use-namespace-for-unix-name-lookup-p)
    (let ((entry (gethash hostname namespace-hostname-host-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
					 (second entry))))
	  (first entry)
	(namespace-make-host (net:parse-host hostname t) :hostnames (list hostname))))))

(defmethod (address->host namespace-unix-name-lookup-access-path-mixin)
	   (address)
  (when (use-namespace-for-unix-name-lookup-p)
    (let ((entry (gethash address namespace-address-host-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p *namespace-unix-name-lookup-cache-validity-time*
					 (second entry))))
	  (first entry)
	(namespace-make-host
	  (net:get-host-from-address address (neti:local-network-of-type :internet) nil
				     :system-type (send host :system-type))
	  :address address)))))

;;; The yellow-pages implementation.

(defflavor yellow-pages-unix-name-lookup-access-path-mixin
	((use-yellow-pages-for-unix-name-lookup nil)
	 (yellow-pages-username-passwd-hash-table (make-hash-table :test 'string=))
	 (yellow-pages-uid-passwd-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (yellow-pages-groupname-group-hash-table (make-hash-table :test 'string=))
	 (yellow-pages-gid-group-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (yellow-pages-username-gids-hash-table (make-hash-table :test 'string=))
	 (yellow-pages-hostname-host-hash-table (make-hash-table :test 'string=))
	 (yellow-pages-address-host-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (yellow-pages-domains-that-have-been-found-not-to-work nil)
	 (yellow-pages-domain-and-server nil)
	 (yellow-pages-group-database nil))
	()
  (:required-flavors unix-name-lookup-access-path-mixin)
  :abstract-flavor)

(defmethod (unix-name-lookup-access-path-report
	     yellow-pages-unix-name-lookup-access-path-mixin)
	   (stream format)
  (ecase format
    (:brief
      (when yellow-pages-domain-and-server
	(format stream " (~A ~A ~A)"
		:yp
		(first yellow-pages-domain-and-server)
		(second yellow-pages-domain-and-server))))))

(defmethod (:reset yellow-pages-unix-name-lookup-access-path-mixin :after)
	   ()
  (setq use-yellow-pages-for-unix-name-lookup nil)
  (clrhash yellow-pages-username-passwd-hash-table)
  (clrhash yellow-pages-uid-passwd-hash-table)
  (clrhash yellow-pages-groupname-group-hash-table)
  (clrhash yellow-pages-gid-group-hash-table)
  (clrhash yellow-pages-username-gids-hash-table)
  (clrhash yellow-pages-hostname-host-hash-table)
  (clrhash yellow-pages-address-host-hash-table)
  (setq yellow-pages-domains-that-have-been-found-not-to-work nil)
  (when (third yellow-pages-domain-and-server)
    (forget-transport-agent self (third yellow-pages-domain-and-server)))
  (setq yellow-pages-domain-and-server nil)
  (setq yellow-pages-group-database nil))

(defparameter *yellow-pages-unix-name-lookup-cache-validity-time* (* 20 60 60)
  "The time that cached yellow pages unix-name-lookup values are valid (60ths of a second).")

(defun-in-flavor (yellow-pages-make-passwd yellow-pages-unix-name-lookup-access-path-mixin)
		 (yp &key username password uid gid gecos home-directory shell)
  (let* ((new-entry
	   (list (and yp
		      (make-passwd
			:username username
			:password password
			:uid uid
			:gid gid
			:gecos gecos
			:home-directory home-directory
			:shell shell))
		 (time:time))))
    (update-entry-in-table new-entry username yellow-pages-username-passwd-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry uid yellow-pages-uid-passwd-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defparameter *use-yellow-pages-for-unix-name-lookup* t
  "Setting this to NIL disables the use of the Yellow Pages for unix-name-lookup.")

(defparameter *default-use-yellow-pages-for-unix-name-lookup* t
  "Default choice for use of the Yellow Pages for unix-name-lookup.")

(defun-in-flavor (use-yellow-pages-for-unix-name-lookup-p
		   yellow-pages-unix-name-lookup-access-path-mixin)
		 ()
  (when *use-yellow-pages-for-unix-name-lookup*
    (unless (and use-yellow-pages-for-unix-name-lookup
		 (not (time:time-elapsed-p *yellow-pages-unix-name-lookup-cache-validity-time*
					   (second use-yellow-pages-for-unix-name-lookup))))
      (setq use-yellow-pages-for-unix-name-lookup
	    (list (if *default-use-yellow-pages-for-unix-name-lookup*
		      (and (get-host-prop-boolean host :rpc-use-yellow-pages t)
			   (get-host-prop-boolean host :nfs-use-yellow-pages t))
		    (or (get-host-prop-boolean host :rpc-use-yellow-pages nil)
			(get-host-prop-boolean host :nfs-use-yellow-pages nil)))
		  (time:time))))
    (first use-yellow-pages-for-unix-name-lookup)))

(defparameter *unix-name-lookup-ypbindproc-domain-timeout* (* 7 60))
(defparameter *unix-name-lookup-ypproc-domain-timeout* (* 15 60))

(defun-in-flavor (yellow-pages-domain-server
		   yellow-pages-unix-name-lookup-access-path-mixin)
		 (host domain serverp)
  (cond ((neti:ns-eq host net:*local-host*)
	 :local-host)
	(serverp
	 (condition-case (error)
	      (and (let ((*udp-call-timeout* *unix-name-lookup-ypproc-domain-timeout*))
		     (ypproc-domain domain :transport-agent (host-udp-transport-agent host)))
		   host)
	    (rpc-error error)))
	(t
	 (let ((resp (condition-case (error)
			  (let ((*udp-call-timeout*
				  *unix-name-lookup-ypbindproc-domain-timeout*))
			    (ypbindproc-domain
			      domain :transport-agent (host-udp-transport-agent host)))
			(rpc-error error))))
	   (typecase resp
	     (ypbind-binding 
	       (let ((ip-address (ypbind-binding-addr resp)))
		 ;; Horribly grotesque kludge to handle bug in some VAX
		 ;; implementations of Yellow pages distributed by Mt. Xinu that
		 ;; have the byte order wrong in the ip-address.
		 (let* ((ip-network (tcp:internet-subnet-number ip-address))
			(reverse-ip-address (multiple-value-bind (b1 b2 b3 b4)
						(tcp:explode-internet-address ip-address)
					      (tcp:build-internet-address b4 b3 b2 b1)))
			(reverse-ip-network (tcp:internet-subnet-number reverse-ip-address))
			(networks
			  (loop with inet = (neti:local-network-of-type :internet)
				for (network address) in (send host :network-addresses)
				when (eq network inet)
				  collect (tcp:internet-subnet-number address))))
		   (when (or (= reverse-ip-address
				#.(neti:parse-internet-address "127.0.0.1"))
			     (and (not (member ip-network networks))
				  (member reverse-ip-network networks)))
		     (setq ip-address reverse-ip-address)))
		 (if (= ip-address #.(neti:parse-internet-address "127.0.0.1"))
		     host
		     (values (net:get-host-from-address
			       ip-address (neti:local-network-of-type :internet) nil
			       :system-type (send host :system-type))))))
	     (t
	       resp))))))

(defparameter *unix-name-lookup-yp-domain-name-timeout* (* 15 60))

(eval-when (compile load)
  (compiler:function-defined 'yp-domain-name))

(defun-in-flavor (find-yellow-pages-domain-and-server
		   yellow-pages-unix-name-lookup-access-path-mixin)
		 ()
  (labels ((establish (domain server agent)
	     (let ((old-agent (third yellow-pages-domain-and-server)))
	       (when (and agent (neq agent old-agent))
		 (udp-agent-note-dependent agent self))
	       (setq yellow-pages-domain-and-server (list domain server agent (time:time)))
	       (when (and old-agent (neq agent old-agent))
		 (udp-agent-note-dependent old-agent self t)))
	     (setq yellow-pages-domains-that-have-been-found-not-to-work
		   (sys:localize-tree yellow-pages-domains-that-have-been-found-not-to-work))
	     (return-from find-yellow-pages-domain-and-server nil))
	   (try1 (domain host serverp)
	     (when (and host
			(stringp domain)
			(not (zerop (string-length domain)))
			(loop for (bad-domain bad-host reason)
				  in yellow-pages-domains-that-have-been-found-not-to-work
			      never (and (neti:ns-eq host bad-host)
					 (or (string= domain bad-domain)
					     (typep reason 'host-not-responding)
					     (typep reason 'port-unavailable)))))
	       (let ((answer (yellow-pages-domain-server host domain serverp)))
		 (typecase answer
		   (net:host (establish domain answer (host-udp-transport-agent answer)))
		   (t (push (list domain host answer)
			    yellow-pages-domains-that-have-been-found-not-to-work))))))
	   (try (domain host &optional serverp)
	     (try1 domain host serverp)
	     (try1 (string-downcase domain) host serverp)
	     (try1 (string-upcase domain) host serverp))
	   (try2 (domain server)
	     (when domain
	       (try domain host)
	       (when server
		 (try domain (net:parse-host server t) t))))
	   (try3 (host)
	     (try2 (get-host-prop-string host :yp-domain-name nil)
		   (get-host-prop-string host :yp-domain-server nil))
	     (loop for name-object in (if (operation-handled-p host :mail-name)
					  (cons (send host :mail-name) (send host :names))
					  (send host :names))
		   for name = (if (stringp name-object) name-object (send name-object :string))
		   for hyphenpos = (string-search-char #\- name)
		   for dotpos = (string-search-char #\. name)
		   when hyphenpos thereis (try (substring name 0 hyphenpos) host)
		   when dotpos thereis (try (substring name (1+ dotpos)) host)
		   when dotpos
		     thereis (let ((rdotpos (string-search-char
					      #\. name :from-end t :start (1+ dotpos))))
			       (and rdotpos (try (substring name (1+ dotpos) rdotpos) host))))
	     (let ((site (send host :site)))
	       (when (typep site 'neti:site) (try (symbol-name (send site :name)) host))
	       (loop for namespace in
			 (append (and (typep site 'neti:site)
				      (ncons (send site :local-namespace)))
				 (send host :namespaces))
		     thereis (try (symbol-name (send namespace :name)) host)
		     for idn = (send namespace :internet-domain-name)
		     thereis (try idn host)
		     thereis (let ((rdotpos (string-search-char #\. idn :from-end t)))
			       (and rdotpos (try (substring idn 0 rdotpos) host)))))))
    (setq yellow-pages-domains-that-have-been-found-not-to-work nil)
    ;; First try a Symbolics RPC entry to determine it.
    (when (and (variable-boundp #'yp-domain-name)
	       (eq (send host :system-type) :unix42))
      (let ((yp-domain-name
	      (condition-case ()
		   (let ((*udp-call-timeout* *unix-name-lookup-yp-domain-name-timeout*))
		     (yp-domain-name :transport-agent (host-udp-transport-agent host)))
		 ((rpc-error network-error)))))
	(when yp-domain-name (try yp-domain-name host))))
    (try3 host)
    (try3 net:*local-host*)
    (establish 
      (first yellow-pages-domain-and-server)
      (second yellow-pages-domain-and-server)
      (third yellow-pages-domain-and-server))))

(defmethod (forget-transport-agent yellow-pages-unix-name-lookup-access-path-mixin) (agent)
  (when (eq agent (third yellow-pages-domain-and-server))
    (setq yellow-pages-domain-and-server nil)
    (udp-agent-note-dependent agent self t)))

(defmethod (dependent-note-udp-agent-closed yellow-pages-unix-name-lookup-access-path-mixin)
	   (agent)
  (forget-transport-agent self agent))

(defgeneric yellow-pages-domain-and-server
	    (unix-name-lookup-access-path)
  (declare (values domain server agent)))

(defmethod (yellow-pages-domain-and-server
	     yellow-pages-unix-name-lookup-access-path-mixin)
	   ()
  (unless (and yellow-pages-domain-and-server
	       (not (time:time-elapsed-p *yellow-pages-unix-name-lookup-cache-validity-time*
					 (fourth yellow-pages-domain-and-server))))
    (find-yellow-pages-domain-and-server))
  (values (first yellow-pages-domain-and-server)
	  (second yellow-pages-domain-and-server)
	  (third yellow-pages-domain-and-server)))

(defgeneric yellow-pages-order (yellow-pages-unix-name-lookup-access-path map)
  (declare (values ordernum)))

(defmethod (yellow-pages-order yellow-pages-unix-name-lookup-access-path-mixin)
	   (map)
  (declare (values ordernum))
  (multiple-value-bind (domain server agent) (yellow-pages-domain-and-server self)
    (when (and domain server agent)
      (multiple-value-bind (ypstat ordernum)
	  (ypproc-order domain map :transport-agent agent)
	(when (eq ypstat :yp-true)
	  ordernum)))))

(defgeneric yellow-pages-lookup (yellow-pages-unix-name-lookup-access-path map key)
  (declare (values val)))

(defmethod (yellow-pages-lookup yellow-pages-unix-name-lookup-access-path-mixin)
	   (map key)
  (declare (values val))
  (multiple-value-bind (domain server agent) (yellow-pages-domain-and-server self)
    (when (and domain server agent)
      (neti:noting-network-progress
	((format nil "YP Lookup ~A ~A ~A ~A" key map domain server))
	(multiple-value-bind (ypstat resp)
	    (ypproc-match domain map key :transport-agent agent)
	  (when (eq ypstat :yp-true)
	    resp))))))

(defgeneric yellow-pages-list (yellow-pages-unix-name-lookup-access-path map)
  (declare (values key-val-list)))

(defmethod (yellow-pages-list yellow-pages-unix-name-lookup-access-path-mixin)
	   (map)
  (declare (values key-val-list))
  (multiple-value-bind (domain server agent) (yellow-pages-domain-and-server self)
    (when (and domain server agent)
      (neti:noting-network-progress ((format nil "YP List ~A ~A ~A" map domain server))
	(loop for (ypstat key val) first
		  (multiple-value-list (ypproc-first domain map :transport-agent agent)) then
		  (multiple-value-list (ypproc-next domain map val :transport-agent agent))
	      until (eq ypstat :yp-nomore)
	      unless (eq ypstat :yp-true) return nil
	      collect (list val key))))))

(defmethod (username->passwd yellow-pages-unix-name-lookup-access-path-mixin)
	   (username)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((entry (gethash username yellow-pages-username-passwd-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p
		      *yellow-pages-unix-name-lookup-cache-validity-time*
		      (second entry))))
	  (first entry)
	(with-recursion-prevented (yellow-pages-unix-name-lookup)
	  (or (let ((line (yellow-pages-lookup self "passwd.byname" username)))
		(when line
		  (let ((decoded-line (decode-passwd-line line)))
		    (when decoded-line
		      (yellow-pages-make-passwd
			decoded-line
			:username username
			:password (second decoded-line)
			:uid (third decoded-line)
			:gid (fourth decoded-line)
			:gecos (fifth decoded-line)
			:home-directory (sixth decoded-line)
			:shell (seventh decoded-line))))))
	      (yellow-pages-make-passwd
		nil
		:username username)))))))

(defmethod (uid->passwd yellow-pages-unix-name-lookup-access-path-mixin)
	   (uid)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((entry (gethash uid yellow-pages-uid-passwd-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p
		      *yellow-pages-unix-name-lookup-cache-validity-time*
		      (second entry))))
	  (first entry)
	(with-recursion-prevented (yellow-pages-unix-name-lookup)
	  (or (let ((line (yellow-pages-lookup self "passwd.byuid" (format nil "~D" uid))))
		(when line
		  (let ((decoded-line (decode-passwd-line line)))
		    (when decoded-line
		      (yellow-pages-make-passwd
			decoded-line
			:username (first decoded-line)
			:password (second decoded-line)
			:uid uid
			:gid (fourth decoded-line)
			:gecos (fifth decoded-line)
			:home-directory (sixth decoded-line)
			:shell (seventh decoded-line))))))
	      (yellow-pages-make-passwd
		nil
		:uid uid)))))))

(defun-in-flavor (yellow-pages-make-group yellow-pages-unix-name-lookup-access-path-mixin)
		 (yp &key groupname password gid usernames)
  (let* ((new-entry
	   (list (and yp
		      (make-group
			:groupname groupname
			:password password
			:gid gid
			:usernames usernames))
		 (time:time))))
    (update-entry-in-table new-entry groupname yellow-pages-groupname-group-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry gid yellow-pages-gid-group-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defmethod (groupname->group yellow-pages-unix-name-lookup-access-path-mixin)
	   (groupname)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((entry (gethash groupname yellow-pages-groupname-group-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p
		      *yellow-pages-unix-name-lookup-cache-validity-time*
		      (second entry))))
	  (first entry)
	(with-recursion-prevented (yellow-pages-unix-name-lookup)
	  (or (let ((line (yellow-pages-lookup self "group.byname" groupname)))
		(when line
		  (let ((decoded-line (decode-group-line line)))
		    (when decoded-line
		      (yellow-pages-make-group
			decoded-line
			:groupname groupname
			:password (second decoded-line)
			:gid (third decoded-line)
			:usernames (fourth decoded-line))))))
	      (yellow-pages-make-group
		nil
		:groupname groupname)))))))

(defmethod (gid->group yellow-pages-unix-name-lookup-access-path-mixin)
	   (gid)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((entry (gethash gid yellow-pages-gid-group-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p
		      *yellow-pages-unix-name-lookup-cache-validity-time*
		      (second entry))))
	  (first entry)
	(with-recursion-prevented (yellow-pages-unix-name-lookup)
	  (or (let ((line (yellow-pages-lookup self "group.bygid" (format nil "~D" gid))))
		(when line
		  (let ((decoded-line (decode-group-line line)))
		    (when decoded-line
		      (yellow-pages-make-group
			decoded-line
			:groupname (first decoded-line)
			:password (second decoded-line)
			:gid gid
			:usernames (fourth decoded-line))))))
	      (yellow-pages-make-group
		nil
		:gid gid)))))))

(defun-in-flavor (yellow-pages-make-gids yellow-pages-unix-name-lookup-access-path-mixin)
		 (username &key gids)
  (let* ((new-entry
	   (list (make-gids :gids gids)
		 (time:time))))
    (update-entry-in-table new-entry username yellow-pages-username-gids-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defmethod (group-database-needs-rebuilding yellow-pages-unix-name-lookup-access-path-mixin)
	   ()
  (and (use-yellow-pages-for-unix-name-lookup-p)
       (or (null yellow-pages-group-database)
	   (null (third yellow-pages-group-database))
	   (when (time:time-elapsed-p *yellow-pages-unix-name-lookup-cache-validity-time*
				      (third yellow-pages-group-database))
	     (setf (third yellow-pages-group-database) (time:time))
	     (neq (second yellow-pages-group-database)
		  (yellow-pages-order self "group.byname"))))))

(defmethod (group-database yellow-pages-unix-name-lookup-access-path-mixin)
	   ()
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((ordernum (yellow-pages-order self "group.byname")))
      (when (or (null yellow-pages-group-database)
		(neq ordernum (second yellow-pages-group-database)))
	(setq yellow-pages-group-database
	      (list (loop for (groupname line) in (yellow-pages-list self "group.byname")
			  initially (progn groupname)
			  collect (decode-group-line line))
		    ordernum
		    nil))))
    (first yellow-pages-group-database)))

(defmethod (group-database-rebuild yellow-pages-unix-name-lookup-access-path-mixin)
	   (new-database)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (clrhash yellow-pages-username-gids-hash-table)
    (group-database-username-gids new-database #'yellow-pages-make-gids)
    (when yellow-pages-group-database
      (setf (third yellow-pages-group-database) (time:time)))))

(defmethod (username->gids yellow-pages-unix-name-lookup-access-path-mixin)
	   (username)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (group-database-check)
    (let ((entry (gethash username yellow-pages-username-gids-hash-table)))
      (if entry
	  (first entry)
	(yellow-pages-make-gids
	  username :gids (if yellow-pages-group-database (ncons nil) nil))))))

(defun-in-flavor (yellow-pages-make-host yellow-pages-unix-name-lookup-access-path-mixin)
		 (yp &key address hostnames)
  (let* ((new-entry
	   (list (and yp
		      (make-host
			:address address
			:hostnames hostnames))
		 (time:time))))
    (update-entry-in-table new-entry (first hostnames) yellow-pages-hostname-host-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry address yellow-pages-address-host-hash-table
			   *yellow-pages-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defmethod (hostname->host yellow-pages-unix-name-lookup-access-path-mixin)
	   (hostname)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((entry (gethash hostname yellow-pages-hostname-host-hash-table)))
      (if (and entry
	       (not (time:time-elapsed-p
		      *yellow-pages-unix-name-lookup-cache-validity-time*
		      (second entry))))
	  (first entry)
	(with-recursion-prevented (yellow-pages-unix-name-lookup)
	  (or (let ((line (yellow-pages-lookup self "hosts.byname" hostname)))
		(when line
		  (let ((decoded-line (decode-hosts-line line)))
		    (when decoded-line
		      (yellow-pages-make-host
			decoded-line
			:address (first decoded-line)
			:hostnames (cons hostname
					 (delete-if #'(lambda (name) (string= name hostname))
						    (rest decoded-line))))))))
	      (yellow-pages-make-host
		nil
		:hostnames (ncons hostname))))))))

(defmethod (address->host yellow-pages-unix-name-lookup-access-path-mixin)
	   (address)
  (when (use-yellow-pages-for-unix-name-lookup-p)
    (let ((entry (gethash address yellow-pages-address-host-hash-table)))
      (if (and entry 
	       (not (time:time-elapsed-p
		      *yellow-pages-unix-name-lookup-cache-validity-time*
		      (second entry))))
	  (first entry)
	(with-recursion-prevented (yellow-pages-unix-name-lookup)
	  (or (let ((line (yellow-pages-lookup
			    self "hosts.byaddr" (neti:unparse-internet-address address))))
		(when line
		  (let ((decoded-line (decode-hosts-line line)))
		    (when decoded-line
		      (yellow-pages-make-host
			decoded-line
			:address address
			:hostnames (rest decoded-line))))))
	      (yellow-pages-make-host
		nil
		:address address)))))))

;;; The file implementation.

(defflavor file-unix-name-lookup-access-path-mixin
	((file-read-lock (process:make-lock "UNIX Name Lookup File Lock"))
	 (use-file-for-unix-name-lookup nil)
	 (use-hosts-file-for-unix-name-lookup nil)
	 (file-username-passwd-hash-table (make-hash-table :test 'string=))
	 (file-uid-passwd-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (file-groupname-group-hash-table (make-hash-table :test 'string=))
	 (file-gid-group-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (file-username-gids-hash-table (make-hash-table :test 'string=))
	 (file-hostname-host-hash-table (make-hash-table :test 'string=))
	 (file-address-host-hash-table (make-hash-table :test 'eql :ignore-gc t))
	 (passwd-file-info nil)
	 (group-file-info nil)
	 (hosts-file-info nil)
	 (file-group-database nil))
	()
  (:required-flavors unix-name-lookup-access-path-mixin)
  :abstract-flavor)

(defmethod (unix-name-lookup-access-path-report
	     file-unix-name-lookup-access-path-mixin)
	   (stream format)
  (ecase format
    (:brief
      (flet ((pretty-info (info)
	       (let ((interesting (second (first info))))
		 (typecase interesting
		   (error (type-of interesting))
		   (t interesting)))))
      (format stream " (~A ~A ~A ~A)"
	      :file
	      (pretty-info passwd-file-info)
	      (pretty-info group-file-info)
	      (pretty-info hosts-file-info))))))

(defmethod (:reset file-unix-name-lookup-access-path-mixin :after)
	   ()
  (setq use-file-for-unix-name-lookup nil)
  (setq use-hosts-file-for-unix-name-lookup nil)
  (clrhash file-username-passwd-hash-table)
  (clrhash file-uid-passwd-hash-table)
  (clrhash file-groupname-group-hash-table)
  (clrhash file-gid-group-hash-table)
  (clrhash file-username-gids-hash-table)
  (clrhash file-hostname-host-hash-table)
  (clrhash file-address-host-hash-table)
  (setq passwd-file-info nil)
  (setq group-file-info nil)
  (setq hosts-file-info nil)
  (setq file-group-database nil))

(defparameter *file-unix-name-lookup-cache-validity-time* (* 20 60 60)
  "The time that cached file unix-name-lookup values are valid (60ths of a second).")

(defparameter *use-file-for-unix-name-lookup* t
  "Setting this to NIL disables the use of the passwd and group files for unix-name-lookup.")

;;; SYS:NFS;NFS-COMMON sets this to T.
(defparameter *default-use-file-for-unix-name-lookup* nil
  "Default choice for use of the passwd and group files for unix-name-lookup.")

(defun-in-flavor (use-file-for-unix-name-lookup-p
		   file-unix-name-lookup-access-path-mixin)
		 ()
  (when *use-file-for-unix-name-lookup*
    (unless (and use-file-for-unix-name-lookup
		 (not (time:time-elapsed-p *file-unix-name-lookup-cache-validity-time*
					   (second use-file-for-unix-name-lookup))))
      (setq use-file-for-unix-name-lookup
	    (list (if *default-use-file-for-unix-name-lookup*
		      (and (get-host-prop-boolean host :rpc-use-file t)
			   (get-host-prop-boolean host :nfs-use-file t))
		    (or (get-host-prop-boolean host :rpc-use-file nil)
			(get-host-prop-boolean host :nfs-use-file nil)))
		  (time:time))))
    (first use-file-for-unix-name-lookup)))

(defvar *file-unix-name-lookup-access-path-open-host-file-access-path-alist* nil)

(defun-in-flavor (file-unix-name-lookup-access-path-open
		   file-unix-name-lookup-access-path-mixin)
		 (pathname &rest options)
  (let* ((translated-pathname (send pathname :translated-pathname))
	 (file-access-path
	  (second
	    (assoc (send translated-pathname :host)
		   *file-unix-name-lookup-access-path-open-host-file-access-path-alist*))))
    (if  file-access-path
	 (apply #'fs:file-access-path-open
		file-access-path translated-pathname pathname options)
      (apply #'open pathname options))))

(defgeneric file-unix-name-lookup-access-path-modification-date
	    (file-unix-name-lookup-access-path stream-or-pathname)
  (declare (values modification-date)))

(defmethod (file-unix-name-lookup-access-path-modification-date
	     file-unix-name-lookup-access-path-mixin
	     :default)
	   (stream-or-pathname)
  (condition-case ()
       (let ((properties (cdr (send stream-or-pathname :properties))))
	 (or (getf properties :modification-date)
	     (getf properties :creation-date)))
     (fs:file-error nil)))

(defun-in-flavor (file-name file-unix-name-lookup-access-path-mixin)
		 (keyword unix-default default)
  (let ((string (or (get-host-prop-string host keyword nil)
		    (and (typep host 'net:host-unix-mixin) unix-default)
		    default)))
    (and string
	 (condition-case (error)
	      (fs:parse-pathname string nil (fs:default-pathname nil host))
	    (fs:pathname-error error)))))

(defun-in-flavor (file-make-passwd file-unix-name-lookup-access-path-mixin)
		 (decoded-line &key username password uid gid gecos home-directory shell)
  (let* ((new-entry
	   (list (and decoded-line
		      (make-passwd
			:username username
			:password password
			:uid uid
			:gid gid
			:gecos gecos
			:home-directory home-directory
			:shell shell))
		 (time:time))))
    (update-entry-in-table new-entry username file-username-passwd-hash-table
			   *file-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry uid file-uid-passwd-hash-table
			   *file-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defparameter *default-unix-passwd-file-name-for-unix-name-lookup* "/etc/passwd"
  "Default passwd file name for file unix-name-lookup for UNIX hosts.")

(defparameter *default-passwd-file-name-for-unix-name-lookup* nil
  "Default passwd file name for file unix-name-lookup for hosts of any type.")

(defun-in-flavor (passwd-file-name file-unix-name-lookup-access-path-mixin)
		 ()
  (file-name :rpc-passwd-file
	     *default-unix-passwd-file-name-for-unix-name-lookup*
	     *default-passwd-file-name-for-unix-name-lookup*))

(defun-in-flavor (file-check file-unix-name-lookup-access-path-mixin)
		 (info pathname-function read-function)
  (declare (sys:downward-funarg pathname-function read-function))
  (with-recursion-prevented (file-unix-name-lookup)
    (process:with-lock (file-read-lock)
      (when (or (null info)
		(and (time:time-elapsed-p
		       *file-unix-name-lookup-cache-validity-time* (second info))
		     (prog1
		       (let ((pathname (funcall pathname-function)))
			 (and (pathnamep pathname) 
			      (or (neq (first (first info)) pathname)
				  (and (rest (first info))
				       (or (errorp (second (first info)))
					   (not (eql (third (first info))
						     (file-unix-name-lookup-access-path-modification-date
						       self (second (first info))))))))))
		       (setf (second info) (time:time)))))
	(funcall read-function)))))

(defun-in-flavor (file-info file-unix-name-lookup-access-path-mixin)
		 (pathname other)
  (list (cons pathname
	      (etypecase other
		(stream
		  (list (send other :truename)
			(file-unix-name-lookup-access-path-modification-date self other)))
		(error
		  (list other))
		(null
		  nil)))
	(time:time)))

(defun-in-flavor (read-passwd-file file-unix-name-lookup-access-path-mixin)
		 ()
  (let ((pathname (passwd-file-name)))
    (if (pathnamep pathname)
	(condition-case (error)
	     (with-open-stream (stream (file-unix-name-lookup-access-path-open
					 pathname
					 :direction :input
					 :element-type 'character
					 :if-does-not-exist :error))
	       (loop initially (clrhash file-username-passwd-hash-table)
			       (clrhash file-uid-passwd-hash-table)
		     for (line eofp) = (multiple-value-list (send stream :line-in))
		     for decoded-line = (decode-passwd-line line)
		     when decoded-line
		       do (file-make-passwd
			    decoded-line
			    :username (first decoded-line)
			    :password (second decoded-line)
			    :uid (third decoded-line)
			    :gid (fourth decoded-line)
			    :gecos (fifth decoded-line)
			    :home-directory (sixth decoded-line)
			    :shell (seventh decoded-line))
		     until eofp
		     finally (setq passwd-file-info (file-info pathname stream))))
	   ((sys:network-error fs:file-error)
	    (setq passwd-file-info (file-info pathname error))))
      (setq passwd-file-info (file-info pathname nil)))))

(defmethod (username->passwd file-unix-name-lookup-access-path-mixin)
	   (username)
  (when (use-file-for-unix-name-lookup-p)
    (file-check passwd-file-info #'passwd-file-name #'read-passwd-file)
    (let ((entry (gethash username file-username-passwd-hash-table)))
      (if entry
	  (first entry)
	(file-make-passwd
	  nil
	  :username username)))))

(defmethod (uid->passwd file-unix-name-lookup-access-path-mixin)
	   (uid)
  (when (use-file-for-unix-name-lookup-p)
    (file-check passwd-file-info #'passwd-file-name #'read-passwd-file)
    (let ((entry (gethash uid file-uid-passwd-hash-table)))
      (if entry
	  (first entry)	(file-make-passwd
	  nil
	  :uid uid)))))

(defun-in-flavor (file-make-group file-unix-name-lookup-access-path-mixin)
		 (decoded-line &key groupname password gid usernames)
  (let* ((new-entry
	   (list (and decoded-line
		      (make-group
			:groupname groupname
			:password password
			:gid gid
			:usernames usernames))
		 (time:time))))
    (update-entry-in-table new-entry groupname file-groupname-group-hash-table
			   *file-unix-name-lookup-cache-validity-time*)
    (update-entry-in-table new-entry gid file-gid-group-hash-table
			   *file-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defparameter *default-unix-group-file-name-for-unix-name-lookup* "/etc/group"
  "Default group file name for file unix-name-lookup for UNIX hosts.")

(defparameter *default-group-file-name-for-unix-name-lookup* nil
  "Default group file name for file unix-name-lookup for hosts of any type.")

(defun-in-flavor (group-file-name file-unix-name-lookup-access-path-mixin)
		 ()
  (file-name :rpc-group-file
	     *default-unix-group-file-name-for-unix-name-lookup*
	     *default-group-file-name-for-unix-name-lookup*))

(defun-in-flavor (file-make-gids file-unix-name-lookup-access-path-mixin)
		 (username &key gids)
  (let* ((new-entry
	   (list (make-gids :gids gids)
		 (time:time))))
    (update-entry-in-table new-entry username file-username-gids-hash-table
			   *file-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defun-in-flavor (read-group-file file-unix-name-lookup-access-path-mixin)
		 ()
  (let ((pathname (group-file-name)))
    (if (pathnamep pathname)
	(condition-case (error)
	     (with-open-stream (stream (file-unix-name-lookup-access-path-open
					 pathname
					 :direction :input
					 :element-type 'character
					 :if-does-not-exist :error))
	       (loop initially (clrhash file-groupname-group-hash-table)
			       (clrhash file-gid-group-hash-table)
		     for (line eofp) = (multiple-value-list (send stream :line-in))
		     for decoded-line = (decode-group-line line)
		     when decoded-line
		       collect decoded-line into decoded-lines
		       and do (file-make-group
				decoded-line
				:groupname (first decoded-line)
				:password (second decoded-line)
				:gid (third decoded-line)
				:usernames (fourth decoded-line))
		     until eofp
		     finally (setq group-file-info (file-info pathname stream))
			     (setq file-group-database (list decoded-lines nil))))
	   ((sys:network-error fs:file-error)
	    (setq group-file-info (file-info pathname error))
	    (setq file-group-database (list nil nil))))
      (setq group-file-info (file-info pathname nil)))))

(defmethod (group-database-needs-rebuilding file-unix-name-lookup-access-path-mixin)
	   ()
  (and (use-file-for-unix-name-lookup-p)
       (progn (file-check group-file-info #'group-file-name #'true)
	      (null (second file-group-database)))))

(defmethod (group-database file-unix-name-lookup-access-path-mixin)
	   ()
  (when (use-file-for-unix-name-lookup-p)
    (file-check group-file-info #'group-file-name #'read-group-file)
    (first file-group-database)))

(defmethod (group-database-rebuild file-unix-name-lookup-access-path-mixin)
	   (new-database)
  (when (use-file-for-unix-name-lookup-p)
    (clrhash file-username-gids-hash-table)
    (group-database-username-gids new-database #'file-make-gids)
    (when file-group-database
      (setf (second file-group-database) (time:time)))))

(defmethod (groupname->group file-unix-name-lookup-access-path-mixin)
	   (groupname)
  (when (use-file-for-unix-name-lookup-p)
    (file-check group-file-info #'group-file-name #'read-group-file)
    (let ((entry (gethash groupname file-groupname-group-hash-table)))
      (if entry
	  (first entry)
	(file-make-group
	  nil
	  :groupname groupname)))))

(defmethod (gid->group file-unix-name-lookup-access-path-mixin)
	   (gid)
  (when (use-file-for-unix-name-lookup-p)
    (file-check group-file-info #'group-file-name #'read-group-file)
    (let ((entry (gethash gid file-gid-group-hash-table)))
      (if entry
	  (first entry)
	(file-make-group
	  nil
	  :gid gid)))))

(defmethod (username->gids file-unix-name-lookup-access-path-mixin)
	   (username)
  (when (use-file-for-unix-name-lookup-p)
    (group-database-check)
    (let ((entry (gethash username file-username-gids-hash-table)))
      (if entry
	  (first entry)
	(file-make-gids
	  username :gids (if file-group-database (ncons nil) nil))))))

(defparameter *use-hosts-file-for-unix-name-lookup* t
  "Setting this to NIL disables the use of the hosts file for unix-name-lookup.")

(defparameter *default-use-hosts-file-for-unix-name-lookup* nil
  "Default choice for use of the hosts file for unix-name-lookup.")

(defun-in-flavor (use-hosts-file-for-unix-name-lookup-p
		   file-unix-name-lookup-access-path-mixin)
		 ()
  (when *use-hosts-file-for-unix-name-lookup*
    (unless (and use-hosts-file-for-unix-name-lookup
		 (not (time:time-elapsed-p *file-unix-name-lookup-cache-validity-time*
					   (second use-hosts-file-for-unix-name-lookup))))
      (setq use-hosts-file-for-unix-name-lookup
	    (list (if *default-use-hosts-file-for-unix-name-lookup*
		      (and (get-host-prop-boolean host :rpc-use-hosts-file t)
			   (get-host-prop-boolean host :nfs-use-hosts-file t))
		    (or (get-host-prop-boolean host :rpc-use-hosts-file nil)
			(get-host-prop-boolean host :nfs-use-hosts-file nil)))
		  (time:time))))
    (first use-hosts-file-for-unix-name-lookup)))

(defun-in-flavor (file-make-host file-unix-name-lookup-access-path-mixin)
		 (decoded-line &key address hostnames)
  (let* ((new-entry
	   (list (and decoded-line
		      (make-host
			:address address
			:hostnames hostnames))
		 (time:time))))
    (loop for hostname in hostnames do
      (update-entry-in-table new-entry hostname file-hostname-host-hash-table
			     *file-unix-name-lookup-cache-validity-time*))
    (update-entry-in-table new-entry address file-address-host-hash-table
			   *file-unix-name-lookup-cache-validity-time*)
    (first new-entry)))

(defparameter *default-unix-hosts-file-name-for-unix-name-lookup* "/etc/hosts"
  "Default hosts file name for file unix-name-lookup for UNIX hosts.")

(defparameter *default-hosts-file-name-for-unix-name-lookup* nil
  "Default hosts file name for file unix-name-lookup for hosts of any type.")

(defun-in-flavor (hosts-file-name file-unix-name-lookup-access-path-mixin)
		 ()
  (file-name :rpc-hosts-file
	     *default-unix-hosts-file-name-for-unix-name-lookup*
	     *default-hosts-file-name-for-unix-name-lookup*))

(defun-in-flavor (read-hosts-file file-unix-name-lookup-access-path-mixin)
		 ()
  (let ((pathname (hosts-file-name)))
    (if (pathnamep pathname)
	(condition-case (error)
	     (with-open-stream (stream (file-unix-name-lookup-access-path-open
					 pathname
					 :direction :input
					 :element-type 'character
					 :if-does-not-exist :error))
	       (loop initially (clrhash file-hostname-host-hash-table)
			       (clrhash file-address-host-hash-table)
		     for (line eofp) = (multiple-value-list (send stream :line-in))
		     for decoded-line = (decode-hosts-line line)
		     when decoded-line
		       do (file-make-host
			    decoded-line
			    :address (first decoded-line)
			    :hostnames (rest decoded-line))
		     until eofp
		     finally (setq hosts-file-info (file-info pathname stream))))
	   ((sys:network-error fs:file-error)
	    (setq hosts-file-info (file-info pathname error))))
      (setq hosts-file-info (file-info pathname nil)))))

(defmethod (hostname->host file-unix-name-lookup-access-path-mixin)
	   (hostname)
  (when (use-hosts-file-for-unix-name-lookup-p)
    (file-check hosts-file-info #'hosts-file-name #'read-hosts-file)
    (let ((entry (gethash hostname file-hostname-host-hash-table)))
      (if entry
	  (first entry)
	(file-make-host
	  nil
	  :hostnames (ncons hostname))))))

(defmethod (address->host file-unix-name-lookup-access-path-mixin)
	   (address)
  (when (use-hosts-file-for-unix-name-lookup-p)
    (file-check hosts-file-info #'hosts-file-name #'read-hosts-file) 
    (let ((entry (gethash address file-address-host-hash-table)))
      (if entry
	  (first entry)
	(file-make-host
	  nil
	  :address address)))))

;;; Hook it up to the system

(defflavor unix-name-lookup-access-path
	()
	(unix-name-lookup-access-path-mixin
	 file-unix-name-lookup-access-path-mixin
	 yellow-pages-unix-name-lookup-access-path-mixin
	 namespace-unix-name-lookup-access-path-mixin
	 default-unix-name-lookup-access-path-mixin)
  )

(compile-flavor-methods unix-name-lookup-access-path)

(defvar *unix-name-lookup-access-paths* nil
  "The list of all UNIX-name-lookup access paths.")

(defmethod (host-unix-name-lookup-access-path net:host)
	   ()
  (first (or (member self *unix-name-lookup-access-paths*
		     :test #'neti:ns-eq
		     :key #'unix-name-lookup-access-path-host)
	     (push (make-instance 'unix-name-lookup-access-path :host self)
		   *unix-name-lookup-access-paths* :localize 1))))

(defun reset-all-unix-name-lookup-access-paths (&optional forget-p)
  (loop for path in *unix-name-lookup-access-paths*
	    do (send path :reset))
  (when forget-p (setq *unix-name-lookup-access-paths* nil)))

(add-initialization
  "Reset All UNIX-NAME-LOOKUP Access Paths"
  '(reset-all-unix-name-lookup-access-paths)
  ()
  'neti:after-network-initialization-list)

(add-initialization
  "Forget All UNIX-NAME-LOOKUP Access Paths"
  '(reset-all-unix-name-lookup-access-paths t)
  ()
  'si:system-shutdown-initialization-list)
