;;; -*- Mode: LISP; Syntax: Common-lisp; Package: RPC; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;; UDP Transport agent

;;; big packets are word aligned so we can use them for XDR blocks

(defstruct (sub-packet-xdr-block
	     (:type :array-leader)
	     :size-symbol
	     (:print-function print-sub-packet-xdr-block)
	     (:constructor nil)
	     (:copier nil)
	     (:include neti:sub-packet))
  data-size
  agent
  module-number
  module-version
  entry-number
  )

(defun print-sub-packet-xdr-block (block stream i-prindepth)
  (declare (ignore i-prindepth))
  (printing-random-object (block stream :typep)
    (condition-case (error)
	 (let ((agent (sub-packet-xdr-block-agent block)))
	   (prin1 (array-total-size block) stream)
	   (when (and agent
		      (variable-boundp #'print-xdr-block)
		      (not (zerop (sub-packet-xdr-block-data-size block))))
	     (write-char #\Space stream)
	     (print-xdr-block
	       block agent stream
	       (sub-packet-xdr-block-module-number block)
	       (sub-packet-xdr-block-module-version block)
	       (sub-packet-xdr-block-entry-number block))))
       (error
	 (write-char #\! stream)
	 (prin1 (type-of error) stream)))))

(defflavor sub-packets-for-xdr-blocks
	((sub-packet-server-info nil))
	()
  (:abstract-flavor))

(defmethod (initialize-sub-packet-xdr-block sub-packets-for-xdr-blocks) (block agent size)
  (declare (values block))
  (setf (sub-packet-xdr-block-data-size block) size)
  (setf (sub-packet-xdr-block-agent block) agent)
  (setf (sub-packet-xdr-block-module-number block) nil)
  (setf (sub-packet-xdr-block-module-version block) nil)
  (setf (sub-packet-xdr-block-entry-number block) nil)
  block)

(defmethod (allocate-xdr-block sub-packets-for-xdr-blocks) (size)
  (initialize-sub-packet-xdr-block
    self
    (neti:get-sub-packet
      (neti:allocate-big-packet (+ tcp::ip-header-size tcp::udp-header-size (* (+ size 1) 4)))
      'art-fixnum (+ tcp::ip-header-size tcp::udp-header-size) sub-packet-xdr-block-size
      'sub-packet-xdr-block)
    self
    size))

(defmethod (stack-allocate-xdr-block sub-packets-for-xdr-blocks) (size)
  (allocate-xdr-block self size))

(defmethod (release-xdr-block sub-packets-for-xdr-blocks) (block)
  (initialize-sub-packet-xdr-block self block nil nil)
  (neti:deallocate-big-packet block))

(defwhopper (copy-xdr-block sub-packets-for-xdr-blocks) (block)
  (let ((copy (continue-whopper block)))
    (setf (sub-packet-xdr-block-agent copy)
	  (sub-packet-xdr-block-agent block))
    (setf (sub-packet-xdr-block-module-number copy)
	  (sub-packet-xdr-block-module-number block))
    (setf (sub-packet-xdr-block-module-version copy)
	  (sub-packet-xdr-block-module-version block))
    (setf (sub-packet-xdr-block-entry-number copy)
	  (sub-packet-xdr-block-entry-number block))
    copy))

(defmethod (xdr-block-data-pointer sub-packets-for-xdr-blocks) (block)
  (locf (aref (array-indirect-pointer block) (array-index-offset-field block))))

(defmethod (xdr-block-data-size sub-packets-for-xdr-blocks) (block)
  (sub-packet-xdr-block-data-size block))

(defstruct sub-packets-for-xdr-blocks-future
  future
  module-number
  module-version
  entry-number)

;;; Save the module number, version and entry number for later.
(defwhopper (send-call-starting-future sub-packets-for-xdr-blocks)
	    (block &optional dont-release)
  (multiple-value-bind (ignore module-number module-version entry-number)
      (decode-call-block self block)
    (make-sub-packets-for-xdr-blocks-future
      :future (continue-whopper block dont-release)
      :module-number module-number
      :module-version module-version
      :entry-number entry-number)))

;;; Stash the saved module number, version and entry number onto the reply so
;;; it can be self-identifying (for printing, tracing, etc.)
(defwhopper (wait-for-future sub-packets-for-xdr-blocks) (future &optional whostate)
  (let ((reply (continue-whopper (sub-packets-for-xdr-blocks-future-future future) whostate)))
    (when reply 
      (setf (sub-packet-xdr-block-module-number reply)
	    (sub-packets-for-xdr-blocks-future-module-number future))
      (setf (sub-packet-xdr-block-module-version reply)
	    (sub-packets-for-xdr-blocks-future-module-version future))
      (setf (sub-packet-xdr-block-entry-number reply)
	    (sub-packets-for-xdr-blocks-future-entry-number future)))
    reply))

;;; Don't forget that we've hacked the future.
(defwhopper (abort-future sub-packets-for-xdr-blocks) (future)
  (continue-whopper (sub-packets-for-xdr-blocks-future-future future)))

;;; Stash the module number, version and entry number into the reply so it can
;;; be self-identifying (for printing, tracing, etc.)
(defwhopper (send-call-and-wait sub-packets-for-xdr-blocks)
	    (block &optional whostate dont-release)
  (multiple-value-bind (ignore module-number module-version entry-number)
      (decode-call-block self block)
    (let ((reply (continue-whopper block whostate dont-release)))
      (when reply 
	(setf (sub-packet-xdr-block-module-number reply) module-number)
	(setf (sub-packet-xdr-block-module-version reply) module-version)
	(setf (sub-packet-xdr-block-entry-number reply) entry-number))
      reply)))

;;; Save the module number, version and entry number so that it can be stashed into the reply
(defwhopper (agent-run-remote-call-handler sub-packets-for-xdr-blocks)
	    (handler transaction-id xdr-block xdr-pointer xdr-limit
		     module-number module-version entry-number
		     credential verifier credential-approved)
  (with-stack-list (info transaction-id module-number module-version entry-number)
    (letf ((sub-packet-server-info info))
      (continue-whopper handler transaction-id xdr-block xdr-pointer xdr-limit
			module-number module-version entry-number
			credential verifier credential-approved))))

;;; Stash the saved module number, version and entry number into the reply
(defwhopper (xdr-initiate-reply sub-packets-for-xdr-blocks)
	    (transaction-id values-size &optional verifier dont-stack-allocate)
  (multiple-value-bind (xdr-block xdr-pointer xdr-limit)
      (continue-whopper transaction-id values-size verifier dont-stack-allocate)
    (when sub-packet-server-info
      (destructuring-bind
	(call-transaction-id call-module-number call-module-version call-entry-number)
	  sub-packet-server-info
	(when (eql transaction-id call-transaction-id)
	  (setf (sub-packet-xdr-block-module-number xdr-block) call-module-number)
	  (setf (sub-packet-xdr-block-module-version xdr-block) call-module-version)
	  (setf (sub-packet-xdr-block-entry-number xdr-block) call-entry-number))))
    (values xdr-block xdr-pointer xdr-limit)))

;;; Stash the saved module number, version and entry number into the reply
(defwhopper (xdr-initiate-error-internal sub-packets-for-xdr-blocks)
	    (transaction-id accept-status lowest-module-version highest-module-version
			    module-number module-version entry-number
			    actual-module-version error-number arguments-size
			    verifier dont-stack-allocate)
  (multiple-value-bind (xdr-block xdr-pointer xdr-limit)
      (continue-whopper 
	transaction-id accept-status lowest-module-version highest-module-version
	module-number module-version entry-number
	actual-module-version error-number arguments-size
	verifier dont-stack-allocate)
    (when sub-packet-server-info
      (destructuring-bind
	(call-transaction-id call-module-number call-module-version call-entry-number)
	  sub-packet-server-info
	(when (eql transaction-id call-transaction-id)
	  (setf (sub-packet-xdr-block-module-number xdr-block) call-module-number)
	  (setf (sub-packet-xdr-block-module-version xdr-block) call-module-version)
	  (setf (sub-packet-xdr-block-entry-number xdr-block) call-entry-number))))
    (values xdr-block xdr-pointer xdr-limit)))

;;; Stash the saved module number, version and entry number into the reply
(defwhopper (xdr-initiate-auth-error sub-packets-for-xdr-blocks)
	    (transaction-id auth-stat arguments-size &optional dont-stack-allocate)
  (multiple-value-bind (xdr-block xdr-pointer xdr-limit)
      (continue-whopper transaction-id auth-stat arguments-size dont-stack-allocate)
    (declare (special sub-packets-for-xdr-blocks-server-info))
    (when sub-packet-server-info
      (destructuring-bind
	(call-transaction-id call-module-number call-module-version call-entry-number)
	  sub-packet-server-info
	(when (eql transaction-id call-transaction-id)
	  (setf (sub-packet-xdr-block-module-number xdr-block) call-module-number)
	  (setf (sub-packet-xdr-block-module-version xdr-block) call-module-version)
	  (setf (sub-packet-xdr-block-entry-number xdr-block) call-entry-number))))
    (values xdr-block xdr-pointer xdr-limit)))

(defflavor std-big-ender-sub-packet-transport-agent ()
	   (big-ender-data sub-packets-for-xdr-blocks std-transport-agent)
  (:abstract-flavor))

(defmethod (call-block-transaction-id std-big-ender-sub-packet-transport-agent) (block)
  (byte-swap (aref block 0)))

(defmethod (decode-call-block std-big-ender-sub-packet-transport-agent) (block)
  (declare (values transaction-id module-number module-version entry-number))
  (values (byte-swap (aref block 0))
	  (byte-swap (aref block 3))
	  (byte-swap (aref block 4))
	  (byte-swap (aref block 5))))

(defmethod (xdr-block-message-type std-big-ender-sub-packet-transport-agent) (block)
  (byte-swap (aref block 1)))

(defmethod (reply-block-transaction-id std-big-ender-sub-packet-transport-agent) (block)
  (byte-swap (aref block 0)))

(defmethod (decode-reply-block std-big-ender-sub-packet-transport-agent) (block)
  (declare (values reply-status accept-status verifier-flavor low high
		   reject-status auth-status))
  (decode-reply-block-body `(byte-swap (aref block ,offset))))

(defflavor std-little-ender-sub-packet-transport-agent ()
	   (little-ender-data sub-packets-for-xdr-blocks std-transport-agent)
  (:abstract-flavor))

(defmethod (call-block-transaction-id std-little-ender-sub-packet-transport-agent) (block)
  (aref block 0))

(defmethod (decode-call-block std-little-ender-sub-packet-transport-agent) (block)
  (declare (values transaction-id module-number module-version entry-number))
  (values (aref block 0) (aref block 3) (aref block 4) (aref block 5)))

(defmethod (xdr-block-message-type std-little-ender-sub-packet-transport-agent) (block)
  (aref block 1))

(defmethod (reply-block-transaction-id std-little-ender-sub-packet-transport-agent) (block)
  (aref block 0))

(defmethod (decode-reply-block std-little-ender-sub-packet-transport-agent) (block)
  (declare (values reply-status accept-status verifier-flavor low high
		   reject-status auth-status))
  (decode-reply-block-body `(aref block ,offset)))

;;; Stuff common to port-mapping and single-connection udp transport agents.
(defflavor udp-transport-agent-mixin
	((reply-alist)
	 (reply-alist-lock (process:make-lock "UDP Reply Alist Lock"))
	 (waiting-for-call nil)
	 (call-timeout nil)
	 (call-retransmit-timeouts nil)
	 (connection-idle-timeout nil)
	 (dependents nil))
	()
  (:required-methods remote-host)
  (:required-flavors std-transport-agent server-process-mixin call-retrying-mixin)
  (:abstract-flavor)
  (:initable-instance-variables
   call-timeout call-retransmit-timeouts connection-idle-timeout))

(defmethod (udp-agent-note-dependent udp-transport-agent-mixin)
	   (dependent &optional delete-p)
  (if delete-p
      (setq dependents (delete dependent dependents))
    (pushnew dependent dependents)))

(defmethod (network-agent-p udp-transport-agent-mixin) () t)

(defgeneric dependent-note-udp-agent-closed (udp-udp-agent-dependent udp-agent)
  "Called for each noted dependent by a UDP agent as it is closing.")

(defmethod (:close udp-transport-agent-mixin :after) (ignore)
  (loop for dependent in dependents
	do (dependent-note-udp-agent-closed dependent self)))

(defparameter *udp-parameter-cache-validity-time* (* 20 60 60)
  "The time that cached namespace-specified UDP parameters are valid (60ths of a second).")

(defun-in-flavor (get-host-prop-string udp-transport-agent-mixin)
		 (keyword default-value)
  (let* ((host (remote-host self))
	 ;; Don't touch the namespace from inside the server portion of the code!
	 (neti:*inhibit-validity-checking*
	   (or neti:*inhibit-validity-checking* *inside-rpc-dispatch-process*))
	 (host-string (send host :user-get keyword)))
    (if (stringp host-string)
	host-string
      (let* ((site (send host :site))
	     (site-string (and (typep site 'neti:site) (send site :user-get keyword))))
	(if (stringp site-string)
	    site-string
	  (loop for namespace in (append (and (typep site 'neti:site)
					      (ncons (send site :local-namespace)))
					 (send host :namespaces))
		for namespace-string = (send namespace :user-get keyword)
		when (stringp namespace-string)
		  return namespace-string
		finally (return default-value)))))))

(defun-in-flavor (get-host-prop-integer udp-transport-agent-mixin)
		 (keyword default-value)
  (let ((string (get-host-prop-string keyword "")))
    (or (parse-integer string :junk-allowed t)
	default-value)))

(defun-in-flavor (get-host-prop-integer-list udp-transport-agent-mixin)
		 (keyword default-value)
  (let ((string (get-host-prop-string keyword "")))
    (or (loop for start first 0 then end
	      for (integer end) =
		  (multiple-value-list (parse-integer string :start start :junk-allowed t))
	      while integer
	      collect integer)
	default-value)))

(defvar *udp-call-timeout* nil)
(defparameter *default-udp-call-timeout* (* 29 60))

(defun-in-flavor (call-timeout udp-transport-agent-mixin) ()
  (or *udp-call-timeout*
      (progn 
	(when (or (null call-timeout)
		  (and (numberp (second call-timeout))
		       (time:time-elapsed-p
			 *udp-parameter-cache-validity-time*
			 (second call-timeout))))
	  (setq call-timeout
		(list (get-host-prop-integer :rpc-udp-call-timeout *default-udp-call-timeout*)
		      (time:time))))
	(first call-timeout))))

(defvar *udp-call-retransmit-timeouts* nil)
(defparameter *default-udp-call-retransmit-timeouts* '(60 120 240 480 840))

(defun-in-flavor (call-retransmit-timeouts udp-transport-agent-mixin) ()
  (or *udp-call-retransmit-timeouts*
      (progn 
	(when (or (null call-retransmit-timeouts)
		  (and (numberp (second call-retransmit-timeouts))
		       (time:time-elapsed-p
			 *udp-parameter-cache-validity-time*
			 (second call-retransmit-timeouts))))
	  (setq call-retransmit-timeouts
		(list (get-host-prop-integer-list
			:rpc-udp-call-retransmit-timeouts
			*default-udp-call-retransmit-timeouts*)
		      (time:time))))
	(first call-retransmit-timeouts))))

(defvar *udp-rpc-connection-idle-timeout* nil)
(defparameter *default-udp-rpc-connection-idle-timeout* (* 3 60 60))

(defun-in-flavor (connection-idle-timeout udp-transport-agent-mixin) ()
  (or *udp-rpc-connection-idle-timeout*
      (progn
	(when (or (null connection-idle-timeout)
		  (and (numberp (second connection-idle-timeout))
		       (time:time-elapsed-p
			 *udp-parameter-cache-validity-time*
			 (second connection-idle-timeout))))
	  (setq connection-idle-timeout
		(list (get-host-prop-integer
			:rpc-udp-connection-idle-timeout
			*default-udp-rpc-connection-idle-timeout*)
		      (time:time))))
	(first connection-idle-timeout))))

(defflavor udp-rpc-host-not-responding
	(module-number module-version entry-number)
	(rpc-error
	 net:host-not-responding-during-connection)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:network udp-rpc-host-not-responding) ()
  (neti:local-network-of-type :internet))

(defmethod (:print-request-name udp-rpc-host-not-responding) (stream)
  (format stream "~A" neti:connection))

(compile-flavor-methods udp-rpc-host-not-responding)

(defstruct udp-future
  queue-element
  initial-time)

(defmethod (send-call-starting-future udp-transport-agent-mixin)
	   (block &optional dont-release)
  (let* ((transaction-id (call-block-transaction-id self block))
	 (queue-element (list transaction-id nil *current-process* nil)))
    (process:atomic-push queue-element reply-queue)
    (send-xdr-block self block dont-release)
    (make-udp-future :queue-element queue-element :initial-time (time:time))))

(defmethod (wait-for-future udp-transport-agent-mixin) (future &optional whostate)
  (let* ((queue-element (udp-future-queue-element future))
	 (reply 
	   (unwind-protect 
	       (or (and (second queue-element)
			(prog1 (second queue-element) (setf (second queue-element) nil)))
		   (let ((timeout (- (first (call-retransmit-timeouts))
				     (time:time-difference
				       (time:time) (udp-future-initial-time future)))))
		     (when (plusp timeout)
		       (process:block-with-timeout
			 (/ (float timeout) 60.0) (or whostate "Remote Call")
			 #'(lambda () (not (null (second queue-element)))))
		       (prog1 (second queue-element) (setf (second queue-element) nil))))
		   (signal 'retry-call :agent self :transaction-id (first queue-element))
		   (error "Should have retried."))
	     (process:atomic-replacef reply-queue (remove queue-element reply-queue))
	     (when (and (second queue-element) (not (errorp (second queue-element))))
	       (release-xdr-block
		 self (prog1 (second queue-element) (setf (second queue-element) nil)))))))
    (if (errorp reply) (signal reply) reply)))

;;; Remove the queue entry from the reply queue.
(defmethod (abort-future udp-transport-agent-mixin) (future)
  (let ((queue-element (udp-future-queue-element future)))
    (process:atomic-replacef reply-queue (remove queue-element reply-queue))
    ;; Release any extra reply block
    (when (and (second queue-element) (not (errorp (second queue-element))))
      (release-xdr-block
	self (prog1 (second queue-element) (setf (second queue-element) nil))))))

(defmethod (send-call-and-wait udp-transport-agent-mixin)
	   (block &optional whostate dont-release)
  (let* ((transaction-id (call-block-transaction-id self block))
	 (queue-element (list transaction-id nil *current-process* nil))
	 (reply
	   (unwind-protect
	       (progn
		 (process:atomic-push queue-element reply-queue)
		 (send-xdr-block self block t)
		 (loop with retransmit-timeouts = (call-retransmit-timeouts)
		       with final-retransmit-timeout = (first (last retransmit-timeouts))
		       with initial-time = (time:time)
		       for retransmit-timeout =
			   (or (pop retransmit-timeouts) final-retransmit-timeout)
		       until (second queue-element)
		       do (process:block-with-timeout
			    (/ (float retransmit-timeout) 60.0) (or whostate "Remote Call")
			    #'(lambda () (not (null (second queue-element)))))
		       until (second queue-element)
		       when (let ((timeout (call-timeout)))
			      (and timeout (time:time-elapsed-p timeout initial-time)))
			 do (multiple-value-bind
			      (transaction-id module-number module-version entry-number)
				(decode-call-block self block)
			      (error 'udp-rpc-host-not-responding
				     :agent self
				     :transaction-id transaction-id
				     :connection (or whostate "Remote Call")
				     :foreign-host (remote-host self)
				     :module-number module-number
				     :module-version module-version
				     :entry-number entry-number))
		       do (send-xdr-block self block t)
		       finally
			 (return (prog1 (second queue-element)
					(setf (second queue-element) nil)))))
	     (process:atomic-replacef reply-queue (remove queue-element reply-queue))
	     ;; Release any extra reply block
	     (when (and (second queue-element) (not (errorp (second queue-element))))
	       (release-xdr-block
		 self (prog1 (second queue-element) (setf (second queue-element) nil))))      
	     (unless dont-release
	       (when block (release-xdr-block self block))))))
    (if (errorp reply) (signal reply) reply)))

;;; Provide for the standard retrying stuff.  This is in a whopper instead of
;;; the method because other mixins have whoppers for this method that go
;;; between this whopper and the method.
(defwhopper (send-call-and-wait udp-transport-agent-mixin)
	    (block &optional whostate dont-release)
  (if waiting-for-call
      (continue-whopper block whostate dont-release)
    (unwind-protect
	(letf ((waiting-for-call t))
	  (let ((*udp-call-timeout* (call-timeout)))
	    (neti:with-connection-retrying ((remote-host self)
					    (or whostate "Remote Call")
					    try-reason)
	      (when (eq try-reason :longer-timeout)
		(setq *udp-call-timeout* (+ *udp-call-timeout* *udp-call-timeout*)))
	      (when (eq try-reason :wait-indefinitely)
		(setq *udp-call-timeout* most-positive-fixnum))
	      (continue-whopper block whostate t))))
      (unless dont-release
	(when block (release-xdr-block self block))))))

(defmethod (rpc-dispatch-process-name udp-transport-agent-mixin) ()
  (format nil "RPC Dispatch (~A via UDP)" (remote-host self)))

(defmethod (rpc-dispatch-process-priority udp-transport-agent-mixin) ()
  ;; Lower than the priority of the ethernet receiver process.
  (process:make-process-priority :fg 9 :preemptive t))

(defmethod (high-latency-p udp-transport-agent-mixin) ()
  t)

;;; Since UDP is unreliable and depends upon retransmission, we will probably
;;; unexpected replies if we retransmitted calls before the first reply gets
;;; back.  Ignore all unexpected replies.
(defmethod (unexpected-reply-disposition udp-transport-agent-mixin) ()
  :ignore)

(defparameter *udp-notify* nil)

;;; modified version of :send-output-buffer
tcp::
(defmethod (:send-output-buffer-without-freeing udp-conn) (udp length &optional ignore)
  (setf (udp-leader-next udp) 't)
  (ip-store-16 local-port udp 0)
  (ip-store-16 foreign-port udp 2)
  (ip-store-16 length udp 4)
  (if no-checksum
      (progn (setf (udp-header-checksum-high udp) 0)
	     (setf (udp-header-checksum-low udp) 0))
    (ip-set-checksum-dont-care
      udp 0 6 length local-address foreign-address protocol-number length))
  (send udp-protocol :transmit-ip-packet udp length
	route local-address foreign-address nil)
  (incf pkts-out))

(defmethod (send-xdr-block-connection udp-transport-agent-mixin)
	   (block connection &optional dont-release)
  (when *udp-notify* (tv:notify nil "UDP RPC Send ~S:~%~S" connection block))
  (send connection (if dont-release :send-output-buffer-without-freeing :send-output-buffer)
	(neti:get-sub-packet
	  block 'art-8b (- tcp::udp-header-size) tcp::udp-leader-size 'tcp::udp-header)
	(+ tcp::udp-header-size (* (xdr-block-data-size self block) 4))))

(defmethod (receive-xdr-block-connection udp-transport-agent-mixin)
	   (connection no-hang-p timeout)
  (declare (values xdr-block))
  (let ((buffer nil)
	(start nil)
	(end nil))
    (unwind-protect 
	(progn 
	  (multiple-value-setq (buffer start end)
	    (send connection :next-input-buffer no-hang-p timeout))
	  (when buffer
	    (let* ((nbytes (- end start))
		   (block
		     (if (neti:big-packet-p buffer)
			 ;; The packet is a big packet, so the data in the packet is
			 ;; word-aligned.  We don't have to copy it.
			 (prog1
			   (neti:get-sub-packet
			     buffer 'art-fixnum start
			     sub-packet-xdr-block-size 'sub-packet-xdr-block)
			   (setq buffer nil))
		       ;; The data isn't in a big packet so it isn't word aligned.
		       ;; We have to copy it.
		       (let ((block (allocate-xdr-block self nbytes)))
			 (copy-array-portion
			   buffer start end (neti:get-sub-packet block 'art-8b 0) 0 nbytes)
			 block))))
	      (initialize-sub-packet-xdr-block self block self (%fixnum-ceiling nbytes 4))
	      (when *udp-notify* (tv:notify nil "UDP RPC Receive ~S:~%~S" connection block))
	      block)))
      (when buffer
	(send connection :discard-input-buffer (prog1 buffer (setq buffer nil)))))))

;;; Server support for retransmitting replies with transaction-ids that match
;;; calls.  This way we catch retransmitted calls for which we have already
;;; sent out replies.  If we didn't do this, a rapidly retransmitting client
;;; could completely bog us down if it retransmitted calls faster than we
;;; could service them.

(defparameter *udp-reply-alist-limit* 8)

(defun-in-flavor (release-replies udp-transport-agent-mixin) (replies)
  (loop for reply in replies
	do (process:with-lock (reply-alist-lock)
	     (setq reply-alist (delete reply reply-alist)))
	when (second reply)
	  do (release-xdr-block self (shiftf (second reply) nil))))

;;; Put a reply into the alist.  We have to copy the block since it might be
;;; stack-allocated.  If adding this reply to the alist makes the alist bigger
;;; than the size we want it, toss out the oldest replies in the alist to make
;;; it small enough again.
(defun-in-flavor (put-reply udp-transport-agent-mixin)
		 (block &optional dont-release)
  (let ((transaction-id (reply-block-transaction-id self block)))
    (unwind-protect
	(progn
	  (process:with-lock (reply-alist-lock)
	    (push (list transaction-id
			(if dont-release
			    (copy-xdr-block self block)
			  (prog1 block (setq block nil))))
		  reply-alist))
	  (release-replies (nthcdr *udp-reply-alist-limit* reply-alist)))
      (unless dont-release
	(when block (release-xdr-block self block))))))

;;; Get a reply from the alist if there is one.
(defun-in-flavor (get-reply udp-transport-agent-mixin)
		 (transaction-id module-number module-version entry-number)
  (process:with-lock (reply-alist-lock)
    (loop for reply in reply-alist
	  for (reply-transaction-id reply-xdr-block)  = reply
	  when (and (= transaction-id reply-transaction-id)
		    (= module-number (sub-packet-xdr-block-module-number reply-xdr-block))
		    (= module-version (sub-packet-xdr-block-module-version reply-xdr-block))
		    (= entry-number (sub-packet-xdr-block-entry-number reply-xdr-block)))
	    do (setq reply-alist (delete reply reply-alist))
	    and return reply-xdr-block)))

(defmethod (:close udp-transport-agent-mixin :before) (&optional mode)
  (declare (ignore mode))
  (release-replies reply-alist))

;;; Since we put replies in the reply alist, we should make sure that they
;;; aren't allocated on the stack.
(defwhopper (xdr-initiate-reply udp-transport-agent-mixin)
	    (transaction-id values-size &optional verifier dont-stack-allocate)
  (declare (ignore dont-stack-allocate))
  (continue-whopper transaction-id values-size verifier t))

;;; Since we put error replies in the reply alist too, we should make sure
;;; that they aren't allocated on the stack.
(defwhopper (xdr-initiate-error-internal udp-transport-agent-mixin)
	    (transaction-id accept-status lowest-module-version highest-module-version
			    module-number module-version entry-number
			    actual-module-version error-number arguments-size
			    verifier dont-stack-allocate)
  (declare (ignore dont-stack-allocate))
  (continue-whopper
    transaction-id accept-status lowest-module-version highest-module-version
    module-number module-version entry-number actual-module-version error-number
    arguments-size verifier t))

;;; Don't stack allocate these either
(defwhopper (xdr-initiate-auth-error udp-transport-agent-mixin)
	    (transaction-id auth-stat arguments-size &optional dont-stack-allocate)
  (declare (ignore dont-stack-allocate))
  (continue-whopper transaction-id auth-stat arguments-size t))

;;; Here's where we catch the replies and enter them into the alist.
(defwhopper (xdr-send-reply udp-transport-agent-mixin) (block &optional dont-release)
  (put-reply block dont-release)
  (continue-whopper block t))

;;; Catch error replies too.
(defwhopper (xdr-send-error udp-transport-agent-mixin) (block &optional dont-release)
  (put-reply block dont-release)
  (continue-whopper block t))

;;; Catch and reply to calls for which we have replies recently stored.  Maybe
;;; notify of all the rest.
(defwhopper (wait-for-call udp-transport-agent-mixin) (&optional credential verifier)
  (let (xdr-block xdr-pointer xdr-limit module-number module-version entry-number
	transaction-id cred verf reply-block)
    (loop do (multiple-value-setq
	       (xdr-block xdr-pointer xdr-limit module-number module-version entry-number
			  transaction-id cred verf)
	       (continue-whopper credential verifier))
	     (setq reply-block
		   (get-reply transaction-id module-number module-version entry-number))
	  while reply-block
	  do (release-xdr-block self (prog1 xdr-block (setq xdr-block nil)))
	     (xdr-send-reply self (prog1 reply-block (setq reply-block nil))))
    (values xdr-block xdr-pointer xdr-limit module-number module-version entry-number
	    transaction-id cred verf)))

(defwhopper (report-error-while-executing-server udp-transport-agent-mixin)
	    (transaction-id module-number module-version entry-number description
			    &optional verifier dont-stack-allocate)
  (condition-case ()
       (continue-whopper
	 transaction-id module-number module-version entry-number description
	 verifier dont-stack-allocate)
     (remote-network-error)))

;;; Port mapping agent is used for client RPC.
(defflavor port-mapping-udp-transport-agent-mixin
	(host
	 (connections nil)
	 (reply-connection-alist nil))
	(port-mapping-transport-agent-mixin)
  (:initable-instance-variables host)
  (:required-init-keywords :host)
  (:required-flavors udp-transport-agent-mixin server-process-mixin)
  (:abstract-flavor))

(defmethod (remote-host port-mapping-udp-transport-agent-mixin) ()
  host)

(defun-in-flavor (close-connection-entry port-mapping-udp-transport-agent-mixin)
		 (connection-entry &optional abort-p)
  (close (first connection-entry) :abort abort-p)
  (process:atomic-replacef connections (remove connection-entry connections))
  (process:atomic-replacef
    reply-connection-alist
    (remove (first connection-entry) reply-connection-alist :key #'second)))

(defun udp-protocol ()
  (tcp::internal-ip-protocol-instance
    (aref (send (tcp::internet-network-ip-protocol (net:local-network-of-type :internet))
		:protocol-array)
	  17)))

(defvar *privileged-local-udp-port-gensym* 1023)

;;; Local port numbers are kept low (below 1024) because Sun considers them to
;;; be privileged and doesn't allow some RPC access (like NFS) from ports
;;; other than these low numbered ports.
(defun privileged-local-udp-port-gensym ()
  (loop for local-port-gensym =
	    (process:atomic-replacef
	      *privileged-local-udp-port-gensym*
	      (+ 512 (%fixnum-mod (- *privileged-local-udp-port-gensym* 511) 512)))
	when (and (null (tcp:udp-port-protocol-name local-port-gensym))
		  (loop for conn in (send (udp-protocol) :conn-list)
			never (= local-port-gensym (send conn :local-port))))
	  return local-port-gensym))

(defun open-udp-connection (host foreign-port &rest options)
  (lexpr-send (udp-protocol) :get-udp-conn host foreign-port options))

(defun-in-flavor (port-connection port-mapping-udp-transport-agent-mixin) (foreign-port)
  (or (loop for (connection time) in connections
	    initially (progn time)
	    when (and (= foreign-port (send connection :foreign-port))
		      (not (send connection :dead)))
	      return connection)
      (let ((connection
	      (open-udp-connection host foreign-port
				   :local-port (privileged-local-udp-port-gensym)
				   :waiting-process (or process *current-process*)
				   :packet-size 10240)))
	(process:atomic-push (list connection (time:time)) connections)
	(when process (process:wakeup process))
	connection)))

;;; Make sure we send the reply back the right connection.
(defmethod (xdr-send-reply port-mapping-udp-transport-agent-mixin)
	   (block &optional dont-release)
  (let ((entry (assoc (reply-block-transaction-id self block) reply-connection-alist)))
    (cond (entry
	   (process:atomic-replacef reply-connection-alist
				    (remove entry reply-connection-alist))
	   (send-xdr-block-connection self block (second entry) dont-release))
	  (t
	   (unless dont-release (release-xdr-block self block))))))

;;; Send errors just like replies.
(defmethod (xdr-send-error port-mapping-udp-transport-agent-mixin)
	   (block &optional dont-release)
  (xdr-send-reply self block dont-release))

(defun-in-flavor (module-connection port-mapping-udp-transport-agent-mixin)
		 (module-number module-version transaction-id)
  (let ((port (module-port self module-number module-version *pmap-udp-protocol-number*
			   t nil transaction-id)))
    (and port (port-connection port))))

;;; Only calls come through this since replies get sent directly through
;;; send-xdr-block-connection
(defmethod (send-xdr-block port-mapping-udp-transport-agent-mixin)
	   (block &optional dont-release)
  (multiple-value-bind (transaction-id module-number module-version ignore)
      (decode-call-block self block)
    (let ((connection (module-connection module-number module-version transaction-id)))
      (cond (connection
	     (let ((queue-entry (assoc transaction-id reply-queue)))
	       (when queue-entry (setf (fourth queue-entry) connection)))
	     (send-xdr-block-connection self block connection dont-release))
	    (t
	     (unless dont-release (release-xdr-block self block)))))))

;;; For each call block we receive, record its transaction-id and connection
;;; on the reply-connection-alist so the replies go to the right place.
(defwhopper (receive-xdr-block-connection port-mapping-udp-transport-agent-mixin)
	    (connection no-hang-p timeout)
  (let ((xdr-block (continue-whopper connection no-hang-p timeout)))
    (multiple-value-bind (transaction-id module-number module-version entry-number)
	(decode-call-block self xdr-block)
      (let ((module (gethash module-number *remote-module-table*)))
	(when (and module (= (remote-module-version module) module-version))
	  (let ((entry (find entry-number (remote-module-entries module)
			     :key #'remote-entry-number)))
	    (when (and entry (null (remote-entry-asynchronous entry)))
	      (let ((alist-entry (list transaction-id connection)))
		(process:atomic-push alist-entry reply-connection-alist)))))))
    xdr-block))

(defflavor udp-rpc-connection-error
	(original-error)
	(rpc-error
	 net:connection-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:network udp-rpc-connection-error) ()
  (neti:local-network-of-type :internet))

(defmethod (dbg:report udp-rpc-connection-error) (stream)
  (format stream "UDP-RPC Connection Error:~%  ~~A~" original-error))

(compile-flavor-methods udp-rpc-connection-error)

(defun-in-flavor (note-connection-error port-mapping-udp-transport-agent-mixin)
		 (connection error)
  (forget-port self (send connection :foreign-port))
  (loop for queue-element in reply-queue
	when (and (null (second queue-element))
		  (eq (fourth queue-element) connection))
	  do (setf (second queue-element)
		   (make-condition 'udp-rpc-connection-error
				   :connection connection
				   :original-error error
				   :agent self
				   :transaction-id (first queue-element)
				   :foreign-host (remote-host self)))
	     (process:wakeup (third queue-element))
	     (process:atomic-replacef reply-queue (remove queue-element reply-queue))))

(defmethod (receive-xdr-block port-mapping-udp-transport-agent-mixin) ()
  (loop
    with idle-timeout = (connection-idle-timeout)
    thereis
      (loop for connection-entry in connections
	    for (connection time) = connection-entry
	    when (send connection :in-head)
	      do (setf (second connection-entry) (time:time))
	      and thereis (receive-xdr-block-connection self connection nil nil)
	    when (consp (send connection :dead))
	      do (note-connection-error
		   connection (apply #'make-condition (send connection :dead)))
	    when (or (send connection :dead)
		     (and idle-timeout
			  (time:time-elapsed-p idle-timeout time)))
	      do (close-connection-entry connection-entry t))
    if connections
      do (loop for (connection time) in connections
	       initially (progn time)
	       do (send connection :set-waiting-process *current-process*))
	 (if idle-timeout
	     (process:block-with-timeout
	       (/ (float (loop with current-time = (time:time)
			       for (connection time) in connections
			       for idle = (time:time-difference current-time time)
			       initially (progn connection)
			       minimize (- idle-timeout idle)))
		  60.0)
	       "Await Remote Call"
	       #'(lambda ()
		   (loop for (connection time) in connections
			 when
			   (or (send connection :in-head)
			       (send connection :dead)
			       (time:time-elapsed-p idle-timeout time))
			   return t)))
	   (process:process-block
	     "Await Remote Call"
	     #'(lambda ()
		 (loop for (connection time) in connections
		       initially (progn time)
		       when
			 (or (send connection :in-head)
			     (send connection :dead))
			 return t))))
    else
      do (process:process-block
	   "Await Connections"
	   #'(lambda ()
	       (not (null connections))))))

(defmethod (:close port-mapping-udp-transport-agent-mixin) (&optional abort-p)
  (loop for connection-entry in connections
	do (close-connection-entry connection-entry abort-p)))

(defflavor big-ender-port-mapping-udp-transport-agent
	()
	(udp-transport-agent-mixin
	 call-retrying-mixin
	 port-mapping-udp-transport-agent-mixin
	 server-process-mixin
	 unix-authentication-mixin
	 std-big-ender-sub-packet-transport-agent)
  )

(compile-flavor-methods big-ender-port-mapping-udp-transport-agent)

(defun host-udp-transport-agent (host)
  (check-type host net:host)
  (or (find host *all-transport-agents*
	    :test
	    #'(lambda (host agent)
		(and (typep agent 'big-ender-port-mapping-udp-transport-agent)
		     (neti:ns-eq (remote-host agent) host))))
      (make-instance 'big-ender-port-mapping-udp-transport-agent :host host)))

(net:define-protocol :udp-rpc (:rpc :udp)
  (:desirability 0.5)
  (:invoke (sap) (host-udp-transport-agent (neti:service-access-path-host sap))))

(tcp:add-udp-port-for-protocol :udp-rpc 111)

;;; Doesn't do port-mapping.  Could be used by a client if the server doesn't
;;; port-map.  Currently, though it is only used by the server.
(defflavor single-connection-udp-transport-agent-mixin
	(connection)
	()
  (:abstract-flavor)
  (:required-flavors udp-transport-agent-mixin)
  (:initable-instance-variables connection)
  (:required-init-keywords :connection))

(defmethod (print-self single-connection-udp-transport-agent-mixin)
	   (stream ignore ignore)
  (printing-random-object (self stream :typep)
    (when connection
      (let ((network (send (send (send connection :udp-protocol) :network) :network))
	    (local-address (send connection :local-address))
	    (local-port (send connection :local-port))
	    (foreign-address (send connection :foreign-address))
	    (foreign-port (send connection :foreign-port))
	    (dead (send connection :dead))
	    (*print-pretty* nil)
	    (*print-length* nil))
	(format stream
		"~~A~@[(~A)~].~D~@[(~S)~]~A~@[(~A)~].~D~@[(~S)~]~@[ (~A)~]~"
		(or (and local-address (neti:unparse-internet-address local-address)) "*")
		(and local-address (net:get-host-from-address local-address network t))
		(or local-port "*")
		(and local-port (tcp:udp-port-protocol-name local-port))
		(or (and foreign-address (neti:unparse-internet-address foreign-address)) "*")
		(and foreign-address (net:get-host-from-address foreign-address network t))
		(or foreign-port "*")
		(and foreign-port (tcp:udp-port-protocol-name foreign-port))
		(cond ((null dead) nil)
		      ((eq dead t) 'dead)
		      ((consp dead) (first dead))
		      (t dead)))))))

(defmethod (agent-connected-p single-connection-udp-transport-agent-mixin) ()
  (and connection (null (send connection :dead))))

(defmethod (remote-host single-connection-udp-transport-agent-mixin) ()
  (send connection :foreign-host))

(defmethod (send-xdr-block single-connection-udp-transport-agent-mixin)
	   (block &optional dont-release)
  (send-xdr-block-connection self block connection dont-release))

(defmethod (receive-xdr-block single-connection-udp-transport-agent-mixin) ()
  (receive-xdr-block-connection self connection nil (connection-idle-timeout)))

(defmethod (:close single-connection-udp-transport-agent-mixin :after) (&optional mode)
  (close connection :abort mode))

(defflavor single-connection-udp-transport-agent
	()
	(udp-transport-agent-mixin
	 call-retrying-mixin
	 single-connection-udp-transport-agent-mixin
	 server-process-mixin))

(defmethod (make-instance single-connection-udp-transport-agent :after) (&rest ignore)
  (when process
    (send connection :set-waiting-process process)
    (process:wakeup process)))

(defflavor big-ender-single-connection-udp-transport-agent
	()
	(single-connection-udp-transport-agent
	 unix-authentication-mixin
	 std-big-ender-sub-packet-transport-agent)
  )

(compile-flavor-methods big-ender-single-connection-udp-transport-agent)

(net:define-server :udp-rpc (:medium :udp
			     :connection connection
			     :error-disposition (:ignore remote-network-error)
			     :process-name "UDP-RPC server"
			     :reject-unless-trusted t
			     :who-line nil
			     :trusted-p trusted-p
			     :property (:big-packets 10240))
   (unless (tcp::ip-possible-broadcast-address-p
	     (send (send connection :udp-protocol) :network)
	     (send connection :local-address)
	     (send connection :route))
     (fs:with-automatic-login-to-sys-host
       (with-open-stream (agent (make-instance 'big-ender-single-connection-udp-transport-agent
					       :connection connection
					       :process nil
					       :trusted-p trusted-p))
	 (server-top-level agent)))))

(defflavor big-ender-non-authenticating-single-connection-udp-transport-agent
	()
	(single-connection-udp-transport-agent
	 std-big-ender-sub-packet-transport-agent)
  )

(compile-flavor-methods big-ender-non-authenticating-single-connection-udp-transport-agent)

(net:define-protocol :rpc-simple (:rpc :udp)
  (:desirability 0.3) ;;big ender is less desirable than little ender
  (:invoke (sap)
    (make-instance
      'big-ender-non-authenticating-single-connection-udp-transport-agent
      :connection (open-udp-connection
		    (neti:service-access-path-host sap)
		    (tcp:protocol-name-udp-port :rpc-simple t)
		    :local-port (privileged-local-udp-port-gensym)
		    :packet-size 10240)
      :connection-idle-timeout '(nil nil))))

(tcp:add-udp-port-for-protocol :rpc-simple 6259)

(net:define-server :rpc-simple
    (:medium :udp
     :connection connection
     :error-disposition (:ignore remote-network-error)
     :process-name "RPC server"
     :reject-unless-trusted t
     :who-line nil
     :property (:big-packets 10240))
   (fs:with-automatic-login-to-sys-host
     (with-open-stream
       (agent (make-instance
		'big-ender-non-authenticating-single-connection-udp-transport-agent 
		:connection connection
		:process nil))
       (server-top-level agent))))

(defflavor little-ender-non-authenticating-single-connection-udp-transport-agent
	()
	(single-connection-udp-transport-agent
	 std-little-ender-sub-packet-transport-agent)
  )

(compile-flavor-methods little-ender-non-authenticating-single-connection-udp-transport-agent)

(net:define-protocol :rpc-little-ender-simple (:rpc :udp)
  (:desirability 0.4) ;;big ender is less desirable than little ender
  (:invoke (sap)
    (make-instance
      'little-ender-non-authenticating-single-connection-udp-transport-agent
      :connection (open-udp-connection
		    (neti:service-access-path-host sap)
		    (tcp:protocol-name-udp-port :rpc-little-ender-simple t)
		    :local-port (privileged-local-udp-port-gensym)
		    :packet-size 10240)
      :connection-idle-timeout '(nil nil))))

(tcp:add-udp-port-for-protocol :rpc-little-ender-simple 6257)

(net:define-server :rpc-little-ender-simple
    (:medium :udp
     :connection connection
     :error-disposition (:ignore remote-network-error)
     :process-name "RPC server"
     :reject-unless-trusted t
     :who-line nil
     :property (:big-packets 10240))
   (fs:with-automatic-login-to-sys-host
     (with-open-stream
       (agent (make-instance
		'little-ender-non-authenticating-single-connection-udp-transport-agent 
		:connection connection
		:process nil))
       (server-top-level agent))))
