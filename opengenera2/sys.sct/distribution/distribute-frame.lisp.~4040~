;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: DIS; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>
    
;;;
;;; Distribute Systems frame

(dw:define-program-framework distribution
  :pretty-name "Standard Distribute Systems"
  :system-menu nil
  :selectable nil
  :command-definer define-distribute-systems-command
  :command-table (:inherit-from '("colon full command"
				  "standard arguments"
				  "standard scrolling"
				  "accept-values-pane")
		  :kbd-accelerator-p t)
  ;;:terminal-io-pane interact
  :top-level (distribution-top-level)
  :state-variables ((*systems-to-distribute*)
		    (*defaults* (loop for (keyword nil init-value)
					  in *distribution-defaults-ptype-alist*
				      collect keyword collect init-value))
		    (*program-state* :systems)
		    (*distribution-plan* nil)
		    (*files-to-distribute* nil)
		    (*systems-of-files-to-distribute* nil)
		    (*system-markers* nil)
		    (*query* :confirm-only)
		    (*use-disk* :tape)
		    (*output-destination* :standard-output)
		    (*disk-pathname* (pathname (format nil "~A-1" dist-tape-scratch-path)))
		    (*tape-spec* (or (dw:presentation-type-default 'tape:tape-spec)
				     (tape:default-tape-spec)))
		    (*floppy-pathname*
		      #+imach (sys:system-case
				(MacIvory
				  (pathname (format nil "~A-1" dist-mac-floppy-scratch-path)))
				(otherwise nil))
		      #+3600 nil)
		    (*scroll-tick* 0))
  :panes ((title :title :redisplay-after-commands nil
		 :redisplay-string "Distribute Systems")
	  (mode :title :height-in-lines 1
		:redisplay-after-commands t
		:redisplay-function 'display-distribution-mode)
	  (menu :command-menu :menu-level :top-level)
	  (actions :accept-values
		   :default-character-style '(:swiss :roman :normal)
		   :accept-values-function 'accept-distribution-actions
		   :size-from-output nil
		   :redisplay-after-commands t
		   :margin-components
		   '((dw:margin-borders)
		     (dw:margin-white-borders :thickness 3)
		     (dw:margin-scroll-bar :visibility :if-needed)
		     (dw:margin-label
		       :string "Actions during Distribution"
		       :Style (:swiss :italic :small))))
	  (defaults :accept-values
		    :default-character-style '(:swiss :roman :normal)
		    :accept-values-function 'accept-distribution-defaults
		    :size-from-output nil
		    :redisplay-after-commands t
		    :margin-components
		    '((dw:margin-borders)
		      (dw:margin-white-borders :thickness 3)
		      (dw:margin-scroll-bar :visibility :if-needed)
		      (dw:margin-label
			:string "Default Parameters"
			:Style (:swiss :italic :small))))
	  (default-recast-menu :command-menu :menu-level :recast)
	  (display :display
		   :default-character-style (si:parse-character-style '(:swiss :roman :normal))
		   :typeout-window t
		   :redisplay-function 'display-distribution-specs
		   :incremental-redisplay :limit-to-viewport
		   :redisplay-after-commands t
		   :margin-components '((dw:margin-borders)
					(dw:margin-white-borders :thickness 3)
					(dw:margin-scroll-bar :visibility :if-needed)
					(dw:margin-label
					  :string "Distribution Specification"
					  :style (:swiss :italic :small)))
		   :end-of-page-mode :truncate)
	  (interact :interactor))
  :configurations '((dw::main (:layout
				(dw::main :column row-1 interact)
				(row-1 :row column-2 display)
				(column-2 :column title mode menu actions default-recast-menu
						  defaults))
			      (:sizes
				(dw::main (interact 6 :lines) :then (row-1 :even))
				(row-1 (column-2 0.32) (display 0.68))
				(column-2 (title 1 :lines)
					  (mode 1 :lines)
					  (menu :ask-window self :size-for-pane menu)
					  (actions 10 :lines)
					  (default-recast-menu 1 :lines)
					  :then
					  (defaults :even))))))

;;;
;;; Another small Distribute Systems frame is necessary as an alternative for small screens,
;;; such as the default Macintosh screen

(dw:define-program-framework small-distribution
  :pretty-name "Small Distribute Systems"
  :system-menu nil
  :selectable nil
  :command-table (:inherit-from '("colon full command" "standard arguments"
				  "standard scrolling" "accept-values-pane"
				  "distribution")
		  :kbd-accelerator-p t)
  :inherit-from (distribution)
  ;;:terminal-io-pane interact
  :top-level (distribution-top-level)
  :state-variables ((*systems-to-distribute*)
		    (*defaults* (loop for (keyword nil init-value)
					  in *distribution-defaults-ptype-alist*
				      collect keyword collect init-value))
		    (*program-state* :systems)
		    (*distribution-plan* nil)
		    (*files-to-distribute* nil)
		    (*systems-of-files-to-distribute* nil)
		    (*system-markers* nil)
		    (*query* :confirm-only)
		    (*use-disk* :tape)
		    (*output-destination* :standard-output)
		    (*disk-pathname* (pathname (format nil "~A-1" dist-tape-scratch-path)))
		    (*tape-spec* (or (dw:presentation-type-default 'tape:tape-spec)
				     (tape:default-tape-spec)))
		    (*floppy-pathname*
		      #+imach (sys:system-case
				(MacIvory
				  (pathname (format nil "~A-1" dist-mac-floppy-scratch-path)))
				(otherwise nil))
		      #+3600 nil)
		    (*scroll-tick* 0))
  :panes ((title :title :redisplay-after-commands nil
		 :margin-components
		 '((dw:margin-borders)
		   (dw:margin-whitespace :margin :top :thickness 2))
		 :redisplay-string "Distribute Systems")
	  (mode :title :height-in-lines 1
		:redisplay-after-commands t
		:redisplay-function 'display-distribution-mode
		:default-character-style '(:swiss :bold :normal)
		:margin-components
		'((dw:margin-borders)
		  (dw:margin-whitespace :margin :top :thickness 2)))
	  (actions :accept-values
		   :default-character-style '(:swiss :roman :small)
		   :accept-values-function 'accept-distribution-actions
		   :size-from-output nil
		   :redisplay-after-commands t
		   :margin-components
		   '((dw:margin-borders)
		     (dw:margin-white-borders :thickness 3)
		     (dw:margin-scroll-bar :visibility :if-needed)
		     (dw:margin-label
		       :string "Actions during Distribution"
		       :Style (:swiss :italic :small))))
	  (defaults :accept-values
		    :default-character-style '(:swiss :roman :small)
		    :accept-values-function 'accept-distribution-defaults
		    :size-from-output nil
		    :redisplay-after-commands t
		    :margin-components
		    '((dw:margin-borders)
		      (dw:margin-white-borders :thickness 3)
		      (dw:margin-scroll-bar :visibility :if-needed)
		      (dw:margin-label
			:string "Default Parameters"
			:Style (:swiss :italic :small))))
	  (menu :command-menu :menu-level :top-level
		:default-character-style '(:dutch :roman :small)
		:margin-components
		'((dw:margin-borders)
		  (dw:margin-whitespace :margin :left :thickness 6)
		  (dw:margin-whitespace :margin :top :thickness 2)))
	  (default-recast-menu :command-menu :menu-level :recast
			       :default-character-style '(:dutch :roman :small)
			       :margin-components
			       '((dw:margin-borders)
				 (dw:margin-whitespace :margin :left :thickness 6)
				 (dw:margin-whitespace :margin :top :thickness 2)))
	  (display :display
		   :default-character-style (si:parse-character-style '(:swiss :roman :normal))
		   :typeout-window t
		   :redisplay-function 'display-distribution-specs
		   :incremental-redisplay :limit-to-viewport
		   :redisplay-after-commands t
		   :margin-components '((dw:margin-borders)
					(dw:margin-white-borders :thickness 3)
					(dw:margin-scroll-bar :visibility :if-needed)
					(dw:margin-label
					  :string "Distribution Specification"
					  :style (:swiss :italic :small)))
		   :end-of-page-mode :truncate)
	  (interact :interactor))
  :configurations '((dw::main (:layout
				(dw::main :column row-1 interact)
				(row-1 :row column-2 display)
				(column-2 :column title mode menu actions default-recast-menu
						  defaults))
			      (:sizes
				(dw::main (interact 2 :lines) :then (row-1 :even))
				(row-1 (column-2 0.36) :then (display :even))
				(column-2 (title 1 :lines)
					  (mode 1 :lines)
					  (menu :ask-window self :size-for-pane menu)
					  (default-recast-menu 1 :lines)
					  :then
					  (actions :even)
					  (defaults :even))))))

(defun choose-distribution-for-screen (screen)
  (let* ((real-screen (or screen tv:main-screen))
	 (screen-type (if (or (null real-screen) (> (send real-screen :inside-width) 950.))
			  :big-screen
			:small-screen)))
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")    0(ecase screen-type
      (:big-screen 'distribution)
      (:small-screen 'small-distribution))))

(cli::define-activity 'cli::program-choice-activity
		      :program-name 'choose-distribution :name "Distribute Systems"
		      :description "Distribute Systems"
		      :choice-predicate 'choose-distribution-for-screen)
(tv:add-activity-to-system-menu-programs-column "Distribute Systems")
(tv:add-to-system-menu-create-menu "Distribute Systems"
				   '(program-frame :program choose-distribution-for-screen)
				   "A Distribute Systems program frame.")

(defun type-of-distribution-frame (window)
  window
  (dw::program-name dw::*program*))

(defmethod (distribution-top-level distribution) ()
  (let ((display (dw:get-program-pane 'display)))
    (flet ((wakeup (blip)
	     (dw:presentation-blip-case blip
	       (dw::window-wakeup-viewport-position-changed
		 (when (eq (dw:presentation-blip-object blip) display)
		   (incf *scroll-tick*)
		   (send dw:*program-frame* :redisplay-pane
			 (dw:presentation-blip-object blip))))
	       (otherwise
		 (dw::default-window-wakeup-handler blip)))))
      (dw:default-command-top-level self
				    :prompt "Distribute: "
				    :window-wakeup #'wakeup
				    :unknown-accelerator-is-command t))))

(defmethod (display-distribution-mode distribution) (stream &optional string)
  (let* ((mode-string (or string (ecase *program-state*
				   (:systems "Specify Systems")
				   (:plan "Edit Distribution Plan"))))
	 (window-width (send stream :inside-width))	;isn't there a built-in centering fn?
	 (string-width (send stream :string-length mode-string))
	 (space-width (send stream :character-width #\space))
	 (leading-spaces (truncate (/ (max 0 (- window-width string-width)) space-width) 2)))
    (format stream "~VT~A" leading-spaces mode-string)))

(define-presentation-type distribution-spec ((&key (spec-list nil)
						   (allow-all nil)))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (let* ((alist `(,@(and allow-all (list (list "**All**" :all)))
			    ,@(loop for s in spec-list
				    as str = (format nil "~A" (first s))
				    collect (list str s))))
		   (presentation-type
		    `((scl:alist-member :alist ,alist)
		      :description "system to specify")))
	      (dw:with-accept-help
		  (((:subhelp :override)
		    (lambda (stream string-so-far)
		      (ignore string-so-far)
		      (format stream "~&The possible systems to specify are: ")
		      (format-item-list alist
					:stream stream
					:printer (lambda (thing stream)
						   (present (second thing) type
							    :stream stream))))))
		(let ((spec (scl:accept presentation-type
					:original-type type	;get the right history
					:initially-display-possibilities
				          initially-display-possibilities
					:stream stream)))
		  (values spec type)))))
   :printer ((spec stream)
	     (format stream "~@(~A~)" (if (eq spec :all) "**All**" (first spec))))
   :describer ((stream) (format stream "a system name")))

(define-presentation-to-command-translator com-edit-system-spec (distribution-spec)
					   (spec)
  `(com-edit-system-spec ,spec))

(define-presentation-to-command-translator com-delete-system-spec (distribution-spec
								    :gesture :describe)
					   (spec)
  `(com-delete-system-specs ,spec))

(define-presentation-to-command-translator com-recast-system-spec-from-defaults
   (distribution-spec :gesture nil) (spec)
  `(com-recast-system-spec-from-defaults ,spec))

(define-presentation-type system-title-marker ()
   :history nil)

(define-presentation-to-command-translator com-add-system-specs (system-title-marker)
					   ()
  `(com-add-system-specs))

(define-presentation-to-command-translator com-switch-modes (system-title-marker
							      :gesture :describe)
					   ()
  `(com-switch-modes))

(define-presentation-type plan-title-marker ()
   :history nil)

(define-presentation-to-command-translator com-plan-switch-modes (plan-title-marker
								   :gesture :describe)
					   ()
  `(com-switch-modes))

(define-presentation-type file-to-distribute ((&key (file-list nil)))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (let* ((alist `(,@(loop for f in file-list
				    as str = (format nil "~A" (first f))
				    collect (list str (first f)))))
		   (presentation-type
		    `((scl:alist-member :alist ,alist)
		      :description "file to distribute")))
	      (dw:with-accept-help
		  (((:subhelp :override)
		    (lambda (stream string-so-far)
		      (ignore string-so-far)
		      (format stream "~&The possible files to distribute are: ")
		      (format-item-list alist
					:stream stream
					:printer (lambda (thing stream)
						   (present (second thing) type
							    :stream stream))))))
		(let ((spec (scl:accept presentation-type
					:original-type type	;get the right history
					:initially-display-possibilities
				          initially-display-possibilities
					:stream stream)))
		  (values spec type)))))
   :printer ((spec stream)
	     (format stream "~@(~A~)" spec))
   :describer ((stream) (format stream "a file name")))

(define-presentation-to-command-translator com-toggle-distribution-of-file (file-to-distribute)
					   (file)
  `(com-toggle-distribution-of-file ,file))

(define-presentation-type system-to-distribute-marker ((&key (system-list nil)))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (let* ((alist `(,@(loop for s in system-list
				    as str = (format nil "~A" s)
				    collect (list str s))))
		   (presentation-type
		    `((scl:alist-member :alist ,alist)
		      :description "system to distribute")))
	      (dw:with-accept-help
		  (((:subhelp :override)
		    (lambda (stream string-so-far)
		      (ignore string-so-far)
		      (format stream "~&The possible systems to distribute are: ")
		      (format-item-list alist
					:stream stream
					:printer (lambda (thing stream)
						   (present (second thing) type
							    :stream stream))))))
		(let ((spec (scl:accept presentation-type
					:original-type type	;get the right history
					:initially-display-possibilities
				          initially-display-possibilities
					:stream stream)))
		  (values spec type)))))
   :printer ((spec stream)
	     (format stream "~@(~A~)" spec))
   :describer ((stream) (format stream "a system name")))

(define-presentation-to-command-translator com-marker-include-all-files-of-system
   (system-to-distribute-marker) (system)
  `(com-include-all-files-of-system ,system))

(define-presentation-to-command-translator com-marker-exclude-all-files-of-system
   (system-to-distribute-marker :gesture :describe) (system)
  `(com-exclude-all-files-of-system ,system))

(defmethod (display-distribution-specs distribution) (stream)
  (ecase *program-state*
    (:systems
      (display-distribution-system-specs self stream))
    (:plan
      (display-distribution-plan-specs self stream))))

(defmethod (display-distribution-system-specs distribution) (stream)
  (if (null *systems-to-distribute*)
      (dw:with-redisplayable-output (:stream stream
				     :unique-id 'foo
				     :cache-value 'foo)
	(dw:with-output-as-presentation (:stream stream
					 :object 'system-spec-header-line
					 :type 'system-title-marker
					 :single-box t
					 :allow-sensitive-inferiors nil)
	  (format stream
		  (ecase (type-of-distribution-frame stream)
		    (distribution "~%~'p *** No systems currently specified for distribution.~")
		    (small-distribution
		      "~%~'p *** No systems currently specified ~%      for distribution.~")))))
    (let ((n (+ 3 (length *systems-to-distribute*))))
      (dw:with-redisplayable-output (:stream stream
				     :unique-id 'bar
				     :cache-value 'bar
				     :vertical-fraction (/ 3 n))
	(dw:with-output-as-presentation (:stream stream
					 :object 'system-spec-header-line
					 :type 'system-title-marker
					 :single-box t
					 :allow-sensitive-inferiors nil)
	  (format stream
		  (ecase (type-of-distribution-frame stream)
		    (distribution
		      "~%~'bSystems and versions to distribute, ~
                                showing non-default parameters:~~2%")
		    (small-distribution
		      "~%~'bSystems and versions to distribute, ~
                                ~%  showing non-default parameters:~~2%")))))
      (loop for spec in *systems-to-distribute*
	    for i upfrom 4
	    as (system version params) = spec
	    do (dw:with-redisplayable-output (:stream stream
					      :unique-id spec
					      :cache-value (cons spec *defaults*)
					      :cache-test #'equal
					      :vertical-fraction (/ i n))
		 (dw:with-output-as-presentation (:stream stream
						  :object spec
						  :type 'distribution-spec
						  :single-box t
						  :allow-sensitive-inferiors t)
		   (format stream "  ~A, version ~A  ~%"
			   system (string-capitalize (format nil "~A" version)))
		   (loop for (kwd val) on params by 'cddr
			 unless (equal val (getf *defaults* kwd 'foo))
			   nconc (list kwd val) into dif-params
			 finally
			   (formatting-table (stream)
			     (loop for (kwd val) on dif-params by 'cddr do
			       (formatting-row (stream)
				 (formatting-cell (stream)
				   (format stream "    ~@(~A~)" kwd))
				 (formatting-cell (stream)
				   (format
				     stream "  ~@(~@\\presentation\\~)  " val
				     (second
				       (assoc kwd *distribution-defaults-ptype-alist*))))))))
		   (format stream "~%")))))))

(defmethod (display-distribution-plan-specs distribution) (stream)
  (let ((n (+ 3 (loop for (nil nil nil length) in *system-markers* sum length)))
	(baselines (loop for (nil nil nil length) in *system-markers*
			 as m first 3 then (+ m j)
			 as j = length
			 collect m)))
    (let ((path (ecase *use-disk*
		  (:disk *disk-pathname*)
		  (:tape *tape-spec*)
		  (:floppy *floppy-pathname*))))
      (dw:with-redisplayable-output (:stream stream
				     :unique-id 'blech
				     :cache-value path
				     :vertical-fraction (/ 3 n))
	(dw:with-output-as-presentation (:stream stream
					 :object 'distribution-plan-header-line
					 :type 'plan-title-marker
					 :single-box t
					 :allow-sensitive-inferiors nil)
	  (format stream
		  (ecase (type-of-distribution-frame stream)
		    (distribution
		      "~%~'b  Files to write on ~A path ~A :~~2%")
		    (small-distribution
		      "~%~'b  Files to write on ~A ~%    path ~A :~~2%")) *use-disk* path))))
    (dw:with-redisplayable-output (:stream stream
				   :unique-id 'baz
				   :cache-value (list *scroll-tick*
						      (loop for (nil list) in *system-markers*
							    append list))
				   :cache-test #'equal)
      (loop for (old-system system-marker start-position) in *system-markers*
	    as system-files = (nthcdr start-position *files-to-distribute*)
	    for baseline in baselines
	    do (dw:with-redisplayable-output (:stream stream
					      :unique-id old-system
					      :cache-value (list *scroll-tick*
								 (copy-list system-marker))
					      :cache-test #'equal)
		 (dw:with-redisplayable-output (:stream stream
						:unique-id old-system
						:cache-value old-system
						:vertical-fraction (/ (1+ baseline) n))
		   (dw:with-output-as-presentation (:stream stream
						    :object old-system
						    :type 'system-to-distribute-marker
						    :single-box t
						    :allow-sensitive-inferiors nil)
		     (format stream "  ~'bFrom system ~A:  ~~%" old-system)))
		 (loop for file-to-be-written in (cdr system-marker)
		       for item in system-files
		       for file = (ftd-file item)
		       for i upfrom (1+ (1+ baseline))
		       do (dw:with-redisplayable-output (:stream stream
							 :unique-id file
							 :cache-value file-to-be-written
							 :vertical-fraction (/ i n))
			    (dw:with-output-as-presentation (:stream stream
							     :object file
							     :type 'file-to-distribute
							     :single-box t
							     :allow-sensitive-inferiors nil)
			      (format stream "    ~V~:[   [ ~]~A~:[ ]~]~    ~%"
				      (if file-to-be-written '(nil nil nil) '(nil nil :small))
				      file-to-be-written file file-to-be-written)))))))))

(defmethod (scroll-display-to-beginning distribution) ()
  (let ((display (dw:get-program-pane 'display)))
    (incf *scroll-tick*)
    (send dw:*program-frame* :redisplay-pane display)
    (send display :y-scroll-to 0 :absolute)))

(defmacro with-distribution-mode-checking ((desired-mode) &body body)
  `(with-distribution-mode-checking-internal ,desired-mode
     #'(sys:named-lambda with-distribution-mode-checking-body ()
	 ,@body)))

(defun-in-flavor (with-distribution-mode-checking-internal distribution)
		 (desired-mode continuation)
  (if (not (eql desired-mode *program-state*))
      (ecase *program-state*
	(:plan
	  (format
	    t "~%  This command is for creating and editing system distribution~@
               ~2Tspecifications.~@
	       ~2TThe frame has already generated a distribution plan for the~@
               ~2Tsystem specifications.~2%")
	  (let ((*query-io* *terminal-io*))
	    (when (yes-or-no-p
		    "Switch to the mode for inspecting the system specifications? ")
	      (setq *program-state* :systems)
	      (send (send dw:*program-frame* :get-pane 'display) :clear-history)
	      (scroll-display-to-beginning self))))
	(:systems
	  (format t "~%  This command is for editing and executing the current ~@
                     ~2Tdistribution plan.~@
		     ~2TThe frame is in the mode for creating and editing system~@
		     ~2Tspecifications.  It has not generated a new distribution~@
                     ~2Tplan for the current specifications.~2%")
	  (let ((*query-io* *terminal-io*))
	    (when (yes-or-no-p
		    "Switch to the mode for inspecting and executing the most recent plan? ")
	      (setq *program-state* :plan)
	      (send (send dw:*program-frame* :get-pane 'display) :clear-history)
	      (scroll-display-to-beginning self)))))
    (funcall continuation)))

(define-distribute-systems-command (com-add-system-specs
				     :menu-accelerator "Add System Specs"
				     :menu-documentation
				     "Create distribution specification(s) in a pop-up editor")
    ()
   (with-distribution-mode-checking (:systems)
     (let ((system-specs (menu-specify-distributed-system *defaults* "Specify systems" t)))
       (unless (eql system-specs :abort)
	 (loop for spec in (first system-specs)
	       as old-idx = (position spec *systems-to-distribute* :key #'first)
	       if old-idx
		 do (replace *systems-to-distribute*
			     (list (append (ncons spec) (cdr system-specs)))
			     :start1 old-idx)
	       else
		 do (setq *systems-to-distribute*
			  (nconc *systems-to-distribute*
				 (ncons
				   (append (ncons spec) (cdr system-specs))))))))))

(define-distribute-systems-command (com-menu-delete-system-specs
				     :menu-accelerator "Delete System Specs"
				     :menu-documentation
				     "Pop up a menu of system specifications to delete")
    ()
   (with-distribution-mode-checking (:systems)
     (let ((system-list *systems-to-distribute*))
       (if (null system-list)
	   (progn (beep)
		  (format t "~2&  No systems have been specified yet.~2%"))
	 (let ((system-to-edit (select-system-to-edit system-list "Delete" t)))
	   (if (null system-to-edit)
	       (beep)
	     (if (eq system-to-edit :all)
		 (setq *systems-to-distribute* nil)
	       (setq *systems-to-distribute* (delete system-to-edit system-list)))))))))

(define-distribute-systems-command (com-delete-system-specs)
    ((system `((distribution-spec :spec-list ,*systems-to-distribute* :allow-all t))
	     :prompt "for system"
	     :default (first *systems-to-distribute*)
	     :documentation "a system for which to delete the distribution spec"))
   (with-distribution-mode-checking (:systems)
     (let ((system-list *systems-to-distribute*))
       (if (null system-list)
	   (progn (beep)
		  (format t "~2&  No systems have been specified yet.~2%"))
	 (let ((system-to-edit (or system
				   (select-system-to-edit system-list "Delete" t))))
	   (if (null system-to-edit)
	       (beep)
	     (if (eq system-to-edit :all)
		 (setq *systems-to-distribute* nil)
	       (setq *systems-to-distribute* (delete system-to-edit system-list)))))))))

(define-distribute-systems-command (com-menu-edit-system-spec
				     :menu-accelerator "Edit System Spec"
				     :menu-documentation
				     "Edit a system specification in a pop-up editor")
    ()
   (with-distribution-mode-checking (:systems)
     (let ((system-list *systems-to-distribute*))
       (if (null system-list)
	   (progn (beep)
		  (format t "~2&  No systems have been specified yet.~2%"))
	 (let ((system-to-edit (select-system-to-edit system-list "Edit")))
	   (if (null system-to-edit)
	       (beep)
	     ;; this should be just (cp:execute-command 'com-edit-system-spec system-to-edit),
	     ;; but cp:execute-command-internal does a gratuitous (fresh-line).
	     (let ((cp:*last-command-values* cp:*last-command-values*))
	       (apply 'com-edit-system-spec (list system-to-edit))
	       cp:*last-command-values*)))))))

(define-distribute-systems-command (com-edit-system-spec)
    ((system `((distribution-spec :spec-list ,*systems-to-distribute*))
	     :prompt "for system"
	     :default (first *systems-to-distribute*)
	     :documentation "a system for which to edit the distribution spec"))
   (with-distribution-mode-checking (:systems)
     (flet ((canonicalize-system-as-defaults (system-spec)
	      (destructuring-bind (system version params) system-spec
		(list :default-system system
		      :default-version version
		      :machine-types (getf params :machine-types)
		      :source-category (getf params :source-category)
		      :distribute-sources (getf params :distribute-sources :use-system-value)
		      :distribute-binaries (getf params :distribute-binaries :use-system-value)
		      :include-components (getf params :include-components)
		      :include-journals (getf params :include-journals) 
		      :include-patches (getf params :include-patches)
		      :distribute-patch-sources (getf params :distribute-patch-sources)
		      :included-files-checkpoint (getf params :included-files-checkpoint)
		      :use-cached-checkpoint (getf params :use-cached-checkpoint)
		      :system-branch (getf params :system-branch)
		      :flatten-files (getf params :flatten-files)
		      :compress-files (getf params :compress-files)))))
       (let ((system-list *systems-to-distribute*))
	 (if (null system-list)
	     (progn (beep)
		    (format t "~2&  No systems have been specified yet.~2%"))
	   ;; ---crock to overcome CP bug
	   (if (eq system :all)
	       (beep)
	     (when system
	       (unless (member (first system) system-list :key 'first)
		 (beep)
		 (format t "~2&  ~A is not a previously specified system.~2%" (first system))
		 (setq system nil)))
	     (let ((system-to-edit
		     ;; It shouldn't be possible for system to be null, but just in case...
		     (or system (select-system-to-edit system-list "Edit"))))
	       (if (null system-to-edit)
		   (beep)
		 (let* ((defaults (canonicalize-system-as-defaults system-to-edit))
			(system-spec (menu-specify-distributed-system
				       defaults "Edit system specification" nil))
			old-idx)
		   (unless (eql system-spec :abort)
		     (setq old-idx
			   (position (first system-spec) system-list :key #'first))
		     (if old-idx
			 (replace system-list (list system-spec) :start1 old-idx)
		       (setq system-list (nconc system-list (ncons system-spec))))
		     (setq *systems-to-distribute* system-list)))))))))))

(define-distribute-systems-command (com-recast-system-specs-from-defaults
				     :name "Recast System Specs from Defaults"
				     :menu-accelerator "Recast System Specs from Defaults"
				     :menu-level :recast
				     :menu-documentation
			    "Reprocess all system specs using the current default parameters")
    ()
   (with-distribution-mode-checking (:systems)
     (setq *systems-to-distribute*
	   (loop with defaults = *defaults*
		 with params = (si:rem-keywords defaults '(:default-version))
		 and version = (getf defaults :default-version)
		 for (system) in *systems-to-distribute*
		 collect (list system version (copy-list params))))))

(define-distribute-systems-command (com-recast-system-spec-from-defaults)
    ((system `((distribution-spec :spec-list ,*systems-to-distribute*))
	     :prompt "for system"
	     :default (first *systems-to-distribute*)
	     :documentation
	     "a system for which to change all parameters to match the defaults"))
   (with-distribution-mode-checking (:systems)
     (let ((system-list *systems-to-distribute*))
       (if (null system-list)
	   (progn (beep)
		  (format t "~2&  No systems have been specified yet.~2%"))
	 (let ((system-spec (list (first system)
				  (getf *defaults* :default-version)
				  (si:rem-keywords *defaults* '(:default-version))))
	       old-idx)
	   (setq old-idx
		 (position (first system-spec) system-list :key #'first))
	   (if old-idx
	       (replace system-list (list system-spec) :start1 old-idx)
	     (setq system-list (nconc system-list (ncons system-spec))))
	   (setq *systems-to-distribute* system-list))))))

(defmethod (accept-distribution-defaults distribution) (stream)
  (macrolet ((with-defaults-bound (&body body)
	       `(let ,(loop for (keyword) in *distribution-defaults-ptype-alist*
			    collect `(,(intern (symbol-name keyword))
				      (getf *defaults* ,keyword)))
		  ,@body))
	     (accept-default (keyword prompt &key (prompt-mode :normal) query-identifier)
	       `(setq ,(intern (symbol-name keyword))
		      (accept (second (assoc ,keyword *distribution-defaults-ptype-alist*))
			      :stream stream :provide-default t
			      :query-identifier ,query-identifier
			      :prompt ,prompt :prompt-mode ,prompt-mode
			      :default ,(intern (symbol-name keyword)))))
	     (return-defaults ()
	       `(list ,@(loop for (keyword) in *distribution-defaults-ptype-alist*
			      collect keyword collect (intern (symbol-name keyword))))))
    (with-defaults-bound
      (flet ((fixed-line (string)
	       (dw:with-redisplayable-output (:unique-id string
					      :cache-value string
					      :stream stream)
		 (cl:write-line string stream))))
	(accept-default :default-version "Default version")
	(fixed-line "Machine Types:")
	(accept-default :machine-types "   "
			:query-identifier 'dist-machine-types :prompt-mode :raw)
	(fixed-line "Source category:")
	(accept-default :source-category "   "
			:query-identifier 'dist-source-category :prompt-mode :raw)
	(fixed-line "Distribute sources:")
	(accept-default :distribute-sources "   "
			:query-identifier 'dist-distribute-sources :prompt-mode :raw)
	(fixed-line "Distribute binaries:")
	(accept-default :distribute-binaries "   "
			:query-identifier 'dist-distribute-binaries :prompt-mode :raw)
	(accept-default :include-patches "Include patches")
	(accept-default :distribute-patch-sources "Include patch sources")
	(accept-default :include-journals "Include journals")
	(accept-default :include-components "Include component systems")
	(accept-default :included-files-checkpoint "Checkpoint for included files")
	(accept-default :use-cached-checkpoint "Use cached checkpoint")
	(when (member :version-control *features*)
	  (accept-default :flatten-files "Flatten VC files")
	  (accept-default :system-branch "System branch"))
	(accept-default :compress-files "Compress files")
	(setq *defaults* (return-defaults))))))

(defmethod (accept-distribution-actions distribution) (stream)
  (flet ((fixed-line (string)
	   (dw:with-redisplayable-output (:unique-id string
					  :cache-value string
					  :stream stream)
	     (cl:write-line string stream))))
    (fixed-line "Query about each system:")
    (setq *query*
	  (accept '((cl:member :everything :yes :confirm-only :no))
		  :stream stream :provide-default t :query-identifier 'dis-query
		  :prompt "   " :prompt-mode :raw :default *query*))
    (fixed-line "Write informational output to:")
    (setq *output-destination*
	  (accept '((token-or-type (:standard-output) cp::destination)
		    :description "a destination")
		  :stream stream :provide-default t :query-identifier 'dis-output-destination
		  :prompt "   " :prompt-mode :raw :default *output-destination*))
    (fixed-line "Write distribution to device:")
    (setq *use-disk*
	  (accept 'distribution-medium
		  :stream stream :provide-default t
		  :query-identifier 'dis-use-disk
		  :prompt "   " :prompt-mode :raw :default *use-disk*))
    (ecase *use-disk*
      (:disk
	(fixed-line "  Pathname for dummy tape file:")
	(setq *disk-pathname*
	      (accept 'fs:pathname :stream stream :provide-default t
		      :query-identifier 'dis-disk-pathname :prompt "      "
		      :prompt-mode :raw :default *disk-pathname*)))
      (:tape
	(fixed-line "  Spec for tape:")
	(setq *tape-spec*
	      (accept 'tape:tape-spec :stream stream :provide-default t
		      :query-identifier 'dis-tape-spec :prompt "      "
		      :prompt-mode :raw :default *tape-spec*)))
      (:floppy
	(fixed-line "  Pathname for diskette file:")
	(setq *floppy-pathname*
	      (accept 'fs:pathname :stream stream :provide-default t
		      :query-identifier 'dis-floppy-pathname :prompt "      "
		      :prompt-mode :raw :default *floppy-pathname*))))))

(defflavor ftd
	((file)
	 (system)
	 (selected)
	 (compress-p))
	()
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables
  (:conc-name ftd-))

(defun make-files-to-distribute-array (array)
  (let ((new-array nil)
	(systems nil)
	(markers nil))
    (loop with old-system and marker
	  with start-count = 0
	  for item being the array-elements of array
	  for count upfrom 0
	  as (nil system) = item
	  unless (equal system old-system)
	    do (pushnew system systems :test #'equal)
	       (when marker
		 (push (list old-system marker start-count (length marker)) markers)
		 (setq start-count count))
	       (setq marker (ncons t))
	       (setq old-system system)
	  do (push (make-instance 'ftd
				  :file (first item)
				  :system (second item)
				  :selected t
				  :compress-p (third item))
		   new-array)
	     (push t marker)
	  finally (push (list old-system marker start-count (length marker)) markers))
    (values (nreverse new-array) (nreverse systems) (nreverse markers))))

(define-distribute-systems-command (com-generate-plan
				     :menu-accelerator "Generate Plan"
				     :menu-documentation 
		"Generate a list of files to write, from the displayed system specifications")
    ()
   (let* ((*query-io* *terminal-io*)
	  (action
	    (ecase *program-state*
	      (:systems :generate)
	      (:plan
		(format *query-io*
			"~%  This command is for generating a system distribution plan,~@
                         ~2Tbut the frame has already generated a distribution plan for the~@
                         ~2Texisting system specifications.~2%")
		(prog1
		  (dw:with-accept-help
		      (((:top-level-help :override)
			"You are being asked how to perform the Generate Plan command:
   Generate a new plan for the existing system specifications.
   Switch to Specify Systems mode.
   Abort this command."))
		    (scl:accept
		      '((cl:member :generate :switch :abort)) :prompt
		      "  Generate a new plan, Switch modes, or Abort this command"))
		  (dw:remove-window-typeout-window
		    (dw:get-program-pane 'display) :prompt-p nil))))))
     (case action
       (:abort)
       (:switch
	 (setq *program-state* :systems)
	 (send (send dw:*program-frame* :get-pane 'display) :clear-history)
	 (scroll-display-to-beginning self))
       (:generate
	 (if (null *systems-to-distribute*)
	     (format t "~2&  No systems specified.~2%")
	   (let ((mode-window (send dw:*program-frame* :get-pane 'mode)))
	     (send mode-window :clear-window)
	     (display-distribution-mode dw:*program* mode-window "Generating plan..."))
	   (setq *distribution-plan*
		 (apply #'make-flat-distribution-plan
			*systems-to-distribute*
			:query nil
			:silent t
			:suppress-detail-printing t
			(si:rem-keywords *defaults* '(:default-version :system-branch))))
	   (multiple-value-setq
	     (*files-to-distribute* *systems-of-files-to-distribute* *system-markers*)
	     (make-files-to-distribute-array *distribution-plan*))	;initially select all
	   (send (send dw:*program-frame* :get-pane 'display) :clear-history)
	   (scroll-display-to-beginning self)
	   (send dw:*program-frame* :redisplay-pane 'display t)
	   (setq *program-state* :plan))))))

(define-distribute-systems-command (com-toggle-distribution-of-file)
    ((file `((file-to-distribute :file-list ,*files-to-distribute*))
	   :prompt "to distribute"
	   :default (ftd-file (first *files-to-distribute*))
	   :documentation "a file to distribute"))
   (with-distribution-mode-checking (:plan)
     (let* ((file-item (find file *files-to-distribute* :key #'ftd-file))
	    (place-in-big-list (position file-item *files-to-distribute*))
	    (system (ftd-system file-item))
	    (sublist-start
	      (1+ (or (position system *files-to-distribute* :key #'ftd-system
				:test-not #'equal :end place-in-big-list :from-end t)
		      -1)))
	    (sublist (nthcdr sublist-start *files-to-distribute*))
	    (place (position file-item sublist))
	    (marker-vector (second (find sublist-start *system-markers* :key #'third)))
	    (new-value (not (ftd-selected file-item))))
       (setf (ftd-selected file-item) new-value)
       (setf (first (nthcdr (1+ place) marker-vector)) new-value))))

(define-distribute-systems-command (com-include-all-files-of-system)
    ((system `((system-to-distribute-marker :system-list ,*systems-of-files-to-distribute*))
	     :prompt "to distribute"
	     :default (first *systems-of-files-to-distribute*)
	     :documentation "a system to distribute"))
   (with-distribution-mode-checking (:plan)
     (loop for item in *files-to-distribute*
	   for sys = (ftd-system item)
	   when (equal sys system)
	     do (setf (ftd-selected item) t))
     (loop for (sys vector) in *system-markers*
	   when (equal sys system)
	     do (loop for sublist on (cdr vector)
		      do (setf (first sublist) t)))))

(define-distribute-systems-command (com-exclude-all-files-of-system)
    ((system `((system-to-distribute-marker :system-list ,*systems-of-files-to-distribute*))
	     :prompt "to distribute"
	     :default (first *systems-of-files-to-distribute*)
	     :documentation "a system to distribute"))
   (with-distribution-mode-checking (:plan)
     (loop for item in *files-to-distribute*
	   for sys = (ftd-system item)
	   when (equal sys system)
	     do (setf (ftd-selected item) nil))
     (loop for (sys vector) in *system-markers*
	   when (equal sys system)
	     do (loop for sublist on (cdr vector)
		      do (setf (first sublist) nil)))))

(define-distribute-systems-command (com-write-distribution
				     :menu-accelerator "Write Distribution"
				     :menu-documentation
				     "Write out the selected files of the distribution plan")
    (&key
      ;; ---Remove this argument at some release after Genera 7.5.
      (full-length-tapes
	'scl:boolean
	:default t
	:documentation "Write all tracks of the tape. Use this 1only0 if~@
you are sure that you don't have to read the tape on a 3600 Cypher drive."))
   (with-distribution-mode-checking (:plan)
     (cp::with-standard-output-bound (if (equal *output-destination* :standard-output) nil
				       *output-destination*)
       (let ((*query-io* *terminal-io*))
	 (with-never-more (*terminal-io*)
	   (if (null *files-to-distribute*)
	       (progn (format *standard-output* "~2&  No files specified.~2%")
		      (unless (eq (si:follow-syn-stream *standard-output*)
				  (si:follow-syn-stream *query-io*))
			(format *query-io* "~2&  No files specified.~2%")))
	     (let ((mode-window (send dw:*program-frame* :get-pane 'mode)))
	       (send mode-window :clear-window)
	       (display-distribution-mode dw:*program* mode-window "Writing distribution..."))
	     (when (and (null *tape-spec*) (eq *use-disk* :tape))
	       (setf *tape-spec*
		     (accept 'tape:tape-spec
			     :prompt "Tape specification for output"
			     :default (or (dw:presentation-type-default
					    'tape:tape-spec)
					  (tape:default-tape-spec)))))
	     (let* ((file-array (make-array 16 :fill-pointer 0))
		    (systems (loop with systems
				   for item in *files-to-distribute*
				   for system = (ftd-system item)
				   for selected = (ftd-selected item)
				   when selected
				     do (pushnew system systems :test #'string-equal)
					(vector-push-extend (list (ftd-file item)
								  (ftd-system item)
								  (ftd-compress-p item))
							    file-array)
				   finally
				     (return (nreverse (loop for s in systems
							     collect (sct:find-system-named
								       s nil nil t))))))
		    (limit (ecase *use-disk*
			     (:tape (tape:get-cart-guaranteed-capacity
				      (send *tape-spec* :host) (send *tape-spec* :device)
				      full-length-tapes))
			     (:disk (if full-length-tapes tape:+cart-9track-max-length+
				      tape:+cart-4track-max-length+))
			     (:floppy +mac-floppy-max-length+)))
		    (reels-needed 0)
		    (divided-plan
		      (loop for reel in (divide-distribution-array
					  (distribution-array file-array)
					  limit)
			    when (plusp (length reel))
			      do (incf reels-needed)
			    when (plusp (length reel))
			      collect reel)))
	       (when (plusp reels-needed)
		 (format *query-io* "~&This distribution requires ~A ~
                                        ~:[reel~P of tape~;floppy disk~P~].~2%"
			 (string-upcase (format nil "~R" reels-needed))
			 (eql *use-disk* :floppy) reels-needed))
	       (write-distribution-plan-files-to-tape
		 systems divided-plan *use-disk*
		 (ecase *use-disk*
		   (:disk *disk-pathname*)
		   (:tape *tape-spec*)
		   (:floppy *floppy-pathname*))))
	     (format *standard-output* "~%")
	     (unless (eq *standard-output* *query-io*) (format *query-io* "~%"))
	     (send (send dw:*program-frame* :get-pane 'display) :clear-history)
	     (setq *program-state* :systems)))))))

(define-distribute-systems-command (com-switch-modes
				     :menu-accelerator "Switch Modes"
				     :menu-documentation
				     "Toggle the mode of the Distribute Systems activity")
    ()
   (setq *program-state*
	 (ecase *program-state*
	   (:plan :systems)
	   (:systems :plan)))
   (send (send dw:*program-frame* :get-pane 'display) :clear-history)
   (scroll-display-to-beginning self))

(define-distribute-systems-command (com-reset-defaults
				     :menu-accelerator "Reset Defaults"
				     :menu-documentation
		    "Set the parameters in Defaults and Actions panes to their initial values")
    ()
   (with-distribution-mode-checking (:systems)
     (setq *defaults* (loop for (keyword nil init-value) in *distribution-defaults-ptype-alist*
			    collect keyword collect init-value))
     (setq *query* :confirm-only)
     (setq *use-disk* :tape)
     (setq *output-destination* :standard-output)))

(defun canonicalize-system-specs (systems-and-versions defaults)
  (loop for (system version sys-defaults) in systems-and-versions
	do (loop for (kwd val) on defaults by 'cddr
		 unless (member kwd sys-defaults)
		   do (push val sys-defaults)
		      (push kwd sys-defaults))
	collect (list system version sys-defaults)))

(defparameter *distribute-help-text*
	      "~2&
  ~You are in the Distribute Systems frame.

This frame enables you to define and edit the specifications for one or
more systems that will be written on a distribution tape.  You can add
specifications for new systems one at a time, make changes to the
details of existing ones, or delete existing ones.

When you are satisfied with all your specifications, you can cause the
frame to generate and display its ~'idistribution plan~ via the
command ~'bGenerate Plan~.  You can examine and modify the plan.  When
you are satisfied, you can cause the distribution to be created with the
command ~'bWrite Distribution~.

The pane just under the frame's title tells you in which of these two
phases the frame currently is.

(You can switch back and forth between phases with the ~'bSwitch Modes~
command.  It will not change the state of the frame in any other respect.)~

")

(defparameter *distribute-specify-systems-help-text*
	      "~
~2T~You are currently in the ~'iSpecify Systems~ phase of Distribute Systems.

The specifications, as you have defined them so far, are displayed in
the large pane on the right side, called ~'iDistribution Specification~. 
On the left are two command menus and two panes for setting parameters.

Scroll the display with the SCROLL and m-SCROLL keys.  m-< and m-> move
the display to the beginning and end, respectively.

The pane called ~'iActions during Distribution~ contains settings that
control the way in which the whole writing of the distribution is done,
such as where to direct the information lines that tell which files are
being written.  They don't have an effect during this phase of the process.

The pane called ~'iDefault Parameters~ contains the default values for the
details of how each system is written.  When a new system specification
is created, these defaults are used as the initial settings of the
detailed parameters for that system spec.

Note that once a system specification has been created, it contains a
full set of parameter values.  It is displayed in the large pane in such
a way that only the settings that don't correspond to the Default
Parameters are shown, for brevity.  If you change a default parameter,
the parameters of existing system specs don't change, but the display of
them does change to reflect the fact that one of their parameter values
is no longer the default value.

If you entered the Distribute Systems frame via the command \"Distribute
Systems ~'isystem1, system2,...~ :Menu Yes\", the frame will contain specs
for ~'isystem1~, ~'isystem2~, and so on, that already have a full set of
parameters.  Changing the defaults will have no direct effect on them. 
Read on for how to change their parameters within this frame. 

Specifications for new systems can be added to the list with the ~'bAdd
System Specs~ command, or by clicking left on the title line of the
system spec display.  The parameter values initially offered in the
pop-up editor are from the current set of Default Parameters.

The detailed parameters of an individual specification already in the
list can be edited via ~'bEdit System Spec~, or by clicking Left on the
displayed line for that system specification.

You may wish to set some parameters in the ~'iDefault Parameters~ pane, and
then force them on all the existing system specs.  You can do this with
~'bRecast System Specs from Defaults~, found in the menu just above the ~'iDefault
Parameters~ pane.  You can force the default parameters on an individual
system spec via ~'bRecast System Spec from Defaults~, found in the menu you
get by clicking Right on the display of that system specification.

A specification in the list can be removed with ~'bDelete System Specs~
or by clicking Middle on the displayed line.  All specifications can be
cleared by ~'bDelete System Specs~ and specifying **All**.

The actions and default parameters can be reset to their initial values
with ~'bReset Defaults~.

When you are satisfied with the specifications that you have
constructed, proceed to the next step of the process with the command
~'bGenerate Plan~.  The frame will compute the exact list of files to
be written, according to your specifications.  When it is finished, it
will switch to the ~'iEdit Distribution Plan~ phase and display the list
of files.~

")

(defparameter *distribute-edit-distribution-plan-help-text*
	      "~
~2T~You are currently in the ~'iEdit Distribution Plan~ phase of Distribute Systems.

The files of the plan that was generated for your system specifications
are displayed in the large pane on the right side, called
~'iDistribution Specification~.  On the left are a command menu and
two panes for setting parameters.

Clicking left of the name of a file in the plan toggles whether it is
selected to be written in the distribution.  Initially, all files are
selected.  If a file is deselected, it is displayed in a smaller font.

There is a boldface header line displayed at the top of the files for
each system.  Clicking left on a system header selects all of the files
for that system.  Clicking middle deselects all the files for that
system.

Scroll the display with the SCROLL and m-SCROLL keys.  m-< and m-> move
the display to the beginning and end, respectively.

The pane called ~'iActions during Distribution~ contains settings that
control the way in which the whole writing of the distribution is done,
such as where to direct the information lines that tell which files are
being written.

When you are satisfied with the actions, and with the list of files to
be distributed, give the ~'bWrite Distribution~ command.

When the distribution plan is being executed, the informational lines
that the operation produces are printed on the typeout window over the
large pane.  Any queries are also done there.  If some other destination
for informational output has been given, the output is written in that
place, also.

~")

(define-distribute-systems-command (com-distribute-help
				     :menu-accelerator "Help"
				     :menu-documentation "Display the help text"
				     :name "Help") ()
   (ecase (type-of-distribution-frame self)
     (distribution
       (format t *distribute-help-text*)
       (format t (ecase *program-state*
		   (:systems *distribute-specify-systems-help-text*)
		   (:plan *distribute-edit-distribution-plan-help-text*))))
     (small-distribution
       (with-character-style ('(nil nil :small))
	 (format t *distribute-help-text*)
	 (format t (ecase *program-state*
		     (:systems *distribute-specify-systems-help-text*)
		     (:plan *distribute-edit-distribution-plan-help-text*)))))))

(cp:define-command-accelerator com-distribute-help "distribution" (#\help) (:echo nil) ()
  (cp:build-command 'com-distribute-help))

(define-distribute-systems-command (com-distribute-refresh)
    ()
   (send dw:*program-frame* :refresh))

(cp:define-command-accelerator com-distribute-refresh "distribution" (#\refresh) (:echo nil) ()
  (cp:build-command 'com-distribute-refresh))

(define-distribute-systems-command (com-distribute-scroll-forward) ()
   (let* ((display (dw:get-program-pane 'display))
	  (line-height (send display :line-height)))
     (incf *scroll-tick*)
     (send display :y-scroll-to (* (1- (truncate (send display :inside-height) line-height))
				   line-height) :relative)
     (send dw:*program-frame* :redisplay-pane display)))

(cp:define-command-accelerator com-distribute-scroll-forward "distribution"
			       (#\c-V #\scroll) (:echo nil) ()
  (cp:build-command 'com-distribute-scroll-forward))

(define-distribute-systems-command (com-distribute-scroll-backward) ()
   (let* ((display (dw:get-program-pane 'display))
	  (line-height (send display :line-height)))
     (incf *scroll-tick*)
     (send display :y-scroll-to (- (* (1- (truncate (send display :inside-height) line-height))
				      line-height)) :relative)
     (send dw:*program-frame* :redisplay-pane display)))

(cp:define-command-accelerator com-distribute-scroll-backward "distribution"
			       (#\m-V #\m-scroll) (:echo nil) ()
  (cp:build-command 'com-distribute-scroll-backward))

(define-distribute-systems-command (com-distribute-scroll-to-beginning) ()
   (let ((display (dw:get-program-pane 'display)))
     (incf *scroll-tick*)
     (send display :y-scroll-to 0 :absolute)))

(cp:define-command-accelerator com-distribute-scroll-to-beginning "distribution"
			       (#\m-<) (:echo nil) ()
  (cp:build-command 'com-distribute-scroll-to-beginning))

(define-distribute-systems-command (com-distribute-scroll-to-end) ()
   (let* ((display (dw:get-program-pane 'display))
	  (line-height (send display :line-height))
	  (pane-height (send display :inside-height))
	  (centering-fudge (* (truncate
				(* 3 (truncate pane-height line-height)) 4) line-height)))
     (incf *scroll-tick*)
     (send display :y-scroll-to (- (send display :maximum-y-position) centering-fudge)
	   :absolute)))

(cp:define-command-accelerator com-distribute-scroll-to-end "distribution"
			       (#\m->) (:echo nil) ()
  (cp:build-command 'com-distribute-scroll-to-end))
(define-distribute-systems-command (com-distribute-remove-typeout-window) ()
  (let ((display (dw:get-program-pane 'display)))
    (dw:remove-window-typeout-window display :prompt-p nil)))

(cp:define-command-accelerator com-distribute-remove-typeout-window "distribution" (#\space)
			       (:echo nil) ()
  (cp:build-command 'com-distribute-remove-typeout-window))

(compile-flavor-methods distribution small-distribution)
