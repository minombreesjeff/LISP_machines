;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: METERING-INTERFACE -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; the general question is do you want
;;;    1) avg per tell
;;;    2) avg per match/merge
;;; Currently merges and matches are both 1.
;;; also you can't tell how much time was spent in each individual match
;;; Only how much time is spent per tell in matching.  It is possible to record
;;; the time per match.  Since we are now recording match and merge counts it would also
;;; be possible to display the average time per match (2).  But what would we name the
;;; field?

;;; To do:
;;; 1) check ask metering to make sure all appropriate continuation times are excluded
;;; 2) * in merge metering change success subfields to be fields of their own
;;; 3) numbers are off - substrate bug
;;; 4) why do the collectors for merges get recompiled each time?
;;; 5) * describe-run for ask
;;; 6) Tell metering has too many default fields
						
(defflavor joshua-predicate-metering-mixin
	(hash-collector
	 components
	 sort-by
	 (sorted-entries nil)
	 (redisplay-tick 0)
	 n-entries
	 (n-printable-entries nil))
	()
  (:required-flavors basic-metering-run))

(defmethod (make-instance joshua-predicate-metering-mixin :after) (&rest ignore)
  (setf sort-by (first (sorting-options-for-metering-type (metering-run-type self)))))

(defmethod (clean-up-run-is-dead joshua-predicate-metering-mixin) ()
  (setf sorted-entries nil))

;;; the data isn't stored right in the collector but rather in the hash-collector 
(defmethod (get-entries-for-key joshua-predicate-metering-mixin) (key)
  (collect-data-for-value hash-collector key))

(defmethod (initialize-display joshua-predicate-metering-mixin :before) (ignore)
  (setq components (metering:get-components-from-recursive-node collector))
  (setq hash-collector
	(get-component-from-components 'predicate components collector)))

(defmethod (change-parameters joshua-predicate-metering-mixin) (stream)
  (dw:accepting-values (stream :label "Change Display Parameters")
    (setq sort-by (accept `(sorting-option ,(metering-run-type self))
			  :default sort-by
			  :prompt "Sort the output by"
			  :stream stream)))
  (force-recalculation self))


(defmethod (display-metering-results joshua-predicate-metering-mixin) (stream header-char-width)
  (ignore header-char-width)
  (when (null n-printable-entries)
    (process-selector-information self))
  (multiple-value-bind (ignore top ignore bottom)
      (send-if-handles stream :visible-cursorpos-limits :character)
    (with-redisplayable-output (:stream stream :unique-id self :cache-value redisplay-tick)
      (dw::with-output-truncation (stream :horizontal t)
	(let ((n-entries (ncomponents hash-collector))
	      (*print-pretty* nil)
	      (char-width (send stream :char-width)))
	  (tv:noting-progress ("Meter Printout")
	    (if (zerop n-entries)
		(display-no-data-message self stream)
		(loop with entry-number = 0
		      for (predicate components) in sorted-entries
		      do (unless (eq predicate 'below-threshold-percentage)
			   (incf entry-number)
			   (tv:note-progress entry-number n-printable-entries)
			   (let ((cache-value (clipped-cache-value entry-number entry-number
								   top bottom header-tick)))
			     (dw:with-redisplayable-output
				 (:stream stream
				  :unique-id predicate
				  :cache-value cache-value
				  :cache-test #'clipped-cache-test)
			       (write-char #\space stream)	;this is necessary for two reasons
			       (unless (eq cache-value :clipped)
				 (loop for first first t then nil
				       for field in output-fields
				       unless first
					 do (format stream "~v@t"
						    *number-of-inter-field-spaces*)
				       do (write-sub-fields field
							    stream self
							    components
							    predicate
							    char-width)))
			       (terpri stream))))))))))))

(defmethod (process-selector-information joshua-predicate-metering-mixin) ()
  (let ((sort-by-field (sorting-option-field sort-by))
	(last-entry nil)
	(total-entries (metering:ncomponents hash-collector)))
    (setf n-printable-entries 0
	  sorted-entries nil)
    (tv:noting-progress ("Filter and Sort Results")
      (metering:sort-collector-values
	hash-collector
	#'(lambda (predicate components ignore)
	    (tv:note-progress n-printable-entries total-entries)
	    (let ((new-entry (list (list predicate components))))
	      (if (null last-entry)
		  (setf sorted-entries new-entry)
		  (setf (cdr last-entry) new-entry))
	      (setf last-entry new-entry))
	    (unless (eq predicate 'below-threshold-percentage)
	      (incf n-printable-entries)))		
	sort-by-field
	:extractor (sorting-option-extractor sort-by)
	:predicate (sorting-option-predicate sort-by)
	:description (metering-run-field-descriptions self)
	:filters nil	  
	:sort-filters-p nil))))

(defmethod (metering-run-field-descriptions joshua-predicate-metering-mixin) ()
  (third (metering:find-slot-in-component-description
	  'predicate
	  (collector-component-description collector))))

(defmethod (force-redisplay joshua-predicate-metering-mixin)  (&optional (only-to-leaves nil))
  (ignore only-to-leaves)
  (incf redisplay-tick))

(defmethod (force-recalculation joshua-predicate-metering-mixin)  ()
  (setf n-printable-entries nil)
  (incf redisplay-tick))
			


(metering:defgenerator (collector-total values :integer (collector)
					:description "get the total stored in a collector"
					:argument-types
					((collector metering:basic-collector "Collector"
						    :value))
					:presentation-type integer)
  `(metering:total ,collector))


(defvar *rule-firing-collector*
	(metering:make-data-collector 'metering:counter))

(defvar *merge-collector*
	(metering:make-data-collector 'metering:counter))

(defvar *merge-time-collector*
	(metering:make-data-collector 'metering:sum))

(defvar *match-collector*
	(metering:make-data-collector 'metering:counter))

(defvar *match-time-collector*
	(metering:make-data-collector 'metering:sum))

(defvar *control-joshua-metering*
	(make-instance 'metering:basic-control :name "Control rule tracing" :keep t))


(defflavor joshua-tell-metering-run
	()
	(joshua-predicate-metering-mixin basic-metering-run))

(defmethod (metering-run-type joshua-tell-metering-run) () :joshua-tell)
									    
(defmethod (metering-run-key-type joshua-tell-metering-run) () 'symbol)

(defmethod (metering-run-parameters joshua-tell-metering-run) ()
  `())

(defmethod (describe-run joshua-tell-metering-run) (stream)
  (let ((components (metering:get-components-from-recursive-node collector)))
    (flet ((total-value (component)
	     (total (get-component-from-components component
						   components collector))))	     
      ;; this sure really be a table or two
      (format stream "~&~%~'iTotal number of tells for run:~   ~16D~
		    ~&~%~'iTotal number of rules fired:~     ~16D~
		    ~&~%~'iTotal number of matches for run:~ ~16D~
		    ~&~%~'iTotal number of merges for run:~  ~16D~
		    ~&~%~'iTotal                           TELL time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                         INSERT time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                        JUSTIFY time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal   NOTICE-CHANGE-OF-TRUTH-VALUE time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal MAP-OVER-FORWARD-RULE-TRIGGERS time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                          Match time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                          Merge time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)"
	      (total-value 'total-count)
	      (total-value 'rule-count)
	      (total-value 'match-count)
	      (total-value 'merge-count)
	      (total-value 'tell-time)
	      (total-value 'insert-time)
	      (total-value 'justify-time)
	      (total-value 'notice-change-time)
	      (total-value 'map-over-time)
	      (total-value 'match-time)
	      (total-value 'merge-time)))))



(defmethod (define-collector joshua-tell-metering-run) ()
  (metering:make-data-collector
    'metering:record
    :component-description
    '((total-count metering:counter)
      (tell-time metering:modal-histogram)
      (insert-time metering:modal-histogram)
      (justify-time metering:modal-histogram)
      (rule-time metering:modal-histogram)
      (rule-count metering:modal-histogram)
      (notice-change-time metering:modal-histogram)
      (map-over-time metering:modal-histogram)
      (match-time metering:modal-histogram)
      (match-count metering:modal-histogram)
      (merge-time metering:modal-histogram)
      (merge-count metering:modal-histogram)
      (predicate metering:collect-hash
		 :component-description
		 ((predicate-count metering:counter)
		  (tell-time metering:modal-histogram)
		  (justify-time metering:modal-histogram)
		  (insert-time metering:modal-histogram)
		  (notice-change-time metering:modal-histogram)
		  (map-over-time metering:modal-histogram)
		  (match-time metering:modal-histogram)
		  (match-count metering:modal-histogram)
		  (merge-time metering:modal-histogram)		
		  (rule-count metering:modal-histogram)
		  (merge-count metering:modal-histogram))))
    :name nil))


;;; this only returns one of the several triggers - but they both have the same
;;; control
(defmethod (metering-run-trigger joshua-tell-metering-run) () 'ji::tell-internal)

(defmethod (set-trigger joshua-tell-metering-run) ()
  ;; just for good measure - is this the right place ?
  (reset *rule-firing-collector*)
  (reset *merge-collector*)
  (reset *merge-time-collector*)
  (reset *match-collector*)
  (reset *match-time-collector*)
  (metering:collect-data-from-trigger
    'ji::execute-forward-rule
    `((,*rule-firing-collector*)))
  (metering:collect-data-from-trigger
    'ji::D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Rete-network-merge-environments
0    `((,*merge-collector*)
      (,*merge-time-collector* exclusive-time)))
  (metering:collect-data-from-trigger
    'ji::1Rete-network-0match1-predication
0    `((,*match-collector*)
      (,*match-time-collector* exclusive-time)))
  (metering:collect-data-from-trigger
    'ji::tell-internal
    `(((,collector)
       (total-count) (tell-time exclusive-time)
       ((predicate (type-of (first arglist))) (predicate-count)
	(tell-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::insert
    `(((,collector)
       (insert-time exclusive-time)
       ((predicate (type-of (first arglist))) (insert-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::justify
    `(((,collector)
       (justify-time exclusive-time)
       ((predicate (type-of (first arglist))) (justify-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::notice-truth-value-change
    `(((,collector)
       (notice-change-time exclusive-time)
       (rule-count rule-count)
       ((predicate (type-of (first arglist))) (notice-change-time exclusive-time)
	(rule-count rule-count)))))
    (metering:collect-data-from-trigger
    'ji::map-over-forward-rule-triggers
    `(((,collector)
       (map-over-time exclusive-time) (merge-time merge-time) (match-time match-time)
       (match-count match-count) (merge-count merge-count)
       ((predicate (type-of (first arglist))) (map-over-time exclusive-time)
	(match-count match-count)
	(match-time match-time)
	(merge-count merge-count)
	(merge-time merge-time))))))

(defun really-going-to-execute-rule (fp func arglist values &optional thrown-through)
  (ignore fp func values thrown-through)
  (let ((state-entry (first arglist)))
    (zerop (ji::rete-internal-state-inactive state-entry))))

;;; currently these are all the same - they will be different
(defmethod (set-generators joshua-tell-metering-run) ()
  (metering:meter-function 'ji::execute-forward-rule)  
  (let ((trigger (parse-trigger 'ji::execute-forward-rule)))
    (clear-trigger trigger)
    (metering:meter-conditionally trigger #'really-going-to-execute-rule)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::1Rete-network-merge-environments0)  
  (let ((trigger (parse-trigger 'ji::1Rete-network-merge-environments0)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 1 0'ji::1Rete-network-0match1-predication0)  
  (let ((trigger (parse-trigger 'ji::1Rete-network-0match1-predication0)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::tell-internal)  
  (let ((trigger (parse-trigger 'ji::tell-internal)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::insert)
  (let ((trigger (parse-trigger 'ji::insert)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::justify)
  (let ((trigger (parse-trigger 'ji::justify)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::notice-truth-value-change)  
  (let ((trigger (parse-trigger 'ji::notice-truth-value-change)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))
	(collector-total *rule-firing-collector* :keywords (:exclusive (:name rule-count)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::map-over-forward-rule-triggers)
  (let ((trigger (parse-trigger 'ji::map-over-forward-rule-triggers)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))
	(collector-total *merge-collector* :keywords (:exclusive (:name merge-count)))
	(collector-total *merge-time-collector* :keywords (:exclusive (:name merge-time)))
	(collector-total *match-collector* :keywords (:exclusive (:name match-count)))
	(collector-total *match-time-collector* :keywords (:exclusive (:name match-time)))))
    (metering:control-trigger *control-joshua-metering* trigger)))

(defmethod (set-scope joshua-tell-metering-run) ()
  (let ((region-spec (parse-region region)))
    (set-scope-of-control
      *control-joshua-metering*
      `(and :switch
	    (:process ,process)
	    ,@(if region-spec
		  `((:within (and (:region ,region-spec)
				  (not (:region #'dbg:debugger-top-level)))
		     (:process ,process)))
		  `((not (:within (:region #'dbg:debugger-top-level)
			  (:process ,process)))))))))

(defmethod (clear-scope joshua-tell-metering-run) ()
  (metering:unmeter-function 'ji::notice-truth-value-change)
  (metering:unmeter-function 'ji::map-over-forward-rule-triggers)
  (metering:unmeter-function 'ji::tell-internal)
  (metering:unmeter-function 'ji::justify)
  (metering:unmeter-function 'ji::insert)
  (metering:unmeter-function1 0'ji::1Rete-network-0match1-predication0)
  (metering:unmeter-function 'ji::1Rete-network-merge-environments0)
  (metering:unmeter-function 'ji::execute-forward-rule)    
  
  (set-scope-of-control *control-joshua-metering* nil))

(defmethod (joshua-total-tell-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'tell-time components collector)))

(defmethod (joshua-total-insert-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'insert-time components collector)))

(defmethod (joshua-total-justify-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'justify-time components collector)))

(defmethod (joshua-total-notice-change-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'notice-change-time components collector)))

(defmethod (joshua-total-map-over-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'map-over-time components collector)))

(defmethod (joshua-total-match-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'match-time components collector)))

(defmethod (joshua-total-merge-time joshua-tell-metering-run) ()
  (total (get-component-from-components 'merge-time components collector)))



(define-sorting-options :joshua-tell
			`(("Predicate Name" :key ,#'identity ,#'alphalessp)
			  ("Tell Count" predicate-count total ,#'>)
			  ("Total Tell Time" tell-time total ,#'>)
			  ("Average Tell Time" tell-time average ,#'>)
			  ("Total Insert Time" insert-time total ,#'>)
			  ("Average Insert Time" insert-time average ,#'>)
			  ("Total Justify Time" justify-time total ,#'>)
			  ("Average Justify Time" justify-time average ,#'>)
			  ("Total Notice Change Time" notice-change-time total ,#'>)
			  ("Average Notice Change Time" notice-change-time average ,#'>)
			  ("Total Map Over Time" map-over-time total ,#'>)
			  ("Average Map Over Time" map-over-time average ,#'>)
			  ("Total Match Time" match-time total ,#'>)
			  ("Average Match Time" match-time average ,#'>)
			  ("Total Match Count" match-count total ,#'>)
			  ("Average Match Count" match-count average ,#'>)
			  ("Total Merge Time" merge-time total ,#'>)
			  ("Average Merge Time" merge-time average ,#'>)
			  ("Total Merge Count" merge-count total ,#'>)
			  ("Average Merge Count" merge-count average ,#'>)
			  ("Total Rule Count" rule-count total ,#'>)
			  ("Average Rule Count" rule-count average ,#'>)))

(defmethod (change-parameters joshua-tell-metering-run) (stream)
  (dw:accepting-values (stream :label "Change Display Parameters")
    (setq sort-by (accept `(sorting-option ,(metering-run-type self))
			  :default sort-by
			  :prompt "Sort the output by"
			  :stream stream)))
  (force-recalculation self))



(defmacro define-output-field-modal-histogram ((component metering-type header-name)
					       doc &optional run-total-accessor-form
					       &key (type "time")
					       (units "(in microseconds)")
					       (within "spent in this function")
					       (per-what "call"))
  `(define-output-field ,component ,metering-type
     :header ,header-name
     :documentation
     ,doc
     :sub-field-descriptions
     ((:header "Total"
       :documentation ,(format nil "The total ~A ~A ~A." type units within)
       :width (14 :character)
       :write-function
       (lambda (stream field &rest ignore)
	 (format stream "~14D" (total field))))
      (:header "Avg"
       :documentation
       ,(format nil "Average ~a per ~A ~a." type per-what within)
       :width (10 :character)
       :write-function
       (lambda (stream field &rest ignore)
	 (format stream "~10,2F" (average field))))
      ,@(when run-total-accessor-form
	  `((:header "/Run"
	     :documentation
	     ,(format nil "Bar graph of percentage of total ~A for run ~A." type within)
	     :width (50 :pixel)
	     :write-function
	     (lambda (stream field run ignore ignore)
	       (bar-graph stream
			  (total field)
			  ,run-total-accessor-form
			  50)))
	    (:header "%Run"
	     :documentation
	     ,(format nil "Percentage of total ~A for the run ~A." type within)
	     :width (7 :character)
	     :write-function
	     (lambda (stream field run &rest ignore)
	       (format stream "~6,2,2F%"
		       (float (/ (total field)
				 ,run-total-accessor-form)))))))
      (:header "Dist"
       :documentation
       ,(format nil "A graph of the distribution of the ~A per ~A ~A.
The distribution from 0 to twice the average value is displayed.   The average value is
marked by a tick (underneath).  Any overflow is displayed as a separate bar to the right."
		type per-what within)
       :width (50 :pixel)
       :write-function
       (lambda (stream field &rest ignore)
	 (graph-histogram-distribution stream field 50)))
      (:header "WDist"
       :documentation
       ,(format nil
		"A graph of the weighted distribution of the ~A per ~A ~A.
The distribution from 0 to twice the average value is displayed.   The average value is
marked by a tick (underneath).  Any overflow is displayed as a separate bar to the right."
		type per-what within)
       :width (50 :pixel)
       :write-function
       (lambda (stream field &rest ignore)
	 (graph-histogram-weighted-distribution stream field 50))))
     :current-sub-field-names ("Total" "Avg")))


(define-output-field predicate-count :joshua-tell
  :header "Tell"
  :documentation "Count of tells."
  :sub-field-descriptions
  ((:header "Count"
     :documentation "Number of times a predication of this predicate was told." 
     :width (5 :character)
     :write-function
     (lambda (stream field &rest ignore)
       (format stream "~5D" (total field)))))
  :current-sub-field-names ("Count"))

(define-output-field-modal-histogram (tell-time :joshua-tell "Tell Time")
				     "The exclusive time spent doing TELL."
  (joshua-total-tell-time run)
  :within "spent in the TELL part of the protocol"
  :per-what "tell")

(define-output-field-modal-histogram (insert-time :joshua-tell "Insert Time")
				     "The exclusive time spent handling the INSERT part of the protocol."
  (joshua-total-insert-time run)
  :within "spent in the INSERT part of the protocol"
  :per-what "tell")

(define-output-field-modal-histogram (justify-time :joshua-tell "Justify Time")
				     "The exclusive time spent handling the JUSTIFY part of the protocol."
  (joshua-total-justify-time run)
  :within "spent in the JUSTIFY part of the protocol"
  :per-what "tell")

(define-output-field-modal-histogram (notice-change-time :joshua-tell "Notice Change Time")
				     "The exclusive time spent handling the NOTICE-CHANGE-IN-TRUTH-VALUE part of the protocol."
  (joshua-total-notice-change-time run)
  :within "spent in the NOTICE-CHANGE-IN-TRUTH-VALUE part of the protocol"
  :per-what "tell")

(define-output-field-modal-histogram (map-over-time :joshua-tell "Map Over Time")
				     "The exclusive time spent handling the MAP-OVER-FORWARD-RULE-TRIGGERS part of the protocol."
  (joshua-total-map-over-time run)
  :within "spent in the MAP-OVER-FORWARD-RULE-TRIGGERS part of the protocol"
  :per-what "tell")

(define-output-field-modal-histogram (match-time :joshua-tell "Match Time")
				     "The exclusive time spent matching triggers.
These are matches caused by this tell."
  (joshua-total-match-time run)
  :within "spent in matching triggers"
  :per-what "tell")

(define-output-field-modal-histogram (merge-time :joshua-tell "Merge Time")
				     "The exclusive time spent merging.  
These are merges caused by this tell."
  (joshua-total-merge-time run)
  :within "spent in merging"
  :per-what "tell")

(define-output-field rule-count :joshua-tell
  :header "Rule Count"
  :documentation
  "Rule Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of rules fired." 
     :width (5 :character)
     :write-function
     (lambda (stream field &rest ignore)
       (format stream "~5D" (total field)))))
  :current-sub-field-names ("Total"))

(define-output-field merge-count :joshua-tell
  :header "Merge Count"
  :documentation
  "Merge Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of attempted merges." 
     :width (5 :character)
     :write-function
     (lambda (stream field &rest ignore)
       (format stream "~5D" (total field)))))
  :current-sub-field-names ("Total"))

(define-output-field match-count :joshua-tell
  :header "Match Count"
  :documentation "Match Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of attempted matches." 
     :width (5 :character)
     :write-function
     (lambda (stream field &rest ignore)
       (format stream "~5D" (total field)))))
  :current-sub-field-names ("Total"))

(define-output-field nil (:joshua-tell)
  :header "Predicate"
  :documentation "The predicate."
  :sub-field-descriptions
  ((:header ""
    :documentation "The predicate name."
    :width nil
    :write-function
    (lambda (stream field run entry predicate)
      (ignore field run entry)
      (when predicate
	(present predicate (type-of predicate) :stream stream)))))
  :current-sub-field-names (""))

(define-default-output-fields :joshua-tell
			      "Tell"
  "Tell Time" "Insert Time"
  "Map Over Time"
  "Rule Count"
  "Predicate")


;;; merge and match metering

;;; we could try a mode that uses incremental graphing
						
;;; to do
;;;  *  filters also should be metered
;;;  we are collecting time - is it correct ?
;;;   do we want to include time in proceed-to-next-node ?
;;;   if we don't since that comes between any two nodes it seems like a good candidate for
;;;   help us get the right exclusive time
;;;  commands should be the same as a call tree ? most should
;;;  gesture for graphing rete net - showing data ?
;;;  *  don't share parents
;;;  *  describe for the run should show all the totals
;;;  fix up all of the doc (descriptions)
;;;  sorting options
;;;     sorting should be at each level not just roots
;;;  rule time ?


(defflavor joshua-merge-metering-run
	(hash-collector
	 components
	 roots
	 hash-components-descriptor
	 sort-by
	 (redisplay-tick 0)
	 n-entries
	 (n-printable-entries nil))
	(basic-metering-run))

(defmethod (make-instance joshua-merge-metering-run :after) (&rest ignore)
  (setf sort-by (first (sorting-options-for-metering-type (metering-run-type self)))))

(defmethod (metering-run-type joshua-merge-metering-run) () :joshua-merge)
									    

(defflavor joshua-match-tree-node
	(joshua-node					
	 run
	 (parent nil)
	 (children nil)
	 (components nil)
	 1(shared-p nil)
0	 (interesting-p nil)
	 (inferior-count 0)
	 (inferior-tick 0)
	 (tick 0))
	()
  (:conc-name match-tree-node-)
  (:initable-instance-variables)
  :readable-instance-variables
  (:writable-instance-variables interesting-p tick inferior-tick inferior-count)
  (:constructor make-match-tree-node (run joshua-node components)))

;; this is necessary to use the constructor below
(compile-flavor-methods joshua-match-tree-node)

(defmethod (metering-run-key-type joshua-merge-metering-run) () 1'joshua-match-tree-node0)

1;;; key is a node
0(defmethod (get-entries-for-key joshua-merge-metering-run) (key)
  1(match-tree-node-components key)0)

(defmethod (metering-run-parameters joshua-merge-metering-run) ()
  `())

(defmethod (clean-up-run-is-dead joshua-merge-metering-run) ()
  )

(defmethod (describe-run joshua-merge-metering-run) (stream)
  (let* ((components (metering:get-components-from-recursive-node collector))
	 (merge-count (total (get-component-from-components 'merge-count
							    components collector)))
	 (merge-success-count (total (get-component-from-components 'merge-success
								    components collector)))
	 (match-count (total (get-component-from-components 'match-count
							    components collector)))
	 (match-success-count (total (get-component-from-components 'match-success
								    components collector))))
    (format stream "~&~%~'iTotal number of rules fired:~ ~16D~
                  ~&~%~'iTotal number of matches for run:~ ~16D~
                  ~&~'iTotal successful matches for run:~ ~16D~
                  ~&~'iPercentage of matches that were successful:~ ~6,2,2F%~
		  ~&~%~'iTotal number of merges for run:~ ~16D~
                  ~&~'iTotal successful merges for run:~ ~16D~
                  ~&~'iPercentage of merges that were successful:~ ~6,2,2F%~
                  ~&~'iTotal number of calls to procedure nodes for run:~ ~16D"
	    (total (get-component-from-components 'rule-count
						  components collector))
	    match-count match-success-count (if (not (zerop match-count))
						(/ match-success-count match-count)
						0)
	    merge-count merge-success-count (if (not (zerop merge-count))
						(/ merge-success-count merge-count)
						0)
	    (total (get-component-from-components 'procedure-count
						  components collector)))))

;;; this has to go down to leaves
(defmethod (force-redisplay joshua-merge-metering-run)  (&optional (only-to-leaves nil))
  (incf redisplay-tick)
  (unless only-to-leaves
    (labels ((incf-tick (node)
	       (when (match-tree-node-interesting-p node)
		 (incf (match-tree-node-tick node))
		 (loop for child in (match-tree-node-children node)
		       do (incf-tick child)))))
      (loop for root in roots
	    do (incf-tick root)))))

(defmethod (force-recalculation joshua-merge-metering-run)  ()
  (setf n-printable-entries nil)
  (incf redisplay-tick))

;;; filters are subst for now so they are hard to meter
(defmethod (define-collector joshua-merge-metering-run) ()
  (metering:make-data-collector
    'metering:record
    :component-description
    '((rule-count metering:counter)
      (match-count metering:counter)
      (match-success metering:sum)
      (merge-count metering:counter)
      (merge-success metering:sum)
      (procedure-count metering:counter)
      (node metering:collect-hash
	    :component-description
	    ((rule-count metering:counter)
	     (excl-match-count metering:counter)
	     (excl-match-success metering:sum)
	     (incl-match-success metering:sum)
	     (incl-match-count metering:sum)
	     (excl-merge-count metering:counter)
	     (incl-merge-count metering:sum)
	     (excl-merge-success metering:sum)
	     (incl-merge-success metering:sum)
	     (excl-procedure-count metering:counter)
	     (incl-procedure-count metering:sum)	     
	     (time metering:modal-histogram))))
    :name nil))

(defmethod (incl-fields-map joshua-merge-metering-run) ()
  '((incl-match-count excl-match-count) (incl-merge-count excl-merge-count)
    (incl-merge-success excl-merge-success)
    (incl-match-success excl-match-success)
    (incl-procedure-count excl-procedure-count)))

;;; this only returns one of the several triggers - but they all have the same
;;; control
(defmethod (metering-run-trigger joshua-merge-metering-run) ()
  'ji::1Rete-network-merge-environments0)

(defmethod (set-trigger joshua-merge-metering-run) ()
  (metering:collect-data-from-trigger
    'ji::1Rete-network-merge-environments
0    `(((,collector) (merge-count) (merge-success (if (eq (first values) t) 1 0))
       ((node (first arglist)) (excl-merge-count)
	(excl-merge-success (if (eq (first values) t) 1 0))))))
  (metering:collect-data-from-trigger
    'ji::1Rete-network-apply-procedure-to-environment
0    `(((,collector) (procedure-count)
       ((node (first arglist)) (excl-procedure-count)))))
  (metering:collect-data-from-trigger
    'ji::1Rete-network-0match1-predication
0    `(((,collector) (match-count) (match-success (if (eq (first values) t) 1 0))
       ((node (first arglist)) (excl-match-count)
	(excl-match-success (if (eq (first values) t) 1 0))))))
  (metering:collect-data-from-trigger
    'ji::run-forward-rule
    `(((,collector) (rule-count) ((node (second arglist)) (rule-count))))))

(defun really-going-to-run-rule (fp func arglist values &optional thrown-through)
  (ignore fp func values thrown-through)
  (let ((state-entry (first arglist)))
    (zerop (ji::rete-internal-state-inactive state-entry))))

;;; currently these are all the same - they will be different
(defmethod (set-generators joshua-merge-metering-run) ()
  (metering:meter-function 'ji::run-forward-rule)  
  (let ((trigger (parse-trigger 'ji::run-forward-rule)))
    (clear-trigger trigger)
    (metering:meter-conditionally trigger #'really-going-to-run-rule)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::1Rete-network-merge-environments0)  
  (let ((trigger (parse-trigger 'ji::1Rete-network-merge-environments0)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 1 0'ji::1Rete-network-0match1-predication0)  
  (let ((trigger (parse-trigger 'ji::1Rete-network-0match1-predication0)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 1 0'ji::1Rete-network-apply-procedure-to-environment0)  
  (let ((trigger (parse-trigger 'ji::1Rete-network-apply-procedure-to-environment0)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger)))

(defmethod (set-scope joshua-merge-metering-run) ()
  (let ((region-spec (parse-region region)))
    (set-scope-of-control
      *control-joshua-metering*
      `(and :switch
	    (:process ,process)
	    ,@(if region-spec
		  `((:within (and (:region ,region-spec)
				  (not (:region #'dbg:debugger-top-level)))
		     (:process ,process)))
		  `((not (:within (:region #'dbg:debugger-top-level)
			  (:process ,process)))))))))

(defmethod (clear-scope joshua-merge-metering-run) ()
  (metering:unmeter-function1 0'ji::1Rete-network-0match1-predication0)
  (metering:unmeter-function 'ji::1Rete-network-merge-environments0)
  (metering:unmeter-function 'ji::run-forward-rule)
  (metering:unmeter-function 'ji::1Rete-network-apply-procedure-to-environment0)
  (set-scope-of-control *control-joshua-metering* nil))


(define-sorting-options :joshua-merge
			`(("Rule Name" :key ,#'ji::1rete-terminal-entry-rule-name
0			   ,#'alphalessp)))

(defmethod (set-parent-node joshua-match-tree-node) (new-parent)
  (setq parent new-parent))

(defmethod (add-child-node joshua-match-tree-node) (new-child)
  (pushnew new-child children))

(defmethod (mark-shared joshua-match-tree-node) ()
  (setq shared-p t))

(defmethod (copy-self-and-children joshua-match-tree-node) (node-to-match-tree-node-table)
  (let ((new-node (make-match-tree-node run joshua-node components)))
    (setq shared-p t)
    (mark-shared new-node)
    (push new-node
	  (gethash joshua-node node-to-match-tree-node-table))
    (loop for child in children
	  for child-node = (copy-self-and-children child
						   node-to-match-tree-node-table)
	  do (add-child-node new-node child-node)
	     (set-parent-node child-node new-node))
    new-node))

(defmethod (copy-self-if-necessary joshua-match-tree-node) (parent-node
							     node-to-match-tree-node-table)
  (if (or (null parent) (eq parent-node parent))
      self
      (copy-self-and-children self node-to-match-tree-node-table)))

(defmethod (initialize-display joshua-merge-metering-run) (mi)
  (ignore mi)
  (unless display-initialized
    (setq components (metering:get-components-from-recursive-node collector))
    (setq hash-collector
	  (get-component-from-components 'node components collector))
    (setq roots nil)
    (setq hash-components-descriptor
	  (third (metering:find-slot-in-component-description
		   'node
		   (collector-component-description collector))))
    (let ((node-to-match-tree-node-table (make-hash-table :locking nil)))
      (labels ((make-tree-node-if-necessary (node components)
		 (or (gethash node node-to-match-tree-node-table)
		     (let ((new-node1s0 1(list 0(make-match-tree-node self node components)1))0)
		       (setf (gethash node node-to-match-tree-node-table)
			     new-node1s0)
		       new-node1s0)))
	       1(link-up-parents-internal (tree-node 0parent-tree-node1s)
0		 1(loop for parent-tree-node in 0parent-tree-node1s
0		       1for child-tree-node = (copy-self-if-necessary tree-node
0								     1parent-tree-node
								     0node-to-match-tree-node-table1)
0		       1do 0(1set-0parent-node 1child-0tree-node parent-tree-node)
			  (add-child-node parent-tree-node 1child-0tree-node))1)
0	       (link-up-parents (node tree-node)
		 (loop for child-entry in (ji::basic-rete-node-children node)
		       do
		   (etypecase child-entry
		     (ji::1Rete-terminal-entry
0		       1(link-up-parents-internal 0tree-node
						 (make-tree-node-if-necessary
						   child-entry
						   (collect-data-for-value hash-collector
									   child-entry))1))
0		     ((or ji::rete-procedure-entry ji::1Rete-child-entry0 ji::rete-or-entry)
		       (let ((real-child-node (ji::basic-rete-child-entry-child child-entry)))
			 1(link-up-parents-internal 0tree-node
						   (make-tree-node-if-necessary
						     real-child-node
						     (collect-data-for-value
						       hash-collector1 0real-child-node))1)))0))))
	(map-over-component-collectors
	  hash-collector
	  #'(lambda (node components)
	      (let ((tree-node1s0 (make-tree-node-if-necessary node components)))
		(etypecase node
		  (ji::1Rete-terminal-entry
0		    (push 1(first 0tree-node1s)0 roots))
		  ((or ji::rete-match-node
		       ji::rete-merge-node
		       ji::rete-procedure-node
		       ji::rete-or-node)
1		   (loop for tree-node in tree-nodes
0			 1do 0(link-up-parents node tree-node))1)0)))))
      (compute-inclusives-from-exclusives self))))
						  
(defmethod (collect-excls-into-incls joshua-match-tree-node) (components-descriptor map)
  (loop for (incl excl) in map
	do
    (combine (get-component-from-components incl components components-descriptor)
	     (get-component-from-components excl components components-descriptor))))


(defmethod (combine-incls joshua-match-tree-node) (other-node components-descriptor map)
  (loop with other-components = (match-tree-node-components other-node)
	for (incl) in map
	do
    (combine (get-component-from-components incl components components-descriptor)
	     (get-component-from-components incl other-components components-descriptor))))

(defmethod (inclusive-computed? joshua-match-tree-node) (components-descriptor map)
  (loop for (incl) in map
	thereis
	  (not (metering:collector-empty-p
		 (get-component-from-components incl components components-descriptor)))))

(defmethod (compute-inclusives-from-exclusives joshua-merge-metering-run) ()
  (labels ((compute-incls (node incl-fields)
	     (loop for child in (match-tree-node-children node)
		   when (not (inclusive-computed? child
						  hash-components-descriptor incl-fields))
		     do (compute-incls child incl-fields)
		   do (combine-incls node child hash-components-descriptor incl-fields))
	     (collect-excls-into-incls node hash-components-descriptor incl-fields)))
    (let ((incl-fields (incl-fields-map self)))
      (loop for root in roots
	    do (compute-incls root incl-fields)))))

(defmethod (change-parameters joshua-merge-metering-run) (stream)
  (dw:accepting-values (stream :label "Change Display Parameters")
    (setq sort-by (accept `(sorting-option ,(metering-run-type self))
			  :default sort-by
			  :prompt "Sort the output by"
			  :stream stream)))
  (force-recalculation self))

(defmethod (display-metering-results joshua-merge-metering-run) (stream header-char-width)
  (ignore header-char-width)
  (when (null n-printable-entries)
    (process-selector-information self))
  (multiple-value-bind (ignore top ignore bottom)
      (send-if-handles stream :visible-cursorpos-limits :character)
    (let ((n-entries (ncomponents hash-collector))
	  (*print-pretty* nil)
	  (char-width (send stream :char-width)))
      (labels ((display-node (stream node depth entry-number)
		 (when (match-tree-node-interesting-p node)
		   (incf entry-number)
		   (tv:note-progress entry-number n-printable-entries)
		   (let ((cache-value (clipped-cache-value entry-number entry-number
							   top bottom
							   (match-tree-node-tick node))))
		     (dw:with-redisplayable-output
			 (:stream stream
			  :unique-id node
			  :cache-value cache-value
			  :cache-test #'clipped-cache-test)
		       (write-char #\space stream)	;this is necessary for two reasons
		       (unless (eq cache-value :clipped)
			 (with-output-as-presentation (:stream stream :object node
							       :type 'joshua-match-tree-node
							       :single-box t)
			   (loop for first first t then nil
				 for field in output-fields
				 unless first
				   do (format stream "~v@t"
					      *number-of-inter-field-spaces*)
				 do (write-sub-fields field
						      stream self
						      (match-tree-node-components node)
						      node
						      char-width))))
		       (terpri stream)))
		   (loop for child in (match-tree-node-children node)
			 do (setf entry-number
				  (display-node stream child (1+ depth)
						entry-number))))
		 entry-number))
	(tv:noting-progress ("Meter Printout")
	  (if (zerop n-entries)
	      (display-no-data-message self stream)
	      (with-redisplayable-output (:stream stream :unique-id self
						  :cache-value redisplay-tick)
		(dw::with-output-truncation (stream :horizontal t)
		  (loop with entry-number = 0
			for node in roots
			do (setf entry-number
				 (display-node stream node 0 entry-number)))))))))))

(defmethod (process-selector-information joshua-merge-metering-run) ()
  (let ((sort-by-field (sorting-option-field sort-by))
	(total-entries (metering:ncomponents hash-collector)))
    (setf n-printable-entries 0)
    (tv:noting-progress ("Filter and Sort Results")
      (let ((sort-by-extractor (sorting-option-extractor sort-by)))
	(setq roots
	      (sort roots (sorting-option-predicate sort-by)
		    :key (lambda (node)
			   (funcall sort-by-extractor (match-tree-node-joshua-node node))))))
      (labels ((mark-interesting (node interesting)
		 (when interesting
		   (incf n-printable-entries))
		 (setf (match-tree-node-interesting-p node) interesting)
		 (loop for child in (match-tree-node-children node)
		       do (mark-interesting child nil))))
	(loop for root in roots do (mark-interesting root t))))))

(defmethod (metering-run-field-descriptions joshua-merge-metering-run) ()
  hash-components-descriptor)

(defmethod (print-short joshua-match-tree-node) (stream)
  (typecase joshua-node
    (ji::Rete-merge-node (format stream "Merge:"))
    (ji::Rete-match-node (format stream "Match: ~S"
				 (match-node-pattern joshua-node)))
    (ji::Rete-terminal-entry 
      (format stream "Rule: ~S" (ji::rete-terminal-entry-rule-name joshua-node)))
    (ji::Rete-procedure-node
      (format stream "Procedure: ~S"
	      (ji::rete-procedure-node-rule-name joshua-node)))
    (ji::Rete-or-node
      (format stream "Or:"))))

(define-presentation-type joshua-match-tree-node ()
   :no-deftype t
   :parser ((stream)
(2 0 (NIL 0) (SAGE:SANS-SERIF-BODY SAGE::TYPEWRITER :NORMAL) "CPTFONT")	    (dw:read-char-for-accept stream)
0	    2(sys:parse-ferror0 2"You must click on the desired 0node2.")0)
   :history nil
   :description "a Joshua match node"
   :printer ((node stream) (print-short node stream)))

(defmethod (node-status joshua-match-tree-node) ()
  (let ((leaf? t)
	(all-sub-nodes-open? t)
	(all-sub-nodes-closed? t))
    (loop for child in children
	  do (setq leaf? nil)
	     (if (and child (match-tree-node-interesting-p child))
		 (setq all-sub-nodes-closed? nil)
		 (setq all-sub-nodes-open? nil)))
    (if leaf?
	:leaf
	(if all-sub-nodes-open?
	    :open
	    (if all-sub-nodes-closed?
		:closed
		:partial)))))

(defmethod (match-tree-node-any-hidden? joshua-match-tree-node) ()
  (loop for child in children
	thereis (not (match-tree-node-interesting-p child))))

(define-mi-command (show-joshua-node-children) ((node 'joshua-match-tree-node))
   (loop for child in (match-tree-node-children node)
	 do (open-node child))
   (incf (match-tree-node-tick node))
   (force-redisplay (match-tree-node-run node) t))

(define-mi-command (hide-joshua-node-children) ((node 'joshua-match-tree-node))
   (hide-children node)
   (incf (match-tree-node-tick node))
   (force-redisplay (match-tree-node-run node) t))

(define-presentation-to-command-translator
  show-children
   (joshua-match-tree-node
     :gesture :select
     :documentation ((node) (ecase (node-status node)
			      ((:closed :partial) "Show node children")
			      (:open "Hide node children")))			      
     :tester ((node) (not (null (match-tree-node-children node)))))
   (node)
  (ecase (node-status node)
    ((:closed :partial) `(show-joshua-node-children ,node))
    (:open `(hide-joshua-node-children ,node))))

(defmethod (close-node joshua-match-tree-node) ()
  (setf interesting-p nil))

(defmethod (hide-children joshua-match-tree-node) ()
  (loop for child in children
	do (when (match-tree-node-interesting-p child)
	     (close-node child)
	     (hide-children child))))

(define-mi-command (com-hide-joshua-node) ((node 'joshua-match-tree-node))
   (let* ((parent (match-tree-node-parent node))
	  (old-parent-status (node-status parent)))
     (unless (root-node-p node)
       (hide-children node)
       (close-node node)
       (incf (match-tree-node-tick node))
       (when (neq (node-status parent) old-parent-status)
	 (incf (match-tree-node-tick parent)))
       (force-redisplay (match-tree-node-run node) t))))

(defmethod (root-node-p joshua-match-tree-node) ()
  (null parent))

(define-presentation-to-command-translator
  hide-joshua-node
  (joshua-match-tree-node :gesture :delete
		  :documentation "Hide this node"
		  :tester ((node)
			   (not (root-node-p node))))
  (node)
  `(com-hide-joshua-node ,node))

(defmethod (open-node joshua-match-tree-node) ()
  (setf interesting-p t))

(defmethod (show-children joshua-match-tree-node) ()
  (loop for child in children
	do (unless (match-tree-node-interesting-p child)
	     (open-node child))
	   (show-children child)))

(define-mi-command (com-show-all-joshua-node-descendants) ((node 'joshua-match-tree-node))
   (show-children node)
   (incf (match-tree-node-tick node))
   (force-redisplay (match-tree-node-run node) t))

(defmethod (all-desendants-shown joshua-match-tree-node) ()
  (ecase (node-status self)
    ((:closed :partial) nil)
    (:leaf t)
    (:open (loop for child in children
		 always (all-desendants-shown child)))))

(define-presentation-to-command-translator show-all-joshua-node-children
   (joshua-match-tree-node :gesture :super-control-left
			   :documentation "Show all of this node's descendants"
			   :tester ((node) (not (all-desendants-shown node))))
   (node)
  `(com-show-all-joshua-node-descendants ,node))



(defmethod (joshua-total-merge-count joshua-merge-metering-run) ()
  (total (get-component-from-components 'merge-count components collector)))

(defmethod (joshua-total-match-count joshua-merge-metering-run) ()
  (total (get-component-from-components 'match-count components collector)))


;;; match metering fields

(define-output-field rule-count :joshua-merge
  :header "Rule Count"
  :documentation
  "Rule Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of rules fired." 
     :width (5 :character)
     :write-function
     (lambda (stream field run components node)
       (ignore run components)
       (if (typep (match-tree-node-joshua-node node) 'ji::Rete-terminal-entry)
	 (format stream "~5D" (total field))
	 (write-string "    -" stream)))))
  :current-sub-field-names ("Total"))


;;; merge fields

(define-output-field incl-merge-count :joshua-merge
  :header "Incl Merge Count"
  :documentation
  "Merge Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Inclusive number of merges attempted." 
    :width (5 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore run components)
      (if (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	  (write-string "    -" stream)
	(format stream "~5D" (total field)))))
   (:header "/Run"
    :documentation
    "Bar graph of percentage of total merges for the run spent in this node and below."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run ignore node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(bar-graph stream
		   (total field)
		   (joshua-total-merge-count run)
		   50))))
   (:header "Success/"
    :documentation
    "Bar graph of percentage of total merges for this node and below that were succesful."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run components node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(bar-graph stream
		   (total 
		     (get-component-from-components 'incl-merge-success components
						    (metering-run-field-descriptions run)))
		   (total field)
		   50))))
   (:header "Success%"
    :documentation
    "Percentage of merges for this node and below that were succesful."
    :width (7 :character)
    :write-function
    (lambda (stream field run components node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(let ((total (total field)))
	  (format stream "~6,2,2F%"
		  (if (zerop total) 1
		      (float (/ (total (get-component-from-components
					 'incl-merge-success components
					 (metering-run-field-descriptions run)))
				total)))))))))
  :current-sub-field-names ("Total" "/Run" "Success/"))

(define-output-field incl-merge-success :joshua-merge
  :header "Incl Merge Success"
  :documentation
  "Incl Merge Success"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Successful merges" 
    :width (5 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore run components)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(format stream "~5D" (total field)))))
   (:header "/Merges"
    :documentation
    "Bar graph of percentage of merges for this node and below that were succesful."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run components node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(bar-graph stream
		   (total field)
		   (total 
		     (get-component-from-components 'incl-merge-count components
						    (metering-run-field-descriptions run)))
		   50))))
   (:header "%Merges"
    :documentation
    "Percentage of merges for this node and below that were succesful."
    :width (7 :character)
    :write-function
    (lambda (stream field run components node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(format stream "~6,2,2F%"
		(float (/ (total field)
			  (total (get-component-from-components
				   'incl-merge-count components
				   (metering-run-field-descriptions run))))))))))
  :current-sub-field-names ("Total" "/Merges"))



(define-output-field excl-merge-count :joshua-merge
  :header "Excl Merge Count"
  :documentation
  "Exclusive Merge Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of merges attempted at this node." 
     :width (5 :character)
     :write-function
     (lambda (stream field run components node)
       (ignore run components)
       (if (typep (match-tree-node-joshua-node node) 'ji::Rete-merge-node)
	 (format stream "~5D" (total field))
	 (write-string "    -" stream))))
   (:header "Success/"
    :documentation
    "Bar graph of percentage of total merges for this node that were succesful."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run components node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(bar-graph stream
		   (total 
		     (get-component-from-components 'excl-merge-success components
						    (metering-run-field-descriptions run)))
		   (total field)
		   50))))
   (:header "Success%"
    :documentation
    "Percentage of merges for this node that were succesful."
    :width (7 :character)
    :write-function
    (lambda (stream field run components node)
      (unless (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(let ((total (total field)))
	  (format stream "~6,2,2F%"
		  (if (zerop total) 1
		      (float (/ (total (get-component-from-components
					 'excl-merge-success components
					 (metering-run-field-descriptions run)))
				total)))))))))
  :current-sub-field-names ("Total"))


(define-output-field excl-merge-success :joshua-merge
  :header "Excl Merge Success"
  :documentation
  "Exclusive Merge Success"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of successful merges at this node."
     :width (5 :character)
     :write-function
     (lambda (stream field run components node)
       (ignore run components)
       (if (typep (match-tree-node-joshua-node node) 'ji::Rete-merge-node)
	 (format stream "~5D" (total field))
	 (write-string "    -" stream)))))
  :current-sub-field-names ("Total"))


;;; match fields

(define-output-field incl-match-count :joshua-merge
  :header "Incl Match Count"
  :documentation
  "Incl Match Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Incl Match Count" 
    :width (5 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore run components node)
      (format stream "~5D" (total field))))
   (:header "/Run"
    :documentation
    "Bar graph of percentage of total matches for the run spent in this node and below."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run ignore node)
      (ignore node)
      (bar-graph stream
		 (total field)
		 (joshua-total-match-count run)
		 50)))
    (:header "Success/"
    :documentation
    "Bar graph of percentage of total matches for this node and below that were succesful."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run components node)
      (ignore node)
      (bar-graph stream
		 (total 
		   (get-component-from-components 'incl-match-success components
						  (metering-run-field-descriptions run)))
		 (total field)
		 50)))
   (:header "Success%"
    :documentation
    "Percentage of matches for this node and below that were succesful."
    :width (7 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore node)
      (let ((total (total field)))
	(format stream "~6,2,2F%"
		(if (zerop total) 1
		    (float (/ (total (get-component-from-components
				       'incl-match-success components
				       (metering-run-field-descriptions run)))
			      total))))))))
  :current-sub-field-names ("Total" "/Run" "Success/"))

(define-output-field incl-match-success :joshua-merge
  :header "Incl Match Success"
  :documentation
  "Incl Match Success"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Successful matches" 
    :width (5 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore run components node)
      (format stream "~5D" (total field))))
   (:header "/Matches"
    :documentation
    "Bar graph of percentage of matches for this node and below that were succesful."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run components node)
      (ignore node)
      (bar-graph stream
		 (total field)
		 (total 
		   (get-component-from-components 'incl-match-count components
						  (metering-run-field-descriptions run)))
		 50)))
   (:header "%Matches"
    :documentation
    "Percentage of matches for this node and below that were succesful."
    :width (7 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore node)
      (format stream "~6,2,2F%"
	      (float (/ (total field)
			(total (get-component-from-components
				 'incl-match-count components
				 (metering-run-field-descriptions run)))))))))
  :current-sub-field-names ("Total" "/Matches"))
(define-output-field excl-match-count :joshua-merge
  :header "Excl Match Count"
  :documentation
  "Excl Match Count"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Excl Match Count" 
    :width (5 :character)
    :write-function
    (lambda (stream field run components node)
      (ignore run components)
      (if (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	  (format stream "~5D" (total field))
	  (write-string "    -" stream))))
   (:header "Success/"
    :documentation
    "Bar graph of percentage of total matches for this node that were succesful."
    :width (50 :pixel)
    :write-function
    (lambda (stream field run components node)
      (when (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(bar-graph stream
		   (total 
		     (get-component-from-components 'excl-match-success components
						    (metering-run-field-descriptions run)))
		   (total field)
		   50))))
   (:header "Success%"
    :documentation
    "Percentage of matches for this node that were succesful."
    :width (7 :character)
    :write-function
    (lambda (stream field run components node)
      (when (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	(let ((total (total field)))
	  (format stream "~6,2,2F%"
		  (if (zerop total) 1
		      (float (/ (total (get-component-from-components
					 'excl-match-success components
					 (metering-run-field-descriptions run)))
				total)))))))))
  :current-sub-field-names ("Total"))

(define-output-field excl-match-success :joshua-merge
  :header "Excl Match Success"
  :documentation
  "Exclusive Match Success"
  :sub-field-descriptions
  ((:header "Total"
    :documentation "Number of successful matchs at this node."
     :width (5 :character)
     :write-function
     (lambda (stream field run components node)
       (ignore run components)
       (if (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	 (format stream "~5D" (total field))
	 (write-string "    -" stream)))))
  :current-sub-field-names ("Total"))


(define-output-field excl-procedure-count :joshua-merge
  :header "Excl Procedure Count"
  :documentation
  "The number of times this procedure was called."
  :sub-field-descriptions
  ((:header "Total"
    :documentation "The total number of times this procedure was called."
     :width (5 :character)
     :write-function
     (lambda (stream field run components node)
       (ignore run components)
       (if (typep (match-tree-node-joshua-node node) 'ji::Rete-procedure-node)
	 (format stream "~5D" (total field))
	 (write-string "    -" stream)))))
  :current-sub-field-names ("Total"))

(define-output-field incl-procedure-count :joshua-merge
  :header "Incl Procedure Count"
  :documentation
  "The total number of procedure node calls at this node and its descendants."
  :sub-field-descriptions
  ((:header "Total"
    :documentation "The total number of procedure node calls at this node and its descendants."
     :width (5 :character)
     :write-function
     (lambda (stream field run components node)
       (ignore run components)
       (if (typep (match-tree-node-joshua-node node) 'ji::Rete-match-node)
	 (write-string "    -" stream)
	 (format stream "~5D" (total field))))))
  :current-sub-field-names ("Total"))



(defun match-node-pattern (match-node)
   (let ((match-ids (ji::Rete-match-node-match-ids match-node)))
     (if match-ids
	 (ji::match-id-pattern
	   (first match-ids))
	 "No Pattern")))

(defmethod (match-tree-node-depth joshua-match-tree-node) ()
  (if (null parent) 1
      (1+ (match-tree-node-depth parent))))

(define-output-field nil :joshua-merge
  :header "Rule/Clause"
  :documentation "The Rule name or the pattern."
  :sub-field-descriptions
  ((:header ""
    :documentation "The depth of the node followed by a description of the node.
If this node is a rule the description is the rule name.
If this is a match node the description is the match pattern.
An \"*\" is placed in front of the description of shared nodes."
    :width nil
    :write-function
    (lambda (stream field run components node)
      (ignore field run components)
      (let ((depth (match-tree-node-depth node)))
	(format stream "~3d " depth)
	(loop repeat (max (- depth 0 #|| (call-tree-zero-indentation-depth run) ||#)
			  0)
	      do (write-string "| " stream)))
      (format stream "~c " (case (node-status node)
			     (:leaf #\center-dot)
			     (:open #\down-arrow)
			     (:closed #\right-arrow)
			     (:partial #\double-arrow)))
      (if (match-tree-node-shared-p node)
	  (write-char #\* stream)
	  (write-char #\space stream))
      (print-short node stream))))
  :current-sub-field-names (""))

(define-default-output-fields :joshua-merge
			      "Rule Count"  "Incl Merge Count"
			      "Incl Match Count"
			      "Rule/Clause")



;;; ask metering

;;; to do
;;; swap the continuation to be something that is metered
;;;  so that we get the correct exclusive time

(defvar *backward-rule-triggering-collector*
	(metering:make-data-collector 'metering:counter))

(defun metered-1arg-continuation (continuation)
  (flet ((metered-continuation (arg)
	   (funcall continuation arg)))
    #'metered-continuation))

(defflavor joshua-ask-metering-run
	()
	(joshua-predicate-metering-mixin basic-metering-run))

(defmethod (metering-run-type joshua-ask-metering-run) () :joshua-ask)
									    
(defmethod (metering-run-key-type joshua-ask-metering-run) () 'symbol)

(defmethod (metering-run-parameters joshua-ask-metering-run) ()
  `())

(defmethod (define-collector joshua-ask-metering-run) ()
  (metering:make-data-collector
    'metering:record
    :component-description
    '((total-count metering:counter)
      (ask-time metering:modal-histogram)
      (ask-data-time metering:modal-histogram)
      (fetch-time metering:modal-histogram)
      (ask-rules-time metering:modal-histogram)
      (map-over-rules-time metering:modal-histogram)
      (ask-questions-time metering:modal-histogram)
      (rule-count metering:modal-histogram)
      (predicate metering:collect-hash
		 :component-description
		 ((predicate-count metering:counter)
		  (ask-time metering:modal-histogram)
		  (ask-data-time metering:modal-histogram)
		  (fetch-time metering:modal-histogram)
		  (ask-rules-time metering:modal-histogram)
		  (map-over-rules-time metering:modal-histogram)
;		  (trigger-rule-time metering:modal-histogram)
		  (ask-questions-time metering:modal-histogram)
		  (rule-count metering:modal-histogram))))
    :name nil))

(defmethod (describe-run joshua-ask-metering-run) (stream)
  (let ((components (metering:get-components-from-recursive-node collector)))
    (flet ((total-value (component)
	     (total (get-component-from-components component
						   components collector))))	     
      ;; this sure really be a table or two
      (format stream "~&~%~'iTotal number of ASKS for run:~    ~16D~
		    ~&~%~'iTotal number of rules triggered:~ ~16D~
		    ~&~%~'iTotal                             ASK time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                        ASK-DATA time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                           FETCH time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal                       ASK-RULES time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)~
		    ~&~%~'iTotal MAP-OVER-BACKWARD-RULE-TRIGGERS time for run:~ ~:16D (microseconds) or ~:*~12,6,-6F (seconds)"
	      (total-value 'total-count)
	      (total-value 'rule-count)
	      (total-value 'ask-time)
	      (total-value 'ask-data-time)
	      (total-value 'fetch-time)
	      (total-value 'ask-rules-time)
	      (total-value 'map-over-rules-time)))))


;;; this only returns one of the several triggers - but they both have the same
;;; control
(defmethod (metering-run-trigger joshua-ask-metering-run) () 'ji::ask-internal)

(defmethod (set-trigger joshua-ask-metering-run) ()
  (metering:collect-data-from-trigger
    'ji::trigger-backward-rule
    `((,*backward-rule-triggering-collector*)))
  (metering:collect-data-from-trigger
    'ji::ask-internal
    `(((,collector)
       (total-count) (ask-time exclusive-time)
       ((predicate (type-of (first arglist))) (predicate-count)
	(ask-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::ask-rules
    `(((,collector)
       (ask-rules-time exclusive-time)
       (rule-count rule-count)
       ((predicate (type-of (first arglist)))
	(ask-rules-time exclusive-time)
	(rule-count rule-count)))))
  (metering:collect-data-from-trigger
    'ji::map-over-backward-rule-triggers
    `(((,collector)
       (map-over-rules-time exclusive-time)
       ((predicate (type-of (first arglist)))
	(map-over-rules-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::ask-data
    `(((,collector)
       (ask-data-time exclusive-time)
       ((predicate (type-of (first arglist))) 
	(ask-data-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::fetch
    `(((,collector)
       (fetch-time exclusive-time)
       ((predicate (type-of (first arglist)))
	(fetch-time exclusive-time)))))
  (metering:collect-data-from-trigger
    'ji::ask-questions
    `(((,collector)
       (ask-questions-time exclusive-time)
       ((predicate (type-of (first arglist)))
	(ask-questions-time exclusive-time))))))

(defmethod (set-generators joshua-ask-metering-run) ()
  (metering:meter-function 'ji::ask-internal)  
  (let ((trigger (parse-trigger 'ji::ask-internal)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))
	;; bash the arglist to have a metered continuation which calls the regular
	;; continuation
	(computation (progn 
		       (setf (third si:arglist)
			     (metered-1arg-continuation (third si:arglist))))
		     :keywords (:initial)
		     )))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::ask-rules)  
  (let ((trigger (parse-trigger 'ji::ask-rules)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))
	(collector-total *backward-rule-triggering-collector*
			 :keywords (:exclusive (:name rule-count)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::map-over-backward-rule-triggers)
  (let ((trigger (parse-trigger 'ji::map-over-backward-rule-triggers)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))
	;; bash the arglist to have a metered continuation which calls the regular
	;; continuation
	(computation (progn 
		       (setf (second si:arglist)
			     (metered-1arg-continuation (second si:arglist))))
		     :keywords (:initial)
		     )))
    (metering:control-trigger *control-joshua-metering* trigger))
    (metering:meter-function 'ji::trigger-backward-rule)  
  (let ((trigger (parse-trigger 'ji::trigger-backward-rule)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::ask-data)  
  (let ((trigger (parse-trigger 'ji::ask-data)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::fetch)
  (let ((trigger (parse-trigger 'ji::fetch)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function 'ji::ask-questions)  
  (let ((trigger (parse-trigger 'ji::ask-questions)))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger))
  (metering:meter-function '(:INTERNAL METERED-1ARG-CONTINUATION 0 METERED-CONTINUATION))  
  (let ((trigger (parse-trigger '(:INTERNAL METERED-1ARG-CONTINUATION 0 METERED-CONTINUATION))))
    (clear-trigger trigger)
    (metering:generate-data-at-trigger
      trigger
      '((metering:real-time :keywords 
			    (:overhead :exclusive (:name exclusive-time)))))
    (metering:control-trigger *control-joshua-metering* trigger)))

(defmethod (set-scope joshua-ask-metering-run) ()
  (let ((region-spec (parse-region region)))
    (set-scope-of-control
      *control-joshua-metering*
      `(and :switch
	    (:process ,process)
	    ,@(if region-spec
		  `((:within (and (:region ,region-spec)
				  (not (:region #'dbg:debugger-top-level)))
		     (:process ,process)))
		  `((not (:within (:region #'dbg:debugger-top-level)
			  (:process ,process)))))))))

(defmethod (clear-scope joshua-ask-metering-run) ()
  (metering:unmeter-function 'ji::ask-internal)
  (metering:unmeter-function 'ji::ask-rules)
  (metering:unmeter-function 'ji::map-over-backward-rule-triggers)
  (metering:unmeter-function 'ji::trigger-backward-rule)
  (metering:unmeter-function 'ji::ask-data)
  (metering:unmeter-function 'ji::fetch)
  (metering:unmeter-function 'ji::ask-questions)
  (metering:unmeter-function '(:function (:INTERNAL METERED-1ARG-CONTINUATION 0 METERED-CONTINUATION)))
  
  (set-scope-of-control *control-joshua-metering* nil))



(define-sorting-options :joshua-ask
			`(("predicate name" :key ,#'identity ,#'alphalessp)))



(define-output-field predicate-count :joshua-ask
  :header "Ask"
  :documentation "Count of Asks."
  :sub-field-descriptions
  ((:header "Count"
     :documentation "Number of times a predication of this predicate was told." 
     :width (5 :character)
     :write-function
     (lambda (stream field &rest ignore)
       (format stream "~5D" (total field)))))
  :current-sub-field-names ("Count"))

(define-output-field-modal-histogram (ask-time :joshua-ask "Ask Time")
				     "The exclusive time spent doing ASK."
  nil
  :within "spent in the ASK part of the protocol"
  :per-what "ask")

(define-output-field-modal-histogram (fetch-time :joshua-ask "Fetch")
				     "The exclusive time spent handling the FETCH part of the protocol."
  nil
  :within "spent in the ASK-DATA part of the protocol"
  :per-what "ask")

(define-output-field-modal-histogram (ask-data-time :joshua-ask "Ask Data")
				     "The exclusive time spent handling the ASK-DATA part of the protocol."
  nil
  :within "spent in the ASK-DATA part of the protocol"
  :per-what "ask")

(define-output-field-modal-histogram (ask-rules-time :joshua-ask "Ask Rules")
				     "The exclusive time spent handling the ASK-RULES part of the protocol."
  nil
  :within "spent in the ASK-RULES part of the protocol"
  :per-what "ask")

(define-output-field-modal-histogram (rule-count :joshua-ask "Rule Count")
				     "The number of rules directly triggered by this ask"
  nil
  :type "number of rules"
  :units ""
  :within "directly triggered by this ask"
  :per-what "ask")

(define-output-field-modal-histogram (map-over-rules-time :joshua-ask "Map Over Rules")
				     "The exclusive time spent handling the MAP-OVER-BACKWARD-RULES part of the protocol."
  nil
  :within "spent in the MAP-OVER-BACKWARD-RULE-TRIGGERS part of the protocol"
  :per-what "ask")

(define-output-field nil :joshua-ask
  :header "Predicate"
  :documentation "The predicate."
  :sub-field-descriptions
  ((:header ""
    :documentation "The predicate name."
    :width nil
    :write-function
    (lambda (stream field run entry predicate)
      (ignore field run entry)
      (when predicate
	(present predicate (type-of predicate) :stream stream)))))
  :current-sub-field-names (""))

(define-default-output-fields :joshua-ask
			      "Ask" "Ask Time" "Ask Data" "Fetch" "Ask Rules"
  "Predicate")
