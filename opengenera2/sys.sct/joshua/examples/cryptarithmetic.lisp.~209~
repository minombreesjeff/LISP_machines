;;; -*- Mode: Joshua; Package: Crypt; Syntax: Joshua; Base: 10 -*-

;;;> EXAMPLES-MESSAGE
;;;>
;;;>******************************************************************************************
;;;>
;;;>       Symbolics hereby grants permission to customer to incorporate
;;;>       the examples in this file in any work belonging to customer.
;;;>
;;;>******************************************************************************************
;;; Created Friday the eighteenth of October, 1985; 9:06:51 pm by sgr on GROUSE at SCRC

;;;
;;; Cryptarithmetic from Newell and Simon's D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Human Problem-Solving0, chapters 5-7.  The problem we
;;; want to solve is to find a bijection from the base-10 digits to the letters {A B D E G L N O R T}
;;; such that the arithmetic problem
;;;
;;;     D O N A L D 
;;;   + G E R A L D
;;;     -----------
;;;     R O B E R T
;;;
;;; is satisfied.  This just stops after finding one solution, instead of trying to find them all.
;;;
;;; The model is primarily one of algebraic constraints.  For example, the above problem is the
;;; following set of algebraic constraints (where C(2 0 (NIL 0) (NIL NIL :SMALLER) "EINY7")ij0 means the carry from column i into column j
;;; (always 0 or 1)):
;;;
;;;  2 0  2 0    2D = T + 10 C2010 (the carry into column 0 is always 0)
;;; C2010 +    2L = R + 10 C212
0;;; C2120 +    2A = E + 10 C223
0;;; C2230 + N + R = B + 10 C234
0;;; C2340 + O + E = O + 10 C245
0;;; C2450 + D + G = R          (the carry out of the leftmost column is always 0)
;;;
;;; We relax so all the constraints are satisfied with the current partial solution, and then 
;;; propose guesses.  The LTMS enforces the constraints and backtracks appropriately.
;;;
;;; So suppose we want to solve the above problem with the clue that D=5.
;;;
;;; * T is even, since it's 2D.
;;; * E is 0 or 9, depending on whether C2340 is 0 or 1, since O + E = O.
;;;
;;; * D = 5, from the clue.
;;;
;;; * T = 0 from D = 5.
;;; * C2010 = 1 from D = 5.
;;; * E = 9 since E = 0 or 9 and T = 0.
;;; * C2120 = 1 from E = 9 & 2A is even.
;;; * C2340 is 1 from E = 9.
;;; * C2450 is 1 from E = 9.
;;; * R is odd from C2010 = 1.
;;; * R is 1,3, or 7 from R is odd and D = 5, E = 9.
;;; * G = 1,2, or 3 from D = 5.
;;; * A = 4 & C2230 = 0 from E = 9 & C2120 = 1.
;;; * R = 7 from 5 + G = R & G = 1,2, or 3.
;;; * L = 8 from 1 + 2L = 7 + 10
;;; * G = 1 from 1 + 5 + G = 7.
;;;
;;; Remains to do a quick search for B, N, and O amongst 2, 3, and 6.  (One of the equations even
;;; narrows N & B to be 6 & 3, respectively.  That leaves O = 2.)
;;;

;;;
;;; Thingz todo:
;;;
;;; RIVER + WATER = SHIPS is still unsolved.

;;; Leftmost letter of sum is never 0.

;;; carry-in = 0.  addend + 9 = sum  addend = sum +1 mod 10

;;; Add clues to other problems.





;;; A cryptarithmetic structure is the data structure that makes
;;; accessing critical information fast.
;;; Obviously we want to find out what we know about each letter
;;; quickly.  So we maintain a list of structures which tell us just that.
;;; Each structure has:
;;;  the name of the letter
;;;  it's current digit value if any
;;;  how many possibilities are left for this letter
;;;  and a vector of predications each one saying
;;;   (value-of-letter-is <letter> i)
;;;   where i is it's index in the vector.
;;; Notice that the three truth values for such predications are
;;; all signification:
;;; If [Value-of-letter <letter> i] is
;;;  *true* then i is currently believed to be the assignment to this letter.
;;;  *false*     i is precluded as a value for this letter.
;;;  *unknown*   i is still a possibility.

;;; Most of the reasoning will be by exclusion.  In particular, if we find that
;;; there is exactly one possibility left for a letter we are forced to take it.
;;; It's faster and more natural to do this in notice-truth-value-change methods.

(defvar *possibilities-update-screen* nil)
(defvar *solution-update-screen* nil)

(defstruct (letter-structure)
  the-letter
  current-value
  current-predication
  (number-of-possibilities-left 10)
  (tick 0)
  (vector (make-array 10))
  (parity-vector (make-array 2))
  (number-of-occurances-in-problem 0)
  (parity-display-piece)
  (possibilities-display-piece-vector (make-array 10))
  (current-value-display-piece)
  )

(defun build-letter-table ()
  (let ((array (make-array 26)))
    (loop for i below 26
	  for character-code from #o101
	  for letter = (character character-code)
	  doing (setf (aref array i) (make-letter-structure :the-letter letter)))
    array))

(defun reset-letter-structure (letter-structure)
  (setf (letter-structure-current-value letter-structure) nil
	(letter-structure-current-predication letter-structure) nil
	(letter-structure-number-of-possibilities-left letter-structure) 10
	(letter-structure-tick letter-structure) 0
	(letter-structure-number-of-occurances-in-problem letter-structure) 0)
  (loop with vector = (letter-structure-vector letter-structure)
	for i below 10
	do (setf (aref vector i) nil))
  (loop with vector = (letter-structure-parity-vector letter-structure)
	for i below 2
	doing (setf (aref vector i) nil)))

(defvar *letter-table* (build-letter-table))

(defun letter-structure-for-letter (letter)
  (aref *letter-table* (- (char-code (char-upcase letter)) #.(char-code #\A))))

(defstruct (column-structure)
  (tick 0)
  (column-number nil)
  (carry-in nil)
  (carry-out nil)
  (carry-in-vector (make-array 2))
  (carry-out-vector (make-array 2))
  (addend-letter nil)
  (augend-letter nil)
  (sum-letter nil)
  (carry-in-display-piece)
  (addend-display-piece)
  (augend-display-piece)
  (sum-display-piece))

(defun reset-column-structure (self)
  (setf (column-structure-tick self) 0
	(column-structure-carry-in self) nil
	(column-structure-carry-out self) nil
	(column-structure-addend-letter self) nil
	(column-structure-augend-letter self) nil
	(column-structure-sum-letter self) nil)
  (loop for i below 2
	doing (setf (aref (column-structure-carry-in-vector self) i) nil)
	      (setf (aref (column-structure-carry-out-vector self) i) nil)))

(defun build-column-table ()
  (loop with vector = (make-array 6)
	for i below 6
	do (setf (aref vector i)
		 (make-column-structure :column-number i))
	finally (return vector)))

(defvar *column-table* (build-column-table))


(3 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")
0;;;
;;; Predicate definitions.
;;;

(define-predicate-model crypt-letter
	(my-structure)
	()
  (:writable-instance-variables))

(define-predicate-method (insert crypt-letter) ()
  (with-statement-destructured (letter digit) self
    (let ((letter-structure (letter-structure-for-letter letter)))
      (let ((pred (aref (letter-structure-vector letter-structure) digit)))
	(if pred
	    (values pred nil)
	    (progn
	      (setf (aref (letter-structure-vector letter-structure) digit) self)
	      (setq my-structure letter-structure)
	      (values self t)))))))

(define-predicate-method (ask-data crypt-letter) (truth-value continuation)
  (with-statement-destructured (letter value) self
    (flet ((handle-a-letter (the-structure)
	     (select truth-value
	       (*true* (when (letter-structure-current-value the-structure)
			 (with-unification
			   (unify value (letter-structure-current-value the-structure))
			   (stack-let ((backward-support `(,self ,*true* ,(letter-structure-current-predication the-structure))))
			     (funcall continuation backward-support)))))
	       (otherwise
		 (if (sys:unbound-logic-variable-p value)
		     (loop with vector = (letter-structure-vector the-structure)
			   for i below 10
			   for pred = (aref vector i)
			   when (and pred (or (null truth-value)
					      (eql (predication-truth-value pred) truth-value)))
			     do (with-unification
				  (unify i value)
				  (stack-let ((backward-support `(,self ,(predication-truth-value pred) ,pred)))
				    (funcall continuation backward-support))))
		     (let ((pred (aref (letter-structure-vector the-structure) value)))
		       (when (and pred (or (null truth-value)
					   (eql (predication-truth-value pred) truth-value)))
			 (stack-let ((backward-support `(,self ,(predication-truth-value pred) ,pred)))
			   (funcall continuation backward-support)))))))))
      (if (sys:unbound-logic-variable-p letter)
	  (loop for letter-structure being the array-elements of *letter-table*
		do (with-unification
		     (unify letter (letter-structure-the-letter letter-structure))
		     (handle-a-letter letter-structure)))
	  (handle-a-letter (letter-structure-for-letter letter))))))

(define-predicate-method (notice-truth-value-change crypt-letter) (old-truth-value)
  (with-statement-destructured (ignore value) self
    (incf (letter-structure-tick my-structure))
    (select old-truth-value
      (*true*
       ;; If I've ceased to be true update the current-value cache in the structure.
       (when (eql (letter-structure-current-value my-structure) value)
	 (setf (letter-structure-current-value my-structure) nil
	       (letter-structure-current-predication my-structure) nil)))
      (*false*
       ;; If I've ceased to be false update the count of possibilities left.
       (incf (letter-structure-number-of-possibilities-left my-structure))))
    (select (predication-truth-value self)
      (*true* 
       ;; If I've become true update the current-value cache in the structure
       ;; unless someone else is there because then there's a contradiction.
       (unless (and (letter-structure-current-predication my-structure)
		    ;; make sure he's true.
		    (eql (predication-truth-value (letter-structure-current-predication my-structure)) *true*))
	 (setf (letter-structure-current-value my-structure) value
	       (letter-structure-current-predication my-structure) self)))
      (*false*
       ;; If I've become false there's one less possibility
       (decf (letter-structure-number-of-possibilities-left my-structure))))))

(define-predicate-method (act-on-truth-value-change crypt-letter :before) (old-truth-value)
  ;; If we're updating displays do this stuff
  (when *possibilities-update-screen*
    (with-statement-destructured (ignore value) self
      (when (or (eql (predication-truth-value self) *true*)
		(eql old-truth-value *true*))
	;; If we've either become or stopped being true
	;; update both the cell for the possibility
	;; and update the addition display
	(let ((redisplayer (letter-structure-current-value-display-piece my-structure)))
	  (dw:do-redisplay redisplayer *possibilities-update-screen*))
	(jericho:redisplay-pane dw:*program* 'cryptarithmetic-solution))
      (when (or (eql (predication-truth-value self) *false*)
		(eql old-truth-value *false*))
	;; If we've become false update the cell for the possibility
	(let ((redisplayer (aref (letter-structure-possibilities-display-piece-vector my-structure) value)))
	  (dw:do-redisplay redisplayer *possibilities-update-screen*))))))

(define-predicate-method (clear crypt-letter) (database ignore)
  (when database
    (loop for letter-structure being the array-elements of *letter-table*
	  doing (reset-letter-structure letter-structure))
    (loop for column-structure being the array-elements of *column-table*
	  doing (reset-column-structure column-structure))
    ))

(define-predicate column-sum-is (number addend augend sum)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))
(define-predicate leftmost-column-is (number)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))
(define-predicate letter-is-in-problem (letter)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))
(define-predicate value-of-letter-is (letter digit)
		  (no-variables-in-data-mixin crypt-letter ltms:ltms-predicate-model))
(define-predicate out-of-possibilities (letter)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))
(define-predicate carry-in (column carry)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))
(define-predicate carry-out (column carry)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))
(define-predicate has-parity (letter parity)
		  (no-variables-in-data-mixin ltms:ltms-predicate-model))

(define-predicate-method (insert carry-in) ()
  (with-statement-destructured (column value) self
    (let* ((column-structure (aref *column-table* column))
	   (carry-in-table (column-structure-carry-in-vector column-structure))
	   (slot (aref carry-in-table value)))
      (if slot
	  (values slot nil)
	  (progn (setf (aref carry-in-table value) self)
		 (values self t))))))

(define-predicate-method (fetch carry-in) (continuation)
  (flet ((fetch-it (column-structure value)
	   (let* ((carry-in-table (column-structure-carry-in-vector column-structure))
		  (slot (aref carry-in-table value)))
	     (when slot (funcall continuation slot)))))
    (with-statement-destructured (column value) self
      (cond ((sys:unbound-logic-variable-p column)
	     (loop for column-structure being the array-elements of *column-table*
		   if (sys:unbound-logic-variable-p value)
		     do (loop for carry below 2
			      doing (fetch-it column-structure carry))
		   else do (fetch-it column-structure value)))
	    (t (let* ((column-structure (aref *column-table* column)))
		 (if (sys:unbound-logic-variable-p value)
		     (loop for carry below 2
			   doing (fetch-it column-structure carry))
		     (fetch-it column-structure value))))))))

(define-predicate-method (notice-truth-value-change carry-in) (ignore)
  (with-statement-destructured (column carry) self
    (if (eql (predication-truth-value self) *true*)
	(setf (column-structure-carry-in (aref *column-table* column)) carry)
	(if (eql (column-structure-carry-in (aref *column-table* column)) carry)
	    (setf (column-structure-carry-in (aref *column-table* column)) nil)))))

(define-predicate-method (insert carry-out) ()
  (with-statement-destructured (column value) self
    (let* ((column-structure (aref *column-table* column))
	   (carry-out-table (column-structure-carry-out-vector column-structure))
	   (slot (aref carry-out-table value)))
      (if slot
	  (values slot nil)
	  (progn (setf (aref carry-out-table value) self)
		 (values self t))))))

(define-predicate-method (fetch carry-out) (continuation)
  (flet ((fetch-it (column-structure value)
	   (let* ((carry-out-table (column-structure-carry-out-vector column-structure))
		  (slot (aref carry-out-table value)))
	     (when slot (funcall continuation slot)))))
    (with-statement-destructured (column value) self
      (cond ((sys:unbound-logic-variable-p column)
	     (loop for column-structure being the array-elements of *column-table*
		   if (sys:unbound-logic-variable-p value)
		     do (loop for carry below 2
			      doing (fetch-it column-structure carry))
		   else do (fetch-it column-structure value)))
	    (t (let* ((column-structure (aref *column-table* column)))
		 (if (sys:unbound-logic-variable-p value)
		     (loop for carry below 2
			   doing (fetch-it column-structure carry))
		     (fetch-it column-structure value))))))))

(define-predicate-method (notice-truth-value-change carry-out) (ignore)
  (with-statement-destructured (column carry) self
    (if (eql (predication-truth-value self) *true*)
	(setf (column-structure-carry-out (aref *column-table* column)) carry)
	(if (eql (column-structure-carry-out (aref *column-table* column)) carry)
	    (setf (column-structure-carry-out (aref *column-table* column)) nil)))))

(define-predicate-method (notice-truth-value-change column-sum-is :before) (ignore)
  (with-statement-destructured (column addend augend sum) self
    (let ((structure (aref *column-table* column)))
      (setf (column-structure-addend-letter structure) addend
	    (column-structure-augend-letter structure) augend
	    (column-structure-sum-letter structure) sum))))

(define-predicate-method (act-on-truth-value-change column-sum-is :before) (ignore)
  (when *possibilities-update-screen*
    (jericho:redisplay-pane dw:*program* 'cryptarithmetic-solution)))

(define-predicate-method (insert has-parity) ()
  (with-statement-destructured (letter value) self
    (let* ((letter-structure (letter-structure-for-letter letter))
	   (parity-vector (letter-structure-parity-vector letter-structure))
	   (index (if (eq value 'even) 0 1))
	   (slot (aref parity-vector index)))
      (if slot
	  (values slot nil)
	  (progn (setf (aref parity-vector index) self)
		 (values self t))))))

(define-predicate-method (fetch has-parity) (continuation)
  (flet ((fetch-it (letter-structure parity)
	   (let* ((parity-vector (letter-structure-parity-vector letter-structure))
		  (index (if (eq parity 'even) 0 1))
		  (slot (aref parity-vector index)))
	     (when slot (funcall continuation slot)))))
    (with-statement-destructured (letter value) self
      (cond ((sys:unbound-logic-variable-p letter)
	     (loop for letter-structure being the array-elements of *letter-table*
		   if (sys:unbound-logic-variable-p value)
		     do (loop for parity in '(even odd)
			      doing (fetch-it letter-structure parity))
		   else do (fetch-it letter-structure value)))
	    (t (let ((letter-structure (letter-structure-for-letter letter)))
		 (if (sys:unbound-logic-variable-p value)
		     (loop for parity in '(even odd)
			   doing (fetch-it letter-structure parity))
		     (fetch-it letter-structure value))))))))

(defmethod (act-on-truth-value-change has-parity :before) (old-truth-value)
  (when *possibilities-update-screen*
    (when (or (eql old-truth-value *true*)
	      (eq (predication-truth-value self) *true*))
      (with-statement-destructured (letter ignore) self
	(let ((letter-structure (letter-structure-for-letter letter)))
	  (dw:do-redisplay (letter-structure-parity-display-piece letter-structure)
			   *possibilities-update-screen*))))))



;;; Some utilities the rules and I/O stuff might like to use.
;;;

(defun opposite-parity (parity)
  ;; the opposite one
  (ecase parity
    (even 'odd)
    (odd 'even)))

(defun digit-parity (digit)
  ;; symbolic parity
  (if (evenp digit)
      'even
      'odd))

(defun find-digit (letter)
  ;; find the digit a letter corresponds to
  (declare (values digit support))
  (letter-structure-current-value (letter-structure-for-letter letter)))

(defun find-letter (digit)
  ;; find the letter a digit corresponds to
  (declare (values letter support))
  (loop for letter-structure in *letter-table*
	for pred = (aref (letter-structure-vector letter-structure) digit)
	when (eql (predication-truth-value pred) *true*)
	  return (letter-structure-the-letter letter-structure)))

(defun letters-in (addend augend sum)
  (when (and (stringp addend) (stringp augend) (stringp sum))
    (loop with letters = nil
	  for i below (string-length addend)
	  do (pushnew (aref addend i) letters :test #'char-equal)
	     (pushnew (aref augend i) letters :test #'char-equal)
	     (pushnew (aref sum i) letters :test #'char-equal)
	  finally (return (sort letters #'alphalessp)))))

(defun possible-values-for-letter (letter)
  (loop with structure = (letter-structure-for-letter letter)
	with vector = (letter-structure-vector structure)
	for i below 10
	for pred = (aref vector i)
	if (and pred (eql (predication-truth-value pred) *false*))
	  collect pred into facts
	else collect i into digits
	finally (return (values digits facts))))

(defun possible-values-for-letter-are-exactly (letter desired-set)
  (loop with structure = (letter-structure-for-letter letter)
	with vector = (letter-structure-vector structure)
	for i below 10
	for pred = (aref vector i)
	for value-is-precluded = (and pred (eql (predication-truth-value pred) *false*))
	for value-should-be-precluded = (not (member i desired-set))
	if (not (eql value-is-precluded value-should-be-precluded))
	  do (return-from possible-values-for-letter-are-exactly nil)
	else when value-is-precluded collect pred))


(defun create-cryptarithmetic-description (addend augend sum &optional update-display-function)
  ;; given a cryptarithmetic problem, decompose it into columns after a bit of error-checking.
  ;; also note the leftmost column and the names of all the letters involved.
  (let ((addend-size (string-length addend))
	(augend-size (string-length augend))
	(sum-size (string-length sum)))
    (unless (= addend-size augend-size sum-size)
      (error "This cryptarithmetic solver only deals with problems where the addend, ~
                         ~&augend, and sum have the same number of letters.  Hence it won't solve~
                         ~&~A + ~A = ~A, since they have ~D, ~D, and ~D letters, respectively."
	     addend augend sum
	     (string-length addend) (string-length augend) (string-length sum)))
    (let* ((size (1- addend-size))
	  (letters (letters-in addend augend sum))
	  (letter-structures (loop for letter in letters collect (letter-structure-for-letter letter))))
      (when (> (length letters) 10)
	(error "The problem ~A + ~A = ~A has ~D letters.  There are only 10 digits, though."
	       addend augend sum (length letters)))
      ;; count number of occurances of each letter
      ;; used to guide search
      (loop for letter-structure in letter-structures
	    for letter = (letter-structure-the-letter letter-structure)
	    do (loop for i below size
		     when (char-equal (aref augend i) letter)
		       do (incf (letter-structure-number-of-occurances-in-problem letter-structure))
		     when (char-equal (aref addend i) letter)
		       do (incf (letter-structure-number-of-occurances-in-problem letter-structure))
		     when (char-equal (aref sum i) letter)
		       do (incf (letter-structure-number-of-occurances-in-problem letter-structure))))
      ;; Enforce the constraint that each letter must have a digit.
      (loop for letter in letters
	    ;; We assert as a premise that we're not out of possibilities for
	    ;; each letter
	    for out-of-possibilities-pred = (tell `[not [out-of-possibilities ,letter]])
	    doing (tell `[letter-is-in-problem ,letter])
		  ;; and we build a justification that says we are out of possibilities
		  ;; if we have all the value-of possibilities for this letter negated.
		  ;; Consult the arguments to Justify if this confuses you.
		  (justify out-of-possibilities-pred
			   *true*
			   'letter-must-have-a-value
			   nil
			   (loop for i below 10
				 collect (tell `[value-of-letter-is ,letter ,i] :justification :none))))
      ;; Enforce the constraint that the parity of a letter is unique
      (loop for letter in letters
	    for even = (tell `[has-parity ,letter even] :justification :none)
	    for odd = (tell `[has-parity ,letter odd] :justification :none)
	    do (justify odd *false* 'unique-letter-parity (list even)))
      ;; Enforce the constraint that each letter can have most one digit
      (loop for structure in letter-structures
	    do (loop with vector = (letter-structure-vector structure)
		     for i below 10
		     for pred1 = (aref vector i)
		     do (loop for j from (1+ i) below 10
			      for pred2 = (aref vector j)
			      do (justify pred2 *false* 'single-digit-for-letter (list pred1)))))
      ;; Enforce the constraint that each digit can be assigned to at most one letter
      (loop for i below 10
	    do (loop for structures on letter-structures
		     for first = (first structures)
		     for pred1 = (aref (letter-structure-vector first) i)
		     do (loop for second in (rest structures)
			      for pred2 = (aref (letter-structure-vector second) i)
			      do (justify pred2 *false* 'single-letter-for-digit (list pred1)))))
      ;; Enforce the constraint that the carry into and carry out of each column is unique
      (loop for i from 0 to size
	    for carry-in-0 = (tell `[carry-in ,i 0] :justification :none)
	    for carry-in-1 = (tell `[carry-in ,i 1] :justification :none)
	    for carry-out-0 = (tell `[carry-out ,i 0] :justification :none)
	    for carry-out-1 = (tell `[carry-out ,i 1] :justification :none)
	    do (justify carry-in-1 *false* 'carry-in-is-unique (list carry-in-0))
	       (justify carry-out-1 *false* 'carry-out-is-unique (list carry-out-0)))
      (when update-display-function (funcall update-display-function))
      ;; Finally get the thing started
      (tell `[leftmost-column-is ,size])
      (tell `[carry-out ,size 0])
      (tell [carry-in 0 0])
      (loop for index from size downto 0
	    for column-number = (- size index)
	    for addend-letter = (aref addend index)
	    for augend-letter = (aref augend index)
	    for sum-letter = (aref sum index)
	    do (tell `[column-sum-is ,column-number ,addend-letter ,augend-letter ,sum-letter]))
      (setq letters (reverse letters))
      (values letters size))))



3

0;;;
;;; Now some rules that can deduce the parity of some letters.  The first 3 capitalize on the fact that
;;; if a digit is repeated, you can determine the parity of the other from the carry-in.  Most of the
;;; rest exploit the relationships between the digit parities and the carry-in.  The final one just
;;; notices that if a digit has been assigned, we know the parity.
;;;

(defrule parity-1 (:forward)
  ;; if addend = augend, then parity of sum is determined by the carry-in.
  IF [and [column-sum-is ?n ?addend ?addend ?sum]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?sum ,(if (= ?carry-in 0) 'even 'odd)])

(defrule parity-2 (:forward)
  ;; if addend = sum, then augend is even if ci = 0, else odd:
  ;; Just like parity-1 but here addend and sum are known to be equal.
  IF [and [column-sum-is ?n ?addend ?augend ?addend]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?augend ,(if (= ?carry-in 0) 'even 'odd)])

(defrule parity-3 (:forward)
  ;; if augend = sum, then addend is even if ci = 0, else odd:
  ;; ci + addend + augend = augend + 10*co    ci + augend = 10*co (rhs is even, thus ci & addend same)
  ;; just like parity-2, but with addend & augend swapped.
  IF [and [column-sum-is ?n ?addend ?augend ?augend]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?addend ,(if (= ?carry-in 0) 'even 'odd)])

(defrule parity-4 (:forward)
  ;; if addend + augend is even, then parity of sum is determined by carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  ;; the sum of 2 numbers is even iff they're of the same parity
	  [has-parity ?addend ?parity]
	  [has-parity ?augend ?parity]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?sum ,(if (= ?carry-in 0) 'even 'odd)])

(defrule parity-5 (:forward)
  ;; if addend + augend is odd, then parity of sum is determined by opposite of carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  ;; the sum of 2 numbers is odd iff they're of opposite parity
	  [has-parity ?addend ?addend-parity]
	  [has-parity ?augend ?augend-parity]
	  (not (eql ?addend-parity ?augend-parity))
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?sum ,(if (= ?carry-in 0) 'odd 'even)])

(defrule parity-6 (:forward)
  ;; if sum is even, then addend and augend have same parity if carry-in is 0, otherwise opposite
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [has-parity ?sum even]
	  [has-parity ?addend ?addend-parity]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?augend ,(if (= ?carry-in 0) ?addend-parity (opposite-parity ?addend-parity))])

(defrule parity-7 (:forward)
  ;; if sum is even, then addend and augend have same parity if carry-in is 0, otherwise opposite
  ;; like parity-7, but with addend & augend swapped
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [has-parity ?sum even]
	  [has-parity ?augend ?augend-parity]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?addend ,(if (= ?carry-in 0) ?augend-parity (opposite-parity ?augend-parity))])

(defrule parity-8 (:forward)
  ;; if sum is odd, then addend and augend have opposite parity if carry-in is 0, otherwise same
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [has-parity ?sum odd]
	  [has-parity ?addend ?addend-parity]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?augend ,(if (= ?carry-in 0) (opposite-parity ?addend-parity) ?addend-parity)])

(defrule parity-9 (:forward)
  ;; if sum is odd, then addend and augend have opposite parity if carry-in is 0, otherwise same
  ;; like parity-8, but with addend & augend swapped
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [has-parity ?sum odd]
	  [has-parity ?augend ?augend-parity]
	  [carry-in ?n ?carry-in]]
  THEN `[has-parity ?addend ,(if (= ?carry-in 0) (opposite-parity ?augend-parity) ?augend-parity)])

(defrule parity-10 (:forward)
  ;; deduce parities from partial answers
  IF [value-of-letter-is ?letter ?digit]
  THEN `[has-parity ?letter ,(digit-parity ?digit)])

3
0;;;
;;; Some rules that tell how carries propagate between columns.  The first 2 just express that there are
;;; no carries into column 0 and no carries out of the leftmost one.  The rest either exploit the
;;; relationship between parities of the digits and the carry-in, or the restricted properties of 0 & 9.
;;;

(defrule carry-out-propagation (:forward)
  If [and [carry-out ?column ?carry-out]
	  [leftmost-column-is ?leftmost]
	  (< ?column ?leftmost)]
  Then `[carry-in ,(1+ ?column) ?carry-out])

(defrule carry-in-propagation (:forward)
  If [and [carry-in ?column ?carry-in]
	  (> ?column 0)]
  Then `[carry-out ,(1- ?column) ?carry-in])

;;; The next two rules are wrong but something like them is true.
;;; On the other hand we probably don't need them anyhow.
;(defrule carry-1 (:forward)
;  ;; if carry-out is 1 and the addend isn't the same letter as the sum
;  ;; then addend can't be 0
;  ;; because if it were then sum would equal it.
;  If [and [column-sum-is ?n ?addend ?augend ?sum]
;	  [carry-out ?n 1]]
;  then [and [not [value-of-letter-is ?addend 0]]
;	    [not [value-of-letter-is ?augend 0]]])
;
;(defrule carry-2 (:forward)
;  ;; if carry-in is 0, the neither addend nor augend can be 0
;  ;; because if it were then sum would equal it.
;  If [and [column-sum-is ?n ?addend ?augend ?sum]
;	  [carry-in ?n 0]]
;  then [and [not [value-of-letter-is ?addend 0]]
;	    [not [value-of-letter-is ?augend 0]]])

(defrule carry-3 (:forward)
  ;; if addend = augend, then carry-in is determined by parity of sum.
  ;; inverse of parity-1.
  IF [and [column-sum-is ?n ?addend ?addend ?sum]
	  [has-parity ?sum ?sum-parity]]
  THEN `[carry-in ?n ,(if (eq ?sum-parity 'even) 0 1)])

(defrule carry-4 (:forward)
  ;; if addend = sum, then carry-in is determined by parity of augend.
  ;; ci + addend + augend = addend + 10*co    ci + augend = 10*co (rhs is even)
  ;; inverse of parity-2
  IF [and [column-sum-is ?n ?addend ?augend ?addend]
	  [has-parity ?augend ?augend-parity]]
  THEN `[carry-in ?n ,(if (eq ?augend-parity 'even) 0 1)])

(defrule carry-5 (:forward)
  ;; if augend = sum, then carry-in is determined by parity of addend.
  ;; ci + addend + augend = augend + 10*co    ci + adend = 10*co (rhs is even)
  ;; inverse of parity-3.  like carry-4, but with addend & augend swapped.
  IF [and [column-sum-is ?n ?addend ?augend ?augend]
	  [has-parity ?addend  ?addend-parity]]
  THEN `[carry-in ?n ,(if (eq ?addend-parity 'even) 0 1)])

(defrule carry-6 (:forward)
  ;; repeating a letter in the sum and having a 9 means both carries are 1
  ;; ci + letter + 9 = letter + 10*co    ci + 9 = 10*co    ci = co = 1
  IF [and [column-sum-is ?n ?addend ?augend ?addend]
	  [value-of-letter-is ?augend 9]]
  THEN [and [carry-in ?n 1]
	    [carry-out ?n 1]])

(defrule carry-7 (:forward)
  ;; repeating a letter in the sum and having a 9 means both carries are 1
  ;; ci + 9 + letter = letter + 10*co    ci + 9 = 10*co    ci = co = 1
  ;; just like carry-6, but with addend & augend swapped.
  IF [and [column-sum-is ?n ?addend ?augend ?augend]
	  [value-of-letter-is ?addend 9]]
  THEN [and [carry-in ?n 1]
	    [carry-out ?n 1]])

(defrule carry-8 (:forward)
  ;; repeating a letter in the sum and having a 0 means both carries are 0
  ;; ci + letter + 0 = letter + 10*co    ci = 10*co    ci = co = 0
  IF [and [column-sum-is ?n ?addend ?augend ?augend]
	  [value-of-letter-is ?addend 0]]
  THEN [and [carry-in ?n 0]
	    [carry-out ?n 0]])

(defrule carry-9 (:forward)
  ;; repeating a letter in the sum and having a 0 means both carries are 0
  ;; carry-in = 0, then 0 + letter = letter means carry-out = 0 also.
  ;; just like carry-8, but with addend & augend swapped.
  IF [and [column-sum-is ?n ?addend ?augend ?addend]
	  [value-of-letter-is ?augend 0]]
  THEN [and [carry-in ?n 0]
	    [carry-out ?n 0]])

(defrule carry-10 (:forward)
  ;; if addend & augend have same parity, we can determine carry-in from sum parity
  ;; inverse of parity-4
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [has-parity ?addend ?parity]
	  [has-parity ?augend ?parity]
	  [has-parity ?sum ?sum-parity]]
  THEN `[carry-in ?n ,(if (eq ?sum-parity 'even) 0 1)])

(defrule carry-11 (:forward)
  ;; if addend & augend have opposite parity, we can determine carry-in from opposite of sum parity
  ;; inverse of parity-5
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [has-parity ?addend ?addend-parity]
	  [has-parity ?augend ?augend-parity]
	  (not (eql ?addend-parity ?augend-parity))
	  [has-parity ?sum ?sum-parity]]
  THEN `[carry-in ?n ,(if (eq ?sum-parity 'even) 1 0)])

(defrule carry-12 (:forward)
  ;; if 2 columns look identical except for their sums, their carry-ins must be different
  ;; if this were not so, sum1 and sum2 would map to the same digit!
  IF [and [column-sum-is ?n ?addend ?augend ?sum1]
	  [column-sum-is ?m ?addend ?augend ?sum2]
	  ( ?n ?m)
	  (char ?sum1 ?sum2)
	  [carry-in ?n ?carry-in-1]]
  THEN `[carry-in ?m ,(if (= ?carry-in-1 0) 1 0)])

3
0;;;
;;; Rules that are the definition of addition:  C2in0 + Addend + Augend = Sum + 10 * C2out0.  The first
;;; 3 rules assume we know the carry-in and 2 of the 3 digits.  The next 3 rules assume we know the
;;; carry-out and parity of the other digit, instead.  The next one assumes we know all 3 digits and
;;; figures out both carries.
;;;

(defrule addition-1 (:forward)
  ;; carry-in + addend + augend  sum + 10*carry-out.
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-in ?n ?carry-in]
	  [value-of-letter-is ?addend ?addend-digit]
	  [value-of-letter-is ?augend ?augend-digit]]
  THEN (multiple-value-bind (carry-out sum-digit)
	   ;; since 0  sum  9, we can use mod-10 arithmetic to get both it and carry-out
	   (floor (+ ?carry-in ?addend-digit ?augend-digit) 10)
	 (if (and ( 0 carry-out 1) ( 0 sum-digit 9))
	     (tell `[and [value-of-letter-is ?sum ,sum-digit]
			 [carry-out ?n ,carry-out]])
	     (tell [ltms:contradiction]))))

(defrule addition-2 (:forward)
  ;; sum - carry-in - augend  addend - 10*carry-out
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-in ?n ?carry-in]
	  [value-of-letter-is ?sum ?sum-digit]
	  [value-of-letter-is ?augend ?augend-digit]]
  THEN (multiple-value-bind (minus-carry-out addend-digit)
	   ;; divide by 10 -- addend-digit goes away, and only carry-out is left
	   ;; minus-carry-out is -1 or 0.
	   (floor (- ?sum-digit ?carry-in ?augend-digit) 10)
	 (let ((carry-out (- minus-carry-out)))
	   (if (and ( 0 carry-out 1) ( 0 addend-digit 9))
	       (tell `[and [carry-out ?n ,carry-out]
			   [value-of-letter-is ?addend ,addend-digit]])
	       (tell [ltms:contradiction])))))

(defrule addition-3 (:forward)
  ;; sum - carry-in - addend  augend - 10*carry-out
  ;; just like addition-2, but with addend & augend swapped.
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-in ?n ?carry-in]
	  [value-of-letter-is ?sum ?sum-digit]
	  [value-of-letter-is ?addend ?addend-digit]]
  THEN (multiple-value-bind (minus-carry-out augend-digit)
	   ;; divide by 10 -- augend-digit goes away, and only carry-out is left
	   ;; minus-carry-out is -1 or 0.
	   (floor (- ?sum-digit ?carry-in ?addend-digit) 10)
	 (let ((carry-out (- minus-carry-out)))
	   (if (and ( 0 carry-out 1) ( 0 augend-digit 9))
	       (tell `[and [carry-out ?n ,carry-out]
			   [value-of-letter-is ?augend ,augend-digit]])
	       (tell [ltms:contradiction])))))

(defrule addition-4 (:forward)
  ;; addend + augend - 10*carry-out  sum - carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-out ?n ?carry-out]
	  [value-of-letter-is ?addend ?addend-digit]
	  [value-of-letter-is ?augend ?augend-digit]
	  [has-parity ?sum ?sum-parity]]
  THEN (let ((sum-digit (+ ?addend-digit ?augend-digit (* -10 ?carry-out))) ;sum - carry-in
	     (carry-in 0))
	 (unless (eq ?sum-parity (digit-parity sum-digit))
	   ;; parities disagree, so make up for it in the carry-in
	   (setq carry-in 1
		 sum-digit (1+ sum-digit)))
	 (if (and ( 0 carry-in 1) ( 0 sum-digit 9))
	     (tell `[and [carry-in ?n ,carry-in]
			 [value-of-letter-is ?sum ,sum-digit]])
	     (tell [ltms:contradiction]))))

(defrule addition-5 (:forward)
  ;; sum + 10*carry-out - addend  augend + carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-out ?n ?carry-out]
	  [value-of-letter-is ?sum ?sum-digit]
	  [value-of-letter-is ?addend ?addend-digit]
	  [has-parity ?augend ?augend-parity]]
  THEN (let ((augend-digit (+ ?sum-digit (* 10 ?carry-out) (- ?addend-digit))) ;augend + carry-in
	     (carry-in 0))
	 (unless (eq ?augend-parity (digit-parity augend-digit))
	   ;; parities disagree, so make up for it in the carry-in
	   (setq carry-in 1
		 augend-digit (1- augend-digit)))
	 (if (and ( 0 carry-in 1) ( 0 augend-digit 9))
	     (tell `[and [carry-in ?n ,carry-in]
			 [value-of-letter-is ?augend ,augend-digit]])
	     (tell [ltms:contradiction]))))

(defrule addition-6 (:forward)
  ;; sum + 10*carry-out - augend  addend + carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-out ?n ?carry-out]
	  [value-of-letter-is ?sum ?sum-digit]
	  [value-of-letter-is ?augend ?augend-digit]
	  [has-parity ?addend ?addend-parity]]
  THEN (let ((addend-digit (+ ?sum-digit (* 10 ?carry-out) (- ?augend-digit))) ;addend + carry-in
	     (carry-in 0))
	 (unless (eq ?addend-parity (digit-parity addend-digit))
	   ;; parities disagree, so make up for it in the carry-in
	   (setq carry-in 1
		 addend-digit (1- addend-digit)))
	 (if (and ( 0 carry-in 1) ( 0 addend-digit 9))
	     (tell `[and [carry-in ?n ,carry-in]
			 [value-of-letter-is ?addend ,addend-digit]])
	     (tell [ltms:contradiction]))))

(defrule addition-7 (:forward)
  ;; addend + augend - sum  10*carry-out - carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [value-of-letter-is ?addend ?addend-digit]
	  [value-of-letter-is ?augend ?augend-digit]
	  [value-of-letter-is ?sum    ?sum-digit]]
  THEN (multiple-value-bind (carry-out minus-carry-in)
	   (ceiling (+ ?addend-digit ?augend-digit (- ?sum-digit)) 10)
	 (let ((carry-in (- minus-carry-in)))
	   (if (and ( 0 carry-in 1)
		    ( 0 carry-out 1))
	       (tell `[and [carry-in ?n ,carry-in]
			   [carry-out ?n ,carry-out]])
	       (tell [ltms:contradiction])))))
3
0;;;
;;; Some rules that are able to deduce letter meanings.  These mostly capitalize on duplicated letters
;;; in a column.
;;;

(defrule identify-1 (:forward)
  ;; if addend = sum then determine augend from carry-in.
  ;; ci + x + y = x + 10*co
  ;; Thus:
  ;; ci=0  y=0 & co = 0
  ;; ci=1  y=9 & co = 1
  IF [and [column-sum-is ?n ?addend ?augend ?addend]
	  [carry-in ?n ?carry-in]]
  THEN [and `[carry-out ?n ?carry-in]
	    `[value-of-letter-is ?augend ,(if (= ?carry-in 0) 0 9)]])

(defrule identify-2 (:forward)
  ;; if augend = sum then determine addend from carry-in.
  ;; ci + x + y = x + 10*co
  ;; Thus:
  ;; ci=0  y=0 & co = 0
  ;; ci=1  y=9 & co = 1
  ;; just like identify-1, but with addend & augend swapped.
  IF [and [column-sum-is ?n ?addend ?augend ?augend]
	  [carry-in ?n ?carry-in]]
  THEN [and `[carry-out ?n ?carry-in]
	    `[value-of-letter-is ?addend ,(if (= ?carry-in 0) 0 9)]])

;;;
;;; The next 3 rules deal with the special case of addend = augend, i.e., C2in0 + A + A = S + 10*C2out0.
;;;

(defrule identify-4 (:forward)
  ;; 10 co + s = 2 a + ci, i.e., (s - ci)/2 = a - 5 co.
  IF [and [column-sum-is ?n ?addend ?addend ?sum]
	  [carry-in ?n ?carry-in]
	  [value-of-letter-is ?sum ?sum-digit]
	  ;; this condition has to be true for the calculation to make sense
	  (eql (digit-parity ?sum-digit) (digit-parity ?carry-in))]
  THEN (let* ((assuming-co-0 (floor (- ?sum-digit ?carry-in) 2))
	      (assuming-co-1 (+ assuming-co-0 5)))
	 ;; everything but these two values are precluded
	 (tell `[and ,@(loop for i below 10
			     unless (or (eql i assuming-co-0)
					(eql i assuming-co-1))
			       collect `[not [value-of-letter-is ?addend ,i]])])))

(defrule identify-5 (:forward)
  ;; 10 co + s = 2 a + ci.  Use one carry, sum, and arithmetic mod 2 to get a and other carry,
  ;; i.e., a is quotient mod 2 and ci is the remainder
  IF [and [column-sum-is ?n ?addend ?addend ?sum]
	  [carry-out ?n ?carry-out]
	  [value-of-letter-is ?sum ?sum-digit]]
  THEN (multiple-value-bind (addend-digit carry-in-digit)
	   (floor (+ (* 10 ?carry-out) ?sum-digit) 2)
	 (tell `[and [value-of-letter-is ?addend ,addend-digit]
		     [carry-in ?n ,carry-in-digit]])))

(defrule identify-6 (:forward)
  ;; 2 a - 10 co = s - ci
  IF [and [column-sum-is ?n ?addend ?addend ?sum]
	  [carry-out ?n ?carry-out]
	  [value-of-letter-is ?addend ?addend-digit]
	  [has-parity ?sum ?sum-parity]]
  THEN (let ((sum-digit (- (* 2 ?addend-digit) (* 10 ?carry-out)))
	     (carry-in 0))
	 (unless (eq ?sum-parity (digit-parity sum-digit))
	   (setq sum-digit (1+ sum-digit)
		 carry-in 1))
	 (tell `[and [value-of-letter-is ?sum ,sum-digit]
		     [carry-in ?n ,carry-in]])))

(defrule identify-7 (:forward)
  ;; if addend = sum and you know carry-out, you can get the augend
  ;; ci + addend + augend = addend + 10* co
  ;; know augend is 0 or 9 (see possibility-8 & possibility-9, below)
  ;; subtract addend from both sides: ci + augend = 10*co
  ;; co = 1  augend = 9 & ci =0
  ;; co = 0  augend = 0 & ci =0
  ;; like identify-1 & identify-2, but uses carry-out instead of carry-in
  IF [and [column-sum-is ?n ?addend ?augend ?addend]
	  [carry-out ?n ?carry-out]]
  THEN [and `[carry-in ?n ?carry-out]
	    `[value-of-letter-is ?augend ,(if (= ?carry-out 0) 0 9)]])

(defrule identify-8 (:forward)
  ;; if augend = sum and you know carry-out, you can get the addend
  ;; ci + augend + addend = augend + 10* co
  ;; know addend is 0 or 9 (see possibility-8 & possibility-9, below)
  ;; subtract augend from both sides: ci + addend = 10*co
  ;; co = 1  addend = 9 & ci =0
  ;; co = 0  addend = 0 & ci =0
  ;; like identify-1 & identify-2, but uses carry-out instead of carry-in
  ;; like identify-8, but with addend & augend swapped
  IF [and [column-sum-is ?n ?addend ?augend ?augend]
	  [carry-in ?n ?carry-in]]
  THEN [and `[carry-out ?n ?carry-in]
	    `[value-of-letter-is ?addend ,(if (= ?carry-in 0) 0 9)]])

(defrule identify-9 (:forward)
  ;; ci + addend + augend = sum, augend  {0, 9}, and addend  sum.
  ;; you can get augend from ci.  (choose it to avoid contradicting addend  sum.)
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  (not (char= ?addend ?sum))
	  [not [value-of-letter-is ?augend ?]]
	  [carry-in ?n ?carry-in] :support ?f2
	  ]
  THEN (let ((support-for-restriction (possible-values-for-letter-are-exactly ?augend '(0 9))))
	 (when support-for-restriction
	   (tell `[value-of-letter-is ?augend ,(if (= ?carry-in 0) 9 0)]
		 :justification `(identify-9 (,?f1 ,?f2) ,support-for-restriction)))))

(defrule identify-10 (:forward)
  ;; ci + addend + augend = sum, addend  {0, 9}, and augend  sum.
  ;; you can get addend from ci. (choose it to avoid contradicting augend  sum.)
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  (not (char= ?augend ?sum))
	  [not [value-of-letter-is ?addend ?]]
	  [carry-in ?n ?carry-in]]
  THEN (let ((support-for-restriction (possible-values-for-letter-are-exactly ?addend '(0 9))))
	 (when support-for-restriction
	   (tell `[value-of-letter-is ?addend ,(if (= ?carry-in 0) 9 0)]
		 :justification `(identify-9 (,?f1 ,?f2) ,support-for-restriction)))))

3
0;;;
;;; Some rules that suggest possibilities.
;;;

;;; This is done by tms constraints in the model
;(defrule possibility-1 (:forward)
;  ;; if you assign a value to a letter, then preclude that value for all other letters
;  ;; the call to intersect-possible-digits prevents this from exploring the entire subset lattice
;  IF [and [value-of-letter-is ?letter ?digit]
;	  [letter-is-in-problem ?other-letter] 
;	  (char ?letter ?other-letter)]
;  THEN [not [value-of-letter-is ?other-letter ?digit]])

(defrule possibility-3 (:forward)
  ;; suggest possibilities based on parity
  IF [has-parity ?letter even]
  THEN [and [not [value-of-letter-is ?letter 1]]
	    [not [value-of-letter-is ?letter 3]]
	    [not [value-of-letter-is ?letter 5]]
	    [not [value-of-letter-is ?letter 7]]
	    [not [value-of-letter-is ?letter 9]]])

(defrule possibility-4 (:forward)
  ;; suggest possibilities based on parity
  IF [has-parity ?letter odd]
  THEN [and [not [value-of-letter-is ?letter 2]]
	    [not [value-of-letter-is ?letter 4]]
	    [not [value-of-letter-is ?letter 6]]
	    [not [value-of-letter-is ?letter 8]]
	    [not [value-of-letter-is ?letter 0]]])

(defrule possibility-8 (:forward)
  ;; if addend = sum, augend is either 0 or 9 (depending on the carry in)
  ;; more general (but less focused) version of identify-1 & identify-3
  IF [column-sum-is ?n ?addend ?augend ?addend]
  THEN [and [not [value-of-letter-is ?augend 1]]
	    [not [value-of-letter-is ?augend 2]]
	    [not [value-of-letter-is ?augend 3]]
	    [not [value-of-letter-is ?augend 4]]
	    [not [value-of-letter-is ?augend 5]]
	    [not [value-of-letter-is ?augend 6]]
	    [not [value-of-letter-is ?augend 7]]
	    [not [value-of-letter-is ?augend 8]]])

(defrule possibility-9 (:forward)
  ;; if augend = sum, addend is either 0 or 9 (depending on the carry in)
  ;; more general (but less focused) version of identify-2 & identify-4
  ;; this is just like possibility-8, but with addend & augend swapped
  IF [column-sum-is ?n ?addend ?augend ?augend]
  THEN [and [not [value-of-letter-is ?addend 1]]
	    [not [value-of-letter-is ?addend 2]]
	    [not [value-of-letter-is ?addend 3]]
	    [not [value-of-letter-is ?addend 4]]
	    [not [value-of-letter-is ?addend 5]]
	    [not [value-of-letter-is ?addend 6]]
	    [not [value-of-letter-is ?addend 7]]
	    [not [value-of-letter-is ?addend 8]]])

;;;
;;; The next 3 rules note that if the carry-out is 0, we can place bounds, since we know addition
;;;  makes things bigger.
;;;

(defrule possibility-10 (:forward)
  ;; if the carry-out is 0, the sum  addend
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-out ?n 0]
	  [value-of-letter-is ?addend ?addend-digit]
	  ( ?addend-digit 0)]			;else this is no real restriction!
  THEN `[and ,@(loop for i below ?addend-digit
		     collect `[not [value-of-letter-is ?sum ,i]])])

(defrule possibility-11 (:forward)
  ;; if the carry-out is 0, the sum  augend
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-out ?n 0]
	  [value-of-letter-is ?augend ?augend-digit]
	  ( ?augend-digit 0)]			;else this is no real restriction!
  THEN `[and ,@(loop for i below ?augend-digit
		     collect `[not [value-of-letter-is ?sum ,i]])])

(defrule possibility-12 (:forward)
  ;; if the carry-out is 0, the sum is greater (or equal, if one is 0) than either of the addends
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [carry-out ?n 0]
	  [value-of-letter-is ?sum ?sum-digit]
	  ( ?sum-digit 9)]			;else this is no real restriction!
  THEN `[and ,@(loop for i from 9 above ?sum-digit
		     collect `[not [value-of-letter-is ?addend ,i]]
		     collect `[not [value-of-letter-is ?augend ,i]])])

(defrule possibility-13 (:forward)
  ;; since the leftmost carry-out must be 0, addend and augend must sum to  9 (8, if carry-in is 1)
  IF [and [leftmost-column-is ?n]
	  [column-sum-is ?n ?addend ?augend ?sum]
	  [value-of-letter-is ?addend ?addend-digit]
	  ( ?addend-digit 0)]			;else this is no real restriction!
  THEN `[and ,@(loop for i from (- 10 ?addend-digit) upto 9
		     collect `[not [value-of-letter-is ?augend ,i]])])

(defrule possibility-14 (:forward)
  ;; since the leftmost carry-out must be 0, addend and augend must sum to  9 (8, if carry-in is 1)
  IF [and [leftmost-column-is ?n]
	  [column-sum-is ?n ?addend ?augend ?sum]
	  [value-of-letter-is ?augend ?augend-digit]
	  ( ?augend-digit 0)] ;else this is no real restriction!
  THEN `[and ,@(loop for i from (- 10 ?augend-digit) upto 9
		     collect `[not [value-of-letter-is ?addend ,i]])])

(defrule possibility-15 (:forward)
  ;; for repeated addends, if carry-out is 0, restrict them to 4, else  5.
  IF [and [column-sum-is ?n ?addend ?addend ?sum]
	  [carry-out ?n ?carry-out]]
  THEN `[and ,@(if (= ?carry-out 0)
		   (loop for i from 5 below 10
			 collecting `[not [value-of-letter-is ?addend ,i]])
		   (loop for i below 5 
			 collecting `[not [value-of-letter-is ?addend ,i]]))])

(defrule possibility-16 (:forward)
  ;; addend + carry-in = sum + 10*carry-out - augend
  ;; this is like addition-6, except that it doesn't know the parity (and hence can't make positive id)
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [value-of-letter-is ?sum ?sum-digit]
	  [value-of-letter-is ?augend ?augend-digit]
	  [carry-out ?n ?carry-out]]
  THEN `[and ,@(let ((assuming-carry-in-0 (+ ?sum-digit (* 10 ?carry-out) (- ?augend-digit))))
		 (loop for i below 10
		       unless (or (eql i assuming-carry-in-0)
				  (eql i (1- assuming-carry-in-0)))
			 collect `[not [value-of-letter-is ?addend ,i]]))])

(defrule possibility-17 (:forward)
  ;; augend + carry-in = sum + 10*carry-out - addend
  ;; this is like addition-5,except that it doesn't know the parity (and hence can't make positive id)
  ;; this is like identify-10, but with addend & augend swapped
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [value-of-letter-is ?sum ?sum-digit]
	  [value-of-letter-is ?addend ?addend-digit]
	  [carry-out ?n ?carry-out]]
  THEN `[and ,@(let ((assuming-carry-in-0 (+ ?sum-digit (* 10 ?carry-out) (- ?addend-digit))))
		 (loop for i below 10
		       unless (or (eql i assuming-carry-in-0)
				  (eql i (1- assuming-carry-in-0)))
			 collect `[not [value-of-letter-is ?augend ,i]]))])

(defrule possibility-18 (:forward)
  ;; addend + augend - 10*carry-out = sum - carry-in
  ;; this is like addition-4, except that it doesn't know the parity (and hence can't make positive id)
  IF [and [column-sum-is ?n ?addend ?augend ?sum]
	  [value-of-letter-is ?addend ?addend-digit]
	  [value-of-letter-is ?augend ?augend-digit]
	  [carry-out ?n ?carry-out]]
  THEN `[and ,@(let ((assuming-carry-in-0 (+ ?addend-digit ?augend-digit (* -10 ?carry-out))))
		 (loop for i below 10
		       unless (or (eql i assuming-carry-in-0)
				  (eql i (1+ assuming-carry-in-0)))
			 collect `[not [value-of-letter-is ?sum ,i]]))])
3
0;;;
;;; The next 3 rules are "narrowing" rules.  Given that you know both carries and a digit in a column,
;;; use the implied constraint to make the possiblilities for both digits consistent with it. 
;;;

(defrule narrow-1a (:forward)
  ;; know both carries and the addend.  Make augend & sum possibilities consistent w/implied constraint
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [value-of-letter-is ?addend ?addend-digit] :support ?f4
	  ;; If we get a new precluded value for the sum
	  ;; then we try to whittle down the possibilities for the augend
	  [not [value-of-letter-is ?sum ?]]]
  Then (multiple-value-bind (possible-values-for-sum support-for-sum)
	   (possible-values-for-letter ?sum)
	 (loop for possible-augend-value in (possible-values-for-letter ?augend)
	       for implied-value-of-sum = (- (+ ?carry-in possible-augend-value ?addend-digit) (* 10 ?carry-out))
	       when (not (member implied-value-of-sum possible-values-for-sum))
		 do (tell `[not [value-of-letter-is ?augend ,possible-augend-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3 ,?f4) ,support-for-sum)))))

(defrule narrow-1b (:forward)
  ;; know both carries and the addend.  Make augend & sum possibilities consistent w/implied constraint
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [value-of-letter-is ?addend ?addend-digit] :support ?f4
	  ;; If we get a new precluded value for the augend
	  ;; then we try to whittle down the possibilities for the sum.
	  [not [value-of-letter-is ?augend ?]]]
  Then (multiple-value-bind (possible-values-for-augend support-for-augend)
	   (possible-values-for-letter ?augend)
	 (loop for possible-sum-value in (possible-values-for-letter ?sum)
	       for implied-value-of-augend = (- (+ possible-sum-value (* 10 ?carry-out)) ?carry-in ?addend-digit)
	       when (not (member implied-value-of-augend possible-values-for-augend))
		 do (tell `[not [value-of-letter-is ?sum ,possible-sum-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3 ,?f4) ,support-for-augend)))))

(defrule narrow-2a (:forward)
  ;; know both carries and the augend.  Make addend & sum possibilities consistent w/implied constraint
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [value-of-letter-is ?augend ?augend-digit] :support ?f4
	  [not [value-of-letter-is ?sum ?]]]
  THEN (multiple-value-bind (possible-values-for-sum support-for-sum)
	   (possible-values-for-letter ?sum)
	 (loop for possible-addend-value in (possible-values-for-letter ?addend)
	       for implied-value-of-sum = (- (+ possible-addend-value ?carry-in ?augend-digit) (* 10 ?carry-out))
	       when (not (member implied-value-of-sum  possible-values-for-sum))
		 do (tell `[not [value-of-letter-is ?addend ,possible-addend-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3 ,?f4) ,support-for-sum)))))

(defrule narrow-2b (:forward)
  ;; know both carries and the augend.  Make addend & sum possibilities consistent w/implied constraint
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [value-of-letter-is ?augend ?augend-digit] :support ?f4
	  [not [value-of-letter-is ?addend ?]]]
  THEN (multiple-value-bind (possible-values-for-addend support-for-addend)
	   (possible-values-for-letter ?addend)
	 (loop for possible-sum-value in (possible-values-for-letter ?sum)
	       for implied-value-of-addend = (- (+ possible-sum-value (* 10 ?carry-out)) ?carry-in ?augend-digit)
	       when (not (member implied-value-of-addend possible-values-for-addend))
		 do (tell `[not [value-of-letter-is ?sum ,possible-sum-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3 ,?f4) ,support-for-addend)))))

(defrule narrow-3a (:forward)
  ;; know both carries and sum.  Make addend & augend possibilities consistent w/implied constraint
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [value-of-letter-is ?sum ?sum-digit] :support ?f4
	  [not [value-of-letter-is ?addend ?]]]
  THEN (multiple-value-bind (possible-values-for-addend support-for-addend)
	   (possible-values-for-letter ?addend)
	 (loop for possible-augend-value in (possible-values-for-letter ?augend)
	       for implied-value-of-addend = (- (+ ?sum-digit (* 10 ?carry-out)) ?carry-in possible-augend-value)
	       when (not (member implied-value-of-addend possible-values-for-addend))
		 do (tell `[not [value-of-letter-is ?augend ,possible-augend-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3 ,?f4) ,support-for-addend)))))

(defrule narrow-3b (:forward)
  ;; know both carries and sum.  Make addend & augend possibilities consistent w/implied constraint
  IF [and [column-sum-is ?n ?addend ?augend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [value-of-letter-is ?sum ?sum-digit] :support ?f4
	  [not [value-of-letter-is ?augend ?]]]
  THEN (multiple-value-bind (possible-values-for-augend support-for-augend)
	   (possible-values-for-letter ?augend)
	 (loop for possible-addend-value in (possible-values-for-letter ?addend)
	       for implied-value-of-augend = (- (+ ?sum-digit (* 10 ?carry-out)) ?carry-in possible-addend-value)
	       when (not (member implied-value-of-augend possible-values-for-augend))
		 do (tell `[not [value-of-letter-is ?addend ,possible-addend-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3 ,?f4) ,support-for-augend)))))

;;; Narrowing in the presence of duplications.  Note that there are no analogs for this when
;;; addend = sum or augend = sum, since other rules above will catch those & assign 0 or 9 to the
;;; other digit.  Then regular narrowing works.

(defrule narrow-4a (:forward)
  ;; know both carries and addend = augend
  IF [and [column-sum-is ?n ?addend ?addend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [not [value-of-letter-is ?sum ?]]]
  THEN (multiple-value-bind (possible-values-for-sum support-for-sum)
	   (possible-values-for-letter ?sum)
	 (loop for possible-addend-value in (possible-values-for-letter ?addend)
	       for implied-value-of-sum = (- (+ (* 2 possible-addend-value) ?carry-in) (* 10 ?carry-out))
	       when (not (member implied-value-of-sum  possible-values-for-sum))
		 do (tell `[not [value-of-letter-is ?addend ,possible-addend-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3) ,support-for-sum)))))

(defrule narrow-4b (:forward)
  ;; know both carries and addend = augend
  IF [and [column-sum-is ?n ?addend ?addend ?sum] :support ?f1
	  [carry-in ?n ?carry-in] :support ?f2
	  [carry-out ?n ?carry-out] :support ?f3
	  [not [value-of-letter-is ?addend ?]]]
  THEN (multiple-value-bind (possible-values-for-addend support-for-addend)
	   (possible-values-for-letter ?addend)
	 (loop for possible-sum-value in (possible-values-for-letter ?sum)
	       for implied-value-of-addend = (floor (- (+ possible-sum-value (* 10 ?carry-out)) ?carry-in) 2)
	       when (not (member implied-value-of-addend  possible-values-for-addend))
		 do (tell `[not [value-of-letter-is ?sum ,possible-sum-value]]
			  :justification `(narrow-1 (,?f1 ,?f2 ,?f3) ,support-for-addend)))))

3

0;;;
;;; Program interface to all this.  The apparent nonsense with all the closures is so the window
;;; interface can pass in wrappers that update displays and so on.  If you don't supply those args,
;;; nothing interesting in the way of display will happen.
;;;

(defun solve-cryptarithmetic-problem (addend augend sum &optional clues
					     (initialize? t)
					     (backtrack-noticer #'ignore)
					     (choice-noticer #'ignore)
					     (lossage-fn #'false)
					     (display-after-initialize-fn #'ignore))
  ;; solve a cryptarithmetic problem, taking advantage of clues
  (declare (values addend-number augend-number sum-number)	;or NIL if it can't find a solution
	   (sys:downward-funarg lossage-fn))
  (setq addend (string-upcase addend)
	augend (string-upcase augend)
	sum (string-upcase sum))
  (let* ((letters-in-problem (letters-in addend augend sum))
	 (letter-structures-in-problem (loop for letter in letters-in-problem
					     collect (letter-structure-for-letter letter)))
	 (active-choices nil))
    (labels ((solved ()
	       (loop for structure in letter-structures-in-problem
		     always (letter-structure-current-value structure)))
	     (check-for-solution ()
	       ;; if we've got a solution, check it.  If valid, return
	       (when (solved)
		 ;; claims to have a solution
		 (flet ((compute-number (symbol)
			  ;; compute the number to which a symbol corresponds
			  (loop for letter being the array-elements of (string symbol)
				for power downfrom (1- (length (string symbol))) to 0
				summing (* (expt 10 power) (find-digit letter)))))
		   (let ((addend-number (compute-number addend))
			 (augend-number (compute-number augend))
			 (sum-number    (compute-number sum)))
		     (unless (= sum-number (+ addend-number augend-number))
		       (error "The (alleged) answer doesn't work: ~D + ~D  ~D!"
			      addend-number augend-number sum-number))
		     (return-from solve-cryptarithmetic-problem
		       (values addend-number augend-number sum-number))))))
	     (crypt-contradiction-handler (condition-object)
	       (let ((choices (loop with pred and mnemonic
				    for justification in (tms-contradiction-support condition-object)
				    do (multiple-value-setq (mnemonic pred) (destructure-justification justification))
				    when (eq mnemonic :choice)
				      collect (cons pred justification))))
		 (if choices
		     (loop for choice in active-choices
			   for pred = (first choice)
			   for (victim-pred . victim-just) = (assoc pred choices)
			   when victim-pred
			     do (condition-bind ((tms-contradiction #'crypt-contradiction-handler))
				  (setq active-choices (delete choice active-choices))
				  (funcall backtrack-noticer active-choices)
				  (remove-justification victim-just)
				  ;; note we handled it
				  (return (values t))))
		     (values nil))))
	     (add-fact-and-check (fact justification)
	       ;; add new fact to the database and see if that makes us win
	       (tell fact :justification justification)
	       (check-for-solution))
	     (try-search ()
	       (flet ((find-possibile-letters ()
			  (loop for letter-structure in letter-structures-in-problem
				unless (and (letter-structure-current-predication letter-structure)
					    (eql (predication-truth-value (letter-structure-current-predication letter-structure))
						 *true*))
				  collect letter-structure))
		      (rank (measure-1 secondary-measure-1 measure-2 secondary-measure-2)
			(or (or (null measure-2)
				(< measure-1 measure-2))
			    (and (= measure-1 measure-2)
				 (or (null secondary-measure-2)
				     (> secondary-measure-1 secondary-measure-2))))))
		 (loop for possibilities = (find-possibile-letters)
		       for victim = (loop with victim = nil and best-count = nil and best-secondary-count = nil
					  for ls in possibilities
					  for count = (letter-structure-number-of-possibilities-left ls)
					  for secondary-count = (letter-structure-number-of-occurances-in-problem ls)
					  when (rank count secondary-count best-count best-secondary-count)
					    do (setq best-count count
						     best-secondary-count secondary-count
						     victim ls)
					  finally (return victim))
		       while victim
			 do (loop with specific-victim
				  for pred being the array-elements of (letter-structure-vector victim)
				  for index from 0
				  when (eql (predication-truth-value pred) *unknown*)
				    if specific-victim
				      collect index into other-values
				  else do (setq specific-victim pred)
				  finally (push (cons specific-victim other-values) active-choices)
					  (funcall choice-noticer active-choices)
					  (justify specific-victim *true* :choice)
					  (return (values))))))
	     (try-clues ()
	       ;; if we were given some clues, add them with appropriate justifications.
	       (loop for (letter . digit) in clues
		     for clue-predication = `[value-of-letter-is ,letter ,digit]
		     doing (add-fact-and-check clue-predication 'clue)))
	     (lose ()
	       ;; what to do if there's no solution you can find
	       (funcall lossage-fn)))
      ;; First, clear the database.  Then state the problem and see if we already know the solution.
      ;; If not, add each of the clues we are given, and see if that does it.
      ;; If we're still losing, try heuristic search.
      ;; Still losing?  Commit hara-kiri quietly.
      (condition-bind ((tms-contradiction #'crypt-contradiction-handler))
	(when initialize?
	  (clear)
	  (create-cryptarithmetic-description addend augend sum display-after-initialize-fn))
	(try-clues)
	(try-search)
	(check-for-solution)
	(lose)))))



3
0;;;
;;; Basic presentation types and translators used by the cryptarithemtic user interface.
;;;

(defun read-char-with-spaces (stream embedded-char)
  ;; get stuff like "  + " and " =  "
  (flet ((flush-spaces ()
	   ;; flush spaces from the input stream
	   (loop while (dw:compare-char-for-accept (dw:peek-char-for-accept stream t) #\Space)
		 doing (dw:read-char-for-accept stream))))
    (flush-spaces)
    (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream) embedded-char)
      (sys:parse-error "Expected ~C" embedded-char))
    (flush-spaces)))

(defun parse-from-string-cp-kludge (original-type stream)
  ;; sometimes the CP wraps things with embedded spaces in ""'s.  Deal with that
  ;; by accepting the string and then reading from it.  (We know we'll be able to find
  ;; what we want in the string, since the CP did us the "favor" of taking what we want
  ;; and wrapping it up prettily and tying a bow around it.)
  (accept-from-string original-type
		      (accept 'string
			      :stream stream
			      :prompt nil
			      :original-type original-type)))

(define-presentation-type cryptarithmetic-problem (())
   ;; basically just a list of 3 symbols
   :description "a cryptarithmetic problem"
   :parser
   ((stream &key original-type default)
    ;; read a cryptarithmetic problem
    (let ((next-char (dw:peek-char-for-accept stream)))
      (cond ((and next-char (char= next-char #\"))
	     ;; stupid command-parser has wrapped "'s around the thing
	     (parse-from-string-cp-kludge original-type stream))
	    (t
	      ;; read it the real way
	      (let ((addend (accept 'symbol
				    :stream stream
				    :default (first default)
				    :original-type original-type
				    :prompt nil
				    :additional-blip-chars '(#\+ #\Space)))
		    (augend (progn (read-char-with-spaces stream #\+)
				   (accept 'symbol
					   :stream stream
					   :default (second default)
					   :original-type original-type
					   :prompt nil
					   :additional-blip-chars '(#\= #\Space))))
		    (sum (progn (read-char-with-spaces stream #\=)
				(accept 'symbol
					:default (third default)
					:original-type original-type
					:stream stream
					:prompt nil))))
		(list addend augend sum))))))
   :printer
   ((self stream &key original-type)
    ;; print a cryptarithmetic problem
    (dw:with-output-as-presentation (:stream stream
				     :object self
				     :type original-type)
      (destructuring-bind (addend augend sum) self
	(format stream "~A + ~A = ~A" addend augend sum)))))

(define-presentation-type cryptarithmetic-clue ((&rest letters))
   ;; basically a cons of a letter and a digit.  The letters get restricted.
   :description "a clue"
   :parser
   ((stream &key original-type)
    (let ((next-char (dw:peek-char-for-accept stream)))
      (cond ((and next-char (char= next-char #\"))
	     ;; stupid command-parser has wrapped "'s around it
	     (parse-from-string-cp-kludge original-type stream))
	    (t
	      ;; do it the real way
	      (let ((letter (accept `(member ,@letters)
				    :original-type original-type
				    :stream stream
				    :prompt nil
				    :additional-blip-chars '(#\= #\Space)))
		    (digit (progn (read-char-with-spaces stream #\=)
				  (accept '(member 0 1 2 3 4 5 6 7 8 9)
					  :original-type original-type
					  :stream stream
					  :prompt nil))))
		(cons letter digit))))))
   :printer
   ((self stream)
    ;; print a clue
    (dw:with-output-as-presentation (:stream stream
				     :object self
				     :type 'cryptarithmetic-clue)
      (format stream "~C = ~D" (car self) (cdr self)))))

(define-presentation-type cryptarithmetic-problem-with-clue (())
   ;; (name problem &rest clues)
   :description "a cryptarithmetic-problem with a clue"
   :parser
   ((stream)
    ;; make it so the only way to get one of these is to click on it
    (dw:read-char-for-accept stream)
    (sys:parse-ferror "You have to click to read a CRYPTARITHMETIC-PROBLEM-WITH-CLUE."))
   :printer 
   ((self stream &key original-type)
    ;; print just the cryptarithmetic problem
    (dw:with-output-as-presentation (:stream stream
				     :object self
				     :type original-type)
      (destructuring-bind (ignore (addend augend sum) &rest ignore) self
	(format stream "~A + ~A = ~A" addend augend sum)))))

(define-presentation-translator to-cryptarithmetic-problem
   ;; translate from cryptarithmetic-problem-with-clue to cryptarithmetic-problem
   (cryptarithmetic-problem-with-clue cryptarithmetic-problem)
   (with-clue)
  (second with-clue))

(define-presentation-translator to-cryptarithmetic-clues
   ;; translate from cryptarithmetic-problem-with-clue to cryptarithmetic-clue
   (cryptarithmetic-problem-with-clue ((sequence cryptarithmetic-clue))
				      ;; check that some clues are present
				      :tester ((with-clue) (cddr with-clue)))
   (with-clue)
  (cddr with-clue))

;;;
;;; Window system for the cryptarithmetic user interface.
;;;

(defvar *cryptarithmetic-states* '((:wait . "Awaiting a Problem")
				   (:clear . "Clearing the Database")
				   (:redisplay . "Redisplaying Some Panes")
				   (:relax . "Relaxing to a Consistent State")
				   (:clue . "Adding a Clue")
				   (:backtrack . "Backtracking From a Contradiction")
				   (:search . "Search for Remaining Possibilities")
				   (:check . "Checking an Alleged Solution")))

(defstruct (possibilies-header-display-cache)
  letter-piece
  current-value-piece
  parity-piece
  (vector (make-array 10)))

(dw:define-program-framework cryptarithmetic
  :pretty-name "Cryptarithmetic Solver"
  :inherit-from (jericho:joshua-demo-program)
  :command-definer t
  :command-table (:inherit-from '("Joshua-Demo-Program") :kbd-accelerator-p t)
  :top-level (dw:default-command-top-level :unknown-accelerator-is-command t)
  :state-variables ((current-problem nil '(or null cryptarithmetic-problem))
		    (addend "" string)
		    (augend "" string)
		    (sum "" string)
		    (letters-in-problem nil)
		    (guesses nil)
		    (number-of-guesses 0)
		    (number-of-backtracks 0)
		    (state :wait `((member ,@(mapcar #'car *cryptarithmetic-states*)))))
  :other-defflavor-options (:readable-instance-variables
			     (:default-init-plist :title-string "Cryptarithmetic Demo"))
  :panes ((LETTER-POSSIBILITIES :DISPLAY
				  :incremental-redisplay t
				  :redisplay-function 'redisplay-possibilities
				  :typeout-window t
				  :redisplay-function nil
				  :default-character-style '(:swiss :roman :normal)
				  :margin-components '((dw:margin-ragged-borders :thickness 1)
						       (dw:margin-white-borders :thickness 3)
						       (dw:margin-label :margin :top
									:centered-p t
									:style (:swiss :bold :small)
									:box :inside
									:string "Cryptarithmetic Problem Letter Assignments"
									)))
	  
	  (CRYPTARITHMETIC-SOLUTION :DISPLAY
				    :incremental-redisplay t
				    :redisplay-function 'redisplay-solution
				    :default-character-style '(:fix :roman :normal)
				    :margin-components '((dw:margin-ragged-borders :thickness 1)
							 (dw:margin-white-borders :thickness 3)
							 (dw:margin-label :margin :top
									  :centered-p t
									  :style (:swiss :bold :small)
									  :box :inside
									  :string "Cryptarithmetic Solver Status")))
	  (guesses :DISPLAY
		   :incremental-redisplay nil
		   :redisplay-function 'redisplay-guesses
		   :default-character-style '(:swiss :roman :normal)
		   :end-of-page-mode :scroll
		   :scroll-factor 1
		   :more-p nil
		   :margin-components '((dw:margin-ragged-borders :thickness 1)
					(dw:margin-white-borders :thickness 3)
					(dw:margin-scroll-bar :history-noun "Guesses")
					(dw:margin-label :margin :top
							 :centered-p t
							 :style (:swiss :bold :small)
							 :box :inside
							 :string "Guesses")))
	  (statistics :display
		      :incremental-redisplay t
		      :redisplay-function 'redisplay-statistics
		      :default-character-style '(:fix :roman :normal)
		      :margin-components '((dw:margin-ragged-borders :thickness 1)
							 (dw:margin-white-borders :thickness 3)
							 (dw:margin-label :margin :top
									  :centered-p t
									  :style (:swiss :bold :small)
									  :box :inside
									  :string "Search Statistics")))
	  (interactor :interactor
		      :margin-components '((dw:margin-ragged-borders :thickness 1)
					   (dw:margin-scroll-bar :history-noun "interaction"))
		      :default-character-style '(:swiss :roman :normal)
		      :height-in-lines 4)
	  (title :title
		 :margin-components '((dw:margin-white-borders :thickness 0))
		 :default-character-style '(:dutch :bold :large)
		 :redisplay-function #'jericho:redisplay-joshua-demo-program-title
		 :height-in-lines 1
		 :redisplay-after-commands nil)
	  (cryptarithmetic-problems :display
				    :incremental-redisplay t
				    :redisplay-function 'redisplay-cryptarithmetic-problems
				    :default-character-style '(:swiss :roman :small)
				    :margin-components '((dw:margin-ragged-borders :thickness 1)
							 (dw:margin-white-borders :thickness 3)
							 (dw:margin-scroll-bar :history-noun "problems")
							 (dw:margin-label :margin :top
									  ;;:background-gray ,tv:50%-gray
									  :centered-p t
									  :style (:swiss :bold :small)
									  :box :inside
									  :string
									  "Suggested Cryptarithmetic Problems")))
	  (cryptarithmetic-commands :command-menu
				    :center-p t
				    :menu-level :cryptarithmetic-commands
				    :default-character-style '(:swiss :roman :large)
				    :margin-components '((dw:margin-ragged-borders :thickness 1)
							 (dw:margin-white-borders :thickness 3)
							 (dw:margin-label :margin :top
									  ;;:background-gray ,tv:50%-gray
									  :centered-p t
									  :style (:swiss :bold :small)
									  :box :inside
									  :string
									  "Cryptarithmetic Solver Commands"))))
  :configurations
  '((cryptarithmetic
      (:LAYOUT
	(cryptarithmetic :column title rest interactor)
	(rest :ROW THE-LEFT-COLUMN THE-RIGHT-COLUMN)
	(THE-LEFT-COLUMN :COLUMN
			  LETTER-POSSIBILITIES
			  CRYPTARITHMETIC-SOLUTION)
	(THE-RIGHT-COLUMN :COLUMN
			  cryptarithmetic-problems
			  guesses
			  statistics
			  cryptarithmetic-commands))
      (:SIZES
	(cryptarithmetic (title 1 :lines) (interactor 4 :lines) :then (rest :even))
	(rest (THE-LEFT-COLUMN 0.5) (THE-RIGHT-COLUMN 0.5))
	(THE-LEFT-COLUMN (CRYPTARITHMETIC-SOLUTION 5 :lines CRYPTARITHMETIC-SOLUTION)
			 :then
			 (LETTER-POSSIBILITIES :even))
	(THE-RIGHT-COLUMN
	  (cryptarithmetic-commands :ask-window self
				    :size-for-pane cryptarithmetic-commands)
	  (guesses 5 :lines guesses)
	  (statistics 3 :lines)
	  :then
	  (cryptarithmetic-problems :even)
	  )))))

;;;
;;; Redisplay stuff for the cryptarithmetic frame.
;;;

(defmethod (redisplay-solution cryptarithmetic) (stream)
  ;; draw the cryptarithmetic problem, substituting known letters, and showing carries
  (dw:with-redisplayable-output (:stream stream
				 :unique-id 'column-state-table)
    (formatting-table (stream)
      ;; draw the cryptarithmetic problem, substituting known letters, and showing carries
      ;; interesting interaction of ask with formatting-cell -- formatting-cell snapshots
      ;; a logic variable, which then becomes unbound outside the ask, and formatting-cell
      ;; goes crazy.
      (dw:with-redisplayable-output (:stream stream
				     :unique-id 'row-labels
				     :cache-value t)
	(formatting-column (stream)
	  (with-character-style ('(nil :italic :smaller) stream)
	    (formatting-cell (stream) (princ "Carries:" stream))
	    (formatting-cell (stream) (princ "Addend:" stream))
	    (formatting-cell (stream) (princ "Augend:" stream))
	    (formatting-cell (stream) (princ "Sum:" stream)))))
      (flet ((letter-value (letter)
	       (if letter
		   ;; get the digit or return the letter, if none
		   (let ((structure (letter-structure-for-letter letter)))
		     (or (letter-structure-current-value structure) letter))
		   "?")))
	(loop for index from (- (string-length addend) 1) downto 0
	      for column-structure = (aref *column-table* index)
	      for carry  = (column-structure-carry-in column-structure)
	      for addend-letter = (column-structure-addend-letter column-structure)
	      for augend-letter = (column-structure-augend-letter column-structure)
	      for sum-letter    = (column-structure-sum-letter column-structure)
	      doing (dw:with-redisplayable-output (:stream stream
						   :unique-id column-structure)
		      (formatting-column (stream)
			(formatting-cell (stream)
			  ;; print the carry
			  (dw:with-redisplayable-output (:stream stream
							 :cache-value carry)
			    (princ (if carry carry "?") stream)))
			(formatting-cell (stream)
			  ;; print the addend
			  (let ((value (letter-value addend-letter)))
			    (dw:with-redisplayable-output (:stream stream
							   :cache-value value)
			      (princ value stream))))
			(formatting-cell (stream)
			  ;; print the augend
			  (let ((value (letter-value augend-letter)))
			    (dw:with-redisplayable-output (:stream stream
							   :cache-value value)
			      (with-underlining (stream)
				(princ value stream)))))
			(formatting-cell (stream)
			  ;; print the sum
			  (let ((value (letter-value sum-letter)))
			    (dw:with-redisplayable-output (:stream stream
							   :cache-value value)
			      (princ value stream)))))))))))

(defmethod (redisplay-possibilities cryptarithmetic) (stream)
  ;; print a table of however much of the solution we know so far
  (flet ((compute-parity (letter-structure)
	   (loop for pred being the array-elements
		     of (letter-structure-parity-vector letter-structure)
		 for answer in '("Even" "Odd")
		 when (and pred (eql (predication-truth-value pred) *true*))
		   return answer))
	 (compute-truth-value (letter-structure i)
	   (let* ((vector (letter-structure-vector letter-structure))
		  (pred (aref vector i)))
	     (when pred (predication-truth-value pred)))))
    (dw:with-redisplayable-output (:stream stream
				   :unique-id 'table
				   :cache-value (loop for letter in letters-in-problem
						      for letter-structure = (letter-structure-for-letter letter)
						      collect (letter-structure-tick letter-structure))
				   :cache-test #'equal)
      (formatting-table (stream)
	(formatting-column-headings (stream :underline-p t)
	  (dw:with-redisplayable-output (:unique-id 'letter-state-table-headings
					 :cache-value t
					 :stream stream)
	    (with-character-style ('(nil :italic :smaller) stream)
	      (formatting-cell (stream :align :center) (princ "Letter" stream))
	      (formatting-cell (stream :align :center) (princ "Parity" stream))
	      (formatting-cell (stream :align :center) (princ "Digit" stream))
	      (loop for i below 10
		    doing (formatting-cell (stream :align :right) (princ i stream))))))
	(loop for letter in letters-in-problem
	      for letter-structure = (letter-structure-for-letter letter)
	      for display-vector = (letter-structure-possibilities-display-piece-vector letter-structure)
	      doing (dw:with-redisplayable-output (:stream stream
						   :unique-id letter-structure
						   :cache-value (letter-structure-tick letter-structure))
		      (formatting-row (stream)
			(formatting-cell (stream)
			  (dw:redisplayable-format stream "~a" letter))
			;; format the parity cell
			(formatting-cell (stream)
			  (dw:with-redisplayable-output
			      (:stream stream
			       :unique-id 'parity
			       :piece-hook #'(lambda (piece)
					       (setf (letter-structure-parity-display-piece letter-structure) piece))
			       :cache-value (compute-parity letter-structure))
			    (dw:redisplayable-format stream "~a"
						     (let ((parity (compute-parity letter-structure)))
						       (if parity parity "?")))))
			;; format the current value cell
			(formatting-cell (stream)
			  (dw:with-redisplayable-output
			      (:stream stream
			       :unique-id 'current-value
			       :piece-hook #'(lambda (piece)
					       (setf (letter-structure-current-value-display-piece letter-structure) piece))
			       :cache-value (letter-structure-current-value letter-structure))
			    (dw:redisplayable-format stream "~a" (or (letter-structure-current-value letter-structure) "?"))))
			;; format each numeric cell
			(loop for i below 10
			      doing (formatting-cell (stream)
				      (dw:with-redisplayable-output
					  (:stream stream
					   :unique-id i
					   :piece-hook #'(lambda (piece)
							   (setf (aref display-vector i) piece))
					   :cache-value (compute-truth-value letter-structure i))
					(dw:redisplayable-format stream "~a"
								 (let ((truth-value (compute-truth-value letter-structure i)))
								   (if (eql truth-value *false*) " " i)))))))))))))

(defvar *suggested-cryptarithmetic-problems* nil)
(defmethod (redisplay-cryptarithmetic-problems cryptarithmetic) (stream)
  ;; redisplay the suggested cryptarithmetic problems
  (declare (special *suggested-cryptarithmetic-problems*))
  (dw:with-redisplayable-output (:stream stream
				 :unique-id 'the-problems
				 :cache-test #'equal
				 :cache-value *suggested-cryptarithmetic-problems*)
    (mapcar #'(lambda (problem)
		(terpri stream)
		(present problem 'cryptarithmetic-problem-with-clue
				   :stream stream
				   :allow-sensitive-inferiors nil))
	    *suggested-cryptarithmetic-problems*)))

(defmethod (redisplay-guesses cryptarithmetic) (stream)
  (send stream :clear-history)
  (loop for (guess . other-possibilities) in (reverse guesses)
	do (with-statement-destructured (letter value) guess
	     (format stream "~%~a = ~d" letter value)
	     (when other-possibilities
	       (write-string " other possibilites: " stream))
	     (format-textual-list other-possibilities #'princ :stream stream :conjunction "and")
	     )))

(defmethod (redisplay-statistics cryptarithmetic) (stream)
  (formatting-table (stream)
    (formatting-row (stream)
      (formatting-cell (stream)
	(dw:redisplayable-format stream "Backtracks:"))
      (formatting-cell (stream)
	(dw:redisplayable-format stream "~d" number-of-backtracks)))
    (formatting-row (stream)
      (formatting-cell (stream)
	(dw:redisplayable-format stream "Guesses:"))
      (formatting-cell (stream)
	(dw:redisplayable-format stream "~d" number-of-guesses)))))
  





(def-defining-form define-cryptarithmetic-problem
   :definer
   ((name addend augend sum &rest clues)
    ;; define a cryptarithmetic problem and put it where the redisplayer will find it
    ;; First element is the problem name, second is the problem, rest is the clues
    `(progn (record-source-file-name ',name 'define-cryptarithmetic-problem)
	    (let ((old-one (assoc ',name *suggested-cryptarithmetic-problems*)))
	      (if old-one
		  (rplacd old-one `((,',(string-upcase addend) ,',(string-upcase augend) ,',(string-upcase sum)) ,@',clues))
		  (push `(,',name (,',(string-upcase addend) ,',(string-upcase augend) ,',(string-upcase sum)) ,@',clues)
			*suggested-cryptarithmetic-problems*)))
	    ',name))
   :killer
   ((name)
    ;; kill a suggested problem
    (setq *suggested-cryptarithmetic-problems*
	  (delete name *suggested-cryptarithmetic-problems* :key #'car))
    name)
   :shower
   ((form)
    (let ((found (assoc (second form) *suggested-cryptarithmetic-problems*)))
      (if found
	  (zwei:typein-line "~&Evaluating this would redefine the Cryptarithmetic Problem ~A + ~A = ~A."
			    (second found) (third found) (fourth found))
	  (zwei:typein-line "~&Evaluating this would define the Cryptarithmetic Problem ~A + ~A = ~A."
			    (third form) (fourth form) (fifth form))))
    t)
   :type-name "Cryptarithmetic Problem")


;;;
;;; Suggested cryptarithmetic problems.  The solutions in the comments are just possible solutions,
;;;  not an exhaustive list.  Most of these have multiple solutions due to symmetries.
;;;

(define-cryptarithmetic-problem problem-1 donald gerald robert (#\D . 5)) ;526485 + 197485 = 723970
(define-cryptarithmetic-problem problem-2 crime trial thief (#\T . 2)) ; 03964 + 23981 = 27945
(define-cryptarithmetic-problem problem-3 potato tomato vegies) ;561416 + 169416 = 730832
(define-cryptarithmetic-problem problem-4 might right money) ;94176 + 04176 = 98352
(define-cryptarithmetic-problem problem-5 funny clown shows) ;16995 + 30284 = 47284
(define-cryptarithmetic-problem problem-6 fever chill sleep) ;13238 + 46099 = 59337
(define-cryptarithmetic-problem problem-7 shovel trowel worker) ;173098 + 263498 = 436596
(define-cryptarithmetic-problem problem-8 travel native savage) ;398140 + 283714 = 681854
;(define-cryptarithmetic-problem problem-9 river water ships) 
(define-cryptarithmetic-problem problem-10 longer larger middle) ;179205 + 185205 = 364410


;;;
;;; Commands for the cryptarithmetic demo.
;;;


(zwei:defindentation (with-cryptarithmetic-state 0 7 1 1)) 
(defmacro-in-flavor (with-cryptarithmetic-state cryptarithmetic) ((state) &body body)
  ;; execute body with the state iv bound
  `(multiple-value-prog1 (letf ((state ,state))
			   ;; redisplay the status pane
			   (jericho:redisplay-pane self 'cryptarithmetic-status)
			   ,@body)
			 (jericho:redisplay-pane self 'cryptarithmetic-status)))

(defun-in-flavor (set-state cryptarithmetic) (new-problem)
  ;; set the state to a new problem
  (clear)
  (setq current-problem new-problem
	addend (or (first current-problem) "")
	augend (or (second current-problem) "")
	sum (or (third current-problem) "")
	letters-in-problem (letters-in addend augend sum)
	guesses nil
	number-of-backtracks 0
	number-of-guesses 0))

(define-cryptarithmetic-command (com-clear-problem :menu-accelerator t :menu-level :cryptarithmetic-commands) ()
   ;; flush all the data cached in iv's and clear the database
   (set-state nil)
   (send (dw:get-program-pane 'guesses) :clear-history)
   (jericho:redisplay-pane self 'letter-possibilities)
   (jericho:redisplay-pane self 'cryptarithmetic-solution))

(define-cryptarithmetic-command (com-solve-problem :menu-accelerator t :menu-level :cryptarithmetic-commands)
    ((problem 'cryptarithmetic-problem
	      :prompt "problem"
	      :documentation "Cryptarithmetic problem to solve")
     (clues `(dw:token-or-type (("None" . nil))
			       ((sequence
				  (cryptarithmetic-clue
				    ,@(letters-in (first problem) (second problem) (third problem))))))
	    :default nil
	    :prompt "clues"
	    :documentation "Breaks to give the solver")
     (do-search 'boolean
		:default t
		:prompt "search"
		:documentation
		"whether to go into search mode if necessary"))
   (ignore do-search)
   (set-state problem)
   (jericho:redisplay-pane self 'statistics)
   (jericho:redisplay-pane self 'guesses)
   (jericho:redisplay-pane self 'cryptarithmetic-solution)
   (jericho:redisplay-pane self 'letter-possibilities)
   (destructuring-bind (ad au s) problem
     ;; give about 17 million closures that do redisplay
     (setq letters-in-problem (letters-in ad au s))
     (let ((*possibilities-update-screen* (dw:get-program-pane 'LETTER-POSSIBILITIES))
	   (*solution-update-screen* (dw:get-program-pane 'CRYPTARITHMETIC-SOLUTION)))
       (solve-cryptarithmetic-problem ad au s clues
				      t
				    #'(lambda (active-choices)
					(incf number-of-backtracks)
					(jericho:redisplay-pane self (dw:get-program-pane 'statistics))
					(setq guesses active-choices)
					(redisplay-guesses self (dw:get-program-pane 'guesses)))
				    #'(lambda (active-choices)
					(incf number-of-guesses)
					(setq guesses active-choices)
					(jericho:redisplay-pane self (dw:get-program-pane 'statistics))
					(redisplay-guesses self (dw:get-program-pane 'guesses)))
				    #'(lambda ()
					;; what to do when you lose
					(format (dw:get-program-pane 'interactor)
						"~&I can't find a solution.  Sorry.")
					(values))
				    #'(lambda ()
					;; What to do after the solver
					;; gets things initialized in
					;; order to clean the screen up.
					(jericho:redisplay-pane self 'letter-possibilities)
					(jericho:redisplay-pane self 'cryptarithmetic-solution))))))


;;;
;;; Translators that go from cryptarithmetic-problem-with-clue to commands.
;;; Left means use clues, middle means don't.
;;; No shift means do search, shift means don't.
;;;

(define-presentation-to-command-translator solve-problem-with-clues-and-search-translator
   ;; :Solve Problem, using the clues and then search
   (cryptarithmetic-problem-with-clue
     :tester ((ignore)
	      ;; this is a kludge, but whaddaya gonna do?
	      (and (boundp 'dw:*program*)
		   (typep dw:*program* 'cryptarithmetic)))
     :gesture :left)
   (crypt-prob)
  (destructuring-bind (problem-name problem &rest clues) crypt-prob
    (ignore problem-name)
    (values `(com-solve-problem ,problem ,clues t)
	    'cp:command
	    :activate t)))

(define-presentation-to-command-translator solve-problem-without-clues-with-search-translator
   ;; :Solve Problem, ignoring the clues but doing search
   (cryptarithmetic-problem-with-clue
     :tester ((ignore)
	      ;; this is a kludge, but whaddaya gonna do?
	      (and (boundp 'dw:*program*)
		   (typep dw:*program* 'cryptarithmetic)))
     :gesture :middle)
   (crypt-prob)
  (destructuring-bind (problem-name problem &rest clues) crypt-prob
    (ignore problem-name clues)
    (values `(com-solve-problem ,problem nil t)
	    'cp:command
	    :activate t)))

(define-presentation-to-command-translator solve-problem-with-clues-without-search-translator
   ;; :Solve Problem, using clues but no search
   (cryptarithmetic-problem-with-clue
     :tester ((ignore)
	      ;; this is a kludge, but whaddaya gonna do?
	      (and (boundp 'dw:*program*)
		   (typep dw:*program* 'cryptarithmetic)))
     :gesture :shift-left)
   (crypt-prob)
  (destructuring-bind (problem-name problem &rest clues) crypt-prob
    (ignore problem-name)
    (values `(com-solve-problem ,problem ,clues nil)
	    'cp:command
	    :activate t)))

(define-presentation-to-command-translator solve-problem-without-clues-or-search-translator
   ;; :Solve Problem, using neither clues nor search
   (cryptarithmetic-problem-with-clue
     :tester ((ignore)
	      ;; this is a kludge, but whaddaya gonna do?
	      (and (boundp 'dw:*program*)
		   (typep dw:*program* 'cryptarithmetic)))
     :gesture :shift-middle)
   (crypt-prob)
  (destructuring-bind (problem-name problem &rest clues) crypt-prob
    (ignore problem-name clues)
    (values `(com-solve-problem ,problem nil nil)
	    'cp:command
	    :activate t)))

(define-presentation-to-command-translator solve-problem-translator
   ;; might as well be able to click on the statistics pane, too.  That one's just
   ;; an ordinary cryptarithmetic-problem.
   (cryptarithmetic-problem
     :tester ((ignore)
	      ;; this is a kludge, but whaddaya gonna do?
	      (and (boundp 'dw:*program*)
		   (typep dw:*program* 'cryptarithmetic)))
     :gesture :left)
   (crypt-prob)
  (values `(com-solve-problem ,crypt-prob nil t)
	  'cp:command
	  :activate t))

