;;; -*- Mode: Joshua; Package: Modelling-Tutor; Syntax: Joshua -*-
;;;> EXAMPLES-MESSAGE
;;;>
;;;>******************************************************************************************
;;;>
;;;>       Symbolics hereby grants permission to customer to incorporate
;;;>       the examples in this file in any work belonging to customer.
;;;>
;;;>******************************************************************************************
;;; Created 2/09/88 13:54:31 by sgr running on GROUSE at SCRC.

;;;
;;; An example of defining several different kinds of models (data, forward trigger, and 
;;;  backward trigger), and then combining them into one predicate.
;;;
;;; The example is [good-to-eat <food>], a statement about what's good to eat.
;;;

;;;
;;; First, a data model that deals with TMS issues.
;;;

(defvar *known-foods* nil "What's on the menu.")

(define-predicate-model good-to-eat-data-model () ()
  (:required-instance-variables food))

(define-predicate-method (insert good-to-eat-data-model) ()
  ;; tell something about food.
  (when (sys:unbound-logic-variable-p food)
    (error "You can't possibly mean that everything is good to eat: ~S" self))
  (let ((cell (assoc food *known-foods*)))
    (if cell
        ;; this thing is already known to be good to eat.
        (values (cdr cell) nil)
        ;; this is a new one, put it on the list
        (let ((database-predication (copy-object-if-necessary self)))
	  (push (cons food database-predication) *known-foods*)
	  (values database-predication t)))))

(define-predicate-method (uninsert good-to-eat-data-model) ()
  ;;remove food name from a special variable	
  (when (sys:unbound-logic-variable-p food)
    (error "You can't possibly mean that nothing is good to eat: ~S" self))
  (setq *known-foods* (delete food *known-foods* :key #'car)))

(define-predicate-method (fetch good-to-eat-data-model) (continuation)
  ;; retrieve some data about known foods
  (if (sys:unbound-logic-variable-p food)
      ;; wants to succeed once for each possible food
      (loop for (nil . predication) in *known-foods*
	    ;; the unification will be done by ASK-DATA
	    doing (funcall continuation predication))
      ;; wants to know if something in particular is good to eat
      (let ((cell (assoc food *known-foods*)))
	(when cell
	  (funcall continuation (cdr cell))))))

(define-predicate-method (clear good-to-eat-data-model) (clear-database ignore)
  ;; flush all the data about known foods
  (when clear-database
    (setq *known-foods* nil)))

(define-predicate-method (act-on-truth-value-change good-to-eat-data-model) (old-truth-value)
  ;; update the value of *known-foods* if this changes to or from *true*.
  (cond ((and (= old-truth-value *true*)
	      ( (predication-truth-value self) *true*))
	 ;; this used to be true, but isn't anymore, so it must be
	 ;; removed from *known-foods*
	 (setq *known-foods* (delete food *known-foods* :key #'car)))
	((and ( old-truth-value *true*)
	      (= (predication-truth-value self) *true*))
	 ;; this used to be not true, but it is now, so it must be
	 ;; added to *known-foods*
	 ;; use pushnew to avoid doubling the data in TELL
	 ;; (change it to push) 
	 (pushnew (cons food self) *known-foods* :key #'car))))

(compile-flavor-methods good-to-eat-data-model)D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 0;leaving this out causes obscure lossage
1
0;;;
;;; Now a model for backward triggers on good-to-eat.
;;;

(defvar *good-to-eat-backward-constant-triggers* (make-hash-table :size 10))
(defvar *good-to-eat-backward-variable-triggers* nil)

(define-predicate-model good-to-eat-backward-trigger-model () ()
  (:required-instance-variables food))

(define-predicate-method (locate-backward-rule-trigger good-to-eat-backward-trigger-model)
			 (truth-value continuation ignore ignore)
  (ignore truth-value)
  ;; call continuation on list of triggers for backward rules that solve good-to-eat goals
  (if (sys:unbound-logic-variable-p food)
      ;; the argument is an unbound logic variable
      (multiple-value-bind (new-triggers triggers-changed-p)
	  (funcall continuation *good-to-eat-backward-variable-triggers*)
	(when triggers-changed-p
	  (setq *good-to-eat-backward-variable-triggers* new-triggers)))
      ;; the argument is a constant
      (let ((list-of-triggers (gethash food *good-to-eat-backward-constant-triggers*)))
	(multiple-value-bind (new-triggers triggers-changed-p) (funcall continuation list-of-triggers)
	  (when triggers-changed-p
	    (if (null new-triggers)
		;; if they're all undefined, nuke this entry
		(remhash food *good-to-eat-backward-constant-triggers*)
		(setf (gethash food *good-to-eat-backward-constant-triggers*) new-triggers)))))))

(define-predicate-method (map-over-backward-rule-triggers good-to-eat-backward-trigger-model) (continuation)
  ;; map continuation over triggers of backward rules that solve good-to-eat goals
  ;; first do all variable triggers
  (mapc continuation *good-to-eat-backward-variable-triggers*)
  (if (sys:unbound-logic-variable-p food)
      ;; food is unbound, so have to map over all remaining triggers
      (maphash #'(lambda (key value)
		   (ignore key)
		   (mapc continuation value))
	       *good-to-eat-backward-constant-triggers*)
      ;; food is bound, so map over just those triggers that will match
      (mapc continuation (gethash food *good-to-eat-backward-constant-triggers*))))

;;; Inherit the symbol-skipping behavior of POSITIONS-BACKWARD-MATCHER-CAN-SKIP from
;;; DEFAULT-RULE-COMPILATION-MODEL.

(compile-flavor-methods good-to-eat-backward-trigger-model)
1
0;;;
;;; Now a model for forward triggers on good-to-eat.  Note this is a dynamic trigger model.
;;;

;;; Given that HES haired up the contract of the locate-*-trigger methods, I claim that add-*-triger
;;;   and delete-*-trigger no longer need to be generic.  In fact, they no longer need to be documented.
;;;   If we (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")do0 keep them generic, we must at a minimum also document add-forward-rule-trigger,
;;;   rete-network-match-predication, add-backward-rule-trigger, delete-forward-rule-trigger, and
;;;   delete-backward-rule-trigger.  (They're all called from the default implementation.)

(defgeneric initial-good-to-eat-trigger-function (predication map-p continuation))

(define-predicate-model good-to-eat-forward-trigger-model () ()
  (:required-instance-variables food))

(defmethod (predication-indexer good-to-eat-forward-trigger-model) ()
  ;; return the thing on which we're going to index
  food)

;;; Use of ugly internals here -- have to extract predication from trigger object.
(defun-in-flavor (classify-trigger good-to-eat-forward-trigger-model) (trigger)
  ;; tell whether the arg is a symbol or not.  Used in the rule indexer.  
  ;; only need to look at the first match id, since they're all variants.
  (predication-indexer (ji::match-id-pattern (car (ji::rete-match-node-match-ids trigger)))))

(defun-in-flavor (compile-good-to-eat-trigger-function good-to-eat-forward-trigger-model)
		 (triggers)
  ;; generate new trigger function for good-to-eat
  (declare (special *good-to-eat-trigger-function*))
  (loop with symbol-triggers-table = (make-hash-table :test 'eq :size 5)
	for trigger in triggers
	for trigger-indexer = (classify-trigger trigger)
	if (symbolp trigger-indexer)
	  ;; hash table keyed on arg.  value is list of triggers with that arg.
	  ;; the list of symbol triggers is for when you re-index, below.
	  do (push trigger (gethash trigger-indexer symbol-triggers-table))
	  and collect trigger into symbol-triggers
	else
	  ;; variable triggers get their own place
	  collect trigger into variable-triggers
	finally
	  ;; return a compiled closure that looks at variable-triggers and symbol-triggers-table.
	  (return
	    #'(lambda (predication map-p continuation)
		;; this is the new trigger-indexing function
		(let ((indexer (predication-indexer predication)))
		  (cond (map-p
			  ;; we're mapping over triggers.  First do variables, since the match anything
			  (mapc continuation variable-triggers)
			  (cond ((symbolp indexer)
				 ;; pattern is a symbol, so just get the ones that match.
				 (mapc continuation (gethash indexer symbol-triggers-table)))
				(t
				  ;; pattern is a variable, so take all the symbols, too.
				  (maphash #'(lambda (ignore value) (mapc continuation value))
					  symbol-triggers-table))))
			((symbolp indexer)
			 ;; we're locating places to store symbol triggers
			 (multiple-value-bind (new-symbol-triggers triggers-changed-p canonical-trigger)
			     (funcall continuation (gethash indexer symbol-triggers-table))
			   (when triggers-changed-p
			     ;; he changed the symbol triggers, so we gotta re-index.
			     (setq *good-to-eat-trigger-function*
				   (compile-good-to-eat-trigger-function
				     (append new-symbol-triggers variable-triggers))))
			   canonical-trigger))
			(t
			  ;; we're locating places to store variable triggers
			  (multiple-value-bind (new-variable-triggers triggers-changed-p canonical-trigger)
			      (funcall continuation variable-triggers)
			    (when triggers-changed-p
			      ;; he changed the variable triggers, so we gotta re-index.
			      (setq *good-to-eat-trigger-function*
				    (compile-good-to-eat-trigger-function
				      (append symbol-triggers new-variable-triggers))))
			    canonical-trigger))))))))

(defmethod (initial-good-to-eat-trigger-function good-to-eat-forward-trigger-model)
	   (map-p continuation)
  (declare (special *good-to-eat-trigger-function*))
  (unless map-p
    ;; Only has to handle the locate case, since there are as yet no triggers over which one can map.
    (multiple-value-bind (new-triggers triggers-changed-p canonical-trigger)
	(funcall continuation nil) ;none yet
      (when triggers-changed-p
	;; the continuation created some triggers, so recompile the function.
	(setq *good-to-eat-trigger-function* (compile-good-to-eat-trigger-function new-triggers)))
      canonical-trigger)))

(defvar *good-to-eat-trigger-function* #'initial-good-to-eat-trigger-function
  "Will take 3 args: predication, locate/map switch, and continuation.")

;;; "Show me the place you would store a rule trigger that looks like this."
(define-predicate-method (locate-forward-rule-trigger good-to-eat-forward-trigger-model)
			 (truth-value continuation ignore ignore)
  ;; how to locate places to put good-to-eat triggers
  (declare (special *good-to-eat-trigger-function*))
  (ignore truth-value) ;;do we need to store the truth value as well - JMH?
  (funcall *good-to-eat-trigger-function* self nil continuation))

(define-predicate-method (map-over-forward-rule-triggers good-to-eat-forward-trigger-model) (continuation)
  ;; how to map over good-to-eat triggers
  (declare (special *good-to-eat-trigger-function*))
  (funcall *good-to-eat-trigger-function* self t continuation))

;;; Inherit the symbol-skipping behavior of POSITIONS-FORWARD-MATCHER-CAN-SKIP from
;;; DEFAULT-RULE-COMPILATION-MODEL.

(compile-flavor-methods good-to-eat-forward-trigger-model)

;;;
;;; Now the predicate itself.  Note how it mixes several models on top of the standard model.
;;;

(define-predicate good-to-eat (food) (good-to-eat-forward-trigger-model
				       good-to-eat-backward-trigger-model
				       good-to-eat-data-model
				       ltms:ltms-mixin
				       default-predicate-model)
  :destructure-into-instance-variables)

(define-predicate-method (say good-to-eat) (&optional (stream *standard-output*))
  ;; how to talk about good-to-eat predications
  (format stream "~&~S is good to eat." food))

(define-predicate tasty (food)) ;to make the example less boring

;;;
;;; An interactive Jericho version of this.
;;;

(dw:define-program-framework modelling-tutor
  :pretty-name "Modelling Tutor"
  :inherit-from (jericho:joshua-demo-program)
  :command-definer t
  :command-table (:inherit-from '("Joshua-Demo-Program") :kbd-accelerator-p t)
  :top-level (dw:default-command-top-level :unknown-accelerator-is-command t)
  :state-variables ((uninteresting-panes nil)) ;alist of panes and grays
  :other-defflavor-options (:readable-instance-variables
			     (:default-init-plist :title-string "Protocol of Inference Tutor"))
  :panes ((interactor :interactor
		      :margin-components '((dw:margin-ragged-borders :thickness 1)
					   (dw:margin-scroll-bar :history-noun "interaction"))
		      :default-character-style '(:swiss :roman :normal)
		      :height-in-lines 4)
	  (title :title
		 :margin-components '((dw:margin-white-borders :thickness 0))
		 :default-character-style '(:dutch :bold :large)
		 :redisplay-function #'jericho:redisplay-joshua-demo-program-title
		 :height-in-lines 1
		 :redisplay-after-commands nil)
	  (DB-DISPLAY
	    :DISPLAY
	    :redisplay-function 'redisplay-display-pane
	    :REDISPLAY-AFTER-COMMANDS T
	    :default-character-style '(:swiss :roman :normal)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-scroll-bar :history-noun "database")
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string "Database Contents (from ASK)")))
	  (DB-MODEL
	    :DISPLAY
	    :redisplay-function 'redisplay-display-pane
	    :REDISPLAY-AFTER-COMMANDS T
	    :default-character-style '(:swiss :roman :normal)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-scroll-bar :history-noun "database model")
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string "Database Model (*KNOWN-FOODS*)")))
	  (LISP-DISPLAY
	    :DISPLAY
	    :redisplay-function 'redisplay-display-pane
	    :AUTOMATICALLY-REMOVE-TYPEOUT-WINDOW T
	    :TYPEOUT-WINDOW T
	    :default-character-style '(:swiss :roman :normal)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-scroll-bar :history-noun "lisp session")
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string "Lisp Session")))
	  (MODELLING-TUTOR-COMMAND-MENU
	    :COMMAND-MENU
	    :CENTER-P T
	    :MENU-LEVEL :MODELLING-TUTOR-COMMAND-MENU
	    :default-character-style '(:swiss :roman :large)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-white-borders :thickness 3)
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string "Modelling Tutor Commands")))
	  (FWD-TRIGGER-DISPLAY
	    :DISPLAY
	    :redisplay-function 'redisplay-display-pane
	    :REDISPLAY-AFTER-COMMANDS T
	    :default-character-style '(:swiss :roman :normal)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-scroll-bar :history-noun "trigger display")
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string
						  "Forward Trigger (*GOOD-TO-EAT-TRIGGER-FUNCTION*)")))
	  (BCKWD-VAR-TRIGGER-DISPLAY
	    :DISPLAY
	    :redisplay-function 'redisplay-display-pane
	    :REDISPLAY-AFTER-COMMANDS T
	    :default-character-style '(:swiss :roman :normal)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-scroll-bar :history-noun "trigger display")
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string "Backward Variable Triggers (*GOOD-TO-EAT-VARIABLE-TRIGGERS*)")))
	  (BCKWD-CONST-TRIGGER-DISPLAY
	    :DISPLAY
	    :redisplay-function 'redisplay-display-pane
	    :REDISPLAY-AFTER-COMMANDS T
	    :default-character-style '(:swiss :roman :normal)
	    :more-p nil
	    :margin-components '((dw:margin-ragged-borders :thickness 1)
				 (dw:margin-scroll-bar :history-noun "trigger display")
				 (dw:margin-label :margin :top
						  ;;:background-gray ,tv:50%-gray
						  :centered-p t
						  :style (:swiss :bold :small)
						  :box :inside
						  :string "Backward Constant Triggers (*GOOD-TO-EAT-CONSTANT-TRIGGERS*)"))))
  :configurations
  '((modelling-tutor
     (:LAYOUT
       (modelling-tutor :column title rest interactor)
       (rest :ROW DATABASE-AND-LISP-PANES DEMO-MENU-AND-TRIGGER-DISPLAYS)
       (DATABASE-AND-LISP-PANES
	 :COLUMN
	  DATABASE-PANES
	  LISP-DISPLAY
	  MODELLING-TUTOR-COMMAND-MENU)
       (DATABASE-PANES :ROW DB-DISPLAY DB-MODEL)
       (DEMO-MENU-AND-TRIGGER-DISPLAYS
	 :COLUMN
	  FWD-TRIGGER-DISPLAY
	  BCKWD-VAR-TRIGGER-DISPLAY
	  BCKWD-CONST-TRIGGER-DISPLAY))
     (:SIZES
       (modelling-tutor (title 1 :lines) (interactor 4 :lines) :then (rest :even))
       (rest (DATABASE-AND-LISP-PANES 0.6) :then (DEMO-MENU-AND-TRIGGER-DISPLAYS :EVEN))
       (DATABASE-AND-LISP-PANES
	 (MODELLING-TUTOR-COMMAND-MENU :ASK-WINDOW SELF
				       :SIZE-FOR-PANE MODELLING-TUTOR-COMMAND-MENU)
	 :THEN
	 (DATABASE-PANES :EVEN)
	 (LISP-DISPLAY :EVEN))
       (DATABASE-PANES
	 (DB-DISPLAY :EVEN)
	 (DB-MODEL :EVEN))
       (DEMO-MENU-AND-TRIGGER-DISPLAYS
	 (FWD-TRIGGER-DISPLAY :EVEN)
	 (BCKWD-VAR-TRIGGER-DISPLAY :EVEN)
	 (BCKWD-CONST-TRIGGER-DISPLAY :EVEN))))))

(defmethod (redisplay-display-pane modelling-tutor) (stream)
  ;; moby redisplay function for all the display panes
  (unless (assoc stream uninteresting-panes)
    ;; if not already grayed over
    (send stream :clear-history)
    (let ((*package* (find-package "Modelling-Tutor")))
      (select stream
	(((dw:get-program-pane 'db-display))
	 ;; the db-display pane
	 (let ((found-one nil))
	   (flet ((display-predications (p)
		    (ask p
			 #'(lambda (q)
			     (setq found-one t)
			     (format stream "~&~A" (ask-query q)))
			 :do-backward-rules nil)))
	     (display-predications [good-to-eat ?])
	     (display-predications [tasty ?]))
	   (unless found-one
	     (format stream "~&It's empty."))))
	(((dw:get-program-pane 'db-model))
	 ;; the db-model pane
	 (format stream "~&~A" *known-foods*))
	(((dw:get-program-pane 'fwd-trigger-display))
	 ;; the forward trigger display
	 (format stream "~&~A" *good-to-eat-trigger-function*))
	(((dw:get-program-pane 'bckwd-var-trigger-display))
	 ;; the backward variable trigger display
	 (format stream "~&~A" *good-to-eat-backward-variable-triggers*))
	(((dw:get-program-pane 'bckwd-const-trigger-display))
	 ;; the backward constant trigger display
	 (let ((found-one nil))
	   (maphash #'(lambda (key val)
			(setq found-one t)
			(format stream "~&~A  ~A" key val))
		    *good-to-eat-backward-constant-triggers*)
	   (unless found-one
	     (format stream "~&It's empty."))))
	(((dw:get-program-pane 'lisp-display))
	 ;; the lisp display pane
	 nil)
	(otherwise
	  ;; can't possibly be right
	  (error "Unknown display pane: ~S" stream))))))


;;;
;;; Some utilities for writing tutorial scripts.
;;;

(defconstant *really-irrelevant* 0.50 "Gray level for panes that are really irrelevant.")
(defconstant *mildly-irrelevant* 0.33 "Intermediate level of irrelevance.")
(defconstant *red-herring*       0.10 "Irrelevant for now, but may be relevant later.")

;;; doesn't really compile it, but this is guaranteed to work.
(defun compile-rule-on-the-fly (rule-form) (compiler:compile-forms (list rule-form)))

(defun-in-flavor (gray-uninteresting-panes modelling-tutor) ()
  ;; draw gray over the interiors of uninteresting panes
  (loop for (pane . gray-level) in uninteresting-panes
	doing (graphics:draw-rectangle 0 0
				       (send pane :inside-width) (send pane :inside-height)
				       :gray-level gray-level :stream pane)))

(defun-in-flavor (clear-display-panes modelling-tutor) ()
  ;; clear all the display panes
  (loop for pane-name in '(lisp-display db-display db-model fwd-trigger-display
					bckwd-var-trigger-display bckwd-const-trigger-display)
	doing (jericho:redisplay-pane self pane-name t)))

(defun-in-flavor (redisplay-display-panes modelling-tutor) ()
  ;; redisplay all the display panes
  (loop for pane-name in '(db-display db-model fwd-trigger-display bckwd-var-trigger-display
				      bckwd-const-trigger-display)
	doing (redisplay-display-pane self (dw:get-program-pane pane-name))))

(defun-in-flavor (prepare-for-tutoring modelling-tutor) ()
  ;; clear out various bits of state
  (clear)
  (mapc #'undefrule '(ma-po-tofu good-to-eat-means-tasty not-tofuud tofuud))
  (setq *good-to-eat-trigger-function* #'initial-good-to-eat-trigger-function))

(zwei:defindentation (with-modelling-tutor-environment 0 4 1 1))
(defmacro-in-flavor (with-modelling-tutor-environment modelling-tutor) ((&rest options) &body body)
  ;; execute body after binding some stuff and clearing some panes
  (ignore options)
  `(let ((ji::*print-make-predication-forms-prettily* t)	;more Cassels lossage
	 (*standard-output* (dw:get-program-pane 'lisp-display)))
     (prepare-for-tutoring)
     (clear-display-panes)
     ,@body))

(defun-in-flavor (figure-out-new-uninteresting-panes modelling-tutor)
		 (gray-level new-uninteresting new-interesting)
  ;; from what panes the user mentions, figure out new binding for uninteresting-panes
  (loop with first-cut = (append (mapcar #'(lambda (x) (cons (dw:get-program-pane x)
							     gray-level))
					 new-uninteresting)
				 uninteresting-panes)
	for pane-name in new-interesting
	for pane = (dw:get-program-pane pane-name)
	doing (setq first-cut (remove pane first-cut :key #'car))
	      finally (return first-cut)))

(defun-in-flavor (with-interests-internal modelling-tutor)
		 (gray-level new-uninteresting new-interesting body)
  ;; helper for the macro below
  (declare (sys:downward-funarg body))
  (multiple-value-prog1
    ;; it's letf instead of let because uninteresting-panes is an instance variable.
    (letf ((uninteresting-panes (figure-out-new-uninteresting-panes gray-level
								    new-uninteresting
								    new-interesting)))
      (gray-uninteresting-panes)
      (funcall body))
    (gray-uninteresting-panes)))

(zwei:defindentation (with-interests 0 4 1 1))
(defmacro-in-flavor (with-interests modelling-tutor) ((&key (gray-level '*red-herring*)
							    uninteresting-panes
							    interesting-panes)
						      &body body)
  ;; execute body with some panes grayed over because they're uninteresting
  `(with-interests-internal ,gray-level ,uninteresting-panes ,interesting-panes
			    #'(lambda () ,@body)))

(defun-in-flavor (centering-in-box-internal modelling-tutor) (stream continuation)
  ;; helper for the macro below
  (declare (sys:downward-funarg continuation))
  ;; This is a kludge that assures the surrounding-output-with-border won't occur at
  ;; the absolute bottom of the window.  If it does, it leaves a mess during the scrolling process.
  (send stream :set-viewport-position
	(send stream :x-scroll-position)
	(+ (send stream :y-scroll-position) (round (send stream :inside-height) 10)))
  ;; figure out how wide it's going to be and position it appropriately
  (jericho:centering-output (stream :vertically-p nil)
    (surrounding-output-with-border (stream)
      (funcall continuation stream))))

(zwei:defindentation (centering-in-box 0 4 1 1))
(defmacro-in-flavor (centering-in-box modelling-tutor) ((stream &rest options) &body body)
  ;; center output horizontally and draw a box around it
  (ignore options)
  `(centering-in-box-internal ,stream #'(lambda (,stream) ,@body)))

(defun-in-flavor (with-commentary-internal modelling-tutor)
		 (commentor form executor gray-level new-interesting new-uninteresting)
  ;; helper for the macro below
  (declare (sys:downward-funarg commentor executor))
  (with-interests (:gray-level gray-level
		   :uninteresting-panes new-uninteresting
		   :interesting-panes new-interesting)
    (let ((lisp-display (dw:get-program-pane 'lisp-display)))
      ;; print the commentary about the form
      (fresh-line lisp-display) (terpri lisp-display)
      (centering-in-box (lisp-display)
	(funcall commentor lisp-display))
      ;; when there's a form, print it and execute it.  NIL means just commentary.
      (when form
	(with-character-style ('(:fix :roman :normal) lisp-display)
	  (with-character-face (:bold lisp-display)
	    (terpri lisp-display) (princ form lisp-display))
	  ;; execute it and collect all its values
	  (loop for value in (multiple-value-list (funcall executor))
		doing (terpri lisp-display) (princ value lisp-display))))
      ;; update the displays
      (redisplay-display-panes)
      ;; get an acknowledgement from the user that she's ready to go on
      (fresh-line lisp-display)
      (let ((presentation (present "Type any character to continue." 'string
				   :stream lisp-display :acceptably nil)))
	;; Bug: The blinking cursor stays in the interactor pane, not the lisp-display.
	(accept 'character
		:stream lisp-display
		:prompt nil
		:prompt-mode :raw
		:provide-default nil)
	;; I suppose this really wants to be redisplayable; I'm just kludging here.
	(dw:erase-displayed-presentation presentation lisp-display)
	(multiple-value-bind (ignore y) (send lisp-display :read-cursorpos)
	  (send lisp-display :set-cursorpos 0 y)))))) 

(zwei:defindentation (with-commentary 0 4 2 1))
(defmacro-in-flavor (with-commentary modelling-tutor)
		    ((format-string &rest format-args)
		     (&key (gray-level '*red-herring*) interesting-panes uninteresting-panes)
		     form)
  ;; yatter about a form with some panes grayed
  `(with-commentary-internal
     #'(lambda (stream) (format stream ,format-string ,@format-args))
     ',form
     #'(lambda () ,form)
     ,gray-level
     ,interesting-panes
     ,uninteresting-panes)) 

;;;
;;; The actual commands the user sees.
;;;

(define-modelling-tutor-command (com-clear-displays :menu-accelerator t :menu-level :MODELLING-TUTOR-COMMAND-MENU)
    ()
   ;; clear some display panes
   (clear-display-panes))

(define-modelling-tutor-command (com-tutor-data-modelling :menu-accelerator t :menu-level :MODELLING-TUTOR-COMMAND-MENU)
    ()
   ;; show off how data modelling works.
   (with-modelling-tutor-environment ()
     (with-interests (:gray-level *really-irrelevant*
		      :uninteresting-panes '(fwd-trigger-display
					      bckwd-var-trigger-display
					      bckwd-const-trigger-display))
       (with-commentary ("This demonstrates simple usage of the Joshua data modelling facilities.~
                      ~2%Here we'll talk about a predicate of one argument, GOOD-TO-EAT, which is~
                       ~&  true of Chinese foods.  The data gets stored in a special variable ~
                       ~&  called *KNOWN-FOODS*, displayed above and to the right.  ASK's view~
                       ~&  of the database is displayed above and to the left.~
                      ~2%As the demo progresses, you'll see foods appear in the database, and~
                       ~&  see that *KNOWN-FOODS* contains an alist mapping from the food name~
                       ~&  to the corresponding GOOD-TO-EAT predication.")
			(:uninteresting-panes '(db-display db-model))
	 nil)
       (with-commentary ("First, let's clear the database.~
                       ~&Note that the database becomes empty,~
                       ~&and *KNOWN-FOODS* becomes NIL.")
			()
	 (clear))
       (with-commentary ("There's nothing around here to eat now:")
			(:uninteresting-panes '(db-model))
	 (map-over-database-predications [good-to-eat ?] #'say))
       (with-commentary ("And the value of *KNOWN-FOODS, the place where this model puts its data, is:")
			(:uninteresting-panes '(db-display))
	 *known-foods*)
       (with-commentary ("Now let's tell some tales about trips to Chinese restaurants.~
                       ~&Note that ASK finds these, and that they're stored in *KNOWN-FOODS*.")
			()
	 (tell [and [good-to-eat suan-la-chow-show]
		    [good-to-eat kung-pao-chi-ding]
		    [good-to-eat ta-chien-chi-ding]
		    [good-to-eat lychee-nuts]]))
       (with-commentary ("Now let's get our hands on one of those predications.~
                         ~&Note that it disappears from *KNOWN-FOODS*, since this data model~
                         ~&only keeps around *TRUE* predications:")
			()
	 (block found-one
	   (map-over-database-predications [good-to-eat ?]
					   #'(lambda (x)
					       (unjustify x)
					       (return-from found-one x)))))
       (with-commentary ("Finally, let's clear the database, and note all the data goes away:")
			()
	 (clear)))))

(defun-in-flavor (tutor-static-trigger-modelling modelling-tutor) ()
  ;; show off how trigger modelling works for backward, static triggers
  (with-modelling-tutor-environment ()
    (with-interests (:gray-level *really-irrelevant*
		     :uninteresting-panes '(db-model fwd-trigger-display))
      (with-interests (:gray-level *mildly-irrelevant*
		       ;; database and forward triggers irrelevant for this lesson.
		       :uninteresting-panes '(db-display))
	(with-commentary ("This demonstrates simple usage of the Joshua trigger modelling facilities.~
                      ~2%Here we'll deal with backward rules triggering on a predicate of one argument,~
                       ~&  GOOD-TO-EAT, which is true of Chinese foods.  The triggers are either of the~
                       ~&  form [GOOD-TO-EAT ?X] or [GOOD-TO-EAT TOFU], i.e., the argument is either a~
                       ~&  variable or a symbol.  The variable triggers are stored in a variable called~
                       ~&  *GOOD-TO-EAT-VARIABLE-TRIGGERS*, displayed in the middle at the right.  The~
                       ~&  symbol triggers are stored in a hash table called~
                       ~&  *GOOD-TO-EAT-CONSTANT-TRIGGERS*, the contents of which are displayed on the~
                       ~&  bottom at the right.~
                      ~2%As the demo progresses, you'll see triggers appear and disappear from those two~
                       ~&  windows as rules get compiled and undefined.")
			 (:uninteresting-panes '(bckwd-var-trigger-display bckwd-const-trigger-display))
	  nil)
	(with-commentary ("First, let's clear the database (hygiene pays!).")
			 (:interesting-panes '(db-display)
			  :uninteresting-panes '(bckwd-var-trigger-display bckwd-const-trigger-display))
	  (clear))
	(with-commentary ("Now nobody knows about any food, nor do any backward rules respond:")
			 (:uninteresting-panes '(bckwd-var-trigger-display bckwd-const-trigger-display)
			  :interesting-panes '(db-display))
	  (ask [good-to-eat ?] #'say-query))
	(with-commentary ("That's because the database is empty,")
			 (:uninteresting-panes '(bckwd-var-trigger-display bckwd-const-trigger-display)
			  :interesting-panes '(db-display))
	  nil)
	(with-commentary ("There are no rules with triggers like [good-to-eat ?],")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  *good-to-eat-backward-variable-triggers*)
	(with-commentary ("And there are no rules with triggers like [good-to-eat <symbol>].")
			 (:uninteresting-panes '(bckwd-var-trigger-display))
	  *good-to-eat-backward-constant-triggers*)
	(with-commentary ("Now let's compile a rule that triggers on all good-to-eat goals.")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  (compile-rule-on-the-fly
	    '(defrule not-tofuud (:backward)
	       IF (prog1 t (format t "~&Fired the NOT-TOFUUD rule with ?food bound to ~A." ?food))
	       THEN [good-to-eat ?food])))
	(with-commentary ("Now there's one rule with a trigger like [good-to-eat ?]:")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  (mapc #'describe *good-to-eat-backward-variable-triggers*))
	(with-commentary ("But still none with symbol triggers.")
			 (:uninteresting-panes '(bckwd-var-trigger-display))
	  *good-to-eat-backward-constant-triggers*)
	(with-commentary ("So now when we ASK something, we'll get one answer from NOT-TOFUUD:")
			 ()
	  (ask [good-to-eat spiders] #'graph-query-results))
	(with-commentary ("Now let's compile a rule that triggers on a particular food:")
			 (:uninteresting-panes '(bckwd-var-trigger-display))
	  (compile-rule-on-the-fly
	    '(defrule tofuud (:backward)
	       IF (prog1 t (format t "~&Fired the TOFUUD rule."))
	       THEN [good-to-eat tofu])))
	(with-commentary ("Now there's still just one variable trigger good-to-eat rule:")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  *good-to-eat-backward-variable-triggers*)
	(with-commentary ("But there's also a trigger indexed under the symbol TOFU:")
			 (:uninteresting-panes '(bckwd-var-trigger-display))
	  (gethash 'tofu *good-to-eat-backward-constant-triggers*))
	(with-commentary ("Now when we ask about TOFU, we'll get 2 answers (one from each rule):")
			 ()
	  (ask [good-to-eat tofu] #'graph-query-results))
	(with-commentary ("Now let's undefine the rule that has a variable trigger:")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  (undefrule 'not-tofuud))
	(with-commentary ("Note that it's gone from the place where it used to live.")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  *good-to-eat-backward-variable-triggers*)
	(with-commentary ("But the rule indexed under the symbol TOFU is still there:")
			 (:uninteresting-panes '(bckwd-var-trigger-display))
	  (gethash 'tofu *good-to-eat-backward-constant-triggers*))
	(with-commentary ("And now we just get one answer to queries about TOFU, from the rule TOFUUD:")
			 ()
	  (ask [good-to-eat tofu] #'graph-query-results))
	(with-commentary ("Now let's undefine the TOFU rule.")
			 (:uninteresting-panes '(bckwd-var-trigger-display))
	  (undefrule 'tofuud))
	(with-commentary ("The variable-trigger rule is still gone,")
			 (:uninteresting-panes '(bckwd-const-trigger-display))
	  *good-to-eat-backward-variable-triggers*)
	(with-commentary ("as is the TOFU rule; in short, they're both gone.")
			 ()
	  *good-to-eat-backward-constant-triggers*)
	(with-commentary ("So we get no answers when we're hungry.")
			 ()
	  (ask [good-to-eat ?] #'graph-query-results))))))

;;; Cute hack, but more general than we need here.
;(defun-in-flavor (describe-lexical-closure-environment modelling-tutor)
;		 (lexical-closure &optional (stream *standard-output*))
;  ;; describe the values the closure is closed over.
;  (let ((map (sort (copy-list (cdr (assoc :lexical-map
;					  (si:compiled-function-debugging-info
;					    (sys:lexical-closure-function lexical-closure)))))
;		   #'< :key #'cadr))
;	(env (sys:lexical-closure-environment lexical-closure)))
;    (fresh-line stream)
;    (formatting-table (stream)
;      (formatting-column-headings (stream :underline-p t)
;	(formatting-cell (stream :align :center) (princ "Symbol" stream))
;	(formatting-cell (stream :align :center) (princ "Value in Closure" stream)))
;      (loop for (symbol . nil) in map
;	    for value in env
;	    doing (formatting-row (stream)
;		    (formatting-cell (stream :align :center) (princ symbol stream))
;		    (formatting-cell (stream :align :center) (princ value  stream))))))
;  (values))

(defun-in-flavor (describe-lexical-closure-environment modelling-tutor)
		 (lexical-closure &optional (stream *standard-output*))
  ;; describe the values the closure is closed over.
  (fresh-line stream)
  (formatting-table (stream)
    (formatting-column-headings (stream)
      (formatting-cell (stream :align :center)
	(with-underlining (stream)
	  (princ "Symbol" stream)))
      (formatting-cell (stream :align :center)
	(with-underlining (stream)
	  (princ "Value in Closure" stream))))
    ;; in fact, we're only interested in these 2 symbols, not the whole environment.
    (loop for symbol in '(symbol-triggers-table variable-triggers)
	  doing (formatting-row (stream)
		  (formatting-cell (stream :align :center) (princ symbol stream))
		  (formatting-cell (stream :align :center) (princ (symbol-value-in-closure
								    lexical-closure symbol)
								  stream)))))
  (values)) 


(defun-in-flavor (tutor-dynamic-trigger-modelling modelling-tutor) ()
  ;; show off the backward trigger model
  (prepare-for-tutoring)
  (with-modelling-tutor-environment ()
    (with-interests (:gray-level *really-irrelevant*
		     :uninteresting-panes '(db-model
					     bckwd-var-trigger-display bckwd-const-trigger-display))
      (with-interests (:gray-level *mildly-irrelevant*
		       :uninteresting-panes '(db-display))
	(with-commentary ("This demonstrates dynamic trigger modelling in Joshua.~
                      ~2%Here we'll deal with forward rules triggering on a predicate of one argument,~
                       ~&  GOOD-TO-EAT, which is true of Chinese foods.  The triggers are either of the~
                       ~&  form [GOOD-TO-EAT ?X] or [GOOD-TO-EAT TOFU], i.e., the argument is either a~
                       ~&  variable or a symbol.  The modelling mechanism compiles a function that~
                       ~&  gets called with a predication, a flag for MAP-OVER-FORWARD-RULE-TRIGGERS or ~
                       ~&  LOCATE-FORWARD-RULE-TRIGGER, and a continuation.  That function, stored in~
                       ~&  *GOOD-TO-EAT-TRIGGER-FUNCTION*, implements both of those generics.~
                      ~2%As the demo progresses, you'll see that function get redefined in the upper~
                       ~&  right.")
			 (:uninteresting-panes '(fwd-trigger-display))
	  nil)
	(with-commentary ("This is an example of a dynamic trigger model, i.e., every time you add~
                         ~&  or delete a rule, the trigger indexing scheme gets changed.~
                        ~2%That is, every time a rule gets added or deleted, the function in~
                         ~&  *GOOD-TO-EAT-TRIGGER-FUNCTION* gets recompiled.  One can imagine more~
                         ~&  elaborate schemes in which *GOOD-TO-EAT-TRIGGER-FUNCTION* would contain~
                         ~&  code tailored to discriminate between just exactly the set of rules~
                         ~&  in your world.")
			 ()
	  nil)
	(with-commentary ("First, let's clear the database (hygiene pays!).")
			 (:interesting-panes '(db-display)
			  :uninteresting-panes '(fwd-trigger-display))
	  (clear))
	(with-commentary ("Since there are no forward rules triggering on GOOD-TO-EAT, the value of ~
                         ~&  *GOOD-TO-EAT-TRIGGER-FUNCTION* is just its initial value, a function that~
                         ~&  implements MAP-OVER-FORWARD-RULE-TRIGGERS as a no-op, and which does ~
                         ~&  LOCATE-FORWARD-RULE-TRIGGER by noting there are as yet no forward triggers:")
			 ()
	  *good-to-eat-trigger-function*)
	(with-commentary ("Now let's define a rule that triggers on [good-to-eat tofu], suggesting that~
                         ~&  those who like tofu will like a certain tofu dish:")
			 ()
	  (compile-rule-on-the-fly
	    '(defrule ma-po-tofu (:forward)
	       IF [good-to-eat tofu]
	       THEN [good-to-eat ma-po-tofu])))
	(with-commentary ("Note that *GOOD-TO-EAT-TRIGGER-FUNCTION* is now a lexical closure:")
			 ()
	  *good-to-eat-trigger-function*)
	(with-commentary ("It's closed over this:")
			 ()
	  (describe-lexical-closure-environment *good-to-eat-trigger-function*))
	(with-commentary ("There are no rules with triggers that look like [GOOD-TO-EAT ?X]:")
			 ()
	  (symbol-value-in-closure *good-to-eat-trigger-function* 'variable-triggers))
	(with-commentary ("But the rule we just compiled is indexed under TOFU:")
			 ()
	  (maphash #'(lambda (key value) (format t "~&~A  ~A" key value))
		   (symbol-value-in-closure *good-to-eat-trigger-function* 'symbol-triggers-table)))
	(with-commentary ("So if we TELL something about TOFU, the rule will execute, causing~
                         ~&a statement about MA-PO-TOFU to appear in the database display.")
			 (:interesting-panes '(db-display))
	  (tell [good-to-eat tofu]))
	(with-commentary ("Now let's clear the database before adding another rule:")
			 (:interesting-panes '(db-display))
	  (clear))
	(with-commentary ("Now let's define another rule that has a trigger containing a variable.~
                         ~&Surely things that are good to eat are tasty:")
			 ()
	  (compile-rule-on-the-fly
	    '(defrule good-to-eat-means-tasty (:forward)
	       IF [good-to-eat ?food]
	       THEN [tasty ?food])))
	(with-commentary ("Now the rules that trigger on variable-containing GOOD-TO-EAT's are:")
			 ()
	  (symbol-value-in-closure *good-to-eat-trigger-function* 'variable-triggers))
	(with-commentary ("And the rule with the constant trigger is still there:")
			 ()
	  (maphash #'(lambda (key value) (format t "~&~A  ~A" key value))
		   (symbol-value-in-closure *good-to-eat-trigger-function* 'symbol-triggers-table)))
	(with-commentary ("If we now say we like to eat spiders, the variable rule will fire,~
                         ~&  telling us that we probably think spiders are tasty:")
			 (:interesting-panes '(db-display))
	  (tell [good-to-eat spiders]))
	(with-commentary ("And if we say we like tofu, both rules will fire.  In addition,~
                         ~&  the variable rule will fire on the ma-po-tofu conclusion:")
			 (:interesting-panes '(db-display))
	  (tell [good-to-eat tofu]))
	(with-commentary ("Clear the database again.  (Forward programs do this a lot while~
                         ~&  being debugged!)")
			 (:interesting-panes '(db-display))
	  (clear))
	(with-commentary ("Now let's undefine the rule that triggers on [GOOD-TO-EAT TOFU]:")
			 ()
	  (undefrule 'ma-po-tofu))
	(with-commentary ("Note that the variable-triggered rule is still there:")
			 ()
	  (symbol-value-in-closure *good-to-eat-trigger-function* 'variable-triggers))
	(with-commentary ("But the trigger on [GOOD-TO-EAT TOFU] is gone:")
			 ()
	  (maphash #'(lambda (key value) (format t "~&~A  ~A" key value))
		   (symbol-value-in-closure *good-to-eat-trigger-function* 'symbol-triggers-table)))
	(with-commentary ("So if we not tell it we like TOFU, only one rule fires:")
			 (:interesting-panes '(db-display))
	  (tell [good-to-eat tofu]))
	(with-commentary ("Clear the database once again:")
			 (:interesting-panes '(db-display))
	  (clear))
	(with-commentary ("Now let's undefine the variable-triggered rule:")
			 ()
	  (undefrule 'good-to-eat-means-tasty))
	(with-commentary ("Now there are no variable-triggered rules:")
			 ()
	  (symbol-value-in-closure *good-to-eat-trigger-function* 'variable-triggers))
	(with-commentary ("And no symbol-triggered rules:")
			 ()
	  (maphash #'(lambda (key value) (format t "~&~A  ~A" key value))
		   (symbol-value-in-closure *good-to-eat-trigger-function* 'symbol-triggers-table)))
	(with-commentary ("And, the rules being gone, nothing interesting happens when we state~
                         ~&  that we like tofu:")
			 (:interesting-panes '(db-display))
	  (tell [good-to-eat tofu]))
	(with-commentary ("Finally, let's clean up after ourselves:")
			 (:interesting-panes '(db-display))
	  (clear))))))

(define-modelling-tutor-command (com-tutor-trigger-modelling :menu-accelerator t :menu-level :MODELLING-TUTOR-COMMAND-MENU)
    ((type '(member static dynamic)
	   :prompt "type"
	   :default nil
	   :documentation
	   "Which kind of trigger modelling"))
   (ecase type
     ;; dispatch on the type to get what to do.
     (static (tutor-static-trigger-modelling))
     (dynamic (tutor-dynamic-trigger-modelling))))

;;;
;;; Now compile away.
;;;

(compile-flavor-methods modelling-tutor)
