;;; -*- Mode: Joshua; Package: (Jericho (JOSHUA SCL)); Syntax: Joshua -*-
;;;> EXAMPLES-MESSAGE
;;;>
;;;>******************************************************************************************
;;;>
;;;>       Symbolics hereby grants permission to customer to incorporate
;;;>       the examples in this file in any work belonging to customer.
;;;>
;;;>******************************************************************************************
;;; Created 4/06/87 13:44:25 by sgr running on GROUSE at SCRC.

;;;
;;; An automatic test suite for Joshua.  This is in no sense a "verification", in that it gives
;;;  no D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")guarantees0 about what's working and what's not.  It just runs a bunch of test programs,
;;;  and fails to go into the debugger if they all work.  
;;;
;;; Oh, yes, the name.  In the parable of the Good Samaritan, the GS met a poor traveller
;;;  who was on his way to Jericho.  Comments about the name to Bug-LMI.
;;;

(defparameter *joshua-tests* nil "List of tests for Joshua.")
(defparameter *innermost-last-resort-handler* nil);globally bogus value

(zl:local-declare ((dbg:error-reporter t))
(defselect last-resort-handler
  ;; cribbed from dbg:debugger-handler
  (:handle-condition (&rest ignore) (throw *innermost-last-resort-handler* nil))
  (:handle-condition-p (cond) (typep cond 'dbg:debugger-condition))
  (:describe-self-briefly () (princ "Throws NIL to the innermost WITH-LAST-RESORT-HANDLER.")))
)

(defmacro with-last-resort-handler (&body body &aux (tag (gensym)))
  ;; Establish a last-resort error handler.  It runs with the priority of interactive handlers.
  ;; This is useful for test suites, which may want to run condition-bound handlers, default handlers,
  ;; global handlers, and restart handlers, and only lose if all of those lose.
  ;; This catches all such errors and throws to an appropriate catch tag.
  `(catch ',tag
     (let ((*innermost-last-resort-handler* *innermost-last-resort-handler*)
	   (dbg:*interactive-handlers* dbg:*interactive-handlers*))
       ;; establish a new binding contour for theses specials
       (without-interrupts
	 ;; now make them what we want, with armor against c-abort
	 (setq *innermost-last-resort-handler* ',tag
	       dbg:*interactive-handlers* '(last-resort-handler)))	 
       ,@body)))

(defun samaritan (&optional (test-names *joshua-tests*) (stream *standard-output*))
  ;; top-level driver for all the Joshua tests.
  ;; poor man's table formatting (we don't use the DW formatting stuff 'cause we want
  ;; to print the table as it's generated, instead of all at the end.  this way there's
  ;; visible progress in the case of a very long test suite.)
  (loop with tab-string
	initially (setq tab-string
			;; poor man's table-formatting.  
			(format nil "~~~DT"
				(+ 12 (loop for test-name in test-names
					    maximize (string-length test-name)))))
		  (with-underlining (stream :underline-whitespace nil)
		    (format stream "~&~8TTest Name~?Verdict" tab-string))
	for test-name in test-names
	doing (format stream "~&Running ~A..." test-name) (clear)
	if (with-last-resort-handler
	     (funcall test-name))
 	  do (format stream "~?passed." tab-string)
	else
	  do (format stream "~?~'pfailed.~" tab-string)
	  and collect test-name into failed-test-names
	finally
	  (clear)
	  (cond (failed-test-names
		  (format stream "~&~'p~D test~:P out of ~D failed: ~~:\\LIST\\."
			  (length failed-test-names) (length test-names) failed-test-names))
		(t
		  (format stream "~&Passed all ~D test~:P."
			  (length test-names))))))

(cp:define-command (com-test-joshua :command-table "Global")
    ;; CP command to make it easy to test Joshua.
    ((tests `((token-or-type (("All" . :all))
			     ;; subset pr type only takes keywords, darn it!
			     ((sequence ((dw:member-sequence ,*joshua-tests*))))))
	    :prompt "Sequence of Joshua test names or All"
	    :default :all ;gets a nicer prompt than if you put *joshua-tests* here.
	    :documentation "which tests to run"))
   (when (eq tests :all)
     (setq tests *joshua-tests*))
   (samaritan tests))

(def-defining-form deftest
   :definer
   ((name &body body)
    ;; succeeds if all the forms in body return non-NIL.
    `(progn (record-source-file-name ',name 'deftest)
	    (pushnew ',name *joshua-tests*)
	    (defun ,name ()
	      (and ,@body))))
   :killer
   ((name)
    ;; how to undefine a Joshua test
    (setq *joshua-tests* (delete name *joshua-tests*))
    (fundefine name))
   :shower
   ((form)
    (let ((name (second form)))
      (cond ((not (symbolp name))
	     (zwei:barf "Mal-formed test name: ~S" name))
	    ((member name *joshua-tests*)
	     (zwei:typein-line "~&Evaluating this will redefine the Joshua test ~S." name))
	    (t
	      (zwei:typein-line "~&Evaluating this will define the Joshua test ~S for the first time."
				name))))
    t)
   :type-name "Joshua Test")

;;;
;;; Some tools useful for writing tests.
;;;

(defun check-database (predication)
  ;; check that something is in the database
  (ask predication #'(lambda (&rest ignore) (return-from check-database t))
       :do-backward-rules nil))

(defun test-n-successes (n query)
  ;; test whether or not a query succeeds n times.
  (let ((success-count 0))
    (flet ((count-successes (ignore) (incf success-count)))
      (ask query #'count-successes)
      (= success-count n)))) 

(defun test-n-fetches (n query)
  ;; like test-n-successes, but at the database level
  (let ((success-count 0))
    (flet ((count-successes (ignore) (incf success-count)))
      (fetch query #'count-successes)
      (= success-count n))))

;;;
;;; Definitions of the tests.
;;;

(deftest ht-test
  ;; test the HT example
  (equal (ht:diagnose-circuit nil) '(ht:m2)))

(deftest ht-test-2
  ;; test an alternative HT example (had a bug, fixed as of 1/26/88)
  (let ((answer (ht:diagnose-circuit nil t 'ht:alternate)))
    (and (= (length answer) 2)
	 (member 'ht:m1 answer)
	 (member 'ht:a1 answer))))

;;; (deftest modelled-ht-test
;;;   ;; test the HT example, new version
;;;   (equal (mht:diagnose-circuit nil) '(mht:m2)))

;;; (deftest modelled-ht-test-2
;;;   ;; test an alternative HT example (had a bug, fixed as of 1/26/88)
;;;   (let ((answer (mht:diagnose-circuit nil t 'mht:alternate)))
;;;     (and (= (length answer) 2)
;;;	  (member 'mht:m1 answer)
;;;	  (member 'mht:a1 answer))))

(deftest monkey-test
  ;; test the monkey & bananas
  (equal (plan:benchmark-monkey-world nil nil)
	 'plan:(HANDLE BANANAS EAT
		       (HANDLE BANANAS TAKE
			       (WALK UP
				     (HANDLE LADDER DROP
					     (WALK RIGHT
						   (HANDLE LADDER TAKE
							   (WALK LEFT NOW)))))))))

(deftest blocks-test
  ;; test the blocks world
  (with-stack-overflows 1
    ;; run the body, growing stacks at most 2 times.
    (equal (plan:benchmark-blocks-world nil nil)
	   'plan:(PUT-ON A C 
			 (PUT-ON C B
				 (PUT-ON A TABLE
					 (PUT-ON A C
						 (PUT-ON D TABLE
							 (PUT-ON B TABLE NOW)))))))))

(deftest grampaw-test
  ;; test the "I'm my own grampaw" example
  (eq (gramps:find-own-grandparent :male nil) 'gramps:me)
  (eq (gramps:find-own-grandparent :female nil) 'gramps:daughter))

(deftest midsummer-test
  ;; test the midsummer TMS example
  (progn
    (let ((number-of-contradictions 0)
	  (number-of-debugger-contradictions 0))
      ;; there should be 2 contradictions, one of which would go into the debugger
      ;; (more than 1 assumption)
      (condition-bind ((tms-contradiction
			 ;; have to handle the contradiction automatically, can't ask user.
			 #'(lambda (condition)
			     ;; make sure it's the contradiction we expect, and then handle it
			     ;; the way we want to.  (Note that 2 contradictions happen, only one
			     ;; of which is interesting.)
			     (incf number-of-contradictions)
			     (let ((non-premises (tms-contradiction-non-premises condition))
				   (premises     (tms-contradiction-premises condition))
				   lysander-loves)
			       (when (> (length non-premises) 1)
				 (incf number-of-debugger-contradictions))
			       (flet ((check-justification-statement (justification statement)
					(multiple-value-bind (nil predication nil) (destructure-justification justification)
					  (equal (predication-statement predication) statement))))
				 (when (and (= (length non-premises) 2)
					    (= (length premises)     1)
					    (check-justification-statement
					      (first premises) 'tme:(jealous lysander))
					    (setq lysander-loves
						  (find-if #'(lambda (x)
							       (check-justification-statement
								 x 'tme:(loves Lysander Hermia)))
							   non-premises))
					    (find-if #'(lambda (x)
							       (check-justification-statement
								 x 'tme:(loves Demetrius Hermia)))
							   non-premises))
				   ;; this is the one we're looking for. (Let the system handle others.)
				   ;; We want to unjustify [loves Lysander Hermia], since that causes the
				   ;; most agitation.
				   (remove-justification lysander-loves)
				   (values :unjustify-subset lysander-loves)))))))
	(tme:midsummer-world nil))
      ;; see if the database is in the state we expect
      (and (check-database tme:[loves Lysander  Hermia])
	   (check-database tme:[loves Hermia    Lysander])
	   (check-database tme:[loves Helena    Demetrius])
	   (check-database tme:[loves Demetrius Helena])
	   (check-database tme:[jealous Lysander])
	   (= number-of-contradictions 2)
	   (= number-of-debugger-contradictions 1)))))

(deftest tweety-test
  ;; test the Tweety TMS example
  (multiple-value-bind (first second third)
      (tme:tweety nil
		  :first-fun  #'(lambda (ignore) (check-database tme:[fly tweety]))
		  :second-fun #'(lambda (ignore) (check-database tme:[not [fly tweety]]))
		  :third-fun  #'(lambda (ignore) (check-database tme:[fly tweety])))
    (and first second third)))

(deftest cryptarithmetic-test
  ;; If these return non-NIL, it's a validated solution.
  ;; If anybody returns NIL, it means he couldn't find a solution.
  ;; If anybody tries to go to the debugger, it means he found a wrong solution!
  (crypt:solve-cryptarithmetic-problem 'donald 'gerald 'robert '((#\D . 5)))
  (crypt:solve-cryptarithmetic-problem 'potato 'tomato 'vegies))

(defun count-n-queens (n)
  ;; count the solutions to the n-queens problem
  (let ((count 0))
    (tme:n-queens n #'(lambda () (incf count)) #'(lambda (ignore) ()))
    count))

(deftest n-queens-test
  ;; test the N Queens problem
  (= (count-n-queens 1) 1)
  (= (count-n-queens 2) 0)
  (= (count-n-queens 3) 0)
  (= (count-n-queens 4) 2)
  (= (count-n-queens 5) 10)
  (= (count-n-queens 6) 4)
  (= (count-n-queens 7) 40)
  (= (count-n-queens 8) 92))

(deftest model-tutor-data-test
  ;; test the data model tutor
  (let ((pred1 [modelling-tutor:good-to-eat suan-la-chow-show])
	(pred2 [modelling-tutor:good-to-eat dan-dan-noodles]))
    (flet ((check-food (food pred)
	     (eq (cdr (assoc food modelling-tutor:*known-foods*)) pred)))
      (and (progn (clear) (null modelling-tutor:*known-foods*))
	   (tell pred1)
	   (check-database pred1)
	   (= (length modelling-tutor:*known-foods*) 1)
	   (check-food 'suan-la-chow-show pred1)
	   (tell pred2)
	   (check-database pred2)
	   (= (length modelling-tutor:*known-foods*) 2)
	   (check-food 'suan-la-chow-show pred1)
	   (check-food 'dan-dan-noodles pred2)
	   (prog1 t (unjustify pred1))
	   (not (check-database pred1))
	   (check-database pred2)
	   (= (length modelling-tutor:*known-foods*) 1)
	   (check-food 'dan-dan-noodles pred2)
	   (progn (clear) (null modelling-tutor:*known-foods*))))))

(deftest model-tutor-static-trigger-test
  ;; static trigger model tests
  (prog1 t
	 (undefrule 'modelling-tutor:tofuud) ;clean up state from previous runs
	 (undefrule 'modelling-tutor:not-tofuud))
  (flet ((count-table-elements (table)
	   (let ((answer 0))
	     (maphash #'(lambda (&rest ignore) (incf answer)) table)
	     answer)))
    (and (null modelling-tutor:*good-to-eat-backward-variable-triggers*)
	 (= (count-table-elements modelling-tutor:*good-to-eat-backward-constant-triggers*) 0)
	 (test-n-successes 0 modelling-tutor:[good-to-eat tofu])
	 ;; add 1 var-trigger rule
	 (prog1 t
		modelling-tutor:
		(compile-rule-on-the-fly
		  '(defrule not-tofuud (:backward)
		     IF t
		     THEN [good-to-eat ?food])))
	 (= (length modelling-tutor:*good-to-eat-backward-variable-triggers*) 1)
	 (= (count-table-elements modelling-tutor:*good-to-eat-backward-constant-triggers*) 0)
	 (test-n-successes 1 modelling-tutor:[good-to-eat spiders])
	 ;; add 1 constant-trigger rule
	 (prog1 t
		modelling-tutor:
		(compile-rule-on-the-fly
		  '(defrule tofuud (:backward)
		     IF t
		     THEN [good-to-eat tofu])))
	 (= (length modelling-tutor:*good-to-eat-backward-variable-triggers*) 1)
	 (= (count-table-elements modelling-tutor:*good-to-eat-backward-constant-triggers*) 1)
	 (test-n-successes 2 modelling-tutor:[good-to-eat tofu])
	 ;; remove the constant-trigger rule
	 (prog1 t (undefrule 'modelling-tutor:tofuud))
	 (= (length modelling-tutor:*good-to-eat-backward-variable-triggers*) 1)
	 (= (count-table-elements modelling-tutor:*good-to-eat-backward-constant-triggers*) 0)
	 (test-n-successes 1 modelling-tutor:[good-to-eat tofu])
	 ;; remove the var-trigger rule
	 (prog1 t (undefrule 'modelling-tutor:not-tofuud))
	 (null modelling-tutor:*good-to-eat-backward-variable-triggers*)
	 (= (count-table-elements modelling-tutor:*good-to-eat-backward-constant-triggers*) 0)
	 (test-n-successes 0 modelling-tutor:[good-to-eat tofu]))))

(deftest model-tutor-dynamic-trigger-test
  ;; dyanmic trigger model tests
  (prog1 t
	 (undefrule 'modelling-tutor:ma-po-tofu) ;clean up state from previous runs
	 (undefrule 'modelling-tutor:good-to-eat-means-tasty))
  (flet ((variable-triggers ()
	   (when (typep modelling-tutor:*good-to-eat-trigger-function* 'sys:lexical-closure)
	     (symbol-value-in-closure modelling-tutor:*good-to-eat-trigger-function*
				      'modelling-tutor:variable-triggers)))
	 (symbol-triggers ()
	   (when (typep modelling-tutor:*good-to-eat-trigger-function* 'sys:lexical-closure)
	     (let ((answer nil))
	       (maphash #'(lambda (ignore value) (push value answer))
			(symbol-value-in-closure modelling-tutor:*good-to-eat-trigger-function*
						 'modelling-tutor:symbol-triggers-table))
	       answer))))
    (and (null (variable-triggers))
	 (null (symbol-triggers))
	 ;; add a symbol-triggered rule
	 (prog1 t
		modelling-tutor:
		(compile-rule-on-the-fly
		  '(defrule ma-po-tofu (:forward)
		     IF [good-to-eat tofu]
		     THEN [good-to-eat ma-po-tofu])))
	 (null (variable-triggers))
	 (= (length (symbol-triggers)) 1)
	 (prog1 t (tell modelling-tutor:[good-to-eat tofu]))
	 (check-database modelling-tutor:[good-to-eat tofu])
	 (check-database modelling-tutor:[good-to-eat ma-po-tofu])
	 (prog1 t (clear))
	 ;; add another rule
	 (prog1 t
		modelling-tutor:
		(compile-rule-on-the-fly
		  '(defrule good-to-eat-means-tasty (:forward)
		     IF [good-to-eat ?food]
		     THEN [tasty ?food])))
	 (= (length (variable-triggers)) 1)
	 (= (length (symbol-triggers)) 1)
	 (prog1 t (tell modelling-tutor:[good-to-eat spiders]))
	 (check-database modelling-tutor:[good-to-eat spiders])
	 (check-database modelling-tutor:[tasty spiders])
	 (prog1 t (clear) (tell modelling-tutor:[good-to-eat tofu]))
	 (check-database modelling-tutor:[good-to-eat tofu])
	 (check-database modelling-tutor:[tasty tofu])
	 (check-database modelling-tutor:[good-to-eat ma-po-tofu])
	 (check-database modelling-tutor:[tasty ma-po-tofu])

	 (prog1 t (clear) (undefrule 'modelling-tutor:ma-po-tofu))
	 (null (symbol-triggers))
	 (= (length (variable-triggers)) 1)
	 (prog1 t (tell modelling-tutor:[good-to-eat tofu]))
	 (check-database modelling-tutor:[good-to-eat tofu])
	 (check-database modelling-tutor:[tasty tofu])
	 (not (check-database modelling-tutor:[good-to-eat ma-po-tofu]))

	 (prog1 t (clear) (undefrule 'modelling-tutor:good-to-eat-means-tasty))
	 (null (symbol-triggers))
	 (null (variable-triggers))
	 (prog1 t (tell modelling-tutor:[good-to-eat tofu]))
	 (check-database modelling-tutor:[good-to-eat tofu])
	 (not (check-database modelling-tutor:[good-to-eat ma-po-tofu]))
	 (not (check-database modelling-tutor:[tasty tofu])))))

;;;
;;; Lower-level tests.
;;;

;;;dumb frob for testing KNOWN
(define-predicate test-known (x)
		  (no-variables-in-data-mixin default-predicate-model))

(deftest known-test 
  ;; run a test of KNOWN
  ;; put test data in database
  (tell [test-known 1])
  (tell [not [test-known 2]])
  ;; ASKing for PROVABLE, 1 truth-value
  (test-n-successes 1 [provable [test-known ?]])
  (test-n-successes 1 [provable [not [test-known ?]]])
  (test-n-successes 0 [provable [test-known foo]])
  (test-n-successes 0 [provable [not [test-known foo]]])
  
  ;; ASKing for NOT PROVABLE, 1 truth-value
  (test-n-successes 1 [not [provable [test-known foo]]])
  (test-n-successes 1 [not [provable [not [test-known foo]]]])	;Yow!  Figure that out!
  (test-n-successes 0 [not [provable [test-known 1]]])
  (test-n-successes 0 [not [provable [not [test-known 2]]]])
  
  ;; ASKing for KNOWN, both truth-values
  (test-n-successes 0 [known [test-known foo]])
  (test-n-successes 0 [known [not [test-known foo]]])	;same as previous case
  (test-n-successes 1 [known [test-known 1]])
  (test-n-successes 1 [known [not [test-known 1]]])	;same as previous case
  (test-n-successes 1 [known [not [test-known 2]]])
  (test-n-successes 1 [known [test-known 2]])		;same as previous case
  
  ;; ASKing for NOT KNOWN, both truth-values
  (test-n-successes 0 [not [known [test-known 1]]])
  (test-n-successes 0 [not [known [not [test-known 1]]]])	;same as previous case
  (test-n-successes 0 [not [known [not [test-known 2]]]])
  (test-n-successes 0 [not [known [test-known 2]]])	;same as previous case
  (test-n-successes 1 [not [known [test-known foo]]])
  (test-n-successes 1 [not [known [not [test-known foo]]]])	;same as previous case
  )

(define-predicate bozo (who) (no-variables-in-data-mixin ltms:ltms-predicate-model))

(deftest one-of-test
  ;;; first add the constraint that sombody is a bozo.
  (prog1 t (tell [ltms:one-of [bozo larry] [bozo curly] [bozo moe]] :justification :assumption))
  ;; now it should believe Larry is a bozo and have no opinion about the others
  (test-n-successes 1 [ltms:one-of . ?])
  (test-n-successes 1 [bozo ?])
  (test-n-successes 0 [not [bozo ?]])
  (check-database [bozo larry])
  ;; now tell it larry's not a bozo
  (prog1 t (tell [not [bozo larry]]))
  ;; it should believe curly's a bozo and larry isn't while having no opinion about moe
  (test-n-successes 1 [ltms:one-of . ?])
  (test-n-successes 1 [bozo ?])
  (test-n-successes 1 [not [bozo ?]])
  (check-database [bozo curly])
  (check-database [not [bozo larry]])
  ;; now tell it curly's not a bozo
  (prog1 t (tell [not [bozo curly]]))
  ;; it should believe curly and larry are not bozos, but moe is
  (test-n-successes 1 [ltms:one-of . ?])
  (test-n-successes 1 [bozo ?])
  (test-n-successes 2 [not [bozo ?]])
  (check-database [bozo moe])
  (check-database [not [bozo larry]])
  (check-database [not [bozo curly]])
  ;; now tell it (ok, so this is a fantasy) that moe is not a bozo
  (prog1 t (tell [not [bozo moe]]))
  ;; now it should believe all 3 are not bozos, and have rejected the one-of
  (test-n-successes 0 [ltms:one-of . ?])
  (test-n-successes 1 [not [ltms:one-of . ?]])
  (test-n-successes 0 [bozo ?])
  (test-n-successes 3 [not [bozo ?]])
  (check-database [not [bozo larry]])
  (check-database [not [bozo curly]])
  (check-database [not [bozo moe]]))

;(defun test-one-of-noisily ()
;  ;; let the three stooges demonstrate backtracking
;  (labels ((print-it (ignore fact)
;	     (formatting-cell () (prin1 fact)))
;	   (show-em (predication justification format-string &rest format-args)
;	     (tell predication :justification justification)
;	     (with-character-face (:bold)
;	       (apply #'format *standard-output* format-string format-args))
;	     (fresh-line)
;	     (formatting-item-list ()
;	       (ask [ltms:one-of . ?] #'print-it :do-backward-rules nil)
;	       (ask [not [ltms:one-of . ?]] #'print-it :do-backward-rules nil)
;	       (ask [bozo ?] #'print-it :do-backward-rules nil)
;	       (ask [not [bozo ?]] #'print-it :do-backward-rules nil))))
;    (clear)
;    (show-em [ltms:one-of [bozo larry] [bozo moe] [bozo curly]] :assumption
;	     "~&One of Larry, Moe, or Curly is a bozo:")
;    (show-em [not [bozo larry]] :premise "~2%It ain't Larry:")
;    (show-em [not [bozo moe]] :premise "~2%It ain't Moe:")
;    (show-em [not [bozo curly]] :premise "~2%And it ain't Curly (ok, so this is a fantasy):")
;    (values)))

;(deftest stack-collector-test
;  ;; simple test suite that causes an overflow
;  (flet ((compare-stack-collector-contents (list stack-collector)
;	   (equal (ji::stack-collector-g-l-p stack-collector) list)))
;    (loop for i from 1 upto 7
;	  always (ji::with-stack-collector (foo 5)
;		   (loop for j from 1 upto i
;			 doing (ji::stack-collect j foo)
;			 collect j into the-list
;			 finally (return (compare-stack-collector-contents the-list foo)))))))

(deftest dn-table-test
  ;; test the tables used by the discrimination net
  ji::
  (let ((dn-table (make-dn-table)))
    (and (zerop (dn-table-size dn-table))
	 (null (dn-table-get 1 dn-table))
	 (loop for i below *dn-table-crossover-size*
	       ;; fill to brim, but not over
	       doing (setf (dn-table-get i dn-table) i)
	       finally (return t))
	 (dn-table-alist-p dn-table)
	 (listp (dn-table-data dn-table))
	 (every #'numberp (dn-table-keys dn-table))
	 (every #'numberp (dn-table-values dn-table))
	 (setf (dn-table-get 'foo dn-table) 'bar) ;1 above
	 (not (dn-table-alist-p dn-table)))))

(define-predicate jericho-type-of-host (a b)
		  (no-variables-in-data-mixin default-predicate-model))
(define-predicate jericho-machine-type (a b)
		  (no-variables-in-data-mixin default-predicate-model))
(define-predicate jericho-uses-bitmap-printer (a b)
		  (no-variables-in-data-mixin default-predicate-model))
(deftest ask-conjunct-test
  ;; 7thSon found a bug in the ASK method of AND-model, which first showed up if you
  ;; ASKed more than 3 conjuncts (a let of conjunct was missing, so it made closures
  ;; over a lexical that subsequently changed).  In the example below, the 2nd query would
  ;; get ASKed 2ce, and the 3rd query not at all, leading to uninstantiated variables.
  (progn (tell [and [jericho-type-of-host riverside lispm]
		    [jericho-machine-type riverside 3600]
		    [jericho-uses-bitmap-printer riverside journal]])
	 (block test-ask-of-conjunct
	   (ask [and [jericho-type-of-host ?host ?type]
		     [jericho-machine-type ?host ?machine-type]
		     [jericho-uses-bitmap-printer ?host ?printer]]
		#'(lambda (backward-support)
		    (when (and (typep (ask-query backward-support) 'ji::and-internal)
			       (not (sys:unbound-logic-variable-p ?host))
			       (not (sys:unbound-logic-variable-p ?type))
			       (not (sys:unbound-logic-variable-p ?machine-type))
			       (not (sys:unbound-logic-variable-p ?printer)))
		      ;; this is ok
		      (return-from test-ask-of-conjunct t)))))))
;;;
;;; Test importance feature for forward rules.  (Incomplete test as of now.)
;;;

(defvar *importance-of-secondary-rule*)
(defvar *importance-of-primary-rule*)
(defvar *firing-order*)

(define-predicate test-forward-importance (x)
		  (no-variables-in-data-mixin default-predicate-model))

(defrule primary-rule (:forward :importance *importance-of-primary-rule*)
  IF [test-forward-importance ?x]
  THEN (push 'primary-rule *firing-order*))

(defrule secondary-rule (:forward :importance *importance-of-secondary-rule*)
  IF [test-forward-importance ?x]
  THEN (push 'secondary-rule *firing-order*))

(deftest forward-importance-test
  ;; test variable rule importances
  (and (progn (clear)
	      (setq *firing-order* nil
		    *importance-of-primary-rule* 10
		    *importance-of-secondary-rule* 1)
	      ;; primary-rule should fire first
	      (tell [test-forward-importance foo])
	      (equal *firing-order* '(secondary-rule primary-rule)))
       (progn (clear)
	      (setq *firing-order* nil
		    *importance-of-primary-rule* 1
		    *importance-of-secondary-rule* 10)
	      ;; secondary-rule should fire first
	      (tell [test-forward-importance foo])
	      (equal *firing-order* '(primary-rule secondary-rule))))) 

;;;
;;; Test importance feature for backward rules.  (Incomplete test as of now.)
;;; (This should be combined with the forward importance test above, and expanded to be rigorous.)
;;;

(define-predicate test-backward-importance (x)) ;should share w/forward importance test

(defrule primary-rule-backward (:backward :importance *importance-of-primary-rule*)
  IF t
  THEN [test-backward-importance primary-rule-backward])

(defrule secondary-rule-backward (:backward :importance *importance-of-secondary-rule*)
  IF t
  THEN [test-backward-importance secondary-rule-backward])

(deftest backward-importance-test
  ;; test variable rule importances
  (and (progn (clear)
	      (setq *importance-of-primary-rule* 10
		    *importance-of-secondary-rule* 1)
	      ;; primary-rule should fire first
	      (let ((firing-order nil))
		(ask [test-backward-importance ?rule-name]
		     #'(lambda (&rest ignore) (push ?rule-name firing-order)))
		(equal firing-order '(secondary-rule-backward primary-rule-backward))))
       (progn (clear)
	      (setq *importance-of-primary-rule* 1
		    *importance-of-secondary-rule* 10)
	      ;; secondary-rule should fire first
	      (let ((firing-order nil))
		(ask [test-backward-importance ?rule-name]
		     #'(lambda (&rest ignore) (push ?rule-name firing-order)))
		(equal firing-order '(primary-rule-backward secondary-rule-backward))))))

;;;
;;; Test of importance-hacking for backward questions.  (This should be automated somehow.)
;;;

(defvar *ask-is-on-2-importance* 1)
(defvar *question-order* nil)

(defquestion ask-is-on-0 (:backward) [plan:is-on a b]
  :code
  ;; just note it's fired and continue
  ((query truth-value continuation)
   (ignore query truth-value)
   (push 0 *question-order*)
   (succeed)))
	     
(defquestion ask-is-on-1 (:backward :importance 2) [plan:is-on a b]
  :code
  ;; just note it's fired and continue
  ((query truth-value continuation)
   (ignore truth-value query)
   (push 1 *question-order*)
   (succeed)))

(defquestion ask-is-on-2 (:backward :importance *ask-is-on-2-importance*) [plan:is-on a b]
  :code
  ;; just note it's fired and continue
  ((query truth-value continuation)
   (ignore truth-value query)
   (push 2 *question-order*)
   (succeed)))

(deftest backward-question-importance-test
  ;; run a simple dummy test of questions & importance.
  (progn (setq *ask-is-on-2-importance* 1
	       *question-order* nil)
	 ;; should get them in order 0, 1, 2
	 (ask [plan:is-on a b] #'ignore :do-backward-rules nil :do-questions t)
	 (equal *question-order* '(2 1 0)))
  (progn (setq *ask-is-on-2-importance* 3
	       *question-order* nil)
	 ;; should get them in order 0, 2, 1
	 (ask [plan:is-on a b] #'ignore :do-backward-rules nil :do-questions t)
	 (equal *question-order* '(1 2 0))))

;;;
;;; Test for UNTELL.
;;;

(define-predicate simple-simon (arg1 arg2)
		  (no-variables-in-data-mixin default-predicate-model))

(deftest untell-test
  (flet ((untell-simon (x y)
	   ;; remove certain simple-simon patterns from the database
	   (map-over-database-predications `[simple-simon ,x ,y] #'untell)
	   t)
	 (tell-simon ()
	   (tell [and [simple-simon 1 2]
		      [simple-simon 2 3]])))
    (and (null (untell [simple-simon foo bar])) ;should do nothing; 1st imple looped!
	 ;; first test that it becomes invisible to ASK
	 (tell-simon)
	 (test-n-successes 2 [simple-simon ? ?])
	 (untell-simon 1 2)
	 (test-n-successes 1 [simple-simon ? ?])
	 (untell-simon 2 3)
	 (test-n-successes 0 [simple-simon ? ?])
	 ;; now test at the database level (no unification or truth-value checking)
	 (tell-simon)
	 (test-n-fetches 2 [simple-simon ? ?])
	 (untell-simon 1 2)
	 (test-n-fetches 1 [simple-simon ? ?])
	 (untell-simon 2 3)
	 (test-n-fetches 0 [simple-simon ? ?]))))

;;;
;;; Tests for filters in forward rules.
;;;

(define-predicate test-filter-1 (a b)
		  (no-variables-in-data-mixin default-predicate-model))
(define-predicate test-filter-2 (a b)
		  (no-variables-in-data-mixin default-predicate-model))
(define-predicate test-filter-3 (a)
		  (no-variables-in-data-mixin default-predicate-model))

(defrule forward-filter-test-rule (:forward)
  IF [and [test-filter-1 ?a ?b]
	  (ask [test-filter-2 ?b ?c] #'(lambda (ignore) (succeed)))
	  [test-filter-1 ?c ?d]]
  THEN [test-filter-3 ?d])

(deftest forward-trigger-filter-test
  ;; put some stuff in the database and see if the ask in the filter above works
  ;; this is nowhere near an exhaustive test
  (tell [test-filter-2 2 3])
  (tell [test-filter-2 2 4])
  (tell [test-filter-2 2 5])
  (tell [test-filter-1 1 2])
  (tell [test-filter-1 3 5])
  (tell [test-filter-1 4 6])
  (tell [test-filter-1 7 8])
  (let ((values nil))
    (ask [test-filter-3 ?x]
	 #'(lambda (ignore)
	     (push ?x values)))
    (equal (sort values #'<)
	   '(5 6))))

;;; Walter's append example.  (Next comments from his original bug report.)
;; The first few queries work fine.
;; The final query causes the control stack to overflow without printing anything.
;; In Prolog, it should succeed with the following answers:
;;
;; nil -- use AP1 once
;; (?) -- use AP1, then AP2
;; (? ?) -- use AP1, then AP2 twice, etc...
;; Is there some way of ordering the Joshua rules to get the
;; prolog effect here?

(define-predicate jappend (x y z))

(defrule jappend-1 (:backward :importance 1)
  If [jappend ?x ?y ?z]
  Then [jappend (?a . ?x) ?y (?a . ?z)])

(defrule jappend-2 (:backward :importance 2)
  If t
  Then [jappend nil ?x ?x])

(deftest jappend-test
  (macrolet ((test-ask-append (query var answer &aux (tag (gensym)))
	       `(block ,tag
		  (ask ,query
		       #'(lambda (&rest ignore)
			   (when (equal ,var ,answer)
			     (return-from ,tag t)))))))
    (and (test-ask-append [jappend (1 2) (3 4) ?x]     ?x '(1 2 3 4))
	 (test-ask-append [jappend (1 2) ?x (1 2 3 4)] ?x '(3 4))
	 (test-ask-append [jappend ?x (3 4) (1 2 3 4)] ?x '(1 2))
	 (test-ask-append [jappend (1 2) (3 . ?y) ?x]  ?x (list* 1 2 3 ?y))
	 (test-ask-append [jappend (1 2) ?y ?x]        ?x (list* 1 2 ?y))
	 ;;(test-ask-append [jappend ?x nil ?x] ???)
	 )))
       
;    (asking [jappend (1 2) ?y ?x] (print ?y))
;    (asking [jappend ?x nil ?x] (print ?x))))

;;;
;;; A test of tell/ask-data/clear modelling.
;;;

(defvar *known-foods* nil "What's on the menu.")

(define-predicate-model good-to-eat-model () (default-protocol-implementation-model)
  (:required-instance-variables food))

(define-predicate-method (tell good-to-eat-model) (truth-value justification)
  (declare (ignore justification))
  ;; tell something about food.
  (when (sys:unbound-logic-variable-p food)
    (error "You can't possibly mean that everything is good to eat: ~S" self))
  (unless (= truth-value *true*)
    (error "You don't need to say what's not good to eat: ~S" self))
  (cond ((member food *known-foods*)
	 ;; this thing is already known to be good to eat.
	 self)
	(t
	 ;; this is a new one, put it on the list
	 (push food *known-foods*)
	 self)))

(define-predicate-method (ask-data good-to-eat-model) (truth-value continuation)
  ;; retrieve some data about known foods
  (unless (or (null truth-value)
	      (eql truth-value *true*))
    (signal 'ji:model-can-only-handle-positive-queries
	    :model (type-of self)
	    :query self))
  (typecase food
    (unbound-logic-variable
      ;; wants to succeed once for each possible food
      (loop for known-food in *known-foods*
	    doing (with-unification
		    (unify food known-food)
		    (stack-let ((support `(,self ,truth-value good-to-eat)))
		      (funcall continuation support)))))
    (otherwise
      ;; wants to know if something in particular is good to eat
      (when (member food *known-foods*) (funcall continuation self 'good-to-eat)))))

(define-predicate-method (clear good-to-eat-model) (&optional (clear-database t) ignore)
  ;; flush all the data about known foods
  (when clear-database
    (setq *known-foods* nil)))

(define-predicate good-to-eat (food) (good-to-eat-model) :destructure-into-instance-variables)

(deftest simple-data-modelling-test
  (and
    ;; test the insert part of it
    (progn (setq *known-foods* nil)
	   (tell [and [good-to-eat suan-la-chow-show]
		      [good-to-eat kung-pao-chi-ding]
		      [good-to-eat ta-chien-chi-ding]
		      [good-to-eat lychee-nuts]])
	   (equal *known-foods* '(lychee-nuts ta-chien-chi-ding kung-pao-chi-ding suan-la-chow-show)))
    ;; test the ask part of it -- first number of successes
    (test-n-successes 4 [good-to-eat ?what])
    ;; then with var instantiated.
    (check-database [good-to-eat suan-la-chow-show])
    (check-database [good-to-eat kung-pao-chi-ding])
    (check-database [good-to-eat ta-chien-chi-ding])
    (check-database [good-to-eat lychee-nuts])
    ;; then with var uninstantiated
    (let ((answers nil))
      (ask [good-to-eat ?what] #'(lambda (ignore) (push ?what answers)))
      (equal (reverse answers) *known-foods*))
    ;; test the clear-model part of it
    (progn (clear)
	   (null *known-foods*))))

;;;
;;; Test of subsumption.
;;;

(define-predicate subsumption-tester (arg))
(deftest subsumption-test
  ;; this tests for a dn bug JGA found while trying to understand unify and variant.
  (progn (clear)
	 (let ((old-guy (tell [subsumption-tester ?x])))
	   (let ((new-guy (tell [subsumption-tester ?y])))
	     (when (eql old-guy new-guy)
	       (test-n-successes 1 [subsumption-tester ?]))))))

(define-object-type site
  :slots (file-server mail-server namespace-server domain-server))

(define-predicate site-value-of
	(slot value)
	(slot-value-mixin default-protocol-implementation-model))

(define-predicate-method (say site-value-of) (&optional (stream *standard-output*))
  (with-statement-destructured (slot server) self
    (destructuring-bind (site server-type) (path-name slot)
      (format stream "~&The ~S of site ~S is ~S." server-type site server))))

(deftest location-value-test
  (let ((site (make-object 'site :name 'SCRC)))
    (and
      ;; first make sure all the slots are unbound
      (let ((found-one nil))
	(map-over-slots-of-object
	  #'(lambda (slot)
	      (when (location-boundp (locf (slot-current-value slot)))
			     (setq found-one t)))
	  site)
	(not found-one))
      ;; now fill in some slots by TELLing the appropriate predications
      (tell [and [site-value-of (scrc file-server) quabbin]
		 [site-value-of (scrc mail-server) elephant-butte]
		 [site-value-of (scrc namespace-server) riverside]
		 [site-value-of (scrc domain-server) pegasus]])
      ;; now see if it got filled in right
      (eq (file-server site) 'quabbin)
      (eq (mail-server site) 'elephant-butte)
      (eq (namespace-server site) 'riverside)
      (eq (domain-server site) 'pegasus)
      ;; make sure the database understands how to find it
      (check-database [site-value-of (scrc file-server) quabbin])
      (check-database [site-value-of (scrc mail-server) elephant-butte])
      (check-database [site-value-of (scrc namespace-server) riverside])
      (check-database [site-value-of (scrc domain-server) pegasus])
      ;; clear the database
      (clear)
      ;; make sure the slots are unbound now
      (not (location-boundp (locf (slot-current-value (file-server site nil)))))
      (not (location-boundp (locf (slot-current-value (mail-server site nil)))))
      (not (location-boundp (locf (slot-current-value (namespace-server site nil)))))
      (not (location-boundp (locf (slot-current-value (domain-server site nil)))))
      ;; make sure the database stuff can't find anything
      (test-n-successes 0 [site-value-of (scrc file-server) quabbin])
      (test-n-successes 0 [site-value-of (scrc mail-server) elephant-butte])
      (test-n-successes 0 [site-value-of (scrc namespace-server) riverside])
      (test-n-successes 0 [site-value-of (scrc domain-server) pegasus])
      ;; flush the example we just made
      (prog1 t (kill site)))))

;;;
;;; A test of trigger-modelling.
;;;

(defvar *trigger-modelling-triggers* nil "Where trigger-modelling triggers go when they're hiding.")

(define-predicate-model trigger-modelling-model () ())

(define-predicate-method (locate-backward-rule-trigger trigger-modelling-model)
			 (truth-value continuation context rule-name)
  (declare (ignore truth-value context rule-name))
  (setq *trigger-modelling-triggers* (funcall continuation *trigger-modelling-triggers*)))

(define-predicate-method (map-over-backward-rule-triggers trigger-modelling-model) (continuation)
  (mapc continuation *trigger-modelling-triggers*))


(define-predicate trigger-modelling (arg) (trigger-modelling-model default-predicate-model))

(defrule trigger-modelling-rule (:backward)
  IF t
  THEN [trigger-modelling foo])

(deftest simple-trigger-modelling-test
  ;; test of simple trigger modelling.  Note that the 0 successes actually
  ;; tests for inheriting the correct POSITIONS-MATCHER-CAN-SKIP method.
  (test-n-successes 0 [trigger-modelling bar])
  (test-n-successes 1 [trigger-modelling foo]))

;;;
;;; Message received from HES:
;;; Could you see if this behaves in a real Joshua, I thought I once saw a
;;; compiler bug in the fact-step world:
;;;
;;; This works as of 8/20/87

(define-predicate fact (arg value)
		  (ask-rules-only-mixin default-protocol-implementation-model))

(defrule fact-ground (:backward)
  IF t
  THEN [fact 0 1]) 

(defrule fact-step (:backward)
  IF (when (> ?arg 0)
       ;; would do this differently if is-lisp-value were in the system.
       (ask `[fact ,(1- ?arg) ,?step-value]
	    #'(lambda (&rest ignore)
		(unify ?value (* ?step-value ?arg))
		(succeed))))
  THEN [fact ?arg ?value])

(deftest factorial-test
  ;; make sure you get 120, and only 120.
  (let ((first-iteration-p t))
    (ask [fact 5 ?what]
	 #'(lambda (&rest ignore)
	     (when (or (not first-iteration-p)
		       (not (numberp ?what))
		       (not (= ?what 120)))
	       (return-from factorial-test nil))))
    t))

;;;
;;; Benchmarking Joshua.
;;;

(defparameter *joshua-benchmarks* nil "List of benchmarks for Joshua.")

(defun philistine (&optional (benchmark-names *joshua-benchmarks*) (iterations 3)
			     (stream *standard-output*))
  ;; top-level driver for all Joshua benchmarks
  (loop with time and forward-rules and backward-rules and merge-count and successful-merge-count
	and semi-merge-count and match-count and successful-match-count and semi-match-count
	for benchmark-name in benchmark-names
	doing
    (loop with my-time and my-overhead-time	  
	  repeat iterations
	  for my-forward-rules          = ji:*forward-fire-count*
	  for my-backward-rules         = ji:*backward-fire-count*
	  for my-merge-count            = ji::*merge-count*
	  for my-successful-merge-count = ji::*successful-merge-count*
	  for my-semi-merge-count       = ji::*semi-merge-count*
	  for my-match-count            = ji::*match-count*
	  for my-successful-match-count = ji::*successful-match-count*
	  for my-semi-match-count       = ji::*semi-match-count*
	  doing (clear)
		(funcall (benchmark-initializer benchmark-name))
		(si:inhibit-gc-flips ;need something more complicated here.
		  (process:without-preemption
		    ;; get more reasonable numbers under a without-preemption
		    (setq my-time (get-internal-run-time))
		    (funcall benchmark-name)
		    (setq my-time (- (get-internal-run-time) my-time))))
		(process:without-preemption
		  ;; account for overhead of reading the clock
		  (setq my-overhead-time (get-internal-run-time)
			my-overhead-time (- (get-internal-run-time) my-overhead-time)))
		(setq my-forward-rules          (- ji:*forward-fire-count* my-forward-rules)
		      my-backward-rules         (- ji:*backward-fire-count* my-backward-rules)
		      my-merge-count            (- ji::*merge-count* my-merge-count)
		      my-successful-merge-count (- ji::*successful-merge-count* my-successful-merge-count)
		      my-semi-merge-count       (- ji::*semi-merge-count* my-semi-merge-count)
		      my-match-count            (- ji::*match-count* my-match-count)
		      my-successful-match-count (- ji::*successful-match-count* my-successful-match-count)
		      my-semi-match-count       (- ji::*semi-match-count* my-semi-match-count))
	  minimize (- my-time my-overhead-time) into my-total-time
	  summing my-forward-rules              into my-total-forward-rules
	  summing my-backward-rules             into my-total-backward-rules
	  summing my-merge-count                into my-total-merge-count
	  summing my-successful-merge-count     into my-total-successful-merge-count
	  summing my-semi-merge-count           into my-total-semi-merge-count
	  summing my-match-count                into my-total-match-count
	  summing my-successful-match-count     into my-total-successful-match-count
	  summing my-semi-match-count          into my-total-semi-match-count
	  finally
	    (setq time                   (/ my-total-time (float internal-time-units-per-second))
		  forward-rules          (/ my-total-forward-rules (float iterations))
		  backward-rules         (/ my-total-backward-rules (float iterations))
		  merge-count            (/ my-total-merge-count (float iterations))
		  successful-merge-count (/ my-total-successful-merge-count (float iterations))
		  semi-merge-count       (/ my-total-semi-merge-count (float iterations))
		  match-count            (/ my-total-match-count (float iterations))
		  successful-match-count (/ my-total-successful-match-count (float iterations))
		  semi-match-count       (/ my-total-semi-match-count (float iterations))))
	collecting (list time
			 forward-rules backward-rules
			 merge-count successful-merge-count semi-merge-count
			 match-count successful-match-count semi-match-count)
	  into data
	finally
	  (clear)
	  (formatting-table (stream)
	    (formatting-column-headings (stream :underline-p t)
	      (formatting-cell (stream :align :center) (princ "Benchmark" stream))
	      (formatting-cell (stream :align :center) (princ "|" stream)) ;vertical lines
	      (formatting-cell (stream :align :center) (princ "Time" stream))
	      (formatting-cell (stream :align :center) (princ "|" stream)) ;vertical lines
	      (formatting-cell (stream :align :center) (princ "FWD" stream))
	      (formatting-cell (stream :align :left)   (princ "Rules" stream))
	      (formatting-cell (stream :align :center) (princ "|" stream)) ;vertical lines
	      (formatting-cell (stream :align :center) (princ "BKWD" stream))
	      (formatting-cell (stream :align :left)   (princ "Rules" stream))
	      (formatting-cell (stream :align :center) (princ "|" stream)) ;vertical lines
	      (formatting-cell (stream :align :center) (princ "" stream)) ;matches succeeding
	      (formatting-cell (stream :align :center) (princ "" stream)) ;slash
	      (formatting-cell (stream :align :center) (princ "" stream)) ;matches attempted
	      (formatting-cell (stream :align :center) (princ "Matches" stream)) ;%matches succeeding
	      (formatting-cell (stream :align :center) (princ "" stream))  ;semi matches
	      (formatting-cell (stream :align :center) (princ "|" stream)) ;vertical lines
	      (formatting-cell (stream :align :center) (princ "" stream)) ;merges succeeding
	      (formatting-cell (stream :align :center) (princ "" stream)) ;slash
	      (formatting-cell (stream :align :center) (princ "" stream)) ;merges attempted
	      (formatting-cell (stream :align :center) (princ "Merges" stream))
	      (formatting-cell (stream :align :center) (princ "" stream)));semi merges
	    (loop for datum in data
		  for benchmark-name in benchmark-names
		  doing (formatting-row (stream)
			  (formatting-cell (stream :align :center)
			    ;; benchmark name
			    (princ benchmark-name stream))
			  (formatting-cell (stream :align :center) (princ "|" stream))
			  (formatting-cell (stream :align :right)
			    ;; elapsed time
			    (format stream "~,3F sec" (first datum)))
			  (formatting-cell (stream :align :center) (princ "|" stream))
			  (formatting-cell (stream :align :right)
			    ;; forward rules
			    (if (zerop (round (second datum)))
				(princ "-" stream)
				(princ (round (second datum)) stream)))
			  (formatting-cell (stream :align :right)
			    ;; forward rules/sec
			    (if (zerop (round (second datum)))
				(princ "-" stream)
				(format stream "(~,1F/sec)" (/ (second datum) (first datum)))))
			  (formatting-cell (stream :align :center) (princ "|" stream))
			  (formatting-cell (stream :align :right)
			    ;; backward rules
			    (if (zerop (round (third datum)))
				(princ "-" stream)
				(princ (round (third datum)) stream)))
			  (formatting-cell (stream :align :right)
			    ;; backward rules/sec
			    (if (zerop (round (third datum)))
				(princ "-" stream)
				(format stream "(~,1F/sec)" (/ (third datum) (first datum)))))
			  (formatting-cell (stream :align :center) (princ "|" stream))
			  (formatting-cell (stream :align :right)
			    ;; match successes
			    (if (zerop (round (seventh datum)))
				(princ "-" stream) ;no matches at all
				(princ (round (eighth datum)) stream)))
			  (formatting-cell (stream :align :center)
			    ;; slash
			    (unless (zerop (round (seventh datum)))
			      (princ #\/ stream)))
			  (formatting-cell (stream :align :right)
			    ;; match attempts
			    (if (zerop (round (seventh datum)))
				(princ "-" stream)
				(princ (round (seventh datum)) stream)))
			  (formatting-cell (stream :align :right)
			    ;; % matches succeeding
			    (if (zerop (round (seventh datum)))
				(princ "-" stream)
				(format stream "(~,2F%," (* (/ (eighth datum) (seventh datum)) 100.0))))
			  (formatting-cell (stream :align :right)
			    ;; semi matches
			    (if (zerop (round (seventh datum)))
				(princ "-" stream)
				(format stream "~D semi)" (round (ninth datum)))))
			  (formatting-cell (stream :align :center) (princ "|" stream))
			  (formatting-cell (stream :align :right)
			    ;; merge successes
			    (if (zerop (round (fourth datum)))
				(princ "-" stream)
				(princ (round (fifth datum)) stream)))
			  (formatting-cell (stream :align :center)
			    ;; slash
			    (unless (zerop (round (fourth datum)))
			      (princ #\/ stream)))
			  (formatting-cell (stream :align :right)
			    ;; merge attempts
			    (if (zerop (round (fourth datum)))
				(princ "-" stream)
				(princ (round (fourth datum)) stream)))
			  (formatting-cell (stream :align :right)
			    ;; % merges succeeding
			    (if (zerop (round (fourth datum)))
				(princ "-" stream)
				(format stream "(~,2F%," (* (/ (fifth datum) (fourth datum)) 100.0))))
			  (formatting-cell (stream :align :right)
			    ;; semi merges
			    (if (zerop (round (fourth datum)))
				(princ "-" stream)
				(format stream "~D semi)" (round (sixth datum))))))))))

(cp:define-command (com-benchmark-joshua :command-table "Global")
    ;; CP command to make it easy to benchmark Joshua
    ((benchmarks `((token-or-type (("All" :all))
				  ((sequence ((dw:member-sequence ,*joshua-benchmarks*))))))
		 :prompt "Sequence of Joshua benchmarks or All"
		 :default :all
		 :documentation "Which benchmarks to run")
     (iterations 'integer
		 :prompt "Number of iterations"
		 :default 3
		 :documentation "Number of times to run each benchmark, for averaging."))
   (when (eq benchmarks :all) (setq benchmarks *joshua-benchmarks*))
   (philistine benchmarks iterations))

(def-defining-form defbenchmark
   :definer
   ((name &key body initializer)
    ;; just run forms in the body
    `(progn (record-source-file-name ',name 'defbenchmark)
	    (pushnew ',name *joshua-benchmarks*)
	    (defun (:property ,name joshua-benchmark-initializer) ()
	      ,initializer)
	    (defun ,name ()
	      ,body)))
   :killer
   ((name)
    ;; how to undefine a Joshua benchmark
    (setq *joshua-benchmarks* (delete name *joshua-benchmarks*))
    (fundefine `(:property ,name joshua-benchmark-initializer))
    (fundefine name))
   :shower
   ((form)
    (let ((name (second form)))
      (cond ((not (symbolp name))
	     (zwei:barf "Mal-formed benchmark name: ~S" name))
	    ((member name *joshua-tests*)
	     (zwei:typein-line "~&Evaluating this will redefine the Joshua benchmark ~S." name))
	    (t
	      (zwei:typein-line
		"~&Evaluating this will define the Joshua benchmark ~S for the first time." name))))
    t)
   :type-name "Joshua Benchmark")

(defun benchmark-initializer (benchmark-name)
  (get benchmark-name 'joshua-benchmark-initializer))


;;;
;;; The actual benchmarks.
;;;

(define-predicate forward-lips (n)
		  (no-variables-in-data-mixin default-predicate-model))

(defrule simple-forward-lips (:forward)
  ;; just run this rule several times.
  ;; Measures rule lookup (depends on other rules in world!) and execution.  
  IF [and [forward-lips ?n]
	  ( ?n 0)]
  THEN `[forward-lips ,(1- ?n)])

(defbenchmark forward-benchmark
  ;; benchmark forward rule calling by counting down to 0
 :body (tell [forward-lips 50]))

(define-predicate backward-lips (n))

(defrule simple-backward-lips (:backward)
  IF (if (= ?n 0)
	 (succeed)
	 ;; wants is-lisp-value!
	 (ask `[backward-lips ,(1- ?n)] #'(lambda (ignore) (succeed))))
  THEN [backward-lips ?n])

(defbenchmark backward-benchmark
  ;; benchmark backward rule calling by counting down to 0
  :body (ask [backward-lips 50] #'ignore))

(defbenchmark ht-benchmark
  ;; benchmark the HT example
 :initializer (ht:describe-circuit)
 :body (ht:diagnose-circuit nil nil))

;;; (defbenchmark modelled-ht-benchmark
;;;   ;; benchmark the new HT example
;;;  :initializer (mht:describe-circuit)
;;;  :body (mht:diagnose-circuit nil nil))


(defbenchmark monkey-benchmark
  ;; benchmark the monkey & bananas
 :initializer (plan:initial-monkey-world)
 :body plan:(ask `[is-heuristic-plan-for [not [hungry monkey]] ?plan now]
	    #'ignore))

(defbenchmark blocks-benchmark
  ;; benchmark the blocks world
 :initializer plan:(debugging-blocks-world)
 :body (with-stack-overflows 1
	 plan:(ask `[is-plan-for [and [is-on baz bar] [is-on foo baz]] ?plan now]
		   #'ignore)))

(defbenchmark grampaw-benchmark
  ;; benchmark the grampaw frob
 :initializer (gramps:initial-grampaw)
 :body gramps:(progn (block foo
		       (ask [is-grandfather-of ?who ?who]
			    #'(lambda (ignore) (return-from foo))))
		     (block foo
		       (ask [is-grandmother-of ?who ?who]
			    #'(lambda (ignore) (return-from foo))))))

(defbenchmark midsummer-benchmark
  ;; benchmark the midsummer TMS example
 :initializer tme:(progn (tell [jealous Lysander] :justification :premise)
			 ;; Hermia and Lysander are an item
			 (tell [loves Hermia Lysander] :justification :premise)
			 (tell [loves Lysander Hermia] :justification :assumption)
			 ;; Here' some opportunity for unrequited love and jealousy-killings.
			 (tell [loves Helena Demetrius] :justification :premise))
 :body
  (condition-bind ((tms-contradiction
		     ;; have to handle the contradiction automatically, can't ask user.
		     #'(lambda (condition)
			 ;; make sure it's the contradiction we expect, and then handle it
			 ;; the way we want to.  (Note that 2 contradictions happen, only one
			 ;; of which is interesting.)
			 (let ((non-premises (tms-contradiction-non-premises condition))
			       (premises     (tms-contradiction-premises condition))
			       lysander-loves)
			   (flet ((check-justification-statement (justification statement)
				    ;; this is kludgery, having to admit there's a statement iv.
				    (multiple-value-bind (nil predication nil) (destructure-justification justification)
				      (equal (predication-statement predication) statement))))
			     (when (and (= (length non-premises) 2)
					(= (length premises)     1)
					(check-justification-statement
					  (first premises) 'tme:(jealous lysander))
					(setq lysander-loves
					      (find-if #'(lambda (x)
							   (check-justification-statement
							     x 'tme:(loves Lysander Hermia)))
						       non-premises))
					(find-if #'(lambda (x)
						     (check-justification-statement
						       x 'tme:(loves Demetrius Hermia)))
						 non-premises))
			       ;; this is the one we're looking for. (Let the system handle others.)
			       ;; We want to unjustify [loves Lysander Hermia], since that causes the
			       ;; most agitation.
			       (remove-justification lysander-loves)
			       (values :unjustify-subset lysander-loves)))))))
    tme:(tell [loves Demetrius Hermia] :justification :assumption)))

(defbenchmark cryptarithmetic-benchmark
  ;; benchmark the cryptarithmetic solver on Newell & Simon's example
 :initializer crypt:(create-cryptarithmetic-description "DONALD" "GERALD" "ROBERT" #'ignore)
 :body crypt:(solve-cryptarithmetic-problem 'donald 'gerald 'robert '((#\D . 5)) nil))

(defbenchmark tweety-benchmark
  ;; benchmark the Tweety TMS example
 :body tme:(Progn
	     (tell [bird tweety] :justification :premise)
	     (let ((penguin-statement (tell [penguin tweety] :justification :premise)))
	       (unjustify penguin-statement))))



;;;
;;; Make the actual program framework that responds to select-J.  This must be done after all the
;;; DEFDEMOS have been done, i.e., this is probably always in the last file of Jericho.
;;;

(dw:define-program-framework jericho-demo-suite
  :pretty-name "Jericho"
  :help "Demonstrate Joshua"
  :select-key #\J
  :system-menu t
  :inherit-from (jericho:joshua-demo-program)
  :top-level (jericho-top-level :unknown-accelerator-is-command t)
  :state-variables ((picture-cache nil))
  :command-definer t
  :command-table (:inherit-from '("Joshua-Demo-Program") :kbd-accelerator-p t)
  :other-defflavor-options (:readable-instance-variables
			     (:default-init-plist :title-string "Joshua's Jericho Demo Suite"))
  :panes ((interactor :interactor
		      :margin-components '((dw:margin-ragged-borders :thickness 1)
					   (dw:margin-scroll-bar :history-noun "interaction"))
		      :default-character-style '(:swiss :roman :normal)
		      :height-in-lines 4)
	  (display :display
		   :default-character-style '(:swiss :roman :normal)
		   :redisplay-function 'redisplay-picture
		   :incremental-redisplay t
		   :more-p nil
		   :typeout-window t
		   :margin-components `((dw:margin-ragged-borders :thickness 1)))
	  (title :title
		 :reverse-video-p t
		 :margin-components '((dw:margin-white-borders :thickness 0))
		 :default-character-style '(:dutch :bold :very-large)
		 :redisplay-function #'redisplay-joshua-demo-program-title
		 :height-in-lines 1
		 :redisplay-after-commands nil)
	  (widgetsim-demo-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'ju::widgetsim
	    :process nil
	    :margin-components ())
	  (ht-demo-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'ht:ht-demo
	    :process nil
	    :margin-components ())
	  (blocks-demo-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'plan:blocks-demo
	    :process nil
	    :margin-components ())
	  (modelling-tutor-demo-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'modelling-tutor:modelling-tutor 
	    :process nil
	    :margin-components ())
	  (n-queens-demo-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'tme:n-queens
	    :process nil
	    :margin-components ())
	  (cryptarithmetic-demo-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'crypt:cryptarithmetic
	    :process nil
	    :margin-components ()))
  :configurations
  '((introduction
      (:layout
	(introduction :column title display interactor))
      (:sizes
	(introduction (title 1 :lines)
		      (interactor 4 :lines)
		      :then
		      (display :even))))
    (widgetsim
      (:layout
	(widgetsim :column title widgetsim-demo-pane))
      (:sizes
	(widgetsim (title 1 :lines)
	       :then
	       (widgetsim-demo-pane :even))))
    (tutor
      (:layout
	(tutor :column title modelling-tutor-demo-pane))
      (:sizes
	(tutor (title 1 :lines)
	       :then
	       (modelling-tutor-demo-pane :even))))
    (queens
      (:layout
	(queens :column title n-queens-demo-pane))
      (:sizes
	(queens (title 1 :lines)
		:then
		(n-queens-demo-pane :even))))
    (ht
      (:layout
	(ht :column title ht-demo-pane))
      (:sizes
	(ht (title 1 :lines)
	    :then
	    (ht-demo-pane :even))))
    (blocks
      (:layout
	(blocks :column title blocks-demo-pane))
      (:sizes
	(blocks (title 1 :lines)
		:then
		(blocks-demo-pane :even))))
    (cryptarithmetic
      (:layout
	(cryptarithmetic :column title cryptarithmetic-demo-pane))
      (:sizes
	(cryptarithmetic (title 1 :lines)
			 :then
			 (cryptarithmetic-demo-pane :even))))))

(defmethod (jericho-top-level jericho-demo-suite) (&rest options)
  (ignore options)
  (let ((configuration (send dw:*program-frame* :configuration)))
    (dbg:with-default-bug-report-recipient-system ("Joshua")
      (loop
	(multiple-value-setq (*terminal-io* *query-io* *standard-output* *standard-input*)
	  (send dw:*program-frame* :terminal-streams))
	(unless (eq configuration (send dw:*program-frame* :configuration))
	  (send dw:*program-frame* :set-configuration configuration))
	(setq configuration
	      (catch 'change-of-configuration
		(let ((pane 
			(dw:get-program-pane
			      (ecase configuration
				(introduction 'interactor)
				(ht 'ht-demo-pane)
				(widgetsim 'widgetsim-demo-pane)
				(tutor 'modelling-tutor-demo-pane)
				(queens 'n-queens-demo-pane)
				(blocks 'blocks-demo-pane)
				(cryptarithmetic 'cryptarithmetic-demo-pane)))))
		  (send dw:*program-frame* :select-pane pane)
		  (if (eq configuration 'introduction)
		      (dw:default-command-top-level self :unknown-accelerator-is-command t)
		      (dw:program-frame-top-level pane)))))))))

(define-presentation-type jericho-configuration ()
   :expander 't) 

(defmethod (redisplay-joshua-demo-program-title jericho-demo-suite) (stream)
  ;; display the thing in the title pane
  (dw:with-output-as-presentation (:stream stream
				   :object 'com-change-configuration
				   :type 'jericho-configuration)
  (send stream :display-centered-string title-string)))


(define-presentation-action force-jericho-change-configuration
   (jericho-configuration
     cp:command					;any old comtab will do
     :tester ((object) (eql object 'com-change-configuration))
     :documentation "Change Configuration"
     :do-not-compose T
     )
   (object &key window)
  (program-force-jericho-change-configuration object window))

(define-jericho-demo-suite-command (com-choose-demo)
    ((configuration `((dw:alist-member :alist (("Introduction" . introduction)
					       ("Factory Simulation" . widgetsim)
					       ("Modelling Tutor" . tutor)
					       ("N Queens Solver" . queens)
					       ("Hardware Trouble Shooter" . ht)
					       ("Blocks World Planner" . blocks)
					       ("Cryptarithmetic Solver" . cryptarithmetic))))
		    :prompt "demo"
		    :documentation "which demo to run"))
   (throw 'change-of-configuration configuration)
   )

(defun program-force-jericho-change-configuration (command window)
  (ignore command)
  (let ((jericho-frame (loop for w = window then (tv:sheet-superior w)
			       do
			   (typecase w
			     ((dw:program-frame)
			      (when (typep (send w :program) 'jericho-demo-suite)
				(return w)))
			     ((tv:sheet) )
			     (otherwise (return nil))))))
    (when jericho-frame
      (let ((jericho-program (send jericho-frame :program)))
	(let ((dw:*program* jericho-program)
	      (dw:*program-frame* jericho-frame)
	      (cp:*command-table* (dw:program-command-table jericho-program))
	      (configuration (dw:menu-choose
			       '(("Introduction" . introduction)
				 ("Factory Simulation" . widgetsim)
				 ("Modelling Tutor" . tutor)
				 ("N Queens Solver" . queens)
				 ("Hardware Trouble Shooter" . ht)
				 ("Blocks World Planner" . blocks)
				 ("Cryptarithmetic Solver" . cryptarithmetic))
			       :prompt "Choose a Jericho Demo")))
	  (when configuration
	    (com-choose-demo configuration)))))))


(defun-in-flavor (draw-jericho-picture jericho-demo-suite) (&optional (*STANDARD-OUTPUT* *STANDARD-OUTPUT*))
  ;; This looks painful, but it was automatically generated by the graphics editor program, so relax.
  ;;
  ;;
  (GRAPHICS::WITH-SAVED-TRANSFORM
    (GRAPHICS::SET-STREAM-TRANSFORM '(1 0 0 1 0 -67))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(163 346 217 375 243 394 249 409 249 424) :thickness 2)
    (GRAPHICS::SET-STREAM-TRANSFORM '(1 0 0 1 48607/224 67677/224))
    (GRAPHICS:DRAW-ELLIPSE 0 0 64.03179 64.03179
			   :START-ANGLE 0.029216
			   :END-ANGLE 1.02927
			   :thickness 2
			   :FILLED NIL)
    (GRAPHICS::SET-STREAM-TRANSFORM '(1 0 0 1 0 -67))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(168.3346 339.18555 221.52594 369.64325 251.40985 381.64136
					   267.31177 378.79007 280.03705 370.84863)
				:THICKNESS 2)
    (GRAPHICS:DRAW-LINE 547 310 616 275)
    (GRAPHICS:DRAW-LINE 546 414 615 379)
    (GRAPHICS:DRAW-LINE 545 474 545 249 :THICKNESS 2)
    (GRAPHICS:DRAW-LINE 545 249 758 143 :THICKNESS 2)
    (GRAPHICS:DRAW-LINE 617 274 617 213)
    (GRAPHICS:DRAW-LINE 583 346 583 293)
    (GRAPHICS:DRAW-LINE 616 378 616 329)
    (GRAPHICS:DRAW-LINE 547 364 616 329)
    (GRAPHICS:DRAW-LINE 584 443 584 394)
    (GRAPHICS:DRAW-LINES #(545 473 548 473 548 473 549 474 550 474 550 474 551 474 551 474
			       553 474 554 474 554 474 555 473 555 473 556 471 556 471 557 470
			       557 470 559 469 559 468 560 467 561 467 561 465 562 465 562 464
			       562 464 563 463 563 463 565 462 565 461 565 461 566 459 566 459
			       567 458 567 458 568 457 568 456 568 456 569 455 569 455 569 453
			       571 452 571 452 571 451 571 451 571 450 572 450 572 449 572 449
			       573 449 573 449 574 447 575 447 577 446 578 446 578 446 579 446
			       579 446 580 446 580 446 581 446 583 445 583 445 584 445 585 444
			       585 444 586 444 586 444 586 443 587 443 587 441 589 441 589 440
			       590 440 590 440 591 439 591 439 591 438 592 437 593 435 595 435
			       596 433 596 432 597 432 597 431 597 431 598 428 601 427 601 426
			       602 425 602 425 603 423 603 422 603 422 604 422 604 420 605 420
			       607 419 607 419 607 417 608 416 608 415 608 415 609 414 609 413
			       609 413 609 411 609 411 609 410 609 408 610 408 610 407 610 407
			       610 405 610 405 610 404 610 403 610 402 610 402 610 401 611 399
			       611 398 613 397 614 395 614 393 615 393 615 392 615 392 617 391
			       617 390 619 389 621 386 622 385 626 383 627 383 627 383 628 381
			       628 380 629 380 631 378 633 375 635 373 635 373 638 371 639 369
			       640 368 641 368 643 367 644 366 645 365 647 363 649 363 651 362
			       653 360 653 359 655 359 655 359 656 357 656 356 656 355 656 354
			       657 353 657 350 658 347 659 344 659 343 661 342 661 341 662 339
			       662 338 663 337 664 336 665 333 667 332 667 331 669 330 674 329
			       676 329 676 329 677 329 679 327 681 327 682 326 682 326 685 325
			       686 325 687 324 689 321 699 320 699 320 701 318 703 317 704 315
			       705 314 706 313 709 311 711 308 712 307 713 307 713 306 715 305
			       716 303 718 301 719 299 721 296 722 295 723 286 725 276 727 276
			       736 275 746 274 751 274 752 272 753 271 754 270 755 268 755 266
			       757 265 759 264 759 264 760 264 760 263 764 260 764 260 766 258
			       767 257 767 256 767 256 769 254 769 253 770 252 770 251 771 250
			       773 248 773 247 773 246 775 245 776 245 777 244 778 242 779 241
			       779 241 781 240 782 239 782 239 783 238 783 238 783 236 784 235
			       785 235 787 234 788 234 788 234 788 233 789 233 789 233 789 232
			       790 232 790 232 791 232 791 232 791 230 793 230)
			 :THICKNESS 2)
    (GRAPHICS:DRAW-LINES #(544 474 544 474 545 475 545 475 547 476 548 476 549 477 549 477
			       550 477 551 477 551 479 553 479 555 479 556 479 556 479 557 479
			       557 479 560 479 560 479 562 479 563 479 565 479 565 479 566 479
			       567 479 567 479 568 477 569 476 569 476 571 476 573 476 573 476
			       574 476 575 476 575 476 577 476 579 476 581 476 581 476 583 477
			       583 479 584 479 586 480 587 480 587 481 587 481 590 481 591 481
			       592 482 593 482 597 482 599 482 602 482 603 482 604 482 604 482
			       608 482 609 483 619 483 623 483 633 483 638 485 643 485 644 486
			       645 486 645 487 647 488 647 488 649 489 650 489 651 489 652 491
			       655 492 657 493 657 493 657 494 658 494 658 494 659 495 661 495
			       662 495 662 495 667 497 667 497 668 497 670 497 670 497 671 497
			       675 497 677 498 679 498 681 498 682 498 683 498 686 499 687 499
			       687 500 689 501 689 501 691 503 692 505 693 506 694 509 697 510
			       699 515 699 516 699 516 700 516 700 516 701 517 703 517 706 517
			       707 517 711 519 713 521 714 521 716 522 730 522 735 522 749 523
			       754 523 754 524 778 524 778 524 783 524 783 524 784 524 784 524
			       785 524 785 524 788 524 788 525 789 525 789 525 790 527 790 528
			       792 529 795 531 796 533 798 534 801 536 802 536 802 537 802 537
			       803 537 803 537 803 539 806 540 808 541 808 541 809 542 809 542
			       810 542 812 542 813 542 813 542 815 542 815 543 816 543 818 543
			       819 543 819 545 820 545 820 545 821 545 821 545 821 546 821 546)
			 :THICKNESS 2)
    (GRAPHICS:DRAW-LINES #(625 450 625 450 627 449 628 449 629 449 631 449 633 449 634 449
			       635 449 638 449 639 449 639 449 640 449 641 449 641 449 643 450
			       645 451 645 451 646 451 647 452 647 452 649 452 650 452 650 453
			       650 453 651 453 653 453 655 453 656 453 657 453 658 455 659 455
			       663 456 664 456 664 457 667 457 668 457 669 457 670 457 671 457
			       673 458 674 458 675 458 676 458 679 459 680 459 680 459 682 461
			       683 461 686 462 687 462 687 463 688 463 689 464 690 465 693 467
			       694 467 696 468 698 468 699 469 700 469 700 469 701 470 702 470
			       702 470 704 471 705 471 706 471 707 471 708 471 710 473 711 473
			       712 474 712 474 713 475 714 476 714 477 714 477 714 480 716 480
			       716 481 716 483 716 485 716 486 717 486 717 487 717 488 717 488
			       718 489 718 489 719 491 720 491 722 491 724 492 724 492 725 492
			       726 492 728 493 730 493 731 493 731 493 734 493 735 493 736 494
			       738 494 740 494 741 494 742 495 746 495 747 495 748 495 749 497
			       752 497 753 497 754 497 755 498 766 498 771 498 776 498 785 499
			       790 499 790 500 791 500 792 500 794 501 795 501 796 501 796 503
			       797 503 797 503 798 503 800 503 800 504 802 505 802 505 803 505
			       804 506 806 507 807 507 808 509 808 509 809 510 809 511 810 511
			       812 512 812 512 813 513 814 513 815 516 816 516 816 516 819 518
			       819 518 820 519 821 521 821 521 822 522 822 522 824 522 825 522
			       826 523 826 523 828 523 830 523 831 523 832 524 833 524 833 524
			       834 524 836 524 837 524 837 524 839 524 839 524 840 524 842 525
			       842 525 843 525)
			 :THICKNESS 2)
    (GRAPHICS:DRAW-LINES #(627 449 627 449 627 447 628 446 628 446 628 445 629 445 629 445
			       630 445 630 444 630 444 632 443 633 443 633 441 633 441 634 441
			       634 440 634 439 635 439 635 438 635 438 636 437 636 435 638 435
			       640 434 641 433 642 433 644 432 645 431 646 431 646 429 647 429
			       647 429 648 428 650 427 650 426 650 426 651 425 651 423 651 423
			       651 422 651 421 651 420 651 420 651 419 651 417 651 417 651 416
			       651 415 651 415 651 414 652 413 652 413 652 411 652 410 652 409
			       652 409 652 407 652 405 652 405 653 403 653 403 653 402 654 401
			       654 401 656 401 656 399 656 399 657 399 657 399 657 398 658 398
			       658 397 659 397 660 397 660 396 660 396 662 395 662 395 663 395
			       664 393 665 393 665 392 668 391 668 391 669 391 669 390 670 390
			       670 389 671 389 674 387 674 387 675 387 675 386 676 386 676 386
			       677 385 677 385 677 384 677 383 677 381 678 381 678 380 678 378
			       680 378 680 377 681 375 682 375 682 375 683 374 684 374 684 374
			       686 373 686 373 687 372 687 371 687 369 687 368 687 368 687 366
			       687 365 687 365 687 363 687 362 687 361 687 361 687 360 687 359
			       688 359 688 357 688 357 689 356 689 356 689 354 690 354 690 354
			       692 353 692 351 693 350 695 349 695 348 695 348 696 348 700 344
			       701 344 702 343 704 343 705 343 705 342 706 342 706 342 707 342
			       710 342 710 342 712 341 713 339 714 339 716 338 716 338 717 337
			       718 336 718 336 719 335 719 335 720 333 720 333 722 333 723 332
			       723 332 724 332 724 331 725 331 726 331 728 330 729 330 729 329
			       730 329 730 327 731 327 731 326 732 325 732 324 732 324 734 323
			       734 321 734 320 735 319 736 319 736 318 736 317 737 315 737 315
			       738 314 738 313 738 312 738 311 738 309 740 309 740 308 740 307
			       741 307 741 307 741 306 742 305 742 303 743 303 744 301 746 301
			       747 301 747 300 747 300 748 299 749 297 749 296 751 296 751 296
			       751 295 754 294 755 294 755 293 756 293 757 291 759 291 761 291
			       762 291 763 291 765 291 766 291 766 291 767 290 768 290 769 290
			       771 290 771 289 772 289 772 288 773 287 774 287 775 285 777 285
			       778 284 779 283 780 282 780 282 781 282 781 281 783 279 785 277
			       785 277 786 276 786 275 787 273 789 272 789 272 789 271 790 270
			       790 269 791 267 792 266 793 265 793 265 796 264 796 263 797 261
			       798 261 798 260 799 259 801 258 801 258 802 257 803 257 805 255
			       805 255 807 254 808 254 809 254 810 254)
			 :THICKNESS 2)
    (GRAPHICS:DRAW-LINE 588 444 627 449)
    (GRAPHICS:DRAW-LINE 666 497 698 470)
    (GRAPHICS:DRAW-LINE 641 387 661 396)
    (GRAPHICS:DRAW-LINE 681 308 681 259)
    (GRAPHICS:DRAW-LINE 681 309 723 290)
    (GRAPHICS:DRAW-LINE 682 258 753 222)
    (GRAPHICS:DRAW-LINE 722 294 743 302)
    (GRAPHICS:DRAW-LINE 755 222 755 265)
    (GRAPHICS:DRAW-LINES #(755 269 755 269 755 271 755 271 757 272 758 272 759 274 759 274
			       760 274 760 275 760 275 761 276 764 280 765 278 765 277 766 276
			       766 275 767 275 770 275 771 275 773 276 773 276 773 277 775 278
			       776 278 778 281 779 281 781 282))
    (GRAPHICS:DRAW-LINE 729 414 729 367)
    (GRAPHICS:DRAW-LINE 820 443 820 396)
    (GRAPHICS:DRAW-LINE 729 414 820 443)
    (GRAPHICS:DRAW-LINE 729 368 820 397)
    (GRAPHICS:DRAW-LINE 737 322 840 359 :THICKNESS 2)
    (GRAPHICS:DRAW-LINE 698 468 698 434)
    (GRAPHICS:DRAW-LINE 698 433 652 420)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(355 265 451 299 542 313) :THICKNESS 3)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(246 304 340 266 445 234) :THICKNESS 3)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(0 289 31 300 71 307) :THICKNESS 3)
    (GRAPHICS:DRAW-PATH #'(LAMBDA (*STANDARD-OUTPUT*)
			    (GRAPHICS:DRAW-LINES #(245 385 245 385 243 384 243 383 241 383
						       240 383 240 382 239 382 239 381 239 379
						       239 378 239 377 238 377 246 375 247 376
						       252 376 253 377 253 378 255 378 255 378
						       256 379 256 381 255 381 253 382 252 382
						       252 383 251 383 251 383 251 384 250 384
						       250 385 249 385 247 385 247 385 246 385
						       245 385 245 387 244 387 244 387 244 385
						       244 384 244 385)))
			:opaque t
			:gray-level 0)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(131 368 168 354 175 335))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(123 362 150 359 159 326 161 312))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(124 359 144 344 148 319 147 310))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(120 360 135 333 135 302))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(118 350 107 329 110 306))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(116 360 93 336 95 312 97 304))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(114 366 84 346 89 314))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(99 365 71 340 62 316))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(116 370 71 360 56 329))
    (GRAPHICS:DRAW-CUBIC-SPLINE #(184 288 234 299 234 299 275 342 275 342 246 387 246 387
				      211 325 211 325 183 318 183 318 148 313)
				:THICKNESS 2)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(208 99 189 191 183 289) :THICKNESS 2)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(41 89 76 102 71 67 71 67 112 98 120 74 120 74 146 97 171 91 208 99)
				:THICKNESS 2)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(41 92 52 133 40 124 39 123 63 177 83 276) :THICKNESS 2)
    (GRAPHICS:DRAW-CUBIC-SPLINE #(83 276 61 210 49 190 48 189 21 196 31 221 19 214 19 214 33
				     239 54 275 66 299 66 299 102 307)
				:THICKNESS 2))) 

(defmethod (encache-picture jericho-demo-suite) (&optional force-p)
  ;; draw the picture in a bitmap, and cache it
  (when (or force-p
	    (not (arrayp picture-cache)))
    ;; want to redraw it
    (setq picture-cache
	  (tv:with-output-to-bitmap (stream )
	    (draw-jericho-picture stream)))))

(defmethod (make-instance jericho-demo-suite :after) (&rest ignore)
  (encache-picture self :force))

(defmethod (redisplay-picture jericho-demo-suite) (stream)
  ;; redisplay the initial display pane
  (flet ((draw-logo (stream)
	   ;; draw the symbolics logo in boxes
	   (terpri stream)
	   (centering-output (stream :vertically-p nil)
	     (surrounding-output-with-border (stream)
	       (surrounding-output-with-border (stream)
		 (dw::centering-lines (stream)
		   (with-character-style ('(:eurex :italic :huge) stream)
		     (terpri stream)
		     (princ " symbolics jericho " stream))
		   (with-character-style ('(:swiss :italic :large) stream)
		     (terpri stream)
		     (terpri stream)
		     (princ " A Joshua test, benchmark, and demo suite " stream))
		   (terpri stream)
;;; It is claimed that various people are offended by this.  O tempora, o mores.
;		   (terpri stream)
;		   (princ " ``And Joshua burnt Ai, and made it an heap forever, " stream)
;		   (terpri stream)
;		   (princ " even a desolation unto this day.'' -- Joshua 8:28, KJV " stream)
		   )))))
	 (draw-picture (stream)
	   ;; draw the funky picture
	   (encache-picture self)
	   (centering-output (stream)
	     (graphics:with-room-for-graphics (stream (send stream :inside-height)
						      :fresh-line nil :move-cursor nil)
	       (graphics:draw-image picture-cache 0 0
				    :scale (float (min 1.
						       (/ (send stream :inside-width)
							  (array-dimension picture-cache 1))
						       (/ (send stream :inside-height)
							  (array-dimension picture-cache 0))))
				    :stream stream)))
	  ))
    (dw:with-redisplayable-output (:stream stream
				   :unique-id 'jericho-picture
				   :cache-value t) ;no state
      (let ((stream-width  (send stream :inside-width))
	    (stream-height (send stream :inside-height)))
	(multiple-value-bind (ignore logo-height) (dw:continuation-output-size #'draw-logo stream)
	  ;; draw the symbolics/joshua logo
	  (draw-logo stream)
	  ;; draw the funky picture
	  (dw:in-sub-window (stream 0 logo-height stream-width (- stream-height logo-height 1))
	    ;; kludge up the height by 1 pixel above
	    (draw-picture stream)))))))
       
(cp:define-command (com-demonstrate-Joshua :command-table "Global"
					   :provide-output-destination-keyword nil)
    ()
   ;; make it easy to get here from a Lisp Listener.
   (dw:find-and-select-program-window 'jericho-demo-suite))


;;;
;;; Commands used in all demos, usually secret.
;;;

(define-jericho-demo-suite-command (eval-form)
    ;; an escape hatch to eval forms while debugging the Joshua Demo frame
    ((form 'sys:form
	   :prompt "form"
	   :documentation "form to evaluate"
	   :confirm t))
   (prin1 (eval form) (dw:get-program-pane 'demo-interactor)))

(define-jericho-demo-suite-command (refresh-screen)
			   ()
   ;; refresh the exposed panes (and just the exposed ones)
   (loop for pane in (send dw:*program-frame* :exposed-inferiors)
	 doing (send pane :refresh)))

(define-jericho-demo-suite-command (com-clear-history)
			   ()
  ;; clear the history (*terminal-io* is on some typeout-window, for some reason)
  ;; interaction is going on *query-io*.
  (send *query-io* :clear-history))




;;;
;;; Compile away.
;;;

(compile-flavor-methods jericho-demo-suite)
