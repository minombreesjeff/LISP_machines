;;; -*- Mode: LISP; Base: 10; Syntax: Joshua; Package: JOSHUA-INTERNALS; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Presentation types and supporting functions

;;; is it a rule?
0(defun joshua-rule-p (symbol)
  (and (symbolp symbol)
       (get symbol 'rule-debug-info)))

1;;; first the p-types for rules
0(defun forward-rule-test-p (symbol)
  (let ((debug-info (get symbol 'rule-debug-info)))
    (and debug-info
	 (eq :forward (rule-debug-info-control debug-info)))))

1;;; is it a backward rule
0(defun backward-rule-test-p (symbol)
  (let ((debug-info (get symbol 'rule-debug-info)))
    (and debug-info
	 (eq :backward (rule-debug-info-control debug-info)))))

1;;; Note the serious dwiming of rules that are in multiple packages
0(define-presentation-type forward-rule ()
   :abbreviation-for '(and rule (satisfies forward-rule-test-p))
   :history t
   :description "a forward rule"
   :parser ((stream &key original-type initially-display-possibilities)
	    (labels ((same-name-p (x y)
		       (equal (symbol-name x)
			      (symbol-name y)))
		     (duplicated-p (x)
		       (member x (cdr (member x *forward-rules* :test #'same-name-p))
			       :test #'same-name-p)))
	      (values
		(dw:complete-from-sequence
		  *forward-rules* stream
		  :name-key
		  #'(lambda (x)
		      (if (and (duplicated-p x)
			       (not (eq (symbol-package x) *package*)))
			  (format nil "~s" x)
			  (string x)))
		  :type original-type
		  :initially-display-possibilities
		  initially-display-possibilities))))
   :printer ((rulename stream)
	     (princ rulename stream)))

(define-presentation-type backward-rule ()
   :abbreviation-for '(and rule (satisfies backward-rule-test-p))
   :history t
   :description "a backward rule"
   :parser ((stream &key original-type initially-display-possibilities)
	    (labels ((same-name-p (x y)
		       (equal (symbol-name x)
			      (symbol-name y)))
		     (duplicated-p (x)
		       (member x (cdr (member x *backward-rules* :test #'same-name-p))
			       :test #'same-name-p)))
	      (values
		(dw:complete-from-sequence
		  *backward-rules* stream
		  :name-key
		  #'(lambda (x)
		      (if (and (duplicated-p x)
			       (not (eq (symbol-package x) *package*)))
			  (format nil "~s" x)
			  (string x)))
		  :type original-type
		  :initially-display-possibilities
		  initially-display-possibilities))))
   :printer ((rulename stream)
	     (princ rulename stream)))


(define-presentation-type rule ()
   1;; I can't use or forward-rule,backward rule here because the handlers won't apply 
0   1;; correctly
0   :abbreviation-for '(and symbol (satisfies joshua-rule-p))
   :history t
   :description "a Joshua rule"
   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (accept '(or forward-rule backward-rule)
		      :stream stream
		      :history 'rule
		      :original-type original-type
		      :initially-display-possibilities initially-display-possibilities)))
   :printer ((rulename stream)
	     (princ rulename stream)))

(defun joshua-protocol-function-p (symbol)
  (or (protocol-internal-name symbol)
      (protocol-external-name symbol)))

(define-presentation-type protocol-function ()
      :abbreviation-for '(and symbol (satisfies joshua-protocol-function-p))
      :description "a Joshua protocol function name"
      :history t
      :parser ((stream &key original-type initially-display-possibilities)
	       (values
		 (protocol-internal-name 
		   (dw::complete-input-from-symbol-set
		     stream
		     *joshua-protocol-functions*
		     original-type
		     initially-display-possibilities))))
      :printer ((obj stream)
		(princ (protocol-external-name obj) stream)))

(define-presentation-type database-predication-presentation (() &key (print-truth-value t))
   :description "a predication from the database"
   :abbreviation-for '(and predication-presentation (satisfies has-been-in-database-p))
   :parser ((stream)
	    (loop do (dw:read-char-for-accept stream)
		     (sys:parse-ferror "Use the mouse to select a database predication")))
   :printer ((obj stream)
	     (let ((*print-predication-top-level-p* print-truth-value))
	       (princ obj stream))))

(defun print-database-predication-without-truth-value (database-predication
						       &optional (stream *standard-output*))
  (present database-predication '((database-predication-presentation) :print-truth-value nil)
	   :stream stream))

(defun predication-read-error (error-object)
  (sys:parse-ferror "~\\presentation\\" error-object))

(define-presentation-type predication-presentation ()
   :history t
   :description "a predication"
   :parser ((stream &key original-type initially-display-possibilities default)
	    (condition-bind ((error 'predication-read-error))
	      (let ((first-char (let ((dw::*accept-blip-chars* nil))
				  (dw:peek-char-for-accept stream t))))
		(when (or (dw:compare-char-for-accept first-char #\)
			  (dw:compare-char-for-accept first-char #\?)
			  (dw:compare-char-for-accept first-char #\))
		  (dw:read-char-for-accept stream)))
	      (let* ((*readtable* *joshua-readtable*)
		     (form (accept '((sys:form) :edit-trivial-errors-p nil)
				   :history 'predication-presentation
				   :default default
				   :prompt nil
				   :stream stream
				   :original-type original-type
				   :initially-display-possibilities
				     initially-display-possibilities)))
	1	;; Is this diseased or what?
0		(cond ((and (consp form)
			    (eq (car form) 'predication-maker))
		       (values (eval form) 'predication-presentation))
		      ((predicationp form)
		       (values (eval form) 'predication-presentation))
		      (t (error "~s is not a Joshua Predication" form))))))
   :printer ((obj stream)
	     (let ((*print-predication-top-level-p* nil))
	       (princ obj stream)))
   :typep ((object)
	   (typep object 'predication)))

;;; Yaaagh!  Avoid stupid quotes.
(define-presentation-translator predication-identity
   (predication-presentation predication-presentation
    :priority 2)		;beat out expression-identity
   (predication)
  (values predication 'predication-presentation
	  :dont-quote t))

(define-presentation-type tms-predication-presentation ()
   :description "A TMS predication"
   :abbreviation-for '(and predication-presentation (satisfies nontrivial-tms-p)))
   

(define-presentation-type truth-value ()
   :description "a truth value"
   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (accept `(alist-member
			 :alist
			 (("true" . ,*true*)
			  ("false" . ,*false*)
			  ("unknown" . ,*unknown*)
			  ("contradictory" . ,*contradictory*)))
		      :stream stream
		      :prompt nil
		      :history nil
		      :original-type original-type
		      :initially-display-possibilities initially-display-possibilities)))
   :printer ((obj stream)
	     (princ 
	       (select obj
		 (*true* "true")
		 (*false* "false")
		 (*unknown* "unknown")
		 (*contradictory* "contradictory"))
	       stream)))

(define-presentation-type tracing-event (() &key (name :pretty-name))
   :no-deftype t
   :history t
   :description "a tracing event"
   :parser ((stream &key original-type initially-display-possibilities)
	    (accept `(alist-member :alist
				   ,(get-events-alist *joshua-debugger*))
		:stream stream
		:prompt nil
		:history 'tracing-event
		:original-type original-type
		:initially-display-possibilities initially-display-possibilities))
   :printer ((object stream)
	     (princ (ecase name
		      (:pretty-name (tracing-event-pretty-name object))
		      (:name (tracing-event-name object))
		      (:short-name (tracing-event-short-name object))
		      (:active-name (tracing-event-active-name object)))
		    stream)))

(define-presentation-type trigger-list ()
   :description "a list of rule triggers"
   :printer ((obj stream)
	     (princ obj stream)))

(define-presentation-translator ptrans-trigger-list-identity 
   (trigger-list
     sys:form)
   (list)
  `(quote ,list))

1;;; P-type for predicates
0(defun joshua-predicate-p (predicate-name)
  (and (typep predicate-name '(and symbol (not null)))
       (flavor:find-flavor predicate-name nil)
       (or (gethash predicate-name *all-predicates*)
	   (member predicate-name *models*))))

1;;; I wish there was a more efficient way to do this - perhaps define-predicate
;;; should maintain a table of predicates.
0(define-presentation-type joshua-predicate ()
   :abbreviation-for '((and symbol ((satisfies joshua-predicate-p))))
   :description "a Joshua predicate name"
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (values 
	      (dw:completing-from-suggestions
		(stream
		  :initially-display-possibilities initially-display-possibilities
		  :type type)
		(loop for ignore-this being the hash-elements of *all-predicates* with-key predicate
		      do (ignore ignore-this)
			 (dw:suggest (symbol-name predicate) predicate))
		(loop for model in *models* do
		  (dw:suggest (symbol-name model) model)))))
   :printer ((obj stream)(princ obj stream)))

(defun tms-predicate-p (predicate)
  (and (joshua-predicate-p predicate)
       (subtypep predicate 'basic-tms-mixin)))

(define-presentation-type tms-predicate ()
   :abbreviation-for '((and joshua-predicate ((satisfies tms-predicate-p))))
   :description "a Joshua TMS predicate"
   :parser ((stream &key initially-display-possibilities)
	    (values 
	      (dw:complete-from-sequence
		(cons 'basic-tms-mixin (flavor:flavor-all-dependents
					 (flavor:find-flavor 'basic-tms-mixin)))
		stream
1;0		original-type
		:initially-display-possibilities initially-display-possibilities)))
   :printer ((obj stream)(princ obj stream)))  

1;;; Some translators0 
1;;; First the translators for rules

;;;tracing and untracing forward rules
0(define-presentation-to-command-translator ptrans-forward-to-trace-rule
   (forward-rule
     :gesture nil
     :documentation "Trace this forward rule"
     :tester ((rule &rest ignore)
	      (tracable-forward-rule-p *joshua-debugger* rule)))
   (rule)
  `(com-joshua-trace rule ,rule
		     :tracing-options
		     (add-trace-forward-rule
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'forward-rule-tracer))))

(define-presentation-to-command-translator ptrans-forward-to-untrace-rule
   (forward-rule
     :gesture nil
     :documentation "Untrace this forward rule"
     :tester ((rule &rest ignore)
	      (untracable-forward-rule-p *joshua-debugger* rule)))
   (rule)
  `(com-joshua-trace rule ,rule
		     :tracing-options
		     (untrace-forward-rule
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'forward-rule-tracer))))

1;;; Tracing and untracing backward rules
0(define-presentation-to-command-translator ptrans-backward-to-trace-rule
   (backward-rule
     :gesture nil
     :documentation "Trace this backward rule"
     :tester ((rule &rest ignore)
	      (tracable-backward-rule-p *joshua-debugger* rule)))
   (rule)
  `(com-joshua-trace rule ,rule
		     :tracing-options
		     (add-trace-backward-rule
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'backward-rule-tracer))))

(define-presentation-to-command-translator ptrans-backward-to-untrace-rule
   (backward-rule
     :gesture nil
     :documentation "Untrace this backward rule"
     :tester ((rule &rest ignore)
	      (untracable-backward-rule-p *joshua-debugger* rule)))
   (rule)
  `(com-joshua-trace rule ,rule
		     :tracing-options
		     (untrace-backward-rule
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'backward-rule-tracer))))

1;;;showing the rule source
0(define-presentation-to-command-translator ptrans-rule-to-show-rule-source
   (rule
     :gesture :middle
     :priority 1 ;;needs to override the Show Functions Arguments translator 
     :documentation "Show the definition for this rule")
   (rule-name)
  `(com-show-rule-source (,rule-name)))

1;;; Translators for predicate flavors 
0(define-presentation-to-command-translator ptrans-joshua-predicate-to-trace-predicate
   (joshua-predicate
     :gesture nil
     :documentation "Trace predications of this flavor"
     :tester ((predicate &rest ignore)
	      (tracable-predicate-p *joshua-debugger* predicate))
     )
   (predicate)
  `(com-joshua-trace joshua-predicate ,predicate :tracing-options
		     (add-trace-predicate
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'predication-tracer))))


(define-presentation-to-command-translator ptrans-joshua-predicate-to-untrace-predicate
   (joshua-predicate
     :gesture nil
     :documentation "Untrace predications of this flavor"
     :tester ((predicate &rest ignore)
	      (untracable-predicate-p *joshua-debugger* predicate))
     )
   (predicate)
  `(com-joshua-trace joshua-predicate ,predicate :tracing-options
		     (untrace-predicate
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'predication-tracer))))

(define-presentation-to-command-translator ptrans-tms-predicate-to-trace-predicate
   (tms-predicate
     :gesture nil
     :documentation "Trace TMS operations on predications of this flavor"
     :tester ((predicate &rest ignore)
	      (tracable-tms-predicate-p *joshua-debugger* predicate))
     )
   (predicate)
  `(com-joshua-trace joshua-predicate ,predicate :tracing-options
		     (add-trace-predicate
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'TMS-tracer))))


(define-presentation-to-command-translator ptrans-tms-predicate-to-untrace-predicate
   (tms-predicate
     :gesture nil
     :documentation "Untrace TMS operations on predications of this flavor"
     :tester ((predicate &rest ignore)
	      (untracable-tms-predicate-p *joshua-debugger* predicate))
     )
   (predicate)
  `(com-joshua-trace joshua-predicate ,predicate :tracing-options
		     (untrace-predicate
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'TMS-tracer))))


1;;; And the translators for predications
0(define-presentation-to-command-translator ptrans-predication-to-trace-forward-rule-trigger
   (predication-presentation
     :gesture nil
     :documentation "Trace forward rules triggered by predications matching this pattern"
     :tester ((predication &rest ignore)
	      (tracable-forward-rule-trigger-p *joshua-debugger* predication))
     )
   (predication)
  `(com-joshua-trace predication ,predication :tracing-options
		     (add-trace-forward-rule-trigger 
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'forward-rule-tracer))))

(define-presentation-to-command-translator ptrans-predication-to-untrace-forward-rule-trigger
   (predication-presentation
     :gesture nil
     :documentation "Untrace forward rules triggered by predications matching this pattern"
     :tester ((predication &rest ignore)
	      (untracable-forward-rule-trigger-p *joshua-debugger* predication))
     )
   (predication)
  `(com-joshua-trace predication ,predication :tracing-options
		     (untrace-forward-rule-trigger 
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'forward-rule-tracer))))

(define-presentation-to-command-translator ptrans-predication-to-trace-backward-rule-trigger
   (predication-presentation
     :gesture nil
     :documentation "Trace backward rules triggered by predications matching this pattern"
     :tester ((predication &rest ignore)
	      (tracable-backward-rule-trigger-p *joshua-debugger* predication))
     )
   (predication)
  `(com-joshua-trace predication ,predication :tracing-options
		     (add-trace-backward-rule-trigger 
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'backward-rule-tracer))))

(define-presentation-to-command-translator ptrans-predication-to-untrace-backward-rule-trigger
   (predication-presentation
     :gesture nil
     :documentation "Untrace backward rules triggered by predications matching this pattern"
     :tester ((predication &rest ignore)
	      (untracable-backward-rule-trigger-p *joshua-debugger* predication))
     )
   (predication)
  `(com-joshua-trace predication ,predication :tracing-options
		     (untrace-backward-rule-trigger 
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'backward-rule-tracer))))

(define-presentation-to-command-translator ptrans-predication-to-trace-predication
   (predication-presentation
     :gesture nil
     :documentation "Trace all predications matching this pattern"
     :tester ((predication &rest ignore)
	      (tracable-predication-p *joshua-debugger* predication))
     )
   (predication)
  `(com-joshua-trace predication ,predication :tracing-options
		     (add-trace-pattern
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'predication-tracer))))

(define-presentation-to-command-translator ptrans-predication-to-untrace-predication
   (predication-presentation
     :gesture nil
     :documentation "Untrace all predications matching this pattern"
     :tester ((predication &rest ignore)
	      (untracable-predication-p *joshua-debugger* predication))
     )
   (predication)
  `(com-joshua-trace predication ,predication :tracing-options
		     (untrace-pattern
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'predication-tracer))))

(define-presentation-to-command-translator ptrans-tms-predication-to-trace-tms-predication
   (tms-predication-presentation
     :gesture nil
     :documentation "Trace TMS operations on predications matching this pattern"
     :tester ((tms-predication &rest ignore)
	      (tracable-tms-predication-p *joshua-debugger* tms-predication))
     )
   (tms-predication)
  `(com-joshua-trace predication ,tms-predication :tracing-options
		     (add-trace-pattern
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'TMS-tracer))))

(define-presentation-to-command-translator ptrans-tms-predication-to-untrace-tms-predication
   (tms-predication-presentation
     :gesture nil
     :documentation "Untrace TMS operations on predications matching this pattern"
     :tester ((tms-predication &rest ignore)
	      (untracable-tms-predication-p *joshua-debugger* tms-predication))
     )
   (tms-predication)
  `(com-joshua-trace predication ,tms-predication :tracing-options
		     (untrace-pattern
		       ,(find-tracer-by-flavor-name *joshua-debugger* 'TMS-tracer))))

(define-presentation-to-command-translator ptrans-tracing-event-to-trace-event
   (tracing-event
     :gesture nil
     :documentation "Trace this event"
     :tester ((event &rest ignore)
	      (not (event-traced-p *joshua-debugger* event)))
     )
   (event)
  `(com-joshua-trace tracing-event ,event :tracing-options
		     (add-trace-event
		       ,(car (gethash (tracing-event-name event)
				      (joshua-debugger-event-to-tracer-table
					*joshua-debugger*))))))

(define-presentation-to-command-translator ptrans-tracing-event-to-untrace-event
   (tracing-event
     :gesture nil
     :documentation "Untrace this event"
     :tester ((event &rest ignore)
	      (event-traced-p *joshua-debugger* event))
     )
   (event)
  `(com-joshua-trace tracing-event ,event :tracing-options
		     (untrace-event
		       ,(car (gethash (tracing-event-name event)
				      (joshua-debugger-event-to-tracer-table
					*joshua-debugger*))))))

(define-presentation-to-command-translator ptrans-tracing-event-to-step-event
   (tracing-event
     :gesture nil
     :documentation "Step this event"
     :tester ((event &rest ignore)
	      (not (event-stepped-p *joshua-debugger* event)))
     )
   (event)
  `(com-joshua-trace tracing-event ,event :tracing-options
		     (add-step-event
		       ,(car (gethash (tracing-event-name event)
				      (joshua-debugger-event-to-tracer-table
					*joshua-debugger*))))))

(define-presentation-to-command-translator ptrans-tracing-event-to-unstep-event
   (tracing-event
     :gesture nil
     :documentation "Unstep this event"
     :tester ((event &rest ignore)
	      (event-stepped-p *joshua-debugger* event))
     )
   (event)
  `(com-joshua-trace tracing-event ,event :tracing-options
		     (unstep-event
		       ,(car (gethash (tracing-event-name event)
				      (joshua-debugger-event-to-tracer-table
					*joshua-debugger*))))))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Joshua Commands and supporting functions

;;; there are a couple of interesting command tables
;;; *joshua-command-table* and *joshua-tracing-command-table*.
;;; *joshua-command-table* is the comtab for joshua listener commands
;;; (currently "Global"), *joshua-tracing-command-table* is for commands
;;; that are available at tracing prompts in the new tracing stuff.
;;; Since the tracing doesn't want to inherit all of the commands from
;;; "Global", these commands are explicitly installed in both comtabs.


0;; width of an editor buffer
(defparameter *file-stream-width* 94)

(defun stream-inside-width (stream)
  (if (operation-handled-p stream :inside-width)
      (send stream :inside-width)
      *file-stream-width*))

1;;; a macro to allow us to define a command in more than one command table,
;;; for when you want a command in another comtab without inheriting all
;;; of the others
0(defmacro define-multiple-command ((name . options) command-tables arguments &body body)
  (declare (zwei:indentation 2 3 3 2))
  `(progn (cp:define-command (,name . ,options) ,arguments ,@body)
	  (loop for comtab in ',command-tables do
	    (cp:install-commands (if (symbolp comtab)
				     (symbol-value comtab)
				     comtab)
				 '(,name)))))

1;;; a command to list the rules
0(define-multiple-command (com-show-joshua-rules :name "Show Joshua Rules")
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    (&key (type '(alist-member :alist
			       (("Forward" :value :Forward
				 :documentation "Show only forward rules")
				("Backward" :value :backward
				 :documentation "Show only Backward Rules")
				("All" :value :all :documentation "Show rules of any type")))
		:default :all
		:documentation "Show backward, forward, or all rules")
	  (matching 'si:several-strings
		    :documentation
		    "Show only rules with names that contain these substrings")
	  (Triggered-by '(null-or-type (sequence predication))
				:default nil
				:documentation
				"Show rules with triggers that unify with one or ~\
				 more of these predications"
				)
	  (packages '((scl:token-or-type (:All)
					 ((cl:sequence cl:package))))
		    :prompt "package"
		    :default `(,*package*)
		    :documentation "Show rules in which packages")
	  (search-inherited-symbols 'boolean
				    :default t
				    :Mentioned-default nil
				    :documentation "Include rules inherited by packages")
	  (system '((or sct:subsystem sct:system))
		  :prompt nil
		  :documentation "List only rules in the specified system "))
   (labels ((print-heading (heading stream)
	      (terpri stream)
	      (with-character-style (*heading-character-style* stream :bind-line-height t )
		(with-underlining (stream) (princ heading stream)))
	      (terpri stream))
	    (thing-in-packages (thing)
	      (declare (sys:downward-function))
	      (and (symbolp thing)
1		   ;; If we have a symbol, just use its package
0		   (or (member (symbol-package thing) packages)
		       (and search-inherited-symbols
			    (loop for pkg in packages
				  when (eq thing (find-symbol (symbol-name thing) pkg))
				    do (return t))))))
	    (thing-in-system (thing)
	      (declare (sys:downward-function))
	      (let* ((pathname (get-source-file-name-that-works thing))
		     (sys (when pathname (send pathname :get 'sct:system))))
1		;; Match if the specified system is EQ to the system we have our
		;; hands on, or if the specified system is not a subsystem, the
		;; current system is a subsystem, and the parent systems are EQ
0		(or (eq sys system)
		    (and (not (typep system 'sct:subsystem))
			 (typep sys 'sct:subsystem)
			 (eq system (sct:subsystem-parent-system sys))))))
	    (get-source-file-name-that-works (symbol)
	      (si:get-source-file-name symbol 'defrule))
	    (sort-and-format (list stream heading)
	      (si:with-stack-array (found-array (min (length list) 50)  :fill-pointer 0)
		(loop for symbol in list do
		  (when (and (loop with symbol-name = (symbol-name symbol)
				   for fragment in matching
				   always (string-search fragment symbol-name))
			     (or (null triggered-by)
				 (loop for trigger in triggered-by 
				       when 
					 (loop for (trigger-pattern) in
						   (rule-debug-info-triggers
						     (rule-debug-info symbol))
					       when
						 (with-unification
						   1;; truth values?
0						   (unify trigger trigger-pattern))
						 do (return t))
					 do (return t)))
			     (or (not system)
				 (thing-in-system symbol))
			     (or (eq packages :all)
				 (thing-in-packages symbol)))
		    (vector-push-extend symbol found-array)
		    ))
		(sort found-array #'string-lessp :key #'symbol-name)
		(cond ((zerop (fill-pointer found-array))
		       (format *standard-output*"~&No ~a"
			       heading)
		       (when matching
			 (format *standard-output*" matching ")
			 (format-textual-list matching #'prin1
					      :conjunction "and"
					      :stream *standard-output*))
		       (when (not (eq packages :all))
			 (format t " in Package~P " (length packages))
			 (format-textual-list packages #'princ
					      :conjunction "and"	
					      :stream *standard-output*))
		       (when system
			 (format t " that are in system ~a" system)))
		      (t
		       (print-heading heading stream)
		       (formatting-item-list (stream
					       :inside-width
					       (stream-inside-width *standard-output*))
			 (loop for x from 0 to (1- (fill-pointer found-array))
			       as name = (aref found-array x)
			       do
			   (formatting-cell (stream)
			     (present name 'rule :stream stream)))))))))
     (when (member type '(:all :forward))
       (sort-and-format *forward-rules* *standard-output* "Forward Rules"))
     (when (member type '(:all :backward)) 
        (sort-and-format *backward-rules* *standard-output* "Backward Rules"))))

;;;
;;; Graphing a Rete network, mostly for debugging, partly for demo-ing.
;;;

(defun graph-Rete-network (rule-names &key (orientation :vertical)
				      (follow-extraneous-paths nil))
  ;; draw a graph of the rete network of some rules
  (let ((desired-nodes (nodes-leading-to-goals rule-names follow-extraneous-paths)))
    (when rule-names
      (fresh-line)
      (let ((visited-nodes nil))
	(format-graph-from-root
	  rule-names
	  #'(lambda (thing stream)
	      (etypecase thing
		(symbol
		  ;; name of a rule that's at the root of a Rete network
		  (dw:with-output-as-presentation (:stream stream
						   :object (rule-debug-info thing)
						   :type 'sys:expression
						   :allow-sensitive-inferiors nil)
		    (dw::centering-lines (stream)
		      (format stream "Rule~%~S" thing))))
		(rete-procedure-node
		  (dw:with-output-as-presentation (:stream stream
						   :object thing
						   :type 'sys:expression
						   :allow-sensitive-inferiors nil)
		    (format stream "Procedure ~d"
			    (length (basic-rete-node-environments thing)))))
		(Rete-match-node
		  ;; note that it's a match node and give a typical pattern
		  (dw:with-output-as-presentation (:stream stream
						   :object thing
						   :type 'sys:expression
						   :allow-sensitive-inferiors nil)
		    (dw::centering-lines (stream)
		      (format stream "~S~%~d"
			      (match-id-pattern (car (Rete-match-node-match-ids thing)))
			      (length (basic-rete-node-environments thing))))))
		(Rete-merge-node
		  ;; these are less printable, so just print the word
		  ;; merge.  Let 'em click if they wanna see
		  (dw:with-output-as-presentation (:stream stream
						   :object thing
						   :type 'sys:expression
						   :allow-sensitive-inferiors nil)
		    (format stream "Merge ~d" (length (basic-rete-node-environments thing)))))
		(rete-or-node
		  (dw:with-output-as-presentation (:stream stream
						   :object thing
						   :type 'sys:expression
						   :allow-sensitive-inferiors nil)
		    (format stream "Or ~d" (length (basic-rete-node-environments thing)))))
		(function
		  ;; a rule body is an executable function
		  (dw:with-output-as-presentation (:stream stream
						   :object thing
						   :type (type-of thing)
						   :allow-sensitive-inferiors nil)
		    (dw::centering-lines (stream)
		      (format stream "Rule Body~%~S" (sys:function-name thing)))))))
	  #'(lambda (parent)
	      (typecase parent
		(symbol
		  (loop with debug-info = (rule-debug-info parent)
			with Rete-nodes = (rule-debug-info-network debug-info)
			for node in Rete-nodes
			do (pushnew node visited-nodes)
			unless (not (member node desired-nodes))
			  collect node))
		(basic-Rete-node
		  (loop for child-entry in (Rete-node-children parent)
			for child-node = (Rete-child-entry-child child-entry)
			do (pushnew child-node visited-nodes)
			when (member child-node desired-nodes)
			  collect child-node))))
	  :dont-draw-duplicates t
	  :root-is-sequence t
	  :orientation orientation
	  :default-drawing-mode :arrow
	  :border :oval)))))

;;; Used by graph forward rule triggers
(defun nodes-leading-to-goals (rule-names &optional (follow-extraneous-paths nil))
  (let ((desired-nodes nil))
    (let ((nodes-visited nil))
      (labels ((pursue (parent)
		 (declare (sys:downward-function))
		 (typecase parent
		   (symbol
		     (pushnew parent nodes-visited)
		     (pushnew parent desired-nodes)
		     (loop with debug-info = (rule-debug-info parent)
			   with Rete-nodes = (rule-debug-info-network debug-info)
			   for node in Rete-nodes
			   do (pursue node)))
		   (function
		     (when (or follow-extraneous-paths
			       (member (sys:function-name parent) rule-names))
		       (pushnew parent nodes-visited)
		       (pushnew parent desired-nodes)
		       t))
		   (basic-Rete-node
		     (pushnew parent nodes-visited)
		     (when
		       (loop for child-entry in (Rete-node-children parent)
			     for child-node = (Rete-child-entry-child child-entry)
			     with any-success = nil
			     do
			 1;; return t if any of the children have
0			 1;; relevant paths, but pursue all of them just
0			 1;; in case.
0			 (when (or (member child-node desired-nodes)
				   (and (not (member child-node nodes-visited))
					(pursue child-node)))
			   (setf any-success t))
			 finally (return any-success))
		       (push parent desired-nodes)
		       t)))))
	(loop for rule-name in rule-names doing (pursue rule-name))))
    desired-nodes))

(define-multiple-command (com-graph-forward-rule-triggers)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((rules `(token-or-type (("All" . :all))
			    (sequence forward-rule))
	    :confirm t
	    :default :all
	    :documentation "One or more rule names (all is acceptable).")
     &key
     (follow-extraneous-paths
       'boolean
       :prompt "Show all related rule branches"
       :default nil
       :documentation "Only show those nodes that lead to at least one of the selected rules.")
     (orientation `((member :horizontal :vertical))
		  :default :vertical
		  :prompt "Orientation of the graph"
		  :documentation "Orientation of the graph"))
   (when (eql rules :all)
     (setf rules *forward-rules*))
   (if rules 
       (graph-rete-network rules
			   :orientation orientation
			   :follow-extraneous-paths  follow-extraneous-paths)
       (with-character-style (*deemphasis-character-style*)
	 (format t "No forward rules defined"))))

1;;; It could be that this command should be more carefull about its destructive 
;;; operations, and query the user first.
0(define-multiple-command (com-clear-joshua-database 
			   :provide-output-destination-keyword nil)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((predications '(token-or-type (("All" :value :all
				     :documentation
				     "Untell all predicates in the Joshua database")
				    ("None" :value nil
				     :documentation
				     "Don't do anything to the Joshua database"))
				   (sequence predication-presentation))
		   :documentation "Remove specified predications from the database"
		   :default :all)
     &key
     (other-truth-values-too 'boolean
			       :prompt "opposite truth-value too?"
			       :default t
			       :documentation "Delete the negative of the predications ~\
					      as well.")
     (undefine-rules 'boolean
		     :documentation "Undefine all rules")
     (verbose 'boolean
	      :default t
	      :documentation "Print information")
     (query 'boolean
	    :default t
	    :documentation "Query the user before actually untelling or undefining things"))
   (cond ((consp predications)
	  (let ((preds-to-untell nil))
	    (loop for pattern in predications do
	      (ask pattern #'(lambda (derivation)
			       (let ((database-predication
				       (ask-database-predication derivation)))
				 (when (predicationp database-predication)
				   (push database-predication preds-to-untell))))
		   :do-backward-rules nil)
	      (when other-truth-values-too
		(ask `[not ,pattern] #'(lambda (derivation)
					 (let ((database-predication
						 (ask-database-predication derivation)))
					   (when (predicationp database-predication)
					     (push database-predication preds-to-untell))))
		     :do-backward-rules nil)))
	    (setf preds-to-untell (nreverse preds-to-untell))
	    (when (or verbose query)
	      (with-character-style (*heading-character-style* *standard-output*)
		(dw:with-underlining (*standard-output*)
		  (format t "~&Predications being removed:")))
	      (if (null preds-to-untell)
		  (format t "~%  None")
		  (format-item-list preds-to-untell :presentation-type 'predication-presentation)))
	    (when (or (not query)
		      (null preds-to-untell)
		      (accept 'boolean
			      :prompt "Untell the above predications?"
			      :default t))
	      (tv:noting-progress ("Untelling Predications")
		(let ((length (length preds-to-untell)))
		  (loop for p in preds-to-untell
			for count = 0 then (1+ count)
			do
		    (untell p)
		    (tv:note-progress count length)))))
	    (when undefine-rules
	      (if query
		  (when (accept 'boolean
				:prompt "Undefine all Joshua Rules?"
				:default t)
		    (clear nil undefine-rules))
		  (when (and verbose (not query))
		    (format t "~&Undefining all Joshua Rules"))
		  (clear nil undefine-rules)))))
	 (t (when (eq predications :all)
	      (when (and verbose (not query))
		(format t "~&Removing all predications from the database"))
	      (when query
		(unless (accept 'boolean
				:prompt "Clear all predications from the database?"
				:default t)
		  (setf predications nil))))
	    (when  undefine-rules
	      (when (and verbose (not query))
		(format t "~&Undefining all Joshua Rules"))
	      (when query
		(unless (accept 'boolean
				:prompt "Undefine all Joshua rules?"
				:default t)
		  (setf undefine-rules nil))))
	    (clear predications undefine-rules))))

(define-multiple-command (com-show-joshua-predicates)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    (&key
      (matching 'si:several-strings
		:documentation "Show only predicates containing this substring(s)")
      (include-models 'boolean
		      :default nil
		      :mentioned-default t
		      :documentation "Show the abstract predicate models also")
      (packages '((scl:token-or-type (:All)
				     ((cl:sequence cl:package))))
		:prompt "package"
		:default `(,*package*)
		:documentation "Show predicates in which packages")
      (search-inherited-symbols 'boolean
				:default t
				:Mentioned-default nil
				:documentation "Include predicates inherited by packages")
      (system '((or sct:subsystem sct:system))
	      :prompt nil
	      :documentation "List only predicates in the specified system "))
   (labels ((thing-in-packages (thing)
	      (declare (sys:downward-function))
	      (and (symbolp thing)
		   ;; If we have a symbol, just use its package
		   (or (member (symbol-package thing) packages)
		       (and search-inherited-symbols
			    (loop for pkg in packages
				  when (eq thing (find-symbol (symbol-name thing) pkg))
				    do (return t))))))
	    (thing-in-system (thing)
	      (declare (sys:downward-function))
	      (let* ((pathname (get-source-file-name-that-works thing))
		     (sys (when pathname (send pathname :get 'sct:system))))
		;; Match if the specified system is EQ to the system we have our
		;; hands on, or if the specified system is not a subsystem, the
		;; current system is a subsystem, and the parent systems are EQ
		(or (eq sys system)
		    (and (not (typep system 'sct:subsystem))
			 (typep sys 'sct:subsystem)
			 (eq system (sct:subsystem-parent-system sys))))))
	    (get-source-file-name-that-works (symbol)
	      (si:get-source-file-name symbol 'cl:deftype))
	    (filter-predicate (flavor)
	      (and (loop with symbol-name = (symbol-name flavor)
			 for fragment in matching
			 always (string-search fragment symbol-name))
		   (or (not system)
		       (thing-in-system flavor))
		   (or (eq packages :all)
		       (thing-in-packages flavor)))))
	      
     (si:with-stack-array (found-array 50 :fill-pointer 0)
       (maphash #'(lambda (key ignore)
		    (when (filter-predicate key)
		      (vector-push-extend key found-array)))
		*all-predicates*)
       (when include-models
	 (loop for model in *models*
	       do
	   (when (filter-predicate model)
	     (vector-push-extend model found-array))))
       (sort found-array #'string-lessp :key #'symbol-name)
       (cond ((zerop (fill-pointer found-array))
	      (format *standard-output*"~&There are no Joshua predicates ")
	      (when matching
		(format *standard-output*"matching ")
		(format-textual-list matching #'prin1
				     :conjunction "and"
				     :stream *standard-output*))
	      (when (not (eq packages :all))
		(format t " in Package~P " (length packages))
		(format-textual-list packages #'princ
				     :conjunction "and"	
				     :stream *standard-output*))
	      (when system
		(format t " that are in system ~a" system)))
	     (t
	      (when (or ( (length found-array) 100)
			(fquery `(:stream ,*standard-output*)
				"There are ~D ~:[possibilities~;possible ~A~].  ~\
				Do you want to see them all? "
				(length found-array)
				'joshua-predicate
				"joshua predicates"))
		(fresh-line)
		(formatting-item-list (*standard-output* :inside-width (stream-inside-width
									 *standard-output*)
							 :inter-column-spacing 3
							 :row-wise nil)
		  (loop for x from 0 to (1- (fill-pointer found-array))
			as name = (aref found-array x)
			do
		    (formatting-cell ()
		      (present name 'joshua-predicate :stream *standard-output*)
		      (let ((predicate-descriptor (gethash name *all-predicates*)))
			(when predicate-descriptor 
			  (princ #\space)
			  (lt:print-lambda-list
			    (predicate-descriptor-arglist predicate-descriptor)
			    *standard-output*))))))))))))


1;;; OK, time to swipe some code from the flavors command Show Flavor Handler
0(define-multiple-command (com-show-joshua-protocol)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((predicate-name 'joshua-predicate
		     :documentation
		     "Describe the protocol implementation for which predicate or model")
     &key
     (protocol-functions '(token-or-type (("All" :value :all
					   :documentation
					   "Show it for all the Joshua Protocol functions"
					   ))
					 (sequence protocol-function))
			 :default :all
			 :documentation
			 "Show the predicate's inheritance of which protocol functions")
     )
   (when (eq protocol-functions :all)
     (setf protocol-functions
	   (loop for external-name in *joshua-protocol-functions*
		 collect (protocol-internal-name external-name)
		   into name-list
		 finally (return (nreverse name-list)))))
   (loop for generic in protocol-functions
	 with flavor = predicate-name
	 do
1     ;; Get information about the handler from the flavor system
0     (MULTIPLE-VALUE-bind (ignore COMBINED-METHOD-LIST)
	 (flavor:COMPOSE-HANDLER GENERIC FLAVOR)
       (when COMBINED-METHOD-LIST
	 (with-character-style (*heading-character-style*)
	   (terpri)
	   (present generic 'protocol-function))
	 (princ #\space)
	 (dw:filling-output ()
	   (lt:print-lambda-list (arglist (protocol-external-name generic)) *standard-output*))
	 (with-character-style ('(nil :italic nil))
	   (format t "~%Implemented by:"))
	 (loop for method in COMBINED-METHOD-LIST do
	   (format t "~%  ~s" method))
	 ))))


1;;; Show everything in the database, or at least in the dn
0(define-multiple-command  (com-show-joshua-database)
			  (*joshua-command-table*
			    *joshua-only-command-table* *joshua-tracing-command-table*)
    ((pattern '(token-or-type (:all) predication-presentation)
	      :prompt "matching pattern"
	      :default :all
	      :documentation "Show predications in the database matching this pattern.")
     (other-truth-value-too-p 'boolean
			      :prompt "opposite truth-value too?"
			      :default t
			      :documentation "Show patterns with both truth-values.")
     &key
     (show-partially-failing-models 'boolean
				    :prompt "show models which couldn't completely handle the query"
				    :mentioned-default t
				    :default nil
				    :documentation "Show a list of those models which encountered trouble answering the query")
     (show-erroring-models 'boolean
			   :prompt "show models which get an error handling the query"
			   :mentioned-default t
			   :default nil
			   :documentation "Show a list of those models which encountered errors answering the query"))
   (with-unbound-logic-variables (predicate arguments)
     (when (eq pattern :all) (setq pattern `[,predicate . ,arguments]))
     (assert (predicationp pattern) nil "Pattern is not a predication: ~S" pattern)
     (let ((true-answers nil)
	   (false-answers nil)
	   (things-i-could-not-handle nil)
	   (things-that-error nil))
       (flet ((print-predication-entries (heading entries)
		(fresh-line)
		(with-underlining ()
		  (with-character-face (:bold)
		    (princ heading)))
		(if entries
		    (format-item-list entries
				      :printer #'print-database-predication-without-truth-value)
		    (format-item-list '("None") :printer #'princ)))
	      (print-model-failure-entries (heading entries)
		(fresh-line)
		(with-underlining ()
		  (with-character-face (:bold)
		    (princ heading)))
		(if entries
		    (format-item-list entries :printer #'prin1)
		    (format-item-list '("None") :printer #'princ)))
	      (print-query-error-entries (heading entries)
		(fresh-line)
		(with-underlining ()
		  (with-character-face (:bold)
		    (princ heading)))
		(if entries
		    (format-item-list entries
				      :printer #'(lambda (entry stream)
						   (prin1 (first entry) stream)
						   (write-string " " stream)
						   (prin1 (second entry) stream)))
		    (format-item-list '("None") :printer #'princ)))
	      (do-truth-value (truth-value)
		;; print out contents of db with this truth-value
		;; disable tracing for these asks
		(without-joshua-tracing
		  (condition-bind ((model-cant-handle-query
				     #'(lambda (condition)
					 (pushnew (model-cant-handle-query-model condition)
						  things-i-could-not-handle)
					 (throw 'ask-variable-predicate-escape nil)))
				   (query-got-error-during-processing 
				     #'(lambda (condition)
					 (push
					   (list
					     (query-got-error-during-processing-query condition)
					     (query-got-error-during-processing-condition condition))
					   things-that-error)
					 (throw 'ask-variable-predicate-escape nil))))
		    (ask-internal pattern
				  truth-value
				  ;; This isn't right.  It works for predications which store and
				  ;; return their canonical predications, but not for other kinds.
				  #'(lambda (backward-support)
				      (when (and (consp backward-support)
						 (consp (rest backward-support))
						 (predicationp (third backward-support)))
					(select (second backward-support)
					  (*true*
					   (push (third backward-support) true-answers))
					  (*false*
					   (push (third backward-support) false-answers)))))
				  nil nil)))))
	 (do-truth-value *true*)
	 (when other-truth-value-too-p
	   (do-truth-value *false*))
	 (when (or true-answers other-truth-value-too-p (null false-answers))
	   (print-predication-entries "True things" (nreverse true-answers)))
	 (when (or false-answers other-truth-value-too-p (null true-answers))
	   (print-predication-entries "False things" (nreverse false-answers)))
	 (when (and things-i-could-not-handle show-partially-failing-models)
	   (print-model-failure-entries "Models which couldn't respond" things-i-could-not-handle))
	 (when (and things-that-error show-erroring-models)
	   (print-query-error-entries "Queries which encountered an error" things-that-error))))))

;;; Replace by Show Predication Support.
(cp:define-command (com-explain-predication :command-table "Global")
    ((p '((database-predication-presentation))
	:prompt "database predication"
	:documentation "a database predication to explain")
     (n '((integer 0))
	:prompt "to what depth"
	:default 1))	
   ;; a real version of this would do it possibly graphically, and with incremental redisplay, etc.
   (explain p n *standard-output*))



1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Commands for manipulating tracing.

;;; I would much prefer to use dw::alist-member here but it doesn't do the right 
;;; thing with mentioned defaults, its help is completely messed up on objects with
;;; spaces as well.

0(define-multiple-command (com-enable-joshua-tracing :Name "Enable Joshua Tracing"
						    :provide-output-destination-keyword nil)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((Type-of-tracing `(dw::alist-member
			 :alist ,(create-tracer-alist
				   *joshua-debugger*
				   :extra-items
				   '(("All" :value :all
				      :documentation "Enable all types of tracing"))
				   :first-word-of-doc-strings "Enable"))
		      :prompt "Type of tracing"
		      :documentation "What kind of tracing to Enable")
     &key
     (menu 'boolean
	   :default nil
	   :mentioned-default t
	   :documentation "Use the menu to set detailed tracing options")
     (trace-events `((dw::alist-subset :alist
				 ,(get-events-alist *joshua-debugger* Type-of-tracing)))
		   :default (get-current-events *joshua-debugger* :trace Type-of-tracing)
		   :prompt "Trace which events"
		   :when (not (eq Type-of-tracing :all))
		   :documentation "What events to output trace messages for")
     (step-events `((dw::alist-subset :alist 
				      ,(get-events-alist *joshua-debugger* Type-of-tracing)))
		  :prompt "Step at which events"
		  :when (not (eq Type-of-tracing :all))
		  :default (get-current-events *joshua-debugger* :step Type-of-tracing)
		  :documentation "What events to stop and interact at"))
   (if (or (eq Type-of-tracing :all) menu)
       (set-joshua-trace-conditions *joshua-debugger* :tracer Type-of-tracing :menu menu
				    :enable-p t)
       (set-joshua-trace-conditions *joshua-debugger* :tracer Type-of-tracing :menu menu
				    :enable-p t :trace-events trace-events
				    :step-events step-events))
   (unless menu
     (show-joshua-tracing *joshua-debugger* Type-of-tracing)))


(define-multiple-command (com-disable-joshua-tracing :Name "Disable Joshua Tracing"
						     :provide-output-destination-keyword nil)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((Type-of-tracing `(dw::alist-member
			 :alist ,(create-tracer-alist
				   *joshua-debugger*
				   :extra-items
				   '(("All" :value :all
				      :documentation "Disable all types of tracing"))
				   :first-word-of-doc-strings "Disable"))
		      :prompt "Type of tracing"
		      :default :all
		      :documentation "What kind of tracing to disable"))
   (set-joshua-trace-conditions *joshua-debugger* :tracer Type-of-tracing :menu nil
				:enable-p nil)
   (show-joshua-tracing *joshua-debugger* Type-of-tracing))

(define-multiple-command (com-Joshua-trace :name "Joshua Trace"
					   :provide-output-destination-keyword nil)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((type '(alist-member :alist
			  (("Rule" :value rule
			    :documentation "Set the tracing options for a rule" )
			   ("Predication"  :value predication
			    :documentation "Set the tracing options for a predication/pattern")
			   ("Predicate"  :value joshua-predicate
			    :documentation "Set the tracing options for a predicate flavor")
			   ("Event" :value tracing-event
			    :documentation
			    "Set the tracing options for a particular tracing event")))
	   :prompt "Type of object to trace (or untrace)"
	   :default nil
	   :documentation "What type of object to trace, a rule, a predication, or a Predicate"
	   )
     (object type
	     :prompt "object to trace"
	     :documentation "What object to trace")
     &key (tracing-options
	    `((alist-member :alist
			   ,(append
			      (collect-options-for-object *joshua-debugger* object)
			      '(("Menu" :value :menu
				 :documentation "Bring up a menu of available options")))
			   )
	      :highlighting-test ,#'equal)
	    :default :menu
;	    :prompt "tracing options"
	    :documentation "What kind of tracing to do"))
   1;;; Tracing-options will return a list containing the generic and the instance to
0   1;;; apply it to to get the desired tracing-options
0   (ignore type)
   (if (eq tracing-options :menu)
       1;;; Just let the menu handle everything
0       (get-all-trace-options *joshua-debugger* object)
       (when tracing-options
	 1;;otherwise they typed in the choice and we can handle it here
0	 (apply (car tracing-options) `(,(cadr tracing-options) ,object))
	 1;;Show them what they did
0	 (show-joshua-tracing *joshua-debugger* (cadr tracing-options)))))


(define-multiple-command (com-show-joshua-tracing)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((Type-of-tracing `(dw::alist-member
			 :alist ,(create-tracer-alist
				   *joshua-debugger*
				   :extra-items
				   '(("All" :value :all
				      :documentation "Disable all types of tracing"))
				   :first-word-of-doc-strings "Show"))
		      :prompt "Type of tracing"
		      :default :all
		      :documentation "What kind of tracing to disable"))
   (show-joshua-tracing *joshua-debugger* Type-of-tracing))

(define-multiple-command (com-show-rule-source :name "Show Rule Definition")
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
    ((rule '(sequence rule)
	   :prompt "rule or rules"
	   :documentation "Show the definitions of which rule or rules")
     &key (load '(alist-member
		   :alist
		   (("Yes" :value t :documentation
		     "Read the file into zmacs if the definition isn't already available")
		    ("No" :value nil :documentation
		     "Don't bother reading the file zmacs if the definition isn't there")
		    ("Query" :value :query :documentation
		     "Ask before reading any files in")))
		:default :query
		:prompt "load the file if necessary?"
		:documentation "Whether to read in the file or query the user if the ~\
				 definition isn't in an editor buffer"))
   (loop for each-rule in rule do
     (show-rule-source each-rule t load)))

1;;; This is really completely bogus, the system has no way of knowing where the currently
;;; loaded definition is from.
0(defun show-rule-source (rule-name &optional (stream t)
			 (load-p :query)(header-p t))
  (when (eq stream t)(setf stream *standard-output*))
  (let* ((section (si:function-correspondence-info rule-name))
	 (file-name (si:get-source-file-name rule-name 'defrule))
	 (real-file-name (when file-name (zwei:pathname-source-file-pathname file-name))))
    (cond ((or section real-file-name)
	   (when (not section)
	     (case load-p
	       ((t) (zwei:load-file-into-zmacs real-file-name)
		(setf section (si:function-correspondence-info rule-name)))
	       ((nil) (format stream "~&Rule ~s is not in an editor buffer" rule-name))
	       (:query (when
			 (accept 'boolean
				 :prompt (format nil
						 "~&Rule ~s is not in an editor buffer~%~\
					   Load the file into Zmacs and show the definition? "
						 rule-name)
				 :default t)
			 (zwei:load-file-into-zmacs real-file-name)
			 (setf section (si:function-correspondence-info rule-name))))))
	   (when section
	     (when header-p
	       (format stream "~&~VRule ~a:~~%"
		       *deemphasis-character-style* rule-name))
	     (let* ((first-bp (send section :first-bp))
		    (last-bp (send section :last-bp))
		    (interval-stream (zwei:open-interval-stream first-bp last-bp t)))
	       (stream-copy-until-eof interval-stream stream))))
	  (t
	   (format stream
		   "Rule ~s was not loaded from a file or editor buffer. No definition found."
		   rule-name)))))

(define-multiple-command (com-reset-joshua-tracing :provide-output-destination-keyword nil)
			 (*joshua-command-table*
			   *joshua-only-command-table* *joshua-tracing-command-table*)
 ((Type-of-tracing `(dw::alist-member
			 :alist ,(create-tracer-alist
				   *joshua-debugger*
				   :extra-items
				   '(("All" :value :all
				      :documentation
				      "Restore all types of tracing to their original defaults"
				      ))
				   :first-word-of-doc-strings
				   "Restore the original defaults for"))
		      :prompt "Type of tracing"
		      :default :all
		      :documentation
		      "What kind of tracing to reset back to the original defaults")
  &key (include-events 'boolean
		       :default nil
		       :mentioned-default t
		       :documentation "Reset the traced and stepped events as well"
		       ))
   (reset-tracers *joshua-debugger* Type-of-tracing include-events))



;(define-multiple-command (com-joshua-help)
;			 (*joshua-command-table* *joshua-only-command-table*
1; 0*joshua-tracing-command-table*)
;    (&key
;      (format '((cl:member :brief :detailed)) :default ':brief	;
;	      :documentation "\"Detailed\" shows all commands.  \"Brief\" uses compression."))
;   (scl:format-item-list (mapcar
;			   #'second
;			   (cp::command-table-complete "" *joshua-tracing-command-table*
;						       :possibilities))
;			 :presentation-type `cp:command-name))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; commands for the Joshua Tracing prompt - for stepping through the execution 
;;; of the rules

;;; By making abort work only as an accelerator (all other aborts are caught), we
;;; get the effect that hitting abort at the command prompt will abort the 
;;; execution of the program while hitting abort while typing or executing a 
;;; command will bring you back to the command prompt
0(cp:define-command-accelerator acc-com-abort "Joshua Trace" (#\abort)
			       ()
			       ()
  (throw 'aborted t))

1;;; Commands that want to exit the command loop should retun :done, all others 
;;; will simply finish and return to the command propmt
0(cp:define-command (com-continue :name "Step" :command-table "Joshua Trace"
				 :provide-output-destination-keyword nil)
    ()
   (add-tracing-filter *joshua-debugger* nil)
   :done)

(cp:define-command-accelerator acc-com-continue "Joshua Trace" (#\return #\c-s)
			       ()()
  `(com-continue))


(cp:define-command (com-leap :name "Leap" :command-table "Joshua Trace"
			     :provide-output-destination-keyword nil)
    ((n-levels 'integer
	       :documentation
	       "Leap to the next tracing message at the current depth + n-levels"
	       :prompt "How many levels"
	       :default 0))
   (let ((target-depth (+ *rule-depth* n-levels))
	 (counter 0))
     (add-tracing-filter
       *joshua-debugger*
       #'(lambda (ignore depth)
	   (when
	     (cond ((or (and (not (plusp n-levels))
			     ( depth target-depth))
			(and (plusp n-levels)
			     ( depth target-depth)))
		    (with-character-style
		      (*deemphasis-character-style* *trace-output*)
		      (fresh-line *trace-output*)
		      (joshua-trace-message-indentor *trace-output*)

		      (format *trace-output* " Leaping past ~d traced events"
			      counter))
		    t)
		   (t (incf counter)
		      nil))
	     (reset-tracing-state *joshua-debugger*)
	     t))))
   :done)

(cp:define-command-accelerator acc-com-leap "Joshua Trace" (#\line #\c-l)
			       (:argument-allowed t)
			       (narg-p narg)
  (unless narg-p (setf narg 0))
  `(com-leap ,narg))

(cp:define-command-accelerator acc-com-leap "Joshua Trace" (#\) ()
			       ()
  `(com-leap 1))

(cp:define-command-accelerator acc-com-leap "Joshua Trace" (#\) ()
			       ()
  `(com-leap -1))

(cp:define-command (com-help :command-table "Joshua Trace")
    (&key
      (format '((cl:member :brief :detailed)) :default ':brief	;
	      :documentation "\"Detailed\" shows all commands.  \"Brief\" uses compression."))
   (cp::show-command-name-help cl:*standard-output* format))

(cp:define-command-accelerator acc-com-simple-help "Joshua Trace" (#\help) ()
			       ()
  `(com-help))


1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Put this here to overcome some compile dependencies
0(defmacro map-over-database-predications (predication-pattern function)
  `(ask ,predication-pattern
	#'(lambda (backward-support)
	    (when (and (consp backward-support)
		       (consp (rest backward-support))
		       (consp (rest (rest backward-support))))
	      (let ((database-predication (ask-database-predication backward-support)))
		(when (predicationp database-predication)
		  (funcall ,function database-predication)))))
	:do-backward-rules nil
	:do-questions nil))



