;;; -*- Mode: Joshua; Package: JI; Syntax: Joshua; Base: 10; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Created 2/14/86 15:46:16 by sgr running on GROUSE at SCRC.

;;;
;;; Define the notion of a predication.
;;;

;;; Define a new invisible frame type; a rug under which we can sweep our dirty laundry,
;;; to mix a m-4.
(pushnew 'joshua-internals dbg:*all-invisible-frame-types*)

(defgeneric install-predicate-args-in-map (predication)
  ;; not part of the protocol!
  "Internal method to keep the statement consistent in the face of recompilation.")

(si:defvar-resettable *support* nil nil
  ;; we need a set of tms primitives to keep from having to tell users about this.
  "Current value of support structure.  The Default Justification.")

;;;
;;; First, some substrate for defining protocol functions.  Joshua protocol function specs
;;; look like (<name> <model/pred> . <keywords>) where <name> is the name of a protocol function (SAY,
;;; TELL, ASK, etc.), <model/pred> is the model or predicate you're talking about, and 
;;; <keywords> is a bunch of options.  <keywords> can be nothing, in which case you're talking
;;; about a primary method.  It can also be flavorish things like :BEFORE, :AFTER, :CASE :FOO, etc.
;;; Finally, it can be :WHOPPER, :WHOPPER-SUBST, or :WRAPPER with the obvious meaning.
;;;

(defvar *joshua-protocol-functions* nil "All the specs for elements of the protocol.")

(defsubst joshua-fspec-protocol (fspec)
  ;; extract protocol from a function spec
  (first fspec))

(defsubst joshua-fspec-model (fspec)
  ;; extract model from a function spec
  (second fspec))

(defsubst joshua-fspec-method-keywords (fspec)
  ;; extract method keywords: :after, :before, :whopper, etc.
  (cddr fspec))

(defun joshua-protocol-function-spec-p (x)
  ;; check function-specs for reasonableness
  ;; (tell <model> :after) or (tell <model>) or (tell <model> :whopper)
  (and (consp x)
       (consp (cdr x)) ;length at least 2
       (member (joshua-fspec-protocol x) *joshua-protocol-functions*)
       (symbolp (joshua-fspec-model x))
       (or (null (joshua-fspec-method-keywords x))
	   (member (car (joshua-fspec-method-keywords x))
		   '(:before :after :whopper :whopper-subst :wrapper :default)))
       ;; leaving this in causes an  loop -- calling this calls the handler, which
       ;; does a check-type that calls this!
       ;;(sys:validate-function-spec x)
       ))

(deftype joshua-protocol-function-spec ()
  ;; good for error-checking in define-predicate-method
  '(satisfies joshua-protocol-function-spec-p))

;;; 
;;; Some parts of the protocol have internal and external names, e.g., TELL and JI::TELL-INTERNAL.
;;; This is a translation mechanism to get from one to the other.
;;;

(defvar *joshua-protocol-name-translations* nil "Alist of (visible-name . internal-name) for protocol.")

(defun protocol-internal-name (external-name)
  ;; translate from external to internal name
  (cdr (assoc external-name *joshua-protocol-name-translations*)))

(defun protocol-external-name (internal-name)
  ;; translate from internal to external name
  (car (rassoc internal-name *joshua-protocol-name-translations*)))

;;;
;;; Sometimes the system will convert function-spec operations to operations
;;;  on a symbol that presumably names the function spec.  This undoes that in the
;;;  cases where it matters.
;;;

(defvar *function-spec-translations*
	'((zl:plist   . si:function-spec-plist)
	  (zl:get     . si:function-spec-get)
	  (zl:putprop . si:function-spec-putprop)
	  (zl:remprop . si:function-spec-remprop))
  "System occasionally gets overenthusiastic about symbols; this translates back to fspec operators.")

(defun translate-to-fspec-operation (operation)
  ;; translate an operation like zl:plist to si:function-spec-plist
  (let ((translated (cdr (assoc operation *function-spec-translations*))))
    (if translated
	translated
	operation)))

(defsubst predicate-synonyms (predicate)
  ;; return everybody who is a synonym for this predicate
  (get predicate 'predicate-synonyms))

;;; this should be called canonical-predicate or something like that
(defsubst predicate-is-synonym-for (synonym-predicate)
  ;; return the canonical thing for which this is a synonym
  (cond ((symbolp synonym-predicate) (or (get synonym-predicate 'predicate-is-synonym-for) synonym-predicate))
	((sys:unbound-logic-variable-p synonym-predicate) 'variable-predicate)
	((logic-variable-maker-p synonym-predicate) 'variable-predicate)
	(t synonym-predicate)))

(defsubst set-predicate-is-synonym-for (synonym-predicate new-value)
  ;; have to do it the hard way if we want the or in the above.
  (setf (get synonym-predicate 'predicate-is-synonym-for) new-value))

(defsetf predicate-is-synonym-for set-predicate-is-synonym-for)

(defun record-predicate-synonyms (new-name old-name)
  ;; note the synonym relationship both ways.
  (check-type new-name symbol)
  (check-type old-name symbol)
  (push new-name (predicate-synonyms old-name))
  (setf (predicate-is-synonym-for new-name) old-name))

;;; Move this to *joshua-area* when that exists.
(defvar *predicate-constructor-hash-table* (make-hash-table :test 'eq :size 10)) ;so small programs win

(defun undefine-predicate-synonym (name)
  ;; how to undo a define-predicate-synonym
  (check-type name symbol)
  (let ((real-pred (predicate-is-synonym-for name)))
    (setf (predicate-synonyms real-pred) (delete name (predicate-synonyms real-pred))))
  (remprop name 'predicate-is-synonym-for)
  (remhash name *predicate-constructor-hash-table*)) 

;;;
;;; The two common (well, system-provided) ways of defining handlers are
;;; flavor methods and functions  stashed on the property lists of
;;; flavor names.  Should probably find out what a derived function 
;;; spec is; it sounds like one of these.  See
;;; SI:DEFINE-DERIVED-FUNCTION-TYPE.
;;;

(defun run-time-fake-method-apply (protocol flavor &rest args)
  ;; fakes up a method-like behavior in terms of general method accessors.
  ;; this is used by the parts of the protocol that want to look like methods, but can't be
  (loop for component in (flavor:get-all-flavor-components flavor)
	;; having to simulate inheritance like this is surely brain-death of the first
	;; degree.  this takes handlers in more or less the order the flavor system would.  (I think.)
	for method = (get component protocol)
	;; SELF will be bound to the first argument (usually a predication-maker form)
	;; The first method found will run and return.
	when method return (apply method args)
; ----  this ought to be here, but isn't for complicated bogus reasons
;	finally (error "The ~S method of ~S is undefined"
;		       protocol (sys:flavor-name flavor-structure))
			   ))

(defun compile-time-fake-method-apply (protocol-method predication-maker &rest args)
  (let ((predicate-name (predicate-is-synonym-for (predication-maker-predicate predication-maker))))
    (if (flavor:find-flavor predicate-name nil 'flavor::compile)
	;; fakes up a method-like behavior in terms of general method accessors.
	;; this is used by the parts of the protocol that want to look like methods, but can't be
	(loop for component in (flavor:get-all-flavor-components predicate-name 'flavor::compile)
	      ;; This simulates flavor inheritance.  This takes handlers in more
	      ;; or less the order the flavor system would.
	      for pseudo-method = (get component protocol-method)
	      ;; SELF will be bound to the first argument (usually a predication-maker form)
	      ;; The first method found will run and return.
	      when pseudo-method return (apply pseudo-method predication-maker args)
	      finally (error "The ~S method of ~S is undefined" protocol-method predicate-name))
	(fatal-compilation-error "~S is an undefined predicate" predicate-name))))

(defun method-protocol-definer (fspec args &rest body)
  (method-protocol-definer-internal '(eval load) fspec args body))

(defun compile-time-method-protocol-definer (fspec args &rest body)
  (method-protocol-definer-internal '(compile eval load) fspec args body))

(defun method-protocol-definer-internal (times-list fspec args body)
  ;; how we usually define handlers (as methods) for Joshua protocol functions
  ;; These don't deal with defun-in-flavor, defmacro-in-flavor or defsubst-in-flavor (and shouldn't,
  ;; because protocol functions are by definition visible to the outside).
  (check-type fspec joshua-protocol-function-spec)
  ;; translate to the internal name, e.g., tell  ji::tell-internal
  (let* ((method-keywords (joshua-fspec-method-keywords fspec))
	 (protocol (protocol-internal-name (joshua-fspec-protocol fspec)))
	 (model (joshua-fspec-model    fspec)))
    `(eval-when ,times-list
       (record-source-file-name ',fspec 'define-predicate-method)
       ,(ecase (first method-keywords)
	  ((:before :after :default nil)
	   ;; just ordinary primary or daemon method, or recognized :case combination
	   `(defmethod (,protocol ,model ,@method-keywords) ,args
	      (declare (sys:function-parent ,fspec define-predicate-method))
	      ,@body))
	  (:wrapper
	    ;; wants to define a wrapper
	    `(defwrapper (,protocol ,model) ,args
	       (declare (sys:function-parent ,fspec define-predicate-method))
	       ,@body))
	  (:whopper
	    ;; wants to define a whopper
	    `(defwhopper (,protocol ,model) ,args
	       (declare (sys:function-parent ,fspec define-predicate-method))
	       ,@body))
	  (:whopper-subst
	    ;; wants to define a subst whopper
	    `(defwhopper-subst (,protocol ,model) ,args
	       (declare (sys:function-parent ,fspec define-predicate-method))
	       ,@body))))))

;;; Method shower is the flavor system's, 'cause that's too wonderful for words.

(defun method-protocol-killer (fspec)
  ;; how to undefine a protocol element
  (check-type fspec joshua-protocol-function-spec)
  (fundefine fspec))

(defun method-protocol-function-spec-handler (operation fspec &rest args)
  ;; translate the fspec into the type of function that implements it
  ;; A comment in SYS:SYS;FSPEC says we have to handle these operations:
  ;; FDEFINE definition
  ;; FDEFINEDP
  ;; FDEFINITION
  ;; FDEFINITION-LOCATION
  ;; DEFINITION-HAS-LOCATION-P
  ;; FUNDEFINE
  ;; FUNCTION-PARENT
  ;; COMPILER-FDEFINEDP -- returns T if will be fdefinedp at run time
  ;; GET indicator
  ;; PUTPROP value indicator
  ;; PLIST retrieves the entire PLIST, which for some function specs
  ;;   will also include things put on with regular PUTPROP.
  ;; ---- Added by sgr from examining the source ---
  ;; REMPROP
  ;; VALIDATE-FUNCTION-SPEC
  ;; 
  ;; SYS:FUNCTION-SPEC-DEFAULT-HANDLER is also interesting.
  (when (and (not (joshua-protocol-function-spec-p fspec))
	     (eq operation 'sys:validate-function-spec))
    ;; sometimes dw will call validate-function-spec on, e.g., an ASK
    ;; form, thinking it's a function spec.  this makes that safe, but
    ;; keeps the error checking for other operations.
    (return-from method-protocol-function-spec-handler nil))
  (check-type fspec joshua-protocol-function-spec)
  ;; translate to internal name, e.g., tell  ji::tell-internal
  (let* ((method-keywords (joshua-fspec-method-keywords fspec))
	 (protocol (protocol-internal-name (joshua-fspec-protocol fspec)))
	 (model (joshua-fspec-model fspec)))
    ;; It doesn't make sense to pass on the function-parent operation,
    ;; as the define-predicate-method is usually the function-parent of
    ;; the internal method. If we pass it on we effectively declare the
    ;; predicate method the function-parent of itself, which confuses m-.
    (unless (eq operation 'sys:function-parent)
      (apply (translate-to-fspec-operation operation)
	     (if (eq (joshua-fspec-protocol fspec) 'map-triggers)
		 ;; yet another special kludge -- flush the case
		 ;; keywords from the internal version
		 `(,protocol ,model ,@(cdr method-keywords))
		 ;; "ordinary" case
		 (ecase (first method-keywords)
		   ((:wrapper :whopper-subst)
		    ;; wrapper or :whopper-subst
		    `(flavor:wrapper ,protocol ,model))
		   (:whopper
		     ;; whopper
		     `(flavor:whopper ,protocol ,model))
		   ((:before :after :default nil)
		    ;; daemon or primary or :case combination from trigger guys.
		    `(flavor:method ,protocol ,model ,@method-keywords))))
	     args))))

;;;
;;; These are for some of the protocol elements that are implemented as
;;; property-list functions.
;;;

(defsubst no-method-keywords (x)
  ;; plist fspecs can't have :after methods, whoppers, etc.
  ;; just (<protocol> <model>)
  (null (cddr x)))

(deftype joshua-plist-function-spec ()
  ;; type for plist fspecs
  `(and joshua-protocol-function-spec
	(satisfies no-method-keywords)))

(defun property-protocol-definer (fspec args &rest body)
  ;; how we define those poor  handlers that have to be property-list functions
  (check-type fspec joshua-plist-function-spec)
  (let* ((method-keywords (joshua-fspec-method-keywords fspec))
	 (protocol (protocol-internal-name (joshua-fspec-protocol fspec)))
	 (model    (joshua-fspec-model fspec)))
    (when method-keywords
      (error "You can't use any method keywords with ~S: ~S"
	     (joshua-fspec-protocol fspec) fspec))
    ;; translate to internal version and expand into plist fn
    (multiple-value-bind (declarations real-body)
	(si:find-body-declarations body nil)
      `(progn (record-source-file-name ',fspec 'define-predicate-method)
	      ;; implement this as a property-list function
	      (defun (:property ,model ,protocol) (self ,@args)
		,@declarations
		(declare (sys:function-parent ,fspec define-predicate-method))
		(ignore self)
		,@real-body)))))

;;; Someday this should imitate defmacro in such a way as not to bash the runtime environment.
(defun compile-time-property-protocol-definer (fspec args &rest body)
  ;; just like property-protocol-definer, but puts stuff in compile env, too.
  (check-type fspec joshua-plist-function-spec)
  (let* ((method-keywords (joshua-fspec-method-keywords fspec))
	 (protocol (protocol-internal-name (joshua-fspec-protocol fspec)))
	 (model    (joshua-fspec-model fspec)))
    (when method-keywords
      (error "You can't use any method keywords with ~S: ~S"
	     (joshua-fspec-protocol fspec) fspec))
    ;; expand into plist fn
    (multiple-value-bind (declarations real-body)
	(si:find-body-declarations body nil)
    `(eval-when (eval load compile)
       (record-source-file-name ',fspec 'define-predicate-method)
       ;; implement this as a property-list function
       (defun (:property ,model ,protocol) (self ,@args)
	 ,@declarations
	 (declare (sys:function-parent ,fspec define-predicate-method))
	 (ignore self)
	 ,@real-body)))))

(defun matcher-cache-clearing-compile-time-property-protocol-definer (fspec args &rest body)
  (declare (special *matcher-cache*))
  (when (boundp '*matcher-cache*) (clrhash *matcher-cache*))
  (apply #'compile-time-property-protocol-definer fspec args body))

(defun property-protocol-shower (form &aux (fspec (second form)))
  ;; well, it's better than saying nothing.
  (check-type fspec joshua-plist-function-spec)
  (format zwei:*typein-window* "~&Evaluating this will define ~S, which is not really a method." fspec)
  t)

(defun property-protocol-killer (fspec)
  ;; how to undefine one of these property-list kludges.
  (check-type fspec joshua-plist-function-spec)
  (fundefine fspec))

(defun property-protocol-function-spec-handler (operation fspec &rest args)
  ;; translate one of these "methods" into what it's really implemented as.
  ;; (tell frobozz-model)  (:property frobozz-model tell)
  ;; A comment in SYS:SYS;FSPEC says we have to handle these operations:
  ;; FDEFINE definition
  ;; FDEFINEDP
  ;; FDEFINITION
  ;; FDEFINITION-LOCATION
  ;; DEFINITION-HAS-LOCATION-P
  ;; FUNDEFINE
  ;; FUNCTION-PARENT
  ;; COMPILER-FDEFINEDP -- returns T if will be fdefinedp at run time
  ;; GET indicator
  ;; PUTPROP value indicator
  ;; PLIST retrieves the entire PLIST, which for some function specs
  ;;   will also include things put on with regular PUTPROP.
  ;; ---- Added by sgr from examining the source ---
  ;; REMPROP
  ;; VALIDATE-FUNCTION-SPEC
  ;; 
  ;; SYS:FUNCTION-SPEC-DEFAULT-HANDLER is also interesting.
  (when (and (not (and (joshua-protocol-function-spec-p fspec)
		       (no-method-keywords fspec)))
	     (eq operation 'sys:validate-function-spec))
    ;; sometimes dw will call validate-function-spec on, e.g., an ASK
    ;; form, thinking it's a function spec.  this makes that safe, but
    ;; keeps the error checking for other operations.
    (return-from property-protocol-function-spec-handler nil))
  (check-type fspec joshua-plist-function-spec)
  (let* ((protocol (protocol-internal-name (joshua-fspec-protocol fspec)))
	 (model (joshua-fspec-model fspec)))
    ;; Don't pass on the sys:function-parent operation or we confuse m-.
    ;; Just return nil and don't let there be a function parent for
    ;; these guys.
    (unless (eq operation 'sys:function-parent)
      (apply (translate-to-fspec-operation operation)
	     `(:property ,model ,protocol)
	     args))))
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")
0;;;
;;; Now the flavor this is all about!
;;;

;;;
;;; Stuff to manipulate the bits instance variable of a predication.
;;;

(defstruct (predication-bits (:type :fixnum))
  ;; what the fields of the bits instance variable are.
  ;; dont' forget to extend the :describe method if you extend this.
  ((truth-value   *unknown* :byte (byte 2 0))	;the current state in the database
   (has-been-in-database 0  :byte (byte 1 2))	;tells whether truth-value is interesting
   (has-logic-variables 0   :byte (byte 1 3))	;set by the make-instance method
   (spare               0   :byte (byte 1 4))
   (ive-been-in-before  0   :byte (byte 1 5))
   (tms-bits            0   :byte (byte 6 6))
   (ive-been-untold     0   :byte (byte 1 12))))

(defflavor predication
	;; STATEMENT is a list representing the statement that the
	;; predication makes.  It's used in looping over the args.
	;; BITS is a fixnum's worth of bits; see the predication-bits defstruct.
	(statement (bits (make-predication-bits)))
	()
  ;; this is not instantiable; mix in storage strategy via define-predicate
  :abstract-flavor
  ;; Make these ivs ordered for fastest possible access
  (:ordered-instance-variables statement bits)
  ;; run all flavor:transform-instance methods, starting from here.
  (:method-combination flavor:transform-instance (:progn :most-specific-last))
  (:initable-instance-variables statement)
  (:readable-instance-variables bits statement))

;;; Want a (probably (make-instance :after)) method to change
;;; prematurely dotted tails into anonymi.

(defmethod (predication-predicate predication) ()
  ;; how to get at the predicate of a predication abstractly.
  (car statement))


(defmethod (:describe predication :after) ()
  ;; arrange for this to happen after the usual describe stuff from flavor:vanilla
  ;; so that mere humans (like me!) can read the bits field.
  (format
    t "~&~S has bits #O~O: Truth value ~@\\presentation\\, ~[no ~;~]logic variables,~& has~[ not~;~] been in the database, has~[ not~;~] been in before, has~[ not~;~] been UNTELL'd,~& TMS bits are #O~O."
    self bits
    (predication-bits-truth-value bits) 'truth-value
    (predication-bits-has-logic-variables bits)
    (predication-bits-has-been-in-database bits)
    (predication-bits-ive-been-in-before bits)
    (predication-bits-ive-been-untold bits)
    (predication-bits-tms-bits bits)))

(defsubst predication-logic-variable-free-p (predication)
  ;; whether or not this guy is variable-free
  (zerop (predication-bits-has-logic-variables (predication-bits predication))))

(defsubst predication-truth-value (predication)
  ;; returns the truth-value of a predication
  (predication-bits-truth-value (predication-bits predication)))

(defmethod (tms-bits predication) ()
  ;; give the tms-bits; used by TMS writers
  (predication-bits-tms-bits bits))

(defmethod ((setf tms-bits) predication) (new-value)
  ;; set the TMS bits field; used by TMS writers
  (setf (predication-bits-tms-bits bits) new-value))

(defmethod (been-in-before-p predication) ()
  ;; wheter or not this predication's been in before
  (not (zerop (predication-bits-ive-been-in-before bits))))

(defmethod ((setf been-in-before-p) predication) (new-value)
  ;; set the ive-been-in-before flag
  (setf (predication-bits-ive-been-in-before bits) (if new-value 1 0)))

(defun has-been-in-database-p (predication)
  (and (predicationp predication)
       (not (zerop 
	      (predication-bits-has-been-in-database
		(predication-bits predication))))))

;;; This is used to examine source code, not objects in the execution
;;; environment.  It is used by tell, ask, and the rule compilers.

(defun logic-variable-makers-in-thing (thing)
  ;; Return list of all variables in a predication, list, or variable.
  ;; Good for analyzing rule trigger patterns.
  ;; Deals properly with embedded lists & predications.
  (let ((variable-list nil))
    (labels ((collect-variables (thing)
	       (loop for rest = (if (predication-maker-p thing)
				    ;; convert thing to a list we can loop over, or just an atom
				    (second thing)	;predication
				    thing)	;list or atom
			      then (cdr rest)
		     ;; stop when it's not a list
		     while (and (consp rest) (not (logic-variable-maker-p rest)))
		     for next = (car rest)
		     doing (cond
			     ((logic-variable-maker-p next)
			       ;; found a variable, so remember it
			       (pushnew (logic-variable-maker-name next) variable-list))
			     ((or (listp next) (predication-maker-p next))
			      ;; recurse over lists and predications
			      (collect-variables next)))
		     finally
		       (cond
			 ((logic-variable-maker-p rest)
			   ;; found a variable, so remember it
			   (pushnew (logic-variable-maker-name rest) variable-list))
			 ((predication-maker-p rest)
			   ;; recurse over lists and predications
			   (collect-variables rest))))))
      (collect-variables thing)
      variable-list)))

;;; This produces the variables in some order, which is used later.
;;; Use it to find variables, so you can later construct the maps.
(defun logic-variables-in-thing (thing)
  ;; Return list of all variables in a predication, list, or variable.
  ;; Good for analyzing rule trigger patterns.
  ;; Deals properly with embedded lists & predications.
  (let ((variable-list nil))
    (labels ((collect-variables (thing)
	       (loop for rest = (if (predicationp thing)
				    ;; convert thing to a list we can loop over, or just an atom
				    (predication-statement thing)	;predication
				    thing)	;list or atom
			      then (cdr rest)
		     ;; stop when it's not a list
		     while (consp rest)
		     for next = (car rest)
		     doing (typecase next
			     (unbound-logic-variable
			       ;; found a variable, so remember it
			       (pushnew next variable-list :test #'compare-logic-variables))
			     ((or list predication)
			      ;; recurse over lists and predications
			      (collect-variables next)))
		     finally
		       (typecase rest
			 (unbound-logic-variable
			   ;; found a variable, so remember it
			   (pushnew rest variable-list :test #'compare-logic-variables))
			 (predication
			   ;; recurse over lists and predications
			   (collect-variables rest))))))
      (collect-variables thing)
      variable-list)))

(defun named-logic-variables-in-thing (thing)
  ;; like variables-in-thing, but ignores anonymous variables.
  (loop for variable in (logic-variables-in-thing thing)
	when (logic-variable-name variable) collect variable))

(defun contains-logic-variables-p (thing)
  ;; like variables-in-thing, except you only want a yes-or-no answer
  (typecase thing
    (unbound-logic-variable t)
    (cons
      ;; check for lv's in a list
      (loop for items = thing then (cdr items)
	    while (consp items)
	    thereis (contains-logic-variables-p (car items))
	    ;; check tail variables
	    finally (return (contains-logic-variables-p items))))
    (predication
      ;; check for lv's in a predication
      (if (predication-logic-variable-free-p thing)
	  ;; known in advance to be variable-free.
	  nil
	  ;; have to check now, since some vars might have been unified.
	  (contains-logic-variables-p (predication-statement thing))))
    (otherwise
      ;; not a structure that Joshua should take apart and not a lv, so NIL
      nil)))

(defmethod (flavor:transform-instance predication) ()
  ;; re-initialize the map to the new arguments
  (install-predicate-args-in-map self))

(defmethod (make-instance predication) (&rest ignore)
  (install-predicate-args-in-map self)
  (labels ((list-has-logic-variables-p (list)
	     (loop for items = list then (cdr items)	;"on" doesn't deal w/ tail vars
		   while (consp items)
		   doing (typecase (car items)
			   (unbound-logic-variable (return t))
			   (predication (unless (predication-logic-variable-free-p (car items))
					  (return t)))
			   (cons (when (list-has-logic-variables-p (car items))
				   (return t))))
		   finally
		     (when (typep items 'unbound-logic-variable) (return t)))))
    (setf (predication-bits-has-logic-variables bits)
	  (if (list-has-logic-variables-p statement) 1 0))))

;;; BUG: this should record the entire bits field.
(defmethod (:fasd-form predication) ()
  ;; Makes an instance of the right flavor.  Relies on make-instance method, above,
  ;; for destructuring and such.  Indexing is somebody else's job.
  (when (= (sys:%area-number self) sys:stack-area)
    (error "You can't dump a stack-consed predication."))
  `(make-predication ',(copy-list statement)
		     ,(sys:area-name (sys:%area-number self))))


(sys:defvar-resettable *print-predication-top-level-p* t)

(defun-in-flavor (print-self-internal predication) (stream)
  ;; subroutine shared by a couple of print-thingys.
  (dw:with-output-as-presentation (:object self
				   :type 'predication-presentation
				   :stream stream)
    (let ((*print-predication-top-level-p* nil))
      (format stream "~C" *joshua-open-predication-char*)	;opening bracket
      (when statement
	;; print the first arg
	(format stream "~S" (car statement))
	;; print the other args, preceeded by spaces
	(loop for rest-args = (cdr statement) then (cdr rest-args)
	      while (consp rest-args)
	      do (format stream " ~S" (car rest-args))
	      finally
		(when rest-args
		  ;; there is a tail variable
		  (format stream " ~C ~S" #\. rest-args))))
      (format stream "~C" *joshua-close-predication-char*))))	;closing bracket

(defmethod (sys:print-self predication)
	   (stream depth slashify-p)
  ;; how to print a predication with the ugly-printer
  (ignore depth slashify-p)
  (when (and (not (zerop (predication-bits-has-been-in-database bits)))
	     *print-predication-top-level-p*)
    (select (predication-bits-truth-value bits)
      (*true*)
      (*false* (write-char #\ stream))
      (*unknown* (write-char #\? stream))
      (*contradictory* (write-char #\ stream))))
  (print-self-internal stream))

(defmethod (print-without-truth-value predication) (&optional (stream *standard-output*))
  ;; Print the predication as if it were *TRUE*.  If stream is NIL, print to a string
  (if (null stream)
      ;; wants to print to a string
      (with-output-to-string (stream)
	(print-self-internal stream))
      ;; wants to print to a real string
      (print-self-internal stream)))

(proclaim '(special *variable-predicate-constructor*)) ;forward reference
(defsubst predicate-constructor-from-name
	  (name &optional (default *variable-predicate-constructor*))
  ;; get the constructor given the name of the predicate
  ;; SNORT!  Inserting declares in substs like this breaks SETF!
  ;;(declare (special *variable-predicate-constructor*)) ;forward reference
  (gethash name *predicate-constructor-hash-table* default))

(defun predicate-constructor-name-from-name (name &optional no-error-p)
  ;; use this instead of make-predicate-constructor-name, because the
  ;; latter depends on *package*; I once got screwed by BLOCKS:|[AND
  ;; ...] MAKER|.  make-predicate-constructor-name should only be used
  ;; by the guy who defines the constructor, namely define-predicate.
  (let ((constructor (predicate-constructor-from-name name nil)))
    (if constructor
	;; found it
	(sys:function-name constructor)
	;; didn't find it
	(if no-error-p
	    (make-predicate-constructor-name name)
	    ;; Give error message more likely to be informative than
	    ;; "NIL isn't a compiled function."
	    (error "Undefined predicate: ~S" name)))))

(defun make-predicate-constructor-name (name)
  ;; symbol unlikely to collide with others.  This should only be called
  ;; by make-predication.  Others are subject to package screws.  See
  ;; the comment in predicate-constructor-name-from-name, which explains
  ;; how I once got BLOCKS:|[AND ...] MAKER|.
  (declare (special *name-of-variable-predicate-constructor*)) ;forward reference
  (if (symbolp name)
      (symbolconc "[" name " ...] " 'maker)
      *name-of-variable-predicate-constructor*))

(defun make-predication (statement &optional area)
  ;; make a predication
  (declare (special *variable-predicate-constructor*)) ;forward reference
  (let* ((predicate (car statement))
	 (constructor (if (symbolp predicate)
			  (predicate-constructor-from-name predicate nil)
			  *variable-predicate-constructor*)))
    (if (and (symbolp predicate)
	     (or (null constructor) (not (fdefinedp constructor))))
	(if (flavor:find-flavor (predicate-is-synonym-for predicate)
				nil 'flavor::compile)
	    (make-instance (predicate-is-synonym-for predicate)
			   :statement statement
			   :area area)
	    (error "~S is an undefined predicate" predicate))
	;; make the predication (supplying the area if necessary), then initialize it
	(if area
	    (funcall constructor statement area)
	    (funcall constructor statement)))))

(compiler:defoptimizer (make-predication make-predication-optimizer) (form)
  ;; check for case of constant predicate, in which case we can get the constructor name now.
  ;; the optimized forms must not cons.  see with-stack-predication.
  (declare (special *name-of-variable-predicate-constructor*))	;forward reference
  (let ((structure (compiler:undo-list-optimization (second form)))	;flush si:%list-3 and so on
	(area (third form)))
    (flet ((optimize-form (predicate)
	     (when (and (symbolp predicate)
			(not (flavor:find-flavor (predicate-is-synonym-for predicate)
						 nil 'flavor::compile)))
	       (warn "~S is an undefined predicate" predicate)
	       (return-from optimize-form form))
	     ;; do an optimization, having extracted the predicate from somewhere
	     (let* ((constructor (if (symbolp predicate)
				     ;; use this instead of
				     ;; make-predicate-constructor-name,
				     ;; because the latter depends on
				     ;; *package*; I once got screwed by
				     ;; BLOCKS:|[AND ...] MAKER|.
				     (predicate-constructor-name-from-name predicate t)
				     *name-of-variable-predicate-constructor*)))
	       ;; new form is the constructor and the structure form,
	       ;; followed by initialization.
	       `(,constructor ,structure ,@(when area `(,area))))))
      (cond ((not (consp structure))
	     ;; (make-predication <non-list-object> ...) -- leave it alone.
	     form)
	    (t
	      ;; (make-predication <list> ...)
	      (case (first structure)
		(quote
		  (unless (consp (second structure))
		    ;; (make-predication '<non-list-object> ...)
		    (error "Structure arg to make-predication is a quoted non-list?"))
		  ;; (make-predication (quote (<pred> . <args>)) ...)
		  (optimize-form (first (second structure))))
		((list si:xr-bq-list data-stack-list)
		 (if (and (consp (second structure))
			  (eq (first (second structure)) 'quote))
		     ;; (make-predication (list/data-stack-list '... ))
		     (optimize-form (second (second structure)))
		     ;; (make-predication (list/data-stack-list <non-constant> ...))
		     form))
		((cons si:xr-bq-cons list* si:xr-bq-list* data-stack-list*)
		 (if (and (consp (second structure))
			  (eq (first (second structure)) 'quote))
		     ;; (make-predication (cons/list*/data-stack-list* '...))
		     (optimize-form (second (second structure)))
		     ;; (make-predication (cons/list*/data-stack-list* <non-constant> ...))
		     form))
		;; don't optimize what you don't understand!
		(otherwise form)))))))

(defun make-predication-form-p (form)
  (and (consp form) (eq (car form) 'make-predication)))

(defmacro with-predication-maker-parsed ((predicate-var args) form
					     &body body &environment env)
  ;; parse up a form like (make-predication '(...)).  Used in rule
  ;; compiler, in the places where it has to be generic over forms,
  ;; instead of instances.
  (once-only (form &environment env)
    `(progn (check-type ,form (satisfies predication-maker-p)
			"a predication source designator.")
	    (multiple-value-bind (,predicate-var ,args)
		(parse-predication-maker ,form)
	      ,@body))))

;;; Need :format-self version of this.

;;; Backquotage of [] expressions results in a make-predication form, not an predication,
;;; since it depends on run-time data.  Thus we have to be able to pretty-print calls
;;; to make-predication.

(defvar *print-make-predication-forms-prettily* nil)

(defun (:property make-predication gprint::formatter) (x)
  "Format make-predication forms so they look brackety."
  (cond ((and *print-make-predication-forms-prettily*
	      (consp (second x))
	      (member (first (second x))
		      'si:(xr-bq-cons xr-bq-list xr-bq-list* xr-bq-append xr-bq-nconc)))
	 ;; backquoted predication to be printed prettily
	 (let ((gprint::*gprint-backquote-depth* (1+ gprint::*gprint-backquote-depth*))
	       (list (gprint::unbackquotify (second x))))
	   (gprint:gformat "CC*[<~*>]C"
			   #\`
			   *joshua-open-predication-char*
			   (first list)
			   (rest list)
			   *joshua-close-predication-char*)))
	((and *print-make-predication-forms-prettily*
	      (consp (second x))
	      (eq (first (second x)) 'quote))
	 ;; quoted predication to be printed prettily
	 (let ((list (second (second x))))
	   (gprint:gformat "C*[<~*>]C"
			   *joshua-open-predication-char*
			   (first list)
			   (rest list)
			   *joshua-close-predication-char*)))
	(t
	  ;; something random, or not to be pretty-printed.
	  (gprint::format-function x))))
1
0;;;
;;; Here's the machinery for defining predicates and their associated models.
;;;

;;;
;;; First some subroutines for writing some of the methods, processing args, and so on.
;;;

(defun length-dotted (possibly-dotted-list)
  ;; "length" and last cons of possibly-dotted-list
  (declare (values length dotted-tail))
  (loop initially (when (atom possibly-dotted-list) (return (values 0 possibly-dotted-list)))
	for cons = possibly-dotted-list then (cdr cons) ;faster than "on"
	counting cons into length
	while (consp (cdr cons))
	finally (return (values length (cdr cons)))))

(defun check-predication-args-all-required (statement name number-args)
  ;; check args for predications whose args are all required.  Don't care about value, just error check.
  (multiple-value-bind (length tail) (length-dotted (cdr statement))
    (cond (tail
	    ;; bad tail
	    (error "Dotted tail ~S given to predicate ~S, which has no &REST argument: ~S"
		   tail name statement))
	  (( length number-args)
	   ;; wrong number args
	   (error "~:[More than~;Fewer than~] ~D arg~:P supplied to predicate ~S: ~S"
		  (< length number-args) number-args name statement)))))

(defun check-predication-args-optional-no-rest (statement name min-args max-args defaulter)
  ;; check args for predications with some &OPTIONAL args, but no &REST arg.  May return new map.
  (declare (sys:downward-funarg defaulter))
  (multiple-value-bind (length tail) (length-dotted (cdr statement))
    (cond (tail
	    ;; bad tail
	    (error "Dotted tail ~S given to predicate ~S, which has no &REST argument: ~S"
		   tail name statement))
	  (( min-args length max-args)
	   ;; acceptable number of args, check out defaulting.
	   (if (or (= length max-args) (null defaulter))
	       ;; all args supplied, or all defaults are NIL, so no need to re-cons
	       statement
	       ;; too few args and non-trivial defaulting, so re-cons statement
	       (apply defaulter statement)))
	  ((< length min-args)
	   ;; too few args
	   (error "Fewer than ~D arg~:P supplied to predicate ~S: ~S" min-args name statement))
	  (t
	   ;; too many args
	   (error "More than ~D arg~:P supplied to predicate ~S: ~S" max-args name statement)))))

(defun check-predication-args-no-optional-rest (statement name min-args rest-defaulter)
  ;; check args for predications with &REST arg, but no &OPTIONAL args.
  (declare (sys:downward-funarg rest-defaulter))
  (multiple-value-bind (length tail) (length-dotted (cdr statement))
    (cond ((< length min-args)
	   ;; too few args
	   (error "Fewer than ~D arg~:P supplied to predicate ~S: ~S" min-args name statement))
	  ((and (= length min-args) (null tail) rest-defaulter)
	   ;; exactly right # positional args supplied, but no tail for &REST and there is a default
	   (append statement (funcall rest-defaulter)))
	  (t
	    ;; either enough args supplied, or there's a tail, or the &REST default is NIL
	    statement))))

(defun check-predication-args-optional-rest (statement name min-args max-args
							  full-defaulter rest-defaulter)
  ;; check args for predications with both &OPTIONAL and &REST args
  (declare (sys:downward-funarg full-defaulter rest-defaulter))
  (multiple-value-bind (length tail) (length-dotted (cdr statement))
    (cond ((< max-args length)
	   ;; there are plenty of args to go around, no defaulting necessary
	   statement)
	  ((= length max-args)
	   ;; just enough to fill positional slots
	   (if (or tail (null rest-defaulter))
	       ;; either a tail was supplied, or default &REST arg is NIL
	       statement
	       ;; have to default the &REST arg
	       (append statement (funcall rest-defaulter))))
	  ((< length min-args)
	   ;; too few args
	   (error "Fewer than ~D arg~:P supplied to predicate ~S: ~S" min-args name statement))
	  (tail
	    ;; prematurely supplied tail variable
	    (error "Dotted tail in predication provided before &REST arg position: ~S"
		   statement))
	  (full-defaulter
	    ;; non-trivial default for some &OPTIONAL arg or the &REST arg
	    (apply full-defaulter statement))
	  (t
	    ;; all defaults are trivial, so no need to re-cons
	    statement))))

;;; Assume out-of-place tail variables replaced already by sufficient anonymous variables
(defun write-argument-mapping-method-for-predicate
       (name required-arg-specs optional-arg-specs rest-arg-spec destructure-ivs fixed-arglist)
  ;; write a method that defaults unsupplied arguments for which the
  ;; user specified defaults, and installs forwarding pointers to the
  ;; argument map in instance variables of destructured args.
  (flet ((write-defaulting-code ()
	   ;; write the code that checks the number of args and ensures defaults are enforced
	   (cond ((and (null optional-arg-specs) (null rest-arg-spec))
		  ;; all args required, so no defaulting -- just check number
		  `(check-predication-args-all-required
		     statement ',name ,(length required-arg-specs)))
		 ((and optional-arg-specs (null rest-arg-spec))
		  ;; some &optionals, no &rest -- therefore no tail variable
		  `(setq statement
			 ;; will re-cons argument map if defaulting dictates it has to.
			 (check-predication-args-optional-no-rest
			   statement ',name
			   ,(length required-arg-specs)
			   ,(+ (length required-arg-specs) (length optional-arg-specs))
			   ,(if (some #'cadr optional-arg-specs)
				;; some &OPTIONAL arg has non-trivial defaulting
				`#'(lambda (predicate-name ,@fixed-arglist)
				     ;; how to default args for this predication
				     (list predicate-name
					   ,@required-arg-specs
					   ,@(mapcar #'car optional-arg-specs)))
				;; all &OPTIONAL args are trivially defaulted to NIL.
				nil))))
		 ((and (null optional-arg-specs) rest-arg-spec)
		  ;; rest, but no optionals -- might be a tail variable
		  `(setq statement
			 ;; will re-cons statement if defaulting dictates it has to.
			 (check-predication-args-no-optional-rest
			   statement ',name
			   ,(length required-arg-specs)
			   ,(if (cadr rest-arg-spec)
				;; defaulter passed as a funarg
				`#'(lambda () ,(cadr rest-arg-spec))
				;; default is NIL, so no need to worry here
				nil))))
		 (t
		   ;; both optionals and rest -- might be a tail variable
		   `(setq statement
			  ;; will re-cons statement if defaulting dictates it has to.
			  (check-predication-args-optional-rest
			    statement ',name
			    ,(length required-arg-specs)
			    ,(+ (length required-arg-specs) (length optional-arg-specs))
			    ,(if (and (null (cadr rest-arg-spec))
				      (not (some #'cadr optional-arg-specs)))
				 ;; need no full defaulter, 'cause all is trivial
				 nil
				 ;; there is a nontrivial default somewhere (&OPTIONAL or &REST)
				 `#'(lambda (predicate-name ,@fixed-arglist)
				      (list* predicate-name
					     ,@required-arg-specs
					     ,@(mapcar #'car optional-arg-specs)
					     (or ,(car rest-arg-spec) ,(cadr rest-arg-spec)))))
			    ,(if (null (cadr rest-arg-spec))
				 ;; trivial rest-arg-default
				 nil
				 `#'(lambda () ,(cadr rest-arg-spec))))))))
	 (write-destructuring-code ()
	   ;; write code for destructuring elements of argument map into instance variables
	   (when destructure-ivs
	     (let* ((positional-arg-names
		      (append required-arg-specs (mapcar #'car optional-arg-specs)))
		    (locations
		      (sort (loop for name in destructure-ivs
				  for pos = (position name positional-arg-names)
				  when pos collect (cons name pos))	;deal with & words
			    #'< :key #'cdr))
		    (rest-arg-position (when (member (car rest-arg-spec) destructure-ivs)
					 (length positional-arg-names))))
	       (when rest-arg-position
		 (setq locations (nconc locations
					(list (cons (car rest-arg-spec) rest-arg-position)))))
	       `((let ((map (cdr statement)))	;flush predicate
		   ,@(loop with current-position = 0
			   for (name . name-pos) in locations
			   when ( current-position name-pos)
			     collect
			       `(setq map (nthcdr ,(- name-pos current-position) map))
			   do (setq current-position name-pos)
			   if (and rest-arg-position (= name-pos rest-arg-position))
			     collect `(setq ,(car rest-arg-spec) map)
			   else
			     collect `(if (consp map)
					  ;; Cassels advises EVCP's instead of
					  ;; logic variables.
					  (sys:%p-store-cdr-type-and-pointer
					    (locf ,name)
					    (sys:%p-cdr-code (locf ,name))
					    sys:dtp-external-value-cell-pointer
					    map)
					  ;; we've run off the end of the map, and are
					  ;; trying to destructure an &optional whose
					  ;; default was NIL, anyway.
					  (setq ,name nil)))))))))
    `((defmethod (install-predicate-args-in-map ,name) ()
	(declare (sys:function-parent ,name define-predicate))
	;; this will always exist, to check the right number of arguments.
	,(write-defaulting-code)
	;; this will only exist if you use :destructure-into-instance-variables.
	,@(write-destructuring-code)))))
  
(defmacro with-statement-destructured (arglist predication &body body)
  ;; useful for spreading some args into instance variables if you don't want to
  ;; do :DESTRUCTURE-INTO-INSTANCE-VARIABLES.
  `(destructuring-bind ,arglist (cdr ,(if (or (null predication)
					      (eq predication 'self))
					  'statement
					  `(predication-statement ,predication)))
     ,@body))

(defun process-predicate-args (args)
  (declare (values fixed-arglist required-arg-specs optional-arg-specs rest-arg-spec))
  ;; &REST and &OPTIONAL as in CL lambda-lists are also allowed, with the usual interpretations.
  ;;
  ;; Return values: a "fixed" arglist, i.e., one in which the &rest arg is not defaulted.
  ;;                names of required arguments
  ;;                names of optional arguments & their defaults
  ;;                name of rest argument
  ;;                rest arg default value
  (flet ((is-acceptable-arg-name (thing)
	   ;; thing must be either a proper symbol or a logic variable
	   (and (symbolp thing)
		(not (member thing lambda-list-keywords)))))
    (loop with context = 'required ;required, optional, rest, or rest-in-peace
	  with rest-arg-spec = nil
	  for arg in args
	  when (eq context 'rest-in-peace)
	    ;; found garbage after rest
	    do (error "Too much stuff after an &REST in predicate arglist ~S" args)
	  ;; now collect things into a "fixed" arglist, which has the rest arg undefaulted
	  ;; and logic variables replaced by their names.
	  if (consp arg)
	    if (eq context 'rest)
	      ;; collect just rest arg, not default
	      collect (first arg) into fixed-arglist
	    else ;loop indentation bug puts this in wrong place, but code is right
	      ;; collect defaulted arg
	      collect (list (first arg) (second arg)) into fixed-arglist
	  ;; collect undefaulted arg or lambda-keyword
	  else collect arg into fixed-arglist
	  if (eq arg '&optional)
	    ;; found &optional marker
	    do (unless (eq context 'required)
		 (error "&OPTIONAL in bad position in predicate arglist ~S; current context is ~A"
			args context))
	       (setq context 'optional)
	  else if (eq arg '&rest)
		 ;; found &rest marker
		 do (setq context 'rest)
	  else if (and (is-acceptable-arg-name arg) (eq context 'required))
		 ;; required variable
		 collect arg into required-arg-specs
	  else if (and (is-acceptable-arg-name arg) (eq context 'optional))
		 ;; undefaulted optional variable.  NIL is the "default default".
		 collect (list arg nil) into optional-arg-specs
	  else if (and (is-acceptable-arg-name arg) (eq context 'rest))
		 ;; undefaulted rest variable.  NIL is the "default default".
		 do (setq rest-arg-spec (list arg nil)
			  context       'rest-in-peace)
	  else if (and (consp arg)
		       (= (length arg) 2.)
		       (is-acceptable-arg-name (first arg)) 
		       (eq context 'rest))
		 ;; defaulted rest variable
		 do (setq rest-arg-spec (list (first arg) (second arg))
			  context       'rest-in-peace)
	  else if (and (consp arg)
		       (= (length arg) 2.)
		       (is-acceptable-arg-name (first arg))
		       (eq context 'optional))
		 ;; defaulted optional arg
		 collect (list (first arg) (second arg)) into optional-arg-specs
	  else do (error "Bad item ~S in predicate arglist; should be arg-symbol, &OPTIONAL, ~
                          (arg-symbol default), or &REST." arg)
	  finally (return (values fixed-arglist required-arg-specs optional-arg-specs rest-arg-spec)))))

;;;
;;; Now define some places to stash info about the predicate.
;;; We use a hash-table of all predicates
;;; 

(defvar *all-predicates* (make-hash-table))

(defstruct (predicate-descriptor)
  args-info
  arglist)

(defsubst predicate-max-args (args-info)
  ;; byte descriptor just like in system
  (ldb sys:%%arg-desc-max-args args-info))

(defsubst predicate-min-args (args-info)
  ;; byte descriptor just like in system
  (ldb sys:%%arg-desc-min-args args-info))

(defsubst predicate-rest-arg (args-info)
  ;; byte descriptor just like in system
  (ldb sys:%%arg-desc-rest-arg args-info))

(defun find-predicate-arglist (predicate)
  ;; given the name, find the arglist or nil if none.
  (let ((synonym (predicate-is-synonym-for predicate)))
    (let ((descriptor (gethash (or synonym predicate) *all-predicates*)))
      (when descriptor
	(values (predicate-descriptor-arglist descriptor) nil nil nil nil t)))))

(defmethod (virtual-data-p predication) ()
  (or (not (zerop (predication-bits-has-logic-variables bits)))
      (si:in-stack-or-temporary-area self)))


(defmethod (update-after-copying predication :default) (new-predication) new-predication)

(defun copy-object-if-necessary (object)
  (let ((variables nil))
    (labels ((copy (object)
	       (typecase object
		 (predication
		   (if (virtual-data-p object)
		       (let ((new-object (make-predication (copy (predication-statement object)) nil)))
			 (update-after-copying object new-object)
			 new-object)
		       object))
		 (cons
		   ;; just copy the list, 'cause you don't know what bound variables
		   ;; might be lurking -- but be nice and cdr-code the copy
		   ;; ---- someday maybe look for logic variables, like copy-unified-value
		   ;; ---- tries to, so we won't copy lists unnecessarily
		   (multiple-value-bind (length-to-copy tail)
		       (loop for object-cons = object then (cdr object-cons)
			     while (consp object-cons)
			     count t into length
			     finally (return (values length object-cons)))
		     (let ((copy (make-list (if tail (1+ length-to-copy) length-to-copy))))
		       (loop for copy-cons = copy then (cdr copy-cons)
			     for object-cons = object then (cdr object-cons)
			     repeat (1- length-to-copy)
			     do (setf (car copy-cons) (copy (car object-cons)))
			     finally (setf (car copy-cons) (copy (car object-cons)))
				     (when tail
				       (sys:%change-list-to-cons copy-cons)
				       (setf (cdr copy-cons) (copy tail))))
		       copy)))
		 (unbound-logic-variable
		   (let ((new-variable-assoc (assoc object variables :test #'eq)))
		     (if new-variable-assoc
			 (cdr new-variable-assoc)
			 (let ((new-variable (make-unbound-logic-variable
					       (logic-variable-name object))))
			   (push (cons object new-variable) variables)
			   new-variable))))
		 (otherwise object))))
      (copy object))))

;;;
;;; Now the guys who are the programmer-visible tip of this iceberg.
;;;

(defparameter *models* nil "List of all known models.")

(defun undefine-predicate-model (name)
  ;; remove this model
  (setq *models* (delete name *models*))
  (flavor:remove-flavor name))

(def-defining-form define-predicate-model
   :definer
   ((name instance-variables components &body options)
    "Define a model."
    (declare (zwei:indentation 1 7 3 1)) ;same as defflavor
    ;; force it to be built on predication
    (pushnew '(:required-flavors predication) options :test #'equal)
    (pushnew :abstract-flavor options)		;force this to be abstract
    `(progn (eval-when (eval load compile)
	      ;; interim kludge for Walter
	      (si:defflavor-with-parent (,name define-predicate-model)
					,name ,instance-variables ,components
		,@options)
	      (pushnew ',name *models*))
	    (record-source-file-name ',name 'define-predicate-model)))
   :killer undefine-predicate-model
   :shower
   ((form)
    (let ((name (second form)))
      (cond ((not (symbolp name))
	     ;; yucky name
	     (zwei:barf "Malformed predicate model name: ~S" name))
	    ((member name *models*)
	     ;; already defined
	     (zwei:typein-line "Evaluating this would redefine the predicate model ~S." name))
	    (t
	      ;; not already defined
	      (zwei:typein-line "Evaluating this would define the predicate model ~S for the first time."
				name))))
    t)
   :type-name "Predicate Model")


(defun undefine-predicate (name)
  ;; how to kill a define-predicate form
  ;; remove name from hash-table of all predicates
  (remhash name *all-predicates*)
  ;; remove constructor from hash table
  (remhash name *predicate-constructor-hash-table*)
  (let ((constructor-name (predicate-constructor-name-from-name name t)))
    ;; clobber the constructor
    (when constructor-name (fundefine constructor-name)))
  ;; clobber the flavor
  (when (flavor:find-flavor name nil) ;dont' blow up if already undefined
    (remprop name 'si:flavor-parent)
    ;; IWBNI this did the constructor fundefine itself.
    (flavor:remove-flavor name))) 

(def-defining-form define-predicate
   :definer
   ((name args &optional (model-and-other-components '(default-predicate-model))
	  &body options
	  &aux alternative-arglist constructor-name destructure-ivs area-keyword)
    "Define a predicate."
    (declare (zwei:indentation 1 7 3 1))	;same as defflavor
    (multiple-value-bind (fixed-arglist required-arg-specs optional-arg-specs rest-arg-spec)
	(process-predicate-args args)
      (setq options (copy-list options))	;so we can smash it
      (flet ((maybe-car (x) (if (consp x) (car x) x)))	; deal with flavor syntax
	;; figure out what arguments he wants spread into instance variables.
	(setq destructure-ivs (find :destructure-into-instance-variables
				    options :key #'maybe-car))
	(setq options (delete :destructure-into-instance-variables options :key #'maybe-car))
	(cond ((listp destructure-ivs)		;includes nil, but that's ok
	       ;; flush the keyword and cdr is list of what he wants destructured
	       (setq destructure-ivs (cdr destructure-ivs)))
	      ((eq destructure-ivs :destructure-into-instance-variables)
	       ;; wants them all destructured
	       (setq destructure-ivs
		     (append required-arg-specs (mapcar #'maybe-car optional-arg-specs)))
	       (when rest-arg-spec
		 ;; put rest arg in place where it'll be in natural position
		 (setq destructure-ivs (nconc destructure-ivs (list (first rest-arg-spec))))))
	      (t
		(error "Bad :DESTRUCTURE-INTO-INSTANCE-VARIABLES option: ~S" destructure-ivs)))
	;; see if the :arglist option was given, and remove it if so
	(setq alternative-arglist (second (find :arglist options :key #'maybe-car)))
	(when alternative-arglist (setq options (delete :arglist options :key #'maybe-car)))
	;; see if the :area-keyword option was given, and parse it if so
	(setq area-keyword (second (find :area-keyword options :key #'maybe-car)))
	(when area-keyword (setq options (delete :area-keyword options :key #'maybe-car)))
	(setq area-keyword (intern (if area-keyword (string area-keyword) "AREA")))
	;; it's legal for users to specify their own constructors, since
	;; the flavor system allows the use of multiple :constructor
	;; frobbies.  It's unlikely to be useful, though.
	)
      ;; figure out a name for the constructor
      (setq constructor-name (make-predicate-constructor-name name))
      (unless (member 'predication model-and-other-components)
	(setq model-and-other-components (append model-and-other-components '(predication))))
      ;; error check for undefined flavor in model-and-other-components
      ;; to avoid later potential type redefinition problems
      (loop for flavor-name in model-and-other-components do
	(when (not (flavor:find-flavor flavor-name nil 'compile))
	  (error "~s is not the name of a flavor or predicate model" flavor-name)))
      ;; now we grok the implications  of the arglist
      (let* ((argument-mapping-methods (write-argument-mapping-method-for-predicate
					 name required-arg-specs optional-arg-specs
					 rest-arg-spec destructure-ivs fixed-arglist)))
	`(progn 
	   (record-source-file-name ',name 'define-predicate)
	   (si:defflavor-with-parent (,name define-predicate)
				     ,name
				     ,destructure-ivs	;these are instance vars 
				     ,model-and-other-components
	     (:constructor ,constructor-name
	      (statement &optional (,area-keyword sys:working-storage-area)))
	     ,@options)
	   ;; write method that keeps the statement consistent
	   ;; used in looping over args to a predication
	   ,@argument-mapping-methods
	   ;; set up some debug-info in the flavor defstruct
	   (setup-predicate-args-info ',name
				      ,(length required-arg-specs)
				      ,(length optional-arg-specs)
				      ,(not (null rest-arg-spec))
				      ',(if alternative-arglist
					    alternative-arglist args))
	   ;; ensure constructors will be defined at load time.
	   ;; this can't put the function object in, because of incremental compilation
	   (setf (predicate-constructor-from-name ',name nil) ',constructor-name)
	   (compile-flavor-methods ,name)
	   ;; return the name
	   ',name)
	)))
   :killer undefine-predicate
   :shower
   ((form)
    ;; how to figure out what a define-predicate form will do
    (let ((name (second form)))
      (cond ((not (symbolp name))
	     (zwei:barf "Malformed predicate name: ~S" name))
	    ((predicate-constructor-from-name name nil)
	     ;; already defined
	     (zwei:typein-line "Evaluating this would redefine the predicate ~S." name))
	    (t
	      ;; not already defined
	      (zwei:typein-line
		"Evaluating this would define the predicate ~S for the first time."
		name))))
    ;; prevent further expansion
    t)
   :type-name "Predicate")

(defun setup-predicate-args-info (predicate-name number-of-required number-of-optional rest-arg arg-list)
  (let* ((args-info 0))
    ;; bash the arity stuff into args-info
    (setf (predicate-max-args args-info) (+ number-of-required number-of-optional))
    (setf (predicate-min-args args-info) number-of-required)
    (setf (predicate-rest-arg args-info) (if rest-arg 1 0))
    (setf (gethash predicate-name *all-predicates*)
	  (make-predicate-descriptor :args-info args-info
				     :arglist arg-list))))

;;; Note that it's a bug to put methods on synonyms, they should go on either a model or the
;;; canonical version.
(def-defining-form define-predicate-synonym
   :definer
   ((new-name old-name)
    ;; define new-name to be a synonym for old-name, without defflavoring new-name.
    ;; Keeps you out of trouble with globalized symbols, like AND.
    `(progn (record-source-file-name ',new-name 'define-predicate-synonym)
	    ;; flush existing definition, if any
	    (undefine-predicate ',new-name)
	    ;; install target predicate's constructor in this guy's slot
	    (setf (predicate-constructor-from-name ',new-name nil)
		  ;; allow it to get the name even if the def-pred for
		  ;; old name isn't loaded yet.
		  ',(predicate-constructor-name-from-name old-name t))
	    ;; keep track of the synonym relationship
	    (record-predicate-synonyms ',new-name ',old-name)
	    ;; return the name
	    ',new-name))
   :killer undefine-predicate-synonym
   :shower
   ((form)
    ;; how to yatter mindlessly about one of these things
    (unless (and (every #'symbolp (cdr form))
		 (null (cdddr form)))
      (zwei:barf "Malformed DEFINE-PREDICATE-SYNONYM form: ~S" form))
    (let* ((new-name (second form))
	   (old-name (third form))
	   (existing-target (predicate-is-synonym-for new-name)))
      (cond (existing-target
	      ;; already defined as a synonym
	      (zwei:typein-line "~S is already a synonym for the predicate ~S.  ~
                                 Evaluating this will ~:[make it be a synonym for the predicate ~S ~
                                 instead.~;~*just say that again.~]"
				new-name existing-target (eq existing-target old-name) old-name))
	    ((predicate-constructor-from-name new-name nil)
	     ;; not already a synonym for something else, but now a predicate in its own right
	     (zwei:typein-line "~S is already defined as a predicate in its own right; ~
                                ~&evaluating this will undo that and make ~S a synonym for ~
                                the predicate ~S."
			       new-name new-name old-name))
	    (t
	      ;; completely undefined
	      (zwei:typein-line "Evaluating this will make ~S be a synonym for the predicate ~S."
				new-name old-name))))
      ;; prevent further macroexpansion
      t)
   :type-name "Predicate Synonym")

(defun parse-predication-maker (form)
  ;; extract the predicate from things predication-maker forms
  (declare (values predicate args))
  (destructuring-bind (predicate &rest args) (predication-maker-statement form)
    (values (predicate-is-synonym-for predicate) args)))
1
0;;;
;;; How users define handlers for a model.
;;;

(defun undefine-predicate-method (method-spec)
  ;; define-predicate-method is data-driven; depends on what part of the
  ;; protocol is being hacked.  see the define-protocol-function of the
  ;; protocol element you're interested in.
  (check-type method-spec joshua-protocol-function-spec "a Joshua protocol function-spec")
  (funcall (get (joshua-fspec-protocol method-spec) 'zwei:kill-definition) method-spec))

(def-defining-form define-predicate-method
   :definer
   (((protocol-function flavor &rest options) args &body body)
    ;; define-predicate-method is data-driven; depends on what part of
    ;; the protocol is being hacked.  see the define-protocol-function
    ;; of the protocol element you're interested in.
    (let ((fspec `(,protocol-function ,flavor ,@options)))
      (check-type fspec joshua-protocol-function-spec "a Joshua protocol function-spec")
      (apply (get (joshua-fspec-protocol fspec) 'protocol-definer) fspec args body)))
   :shower
   ((form &aux handler)
    ;; define-predicate-method is data-driven; depends on what part of
    ;; the protocol is being hacked.  see the define-protocol-function
    ;; of the protocol element you're interested in.
    (check-type (second form) joshua-protocol-function-spec "a Joshua protocol function-spec")
    (setq handler (get (joshua-fspec-protocol (second form)) 'protocol-shower))
    (cond (handler
	    ;; if there is a handler, call it and stop.
	    (funcall handler form)
	    t)
	  (t
	    ;; no handler, so macroexpand and try again.
	    nil)))
   :killer undefine-predicate-method
   :parser
   ((bp-after-definer)
    ;; this is so define-predicate-method forms sectionize properly.
    ;; cribbed from (:PROPERTY DEFMETHOD
    ;; ZWEI:DEFINITION-FUNCTION-SPEC-PARSER) the next S-expression has
    ;; to be (<protocol-name> <model> &rest <other-stuff>)
    (declare (values fspec type str error-p))
    (let ((next-form-bp (zwei:forward-sexp bp-after-definer)))
      (when next-form-bp
	;; managed to find the end of the next S-expression
	(multiple-value-bind (fspec error-p)
	    (zwei:read-fspec-item-from-interval bp-after-definer next-form-bp)
	  (if (or error-p (symbolp fspec) (not (sys:validate-function-spec fspec)))
	      ;; error case
	      (values nil nil nil t)
	      ;; found a spec, return the fspec and the type that will
	      ;; be used to look up the definition. This must agree with
	      ;; the type returned by function parent etc.
	      (values fspec 'define-predicate-method 
		      (zwei:string-interval bp-after-definer next-form-bp t) nil))))))
   :type-name "Predicate Method")



(defun stackify-thing (thing environment *known-lvs*)
  ;; Take a structure and return equipment required to cons it on the
  ;; stack.  Returns a possibly-new reference to the thing, bindings to
  ;; be put in the STACK-LET* form, and a flag that tells whether or not
  ;; it's going to use the data stack.  (The latter lets you avoid the
  ;; overhead of consing a data stack frame (via sys:with-data-stack) if
  ;; you don't need it.)
  (declare (values new-thing new-bindings data-stack-used-p))
  (labels ((stackify-make-predication-form (form &aux (structure (second form))
						 (predication-name (sys:gensymbol "PREDICATION")))
	     ;; stackify something like (make-predication '(a . x))
	     (declare (values new-thing new-bindings data-stack-used-p))
	     (unless (member (third form) '(:stack nil))
	       (error "Area specified for make-predication form being stackified: ~S" form))
	     (let ((make-function (first (make-predication-optimizer form))))
	       (multiple-value-bind (new-thing new-bindings)	;know we're gonna use the data stack.
			  (stackify-form structure)	;eliminate gratuitous consing
			(values predication-name
				`(,@new-bindings
				  ;; stack-let puts in area
				  (,predication-name
				   (,make-function ,new-thing ,@(cddr form) :stack)))
				t))))
	   (stackify-form (form)
	     ;; how to stackify a lisp form -- predications get stackified.
	     (declare (values new-thing bindings data-stack-used-p))
	     (let ((bindings nil)
		   (data-stack-used-p nil))
	       ;; (format *debug-io* "~&~'bForm:~ ~S" form)
	       (values
		 (lt:copyforms
		   ;; code-walk the form to find subforms which can be stackified.
		   #'(lambda (subform kind usage)
		       (ignore kind usage)
		       ;; (format *debug-io* "~&~'bSubform:~ ~S" subform)
		       (cond ((make-predication-form-p subform)
			      ;; a make-predication subform, so handle it specially
			      (multiple-value-bind (new-form new-bindings new-data-stack-used-p)
				  (stackify-make-predication-form subform)
				(setq bindings (append bindings new-bindings))
				(when new-data-stack-used-p
				  (setq data-stack-used-p t))
				new-form))
			     ((and (consp subform)
				   (assoc (car subform) si:*stack-let-operations*))
			      (let ((name (sys:gensymbol "FORM"))
				    (walked-rest
				      (loop for subsubform in (rest subform)
					    collect (multiple-value-bind (new-form new-bindings)
							(stackify-form subsubform)
						      (setq bindings (append bindings new-bindings))
						      new-form))))
				(setq bindings (append bindings `((,name
								   (,(first subform)
								    .,walked-rest)))))
				(setq data-stack-used-p t)
				name))
			     (t subform)))
		   form
		   ;; this is to prevent lossage of nested
		   ;; macros.  An ASK in the action of a rule
		   ;; that referenced trigger variables would
		   ;; lose, unless it got the variable analyses
		   ;; from the rule.  This ensures the
		   ;; macroexpansion occurs once, when that
		   ;; information is available.
		   :expand-all-macros t
		   :environment environment)
		 bindings
		 data-stack-used-p))))
    (cond ((make-predication-form-p thing)
	   (stackify-make-predication-form thing))
	  (t (stackify-form thing)))))


;;; Here are the macro versions of TELL and ASK.  They have positional
;;; rather than keyword arguments.

(defmacro tell (predication &key justification)
  ;; convert to positional form, defaulting correctly.
  (declare (values canonical-version new-or-old))
  `(tell-internal ,predication *true* ,justification))

(defmacro ask (query continuation &key (do-backward-rules t) (do-questions nil)
	       &environment environment)
  (let* ((new-lvs-in-thing (set-difference (logic-variable-makers-in-thing query)
					   *known-lvs*))
	 (all-lvs (union new-lvs-in-thing *known-lvs*)))
    (multiple-value-bind (new-thing new-bindings used-data-stack-p)
	;; a larger hammer than we probably need, but...
	(stackify-thing query environment all-lvs)
      (let ((new-form
	      `(ask-internal ,new-thing *true*
			     ;; substitute lexicals for logic variables in the continuation
			     ,continuation
			     ,do-backward-rules
			     ,do-questions)))
	(when new-bindings
	  (setq new-form `(stack-let* ,new-bindings ,new-form)))
	(when used-data-stack-p
	  ;; we consed on the data stack, so we gotta create the appropriate frame.
	  (setq new-form `(sys:with-data-stack ,new-form)))
	(when new-lvs-in-thing
	  (setq new-form `(with-unbound-logic-variables ,new-lvs-in-thing
			    (compiler-let ((*known-lvs* ',all-lvs))
			      ,new-form))))
	;; return the form.
	new-form))))


(defsubst ask-query (backward-support)
  (first backward-support))

(defsubst ask-query-truth-value (backward-support)
  (second backward-support))

(defsubst ask-database-predication (backward-support)
  (third backward-support))

(defsubst ask-derivation (backward-support)
  (rest (rest backward-support)))

;;; A number of functions to use in the continuation to ask.  These two
;;; are just for convenience, allowing the the user to say (ask [...]
;;; #'print-query)

(defun print-query-internal (backward-support stream)
  (select (ask-query-truth-value backward-support)
    (*true*
     (prin1 (ask-query backward-support) stream))
    (*false*
     (princ "(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")[not 0" stream)
     (print-without-truth-value (ask-query backward-support) stream)
     (princ "2]0" stream))))

(defun print-query (backward-support &optional (stream *standard-output*))
  (check-type backward-support cons "backward-support from a query")
  (terpri stream)
  (print-query-internal backward-support stream)
  nil)

(defun say-query (backward-support &optional (stream *standard-output*))
  (check-type backward-support cons "backward-support from a query")
  (fresh-line stream)
  (say (ask-query backward-support) stream))

;;; This applies a function to each element in the backward-support. 
;(defun map-over-derivation (derivation function)	
;  (declare (sys:downward-funarg function))
;  (labels ((map-over-support (support)
;	     (cond ((consp support)
;		    (funcall function (car support))
;		    (map nil #'map-over-support (cdr support)))
;		   (t 
;		      (funcall support-continuation support)))))
;    (loop for derivation-item in derivation
;	  do
;      (map-over-support support-item))))

;;; Derivation is always a list.
;;;  The first element is always the (unified) query.  Almost always the query is positive.
;;;  The second is always the truth value of the query.
;;;  Possibilities for the rest are:
;;;  (<query> <t/f> <database predication>)
;;;  (<query> <t> AND <conjunct1 derivation> <conjunct2 derivation> ...)
;;;  (<query> <t/f> (RULE <rule name>) <conjunct1 derivation> <conjunct2 derivation> ...)
;;;  (<query> <t/f> (QUESTION <question name>) <succeed argument>)
;;;  (<query> <t/f> KNOWN <derivation>)
;;;  (<query> <t/f> PROVABLE <derivation>)
;;;
(defun print-query-results (backward-support &key (stream *standard-output*) (printer #'prin1))
  (fresh-line stream)
  (let ((relative-indentation 2))
    (typecase backward-support
      (cons
	(destructuring-bind (ignore truth-value type . rest) backward-support
	  (print-query-internal backward-support stream)
	  (princ " succeeded" stream)
	  (sys:with-indentation (stream relative-indentation)
	    (terpri stream)
	    (etypecase type
	      (predication
		(print-database-predication-without-truth-value type stream)
		(princ " was " stream)
		(present truth-value 'truth-value :stream stream)
		(princ " in the database" stream))
	      (cons
		(princ "It was derived from " stream)
		(princ (case (first type)
			 (rule "rule")
			 (question "question")
			 (otherwise (first type)))
		       stream)
		(princ " " stream)
		(princ (second type) stream)
		;; rules can have support of nil when the 2if 0part is trivial
		(when (first rest)
		  (print-query-results (first rest) :stream stream))
		(loop for sub-support in (rest rest)
		      do (when sub-support
			   (fresh-line stream)
			   (print-query-results sub-support :stream stream))))
	      (symbol
		(ecase type
		  ((and or)
		   (cond ((null rest)
			  (princ "it's true by convention" stream))
			 (t
			  (sys:with-indentation (stream relative-indentation)
			    (print-query-results (first rest) :stream stream)
			    (loop for sub-support in (rest rest)
				  do (fresh-line stream)
				     (print-query-results sub-support :stream stream))))))
		  ((known provable)
		   (select truth-value
		     (*true*
		      (sys:with-indentation (stream relative-indentation)
			(print-query-results (first rest) :stream stream)))
		     (*false*
		      (princ "it was not " stream)
		      (princ type stream))))))))))
      (otherwise
	(funcall printer backward-support stream)))))
  
;;; This follows the same conventions as above, ignoring ors and null
;;; leaves in the support Rules and questions are ovals, predications
;;; and anything we don't know about are rectangles.
;;;

(defun graph-query-results (backward-support
			    &key (orientation :vertical) (stream *standard-output*)
			    (printer #'prin1))
  ;; graph the support tree of the answer to an ASK.
  ;; Use print-query-results on non-graphics streams
  (unless (send-if-handles stream :graphics-stream-p)
    (print-query-results backward-support :stream stream)
    (return-from graph-query-results nil))
  (with-character-size (:smaller stream :bind-line-height t)
    (fresh-line stream)
    (format-graph-from-root
      backward-support
      #'(lambda (support stream)
	  (typecase support
	    (cons
	      (destructuring-bind (ignore truth-value type . ignore) support
		(multiple-value-bind (database-p reason shape)
		    (etypecase type
		      (predication
			(values t
				(select truth-value
				  (*true* "Database")
				  (*false* "Database  (False)"))
				:rectangle))
		      (cons
			(values nil type :oval))
		      (symbol
			(values nil type :oval)))
		  (dw:surrounding-output-with-border (stream :shape shape)
		    (dw::centering-lines (stream)
		      (unless (and database-p
				   (eql truth-value *true*)
				   (predication-logic-variable-free-p type))
			;; don't print the query if it matches the database exactly
			(print-query-internal support stream)
			(terpri stream))
		      (with-character-face (:italic stream)
			(typecase reason
			  (string
			    (princ reason stream))
			  (cons
			    (case (first reason)
			      (rule
				(princ "Rule" stream))
			      (question
				(princ "Question" stream))
			      (otherwise
				(prin1 (first reason) stream)))
			    (princ " " stream)
			    (prin1 (second reason) stream))
			  (otherwise
			    (prin1 reason stream))))
		      (when database-p
			(terpri stream)
			(print-database-predication-without-truth-value type stream)))))))
	    (otherwise
	      (funcall printer support stream))))
      #'(lambda (support)
	  (and (consp support)
	       (remove nil 
		       (rest (rest (rest support))))))
      :stream stream
      :default-drawing-mode :reverse-arrow
      ;; If you want to use :reverse-arrow you have to have branch-point :at-parent
      :branch-point :at-parent
      :orientation orientation
      :border nil)))
;
;(defun graph-query-results (derivation
;			    &key (printer #'prin1)	
;			    (orientation :horizontal) (stream *standard-output*))
;  ;; graph the support tree of the answer to an ASK.
;  ;; Use print-query-results on non-graphics streams
;  (unless (send-if-handles stream :graphics-stream-p)
;    (print-query-results query query-support :printer printer :stream stream)
;    (return-from graph-query-results nil))
;  ;; Don't show ors and the empty or branches
;  (flet ((strip-ors (object)
;	   (when (and (consp object)
;		      (eq (car object) 'or))
;	     ;; There's only one non-nil leg in the support for or - strip all of the others
;	     (setf object (some  #'identity (cdr object))))
;	   object)
;	 (print-heading (heading stream)
;	   (with-character-style ('(:dutch :italic :smaller) stream)
;	     (with-underlining (stream) (princ heading stream)))))
;    (fresh-line stream)
;    (format-graph-from-root
;      `(,query ,query-support)
;      #'(lambda (obj stream)
;	  (let* ((object-type
;		   (typecase obj
;		     (symbol (if (question-p obj) :question :unknown))	;*** might be an ASK method, too
;		     (predication :predication)
;		     (Cons (cond ((and (symbolp (car obj))
;				       (backward-rule-p (car obj)))
;				  :rule)
;				 ((predicationp (car obj))
;				  :predication)
;				 (t :unknown)))))
;		 (object-to-print (if (consp obj) (car obj) obj))
;		 (fancy-node-p (member object-type '(:rule :question))))
;	    (dw:surrounding-output-with-border (stream
;						 ;; preds are rectangles, all else is oval
;						 :shape (if fancy-node-p
;							    :oval
;							    :rectangle)
;						 :label (when fancy-node-p 
;							  (print-heading (string-capitalize object-type) stream))
;						 :label-alignment :center
;						 :label-position :top )
;	      (funcall printer object-to-print stream))))
;      #'(lambda (obj)
;	  (when (consp obj)
;	    (remove nil 
;		    (if (predicationp (car obj))
;			;; must be the root object
;			(map 'list #'strip-ors (strip-ors (cdr obj)))
;			(map 'list #'strip-ors (cdr obj))))))
;      :default-drawing-mode :arrow
;      :stream stream
;      :orientation orientation
;      :border nil)))

;;; This needs to si:parse-body-declarations so they can occur at the block definition.
(defun expand-do-queries (name varspecs body)
  ;; expander function for the two macros that follow.
  (loop for (var query . options) in (reverse varspecs)
	for continuation-body = `(progn ,@body) then form
	for continuation = `#'(lambda (,var) ,continuation-body)
	for form = `(ask ,query ,continuation ,@options)
	;; enclose in a (block nil ...) to allow return to be used in the body.
	finally (return `(block ,name ,form))))

;;; This is a good model to give to users to explain how backward rules compile.
(defmacro do-queries* (varspecs &body body)
  ;; iterative syntax like do-list and so on, for people who don't like
  ;; continuation-passing style.
  (expand-do-queries nil varspecs body))

(defmacro do-queries-named* (name varspecs &body body)
  ;; like do-queries*, but has a named block so return-from makes sense
  (expand-do-queries name varspecs body))

(defsubst ask-question (question predication truth-value continuation)
  ;; how to ask a question.
  (funcall question predication truth-value continuation))
