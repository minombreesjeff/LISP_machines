;;; -*- Mode: Joshua; Package: JI; Syntax: Joshua; Base: 10; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;
;;; How to compile rules.
;;;

(defparameter *rule-control-structures* nil
  "Registry of rule control structures.")

(defsubst rule-control-structure-p (x)
  ;; whether or not you've got a rule in your hands, there
  (member x *rule-control-structures*))

(defun rule-control-structure-compiler (rule-control-structure)
  ;; the thing that knows how to compile rules with this kind of control structure
  (get rule-control-structure 'rule-control-structure-compiler))

(defvar *fatal-compilation-error*)

(defun fatal-compilation-error (error &rest args)
  (apply #'warn error args)
  (setq *fatal-compilation-error* t)
  ;; return nil, so it can be used as a (bogus) form
  nil)

(def-defining-form defrule
   ;; how to define a rule
   :definer
   ((rule-name (control-structure &rest control-structure-args) if if-part then then-part
	       &environment environment)
    (compiler:compiler-warnings-context-bind
      (let ((compiler:default-warning-function rule-name)
	    (compiler:default-warning-definition-type 'defrule)
	    (*fatal-compilation-error* nil))
	  (unless (symbolp rule-name)
	    (fatal-compilation-error "~S is not a symbol suitable for naming a rule"
				     rule-name))
	  ;; first check the args
	  (unless (rule-control-structure-p control-structure)
	    (fatal-compilation-error "~S is not a rule control structure" control-structure))
	  (unless (listp control-structure-args)
	    (fatal-compilation-error "~S is not a list of keyword/value pairs"
				     control-structure-args))
	  (when (and (string-equal if 'then) (string-equal then 'if))
	    ;; if in the "wrong" order; HES claims this is cuter for backward rules.
	    ;; I disagree, but it's cheap to allow it. -- sgr
	    (rotatef if then)
	    (rotatef if-part then-part))
	  (unless (string-equal if 'if)
	    (fatal-compilation-error
	      "IF token is missing or misplaced in the rule specification"))
	  (unless (string-equal then 'then)
	    (fatal-compilation-error
	      "THEN token is missing or misplaced in the rule specification"))
	  (let ((result (or *fatal-compilation-error*
			    ;; generate a form to compile in place of this
			    (apply (rule-control-structure-compiler control-structure)
				   rule-name if-part then-part
				   environment control-structure-args))))
	    (cond (*fatal-compilation-error*
		   (warn "Compilation of this rule skipped")
		   nil)
		  (t result))))))
   :killer undefrule
   :shower
   ((form)
    ;; how m-X Show Effect of Definition should hack a defrule form.
    (let ((rule-name (second form))
	  (rule-control-structure (first (third form)))) ; could parse control-structure-args, I suppose
      (cond ((not (symbolp rule-name))
	     (zwei:barf "Malformed rule name: ~S" rule-name))
	    ((null (rule-debug-info rule-name))
	     ;; this rule is already defined (although possibly disarmed)
	     (zwei:typein-line
	       "Evaluating this would define the ~S rule ~S for the first time."
	       rule-control-structure rule-name))
	    (t
	      ;; not already defined
	      (zwei:typein-line
		"Evaluating this would redefine the ~S rule ~S (currently ~:[disarmed~;armed~])."
		rule-control-structure rule-name (rule-armed-p rule-name)))))
    ;; return t to prevent further macroexpansion
    t)
   :type-name "Rule")

;;; By now you've realized that the real power is in the rule-control-structures.
(def-defining-form define-rule-control-structure
		   :definer
  ((name arglist &body body)
   ;; be nice to Zmacs, put body in right place, register this, and return the name
   `(progn (record-source-file-name ',name 'define-rule-control-structure)
	   (defun (:property ,name rule-control-structure-compiler) ,arglist
	     (declare (sys:function-parent ,name define-rule-control-structure))
	     ,@body)
	   (pushnew ',name *rule-control-structures*)
	   ',name))
  :killer
  ((name)
   (setq *rule-control-structures* (delete name *rule-control-structures*))
   (fundefine `(:property ,name rule-control-structure-compiler)))
  ;;:shower nil
  :type-name "Rule Control Structure")

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")
0;;;
;;; Analyzing rule triggers and actions.
;;;

(defun analyze-trigger (trigger trigger-variable-analyses-so-far &optional name)
  ;; figure out the variable situation in this trigger.
  (loop with analyses = trigger-variable-analyses-so-far
	with named-variables = (logic-variable-makers-in-thing trigger)
	for variable in (if name (cons name named-variables) named-variables)
	for canonical = (find-corresponding-analysis variable analyses)
	if canonical
	  ;; recurrence of already-known variable, so note its occurs in another trigger
	  do (push trigger (variable-analysis-triggers-found-in canonical))
	else
	  ;; first occurrence of this variable, so construct an analysis
	  do (push (make-variable-analysis :variable variable
					   :triggers-found-in (list trigger))
		   analyses)
	finally (return analyses)))

(defun analyze-action (action action-variable-analyses-so-far trigger-variable-analyses)
  ;; figure out the variable situation in this action.
  (loop with analyses = action-variable-analyses-so-far
	for variable in (logic-variable-makers-in-thing action)
	for trigger-canonical = (find-corresponding-analysis variable trigger-variable-analyses)
	for action-canonical = (find-corresponding-analysis variable analyses)
	if trigger-canonical
	  ;; this is a trigger variable, so just note it is in this action
	  do (push action (variable-analysis-actions-found-in trigger-canonical))
	else if action-canonical
	       ;; recurrence of this action variable, so just note it is in this action
	       do (push action (variable-analysis-actions-found-in action-canonical))
	else
	  ;; first occurrence of this variable seen, so make an action analysis
	  do (push (make-variable-analysis :variable variable
					   :actions-found-in (list action))
		   analyses)
	finally (return analyses)))
1

0;;;; Parsing up rule control structure arguments.

;;; Make backward chaining do this, too.
(defmacro with-control-structure-arguments
	  ((arg-names control-structure-args
		      &optional (allow-unknown-p (sys:gensymbol "UNKNOWN-ARGS") supplied-p))
	   &body body
	   &aux (keywords (mapcar #'(lambda (x)
				      (intern (string x)
					      (find-package 'keyword)))
				  arg-names)))
  ;; Parse up certain control structure args.  If allow-unknown-p is supplied, bind it
  ;; to the remaining ones.  If it's not supplied, cause an error if there are any remaining.
  ;; Execute the body in that context.
  `(let ,(loop for arg-name in arg-names
	       for keyword in keywords
	       collecting `(,arg-name (getf ,control-structure-args ,keyword)))
     (si:with-rem-keywords (,allow-unknown-p ,control-structure-args ',keywords)
       ,@(when (not supplied-p)
	   `((when ,allow-unknown-p
	       (error "Unhandled control structure arguments: ~S" ,allow-unknown-p))))
       ,@body)))

;;; This subroutine is shared between backward & forward trigger writers.

(defun process-importance (importance)
  ;; convert the thing given in the rule control structure args to something we can use at runtime.
  (when (consp importance)
    (compiler:constant-fold-optimizer importance))
  (when (compiler:constant-form-p importance)
    ;; importance is a compile-time constant
    (setq importance (compiler:constant-evaluator importance)))
  (when (and (not (numberp importance)) (not (symbolp importance)))
    ;; neither a number nor a symbol be, so a closure I'll make of thee
    (setq importance `#'(lambda () ,importance)))
  importance)

(defun maybe-quote-importance (importance-form)
  ;; if importance-form is a list, don't quote it, since it's a ˆ-expression that needs to be compiled.
  ;; this is called by the trigger-code writers for rules and questions when they store away
  ;; importance forms.
  (if (listp importance-form)
      ;; needs to be seen by compiler
      importance-form
      ;; compiler needn't see it
      `',importance-form))
1

0;;;; Rule compilation for forward chaining.

;;;; Rule compilation for forward chaining.

(defun write-forward-rule-trigger-code (Rule-name if-part environment arguments body-variables
					&aux trigger-variable-analyses)
  ;; write some code to generate a Rete network and index the triggers appropriately
  (declare (values trigger-code subsidiary-functions trigger-variable-analyses pure-unification-p))
  (let ((*forward-rule-trigger-compiler-environment* environment))
    (declare (special *forward-rule-trigger-compiler-environment*))
    ;; first, parse up the arguments to the control structure
    (with-control-structure-arguments ((importance documentation semi-unification) arguments)
      ;; this implementation is a kludge that awaits the rest of the generic rule compiler.
      ;; its advantage over the previous implementation is that all the kludges are in the same place!
      (ignore documentation)
      (setq importance (process-importance importance))
      (unless (predication-maker-p if-part)
	(error "The IF part of the forward rule ~s contains only Lisp code.~&It must contain at least one pattern." rule-name))
      (with-predication-maker-parsed (predicate the-statement) if-part
	(when (member predicate '(or and))
	  (unless (loop for form in the-statement thereis (predication-maker-p form))
	    (error "The IF part of the forward rule ~s contains only Lisp code.~&It must contain at least one pattern."
		   rule-name))))
      ;; At this point, triggers is a list of (possibly nested) predication-maker forms.
      ;; each possibly followed by a :support x.
      ;; Process them and make up entry structures that are dispatched on by
      ;; make-rete-network.
      (let ((real-triggers (expand-forward-rule-trigger if-part nil *true* if-part nil)))
	(labels ((find-and-analyze-trigger (trigger)
		   (case (car trigger)
		     ((:and :or) (loop for thing in (cdr trigger) doing (find-and-analyze-trigger thing)))
		     (:procedure
		       (setq trigger-variable-analyses
			     (analyze-trigger trigger trigger-variable-analyses (third trigger))))
		     ((:match :object-match)
		       (when (null (third trigger))
			 ;; this is the name of the support variable
			 (setf (third trigger)
			       ;; make all patterns have a support variable
			       (gentemp "ANONYMOUS-")))
		       (setq trigger-variable-analyses
			     (analyze-trigger trigger trigger-variable-analyses (third trigger)))))))
	  (find-and-analyze-trigger real-triggers))
	(let ((*forward-rule-subsidiary-functions* nil))
	  (let ((analysis (build-rete-topology real-triggers)))
	    (analyze-variable-consumption analysis body-variables)
	    (analyze-semi-ability analysis semi-unification)
	    (write-rete-procedures rule-name analysis)
	    (multiple-value-bind (pred-forms top-level-pred pred-mapping) (collect-all-predications if-part)
	      (multiple-value-bind (rete-bindings rete-body) (make-rete-network rule-name analysis pred-mapping)
		(multiple-value-bind (final-output-map terminal-node pure-unification)
		    (follow-analysis-to-terminal analysis)
		  (make-output-env-assignments trigger-variable-analyses final-output-map)
		  (let ((lvs-in-triggers (logic-variable-makers-in-thing if-part)))
		    ;; write a function to install this rule.
		    (values `(defun (:property ,rule-name install-triggers) ()
			       (declare (sys:function-parent ,rule-name defrule))
			       ;; disarm any previously existing rule by this name
			       ;; now write, compile, and collect up the matchers & mergers
			       ;; record the debug-info and index the Rete network
			       ;; under each of the triggers Do this by calling out
			       ;; of line, there's nothing gained by compiling lots
			       ;; of crud in line here.
			       (let ,(loop for lv in lvs-in-triggers
					   collect `(,lv (make-unbound-logic-variable ',lv)))
				 (declare (sys:logic-variable ,@lvs-in-triggers))
				 (compiler-let ((*known-lvs* ',lvs-in-triggers))
				   (let* (,@pred-forms ,@rete-bindings)
				     (ignore ,top-level-pred)
				     ,@rete-body
				     (install-forward-rule-triggers ',rule-name
								    ,(pattern-analysis-rete-node analysis)
								    ,terminal-node
								    ,(maybe-quote-importance importance)
								    ',if-part)))))
			    (nreverse *forward-rule-subsidiary-functions*)
			    ;; want the variable analyses, 'cause they contain final slot assignments.
			    trigger-variable-analyses
			    pure-unification
			    )))))))))))


(defun follow-analysis-to-terminal (analysis)
  (loop with my-analysis = analysis
	doing (setq my-analysis (typecase my-analysis
				  (and-group-pattern-analysis (car (and-group-pattern-analysis-sub-patterns my-analysis)))
				  (or-group-pattern-analysis (car (or-group-pattern-analysis-sub-patterns my-analysis)))
				  (otherwise my-analysis)))
	for links = (pattern-analysis-links my-analysis)
	until (and (null links)
		   (not (and-group-pattern-analysis-p my-analysis))
		   (not (or-group-pattern-analysis-p my-analysis)))
	finally (return (values (pattern-analysis-map my-analysis)
				(pattern-analysis-rete-node my-analysis)
				(pattern-analysis-pure-semi-unification? my-analysis)))
	when links
	  do (setq my-analysis (second (first links)))))

(defun collect-all-predications (if-part)
  (let ((forms nil) (mapping nil))
    (labels ((do-one-piece (p-maker)
	       (cond
		 ((predication-maker-p p-maker)
		   (let ((name (assoc p-maker mapping)))
		     (unless name
		       (setq name (gentemp "PREDICATION-"))
		       (push (cons p-maker name) mapping)
		       (let ((predicate (predication-maker-predicate p-maker)))
			 (when (member predicate '(and or not))
			   (setq p-maker `(predication-maker
					    (list ',predicate
						  ,@(loop for piece in (cdr (predication-maker-statement p-maker))
							  collect (do-one-piece piece)))))))
		       (push (list name p-maker) forms))
		     (setq p-maker name)))
		 ((logic-variable-maker-p p-maker))
		 ((eql p-maker :support))
		 (t (setq p-maker `',p-maker)))
		 p-maker))
      (let ((top-name (do-one-piece if-part)))
	(values (nreverse forms) top-name mapping)))))



(defun preliminary-analysis-of-forward-rule-body (then-part)
  (declare (values actions variables))
  (let ((actions
	  (if (predication-maker-p then-part)
	      (with-predication-maker-parsed (predicate args) then-part
		(when (eq predicate 'or)
		  (error "Forward rules don't grok OR actions yet: ~S" then-part))
		(if (and (eq predicate 'and-internal)
			 ;; If it's backquoted anything could be going on
			 ;; so we don't try to expand it out.
			 (neq (first (second then-part)) 'backquote))
		    args
		    ;; some predication other than and
		    (list then-part)))
	      ;; just a lisp form
	      (list then-part))))    
    (values actions (logic-variable-makers-in-thing actions))))

(defun write-forward-rule-body (rule-name actions then-part trigger-variable-analyses environment
				arguments computed-semi-unification
				&aux action-variable-analyses analyses-in-actions)
  ;; writes a function that presumably implements a forward rule's actions
  (declare (values body-code action-variable-analyses))
  (ignore environment)
  (with-control-structure-arguments ((importance documentation semi-unification) arguments)
    (ignore importance)
    (setq computed-semi-unification (or computed-semi-unification semi-unification))
    ;; At this point, actions is a list of forms -- some lisp, some predication-maker forms.
    (loop for action in actions
	  doing (setq action-variable-analyses
		      (analyze-action action action-variable-analyses trigger-variable-analyses)))
    (setq analyses-in-actions (loop for t-v-a in trigger-variable-analyses
				     when (variable-analysis-actions-found-in t-v-a)
				       ;; all the action variables and some of the trigger
				       ;; variables
				       collect t-v-a into answer
				     finally (return (append answer action-variable-analyses))))
    (multiple-value-bind (names bindings) (rule-variable-initializations analyses-in-actions)      
      (loop
	  with *known-lvs* = (append (mapcar #'variable-analysis-variable analyses-in-actions) *known-lvs*)
	  for action in actions
	  collect (compile-forward-rule-action action then-part rule-name environment)
	    into body-forms
	  finally
	    ;; actually, in the forward-chaining case, action variables
	    ;; and bindings always occur either together or not at all.
	    (return
	      (values `(defun ,rule-name (*running-rule* .environment. *support*)
			 ,@(when documentation (list documentation))
			 (declare (sys:function-parent ,rule-name defrule))	;be nice to Zmacs
			 ;;so rules with no variables don't get warnings
			 (ignore .environment. *support*)
			 (let ,bindings
			   (declare (sys:logic-variable ,@(unless computed-semi-unification names)))
			   (compiler-let ((*known-lvs* ',names))
			     ;; bind all the trigger and action variables
			     ,@body-forms)))
		      action-variable-analyses))))))

(defparameter *forward-rules*  nil "List of all known forward rules.")

(define-rule-control-structure :forward (rule-name if-part then-part environment &rest arguments)
  ;; define forward-chaining -- return a form to be compiled in place of a forward rule
  ;; figuring out triggers and actions needs to be genericized.
  (multiple-value-bind (actions body-variables) (preliminary-analysis-of-forward-rule-body then-part)
    (multiple-value-bind (trigger-code subsidiary-functions trigger-variable-analyses semi-unification)
	;; the trigger code must be generated before the body code, since it assigns environment
	;; indices to variables that the body needs.  However, in the expansion, you almost always
	;; want to see the body code first.
	(write-forward-rule-trigger-code rule-name if-part environment arguments body-variables)
      (multiple-value-bind (body-code action-variable-analyses)
	  (write-forward-rule-body rule-name actions then-part trigger-variable-analyses
				   environment arguments semi-unification)
	(ignore action-variable-analyses)
	`(progn ;; (undefrule ',rule-name)
	   (si:record-source-file-name ',rule-name 'defrule)
	   ;; put body before triggers since it's almost always what you want to see in macroexpand
	   ,body-code
	   ,trigger-code
	   ,@subsidiary-functions
	   (funcall #'(:property ,rule-name install-triggers))
	   ;; register the name
	   (pushnew ',rule-name *forward-rules*)
	   ;; return the name
	   ',rule-name)))))

(defparameter *backward-rules* nil "List of all known backward rules.")

(define-rule-control-structure :backward (rule-name if-part then-part environment &rest arguments)
  ;; define backward chaining -- return a form to be compiled in place of a backward rule
  (multiple-value-bind (trigger trigger-negated)
      (parse-backward-trigger then-part)
    (let ((trigger-code (write-backward-rule-trigger-code rule-name trigger trigger-negated if-part  environment arguments))
	  (body-code (write-backward-rule-body rule-name trigger trigger-negated if-part environment arguments)))
	`(progn (undefrule ',rule-name)
		(si:record-source-file-name ',rule-name 'defrule)
		;; put body first, 'cause it's usually what we're interested in looking at.
		,body-code
		,trigger-code
		(funcall #'(:property ,rule-name install-triggers))
		;; register the name
		(pushnew ',rule-name *backward-rules*)
		;; return the name
		',rule-name))))


(defun parse-backward-trigger (then-part)
  (declare (values trigger trigger-negated))
  (with-predication-maker-parsed (predicate args) then-part
      ;; ---- probably ought to make sure it's well-formed
      (case predicate
	(not-internal
	  (values (first args) t))
	(otherwise
	  (values then-part nil)))))



(defun write-backward-rule-trigger-code (rule-name trigger trigger-negated if-part environment arguments)
  ;; write some code to generate the trigger mechanism for a backward rule.
  (declare (values trigger-code))
  (ignore environment)
  (with-control-structure-arguments ((importance documentation) arguments)
    ;; this implementation is a kludge that awaits the rest of the generic rule compiler.
    ;; its advantage over the previous implementation is that all the kludges are in the same place!
    (ignore documentation)
    (setq importance (process-importance importance))
    (let ((predicate (predication-maker-predicate trigger)))
      (when (eq predicate 'or)
	(error "Backward rules don't grok OR triggers yet: ~S" trigger))
      (when (eq predicate 'and)
	(error "Backward rules don't deal with conjunctive triggers yet.")))
    ;; write a function to install this rule.
    (let ((truth-value (if trigger-negated '*false* '*true*)))
    `(defun (:property ,rule-name install-triggers) ()
       (declare (sys:function-parent ,rule-name defrule))
       ;; disarm any previously existing rule by this name
       (disarm-rule-triggers ',rule-name)	;take direction arg?
       (let* ((trigger ,trigger)
	      (entry (make-backward-trigger
		       :rule ',rule-name
		       :importance ,(maybe-quote-importance importance))))
	 ;; record the debug-info
	 (setf (rule-debug-info ',rule-name)
	       (make-rule-debug-info :name ',rule-name
				     :control :backward
				     :triggers (list (list trigger ,truth-value))
				     :context ',if-part
				     :network entry))	;this should be called something else
	 ;; now index the trigger-object (this does the interning of variant patterns)
	 (add-backward-rule-trigger trigger ,truth-value entry ',if-part ',rule-name))))))


(defun write-backward-rule-body (rule-name trigger trigger-negated if-part environment arguments)
  ;; Write the body of a backward rule.  This is more complicated than you might think,
  ;; because it has to cons all structures containing logic variables in order to be
  ;; re-entrant.  This version is pretty careful to cons them on the stack.
  ;;
  ;; We keep track of whether or not the data stack got used (requiring a sys:with-data-stack
  ;; wrapper), the things that need to get bound in a stack-let*, and a body form
  (declare (values body-code))
  (with-control-structure-arguments ((importance documentation) arguments)
    ;; this implementation is a kludge that awaits the rest of the generic rule compiler.
    ;; its advantage over the previous implementation is that all the kludges are in the same place!
    (ignore importance)
    (let ((actions (expand-backward-rule-action if-part nil *true* nil if-part)))
      ;; at this point, actions is a tree of nested rule-action expressions.
      (let* ((data-stack-p nil)
	     (variables (union (logic-variable-makers-in-thing if-part)
			       (logic-variable-makers-in-thing trigger)))
	     (bindings nil))
	(labels ((compile-head (head)
		   ;; ---- for now, just build a predication and match it.
		   ;; ---- eventually, open-code the unification
		   (multiple-value-bind (match-form new-bindings used-data-stack-p)
		       (write-backward-rule-matcher head variables environment '.goal.)
		     ;; add new bindings and data stack flag; body depends on whether we're
		     ;; back-chaining on another predication or executing a piece of lisp code.
		     (setq bindings (nconc bindings new-bindings))
		     (when used-data-stack-p (setq data-stack-p t))
		     match-form))
		 (compile-node (node continuation top-level?)
		   (case (car node)
		     (:ignore (compile-ignore-node node continuation top-level?))
		     (:procedure (compile-procedure-node node continuation top-level?))
		     (:or (compile-or-node node continuation top-level?))
		     (:and (compile-and-node node continuation top-level?))
		     (:match (compile-match-node node continuation top-level?))))
		 (continuation-variable-name-of-node (node)
		   (case (car node)
		     (:or nil)
		     (:and nil)
		     (:match (fourth node))
		     (:ignore nil)
		     (:procedure nil)))
		 (compile-ignore-node (node continuation top-level?)
		   (ignore node)
		   (when top-level?
		     `(stack-let ((rule-support (list .goal. .truth-value. '(rule ,rule-name))))
			(funcall ,continuation rule-support))))
		 (compile-match-node (node continuation top-level?)
		   (destructuring-bind (action truth-value ignore ask-args) (cdr node)
		     (when (null ask-args)
		       (setq ask-args '(t .do-questions.)))
		     (multiple-value-bind (new-thing new-bindings used-data-stack-p)
			 (stackify-thing action environment variables)
		       (when used-data-stack-p (setq data-stack-p t))
		       (when top-level?
			 (setq continuation
			       (let ((support-var (sys:gensymbol "SUPPORT")))
				 `#'(lambda (,support-var)
				      (stack-let ((rule-support (list .goal. .truth-value. '(rule ,rule-name)
									 ,support-var)))
					(funcall ,continuation rule-support))))))
		       (let ((body `(ask-internal ,new-thing ,truth-value ,continuation ,@ask-args)))
			 (when new-bindings (setq body `(stack-let* ,new-bindings ,body)))
			 body))))
		 (compile-procedure-node (node continuation top-level?)
		   (let ((lv-name (third node))
			 (body (second node))
			 (support-var (sys:gensymbol "SUPPORT")))
		     (cond ((not (calls-succeed-p body environment variables))
			    (cond ((not top-level?)
				   ;; no calls to succeed -- call the continuation
				   ;; note that the compiler will optimize out the funcall for us
				   `(when ,body (funcall ,continuation nil)))
				  (t `(when ,body
					(stack-let ((rule-support (list .goal. .truth-value. (list 'rule ',rule-name))))
					  (funcall ,continuation rule-support))))))
			   (t
			    ;; some calls to succeed -- succeed either by doing (succeed) or returning
			    ;; non-NIL
			    (cond ((not top-level?)
				   `(flet ((succeed (&optional ,support-var)
						    (declare (sys:downward-function))
						    ,@(when lv-name `((unify ,lv-name ,support-var)))
						    (funcall ,continuation ,support-var)
						    ;; if the last action is (succeed), don't do it again
						    nil))
				      (when ,body (succeed))))
				  (t `(flet ((succeed (&optional ,support-var)
						      (declare (sys:downward-function))
						      ,@(when lv-name `((unify ,lv-name ,support-var)))
						      (when (predicationp ,support-var)
							(setq ,support-var (list ,support-var)))
						      (stack-let ((rule-support (list* .goal. .truth-value.
										       (list 'rule ',rule-name)
										       ,support-var)))
							(funcall ,continuation rule-support))))
					(when ,body (succeed)))))))))
		 (compile-and-node (node continuation top-level?)
		   (labels ((compile-and-list (remaining-actions support-list)
			      (if (null remaining-actions)
				  `(stack-let ((rule-support (list ,@(if top-level?
									 `(.goal. .truth-value. '(rule ,rule-name))
									 `('and *true* 'and))
								   ,@(reverse support-list))))
				     (funcall ,continuation rule-support))
				  (let (next-node lv-name)
				    (loop doing (setq next-node (pop remaining-actions))
					  until (not (eql (car next-node) :ignore)))
				    (setq lv-name (continuation-variable-name-of-node next-node))
				    (compile-node next-node
						  (let ((support-var (sys:gensymbol "SUPPORT")))
						    (push support-var support-list)
						    (let ((body (compile-and-list remaining-actions support-list)))
						      `#'(lambda (,support-var)
							   (declare (sys:downward-function))
							   ,@(when lv-name `((unify ,lv-name ,support-var)))
							   ,body)))
						  nil)))))
		     (compile-and-list (cdr node) nil)))
		 (compile-or-node (node continuation top-level?)
		   `(let ((.or-continuation. ,continuation))
		      ,@(loop for next-node in (cdr node)
			      when (not (eql (car next-node) :ignore))
			      for lv-name = (continuation-variable-name-of-node next-node)
			      collect (compile-node next-node
						    (if top-level?
							(let ((support-var (sys:gensymbol "SUPPORT")))
							  `#'(lambda (,support-var)
							       (declare (sys:downward-function))
							       ,@(when lv-name `((unify ,lv-name ,support-var)))
							       (stack-let ((rule-support (list .goal. .truth-value.
											       '(rule ,rule-name)
											       ,support-var)))
								 (funcall .or-continuation. rule-support))))
							'.or-continuation.)
						    nil))))
		 (compile-body (node) (compile-node node '.continuation. t)))
	  (let ((body-form `(with-unification
			      ,(compile-head trigger)
			      ,(compile-body actions))))
	    (when bindings
	      ;; wrap the body form in a stack-let* to do the bindings
	      ;; Also, we cons all the necessary structures on the stack now,
	      ;; even if we might not need them later.  This is like the caller/callee saves
	      ;; tradeoffs in function calls in register machines.  I cons them all here,
	      ;; because if I consed them later, they might get consed many times -- once
	      ;; for each success.
	      (setq body-form `(stack-let* ,bindings ,body-form)))
	    (when variables
	      (setq body-form `(with-unbound-logic-variables ,variables
				 (compiler-let ((*known-lvs* ',variables))
				   ,body-form))))
	    (when data-stack-p
	      ;; only pay the overhead of setting up a data-stack frame when we need it.
	      (setq body-form `(sys:with-data-stack ,body-form)))
	    `(defun ,rule-name (.goal. .truth-value. .continuation. .do-questions.)
	       ,@(when documentation (list documentation))
	       ;;cons like woodchuck, instead of bear
	       (declare (sys:function-parent ,rule-name defrule)	
			(sys:downward-funarg .continuation.))
	       (ignore .do-questions.)
	       (when (eql .truth-value.
			  ,(if trigger-negated '*false* '*true*))
		 (let ((*running-rule* ',rule-name))
		   ,body-form)))))))))

(defun calls-succeed-p (form environment *known-lvs*)
  ;; determine whether or not this form does (succeed).
  (block called-succeed
    (lt:mapforms #'(lambda (subform kind usage state)
		     (ignore kind)
		     (when (and (member usage 'lt:(eval effect))
				(consp subform) (eq (car subform) 'succeed))
		       ;; return t when we see a call to succeed
		       (return-from called-succeed t))
		     ;; otherwise continue code-walking
		     state)
		 form
		 :environment environment)))


;;; The default head matcher for backward chaining rules.

(define-predicate-method (write-backward-rule-matcher default-rule-compilation-model)
			 (variables-in-trigger environment name-of-pred-to-match)
  ;; ---- for now, just build a predication and match it.
  ;; ---- eventually, open-code the unification
  (multiple-value-bind (new-thing new-bindings used-data-stack-p)
      (stackify-thing self environment variables-in-trigger)
    ;; add new bindings and data stack flag; body depends on whether we're
    ;; back-chaining on another predication or executing a piece of lisp code.
    (values
      `(unify-predication ,name-of-pred-to-match ,new-thing)
      new-bindings
      used-data-stack-p)))

1

0;;;
;;; Defining backward questions.  (A little like rules, but run later.)
;;;

;;; BUG: the accept's appear to be ignoring the readtable.  You can't type variables, preds, etc.
(defun ask-default-backward-question (query truth-value what-to-funcall)
  ;; what gets called by the default question-asker.  This is what Joshua calls
  ;; for people who want an automatically-generated user-interface.
  (let* ((named-vars (named-logic-variables-in-thing query))
	 (named-vars-names (nreverse (loop for thing in named-vars
					   collect (logic-variable-name thing)))))
    (cond ((null named-vars-names)
	   ;; there are no variables in this query
	   (fresh-line *query-io*) ;can't do conditional newlines in redisplayers in 365!
	   (when (accept 'boolean
			 :prompt #'(lambda (stream origin)
				     (ignore origin)
				     (cond ((contains-logic-variables-p query)
					    ;; may contain anonymous variables
					    (format stream
						    (select truth-value
						      (*true*
						       "Is it ~'iever~ true that \"~\\SAY\\\"? ")
						      (*false*
						       "Is it ~'ialways~ false that \"~\\SAY\\\"? "))
						    query))
					   (t
					     ;; no variables whatsoever
					     (format stream
						     (select truth-value
						       (*true*
							"Is it true that \"~\\SAY\\\"? ")
						       (*false*
							"Is it false that \"~\\SAY\\\"? "))
						     query))))
			 :default nil
			 :provide-default t
			 :display-default t)
	     ;; user says yes
	     (funcall what-to-funcall)))
	  (t
	    ;; there are some variables here, so there could be many solutions.
	    ;; should there be a special case where there's just one variable, which just does accept,
	    ;;   instead of an accepting-values?
	    (loop with solution-exists-p = t and solution-values
		  and no-value = (locf named-vars-names)
		  ;; no-value is armor against people who type ” without filling in
		  ;; any of the values.
		  initially
		    (fresh-line *query-io*) ;can't do conditional newlines in redisplayers in 365!
		    (dw:accepting-values (*query-io* :resynchronize-every-pass t)
		      ;; first print out a prompt
		      (format *query-io*
			      (select truth-value
				(*true*
				 "For what values of ~:\\LIST\\ is it true that \"~\\SAY\\\"?~%")
				(*false*
				 "For what values of ~:\\LIST\\ is it false that \"~\\SAY\\\"?~%"))
			      named-vars-names query)
		      ;; now try to accept some values
		      (setq solution-exists-p (accept 'boolean
						      :prompt "Some solution exists"
						      :default solution-exists-p))
		      (when solution-exists-p
			;; if he says there's a solution, ask for more values
			(setq solution-values
			      (loop for var in named-vars-names
				    ;; Should use type-info in predicate, when available.
				    collecting (accept 'sys:expression
						       :default no-value
						       :provide-default nil
						       :prompt (format nil "Value for ~S" var))))))
		    (cond ((and solution-exists-p
				(notany #'(lambda (x) (eq x no-value))
					solution-values))
			    ;; found a solution
			    (with-unification
			      (loop for var in named-vars
				    for value in (reverse solution-values)
				    doing (%unify-variable var value)
				    finally (funcall what-to-funcall))))
			  (t
			    ;; no solution
			    (loop-finish)))
		  doing
	      ;; clear out old solution and look for another
	      (setq solution-exists-p t solution-values nil)
	      (fresh-line *query-io*) ;can't do conditional newlines in redisplayers in 365!
	      (dw:accepting-values (*query-io* :resynchronize-every-pass t)
		;; put out repeat prompt
		(format *query-io*
			(select truth-value
			  (*true*
			   "What are some more values of ~:\\LIST\\ such that \"~\\SAY\\\" is true?~%")
			  (*false*
			   "What are some more values of ~:\\LIST\\ such that \"~\\SAY\\\" is false?~%"))
			named-vars-names query)
		;; now accept the values
		(setq solution-exists-p (accept 'boolean
						:prompt "Some solution exists"
						:default solution-exists-p))
		(when solution-exists-p
		  ;; if he says there's a solution, ask for more values
		  (setq solution-values
			(loop for var in named-vars-names
			      ;; Should use type-info in predicate, when available.
			      collecting (accept 'sys:expression
						 :default no-value
						 :provide-default nil
						 :prompt (format nil "Value for ~S" var))))))
	      (cond ((and solution-exists-p
			  (notany #'(lambda (x) (eq x no-value))
				  solution-values))
		      ;; found a solution
		      (with-unification
			(loop for var in named-vars
			      for value in (reverse solution-values)
			      doing (%unify-variable var value)
			      finally (funcall what-to-funcall))))
		    (t
		      ;; no solution
		      (loop-finish))))))))

(defsubst question-pattern (name)
  ;; figure out what the pattern is for a given question.
  (get name 'question-pattern))

(defun write-default-question-body (pattern control-structure &rest args
					    &key importance &allow-other-keys) ;for c-s args
  ;; write a question body suitable for a quick-and-dirty user interface
  (declare (ignore args))
  (check-type control-structure (member :backward))
  (ignore pattern importance)
  `((query truth-value continuation &optional ignore)
    (ask-default-backward-question query truth-value #'succeed)))

(defun check-question-code-arg (code-arg)
  ;; verify the code arg
  (or (null code-arg)				;wants the default
      (and (consp code-arg)
	   (let ((arglist (car code-arg)))
	     (and (symbolp (first arglist))
		  (not (member (first arglist) si:lambda-list-keywords))
		  (not (eq (first arglist) 'ignore))
		  (symbolp (second arglist))
		  (not (member (second arglist) si:lambda-list-keywords))
		  (not (eq (second arglist) 'ignore))
		  (symbolp (third arglist))
		  (not (member (third arglist) si:lambda-list-keywords))
		  (not (eq (third arglist) 'ignore)))))))

(defvar *backward-questions* nil "Registry of backward questions.")

(def-defining-form defquestion
   :definer
   ((name (control-structure &rest control-structure-args) pattern
	  &key code context
	  &environment environment
	  &aux variables bindings body-form args)
    (declare (zwei:indentation 1 1 1 2))
    ;; the body is a keyword because, in the future, there will be a
    ;; declarative question-asking language.  You'll say something like
    ;; (defquestion foo (:backward) :menu *** :picture ***) and the
    ;; system will write the :code thing for you.  first, indulge some
    ;; paranoia
    (check-type control-structure (member :backward))
    (check-type code (satisfies check-question-code-arg)
		"an arglist like (QUERY TRUTH-VALUE CONTINUATION)")
    (check-type pattern (satisfies predication-maker-p) "a PREDICATION-MAKER form")
    (with-control-structure-arguments ((importance documentation) control-structure-args)
      ;; can stackify the pattern
      (setq importance (process-importance importance))
      (multiple-value-bind (trigger trigger-negated)
	  (parse-backward-trigger pattern)
	(when (null code)
	  ;; wants us to write his user interface for him, the wimp!
	  (when trigger-negated
	    (error "I don't know how to ask negated questions -- you must supply :CODE"))
	  (setq code (apply #'write-default-question-body
			    trigger control-structure control-structure-args)))
	(setq args (car code))
	(setq variables (union (logic-variable-makers-in-thing trigger)
			       (logic-variable-makers-in-thing context)))
	(multiple-value-bind (new-trigger new-trigger-bindings trigger-data-stack-p)
	    (write-backward-rule-matcher trigger variables environment (first args))
	  (setq bindings new-trigger-bindings)
	  (setq body-form
		`(with-unification
		   ;; failing to unify will skip executing the rest of the body
		   ,new-trigger
		   (flet ((succeed (&optional support)
			    (stack-let ((question-support (list ,(first args)
								,(second args)
								'(question ,name)
								support)))
			      (funcall ,(third args) question-support))
			    ;; if this is the last thing, don't succeed again
			    nil))
		     ;; The body succeeds by unifying vars & doing
		     ;; (SUCCEED).  Replace logic vars by their
		     ;; corresponding lisp forms -- this code-walking 
		     ;; is essentially equivalent to what ASK does to
		     ;; its continuation.   In fact, this is copied from
		     ;; the ASK macro, so you should look there, too.
		     (when
		       (let ((dw::*readtable-for-expression* ji::*joshua-readtable*))
			 ,@(cdr code))
		       (succeed)))))
	  (when bindings
	    ;; use bindings generated by stackify and the variable-conser
	    (setq body-form `(stack-let* ,bindings ,body-form)))
	  (when trigger-data-stack-p
	    ;; stackify-form says we're gonna use the data stack
	    (setq body-form `(sys:with-data-stack ,body-form)))
	  (when variables
	      (setq body-form `(with-unbound-logic-variables ,variables
				 (compiler-let ((*known-lvs* ',variables))
				   ,body-form))))
	  ;; now ready to emit code.
	  (let ((truth-value (if trigger-negated '*false* '*true*)))
	  `(progn (record-source-file-name ',name 'defquestion)
		  (undefquestion ',name)
		  (setf (question-info ',name)
			(make-question-info :name ',name
					    :context ',context
					    :importance ,(maybe-quote-importance importance)
					    :pattern (list ,trigger ,truth-value)))	;already quoted
		  (defun ,name ,args
		    ,@(when documentation (list documentation))
		    ;; takes 2 args -- query and continuation
		    (declare (sys:function-parent ,name defquestion)
			     (sys:downward-funarg ,(third args)))
		    (when (eql ,(second args)
			       ,(if trigger-negated '*false* '*true*))
		      ,body-form))
		  (add-backward-question-trigger ,trigger ,truth-value ',name ',context ',name)
		  (pushnew ',name *backward-questions*)
		  ',name))))))
   :killer undefquestion
   :shower
   ((form)
    (let ((name (second form)))
      (cond ((not (symbolp name))
	     (zwei:barf "Malformed question name."))
	    ((fdefinedp name)
	     (zwei:typein-line "~&Evaluating this will redefine ~S as a Question." name))
	    (t
	      (zwei:typein-line "~&Evaluating this will define ~S as a Question, for the first time."
				name)))))
   :type-name "Question") 

(defun undefquestion (name &aux (info (question-info name)))
  ;; how to undefine a question
  (when info
    ;; need a predication to index with its storage method to get rid of it.
    (condition-case ()
	 (delete-backward-question-trigger (first (question-info-pattern info))
					   (second (question-info-pattern info))
					   name
					   (question-info-context info))
       (error nil))
    (setf (question-info name) nil)
    (setq *backward-questions* (delete name *backward-questions*))
    (fundefine name)))1 



0;;;
;;; Sledge hammers to clean up the universe by removing all internal state in rules.
;;;

(defun undefrule (rule-name &aux (debug-info (rule-debug-info rule-name)))
  ;; flush a rule
  (when debug-info				;check if rule is there, first
    ;; first, make sure it won't trigger anymore.
    (disarm-rule-triggers rule-name)
    ;; second, flush its internal state
    (ecase (rule-debug-info-control debug-info)
      (:forward
	(clear-rete-network (rule-debug-info-network debug-info))
	(setq *forward-rules* (delete rule-name *forward-rules*)))
      (:backward
	;; have to do something here to remove it from the interned matcher stuff.
	(setq *backward-rules* (delete rule-name *backward-rules*))))
    ;; third, undefine it.
    (setf (rule-debug-info rule-name) nil)
    (fundefine rule-name)
    (fundefine `(:property ,rule-name install-triggers))))

(defun clear (&optional (clear-database t) (undefrule-rules nil))
  ;; clear the database and undefine the rules, under control of the arguments.
  (clear-forward-queue)
  (flet ((clear-rule (rule-name)
	   ;; given a rule name, clear the associated Rete network.
	   ;; ("Forget everything you've ever heard.")
	   (ecase (rule-debug-info-control (rule-debug-info rule-name))
	     (:forward
	       (clear-Rete-network (rule-debug-info-network (rule-debug-info rule-name))))
	     (:backward
	       ;;nothing to do, since no state is saved.
	       nil)
	     (:mixed nil))))
    (when undefrule-rules
      ;; supposed to undefine all the rules, too (wants a semi-virgin world)
      (mapc #'undefrule *forward-rules*)
      (mapc #'undefrule *backward-rules*))
    (when (or clear-database undefrule-rules)
      ;; clear the predications out of each model
      (loop for model in *models* doing (clear-model model clear-database undefrule-rules)))
    (when clear-database
      ;; clear the rules of the state in the database
      (mapc #'clear-rule *forward-rules*)
      (mapc #'clear-rule *backward-rules*))
    ;; return a harmless value
    t))
