;;; -*- Mode: Joshua; Package: JI; Syntax: Joshua; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Created 2/27/86 21:13:27 by sgr running on GROUSE at SCRC.

;;;
;;; Models and predicates supplied with basic Joshua.
;;;

;;; Signal this if you catch an error while a query is being processed.

(defflavor query-got-error-during-processing (query condition)
	   (dbg:debugger-condition)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (dbg:report query-got-error-during-processing) (stream)
  (format stream "The query ~s got an ~s error."
	  query condition))

;;; Signal this flavor (or something built on it) if you can't
;;; handle a query asked of you.

(defflavor model-cant-handle-query (query model)
	   (dbg:debugger-condition)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (dbg:report model-cant-handle-query) (stream)
  (format stream "The query ~s could not be processed~&because it is more general than is supported by the ~s model."
	  query model))

(defflavor model-can-only-handle-positive-queries (query model)
	   (model-cant-handle-query)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (dbg:report model-can-only-handle-positive-queries) (stream)
  (format stream "The query ~s could not be processed~&because the ~s model only handles true queries."
	  query model))

(compile-flavor-methods model-cant-handle-query model-can-only-handle-positive-queries)

;;;
;;; A model for predications that are really just data structures (like lists)
;;; and shouldn't ever be given to TELL or ASK.  These are meant to be embedded in
;;; other predications.
;;;

;;; I suppose these ought to signal separate conditions that the user could bind.

(define-predicate-model tell-error-model () ()) 

(define-predicate-method (tell tell-error-model) (&rest ignore)
  ;; cause an error if you try to TELL one of these
  (error "Predication ~S is built on TELL-ERROR-MODEL, so you can't TELL it." (type-of self)))

(define-predicate-model ask-error-model () ()) 

(define-predicate-method (ask ask-error-model) (&rest ignore)
  ;; cause an error if you try to ASK one of these
  (error "Predication ~S is built on ASK-ERROR-MODEL, so you can't ASK it." (type-of self)))
	 
(define-predicate-model error-model () (tell-error-model ask-error-model)) 

;;;
;;; The discrimination net model.
;;;

(defparameter *data-discrimination-net* (make-discrimination-net-node
					  :token '*begin-predication*)
  "Root node of the default database discrimination net.")

(define-predicate-model discrimination-net-data-mixin () ())

(define-predicate-method (insert discrimination-net-data-mixin) ()
  ;; stick it in the dn
  (discrimination-net-insert *data-discrimination-net* self))

(define-predicate-method (uninsert discrimination-net-data-mixin) ()
  ;; get it out of the dn
  (discrimination-net-uninsert *data-discrimination-net* self))

(define-predicate-method (clear discrimination-net-data-mixin) (&optional (clear-database t) ignore)
  ;; how to clear discrimination-net modelled predicates
  (when clear-database
    (discrimination-net-clear *data-discrimination-net*)))

(define-predicate-method (fetch discrimination-net-data-mixin) (continuation)
  ;; how to fetch data from the discrimination net.
  (discrimination-net-fetch *data-discrimination-net* self continuation))

(define-predicate-model default-predicate-model
	()
	(discrimination-net-data-mixin trivial-tms-mixin default-protocol-implementation-model))

;;;
;;; AND, OR & NOT
;;;
(define-predicate-model and-model () (default-rule-compilation-model)
  ;;needs no clear-model method, 'cause it's never really told.
  (:required-instance-variables predications))

(define-predicate-method (say and-model) (&optional (stream *standard-output*))
  ;; how to say conjunctions
  (format-textual-list predications #'say :conjunction "and" :stream stream))

(define-predicate-method (expand-forward-rule-trigger and-model) (ignore truth-value context ignore)
  (let ((statement (predication-maker-statement self)))
    (cond ((eql truth-value *true*)
	   `(:and ,@(parse-pattern-for-expand-forward-trigger statement *true* context)))
	  (t `(:or ,@(parse-pattern-for-expand-forward-trigger statement *false* context))))))

(defun parse-pattern-for-expand-forward-trigger (statement truth-value context)
  (loop with triggers = (cdr statement)
	until (null triggers)
	for (trigger . rest) = triggers
	for support-variable-name = nil
	and bound-variable-names = nil
	do (loop with stuff = rest
		 for token = (car stuff)
		 for value = (cadr stuff)
		 do (cond ((eql token :support)
			   (setq support-variable-name value
				 stuff (cddr stuff)))
			  ((eql token :bound-variables)
			   (setq bound-variable-names value
				 stuff (cddr stuff)))
			  (t (setq triggers stuff)
			     (return (values)))))
	collect (expand-forward-rule-trigger trigger
					     (when support-variable-name
					       (logic-variable-maker-name support-variable-name))
					     truth-value
					     context bound-variable-names)))

(define-predicate-method (expand-backward-rule-action and-model) (ignore truth-value ignore context)
  (let ((statement (predication-maker-statement self)))
    (cond ((eql truth-value *true*)
	   `(:and ,@(parse-pattern-for-expand-backward-action statement *true* context)))
	  (t `(:or ,@(parse-pattern-for-expand-backward-action statement *false* context))))))

(defun parse-pattern-for-expand-backward-action (statement truth-value context)
  (loop with triggers = (cdr statement)
	until (null triggers)
	for (trigger . rest) = triggers
	for support-variable-name = nil
	and do-rules = t
	and do-questions = '.do-questions.
	do (loop with stuff = rest
		 for token = (car stuff)
		 for value = (cadr stuff)
		 do (cond ((eql token :support)
			   (setq support-variable-name value
				 stuff (cddr stuff)))
			  ((eql token :do-backward-rules)
			   (setq do-rules value
				 stuff (cddr stuff)))
			  ((eql token :do-questions)
			   (setq do-questions value
				 stuff (cddr stuff)))
			  (t (setq triggers stuff)
			     (return (values)))))
	collect (expand-backward-rule-action trigger
					     (when support-variable-name
					       (logic-variable-maker-name support-variable-name))
					     truth-value
					     (list do-rules do-questions)
					     context)))

(define-predicate-method (tell and-model) (truth-value justification)
  (select truth-value
    (*true*
     (loop for predication in predications
	   doing (tell-internal predication *true* justification)))
    (*false*
     (cond ((null predications)
	    ;; (tell [not [and]])
	    (error "[NOT [AND]] is a contradiction."))
	   ((and (consp predications) (null (rest predications)))
	    ;; (tell [not [and <single thing>])
	    (tell-internal (first predications) *false* justification))
	   (t
	    (error "I don't know how to TELL [NOT [AND <two or more things>]].")))))
  ;; return the conjunct
  self)

(defun list-of-predications-p (thing)
  (or (null thing)
      (and (listp thing)
	   (predicationp (car thing))
	   (list-of-predications-p (cdr thing)))))

(define-predicate-method (ask and-model) (truth-value continuation do-backward-rules do-questions)
  (labels ((ask-and (predications derivations)
	     (if (null predications)
		 ;; call the AND's continuation
		 (let ((and-derivation `(,self ,truth-value and
					       ,@(reverse derivations))))
		   (funcall continuation and-derivation))
		 ;; ASK about one predication, then the rest
		 (ask-internal (first predications)
			       *true*
			       #'(lambda (derivation)
				   (let ((more-derivations `(,derivation ,@derivations)))
				     (ask-and (rest predications) more-derivations)))
			       do-backward-rules do-questions))))
    (unless (list-of-predications-p predications)
      (signal 'model-cant-handle-query
	      :query self
	      :model 'and-model))
    (select truth-value
      (*true*
       (ask-and predications nil))
      (*false*
       (loop for predication in predications
	     do (ask-internal predication
			      *false*
			      continuation
			       do-backward-rules do-questions))))
    (values)))

;;; This model treats the telling of everything within the and as atomic
;;; as far as forward rule triggering goes.

(define-predicate-model atomic-and-model () (and-model))

(define-predicate-method (tell atomic-and-model :whopper) (truth-value justification)
  (with-atomic-action
    (continue-whopper truth-value justification)))

(define-predicate-model or-model () (default-rule-compilation-model)
  ;; needs no clear-model method, 'cause it's never really told
  (:required-instance-variables predications))

(define-predicate-method (say or-model) (&optional (stream *standard-output*))
  ;; how to say disjunctions
  (format-textual-list predications #'say :conjunction "or" :stream stream))

(define-predicate-method (expand-forward-rule-trigger or-model) (ignore truth-value context ignore)
  (let ((statement (predication-maker-statement self)))
    (cond ((eql truth-value *true*)
	   `(:or ,@(parse-pattern-for-expand-forward-trigger statement *true* context)))
	  (t `(:and ,@(parse-pattern-for-expand-forward-trigger statement *false* context))))))

(define-predicate-method (expand-backward-rule-action or-model) (ignore truth-value ignore context)
  (let ((statement (predication-maker-statement self)))
    (cond ((eql truth-value *true*)
	   `(:or ,@(parse-pattern-for-expand-backward-action statement *true* context)))
	  (t `(:and ,@(parse-pattern-for-expand-backward-action statement *false* context))))))

(define-predicate-method (tell or-model) (truth-value justification)
  (select truth-value
    (*true*
     (cond ((null predications)
	    ;; (tell [or])
	    (error "[OR] is a contradiction."))
	   ((and (consp predications) (null (rest predications)))
	    ;; (tell [or <single thing>])
	    (tell-internal (first predications) *true* justification))
	   (t
	    (error "I don't know how to TELL [OR <two or more things>]."))))
    (*false*
     (loop for predication in predications
	   doing (tell-internal predication *false* justification))))
  ;; return the conjunct
  self)

(define-predicate-method (ask or-model) (truth-value continuation do-backward-rules do-questions)
  (unless (list-of-predications-p predications)
    (signal 'model-cant-handle-query
	    :query self
	    :model 'or-model))
  (labels ((ask-and (predications derivations)
	     (if (null predications)
		 ;; call the AND's continuation
		 (stack-let ((and-derivation `(,self ,truth-value or
					       ,@(reverse derivations))))
		   (funcall continuation and-derivation))
		 ;; ASK about one predication, then the rest
		 (ask-internal (first predications)
			       *false*
			       #'(lambda (derivation)
				   (stack-let ((more-derivations `(,derivation ,@derivations)))
				     (ask-and (rest predications) more-derivations)))
			       do-backward-rules do-questions))))
    (select truth-value
      (*true*
       (loop for predication in predications
	     do (ask-internal predication
			      *true*
			      continuation
			      do-backward-rules do-questions)))
      (*false*
       (ask-and predications nil)))
    (values)))

(define-predicate-model not-model () (default-rule-compilation-model)
  (:required-instance-variables predication))

(define-predicate-method (expand-forward-rule-trigger not-model) (name truth-value context ignore)
  (let ((statement (predication-maker-statement self)))
    (expand-forward-rule-trigger (cadr statement) name (negate-truth-value truth-value) context nil)))

(define-predicate-method (expand-backward-rule-action not-model) (name truth-value other-ask-args context)
  (let ((statement (predication-maker-statement self)))
    (expand-backward-rule-action (cadr statement) name (negate-truth-value truth-value) other-ask-args context)))

(define-predicate-method (tell not-model) (truth-value justification)
  (tell-internal predication (negate-truth-value truth-value) justification))

(define-predicate-method (ask not-model) (truth-value continuation do-backward-rules do-questions)
  (unless (predicationp predication)
    (signal 'model-cant-handle-query
	    :query self
	    :model 'not-model))
  (ask-internal predication (negate-truth-value truth-value)
		continuation
		do-backward-rules do-questions))

(define-predicate and-internal (&rest predications) (and-model trivial-tms-mixin)
  (:conc-name and-)
  :readable-instance-variables
  :destructure-into-instance-variables)

(define-predicate atomic-and (&rest predications) (atomic-and-model trivial-tms-mixin)
  :readable-instance-variables
  :destructure-into-instance-variables)

(define-predicate or-internal (&rest predications) (or-model trivial-tms-mixin)
  (:conc-name or-)
  :readable-instance-variables
  :destructure-into-instance-variables)

(define-predicate not-internal (predication) (not-model trivial-tms-mixin)
  (:conc-name not-)
  :readable-instance-variables
  :destructure-into-instance-variables)

(define-predicate-synonym and and-internal)
(define-predicate-synonym or  or-internal)
(define-predicate-synonym not not-internal) 

;;;
;;; Stuff with funny things in functor positions has to do something
;;; else, of course.  For example, [[is not] is not [not is]] has [is
;;; not] as a functor.  Reasonable things other than symbols that might
;;; occur in functor position include variables (anything else?).
;;; Variable-functor predications probably go into their own dn?
;;;

(define-predicate-model variable-predicate-model () (default-predicate-model))

(define-predicate-method (ask variable-predicate-model) (truth-value continuation do-backward-rules do-questions)
  (loop for descriptor being the hash-elements of *all-predicates* with-key predicate
	for args-info = (predicate-descriptor-args-info descriptor)
	when args-info
	  do (catch 'ask-variable-predicate-escape
	       (let* ((arglist (loop for count below (predicate-max-args args-info)
				     do (ignore count)
				     collect (make-unbound-logic-variable
					       (gentemp "ANONYMOUS")) into variable-list
				     finally
				       (unless (zerop (predicate-rest-arg args-info))
					 (let ((tailvar (make-unbound-logic-variable
							  (gentemp "ANONYMOUS"))))
					   (if (null variable-list)
					       (setq variable-list tailvar)
					       (setf (cdr (last variable-list)) tailvar))))
				       (return variable-list)))
		      (query (make-predication `(,predicate . ,arglist))))
		 (unless (typep query 'variable-predicate-model)
		   (with-unification
		     (unify query self)
		     (condition-bind ((error
					#'(lambda (condition)
					    (signal 'query-got-error-during-processing 
						    :query query
						    :condition (type-of condition))
					    nil)))
		     (ask-internal query truth-value continuation do-backward-rules do-questions)))))))
  (values))

(defmacro suppressing-unanswerable-queries (query continuation &rest keys)
  `(condition-bind ((model-cant-handle-query #'(lambda (ignore)
						 (throw 'ask-variable-predicate-escape
						   (values)))))
     (ask ,query ,continuation ,@keys)))

(defmacro asking-all (continuation &rest keys)
  `(with-unbound-logic-variables (predicate args)
     (suppressing-unanswerable-queries `[,predicate . ,args] ,continuation ,@keys)))

(define-predicate variable-predicate (&rest arguments) (variable-predicate-model trivial-tms-mixin))

(defparameter *name-of-variable-predicate-constructor*
	      (make-predicate-constructor-name 'variable-predicate))
(defparameter *variable-predicate-constructor*
	      *name-of-variable-predicate-constructor*)

;;;
;;; Functions that various example programs (hence, presumably, user programs) find useful.
;;;

(defun different-objects (object1 object2)
  ;; Some optimizations of procedures can happen if this is known.
  (DECLARE LT:(SIDE-EFFECTS READER))
  ;; test that 2 things are distinct -- used as rule action to prevent
  ;; trying to put a block on top of itself and stuff like that
  (not (or (eql object1 object2)
	   ;; don't deal with unbound vars, they could later get instantiated the same
	   (sys:unbound-logic-variable-p object1)
	   (sys:unbound-logic-variable-p object2))))

(define-predicate-model ask-data-only-mixin () ())D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 0;only ask in database

(define-predicate-method (ask ask-data-only-mixin) (truth-value continuation do-backward-rules do-questions)
  (declare (ignore do-backward-rules do-questions))
  (ask-data self truth-value continuation)
  ;; make it clear that there is no interesting return value
  (values))

(define-predicate-model ask-rules-only-mixin () ())	;only ask rules

(define-predicate-method (ask ask-rules-only-mixin) (truth-value continuation do-backward-rules do-questions)
  (when do-backward-rules
    (ask-rules self truth-value continuation do-questions))
  ;; make it clear that there is no interesting return value
  (values))

(define-predicate-model ask-questions-only-mixin () ())	;only ask questions

(define-predicate-method (ask ask-questions-only-mixin) (truth-value continuation do-backward-rules do-questions)
  (declare (ignore do-backward-rules))
  (when do-questions
    (ask-questions self truth-value continuation))
  ;; make it clear that there is no interesting return value
  (values))

(define-predicate-model ask-data-and-rules-only-mixin () ())

(define-predicate-method (ask ask-data-and-rules-only-mixin) (truth-value continuation do-backward-rules do-questions)
  (ask-data self truth-value continuation)
  (when do-backward-rules
    (ask-rules self truth-value continuation do-questions))
  ;; make it clear that there is no interesting return value
  (values))

(define-predicate-model ask-rules-and-questions-only-mixin () ())

(define-predicate-method (ask ask-rules-and-questions-only-mixin) (truth-value continuation do-backward-rules do-questions)
  (when do-backward-rules
    (ask-rules self truth-value continuation do-questions))
  (when do-questions
    (ask-questions self truth-value continuation))
  ;; make it clear that there is no interesting return value
  (values))

(define-predicate-model ask-data-and-questions-only-mixin () ())

(define-predicate-method (ask ask-data-and-questions-only-mixin) (truth-value continuation do-backward-rules do-questions)
  (declare (ignore do-backward-rules))
  (ask-data self truth-value continuation)
  (when do-questions
    (ask-questions self truth-value continuation))
  ;; make it clear that there is no interesting return value
  (values))


;;; Asserted Data without variables

(define-predicate-model no-variables-in-data-mixin () ())

(define-predicate-method (data-is-guaranteed-variable-free no-variables-in-data-mixin) () t)

(define-predicate-method (tell no-variables-in-data-mixin :before) (truth-value justification)
  (ignore truth-value justification)
  (unless (predication-logic-variable-free-p self)
    (error "Trying to TELL ~s which contains logic-variables" self)))

(define-predicate-method (write-forward-rule-full-matcher no-variables-in-data-mixin) (predicate-variable environment)
  (ignore predicate-variable environment)
  nil)



;;;
;;; Add KNOWN, a modal operator.  I think known corresponds to the BOX operator of
;;;  modal logics.  The modal  operator (~BOX~), is [not [known [not ...]]].
;;;

(define-predicate-model known-model () (default-rule-compilation-model)
  (:required-instance-variables predication)) 

(define-predicate-method (ask known-model) (truth-value continuation do-backward-rules do-questions)
  (unless (predicationp predication)
    (signal 'model-cant-handle-query
	    :query self
	    :model 'known-model))
  (select truth-value
    (*true*
     (flet ((known-continuation (derivation)
	      (stack-let ((known-derivation `(,self ,truth-value known ,derivation)))
		(funcall continuation known-derivation))))
       (ask-internal predication *true* #'known-continuation
		     do-backward-rules do-questions)
       (ask-internal predication *false* #'known-continuation
		     do-backward-rules do-questions)))
    (*false*
     (when (block try-queries
	     (flet ((unknown-continuation (ignore)
		      (return-from try-queries nil)))
	       (ask-internal predication *true* #'unknown-continuation
			     do-backward-rules do-questions)
	       (ask-internal predication *false* #'unknown-continuation
			     do-backward-rules do-questions)
	       t))
       (stack-let ((unknown-derivation `(,self ,truth-value known)))
	 (funcall continuation unknown-derivation)))))
  (values))

(define-predicate-method (expand-forward-rule-trigger known-model) (support-variable-name truth-value context bound-variables)
  (ignore support-variable-name context)
  (when (null support-variable-name) (setq support-variable-name (gensym)))
  (let ((query (if (eql truth-value *true*) self `(predication-maker '(not ,self)))))
    `(:procedure
       (ask ,query
	    #'(lambda (thingy) (succeed (third (fourth thingy))))
	    :do-backward-rules nil :do-questions nil)
       ,support-variable-name
       ,bound-variables)))

(define-predicate known (predication) (known-model trivial-tms-mixin)
  :destructure-into-instance-variables)

(define-predicate-model provable-model () (default-rule-compilation-model)
  (:required-instance-variables predication))

(define-predicate-method (ask provable-model) (truth-value continuation do-backward-rules do-questions)
  (unless (predicationp predication)
    (signal 'model-cant-handle-query
	    :query self
	    :model 'provable-model))
  (select truth-value
    (*true*
     (ask-internal predication *true*
		   #'(lambda (derivation)
		       (stack-let ((provable-derivation `(,self ,truth-value provable
							  ,derivation)))
			 (funcall continuation provable-derivation)))
		   do-backward-rules do-questions))
    (*false*
     (when (block try-queries
	     (ask-internal predication *true*
			   #'(lambda (ignore)
			       (return-from try-queries nil))
			   do-backward-rules do-questions)
	     t)
       (stack-let ((unprovable-derivation `(,self ,truth-value provable)))
	 (funcall continuation unprovable-derivation)))))
  (values))

(define-predicate provable (predication) (provable-model trivial-tms-mixin)
  :destructure-into-instance-variables)
1

0;;;
;;; LOCATION-VALUE-MODEL supplies INSERT, FETCH, and CLEAR methods.
;;; Presumably a UNJUSTIFY method should make the slot unbound, if this were TMS'd.
;;; You supply a function that gives a locative to where this predicate wants to store a value.
;;;

(defgeneric locate-predication-value (predication)
  "Given a predication, return a locative and parse out a value to put there."
  ;; If it has to, LOCATE-PREDICATION-VALUE can punt and return NIL for
  ;; the locative.  If INSERT is calling it, this will cause an error,
  ;; complaining that it can't figure out where to put it.  If FETCH
  ;; called it, VALUE should also be returned.  This will cause FETCH to
  ;; iterate over all the locatives that have been bashed, looking for
  ;; things that might unify with VALUE.
  (declare (values locative value)))

(define-predicate-model location-value-model () ()
  ;; You have to supply a method that gives a locative to where you want
  ;; the data put.  It takes the predication and parses out a locative
  ;; and a value.  "Find the place this predication wants to store its
  ;; data."
  )

(defmethod (locate-predication-value location-value-model) ()
  (error "You have failed to provide a locate-predication-value method for Predication ~S."
	 (type-of self)))

(defvar *location-value-model-locatives* nil
  "Kludge to store all locatives that got set, for purposes of CLEAR.")

(define-predicate-method (insert location-value-model) ()
  ;; INSERTing one of these goes and bashes some location to contain the value
  ;; and the predication that made it have that value (for TMS's).
  (multiple-value-bind (location value)
      ;; find the location of the data
      (locate-predication-value self)
    (cond ((null location)
	   ;; locator function punted
	   (error "LOCATE-PREDICATION-VALUE couldn't figure out how to locate ~S." self))
	  ((and (location-boundp location)
		(consp (location-contents location)))
	   ;; this location already has a value, and we probably understand it
	   (let ((entry (location-contents location)))
	     (if (eql (car entry) value)
		 ;; values are same
		 (values (cdr entry) nil)
		 ;; values are different
		 (if (nontrivial-tms-p self)
		     ;; there is a TMS present (wants ltms::backtrack, only generically)
		     (error
		       "This wants to backtrack, but the TMS stuff hasn't exposed it yet: ~S"
			    self)
		     ;; no TMS present, just bash existing cons -- value
		     ;;  car, predication  cdr
		     (let ((database-predication (copy-object-if-necessary self)))
		       (setf (car entry) value)
		       (setf (cdr entry) database-predication)
		       (pushnew location *location-value-model-locatives*)
		       (values database-predication t))))))
	  (t
	    ;; slot currently unbound, so bash it and tell the user we did so.
	    (let ((database-predication (copy-object-if-necessary self)))
	      (setf (location-contents location) (cons value database-predication))
	      (pushnew location *location-value-model-locatives*)
	      (values database-predication t))))))

(define-predicate-method (fetch location-value-model) (continuation)
  ;; FETCHing one of these goes and looks at various objects and their slots
  (multiple-value-bind (location value)
      ;; find the location of the data
      (locate-predication-value self)
    (flet ((process-location (location)
	     ;; see if we should succeed with this location
	     (when (and (location-boundp location)
			(consp (location-contents location))
			(predicationp (cdr (location-contents location))))
	       ;; at least there's some kind of sensible value there
	       (cond ((sys:unbound-logic-variable-p value)
		      ;; wants to bind value
		      (with-unification
			;; value is in car, predication that did it is in the cdr
			(%unify-variable value (car (location-contents location)))
			(funcall continuation (cdr (location-contents location)))))
		     ((eql (car (location-contents location)) value)
		      ;; wants to compare value, and they're eql
		      (funcall continuation (cdr (location-contents location))))))))	       
      (cond ((null location)
	     ;; locator function punted, so we're reduced to looking at all the locations
	     (mapc #'process-location *location-value-model-locatives*))
	    (t
	      ;; locator function found us the unique place to go
	      (process-location location))))))

;;; Note that a world having a concept of separate databases (domains, I
;;; think we called them once)  wouldn't have to do this kind of
;;; kludgery.  Maybe it would just be(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI") different0 kludgery, but at  least
;;; not 2this0 kludgery.
(define-predicate-method (clear location-value-model) (&optional (clear-database t) ignore)
  ;; make all the locatives we've bashed with this mechanism get unbound.
  (when clear-database
    (loop for location in *location-value-model-locatives*
	  doing (location-makunbound location))
    (setq *location-value-model-locatives* nil)))

(define-predicate-method (act-on-truth-value-change location-value-model) (old-truth-value)
  ;; update the slot if this becomes not *true*.
  (cond ((and (= old-truth-value *true*)
	      ( (predication-truth-value self) *true*))
	 ;; this used to be true, but isn't so anymore, so it must be removed.
	 (location-makunbound (locate-predication-value self)))
	((and ( old-truth-value *true*)
	      (= (predication-truth-value self) *true*))
	 ;; this used to be not true, but it is now, so it has to be added back.
	 (multiple-value-bind (location value)
	     (locate-predication-value self)
	   (setf (location-contents location) (cons value self))))))
1

0;;;; General TMS stuff.

;;; TMS-CONTRADICTION
;;; The flavor that is signalled when a contradiction is detected
;;; This has all the information you'd like:
;;;   The contradictory predication if any
;;;   The unsatisfiable clause if any
;;;   All the ground support
;;;    The subset of this which are premises
;;;    The subset of this which aren't premises
;;;    It takes a little time to calculate the last two sets, but it takes much longer
;;;       to make and process the signal so it doesn't matter
;;; TMS-HARD-CONTRADICTION
;;; A hard contradiction is signalled when the only support for a contradiction are premises.
;;; This is something that a user might want to consider really wrong, so we make a specific
;;; signal for this case.

;;; The general strategy:
;;;
;;; When a contradiction is detected we signal a tms-contradiction.  There is a default
;;; handler for this signal which handles a couple of cases automatically.  This handler can
;;; be overridden by specifically handling the tms-contradiction condition.
;;;
;;; The default handler takes special action if there is exactly one non-premise supporter.
;;; In that case it unjustifys that one guy and proceeds.
;;; If all the supporters are premises it signals a tms-hard-contradiction.
;;;
;;; By condition binding either or both of these conditions you can gain
;;; whatever control you'd like.

(defflavor tms-contradiction (justification contradictory-predication premises non-premises support)
	   (dbg:debugger-condition) ;force to debugger
  ;; This condition is a basic one for all TMS's -- it defines fairly nice
  ;; dbg:report and sys:proceed methods (which you can override if you are so minded)
  ;; Your TMS can define more specialized versions if it wants.
  :abstract-flavor
  :initable-instance-variables
  :readable-instance-variables)

(defgeneric tms-contradiction-hard-contradiction-flavor (tms-contradiction-condition-object))

(defflavor tms-hard-contradiction (justification contradictory-predication premises)
	   (error)
  :abstract-flavor
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (dbg:report tms-contradiction) (stream)
  (report-tms-contradiction stream premises non-premises justification contradictory-predication))

(defmethod (dbg:report tms-hard-contradiction) (stream)
  (report-tms-contradiction stream premises nil justification contradictory-predication))

(defvar *graphical-display-of-contradiction* t)

(defmacro without-indentation (stream &body body)
  `(unwind-protect
       (let ((old-indent (send ,stream :indentation)))
	 (unwind-protect
	     (progn
	       (send ,stream :set-indentation 0)
	       ,@body)
	   (send ,stream :set-indentation old-indent)))))

(defun report-tms-contradiction (stream premises non-premises justification contradictory-predication)
  ;; how to report a contradiction.
  (format stream "Backtracking because:")
  (when contradictory-predication
    (fresh-line stream)
    (print-without-truth-value contradictory-predication stream)
    (format stream " is contradictory")
    (unless non-premises
      (format stream " but has only premises in its support")))
  (when justification
    (format stream "~&~S is ~:[an~;the~] unsatisfiable ~(~a~)."
	    justification contradictory-predication (type-of justification)))
  (cond ((or (null *graphical-display-of-contradiction*)
	     ;;; You can't draw graphs on all streams
	     (null (send-if-handles stream :graphics-stream-p)))
	 (when non-premises
	   (format stream "~%The non-premise, primitive support underlying it is:")
	   (format-textual-list non-premises
				#'(lambda (x stream)
				    (multiple-value-bind (mnemonic predication)
					(destructure-justification x)
				      (dw:with-output-as-presentation (:stream stream
								       :object x
								       :single-box t
								       :type  `((member ,@non-premises)))
					(format stream "~&    The ~:(~a~) that ~a is ~:(~a~)"
						mnemonic
						(print-without-truth-value predication nil)
						(truth-value-name (predication-truth-value predication))))))
				:conjunction "and"
				:stream stream))
	 (when premises
	   (format stream "~%The premise support underlying it is:")
	   (format-textual-list premises
				#'(lambda (x stream)
				    (multiple-value-bind (mnemonic predication)
					(destructure-justification x)
				      (dw:with-output-as-presentation (:stream stream
								       :object x
								       :single-box t
								       :type `((member ,@premises)))
					(format stream "~&    The ~:(~a~) that ~a is ~:(~a~)"
						mnemonic
						(print-without-truth-value predication nil)
						(truth-value-name (predication-truth-value predication))))))
				:conjunction "and"
				:stream stream)))
	(t 
	  (flet ((draw-graph (stream)
		   (fresh-line stream)
		   (format-graph-from-root
		     contradictory-predication
		     #'(lambda (thing stream)
			 ;; node printer
			 (typecase thing
			   (predication (prin1 thing stream))
			   (otherwise
			     (dw:with-output-as-presentation
				 (:stream stream
				  :object thing
				  :single-box t
				  :type (if (member thing non-premises)
					    `((member ,@non-premises))
					    `((member ,@premises))))
			       (dw::centering-lines (stream)
				 (with-character-face (:bold stream)
				   (multiple-value-bind (mnemonic predication)
				       (destructure-justification thing)
				     (dw:with-output-as-presentation
					 (:stream stream
					  :object predication
					  :type 'predication-presentation)
				       (if (eql (predication-truth-value predication) *false*)
					   (format stream "[NOT ~a]" (print-without-truth-value predication nil))
					   (format stream "~a" (print-without-truth-value predication nil))))
				     (print mnemonic stream))))))))
		     #'(lambda (thing)
			 ;; the inferior producer -- graph is always one level
			 (when (eq thing contradictory-predication)
			   (append non-premises premises)))
		     :stream stream
		     :dont-draw-duplicates t
		     :root-is-sequence nil
		     :orientation :horizontal
		     :default-drawing-mode :arrow
		     :border :oval)))
	    ;; If we want to graph things inside the debugger we have to disable the indentation
	    (if (typep stream 'si:basic-indenting-stream)
		(without-indentation stream
		  (draw-graph stream))
		(draw-graph stream))
	    ))))

(defmethod (sys:proceed tms-contradiction :unjustify-subset)
	   (&optional (subset (accept `((sequence ((member ,@non-premises))))
				      :prompt "Subset to be unjustified")))
  "Pick a subset of these predications to be unjustified."
  (when (null subset)
    ;; I don't think the accept above will ever do this, but let's be safe.
    (error "You have to give a non-empty subset."))
  (loop for item in subset do (remove-justification item))
  (values :unjustify-subset subset))

(defmethod (sys:proceed tms-hard-contradiction :unjustify-premise-subset) ()
  "Pick a subset of the premises to be unjustified."
  (let* ((subset (cond ((null premises))
		       ((null (cdr premises))
			(multiple-value-bind (mnemonic predication)
			    (destructure-justification (car premises))
			  (format *query-io* "~&~s is the only ~:(~a~) in the support, I'll unjustify it"
				  predication mnemonic))
			premises)
		       ;; we've already printed the choices in the tms-contradiction condition handler
		       (t (accept `((sequence ((member ,@premises))))
				  :prompt "Subset to be unjustified")))))
    (cond ((null subset) nil)
	  (t (loop for item in subset doing (remove-justification item))
	     (values :unjustify-premise-subset subset)))))

;;; This is the magic default handler described above.  This tries to handle any
;;; condition based on tms-contradition (not tms-hard-contradiction).

(define-global-handler singleton-support-is-automatic-unjustify tms-contradiction
		       (condition-object)
  (let* ((premises (tms-contradiction-premises condition-object))
	 (non-premises (tms-contradiction-non-premises condition-object)))
    (cond ((= 1 (length non-premises))
	   ;; The real nice case, exactly one non-premise supporter, unjustify it.
	   (remove-justification (car non-premises))
	   (values :unjustify-subset (car non-premises)))
	  ((null non-premises)
	   ;; If there are only premises, signal the hard-condition error
	   ;; use the one corresponding to the condition we got.
	   (signal (tms-contradiction-hard-contradiction-flavor condition-object)
		   :premises premises
		   :justification (tms-contradiction-justification condition-object)
		   :contradictory-predication (tms-contradiction-contradictory-predication condition-object)))
	  ;; otherwise decline to handle and let dbg take over
	  (t nil))))

(compile-flavor-methods tms-contradiction tms-hard-contradiction)



;;;; Some useful functions to use with predications that satisfy non-trivial-tms-p

(defvar *generation-counter* 0 "A generation counter used by some TMS algorithms.")

(define-predicate-model basic-tms-mixin
			((generation-mark -1))
			()
  :initable-instance-variables
  :readable-instance-variables
  :locatable-instance-variables
  :writable-instance-variables
  (:required-flavors predication)
  (:conc-name predication-))

(define-predicate-method (nontrivial-tms-p basic-tms-mixin) ()
  ;; this one 2really0 supports the TMS protocol.
  t)

(define-predicate-method (untell basic-tms-mixin) ()
  (loop for justification in (all-justifications self)
	doing (unjustify self justification))
  (uninsert self))

(define-predicate-method (support basic-tms-mixin) (&optional filter)
  "Returns the predication leaves of the support tree for a predication"
  ;; filter is a function to apply to the unit justification to see if you want to collect it
  ;; nil means collect everything
  (let ((generation (incf *generation-counter*)))
    (labels ((trace-support-through-justification (justification)
	       (multiple-value-bind (ignore consequent true-support false-support unknown-support)
		   (destructure-justification justification)
		 (cond ((and (and (null true-support) (null false-support) (null unknown-support))
			     (or (null filter) (funcall filter justification)))
			(list consequent))
		       (t (loop for supporter in (append true-support false-support unknown-support)
				nconc (trace-support-through-predication supporter))))))
	     (trace-support-through-predication (predication)
	       (when (null (predication-generation-mark predication)) (setf (predication-generation-mark predication) -1))
	       (unless (= (predication-generation-mark predication) generation)
		 (setf (predication-generation-mark predication) generation)
		 (let ((current-justification (current-justification predication)))
		   (when current-justification
		     (trace-support-through-justification current-justification))))))
      (trace-support-through-predication self))))

;;; Find the primitive support with a specific mnemonic

(defun support-with-name (database-predication the-name)
  (support database-predication
	   #'(lambda (justification)
	       (multiple-value-bind (mnemonic ignore true-support false-support unknown-support)
		   (destructure-justification justification)
		 (and (eq the-name mnemonic)
		      (null true-support)
		      (null false-support)
		      (null unknown-support))))))

(defun assumption-support (database-predication) (support-with-name database-predication :assumption))

(defun premise-support (database-predication) (support-with-name database-predication :premise))

(defun remove-justification (justification)
  (multiple-value-bind (ignore supportee) (destructure-justification justification)
    (unjustify supportee justification)))


;;;
;;; Hacks to graph the dependency structures.
;;; These rely on generic functions of the protocol but are
;;; not themselves generic functions.

(defun explain (predication &optional depth (stream *standard-output*))
  ;; explain why a particular predication is believed.
  (flet ((explain-justification (justification stream depth)
	   (multiple-value-bind (mnemonic ignore true-support false-support unknown-support)
	       (destructure-justification justification)
	     (cond ((and (null true-support) (null false-support) (null unknown-support))
		    (format stream "It is ~\\a-an\\ ~a" mnemonic mnemonic))
		   (t
		     (format stream "It was derived from rule ~a" mnemonic)
		     ;; this seems a bit nicer than the old behavior, which was to follow the tree to its end.
		     (let ((all-literals (append true-support false-support unknown-support)))
		       (loop for literal in all-literals
			     do (explain literal (when depth (1- depth)) stream))))))))
    (when (or (null depth) ( depth 0)) 
      (let ((truth-value (predication-truth-value predication)))
	(terpri stream)
	(print-database-predication-without-truth-value predication stream)
	(write-string " is " stream)
	(present truth-value 'truth-value :stream stream)
	(when (or (null depth) ( depth 1))
	  (unless (= truth-value *unknown*)
	    (indenting-output (stream 2)
	      (terpri stream)
	      (explain-justification (current-justification predication) stream depth))))))))

(defun all-predications-p (predications)
  ;; true if arg is a list of predications.
  (and predications
       (every #'predicationp predications)))

(defun graph-tms-support (&rest predications)
  ;; show the supporters of a bunch of predications
  (check-type predications (satisfies all-predications-p) "a bunch of predications")
  (fresh-line)
  (with-character-size (:smaller t :bind-line-height t)
    (format-graph-from-root
      predications
      #'(lambda (pred stream)
	  (dw:with-output-as-presentation
	    (:stream stream :object pred :single-box t :allow-sensitive-inferiors nil
		     :type 'predication-presentation
		     :allow-sensitive-raw-text nil)
	    (dw::centering-lines (stream)
	      (print-database-predication-without-truth-value pred stream)
	      (terpri stream)
	      (with-character-face (:italic stream)
		(select (predication-truth-value pred)
		  (*true*)
		  (*false* (princ "(False)  " stream)))
		(let* ((clause-type (destructure-justification (current-justification pred))))
		  (case clause-type
		    ((:premise :assumption))
		    (otherwise
		      (princ "Rule " stream)))
		  (prin1 clause-type stream))))))
      #'(lambda (thing)
	  (etypecase thing
	    (predication (multiple-value-bind (ignore ignore true-support false-support unknown-support)
			     (destructure-justification
			       (current-justification thing))
			   (append true-support false-support unknown-support)))			       
	    (symbol nil)))
      :dont-draw-duplicates t
      :root-is-sequence t
      :orientation :vertical
      :default-drawing-mode :reverse-arrow
      ;; If you want to use :reverse-arrow you have to have branch-point :at-parent
      :branch-point :at-parent
      :border :rectangle)))


