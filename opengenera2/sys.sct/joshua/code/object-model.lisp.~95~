;;; -*- Base: 10; Mode: Joshua; Package: JOSHUA-INTERNALS; Syntax: Joshua -*-
;;; Created 11/01/88 21:43:09 by howie running on HOLBROOK at JAMAICA-PLAIN.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


;;;; The slot protocol.

;;; This predicate model is the mixin that links us to the slot protocol.
;;; It's defined here (but all the methods come much later) so that we can refer to 
;;; a writable-instance-variable from the slot methods.

(define-predicate-model slot-value-mixin (my-slot)
			(no-variables-in-data-mixin)
  (:conc-name "PREDICATION-")
  :writable-instance-variables)

;;; These generic-functions constitute the slot protocol as understood
;;; so far.  These are methods on Slot mixins.

;;; Called to index the predication
(defgeneric insert-new-predication (slot predication value))

;;; Called to remove the predication from the index
(defgeneric uninsert-predication (slot predication))

;;; Called to update the value cache when a predication changes truth-value.
(defgeneric notice-new-value (slot value predication))

;;; Called after all updating is done to allow inferences to be made in a consistent
;;; view of the world.
(defgeneric act-on-new-value (slot predication old-truth-value))

;;; Called to map over the values of a slot for ASK.
(defgeneric map-over-values (slot query continuation value-in-predication)
  "The Slot Protocol's Implementation of Ask-Data"
  (declare (sys:downward-funarg continuation)))

(defgeneric map-over-slot-backward-rule-triggers (slot continuation)
  "The Slot Protocol's Implementation of Map-over-backward-rule-triggers"
  (declare (sys:downward-funarg continuation)))

(defgeneric map-over-slot-backward-question-triggers (slot continuation)
  "The Slot Protocol's Implementation of Map-over-backward-Question-triggers"
  (declare (sys:downward-funarg continuation)))

(defgeneric slot-is-empty-p (slot)
  "Does this slot have an explicit value?")

(defgeneric slot-is-set-valued (slot)
  "Does this slot store multiple values?")

(defflavor prototype-slot
	(name
	 my-object
	 (forward-triggers nil)
	 (backward-triggers nil)
	 (backward-question-triggers nil))
	()
  (:conc-name "SLOT-")
  (:constructor make-prototype-slot (name my-object))
  (:initable-instance-variables name my-object)
  (:writable-instance-variables forward-triggers backward-triggers backward-question-triggers)
  (:locatable-instance-variables
   forward-triggers backward-triggers backward-question-triggers))

(compile-flavor-methods prototype-slot)

(defflavor basic-slot
	(name
	 current-value
	 current-predication
	 (all-predications nil)
	 my-object
	 prototype-slot)
	()
  :abstract-flavor
  (:conc-name "SLOT-")
  (:locatable-instance-variables current-value current-predication)
  (:method-combination act-on-new-value :progn)
  :writable-instance-variables)

(defmethod (reset-slot basic-slot) ()
  (variable-makunbound current-value)
  (variable-makunbound current-predication)
  (setq all-predications nil))

;;; Prototype slots don't have anything to reset
(defmethod (reset-slot prototype-slot) () nil)


;;; Two default methods that do nothing.
(defmethod (notice-new-value basic-slot :default) (value predication) (ignore value predication) nil)
(defmethod (act-on-new-value basic-slot :default) (predication old-truth-value)
  (ignore predication old-truth-value)
  nil)

;;; And one which does something.
(defmethod (insert-new-predication basic-slot :default) (predication value)
  (let ((already-there (assoc value all-predications)))
    (if already-there
	(values (cdr already-there) nil)
	(let ((canonicalized-predication `[,(type-of predication) ,self ,value]))
	  (setf (predication-my-slot canonicalized-predication) self)
	  (push (cons value canonicalized-predication) all-predications)
	  (values canonicalized-predication t)))))

(defmethod (map-over-slot-backward-rule-triggers basic-slot) (continuation)
  (loop for trigger in (slot-backward-triggers (slot-prototype-slot self))
	do (funcall continuation trigger)))

(defmethod (map-over-slot-backward-question-triggers basic-slot) (continuation)
  (loop for question in (slot-backward-question-triggers (slot-prototype-slot self))
	do (funcall continuation question)))

(defmethod (uninsert-predication basic-slot :default) (predication)
  (setq all-predications (delete predication all-predications :key #'cdr)))

(defmethod (nth-superpart basic-slot) (n)
  (loop for i below n
	for object = (slot-my-object self) then (basic-object-superpart-object object)
	do (ignore i)
	finally (return object)))

(defmethod (role-name basic-slot) () name)

(defmethod (path-name basic-slot) (&optional relative-to)
  (cond ((null my-object) (list name))
	((eql self relative-to) nil)
	((eql my-object relative-to) (list name))
	(t (append (path-name my-object relative-to) (list name)))))

(defmethod (sys:print-self basic-slot) (stream depth slashify-p)
  ;; how to print a slot with the ugly-printer
  (ignore depth slashify-p)
  (dw:with-output-as-presentation (:object self
				   :type 'slot-presentation
				   :stream stream)
    (format stream "#<SLOT ~a>" (path-name self))))



(defflavor truth-maintained-slot-mixin
	()
	()
  :abstract-flavor)

(defmethod (truth-maintained? truth-maintained-slot-mixin) () t)

(defflavor non-truth-maintained-slot-mixin
	()
	()
  :abstract-flavor)

(defmethod (truth-maintained? non-truth-maintained-slot-mixin) () nil)



;;; A mixin for slots whose value is a set.
;;; A set valued slot simply adds the value when it becomes
;;; true and deletes the value otherwise.
(defflavor set-valued-slot-mixin
	((current-value nil)
	 (current-predication nil))
	()
  :abstract-flavor
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (slot-is-empty-p set-valued-slot-mixin) () (null current-value))

(defmethod (slot-is-set-valued set-valued-slot-mixin) () t)

(defmethod (notice-new-value set-valued-slot-mixin) (value predication)
  (cond ((eql (predication-truth-value predication) *true*)
	 (pushnew value current-value)
	 (pushnew predication current-predication))
	(t (setq current-value (delete value current-value))
	   (setq current-predication (delete predication current-predication)))))

(defmethod (map-over-values set-valued-slot-mixin) (query continuation value-in-query)
  (let ((query-predicate (predication-predicate query)))
    (loop for value in current-value
	  for predication in current-predication
	  when (eql (predication-predicate predication) query-predicate)
	    doing (with-unification
		    (unify value-in-query value)
		    (stack-let ((backward-support `(,query ,*true* ,predication)))
		      (funcall continuation backward-support))))))


;;; The mixin for slots which are allowed to have only a unique value
;;; at a time.

(defflavor unique-valued-slot-mixin
	((number-of-true-predications 0))
	()
  :abstract-flavor
  (:required-flavors basic-slot)
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (slot-is-empty-p unique-valued-slot-mixin) () (not (variable-boundp current-value)))
(defmethod (slot-is-set-valued unique-valued-slot-mixin) () nil)

(defflavor truth-maintained-unique-valued-slot-mixin
	((number-of-true-predications 0))
	(unique-valued-slot-mixin)
  :abstract-flavor
  (:required-flavors basic-slot)
  :initable-instance-variables
  :writable-instance-variables)

(defflavor value-overriding-unique-valued-slot-mixin
	((number-of-true-predications 0))
	(unique-valued-slot-mixin)
  :abstract-flavor
  (:required-flavors basic-slot)
  :initable-instance-variables
  :writable-instance-variables)

(defwhopper (insert-new-predication truth-maintained-unique-valued-slot-mixin) (predication value)
  (multiple-value-bind (canonical-pred new) (continue-whopper predication value)
    (when new
      (loop for (nil . other-predication) in all-predications
	    unless (eql canonical-pred other-predication)
	    do (justify other-predication *false* 'unique-valued-slot (list canonical-pred))))
    (values canonical-pred new)))

(defmethod (notice-new-value value-overriding-unique-valued-slot-mixin :before) (value predication)
  (when (and (eql (predication-truth-value predication) *true*)
	     (variable-boundp current-value)
	     (not (eql value current-value)))
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")    ;; Should this be UNTELL?
0    (untell current-predication)))

(defmethod (notice-new-value unique-valued-slot-mixin) (value predication)
  (cond
    ((eql (predication-truth-value predication) *true*)
     ;; just blindly overwrite the value cell.  if this is the
     ;; unique true value, that's what we want.
     ;; If there turns out to be more than one true pred
     ;; we've got expensive contradiction handling to do anyhow.
     (setq current-value value)
     (setq current-predication predication)
     (incf number-of-true-predications))
    (t (decf number-of-true-predications)
       (when (zerop number-of-true-predications)
	 ;; If there are now no true predications, then
	 ;; make the cache unbound.  Otherwise, somebody will
	 ;; write a true value into the slot sooner or later.
	 (variable-makunbound current-value)
	 (variable-makunbound current-predication)))))

(defmethod (map-over-values unique-valued-slot-mixin) (query continuation value-in-query)
  (when (variable-boundp current-value)
    (when (eql (predication-predicate current-predication) (predication-predicate query))
      (with-unification
	(unify value-in-query current-value)
	(stack-let ((backward-support `(,query ,*true* ,current-predication)))
	  (funcall continuation backward-support))))))

(defun build-justification-from-backward-support (backward-support)
  (let (true false unknown)
    (labels ((build-justification-from-backward-support-internal (backward-support)
	       (when backward-support
		 (destructuring-bind (ignore truth-value type &rest stuff) backward-support
		   (let ((cached-result-in-query (when (listp type) (third type))))
		     (cond
		       ((typep type 'predication)
			(select truth-value
			  (*true* (push type true))
			  (*false* (push type false))
			  (*unknown* (push type unknown))))
		       (cached-result-in-query
			(select truth-value
			  (*true* (push cached-result-in-query true))
			  (*false* (push cached-result-in-query false))
			  (*unknown* (push cached-result-in-query unknown))))
		       (t (loop for thing in stuff
				doing (build-justification-from-backward-support-internal thing)))))))))
      (build-justification-from-backward-support-internal backward-support))
    (list (second (third backward-support)) true false unknown)))



;;; This mixin allows this slot to be connected to other slots.
;;; This allows "Wire Rules" to be run in the data representation.
;;; It's not clear that this makes sense with set-valued slots.
(defflavor slot-with-equalities-mixin
	((equal-cells nil) (block-propagation nil))
	()
  (:required-flavors basic-slot)
  (:conc-name "SLOT-")
  :abstract-flavor
  :initable-instance-variables
  :writable-instance-variables)

(defsubst propagate-equality (value destination source-predication equality-predication)
  (tell `[,(predication-predicate source-predication) ,destination ,value]
	:justification `(equal-to (,equality-predication ,source-predication))))

(defmethod (act-on-new-value slot-with-equalities-mixin :progn) (predication old-truth-value)
  (ignore old-truth-value)
  (when (eql (predication-truth-value predication) *true*)
    (loop for entry in equal-cells
	  for (cell justification) = entry
	  if (or (eql (predication-truth-value justification) *true*)
		   (truth-maintained? self))
	    do (propagate-equality current-value cell predication justification)
	  else do (push (cons current-value predication) (third entry)))))

(defmethod (allow-equalities? basic-slot :default) () nil)
(defmethod (allow-equalities? slot-with-equalities-mixin) () t)

(defmethod (insert-equality slot-with-equalities-mixin) (other-cell equality-predication &optional (reflect t))
  (when (allow-equalities? other-cell)
    (let ((cell-already-there (assoc other-cell equal-cells)))
      (cond (cell-already-there (values (second cell-already-there) nil))
	    (t (push (list other-cell equality-predication nil) equal-cells)
	       (when reflect
		 (insert-equality other-cell self equality-predication nil)
		 (when (variable-boundp current-value)
		   (if (listp (slot-current-value self))
		       (loop for value in (slot-current-value self)
			     for his-predication in (slot-current-predication self)
			     do (propagate-equality value other-cell his-predication equality-predication))
		       (propagate-equality (slot-current-value self) other-cell
					   (slot-current-predication self) equality-predication))))
	       (values equality-predication t))))))

(defmethod (uninsert-equality slot-with-equalities-mixin) (other-thing &optional (reflect t))
  (setq equal-cells (delete other-thing equal-cells :key #'car))
  (when reflect (uninsert-equality other-thing self nil)))

;; This is tricky.
;;
;; We're doing a backward-chaining kind of inference  but we
;; take advantage of the fact that there's an underlying
;; forward-chaining mechanism  for equalities.
;;
;; If there is no value in this slot, we spread out an activation
;; ring to everyone it's connected to, ASK'ing each of those
;; slots to get the value.  We allow rules and questions to be
;; invoked on them.  
;;
;; Since we cache deduced values, if one of the slots chained to
;; deduces a value, he'll TELL that that's his
;; value, and then the value will propagate back to us by the
;; forward-chaining slot-with-equalities mechanisms.
;;
;; We pass Ignore in as the continuation of ASK because this is
;; just a before method that causes the other slots to do some work
;; The first thing the main method does is to check for values
;; explicitly in the slot.  As just argued, the values will be
;; there.  So he'll call the continuation on it and therefore we
;; don't need to notice the other slots succeeding.
;;
;; Finally notice that this is a symmetric backward chaining
;; problem which has the usual problem of looping back and forth.
;; We block that by setting the "block propagation" instance-variable in the
;; slots.

(defmethod (map-over-values slot-with-equalities-mixin :before) (query ignore value-in-query)
  (when (and (slot-is-empty-p self) (not block-propagation))
    (setq block-propagation t)
    (unwind-protect
	(loop for equality-entry in equal-cells
	      for cell = (first equality-entry)
	      unless (slot-block-propagation cell)
		do (ask `[,(type-of query) ,cell ,value-in-query]
			#'ignore
			:do-backward-rules t :do-questions t))
      (setq block-propagation nil))))



;;; This mixin allows specific actions to be attached to the slot which
;;; are run after the slot is updated.  This allows "meters" "dials"
;;; etc. to work easily.  It also allows integrity constraints to be
;;; checked.
(defflavor slot-with-attached-actions-mixin
	((actions nil))
	()
  (:conc-name "SLOT-")
  (:required-flavors basic-slot)
  :abstract-flavor
  :initable-instance-variables 
  :writable-instance-variables)

(defmethod (act-on-new-value slot-with-attached-actions-mixin :progn) (predication old-truth-value)
  (let ((value (if (and (eql (predication-truth-value predication) *true*)
			(variable-boundp current-value))
		   current-value
		   (with-statement-destructured (ignore value) predication value))))
    (loop for (nil . function) in actions
	  doing (funcall function self value predication old-truth-value))))

;;; actions are indexed under a name

(defgeneric add-action (slot-or-path function &optional (name :action))
  (:function (if (typep slot-or-path 'slot-with-attached-actions-mixin)
		 (funcall (flavor:generic add-action) slot-or-path function name)
		 (let ((real-slot (follow-path-to-slot slot-or-path)))
		   (funcall (flavor:generic add-action) real-slot function name))))) 

(defmethod (add-action slot-with-attached-actions-mixin) (function &optional (name :action))
  (let ((existing-action-pair (find name actions :key #'car)))
    (if existing-action-pair
	(setf (cdr existing-action-pair) function)
	(push (cons name function) actions))))


(defgeneric remove-action (slot-or-path &optional (name :action))
  (:function (if (typep slot-or-path 'slot-with-attached-actions-mixin)
		 (funcall (flavor:generic remove-action) slot-or-path name)
		 (let ((real-slot (follow-path-to-slot slot-or-path)))
		   (funcall (flavor:generic remove-action) real-slot name)))))

(defmethod (remove-action slot-with-attached-actions-mixin) (&optional (name :action))
  (setq actions (delete name actions :key #'car)))

;;; This mixin notifies the parent object that the slot has been updated.
;;; This allows methods on the parent to do something.
(defflavor object-notifying-slot-mixin
	()
	()
  (:conc-name "SLOT-")
  (:required-flavors basic-slot)
  :abstract-flavor
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (act-on-new-value object-notifying-slot-mixin :progn) (predication old-truth-value)
  (declare (ignore old-truth-value))
  (when (variable-boundp current-value)
    (funcall (fdefinition `(setf ,name)) my-object current-value predication)))



(eval-when (compile load)
(defvar *slot-options* '(:set-valued :truth-maintenance :equalities :attached-actions :object-notifying))

(defvar *default-slot-options*
	`(:set-valued nil :truth-maintenance nil :equalities t :attached-actions nil :object-notifying nil))

(defvar *slot-mixture* '((:set-valued
			   (t set-valued-slot-mixin)
			   (nil (:truth-maintenance
				  (t truth-maintained-unique-valued-slot-mixin)
				  (nil value-overriding-unique-valued-slot-mixin))))
			 (:truth-maintenance
			   (t truth-maintained-slot-mixin)
			   (nil non-truth-maintained-slot-mixin))
			 (:equalities (t slot-with-equalities-mixin))
			 (:attached-actions (t slot-with-attached-actions-mixin))
			 (:object-notifying (t object-notifying-slot-mixin))))


(defun decode-slot-options-to-flavors (options)
  (labels ((decode (entry)
	     (if (symbolp entry)
		 (if (null entry) nil (list entry))
		 (let* ((name (car entry))
			(present (getf options name))
			(subentry (second (assoc present (cdr entry)))))
		   (decode subentry)))))
    (loop for entry in *slot-mixture*
	  append (decode entry)))))

(defun decode-slot-options-to-slot-type-constructor (options)
  (loop with type-number = 0
	for bit-position below 5
	for option-name in *slot-options*
	when (let ((value (getf options option-name 'not-present)))
	       (if (eql value 'not-present)
		   (getf *default-slot-options* option-name)
		   value))
	  do (setq type-number (logior (lsh 1 bit-position) type-number))
	finally (return (intern (string-upcase (format nil "make-slot-type-~d" type-number)) 'ji))))

(defmacro create-all-slot-types ()
  (let ((all-slot-names nil))
    (flet ((decode-integer-to-slot-options (i)
	     (loop for bit-position below 5
		   for option-name in *slot-options*
		   for bit-present = (not (zerop (logand (lsh 1 bit-position) i)))
		   when bit-present
		     collect option-name
		   and collect t)))
      `(progn
	 ,@(loop for i below 32
		 for options = (decode-integer-to-slot-options i)
		 for name = (intern (string-upcase (format nil "slot-type-~d" i)) 'ji)
		 do (push name all-slot-names)
		 collect `(defflavor ,name
				  ()
				  (,@(decode-slot-options-to-flavors options)
				   basic-slot)
			    (:constructor ,(intern (string-upcase (format nil "make-~a" name)) 'ji)
			     (name my-object))))
	 (compile-flavor-methods ,@all-slot-names)))))

(create-all-slot-types)



;;; associates name  object-type

(defvar *all-object-types* (make-hash-table :size 20))

(defflavor object-type
	((typical-instance nil)
	 (instances)
	 slot-names				;just my local slots
	 (all-slot-names nil)			;includes names of all supertypes' slots
	 name
	 (subtypes nil)
	 (supertypes nil)
	 (all-rules nil)
	 (rebuild-list nil)			;used when redefining an object type
	 (rule-triggers nil)
	 )
	()
  :writable-instance-variables
  :initable-instance-variables)

(defmethod (sys:print-self object-type) (stream depth slashify-p)
  ;; how to print a slot with the ugly-printer
  (ignore depth slashify-p)
  (format stream "#<TYPE ~s>" name))

(defvar *building-prototype* nil)

(defmethod (find-or-create-typical-instance object-type) ()
  (or typical-instance
      (let ((*building-prototype* t))
	(make-instance (object-type-name self)
		       :typical-instance-of-type? t
		       :superpart-object nil
		       :role-name nil))))

;;; Use hash tables in these three routines because
;;; the sets can get large.

(defmethod (map-over-subtypes object-type) (function)
  (declare (sys:downward-funarg function))
  (let ((subtypes-visited (make-hash-table)))
    (labels ((do-one-subtype (type)
	       (unless (gethash type subtypes-visited)
		 (setf (gethash type subtypes-visited) t)
		 (funcall function type)
		 (loop for subtype in (object-type-subtypes type)
		       do (do-one-subtype subtype)))))
      (do-one-subtype self))))

(defmethod (map-over-supertypes object-type) (function)
  (declare (sys:downward-funarg function))
  (let ((supertypes-visited (make-hash-table)))
    (labels ((do-one-supertype (type)
	       (unless (gethash type supertypes-visited)
		 (setf (gethash type supertypes-visited) t)
		 (funcall function type)
		 (loop for supertype in (object-type-supertypes type)
		       do (do-one-supertype supertype)))))
      (do-one-supertype self))))

(defmethod (clean-up-for-redefinition object-type) ()
  (let ((all-affected-types (make-hash-table)))
    (labels ((find-all-affected-stuff (type depth)
	       ;; Collect everything affected
	       ;; Subtypes and types whose typical object
	       ;; contains one of my objects as a subpart
	       ;; appropriately ordered.
	       (let ((his-current-depth (gethash type all-affected-types))
		     (next-depth (1+ depth)))
		 (when (or (null his-current-depth)
			   (> depth his-current-depth))
		   ;; If he's never been seen before or we're
		   ;; getting a deeper level, then keep going
		   ;; to the stuff he affects.  Otherwise, it's been
		   ;; seen witht the correct values already.
		   (setf (gethash type all-affected-types) depth)
		   (loop for subtype in (object-type-subtypes type)
			 do (find-all-affected-stuff subtype next-depth))
		   (loop for instance in (object-type-instances type)
			 for ultimate-superior = (ultimate-superpart instance)
			 when (basic-object-typical-instance-of-type? ultimate-superior)
			   do (find-all-affected-stuff (basic-object-type ultimate-superior) next-depth))))))
      (find-all-affected-stuff self 0))
    (let ((queue (make-heap)))
      ;; now heap sort them.
      (loop for depth being the hash-elements of all-affected-types with-key type
	    do (send queue :insert type depth))
      (setq rebuild-list (loop for type = (send queue :remove)
			       until (null type)
			       collect type))))
  ;; now kill all the prototypes
  (loop for type in rebuild-list
	for his-prototype = (object-type-typical-instance type)
	when his-prototype
	  do (kill his-prototype))
  (values))

(defmethod (make-instance object-type :after) (&rest ignore)
  (let* ((previous-type-object (object-type-named name))
	 (rebuild-list (when previous-type-object (object-type-rebuild-list previous-type-object))))
    (when previous-type-object
      (setq subtypes (object-type-subtypes previous-type-object)
	    all-rules (object-type-all-rules previous-type-object)
	    instances (object-type-instances previous-type-object)
	    rule-triggers (object-type-rule-triggers previous-type-object))
      (remove-object-type previous-type-object))
    (setf (gethash name *all-object-types*) self)
    (map-over-subtypes self #'(lambda (type) (setf (object-type-all-slot-names type) nil)))
    (loop for subtype in subtypes
	  do (add-supertype subtype self))
    (loop for supertype in supertypes
	  do (add-subtype supertype self))
    ;; This Cleans up the world when we make a new one of these
    ;; Links up the rule triggers to the new type
    ;; Rebuilds old instances
    (rebuild-dependent-types self (delete previous-type-object rebuild-list))))

;;; Notice that this guy only pulls stuff from its supertypes
;;; and it does this just by building the prototypical instance.
;;; There's no issue of needing to push to subtypes since
;;; they're going to get rebuilt too and only after I'm rebuilt.


(defvar *im-handling-bad-rule-patterns* nil)

(defvar *rebuilding-rules-for-type-redefinition* nil)

(defmethod (rebuild-dependent-types object-type) (rebuild-list)
  (labels ((rebuild-one-type (type)
	     ;; Nil out his slot-names so that no stale data is kept.
	     ;; This will be recalculated on demand.
	     ;; The prototype will only get built when needed.
	     ;; Now relink up rules.
	     (rebuild-rules type)
	     (rebuild-instances type))
	   (rebuild-rules (type)
	     (let ((*rebuilding-rules-for-type-redefinition* t))
	       ;; Notice that if this is the first time this type is defined there
	       ;; won't be any so nothing will happen.
	       (let ((losing-match-nodes nil)
		     (losing-backward-rules nil)
		     (losing-questions nil)
		     (old-rules (object-type-all-rules type)))
		 (setf (object-type-all-rules type) nil)
		 (let ((*im-handling-bad-rule-patterns* t))
		   (loop for rule-name in old-rules
			 for debug-info = (or (rule-debug-info rule-name) (question-info rule-name))
			 for rule-type = (if (typep debug-info 'rule-debug-info)
					     (rule-debug-info-control debug-info)
					     :backward-question)
			 when debug-info
			   do (case rule-type
				(:forward
				  ;; (format t "~%Rebuilding ~a for ~a" rule-name type)
				  (loop for (pattern pattern-truth-value) in (rule-debug-info-triggers debug-info)
					do (loop named find-node
						 for node in (rule-debug-info-network debug-info)
						 for truth-value = (rete-match-node-truth-value node)
						 when (eql pattern-truth-value truth-value)
						   do (loop for match-id in (rete-match-node-match-ids node)
							    when (and (eql rule-name (match-id-rule-name match-id))
								      (eql pattern (match-id-pattern match-id)))
							      do (condition-case (object)
								      (add-forward-rule-trigger
									pattern
									truth-value
									node
									(rule-debug-info-context debug-info)
									rule-name)
								    (bad-path (pushnew node losing-match-nodes)))
								 (return-from find-node (values)))
						 finally (error "No such pattern"))))
				(:backward
				  (destructuring-bind (pattern truth-value) (first (rule-debug-info-triggers debug-info))
				    (condition-case ()
					 (add-backward-rule-trigger pattern
								    truth-value
								    (rule-debug-info-network debug-info)
								    (rule-debug-info-context debug-info)
								    rule-name)
				       (bad-path (push rule-name losing-backward-rules)))))
				(:backward-question
				  (destructuring-bind (pattern truth-value) (question-info-pattern debug-info)
				    (condition-case ()
					 (add-backward-question-trigger pattern truth-value
									rule-name
									(question-info-context debug-info)
									rule-name)
				       (bad-path (push rule-name losing-questions))))))))
		 (flet ((grumble-about-type-redefinition (base-type dependent-type kind-of-thing)
			  (if (eql base-type dependent-type)
			      (format t "~&Because of the redefinition of type ~a the following ~a no longer make sense:"
				      (object-type-name base-type) kind-of-thing)
			      (format t
				      "~&Because the redefinition of type ~a affects type ~a the following ~a no longer make sense:"
				      (object-type-name base-type) (object-type-name dependent-type) kind-of-thing))))
		   (when losing-match-nodes
		     (grumble-about-type-redefinition self type "forward rules")
		     (let ((rule-names nil))
		       (loop for match-node in losing-match-nodes
			     do (loop for match-id in (rete-match-node-match-ids match-node)
				      for rule-name = (match-id-rule-name match-id)
				      do (pushnew rule-name rule-names)
					 (format t "~&The ~a pattern of ~a is invalid"
						 (match-id-pattern match-id) rule-name)))
		       (format t "~&These rules are being removed, please redefine them")
		       (mapc #'undefrule rule-names)))
		   (when losing-backward-rules
		     (grumble-about-type-redefinition self type "backward rules")
		     (format-item-list losing-backward-rules)
		     (format t "~&These rules are being removed, please redefine them")
		     (mapc #'undefrule losing-backward-rules))
		   (when losing-questions
		     (grumble-about-type-redefinition self type "questions")
		     (format-item-list losing-questions)
		     (format t "~&These questions are being removed, please redefine them")
		     (mapc #'undefquestion losing-questions))))))
	   (rebuild-instances (type)
	     (loop for existing-instance in (object-type-instances type)
		   unless (basic-object-typical-instance-of-type? (ultimate-superpart existing-instance))
		     do (rebuild-object existing-instance))))
    (rebuild-one-type self)
    (mapc #'rebuild-one-type rebuild-list)))

(defmethod (all-slot-names object-type) ()
  (unless all-slot-names
    (setq all-slot-names
	  (loop with all-names = slot-names
		for type in supertypes
		do (setq all-names (union all-names (all-slot-names type)))
		finally (return all-names))))
  all-slot-names)

(defun undefine-object-type (type-name)
  (let ((type (object-type-named type-name)))
    (when type
      (kill type))))

1;; Should this kill all its instances first?
0(defmethod (kill object-type) ()
  (flavor:remove-flavor name)
  (remove-object-type self))

(defvar *root*)

(defmethod (all-dependent-instances object-type) ()
  (let ((top-level-parts nil) (typical-instances nil))
    (labels ((one-more-time (type-object)
	       (loop for sub-type in (object-type-subtypes type-object)
		     doing (one-more-time sub-type))
	       (loop for instance in (object-type-instances type-object)
		     doing (do-an-instance instance)))
	     (do-an-instance (object)
	       (cond ((basic-object-typical-instance-of-type? object)
		      (pushnew object typical-instances))
		     ((or (eql (basic-object-superpart-object object) *root*)
			  (null (basic-object-superpart-object object)))
		      (pushnew object top-level-parts))
		     (t (do-an-instance (basic-object-superpart-object object))))))
      (one-more-time self)
      (values top-level-parts typical-instances))))

(defmethod (remove-object-type object-type) ()
  (remhash name *all-object-types*)
  (loop for supertype in supertypes
	doing (remove-subtype supertype self))
  (loop for subtype in subtypes
	doing (remove-supertype subtype self)))

(defmethod (add-supertype object-type) (who)
  (push who supertypes))

(defmethod (add-subtype object-type) (who)
  (push who subtypes))

(defmethod (remove-supertype object-type) (who)
  (setq supertypes (delete who supertypes)))

(defmethod (remove-subtype object-type) (who)
  (setq subtypes (delete who subtypes)))

(defmethod (add-instance object-type) (object)
  (pushnew object instances)
  ;; If this guy isn't part of a prototype structure
  ;; Then link up his slots to those of his prototype
  (unless *building-prototype*
    (labels ((link-up (prototype object)
	       (let ((slot-names (all-slot-names prototype)))
		 (loop for slot-name in slot-names 
		       for object-slot = (funcall slot-name object nil)
		       for prototype-slot = (funcall slot-name prototype nil)
		       do (setf (slot-prototype-slot object-slot) prototype-slot)) 
		 1;; Code here to check if I already have values and then to0 1map-over-forward-rule
		 ;; triggers for that value?
0		 )))
      (map-over-parallel-object-hierarchies (find-or-create-typical-instance self)
					    object #'link-up))))

(defmethod (set-typical-instance object-type) (object)
  (setq typical-instance object)
  (copy-rule-triggers self))

(defmethod (remove-instance object-type) (object typical-instance-p)
  (if typical-instance-p
      (setq typical-instance nil)
      (setq instances (delete object instances))))

(defsubst object-type-named (type-name)
  (gethash type-name *all-object-types*))

(defmethod (copy-rule-triggers object-type) ()
  (labels ((copy-triggers (from-prototype to-prototype)
	     ;; (format t "~&Copying triggers from ~a to ~a" from-prototype to-prototype)
	     ;; Copy the triggers in those slots that from-prototype
	     ;; provides to to-prototype.
	     (loop for slot-name in (all-slot-names from-prototype)
		   for from-slot = (funcall slot-name from-prototype nil)
		   for to-slot = (funcall slot-name to-prototype nil)
		   do (setf (slot-forward-triggers to-slot)
			    (append (slot-forward-triggers from-slot)
				    (slot-forward-triggers to-slot)))
		      (setf (slot-backward-triggers to-slot)
			    (append (slot-backward-triggers from-slot)
				    (slot-backward-triggers to-slot)))
		      (setf (slot-backward-question-triggers to-slot)
			    (append (slot-backward-question-triggers from-slot)
				    (slot-backward-question-triggers to-slot)))))
	   (do-one-piece-of-substructure (prototype)
	     (flet ((do-one-level-of-type (from-type)
		      ;;; Copy triggers throughout the substructure of this guy
		      ;;; from the slots it inherits from from-type
		      (let ((from-prototype (object-type-typical-instance from-type)))
			(unless (or (null from-prototype)
				    (eql from-prototype prototype))
			  ;; Map over substructure and copy slots
			  (map-over-parallel-object-hierarchies from-prototype prototype #'copy-triggers)))))
	       ;; Map Over all supertypes doing this
	       ;; Copying rule triggers throughout its part structure
	       ;; that it gets from any of its supertypes.
	       (map-over-supertypes (basic-object-type prototype) #'do-one-level-of-type))))
  (map-over-object-hierarchy #'do-one-piece-of-substructure typical-instance)))



(defgeneric basic-object-body-builder (basic-object))
(defgeneric basic-object-initializer (basic-object))
(defgeneric basic-object-prototype-builder (basic-object))
(defgeneric basic-object-substructure-builder (basic-object))

(defflavor basic-object
	((superpart-object nil)
	 (role-name nil)
	 (subparts (make-hash-table :size 10))
	 type
	 (typical-instance-of-type? nil)
	 (rete-states nil))
	()
  (:method-combination basic-object-body-builder :progn
		       basic-object-substructure-builder :progn
		       basic-object-prototype-builder :progn
		       basic-object-initializer (:progn :most-specific-last))
  (:initable-instance-variables role-name superpart-object
				typical-instance-of-type?)
  (:writable-instance-variables superpart-object role-name subparts)
  (:readable-instance-variables superpart-object role-name subparts type typical-instance-of-type?))

(defmethod (basic-object-body-builder basic-object :progn) () nil)
(defmethod (basic-object-initializer basic-object :progn) () nil)
(defmethod (basic-object-prototype-builder basic-object :progn) () nil)
(defmethod (basic-object-substructure-builder basic-object :progn) () nil)

(defmethod (all-slot-names basic-object) ()
  (when type
    (all-slot-names type)))

(defmethod (role-name basic-object) () role-name)

(defmethod (path-name basic-object) (&optional relative-to)
  (cond ((eql relative-to self) nil)
	(superpart-object
	 ;;could be nconc?
	 (append (path-name superpart-object relative-to) (list role-name)))
	(role-name (list role-name))
	(typical-instance-of-type? (list self))
	(t nil)))

(defmethod (object-type-of basic-object) ()
  (object-type-name type))

(defmethod (superpart basic-object) () superpart-object)

(defmethod (ultimate-superpart basic-object) ()
  (loop for thing = self then next
	for next = (superpart thing)
	until (null next)
	finally (return thing)))

(defmethod (sys:print-self basic-object) (stream depth slashify-p)
  ;; how to print an object with the ugly-printer
  (ignore depth slashify-p)
  (let ((name (if (variable-boundp type) (object-type-name type) (type-of self))))
    (dw:with-output-as-presentation (:stream stream
				     :object self
				     :type 'object-presentation)
      (if typical-instance-of-type?
	  (format stream "#<TYPICAL-~a>" name)
	  (let ((path (path-name self)))
	    (when (and (null path) (eql self *root*))
	      (setq path '(*root*)))
	    (format stream "#<OBJECT ~a>" (or path '(unnamed))))))
      ))

;;; apparently there is no need for error checking the case of running out of superparts

(defmethod (nth-superpart basic-object) (n)
  (loop for i below n
	for object = self then (basic-object-superpart-object object)
	do (ignore i)
	finally (return object)))

(defmethod (subpart-named basic-object) (role-name)
  (gethash role-name subparts))

(defmethod (add-part basic-object) (role-name part-object)
  (setf (gethash role-name subparts) part-object))

(defmethod (remove-part basic-object) (role-name part-object)
  (ignore part-object)
  (remhash role-name subparts))

(defvar *dont-link-up-types* nil)

(defmethod (make-instance basic-object) (&rest ignore)
  (rebuild-object self)
  (trigger-rules-when-created self))

(defmethod (trigger-rules-when-created basic-object) ()
  (when (and type (not *building-prototype*))
    (if *delay-rule-triggering*
	(push self *delay-rule-trigger-list*)
	(map-over-supertypes type
			     #'(lambda (type)
				 (declare (sys:downward-function))
				 (loop for trigger in (object-type-rule-triggers type)
				       do (rete-network-match-object trigger self)))))))

(defmethod (continue-suspended-forward-rule-triggering basic-object) ()
  (when type
    (map-over-supertypes type
			 #'(lambda (type)
			     (declare (sys:downward-function))
			     (loop for trigger in (object-type-rule-triggers type)
				   do (rete-network-match-object trigger self))))))

(defmethod (add-rete-state basic-object) (rete-state)
  (push rete-state rete-states))

(defmethod (rete-states basic-object) () rete-states)

(defmethod (rebuild-object basic-object) ()
  (when superpart-object
    (add-part superpart-object role-name self))
  (let ((type-object (object-type-named (type-of self))))
    (setq type type-object)
    (when type
      (if *building-prototype*
	  ;; If we're building prototype structure run the guy who
	  ;; makes prototype slots
	  (basic-object-prototype-builder self)
	  ;; We're building a real object
	  ;; use the guy who builds instance slots.
	  (basic-object-body-builder self))
      (basic-object-substructure-builder self)
      ;; Now that it's completely built
      ;; tell the type about it.
      (cond (typical-instance-of-type?
	     ;; This will also collect all rule triggers from the supertypes.
	     (set-typical-instance type-object self))
	    (t
	     ;; this links the object slots to those of its prototype.
	     (add-instance type-object self)
	     ;; Now that it's rules are linked
	     (unless *building-prototype*
	       ;; It might still be part of a prototype even if
	       ;; it itself isn't the prototype.  If it's not, I.e. if
	       ;; it's a real object, run the
	       ;; initializations.
	       (basic-object-initializer self)))))))

(defmethod (kill basic-object) ()
  (rete-network-delete-object self)
  (map-over-slots-of-object #'reset-slot self)
  (loop for object being the hash-elements of subparts
	doing (kill object))
  (when (and (variable-boundp type) type)
    (remove-instance type self typical-instance-of-type?)
    (setq type nil))
  (when superpart-object
    (remove-part superpart-object role-name self)))

(setq *root* (make-instance 'basic-object :role-name nil))

;;; don't reveal *root* to the casual typer of c-sh-A
(defun make-object (object-type &key name superpart-object)
  (when (null superpart-object) (setq superpart-object *root*))
  (make-instance object-type :role-name name :superpart-object superpart-object))

(defmacro part (role-name type)
  `(make-instance ',type
		  :role-name ',role-name
		  :superpart-object *root*))

(def-defining-form define-object-type
   :definer
   ((name &key slots parts equalities initializations included-object-types
	  other-instance-variables other-flavors)
    (declare (zwei:indentation 1 1))
    (multiple-value-bind (slot-names slot-options)
	(loop for s-d in slots
	      if (symbolp s-d)
		collect s-d into slot-names
		and collect nil into slot-options
	      else collect (car s-d) into slot-names
		   and collect (cdr s-d) into slot-options
	      finally (return (values slot-names slot-options)))
      (let ((initialization-tells
	      (loop for slot-name in slot-names
		    for slot-options in slot-options
		    for tms? = (getf slot-options :truth-maintenance)
		    for predication-name = (if tms? 'ltms:value-of 'value-of)
		    for set-valued = (getf slot-options :set-valued)
		    for init-form-present = nil
		    for init-form = nil
		    do (loop for (indicator value) on slot-options by #'cddr
			     when (eql indicator :initform)
			       do (setq init-form-present t init-form value))
		    when init-form-present
		      if (not set-valued)
			collect `(tell `[,',predication-name (,self ,',slot-name) ,,init-form])
		    else collect `(loop for value in ,init-form
					do (tell (predication-maker
						   `(,',predication-name (,self ,',slot-name) ,value)))))))
      `(progn
	 (let ((old-type-object (object-type-named ',name)))
	   (when old-type-object
	     (clean-up-for-redefinition old-type-object)))
	 (defflavor ,name
		 (,@slot-names ,@other-instance-variables)
		 (,@other-flavors ,@included-object-types basic-object)
	   (:conc-name "")
	   ,@(when other-instance-variables
	       `((:writable-instance-variables ,@(loop for thing in other-instance-variables
						       if (consp thing)
							 collect (car thing)
						       else collect thing))))
	   :initable-instance-variables)
	 ,@(loop for slot-name in slot-names
		 for his-slot-options in slot-options
		 when (getf his-slot-options :object-notifying)
		 collect `(defmethod ((setf ,slot-name) ,name :default) (new-value justifying-predication)
			    (ignore new-value justifying-predication)
			    ;; This method does nothing.  The updating of
			    ;; the slot contents is all done by Joshua and
			    ;; Slot Protocol methods.  In particular, then
			    ;; notice-truth-value-change and
			    ;; act-on-truth-value-change methods.
			    nil)
		 collect `(defmethod (,slot-name ,name) (&optional (value t))
			    (if value
				(slot-current-value ,slot-name)
				,slot-name)))
	 ,@(when slot-names
	     `((defmethod (basic-object-prototype-builder ,name) ()
		 ,@(loop for slot-name in slot-names 
			 collect `(setq ,slot-name 
					(make-prototype-slot ',slot-name self))))
	       (defmethod (basic-object-body-builder ,name) () 
		 ,@(loop for slot-name in slot-names
			 for his-slot-options in slot-options
			 for slot-constructor = (decode-slot-options-to-slot-type-constructor his-slot-options)
			 collect `(setq ,slot-name (,slot-constructor ',slot-name self))))))
	 ,@(when parts
	     `((defmethod (basic-object-substructure-builder ,name) ()
		 ,@(loop for (role-name type) in parts 
			 collect `(make-instance ',type 
						 :role-name ',role-name 
						 :superpart-object self)))))
	 ,@(when (or initialization-tells initializations equalities)
	     `((defmethod (basic-object-initializer ,name) ()
		 ,@initialization-tells
		 ,@initializations
		 ,@(when equalities
		     `((impose-equalities self ',equalities))))))
	 (make-instance 'object-type
			:supertypes (loop for name in ',included-object-types
					  collect (object-type-named name))
			:name ',name
			:slot-names ',slot-names)))))
   :killer undefine-object-type
   :type-name "Object Type")

(defmethod (impose-equalities basic-object) (equality-list)
  (flet ((impose-one-equality (from to)
	   (let* ((from-cell (condition-case (condition)
				  (follow-path-to-slot (cons self from))
				(bad-path
				  (format *error-output* "~&While building ~a, trying to impose equality between ~a and ~a"
					  self from to)
				  (terpri *error-output*)
				  (dbg:report condition *error-output*)
				  (return-from impose-one-equality (values)))))
		  (to-cell (condition-case (condition)
				(follow-path-to-slot (cons self to))
			      (bad-path
				(format *error-output* "~&While building ~a, trying to impose equality between ~a and ~a"
					  self from to)
				(terpri *error-output*)
				(dbg:report condition *error-output*)
				(return-from impose-one-equality (values)))))
		  (tms? (truth-maintained? from-cell)))
	     (tell `[,(if tms? 'ltms:equated 'equated) ,from-cell ,to-cell]))))
    (loop for (from to) in equality-list
	  do (impose-one-equality from to))))

(defflavor bad-path
	(whole-path first-bad-token current-object remaining-path)
	(error)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (dbg:report bad-path) (stream)
  (format stream "The path ~s is incorrect.~%There is no part of ~s named ~s.~%The rest of the path is ~s"
	  whole-path current-object first-bad-token remaining-path))

(compile-flavor-methods bad-path)

(defun follow-path (path &optional (fetch-value t))
  (if (null path)
      *root*
      (multiple-value-bind (initial-object list-of-keys)
	  (if (symbolp (car path))
	      (values *root* path)
	      (values (car path) (cdr path)))
	(loop for keys on list-of-keys
	      for key = (first keys)
	      for current-object = initial-object then next-object
	      until (null (cdr keys))
	      for next-object = (subpart-named current-object key)
	      when (null next-object)
		do (signal 'bad-path
			   :remaining-path keys
			   :whole-path path
			   :first-bad-token key
			   :current-object current-object)
	      finally (return
			(cond ((subpart-named current-object key))
			      ((member key (all-slot-names current-object))
			       (funcall key current-object fetch-value))
			      (t (signal 'bad-path
					 :remaining-path keys
					 :whole-path path
					 :first-bad-token key
					 :current-object current-object))))))))

;;; for internal use only - always returns a slot

(defun follow-path-to-slot (path &optional (error-if-bad-path t))
  (if (typep path 'basic-slot)
      path
      (multiple-value-bind (initial-object list-of-keys)
	  (if (symbolp (car path))
	      (values *root* path)
	      (values (car path) (cdr path)))
	(loop for keys on list-of-keys
	      for key = (car keys)
	      for current-object = initial-object then next-object
	      until (null (cdr keys))
	      for next-object = (subpart-named current-object key)
	      when (null next-object)
		do (if error-if-bad-path
		       (signal 'bad-path
			       :remaining-path keys
			       :whole-path path
			       :first-bad-token key
			       :current-object current-object)
		       (return nil))
	      finally (if (not (member key (all-slot-names current-object)))
			  (if error-if-bad-path
			      (signal 'bad-path
				      :remaining-path keys
				      :whole-path path
				      :first-bad-token key
				      :current-object current-object)
			      (return nil))
			  (return (funcall key current-object nil)))))))

(defun map-over-object-hierarchy (function-to-apply &optional initial-object)
  (declare (sys:downward-funarg function-to-apply))
  (labels ((handle-object (object)
	     (declare (sys:downward-function))
	     (funcall function-to-apply object)
	     (loop for part being the hash-elements of (basic-object-subparts object)
		   doing (handle-object part))))
    (if initial-object
	(handle-object initial-object)
	(loop for object-type being the hash-elements of *all-object-types*
	      doing (loop for part in (object-type-instances object-type)
			  doing (handle-object part))))))

(defun map-over-parallel-object-hierarchies (from-object to-object function)
  (labels ((do-one-level (from to)
	     (declare (sys:downward-function))
	     (funcall function from to)
	     (loop for part-of-from being the hash-elements of (basic-object-subparts from)
				    with-key role-name
		   for part-of-to = (gethash role-name (basic-object-subparts to))
		   doing (do-one-level part-of-from part-of-to))))
    (do-one-level from-object to-object)))

(defun map-over-slots-of-object (function-to-apply object)
  (declare (sys:downward-funarg function-to-apply))
  (loop for slot-name in (all-slot-names object)
	for slot = (funcall slot-name object nil)
	doing (funcall function-to-apply slot)))

(defun map-over-slots-in-object-hierarchy (function-to-apply &optional initial-object)
  (declare (sys:downward-funarg function-to-apply))
  (flet ((slot-mapper (object)
	   (declare (sys:downward-function))
	   (map-over-slots-of-object function-to-apply object)))
    (map-over-object-hierarchy #'slot-mapper initial-object)))

(defun clean-object-hierarchy ()
  (let ((protected-instances nil))
    ;; First protect the hierarchy under all the typical instances.
    (loop for object-type being the hash-elements of *all-object-types*
	  when (object-type-typical-instance object-type)
	  do (map-over-object-hierarchy
	       #'(lambda (thing)
		   (pushnew thing protected-instances))
	       (object-type-typical-instance object-type)))
    ;; Now kill any unprotected instances.
    (map-over-object-hierarchy
      #'(lambda (object)
	  (unless (member object protected-instances)
	    (kill object))))))



;;; The method for the slot-value-mixin Predicate-Model.

(define-predicate-method (clear slot-value-mixin) (ignore undefrule)
  ;; Dont reset slots here, part-of-mixin will take of it.
  (when undefrule
    (loop for type being the hash-elements of *all-object-types*
	  do (setf (object-type-all-rules type) nil))))

(define-predicate-method (insert slot-value-mixin) ()
  (with-statement-destructured (path value) self
    (let ((final-slot (if (listp path) (follow-path-to-slot path) path)))
      (insert-new-predication final-slot self value))))

(define-predicate-method (uninsert slot-value-mixin) ()
  (let ((slot (predication-my-slot self)))
    (when slot
      (setf (predication-my-slot self) nil)
      (uninsert-predication slot self))))

(define-predicate-method (notice-truth-value-change slot-value-mixin) (old-truth-value)
  (ignore old-truth-value)
  (with-statement-destructured (slot value) ()
    (notice-new-value slot value self)))

(define-predicate-method (act-on-truth-value-change slot-value-mixin) (old-truth-value)
  (unless (= (predication-bits-truth-value bits) old-truth-value)
    ;; before acting on it make sure it's still different
    (let ((slot (predication-my-slot self)))
      ;; Need to check this because telling this fact could have triggered
      ;; a rule which untold this fact which would have nil'd out the slot.
      (when slot
	(act-on-new-value slot self old-truth-value)))))

;;; We define our own Ask for slot-value-mixins for two reasons.
;;; First we resolve what the path means at this level rather than
;;; doing it once for data, once for rules and once for questions.
;;; Second we build a new continuation which caches the results of
;;; successful rule or question firing (i.e. it TELL's the answer).

(define-predicate-method (ask slot-value-mixin) (truth-value continuation do-backward-rules do-questions)
  (unless (eql truth-value *true*)
    (signal 'model-can-only-handle-positive-queries
	    :query self
	    :model (type-of self)))
  (with-statement-destructured (path ignore) self
    (flet ((handle-one-slot (slot)
	     (declare (sys:downward-function))
	     (setq my-slot slot)
	     (let ((he-was-empty (slot-is-empty-p my-slot)))
	       (setq do-backward-rules (and he-was-empty do-backward-rules)
		     do-questions (and he-was-empty do-questions)))
	     (ask-data self truth-value continuation)
	     ;; Now go get stuff from rules.  The continuation we
	     ;; pass on the rule stuff is hacked up to Tell the
	     ;; answer found and the call the real continuation.
	     ;; For efficiency we test here whether the answer
	     ;; will need truth-maintenance or not and build the
	     ;; correct continuation for that case.
	     (if (truth-maintained? slot)
		 (flet ((caching-continuation (backward-support)
			  (declare (sys:downward-function))
			  (with-statement-destructured (ignore value-in-query) self
			    (let ((new-pred (tell `[,(type-of self) ,slot ,value-in-query]
						  :justification (build-justification-from-backward-support
								   backward-support))))
			      (let ((rule-query (third backward-support)))
				(with-stack-list (new-rule-query (first rule-query) (second rule-query) new-pred)
				  (with-stack-list* (new-backward-support (first backward-support)
									  (second backward-support)
									  new-rule-query
									  (cdddr backward-support))
				    (funcall continuation new-backward-support))))))))
		   (when do-backward-rules
		     (ask-rules self truth-value #'caching-continuation do-questions))
		   ;; now go hack questions
		   (when do-questions
		     (ask-questions self truth-value #'caching-continuation)))
		 (flet ((caching-continuation (backward-support)
			  (declare (sys:downward-function))
			  (with-statement-destructured (ignore value-in-query) self
			    (tell `[,(type-of self) ,slot ,value-in-query])
			    (funcall continuation backward-support))))
		   (when do-backward-rules
		     (ask-rules self truth-value #'caching-continuation do-questions))
		   ;; now go hack questions
		   (when (and do-questions (slot-is-empty-p my-slot))
		     (ask-questions self truth-value #'caching-continuation))))))
      (cond
	((typep path 'basic-slot) (handle-one-slot path))
	((sys:unbound-logic-variable-p path)
	 ;; If the path is a variable it's a request to
	 ;; show everything.
	 (map-over-slots-in-object-hierarchy
	   #'(lambda (slot)
	       (with-unification
		 (unify path slot)
		 (handle-one-slot slot)))
	   *root*))
	(t ;; we have a real initial object.
	 ;; What about variables later in the path?
	 (let ((final-slot (follow-path-to-slot path nil)))
	   (when (typep final-slot 'basic-slot)
	     (handle-one-slot final-slot)))))))
  ;; make it clear that there is no interesting return value
  (values))

(define-predicate-method (ask-data slot-value-mixin) (ignore continuation)
  (with-statement-destructured (ignore value-in-query) self
    (map-over-values my-slot self continuation value-in-query)))

(define-predicate-method (map-over-backward-rule-triggers slot-value-mixin) (continuation)
  (map-over-slot-backward-rule-triggers my-slot continuation))

(define-predicate-method (map-over-backward-question-triggers slot-value-mixin) (continuation)
  (map-over-slot-backward-question-triggers my-slot continuation))

(define-predicate-method (prefetch-forward-rule-matches slot-value-mixin) (context continuation)
  (with-statement-destructured (path value) self
    (let ((type-name (find-object-type-in-trigger-pattern self (car path) context)))
      (loop for object in (object-type-instances (object-type-named type-name))
	    unless (basic-object-typical-instance-of-type? (ultimate-superpart object))
	    do (let ((final-slot (let ((*root* object)) (follow-path-to-slot (cdr path)))))
		 (with-unification
		   (unify (car path) object)
		   (map-over-values final-slot self 
				    #'(lambda (derivation)
					(funcall continuation (ask-database-predication derivation)))
				    value)))))))

(define-predicate-method (add-backward-rule-trigger slot-value-mixin :after) (ignore ignore context rule-name)
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest ignore) full-path
      (let ((type (object-type-named (find-object-type-in-trigger-pattern self object context))))
	(pushnew rule-name (object-type-all-rules type))))))

(define-predicate-method (add-backward-question-trigger slot-value-mixin :after) (ignore ignore context rule-name)
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest ignore) full-path
      (let ((type (object-type-named (find-object-type-in-trigger-pattern self object context))))
	(pushnew rule-name (object-type-all-rules type))))))

(define-predicate-method (add-forward-rule-trigger slot-value-mixin :after) (ignore ignore context rule-name)
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest ignore) full-path
      (let ((type (object-type-named (find-object-type-in-trigger-pattern self object context))))
	(pushnew rule-name (object-type-all-rules type))))))

(define-predicate-method (delete-backward-rule-trigger slot-value-mixin :after) (ignore rule-name context)
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest ignore) full-path
      (let ((type (object-type-named (find-object-type-in-trigger-pattern self object context))))
	(setf (object-type-all-rules type) (delete rule-name (object-type-all-rules type)))))))

(define-predicate-method (delete-backward-question-trigger slot-value-mixin :after) (ignore question-name context)
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest ignore) full-path
      (let ((type (object-type-named (find-object-type-in-trigger-pattern self object context))))
	(setf (object-type-all-rules type) (delete question-name (object-type-all-rules type)))))))

(define-predicate-method (delete-forward-rule-trigger slot-value-mixin :after) (ignore rule-name context)
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest ignore) full-path
      (let ((type (object-type-named (find-object-type-in-trigger-pattern self object context))))
	(setf (object-type-all-rules type) (delete rule-name (object-type-all-rules type)))))))

;;; The context is always source code
(defmethod (find-object-type-in-trigger-pattern slot-value-mixin) (object context)
  ;; object is a real object
  (let ((thing-to-match (if (sys:unbound-logic-variable-p object)
			    (logic-variable-name object)
			    object)))
    (labels ((find-in-current-context (sub-context)
	       (cond ((predication-maker-p sub-context)
		      (let ((predicate (predication-maker-predicate sub-context)))
			(cond ((is-an-object-type-of-predicate predicate)
			       (with-predication-maker-destructured (thing type) sub-context
				 (when (same-as-object thing)
				   (return-from find-object-type-in-trigger-pattern type))))
			      (t
			       (loop for piece in (predication-maker-statement sub-context)
				     doing (find-in-current-context piece))))))
		     ((listp sub-context)
		      (loop for thing in sub-context doing (find-in-current-context thing)))))
	     (is-an-object-type-of-predicate (predicate-name)
	       (let ((his-flavor (flavor:find-flavor predicate-name nil 'flavor::compile)))
		 (and his-flavor
		      (member 'type-of-mixin (flavor:get-all-flavor-components predicate-name 'flavor::compile)))))
	     (same-as-object (thing)
	       ;; Thing is from the context, meaning it's a designator
	       (cond ((logic-variable-maker-p thing)
		      (eql (logic-variable-maker-name thing) thing-to-match))
		     (t (eql thing thing-to-match)))))		    
      (find-in-current-context context))))

(define-predicate-method (write-backward-rule-matcher slot-value-mixin) (variables environment name-of-pred-to-match)
  (ignore variables environment)
  (with-predication-maker-destructured (path value) ()
    (let ((my-object (car path))
	  (my-path-length (length (cdr path))))
      (values
	`(progn
	   (let ((statement (cdr (predication-statement ,name-of-pred-to-match))))
	     (let ((his-path (pop statement)))
	       (unify ,(if (logic-variable-maker-p my-object)
			   (logic-variable-maker-name my-object)
			   `',my-object)
		      (nth-superpart (follow-path-to-slot his-path) ,my-path-length)))
	     (let ((his-value (pop statement)))
	       (unify ,(if (logic-variable-maker-p value)
			  (logic-variable-maker-name value)
			  `',value)
		      his-value))))
	nil
	nil))))

(define-predicate-method (locate-backward-rule-trigger slot-value-mixin) (truth-value continuation context rule-name)
  (unless (eql truth-value *true*)
    (error "this ~s pattern for rule ~s has a truth value which isn't *true*" self rule-name))
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest path) full-path
      (let ((type (find-object-type-in-trigger-pattern self object context)))
	(unless type
	  (error "this rule uses slot-value pattern ~s but does not contain a type pattern" self))
	(setq type (object-type-named type))
	(let ((canonical-node-to-return nil))
	  (labels ((do-one-type (subtype)
		     ;; (format t "~&Doing type ~s for rule ~s pattern ~s"
		     ;;    (object-type-name subtype) rule-name self)
		     (let ((typical-instance (cond (*rebuilding-rules-for-type-redefinition*
						    (find-or-create-typical-instance subtype))
						   (t (if (eql subtype type)
							  (find-or-create-typical-instance subtype)
							  (object-type-typical-instance subtype))))))
		       ;; Make sure there is one.
		       ;; Necessary because this can get called during the course
		       ;; of redefining a type.  In that case the type has subtypes
		       ;; but their typical instances have been killed.
		       ;; We don't need to push stuff forward to those guys anyhow
		       ;; since they're about to get built and they'll get this stuff
		       ;; by pulling it.
		       (when typical-instance
			 (do-one-object typical-instance)))
		     (loop for instance in (object-type-instances subtype)
			   when (basic-object-typical-instance-of-type? (ultimate-superpart instance))
			     do (do-one-object instance)))
		   (do-one-object (object)
		     (let ((real-path (cons object path)))
		       (let ((slot (condition-bind
				     ((bad-path
					(lambda (condition)
					  (declare (ignore condition))
					  (unless *im-handling-bad-rule-patterns*
					    (format *error-output*
						    "~%While trying to install the ~a pattern~%of the backward rule ~a~%"
						    self rule-name))
					  nil)))
				     (follow-path-to-slot real-path))))
			 (multiple-value-bind (new-triggers something-changed the-canonical-node)
			     (funcall continuation (slot-backward-triggers slot))
			   ;; (format t "~&Something changed? ~s canonical ~s" something-changed the-canonical-node)
			   (when something-changed
			     (setf (slot-backward-triggers slot) new-triggers))
			   (setq canonical-node-to-return the-canonical-node))))))
	    (if *rebuilding-rules-for-type-redefinition*
		(do-one-type type)
		(map-over-subtypes type #'do-one-type)))
	  canonical-node-to-return)))))

(define-predicate-method (locate-backward-question-trigger slot-value-mixin) (truth-value continuation context question-name)
  (unless (eql truth-value *true*)
    (error "The ~s question's pattern ~s has a truth value which isn't *true*" question-name self))
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest path) full-path
      (let ((type (find-object-type-in-trigger-pattern self object context)))
	(unless type
	  (error "this rule uses slot-value pattern ~s but does not contain a type pattern" self))
	(setq type (object-type-named type))
	(let ((canonical-node-to-return nil))
	  (labels ((do-one-type (subtype)
		     ;; (format t "~&Doing type ~s for rule ~s pattern ~s"
		     ;;    (object-type-name subtype) rule-name self)
		     (let ((typical-instance (cond (*rebuilding-rules-for-type-redefinition*
						    (find-or-create-typical-instance subtype))
						   (t (if (eql subtype type)
							  (find-or-create-typical-instance subtype)
							  (object-type-typical-instance subtype))))))
		       ;; Make sure there is one.
		       ;; Necessary because this can get called during the course
		       ;; of redefining a type.  In that case the type has subtypes
		       ;; but their typical instances have been killed.
		       ;; We don't need to push stuff forward to those guys anyhow
		       ;; since they're about to get built and they'll get this stuff
		       ;; by pulling it.
		       (when typical-instance
			 (do-one-object typical-instance)))
		     (loop for instance in (object-type-instances subtype)
			   when (basic-object-typical-instance-of-type? (ultimate-superpart instance))
			     do (do-one-object instance)))
		   (do-one-object (object)
		     (let ((real-path (cons object path)))
		       (let ((slot (condition-bind
				     ((bad-path
					(lambda (condition)
					  (declare (ignore condition))
					  (unless *im-handling-bad-rule-patterns*
					    (format *error-output*
						    "~%While trying to install the ~a pattern~%of the backward question ~a~%"
						    self question-name))
					  nil)))
				     (follow-path-to-slot real-path))))
			 (multiple-value-bind (new-triggers something-changed the-canonical-node)
			     (funcall continuation (slot-backward-question-triggers slot))
			   ;; (format t "~&Something changed? ~s canonical ~s" something-changed the-canonical-node)
			   (when something-changed
			     (setf (slot-backward-question-triggers slot) new-triggers))
			   (setq canonical-node-to-return the-canonical-node))))))
	    (If *rebuilding-rules-for-type-redefinition*
		(do-one-type type)
		(map-over-subtypes type #'do-one-type)))
	  canonical-node-to-return)))))

(define-predicate-method (write-forward-rule-semi-matcher slot-value-mixin) (predication-to-match ignore)
  (with-predication-maker-destructured (path value) ()
    (let ((my-object (car path))
	  (my-path-length (length (cdr path))))
      `(and
	 (let ((statement (cdr (predication-statement ,predication-to-match))))
	   (let ((his-cell (pop statement)))
	     ,(cond ((logic-variable-maker-p my-object)
		     `(progn (setq ,(logic-variable-maker-name my-object)
				   (nth-superpart his-cell ,my-path-length))
			     t))
		    (t `(eq ',my-object (nth-superpart his-cell ,my-path-length)))))
	   (let ((his-value (pop statement)))
	     ,(cond ((logic-variable-maker-p value)
		     `(progn (setq ,(logic-variable-maker-name value) his-value)
			     t))
		    (t `(eq ',value his-value)))))))))

(define-predicate-method (positions-forward-rule-matcher-can-skip slot-value-mixin) ()
  ;; return list of tails of statement that are headed by symbols
  (let ((statement (predication-maker-statement self)))
    (cons statement
	  (loop for token = (cadr statement) then (cdr token)
		while (consp token)
		;; needn't deal with tail variable, since variables can't ever be skipped anyway
		when (or (symbolp (car token)) (numberp (car token))) collect token))))


;;; This checks every instance to see if its ultimate parent 
;;; is a typical instance and if so shoves the thing there also.

;;; This checks every instance to see if its ultimate parent 
;;; is a typical instance and if so shoves the thing there also.

(define-predicate-method (locate-forward-rule-trigger slot-value-mixin) (truth-value continuation context rule-name)
  (ignore rule-name) 
  (unless (eql truth-value *true*)
    (error "this rule's pattern ~s has a truth value which isn't *true*" self))
  (with-statement-destructured (full-path ignore) self
    (destructuring-bind (object &rest path) full-path
      (let ((type-name (find-object-type-in-trigger-pattern self object context))
	    (type nil))
 	(unless type-name 
	  (error "This rule uses slot-value pattern ~s but does not contain a type pattern" self))
	(setq type (object-type-named type-name))
	(unless type
	  (error "The rule pattern ~s believes that ~s has object-type ~s which isn't defined" self object type-name))
	(let ((canonical-node-to-return nil))
	  (labels ((do-one-type (subtype)
		     ;; (format t "~&Doing type ~s for rule ~s pattern ~s"
		     ;;         (object-type-name subtype) rule-name self)
		     (let ((typical-instance (cond (*rebuilding-rules-for-type-redefinition*
						    (find-or-create-typical-instance subtype))
						   (t (if (eql subtype type)
							  (find-or-create-typical-instance subtype)
							  (object-type-typical-instance subtype))))))
		       ;; Make sure there is one.
		       ;; Necessary because this can get called during the course
		       ;; of redefining a type.  In that case the type has subtypes
		       ;; but their typical instances have been killed.
		       ;; We don't need to push stuff forward to those guys anyhow
		       ;; since they're about to get built and they'll get this stuff
		       ;; by pulling it.
		       (when typical-instance
			 ;; (format t " typical = ~a" typical-instance)
			 (do-one-object typical-instance)))
		     (loop for instance in (object-type-instances subtype)
			   when (basic-object-typical-instance-of-type? (ultimate-superpart instance))
			     do (do-one-object instance)))
		   (do-one-object (object)
		     (let ((real-path (cons object path)))
		       (let ((slot (condition-bind
				     ((bad-path
					(lambda (condition)
					  (declare (ignore condition))
					  (unless *im-handling-bad-rule-patterns*
					    (format *error-output*
						    "~%While trying to install the ~a pattern~%of the forward rule ~a~%"
						    self rule-name))
					  nil)))
				     (follow-path-to-slot real-path))))
			 (multiple-value-bind (new-triggers something-changed the-canonical-node)
			     (funcall continuation (slot-forward-triggers slot))
			   ;; (format t "~&Something changed? ~s canonical ~s" something-changed the-canonical-node)
			   (when something-changed
			     (setf (slot-forward-triggers slot) new-triggers))
			   (setq canonical-node-to-return the-canonical-node))))))
	    (if *rebuilding-rules-for-type-redefinition*
		(do-one-type type)
		(map-over-subtypes type #'do-one-type)))
	  canonical-node-to-return)))))

(define-predicate-method (map-over-forward-rule-triggers slot-value-mixin) (continuation)
  (let ((final-slot (slot-prototype-slot (predication-my-slot self))))
    (loop for trigger in (slot-forward-triggers final-slot) 
	  do (funcall continuation trigger))))

(define-predicate value-of (path value) (slot-value-mixin trivial-tms-mixin default-protocol-implementation-model))
(define-predicate ltms:value-of (path value) (slot-value-mixin ltms:ltms-mixin default-protocol-implementation-model))



;;; Object-Type-of can only be asked, never told.

(define-predicate-model type-of-mixin () (tell-error-model ask-data-only-mixin no-variables-in-data-mixin))

(define-predicate-method (locate-forward-rule-trigger type-of-mixin) (truth-value continuation ignore ignore)
  (unless (eql truth-value *true*)
    (error "this rule's pattern ~s has a truth value which isn't *true*" self))
  (with-statement-destructured (ignore type-name) self
    (let ((type (object-type-named type-name)))
      (unless type
	(error "The rule pattern ~s refers to the object-type ~s which isn't defined" self type-name))
      (multiple-value-bind (new-triggers something-changed the-canonical-node)
	  (funcall continuation (object-type-rule-triggers type))
	(when something-changed
	  (setf (object-type-rule-triggers type) new-triggers))
	the-canonical-node))))

(define-predicate-method (prefetch-forward-rule-matches type-of-mixin) (ignore continuation)
  (with-statement-destructured (ignore type-name) self
    (let ((type (object-type-named type-name)))
      (labels ((next-subtype (type)
		 (loop for instance in (object-type-instances type)
		       do (funcall continuation instance))
		 (loop for subtype in (object-type-subtypes type)
		       do (next-subtype subtype))))
	(next-subtype type)))))

(define-predicate-method (write-forward-rule-semi-matcher type-of-mixin) (object-to-match ignore)
  (with-predication-maker-destructured (my-object ignore) ()
    (cond ((logic-variable-maker-p my-object)
	   `(progn (setq ,(logic-variable-maker-name my-object) ,object-to-match)
		   t))
	  (t `(eq ',my-object ,object-to-match)))))

(define-predicate-method (positions-forward-rule-matcher-can-skip type-of-mixin) ()
  ;; return list of tails of statement that are headed by symbols
  (loop for token = (cdr (predication-maker-statement self)) then (cdr token)
	while (consp token)
	;; needn't deal with tail variable, since variables can't ever be skipped anyway
	when (or (symbolp (car token)) (numberp (car token))) collect token))


(define-predicate-method (ask-data type-of-mixin) (truth-value continuation)
  (unless (eql truth-value *true*)
    (signal 'model-can-only-handle-positive-queries
	    :query self
	    :model (type-of self)))
  (with-statement-destructured (the-object type) self
    (when (sys:unbound-logic-variable-p type)
      (signal 'model-cant-handle-query
	      :query self
	      :model (type-of self)))
    (cond ((sys:unbound-logic-variable-p the-object)
	   (labels ((do-one-type (object-type)
		      (loop for instance in (object-type-instances object-type)
			    unless (basic-object-typical-instance-of-type? (ultimate-superpart instance))
			    do (with-unification
				 (unify instance the-object)
				 (stack-let* ((backward-support (list self *true* '(ask-data object-type-of)
								     (make-predication
								       `(,(predication-predicate self)
									 ,instance
									 ,(object-type-name object-type))
								       :stack)
								       )))
				   (funcall continuation backward-support))))
		      (loop for sub-type in (object-type-subtypes object-type)
			    do (do-one-type sub-type))))
	     (do-one-type (object-type-named type))))
	  (t (when (typep the-object type)
	       (stack-let ((backward-support (list self *true* '(ask-data object-type-of))))
		 (funcall continuation backward-support)))))))

(defun find-all-uses-of-object-type-in-trigger-pattern (object context)
  ;; Here we're working totally on source code
  (let ((object-name (logic-variable-maker-name object))
	(types nil)
	(uses-in-path nil)
	(uses-as-value nil))
    (labels ((find-in-current-context (sub-context enclosing-predication-maker kind-of-usage)
	       (cond ((predication-maker-p sub-context)
		      (let ((predicate (predication-maker-predicate sub-context)))
			(cond ((is-an-object-type-of-predicate predicate)
			       (with-predication-maker-destructured (thing type) sub-context
				 (when (same-as-object thing)
				   (push type types))))
			      ((is-a-value-of-predicate predicate)
			       (with-predication-maker-destructured (path value) sub-context
				 (find-in-current-context path sub-context 'in-path)
				 (find-in-current-context value sub-context 'as-value)))
			      (t
			       (loop for piece in (predication-maker-statement sub-context)
				     doing (find-in-current-context piece sub-context kind-of-usage))))))
		     ((and (logic-variable-maker-p sub-context)
			   (same-as-object sub-context))
		      (if (eql kind-of-usage 'in-path)
			  (push enclosing-predication-maker uses-in-path)
			  (push enclosing-predication-maker uses-as-value)))
		     ((listp sub-context)
		      (loop for thing in sub-context
			    doing (find-in-current-context thing enclosing-predication-maker kind-of-usage)))))
	     (is-an-object-type-of-predicate (predicate-name)
	       (let ((his-flavor (flavor:find-flavor predicate-name nil 'flavor::compile)))
		 (and his-flavor
		      (member 'type-of-mixin (flavor:get-all-flavor-components predicate-name 'flavor::compile)))))
	     (is-a-value-of-predicate (predicate-name)
	       (let ((his-flavor (flavor:find-flavor predicate-name nil 'flavor::compile)))
		 (and his-flavor
		      (member 'slot-value-mixin (flavor:get-all-flavor-components predicate-name 'flavor::compile)))))
	     (same-as-object (thing)
	       (and (logic-variable-maker-p thing)
		    (equal (logic-variable-maker-name thing) object-name))))
      (find-in-current-context context context nil)
      (values types uses-as-value uses-in-path))))

(define-predicate-method (expand-forward-rule-trigger type-of-mixin) (support-variable-name truth-value context bound-variables)
  (declare (ignore context bound-variables))
  (unless (eql truth-value *true*)
    (error "The rule pattern ~s does not have a truth-value of true" self))
  `(:object-match ,self ,support-variable-name ,truth-value))


(define-predicate-method (expand-backward-rule-action type-of-mixin) (support-variable-name truth-value other-ask-args context)
  (ignore support-variable-name other-ask-args context)
  (unless (eql truth-value *true*)
    (error "The rule pattern ~s does not have a truth-value of true" self))
  (with-predication-maker-destructured (thing type) self
    (multiple-value-bind (all-types uses-as-value uses-in-path)
	(find-all-uses-of-object-type-in-trigger-pattern thing context)
      (ignore all-types)
      ;; If the variable is used as the value of another predicate
      ;; and this isn't the leading thing in the context
      ;; it should turn into a type-of procedure check.
      (if (or uses-as-value (and (null uses-as-value) uses-in-path))
	  `(:procedure
	     (if (sys:unbound-logic-variable-p ,thing)
		 (ask-data ,self *true* #'(lambda (ignore) (succeed)))
		 (typep ,thing ',type))
	     ,support-variable-name)
	  `(:ignore)))))


(define-predicate object-type-of (object-name type) (type-of-mixin default-predicate-model))
(define-predicate ltms:object-type-of (object-name type) (type-of-mixin ltms:ltms-predicate-model))



;;; Part-of can only be asked, never told.

(define-predicate-model part-of-mixin ()
			(no-variables-in-data-mixin tell-error-model ask-data-only-mixin))

(define-predicate-method (ask-data part-of-mixin) (truth-value continuation)
  (unless (eql truth-value *true*)
    (signal 'model-can-only-handle-positive-queries
	    :query self
	    :model (type-of self)))
  (with-statement-destructured (parent-object child-object) self
    (cond
      ((and (sys:unbound-logic-variable-p parent-object)
	    (sys:unbound-logic-variable-p child-object))
       (map-over-object-hierarchy
	 #'(lambda (object)
	     (let ((superpart (basic-object-superpart-object object)))
	       (when superpart
		 (with-unification
		   (unify parent-object superpart)
		   (unify child-object object)
		   (stack-let ((backward-support (list self *true* '(ask-data part-of))))
		     (funcall continuation backward-support))))))
	 *root*))
      ((sys:unbound-logic-variable-p parent-object)
       (let ((object (basic-object-superpart-object child-object)))
	 (when object
	   (with-unification
	     (unify parent-object object)
	     (stack-let ((backward-support (list self *true* '(ask-data part-of))))
	       (funcall continuation backward-support))))))
      ((sys:unbound-logic-variable-p child-object)
       (loop for child being the hash-elements of (basic-object-subparts parent-object)
	     doing (with-unification
		     (unify child-object child)
		     (stack-let ((backward-support (list self *true* '(ask-data part-of))))
		       (funcall continuation backward-support)))))
      ((eql (basic-object-superpart-object child-object) parent-object)
       (stack-let ((backward-support (list self *true*)))
	 (funcall continuation backward-support))))))

(define-predicate-method (expand-forward-rule-trigger part-of-mixin) (support-variable-name truth-value context bound-variables)
  (declare (ignore context bound-variables))
  (unless (eql truth-value *true*)
    (error "The rule pattern ~s does not have a truth-value of true" self))
  `(:procedure
     (ask ,self
	  #'(lambda (ignore) (succeed))
	  :do-backward-rules nil :do-questions nil)
    ,support-variable-name))

(define-predicate-method (clear part-of-mixin) (clear-database ignore)
  (when clear-database
    ;; Kill all top-level objects, which recursively kill their children
    ;; and resets all the slots.
    (map-over-object-hierarchy
      #'(lambda (object)
	  (let ((parent (basic-object-superpart-object object)))
	  (when (or (null parent) (eql parent *root*))
	    (kill object)))))))

(define-predicate part-of (superpart-object subpart-object) (part-of-mixin default-predicate-model))
(define-predicate ltms:part-of (superpart-object subpart-object) (part-of-mixin ltms:ltms-predicate-model))




;;; EQUATED can be both ask'd and tell'd

(define-predicate-model equated-mixin () (no-variables-in-data-mixin))

(define-predicate-method (ask-data equated-mixin) (truth-value continuation)
  (unless (eql truth-value *true*)
    (signal 'model-can-only-handle-positive-queries
	    :query self
	    :model (type-of self)))
  (with-statement-destructured (cell1 cell2) self
    (flet ((do-one-cell (cell other)
	     (declare (sys:downward-function))
	     (when (listp cell) (setq cell (follow-path-to-slot cell)))
	     (loop for (other-cell supporting-predication) in (slot-equal-cells cell)
		   do (with-unification
			(unify (predication-predicate self) (predication-predicate supporting-predication))
			(unify other-cell other)
			(stack-let ((backward-support (list self *true* supporting-predication )))
			  (funcall continuation backward-support))))))
    (cond
      ((and (sys:unbound-logic-variable-p cell1)
	    (sys:unbound-logic-variable-p cell2))
       (signal 'model-cant-handle-query
	       :query self
	       :model (type-of self)))
      ((sys:unbound-logic-variable-p cell1) (do-one-cell cell2 cell1))
      ((sys:unbound-logic-variable-p cell2) (do-one-cell cell1 cell2))
      (t (unless (typep cell2 'basic-slot)
	   (setq cell2 (follow-path-to-slot cell2)))
	 (do-one-cell cell1 cell2))))))

(define-predicate-method (expand-forward-rule-trigger equated-mixin) (support-variable-name truth-value context bound-variables)
  (declare (ignore context bound-variables))
  (unless (eql truth-value *true*)
    (error "The rule pattern ~s does not have a truth-value of true" self))
  `(:procedure
     (ask ,self
	  #'(lambda (ignore) (succeed))
	  :do-backward-rules nil :do-questions nil)
    ,support-variable-name))

(define-predicate-method (insert equated-mixin) ()
  (let ((statement-changed nil))
    (with-statement-destructured (cell1 cell2) self
      (when (listp cell1) (setq cell1 (follow-path-to-slot cell1) statement-changed t))
      (when (listp cell2) (setq cell2 (follow-path-to-slot cell2) statement-changed t))
      (insert-equality cell1 cell2 (if statement-changed `[,(predication-predicate self) ,cell1 ,cell2] self)))))

(define-predicate-method (uninsert equated-mixin) ()
  (with-statement-destructured (cell1 cell2) self
    (uninsert-equality cell1 cell2)))

(define-predicate-method (act-on-truth-value-change equated-mixin) (ignore)
  (when (eql (predication-truth-value self) *true*)
    (with-statement-destructured (cell1 cell2) self
      (let ((entry-for-cell2 (find cell2 (slot-equal-cells cell1) :key #'second)))
	(when entry-for-cell2
	  (loop for (value . his-pred) in (third entry-for-cell2)
		do (propagate-equality value cell2 his-pred self))
	  (setf (third entry-for-cell2) nil)))
      (let ((entry-for-cell1 (find cell1 (slot-equal-cells cell2) :key #'second)))
	(when entry-for-cell1
	  (loop for (value . his-pred) in (third entry-for-cell1)
		do (propagate-equality value cell1 his-pred self))
	  (setf (third entry-for-cell1) nil))))))

(define-predicate equated (slot1 slot2) (equated-mixin default-predicate-model))
(define-predicate ltms:equated (slot1 slot2) (equated-mixin ltms:ltms-predicate-model))




;;; Presentation Type Niceties

(define-presentation-type slot-presentation ()
   :history t
   :description "a joshua slot"
   :typep ((object)
	   (typep object 'basic-slot))
   :expander 'sys:expression)

(define-multiple-command (com-change-slot-value :name "Change Slot Value")
			 (*joshua-command-table* *joshua-only-command-table*) 
    ((the-slot 'slot-presentation)
     (new-value 'sys:expression :prompt "New value for this slot" :provide-default nil))
   (tell `[value-of ,the-slot ,new-value]))

(define-multiple-command (com-set-slot-value :name "Set Slot Value")
			 (*joshua-command-table* *joshua-only-command-table*)
    ((the-slot 'slot-presentation))
   (tell `[value-of ,the-slot ,(accept 'sys:expression :prompt "New value for this slot" :provide-default nil)]))

(dw:define-presentation-to-command-translator slot-presentation-to-change-slot-value
   (slot-presentation
    :documentation "Modify this slot"
    :gesture :modify
    :priority 10)
   (the-slot)
  `(com-set-slot-value ,the-slot))



(define-presentation-type object-presentation ()
   :history t
   :description "a Joshua object"
   :typep ((object)
	   (typep object 'basic-object))
   :expander 'sys:expression)

(defmethod (show-object basic-object) (stream)
  (terpri stream)
  (formatting-table (stream :inter-column-spacing (* 5 (send stream :char-width)))
    (formatting-column-headings (stream :underline-p t)
      (formatting-cell (stream)
	(write-string "Slot Name" stream))
      (formatting-cell (stream)
	(write-string "Slot Value" stream)))
    (loop for slot-name in (all-slot-names self)
	  for slot = (funcall slot-name self nil)
	  for slot-has-value = (location-boundp (locf (slot-current-value slot)))
	  for slot-value = (when slot-has-value
			     (slot-current-value slot))
	  do (formatting-row (stream)
	       (formatting-cell (stream)
		 (write-string (string-capitalize-words slot-name) stream))
	       (formatting-cell (stream)
		 (dw:with-output-as-presentation (:stream stream
						  :object slot
						  :type 'slot-presentation)
		   (princ (if slot-has-value slot-value "Unbound") stream))))))
  (princ self stream))

(define-multiple-command (com-describe-joshua-object :name "Describe Object")
			 (*joshua-command-table* *joshua-only-command-table*)
    ((the-object 'object-presentation))
   (show-object the-object *standard-output*))

(dw:define-presentation-to-command-translator object-presentation-to-show-object
   (object-presentation
    :documentation "Describe This Object"
    :gesture :control-meta-left
    :priority 10)
   (the-object)
  `(com-describe-joshua-object ,the-object))
