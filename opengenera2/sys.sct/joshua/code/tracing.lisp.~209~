;;; -*- Mode: LISP; Syntax: Joshua; Base: 10; Package: JOSHUA-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; The Joshua tracing substrate

;;; This file contains:
;;;  
;;; The defflavor and methods for the following flavors
;;;
;;; 1.) Joshua-debbugger - keeps track of all of the global state of Joshua
;;; tracing. It makes sure that the right events are enabled and
;;; encapsulated. It provides the top level interface for enabling and
;;; disabling tracing. It knows how to do joshua encapsulations.

;;; 2.) tracing-event - each event at which we might want to trap out
;;; for tracing is defined as one of these. In addition there is a macro
;;; automatically defined for each event that you can insert into your
;;; code. It will make sure that the appropriate tracer is called when
;;; tracing for that event is enabled.
;;;
;;; 3.) Joshua-encapsulations - most events have associated
;;; encapsulations so the system can do the tracing related bookkeeping
;;; only when tracing is on. Encapsulations are cached and managed by
;;; the tracing-events which depend on them. When you enable the
;;; tracing of an event, it will encapsulate the appropriate functions.
;;; See also the file encapsulations.lisp where a number of the
;;; encapsulations are defined.
;;;
;;; 4.) tracers - Each "Type of Tracing" (Forward Rule Tracing, Backward
;;; Rule Tracing...) uses tracer as a component flavor. A tracer is
;;; defined to have a collection of associated tracing events and
;;; controls the interface to those events. The trace-it method of each
;;; tracer does the actual output for those events. They also keep track
;;; of any filtering the user wants to do on the traced events. For
;;; example the Forward Rule Tracer keeps a list of traced forward rule
;;; triggers.
;;;
;;; 4) forward-rule-tracer, backward-rule-tracer, predication-tracer,
;;; and tms-tracer - These are the flavors of the four types of tracers.
;;; 
;;; It also contains all of the definitions that create the instances of
;;; the event and the tracers and register them with joshua-debugger.
;;; See define-tracing-event and define-tracer

;;; First some defvars 
;;; Where to install joshua commands, for now we just stick them in Global
0(defvar *joshua-command-table* (cp:find-command-table "Global"))

1;;; This really just keeps a register of all the the strictly Joshua
;;; related commands0.1 Its not currently used by any command loop.
0(defvar *joshua-only-command-table*
	(cp:make-command-table "Joshua" :inherit-from '("Colon Full Command"
							"Standard arguments")))

(defvar *joshua-tracing-command-table*
	(cp:make-command-table "Joshua Trace" :inherit-from '("Colon Full Command"
							      "Standard arguments")))

1;;; Do the debugging tables need to be locked?
0(defvar *default-joshua-debugger-table-locking* nil)

1;;; Some character styles
0(defvar *heading-character-style* '(nil :bold nil))

(defvar *emphasis-character-style* '(nil :bold nil))

(defvar *deemphasis-character-style* '(nil :italic nil))

1;;; The prompt used for tracing interaction
0(defvar *joshua-tracing-prompt*
	(format nil "~VJoshua trace: ~" '(nil :italic nil)))

1;;; What charater to use to denote Joshua tracing messages
0(defvar *joshua-tracing-character* #\arrow:right-triangle)

1;;; Restrict the width of the menu used by the Joshua trace command
0(defvar *trace-options-menu-width* 60)

1;;; For now we'll continue to use rule depth to give tracing indentation
0(defmacro indenting-body ((stream) &body body)
  `(progn (indenting-output (,stream  #'joshua-trace-message-indentor)
	    ,@body)))

1;;; By wrapping all of the trace messages with this we make sure that 
;;; any output done by the user between trace outputs is done to a 
;;; new line, but at the same time we get the trace indentation for the 
;;; first line of the message.
0(defmacro with-joshua-trace-message-output ((stream) &body body)
  `(progn (fresh-line ,stream)
	  (loop for x from 0 to (* 2 *rule-depth*) do
	    (ignore x)
	    (write-char #\space ,stream))
	  (write-char *joshua-tracing-character* ,stream)
	  (write-char #\space ,stream)
	  ,@body
	  (fresh-line ,stream)
	  ))

1;;; A hack to draw lines before and/or after output to the screen
0(defmacro delineating-output ((&optional (stream *standard-output*)
					 &key (fraction-of-screen .8)
					 (location :around) (thickness 2))
			      &body body)
  (let ((right-edge (gensym))
	(draw-line (sys:gensymbol "DRAW-LINE")))
    `(flet ((,draw-line (where)
	     (when (member ,location  `(,where :around))
	       (when (eq where :after)
		 (terpri ,stream) (terpri ,stream))
	       (multiple-value-bind (nil nil ,right-edge)
		   (send ,stream :visible-cursorpos-limits :pixel)
		 (graphics:with-room-for-graphics (,stream (1+ ,thickness))
		   (graphics:draw-line 0 1 (floor (* ,fraction-of-screen ,right-edge))
				       1
				       :thickness ,thickness
				       :stream ,stream))))))
       (fresh-line ,stream)
       (,draw-line :before)
       ,@body
       (,draw-line :after))))

1;;; A little utility function
0(defun print-with-truth-value-as-not (predication truth-value &optional
						     (stream *standard-output*))
  (select truth-value
    ((*true* nil)
     (print-without-truth-value predication stream))
    (*false*
     (princ "1[not 0" stream)
     (print-without-truth-value predication stream)
     (princ "1]0" stream))
    (*unknown*
     (prin1 predication stream))))

1;;; This is here for compilation dependency reasons
0(defflavor tracing-event
	(name
	 pretty-name
	 short-name
	 active-name
	 (enabled-p nil)
	 (encapsulations nil)
	 (enablers ())
	 documentation
	 enabling-function 
	 disabling-function)
	()
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)


1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The defs for joshua debugger which maintains the global state for joshua
;;; tracing

0(defflavor joshua-debugger
	((event-to-tracer-table
	   (make-hash-table :test #'eq
			    :locking *default-joshua-debugger-table-locking*))
	 (event-to-collector-table
	   (make-hash-table :test #'eq
			    :locking *default-joshua-debugger-table-locking*))
	 (event-to-interactor-table
	   (make-hash-table :test #'eq
			    :locking *default-joshua-debugger-table-locking*))
	 (event-to-symbol-table
	   (make-hash-table :test #'eq
			    :locking *default-joshua-debugger-table-locking*))
	 (tracers ())
	 (active-tracers ())
	 (collectors ())
	 (active-collectors ())
	 (tracing-events ())
	 (encapsulations ())
	 (global-encapsulations nil)1            ;; these must be active whenever any
0					1	;; tracing is going on.
0	 (tracing-filter nil)
	 )
	()
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

1;;; a hack for warning people when I'm going to patch something that
;;; will reset their tracing options
0(defmethod (warn-and-reset joshua-debugger)(&optional (warn-p t))
  (when active-tracers
    (when warn-p
      (beep)
      (delineating-output (*standard-output*)
	(with-character-style ('(nil :bold nil))
	  (format t "Warning: Disabling and resetting all Joshua tracing."))))
    (set-joshua-trace-conditions self :tracer :all :enable-p nil)))


1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Adding and removing filters for controlling interactive tracing/stepping

;;; The filter should be a two arg function that takes the event and the current depth 
;;; as its args. It returns t when tracing should happen, nil if we want to skip the
;;; event. This is used by the Leap command.
0(defmethod (add-tracing-filter joshua-debugger)(continuation)
  (setf tracing-filter continuation))

1;;; Tracing filters are reset when we reach a rule depth of 0
0(defmethod (reset-tracing-state joshua-debugger)()
  (setf tracing-filter nil))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The code for keeping track of individual tracing events 

;;; create a symbol for each event. This is used by the event macros to determine
;;; whether a tracing event is active.
0(defun-in-flavor (create-symbol-for-event joshua-debugger)(event-keyword)
  (intern (string-append "." (symbol-name event-keyword) ".") 'ji))

(defgeneric handle-event (joshua-debugger event &rest args))

(defmethod (handle-event joshua-debugger)(event &rest args)
  (when (or (not tracing-filter)
	    (funcall tracing-filter event *rule-depth*))
    (loop for tracer in (gethash event event-to-tracer-table)
	  do
      (apply 'trace-it tracer event args))
;  (loop for collector in (gethash event event-to-collector-table) do
;    (apply #'collect collector event args))
    (apply #'interact (gethash event event-to-interactor-table) event args)))

(defmethod (add-tracing-event joshua-debugger)(event)
  (let ((old-one (find event tracing-events :test #'(lambda (obj1 obj2)
						      (eq (tracing-event-name obj1)
							  (tracing-event-name obj2)
							  )))))
    (when old-one (delete-tracing-event self old-one)))
  (let ((event-symbol (create-symbol-for-event (tracing-event-name event))))
    (proclaim `(special ,event-symbol))
    (set event-symbol nil)
    (setf (gethash (tracing-event-name event) event-to-symbol-table) event-symbol))
  (let ((event-name (tracing-event-name event)))
    (setf (gethash event-name event-to-tracer-table) nil)
    (setf (gethash event-name event-to-collector-table) nil)
    (setf (gethash event-name event-to-interactor-table) nil))
  (push event tracing-events)
  event)


(defmethod (delete-tracing-event joshua-debugger)(event)
  (remhash event event-to-symbol-table)
  (remhash event event-to-collector-table)
  (remhash event event-to-tracer-table)
  (remhash event event-to-interactor-table)
  (setf tracing-events (delete event tracing-events)))

(defmethod (symbol-for-event joshua-debugger)(event)
  (gethash event event-to-symbol-table))

1;;; keep track of who enabled the tracing event so we can have one event used 
;;; by multiple tracers/collectors
0(defmethod (enable-event joshua-debugger)(event-name enabler-name)
  (let ((event (find event-name tracing-events
		     :test
		     #'(lambda (name obj)
			 (eq name (tracing-event-name obj))))))
    (unless event (error "Unable to find the event ~s in the list of known tracing-events"
			 event-name))
    (set (gethash event-name event-to-symbol-table) t)
    (enable-tracing-event event enabler-name)))

(defmethod (disable-event joshua-debugger)(event-name disabler-name)
  (let ((event (find event-name tracing-events
		     :test
		     #'(lambda (name obj)
			 (eq name (tracing-event-name obj))))))
    (unless event (error "Unable to find the event ~s in the list of known tracing-events"
			 event-name))
    (set (gethash event-name event-to-symbol-table) nil)
    (disable-tracing-event event disabler-name)))

(defmethod (find-event-by-name joshua-debugger)(event-name)
  (let ((event (find event-name tracing-events :test #'(lambda (name obj)
						  (eq name (tracing-event-name obj))))))
    (unless event
      (error "There is no known tracing event named ~s" event-name))
    event))

(defmethod (event-stepped-p joshua-debugger)(event-object)
  (loop for tracer in tracers do
    (when (and (member (tracing-event-name event-object)
		       (tracer-current-interaction-events tracer))
	       (tracer-enabled-p self tracer))
      (return t))))

(defmethod (event-traced-p joshua-debugger)(event-object)
  (loop for tracer in tracers do
    (when (and (member (tracing-event-name event-object)
		       (tracer-current-output-events tracer))
	       (tracer-enabled-p self tracer))
      (return t))))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Code for handling the definition and manipulation of tracers which are 
;;; logical collections of tracing events that use the same functions for 
;;; doing output. Things like the forward-rule-tracer, backward-rule-tracer,
;;; etc.

0(defmethod (find-tracer-by-flavor-name joshua-debugger)(name &optional error-p)
  (let (tracer)
    (unless (and (dw::flavor-name-p name) 
		 (setf tracer (find name tracers :test #'(lambda (name obj1)
							   (typep obj1 name)))))
      (when error-p
	(error "Unknown Type of Tracing ~s. It must must be one of ~s."
	       name
	       (loop for a-tracer in tracers 
		     collect (tracer-unique-id a-tracer)))))
    tracer))

(defmethod (add-tracer joshua-debugger)(tracer)
  (let ((old-one (find-tracer-by-flavor-name self (type-of tracer))))
    (when old-one
      (delete-tracer self old-one)))
  (loop for event in (tracer-events tracer) do
    (push tracer (gethash event event-to-tracer-table))
    (setf (gethash event event-to-interactor-table) tracer))
  (push tracer tracers))


(defmethod (delete-tracer joshua-debugger)(tracer)
  (when (member tracer active-tracers)
    (disable-tracer self tracer)
    (setf active-tracers (delete tracer active-tracers)))
  (setf tracers (delete tracer tracers))
  (maphash #'(lambda (key value)
	       (when (member tracer value)
		 (setf (gethash key event-to-tracer-table)
		       (delete tracer value))))
	   event-to-tracer-table)
  (maphash #'(lambda (key value)
	       (when (eq tracer value)
		 (setf (gethash key event-to-interactor-table) nil)))
	   event-to-tracer-table))

(defmethod (enable-tracer joshua-debugger)
	   (tracer
	     &key
	     (new-output-events (tracer-current-output-events tracer))
	     (new-interaction-events (tracer-current-interaction-events tracer)))
  (pushnew tracer active-tracers)
  (enable tracer new-output-events new-interaction-events)
  (ensure-global-encapsulation-state self))

(defmethod (disable-tracer joshua-debugger)(tracer)
  (disable tracer)
  (setf active-tracers  (delete tracer active-tracers))
  (ensure-global-encapsulation-state self))
  
(defmethod (tracer-enabled-p joshua-debugger)(tracer)
  (member tracer active-tracers))


1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; creating and manipiulating the encapsulations for joshua tracing.

;;; After an encapsulation is defined it should be added to the tracing-events
;;; that it includes
0(defmethod (add-encapsulation-to-events joshua-debugger)(encaps events-list)
  (loop for event in events-list do
    (add-encapsulation
      (find event tracing-events :test #'(lambda (name each-event)
					   (eq (tracing-event-name each-event)
					       name)))
      encaps)))

1;;; create a new type of encapsulation for joshua-tracing this should 
;;; go into the system source at the next release
0(unless (member 'si:joshua-trace si:encapsulation-standard-order)
  (setf si:encapsulation-standard-order
	(append si:encapsulation-standard-order '(si:joshua-trace))))

(defun unencapsulate-function-for-joshua-tracing (function-desc)
  (let* ((spec1 (si:unencapsulate-function-spec function-desc 'si:joshua-trace))
	 (spec2 (si:unencapsulate-function-spec spec1 '(si:joshua-trace))))
    (and (neq spec1 spec2)
	 ;; make sure it is unencapsulated
	 (fdefine spec1 (fdefinition spec2)))))

1;;; these are just around for debugging the encapsulation and event 
;;; mechanisms
0;
;(defmethod (do-encapsulations joshua-debugger)()
;  (loop for encaps in encapsulations do
;    (when (joshua-encapsulation-enabled-p encaps)
;      (do-encapsulation encaps))))
;
;(defmethod (undo-encapsulations joshua-debugger)()
;  (loop for encaps in encapsulations do
;    (loop for enabler in (joshua-encapsulation-enablers encaps) do 
;      (undo-encapsulation encaps enabler))))
;;
;;;; these are just for debugging 
;(defmethod (clear-encapsulations joshua-debugger)()
;  (setf  encapsulations nil))
;
;(defmethod (enable-all-encapsulations joshua-debugger)()
;  (loop for encaps in encapsulations do
;    (setf (joshua-encapsulation-enabled-p encaps) t))
;  (do-encapsulations self))
;
;(defmethod (enable-all-tracing-events joshua-debugger)()
;  (maphash #'(lambda (ignore value &rest ignore)
;	       (set value t))
;	   event-to-symbol-table)
;  (enable-all-encapsulations self))


1;;; Keep track of the current encapsulations. Global encapsulations are those
;;; that must be done whenever any kind of tracing is enabled. For example, 
;;; the encapsulations that maintain the *rule-depth* variable.
0(defmethod (add-encapsulation joshua-debugger)(encapsulation &optional global-p)
  (let ((old-one (find encapsulation encapsulations
		       :test #'(lambda (obj1 obj2)
				 (eq (joshua-encapsulation-name obj1)
				     (joshua-encapsulation-name obj2))))))
    (when old-one
      (setf encapsulations (delete old-one encapsulations))
      (setf global-encapsulations (delete old-one global-encapsulations))))
  (push encapsulation encapsulations)
  (when global-p
    (push encapsulation global-encapsulations))
  encapsulation)

(defmethod (ensure-global-encapsulation-state joshua-debugger)()
  (if active-tracers
      (loop for encaps in global-encapsulations do
	(do-encapsulation encaps :global))
      (loop for encaps in global-encapsulations do
	(undo-encapsulation encaps :global))))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; finally some methods used by joshua-debugger to interact with the user

;;; this is called by the tracer after it determines that the event is one 
;;; that the user wants to step at. 

0(defmethod (interact joshua-debugger)()
  (labels ((read-acc ()
	     (cp:read-accelerated-command
	       :stream *terminal-io*
	       :help-stream *terminal-io*
	       :blank-line-mode :ignore ; cp::*blank-line-mode*
	       :command-table *joshua-tracing-command-table*
	       :form-p nil
	       :command-prompt nil
	       :prompt *joshua-tracing-prompt*
	       :full-command-full-rubout t
	       :catch-accelerator-errors :abort
	       :unknown-accelerator-is-command t
	       :unknown-accelerator-reader-prompt ""
	       :handle-clear-input t
	       :abort-chars '(#\m-Abort)
	       :suspend-chars '(#\Suspend #\m-Suspend)
	       )))
    (let ((com-values nil)
	  (cp:*command-table* *joshua-tracing-command-table*))
      1;; any command that returns :done will exit the loop
0      (loop until (eq :done (car com-values))
	    do
	1;; reinitialize com-values so we don't get stuck obeying old ones
0	(setf cp:*last-command-values* nil)
	(let ((aborted-p
		1;; signal abort only when 'aborted is thrown
0		(catch 'aborted
		  (error-restart ((sys:abort error) "Joshua Trace Command Loop")
		    (multiple-value-bind 
		      (command args flag)
			(read-acc)
1;0		      (format t "~%~s ~%~s ~%~s" command args flag)
		      (case flag
			((:command :accelerator)
			 (apply command args))
			((nil) (unless (or (eq args :full-rubout)
					   (null command))
				 (apply command args))))
		      (setf com-values  cp:*last-command-values*)))
		  nil)))
	  (when aborted-p (signal 'sys:abort)))))))

1;;; I suppose this should be created statically to avoid consing, but it
;;; makes it easier to patch in new tracers if it isn't
0(defmethod (create-tracer-alist joshua-debugger) (&key (tracer-list tracers)
						       (extra-items nil)
						       (First-word-of-doc-strings "Enable"))
  (loop for tracer in tracer-list
	collect `(,(tracer-name tracer) :value ,tracer
		  :documentation ,(format nil "~a the tracing of ~a"
					  First-word-of-doc-strings
					  (tracer-name tracer)))
	  into alist
	finally (return (append (nreverse alist) extra-items))))

1;;; Set the tracing options, either explicitly or via menu. With enable-p nil
;;; it will disable the tracing options. Here's a good example of a function 
;;; that should really be three or four functions. 
0(defmethod (set-joshua-trace-conditions joshua-debugger)
	   (&key tracer menu enable-p (trace-events nil trace-supplied-p)
		 (step-events nil step-supplied-p)
		 (stream *query-io*) (own-window-p nil))
  (let ((disable-list (when (not enable-p)
			(if (eq tracer :all) tracers `(,tracer))))
	(enable-list (when enable-p
		       (if (eq tracer :all) tracers `(,tracer)))))
    (if menu
	1;; Conditions is the list of all tracers that we want to deal with
0	(let* ((conditions (if (eq tracer :all) tracers `(,tracer)))
	       1;; tracing-list is the list of tracers that should be enabled when the 
0	       1;;  menu comes up. Here's a little set logic - I don't want to actually 
0	       1;; enable them until the menu returns normally.
0	       (tracing-list (set-difference (intersection (union active-tracers enable-list)
							   conditions)
					     disable-list))
	       1;; just the alist for accepting conditions
0	       (tracer-alist (create-tracer-alist self :tracer-list conditions
						  :first-word-of-doc-strings "Toggle"))
1	       ;; These guys will hold the alists of tracers/properties that get munged
	       ;; during the accepting-values below
0	       (output-events-list  (loop for tracer in conditions
					  ;; these lists will be destructively altered
					  collect
					    (cons tracer
						  (tracer-current-output-events tracer ))
					    into alist
					  finally (return alist)))
	       (interaction-events-list (loop for tracer in conditions
					      ;; these lists will be destructively altered
					      collect
						(cons tracer
						      (tracer-current-interaction-events
							tracer ))
						into alist
					      finally (return alist)))
	       (tracer-action-list (loop for tracer in conditions
					 ;; these lists will be destructively altered
					 collect
					   (list tracer)
					   into alist
					 finally (return alist)))
	       1;; Generate some unique-ids for the step and trace event prompts
0	       (query-identifier-list
		 (loop for sub-tracers on tracers
		       do (ignore sub-tracers)
		       collect (gensym) into qi-list 
		       collect (gensym) into qi-list
		       finally (return qi-list))))
	  (flet ((print-heading (heading stream)
		   (terpri stream)
		   (with-character-style (*deemphasis-character-style*
					   stream :bind-line-height t )
		     (princ heading stream))
		   (terpri stream))
		 1;; Get the unique ID
0		 (get-query-identifier (tracer &key step)
		   (nth (if step (1+ (* 2 (position tracer tracers)))
			    (* 2 (position tracer tracers)))
			query-identifier-list)))
	    1;; Let success indicate the normal completion of the accepting values (No abort)
0	    (let ((success-p
		    (catch 'aborted
		      (tv:with-auto-line-height (stream nil)
			(with-character-style ('(nil nil nil) stream :bind-line-height t)
			  (terpri stream)
			  (condition-bind ((sys:abort #'(lambda (ignore)
							  (throw 'aborted nil))))
			    (dw:accepting-values (stream :own-window own-window-p :label
							 "Joshua Tracing Options"
							 :queries-are-independent nil)
			      (setf tracing-list
				    (accept `(dw::alist-subset
						 :alist
						 ,tracer-alist)
					      :prompt nil
					      :prompt-mode :raw
					      :default tracing-list
					      :stream stream))
			      1;; this reverse of tracing list will make the most 
0			      1;; recently enabled appear last - minimize redisplay
0			      (loop for tracer in (reverse tracing-list)
				    do
				(dw:with-redisplayable-output
				    (:stream stream
				     :cache-value t
				     :unique-id tracer)
				  (print-heading (string-append (tracer-name tracer)
								" Options")
						 stream))
				(setf (cdr (assoc tracer tracer-action-list))
				      (accept-tracing-options tracer stream))
				(setf (cdr (assoc tracer output-events-list))
				      (accept-events tracer stream
						     :prompt "Traced Events "
						     :query-identifier
						     (get-query-identifier tracer)
						     :default
						     (cdr (assoc tracer output-events-list))))
				(setf (cdr (assoc tracer interaction-events-list))
				      (accept-events tracer stream
						     :prompt "Stepped Events"
						     :query-identifier
						     (get-query-identifier tracer :step t)
						     :default
						     (cdr (assoc tracer
								 interaction-events-list))
						     )))))))
1		      ;;explicitly return t to signal successfull completion
0		      t)))
	      1;; The user's hit ” so we can do our stuff
0	      (if success-p
		  (loop for tracer in conditions
			do
		    (if (not (member tracer tracing-list))
			(disable-tracer self tracer)
			(enable-tracer self tracer
				       :new-output-events
				       (cdr (assoc tracer output-events-list))
				       :new-interaction-events
				       (cdr (assoc tracer interaction-events-list)))
			(set-tracing-options tracer (cdr (assoc tracer  tracer-action-list)))
			))
		  (format stream "~&~VNo changes made to the tracing options~"
			  *deemphasis-character-style*)))))
	1;;; If the user didn't want the menu just do what they ask
0	(cond (enable-p
	       (unless (eq tracer :all)
		 (setf step-events
		       (if step-supplied-p
			   (loop for event in step-events
				 collect (tracing-event-name event)
				   into new-events
				 finally (return new-events))
			   (tracer-current-interaction-events tracer)))
		 (setf trace-events
		       (if trace-supplied-p
			   (loop for event in trace-events
				 collect (tracing-event-name event)
				   into new-events
				 finally (return new-events))
			   (tracer-current-output-events tracer))))
	       (if (eq tracer :all)
		   (loop for each-tracer in tracers do
		     (enable-tracer self each-tracer))
		   (enable-tracer self tracer
				  :new-interaction-events step-events
				  :new-output-events trace-events)))
	      (t (if (eq tracer :all)
		     (loop for each-tracer in tracers do
		       (disable-tracer self each-tracer))
		     (disable-tracer self tracer)))))))

1;;; Print information about the global tracing state0	
(defmethod (show-joshua-tracing joshua-debugger)(tracer-or-all)
  (delineating-output (*standard-output* :fraction-of-screen .9)
    (if (eq tracer-or-all :all)
	(loop for (tracer . rest) on tracers
	      while rest
	      do
	  (delineating-output (*standard-output* :fraction-of-screen .6 
						 :location :after :thickness 1)
	    (show-tracing-state tracer))
	      finally (show-tracing-state tracer))
	(show-tracing-state tracer-or-all))))


(defmethod (get-events-alist joshua-debugger)(&optional (tracer-or-all :all))
  (if (eq tracer-or-all :all)
      (loop for event in tracing-events
	    collect `(,(tracing-event-pretty-name event)
		      :value ,event
		      :documentation
		      ,(tracing-event-documentation event))
	      into alist
	    finally (return alist))
      (loop for event in (tracer-events tracer-or-all)
	    for event-object = (find-event-by-name self event)
	    collect `(,(tracing-event-pretty-name event-object)
		       :value ,event-object :documentation
		       ,(tracing-event-documentation event-object))
	      into alist
	    finally (return alist))))

(defmethod (get-current-events joshua-debugger)(step-or-trace &optional (tracer-or-all :all))
  (flet ((get-events-for-tracer (tracer)
	   (loop for event in
		     (case step-or-trace
		       (:step (tracer-current-interaction-events tracer))
		       (:trace (tracer-current-output-events tracer)))
		 collect (find-event-by-name self event) into event-list
		 finally (return event-list))))
    (if (eq tracer-or-all :all)
	(loop for tracer in tracers
	      append (get-events-for-tracer tracer)
		into all-event-list
	      finally (return all-event-list))
	(get-events-for-tracer tracer-or-all))))

(defmethod (collect-options-for-object joshua-debugger)(object)
  (if  (typep object 'tracing-event)
       (loop for tracer in tracers
	     nconc (options-for-event tracer object)
	       into option-action-alist
	     finally (return option-action-alist))
       (loop for tracer in tracers
	     nconc (options-for-object tracer object)
	       into option-action-alist
	     finally (return option-action-alist))))


(defun abbreviate-string (string length)
  (if (> (length string) length)
      (string-append (substring string 0 (1- length)) "...")
      string))

(defmethod (get-all-trace-options joshua-debugger)(object)
  (let* ((options (collect-options-for-object self object))
	 (choice
	   (dw:menu-choose
	     options
	     :center-p t
	     :prompt
	     (if (= (length options) 1) "Confirm:"
		 (abbreviate-string
		   (format nil "Joshua Tracing Options for: ~a"
			   (if (typep object 'tracing-event)
			       (tracing-event-pretty-name object)
			       object))
		   *trace-options-menu-width*)))))
    (when choice (apply (car choice) `(,(cadr choice) ,object))
	  (delineating-output (*standard-output*)
	    (show-tracing-state (cadr choice)))
	  )))

(defmacro without-joshua-tracing (&body body)
  (let ((saved-active-tracers (si:gensymbol "TRACERS")))
    `(let ((,saved-active-tracers (joshua-debugger-active-tracers *joshua-debugger*)))
       (unwind-protect
	   (progn (loop for tracer in ,saved-active-tracers do
		    (disable-tracer *joshua-debugger* tracer))
		  ,@body)
	 (loop for tracer in ,saved-active-tracers do
	   (enable-tracer *joshua-debugger* tracer))))))


(defmacro with-joshua-tracing (tracing-types &body body)
  (let ((tracers-coming-in (si:gensymbol "TRACERS-IN"))
	(tracers-going-out (si:gensymbol "TRACERS-OUT")))
    `(let* ((,tracers-coming-in nil)
	    (,tracers-going-out (joshua-debugger-active-tracers *joshua-debugger*)))
       (loop for ttype in ,tracing-types
	     for tracer = (find-tracer-by-flavor-name *joshua-debugger* ttype t)
	     do (if (member tracer ,tracers-going-out)
		    (setq ,tracers-going-out (delete tracer ,tracers-going-out))
		    (push tracer ,tracers-coming-in)))
       (unwind-protect
	   (progn (loop for tracer in ,tracers-going-out do
		    (disable-tracer *joshua-debugger* tracer))
		  (loop for tracer in ,tracers-coming-in do
		    (enable-tracer *joshua-debugger* tracer))
		  ,@body)
	 (loop for tracer in ,tracers-coming-in do
	   (disable-tracer *joshua-debugger* tracer))
	 (loop for tracer in ,tracers-going-out do
	   (enable-tracer *joshua-debugger* tracer))))))


1;;; Return all tracers to their default settings but don't turn them off
;;; altogether
0(defmethod (reset-tracers joshua-debugger)(tracer-or-all
					    &optional events-too-p (verbose-p t))
  (if (eq tracer-or-all :all)
      (loop for tracer in tracers do
	(reset-defaults tracer events-too-p))
      (reset-defaults tracer-or-all events-too-p))
  (when verbose-p (show-joshua-tracing self tracer-or-all)))

1;;; This will define a method and a method on joshua-debugger to get to it
0(defmacro define-joshua-tracing-method ((name flavor) argument-list &body body)
  `(progn (defmethod (,name ,flavor) ,argument-list
	    (declare (sys:function-parent ,name define-joshua-tracing-method))
	    ,@body)
	  (defmethod (,name joshua-debugger) (&rest args)
	    (declare (sys:function-parent ,name  define-joshua-tracing-method)
		     (arglist ,argument-list))
	    (apply ',name (find-tracer-by-flavor-name self ',flavor) args))))


1;;; And make an instance of this as it must be around by the time we 
;;; load the defs of encapsulations, tracing-events, tracers, etc.

0(defvar *joshua-debugger* (make-instance 'joshua-debugger))


(warn-and-reset *joshua-debugger*)

1;;; Just a kludge to allow people to easily enable and disable tracing
;;; in their code. This should really be a better defined interface.
0(defun enable-joshua-tracing (tracing-type &optional (verbose t))
  (let ((tracer (find-tracer-by-flavor-name *joshua-debugger* tracing-type t)))
    (enable-tracer *joshua-debugger* tracer)
    (when verbose (show-tracing-state tracer))))

(defun disable-joshua-tracing (tracing-type &optional (verbose t))
  (let ((tracer (find-tracer-by-flavor-name *joshua-debugger* tracing-type t)))
    (disable-tracer *joshua-debugger* tracer)
    (when verbose (show-tracing-state tracer))))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; forms for defining tracing events
;;; the flavor for tracing events 

0(defmethod (add-encapsulation tracing-event)(encaps)
  (let ((old-one (find encaps encapsulations :test #'(lambda (x y)
						       (eq (joshua-encapsulation-name x)
							   (joshua-encapsulation-name y))))))
    (when old-one
      (setf encapsulations (delete old-one encapsulations))))
  (push encaps encapsulations))

(defmethod (enable-tracing-event tracing-event)(enabler)
  (pushnew enabler enablers)
  (unless enabled-p
    (loop for encaps in encapsulations do
      (do-encapsulation encaps name))
    (when enabling-function (funcall enabling-function ))
    (setf enabled-p t)))

(defmethod (disable-tracing-event tracing-event)(disabler)
  (when (member disabler enablers)
    (setf enablers (delete disabler enablers)))
  (when (and enabled-p (null enablers))
    (loop for encaps in encapsulations do
      (undo-encapsulation encaps name))
    (when disabling-function (funcall enabling-function ))
    (setf enabled-p nil)))

(defmethod (enable-alist-item tracing-event)()
  `(,name :value self :documentation ,(format nil "Enable tracing of ~a" name)))

1;;; create a macro that will filter on whether we are actually interested in the event
0(defmacro create-macro-for-event (name arglist event-name)
  `(defmacro ,name arguments
     (declare (arglist ,@arglist)
	      (sys:function-parent ,name define-tracing-event))
     (let ((symbol (symbol-for-event *joshua-debugger* ,event-name)))
       `(when ,symbol
	  (handle-event
	    *joshua-debugger* ,',event-name ,@arguments)))))


1;;; a macro to define interesting tracing events 
0(defmacro define-tracing-event (name pretty-name 
				&key (short-name pretty-name)
				(active-name pretty-name)
				macro-name
				arglist
				documentation
				enabling-function disabling-function)
  (let ((instance (gensym)))
    `(let ((,instance (make-instance 'tracing-event
				     :name ',name
				     :pretty-name ,pretty-name
				     :short-name ,short-name
				     :active-name ,active-name
				     :documentation ,documentation
				     :enabling-function ,enabling-function
				     :disabling-function ,disabling-function)))
       (add-tracing-event *joshua-debugger* ,instance)
       (create-macro-for-event  ,macro-name ,arglist ',name)
      )))



1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Forms for defining joshua-encapsulations
0				
1;;; the flavor for keeping track of encapsulations
0(defflavor joshua-encapsulation
	(name
	 original-fspec 
	 (cached-encapsulation nil)
	 (cached-fdefinition nil)
	 (enablers ())
	 (before-body nil)
	 (after-body nil)
	 (call-original-p nil)
	 (enabled-p nil))
	()
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

1;;; This will force the precompilation of encapsulations at load time. It also 
;;; will make sure that the encapsulation can compile when it is compiled to
;;; core, instead of having to enable it to make sure it compiles.
0(defmethod (make-instance joshua-encapsulation :after)(&rest ignore)
  (do-encapsulation self :self)
  (undo-encapsulation self :self))

1;;; We need to look at what event is enabling us. This makes a sloppy
;;; attempt at returning the value from the encapsulated function. The 
;;; general approach to encapsulation probably could use to be rethought.
0(defmethod (do-encapsulation joshua-encapsulation)(enabler)
  (unless (member enabler enablers)
    (pushnew enabler enablers)
    (unless enabled-p 
      (unencapsulate-function-for-joshua-tracing original-fspec)
      1;; See if we can reuse an old encapsulation
0      (if (and (eq (fdefinition original-fspec)
		   cached-fdefinition)
	       (not (si:function-encapsulated-p original-fspec)))
	  1;; if so, we can just fdefine the original fspec to the old encapsulation
0	  (fdefine original-fspec cached-encapsulation nil t)
	  1;; Otherwise we have to compile the encapsulation
0	  (let ((si:inhibit-fdefine-warnings 't))
	    1;;save the definition that we encapsulate so we can check to see if it changed
0	    (setf cached-fdefinition
		  (fdefinition (si:unencapsulate-function-spec
				 original-fspec 'si:joshua-trace)))
1;0	    (format t "Recompiling encapsulation for ~s" original-fspec)
	    (si:encapsulate-and-compile
	      (si:unencapsulate-function-spec original-fspec 'si:joshua-trace)
	      original-fspec
	      'si:joshua-trace
	      `(progn ,before-body
		      (let ((.answer
			      ,(when call-original-p
				 `(multiple-value-list
				    (apply ,si:encapsulated-function si:arglist)))))
			,after-body
			(apply #'values .answer)))))
	  1;; Save the encapsulation so we can reuse it
0	  (setf cached-encapsulation
		(fdefinition 
		  (si:unencapsulate-function-spec original-fspec 'si:joshua-trace))))
      (setf enabled-p t))))

1;;; keep track of which events are enabling this encaps and only 
;;; unencapsulate it when no one's interested
0(defmethod (undo-encapsulation joshua-encapsulation)(disabler)
  (setf enablers (delete disabler enablers))
  (unless enablers 
    (unencapsulate-function-for-joshua-tracing original-fspec)
    (setf enabled-p nil)) )
  

1;;; the macro for defining encapsulations
0(defmacro define-joshua-encapsulation ((name original-fspec call-original-p event-list
					     &optional global-p)
				       &key before-body after-body)
  (declare (zwei:indentation 1 1 1 1))
   (let ((instance (gensym)))
    `(let ((,instance (make-instance 'joshua-encapsulation
				     :name ',name
				     :original-fspec ',original-fspec
				     :call-original-p ,call-original-p
				     :before-body ,before-body
				     :after-body ,after-body)))
       (add-encapsulation *joshua-debugger* ,instance ,global-p)
       (add-encapsulation-to-events *joshua-debugger* ,instance ,event-list)
       )))

1;;; The macro used to tell the debugger about a tracing entity and to 
;;; create the tracing macro.
0(defmacro define-tracer (flavor-name name
			 &key pretty-name events default-trace-events
			 default-step-events 
			 )
  `(add-tracer
     *joshua-debugger*
     (make-instance ',flavor-name
		    :pretty-name ,pretty-name
		    :events ,events
		    :current-output-events ,default-trace-events
		    :current-interaction-events ,default-step-events
		    :name ,name
;		    :events-alist ,events-alist
		    )))

1;;; A hack to unify the predications with explicit truth-values
;;; Note that this must be called from inside a unification-block
0(defun unify-predications-with-explicit-t-vs (predication-1 t-v-1
					      predication-2 t-v-2)
  (cond ((eq (predication-predicate  predication-1) 'not)
	 (unify-predications-with-explicit-t-vs
	   (not-predication predication-1)
	   (negate-truth-value t-v-1)
	   predication-2 t-v-2))
	((eq (predication-predicate predication-2) 'not)
	 (unify-predications-with-explicit-t-vs
	   predication-1
	   t-v-1
	   (not-predication predication-2)
	   (negate-truth-value t-v-2)))
	(t (and (= t-v-1 t-v-2)
		(unify predication-1 predication-2)))))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The base flavor for tracers

0(defflavor tracer
	 ((events nil)
	  (events-alist nil)
	  unique-id
	  name
	  pretty-name
	  (current-output-events nil)
	  (current-interaction-events nil)
	  (default-output-events nil)
	  (default-interaction-events nil)
	 )
	()
  :abstract-flavor 
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

(defmethod (make-instance tracer :after)(&rest ignore)
  (unless events-alist
    (set-events-alist self))
  1;; Store the original event settings so we can reset them
0  (setf default-output-events current-output-events
	default-interaction-events current-interaction-events)
  1;; Ok, so its a hack...
0  (setf unique-id (type-of self)))

(defmethod (set-events-alist tracer)()
  (setf events-alist
	  (loop for event-name in events
		for event = (find-event-by-name *joshua-debugger* event-name)
		collect `(,(tracing-event-short-name event)
			  :value ,event-name
			  :documentation
			  ,(tracing-event-documentation event)))))

(defmethod (accept-events tracer)(&optional (stream *query-io*)
					    &key (prompt "")  default query-identifier )
  (accept `(dw::alist-subset :alist ,events-alist)
	  :stream stream
	  :prompt prompt
;	  #'(lambda (stream ignore)
;			(with-character-style ('(nil :italic nil) stream)
;			  (format stream "~a: ~%" prompt)))
1;0	  :prompt-mode :raw
	  :default default
	  :query-identifier query-identifier
	  ))



1;;; the method for enabling a tracer. 
0(defmethod (enable tracer)(new-output-events new-interaction-events)
  (setf current-output-events new-output-events)
  (setf current-interaction-events new-interaction-events)
  (loop for event in events do
    (if (or (member event new-output-events)
	    (member event new-interaction-events))
	(enable-event *joshua-debugger* event unique-id)
	(disable-event *joshua-debugger* event unique-id))))

(defun-in-flavor (find-event-in-alist tracer)(event alist)
  (loop for item in alist
	when (member event item)
	  do
	    (return (car item))))

(defmethod (show-event-state tracer)(&optional (stream *standard-output*))
  (flet ((present-event (event stream)
			(dw:with-output-as-presentation
			    (:stream stream
			     :object
			     (find-event-by-name *joshua-debugger* event)
			     :type 'tracing-event
			     :allow-sensitive-inferiors nil)
			  (princ (find-event-in-alist event events-alist)
				 stream))))
    (when  current-output-events
      (format stream "~&Traced event~P: " (length current-output-events))
      (format-textual-list current-output-events
			   #'present-event
			   :filled t
			   :conjunction "and"
			   :if-two " and "))
    (when current-interaction-events
      (format stream "~&Stepped event~P: " (length current-interaction-events))
      (format-textual-list current-interaction-events
			   #'present-event
			   :filled t
			   :conjunction "and"
			   :if-two " and "))))

(defmethod (options-for-event tracer)(event)
  (let ((event-name (tracing-event-name event))
	(alist nil))
    (when (member event-name events)
      (if (member event-name current-output-events)
	  (push `("Untrace event"
		  :value (untrace-event ,self)
		  :documentation ,(format nil "Disable the tracing of the ~a event ~a"
					  name (tracing-event-pretty-name event)))
		alist)
	  (push `("Trace event"
		  :value (add-trace-event ,self)
		  :documentation ,(format nil "Enable the tracing of the ~a event ~a"
					  name (tracing-event-pretty-name event)))
		alist))
      (if (member event-name current-interaction-events)
	  (push `("Unstep event"
		  :value (unstep-event ,self)
		  :documentation ,(format nil "Disable stepping of the ~a event ~a"
					  name (tracing-event-pretty-name event)))
		alist)
	  (push `("Step event"
		  :value (add-step-event ,self)
		  :documentation ,(format nil "Enable the stepping of the ~a event ~a"
					  name (tracing-event-pretty-name event)))
		alist)))
    alist))



(defmethod (add-trace-event tracer)(event)
  (let ((event-name (tracing-event-name event))) 
    (pushnew event-name current-output-events)
    (enable-event *joshua-debugger* event-name unique-id)
    (ensure-event-state self t)))

(defmethod (untrace-event tracer)(event)
  (let ((event-name (tracing-event-name event))) 
    (setf current-output-events (delete event-name current-output-events))
    (unless (member event-name current-interaction-events)
      (disable-event *joshua-debugger* event-name unique-id))
    (ensure-event-state self )))

(defmethod (add-step-event tracer)(event)
  (let ((event-name (tracing-event-name event)))
    (pushnew event-name current-interaction-events)
    (enable-event *joshua-debugger* event-name unique-id)
    (ensure-event-state self t)))

(defmethod (unstep-event tracer) (event)
  (let ((event-name (tracing-event-name event)))
    (setf current-interaction-events
	  (delete event-name current-interaction-events))
    (unless (member event-name current-output-events)
      (disable-event *joshua-debugger* event-name unique-id))
    (ensure-event-state self)))

(defmethod (ensure-event-state tracer)(&optional (must-be-enabled-p))
  (unless (or current-output-events current-interaction-events)
    (reset-events self)
    (unless must-be-enabled-p
      (disable-tracer *joshua-debugger* self)))
  (when must-be-enabled-p
    (enable-tracer *joshua-debugger* self)))

(defmethod (reset-events tracer)()
  (setf current-output-events default-output-events
	current-interaction-events default-interaction-events))

(defmethod (disable tracer)()
  (loop for event in events do
    (disable-event *joshua-debugger* event unique-id)))

1;;; A method which modifies the options from a list of instance vars and 
;;; values produced by accepting values.

0(defmethod (set-tracing-options tracer)(option-list)
  (loop for (name . value) in option-list do
      (setf (symbol-value-in-instance self name ) value)))


1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Defs for forward rule tracing

0(defflavor forward-rule-tracer
	((trace-everything-p t)
	 (traced-forward-rules nil)
	 (traced-forward-rule-table (make-hash-table
				      :number-of-values 0
				      :locking
				      *default-joshua-debugger-table-locking*))
	 (traced-forward-rule-triggers nil)		
	 (currently-running-forward-rules ())
	 (forward-rule-firings (make-hash-table :test #'equal
						:locking
						*default-joshua-debugger-table-locking*))
	 (forward-rule-invocation-count 0)
	 )
	(tracer)
  (:conc-name frt)
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

(defmacro-in-flavor (traced-rule-p forward-rule-tracer)(rule-name)
  `(gethash ,rule-name traced-forward-rule-table))

(defmacro-in-flavor (store-traced-forward-rule forward-rule-tracer)(rule-name)
  `(setf (gethash ,rule-name traced-forward-rule-table) ,rule-name))

(defmacro-in-flavor (unstore-traced-forward-rule forward-rule-tracer)(rule-name)
  `(remhash ,rule-name traced-forward-rule-table))

(defun-in-flavor  (filter-forward-rule  forward-rule-tracer ) (rule predications)
  (or trace-everything-p
      (traced-rule-p rule)
      (loop for pred in predications
	    when  (some #'(lambda (p) (with-unification
					(unify-predications-with-explicit-t-vs
					  p *true* pred (predication-truth-value pred))))
			traced-forward-rule-triggers)
	      do (return t))))

1;;; These are the events that Forward rules can deal with
0(defvar *forward-rule-trace-events* '(:fire-forward-rule :exit-forward-rule
				      :enqueue-forward-rule :dequeue-forward-rule))

(defsubst present-event (event-name &optional (stream *standard-output*)(style :active-name))
  (present (find-event-by-name *joshua-debugger* event-name)
	   `((tracing-event ) :name ,style)
	   :stream stream))

(defun present-triggers-as-list (string triggers &optional (stream *standard-output*))
  (dw:with-output-as-presentation (:stream stream
				   :type 'trigger-list
				   :object
				   (sys:copy-if-necessary triggers)
				   :allow-sensitive-inferiors nil)
    (princ string stream)))

(defmethod (trace-it forward-rule-tracer)
	   (event rule-name triggers env importance)
  (ignore env)
  (when (filter-forward-rule rule-name triggers)
    (with-joshua-trace-message-output (*trace-output*)
      (present-event event *trace-output* :active-name)
      (write-char #\space *trace-output*)
      (with-character-style (*emphasis-character-style* *trace-output*)
	(present rule-name 'forward-rule :allow-sensitive-inferiors nil))
      (write-char #\space *trace-output*)
      (when importance
	(format *trace-output* "[Importance: ~d] "
		importance))
      (when triggers
	(with-character-style (*deemphasis-character-style* *trace-output*)
	  (present-triggers-as-list
	    (format nil "(~d trigger~:P)" (length triggers)) triggers *trace-output*))))))


(defmethod (interact forward-rule-tracer)(event rule-name triggers &rest ignore)
  (when (and (member event current-interaction-events)
	     (filter-forward-rule rule-name triggers))
    (interact *joshua-debugger*)))

1;;; This should return an alist of instance-vars and settings that can 
;;; be handled by set-tracing-options

0(defmethod (accept-tracing-options forward-rule-tracer) (&optional (stream *query-io*))
  (let (te tfr tfrt)
    (setf te (accept '(alist-member :alist (("All" :value t
					     :documentation "Trace all forward rules")
					    ("Selectively" :value nil
					     :documentation "Specify which rules to trace")))
		     :prompt "Trace forward rules"
		     :default trace-everything-p
		     :query-identifier :trace-all-forward-rules-p
		     :stream stream))
    (unless te
      (setf tfr (accept '(null-or-type (sequence forward-rule))
			:prompt "Trace forward rules"
			:default traced-forward-rules
			:query-identifier :forward-rules-to-trace
			:stream stream
			))
      (setf tfrt (accept '(null-or-type (sequence predication-presentation))
			 :prompt "Traced forward rule triggers"
			 :query-identifier :forward-rule-triggers
			 :default traced-forward-rule-triggers
			 :stream stream)))
    `((trace-everything-p . ,te)
      (traced-forward-rules . ,tfr)
      (traced-forward-rule-triggers . ,tfrt))))


(defmethod (set-tracing-options forward-rule-tracer :after)(&rest ignore)
  (clrhash traced-forward-rule-table)
  (loop for rule-name in traced-forward-rules do
    (store-traced-forward-rule rule-name))
  (setf traced-forward-rule-triggers
	(delete-duplicates traced-forward-rule-triggers :test #'variant))
  (ensure-tracing-state self))

1;;; This should return a menu alist whose :value is a list of the method
;;; and the instance to call to do the tracing to do the tracing. If you
;;; change the string that this returns you will have to change the  handler as well
0(defmethod (options-for-object forward-rule-tracer)(object)
  (let ((alist nil))
    (when (and (symbolp object)
	       (forward-rule-test-p object))
      (if (traced-rule-p object)
	  (push `( "Untrace Forward Rule"
		  :value (untrace-forward-rule ,self)
		  :documentation
		  ,(format nil "Untrace the forward rule ~a" object))
		alist)
	  (push `("Trace Forward Rule"
		  :value (add-trace-forward-rule ,self)
		  :documentation
		  ,(format nil "Trace the forward rule ~a" object))
		alist)))
    (when (predicationp object)
      (let ((variant (find object traced-forward-rule-triggers :test #'variant)))
	(if variant 
	    (push `("Untrace Forward Rule Trigger"
		    :value (untrace-forward-rule-trigger ,self)
		    :documentation
		    ,(format nil "Untrace forward rules triggered by patterns matching ~a"
			     object))
	    alist)
	    (push `("Trace Forward Rule Trigger"
		    :value (add-trace-forward-rule-trigger ,self)
		    :documentation
		    ,(format
		       nil
		       "Trace forward rules when they are triggered by patterns matching ~a"
		       object))
		  alist))))
    alist))

1;;; Ok lets try doing it like this
;;; a tester for tracing rules 

0(define-joshua-tracing-method (tracable-forward-rule-p forward-rule-tracer)(object)
  (and (symbolp object)
       (forward-rule-test-p object)
       (not (traced-rule-p object))))

1;;; And for untracing forward rules
0(define-joshua-tracing-method (untracable-forward-rule-p forward-rule-tracer)(object)
  (and (symbolp object)
       (forward-rule-test-p object)
       (traced-rule-p object)))

1;;; For predications 
0(define-joshua-tracing-method (tracable-forward-rule-trigger-p forward-rule-tracer)(object)
  (and (predicationp object)
       (not (find object traced-forward-rule-triggers :test #'variant))))

(define-joshua-tracing-method (untracable-forward-rule-trigger-p forward-rule-tracer)(object)
  (and (predicationp object)
       (find object traced-forward-rule-triggers :test #'variant)))

(defmacro with-output-as-command ((stream command-form) &body body)
  `(dw:with-output-as-presentation (:stream ,stream
				    :object ,command-form
				    :type 'cp:command)
     ,@body))

(defmethod (show-tracing-state forward-rule-tracer)(&optional (stream *standard-output*))
  (cond ((tracer-enabled-p *joshua-debugger* self)
	 (with-output-as-command (stream `(com-disable-joshua-tracing ,self))
	   (format stream "~&~VForward Rule~ tracing is ~Von~"
		   *emphasis-character-style* *emphasis-character-style*))
	 (indenting-output (stream 3)
	   (if trace-everything-p 
	       (format stream "~%Tracing ~VAll~ forward rules"
		       *emphasis-character-style*)
	       (when traced-forward-rules
		 (format stream "~%Tracing forward rule~p: " (length traced-forward-rules))
		 (format-textual-list traced-forward-rules
				    #'(lambda (r s) (present r 'forward-rule :stream s))
				    :stream stream
				    :filled t
				    :conjunction "and"
				    :if-two " and "))
	       (when traced-forward-rule-triggers
		 (format stream
			 "~&Tracing all forward rules triggered by a predication matching:")
		 (indenting-output (stream 3)
		   (fresh-line stream)
		   (format-textual-list traced-forward-rule-triggers
					#'(lambda (p s) (present p 'predication-presentation :stream s))
					:stream stream
					:filled t
					:conjunction "or"
					:if-two " or "))))
	   (show-event-state self stream)))
	(t
	 (with-output-as-command (stream `(com-enable-joshua-tracing ,self))
	   (format stream "~&~VForward Rule~ tracing is ~Voff~"
		   *emphasis-character-style* *emphasis-character-style*)))))

1;;; This will turn off rule tracing when there's no way we could be interested 
;;; in anything. 
0(defmethod (ensure-tracing-state forward-rule-tracer)(&optional force-enable-p)
  (unless (or trace-everything-p
	      traced-forward-rules
	      traced-forward-rule-triggers)
    (reset-defaults self)
    (unless force-enable-p 
      (disable-tracer *joshua-debugger* self)))
  (when (and trace-everything-p (or traced-forward-rules traced-forward-rule-triggers))
    (setf trace-everything-p nil))
  (ensure-event-state self force-enable-p)
  (when (and force-enable-p (not (tracer-enabled-p *joshua-debugger* self)))
    (enable-tracer *joshua-debugger* self
		   :new-output-events current-output-events
		   :new-interaction-events current-interaction-events
		   )))

(defmethod (reset-defaults forward-rule-tracer)(&optional events-too-p)
  (clrhash traced-forward-rule-table)
  (setf trace-everything-p t
	traced-forward-rules nil
	traced-forward-rule-triggers nil)
  (when events-too-p (reset-events self)))
  
(defmethod (add-trace-forward-rule forward-rule-tracer)(rule-name)
  (when trace-everything-p (setf trace-everything-p nil))
  (pushnew rule-name traced-forward-rules)
  (store-traced-forward-rule rule-name)
  (ensure-tracing-state self t)
  )

(defmethod (untrace-forward-rule forward-rule-tracer)(rule-name)
  (setf traced-forward-rules (delete rule-name traced-forward-rules))
  (unstore-traced-forward-rule rule-name)
  (ensure-tracing-state self))

(defmethod (add-trace-forward-rule-trigger forward-rule-tracer)(predication)
  (when trace-everything-p (setf trace-everything-p nil))
  (pushnew predication traced-forward-rule-triggers :test #'variant)
  (ensure-tracing-state self t))


(defmethod (untrace-forward-rule-trigger forward-rule-tracer) (predication)
  (setf traced-forward-rule-triggers
	(delete predication traced-forward-rule-triggers :test #'variant))
  (ensure-tracing-state self))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; backward rule tracer

0(defflavor backward-rule-tracer
	((trace-everything-p t)
	 (traced-backward-rules nil)
	 (traced-backward-rule-table (make-hash-table
					:number-of-values 0
					:locking
					*default-joshua-debugger-table-locking*))
	 (traced-backward-rule-triggers nil)
	 )
	(tracer)
  (:conc-name brt)
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

(defmacro-in-flavor (traced-rule-p backward-rule-tracer)(rule-name)
  `(gethash ,rule-name traced-backward-rule-table))

(defmacro-in-flavor (store-traced-backward-rule backward-rule-tracer)(rule-name)
  `(setf (gethash ,rule-name traced-backward-rule-table) ,rule-name))

(defmacro-in-flavor (unstore-traced-backward-rule backward-rule-tracer)(rule-name)
  `(remhash ,rule-name traced-backward-rule-table))

(defun-in-flavor (filter-backward-rule  backward-rule-tracer ) (rule predication truth-value)
  (or trace-everything-p
      (traced-rule-p rule)
      (some #'(lambda (p)
		(with-unification
		  (unify-predications-with-explicit-t-vs
		    p *true* predication truth-value)))
	    traced-backward-rule-triggers)))

(defvar *backward-rule-trace-events* '(:fire-backward-rule :exit-backward-rule 
				       :succeed-backward-rule :retry-backward-rule
 				       :enqueue-backward-rule :dequeue-backward-rule))
(defmethod (trace-it backward-rule-tracer)
	   (event rule predication truth-value importance)
  (when (filter-backward-rule rule predication truth-value)
    (with-joshua-trace-message-output (*trace-output*)
      (present-event event *trace-output* :active-name)
      (write-char #\space *trace-output*)
      (with-character-style (*emphasis-character-style* *trace-output*)
	(present rule 'backward-rule :allow-sensitive-inferiors nil))
      (write-char #\space *trace-output*)
      (when (and importance (plusp importance))
	(format *trace-output* " ~V[Importance ~d]~"
		*deemphasis-character-style* importance))
      (when (member event '(:fire-backward-rule :retry-backward-rule))
	(dw:with-output-as-presentation (:stream *trace-output*
					 :object predication
					 :type 'predication-presentation
					 :allow-sensitive-inferiors nil)
	  (with-character-style (*deemphasis-character-style* *trace-output*)
	    (format *trace-output* " (Goal... )")
1;0	    (print-with-truth-value-as-not predication truth-value)
	    )))
      )))
  
(defmethod (interact backward-rule-tracer)(event rule predication truth-value &rest ignore)
  (when (and (member event current-interaction-events)
	     (filter-backward-rule rule predication truth-value))
    (interact *joshua-debugger*)))

(defmethod (accept-tracing-options backward-rule-tracer) (&optional (stream *query-io*))
  (let (te tbr tbrt)
    (setf te (accept '(alist-member :alist (("All" :value t
					     :documentation "Trace all backward rules")
					    ("Selectively" :value nil
					     :documentation "Specify which rules to trace")))
		     :prompt "Trace backward rules"
		     :default trace-everything-p
		     :query-identifier :trace-all-backward-rules-p
		     :stream stream))
    (unless te 
      (setf tbr (accept '(null-or-type (sequence backward-rule))
			:prompt "Trace rules"
			:default traced-backward-rules
			:query-identifier :backward-rules-to-trace
			:stream stream
			))
      (setf tbrt (accept '(null-or-type (sequence predication-presentation))
			 :prompt "Trace backward rule triggers"
			 :query-identifier :backward-rule-triggers
			 :default traced-backward-rule-triggers
			 :stream stream)))
    `((trace-everything-p . ,te)
      (traced-backward-rules . ,tbr)
      (traced-backward-rule-triggers . ,tbrt)
      )))


(defmethod (set-tracing-options backward-rule-tracer :after)(&rest ignore)
  (clrhash traced-backward-rule-table)
  (loop for rule-name in traced-backward-rules do
    (store-traced-backward-rule rule-name))
  (setf traced-backward-rule-triggers
	(delete-duplicates traced-backward-rule-triggers :test #'variant))
  (ensure-tracing-state self))

1;;; This should return a menu alist whose :value is a list of the method
;;; and the instance to call to do the tracing to do the tracing. If you
;;; change the string that this returns you will have to change the  handler as well
0(defmethod (options-for-object backward-rule-tracer)(object)
  (let ((alist nil))
    (when (and (symbolp object)
	       (backward-rule-test-p object ))
      (if (traced-rule-p object)
	  (push `("Untrace Backward Rule"
		  :value (untrace-backward-rule ,self)
		  :documentation
		  ,(format nil "Untrace the backward rule ~a" object))
		alist)
	  (push `("Trace Backward Rule"
		  :value (add-trace-backward-rule ,self)
		  :documentation
		  ,(format nil "Trace the backward rule ~a" object))
		alist)))
    (when (predicationp object)
      (let ((variant (find object traced-backward-rule-triggers :test #'variant)))
	(if variant 
	    (push `("Untrace Backward Rule Trigger"
		    :value (untrace-backward-rule-trigger ,self)
		    :documentation
		    ,(format nil
			     "Untrace backward rules when triggered by a pattern matching ~a"
			     object))
		  alist)
	    (push `("Trace Backward Rule Trigger"
		    :value (add-trace-backward-rule-trigger ,self)
		    :documentation
		    ,(format nil "Trace backward rules when triggered by a pattern matching ~a"
			     object))
		  alist))))
    alist))


(define-joshua-tracing-method (tracable-backward-rule-p backward-rule-tracer)(object)
  (and (symbolp object)
       (backward-rule-test-p object)
       (not (traced-rule-p object))))

1;;; And for untracing backward rules
0(define-joshua-tracing-method (untracable-backward-rule-p backward-rule-tracer)(object)
  (and (symbolp object)
       (backward-rule-test-p object)
       (traced-rule-p object)))

1;;; For predications 
0(define-joshua-tracing-method (tracable-backward-rule-trigger-p backward-rule-tracer)(object)
  (and (predicationp object)
       (not (find object traced-backward-rule-triggers :test #'variant))))

(define-joshua-tracing-method (untracable-backward-rule-trigger-p backward-rule-tracer)(object)
  (and (predicationp object)
       (find object traced-backward-rule-triggers :test #'variant)))

(defmethod (show-tracing-state backward-rule-tracer)(&optional (stream *standard-output*))
  (cond ((tracer-enabled-p *joshua-debugger* self)
	 (with-output-as-command (stream `(com-disable-joshua-tracing ,self))
	   (format stream "~&~VBackward Rule~ tracing is ~Von~"
		   *emphasis-character-style* *emphasis-character-style*))
	 (indenting-output (stream 3)
	   (if trace-everything-p
	       (format stream "~%Tracing ~VAll~ backward rules"
		       *emphasis-character-style*)
	       (format stream "~%Tracing backward rule~p: " (length traced-backward-rules))
	       (format-textual-list traced-backward-rules
				    #'(lambda (r s) (present r 'backward-rule :stream s))
				    :stream stream
				    :conjunction " and "
				    :filled t
				    :if-two " and ")
	       (when traced-backward-rule-triggers
		 (format stream
			 "~&Tracing all backward rules triggered by a predication matching:")
		 (indenting-output (stream 3)
		   (fresh-line stream)
		   (format-textual-list traced-backward-rule-triggers
					#'(lambda (p s) (present p 'predication-presentation :stream s))
					:stream stream
					:conjunction "or"
					:filled t
					:if-two " or "))))
	   (show-event-state self stream)))
	(t
	 (with-output-as-command (stream `(com-enable-joshua-tracing ,self))
	   (format stream "~&~VBackward Rule~ tracing is ~Voff~"
		   *emphasis-character-style* *emphasis-character-style*)))))

(defmethod (ensure-tracing-state backward-rule-tracer)(&optional force-enable-p)
  (unless (or trace-everything-p traced-backward-rules traced-backward-rule-triggers)
    (reset-defaults self)
    (unless force-enable-p
      (disable-tracer *joshua-debugger* self)))
  (when (and trace-everything-p
	     (or traced-backward-rules traced-backward-rule-triggers))
    (setf trace-everything-p nil))
  (ensure-event-state self force-enable-p)
  (when (and force-enable-p (not (tracer-enabled-p *joshua-debugger* self)))
    (enable-tracer *joshua-debugger* self
		   :new-output-events current-output-events
		   :new-interaction-events current-interaction-events
		   )))

(defmethod (reset-defaults backward-rule-tracer) (&optional events-too-p)
  (setf trace-everything-p t
	traced-backward-rules nil
	traced-backward-rule-triggers nil)
  (clrhash traced-backward-rule-table)
  (when events-too-p (reset-events self)))
    
(defmethod (add-trace-backward-rule backward-rule-tracer)(rule-name)
  (pushnew rule-name traced-backward-rules)
  (store-traced-backward-rule rule-name)
  (ensure-tracing-state self t)
  )

(defmethod (untrace-backward-rule backward-rule-tracer)(rule-name)
  (setf traced-backward-rules (delete rule-name traced-backward-rules))
  (unstore-traced-backward-rule rule-name)
  (ensure-tracing-state self))

(defmethod (add-trace-backward-rule-trigger backward-rule-tracer)(predication)
  (pushnew predication traced-backward-rule-triggers :test #'variant)
  (ensure-tracing-state self t))

(defmethod (untrace-backward-rule-trigger backward-rule-tracer) (predication)
  (setf traced-backward-rule-triggers
	(delete predication traced-backward-rule-triggers :test #'variant))
  (ensure-tracing-state self))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Predication tracing 

0(defflavor predication-tracer
	((trace-everything-p t)
	 (traced-predicate-flavors nil) 	; a list of flavor-names
	 (interesting-predicate-flavors nil)	; holds all dependents of
						 ;traced-predicate-flavors
	 (traced-patterns nil)
	 )
	(tracer)
  (:conc-name pt)
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

(defun-in-flavor (traced-predicate-p predication-tracer)(predicate)
  (member predicate interesting-predicate-flavors :test #'eq))

(defmacro-in-flavor (register-traced-predicate predication-tracer)()
  `(setf interesting-predicate-flavors
	 (loop for pred in traced-predicate-flavors
	       nconc `(,pred . ,(flavor:flavor-all-dependents
				  (flavor:find-flavor pred)))
		 into flavor-list
	       finally (return (remove-duplicates flavor-list)))))

(defun-in-flavor (filter-fact  predication-tracer) (predication truth-value)
  (or trace-everything-p
      (traced-predicate-p (type-of predication) )
      (some #'(lambda (p)
		(with-unification
		  (unify-predications-with-explicit-t-vs
		    p *true* predication truth-value))
		)
	    traced-patterns)))

(defvar *predication-trace-events* '(:ask :tell :untell
					  :notice-truth-value-change :act-on-truth-value-change
					  :justify :unjustify))

(defun print-with-truth-value  (predication truth-value &optional (stream *standard-output*))
  (unless (= truth-value *true*)
    (write-char (select truth-value
		  (*unknown* #\?)
 		  (*false*  #\)
		  (*contradictory* #\))
		stream))
  (print-database-predication-without-truth-value predication stream))

(defmethod (trace-it predication-tracer)
	   (event predication &key truth-value old-truth-value justification)
  (ignore justification)
  (when (filter-fact predication truth-value)
    (with-joshua-trace-message-output (*trace-output*)
      (present-event event *trace-output* :active-name)
      (write-char #\space *trace-output*)
      (case event
	(:notice-truth-value-change
	  (format *trace-output* "of ")
	  (with-character-style (*emphasis-character-style* *trace-output*)
	    (print-with-truth-value predication old-truth-value *trace-output*))
	  (format *trace-output* " from ")
	  (present  old-truth-value 'truth-value :stream *trace-output*)
	  (format *trace-output* " to ")
	  (present truth-value 'truth-value :stream *trace-output*))
	(:act-on-truth-value-change
	  (format *trace-output* "of ")
	  (with-character-style (*emphasis-character-style* *trace-output*)
	    (print-with-truth-value predication old-truth-value *trace-output*))
	  (format *trace-output* " from ")
	  (present  old-truth-value 'truth-value :stream *trace-output*)
	  (format *trace-output* " to ")
	  (present truth-value 'truth-value :stream *trace-output*))
	((:ask :tell)
	 (with-character-style (*emphasis-character-style* *trace-output*)
	   (print-with-truth-value-as-not predication truth-value *trace-output*)))
	(otherwise (princ predication *trace-output*))))))

(defmethod (show-tracing-state predication-tracer)(&optional (stream *standard-output*))
  (cond ((tracer-enabled-p *joshua-debugger* self)
	 (with-output-as-command (stream `(com-disable-joshua-tracing ,self))
	   (format stream "~&~VPredication~ tracing is ~Von~"
		   *emphasis-character-style* *emphasis-character-style*))
	 (indenting-output (stream 3)
	   (if trace-everything-p
	       (format stream "~%Tracing ~VAll~ predicates"
		       *emphasis-character-style*)
	       (when traced-predicate-flavors
		 (format stream "~%Tracing predications of flavor~p: "
		       (length traced-predicate-flavors))
		 (format-textual-list traced-predicate-flavors
				    #'(lambda (p s) (present p 'joshua-predicate :stream s))
				    :stream stream
				    :conjunction "and"
				    :filled t
				    :if-two " and "))
	       (when traced-patterns
		 (format stream
			 "~&Tracing all predications matching:")
		 (indenting-output (stream 3)
		   (fresh-line stream)
		   (format-textual-list traced-patterns
					#'(lambda (p s) (present p 'predication-presentation :stream s))
					:stream stream
					:conjunction "or"
					:filled t
					:if-two " or "))))
	   (show-event-state self stream)))
	(t
	 (with-output-as-command (stream `(com-enable-joshua-tracing ,self))
	   (format stream "~&~VPredication~ tracing is ~Voff~"
		   *emphasis-character-style* *emphasis-character-style*)))))

(defmethod (interact predication-tracer)(event predication &key truth-value
					       &allow-other-keys)
  (when (and (member event current-interaction-events)
	     (filter-fact predication truth-value))
    (interact *joshua-debugger*)))

(defmethod (accept-tracing-options predication-tracer)
	   (&optional (stream *query-io*))
  (let (te tpf tp)
    (setf te (accept '(alist-member :alist (("All" :value t
					     :documentation "Trace all predications")
					    ("Selectively" :value nil
					     :documentation
					     "Specify which predications to trace")))
		     :prompt "Trace Predications"
		     :default trace-everything-p
		     :stream stream))
    (unless te 
      (setf tpf (accept '(null-or-type (sequence joshua-predicate))
			:prompt "Trace Predicates of flavor(s)"
			:default traced-predicate-flavors
			:stream stream))
      (setf tp (accept '(null-or-type (sequence predication-presentation))
		       :prompt "Trace Facts Matching"
		       :default traced-patterns
		       :stream stream)))
    `((trace-everything-p . ,te)
      (traced-predicate-flavors . ,tpf)
      (traced-patterns . ,tp))))

;;; Compute the list of interesting predicate flavors from the traced predicate flavors
(defmethod (set-tracing-options predication-tracer :after)(&rest ignore)
  (if trace-everything-p
      (setf interesting-predicate-flavors nil)
      (register-traced-predicate))
  (ensure-tracing-state self))

(defmethod (ensure-tracing-state predication-tracer)(&optional force-enable-p)
  (unless (or trace-everything-p traced-predicate-flavors
	      traced-patterns)
    (reset-defaults self)
    (unless force-enable-p
      (disable-tracer *joshua-debugger* self)))
  (when (and trace-everything-p (or traced-predicate-flavors traced-patterns))
    (setf trace-everything-p nil))
  (ensure-event-state self force-enable-p)
  (when (and force-enable-p (not (tracer-enabled-p *joshua-debugger* self)))
    (enable-tracer *joshua-debugger* self
		   :new-output-events current-output-events
		   :new-interaction-events current-interaction-events
		   )))

(defmethod (reset-defaults predication-tracer) (&optional events-too-p)
  (setf trace-everything-p t
	traced-predicate-flavors nil
	traced-patterns nil
	interesting-predicate-flavors nil)
  (when events-too-p (reset-events self)))

1;;; Add one predicate flavor to the list of interesting predicate flavors
0(defmethod (add-trace-predicate predication-tracer)(predicate)
  (pushnew predicate traced-predicate-flavors)
  (register-traced-predicate)
  (ensure-tracing-state self t))

(defmethod (untrace-predicate predication-tracer) (predicate)
  (setf traced-predicate-flavors (delete predicate traced-predicate-flavors))
  (register-traced-predicate)
  (ensure-tracing-state self))

(defmethod (add-trace-pattern predication-tracer)(predication)
  (setf traced-patterns (pushnew predication traced-patterns :test #'variant))
  (ensure-tracing-state self t))

(defmethod (untrace-pattern predication-tracer) (predication)
  (setf traced-patterns (delete predication traced-patterns :test #'variant))
  (ensure-tracing-state self))

1;;; This should return a menu alist whose :value is a list of the method
;;; and the instance to call to do the tracing to do the tracing. If you
;;; change the string that this returns you will have to change the  handler as well
0(defmethod (options-for-object predication-tracer)(object)
  (let ((alist nil))
    (when (and (symbolp object)
	       (joshua-predicate-p object))
      (if (member object traced-predicate-flavors)
	  (push `("Untrace Predicate Flavor"
		  :value (untrace-predicate ,self)
		  :documentation
		  ,(format nil "Untrace the predication built on ~a" object))
		alist)
	  (push `("Trace Predicate Flavor"
		  :value (add-trace-predicate ,self)
		  :documentation
		  ,(format nil "Trace predications built on ~a" object))
		alist)))
    (when (predicationp object)
      (let ((variant (find object traced-patterns  :test #'variant)))
	(if variant 
	    (push `("Untrace Predication Pattern"
		    :value (untrace-pattern ,self)
		    :documentation
		    ,(format nil "Untrace Predications matching ~a" object))
		  alist)
	    (push `("Trace Predications Pattern"
		    :value (add-trace-pattern ,self)
		    :documentation
		    ,(format nil "Trace Predications matching ~a" object))
		  alist))))
    alist))

(define-joshua-tracing-method (tracable-predicate-p predication-tracer)(object)
  (and (symbolp object)
       (joshua-predicate-p object)
       (not (member object traced-predicate-flavors))))

(define-joshua-tracing-method (untracable-predicate-p predication-tracer)(object)
  (and (symbolp object)
       (joshua-predicate-p object)
       (member object traced-predicate-flavors)))

(define-joshua-tracing-method (tracable-predication-p predication-tracer)(object)
  (and (predicationp object)
       (not (find object traced-patterns  :test #'variant))))

(define-joshua-tracing-method (untracable-predication-p predication-tracer)(object)
  (and (predicationp object)
       (find object traced-patterns  :test #'variant)))


1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Rete match and Merge tracing.

0;(defflavor rete-tracer
;	((trace-everything-p t)
;	 (traced-rete-rules nil)
;	 (traced-rete-patterns nil)
;	 (interesting-rete-nodes
;	  (make-hash-table :test 'eq :number-of-values 0
;			   :locking *default-joshua-debugger-table-locking*))
;	 (local-forward-rule-firings 0)
;	 (local-merges-tried 0)
;	 (local-merges-succeeded 0)
;	 (local-merges-failed 0)
;	 (local-matches-tried 0)
;	 (local-matches-succeeded 0)
;	 (local-matches-failed 0))
;	(tracer)
;  (:conc-name rt)
;  :readable-instance-variables
;  :writable-instance-variables
;  :settable-instance-variables)
;
;(defun-in-flavor (filter-rete rete-tracer) (rete-node)
;  (or trace-everything-p
;      (gethash rete-node interesting-rete-nodes)))
;
;(defmacro-in-flavor (register-rule-nodes rete-tracer)()
;  `(progn (clrhash interesting-rete-nodes)
;	 (unless trace-everything-p 
;	   (loop for rule in traced-rete-rules
;		 do
;	     (loop for node in (nodes-leading-to-goals `(,rule))
;		   do
;	       (setf (gethash node interesting-rete-nodes) node))))))
;
;(defvar *rete-trace-events* '(:try-merge :succeed-merge :fail-merge :try-match
;					:succeed-match :fail-match))
;1;; sap:>nlm>joshua-metering-interface
0;(defmethod (trace-it rete-tracer)
;	   (event node &key merge-left merge-right environment match-predication match-pattern)
;  (ignore environment)
;  (when (filter-rete node)
;	(with-joshua-trace-message-output (*trace-output*)
;	  (let ((*print-structure-contents* nil))
;	    (present-event event *trace-output* :active-name)
;	    (write-char #\space *trace-output*)
;	    (case event
;	      (:try-merge
;		(incf local-merges-tried)
;		(format *trace-output*
;			"of ~S and ~S" merge-left merge-right))
;	      (:succeed-merge
;		(incf local-merges-succeeded)
;		(format *trace-output* "~S and~S"
;			merge-left merge-right))
;	      (:fail-merge
;		(incf local-merges-failed)
;		(format *trace-output* "of ~S and~S"
;			merge-left merge-right))
;	      (:try-match
;		(incf local-matches-tried)
;		(format *trace-output* "~s to pattern ~s"
;			match-predication match-pattern))
;	      (:succeed-match
;		(incf local-matches-succeeded)
;		(format *trace-output* "~s to pattern ~s"
;			match-predication match-pattern))
;	      (:fail-match
;		(incf local-matches-failed)
;		(format *trace-output* "of ~s to pattern ~s "
;			match-predication match-pattern)))))))
;
;(defmethod (interact rete-tracer)(event node &rest ignore)
;  (when (and (member event current-interaction-events)
;	     (filter-rete node))
;    (interact *joshua-debugger*)))
;
;(defmethod (accept-tracing-options rete-tracer)(&optional (stream *query-io*))
;  (let ((te trace-everything-p)
;	(trr traced-rete-rules))
;    (setf te (accept '(alist-member :alist (("All" :value t
;					     :documentation
;					     "Trace Matches and merges for all rules ")
;					    ("Selectively" :value nil
;					     :documentation
;					     "Specify which rules to trace")))
;		     :prompt "Trace Matches and Merges for forward rules"
;		     :default trace-everything-p
;		     :stream stream))
;    (unless te
;      (setf trr (accept '(null-or-type (sequence forward-rule))
;			:prompt "Rules"
;			:default traced-rete-rules
;			:stream stream)))
;    `((trace-everything-p . ,te)
;      (traced-rete-rules . ,trr))))
;
;(defmethod (show-tracing-state rete-tracer)(&optional (stream *standard-output*))
;  (cond ((tracer-enabled-p *joshua-debugger* self)
;	 (format stream "~&~VMatches and Merges~ tracing is ~Von~"
;		 *emphasis-character-style* *emphasis-character-style*)
;	 (indenting-output (stream 3)
;	   (if trace-everything-p
;	       (format stream "~%Tracing matching and merging of ~VAll~ forward rules"
;		       *emphasis-character-style*)
;	       (format stream "~%Tracing matching and merging of forward rule~p: "
;		       (length traced-rete-rules))
;	       (format-textual-list traced-rete-rules
;				    #'(lambda (r s) (present r 'forward-rule :stream s))
;				    :stream stream
;				    :conjunction "and"
;				    :filled t
;				    :if-two " and "))
;;	   (when traced-patterns
;;	     (format stream
;;		     "~&Tracing all predications matching:")
;;	     (indenting-output (stream 3)
;;	       (fresh-line stream)
;;	       (format-textual-list traced-patterns
;;				    #'(lambda (p s) (present p 'predication-presentation :stream s))
;;				    :stream stream
;;				    :conjunction "or"
;;				    :filled t
;;				    :if-two " or ")))
;	   (show-event-state self stream)))
;	(t (format stream "~&~VMatches and Merges~ tracing is ~Voff~"
;		 *emphasis-character-style* *emphasis-character-style*))))
;
;(defmethod (set-tracing-options rete-tracer :after)(ignore)
;  (clrhash interesting-rete-nodes)
;  (unless trace-everything-p
;    (register-rule-nodes))
;  (ensure-tracing-state self))
;
;
;(defmethod (options-for-object rete-tracer)(object)
;  (let ((alist nil))
;    (when (and (symbolp object)
;	       (forward-rule-test-p object))
;      (if (member object traced-rete-rules)
;	  (push `(,(abbreviate-string (format nil "Untrace matches and merges of rule ~a"
;					      object)
;				      *trace-options-menu-width*)
;		  :value (untrace-rete-rule ,self)
;		  :documentation
;		  ,(format nil "Untrace the matches and merges of rule ~a" object))
;		alist)
;	  (push `(,(abbreviate-string (format nil "Trace the matches and merges of rule ~a"
;					      object)
;				      *trace-options-menu-width*)
;		  :value (add-trace-rete-rule ,self)
;		  :documentation
;		  ,(format nil "Trace the matches and merges of rule ~a" object))
;		alist)))
;    alist))
;
;(defmethod (add-trace-rete-rule rete-tracer)(rule)
;  (pushnew rule traced-rete-rules)
;  (register-rule-nodes)
;  (ensure-tracing-state self t))
;
;(defmethod (untrace-rete-rule rete-tracer)(rule)
;  (setf traced-rete-rules (delete rule traced-rete-rules))
;  (register-rule-nodes)
;  (ensure-tracing-state self))
;
;(defmethod (ensure-tracing-state rete-tracer)(&optional force-enable-p)
;  (unless (or trace-everything-p traced-rete-rules)
;    (reset-defaults self)
;    (unless force-enable-p
;      (disable-tracer *joshua-debugger* self)))
;  (when (and trace-everything-p traced-rete-rules)
;    (setf trace-everything-p nil))
;  (ensure-event-state self t)
;  (when (and force-enable-p (not (tracer-enabled-p *joshua-debugger* self)))
;    (enable-tracer *joshua-debugger* self
;		   :new-output-events current-output-events
;		   :new-interaction-events current-interaction-events
;		   )))
;
;(defmethod (reset-defaults rete-tracer) (&optional events-too-p)
;  (setf trace-everything-p t
;	traced-rete-rules nil)
;  (register-rule-nodes)
;  (when events-too-p (reset-events self)))

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; TMS tracing.

0(defflavor TMS-tracer
	((trace-everything-p t)
	 (traced-predicate-flavors nil)
	 (interesting-predicate-flavors nil)	; holds all dependents of
						 ;traced-predicate-flavors
	 (traced-patterns nil)
	 )
	(tracer)
  (:conc-name pt)
  :readable-instance-variables
  :writable-instance-variables
  :settable-instance-variables)

(defun-in-flavor (traced-predicate-p TMS-tracer)(predicate)
  (member predicate interesting-predicate-flavors :test #'eq))

(defmacro-in-flavor (register-traced-predicate TMS-tracer)()
  `(setf interesting-predicate-flavors
	 (loop for pred in traced-predicate-flavors
	       nconc `(,pred . ,(flavor:flavor-all-dependents
				  (flavor:find-flavor pred)))
		 into flavor-list
	       finally (return (remove-duplicates flavor-list)))))

(defun-in-flavor (filter-TMS  TMS-tracer) (predication truth-value)
  (and (nontrivial-tms-p predication)
       (or trace-everything-p
	   (traced-predicate-p (type-of predication))
	   (some #'(lambda (p)
		     (with-unification
		       (unify-predications-with-explicit-t-vs
			 p *true* predication truth-value)))
		 traced-patterns))))

(defvar *TMS-trace-events* '(:contradiction :bring-in :retract))

(defmethod (trace-it TMS-tracer)
	   (event predication &key truth-value old-truth-value justification)
  (ignore old-truth-value)
  (when (filter-TMS predication truth-value)
    (with-joshua-trace-message-output (*trace-output*)
      (flet ((print-pred (&optional print-with-t-v-p)
	       (with-character-style (*emphasis-character-style* *trace-output*)
		 (if print-with-t-v-p (present predication 'database-predication-presentation
					       :stream *trace-output*)
		     (print-database-predication-without-truth-value predication
								     *trace-output*)))
	       (unless (or (= *true* truth-value) print-with-t-v-p)
		 (format *trace-output* " as ")
		 (with-character-style (*emphasis-character-style* *trace-output*)
		   (present truth-value 'truth-value :stream *trace-output*))))
	     (print-support ()
	       (when justification
		 (let ((name (ltms::clause-name justification)) ; used to be destructure-justification
		       (support justification))
		   (with-character-style (*deemphasis-character-style* *trace-output*)
		     (write-char #\space *trace-output*)
		     (dw:with-output-as-presentation (:stream *trace-output*
						      :object support
						      :type 'sys:expression
						      )
		       (format *trace-output* "<-- ")
		       (cond ((joshua-rule-p name)
			      (format *trace-output* "Rule: ")
			      (present name 'rule :stream *trace-output*))
			     (t (format *trace-output* "~a" name)))))))))
	(present-event event *trace-output* :active-name)
	(write-char #\: *trace-output*)
	(write-char #\space *trace-output*)
	(case event
	  ((:bring-in :retract)
	    (print-pred)
	    (print-support))
	  (:contradiction
	    (format *trace-output* "Establishing ")
	    (print-pred)
	    (print-support))
	  1;; No need to print support for these guys, or to fake the t-v
0	  )))))

(defmethod (show-tracing-state TMS-tracer)(&optional (stream *standard-output*))
  (cond ((tracer-enabled-p *joshua-debugger* self)
	 (with-output-as-command (stream `(com-disable-joshua-tracing ,self))
	   (format stream "~&~VTMS~ tracing is ~Von~"
		   *emphasis-character-style* *emphasis-character-style*))
	 (indenting-output (stream 3)
	   (if trace-everything-p
	       (format stream "~%Tracing ~VAll~ TMS predicates"
		       *emphasis-character-style*)
	       (when traced-predicate-flavors
		 (format stream "~%Tracing TMS predicatations of flavor~p: "
			 (length traced-predicate-flavors))
		 (format-textual-list traced-predicate-flavors
				      #'(lambda (p s) (present p 'joshua-predicate :stream s))
				      :stream stream
				      :conjunction "and"
				      :filled t
				      :if-two " and "))
	       (when traced-patterns
		 (format stream
			 "~&Tracing all TMS predications matching:")
		 (indenting-output (stream 3)
		   (fresh-line stream)
		   (format-textual-list traced-patterns
					#'(lambda (p s) (present p 'predication-presentation :stream s))
					:stream stream
					:conjunction "or"
					:filled t
					:if-two " or "))))
	   (show-event-state self stream)))
	(t
	 (with-output-as-command (stream `(com-enable-joshua-tracing ,self))
	   (format stream "~&~VTMS~ tracing is ~Voff~"
		   *emphasis-character-style* *emphasis-character-style*)))))

(defmethod (interact TMS-tracer)(event predication &key truth-value &allow-other-keys)
  (when (and (member event current-interaction-events)
	     (filter-TMS predication truth-value))
    (interact *joshua-debugger*)))

(defmethod (accept-tracing-options TMS-tracer)(&optional (stream *query-io*))
  (let (te tpf tp)
    (setf te (accept '(alist-member :alist (("All" :value t
					     :documentation "Trace all TMS predications")
					    ("Selectively" :value nil    
					     :documentation
					     "Specify which TMS predications to trace")))
		     :prompt "Trace TMS operations on which TMS Predications"
		     :default trace-everything-p
		     :stream stream))
    (unless te
      (setf tpf (accept '(null-or-type (sequence tms-predicate))
			:prompt "TMS predicate flavors"
			:default traced-predicate-flavors
			:stream stream))
      (setf tp (accept '(null-or-type (sequence tms-predication-presentation))
		       :prompt "Trace TMS predications matching"
		       :default traced-patterns
		       :stream stream)))
    `((trace-everything-p . ,te)
      (traced-predicate-flavors . ,tpf)
      (traced-patterns . ,tp))))

;;; Compute the list of interesting predicate flavors from the traced predicate flavors
(defmethod (set-tracing-options TMS-tracer :after)(&rest ignore)
  (if trace-everything-p
      (setf interesting-predicate-flavors nil)
      (register-traced-predicate))
  (ensure-tracing-state self))

(defmethod (ensure-tracing-state TMS-tracer)(&optional force-enable-p)
  (unless (or trace-everything-p traced-predicate-flavors
	      traced-patterns)
    (reset-defaults self)
    (unless force-enable-p
      (disable-tracer *joshua-debugger* self)))
  (when (and trace-everything-p (or traced-predicate-flavors traced-patterns))
    (setf trace-everything-p nil))
  (ensure-event-state self force-enable-p)
  (when (and force-enable-p (not (tracer-enabled-p *joshua-debugger* self)))
    (enable-tracer *joshua-debugger* self
		   :new-output-events current-output-events
		   :new-interaction-events current-interaction-events
		   )))

(defmethod (reset-defaults TMS-tracer) (&optional events-too-p)
  (setf trace-everything-p t
	traced-predicate-flavors nil
	traced-patterns nil
	interesting-predicate-flavors nil)
  (when events-too-p (reset-events self)))

1;;; Add one predicate flavor to the list of interesting predicate flavors
0(defmethod (add-trace-predicate TMS-tracer)(predicate)
  (pushnew predicate traced-predicate-flavors)
  (register-traced-predicate)
  (ensure-tracing-state self t))

(defmethod (untrace-predicate TMS-tracer) (predicate)
  (setf traced-predicate-flavors (delete predicate traced-predicate-flavors))
  (register-traced-predicate)
  (ensure-tracing-state self))

(defmethod (add-trace-pattern TMS-tracer)(predication)
  (setf traced-patterns (pushnew predication traced-patterns :test #'variant))
  (ensure-tracing-state self t))

(defmethod (untrace-pattern TMS-tracer) (predication)
  (setf traced-patterns (delete predication traced-patterns :test #'variant))
  (ensure-tracing-state self))

1;;; This should return a menu alist whose :value is a list of the method
;;; and the instance to call to do the tracing to do the tracing. If you
;;; change the string that this returns you will have to change the
;;; handler as well
0(defmethod (options-for-object TMS-tracer)(object)
  (let ((alist nil))
    (when (and (symbolp object)
	       (tms-predicate-p object))
      (if (member object traced-predicate-flavors)
	  (push `("Untrace TMS Predicate"
		  :value (untrace-predicate ,self)
		  :documentation
		  ,(format nil "Turn off the tracing of TMS predications built on ~a" object))
		alist)
	  (push `("Trace TMS Predicate"
		  :value (add-trace-predicate ,self)
		  :documentation
		  ,(format nil "Turn on the tracing of TMS predications built on ~a" object))
		alist)))
    (when (and (predicationp object)(nontrivial-tms-p object))
      (let ((variant (find object traced-patterns  :test #'variant)))
	(if variant 
	    (push `("Untrace TMS Predication Pattern"
		    :value (untrace-pattern ,self)
		    :documentation
		    ,(format nil "Turn off the tracing of TMS predications matching ~a"
			     object))
		  alist)
	    (push `("Trace TMS Predication Pattern"
		    :value (add-trace-pattern ,self)
		    :documentation
		    ,(format nil "Turn on the tracing of TMS predications matching ~a" object))
		  alist))))
    alist))


(define-joshua-tracing-method (tracable-tms-predicate-p tms-tracer)(object)
  (and (symbolp object)
       (joshua-predicate-p object)
       (not (member object traced-predicate-flavors))))

(define-joshua-tracing-method (untracable-tms-predicate-p tms-tracer)(object)
  (and (symbolp object)
       (joshua-predicate-p object)
       (member object traced-predicate-flavors)))

(define-joshua-tracing-method (tracable-tms-predication-p tms-tracer)(object)
  (and (predicationp object)
       (not (find object traced-patterns  :test #'variant))))

(define-joshua-tracing-method (untracable-tms-predication-p tms-tracer)(object)
  (and (predicationp object)
       (find object traced-patterns  :test #'variant)))


1;;; The end of all the flavor methods

0(compile-flavor-methods tracing-event joshua-encapsulation
			tracer
			;; rete-tracer
			predication-tracer TMS-tracer
			backward-rule-tracer forward-rule-tracer joshua-debugger)


1;;; Here are the actual definitions of the debugging events and tracers
;;; The pretty name is for accepting and presenting
;;; The short-name is for the accept-events in the menu
;;; The active name is for trace messages: "firing forwarard rule ..."
0(define-tracing-event :fire-forward-rule "Fire forward rule"
  :short-name "Fire"
  :active-name "Firing forward rule"
  :macro-name trace-fire-forward-rule
  :arglist (rule-name triggers environment importance)
  :documentation "Firing the THEN part of a forward rule" 
  )

(define-tracing-event :exit-forward-rule "Exit forward rule"
  :short-name "Exit"
  :active-name "Exiting forward rule"
  :macro-name trace-exit-forward-rule
  :arglist (rule-name triggers environment importance)
  :documentation "Exiting the THEN part of a forward rule"
  )

(define-tracing-event :enqueue-forward-rule "Queue forward rule"
  :short-name "Queue"
  :active-name "Queuing forward rule"
  :macro-name trace-enqueue-forward-rule
  :arglist (rule-name triggers environment importance)
  :documentation "Putting the rule on the forward importance queue"
  )

(define-tracing-event :dequeue-forward-rule "Dequeue forward rule"
  :short-name "Dequeue"
  :active-name "Dequeuing forward rule"
  :macro-name trace-dequeue-forward-rule
  :arglist (rule-name triggers environment importance)
  :documentation "Taking the forward rule off the importance queue"
  )

(define-tracing-event :fire-backward-rule "Try backward rule"
  :short-name "Try"
  :active-name "Trying backward rule"
  :macro-name trace-fire-backward-rule
  :arglist (rule-name predication truth-value importance)
  :documentation "Trying the IF part of a backward rule")

;;; this event is called exit even though it currently prints as "Failing"
(define-tracing-event :exit-backward-rule "Fail backward1 0rule"
  :short-name "Fail"
  :active-name "Failing backward rule"
  :macro-name trace-exit-backward-rule
  :arglist (rule-name predication truth-value importance)
  :documentation "Failing the IF part of a backward rule")

(define-tracing-event :succeed-backward-rule "Succeed backward rule"
  :short-name "Succeed"
  :active-name "Succeeding backward rule"
  :macro-name trace-succeed-backward-rule
  :arglist (rule-name predication truth-value importance)
  :documentation "Succeeding from the IF part of a backward rule")

(define-tracing-event :retry-backward-rule "Retry backward rule"
  :short-name "Retry"
  :active-name "Retrying backward rule"
  :macro-name trace-retry-backward-rule
  :arglist (rule-name predication truth-value importance)
  :documentation "Looking for another solution in the IF part of a backward rule")

(define-tracing-event :enqueue-backward-rule "Queue backward rule"
  :short-name "Queue"
  :active-name "Queuing backward rule"
  :macro-name trace-enqueue-backward-rule
  :arglist (rule-name predication truth-value importance)
  :documentation "Putting a backward rule onto the backward importance queue")

(define-tracing-event :dequeue-backward-rule "Dequeue backward rule"
  :short-name "Dequeue"
  :active-name "Dequeuing backward rule"
  :macro-name trace-dequeue-backward-rule
  :arglist (rule-name predication truth-value importance)
  :documentation "Removing a backward rule from the backward importance queue")

(define-tracing-event :ask "Ask predication"
  :short-name "Ask"
  :active-name "Asking predication"
  :macro-name trace-ask
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Ask predication")

(define-tracing-event :tell "Tell predication"
  :short-name "Tell"
  :active-name "Telling predication"
  :macro-name trace-tell
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Tell predication to the database")

(define-tracing-event :untell "Untell predication"
  :short-name "Untell"
  :active-name "Untelling predication"
  :macro-name trace-untell
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Removing a predication from the database")

(define-tracing-event :notice-truth-value-change "Notice truth value change"
  :short-name "Truth value change"
  :active-name "Noticing truth value change"
  :macro-name trace-notice-truth-value-change
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Noticing the Change of the truth value of a predication in the database")

(define-tracing-event :act-on-truth-value-change "Act on truth value change"
  :short-name "Act on truth value change"
  :active-name "Responding to change of truth value"
  :macro-name trace-act-on-truth-value-change
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Acting on the change of the truth value of a predication in the database")

(define-tracing-event :try-merge "Try merge"	
  :short-name "Try merge"
  :active-name "Trying to merge"
  :macro-name trace-try-merge
  :arglist (node &key merge-left merge-right environment match-predication match-pattern)
  :documentation "Trying to merge the bindings of matched forward rule triggers ")

(define-tracing-event :succeed-merge "Merge"
  :short-name "Merge"
  :active-name "Merging"
  :macro-name trace-succeed-merge
  :arglist (node &key merge-left merge-right environment match-predication match-pattern)
  :documentation "Successfully merging the bindings of matched forward rule triggers")

(define-tracing-event :fail-merge "Fail merge"
  :short-name "Fail Merge"
  :active-name "Failing to merge"
  :macro-name trace-fail-merge
  :arglist (node &key merge-left merge-right environment match-predication match-pattern)
  :documentation "Failing an attempt to merge the bindings of matched forward rule triggers")

(define-tracing-event :try-match "Try match"
  :short-name "Try match"
  :active-name "Trying to match"
  :macro-name trace-try-match
  :arglist (node &key merge-left merge-right environment match-predication match-pattern)
  :documentation "Trying to match a predication against a forward rule trigger")

(define-tracing-event :succeed-match "Match"
  :short-name "Match"
  :active-name "Matching"
  :macro-name trace-succeed-match
  :arglist (node &key merge-left merge-right environment match-predication match-pattern)
  :documentation "Successfully matching a predication against a forward rule trigger")

(define-tracing-event :fail-match "Fail match"
  :short-name "Fail match"
  :active-name "Failing to match"
  :macro-name trace-fail-match
  :arglist (node &key merge-left merge-right environment match-predication match-pattern)
  :documentation "Failing an attempt to match against a forward rule trigger")

(define-tracing-event :justify "Justify predication"
  :short-name "Justify"
  :active-name "Justifying"
  :macro-name trace-justify
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Installing the justification of a predication")

(define-tracing-event :unjustify "Unjustify predication"
  :short-name "Unjustify"
  :active-name "Unjustifying"
  :macro-name trace-unjustify
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Removing the justification of a predication")

(define-tracing-event :contradiction "Notice contradiction"
  :short-name "Contradiction"
  :active-name "Noticing contradiction"
  :macro-name trace-contradiction
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Noticing a TMS contradiction")

(define-tracing-event :bring-in "Justify TMS predication"
  :short-name "Justify"
  :active-name "Justifying"
  :macro-name trace-bring-in
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Bringing a TMS predication into the database")

(define-tracing-event :retract "Unjustify TMS predication"
  :short-name "Unjustify"
  :active-name "Unjustifying"
  :macro-name trace-retract
  :arglist (predication &key truth-value old-truth-value justification)
  :documentation "Retracting a TMS predication from the database")

1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; here are the defs for the tracers (collections of traced events)
;;; These should be compiled after the events they use.

0(define-tracer forward-rule-tracer "Forward Rules"
  :pretty-name "Trace Forward Rules"
  :events *forward-rule-trace-events*
  :default-trace-events '(:Fire-forward-rule :enqueue-forward-rule)
  :default-step-events nil)

(define-tracer backward-rule-tracer "Backward Rules"
  :pretty-name "Trace Backward Rules"
  :events *backward-rule-trace-events*
  :default-trace-events '(:Fire-backward-rule :exit-backward-rule
			  :retry-backward-rule :succeed-backward-rule)
  :default-step-events nil)

(define-tracer predication-tracer "Predications"
  :pretty-name "Trace Predications"
  :events *predication-trace-events*
  :default-trace-events '(:ask :tell)
  :default-step-events nil)

;(define-tracer rete-tracer "Matches and Merges"
;  :pretty-name "Trace Matches and Merges"
;  :events *rete-trace-events*
;  :default-trace-events '(:succeed-match)
;  :default-step-events nil)

(define-tracer tms-tracer "TMS Operations"
  :pretty-name "Trace TMS Operations"
  :events *tms-trace-events*
  :default-trace-events '(:contradiction :bring-in :retract)
  :default-step-events nil)
  

