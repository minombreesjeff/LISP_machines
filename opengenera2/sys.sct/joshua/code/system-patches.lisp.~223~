;;; -*- Mode: LISP; Package: COMMON-LISP-USER; Syntax: Common-Lisp; Patch-File: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Created Friday the sixteenth of May, 1986; 12:54:52 pm by sgr on GROUSE at SCRC

;;;
;;; Release 7.2 system patches.  Migrate as sources unlock.
;;; 
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;; There are a bunch of things that look broken - see comments in bold

0;;;
;;; Fix a compiler optimizer to not barf when we apply a constructor to a dotted list.
;;;  (The rest arg will be a non-list, but that's what we want.)  :Show Joshua Database
;;;  uses the pattern [ . ] in its default, which exercises this.

;;; --- Already patched into 7.4 and 7.5.  This definition should work in 7.2.

;;#.(when (< (si:get-system-version) 418)
;;'
;;compiler:
;;(defoptimizer (cl:apply apply-on-list) (form)
;;  (block apply-on-list
;;    (let ((last-arg (first (last form))))
;;      (when (cl:constantp last-arg)
;;	(let* ((last-arg-value (lt:evaluate-constant last-arg))
;;	       (last-last-arg-value (last last-arg-value)))
;;	  ;; make sure the constant list we're expanding is well-formed
;;	  (when (and (cl:listp last-last-arg-value)
;;		     (null (cdr last-last-arg-value)))
;;	    (return-from apply-on-list
;;	      ;; If function to be called is constant, optimize out the "funcall"
;;	      ;; in case the symbol is a subst function.
;;	      (funcall-function `(funcall ,@(butlast (cdr form))
;;					  ,@(mapcar #'(lambda (x) `',x)
;;						    last-arg-value)))))))
;;      (setq last-arg (undo-list-optimization last-arg))
;;      (matchp last-arg
;;	(('list . args)
;;	 (funcall-function `(funcall ,@(butlast (cdr form)) ,@args)))
;;	(('list* . args)
;;	 `(cl:apply ,@(butlast (cdr form)) ,@args))
;;	(* form)))))
;;)
;
;; 
;; compiler:
;; (defoptimizer (cl:apply apply-on-list) (form)
;;   (block apply-on-list
;;     (let ((last-arg (first (last form))))
;;       (when (constant-form-p last-arg)
;;1	 (when (and (listp last-arg)
0;;1		     (eq (car last-arg) 'quote)
0;;1		     (not (null (cdr (last (second last-arg))))))
0;;1	   ;; apply to a quoted, dotted list
0;;1	   (if (sys:unbound-logic-variable-p (cdr (last (second last-arg))))
0;;1	       ;; logic var in cdr, so it's probably just a tail var.  defeat the optimization.
0;;1	       (return-from apply-on-list form)
0;;1	       ;; looks like a real error.
0;;1	       (error "Tried to optimize apply to a quoted, dotted list")))
0;;	 ;; If function to be called is constant, optimize out the "funcall"
;;	 ;; in case the symbol is a subst function.
;;	 (return-from apply-on-list
;;	   (funcall-function `(funcall ,@(butlast (cdr form))
;;				       ,@(mapcar #'(lambda (x) `',x)
;;						 (constant-evaluator last-arg)))
;;			     t)))
;;       (setq last-arg (undo-list-optimization last-arg))
;;       (matchp last-arg
;;	 (('list . args)
;;	  (funcall-function `(funcall ,@(butlast (cdr form)) ,@args)
;;			    t))
;;	 (('list* . args)
;;	  `(cl:apply ,@(butlast (cdr form)) ,@args))
;;	 (* form)))))

1
0;;;
;;; FORMAT hacks.
;;;

(format:defformat format:a-an (:one-arg) (argument parameters)
  ;;; a-an hack
  (ignore parameters)
  (flet ((vowelp (x)
	   (and (characterp x)
		;; what about semi-vowels, like y?
		(member x '(#\a #\e #\i #\o #\u) :test #'char-equal))))
    (setq argument (aref (string argument) 0)) ;coerce to string & get 1st char
    (princ (if (vowelp argument) "an" "a") format:*format-output*)))

(format:defformat format:list (:one-arg) (argument parameters)
  ;; print a textual list in a couple of the common cases.
  ;; no modifiers  prin1 and "and"
  ;; : modifier    use princ instead
  ;; @ modifier    use "or" instead
  (ignore parameters) ;what does this do?
  (format-textual-list argument
		       (if format:colon-flag
			   #'princ
			   #'prin1)
		       :conjunction (if format:atsign-flag
					"or"
					"and")
		       :stream format:*format-output*))


;;; Record types for Joshua rules
;;; If you own concordia too, this will let you document rules.

sage::
(create-record-type :sage-joshua-rule 'rule "Rule"
		    '(rule |JOSHUA FORWARD RULE| |JOSHUA BACKWARD RULE|)
		    '())


sage::
(create-record-type :sage-joshua-forward-rule-record 
		    T ;; I have no idea whether this is right
		    "Joshua Forward Rule"
		    ()
		    '()	;; Ditto
		    )
sage::
(create-record-type :sage-joshua-backward-rule-record 
		    T ;; I have no idea whether this is right
		    "Joshua Backward Rule"
		    ()
		    '()	;; Ditto
		    )

zwei:
(defcom COM-SHOW-RULE-DOCUMENTATION
	"Looks up a topic from the documentation set and displays it on a typeout window.
It offers the current rule definition as a default, but prompts for a
definition, which can be supplied by mouse or minibuffer.  It accepts
only those topics for which documentation has been installed.

Some topic names are not unique.  In this case, it offers you a short menu
of choices and you pick the one you wanted.  When the topic name is
unique, it shows it without prompting you for the category.

With a numeric argument, it prompts for an output device.  The devices
include the screen and supported printers." ()
  (let* ((default (relevant-function-or-message-name (point)))
	 (default-record-group
	   (sage:find-record-group-for-topic-and-type default 'sage::rule)))
    (let ((record-group (collect-record-group-from-user "Look up Documentation for Rule"
							default-record-group)))
      (sage-displayer-interface record-group)))
  dis-none)

1zwei:
(set-comtab *0zmacs-1comtab*0 1'(#\0s-m-d com-show-rule-documentation)1)

0

;;;; Keep Ivory Rev-4 From losing with Joshua

#+Imach
(defvar *protect-ivory-rev-4-from-joshua* nil
  "Normally NIL, but When Compiling Joshua Stuff T")

#+Imach
(advise I-LISP-COMPILER:LOOK-FOR-SET-TO-CDR-PUSH-CAR
	:around
	conditionally-disable-set-to-cdr-push-car
	nil
  (if *protect-ivory-rev-4-from-joshua*
      nil
      :do-it))

#+Imach
(advise I-LISP-COMPILER:LOOK-FOR-COMPILICATED-SET-TO-CDR-PUSH-CAR
	:around
	conditionally-disable-set-to-cdr-push-car
	nil
  (if *protect-ivory-rev-4-from-joshua*
      nil
      :do-it))

#+Imach
(advise compiler:compile-from-stream
	:around
	if-compiling-for-joshua-dont-emit-unsafe-instructions
	nil
  (destructuring-bind (input-stream generic-pathname ignore additional-bindings &rest ignore) arglist
    (let ((plist (if generic-pathname
		     (send generic-pathname :plist)
		     ADDITIONAL-BINDINGS)))
      (when (locativep plist)
	   (setf plist (location-contents plist)))
      (let-if (eq :joshua (getf plist :syntax))
	      ((*protect-ivory-rev-4-from-joshua* t))
	:do-it))))



;;;;
;;;;  Control of DW type updates
;
;;;; Whether to hack type updating while compiling things in Joshua Syntax
;(defvar si:*delay-type-updating-while-compiling-joshua-code* t)
;
;;;; And loading 
;(defvar si:*delay-type-updating-while-loading-joshua-bins* t)
;
;;;; Ok, I'm blushing. If the Plist has a Joshua :syntax property, inhibit the
;;;; merging of type changes until the body has compiled. This doubles the speed
;;;; of both loading and compiling define-predicates.
;si:
;(defmacro with-joshua-pending-dw-updates ((generic-pathname-plist operation) &body body)
;  (let ((load-file-for-joshua (sys:gensymbol "LOAD-FILE-FOR-JOSHUA"))
;	(plist (sys:gensymbol "GENERIC-PLIST")))
;    `(flet ((,load-file-for-joshua ()
;	     ,@body))
;       (let ((,plist ,generic-pathname-plist))
;	 (when (locativep ,plist)
;	   (setf ,plist (location-contents ,plist)))
;	 (if (and (eq :joshua (getf ,plist :syntax))
;		  (cl:ecase ,operation
;		    (:load si:*delay-type-updating-while-loading-joshua-bins*)
;		    (:compile si:*delay-type-updating-while-compiling-joshua-code*)))
;	     (let-globally ((dw::*background-update-check-interval* (* 1000 60)))
;	       (flavor::with-pending-dw-updates
;		 (,load-file-for-joshua)))       
;	     (,load-file-for-joshua))))))
;
;;;; Hack the bin-loader do it wraps Joshua files with the above macro.
;si::
;(DEFUN BIN-LOAD-FILE-INTERNAL (STREAM INTO-PACKAGE NO-MSG-P)
;  (DECLARE (VALUES PATHNAME BINARY-TRUENAME))
;  ;; If we're loading a file, any type definitions up to now must be
;  ;; complete, so go ahead and finish them up.
;  (CLEANUP-BIN-LOAD-FUNCTIONS-TO-CALL)
;  (LET ((*FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE* NIL)
;	(*FUNCTIONS-TO-CALL-ON-BIN-LOAD-DONE-ENABLE* T))
;    (UNWIND-PROTECT
;	(LOADING-BIN-FILE (STREAM PATHNAME #'BIN-LOAD-NEXT-COMMAND)
;	  (LET* ((PACKAGE (PKG-FIND-PACKAGE (OR INTO-PACKAGE PACKAGE) ':ASK))
;		 (*BIN-LOAD-PACKAGE* PACKAGE)
;		 (FASL-STREAM STREAM)
;		 (FASLOAD-COMPILE-DATA (GET SI:FASL-GENERIC-PATHNAME-PLIST ':COMPILE-DATA)))
;	    (UNLESS (OR INTO-PACKAGE NO-MSG-P)
;	      (FORMAT T "~&Loading ~A into package ~A~%"
;		      (BIN-LOAD-PRETTY-PATHNAME PATHNAME) *BIN-LOAD-PACKAGE*))
;	    (LET* ((DUMPED-SOURCE-MODE-KEYWORD (GET SI:FASL-GENERIC-PATHNAME-PLIST ':MODE))
;		   (SOURCE-MODE
;		     (WHEN (VARIABLE-BOUNDP #'ZWEI:MAJOR-MODE-FROM-KEYWORD)
;		       (ZWEI:MAJOR-MODE-FROM-KEYWORD
;			 (OR DUMPED-SOURCE-MODE-KEYWORD :LISP) :SILENT))))
;	      (with-joshua-pending-dw-updates (SI:FASL-GENERIC-PATHNAME-PLIST :load)
;		(IF SOURCE-MODE
;		    (LOADING-FILE SI:FASL-GENERIC-PATHNAME-PLIST
;		      (SEND SOURCE-MODE ':LOAD-BINARY-FILE
;			    SI:FASL-GENERIC-PATHNAME-PLIST
;			    STREAM))
;		    (LOADING-FILE SI:FASL-GENERIC-PATHNAME-PLIST
;		      (BIN-LOAD-TOP-LEVEL STREAM)))))
;	    (SET-FILE-STREAM-LOADED-ID STREAM *BIN-LOAD-PACKAGE*))
;	  (VALUES PATHNAME (SEND STREAM :TRUENAME)))
;      (CLEANUP-BIN-LOAD-FUNCTIONS-TO-CALL))))
;
;;;; This takes care of compiling to a file or to core.
;compiler::
;(DEFUN COMPILE-FROM-STREAM (INPUT-STREAM GENERIC-PATHNAME *COMPILE-FUNCTION*
;			    ADDITIONAL-BINDINGS &KEY ((INITIALIZE-P INITIALIZE-P) T))
;  (MULTIPLE-VALUE-BIND (COMPILER-VARS COMPILER-VALS)
;      (GET-BINDINGS *COMPILER*)
;    (PROGV COMPILER-VARS COMPILER-VALS
;      ;; The next two variables have to be setup before entering compiler warnings context.
;      ;; Override the generic pathname
;      (LET ((FDEFINE-FILE-PATHNAME
;	      (LET ((PATHNAME (SEND INPUT-STREAM ':SEND-IF-HANDLES ':PATHNAME)))
;		(AND PATHNAME (SEND PATHNAME ':GENERIC-PATHNAME))))
;	    (SI:PATCH-SOURCE-FILE-PATHNAME NIL)
;	    (COMPILING-WHOLE-FILE-P (COMPILING-WHOLE-FILE-P INPUT-STREAM)))
;	(WHEN (AND COMPILING-WHOLE-FILE-P INITIALIZE-P)
;	  (RESET-FILE-WARNINGS FDEFINE-FILE-PATHNAME))
;	(COMPILER-WARNINGS-CONTEXT-BIND
;	  ;; Bind all the variables required by the file property list
;	  (MULTIPLE-VALUE-BIND (FVARS FVALS)
;	      (FS:FILE-ATTRIBUTE-BINDINGS
;		GENERIC-PATHNAME
;		:ADDITIONAL-ATTRIBUTES ADDITIONAL-BINDINGS)
;	    (STANDARD-VALUE-PROGV FVARS FVALS
;	      ;; Having bound the variables, process the file
;	      (LET* ((QC-FILE-IN-PROGRESS (FUNCALL *COMPILE-FUNCTION* ':COMPILER-TYPE))
;		     (QC-FILE-LOAD-FLAG (FUNCALL *COMPILE-FUNCTION* ':TO-CORE-P))
;		     (UNDO-DECLARATIONS-FLAG (NOT QC-FILE-LOAD-FLAG))
;		     (LOCAL-DECLARATIONS NIL)
;		     (OPEN-CODE-MAP-SWITCH OPEN-CODE-MAP-SWITCH)
;		     (RUN-IN-MACLISP-SWITCH RUN-IN-MACLISP-SWITCH)
;		     (OBSOLETE-FUNCTION-WARNING-SWITCH OBSOLETE-FUNCTION-WARNING-SWITCH)
;		     (ALL-SPECIAL-SWITCH ALL-SPECIAL-SWITCH)
;		     (QC-FILE-OLD-DEFAULT-CONS-AREA DEFAULT-CONS-AREA))
;		(UNWIND-PROTECT
;		    (si:with-joshua-pending-dw-updates ((if generic-pathname
;							    (send generic-pathname :plist)
;							    ADDITIONAL-BINDINGS)
;							:compile)
;		      (WHEN INITIALIZE-P
;			(FUNCALL *COMPILE-FUNCTION* ':INITIALIZE INPUT-STREAM
;				 GENERIC-PATHNAME))
;		      (PROCESS-FORMS-FROM-STREAM INPUT-STREAM 'COMPILE-FROM-STREAM-1
;						 (FUNCALL *COMPILE-FUNCTION* ':FOR-FILE)
;						 (FUNCALL *COMPILE-FUNCTION* ':CONS-AREA)))
;		  (FUNCALL *COMPILE-FUNCTION* ':FINALIZE
;			   INPUT-STREAM GENERIC-PATHNAME))))))))))

;;; --- seems not to be used but it's documented I think
ji::
(defmacro setf-carefully (place value)
  ;; on ivory rev 0 through 2, logic-variables have a bug whereby
  ;; they act like evcps.  doing this stuff prevents logic-variables
  ;; from getting totally smashed.
  `(si:%p-store-contents (follow-cell-forwarding (locf ,place) nil) ,value))


;=====================================
;(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
;(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:L-BIN;DUMP.LISP.164")
;(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
;  "-*- Syntax: Zetalisp; Mode: LISP; Package: SI; Base: 8 -*-")
;1;;;This one's OK - I think?
0;
;#+IMACH
;(DEFUN DUMP-I-COMPILED-FUNCTION (FUNCTION STREAM)
;  (WITH-STACK-LIST* (*DUMPING-COMPILED-FUNCTIONS* FUNCTION *DUMPING-COMPILED-FUNCTIONS*)
;    (ENTER-TABLE FUNCTION STREAM)
;    (SEND STREAM ':TYO BIN-OP-I-COMPILED-FUNCTION)
;    (MACROLET ((SEND-WORD (STREAM WORD)
;			  (ONCE-ONLY (WORD)
;			    `(PROGN (SEND ,STREAM :TYO (LDB (BYTE 16. 00.) ,WORD))
;				    (SEND ,STREAM :TYO (LDB (BYTE 16. 16.) ,WORD)))))
;	       (SEND-TAG (STREAM TAG &REST BITS)
;			 (LOOP WITH RESULT = 0
;			       FOR BIT IN BITS
;			       DOING
;			   (CL:ECASE BIT
;			     (:TYPE-FROM-TAG
;			       (SETF (LDB %%I-COMPILED-FUNCTION-TYPE-FROM-TAG RESULT) 1))
;			     (:IMMEDIATE (SETF (LDB %%I-COMPILED-FUNCTION-IMMEDIATE RESULT) 1))
;			     (:RELATIVE (SETF (LDB %%I-COMPILED-FUNCTION-RELATIVE RESULT) 1)))
;			       FINALLY
;				 (RETURN
;				   `(SEND ,STREAM :TYO
;					  ,(IF (ZEROP RESULT)
;					       TAG
;					       `(LOGIOR ,TAG ,RESULT)))))))
;      (LET* ((CCA (SYS:COMPILED-FUNCTION-CCA FUNCTION))
;	     (TOTAL-SIZE (CCA-TOTAL-SIZE CCA))
;	     (SUFFIX-SIZE (CCA-SUFFIX-SIZE CCA))
;	     (EXTRA-INFO (CCA-EXTRA-INFO-FOR-DEBUGGING CCA))
;	     (FDEFINITION-HINTS (CDR (ASSQ ':FDEFINITION-LOCATION-HINTS (CDR EXTRA-INFO)))))
;	(DUMP-OBJECT TOTAL-SIZE STREAM)
;	(DUMP-OBJECT SUFFIX-SIZE STREAM)
;
;	;; Dump extra-info needed by storage categories and area
;	(LET ((STORAGE-CATEGORY (CL:ASSOC 'SI:STORAGE-CATEGORY (CDR EXTRA-INFO)))
;	      (AREA (CL:ASSOC 'COMPILER:AREA (CDR EXTRA-INFO))))
;	  (DUMP-OBJECT (IF STORAGE-CATEGORY
;			   (IF AREA
;			       (LIST (FIRST EXTRA-INFO) STORAGE-CATEGORY AREA)
;			       (LIST (FIRST EXTRA-INFO) STORAGE-CATEGORY))
;			   (IF AREA
;			       (LIST (FIRST EXTRA-INFO) AREA)
;			       (LIST (FIRST EXTRA-INFO))))
;		       STREAM))
;
;	(FLET ((DUMP-LOCATIVE-REFERENCE (TAG LOCATIVE OFFSET FDEFINITION-HINTS STREAM)
;		 (SEND-TAG STREAM TAG :TYPE-FROM-TAG)
;		 ;; See if there are any hints about this
;		 (LET* ((PC (* 2 OFFSET))
;			(INDEX)
;			(REFERENCE
;			  (LOOP FOR (FSPEC . INDICES) IN FDEFINITION-HINTS
;				DOING
;			    (WHEN (CL:MEMBER PC INDICES)
;			      (RETURN FSPEC)))))
;		   (IF REFERENCE
;		       (IF (SETQ INDEX (CL:GETHASH LOCATIVE *BIN-DUMP-TABLE*))
;			   (COND ((< INDEX 1_14)
;				  (SEND STREAM ':TYO
;					(DPB BIN-OP-TABLE-FETCH-IMMEDIATE
;					     %%BIN-OP-HIGH INDEX)))
;				 ((< INDEX 1_20)
;				  (SEND STREAM ':TYO BIN-OP-TABLE-FETCH-MEDIUM)
;				  (SEND STREAM ':TYO INDEX))
;				 (T
;				  (SEND STREAM ':TYO BIN-OP-TABLE-FETCH-LARGE)
;				  (SEND STREAM ':TYO (LDB (BYTE 20 0) INDEX))
;				  (SEND STREAM ':TYO (LDB (BYTE 20 20) INDEX))))
;			   (PROGN
;			     (ENTER-TABLE LOCATIVE STREAM)
;			     (SEND STREAM :TYO BIN-OP-FDEFINITION-LOCATION)
;			     (DUMP-OBJECT REFERENCE STREAM)))
;		       (DUMP-OBJECT LOCATIVE STREAM)))))
;	  (LOOP FOR PTR FIRST (%MAKE-POINTER-OFFSET
;				DTP-LOCATIVE CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION))
;			THEN (%POINTER-PLUS PTR 1)
;		FOR OFFSET FROM 0 BELOW (- TOTAL-SIZE (DEFSTORAGE-SIZE COMPILED-FUNCTION))
;		DOING
;	    (LET* ((WORD (%MEMORY-READ PTR :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))
;		   (TAG (%TAG WORD)))
;	      ;; Immediate data
;	      (COND ((OR (TYPE-MEMBER WORD
;				      DTP-PACKED-INSTRUCTION-60 DTP-PACKED-INSTRUCTION-61
;				      DTP-PACKED-INSTRUCTION-62 DTP-PACKED-INSTRUCTION-63
;				      DTP-PACKED-INSTRUCTION-64 DTP-PACKED-INSTRUCTION-65
;				      DTP-PACKED-INSTRUCTION-66 DTP-PACKED-INSTRUCTION-67)
;			 (TYPE-MEMBER WORD
;				      DTP-PACKED-INSTRUCTION-70 DTP-PACKED-INSTRUCTION-71
;				      DTP-PACKED-INSTRUCTION-72 DTP-PACKED-INSTRUCTION-73
;				      DTP-PACKED-INSTRUCTION-74 DTP-PACKED-INSTRUCTION-75
;				      DTP-PACKED-INSTRUCTION-76 DTP-PACKED-INSTRUCTION-77)
;			 (TYPE-MEMBER WORD DTP-FIXNUM DTP-SINGLE-FLOAT DTP-SMALL-RATIO)
;			 (AND (TYPEP WORD :CHARACTER)
;			      (ZEROP (CHAR-LDB-INTERNAL %%CHAR-CHAR-SET WORD))
;			      (ZEROP (CHAR-LDB-INTERNAL %%CHAR-STYLE WORD))))
;		     ;; Immediate data
;		     (SEND-TAG STREAM TAG :IMMEDIATE :TYPE-FROM-TAG)
;		     (SEND-WORD STREAM (%POINTER WORD)))
;		    ((and (TYPE-MEMBER WORD
;				  DTP-EXTERNAL-VALUE-CELL-POINTER
;				  DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH)
;			  (NOT (UNBOUND-LOGIC-VARIABLE-P WORD)))
;		     (DUMP-LOCATIVE-REFERENCE
;		       TAG (%SET-TAG WORD DTP-LOCATIVE) OFFSET FDEFINITION-HINTS STREAM))
;		    ((TYPE-MEMBER WORD DTP-CALL-GENERIC-PREFETCH)
;		     (SEND-TAG STREAM TAG :TYPE-FROM-TAG)
;		     (DUMP-OBJECT (%MAKE-POINTER DTP-GENERIC-FUNCTION WORD) STREAM))
;		    ((TYPE-MEMBER WORD DTP-CALL-GENERIC)
;		     ;; This is a direct call generated by the linker.  Dump it as
;		     ;; an indirect call.
;		     (DUMP-LOCATIVE-REFERENCE
;		       ;;--- Need to parse code to determine the prefetch bit.
;		       (DPB DTP-CALL-INDIRECT %%Q-TYPE-WITHIN-TAG TAG)
;		       (FOLLOW-CELL-FORWARDING
;			 (FDEFINITION-LOCATION (GENERIC-FUNCTION-NAME
;						 (%SET-TAG WORD DTP-GENERIC-FUNCTION)))
;			 NIL)
;		       OFFSET FDEFINITION-HINTS STREAM))
;		    ;; See if this is a pointer into this function, as opposed to a
;		    ;; pointer elsewhere.  If this is the case, we have to dump a
;		    ;; relative pointer.
;		    ((AND (NOT (%POINTER-LESSP WORD FUNCTION))
;			  (%UNSIGNED-LESSP (%POINTER-DIFFERENCE WORD CCA) TOTAL-SIZE))
;		     (SEND-TAG STREAM TAG :RELATIVE :TYPE-FROM-TAG :IMMEDIATE)
;		     (SEND-WORD STREAM (%POINTER-DIFFERENCE WORD FUNCTION)))
;		    ((TYPE-MEMBER WORD DTP-CALL-COMPILED-EVEN
;				       DTP-CALL-COMPILED-ODD
;				       DTP-CALL-COMPILED-EVEN-PREFETCH
;				       DTP-CALL-COMPILED-ODD-PREFETCH)
;		     ;; Dump this as if it were a CALL-INDIRECT.
;		     ;; Note that this clause has to come after the relative pointer check
;		     ;; since the compiler generates direct calls within a compiled function.
;		     (DUMP-LOCATIVE-REFERENCE
;		       (DPB (IF (TYPE-MEMBER WORD DTP-CALL-COMPILED-EVEN DTP-CALL-COMPILED-ODD)
;				DTP-CALL-INDIRECT
;				DTP-CALL-INDIRECT-PREFETCH)
;			    %%Q-TYPE-WITHIN-TAG
;			    TAG)
;		       (LOCF (CCA-FUNCTION-CELL
;			       (COMPILED-FUNCTION-CCA
;				 (%FIND-STRUCTURE-HEADER WORD))))
;		       OFFSET FDEFINITION-HINTS STREAM))
;		    (T
;		      (SEND-TAG STREAM TAG)
;		      (DUMP-OBJECT WORD STREAM))))))))))

;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:SYS;COMMAND-LOOP.LISP.167")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: Lisp; Package: System-Internals; Base: 8 -*-")

;;; Keep set * from messing with l-v's 
(DEFUN SET-VALUE-FOR-* (NEW-*)
  (MACROLET ((SET (PLACE VALUE)
	       #+3600
	       `(SETQ ,PLACE ,VALUE)
	       #+IMACH
	       ;; On Ivory Rev 0 through 2, logic-variables have a bug whereby
	       ;; they act like EVCPs.  Doing this stuff prevents logic-variables
	       ;; from getting totally smashed.
	       `(LET* ((LOCATION (FOLLOW-CELL-FORWARDING (LOCF ,PLACE) NIL))
		       (TYPE (%P-DATA-TYPE LOCATION)))
		  ;; Check for either type just for paranoia.
		  (IF (or (= TYPE DTP-EXTERNAL-VALUE-CELL-POINTER)
			  (= TYPE DTP-LOGIC-VARIABLE))
		      (%P-STORE-CONTENTS (LOCF ,PLACE) ,VALUE)
		    (SETQ ,PLACE ,VALUE)))))
    (SET *** **)
    (SET **  *)
    (SET *   NEW-*)))


;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:GPRINT;GPRINT.LISP.55")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-")


;;; Enqueue.

;;; enqueue is called by the code generated from the formatting strings.
;;; type is a keyword symbol saying what to do.  object is an argument,
;;; whose meaning depends on type (see comments at defstruct of queue).
;;; State variables:
;;; *enqueued-size* is the total sizes of all :princ, :prin1, :special, 
;;; and :space commands in the queue from 0 to the *queue-in* pointer.
;;; *dequeued-size* is the same from 0 to the *queue-out* pointer, so their
;;; difference is the total size of what's waiting in the queue to be printed.
;;; Note: *queue-in* is always > *queue-out*; the queue is not "circular".
1;;; We think this is still OK
0#+imach
(defun enqueue (type object &aux size)
  ;; Compute the size.
  (setq size (case type
	       (:start nil)		;Don't know the size yet.
	       (:newline		;For :block or :initial, don't know yet.  Else unused.
		(if (member object '(:block :initial)) nil 0))
	       ((:prin1 :prin1-lv)
		 (let ((*print-pretty* nil)
		       (*print-circle* nil));finding size doesn't count as printing
		   ;; Compute size, with slashes.
		   (bounded-flatsize (case type
				       (:prin1 object)
				       (:prin1-lv (car object))) *total-line-length*)))
	       ((:princ :princ-lv)			;Compute size, without slashes.
		(let ((*print-pretty* nil)
		      (*print-circle* nil)) ;finding size doesn't count as printing
		  (bounded-flatc (case type
				       (:princ object)
				       (:princ-lv (car object))) *total-line-length*)))
	       (:special (string-length object))
	       (:space object)		;The argument is the size.
	       ((:ind :end :tab :eval
		 :sensitivity-ellipsis-start :sensitivity-ellipsis-end
		 :sensitivity-expression-start :sensitivity-expression-end) 0)	;Unused.
	       (otherwise (error "~S is not a known type" type))))
  ;; Fill in the queue entry.
  (setf (queue-type *queue-in*) type)
  (setf (queue-object *queue-in*) object)
  (setf (queue-size *queue-in*) size)
  ;; Do special processing for :start and :end.
  (case type
    (:start
     ;; Push a new entry on the enqueueing stack.
     (let ((old-level (eqs-level *eqs-ptr*)))
       (push-eqs)
       (setf (eqs-queue-ptr *eqs-ptr*)	;Save pointer to corresponding queue entry.
	     *queue-in*)
       (setf (eqs-level *eqs-ptr*)	;Current level for prinlevel checks.
	     (if (equal object 0) old-level (1+ old-level)))
       (setf (eqs-length *eqs-ptr*) 0)	;Start counting length for prinlength checks.
       (setf (eqs-saved-size *eqs-ptr*)	;Saved *enqueued-size* to compute structure's size.
	     *enqueued-size*)))
    (:end
     (let ((queue-ptr (eqs-queue-ptr *eqs-ptr*)))
       (unless (minusp queue-ptr)
	 ;; The :start entry is still in the queue.  We now know the structure's size.
	 (setf (queue-size queue-ptr)
	       (setq size (- *enqueued-size* (eqs-saved-size *eqs-ptr*))))
	 (update-sizes queue-ptr size)))	;Propagate the size to waiting newlines.
     ;; Pop the entry from the enqueueing stack.
     (pop-eqs)))
  ;; Update the total size.
  (when (member type '(:princ :prin1 :princ-lv :prin1-lv :special :space))
    (incf *enqueued-size* size))
  ;; If this is a real Lisp object, count it against the eqs-length.
  (when (member type '(:princ :prin1 :princ-lv :prin1-lv :end))
    (incf (eqs-length *eqs-ptr*)))
  ;; If we now know the size of the stuff between two newline-points, propagate
  ;; the size of that stuff back to the earlier newline-point.
  (when (eq type ':newline)
    (update-sizes *queue-in* 0))
  (push-queue)
  (setq *queue-max* (max *queue-max* *queue-in*))

  ;; Now try to dequeue any entries that are ready to be printed.
  (loop while (< *queue-out* *queue-in*) do
	(cond ((not (null (queue-size *queue-out*)))
	       ;; The size of the item is known; print it.
	       (print-out))
	      ((or (and (eq type ':newline) (eq object ':always))
		   (> (- *enqueued-size* *dequeued-size*) *total-line-length*))
	       ;; Either a forced newline is upon us, or there's more stuff in the
	       ;; queue than fits on a line.  Don't bother to wait to compute the size,
	       ;; just print it, preceded by a newline if possible.
	       (setf (queue-size *queue-out*) #o7777777)
	       (print-out))
	      (t
	       ;; It's not time yet; stop trying to dequeue.
	       (return)))
	;; The top item has been printed out.  Add to *dequeued-size* and get rid of the item.
	(when (member (queue-type *queue-out*) '(:princ :prin1 :princ-lv :prin1-lv :special :space))
	  (incf *dequeued-size* (queue-size *queue-out*)))
	(incf *queue-out* *queue-size*))

  ;; If the queue was left empty, reset pointers.  Invalidate all existing eqs-queue-ptrs.
  ;; Otherwise if the queue is more than half empty, garbage collect it.
  (cond ((= *queue-in* *queue-out*)
	 (setq *queue-in* 0
	       *queue-out* 0
	       *enqueued-size* 0
	       *dequeued-size* 0)
	 (loop for i from 0 to *eqs-ptr* by *eqs-size* do
	   (setf (eqs-queue-ptr i) -1)))
	((> (* *queue-out* 2) *queue-in*)
	 (loop for i from 0 to *eqs-ptr* by *eqs-size* do
	   (decf (eqs-queue-ptr i) *queue-out*))
	 (replace *queue* *queue* :start2 *queue-out* :end2 *queue-in*
		  :end1 (- *queue-in* *queue-out*))
	 (decf *queue-in* *queue-out*)
	 (setq *queue-out* 0))))

;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:GPRINT;GPRINT.LISP.55")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-")


;;; Now that we know the size of the queue entry pointed to by ptr, go back
;;; the queue to find any :newline/:block entries right before us and set
;;; their queue-size from it.  Do not back up over a :start, which has its
;;; own handling of size propagation.

(defun update-sizes (ptr size)
  (loop until (< (decf ptr *queue-size*) *queue-out*)
	do (case (queue-type ptr)
	     ((:princ :prin1 :princ-lv :prin1-lv :special :eval :space
	       :sensitivity-ellipsis-start :sensitivity-ellipsis-end
	       :sensitivity-expression-start :sensitivity-expression-end)
	      (incf size (queue-size ptr)))
	     ((:newline)
	      (when (eq (queue-object ptr) ':block)
		(setf (queue-size ptr) size))
	      (return nil))
	     ((:end :ind))
	     (otherwise (return nil)))))

;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:GPRINT;GPRINT.LISP.55")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-")


;;; print-out is called from enqueue.  It prints out the queue item pointed
;;; to by *queue-out*.  The caller is responsible for actually updating *queue-out*.
;;; State variables:
;;; *depth* is normally zero.  It becomes positive when we are inside a list that
;;; completely fits on the current line; its value is the depth in such lists.
;;; The best way to understand this crucial state variable is to notice that it controls
;;; whether :newline/:normal will cause a new line or not.  While *depth* is
;;; positive, print-out mostly doesn't do anything except simply print out items
;;; on the current line and watch for it to become zero again.
;;; *went-up* means that there was a :end on this physical line; that is, we have
;;; gone up out of list structure while printing this line.
;;; *pending* is the number of pending spaces; they only get actually printed if
;;; there's something to come after them before the line ends.
;;; *pending-newline* is a flag meaning that a newline is pending, again only
;;; if something will actually come after it.
;;; *line-number* is the count of lines printed, for *print-start/end-line*.
;;; *free* is the number of free character positions left on this line.
;;; *line-length* is the total length of a line, and so (- *line-length *free*)
;;; is the number of characters that have already been printed on this line.
;;; *total-line-length* is the total length of a line, including the left
;;; margin.  The :newline :initial queue entry will cause a newline if the
;;; left margin is so large that it's forcing the text to be crammed to the
;;; right too much.

(defun print-out ()
  (let ((type (queue-type *queue-out*))
	(object (queue-object *queue-out*))
	(size (queue-size *queue-out*)))
    ;; First decide whether this item puts us onto a new line.
    (when (and (zerop *depth*)		;If *depth* > 0, it all fits, so no newline.
	       (or (and (eq type ':newline)
			(case object
			  ((:always :normal) t)
			  (:miser (miser-mode-p))
			  (:block
			   (or *went-up*
			       (and (< (dqs-pending-indent *dqs-ptr*)
				       (- *line-length* *free*))
				    (> size *free*))))
			  (:initial
			    ;; Putting in this newline would cause the stuff queued so far
			    ;; to take two lines, plus however many mandatory newlines it
			    ;; contains.  If the last item would cause overflow onto
			    ;; an additional line, it is not counted.
			    ;; Estimate the number of lines that the queued stuff would
			    ;; take without this newline.  There are some approximations
			    ;; here, but it should be close enough.  If it's at least two
			    ;; more lines than with this newline, put in this newline.
			    ;; This is a heuristic; to decide for sure would require
			    ;; infinite lookahead.  Assuming :newline :normal does the
			    ;; same thing on both passes is another heuristic approximation.
			    ;; Also put in the newline if not doing so would cause a long
			    ;; symbol to overflow the right margin.
			    (flet ((lookahead (line-length limit)
				    (declare (values n-lines limit line-overflow))
				    (loop for ptr from *queue-out* by *queue-size* below limit
					  with size = 0 with ind = 0 with n-lines = 1
					  with possible-newline = nil
					  with line-overflow = nil with allow-newline = nil
					  with went-up = nil with depth = 0
					  with *dqs-ptr* = *dqs-ptr*
					  until (> size *total-line-length*)
					  finally
					    ;; Don't force a newline when printing an atom
					    ;; (actually when no newline could occur within
					    ;; the text), because too many uses of PRINC
					    ;; (or ~A) depend on newlines not being inserted.
					    (unless allow-newline
					      (setq line-overflow nil))
					    (return (values n-lines ptr line-overflow))
					  as qsize = (queue-size ptr) do
				     (case (queue-type ptr)
				      ((:princ :prin1 :princ-lv :prin1-lv :special :eval :space
					:sensitivity-ellipsis-start :sensitivity-ellipsis-end
					:sensitivity-expression-start
					:sensitivity-expression-end)
				       (incf size qsize)
				       (when (> size line-length)
					 ;; Allow for crock below that sometimes newlines
					 (cond ((and (zerop depth)
						     (member (queue-type ptr)
							     '(:princ :prin1 :princ-lv :prin1-lv :special))
						     (> size line-length)
						     ( (+ ind qsize) line-length))
						(setq size (+ ind qsize))
						(incf n-lines)
						(setq went-up nil))
					       ((not possible-newline)
						;; Would overflow right margin if initial
						;; newline omitted, and there are no
						;; :newline :blocks of unresolved size,
						;; so force a newline at the front.
						(setq line-overflow t)))))
				      (:start
				       (cond ((and (zerop depth)
						   (or (null qsize)
						       (> (+ qsize size) line-length)))
					      (push-dqs)
					      (setf (dqs-pending-indent *dqs-ptr*) ind)
					      (setq ind size)
					      (unless (< (+ size *miser-width*) line-length)
						(incf ind)))
					     (t (incf depth))))
				      (:ind
				       (when (and (zerop depth)
						  (< (+ size *miser-width*) line-length))
					 (incf ind (or (queue-object ptr)
						       (let ((*queue-out* ptr))
							 (get-indentation)))))
				       ;; Crock for one-element list -- without this,
				       ;; if it runs off the right margin, a newline
				       ;; would be inserted before the close parenthesis
				       (setq allow-newline t))
				      (:end
				       (cond ((zerop depth)
					      (setq ind (dqs-pending-indent *dqs-ptr*))
					      (pop-dqs)
					      (setq went-up t))
					     (t (decf depth))))
				      (:newline
				       (unless (eq (queue-object ptr) ':initial)
					 (setq allow-newline t))
				       (when (zerop depth)
					 (when (case (queue-object ptr)
						 ((:always :normal) t)
						 (:miser ( (+ ind *miser-width*)
							    line-length))
						 (:block
						  (cond (went-up)
							((null qsize)
							 ;; Assuming it's too big to fit gives
							 ;; better results than assuming small
							 (setq possible-newline t)
							 (< ind size))
							(t (and (< ind size)
								(> (+ size qsize) line-length)
								)))))
					   (setq size ind)
					   (incf n-lines)
					   (setq went-up nil))))))))
			      (multiple-value-bind (n-long-lines limit)
				  (lookahead *total-line-length* *queue-in*)
				(multiple-value-bind (n-short-lines nil line-overflow)
				    (lookahead *line-length* limit)
				  (cond ((or ( n-short-lines (+ n-long-lines 2))
					     line-overflow)
					 ;; Put in the extra newline
					 (setq *left-margin* (or *overriding-left-indent* 0)
					       *line-length* *total-line-length*)
					 t)
					(t
					 ;; Do not put in the extra newline.  Don't need extra
					 ;; lookahead any more so decrease *total-line-length*
					 (setq *total-line-length* *line-length*)
					 nil))))))))
		   ;; Put a newline before this item if we have a succession of close
		   ;; parentheses that would run off the end of the line or we are printing
		   ;; a really long atom that would run off the end of the line if printed
		   ;; in its normal position.  Only do this if it buys something, of course.
		   (and (member type '(:princ :prin1 :princ-lv :prin1-lv :special))
			(> size *free*)
			( (+ (dqs-pending-indent *dqs-ptr*) size)
			   *line-length*))
		   ))
      ;; Yes, this entry puts us onto a new line.
      (setq *pending-newline* t)
      (setq *pending* (dqs-pending-indent *dqs-ptr*))
      (setq *free* (- *line-length* *pending*))
      (setq *went-up* nil))
    ;; Process the item, according to its type.
    (case type
      (:start
       (incf *print-out-level*)
       (cond ((and (zerop *depth*) (> size *free*))
	      ;; This substructure doesn't fit either, so keep *depth* zero.
	      ;; Push an entry on the dequeueing stack.
	      (push-dqs)
	      (setf (dqs-pending-indent *dqs-ptr*)	;Save current indentation level
		    (- *line-length* *free*))
	      (when (miser-mode-p)	;:ind is ignored in miser mode; just use 1 instead.
		(incf (dqs-pending-indent *dqs-ptr*)))
	      (setf (dqs-tab-size *dqs-ptr*) -1))
	     (t (incf *depth*))))
      (:ind
       (when (and (zerop *depth*)		;There's no queue entry if *depth* > 0.
		  (not (miser-mode-p)))		;:ind is ignored in miser mode.
	 (setf (dqs-pending-indent *dqs-ptr*)
	       (max (+ (dqs-pending-indent *dqs-ptr*)
		       (or object (get-indentation)))
		    0))))
      (:end
       (decf *print-out-level*)
       (cond ((zerop *depth*)
	      (setq *went-up* t)
	      (pop-dqs))
	     (t (decf *depth*))))
      ((:sensitivity-ellipsis-start :sensitivity-expression-start)
       (setq *pending-sensitivity-type* type
	     *pending-sensitivity-object* object))
      ((:sensitivity-ellipsis-end :sensitivity-expression-end)
       (case type
	 (:sensitivity-expression-end
	   (funcall *inspecting* :end :location object))
	 (:sensitivity-ellipsis-end
	   (funcall *inspecting* :end :location object :type 'expression-length-ellipsis))))
      ((:princ :prin1 :special :eval :princ-lv :prin1-lv)
       ;; The time has come to actually print something.
       ;; If there is a pending newline, do it.
       (when *pending-newline*
	 (when ( *line-number* *print-end-line*)	;If passed end-line, quit.
	   (throw 'finished nil))
	 (when ( *line-number* *print-start-line*)	;If printing not suppressed,
	   (write-char #\Return *stream*)
	   (incf *pending* *left-margin*))
	 (incf *line-number*)
	 (setq *pending-newline* nil))
       ;; If there are pending spaces, do them.
       (when ( *line-number* *print-start-line*)	;If printing not suppressed,
	 (let ((to-go *pending*))
	   (loop while (> to-go 0) do
	     (cond ((= to-go 1)
		    (write-char #\Space *stream*)
		    (decf to-go))
		   (t
		    (let ((n (min 100 to-go)))
		      (write-string #.(make-array 100 :element-type 'string-char
						  :initial-element #\space)
				    *stream* :start 0 :end n)
		      (decf to-go n)))))))
       (setq *pending* 0)
       ;; If there is pending presentation start, start it now.
       (when *pending-sensitivity-type*
	 (ecase *pending-sensitivity-type*
	   (:sensitivity-expression-start
	     (funcall *inspecting* :start :location *pending-sensitivity-object*))
	   (:sensitivity-ellipsis-start
	     (funcall *inspecting* :start :location *pending-sensitivity-object*
		      :type 'expression-length-ellipsis)))
	 (setq *pending-sensitivity-type* nil))
       ;; Now actually do it.
       (cond ((eq type ':eval)
	      (eval object))
	     (( *line-number* *print-start-line*)	;If printing not suppressed,
	      (case type			; do what prin1 or princ would do
		(:prin1				; in non-pretty, non-circle case
		  (simple-print-object object t *stream*))
		(:prin1-lv				; in non-pretty, non-circle case
		  (simple-print-object (car object) t *stream*))
		(:princ
		 (simple-print-object object nil *stream*))
		(:princ-lv
		 (simple-print-object (car object) nil *stream*))
		(:special
		  ;; Send single-character strings out with :tyo, which saves some
		  ;; time on dynamic windows compared with sending them via :string-out,
		  ;; for instance it does one less :read-cursorpos
		  ;; Making these objects characters instead of strings in the first
		  ;; place would be better, but more difficult
		  ;; Use array-total-size because it compiles as an instruction
		  (if (= (array-total-size object) 1)
		      (send *stream* :tyo (aref object 0))
		      (send *stream* :string-out object))))))
       (decf *free* size))
      (:space
       (when (minusp object)			;Limit negative spaces to undo pending space.
	 (setq object (max (- *pending*) object)))
       (incf *pending* object)
       (decf *free* object))
      (:tab
       (when (and (zerop *depth*)
		  (not *pending-newline*))
	 (let* ((tab (cond (object)		;Tab size explicitly supplied.
			   ((not (minusp (dqs-tab-size *dqs-ptr*)))
			    ;; Not supplied.  If computed for this level, use it.
			    (dqs-tab-size *dqs-ptr*))
			   (t
			    ;; Not computed yet.  Compute it, save it, and use it.
			    (setf (dqs-tab-size *dqs-ptr*) (estimate-tab-size))
			    (dqs-tab-size *dqs-ptr*))))
		(offset (mod (- (- *line-length* *free*)
				(dqs-pending-indent *dqs-ptr*))
			   tab)))
	   (when (not (zerop offset)) (setq offset (- tab offset)))
	   (incf *pending* offset)
	   (decf *free* offset)))))))


;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:GPRINT;GPRINT.LISP.55")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-")


;;; This computes the pending-indent for a level when it is not explicitly specified.
;;; Go over the queue, adding up the width of everything up to the first :prin1 or
;;; :princ, and any :space after it.  In the usual case, if you just use () in your
;;; control string, the indentation defaults to the sum of the lengths of the open
;;; paren, the first item in the list, and any blank space after it.  Note that
;;; if there isn't enough stuff queued up, the answer will be too small, but this 
;;; only happens when you're printing up against the right margin.

(defun get-indentation ()
  (let ((indent 0)
	(found-print nil))
    (loop for i from *queue-out* below *queue-in* by *queue-size* do
	  (case (queue-type i)
	    ((:prin1 :princ :princ-lv :prin1-lv)
	     (when found-print (return))
	     (setq found-print t)
	     (incf indent (queue-size i)))
	    (:space
	     (incf indent (queue-size i)))
	    (:special
	     (when found-print (return))
	     (incf indent (queue-size i)))))
    indent))


;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:GPRINT;GPRINT.LISP.55")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-")


;;; This function takes a Lisp object and decides what to do with it.  Basically,
;;; it enqueues objects, and so the queue has to be ready to run at the time this
;;; is called.  If it sees a list, its action depends on whether suggested-format
;;; is provided.  If suggested-format is nil, it assumes the object is a Lisp form
;;; and uses the car to figure out what to do.  If suggested-format is not nil, it
;;; should be a function, and it is applied to the list to handle it.  There are also
;;; the various lists of hooks above that let you control what goes on inside here.
;;; This function also does print-level checking and calls the inspector hook function.

(defun gdispatch (suggested-format object)
  (let ((locative *locative*) (*locative* nil)	;New level for inspector.
	(basic-printer #|*basic-printer*|# (if *print-escape* :prin1 :princ))
	(depth-exceeded? ( (eqs-level *eqs-ptr*) *actual-print-level*))
	entry)
    (cond ((and *print-circle*
		(progn (setf entry (find-in-duplicates-table object))
		       (duplicate-entry-p entry)))
	   (if (printed-duplicate-entry-p entry)
	       (let ((*print-base* 10.))
		 (with-sensitivity ()
		   (gformat "'#'*'#'" (- entry)))
		 (return-from gdispatch nil))
	       (progn (set-printed-duplicate-entry object entry)
		      (let ((*print-base* 10.))
			(gformat "'#'*'='" entry))))))
    (cond ((and (null depth-exceeded?)
		(loop for fn in *special-formatters* do
		  (when (funcall fn object) (return t))))
	   ;; Try special formatters.  If any return t, done.
	   nil)
	  ((or (symbolp object) (numberp object) (stringp object) (bit-vector-p object))
	   ;; Simple atom, just enqueue it.
	   (with-sensitivity ()
	     (enqueue basic-printer object)))
	  ((consp object)
	   (with-sensitivity ()
	     (cond (depth-exceeded?
		    (enqueue :princ "#"))
		   ((loop for fn in *overriding-list-formatters*
			  thereis (funcall fn object))
		    ;; First the overriding list formatters get their chance at the object.
		    nil)
		   ((and (plusp *gprint-backquote-depth*)
			 (assoc (first object) *readable-backquote-formatters*))
		    (funcall (second (assoc (first object) *readable-backquote-formatters*))
			     object))
		   ((not (null suggested-format))
		    ;; If a suggested-format was provided, it takes over.
		    (funcall suggested-format object))
		   ((loop for fn in *list-formatters* thereis (funcall fn object))
		    ;; Next the regular list formatters get their chance.
		    nil)
		   (t
		    (let ((first (first object)))
		      (funcall		;Find a function to call on the list.
			(cond ((symbolp first)
			       (cond ((get first 'formatter))
				     ((fboundp first) *function-formatter*)
				     (t *symbol-car-formatter*)))
			      ((and (listp first)
				    (member (car first)
					  '(lambda zl:named-lambda zl:subst zl:named-subst)))
			       *lambda-combination-formatter*)
			      (t *non-symbol-car-formatter*))
			object))))))
	  ((named-structure-p object)
	   (with-sensitivity ()
	     (if depth-exceeded?
		 (enqueue :princ "#")
		 (let* ((name (named-structure-symbol object))
			(operations (and (symbolp name) (get name 'named-structure-invoke)
					 (named-structure-invoke object
								 :which-operations))))
		   (cond ((member :format-self operations)
			  (named-structure-invoke object :format-self *stream*))
			 ((member :print-self operations)
			  ;; :PRINT-SELF overrides #S.
			  (enqueue basic-printer object))
			 ((and (symbolp name)
			       (get name 'si:defstruct-description)
			       (or si:print-readably *print-structure-contents*))
			  (format-structure-contents
			    (list*
			      name
			      (loop for (slot . plist)
					in (si:defstruct-description-slot-alist
					     (get name 'si:defstruct-description))
				    collect (intern (symbol-name slot) "")
				    collect
				      (eval `(,(si:defstruct-slot-description-ref-macro-name
						 plist)
					      ',object))))))
			 (t (enqueue basic-printer object)))))))
	  ((instancep object)
	   (with-sensitivity ()
	     (cond (depth-exceeded? (enqueue :princ "#"))
		   ((operation-handled-p object ':format-self)
		    (send object ':format-self *stream*))
		   (t (enqueue basic-printer object)))))
	  ((and (arrayp object)
		*print-array*
		(or (null *print-array-length*)
		    (> *print-array-length* (zl:array-active-length object))))
	   (with-sensitivity ()
	     (if depth-exceeded?
		 (enqueue :princ "#")
		 (loop for fn in *array-formatters* do
		   (when (funcall fn object) (return))
		       finally (format-array object)))))
	  #+imach
	  ((type-member object sys:dtp-external-value-cell-pointer)
	   (with-sensitivity ()
	     (let ((lv-basic-printer (case basic-printer
				       (:princ :princ-lv)
				       (:prin1 :prin1-lv))))
	       (enqueue lv-basic-printer (list object)))))
	  (t
	   (with-sensitivity ()
	     (enqueue basic-printer object))))))


;=====================================
(SYSTEM-INTERNALS:BEGIN-PATCH-SECTION)
(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE "SYS:GPRINT;GPRINT.LISP.55")
(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: GPrint; Syntax: Common-Lisp; Lowercase: Yes -*-")
1;;; Looks plausable

0(defun print-object (object &optional suggested-format (stream *standard-output*)
				      (recursive nil))
  (let ((dbg:*printing-monitor-message* dbg:*inhibit-monitoring-during-print*)
	(full-gprint nil))
    (condition-bind
        ((error #'(lambda (condition)
		    (condition-case ()
			 ;; Normal printing method got an error.  If appropriate
			 ;; substitute a default printed representation similar
			 ;; to what PRINT-RANDOM-OBJECT prints.  But if that
			 ;; gets an error (maybe the stream is dead), go back
			 ;; to signalling the original error.
			 ;; Do this on interactive streams, so we can inspect and
			 ;; debug busted objects, but don't do it on non-interactive
			 ;; streams, where we would rather be able to debug the error.
			 (unless si:*print-error*
			   (when (send stream :interactive)
			     (unless (typep condition 'print-not-readable)
			       (let ((si:*print-error* t))
				 (when full-gprint (flush-queue))
				 (printing-random-object (object stream)
				   (si:print-raw-string "Error printing object " stream)
				   (si:print-raw-string
				     (string (or (si:allow-recursive-wired-ferror
						   (ignore-errors (type-of object)))
						 (data-type object)))
				     stream))
				 ;; Make sure the stream is really working
				 (send stream :force-output)
				 (return-from print-object object)))))
		       (error
			 ;; Error while printing the substitute p.r., give up
			 (setq si:*print-error* t)
			 nil)))))

      ;; Give the stream a chance to handle it (e.g. for mouse-sensitivity)
      (unless (and (not recursive)
		   (send-if-handles stream :gprint object suggested-format stream))

	;; If gdispatch isn't going to do anything, avoid the setup overhead
	;; This assumes *special-formatters* isn't going to do anything with these objects
	(cond (*locative*)
	      ((symbolp object)
	       (return-from print-object
		 (si:print-pname-string object *print-escape* stream)))
	      ((numberp object)
	       (return-from print-object
		 (typecase object
		   (fixnum (si:print-fixnum-or-bignum object stream))
		   (single-float (si:print-flonum object stream))
		   #+3600
		   (otherwise (si:print-extended-number object stream nil 0 nil))
		   #+IMACH
		   (bignum (si:print-fixnum-or-bignum object stream))
		   #+IMACH
		   (rational (si:print-rational object stream))
		   #+IMACH
		   (complex (si:print-complex object stream))
		   #+IMACH
		   (double-float (si:print-flonum object stream)))))
	      ((and (arrayp object)
		    (let ((object (follow-structure-forwarding object)))
		      (and (= (%p-data-type object) dtp-header-i)
			   (= (%p-ldb %%header-type-field object) %header-type-array)))
		    (not (named-structure-p object))
		    (or (stringp object) (bit-vector-p object)))
	       (return-from print-object
		 (si:print-array-contents object 0 *print-escape* stream nil nil)))
	      
	      #+imach
	      ((type-member object sys:dtp-external-value-cell-pointer)
	       (return-from print-object
		 (si:print-object object 0 *print-escape* stream nil nil))))

	(using-resource (*queue* queues)
	  (using-resource (*eqs* stacks)
	    (using-resource (*dqs* stacks)
	      (let* ((*stream* stream)
		     ;; Queue pointers and stack pointers.
		     (*queue-in* 0) (*queue-out* 0) (*queue-max* 0)
		     (*eqs-ptr* 0) (*dqs-ptr* 0)
		     ;; State variables for enqueue and print-out.
		     (*enqueued-size* 0) (*dequeued-size* 0)
		     (*depth* 0) (*went-up* nil)
		     (*pending* 0) (*pending-newline* nil)
		     (*pending-sensitivity-type* nil) (*pending-sensitivity-object* nil)
		     (*actual-print-length* (if (eq recursive ':print-self)
						*actual-print-length*
						(or *print-length* most-positive-fixnum)))
		     (*actual-print-level* (if (eq recursive ':print-self)
						*actual-print-level*
						(or *print-level* most-positive-fixnum)))
		     (*print-out-level* 0)
		     (*line-number* 0)
		     (*left-margin*
		       (or *overriding-left-indent*
			   (send-if-handles *stream* :read-cursorpos :character)
			   0))
		     (*total-line-length*
		       (or *overriding-line-length*
			   (send-if-handles *stream* :size-in-characters)
			   95.))
		     (*line-length*
		       (- *total-line-length* *left-margin*))
		     (*free* *line-length*)
		     (*print-pretty* (not (null *print-pretty*))))

		;; Interpret formatting specification
		(etypecase suggested-format
		  (boolean
		    (setq suggested-format nil))
		  (keyword
		    (setq suggested-format (eval
					     (second
					       (assoc suggested-format
						      *standard-formatters*))))
		    ;; Format subexpressions as data too
		    (when (and *print-pretty* (neq suggested-format :code))
		      (setq *print-pretty* :data)))
		  (function ))

		;; Set up the zero-entries of the enqueueing and dequeueing stacks.
		(setf (eqs-queue-ptr 0) -1)
		(setf (eqs-level 0) 0)
		(setf (eqs-length 0) 0)
		(setf (eqs-saved-size 0) 0)
		(setf (dqs-tab-size 0) -1)
		(setf (dqs-pending-indent 0) 0)
		(catch 'finished
		  (setq full-gprint t)
		  (cond ((eq recursive ':print-self)
			 (gdispatch suggested-format object)
			 (setq full-gprint nil)
			 (flush-queue))
			(t
			 (with-circular-printer-tables
			   (when *print-circle* (find-duplicates object))
			   (unless (zerop *left-margin*)
			     (enqueue :newline :initial))
			   (gdispatch suggested-format object)
			   (setq full-gprint nil)
			   (flush-queue))))
		  (when (or (not (zerop *eqs-ptr*)) (not (zerop *dqs-ptr*)))
		    (error "Not enough }s in formatting string")))
		(si:fill-array *queue* *queue-max* nil)	;Don't hold onto garbage
		)))))
    object)))

