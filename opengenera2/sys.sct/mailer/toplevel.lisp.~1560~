;;; -*- Mode: Lisp; Package: Mailer; Base: 10.; Syntax: Zetalisp; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Process top levels

0(defvar (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")receipt-process-count0)
(defvar 2receipt-process-time0)
(define-interval-60 2receipt-process-timeout0 "10 seconds")
(define-interval-60 2receipt-process-blast-timeout0 "10 minutes")

1;; When any mail receipt processes are running, don't run any of the other mailer processes.
;; This provides faster mail service since the receipt processes don't have to compete with
;; the other processes for resources.  This also keeps the entries in the log in the correct
;; order, since messages are entered into the incoming and outgoing queues before log entries
;; are made.  And finally, this is called while halting the mailer.  No receipt process should
;; take longer than ten seconds to run.  If one has, then it is probably talking to a slow
;; host, or the other side of the connection went away and this side didn't notice, so stop
;; waiting and do something else.  If a receipt process takes more than ten minutes to run,
;; then the other host is keeping the connection open and not doing anything, so assume the
;; process is dead.

;; This should be extended to maintain a database of all the receipt processes for the case of
;; halting the mailer.  If the receipt process hasn't returned after RECEIPT-PROCESS-TIMEOUT,
;; then the process should be blasted so that the mailer can be brought down.

;; [This code is not being used now since it was diked out when the mail-access-paths were installed.
;; i.e. receipt-process-count is never incremented, so the process-wait function never waits
;; and the body is never executed.  See Q:>sys>mailer>servers.lisp for the old code.]

0(defun 2receipt-process-wait0 (&optional (whostate "Receipt Process Wait"))
  (process-wait whostate
		#'(lambda () (or (zerop receipt-process-count)
				 (> (- (time) receipt-process-time) receipt-process-timeout))))
  (let (count time)
    (cond ((zerop receipt-process-count))
	  ((without-interrupts
	     (and (> (- (time) receipt-process-time) receipt-process-timeout)
		  (setq count receipt-process-count)
		  (setq time receipt-process-time)))
	   (receipt-process-note "slow" count time))
	  ((without-interrupts
	     (and (> (- (time) receipt-process-time) receipt-process-blast-timeout)
		  (setq count receipt-process-count)
		  (setq time receipt-process-time)
		  (setq receipt-process-count 0)))
	   (receipt-process-note "dead" count time)
	   (su:log-event :normal "Setting receipt process count back to zero")))))

(defun 2receipt-process-note0 (type count time)
  (su:log-event :normal "Found ~D ~A receipt process~:[es~;~]; last receipt activity was ~\TIME-INTERVAL\ ago"
	count type (= count 1) (// (- (time) time) 60.)))

1;; Per-process information maintained by the Mailer

0(defstruct (2process-info0 :named (:conc-name pi-))
  process           ; actual process associated with this structure
  description       ; short string describing process, e.g. "foreground"
  command-queue)

(defstruct (2process-command0 :named (:conc-name pc-))
  command
  commanding-process)

1;; alist mapping processes to their process-info structures
0(defvar 2*process-info*0 nil)

1;; Describing a process

0(format:defformat 2format:mailer-process0 (:one-arg) (process ignore)
  (check-arg-type process si:process "a mailer process")
  (let* ((pi (cdr (assq process *process-info*)))
	 (description (when pi (pi-description pi))))
    (if description
	(progn (send format:*format-output* :string-out
		     (if format:colon-flag "The " "the "))
	       (send format:*format-output* :string-out description)
	       (send format:*format-output* :string-out " process"))
	(progn (send format:*format-output* :string-out
		     (if format:colon-flag "Process " "process "))
	       (send format:*format-output* :string-out (process-name process))))))

1;; Receiver side of inter-process communication
0(defun 2reset-process-info-command-queue0 (pi)
  (setf (pi-command-queue pi) nil))

(defun 2command-dequeue0 (pi)
  (without-interrupts
    (cl:pop (pi-command-queue pi))))

(defun 2command-enqueue0 (pi pc)
  (without-interrupts
    (setf (pi-command-queue pi) (nconc (pi-command-queue pi) (list pc)))
    (process:wakeup (pi-process pi))))

(defun 2report-command0 (pc description &optional queue)
  (su:log-event :normal
		"Received command to ~A from ~\Mailer-Process\~
		 ~@[; ~A ~[is empty~;has 1 entry~:;has ~:*~D entries~]~]"
		description (pc-commanding-process pc) queue (if queue (send queue :length))))

(defun 2report-unknown-command0 (pc &optional stopped?)
  (su:log-event :normal
		"Received unknown command ~S from ~\Mailer-Process\~:[~; while suspended~]"
		(pc-command pc) (pc-commanding-process pc) stopped?))

(defun 2wait-for-and-report-start-command0 (pi &optional queue)
  (loop with pc = nil
	do
    (process:process-block-and-poll-wait-function "Mailer Suspended" 60
      #'(lambda () (not (null (location-contents (locf (pi-command-queue pi)))))))
    (setf pc (command-dequeue pi))
    (selectq (pc-command pc)
      (:start
       (report-command pc "start" queue)
       (return nil))
      (:stop)					1;Just ignore it.
0      (:halt
       (report-command pc "halt" queue)
       (halt-current-process))
      (otherwise
       (report-unknown-command pc t)))))

(defun 2halt-mailer-process0 (process)
  (process-kill process)) 

(defun 2halt-current-process0 ()
  (su:log-event :normal "Shutting down")
  (halt-mailer-process scl:*current-process*))

1;; The basic operation of the foreground and delivery processes is to take a message
;; from a queue, and perform some operation on it.  They may also receive commands
;; from either a human operator or an error handler.
0(defun 2message-loop0 (pi queue operation whostate)
  (condition-bind ((mailer-timeout
		     #'(lambda (condition)
			 (su:log-event :problem "Spurious timeout ignored:~%~4@T~~A~"
				       condition)
			 :no-action)))
    (loop doing
      (process:process-block-and-poll-wait-function whostate 60
	#'(lambda () (not (and (null (send queue :head))
			       (null (location-contents (locf (pi-command-queue pi))))))))
      (let ((pc (command-dequeue pi)))
	(if pc
	    1;; Handle this command (takes priority over any message(s)).
0	    (selectq (pc-command pc)
	      (:start)				1;Just ignore it.
0	      (:stop
	       (wait-for-and-report-start-command pi queue))
	      (:halt
	       (report-command pc "halt" queue)
	       (halt-current-process))
	      (otherwise
	       (report-unknown-command pc)))
	    1;; No command this time, handle any message instead.
0	    (let ((message (message-dequeue queue operation)))
	      (when message
		(receipt-process-wait)
		(letf (((su:log-herald *mailer-log*) message))
		  (send message operation)))))))))

1;; Transmitter side of inter-process communication

0(defun 2command-enqueue-for-all-processes0 (command
					  &key (commanding-process scl:*current-process*))
  (loop with pc = (make-process-command command command
					commanding-process commanding-process)
	for (process . pi) in *process-info* do
	(when (process-active-p process)
	  (command-enqueue pi pc))))

(defun 2reset-command-info0 ()
  (loop for (nil . pi) in *process-info* do
    (reset-process-info-command-queue pi)))

1;; This function is near the base of the stack for all mailer processes.  Bind USER-ID
;; here so that files created by the mailer show this in the author field.  Later, bind
;; TERMINAL-IO here to a window which is in the same place the mail log listener is now,
;; if the process is one of the mailer processes.  Don't do this for the :LOCAL-MAILER
;; protocol.  Arrest the log listener while debugging is going on?

0(declare (special 2foreground-boot-mode0))

(defun 2top-level0 (log-process-id function &rest args)
  (declare (zwei:indentation 1 1)
	   (dbg:bug-report-recipient-system "Mailer"))
  (letf (((su:log-process-id *mailer-log*) log-process-id)
	 ((su:log-herald *mailer-log*) (process-name scl:*current-process*))
	 (su:*log* *mailer-log*))
    (let ((user-id "Mail-Server")
	  (neti:*inhibit-obsolete-information-warning* t)
	  (error-restart-mode nil)
	  (process-info (cdr (assq scl:*current-process* *process-info*))))
      1;; The 2top-level-error1 function does some at0-1error-time analysis of the error,
      ;; and either proceeds (in which case the error restarts below are never offered)
      ;; or stops all the other Mailer processes and then returns 2nil1 so that we offer
      ;; the error restarts below.
0      (condition-bind ((error 'top-level-error))
	(error-restart (error "Cold boot the Mailer (restore state from the file system)")
	  (if error-restart-mode (setq error-restart-mode 'cold-boot))
	  (error-restart (error "Warm boot the Mailer (use state in virtual memory)")
	    (if error-restart-mode
		(progn (setq foreground-boot-mode error-restart-mode)
		       (boot-foreground-process))
		(progn (setq error-restart-mode 'warm-boot)
		       (lexpr-funcall function process-info args)))))))))

(zwei:defindentation (top-level 1 1))

(defflavor 2rejection-slip
0	((timestamp (cl:get-universal-time))	1;When we decided to reject incoming mail0 --
						1;0   2nil1 means supply the current time in
0						1;0   1rejections0 --1 chiefly for case where we
0						1;0   1haven't brought up the Mailer yet, and
0						1;0   1we don't want to use some old disk-saved
0						1;0   1time.
0	 author-type				1;2:operator1 or 2:program
0	 reason)
	()
  (:initable-instance-variables author-type  reason)
  (:readable-instance-variables)
  (:required-init-keywords     :author-type :reason))

(defmethod 2(make-instance rejection-slip)0 (&key author-type &allow-other-keys)
  (cl:check-type author-type (cl:member :uninitialized :operator :program)))

(defmethod 2(print-to-stream rejection-slip)0 (stream)
  (if (eq author-type :uninitialized)
      (format stream
	      "The store-and-forward mailer on this machine has not yet been initialized.")
    (let ((shutdown-origin (selectq author-type
			     (:program " because of a program error")
			     (:operator " by operator intervention"))))
      (format stream "The store-and-forward mailer on this machine has been shut down~@[~A~].~
		      ~@[~%The explanation given was:~@
		         ~4@T~~A~~]~
		      ~@[~%The time of shutdown was ~\time\.~]"
	      shutdown-origin
	      reason
	      timestamp))))

(compile-flavor-methods2 rejection-slip0)

(defvar 2*rejection-slip*
0	(make-instance 'rejection-slip
		       :author-type :uninitialized
		       :reason "The mailer has not yet been initialized."))

1;; Log errors and refuse incoming messages.  Attempt to diagnose certain categories of
;; problems and continue.

0(defvar 2no-more-room-lock0 nil)

(defun 2top-level-error0 (error)
  (typecase error
    (zwei:barf
      nil)
    (fs:no-more-room
      (setf *rejection-slip*
	    (make-instance 'rejection-slip
			   :author-type :program
			   :reason (format nil "~A" error)))
      (let (lock? probe?)
	(when (or (setq lock? no-more-room-lock)
		  (setq probe? (su:probe-path :file breathing-room-pathname)))
	  (cond ((and probe?
		      (store-conditional (locf no-more-room-lock) nil t))
		 (when (su:probe-path :file breathing-room-pathname)
		   (su:log-event :problem "The file system is out of room")
		   (su:delete-server-file breathing-room-pathname)
		   (su:expunge-server-directory dynamic-directory)
		   (su:log-event :normal
				 "Ran out of room.  Deleted ~A." breathing-room-pathname)
		   (setq no-more-room-lock nil)))
		(lock?
		 (process-wait "FS Expunge Wait" #'(lambda () (not no-more-room-lock)))
		 (su:log-event :normal
			       "Ran out of room.  Waited for some other process to make space."
			       ))))
	(su:log-event :normal
	  "Periodically retrying the file operation until file system space available.")
	(loop with proceedable-error = error
	      while (send proceedable-error :proceed-type-p :retry-file-operation)
	      do (condition-case (new-error)
		      (send proceedable-error :proceed :retry-file-operation)
		    (fs:no-more-room
		      (setf proceedable-error new-error))
		    (error (return nil)))
		 (cl:sleep 10 :sleep-reason "FS Room Wait"))))
    (otherwise
      (setf *rejection-slip*
	    (make-instance 'rejection-slip
			   :author-type :program
			   :reason (format nil "~A" error)))
      (command-enqueue-for-all-processes :stop)
      (su:log-event :disaster "Error in process ~A of type ~A~%~A"
		    (process-name scl:*current-process*) (typep error) error)
      nil)))


1;; Process parameters

;; If 2enable-delivery-processes0 1is T:
;;   All foreign deliveries (except possibly direct, slow ones) are handed off to separate
;;     "delivery processes", and the foreground process performs only local deliveries.
;;   When the Mailer starts up, a number of delivery processes (the number being taken
;;     from the variable 2number-of-delivery-processes1) are created.
;;
;; If 2enable-delivery-processes1 is NIL:
;;   The foreground process performs both local deliveries and all foreign deliveries
;;    0  1(except possibly direct, slow ones)0 1to0 1fast networks0.
1;; 0  1The variable 2number-of-delivery-processes0 1is ignored.

0(define-option 2enable-delivery-processes0    T)
(define-option 2number-of-delivery-processes0 1)

1;; If 2enable-slow-delivery-process1 is T, a special "slow delivery" process is created
;; when the Mailer starts up; this process delivers messages to hosts that are directly
;; reachable but only via "slow" networks.  If 2enable-slow-delivery-process1 is NIL,
;; then the foreground process performs delivery to directly reachable hosts over
;; slow networks, as well as local delivery and (possibly, depending on the value of
;; 2enable-delivery-processes1) indirectly reachable hosts, or hosts reachable over
;; "fast" networks.

0(define-option 2enable-slow-delivery-process0 T)

(cl:defparameter 2foreground-priority0 0)
(cl:defparameter 2foreground-whostate0 "Foreground Wait")

(cl:defparameter 2background-priority0 0)
(cl:defparameter 2background-whostate0 "Background Wait")

(cl:defparameter 2delivery-priority0 0)
(cl:defparameter 2delivery-whostate0 "Delivery Wait")

(defvar 2foreground-process0 nil)
(defvar 2background-process0 nil)
(defvar 2slow-delivery-process0 nil)
(defvar 2delivery-processes0 nil)

(defun 2create-process0 (name description priority)
  (let* ((process (make-process name
				:priority priority
				:warm-boot-action #'halt-mailer-process))
	 (pi (make-process-info process process description description))
	 (ppi (cons process pi)))
    (setf-nconc *process-info* ppi)
    (sort-*process-info*)
    process))

(defun 2sort-*process-info*0 ()
  (labels ((mailer-process-lessp (ppi-1 ppi-2)
	     (let ((process-1 (car ppi-1))
		   (process-2 (car ppi-2))
		   (process-description-2 (pi-description (cdr ppi-2))))
	       (cond ((eq process-1 foreground-process))
		     ((eq process-1 background-process) (neq process-2 foreground-process))
		     ((eq process-1 slow-delivery-process) (null process-description-2))
		     (process-description-2 nil)
		     (t
		      (string-lessp (process-name process-1) (process-name process-2)))))))
    (setf *process-info* (cl:sort *process-info* #'mailer-process-lessp))))

(defun 2boot-process0 (symbol name description top-level priority)
  (let ((process (symeval symbol)))
    (if process
	(process-reset process :always)
      (setq process (create-process name description priority))
      (set symbol process)
      (process-preset process top-level))
    (unless (eq symbol 'foreground-process)
      (su:log-event :normal "Booting ~\Mailer-Process\" process))
    (process-enable process)))

(defun 2boot-foreground-process0 ()
  (boot-process 'foreground-process "Mail Foreground" "foreground"
		'foreground-top-level foreground-priority))

(defun 2boot-background-process0 ()
  (boot-process 'background-process "Mail Background" "background"
		'background-top-level background-priority))

(defun 2boot-slow-delivery-process0 ()
  (when enable-slow-delivery-process
    (if (not (local-host-on-slow-network-p))
	(su:log-event :normal
	  "Not booting a slow delivery process since this host is not on any slow networks")
	(boot-process 'slow-delivery-process "Mail Slow Delivery" "slow delivery"
		      'slow-delivery-top-level delivery-priority))))

1;; Multiple delivery processes

;; Keep the mailer from blocking on outgoing mail connections.  Also, keep long messages
;; from backing up all other mail delivery.

0(defun 2delivery-top-level0 (n)
  (top-level (code-char (+ (char-code #/0) n)) #'message-loop outgoing-queue
	     :delivery-process delivery-whostate))

(defun 2slow-delivery-top-level0 ()
  (top-level "<" #'message-loop slow-queue
	     :slow-delivery-process delivery-whostate))

1;; Assure that the desired number of delivery processes exist, creating more if necessary.
;; Cons processes in backwards order so the peek display looks nice.  Make sure that all of
;; these processes are reset.

0(defun 2boot-delivery-processes0 ()
  (when (and enable-delivery-processes (> number-of-delivery-processes 0))
    (su:log-event :normal "Booting ~D mail delivery processes" number-of-delivery-processes)
    (let ((n-existing-processes (length delivery-processes)))
      (cond ((= number-of-delivery-processes n-existing-processes))
	    ((< number-of-delivery-processes n-existing-processes)
	     (dotimes (ignore (- n-existing-processes number-of-delivery-processes))
	       (let ((process (first delivery-processes)))
		 (setq delivery-processes (cl:rest delivery-processes)
		       *process-info* (cl:delete process *process-info* :key #'first)))))
	    ((> number-of-delivery-processes n-existing-processes)
	     (dotimes (counter (- number-of-delivery-processes n-existing-processes))
	       (let* ((process-number (- number-of-delivery-processes counter))
		      (process (create-process (format nil "Mail Delivery ~D" process-number)
					       nil
					       delivery-priority)))
		 (process-preset process 'delivery-top-level process-number)
		 (push process delivery-processes))))))
    (mapc #'process-reset delivery-processes)
    (mapc #'process-enable delivery-processes)))

(defun 2register-interested-processes0 ()
  (send incoming-queue :register-interested-process foreground-process)
  (cond ((and enable-delivery-processes (> number-of-delivery-processes 0))
	 (dolist (process delivery-processes)
	   (send outgoing-queue :register-interested-process process)))
	(t
	 (send outgoing-queue :register-interested-process foreground-process)))
  (cond (slow-delivery-process
	 (send slow-queue :register-interested-process slow-delivery-process))
	((and enable-delivery-processes (> number-of-delivery-processes 0))
	 (dolist (process delivery-processes)
	   (send slow-queue :register-interested-process process)))
	(t
	 (send slow-queue :register-interested-process foreground-process))))

(defun 2process-summary0 (&optional (stream standard-output))
  (loop for (process) in *process-info* do
    (dw:with-redisplayable-output (:stream stream
				   :unique-id process)
      (dw:redisplayable-format stream "~A:~20T" process)
      (let ((whostate (and (process-active-p process)
			   (process-whostate process))))
	(dw:with-redisplayable-output (:stream stream
				       :cache-value whostate)
	  (if whostate
	      (format stream "~A" whostate)
	      (format stream "Not active")))))
    (send stream :tyo #\newline))
  (dw:with-redisplayable-output (:stream stream
				 :unique-id 'rejection-slip
				 :cache-value *rejection-slip*)
    (when *rejection-slip*
      (send stream :tyo #\newline)
      (print-to-stream *rejection-slip* stream)
      (send stream :tyo #\newline))))

1;; Foreground top level

0(defvar 2foreground-boot-mode0)

(cl:defparameter 2foreground-boot-list
0		 '(log-monitor options directory log-file
		   dialnet-registry breathing-room uid queue mailboxes host message))

1;; Set *REJECTION-SLIP* so that the incoming mail processes don't run while the
;; foreground is starting up.  Set FOREGROUND-BOOT-MODE so that resetting the
;; process runs the warm boot sequence.  Set the log PROCESS-ID instead of
;; binding it in TOP-LEVEL so that the start-up log entries don't show the process-id.

0(defun 2foreground-top-level0 ()
  (setf *rejection-slip* (make-instance 'rejection-slip
					:author-type :uninitialized
					:reason "The mailer is starting up."))
  (setq receipt-process-count 0)
  (fs:with-automatic-login-to-sys-host
    (top-level nil
      #'(lambda (process-info)
	  (let ((initialization-error
		  (catch 'foreground-abort
		    (loop for item in foreground-boot-list
			  do (letf (((su:log-herald *mailer-log*) (get item 'herald)))
			       (funcall (cl:get item foreground-boot-mode #'ignore)))))))
	    (if initialization-error
		(progn
		  (setf *rejection-slip* (make-instance 'rejection-slip
							:author-type :program
							:reason initialization-error))
		  (when *mailer-log*
		    (su:log-event :disaster
		      "Can't bring up the mailer because of serious errors while starting up")
		    (su:close-log-file *mailer-log*))
		  (halt-current-process))
		(progn
		  (reset-command-info)
		  (letf (((su:log-herald *mailer-log*) "Process setup"))
		    (boot-background-process)
		    (boot-slow-delivery-process)
		    (boot-delivery-processes)
		    (register-interested-processes)
		    (setq foreground-boot-mode 'warm-boot)
		    (su:log-event :normal "The mailer is now in operation"))
		  (setq *rejection-slip* nil)
		  (setf (su:log-process-id *mailer-log*) (if enable-delivery-processes "-" "")
			)
		  (message-loop process-info incoming-queue
				:foreground-process foreground-whostate))))))))

1;;; The background process runs tasks.

0(defvar 2*mailer-task-queue*
0	(make-instance 'su:background-task-queue :name "Mailer Background Tasks"
						 :period "1 minute"))

(defun 2background-top-level0 ()
  (top-level "+"
    #'(lambda (pi)
	(su:make-background-tasks-want-to-run *mailer-task-queue*)
	(error-restart-loop (error "Allow the mailer background process to continue running")
	  (process:block-and-poll-with-timeout (su:background-task-queue-period
						 *mailer-task-queue*)
					       background-whostate
					       60
	    #'(lambda () (not (null (location-contents (locf (pi-command-queue pi)))))))
	  (let ((pc (command-dequeue pi)))
	    (when pc
	      (selectq (pc-command pc)
		(:start)			1;Just ignore it.
0		(:stop
		 (wait-for-and-report-start-command pi))
		(:halt
		 (report-command pc "halt")
		 (halt-current-process))
		(otherwise
		 (report-unknown-command pc))))
	    (letf (((su:log-herald *mailer-log*) "Background"))
	      (su:maybe-run-background-tasks *mailer-task-queue*)))))))



1;; Retransmission

;; If a host comes up immediately after a message is queued, the message will be sent between
;; 10 and 20 minutes afterward.  Probe all hosts before requeueing any messages so that the
;; foreground process won't try to send any messages before all hosts have been probed.

0(defun 2retransmission0 ()
  (let ((time (cl:get-universal-time)))
  (map-hosts :probe time)
  (map-hosts :queue-messages)))

(su:add-background-task *mailer-task-queue*
			"Message retransmission" 'retransmission "10 minutes")

1;; Deferred delivery and receipt

;; Deferred delivery is used when opening a connection to a host is expensive.  This allows
;; connections to be opened only at specific frequencies or times of day.  This also allows
;; messages to be grouped together so that several are sent over a single connection.

;; Deferred receipt is used when mail is expected from a certain host, but that host is known
;; not to make outgoing connections.  If that host has a Telenet pad or similar device, then it
;; may be much cheaper to connect to it than for it to connect to other hosts.

0(defun 2select-next-deferred-time0 (next-var times-var)
  (let ((times (symeval times-var)))
    (set next-var
	 (multiple-value-bind (nil minutes hours day month year) (time:get-time)
	   (cond ((fixp times)
		  (+ (time:encode-universal-time 0 minutes hours day month year)
		     times))
		 ((listp times)
		  (+ (time:encode-universal-time 0 0 0 day month year)
		     (loop with now = (* (+ (* hours 60.) minutes) 60.)
			   for time in times do
			   (if (> time now) (return time))
			   finally (return (+ (car times) (* 24. 60. 60.))))))
		 (t (ferror "~S is an invalid setting for ~A"
			    times times-var)))))))

(defun 2parse-deferred-times0 (times-var)
  (let ((times (symeval times-var)))
    (set times-var
	 (cond
	   ;; Must be already parsed
	   ((or (fixp times)
		(and (listp times) (fixp (car times))))
	    times)	       
	   ;; A string describes an interval
	   ((stringp times)
	    (time:parse-interval-or-never times))
	   ;; A list of strings describes times of day
	   ((and (listp times)
		 (stringp (car times)))
	    (sort (loop with hours
			with minutes
			for time in times
			do (multiple-value (nil minutes hours) (time:parse time))
			collect (* (+ (* hours 60.) minutes) 60.))
		  '<))
	   ;; Garbage
	   (t (let ((log-entry
		      (format nil "The value of ~A is ~S, which is not a valid setting" times-var times)))
		(su:log-event :disaster log-entry)
		(throw 'foreground-abort
		  (format nil "Error while parsing deferred-time spec:~%  ~A" log-entry))))))))

1;; Possible values for DEFERRED-DELIVERY-TIMES are:
;;  NIL           -- Never make deferred deliveries unless a connection is already open
;;  Interval      -- Make deferred deliveries at this interval
;;  List of times -- Make deferred deliveries at these times
;;  T             -- Send deferred delivery mail whenever the task wakes up
;; This will have to be improved later.

0(define-option 2deferred-delivery-times0 nil)

(defvar 2next-deferred-delivery-time0)

(defun 2select-next-deferred-delivery-time0 ()
  (parse-deferred-times 'deferred-delivery-times)
  (select-next-deferred-time 'next-deferred-delivery-time 'deferred-delivery-times))

(defun 2parse-deferred-delivery-times0 ()
  (unless (memq deferred-delivery-times '(nil t))
    (select-next-deferred-delivery-time)))

(add-option-computation '(parse-deferred-delivery-times))

(defun 2deferred-delivery0 ()
  (let ((time (cl:get-universal-time)))
    (cond ((memq deferred-delivery-times '(t nil)))
	  (( time next-deferred-delivery-time)
	   (select-next-deferred-delivery-time)
	   (su:log-event :normal "Beginning deferred delivery; next delivery at ~\TIME\" NEXT-DEFERRED-DELIVERY-TIME)
	   (map-directly-reachable-mailer-hosts :queue-deferred-messages)))))

(su:add-background-task *mailer-task-queue*
			"Deferred delivery" 'deferred-delivery "10 minutes")

1;; Possible values for DEFERRED-RECEIPT-TIMES are:
;;  NIL           -- Never probe
;;  Interval      -- Probe at this interval
;;  List of times -- Probe at these times

0(define-option 2deferred-receipt-times0 nil)
(define-option 2deferred-receipt-hosts0 nil)

(defvar 2next-deferred-receipt-time0)

(defun 2select-next-deferred-receipt-time0 ()
  (parse-deferred-times 'deferred-receipt-times)
  (select-next-deferred-time 'next-deferred-receipt-time 'deferred-receipt-times))

(defun 2parse-deferred-receipt-times0 ()
  (when deferred-receipt-times
    (select-next-deferred-receipt-time)))

(add-option-computation '(parse-deferred-receipt-times))

(defun 2deferred-receipt0 ()
  (let ((time (cl:get-universal-time)))
    (when (and deferred-receipt-hosts
	       deferred-receipt-times
	       ( time next-deferred-receipt-time))
      (select-next-deferred-receipt-time)
      (unless (typep (first deferred-receipt-hosts) 'basic-mailer-host)
	(setq deferred-receipt-hosts (mapcar 'parse-mailer-host deferred-receipt-hosts)))
      (su:log-event :normal "Beginning probe~P for deferred mail; next probe at ~\TIME\"
		    (length deferred-receipt-hosts) next-deferred-receipt-time)
      (dolist (mailer-host deferred-receipt-hosts)
	(if (typep mailer-host 'reachable-mailer-host)
	    (condition-case (error)
		 (progn
		   (su:log-event :normal "Beginning probe of ~A" mailer-host)
		   (invoke-service-on-host :mail-probe (send mailer-host :host) mailer-host))
	       (error
		 (su:log-event :normal "Error while probing ~A: ~A" mailer-host error))
	       (:no-error
		 (su:log-event :normal "Ending probe of ~A" mailer-host)))
	    (su:log-event :normal "Not probing ~A, host is not reachable" mailer-host))))))

(su:add-background-task *mailer-task-queue*
			"Deferred receipt" 'deferred-receipt "10 minutes")

;; Try and resolve hosts that were unresolvable a while back.
(su:add-background-task *mailer-task-queue*
			"Resolve hosts" 'resolve-unresolvable-mailer-hosts "20 minutes")

1;; Simple kludge until the mailer knows about the "turn" command.
0(define-protocol 2:mail-probe0 (:mail-probe :byte-stream)
  (:invoke (path)
    (let ((host (car (neti:service-access-path-args path))))
      (su:log-event :debug "Opening connection to ~A" host)
      (condition-case (error)
	   (with-open-stream (stream (get-connection-for-service path :characters t))
	     (neti:with-stream-timeout (stream :input *network-delivery-timeout*)
	       (let ((char (send stream :tyi t)))
		 (selector char char-equal
		   (#/+
		    (let ((n (parse-number (send stream :line-in) 0 nil 10.)))
		      (su:log-event :normal "~A has ~D message~:P for this host" host n)))
		   (#/-
		    (su:log-event :normal "~A has no messages for this host" host))
		   (otherwise
		     (su:log-event :problem
				   "~A violated protocol; unrecognized response /"~C/""
				   host char))))))
	 (sys:network-error
	   (note-connection-error host error))))))

(define-server 2:mail-probe0 (:medium :byte-stream
			    :stream (stream :accept-p nil :characters t)
			    :reject-unless-trusted nil
			    :who-line nil :no-eof t
			    :network network :host host
			    :error-disposition :debugger)
   (if *rejection-slip*
       (let ((rejection-text (print-to-stream *rejection-slip* nil)))
	 (send stream :reject rejection-text))
       (progn
	 (send stream :accept)
	 (top-level ">" #'(lambda (ignore stream host network)
			    (letf (((su:log-herald *mailer-log*) "Mail Probe"))
			      (let ((mailer-host (parse-mailer-host host
						 :host-must-have-mail-service nil))
				    (count))
				(send mailer-host :incoming-conn (time:get-universal-time))
				(su:log-event :normal "Probe from ~A via ~A" mailer-host network)
				(setq count (send mailer-host :queue-deferred-messages t))
				(condition-case (error)
				     (progn
				       (if (and count (plusp count))
					   (format stream "+~D~%" count)
					   (send stream :tyo #/-))
				       (send stream :force-output)
				       (send stream :finish))
				   (sys:network-error
				     (note-connection-error host error))))))
		    stream host network))))

1;; MAILBOX-TABLE-READ determines whether or not the files have changed.

0(defun 2mailbox-table0 ()
  (declare (special local-mailboxes-creation-date forwarding-table-lock))
  (fs:with-automatic-login-to-sys-host
    (unless (mailbox-table-read nil)
      1;; Either the table didn't change or an error occurred --
      ;;    In either event, write any forwarding tables that weren't written the last time.
      ;;    (If we didn't do any work because of an error, it doesn't hurt to try to get the
      ;;     other mailer hosts up-to-date w.r.t. our last successfull read.)
0      (when (and (forwarding-table-hosts)
		 (fixp local-mailboxes-creation-date))
	(let ((lock-snapshot forwarding-table-lock))
	  (when lock-snapshot
	    (su:log-event :normal "Process ~A is currently writing forwarding tables; ~
				   waiting for it to finish"
			  (process-name lock-snapshot))))
	(si:with-lock-held (forwarding-table-lock :whostate "Forwarding Table Lock")
	  (condition-case (error)
	       (write-forwarding-tables-if-necessary)
	     (mailbox-error
	       (su:log-event :disaster
			     "Error while writing deferred forwarding tables~%~A" error))))))))

(su:add-background-task *mailer-task-queue*
			"Process mailbox table" 'mailbox-table "15 minutes")

1;; This really only needs to be called once a day, but then it would only be called if the
;; machine had not been booted for a day or longer.  This is often not the case for non-server
;; Lisp machines.  All background tasks should be run immediately after cold booting.  If we
;; had a list of all queued messages, we could iterate over that list instead of iterating over
;; the hosts.

0(defun 2return-mail0 ()
  (let ((time (cl:get-universal-time)))
    (su:log-event :normal "Checking for mail queued to undeliverable hosts")
    (map-hosts :return-mail-for-undeliverable-hosts time)))

(su:add-background-task *mailer-task-queue*
			"Return mail for undeliverable hosts" 'return-mail "4 hours")

1;; All assignments of *rejection-slip* and control of the slave processes should be
;; done by the foreground process, rather than being split between here and
;; FOREGROUND-TOP-LEVEL.  All of the functions below should work by communicating with that
;; process only.  When shutting down, wait until the message queues are all empty and the
;; background process is idle.

;; Returns NIL if the process has never been created or is inactive.

0(defun 2foreground-active0 ()
  (and foreground-process (process-active-p foreground-process) t))

1;; START-MAILER invokes all the COLD-BOOT handlers.
;; RESTART-MAILER invokes all the WARM-BOOT handlers.
;; HALT sends a :HALT message to all of the mailer processes.
;; A mailer warm boot means that the mailer state in virtual memory is used.
;; A mailer cold boot means that the mailer state is restored from the file system.

;; These terms are somewhat misleading, since the COLD-BOOT operation is performed whenever
;; the machine either warm boots or cold boots.  The WARM-BOOT operation is performed whenever
;; the foreground process is reset.  You have to be careful when warm booting the mailer that
;; all of the data structures are consistent.  If a message has been removed from the incoming
;; queue by the foreground process when the mailer is warm booted, then it will not be
;; delivered until the mailer is next cold booted.

0(defvar 2*suspended-mailer*0 nil) 1; Mailer was manually suspended

;;; Determines whether or not the Mailer was suspended in the indicated fashion.
0(defun 2mailer-suspended0 (&optional how)
  (cl:ecase how
    (:manually
      *suspended-mailer*)
    (:by-program
      (and *rejection-slip*
	   (eq (rejection-slip-author-type *rejection-slip*) :program)))
    ((nil)
     (or (mailer-suspended :manually)
	 (mailer-suspended :by-program)))))

1;;; We use the following variable to prevent multiple processes from trying to bring up the
;;; mailer at the same time.  Using the foreground-active function won't suffice, since
;;; another process could already be in the initialization code, but before the spot where
;;; the foreground process actually becomes active.

0(defvar 2*starting-mailer*0 nil)

(defun 2start-internal0 (force? warn? boot-mode)
  (when (store-conditional (locf *starting-mailer*) nil scl:*current-process*)
    (unwind-protect
	(cond ((not (or force?
			(send *local-host* :user-get :experimental-mailer)
			(assq :store-and-forward-mail (send *local-host* :service))))
	       (when warn?
		 (tell "This machine is not configured for store-and-forward mail service."))
	       nil)
	      ((and (foreground-active)
		    (not (mailer-suspended)))
	       (when warn?
		 (tell "The mailer is already running."))
	       nil)
	      ((and (foreground-active)
		    (mailer-suspended :manually)
		    (not (and warn?
			      (cl:y-or-n-p "The Mailer has been manually suspended.  ~
					    Start the Mailer anyway? "))))
	       nil)
	      ((and (foreground-active)
		    (mailer-suspended :by-program)
		    (not (and warn?
			      (cl:y-or-n-p "The Mailer has been suspended by program error.  ~
					    Start the Mailer anyway? "))))
	       nil)
	      (t
	       1;; Do nothing that requires logging in this process0 --
1	       ;; 0   1Otherwise, we'd have to bind 2su:*log*1, etc.
0	       (setf *suspended-mailer* nil)
	       (initialize-environment)
	       (initialize-log-monitor-early)
	       (setq foreground-boot-mode boot-mode)	1;Foreground process will bind it.
0	       (boot-foreground-process)
	       t))
      (store-conditional (locf *starting-mailer*) scl:*current-process* nil))))

(defun 2start-mailer0   (&optional (force? t) (warn? t))
  (start-internal force? warn? 'cold-boot))

(defun 2restart-mailer0 (&optional (force? t) (warn? t))
  (start-internal force? warn? 'warm-boot))

1;; Ideally, MESSAGE-LOOP should just return when it sees a :HALT command and LOG-FILE-CLOSE
;; should be called by FOREGROUND-TOP-LEVEL.  But this would require that foreground process
;; wait until all of the other processes have shut down first.

0(define-interval-60 shutdown-timeout "5 seconds")

(defun 2shutdown-wait0 (process)
  (when (process-active-p process)
    (su:log-event :normal "Waiting for ~\Mailer-Process\ to shut down" process)
    (process-wait "Mailer Shutdown"
      #'(lambda () (not (process-active-p process))))))

1;;; See the comments for the *starting-mailer* variable.  The same general arguments hold here.

0(defvar 2*halting-mailer*0 nil)

(defun 2halt-mailer0 (&optional (warn? t))
  (when (store-conditional (locf *halting-mailer*) nil scl:*current-process*)
    (unwind-protect
	(with-log-output-to-user ("Mailer halt" warn?)
	  (if (not (foreground-active))
	      (when warn?
		(tell "The mailer is not running."))
	      (progn
		(when (mailer-suspended :manually)
		  (su:log-event :normal
				"The Mailer has already been suspended; it will now be halted."
				))
		(setf *rejection-slip*
		      (make-instance 'rejection-slip
				     :author-type :operator
				     :reason "The mailer has been manually halted."))
		(unless (zerop receipt-process-count)
		  (su:log-event :normal "Waiting for receipt process(es) to finish")
		  (receipt-process-wait))
		(command-enqueue-for-all-processes :halt)
		1;; In the common case where all of the mailer processes are idle, it should
		;; only take them a few seconds to shut down.  Otherwise, make log entries
		;; for those processes we are waiting for to shut down.
		0(unless (process-wait-with-timeout "Mailer Shutdown" shutdown-timeout
			  #'(lambda ()
			      (loop for (process) in *process-info*
				    never (process-active-p process))))
		  (mapc #'(lambda (x) (shutdown-wait (car x))) *process-info*))
		(su:close-log-file *mailer-log*))))
      (store-conditional (locf *halting-mailer*) scl:*current-process* nil))))

(defun 2resume-mailer0 (&optional (warn? t))
  (with-log-output-to-user ("Mailer resume" warn?)
    (cond ((not (foreground-active))
	   (if warn? (tell "The mailer is not running; there is nothing to resume.")))
	  ((and (not (mailer-suspended)))
	   (if warn? (tell "The mailer has not been suspended; there is nothing to resume.")))
	  (t (setf *suspended-mailer* nil)
	     (setf *rejection-slip* nil)
	     (command-enqueue-for-all-processes :start)))))

(defun 2suspend-mailer0 (&optional (warn? t))
  (with-log-output-to-user ("Mailer suspend" warn?)
    (cond ((not (foreground-active))
	   (if warn? (tell "The mailer is not running; there is nothing to suspend.")))
	  ((mailer-suspended)
	   (if warn? (tell "The mailer has already been suspended.")))
	  (t (setf *suspended-mailer* t)
	     (setf *rejection-slip*
		   (make-instance 'rejection-slip
				  :author-type :operator
				  :reason "The mailer has been manually suspended."))
	     (command-enqueue-for-all-processes :stop)))))

1;; Use the PROCESS slot of the PROCESS-INFO structure to mark those processes which were
;; disabled.  This way, *PROCESS-INFO* serves as SYS:ACTIVE-PROCESSES as well as
;; SYS:ALL-PROCESSES for the mailer.

0(defun 2enable-process0 (process-info-entry)
  (destructuring-bind (process . pi) process-info-entry
    (unless (pi-process pi)
      (setf (pi-process pi) process)
      (su:log-event :normal "Enabling ~\Mailer-Process\" process)
      (process-enable process))))

1;; Set the process of the log pane to NIL when disabling the foreground process so that the
;; process won't be given a run reason by the window system.

0(defun 2disable-process0 (process-info-entry &optional force?)
  (destructuring-bind (process . pi) process-info-entry
    (cond ((not (process-active-p process)))
	  ((and (eq process scl:*current-process*) (not force?))
	   (su:log-event :normal
			 "~:\Mailer-Process\ is the current process; leaving it enabled."
			 process))
	  (t
	   (su:log-event :normal "Disabling ~\Mailer-Process\" process)
	   (setf (pi-process pi) nil)
	   (process-disable process)))))

(defun2 (:property :smtp sys:enable-services)0 (ignore)
  (start-mailer nil nil))

(defun2 (:property :chaos-mail sys:enable-services)0 (ignore)
  (start-mailer nil nil))

(defun2 (:property :smtp sys:disable-services)0 (ignore)
  (halt-mailer nil)) 

(defun2 (:property :chaos-mail sys:disable-services)0 (ignore)
  (halt-mailer nil))
