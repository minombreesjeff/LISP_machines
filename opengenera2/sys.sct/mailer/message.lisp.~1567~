;; -*- Mode: Lisp; Package: Mailer; Base: 10.; Syntax: ZetaLisp; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Messages

0(defenv(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") mail-file-pathname0 (su:new-pathname dynamic-directory :wild "Mail"))
(defenv 2work-file-pathname0 (su:new-pathname dynamic-directory :wild "Work"))
(defenv 2temp-file-pathname0 (su:new-pathname dynamic-directory :wild "Temp"))

1;; Possible message states:
;;   UNUSED		Not in use
;;   STARTED		?
;;   RECIPIENTS		?
;;   DATA		?
;;   CAPTURED		Reception completed but not yet queued
;;   RESTORE		Being restored from the file system
;;   RETRANSMIT		Waiting for a host to come up
;;   INCOMING-QUEUE	Received and queued for delivery
;;   OUTGOING-QUEUE	Delivered locally and queued for foreign delivery
;;   SLOW-QUEUE		Delivered locally and queued for slow delivery
;;   :FOREGROUND-PROCESS 
;;			Being delivered to local recipients by the foreground process
;;   :DELIVERY-PROCESS	Being delivered to foreign recipients by a delivery process
;;   :SLOW-DELIVERY-PROCESS
;;			Being delivered to slow foreign recipients by the slow delivery process

;; The state of a message as seen by the mailer is determined by the three instance
;; variables STATE, RETRANSMISSION, and LINK.  The code only compares the message state
;; with UNUSED.  The other states exist for debugging.  Transitions between message states
;; are checked by the :DEALLOCATE and :ENQUEUE methods.

;; STATE is a symbol from the list above.
;; RETRANSMISSION is T if the message has already been through the incoming
;;   queue once and is now queued for retransmission or deferred delivery to a host.  This
;;   information is not saved in the file system.  All restored messages enter the incoming
;;   queue regardless of the state of the host.
;; LINK points to the next message in a queue, or to NIL if it is not in any queue.

;; WORK-FILE-NEEDS-WRITING means there have been in-core changes to message state stored
;; in the work file.
;; RECEIPT-TIME should perhaps be renamed to CREATION-TIME.
;; MAIL-FILE stores the original list of recipients and the text of the message.
;; WORK-FILE stores those recipients on the expanded list to which this
;;   message has not yet been sent, and those recipients on the failed list
;;   about which notifications have not been sent.
;; TEMP-FILE is written when a new work file is to be created, and is renamed
;;   after the old work file is deleted.
;; RETURN-RECIPIENT and RETURN-RECIPIENT-LONG represent the contents of
;;   the "Sender" or "From" field as parsed from the header of the message.  The header is
;;   parsed only if it is necessary to reply to the originator of the message.  The first
;;   contains a RECIPIENT and the second the ":LONG" format of its printed representation.

;; ORIGINAL-RECIPIENTS is a list of recipients as recieved from the network.

;; EXPANDED-RECIPIENTS is a property list keyed by host.  Each property value is a list of
;;   recipient objects which are the recipients after mailing lists have been expanded.

;; FAILED-RECIPIENTS is a list of recipients with invalid local addresses,
;;   invalid foreign addresses, or invalid host names.

0(defflavor 2message
0	(uid
	 receipt-time
	 mail-file
	 work-file
	 temp-file
	 state
	 retransmission
	 work-file-needs-writing
	 work-file-write-failed
	 source-host
	 return-path
	 return-recipient
	 return-recipient-long
	 original-recipients
	 expanded-recipients
	 failed-recipients
	 message-text
	 (link nil)
	 access-path)
	()
  :gettable-instance-variables
  (:settable-instance-variables state link original-recipients))

(defresource2 message-text0 (&optional (length 2000))
  :constructor (make-array length :type 'art-string :fill-pointer 0)
  :matcher ( (array-length object) length))

(defun-in-flavor2 (message-init message)0 ()
  (cl:setf uid nil
	   receipt-time nil
	   mail-file nil
	   work-file nil
	   temp-file nil
	   retransmission nil
	   work-file-needs-writing nil
	   work-file-write-failed nil
	   source-host nil
	   return-path nil
	   return-recipient nil
	   return-recipient-long nil
	   original-recipients nil
	   expanded-recipients nil
	   failed-recipients nil
	   message-text nil
	   access-path nil
	   link nil
	   state 'unused))

(defmethod2 (:init message :after)0 (ignore)
  (message-init))

(defmethod2 (:reset message)0 ()
  (when message-text
    (setf (fill-pointer message-text) 0)
    (deallocate-resource 'message-text message-text)
    (setf message-text nil))
  (message-init))

(defmethod2 (:held message)0 () (or (eq state 'unused) link))

(defmethod2 (:print-self message)0 (stream ignore slashify-p)
  (if slashify-p
      (printing-random-object (self stream)
	(if (eq state 'unused)
	    (send stream :string-out "Unused message")
	    (format stream "Message ~D from ~A, ~A" uid source-host state)))
      (if (eq state 'unused)
	  (send stream :string-out "Unused message")
	  (format stream "Message ~D" uid))))

(defmethod2 (:locf-recipients message)0 () (locf expanded-recipients))
(defmethod2 (:locf-state message)0 () (locf state))



(defmethod2 (:cold-boot message)0 (allocated?)
  (when allocated?
    (su:log-event :normal "Deallocating ~A from ~A, in state ~A" self source-host state)
    (message-deallocate self :force t)))

(defmethod2 (:warm-boot message)0 (allocated?)
  (when allocated?
    (su:log-event :normal "~A from ~A is in state ~A" self source-host state)
    (when (memq state '(:foreground-process :delivery-process :slow-delivery-process))
      (su:log-event :normal "~A entered into the incoming queue" self)
      (message-enqueue incoming-queue self))))

(defsubst-in-flavor 2(get-hosts message)0 ()
  (loop for host in expanded-recipients by 'cddr
	collect host))

(defmethod 2(:hosts message)0 ()
  (get-hosts))

(defsubst-in-flavor 2(get-recipients-for-host message)0 (mailer-host)
  (cl:getf expanded-recipients mailer-host))

1;;; Return the mailer host so callers can build up histories of affected mailer hosts
;;; Note that we must look under every mailer host in the expanded recipients list
;;; for the recipient, since the mailer host stored in the recipient object might
;;; differ from the mailer host under which it is queued.  For example, consider
;;;   Fred.Bedrock.DialNet.Symbolics.COM
;;; which is queued through
;;;   Wilma.Bedrock.DialNet.Symbolics.COM
0(defun-in-flavor2 (delete-recipient message)0 (recipient)
  (declare (values mailer-host))
  (loop for mailer-host-recipient-list on expanded-recipients by #'cddr
	for (mailer-host recipients . nil) = mailer-host-recipient-list
	do (when (memq recipient recipients)
	     (let ((remaining-recipients (delq recipient recipients)))
	       (if (null remaining-recipients)
		   (cl:remf expanded-recipients mailer-host)
		   (setf (cl:getf expanded-recipients mailer-host) remaining-recipients)))
	     (setf work-file-needs-writing t)
	     (return mailer-host))))

1;; Deliver failed recipient mail directly rather than queueing for the mailer since the
;; work file keeps track of this for us, and we don't have to copy the mail file that way.

0(defun-in-flavor2 (fail-recipient message)0 (recipient reason &optional (note? t))
  (when (not (assq recipient failed-recipients))
    (when (null reason)
      (su:log-event :problem "Recipient ~A is being marked as having failed verification or delivery,~@
                              but the description of the failure was unexpectedly not given."))
    (setf-nconc failed-recipients (list recipient reason))
    (setf work-file-needs-writing t)
    (when note?
      (su:log-event :normal "~A failed:~&    ~~A~" recipient reason))))

1;; Sort message recipients by host and eliminate duplicates.  Store the sorted recipients
;; in both the message and the work file.  Look at the recipients at the local host and do
;; forwarding and mailing list expansion.  Note: The forground process may block in this
;; function while trying to parse an Internet domain name.

0(defun-in-flavor2 (add-recipient message)0 (recipient)
  (labels ((add-recipient-internal (recipient host)
	     (let ((entry (get (locf expanded-recipients) host)))
	       (when (not (memq recipient entry))
		 (putprop (locf expanded-recipients) (cons recipient entry) host)
		 (setf work-file-needs-writing t)))))
    (let ((host (send recipient :host)))
      (cond ((null host)
	     (fail-recipient recipient "No such host."))
	    ((neq host local-mailer-host)
	     (if (or (send host :mail-service)
		     (typep host 'unresolved-mailer-host))
		 (add-recipient-internal recipient host)
		 ;; for side effect, run this. It might add the service,
		 ;; and it might turn us into unresolved. What if the host
		 ;; is now redirected elsewhere? find-mail-service
		 ;; ignores domain-mail-hosts with new names.
		 ;; but we assume that the unresolved host will resolve
		 ;; by paying attention to those other names.
		 (condition-case ()
		      (find-mail-service host)
		    ;; This just means we're going to have to change things...
		    (no-path-to-mail-service-on-host nil))
		 (if (or (send host :mail-service)
			 (typep host 'unresolved-mailer-host))
		     (add-recipient-internal recipient host)
		     (fail-recipient recipient "Host does not provide mail service."))))
	    ((send recipient :file)
	     (add-recipient-internal recipient host))
	    (t 
	     (let ((new-recipient (mailbox-lookup (send recipient :name))))
	       (cond ((null new-recipient)
		      (fail-recipient recipient "No such mailbox at this host."))
		     ((listp new-recipient)
		      (mapc #'add-recipient new-recipient))
		     (t
		      (add-recipient new-recipient))))))))) 

(defun-in-flavor2 (expand-recipients message)0 ()
  (mapc #'add-recipient original-recipients))

(defmethod2 (:smash-expanded-recipients-mailer-host message)0 (old-host new-host)
  (declare (values message-already-queued-for-new-host-p))
  (loop with new-host-cons = nil
	with first-old-host-cons = nil
	for host-recipient-list on expanded-recipients by #'cddr
	for (host recipients . nil) = host-recipient-list
	when (eq host new-host)
	  do (setf new-host-cons host-recipient-list)
	when (eq host old-host)
	  do (if (null first-old-host-cons)
		 (setf first-old-host-cons host-recipient-list)
		 (setf (first host-recipient-list) nil))
	     (loop for recipient in recipients
		   do (send recipient :set-host new-host))
	     (setf work-file-needs-writing t)
	  and nconc recipients into all-recipients
	finally
	  (when first-old-host-cons
	    (if new-host-cons
		(cl:setf (second new-host-cons) (nconc (second new-host-cons) all-recipients)
			 (first first-old-host-cons) nil)
		(cl:setf (first first-old-host-cons) new-host
			 (second first-old-host-cons) all-recipients))
	    (loop for (host recipients) on expanded-recipients by #'cddr
		  unless (null host)
		    collect host into new-expanded-recipients
		    and collect recipients into new-expanded-recipients
		  finally
		    (setf expanded-recipients new-expanded-recipients)))
	  (return (not (null new-host-cons)))))

1;; If both the expanded recipients and the failed recipients are NIL, then either this is
;; the first time through the incoming queue or the delivery is complete.  We can't use
;; the RETRANSMISSION bit in this computation since it isn't saved on disk.  We should try
;; harder to make sure that a message doesn't have its recipients expanded twice and to
;; distinguish between the delivery beginning and delivery complete cases.

0(defun-in-flavor2 (delivery-complete message)0 ()
  (and (null expanded-recipients) (null failed-recipients)))

1;; Message delivery

;; In addition to the file storing the message and the original recipients, the
;; mailer also maintains a "work" file which stores the expanded recipients.  The purpose
;; of this file is to prevent sending the message to the same recipients more than once
;; if the mailer is booted between the first and last deliveries.

;; The current work file scheme has two deficiencies:
;; 1) If the mailer is booted after mailing lists have been expanded but before the
;;    first delivery has been completed, mailing list expansion will happen a second
;;    time.  This may not be a problem.
;; 2) There is a large window after the delivery of a message when the work file
;;    does not reflect the true message state.  We could fix this by writing a
;;    "likely" new work file before the delivery takes place, but implementing such
;;    a scheme correctly would take a lot of work.

;; A new work file is written as a "temp" file, the old work file is deleted, and the temp
;; file is renamed to be the work file, for the benefit of file systems without version
;; numbers.

;; Work files store information about failed and pending recipients.  The format of
;; a work file varies, depending on the release in which it was written.  All work
;; files written prior to Release 7.1 are said to be in(3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI") :version 01 format.  A work
;; file written in Release 7.1 or a later release contains, as its first line, the
;; keyword3 :version1 and a version number.  The format of3 :version 01 work files was
;; such that the first character of the first line could never be 3:1, so a simple
;; :tyi and :untyi when the stream is first opened will determine with what format
;; of work file we are dealing.
;;
;; After the work file version line, if present, comes the description of any failed
;; recipients.  For a3 :version 01 work file, failed recipients are stored two lines
;; per entry, the first line containing the name of the recipient, and the second
;; line containing the error message.  For a3 :version 11 or later work file, recipients
;; are stored in n lines per entry, with each entry terminated with an or-sign (01), and
;; an additional blank line terminating the set of failed recipients as a whole.
;;
;; Next come entries describing the hosts and their pending recipients.  The first
;; line gives the mail name of the host, and subsequent lines give the names of the
;; recipients pending for that host.  Each entry is terminated by a blank line, and
;; set of per-host entries as a whole is terminated by an additional blank line.

0(defun-in-flavor2 (read-work-file message)0 (file)
  (with-open-file (stream file :direction :input)
    (let ((version 0))
      (let ((first-char nil))
	(setf first-char (send stream :tyi))
	(send stream :untyi first-char)
	(when (char-equal first-char #/:)
	  (let* ((version-line (send stream :line-in))
		 (space-index (string-search-char #/Space version-line))
		 (version-string (string-trim " " (substring version-line (1+ space-index)))))
	    (setf version (parse-number version-string)))))
      (loop for failed-recipient = (send stream :line-in)
	    until (equal failed-recipient "")
	    do (setf-nconc failed-recipients
			   (list (make-recipient :printed-representation failed-recipient)
				 (selector version =
				   (0 (send stream :line-in))
				   (1
				     (let ((error-description (send stream :line-in 1)))
				       (loop for more-error-text = (send stream :line-in)
					     until (and (plusp (string-length more-error-text))
							(char-equal (aref more-error-text 0)
								    #/))
					     do (string-nconc error-description
							      #/Newline
							      more-error-text))
				       error-description))
				   (otherwise (ferror "Unimplemented work file version."))))))
      (loop for line = (send stream :line-in)
	    until (equal line "")
	    do (setf expanded-recipients
		     (nconc expanded-recipients
			    (list (parse-mailer-host line
						     :host-must-exist nil
						     :host-must-have-mail-service nil
						     :must-return-a-mailer-host t)
				  (loop for line = (send stream :line-in)
					until (equal line "")
					collect (make-recipient
						  :printed-representation line)))))))
    (setf work-file-needs-writing nil)
    (setf work-file-write-failed nil)))

(defresource2 failure-string-buffer0 ()
  :constructor (make-array 100. :type 'art-string :fill-pointer 0))

(defun-in-flavor2 (write-work-file message)0 (file)
  (su:log-event :debug "Writing work file")
  (with-open-file (stream file :direction :output)
    (send stream :line-out ":version 1")
    (loop for (recipient reason) in failed-recipients do
	  (send stream :line-out (send recipient :printed-representation))
	  (using-resource (fsb failure-string-buffer)
	    (setf (fill-pointer fsb) 0)
	    (with-output-to-string (string fsb)
	      (format string "~A" reason))
	    (loop for done first 0 then (1+ idx)
		  for idx = (string-search-char #/ fsb done)
		  while idx
		  do (array-push-extend fsb #/.)
		     (loop for i downfrom (1- (fill-pointer fsb)) above idx
			   do (setf (aref fsb i) (aref fsb (1- i))))
		     (setf (aref fsb idx) #/^)
		     (setf (aref fsb (1+ idx)) #/_))
	    (format stream "~A~&~%" fsb)))
    (send stream :tyo #/Newline)
    (loop for (host recipients) on expanded-recipients by 'cddr do
	  (send stream :line-out (string host))
	  (dolist (r recipients) (send stream :line-out (send r :printed-representation)))
	  (send stream :tyo #/Newline)))
  (setf work-file-needs-writing nil)
  (setf work-file-write-failed nil))

(defun-in-flavor2 (create-work-files message)0 ()
  (setf work-file (su:new-name work-file-pathname (send mail-file :name)))
  (setf temp-file (su:new-name temp-file-pathname (send mail-file :name))))

1;;; Try to minimize the number of file system operations.  If a message requires only one
;;; connection to deliver the message, and the message is delivered successfully with no
;;; failed recipients, then no file operations take place.

;;; If delivery is complete, then delete the mail and work files.  Be sure to delete the
;;; mail file first, since if we were to delete the work file and then crash, the message
;;; would be sent all over again.  If no work file exists, then the first delivery for this
;;; message has just been completed.

;;; If we run out of room trying to create the initial work file, or update an existing one,
;;; just log the problem and continue running as best we can.  This means that recipients
;;; will get extra copies if the mailer is rebooted "too quickly", i.e. before the next
;;; retransmission that finds enough disk space to update the work file.  Too many copies
;;; of a message are preferable to none at all.

0(defun-in-flavor2 (update-work-file message)0 ()
  (cond ((delivery-complete)
	 (su:delete-server-file mail-file :errors-only t)
	 (when work-file
	   1;; If last attempt to write work file failed, it's OK if it's not there now.
0	   (su:delete-server-file work-file nil work-file-write-failed)))
	((not work-file)
	 (condition-case (error)
	      (progn
		(create-work-files)
		(write-work-file work-file))
	    (fs:no-more-room
	      (setf work-file-write-failed t)
	      (su:log-event :normal "No room to write initial work file for this message"))))
	(t
	 (condition-case (error)
	      (let ((last-work-file-write-failed work-file-write-failed))
		(write-work-file temp-file)
		1;; If last attempt to write work file failed, it's OK if it's not there now.
0		(su:delete-server-file work-file nil last-work-file-write-failed)
		(su:rename-server-file temp-file work-file))
	    (fs:no-more-room
	      (setf work-file-write-failed t)
	      (su:log-event :normal "No room to write updated work file for this message"))))))

1;; Note the beginning of delivery to a host.

0(defun-in-flavor2 (begin-host-delivery message)0 (hosts note-gateway)
  (su:log-event :normal "Beginning delivery from ~A to ~{~A~^, ~}~@[ via ~A~]" source-host hosts note-gateway))

1;; Note the end of delivery to a host or set of hosts.
0(defun-in-flavor2 (end-host-delivery message)0 (hosts hosts-making-progress notable-gateway)
  (when work-file-needs-writing
    (update-work-file))
  (loop for host in hosts
	for progress = (not (null (memq host hosts-making-progress)))
	for done-with-this-host = (null (get-recipients-for-host host))
	do (when progress
	     (send host :increment-delivery-count))
	   (when (and retransmission
		      done-with-this-host)
	     (send host :delete-message self))
	   (if done-with-this-host
	       (su:log-event :normal   "Completed delivery to ~A~@[ via ~A~]" host notable-gateway)
	       (if progress
		   (su:log-event :normal "Partial delivery to ~A~@[ via ~A~]" host notable-gateway)
		   (su:log-event :normal  "Failed delivery to ~A~@[ via ~A~]" host notable-gateway)))))

1;; Compatibility with prior systems.
0(cli::make-cl-value-link *network-delivery-timeout* 2network-delivery-timeout0)

1;; Collect those hosts which can be reached via this gateway, and include the gateway if
;; there are any recipients for it.  Only collect indirect hosts.  If we can't connect to
;; a direct host, just leave the mail queued, since if we can't reach it, a gateway won't
;; be able reach it either.  (Actually, that isn't completely true.  If part of a network
;; or a network interface were down, we might not be able to reach it, but a gateway
;; could.  We would need knowledge of every piece of hardware on the network to figure
;; this out.) If this function conses too often, cons the list on the stack inside of
;; TRANSMIT-TO-GATEWAY.

0(defun-in-flavor2 (select-delivery-hosts message)0 (gateway)
  (loop for host in (get-hosts)
	when (deliver-via-gateway-p gateway host)
	collect host))

(cl:defparameter 2*headers-for-return-path*
0  '(:redirected-by :resent-sender :resent-from :redistributed-by :sender :from))

(defun-in-flavor2 (parse-message-for-return-path message)0 ()
  (when (get (locf return-path) :return-path-from-header)
    (su:log-event :normal "Parsing the header to find the sender of this message")
1    
    ;; ZWEI:*INTERVAL* must be bound here, instead of using a local variable,
    ;; because something inside of ZWEI:PARSE-HEADERS-INTERVAL references it,
    ;; even though it is given an interval as an argument.
0    (let* ((zwei:*interval* (zwei:create-interval))
	   (interval-stream (zwei:interval-stream zwei:*interval*)))
      (with-input-from-string (input-stream message-text)
	(stream-copy-to-blank-line input-stream interval-stream zwei:line-leader-size))
      (let* ((zwei:*allow-namespace-server-parsing-host* t)
	     (headers (zwei:parse-headers-interval zwei:*interval* nil nil nil
						   *headers-for-return-path*)))
1	;; Call GET on each indicator in sequence rather than
	;; calling GETL since we want to check for each in a
	;; specific order.
0	(setq return-path (first (last (loop for ind in *headers-for-return-path*
					     thereis (get (locf headers) ind))))))
      (setq return-path (if (null return-path)
			    `(:name "Postmaster" :host (:object ,*local-host*))
			  (canonicalize-address-for-recipient return-path)))))
  (setq return-recipient-long (zwei:string-from-header return-path :long))
  (setq return-recipient (make-recipient :address return-path)))



(defun-in-flavor2 (verify-recipients-collecting-errors message)0 (mailer recipients)
  (let ((collected-errors nil))
    (loop for recipient in recipients
	  do (condition-case (error)
		  (send mailer :verify-recipient (send recipient :address))
		((mailer-temporary-error mailer-permanent-error)
		 (let* ((recipient-name (send recipient :name))
			(recipient-host (send recipient :host))
			(host-mail-name (send recipient-host :mail-name)))
		   (su:log-event :debug "Error delivering to host ~A, recipient ~A:~%    ~~A~"
				 host-mail-name recipient-name error))
		 (push (make-recipient-and-status recipient recipient status error) collected-errors))
		(mailer-error
		  (ferror "Unhandled type of mailer error while verifying recipient ~A" recipient)
		  nil)))
    collected-errors))

(defsubst-in-flavor 2(find-recipient-in-error-collection message)0 (recipient error-collection)
  (loop for verification-failure in error-collection
	when (eq recipient (ras-recipient verification-failure))
	  do (return verification-failure)
	finally (return nil)))
      
(defun-in-flavor2 (maybe-add-progressing-host message)0 (mailer-host progressing-mailer-host-list)
  (unless (memq mailer-host (g-l-p progressing-mailer-host-list))
    (array-push-extend progressing-mailer-host-list mailer-host 10)))

(defun-in-flavor 2(fail-and-delete-recipients-that-permanently-failed-verification message)
0		 (recipient-and-status-list progressing-mailer-host-list)
  (loop for ras in recipient-and-status-list
	for status = (ras-status ras)
	for recipient = (ras-recipient ras)
	when (typep status 'mailer-permanent-error)
	  do (fail-recipient recipient status t)
	     (maybe-add-progressing-host (delete-recipient recipient) progressing-mailer-host-list)))

(defun-in-flavor 2(delete-recipients-except-those-that-temporarily-failed-verification message)
0		 (recipients recipient-and-status-list deletion-for-failure progressing-mailer-host-list)
  (loop for recipient in recipients
	for verification-failure = (find-recipient-in-error-collection recipient recipient-and-status-list)
	for verification-error = (and verification-failure
				      (ras-status verification-failure))
	do (cl:etypecase verification-error
	     (mailer-temporary-error)
	     (mailer-permanent-error
	       (fail-recipient recipient verification-error t))
	     (null
	       (when deletion-for-failure
		 (fail-recipient recipient deletion-for-failure t))))
	unless (typep verification-error 'mailer-temporary-error)
	  do (maybe-add-progressing-host (delete-recipient recipient) progressing-mailer-host-list)))

(defun-in-flavor2 (transmit-to-gateway message)0 (gateway)
  (let* ((hosts (select-delivery-hosts gateway))
	 (notable-gateway (when (or (cdr hosts)
				    (neq gateway (car hosts)))
			    gateway))
						1;0(path (find-mail-service gateway))
	 (failed-during-message-setup t)
	 (verification-errors nil)
	 (all-recipients nil)
						1;0(net-error?)
	 )
    (if (null hosts)
	(progn
	  (su:log-event :debug
			"TRANSMIT-TO-GATEWAY found no hosts to deliver to via ~A" gateway)
	  t)
	(with-stack-array (progressing-hosts 20 :type 'art-q-list :fill-pointer 0)
	  1;; Since a given "gateway" or directly-reachable host can have multiple hosts that
0	  1;; can0 1accept mail from it (via MX-records), we loop through them trying to deliver
0	  1;; the0 1message to any one of them that will accept it.  This handles the case where
0	  1;; only0 1a few of the MX hosts advertised is actually responding (a typical case
0	  1;; these days).  We have to be careful not to try ourselves or any host
	  ;; less-desirable than ourselves.
0	  (multiple-value-bind (mx-hosts nil mx-costs)
	      (neti:find-domain-mail-hosts (send gateway :name))
	    1;; First we go through and eliminate duplicates, ourselves, and any hosts that are
0	    1;; our cost or0 1higher.
0	    (let ((mailer-host-list nil))
	      (loop for host in mx-hosts
		    for cost in mx-costs
		    with hosts-at-this-cost = nil
		    with local-host-cost = nil
		    with last-cost = 0
		    when ( cost last-cost)
		      do (setq mailer-host-list (nconc mailer-host-list hosts-at-this-cost))
			 (setq hosts-at-this-cost nil)
			 (setq last-cost cost)
		    if (neti:ns-eq host net:*local-host*)
		      do (setq local-host-cost cost)
			 (setq hosts-at-this-cost nil)
		    else if (and (< cost (or local-host-cost lisp:most-positive-fixnum))
				 (not (cl:member host hosts-at-this-cost :test #'neti:ns-eq))
				 (not (cl:member host mailer-host-list :test #'neti:ns-eq)))
			   do (setq hosts-at-this-cost (nconc hosts-at-this-cost (list host)))
		    finally
		      (setq mailer-host-list (nconc mailer-host-list hosts-at-this-cost))
		      (setq mailer-host-list
			    (loop for good-host in mailer-host-list
				  collect (parse-mailer-host good-host))))
	    (loop for direct-host in mailer-host-list
		  with sent? = nil
		  as path = (find-mail-service direct-host)
		  as net-error? = nil
		  while (not sent?)
		  do
	      1;; We can't deliver to ourseleves or any host lower on the list than
	      ;; ourselves.  This can cause loops.
0	      (if (neti:ns-eq (send direct-host :host) net:*local-host*)
		  (setq sent? t)
		  (loop repeat (loop with addr-count = 0
				     for (net nil) in
					 (send (send direct-host :host) :network-addresses)
				     when (neti:ns-eq (send direct-host :network) net)
				       do (incf addr-count)
				     finally (return addr-count))
			while (not sent?) do
		    (SU:LOG-EVENT
		      :DEBUG
		      "Trying direct-host ~A with gateway ~A" DIRECT-HOST GATEWAY)
		    (begin-host-delivery hosts direct-host)
		    (condition-bind ((fs:login-required 'login-required))
		      (send direct-host :begin-outgoing-conn
			    (send direct-host :network)
			    (neti:protocol-name (neti:service-access-path-protocol path)))
		      (condition-case (error)
			   (with-mailer (mailer path :cache-unavailability nil
						:timeout *network-delivery-timeout*)
			     (when (send mailer :need-return-path)
			       (parse-message-for-return-path))
			     (send mailer :start-message return-path)
			     (setf failed-during-message-setup nil)
			     (loop for host in hosts
				   for recipients = (get-recipients-for-host host)
				   do (setf verification-errors
					    (nconc verification-errors
						   (verify-recipients-collecting-errors
						     mailer recipients)))
				      1;; Exercise the EGC a little.  Oh well.
0				      (setf all-recipients (nconc all-recipients
								  (copylist recipients))))
			     (with-input-from-string (input-stream message-text)
			       (send mailer :receive-message nil input-stream))
			     (send mailer :finish-message))
			 (mailer-temporary-error
			   (when (typep error 'mailer-timeout)
			     1;; Timeouts cause the host to be considered down for this
0			     1;; "pass" ...
0			     (su:log-event
			       :normal
			       "Timed out sending with ~A to ~A: ~A" path hosts error)
			     (setf net-error? t))
			   (fail-and-delete-recipients-that-permanently-failed-verification
			     verification-errors progressing-hosts))
			 (mailer-permanent-error
			   (if failed-during-message-setup
			       1;; Permanent failure during 2:start-message1 -- Everyone
0			       1;; loses.
0			       (dolist (host hosts)
				 (delete-recipients-except-those-that-temporarily-failed-verification
				   (copylist (get-recipients-for-host host)) nil error
				   progressing-hosts))
			       1;; Permanent failure during 2:receive-message 1or
0			       1;; 2:finish-message1 --  Everyone who didn't temporarily
0			       1;; fail verification loses.
			       ;;    Those who did temporarily fail verification aren't
			       ;;    flushed as they weren't involved in the actual
			       ;;    failure.
0			       (delete-recipients-except-those-that-temporarily-failed-verification
				 all-recipients verification-errors error
				 progressing-hosts)))
			 (mailer-error
			   (ferror
			     "Unhandled type of mailer error while delivering message: ~A" error)
			   nil)
			 ((network-error end-of-file)
			  (setf net-error? t)
			  (su:log-event
			    :normal
			    "Network error sending with ~A to ~A: ~A" path hosts error)
			  nil)
			 (:no-error
			   (delete-recipients-except-those-that-temporarily-failed-verification
			     all-recipients verification-errors nil progressing-hosts)
			   (send direct-host :end-outgoing-conn (not net-error?))
			   (setq sent? t)))	1;Exit out of the loop when we have delivered
0		      (send direct-host :end-outgoing-conn (not net-error?))))))))
	  (end-host-delivery hosts (g-l-p progressing-hosts) notable-gateway)))))

1;; Transmit message to direct host.  If host isn't up, punt and try0 1again0 1later.

0(defun-in-flavor2 (transmit-direct message)0 (mailer-host)
  (if (typep mailer-host 'reachable-mailer-host)
      (if (send mailer-host :attempt-delivery?)
	  (condition-case ()
	       (transmit-to-gateway mailer-host)
	     (no-path-to-mail-service-on-host
	       (su:log-event :normal "Not delivered to ~A, host currently lacks services"
			     mailer-host)))
	  (su:log-event :normal "Not delivered to ~A, host is believed down" mailer-host))
      (su:log-event :normal "Not delivered to ~A, host is currently unreachable" mailer-host)))

1;; Transmit a message to a host on a foreign network, and to possibly to other hosts
;; on that network.  Loop through gateways capable of forwarding mail to that network
;; in order of preference.  Gateways are ordered by preference statically by OS type,
;; and then by :ATTEMPT-DELIVERY? preference, which is state UP or UNKNOWN and then PROBE.
;; If all gateways are DOWN, then :ATTEMPT-DELIVERY? returns NIL.

0(defun-in-flavor2 (transmit-indirect message)0 (mailer-host)
  (let ((attempt? nil))
    (loop for gateway = (send mailer-host :attempt-delivery?) do
      (if (null gateway)
	  (return nil)
	  (when (typep mailer-host 'reachable-mailer-host)
	    (setq attempt? t)
	    (when (condition-case ()
		       (transmit-to-gateway gateway)
		     (no-path-to-mail-service-on-host
		       (su:log-event
			 :normal
			 "Not delivered to gateway ~A, host currently lacks services"
			 gateway)
		       nil))
	      (return nil)))))
    (if (not attempt?)
	(su:log-event :normal "Not delivered to ~A, all ~A gateways are believed down"
		      mailer-host (send mailer-host :network)))))

1;; Deliver a message to recipients on the mailer host via the local file system.
;;
;; +++ We need to keep pointers back to the original recipient which produced this pathname
;; +++ to report errors reasonably.

0(defun-in-flavor2 (deliver-local message)0 ()
  (let ((recipients (get-recipients-for-host local-mailer-host))
	(verification-errors nil))
    (when recipients
      (with-stack-list (hosts local-mailer-host)
	(begin-host-delivery hosts nil)
	(with-stack-array (progressing-hosts 10 :type 'art-q-list :fill-pointer 0)
	  (condition-case (error)
	       (with-mailer (mailer (neti:find-path-to-service-on-host :mail-to-user
								       *local-host*)
				    :cache-unavailability nil)
		 (when (send mailer :need-return-path)
		   (parse-message-for-return-path))
		 (send mailer :start-message return-path)
		 (setf verification-errors (verify-recipients-collecting-errors mailer
										recipients))
		 (with-input-from-string (input-stream message-text)
		   (send mailer :receive-message nil input-stream))
		 (send mailer :finish-message))
	     (mailer-temporary-error
	       (fail-and-delete-recipients-that-permanently-failed-verification
		 verification-errors progressing-hosts))
	     (mailer-permanent-error
	       (delete-recipients-except-those-that-temporarily-failed-verification
		 recipients verification-errors error progressing-hosts))
	     (mailer-incomplete-delivery-error
	       1;; First, get rid of some certified losers.
0	       (fail-and-delete-recipients-that-permanently-failed-verification
		 verification-errors progressing-hosts)
	       1;; Now, walk down the per-recipient errors and do what we can to dispose of recipients
0	       1;;
0	       1;; Unfortunately, the "recipients" known to the signallers of this error are not the
0	       1;; same kind of "recipient" as used by the Mailer.  Bad terminology, but anyway.  For
0	       1;; the moment, we need to backtranslate error recipients to mailer recipients.  Do this
0	       1;; by making a table of all the recipients and their translations, and then walk the
0	       1;; table to find a recipient that matches a given translation.
0	       (let ((address-to-recipient-table (cl:make-hash-table :test 'cl:equal)))
		 (loop for recipient in recipients
		       do (setf (cl:gethash (send recipient :address) address-to-recipient-table) recipient))
		 (let ((ras-list (send error :recipient-and-status-list)))
		   (loop for ras in ras-list
			 for address = (ras-recipient ras)
			 for recipient = (cl:gethash address address-to-recipient-table)
			 unless recipient
			   do (ferror "Erring mail delivery address ~A cannot be backtranslated to a recipient" address)
			 for status = (ras-status ras)
			 for progressing-host = (cl:etypecase status
						  (mailer-temporary-error
						    nil)
						  (mailer-permanent-error
						    (unless (find-recipient-in-error-collection recipient verification-errors)
						      (fail-recipient recipient status t)
						      (delete-recipient recipient)))
						  (symbol
						    (cl:ecase status
						      (:completed-OK
							(delete-recipient recipient))
						      (:not-attempted
							nil))))
			 when progressing-host
			   do (maybe-add-progressing-host progressing-host progressing-hosts)))))
	     (mailer-error
	       (ferror "Unhandled type of mailer error while delivering message: ~A" error)
	       nil)
	     (:no-error
	       (delete-recipients-except-those-that-temporarily-failed-verification
		 recipients verification-errors nil progressing-hosts)))
	  (end-host-delivery hosts (g-l-p progressing-hosts) nil))))))

1;; Deliver a message to recipients on foreign hosts via networks.  Make two passes -- one for
;; the direct hosts and one for the indirect hosts.  Those hosts which can only be reached by
;; deferred-delivery networks are skipped over, if this the first time the message has gone
;; through this function.  Slow hosts are skipped over, unless we are in the right process.

;; Later, we can optimize the second loop of this procedure to minimize the number of
;; connections to gateways rather than just picking the first network on the list.  Also, we
;; have to try other networks if all gateways to the "best path" network are down.  Instead of
;; iterating over hosts, we should compute the union of the networks and iterate over them.

0(declare (special 2deferred-delivery-times0))

(defun-in-flavor2 (deliver-foreign message)0 (fast-p)
1  ;; Send to those hosts which can be connected to directly.  For each direct host,
  ;; if the host is a gateway to any of the indirect hosts, also include them in
  ;; the transmission.
0  (loop for host in (get-hosts)
	unless (eq host local-mailer-host)
	  do (if (and (not (typep host 'unresolved-mailer-host))
		      (send host :direct-p)
		      (eq fast-p (send host :fast-p))
		      (or (send host :immediate-p)
			  (eq deferred-delivery-times t)
			  retransmission))
		 (transmit-direct host)))
1  ;; Send to those hosts which cannot be connected to directly.  For each indirect host,
  ;; choose a gateway to which to send the message.  If the gateway can also connect to some
  ;; of the other indirect hosts, also include them in the transmission.  Verify that
  ;; the host is still on EXPANDED-RECIPIENTS since it may have been included in
  ;; an earlier gateway delivery and no longer on the list.  
0  (when fast-p
1    ;; The WHEN FAST-P is a kludge.  The FAST-P parameter should really be passed on
    ;; to TRANSMIT-INDIRECT, and only fast gateways selected.
0    (loop for host in (get-hosts)
	  unless (eq host local-mailer-host)
	    do (if (and (not (typep host 'unresolved-mailer-host))
			(not (send host :direct-p))
			(get (locf expanded-recipients) host))
		   (transmit-indirect host)))))

1;; Process failed recipients by entering new messages into the incoming queue.  This may
;; get called more than once during the lifetime of a message, if retransmission takes
;; place.  Be sure not to defer failed recipient messages until attempts have been made to
;; all recipients since some hosts may be down for a long time.

0(defun-in-flavor2 (print-failed-mail message)0 (output-stream reply-failure)
  (print-header output-stream return-recipient-long "Unable to deliver letter"
		"Postmaster" local-mailer-host)
  (format output-stream "Unable to deliver letter to the following recipient~P:~%"
	  (length failed-recipients))
  (loop for (recipient reason) in failed-recipients do
	(format output-stream "  ~A:~%~4@T~~A~~%"
		(zwei:string-from-header (send recipient :address) :long)
		reason))
  (if reply-failure
      (format output-stream "Unable to find an address to reply to from the header.~%"))
  (format output-stream "~%----- Text of letter follows -----~%")
  (send output-stream :string-out message-text))

(define-option 2failed-mail-reply-mail0 t)
(define-option 2failed-mail-reply-file0 nil)

(defenv2 failed-mail-pathname0 (su:new-pathname static-directory "Failed" "Mail"))

(defvar2 failed-mail-lock0 nil)

1;;; Most likely, it's bogus that we always clear the failed-recipients instance variable
;;; in the message object.  It shouldn't be cleared on temporary delivery errors.  Still,
;;; the present behavior is better than going into the debugger.
0(defun-in-flavor2 (process-failed-recipients message)0 ()
  (when failed-recipients
    (let ((reply-failure nil))
      (su:log-event :normal "Processing ~D failed recipient~:P" (length failed-recipients))
      
1      ;; Parse the message header.  Do this only once.  RETURN-RECIPIENT
      ;; contains the complete return-path information.
0      (parse-message-for-return-path)
      
1      ;; Direct a copy of all failed mail replies to a file if desired.
      ;; Do this first, since it is less likely to blow out.
0      (when failed-mail-reply-file
	(condition-case (error)
	     (si:with-lock-held (failed-mail-lock :whostate "Failed Mail Lock")
	       (append-to-mail-file failed-mail-pathname #'print-failed-mail reply-failure))
	   (error
	     (su:log-event :normal "Reply to ~A not written to ~A: ~A"
			   return-recipient-long failed-mail-pathname error))
	   (:no-error
	     (su:log-event :normal "Reply to ~A written to ~A"
			   return-recipient-long failed-mail-pathname))))
      
1      ;; Queue a reply to be sent to the originator of the message.
0      (when (and failed-mail-reply-mail return-path)
	(condition-case (error)
	     (with-mailer (mailer (neti:find-path-to-service-on-host :store-and-forward-mail
								     net:*local-host*)
				  :cache-unavailability nil)
	       (send mailer :start-message nil)
	       (send mailer :verify-recipient return-path)
	       (with-input-from-string (failed-mail-msg
					 (with-output-to-string (msg)
					   (print-failed-mail msg reply-failure)))
		 (send mailer :receive-message nil failed-mail-msg))
	       (send mailer :finish-message)
	       (su:log-event :normal "Reply to ~A queued." return-recipient-long))
	   (mailer-error (su:log-event :normal "Failed mail message aborted: ~A" error))))
      
1      ;; Finish up
0      (setf failed-recipients nil)
      (update-work-file))))

1;; Queue the message for retransmission to those hosts we weren't able to connect to on the
;; first try and to those hosts which can only be reached via deferred delivery networks.

0(defun-in-flavor2 (queue-for-retransmission message)0 ()
  (unless retransmission
    (loop for host in (get-hosts) do
	  (su:log-event :normal "Queued for ~:[later~;deferred~] delivery to ~A"
		(and (neq deferred-delivery-times t)
		     (send host :direct-p)
		     (not (send host :immediate-p)))
		host)
	  (send host :add-message self))
    (setf retransmission t)))

(declare (special 2enable-delivery-processes enable-slow-delivery-process0))

(defun-in-flavor2 (check-delivery-complete message)0 ()
  (when (delivery-complete)
    (message-deallocate self)
    (throw 'delivery-complete t)))

1;; Delivery to foreign hosts on slow networks.  Return failed mail.  Queue for retransmission
;; and deferred delivery.  The last two operations are performed in whichever process last
;; delivered this message to a host, although it may be better to do this in the foreground
;; process.  If so, we will need to set up another queue going back to the foreground process.

0(defun-in-flavor 2(perform-slow-delivery message)0 ()
  (deliver-foreign nil)
  (queue-for-retransmission)
  (process-failed-recipients)
  (check-delivery-complete)
  (setf state 'retransmit))

1;; Deliver to foreign hosts on fast networks.  If there are any recipients for foreign hosts
;; on slow networks, then send the message to the slow queue.

0(defun-in-flavor2 (perform-foreign-delivery message)0 ()
  (deliver-foreign t)
  (check-delivery-complete)
  (if (and enable-slow-delivery-process
	   (loop for host in (get-hosts)
		 thereis (and (send host :direct-p) (not (send host :fast-p)))))
      (message-enqueue slow-queue self)
      (perform-slow-delivery)))

1;; If EXPANDED-RECIPIENTS and FAILED-RECIPIENTS are NIL, then this is the first time this
;; message has gone through the incoming queue.  Expand mailing lists and sort recipients by
;; host.  Deliver to the local host.  This is always performed in the foreground process.  If
;; there are any recipients for foreign hosts on fast networks, send the message to the
;; outgoing queue.

;; The receipt count should really be incremented for the host this message is from, not the
;; host which forwarded it.  Currently, this count is only kept for direct hosts, and, with
;; the Chaos mail protocol, it is the same number as INCOMING-CONN-COUNT, since there is only
;; one message per connection.  When we parse headers to get the "from" field, change this.

0(defun-in-flavor2 (perform-local-delivery message)0 ()
  (when (and (null expanded-recipients) (null failed-recipients))
    (send source-host :increment-receipt-count)
    (expand-recipients))
  (deliver-local)
  (check-delivery-complete)
  (if (and enable-delivery-processes
	   (loop for host in (get-hosts)
		 thereis (or (not (send host :direct-p)) (send host :fast-p))))
      (message-enqueue outgoing-queue self)
      (perform-foreign-delivery)))

1;; Each of these methods correspond to each of the different types of mailer process, except
;; for the background process, which iterates over tasks instead of messages.

0(defmethod2 (:foreground-process message)0 ()
  (catch 'delivery-complete
    (perform-local-delivery)))

(defmethod2 (:delivery-process message)0 ()
  (catch 'delivery-complete
    (perform-foreign-delivery)))

(defmethod2 (:slow-delivery-process message)0 ()
  (catch 'delivery-complete
    (perform-slow-delivery)))

1;; Message creation

0(defmethod2 (:create message)0 (host)
  (set-time receipt-time)
  (setf uid (su:uid-allocate))
  (setf mail-file (su:new-name mail-file-pathname (su:uid-string uid)))
  (setf source-host (parse-mailer-host host :host-must-have-mail-service nil)))

(defmethod2 (:begin-mail-file message)0 (stream)
  (send stream :line-out (string source-host))
  (if (get (locf return-path) :return-path-from-header)
      (format stream ":RETURN-PATH-FROM-HEADER~%")
      (format stream "~@[<~A>~]~%" (zwei:string-from-header return-path :host)))
  (dolist (recipient original-recipients)
    (send stream :line-out (send recipient :printed-representation)))
  (send stream :tyo #\newline))

1;; Message restoration at start-up time

0(defmethod2 (:restore message)0 (mail work)
  (let (length)
    (setf mail-file (send mail :new-version :newest))
    (setf uid (parse-number (send mail :name)))
1    ;; Restore from mail file
0    (with-open-file (stream mail :direction :input)
      (setf receipt-time (send stream :creation-date))
      (setf source-host (parse-mailer-host (send stream :line-in)
					   :host-must-exist nil
					   :host-must-have-mail-service nil
					   :must-return-a-mailer-host t))
      (setf return-path nil)
      (let ((rpath (send stream :line-in)))
	(cond ((string-search-char #/@ rpath)
	       (setf return-path (zwei:parse-one-address rpath)))
	      ((string-equal rpath ":RETURN-PATH-FROM-HEADER")
	       (setf return-path (copylist '(:return-path-from-header t))))))
      (loop for line = (send stream :line-in)
	    until (equal line "")
	    do (push (make-recipient :printed-representation line) original-recipients))
      (setq length (- (send stream :length) (send stream :read-pointer)))
      (setf message-text (allocate-resource 'message-text length))
      (send stream :string-in nil message-text 0))
1    ;; Restore from work file
0    (when work
      (create-work-files)
      (read-work-file work))
1    ;; Done
0    (su:log-event :normal "~A from ~A, for ~D recipient~:P, ~D characters"
		  self source-host (length original-recipients) length)))

(define-interval2 undeliverable-host-interval0 "1 week")

(defmethod 2(return-mail-for-hosts message)0 (hosts reason)
  (loop for host in (get-hosts)
	as recipients = (get-recipients-for-host host)
	do
    (when (or (eq hosts :all)
	      (memq host hosts))
      (loop for recipient in (copylist recipients)
	    do (fail-recipient recipient reason)
	       (delete-recipient recipient))
      (send host :delete-message self)))
  (process-failed-recipients)
  (when (delivery-complete)
    (message-deallocate self)))

(defmethod2 (:return-mail-for-undeliverable-hosts message)0 (time)
  (when (and receipt-time
	     (> (- time receipt-time) undeliverable-host-interval))
    (return-mail-for-hosts self :all
     (format nil "Host not responding (tried for ~A)"
	     (time:seconds-to-interval-string undeliverable-host-interval)))))


1;; This is the world's interface to the store and forward mailer.
;; If this code is loaded it should be available for use and
;; (invoke-service-on-host :store-and-forward-mail *local-host*) should
;; find it.

;; Receive mail for distribution by the mailer.  Allocate a message instance, update the
;; host table, and enter the message in the incoming mail queue.  Log entry into and exit
;; from this function.  Zmail will close the connection if it receives an error for one of
;; the recipients.  Make this case fast by not opening the mail file until all recipients
;; have been received.  An idea for speeding up mail service is to cache a message and an
;; open file.  When an error occurs, the note should say "during transfer of recipients"
;; or "during transfer of text".  Add a third argument to NOTE-CONNECTION-ERROR, and set
;; it up in this function.  It should be easy to do; I just don't have time now.

;; Closing the mail file has the effect of queueing the message in the file system.  It
;; isn't queued in virtual memory until the connection is closed successfully.  If an
;; error occurs while closing the connection, it will be dequeued in the file system.
;; This behavior is trial for the time being.  Later it may be changed to always queue.
;; Service is speeded by closing the connection before queueing in virtual memory.  This
;; assures that the foreground process won't start up until service is complete.

0(defflavor2 mailer-unknown-host
0	(recipient)
	(mailer-permanent-error)
  :initable-instance-variables)

(defmethod2 (:report mailer-unknown-host)0 (stream)
  (format stream "The host of recipient ~A is not recognized."
	  (zwei:string-from-header recipient :host)))

(defflavor 2mailer-no-more-room
0	()
	(mailer-temporary-error)
  :initable-instance-variables)

(defmethod 2(:report mailer-no-more-room)0 (stream)
  (format stream "The file system, used by the mailer for stable storage, is full.~@
                  This is a temporary error (we hope); please retransmit your message sometime later."))

(defflavor2 mailer-not-running
0	()
	(ferror mailer-temporary-error))

(defflavor 2mailer-internal-error
0	()
	(ferror mailer-protocol-error))

(compile-flavor-methods
  2mailer-unknown-host
0  2mailer-no-more-room
0  2mailer-not-running
0  2mailer-internal-error0)

;;;

(defflavor 2mailer-access-path
0	((message nil))
	(mail-access-path)
  :writable-instance-variables)

1;; ** This binding of LOG-PROCESS-ID is totally bogus because it is completely unrelated to
;; which process is sending this message.  Fix later. **
0(defmethod1 2(su:with-access-path-logging-internal mailer-access-path)0 (continuation)
  (su:with-log-bindings continuation :log *mailer-log*
				     :user-id "Mail-Server"
				     :log-process-id ""
				     :log-herald message))

(defmethod2 (:start-message mailer-access-path)0 (&optional sender)
  (when message
    (error 'mailer-internal-error :format-string "Message already in progress."))
  (start-mailer-message (message-allocate 'started) self sender))

(defmethod2 (:verify-recipient mailer-access-path)0 (recipient)
  (unless message
    (error 'mailer-internal-error :format-string "No message in progress."))
  (verify-mailer-message-recipient message recipient))

(defmethod2 (:receive-message mailer-access-path)0 (trace-line stream &optional body-stream)
  (unless message
    (error 'mailer-internal-error :format-string "No message in progress."))
  (capture-mailer-message message trace-line stream body-stream))

(defmethod2 (:finish-message mailer-access-path)0 ()
  (unless message
    (error 'mailer-internal-error :format-string "No message in progress."))
  (finish-mailer-message message))

(defmethod2 (:close mailer-access-path)0 (&optional abort-p)
  (when message
    (close-mailer-message message :abort abort-p)))

1;; Expand a local recipient.  If the host wasn't local, it was handled at a higher level.

0(defmethod2 (:expand-recipient mailer-access-path)0 (recipient &optional collect-errors)
  (ignore collect-errors)			;Only error is unknown-recipient
  (letf ((su:*log* *mailer-log*)
	 ((su:log-process-id *mailer-log*) ">")
	 ((su:log-herald *mailer-log*) nil))	;Kludge until braindamage flushed
    ;; Needed because SMTP sends the mailer an expand-recipient message
    ;; rather than invoking :EXPAND-MAIL-RECIPIENT service.
    ;; Fixed when messages are no longer mailers.
    (su:log-event :normal "Expanding recipient ~A" (zwei:string-from-header recipient :short))
    (expand-recipient-internal (or (mailbox-lookup (get (locf recipient) :name))
				   (error 'mailer-unknown-recipient :recipient recipient)))))

(defun2 expand-recipient-internal0 (recipient)
  (cond ((listp recipient)
	 (loop for r in recipient
	       nconc (expand-recipient-internal r)))
	(t (ncons (send recipient :address)))))


1;;; This isn't quite the right place for this but it seems to be the only way to get something
;;; from the SMTP server to a mailer without calling internal mailer functions
0(defmethod 2(:probe-one-host mailer-access-path)0 (host-object)
  (let ((mailer-host (parse-mailer-host host-object)))
    (when mailer-host (send mailer-host :force-probe))))


(compile-flavor-methods2 mailer-access-path0)

1;;;

0(declare (special 2*rejection-slip*0))

(define-protocol 2:local-store-and-forward-mail0 (:store-and-forward-mail :local)
  (:invoke (ignore)
    (when *rejection-slip*
      (let ((rejection-message (print-to-stream *rejection-slip* nil)))
	(error 'mailer-not-running :format-string rejection-message)))
    (make-instance 'mailer-access-path)))

(define-protocol2 :local-expand-mail-recipient0 (:expand-mail-recipient :local)
  (:invoke (ignore)
    (when *rejection-slip*
      (let ((rejection-message (print-to-stream *rejection-slip* nil)))
	(error 'mailer-not-running :format-string rejection-message)))
    (make-instance 'mailer-access-path)))

1;;;

0(defmethod 2(start-mailer-message message)0 (mailer-access-path sender)
  (cl:setf (su:log-herald *mailer-log*) self	1;Presumes caller uses 2with-mailer1.
0	   (mailer-access-path-message mailer-access-path) self
	   access-path mailer-access-path
	   state 'started
	   return-path sender)
  (send self :create (or (address-first-hop-raw return-path) *local-host*))
  (send source-host :incoming-conn receipt-time)
  (su:log-event :normal "Beginning receipt from ~A" source-host))

1;;; Validate recipients as they arrive from the network.
0(defmethod2 (verify-mailer-message-recipient message)0 (recipient)
  (setf state 'recipients)
  (flet ((add-a-recipient (recipient host)
	   (push (make-recipient :address recipient
				 :host (parse-mailer-host host
							  :host-must-exist nil
							  :host-must-have-mail-service nil))
		 original-recipients)))
    (multiple-value-bind (recipient host)
	(canonicalize-address-for-recipient recipient)
      (cl:etypecase host
	(cl:null
	  (error 'mailer-unknown-host :recipient recipient))
	(host
	  (when (and (neti:ns-eq host net:*local-host*)
		     (not (mailbox-probe (get (locf recipient) :name))))
	    (error 'mailer-unknown-recipient :recipient recipient))
	  (add-a-recipient recipient host))
	(cl:string
	  (add-a-recipient recipient host))))))

1;;; Capture the message into stable storage.
0(defmethod 2(capture-mailer-message message)0 (trace-line stream &optional body-stream)
  (setf state 'data)
  (condition-case (error)
       (progn
	 (setf message-text (allocate-resource 'message-text))
	 (with-output-to-string (output-stream message-text)
	   (when trace-line
	     (su:log-event :debug "  ~1@{~:}"
			   (substring trace-line 0 (string-reverse-search-char #/;
									       trace-line)))
	     (format output-stream trace-line uid))
	   (copy-message-streams stream body-stream output-stream))
	 (with-open-file (output-stream mail-file :direction :output)
	   (send self :begin-mail-file output-stream)
	   (send output-stream :string-out message-text))
	 (setf state 'captured))
     (fs:no-more-room
       (error 'mailer-no-more-room))
     ((remote-network-error end-of-file)
      (note-connection-error source-host error))))

1;;; Perform cleanup actions not necessary to do before acknowledging capture of message.
0(defmethod2 (finish-mailer-message0 2message)0 ()
  (selectq state
    ((started recipients data)
     (close-mailer-message self :finished t))
    (captured
     (su:log-event :normal "Ending receipt from ~A, ~D recipient~:P"
		   source-host (length original-recipients))
     (send source-host :queue-deferred-messages)
     (message-enqueue incoming-queue self)
     (cl:setf (su:log-herald *mailer-log*) nil
	      (mailer-access-path-message access-path) nil
	      access-path nil))))

1;;; Close the message --
;;;    Normally, the 2finish-mailer-message1 method has already been invoked but there
;;;    are some paths through the Mailer that will invoke this method without using
;;;    2finish-mailer-message1.  In those cases, we'll do the 2finish-mailer-message
1;;;    ourself if we sucessfully received the message; otherwise, we'll just throw
;;;    the message away.
0(defmethod2 (close-mailer-message message)0 (&key abort finished)
  (flet ((close-self ()
	   1;; Make ourself disappear.
0	   (cl:setf (su:log-herald *mailer-log*) nil
		    (mailer-access-path-message access-path) nil
		    access-path nil)
	   (message-deallocate self)))
    (if (or abort finished)
	(selectq state
	  ((started recipients data)
	   1;; Message wasn't successfully received.
0	   (when (null original-recipients)
	     (su:log-event :normal "No ~:[~;valid ~]recipients for message from ~A"
			   (plusp (send access-path :count-of-recipients)) source-host))
	   (when source-host
	     1;; 2source-host1 is null until the 2:create1 method is invoked.
0	     (su:log-event :normal "Aborting receipt from ~A" source-host))
	   (when (and (eq state 'data) (su:probe-path :file mail-file))
	     1;; Delete the mail file if present.
0	     (su:delete-server-file mail-file :errors-only t))
	   (close-self))
	  (captured
	   (if abort
	       (close-self)
	       (finish-mailer-message self))))
	(finish-mailer-message self))))

(compile-flavor-methods 2message0)

1;; Message allocation

0(defresource 2message 0()
  :constructor (make-instance 'message)
  :initial-copies 20.)

(defun2 map-messages0 (function)
  (declare (sys:downward-funarg function))
  (si:map-resource function 'message))

(defun2 message-allocate0 (state)
  (let ((message (allocate-resource 'message)))
    (send message :set-state state)
    message))

(defun2 message-deallocate0 (message &key force)
  (flet ((deallocate ()
	   (send message :reset)
	   (deallocate-resource 'message message)))
    (cond (force
	   (deallocate))
	  ((send message :held)
	   (su:log-event :problem "Attempt to deallocate ~S" message))
	  (t
	   (deallocate)))))

(defun2 message-enqueue0 (queue message)
  (cond ((send message :held)
	 (su:log-event :problem "Attempt to queue ~S" message))
	(t (send message :set-state (send queue :state))
	   (send queue :enqueue message))))

(defun2 message-dequeue0 (queue state)
  (let ((message (send queue :dequeue)))
    (if message (send message :set-state state))
    message))

(defun2 message-restore0 (mail-file work-file)
  (let ((message (message-allocate 'restore)))
    (send message :restore mail-file work-file)
    (message-enqueue incoming-queue message)))

(defun2 uid-equal0 (uid file) (equal uid (send file :name)))

(defprop2 message0 "Message setup" herald)

1;; DIRECTORY-LIST returns a sorted list, so messages get entered into the incoming queue
;; in the right order.

0(defun2 (message cold-boot)0 ()
  (map-messages
    #'(lambda (message allocated? ignore) (send message :cold-boot allocated?)))
  (let ((mail-files (su:directory-list mail-file-pathname))
	(work-files (su:directory-list work-file-pathname))
	(temp-files (su:directory-list temp-file-pathname)))
    (when mail-files
      (su:log-event :normal "Restoring state of ~D message~:P from disk" (length mail-files)))
    1;; Restore all messages from disk.
0    (tv:dolist-noting-progress (mail-file mail-files "Restoring messages from disk")
      (let* ((uid (send mail-file :name))
	     (work-file (first (mem #'uid-equal uid work-files)))
	     (temp-file (first (mem #'uid-equal uid temp-files))))
	1;; Keep track of work files and temp files which have been found.
0	(when work-file
	  (setq work-files (delq work-file work-files)))
	(when temp-file
	  (setq temp-files (delq temp-file temp-files)))
	(cond ((and work-file temp-file)
	       1;; Work file and temp file both exist --
	       ;;    We crashed after writing a new work file but before deleting the old one.
0	       (su:delete-server-file work-file t)
	       (su:rename-server-file temp-file work-file t))
	      (temp-file
	       1;; Temp file only exists --
	       ;;    We crashed after deleting old work file but before renaming the new one.
0	       (setq work-file (su:new-type temp-file "Work"))
	       (su:rename-server-file temp-file work-file t)))
	1;; Restore the message from disk.
0	(condition-case (error)
	     (message-restore mail-file work-file)
	   (error
	     (su:log-event :disaster "Error while restoring message ~A: ~A" uid error)
	     (throw 'foreground-abort error)))))
1    ;; Get rid of remaining work files --
    ;;   If a work file exists by itself, we crashed just after the final delivery;
    ;;   the mail file had already been deleted.
0    (tv:dolist-noting-progress (work-file work-files "Deleting orphan work files.")
      (su:delete-server-file work-file t))
    1;; Rename remaining temp files -- They should never exist by themselves.
0    (tv:dolist-noting-progress (temp-file temp-files "Renaming orphan temp files.")
      (su:log-event :normal "Found ~A without corresponding mail file" temp-file)
      (su:rename-server-file temp-file (su:new-type temp-file "Error") t))))

(defun2 (message warm-boot)0 ()
  (map-messages
    #'(lambda (message allocated? ignore) (send message :warm-boot allocated?))))
