D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; -*- Mode: Lisp; Package: Mailer; Syntax: Zetalisp; Base: 10.; Lowercase: Yes -*-
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>



1;;; Recipients

0(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")make-local-recipient0 (pathname)
  (make-recipient
    :address `(:name ,(string pathname) :file ,pathname :host (:object ,*local-host*))
    :host local-mailer-host))

(defun 2make-foreign-recipient0 (name mailer-host)
  (make-recipient
    :address `(:name ,name :host (:object ,(send mailer-host :host)))
    :host mailer-host))

(defvar 2local-recipient-table0 (make-hash-table :size 500.))
(defvar 2foreign-recipient-table0 (make-equal-hash-table :size 1500.))

(defun 2find-local-recipient0 (pathname)
  (or (send local-recipient-table :get-hash pathname)
      (send local-recipient-table :put-hash pathname (make-local-recipient pathname))))

(defenv 2postmaster-recipient0 (find-local-recipient (su:new-pathname static-directory "Postmaster" "Mail")))

(defun 2clear-recipient-tables0 ()
  (send local-recipient-table :clear-hash)
  (send foreign-recipient-table :clear-hash))

(defun 2clear-recipient-tables-and-postmaster0 ()
  (clear-recipient-tables)
  (setf postmaster-recipient nil))

(add-initialization "Clear recipient tables" '(clear-recipient-tables-and-postmaster) '(:before-cold))

(defun 2find-foreign-recipient0 (name mailer-host)
  (flet ((add-foreign-recipient (&optional adder old-entries)
	   (let ((recipient (make-foreign-recipient name mailer-host)))
	     (send foreign-recipient-table :put-hash name
		   (if adder
		       (funcall adder recipient old-entries)
		       recipient))
	     recipient)))
    (let ((entry (send foreign-recipient-table :get-hash name)))
      (typecase entry
	(:null (add-foreign-recipient))
	(:list (or (loop for r in entry when (eq (send r :host) mailer-host) return r)
		   (add-foreign-recipient #'cons entry)))
	(otherwise
	  (if (eq (send entry :host) mailer-host)
	      entry
	      (add-foreign-recipient #'list entry)))))))

(defun 2find-recipient0 (name mailer-host)
  (if (eq mailer-host local-mailer-host)
      name
      (find-foreign-recipient name mailer-host)))

1;; Mailboxes and mailing lists

;; The entries in the "in core" mailbox table are recipients, strings, and lists.  Recipients
;; are for delivery to local files or to foreign addresses.  Strings are placeholders and only
;; exist during pass 1.  Lists expand into more recipients, placeholders, and lists, but are
;; flattened during pass 2.

;; For normal operation, there shouldn't be more than two mailbox tables.  One will be used by
;; the foreground process for delivery, and another will be used by the background process for
;; processing a new version of the mailboxes file.  Make a third initially for human callers.

0(defresource 2mailbox-table0 ()
  :constructor (make-equal-hash-table :size 2000. :growth-factor 2.0)
  :initializer (send object :clear-hash)
  :initial-copies 3)

1;; MAILBOX-TABLE maps strings to recipient objects or lists of recipient objects.
;;         Always non-NIL after MAILBOX-TABLE-READ has been run, since there must be at
;;         least one entry for Postmaster.
;; MAILBOX-LOCAL-TABLE is a list of strings.  These entries aren't included in any
;;         forwarding tables that get passed around.

0(defvar 2mailbox-table0 nil)
(defvar 2mailbox-local-table0 nil)

(defun 2clear-mailbox-tables0 ()
  (when mailbox-table (send mailbox-table :clear-hash))
  (setq mailbox-local-table nil))

(add-initialization "Clear mailbox tables"2 0'(clear-mailbox-tables) '(:before-cold))

(defun 2print-mailbox-table0 (&optional (slashify-p nil) (stream standard-output))
  (if (not mailbox-table)
      (format stream "~&No mailbox table defined.")
      (mailbox-map
	#'(lambda (key value local? stream slashify-p)
	    (format stream "~&~:[ ~;*~] ~25A = " local? key)
	    (cond ((not (listp value))
		   (send value :print-self stream nil slashify-p))
		  (slashify-p
		   (prin1 value stream))
		  (t (format stream "Mailing list with ~D entries" (length value)))))
	stream slashify-p)))

1;; For now, just log the error and punt processing.  Later, queue mail to Postmaster
;; and to the author of the mailboxes file.

0(defflavor 2mailbox-error0 () (ferror))

(compile-flavor-methods 2mailbox-error0)

(defun 2mailbox-error0 (string &rest args)
  (error 'mailbox-error :format-string string :format-args (copylist args)))

(defsubst 2mailbox-get-raw0 (key)
  (send mailbox-table :get-hash key))

(defsubst 2mailbox-put-raw0 (key value)
  (send mailbox-table :put-hash key value))

(defsubst 2mailbox-get-local0 (key)
  (not (null (member key mailbox-local-table))))

(defun 2mailbox-get0 (key)
  (check-arg-type key :string)
  (values (and mailbox-table (mailbox-get-raw key))
	  (mailbox-get-local key)))

1;; This must return VALUE for the benefit of MAILBOX-TABLE-FLATTEN-ENTRY.

0(defun 2mailbox-put0 (key value &optional local?)
  (check-arg-type key :string)
  (let ((mailbox-entry (mailbox-get-raw key)))
    (if (null mailbox-entry)
	(mailbox-put-raw key value)
	(mailbox-error "The mailbox ~S has already been defined as ~A~@[, for the local host only~]"
		       key mailbox-entry (mailbox-get-local key)))
    (when local?
      (push key mailbox-local-table)))
  value)

1;; Functions passed in to mailbox-map should expect to be called with the following
;; arguments: mailbox name, mailbox, locality, and any args passed to mailbox-map
;; beyond the function itself.
0(defun 2mailbox-map0 (function &rest arguments)
  (send mailbox-table :map-hash
	#'(lambda (key entry function arguments)
	    (lexpr-funcall function key entry (mailbox-get-local key) arguments))
	function arguments))

1;; Host to which to forward mail for unrecognized recipients.  This is only useful if
;; forwarding tables aren't being provided.  MAILBOX-LOOKUP is like MAILBOX-GET except
;; that it checks the forward host if the address isn't found in the mailbox table.

0(defvar 2*host-for-unrecognized-recipients* 0nil)

(defun 2mailbox-probe0 (address)
  (check-arg-type address :string)
  (not (null (or (and mailbox-table (mailbox-get-raw address))
		 *host-for-unrecognized-recipients*))))

(defun 2mailbox-lookup0 (address)
  (check-arg-type address :string)
  (or (and mailbox-table (mailbox-get-raw address))
      (and *host-for-unrecognized-recipients*
	   (find-foreign-recipient address *host-for-unrecognized-recipients*))))


1;; Syntax of the mailboxes file.
;;
;; The way this stuff is implemented, it's as if all of these things were special forms.
;; None of the "arguments" to the "functions" are evaluated before being passed down.
;; 
;; The file is parsed by READ.  There is no difference between strings and symbols.
;; The following functions define the syntax of forms.  Some typical examples:
;;
;; Delivery to a local address.  (Alias)
;;     (3 0 (NIL 0) (NIL :ROMAN NIL) "CPTFONT")(DEFINE Hoffman CWH)
1;;     3(DEFINE Hoffman (MAILBOX CWH))
1;;
;; Delivery to a foreign address.
;;     3(DEFINE CWH CWH@SCRC)
1;;     3(DEFINE CWH (MAILBOX CWH SCRC))
1;;
;; Delivery to a local file.
;;     3(DEFINE GRAPHICS-ARCHIVE ">Graphics>mail-archive.text")
1;;     3(DEFINE GRAPHICS-ARCHIVE (FILE ">Graphics>mail-archive.text"))
1;;
;; Delivery to a mailing list.
;;     3(DEFINE BUG-LISPM (LIST Moon MMcM DLW BSG RSL@Nimbus ">Mail-Archive>Bug-Lispm.text"))
1;;
;; Defining a name which is known on this host only (i.e. if this host writes forwarding tables,
;;   it won't include names defined with DEFINE-LOCAL.
;;     3(DEFINE-LOCAL Postmaster CWH)
1;;     3(DEFINE-LOCAL Bugs (LIST JEK Sned))
1;;
;; Abbreviation for delivery to multiple foreign addresses.
;;     3(DELIVER-TO SPA-NIMBUS Benson MLB RSL RWG Synaps)
1;;
;; Abbreviations for delivery to multiple local addresses.
;;     3(DELIVER-LOCAL Benson MLB RSL RWG Synaps)
1;; This is a crock, since it won't catch users whose directories aren't just under
;; 0  1the root, or those whose under-the-root directories were created after the
;; 0  1Mailer was started.
;;     3(DELIVER-LOCAL-EXCEPT Sys Lmach Project-A Project-B)
1;;
;; Delivery to a hardcopy recipient.
;;     3(DEFINE Barreras ">Mail>Hardcopy>Barreras.mail")
1;;
;; Abbreviation for delivery to local hardcopy recipients.
;;     3(DELIVER-HARDCOPY Barreras Debbi Derry Erin Floyd)
1;;
;; Some loose ends:
;;
;; 0 1Define a host to which unrecognized recipients should be forwarded.
;;     0(FORWARD-TO host)
1;;
;;  Evaluate a bunch of mailbox forms and return the value of the last one.
;;     3(PROGN form1 form2 ... formn)
1;;
;;  Evaluate a single lisp form.  note that the real evaluator is used,
;;    not the teeny mailbox evaluator used for mailbox forms.
;;     3(LISP form)
1;;   

0

1;;; Pass 1 parses the forms and makes entries into the mailbox-table that is
;;;        the binding of 2mailbox-table1.  Entries will be either recipients,
;;;        strings (placeholders), or lists.

;; Don't convert this to #'cl:identity; the extra efficiency is not worth the
;; possible maintenance headaches if someone patches that function.
0(deff 2parse-string0 'cl:identity)

1;; The argument HOST is either a string or a mailer host.

0(defun 2parse-mailbox0 (string)
  (if (not (string-search-set '(#\Space #\Tab #\. #\, #\@ #\%) string))
      string
      (let ((address (zwei:parse-one-address string)))
	(multiple-value-bind (host host-string)
	    (address-first-hop address)
	  (if (or (and (null host) (null host-string))
		  (neti:ns-eq host *local-host*))
	      (cl:getf address :name)
	      (condition-case (error)
		   (find-foreign-recipient (cl:getf address :name)
					   (parse-mailer-host (or host host-string)))
		 ((net:unknown-host-name no-path-to-mail-service-on-host)
		  (mailbox-error "For the address /"~A/": ~A" string error))))))))

(defun 2local-mailer-host0 ()
  #-vlm neti:*local-host*
  #+vlm (si:parse-host (send neti:*local-host* :user-get :embedded-in)))

(defun 2parse-pathname0 (string)
  (let* ((local-mailer-host (local-mailer-host))
	 (pathname (fs:merge-pathnames string (send local-mailer-host :sample-pathname))))
    (if (not (neti:ns-eq (send pathname :host) local-mailer-host))
	(mailbox-error "Cannot deliver mail to the pathname ~A - host is not local" pathname))
    (find-local-recipient pathname)))


1;; There are never any symbols read from the mailing list file, since interning is turned off.

0(defvar 2mailbox-package0 (pkg-find-package "MAILER"))

1;;; Looks like form is either:
;;;    a string (perhaps a parsing function is passed in to handle it), or
;;;    a list (whose first element indicates how it should be handled).
0(defun 2mailbox-eval0 (form &optional parse-function)
  (cond ((stringp form)
	 1;; copy the string
0	 (setq form (string form))
	 (cond (parse-function
		(funcall parse-function form))
	       ((or (string-search-char #/: form)
		    (char-equal (aref form 0) #/>))
		(parse-pathname form))
	       (t (parse-mailbox form))))
	((atom form)
	 (mailbox-error "Unable to parse the atom ~S" form))
	(parse-function
	 (mailbox-error "Attempt to parse the non-atomic form ~S" form))
	((not (stringp (car form)))
	 (mailbox-error "Unknown expression in the car of the form ~S" form))
	(t (let* ((symbol (si:intern1 (si:string-upcase-if-necessary (car form)) mailbox-package))
		  (function (get symbol 'mailbox-eval)))
	     (unless function
	       (mailbox-error "Unable to interpret the form (~A ...)" symbol))
	     (setf (car form) symbol)
	     (funcall function form)))))

(defun 2(file mailbox-eval)0 (form)
  (mailbox-eval (cadr form) #'parse-pathname))

(defun 2(mailbox mailbox-eval)0 (form)
  (if (null (cddr form))
      (mailbox-eval (cadr form) #'parse-mailbox)
      (destructuring-bind (nil name host) form
	(find-recipient (mailbox-eval name #'parse-string)
			(mailbox-eval host #'parse-mailer-host)))))

(defun 2define-internal0 (form local?)
  (destructuring-bind (nil address expansion) form
    (mailbox-put
1      ;; Check that the address part of form is either a string or a symbol
0      (mailbox-eval address #'parse-string)
      (mailbox-eval expansion)
      local?)))

(defun 2(define mailbox-eval)0 (form) (define-internal form nil))

(defun 2(define-local mailbox-eval)0 (form) (define-internal form t))

(defun 2(list mailbox-eval)0 (form)
  (loop for x in (cdr form) collect (mailbox-eval x)))

(defun 2(deliver-to mailbox-eval)0 (form)
  (destructuring-bind (nil host . names) form
    (condition-case (ignore)
	 (setq host (mailbox-eval host #'parse-mailer-host))
       (net:unknown-host-name
	 (mailbox-error "Unknown host ~A found in DELIVER-TO form; no mail will be delivered to that host" host))
       (no-path-to-mail-service-on-host
	 (mailbox-error "Host ~A does not offer mail services; no mail will be delivered to that host" host))
       (:no-error
	 (dolist (name names)
	   (setq name (mailbox-eval name #'parse-string))
	   (if (eq host local-mailer-host)
	       (mailbox-put name (find-local-recipient (get-recipient-mail-file name)))
	       (mailbox-put name (find-foreign-recipient name host))))))))

(defun 2(deliver-local mailbox-eval)0 (form)
  (destructuring-bind (nil . names) form
    (dolist (name names)
      (setq name (mailbox-eval name #'parse-string))
      (mailbox-put name (find-local-recipient (get-recipient-mail-file name))))))

(defenv 2deliver-wild-pathname
0		    (fs:make-pathname :host *local-host* :directory :root
				      :name :wild :type "DIRECTORY"))

(defun 2(deliver-local-except mailbox-eval)0 (form)
  (destructuring-bind (nil . names) form
    (loop for l on names do
	  (setf (car l) (mailbox-eval (car l) #'parse-string)))
    (loop for (entry) in (cdr (fs:directory-list deliver-wild-pathname :fast))
	  for name = (send entry :name) do
	  (if (not (member name names))
	      (mailbox-put name (find-local-recipient (get-recipient-mail-file name)))))))

(defun 2(deliver-hardcopy mailbox-eval)0 (form)
  (destructuring-bind (nil . names) form
    (dolist (name names)
      (setq name (mailbox-eval name #'parse-string))
      (mailbox-put name (make-local-recipient (get-recipient-hardcopy-mail-file name))))))

(defun 2(forward-to mailbox-eval)0 (form)
  (let ((host (cadr form)))
    (condition-case (ignore)
	 (setq *host-for-unrecognized-recipients* (mailbox-eval host #'parse-mailer-host))
       (net:unknown-host-name
	 (mailbox-error "Host ~A is unknown; can't forward unrecognized mail to it" host))
       (no-path-to-mail-service-on-host
	 (mailbox-error "Host ~A does not offer mail services; can't forward unrecognized mail to it" host))
       (:no-error
	 (when (eq *host-for-unrecognized-recipients* local-mailer-host)
	   (mailbox-error "Can't forward to the local host"))))))

(defun 2(progn mailbox-eval)0 (form) (mapc #'mailbox-eval (cdr form)))

1;; This doesn't have anything to do with the mailboxes table, but we don't have a mailer
;; parameters file, so put it here for now.  Write a general purpose mailer parameters
;; facility, so that if a parameter assignment is removed from the file, it gets set back
;; to its default value.

0(defun 2(lisp mailbox-eval)0 (form)
  (mapc #'eval (cdr form)))



1;; Pass 2 flattens the mailbox table.

0(defvar 2seen-entries0)

(defun 2mailbox-table-flatten0 ()
  (su:log-event :normal "Flattening entries in the mailboxes table")
  (using-resource (seen-entries mailbox-table)
    (mailbox-map #'(lambda (key value ignore) (mailbox-table-flatten-entry key value)))))

(defun 2mailbox-table-flatten-entry0 (key value)
  (cond ((eq value t)
	 (mailbox-error "The definition of ~A is circular" key))
	((send seen-entries :get-hash key)
	 value)
	(t (prog1
	     (typecase value
	       (recipient
		 value)
	       (:string
		 (mailbox-put-raw key t)
		 (let ((value (mailbox-table-flatten-placeholder value)))
		   (mailbox-put-raw key value)
		   value))
	       (:list
		(mailbox-put-raw key t)
		(let ((value (mailbox-table-flatten-list value)))
		  (mailbox-put-raw key value)
		  value))
	       (otherwise
		 (ferror "The definition of ~A is the illegal object ~S" key value)))
	     (send seen-entries :put-hash key t)
	     ))))

(defun 2mailbox-table-flatten-placeholder0 (name)
  (let ((value (mailbox-get-raw name)))
    (cond (value
	   (mailbox-table-flatten-entry name value))
	  ((not *host-for-unrecognized-recipients*)
	   (mailbox-error "Unknown mailbox ~A" name))
	  (t (setq value (find-foreign-recipient name *host-for-unrecognized-recipients*))
	     (mailbox-put-raw name value)
	     (mailbox-table-flatten-entry name value)))))

(defun 2mailbox-table-flatten-list0 (list)
  (unless (loop for entry in list always (typep entry 'recipient))
    (setq list
	  (loop for entry in list
		nconc (mailbox-table-flatten-list-entry entry))))
  (loop for l on list
	do (setf (cdr l) (delq (car l) (cdr l))))
  list)

(defun 2mailbox-table-flatten-list-entry0 (entry)
  (typecase entry
    (recipient
      (ncons entry))
    (:string
      (mailbox-table-flatten-list-entry (mailbox-table-flatten-placeholder entry)))
    (:list
     (copylist (mailbox-table-flatten-list entry)))
    (otherwise
      (ferror "The body of a mailing list contains the illegal object ~S" entry))))



1;; Global forwarding table.  This is mostly for the benefit of non-Lispm systems, since
;; mailboxes will eventually be stored in the namespace system.

0(defun 2create-forwarding-table0 ()
  (su:log-event :normal "Creating a forwarding table")
  (let ((table nil))
    (mailbox-map
      #'(lambda (key value local? table-ptr)
	  (unless local?
	    (cond ((or (listp value)
		       (and (typep value 'recipient) (send value :file)))
1		   ;; local recipient or mailing list
0		   (add-to-forwarding-table local-mailer-host key table-ptr))
		  ((typep value 'recipient)
1		   ;; foreign recipient
0		   (let ((name (send value :name))
			 (mailer-host (send value :host)))
		     (unless (equal key name)
		       (let ((network-host (send mailer-host :host)))
			 ;; This should really check the domain rather than the site.
			 (if (and network-host
				  (neti:ns-eq *local-site* (send network-host :site)))
			     (mailbox-error
			       "~A forwards to ~A@~A; it should be defined using DEFINE-LOCAL"
			       key name mailer-host)
			     (setq name (list key name)))))
		     (add-to-forwarding-table mailer-host name table-ptr)))
		  (t
		   (ferror "The mailbox table entry ~A forwards to the illegal object ~S"
			   key value)))))
      (locf table))
1    ;; Major sort by hosts
0    (setq table (sortcar table #'(lambda (a b) (alphalessp (send a :name) (send b :name)))))
1    ;; Minor sort by recipients
0    (loop for entry in table do (setf (cdr entry) (sort (cdr entry) #'alphalessp)))
    table))

(defun 2add-to-forwarding-table0 (host key table-ptr)
  (let ((entry (assq host (car table-ptr))))
    (if entry
	(rplacd entry (cons key (cdr entry)))
	(push (list* host key nil) (car table-ptr)))))

(defvar 2forwarding-table0)
(defvar 2forwarding-table-hosts0 nil)
(defvar 2parsed-forwarding-table-hosts0 nil)

(defun2 clear-parsed-forwarding-table-hosts0 ()
  (setf parsed-forwarding-table-hosts nil))

1;; The two CREATION-DATE specials keep track of the creation dates of the files, only.
;; They do not say anything about the state of the mailbox table in virtual memory.
;; Their values can be:
;;  :UNKNOWN      The mailer has just been loaded or cold booted.
;;  :NOT-FOUND    The file was probed for, but does not exist.
;;  an integer    The file exists, and this is its creation date.

0(defun 2static-directory-pathname0 (name type)
  (su:new-pathname static-directory name type))

(defun 2dynamic-directory-pathname0 (name type)
  (su:new-pathname dynamic-directory name type))

(defun 2mailer-relative-pathname0 (relative-directory-components name type)
  (su:new-pathname 
    (loop with previous-pathname = home-directory
	  for component in relative-directory-components
	  do (setq previous-pathname (su:new-directory previous-pathname component))
	  finally (return previous-pathname)) name type))

(defconstant 2mailboxes-name0 "Mailboxes")
(defconstant 2mailboxes-type0 "text")
(defconstant 2forwarding-name0 "Forwarding")
(defconstant 2forwarding-type0 "text")

(defenv 2local-mailboxes-creation-date0 :unknown)
(defenv 2local-mailboxes-pathname0 (su:new-pathname static-directory mailboxes-name mailboxes-type))
(defenv 2local-mailboxes-truename0 :unknown)
(defenv 2foreign-mailboxes-creation-date0 :unknown)
(defenv2 foreign-mailboxes-pathname0 (su:new-pathname dynamic-directory forwarding-name forwarding-type))
(defenv 2foreign-mailboxes-truename0 :unknown)

(defun 2write-forwarding-table-to-stream0 (mailer-host system-type stream comment-char define-char)
  (let* ((host (send mailer-host :host))
	 (host-mail-name (send host :mail-name)))
    (format stream
	    "~C -*- Mode: Lisp; Syntax: Common-Lisp -*-~@
	     ~C Mailbox forwarding table for ~A.~@
	     ~C Written ~\DATIME\ by ~A running on ~A.~@
	     ~C From ~A created on ~\TIME\.~@
	     ~C This table is automatically generated by a program.  Do not edit it.~%"
	    comment-char
	    comment-char host-mail-name
	    comment-char user-id local-mailer-host
	    comment-char local-mailboxes-pathname local-mailboxes-creation-date
	    comment-char)
    ;; Normalize host
    (loop for (entry-mailer-host . entries) in forwarding-table
	  for entry-host = (send entry-mailer-host :host)
	  for entry-host-mail-name = (send entry-host :mail-name) do
      (unless (or (neti:ns-eq entry-host host)
		  (send entry-host :user-get :experimental-mailer))
	(if (eq system-type :lispm)
	    (progn
	      (send stream :tyo #\return)
	      (loop for entry in entries
		    do
		(when (listp entry)
		  (format stream "(DEFINE ~A ~A@~A)~%"
			  (car entry) (cadr entry) entry-host-mail-name)))
	      (loop with header-printed = nil
		    with total-width = 0
		    for entry in entries
		    with entry-width
		    do
		(unless (listp entry)
		  (unless header-printed
		    (format stream "(DELIVER-TO ~A~% " entry-host-mail-name)
		    (setq header-printed t))
		  (setq entry-width (1+ (string-length entry)))
		  (incf total-width entry-width)
		  (when (> total-width 93.)
		    (send stream :string-out #.(format nil "~% "))
		    (setq total-width entry-width))
		  (send stream :tyo #\space)
		  (if (parse-number entry 0 nil 10. t)
		      (send stream :string-out (string-append "|" entry "|"))
		      (send stream :string-out entry)))
		    finally
		      (if header-printed (send stream :line-out ")"))))
	    (let ((downcase? (eq system-type :unix)))
	      (format stream "~%~C Forwarding entries for ~A.~@
			          ~C *** Automatically generated -- Do not edit ***~%"
		      comment-char entry-host-mail-name comment-char)
	      (if downcase? (setq entry-host-mail-name (string-downcase entry-host-mail-name)))
	      (loop for entry in entries
		    with key
		    with name
		    do
		(if (listp entry)
		    (setq key (car entry) name (cadr entry))
		    (setq key entry name entry))
		(if downcase? (setq key (string-downcase key)))
		(send stream :string-out key)
		(send stream :tyo define-char)
		(send stream :string-out name)
		(send stream :tyo #/@)
		(send stream :string-out entry-host-mail-name)
		(send stream :tyo #\return))))))))



1;;; This protocol is used when the old file-writing technique can't be used, perhaps because
;;; the host to receive the protocol won't allow file writes for security reasons.
0(net:define-server2 :mailer-forwarding-table
0    (:medium :byte-stream
     :error-disposition :notify
     :stream (stream :direction :input :ascii-translation t)
     :no-eof nil
     :reject-unless-trusted t
     :no-close nil
     :process-name "Mailer forwarding table receiver")
   (let* ((pathname (send foreign-mailboxes-pathname :new-pathname :host net:*local-host*)))
     (with-open-file (local-file pathname :direction :output)
       (set-forwarding-table-grc local-file)
       (stream-copy-until-eof stream local-file))))

(chaos:add-contact-name-for-protocol 2:mailer-forwarding-table0)

1;;; If and when we get a TCP port number assigned for this protocol, tell the
;;; network system about it here.

;;; User side of the protocol.
0(net:define-protocol 2:mailer-forwarding-table0 (:mailer-forwarding-table :byte-stream)
  (:desirability 0.9)
  (:invoke (service-access-path)
    (let* ((host (neti:service-access-path-host service-access-path))
	   (system-type (send host :system-type))
	   (handler (get system-type 'write-forwarding-table-using-mailer-forwarding-table-protocol)))
      (unless handler
	(signal 'neti:unable-to-invoke-service :service :byte-stream-mailer-forwarding-table
		:host host
		:service-access-paths `(,service-access-path)))
      (scl:destructuring-bind (&key writer mailer-host)
	 (neti:service-access-path-args service-access-path)
	(su:log-event :normal
		      "Writing a forwarding table to ~A using the MAILER-FORWARDING-TABLE protocol" host)
	(with-open-stream (stream (net:get-connection-for-service service-access-path
								  :ascii-translation t))
	  (funcall handler mailer-host writer stream))
	(send mailer-host :putprop nil 'forwarding-update-needed)))))

1;;; Old way: use the FILE protocol
0(defun2 write-forwarding-table-via-file-protocol0 (mailer-host writer)
  (let* ((host (send mailer-host :host))
	 (system-type (send host :system-type))
	 (handler (get system-type 'write-forwarding-table-using-file-protocol)))
    (unless handler
      (mailbox-error "Writing a forwarding table for a ~A host (~A) ~
		      using the FILE protocol is not supported"
		     system-type host))
    (su:log-event :normal "Writing a forwarding table to ~A using the FILE protocol" host)
    (error-restart (error "Retrying writing a forwarding table to ~A" host)
1      ;; Log out any existing file job, since we don't want to write the file with some
      ;; other user's id or privileges.  It would be nice if we could tell if we really
      ;; logged anything out or not.
0      (send host :login nil)
      (send host :reset-host-user-id)
      (let ((success? nil))
	(condition-case (error)
	     (condition-bind ((fs:login-required 'login-required))
	       (funcall handler mailer-host writer)
	       (setq success? t))
	   (sys:remote-network-error
	     (note-connection-error host error))
	   (fs:file-request-failure
	     (su:log-event :normal "~A" error))
	   (fs:file-operation-failure
	     (setq success? :error)
	     (su:log-event :problem "~A" error)))
	;; Log out the file job we just created.
	(send host :login nil)
	(send host :reset-host-user-id)
	(when success?
	  (send mailer-host :putprop nil 'forwarding-update-needed))
	(when (neq success? t)
	  (su:log-event :normal "Unable to write a forwarding table for ~A; ~
				 will ~@[not ~]try again later"
			host (eq success? :error)))
	success?))))

;;;--- This may be more complex than its needs to be. One could define
;;;--- a protocol on the null medium (the :local medium) that did the
;;;--- file protocol case, then teach all the host's namespace objects
;;;--- for mailers that they `serve' that protocol over whatever medium.
;;;--- However, its not entirely clear that this would work, so what you see
;;;--- is here instead.
(defun 2write-forwarding-tables-to-hosts0 (mailer-host-list)
  (let* ((hosts-succeeded nil)
	 (neti:*invoke-service-automatic-retry* t)
	 (paths
	   (loop for mailer-host in mailer-host-list
		 for host = (send mailer-host :host)
		 as s-a-p-s = (when host
				(net:find-paths-to-service-on-host :mailer-forwarding-table
								   host
								   t	; best suffices
								   nil))	;none is OK
		 when s-a-p-s append s-a-p-s
		 unless s-a-p-s
		   do
		     (when
		       (write-forwarding-table-via-file-protocol
			 mailer-host
			 #'write-forwarding-table-to-stream)
		       (push host hosts-succeeded)))))
1    #|| This doesn't work because futures don't exist for streams.
    ;; setup the arguments to the service access paths by brute force, since we can't pass them
    ;; to net:find-paths-to-service-on-host or net:invoke-multiple-services.
    (loop for s-a-p in paths
	  for mailer-host = (send (neti:service-access-path-host s-a-p) :get 'mailer-host)
	  do (setf (neti:service-access-path-args s-a-p)
		   `(:writer ,#'write-forwarding-table-to-stream :mailer-host ,mailer-host)))
    (net:invoke-multiple-services
      (paths (* 60. 10.) "Write Forwarding Tables Connection")
      (host error)
      (sys:network-error
	(su:log-event 
	  :normal "Failed to write forwarding table via :mailer-forwarding-table.")
	(when
	  (write-forwarding-table-via-file-protocol
	    (send host :get 'mailer-host)
	    #'write-forwarding-table-to-stream)
	  (push host hosts-succeeded)))
      (:no-error (push host hosts-succeeded))) ||#
0    
1    ;; Step by step, inch by inch...
0    (loop for path in paths
	  for host = (neti:service-access-path-host path)
	  for mailer-host = (send host :get 'mailer-host)
	  do
      (condition-case (err)
	   (net:invoke-service-access-path
	     path
	     `(:writer ,#'write-forwarding-table-to-stream :mailer-host ,mailer-host))
	 (sys:network-error
	   (su:log-event 
	     :normal "Error ~A: Failed to write forwarding table via :mailer-forwarding-table." err)
	   (when (write-forwarding-table-via-file-protocol mailer-host #'write-forwarding-table-to-stream)
	     (push host hosts-succeeded)))
	 (:no-error (push host hosts-succeeded))))
    hosts-succeeded))

(defun 2(:lispm write-forwarding-table-using-file-protocol)0 (mailer-host writer)
  (let* ((host (send mailer-host :host))
	 (pathname (send foreign-mailboxes-pathname :new-pathname :host host))
	 (already-exists (su:probe-path :file pathname)))
    (unless already-exists
      (su:log-event :normal "Creating ~A" pathname))
    (with-open-file (stream pathname :direction :output)
      (set-forwarding-table-grc stream)
      (funcall writer mailer-host :lispm stream #/; nil))))

(defun 2set-forwarding-table-grc0 (stream)
  (let ((old-grc (get (send stream :properties) :generation-retention-count)))
    (unless old-grc
      (send stream :change-properties t :generation-retention-count 5))))

(defun 2(:property :lispm write-forwarding-table-using-mailer-forwarding-table-protocol)
0       (mailer-host writer stream)
  (funcall writer mailer-host :lispm stream #/; nil))

(defun 2(:unix write-forwarding-table-using-file-protocol)0 (mailer-host writer)
  (let* ((host (send mailer-host :host))
	 (pathname (fs:parse-pathname "//usr//lib//aliases" host)))
    (with-open-file (input-stream pathname :direction :input)
      (with-open-file (output-stream pathname :direction :output :if-exists :truncate)
	(loop with line = (make-array 200. :type art-string :fill-pointer 0) do
	      (multiple-value-bind (nil nil more-p)
		  (send input-stream :string-line-in t line)
		(when (or (string-equal line "# -*- Mode: Lisp; Syntax: Common-Lisp -*-")
			  (string-equal line "# Mailbox forwarding table" 0 0 26.))
		  (return))
		(send output-stream (if more-p :string-out :line-out) line)))
	(close input-stream)
	(funcall writer mailer-host :unix output-stream #/# #/:)))))

(putprop 2:unix42
0	 (get :unix 'write-forwarding-table-using-file-protocol)
	 'write-forwarding-table-using-file-protocol)

(defun 2(:tenex write-forwarding-table-using-file-protocol)0 (mailer-host writer)
  (let* ((host (send mailer-host :host))
	 (pathname (fs:parse-pathname "<MAIL>FORWARDING.LISTS;0" host)))
    (with-open-file (input-stream pathname :direction :input)
      (with-open-file (output-stream pathname :direction :output)
	(loop for char = (send input-stream :tyi t)
	      do (send output-stream :tyo char)
	      until (char-equal char #\page))
	(send output-stream :tyo #\newline)
	(close input-stream)
	(funcall writer mailer-host :tenex output-stream #/; #/=)))))



1;; Until we have the parameters facility.
;; If some host in this list is bad, just leave it out for now.  We really should log this.

0(defun 2forwarding-table-hosts0 ()
  (unless parsed-forwarding-table-hosts
    (setq parsed-forwarding-table-hosts
	  (loop for mailer-host in forwarding-table-hosts
		for parsed-mailer-host = (parse-mailer-host mailer-host
							    :host-must-have-mail-service nil)
		when parsed-mailer-host collect it)))
  parsed-forwarding-table-hosts)

(defun 2write-forwarding-tables-if-necessary0 ()
  (write-forwarding-tables-to-hosts
    (loop for mailer-host in (forwarding-table-hosts)
	  when (and (neq mailer-host local-mailer-host)
		    (send mailer-host :get 'forwarding-update-needed))
	    collect mailer-host)))

(defun 2login-required0 (error)
  (let ((host (send (send error :access-path) :host)))
    (if (and (send host :get 'host-user-id)
	     (send host :get 'password))
	(send error :proceed :password (send host :get 'host-user-id)
	      1;; Copy the password string since it will get smashed by QFILE.
0	      (string-append (send host :get 'password))))))

1;; Stick this in the init file for File-Server for those hosts which don't allow anonymous0 1logins.

0(defun 2define-host-user-id0 (host host-user-id password)
  (setq host (parse-host host))
  (send host :putprop host-user-id 'host-user-id)
  (send host :putprop password 'password))

(defvar2 forwarding-table-lock0 nil)

(defun 2write-forwarding-tables0 (&optional dont-actually-write-tables)
  (when (and (forwarding-table-hosts)
	     (fixp local-mailboxes-creation-date))
    (let ((lock-snapshot forwarding-table-lock))
      (when lock-snapshot
	(su:log-event :normal
	  "Process ~A is currently writing forwarding tables; waiting for it to finish"
		      (process-name lock-snapshot))))
    (si:with-lock-held (forwarding-table-lock :whostate "Forwarding Table Lock")
      (setq forwarding-table (create-forwarding-table))
      (dolist (mailer-host (forwarding-table-hosts))
	(send mailer-host :putprop t 'forwarding-update-needed))
      (unless dont-actually-write-tables
	(write-forwarding-tables-if-necessary)))))

1;; While reading the mailboxes file, preserve case so that pathnames get created with the
;; proper case.  Don't bother interning, since only the car of each form needs to be interned,
;; and that is done by MAILBOX-EVAL.

0(defvar 2mailbox-table-readtable
0	(loop with rdtbl = (copy-readtable)
	      for c from (char-code #/a) to (char-code #/z)
	      do (setf (si:rdtbl-trans rdtbl c) c)
	      finally (return rdtbl)))

(defun2 mailbox-table-intern-function0 (string) (substring string 0))
(defvar 2mailbox-table-intern0 'mailbox-table-intern-function)

1;; Set both creation dates before processing either file so that if somebody creates a new
;; version while it is being processed, it will be re-read the next time the mailboxes task is
;; invoked.  Also, if an error occurs while processing the file, don't try reading it again
;; and again.

0;;1 This function returns T if a mailboxes file has changed in any way since it was
;; last called.  If this is the first time it is being called, then it returns NIL.  This
;; function is frequently called by the background process, so only make log entries when a
;; value of T is being returned.

0(defun 2mailbox-table-probe0 (pathname creation-date-symbol)
  (let* ((old-creation-date (symeval creation-date-symbol))
	 (properties (condition-case ()
			  (fs:file-properties pathname)
			(fs:file-not-found '(nil :deleted t))))
	 (new-author (get properties :author))
	 (new-creation-date (cond ((get properties :deleted) :not-found)
				  ((get properties :open-for-writing) :open-for-writing)
				  (t (get properties :creation-date))))
	 (truename (if (fixp new-creation-date) (first properties) pathname)))
    (unless (eq new-creation-date :open-for-writing)
      (set creation-date-symbol new-creation-date))
    (cond ((eq old-creation-date :unknown)
	   nil)
	  ((eq new-creation-date :not-found)
	   (when (fixp old-creation-date)
	     (su:log-event :normal "~A has just been deleted" truename)
	     t))
	  ((eq new-creation-date :open-for-writing)
	   nil)
	  ((eq old-creation-date :not-found)
	   (su:log-event :normal "~A was just created at ~\TIME\~@[ by ~A~]"
		 truename new-creation-date new-author)
	   t)
	  ((> new-creation-date old-creation-date)
	   (su:log-event :normal "~A was written at ~\TIME\~@[ by ~A~]"
		 truename new-creation-date new-author)
	   t))))

1;; Record the creation date before processing any of the forms in the file, since the date may
;; change between probe time and read time.

0(defun 2mailbox-table-read-file0 (pathname creation-date-symbol truename-symbol transition? type)
  (if (eq (symeval creation-date-symbol) :not-found)
      (or transition? (su:log-event :normal "~A not found" pathname))
      (with-open-file-case (stream pathname :direction :input)
	(fs:file-not-found
	  (set creation-date-symbol :not-found)
	  (set truename-symbol :not-found)
	  (su:log-event :normal "~A was deleted within the probe / read window" pathname))
	(:no-error
	 (set creation-date-symbol (send stream :creation-date))
	 (let ((truename (send stream :get :truename)))
	   (set truename-symbol truename)
	   (su:log-event :normal "Reading ~A from ~A" type truename))
	 (loop with readtable = mailbox-table-readtable
	       with si:*reader-intern* = mailbox-table-intern
	       for form = (read stream nil)
	       while form do (mailbox-eval form))))))

1;;; Threshold of mailbox table shrinkage in the background --
;;;
;;;    If the number of entries in the mailbox table decreases by more than the amount
;;;    specified by this option, we will refuse to perform any background updates on the
;;;    theory that a major editing mistake has taken place.
;;;
;;;    This option is interpreted as follows:
;;;       2nil1 -- Don't check for shrinkage.
;;;      2 0 < threshold < 11 -- Refuse if more than this percentage of entries would be deleted.
;;;       2threshold  101 -- Refuse if more than this number of entries would be deleted.

0(define-option 2mailbox-deletion-threshold0 100)

1;;; Validate that this option is set properly.
0(defun 2validate-mailbox-deletion-threshold 0()
  (unless (or (null mailbox-deletion-threshold)
	      (and (numberp mailbox-deletion-threshold)
		   (or (< 0 mailbox-deletion-threshold 1)
		       ( mailbox-deletion-threshold 10))))
    (su:log-event :problem "Invalid setting ~S for mailbox-deletion-threshold; ~
			    checking will be disabled"
		  mailbox-deletion-threshold)
    (setf mailbox-deletion-threshold nil)))

(add-option-computation '(validate-mailbox-deletion-threshold))

1;;; No attempt is made to reap old versions of Mailboxes.text.
;;; ++ This should send mail or an interactive message to the file author when an error occurs.

0(defun 2mailbox-table-read0 (force?)
  (keeping-namespace-server
    (let ((local-transition?
	    (mailbox-table-probe local-mailboxes-pathname 'local-mailboxes-creation-date))
	  (foreign-transition?
	    (mailbox-table-probe foreign-mailboxes-pathname 'foreign-mailboxes-creation-date))
	  (new-mailbox-table)
	  (new-mailbox-local-table)
	  (new-host-for-unrecognized-recipients)
	  (error-state))
      (unwind-protect
	  (when (or local-transition? foreign-transition? force?)
	    (setq new-mailbox-table (allocate-resource 'mailbox-table))
	    (condition-case (error)
		 (let ((old-mailbox-count (if mailbox-table
					      (cl:hash-table-count mailbox-table)
					      0))
		       (mailbox-table new-mailbox-table)
		       (mailbox-local-table nil)
		       (*host-for-unrecognized-recipients* nil))
		   (setq error-state local-mailboxes-pathname)
		   (when (eq local-mailboxes-creation-date :not-found)
		     (mailbox-error "This file must exist for proper mailer operation.~@[~@
				     If you really want to run the Mailer without ~
				     any locally defined mailboxes,~@
				     you must create an empty Mailboxes.text file.~]"
				    (neq foreign-mailboxes-creation-date :not-found)))
		   (mailbox-table-read-file local-mailboxes-pathname
					    'local-mailboxes-creation-date
					    'local-mailboxes-truename
					    local-transition?
					    "local mailboxes")
		   (setq error-state foreign-mailboxes-pathname)
		   (when (and (fixp foreign-mailboxes-creation-date)
			      (forwarding-table-hosts)
			      (not (send local-mailer-host :user-get :experimental-mailer)))
		     (mailbox-error "~A found on a forwarding table server"
				    foreign-mailboxes-pathname))
		   (mailbox-table-read-file foreign-mailboxes-pathname
					    'foreign-mailboxes-creation-date
					    'foreign-mailboxes-truename
					    foreign-transition?
					    "foreign mailboxes")
		   (setq error-state "the in-core mailboxes table")
		   (when (fixp local-mailboxes-creation-date)
		     (mailbox-table-flatten))
		   (let ((new-mailbox-count (cl:hash-table-count mailbox-table)))
		     (when (and (not force?)
				(cond ((zerop new-mailbox-count))
				      ((null mailbox-deletion-threshold) nil)
				      ((< 0 mailbox-deletion-threshold 1)
				       (< new-mailbox-count
					  (* (- 1 mailbox-deletion-threshold)
					     old-mailbox-count)))
				      (( mailbox-deletion-threshold 10)
				       (> (- old-mailbox-count new-mailbox-count)
					  mailbox-deletion-threshold))))
		       (mailbox-error "~@?~%Use the :Update Mailbox Table command in ~
					    the Store-and-Forward Mailer frame to ~
					    force this change to the table to take effect"
				      (cond ((zerop new-mailbox-count)
					     "The new mailbox table is empty.")
					    ((< 0 mailbox-deletion-threshold 1)
					     "More than ~D%~* of the entries in the ~
					      mailbox table would have been deleted.")
					    (( mailbox-deletion-threshold 10)
					     "More than ~*~D entries would have been ~
					      deleted from the mailbox table."))
				      (fix (* mailbox-deletion-threshold 100))
				      mailbox-deletion-threshold)))
		   (unless (mailbox-get-raw "Postmaster")
		     (su:log-event :normal
				   "Adding an entry for Postmaster@~A" local-mailer-host)
		     (mailbox-put "Postmaster" postmaster-recipient t))
		   (setq new-mailbox-local-table mailbox-local-table)
		   (when *host-for-unrecognized-recipients*
		     (su:log-event :normal
				   "Forwarding mail for unrecognized recipients to ~A"
				   *host-for-unrecognized-recipients*)
		     (setq new-host-for-unrecognized-recipients *host-for-unrecognized-recipients*))
		   (setq error-state "the forwarding table")
		   (write-forwarding-tables))
	       ((sys:read-error mailbox-error)
		(flet ((valid-mailbox-name (name)
			 (if (eq name :unknown) nil name)))
		  (su:log-event :disaster
				"Error while processing ~A~%~
				 ~@[(local mailbox table is from ~A~:[)~%~;,~%~]~:*~]~
				 ~@[~:*~:[(~; ~]forwarding table is from ~A)~%~]~
				 ~A"
				error-state
				(valid-mailbox-name local-mailboxes-truename)
				(valid-mailbox-name foreign-mailboxes-truename)
				error))
		nil)
	       (:no-error
		 (without-interrupts
		   (swapf mailbox-table new-mailbox-table)
		   (setq mailbox-local-table new-mailbox-local-table)
		   (setq *host-for-unrecognized-recipients* new-host-for-unrecognized-recipients))
		 (write-mailboxes-snapshot)
		 t)))
	(when new-mailbox-table
	  (deallocate-resource 'mailbox-table new-mailbox-table))))))

(defun 2update-mailbox-table0 ()
  (with-log-output-to-user "Update mailbox table"
    (mailbox-table-read t)))

(defun 2update-forwarding-tables0 ()
  (with-log-output-to-user "Update forwarding tables"
    (write-forwarding-tables)))

(defun 2test-mailbox-table0 ()
  (when (update-mailbox-table)
    (format t "~2&")
    (print-mailbox-table nil)
    (format t "~2&")
    (print-mailbox-table t)))



1;;; After successfully reading and "compiling" a new mailboxes table, we dump a binary
;;; image of the table which will be read at cold boot time to allow the Mailer to
;;; get into operation more quickly and even if there are errors in the most recent text
;;; version of the table.

0(defenv 2*mailboxes-snapshot-pathname*0 (su:new-pathname dynamic-directory
						       "Mailboxes" "Snapshot"))

(cl:defparameter 2*mailboxes-snapshot-version*0 1)

(defun 2write-mailboxes-snapshot0 ()
  (with-open-file (snapshot-stream *mailboxes-snapshot-pathname*
				   :direction :output
				   :element-type '(cl:unsigned-byte 16))
    (su:log-event :normal
		  "Saving snapshot of mailboxes table to ~A" (send snapshot-stream :truename))
    (set-mailboxes-snapshot-grc snapshot-stream)
    (let ((success nil))
      (condition-case (error)
	   (setf success (write-mailboxes-snapshot-to-stream snapshot-stream))
	 (fs:file-error
	   (su:log-event :problem
			 "Unable to save snapshot of mailboxes table to ~A:~%~4@T~~A~"
			 (send snapshot-stream :truename) error)))
      (unless success
	(cl:close snapshot-stream :abort t)))))

(defun 2write-mailboxes-snapshot-to-stream0 (snapshot-stream)
  (bin:with-character-dumper (snapshot-dumper snapshot-stream)
    (labels ((dumper-error (error-string &rest error-args)
	       (su:log-event :problem
			     "Unable to save snapshot of mailboxes table to ~A:~%~4@T~~?~"
			     (send snapshot-stream :truename) error-string error-args)
	       (return-from write-mailboxes-snapshot-to-stream nil))
	     (dump (object)
	       (send snapshot-dumper :invoke-object-dumper object)))
      (dump "MTH")
      (dump *mailboxes-snapshot-version*)
      (dump local-mailboxes-creation-date)
      (dump foreign-mailboxes-creation-date)
      (let ((mailer-host-mapping-table (cl:make-hash-table :test 'string-equal)))
	(stack-let* ((host-array-size
		       (+ (cl:hash-table-count *directly-reachable-mailer-host-table*)
			  (cl:hash-table-count *indirectly-reachable-mailer-host-table*)))
		     (host-array (make-array host-array-size))
		     (host-index 0))
	  (labels ((add-host (host)
		     (let ((mailer-host-name (send host :name)))
		       (unless (gethash mailer-host-name mailer-host-mapping-table)
			 (setf (gethash mailer-host-name mailer-host-mapping-table) host-index)
			 (setf (aref host-array host-index) mailer-host-name)
			 (incf host-index))))
		   (add-recipient-host (recipient)
		     (add-host (send recipient :host)))
		   (add-mailbox-entry-hosts (ignore recipients ignore)
		     (if (listp recipients)
			 (dolist (recipient recipients)
			   (add-recipient-host recipient))
			 (add-recipient-host recipients))))
	    (mailbox-map #'add-mailbox-entry-hosts)
	    (when *host-for-unrecognized-recipients*
	      (add-host *host-for-unrecognized-recipients*)))
	  (dump "HOSTS")
	  (dump host-index)
	  (loop for i below host-index
		do (dump (aref host-array i))))
	(labels ((dump-host (mailer-host)
		   (let ((value (gethash (send mailer-host :name) mailer-host-mapping-table)))
		     (if value
			 (dump value)
			 (dumper-error "Mailer host ~A not in table of known hosts"
				       mailer-host))))
		 (dump-recipient (recipient)
		   (let* ((address (send recipient :address))
			  (host (send recipient :host)))
		     (cond ((eq host local-mailer-host)
			    (let ((file (cl:getf address :file)))
			      (unless file
				(dumper-error "Recipient ~A is local but without a pathname"
					      recipient))
			      (dump nil)	1;Local recipient.
0			      (dump (send file :string-for-host))))
			   (t
			    (let ((name (cl:getf address :name)))
			      (unless name
				(dumper-error "Recipient ~A is foreign but without a name"
					      recipient))
			      (dump-host host)
			      (dump name))))))
		 (dump-mailbox-entry (name value local?)
		   (dump "ME")
		   (dump name)
		   (dump local?)
		   (cond ((listp value)
			  (dump (length value))
			  (dolist (recipient value)
			    (dump-recipient recipient)))
			 (t
			  (dump nil)		1;Single recipient entry.
0			  (dump-recipient value)))))
	  (dump "HFUR")
	  (if *host-for-unrecognized-recipients*
	      (dump-host *host-for-unrecognized-recipients*)
	      (dump nil))
	  (dump "ENTRIES")
	  (mailbox-map #'dump-mailbox-entry)
	  (dump "END")
	  (dump nil)				1;Keeps the loader happy?
0	  ))))
  t)

(defun 2set-mailboxes-snapshot-grc0 (stream)
  (let ((old-grc (get (send stream :properties) :generation-retention-count)))
    (unless old-grc
      (condition-case (error)
	   (send stream :change-properties t :generation-retention-count 5)
	 (fs:file-error
	   (su:log-event :normal "Unable to set generation retention count of ~A:~%~4@T~~A~"
			 (send stream :truename) error))))))

(defun 2read-mailboxes-snapshot0 ()
  (cond ((su:probe-path :file *mailboxes-snapshot-pathname*)
	 (with-open-file (snapshot-stream *mailboxes-snapshot-pathname*
					  :direction :input
					  :element-type '(cl:unsigned-byte 16))
	   (su:log-event :normal "Restoring snapshot of mailboxes table from ~A"
			 (send snapshot-stream :truename))
	   (condition-case (error)
		(prog1
		  (read-mailboxes-snapshot-from-stream snapshot-stream)
		  1;; Create a forwarding table if needed and prime the background process.
0		  (condition-case (error)
		       (write-forwarding-tables t)
		     (mailbox-error
		       (su:log-event :problem
				     "Unable to create a forwarding table from ~A:~@
				      ~4@T~~A~~@
				      Fix the problem in Mailboxes.text and then use ~
				      the :Update Mailboxes Table command to create ~
				      the forwarding table."
				     (send snapshot-stream :truename)
				     error))
		     (:no-error
		       (when (forwarding-table-hosts)
			 (su:log-event :normal
				       "Forwarding table will be written in the background"))))
		  )
	      (fs:file-error
		(su:log-event :problem
			      "Unable to restore snapshot of mailboxes table from ~A:~@
			       ~4@T~~A~~@
		               The Mailer will try to read and parse Mailboxes.text~
			       ~@[ and Forwarding.text~] instead"
			      (send snapshot-stream :truename)
			      error
			      (su:probe-path :file foreign-mailboxes-pathname))
		nil))))
	(t
	 (su:log-event :normal
		       "Snapshot of prior mailboxes table not found.~@
		        The Mailer will try to read and parse Mailboxes.text~
			~@[ and Forwarding.text~] instead"
		       (su:probe-path :file foreign-mailboxes-pathname))
	 nil)))

(defun 2read-mailboxes-snapshot-from-stream0 (snapshot-stream)
  (bin:with-character-loader (snapshot-loader snapshot-stream)
    (labels ((loader-error (error-string &rest error-string-args)
	       (su:log-event :problem
			     "Unable to restore snapshot of mailboxes table from ~A:~@
			      ~4@T~~?~~@
		              The Mailer will try to read and parse Mailboxes.text~
			      ~@[ and Forwarding.text~] instead"
			     (send snapshot-stream :truename)
			     error-string error-string-args
			     (su:probe-path :file foreign-mailboxes-pathname))
	       (return-from read-mailboxes-snapshot-from-stream nil))
	     (next-value ()
	       (send snapshot-loader :invoke-object-loader))
	     (verify (expected-value)
	       (let ((next-value (next-value)))
		 (unless (cl:equalp next-value expected-value)
		   (loader-error "Next value in file should be ~S but ~S was read instead"
				 expected-value next-value)))))
      (let ((local-pathname (send (send local-mailer-host :host) :sample-pathname))
	    (new-mailbox-table)
	    (new-mailbox-local-table)
	    (new-local-mailboxes-creation-date)
	    (new-foreign-mailboxes-creation-date)
	    (new-host-for-unrecognized-recipients))
	(verify "MTH")
	(let ((version (next-value)))
	  (unless (and (numberp version)
		       ( version *mailboxes-snapshot-version*))
	    (loader-error "Unsupported mailboxes snapshot version ~S encountered"
			  version)))
	(cl:setf new-local-mailboxes-creation-date (next-value)
		 new-foreign-mailboxes-creation-date (next-value))
	(verify "HOSTS")
	(stack-let* ((hosts-array-size (next-value))
		     (hosts-array (make-array hosts-array-size)))
	  (loop for i below hosts-array-size
		as mailer-host-name = (next-value)
		do (condition-case (error)
			(setf (aref hosts-array i) (parse-mailer-host mailer-host-name))
		      ((net:unknown-host-name no-path-to-mail-service-on-host)
		       (loader-error "Can't convert ~A to its internal representation:~@
				      ~8@T~~A~"
				     mailer-host-name error))))
	  (unwind-protect
	      (labels ((load-host (&optional (null-value local-mailer-host))
			 (let ((host-index (next-value)))
			   (cond ((null host-index)
				  null-value)
				 ((and (numberp host-index)
				       ( 0 host-index (1- hosts-array-size)))
				  (aref hosts-array host-index))
				 (t
				  (loader-error "Expected a host index but ~S was read instead"
						host-index)))))
		       (parse-path (path)
			 (condition-case (error)
			      (cl:pathname path local-pathname)
			    (error
			      (loader-error "Can't convert ~A to its internal representation:~@
					     ~8@T~~A~"
					    path error))))
		       (load-recipient ()
			 (let* ((host (load-host))
				(data (next-value)))
			   (if (eq host local-mailer-host)
			       (find-local-recipient (parse-path data))
			       (find-foreign-recipient data host)))))
		(verify "HFUR")
		(setf new-host-for-unrecognized-recipients (load-host nil))
		(verify "ENTRIES")
		(setf new-mailbox-table (allocate-resource 'mailbox-table))
		(let ((mailbox-table new-mailbox-table)
		      (mailbox-local-table nil)
		      (*host-for-unrecognized-recipients* new-host-for-unrecognized-recipients)
		      )
		  (do ((next-item (next-value) (next-value)))
		      ((cl:equalp next-item "END")
		       (setf new-mailbox-local-table mailbox-local-table))
		    (unless (cl:equalp next-item "ME")
		      (loader-error "Next value in file should be ~S but ~S was read instead"
				    "ME" next-item))
		    (let* ((name (next-value))
			   (local? (next-value))
			   (n-recipients (next-value)))
		      (cond ((null n-recipients)
			     (mailbox-put name (load-recipient) local?))
			    (t
			     (mailbox-put name
					  (loop repeat n-recipients
						collect (load-recipient))
					  local?))))))
		(without-interrupts
		  (swapf mailbox-table new-mailbox-table)
		  (setf mailbox-local-table new-mailbox-local-table)
		  (setf local-mailboxes-creation-date new-local-mailboxes-creation-date)
		  (setf foreign-mailboxes-creation-date new-foreign-mailboxes-creation-date)
		  (setf *host-for-unrecognized-recipients* new-host-for-unrecognized-recipients
			))
		t)
	    (when new-mailbox-table
	      (deallocate-resource 'mailbox-table new-mailbox-table))))))))



(defprop 2mailboxes0 "Mailbox setup" herald)

(defun 2(mailboxes warm-boot)0 ()
  (cond ((null mailbox-table)
	 (funcall #'(:property mailboxes cold-boot)))
	(t
	 (su:log-event :normal "Using existing mailboxes table")
	 (when (forwarding-table-hosts)
	   (su:log-event :normal "Forwarding table host~:[ is~;s are~] ~{~A~^, ~}"
			 (cdr (forwarding-table-hosts)) (forwarding-table-hosts))))))

(defun2 (mailboxes cold-boot)0 ()
  (or (read-mailboxes-snapshot)
      (mailbox-table-read t)
      (throw 'foreground-abort "Error reading mailbox table")))
