D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; -*- Mode: Lisp; Package: Mailer; Base: 10.; Syntax: ZetaLisp; Lowercase: Yes -*-
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

1;;; Mailer-specific host objects

0(defun(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") mailer-host-table-make0 ()
  (cl:make-hash-table :test #'cl:string-equal))

(defun2 mailer-host-table-empty0 (mailer-host-table)
  (zerop (cl:hash-table-count mailer-host-table)))

(defun2 mailer-host-table-search0 (mailer-host-table mailer-host-name)
  (cl:gethash mailer-host-name mailer-host-table))

(defun2 mailer-host-table-insert0 (mailer-host-table mailer-host-name mailer-host)
  (cl:setf (cl:gethash mailer-host-name mailer-host-table) mailer-host))

(defun2 mailer-host-table-delete0 (mailer-host-table mailer-host-name)
  (cl:remhash mailer-host-name mailer-host-table))

(defun2 mailer-host-table-map0 (mailer-host-table function)
  (cl:maphash function mailer-host-table))

(defun2 mailer-host-table-clear0 (mailer-host-table)
  (cl:clrhash mailer-host-table))

(defflavor2 no-path-to-mail-service-on-host
0	(host)
	(neti:network-error)
  (:initable-instance-variables host))

(defmethod 2(:report no-path-to-mail-service-on-host)0 (stream)
  (format stream "No path can be found to any sort of mail service on host ~A" host))

(compile-flavor-methods 2no-path-to-mail-service-on-host0)

1

;;; Extend the system's notion of host (i.e. the usual namespace-system host object built
;;; on top of(3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI") net:host1) to also record information about mail routing, traffic, queues, etc.
;;; These objects have a slot (3host1) that points to the host objects maintained by the namespace
;;; system, and the namespace system objects have a property (3mailer:mailer-host1) that points
;;; back to one of these objects.

;; NETWORK is the "best path" to this host, but may not be the only path.  Currently, we
;; only have the notion of a host being down, and not of a path to a host being down.  If
;; we cannot connect to a host, we should try going via some other route.

;;; A 2basic-mailer-host1 is an object on which we can queue mail, and take notes about
;;; mail it sends us.  Note that just because it can send mail to us, we don't know
;;; that we can send it mail to it.

0(defflavor2 basic-mailer-host
0	((name nil)
	 (messages ())
	 (counters ())
	 (receipt-count	 (make-counter "Messages received"))
	 (incoming-conn-count (make-counter "Incoming connections"))
	 incoming-conn-time)
	()
  :gettable-instance-variables
  (:initable-instance-variables name)
  :abstract-flavor)

(defflavor 2stale-basic-mailer-host
0	(stale-name
	 stale-messages
	 stale-counters
	 stale-receipt-count
	 stale-incoming-conn-count
	 stale-incoming-conn-time)
	())

(defmethod 2(make-instance basic-mailer-host)0 (&rest ignore)
  (push receipt-count counters)
  (push incoming-conn-count counters))

(defwhopper 2(:describe0 2basic-mailer-host)0 ()
  (let ((display-counter-name nil))
    (continue-whopper)))

(defmethod 2(:string-for-printing0 2basic-mailer-host)0 ()
  name)

(defmethod 2(:mail-name0 2basic-mailer-host)0 ()
  name)

(defmethod 2(:increment-receipt-count0 2basic-mailer-host)0  ()
  (send receipt-count :increment))

(defmethod 2(:incoming-conn0 2basic-mailer-host)0 (time)
  (su:log-event :debug "Incoming connection from ~A" self)
  (setf incoming-conn-time time)
  (send incoming-conn-count :increment))

(defmethod2 (:direct-p0 2basic-mailer-host)0 ()
  nil)

(defmethod 2(:fast-p0 2basic-mailer-host)0 ()
  nil)

(defmethod2 (:immediate-p0 2basic-mailer-host)0 ()
  nil)

(defmethod 2(:attempt-delivery?0 2basic-mailer-host) 0()
  nil)

(defmethod 2(:queue-deferred-messages0 2basic-mailer-host)0 (&rest ignore)
  nil)

(defmethod 2(:queue-messages basic-mailer-host)0 (&optional force? note?)
  (ignore force? note?)
  nil)

(defmethod 2(:probe0 2basic-mailer-host)0 (time &optional (as-gateway nil))
  (ignore time as-gateway))

(defmethod 2(:return-mail-for-undeliverable-hosts basic-mailer-host)0 (time)
  (dolist (message messages)
    (send message :return-mail-for-undeliverable-hosts time)))

(defmethod 2(:add-message0 2basic-mailer-host)0 (message)
  (if (memq message messages)
      (su:log-event :problem "Attempt to add ~S to the queue for ~S, ~@
                              but ~S is already queued for ~S"
		    message self message self)
      (setf-nconc messages message)))

(defmethod 2(:delete-message0 2basic-mailer-host)0 (message)
  (if (not (memq message messages))
      (su:log-event :problem "Attempt to delete ~S from the queue for ~S, ~@
                              but ~S is not queued for ~S"
		    message self message self)
      (setf messages (delq message messages))))

1;; Atomically test and set the message state and the message since more than one process may
;; try to requeue messages.  In normal operation, only the background process queues messages
;; from a host, but sometimes it may be done while debugging by means of the :FORCE-PROBE
;; operation.  Make the log entry before queueing the message so that entries in the log don't
;; get out of order.

0(defun-in-flavor 2(host-queue-messages basic-mailer-host)0 (description note?)
  (let ((count 0))
    (loop for message in messages
	  for locative = (send message :locf-state) do
      (if (store-conditional locative 'retransmit current-process)
	  (incf count)))
    (if (> count 0)
	(progn
	  (su:log-event :normal "~A ~D message~:P for ~A" description (length messages) self)
	  (dolist (message messages)
	    (if (eq (send message :state) current-process)
		(message-enqueue incoming-queue message)))
	  count)
	(progn
	  (when note?
	    (su:log-event :normal "No messages queued for ~A" self))
	  nil))))

(defun-in-flavor 2(basic-mailer-host-init basic-mailer-host)0 ()
  (mapc #'(lambda (c) (send c :reset)) counters)
  (when messages
    (su:log-event :normal "Flushing ~D message~:P queued for ~A" (length messages) self)
    (setq messages nil))
  (setq incoming-conn-time nil))

(defmethod 2(:cold-boot0 2basic-mailer-host)0 ()
  (basic-mailer-host-init))

(defmethod 2(:warm-boot0 2basic-mailer-host)0 ()
  (when messages
    (su:log-event :normal "~20A Messages = ~D" self (length messages))))

1;;; Instantiable flavor, to represent hosts where only the name is known
;;; and we can't tell conclusively that there is no such host.
0(defflavor 2unresolved-mailer-host
0	()
	(basic-mailer-host)
  (:required-init-keywords :name))

(defflavor 2stale-unresolved-mailer-host
0	()
	(stale-basic-mailer-host))

(compile-flavor-methods 2stale-unresolved-mailer-host0)

(defmethod2 (:print-self unresolved-mailer-host)0 (stream ignore slashify-p)
  (if slashify-p
      (printing-random-object (self stream)
	(send stream :string-out "Unresolved Mailer Host ")
	(send stream :string-out name))
      (send stream :string-out name))) 

(defmethod 2(:print-summary0 2unresolved-mailer-host)0 (stream)
  (format stream "~43A UNKNOWN   ~3D" self (length messages))
  (send stream :tyo #\return)) 

1;;; These are here to handle instance variable accesses normally handled
;;; by the :gettable-instance-variables of reachable-mailer-host.
0(defmethod2 (:host           unresolved-mailer-host)0 () nil)
(defmethod 2(:mail-service 0  2unresolved-mailer-host)0 () nil)

(defvar 2*unresolvable-mailer-host-table*0 (mailer-host-table-make))
(defvar2 0*2unresolvable-mailer-host-table-lock0* nil)

(define-interval 2unresolvable-host-interval0 "1 week")

(defun 2clear-unresolvable-mailer-host-table0 ()
  (si:with-lock-held (*unresolvable-mailer-host-table-lock* :whostate "Clear Unresolvable Host List")
    (mailer-host-table-clear *unresolvable-mailer-host-table*)))

1;;; Try to resolve an unresolved domain name
0(defmethod2 (:attempt-resolution unresolved-mailer-host)0 (time)
  (declare (values resolved new-mailer-host))
  (multiple-value-prog1
    (labels ((resolution-time-exceeded-p ()
	       (let ((oldest-receipt-time (loop for message in messages
						for receipt-time = (send message :receipt-time)
						when receipt-time
						  minimize receipt-time)))
		 (and oldest-receipt-time 
		      (> (- time oldest-receipt-time) unresolvable-host-interval))))
	     (return-mail (reason &rest reason-args)
	       (let ((reason (cl:apply 'format nil reason reason-args)))
		 (with-stack-list (hosts self)
		   (dolist (message (copylist messages))
		     (return-mail-for-hosts message hosts reason))))
	       1;; Resolved but no replacement host.
0	       (values t nil)))
      (multiple-value-bind (mail-handling-hosts valid)
	  (neti:find-domain-mail-hosts name)
	(cond ((and valid mail-handling-hosts)
	       1;; Definitely know the hosts which accept mail for this domain --
	       ;;    Request our messages for the first host in the list which provides mail
	       ;;    service.  We should really remember all the possible hosts and keep
	       ;;    trying them all but we don't yet have the necessary code or data
	       ;;    structures to do so.
0	       (multiple-value-bind (mailer-host serviceless-hosts)
		   (do ((serviceless-hosts)
			(mailer-host (first mail-handling-hosts) (first remaining-hosts))
			(remaining-hosts (rest1 mail-handling-hosts) (rest1 remaining-hosts)))
		       ((null mailer-host)
			(values nil (nreverse serviceless-hosts)))
		     (condition-case ()
			  (return (parse-mailer-host mailer-host))
			(no-path-to-mail-service-on-host
			  (push mailer-host serviceless-hosts))
			(net:unknown-host-name nil)))
		 (cond (mailer-host
			1;; At least one of the hosts exists and we know how to send it mail.
0			(su:log-event :normal "Resolved domain name ~A; ~
					       queued mail will be delivered to ~A"
				      name (send mailer-host :mail-name))
			(dolist (message (copylist messages))
			  (send self :delete-message message)
			  (multiple-value-bind (message-already-queued-for-new-host-p)
			      (send message :smash-expanded-recipients-mailer-host self
										   mailer-host)
			    (unless message-already-queued-for-new-host-p
			      (send mailer-host :add-message message))))
			(values t mailer-host))
		       (serviceless-hosts
			1;; Some of the hosts exist but we can't get there from here.
0			(return-mail
			  "After contacting the relevant domain servers, the Mailer has been~@
			   informed that messages addressed to the domain named /"~A/"~@
			   should be delivered through the host~P~@[ ~{~A~@{, ~A~}~} or~] ~A.~@
			   However, while the Mailer was to able verify the existence of ~
			   ~:[the host~P~@[ ~{~A~@{, ~A~}~} and~] ~A~;~
			      ~3*~:[this host~;these hosts~]~:*~],~@
			   the Mailer was unable to find a path to deliver the message to ~
			   ~:[this host~;any of these hosts~].~%"
			  name
			  (length mail-handling-hosts)
			  (butlast mail-handling-hosts) (first (last mail-handling-hosts))
			  (equal mail-handling-hosts serviceless-hosts)
			  (length serviceless-hosts)
			  (butlast serviceless-hosts) (first (last serviceless-hosts))
						      (> (length serviceless-hosts) 1)))
		       (t
			1;; None of the hosts exist as far as we can tell.
0			(return-mail
			  "After contacting the relevant domain servers, the Mailer has been~@
			   informed that messages addressed to the domain named /"~A/"~@
			   should be delivered through the host~P~
			   ~@[ ~{~A~@~{, ~A~}~} or~] ~A.~@
			   However, the Mailer was unable to verify the existence of ~
			   ~:[this host~;any of these hosts~]."
			  name
			  (length mail-handling-hosts)
			  (butlast mail-handling-hosts) (first (last mail-handling-hosts))
			  (> (length mail-handling-hosts) 1))))))
	      (mail-handling-hosts
	       1;; Possibly have some hosts which accept mail for this domain --
	       ;;    We really ought to try the hosts in the list but we presently don't have
	       ;;    the appropriate code or data structures in place to permit this.
	       ;;    Therefore, just treat this as if no useful information were returned.
0	       (when (resolution-time-exceeded-p)
		 (return-mail "After trying without success for ~A to contact the relevant~@
			       domain servers needed to resolve the domain name /"~A/",~@
			       the Mailer must presume that there probably is no such domain."
			      (time:seconds-to-interval-string unresolvable-host-interval)
			      name)))
	      (valid
	       1;; Definitely know that no hosts accept mail for this domain.
0	       (return-mail
		 "After contacting the relevant domain servers, the Mailer has been~@
		  informed that there is no domain named /"~A/"."
		 name))
	      (t
	       1;; Unable to determine anything useful at this time --
	       ;;   Give up if we've been trying to resolve this domain name for a long time.
0	       (when (resolution-time-exceeded-p)
		 (return-mail "After trying without success for ~A to contact the relevant~@
			       domain servers needed to resolve the domain name /"~A/",~@
			       the Mailer must presume that there probably is no such domain."
			      (time:seconds-to-interval-string unresolvable-host-interval)
			      name))))))
    (when (null messages)
      1;; No more need for this object.
0      (si:with-lock-held (*unresolvable-mailer-host-table-lock* :whostate "Host Resolution")
	(mailer-host-table-delete *unresolvable-mailer-host-table* name)))))

(defmethod 2(:force-probe unresolved-mailer-host)0 ()
  (cond (messages
	 (su:log-event :normal "Attempting to resolve ~A" self)
	 (multiple-value-bind (resolved new-mailer-host)
	     (send self :attempt-resolution (cl:get-universal-time))
	   (cond ((and resolved new-mailer-host)
		  (send new-mailer-host :force-probe))
		 (resolved
		  1;; Already reported by 2:attempt-resolution1.
0		  )
		 (t
		  (su:log-event :normal "Unable to resolve ~A at this time" self)))))
	(t
	 (su:log-event :normal "No messages queued for ~A" self))))

(defun 2resolve-unresolvable-mailer-hosts0 ()
  (let ((time (cl:get-universal-time)))
    (when (not (mailer-host-table-empty *unresolvable-mailer-host-table*))
      (su:log-event :normal "Attempting to resolve previously unresolvable host names")
      (let ((unresolved-mailer-hosts))
	(si:with-lock-held (*unresolvable-mailer-host-table-lock* :whostate "Host Resolution")
	  (mailer-host-table-map *unresolvable-mailer-host-table*
				 #'(lambda (ignore mailer-host)
				     (push mailer-host unresolved-mailer-hosts))))
	(dolist (mailer-host unresolved-mailer-hosts)
	  (send mailer-host :attempt-resolution time))))))



(defflavor 2reachable-mailer-host
0	((host)
	 (network)
	 (mail-service)
	 (delivery-count (make-counter "Messages delivered")))
	()
  :gettable-instance-variables
  (:writable-instance-variables host         mail-service)
  (:initable-instance-variables host network mail-service)
  (:required-flavors basic-mailer-host)
  :abstract-flavor)

(defflavor 2stale-reachable-mailer-host
0	(stale-host
	 stale-network
	 stale-mail-service
	 stale-delivery-count)
	())

(defmethod 2(make-instance reachable-mailer-host)0 (&rest ignore)
  (when (null name)
    (setf name (send host :mail-name)))
  (push delivery-count counters))

(defmethod 2(:increment-delivery-count0 2reachable-mailer-host)0 ()
  (send delivery-count :increment))

(defmethod 2(:print-summary0 2reachable-mailer-host)0 (stream)
  (format stream "~43A ~9A ~3D" self network (length messages))
  (send delivery-count :print-summary stream)
  (send receipt-count :print-summary stream)
  (send stream :tyo #\return))

(defmethod 2(:print-full0 2reachable-mailer-host)0 (stream)
  (format stream "Host: ~A~%Network: ~A~%Number of queued messages: ~D~%"
	  self network (length messages))
  (send delivery-count :print-full stream)
  (send receipt-count :print-full stream))

(defun2 host-summary-header0 (stream)
  (format stream "~&Host~44TNetwork~56TQ")
  (counter-summary-header stream "D")
  (counter-summary-header stream "R")
  (send stream :tyo #\return))

(defun 2host-summary0 (&optional (stream standard-output))
  (host-summary-header stream)
  (map-hosts :print-summary stream))

(define-forwarded-messages (reachable-mailer-host host)
  2:address :get :plist :property-list :putprop :service :system-type :user-get
  :login :reset-host-user-id :network-services0)



(defvar2 *indirectly-reachable-mailer-host-table*0 (mailer-host-table-make))

1;;; Instantiable flavor, for hosts that we can't reach directly, but instead must
;;; reach by going through a gateway.
0(defflavor 2indirectly-reachable-mailer-host
0	()
	(reachable-mailer-host
	 basic-mailer-host))

(defflavor 2stale-indirectly-reachable-mailer-host
0	()
	(stale-reachable-mailer-host
	 stale-basic-mailer-host))

(compile-flavor-methods 2stale-indirectly-reachable-mailer-host0)

(defmethod 2(:print-self0 2indirectly-reachable-mailer-host)0 (stream ignore slashify-p)
  (if slashify-p
      (printing-random-object (self stream)
	(send stream :string-out "Indirectly Reachable Mailer Host ")
	(send stream :string-out name))
      (send stream :string-out name)))

(defmethod2 (:direct-p0 2indirectly-reachable-mailer-host)0 () nil)

1;;; Transmission

;;; When considering delivery to an indirect host, look at all the gateways to the host's
;;; primary network.  Prefer a gateway which is UP or UNKNOWN to one which is PROBE.  The
;;; NETWORK-MAIL-GATEWAYS list is ordered by preference by OS type, so be sure to choose a host
;;; which is UNKNOWN and near the head of the list over one which is UP and near the tail.

;;; This code used to only consider those gateways which were immediate if any of them were
;;; immediate but that idea was bogus since the time until an immediate gateway comes up is not
;;; necessarily shorter than the time until the next deferred delivery.

0(defmethod 2(:attempt-delivery?0 2indirectly-reachable-mailer-host)0 ()
  (when network
    (let ((up-host nil)
	  (probe-host nil))
      (dolist (gateway (network-mail-gateways network))
	(setq gateway (parse-mailer-host gateway))
	(selectq (send gateway :state)
	  ((up unknown) (setq up-host gateway) (return))
	  (probe (if (not probe-host) (setq probe-host gateway)))))
      (or up-host probe-host))))

1;; Retransmission

;; When probing an indirect host, probe all of the gateways to its primary network.
0(defmethod 2(:probe0 2indirectly-reachable-mailer-host)0 (time &optional (as-gateway nil))
  (if as-gateway
      1;; An indirect host can't ever be a gatway as we can't get there from here...
0      (su:log-event :problem "Attempt to probe ~A as a gateway." self)
   (when (and messages network)
     (dolist (gateway (network-mail-gateways network))
       (send (parse-mailer-host gateway) :probe time t)))))

(defmethod 2(:queue-messages0 2indirectly-reachable-mailer-host)0 (&optional force? note?)
  (ignore force?)				1;No sense in trying if no gateways are usable.
0  (cond ((send self :attempt-delivery?)
	 (host-queue-messages "Requeueing" note?))
	(note?
	 (su:log-event :normal "Not queueing messages for ~A as all gateways appear to be down"
		       self))))

(defmethod 2(:force-probe0 2indirectly-reachable-mailer-host)0 ()
  (cond (messages
	 (dolist (gateway (network-mail-gateways network))
	   (send (parse-mailer-host gateway) :force-probe))
	 (send self :queue-messages t t))
	(t
	 (su:log-event :normal "No messages queued for ~A" self))))



(defvar2 *directly-reachable-mailer-host-table*0 (mailer-host-table-make))

1;; Possible host states:
;;
;;   UNKNOWN -- Host object has just been created.
;;   UP      -- Last connection to this host succeeded,
;;		or we recently received an incoming connection from this host.
;;   DOWN    -- Last connection to this host failed.
;;   GONE    -- Host has been down for a long time, i.e. "permanently down".
;;   PROBE   -- Host has been down for some time, but try connecting to it again
;;		the next time we have a message to deliver.

;; UP-TIME is the time the host last came up.
;; DOWN-TIME is the time the host last went down.
;; (MAX INCOMING-CONN-TIME SUCCESSFUL-OUTGOING-CONN-TIME) is the time the host was
;;   last known to be up
;; FAILED-OUTGOING-CONN-TIME is the time the host was last known to be down.

0(defflavor 2directly-reachable-mailer-host
0	(state
	 immediate-p
	 fast-p
	 up-time
	 down-time
	 failed-outgoing-conn-time
	 successful-outgoing-conn-time
	 probe-count
	 (failed-outgoing-conn-count	 (make-counter "Failed outgoing connections"))
	 (successful-outgoing-conn-count (make-counter "Successful outgoing connections")))
	(reachable-mailer-host
	 basic-mailer-host)
  :gettable-instance-variables
  (:initable-instance-variables immediate-p fast-p)
  (:required-init-keywords :immediate-p :fast-p))

(defflavor 2stale-directly-reachable-mailer-host
0	(stale-state
	 stale-immediate-p
	 stale-fast-p
	 stale-up-time
	 stale-down-time
	 stale-failed-outgoing-conn-time
	 stale-successful-outgoing-conn-time
	 stale-probe-count
	 stale-failed-outgoing-conn-count
	 stale-successful-outgoing-conn-count)
	(stale-reachable-mailer-host
	 stale-basic-mailer-host))

(compile-flavor-methods 2stale-directly-reachable-mailer-host0)

(defmethod 2(:print-self0 2directly-reachable-mailer-host)0 (stream ignore slashify-p)
  (if slashify-p
      (si:printing-random-object (self stream)
	(send stream :string-out "Directly Reachable Mailer Host ")
	(send stream :string-out name))
      (send stream :string-out name)))

(defmethod 2(:direct-p0 2directly-reachable-mailer-host)0 () t)

(defun 2directly-reachable-mailer-host-summary-header0 (stream)
  (format stream "~&Host~44TState~54TProbes~65TTime up~87TTime down~%"))

(defmethod 2(:print-direct-summary0 2directly-reachable-mailer-host)0 (stream)
  (format stream "~43A ~9A ~6D~65T~:[never~;~:*~\TIME\~]~87T~:[never~;~:*~\TIME\~]~%"
	  self state probe-count up-time down-time))

(defun-in-flavor (2directly-reachable-mailer-host-init0 directly-reachable-mailer-host) ()
1  ;; 3immediate-p1 and3 fast-p1 are initialized by keyword arguments to make-instance
0  (multiple-value (state up-time)
    (if (neti:ns-eq host *local-host*)
	(values 'up (time:get-universal-time))
	(values 'unknown nil)))
  (setq down-time nil)
  (setq failed-outgoing-conn-time nil)
  (setq successful-outgoing-conn-time nil)
  (setq probe-count 0))

(defmethod 2(make-instance directly-reachable-mailer-host)0 (&rest ignore)
  (directly-reachable-mailer-host-init)
  (push failed-outgoing-conn-count counters)
  (push successful-outgoing-conn-count counters))

(defmethod 2(:cold-boot0 2directly-reachable-mailer-host)0 ()
  (basic-mailer-host-init)
  (directly-reachable-mailer-host-init))

(defmethod 2(:warm-boot0 2directly-reachable-mailer-host)0 ()
  (when messages
    (su:log-event :normal "~20A Messages = ~D  Probes = ~D  State = ~A"
		  self (length messages) probe-count state)))


1;;; State transitions for direct hosts.  There is no returning to the UNKNOWN state, thus
;;; there is no3 host-state-unknown1 defun-in-flavor.

0(defun-in-flavor2 (state-worry directly-reachable-mailer-host)0 (new-state)
  (su:log-event :debug "Attempt to change the state of ~A from ~A to ~A" self state new-state))

(defun-in-flavor2 (host-state-up directly-reachable-mailer-host)0 ()
  (selectq state
    (up)
    ((unknown down probe gone)
     (selectq state
       ((down probe) (su:log-event :normal "~A has come up" self))
       (gone (su:log-event :debug "~A has come up after being permanently down" self)))
     (set-time up-time)
     (setq probe-count 0)
     (mapc #'(lambda (c) (send c :host-up)) counters)
     (setf state 'up))
    (t (state-worry 'up))))

(defun-in-flavor2 (host-state-down directly-reachable-mailer-host)0 ()
  (selectq state
    (down)
    ((unknown up)
     (set-time down-time)
     (setf state 'down)
     (su:log-event :normal "~A has gone down" self))
    (probe
     (when (null down-time)
       (set-time down-time))
     (setf state 'down)
     (su:log-event :normal "Probe of ~A was unsuccessful" self))
    (t (state-worry 'down))))

(defun-in-flavor 2(host-state-gone directly-reachable-mailer-host)0 ()
  (selectq state
    (down
     (setf state 'gone)
     (su:log-event :normal "~A has gone down permanently" self))
    (t (state-worry 'gone))))

(defun-in-flavor2 (host-state-probe directly-reachable-mailer-host)0 ()
  (selectq state
    ((up probe))
    (down
     (setf state 'probe)
     (incf probe-count)
     (su:log-event :normal "~A being probed, this is try ~D" self probe-count))
    (unknown (setf state 'probe))
    (t (state-worry 'probe))))

(defmethod 2(:incoming-conn0 2directly-reachable-mailer-host :after)0 (time)
  (ignore time)
  (host-state-up))

(defmethod 2(:begin-outgoing-conn0 2directly-reachable-mailer-host)0 (net prot)
  (su:log-event :debug "Outgoing connection to ~A via the ~A network with ~A" self net prot))

(defmethod 2(:end-outgoing-conn0 2directly-reachable-mailer-host)0 (success?)
  (if success?
      (progn (su:log-event :debug "Outgoing connection to ~A succeeded" self)
	     (host-state-up)
	     (set-time successful-outgoing-conn-time)
	     (send successful-outgoing-conn-count :increment))
      (progn (su:log-event :debug "Outgoing connection to ~A failed" self)
	     (host-state-down)
	     (set-time failed-outgoing-conn-time)
	     (send failed-outgoing-conn-count :increment))))


1;;; Transmission

0(defmethod 2(:attempt-delivery?0 2directly-reachable-mailer-host)0 ()
  (memq state '(up unknown probe)))

1;;; +++ This won't handle hosts that are farther than one gateway away.
0(defun 2deliver-via-gateway-p0 (gateway host)
  (or (eq gateway host)
      (and (not (typep host 'unresolved-mailer-host))
	   (not (send host :direct-p))
	   (neti:network-assoc (send host :network) (send gateway :address)))))

1;; Retransmission

0(define-interval 2probe-interval0 "10 minutes")
1;; Declare a host permanently down if it has been down for one month.
0(define-interval 2host-gone-interval0 "4 weeks")

(defmethod 2(:probe0 2directly-reachable-mailer-host)0 (time &optional (as-gateway nil))
  (when (or messages as-gateway)
    (selectq state
      ((up probe))
      (down
       (cond ((> (- time down-time) host-gone-interval)
	      (host-state-gone))
	     ((or (null failed-outgoing-conn-time)
		  (> (- time failed-outgoing-conn-time) (* probe-count probe-interval)))
	      (host-state-probe))))
      (unknown (host-state-probe))
      (t (state-worry 'probe))))) 

(declare 2(special deferred-delivery-times)0)

(defmethod2 (:queue-messages0 2directly-reachable-mailer-host)0 (&optional force? note?)
  (cond ((send self :attempt-delivery?)
	 (cond ((or immediate-p force? (eq deferred-delivery-times t))
		(host-queue-messages "Requeueing" note?))
	       (note?
		(su:log-event :normal "Not queueing messages for ~A ~
				       as doing so now violates deferred delivery constraints"
			      self))))
	(note?
	 (su:log-event :normal "Not queueing messages for ~A as it appears to be down" self))))

(defmethod 2(:queue-deferred-messages0 2directly-reachable-mailer-host)0 (&optional note?)
  (unless immediate-p
    (send self :queue-messages t note?)))

(defmethod 2(:force-probe0 2directly-reachable-mailer-host)0 ()
  (cond (messages
	 (host-state-probe)
	 (send self :queue-messages t t))
	((and (not immediate-p)
	      (find-paths-to-service-on-host :mail-probe host t nil))
	 1;; Ask deferred hosts (i.e, Dialnet, X.25) if they have mail for us.
0	 (su:log-event :normal "No messages queued for ~A; will try a ~S" self :mail-probe)
	 (neti:invoke-service-on-host :mail-probe host self))
	(t
	 (su:log-event :normal "No messages queued for ~A" self))))

(compile-flavor-methods
  2unresolved-mailer-host
0  2indirectly-reachable-mailer-host
0  2directly-reachable-mailer-host0)

(defun 2probe-hosts-internal0 (hosts)
  (flet ((probe-host (host)
	   (send host :force-probe)))
    (with-log-output-to-user "Probe hosts"
      (if (eq hosts :all)
	  (let ((hosts-to-probe))
	    (map-hosts-internal #'(lambda (mailer-host)
				    (when (send mailer-host :messages)
				      (push mailer-host hosts-to-probe))))
	    (if (null hosts-to-probe)
		(dw:command-error "No messages queued for any hosts.")
		(dolist (host hosts-to-probe)
		  (probe-host host))))
	  (dolist (host hosts)
	    (probe-host host))))))

1;;; A relatively easy to use interface for operators who don't like the Mailer frame.
0(defun 2probe-hosts0 (&rest hosts)
  (if (null hosts)
      (probe-hosts-internal :all)
      (let ((mailer-hosts))
	(dolist (host hosts)
	  (condition-case (error)
	       (push (parse-mailer-host host) mailer-hosts)
	     ((net:object-not-found net:unknown-host-name no-path-to-mail-service-on-host)
	      (if (> (length hosts) 1)
		  (cl:cerror "Probe the other hosts." "~~A~" error)
		  (dw:command-error "~~A~" error)))))
	(probe-hosts-internal (nreverse mailer-hosts)))))

1;;; Compatibility with Genera 7.
0(defun 2probe-host0 (host)
  (probe-hosts host))



(defun2 mailer-host-from-network-host0 (network-host host-must-have-mail-service)
  (labels ((make-mailer-host (network-host)
	     (when (or host-must-have-mail-service (send network-host :uninterned-p))
	       (neti:ensure-mail-service-entries network-host))
	     (multiple-value-bind (network mail-service direct-p immediate-p fast-p)
		 (host-best-path network-host)
	       (let* ((mailer-host
			(if direct-p
			    (make-instance 'directly-reachable-mailer-host
					   :host network-host
					   :network network
					   :mail-service mail-service
					   :immediate-p immediate-p
					   :fast-p fast-p)
			    (make-instance 'indirectly-reachable-mailer-host
					   :host network-host
					   :network network
					   :mail-service mail-service)))
		      (mailer-host-name (send mailer-host :name)))
		 (if direct-p
		     (mailer-host-table-insert *directly-reachable-mailer-host-table*
					       mailer-host-name mailer-host)
		     (mailer-host-table-insert *indirectly-reachable-mailer-host-table*
					       mailer-host-name mailer-host))
		 (send network-host :putprop mailer-host 'mailer-host)
		 mailer-host)))
	   (vette-mail-service-for-mailer-host (mailer-host)
	     (when (and host-must-have-mail-service
			(null (send mailer-host :mail-service)))
	       (error 'no-path-to-mail-service-on-host :host (send mailer-host :host)))))
    (or
      1;; Host already associated with a mailer-host.
0      (send network-host :get 'mailer-host)
1      ;; Host with no real name, just a name built from an address, e.g. CHAOS|24606
0      (let ((uninterned-p (send network-host :uninterned-p))
	    (primary-name (send network-host :primary-name)))
	(when uninterned-p
	  (or (mailer-host-table-search   *directly-reachable-mailer-host-table* primary-name)
	      (mailer-host-table-search *indirectly-reachable-mailer-host-table* primary-name)
	      1;; *** This kludge needed because the Chaos mail server was broken
0	      1;; *** to not pass in the network to PARSE-MAILER-HOST.  Fix later.
0	      1;; *** Right now, (parse-mailer-host "chaos|37776") will trigger the
0	      1;; *** notification below.  That should only happen if 37776 actually
0	      1;; *** opens a mail connection to us.
0	      (let ((mailer-host (make-mailer-host network-host)))
		(vette-mail-service-for-mailer-host mailer-host)
		mailer-host))))
      1;; Host with no associated mailer-host, whose :mail-name is already naming
0      1;; a mailer-host.
0      1;;
0      1;; This doesn't handle the case where two hosts with the same mail name have
0      1;; different addresses, which is an error in any case.
0      1;; 
0      1;; This code gets invoked in the present screwy situation: You can have a host
0      1;; in the DIAL namespace and a host in the DOMAIN namespace with the same mail
0      1;; name.  We want to prefer the DOMAIN one over the DIAL one.  PARSE-HOST
0      1;; always prefers DOMAIN over DIAL, so if we're handed a host in the DIAL
0      1;; namespace, and there's a host of the same name in the DOMAIN namespace,
0      1;; when we reparse the mail name, we'll get the one in the DOMAIN namespace,
0      1;; and then smash the mailer host to point to the DOMAIN network host, if
0      1;; it hadn't been pointing to the DOMAIN one already.
0      (let* ((mail-name (send network-host :mail-name))
	     (existing-mailer-host
	       (or (mailer-host-table-search *directly-reachable-mailer-host-table* mail-name)
		   (mailer-host-table-search *indirectly-reachable-mailer-host-table*
					     mail-name))))
	(when existing-mailer-host
	  (let* ((existing-network-host (send existing-mailer-host :host))
		 (network-host-from-mail-name (condition-case ()
						   (parse-host mail-name)
						 ;; handles bogus "[a.b.c.d]-type" mail-names
						 (unknown-host-name existing-network-host))))
	    (when (not (neti:ns-eq network-host-from-mail-name existing-network-host))
	      (su:log-event :normal "Changing Mailer Host ~A to deliver to ~A instead of ~A"
			    existing-mailer-host network-host-from-mail-name
			    existing-network-host)
	      (setf (reachable-mailer-host-host existing-mailer-host) network-host-from-mail-name))
	    (send network-host :putprop existing-mailer-host 'mailer-host)
	    existing-mailer-host)))
      1;; Host completely unconnected to any known mailer host.  Create a new mailer host.
0      (let ((mailer-host (make-mailer-host network-host)))
	(vette-mail-service-for-mailer-host mailer-host)
	mailer-host))))

(defun 2parse-mailer-host0 (host &key (host-must-exist t) (host-must-have-mail-service t)
				    (must-return-a-mailer-host nil))
  (cl:etypecase host
    ((or null basic-mailer-host) host)
    (host
      (mailer-host-from-network-host host host-must-have-mail-service))
    ((or string symbol)
     (when (symbolp host)
       (setf host (string host)))
     (cond ((let ((components (zwei:pdoh-parse-into-components host 0 (string-length host)))
		  (internet (local-network-of-type :internet nil)))
	      (and internet
		   (< 0 (length components) 3)
		   (eq (car (first components)) :domain-literal)
		   (or (= (length components) 1)
		       (and (eq (car (second components)) :subdomain)
			    (string-equal (cdr (second components)) "ARPA")))
		   (multiple-value-bind (network-host ignore)
		       (net:get-host-from-address
			 (send internet :parse-address (cdr (first components))) internet)
		     (when network-host
		       (mailer-host-from-network-host network-host
						      host-must-have-mail-service))))))
	   ((multiple-value-bind (network-host ignore)
		(parse-host host t host-must-exist)
	      (when network-host
		(mailer-host-from-network-host network-host host-must-have-mail-service))))
	   ((multiple-value-bind (network-hosts valid-p)
		(neti:find-domain-mail-hosts host (not host-must-exist))
	      (cond (network-hosts
		     (mailer-host-from-network-host (first network-hosts)
						    host-must-have-mail-service))
		    ((and valid-p (not must-return-a-mailer-host))
		     (error 'net:unknown-host-name :name host :valid-p t))
		    (t nil))))
	   ((or host-must-exist host-must-have-mail-service)
	    (error 'net:unknown-host-name :name host :valid-p nil))
	   (t
	    (si:with-lock-held (*unresolvable-mailer-host-table-lock*
				 :whostate "Host Resolution")
	      (or (mailer-host-table-search *unresolvable-mailer-host-table* host)
		  (let ((mailer-host (make-instance 'unresolved-mailer-host :name host)))
		    (mailer-host-table-insert *unresolvable-mailer-host-table* host
					      mailer-host)
		    mailer-host))))))))

(defun2 find-mail-service0 (mailer-host)
  (flet ((try (mailer-host)
	   (neti:find-path-to-service-on-host (send mailer-host :mail-service)
					      (send mailer-host :host))))
    (if (send mailer-host :mail-service)
	(condition-case ()
	     (return-from find-mail-service (try mailer-host))
	   (neti:host-does-not-support-service 
	     (su:log-event :debug
			   "Couldn't find a path for ~A service to network host ~A ~
			    on behalf of mailer host ~A"
			   (send mailer-host :mail-service)
			   (send mailer-host :host)
			   (send mailer-host :mail-name))))
	(su:log-event :debug
		      "Don't know what mail service to use for network host ~A ~
		       on behalf of mailer host ~A"
		      (send mailer-host :host)
		      (send mailer-host :mail-name)))
    1;; Here if we failed on the first bounce.
0    (let* ((mailer-host-name (send mailer-host :mail-name))
	   (supporting-hosts (neti:find-domain-mail-hosts mailer-host-name)))
      (when supporting-hosts
	(su:log-event :debug
		      "Supporting hosts for ~A are~{ ~A~}" mailer-host-name supporting-hosts))
      (dolist (host supporting-hosts)
	(when (string-equal (send host :mail-name) mailer-host-name)
	  (let ((services (send host :network-services)))
	    (dolist (candidate-service '(:store-and-forward-mail :mail-to-user))
	      (when (assoc candidate-service services)
		(cl:setf (reachable-mailer-host-mail-service mailer-host) candidate-service
			 (reachable-mailer-host-host mailer-host) host)
		(su:log-event :debug
			      "Trying service ~A on supporting host ~A" candidate-service host)
		(block try-next-candidate-service
		  (condition-case ()
		       (return-from find-mail-service
			 (prog1 (try mailer-host)
				(su:log-event :debug
					      "Found path to ~A service on supporting host ~A"
					      candidate-service host)))
		     (neti:host-does-not-support-service
		       (return-from try-next-candidate-service nil)))))))))
      (su:log-event :normal
		    "Can't reach ~A; changing it into an unresolved mailer host." mailer-host)
      (si:with-lock-held (*unresolvable-mailer-host-table-lock*
			   :whostate "Make host unresolved")
	(if (send mailer-host :direct-p)
	    (mailer-host-table-delete *directly-reachable-mailer-host-table* mailer-host-name)
	    (mailer-host-table-delete *indirectly-reachable-mailer-host-table* mailer-host-name
				      ))
	(let ((network-host (send mailer-host :host)))
	  (when network-host
	    (send network-host :remprop 'mailer-host)))
	(change-instance-flavor mailer-host 'unresolved-mailer-host)
	(mailer-host-table-insert *unresolvable-mailer-host-table* mailer-host-name
								   mailer-host))
      (signal 'no-path-to-mail-service-on-host :host mailer-host))))

(define-presentation-type2 mailer-host0 ((&key (resolved-hosts t)
					     (unresolved-hosts t))
				       &key (network-hosts t))
   :abbreviation-for 'basic-mailer-host
   :history t
   :parser ((stream &key initially-display-possibilities)
	    (let ((n-possibilities
		    (+ (cl:hash-table-count *directly-reachable-mailer-host-table*)
		       (cl:hash-table-count *indirectly-reachable-mailer-host-table*)
		       (cl:hash-table-count *unresolvable-mailer-host-table*))))
	      (stack-let ((mailer-hosts (make-array n-possibilities :fill-pointer 0)))
		(when resolved-hosts
		  (mailer-host-table-map *directly-reachable-mailer-host-table*
					 #'(lambda (ignore mailer-host)
					     (array-push mailer-hosts mailer-host)))
		  (mailer-host-table-map *indirectly-reachable-mailer-host-table*
					 #'(lambda (ignore mailer-host)
					     (array-push mailer-hosts mailer-host))))
		(when unresolved-hosts
		  (mailer-host-table-map *unresolvable-mailer-host-table*
					 #'(lambda (ignore mailer-host)
					     (array-push mailer-hosts mailer-host))))
		(let ((original-location (send stream :read-location)))
		  (dw:with-accept-help-if network-hosts
					  ((:subhelp
					     "In addition to the completions shown here, ~
					      you may also enter a network host.~@
					      Be careful typing because, if you mistype one ~
					      of the acceptable completions,~@
					      namespace servers will be consulted to see ~
					      if you typed a network host name~@
					      and this consultation may take quite some time.")
					   )
		    (multiple-value-bind (object success string)
			(dw:complete-from-sequence mailer-hosts stream
						   :name-key #'(lambda (mh) (send mh :name))
						   :allow-any-input network-hosts
						   :initially-display-possibilities
						     initially-display-possibilities)
		      (ignore success)
		      (or object
			  (si:with-parse-ferror ((net:object-not-found
						   net:unknown-host-name
						   no-path-to-mail-service-on-host))
			    (multiple-value-bind (new-mailer-host)
				(parse-mailer-host string :host-must-have-mail-service nil)
			      (dw::presentation-replace-input stream
							      original-location
							      (send new-mailer-host :name))
			      new-mailer-host)))))))))
   :typep ((object)
	   (cl:typecase object
	     ((directly-reachable-mailer-host indirectly-reachable-mailer-host) resolved-hosts)
	     ((unresolved-mailer-host) unresolved-hosts)
	     (otherwise nil)))
   :describer ((stream &key plural-count)
	       (cond ((and resolved-hosts unresolved-hosts)
		      (dw::presentation-string-pluralize "a mailer host" stream plural-count))
		     (resolved-hosts
		      (dw::presentation-string-pluralize "a resolved mailer host"
							 stream plural-count))
		     (unresolved-hosts
		      (dw::presentation-string-pluralize "an unresolved mailer host"
							 stream plural-count)))))

(define-presentation-translator 2net-host-to-mailer-host
0   (net:host mailer-host :tester ((net-host)
				  (send net-host :get 'mailer-host)))
   (net-host)
  (send net-host :get 'mailer-host))
 
(define-presentation-translator 2mailer-host-to-net-host
0   (mailer-host net:host :tester ((mailer-host)
				  (send mailer-host :host)))
   (mailer-host)
  (send mailer-host :host))

(defenv 2local-mailer-host0 (parse-mailer-host *local-host* :host-must-have-mail-service nil))

(defun 2map-hosts-internal0 (function &rest args)
  (labels ((mapped-function (ignore mailer-host)
	     (lexpr-funcall function mailer-host args)))
    (mailer-host-table-map   *directly-reachable-mailer-host-table* #'mapped-function)
    (mailer-host-table-map *indirectly-reachable-mailer-host-table* #'mapped-function)
    (mailer-host-table-map *unresolvable-mailer-host-table* #'mapped-function)))

(defun 2map-hosts0 (operation &rest args)
  (map-hosts-internal #'lexpr-send operation args))

(defun 2map-directly-reachable-mailer-hosts0 (operation &rest args)
  (mailer-host-table-map
    *directly-reachable-mailer-host-table*
    #'(lambda (ignore mailer-host) (lexpr-send mailer-host operation args))))

(defflavor2 stale-mailer-host0 () ())

;; Hafta do this or we blow lunch into the cold load stream when someone
(compile-flavor-methods 2stale-mailer-host0)	; touches a host that went stale.

(defun2 resolve-hosts-internal0 (hosts)
  (flet ((resolve-host (host)
	   (send host :force-probe)))
    (with-log-output-to-user "Resolve hosts"
      (if (eq hosts :all)
	  (let ((hosts-to-resolve))
	    (si:with-lock-held (*unresolvable-mailer-host-table-lock*
				 :whostate "Host Resolution")
	      (mailer-host-table-map *unresolvable-mailer-host-table*
				     #'(lambda (ignore mailer-host)
					 (when (send mailer-host :messages)
					   (push mailer-host hosts-to-resolve)))))
	    (if (null hosts-to-resolve)
		(dw:command-error "No messages queued for unresolved hosts.")
		(dolist (host hosts-to-resolve)
		  (resolve-host host))))
	  (dolist (host hosts)
	    (resolve-host host))))))

1;;; A relatively easy to use interface for operators who don't like the Mailer frame --
;;;    (Actually, this interface is much harder to use as it requires the user type the
;;;     unresolved host names exactly (modulo case) whereas the Mailer command supports
;;;     completion.)
0(defun 2resolve-hosts0 (&rest hosts)
  (if (null hosts)
      (resolve-hosts-internal :all)
      (let ((mailer-hosts))
	(dolist (host hosts)
	  (si:with-lock-held (*unresolvable-mailer-host-table-lock* :whostate "Host Resolution"
								    )
	    (flet ((complain (format-string &rest format-args)
		     (if (> (length hosts) 1)
			 (cl:apply 
			   'cl:cerror "Resolve the other hosts." format-string format-args)
			 (cl:apply 'dw:command-error format-string format-args))))
	      (cl:typecase host
		(unresolved-mailer-host
		  (push host mailer-hosts))
		((reachable-mailer-host)
		 (complain "~A has already been resolved." host))
		((or string symbol)
		 (let ((mailer-host (mailer-host-table-search *unresolvable-mailer-host-table*
							      (string host))))
		   (if mailer-host
		       (push mailer-host mailer-hosts)
		       (complain "~A isn't the name of an unresolved host." host))))))))
	(resolve-hosts-internal (nreverse mailer-hosts)))))

(defun2 destroy-all-hosts0 ()
  (map-messages
    #'(lambda (message allocated? ignore)
	(declare (sys:downward-function))
	(when (and allocated?
		   (send message :hosts))
	  (cl:cerror "Destroy all mailer hosts anyway."
		     "Some mailer hosts are still referenced by active messages.~@
		      Destroying all mailer hosts will lead to unpredictable future behavior.")
	  )))
  (send net:*local-host* :remprop 'mailer-host)
  (setq local-mailer-host nil)
  (flet ((destroy-mailer-host (mailer-host)
	   ;; Don't destroy a mailer host that's already been destroyed...
	   (unless (typep mailer-host 'stale-basic-mailer-host)
	     (let ((underlying-host (send-if-handles mailer-host :host)))
	       (when underlying-host
		 (send underlying-host :remprop 'mailer-host)))
	     (change-instance-flavor
	       mailer-host
	       (cl:etypecase mailer-host
		 (unresolved-mailer-host 'stale-unresolved-mailer-host)
		 (indirectly-reachable-mailer-host 'stale-indirectly-reachable-mailer-host)
		 (directly-reachable-mailer-host 'stale-directly-reachable-mailer-host))))))
    (map-hosts-internal #'destroy-mailer-host))
  (mailer-host-table-clear   *directly-reachable-mailer-host-table*)
  (mailer-host-table-clear *indirectly-reachable-mailer-host-table*)
  (clear-unresolvable-mailer-host-table)
  (setf local-mailer-host (parse-mailer-host *local-host* :host-must-have-mail-service nil))
  (send probe-recipient-cache :clear-hash)
  (clear-recipient-tables)
  (clear-parsed-forwarding-table-hosts)
  (clear-mailbox-tables))

(defun 2directly-reachable-mailer-host-summary0 (&optional (stream standard-output))
  (directly-reachable-mailer-host-summary-header stream)
  (map-directly-reachable-mailer-hosts :print-direct-summary stream))

(defun 2summary0 (&optional (stream standard-output))
  (send-if-handles stream :clear-window)
  (process-summary stream)
  (send stream :tyo #\newline)
  (queue-summary stream)
  (send stream :tyo #\newline)
  (host-summary stream)
  (send stream :tyo #\newline)
  (directly-reachable-mailer-host-summary stream))

(defprop2 host0 "Host setup" herald)

(defun 2(host cold-boot)0 ()
  (clear-unresolvable-mailer-host-table)
  (map-hosts :cold-boot))

(defun 2(host warm-boot)0 ()
  (map-hosts :warm-boot))

